--- Emails for Year 2006 ---

=== Thread: . ===

From: "Joan Johnson" <GavinCompton () ukr ! net>
To: linux-sparse
Subject: RE:.
Date: Tue, 30 May 2006 09:18:03 +0000
Message-ID: <099326024.8488102404 () localhost>
--------------------
Hello!
Our company Barcelo Travel Inc. seek enthusiastic, organised and alert individual to 
support our busy sales offices. If you live in germany our offer its good chance change your liife.
You must have excellent customer relations, communication and administration skills 
Successful candidates will be required to work in Main our Office for approximately 
one month.
To apply, please email CV to barcelotravinc@aol.com
regards,
Dominico Barcelo

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: :), parliament cake ===

From: "Jodie Ash" <JodieAsh () mail ! ru>
To: linux-sparse
Subject: :), parliament cake
Date: Wed, 26 Jul 2006 07:43:51 +0000
Message-ID: <662161c806042kmuinbqmqn6f0jjkw422rv1t0rkvf4v () mxs ! mail ! ru>
--------------------
Genuine Swiss made Role6x repilcas are as close to the real thing 
as a repilca watch can be. Sometimes even the professional jewelers 
are unable to tell the difference from the real RoleGx watch.

Why spend thousands of dollars on the real deal when 
a repilca watch looks so much alike that only an expert could tell the difference...
And you only pay a fractoin of the price.

VISIT US, AND GET OUR SPECIL 370% DISNCOUNT OFER!

http://C4C132g44blo4a4h4rhggw3gge3ygg.borizekk.com/

=====
at sea, hungry, happy, learning.
scientific community  when questions  come up  on implementing UN  decisions
rest of the flock, Jon? Why can't you leave low flying  to  the  pelicans,
     He braked immediately. Good reflexes, I was proud of him. I took Tender
alone! Short wings!
     "I saw it."

Livingston Seagull fired directly through the center of  Breakfast  Flock,
remember. When the panic began he and all his neighbors ran to the bridge in
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Ave... ===

From: "Margo" <andy () 2sun ! ru>
To: linux-sparse
Subject: Ave...
Date: Thu, 20 Jul 2006 07:59:09 +0000
Message-ID: <002501c6abd2$5d186700$0100a8c0 () 218 ! 19 ! 82 ! 143>
--------------------
Hello,	

I think we had correspondence a long time ago if it was not you I am sorry.
If it was I could not answer you because my Mozilla mail manager was down for a 
long time and I could not fix it only with my friend's help I got the emails 
address out for me ..:)
I hope it was whom we were corresponded with you are still interested, as I am, 
though I realize much time has passed since then...
I really don't know where to start ....
Maybe you could tell me a little about yourself since I lost our early letters, 
your appearance,age , hobbies, and are you still in the search?
If it was you I wrote to and you are interested to get to know me better, I have 
a profile at :
http://www.iamsearching-forlove.com/

Don't really know what else to say for now I hope this is the right address

Let me know if you are interested, And I hope
you won't run when you see my picture :-)

a rivederci

Maria

If you think that you were subscribed by mistake for this mail
delivery or if your email has been added without your permission,
please, visit http://iamsearching-forlove.com/ and unsubscribe from our mails.


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Folv" <Multik () 74 ! ru>
To: linux-sparse
Subject: Ave...
Date: Sat, 12 Aug 2006 15:22:19 +0000
Message-ID: <008801c6be23$1578aa00$6320000a () 201-43-133-108 ! dsl ! telesp ! net ! br>
--------------------
Hi my Dear Stranger!

I am a lovely and lonely Lady who is looking for the man who will make me happy and whom I want to feel like in paradise with!
If you want to be my beautiful Hero who will save me from this loneliness find me 
http://www.justwaitingforyou.com/loveyou/
and wake me up with a warm kiss.

good-bye,
Folv A.

If you think that you were subscribed by mistake for this mail
delivery or if your email has been added without your permission,
please, visit http://justwaitingforyou.com/loveyou/ and unsubscribe from our mails.


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Better Future, white-way ===

From: "Errol Childress" <ErrolChildress () 0net ! com>
To: linux-sparse
Subject: Better Future, white-way
Date: Thu, 27 Jul 2006 13:33:02 +0000
Message-ID: <755980915.20060727182102 () 0net ! com>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATEY cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rateN
$372,000.00 at a 3.90,% variable-rateN
$492,000.00 at a 3.21,% interest-onlyK
$248,000.00 at a 3.36,% fixed-rateF
$198,000.00 at a 3.55,% variable-rateS

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://1YTS5HC.corkpencills.com



     Yes, he would have made a good stalker. What the hell, do I feel  sorry
left this. There's more under there.

system? He slipped on  a stone  that turned  under his foot, and fell in. He
been  very powerful, for there hadn't even  been a real fire,  and the Royal
many of our boys fell there? But I found it! I was saving it for myself. And

the slope, and a multitude of black splotches in the dust, as though someone
or  even better,  to lean  back against  it,  close  his  eyes,  and  think,
hills with the corpses. The damn hills, just stood there, the lousy mothers,
always been that way, and it would have continued, if he had not ended up in

night.  He  woke up from the same sound, sad and long,  his  heart stopping,
felt a chill: he thought that he had lost  his way.  But he had  not  gotten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Better Future, world-canvassed ===

From: "Coleman Knutson" <ColemanKnutson () 0733 ! com>
To: linux-sparse
Subject: Better Future, world-canvassed
Date: Thu, 27 Jul 2006 00:29:07 +0000
Message-ID: <8495387050.20060927122803 () 0733 ! com>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATET cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rate8
$372,000.00 at a 3.90,% variable-rateW
$492,000.00 at a 3.21,% interest-onlyE
$248,000.00 at a 3.36,% fixed-rateS
$198,000.00 at a 3.55,% variable-rateQ

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://9B315Q.doolies.net



     When  they finally  scrambled out onto dry  land  that  was covered  by
     He gulped  the rest of  the  coffee, pulled out  a cigarette, and as he

his rear end and  at the dirt. He could barely hear the muffled moans coming
could hear another  peal of  thunder. I'll shake your souls  out of you  for
I never  gave it a second thought. I Pulled him out like he was my flesh and

I never  gave it a second thought. I Pulled him out like he was my flesh and
Burbridge, maybe I'll figure something out.
cottage  for myself, with a garden--as good as Buzzard's place. You know,  I
later, after we've eaten. Brother, it's not  something you should have on an

many of the  tales had  it. It lay where it had fallen. Maybe  it had fallen
Schuhart?"
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Better Life, weeping-ripe ===

From: "Patti Jeffries" <PattiJeffries () 10-4 ! com>
To: linux-sparse
Subject: Better Life, weeping-ripe
Date: Mon, 24 Jul 2006 07:37:05 +0000
Message-ID: <662161c80604jqa70qmo32by0zqzeljs30dxoelpsg10ki () mail ! 10-4 ! com>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATE6 cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rate6
$372,000.00 at a 3.90,% variable-rate4
$492,000.00 at a 3.21,% interest-only1
$248,000.00 at a 3.36,% fixed-rateG
$198,000.00 at a 3.55,% variable-rateI

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://FPDE8VH.fortessed.com



but one  doesn't necessarily rule out  the  other. Only  I don't get to feel
with  two  orderlies, tough  and  rough  burly  guys  used to  lugging heavy

wanted to complain but that he  didn't  dare.  He  only said  in a strangled
Redrick, ears clogged by the noise, turned and saw a bright red spot quickly
the gravel tumbling down the incline under their feet.

far wall,  cozily ensconced amid  the piles  of  accumulated rocks, and even
the  boy stepped over two  ties at a  time, broad-shouldered, narrow-hipped.
to do, don't  suddenly be afraid of the  dirt. If I tell  you  to, drop your
seen one in many years  and had almost  forgotten  what the  insignia looked

legs  numb. I don't care what you say, Dick, I'm going to treat you  royally
     "I see it," Arthur said and shuddered.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Better Life, wind tunnel ===

From: "Theron Schwartz" <TheronSchwartz () mail ! ru>
To: linux-sparse
Subject: Better Life, wind tunnel
Date: Sat, 22 Jul 2006 02:34:29 +0000
Message-ID: <89728418.20060722023411 () mail ! ru>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATE0 cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rate5
$372,000.00 at a 3.90,% variable-rateE
$492,000.00 at a 3.21,% interest-onlyJ
$248,000.00 at a 3.36,% fixed-rate6
$198,000.00 at a 3.55,% variable-rateR

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://70LVKUJ.foorests.net



"Maria! Are you  asleep?"  He had to  wait until his  father  had washed and
up.  Maybe  we'll have to  shoot it  out  with  the patrol  guards. However,

would you wish?"
smack at his feet, raising a cloud of white dust. He was
clearly as if they were in the palm of his hand. Right in front, two hundred

     "A gun."
meaning. It  had no meaning before,  either, but before it was  a person  at
laughed and gave Arthur a poke in the shoulder.
visible against the bright sky. Arthur sat down, shoulder deep in the slime.

to  take  somebody  with  you.  I  can  give you  one  of  my  people  who's
Redrick rummaged in his pocket, took out a bolt weighing an ounce or so, and
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Better Life, witney nap ===

From: "Fran Hanley" <FranHanley () 1-toit-o-soleil ! com>
To: linux-sparse
Subject: Better Life, witney nap
Date: Sun, 23 Jul 2006 04:17:00 +0000
Message-ID: <1110108058.20060723041651 () 1-toit-o-soleil ! com>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATET cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rateD
$372,000.00 at a 3.90,% variable-rateF
$492,000.00 at a 3.21,% interest-onlyK
$248,000.00 at a 3.36,% fixed-rateY
$198,000.00 at a 3.55,% variable-rate9

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://9QN9U95.foorests.net



it,  Redrick  thought  grimly.  Himself. Why did he  beg  to come  along  so
did  this: he  walked through and  left this behind.  Four-eyes  lay on  the

followed. Out of  the  corner  of his  eye  he could see Arthur's  face, his
for   water,   for   coolness.   The  memories,  worn   to   the  point   of
could feel a thousand needles  puncturing  his face.  "For- ward!"  he  kept

     "Mr.  Schuhart,"  Arthur  suddenly  said,  looking away "Do you  really
My legs, do  you  understand? The Zone took them away, and maybe  it'll give
     "See that depression between the hills?" he asked.
thinks that  it was Burbridge who pulled him out of it. The hell he did! You

all of you, buzzards, toads, Visitors, Boneses,  Quarterblads, bloodsuckers,
top of  the rock stuck out of the slime; he realized that even  though there
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: C++ pushback + sparse ===

From: "Randy.Dunlap" <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: C++ pushback + sparse
Date: Tue, 02 May 2006 20:09:50 +0000
Message-ID: <20060502130950.61792c71.rdunlap () xenotime ! net>
--------------------
On Wed, 26 Apr 2006 13:44:19 -0700 Randy.Dunlap wrote:

> > > 	C++ has how many additional reserved words? I believe the list is delete,
> > > friend, private, protected, public, template, throw, try, and catch.
> > 
> > You forgot namespace, mutable, new, class, const_cast, dynamic_cast,
> > static_cast, reinterpret_cast, explicit, true, false, operator, typeid,
> > typename and virtual. Maybe I forgot some (interface ?). Probably some
> > new ones will appear.
> 
> I did a sparse patch to check for all(?) of those once (with Linus's
> help).  I don't know if it still applies or not...
> 
> It's at http://www.xenotime.net/linux/sparse/check_keywords_v7.patch
> (You'll also need the other patch there; they got a bit comingled:
> http://www.xenotime.net/linux/sparse/check_sizeof_v7.patch)

I updated this patch so that it works with sparse (snapshot of
2006-may-01).  The patch is here:
http://www.xenotime.net/linux/sparse/sparse-keywords-sizes.patch


sparse additions to:
- check for C/C++ keywords: usage: -keywords
- print all global data symbols and their sizes: usage: -list-symbols
  Example of -list-symbols:
  make C=2 CF="-list-symbols" arch/x86_64/kernel/smpboot.o
  arch/x86_64/kernel/smpboot.c:90:20: struct cpuinfo_x86 [addressable] [toplevel
] [assigned] cpu_data[8]: compound size 1344, alignment 64

---
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: COMPLIMENT! PIDA INC LOAN. ===

From: "PIDA INC" <pidaincn15 () hotmail ! com>
To: linux-sparse
Subject: COMPLIMENT! PIDA INC LOAN.
Date: Thu, 10 Aug 2006 22:58:58 +0000
Message-ID: <BAY18-F16B740F5AF1D79D8108798DD4A0 () phx ! gbl>
--------------------
PRUDENT INDUSTRIAL DEVELOPMENT AGENCY(PIDA INC)
Educating And Granting Of Loans.
A symbol of entrepreneural relationship and growth.

Email: pidainc26@yahoo.co.nz

Dear Sir/Madam,

I write to you based on a request by an investor and his need for 
investment/funding in your country. My name is MR LARRY GREEN, a financial 
consultant with PRUDENT INDUSTRIAL DEVELOPMENT AGENCY (PIDA INC) which is a 
reputable financial services firm. My company most times represents the 
interests of very wealthy investors. Due to the sensitivity of the position 
they hold in their society and the unstable investment environment of their 
country, they evacuate majority of their funds into more stable economies 
and developed nations where they can get good yield for their money.

I was recently approached by a Reserved Client, whom I had personally worked 
with a few years ago with a proposal. What he request is an individual such 
as you, who will be willing to receive money on his behalf abroad, and put 
it to good use for a period not exceeding 6 years for a start.

The client has offered these terms: 1. 10% commission paid to me and my 
foreign partner of the total funds successfully evacuated. The funds in 
question are over 13.2Million US Dollars.

2. The funds will be used by the foreign partner for six years as a loan 
without any interest. That is, you do not pay any interest on the money but 
you give the client 50% of all profits after tax that accrued from the use 
of the funds.

If these terms are agreeable to you, kindly let me know and I will provide 
you with all necessary information and procedures involved.


All reply should be sent to this Email: pidainc26@yahoo.co.nz    for urgent 
attendance.

Sincerely yours,
MR. LARRY GREEN
Consultant Officer PIDA INC. Belfast
Email:pidainc26@yahoo.co.nz

PS* The client is willing to make available the fund to your possession and 
in your country within 7days of confirmation of your capabilities.

_________________________________________________________________
Dont just search. Find. Check out the new MSN Search! 
http://search.msn.click-url.com/go/onm00200636ave/direct/01/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Future, well-thumbed ===

From: "Mack Gardner" <MackGardner () mail ! ru>
To: linux-sparse
Subject: Future, well-thumbed
Date: Sun, 16 Jul 2006 19:55:49 +0000
Message-ID: <662161c80604ms7rj3x1rf9sujhv7c13s4wb78y9i9mx () mxs ! mail ! ru>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATEL cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rate7
$372,000.00 at a 3.90,% variable-rate3
$492,000.00 at a 3.21,% interest-only6
$248,000.00 at a 3.36,% fixed-rateS
$198,000.00 at a 3.55,% variable-rateC

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://GJYHVOGH.jokip.com



shooting it out with them.... Arthur decisively shook his head.
his senses. His gaze settled on Redrick.

leather of  his shoes and jacket was blistering and  cracking, and  Redrick,
Because I would lose  money? No, it has nothing to  do with the  money. That
     The boy obediently froze in his tracks. His reflexes were good-- he had

and holding on to each other. Redrick saw the peeling pick-up truck, sagging
even redder. His eyes filled with tears. Redrick grinned.
hurry  to hide in some faraway corner and watch in  fear  as his father tore
     "Do you think I might have another sip, Mr. Schuhart?"

corner of his eye. He's  scared, he thought. He must sense  it. If his sense
and it  was even  nicer to drink  now  than alcohol. It smelled of home.  Of
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Future, whippers-in ===

From: "June Logan" <JuneLogan () mail ! ru>
To: linux-sparse
Subject: Future, whippers-in
Date: Wed, 19 Jul 2006 12:15:56 +0000
Message-ID: <75930947.20060719140356 () mail ! ru>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATEJ cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rateG
$372,000.00 at a 3.90,% variable-rate8
$492,000.00 at a 3.21,% interest-onlyY
$248,000.00 at a 3.36,% fixed-rateY
$198,000.00 at a 3.55,% variable-rateW

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://FNIMY5RT.foorests.net



     Redrick  didn't reply. That's  a mistake, he thought,  dispassionately.
rusty  rails,  and  Redrick  watched the drops of condensed fog  glisten  on

the slope, and a multitude of black splotches in the dust, as though someone
was nothing to inspire hope either. For some reason,  his first thought  was
be all right. There  were a few  scratches,  a bump on his forehead, and his

thousand  at  the  end of the  road. I  can work  up a sweat  for that. Five
get it all anyway.
off  his work clothes and tossed  them to his mother,  pulled off his  huge,
meaning. It  had no meaning before,  either, but before it was  a person  at

nothing.
his burned neck.  The pain and lack  of air made  Redrick think that he  was
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Greeting! ===

From: "Bibian M." <bad () aaanet ! ru>
To: linux-sparse
Subject: Greeting!
Date: Fri, 02 Jun 2006 13:43:23 +0000
Message-ID: <004801c6864a$7b3dfe00$4903000a () 201-13-42-221 ! dsl ! telesp ! net ! br>
--------------------
Hi my Dear Stranger!

I want to start my first letter from a question: "Is it possible to be happy without LOVE?"
I think that you will agree with me if the answer will be "NO WAY". Love is the most beautiful and exciting thing
that may happen between man and woman! It inspires us only for doing positive things towards each other.
One very famous writer said: "The beauty will rescue the world" i agree with his words but still i would add :
" LOVE and Beauty will rescure the world". 

I hope you agree with me that Love is a big notion.
There's love to  God, to Mother, to a child to the country where you were born, and there's love that joins a man
and woman for all their life. That is the LOVE i'm looking for! And i'm seeking for the man who is also eager to have
this life long adventure full of surprises and new experience we can share together! Will you join me for this trip?

I do realise that it should be very difficult to say "Yes" from the first letter having no idea about me.
That's why i just offer to get to know each other better though correspondence that will help us to reveal many things
about each other whether we mach perfectly or not. In addition you can look at my pictures and read some info about me here
http://ojbf5HinfFcJyKG9bDUk.i-am-waiting4love.net/
I hope you'll like what you see and read there.

Well closing my first letter to you i just want to thank you for reading it and i really hope that you'll share
my point of view on what i said above. I do really hope that you'll answer me soon.

so long...

Bi M.


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Hi, oil sand ===

From: "Garrett Maxwell" <GarrettMaxwell () 0451 ! com>
To: linux-sparse
Subject: Hi, oil sand
Date: Thu, 15 Jun 2006 01:57:18 +0000
Message-ID: <806986347.20060615015721 () 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://duaocm.jugjest.com/?18594477

==========
brothers in a novel called Hard  to Be a Cod Remarkable, purely as a  novel,
     "The devil knows. It was, and now it's gone.  Thank  God. And shut  up,
old one had ever flown. Why, with half the effort, he  thought,  I'll  get
     My Kirill was cured. Bright-eyed and bushy-tailed.
times, "is nothing more than your thought itself, in a form you  can  see.
like graviconcentrate, he thought that he understood everything and life was

certain portion suffers  from execrable translation. Some works have had the
right down  the middle of the street. It had been ages since  the  last time
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Hi, parrot bullfinch ===

From: "Dirk Blake" <DirkBlake () 0451 ! com>
To: linux-sparse
Subject: Hi, parrot bullfinch
Date: Sat, 29 Jul 2006 11:06:23 +0000
Message-ID: <14208159.20060729110604 () 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIAPLIS 
would help you to make BETTER SEKX MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT EREECTION during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISCBOUNT OFER!

http://evhllv.morelstore.com/?23283033

==========
sleep in the air, setting a course at  night  across  the  offshore  wind,
     "It's not impossible."
pure Outlaw, if that's the way  they  want  it.  And  I'll  make  them  so
didn't enter the  Zone in two's. The rule is: two do the work and  the third
you know what you're doing. Now about your control..."
because you can't press them together,  and no one's been able to pull  them

     But way off alone, out by himself beyond  boat  and  shore,  Jonathan
     "Let's go."
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: How do You do! ===

From: "Valentyna" <hughes () mustek ! com>
To: linux-sparse
Subject: How do You do!
Date: Fri, 08 Dec 2006 05:05:40 +0000
Message-ID: <006a01c71a86$3c1fb800$0100a8c0 () 218 ! 58 ! 86 ! 182>
--------------------
Aloha, Dear!

I am writing to you because I can't be lonely any more... Recently
I understood that I can't breathe freely because I don't have a loving
man near me who will support and protect me every day and to who I
will present all the love and tenderness I have!
With me you will see coziness and comfort in your house, you will feel
love and care every day... I want to be the best wife... Let's
correspond... If you wish to, please see me here http://loveonlyme.com/goodforlove

Looking forward to hear from you!

Valyusha


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Incorrect scoping ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Incorrect scoping
Date: Fri, 31 Mar 2006 22:05:33 +0000
Message-ID: <20060331220533.69B67C000E2 () dunnock ! rentec ! com>
--------------------

Sparse fails to detect this scoping monster:

typedef int typ;
static void typ (void) { }

gcc says...

foo.c:2: error: `typ' redeclared as different kind of symbol
foo.c:1: error: previous declaration of `typ'

M.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Life, winter-wasted ===

From: "Tommy Laird" <TommyLaird () 0ol ! com>
To: linux-sparse
Subject: Life, winter-wasted
Date: Wed, 19 Jul 2006 02:45:24 +0000
Message-ID: <59453637.20060719024441 () 0ol ! com>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATEC cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rateA
$372,000.00 at a 3.90,% variable-rateO
$492,000.00 at a 3.21,% interest-onlyX
$248,000.00 at a 3.36,% fixed-rateV
$198,000.00 at a 3.55,% variable-rateD

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://SZYKM9.jokip.com



up and Arthur jumped up too. But it was quiet  again, and the only sound was
to  take  somebody  with  you.  I  can  give you  one  of  my  people  who's

this! He had  a  fleeting thought: who do I mean? I don't know. But somebody
     "Nonsense!"  Redrick muttered distractedly and froze over the cup  near
to  take  somebody  with  you.  I  can  give you  one  of  my  people  who's

much out of it."
place. Redrick's  parboiled hands ached, and the backpack  kept bumping into
he had  caught something from  Buzzard, not some disgusting  disease, but on
     He shuddered. He could hear a long sad sound through the fog. He jumped

go anyway. He had nowhere  else to go. He'd go. And Arthur went. He wandered
taken care of. "What's that in your back pocket?" he asked casually.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Linux Kernel Markers format string idea ===

From: Mathieu Desnoyers <compudj () krystal ! dyndns ! org>
To: linux-sparse
Subject: Linux Kernel Markers format string idea
Date: Thu, 21 Dec 2006 16:20:35 +0000
Message-ID: <20061221162035.GA9609 () Krystal>
--------------------
Hi,

First, some context : I created the Linux Kernel Markers as a lightweight
code instrumentation mechanism with which we can connect a probe dynamically.
Type checking is done dynamically by comparing the string in the probe to the
string found at the instrumentation site. If we want to have strong type
checking with this mechanism, all the information used for typing must be in
the format string and validated. Frank showed some concerns about the use of
format strings regarding type checking. Here is a proposal to fix this.

I just had an idea about a format string extension that would help fix the
missing type checking with format strings for Linux Kernel Markers. It would
however imply that we extend the format string standard. One of the goals is
to keep backward compatibility with existing format strings.

The two sample cases I would like to "dynamically type check" are the
following :

- Passing a "struct mystruct *" as an argument.
- Passing a "__be64" as an argument
  (typedef as "__u64 __bitwise", where __bitwise is undefined when compiled by
  gcc but is defined as __attribute__((bitwise)) when compiled with __CHECKER__
  for sparse).
  (http://kernel.org/pub/linux/kernel/people/josh/sparse/)

The idea is to add the type between brackets after the conversion specifier.

For a pointer to a structure :
"%p[struct mystruct *]"

For a __be64 :
"%llu[__be64]"

The current format string validation of gcc will not perform more or less
validation than what is actually done, which is to verify that the type is a
pointer or a 64 bytes integer. Printing it through printk will show, for
instance :

0xfffffff[struct mystruct *]
1152921504606846976[__be64]

However, an enhanced format string verificator could check the type of the
pointer and the complete type of the __be64. It could start by being integrated
to the "checker", and only later make its way into gcc.

Comments on this idea are welcome.

Mathieu


-- 
OpenPGP public key:              http://krystal.dyndns.org:8080/key/compudj.gpg
Key fingerprint:     8CD5 52C3 8E3C 4140 715F  BA06 3F25 A8FE 3BAE 9A68 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Frank Ch. Eigler" <fche () redhat ! com>
To: linux-sparse
Subject: Re: Linux Kernel Markers format string idea
Date: Tue, 26 Dec 2006 19:48:13 +0000
Message-ID: <20061226194813.GB20627 () redhat ! com>
--------------------
Hi -

On Thu, Dec 21, 2006 at 11:20:35AM -0500, Mathieu Desnoyers wrote:

> [...]  I just had an idea about a format string extension that would
> help fix the missing type checking with format strings for Linux
> Kernel Markers. [...]  The idea is to add the type between brackets
> after the conversion specifier.  For a pointer to a structure :
> "%p[struct mystruct *]" [...]

It's probably an improvement, though as it is still at the
programmers' discretion, it is less useful for checking and more as
documenting.  I remain ambivalent about whether exposing this level of
detail (complex typing) is a good idea, or whether imposing a small
fixed set of types (string/number/blob) is better.

- FChE
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Moving smatch to use sparse ===

From: "Dan Carpenter" <error27 () gmail ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Sun, 16 Jul 2006 00:42:46 +0000
Message-ID: <a63d67fe0607151742l6a387783x59494b84de80be88 () mail ! gmail ! com>
--------------------
On 7/14/06, Dan Carpenter <error27@gmail.com> wrote:
> I've been porting smatch to c using sparse as a front end.

I'm going to post the diff's at http://smatch.sourceforge.net/sparse/

I'll send another email once some checks are working...

regards,
dan carpenter
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Dan Carpenter" <error27 () gmail ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Thu, 05 Oct 2006 08:41:03 +0000
Message-ID: <a63d67fe0610050141x251253fei59b93fff28505dc4 () mail ! gmail ! com>
--------------------
Work on smatch is going ahead.  I have one real life check is working
and I've added a patched up the core code quite a bit.

 Makefile               |   15
 check_derefed_params.c |  171 +++++
 check_null_deref.c     |  178 +++++
 smatch.c               |   33 +
 smatch.h               |  138 ++++
 smatch_flow.c          |  462 ++++++++++++++
 smatch_helper.c        |  180 +++++
 smatch_hooks.c         |  125 ++++
 smatch_states.c        |  587 +++++++++++++++++++
 9 files changed, 1888 insertions(+), 1 deletion(-)

check_derefed_params prints out a message every time a function
dereferences a parameter without checking.  check_null_deref.c prints
out a message whenever code calls a funtion with possibly null
parameters.  Afterwards you sort the output for functions that are in
both lists like this:

   grep Und warns.out | cut -d ' ' -f 6,7 | sort | uniq > tmp
   grep unchecked warns.out | cut -d ' ' -f 7,8 | sort | uniq > tmp2
   cat tmp* | sort | uniq -c | sort -n | grep " 2 "

If you run the code with an allno config then you get 9 potential
errors but only one is real...

In drivers/char/tty_ioctl.c line 549, ld could possibly NULL if arg is
TCIFLUSH, TCIOFLUSH or TCOFLUSH which leads to a BUG_ON when
tty_ldisc_deref() is called.

It kind sucks to get so many false positives, but the old version of
smatch would have had more even more because it wasn't as good at
handling compound conditions.

The code is on:  http://smatch.sourceforge.net/sparse/

regards,
dan carpenter
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Thu, 05 Oct 2006 09:26:56 +0000
Message-ID: <20061005092656.GA17866 () uranus ! ravnborg ! org>
--------------------
On Thu, Oct 05, 2006 at 01:41:03AM -0700, Dan Carpenter wrote:
> Work on smatch is going ahead.  I have one real life check is working
> and I've added a patched up the core code quite a bit.

For the mindless - can you please repeat what smatch does?

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Dan Carpenter" <error27 () gmail ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Thu, 05 Oct 2006 09:49:36 +0000
Message-ID: <a63d67fe0610050249j1cadc3bfk438b66ec8ad34586 () mail ! gmail ! com>
--------------------
On 10/5/06, Sam Ravnborg <sam@ravnborg.org> wrote:
> On Thu, Oct 05, 2006 at 01:41:03AM -0700, Dan Carpenter wrote:
> > Work on smatch is going ahead.  I have one real life check is working
> > and I've added a patched up the core code quite a bit.
>
> For the mindless - can you please repeat what smatch does?
>
>         Sam
>

It's a static code checker.  Take a look at check_null_deref.c.

You've got a function called match_assign() that gets called for every
assignment:

       name = get_variable_from_expr(expr->left, &sym);
       name = alloc_string(name);
       if (is_null(expr->right))
               set_state(name, my_id, sym, ISNULL);
       else
               set_state(name, my_id, sym, NONNULL);

Say it encounter the code:  a = foo(), then it's going to set the
state of 'a' to NONNULL;

Then say it encounters a call to tty_ldisc_deref(), it's going to
check the state of 'a' and if it's ISNULL or UNDEFINED it's going to
print a message out.

More often you have something like:
a = NULL;
if (b) {
       a = foo();
}
a->x;  <---Error.  'a' is Undefined.

The idea is that it's easy to write checks once all the state tracking
code is in place.

Use it like this:
make C=1 CHECK=/path/to/smatch > warns.out 2>&1

regards,
dan carpenter
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?iso-8859-1?Q?J=F6rn?= Engel <joern () wohnheim ! fh-wedel ! de>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Thu, 05 Oct 2006 10:25:42 +0000
Message-ID: <20061005102542.GD23093 () wohnheim ! fh-wedel ! de>
--------------------
On Thu, 5 October 2006 02:49:36 -0700, Dan Carpenter wrote:
> On 10/5/06, Sam Ravnborg <sam@ravnborg.org> wrote:
> >
> >For the mindless - can you please repeat what smatch does?
> 
> It's a static code checker.  Take a look at check_null_deref.c.
> 
> You've got a function called match_assign() that gets called for every
> assignment:
> 
>       name = get_variable_from_expr(expr->left, &sym);
>       name = alloc_string(name);
>       if (is_null(expr->right))
>               set_state(name, my_id, sym, ISNULL);
>       else
>               set_state(name, my_id, sym, NONNULL);
> 
> Say it encounter the code:  a = foo(), then it's going to set the
> state of 'a' to NONNULL;
> 
> Then say it encounters a call to tty_ldisc_deref(), it's going to
> check the state of 'a' and if it's ISNULL or UNDEFINED it's going to
> print a message out.
> 
> More often you have something like:
> a = NULL;
> if (b) {
>       a = foo();
> }
> a->x;  <---Error.  'a' is Undefined.
> 
> The idea is that it's easy to write checks once all the state tracking
> code is in place.
> 
> Use it like this:
> make C=1 CHECK=/path/to/smatch > warns.out 2>&1

One advantage over gcc or plain sparse is that code checking can be
done in two passes.  Pass one collects all sorts of information for
every compilation unit.  Pass two can then combine the information for
all compilation units and do global checking of some sort.

For example, the currently debated "may be used uninitialized" warning
in gcc is simply not able to detect something like:

foo.c:
	int foo;
	do_initialize(&foo);
	do_something(foo);
bar.c:
void do_initialize(int *bar)
{
	*bar = 0;
}

The code is 100% correct, but gcc only looks at foo.c and spits out a
warning.  Smatch can do better than that - if someone writes a
checker.

Jörn

-- 
But this is not to say that the main benefit of Linux and other GPL
software is lower-cost. Control is the main benefit--cost is secondary.
-- Bruce Perens
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Thu, 05 Oct 2006 15:52:25 +0000
Message-ID: <45252A39.3050008 () redhat ! com>
--------------------
Hello Dan,

Dan Carpenter wrote:
> Work on smatch is going ahead.  I have one real life check is working
> and I've added a patched up the core code quite a bit.
great work! What about the old smatch.pm and perl scripts? Will i be
still able to use those or would i have to port them over? I'm still
using the old smatch on checking Wine.

bye
	michael

> 
> Makefile               |   15
> check_derefed_params.c |  171 +++++
> check_null_deref.c     |  178 +++++
> smatch.c               |   33 +
> smatch.h               |  138 ++++
> smatch_flow.c          |  462 ++++++++++++++
> smatch_helper.c        |  180 +++++
> smatch_hooks.c         |  125 ++++
> smatch_states.c        |  587 +++++++++++++++++++
> 9 files changed, 1888 insertions(+), 1 deletion(-)
> 
> check_derefed_params prints out a message every time a function
> dereferences a parameter without checking.  check_null_deref.c prints
> out a message whenever code calls a funtion with possibly null
> parameters.  Afterwards you sort the output for functions that are in
> both lists like this:
> 
>   grep Und warns.out | cut -d ' ' -f 6,7 | sort | uniq > tmp
>   grep unchecked warns.out | cut -d ' ' -f 7,8 | sort | uniq > tmp2
>   cat tmp* | sort | uniq -c | sort -n | grep " 2 "
> 
> If you run the code with an allno config then you get 9 potential
> errors but only one is real...
> 
> In drivers/char/tty_ioctl.c line 549, ld could possibly NULL if arg is
> TCIFLUSH, TCIOFLUSH or TCOFLUSH which leads to a BUG_ON when
> tty_ldisc_deref() is called.
> 
> It kind sucks to get so many false positives, but the old version of
> smatch would have had more even more because it wasn't as good at
> handling compound conditions.
> 
> The code is on:  http://smatch.sourceforge.net/sparse/


-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Dan Carpenter" <error27 () gmail ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Thu, 05 Oct 2006 20:58:02 +0000
Message-ID: <a63d67fe0610051358j6181f558p2baaf1b59b0a042e () mail ! gmail ! com>
--------------------
On 10/5/06, Michael Stefaniuc <mstefani@redhat.com> wrote:
> Hello Dan,
>
> Dan Carpenter wrote:
> > Work on smatch is going ahead.  I have one real life check is working
> > and I've added a patched up the core code quite a bit.
> great work! What about the old smatch.pm and perl scripts? Will i be
> still able to use those or would i have to port them over? I'm still
> using the old smatch on checking Wine.
>
> bye
>         michael
>

They'll have to be ported I'm afraid.

Rewrites are a pain, but it's worth it because now it's easier to
install, it's easier to use, and it runs a bajillion times faster.
Using sparse also buys us a bunch of features for free, for example if
you have 'i' defined in two different scopes with sparse handles that.
 Another example is compound conditions.  The old code was confused by
stuff like:
if (a && a->foo() || a && a->bar())
there wasn't a good way to deal with that with the old way.

Which checks do you use most?  I'll port those first...

regards,
dan carpenter
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Thu, 05 Oct 2006 22:46:35 +0000
Message-ID: <45258B4B.6010907 () redhat ! com>
--------------------
Dan Carpenter wrote:
> On 10/5/06, Michael Stefaniuc <mstefani@redhat.com> wrote:
>> Dan Carpenter wrote:
>> > Work on smatch is going ahead.  I have one real life check is working
>> > and I've added a patched up the core code quite a bit.
>> great work! What about the old smatch.pm and perl scripts? Will i be
>> still able to use those or would i have to port them over? I'm still
>> using the old smatch on checking Wine.
> 
> They'll have to be ported I'm afraid.
That's not realy a problem especialy as i can keep using the old smatch
for a while.

> Rewrites are a pain, but it's worth it because now it's easier to
> install, it's easier to use, and it runs a bajillion times faster.
I'm more concerned about how easy it is to write new "scripts" or modify
existing ones. For Wine I use only unreached-code.pl as is. Due to the
Win32 API i had to modify unfree.pl quite a bit.

> Using sparse also buys us a bunch of features for free, for example if
> you have 'i' defined in two different scopes with sparse handles that.
> Another example is compound conditions.  The old code was confused by
> stuff like:
> if (a && a->foo() || a && a->bar())
> there wasn't a good way to deal with that with the old way.
> 
> Which checks do you use most?  I'll port those first...
The scripts used regularly for Wine are on
http://people.redhat.com/mstefani/wine/smatch/scripts.html. Except that
i use only unreached-code.pl from the original smatch scripts.
Though not all scripts are that usefull; i probably could throw out
immediately while_for_check.pl and crosscalls_WtoA.pl. Most successfull
script is redundant_null_check.pl (finds "if (bla) free(bla);") as i had
only 2 false positives until now. unfree-wine.pl is the adaptation+bug
fixes of the original unfree.pl (usefull but lots of false positives).
The other usefull script is wine_locks.pl that found quite a few missing
unlocks on error paths. And i have some other ideas about a couple of
usefull smatch scripts for Wine but lack the time to implement them.

So most usefull would be a short documentation how to port things. Maybe
a short mapping between the most importand smatch.pm functions and their
 C counter part would be enough for the start. I looked at the smatch
sparse diff and it didn't look that complicated to use. I have anyway a
longish train ride next week so i will give it a try; maybe with an easy
and dumb version of redundant_null_check.pl

bye
	michael
-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Dan Carpenter" <error27 () gmail ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Fri, 06 Oct 2006 06:31:14 +0000
Message-ID: <a63d67fe0610052331y4e914869k7c0feaf42bb8b14c () mail ! gmail ! com>
--------------------
On 10/5/06, Jörn Engel <joern@wohnheim.fh-wedel.de> wrote:
>
> One advantage over gcc or plain sparse is that code checking can be
> done in two passes.  Pass one collects all sorts of information for
> every compilation unit.  Pass two can then combine the information for
> all compilation units and do global checking of some sort.
>
> For example, the currently debated "may be used uninitialized" warning
> in gcc is simply not able to detect something like:
>
> foo.c:
>         int foo;
>         do_initialize(&foo);
>         do_something(foo);
> bar.c:
> void do_initialize(int *bar)
> {
>         *bar = 0;
> }
>
> The code is 100% correct, but gcc only looks at foo.c and spits out a
> warning.  Smatch can do better than that - if someone writes a
> checker.
>
> Jörn
>

Actually, I think gcc handles that specific example correctly...  If
do_initialize() is in the same file it looks to see if it actually
initializes it or not.  If it's in a seperate file then it assumes
that it initializes it and doesn't print a warning.

I'm using gcc 4.0.3.

regards,
dan carpenter
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Dan Carpenter" <error27 () gmail ! com>
To: linux-sparse
Subject: Re: Moving smatch to use sparse
Date: Fri, 06 Oct 2006 08:57:06 +0000
Message-ID: <a63d67fe0610060157g117228fambc77363513a464d9 () mail ! gmail ! com>
--------------------
Sparse reads the source and creates a parse tree.  At the base, are
function symbols, the function has a bunch statements and the
statements have a bunch of expressions which branch out into even more
expressions.  If you have data that's a symbol.

struct expression is defined in expression.h
struct symbol is defined in symbol.h
struct statement is in parse.h

The important functions are:
set_state(name, my_id, sym, ISNULL);
get_state(deref, my_id, sym)
set_true_false_states(left, my_id, sym_left, ISNULL, NONNULL);
add_hook(&match_assign, ASSIGNMENT_HOOK);
void register_your_check(int id)
left = get_variable_from_expr(expr->left, &sym_left);
left = alloc_string(left);

my_id is a different int for every check script.
sym is a symbol * to the sparse symbol.
The condition hook feeds you one condition at a time.
add_hook() sets up a call back that will be called for every
assignment in this case.
add the register_your_check() to smatch.c.
get_variable_from_expr() is a bit buggy still but it's supposed to
give a string representation of an expression and it also gives you a
symbol pointer.  If you want to keep the string instead of just
printing it out or using it for get_state() then you have to call
alloc_string().

I haven't added setting up custom merge_rules yet.  Will do.

Internally smatch_states are a struct.  I'm going to add some more
fields to that so it might be useful to have a get_state_struct()
function...

smatch_flow.c interprets that sparse tree.  If you want to add another
hook that's the place to do it.

That's pretty much it.

regards,
dan carpenter
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: New sparse git tree; please pull ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: New sparse git tree; please pull
Date: Tue, 17 Oct 2006 08:04:07 +0000
Message-ID: <45348E77.6020600 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig571E77E05835E9DD808DC834
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I've put my current sparse development work in a new tree on kernel.org,
available via:

git://git.kernel.org/pub/scm/linux/kernel/git/josh/sparse.git

or to master.kernel.org users via:

git+ssh://master.kernel.org/pub/scm/linux/kernel/git/josh/sparse.git


I've also included a couple of patches from the linux-sparse list which
have slipped through the cracks.


Linus, please pull from

git+ssh://master.kernel.org/pub/scm/linux/kernel/git/josh/sparse.git

to get the following changes:

Adam DiCarlo:
      Add type information to enum mismatch warning

Josh Triplett:
      "Initializer entry defined twice" should not trigger with
zero-size fields
      Fix incorrect symbol in comment on #endif for multiple-inclusion gu=
ard
      Add -Wno-uninitialized
      graph: Show position in basic block nodes
      bb_terminated: Use boundary values rather than specific opcodes
      Turn on -Wcontext by default
      Merge branch 'fix-defined-twice-error-on-empty-struct' into staging=

      Merge branch 'graph' into staging
      merge branch 'more-warning-flags' into staging and fix conflicts
      merge branch 'no-semantic-h' into staging and fix conflicts
      Merge branch 'Wcontext-default' into staging

Josh Triplett and Pavel Roskin:
      Recognize and ignore __alias__ and __visibility__

 check.c                                      |    2 -
 evaluate.c                                   |    5 ++-
 expand.c                                     |   10 ++----
 graph.c                                      |    3 +
 ident-list.h                                 |    4 +-
 lib.c                                        |    4 +-
 lib.h                                        |    1
 linearize.h                                  |    3 +
 parse.c                                      |    6 ++-
 symbol.h                                     |    2 -
 validation/initializer-entry-defined-twice.c |   43
+++++++++++++++++++++++++++
 11 files changed, 67 insertions(+), 16 deletions(-)

- Josh Triplett


--------------enig571E77E05835E9DD808DC834
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFNI53GJuZRtD+evsRAq9jAJ4p6gozmEJK43YKd+Pdlb/r4RSQGwCeMbCN
G+yMYrmfj09KEQZ9gMdbtZ0=
=681A
-----END PGP SIGNATURE-----

--------------enig571E77E05835E9DD808DC834--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Official releases? ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: Official releases?
Date: Tue, 31 Oct 2006 17:08:24 +0000
Message-ID: <20061031170824.GC23354 () redhat ! com>
--------------------
On Tue, Oct 31, 2006 at 09:03:45AM -0600, Josh Boyer wrote:
 > Howdy,
 > 
 > I'm just curious if anyone is ever really going to do an "official"
 > release of sparse.  We've got daily snapshots provided by Dave Jones,
 > and git of course, but will an official release tarball with shiny
 > version numbers and everything be created?
 > 
 > The only reason I ask is because it makes packaging sparse a bit easier
 > to some degree.

Well, all you need from a version number is a monotonically increasing
number right?  You could munge the daily snapshot dates into same.
It's not as 'pretty' as a real version number, but it works with
minimal effort on behalf of Linus.

	Dave

-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jwboyer () jdub ! homelinux ! org>
To: linux-sparse
Subject: Re: Official releases?
Date: Tue, 31 Oct 2006 18:19:21 +0000
Message-ID: <1162318761.3785.3.camel () zod ! rchland ! ibm ! com>
--------------------
On Tue, 2006-10-31 at 12:08 -0500, Dave Jones wrote:
> On Tue, Oct 31, 2006 at 09:03:45AM -0600, Josh Boyer wrote:
>  > Howdy,
>  > 
>  > I'm just curious if anyone is ever really going to do an "official"
>  > release of sparse.  We've got daily snapshots provided by Dave Jones,
>  > and git of course, but will an official release tarball with shiny
>  > version numbers and everything be created?
>  > 
>  > The only reason I ask is because it makes packaging sparse a bit easier
>  > to some degree.
> 
> Well, all you need from a version number is a monotonically increasing
> number right?  You could munge the daily snapshot dates into same.

Yes, but you don't keep them all laying around forever.  You keep about
a week's worth right?

So if one were to package say sparse-2006-10-25.tar.gz, it'll disappear
in a week.  Makes it hard to verify those against the upstream tarball
when the tarball no longer exists :).

> It's not as 'pretty' as a real version number, but it works with
> minimal effort on behalf of Linus.

Yeah, I know.  It's not a big deal.  I was just curious if something
like an official release was ever even planned or not.

josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Official releases?
Date: Tue, 31 Oct 2006 18:37:55 +0000
Message-ID: <Pine.LNX.4.64.0610311030370.25218 () g5 ! osdl ! org>
--------------------


On Tue, 31 Oct 2006, Josh Boyer wrote:
>
> Yes, but you don't keep them all laying around forever.  You keep about
> a week's worth right?

If each tar-ball contains the git version, at least you can get back to 
it..

Anyway, I suspect it would be better if people didn't consider me the 
maintainer for sparse, simply because it does the things I really cared 
about, and as a result I'm not really very active.

How about talking to Josh Triplett, who maintains a tree at

	git://git.kernel.org/pub/scm/linux/kernel/git/josh/sparse.git

with gitk at

	http://www.kernel.org/git/?p=linux/kernel/git/josh/sparse.git;a=summary

and see if he wouldn't mind making "real" releases.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Official releases?
Date: Tue, 31 Oct 2006 20:36:23 +0000
Message-ID: <4547B3C7.5030608 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig609CD12919F61BC1C049DEFC
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Josh Boyer wrote:
> I'm just curious if anyone is ever really going to do an "official"
> release of sparse.  We've got daily snapshots provided by Dave Jones,
> and git of course, but will an official release tarball with shiny
> version numbers and everything be created?

Since sparse doesn't use any autofoolery, and doesn't include a version n=
umber
in the source anywhere, making a release should just require running git =
tag
and git archive, and putting the resulting tarball up in an official loca=
tion.
As far as version numbering, it seems reasonable to use the former kernel=

versioning system: major.oddeven.revision, starting from something like 0=
=2E1.0,
and keeping major version 0 until sparse can comfortably provide some
guarantee of backward compatibility for sparse extensions.  Thus, periodi=
c
releases (0.1.1, 0.1.2, ...) wouldn't take much effort at all, and eventu=
ally
calling one "stable" (0.2.0, with crash-fixes an similar backported to pr=
oduce
0.2.1, 0.2.2, ...) would mostly consist of a judgement call.

- Josh Triplett


--------------enig609CD12919F61BC1C049DEFC
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFR7PHGJuZRtD+evsRAiLZAJ4jcV33Sc493kkVKucJSdaOW4BjHgCbB3xc
OsfObTdrpolbawrP7XQv8Kk=
=eo0f
-----END PGP SIGNATURE-----

--------------enig609CD12919F61BC1C049DEFC--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jwboyer () jdub ! homelinux ! org>
To: linux-sparse
Subject: Re: Official releases?
Date: Tue, 31 Oct 2006 20:45:18 +0000
Message-ID: <1162327518.26960.0.camel () zod ! rchland ! ibm ! com>
--------------------
On Tue, 2006-10-31 at 12:36 -0800, Josh Triplett wrote:
> Josh Boyer wrote:
> > I'm just curious if anyone is ever really going to do an "official"
> > release of sparse.  We've got daily snapshots provided by Dave Jones,
> > and git of course, but will an official release tarball with shiny
> > version numbers and everything be created?
> 
> Since sparse doesn't use any autofoolery, and doesn't include a version number
> in the source anywhere, making a release should just require running git tag
> and git archive, and putting the resulting tarball up in an official location.
> As far as version numbering, it seems reasonable to use the former kernel
> versioning system: major.oddeven.revision, starting from something like 0.1.0,
> and keeping major version 0 until sparse can comfortably provide some
> guarantee of backward compatibility for sparse extensions.  Thus, periodic
> releases (0.1.1, 0.1.2, ...) wouldn't take much effort at all, and eventually
> calling one "stable" (0.2.0, with crash-fixes an similar backported to produce
> 0.2.1, 0.2.2, ...) would mostly consist of a judgement call.

Great.  Did you see Linus' email suggesting that I ask you to do
this? :)

josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Official releases?
Date: Sat, 04 Nov 2006 05:16:29 +0000
Message-ID: <454C222D.8000901 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE6D149A71CBCDB16D7CCB96D
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Josh Boyer wrote:
> On Tue, 2006-10-31 at 12:36 -0800, Josh Triplett wrote:
>> Josh Boyer wrote:
>>> I'm just curious if anyone is ever really going to do an "official"
>>> release of sparse.  We've got daily snapshots provided by Dave Jones,=

>>> and git of course, but will an official release tarball with shiny
>>> version numbers and everything be created?
>> Since sparse doesn't use any autofoolery, and doesn't include a versio=
n number
>> in the source anywhere, making a release should just require running g=
it tag
>> and git archive, and putting the resulting tarball up in an official l=
ocation.
>> As far as version numbering, it seems reasonable to use the former ker=
nel
>> versioning system: major.oddeven.revision, starting from something lik=
e 0.1.0,
>> and keeping major version 0 until sparse can comfortably provide some
>> guarantee of backward compatibility for sparse extensions.  Thus, peri=
odic
>> releases (0.1.1, 0.1.2, ...) wouldn't take much effort at all, and eve=
ntually
>> calling one "stable" (0.2.0, with crash-fixes an similar backported to=
 produce
>> 0.2.1, 0.2.2, ...) would mostly consist of a judgement call.
>=20
> Great.  Did you see Linus' email suggesting that I ask you to do
> this? :)

I did, and I plan to roll a release this weekend.

- Josh Triplett



--------------enigE6D149A71CBCDB16D7CCB96D
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFTCItGJuZRtD+evsRAmtIAJ97+BEmzs0geRYr8UmbtHhTPWL8rgCgvfzP
fkF7qNj7U/g2HM15hgzBC1g=
=09iF
-----END PGP SIGNATURE-----

--------------enigE6D149A71CBCDB16D7CCB96D--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jwboyer () jdub ! homelinux ! org>
To: linux-sparse
Subject: Re: Official releases?
Date: Sat, 04 Nov 2006 06:09:25 +0000
Message-ID: <1162620565.3139.100.camel () vader ! jdub ! homelinux ! org>
--------------------
On Fri, 2006-11-03 at 21:16 -0800, Josh Triplett wrote:
> Josh Boyer wrote:
> > On Tue, 2006-10-31 at 12:36 -0800, Josh Triplett wrote:
> >> Josh Boyer wrote:
> >>> I'm just curious if anyone is ever really going to do an "official"
> >>> release of sparse.  We've got daily snapshots provided by Dave Jones,
> >>> and git of course, but will an official release tarball with shiny
> >>> version numbers and everything be created?
> >> Since sparse doesn't use any autofoolery, and doesn't include a version number
> >> in the source anywhere, making a release should just require running git tag
> >> and git archive, and putting the resulting tarball up in an official location.
> >> As far as version numbering, it seems reasonable to use the former kernel
> >> versioning system: major.oddeven.revision, starting from something like 0.1.0,
> >> and keeping major version 0 until sparse can comfortably provide some
> >> guarantee of backward compatibility for sparse extensions.  Thus, periodic
> >> releases (0.1.1, 0.1.2, ...) wouldn't take much effort at all, and eventually
> >> calling one "stable" (0.2.0, with crash-fixes an similar backported to produce
> >> 0.2.1, 0.2.2, ...) would mostly consist of a judgement call.
> > 
> > Great.  Did you see Linus' email suggesting that I ask you to do
> > this? :)
> 
> I did, and I plan to roll a release this weekend.

Excellent.  Thanks much!

josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Order status, muffle kiln ===

From: "Miles Hardin" <MilesHardin () 0451 ! com>
To: linux-sparse
Subject: Order status, muffle kiln
Date: Fri, 21 Jul 2006 15:39:43 +0000
Message-ID: <4351914156.20060721153901 () 0451 ! com>
--------------------
Genuine Swiss made Role8x repilcas are as close to the real thing 
as a repilca watch can be. Sometimes even the professional jewelers 
are unable to tell the difference from the real Role9x watch.

Why spend thousands of dollars on the real deal when 
a repilca watch looks so much alike that only an expert could tell the difference...
And you only pay a fractoin of the price.

VISIT US, AND GET OUR SPECIL 370% DISMCOUNT OFER!

http://YEDQUBtrgmgchjzzzmubbrytbrgttb.futhorcib.com/

==========
flashing one hundred fifty miles per hour past his instructor.  He  pulled
     You bet I did!  Of  course, he was just  trying to  humor me. The third
joy.
     "In view of your bravery  beyond the call of duty, and as an exception,
predictions of battle melted in the Flock's confusion.
at me. Of course, he immediately figured it out about me--what was there not

flying than just flapping around from place to place! A...  a...  mosquito
the sidewalk on our left there was black bramble growing, and you could tell
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Order status, nickel ocher ===

From: "Woodrow Busby" <WoodrowBusby () 0451 ! com>
To: linux-sparse
Subject: Order status, nickel ocher
Date: Sun, 13 Aug 2006 15:06:36 +0000
Message-ID: <7333494693.20060813165436 () 0451 ! com>
--------------------
Worried about the loss of erectoin? EVEN if you have no 
erectoin problems SOFT CIADLIS would help you to bring 
back some romantic moments that u lost in past.

Just disolve half a pil under your tongue and get ready for action 
in 15 minutes. SOFT CIA1LIS! It makes your lovemaking incredible!

VISIT US TODAY, AND GET OUR SPECIAL 70% DISCTOUNT OFER!

http://uqcmbd.thetropictan.com/?18298533

Instant shipping worldwide. Absolutely CONFIDENTIAL and SECURE purchase.

------------------
If I were meant to learn so much about flying, I'd have charts for brains.

VAIO Update, Recovery Wizard, Help and Support
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Order status, orange lily ===

From: "Marcia Mayo" <MarciaMayo () 0451 ! com>
To: linux-sparse
Subject: Order status, orange lily
Date: Fri, 04 Aug 2006 18:14:11 +0000
Message-ID: <662161c80604pnvb15u3c7helc975ynu3zpqc0ymaskmz () mail ! 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIAFLIS 
would help you to make BETTER SE4X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ERXECTION during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISCROUNT OFER!

http://wkmbdd.markerbeach.com/?99591414

=====
but he didn't appear to notice. He held  his  practice  sessions  directly
stupid map?
through the night, and all so peaceful and still...
looks  of those  two hillocks!  A  straight line to  the  asphalt led  right
startled that you obliged them so well."
But  what  was  the  silvery thing  shining  back  there?  Was  it  just  my

     "I don't think  so.  The Pilman  Radiant wasn't the first, nor  was  it
order you to start walking on your hands you will immediately hoist your fat
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Q6N ===

From: "Lemuel Sharp" <LemuelSharp () mail ! ru>
To: linux-sparse
Subject: Q6N
Date: Tue, 11 Jul 2006 09:24:08 +0000
Message-ID: <35824884.20060711084808 () mail ! ru>
--------------------
Canada  do they find these  guys? Have they  been sent out here to breed? In
Fletchers, that need an instructor more than this one, that's on  its  way
sergeant, you'll make lieutenant yet.
they're wrong!
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re[1]:Janina ===

From: "Gabriele" <allens () columbus ! rr ! com>
To: linux-sparse
Subject: Re[1]:Janina
Date: Tue, 24 Oct 2006 11:33:29 +0000
Message-ID: <00bd01c6f760$37b27080$8003000a () 200-148-80-174 ! dsl ! telesp ! net ! br>
--------------------
Hallo!!

These girls have no limits. Every hole must be filled!
www.musicworld.cc


Yourth faithfully...

Gabriele


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re[2]: i'll be seeing you ===

From: "Yana" <allenbeasleyallenbeasley () btinternet ! com>
To: linux-sparse
Subject: Re[2]: i'll be seeing you
Date: Sat, 21 Oct 2006 13:01:35 +0000
Message-ID: <008e01c6f510$eb252600$0009000a () 190-48-75-109 ! speedy ! com ! ar>
--------------------
Hi, Manfred

I'm a very young and energetic lady! I have very positive attitude to life and people. I do enjoy new experience life can offer me: to see new interesting places, to meet new people.
I do try to enjoy every moment of life and accept everything the way it comes without complaining.
Though my life seems to be quite enjoyable there's one important thing missing. It's LOVE!
Without my beloved one, my soul mate, my King my life is not completed.
I wish i coud find him very soon so that we could share together every momement of the life-time romance! 
What about you? Could you be my King? If answer is "yes" - you can find more about me 
http://findsomelove.com/myhoney

ta-ta!!
Yanaa


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse and LLVM ===

From: "Sanghyeon Seo" <sanxiyn () gmail ! com>
To: linux-sparse
Subject: Sparse and LLVM
Date: Wed, 27 Dec 2006 09:01:58 +0000
Message-ID: <5b0248170612270101o14ad99e0r897fbffdb41e3009 () mail ! gmail ! com>
--------------------
I can't be the first person to think of this, can I? But I couldn't
locate any reference on this combination. If you know of one, please
tell me.

Sparse: http://kernel.org/pub/linux/kernel/people/josh/sparse/
LLVM: http://llvm.org/

So, you may expect compile-llvm.c in a few days. :)

-- 
Seo Sanghyeon
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Chris Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Sparse and LLVM
Date: Wed, 27 Dec 2006 11:15:33 +0000
Message-ID: <70318cbf0612270315p483df383l6d91ca0280a0af27 () mail ! gmail ! com>
--------------------
It is on my todo list, I even have some half baked patches try to do
that.

Converting from sparse linearized code to llvm byte code should
be very straight forward. Like llvm, the sparse pesudo stay in SSA
from. The only tricky part is GEP, sparse convert member deference
to ptr + constant + type cast on the symbol expand stage. Even before
linearization. It is still doable by guesting the type plus offset. I have
some idea how to preserve that information in sparse but I haven't complete
it.

If you try to write a sparse to llvm byte code converter, please start
from the linearized instructions. It will save you a lot of work.

Chris

On 12/27/06, Sanghyeon Seo <sanxiyn@gmail.com> wrote:
> I can't be the first person to think of this, can I? But I couldn't
> locate any reference on this combination. If you know of one, please
> tell me.
>
> Sparse: http://kernel.org/pub/linux/kernel/people/josh/sparse/
> LLVM: http://llvm.org/
>
> So, you may expect compile-llvm.c in a few days. :)
>
> --
> Seo Sanghyeon
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Success, wild-woven ===

From: "Byron Brandt" <ByronBrandt () 0733 ! com>
To: linux-sparse
Subject: Success, wild-woven
Date: Sat, 15 Jul 2006 23:48:18 +0000
Message-ID: <662161c80604cpxelj24s7gfuzab0tzs1odaqr1c4165h () 61 ! 187 ! 98 ! 10>
--------------------
Your cre dit doesn't matter to us! If you OWN real est ate
and want IMMEDIATEC cash to spend ANY way you like, or simply wish 
to LOWER your monthly paym ents by a third or more, here are the dea ls
we have TODAY (hurry, these ofers will expre TONIGHT):

$488,000.00 at a 3.67,% fixed-rateL
$372,000.00 at a 3.90,% variable-rateX
$492,000.00 at a 3.21,% interest-onlyM
$248,000.00 at a 3.36,% fixed-rate8
$198,000.00 at a 3.55,% variable-rate8

Hurry, when these deals are gone, they are gone Simply fill out this one-min ute form... 

Don't worry about approval, your cre dit will not disqualify you! 

http://VR74KBUY.gtris.net



to it in clumsy letters.  The red dotted line of the  path went to the right
disappeared somewhere from his fingers, and he lit another one. Arthur stood

before, Red," he said to Schuhart, Jr.,  who  was puttering at  the bar. "We
Redrick, ears clogged by the noise, turned and saw a bright red spot quickly
the shower in his stocking feet, leaving sticky footprints. He would stay in

not dissolving with time, but  on the contrary, it was accumulating. And  he
gasped, grabbed  his  head, crouched,  and fell  into the dry grass. Redrick
clumps of dirt flew  in all directions. And only then did Redrick look up at
     "The backpack. You forgot the backpack, Mr. Schuhart."

shooting it out with them.... Arthur decisively shook his head.
     He set up the glasses, quickly opened the bottle, and turned to Noonan.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Try to teach sparse about construct like 'struct ===

From: "Bryan O'Sullivan" <bos () serpentine ! com>
To: linux-sparse
Subject: Re: Try to teach sparse about construct like 'struct
Date: Wed, 18 Jan 2006 01:05:15 +0000
Message-ID: <1137546315.4757.20.camel () serpentine ! pathscale ! com>
--------------------
On Wed, 2006-01-18 at 01:39 +0100, Luc Van Oostenryck wrote:
> On the current linux git tree, sparse spit a lot of errors:
> 	include/asm/lppaca.h:34:8: error: Trying to use reserved word '__attribute__' as identifier
> 
> which is caused by a declaration:
> 	struct __attribute__((__aligned__(0x400))) lppaca {

Funny, I just posted a patch to lkml regarding this.  It'll be in the
next -mm patch.

	<b

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Try to teach sparse about construct like 'struct __attribute__((foo)) bar' ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: Try to teach sparse about construct like 'struct __attribute__((foo)) bar'
Date: Wed, 18 Jan 2006 00:39:43 +0000
Message-ID: <20060118003942.GA1419 () ralph05 ! lan>
--------------------
On the current linux git tree, sparse spit a lot of errors:
	include/asm/lppaca.h:34:8: error: Trying to use reserved word '__attribute__' as identifier

which is caused by a declaration:
	struct __attribute__((__aligned__(0x400))) lppaca {

The following patch seems to solve the symptom but I'm not sure that the ctype
is not handled correctly.
Also, now sparse produce a lot of others errors, mainly about address space
mismatch like:
	init/do_mounts.c:69:16: warning: incorrect type in argument 1 (different address spaces)
	init/do_mounts.c:69:16:    expected char const [noderef] *filename<asn:1>
	init/do_mounts.c:69:16:    got char *<noident>

What is strange is that these warning seems to be about a real address space problem
but why sparse didn't warn before?
(IIRC, the warnings in init/do_mounts.c were reported by sparse some time ago).


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---


diff --git a/parse.c b/parse.c
index d871afd..3c071d6 100644
--- a/parse.c
+++ b/parse.c
@@ -34,6 +34,7 @@ struct symbol_list *function_computed_ta
 struct statement_list *function_computed_goto_list;
 
 static struct token *statement(struct token *token, struct statement **tree);
+static struct token *handle_attributes(struct token *token, struct ctype *ctype);
 
 // Add a symbol to the list of function-local symbols
 static void fn_local_symbol(struct symbol *sym)
@@ -112,6 +113,7 @@ static struct token *struct_union_enum_s
 	struct position *repos;
 
 	ctype->modifiers = 0;
+	token = handle_attributes(token, ctype);
 	if (token_type(token) == TOKEN_IDENT) {
 		sym = lookup_symbol(token->ident, NS_STRUCT);
 		if (!sym ||

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your cash, Non-shakespearean ===

From: "Tameka Hinson" <TamekaHinson () 1000augen ! com>
To: linux-sparse
Subject: Your cash, Non-shakespearean
Date: Mon, 12 Jun 2006 19:31:25 +0000
Message-ID: <662161c806042b23o1vcku61u1c6af92hsf1qn9jakv9 () mxpf00 ! ispgateway ! de>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://ddimkj.muffsoap.net/?62728585

=====
to enter it.
silvery.  That  hadn't been  there  before.  Well, all right, so  there  was
     "Couldn't I? Don't you think that there might be other flocks,  other
hold hands. Especially when  you think of those stories about what stalkers'
The gull  who  looks  upon  an  Outcast  breaks  the  Law  of  the  Flock,
night,  when  you crawl  past, you can  see  the glow  inside,  like alcohol

thought, he lived a long fine life indeed.
truck was still  parked over the pit, in perfect shape, without any holes or
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your cash, palmer worm ===

From: "Jame Gregg" <JameGregg () mail ! ru>
To: linux-sparse
Subject: Your cash, palmer worm
Date: Fri, 04 Aug 2006 06:56:33 +0000
Message-ID: <1770035791.20060804065628 () mail ! ru>
--------------------
Even if you have no erectin problems SOFT CIABLIS 
would help you to make BETTER SEXX MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER4ECTION during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC9OUNT OFER!

http://mjelbn.techniworlds.net/?83294433

==========
     Gradually, in the night, another circle formed around the  circle  of
warehouse or something. And it will be perfectly clear to everyone," I said,
hard?"
twenty feet away and it's completely rusted out, but they look  like they've
on the upstroke.
a  cigarette. I sat  there and felt that I  was  coming round. The bonus pay

pulled out of his dive from seven thousand feet, a long gray streak firing
     "Follow me  step for step, two steps behind  me,  keep your  eyes on my
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your future, ninety-eight ===

From: "Dewayne Rios" <DewayneRios () 0451 ! com>
To: linux-sparse
Subject: Your future, ninety-eight
Date: Mon, 12 Jun 2006 01:01:20 +0000
Message-ID: <534062501.20060612054920 () 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://qkjppq.admityolk.com/?70295077

==========
slowed to twenty and stretched his wings again at last,  the  boat  was  a
nothing seemed to have changed in the  garage since the last time. The  dump
as though the formation were a giant knife, and eight  thousand  gull-eyes
gone, the visibility good. It was  as smooth as silk. I could  see the ditch
translator of these short novels. Russian I do not know; fiction I do; and I
everything. Over the pile of old refuse, over broken glass and rags, crawled

     "Thank you, doctor. My fellow Harmonites! Finally we have heard a clear
the buttons for him....
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your future, paper chaser ===

From: "Annabelle Conway" <AnnabelleConway () mail ! ru>
To: linux-sparse
Subject: Your future, paper chaser
Date: Sun, 23 Jul 2006 06:39:30 +0000
Message-ID: <4199831231.20060723063910 () mail ! ru>
--------------------
Genuine Swiss made RoleHx repilcas are as close to the real thing 
as a repilca watch can be. Sometimes even the professional jewelers 
are unable to tell the difference from the real Role0x watch.

Why spend thousands of dollars on the real deal when 
a repilca watch looks so much alike that only an expert could tell the difference...
And you only pay a fractoin of the price.

VISIT US, AND GET OUR SPECIL 370% DISHCOUNT OFER!

http://QUOTC7Wusz5zdi2i0i5dcuazuushucu.contracthe.com/

==========
crumb on the sea, four thousand feet below.
fate.
grateful for what he had learned about work-saving low-altitude flying.
night,  when  you crawl  past, you can  see  the glow  inside,  like alcohol
this once, and no one was killed.
please, you're  not a human being now, do you understand? You are a machine,

which there are,  at this writing,  over 1,500 in the U.S.A. alone). Suffice
fearless rescuers--a bunch of overfed bums  with a helicopter. I wish I  had
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your future, parcel post ===

From: "Josh Miner" <JoshMiner () 1-choice ! com>
To: linux-sparse
Subject: Your future, parcel post
Date: Fri, 16 Jun 2006 07:24:33 +0000
Message-ID: <662161c80604bpm2r4ub037ufzn3fs0mjxo5fqipjns1 () 1-choice ! com>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://gpdrsc.nosedesk.com/?67964477

=====
     Jonathan opened his eyes. He stood alone with the Elder on a  totally
in arresting you, they're  terrified that you're contaminated. All they want
longer needed fishing boats and stale bread for survival.  He  learned  to
all our  maneuvers, stopping and hovering for a bit, and then continuing. We
directly into his path, calling for its mother. With a tenth of  a  second
cowardice, but I feel he's doomed. You can't explain it to Kirill, but I can

     His thought was triumph. Terminal velocity! A seagull at two  hundred
really is no time in the Zone. Five hours. But if you think about it, what's
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your future, pearl fisher ===

From: "Augustus Addison" <AugustusAddison () 0451 ! com>
To: linux-sparse
Subject: Your future, pearl fisher
Date: Mon, 12 Jun 2006 22:44:15 +0000
Message-ID: <510602519.20060612223917 () 0451 ! com>
--------------------
Join and Play at the best Emperial zCASINOz!
As a Special Welcome TODAY, we will DOUBL your 1 Deposit up to 200 bucks!

For example:
Deposit 50 play with 100!
Deposit 100 play with 200!
And your FREE Bonuses will be INSTANTLY added to your acount!

Try us, inhere: 

http://EI4AOJ.erprost.com/d1/today

==========
     The Strugatskys  posit  that  the Earth experiences  a brief visit from
trying to raise my price.
a bigday for him, a day whose sunrise he no longer remembered.
together now, in formation. And pay  attention  to  that  pullup.  It's  a
They were all just watching and grunting  words of welcome, but not one  was
==
     "Forget about faith!" Chiang said it time and again. "You didn't need
bars on the windows  just like  a police station. Willy was  sitting  at his
     "Jonathan Livingston Seagull! Stand to  Center!"  The  Elder's  words
==
to  them, but I gave him such a  jab in the ribs that he immediately dropped
     When Jonathan Seagull joined the Flock on  the  beach,  it  was  full
get to see her."


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your health, Non-european ===

From: "Humberto Klein" <HumbertoKlein () 0451 ! com>
To: linux-sparse
Subject: Your health, Non-european
Date: Thu, 15 Jun 2006 00:33:22 +0000
Message-ID: <662161c80604xb6v2w7r0p0ht5uiy54kvvvw5m2m1oaj () mail ! 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://sbnpjl.motivefood.com/?88745077

=====
     And so he shut his eyes.
went over each of  my nuts and bolts. I could have gathered them up if I had
scorn.
     We got up into the boot, and Kirill took the controls and said:
imagine that anything like that could possibly happen In our little Harmont.
     "Here," he said. "From a grateful humanity.

     "The first and last."
I'd  never seen. We have  more sergeants  at the institute than  at division
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your health, mountain making ===

From: "Rosalie Weaver" <RosalieWeaver () 0451 ! com>
To: linux-sparse
Subject: Your health, mountain making
Date: Sun, 30 Jul 2006 04:10:12 +0000
Message-ID: <6465553996.20060730055812 () 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIA1LIS 
would help you to make BETTER SE6X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER2ECTION during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISCZOUNT OFER!

http://hudfmn.morelstore.com/?35416393

==========
Flock: Ignore them. The gull who speaks to an Outcast is himself  Outcast.
quickly  figured  what was what  and  dropped the cable  and  made  a  quick
Jonathan's voice raised. "Irresponsibility? My brothers!" he  cried.  "Who
way back, the  boot drives itself.  In other words,  it has  a mechanism,  a
precision flying is a step toward expressing  our  real  nature.Everything
hankies and an orchestra.

     Get down! Seagulls never fly in the dark! If you were meant to fly in
     "How is he telling them?"
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your health, off-bearer ===

From: "John Healy" <JohnHealy () 1000ideasweb ! com>
To: linux-sparse
Subject: Your health, off-bearer
Date: Sun, 11 Jun 2006 19:39:20 +0000
Message-ID: <662161c806042q4a7ycbnargpo1dzdi1x09qxgzr2xfy () orion ! factoriadeinnovacion ! com>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://ijmbtj.greygull.net/?88298550

=====
ordinary experience, and now, the special student of the Elder Himself, he
left.
faith to fly, you needed to understand flying.This is jast the  same.  Now
turned around  without being noticed  and  spit over my left shoulder. I saw
himself if he'd just spend a little time practicing? Why should that be so
looks  of those  two hillocks!  A  straight line to  the  asphalt led  right

Livingston Seagull was practicing. A hundred feet in the  sky  he  lowered
laid the tracks to it yet. You know that. So here we come back from the Zone
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your health, panel wheel ===

From: "Wilburn Blanco" <WilburnBlanco () 0451 ! com>
To: linux-sparse
Subject: Your health, panel wheel
Date: Wed, 14 Jun 2006 08:26:31 +0000
Message-ID: <662161c806041tpj8y83hnfd1h6velxma3ixs3el76df3u () mail ! 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://ojfkqc.pultviewer.com/?99725133

=====
gull had ever passed. He twisted his wings, slowed to a  single  mile  per
it was he wanted to learn from them, and, to tell the truth, I wasn't trying
     His thought was triumph. Terminal velocity! A seagull at two  hundred
couldn't  control himself. I think  it's like  a runny  nose  with  them. It
pulled sharply upward into a full loop and flew all the way  around  to  a
a few of them, but  I'm still surprised every  time I see  one. They're just

and the lights twinkling on the water, throwing out  little  beacon-trails
     I  shouldered  my  way through the crowd, I  was almost past it when  I
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your money, Mindel-riss ===

From: "Marlon Gould" <MarlonGould () 0451 ! com>
To: linux-sparse
Subject: Your money, Mindel-riss
Date: Mon, 07 Aug 2006 18:31:45 +0000
Message-ID: <80393208.20060807183004 () 0451 ! com>
--------------------
Even if you have no erectin problems SOFT CIAMLIS 
would help you to make BETTER SE4X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ERAECTION during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISCCOUNT OFER!

http://mwddcf.forgettry.net/?83283351

==========
     "I don't care what they say," he thought  fiercely,  and  his  vision
nearer to Heaven."
end it all.
I won't take Tender along.  What do you  think, Red? Maybe I  shouldn't take
fourteen miles per hour! It was a breakthrough, the greatest single moment
borders in Rexopolis.  The  flying boot was  waiting  for us, brought by the

dazzling clear skies... in the very times when every other gull  stood  on
somewhere around here, then there wouldn't  even be  a little damp spot left
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Your money, palo blanco ===

From: "Faustino Trent" <FaustinoTrent () mail ! ru>
To: linux-sparse
Subject: Your money, palo blanco
Date: Fri, 28 Jul 2006 15:03:30 +0000
Message-ID: <662161c80604pfw7b2amv13bfvr2mw2yp3xmm336552n () mxs ! mail ! ru>
--------------------
Even if you have no erectin problems SOFT CIAVLIS 
would help you to make BETTER SE3X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER8ECTION during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISCYOUNT OFER!

http://nsqqdl.allsamsite.net/?76288533

=====
slowed to twenty and stretched his wings again at last,  the  boat  was  a
     "Follow me  step for step, two steps behind  me,  keep your  eyes on my
and perfect as sheets of polished silver. He began, delightedly, to  learn
     He  had been  struggling with those empties forever, and the  way I see
     So quiet little Martin William Seagull, startled to be  caught  under
looked at me, I nodded, and our boot stopped moving.

scene. American and English science fiction is widely read in France, Italy,
     He stayed to pore over the map and I  made a beeline  for  the Borscht,
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [ANNOUNCE] Sparse 0.2 released ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: [ANNOUNCE] Sparse 0.2 released
Date: Tue, 05 Dec 2006 12:20:38 +0000
Message-ID: <45756416.3020800 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig2BACAF26407F1CFAF7E845DD
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I have tagged and tarballed a 0.2 release of Sparse, now available from
<http://kernel.org/pub/linux/kernel/people/josh/sparse/dist/sparse-0.2.ta=
r.gz>,
with sha1sum `1762fc609fe436e74b87356a52690b5f7bb40c81`.

In addition to plenty of bug fixes, this release includes several notable=
 new
features:

* -Wall, thanks to Pavel Roskin
* `#strong_define` and `#strong_undef`, thanks to Oleg Nesterov
* Argument parsing functions no longer mangle the argv passed to them, th=
anks
  to Christopher Li
* static library and header files now installed, along with a pkg-config =
file
  to find them
* Makefile now supports DESTDIR, useful for packagers

Full changelog:

    Christopher Li (4):
          trivial fix for seg fault.
          Fix warning on self check.
          delay removing file scope
          cleanup write to argument array hack
    =20
    Damien Lespiau (1):
          trivial: more .gitignore stuff
    =20
    Josh Triplett (5):
          Update the FAQ: add sparse website and gitweb, update git URL, =
remove old BK url
          Rename "check.c" to "sparse.c" to match program name; update .g=
itignore
          Install static library and header files
          Generate and install a pkg-config file.  Add DESTDIR support to=
 Makefile.
          Remove old SCCS target from Makefile.
    =20
    Nicolas Kaiser (1):
          double inclusions
    =20
    Oleg Nesterov (7):
          use lookup_macro() in handle_undef()
          kill NS_INVISIBLEMACRO, introduce NS_UNDEF
          fix redefine of #weak_define
          fix 'weak' attribute loss
          prepare for #strong_{define,undef}
          implement #strong_define
          implement #strong_undef
    =20
    Pavel Roskin (1):
          Support -Wall flag

-- Josh Triplett


--------------enig2BACAF26407F1CFAF7E845DD
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFdWQWGJuZRtD+evsRAhURAJ9g3+BW2XbVWoqhiBtqvmHRJqRzTACgq5Hk
lDQ6r6czMMTGue/vcAzQxaw=
=YXp7
-----END PGP SIGNATURE-----

--------------enig2BACAF26407F1CFAF7E845DD--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] implement strong define/undef ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 0/3] implement strong define/undef
Date: Mon, 04 Sep 2006 12:17:40 +0000
Message-ID: <20060904161552.GA7686 () oleg>
--------------------
Re-send. Imho, this is a useful feature. It allows to override
the defines in the source code without editing it.

Oleg.


-- 
VGER BF report: H 2.8265e-10
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/4] pre-processor fixes ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 0/4] pre-processor fixes
Date: Mon, 04 Sep 2006 11:46:15 +0000
Message-ID: <20060904154115.GA6419 () oleg>
--------------------
Hello.

Re-send, see

	[PATCH 1/7] use lookup_macro() in handle_undef()
	http://marc.theaimsgroup.com/?l=linux-sparse&m=113622504413831
	... and others ...

There was no responce. I must admit, I don't remember how this all
works, but this series still applies cleanly, and still fixes bugs.

This is also a preparation for the strong define/undef implementation,
it was sent and ignored as well :)

Oleg.


-- 
VGER BF report: U 0.476099
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3 RESEND] Add -Wno-address-space ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH 1/3 RESEND] Add -Wno-address-space
Date: Wed, 30 Aug 2006 01:17:16 +0000
Message-ID: <1156900636.5203.10.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add the ability to turn off address-space mismatch warnings using
-Wno-address-space, helpful when attempting to track down a particular class
of warnings only without losing them amongst others.  Address space checking
defaults to on, so this does not change the default behavior of sparse.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 evaluate.c |    2 +-
 lib.c      |    2 ++
 lib.h      |    1 +
 3 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 2561f38..c5d2526 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -681,7 +681,7 @@ const char * type_difference(struct symb
 			return "different base types";
 
 		/* Must be same address space to be comparable */
-		if (as1 != as2)
+		if (Waddress_space && as1 != as2)
 			return "different address spaces";
 
 		/* Ignore differences in storage types or addressability */
diff --git a/lib.c b/lib.c
index feb755a..61c35b3 100644
--- a/lib.c
+++ b/lib.c
@@ -178,6 +178,7 @@ int Wcast_to_address_space = 0;
 int Wdecl = 0;
 int Wtransparent_union = 1;
 int Wshadow = 0;
+int Waddress_space = 1;
 int preprocess_only;
 char *include;
 int include_fd = -1;
@@ -323,6 +324,7 @@ static const struct warning {
 	{ "context", &Wcontext },
 	{ "transparent-union", &Wtransparent_union },
 	{ "shadow", &Wshadow },
+	{ "address-space", &Waddress_space },
 };
 

diff --git a/lib.h b/lib.h
index a248c08..24dd38f 100644
--- a/lib.h
+++ b/lib.h
@@ -77,6 +77,7 @@ extern int Wdefault_bitfield_sign;
 extern int Wundefined_preprocessor;
 extern int Wbitwise, Wtypesign, Wcontext;
 extern int Wtransparent_union;
+extern int Waddress_space;
 extern int Wcast_to_address_space;
 extern int Wdecl;
 extern int Wone_bit_signed_bitfield;
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] prepare for #strong_{define,undef} ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 1/3] prepare for #strong_{define,undef}
Date: Mon, 04 Sep 2006 12:17:40 +0000
Message-ID: <20060904161607.GA7689 () oleg>
--------------------
This patch renames symbol->weak to symbol->attr and adds
symbolic names for it's values.

I don't like the new name, and will be happy to rename if
you suggest me something different.

Probably it is also better to move ->attr into the NS_MACRO
part of the union and make it integer.

No changes in pre-process.o

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060904/symbol.h~5PREP	2006-09-04 19:22:36.000000000 +0400
+++ git-snapshot-20060904/symbol.h	2006-09-04 19:44:19.000000000 +0400
@@ -80,10 +80,13 @@ struct symbol_op {
 extern int expand_safe_p(struct expression *expr, int cost);
 extern int expand_constant_p(struct expression *expr, int cost);
 
+#define SYM_ATTR_WEAK		1
+#define SYM_ATTR_NORMAL		0
+
 struct symbol {
 	enum namespace namespace:8;
 	enum type type:8;
-	unsigned char used:1, weak:1;
+	unsigned char used:1, attr:1;
 	struct position pos;		/* Where this symbol was declared */
 	struct ident *ident;		/* What identifier this symbol is associated with */
 	struct symbol *next_id;		/* Next semantic symbol that shares this identifier */
--- git-snapshot-20060904/pre-process.c~5PREP	2006-09-04 19:22:36.000000000 +0400
+++ git-snapshot-20060904/pre-process.c	2006-09-04 19:44:19.000000000 +0400
@@ -1055,7 +1055,7 @@ Earg:
 	return NULL;
 }
 
-static int do_handle_define(struct stream *stream, struct token **line, struct token *token, int weak)
+static int do_handle_define(struct stream *stream, struct token **line, struct token *token, int attr)
 {
 	struct token *arglist, *expansion;
 	struct token *left = token->next;
@@ -1088,15 +1088,16 @@ static int do_handle_define(struct strea
 	if (sym) {
 		int clean;
 
-		if (weak > sym->weak)
+		if (attr > sym->attr)
 			goto out;
 
-		clean = (weak == sym->weak);
+		clean = (attr == sym->attr);
 
 		if (token_list_different(sym->expansion, expansion) ||
 		    token_list_different(sym->arglist, arglist)) {
 			ret = 0;
-			if ((clean && !weak) || sym->used_in == file_scope) {
+			if ((clean && attr == SYM_ATTR_NORMAL)
+					|| sym->used_in == file_scope) {
 				warning(left->pos, "preprocessor token %.*s redefined",
 						name->len, name->name);
 				info(sym->pos, "this was the original definition");
@@ -1118,19 +1119,19 @@ static int do_handle_define(struct strea
 	}
 
 	sym->used_in = NULL;
-	sym->weak = weak;
+	sym->attr = attr;
 out:
 	return ret;
 }
 
 static int handle_define(struct stream *stream, struct token **line, struct token *token)
 {
-	return do_handle_define(stream, line, token, 0);
+	return do_handle_define(stream, line, token, SYM_ATTR_NORMAL);
 }
 
 static int handle_weak_define(struct stream *stream, struct token **line, struct token *token)
 {
-	return do_handle_define(stream, line, token, 1);
+	return do_handle_define(stream, line, token, SYM_ATTR_WEAK);
 }
 
 static int handle_undef(struct stream *stream, struct token **line, struct token *token)


-- 
VGER BF report: H 0.0993777
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/4] use lookup_macro() in handle_undef() ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 1/4] use lookup_macro() in handle_undef()
Date: Mon, 04 Sep 2006 11:46:15 +0000
Message-ID: <20060904154135.GA6424 () oleg>
--------------------
The current code looks strange, I think it used to remove the symbol
from ->symbols list some time ago.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060904/pre-process.c~1HUCL	2006-09-03 23:32:31.000000000 +0400
+++ git-snapshot-20060904/pre-process.c	2006-09-04 17:19:51.000000000 +0400
@@ -1126,22 +1126,17 @@ static int handle_weak_define(struct str
 static int handle_undef(struct stream *stream, struct token **line, struct token *token)
 {
 	struct token *left = token->next;
-	struct symbol **sym;
+	struct symbol *sym;
 
 	if (token_type(left) != TOKEN_IDENT) {
 		sparse_error(token->pos, "expected identifier to 'undef'");
 		return 1;
 	}
 
-	sym = &left->ident->symbols;
-	while (*sym) {
-		struct symbol *t = *sym;
-		if (t->namespace & (NS_MACRO | NS_INVISIBLEMACRO)) {
-			t->namespace = NS_INVISIBLEMACRO;
-			return 1;
-		}
-		sym = &t->next_id;
-	}
+	sym = lookup_macro(left->ident);
+	if (sym)
+		sym->namespace = NS_INVISIBLEMACRO;
+
 	return 1;
 }
 


-- 
VGER BF report: H 0.0167159
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/7] casting null pointer constant to non-zero address space is always OK ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 1/7] casting null pointer constant to non-zero address space is always OK
Date: Sun, 01 Oct 2006 13:57:11 +0000
Message-ID: <E1GU1od-0006tw-PF () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |   13 ++++++++++++-
 1 files changed, 12 insertions(+), 1 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 0dc05b9..fd29edf 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2126,14 +2126,25 @@ static int get_as(struct symbol *sym)
 static void cast_to_as(struct expression *e, int as)
 {
 	struct expression *v = e->cast_expression;
+	struct symbol *type = v->ctype;
 
 	if (!Wcast_to_address_space)
 		return;
 
+	if (v->type != EXPR_VALUE || v->value)
+		goto out;
+
 	/* cast from constant 0 to pointer is OK */
-	if (v->type == EXPR_VALUE && is_int_type(v->ctype) && !v->value)
+	if (is_int_type(type))
+		return;
+
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+
+	if (type->type == SYM_PTR && type->ctype.base_type == &void_ctype)
 		return;
 
+out:
 	warning(e->pos, "cast adds address space to expression (<asn:%d>)", as);
 }
 
-- 
1.4.2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/7] use lookup_macro() in handle_undef() ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 1/7] use lookup_macro() in handle_undef()
Date: Mon, 02 Jan 2006 18:04:04 +0000
Message-ID: <43B97CCD.5BD4F335 () tv-sign ! ru>
--------------------
Current code looks strange, I think it used to remove the symbol
from ->symbols list some time ago.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060101/pre-process.c~1_HUCL	2006-01-01 00:13:52.000000000 +0300
+++ git-snapshot-20060101/pre-process.c	2006-01-02 20:04:22.000000000 +0300
@@ -1126,22 +1126,17 @@ static int handle_weak_define(struct str
 static int handle_undef(struct stream *stream, struct token **line, struct token *token)
 {
 	struct token *left = token->next;
-	struct symbol **sym;
+	struct symbol *sym;
 
 	if (token_type(left) != TOKEN_IDENT) {
 		sparse_error(token->pos, "expected identifier to 'undef'");
 		return 1;
 	}
 
-	sym = &left->ident->symbols;
-	while (*sym) {
-		struct symbol *t = *sym;
-		if (t->namespace & (NS_MACRO | NS_INVISIBLEMACRO)) {
-			t->namespace = NS_INVISIBLEMACRO;
-			return 1;
-		}
-		sym = &t->next_id;
-	}
+	sym = lookup_macro(left->ident);
+	if (sym)
+		sym->namespace = NS_INVISIBLEMACRO;
+
 	return 1;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: Re: [PATCH 1/7] use lookup_macro() in handle_undef()
Date: Wed, 18 Jan 2006 09:14:49 +0000
Message-ID: <43CE18ED.79C43324 () tv-sign ! ru>
--------------------
Any comments?

Please note that patches 3-4 are bugfixes.

Oleg.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/7] use lookup_macro() in handle_undef()
Date: Tue, 05 Dec 2006 11:14:55 +0000
Message-ID: <457554AF.40800 () freedesktop ! org>
--------------------
I've merged all 7 of these patches.  Thanks again, and sorry these slipped
through the cracks for for so long.

- Josh Triplett
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/7] use lookup_macro() in handle_undef()
Date: Tue, 05 Dec 2006 11:14:55 +0000
Message-ID: <457554AF.40800 () freedesktop ! org>
--------------------
I've merged all 7 of these patches.  Thanks again, and sorry these slipped
through the cracks for for so long.

- Josh Triplett
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3 RESEND] Add -Wno-enum-mismatch ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH 2/3 RESEND] Add -Wno-enum-mismatch
Date: Wed, 30 Aug 2006 01:17:24 +0000
Message-ID: <1156900644.5203.12.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add the ability to turn off enum type mismatch warnings using
-Wno-enum-mismatch, helpful when attempting to track down a particular class
of warnings only without losing them amongst others.  Enum type mismatch
checking defaults to on, so this does not change the default behavior of
sparse.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 evaluate.c |    2 ++
 lib.c      |    2 ++
 lib.h      |    1 +
 3 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index c5d2526..177797a 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -243,6 +243,8 @@ warn_for_different_enum_types (struct po
 			       struct symbol *typea,
 			       struct symbol *typeb)
 {
+	if (!Wenum_mismatch)
+		return;
 	if (typea->type == SYM_NODE)
 		typea = typea->ctype.base_type;
 	if (typeb->type == SYM_NODE)
diff --git a/lib.c b/lib.c
index 61c35b3..8fac8ae 100644
--- a/lib.c
+++ b/lib.c
@@ -179,6 +179,7 @@ int Wdecl = 0;
 int Wtransparent_union = 1;
 int Wshadow = 0;
 int Waddress_space = 1;
+int Wenum_mismatch = 1;
 int preprocess_only;
 char *include;
 int include_fd = -1;
@@ -325,6 +326,7 @@ static const struct warning {
 	{ "transparent-union", &Wtransparent_union },
 	{ "shadow", &Wshadow },
 	{ "address-space", &Waddress_space },
+	{ "enum-mismatch", &Wenum_mismatch },
 };
 

diff --git a/lib.h b/lib.h
index 24dd38f..0b45c67 100644
--- a/lib.h
+++ b/lib.h
@@ -79,6 +79,7 @@ extern int Wbitwise, Wtypesign, Wcontext
 extern int Wtransparent_union;
 extern int Waddress_space;
 extern int Wcast_to_address_space;
+extern int Wenum_mismatch;
 extern int Wdecl;
 extern int Wone_bit_signed_bitfield;
 extern int Wshadow;
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] implement #strong_define ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 2/3] implement #strong_define
Date: Mon, 04 Sep 2006 12:17:41 +0000
Message-ID: <20060904161618.GA7692 () oleg>
--------------------
Example

	#strong_define FOO 1

	#undef	FOO	// silently ignored
	#define	FOO 2	// silently ignored

This allows (for example) to override CONFIG_XXX values without
editing include/linux/autoconf.h

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060904/symbol.h~6DEF	2006-09-04 19:44:19.000000000 +0400
+++ git-snapshot-20060904/symbol.h	2006-09-04 19:48:23.000000000 +0400
@@ -80,13 +80,14 @@ struct symbol_op {
 extern int expand_safe_p(struct expression *expr, int cost);
 extern int expand_constant_p(struct expression *expr, int cost);
 
-#define SYM_ATTR_WEAK		1
-#define SYM_ATTR_NORMAL		0
+#define SYM_ATTR_WEAK		0
+#define SYM_ATTR_NORMAL		1
+#define SYM_ATTR_STRONG		2
 
 struct symbol {
 	enum namespace namespace:8;
 	enum type type:8;
-	unsigned char used:1, attr:1;
+	unsigned char used:1, attr:2;
 	struct position pos;		/* Where this symbol was declared */
 	struct ident *ident;		/* What identifier this symbol is associated with */
 	struct symbol *next_id;		/* Next semantic symbol that shares this identifier */
--- git-snapshot-20060904/pre-process.c~6DEF	2006-09-04 19:44:19.000000000 +0400
+++ git-snapshot-20060904/pre-process.c	2006-09-04 19:48:23.000000000 +0400
@@ -1088,7 +1088,7 @@ static int do_handle_define(struct strea
 	if (sym) {
 		int clean;
 
-		if (attr > sym->attr)
+		if (attr < sym->attr)
 			goto out;
 
 		clean = (attr == sym->attr);
@@ -1134,6 +1134,11 @@ static int handle_weak_define(struct str
 	return do_handle_define(stream, line, token, SYM_ATTR_WEAK);
 }
 
+static int handle_strong_define(struct stream *stream, struct token **line, struct token *token)
+{
+	return do_handle_define(stream, line, token, SYM_ATTR_STRONG);
+}
+
 static int handle_undef(struct stream *stream, struct token **line, struct token *token)
 {
 	struct token *left = token->next;
@@ -1145,7 +1150,7 @@ static int handle_undef(struct stream *s
 	}
 
 	sym = lookup_macro(left->ident);
-	if (!sym)
+	if (!sym || sym->attr > SYM_ATTR_NORMAL)
 		return 1;
 
 	if (sym->scope != file_scope) {
@@ -1565,15 +1570,16 @@ static void init_preprocessor(void)
 		const char *name;
 		int (*handler)(struct stream *, struct token **, struct token *);
 	} normal[] = {
-		{ "define",	handle_define },
-		{ "weak_define",handle_weak_define },
-		{ "undef",	handle_undef },
-		{ "warning",	handle_warning },
-		{ "error",	handle_error },
-		{ "include",	handle_include },
-		{ "include_next",handle_include_next },
-		{ "pragma",	handle_pragma },
-		{ "line",	handle_line },
+		{ "define",		handle_define },
+		{ "weak_define",	handle_weak_define },
+		{ "strong_define",	handle_strong_define },
+		{ "undef",		handle_undef },
+		{ "warning",		handle_warning },
+		{ "error",		handle_error },
+		{ "include",		handle_include },
+		{ "include_next",	handle_include_next },
+		{ "pragma",		handle_pragma },
+		{ "line",		handle_line },
 
 		// our internal preprocessor tokens
 		{ "nostdinc",	   handle_nostdinc },


-- 
VGER BF report: H 5.71153e-14
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/4] fix handle_undef() on builtin macros ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 2/4] fix handle_undef() on builtin macros
Date: Mon, 04 Sep 2006 11:46:14 +0000
Message-ID: <20060904154148.GA6431 () oleg>
--------------------
Example:

	inc.h:
		#define FOO bar
		#undef FOO

	file.c:
		FOO

	$ test-lexing -include inc.h file.c
	bar					<------ should be 'FOO'

This patch kills NS_INVISIBLEMACRO and introduces NS_UNDEF,
this is also used in the next patches.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060904/symbol.h~2UNDEF	2006-09-03 23:32:31.000000000 +0400
+++ git-snapshot-20060904/symbol.h	2006-09-04 18:20:23.000000000 +0400
@@ -32,7 +32,7 @@ enum namespace {
 	NS_SYMBOL = 16,
 	NS_ITERATOR = 32,
 	NS_PREPROCESSOR = 64,
-	NS_INVISIBLEMACRO = 128,
+	NS_UNDEF = 128,
 };
 
 enum type {
--- git-snapshot-20060904/scope.c~2UNDEF	2006-09-03 23:32:31.000000000 +0400
+++ git-snapshot-20060904/scope.c	2006-09-04 18:20:23.000000000 +0400
@@ -41,7 +41,6 @@ static void start_scope(struct scope **s
 void start_file_scope(void)
 {
 	struct scope *scope = __alloc_scope(0);
-	struct symbol *sym;
 
 	memset(scope, 0, sizeof(*scope));
 	scope->next = &builtin_scope;
@@ -50,12 +49,6 @@ void start_file_scope(void)
 	/* top-level stuff defaults to file scopt, "extern" etc will choose global scope */
 	function_scope = scope;
 	block_scope = scope;
-
-	/* Make the builtin macros visible again */
-	FOR_EACH_PTR(builtin_scope.symbols, sym) {
-		if (sym->namespace == NS_INVISIBLEMACRO)
-			sym->namespace = NS_MACRO;
-	} END_FOR_EACH_PTR(sym);
 }
 
 void start_symbol_scope(void)
--- git-snapshot-20060904/pre-process.c~2UNDEF	2006-09-04 17:19:51.000000000 +0400
+++ git-snapshot-20060904/pre-process.c	2006-09-04 18:20:23.000000000 +0400
@@ -103,7 +103,7 @@ static void replace_with_integer(struct 
 
 static struct symbol *lookup_macro(struct ident *ident)
 {
-	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_INVISIBLEMACRO);
+	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_UNDEF);
 	if (sym && sym->namespace != NS_MACRO)
 		sym = NULL;
 	return sym;
@@ -1134,8 +1134,15 @@ static int handle_undef(struct stream *s
 	}
 
 	sym = lookup_macro(left->ident);
-	if (sym)
-		sym->namespace = NS_INVISIBLEMACRO;
+	if (!sym)
+		return 1;
+
+	if (sym->scope != file_scope) {
+		sym = alloc_symbol(left->pos, SYM_NODE);
+		bind_symbol(sym, left->ident, NS_MACRO);
+	}
+
+	sym->namespace = NS_UNDEF;
 
 	return 1;
 }


-- 
VGER BF report: U 0.500014
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/7] introduce classify_type(), use it in obvious places ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 2/7] introduce classify_type(), use it in obvious places
Date: Sun, 01 Oct 2006 13:57:21 +0000
Message-ID: <E1GU1on-0006ug-QV () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |  107 +++++++++++++++++++++++++++++++++---------------------------
 1 files changed, 58 insertions(+), 49 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index fd29edf..b3a79e7 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -337,6 +337,40 @@ static inline int is_byte_type(struct sy
 	return type->bit_size == bits_in_char && type->type != SYM_BITFIELD;
 }
 
+enum {
+	TYPE_NUM = 1,
+	TYPE_BITFIELD = 2,
+	TYPE_RESTRICT = 4,
+	TYPE_FLOAT = 8,
+	TYPE_PTR = 16,
+	TYPE_COMPOUND = 32,
+};
+
+static inline int classify_type(struct symbol *type, struct symbol **base)
+{
+	static int type_class[SYM_BAD + 1] = {
+		[SYM_PTR] = TYPE_PTR,
+		[SYM_FN] = TYPE_PTR,
+		[SYM_ARRAY] = TYPE_PTR | TYPE_COMPOUND,
+		[SYM_STRUCT] = TYPE_COMPOUND,
+		[SYM_UNION] = TYPE_COMPOUND,
+		[SYM_BITFIELD] = TYPE_NUM | TYPE_BITFIELD,
+		[SYM_RESTRICT] = TYPE_NUM | TYPE_RESTRICT,
+	};
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	if (type->type == SYM_ENUM)
+		type = type->ctype.base_type;
+	*base = type;
+	if (type->type == SYM_BASETYPE) {
+		if (type->ctype.base_type == &int_type)
+			return TYPE_NUM;
+		if (type->ctype.base_type == &fp_type)
+			return TYPE_NUM | TYPE_FLOAT;
+	}
+	return type_class[type->type];
+}
+
 static inline int is_string_type(struct symbol *type)
 {
 	if (type->type == SYM_NODE)
@@ -1083,31 +1117,26 @@ static int compatible_assignment_types(s
 	struct expression **rp, struct symbol *source, const char *where, int op)
 {
 	const char *typediff;
-	struct symbol *t;
+	struct symbol *t, *s;
 	int target_as;
+	int tclass = classify_type(target, &t);
+	int sclass = classify_type(source, &s);
 
-	if (is_int_type(target)) {
-		if (is_int_type(source))
-			goto Cast;
-		if (is_float_type(source))
-			goto Cast;
-	} else if (is_float_type(target)) {
-		if (!compatible_float_op(op)) {
+	if (tclass & sclass & TYPE_NUM) {
+		if (tclass & TYPE_FLOAT && !compatible_float_op(op)) {
 			sparse_error(expr->pos, "invalid assignment");
 			return 0;
 		}
-		if (is_int_type(source))
-			goto Cast;
-		if (is_float_type(source))
+		if (tclass & TYPE_RESTRICT) {
+			if (restricted_binop(op, target)) {
+				sparse_error(expr->pos, "bad restricted assignment");
+				return 0;
+			}
+			if (!restricted_value(*rp, target))
+				return 1;
+		} else if (!(sclass & TYPE_RESTRICT))
 			goto Cast;
-	} else if (is_restricted_type(target)) {
-		if (restricted_binop(op, target)) {
-			sparse_error(expr->pos, "bad restricted assignment");
-			return 0;
-		}
-		if (!restricted_value(*rp, target))
-			return 1;
-	} else if (is_ptr_type(target)) {
+	} else if (tclass & TYPE_PTR) {
 		if (op == SPECIAL_ADD_ASSIGN || op == SPECIAL_SUB_ASSIGN) {
 			evaluate_ptr_add(expr, target, rp);
 			return 1;
@@ -1127,15 +1156,8 @@ static int compatible_assignment_types(s
 		return 1;
 
 	/* Pointer destination? */
-	t = target;
-	target_as = t->ctype.as;
-	if (t->type == SYM_NODE) {
-		t = t->ctype.base_type;
-		target_as |= t->ctype.as;
-	}
-	if (t->type == SYM_PTR || t->type == SYM_FN || t->type == SYM_ARRAY) {
+	if (tclass & TYPE_PTR) {
 		struct expression *right = *rp;
-		struct symbol *s = source;
 		int source_as;
 
 		// NULL pointer is always ok
@@ -1143,11 +1165,8 @@ static int compatible_assignment_types(s
 			goto Cast;
 
 		/* "void *" matches anything as long as the address space is ok */
-		source_as = s->ctype.as;
-		if (s->type == SYM_NODE) {
-			s = s->ctype.base_type;
-			source_as |= s->ctype.as;
-		}
+		target_as = t->ctype.as | target->ctype.as;
+		source_as = s->ctype.as | source->ctype.as;
 		if (source_as == target_as && (s->type == SYM_PTR || s->type == SYM_ARRAY)) {
 			s = get_base_type(s);
 			t = get_base_type(t);
@@ -2153,7 +2172,7 @@ static struct symbol *evaluate_cast(stru
 	struct expression *target = expr->cast_expression;
 	struct symbol *ctype = examine_symbol_type(expr->cast_type);
 	struct symbol *t1, *t2;
-	enum type type1, type2;
+	int class1, class2;
 	int as1, as2;
 
 	if (!target)
@@ -2193,12 +2212,7 @@ static struct symbol *evaluate_cast(stru
 	evaluate_expression(target);
 	degenerate(target);
 
-	t1 = ctype;
-	if (t1->type == SYM_NODE)
-		t1 = t1->ctype.base_type;
-	if (t1->type == SYM_ENUM)
-		t1 = t1->ctype.base_type;
-
+	class1 = classify_type(ctype, &t1);
 	/*
 	 * You can always throw a value away by casting to
 	 * "void" - that's an implicit "force". Note that
@@ -2207,8 +2221,7 @@ static struct symbol *evaluate_cast(stru
 	if (t1 == &void_ctype)
 		goto out;
 
-	type1 = t1->type;
-	if (type1 == SYM_ARRAY || type1 == SYM_UNION || type1 == SYM_STRUCT)
+	if (class1 & TYPE_COMPOUND)
 		warning(expr->pos, "cast to non-scalar");
 
 	t2 = target->ctype;
@@ -2216,19 +2229,15 @@ static struct symbol *evaluate_cast(stru
 		sparse_error(expr->pos, "cast from unknown type");
 		goto out;
 	}
-	if (t2->type == SYM_NODE)
-		t2 = t2->ctype.base_type;
-	if (t2->type == SYM_ENUM)
-		t2 = t2->ctype.base_type;
+	class2 = classify_type(t2, &t2);
 
-	type2 = t2->type;
-	if (type2 == SYM_ARRAY || type2 == SYM_UNION || type2 == SYM_STRUCT)
+	if (class2 & TYPE_COMPOUND)
 		warning(expr->pos, "cast from non-scalar");
 
 	if (!(ctype->ctype.modifiers & MOD_FORCE) && t1 != t2) {
-		if (t1->type == SYM_RESTRICT)
+		if (class1 & TYPE_RESTRICT)
 			warning(expr->pos, "cast to restricted type");
-		if (t2->type == SYM_RESTRICT)
+		if (class2 & TYPE_RESTRICT)
 			warning(expr->pos, "cast from restricted type");
 	}
 
-- 
1.4.2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/7] kill NS_INVISIBLEMACRO, introduce NS_UNDEF ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 2/7] kill NS_INVISIBLEMACRO, introduce NS_UNDEF
Date: Mon, 02 Jan 2006 18:04:04 +0000
Message-ID: <43B97CD5.493EF3C2 () tv-sign ! ru>
--------------------
With this patch handle_undef() doesn't corrupt the builtin macros.

This (imho) cleanups the code and is used in the next patches.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060101/symbol.h~2_UNDEF	2006-01-01 00:13:52.000000000 +0300
+++ git-snapshot-20060101/symbol.h	2006-01-02 20:10:26.000000000 +0300
@@ -32,7 +32,7 @@ enum namespace {
 	NS_SYMBOL = 16,
 	NS_ITERATOR = 32,
 	NS_PREPROCESSOR = 64,
-	NS_INVISIBLEMACRO = 128,
+	NS_UNDEF = 128,
 };
 
 enum type {
--- git-snapshot-20060101/scope.c~2_UNDEF	2006-01-01 00:13:52.000000000 +0300
+++ git-snapshot-20060101/scope.c	2006-01-02 20:28:40.000000000 +0300
@@ -41,7 +41,6 @@ static void start_scope(struct scope **s
 void start_file_scope(void)
 {
 	struct scope *scope = __alloc_scope(0);
-	struct symbol *sym;
 
 	memset(scope, 0, sizeof(*scope));
 	scope->next = &builtin_scope;
@@ -50,12 +49,6 @@ void start_file_scope(void)
 	/* top-level stuff defaults to file scopt, "extern" etc will choose global scope */
 	function_scope = scope;
 	block_scope = scope;
-
-	/* Make the builtin macros visible again */
-	FOR_EACH_PTR(builtin_scope.symbols, sym) {
-		if (sym->namespace == NS_INVISIBLEMACRO)
-			sym->namespace = NS_MACRO;
-	} END_FOR_EACH_PTR(sym);
 }
 
 void start_symbol_scope(void)
--- git-snapshot-20060101/pre-process.c~2_UNDEF	2006-01-02 20:02:57.000000000 +0300
+++ git-snapshot-20060101/pre-process.c	2006-01-02 20:34:38.000000000 +0300
@@ -103,7 +103,7 @@ static void replace_with_integer(struct 
 
 static struct symbol *lookup_macro(struct ident *ident)
 {
-	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_INVISIBLEMACRO);
+	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_UNDEF);
 	if (sym && sym->namespace != NS_MACRO)
 		sym = NULL;
 	return sym;
@@ -1134,8 +1134,15 @@ static int handle_undef(struct stream *s
 	}
 
 	sym = lookup_macro(left->ident);
-	if (sym)
-		sym->namespace = NS_INVISIBLEMACRO;
+	if (!sym)
+		return 1;
+
+	if (sym->scope != file_scope) {
+		sym = alloc_symbol(left->pos, SYM_NODE);
+		bind_symbol(sym, left->ident, NS_MACRO);
+	}
+
+	sym->namespace = NS_UNDEF;
 
 	return 1;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3 RESEND] Add -Wno-cast-truncate ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH 3/3 RESEND] Add -Wno-cast-truncate
Date: Wed, 30 Aug 2006 01:17:31 +0000
Message-ID: <1156900651.5203.14.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add the ability to turn off checks for casts that truncate constant values
using -Wno-cast-truncate, helpful when attempting to track down a particular
class of warnings only without losing them amongst others.  Checks for
truncating casts default to on, so this does not change the default behavior
of sparse.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 expand.c |    4 ++++
 lib.c    |    2 ++
 lib.h    |    1 +
 3 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/expand.c b/expand.c
index 474344d..882d80e 100644
--- a/expand.c
+++ b/expand.c
@@ -94,6 +94,10 @@ Int:
 	mask = signmask | (signmask-1);
 	expr->value = value & mask;
 
+	// Stop here unless checking for truncation
+	if (!Wcast_truncate)
+		return;
+	
 	// Check if we dropped any bits..
 	oldsignmask = 1ULL << (old_size-1);
 	oldmask = oldsignmask | (oldsignmask-1);
diff --git a/lib.c b/lib.c
index 8fac8ae..fb5e54e 100644
--- a/lib.c
+++ b/lib.c
@@ -169,6 +169,7 @@ static char pre_buffer[8192];
 
 int Wdefault_bitfield_sign = 0;
 int Wone_bit_signed_bitfield = 1;
+int Wcast_truncate = 1;
 int Wbitwise = 0;
 int Wtypesign = 0;
 int Wcontext = 0;
@@ -317,6 +318,7 @@ static const struct warning {
 	{ "cast-to-as", &Wcast_to_address_space },
 	{ "decl", &Wdecl },
 	{ "one-bit-signed-bitfield", &Wone_bit_signed_bitfield },
+	{ "cast-truncate", &Wcast_truncate },
 	{ "ptr-subtraction-blows", &Wptr_subtraction_blows },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
 	{ "undef", &Wundefined_preprocessor },
diff --git a/lib.h b/lib.h
index 0b45c67..207a8ec 100644
--- a/lib.h
+++ b/lib.h
@@ -83,6 +83,7 @@ extern int Wenum_mismatch;
 extern int Wdecl;
 extern int Wone_bit_signed_bitfield;
 extern int Wshadow;
+extern int Wcast_truncate;
 
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/4] fix (SIGSEGV) handle_define() on #weak_define ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 3/4] fix (SIGSEGV) handle_define() on #weak_define
Date: Mon, 04 Sep 2006 11:46:13 +0000
Message-ID: <20060904154157.GA6434 () oleg>
--------------------
This patch fixes 2 bugs in do_handle_define()

1.
	do_handle_define:
		...
		if (sym->weak)
			goto replace_it;

	This is wrong, we should allocate a new symbol if
	sym->scope != file_scope, example:

		inc.h:
			#weak_define FOO default

		redefine.c:
			#define FOO redefine
			FOO

		default.c:
			FOO

		$ ./test-lexing -include inc.h redefine.c default.c
		redefine
		Segmentation fault


2.
	'#define' shouldn't inherit a weak attribute if the symbol
	was previously weak_define'd. Example:

		#weak_define	FOO	1
		#define		FOO	1	// has no effect
		#define		FOO	2	// redefined without warning

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060904/pre-process.c~3WEAK	2006-09-04 18:20:23.000000000 +0400
+++ git-snapshot-20060904/pre-process.c	2006-09-04 19:16:45.000000000 +0400
@@ -1061,6 +1061,7 @@ static int do_handle_define(struct strea
 	struct token *left = token->next;
 	struct symbol *sym;
 	struct ident *name;
+	int ret;
 
 	if (token_type(left) != TOKEN_IDENT) {
 		sparse_error(token->pos, "expected identifier to 'define'");
@@ -1082,35 +1083,43 @@ static int do_handle_define(struct strea
 	if (!expansion)
 		return 1;
 
+	ret = 1;
 	sym = lookup_macro(name);
-	if (sym) {
-		if (token_list_different(sym->expansion, expansion) || 
-		    token_list_different(sym->arglist, arglist)) {
-			if (sym->weak)
-				goto replace_it;
-			if (weak)
-				return 1;
-			warning(left->pos, "preprocessor token %.*s redefined",
-					name->len, name->name);
-			info(sym->pos, "this was the original definition");
-
-			/* Don't overwrite global defs */
-			if (sym->scope != file_scope)
-				goto allocate_new;
-			goto replace_it;
-		}
-		return 1;
-	}
-allocate_new:
-	sym = alloc_symbol(left->pos, SYM_NODE);
-	bind_symbol(sym, name, NS_MACRO);
-
-replace_it:
-	sym->expansion = expansion;
-	sym->arglist = arglist;
-	sym->weak = weak;
-	__free_token(token);		/* Free the "define" token, but not the rest of the line */
-	return 0;
+	if (sym) {
+		int clean;
+
+		if (weak > sym->weak)
+			goto out;
+
+		clean = (weak == sym->weak);
+
+		if (token_list_different(sym->expansion, expansion) ||
+		    token_list_different(sym->arglist, arglist)) {
+			ret = 0;
+			if (clean && !weak) {
+				warning(left->pos, "preprocessor token %.*s redefined",
+						name->len, name->name);
+				info(sym->pos, "this was the original definition");
+			}
+		} else if (clean)
+			goto out;
+	}
+
+	if (!sym || sym->scope != file_scope) {
+		sym = alloc_symbol(left->pos, SYM_NODE);
+		bind_symbol(sym, name, NS_MACRO);
+		ret = 0;
+	}
+
+	if (!ret) {
+		sym->expansion = expansion;
+		sym->arglist = arglist;
+		__free_token(token);	/* Free the "define" token, but not the rest of the line */
+	}
+
+	sym->weak = weak;
+out:
+	return ret;
 }
 
 static int handle_define(struct stream *stream, struct token **line, struct token *token)


-- 
VGER BF report: U 0.499562
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/7] evaluate_compare() can just use evaluate_arith() for non-pointer cases ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 3/7] evaluate_compare() can just use evaluate_arith() for non-pointer cases
Date: Sun, 01 Oct 2006 13:57:31 +0000
Message-ID: <E1GU1ox-0006vS-RC () ZenIV ! linux ! org ! uk>
--------------------

---
 evaluate.c |   17 +----------------
 1 files changed, 1 insertions(+), 16 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index b3a79e7..1d33c58 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -999,26 +999,11 @@ static struct symbol *evaluate_compare(s
 		goto OK;
 	}
 
-	ctype = compatible_integer_binop(&expr->left, &expr->right);
+	ctype = evaluate_arith(expr, 1);
 	if (ctype) {
 		if (ctype->ctype.modifiers & MOD_UNSIGNED)
 			expr->op = modify_for_unsigned(expr->op);
-		goto OK;
-	}
-
-	ctype = compatible_float_binop(&expr->left, &expr->right);
-	if (ctype)
-		goto OK;
-
-	ctype = compatible_restricted_binop(expr->op, &expr->left, &expr->right);
-	if (ctype) {
-		if (ctype->ctype.modifiers & MOD_UNSIGNED)
-			expr->op = modify_for_unsigned(expr->op);
-		goto OK;
 	}
-
-	bad_expr_type(expr);
-
 OK:
 	expr->ctype = &bool_ctype;
 	return &bool_ctype;
-- 
1.4.2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/7] fix redefine of #weak_define ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 3/7] fix redefine of #weak_define
Date: Mon, 02 Jan 2006 18:04:04 +0000
Message-ID: <43B97CDC.4BA569C0 () tv-sign ! ru>
--------------------
This patch fixes 2 bugs in do_handle_define()

1.	if (sym->weak)
		goto replace_it;

	This is wrong, we should allocate a new symbol if
	sym->scope != file_scope, example:

	inc.h:
		#weak_define FOO default

	redefine.c:
		#define FOO redefine
		FOO

	default.c:
		FOO

	$ ./test-lexing -include inc.h redefine.c default.c
	redefine
	Segmentation fault

2.	if (token_list_different(...)) {
		...
	}
	return 1;

	This is wrong too:

		#weak_define	FOO	1
		#define		FOO	1	// has no effect
		#define		FOO	2	// redefined without warning


Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060101/pre-process.c~3_WEAK	2006-01-02 20:34:38.000000000 +0300
+++ git-snapshot-20060101/pre-process.c	2006-01-02 22:45:36.000000000 +0300
@@ -1061,6 +1061,7 @@ static int do_handle_define(struct strea
 	struct token *left = token->next;
 	struct symbol *sym;
 	struct ident *name;
+	int ret;
 
 	if (token_type(left) != TOKEN_IDENT) {
 		sparse_error(token->pos, "expected identifier to 'define'");
@@ -1082,35 +1083,43 @@ static int do_handle_define(struct strea
 	if (!expansion)
 		return 1;
 
+	ret = 1;
 	sym = lookup_macro(name);
-	if (sym) {
-		if (token_list_different(sym->expansion, expansion) || 
-		    token_list_different(sym->arglist, arglist)) {
-			if (sym->weak)
-				goto replace_it;
-			if (weak)
-				return 1;
-			warning(left->pos, "preprocessor token %.*s redefined",
-					name->len, name->name);
-			info(sym->pos, "this was the original definition");
-
-			/* Don't overwrite global defs */
-			if (sym->scope != file_scope)
-				goto allocate_new;
-			goto replace_it;
-		}
-		return 1;
-	}
-allocate_new:
-	sym = alloc_symbol(left->pos, SYM_NODE);
-	bind_symbol(sym, name, NS_MACRO);
-
-replace_it:
-	sym->expansion = expansion;
-	sym->arglist = arglist;
-	sym->weak = weak;
-	__free_token(token);		/* Free the "define" token, but not the rest of the line */
-	return 0;
+	if (sym) {
+		int clean;
+
+		if (weak > sym->weak)
+			goto out;
+
+		clean = (weak == sym->weak);
+
+		if (token_list_different(sym->expansion, expansion) ||
+		    token_list_different(sym->arglist, arglist)) {
+			ret = 0;
+			if (clean && !weak) {
+				warning(left->pos, "preprocessor token %.*s redefined",
+						name->len, name->name);
+				info(sym->pos, "this was the original definition");
+			}
+		} else if (clean)
+			goto out;
+	}
+
+	if (!sym || sym->scope != file_scope) {
+		sym = alloc_symbol(left->pos, SYM_NODE);
+		bind_symbol(sym, name, NS_MACRO);
+		ret = 0;
+	}
+
+	if (!ret) {
+		sym->expansion = expansion;
+		sym->arglist = arglist;
+		__free_token(token);	/* Free the "define" token, but not the rest of the line */
+	}
+
+	sym->weak = weak;
+out:
+	return ret;
 }
 
 static int handle_define(struct stream *stream, struct token **line, struct token *token)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/4] fix loss of 'weak' attribute on usage ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 4/4] fix loss of 'weak' attribute on usage
Date: Mon, 04 Sep 2006 11:46:14 +0000
Message-ID: <20060904154211.GA6437 () oleg>
--------------------
When NS_MACRO symbol is used, sparse clears it's 'weak' flag.
This is bad for multifile parsing, and wrong:

	#weak_define FOO 1
	FOO
	#weak_define FOO 2	// silently ignored

After this patch sparse never writes to NS_MACRO symbols from
another scope.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060904/symbol.h~4USED	2006-09-04 18:20:23.000000000 +0400
+++ git-snapshot-20060904/symbol.h	2006-09-04 19:22:36.000000000 +0400
@@ -97,6 +97,7 @@ struct symbol {
 		struct /* NS_MACRO */ {
 			struct token *expansion;
 			struct token *arglist;
+			struct scope *used_in;
 		};
 		struct /* NS_PREPROCESSOR */ {
 			int (*handler)(struct stream *, struct token **, struct token *);
--- git-snapshot-20060904/pre-process.c~4USED	2006-09-04 19:17:22.000000000 +0400
+++ git-snapshot-20060904/pre-process.c	2006-09-04 19:22:36.000000000 +0400
@@ -114,7 +114,7 @@ static int token_defined(struct token *t
 	if (token_type(token) == TOKEN_IDENT) {
 		struct symbol *sym = lookup_macro(token->ident);
 		if (sym) {
-			sym->weak = 0;
+			sym->used_in = file_scope;
 			return 1;
 		}
 		return 0;
@@ -143,7 +143,7 @@ static int expand_one_symbol(struct toke
 
 	sym = lookup_macro(token->ident);
 	if (sym) {
-		sym->weak = 0;
+		sym->used_in = file_scope;
 		return expand(list, sym);
 	}
 	if (token->ident == &__LINE___ident) {
@@ -1096,7 +1096,7 @@ static int do_handle_define(struct strea
 		if (token_list_different(sym->expansion, expansion) ||
 		    token_list_different(sym->arglist, arglist)) {
 			ret = 0;
-			if (clean && !weak) {
+			if ((clean && !weak) || sym->used_in == file_scope) {
 				warning(left->pos, "preprocessor token %.*s redefined",
 						name->len, name->name);
 				info(sym->pos, "this was the original definition");
@@ -1117,6 +1117,7 @@ static int do_handle_define(struct strea
 		__free_token(token);	/* Free the "define" token, but not the rest of the line */
 	}
 
+	sym->used_in = NULL;
 	sym->weak = weak;
 out:
 	return ret;
@@ -1152,6 +1153,7 @@ static int handle_undef(struct stream *s
 	}
 
 	sym->namespace = NS_UNDEF;
+	sym->used_in = NULL;
 
 	return 1;
 }


-- 
VGER BF report: U 0.500211
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/7] fix 'weak' attribute loss ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 4/7] fix 'weak' attribute loss
Date: Mon, 02 Jan 2006 18:04:13 +0000
Message-ID: <43B97CEC.6E90F4B3 () tv-sign ! ru>
--------------------
When NS_MACRO symbol is used, sparse clears it's 'weak' flag.
This is bad for multifile parsing, and wrong:

	#weak_define FOO 1
	FOO
	#weak_define FOO 2	// silently ignored

After this patch sparse never writes to NS_MACRO symbols from
another scope (except ->used_in).

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060101/symbol.h~4_USED	2006-01-02 20:10:26.000000000 +0300
+++ git-snapshot-20060101/symbol.h	2006-01-02 22:51:09.000000000 +0300
@@ -87,6 +87,7 @@ struct symbol {
 		struct /* NS_MACRO */ {
 			struct token *expansion;
 			struct token *arglist;
+			struct scope *used_in;
 		};
 		struct /* NS_PREPROCESSOR */ {
 			int (*handler)(struct stream *, struct token **, struct token *);
--- git-snapshot-20060101/pre-process.c~4_USED	2006-01-02 22:48:30.000000000 +0300
+++ git-snapshot-20060101/pre-process.c	2006-01-02 23:15:07.000000000 +0300
@@ -114,7 +114,7 @@ static int token_defined(struct token *t
 	if (token_type(token) == TOKEN_IDENT) {
 		struct symbol *sym = lookup_macro(token->ident);
 		if (sym) {
-			sym->weak = 0;
+			sym->used_in = file_scope;
 			return 1;
 		}
 		return 0;
@@ -143,7 +143,7 @@ static int expand_one_symbol(struct toke
 
 	sym = lookup_macro(token->ident);
 	if (sym) {
-		sym->weak = 0;
+		sym->used_in = file_scope;
 		return expand(list, sym);
 	}
 	if (token->ident == &__LINE___ident) {
@@ -1096,7 +1096,7 @@ static int do_handle_define(struct strea
 		if (token_list_different(sym->expansion, expansion) ||
 		    token_list_different(sym->arglist, arglist)) {
 			ret = 0;
-			if (clean && !weak) {
+			if ((clean && !weak) || sym->used_in == file_scope) {
 				warning(left->pos, "preprocessor token %.*s redefined",
 						name->len, name->name);
 				info(sym->pos, "this was the original definition");
@@ -1117,6 +1117,7 @@ static int do_handle_define(struct strea
 		__free_token(token);	/* Free the "define" token, but not the rest of the line */
 	}
 
+	sym->used_in = NULL;
 	sym->weak = weak;
 out:
 	return ret;
@@ -1152,6 +1153,7 @@ static int handle_undef(struct stream *s
 	}
 
 	sym->namespace = NS_UNDEF;
+	sym->used_in = NULL;
 
 	return 1;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/7] merged compatible_..._binop() into single function ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 5/7] merged compatible_..._binop() into single function
Date: Sun, 01 Oct 2006 13:57:51 +0000
Message-ID: <E1GU1pH-0006yN-Sq () ZenIV ! linux ! org ! uk>
--------------------

All these guys are really pieces of usual arithmetic conversions;
doesn't make sense to handle them separately, especially if we
want to recover from mismatches in __bitwise__, etc. by letting
them degrade to corresponding integer types.
---
 evaluate.c |  140 ++++++++++++++++++++++++++----------------------------------
 1 files changed, 61 insertions(+), 79 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 9ff3983..7f4810d 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -398,61 +398,6 @@ static struct symbol *bad_expr_type(stru
 	return expr->ctype = &bad_ctype;
 }
 
-static struct symbol *compatible_float_binop(struct expression **lp, struct expression **rp)
-{
-	struct expression *left = *lp, *right = *rp;
-	struct symbol *ltype = left->ctype, *rtype = right->ctype;
-
-	if (ltype->type == SYM_NODE)
-		ltype = ltype->ctype.base_type;
-	if (rtype->type == SYM_NODE)
-		rtype = rtype->ctype.base_type;
-	if (is_float_type(ltype)) {
-		if (is_int_type(rtype))
-			goto Left;
-		if (is_float_type(rtype)) {
-			unsigned long lmod = ltype->ctype.modifiers;
-			unsigned long rmod = rtype->ctype.modifiers;
-			lmod &= MOD_LONG | MOD_LONGLONG;
-			rmod &= MOD_LONG | MOD_LONGLONG;
-			if (lmod == rmod)
-				return ltype;
-			if (lmod & ~rmod)
-				goto Left;
-			else
-				goto Right;
-		}
-		return NULL;
-	}
-	if (!is_float_type(rtype) || !is_int_type(ltype))
-		return NULL;
-Right:
-	*lp = cast_to(left, rtype);
-	return rtype;
-Left:
-	*rp = cast_to(right, ltype);
-	return ltype;
-}
-
-static struct symbol *compatible_integer_binop(struct expression **lp, struct expression **rp)
-{
-	struct expression *left = *lp, *right = *rp;
-	struct symbol *ltype = left->ctype, *rtype = right->ctype;
-
-	if (ltype->type == SYM_NODE)
-		ltype = ltype->ctype.base_type;
-	if (rtype->type == SYM_NODE)
-		rtype = rtype->ctype.base_type;
-	if (is_int_type(ltype) && is_int_type(rtype)) {
-		struct symbol *ctype = bigger_int_type(ltype, rtype);
-
-		*lp = cast_to(left, ctype);
-		*rp = cast_to(right, ctype);
-		return ctype;
-	}
-	return NULL;
-}
-
 static int restricted_value(struct expression *v, struct symbol *type)
 {
 	if (v->type != EXPR_VALUE)
@@ -514,33 +459,70 @@ static struct symbol *restricted_binop_t
 	return ctype;
 }
 
-static struct symbol *compatible_restricted_binop(int op, struct expression **lp, struct expression **rp)
+static struct symbol *usual_conversions(int op,
+					struct expression **left,
+					struct expression **right,
+					int lclass, int rclass,
+					struct symbol *ltype,
+					struct symbol *rtype)
 {
-	struct expression *left = *lp, *right = *rp;
-	struct symbol *ltype, *rtype;
-	int lclass = classify_type(left->ctype, &ltype);
-	int rclass = classify_type(right->ctype, &rtype);
+	struct symbol *ctype;
 
-	warn_for_different_enum_types(right->pos, left->ctype, right->ctype);
+	warn_for_different_enum_types((*right)->pos, (*left)->ctype, (*right)->ctype);
+
+	if ((lclass | rclass) & TYPE_RESTRICT)
+		goto Restr;
+
+	if (!(lclass & TYPE_FLOAT)) {
+		if (!(rclass & TYPE_FLOAT))
+			ctype = bigger_int_type(ltype, rtype);
+		else
+			ctype = rtype;
+	} else if (rclass & TYPE_FLOAT) {
+		unsigned long lmod = ltype->ctype.modifiers;
+		unsigned long rmod = rtype->ctype.modifiers;
+		if (rmod & ~lmod & (MOD_LONG | MOD_LONGLONG))
+			ctype = rtype;
+		else
+			ctype = ltype;
+	} else
+		ctype = ltype;
+
+Convert:
+	*left = cast_to(*left, ctype);
+	*right = cast_to(*right, ctype);
+	return ctype;
 
-	if (!(lclass & rclass & TYPE_RESTRICT))
-		return NULL;
+Restr:
+	ctype = restricted_binop_type(op, *left, *right,
+				      lclass, rclass, ltype, rtype);
+	if (ctype)
+		goto Convert;
 
-	return restricted_binop_type(op, left, right,
-				     lclass, rclass, ltype, rtype);
+	return NULL;
 }
 
 static struct symbol *evaluate_arith(struct expression *expr, int float_ok)
 {
-	struct symbol *ctype = compatible_integer_binop(&expr->left, &expr->right);
-	if (!ctype && float_ok)
-		ctype = compatible_float_binop(&expr->left, &expr->right);
-	if (!ctype)
-		ctype = compatible_restricted_binop(expr->op, &expr->left, &expr->right);
+	struct symbol *ltype, *rtype;
+	int lclass = classify_type(expr->left->ctype, &ltype);
+	int rclass = classify_type(expr->right->ctype, &rtype);
+	struct symbol *ctype;
+
+	if (!(lclass & rclass & TYPE_NUM))
+		goto Bad;
+
+	if (!float_ok && (lclass | rclass) & TYPE_FLOAT)
+		goto Bad;
+
+	ctype = usual_conversions(expr->op, &expr->left, &expr->right,
+				  lclass, rclass, ltype, rtype);
 	if (ctype) {
 		expr->ctype = ctype;
 		return ctype;
 	}
+
+Bad:
 	return bad_expr_type(expr);
 }
 
@@ -1048,6 +1030,7 @@ static struct symbol *evaluate_condition
 {
 	struct expression **true;
 	struct symbol *ctype, *ltype, *rtype;
+	int lclass, rclass;
 	const char * typediff;
 
 	if (!evaluate_conditional(expr->conditional, 0))
@@ -1067,18 +1050,17 @@ static struct symbol *evaluate_condition
 		true = &expr->cond_true;
 	}
 
-	ctype = compatible_integer_binop(true, &expr->cond_false);
-	if (ctype)
-		goto out;
+	lclass = classify_type(ltype, &ltype);
+	rclass = classify_type(rtype, &rtype);
+	if (lclass & rclass & TYPE_NUM) {
+		ctype = usual_conversions('?', true, &expr->cond_false,
+					  lclass, rclass, ltype, rtype);
+		if (ctype)
+			goto out;
+	}
 	ctype = compatible_ptr_type(*true, expr->cond_false);
 	if (ctype)
 		goto out;
-	ctype = compatible_float_binop(true, &expr->cond_false);
-	if (ctype)
-		goto out;
-	ctype = compatible_restricted_binop('?', true, &expr->cond_false);
-	if (ctype)
-		goto out;
 	ctype = ltype;
 	typediff = type_difference(ltype, rtype, MOD_IGN, MOD_IGN);
 	if (!typediff)
-- 
1.4.2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/7] prepare for #strong_{define,undef} ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 5/7] prepare for #strong_{define,undef}
Date: Mon, 02 Jan 2006 18:04:19 +0000
Message-ID: <43B97CF1.8A073C26 () tv-sign ! ru>
--------------------
This patch renames symbol->weak to symbol->attr and adds
symbolic names for it's values.

I don't like the new name, and will be happy to rename if
you suggest me something different.

Probably it is also better to move ->attr into the NS_MACRO
part of the union and make it integer.

No changes in pre-process.o

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060101/symbol.h~5_PREP	2006-01-02 22:51:09.000000000 +0300
+++ git-snapshot-20060101/symbol.h	2006-01-02 23:36:40.000000000 +0300
@@ -70,10 +70,13 @@ struct symbol_op {
 extern int expand_safe_p(struct expression *expr, int cost);
 extern int expand_constant_p(struct expression *expr, int cost);
 
+#define SYM_ATTR_WEAK		1
+#define SYM_ATTR_NORMAL		0
+
 struct symbol {
 	enum namespace namespace:8;
 	enum type type:8;
-	unsigned char used:1, weak:1;
+	unsigned char used:1, attr:1;
 	struct position pos;		/* Where this symbol was declared */
 	struct ident *ident;		/* What identifier this symbol is associated with */
 	struct symbol *next_id;		/* Next semantic symbol that shares this identifier */
--- git-snapshot-20060101/pre-process.c~5_PREP	2006-01-02 23:15:07.000000000 +0300
+++ git-snapshot-20060101/pre-process.c	2006-01-02 23:45:32.000000000 +0300
@@ -1055,7 +1055,7 @@ Earg:
 	return NULL;
 }
 
-static int do_handle_define(struct stream *stream, struct token **line, struct token *token, int weak)
+static int do_handle_define(struct stream *stream, struct token **line, struct token *token, int attr)
 {
 	struct token *arglist, *expansion;
 	struct token *left = token->next;
@@ -1088,15 +1088,16 @@ static int do_handle_define(struct strea
 	if (sym) {
 		int clean;
 
-		if (weak > sym->weak)
+		if (attr > sym->attr)
 			goto out;
 
-		clean = (weak == sym->weak);
+		clean = (attr == sym->attr);
 
 		if (token_list_different(sym->expansion, expansion) ||
 		    token_list_different(sym->arglist, arglist)) {
 			ret = 0;
-			if ((clean && !weak) || sym->used_in == file_scope) {
+			if ((clean && attr == SYM_ATTR_NORMAL)
+					|| sym->used_in == file_scope) {
 				warning(left->pos, "preprocessor token %.*s redefined",
 						name->len, name->name);
 				info(sym->pos, "this was the original definition");
@@ -1118,19 +1119,19 @@ static int do_handle_define(struct strea
 	}
 
 	sym->used_in = NULL;
-	sym->weak = weak;
+	sym->attr = attr;
 out:
 	return ret;
 }
 
 static int handle_define(struct stream *stream, struct token **line, struct token *token)
 {
-	return do_handle_define(stream, line, token, 0);
+	return do_handle_define(stream, line, token, SYM_ATTR_NORMAL);
 }
 
 static int handle_weak_define(struct stream *stream, struct token **line, struct token *token)
 {
-	return do_handle_define(stream, line, token, 1);
+	return do_handle_define(stream, line, token, SYM_ATTR_WEAK);
 }
 
 static int handle_undef(struct stream *stream, struct token **line, struct token *token)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/7] implement #strong_define ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 6/7] implement #strong_define
Date: Mon, 02 Jan 2006 18:04:23 +0000
Message-ID: <43B97CF5.B57A133A () tv-sign ! ru>
--------------------
Example

	#strong_define FOO 1

	#undef	FOO	// silently ignored
	#define	FOO 2	// silently ignored

This allows (for example) to override CONFIG_XXX values without
editing include/linux/autoconf.h

I think this is useful. If you think differently, I will appreciate
your comments on this patch correctness.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060101/symbol.h~6_DEF	2006-01-02 23:36:40.000000000 +0300
+++ git-snapshot-20060101/symbol.h	2006-01-02 23:51:36.000000000 +0300
@@ -70,13 +70,14 @@ struct symbol_op {
 extern int expand_safe_p(struct expression *expr, int cost);
 extern int expand_constant_p(struct expression *expr, int cost);
 
-#define SYM_ATTR_WEAK		1
-#define SYM_ATTR_NORMAL		0
+#define SYM_ATTR_WEAK		0
+#define SYM_ATTR_NORMAL		1
+#define SYM_ATTR_STRONG		2
 
 struct symbol {
 	enum namespace namespace:8;
 	enum type type:8;
-	unsigned char used:1, attr:1;
+	unsigned char used:1, attr:2;
 	struct position pos;		/* Where this symbol was declared */
 	struct ident *ident;		/* What identifier this symbol is associated with */
 	struct symbol *next_id;		/* Next semantic symbol that shares this identifier */
--- git-snapshot-20060101/pre-process.c~6_DEF	2006-01-02 23:45:31.000000000 +0300
+++ git-snapshot-20060101/pre-process.c	2006-01-03 00:28:36.000000000 +0300
@@ -1088,7 +1088,7 @@ static int do_handle_define(struct strea
 	if (sym) {
 		int clean;
 
-		if (attr > sym->attr)
+		if (attr < sym->attr)
 			goto out;
 
 		clean = (attr == sym->attr);
@@ -1134,6 +1134,11 @@ static int handle_weak_define(struct str
 	return do_handle_define(stream, line, token, SYM_ATTR_WEAK);
 }
 
+static int handle_strong_define(struct stream *stream, struct token **line, struct token *token)
+{
+	return do_handle_define(stream, line, token, SYM_ATTR_STRONG);
+}
+
 static int handle_undef(struct stream *stream, struct token **line, struct token *token)
 {
 	struct token *left = token->next;
@@ -1145,7 +1150,7 @@ static int handle_undef(struct stream *s
 	}
 
 	sym = lookup_macro(left->ident);
-	if (!sym)
+	if (!sym || sym->attr > SYM_ATTR_NORMAL)
 		return 1;
 
 	if (sym->scope != file_scope) {
@@ -1565,15 +1570,16 @@ static void init_preprocessor(void)
 		const char *name;
 		int (*handler)(struct stream *, struct token **, struct token *);
 	} normal[] = {
-		{ "define",	handle_define },
-		{ "weak_define",handle_weak_define },
-		{ "undef",	handle_undef },
-		{ "warning",	handle_warning },
-		{ "error",	handle_error },
-		{ "include",	handle_include },
-		{ "include_next",handle_include_next },
-		{ "pragma",	handle_pragma },
-		{ "line",	handle_line },
+		{ "define",		handle_define },
+		{ "weak_define",	handle_weak_define },
+		{ "strong_define",	handle_strong_define },
+		{ "undef",		handle_undef },
+		{ "warning",		handle_warning },
+		{ "error",		handle_error },
+		{ "include",		handle_include },
+		{ "include_next",	handle_include_next },
+		{ "pragma",		handle_pragma },
+		{ "line",		handle_line },
 
 		// our internal preprocessor tokens
 		{ "nostdinc",	   handle_nostdinc },
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/7] saner recovery from endianness errors, part 1. ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 6/7] saner recovery from endianness errors, part 1.
Date: Sun, 01 Oct 2006 13:58:01 +0000
Message-ID: <E1GU1pR-0006zg-TT () ZenIV ! linux ! org ! uk>
--------------------

---
 evaluate.c |   26 +++++++++++++++++---------
 1 files changed, 17 insertions(+), 9 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 7f4810d..71c46d1 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -473,6 +473,7 @@ static struct symbol *usual_conversions(
 	if ((lclass | rclass) & TYPE_RESTRICT)
 		goto Restr;
 
+Normal:
 	if (!(lclass & TYPE_FLOAT)) {
 		if (!(rclass & TYPE_FLOAT))
 			ctype = bigger_int_type(ltype, rtype);
@@ -499,7 +500,15 @@ Restr:
 	if (ctype)
 		goto Convert;
 
-	return NULL;
+	if (lclass & TYPE_RESTRICT) {
+		warning((*left)->pos, "restricted degrades to integer");
+		ltype = ltype->ctype.base_type;
+	}
+	if (rclass & TYPE_RESTRICT) {
+		warning((*right)->pos, "restricted degrades to integer");
+		rtype = rtype->ctype.base_type;
+	}
+	goto Normal;
 }
 
 static struct symbol *evaluate_arith(struct expression *expr, int float_ok)
@@ -517,10 +526,8 @@ static struct symbol *evaluate_arith(str
 
 	ctype = usual_conversions(expr->op, &expr->left, &expr->right,
 				  lclass, rclass, ltype, rtype);
-	if (ctype) {
-		expr->ctype = ctype;
-		return ctype;
-	}
+	expr->ctype = ctype;
+	return ctype;
 
 Bad:
 	return bad_expr_type(expr);
@@ -1055,8 +1062,7 @@ static struct symbol *evaluate_condition
 	if (lclass & rclass & TYPE_NUM) {
 		ctype = usual_conversions('?', true, &expr->cond_false,
 					  lclass, rclass, ltype, rtype);
-		if (ctype)
-			goto out;
+		goto out;
 	}
 	ctype = compatible_ptr_type(*true, expr->cond_false);
 	if (ctype)
@@ -2670,9 +2676,11 @@ static void check_case_type(struct expre
 	if (!((sclass | cclass) & TYPE_RESTRICT))
 		return;
 
-	if (restricted_binop_type(SPECIAL_EQUAL, case_expr, switch_expr,
+	if (!restricted_binop_type(SPECIAL_EQUAL, case_expr, switch_expr,
 				   cclass, sclass, case_type, switch_type))
-		return;
+		warning(case_expr->pos, "restricted degrades to integer");
+
+	return;
 
 Bad:
 	sparse_error(case_expr->pos, "incompatible types for 'case' statement");
-- 
1.4.2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/7] handle fouled-bitwise ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 7/7] handle fouled-bitwise
Date: Sun, 01 Oct 2006 13:58:11 +0000
Message-ID: <E1GU1pb-00070U-Tt () ZenIV ! linux ! org ! uk>
--------------------

This stuff comes from handling smaller-than-int bitwise types (e.g. __le16).
The problem is in handling things like
	__be16 x, y;
	...
	if (x == (x & ~y))
The code is bitwise-clean, but current sparse can't deduce that.  Operations
allowed on bitwise types have the following property: (type)(x <op> y) can
be substituted for x <op> y in any expression other than sizeof.  That allows
us to ignore usual arithmetical conversions for those types and treat e.g.
| as __be16 x __be16 -> __be16, despite the promotion rules; resulting
semantics will be the same.  However, ~ on smaller-than-int does not have
such property; indeed, ~y is guaranteed to _not_ fit into range of __be16
in the example above.

That causes a lot of unpleasant problems when dealing with e.g. networking
code - IP checksums are 16bit and ~ is often used in their (re)calculations.
The way to deal with that is based on the observation that even though we do
get junk in upper bits, it normally ends up being discarded and sparse can
be taught to prove that.  To do that we need "fouled" conterparts for short
bitwise types.  They will be assigned to (sub)expressions that might carry
junk in upper bits, but trimming those bits would result in the value we'd
get if all operations had been done within the bitwise type.  E.g. in the
example above y would be __be16, ~y - fouled __be16, x & ~y - __be16 again
and x == (x & ~y) - boolean.

Basically, we delay reporting an error on ~<short bitwise> for as long as
possible in hope that taint will be cleansed later.  Exact rules follow:

        * ~short_bitwise => corresponding fouled
        * any arithmetics that would be banned for bitwise => same warning
as if we would have bitwise
        * if t1 is bitwise type and t2 - its fouled analog, then
t1 & t2 => t1, t1 | t2 => t2, t1 ^ t2 => t2.
        * conversion of t2 to t1 is silent (be it passing as argument
or assignment).  Other conversions are banned.
        * x ? t1 : t2 => t2
        * ~t2 => t2 (_not_ t1; something like ~(x ? y : ~y) is still fouled)
        * x ? t2 : t2 => t2, t2 {&,|,^} t2 => t2 (yes, even ^ - same as before).
        * x ? t2 : constant_valid_for_t1 => t2
        * !t2 => warning, ditto for comparisons involving t2 in any way.
        * wrt casts t2 acts exactly as t1 would.
        * for sizeof, typeof and alignof t2 acts as promoted t1.  Note that
fouled can never be an lvalue or have types derived from it - can't happen.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c                |   77 ++++++++++++++++++++++++++++++++++++---------
 parse.c                   |    1 +
 show-parse.c              |    8 +++++
 symbol.c                  |   38 ++++++++++++++++++++++
 symbol.h                  |    5 +++
 validation/foul-bitwise.c |   20 ++++++++++++
 6 files changed, 134 insertions(+), 15 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 71c46d1..0ebbfc7 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -344,6 +344,7 @@ enum {
 	TYPE_FLOAT = 8,
 	TYPE_PTR = 16,
 	TYPE_COMPOUND = 32,
+	TYPE_FOULED = 64,
 };
 
 static inline int classify_type(struct symbol *type, struct symbol **base)
@@ -356,6 +357,7 @@ static inline int classify_type(struct s
 		[SYM_UNION] = TYPE_COMPOUND,
 		[SYM_BITFIELD] = TYPE_NUM | TYPE_BITFIELD,
 		[SYM_RESTRICT] = TYPE_NUM | TYPE_RESTRICT,
+		[SYM_FOULED] = TYPE_NUM | TYPE_RESTRICT | TYPE_FOULED,
 	};
 	if (type->type == SYM_NODE)
 		type = type->ctype.base_type;
@@ -411,26 +413,30 @@ static int restricted_binop(int op, stru
 {
 	switch (op) {
 		case '&':
+		case '=':
+		case SPECIAL_AND_ASSIGN:
+		case SPECIAL_OR_ASSIGN:
+		case SPECIAL_XOR_ASSIGN:
+			return 1;	/* unfoul */
 		case '|':
 		case '^':
 		case '?':
-		case '=':
+			return 2;	/* keep fouled */
 		case SPECIAL_EQUAL:
 		case SPECIAL_NOTEQUAL:
-		case SPECIAL_AND_ASSIGN:
-		case SPECIAL_OR_ASSIGN:
-		case SPECIAL_XOR_ASSIGN:
-			return 0;
+			return 3;	/* warn if fouled */
 		default:
-			return 1;
+			return 0;	/* warn */
 	}
 }
 
-static int restricted_unop(int op, struct symbol *type)
+static int restricted_unop(int op, struct symbol **type)
 {
-	if (op == '~' && type->bit_size >= bits_in_int)
+	if (op == '~') {
+		if ((*type)->bit_size < bits_in_int)
+			*type = befoul(*type);
 		return 0;
-	if (op == '+')
+	} if (op == '+')
 		return 0;
 	return 1;
 }
@@ -445,8 +451,15 @@ static struct symbol *restricted_binop_t
 	struct symbol *ctype = NULL;
 	if (lclass & TYPE_RESTRICT) {
 		if (rclass & TYPE_RESTRICT) {
-			if (ltype == rtype)
+			if (ltype == rtype) {
 				ctype = ltype;
+			} else if (lclass & TYPE_FOULED) {
+				if (ltype->ctype.base_type == rtype)
+					ctype = ltype;
+			} else if (rclass & TYPE_FOULED) {
+				if (rtype->ctype.base_type == ltype)
+					ctype = rtype;
+			}
 		} else {
 			if (!restricted_value(right, ltype))
 				ctype = ltype;
@@ -454,8 +467,22 @@ static struct symbol *restricted_binop_t
 	} else if (!restricted_value(left, rtype))
 		ctype = rtype;
 
-	if (ctype && restricted_binop(op, ctype))
-		ctype = NULL;
+	if (ctype) {
+		switch (restricted_binop(op, ctype)) {
+		case 1:
+			if ((lclass ^ rclass) & TYPE_FOULED)
+				ctype = ctype->ctype.base_type;
+			break;
+		case 3:
+			if (!(lclass & rclass & TYPE_FOULED))
+				break;
+		case 0:
+			ctype = NULL;
+		default:
+			break;
+		}
+	}
+
 	return ctype;
 }
 
@@ -503,10 +530,14 @@ Restr:
 	if (lclass & TYPE_RESTRICT) {
 		warning((*left)->pos, "restricted degrades to integer");
 		ltype = ltype->ctype.base_type;
+		if (is_restricted_type(ltype)) /* was fouled */
+			ltype = ltype->ctype.base_type;
 	}
 	if (rclass & TYPE_RESTRICT) {
 		warning((*right)->pos, "restricted degrades to integer");
 		rtype = rtype->ctype.base_type;
+		if (is_restricted_type(rtype)) /* was fouled */
+			rtype = rtype->ctype.base_type;
 	}
 	goto Normal;
 }
@@ -1104,10 +1135,13 @@ static int compatible_assignment_types(s
 			return 0;
 		}
 		if (tclass & TYPE_RESTRICT) {
-			if (restricted_binop(op, target)) {
+			if (!restricted_binop(op, target)) {
 				sparse_error(expr->pos, "bad restricted assignment");
 				return 0;
 			}
+			/* allowed assignments unfoul */
+			if (sclass & TYPE_FOULED && s->ctype.base_type == t)
+				goto Cast;
 			if (!restricted_value(*rp, target))
 				return 1;
 		} else if (!(sclass & TYPE_RESTRICT))
@@ -1482,7 +1516,10 @@ static struct symbol *evaluate_postop(st
 		sparse_error(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
-	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
+	if (is_restricted_type(ctype) && restricted_unop(expr->op, &ctype)) {
+		sparse_error(expr->pos, "bad operation on restricted");
+		return NULL;
+	} else if (is_fouled_type(ctype) && restricted_unop(expr->op, &ctype)) {
 		sparse_error(expr->pos, "bad operation on restricted");
 		return NULL;
 	}
@@ -1506,7 +1543,9 @@ static struct symbol *evaluate_sign(stru
 		ctype = rtype;
 	} else if (is_float_type(ctype) && expr->op != '~') {
 		/* no conversions needed */
-	} else if (is_restricted_type(ctype) && !restricted_unop(expr->op, ctype)) {
+	} else if (is_restricted_type(ctype) && !restricted_unop(expr->op, &ctype)) {
+		/* no conversions needed */
+	} else if (is_fouled_type(ctype) && !restricted_unop(expr->op, &ctype)) {
 		/* no conversions needed */
 	} else {
 		return bad_expr_type(expr);
@@ -1556,6 +1595,8 @@ static struct symbol *evaluate_preop(str
 			expr->right = alloc_expression(expr->pos, EXPR_FVALUE);
 			expr->right->ctype = ctype;
 			expr->right->fvalue = 0;
+		} else if (is_fouled_type(ctype)) {
+			warning(expr->pos, "restricted degrades to integer");
 		}
 		ctype = &bool_ctype;
 		break;
@@ -1755,6 +1796,8 @@ static struct symbol *evaluate_type_info
 		if (is_restricted_type(sym)) {
 			if (sym->bit_size < bits_in_int && is_promoted(expr))
 				sym = &int_ctype;
+		} else if (is_fouled_type(sym)) {
+			sym = &int_ctype;
 		}
 	}
 	examine_symbol_type(sym);
@@ -2210,6 +2253,10 @@ static struct symbol *evaluate_cast(stru
 	if (class2 & TYPE_COMPOUND)
 		warning(expr->pos, "cast from non-scalar");
 
+	/* allowed cast unfouls */
+	if (class2 & TYPE_FOULED)
+		t2 = t2->ctype.base_type;
+
 	if (!(ctype->ctype.modifiers & MOD_FORCE) && t1 != t2) {
 		if (class1 & TYPE_RESTRICT)
 			warning(expr->pos, "cast to restricted type");
diff --git a/parse.c b/parse.c
index bdd6e29..5c78ac0 100644
--- a/parse.c
+++ b/parse.c
@@ -809,6 +809,7 @@ static struct token *declaration_specifi
 		type->type = SYM_RESTRICT;
 		type->ctype.modifiers &= ~MOD_SPECIFIER;
 		ctype->base_type = type;
+		create_fouled(type);
 	}
 	return token;
 }
diff --git a/show-parse.c b/show-parse.c
index 5437a62..2701d17 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -48,6 +48,7 @@ static void do_debug_symbol(struct symbo
 		[SYM_BITFIELD] = "bitf",
 		[SYM_LABEL] = "labl",
 		[SYM_RESTRICT] = "rstr",
+		[SYM_FOULED] = "foul",
 		[SYM_BAD] = "bad.",
 	};
 	struct context *context;
@@ -257,6 +258,9 @@ static void do_show_type(struct symbol *
 	case SYM_RESTRICT:
 		break;
 
+	case SYM_FOULED:
+		break;
+
 	default:
 		prepend(name, "unknown type %d", sym->type);
 		return;
@@ -289,6 +293,10 @@ static void do_show_type(struct symbol *
 		prepend(name, "restricted ");
 		return;
 
+	case SYM_FOULED:
+		prepend(name, "fouled ");
+		return;
+
 	default:
 		break;
 	}
diff --git a/symbol.c b/symbol.c
index 7d64f7f..6c91112 100644
--- a/symbol.c
+++ b/symbol.c
@@ -423,6 +423,9 @@ struct symbol *examine_symbol_type(struc
 	case SYM_RESTRICT:
 		examine_base_type(sym);
 		return sym;
+	case SYM_FOULED:
+		examine_base_type(sym);
+		return sym;
 	default:
 		sparse_error(sym->pos, "Examining unknown symbol type %d", sym->type);
 		break;
@@ -430,6 +433,41 @@ struct symbol *examine_symbol_type(struc
 	return sym;
 }
 
+static struct symbol_list *restr, *fouled;
+
+void create_fouled(struct symbol *type)
+{
+	if (type->bit_size < bits_in_int) {
+		struct symbol *new = alloc_symbol(type->pos, type->type);
+		*new = *type;
+		new->bit_size = bits_in_int;
+		new->type = SYM_FOULED;
+		new->ctype.base_type = type;
+		add_symbol(&restr, type);
+		add_symbol(&fouled, new);
+	}
+}
+
+struct symbol *befoul(struct symbol *type)
+{
+	struct symbol *t1, *t2;
+	while (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	PREPARE_PTR_LIST(restr, t1);
+	PREPARE_PTR_LIST(fouled, t2);
+	for (;;) {
+		if (t1 == type)
+			return t2;
+		if (!t1)
+			break;
+		NEXT_PTR_LIST(t1);
+		NEXT_PTR_LIST(t2);
+	}
+	FINISH_PTR_LIST(t2);
+	FINISH_PTR_LIST(t1);
+	return NULL;
+}
+
 void check_declaration(struct symbol *sym)
 {
 	int warned = 0;
diff --git a/symbol.h b/symbol.h
index f1ed4c1..367c0f5 100644
--- a/symbol.h
+++ b/symbol.h
@@ -52,6 +52,7 @@ enum type {
 	SYM_BITFIELD,
 	SYM_LABEL,
 	SYM_RESTRICT,
+	SYM_FOULED,
 	SYM_BAD,
 };
 
@@ -270,7 +271,11 @@ static inline int get_sym_type(struct sy
 }
 
 #define is_restricted_type(type) (get_sym_type(type) == SYM_RESTRICT)
+#define is_fouled_type(type) (get_sym_type(type) == SYM_FOULED)
 #define is_bitfield_type(type)   (get_sym_type(type) == SYM_BITFIELD)
 extern int is_ptr_type(struct symbol *);
 
+void create_fouled(struct symbol *type);
+struct symbol *befoul(struct symbol *type);
+
 #endif /* SEMANTIC_H */
diff --git a/validation/foul-bitwise.c b/validation/foul-bitwise.c
new file mode 100644
index 0000000..576790d
--- /dev/null
+++ b/validation/foul-bitwise.c
@@ -0,0 +1,20 @@
+typedef unsigned short __attribute__((bitwise))__le16;
+__le16 foo(__le16 a)
+{
+	return a |= ~a;
+}
+
+int baz(__le16 a)
+{
+	return ~a == ~a;
+}
+
+int barf(__le16 a)
+{
+	return a == (a & ~a);
+}
+
+__le16 bar(__le16 a)
+{
+	return -a;
+}
-- 
1.4.2.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/7] implement #strong_undef ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 7/7] implement #strong_undef
Date: Mon, 02 Jan 2006 18:04:28 +0000
Message-ID: <43B97CF8.22FC0C49 () tv-sign ! ru>
--------------------
Example

	// pre-buffer
	#strong_undef CONFIG_SMP

	// include/linux/autoconf.h
	#define CONFIG_SMP 1		// silently ignored

	#ifdef CONFIG_SMP
		...			// not taken
	#endif

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20060101/pre-process.c~7_UNDEF	2006-01-03 00:31:42.000000000 +0300
+++ git-snapshot-20060101/pre-process.c	2006-01-03 00:46:37.000000000 +0300
@@ -1084,14 +1084,14 @@ static int do_handle_define(struct strea
 		return 1;
 
 	ret = 1;
-	sym = lookup_macro(name);
+	sym = lookup_symbol(name, NS_MACRO | NS_UNDEF);
 	if (sym) {
 		int clean;
 
 		if (attr < sym->attr)
 			goto out;
 
-		clean = (attr == sym->attr);
+		clean = (attr == sym->attr && sym->namespace == NS_MACRO);
 
 		if (token_list_different(sym->expansion, expansion) ||
 		    token_list_different(sym->arglist, arglist)) {
@@ -1118,6 +1118,7 @@ static int do_handle_define(struct strea
 		__free_token(token);	/* Free the "define" token, but not the rest of the line */
 	}
 
+	sym->namespace = NS_MACRO;
 	sym->used_in = NULL;
 	sym->attr = attr;
 out:
@@ -1139,7 +1140,7 @@ static int handle_strong_define(struct s
 	return do_handle_define(stream, line, token, SYM_ATTR_STRONG);
 }
 
-static int handle_undef(struct stream *stream, struct token **line, struct token *token)
+static int do_handle_undef(struct stream *stream, struct token **line, struct token *token, int attr)
 {
 	struct token *left = token->next;
 	struct symbol *sym;
@@ -1149,21 +1150,37 @@ static int handle_undef(struct stream *s
 		return 1;
 	}
 
-	sym = lookup_macro(left->ident);
-	if (!sym || sym->attr > SYM_ATTR_NORMAL)
+	sym = lookup_symbol(left->ident, NS_MACRO | NS_UNDEF);
+	if (sym) {
+		if (attr < sym->attr)
+			return 1;
+		if (attr == sym->attr && sym->namespace == NS_UNDEF)
+			return 1;
+	} else if (attr <= SYM_ATTR_NORMAL)
 		return 1;
 
-	if (sym->scope != file_scope) {
+	if (!sym || sym->scope != file_scope) {
 		sym = alloc_symbol(left->pos, SYM_NODE);
 		bind_symbol(sym, left->ident, NS_MACRO);
 	}
 
 	sym->namespace = NS_UNDEF;
 	sym->used_in = NULL;
+	sym->attr = attr;
 
 	return 1;
 }
 
+static int handle_undef(struct stream *stream, struct token **line, struct token *token)
+{
+	return do_handle_undef(stream, line, token, SYM_ATTR_NORMAL);
+}
+
+static int handle_strong_undef(struct stream *stream, struct token **line, struct token *token)
+{
+	return do_handle_undef(stream, line, token, SYM_ATTR_STRONG);
+}
+
 static int preprocessor_if(struct stream *stream, struct token *token, int true)
 {
 	token_type(token) = false_nesting ? TOKEN_SKIP_GROUPS : TOKEN_IF;
@@ -1574,6 +1591,7 @@ static void init_preprocessor(void)
 		{ "weak_define",	handle_weak_define },
 		{ "strong_define",	handle_strong_define },
 		{ "undef",		handle_undef },
+		{ "strong_undef",	handle_strong_undef },
 		{ "warning",		handle_warning },
 		{ "error",		handle_error },
 		{ "include",		handle_include },
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] Add backend to graph basic blocks ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] Add backend to graph basic blocks
Date: Wed, 30 Aug 2006 00:45:20 +0000
Message-ID: <1156898720.5203.9.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add a new backend program which parses the input files, processes them through
the linearization pass, and outputs a graphviz graph of the resulting basic
blocks.  Each entrypoint gets labelled by name, but for now the basic blocks
just get labelled with the address of the basic_block structure.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 .gitignore |    1 +
 Makefile   |    6 +++++-
 graph.c    |   63 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 69 insertions(+), 1 deletions(-)

diff --git a/.gitignore b/.gitignore
index 32d6e70..3e12ce7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,6 +13,7 @@ test-parsing
 obfuscate
 check
 compile
+graph
 test-dissect
 test-linearize
 example
diff --git a/Makefile b/Makefile
index 378ee72..e71f360 100644
--- a/Makefile
+++ b/Makefile
@@ -21,7 +21,7 @@ # LDFLAGS += -Wl,-rpath,$(BINDIR)
 
 PREFIX=$(HOME)
 BINDIR=$(PREFIX)/bin
-PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example test-unssa test-dissect
+PROGRAMS=test-lexing test-parsing obfuscate check compile graph test-linearize example test-unssa test-dissect
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
@@ -77,6 +77,9 @@ obfuscate: obfuscate.o $(LIBS)
 check: check.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+graph: graph.o $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+
 example: example.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
@@ -123,6 +126,7 @@ obfuscate.o: $(LIB_H)
 example.o: $(LIB_H)
 storage.o: $(LIB_H) storage.h
 dissect.o: $(LIB_H) dissect.h
+graph.o: $(LIB_H)
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
diff --git a/graph.c b/graph.c
new file mode 100644
index 0000000..db940ae
--- /dev/null
+++ b/graph.c
@@ -0,0 +1,63 @@
+/* Copyright Â© International Business Machines Corp., 2006
+ *
+ * Author: Josh Triplett <josh@freedesktop.org>
+ *
+ * Licensed under the Open Software License version 1.1
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+
+static void graph_ep(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	printf("ep%p [label=\"%s\",shape=ellipse];\n",
+	       ep, show_ident(ep->name->ident));
+	FOR_EACH_PTR(ep->bbs, bb) {
+		printf("bb%p [shape=record,label=\"bb at %p\"]\n", bb, bb);
+	} END_FOR_EACH_PTR(bb);
+	FOR_EACH_PTR(ep->bbs, bb) {
+		struct basic_block *child;
+		FOR_EACH_PTR(bb->children, child) {
+			printf("bb%p -> bb%p;\n", bb, child);
+		} END_FOR_EACH_PTR(child);
+	} END_FOR_EACH_PTR(bb);
+	printf("ep%p -> bb%p;\n", ep, ep->entry->bb);
+}
+
+static void graph_symbols(struct symbol_list *list)
+{
+	struct symbol *sym;
+
+	FOR_EACH_PTR(list, sym) {
+		struct entrypoint *ep;
+
+		expand_symbol(sym);
+		ep = linearize_symbol(sym);
+		if (ep)
+			graph_ep(ep);
+	} END_FOR_EACH_PTR(sym);
+}
+
+int main(int argc, char **argv)
+{
+	printf("digraph control_flow {\n");
+	graph_symbols(sparse_initialize(argc, argv));
+	while (*argv)
+		graph_symbols(sparse(argv));
+	printf("}\n");
+	return 0;
+}
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] Add support for GCC's __builtin_va_copy ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] Add support for GCC's __builtin_va_copy
Date: Wed, 30 Aug 2006 00:41:19 +0000
Message-ID: <1156898479.5203.5.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
Recent versions of Linux started using this extension, so sparse needs
this fix to avoid parse errors.

 lib.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index feb755a..bb2da7b 100644
--- a/lib.c
+++ b/lib.c
@@ -492,6 +492,7 @@ void create_builtin_stream(void)
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ({ type __va_arg_ret = *(type *)(arg); arg += sizeof(type); __va_arg_ret; })\n");
 	add_pre_buffer("#define __builtin_va_alist (*(void *)0)\n");
 	add_pre_buffer("#define __builtin_va_arg_incr(x) ((x) + 1)\n");
+	add_pre_buffer("#define __builtin_va_copy(dest, src) ({ dest = src; (void)0; })\n");
 	add_pre_buffer("#define __builtin_va_end(arg)\n");
 	add_pre_buffer("#define __builtin_offsetof(type, name) ((__SIZE_TYPE__)&((type *)(0ul))->name)\n");
 
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] Add type information to enum mismatch warning ===

From: Adam DiCarlo <bikko () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] Add type information to enum mismatch warning
Date: Mon, 11 Sep 2006 21:06:14 +0000
Message-ID: <4505CFC6.4000807 () us ! ibm ! com>
--------------------

Signed-off-by: Adam DiCarlo <adam.dicarlo@gmail.com>
---
  evaluate.c |    5 ++++-
  1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 177797a..3076d41 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -253,8 +253,11 @@ warn_for_different_enum_types (struct po
  	if (typea == typeb)
  		return;

-	if (typea->type == SYM_ENUM && typeb->type == SYM_ENUM)
+	if (typea->type == SYM_ENUM && typeb->type == SYM_ENUM) {
  		warning(pos, "mixing different enum types");
+		info(pos, "    %s versus", show_typename(typea));
+		info(pos, "    %s", show_typename(typeb));
+	}
  }

  /*
-- 
1.4.2.ga444
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] Parse and track multiple contexts by expression ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] Parse and track multiple contexts by expression
Date: Wed, 30 Aug 2006 17:14:53 +0000
Message-ID: <1156958093.3418.1.camel () josh-work ! beaverton ! ibm ! com>
--------------------
sparse currently only tracks one global context for __context__ and
__attribute__((context)).  Add support for parsing an additional argument to
each of these which gives a context expression.  For __attribute__((context)),
store each context attribute as a separate context structure containing the
expression, the entry context, and the exit context, and keep a list of these
structures in the ctype.  For __context__, store the context expression in the
context instruction.  Modify the various frontends to adapt to this change,
without changing functionality.

This change should not affect parsing of programs which worked with previous
versions of sparse, unless those programs use comma expressions as arguments
to __context__ or __attribute__((context)), which seems highly dubious and
unlikely.  sparse with -Wcontext generates identical output with or without
this change on Linux 2.6.18-rc4.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 allocate.c   |    1 +
 allocate.h   |    1 +
 check.c      |    8 +++++++-
 linearize.c  |   49 ++++++++++++++++++++++++++++---------------------
 linearize.h  |    1 +
 parse.c      |   36 +++++++++++++++++++++++++-----------
 parse.h      |    5 ++++-
 show-parse.c |   17 +++++++++++++----
 symbol.c     |    9 +++++++--
 symbol.h     |   12 +++++++++++-
 10 files changed, 98 insertions(+), 41 deletions(-)

diff --git a/allocate.c b/allocate.c
index 4894e59..f3d29a6 100644
--- a/allocate.c
+++ b/allocate.c
@@ -113,6 +113,7 @@ void show_allocations(struct allocator_s
 
 ALLOCATOR(ident, "identifiers");
 ALLOCATOR(token, "tokens");
+ALLOCATOR(context, "contexts");
 ALLOCATOR(symbol, "symbols");
 ALLOCATOR(expression, "expressions");
 ALLOCATOR(statement, "statements");
diff --git a/allocate.h b/allocate.h
index ab6bd0a..33703fe 100644
--- a/allocate.h
+++ b/allocate.h
@@ -61,6 +61,7 @@ #define ALLOCATOR(x, n) __ALLOCATOR(stru
 
 DECLARE_ALLOCATOR(ident);
 DECLARE_ALLOCATOR(token);
+DECLARE_ALLOCATOR(context);
 DECLARE_ALLOCATOR(symbol);
 DECLARE_ALLOCATOR(expression);
 DECLARE_ALLOCATOR(statement);
diff --git a/check.c b/check.c
index bbfac44..d327c3b 100644
--- a/check.c
+++ b/check.c
@@ -234,6 +234,8 @@ static void check_instructions(struct en
 static void check_context(struct entrypoint *ep)
 {
 	struct symbol *sym = ep->name;
+	struct context *context;
+	unsigned int in_context = 0, out_context = 0;
 
 	if (verbose && ep->entry->bb->needs) {
 		pseudo_t pseudo;
@@ -246,7 +248,11 @@ static void check_context(struct entrypo
 
 	check_instructions(ep);
 
-	check_bb_context(ep, ep->entry->bb, sym->ctype.in_context, sym->ctype.out_context);
+	FOR_EACH_PTR(sym->ctype.contexts, context) {
+		in_context += context->in;
+		out_context += context->out;
+	} END_FOR_EACH_PTR(context);
+	check_bb_context(ep, ep->entry->bb, in_context, out_context);
 }
 
 static void check_symbols(struct symbol_list *list)
diff --git a/linearize.c b/linearize.c
index f47bad9..8a8a2d3 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1183,7 +1183,8 @@ static pseudo_t linearize_call_expressio
 	struct expression *arg, *fn;
 	struct instruction *insn = alloc_typed_instruction(OP_CALL, expr->ctype);
 	pseudo_t retval, call;
-	int context_diff, check;
+	struct ctype *ctype = NULL;
+	struct context *context;
 
 	if (!expr->ctype) {
 		warning(expr->pos, "call with no type!");
@@ -1197,21 +1198,8 @@ static pseudo_t linearize_call_expressio
 
 	fn = expr->fn;
 
-	check = 0;
-	context_diff = 0;
-	if (fn->ctype) {
-		int in = fn->ctype->ctype.in_context;
-		int out = fn->ctype->ctype.out_context;
-		if (in < 0) {
-			check = 1;
-			in = 0;
-		}
-		if (out < 0) {
-			check = 0;
-			out = 0;
-		}
-		context_diff = out - in;
-	}
+	if (fn->ctype)
+		ctype = &fn->ctype->ctype;
 
 	if (fn->type == EXPR_PREOP) {
 		if (fn->unop->type == EXPR_SYMBOL) {
@@ -1232,11 +1220,29 @@ static pseudo_t linearize_call_expressio
 	insn->target = retval;
 	add_one_insn(ep, insn);
 
-	if (check || context_diff) {
-		insn = alloc_instruction(OP_CONTEXT, 0);
-		insn->increment = context_diff;
-		insn->check = check;
-		add_one_insn(ep, insn);
+	if (ctype) {
+		FOR_EACH_PTR(ctype->contexts, context) {
+			int in = context->in;
+			int out = context->out;
+			int check = 0;
+			int context_diff;
+			if (in < 0) {
+				check = 1;
+				in = 0;
+			}
+			if (out < 0) {
+				check = 0;
+				out = 0;
+			}
+			context_diff = out - in;
+			if (check || context_diff) {
+				insn = alloc_instruction(OP_CONTEXT, 0);
+				insn->increment = context_diff;
+				insn->check = check;
+				insn->context_expr = context->context;
+				add_one_insn(ep, insn);
+			}
+		} END_FOR_EACH_PTR(context);
 	}
 
 	return retval;
@@ -1637,6 +1643,7 @@ static pseudo_t linearize_context(struct
 		value = expr->value;
 
 	insn->increment = value;
+	insn->context_expr = stmt->context;
 	add_one_insn(ep, insn);
 	return VOID;
 }
diff --git a/linearize.h b/linearize.h
index 66a76dc..ac946f3 100644
--- a/linearize.h
+++ b/linearize.h
@@ -105,6 +105,7 @@ struct instruction {
 		struct /* context */ {
 			int increment;
 			int check;
+			struct expression *context_expr;
 		};
 		struct /* asm */ {
 			const char *string;
diff --git a/parse.c b/parse.c
index c536ec2..bdd6e29 100644
--- a/parse.c
+++ b/parse.c
@@ -434,10 +434,17 @@ static const char * handle_attribute(str
 	}
 	if (attribute == &context_ident) {
 		if (expr && expr->type == EXPR_COMMA) {
-			int input = get_expression_value(expr->left);
-			int output = get_expression_value(expr->right);
-			ctype->in_context = input;
-			ctype->out_context = output;
+			struct context *context = alloc_context();
+			if(expr->left->type == EXPR_COMMA) {
+				context->context = expr->left->left;
+				context->in = get_expression_value(
+					expr->left->right);
+			} else {
+				context->context = NULL;
+				context->in = get_expression_value(expr->left);
+			}
+			context->out = get_expression_value(expr->right);
+			add_ptr_list(&ctype->contexts, context);
 			return NULL;
 		}
 		return "expected context input/output values";
@@ -669,9 +676,9 @@ static void apply_ctype(struct position 
 		ctype->modifiers = old | mod | extra;
 	}
 
-	/* Context mask and value */
-	ctype->in_context += thistype->in_context;
-	ctype->out_context += thistype->out_context;
+	/* Context */
+	concat_ptr_list((struct ptr_list *)thistype->contexts,
+	                (struct ptr_list **)&ctype->contexts);
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
@@ -908,16 +915,15 @@ static struct token *pointer(struct toke
 		struct symbol *ptr = alloc_symbol(token->pos, SYM_PTR);
 		ptr->ctype.modifiers = modifiers & ~MOD_STORAGE;
 		ptr->ctype.as = ctype->as;
-		ptr->ctype.in_context += ctype->in_context;
-		ptr->ctype.out_context += ctype->out_context;
+		concat_ptr_list((struct ptr_list *)ctype->contexts,
+				(struct ptr_list **)&ptr->ctype.contexts);
 		ptr->ctype.base_type = base_type;
 
 		base_type = ptr;
 		ctype->modifiers = modifiers & MOD_STORAGE;
 		ctype->base_type = base_type;
 		ctype->as = 0;
-		ctype->in_context = 0;
-		ctype->out_context = 0;
+		free_ptr_list(&ctype->contexts);
 
 		token = declaration_specifiers(token->next, ctype, 1);
 		modifiers = ctype->modifiers;
@@ -1384,6 +1390,14 @@ default_statement:
 		if (token->ident == &__context___ident) {
 			stmt->type = STMT_CONTEXT;
 			token = parse_expression(token->next, &stmt->expression);
+			if(stmt->expression->type == EXPR_PREOP
+			   && stmt->expression->op == '('
+			   && stmt->expression->unop->type == EXPR_COMMA) {
+				struct expression *expr;
+				expr = stmt->expression->unop;
+				stmt->context = expr->left;
+				stmt->expression = expr->right;
+			}
 			return expect(token, ';', "at end of statement");
 		}
 		if (token->ident == &__range___ident) {
diff --git a/parse.h b/parse.h
index 2f3a3fe..f43d431 100644
--- a/parse.h
+++ b/parse.h
@@ -39,7 +39,10 @@ struct statement {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
-		struct expression *expression;
+		struct {
+			struct expression *expression;
+			struct expression *context;
+		};
 		struct /* return_statement */ {
 			struct expression *ret_value;
 			struct symbol *ret_target;
diff --git a/show-parse.c b/show-parse.c
index 70a5b08..5437a62 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -50,18 +50,27 @@ static void do_debug_symbol(struct symbo
 		[SYM_RESTRICT] = "rstr",
 		[SYM_BAD] = "bad.",
 	};
+	struct context *context;
+	int i;
 
 	if (!sym)
 		return;
-	fprintf(stderr, "%.*s%s%3d:%lu %lx %s (as: %d, context: %x:%x) %p (%s:%d:%d)\n",
+	fprintf(stderr, "%.*s%s%3d:%lu %lx %s (as: %d) %p (%s:%d:%d)\n",
 		indent, indent_string, typestr[sym->type],
 		sym->bit_size, sym->ctype.alignment,
-		sym->ctype.modifiers, show_ident(sym->ident),
-		sym->ctype.as, sym->ctype.in_context, sym->ctype.out_context,
+		sym->ctype.modifiers, show_ident(sym->ident), sym->ctype.as,
 		sym, stream_name(sym->pos.stream), sym->pos.line, sym->pos.pos);
+	i = 0;
+	FOR_EACH_PTR(sym->ctype.contexts, context) {
+		/* FIXME: should print context expression */
+		fprintf(stderr, "< context%d: in=%d, out=%d\n",
+			i, context->in, context->out);
+		fprintf(stderr, "  end context%d >\n", i);
+		i++;
+	} END_FOR_EACH_PTR(context);
 	if (sym->type == SYM_FN) {
-		int i = 1;
 		struct symbol *arg;
+		i = 0;
 		FOR_EACH_PTR(sym->arguments, arg) {
 			fprintf(stderr, "< arg%d:\n", i);
 			do_debug_symbol(arg, 0);
diff --git a/symbol.c b/symbol.c
index 4856349..1ebfd56 100644
--- a/symbol.c
+++ b/symbol.c
@@ -53,6 +53,11 @@ struct symbol *lookup_symbol(struct iden
 	return sym;
 }
 
+struct context *alloc_context(void)
+{
+	return __alloc_context(0);
+}
+
 struct symbol *alloc_symbol(struct position pos, int type)
 {
 	struct symbol *sym = __alloc_symbol(0);
@@ -247,8 +252,8 @@ void merge_type(struct symbol *sym, stru
 {
 	sym->ctype.as |= base_type->ctype.as;
 	sym->ctype.modifiers |= (base_type->ctype.modifiers & ~MOD_STORAGE);
-	sym->ctype.in_context += base_type->ctype.in_context;
-	sym->ctype.out_context += base_type->ctype.out_context;
+	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
+	                (struct ptr_list **)&sym->ctype.contexts);
 	sym->ctype.base_type = base_type->ctype.base_type;
 }
 
diff --git a/symbol.h b/symbol.h
index a773a0a..9d939cf 100644
--- a/symbol.h
+++ b/symbol.h
@@ -55,10 +55,20 @@ enum type {
 	SYM_BAD,
 };
 
+struct context {
+	struct expression *context;
+	unsigned int in, out;
+};
+
+extern struct context *alloc_context(void);
+
+DECLARE_PTR_LIST(context_list, struct context);
+
 struct ctype {
 	unsigned long modifiers;
 	unsigned long alignment;
-	unsigned int in_context, out_context, as;
+	struct context_list *contexts;
+	unsigned int as;
 	struct symbol *base_type;
 };
 
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] Recognize and ignore __alias__ and __visibility__ ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] Recognize and ignore __alias__ and __visibility__
Date: Mon, 11 Sep 2006 21:09:36 +0000
Message-ID: <1158008976.4373.47.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Sparse currently parses and ignores the alias and visibility attributes,
but not the variants __alias__ and __visibility__, which GCC permits
even in ANSI C to allow for use in headers.  Add support for these
variants.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
Signed-off-by: Pavel Roskin <proski@gnu.org>
---
Original patch by Pavel Roskin; modified version with consolidated if
statements by me, with signoff from Pavel.

 parse.c      |    6 ++++--
 ident-list.h |    4 ++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/ident-list.h b/ident-list.h
index 95bb96a..ecdce6d 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -56,8 +56,8 @@ IDENT(__const); IDENT(__const__); IDENT(
 IDENT(__noreturn__); IDENT(regparm); IDENT(weak); IDENT(__weak__);
 IDENT(__no_instrument_function__); IDENT(no_instrument_function);
 IDENT(__sentinel__); IDENT(sentinel);
-IDENT(alias); IDENT(pure); IDENT(always_inline);
-IDENT(syscall_linkage); IDENT(visibility);
+IDENT(alias); IDENT(__alias__); IDENT(pure); IDENT(always_inline);
+IDENT(syscall_linkage); IDENT(visibility); IDENT(__visibility__);
 IDENT(bitwise); IDENT(__bitwise__);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
diff --git a/parse.c b/parse.c
index c536ec2..6857541 100644
--- a/parse.c
+++ b/parse.c
@@ -528,7 +528,8 @@ static const char * handle_attribute(str
 	if (attribute == &weak_ident ||
 	    attribute == &__weak___ident)
 		return NULL;
-	if (attribute == &alias_ident)
+	if (attribute == &alias_ident ||
+	    attribute == &__alias___ident)
 		return NULL;
 	if (attribute == &pure_ident ||
 	    attribute == &__pure___ident)
@@ -537,7 +538,8 @@ static const char * handle_attribute(str
 		return NULL;
 	if (attribute == &syscall_linkage_ident)
 		return NULL;
-	if (attribute == &visibility_ident)
+	if (attribute == &visibility_ident ||
+	    attribute == &__visibility___ident)
 		return NULL;
 	if (attribute == &deprecated_ident ||
 	    attribute == &__deprecated___ident)


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] Turn on -Wcontext by default ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] Turn on -Wcontext by default
Date: Mon, 11 Sep 2006 21:15:38 +0000
Message-ID: <1158009338.4373.55.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Context checking currently requires explicitly passing the -Wcontext option.
In a Linux build, this requires passing CF=-Wcontext.  Thus, running people
running sparse over Linux or other software in the default way will not see
context warnings.  Change this by enabling -Wcontext.

While context checking does generate false positives, due to both missing
annotations on kernel functions and insufficiently clever checking in sparse,
the context warnings still do provide useful information and help track down
real bugs.  Furthermore, showing these warnings by default may incite more
people to add annotations or enhance sparse.  As a last resort, -Wno-context
will still work.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 lib.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib.c b/lib.c
index cd46e03..c89ac75 100644
--- a/lib.c
+++ b/lib.c
@@ -179,7 +179,7 @@ int Wone_bit_signed_bitfield = 1;
 int Wcast_truncate = 1;
 int Wbitwise = 0;
 int Wtypesign = 0;
-int Wcontext = 0;
+int Wcontext = 1;
 int Wundefined_preprocessor = 0;
 int Wptr_subtraction_blows = 0;
 int Wcast_to_address_space = 0;
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] Use $(BINDIR) consistently in Makefile rather than ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] Use $(BINDIR) consistently in Makefile rather than
Date: Wed, 30 Aug 2006 00:41:46 +0000
Message-ID: <1156898507.5203.7.camel () josh-work ! beaverton ! ibm ! com>
--------------------
The Makefile has variables for both PREFIX (default $(HOME)) and BINDIR
(default $(PREFIX)/bin); however, it then uses $(PREFIX)/bin in several other
places, making it difficult to install to an alternate BINDIR.  Fix this by
using $(BINDIR) consistently throughout the Makefile.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 Makefile |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/Makefile b/Makefile
index 378ee72..6755e07 100644
--- a/Makefile
+++ b/Makefile
@@ -45,11 +45,11 @@ #
 #		"The better to keep you on your toes, my dear".
 #
 install: check $(SLIB_FILE) bin-dir
-	if test $< -nt $(PREFIX)/bin/sparse ; then install -v $< $(BINDIR)/sparse ; install -v $(SLIB_FILE) $(BINDIR) ; fi
+	if test $< -nt $(BINDIR)/sparse ; then install -v $< $(BINDIR)/sparse ; install -v $(SLIB_FILE) $(BINDIR) ; fi
 
 bin-dir:
-	@if ! test -d $(PREFIX)/bin; then \
-		echo "No '$(PREFIX)/bin' directory to install in"; \
+	@if ! test -d $(BINDIR); then \
+		echo "No '$(BINDIR)' directory to install in"; \
 		echo "Please create it and add it to your PATH"; \
 		exit 1; \
 	fi
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] bb_terminated: Use boundary values rather than ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] bb_terminated: Use boundary values rather than
Date: Mon, 11 Sep 2006 21:15:17 +0000
Message-ID: <1158009317.4373.53.camel () josh-work ! beaverton ! ibm ! com>
--------------------
The opcode enum defines the boundary values OP_TERMINATOR and
OP_TERMINATOR_END for terminator instructions; use those in bb_terminated
rather than the specific values they currently equal.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 linearize.h |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/linearize.h b/linearize.h
index ac946f3..517ec67 100644
--- a/linearize.h
+++ b/linearize.h
@@ -254,7 +254,8 @@ static inline int bb_terminated(struct b
 	if (!bb)
 		return 0;
 	insn = last_instruction(bb->insns);
-	return insn && insn->opcode >= OP_RET && insn->opcode <= OP_UNWIND;
+	return insn && insn->opcode >= OP_TERMINATOR
+	            && insn->opcode <= OP_TERMINATOR_END;
 }
 
 static inline int bb_reachable(struct basic_block *bb)
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RESEND] sparse_error() should not silence info() after ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] sparse_error() should not silence info() after
Date: Wed, 30 Aug 2006 00:41:56 +0000
Message-ID: <1156898516.5203.8.camel () josh-work ! beaverton ! ibm ! com>
--------------------
sparse_error() sets max_warnings = 0 to silence subsequent sparse_warning()s
or info()s; however, this also silences the info() after that sparse_error()
and subsequent sparse_errors() which still get shown.  bad_expr_type runs into
this problem: it reports an error with sparse_error() and then provides
further information with info(), which the user never sees.  Make info()
continue to print as long as the immediately preceeding warning or error does.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 lib.c |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index feb755a..05ed848 100644
--- a/lib.c
+++ b/lib.c
@@ -94,12 +94,13 @@ static void do_warn(const char *type, st
 }
 
 static int max_warnings = 100;
+static int show_info = 1;
 
 void info(struct position pos, const char * fmt, ...)
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!show_info)
 		return;
 	va_start(args, fmt);
 	do_warn("", pos, fmt, args);
@@ -110,11 +111,15 @@ void warning(struct position pos, const 
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!max_warnings) {
+		show_info = 0;
 		return;
+	}
 
-	if (!--max_warnings)
+	if (!--max_warnings) {
+		show_info = 0;
 		fmt = "too many warnings";
+	}
 
 	va_start(args, fmt);
 	do_warn("warning: ", pos, fmt, args);
@@ -126,10 +131,12 @@ void sparse_error(struct position pos, c
 	static int errors = 0;
 	va_list args;
         die_if_error = 1;
+	show_info = 1;
 	/* Shut up warnings after an error */
 	max_warnings = 0;
 	if (errors > 100) {
 		static int once = 0;
+		show_info = 0;
 		if (once)
 			return;
 		fmt = "too many errors";
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] sparse_error() should not silence info() after
Date: Wed, 30 Aug 2006 00:41:56 +0000
Message-ID: <1156898516.5203.8.camel () josh-work ! beaverton ! ibm ! com>
--------------------
sparse_error() sets max_warnings = 0 to silence subsequent sparse_warning()s
or info()s; however, this also silences the info() after that sparse_error()
and subsequent sparse_errors() which still get shown.  bad_expr_type runs into
this problem: it reports an error with sparse_error() and then provides
further information with info(), which the user never sees.  Make info()
continue to print as long as the immediately preceeding warning or error does.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 lib.c |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index feb755a..05ed848 100644
--- a/lib.c
+++ b/lib.c
@@ -94,12 +94,13 @@ static void do_warn(const char *type, st
 }
 
 static int max_warnings = 100;
+static int show_info = 1;
 
 void info(struct position pos, const char * fmt, ...)
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!show_info)
 		return;
 	va_start(args, fmt);
 	do_warn("", pos, fmt, args);
@@ -110,11 +111,15 @@ void warning(struct position pos, const 
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!max_warnings) {
+		show_info = 0;
 		return;
+	}
 
-	if (!--max_warnings)
+	if (!--max_warnings) {
+		show_info = 0;
 		fmt = "too many warnings";
+	}
 
 	va_start(args, fmt);
 	do_warn("warning: ", pos, fmt, args);
@@ -126,10 +131,12 @@ void sparse_error(struct position pos, c
 	static int errors = 0;
 	va_list args;
         die_if_error = 1;
+	show_info = 1;
 	/* Shut up warnings after an error */
 	max_warnings = 0;
 	if (errors > 100) {
 		static int once = 0;
+		show_info = 0;
 		if (once)
 			return;
 		fmt = "too many errors";
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH RESEND] sparse_error() should not silence info() after
Date: Mon, 11 Sep 2006 21:11:27 +0000
Message-ID: <1158009087.4373.49.camel () josh-work ! beaverton ! ibm ! com>
--------------------
sparse_error() sets max_warnings = 0 to silence subsequent sparse_warning()s
or info()s; however, this also silences the info() after that sparse_error()
and subsequent sparse_errors() which still get shown.  bad_expr_type runs into
this problem: it reports an error with sparse_error() and then provides
further information with info(), which the user never sees.  Make info()
continue to print as long as the immediately preceeding warning or error does.

Thanks to Adam DiCarlo <adam.dicarlo@gmail.com> for reporting the problem.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
Cc: Adam DiCarlo <adam.dicarlo@gmail.com>
---
 lib.c |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index feb755a..05ed848 100644
--- a/lib.c
+++ b/lib.c
@@ -94,12 +94,13 @@ static void do_warn(const char *type, st
 }
 
 static int max_warnings = 100;
+static int show_info = 1;
 
 void info(struct position pos, const char * fmt, ...)
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!show_info)
 		return;
 	va_start(args, fmt);
 	do_warn("", pos, fmt, args);
@@ -110,11 +111,15 @@ void warning(struct position pos, const 
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!max_warnings) {
+		show_info = 0;
 		return;
+	}
 
-	if (!--max_warnings)
+	if (!--max_warnings) {
+		show_info = 0;
 		fmt = "too many warnings";
+	}
 
 	va_start(args, fmt);
 	do_warn("warning: ", pos, fmt, args);
@@ -126,10 +131,12 @@ void sparse_error(struct position pos, c
 	static int errors = 0;
 	va_list args;
         die_if_error = 1;
+	show_info = 1;
 	/* Shut up warnings after an error */
 	max_warnings = 0;
 	if (errors > 100) {
 		static int once = 0;
+		show_info = 0;
 		if (once)
 			return;
 		fmt = "too many errors";


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCHSET] fouled-bitwise handling ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCHSET] fouled-bitwise handling
Date: Sun, 01 Oct 2006 13:57:11 +0000
Message-ID: <E1GU1od-0006tu-Oo () ZenIV ! linux ! org ! uk>
--------------------

This stuff comes from handling smaller-than-int bitwise types (e.g. __le16).
The problem is in handling things like
	__be16 x, y;
	...
	if (x == (x & ~y))
The code is bitwise-clean, but current sparse can't deduce that.  Operations
allowed on bitwise types have the following property: (type)(x <op> y) can
be substituted for x <op> y in any expression other than sizeof.  That allows
us to ignore usual arithmetical conversions for those types and treat e.g.
| as __be16 x __be16 -> __be16, despite the promotion rules; resulting
semantics will be the same.  However, ~ on smaller-than-int does not have
such property; indeed, ~y is guaranteed to _not_ fit into range of __be16
in the example above.

That causes a lot of unpleasant problems when dealing with e.g. networking
code - IP checksums are 16bit and ~ is often used in their (re)calculations.
The way to deal with that is based on the observation that even though we do
get junk in upper bits, it normally ends up being discarded and sparse can
be taught to prove that.  To do that we need "fouled" conterparts for short
bitwise types.  They will be assigned to (sub)expressions that might carry
junk in upper bits, but trimming those bits would result in the value we'd
get if all operations had been done within the bitwise type.  E.g. in the
example above y would be __be16, ~y - fouled __be16, x & ~y - __be16 again
and x == (x & ~y) - boolean.

Basically, we delay reporting an error on ~<short bitwise> for as long as
possible in hope that taint will be cleansed later.

This patchset can be pulled from
git://git.kernel.org/pub/scm/linux/kernel/git/viro/sparse.git for-linus

shortlog:
Al Viro:
      casting null pointer constant to non-zero address space is always OK
      introduce classify_type(), use it in obvious places
      evaluate_compare() can just use evaluate_arith() for non-pointer cases
      beginning of SYM_RESTRICT rewrite: restricted_binop_type()
      merged compatible_..._binop() into single function
      saner recovery from endianness errors, part 1.
      handle fouled-bitwise

diffstat:
 evaluate.c                |  442 ++++++++++++++++++++++++++-------------------
 parse.c                   |    1 
 show-parse.c              |    8 +
 symbol.c                  |   38 ++++
 symbol.h                  |    5 +
 validation/foul-bitwise.c |   20 ++
 6 files changed, 324 insertions(+), 190 deletions(-)
 create mode 100644 validation/foul-bitwise.c

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCHSET] fouled-bitwise handling
Date: Sun, 01 Oct 2006 14:09:50 +0000
Message-ID: <20061001140950.GV29920 () ftp ! linux ! org ! uk>
--------------------
>       casting null pointer constant to non-zero address space is always OK

... gah.  That patch has nothing to do with the series, but it's probably
not worth pulling out (cast handling is seriously affected by the patches
that do belong there).  My apologies for missing it.

OTOH, the patch is trivial and obviously correct, so...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCHSET] fouled-bitwise handling
Date: Sun, 01 Oct 2006 16:21:21 +0000
Message-ID: <Pine.LNX.4.64.0610010906030.3952 () g5 ! osdl ! org>
--------------------


On Sun, 1 Oct 2006, Al Viro wrote:
> 
> This stuff comes from handling smaller-than-int bitwise types (e.g. __le16).
> The problem is in handling things like
> 	__be16 x, y;
> 	...
> 	if (x == (x & ~y))
> The code is bitwise-clean, but current sparse can't deduce that.

Al, I understand why you did it the way you did, but I think it's wrong.

Why do I think it's wrong? Let me count the ways.

Umm. Ok, I counted, and there's only one way.

The only reason I think you're doing it wrong is that you're using this 
totally new separate mechanism for it (which is not a bad mechanism, but 
it's very much a special case), and you should not need to!

The fact is, regardless of any bitwise issues, the

	(cast) narrower-type <op> (wider-type "&" (cast) narrower-type)

should _always_ be simplified to a small-type.

See? Even from a purely optimization angle, we're actually better off just 
noticing that the whole comparison can be done in the narrower type.

Imagine this piece of code:

	int mask;
	char c, *p;

	if (*p == (mask & c))

where there is no bitwise stuff, a good compiler should notice on its own 
that it should just be done in 8 bits rather than having to convert "c" 
and "*p" to integers.

And once you do that _generic_ optimization, your whole "fouled" thing is 
useless.

Btw, we _already_ do this optimization for a few cases, we just didn't do 
it for enough cases.  We do it purely for assignment statements, ie notice 
how git already does not warn for

	__le16 a, b;

	a = ~b;

exactly because we have done a simplification of

	a = (implicit cast back to __le16)~(implicit cast to int)b;

to just keeping everything in the narrower type..

See commit 4b6c2e63d3423931ac687f113882cec427df9f91 for details.

And I _think_ we should be able to do exactly the same for this one, by 
simply noticing that doing a

	(widening-cast) a == b & (widening-cast) c

is by definition throwing away the higher bits on both sides, and we can 
just turn it into the simpler

	a == c & (narrowing-cast) b

instead. Of course, we can only do this with ops that don't have overflow 
from the narrower type (but comparisons and bitops are ok).

No?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCHSET] fouled-bitwise handling
Date: Sun, 01 Oct 2006 16:45:13 +0000
Message-ID: <20061001164513.GW29920 () ftp ! linux ! org ! uk>
--------------------
On Sun, Oct 01, 2006 at 09:21:21AM -0700, Linus Torvalds wrote:
> The only reason I think you're doing it wrong is that you're using this 
> totally new separate mechanism for it (which is not a bad mechanism, but 
> it's very much a special case), and you should not need to!
 
> The fact is, regardless of any bitwise issues, the
> 
> 	(cast) narrower-type <op> (wider-type "&" (cast) narrower-type)
> 
> should _always_ be simplified to a small-type.
 
Sure.  Now try to carry that to more complex expressions.
 
> And I _think_ we should be able to do exactly the same for this one, by 
> simply noticing that doing a
> 
> 	(widening-cast) a == b & (widening-cast) c
> 
> is by definition throwing away the higher bits on both sides, and we can 
> just turn it into the simpler
> 
> 	a == c & (narrowing-cast) b
> 
> instead. Of course, we can only do this with ops that don't have overflow 
> from the narrower type (but comparisons and bitops are ok).
> 
> No?

At which phase would you do that?  We assign types pretty much leaves
to root - type of node is derived from the types of children.

Now, you suggest basically going *other* way.  I.e. noticing that
we have
	<complex expression in narrow> & <complex expression in wide>
and trying to propagate narrowing down another subexpression.

Note that we need *both* arguments typed - we don't know which one
might be narrow here.  So it's really re-evaluation of subexpression.

OK, so we have expand phase that could do that.  _However_, we'd have
to postpone the bitwise checks until that phase, or we'd get them
anyway.  And that is not to mention the fun with evaluate_expression()
mangling the tree, so re-walking it won't be easy.

IOW, I very much prefer to deal with that by _existing_ mechanism;
namely, the type assignment.  It's easier to propagate the information
along with the rest of type information, in the direction we are
already doing.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCHSET] fouled-bitwise handling
Date: Sun, 01 Oct 2006 17:22:53 +0000
Message-ID: <20061001172253.GX29920 () ftp ! linux ! org ! uk>
--------------------
On Sun, Oct 01, 2006 at 09:52:31AM -0700, Linus Torvalds wrote:
> (Now, it's entirely possible that we warn so early that we can't 
> reasonably do this optimization until after we've already warned, but I've 
> been able to remove these kinds of warnings before, so I think it should 
> be possible to do it here too).
> 
> I much prefer (if possible) the "make sparse so much smarter that it sees 
> that it's ok" approach over "let's add a magic special case". For example, 
> a lot of the work I did to make the lock acquire/release logic useful was 
> very much about teaching sparse to simplify code-flow rather than anything 
> else.
> 
> But hey, maybe this case is too hard or nasty..

Hrm...  The gut feeling: we mangle expression trees too much to be able
to do that decently.

We would have to carry "this might be le16"/"this might be be16"/"this
might be foo_t" up *anyway*.  Because what we see several nodes up is
be16 | int.  And even if we guess that it might be expanded 16bit,
we _still_ need to know which 16bit it was.  So you have to propagate
that up and that's exactly what I'm doing.

"Find how much we could narrow it" is a separate question; _that_ is
best done by moving the casts down.  But I would not mix that with
type warnings.  We _do_ mangle the tree a lot, so by the time we
start walking down, we might have large chunks in a very inconvenient
shape.

The bottom line: your variant either requires to carry "which 16bit
it might have been" along with the expression type (in which case it's
exactly what I've done, modulo data representation), _OR_ it requires
3 passes - normal type evaluation + walking down trying to narrow the
things down + walking up *again* trying to generate those postponed
warnings.  Because you won't be able to do them on the second pass -
not enough information.

I'd rather handle them on the first pass when we can easily do that
and then do exact equivalent of the second pass (top to bottom) of
your approach.  Endianness type checks can be easily combined with
the first pass, but not with the second...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCHSET] fouled-bitwise handling
Date: Sun, 01 Oct 2006 17:29:11 +0000
Message-ID: <20061001172911.GY29920 () ftp ! linux ! org ! uk>
--------------------
PS: "fouled(le16)" is exactly "int, and if you narrow it to 16bit, it'd
better be le16".  We could separate that from type information, but hey,
if we want to carry reference to some type + indication that we do have
that reference + int as type, we might as well introduce a type node
saying "I'm int, might be base_type".  Which is exactly what I've done...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCHSET] fouled-bitwise handling
Date: Sun, 01 Oct 2006 17:33:44 +0000
Message-ID: <Pine.LNX.4.64.0610011031280.3952 () g5 ! osdl ! org>
--------------------


On Sun, 1 Oct 2006, Al Viro wrote:
> 
> Hrm...  The gut feeling: we mangle expression trees too much to be able
> to do that decently.

Having looked at it a bit now, I think I agree.

We warn about the whole "~" thing too early, so we'd have to remove that 
warning anyway (easy enough to do), but then we'd have to track the ops 
that don't like using a "~" because of its C semantics.

And at that point, your "fouled" bit is actually probably simpler.

Let me think about this a bit more, but I'm starting to think that you're 
right.

As usual.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add -Wno-address-space ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add -Wno-address-space
Date: Sat, 22 Jul 2006 02:35:09 +0000
Message-ID: <1153535709.1797.3.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add the ability to turn off address-space mismatch warnings using
-Wno-address-space, helpful when attempting to track down a particular class
of warnings only without losing them amongst others.  Address space checking
defaults to on, so this does not change the default behavior of sparse.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 evaluate.c |    2 +-
 lib.c      |    2 ++
 lib.h      |    1 +
 3 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 2561f38..c5d2526 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -681,7 +681,7 @@ const char * type_difference(struct symb
 			return "different base types";
 
 		/* Must be same address space to be comparable */
-		if (as1 != as2)
+		if (Waddress_space && as1 != as2)
 			return "different address spaces";
 
 		/* Ignore differences in storage types or addressability */
diff --git a/lib.c b/lib.c
index ad19696..84d0647 100644
--- a/lib.c
+++ b/lib.c
@@ -177,6 +177,7 @@ int Wptr_subtraction_blows = 0;
 int Wcast_to_address_space = 0;
 int Wdecl = 0;
 int Wtransparent_union = 1;
+int Waddress_space = 1;
 int preprocess_only;
 char *include;
 int include_fd = -1;
@@ -321,6 +322,7 @@ static const struct warning {
 	{ "typesign", &Wtypesign },
 	{ "context", &Wcontext },
 	{ "transparent-union", &Wtransparent_union },
+	{ "address-space", &Waddress_space },
 };
 

diff --git a/lib.h b/lib.h
index a61b2dd..e6b9bfa 100644
--- a/lib.h
+++ b/lib.h
@@ -77,6 +77,7 @@ extern int Wdefault_bitfield_sign;
 extern int Wundefined_preprocessor;
 extern int Wbitwise, Wtypesign, Wcontext;
 extern int Wtransparent_union;
+extern int Waddress_space;
 extern int Wcast_to_address_space;
 extern int Wdecl;
 extern int Wone_bit_signed_bitfield;


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add -Wno-cast-truncate ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add -Wno-cast-truncate
Date: Wed, 26 Jul 2006 17:24:52 +0000
Message-ID: <1153934692.12517.46.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add the ability to turn off checks for casts that truncate constant values
using -Wno-cast-truncate, helpful when attempting to track down a particular
class of warnings only without losing them amongst others.  Checks for
truncating casts default to on, so this does not change the default behavior
of sparse.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 expand.c |    4 ++++
 lib.c    |    2 ++
 lib.h    |    1 +
 3 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/expand.c b/expand.c
index 474344d..882d80e 100644
--- a/expand.c
+++ b/expand.c
@@ -94,6 +94,10 @@ Int:
 	mask = signmask | (signmask-1);
 	expr->value = value & mask;
 
+	// Stop here unless checking for truncation
+	if (!Wcast_truncate)
+		return;
+	
 	// Check if we dropped any bits..
 	oldsignmask = 1ULL << (old_size-1);
 	oldmask = oldsignmask | (oldsignmask-1);
diff --git a/lib.c b/lib.c
index d92418a..7a2e291 100644
--- a/lib.c
+++ b/lib.c
@@ -169,6 +169,7 @@ static char pre_buffer[8192];
 
 int Wdefault_bitfield_sign = 0;
 int Wone_bit_signed_bitfield = 1;
+int Wcast_truncate = 1;
 int Wbitwise = 0;
 int Wtypesign = 0;
 int Wcontext = 0;
@@ -316,6 +317,7 @@ static const struct warning {
 	{ "cast-to-as", &Wcast_to_address_space },
 	{ "decl", &Wdecl },
 	{ "one-bit-signed-bitfield", &Wone_bit_signed_bitfield },
+	{ "cast-truncate", &Wcast_truncate },
 	{ "ptr-subtraction-blows", &Wptr_subtraction_blows },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
 	{ "undef", &Wundefined_preprocessor },
diff --git a/lib.h b/lib.h
index 5f67a12..b542cd6 100644
--- a/lib.h
+++ b/lib.h
@@ -82,6 +82,7 @@ extern int Wcast_to_address_space;
 extern int Wenum_mismatch;
 extern int Wdecl;
 extern int Wone_bit_signed_bitfield;
+extern int Wcast_truncate;
 
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add -Wno-enum-mismatch ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add -Wno-enum-mismatch
Date: Sat, 22 Jul 2006 02:35:25 +0000
Message-ID: <1153535725.1797.5.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add the ability to turn off enum type mismatch warnings using
-Wno-enum-mismatch, helpful when attempting to track down a particular class
of warnings only without losing them amongst others.  Enum type mismatch
checking defaults to on, so this does not change the default behavior of
sparse.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 evaluate.c |    2 ++
 lib.c      |    2 ++
 lib.h      |    1 +
 3 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index c5d2526..177797a 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -243,6 +243,8 @@ warn_for_different_enum_types (struct po
 			       struct symbol *typea,
 			       struct symbol *typeb)
 {
+	if (!Wenum_mismatch)
+		return;
 	if (typea->type == SYM_NODE)
 		typea = typea->ctype.base_type;
 	if (typeb->type == SYM_NODE)
diff --git a/lib.c b/lib.c
index 84d0647..d92418a 100644
--- a/lib.c
+++ b/lib.c
@@ -178,6 +178,7 @@ int Wcast_to_address_space = 0;
 int Wdecl = 0;
 int Wtransparent_union = 1;
 int Waddress_space = 1;
+int Wenum_mismatch = 1;
 int preprocess_only;
 char *include;
 int include_fd = -1;
@@ -323,6 +324,7 @@ static const struct warning {
 	{ "context", &Wcontext },
 	{ "transparent-union", &Wtransparent_union },
 	{ "address-space", &Waddress_space },
+	{ "enum-mismatch", &Wenum_mismatch },
 };
 

diff --git a/lib.h b/lib.h
index e6b9bfa..5f67a12 100644
--- a/lib.h
+++ b/lib.h
@@ -79,6 +79,7 @@ extern int Wbitwise, Wtypesign, Wcontext
 extern int Wtransparent_union;
 extern int Waddress_space;
 extern int Wcast_to_address_space;
+extern int Wenum_mismatch;
 extern int Wdecl;
 extern int Wone_bit_signed_bitfield;
 


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add __builtin_popcountl ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] Add __builtin_popcountl
Date: Thu, 26 Oct 2006 18:43:01 +0000
Message-ID: <20061026184301.GJ29920 () ftp ! linux ! org ! uk>
--------------------
On Thu, Oct 26, 2006 at 11:47:30AM -0600, Matthew Wilcox wrote:
> 
> IA-64 uses __builtin_popcountl() which wasn't a function sparse knew
> about.  This patch adds it.  I've never looked at sparse before, so this
> is a hack-and-run job.  Please feel free to rewrite it if it doesn't suit.

AFAICS, that's way over the top.  That kind of stuff is needed only
when builtin can't be described as a normal function.  This, OTOH...

diff --git a/lib.c b/lib.c
--- a/lib.c
+++ b/lib.c
@@ -467,6 +467,16 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(int);\n");
 	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+	add_pre_buffer("extern int __builtin_popcount(unsigned int);\n");
+	add_pre_buffer("extern int __builtin_popcountl(unsigned long);\n");
+	add_pre_buffer("extern void __builtin_prefetch (const void *, ...);\n");
+	add_pre_buffer("extern long __builtin_alpha_extbl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_extwl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_insbl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_inswl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_insql(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_inslh(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 }
 
 void create_builtin_stream(void)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Add __builtin_popcountl
Date: Thu, 26 Oct 2006 18:56:00 +0000
Message-ID: <Pine.LNX.4.64.0610261153510.3962 () g5 ! osdl ! org>
--------------------


On Thu, 26 Oct 2006, Al Viro wrote:
> 
> AFAICS, that's way over the top.  That kind of stuff is needed only
> when builtin can't be described as a normal function.  This, OTOH...

On the other hand, adding "true" builtin functions is actually a lot 
cheaper than adding bogus code to be parsed explicitly.

So I'd actually prefer a way to have a table to describe and initialize 
these things, as a way to make it a lot more efficient, and without the 
silly preprocessor buffer hacks..

The preprocessor hack is certainly simple, but it's not what you really 
want in real life.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] Add __builtin_popcountl
Date: Thu, 26 Oct 2006 19:19:41 +0000
Message-ID: <20061026191941.GK29920 () ftp ! linux ! org ! uk>
--------------------
On Thu, Oct 26, 2006 at 11:56:00AM -0700, Linus Torvalds wrote:
> 
> 
> On Thu, 26 Oct 2006, Al Viro wrote:
> > 
> > AFAICS, that's way over the top.  That kind of stuff is needed only
> > when builtin can't be described as a normal function.  This, OTOH...
> 
> On the other hand, adding "true" builtin functions is actually a lot 
> cheaper than adding bogus code to be parsed explicitly.
> 
> So I'd actually prefer a way to have a table to describe and initialize 
> these things, as a way to make it a lot more efficient, and without the 
> silly preprocessor buffer hacks..
> 
> The preprocessor hack is certainly simple, but it's not what you really 
> want in real life.

Well...  Keep in mind that those _are_ functions; i.e. unlike something
like __builtin_choose_expr() you can pass such puppy to a function
expecting a callback, etc.

So it's not enough to special-case them; we really need types for those
symbols.  I don't think that it will be more efficient in the end.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add backend to graph basic blocks ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add backend to graph basic blocks
Date: Sat, 12 Aug 2006 01:37:11 +0000
Message-ID: <1155346631.22069.5.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add a new backend program which parses the input files, processes them through
the linearization pass, and outputs a graphviz graph of the resulting basic
blocks.  Each entrypoint gets labelled by name, but for now the basic blocks
just get labelled with the address of the basic_block structure.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 .gitignore |    1 +
 Makefile   |    6 +++++-
 graph.c    |   63 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 69 insertions(+), 1 deletions(-)

diff --git a/.gitignore b/.gitignore
index 32d6e70..3e12ce7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,6 +13,7 @@ test-parsing
 obfuscate
 check
 compile
+graph
 test-dissect
 test-linearize
 example
diff --git a/Makefile b/Makefile
index 378ee72..e71f360 100644
--- a/Makefile
+++ b/Makefile
@@ -21,7 +21,7 @@ # LDFLAGS += -Wl,-rpath,$(BINDIR)
 
 PREFIX=$(HOME)
 BINDIR=$(PREFIX)/bin
-PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example test-unssa test-dissect
+PROGRAMS=test-lexing test-parsing obfuscate check compile graph test-linearize example test-unssa test-dissect
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
@@ -77,6 +77,9 @@ obfuscate: obfuscate.o $(LIBS)
 check: check.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+graph: graph.o $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+
 example: example.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
@@ -123,6 +126,7 @@ obfuscate.o: $(LIB_H)
 example.o: $(LIB_H)
 storage.o: $(LIB_H) storage.h
 dissect.o: $(LIB_H) dissect.h
+graph.o: $(LIB_H)
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
diff --git a/graph.c b/graph.c
new file mode 100644
index 0000000..db940ae
--- /dev/null
+++ b/graph.c
@@ -0,0 +1,63 @@
+/* Copyright Â© International Business Machines Corp., 2006
+ *
+ * Author: Josh Triplett <josh@freedesktop.org>
+ *
+ * Licensed under the Open Software License version 1.1
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+
+static void graph_ep(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	printf("ep%p [label=\"%s\",shape=ellipse];\n",
+	       ep, show_ident(ep->name->ident));
+	FOR_EACH_PTR(ep->bbs, bb) {
+		printf("bb%p [shape=record,label=\"bb at %p\"]\n", bb, bb);
+	} END_FOR_EACH_PTR(bb);
+	FOR_EACH_PTR(ep->bbs, bb) {
+		struct basic_block *child;
+		FOR_EACH_PTR(bb->children, child) {
+			printf("bb%p -> bb%p;\n", bb, child);
+		} END_FOR_EACH_PTR(child);
+	} END_FOR_EACH_PTR(bb);
+	printf("ep%p -> bb%p;\n", ep, ep->entry->bb);
+}
+
+static void graph_symbols(struct symbol_list *list)
+{
+	struct symbol *sym;
+
+	FOR_EACH_PTR(list, sym) {
+		struct entrypoint *ep;
+
+		expand_symbol(sym);
+		ep = linearize_symbol(sym);
+		if (ep)
+			graph_ep(ep);
+	} END_FOR_EACH_PTR(sym);
+}
+
+int main(int argc, char **argv)
+{
+	printf("digraph control_flow {\n");
+	graph_symbols(sparse_initialize(argc, argv));
+	while (*argv)
+		graph_symbols(sparse(argv));
+	printf("}\n");
+	return 0;
+}


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add support for GCC's __builtin_extract_return_addr ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add support for GCC's __builtin_extract_return_addr
Date: Wed, 26 Jul 2006 17:29:53 +0000
Message-ID: <1153934993.12517.52.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
Needed to avoid several sparse errors when checking recent Linux kernels
from GIT, which use this builtin in include/linux/kallsyms.h, included
from various places.

 lib.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index ad19696..eba58c3 100644
--- a/lib.c
+++ b/lib.c
@@ -463,6 +463,7 @@ void declare_builtin_functions(void)
 
 	/* And some random ones.. */
 	add_pre_buffer("extern void *__builtin_return_address(unsigned int);\n");
+	add_pre_buffer("extern void *__builtin_extract_return_addr(void *);\n");
 	add_pre_buffer("extern void *__builtin_frame_address(unsigned int);\n");
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(int);\n");


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add support for GCC's __builtin_va_copy ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add support for GCC's __builtin_va_copy
Date: Wed, 26 Jul 2006 18:18:34 +0000
Message-ID: <1153937914.12517.55.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
Sparse already supports __builtin_va_{start,arg,end} and various others,
but not __builtin_va_copy.

 lib.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index ad19696..1e921d3 100644
--- a/lib.c
+++ b/lib.c
@@ -490,6 +490,7 @@ void create_builtin_stream(void)
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ({ type __va_arg_ret = *(type *)(arg); arg += sizeof(type); __va_arg_ret; })\n");
 	add_pre_buffer("#define __builtin_va_alist (*(void *)0)\n");
 	add_pre_buffer("#define __builtin_va_arg_incr(x) ((x) + 1)\n");
+	add_pre_buffer("#define __builtin_va_copy(dest, src) ({ dest = src; (void)0; })\n");
 	add_pre_buffer("#define __builtin_va_end(arg)\n");
 	add_pre_buffer("#define __builtin_offsetof(type, name) ((__SIZE_TYPE__)&((type *)(0ul))->name)\n");
 


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add test cases for __context__ statement and context ===

From: Josh Triplett <josht () vnet ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add test cases for __context__ statement and context
Date: Thu, 29 Jun 2006 22:31:04 +0000
Message-ID: <1151620264.6507.18.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Add validation/context.c, which includes various test cases for
__context__(...)  and __attribute__((context(...))).  These test cases include
both correct usage, in the functions named good_*, and incorrect usage, in the
functions named warn_*.

Signed-off-by: Josh Triplett <josh@freedesktop.org>

---

Running sparse -Wcontext validation/context.c gives:
sparse/validation/context.c:64:6: warning: context imbalance in 'warn_lock1' - wrong count at exit
sparse/validation/context.c:69:6: warning: context imbalance in 'warn_lock2' - wrong count at exit
sparse/validation/context.c:76:6: warning: context imbalance in 'warn_lock3' - wrong count at exit
sparse/validation/context.c:83:6: warning: context imbalance in 'warn_unlock1' - unexpected unlock
sparse/validation/context.c:88:6: warning: context imbalance in 'warn_unlock2' - unexpected unlock
sparse/validation/context.c:126:5: warning: context imbalance in 'warn_if1' - wrong count at exit
sparse/validation/context.c:135:5: warning: context imbalance in 'warn_if2' - different lock contexts for basic block
sparse/validation/context.c:197:2: warning: context imbalance in 'warn_while1' - different lock contexts for basic block
sparse/validation/context.c:205:3: warning: context imbalance in 'warn_while2' - unexpected unlock
sparse/validation/context.c:211:2: warning: context imbalance in 'warn_while3' - wrong count at exit
sparse/validation/context.c:269:6: warning: context imbalance in 'warn_goto1' - wrong count at exit
sparse/validation/context.c:278:6: warning: context imbalance in 'warn_goto2' - wrong count at exit
sparse/validation/context.c:295:5: warning: context imbalance in 'warn_goto3' - different lock contexts for basic block

 validation/context.c |  296 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 296 insertions(+), 0 deletions(-)
 create mode 100644 validation/context.c

8e4964e89379a83c9fc66e25b0d1dd86a2cb7618
diff --git a/validation/context.c b/validation/context.c
new file mode 100644
index 0000000..165d4f6
--- /dev/null
+++ b/validation/context.c
@@ -0,0 +1,296 @@
+void a(void) __attribute__((context(0,1)))
+{
+	__context__(1);
+}
+
+void r(void) __attribute__((context(1,0)))
+{
+	__context__(-1);
+}
+
+void good_paired1(void)
+{
+	a();
+	r();
+}
+
+void good_paired2(void)
+{
+	a();
+	r();
+	a();
+	r();
+}
+
+void good_paired3(void)
+{
+	a();
+	a();
+	r();
+	r();
+}
+
+void good_lock1(void) __attribute__((context(0,1)))
+{
+	a();
+}
+
+void good_lock2(void) __attribute__((context(0,1)))
+{
+	a();
+	r();
+	a();
+}
+
+void good_lock3(void) __attribute__((context(0,1)))
+{
+	a();
+	a();
+	r();
+}
+
+void good_unlock1(void) __attribute__((context(1,0)))
+{
+	r();
+}
+
+void good_unlock2(void) __attribute__((context(1,0)))
+{
+	a();
+	r();
+	r();
+}
+
+void warn_lock1(void)
+{
+	a();
+}
+
+void warn_lock2(void)
+{
+	a();
+	r();
+	a();
+}
+
+void warn_lock3(void)
+{
+	a();
+	a();
+	r();
+}
+
+void warn_unlock1(void)
+{
+	r();
+}
+
+void warn_unlock2(void)
+{
+	a();
+	r();
+	r();
+}
+
+extern int condition, condition2;
+
+int good_if1(void)
+{
+	a();
+	if(condition) {
+		r();
+		return -1;
+	}
+	r();
+	return 0;
+}
+
+void good_if2(void)
+{
+	if(condition) {
+		a();
+		r();
+	}
+}
+
+void good_if3(void)
+{
+	a();
+	if(condition) {
+		a();
+		r();
+	}
+	r();
+}
+
+int warn_if1(void)
+{
+	a();
+	if(condition)
+		return -1;
+	r();
+	return 0;
+}
+
+int warn_if2(void)
+{
+	a();
+	if(condition) {
+		r();
+		return -1;
+	}
+	return 0;
+}
+
+void good_while1(void)
+{
+	a();
+	while(condition)
+		;
+	r();
+}
+
+void good_while2(void)
+{
+	while(condition) {
+		a();
+		r();
+	}
+}
+
+void good_while3(void)
+{
+	while(condition) {
+		a();
+		r();
+		if(condition2)
+			break;
+		a();
+		r();
+	}
+}
+
+void good_while4(void)
+{
+	a();
+	while(1) {
+		if(condition2) {
+			r();
+			break;
+		}
+	}
+}
+
+void good_while5(void)
+{
+	a();
+	while(1) {
+		r();
+		if(condition2)
+			break;
+		a();
+	}
+}
+
+void warn_while1(void)
+{
+	while(condition) {
+		a();
+	}
+}
+
+void warn_while2(void)
+{
+	while(condition) {
+		r();
+	}
+}
+
+void warn_while3(void)
+{
+	while(condition) {
+		a();
+		if(condition2)
+			break;
+		r();
+	}
+}
+
+void good_goto1(void)
+{
+    a();
+    goto label;
+label:
+    r();
+}
+
+void good_goto2(void)
+{
+    a();
+    goto label;
+    a();
+    r();
+label:
+    r();
+}
+
+void good_goto3(void)
+{
+    a();
+    if(condition)
+        goto label;
+    a();
+    r();
+label:
+    r();
+}
+
+void good_goto4(void)
+{
+    if(condition)
+        goto label;
+    a();
+    r();
+label:
+    ;
+}
+
+void good_goto5(void)
+{
+    a();
+    if(condition)
+        goto label;
+    r();
+    return;
+label:
+    r();
+}
+
+void warn_goto1(void)
+{
+    a();
+    goto label;
+    r();
+label:
+    ;
+}
+
+void warn_goto2(void)
+{
+    a();
+    goto label;
+    r();
+label:
+    a();
+    r();
+}
+
+void warn_goto3(void)
+{
+    a();
+    if(condition)
+        goto label;
+    r();
+label:
+    r();
+}


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add test-dissect to .gitignore ===

From: Josh Triplett <josht () vnet ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add test-dissect to .gitignore
Date: Fri, 30 Jun 2006 18:49:04 +0000
Message-ID: <1151693344.6507.84.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Signed-off-by: Josh Triplett <josh@freedesktop.org>

---

 .gitignore |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

50d7ca63b85abe691beeb4d0ea39f6d8653798e9
diff --git a/.gitignore b/.gitignore
index a7e5514..32d6e70 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,6 +13,7 @@ test-parsing
 obfuscate
 check
 compile
+test-dissect
 test-linearize
 example
 test-unssa


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add type information to enum mismatch warning ===

From: Adam DiCarlo <bikko () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Add type information to enum mismatch warning
Date: Fri, 01 Sep 2006 00:07:47 +0000
Message-ID: <44F779D3.8090402 () us ! ibm ! com>
--------------------
Signed-off-by: Adam DiCarlo <adam.dicarlo@gmail.com>
---
  evaluate.c |    5 ++++-
  1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 177797a..3076d41 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -253,8 +253,11 @@ warn_for_different_enum_types (struct po
  	if (typea == typeb)
  		return;

-	if (typea->type == SYM_ENUM && typeb->type == SYM_ENUM)
+	if (typea->type == SYM_ENUM && typeb->type == SYM_ENUM) {
  		warning(pos, "mixing different enum types");
+		info(pos, "    %s versus", show_typename(typea));
+		info(pos, "    %s", show_typename(typeb));
+	}
  }

  /*
-- 
1.4.2.ga444


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Attribute "sentinel" ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Attribute "sentinel"
Date: Tue, 28 Mar 2006 20:07:14 +0000
Message-ID: <20060328200714.D9B03C000E2 () dunnock ! rentec ! com>
--------------------

[This is a resend.]

This makes sparse ignore the "sentinel" attribute.




Signed-off-by: Morten Welinder <terra@gnome.org>


diff --git a/ident-list.h b/ident-list.h
index f5812de..3051e56 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -53,6 +53,7 @@ IDENT(noinline);
 IDENT(deprecated);
 IDENT(__const); IDENT(__const__); IDENT(noreturn);
 IDENT(__noreturn__); IDENT(regparm); IDENT(weak); IDENT(__weak__);
+IDENT(__sentinel__); IDENT(sentinel);
 IDENT(alias); IDENT(pure); IDENT(always_inline);
 IDENT(syscall_linkage); IDENT(visibility);
 IDENT(bitwise); IDENT(__bitwise__);
diff --git a/parse.c b/parse.c
index d871afd..4339657 100644
--- a/parse.c
+++ b/parse.c
@@ -517,6 +517,9 @@ static const char * handle_attribute(str
 	if (attribute == &noreturn_ident ||
 	    attribute == &__noreturn___ident)
 		return NULL;
+	if (attribute == &sentinel_ident ||
+	    attribute == &__sentinel___ident)
+		return NULL;
 	if (attribute == &regparm_ident)
 		return NULL;
 	if (attribute == &weak_ident ||
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix incorrect symbol in comment on #endif for ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Fix incorrect symbol in comment on #endif for
Date: Wed, 13 Sep 2006 20:42:37 +0000
Message-ID: <1158180157.5097.28.camel () josh-work ! beaverton ! ibm ! com>
--------------------
symbol.h uses the standard multiple-inclusion guard, with the symbol SYMBOL_H,
but the comment on the final #endif says /* SEMANTIC_H */.  Change this to the
correct symbol.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 symbol.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/symbol.h b/symbol.h
index 9d939cf..f308763 100644
--- a/symbol.h
+++ b/symbol.h
@@ -272,4 +272,4 @@ #define is_restricted_type(type) (get_sy
 #define is_bitfield_type(type)   (get_sym_type(type) == SYM_BITFIELD)
 extern int is_ptr_type(struct symbol *);
 
-#endif /* SEMANTIC_H */
+#endif /* SYMBOL_H */
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix mistaken comparison that becomes a no-op. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix mistaken comparison that becomes a no-op.
Date: Mon, 18 Dec 2006 21:10:56 +0000
Message-ID: <20061218211056.GA28336 () chrisli ! org>
--------------------
Good catch. Do you find it by having some some code which triggers
this?

Chris

On Mon, Dec 18, 2006 at 08:44:35PM +0000, James Westby wrote:
> Fix a mistake in same_cast_type where the second test became a no-op as it
> compared a value to itself, rather than to the second operand.
> 
> Signed-off-by: James Westby <jw+debian@jameswestby.net>
> ---
>  evaluate.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)
> 
> diff --git a/evaluate.c b/evaluate.c
> index ca49ed0..e3aa2fe 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -179,7 +179,7 @@ left:
>  
>  static int same_cast_type(struct symbol *orig, struct symbol *new)
>  {
> -	return orig->bit_size == new->bit_size && orig->bit_offset == orig->bit_offset;
> +	return orig->bit_size == new->bit_size && orig->bit_offset == new->bit_offset;
>  }
>  
>  static struct symbol *base_type(struct symbol *node, unsigned long *modp, unsigned long *asp)
> -- 
> 1.4.4.2
> 
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: James Westby <jw+debian () jameswestby ! net>
To: linux-sparse
Subject: Re: [PATCH] Fix mistaken comparison that becomes a no-op.
Date: Mon, 18 Dec 2006 21:31:11 +0000
Message-ID: <20061218213111.GB8251 () jameswestby ! net>
--------------------
On (18/12/06 13:10), Christopher Li wrote:
> Good catch. Do you find it by having some some code which triggers
> this?
> 

No, I'm currently reading the code trying to work out what sparse
actually does, and writing documentation as I go.

I realised after I sent it that I should perhaps have done some testing,
it just seemed so obvious I didn't think to.

James

-- 
  James Westby   --    GPG Key ID: B577FE13    --     http://jameswestby.net/
  seccure key - (3+)k7|M*edCX/.A:n*N!>|&7U.L#9E)Tu)T0>AM - secp256r1/nistp256

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix mistaken comparison that becomes a no-op.
Date: Sat, 27 Jan 2007 09:39:50 +0000
Message-ID: <45BB1DE6.5060706 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigAEAD2C143C0C43ABB41AEFAE
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

James Westby wrote:
> Fix a mistake in same_cast_type where the second test became a no-op as=
 it
> compared a value to itself, rather than to the second operand.

Applied; good catch!

- Josh Triplett



--------------enigAEAD2C143C0C43ABB41AEFAE
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFux3mGJuZRtD+evsRAuC6AKCktte4aaX2lmxfOD1YFrLQLcaxygCfUB+3
LDOId98F5lCTIafiks/tWMg=
=T2xE
-----END PGP SIGNATURE-----

--------------enigAEAD2C143C0C43ABB41AEFAE--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Parse and track multiple contexts by expression ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Parse and track multiple contexts by expression
Date: Thu, 24 Aug 2006 19:21:13 +0000
Message-ID: <1156447273.3418.34.camel () josh-work ! beaverton ! ibm ! com>
--------------------
sparse currently only tracks one global context for __context__ and
__attribute__((context)).  Add support for parsing an additional argument to
each of these which gives a context expression.  For __attribute__((context)),
store each context attribute as a separate context structure containing the
expression, the entry context, and the exit context, and keep a list of these
structures in the ctype.  For __context__, store the context expression in the
context instruction.  Modify the various frontends to adapt to this change,
without changing functionality.

This change should not affect parsing of programs which worked with previous
versions of sparse, unless those programs use comma expressions as arguments
to __context__ or __attribute__((context)), which seems highly dubious and
unlikely.  sparse with -Wcontext generates identical output with or without
this change on Linux 2.6.18-rc4.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 allocate.c   |    1 +
 allocate.h   |    1 +
 check.c      |    8 +++++++-
 linearize.c  |   49 ++++++++++++++++++++++++++++---------------------
 linearize.h  |    1 +
 parse.c      |   36 +++++++++++++++++++++++++-----------
 parse.h      |    5 ++++-
 show-parse.c |   17 +++++++++++++----
 symbol.c     |    9 +++++++--
 symbol.h     |   12 +++++++++++-
 10 files changed, 98 insertions(+), 41 deletions(-)

diff --git a/allocate.c b/allocate.c
index 4894e59..f3d29a6 100644
--- a/allocate.c
+++ b/allocate.c
@@ -113,6 +113,7 @@ void show_allocations(struct allocator_s
 
 ALLOCATOR(ident, "identifiers");
 ALLOCATOR(token, "tokens");
+ALLOCATOR(context, "contexts");
 ALLOCATOR(symbol, "symbols");
 ALLOCATOR(expression, "expressions");
 ALLOCATOR(statement, "statements");
diff --git a/allocate.h b/allocate.h
index ab6bd0a..33703fe 100644
--- a/allocate.h
+++ b/allocate.h
@@ -61,6 +61,7 @@ #define ALLOCATOR(x, n) __ALLOCATOR(stru
 
 DECLARE_ALLOCATOR(ident);
 DECLARE_ALLOCATOR(token);
+DECLARE_ALLOCATOR(context);
 DECLARE_ALLOCATOR(symbol);
 DECLARE_ALLOCATOR(expression);
 DECLARE_ALLOCATOR(statement);
diff --git a/check.c b/check.c
index bbfac44..d327c3b 100644
--- a/check.c
+++ b/check.c
@@ -234,6 +234,8 @@ static void check_instructions(struct en
 static void check_context(struct entrypoint *ep)
 {
 	struct symbol *sym = ep->name;
+	struct context *context;
+	unsigned int in_context = 0, out_context = 0;
 
 	if (verbose && ep->entry->bb->needs) {
 		pseudo_t pseudo;
@@ -246,7 +248,11 @@ static void check_context(struct entrypo
 
 	check_instructions(ep);
 
-	check_bb_context(ep, ep->entry->bb, sym->ctype.in_context, sym->ctype.out_context);
+	FOR_EACH_PTR(sym->ctype.contexts, context) {
+		in_context += context->in;
+		out_context += context->out;
+	} END_FOR_EACH_PTR(context);
+	check_bb_context(ep, ep->entry->bb, in_context, out_context);
 }
 
 static void check_symbols(struct symbol_list *list)
diff --git a/linearize.c b/linearize.c
index f47bad9..8a8a2d3 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1183,7 +1183,8 @@ static pseudo_t linearize_call_expressio
 	struct expression *arg, *fn;
 	struct instruction *insn = alloc_typed_instruction(OP_CALL, expr->ctype);
 	pseudo_t retval, call;
-	int context_diff, check;
+	struct ctype *ctype = NULL;
+	struct context *context;
 
 	if (!expr->ctype) {
 		warning(expr->pos, "call with no type!");
@@ -1197,21 +1198,8 @@ static pseudo_t linearize_call_expressio
 
 	fn = expr->fn;
 
-	check = 0;
-	context_diff = 0;
-	if (fn->ctype) {
-		int in = fn->ctype->ctype.in_context;
-		int out = fn->ctype->ctype.out_context;
-		if (in < 0) {
-			check = 1;
-			in = 0;
-		}
-		if (out < 0) {
-			check = 0;
-			out = 0;
-		}
-		context_diff = out - in;
-	}
+	if (fn->ctype)
+		ctype = &fn->ctype->ctype;
 
 	if (fn->type == EXPR_PREOP) {
 		if (fn->unop->type == EXPR_SYMBOL) {
@@ -1232,11 +1220,29 @@ static pseudo_t linearize_call_expressio
 	insn->target = retval;
 	add_one_insn(ep, insn);
 
-	if (check || context_diff) {
-		insn = alloc_instruction(OP_CONTEXT, 0);
-		insn->increment = context_diff;
-		insn->check = check;
-		add_one_insn(ep, insn);
+	if (ctype) {
+		FOR_EACH_PTR(ctype->contexts, context) {
+			int in = context->in;
+			int out = context->out;
+			int check = 0;
+			int context_diff;
+			if (in < 0) {
+				check = 1;
+				in = 0;
+			}
+			if (out < 0) {
+				check = 0;
+				out = 0;
+			}
+			context_diff = out - in;
+			if (check || context_diff) {
+				insn = alloc_instruction(OP_CONTEXT, 0);
+				insn->increment = context_diff;
+				insn->check = check;
+				insn->context_expr = context->context;
+				add_one_insn(ep, insn);
+			}
+		} END_FOR_EACH_PTR(context);
 	}
 
 	return retval;
@@ -1637,6 +1643,7 @@ static pseudo_t linearize_context(struct
 		value = expr->value;
 
 	insn->increment = value;
+	insn->context_expr = stmt->context;
 	add_one_insn(ep, insn);
 	return VOID;
 }
diff --git a/linearize.h b/linearize.h
index 66a76dc..ac946f3 100644
--- a/linearize.h
+++ b/linearize.h
@@ -105,6 +105,7 @@ struct instruction {
 		struct /* context */ {
 			int increment;
 			int check;
+			struct expression *context_expr;
 		};
 		struct /* asm */ {
 			const char *string;
diff --git a/parse.c b/parse.c
index c536ec2..bdd6e29 100644
--- a/parse.c
+++ b/parse.c
@@ -434,10 +434,17 @@ static const char * handle_attribute(str
 	}
 	if (attribute == &context_ident) {
 		if (expr && expr->type == EXPR_COMMA) {
-			int input = get_expression_value(expr->left);
-			int output = get_expression_value(expr->right);
-			ctype->in_context = input;
-			ctype->out_context = output;
+			struct context *context = alloc_context();
+			if(expr->left->type == EXPR_COMMA) {
+				context->context = expr->left->left;
+				context->in = get_expression_value(
+					expr->left->right);
+			} else {
+				context->context = NULL;
+				context->in = get_expression_value(expr->left);
+			}
+			context->out = get_expression_value(expr->right);
+			add_ptr_list(&ctype->contexts, context);
 			return NULL;
 		}
 		return "expected context input/output values";
@@ -669,9 +676,9 @@ static void apply_ctype(struct position 
 		ctype->modifiers = old | mod | extra;
 	}
 
-	/* Context mask and value */
-	ctype->in_context += thistype->in_context;
-	ctype->out_context += thistype->out_context;
+	/* Context */
+	concat_ptr_list((struct ptr_list *)thistype->contexts,
+	                (struct ptr_list **)&ctype->contexts);
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
@@ -908,16 +915,15 @@ static struct token *pointer(struct toke
 		struct symbol *ptr = alloc_symbol(token->pos, SYM_PTR);
 		ptr->ctype.modifiers = modifiers & ~MOD_STORAGE;
 		ptr->ctype.as = ctype->as;
-		ptr->ctype.in_context += ctype->in_context;
-		ptr->ctype.out_context += ctype->out_context;
+		concat_ptr_list((struct ptr_list *)ctype->contexts,
+				(struct ptr_list **)&ptr->ctype.contexts);
 		ptr->ctype.base_type = base_type;
 
 		base_type = ptr;
 		ctype->modifiers = modifiers & MOD_STORAGE;
 		ctype->base_type = base_type;
 		ctype->as = 0;
-		ctype->in_context = 0;
-		ctype->out_context = 0;
+		free_ptr_list(&ctype->contexts);
 
 		token = declaration_specifiers(token->next, ctype, 1);
 		modifiers = ctype->modifiers;
@@ -1384,6 +1390,14 @@ default_statement:
 		if (token->ident == &__context___ident) {
 			stmt->type = STMT_CONTEXT;
 			token = parse_expression(token->next, &stmt->expression);
+			if(stmt->expression->type == EXPR_PREOP
+			   && stmt->expression->op == '('
+			   && stmt->expression->unop->type == EXPR_COMMA) {
+				struct expression *expr;
+				expr = stmt->expression->unop;
+				stmt->context = expr->left;
+				stmt->expression = expr->right;
+			}
 			return expect(token, ';', "at end of statement");
 		}
 		if (token->ident == &__range___ident) {
diff --git a/parse.h b/parse.h
index 2f3a3fe..f43d431 100644
--- a/parse.h
+++ b/parse.h
@@ -39,7 +39,10 @@ struct statement {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
-		struct expression *expression;
+		struct {
+			struct expression *expression;
+			struct expression *context;
+		};
 		struct /* return_statement */ {
 			struct expression *ret_value;
 			struct symbol *ret_target;
diff --git a/show-parse.c b/show-parse.c
index 70a5b08..5437a62 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -50,18 +50,27 @@ static void do_debug_symbol(struct symbo
 		[SYM_RESTRICT] = "rstr",
 		[SYM_BAD] = "bad.",
 	};
+	struct context *context;
+	int i;
 
 	if (!sym)
 		return;
-	fprintf(stderr, "%.*s%s%3d:%lu %lx %s (as: %d, context: %x:%x) %p (%s:%d:%d)\n",
+	fprintf(stderr, "%.*s%s%3d:%lu %lx %s (as: %d) %p (%s:%d:%d)\n",
 		indent, indent_string, typestr[sym->type],
 		sym->bit_size, sym->ctype.alignment,
-		sym->ctype.modifiers, show_ident(sym->ident),
-		sym->ctype.as, sym->ctype.in_context, sym->ctype.out_context,
+		sym->ctype.modifiers, show_ident(sym->ident), sym->ctype.as,
 		sym, stream_name(sym->pos.stream), sym->pos.line, sym->pos.pos);
+	i = 0;
+	FOR_EACH_PTR(sym->ctype.contexts, context) {
+		/* FIXME: should print context expression */
+		fprintf(stderr, "< context%d: in=%d, out=%d\n",
+			i, context->in, context->out);
+		fprintf(stderr, "  end context%d >\n", i);
+		i++;
+	} END_FOR_EACH_PTR(context);
 	if (sym->type == SYM_FN) {
-		int i = 1;
 		struct symbol *arg;
+		i = 0;
 		FOR_EACH_PTR(sym->arguments, arg) {
 			fprintf(stderr, "< arg%d:\n", i);
 			do_debug_symbol(arg, 0);
diff --git a/symbol.c b/symbol.c
index 4856349..1ebfd56 100644
--- a/symbol.c
+++ b/symbol.c
@@ -53,6 +53,11 @@ struct symbol *lookup_symbol(struct iden
 	return sym;
 }
 
+struct context *alloc_context(void)
+{
+	return __alloc_context(0);
+}
+
 struct symbol *alloc_symbol(struct position pos, int type)
 {
 	struct symbol *sym = __alloc_symbol(0);
@@ -247,8 +252,8 @@ void merge_type(struct symbol *sym, stru
 {
 	sym->ctype.as |= base_type->ctype.as;
 	sym->ctype.modifiers |= (base_type->ctype.modifiers & ~MOD_STORAGE);
-	sym->ctype.in_context += base_type->ctype.in_context;
-	sym->ctype.out_context += base_type->ctype.out_context;
+	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
+	                (struct ptr_list **)&sym->ctype.contexts);
 	sym->ctype.base_type = base_type->ctype.base_type;
 }
 
diff --git a/symbol.h b/symbol.h
index a773a0a..9d939cf 100644
--- a/symbol.h
+++ b/symbol.h
@@ -55,10 +55,20 @@ enum type {
 	SYM_BAD,
 };
 
+struct context {
+	struct expression *context;
+	unsigned int in, out;
+};
+
+extern struct context *alloc_context(void);
+
+DECLARE_PTR_LIST(context_list, struct context);
+
 struct ctype {
 	unsigned long modifiers;
 	unsigned long alignment;
-	unsigned int in_context, out_context, as;
+	struct context_list *contexts;
+	unsigned int as;
 	struct symbol *base_type;
 };
 
-- 
1.4.1.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Recognize and ignore __alias__ and __visibility__ ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: [PATCH] Recognize and ignore __alias__ and __visibility__
Date: Sun, 13 Aug 2006 05:51:58 +0000
Message-ID: <20060813055158.28706.93407.stgit () dv ! roinet ! com>
--------------------
From: Pavel Roskin <proski@gnu.org>

They are equivalent to "alias" and "visibility" except that gcc won't
complain about them in ANSI programs.

Signed-off-by: Pavel Roskin <proski@gnu.org>
---

 ident-list.h |    4 ++--
 parse.c      |    4 ++++
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/ident-list.h b/ident-list.h
index 95bb96a..ecdce6d 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -56,8 +56,8 @@ IDENT(__const); IDENT(__const__); IDENT(
 IDENT(__noreturn__); IDENT(regparm); IDENT(weak); IDENT(__weak__);
 IDENT(__no_instrument_function__); IDENT(no_instrument_function);
 IDENT(__sentinel__); IDENT(sentinel);
-IDENT(alias); IDENT(pure); IDENT(always_inline);
-IDENT(syscall_linkage); IDENT(visibility);
+IDENT(alias); IDENT(__alias__); IDENT(pure); IDENT(always_inline);
+IDENT(syscall_linkage); IDENT(visibility); IDENT(__visibility__);
 IDENT(bitwise); IDENT(__bitwise__);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
diff --git a/parse.c b/parse.c
index c536ec2..1c9aab8 100644
--- a/parse.c
+++ b/parse.c
@@ -530,6 +530,8 @@ static const char * handle_attribute(str
 		return NULL;
 	if (attribute == &alias_ident)
 		return NULL;
+	if (attribute == &__alias___ident)
+		return NULL;
 	if (attribute == &pure_ident ||
 	    attribute == &__pure___ident)
 		return NULL;
@@ -539,6 +541,8 @@ static const char * handle_attribute(str
 		return NULL;
 	if (attribute == &visibility_ident)
 		return NULL;
+	if (attribute == &__visibility___ident)
+		return NULL;
 	if (attribute == &deprecated_ident ||
 	    attribute == &__deprecated___ident)
 		return NULL;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] Recognize and ignore __alias__ and __visibility__
Date: Mon, 14 Aug 2006 15:52:25 +0000
Message-ID: <1155570745.5410.8.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Sun, 2006-08-13 at 01:51 -0400, Pavel Roskin wrote:
> diff --git a/parse.c b/parse.c
> index c536ec2..1c9aab8 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -530,6 +530,8 @@ static const char * handle_attribute(str
>  		return NULL;
>  	if (attribute == &alias_ident)
>  		return NULL;
> +	if (attribute == &__alias___ident)
> +		return NULL;
>  	if (attribute == &pure_ident ||
>  	    attribute == &__pure___ident)
>  		return NULL;
> @@ -539,6 +541,8 @@ static const char * handle_attribute(str
>  		return NULL;
>  	if (attribute == &visibility_ident)
>  		return NULL;
> +	if (attribute == &__visibility___ident)
> +		return NULL;
>  	if (attribute == &deprecated_ident ||
>  	    attribute == &__deprecated___ident)
>  		return NULL;

Stylistically, it looks like all of the existing ignored keywords in
this function use a single combined if condition for the underscored and
non-underscored versions of a given keyword, rather than two separate if
conditions.  For consistency, what about something like the following
instead:

diff --git a/ident-list.h b/ident-list.h
index 95bb96a..ecdce6d 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -56,8 +56,8 @@ IDENT(__const); IDENT(__const__); IDENT(
 IDENT(__noreturn__); IDENT(regparm); IDENT(weak); IDENT(__weak__);
 IDENT(__no_instrument_function__); IDENT(no_instrument_function);
 IDENT(__sentinel__); IDENT(sentinel);
-IDENT(alias); IDENT(pure); IDENT(always_inline);
-IDENT(syscall_linkage); IDENT(visibility);
+IDENT(alias); IDENT(__alias__); IDENT(pure); IDENT(always_inline);
+IDENT(syscall_linkage); IDENT(visibility); IDENT(__visibility__);
 IDENT(bitwise); IDENT(__bitwise__);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
diff --git a/parse.c b/parse.c
index c536ec2..6857541 100644
--- a/parse.c
+++ b/parse.c
@@ -528,7 +528,8 @@ static const char * handle_attribute(str
 	if (attribute == &weak_ident ||
 	    attribute == &__weak___ident)
 		return NULL;
-	if (attribute == &alias_ident)
+	if (attribute == &alias_ident ||
+	    attribute == &__alias___ident)
 		return NULL;
 	if (attribute == &pure_ident ||
 	    attribute == &__pure___ident)
@@ -537,7 +538,8 @@ static const char * handle_attribute(str
 		return NULL;
 	if (attribute == &syscall_linkage_ident)
 		return NULL;
-	if (attribute == &visibility_ident)
+	if (attribute == &visibility_ident ||
+	    attribute == &__visibility___ident)
 		return NULL;
 	if (attribute == &deprecated_ident ||
 	    attribute == &__deprecated___ident)

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH] Recognize and ignore __alias__ and __visibility__
Date: Mon, 14 Aug 2006 19:25:29 +0000
Message-ID: <1155583529.24307.1.camel () dv>
--------------------
On Mon, 2006-08-14 at 08:52 -0700, Josh Triplett wrote:
> Stylistically, it looks like all of the existing ignored keywords in
> this function use a single combined if condition for the underscored and
> non-underscored versions of a given keyword, rather than two separate if
> conditions.  For consistency, what about something like the following
> instead:

Thanks for this improvement!

Signed-off-by: Pavel Roskin <proski@gnu.org>

-- 
Regards,
Pavel Roskin


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Sparse Ctags ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Sparse Ctags
Date: Fri, 08 Dec 2006 02:27:05 +0000
Message-ID: <20061208022705.GA18370 () chrisli ! org>
--------------------
Here is my attempt to write a Ctags base on sparse.
It depend on the result from actually preprocessing the C source file.
It can handle the tags from macro expansion.

It works well enough for me to locate "int32_t" and "clear_token_alloc".

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/symbol.h
===================================================================
--- sparse.orig/symbol.h	2006-12-07 18:27:50.000000000 -0800
+++ sparse/symbol.h	2006-12-07 18:27:52.000000000 -0800
@@ -133,6 +133,10 @@ struct symbol {
 	union /* backend */ {
 		struct basic_block *bb_target;	/* label */
 		void *aux;			/* Auxiliary info, eg. backend information */
+		struct {			/* sparse ctags */
+			char kind;
+			unsigned int visited:1;
+		};
 	};
 	pseudo_t pseudo;
 };
Index: sparse/Makefile
===================================================================
--- sparse.orig/Makefile	2006-12-07 18:27:50.000000000 -0800
+++ sparse/Makefile	2006-12-07 18:27:52.000000000 -0800
@@ -22,7 +22,7 @@ LIBDIR=$(PREFIX)/lib
 INCLUDEDIR=$(PREFIX)/include
 PKGCONFIGDIR=$(PREFIX)/share/pkgconfig
 
-PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize example test-unssa test-dissect
+PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize example test-unssa test-dissect sctags
 INST_PROGRAMS=sparse cgcc
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
@@ -93,6 +93,9 @@ test-unssa: test-unssa.o $(LIBS)
 test-dissect: test-dissect.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+sctags: sctags.o
+	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+
 $(LIB_FILE): $(LIB_OBJS)
 	$(AR) rcs $@ $(LIB_OBJS)
 
@@ -122,6 +125,7 @@ test-lexing.o: $(LIB_H)
 test-parsing.o: $(LIB_H)
 test-linearize.o: $(LIB_H)
 test-dissect.o: $(LIB_H)
+sctags.o: $(LIB_H)
 compile.o: $(LIB_H) compile.h
 compile-i386.o: $(LIB_H) compile.h
 tokenize.o: $(LIB_H)
Index: sparse/sctags.c
===================================================================
--- sparse.orig/sctags.c	2006-12-07 18:27:52.000000000 -0800
+++ sparse/sctags.c	2006-12-07 18:28:11.000000000 -0800
@@ -0,0 +1,202 @@
+/*
+ * Sparse Ctags
+ * 
+ * SCtags generate tags from preprocessing results.
+ *
+ * Copyright (C) 2006 Christopher Li
+ *
+ * Licensed under the Open Software License version 1.1
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "parse.h"
+#include "scope.h"
+
+static struct symbol_list *taglist = NULL;
+
+static void examine_symbol(struct symbol *sym);
+
+#define MAX(_x,_y) ((_x) > (_y) ? (_x) : (_y))
+
+static int cmp_sym(const void* m, const void*n)
+{
+	struct ident *a = ((struct symbol*)m)->ident;
+	struct ident *b = ((struct symbol*)n)->ident;
+	int ret = strncmp(a->name, b->name, MAX(a->len, b->len));
+	if (!ret) {
+		struct position a = ((struct symbol*)m)->pos;
+		struct position b = ((struct symbol*)n)->pos;
+
+		ret = strcmp(stream_name(a.stream), stream_name(b.stream));
+		if (!ret)
+			return a.line < b.line;
+	}
+	return ret;
+}
+
+static void show_tag_header(void)
+{
+	printf("!_TAG_FILE_FORMAT\t2\t/extended format; --format=1 will not append ;\" to lines/\n");
+	printf("!_TAG_FILE_SORTED\t0\t/1=unsorted, 1=sorted, 2=foldcase/\n");
+	printf("!_TAG_PROGRAM_AUTHOR\tChristopher Li\t/sparse@chrisli.org/\n");
+	printf("!_TAG_PROGRAM_NAME\tSparse Ctags\t//\n");
+	printf("!_TAG_PROGRAM_URL\thttp://kernel.org/pub/linux/kernel/people/josh/sparse/\t/official site/\n");
+	printf("!_TAG_PROGRAM_VERSION\t0.01\t//\n");
+}
+
+static inline void show_symbol_tag(struct symbol *sym)
+{
+	printf("%s\t%s\t%d;\"\t%c\tfile:\n", show_ident(sym->ident),
+	       stream_name(sym->pos.stream), sym->pos.line, (int)sym->aux);
+}
+
+static void show_tags(struct symbol_list *list)
+{
+	struct symbol *sym;
+	struct ident *ident = NULL;
+	struct position pos = {};
+	static const char *filename;
+
+	if (!list)
+		return;
+	show_tag_header();
+	FOR_EACH_PTR(list, sym) {
+		if (ident == sym->ident && pos.line == sym->pos.line &&
+		    !strcmp(filename, stream_name(sym->pos.stream)))
+			continue;
+
+		show_symbol_tag(sym);
+		ident = sym->ident;
+		pos = sym->pos;
+		filename = stream_name(sym->pos.stream);
+	} END_FOR_EACH_PTR(sym);
+}
+
+static inline void add_tag(struct symbol *sym)
+{
+	if (sym->ident && !sym->visited) {
+		sym->visited = 1;
+		add_symbol(&taglist, sym);
+	}
+}
+
+
+static inline void examine_members(struct symbol_list *list)
+{
+	struct symbol *sym;
+
+	FOR_EACH_PTR(list, sym) {
+		sym->kind = 'm';
+		examine_symbol(sym);
+	} END_FOR_EACH_PTR(sym);
+}
+
+static void examine_symbol(struct symbol *sym)
+{
+	struct symbol *base = sym;
+
+	if (!sym || sym->visited)
+		return;
+	if (sym->ident && sym->ident->reserved)
+		return;
+
+	add_tag(sym);
+	base = sym->ctype.base_type;
+
+	switch (sym->type) {
+	case SYM_NODE:
+		if (base->type == SYM_FN)
+			sym->kind = 'f';
+		examine_symbol(base);
+		break;
+	case SYM_STRUCT:
+		sym->kind = 's';
+		examine_members(sym->symbol_list);
+		break;
+	case SYM_UNION:
+		sym->kind = 'u';
+		examine_members(sym->symbol_list);
+		break;
+	case SYM_ENUM:
+		sym->kind = 'e';
+	case SYM_PTR:
+	case SYM_TYPEOF:
+	case SYM_BITFIELD:
+	case SYM_FN:
+	case SYM_ARRAY:
+		examine_symbol(sym->ctype.base_type);
+		break;
+	case SYM_BASETYPE:
+		break;
+		
+	default:
+		die("unknown symbol %s namespace:%d type:%d\n", show_ident(sym->ident),
+		    sym->namespace, sym->type);
+	}
+	if (!sym->kind)
+		sym->kind = 'v';
+	return;
+}
+
+static void examine_namespace(struct symbol *sym)
+{
+	if (sym->visited)
+		return;
+	if (sym->ident && sym->ident->reserved)
+		return;
+
+	switch(sym->namespace) {
+	case NS_LABEL:
+		sym->kind = 'l';
+		break;
+	case NS_PREPROCESSOR:
+		break;
+	case NS_MACRO:
+	case NS_UNDEF:
+		sym->kind = 'd';
+		break;
+	case NS_TYPEDEF:
+		sym->kind = 't';
+	case NS_SYMBOL:
+	case NS_STRUCT:
+		examine_symbol(sym);
+		break;
+	default:
+		die("unknown namespace %d symbol:%s type:%d\n", sym->namespace,
+		    show_ident(sym->ident), sym->type);
+	}
+	add_tag(sym);
+}
+
+static inline void examine_symbol_list(struct symbol_list *list)
+{
+	struct symbol *sym;
+
+	if (!list)
+		return;
+	FOR_EACH_PTR(list, sym) {
+		examine_namespace(sym);
+	} END_FOR_EACH_PTR(sym);
+}
+
+
+int main(int argc, char **argv)
+{
+	struct string_list *filelist = NULL;
+	char *file;
+
+	examine_symbol_list(sparse_initialize(argc, argv, &filelist));
+	FOR_EACH_PTR_NOTAG(filelist, file) {
+		sparse(file);
+		examine_symbol_list(file_scope->symbols);
+	} END_FOR_EACH_PTR_NOTAG(file);
+	examine_symbol_list(global_scope->symbols);
+	sort_list((struct ptr_list**)&taglist, cmp_sym);
+	show_tags(taglist);
+	return 0;
+}
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Support -Wall flag ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: [PATCH] Support -Wall flag
Date: Tue, 01 Aug 2006 17:50:08 +0000
Message-ID: <20060801175008.11809.99999.stgit () dv ! roinet ! com>
--------------------
From: Pavel Roskin <proski@gnu.org>

If -Wall is specified, enable all warnings except those explicitly
disabled by -Wno-* switches.

Signed-off-by: Pavel Roskin <proski@gnu.org>
---

 lib.c |   30 +++++++++++++++++++++++++++---
 1 files changed, 27 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index feb755a..faafdf8 100644
--- a/lib.c
+++ b/lib.c
@@ -325,24 +325,37 @@ static const struct warning {
 	{ "shadow", &Wshadow },
 };
 
+enum {
+	WARNING_OFF,
+	WARNING_ON,
+	WARNING_FORCE_OFF
+};
+
 
 static char **handle_switch_W(char *arg, char **next)
 {
-	int no = 0;
+	int flag = WARNING_ON;
 	char *p = arg + 1;
 	unsigned i;
 
+	if (!strcmp(p, "all")) {
+		for (i = 0; i < sizeof(warnings) / sizeof(warnings[0]); i++) {
+			if (*warnings[i].flag != WARNING_FORCE_OFF)
+				*warnings[i].flag = WARNING_ON;
+		}
+	}
+
 	// Prefixes "no" and "no-" mean to turn warning off.
 	if (p[0] == 'n' && p[1] == 'o') {
 		p += 2;
 		if (p[0] == '-')
 			p++;
-		no = 1;
+		flag = WARNING_FORCE_OFF;
 	}
 
 	for (i = 0; i < sizeof(warnings) / sizeof(warnings[0]); i++) {
 		if (!strcmp(p,warnings[i].name)) {
-			*warnings[i].flag = !no;
+			*warnings[i].flag = flag;
 			return next;
 		}
 	}
@@ -351,6 +364,16 @@ static char **handle_switch_W(char *arg,
 	return next;
 }
 
+static void handle_switch_W_finalize(void)
+{
+	unsigned i;
+
+	for (i = 0; i < sizeof(warnings) / sizeof(warnings[0]); i++) {
+		if (*warnings[i].flag == WARNING_FORCE_OFF)
+			*warnings[i].flag = WARNING_OFF;
+	}
+}
+
 static char **handle_switch_U(char *arg, char **next)
 {
 	const char *name = arg + 1;
@@ -608,6 +631,7 @@ struct symbol_list *sparse_initialize(in
 		 */
 		argv[files++] = arg;
 	}
+	handle_switch_W_finalize();
 
 	list = NULL;
 	argv[files] = NULL;

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Update README to match changes in the initialization ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Update README to match changes in the initialization
Date: Tue, 27 Feb 2007 19:05:53 +0000
Message-ID: <45E48111.2000107 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigDA51990BCB93A91B4CA6C433
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

James Westby wrote:
> On (18/12/06 17:01), James Westby wrote:
>> There have been changes in the functions to call to get the parse tree=

>> from sparse, so update the README file to reflect these changes.
>=20
> My apologies, I didn't think that this message had made it, and the
> patch is incorrect anyway. My other patch supercedes this one.

OK.  I've applied your superseding patch, so I'll ignore this one.

- Josh Triplett



--------------enigDA51990BCB93A91B4CA6C433
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5IERGJuZRtD+evsRAqnoAKCwl6RZzzQAeDeG2zxZtKI/pAJ3CgCgkPAo
csl0VOhLEMfZNFsy24hCrOw=
=purs
-----END PGP SIGNATURE-----

--------------enigDA51990BCB93A91B4CA6C433--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Update README to match changes in the initialization code ===

From: James Westby <jw+debian () jameswestby ! net>
To: linux-sparse
Subject: [PATCH] Update README to match changes in the initialization code
Date: Mon, 18 Dec 2006 17:01:13 +0000
Message-ID: <20061218170107.GA7269 () jameswestby ! net>
--------------------
There have been changes in the functions to call to get the parse tree
from sparse, so update the README file to reflect these changes.

Signed-off-by: James Westby <jw+debian@jameswestby.net>
---
 README |   20 +++-----------------
 1 files changed, 3 insertions(+), 17 deletions(-)

diff --git a/README b/README
index 6b1034b..b9ee73c 100644
--- a/README
+++ b/README
@@ -47,28 +47,14 @@ requires the information.
 
 This means that a user of the library will literally just need to do
 
-	struct token *token;
-	int fd = open(filename, O_RDONLY);
 	struct symbol_list *list = NULL;
 
-	if (fd < 0)
-		exit_with_complaint();
-
-	// Initialize parse symbols
-	init_symbols();
-
-	// Tokenize the input stream
-	token = tokenize(filename, fd, NULL);
-
-	// Pre-process the stream
-	token = preprocess(token);
-
-	// Parse the resulting C code
-	translation_unit(token, &list);
+	// Initialise sparse and tokenize, preprocess and parse the file.
+	list = sparse(filename);
 
 	// Evaluate the types now if we want to
 	// Or leave it until later.
-	symbol_iterate(list, evaluate_symbol, NULL);
+	evaluate_symbol_list(list);
 
 and he is now done - having a full C parse of the file he opened.  The
 library doesn't need any more setup, and once done does not impose any
-- 
1.4.4.2

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: James Westby <jw+debian () jameswestby ! net>
To: linux-sparse
Subject: Re: [PATCH] Update README to match changes in the initialization code
Date: Mon, 18 Dec 2006 22:43:23 +0000
Message-ID: <20061218224322.GD8251 () jameswestby ! net>
--------------------
On (18/12/06 17:01), James Westby wrote:
> There have been changes in the functions to call to get the parse tree
> from sparse, so update the README file to reflect these changes.
> 

My apologies, I didn't think that this message had made it, and the
patch is incorrect anyway. My other patch supercedes this one.

Thanks,

James

-- 
  James Westby   --    GPG Key ID: B577FE13    --     http://jameswestby.net/
  seccure key - (3+)k7|M*edCX/.A:n*N!>|&7U.L#9E)Tu)T0>AM - secp256r1/nistp256

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Update the information in README about using the library. ===

From: James Westby <jw+debian () jameswestby ! net>
To: linux-sparse
Subject: [PATCH] Update the information in README about using the library.
Date: Mon, 18 Dec 2006 22:00:21 +0000
Message-ID: <20061218220021.GC8251 () jameswestby ! net>
--------------------
Changes in the library have left the README giving out of date information
on how to intialise the library and get the symbols out of it. Update the
documentation to match the latest functions.

Signed-off-by: James Westby <jw+debian@jameswestby.net>
---
 README |   29 ++++++++---------------------
 1 files changed, 8 insertions(+), 21 deletions(-)

diff --git a/README b/README
index 6b1034b..69492ab 100644
--- a/README
+++ b/README
@@ -47,35 +47,22 @@ requires the information.
 
 This means that a user of the library will literally just need to do
 
-	struct token *token;
-	int fd = open(filename, O_RDONLY);
-	struct symbol_list *list = NULL;
+  struct string_list *filelist = NULL;
+  char *file;
 
-	if (fd < 0)
-		exit_with_complaint();
+  action(sparse_initialize(argc, argv, filelist));
 
-	// Initialize parse symbols
-	init_symbols();
-
-	// Tokenize the input stream
-	token = tokenize(filename, fd, NULL);
-
-	// Pre-process the stream
-	token = preprocess(token);
-
-	// Parse the resulting C code
-	translation_unit(token, &list);
-
-	// Evaluate the types now if we want to
-	// Or leave it until later.
-	symbol_iterate(list, evaluate_symbol, NULL);
+  FOR_EACH_PTR_NOTAG(filelist, file) {
+    action(sparse(file));
+  } END_FOR_EACH_PTR_NOTAG(file);
 
 and he is now done - having a full C parse of the file he opened.  The
 library doesn't need any more setup, and once done does not impose any
 more requirements.  The user is free to do whatever he wants with the
 parse tree that got built up, and needs not worry about the library ever
 again.  There is no extra state, there are no parser callbacks, there is
-only the parse tree that is described by the header files. 
+only the parse tree that is described by the header files. The action 
+funtion takes a pointer to a symbol_list and does whatever it likes with it.
 
 The library also contains (as an example user) a few clients that do the
 preprocessing, parsing and type evaluation and just print out the
-- 
1.4.4.2


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Use $(BINDIR) consistently in Makefile rather than ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] Use $(BINDIR) consistently in Makefile rather than
Date: Mon, 07 Aug 2006 16:44:44 +0000
Message-ID: <1154969084.14202.5.camel () josh-work ! beaverton ! ibm ! com>
--------------------
The Makefile has variables for both PREFIX (default $(HOME)) and BINDIR
(default $(PREFIX)/bin); however, it then uses $(PREFIX)/bin in several other
places, making it difficult to install to an alternate BINDIR.  Fix this by
using $(BINDIR) consistently throughout the Makefile.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 Makefile |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/Makefile b/Makefile
index 378ee72..6755e07 100644
--- a/Makefile
+++ b/Makefile
@@ -45,11 +45,11 @@ #
 #		"The better to keep you on your toes, my dear".
 #
 install: check $(SLIB_FILE) bin-dir
-	if test $< -nt $(PREFIX)/bin/sparse ; then install -v $< $(BINDIR)/sparse ; install -v $(SLIB_FILE) $(BINDIR) ; fi
+	if test $< -nt $(BINDIR)/sparse ; then install -v $< $(BINDIR)/sparse ; install -v $(SLIB_FILE) $(BINDIR) ; fi
 
 bin-dir:
-	@if ! test -d $(PREFIX)/bin; then \
-		echo "No '$(PREFIX)/bin' directory to install in"; \
+	@if ! test -d $(BINDIR); then \
+		echo "No '$(BINDIR)' directory to install in"; \
 		echo "Please create it and add it to your PATH"; \
 		exit 1; \
 	fi


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Warning for mixing enums of different types ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Warning for mixing enums of different types
Date: Tue, 28 Mar 2006 20:10:58 +0000
Message-ID: <20060328201058.43BB1C000E2 () dunnock ! rentec ! com>
--------------------

[This is a resend.]

This patch adds a warning when enums of different types are mixed.
I found a handful of problems with this in my own code -- nothing
that testing could have revealed at this point, but if someone
has added an extra flag to an enum, things would have gone "boom!"

Morten



=============================================================================

typedef enum { A1, A2 } enumA;
typedef enum { B1 = 10, B2 } enumB;

static void Afunc (enumA a) { }


int
main (int argc, char **argv)
{
  enumA a = A1;

  switch (A1) {
  case A1: break;
  case A2: break;
  case B1: break;  // Warn
  case B2: break;  // Warn
  default: break;
  }

  switch (1) {
  case A1: break;
  case A2: break;
  case B1: break;  // Warn
  case B2: break;  // Warn
  default: break;
  }

  switch (1) {
  case A1 ... B2: break;  // Warn
  default: break;
  }

  (void)(1 ? a : B1);  // Warn
  (void)(A1 == B1);  // Warn

  (void)(A1 << B1);  // No warning wanted

  a = B1;  // Warn

  Afunc (B1);  // Warn

  return 0;
}

=============================================================================


Signed-off-by: Morten Welinder <terra@gnome.org>

diff --git a/evaluate.c b/evaluate.c
index 1a12b67..2c70cee 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -238,6 +238,23 @@ static int is_same_type(struct expressio
 	return 0;
 }
 
+static void
+warn_for_different_enum_types (struct position pos,
+			       struct symbol *typea,
+			       struct symbol *typeb)
+{
+	if (typea->type == SYM_NODE)
+		typea = typea->ctype.base_type;
+	if (typeb->type == SYM_NODE)
+		typeb = typeb->ctype.base_type;
+
+	if (typea == typeb)
+		return;
+
+	if (typea->type == SYM_ENUM && typeb->type == SYM_ENUM)
+		warning(pos, "mixing different enum types");
+}
+
 /*
  * This gets called for implicit casts in assignments and
  * integer promotion. We often want to try to move the
@@ -249,6 +266,8 @@ static struct expression * cast_to(struc
 {
 	struct expression *expr;
 
+	warn_for_different_enum_types (old->pos, old->ctype, type);
+
 	if (is_same_type(old, type))
 		return old;
 
@@ -267,6 +286,8 @@ static struct expression * cast_to(struc
 		break;
 
 	case EXPR_IMPLIED_CAST:
+		warn_for_different_enum_types(old->pos, old->ctype, type);
+
 		if (old->ctype->bit_size >= type->bit_size) {
 			struct expression *orig = old->cast_expression;
 			if (same_cast_type(orig->ctype, type))
@@ -441,12 +462,16 @@ static struct symbol *compatible_restric
 
 	if (ltype->type == SYM_NODE)
 		ltype = ltype->ctype.base_type;
-	if (ltype->type == SYM_ENUM)
-		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_NODE)
 		rtype = rtype->ctype.base_type;
+
+	warn_for_different_enum_types(right->pos, ltype, rtype);
+
+	if (ltype->type == SYM_ENUM)
+		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_ENUM)
 		rtype = rtype->ctype.base_type;
+
 	if (is_restricted_type(ltype)) {
 		if (is_restricted_type(rtype)) {
 			if (ltype == rtype)
@@ -2604,7 +2629,9 @@ static void evaluate_case_statement(stru
 	evaluate_statement(stmt->case_statement);
 }
 
-static void check_case_type(struct expression *switch_expr, struct expression *case_expr)
+static void check_case_type(struct expression *switch_expr,
+			    struct expression *case_expr,
+			    struct expression **enumcase)
 {
 	struct symbol *switch_type, *case_type;
 	if (!case_expr)
@@ -2613,11 +2640,18 @@ static void check_case_type(struct expre
 	case_type = evaluate_expression(case_expr);
 
 	if (case_type && switch_type) {
+		if (enumcase) {
+			if (*enumcase)
+				warn_for_different_enum_types(case_expr->pos, case_type, (*enumcase)->ctype);
+			else if (is_enum_type(case_type))
+				*enumcase = case_expr;
+		}
+
 		/* Both integer types? */
-		if (is_int_type(switch_type) && is_int_type(case_type))
-			return;
 		if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
 			return;
+		if (is_int_type(switch_type) && is_int_type(case_type)) 
+			return;
 	}
 
 	sparse_error(case_expr->pos, "incompatible types for 'case' statement");
@@ -2626,15 +2660,21 @@ static void check_case_type(struct expre
 static void evaluate_switch_statement(struct statement *stmt)
 {
 	struct symbol *sym;
+	struct expression *enumcase = NULL;
+	struct expression **enumcase_holder;
 
 	evaluate_expression(stmt->switch_expression);
 	evaluate_statement(stmt->switch_statement);
 	if (!stmt->switch_expression)
 		return;
+	enumcase_holder = is_enum_type(stmt->switch_expression->ctype)
+		? NULL /* Only check cases against switch */
+		: &enumcase;
+
 	FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
 		struct statement *case_stmt = sym->stmt;
-		check_case_type(stmt->switch_expression, case_stmt->case_expression);
-		check_case_type(stmt->switch_expression, case_stmt->case_to);
+		check_case_type(stmt->switch_expression, case_stmt->case_expression, enumcase_holder);
+		check_case_type(stmt->switch_expression, case_stmt->case_to, enumcase_holder);
 	} END_FOR_EACH_PTR(sym);
 }
 
diff --git a/symbol.h b/symbol.h
index 986a9cc..a773a0a 100644
--- a/symbol.h
+++ b/symbol.h
@@ -242,6 +242,13 @@ static inline int is_int_type(const stru
 	       type->ctype.base_type == &int_type;
 }
 
+static inline int is_enum_type(const struct symbol *type)
+{
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	return (type->type == SYM_ENUM);
+}
+
 static inline int get_sym_type(struct symbol *type)
 {
 	if (type->type == SYM_NODE)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] added a bunch of gcc builtins ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] added a bunch of gcc builtins
Date: Sun, 01 Oct 2006 18:49:13 +0000
Message-ID: <20061001184913.GZ29920 () ftp ! linux ! org ! uk>
--------------------
[PATCH] added a bunch of gcc builtins

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---

[getting rid of ancient patches sitting in my tree]

 lib.c |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index cd46e03..005aaa5 100644
--- a/lib.c
+++ b/lib.c
@@ -483,6 +483,16 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(int);\n");
 	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+	add_pre_buffer("extern int __builtin_popcount(unsigned int);\n");
+	add_pre_buffer("extern int __builtin_popcountl(unsigned long);\n");
+	add_pre_buffer("extern void __builtin_prefetch (const void *, ...);\n");
+	add_pre_buffer("extern long __builtin_alpha_extbl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_extwl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_insbl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_inswl(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_insql(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_inslh(long, long);\n");
+	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 }
 
 void create_builtin_stream(void)
-- 
1.4.2.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] added a bunch of gcc builtins
Date: Tue, 24 Oct 2006 15:42:16 +0000
Message-ID: <453E3458.50001 () freedesktop ! org>
--------------------
Al Viro wrote:
> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
> ---
> 
> [getting rid of ancient patches sitting in my tree]
> 
>  lib.c |   10 ++++++++++
>  1 files changed, 10 insertions(+), 0 deletions(-)
> 

Added to my sparse tree at:
git://git.kernel.org/pub/scm/linux/kernel/git/josh/sparse.git

Thanks,
Josh Triplett

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] adding anonymous string ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] adding anonymous string
Date: Wed, 20 Dec 2006 02:34:15 +0000
Message-ID: <20061220023415.GC8137 () chrisli ! org>
--------------------
Anonymous string is one exception that the back end does
need to generate storage on (read only) data section.

Currently in order to determine a symbol is anonymous string,
we can test:
	symbol is array
	and symbol has no ident.
	and symbol base type is char.
	and symbol initializer is a string expression.

This patch add a bitfield to easier identify an anonymous string.

Signed-off-by: Christopher Li <sparse@chrisli.org>

Index: sparse/symbol.h
===================================================================
--- sparse.orig/symbol.h	2006-12-12 02:04:05.000000000 -0800
+++ sparse/symbol.h	2006-12-12 02:05:24.000000000 -0800
@@ -118,7 +118,8 @@ struct symbol {
 					initialized:1,
 					examined:1,
 					expanding:1,
-					evaluated:1;
+					evaluated:1,
+					string:1;
 			struct expression *array_size;
 			struct ctype ctype;
 			struct symbol_list *arguments;
Index: sparse/evaluate.c
===================================================================
--- sparse.orig/evaluate.c	2006-12-12 02:04:05.000000000 -0800
+++ sparse/evaluate.c	2006-12-12 02:05:24.000000000 -0800
@@ -74,6 +74,7 @@ static struct symbol *evaluate_string(st
 	sym->array_size = alloc_const_expression(expr->pos, length);
 	sym->bit_size = bits_in_char * length;
 	sym->ctype.alignment = 1;
+	sym->string = 1;
 	sym->ctype.modifiers = MOD_STATIC;
 	sym->ctype.base_type = array;
 	sym->initializer = initstr;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] bb_terminated: Use boundary values rather than specific ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] bb_terminated: Use boundary values rather than specific
Date: Fri, 01 Sep 2006 23:01:17 +0000
Message-ID: <1157151677.4217.5.camel () josh-work ! beaverton ! ibm ! com>
--------------------
The opcode enum defines the boundary values OP_TERMINATOR and
OP_TERMINATOR_END for terminator instructions; use those in bb_terminated
rather than the specific values they currently equal.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 linearize.h |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/linearize.h b/linearize.h
index ac946f3..517ec67 100644
--- a/linearize.h
+++ b/linearize.h
@@ -254,7 +254,8 @@ static inline int bb_terminated(struct b
 	if (!bb)
 		return 0;
 	insn = last_instruction(bb->insns);
-	return insn && insn->opcode >= OP_RET && insn->opcode <= OP_UNWIND;
+	return insn && insn->opcode >= OP_TERMINATOR
+	            && insn->opcode <= OP_TERMINATOR_END;
 }
 
 static inline int bb_reachable(struct basic_block *bb)
-- 
1.4.1.1



-- 
VGER BF report: H 1.73195e-14
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] cleanup write to argument array hack ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] cleanup write to argument array hack
Date: Tue, 05 Dec 2006 07:37:37 +0000
Message-ID: <457521C1.4060102 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE71F02660D9EE7BBC7ECDBF6
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> The sparse interface is a kind of snaky that it change the input argume=
nt
> array. The function sparse() does the same hack just to skip the files.=

>=20
> This patch add the ptr list for string. So sparse_initialize will
> return list of file to compile. The string pointer is not aligned
> at word boundary. This patch introduce non taged version of the ptr
> list iteration function.

Nice improvement; thanks.

Since tagged lists seem like by far the common case, I'd prefer to see
PTR_ENTRY keep its current name, as you did with add_ptr_list.  Also, you=
r
patch didn't update test-unssa.c.  I've merged your patch, with those two=

additional changes.

I'd also love to see some additional static type checking here, to preven=
t
using the untagged functions on a tagged list or vice versa at compile ti=
me,
rather than allowing mysterious corruption at runtime.

- Josh Triplett


--------------enigE71F02660D9EE7BBC7ECDBF6
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFdSHKGJuZRtD+evsRApIxAKClyLpyf8Z0oHkiniT/cANymbiAtwCgjkSf
4EdU0tmr4e0tDanRyqEZZbE=
=ez8e
-----END PGP SIGNATURE-----

--------------enigE71F02660D9EE7BBC7ECDBF6--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] dissect: cleanup report_implicit() ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH] dissect: cleanup report_implicit()
Date: Thu, 14 Dec 2006 21:37:40 +0000
Message-ID: <20061214213740.GC422 () tv-sign ! ru>
--------------------
It doesn't make sense to do report_implicit() for the anonymous structures,
check "type->ident != NULL".

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- DS/dissect.c~	2006-04-21 00:04:14.000000000 +0400
+++ DS/dissect.c	2006-04-21 01:04:14.000000000 +0400
@@ -130,12 +130,14 @@ static void report_implicit(usage_t mode
 	if (type->type != SYM_STRUCT && type->type != SYM_UNION)
 		return;
 
-	if (reporter->r_member) {
+	if (!reporter->r_member)
+		return;
+
+	if (type->ident != NULL)
 		reporter->r_member(mode, pos, type, NULL);
 
-		DO_LIST(type->symbol_list, mem,
-			report_implicit(mode, pos, base_type(mem)));
-	}
+	DO_LIST(type->symbol_list, mem,
+		report_implicit(mode, pos, base_type(mem)));
 }
 
 static inline struct symbol *expr_symbol(struct expression *expr)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] graph: Show position in basic block nodes ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] graph: Show position in basic block nodes
Date: Fri, 01 Sep 2006 21:02:06 +0000
Message-ID: <1157144526.4217.0.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Change the label for basic block nodes from the basic block address to the
position (file, line, column) of the basic block.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 graph.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/graph.c b/graph.c
index db940ae..f9eb33d 100644
--- a/graph.c
+++ b/graph.c
@@ -27,7 +27,8 @@ static void graph_ep(struct entrypoint *
 	printf("ep%p [label=\"%s\",shape=ellipse];\n",
 	       ep, show_ident(ep->name->ident));
 	FOR_EACH_PTR(ep->bbs, bb) {
-		printf("bb%p [shape=record,label=\"bb at %p\"]\n", bb, bb);
+		printf("bb%p [shape=record,label=\"%s:%d:%d\"]\n", bb, bb,
+		       stream_name(bb->pos.stream), bb->pos.line, bb->pos.pos);
 	} END_FOR_EACH_PTR(bb);
 	FOR_EACH_PTR(ep->bbs, bb) {
 		struct basic_block *child;
-- 
1.4.1.1



-- 
VGER BF report: U 0.49994
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: gcc 4.1 warnings ===

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: [PATCH] sparse: gcc 4.1 warnings
Date: Sat, 08 Apr 2006 04:14:19 +0000
Message-ID: <20060408041419.GA8943 () havoc ! gtf ! org>
--------------------

This patch kills the sparse warnings that appeared for me on FC5/x86-64,
which uses gcc 4.1.0.

Note this MAY OR MAY NOT be the right thing to do; I didn't audit each
location to see if checking the return value would be more appropriate.

Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/compile-i386.c b/compile-i386.c
index d61652e..158b879 100644
--- a/compile-i386.c
+++ b/compile-i386.c
@@ -472,12 +472,12 @@ static inline void push_cstring(struct f
 	atom->string = str;
 	atom->label = label;
 
-	add_ptr_list(&f->str_list, atom);	/* note: _not_ atom_list */
+	(void) add_ptr_list(&f->str_list, atom);     /* note: _not_ atom_list */
 }
 
 static inline void push_atom(struct function *f, struct atom *atom)
 {
-	add_ptr_list(&f->atom_list, atom);
+	(void) add_ptr_list(&f->atom_list, atom);
 }
 
 static void push_text_atom(struct function *f, const char *text)
@@ -518,7 +518,7 @@ static struct storage *stack_alloc(int n
 	f->stack_size += n_bytes;
 	f->pseudo_nr++;
 
-	add_ptr_list(&f->pseudo_list, stor);
+	(void) add_ptr_list(&f->pseudo_list, stor);
 
 	return stor;
 }
diff --git a/example.c b/example.c
index 7e30c22..42e64c1 100644
--- a/example.c
+++ b/example.c
@@ -230,7 +230,7 @@ static struct storage_hash *find_or_crea
 	if (!entry) {
 		entry = alloc_storage_hash(alloc_storage());
 		entry->pseudo = pseudo;
-		add_ptr_list(listp, entry);
+		(void) add_ptr_list(listp, entry);
 	}
 	return entry;
 }
@@ -460,7 +460,7 @@ static void mark_reg_dead(struct bb_stat
 static void add_pseudo_reg(struct bb_state *state, pseudo_t pseudo, struct hardreg *reg)
 {
 	output_comment(state, "added pseudo %s to reg %s", show_pseudo(pseudo), reg->name);
-	add_ptr_list_tag(&reg->contains, pseudo, TAG_DIRTY);
+	(void) add_ptr_list_tag(&reg->contains, pseudo, TAG_DIRTY);
 }
 
 static struct hardreg *preferred_reg(struct bb_state *state, pseudo_t target)
diff --git a/lib.h b/lib.h
index a61b2dd..7c31dd2 100644
--- a/lib.h
+++ b/lib.h
@@ -168,17 +168,17 @@ static inline void concat_instruction_li
 
 static inline void add_symbol(struct symbol_list **list, struct symbol *sym)
 {
-	add_ptr_list(list, sym);
+	(void) add_ptr_list(list, sym);
 }
 
 static inline void add_statement(struct statement_list **list, struct statement *stmt)
 {
-	add_ptr_list(list, stmt);
+	(void) add_ptr_list(list, stmt);
 }
 
 static inline void add_expression(struct expression_list **list, struct expression *expr)
 {
-	add_ptr_list(list, expr);
+	(void) add_ptr_list(list, expr);
 }
 
 #define hashval(x) ((unsigned long)(x))
diff --git a/linearize.c b/linearize.c
index f47bad9..6986517 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1664,7 +1664,7 @@ static void add_asm_input(struct entrypo
 	rule->ident = ident;
 	rule->constraint = constraint;
 	use_pseudo(pseudo, &rule->pseudo);
-	add_ptr_list(&insn->asm_rules->inputs, rule);
+	(void) add_ptr_list(&insn->asm_rules->inputs, rule);
 }
 
 static void add_asm_output(struct entrypoint *ep, struct instruction *insn, struct expression *expr,
@@ -1682,7 +1682,7 @@ static void add_asm_output(struct entryp
 	rule->ident = ident;
 	rule->constraint = constraint;
 	use_pseudo(pseudo, &rule->pseudo);
-	add_ptr_list(&insn->asm_rules->outputs, rule);
+	(void) add_ptr_list(&insn->asm_rules->outputs, rule);
 }
 
 static pseudo_t linearize_asm_statement(struct entrypoint *ep, struct statement *stmt)
diff --git a/linearize.h b/linearize.h
index 5f021a3..fa37c8b 100644
--- a/linearize.h
+++ b/linearize.h
@@ -224,17 +224,17 @@ static inline int is_branch_goto(struct 
 
 static inline void add_bb(struct basic_block_list **list, struct basic_block *bb)
 {
-	add_ptr_list(list, bb);
+	(void) add_ptr_list(list, bb);
 }
 
 static inline void add_instruction(struct instruction_list **list, struct instruction *insn)
 {
-	add_ptr_list(list, insn);
+	(void) add_ptr_list(list, insn);
 }
 
 static inline void add_multijmp(struct multijmp_list **list, struct multijmp *multijmp)
 {
-	add_ptr_list(list, multijmp);
+	(void) add_ptr_list(list, multijmp);
 }
 
 static inline void *add_pseudo(struct pseudo_list **list, struct pseudo *pseudo)
@@ -263,7 +263,7 @@ static inline int bb_reachable(struct ba
 
 static inline void add_pseudo_ptr(pseudo_t *ptr, struct pseudo_ptr_list **list)
 {
-	add_ptr_list(list, ptr);
+	(void) add_ptr_list(list, ptr);
 }
 
 static inline int has_use_list(pseudo_t p)
diff --git a/liveness.c b/liveness.c
index 8b0dfd8..5a8bb06 100644
--- a/liveness.c
+++ b/liveness.c
@@ -288,7 +288,7 @@ static void track_phi_uses(struct instru
 			continue;
 		def = phi->def;
 		assert(def->opcode == OP_PHISOURCE);
-		add_ptr_list(&def->phi_users, insn);
+		(void) add_ptr_list(&def->phi_users, insn);
 	} END_FOR_EACH_PTR(phi);
 }
 
diff --git a/parse.c b/parse.c
index 4339657..d2d24e1 100644
--- a/parse.c
+++ b/parse.c
@@ -278,7 +278,7 @@ static struct token *parse_enum_declarat
 
 		sym->initializer = expr;
 		sym->ctype.base_type = parent;
-		add_ptr_list(&entries, sym);
+		(void) add_ptr_list(&entries, sym);
 
 		if (base_type != &bad_ctype) {
 			if (ctype->type == SYM_NODE)
diff --git a/storage.c b/storage.c
index acbc477..1b34e1e 100644
--- a/storage.c
+++ b/storage.c
@@ -52,7 +52,7 @@ struct storage_hash_list *gather_storage
 		struct storage_hash *hash;
 		FOR_EACH_PTR(storage_hash_table[i], hash) {
 			if (hash->bb == bb && hash->inout == inout)
-				add_ptr_list(&list, hash);
+				(void) add_ptr_list(&list, hash);
 		} END_FOR_EACH_PTR(hash);
 	}
 	sort_hash_list(&list);
@@ -106,7 +106,7 @@ void add_storage(struct storage *storage
 	hash->pseudo = pseudo;
 	hash->inout = inout;
 
-	add_ptr_list(listp, hash);
+	(void) add_ptr_list(listp, hash);
 }
 
 
@@ -203,7 +203,7 @@ static struct storage * combine_storage(
 	FOR_EACH_PTR(src->users, usep) {
 		assert(*usep == src);
 		*usep = dst;
-		add_ptr_list(&dst->users, usep);
+		(void) add_ptr_list(&dst->users, usep);
 	} END_FOR_EACH_PTR(usep);
 
 	/* Mark it unused */
diff --git a/storage.h b/storage.h
index c1822e5..fee106f 100644
--- a/storage.h
+++ b/storage.h
@@ -69,7 +69,7 @@ static inline struct storage_hash *alloc
 	struct storage **usep = &entry->storage;
 
 	*usep = s;
-	add_ptr_list(&s->users, usep);
+	(void) add_ptr_list(&s->users, usep);
 	return entry;
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [PATCH] sparse: gcc 4.1 warnings
Date: Mon, 10 Apr 2006 13:21:57 +0000
Message-ID: <20060410132157.4AF15C000E2 () dunnock ! rentec ! com>
--------------------

This doesn't look quite right.

So it looks like gcc 4.1 complains over non-used values that are the
result of a cast.  That feels obnoxious, but in this case maybe you
could try just casting to void in add_ptr_list -- is the value ever
used?

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?iso-8859-1?Q?J=F6rn?= Engel <joern () wohnheim ! fh-wedel ! de>
To: linux-sparse
Subject: Re: [PATCH] sparse: gcc 4.1 warnings
Date: Tue, 11 Apr 2006 08:56:02 +0000
Message-ID: <20060411085602.GA11643 () wohnheim ! fh-wedel ! de>
--------------------
On Mon, 10 April 2006 20:30:28 -0400, Jeff Garzik wrote:
> Morten Welinder wrote:
> >This doesn't look quite right.
> >
> >So it looks like gcc 4.1 complains over non-used values that are the
> >result of a cast.  That feels obnoxious, but in this case maybe you
> 
> Yes, it is :)  See below for vanilla sparse build under gcc 4.1...
> 
> 
> >could try just casting to void in add_ptr_list -- is the value ever
> >used?
> 
> All uses except for add_pseudo() ignore the return value.

How about making this two functions instead?  Something like

void add_ptr_list(...)
{
	(void) __add_ptr_list(...);
}

And use the __add_ptr_list version in add_pseudo().

Hmm.  Except that this is userspace and double underscores are not
allowed.  Maybe do_add_ptr_list(...) then?

And yes, this is really obnoxious.  I have read code before that
constantly does
	(void) this(...);
	(void) that(...);
and didn't like it much.  Ignoring the issue and fixing the code
checker instead might be a better idea.

Jörn

-- 
More computing sins are committed in the name of efficiency (without
necessarily achieving it) than for any other single reason - including
blind stupidity.
-- W. A. Wulf 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?iso-8859-1?Q?J=F6rn?= Engel <joern () wohnheim ! fh-wedel ! de>
To: linux-sparse
Subject: Re: [PATCH] sparse: gcc 4.1 warnings
Date: Tue, 11 Apr 2006 09:19:09 +0000
Message-ID: <20060411091908.GC11643 () wohnheim ! fh-wedel ! de>
--------------------
On Tue, 11 April 2006 02:10:44 -0700, Chris Wedgwood wrote:
> On Tue, Apr 11, 2006 at 10:56:02AM +0200, J?rn Engel wrote:
> 
> > And yes, this is really obnoxious.  I have read code before that
> > constantly does
> > 	(void) this(...);
> > 	(void) that(...);
> > and didn't like it much.  Ignoring the issue and fixing the code
> > checker instead might be a better idea.
> 
> why not leave it just as it is?
> 
> making code ugly and unreadable because some random very of gcc is
> being stilly doesn't seem ideal

Absolutely!

Jörn

-- 
You can't tell where a program is going to spend its time. Bottlenecks
occur in surprising places, so don't try to second guess and put in a
speed hack until you've proven that's where the bottleneck is.
-- Rob Pike
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse_error() should not silence info() after ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCH] sparse_error() should not silence info() after
Date: Fri, 25 Aug 2006 21:27:04 +0000
Message-ID: <1156541224.19291.13.camel () josh-work ! beaverton ! ibm ! com>
--------------------
sparse_error() sets max_warnings = 0 to silence subsequent sparse_warning()s
or info()s; however, this also silences the info() after that sparse_error()
and subsequent sparse_errors() which still get shown.  bad_expr_type runs into
this problem: it reports an error with sparse_error() and then provides
further information with info(), which the user never sees.  Make info()
continue to print as long as the immediately preceeding warning or error does.

Thanks to Adam DiCarlo <adam.dicarlo@gmail.com> for reporting the problem.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
Cc: Adam DiCarlo <adam.dicarlo@gmail.com>
---
 lib.c |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index feb755a..05ed848 100644
--- a/lib.c
+++ b/lib.c
@@ -94,12 +94,13 @@ static void do_warn(const char *type, st
 }
 
 static int max_warnings = 100;
+static int show_info = 1;
 
 void info(struct position pos, const char * fmt, ...)
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!show_info)
 		return;
 	va_start(args, fmt);
 	do_warn("", pos, fmt, args);
@@ -110,11 +111,15 @@ void warning(struct position pos, const 
 {
 	va_list args;
 
-	if (!max_warnings)
+	if (!max_warnings) {
+		show_info = 0;
 		return;
+	}
 
-	if (!--max_warnings)
+	if (!--max_warnings) {
+		show_info = 0;
 		fmt = "too many warnings";
+	}
 
 	va_start(args, fmt);
 	do_warn("warning: ", pos, fmt, args);
@@ -126,10 +131,12 @@ void sparse_error(struct position pos, c
 	static int errors = 0;
 	va_list args;
         die_if_error = 1;
+	show_info = 1;
 	/* Shut up warnings after an error */
 	max_warnings = 0;
 	if (errors > 100) {
 		static int once = 0;
+		show_info = 0;
 		if (once)
 			return;
 		fmt = "too many errors";


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] switch to hash-based get_one_special() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] switch to hash-based get_one_special()
Date: Sun, 01 Oct 2006 18:55:02 +0000
Message-ID: <20061001185502.GA29920 () ftp ! linux ! org ! uk>
--------------------
Subject: [PATCH] switch to hash-based get_one_special()

Weird, but true: the set of C two-character punctuators and
two-symbol prefices of three-character punctuators is
distinguishable by 5-bit hash function (27 out of 32).
Application is obvious - we get much faster get_one_special()
out of that...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---

[and now all patches older than a month are gone]

 token.h    |   18 +++++++-------
 tokenize.c |   78 +++++++++++++++++++++++++++++++++++++++++++++++++++---------
 2 files changed, 75 insertions(+), 21 deletions(-)

diff --git a/token.h b/token.h
index 96b0c41..71ef151 100644
--- a/token.h
+++ b/token.h
@@ -88,13 +88,13 @@ #define COMBINATION_STRINGS {	\
 	"*=",			\
 	"/=",			\
 	"%=",			\
-	"..", "...",		\
-	"<=", "<<", "<<=",	\
-	">=", ">>", ">>=",	\
+	"<=", ">=",		\
 	"==", "!=",		\
 	"&&", "&=",		\
 	"||", "|=",		\
 	"^=", "##",		\
+	"<<", ">>", "..",	\
+	"<<=", ">>=", "..."	\
 	"",			\
 	"<", ">", "<=", ">="	\
 }
@@ -111,14 +111,8 @@ enum special_token {
 	SPECIAL_MUL_ASSIGN,
 	SPECIAL_DIV_ASSIGN,
 	SPECIAL_MOD_ASSIGN,
-	SPECIAL_DOTDOT,
-	SPECIAL_ELLIPSIS,
 	SPECIAL_LTE,
-	SPECIAL_LEFTSHIFT,
-	SPECIAL_SHL_ASSIGN,
 	SPECIAL_GTE,
-	SPECIAL_RIGHTSHIFT,
-	SPECIAL_SHR_ASSIGN,
 	SPECIAL_EQUAL,
 	SPECIAL_NOTEQUAL,
 	SPECIAL_LOGICAL_AND,
@@ -127,6 +121,12 @@ enum special_token {
 	SPECIAL_OR_ASSIGN,
 	SPECIAL_XOR_ASSIGN,
 	SPECIAL_HASHHASH,
+	SPECIAL_LEFTSHIFT,
+	SPECIAL_RIGHTSHIFT,
+	SPECIAL_DOTDOT,
+	SPECIAL_SHL_ASSIGN,
+	SPECIAL_SHR_ASSIGN,
+	SPECIAL_ELLIPSIS,
 	SPECIAL_ARG_SEPARATOR,
 	SPECIAL_UNSIGNED_LT,
 	SPECIAL_UNSIGNED_GT,
diff --git a/tokenize.c b/tokenize.c
index 497da13..67f5a67 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -283,7 +283,7 @@ got_eof:
  *  Slow path (including the logics with line-splicing and EOF sanity
  *  checks) is in nextchar_slow().
  */
-static int nextchar(stream_t *stream)
+static inline int nextchar(stream_t *stream)
 {
 	int offset = stream->offset;
 
@@ -615,12 +615,68 @@ unsigned char combinations[][3] = COMBIN
 
 #define NR_COMBINATIONS (SPECIAL_ARG_SEPARATOR - SPECIAL_BASE)
 
+/* hash function for two-character punctuators - all give unique values */
+#define special_hash(c0, c1) (((c0*8+c1*2)+((c0*8+c1*2)>>5))&31)
+
+/*
+ * note that we won't get false positives - special_hash(0,0) is 0 and
+ * entry 0 is filled (by +=), so all the missing ones are OK.
+ */
+static unsigned char hash_results[32][2] = {
+#define RES(c0, c1) [special_hash(c0, c1)] = {c0, c1}
+	RES('+', '='), /* 00 */
+	RES('/', '='), /* 01 */
+	RES('^', '='), /* 05 */
+	RES('&', '&'), /* 07 */
+	RES('#', '#'), /* 08 */
+	RES('<', '<'), /* 0a */
+	RES('<', '='), /* 0c */
+	RES('!', '='), /* 0e */
+	RES('%', '='), /* 0f */
+	RES('-', '-'), /* 10 */
+	RES('-', '='), /* 11 */
+	RES('-', '>'), /* 13 */
+	RES('=', '='), /* 15 */
+	RES('&', '='), /* 17 */
+	RES('*', '='), /* 18 */
+	RES('.', '.'), /* 1a */
+	RES('+', '+'), /* 1b */
+	RES('|', '='), /* 1c */
+	RES('>', '='), /* 1d */
+	RES('|', '|'), /* 1e */
+	RES('>', '>')  /* 1f */
+#undef RES
+};
+static int code[32] = {
+#define CODE(c0, c1, value) [special_hash(c0, c1)] = value
+	CODE('+', '=', SPECIAL_ADD_ASSIGN), /* 00 */
+	CODE('/', '=', SPECIAL_DIV_ASSIGN), /* 01 */
+	CODE('^', '=', SPECIAL_XOR_ASSIGN), /* 05 */
+	CODE('&', '&', SPECIAL_LOGICAL_AND), /* 07 */
+	CODE('#', '#', SPECIAL_HASHHASH), /* 08 */
+	CODE('<', '<', SPECIAL_LEFTSHIFT), /* 0a */
+	CODE('<', '=', SPECIAL_LTE), /* 0c */
+	CODE('!', '=', SPECIAL_NOTEQUAL), /* 0e */
+	CODE('%', '=', SPECIAL_MOD_ASSIGN), /* 0f */
+	CODE('-', '-', SPECIAL_DECREMENT), /* 10 */
+	CODE('-', '=', SPECIAL_SUB_ASSIGN), /* 11 */
+	CODE('-', '>', SPECIAL_DEREFERENCE), /* 13 */
+	CODE('=', '=', SPECIAL_EQUAL), /* 15 */
+	CODE('&', '=', SPECIAL_AND_ASSIGN), /* 17 */
+	CODE('*', '=', SPECIAL_MUL_ASSIGN), /* 18 */
+	CODE('.', '.', SPECIAL_DOTDOT), /* 1a */
+	CODE('+', '+', SPECIAL_INCREMENT), /* 1b */
+	CODE('|', '=', SPECIAL_OR_ASSIGN), /* 1c */
+	CODE('>', '=', SPECIAL_GTE), /* 1d */
+	CODE('|', '|', SPECIAL_LOGICAL_OR), /* 1e */
+	CODE('>', '>', SPECIAL_RIGHTSHIFT)  /* 1f */
+#undef CODE
+};
+
 static int get_one_special(int c, stream_t *stream)
 {
 	struct token *token;
-	unsigned char c1, c2, c3;
 	int next, value, i;
-	unsigned char *comb;
 
 	next = nextchar(stream);
 
@@ -648,17 +704,15 @@ static int get_one_special(int c, stream
 	 */
 	value = c;
 	if (cclass[next + 1] & ValidSecond) {
-		comb = combinations[0];
-		c1 = c; c2 = next; c3 = 0;
-		for (i = 0; i < NR_COMBINATIONS; i++) {
-			if (comb[0] == c1 && comb[1] == c2 && comb[2] == c3) {
-				value = i + SPECIAL_BASE;
+		i = special_hash(c, next);
+		if (hash_results[i][0] == c && hash_results[i][1] == next) {
+			value = code[i];
+			next = nextchar(stream);
+			if (value >= SPECIAL_LEFTSHIFT &&
+			    next == "==."[value - SPECIAL_LEFTSHIFT]) {
+				value += 3;
 				next = nextchar(stream);
-				if (c3)
-					break;
-				c3 = next;
 			}
-			comb += 3;
 		}
 	}
 
-- 
1.4.2.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] switch to hash-based get_one_special()
Date: Tue, 24 Oct 2006 15:42:34 +0000
Message-ID: <453E346A.1010203 () freedesktop ! org>
--------------------
Al Viro wrote:
> Weird, but true: the set of C two-character punctuators and
> two-symbol prefices of three-character punctuators is
> distinguishable by 5-bit hash function (27 out of 32).
> Application is obvious - we get much faster get_one_special()
> out of that...
> 
> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
> ---
>
> [and now all patches older than a month are gone]
> 
>  token.h    |   18 +++++++-------
>  tokenize.c |   78 +++++++++++++++++++++++++++++++++++++++++++++++++++---------
>  2 files changed, 75 insertions(+), 21 deletions(-)

Added to my sparse tree at:
git://git.kernel.org/pub/scm/linux/kernel/git/josh/sparse.git

Thanks,
Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH][RFC] Adding instruction to pseudo user tracking. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH][RFC] Adding instruction to pseudo user tracking.
Date: Wed, 20 Dec 2006 02:19:09 +0000
Message-ID: <20061220021909.GB8137 () chrisli ! org>
--------------------
The current way of tracking pseudo register user is by
keeping a list of the address of the pseudo_t member.
This address can be in part of the instruction member, the
worse case is in the argument list of the call instruction.

As the comment for address_taken() said, using the container
to get instruction pointer is wrong. It use to work with instruction
that relate to symbol address. But that is not true any more. Even
worse, it is very hard to track the pseudo usage other than symbol
address. The only reason symbol address used to works for call instruction
is because call instruction did not directly use the symbol address.

I can't find other way to safely link instruction to pseudo usage.
I bit the bullet and just add the instruction pointer to pair with
the pseudo user pointer. So sparse can get the instruction from the
pseudo user chain. It is actually useful in doing other analyze.

Testing:

I compare the linearize result with/without the patch on a few
sparse source file itself. The linearize generate exactly
the same result except the symbol address changes, which is
predictable different because the pseudo user structure allocate
memory. So I know I did not break the simplify memory operation
too badly.


Index: sparse/flow.c
===================================================================
--- sparse.orig/flow.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/flow.c	2006-12-18 13:58:32.000000000 -0800
@@ -229,27 +229,27 @@ int simplify_flow(struct entrypoint *ep)
 	return simplify_branch_nodes(ep);
 }
 
-static inline void concat_user_list(struct pseudo_ptr_list *src, struct pseudo_ptr_list **dst)
+static inline void concat_user_list(struct pseudo_user_list *src, struct pseudo_user_list **dst)
 {
 	concat_ptr_list((struct ptr_list *)src, (struct ptr_list **)dst);
 }
 
 void convert_instruction_target(struct instruction *insn, pseudo_t src)
 {
-	pseudo_t target, *usep;
-
+	pseudo_t target;
+	struct pseudo_user *pu;
 	/*
 	 * Go through the "insn->users" list and replace them all..
 	 */
 	target = insn->target;
 	if (target == src)
 		return;
-	FOR_EACH_PTR(target->users, usep) {
-		if (*usep != VOID) {
-			assert(*usep == target);
-			*usep = src;
+	FOR_EACH_PTR(target->users, pu) {
+		if (*pu->userp != VOID) {
+			assert(*pu->userp == target);
+			*pu->userp = src;
 		}
-	} END_FOR_EACH_PTR(usep);
+	} END_FOR_EACH_PTR(pu);
 	concat_user_list(target->users, &src->users);
 	target->users = NULL;
 }
@@ -360,7 +360,7 @@ found_dominator:
 		phi = alloc_phi(parent, one->target, one->size);
 		phi->ident = phi->ident ? : pseudo->ident;
 		add_instruction(&parent->insns, br);
-		use_pseudo(phi, add_pseudo(dominators, phi));
+		use_pseudo(insn, phi, add_pseudo(dominators, phi));
 	} END_FOR_EACH_PTR(parent);
 	return 1;
 }		
@@ -592,7 +592,8 @@ void check_access(struct instruction *in
 
 static void simplify_one_symbol(struct entrypoint *ep, struct symbol *sym)
 {
-	pseudo_t pseudo, src, *pp;
+	pseudo_t pseudo, src;
+	struct pseudo_user *pu;
 	struct instruction *def;
 	unsigned long mod;
 	int all, stores, complex;
@@ -614,9 +615,9 @@ static void simplify_one_symbol(struct e
 	def = NULL;
 	stores = 0;
 	complex = 0;
-	FOR_EACH_PTR(pseudo->users, pp) {
+	FOR_EACH_PTR(pseudo->users, pu) {
 		/* We know that the symbol-pseudo use is the "src" in the instruction */
-		struct instruction *insn = container(pp, struct instruction, src);
+		struct instruction *insn = pu->insn;
 
 		switch (insn->opcode) {
 		case OP_STORE:
@@ -639,7 +640,7 @@ static void simplify_one_symbol(struct e
 			warning(sym->pos, "symbol '%s' pseudo used in unexpected way", show_ident(sym->ident));
 		}
 		complex |= insn->offset;
-	} END_FOR_EACH_PTR(pp);
+	} END_FOR_EACH_PTR(pu);
 
 	if (complex)
 		goto complex_def;
@@ -655,13 +656,13 @@ static void simplify_one_symbol(struct e
 	if (def)
 		src = def->target;
 
-	FOR_EACH_PTR(pseudo->users, pp) {
-		struct instruction *insn = container(pp, struct instruction, src);
+	FOR_EACH_PTR(pseudo->users, pu) {
+		struct instruction *insn = pu->insn;
 		if (insn->opcode == OP_LOAD) {
 			check_access(insn);
 			convert_load_instruction(insn, src);
 		}
-	} END_FOR_EACH_PTR(pp);
+	} END_FOR_EACH_PTR(pu);
 
 	/* Turn the store into a no-op */
 	kill_store(def);
@@ -671,29 +672,29 @@ multi_def:
 complex_def:
 external_visibility:
 	all = 1;
-	FOR_EACH_PTR_REVERSE(pseudo->users, pp) {
-		struct instruction *insn = container(pp, struct instruction, src);
+	FOR_EACH_PTR_REVERSE(pseudo->users, pu) {
+		struct instruction *insn = pu->insn;
 		if (insn->opcode == OP_LOAD)
 			all &= find_dominating_stores(pseudo, insn, ++bb_generation, !mod);
-	} END_FOR_EACH_PTR_REVERSE(pp);
+	} END_FOR_EACH_PTR_REVERSE(pu);
 
 	/* If we converted all the loads, remove the stores. They are dead */
 	if (all && !mod) {
-		FOR_EACH_PTR(pseudo->users, pp) {
-			struct instruction *insn = container(pp, struct instruction, src);
+		FOR_EACH_PTR(pseudo->users, pu) {
+			struct instruction *insn = pu->insn;
 			if (insn->opcode == OP_STORE)
 				kill_store(insn);
-		} END_FOR_EACH_PTR(pp);
+		} END_FOR_EACH_PTR(pu);
 	} else {
 		/*
 		 * If we couldn't take the shortcut, see if we can at least kill some
 		 * of them..
 		 */
-		FOR_EACH_PTR(pseudo->users, pp) {
-			struct instruction *insn = container(pp, struct instruction, src);
+		FOR_EACH_PTR(pseudo->users, pu) {
+			struct instruction *insn = pu->insn;
 			if (insn->opcode == OP_STORE)
 				kill_dominated_stores(pseudo, insn, ++bb_generation, insn->bb, !mod, 0);
-		} END_FOR_EACH_PTR(pp);
+		} END_FOR_EACH_PTR(pu);
 
 		if (!(mod & (MOD_NONLOCAL | MOD_STATIC))) {
 			struct basic_block *bb;
Index: sparse/simplify.c
===================================================================
--- sparse.orig/simplify.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/simplify.c	2006-12-18 13:58:32.000000000 -0800
@@ -146,10 +146,27 @@ static int clean_up_phi(struct instructi
 	return if_convert_phi(insn);
 }
 
+int delete_pseudo_user_list_entry(struct pseudo_user_list **list, pseudo_t *entry, int count)
+{
+	struct pseudo_user *pu;
+
+	FOR_EACH_PTR(*list, pu) {
+		if (pu->userp == entry) {
+			DELETE_CURRENT_PTR(pu);
+			if (!--count)
+				goto out;
+		}
+	} END_FOR_EACH_PTR(pu);
+	assert(count <= 0);
+out:
+	pack_ptr_list((struct ptr_list **)list);
+	return count;
+}
+
 static inline void remove_usage(pseudo_t p, pseudo_t *usep)
 {
 	if (has_use_list(p)) {
-		delete_ptr_list_entry((struct ptr_list **)&p->users, usep, 1);
+		delete_pseudo_user_list_entry(&p->users, usep, 1);
 		if (!p->users)
 			kill_instruction(p->def);
 	}
@@ -208,11 +225,11 @@ void kill_instruction(struct instruction
  */
 static int dead_insn(struct instruction *insn, pseudo_t *src1, pseudo_t *src2, pseudo_t *src3)
 {
-	pseudo_t *usep;
-	FOR_EACH_PTR(insn->target->users, usep) {
-		if (*usep != VOID)
+	struct pseudo_user *pu;
+	FOR_EACH_PTR(insn->target->users, pu) {
+		if (*pu->userp != VOID)
 			return 0;
-	} END_FOR_EACH_PTR(usep);
+	} END_FOR_EACH_PTR(pu);
 
 	insn->bb = NULL;
 	kill_use(src1);
@@ -419,12 +436,12 @@ static int simplify_binop(struct instruc
 	return 0;
 }
 
-static void switch_pseudo(pseudo_t *pp1, pseudo_t *pp2)
+static void switch_pseudo(struct instruction *insn1, pseudo_t *pp1, struct instruction *insn2, pseudo_t *pp2)
 {
 	pseudo_t p1 = *pp1, p2 = *pp2;
 
-	use_pseudo(p2, pp1);
-	use_pseudo(p1, pp2);
+	use_pseudo(insn1, p2, pp1);
+	use_pseudo(insn2, p1, pp2);
 	remove_usage(p1, pp1);
 	remove_usage(p2, pp2);
 }
@@ -444,7 +461,7 @@ static int canonical_order(pseudo_t p1, 
 static int simplify_commutative_binop(struct instruction *insn)
 {
 	if (!canonical_order(insn->src1, insn->src2)) {
-		switch_pseudo(&insn->src1, &insn->src2);
+		switch_pseudo(insn, &insn->src1, insn, &insn->src2);
 		return REPEAT_CSE;
 	}
 	return 0;
@@ -473,7 +490,7 @@ static int simplify_associative_binop(st
 		return 0;
 	if (ptr_list_size((struct ptr_list *)def->target->users) != 1)
 		return 0;
-	switch_pseudo(&def->src1, &insn->src2);
+	switch_pseudo(def, &def->src1, insn, &insn->src2);
 	return REPEAT_CSE;
 }
 
@@ -517,7 +534,7 @@ static int simplify_one_memop(struct ins
 		struct instruction *def = addr->def;
 		if (def->opcode == OP_SYMADDR && def->src) {
 			kill_use(&insn->src);
-			use_pseudo(def->src, &insn->src);
+			use_pseudo(insn, def->src, &insn->src);
 			return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
 		}
 		if (def->opcode == OP_ADD) {
@@ -543,7 +560,7 @@ offset:
 		warning(insn->pos, "crazy programmer");
 	}
 	insn->offset += off->value;
-	use_pseudo(new, &insn->src);
+	use_pseudo(insn, new, &insn->src);
 	remove_usage(addr, &insn->src);
 	return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
 }
@@ -699,7 +716,7 @@ static int simplify_range(struct instruc
  */
 static int simplify_cond_branch(struct instruction *br, pseudo_t cond, struct instruction *def, pseudo_t *pp)
 {
-	use_pseudo(*pp, &br->cond);
+	use_pseudo(br, *pp, &br->cond);
 	remove_usage(cond, &br->cond);
 	if (def->opcode == OP_SET_EQ) {
 		struct basic_block *true = br->bb_true;
@@ -763,7 +780,7 @@ static int simplify_branch(struct instru
 					insn->bb_false = true;
 					insn->bb_true = false;
 				}
-				use_pseudo(def->src1, &insn->cond);
+				use_pseudo(insn, def->src1, &insn->cond);
 				remove_usage(cond, &insn->cond);
 				return REPEAT_CSE;
 			}
@@ -771,7 +788,7 @@ static int simplify_branch(struct instru
 		if (def->opcode == OP_CAST || def->opcode == OP_SCAST) {
 			int orig_size = def->orig_type ? def->orig_type->bit_size : 0;
 			if (def->size > orig_size) {
-				use_pseudo(def->src, &insn->cond);
+				use_pseudo(insn, def->src, &insn->cond);
 				remove_usage(cond, &insn->cond);
 				return REPEAT_CSE;
 			}
Index: sparse/memops.c
===================================================================
--- sparse.orig/memops.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/memops.c	2006-12-18 13:58:32.000000000 -0800
@@ -59,31 +59,19 @@ found_dominator:
 		phi = alloc_phi(parent, one->target, one->size);
 		phi->ident = phi->ident ? : one->target->ident;
 		add_instruction(&parent->insns, br);
-		use_pseudo(phi, add_pseudo(dominators, phi));
+		use_pseudo(insn, phi, add_pseudo(dominators, phi));
 	} END_FOR_EACH_PTR(parent);
 	return 1;
 }		
 
-/*
- * FIXME! This is wrong. Since we now distribute out the OP_SYMADDR,
- * we can no longer really use "container()" to get from a user to
- * the instruction that uses it.
- *
- * This happens to work, simply because the likelihood of the
- * (possibly non-instruction) containing the right bitpattern
- * in the right place is pretty low. But this is still wrong.
- *
- * We should make symbol-pseudos count non-load/store usage,
- * or something.
- */
 static int address_taken(pseudo_t pseudo)
 {
-	pseudo_t *usep;
-	FOR_EACH_PTR(pseudo->users, usep) {
-		struct instruction *insn = container(usep, struct instruction, src);
+	struct pseudo_user *pu;
+	FOR_EACH_PTR(pseudo->users, pu) {
+		struct instruction *insn = pu->insn;
 		if (insn->bb && (insn->opcode != OP_LOAD || insn->opcode != OP_STORE))
 			return 1;
-	} END_FOR_EACH_PTR(usep);
+	} END_FOR_EACH_PTR(pu);
 	return 0;
 }
 
Index: sparse/linearize.h
===================================================================
--- sparse.orig/linearize.h	2006-12-18 13:58:01.000000000 -0800
+++ sparse/linearize.h	2006-12-19 16:12:49.000000000 -0800
@@ -9,6 +9,15 @@
 struct instruction;
 DECLARE_PTR_LIST(pseudo_ptr_list, pseudo_t);
 
+struct pseudo_user {
+	struct instruction *insn;
+	pseudo_t *userp;
+};
+
+DECLARE_ALLOCATOR(pseudo_user);
+DECLARE_PTR_LIST(pseudo_user_list, struct pseudo_user);
+
+
 enum pseudo_type {
 	PSEUDO_VOID,
 	PSEUDO_REG,
@@ -21,7 +30,7 @@ enum pseudo_type {
 struct pseudo {
 	int nr;
 	enum pseudo_type type;
-	struct pseudo_ptr_list *users;
+	struct pseudo_user_list *users;
 	struct ident *ident;
 	union {
 		struct symbol *sym;
@@ -268,16 +277,29 @@ static inline void add_pseudo_ptr(pseudo
 	add_ptr_list(list, ptr);
 }
 
+static inline void add_pseudo_user_ptr(struct pseudo_user *user, struct pseudo_user_list **list)
+{
+	add_ptr_list(list, user);
+}
+
 static inline int has_use_list(pseudo_t p)
 {
 	return (p && p->type != PSEUDO_VOID && p->type != PSEUDO_VAL);
 }
 
-static inline void use_pseudo(pseudo_t p, pseudo_t *pp)
+static inline struct pseudo_user* alloc_pseudo_user(struct instruction *insn, pseudo_t *pp)
+{
+	struct pseudo_user *user = __alloc_pseudo_user(0);
+	user->userp = pp;
+	user->insn = insn;
+	return user;
+}
+
+static inline void use_pseudo(struct instruction *insn, pseudo_t p, pseudo_t *pp)
 {
 	*pp = p;
 	if (has_use_list(p))
-		add_pseudo_ptr(pp, &p->users);
+		add_pseudo_user_ptr(alloc_pseudo_user(insn, pp), &p->users);
 }
 
 static inline void remove_bb_from_list(struct basic_block_list **list, struct basic_block *entry, int count)
Index: sparse/linearize.c
===================================================================
--- sparse.orig/linearize.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/linearize.c	2006-12-19 16:13:29.000000000 -0800
@@ -37,6 +37,8 @@ struct pseudo void_pseudo = {};
 
 static struct position current_pos;
 
+ALLOCATOR(pseudo_user, "pseudo_user");
+
 static struct instruction *alloc_instruction(int opcode, int size)
 {
 	struct instruction * insn = __alloc_instruction(0);
@@ -517,12 +519,12 @@ void show_bb(struct basic_block *bb)
 
 static void show_symbol_usage(pseudo_t pseudo)
 {
+	struct pseudo_user *pu;
+
 	if (pseudo) {
-		pseudo_t *pp;
-		FOR_EACH_PTR(pseudo->users, pp) {
-			struct instruction *insn = container(pp, struct instruction, src);
-			printf("\t%s\n", show_instruction(insn));
-		} END_FOR_EACH_PTR(pp);
+		FOR_EACH_PTR(pseudo->users, pu) {
+			printf("\t%s\n", show_instruction(pu->insn));
+		} END_FOR_EACH_PTR(pu);
 	}
 }
 
@@ -667,15 +669,15 @@ void insert_select(struct basic_block *b
 	select->bb = bb;
 
 	assert(br->cond);
-	use_pseudo(br->cond, &select->src1);
+	use_pseudo(select, br->cond, &select->src1);
 
 	target = phi_node->target;
 	assert(target->def == phi_node);
 	select->target = target;
 	target->def = select;
 
-	use_pseudo(true, &select->src2);
-	use_pseudo(false, &select->src3);
+	use_pseudo(select, true, &select->src2);
+	use_pseudo(select, false, &select->src3);
 
 	add_instruction(&bb->insns, select);
 	add_instruction(&bb->insns, br);
@@ -711,7 +713,7 @@ static void add_branch(struct entrypoint
 
 	if (bb_reachable(bb)) {
        		br = alloc_instruction(OP_BR, 0);
-		use_pseudo(cond, &br->cond);
+		use_pseudo(br, cond, &br->cond);
 		br->bb_true = bb_true;
 		br->bb_false = bb_false;
 		add_bb(&bb_true->parents, bb);
@@ -809,7 +811,7 @@ pseudo_t alloc_phi(struct basic_block *s
 	phi->nr = ++nr;
 	phi->def = insn;
 
-	use_pseudo(pseudo, &insn->phi_src);
+	use_pseudo(insn, pseudo, &insn->phi_src);
 	insn->bb = source;
 	insn->target = phi;
 	add_instruction(&source->insns, insn);
@@ -905,7 +907,7 @@ static pseudo_t add_load(struct entrypoi
 
 	insn->target = new;
 	insn->offset = ad->offset;
-	use_pseudo(ad->address, &insn->src);
+	use_pseudo(insn, ad->address, &insn->src);
 	add_one_insn(ep, insn);
 	return new;
 }
@@ -917,8 +919,8 @@ static void add_store(struct entrypoint 
 	if (bb_reachable(bb)) {
 		struct instruction *store = alloc_typed_instruction(OP_STORE, ad->source_type);
 		store->offset = ad->offset;
-		use_pseudo(value, &store->target);
-		use_pseudo(ad->address, &store->src);
+		use_pseudo(store, value, &store->target);
+		use_pseudo(store, ad->address, &store->src);
 		add_one_insn(ep, store);
 	}
 }
@@ -950,8 +952,8 @@ static pseudo_t add_binary_op(struct ent
 	struct instruction *insn = alloc_typed_instruction(op, ctype);
 	pseudo_t target = alloc_pseudo(insn);
 	insn->target = target;
-	use_pseudo(left, &insn->src1);
-	use_pseudo(right, &insn->src2);
+	use_pseudo(insn, left, &insn->src1);
+	use_pseudo(insn, right, &insn->src2);
 	add_one_insn(ep, insn);
 	return target;
 }
@@ -972,7 +974,7 @@ static pseudo_t add_symbol_address(struc
 	pseudo_t target = alloc_pseudo(insn);
 
 	insn->target = target;
-	use_pseudo(symbol_pseudo(ep, sym), &insn->symbol);
+	use_pseudo(insn, symbol_pseudo(ep, sym), &insn->symbol);
 	add_one_insn(ep, insn);
 	return target;
 }
@@ -1026,7 +1028,7 @@ static pseudo_t add_uniop(struct entrypo
 	pseudo_t new = alloc_pseudo(insn);
 
 	insn->target = new;
-	use_pseudo(src, &insn->src1);
+	use_pseudo(insn, src, &insn->src1);
 	add_one_insn(ep, insn);
 	return new;
 }
@@ -1040,7 +1042,7 @@ static pseudo_t linearize_slice(struct e
 	insn->target = new;
 	insn->from = expr->r_bitpos;
 	insn->len = expr->r_nrbits;
-	use_pseudo(pre, &insn->base);
+	use_pseudo(insn, pre, &insn->base);
 	add_one_insn(ep, insn);
 	return new;
 }
@@ -1122,7 +1124,7 @@ static pseudo_t cast_pseudo(struct entry
 	result = alloc_pseudo(insn);
 	insn->target = result;
 	insn->orig_type = from;
-	use_pseudo(src, &insn->src);
+	use_pseudo(insn, src, &insn->src);
 	add_one_insn(ep, insn);
 	return result;
 }
@@ -1193,7 +1195,7 @@ static pseudo_t linearize_call_expressio
 
 	FOR_EACH_PTR(expr->args, arg) {
 		pseudo_t new = linearize_expression(ep, arg);
-		use_pseudo(new, add_pseudo(&insn->arguments, new));
+		use_pseudo(insn, new, add_pseudo(&insn->arguments, new));
 	} END_FOR_EACH_PTR(arg);
 
 	fn = expr->fn;
@@ -1213,7 +1215,7 @@ static pseudo_t linearize_call_expressio
 	} else {
 		call = linearize_expression(ep, fn);
 	}
-	use_pseudo(call, &insn->func);
+	use_pseudo(insn, call, &insn->func);
 	retval = VOID;
 	if (expr->ctype != &void_ctype)
 		retval = alloc_pseudo(insn);
@@ -1286,9 +1288,9 @@ static pseudo_t linearize_select(struct 
 	insn = alloc_typed_instruction(OP_SEL, expr->ctype);
 	if (!expr->cond_true)
 		true = cond;
-	use_pseudo(cond, &insn->src1);
-	use_pseudo(true, &insn->src2);
-	use_pseudo(false, &insn->src3);
+	use_pseudo(insn, cond, &insn->src1);
+	use_pseudo(insn, true, &insn->src2);
+	use_pseudo(insn, false, &insn->src3);
 
 	res = alloc_pseudo(insn);
 	insn->target = res;
@@ -1308,8 +1310,8 @@ static pseudo_t add_join_conditional(str
 		return phi1;
 
 	phi_node = alloc_typed_instruction(OP_PHI, expr->ctype);
-	use_pseudo(phi1, add_pseudo(&phi_node->phi_list, phi1));
-	use_pseudo(phi2, add_pseudo(&phi_node->phi_list, phi2));
+	use_pseudo(phi_node, phi1, add_pseudo(&phi_node->phi_list, phi1));
+	use_pseudo(phi_node, phi2, add_pseudo(&phi_node->phi_list, phi2));
 	phi_node->target = target = alloc_pseudo(phi_node);
 	add_one_insn(ep, phi_node);
 	return target;
@@ -1652,9 +1654,9 @@ static pseudo_t linearize_range(struct e
 {
 	struct instruction *insn = alloc_instruction(OP_RANGE, 0);
 
-	use_pseudo(linearize_expression(ep, stmt->range_expression), &insn->src1);
-	use_pseudo(linearize_expression(ep, stmt->range_low), &insn->src2);
-	use_pseudo(linearize_expression(ep, stmt->range_high), &insn->src3);
+	use_pseudo(insn, linearize_expression(ep, stmt->range_expression), &insn->src1);
+	use_pseudo(insn, linearize_expression(ep, stmt->range_low), &insn->src2);
+	use_pseudo(insn, linearize_expression(ep, stmt->range_high), &insn->src3);
 	add_one_insn(ep, insn);
 	return VOID;
 }
@@ -1670,7 +1672,7 @@ static void add_asm_input(struct entrypo
 
 	rule->ident = ident;
 	rule->constraint = constraint;
-	use_pseudo(pseudo, &rule->pseudo);
+	use_pseudo(insn, pseudo, &rule->pseudo);
 	add_ptr_list(&insn->asm_rules->inputs, rule);
 }
 
@@ -1688,7 +1690,7 @@ static void add_asm_output(struct entryp
 	rule = __alloc_asm_constraint(0);
 	rule->ident = ident;
 	rule->constraint = constraint;
-	use_pseudo(pseudo, &rule->pseudo);
+	use_pseudo(insn, pseudo, &rule->pseudo);
 	add_ptr_list(&insn->asm_rules->outputs, rule);
 }
 
@@ -1847,7 +1849,7 @@ pseudo_t linearize_statement(struct entr
 			}
 			phi = alloc_phi(active, src, type_size(expr->ctype));
 			phi->ident = &return_ident;
-			use_pseudo(phi, add_pseudo(&phi_node->phi_list, phi));
+			use_pseudo(phi_node, phi, add_pseudo(&phi_node->phi_list, phi));
 		}
 		add_goto(ep, bb_return);
 		return VOID;
@@ -1897,7 +1899,7 @@ pseudo_t linearize_statement(struct entr
 
 		pseudo = linearize_expression(ep, expr);
 		goto_ins = alloc_instruction(OP_COMPUTEDGOTO, 0);
-		use_pseudo(pseudo, &goto_ins->target);
+		use_pseudo(goto_ins, pseudo, &goto_ins->target);
 		add_one_insn(ep, goto_ins);
 
 		FOR_EACH_PTR(stmt->target_list, sym) {
@@ -1956,7 +1958,7 @@ pseudo_t linearize_statement(struct entr
 			break;
 
 		switch_ins = alloc_instruction(OP_SWITCH, 0);
-		use_pseudo(pseudo, &switch_ins->cond);
+		use_pseudo(switch_ins, pseudo, &switch_ins->cond);
 		add_one_insn(ep, switch_ins);
 		finish_block(ep);
 
@@ -2086,7 +2088,7 @@ static struct entrypoint *linearize_fn(s
 		struct instruction *insn = alloc_typed_instruction(OP_RET, ret_type);
 
 		if (type_size(ret_type) > 0)
-			use_pseudo(result, &insn->src);
+			use_pseudo(insn, result, &insn->src);
 		add_one_insn(ep, insn);
 	}
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH][RFC] Re: sparse handles int64_t type wrong ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH][RFC] Re: sparse handles int64_t type wrong
Date: Thu, 14 Dec 2006 04:21:04 +0000
Message-ID: <20061214042104.GB20494 () chrisli ! org>
--------------------
Never mind my previous patch. It is too simple and wrong.
It can't really tell the C type is abstract or not because
int_ctype has base_type to int_type as well. It ends up applying
the modifiers to int_ctype.

You are right about it is very nasty to delay the finalization
of the C type. Back to drawing board.

Chris

On Wed, Dec 13, 2006 at 04:57:59PM -0800, Linus Torvalds wrote:
> 
> 
> On Wed, 13 Dec 2006, Christopher Li wrote:
> > 
> > Do you mean some thing like this?  I might leave some abstract ctype
> > in the tree, it is hard to find all all the user of ctype before
> > it get finalized.  It seems work with the test case in my hand.
> 
> Yes, this is I think the proper way to do it. 
> 
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH][take II] Re: sparse handles int64_t type wrong ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH][take II] Re: sparse handles int64_t type wrong
Date: Fri, 15 Dec 2006 04:52:15 +0000
Message-ID: <20061215045215.GA2929 () chrisli ! org>
--------------------
Another attempt to fix the attribute parsing.

This patch delay the finalized of the abstract int type so it
can take the __attribute__ in the end of declaration. 

It complicate the bit field parsing because the abstract type can
show up in the base type of bit field.

It assume in the finalize stage the modifier only apply to the
simple base type.  In the case like:

int (*fn)(void) __attribute__(x);

If the attribute x need to handle in finalize stage, it need
to extend the while loop in apply_modifiers()

Signed-off-by: Christopher Li <sparse@chrisli.org>

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2006-12-14 20:26:32.000000000 -0800
+++ sparse/parse.c	2006-12-14 20:27:44.000000000 -0800
@@ -70,6 +70,50 @@ struct statement *alloc_statement(struct
 
 static struct token *struct_declaration_list(struct token *token, struct symbol_list **list);
 
+static int apply_modifiers(struct position pos, struct ctype *ctype)
+{
+	struct symbol *base;
+
+	while ((base = ctype->base_type)) {
+		switch (base->type) {
+		case SYM_FN:
+		case SYM_ENUM:
+		case SYM_ARRAY:
+		case SYM_BITFIELD:
+		case SYM_PTR:
+			ctype = &base->ctype;
+			continue;
+		}
+		break;
+	}
+
+	/* Turn the "virtual types" into real types with real sizes etc */
+	if (ctype->base_type == &int_type) {
+		ctype->base_type = ctype_integer(ctype->modifiers);
+		ctype->modifiers &= ~MOD_SPECIFIER;
+	} else if (ctype->base_type == &fp_type) {
+		ctype->base_type = ctype_fp(ctype->modifiers);
+		ctype->modifiers &= ~MOD_SPECIFIER;
+	}
+
+	if (ctype->modifiers & MOD_BITWISE) {
+		struct symbol *type;
+		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
+		if (!is_int_type(ctype->base_type)) {
+			sparse_error(pos, "invalid modifier");
+			return 1;
+		}
+		type = alloc_symbol(pos, SYM_BASETYPE);
+		*type = *ctype->base_type;
+		type->ctype.base_type = ctype->base_type;
+		type->type = SYM_RESTRICT;
+		type->ctype.modifiers &= ~MOD_SPECIFIER;
+		ctype->base_type = type;
+		create_fouled(type);
+	}
+	return 0;
+}
+
 static struct symbol * indirect(struct position pos, struct ctype *ctype, int type)
 {
 	struct symbol *sym = alloc_symbol(pos, type);
@@ -724,7 +768,6 @@ static void check_modifiers(struct posit
 		     modifier_string (wrong));
 }
 
-
 static struct token *declaration_specifiers(struct token *next, struct ctype *ctype, int qual)
 {
 	struct token *token;
@@ -778,7 +821,6 @@ static struct token *declaration_specifi
 		apply_ctype(token->pos, &thistype, ctype);
 	}
 
-	/* Turn the "virtual types" into real types with real sizes etc */
 	if (!ctype->base_type) {
 		struct symbol *base = &incomplete_ctype;
 
@@ -791,28 +833,6 @@ static struct token *declaration_specifi
 			base = &int_type;
 		ctype->base_type = base;
 	}
-	if (ctype->base_type == &int_type) {
-		ctype->base_type = ctype_integer(ctype->modifiers);
-		ctype->modifiers &= ~MOD_SPECIFIER;
-	} else if (ctype->base_type == &fp_type) {
-		ctype->base_type = ctype_fp(ctype->modifiers);
-		ctype->modifiers &= ~MOD_SPECIFIER;
-	}
-	if (ctype->modifiers & MOD_BITWISE) {
-		struct symbol *type;
-		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
-		if (!is_int_type(ctype->base_type)) {
-			sparse_error(token->pos, "invalid modifier");
-			return token;
-		}
-		type = alloc_symbol(token->pos, SYM_BASETYPE);
-		*type = *ctype->base_type;
-		type->ctype.base_type = ctype->base_type;
-		type->type = SYM_RESTRICT;
-		type->ctype.modifiers &= ~MOD_SPECIFIER;
-		ctype->base_type = type;
-		create_fouled(type);
-	}
 	return token;
 }
 
@@ -947,7 +967,7 @@ static struct token *handle_bitfield(str
 	struct symbol *bitfield;
 	long long width;
 
-	if (!is_int_type(ctype->base_type)) {
+	if (ctype->base_type != &int_type && !is_int_type(ctype->base_type)) {
 		sparse_error(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
@@ -968,15 +988,16 @@ static struct token *handle_bitfield(str
 		width = -1;
 	} else if (decl->ident) {
 		struct symbol *base_type = bitfield->ctype.base_type;
-		int is_signed = !(base_type->ctype.modifiers & MOD_UNSIGNED);
+		struct symbol *bitfield_type = base_type == &int_type ? bitfield : base_type;
+		int is_signed = !(bitfield_type->ctype.modifiers & MOD_UNSIGNED);
 		if (Wone_bit_signed_bitfield && width == 1 && is_signed) {
 			// Valid values are either {-1;0} or {0}, depending on integer
 			// representation.  The latter makes for very efficient code...
 			sparse_error(token->pos, "dubious one-bit signed bitfield");
 		}
 		if (Wdefault_bitfield_sign &&
-		    base_type->type != SYM_ENUM &&
-		    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) &&
+		    bitfield_type->type != SYM_ENUM &&
+		    !(bitfield_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) &&
 		    is_signed) {
 			// The sign of bitfields is unspecified by default.
 			sparse_error(token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
@@ -1001,6 +1022,7 @@ static struct token *declaration_list(st
 			token = handle_bitfield(token, decl);
 			token = handle_attributes(token, &decl->ctype);
 		}
+		apply_modifiers(token->pos, &decl->ctype);
 		add_symbol(list, decl);
 		if (!match_op(token, ','))
 			break;
@@ -1034,6 +1056,7 @@ static struct token *parameter_declarati
 	*tree = sym;
 	token = declarator(token, sym, &ident);
 	sym->ident = ident;
+	apply_modifiers(token->pos, &sym->ctype);
 	return token;
 }
 
@@ -1042,7 +1065,9 @@ struct token *typename(struct token *tok
 	struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
 	*p = sym;
 	token = declaration_specifiers(token, &sym->ctype, 0);
-	return declarator(token, sym, NULL);
+	token = declarator(token, sym, NULL);
+	apply_modifiers(token->pos, &sym->ctype);
+	return token;
 }
 
 static struct token *expression_statement(struct token *token, struct expression **tree)
@@ -1770,6 +1795,7 @@ struct token *external_declaration(struc
 	decl = alloc_symbol(token->pos, SYM_NODE);
 	decl->ctype = ctype;
 	token = declarator(token, decl, &ident);
+	apply_modifiers(token->pos, &decl->ctype);
 
 	/* Just a type declaration? */
 	if (!ident)
@@ -1830,6 +1856,7 @@ struct token *external_declaration(struc
 		decl->ctype = ctype;
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, decl, &ident);
+		apply_modifiers(token->pos, &decl->ctype);
 		if (!ident) {
 			sparse_error(token->pos, "expected identifier name in type definition");
 			return token;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCHv2] graph: Show position in basic block nodes ===

From: Josh Triplett <josht () us ! ibm ! com>
To: linux-sparse
Subject: [PATCHv2] graph: Show position in basic block nodes
Date: Fri, 01 Sep 2006 21:05:29 +0000
Message-ID: <1157144729.4217.3.camel () josh-work ! beaverton ! ibm ! com>
--------------------
Change the label for basic block nodes from the basic block address to the
position (file, line, column) of the basic block.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
Please ignore the previous patch, which unintentionally included part of
an unrelated change.

 graph.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/graph.c b/graph.c
index db940ae..ede3dfa 100644
--- a/graph.c
+++ b/graph.c
@@ -27,7 +27,8 @@ static void graph_ep(struct entrypoint *
 	printf("ep%p [label=\"%s\",shape=ellipse];\n",
 	       ep, show_ident(ep->name->ident));
 	FOR_EACH_PTR(ep->bbs, bb) {
-		printf("bb%p [shape=record,label=\"bb at %p\"]\n", bb, bb);
+		printf("bb%p [shape=record,label=\"%s:%d:%d\"]\n", bb,
+		       stream_name(bb->pos.stream), bb->pos.line, bb->pos.pos);
 	} END_FOR_EACH_PTR(bb);
 	FOR_EACH_PTR(ep->bbs, bb) {
 		struct basic_block *child;
-- 
1.4.1.1



-- 
VGER BF report: H 0
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH] Fix -Wtypesign ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [RFC PATCH] Fix -Wtypesign
Date: Fri, 14 Jul 2006 05:36:36 +0000
Message-ID: <Pine.LNX.4.64.0607132232310.5623 () g5 ! osdl ! org>
--------------------


On Thu, 13 Jul 2006, Pavel Roskin wrote:
>
> Fix -Wtypesign
> 
> Run evaluate_symbol() before check_duplicates() so that the signedness
> of the token is known by the time the token is compared with other
> tokens.
> 
> Signed-off-by: Pavel Roskin <proski@gnu.org>
> ---
> 
>  evaluate.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)
> 
> diff --git a/evaluate.c b/evaluate.c
> index 42005eb..2561f38 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -2473,8 +2473,8 @@ void evaluate_symbol_list(struct symbol_
>  	struct symbol *sym;
>  
>  	FOR_EACH_PTR(list, sym) {
> -		check_duplicates(sym);
>  		evaluate_symbol(sym);
> +		check_duplicates(sym);


That, on the face of it, looks "Obviously Correct(tm)".

I'm wondering if I had some reason for doing them in what is obviously the 
wrong order, which worries me a bit, but quite frankly, the most likely 
reasons is just that it was a thinko.

(Long long ago, I did "check_duplicates()" from _within_ evaluation, 
which had serious recursion issues, so there's been confusion here 
before).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH] Handling multiple -include directives ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: [RFC PATCH] Handling multiple -include directives
Date: Fri, 22 Dec 2006 07:06:29 +0000
Message-ID: <1166771189.18955.10.camel () dv>
--------------------
Hello!

sparse doesn't handle multiple -include directives.  Variables "include"
and "include_fd" have file scope in lib.c.  The file for inclusion is
processed only once in sparse_initial() after the command line has been
processed.

It seems to me that the existing add_pre_buffer() mechanism can be used
instead.  I'm just a bit worried why it wasn't done like this in the
first place.

---
Handle multiple -include directives

Signed-off-by: Pavel Roskin <proski@gnu.org>
---

 lib.c |   26 ++++++--------------------
 1 files changed, 6 insertions(+), 20 deletions(-)

diff --git a/lib.c b/lib.c
index 51c415d..3ea3bde 100644
--- a/lib.c
+++ b/lib.c
@@ -191,8 +191,6 @@ int Wenum_mismatch = 1;
 int Wdo_while = 1;
 int Wuninitialized = 1;
 int preprocess_only;
-char *include;
-int include_fd = -1;
 
 
 void add_pre_buffer(const char *fmt, ...)
@@ -266,21 +264,15 @@ static char **handle_switch_i(char *arg, char **next)
 {
 	if (*next && !strcmp(arg, "include")) {
 		char *name = *++next;
-		int fd = open(name, O_RDONLY);
-
-		include_fd = fd;
-		include = name;
-		if (fd < 0)
-			perror(name);
+		if (!name)
+			die("missing argument for -include option");
+		add_pre_buffer("#include \"%s\"\n", name);
 	}
 	if (*next && !strcmp(arg, "imacros")) {
 		char *name = *++next;
-		int fd = open(name, O_RDONLY);
-
-		include_fd = fd;
-		include = name;
-		if (fd < 0)
-			perror(name);
+		if (!name)
+			die("missing argument for -include option");
+		add_pre_buffer("#include \"%s\"\n", name);
 	}
 	else if (*next && !strcmp(arg, "isystem")) {
 		char *path = *++next;
@@ -624,12 +616,6 @@ static struct symbol_list *sparse_initial(void)
 {
 	struct token *token;
 
-	// Prepend any "include" file to the stream.
-	// We're in global scope, it will affect all files!
-	token = NULL;
-	if (include_fd >= 0)
-		token = tokenize(include, include_fd, NULL, includepath);
-
 	// Prepend the initial built-in stream
 	token = tokenize_buffer(pre_buffer, pre_buffer_size, token);
 	return sparse_tokenstream(token);


-- 
Regards,
Pavel Roskin


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [RFC PATCH] Handling multiple -include directives
Date: Fri, 22 Dec 2006 07:36:48 +0000
Message-ID: <1166773008.21614.4.camel () dv>
--------------------
On Fri, 2006-12-22 at 02:06 -0500, Pavel Roskin wrote:
> It seems to me that the existing add_pre_buffer() mechanism can be used
> instead.  I'm just a bit worried why it wasn't done like this in the
> first place.

There was a reason to worry.  Now create_builtin_stream() is run after
the includes have been processed, so that e.g. the Linux compiler.h
tells me that my compiler is too old (because it was included from the
command line before __GNUC__ was defined).

The initialization order needs some untangling.  It's too intertwined
with the command line processing.

-- 
Regards,
Pavel Roskin


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] More checking with sparse 0/4 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [RFC] More checking with sparse 0/4
Date: Thu, 28 Dec 2006 09:23:59 +0000
Message-ID: <20061228092359.GA6573 () chrisli ! org>
--------------------
Hi,

I have been play with sparse to add more Stanford checker style
of checking. The paper is "Checking System Rules Using System-
Specific, Programmer-Written Compiler Extensions" by Dawson Engler
etc.

Unlike the Stanford checker and smatch, this checker is working on
the linearization level instead of AST level. Linearization code
can be very convenient (when it works) to trace the data flow because
pseudo is in SSA form. There is define/user chain to avoid scan
every instruction.

I write the demo of checking null pointer and irq checking. It is mostly
an example.

The checking seems very fast. It adds about 10 seconds to the whole
make C=1 run. We might able to add it to stander sparse checking.

The some of the patch I send it to the list before. I post it again
to make it easy for the people who want to try it out.

As always, comments and suggestions are welcome.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] [PATCH 2/4] remove dead branch usage ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [RFC] [PATCH 2/4] remove dead branch usage
Date: Thu, 28 Dec 2006 09:25:40 +0000
Message-ID: <20061228092540.GC6573 () chrisli ! org>
--------------------
Fix some problem cause by dead branch instruction left in the user chain.

Signed-off-by: Christopher Li <sparse@chrisli.org>

Index: sparse/flow.c
===================================================================
--- sparse.orig/flow.c	2006-12-21 14:35:18.000000000 -0800
+++ sparse/flow.c	2006-12-21 14:35:55.000000000 -0800
@@ -195,6 +195,7 @@ try_to_rewrite_target:
 	if (bb_list_size(target->parents) != 1)
 		return retval;
 	insert_branch(target, insn, final);
+	kill_instruction(insn);
 	return 1;
 }
 
Index: sparse/simplify.c
===================================================================
--- sparse.orig/simplify.c	2006-12-21 14:35:18.000000000 -0800
+++ sparse/simplify.c	2006-12-21 14:35:55.000000000 -0800
@@ -217,6 +217,11 @@ void kill_instruction(struct instruction
 		kill_use(&insn->src2);
 		kill_use(&insn->src3);
 		return;
+	case OP_BR:
+		insn->bb = NULL;
+		repeat_phase |= REPEAT_CSE;
+		if (insn->cond)
+			kill_use(&insn->cond);
 	}
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] [PATCH 3/4] and other branch usage fix ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [RFC] [PATCH 3/4] and other branch usage fix
Date: Thu, 28 Dec 2006 09:26:18 +0000
Message-ID: <20061228092618.GD6573 () chrisli ! org>
--------------------
Remove dead branch from usage chain.

Branch like the following will get simplify and removed.
But the usage information is not updated.

br %c, 0x10, 0x10

Singed-off-by: Christopher Li <sparse@chrisli.org>

Index: sparse/flow.c
===================================================================
--- sparse.orig/flow.c	2006-12-21 20:48:07.000000000 -0800
+++ sparse/flow.c	2006-12-21 22:20:44.000000000 -0800
@@ -987,7 +987,7 @@ out:
 			replace_bb_in_list(&child->parents, bb, parent, 0);
 		} END_FOR_EACH_PTR(child);
 
-		delete_last_instruction(&parent->insns);
+		kill_instruction(delete_last_instruction(&parent->insns));
 		FOR_EACH_PTR(bb->insns, insn) {
 			if (insn->bb) {
 				assert(insn->bb == bb);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] [PATCH 4/4] adding the null pointer checking ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [RFC] [PATCH 4/4] adding the null pointer checking
Date: Thu, 28 Dec 2006 09:27:05 +0000
Message-ID: <20061228092705.GE6573 () chrisli ! org>
--------------------
This patch add the kmalloc null pointer checking. It also
try to track the double free as well. It knows a few kmalloc like
functions and kfree etc.

The interrupt checking is just a toy. Without cross function checking,
it is way too many false positive. 

BTW, I disable the branch optimization in expand stage because this type
of checking works best when different state follow different path.

Not a real patch submitting, I would love to heard some comment though.

Chris

Index: sparse/blobhash.c
===================================================================
--- sparse.orig/blobhash.c	2006-12-28 00:22:18.000000000 -0800
+++ sparse/blobhash.c	2006-12-28 00:22:18.000000000 -0800
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2006 Christopher Li <sparse@chrisli.org>
+ * Copyright (C) 2003 Transmeta Corp.
+ *               2003 Linus Torvalds
+ *
+ *  Licensed under the Open Software License version 1.1
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "storage.h"
+#include "checker.h"
+
+/*
+ * steal from tokenize.c 
+ */
+#define BLOB_HASH_BITS (13)
+#define BLOB_HASH_SIZE (1<<BLOB_HASH_BITS)
+#define BLOB_HASH_MASK (BLOB_HASH_SIZE-1)
+
+#define blob_hash_init(c)		(c)
+#define blob_hash_add(oldhash,c)	((oldhash)*11 + (c))
+#define blob_hash_end(hash)		((((hash) >> BLOB_HASH_BITS) + (hash)) & BLOB_HASH_MASK)
+
+ALLOCATOR(blob, "pseudo state blob");
+ALLOCATOR(bb_state, "basic block state");
+ALLOCATOR(state, "one state");
+
+
+static struct blob_list *blob_hash_table[BLOB_HASH_SIZE];
+
+static unsigned long blob_hash(const unsigned char *data, int len)
+{
+	unsigned long hash;
+	const unsigned char *p = data;
+
+	hash = blob_hash_init(0);
+	while (len--) {
+		unsigned int i = *p++;
+		hash = blob_hash_add(hash, i);
+	}
+	return blob_hash_end(hash);
+}
+
+struct blob *lookup_blob(const unsigned char *data, int len)
+{
+	struct blob_list *list = blob_hash_table[blob_hash(data, len)];
+	struct blob *blob;
+
+	FOR_EACH_PTR(list, blob) {
+		if (blob->len == len && !memcmp(blob->data, data, len))
+			return blob;
+	} END_FOR_EACH_PTR(blob);
+	return NULL;
+}
+
+struct blob *create_hashed_blob(const unsigned char *data, int len)
+{
+	struct blob_list **list = blob_hash_table + blob_hash(data, len);
+	struct blob *blob;
+	FOR_EACH_PTR(*list, blob) {
+		if (blob->len == len && !memcmp(blob->data, data, len))
+			return blob;
+	} END_FOR_EACH_PTR(blob);
+	blob = alloc_blob(len);
+	memcpy(blob->data, data, len);
+	add_blob(list, blob);
+	return blob;
+}
+
+void free_blob(void)
+{
+	int i;
+
+	for (i = 0; i < BLOB_HASH_SIZE; i++) {
+		free_ptr_list(blob_hash_table + i);
+	}
+	clear_blob_alloc();
+}
+
Index: sparse/unssa.h
===================================================================
Index: sparse/unssa.c
===================================================================
--- sparse.orig/unssa.c	2006-12-28 00:22:10.000000000 -0800
+++ sparse/unssa.c	2006-12-28 00:22:35.000000000 -0800
@@ -24,8 +24,8 @@
  */
 
 #include "lib.h"
-#include "linearize.h"
 #include "allocate.h"
+#include "linearize.h"
 #include <assert.h>
 
 
Index: sparse/flow.c
===================================================================
Index: sparse/ptrlist.h
===================================================================
--- sparse.orig/ptrlist.h	2006-12-28 00:21:06.000000000 -0800
+++ sparse/ptrlist.h	2006-12-28 00:22:18.000000000 -0800
@@ -45,6 +45,8 @@ extern void concat_ptr_list(struct ptr_l
 extern void __free_ptr_list(struct ptr_list **);
 extern int ptr_list_size(struct ptr_list *);
 extern int linearize_ptr_list(struct ptr_list *, void **, int);
+extern int find_ptr_in_list(struct ptr_list* list, void *ptr);
+extern int find_ptr_index(struct ptr_list* list, void *ptr);
 
 /*
  * Hey, who said that you can't do overloading in C?
Index: sparse/Makefile
===================================================================
--- sparse.orig/Makefile	2006-12-28 00:21:06.000000000 -0800
+++ sparse/Makefile	2006-12-28 00:22:18.000000000 -0800
@@ -27,12 +27,13 @@ INST_PROGRAMS=sparse cgcc
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
-	  storage.h ptrlist.h dissect.h
+	  storage.h ptrlist.h dissect.h checker.h
 
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
-	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o
+	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o \
+	  blobhash.o check-nullptr.o check-interrupt.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -131,6 +132,9 @@ example.o: $(LIB_H)
 storage.o: $(LIB_H)
 dissect.o: $(LIB_H)
 graph.o: $(LIB_H)
+blobstate.o: $(LIB_H)
+check-nullptr.o: $(LIB_H)
+check-interrupt.o: $(LIB_H)
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
Index: sparse/checker.h
===================================================================
--- sparse.orig/checker.h	2006-12-28 00:22:18.000000000 -0800
+++ sparse/checker.h	2006-12-28 00:22:18.000000000 -0800
@@ -0,0 +1,92 @@
+#ifndef _CHECKER_H_
+#define _CHECKER_H_
+
+struct blob {
+	int len;
+	unsigned char data[0];
+};
+
+struct bb_state;
+
+DECLARE_PTR_LIST(blob_list, struct blob);
+
+struct bb_state {
+	unsigned long generation;
+	struct instruction_list *insns;	// instruction relate to state.
+	struct blob_list *cached_state;
+	struct instruction *branch;
+	unsigned noret:1;
+};
+
+struct state {
+	unsigned char *statep;
+	unsigned long value;
+};
+
+DECLARE_ALLOCATOR(blob);
+DECLARE_ALLOCATOR(bb_state);
+DECLARE_ALLOCATOR(state);
+DECLARE_PTR_LIST(state_list, struct state);
+
+struct blob *lookup_blob(const unsigned char *data, int len);
+struct blob *create_hashed_blob(const unsigned char *data, int len);
+
+static inline struct blob* alloc_blob(int len)
+{
+	struct blob *blob = __alloc_blob(len);
+	blob->len = len;
+	return blob;
+}
+
+static inline void add_blob(struct blob_list **list, struct blob *blob)
+{
+	add_ptr_list(list, blob);
+}
+
+static inline struct bb_state* alloc_bb_state(void)
+{
+	return __alloc_bb_state(0);
+}
+
+#define new_state(list, p, v)						\
+	do {								\
+		typeof(p) __p = p;					\
+		struct state *__state = __alloc_state(0);		\
+		__state->statep = __p;					\
+		__state->value = *__p;					\
+		*__p = (v);						\
+		add_ptr_list(list, __state);				\
+	} while (0)
+
+
+#define revert_state(type, list, size)					\
+	do {								\
+		struct state *__state;					\
+		struct ptr_list **__list = (struct ptr_list **)(list);	\
+		type *__p;						\
+		while (ptr_list_size(*__list) > (size)) {		\
+			__state = undo_ptr_list_last(__list);		\
+			__p = __state->statep;				\
+			*__p = (type)__state->value;			\
+			__free_state(__state);				\
+		}							\
+	} while (0)
+
+
+static inline struct instruction *checker_instruction(struct instruction *insn, int opcode, pseudo_t src)
+{
+	struct instruction *new = __alloc_instruction(0);
+	new->opcode = opcode;
+	new->pos = insn->pos;
+	new->bb = insn->bb;
+	new->src = src;
+	new->offset = find_ptr_index((struct ptr_list *)insn->bb->insns, insn);
+	return new;
+}
+
+extern void init_check_null_ptr(void);
+extern void check_null_ptr(struct entrypoint *ep);
+extern void check_interrupt(struct entrypoint *ep);
+
+#endif
+
Index: sparse/token.h
===================================================================
Index: sparse/allocate.c
===================================================================
Index: sparse/simplify.c
===================================================================
Index: sparse/memops.c
===================================================================
Index: sparse/allocate.h
===================================================================
Index: sparse/expand.c
===================================================================
--- sparse.orig/expand.c	2006-12-28 00:21:06.000000000 -0800
+++ sparse/expand.c	2006-12-28 00:22:18.000000000 -0800
@@ -29,8 +29,8 @@
 /* Random cost numbers */
 #define SIDE_EFFECTS 10000	/* The expression has side effects */
 #define UNSAFE 100		/* The expression may be "infinitely costly" due to exceptions */
-#define SELECT_COST 20		/* Cut-off for turning a conditional into a select */
-#define BRANCH_COST 10		/* Cost of a conditional branch */
+#define SELECT_COST 0		/* Cut-off for turning a conditional into a select */
+#define BRANCH_COST 0		/* Cost of a conditional branch */
 
 static int expand_expression(struct expression *);
 static int expand_statement(struct statement *);
Index: sparse/ident-list.h
===================================================================
Index: sparse/lib.h
===================================================================
Index: sparse/sparse.c
===================================================================
--- sparse.orig/sparse.c	2006-12-28 00:21:06.000000000 -0800
+++ sparse/sparse.c	2006-12-28 00:22:18.000000000 -0800
@@ -23,6 +23,8 @@
 #include "symbol.h"
 #include "expression.h"
 #include "linearize.h"
+#include "storage.h"
+#include "checker.h"
 
 static int context_increase(struct basic_block *bb, int entry)
 {
@@ -170,29 +172,39 @@ struct checkfn {
 	void (*check)(struct instruction *insn);
 };
 
+static const struct checkfn* match_function(const struct checkfn* checklist, struct symbol *fn)
+{
+	struct ident *ident;
+	int i;
+
+	ident = fn->ident;
+	if (!ident)
+		return NULL;
+
+	for (i = 0; checklist[i].id; i++) {
+		if (checklist[i].id != ident)
+			continue;
+		return checklist + i;
+	}
+	return NULL;
+}
+
 static void check_call_instruction(struct instruction *insn)
 {
 	pseudo_t fn = insn->func;
-	struct ident *ident;
-	static const struct checkfn check_fn[] = {
+	static const struct checkfn *entry, check_fn[] = {
 		{ &memset_ident, check_memset },
 		{ &memcpy_ident, check_memcpy },
 		{ &copy_to_user_ident, check_ctu },
 		{ &copy_from_user_ident, check_cfu },
+		{ NULL },
 	};
-	int i;
 
 	if (fn->type != PSEUDO_SYM)
 		return;
-	ident = fn->sym->ident;
-	if (!ident)
-		return;
-	for (i = 0; i < sizeof(check_fn)/sizeof(struct checkfn) ; i++) {
-		if (check_fn[i].id != ident)
-			continue;
-		check_fn[i].check(insn);
-		break;
-	}
+	entry = match_function(check_fn, fn->sym);
+	if (entry)
+		entry->check(insn);
 }
 
 static void check_one_instruction(struct instruction *insn)
@@ -264,8 +276,11 @@ static void check_symbols(struct symbol_
 
 		expand_symbol(sym);
 		ep = linearize_symbol(sym);
-		if (ep)
+		if (ep) {
 			check_context(ep);
+			check_null_ptr(ep);
+			check_interrupt(ep);
+		}
 	} END_FOR_EACH_PTR(sym);
 }
 
@@ -276,6 +291,8 @@ int main(int argc, char **argv)
 
 	// Expand, linearize and show it.
 	check_symbols(sparse_initialize(argc, argv, &filelist));
+
+	init_check_null_ptr();
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		check_symbols(sparse(file));
 	} END_FOR_EACH_PTR_NOTAG(file);
Index: sparse/linearize.h
===================================================================
--- sparse.orig/linearize.h	2006-12-28 00:22:15.000000000 -0800
+++ sparse/linearize.h	2006-12-28 00:22:18.000000000 -0800
@@ -29,7 +29,9 @@ enum pseudo_type {
 
 struct pseudo {
 	int nr;
-	enum pseudo_type type;
+	enum pseudo_type type:8;
+	unsigned state_index:16;
+	unsigned tracking:1;
 	struct pseudo_user_list *users;
 	struct ident *ident;
 	union {
@@ -211,14 +213,19 @@ enum opcode {
 
 	/* Needed to translate SSA back to normal form */
 	OP_COPY,
+	OP_LAST,
 };
 
 struct basic_block_list;
 struct instruction_list;
+struct bb_state;
 
 struct basic_block {
 	struct position pos;
-	unsigned long generation;
+	union {
+		unsigned long generation;
+		struct bb_state *state;
+	};
 	int context;
 	struct entrypoint *ep;
 	struct basic_block_list *parents; /* sources */
Index: sparse/check-interrupt.c
===================================================================
--- sparse.orig/check-interrupt.c	2006-12-28 00:22:18.000000000 -0800
+++ sparse/check-interrupt.c	2006-12-28 00:22:18.000000000 -0800
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2006 Christopher Li <sparse@chrisli.org>
+ *
+ *  Licensed under the Open Software License version 1.1
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "storage.h"
+#include "checker.h"
+
+
+static unsigned char current;
+static struct blob *hashed_state;
+static struct state_list *state_stack = NULL;
+
+enum {
+	OP_CLI = OP_LAST,
+	OP_STI,
+	OP_RESTORE,
+};
+
+enum {
+	INTR_ENABLE,
+	INTR_DISABLE,
+};
+
+static inline void execute_enable(struct instruction *insn)
+{
+	if (current == INTR_ENABLE) {
+		warning(insn->pos, "checker function %s double enable",
+			show_ident(insn->bb->ep->name->ident));
+		return;
+	}
+	new_state(&state_stack, &current, INTR_ENABLE); 
+	hashed_state = NULL;
+}
+
+static inline void execute_disable(struct instruction *insn)
+{
+	if (current == INTR_DISABLE) {
+		warning(insn->pos, "checker function %s double ensable",
+			show_ident(insn->bb->ep->name->ident));
+		return;
+	}
+	new_state(&state_stack, &current, INTR_DISABLE); 
+	hashed_state = NULL;
+}
+
+static inline void execute_ret(struct instruction *insn)
+{
+	if (current == INTR_DISABLE)
+		warning(insn->pos, "checker funcion %s exit with interrupt disabled",
+			show_ident(insn->bb->ep->name->ident));
+}
+
+static void check_bb(struct basic_block *bb)
+{
+	struct bb_state *bbs = bb->state;
+	struct instruction *insn;
+	int stacksize = ptr_list_size((struct ptr_list*)state_stack);
+	struct basic_block *child;
+
+	if (bbs->generation)
+		return;
+
+	if (!hashed_state)
+		hashed_state = create_hashed_blob(&current, 1);
+
+	/*
+	 * Try to find out if we execute the same state before. If the state is
+	 * same, there is not point try to execute it again.
+	 */
+	if (find_ptr_in_list((struct ptr_list*)bbs->cached_state, hashed_state))
+		return;
+
+	add_ptr_list(&bbs->cached_state, hashed_state);
+
+	bbs->generation = 1;
+
+	FOR_EACH_PTR(bbs->insns, insn) {
+		switch (insn->opcode) {
+		case OP_CLI:
+			execute_disable(insn);
+			break;
+		case OP_STI:
+		case OP_RESTORE:
+			execute_enable(insn);
+			break;
+		case OP_RET:
+			execute_ret(insn);
+			break;
+		}
+	} END_FOR_EACH_PTR(insn);
+
+	if (bbs->noret)
+		goto exit_bb;
+
+		
+	FOR_EACH_PTR(bb->children, child) {
+		check_bb(child);
+	} END_FOR_EACH_PTR(child);
+
+exit_bb:
+	if (ptr_list_size((struct ptr_list*)state_stack) > stacksize) {
+		revert_state(unsigned char, &state_stack, stacksize);
+		hashed_state = NULL;
+	}
+	bbs->generation = 0;
+}
+
+static inline void scan_interrupt_insn(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+	struct instruction *insn;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		struct bb_state *bbs = bb->state;
+		FOR_EACH_PTR(bb->insns, insn) {
+			if (!insn->bb)
+				continue;
+			if (insn->opcode == OP_RET) {
+				add_instruction(&bbs->insns, insn);
+				continue;
+			}
+			else if (insn->opcode != OP_ASM)
+				continue;
+			if (!strcmp(insn->string, "cli"))
+				add_instruction(&bbs->insns, checker_instruction(insn, OP_CLI, NULL));
+			else if (!strcmp(insn->string, "sti"))
+				add_instruction(&bbs->insns, checker_instruction(insn, OP_STI, NULL));
+			else if (!strcmp(insn->string, "pushl %0 ; popfl"))
+				add_instruction(&bbs->insns, checker_instruction(insn, OP_RESTORE, NULL));
+		} END_FOR_EACH_PTR(insn);
+	} END_FOR_EACH_PTR(bb);
+}
+
+void check_interrupt(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		bb->state = alloc_bb_state();
+	} END_FOR_EACH_PTR(bb);
+
+	current = INTR_ENABLE;
+	hashed_state = NULL;
+	scan_interrupt_insn(ep);
+	check_bb(ep->entry->bb);
+}
+
Index: sparse/storage.h
===================================================================
Index: sparse/check-nullptr.c
===================================================================
--- sparse.orig/check-nullptr.c	2006-12-28 00:22:18.000000000 -0800
+++ sparse/check-nullptr.c	2006-12-28 00:22:18.000000000 -0800
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2006 Christopher Li <sparse@chrisli.org>
+ *
+ *  Licensed under the Open Software License version 1.1
+ */
+
+#include <stdio.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "storage.h"
+#include "checker.h"
+
+
+static int state_count = 0;
+static struct ptr_list *malloc_ident_list = NULL;
+static struct ptr_list *free_ident_list = NULL;
+static struct ptr_list *noret_ident_list = NULL;
+
+static struct blob *current;
+static struct blob *hashed_state;
+static struct state_list *state_stack;
+static void check_bb(struct basic_block *bb);
+
+#define alloc_state() alloc_blob(state_count)
+#define reg_state(pseudo) ((current)->data[pseudo->state_index])
+
+#define PTR_NULL		1
+#define PTR_NOTNULL		2
+#define PTR_FREE		4
+
+enum {
+	OP_DEF_PTR = OP_LAST,
+	OP_USE_PTR,
+	OP_FREE_PTR
+};
+
+static int cmp_insn_pos(const void *a, const void *b)
+{
+	int a1 = ((struct instruction *)a)->offset, b1 = ((struct instruction *)b)->offset;
+	if (a1 == b1)
+		return 0;
+	return a1 > b1 ? 1 : -1;
+}
+
+static void check_bb_cond(struct basic_block *bb, pseudo_t cond, unsigned value)
+{
+	new_state(&state_stack, &reg_state(cond), value);
+	hashed_state = NULL;
+	check_bb(bb);
+}
+
+
+static inline void execute_pointer_define(struct instruction *insn)
+{
+	new_state(&state_stack, &reg_state(insn->src), PTR_NULL | PTR_NOTNULL); 
+	hashed_state = NULL;
+}
+
+static inline void execute_pointer_usage(struct instruction *insn)
+{
+	if (reg_state(insn->src) & PTR_NULL)
+		warning(insn->pos, "funcion %s possible using NULL pointer",
+			show_ident(insn->bb->ep->name->ident));
+	if (reg_state(insn->src) & PTR_FREE)
+		warning(insn->pos, "funcion %s possible using pointer after free",
+			show_ident(insn->bb->ep->name->ident));
+}
+
+static inline void execute_pointer_free(struct instruction *insn)
+{
+	if (reg_state(insn->src) & PTR_FREE)
+		warning(insn->pos, "funcion %s possible double free pointer",
+			show_ident(insn->bb->ep->name->ident));
+	new_state(&state_stack, &reg_state(insn->src), reg_state(insn->src) | PTR_FREE); 
+	hashed_state = NULL;
+
+}
+static void check_bb(struct basic_block *bb)
+{
+	struct bb_state *bbs = bb->state;
+	struct instruction *insn;
+	int stacksize = ptr_list_size((struct ptr_list*)state_stack);
+
+	if (bbs->generation)
+		return;
+
+	if (!hashed_state)
+		hashed_state = create_hashed_blob(current->data, state_count);
+
+	/*
+	 * Try to find out if we execute the same state before. If the state is
+	 * same, there is not point try to execute it again.
+	 */
+	if (find_ptr_in_list((struct ptr_list*)bbs->cached_state, hashed_state))
+		return;
+
+	add_ptr_list(&bbs->cached_state, hashed_state);
+
+	bbs->generation = 1;
+
+	FOR_EACH_PTR(bbs->insns, insn) {
+		switch (insn->opcode) {
+		case OP_DEF_PTR:
+			execute_pointer_define(insn);
+			break;
+		case OP_USE_PTR:
+			execute_pointer_usage(insn);
+			break;
+		case OP_FREE_PTR:
+			execute_pointer_free(insn);
+			break;
+		}
+	} END_FOR_EACH_PTR(insn);
+
+	if (bbs->noret)
+		goto exit_bb;
+
+	if (bbs->branch) {
+		struct instruction *br = bbs->branch;
+		unsigned char orig = reg_state(br->cond);
+		check_bb_cond(br->bb_true, br->cond, orig & ~PTR_NULL);
+		check_bb_cond(br->bb_false, br->cond, orig & ~PTR_NOTNULL);
+	} else {
+		struct basic_block *child;
+		
+		FOR_EACH_PTR(bb->children, child) {
+			check_bb(child);
+		} END_FOR_EACH_PTR(child);
+	}
+
+exit_bb:
+	if (ptr_list_size((struct ptr_list*)state_stack) > stacksize) {
+		revert_state(unsigned char, &state_stack, stacksize);
+		hashed_state = NULL;
+	}
+	bbs->generation = 0;
+}
+
+static inline int match_call_function(struct instruction *insn, struct ptr_list *list)
+{
+	struct ident *ident;
+	pseudo_t fn;
+
+	if (insn->opcode != OP_CALL)
+		return 0;
+	fn = insn->func;
+	if (fn->type != PSEUDO_SYM)
+		return 0;
+	ident = fn->sym->ident;
+	if (!ident)
+		return 0;
+	return find_ptr_in_list(list, ident);
+}
+
+static void follow_pointer_usage(struct instruction *insn, pseudo_t pseudo, int index)
+{
+	struct pseudo_user *pu;
+
+	pseudo->tracking = 1;
+	pseudo->state_index = index;
+
+	FOR_EACH_PTR(pseudo->users, pu) {
+		struct instruction *useri = pu->insn;
+		struct basic_block *bb = useri->bb;
+		struct bb_state *bb_state;
+		if (!bb)
+			continue;
+		bb_state = bb->state;
+
+		switch(useri->opcode) {
+		case OP_CAST: case OP_SCAST: case OP_PTRCAST:
+			/* cast a pointer does not change the pointer state, it is just alias */
+			follow_pointer_usage(useri, useri->target, index);
+			break;
+		case OP_STORE: case OP_SNOP:
+			if (pseudo == useri->src) {
+				struct instruction *use = checker_instruction(useri, OP_USE_PTR,
+									      pseudo);
+				add_instruction(&bb_state->insns, use);
+			}
+			break;
+		case OP_CALL:
+			if (match_call_function(useri, free_ident_list)) {
+				struct instruction *fr = checker_instruction(useri, OP_FREE_PTR,
+									      pseudo);
+				add_instruction(&bb_state->insns, fr);
+			}
+			break;
+		case OP_BR:
+			bb_state->branch = useri;
+			break;
+ 		case OP_SWITCH:
+			warning(insn->pos, "switch on pointer not implemented\n");
+			break;
+		}
+	} END_FOR_EACH_PTR(pu);
+}
+
+static inline void scan_pointer_define(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+	struct instruction *insn;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		FOR_EACH_PTR(bb->insns, insn) {
+			if (!insn->bb)
+				continue;
+			if (match_call_function(insn, malloc_ident_list)) {
+				struct instruction *def = checker_instruction(insn, OP_DEF_PTR, insn->target);
+				add_instruction(&bb->state->insns, def);
+				follow_pointer_usage(insn, insn->target, state_count++);
+			}
+			if (match_call_function(insn, noret_ident_list)) {
+				bb->state->noret = 1;
+			}
+		} END_FOR_EACH_PTR(insn);
+	} END_FOR_EACH_PTR(bb);
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		sort_list((struct ptr_list **)&bb->state->insns, cmp_insn_pos);
+	} END_FOR_EACH_PTR(bb);
+}
+
+void check_null_ptr(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	state_count = 0;
+	
+	FOR_EACH_PTR(ep->bbs, bb) {
+		bb->state = alloc_bb_state();
+	} END_FOR_EACH_PTR(bb);
+
+	scan_pointer_define(ep);
+	current = alloc_state();
+	check_bb(ep->entry->bb);
+}
+
+void init_check_null_ptr(void)
+{
+	static const char *malloc_name[] = {
+		"malloc",
+		"__kmalloc",
+		"__kmalloc_node",
+		"__kzalloc",
+		"kmem_cache_alloc",
+		"kmem_cache_zalloc",
+		"kmem_cache_alloc_node",
+		"vmalloc",
+		"vmalloc_user",
+		"vmalloc_node",
+		"vmalloc_32",
+		"vmalloc_32_user",
+		"__vmalloc",
+		NULL,
+	};
+	static const char *free_name[] = {
+		"free",
+		"kfree",
+		"kmem_cache_free",
+		"vfree",
+		NULL,
+	};
+	static const char *noret[] = {
+		"panic",
+		NULL,
+	};
+	int i;
+
+	for (i = 0; malloc_name[i]; i++) {
+		void* id = (void*) built_in_ident(malloc_name[i]);
+		add_ptr_list(&malloc_ident_list, id);
+	}
+
+	for (i = 0; free_name[i]; i++) {
+		void* id = (void*) built_in_ident(free_name[i]);
+		add_ptr_list(&free_ident_list, id);
+	}
+
+	for (i = 0; noret[i]; i++) {
+		void* id = (void*) built_in_ident(noret[i]);
+		add_ptr_list(&noret_ident_list, id);
+	}
+
+}
+
Index: sparse/linearize.c
===================================================================
Index: sparse/ptrlist.c
===================================================================
--- sparse.orig/ptrlist.c	2006-12-28 00:21:06.000000000 -0800
+++ sparse/ptrlist.c	2006-12-28 00:22:18.000000000 -0800
@@ -243,3 +243,29 @@ void __free_ptr_list(struct ptr_list **l
 
 	*listp = NULL;
 }
+
+int find_ptr_in_list(struct ptr_list* list, void *ptr)
+{
+	void *p;
+	FOR_EACH_PTR(list, p) {
+		if (p == ptr)
+			return 1;
+	} END_FOR_EACH_PTR(p);
+	return 0;
+}
+
+int find_ptr_index(struct ptr_list* list, void *ptr)
+{
+	void *p;
+	int i = 0;
+	FOR_EACH_PTR(list, p) {
+		if (p == ptr)
+			return i;
+		i++;
+	} END_FOR_EACH_PTR(p);
+	return -1;
+}
+
+
+
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: assignment expressions are not validated ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: FW: assignment expressions are not validated
Date: Thu, 30 Mar 2006 00:17:49 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHAEIOCJAA.mshah () teja ! com>
--------------------

Any input regarding this patch?

Thanks,

-Mitesh


> -----Original Message-----
> From: linux-sparse-owner@vger.kernel.org
> [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Mitesh Shah
> Sent: Tuesday, March 21, 2006 12:37 PM
> To: Linux-Sparse
> Subject: assignment expressions are not validated
> 
> 
> 
> There is no error/warning for the following code:
> 
> void f(void) {
> 
>   int a;
> 
>   a = ;
> 
> }
> 
> 
> Looks like there is no check for empty expression in 
> primary_expression.
> default case simply ignores the token. Instead we can add a 
> sparse_error
> at line 360.
> 
> -Mitesh
> 
> 
> 
>  Index: expression.c
> ===================================================================
> RCS file: /home/cvs/root/sparse-bk/expression.c,v
> retrieving revision 1.10
> diff -u -r1.10 expression.c
> --- expression.c        16 Nov 2005 23:28:58 -0000      1.10
> +++ expression.c        21 Mar 2006 20:36:52 -0000
> @@ -357,7 +357,7 @@
>                 }
> 
>         default:
> -               ;
> +               sparse_error(token->pos, "Expected an expression");
>         }
>         *tree = expr;
>         return token;
> 
> 
> -
> To unsubscribe from this list: send the line "unsubscribe 
> linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: basic block output order? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: basic block output order?
Date: Tue, 12 Dec 2006 10:24:22 +0000
Message-ID: <20061212102422.GA6013 () chrisli ! org>
--------------------
I am playing with the example.c. I am wondering why the parent
basic blocks need to generate first?

The entry point has it's own "entry" instruction now, it should
remain as the first basic block in entry->bbs.

e.g. what is wrong with the following patch?

The reason I ask is because I think I need a few more pass
on the basic block. I try to avoid recursive if it is not necessary.

Thanks

Chris

Index: sparse/flow.c
===================================================================
--- sparse.orig/flow.c	2006-12-12 01:52:06.000000000 -0800
+++ sparse/flow.c	2006-12-12 01:52:40.000000000 -0800
@@ -903,12 +903,10 @@ void vrfy_flow(struct entrypoint *ep)
 	struct basic_block *bb;
 	struct basic_block *entry = ep->entry->bb;
 
+	assert(first_basic_block(ep->bbs) == entry);
 	FOR_EACH_PTR(ep->bbs, bb) {
-		if (bb == entry)
-			entry = NULL;
 		vrfy_bb_flow(bb);
 	} END_FOR_EACH_PTR(bb);
-	assert(!entry);
 }
 
 void pack_basic_blocks(struct entrypoint *ep)
Index: sparse/example.c
===================================================================
--- sparse.orig/example.c	2006-12-12 01:52:06.000000000 -0800
+++ sparse/example.c	2006-12-12 01:52:40.000000000 -0800
@@ -1765,9 +1765,6 @@ static void output_bb(struct basic_block
 
 	bb->generation = generation;
 
-	/* Make sure all parents have been generated first */
-	generate_list(bb->parents, generation);
-
 	state.pos = bb->pos;
 	state.inputs = gather_storage(bb, STOR_IN);
 	state.outputs = gather_storage(bb, STOR_OUT);
@@ -1782,9 +1779,6 @@ static void output_bb(struct basic_block
 
 	free_ptr_list(&state.inputs);
 	free_ptr_list(&state.outputs);
-
-	/* Generate all children... */
-	generate_list(bb->children, generation);
 }
 
 /*
@@ -1920,7 +1914,7 @@ static void output(struct entrypoint *ep
 	arch_set_up_storage(ep);
 
 	/* Show the results ... */
-	output_bb(ep->entry->bb, generation);
+	generate_list(ep->bbs, generation);
 
 	/* Clear the storage hashes for the next function.. */
 	free_storage();
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: basic block output order?
Date: Wed, 13 Dec 2006 01:15:49 +0000
Message-ID: <20061213011549.GA12570 () chrisli ! org>
--------------------
Thanks for your explain. I see, you want to generate the dominator
first.

Chris

On Tue, Dec 12, 2006 at 08:36:43AM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 12 Dec 2006, Christopher Li wrote:
> 
> They don't have to. But it generated nicer code, iirc, mainly because it 
> did the storage allocation the natural way. In particular, if I recall 
> correctly, it causes loops to have the storage for the _innermost_ loop to 
> be done first.
> 
> Notes off the top of my head, without actually looking at the code: 
> because when you hit a loop, the "parent" set is actually both the entry 
> and the BB that ha the loopback, so you actually end up going to the 
> loopback thing, which goes to _its_ parents, etc etc, until you actually 
> get back to the _top_ of the loop (and now the "generation" count triggers 
> you to break the looping), so you end up doing the actual register 
> allocation at tops of loops, but because you do this all recursively, and 
> the inner loop will have _its_ parents point to the callback too, you 
> generally tend to have started storage allocation at loop-tops.
> 
> HOWEVER. There's a reason the thing is called "example.c". The reason is 
> simply that it's stupid, idiotic, and not meant to be taken seriously. I 
> also ended up just hackign things around randomly to make it output 
> something that looked half-way sane, _and_ I ended up changign it to use 
> the "unssa" pass by Luc, _and_ I'm border-line psychotic when it comes to 
> compilers anyway.
> 
> In other words, what I'm trying to say is that you shouldn't take anything 
> I say too seriously, and that the "example.c" code wasn't really even 
> meant to be serious. I always wanted somebody else to write the back-end, 
> and held back as long as I could from writing example.c, and when I wrote 
> it, it was more a case of desperately trying to find somebody interested 
> in it, and having it as an example of how things _might_ work.
> 
> So as far as I am concerned, the whole "example.c" is just total 
> throw-away code. Go wild with it.
> 
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: broken 0 sized memset checks? ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: broken 0 sized memset checks?
Date: Tue, 05 Sep 2006 20:58:29 +0000
Message-ID: <20060905210512.GF22261 () redhat ! com>
--------------------
I ran sparse over the current linux kernel, and noticed this..

drivers/net/chelsio/sge.c:341:9: warning: memset with byte count of 0
drivers/net/chelsio/sge.c:469:9: warning: memset with byte count of 0

The first..

        q->size = p->freelQ_size[i];
        ....
        size = sizeof(struct freelQ_ce) * q->size;
        q->centries = kmalloc(size, GFP_KERNEL);
        if (!q->centries)
            goto err_no_mem;
        memset(q->centries, 0, size);

Looks valid enough, as does the second..

        q->size = p->cmdQ_size[i];
        ....
        size = sizeof(struct cmdQ_ce) * q->size;
        q->centries = kmalloc(size, GFP_KERNEL);
        if (!q->centries)
            goto err_no_mem;
        memset(q->centries, 0, size);

Sparse bug ?

	Dave
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: broken 0 sized memset checks?
Date: Tue, 05 Sep 2006 21:20:30 +0000
Message-ID: <Pine.LNX.4.64.0609051417270.27779 () g5 ! osdl ! org>
--------------------


On Tue, 5 Sep 2006, Dave Jones wrote:
>
> I ran sparse over the current linux kernel, and noticed this..
> 
> drivers/net/chelsio/sge.c:341:9: warning: memset with byte count of 0
> drivers/net/chelsio/sge.c:469:9: warning: memset with byte count of 0
> 
> The first..
> 
>         q->size = p->freelQ_size[i];
>         ....
>         size = sizeof(struct freelQ_ce) * q->size;
>         q->centries = kmalloc(size, GFP_KERNEL);
>         if (!q->centries)
>             goto err_no_mem;
>         memset(q->centries, 0, size);
>
> Sparse bug ?

I _suspect_ sparse has had some type-parsing bug, and thinks that 
"sizeof(struct freelQ_ce)" is zero for some reason, and then does all the 
constant folding (yeah, sparse is clever when it isn't really stupid ;), 
and that's what is going on.

I'll see if I can figure out what's up.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: case label types ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: case label types
Date: Thu, 16 Mar 2006 01:29:21 +0000
Message-ID: <Pine.LNX.4.64.0603151721130.3618 () g5 ! osdl ! org>
--------------------


On Wed, 15 Mar 2006, Morten Welinder wrote:
> 
> Shouldn't sparse complain over this kind of code, or does it have
> legitimate uses?

Hm.. Making sparse complain is probably a good idea.

> Specifically, enum constants from two different enums occur in the
> same switch.

However, this is actually no different from

	typedef enum { A1, A2 } enumA;
	typedef enum { B1 = 10, B2 } enumB;

	..
	if (A1 == B1)
		..

and the lack of warning comes from the exact same cause. Indeed, these 
days (since commit 464710af, to be exact), the case type-checking shares 
the exact same logic - it does

	...
	if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
		return;
	..

so it literally considers the case/switch expression equality testing to 
be 100% the same as the binop "==" test.

Oh, except there is a bug there: it _meant_ to check that they are both 
integer types, but it does that wrong:

	if (is_int_type(switch_type) && is_int_type(case_type))
		return;

which looks way too permissive. That should probably be testing for 
"compatible_integer_binop(switch_type, case_type)" instead.

I assume that in general we _do_ want the case/switch statements to have 
the same test as if you tested for equality explicitly.

Hmm? 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: case label types
Date: Thu, 16 Mar 2006 03:33:03 +0000
Message-ID: <200603160333.k2G3X3H08808 () troll ! rentec ! com>
--------------------

In the great tradition of monkey-see-monkey-do, I propose this
patch.  It does all the cases I listed except compare the case
labels against each other.

Morten

Signed-off-by: Morten Welinder <terra@gnome.org>


diff --git a/evaluate.c b/evaluate.c
index 1a12b67..3a47dcc 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -386,6 +386,12 @@ static struct symbol *compatible_integer
 		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_NODE)
 		rtype = rtype->ctype.base_type;
+
+	if (ltype->type == SYM_ENUM && rtype->type == SYM_ENUM &&
+	    ltype != rtype) {
+		warning(right->pos, "mixing different enum types");
+	}
+
 	if (is_int_type(ltype) && is_int_type(rtype)) {
 		struct symbol *ctype = bigger_int_type(ltype, rtype);
 
@@ -441,12 +447,19 @@ static struct symbol *compatible_restric
 
 	if (ltype->type == SYM_NODE)
 		ltype = ltype->ctype.base_type;
-	if (ltype->type == SYM_ENUM)
-		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_NODE)
 		rtype = rtype->ctype.base_type;
+
+	if (ltype->type == SYM_ENUM && rtype->type == SYM_ENUM &&
+	    ltype != rtype) {
+		warning(right->pos, "mixing different enum types");
+	}
+
+	if (ltype->type == SYM_ENUM)
+		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_ENUM)
 		rtype = rtype->ctype.base_type;
+
 	if (is_restricted_type(ltype)) {
 		if (is_restricted_type(rtype)) {
 			if (ltype == rtype)
@@ -2614,10 +2627,10 @@ static void check_case_type(struct expre
 
 	if (case_type && switch_type) {
 		/* Both integer types? */
-		if (is_int_type(switch_type) && is_int_type(case_type))
-			return;
 		if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
 			return;
+		if (is_int_type(switch_type) && is_int_type(case_type)) 
+			return;
 	}
 
 	sparse_error(case_expr->pos, "incompatible types for 'case' statement");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: case label types
Date: Thu, 16 Mar 2006 14:55:58 +0000
Message-ID: <20060316145558.1C383C000E2 () dunnock ! rentec ! com>
--------------------


Here's an improved version that catches inconsistent case labels too.

M.


=============================================================================

typedef enum { A1, A2 } enumA;
typedef enum { B1 = 10, B2 } enumB;

int
main (int argc, char **argv)
{
  enumA a = A1;

  switch (A1) {
  case A1: break;
  case A2: break;
  case B1: break;  // Warn
  case B2: break;  // Warn
  default: break;
  }

  switch (1) {
  case A1: break;
  case A2: break;
  case B1: break;  // Warn
  case B2: break;  // Warn
  default: break;
  }

  switch (1) {
  case A1 ... B2: break;  // Warn
  default: break;
  }

  (void)(1 ? a : B1);  // Warn
  (void)(A1 == B1);  // Warn

  return 0;
}

=============================================================================


Signed-off-by: Morten Welinder <terra@gnome.org>

diff --git a/evaluate.c b/evaluate.c
index 1a12b67..b099dcd 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -386,6 +386,12 @@ static struct symbol *compatible_integer
 		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_NODE)
 		rtype = rtype->ctype.base_type;
+
+	if (ltype->type == SYM_ENUM && rtype->type == SYM_ENUM &&
+	    ltype != rtype) {
+		warning(right->pos, "mixing different enum types");
+	}
+
 	if (is_int_type(ltype) && is_int_type(rtype)) {
 		struct symbol *ctype = bigger_int_type(ltype, rtype);
 
@@ -441,12 +447,19 @@ static struct symbol *compatible_restric
 
 	if (ltype->type == SYM_NODE)
 		ltype = ltype->ctype.base_type;
-	if (ltype->type == SYM_ENUM)
-		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_NODE)
 		rtype = rtype->ctype.base_type;
+
+	if (ltype->type == SYM_ENUM && rtype->type == SYM_ENUM &&
+	    ltype != rtype) {
+		warning(right->pos, "mixing different enum types");
+	}
+
+	if (ltype->type == SYM_ENUM)
+		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_ENUM)
 		rtype = rtype->ctype.base_type;
+
 	if (is_restricted_type(ltype)) {
 		if (is_restricted_type(rtype)) {
 			if (ltype == rtype)
@@ -2604,7 +2617,9 @@ static void evaluate_case_statement(stru
 	evaluate_statement(stmt->case_statement);
 }
 
-static void check_case_type(struct expression *switch_expr, struct expression *case_expr)
+static void check_case_type(struct expression *switch_expr,
+			    struct expression *case_expr,
+			    struct expression **enumcase)
 {
 	struct symbol *switch_type, *case_type;
 	if (!case_expr)
@@ -2613,11 +2628,19 @@ static void check_case_type(struct expre
 	case_type = evaluate_expression(case_expr);
 
 	if (case_type && switch_type) {
+		if (enumcase && is_enum_type(case_type)) {
+			/* Check case expressions against each other.  */
+			if (*enumcase)
+				(void)compatible_restricted_binop(SPECIAL_EQUAL, enumcase, &case_expr);
+			else
+				*enumcase = case_expr;
+		}
+
 		/* Both integer types? */
-		if (is_int_type(switch_type) && is_int_type(case_type))
-			return;
 		if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
 			return;
+		if (is_int_type(switch_type) && is_int_type(case_type)) 
+			return;
 	}
 
 	sparse_error(case_expr->pos, "incompatible types for 'case' statement");
@@ -2626,15 +2649,21 @@ static void check_case_type(struct expre
 static void evaluate_switch_statement(struct statement *stmt)
 {
 	struct symbol *sym;
+	struct expression *enumcase = NULL;
+	struct expression **enumcase_holder;
 
 	evaluate_expression(stmt->switch_expression);
 	evaluate_statement(stmt->switch_statement);
 	if (!stmt->switch_expression)
 		return;
+	enumcase_holder = is_enum_type(stmt->switch_expression->ctype)
+		? NULL /* Only check cases against switch */
+		: &enumcase;
+
 	FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
 		struct statement *case_stmt = sym->stmt;
-		check_case_type(stmt->switch_expression, case_stmt->case_expression);
-		check_case_type(stmt->switch_expression, case_stmt->case_to);
+		check_case_type(stmt->switch_expression, case_stmt->case_expression, enumcase_holder);
+		check_case_type(stmt->switch_expression, case_stmt->case_to, enumcase_holder);
 	} END_FOR_EACH_PTR(sym);
 }
 
diff --git a/symbol.h b/symbol.h
index 986a9cc..a773a0a 100644
--- a/symbol.h
+++ b/symbol.h
@@ -242,6 +242,13 @@ static inline int is_int_type(const stru
 	       type->ctype.base_type == &int_type;
 }
 
+static inline int is_enum_type(const struct symbol *type)
+{
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	return (type->type == SYM_ENUM);
+}
+
 static inline int get_sym_type(struct symbol *type)
 {
 	if (type->type == SYM_NODE)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: case label types
Date: Thu, 16 Mar 2006 22:09:36 +0000
Message-ID: <20060316220936.43234C000E2 () dunnock ! rentec ! com>
--------------------

...and this one handles assignments and function arguments too.
This was done by moving one of the checks into the implicit-
cast handling.

Morten



=============================================================================

typedef enum { A1, A2 } enumA;
typedef enum { B1 = 10, B2 } enumB;

static void Afunc (enumA a) { }


int
main (int argc, char **argv)
{
  enumA a = A1;

  switch (A1) {
  case A1: break;
  case A2: break;
  case B1: break;  // Warn
  case B2: break;  // Warn
  default: break;
  }

  switch (1) {
  case A1: break;
  case A2: break;
  case B1: break;  // Warn
  case B2: break;  // Warn
  default: break;
  }

  switch (1) {
  case A1 ... B2: break;  // Warn
  default: break;
  }

  (void)(1 ? a : B1);  // Warn
  (void)(A1 == B1);  // Warn

  (void)(A1 << B1);  // No warning wanted

  a = B1;  // Warn

  Afunc (B1);  // Warn

  return 0;
}

=============================================================================


Signed-off-by: Morten Welinder <terra@gnome.org>

diff --git a/evaluate.c b/evaluate.c
index 1a12b67..2c70cee 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -238,6 +238,23 @@ static int is_same_type(struct expressio
 	return 0;
 }
 
+static void
+warn_for_different_enum_types (struct position pos,
+			       struct symbol *typea,
+			       struct symbol *typeb)
+{
+	if (typea->type == SYM_NODE)
+		typea = typea->ctype.base_type;
+	if (typeb->type == SYM_NODE)
+		typeb = typeb->ctype.base_type;
+
+	if (typea == typeb)
+		return;
+
+	if (typea->type == SYM_ENUM && typeb->type == SYM_ENUM)
+		warning(pos, "mixing different enum types");
+}
+
 /*
  * This gets called for implicit casts in assignments and
  * integer promotion. We often want to try to move the
@@ -249,6 +266,8 @@ static struct expression * cast_to(struc
 {
 	struct expression *expr;
 
+	warn_for_different_enum_types (old->pos, old->ctype, type);
+
 	if (is_same_type(old, type))
 		return old;
 
@@ -267,6 +286,8 @@ static struct expression * cast_to(struc
 		break;
 
 	case EXPR_IMPLIED_CAST:
+		warn_for_different_enum_types(old->pos, old->ctype, type);
+
 		if (old->ctype->bit_size >= type->bit_size) {
 			struct expression *orig = old->cast_expression;
 			if (same_cast_type(orig->ctype, type))
@@ -441,12 +462,16 @@ static struct symbol *compatible_restric
 
 	if (ltype->type == SYM_NODE)
 		ltype = ltype->ctype.base_type;
-	if (ltype->type == SYM_ENUM)
-		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_NODE)
 		rtype = rtype->ctype.base_type;
+
+	warn_for_different_enum_types(right->pos, ltype, rtype);
+
+	if (ltype->type == SYM_ENUM)
+		ltype = ltype->ctype.base_type;
 	if (rtype->type == SYM_ENUM)
 		rtype = rtype->ctype.base_type;
+
 	if (is_restricted_type(ltype)) {
 		if (is_restricted_type(rtype)) {
 			if (ltype == rtype)
@@ -2604,7 +2629,9 @@ static void evaluate_case_statement(stru
 	evaluate_statement(stmt->case_statement);
 }
 
-static void check_case_type(struct expression *switch_expr, struct expression *case_expr)
+static void check_case_type(struct expression *switch_expr,
+			    struct expression *case_expr,
+			    struct expression **enumcase)
 {
 	struct symbol *switch_type, *case_type;
 	if (!case_expr)
@@ -2613,11 +2640,18 @@ static void check_case_type(struct expre
 	case_type = evaluate_expression(case_expr);
 
 	if (case_type && switch_type) {
+		if (enumcase) {
+			if (*enumcase)
+				warn_for_different_enum_types(case_expr->pos, case_type, (*enumcase)->ctype);
+			else if (is_enum_type(case_type))
+				*enumcase = case_expr;
+		}
+
 		/* Both integer types? */
-		if (is_int_type(switch_type) && is_int_type(case_type))
-			return;
 		if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
 			return;
+		if (is_int_type(switch_type) && is_int_type(case_type)) 
+			return;
 	}
 
 	sparse_error(case_expr->pos, "incompatible types for 'case' statement");
@@ -2626,15 +2660,21 @@ static void check_case_type(struct expre
 static void evaluate_switch_statement(struct statement *stmt)
 {
 	struct symbol *sym;
+	struct expression *enumcase = NULL;
+	struct expression **enumcase_holder;
 
 	evaluate_expression(stmt->switch_expression);
 	evaluate_statement(stmt->switch_statement);
 	if (!stmt->switch_expression)
 		return;
+	enumcase_holder = is_enum_type(stmt->switch_expression->ctype)
+		? NULL /* Only check cases against switch */
+		: &enumcase;
+
 	FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
 		struct statement *case_stmt = sym->stmt;
-		check_case_type(stmt->switch_expression, case_stmt->case_expression);
-		check_case_type(stmt->switch_expression, case_stmt->case_to);
+		check_case_type(stmt->switch_expression, case_stmt->case_expression, enumcase_holder);
+		check_case_type(stmt->switch_expression, case_stmt->case_to, enumcase_holder);
 	} END_FOR_EACH_PTR(sym);
 }
 
diff --git a/symbol.h b/symbol.h
index 986a9cc..a773a0a 100644
--- a/symbol.h
+++ b/symbol.h
@@ -242,6 +242,13 @@ static inline int is_int_type(const stru
 	       type->ctype.base_type == &int_type;
 }
 
+static inline int is_enum_type(const struct symbol *type)
+{
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	return (type->type == SYM_ENUM);
+}
+
 static inline int get_sym_type(struct symbol *type)
 {
 	if (type->type == SYM_NODE)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: segfault on switch() + bitwise combo ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: segfault on switch() + bitwise combo
Date: Fri, 09 Jun 2006 15:17:43 +0000
Message-ID: <20060609151742.GA21428 () martell ! zuzino ! mipt ! ru>
--------------------
It triggers by checking with -Wbitwise on drivers/net/wireless/ipw2100.c
and net/sctp/sm_make_chunk.c

Reduced testcase:
-----------------------------------------------------
     1	typedef int __attribute__((bitwise)) A;
     2	
     3	void f(A a)
     4	{
     5		switch (a & 1) {
     6		case 0:
     7			break;
     8		}
     9	}

$ sparse -Wbitwise 1.c
1.c:5:12: error: incompatible types for operation (&)
Segmentation fault
-----------------------------------------------------
Recently added is_enum_type() call at evaluate.c:2670 gets NULL pointer.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: segfault on switch() + bitwise combo
Date: Sat, 10 Jun 2006 18:43:50 +0000
Message-ID: <Pine.LNX.4.64.0606101143360.5498 () g5 ! osdl ! org>
--------------------


On Fri, 9 Jun 2006, Alexey Dobriyan wrote:
>
> It triggers by checking with -Wbitwise on drivers/net/wireless/ipw2100.c
> and net/sctp/sm_make_chunk.c

Perhaps something like this?

		Linus
---
diff --git a/evaluate.c b/evaluate.c
index 2c70cee..42005eb 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -359,7 +359,7 @@ static struct symbol *bad_expr_type(stru
 		break;
 	}
 
-	return NULL;
+	return expr->ctype = &bad_ctype;
 }
 
 static struct symbol *compatible_float_binop(struct expression **lp, struct expression **rp)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: Re: segfault on switch() + bitwise combo
Date: Sat, 10 Jun 2006 18:59:33 +0000
Message-ID: <20060610185933.GC7268 () martell ! zuzino ! mipt ! ru>
--------------------
On Sat, Jun 10, 2006 at 11:43:50AM -0700, Linus Torvalds wrote:
> On Fri, 9 Jun 2006, Alexey Dobriyan wrote:
> > It triggers by checking with -Wbitwise on drivers/net/wireless/ipw2100.c
> > and net/sctp/sm_make_chunk.c
>
> Perhaps something like this?

Looks like it works, thanks.

> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -359,7 +359,7 @@ static struct symbol *bad_expr_type(stru
>  		break;
>  	}
>
> -	return NULL;
> +	return expr->ctype = &bad_ctype;
>  }
>
>  static struct symbol *compatible_float_binop(struct expression **lp, struct expression **rp)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse 0.2 - incomprehensible context warnings ===

From: Ulrich Kunitz <kune () deine-taler ! de>
To: linux-sparse
Subject: sparse 0.2 - incomprehensible context warnings
Date: Tue, 05 Dec 2006 22:07:10 +0000
Message-ID: <20061205220710.GA12614 () p15091797 ! pureserver ! info>
--------------------
Hi,

I have tried sparse 0.2 for the zd1211rw WLAN driver, which I
happen to contribute too.

I get numerous context imbalance warnings, that I don't
understand. This is on an SMP (x86-64) build of a vanilla 2.6.19.
I get the same warning on an SMP build of PPC32.

A simple example is:

/home/kunitz/zd1211/rw/zd_usb.c:1167:13: warning: context imbalance in 'disable_read_regs_int' - wrong count at exit

zd_usb.c
1167 static void disable_read_regs_int(struct zd_usb *usb)
1168 {
1169         struct zd_usb_interrupt *intr = &usb->intr;
1170
1171         spin_lock_irq(&intr->lock);
1172         intr->read_regs_enabled = 0;
1173         spin_unlock_irq(&intr->lock);
1174 }

Please set me on CC of the answer I'm not a regular reader of this
list.

You will find the driver source in the kernel itself. I tested it
however against my latest git tree, which is available from

git-clone http://deine-taler.de/zd1211/zd1211.git

-- 
Uli Kunitz
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse as a compiler front-end ===

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: sparse as a compiler front-end
Date: Sat, 11 Nov 2006 21:54:08 +0000
Message-ID: <45564680.8090806 () garzik ! org>
--------------------
I see that sparse made it into Fedora Extras, so that 'yum install' 
automatically pulls it down for me.  Yay!  Thanks, Matt.

Can libsparse.a and necessary includes be packaged as well?

I have wild ambitions of rewriting compile-i386.c (my int-only x86 
pseudo-compiler) using the new basic block stuff, into a proper [if very 
very basic] C99 compiler.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sun, 12 Nov 2006 01:32:32 +0000
Message-ID: <455679B0.8030106 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigAC3CEC93C9EB473B8DFEC217
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Jeff Garzik wrote:
> I see that sparse made it into Fedora Extras, so that 'yum install'=20
> automatically pulls it down for me.  Yay!  Thanks, Matt.

Thanks indeed.

> Can libsparse.a and necessary includes be packaged as well?

Sure, assuming you don't mind coding against something potentially fluid.=
  The
next release will install the library and headers.  (At the moment, "nece=
ssary
headers" seems to mean "all of them".)

> I have wild ambitions of rewriting compile-i386.c (my int-only x86=20
> pseudo-compiler) using the new basic block stuff, into a proper [if ver=
y=20
> very basic] C99 compiler.

I look forward to seeing that.

- Josh Triplett


--------------enigAC3CEC93C9EB473B8DFEC217
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFVnmwGJuZRtD+evsRApkCAJ9Pb1O8c5pB8hajpM35E36J1oFK1wCfY40G
MNAieAEp/JzaaJO/tKpyyl0=
=W0fm
-----END PGP SIGNATURE-----

--------------enigAC3CEC93C9EB473B8DFEC217--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sun, 12 Nov 2006 01:45:41 +0000
Message-ID: <45567CC5.4030806 () garzik ! org>
--------------------
Matt Domsch wrote:
> On Sat, Nov 11, 2006 at 04:54:08PM -0500, Jeff Garzik wrote:
>> I see that sparse made it into Fedora Extras, so that 'yum install' 
>> automatically pulls it down for me.  Yay!  Thanks, Matt.
>>
>> Can libsparse.a and necessary includes be packaged as well?
> 
> .a or .so?  The .so just got dropped from the standard sparse 'make

Doesn't matter to me...  Something is better than nothing.  With 
sparse's license, .a is no big deal.

Thanks,

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Matt Domsch <Matt_Domsch () dell ! com>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sun, 12 Nov 2006 03:04:53 +0000
Message-ID: <20061112030453.GA20415 () humbolt ! us ! dell ! com>
--------------------
On Sat, Nov 11, 2006 at 08:45:41PM -0500, Jeff Garzik wrote:
> Matt Domsch wrote:
> >On Sat, Nov 11, 2006 at 04:54:08PM -0500, Jeff Garzik wrote:
> >>I see that sparse made it into Fedora Extras, so that 'yum install' 
> >>automatically pulls it down for me.  Yay!  Thanks, Matt.
> >>
> >>Can libsparse.a and necessary includes be packaged as well?
> >
> >.a or .so?  The .so just got dropped from the standard sparse 'make
> 
> Doesn't matter to me...  Something is better than nothing.  With 
> sparse's license, .a is no big deal.

Fedora Extras strongly discourages shipping and using .a if only to
ensure that any security issue uncovered can be addressed without
always rebuilding all downstream dependent apps.  Not too likely a
problem with a tool like sparse, but always a concern.

The .so would need to start being versioned, and care paid to bump the
version as the ABIs change.

That's one thing the opensuse build system does differently - tracking
the full dependency tree, and automatically rebuilding all downstream
dependent apps when an upstream app changes.


-- 
Matt Domsch
Software Architect
Dell Linux Solutions linux.dell.com & www.dell.com/linux
Linux on Dell mailing lists @ http://lists.us.dell.com
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sun, 12 Nov 2006 03:22:41 +0000
Message-ID: <45569381.9000109 () garzik ! org>
--------------------
Matt Domsch wrote:
> On Sat, Nov 11, 2006 at 08:45:41PM -0500, Jeff Garzik wrote:
>> Matt Domsch wrote:
>>> On Sat, Nov 11, 2006 at 04:54:08PM -0500, Jeff Garzik wrote:
>>>> I see that sparse made it into Fedora Extras, so that 'yum install' 
>>>> automatically pulls it down for me.  Yay!  Thanks, Matt.
>>>>
>>>> Can libsparse.a and necessary includes be packaged as well?
>>> .a or .so?  The .so just got dropped from the standard sparse 'make
>> Doesn't matter to me...  Something is better than nothing.  With 
>> sparse's license, .a is no big deal.
> 
> Fedora Extras strongly discourages shipping and using .a if only to
> ensure that any security issue uncovered can be addressed without
> always rebuilding all downstream dependent apps.  Not too likely a
> problem with a tool like sparse, but always a concern.
> 
> The .so would need to start being versioned, and care paid to bump the
> version as the ABIs change.

Or alteratively we could recognize that sparse is a bit of an unusual 
lib.  With the library likely to be changing rapidly, caring about ABIs 
at this early stage probably isn't in anybody's best interests.

	Jeff




-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Tue, 05 Dec 2006 16:53:04 +0000
Message-ID: <4575A3F0.2090502 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigF84D02FFBA7A9AF9C9AC9761
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Josh Triplett wrote:
> Jeff Garzik wrote:
>> Can libsparse.a and necessary includes be packaged as well?
>=20
> Sure, assuming you don't mind coding against something potentially flui=
d.  The
> next release will install the library and headers.  (At the moment, "ne=
cessary
> headers" seems to mean "all of them".)

The Sparse 0.2 release installs the library and headers, as well as a
pkg-config file.

- Josh Triplett


--------------enigF84D02FFBA7A9AF9C9AC9761
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFdaPwGJuZRtD+evsRAvW6AJ0TVTtMEEW8yD3AanEX/nfuOqwzHQCfUh4c
W0RJwfb2iNj3Vfd/yimCrzs=
=T4H2
-----END PGP SIGNATURE-----

--------------enigF84D02FFBA7A9AF9C9AC9761--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sat, 09 Dec 2006 09:43:43 +0000
Message-ID: <457A854F.5010602 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE19A31C1E7046D4780C8E8BA
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Matt Domsch wrote:
> On Tue, Dec 05, 2006 at 08:53:04AM -0800, Josh Triplett wrote:
>> Josh Triplett wrote:
>>> Jeff Garzik wrote:
>>>> Can libsparse.a and necessary includes be packaged as well?
>>> Sure, assuming you don't mind coding against something potentially fl=
uid.  The
>>> next release will install the library and headers.  (At the moment, "=
necessary
>>> headers" seems to mean "all of them".)
>> The Sparse 0.2 release installs the library and headers, as well as a
>> pkg-config file.
>=20
> I've got a test build of sparse-0.2 posted at
> http://domsch.com/linux/fedora/extras/sparse/0.2/ which I intend to
> put into Fedora Extras for FC5,6,devel.  This puts the libsparse.a and
> headers into a -devel package.

=46rom the spec file, I notice that you install the pkg-config file to
/usr/lib/pkgconfig (or equivalent), rather than /usr/share/pkgconfig (or
equivalent) as the Makefile does; any particular reason for that?

- Josh Triplett


--------------enigE19A31C1E7046D4780C8E8BA
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFeoVPGJuZRtD+evsRAvwXAJ9DO0UA9krzxraoa6XqMF8ySJ1KPwCffUzo
2IGAFEQr0bMHFFxRRH4xI10=
=6XgF
-----END PGP SIGNATURE-----

--------------enigE19A31C1E7046D4780C8E8BA--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sat, 09 Dec 2006 10:15:48 +0000
Message-ID: <457A8CD4.8020008 () garzik ! org>
--------------------
Josh Triplett wrote:
> From the spec file, I notice that you install the pkg-config file to
> /usr/lib/pkgconfig (or equivalent), rather than /usr/share/pkgconfig (or
> equivalent) as the Makefile does; any particular reason for that?

The pkgconfig file describes an architecture-specific library, so it 
goes into /usr/lib/pkgconfig/$pkg.pc if its 32-bit (or the rare 64-bit 
arch that uses /usr/lib), and it goes into /usr/lib64/pkgconfig/$pkg.pc 
if the library is 64-bit.

/usr/share is not appropriate for architecture-specific data.

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sat, 09 Dec 2006 10:17:46 +0000
Message-ID: <457A8D4A.5060007 () garzik ! org>
--------------------
Matt Domsch wrote:
> On Tue, Dec 05, 2006 at 08:53:04AM -0800, Josh Triplett wrote:
>> Josh Triplett wrote:
>>> Jeff Garzik wrote:
>>>> Can libsparse.a and necessary includes be packaged as well?
>>> Sure, assuming you don't mind coding against something potentially fluid.  The
>>> next release will install the library and headers.  (At the moment, "necessary
>>> headers" seems to mean "all of them".)
>> The Sparse 0.2 release installs the library and headers, as well as a
>> pkg-config file.
> 
> I've got a test build of sparse-0.2 posted at
> http://domsch.com/linux/fedora/extras/sparse/0.2/ which I intend to
> put into Fedora Extras for FC5,6,devel.  This puts the libsparse.a and
> headers into a -devel package.
> 
> Jeff, does this suit your needs?

Yep, both sparse and sparse-devel look great, here on FC6!

Thanks,

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Matt Domsch <Matt_Domsch () dell ! com>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Sat, 09 Dec 2006 16:17:04 +0000
Message-ID: <20061209161704.GA20975 () lists ! us ! dell ! com>
--------------------
On Sat, Dec 09, 2006 at 05:17:46AM -0500, Jeff Garzik wrote:
> Matt Domsch wrote:
> >I've got a test build of sparse-0.2 posted at
> >http://domsch.com/linux/fedora/extras/sparse/0.2/
> >
> >Jeff, does this suit your needs?
> 
> Yep, both sparse and sparse-devel look great, here on FC6!

Great.  This will be in tomorrow's push of Fedora Extras for
FC{5,6,devel} then.

Thanks,
Matt

-- 
Matt Domsch
Software Architect
Dell Linux Solutions linux.dell.com & www.dell.com/linux
Linux on Dell mailing lists @ http://lists.us.dell.com
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Wed, 28 Feb 2007 01:36:14 +0000
Message-ID: <45E4DC8E.9000702 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig5025F87992AD378E87B74933
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Jeff Garzik wrote:
> Josh Triplett wrote:
>> From the spec file, I notice that you install the pkg-config file to
>> /usr/lib/pkgconfig (or equivalent), rather than /usr/share/pkgconfig (=
or
>> equivalent) as the Makefile does; any particular reason for that?
>=20
> The pkgconfig file describes an architecture-specific library, so it=20
> goes into /usr/lib/pkgconfig/$pkg.pc if its 32-bit (or the rare 64-bit =

> arch that uses /usr/lib), and it goes into /usr/lib64/pkgconfig/$pkg.pc=
=20
> if the library is 64-bit.
>=20
> /usr/share is not appropriate for architecture-specific data.

Latest sparse from Git now installs sparse.pc to $(LIBDIR)/pkgconfig (def=
ault
/usr/lib/pkgconfig).

Thanks,
Josh Triplett


--------------enig5025F87992AD378E87B74933
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5NyOGJuZRtD+evsRAhu2AKCAxMawUbXX9m5+ZHQx36Wd/QGErwCeIbdl
GeQGubZBYam9iOY8xD/rucQ=
=jTT+
-----END PGP SIGNATURE-----

--------------enig5025F87992AD378E87B74933--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse handles int64_t type wrong ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse handles int64_t type wrong
Date: Tue, 12 Dec 2006 19:44:11 +0000
Message-ID: <Pine.LNX.4.64.0612121143280.3535 () woody ! osdl ! org>
--------------------


On Tue, 12 Dec 2006, Yura Pakhuchiy wrote:
>
> sparse 0.2 produces following errors on attached code:
> a.c:15:7: warning: incorrect type in argument 1 (different type sizes)
> a.c:15:7:    expected int [long] [usertype] *baz
> a.c:15:7:    got int *<noident>
> a.c:13:10: warning: shift too big (32) for type int 
> 
> However I believe it should not. Please fix!

Did you use "-m64" if you are doing this on an architecture with 64-bit 
/usr/include?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Yura Pakhuchiy <pakhuchiy () gmail ! com>
To: linux-sparse
Subject: Re: sparse handles int64_t type wrong
Date: Tue, 12 Dec 2006 19:50:49 +0000
Message-ID: <1165953049.17896.9.camel () chaos ! malinovka7 ! net>
--------------------
On Tue, 12 Dec 2006 at 11:44 -0800, Linus Torvalds wrote:
> 
> On Tue, 12 Dec 2006, Yura Pakhuchiy wrote:
> >
> > sparse 0.2 produces following errors on attached code:
> > a.c:15:7: warning: incorrect type in argument 1 (different type sizes)
> > a.c:15:7:    expected int [long] [usertype] *baz
> > a.c:15:7:    got int *<noident>
> > a.c:13:10: warning: shift too big (32) for type int 
> > 
> > However I believe it should not. Please fix!
> 
> Did you use "-m64" if you are doing this on an architecture with 64-bit 
> /usr/include?

I use 32bit machine. But I tried to append -m64 anyway and this does not
helps.

-- 
Best regards,
        Yura

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse handles int64_t type wrong
Date: Tue, 12 Dec 2006 20:02:54 +0000
Message-ID: <Pine.LNX.4.64.0612121155450.3535 () woody ! osdl ! org>
--------------------


On Tue, 12 Dec 2006, Linus Torvalds wrote:
> 
> Did you use "-m64" if you are doing this on an architecture with 64-bit 
> /usr/include?

Never mind, that's not it.

The problem is that the standard headers use _this_ for "int64_t":

	typedef int int64_t __attribute__ ((__mode__ (__DI__)));

and sparse just says "ok, int64_t is an 'int'"

The "__attribute__((__mode__()))" thing has always been a quick hack - 
sparse actually tries to parse it, but not very well.

If you use 

	typedef long long s64;

sparse gets it right.

In fact, sparse even gets it right if you do

	typedef int __attribute__((__mode__(__DI__))) int64_t;

because then the attribute gets attached to the underlying type, before it 
gets bound to the typedef.

I'll take a look if I can fix typedef to accept the crapola __attibute__ 
syntax.

Putting the attributes at the end really _does_ suck. It's as if you were 
to write

	typedef void * const_ptr_t const;

and that obviously isn't supposed to work. Why gcc thinks attributes can 
go at the end will never be clear to me.

Gcc attributes suck. Some gcc extensions really were thought out really 
really badly.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Yura Pakhuchiy <pakhuchiy () gmail ! com>
To: linux-sparse
Subject: Re: sparse handles int64_t type wrong
Date: Tue, 12 Dec 2006 20:25:25 +0000
Message-ID: <1165955125.17896.13.camel () chaos ! malinovka7 ! net>
--------------------
On Tue, 12 Dec 2006 at 12:02 -0800, Linus Torvalds wrote:
> On Tue, 12 Dec 2006, Linus Torvalds wrote:
> > 
> > Did you use "-m64" if you are doing this on an architecture with 64-bit 
> > /usr/include?
> 
> Never mind, that's not it.
> 
> The problem is that the standard headers use _this_ for "int64_t":
> 
> 	typedef int int64_t __attribute__ ((__mode__ (__DI__)));
> 
> and sparse just says "ok, int64_t is an 'int'"
> 
> The "__attribute__((__mode__()))" thing has always been a quick hack - 
> sparse actually tries to parse it, but not very well.
> 
> If you use 
> 
> 	typedef long long s64;
> 
> sparse gets it right.
> 
> In fact, sparse even gets it right if you do
> 
> 	typedef int __attribute__((__mode__(__DI__))) int64_t;
> 
> because then the attribute gets attached to the underlying type, before it 
> gets bound to the typedef.

Great! This works for me. So I will probably use
	#ifdef __CHECKER__
	typedef int __attribute__((__mode__(__DI__))) int64_t;
	#endif
until it will be fixed in sparse.

> I'll take a look if I can fix typedef to accept the crapola __attibute__ 
> syntax.
> 
> Putting the attributes at the end really _does_ suck. It's as if you were 
> to write
> 
> 	typedef void * const_ptr_t const;
> 
> and that obviously isn't supposed to work. Why gcc thinks attributes can 
> go at the end will never be clear to me.
> 
> Gcc attributes suck. Some gcc extensions really were thought out really 
> really badly.

Thanks for quick reply and explanations!

-- 
Best regards,
        Yura

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse triggers OOM killer ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-kernel
Subject: sparse triggers OOM killer
Date: Sat, 07 Jan 2006 11:18:27 +0000
Message-ID: <20060107111827.GA16133 () mars ! ravnborg ! org>
--------------------

--T4sUOijqQbZv57TR
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

I have played a little with attached patch.
It teach kbuild to check all files in one go in a directory when
sparsing the kernel.

I did a make allmodconfig and then ran:
make fs/xfs/ C=A

On my machine with 1 GB RAM it started a swap storm and later the OOM
triggered.
xfs is one of the bigger modules but still I was suprised to see it
causing such dramatic effect on my box.
[amd64 3.7 GHz  UP  1 GB RAM]

There was no oops or similar and sparse just exited after a while with
an errorcode (137).
Now I wonder if I have hit a bug in sparse or this is what I should
expect.

An easy way to try it out would be to run the sparse command from
attached file (it's long..).
If I can do anything to find out if this is a sparse bug or just
expected behaviour please say so.

	Sam

diff --git a/scripts/Makefile.build b/scripts/Makefile.build
index c33e62b..7e1b40a 100644
--- a/scripts/Makefile.build
+++ b/scripts/Makefile.build
@@ -85,16 +85,23 @@ __build: $(if $(KBUILD_BUILTIN),$(builti
 	@:
 
 # Linus' kernel sanity checking tool
-ifneq ($(KBUILD_CHECKSRC),0)
-  ifeq ($(KBUILD_CHECKSRC),2)
-    quiet_cmd_force_checksrc = CHECK   $<
-          cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
-  else
-      quiet_cmd_checksrc     = CHECK   $<
-            cmd_checksrc     = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
-  endif
+ifeq ($(KBUILD_CHECKSRC),1)
+  quiet_cmd_checksrc     = CHECK   $<
+        cmd_checksrc     = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
+endif
+ifeq ($(KBUILD_CHECKSRC),2)
+  quiet_cmd_force_checksrc = CHECK   $<
+        cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
+endif
+ifeq ($(KBUILD_CHECKSRC),A)
+  all-c-files = $(wildcard $(patsubst %.o, %.c, $(real-objs-y) $(real-objs-m)))
+  all-o-files = $(patsubst %.c, %.o, $(all-c-files))
+  all-o-flags = $(strip $(foreach o, $(all-o-files), $(CFLAGS_$(notdir $(o)))))
+  quiet_cmd_sparse-all = CHECK $(notdir $(all-c-files))
+        cmd_sparse-all = $(CHECK) $(CHECKFLAGS) \
+                                  $(c_flags) $(all-o-flags) $(all-c-files)
+  sparse-all = $(call cmd,sparse-all)
 endif
-
 
 # Compile C sources (.c)
 # ---------------------------------------------------------------------------
@@ -256,6 +263,7 @@ cmd_link_o_target = $(if $(strip $(obj-y
 		      rm -f $@; $(AR) rcs $@)
 
 $(builtin-target): $(obj-y) FORCE
+	$(call sparse-all)
 	$(call if_changed,link_o_target)
 
 targets += $(builtin-target)

--T4sUOijqQbZv57TR
Content-Type: text/plain; charset=us-ascii
Content-Disposition: attachment; filename=sparse-xfs
Content-Transfer-Encoding: quoted-printable

sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__x86_6=
4__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linux-gnu/3.4.4/include =
-Wp,-MD,fs/xfs/.built-in.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-pc-linu=
x-gnu/3.4.4/include -D__KERNEL__ -Iinclude -include include/linux/autoconf.=
h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fn=
o-common -ffreestanding -Os -fno-omit-frame-pointer -fno-optimize-sibling-c=
alls -g -march=3Dk8 -mno-red-zone -mcmodel=3Dkernel -pipe -fno-reorder-bloc=
ks -Wno-sign-compare -funit-at-a-time -mno-sse -mno-mmx -mno-sse2 -mno-3dno=
w -Wdeclaration-after-statement -Ifs/xfs -Ifs/xfs/linux-2.6 -funsigned-char=
 -DKBUILD_STR(s)=3D#s -DKBUILD_BASENAME=3DKBUILD_STR(built_in) -DKBUILD_MOD=
NAME=3DKBUILD_STR(built_in) fs/xfs/quota/xfs_dquot.c fs/xfs/quota/xfs_dquot=
_item.c fs/xfs/quota/xfs_trans_dquot.c fs/xfs/quota/xfs_qm_syscalls.c fs/xf=
s/quota/xfs_qm_bhv.c fs/xfs/quota/xfs_qm.c fs/xfs/quota/xfs_qm_stats.c fs/x=
fs/xfs_rtalloc.c fs/xfs/xfs_acl.c fs/xfs/linux-2.6/xfs_stats.c fs/xfs/linux=
-2.6/xfs_sysctl.c fs/xfs/linux-2.6/xfs_ioctl32.c fs/xfs/linux-2.6/xfs_expor=
t.c fs/xfs/xfs_alloc.c fs/xfs/xfs_alloc_btree.c fs/xfs/xfs_attr.c fs/xfs/xf=
s_attr_leaf.c fs/xfs/xfs_behavior.c fs/xfs/xfs_bit.c fs/xfs/xfs_bmap.c fs/x=
fs/xfs_bmap_btree.c fs/xfs/xfs_btree.c fs/xfs/xfs_buf_item.c fs/xfs/xfs_da_=
btree.c fs/xfs/xfs_dir.c fs/xfs/xfs_dir2.c fs/xfs/xfs_dir2_block.c fs/xfs/x=
fs_dir2_data.c fs/xfs/xfs_dir2_leaf.c fs/xfs/xfs_dir2_node.c fs/xfs/xfs_dir=
2_sf.c fs/xfs/xfs_dir_leaf.c fs/xfs/xfs_error.c fs/xfs/xfs_extfree_item.c f=
s/xfs/xfs_fsops.c fs/xfs/xfs_ialloc.c fs/xfs/xfs_ialloc_btree.c fs/xfs/xfs_=
iget.c fs/xfs/xfs_inode.c fs/xfs/xfs_inode_item.c fs/xfs/xfs_iocore.c fs/xf=
s/xfs_iomap.c fs/xfs/xfs_itable.c fs/xfs/xfs_dfrag.c fs/xfs/xfs_log.c fs/xf=
s/xfs_log_recover.c fs/xfs/xfs_mount.c fs/xfs/xfs_rename.c fs/xfs/xfs_trans=
=2Ec fs/xfs/xfs_trans_ail.c fs/xfs/xfs_trans_buf.c fs/xfs/xfs_trans_extfree=
=2Ec fs/xfs/xfs_trans_inode.c fs/xfs/xfs_trans_item.c fs/xfs/xfs_utils.c fs=
/xfs/xfs_vfsops.c fs/xfs/xfs_vnodeops.c fs/xfs/xfs_rw.c fs/xfs/xfs_dmops.c =
fs/xfs/xfs_qmops.c fs/xfs/linux-2.6/kmem.c fs/xfs/linux-2.6/xfs_aops.c fs/x=
fs/linux-2.6/xfs_buf.c fs/xfs/linux-2.6/xfs_file.c fs/xfs/linux-2.6/xfs_fs_=
subr.c fs/xfs/linux-2.6/xfs_globals.c fs/xfs/linux-2.6/xfs_ioctl.c fs/xfs/l=
inux-2.6/xfs_iops.c fs/xfs/linux-2.6/xfs_lrw.c fs/xfs/linux-2.6/xfs_super.c=
 fs/xfs/linux-2.6/xfs_vfs.c fs/xfs/linux-2.6/xfs_vnode.c fs/xfs/support/deb=
ug.c fs/xfs/support/move.c fs/xfs/support/uuid.c

--T4sUOijqQbZv57TR--
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse triggers OOM killer
Date: Sat, 07 Jan 2006 18:07:10 +0000
Message-ID: <Pine.LNX.4.64.0601071004130.3169 () g5 ! osdl ! org>
--------------------


On Sat, 7 Jan 2006, Sam Ravnborg wrote:
> 
> There was no oops or similar and sparse just exited after a while with
> an errorcode (137).

That's just SIGKILL (128+9). Which is normal for the OOM killer.

> Now I wonder if I have hit a bug in sparse or this is what I should
> expect.

Well, sparse does keep a _lot_ of stuff in memory, and the "do many files 
at once" will basically keep every single one (with full types, full 
linearization etc) in memory at the same time.

It's probably fairly easy to fix: I should just make sparse release all 
the linearizations and symbols when they go out of file scope.

The "do many files at once" thing really was just a quick hack, so the 
lack of memory release is not that susprising.

I'll see what I can do.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-kernel
Subject: Re: sparse triggers OOM killer
Date: Sat, 07 Jan 2006 18:07:10 +0000
Message-ID: <Pine.LNX.4.64.0601071004130.3169 () g5 ! osdl ! org>
--------------------


On Sat, 7 Jan 2006, Sam Ravnborg wrote:
> 
> There was no oops or similar and sparse just exited after a while with
> an errorcode (137).

That's just SIGKILL (128+9). Which is normal for the OOM killer.

> Now I wonder if I have hit a bug in sparse or this is what I should
> expect.

Well, sparse does keep a _lot_ of stuff in memory, and the "do many files 
at once" will basically keep every single one (with full types, full 
linearization etc) in memory at the same time.

It's probably fairly easy to fix: I should just make sparse release all 
the linearizations and symbols when they go out of file scope.

The "do many files at once" thing really was just a quick hack, so the 
lack of memory release is not that susprising.

I'll see what I can do.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse triggers OOM killer
Date: Mon, 16 Jan 2006 23:23:32 +0000
Message-ID: <20060116232332.GC8752 () mars ! ravnborg ! org>
--------------------
Hi Linus.

On Sat, Jan 07, 2006 at 10:07:10AM -0800, Linus Torvalds wrote:
> 
> 
> On Sat, 7 Jan 2006, Sam Ravnborg wrote:
> > 
> > There was no oops or similar and sparse just exited after a while with
> > an errorcode (137).
> 
> That's just SIGKILL (128+9). Which is normal for the OOM killer.
> 
> > Now I wonder if I have hit a bug in sparse or this is what I should
> > expect.
> 
> Well, sparse does keep a _lot_ of stuff in memory, and the "do many files 
> at once" will basically keep every single one (with full types, full 
> linearization etc) in memory at the same time.
> 
> It's probably fairly easy to fix: I should just make sparse release all 
> the linearizations and symbols when they go out of file scope.
> 
> The "do many files at once" thing really was just a quick hack, so the 
> lack of memory release is not that susprising.
> 
> I'll see what I can do.

Any news on this (call this a polite remineder)?
I have not tried to dig into it myself - assuming that it will take me
considerably time to do right..

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-kernel
Subject: Re: sparse triggers OOM killer
Date: Mon, 16 Jan 2006 23:23:32 +0000
Message-ID: <20060116232332.GC8752 () mars ! ravnborg ! org>
--------------------
Hi Linus.

On Sat, Jan 07, 2006 at 10:07:10AM -0800, Linus Torvalds wrote:
> 
> 
> On Sat, 7 Jan 2006, Sam Ravnborg wrote:
> > 
> > There was no oops or similar and sparse just exited after a while with
> > an errorcode (137).
> 
> That's just SIGKILL (128+9). Which is normal for the OOM killer.
> 
> > Now I wonder if I have hit a bug in sparse or this is what I should
> > expect.
> 
> Well, sparse does keep a _lot_ of stuff in memory, and the "do many files 
> at once" will basically keep every single one (with full types, full 
> linearization etc) in memory at the same time.
> 
> It's probably fairly easy to fix: I should just make sparse release all 
> the linearizations and symbols when they go out of file scope.
> 
> The "do many files at once" thing really was just a quick hack, so the 
> lack of memory release is not that susprising.
> 
> I'll see what I can do.

Any news on this (call this a polite remineder)?
I have not tried to dig into it myself - assuming that it will take me
considerably time to do right..

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

