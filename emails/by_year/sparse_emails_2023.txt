--- Emails for Year 2023 ---

=== Thread: [No Subject] ===

From: Greg Denzell <mzsophie () gmail ! com>
To: linux-sparse
Subject: 
Date: Wed, 04 Jan 2023 12:54:41 +0000
Message-ID: <CAEoj5=ZpJ15GRz-U33Ocbu5-P3Va+3bNv3476+mmJJ52cwx7tA () mail ! gmail ! com>
--------------------
Seasons Greetings!

This will remind you again that I have not yet received your reply to
my last message to you.
================================================================================


################################################################################

=== Thread: =?UTF-8?Q?Efektivn=C3=AD_sledov=C3=A1n=C3=AD_a_optimalizace_v=C3=BDroby_pro_va=C5=A1i_spole=C4=8Dnos ===

From: "Michal Rmoutil" <michal.rmoutil () venturelinkbiz ! com>
To: linux-sparse
Subject: =?UTF-8?Q?Efektivn=C3=AD_sledov=C3=A1n=C3=AD_a_optimalizace_v=C3=BDroby_pro_va=C5=A1i_spole=C4=8Dnos
Date: Fri, 29 Sep 2023 07:59:17 +0000
Message-ID: <20230929064500-0.1.2p.7fvz.0.y78eg7qdjv () venturelinkbiz ! com>
--------------------
Dobr=C3=A9 r=C3=A1no,

m=C3=A1te mo=C5=BEnost sledovat stav ka=C5=BEd=C3=A9ho stroje a v=C3=BDro=
bn=C3=ADho procesu z kancel=C3=A1=C5=99e, konferen=C4=8Dn=C3=AD m=C3=ADst=
nosti nebo dokonce z domova =C4=8Di na cest=C3=A1ch =E2=80=93 na va=C5=A1=
em telefonu?

Poskytujeme rychle implementovateln=C3=BD a snadno pou=C5=BEiteln=C3=BD n=
=C3=A1stroj, kter=C3=BD zachyt=C3=AD i n=C4=9Bkolikasekundov=C3=BD mikrop=
rostoj a okam=C5=BEit=C4=9B p=C5=99epo=C4=8D=C3=ADt=C3=A1 vyu=C5=BEit=C3=AD=
 stroje v kontextu dan=C3=A9 v=C3=BDrobn=C3=AD zak=C3=A1zky.

Kdykoli vid=C3=ADte stav objedn=C3=A1vky a jste informov=C3=A1ni o p=C5=99=
=C3=ADpadn=C3=A9m sn=C3=AD=C5=BEen=C3=AD efektivity. Syst=C3=A9m s=C3=A1m=
 analyzuje data a p=C5=99ipravuje cenn=C3=A9 reporty, co=C5=BE oper=C3=A1=
tor=C5=AFm umo=C5=BE=C5=88uje soust=C5=99edit se na v=C3=BDrobn=C3=AD c=C3=
=ADl.

C=C3=ADl je jednoduch=C3=BD: jeden pohled =E2=80=93 cel=C3=A1 tov=C3=A1rn=
a. =C4=8Cek=C3=A1m na odpov=C4=9B=C4=8F, jestli vid=C3=ADte mo=C5=BEnost =
vyu=C5=BEit=C3=AD takov=C3=A9ho n=C3=A1stroje ve va=C5=A1=C3=AD firm=C4=9B=
=2E


Pozdravy
Michal Rmoutil
================================================================================


################################################################################

=== Thread: =?UTF-8?Q?Tlakov=C4=9B_lit=C3=BD?= ===

From: =?UTF-8?Q? "Kristi=C3=A1n_Plet=C3=A1nek" ?=  <kristian.pletanek () mahavavy ! com>
To: linux-sparse
Subject: =?UTF-8?Q?Tlakov=C4=9B_lit=C3=BD?=
Date: Mon, 15 May 2023 07:30:52 +0000
Message-ID: <20230515064500-0.1.2i.4hb8.0.7k18gozu1g () mahavavy ! com>
--------------------
Dobr=C3=A9 r=C3=A1no,

zaji=C5=A1=C5=A5ujeme technologii tlakov=C3=A9ho lit=C3=AD hlin=C3=ADku.

M=C3=A1me v=C3=BDrobn=C3=AD z=C3=A1vody v Polsku, =C5=A0v=C3=A9dsku a =C4=
=8C=C3=ADn=C4=9B se schopnost=C3=AD flexibiln=C4=9B p=C5=99esouvat v=C3=BD=
robu mezi lokalitami.

Na=C5=A1e lic=C3=AD bu=C5=88ky jsou v=C4=9Bt=C5=A1inou automatick=C3=A9 n=
ebo poloautomatick=C3=A9, co=C5=BE umo=C5=BE=C5=88uje v=C3=BDrobu velk=C3=
=BDch v=C3=BDrobn=C3=ADch s=C3=A9ri=C3=AD s vysokou flexibilitou detail=C5=
=AF.
=20
Poskytujeme podporu v ka=C5=BEd=C3=A9 f=C3=A1zi v=C3=BDvoje projektu, vyv=
=C3=ADj=C3=ADme strukturu detailu.

Cht=C4=9Bli byste mluvit o spolupr=C3=A1ci v t=C3=A9to oblasti?

Pozdravy
Kristi=C3=A1n Plet=C3=A1nek
================================================================================


################################################################################

=== Thread: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?= ===

From: gvalencia () maprial ! com
To: linux-wireless
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:31 +0000
Message-ID: <20231110210342.486AC815E1DE () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-wpan
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:31 +0000
Message-ID: <20231110210342.486AC815E1DE () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-scsi
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:31 +0000
Message-ID: <20231110210342.486AC815E1DE () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-parisc
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:32 +0000
Message-ID: <20231110210342.D7D717380A17 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-pm
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:35 +0000
Message-ID: <20231110210344.0128075C1F1E () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-driver-devel
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:36 +0000
Message-ID: <20231110210345.289B37810B76 () mail ! maprial ! com>
--------------------
R29lZGVkYWcsCklrIGJlbiBtZXZyb3V3IEpvYW5uYSBMaXUgZW4gZWVuIG1lZGV3ZXJrZXIgdmFu
IENpdGkgQmFuayBIb25nIEtvbmcuCkthbiBpayDigqwgMTAwLjAwMC4wMDAgYWFuIHUgb3Zlcm1h
a2VuPyBLYW4gaWsgamUgdmVydHJvdXdlbgoKCklrIHdhY2h0IG9wIGp1bGxpZSByZWFjdGllcwpN
ZXQgdnJpZW5kZWxpamtlIGdyb2V0ZW4KbWV2cm91dyBKb2FubmEgTGl1Cl9fX19fX19fX19fX19f
X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fCmRldmVsIG1haWxpbmcgbGlzdApkZXZl
bEBsaW51eGRyaXZlcnByb2plY3Qub3JnCmh0dHA6Ly9kcml2ZXJkZXYubGludXhkcml2ZXJwcm9q
ZWN0Lm9yZy9tYWlsbWFuL2xpc3RpbmZvL2RyaXZlcmRldi1kZXZlbAo=
================================================================================

From: gvalencia () maprial ! com
To: linux-renesas-soc
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:41 +0000
Message-ID: <20231110210351.838F1815F5BE () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-tegra
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:43 +0000
Message-ID: <20231110210352.0476B81628E5 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-pci
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:50 +0000
Message-ID: <20231110210400.479B88165629 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-spi
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:03:58 +0000
Message-ID: <20231110210409.97A68816872F () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-xfs
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:07 +0000
Message-ID: <20231110210418.01F3376F6993 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: kexec
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:11 +0000
Message-ID: <20231110210420.B36D580845C4 () mail ! maprial ! com>
--------------------
R29lZGVkYWcsCklrIGJlbiBtZXZyb3V3IEpvYW5uYSBMaXUgZW4gZWVuIG1lZGV3ZXJrZXIgdmFu
IENpdGkgQmFuayBIb25nIEtvbmcuCkthbiBpayDigqwgMTAwLjAwMC4wMDAgYWFuIHUgb3Zlcm1h
a2VuPyBLYW4gaWsgamUgdmVydHJvdXdlbgoKCklrIHdhY2h0IG9wIGp1bGxpZSByZWFjdGllcwpN
ZXQgdnJpZW5kZWxpamtlIGdyb2V0ZW4KbWV2cm91dyBKb2FubmEgTGl1CgpfX19fX19fX19fX19f
X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXwprZXhlYyBtYWlsaW5nIGxpc3QKa2V4
ZWNAbGlzdHMuaW5mcmFkZWFkLm9yZwpodHRwOi8vbGlzdHMuaW5mcmFkZWFkLm9yZy9tYWlsbWFu
L2xpc3RpbmZvL2tleGVjCg==
================================================================================

From: gvalencia () maprial ! com
To: linux-m68k
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:14 +0000
Message-ID: <20231110210426.07521772A7B7 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: netfilter-devel
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:16 +0000
Message-ID: <20231110210426.AA2097238B67 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-nilfs
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:18 +0000
Message-ID: <20231110210428.EBF3D81718BB () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-ppp
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:25 +0000
Message-ID: <20231110210434.D28E481728ED () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: reiserfs-devel
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:27 +0000
Message-ID: <20231110210437.A2AF77222E1A () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-s390
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:27 +0000
Message-ID: <20231110210437.A2AF77222E1A () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-sctp
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:29 +0000
Message-ID: <20231110210439.9E73081737DA () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-raid
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:31 +0000
Message-ID: <20231110210440.CC83C81737C7 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-sparc
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:31 +0000
Message-ID: <20231110210442.26CE178D6CD5 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: linux-sh
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:32 +0000
Message-ID: <20231110210441.A2E8381737F3 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================

From: gvalencia () maprial ! com
To: util-linux-ng
Subject: =?utf-8?b?4oKsIDEwMC4wMDAuMDAwPw==?=
Date: Fri, 10 Nov 2023 21:04:37 +0000
Message-ID: <20231110210446.5C37C8174291 () mail ! maprial ! com>
--------------------
Goededag,
Ik ben mevrouw Joanna Liu en een medewerker van Citi Bank Hong Kong.
Kan ik =E2=82=AC 100.000.000 aan u overmaken? Kan ik je vertrouwen


Ik wacht op jullie reacties
Met vriendelijke groeten
mevrouw Joanna Liu
================================================================================


################################################################################

=== Thread: Betrugsopfer ===

From: "(IMF) SCAM VICTIMS" <mimichi4500 () gmail ! com>
To: linux-sparse
Subject: Betrugsopfer
Date: Tue, 05 Sep 2023 08:20:50 +0000
Message-ID: <CAGhkD8USA9d9+1HDw3AKO0o45v_Z8cjdpcgnjTbVjdDUbiyg2w () mail ! gmail ! com>
--------------------
Sehr geehrter E-Mail-Besitzer,



Der Internationale W=C3=A4hrungsfonds (IWF) entsch=C3=A4digt alle Betrugsop=
fer
und Ihre E-Mail-Adresse wurde auf der Liste der Betrugsopfer gefunden.

Dieses Western Union-B=C3=BCro wurde vom IWF beauftragt Ihnen Ihre
Verg=C3=BCtung per Western Union Money Transfer zu =C3=BCberweisen.

Wir haben uns jedoch entschieden Ihre eigene Zahlung =C3=BCber Geldtransfer
der Westunion in H=C3=B6he von =E2=82=AC5,000, pro Tag vorzunehmen bis die
Gesamtsumme von =E2=82=AC1,500.000.00, vollst=C3=A4ndig an Sie =C3=BCberwie=
sen wurde.

Wir k=C3=B6nnen die Zahlung m=C3=B6glicherweise nicht nur mit Ihrer
E-Mail-Adresse senden daher ben=C3=B6tigen wir Ihre Informationen dar=C3=BC=
ber
wohin wir das Geld an Sie senden wie z. B.:


Name des Adressaten ________________

Adresse________________

Land__________________

Telefonnummer________________

Angeh=C3=A4ngte Kopie Ihres Ausweises______________

Das Alter ________________________


Wir beginnen mit der =C3=9Cbertragung sobald wir Ihre Informationen
erhalten haben: Kontakt E-Mail: ( wuwumoneytransfer5000@hotmail.com)


Getreu,


Herr Anthony Duru,

Direktor von Geldtransfer der Westunion
================================================================================


################################################################################

=== Thread: Consumo de combustible ===

From: "Miguel Garcia" <miguel.garcia () clydespay ! com>
To: linux-sparse
Subject: Consumo de combustible
Date: Thu, 20 Jul 2023 08:05:31 +0000
Message-ID: <20230720064520-0.1.92.2d6mz.0.hu52i7m3x1 () clydespay ! com>
--------------------
Buenos dias

Le escribo sobre la gesti=C3=B3n de los autom=C3=B3viles de la empresa.

Gracias a las abundantes funcionalidades de la herramienta GPS, que monit=
orea cada autom=C3=B3vil de manera continua, puede registrar la posici=C3=
=B3n, el tiempo y el kilometraje de los autom=C3=B3viles en tiempo real.

Como resultado, los costos de mantenimiento de la flota de la compa=C3=B1=
=C3=ADa se reducen en un 20% y el tiempo de viaje o la planificaci=C3=B3n=
 de la entrega se reduce significativamente. 49 mil est=C3=A1n detr=C3=A1=
s del =C3=A9xito de nuestras soluciones. Empresas que cooperan con nosotr=
os.

Si el tema le parece interesante, cont=C3=A1ctame.


Atentamente,
Miguel Garcia
================================================================================

From: "Miguel Garcia" <miguel.garcia () clydespay ! com>
To: linux-sparse
Subject: Consumo de combustible
Date: Tue, 21 Nov 2023 08:55:58 +0000
Message-ID: <20231121074500-0.1.bj.2qih7.0.cbtp20dad6 () clydespay ! com>
--------------------
Buenos dias

Le escribo sobre la gesti=C3=B3n de los autom=C3=B3viles de la empresa.

Gracias a las abundantes funcionalidades de la herramienta GPS, que monit=
orea cada autom=C3=B3vil de manera continua, puede registrar la posici=C3=
=B3n, el tiempo y el kilometraje de los autom=C3=B3viles en tiempo real.

Como resultado, los costos de mantenimiento de la flota de la compa=C3=B1=
=C3=ADa se reducen en un 20% y el tiempo de viaje o la planificaci=C3=B3n=
 de la entrega se reduce significativamente. 49 mil est=C3=A1n detr=C3=A1=
s del =C3=A9xito de nuestras soluciones. Empresas que cooperan con nosotr=
os.

Si el tema le parece interesante, cont=C3=A1ctame.


Atentamente,
Miguel Garcia

================================================================================


################################################################################

=== Thread: IST DIESE E-MAIL AKTIV? ===

From: INFO <boothg () istar ! ca>
To: linux-sparse
Subject: IST DIESE E-MAIL AKTIV?
Date: Fri, 13 Jan 2023 05:47:42 +0000
Message-ID: <20230113004742.621163hyb1z0eida () webmail ! ca ! inter ! net>
--------------------


Sehr geehrter E-Mail-Begünstigter, Sie wurden für eine Spende in Höhe  
von 3.500.000,00 ? ausgewählt. Wenden Sie sich an diese  
E-Mail-Adresse: s.g0392440821@gmail.com, um weitere Informationen zum  
Erhalt Ihrer Spende zu erhalten. Vielen Dank

================================================================================


################################################################################

=== Thread: Infinite loop in delete_pseudo_user_list_entry() bisected to commit "cast: optimize away casts t ===

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: Infinite loop in delete_pseudo_user_list_entry() bisected to commit "cast: optimize away casts t
Date: Wed, 27 Dec 2023 23:46:04 +0000
Message-ID: <xwsuvxor4dwmmabaf3f7acgo53rkjigtzxqfgdmlibkgejb2m3 () ib6s5sn5njgv>
--------------------
On Wed, Dec 27, 2023 at 08:00:32AM +0000, Herbert, Marc wrote:
> Hi,
> 
>  I just bisected and gathered detailed information about a 100%-reproducible infinite loop in simplify.c:delete_pseudo_user_list_entry().
> 
> If you're interested please take a look at https://github.com/zephyrproject-rtos/zephyr/issues/63417#issuecomment-1870029877
> 
> Marc

Hi,

I've some problems to reproduce this.
Would it be possible to get the result of the preprocessing of the file tls.c ?
For example get the exact sparse command, something like:
	sparse ... arch/arm64/core/tls.c
and the changing it by:
	sparse ... arch/arm64/core/tls.c -E > tls.i

Best regards,
-- Luc

================================================================================

From: "Herbert, Marc" <marc.herbert () intel ! com>
To: linux-sparse
Subject: Re: Infinite loop in delete_pseudo_user_list_entry() bisected to commit "cast: optimize away casts t
Date: Thu, 28 Dec 2023 01:08:27 +0000
Message-ID: <4EB87136-D1B0-41CF-B552-9E9F19C00F3B () intel ! com>
--------------------
Hi,

> I've some problems to reproduce this.

I understand; reproduction is easy but only if you've setup the entire
Zephyr environment. It's not complicated but it does take some time.

> Would it be possible to get the result of the preprocessing of the
> file tls.c ?

Funny enough, when using sparse the Zephyr build system prints the
command only AFTER sparse has run :-( Fortunately, copying the command
from `ps` worked! No evil environment variable required.

More good news: running `sparse tls.i` on this pre-processed file
reproduces instantly for me.

So see tls.i file below. In case my mailer mangled the file (I gave up
on plain text email a long time ago, sorry about that) I also attached
it to the issue:
  https://github.com/zephyrproject-rtos/zephyr/issues/63417
I doubt this list accepts attachments...

I can also create a bug at bugzilla.kernel.org if you prefer.

Marc


typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef int wchar_t;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void * __timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef union {
			long long thelonglong;
			long double thelongdouble;
			uintmax_t theuintmax_t;
			size_t thesize_t;
			uintptr_t theuintptr_t;
			void *thepvoid;
			void (*thepfunc)(void);
} z_max_align_t;
typedef long atomic_t;
typedef atomic_t atomic_val_t;
typedef void *atomic_ptr_t;
typedef atomic_ptr_t atomic_ptr_val_t;
static inline _Bool atomic_cas(atomic_t *target, atomic_val_t old_value,
			atomic_val_t new_value)
{
			return __atomic_compare_exchange_n(target, &old_value, new_value,
			0, 8,
			8);
}
static inline _Bool atomic_ptr_cas(atomic_ptr_t *target, atomic_ptr_val_t o=
ld_value,
			atomic_ptr_val_t new_value)
{
			return __atomic_compare_exchange_n(target, &old_value, new_value,
			0, 8,
			8);
}
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
			return __atomic_fetch_add(target, value, 8);
}
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
			return __atomic_fetch_sub(target, value, 8);
}
static inline atomic_val_t atomic_inc(atomic_t *target)
{
			return atomic_add(target, 1);
}
static inline atomic_val_t atomic_dec(atomic_t *target)
{
			return atomic_sub(target, 1);
}
static inline atomic_val_t atomic_get(const atomic_t *target)
{
			return __atomic_load_n(target, 8);
}
static inline atomic_ptr_val_t atomic_ptr_get(const atomic_ptr_t *target)
{
			return __atomic_load_n(target, 8);
}
static inline atomic_val_t atomic_set(atomic_t *target, atomic_val_t value)
{
			return __atomic_exchange_n(target, value, 8);
}
static inline atomic_ptr_val_t atomic_ptr_set(atomic_ptr_t *target, atomic_=
ptr_val_t value)
{
			return __atomic_exchange_n(target, value, 8);
}
static inline atomic_val_t atomic_clear(atomic_t *target)
{
			return atomic_set(target, 0);
}
static inline atomic_ptr_val_t atomic_ptr_clear(atomic_ptr_t *target)
{
			return atomic_ptr_set(target, ((void *)0));
}
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
			return __atomic_fetch_or(target, value, 8);
}
static inline atomic_val_t atomic_xor(atomic_t *target, atomic_val_t value)
{
			return __atomic_fetch_xor(target, value, 8);
}
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
			return __atomic_fetch_and(target, value, 8);
}
static inline atomic_val_t atomic_nand(atomic_t *target, atomic_val_t value=
)
{
			return __atomic_fetch_nand(target, value, 8);
}
static inline _Bool atomic_test_bit(const atomic_t *target, int bit)
{
			atomic_val_t val =3D atomic_get(((target) + ((bit) / (sizeof(atomic_val_=
t) * 8))));
			return (1 & (val >> (bit & ((sizeof(atomic_val_t) * 8) - 1)))) !=3D 0;
}
static inline _Bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
			atomic_val_t mask =3D (1UL << ((unsigned long)(bit) & ((sizeof(atomic_va=
l_t) * 8) - 1U)));
			atomic_val_t old;
			old =3D atomic_and(((target) + ((bit) / (sizeof(atomic_val_t) * 8))), ~m=
ask);
			return (old & mask) !=3D 0;
}
static inline _Bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
			atomic_val_t mask =3D (1UL << ((unsigned long)(bit) & ((sizeof(atomic_va=
l_t) * 8) - 1U)));
			atomic_val_t old;
			old =3D atomic_or(((target) + ((bit) / (sizeof(atomic_val_t) * 8))), mas=
k);
			return (old & mask) !=3D 0;
}
static inline void atomic_clear_bit(atomic_t *target, int bit)
{
			atomic_val_t mask =3D (1UL << ((unsigned long)(bit) & ((sizeof(atomic_va=
l_t) * 8) - 1U)));
			(void)atomic_and(((target) + ((bit) / (sizeof(atomic_val_t) * 8))), ~mas=
k);
}
static inline void atomic_set_bit(atomic_t *target, int bit)
{
			atomic_val_t mask =3D (1UL << ((unsigned long)(bit) & ((sizeof(atomic_va=
l_t) * 8) - 1U)));
			(void)atomic_or(((target) + ((bit) / (sizeof(atomic_val_t) * 8))), mask)=
;
}
static inline void atomic_set_bit_to(atomic_t *target, int bit, _Bool val)
{
			atomic_val_t mask =3D (1UL << ((unsigned long)(bit) & ((sizeof(atomic_va=
l_t) * 8) - 1U)));
			if (val) {
			(void)atomic_or(((target) + ((bit) / (sizeof(atomic_val_t) * 8))), mask)=
;
			} else {
			(void)atomic_and(((target) + ((bit) / (sizeof(atomic_val_t) * 8))), ~mas=
k);
			}
}
void __attribute__((format (printf, 1, 2))) assert_print(const char *fmt, .=
..);
static inline _Bool is_power_of_two(unsigned int x)
{
			return (((x) !=3D 0U) && (((x) & ((x) - 1U)) =3D=3D 0U));
}
static inline int64_t arithmetic_shift_right(int64_t value, uint8_t shift)
{
			int64_t sign_ext;
			if (shift =3D=3D 0U) {
			return value;
			}
			sign_ext =3D (value >> 63) & 1;
			sign_ext =3D -sign_ext;
			return (value >> shift) | (sign_ext << (64 - shift));
}
static inline void bytecpy(void *dst, const void *src, size_t size)
{
			size_t i;
			for (i =3D 0; i < size; ++i) {
			((volatile uint8_t *)dst)[i] =3D ((volatile const uint8_t *)src)[i];
			}
}
static inline void byteswp(void *a, void *b, size_t size)
{
			uint8_t t;
			uint8_t *aa =3D (uint8_t *)a;
			uint8_t *bb =3D (uint8_t *)b;
			for (; size > 0; --size) {
			t =3D *aa;
			*aa++ =3D *bb;
			*bb++ =3D t;
			}
}
int char2hex(char c, uint8_t *x);
int hex2char(uint8_t x, char *c);
size_t bin2hex(const uint8_t *buf, size_t buflen, char *hex, size_t hexlen)=
;
size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)=
;
static inline uint8_t bcd2bin(uint8_t bcd)
{
			return ((10 * (bcd >> 4)) + (bcd & 0x0F));
}
static inline uint8_t bin2bcd(uint8_t bin)
{
			return (((bin / 10) << 4) | (bin % 10));
}
uint8_t u8_to_dec(char *buf, uint8_t buflen, uint8_t value);
char *utf8_trunc(char *utf8_str);
char *utf8_lcpy(char *dst, const char *src, size_t n);
static inline int sys_clock_hw_cycles_per_sec_runtime_get(void);
static inline int z_impl_sys_clock_hw_cycles_per_sec_runtime_get(void)
{
			extern int z_clock_hw_cycles_per_sec;
			return z_clock_hw_cycles_per_sec;
}
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef uintptr_t (*_k_syscall_handler_t)(uintptr_t arg1, uintptr_t arg2,
			uintptr_t arg3, uintptr_t arg4,
			uintptr_t arg5, uintptr_t arg6,
			void *ssf);
static inline __attribute__((always_inline)) _Bool z_syscall_trap(void)
{
			_Bool ret =3D 0;
			return ret;
}
static inline _Bool k_is_user_context(void)
{
			return 0;
}
extern int z_impl_sys_clock_hw_cycles_per_sec_runtime_get(void);
static inline int sys_clock_hw_cycles_per_sec_runtime_get(void)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_sys_clock_hw_cycles_per_sec_runtime_get();
}
struct _dnode {
			union {
			struct _dnode *head;
			struct _dnode *next;
			};
			union {
			struct _dnode *tail;
			struct _dnode *prev;
			};
};
typedef struct _dnode sys_dlist_t;
typedef struct _dnode sys_dnode_t;
static inline void sys_dlist_init(sys_dlist_t *list)
{
			list->head =3D (sys_dnode_t *)list;
			list->tail =3D (sys_dnode_t *)list;
}
static inline void sys_dnode_init(sys_dnode_t *node)
{
			node->next =3D ((void *)0);
			node->prev =3D ((void *)0);
}
static inline _Bool sys_dnode_is_linked(const sys_dnode_t *node)
{
			return node->next !=3D ((void *)0);
}
static inline _Bool sys_dlist_is_head(sys_dlist_t *list, sys_dnode_t *node)
{
			return list->head =3D=3D node;
}
static inline _Bool sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
			return list->tail =3D=3D node;
}
static inline _Bool sys_dlist_is_empty(sys_dlist_t *list)
{
			return list->head =3D=3D list;
}
static inline _Bool sys_dlist_has_multiple_nodes(sys_dlist_t *list)
{
			return list->head !=3D list->tail;
}
static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
			return sys_dlist_is_empty(list) ? ((void *)0) : list->head;
}
static inline sys_dnode_t *sys_dlist_peek_head_not_empty(sys_dlist_t *list)
{
			return list->head;
}
static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
			sys_dnode_t *node)
{
			return (node =3D=3D list->tail) ? ((void *)0) : node->next;
}
static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
			sys_dnode_t *node)
{
			return (node !=3D ((void *)0)) ? sys_dlist_peek_next_no_check(list, node=
) : ((void *)0);
}
static inline sys_dnode_t *sys_dlist_peek_prev_no_check(sys_dlist_t *list,
			sys_dnode_t *node)
{
			return (node =3D=3D list->head) ? ((void *)0) : node->prev;
}
static inline sys_dnode_t *sys_dlist_peek_prev(sys_dlist_t *list,
			sys_dnode_t *node)
{
			return (node !=3D ((void *)0)) ? sys_dlist_peek_prev_no_check(list, node=
) : ((void *)0);
}
static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
			return sys_dlist_is_empty(list) ? ((void *)0) : list->tail;
}
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
			sys_dnode_t *const tail =3D list->tail;
			node->next =3D list;
			node->prev =3D tail;
			tail->next =3D node;
			list->tail =3D node;
}
static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
			sys_dnode_t *const head =3D list->head;
			node->next =3D head;
			node->prev =3D list;
			head->prev =3D node;
			list->head =3D node;
}
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *no=
de)
{
			sys_dnode_t *const prev =3D successor->prev;
			node->prev =3D prev;
			node->next =3D successor;
			prev->next =3D node;
			successor->prev =3D node;
}
static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node=
,
			int (*cond)(sys_dnode_t *node, void *data), void *data)
{
			if (sys_dlist_is_empty(list)) {
			sys_dlist_append(list, node);
			} else {
			sys_dnode_t *pos =3D sys_dlist_peek_head(list);
			while ((pos !=3D ((void *)0)) && (cond(pos, data) =3D=3D 0)) {
			pos =3D sys_dlist_peek_next(list, pos);
			}
			if (pos !=3D ((void *)0)) {
			sys_dlist_insert(pos, node);
			} else {
			sys_dlist_append(list, node);
			}
			}
}
static inline void sys_dlist_remove(sys_dnode_t *node)
{
			sys_dnode_t *const prev =3D node->prev;
			sys_dnode_t *const next =3D node->next;
			prev->next =3D next;
			next->prev =3D prev;
			sys_dnode_init(node);
}
static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
			sys_dnode_t *node =3D ((void *)0);
			if (!sys_dlist_is_empty(list)) {
			node =3D list->head;
			sys_dlist_remove(node);
			}
			return node;
}
static inline size_t sys_dlist_len(sys_dlist_t *list)
{
			size_t len =3D 0;
			sys_dnode_t *node =3D ((void *)0);
			for (node =3D sys_dlist_peek_head(list); node !=3D ((void *)0); node =3D=
 sys_dlist_peek_next(list, node)) {
			len++;
			}
			return len;
}
struct rbnode {
			struct rbnode *children[2];
};
typedef _Bool (*rb_lessthan_t)(struct rbnode *a, struct rbnode *b);
struct rbtree {
			struct rbnode *root;
			rb_lessthan_t lessthan_fn;
			int max_depth;
};
typedef void (*rb_visit_t)(struct rbnode *node, void *cookie);
struct rbnode *z_rb_child(struct rbnode *node, uint8_t side);
int z_rb_is_black(struct rbnode *node);
void z_rb_walk(struct rbnode *node, rb_visit_t visit_fn, void *cookie);
struct rbnode *z_rb_get_minmax(struct rbtree *tree, uint8_t side);
void rb_insert(struct rbtree *tree, struct rbnode *node);
void rb_remove(struct rbtree *tree, struct rbnode *node);
static inline struct rbnode *rb_get_min(struct rbtree *tree)
{
			return z_rb_get_minmax(tree, 0U);
}
static inline struct rbnode *rb_get_max(struct rbtree *tree)
{
			return z_rb_get_minmax(tree, 1U);
}
_Bool rb_contains(struct rbtree *tree, struct rbnode *node);
static inline void rb_walk(struct rbtree *tree, rb_visit_t visit_fn,
			void *cookie)
{
			z_rb_walk(tree->root, visit_fn, cookie);
}
struct _rb_foreach {
			struct rbnode **stack;
			uint8_t *is_left;
			int32_t top;
};
struct rbnode *z_rb_foreach_next(struct rbtree *tree, struct _rb_foreach *f=
);
struct k_thread;
struct k_thread *z_priq_dumb_best(sys_dlist_t *pq);
void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread);
struct _priq_rb {
			struct rbtree tree;
			int next_order_key;
};
void z_priq_rb_add(struct _priq_rb *pq, struct k_thread *thread);
void z_priq_rb_remove(struct _priq_rb *pq, struct k_thread *thread);
struct k_thread *z_priq_rb_best(struct _priq_rb *pq);
struct _priq_mq {
			sys_dlist_t queues[32];
			unsigned int bitmask;
};
struct k_thread *z_priq_mq_best(struct _priq_mq *pq);
struct _snode {
			struct _snode *next;
};
typedef struct _snode sys_snode_t;
struct _slist {
			sys_snode_t *head;
			sys_snode_t *tail;
};
typedef struct _slist sys_slist_t;
static inline void sys_slist_init(sys_slist_t *list)
{
			list->head =3D ((void *)0);
			list->tail =3D ((void *)0);
}
static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
			return node->next;
}
static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child=
)
{
			parent->next =3D child;
}
static inline void z_slist_head_set(sys_slist_t *list, sys_snode_t *node)
{
			list->head =3D node;
}
static inline void z_slist_tail_set(sys_slist_t *list, sys_snode_t *node)
{
			list->tail =3D node;
}
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
			return list->head;
}
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
			return list->tail;
}
static inline _Bool sys_slist_is_empty(sys_slist_t *list);
static inline _Bool sys_slist_is_empty(sys_slist_t *list) { return (sys_sli=
st_peek_head(list) =3D=3D ((void *)0)); }
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);
static inline sys_snode_t * sys_slist_peek_next_no_check(sys_snode_t *node)=
 { return z_snode_next_peek(node); }
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);
static inline sys_snode_t * sys_slist_peek_next(sys_snode_t *node) { return=
 node !=3D ((void *)0) ? sys_slist_peek_next_no_check(node) : ((void *)0); =
}
static inline void sys_slist_prepend(sys_slist_t *list,
			sys_snode_t *node);
static inline void sys_slist_prepend(sys_slist_t *list, sys_snode_t *node) =
{ z_snode_next_set(node, sys_slist_peek_head(list)); z_slist_head_set(list,=
 node); if (sys_slist_peek_tail(list) =3D=3D ((void *)0)) { z_slist_tail_se=
t(list, sys_slist_peek_head(list)); } }
static inline void sys_slist_append(sys_slist_t *list,
			sys_snode_t *node);
static inline void sys_slist_append(sys_slist_t *list, sys_snode_t *node) {=
 z_snode_next_set(node, ((void *)0)); if (sys_slist_peek_tail(list) =3D=3D =
((void *)0)) { z_slist_tail_set(list, node); z_slist_head_set(list, node); =
} else { z_snode_next_set( sys_slist_peek_tail(list), node); z_slist_tail_s=
et(list, node); } }
static inline void sys_slist_append_list(sys_slist_t *list,
			void *head, void *tail);
static inline void sys_slist_append_list(sys_slist_t *list, void *head, voi=
d *tail) { if (head !=3D ((void *)0) && tail !=3D ((void *)0)) { if (sys_sl=
ist_peek_tail(list) =3D=3D ((void *)0)) { z_slist_head_set(list, (sys_snode=
_t *)head); } else { z_snode_next_set( sys_slist_peek_tail(list), (sys_snod=
e_t *)head); } z_slist_tail_set(list, (sys_snode_t *)tail); } }
static inline void sys_slist_merge_slist(sys_slist_t *list,
			sys_slist_t *list_to_append);
static inline void sys_slist_merge_slist ( sys_slist_t *list, sys_slist_t *=
list_to_append) { sys_snode_t *head, *tail; head =3D sys_slist_peek_head(li=
st_to_append); tail =3D sys_slist_peek_tail(list_to_append); sys_slist_appe=
nd_list(list, head, tail); sys_slist_init(list_to_append); }
static inline void sys_slist_insert(sys_slist_t *list,
			sys_snode_t *prev,
			sys_snode_t *node);
static inline void sys_slist_insert(sys_slist_t *list, sys_snode_t *prev, s=
ys_snode_t *node) { if (prev =3D=3D ((void *)0)) { sys_slist_prepend(list, =
node); } else if (z_snode_next_peek(prev) =3D=3D ((void *)0)) { sys_slist_a=
ppend(list, node); } else { z_snode_next_set(node, z_snode_next_peek(prev))=
; z_snode_next_set(prev, node); } }
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);
static inline sys_snode_t * sys_slist_get_not_empty(sys_slist_t *list) { sy=
s_snode_t *node =3D sys_slist_peek_head(list); z_slist_head_set(list, z_sno=
de_next_peek(node)); if (sys_slist_peek_tail(list) =3D=3D node) { z_slist_t=
ail_set(list, sys_slist_peek_head(list)); } return node; }
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);
static inline sys_snode_t * sys_slist_get(sys_slist_t *list) { return sys_s=
list_is_empty(list) ? ((void *)0) : sys_slist_get_not_empty(list); }
static inline void sys_slist_remove(sys_slist_t *list,
			sys_snode_t *prev_node,
			sys_snode_t *node);
static inline void sys_slist_remove(sys_slist_t *list, sys_snode_t *prev_no=
de, sys_snode_t *node) { if (prev_node =3D=3D ((void *)0)) { z_slist_head_s=
et(list, z_snode_next_peek(node)); if (sys_slist_peek_tail(list) =3D=3D nod=
e) { z_slist_tail_set(list, sys_slist_peek_head(list)); } } else { z_snode_=
next_set(prev_node, z_snode_next_peek(node)); if (sys_slist_peek_tail(list)=
 =3D=3D node) { z_slist_tail_set(list, prev_node); } } z_snode_next_set(nod=
e, ((void *)0)); }
static inline _Bool sys_slist_find_and_remove(sys_slist_t *list,
			sys_snode_t *node);
static inline size_t sys_slist_len(sys_slist_t *list);
static inline size_t sys_slist_len(sys_slist_t * list) { size_t len =3D 0; =
static sys_snode_t * node; for (node =3D sys_slist_peek_head(list); node !=
=3D ((void *)0); node =3D sys_slist_peek_next(node)) { len++; } return len;=
 }
static inline _Bool sys_slist_find_and_remove(sys_slist_t *list, sys_snode_=
t *node) { sys_snode_t *prev =3D ((void *)0); sys_snode_t *test; for (test =
=3D sys_slist_peek_head(list); test !=3D ((void *)0); test =3D sys_slist_pe=
ek_next(test)) { if (test =3D=3D node) { sys_slist_remove(list, prev, node)=
; return 1; } prev =3D test; } return 0; }
typedef uint64_t unative_t;
struct _sfnode {
			unative_t next_and_flags;
};
typedef struct _sfnode sys_sfnode_t;
struct _sflist {
			sys_sfnode_t *head;
			sys_sfnode_t *tail;
};
typedef struct _sflist sys_sflist_t;
static inline void sys_sflist_init(sys_sflist_t *list)
{
			list->head =3D ((void *)0);
			list->tail =3D ((void *)0);
}
static inline sys_sfnode_t *z_sfnode_next_peek(sys_sfnode_t *node)
{
			return (sys_sfnode_t *)(node->next_and_flags & ~0x3UL);
}
static inline uint8_t sys_sfnode_flags_get(sys_sfnode_t *node);
static inline void z_sfnode_next_set(sys_sfnode_t *parent,
			sys_sfnode_t *child)
{
			uint8_t cur_flags =3D sys_sfnode_flags_get(parent);
			parent->next_and_flags =3D cur_flags | (unative_t)child;
}
static inline void z_sflist_head_set(sys_sflist_t *list, sys_sfnode_t *node=
)
{
			list->head =3D node;
}
static inline void z_sflist_tail_set(sys_sflist_t *list, sys_sfnode_t *node=
)
{
			list->tail =3D node;
}
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
			return list->head;
}
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
			return list->tail;
}
static inline uint8_t sys_sfnode_flags_get(sys_sfnode_t *node)
{
			return node->next_and_flags & 0x3UL;
}
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
			{ };
			node->next_and_flags =3D flags;
}
static inline void sys_sfnode_flags_set(sys_sfnode_t *node, uint8_t flags)
{
			{ };
			node->next_and_flags =3D (unative_t)(z_sfnode_next_peek(node)) | flags;
}
static inline _Bool sys_sflist_is_empty(sys_sflist_t *list);
static inline _Bool sys_sflist_is_empty(sys_sflist_t *list) { return (sys_s=
flist_peek_head(list) =3D=3D ((void *)0)); }
static inline sys_sfnode_t *sys_sflist_peek_next_no_check(sys_sfnode_t *nod=
e);
static inline sys_sfnode_t * sys_sflist_peek_next_no_check(sys_sfnode_t *no=
de) { return z_sfnode_next_peek(node); }
static inline sys_sfnode_t *sys_sflist_peek_next(sys_sfnode_t *node);
static inline sys_sfnode_t * sys_sflist_peek_next(sys_sfnode_t *node) { ret=
urn node !=3D ((void *)0) ? sys_sflist_peek_next_no_check(node) : ((void *)=
0); }
static inline void sys_sflist_prepend(sys_sflist_t *list,
			sys_sfnode_t *node);
static inline void sys_sflist_prepend(sys_sflist_t *list, sys_sfnode_t *nod=
e) { z_sfnode_next_set(node, sys_sflist_peek_head(list)); z_sflist_head_set=
(list, node); if (sys_sflist_peek_tail(list) =3D=3D ((void *)0)) { z_sflist=
_tail_set(list, sys_sflist_peek_head(list)); } }
static inline void sys_sflist_append(sys_sflist_t *list,
			sys_sfnode_t *node);
static inline void sys_sflist_append(sys_sflist_t *list, sys_sfnode_t *node=
) { z_sfnode_next_set(node, ((void *)0)); if (sys_sflist_peek_tail(list) =
=3D=3D ((void *)0)) { z_sflist_tail_set(list, node); z_sflist_head_set(list=
, node); } else { z_sfnode_next_set( sys_sflist_peek_tail(list), node); z_s=
flist_tail_set(list, node); } }
static inline void sys_sflist_append_list(sys_sflist_t *list,
			void *head, void *tail);
static inline void sys_sflist_append_list(sys_sflist_t *list, void *head, v=
oid *tail) { if (head !=3D ((void *)0) && tail !=3D ((void *)0)) { if (sys_=
sflist_peek_tail(list) =3D=3D ((void *)0)) { z_sflist_head_set(list, (sys_s=
fnode_t *)head); } else { z_sfnode_next_set( sys_sflist_peek_tail(list), (s=
ys_sfnode_t *)head); } z_sflist_tail_set(list, (sys_sfnode_t *)tail); } }
static inline void sys_sflist_merge_sflist(sys_sflist_t *list,
			sys_sflist_t *list_to_append);
static inline void sys_sflist_merge_sflist ( sys_sflist_t *list, sys_sflist=
_t *list_to_append) { sys_sfnode_t *head, *tail; head =3D sys_sflist_peek_h=
ead(list_to_append); tail =3D sys_sflist_peek_tail(list_to_append); sys_sfl=
ist_append_list(list, head, tail); sys_sflist_init(list_to_append); }
static inline void sys_sflist_insert(sys_sflist_t *list,
			sys_sfnode_t *prev,
			sys_sfnode_t *node);
static inline void sys_sflist_insert(sys_sflist_t *list, sys_sfnode_t *prev=
, sys_sfnode_t *node) { if (prev =3D=3D ((void *)0)) { sys_sflist_prepend(l=
ist, node); } else if (z_sfnode_next_peek(prev) =3D=3D ((void *)0)) { sys_s=
flist_append(list, node); } else { z_sfnode_next_set(node, z_sfnode_next_pe=
ek(prev)); z_sfnode_next_set(prev, node); } }
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);
static inline sys_sfnode_t * sys_sflist_get_not_empty(sys_sflist_t *list) {=
 sys_sfnode_t *node =3D sys_sflist_peek_head(list); z_sflist_head_set(list,=
 z_sfnode_next_peek(node)); if (sys_sflist_peek_tail(list) =3D=3D node) { z=
_sflist_tail_set(list, sys_sflist_peek_head(list)); } return node; }
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);
static inline sys_sfnode_t * sys_sflist_get(sys_sflist_t *list) { return sy=
s_sflist_is_empty(list) ? ((void *)0) : sys_sflist_get_not_empty(list); }
static inline void sys_sflist_remove(sys_sflist_t *list,
			sys_sfnode_t *prev_node,
			sys_sfnode_t *node);
static inline void sys_sflist_remove(sys_sflist_t *list, sys_sfnode_t *prev=
_node, sys_sfnode_t *node) { if (prev_node =3D=3D ((void *)0)) { z_sflist_h=
ead_set(list, z_sfnode_next_peek(node)); if (sys_sflist_peek_tail(list) =3D=
=3D node) { z_sflist_tail_set(list, sys_sflist_peek_head(list)); } } else {=
 z_sfnode_next_set(prev_node, z_sfnode_next_peek(node)); if (sys_sflist_pee=
k_tail(list) =3D=3D node) { z_sflist_tail_set(list, prev_node); } } z_sfnod=
e_next_set(node, ((void *)0)); }
static inline _Bool sys_sflist_find_and_remove(sys_sflist_t *list,
			sys_sfnode_t *node);
static inline _Bool sys_sflist_find_and_remove(sys_sflist_t *list, sys_sfno=
de_t *node) { sys_sfnode_t *prev =3D ((void *)0); sys_sfnode_t *test; for (=
test =3D sys_sflist_peek_head(list); test !=3D ((void *)0); test =3D sys_sf=
list_peek_next(test)) { if (test =3D=3D node) { sys_sflist_remove(list, pre=
v, node); return 1; } prev =3D test; } return 0; }
static inline size_t sys_sflist_len(sys_sflist_t *list);
static inline size_t sys_sflist_len(sys_sflist_t * list) { size_t len =3D 0=
; static sys_sfnode_t * node; for (node =3D sys_sflist_peek_head(list); nod=
e !=3D ((void *)0); node =3D sys_sflist_peek_next(node)) { len++; } return =
len; }
struct k_obj_type;
struct k_obj_core;
extern sys_slist_t z_obj_type_list;
struct k_obj_core_stats_desc {
			size_t raw_size;
			size_t query_size;
			int (*raw)(struct k_obj_core *obj_core, void *stats);
			int (*query)(struct k_obj_core *obj_core, void *stats);
			int (*reset)(struct k_obj_core *obj_core);
			int (*disable)(struct k_obj_core *obj_core);
			int (*enable)(struct k_obj_core *obj_core);
};
struct k_obj_type {
			sys_snode_t node;
			sys_slist_t list;
			uint32_t id;
			size_t obj_core_offset;
};
struct k_obj_core {
			sys_snode_t node;
			struct k_obj_type *type;
};
struct k_obj_type *z_obj_type_init(struct k_obj_type *type,
			uint32_t id, size_t off);
struct k_obj_type *k_obj_type_find(uint32_t type_id);
int k_obj_type_walk_locked(struct k_obj_type *type,
			int (*func)(struct k_obj_core *, void *),
			void *data);
int k_obj_type_walk_unlocked(struct k_obj_type *type,
			int (*func)(struct k_obj_core *, void *),
			void *data);
void k_obj_core_init(struct k_obj_core *obj_core, struct k_obj_type *type);
void k_obj_core_link(struct k_obj_core *obj_core);
void k_obj_core_init_and_link(struct k_obj_core *obj_core,
			struct k_obj_type *type);
void k_obj_core_unlink(struct k_obj_core *obj_core);
int k_obj_core_stats_register(struct k_obj_core *obj_core, void *stats,
			size_t stats_len);
int k_obj_core_stats_deregister(struct k_obj_core *obj_core);
int k_obj_core_stats_raw(struct k_obj_core *obj_core, void *stats,
			size_t stats_len);
int k_obj_core_stats_query(struct k_obj_core *obj_core, void *stats,
			size_t stats_len);
int k_obj_core_stats_reset(struct k_obj_core *obj_core);
int k_obj_core_stats_disable(struct k_obj_core *obj_core);
int k_obj_core_stats_enable(struct k_obj_core *obj_core);
struct sys_memory_stats {
			size_t free_bytes;
			size_t allocated_bytes;
			size_t max_allocated_bytes;
};
struct sys_heap {
			struct z_heap *heap;
			void *init_mem;
			size_t init_bytes;
};
struct z_heap_stress_result {
			uint32_t total_allocs;
			uint32_t successful_allocs;
			uint32_t total_frees;
			uint64_t accumulated_in_use_bytes;
};
void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes);
void *sys_heap_alloc(struct sys_heap *heap, size_t bytes);
void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t by=
tes);
void sys_heap_free(struct sys_heap *heap, void *mem);
void *sys_heap_aligned_realloc(struct sys_heap *heap, void *ptr,
			size_t align, size_t bytes);
size_t sys_heap_usable_size(struct sys_heap *heap, void *mem);
_Bool sys_heap_validate(struct sys_heap *heap);
void sys_heap_stress(void *(*alloc_fn)(void *arg, size_t bytes),
			void (*free_fn)(void *arg, void *p),
			void *arg, size_t total_bytes,
			uint32_t op_count,
			void *scratch_mem, size_t scratch_bytes,
			int target_percent,
			struct z_heap_stress_result *result);
void sys_heap_print_info(struct sys_heap *heap, _Bool dump_chunks);
struct _cpu_arch {
			atomic_ptr_val_t fpu_owner;
};
typedef struct _cpu_arch _cpu_arch_t;
struct k_cycle_stats {
			uint64_t total;
			_Bool track_usage;
};
struct _ready_q {
			struct k_thread *cache;
			sys_dlist_t runq;
};
typedef struct _ready_q _ready_q_t;
struct _cpu {
			uint32_t nested;
			char *irq_stack;
			struct k_thread *current;
			struct k_thread *idle_thread;
			uint8_t id;
			void *fp_ctx;
			struct _cpu_arch arch;
};
typedef struct _cpu _cpu_t;
struct z_kernel {
			struct _cpu cpus[1];
			struct _ready_q ready_q;
			struct k_thread *current_fp;
};
typedef struct z_kernel _kernel_t;
extern struct z_kernel _kernel;
extern atomic_t _cpus_active;
typedef struct {
			sys_dlist_t waitq;
} _wait_q_t;
struct _timeout;
typedef void (*_timeout_func_t)(struct _timeout *t);
struct _timeout {
			sys_dnode_t node;
			_timeout_func_t fn;
			int64_t dticks;
};
typedef void (*k_thread_timeslice_fn_t)(struct k_thread *thread, void *data=
);
uint32_t sys_kernel_version_get(void);
typedef int __gwchar_t;
typedef struct
		{
			long int quot;
			long int rem;
		} imaxdiv_t;
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf=
__)) __attribute__ ((__const__));
extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern intmax_t strtoimax (const char *__restrict __nptr,
			char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __=
leaf__));
extern uintmax_t strtoumax (const char *__restrict __nptr,
			char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , _=
_leaf__));
extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
			__gwchar_t **__restrict __endptr, int __base)
			__attribute__ ((__nothrow__ , __leaf__));
extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
			__gwchar_t ** __restrict __endptr, int __base)
			__attribute__ ((__nothrow__ , __leaf__));
__attribute__((format (printf, 1, 2))) void printk(const char *fmt, ...);
__attribute__((format (printf, 1, 0))) void vprintk(const char *fmt, va_lis=
t ap);
typedef struct
{
		int __count;
		union
		{
			unsigned int __wch;
			char __wchb[4];
		} __value;
} __mbstate_t;
typedef struct _G_fpos_t
{
		__off_t __pos;
		__mbstate_t __state;
} __fpos_t;
typedef struct _G_fpos64_t
{
		__off64_t __pos;
		__mbstate_t __state;
} __fpos64_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE
{
		int _flags;
		char *_IO_read_ptr;
		char *_IO_read_end;
		char *_IO_read_base;
		char *_IO_write_base;
		char *_IO_write_ptr;
		char *_IO_write_end;
		char *_IO_buf_base;
		char *_IO_buf_end;
		char *_IO_save_base;
		char *_IO_backup_base;
		char *_IO_save_end;
		struct _IO_marker *_markers;
		struct _IO_FILE *_chain;
		int _fileno;
		int _flags2;
		__off_t _old_offset;
		unsigned short _cur_column;
		signed char _vtable_offset;
		char _shortbuf[1];
		_IO_lock_t *_lock;
		__off64_t _offset;
		struct _IO_codecvt *_codecvt;
		struct _IO_wide_data *_wide_data;
		struct _IO_FILE *_freeres_list;
		void *_freeres_buf;
		size_t __pad5;
		int _mode;
		char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef __fpos_t fpos_t;
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __=
leaf__));
extern int rename (const char *__old, const char *__new) __attribute__ ((__=
nothrow__ , __leaf__));
extern int renameat (int __oldfd, const char *__old, int __newfd,
			const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern int fclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern FILE *tmpfile (void)
		__attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __a=
ttribute__ ((__warn_unused_result__));
extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ , __leaf__)) __a=
ttribute__ ((__warn_unused_result__));
extern int fflush (FILE *__stream);
extern FILE *fopen (const char *__restrict __filename,
			const char *__restrict __modes)
		__attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __a=
ttribute__ ((__warn_unused_result__));
extern FILE *freopen (const char *__restrict __filename,
			const char *__restrict __modes,
			FILE *__restrict __stream) __attribute__ ((__warn_unused_result__)) __at=
tribute__ ((__nonnull__ (3)));
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothr=
ow__ , __leaf__))
		__attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __a=
ttribute__ ((__warn_unused_result__));
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
		__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __a=
ttribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result_=
_));
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribut=
e__ ((__nothrow__ , __leaf__))
		__attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __a=
ttribute__ ((__warn_unused_result__));
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __at=
tribute__ ((__nothrow__ , __leaf__));
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
			int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern int fprintf (FILE *__restrict __stream,
			const char *__restrict __format, ...);
extern int printf (const char *__restrict __format, ...);
extern int sprintf (char *__restrict __s,
			const char *__restrict __format, ...) __attribute__ ((__nothrow__));
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
			__gnuc_va_list __arg);
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
extern int vsprintf (char *__restrict __s, const char *__restrict __format,
			__gnuc_va_list __arg) __attribute__ ((__nothrow__));
extern int snprintf (char *__restrict __s, size_t __maxlen,
			const char *__restrict __format, ...)
			__attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3,=
 4)));
extern int vsnprintf (char *__restrict __s, size_t __maxlen,
			const char *__restrict __format, __gnuc_va_list __arg)
			__attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3,=
 0)));
extern int vdprintf (int __fd, const char *__restrict __fmt,
			__gnuc_va_list __arg)
			__attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
			__attribute__ ((__format__ (__printf__, 2, 3)));
extern int fscanf (FILE *__restrict __stream,
			const char *__restrict __format, ...) __attribute__ ((__warn_unused_resu=
lt__));
extern int scanf (const char *__restrict __format, ...) __attribute__ ((__w=
arn_unused_result__));
extern int sscanf (const char *__restrict __s,
			const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __le=
af__));
extern int fscanf (FILE *__restrict __stream, const char *__restrict __form=
at, ...) __asm__ ("__USER_LABEL_PREFIX__" "__isoc99_fscanf") __attribute__ =
((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("__USER_LA=
BEL_PREFIX__" "__isoc99_scanf") __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __for=
mat, ...) __asm__ ("__USER_LABEL_PREFIX__" "__isoc99_sscanf") __attribute__=
 ((__nothrow__ , __leaf__));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
			__gnuc_va_list __arg)
			__attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_un=
used_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
			__attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_un=
used_result__));
extern int vsscanf (const char *__restrict __s,
			const char *__restrict __format, __gnuc_va_list __arg)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__s=
canf__, 2, 0)));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, =
__gnuc_va_list __arg) __asm__ ("__USER_LABEL_PREFIX__" "__isoc99_vfscanf")
			__attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_un=
used_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) _=
_asm__ ("__USER_LABEL_PREFIX__" "__isoc99_vscanf")
			__attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_un=
used_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __fo=
rmat, __gnuc_va_list __arg) __asm__ ("__USER_LABEL_PREFIX__" "__isoc99_vssc=
anf") __attribute__ ((__nothrow__ , __leaf__))
			__attribute__ ((__format__ (__scanf__, 2, 0)));
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);
extern int getchar (void);
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);
extern int putchar (int __c);
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __strea=
m)
			__attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__w=
rite_only__, 1, 2)));
extern char *gets (char *__s) __attribute__ ((__warn_unused_result__)) __at=
tribute__ ((__deprecated__));
extern __ssize_t __getdelim (char **__restrict __lineptr,
			size_t *__restrict __n, int __delimiter,
			FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
			size_t *__restrict __n, int __delimiter,
			FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getline (char **__restrict __lineptr,
			size_t *__restrict __n,
			FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
extern int puts (const char *__s);
extern int ungetc (int __c, FILE *__stream);
extern size_t fread (void *__restrict __ptr, size_t __size,
			size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_res=
ult__));
extern size_t fwrite (const void *__restrict __ptr, size_t __size,
			size_t __n, FILE *__restrict __s);
extern int fseek (FILE *__stream, long int __off, int __whence);
extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result=
__));
extern void rewind (FILE *__stream);
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result=
__));
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf_=
_));
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) _=
_attribute__ ((__warn_unused_result__));
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__))=
 __attribute__ ((__warn_unused_result__));
extern void perror (const char *__s) __attribute__ ((__cold__));
extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__))=
 __attribute__ ((__warn_unused_result__));
extern int pclose (FILE *__stream);
extern FILE *popen (const char *__command, const char *__modes)
		__attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) __a=
ttribute__ ((__warn_unused_result__));
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__))
		__attribute__ ((__access__ (__write_only__, 1)));
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf=
__));
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __le=
af__)) __attribute__ ((__warn_unused_result__));
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __le=
af__));
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
			const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __le=
af__))
			__attribute__ ((__access__ (__write_only__, 1, 3)));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
			const char *__restrict __format,
			__gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__))
			__attribute__ ((__access__ (__write_only__, 1, 3)));
extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
			size_t __slen, const char *__restrict __format,
			...) __attribute__ ((__nothrow__ , __leaf__))
			__attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
			size_t __slen, const char *__restrict __format,
			__gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__))
			__attribute__ ((__access__ (__write_only__, 1, 2)));
extern char *__gets_warn (char *__str) __asm__ ("__USER_LABEL_PREFIX__" "ge=
ts")
			__attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pl=
ease use fgets or getline instead, gets can't " "specify buffer size")));
extern char *__gets_chk (char *__str, size_t) __attribute__ ((__warn_unused=
_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict=
 __stream) __asm__ ("__USER_LABEL_PREFIX__" "fgets")
			__attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__w=
rite_only__, 1, 2)));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n=
, FILE *__restrict __stream) __asm__ ("__USER_LABEL_PREFIX__" "__fgets_chk"=
)
			__attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fg=
ets called with bigger size than length " "of destination buffer")));
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
			FILE *__restrict __stream)
			__attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__w=
rite_only__, 1, 3)));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t =
__n, FILE *__restrict __stream) __asm__ ("__USER_LABEL_PREFIX__" "fread") _=
_attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, si=
ze_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("__USER_LABEL_=
PREFIX__" "__fread_chk")
			__attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fr=
ead called with bigger size * nmemb than length " "of destination buffer"))=
);
extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
			size_t __size, size_t __n,
			FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, con=
st char *__restrict __fmt, ...)
{
		return __builtin___sprintf_chk (__s, 1 - 1,
			__builtin_object_size (__s, 1 > 1), __fmt,);
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, co=
nst char *__restrict __fmt, __gnuc_va_list __ap)
{
		return __builtin___vsprintf_chk (__s, 1 - 1,
			__builtin_object_size (__s, 1 > 1), __fmt, __ap);
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, si=
ze_t __n, const char *__restrict __fmt, ...)
{
		return __builtin___snprintf_chk (__s, __n, 1 - 1,
			__builtin_object_size (__s, 1 > 1), __fmt,);
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, s=
ize_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)
{
		return __builtin___vsnprintf_chk (__s, __n, 1 - 1,
			__builtin_object_size (__s, 1 > 1), __fmt, __ap);
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) __attribute__ ((__warn_unused_result__)) char *
gets (char *__str)
{
		if (__builtin_object_size (__str, 1 > 1) !=3D (size_t) -1)
			return __gets_chk (__str, __builtin_object_size (__str, 1 > 1));
		return __gets_warn (__str);
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access=
__ (__write_only__, 1, 2))) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
		size_t sz =3D __builtin_object_size (__s, 1 > 1);
		if (((__builtin_constant_p (sz) && (sz) =3D=3D (unsigned long) -1) || (((=
__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (=
__n) > 0)) && __builtin_constant_p ((((unsigned long) (__n)) <=3D ((sz)) / =
((sizeof (char))))) && (((unsigned long) (__n)) <=3D ((sz)) / ((sizeof (cha=
r)))))))
			return __fgets_alias (__s, __n, __stream);
		if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (=
__n) && (__n) > 0)) && __builtin_constant_p ((((unsigned long) (__n)) <=3D =
(sz) / (sizeof (char)))) && !(((unsigned long) (__n)) <=3D (sz) / (sizeof (=
char)))))
			return __fgets_chk_warn (__s, sz, __n, __stream);
		return __fgets_chk (__s, sz, __n, __stream);
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
			FILE *__restrict __stream)
{
		size_t sz =3D __builtin_object_size (__ptr, 0);
		if (((__builtin_constant_p (sz) && (sz) =3D=3D (unsigned long) -1) || (((=
__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (=
__n) > 0)) && __builtin_constant_p ((((unsigned long) (__n)) <=3D ((sz)) / =
((__size)))) && (((unsigned long) (__n)) <=3D ((sz)) / ((__size))))))
			return __fread_alias (__ptr, __size, __n, __stream);
		if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (=
__n) && (__n) > 0)) && __builtin_constant_p ((((unsigned long) (__n)) <=3D =
(sz) / (__size))) && !(((unsigned long) (__n)) <=3D (sz) / (__size))))
			return __fread_chk_warn (__ptr, sz, __size, __n, __stream);
		return __fread_chk (__ptr, sz, __size, __n, __stream);
}
typedef void (*irq_offload_routine_t)(const void *parameter);
void irq_offload(irq_offload_routine_t routine, const void *parameter);
struct k_thread;
struct k_mem_domain;
typedef struct z_thread_stack_element k_thread_stack_t;
typedef void (*k_thread_entry_t)(void *p1, void *p2, void *p3);
static inline uint32_t arch_k_cycle_get_32(void);
static inline uint64_t arch_k_cycle_get_64(void);
void arch_cpu_idle(void);
void arch_cpu_atomic_idle(unsigned int key);
typedef __attribute__((__noreturn__)) void (*arch_cpustart_t)(void *data);
void arch_start_cpu(int cpu_num, k_thread_stack_t *stack, int sz,
			arch_cpustart_t fn, void *arg);
_Bool arch_cpu_active(int cpu_num);
static inline unsigned int arch_irq_lock(void);
static inline void arch_irq_unlock(unsigned int key);
static inline _Bool arch_irq_unlocked(unsigned int key);
void arch_irq_disable(unsigned int irq);
void arch_irq_enable(unsigned int irq);
int arch_irq_is_enabled(unsigned int irq);
int arch_irq_connect_dynamic(unsigned int irq, unsigned int priority,
			void (*routine)(const void *parameter),
			const void *parameter, uint32_t flags);
int arch_irq_disconnect_dynamic(unsigned int irq, unsigned int priority,
			void (*routine)(const void *parameter),
			const void *parameter, uint32_t flags);
unsigned int arch_irq_allocate(void);
void arch_irq_set_used(unsigned int irq);
_Bool arch_irq_is_used(unsigned int irq);
static inline unsigned int arch_num_cpus(void);
static inline _Bool arch_mem_coherent(void *ptr)
{
			(void)(ptr);
			return 1;
}
static inline void arch_cohere_stacks(struct k_thread *old_thread,
			void *old_switch_handle,
			struct k_thread *new_thread)
{
			(void)(old_thread);
			(void)(old_switch_handle);
			(void)(new_thread);
}
void arch_spin_relax(void);
static inline __attribute__((always_inline)) uint64_t read_ccsidr_el1(void)=
 { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "ccsidr_el1" : =
"=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((=
always_inline)) void write_ccsidr_el1(uint64_t val) { ({ __asm__ volatile (=
"msr " "ccsidr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __=
attribute__((always_inline)) void zero_ccsidr_el1(void) { ({ __asm__ volati=
le ("msr " "ccsidr_el1" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_clidr_el1(void) =
{ return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "clidr_el1" : "=
=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((a=
lways_inline)) void write_clidr_el1(uint64_t val) { ({ __asm__ volatile ("m=
sr " "clidr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __att=
ribute__((always_inline)) void zero_clidr_el1(void) { ({ __asm__ volatile (=
"msr " "clidr_el1" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_cntfrq_el0(void)=
 { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cntfrq_el0" : =
"=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((=
always_inline)) void write_cntfrq_el0(uint64_t val) { ({ __asm__ volatile (=
"msr " "cntfrq_el0" ", %0" :: "r" (val) : "memory"); }); } static inline __=
attribute__((always_inline)) void zero_cntfrq_el0(void) { ({ __asm__ volati=
le ("msr " "cntfrq_el0" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_cnthctl_el2(void=
) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cnthctl_el2" =
: "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__=
((always_inline)) void write_cnthctl_el2(uint64_t val) { ({ __asm__ volatil=
e ("msr " "cnthctl_el2" ", %0" :: "r" (val) : "memory"); }); } static inlin=
e __attribute__((always_inline)) void zero_cnthctl_el2(void) { ({ __asm__ v=
olatile ("msr " "cnthctl_el2" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_cnthp_ctl_el2(vo=
id) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cnthp_ctl_e=
l2" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribu=
te__((always_inline)) void write_cnthp_ctl_el2(uint64_t val) { ({ __asm__ v=
olatile ("msr " "cnthp_ctl_el2" ", %0" :: "r" (val) : "memory"); }); } stat=
ic inline __attribute__((always_inline)) void zero_cnthp_ctl_el2(void) { ({=
 __asm__ volatile ("msr " "cnthp_ctl_el2" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_cnthps_ctl_el2(v=
oid) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cnthps_ctl=
_el2" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attri=
bute__((always_inline)) void write_cnthps_ctl_el2(uint64_t val) { ({ __asm_=
_ volatile ("msr " "cnthps_ctl_el2" ", %0" :: "r" (val) : "memory"); }); } =
static inline __attribute__((always_inline)) void zero_cnthps_ctl_el2(void)=
 { ({ __asm__ volatile ("msr " "cnthps_ctl_el2" ", xzr" ::: "memory"); }); =
};
static inline __attribute__((always_inline)) uint64_t read_cntv_ctl_el0(voi=
d) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cntv_ctl_el0=
" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute=
__((always_inline)) void write_cntv_ctl_el0(uint64_t val) { ({ __asm__ vola=
tile ("msr " "cntv_ctl_el0" ", %0" :: "r" (val) : "memory"); }); } static i=
nline __attribute__((always_inline)) void zero_cntv_ctl_el0(void) { ({ __as=
m__ volatile ("msr " "cntv_ctl_el0" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_cntv_cval_el0(vo=
id) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cntv_cval_e=
l0" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribu=
te__((always_inline)) void write_cntv_cval_el0(uint64_t val) { ({ __asm__ v=
olatile ("msr " "cntv_cval_el0" ", %0" :: "r" (val) : "memory"); }); } stat=
ic inline __attribute__((always_inline)) void zero_cntv_cval_el0(void) { ({=
 __asm__ volatile ("msr " "cntv_cval_el0" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_cntvct_el0(void)=
 { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cntvct_el0" : =
"=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((=
always_inline)) void write_cntvct_el0(uint64_t val) { ({ __asm__ volatile (=
"msr " "cntvct_el0" ", %0" :: "r" (val) : "memory"); }); } static inline __=
attribute__((always_inline)) void zero_cntvct_el0(void) { ({ __asm__ volati=
le ("msr " "cntvct_el0" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_cntvoff_el2(void=
) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cntvoff_el2" =
: "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__=
((always_inline)) void write_cntvoff_el2(uint64_t val) { ({ __asm__ volatil=
e ("msr " "cntvoff_el2" ", %0" :: "r" (val) : "memory"); }); } static inlin=
e __attribute__((always_inline)) void zero_cntvoff_el2(void) { ({ __asm__ v=
olatile ("msr " "cntvoff_el2" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_currentel(void) =
{ return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "currentel" : "=
=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((a=
lways_inline)) void write_currentel(uint64_t val) { ({ __asm__ volatile ("m=
sr " "currentel" ", %0" :: "r" (val) : "memory"); }); } static inline __att=
ribute__((always_inline)) void zero_currentel(void) { ({ __asm__ volatile (=
"msr " "currentel" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_csselr_el1(void)=
 { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "csselr_el1" : =
"=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((=
always_inline)) void write_csselr_el1(uint64_t val) { ({ __asm__ volatile (=
"msr " "csselr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __=
attribute__((always_inline)) void zero_csselr_el1(void) { ({ __asm__ volati=
le ("msr " "csselr_el1" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_daif(void) { ret=
urn ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "daif" : "=3Dr" (reg_=
val) :: "memory"); reg_val; }); } static inline __attribute__((always_inlin=
e)) void write_daif(uint64_t val) { ({ __asm__ volatile ("msr " "daif" ", %=
0" :: "r" (val) : "memory"); }); } static inline __attribute__((always_inli=
ne)) void zero_daif(void) { ({ __asm__ volatile ("msr " "daif" ", xzr" ::: =
"memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_hcr_el2(void) { =
return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "hcr_el2" : "=3Dr"=
 (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always=
_inline)) void write_hcr_el2(uint64_t val) { ({ __asm__ volatile ("msr " "h=
cr_el2" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__(=
(always_inline)) void zero_hcr_el2(void) { ({ __asm__ volatile ("msr " "hcr=
_el2" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_id_aa64pfr0_el1(=
void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "id_aa64pf=
r0_el1" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __att=
ribute__((always_inline)) void write_id_aa64pfr0_el1(uint64_t val) { ({ __a=
sm__ volatile ("msr " "id_aa64pfr0_el1" ", %0" :: "r" (val) : "memory"); })=
; } static inline __attribute__((always_inline)) void zero_id_aa64pfr0_el1(=
void) { ({ __asm__ volatile ("msr " "id_aa64pfr0_el1" ", xzr" ::: "memory")=
; }); };
static inline __attribute__((always_inline)) uint64_t read_id_aa64mmfr0_el1=
(void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "id_aa64m=
mfr0_el1" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __a=
ttribute__((always_inline)) void write_id_aa64mmfr0_el1(uint64_t val) { ({ =
__asm__ volatile ("msr " "id_aa64mmfr0_el1" ", %0" :: "r" (val) : "memory")=
; }); } static inline __attribute__((always_inline)) void zero_id_aa64mmfr0=
_el1(void) { ({ __asm__ volatile ("msr " "id_aa64mmfr0_el1" ", xzr" ::: "me=
mory"); }); };
static inline __attribute__((always_inline)) uint64_t read_mpidr_el1(void) =
{ return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "mpidr_el1" : "=
=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((a=
lways_inline)) void write_mpidr_el1(uint64_t val) { ({ __asm__ volatile ("m=
sr " "mpidr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __att=
ribute__((always_inline)) void zero_mpidr_el1(void) { ({ __asm__ volatile (=
"msr " "mpidr_el1" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_par_el1(void) { =
return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "par_el1" : "=3Dr"=
 (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always=
_inline)) void write_par_el1(uint64_t val) { ({ __asm__ volatile ("msr " "p=
ar_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__(=
(always_inline)) void zero_par_el1(void) { ({ __asm__ volatile ("msr " "par=
_el1" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_scr_el3(void) { =
return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "scr_el3" : "=3Dr"=
 (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always=
_inline)) void write_scr_el3(uint64_t val) { ({ __asm__ volatile ("msr " "s=
cr_el3" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__(=
(always_inline)) void zero_scr_el3(void) { ({ __asm__ volatile ("msr " "scr=
_el3" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_tpidrro_el0(void=
) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "tpidrro_el0" =
: "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__=
((always_inline)) void write_tpidrro_el0(uint64_t val) { ({ __asm__ volatil=
e ("msr " "tpidrro_el0" ", %0" :: "r" (val) : "memory"); }); } static inlin=
e __attribute__((always_inline)) void zero_tpidrro_el0(void) { ({ __asm__ v=
olatile ("msr " "tpidrro_el0" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_vmpidr_el2(void)=
 { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "vmpidr_el2" : =
"=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((=
always_inline)) void write_vmpidr_el2(uint64_t val) { ({ __asm__ volatile (=
"msr " "vmpidr_el2" ", %0" :: "r" (val) : "memory"); }); } static inline __=
attribute__((always_inline)) void zero_vmpidr_el2(void) { ({ __asm__ volati=
le ("msr " "vmpidr_el2" ", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_sp_el0(void) { r=
eturn ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "sp_el0" : "=3Dr" (=
reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always_i=
nline)) void write_sp_el0(uint64_t val) { ({ __asm__ volatile ("msr " "sp_e=
l0" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__((alw=
ays_inline)) void zero_sp_el0(void) { ({ __asm__ volatile ("msr " "sp_el0" =
", xzr" ::: "memory"); }); };
static inline __attribute__((always_inline)) uint64_t read_actlr_el1(void) =
{ return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "actlr_el1" : "=
=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((a=
lways_inline)) void write_actlr_el1(uint64_t val) { ({ __asm__ volatile ("m=
sr " "actlr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __att=
ribute__((always_inline)) void zero_actlr_el1(void) { ({ __asm__ volatile (=
"msr " "actlr_el1" ", xzr" ::: "memory"); }); } static inline __attribute__=
((always_inline)) uint64_t read_actlr_el2(void) { return ({ uint64_t reg_va=
l; __asm__ volatile ("mrs %0, " "actlr_el2" : "=3Dr" (reg_val) :: "memory")=
; reg_val; }); } static inline __attribute__((always_inline)) void write_ac=
tlr_el2(uint64_t val) { ({ __asm__ volatile ("msr " "actlr_el2" ", %0" :: "=
r" (val) : "memory"); }); } static inline __attribute__((always_inline)) vo=
id zero_actlr_el2(void) { ({ __asm__ volatile ("msr " "actlr_el2" ", xzr" :=
:: "memory"); }); } static inline __attribute__((always_inline)) uint64_t r=
ead_actlr_el3(void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0=
, " "actlr_el3" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inli=
ne __attribute__((always_inline)) void write_actlr_el3(uint64_t val) { ({ _=
_asm__ volatile ("msr " "actlr_el3" ", %0" :: "r" (val) : "memory"); }); } =
static inline __attribute__((always_inline)) void zero_actlr_el3(void) { ({=
 __asm__ volatile ("msr " "actlr_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_cpacr_el1(void) =
{ return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cpacr_el1" : "=
=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((a=
lways_inline)) void write_cpacr_el1(uint64_t val) { ({ __asm__ volatile ("m=
sr " "cpacr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __att=
ribute__((always_inline)) void zero_cpacr_el1(void) { ({ __asm__ volatile (=
"msr " "cpacr_el1" ", xzr" ::: "memory"); }); } static inline __attribute__=
((always_inline)) uint64_t read_cpacr_el2(void) { return ({ uint64_t reg_va=
l; __asm__ volatile ("mrs %0, " "cpacr_el2" : "=3Dr" (reg_val) :: "memory")=
; reg_val; }); } static inline __attribute__((always_inline)) void write_cp=
acr_el2(uint64_t val) { ({ __asm__ volatile ("msr " "cpacr_el2" ", %0" :: "=
r" (val) : "memory"); }); } static inline __attribute__((always_inline)) vo=
id zero_cpacr_el2(void) { ({ __asm__ volatile ("msr " "cpacr_el2" ", xzr" :=
:: "memory"); }); } static inline __attribute__((always_inline)) uint64_t r=
ead_cpacr_el3(void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0=
, " "cpacr_el3" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inli=
ne __attribute__((always_inline)) void write_cpacr_el3(uint64_t val) { ({ _=
_asm__ volatile ("msr " "cpacr_el3" ", %0" :: "r" (val) : "memory"); }); } =
static inline __attribute__((always_inline)) void zero_cpacr_el3(void) { ({=
 __asm__ volatile ("msr " "cpacr_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_cptr_el1(void) {=
 return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cptr_el1" : "=3D=
r" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((alwa=
ys_inline)) void write_cptr_el1(uint64_t val) { ({ __asm__ volatile ("msr "=
 "cptr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribut=
e__((always_inline)) void zero_cptr_el1(void) { ({ __asm__ volatile ("msr "=
 "cptr_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((alway=
s_inline)) uint64_t read_cptr_el2(void) { return ({ uint64_t reg_val; __asm=
__ volatile ("mrs %0, " "cptr_el2" : "=3Dr" (reg_val) :: "memory"); reg_val=
; }); } static inline __attribute__((always_inline)) void write_cptr_el2(ui=
nt64_t val) { ({ __asm__ volatile ("msr " "cptr_el2" ", %0" :: "r" (val) : =
"memory"); }); } static inline __attribute__((always_inline)) void zero_cpt=
r_el2(void) { ({ __asm__ volatile ("msr " "cptr_el2" ", xzr" ::: "memory");=
 }); } static inline __attribute__((always_inline)) uint64_t read_cptr_el3(=
void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "cptr_el3"=
 : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute_=
_((always_inline)) void write_cptr_el3(uint64_t val) { ({ __asm__ volatile =
("msr " "cptr_el3" ", %0" :: "r" (val) : "memory"); }); } static inline __a=
ttribute__((always_inline)) void zero_cptr_el3(void) { ({ __asm__ volatile =
("msr " "cptr_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_elr_el1(void) { =
return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "elr_el1" : "=3Dr"=
 (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always=
_inline)) void write_elr_el1(uint64_t val) { ({ __asm__ volatile ("msr " "e=
lr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__(=
(always_inline)) void zero_elr_el1(void) { ({ __asm__ volatile ("msr " "elr=
_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((always_inli=
ne)) uint64_t read_elr_el2(void) { return ({ uint64_t reg_val; __asm__ vola=
tile ("mrs %0, " "elr_el2" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } =
static inline __attribute__((always_inline)) void write_elr_el2(uint64_t va=
l) { ({ __asm__ volatile ("msr " "elr_el2" ", %0" :: "r" (val) : "memory");=
 }); } static inline __attribute__((always_inline)) void zero_elr_el2(void)=
 { ({ __asm__ volatile ("msr " "elr_el2" ", xzr" ::: "memory"); }); } stati=
c inline __attribute__((always_inline)) uint64_t read_elr_el3(void) { retur=
n ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "elr_el3" : "=3Dr" (reg=
_val) :: "memory"); reg_val; }); } static inline __attribute__((always_inli=
ne)) void write_elr_el3(uint64_t val) { ({ __asm__ volatile ("msr " "elr_el=
3" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__((alwa=
ys_inline)) void zero_elr_el3(void) { ({ __asm__ volatile ("msr " "elr_el3"=
 ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_esr_el1(void) { =
return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "esr_el1" : "=3Dr"=
 (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always=
_inline)) void write_esr_el1(uint64_t val) { ({ __asm__ volatile ("msr " "e=
sr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__(=
(always_inline)) void zero_esr_el1(void) { ({ __asm__ volatile ("msr " "esr=
_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((always_inli=
ne)) uint64_t read_esr_el2(void) { return ({ uint64_t reg_val; __asm__ vola=
tile ("mrs %0, " "esr_el2" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } =
static inline __attribute__((always_inline)) void write_esr_el2(uint64_t va=
l) { ({ __asm__ volatile ("msr " "esr_el2" ", %0" :: "r" (val) : "memory");=
 }); } static inline __attribute__((always_inline)) void zero_esr_el2(void)=
 { ({ __asm__ volatile ("msr " "esr_el2" ", xzr" ::: "memory"); }); } stati=
c inline __attribute__((always_inline)) uint64_t read_esr_el3(void) { retur=
n ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "esr_el3" : "=3Dr" (reg=
_val) :: "memory"); reg_val; }); } static inline __attribute__((always_inli=
ne)) void write_esr_el3(uint64_t val) { ({ __asm__ volatile ("msr " "esr_el=
3" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__((alwa=
ys_inline)) void zero_esr_el3(void) { ({ __asm__ volatile ("msr " "esr_el3"=
 ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_far_el1(void) { =
return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "far_el1" : "=3Dr"=
 (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always=
_inline)) void write_far_el1(uint64_t val) { ({ __asm__ volatile ("msr " "f=
ar_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__(=
(always_inline)) void zero_far_el1(void) { ({ __asm__ volatile ("msr " "far=
_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((always_inli=
ne)) uint64_t read_far_el2(void) { return ({ uint64_t reg_val; __asm__ vola=
tile ("mrs %0, " "far_el2" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } =
static inline __attribute__((always_inline)) void write_far_el2(uint64_t va=
l) { ({ __asm__ volatile ("msr " "far_el2" ", %0" :: "r" (val) : "memory");=
 }); } static inline __attribute__((always_inline)) void zero_far_el2(void)=
 { ({ __asm__ volatile ("msr " "far_el2" ", xzr" ::: "memory"); }); } stati=
c inline __attribute__((always_inline)) uint64_t read_far_el3(void) { retur=
n ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "far_el3" : "=3Dr" (reg=
_val) :: "memory"); reg_val; }); } static inline __attribute__((always_inli=
ne)) void write_far_el3(uint64_t val) { ({ __asm__ volatile ("msr " "far_el=
3" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__((alwa=
ys_inline)) void zero_far_el3(void) { ({ __asm__ volatile ("msr " "far_el3"=
 ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_mair_el1(void) {=
 return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "mair_el1" : "=3D=
r" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((alwa=
ys_inline)) void write_mair_el1(uint64_t val) { ({ __asm__ volatile ("msr "=
 "mair_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribut=
e__((always_inline)) void zero_mair_el1(void) { ({ __asm__ volatile ("msr "=
 "mair_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((alway=
s_inline)) uint64_t read_mair_el2(void) { return ({ uint64_t reg_val; __asm=
__ volatile ("mrs %0, " "mair_el2" : "=3Dr" (reg_val) :: "memory"); reg_val=
; }); } static inline __attribute__((always_inline)) void write_mair_el2(ui=
nt64_t val) { ({ __asm__ volatile ("msr " "mair_el2" ", %0" :: "r" (val) : =
"memory"); }); } static inline __attribute__((always_inline)) void zero_mai=
r_el2(void) { ({ __asm__ volatile ("msr " "mair_el2" ", xzr" ::: "memory");=
 }); } static inline __attribute__((always_inline)) uint64_t read_mair_el3(=
void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "mair_el3"=
 : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute_=
_((always_inline)) void write_mair_el3(uint64_t val) { ({ __asm__ volatile =
("msr " "mair_el3" ", %0" :: "r" (val) : "memory"); }); } static inline __a=
ttribute__((always_inline)) void zero_mair_el3(void) { ({ __asm__ volatile =
("msr " "mair_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_sctlr_el1(void) =
{ return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "sctlr_el1" : "=
=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((a=
lways_inline)) void write_sctlr_el1(uint64_t val) { ({ __asm__ volatile ("m=
sr " "sctlr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __att=
ribute__((always_inline)) void zero_sctlr_el1(void) { ({ __asm__ volatile (=
"msr " "sctlr_el1" ", xzr" ::: "memory"); }); } static inline __attribute__=
((always_inline)) uint64_t read_sctlr_el2(void) { return ({ uint64_t reg_va=
l; __asm__ volatile ("mrs %0, " "sctlr_el2" : "=3Dr" (reg_val) :: "memory")=
; reg_val; }); } static inline __attribute__((always_inline)) void write_sc=
tlr_el2(uint64_t val) { ({ __asm__ volatile ("msr " "sctlr_el2" ", %0" :: "=
r" (val) : "memory"); }); } static inline __attribute__((always_inline)) vo=
id zero_sctlr_el2(void) { ({ __asm__ volatile ("msr " "sctlr_el2" ", xzr" :=
:: "memory"); }); } static inline __attribute__((always_inline)) uint64_t r=
ead_sctlr_el3(void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0=
, " "sctlr_el3" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inli=
ne __attribute__((always_inline)) void write_sctlr_el3(uint64_t val) { ({ _=
_asm__ volatile ("msr " "sctlr_el3" ", %0" :: "r" (val) : "memory"); }); } =
static inline __attribute__((always_inline)) void zero_sctlr_el3(void) { ({=
 __asm__ volatile ("msr " "sctlr_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_spsr_el1(void) {=
 return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "spsr_el1" : "=3D=
r" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((alwa=
ys_inline)) void write_spsr_el1(uint64_t val) { ({ __asm__ volatile ("msr "=
 "spsr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribut=
e__((always_inline)) void zero_spsr_el1(void) { ({ __asm__ volatile ("msr "=
 "spsr_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((alway=
s_inline)) uint64_t read_spsr_el2(void) { return ({ uint64_t reg_val; __asm=
__ volatile ("mrs %0, " "spsr_el2" : "=3Dr" (reg_val) :: "memory"); reg_val=
; }); } static inline __attribute__((always_inline)) void write_spsr_el2(ui=
nt64_t val) { ({ __asm__ volatile ("msr " "spsr_el2" ", %0" :: "r" (val) : =
"memory"); }); } static inline __attribute__((always_inline)) void zero_sps=
r_el2(void) { ({ __asm__ volatile ("msr " "spsr_el2" ", xzr" ::: "memory");=
 }); } static inline __attribute__((always_inline)) uint64_t read_spsr_el3(=
void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "spsr_el3"=
 : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute_=
_((always_inline)) void write_spsr_el3(uint64_t val) { ({ __asm__ volatile =
("msr " "spsr_el3" ", %0" :: "r" (val) : "memory"); }); } static inline __a=
ttribute__((always_inline)) void zero_spsr_el3(void) { ({ __asm__ volatile =
("msr " "spsr_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_tcr_el1(void) { =
return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "tcr_el1" : "=3Dr"=
 (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((always=
_inline)) void write_tcr_el1(uint64_t val) { ({ __asm__ volatile ("msr " "t=
cr_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__(=
(always_inline)) void zero_tcr_el1(void) { ({ __asm__ volatile ("msr " "tcr=
_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((always_inli=
ne)) uint64_t read_tcr_el2(void) { return ({ uint64_t reg_val; __asm__ vola=
tile ("mrs %0, " "tcr_el2" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } =
static inline __attribute__((always_inline)) void write_tcr_el2(uint64_t va=
l) { ({ __asm__ volatile ("msr " "tcr_el2" ", %0" :: "r" (val) : "memory");=
 }); } static inline __attribute__((always_inline)) void zero_tcr_el2(void)=
 { ({ __asm__ volatile ("msr " "tcr_el2" ", xzr" ::: "memory"); }); } stati=
c inline __attribute__((always_inline)) uint64_t read_tcr_el3(void) { retur=
n ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "tcr_el3" : "=3Dr" (reg=
_val) :: "memory"); reg_val; }); } static inline __attribute__((always_inli=
ne)) void write_tcr_el3(uint64_t val) { ({ __asm__ volatile ("msr " "tcr_el=
3" ", %0" :: "r" (val) : "memory"); }); } static inline __attribute__((alwa=
ys_inline)) void zero_tcr_el3(void) { ({ __asm__ volatile ("msr " "tcr_el3"=
 ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_ttbr0_el1(void) =
{ return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "ttbr0_el1" : "=
=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((a=
lways_inline)) void write_ttbr0_el1(uint64_t val) { ({ __asm__ volatile ("m=
sr " "ttbr0_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __att=
ribute__((always_inline)) void zero_ttbr0_el1(void) { ({ __asm__ volatile (=
"msr " "ttbr0_el1" ", xzr" ::: "memory"); }); } static inline __attribute__=
((always_inline)) uint64_t read_ttbr0_el2(void) { return ({ uint64_t reg_va=
l; __asm__ volatile ("mrs %0, " "ttbr0_el2" : "=3Dr" (reg_val) :: "memory")=
; reg_val; }); } static inline __attribute__((always_inline)) void write_tt=
br0_el2(uint64_t val) { ({ __asm__ volatile ("msr " "ttbr0_el2" ", %0" :: "=
r" (val) : "memory"); }); } static inline __attribute__((always_inline)) vo=
id zero_ttbr0_el2(void) { ({ __asm__ volatile ("msr " "ttbr0_el2" ", xzr" :=
:: "memory"); }); } static inline __attribute__((always_inline)) uint64_t r=
ead_ttbr0_el3(void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0=
, " "ttbr0_el3" : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inli=
ne __attribute__((always_inline)) void write_ttbr0_el3(uint64_t val) { ({ _=
_asm__ volatile ("msr " "ttbr0_el3" ", %0" :: "r" (val) : "memory"); }); } =
static inline __attribute__((always_inline)) void zero_ttbr0_el3(void) { ({=
 __asm__ volatile ("msr " "ttbr0_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) uint64_t read_vbar_el1(void) {=
 return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "vbar_el1" : "=3D=
r" (reg_val) :: "memory"); reg_val; }); } static inline __attribute__((alwa=
ys_inline)) void write_vbar_el1(uint64_t val) { ({ __asm__ volatile ("msr "=
 "vbar_el1" ", %0" :: "r" (val) : "memory"); }); } static inline __attribut=
e__((always_inline)) void zero_vbar_el1(void) { ({ __asm__ volatile ("msr "=
 "vbar_el1" ", xzr" ::: "memory"); }); } static inline __attribute__((alway=
s_inline)) uint64_t read_vbar_el2(void) { return ({ uint64_t reg_val; __asm=
__ volatile ("mrs %0, " "vbar_el2" : "=3Dr" (reg_val) :: "memory"); reg_val=
; }); } static inline __attribute__((always_inline)) void write_vbar_el2(ui=
nt64_t val) { ({ __asm__ volatile ("msr " "vbar_el2" ", %0" :: "r" (val) : =
"memory"); }); } static inline __attribute__((always_inline)) void zero_vba=
r_el2(void) { ({ __asm__ volatile ("msr " "vbar_el2" ", xzr" ::: "memory");=
 }); } static inline __attribute__((always_inline)) uint64_t read_vbar_el3(=
void) { return ({ uint64_t reg_val; __asm__ volatile ("mrs %0, " "vbar_el3"=
 : "=3Dr" (reg_val) :: "memory"); reg_val; }); } static inline __attribute_=
_((always_inline)) void write_vbar_el3(uint64_t val) { ({ __asm__ volatile =
("msr " "vbar_el3" ", %0" :: "r" (val) : "memory"); }); } static inline __a=
ttribute__((always_inline)) void zero_vbar_el3(void) { ({ __asm__ volatile =
("msr " "vbar_el3" ", xzr" ::: "memory"); }); }
static inline __attribute__((always_inline)) void enable_debug_exceptions(v=
oid)
{
			__asm__ volatile ("msr DAIFClr, %0"
			:: "i" ((1UL << (3))) : "memory");
}
static inline __attribute__((always_inline)) void disable_debug_exceptions(=
void)
{
			__asm__ volatile ("msr DAIFSet, %0"
			:: "i" ((1UL << (3))) : "memory");
}
static inline __attribute__((always_inline)) void enable_serror_exceptions(=
void)
{
			__asm__ volatile ("msr DAIFClr, %0"
			:: "i" ((1UL << (2))) : "memory");
}
static inline __attribute__((always_inline)) void disable_serror_exceptions=
(void)
{
			__asm__ volatile ("msr DAIFSet, %0"
			:: "i" ((1UL << (2))) : "memory");
}
static inline __attribute__((always_inline)) void enable_irq(void)
{
			__asm__ volatile ("msr DAIFClr, %0"
			:: "i" ((1UL << (1))) : "memory");
}
static inline __attribute__((always_inline)) void disable_irq(void)
{
			__asm__ volatile ("msr DAIFSet, %0"
			:: "i" ((1UL << (1))) : "memory");
}
static inline __attribute__((always_inline)) void enable_fiq(void)
{
			__asm__ volatile ("msr DAIFClr, %0"
			:: "i" ((1UL << (0))) : "memory");
}
static inline __attribute__((always_inline)) void disable_fiq(void)
{
			__asm__ volatile ("msr DAIFSet, %0"
			:: "i" ((1UL << (0))) : "memory");
}
static inline _Bool is_el_implemented(unsigned int el)
{
			unsigned int shift;
			if (el > 3) {
			return 0;
			}
			shift =3D (4) * el;
			return (((read_id_aa64pfr0_el1() >> shift) & (0xf)) !=3D 0U);
}
static inline _Bool is_el_highest_implemented(void)
{
			uint32_t el_highest;
			uint32_t curr_el;
			el_highest =3D read_id_aa64pfr0_el1() & 0xFFFF;
			el_highest =3D (31U - __builtin_clz(el_highest)) / 4;
			curr_el =3D (((read_currentel()) >> (0x2)) & (0x3));
			if (curr_el < el_highest)
			return 0;
			return 1;
}
static inline _Bool is_el2_sec_supported(void)
{
			return (((read_id_aa64pfr0_el1() >> (36)) &
			(0xf)) !=3D 0U);
}
static inline _Bool is_in_secure_state(void)
{
			return !0;
}
static inline __attribute__((always_inline)) _cpu_t *arch_curr_cpu(void)
{
			return (_cpu_t *)(read_tpidrro_el0() & 0x0000fffffffffff8);
}
static inline __attribute__((always_inline)) int arch_exception_depth(void)
{
			return (read_tpidrro_el0() & 0xff00000000000000) / 0x0100000000000000;
}
static inline __attribute__((always_inline)) uint32_t arch_proc_id(void)
{
			uint64_t cpu_mpid =3D read_mpidr_el1();
			{ };
			return (uint32_t)cpu_mpid;
}
static inline __attribute__((always_inline)) unsigned int arch_num_cpus(voi=
d)
{
			return 1;
}
typedef struct
		{
			int quot;
			int rem;
		} div_t;
typedef struct
		{
			long int quot;
			long int rem;
		} ldiv_t; typedef struct
		{
			long long int quot;
			long long int rem;
		} lldiv_t;
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , _=
_leaf__)) __attribute__ ((__warn_unused_result__));
extern double atof (const char *__nptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int atoi (const char *__nptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern long int atol (const char *__nptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)); ext=
ern long long int atoll (const char *__nptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern double strtod (const char *__restrict __nptr,
			char **__restrict __endptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)=
));
extern float strtof (const char *__restrict __nptr,
			char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __a=
ttribute__ ((__nonnull__ (1)));
extern long double strtold (const char *__restrict __nptr,
			char **__restrict __endptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)=
));
extern long int strtol (const char *__restrict __nptr,
			char **__restrict __endptr, int __base)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)=
));
extern unsigned long int strtoul (const char *__restrict __nptr,
			char **__restrict __endptr, int __base)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)=
));
extern long long int strtoll (const char *__restrict __nptr,
			char **__restrict __endptr, int __base)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)=
));
extern unsigned long long int strtoull (const char *__restrict __nptr,
			char **__restrict __endptr, int __base)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)=
));
extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));
extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __lea=
f__));
extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __le=
af__));
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)=
) __attribute__ ((__malloc__))
			__attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_resul=
t__));
extern void *calloc (size_t __nmemb, size_t __size)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __=
attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result_=
_));
extern void *realloc (void *__ptr, size_t __size)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_r=
esult__)) __attribute__ ((__alloc_size__ (2)));
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __si=
ze)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)=
)) __attribute__ ((__warn_unused_result__));
extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribu=
te__ ((__noreturn__));
extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __l=
eaf__)) __attribute__ ((__nonnull__ (1)));
extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __=
attribute__ ((__noreturn__));
extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) _=
_attribute__ ((__noreturn__));
extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __le=
af__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_resu=
lt__));
extern int setenv (const char *__name, const char *__value, int __replace)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)=
));
extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __le=
af__)) __attribute__ ((__nonnull__ (1)));
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __a=
ttribute__ ((__warn_unused_result__));
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __lea=
f__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_resul=
t__));
extern int system (const char *__command) __attribute__ ((__warn_unused_res=
ult__));
typedef int (*__compar_fn_t) (const void *, const void *);
extern void *bsearch (const void *__key, const void *__base,
			size_t __nmemb, size_t __size, __compar_fn_t __compar)
			__attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_re=
sult__));
extern void qsort (void *__base, size_t __nmemb, size_t __size,
			__compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribu=
te__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)=
) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__)); ext=
ern long long int llabs (long long int __x)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __a=
ttribute__ ((__warn_unused_result__));
extern div_t div (int __numer, int __denom)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __a=
ttribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __a=
ttribute__ ((__warn_unused_result__)); extern lldiv_t lldiv (long long int =
__numer,
			long long int __denom)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __a=
ttribute__ ((__warn_unused_result__));
extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ =
, __leaf__));
extern int mbtowc (wchar_t *__restrict __pwc,
			const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __=
leaf__));
extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ =
, __leaf__));
extern size_t mbstowcs (wchar_t *__restrict __pwcs,
			const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __=
leaf__))
			__attribute__ ((__access__ (__read_only__, 2)));
extern size_t wcstombs (char *__restrict __s,
			const wchar_t *__restrict __pwcs, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__))
		__attribute__ ((__access__ (__write_only__, 1, 3)))
		__attribute__ ((__access__ (__read_only__, 2)));
extern int getsubopt (char **__restrict __optionp,
			char *const *__restrict __tokens,
			char **__restrict __valuep)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2, 3))) __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk (const char *__restrict __name,
			char *__restrict __resolved,
			size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribu=
te__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restr=
ict __resolved) __asm__ ("__USER_LABEL_PREFIX__" "realpath") __attribute__ =
((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__re=
strict __resolved, size_t __resolvedlen) __asm__ ("__USER_LABEL_PREFIX__" "=
__realpath_chk") __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((_=
_warn_unused_result__))
			__attribute__((__warning__ ("second argument of realpath must be either =
NULL or at " "least PATH_MAX bytes long buffer")));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict _=
_name, char *__restrict __resolved)
{
		size_t sz =3D __builtin_object_size (__resolved, 1 > 1);
		if (sz =3D=3D (size_t) -1)
			return __realpath_alias (__name, __resolved);
		if ((((__typeof (4096)) 0 < (__typeof (4096)) -1 || (__builtin_constant_p=
 (4096) && (4096) > 0)) && __builtin_constant_p ((((unsigned long) (4096)) =
<=3D (sz) / (sizeof (char)))) && !(((unsigned long) (4096)) <=3D (sz) / (si=
zeof (char)))))
			return __realpath_chk_warn (__name, __resolved, sz);
		return __realpath_chk (__name, __resolved, sz);
}
extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
			size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ (=
(__nonnull__ (2)))
			__attribute__ ((__access__ (__write_only__, 2, 3)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm=
__ ("__USER_LABEL_PREFIX__" "ptsname_r") __attribute__ ((__nothrow__ , __le=
af__))
			__attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_on=
ly__, 2, 3)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, si=
ze_t __nreal) __asm__ ("__USER_LABEL_PREFIX__" "__ptsname_r_chk") __attribu=
te__ ((__nothrow__ , __leaf__))
			__attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r=
 called with buflen bigger than " "size of buf")));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, =
size_t __buflen)
{
		return (((__builtin_constant_p (__builtin_object_size (__buf, 1 > 1)) && =
(__builtin_object_size (__buf, 1 > 1)) =3D=3D (unsigned long) -1) || (((__t=
ypeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__=
buflen) && (__buflen) > 0)) && __builtin_constant_p ((((unsigned long) (__b=
uflen)) <=3D ((__builtin_object_size (__buf, 1 > 1))) / ((sizeof (char)))))=
 && (((unsigned long) (__buflen)) <=3D ((__builtin_object_size (__buf, 1 > =
1))) / ((sizeof (char)))))) ? __ptsname_r_alias (__fd, __buf, __buflen) : (=
(((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant=
_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((unsigned long=
) (__buflen)) <=3D (__builtin_object_size (__buf, 1 > 1)) / (sizeof (char))=
)) && !(((unsigned long) (__buflen)) <=3D (__builtin_object_size (__buf, 1 =
> 1)) / (sizeof (char)))) ? __ptsname_r_chk_warn (__fd, __buf, __buflen, __=
builtin_object_size (__buf, 1 > 1)) : __ptsname_r_chk (__fd, __buf, __bufle=
n, __builtin_object_size (__buf, 1 > 1))));
}
extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
		__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_re=
sult__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("__USER_LAB=
EL_PREFIX__" "wctomb") __attribute__ ((__nothrow__ , __leaf__)) __attribute=
__ ((__warn_unused_result__));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar=
)
{
		if (__builtin_object_size (__s, 1 > 1) !=3D (size_t) -1
			&& 16 > __builtin_object_size (__s, 1 > 1))
			return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 1 > 1));
		return __wctomb_alias (__s, __wchar);
}
extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
			const char *__restrict __src,
			size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__))
			__attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__ac=
cess__ (__read_only__, 2)));
extern size_t __mbstowcs_nulldst (wchar_t *__restrict __dst, const char *__=
restrict __src, size_t __len) __asm__ ("__USER_LABEL_PREFIX__" "mbstowcs") =
__attribute__ ((__nothrow__ , __leaf__))
			__attribute__ ((__access__ (__read_only__, 2)));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__re=
strict __src, size_t __len) __asm__ ("__USER_LABEL_PREFIX__" "mbstowcs") __=
attribute__ ((__nothrow__ , __leaf__))
			__attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__ac=
cess__ (__read_only__, 2)));
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *_=
_restrict __src, size_t __len, size_t __dstlen) __asm__ ("__USER_LABEL_PREF=
IX__" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))
			__attribute__((__warning__ ("mbstowcs called with dst buffer smaller tha=
n len " "* sizeof (wchar_t)")));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __ds=
t, const char *__restrict __src, size_t __len)
{
		if (__builtin_constant_p (__dst =3D=3D ((void *)0)) && __dst =3D=3D ((voi=
d *)0))
			return __mbstowcs_nulldst (__dst, __src, __len);
		else
			return (((__builtin_constant_p (__builtin_object_size (__dst, 1 > 1)) &&=
 (__builtin_object_size (__dst, 1 > 1)) =3D=3D (unsigned long) -1) || (((__=
typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) =
&& (__len) > 0)) && __builtin_constant_p ((((unsigned long) (__len)) <=3D (=
(__builtin_object_size (__dst, 1 > 1))) / ((sizeof (wchar_t))))) && (((unsi=
gned long) (__len)) <=3D ((__builtin_object_size (__dst, 1 > 1))) / ((sizeo=
f (wchar_t)))))) ? __mbstowcs_alias (__dst, __src, __len) : ((((__typeof (_=
_len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len=
) > 0)) && __builtin_constant_p ((((unsigned long) (__len)) <=3D (__builtin=
_object_size (__dst, 1 > 1)) / (sizeof (wchar_t)))) && !(((unsigned long) (=
__len)) <=3D (__builtin_object_size (__dst, 1 > 1)) / (sizeof (wchar_t)))) =
? __mbstowcs_chk_warn (__dst, __src, __len, (__builtin_object_size (__dst, =
1 > 1)) / (sizeof (wchar_t))) : __mbstowcs_chk (__dst, __src, __len, (__bui=
ltin_object_size (__dst, 1 > 1)) / (sizeof (wchar_t)))));
}
extern size_t __wcstombs_chk (char *__restrict __dst,
			const wchar_t *__restrict __src,
			size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__))
		__attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__acc=
ess__ (__read_only__, 2)));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__re=
strict __src, size_t __len) __asm__ ("__USER_LABEL_PREFIX__" "wcstombs") __=
attribute__ ((__nothrow__ , __leaf__))
		__attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__acc=
ess__ (__read_only__, 2)));
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *_=
_restrict __src, size_t __len, size_t __dstlen) __asm__ ("__USER_LABEL_PREF=
IX__" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))
			__attribute__((__warning__ ("wcstombs called with dst buffer smaller tha=
n len")));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, =
const wchar_t *__restrict __src, size_t __len)
{
		return (((__builtin_constant_p (__builtin_object_size (__dst, 1 > 1)) && =
(__builtin_object_size (__dst, 1 > 1)) =3D=3D (unsigned long) -1) || (((__t=
ypeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) &=
& (__len) > 0)) && __builtin_constant_p ((((unsigned long) (__len)) <=3D ((=
__builtin_object_size (__dst, 1 > 1))) / ((sizeof (char))))) && (((unsigned=
 long) (__len)) <=3D ((__builtin_object_size (__dst, 1 > 1))) / ((sizeof (c=
har)))))) ? __wcstombs_alias (__dst, __src, __len) : ((((__typeof (__len)) =
0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0))=
 && __builtin_constant_p ((((unsigned long) (__len)) <=3D (__builtin_object=
_size (__dst, 1 > 1)) / (sizeof (char)))) && !(((unsigned long) (__len)) <=
=3D (__builtin_object_size (__dst, 1 > 1)) / (sizeof (char)))) ? __wcstombs=
_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 1 > 1)) : __w=
cstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 1 > 1))));
}
struct arm_mmu_region {
			uintptr_t base_pa;
			uintptr_t base_va;
			size_t size;
			const char *name;
			uint32_t attrs;
};
struct arm_mmu_config {
			unsigned int num_regions;
			const struct arm_mmu_region *mmu_regions;
};
struct arm_mmu_ptables {
			uint64_t *base_xlat_table;
			uint64_t ttbr0;
};
typedef struct { uint32_t attrs; } k_mem_partition_attr_t;
extern const struct arm_mmu_config mmu_config;
struct k_thread;
void z_arm64_thread_mem_domains_init(struct k_thread *thread);
void z_arm64_swap_mem_domains(struct k_thread *thread);
struct _callee_saved {
			uint64_t x19;
			uint64_t x20;
			uint64_t x21;
			uint64_t x22;
			uint64_t x23;
			uint64_t x24;
			uint64_t x25;
			uint64_t x26;
			uint64_t x27;
			uint64_t x28;
			uint64_t x29;
			uint64_t sp_el0;
			uint64_t sp_elx;
			uint64_t lr;
};
typedef struct _callee_saved _callee_saved_t;
struct z_arm64_fp_context {
			__int128 q0, q1, q2, q3, q4, q5, q6, q7;
			__int128 q8, q9, q10, q11, q12, q13, q14, q15;
			__int128 q16, q17, q18, q19, q20, q21, q22, q23;
			__int128 q24, q25, q26, q27, q28, q29, q30, q31;
			uint32_t fpsr, fpcr;
};
struct _thread_arch {
			struct z_arm64_fp_context saved_fp_context;
			uint8_t exception_depth;
};
typedef struct _thread_arch _thread_arch_t;
struct __esf {
			uint64_t x0;
			uint64_t x1;
			uint64_t x2;
			uint64_t x3;
			uint64_t x4;
			uint64_t x5;
			uint64_t x6;
			uint64_t x7;
			uint64_t x8;
			uint64_t x9;
			uint64_t x10;
			uint64_t x11;
			uint64_t x12;
			uint64_t x13;
			uint64_t x14;
			uint64_t x15;
			uint64_t x16;
			uint64_t x17;
			uint64_t x18;
			uint64_t lr;
			uint64_t spsr;
			uint64_t elr;
} __attribute__((__aligned__(16)));
typedef struct __esf z_arch_esf_t;
static inline int
irq_connect_dynamic(unsigned int irq, unsigned int priority,
			void (*routine)(const void *parameter),
			const void *parameter, uint32_t flags)
{
			return arch_irq_connect_dynamic(irq, priority, routine, parameter,
			flags);
}
static inline int
irq_disconnect_dynamic(unsigned int irq, unsigned int priority,
			void (*routine)(const void *parameter),
			const void *parameter, uint32_t flags)
{
			return arch_irq_disconnect_dynamic(irq, priority, routine,
			parameter, flags);
}
struct device;
union init_function {
			int (*sys)(void);
			int (*dev)(const struct device *dev);
};
struct init_entry {
			union init_function init_fn;
			union {
			const struct device *dev;
			};
};
_Bool sys_mm_is_phys_addr_in_range(uintptr_t phys);
_Bool sys_mm_is_virt_addr_in_range(void *virt);
static inline uintptr_t z_mem_phys_addr(void *virt)
{
			uintptr_t addr =3D (uintptr_t)virt;
			{ };
			return ((addr) - ((0x200000 + 0x0) - (0x200000 + 0x0)));
}
static inline void *z_mem_virt_addr(uintptr_t phys)
{
			{ };
			return (void *)((phys) + ((0x200000 + 0x0) - (0x200000 + 0x0)));
}
void z_phys_map(uint8_t **virt_ptr, uintptr_t phys, size_t size,
			uint32_t flags);
void z_phys_unmap(uint8_t *virt, size_t size);
size_t k_mem_free_get(void);
void *k_mem_map(size_t size, uint32_t flags);
void k_mem_unmap(void *addr, size_t size);
size_t k_mem_region_align(uintptr_t *aligned_addr, size_t *aligned_size,
			uintptr_t addr, size_t size, size_t align);
typedef uint32_t io_port_t;
typedef uintptr_t mm_reg_t;
typedef uintptr_t mem_addr_t;
struct z_device_mmio_rom {
			uintptr_t phys_addr;
			size_t size;
};
static inline void device_map(mm_reg_t *virt_addr, uintptr_t phys_addr,
			size_t size, uint32_t flags)
{
			z_phys_map((uint8_t **)virt_addr, phys_addr, size,
			flags | (1UL << (3)));
}
typedef int16_t device_handle_t;
struct device_state {
			uint8_t init_res;
			_Bool initialized : 1;
};
struct pm_device;
struct device {
			const char *name;
			const void *config;
			const void *api;
			struct device_state *state;
			void *data;
};
static inline device_handle_t device_handle_get(const struct device *dev)
{
			device_handle_t ret =3D 0;
			extern struct device _device_list_start[];
			if (dev !=3D ((void *)0)) {
			ret =3D 1 + (device_handle_t)(dev - _device_list_start);
			}
			return ret;
}
static inline const struct device *
device_from_handle(device_handle_t dev_handle)
{
			extern struct device _device_list_start[];
			const struct device *dev =3D ((void *)0);
			size_t numdev;
			do { extern struct device _device_list_start[]; extern struct device _de=
vice_list_end[]; *(&numdev) =3D ((uintptr_t)_device_list_end - (uintptr_t)_=
device_list_start) / sizeof(struct device); } while (0);;
			if ((dev_handle > 0) && ((size_t)dev_handle <=3D numdev)) {
			dev =3D &_device_list_start[dev_handle - 1];
			}
			return dev;
}
static inline const struct device *device_get_binding(const char *name);
size_t z_device_get_all_static(const struct device **devices);
_Bool z_device_is_ready(const struct device *dev);
static inline _Bool device_is_ready(const struct device *dev);
static inline _Bool z_impl_device_is_ready(const struct device *dev)
{
			return z_device_is_ready(dev);
}
extern const struct device __device_dts_ord_0; extern const struct device _=
_device_dts_ord_2; extern const struct device __device_dts_ord_1; extern co=
nst struct device __device_dts_ord_3; extern const struct device __device_d=
ts_ord_12; extern const struct device __device_dts_ord_4; extern const stru=
ct device __device_dts_ord_8; extern const struct device __device_dts_ord_9=
; extern const struct device __device_dts_ord_13; extern const struct devic=
e __device_dts_ord_6; extern const struct device __device_dts_ord_7; extern=
 const struct device __device_dts_ord_5; extern const struct device __devic=
e_dts_ord_10; extern const struct device __device_dts_ord_11;
extern const struct device * z_impl_device_get_binding(const char * name);
static inline const struct device * device_get_binding(const char * name)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_device_get_binding(name);
}
extern _Bool z_impl_device_is_ready(const struct device * dev);
static inline _Bool device_is_ready(const struct device * dev)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_device_is_ready(dev);
}
void _isr_wrapper(void);
void z_irq_spurious(const void *unused);
struct _isr_table_entry {
			const void *arg;
			void (*isr)(const void *);
};
extern struct _isr_table_entry _sw_isr_table[];
struct _irq_parent_entry {
			const struct device *dev;
			unsigned int irq;
			unsigned int offset;
};
struct _isr_list {
			int32_t irq;
			int32_t flags;
			void *func;
			const void *param;
};
extern void arch_irq_enable(unsigned int irq);
extern void arch_irq_disable(unsigned int irq);
extern int arch_irq_is_enabled(unsigned int irq);
extern void z_arm64_irq_priority_set(unsigned int irq, unsigned int prio,
			uint32_t flags);
extern void z_arm64_interrupt_init(void);
extern uint32_t sys_clock_cycle_get_32(void);
static inline uint32_t arch_k_cycle_get_32(void)
{
			return sys_clock_cycle_get_32();
}
extern uint64_t sys_clock_cycle_get_64(void);
static inline uint64_t arch_k_cycle_get_64(void)
{
			return sys_clock_cycle_get_64();
}
static inline __attribute__((always_inline)) void arch_nop(void)
{
			__asm__ volatile("nop");
}
static inline __attribute__((always_inline)) unsigned int arch_irq_lock(voi=
d)
{
			unsigned int key;
			key =3D read_daif();
			disable_irq();
			return key;
}
static inline __attribute__((always_inline)) void arch_irq_unlock(unsigned =
int key)
{
			write_daif(key);
}
static inline __attribute__((always_inline)) _Bool arch_irq_unlocked(unsign=
ed int key)
{
			return (key & (1UL << (7))) =3D=3D 0;
}
static inline __attribute__((always_inline)) void z_barrier_dmem_fence_full=
(void)
{
			__asm__ volatile ("dmb sy" ::: "memory");
}
static inline __attribute__((always_inline)) void z_barrier_dsync_fence_ful=
l(void)
{
			__asm__ volatile ("dsb sy" ::: "memory");
}
static inline __attribute__((always_inline)) void z_barrier_isync_fence_ful=
l(void)
{
			__asm__ volatile ("isb" ::: "memory");
}
static inline __attribute__((always_inline)) void barrier_dmem_fence_full(v=
oid)
{
			z_barrier_dmem_fence_full();
}
static inline __attribute__((always_inline)) void barrier_dsync_fence_full(=
void)
{
			z_barrier_dsync_fence_full();
}
static inline __attribute__((always_inline)) void barrier_isync_fence_full(=
void)
{
			z_barrier_isync_fence_full();
}
static inline __attribute__((always_inline)) uint8_t sys_read8(mem_addr_t a=
ddr)
{
			uint8_t val;
			__asm__ volatile("ldrb %w0, [%1]" : "=3Dr" (val) : "r" (addr));
			barrier_dmem_fence_full();
			return val;
}
static inline __attribute__((always_inline)) void sys_write8(uint8_t data, =
mem_addr_t addr)
{
			barrier_dmem_fence_full();
			__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
}
static inline __attribute__((always_inline)) uint16_t sys_read16(mem_addr_t=
 addr)
{
			uint16_t val;
			__asm__ volatile("ldrh %w0, [%1]" : "=3Dr" (val) : "r" (addr));
			barrier_dmem_fence_full();
			return val;
}
static inline __attribute__((always_inline)) void sys_write16(uint16_t data=
, mem_addr_t addr)
{
			barrier_dmem_fence_full();
			__asm__ volatile("strh %w0, [%1]" : : "r" (data), "r" (addr));
}
static inline __attribute__((always_inline)) uint32_t sys_read32(mem_addr_t=
 addr)
{
			uint32_t val;
			__asm__ volatile("ldr %w0, [%1]" : "=3Dr" (val) : "r" (addr));
			barrier_dmem_fence_full();
			return val;
}
static inline __attribute__((always_inline)) void sys_write32(uint32_t data=
, mem_addr_t addr)
{
			barrier_dmem_fence_full();
			__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
}
static inline __attribute__((always_inline)) uint64_t sys_read64(mem_addr_t=
 addr)
{
			uint64_t val;
			__asm__ volatile("ldr %x0, [%1]" : "=3Dr" (val) : "r" (addr));
			barrier_dmem_fence_full();
			return val;
}
static inline __attribute__((always_inline)) void sys_write64(uint64_t data=
, mem_addr_t addr)
{
			barrier_dmem_fence_full();
			__asm__ volatile("str %x0, [%1]" : : "r" (data), "r" (addr));
}
static inline __attribute__((always_inline)) void arm_arch_timer_init(void)
{
			extern int z_clock_hw_cycles_per_sec;
			uint64_t cntfrq_el0 =3D read_cntfrq_el0();
			{ };
			z_clock_hw_cycles_per_sec =3D (int) cntfrq_el0;
}
static inline __attribute__((always_inline)) void arm_arch_timer_set_compar=
e(uint64_t val)
{
			write_cntv_cval_el0(val);
}
static inline __attribute__((always_inline)) void arm_arch_timer_enable(uns=
igned char enable)
{
			uint64_t cntv_ctl;
			cntv_ctl =3D read_cntv_ctl_el0();
			if (enable) {
			cntv_ctl |=3D (1UL << (0));
			} else {
			cntv_ctl &=3D ~(1UL << (0));
			}
			write_cntv_ctl_el0(cntv_ctl);
}
static inline __attribute__((always_inline)) void arm_arch_timer_set_irq_ma=
sk(_Bool mask)
{
			uint64_t cntv_ctl;
			cntv_ctl =3D read_cntv_ctl_el0();
			if (mask) {
			cntv_ctl |=3D (1UL << (1));
			} else {
			cntv_ctl &=3D ~(1UL << (1));
			}
			write_cntv_ctl_el0(cntv_ctl);
}
static inline __attribute__((always_inline)) uint64_t arm_arch_timer_count(=
void)
{
			return read_cntvct_el0();
}
struct z_arm64_thread_stack_header {
			char privilege_stack[4096];
} __attribute__((__packed__)) __attribute__((__aligned__(16)));
typedef uintptr_t paddr_t;
typedef void *vaddr_t;
static inline __attribute__((always_inline)) void sys_set_bit(mem_addr_t ad=
dr, unsigned int bit)
{
			uint32_t temp =3D *(volatile uint32_t *)addr;
			*(volatile uint32_t *)addr =3D temp | (1 << bit);
}
static inline __attribute__((always_inline)) void sys_clear_bit(mem_addr_t =
addr, unsigned int bit)
{
			uint32_t temp =3D *(volatile uint32_t *)addr;
			*(volatile uint32_t *)addr =3D temp & ~(1 << bit);
}
static inline __attribute__((always_inline)) int sys_test_bit(mem_addr_t ad=
dr, unsigned int bit)
{
			uint32_t temp =3D *(volatile uint32_t *)addr;
			return temp & (1 << bit);
}
static inline __attribute__((always_inline)) void sys_set_bits(mem_addr_t a=
ddr, unsigned int mask)
{
			uint32_t temp =3D *(volatile uint32_t *)addr;
			*(volatile uint32_t *)addr =3D temp | mask;
}
static inline __attribute__((always_inline)) void sys_clear_bits(mem_addr_t=
 addr, unsigned int mask)
{
			uint32_t temp =3D *(volatile uint32_t *)addr;
			*(volatile uint32_t *)addr =3D temp & ~mask;
}
static inline __attribute__((always_inline))
			void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
			sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
}
static inline __attribute__((always_inline))
			void sys_bitfield_clear_bit(mem_addr_t addr, unsigned int bit)
{
			sys_clear_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
}
static inline __attribute__((always_inline))
			int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
			return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
}
static inline __attribute__((always_inline))
			int sys_test_and_set_bit(mem_addr_t addr, unsigned int bit)
{
			int ret;
			ret =3D sys_test_bit(addr, bit);
			sys_set_bit(addr, bit);
			return ret;
}
static inline __attribute__((always_inline))
			int sys_test_and_clear_bit(mem_addr_t addr, unsigned int bit)
{
			int ret;
			ret =3D sys_test_bit(addr, bit);
			sys_clear_bit(addr, bit);
			return ret;
}
static inline __attribute__((always_inline))
			int sys_bitfield_test_and_set_bit(mem_addr_t addr, unsigned int bit)
{
			int ret;
			ret =3D sys_bitfield_test_bit(addr, bit);
			sys_bitfield_set_bit(addr, bit);
			return ret;
}
static inline __attribute__((always_inline))
			int sys_bitfield_test_and_clear_bit(mem_addr_t addr, unsigned int bit)
{
			int ret;
			ret =3D sys_bitfield_test_bit(addr, bit);
			sys_bitfield_clear_bit(addr, bit);
			return ret;
}
static inline __attribute__((always_inline)) unsigned int find_msb_set(uint=
32_t op)
{
			if (op =3D=3D 0) {
			return 0;
			}
			return 32 - __builtin_clz(op);
}
static inline __attribute__((always_inline)) unsigned int find_lsb_set(uint=
32_t op)
{
			return __builtin_ffs(op);
}
struct arch_mem_domain {
			struct arm_mmu_ptables ptables;
			sys_snode_t node;
};
typedef int64_t k_ticks_t;
typedef struct {
			k_ticks_t ticks;
} k_timeout_t;
uint32_t sys_clock_tick_get_32(void);
int64_t sys_clock_tick_get(void);
typedef struct { uint64_t tick; } k_timepoint_t;
k_timepoint_t sys_timepoint_calc(k_timeout_t timeout);
k_timeout_t sys_timepoint_timeout(k_timepoint_t timepoint);
__attribute__((deprecated))
static inline uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
			k_timepoint_t tp =3D sys_timepoint_calc(timeout);
			return tp.tick;
}
static inline int sys_timepoint_cmp(k_timepoint_t a, k_timepoint_t b)
{
			if (a.tick =3D=3D b.tick) {
			return 0;
			}
			return a.tick < b.tick ? -1 : 1;
}
static inline _Bool sys_timepoint_expired(k_timepoint_t timepoint)
{
			return ((sys_timepoint_timeout(timepoint)).ticks =3D=3D (((k_timeout_t) =
{0})).ticks);
}
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)=
) __attribute__ ((__const__));
struct z_spinlock_key {
			int key;
};
struct k_spinlock {
};
typedef struct z_spinlock_key k_spinlock_key_t;
static inline __attribute__((always_inline)) void z_spinlock_validate_pre(s=
truct k_spinlock *l)
{
			(void)(l);
}
static inline __attribute__((always_inline)) void z_spinlock_validate_post(=
struct k_spinlock *l)
{
			(void)(l);
}
static inline __attribute__((always_inline)) k_spinlock_key_t k_spin_lock(s=
truct k_spinlock *l)
{
			(void)(l);
			k_spinlock_key_t k;
			k.key =3D arch_irq_lock();
			z_spinlock_validate_pre(l);
			z_spinlock_validate_post(l);
			return k;
}
static inline __attribute__((always_inline)) int k_spin_trylock(struct k_sp=
inlock *l, k_spinlock_key_t *k)
{
			int key =3D arch_irq_lock();
			z_spinlock_validate_pre(l);
			z_spinlock_validate_post(l);
			k->key =3D key;
			return 0;
}
static inline __attribute__((always_inline)) void k_spin_unlock(struct k_sp=
inlock *l,
			k_spinlock_key_t key)
{
			(void)(l);
			arch_irq_unlock(key.key);
}
static inline __attribute__((always_inline)) void k_spin_release(struct k_s=
pinlock *l)
{
			(void)(l);
}
enum k_fatal_error_reason {
			K_ERR_CPU_EXCEPTION,
			K_ERR_SPURIOUS_IRQ,
			K_ERR_STACK_CHK_FAIL,
			K_ERR_KERNEL_OOPS,
			K_ERR_KERNEL_PANIC,
			K_ERR_ARCH_START =3D 16
};
__attribute__((__noreturn__)) void k_fatal_halt(unsigned int reason);
void k_sys_fatal_error_handler(unsigned int reason, const z_arch_esf_t *esf=
);
void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf);
struct __attribute__((__packed__)) z_thread_stack_element {
			char data;
};
static inline char *z_stack_ptr_align(char *ptr)
{
			return (char *)(((unsigned long)(ptr) / (unsigned long)(16)) * (unsigned=
 long)(16));
}
static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
			return (char *)sym + ((size_t)0);
}
struct k_thread;
struct _pipe_desc {
			sys_dnode_t node;
			unsigned char *buffer;
			size_t bytes_to_xfer;
			struct k_thread *thread;
};
struct _thread_base {
			union {
			sys_dnode_t qnode_dlist;
			struct rbnode qnode_rb;
			};
			_wait_q_t *pended_on;
			uint8_t user_options;
			uint8_t thread_state;
			union {
			struct {
			int8_t prio;
			uint8_t sched_locked;
			};
			uint16_t preempt;
			};
			uint32_t order_key;
			void *swap_data;
			struct _timeout timeout;
};
typedef struct _thread_base _thread_base_t;
typedef struct k_thread_runtime_stats {
} k_thread_runtime_stats_t;
struct z_poller {
			_Bool is_polling;
			uint8_t mode;
};
struct k_thread {
			struct _thread_base base;
			struct _callee_saved callee_saved;
			void *init_data;
			_wait_q_t join_queue;
			int swap_retval;
			void *switch_handle;
			struct k_heap *resource_pool;
			uintptr_t tls;
			struct _thread_arch arch;
};
typedef struct k_thread _thread_t;
typedef struct k_thread *k_tid_t;
struct k_mem_domain;
struct k_mem_partition;
extern int k_mem_domain_init(struct k_mem_domain *domain, uint8_t num_parts=
,
			struct k_mem_partition *parts[]);
extern int k_mem_domain_add_partition(struct k_mem_domain *domain,
			struct k_mem_partition *part);
extern int k_mem_domain_remove_partition(struct k_mem_domain *domain,
			struct k_mem_partition *part);
extern int k_mem_domain_add_thread(struct k_mem_domain *domain,
			k_tid_t thread);
static inline void k_object_init(const void *obj)
{
			(void)(obj);
}
static inline struct k_object *k_object_create_dynamic_aligned(size_t align=
,
			size_t size)
{
			(void)(align);
			(void)(size);
			return ((void *)0);
}
static inline struct k_object *k_object_create_dynamic(size_t size)
{
			(void)(size);
			return ((void *)0);
}
struct k_thread;
struct k_mutex;
struct z_futex_data;
enum k_objects {
			K_OBJ_ANY,
K_OBJ_MEM_SLAB,
K_OBJ_MSGQ,
K_OBJ_MUTEX,
K_OBJ_PIPE,
K_OBJ_QUEUE,
K_OBJ_POLL_SIGNAL,
K_OBJ_SEM,
K_OBJ_STACK,
K_OBJ_THREAD,
K_OBJ_TIMER,
K_OBJ_THREAD_STACK_ELEMENT,
K_OBJ_NET_SOCKET,
K_OBJ_NET_IF,
K_OBJ_SYS_MUTEX,
K_OBJ_FUTEX,
K_OBJ_CONDVAR,
K_OBJ_DRIVER_UART,
K_OBJ_DRIVER_CRYPTO,
K_OBJ_DRIVER_ADC,
K_OBJ_DRIVER_AUXDISPLAY,
K_OBJ_DRIVER_BBRAM,
K_OBJ_DRIVER_CAN,
K_OBJ_DRIVER_CHARGER,
K_OBJ_DRIVER_COREDUMP,
K_OBJ_DRIVER_COUNTER,
K_OBJ_DRIVER_DAC,
K_OBJ_DRIVER_DAI,
K_OBJ_DRIVER_DMA,
K_OBJ_DRIVER_EDAC,
K_OBJ_DRIVER_EEPROM,
K_OBJ_DRIVER_FUEL_GAUGE_EMUL,
K_OBJ_DRIVER_EMUL_SENSOR_BACKEND_API,
K_OBJ_DRIVER_ENTROPY,
K_OBJ_DRIVER_ESPI,
K_OBJ_DRIVER_ESPI_SAF,
K_OBJ_DRIVER_FLASH,
K_OBJ_DRIVER_FPGA,
K_OBJ_DRIVER_FUEL_GAUGE,
K_OBJ_DRIVER_GNSS,
K_OBJ_DRIVER_GPIO,
K_OBJ_DRIVER_HWSPINLOCK,
K_OBJ_DRIVER_I2C,
K_OBJ_DRIVER_I2S,
K_OBJ_DRIVER_I3C,
K_OBJ_DRIVER_IPM,
K_OBJ_DRIVER_KSCAN,
K_OBJ_DRIVER_LED,
K_OBJ_DRIVER_MBOX,
K_OBJ_DRIVER_MDIO,
K_OBJ_DRIVER_MIPI_DSI,
K_OBJ_DRIVER_PECI,
K_OBJ_DRIVER_PS2,
K_OBJ_DRIVER_PTP_CLOCK,
K_OBJ_DRIVER_PWM,
K_OBJ_DRIVER_REGULATOR_PARENT,
K_OBJ_DRIVER_REGULATOR,
K_OBJ_DRIVER_RESET,
K_OBJ_DRIVER_RETAINED_MEM,
K_OBJ_DRIVER_RTC,
K_OBJ_DRIVER_SDHC,
K_OBJ_DRIVER_SENSOR,
K_OBJ_DRIVER_SMBUS,
K_OBJ_DRIVER_SPI,
K_OBJ_DRIVER_SYSCON,
K_OBJ_DRIVER_W1,
K_OBJ_DRIVER_WDT,
K_OBJ_DRIVER_CAN_TRANSCEIVER,
K_OBJ_DRIVER_UART_MUX,
K_OBJ_DRIVER_ITS,
K_OBJ_DRIVER_TGPIO,
K_OBJ_DRIVER_PCIE_CTRL,
K_OBJ_DRIVER_SVC,
K_OBJ_DRIVER_BC12_EMUL,
K_OBJ_DRIVER_BC12,
K_OBJ_DRIVER_TCPC,
K_OBJ_DRIVER_IVSHMEM,
K_OBJ_DRIVER_EC_HOST_CMD_BACKEND_API,
K_OBJ_DRIVER_ETHPHY,
			K_OBJ_LAST
};
static inline void z_impl_k_object_access_grant(const void *object,
			struct k_thread *thread)
{
			(void)(object);
			(void)(thread);
}
static inline void k_object_access_revoke(const void *object,
			struct k_thread *thread)
{
			(void)(object);
			(void)(thread);
}
static inline void z_impl_k_object_release(const void *object)
{
			(void)(object);
}
static inline void k_object_access_all_grant(const void *object)
{
			(void)(object);
}
static inline _Bool k_object_is_valid(const void *obj, enum k_objects otype=
)
{
			(void)(obj);
			(void)(otype);
			return 1;
}
static inline void *z_impl_k_object_alloc(enum k_objects otype)
{
			(void)(otype);
			return ((void *)0);
}
static inline void *z_impl_k_object_alloc_size(enum k_objects otype,
			size_t size)
{
			(void)(otype);
			(void)(size);
			return ((void *)0);
}
static inline void k_object_free(void *obj)
{
			(void)(obj);
}
extern void z_impl_k_object_access_grant(const void * object, struct k_thre=
ad * thread);
static inline void k_object_access_grant(const void * object, struct k_thre=
ad * thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_object_access_grant(object, thread);
}
extern void z_impl_k_object_release(const void * object);
static inline void k_object_release(const void * object)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_object_release(object);
}
extern void * z_impl_k_object_alloc(enum k_objects otype);
static inline void * k_object_alloc(enum k_objects otype)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_object_alloc(otype);
}
extern void * z_impl_k_object_alloc_size(enum k_objects otype, size_t size)=
;
static inline void * k_object_alloc_size(enum k_objects otype, size_t size)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_object_alloc_size(otype, size);
}
struct k_thread;
void z_init_cpu(int id);
void z_sched_ipi(void);
void z_smp_start_cpu(int id);
extern int (*__Static_assert_function (void)) [!!sizeof (struct { int __err=
or_if_negative: (sizeof(int32_t) =3D=3D sizeof(int)) ? 2 : -1; })];
extern int (*__Static_assert_function (void)) [!!sizeof (struct { int __err=
or_if_negative: (sizeof(int64_t) =3D=3D sizeof(long long)) ? 2 : -1; })];
extern int (*__Static_assert_function (void)) [!!sizeof (struct { int __err=
or_if_negative: (sizeof(intptr_t) =3D=3D sizeof(long)) ? 2 : -1; })];
struct k_thread;
struct k_mutex;
struct k_sem;
struct k_msgq;
struct k_mbox;
struct k_pipe;
struct k_queue;
struct k_fifo;
struct k_lifo;
struct k_stack;
struct k_mem_slab;
struct k_timer;
struct k_poll_event;
struct k_poll_signal;
struct k_mem_domain;
struct k_mem_partition;
struct k_futex;
struct k_event;
enum execution_context_types {
			K_ISR =3D 0,
			K_COOP_THREAD,
			K_PREEMPT_THREAD,
};
struct k_work_poll;
typedef int (*_poller_cb_t)(struct k_poll_event *event, uint32_t state);
typedef void (*k_thread_user_cb_t)(const struct k_thread *thread,
			void *user_data);
void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data);
void k_thread_foreach_unlocked(
			k_thread_user_cb_t user_cb, void *user_data);
static inline k_thread_stack_t *k_thread_stack_alloc(size_t size, int flags=
);
static inline int k_thread_stack_free(k_thread_stack_t *stack);
static inline k_tid_t k_thread_create(struct k_thread *new_thread,
			k_thread_stack_t *stack,
			size_t stack_size,
			k_thread_entry_t entry,
			void *p1, void *p2, void *p3,
			int prio, uint32_t options, k_timeout_t delay);
__attribute__((__noreturn__)) void k_thread_user_mode_enter(k_thread_entry_=
t entry,
			void *p1, void *p2,
			void *p3);
static inline void k_thread_heap_assign(struct k_thread *thread,
			struct k_heap *heap)
{
			thread->resource_pool =3D heap;
}
static inline int k_thread_join(struct k_thread *thread, k_timeout_t timeou=
t);
static inline int32_t k_sleep(k_timeout_t timeout);
static inline int32_t k_msleep(int32_t ms)
{
			return k_sleep(((k_timeout_t) { .ticks =3D ((k_ticks_t)((1) ? ( ((10000)=
 =3D=3D (1000)) ? (uint64_t) ((((ms) > (0)) ? (ms) : (0))) : ((1000) > (100=
00) && (1000) % (10000) =3D=3D 0U) ? (((uint64_t) ((((ms) > (0)) ? (ms) : (=
0))) + ((0) ? ((1000) / (10000)) / 2 : (1) ? ((1000) / (10000)) - 1 : 0)) /=
 ((1000)/(10000) ? (1000)/(10000) : 01u)) : ((10000) > (1000) && (10000) % =
(1000) =3D=3D 0U) ? (uint64_t) ((((ms) > (0)) ? (ms) : (0)))*((10000) / (10=
00)) : ((((((365 * 24ULL * 3600ULL * 1000) + ((4294967295U)) - 1) / ((42949=
67295U))) * 10000) <=3D (4294967295U)) ? (((uint64_t) ((((ms) > (0)) ? (ms)=
 : (0)))*(10000) + ((0) ? (1000) / 2 : (1) ? (1000) - 1 : 0)) / (1000)) : (=
((uint64_t) ((((ms) > (0)) ? (ms) : (0))) / (1000))*(10000) + (((uint64_t) =
((((ms) > (0)) ? (ms) : (0))) % (1000))*(10000) + ((0) ? (1000) / 2 : (1) ?=
 (1000) - 1 : 0)) / (1000))) ) : (((uint64_t) ((((ms) > (0)) ? (ms) : (0)))=
 / (1000))*(10000) + (((uint64_t) ((((ms) > (0)) ? (ms) : (0))) % (1000))*(=
10000) + ((0) ? (1000) / 2 : (1) ? (1000) - 1 : 0)) / (1000)) )) }));
}
static inline int32_t k_usleep(int32_t us);
static inline void k_busy_wait(uint32_t usec_to_wait);
_Bool k_can_yield(void);
static inline void k_yield(void);
static inline void k_wakeup(k_tid_t thread);
__attribute__ ((__const__))
static inline k_tid_t k_sched_current_thread_query(void);
__attribute__ ((__const__))
static inline k_tid_t k_current_get(void)
{
			extern __thread k_tid_t z_tls_current;
			return z_tls_current;
}
static inline void k_thread_abort(k_tid_t thread);
static inline void k_thread_start(k_tid_t thread);
k_ticks_t z_timeout_expires(const struct _timeout *timeout);
k_ticks_t z_timeout_remaining(const struct _timeout *timeout);
static inline k_ticks_t k_thread_timeout_expires_ticks(const struct k_threa=
d *t);
static inline k_ticks_t z_impl_k_thread_timeout_expires_ticks(
			const struct k_thread *t)
{
			return z_timeout_expires(&t->base.timeout);
}
static inline k_ticks_t k_thread_timeout_remaining_ticks(const struct k_thr=
ead *t);
static inline k_ticks_t z_impl_k_thread_timeout_remaining_ticks(
			const struct k_thread *t)
{
			return z_timeout_remaining(&t->base.timeout);
}
struct _static_thread_data {
			struct k_thread *init_thread;
			k_thread_stack_t *init_stack;
			unsigned int init_stack_size;
			k_thread_entry_t init_entry;
			void *init_p1;
			void *init_p2;
			void *init_p3;
			int init_prio;
			uint32_t init_options;
			const char *init_name;
			int32_t init_delay_ms;
};
static inline int k_thread_priority_get(k_tid_t thread);
static inline void k_thread_priority_set(k_tid_t thread, int prio);
static inline void k_thread_suspend(k_tid_t thread);
static inline void k_thread_resume(k_tid_t thread);
void k_sched_time_slice_set(int32_t slice, int prio);
void k_thread_time_slice_set(struct k_thread *th, int32_t slice_ticks,
			k_thread_timeslice_fn_t expired, void *data);
_Bool k_is_in_isr(void);
static inline int k_is_preempt_thread(void);
static inline _Bool k_is_pre_kernel(void)
{
			extern _Bool z_sys_post_kernel;
			return !z_sys_post_kernel;
}
void k_sched_lock(void);
void k_sched_unlock(void);
static inline void k_thread_custom_data_set(void *value);
static inline void *k_thread_custom_data_get(void);
static inline int k_thread_name_set(k_tid_t thread, const char *str);
const char *k_thread_name_get(k_tid_t thread);
static inline int k_thread_name_copy(k_tid_t thread, char *buf,
			size_t size);
const char *k_thread_state_str(k_tid_t thread_id, char *buf, size_t buf_siz=
e);
struct k_timer {
			struct _timeout timeout;
			_wait_q_t wait_q;
			void (*expiry_fn)(struct k_timer *timer);
			void (*stop_fn)(struct k_timer *timer);
			k_timeout_t period;
			uint32_t status;
			void *user_data;
};
typedef void (*k_timer_expiry_t)(struct k_timer *timer);
typedef void (*k_timer_stop_t)(struct k_timer *timer);
void k_timer_init(struct k_timer *timer,
			k_timer_expiry_t expiry_fn,
			k_timer_stop_t stop_fn);
static inline void k_timer_start(struct k_timer *timer,
			k_timeout_t duration, k_timeout_t period);
static inline void k_timer_stop(struct k_timer *timer);
static inline uint32_t k_timer_status_get(struct k_timer *timer);
static inline uint32_t k_timer_status_sync(struct k_timer *timer);
static inline k_ticks_t k_timer_expires_ticks(const struct k_timer *timer);
static inline k_ticks_t z_impl_k_timer_expires_ticks(
			const struct k_timer *timer)
{
			return z_timeout_expires(&timer->timeout);
}
static inline k_ticks_t k_timer_remaining_ticks(const struct k_timer *timer=
);
static inline k_ticks_t z_impl_k_timer_remaining_ticks(
			const struct k_timer *timer)
{
			return z_timeout_remaining(&timer->timeout);
}
static inline uint32_t k_timer_remaining_get(struct k_timer *timer)
{
			return ((1) ? ( ((1000) =3D=3D (10000)) ? (uint32_t) (k_timer_remaining_=
ticks(timer)) : ((10000) > (1000) && (10000) % (1000) =3D=3D 0U) ? ((uint64=
_t) (k_timer_remaining_ticks(timer)) <=3D 0xffffffffU - ((0) ? ((10000) / (=
1000)) / 2 : (0) ? ((10000) / (1000)) - 1 : 0) ? ((uint32_t)((k_timer_remai=
ning_ticks(timer)) + ((0) ? ((10000) / (1000)) / 2 : (0) ? ((10000) / (1000=
)) - 1 : 0)) / ((10000)/(1000) ? (10000)/(1000) : 01u)) : (uint32_t) (((uin=
t64_t) (k_timer_remaining_ticks(timer)) + ((0) ? ((10000) / (1000)) / 2 : (=
0) ? ((10000) / (1000)) - 1 : 0)) / ((10000)/(1000) ? (10000)/(1000) : 01u)=
) ) : ((1000) > (10000) && (1000) % (10000) =3D=3D 0U) ? (uint32_t) (k_time=
r_remaining_ticks(timer))*((1000) / (10000)) : ((uint32_t) (((uint64_t) (k_=
timer_remaining_ticks(timer))*(1000) + ((0) ? (10000) / 2 : (0) ? (10000) -=
 1 : 0)) / (10000))) ) : ((uint32_t) (((uint64_t) (k_timer_remaining_ticks(=
timer))*(1000) + ((0) ? (10000) / 2 : (0) ? (10000) - 1 : 0)) / (10000))) )=
;
}
static inline void k_timer_user_data_set(struct k_timer *timer, void *user_=
data);
static inline void z_impl_k_timer_user_data_set(struct k_timer *timer,
			void *user_data)
{
			timer->user_data =3D user_data;
}
static inline void *k_timer_user_data_get(const struct k_timer *timer);
static inline void *z_impl_k_timer_user_data_get(const struct k_timer *time=
r)
{
			return timer->user_data;
}
static inline int64_t k_uptime_ticks(void);
static inline int64_t k_uptime_get(void)
{
			return ((1) ? ( ((1000) =3D=3D (10000)) ? (uint64_t) (k_uptime_ticks()) =
: ((10000) > (1000) && (10000) % (1000) =3D=3D 0U) ? (((uint64_t) (k_uptime=
_ticks()) + ((0) ? ((10000) / (1000)) / 2 : (0) ? ((10000) / (1000)) - 1 : =
0)) / ((10000)/(1000) ? (10000)/(1000) : 01u)) : ((1000) > (10000) && (1000=
) % (10000) =3D=3D 0U) ? (uint64_t) (k_uptime_ticks())*((1000) / (10000)) :=
 ((((((365 * 24ULL * 3600ULL * 10000) + ((4294967295U)) - 1) / ((4294967295=
U))) * 1000) <=3D (4294967295U)) ? (((uint64_t) (k_uptime_ticks())*(1000) +=
 ((0) ? (10000) / 2 : (0) ? (10000) - 1 : 0)) / (10000)) : (((uint64_t) (k_=
uptime_ticks()) / (10000))*(1000) + (((uint64_t) (k_uptime_ticks()) % (1000=
0))*(1000) + ((0) ? (10000) / 2 : (0) ? (10000) - 1 : 0)) / (10000))) ) : (=
((uint64_t) (k_uptime_ticks()) / (10000))*(1000) + (((uint64_t) (k_uptime_t=
icks()) % (10000))*(1000) + ((0) ? (10000) / 2 : (0) ? (10000) - 1 : 0)) / =
(10000)) );
}
static inline uint32_t k_uptime_get_32(void)
{
			return (uint32_t)k_uptime_get();
}
static inline int64_t k_uptime_delta(int64_t *reftime)
{
			int64_t uptime, delta;
			uptime =3D k_uptime_get();
			delta =3D uptime - *reftime;
			*reftime =3D uptime;
			return delta;
}
static inline uint32_t k_cycle_get_32(void)
{
			return arch_k_cycle_get_32();
}
static inline uint64_t k_cycle_get_64(void)
{
			if (!1) {
			{ };
			return 0;
			}
			return arch_k_cycle_get_64();
}
struct k_queue {
			sys_sflist_t data_q;
			struct k_spinlock lock;
			_wait_q_t wait_q;
};
static inline void k_queue_init(struct k_queue *queue);
static inline void k_queue_cancel_wait(struct k_queue *queue);
void k_queue_append(struct k_queue *queue, void *data);
static inline int32_t k_queue_alloc_append(struct k_queue *queue, void *dat=
a);
void k_queue_prepend(struct k_queue *queue, void *data);
static inline int32_t k_queue_alloc_prepend(struct k_queue *queue, void *da=
ta);
void k_queue_insert(struct k_queue *queue, void *prev, void *data);
int k_queue_append_list(struct k_queue *queue, void *head, void *tail);
int k_queue_merge_slist(struct k_queue *queue, sys_slist_t *list);
static inline void *k_queue_get(struct k_queue *queue, k_timeout_t timeout)=
;
_Bool k_queue_remove(struct k_queue *queue, void *data);
_Bool k_queue_unique_append(struct k_queue *queue, void *data);
static inline int k_queue_is_empty(struct k_queue *queue);
static inline int z_impl_k_queue_is_empty(struct k_queue *queue)
{
			return (int)sys_sflist_is_empty(&queue->data_q);
}
static inline void *k_queue_peek_head(struct k_queue *queue);
static inline void *k_queue_peek_tail(struct k_queue *queue);
struct k_event {
			_wait_q_t wait_q;
			uint32_t events;
			struct k_spinlock lock;
};
static inline void k_event_init(struct k_event *event);
static inline uint32_t k_event_post(struct k_event *event, uint32_t events)=
;
static inline uint32_t k_event_set(struct k_event *event, uint32_t events);
static inline uint32_t k_event_set_masked(struct k_event *event, uint32_t e=
vents,
			uint32_t events_mask);
static inline uint32_t k_event_clear(struct k_event *event, uint32_t events=
);
static inline uint32_t k_event_wait(struct k_event *event, uint32_t events,
			_Bool reset, k_timeout_t timeout);
static inline uint32_t k_event_wait_all(struct k_event *event, uint32_t eve=
nts,
			_Bool reset, k_timeout_t timeout);
static inline uint32_t k_event_test(struct k_event *event, uint32_t events_=
mask)
{
			return k_event_wait(event, events_mask, 0, ((k_timeout_t) {0}));
}
struct k_fifo {
			struct k_queue _queue;
};
struct k_lifo {
			struct k_queue _queue;
};
typedef uintptr_t stack_data_t;
struct k_stack {
			_wait_q_t wait_q;
			struct k_spinlock lock;
			stack_data_t *base, *next, *top;
			uint8_t flags;
};
void k_stack_init(struct k_stack *stack,
			stack_data_t *buffer, uint32_t num_entries);
static inline int32_t k_stack_alloc_init(struct k_stack *stack,
			uint32_t num_entries);
int k_stack_cleanup(struct k_stack *stack);
static inline int k_stack_push(struct k_stack *stack, stack_data_t data);
static inline int k_stack_pop(struct k_stack *stack, stack_data_t *data,
			k_timeout_t timeout);
struct k_work;
struct k_work_q;
struct k_work_queue_config;
extern struct k_work_q k_sys_work_q;
struct k_mutex {
			_wait_q_t wait_q;
			struct k_thread *owner;
			uint32_t lock_count;
			int owner_orig_prio;
};
static inline int k_mutex_init(struct k_mutex *mutex);
static inline int k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout);
static inline int k_mutex_unlock(struct k_mutex *mutex);
struct k_condvar {
			_wait_q_t wait_q;
};
static inline int k_condvar_init(struct k_condvar *condvar);
static inline int k_condvar_signal(struct k_condvar *condvar);
static inline int k_condvar_broadcast(struct k_condvar *condvar);
static inline int k_condvar_wait(struct k_condvar *condvar, struct k_mutex =
*mutex,
			k_timeout_t timeout);
struct k_sem {
			_wait_q_t wait_q;
			unsigned int count;
			unsigned int limit;
};
static inline int k_sem_init(struct k_sem *sem, unsigned int initial_count,
			unsigned int limit);
static inline int k_sem_take(struct k_sem *sem, k_timeout_t timeout);
static inline void k_sem_give(struct k_sem *sem);
static inline void k_sem_reset(struct k_sem *sem);
static inline unsigned int k_sem_count_get(struct k_sem *sem);
static inline unsigned int z_impl_k_sem_count_get(struct k_sem *sem)
{
			return sem->count;
}
struct k_work_delayable;
struct k_work_sync;
typedef void (*k_work_handler_t)(struct k_work *work);
void k_work_init(struct k_work *work,
			k_work_handler_t handler);
int k_work_busy_get(const struct k_work *work);
static inline _Bool k_work_is_pending(const struct k_work *work);
int k_work_submit_to_queue(struct k_work_q *queue,
			struct k_work *work);
int k_work_submit(struct k_work *work);
_Bool k_work_flush(struct k_work *work,
			struct k_work_sync *sync);
int k_work_cancel(struct k_work *work);
_Bool k_work_cancel_sync(struct k_work *work, struct k_work_sync *sync);
void k_work_queue_init(struct k_work_q *queue);
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack, size_t stack_size,
			int prio, const struct k_work_queue_config *cfg);
static inline k_tid_t k_work_queue_thread_get(struct k_work_q *queue);
int k_work_queue_drain(struct k_work_q *queue, _Bool plug);
int k_work_queue_unplug(struct k_work_q *queue);
void k_work_init_delayable(struct k_work_delayable *dwork,
			k_work_handler_t handler);
static inline struct k_work_delayable *
k_work_delayable_from_work(struct k_work *work);
int k_work_delayable_busy_get(const struct k_work_delayable *dwork);
static inline _Bool k_work_delayable_is_pending(
			const struct k_work_delayable *dwork);
static inline k_ticks_t k_work_delayable_expires_get(
			const struct k_work_delayable *dwork);
static inline k_ticks_t k_work_delayable_remaining_get(
			const struct k_work_delayable *dwork);
int k_work_schedule_for_queue(struct k_work_q *queue,
			struct k_work_delayable *dwork,
			k_timeout_t delay);
int k_work_schedule(struct k_work_delayable *dwork,
			k_timeout_t delay);
int k_work_reschedule_for_queue(struct k_work_q *queue,
			struct k_work_delayable *dwork,
			k_timeout_t delay);
int k_work_reschedule(struct k_work_delayable *dwork,
			k_timeout_t delay);
_Bool k_work_flush_delayable(struct k_work_delayable *dwork,
			struct k_work_sync *sync);
int k_work_cancel_delayable(struct k_work_delayable *dwork);
_Bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,
			struct k_work_sync *sync);
enum {
			K_WORK_RUNNING_BIT =3D 0,
			K_WORK_CANCELING_BIT =3D 1,
			K_WORK_QUEUED_BIT =3D 2,
			K_WORK_DELAYED_BIT =3D 3,
			K_WORK_MASK =3D (1UL << (K_WORK_DELAYED_BIT)) | (1UL << (K_WORK_QUEUED_B=
IT))
			| (1UL << (K_WORK_RUNNING_BIT)) | (1UL << (K_WORK_CANCELING_BIT)),
			K_WORK_DELAYABLE_BIT =3D 8,
			K_WORK_DELAYABLE =3D (1UL << (K_WORK_DELAYABLE_BIT)),
			K_WORK_QUEUE_STARTED_BIT =3D 0,
			K_WORK_QUEUE_STARTED =3D (1UL << (K_WORK_QUEUE_STARTED_BIT)),
			K_WORK_QUEUE_BUSY_BIT =3D 1,
			K_WORK_QUEUE_BUSY =3D (1UL << (K_WORK_QUEUE_BUSY_BIT)),
			K_WORK_QUEUE_DRAIN_BIT =3D 2,
			K_WORK_QUEUE_DRAIN =3D (1UL << (K_WORK_QUEUE_DRAIN_BIT)),
			K_WORK_QUEUE_PLUGGED_BIT =3D 3,
			K_WORK_QUEUE_PLUGGED =3D (1UL << (K_WORK_QUEUE_PLUGGED_BIT)),
			K_WORK_QUEUE_NO_YIELD_BIT =3D 8,
			K_WORK_QUEUE_NO_YIELD =3D (1UL << (K_WORK_QUEUE_NO_YIELD_BIT)),
			K_WORK_RUNNING =3D (1UL << (K_WORK_RUNNING_BIT)),
			K_WORK_CANCELING =3D (1UL << (K_WORK_CANCELING_BIT)),
			K_WORK_QUEUED =3D (1UL << (K_WORK_QUEUED_BIT)),
			K_WORK_DELAYED =3D (1UL << (K_WORK_DELAYED_BIT)),
};
struct k_work {
			sys_snode_t node;
			k_work_handler_t handler;
			struct k_work_q *queue;
			uint32_t flags;
};
struct k_work_delayable {
			struct k_work work;
			struct _timeout timeout;
			struct k_work_q *queue;
};
struct z_work_flusher {
			struct k_work work;
			struct k_sem sem;
};
struct z_work_canceller {
			sys_snode_t node;
			struct k_work *work;
			struct k_sem sem;
};
struct k_work_sync {
			union {
			struct z_work_flusher flusher;
			struct z_work_canceller canceller;
			};
};
struct k_work_queue_config {
			const char *name;
			_Bool no_yield;
};
struct k_work_q {
			struct k_thread thread;
			sys_slist_t pending;
			_wait_q_t notifyq;
			_wait_q_t drainq;
			uint32_t flags;
};
static inline _Bool k_work_is_pending(const struct k_work *work)
{
			return k_work_busy_get(work) !=3D 0;
}
static inline struct k_work_delayable *
k_work_delayable_from_work(struct k_work *work)
{
			return ({ extern int (*__Static_assert_function (void)) [!!sizeof (struc=
t { int __error_if_negative: (__builtin_types_compatible_p(__typeof__(*(wor=
k)), __typeof__(((struct k_work_delayable *)0)->work)) || __builtin_types_c=
ompatible_p(__typeof__(*(work)), __typeof__(void))) ? 2 : -1; })]; ((struct=
 k_work_delayable *)(((char *)(work)) - __builtin_offsetof (struct k_work_d=
elayable, work))); });
}
static inline _Bool k_work_delayable_is_pending(
			const struct k_work_delayable *dwork)
{
			return k_work_delayable_busy_get(dwork) !=3D 0;
}
static inline k_ticks_t k_work_delayable_expires_get(
			const struct k_work_delayable *dwork)
{
			return z_timeout_expires(&dwork->timeout);
}
static inline k_ticks_t k_work_delayable_remaining_get(
			const struct k_work_delayable *dwork)
{
			return z_timeout_remaining(&dwork->timeout);
}
static inline k_tid_t k_work_queue_thread_get(struct k_work_q *queue)
{
			return &queue->thread;
}
struct k_work_user;
typedef void (*k_work_user_handler_t)(struct k_work_user *work);
struct k_work_user_q {
			struct k_queue queue;
			struct k_thread thread;
};
enum {
			K_WORK_USER_STATE_PENDING,
};
struct k_work_user {
			void *_reserved;
			k_work_user_handler_t handler;
			atomic_t flags;
};
static inline void k_work_user_init(struct k_work_user *work,
			k_work_user_handler_t handler)
{
			*work =3D (struct k_work_user){ ._reserved =3D ((void *)0), .handler =3D=
 handler, .flags =3D 0 };
}
static inline _Bool k_work_user_is_pending(struct k_work_user *work)
{
			return atomic_test_bit(&work->flags, K_WORK_USER_STATE_PENDING);
}
static inline int k_work_user_submit_to_queue(struct k_work_user_q *work_q,
			struct k_work_user *work)
{
			int ret =3D -16;
			if (!atomic_test_and_set_bit(&work->flags,
			K_WORK_USER_STATE_PENDING)) {
			ret =3D k_queue_alloc_append(&work_q->queue, work);
			if (ret !=3D 0) {
			atomic_clear_bit(&work->flags,
			K_WORK_USER_STATE_PENDING);
			}
			}
			return ret;
}
void k_work_user_queue_start(struct k_work_user_q *work_q,
			k_thread_stack_t *stack,
			size_t stack_size, int prio,
			const char *name);
static inline k_tid_t k_work_user_queue_thread_get(struct k_work_user_q *wo=
rk_q)
{
			return &work_q->thread;
}
struct k_work_poll {
			struct k_work work;
			struct k_work_q *workq;
			struct z_poller poller;
			struct k_poll_event *events;
			int num_events;
			k_work_handler_t real_handler;
			struct _timeout timeout;
			int poll_result;
};
void k_work_poll_init(struct k_work_poll *work,
			k_work_handler_t handler);
int k_work_poll_submit_to_queue(struct k_work_q *work_q,
			struct k_work_poll *work,
			struct k_poll_event *events,
			int num_events,
			k_timeout_t timeout);
int k_work_poll_submit(struct k_work_poll *work,
			struct k_poll_event *events,
			int num_events,
			k_timeout_t timeout);
int k_work_poll_cancel(struct k_work_poll *work);
struct k_msgq {
			_wait_q_t wait_q;
			struct k_spinlock lock;
			size_t msg_size;
			uint32_t max_msgs;
			char *buffer_start;
			char *buffer_end;
			char *read_ptr;
			char *write_ptr;
			uint32_t used_msgs;
			uint8_t flags;
};
struct k_msgq_attrs {
			size_t msg_size;
			uint32_t max_msgs;
			uint32_t used_msgs;
};
void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
			uint32_t max_msgs);
static inline int k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,
			uint32_t max_msgs);
int k_msgq_cleanup(struct k_msgq *msgq);
static inline int k_msgq_put(struct k_msgq *msgq, const void *data, k_timeo=
ut_t timeout);
static inline int k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t t=
imeout);
static inline int k_msgq_peek(struct k_msgq *msgq, void *data);
static inline int k_msgq_peek_at(struct k_msgq *msgq, void *data, uint32_t =
idx);
static inline void k_msgq_purge(struct k_msgq *msgq);
static inline uint32_t k_msgq_num_free_get(struct k_msgq *msgq);
static inline void k_msgq_get_attrs(struct k_msgq *msgq,
			struct k_msgq_attrs *attrs);
static inline uint32_t z_impl_k_msgq_num_free_get(struct k_msgq *msgq)
{
			return msgq->max_msgs - msgq->used_msgs;
}
static inline uint32_t k_msgq_num_used_get(struct k_msgq *msgq);
static inline uint32_t z_impl_k_msgq_num_used_get(struct k_msgq *msgq)
{
			return msgq->used_msgs;
}
struct k_mbox_msg {
			size_t size;
			uint32_t info;
			void *tx_data;
			k_tid_t rx_source_thread;
			k_tid_t tx_target_thread;
			k_tid_t _syncing_thread;
			struct k_sem *_async_sem;
};
struct k_mbox {
			_wait_q_t tx_msg_queue;
			_wait_q_t rx_msg_queue;
			struct k_spinlock lock;
};
void k_mbox_init(struct k_mbox *mbox);
int k_mbox_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,
			k_timeout_t timeout);
void k_mbox_async_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,
			struct k_sem *sem);
int k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg,
			void *buffer, k_timeout_t timeout);
void k_mbox_data_get(struct k_mbox_msg *rx_msg, void *buffer);
struct k_pipe {
			unsigned char *buffer;
			size_t size;
			size_t bytes_used;
			size_t read_index;
			size_t write_index;
			struct k_spinlock lock;
			struct {
			_wait_q_t readers;
			_wait_q_t writers;
			} wait_q;
			uint8_t flags;
};
void k_pipe_init(struct k_pipe *pipe, unsigned char *buffer, size_t size);
int k_pipe_cleanup(struct k_pipe *pipe);
static inline int k_pipe_alloc_init(struct k_pipe *pipe, size_t size);
static inline int k_pipe_put(struct k_pipe *pipe, const void *data,
			size_t bytes_to_write, size_t *bytes_written,
			size_t min_xfer, k_timeout_t timeout);
static inline int k_pipe_get(struct k_pipe *pipe, void *data,
			size_t bytes_to_read, size_t *bytes_read,
			size_t min_xfer, k_timeout_t timeout);
static inline size_t k_pipe_read_avail(struct k_pipe *pipe);
static inline size_t k_pipe_write_avail(struct k_pipe *pipe);
static inline void k_pipe_flush(struct k_pipe *pipe);
static inline void k_pipe_buffer_flush(struct k_pipe *pipe);
struct k_mem_slab_info {
			uint32_t num_blocks;
			size_t block_size;
			uint32_t num_used;
};
struct k_mem_slab {
			_wait_q_t wait_q;
			struct k_spinlock lock;
			char *buffer;
			char *free_list;
			struct k_mem_slab_info info;
};
int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
			size_t block_size, uint32_t num_blocks);
int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem,
			k_timeout_t timeout);
void k_mem_slab_free(struct k_mem_slab *slab, void *mem);
static inline uint32_t k_mem_slab_num_used_get(struct k_mem_slab *slab)
{
			return slab->info.num_used;
}
static inline uint32_t k_mem_slab_max_used_get(struct k_mem_slab *slab)
{
			(void)(slab);
			return 0;
}
static inline uint32_t k_mem_slab_num_free_get(struct k_mem_slab *slab)
{
			return slab->info.num_blocks - slab->info.num_used;
}
int k_mem_slab_runtime_stats_get(struct k_mem_slab *slab, struct sys_memory=
_stats *stats);
int k_mem_slab_runtime_stats_reset_max(struct k_mem_slab *slab);
struct k_heap {
			struct sys_heap heap;
			_wait_q_t wait_q;
			struct k_spinlock lock;
};
void k_heap_init(struct k_heap *h, void *mem,
			size_t bytes) __attribute__((nonnull(1)));
void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout) __attribute__((nonnull(1)));
void *k_heap_alloc(struct k_heap *h, size_t bytes,
			k_timeout_t timeout) __attribute__((nonnull(1)));
void k_heap_free(struct k_heap *h, void *mem) __attribute__((nonnull(1)));
void *k_aligned_alloc(size_t align, size_t size);
void *k_malloc(size_t size);
void k_free(void *ptr);
void *k_calloc(size_t nmemb, size_t size);
enum _poll_types_bits {
			_POLL_TYPE_IGNORE,
			_POLL_TYPE_SIGNAL,
			_POLL_TYPE_SEM_AVAILABLE,
			_POLL_TYPE_DATA_AVAILABLE,
			_POLL_TYPE_MSGQ_DATA_AVAILABLE,
			_POLL_TYPE_PIPE_DATA_AVAILABLE,
			_POLL_NUM_TYPES
};
enum _poll_states_bits {
			_POLL_STATE_NOT_READY,
			_POLL_STATE_SIGNALED,
			_POLL_STATE_SEM_AVAILABLE,
			_POLL_STATE_DATA_AVAILABLE,
			_POLL_STATE_CANCELLED,
			_POLL_STATE_MSGQ_DATA_AVAILABLE,
			_POLL_STATE_PIPE_DATA_AVAILABLE,
			_POLL_NUM_STATES
};
enum k_poll_modes {
			K_POLL_MODE_NOTIFY_ONLY =3D 0,
			K_POLL_NUM_MODES
};
struct k_poll_signal {
			sys_dlist_t poll_events;
			unsigned int signaled;
			int result;
};
struct k_poll_event {
			sys_dnode_t _node;
			struct z_poller *poller;
			uint32_t tag:8;
			uint32_t type:_POLL_NUM_TYPES;
			uint32_t state:_POLL_NUM_STATES;
			uint32_t mode:1;
			uint32_t unused:(32 - (0 + 8 + _POLL_NUM_TYPES + _POLL_NUM_STATES + 1 ))=
;
			union {
			void *obj;
			struct k_poll_signal *signal;
			struct k_sem *sem;
			struct k_fifo *fifo;
			struct k_queue *queue;
			struct k_msgq *msgq;
			};
};
void k_poll_event_init(struct k_poll_event *event, uint32_t type,
			int mode, void *obj);
static inline int k_poll(struct k_poll_event *events, int num_events,
			k_timeout_t timeout);
static inline void k_poll_signal_init(struct k_poll_signal *sig);
static inline void k_poll_signal_reset(struct k_poll_signal *sig);
static inline void k_poll_signal_check(struct k_poll_signal *sig,
			unsigned int *signaled, int *result);
static inline int k_poll_signal_raise(struct k_poll_signal *sig, int result=
);
static inline void k_cpu_idle(void)
{
			arch_cpu_idle();
}
static inline void k_cpu_atomic_idle(unsigned int key)
{
			arch_cpu_atomic_idle(key);
}
void z_init_static_threads(void);
void z_timer_expiration_handler(struct _timeout *t);
static inline void k_str_out(char *c, size_t n);
static inline int k_float_disable(struct k_thread *thread);
static inline int k_float_enable(struct k_thread *thread, unsigned int opti=
ons);
int k_thread_runtime_stats_get(k_tid_t thread,
			k_thread_runtime_stats_t *stats);
int k_thread_runtime_stats_all_get(k_thread_runtime_stats_t *stats);
int k_thread_runtime_stats_enable(k_tid_t thread);
int k_thread_runtime_stats_disable(k_tid_t thread);
void k_sys_runtime_stats_enable(void);
void k_sys_runtime_stats_disable(void);
void sys_trace_isr_enter(void);
void sys_trace_isr_exit(void);
void sys_trace_isr_exit_to_scheduler(void);
void sys_trace_idle(void);
extern k_thread_stack_t * z_impl_k_thread_stack_alloc(size_t size, int flag=
s);
static inline k_thread_stack_t * k_thread_stack_alloc(size_t size, int flag=
s)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_stack_alloc(size, flags);
}
extern int z_impl_k_thread_stack_free(k_thread_stack_t * stack);
static inline int k_thread_stack_free(k_thread_stack_t * stack)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_stack_free(stack);
}
extern k_tid_t z_impl_k_thread_create(struct k_thread * new_thread, k_threa=
d_stack_t * stack, size_t stack_size, k_thread_entry_t entry, void * p1, vo=
id * p2, void * p3, int prio, uint32_t options, k_timeout_t delay);
static inline k_tid_t k_thread_create(struct k_thread * new_thread, k_threa=
d_stack_t * stack, size_t stack_size, k_thread_entry_t entry, void * p1, vo=
id * p2, void * p3, int prio, uint32_t options, k_timeout_t delay)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, =
p2, p3, prio, options, delay);
}
extern int z_impl_k_thread_stack_space_get(const struct k_thread * thread, =
size_t * unused_ptr);
static inline int k_thread_stack_space_get(const struct k_thread * thread, =
size_t * unused_ptr)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_stack_space_get(thread, unused_ptr);
}
extern int z_impl_k_thread_join(struct k_thread * thread, k_timeout_t timeo=
ut);
static inline int k_thread_join(struct k_thread * thread, k_timeout_t timeo=
ut)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_join(thread, timeout);
}
extern int32_t z_impl_k_sleep(k_timeout_t timeout);
static inline int32_t k_sleep(k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_sleep(timeout);
}
extern int32_t z_impl_k_usleep(int32_t us);
static inline int32_t k_usleep(int32_t us)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_usleep(us);
}
extern void z_impl_k_busy_wait(uint32_t usec_to_wait);
static inline void k_busy_wait(uint32_t usec_to_wait)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_busy_wait(usec_to_wait);
}
extern void z_impl_k_yield(void);
static inline void k_yield(void)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_yield();
}
extern void z_impl_k_wakeup(k_tid_t thread);
static inline void k_wakeup(k_tid_t thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_wakeup(thread);
}
extern k_tid_t z_impl_k_sched_current_thread_query(void);
static inline k_tid_t k_sched_current_thread_query(void)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_sched_current_thread_query();
}
extern void z_impl_k_thread_abort(k_tid_t thread);
static inline void k_thread_abort(k_tid_t thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_thread_abort(thread);
}
extern void z_impl_k_thread_start(k_tid_t thread);
static inline void k_thread_start(k_tid_t thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_thread_start(thread);
}
extern k_ticks_t z_impl_k_thread_timeout_expires_ticks(const struct k_threa=
d * t);
static inline k_ticks_t k_thread_timeout_expires_ticks(const struct k_threa=
d * t)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_timeout_expires_ticks(t);
}
extern k_ticks_t z_impl_k_thread_timeout_remaining_ticks(const struct k_thr=
ead * t);
static inline k_ticks_t k_thread_timeout_remaining_ticks(const struct k_thr=
ead * t)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_timeout_remaining_ticks(t);
}
extern int z_impl_k_thread_priority_get(k_tid_t thread);
static inline int k_thread_priority_get(k_tid_t thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_priority_get(thread);
}
extern void z_impl_k_thread_priority_set(k_tid_t thread, int prio);
static inline void k_thread_priority_set(k_tid_t thread, int prio)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_thread_priority_set(thread, prio);
}
extern void z_impl_k_thread_deadline_set(k_tid_t thread, int deadline);
static inline void k_thread_deadline_set(k_tid_t thread, int deadline)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_thread_deadline_set(thread, deadline);
}
extern void z_impl_k_thread_suspend(k_tid_t thread);
static inline void k_thread_suspend(k_tid_t thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_thread_suspend(thread);
}
extern void z_impl_k_thread_resume(k_tid_t thread);
static inline void k_thread_resume(k_tid_t thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_thread_resume(thread);
}
extern int z_impl_k_is_preempt_thread(void);
static inline int k_is_preempt_thread(void)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_is_preempt_thread();
}
extern void z_impl_k_thread_custom_data_set(void * value);
static inline void k_thread_custom_data_set(void * value)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_thread_custom_data_set(value);
}
extern void * z_impl_k_thread_custom_data_get(void);
static inline void * k_thread_custom_data_get(void)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_custom_data_get();
}
extern int z_impl_k_thread_name_set(k_tid_t thread, const char * str);
static inline int k_thread_name_set(k_tid_t thread, const char * str)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_name_set(thread, str);
}
extern int z_impl_k_thread_name_copy(k_tid_t thread, char * buf, size_t siz=
e);
static inline int k_thread_name_copy(k_tid_t thread, char * buf, size_t siz=
e)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_thread_name_copy(thread, buf, size);
}
extern void z_impl_k_timer_start(struct k_timer * timer, k_timeout_t durati=
on, k_timeout_t period);
static inline void k_timer_start(struct k_timer * timer, k_timeout_t durati=
on, k_timeout_t period)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_timer_start(timer, duration, period);
}
extern void z_impl_k_timer_stop(struct k_timer * timer);
static inline void k_timer_stop(struct k_timer * timer)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_timer_stop(timer);
}
extern uint32_t z_impl_k_timer_status_get(struct k_timer * timer);
static inline uint32_t k_timer_status_get(struct k_timer * timer)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_timer_status_get(timer);
}
extern uint32_t z_impl_k_timer_status_sync(struct k_timer * timer);
static inline uint32_t k_timer_status_sync(struct k_timer * timer)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_timer_status_sync(timer);
}
extern k_ticks_t z_impl_k_timer_expires_ticks(const struct k_timer * timer)=
;
static inline k_ticks_t k_timer_expires_ticks(const struct k_timer * timer)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_timer_expires_ticks(timer);
}
extern k_ticks_t z_impl_k_timer_remaining_ticks(const struct k_timer * time=
r);
static inline k_ticks_t k_timer_remaining_ticks(const struct k_timer * time=
r)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_timer_remaining_ticks(timer);
}
extern void z_impl_k_timer_user_data_set(struct k_timer * timer, void * use=
r_data);
static inline void k_timer_user_data_set(struct k_timer * timer, void * use=
r_data)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_timer_user_data_set(timer, user_data);
}
extern void * z_impl_k_timer_user_data_get(const struct k_timer * timer);
static inline void * k_timer_user_data_get(const struct k_timer * timer)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_timer_user_data_get(timer);
}
extern int64_t z_impl_k_uptime_ticks(void);
static inline int64_t k_uptime_ticks(void)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_uptime_ticks();
}
extern void z_impl_k_queue_init(struct k_queue * queue);
static inline void k_queue_init(struct k_queue * queue)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_queue_init(queue);
}
extern void z_impl_k_queue_cancel_wait(struct k_queue * queue);
static inline void k_queue_cancel_wait(struct k_queue * queue)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_queue_cancel_wait(queue);
}
extern int32_t z_impl_k_queue_alloc_append(struct k_queue * queue, void * d=
ata);
static inline int32_t k_queue_alloc_append(struct k_queue * queue, void * d=
ata)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_queue_alloc_append(queue, data);
}
extern int32_t z_impl_k_queue_alloc_prepend(struct k_queue * queue, void * =
data);
static inline int32_t k_queue_alloc_prepend(struct k_queue * queue, void * =
data)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_queue_alloc_prepend(queue, data);
}
extern void * z_impl_k_queue_get(struct k_queue * queue, k_timeout_t timeou=
t);
static inline void * k_queue_get(struct k_queue * queue, k_timeout_t timeou=
t)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_queue_get(queue, timeout);
}
extern int z_impl_k_queue_is_empty(struct k_queue * queue);
static inline int k_queue_is_empty(struct k_queue * queue)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_queue_is_empty(queue);
}
extern void * z_impl_k_queue_peek_head(struct k_queue * queue);
static inline void * k_queue_peek_head(struct k_queue * queue)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_queue_peek_head(queue);
}
extern void * z_impl_k_queue_peek_tail(struct k_queue * queue);
static inline void * k_queue_peek_tail(struct k_queue * queue)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_queue_peek_tail(queue);
}
extern int z_impl_k_futex_wait(struct k_futex * futex, int expected, k_time=
out_t timeout);
static inline int k_futex_wait(struct k_futex * futex, int expected, k_time=
out_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_futex_wait(futex, expected, timeout);
}
extern int z_impl_k_futex_wake(struct k_futex * futex, _Bool wake_all);
static inline int k_futex_wake(struct k_futex * futex, _Bool wake_all)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_futex_wake(futex, wake_all);
}
extern void z_impl_k_event_init(struct k_event * event);
static inline void k_event_init(struct k_event * event)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_event_init(event);
}
extern uint32_t z_impl_k_event_post(struct k_event * event, uint32_t events=
);
static inline uint32_t k_event_post(struct k_event * event, uint32_t events=
)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_event_post(event, events);
}
extern uint32_t z_impl_k_event_set(struct k_event * event, uint32_t events)=
;
static inline uint32_t k_event_set(struct k_event * event, uint32_t events)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_event_set(event, events);
}
extern uint32_t z_impl_k_event_set_masked(struct k_event * event, uint32_t =
events, uint32_t events_mask);
static inline uint32_t k_event_set_masked(struct k_event * event, uint32_t =
events, uint32_t events_mask)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_event_set_masked(event, events, events_mask);
}
extern uint32_t z_impl_k_event_clear(struct k_event * event, uint32_t event=
s);
static inline uint32_t k_event_clear(struct k_event * event, uint32_t event=
s)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_event_clear(event, events);
}
extern uint32_t z_impl_k_event_wait(struct k_event * event, uint32_t events=
, _Bool reset, k_timeout_t timeout);
static inline uint32_t k_event_wait(struct k_event * event, uint32_t events=
, _Bool reset, k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_event_wait(event, events, reset, timeout);
}
extern uint32_t z_impl_k_event_wait_all(struct k_event * event, uint32_t ev=
ents, _Bool reset, k_timeout_t timeout);
static inline uint32_t k_event_wait_all(struct k_event * event, uint32_t ev=
ents, _Bool reset, k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_event_wait_all(event, events, reset, timeout);
}
extern int32_t z_impl_k_stack_alloc_init(struct k_stack * stack, uint32_t n=
um_entries);
static inline int32_t k_stack_alloc_init(struct k_stack * stack, uint32_t n=
um_entries)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_stack_alloc_init(stack, num_entries);
}
extern int z_impl_k_stack_push(struct k_stack * stack, stack_data_t data);
static inline int k_stack_push(struct k_stack * stack, stack_data_t data)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_stack_push(stack, data);
}
extern int z_impl_k_stack_pop(struct k_stack * stack, stack_data_t * data, =
k_timeout_t timeout);
static inline int k_stack_pop(struct k_stack * stack, stack_data_t * data, =
k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_stack_pop(stack, data, timeout);
}
extern int z_impl_k_mutex_init(struct k_mutex * mutex);
static inline int k_mutex_init(struct k_mutex * mutex)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_mutex_init(mutex);
}
extern int z_impl_k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)=
;
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_mutex_lock(mutex, timeout);
}
extern int z_impl_k_mutex_unlock(struct k_mutex * mutex);
static inline int k_mutex_unlock(struct k_mutex * mutex)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_mutex_unlock(mutex);
}
extern int z_impl_k_condvar_init(struct k_condvar * condvar);
static inline int k_condvar_init(struct k_condvar * condvar)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_condvar_init(condvar);
}
extern int z_impl_k_condvar_signal(struct k_condvar * condvar);
static inline int k_condvar_signal(struct k_condvar * condvar)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_condvar_signal(condvar);
}
extern int z_impl_k_condvar_broadcast(struct k_condvar * condvar);
static inline int k_condvar_broadcast(struct k_condvar * condvar)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_condvar_broadcast(condvar);
}
extern int z_impl_k_condvar_wait(struct k_condvar * condvar, struct k_mutex=
 * mutex, k_timeout_t timeout);
static inline int k_condvar_wait(struct k_condvar * condvar, struct k_mutex=
 * mutex, k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_condvar_wait(condvar, mutex, timeout);
}
extern int z_impl_k_sem_init(struct k_sem * sem, unsigned int initial_count=
, unsigned int limit);
static inline int k_sem_init(struct k_sem * sem, unsigned int initial_count=
, unsigned int limit)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_sem_init(sem, initial_count, limit);
}
extern int z_impl_k_sem_take(struct k_sem * sem, k_timeout_t timeout);
static inline int k_sem_take(struct k_sem * sem, k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_sem_take(sem, timeout);
}
extern void z_impl_k_sem_give(struct k_sem * sem);
static inline void k_sem_give(struct k_sem * sem)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_sem_give(sem);
}
extern void z_impl_k_sem_reset(struct k_sem * sem);
static inline void k_sem_reset(struct k_sem * sem)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_sem_reset(sem);
}
extern unsigned int z_impl_k_sem_count_get(struct k_sem * sem);
static inline unsigned int k_sem_count_get(struct k_sem * sem)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_sem_count_get(sem);
}
extern int z_impl_k_msgq_alloc_init(struct k_msgq * msgq, size_t msg_size, =
uint32_t max_msgs);
static inline int k_msgq_alloc_init(struct k_msgq * msgq, size_t msg_size, =
uint32_t max_msgs)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_msgq_alloc_init(msgq, msg_size, max_msgs);
}
extern int z_impl_k_msgq_put(struct k_msgq * msgq, const void * data, k_tim=
eout_t timeout);
static inline int k_msgq_put(struct k_msgq * msgq, const void * data, k_tim=
eout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_msgq_put(msgq, data, timeout);
}
extern int z_impl_k_msgq_get(struct k_msgq * msgq, void * data, k_timeout_t=
 timeout);
static inline int k_msgq_get(struct k_msgq * msgq, void * data, k_timeout_t=
 timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_msgq_get(msgq, data, timeout);
}
extern int z_impl_k_msgq_peek(struct k_msgq * msgq, void * data);
static inline int k_msgq_peek(struct k_msgq * msgq, void * data)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_msgq_peek(msgq, data);
}
extern int z_impl_k_msgq_peek_at(struct k_msgq * msgq, void * data, uint32_=
t idx);
static inline int k_msgq_peek_at(struct k_msgq * msgq, void * data, uint32_=
t idx)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_msgq_peek_at(msgq, data, idx);
}
extern void z_impl_k_msgq_purge(struct k_msgq * msgq);
static inline void k_msgq_purge(struct k_msgq * msgq)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_msgq_purge(msgq);
}
extern uint32_t z_impl_k_msgq_num_free_get(struct k_msgq * msgq);
static inline uint32_t k_msgq_num_free_get(struct k_msgq * msgq)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_msgq_num_free_get(msgq);
}
extern void z_impl_k_msgq_get_attrs(struct k_msgq * msgq, struct k_msgq_att=
rs * attrs);
static inline void k_msgq_get_attrs(struct k_msgq * msgq, struct k_msgq_att=
rs * attrs)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_msgq_get_attrs(msgq, attrs);
}
extern uint32_t z_impl_k_msgq_num_used_get(struct k_msgq * msgq);
static inline uint32_t k_msgq_num_used_get(struct k_msgq * msgq)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_msgq_num_used_get(msgq);
}
extern int z_impl_k_pipe_alloc_init(struct k_pipe * pipe, size_t size);
static inline int k_pipe_alloc_init(struct k_pipe * pipe, size_t size)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_pipe_alloc_init(pipe, size);
}
extern int z_impl_k_pipe_put(struct k_pipe * pipe, const void * data, size_=
t bytes_to_write, size_t * bytes_written, size_t min_xfer, k_timeout_t time=
out);
static inline int k_pipe_put(struct k_pipe * pipe, const void * data, size_=
t bytes_to_write, size_t * bytes_written, size_t min_xfer, k_timeout_t time=
out)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_pipe_put(pipe, data, bytes_to_write, bytes_written, min_=
xfer, timeout);
}
extern int z_impl_k_pipe_get(struct k_pipe * pipe, void * data, size_t byte=
s_to_read, size_t * bytes_read, size_t min_xfer, k_timeout_t timeout);
static inline int k_pipe_get(struct k_pipe * pipe, void * data, size_t byte=
s_to_read, size_t * bytes_read, size_t min_xfer, k_timeout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_pipe_get(pipe, data, bytes_to_read, bytes_read, min_xfer=
, timeout);
}
extern size_t z_impl_k_pipe_read_avail(struct k_pipe * pipe);
static inline size_t k_pipe_read_avail(struct k_pipe * pipe)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_pipe_read_avail(pipe);
}
extern size_t z_impl_k_pipe_write_avail(struct k_pipe * pipe);
static inline size_t k_pipe_write_avail(struct k_pipe * pipe)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_pipe_write_avail(pipe);
}
extern void z_impl_k_pipe_flush(struct k_pipe * pipe);
static inline void k_pipe_flush(struct k_pipe * pipe)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_pipe_flush(pipe);
}
extern void z_impl_k_pipe_buffer_flush(struct k_pipe * pipe);
static inline void k_pipe_buffer_flush(struct k_pipe * pipe)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_pipe_buffer_flush(pipe);
}
extern int z_impl_k_poll(struct k_poll_event * events, int num_events, k_ti=
meout_t timeout);
static inline int k_poll(struct k_poll_event * events, int num_events, k_ti=
meout_t timeout)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_poll(events, num_events, timeout);
}
extern void z_impl_k_poll_signal_init(struct k_poll_signal * sig);
static inline void k_poll_signal_init(struct k_poll_signal * sig)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_poll_signal_init(sig);
}
extern void z_impl_k_poll_signal_reset(struct k_poll_signal * sig);
static inline void k_poll_signal_reset(struct k_poll_signal * sig)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_poll_signal_reset(sig);
}
extern void z_impl_k_poll_signal_check(struct k_poll_signal * sig, unsigned=
 int * signaled, int * result);
static inline void k_poll_signal_check(struct k_poll_signal * sig, unsigned=
 int * signaled, int * result)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_poll_signal_check(sig, signaled, result);
}
extern int z_impl_k_poll_signal_raise(struct k_poll_signal * sig, int resul=
t);
static inline int k_poll_signal_raise(struct k_poll_signal * sig, int resul=
t)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_poll_signal_raise(sig, result);
}
extern void z_impl_k_str_out(char * c, size_t n);
static inline void k_str_out(char * c, size_t n)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			z_impl_k_str_out(c, n);
}
extern int z_impl_k_float_disable(struct k_thread * thread);
static inline int k_float_disable(struct k_thread * thread)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_float_disable(thread);
}
extern int z_impl_k_float_enable(struct k_thread * thread, unsigned int opt=
ions);
static inline int k_float_enable(struct k_thread * thread, unsigned int opt=
ions)
{
			do { __asm__ __volatile__ ("" ::: "memory"); } while (0);
			return z_impl_k_float_enable(thread, options);
}
void arch_busy_wait(uint32_t usec_to_wait);
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
			char *stack_ptr, k_thread_entry_t entry,
			void *p1, void *p2, void *p3);
static inline void arch_switch(void *switch_to, void **switched_from);
int arch_float_disable(struct k_thread *thread);
int arch_float_enable(struct k_thread *thread, unsigned int options);
__attribute__((__noreturn__)) void arch_system_halt(unsigned int reason);
static inline _Bool arch_is_in_isr(void);
void arch_mem_map(void *virt, uintptr_t phys, size_t size, uint32_t flags);
void arch_mem_unmap(void *addr, size_t size);
int arch_page_phys_get(void *virt, uintptr_t *phys);
void arch_reserved_pages_update(void);
void arch_mem_page_out(void *addr, uintptr_t location);
void arch_mem_page_in(void *addr, uintptr_t phys);
void arch_mem_scratch(uintptr_t phys);
enum arch_page_location {
			ARCH_PAGE_LOCATION_PAGED_OUT,
			ARCH_PAGE_LOCATION_PAGED_IN,
			ARCH_PAGE_LOCATION_BAD
};
enum arch_page_location arch_page_location_get(void *addr, uintptr_t *locat=
ion);
uintptr_t arch_page_info_get(void *addr, uintptr_t *location,
			_Bool clear_accessed);
int arch_printk_char_out(int c);
static inline void arch_kernel_init(void);
static inline void arch_nop(void);
void arch_coredump_info_dump(const z_arch_esf_t *esf);
uint16_t arch_coredump_tgt_code_get(void);
size_t arch_tls_stack_setup(struct k_thread *new_thread, char *stack_ptr);
static inline __attribute__((always_inline)) _Bool arch_is_in_isr(void)
{
			return arch_curr_cpu()->nested !=3D 0U;
}
typedef struct __esf _esf_t;
typedef struct __basic_sf _basic_sf_t;
static inline __attribute__((always_inline)) void arch_kernel_init(void)
{
}
static inline void arch_switch(void *switch_to, void **switched_from)
{
			extern void z_arm64_context_switch(struct k_thread *new,
			struct k_thread *old);
			struct k_thread *new =3D switch_to;
			struct k_thread *old =3D ({ extern int (*__Static_assert_function (void)=
) [!!sizeof (struct { int __error_if_negative: (__builtin_types_compatible_=
p(__typeof__(*(switched_from)), __typeof__(((struct k_thread *)0)->switch_h=
andle)) || __builtin_types_compatible_p(__typeof__(*(switched_from)), __typ=
eof__(void))) ? 2 : -1; })]; ((struct k_thread *)(((char *)(switched_from))=
 - __builtin_offsetof (struct k_thread, switch_handle))); });
			z_arm64_context_switch(new, old);
}
extern void z_arm64_fatal_error(unsigned int reason, z_arch_esf_t *esf);
extern void z_arm64_set_ttbr0(uint64_t ttbr0);
extern void z_arm64_mem_cfg_ipi(void);
void z_arm64_flush_local_fpu(void);
void z_arm64_flush_fpu_ipi(unsigned int cpu);
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
			size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__n=
onnull__ (1, 2)));
extern void *memmove (void *__dest, const void *__src, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__noth=
row__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int memcmp (const void *__s1, const void *__s2, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern void *memchr (const void *__s, int __c, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1)));
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern char *strncpy (char *__restrict __dest,
			const char *__restrict __src, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern char *strcat (char *__restrict __dest, const char *__restrict __src)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern char *strncat (char *__restrict __dest, const char *__restrict __src=
,
			size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__n=
onnull__ (1, 2)));
extern int strcmp (const char *__s1, const char *__s2)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern int strncmp (const char *__s1, const char *__s2, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern int strcoll (const char *__s1, const char *__s2)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern size_t strxfrm (char *__restrict __dest,
			const char *__restrict __src, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)=
)) __attribute__ ((__access__ (__write_only__, 1, 3)));
struct __locale_struct
{
		struct __locale_data *__locales[13];
		const unsigned short int *__ctype_b;
		const int *__ctype_tolower;
		const int *__ctype_toupper;
		const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2, 3)));
extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
			locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((_=
_nonnull__ (2, 4)))
			__attribute__ ((__access__ (__write_only__, 1, 3)));
extern char *strdup (const char *__s)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __=
attribute__ ((__nonnull__ (1)));
extern char *strndup (const char *__string, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __=
attribute__ ((__nonnull__ (1)));
extern char *strchr (const char *__s, int __c)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1)));
extern char *strrchr (const char *__s, int __c)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1)));
extern size_t strcspn (const char *__s, const char *__reject)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern size_t strspn (const char *__s, const char *__accept)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern char *strpbrk (const char *__s, const char *__accept)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern char *strstr (const char *__haystack, const char *__needle)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1, 2)));
extern char *strtok (char *__restrict __s, const char *__restrict __delim)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)=
));
extern char *__strtok_r (char *__restrict __s,
			const char *__restrict __delim,
			char **__restrict __save_ptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2,=
 3)));
extern char *strtok_r (char *__restrict __s, const char *__restrict __delim=
,
			char **__restrict __save_ptr)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2,=
 3)));
extern size_t strlen (const char *__s)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1)));
extern size_t strnlen (const char *__string, size_t __maxlen)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __at=
tribute__ ((__nonnull__ (1)));
extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__=
));
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ =
("__USER_LABEL_PREFIX__" "__xpg_strerror_r") __attribute__ ((__nothrow__ , =
__leaf__)) __attribute__ ((__nonnull__ (2)))
			__attribute__ ((__access__ (__write_only__, 2, 3)));
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__noth=
row__ , __leaf__));
extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__))=
;
extern char *__stpcpy (char *__restrict __dest, const char *__restrict __sr=
c)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern char *__stpncpy (char *__restrict __dest,
			const char *__restrict __src, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern char *stpncpy (char *__restrict __dest,
			const char *__restrict __src, size_t __n)
			__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1,=
 2)));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, c=
onst void *__restrict __src, size_t __len)
{
		return __builtin___memcpy_chk (__dest, __src, __len,
			__builtin_object_size (__dest, 0));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void =
*__src, size_t __len)
{
		return __builtin___memmove_chk (__dest, __src, __len,
			__builtin_object_size (__dest, 0));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, si=
ze_t __len)
{
		return __builtin___memset_chk (__dest, __ch, __len,
			__builtin_object_size (__dest, 0));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, c=
onst char *__restrict __src)
{
		return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__de=
st, 1 > 1));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpcpy (char *__restrict __dest, c=
onst char *__restrict __src)
{
		return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__de=
st, 1 > 1));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, =
const char *__restrict __src, size_t __len)
{
		return __builtin___strncpy_chk (__dest, __src, __len,
			__builtin_object_size (__dest, 1 > 1));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char =
*__src, size_t __n)
{
		return __builtin___stpncpy_chk (__dest, __src, __n,
			__builtin_object_size (__dest, 1 > 1));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, c=
onst char *__restrict __src)
{
		return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__de=
st, 1 > 1));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artif=
icial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, =
const char *__restrict __src, size_t __len)
{
		return __builtin___strncat_chk (__dest, __src, __len,
			__builtin_object_size (__dest, 1 > 1));
}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
			uint32_t initial_state, unsigned int options);
void z_early_memset(void *dst, int c, size_t n);
void z_early_memcpy(void *dst, const void *src, size_t n);
void z_bss_zero(void);
static inline void z_data_copy(void)
{
}
static inline void z_bss_zero_boot(void)
{
}
static inline void z_bss_zero_pinned(void)
{
}
__attribute__((__noreturn__)) void z_cstart(void);
void z_device_state_init(void);
extern __attribute__((__noreturn__)) void z_thread_entry(k_thread_entry_t e=
ntry,
			void *p1, void *p2, void *p3);
extern char *z_setup_new_thread(struct k_thread *new_thread,
			k_thread_stack_t *stack, size_t stack_size,
			k_thread_entry_t entry,
			void *p1, void *p2, void *p3,
			int prio, uint32_t options, const char *name);
void *z_thread_aligned_alloc(size_t align, size_t size);
static inline void *z_thread_malloc(size_t size)
{
			return z_thread_aligned_alloc(0, size);
}
extern void z_thread_essential_set(void);
extern void z_thread_essential_clear(void);
static inline __attribute__((always_inline)) void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
			thread->swap_retval =3D value;
}
static inline __attribute__((always_inline)) void
z_thread_return_value_set_with_data(struct k_thread *thread,
			unsigned int value,
			void *data)
{
			arch_thread_return_value_set(thread, value);
			thread->base.swap_data =3D data;
}
extern void z_early_rand_get(uint8_t *buf, size_t length);
extern struct k_thread z_main_thread;
extern struct k_thread z_idle_threads[1];
extern struct z_thread_stack_element z_interrupt_stacks[1][((((unsigned lon=
g)((((((unsigned long)(4096) + ((unsigned long)(16) - 1)) / (unsigned long)=
(16)) * (unsigned long)(16)) + ((size_t)0))) + ((unsigned long)(16) - 1)) /=
 (unsigned long)(16)) * (unsigned long)(16))];
int z_stack_space_get(const uint8_t *stack_start, size_t size, size_t *unus=
ed_ptr);
void z_mem_manage_init(void);
void z_mem_manage_boot_finish(void);
void z_handle_obj_poll_events(sys_dlist_t *events, uint32_t state);
extern char _app_smem_start[];
extern char _app_smem_end[];
extern char _app_smem_size[];
extern char _app_smem_rom_start[];
extern char _app_smem_num_words[];
extern char __kernel_ram_start[];
extern char __kernel_ram_end[];
extern char __kernel_ram_size[];
extern char __bss_start[];
extern char __bss_end[];
extern char z_mapped_start[];
extern char z_mapped_end[];
extern char __rom_region_start[];
extern char __rom_region_end[];
extern char __rom_region_size[];
extern char _flash_used[];
extern char _image_ram_start[];
extern char _image_ram_end[];
extern char _image_ram_size[];
extern char __text_region_start[];
extern char __text_region_end[];
extern char __text_region_size[];
extern char __rodata_region_start[];
extern char __rodata_region_end[];
extern char __rodata_region_size[];
extern char _vector_start[];
extern char _vector_end[];
extern char _end[];
extern char __tdata_start[];
extern char __tdata_end[];
extern char __tdata_size[];
extern char __tdata_align[];
extern char __tbss_start[];
extern char __tbss_end[];
extern char __tbss_size[];
extern char __tbss_align[];
extern char __tls_start[];
extern char __tls_end[];
extern char __tls_size[];
static inline size_t z_tls_data_size(void)
{
			size_t tdata_size =3D ((((unsigned long)(__tdata_size) + ((unsigned long=
)(__tdata_align) - 1)) / (unsigned long)(__tdata_align)) * (unsigned long)(=
__tdata_align));
			size_t tbss_size =3D ((((unsigned long)(__tbss_size) + ((unsigned long)(=
__tbss_align) - 1)) / (unsigned long)(__tbss_align)) * (unsigned long)(__tb=
ss_align));
			return tdata_size + tbss_size;
}
static inline void z_tls_copy(char *dest)
{
			size_t tdata_size =3D (size_t)__tdata_size;
			size_t tbss_size =3D (size_t)__tbss_size;
			memcpy(dest, __tdata_start, tdata_size);
			dest +=3D ((((unsigned long)(tdata_size) + ((unsigned long)(__tdata_alig=
n) - 1)) / (unsigned long)(__tdata_align)) * (unsigned long)(__tdata_align)=
);
			memset(dest, 0, tbss_size);
}
size_t arch_tls_stack_setup(struct k_thread *new_thread, char *stack_ptr)
{
			stack_ptr -=3D z_tls_data_size();
			z_tls_copy(stack_ptr);
			stack_ptr -=3D sizeof(uintptr_t) * 2;
			new_thread->tls =3D ((uintptr_t) (stack_ptr));
			return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
}


================================================================================

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: Infinite loop in delete_pseudo_user_list_entry() bisected to commit "cast: optimize away casts t
Date: Thu, 28 Dec 2023 14:21:22 +0000
Message-ID: <hgs2cgb2auv5y3apocuig6xjhmv3oy5hbzmvjxrxoharjb3fzy () mhjaitwlrnvy>
--------------------
On Thu, Dec 28, 2023 at 01:08:27AM +0000, Herbert, Marc wrote:
> 
> More good news: running `sparse tls.i` on this pre-processed file
> reproduces instantly for me.

Nice!
 
> So see tls.i file below. In case my mailer mangled the file (I gave up
> on plain text email a long time ago, sorry about that) I also attached
> it to the issue:
>   https://github.com/zephyrproject-rtos/zephyr/issues/63417
> I doubt this list accepts attachments...

No problems, I got it alright, thanks.
I think that not too long text attachments (<20M) are OK but I may be wrong.
 
Anyway, with this it was very easy to reproduce and find the cause.
Fixed and pushed, so mainline Sparse should be OK now.

Many thanks for the bug report,
-- Luc

================================================================================


################################################################################

=== Thread: PSA: this list has moved to new vger infra (no action required) ===

From: Konstantin Ryabitsev <konstantin () linuxfoundation ! org>
To: linux-sparse
Subject: PSA: this list has moved to new vger infra (no action required)
Date: Tue, 21 Nov 2023 01:10:09 +0000
Message-ID: <20231120-glaring-tentacled-bear-c5dbfa () nitro>
--------------------
Hello, all:

This list has been migrated to new vger infrastructure. No action is required
on your part and there should be no change in how you interact with this list.

This message acts as a verification test that the archives are properly
updating.

If something isn't working or looking right, please reach out to
helpdesk@kernel.org.

Best regards,
-K

================================================================================


################################################################################

=== Thread: Re ===

From: "Maria-Elisabeth Schaeffler" <wiki () paul-scerri ! ch>
To: linux-sparse
Subject: Re
Date: Mon, 10 Apr 2023 19:34:30 +0000
Message-ID: <20230410193431.B73A65809BE () zimbra-dc ! paul-scerri ! ch>
--------------------
Your email account has been selected for a donation of â¬1,700,000. Please contact for more information.

Mrs Maria Elisabeth Schaeffler
CEO SCHAEFFLER.
================================================================================


################################################################################

=== Thread: Servicio de la flota ===

From: "Miguel Garcia" <miguel.garcia () slidebizcompany ! com>
To: linux-sparse
Subject: Servicio de la flota
Date: Mon, 02 Jan 2023 09:05:35 +0000
Message-ID: <20230102074500-0.1.53.1ov3i.0.vlhf4a2upq () slidebizcompany ! com>
--------------------
Buenos d=C3=ADas:

Le escribo para hablarle sobre una de las mejores herramientas GPS en el =
mercado.

La herramienta, que me gustar=C3=ADa presentarle brevemente, dispone de m=
uchas funciones =C3=BAtiles para su trabajo, que optimizan los procesos d=
e transporte y le ayudan a realizar tareas de campo de manera m=C3=A1s ef=
iciente.

=C2=BFQuiere conocer los detalles?


Atentamente,
Miguel Garcia
================================================================================

From: "Miguel Garcia" <miguel.garcia () clydespay ! com>
To: linux-sparse
Subject: Servicio de la flota
Date: Thu, 11 May 2023 08:05:22 +0000
Message-ID: <20230511064500-0.1.7n.257u3.0.mvcsq5xgqn () clydespay ! com>
--------------------
Buenos d=C3=ADas:

Le escribo para hablarle sobre una de las mejores herramientas GPS en el =
mercado.

La herramienta, que me gustar=C3=ADa presentarle brevemente, dispone de m=
uchas funciones =C3=BAtiles para su trabajo, que optimizan los procesos d=
e transporte y le ayudan a realizar tareas de campo de manera m=C3=A1s ef=
iciente.

=C2=BFQuiere conocer los detalles?


Atentamente,
Miguel Garcia
================================================================================


################################################################################

=== Thread: Silikonmischungen ===

From: "Zbynek Spacek" <zbynek.spacek () glencoeaur ! com>
To: linux-sparse
Subject: Silikonmischungen
Date: Thu, 12 Jan 2023 08:31:00 +0000
Message-ID: <20230112074500-0.1.z.3f8h.0.4ujpdcb44k () glencoeaur ! com>
--------------------
Good morning,

do you need intermediates for processing, plastics (e.g. rubber) or silic=
one mixtures?

We provide a wide range of silicone rubbers with various properties, sili=
cone mixtures from renowned manufacturers such as Wacker, Elastosil LR an=
d dyes, stabilizers, primers and anti-adhesive additives.

We also produce technical silicone compounds with increased resistance to=
 oils, resistant to high temperatures and water vapor, conductive and man=
y more.

We provide fast order fulfillment, timely deliveries and cost optimizatio=
n.

Can I introduce what we can offer you?


Best regards
Zbynek Spacek
================================================================================


################################################################################

=== Thread: Sparse infinite loop ===

From: =?UTF-8?Q?Ramon_Vall=C3=A9s_Puig?= <vallespuigramon () gmail ! com>
To: linux-sparse
Subject: Sparse infinite loop
Date: Sat, 06 May 2023 14:58:31 +0000
Message-ID: <CAMme6D7mQx5m7cbqp641ZfdOeE9UJAHJ_9xT-fAdSD8YMJfm=A () mail ! gmail ! com>
--------------------
Hi,
I have been experiencing a situation in which the free use of global
variables has noticeably hindered my experience with Sparse.

The main issue that I wanted to report is that there is no easy way to
"clean up '' sparse in execution, leading to unexpected behaviour if
Sparse is being run multiple times in a row.

Say for instance that I am running automated tests in a given project
that uses Sparse. Each test will call sparse_initialize() in the start
up, making Sparse fill the hash_table "global" variable with the
different identifiers. But I do not have a possibility to clean up
Sparse in the teardown of the tests. While running sparse in the first
run, hash_table is an array of null pointers ( static struct ident
*hash_table[IDENT_HASH_SIZE]; ) so everything will work as expected.
However, if we run Sparse a second time, hash_table will no longer be
an empty array, instead will contain the artifacts of the first run.
This is an issue, since several functions within tokenize.c use
hash_table to check the existence of an identifier in the hash, and
assign it to the "next" ident, opening the door to a cyclic linked
list: ident =3D ident->next, thus falling in an infinite loop.

The issue can be reproduce just by running:

int main(int argc, char **argv)
{
    struct string_list *filelist =3D NULL;
    sparse_initialize(argc, argv, &filelist); // (1)
    sparse_initialize(argc, argv, &filelist); // (2)
    return 0;
}

this will never terminate as sparse_initialize (2) will most likely
fall in an infinite loop at some point inside create_hashed_ident.

A possible solution would be to add a "clean_up" function in
tokenize.c to reset the hash_table to null pointers which should be
called in between steps (1) and (2).
It would also make sense to add a security check in insert_hash, to
protect ident->next =3D ident.



Maybe I am missing something, but I've been stuck here for a while (bad jok=
e).
I look forward to your reply,
best regards,

Vall=C3=A9s Puig, Ramon
================================================================================


################################################################################

=== Thread: Sparse on ARM Neon intrinsics ===

From: Dan Carpenter <dan.carpenter () linaro ! org>
To: linux-sparse
Subject: Sparse on ARM Neon intrinsics
Date: Wed, 03 May 2023 15:32:24 +0000
Message-ID: <f6adc14d-c5c5-45c5-9e85-979d5d328842 () kili ! mountain>
--------------------
There are a couple files in an ARM build which fail because of ARM Neon
intrinsics: lib/raid6/recov_neon_inner.c and crypto/aegis128-neon-inner.c

  CHECK   crypto/aegis128-neon-inner.c
crypto/aegis128-neon-inner.c: note: in included file (through arch/arm64/include/asm/neon-intrinsics.h):
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:40:9: warning: '__Int8x8_t' has implicit type
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:40:20: error: Expected ; at end of declaration
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:40:20: error: got int8x8_t
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:41:21: error: Expected ; at end of declaration
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:41:21: error: got int16x4_t
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:42:21: error: Expected ; at end of declaration
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:42:21: error: got int32x2_t
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:43:21: error: Expected ; at end of declaration
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:43:21: error: got int64x1_t
/usr/lib/gcc-cross/aarch64-linux-gnu/12/include/arm_neon.h:44:23: error: Expected ; at end of declaration

Neon intrinsics seem really complicated to handle, but maybe there is
a hack around to just silence the warnings?

regards,
dan carpenter

================================================================================


################################################################################

=== Thread: [PATCH v1 00/14] DCE/DSE: Add Dead Syscalls Elimination support, part2 ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 00/14] DCE/DSE: Add Dead Syscalls Elimination support, part2
Date: Fri, 03 Nov 2023 15:56:35 +0000
Message-ID: <cover.1699025537.git.tanyuan () tinylab ! org>
--------------------
Hi, all

This series aims to add Dead Code Elimination(DCE) based Dead Syscalls
Elimination(DSE) support, here is the RFC patchset[1]. The whole series
includes three parts, here is the Part2.

Part1 adds basic DCE based DSE support [5].

Part3 will add DSE test support with nolibc-test.c.

This Part2 further eliminates the unused syscalls forcely kept by the
exception tables. This is just a preliminary approach and requires a lot
of discussion and modifications.

Some syscalls use put_user()/get_user() to access memory from
user-space, the exception tables are added for such memory addresses to
fixup potential exceptions fairily.

These exception tables are added by the simple '.pushsection' directive
and there is no explicit section relationship between them and their
syscall functions, So, all of such tables are explicitly kept by the
KEEP() directive in vmlinux.lds, but such forcely KEEP() operations
prevent DCE from eliminating their syscall functions for the tables used
some addresses in their syscall functions, the insn and fixup addresses
(arch/riscv/include/asm/asm-extable.h) are from their syscall functions,
as a result, the ownership reverses.

To further eliminate such syscalls, we must fix up this ownership
reversal issue. At first, the KEEP() operations must be removed from
vmlinux.lds, but at the same time, we must find a way to tell ld the
real ownership between the syscalls and their exceptions tables.

Fortunately, under the guidance of Zhangjin Wu, I discovered that both
SHF_GROUP and SHF_LINK_ORDER can be helpful for such targets ([6] [7]
[8]), but the former method triggers a warning from as. The binary files
compiled using both methods turn out to be identical. So maybe we just
choose the later one?

This series adds a very elementary level of patchset to demonstate how
to use them to drop KEEP() for all of the exception tables, only for
RISC-V currently.

This may also be a good start for us to rethink the widely used KEEP().
This approach can thoroughly eliminate orphan sections, providing the
compiler with more information. Eventually, most of the KEEP() calls
can be eliminated.

The nolibc-test based initrd run well on riscv64 kernel image with dead
syscalls eliminated:

    $ nm build/riscv64/virt/linux/v6.6-rc2/vmlinux | grep "T __riscv_sys" | grep -v sys_ni_syscall | wc -l
    40

These options should be enabled:

    CONFIG_LD_DEAD_CODE_DATA_ELIMINATION=y
    CONFIG_LD_DEAD_CODE_DATA_ELIMINATION_DEBUG=y
    CONFIG_TRIM_UNUSED_SYSCALLS=y
    CONFIG_SECTION_SHF_LINK_ORDER_SUPPORT=y
    CONFIG_USED_SYSCALLS="sys_dup sys_dup3 sys_ioctl sys_mknodat sys_mkdirat sys_unlinkat sys_symlinkat sys_linkat sys_mount sys_chdir sys_chroot sys_fchmodat sys_fchownat sys_openat sys_close sys_pipe2 sys_getdents64 sys_lseek sys_read sys_write sys_pselect6 sys_ppoll sys_exit sys_sched_yield sys_kill sys_reboot sys_getpgid sys_prctl sys_gettimeofday sys_getpid sys_getppid sys_getuid sys_geteuid sys_brk sys_munmap sys_clone sys_execve sys_mmap sys_wait4 sys_statx"

Or using section group intead of section link order:

    CONFIG_SECTION_SHF_GROUP_SUPPORT=y

Thanks to Song Fangrui's idea [9] of SHF_LINK_ORDER. To be honest, this
part is hard to understand, and there may be some mistakes in my
solutions. Welcome your further advice. :)

Besides, I want to express my thanks to Zhangjin Wu, Zhiming Xu, Anqi
Xiao, Jun Kong, and Yuzhe Ling for their help during the investigation
stage.

Best Regards,
Yuan Tan

---
[1]: https://lore.kernel.org/lkml/cover.1676594211.git.falcon@tinylab.org/
[2]: https://lore.kernel.org/lkml/234017be6d06ef84844583230542e31068fa3685.1676594211.git.falcon@tinylab.org/
[3]: https://lore.kernel.org/lkml/CAFP8O3+41QFVyNTVJ2iZYkB0tqnvdLTAoGShgGy-qPP1PHjBEw@mail.gmail.com/
[4]: https://lore.kernel.org/lkml/cbcbfbb37cabfd9aed6088c75515e4ea86006cff.1676594211.git.falcon@tinylab.org/
[5]: https://lore.kernel.org/lkml/cover.1695679700.git.falcon@tinylab.org/
[6]: https://maskray.me/blog/2021-07-25-comdat-and-section-group
[7]: https://maskray.me/blog/2021-01-31-metadata-sections-comdat-and-shf-link-order
[8]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html
[9]: https://sourceware.org/pipermail/binutils/2023-July/128521.html

Yuan Tan (10):
  DCE/DSE: add HAVE_SECTION_SHF_LINK_ORDER_SUPPORT option
  DCE/DSE: add HAVE_SECTION_SHF_GROUP_SUPPORT option
  DCE/DSE: add HAVE_SECTION_NO_KEEP_SUPPORT option
  DCE/DSE: add choice of methods to build reference for orphan sections
  DCE/DSE: inhibit .size directive for SHF_GROUP
  DCE/DSE: riscv: make every ex_table's name unique
  DCE/DSE: riscv: build reference for .pushsection in C functions
  DCE/DSE: riscv: build reference for .pushsection in assembly
  DCE/DSE: add SECTION_NO_KEEP_SUPPORT option
  DCE/DSE: vmlinux.lds.h: allow NO_KEEP on __ex_table sections

Zhangjin Wu (4):
  DCE/DSE: allow keep unique bounded sections
  compiler: add a global __QUITE_UNIQUE_ID()
  compiler: add unique __SECTION_NAME()
  compiler: add unique LABEL_NAME()

 Makefile                             |  3 ++
 arch/riscv/include/asm/asm-extable.h | 43 +++++++++++++---
 arch/riscv/lib/uaccess.S             | 60 +++++++++++-----------
 include/asm-generic/vmlinux.lds.h    | 28 ++++++++---
 include/linux/compiler.h             | 25 ++++++++++
 include/linux/compiler_types.h       |  8 +--
 init/Kconfig                         | 74 ++++++++++++++++++++++++++++
 7 files changed, 193 insertions(+), 48 deletions(-)

-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 01/14] DCE/DSE: allow keep unique bounded sections ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 01/14] DCE/DSE: allow keep unique bounded sections
Date: Fri, 03 Nov 2023 15:58:30 +0000
Message-ID: <c1af88e9c5e5956f22de6b9e7e69186dfad68767.1699025537.git.tanyuan () tinylab ! org>
--------------------
From: Zhangjin Wu <falcon@tinylab.org>

The bounded sections may break the elimination of some dead code.

Some unused syscalls have been wrongly kept by `__ex_table`, we will
unique `__ex_table` for every inserting and then remove the unused ones
explicitly and eventually, the unused syscalls will be eliminated.

In the future, we should find better methods to solve such issue:

  Some code may use '.pushsection/.popsection' to insert data
  to a bounded section, use `sys_sendfile` as an example:

      sys_sendfile:

        ".pushsection __ex_table,\"\"\n"
        ...
	".long		((" insn ") - .)\n"
        ...
        ".popsection"

  `insn` is an address in `sys_sendfile`, even if no real user uses
  sys_sendfile, the keeping of __ex_table will become a 'user' and
  break the elimination of `sys_sendfile`.

All of the bounded sections should be uniqued, and we should check if
they are the last users of the code, if so, those sections should be
removed and the code should be eliminated.

Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 include/asm-generic/vmlinux.lds.h | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index 9c59409104f6..ea8170e11ab1 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -103,6 +103,7 @@
 #define RODATA_MAIN .rodata .rodata.[0-9a-zA-Z_]* .rodata..L*
 #define BSS_MAIN .bss .bss.[0-9a-zA-Z_]* .bss..compoundliteral*
 #define SBSS_MAIN .sbss .sbss.[0-9a-zA-Z_]*
+#define BSEC_MAIN(sec) sec sec##.[0-9a-zA-Z_]*
 #else
 #define TEXT_MAIN .text
 #define DATA_MAIN .data
@@ -110,6 +111,7 @@
 #define RODATA_MAIN .rodata
 #define BSS_MAIN .bss
 #define SBSS_MAIN .sbss
+#define BSEC_MAIN(sec) sec
 #endif
 
 /*
@@ -201,12 +203,12 @@
 
 #define BOUNDED_SECTION_PRE_LABEL(_sec_, _label_, _BEGIN_, _END_)	\
 	_BEGIN_##_label_ = .;						\
-	KEEP(*(_sec_))							\
+	KEEP(*(BSEC_MAIN(_sec_)))					\
 	_END_##_label_ = .;
 
 #define BOUNDED_SECTION_POST_LABEL(_sec_, _label_, _BEGIN_, _END_)	\
 	_label_##_BEGIN_ = .;						\
-	KEEP(*(_sec_))							\
+	KEEP(*(BSEC_MAIN(_sec_)))					\
 	_label_##_END_ = .;
 
 #define BOUNDED_SECTION_BY(_sec_, _label_)				\
-- 
2.34.1


================================================================================


################################################################################

=== Thread: [PATCH v1 02/14] compiler: add a global __QUITE_UNIQUE_ID() ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 02/14] compiler: add a global __QUITE_UNIQUE_ID()
Date: Fri, 03 Nov 2023 15:58:49 +0000
Message-ID: <152d812cb6fa2c6018794ea7f05f487631542d6e.1699025537.git.tanyuan () tinylab ! org>
--------------------
From: Zhangjin Wu <falcon@tinylab.org>

Differs from __UNIQUE_ID(), __QUITE_UNIQUE_ID() also appends the
__COUNTER__ info to make it more unique.

Besides, seems assembly code also require such a unique id, let's make
it global, the same to the required __PASTE macro.

Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
I am not sure whether it is proper to put the __QUITE_UNIQUE_ID and
other stuff later in compiler.h. Welcome discussion as this is just
a preliminary approach.

 include/linux/compiler.h       | 5 +++++
 include/linux/compiler_types.h | 8 ++++----
 2 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index d7779a18b24f..405b19cf6cf3 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -227,6 +227,11 @@ static inline void *offset_to_ptr(const int *off)
 
 #endif /* __ASSEMBLY__ */
 
+/* Quite-unique ID. */
+#ifndef __QUITE_UNIQUE_ID
+# define __QUITE_UNIQUE_ID(prefix) __PASTE(__PASTE(prefix, __LINE__), __COUNTER__)
+#endif
+
 /* &a[0] degrades to a pointer: a different type from an array */
 #define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
 
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index c523c6683789..0b79e19d1017 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -70,10 +70,6 @@ static inline void __chk_io_ptr(const volatile void __iomem *ptr) { }
 # define __builtin_warning(x, y...) (1)
 #endif /* __CHECKER__ */
 
-/* Indirect macros required for expanded argument pasting, eg. __LINE__. */
-#define ___PASTE(a,b) a##b
-#define __PASTE(a,b) ___PASTE(a,b)
-
 #ifdef __KERNEL__
 
 /* Attributes */
@@ -308,6 +304,10 @@ struct ftrace_likely_data {
 
 #endif /* __ASSEMBLY__ */
 
+/* Indirect macros required for expanded argument pasting, eg. __LINE__. */
+#define ___PASTE(a, b) a##b
+#define __PASTE(a, b) ___PASTE(a, b)
+
 /*
  * The below symbols may be defined for one or more, but not ALL, of the above
  * compilers. We don't consider that to be an error, so set them to nothing.
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 03/14] compiler: add unique __SECTION_NAME() ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 03/14] compiler: add unique __SECTION_NAME()
Date: Fri, 03 Nov 2023 15:58:59 +0000
Message-ID: <3c10b123c7ec27fbd942dd9a07d877743616c935.1699025537.git.tanyuan () tinylab ! org>
--------------------
From: Zhangjin Wu <falcon@tinylab.org>

The new section helper is added for LD_DEAD_CODE_DATA_ELIMINATION to
generate unique section name (strigified).

Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
---
 include/linux/compiler.h | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 405b19cf6cf3..5a9cc3209b12 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -227,11 +227,25 @@ static inline void *offset_to_ptr(const int *off)
 
 #endif /* __ASSEMBLY__ */
 
+/* Import __stringify. */
+#ifndef __stringify
+#include <linux/stringify.h>
+#endif
+
 /* Quite-unique ID. */
 #ifndef __QUITE_UNIQUE_ID
 # define __QUITE_UNIQUE_ID(prefix) __PASTE(__PASTE(prefix, __LINE__), __COUNTER__)
 #endif
 
+/* Quite-unique Section NAME. */
+#ifndef __SECTION_NAME
+#ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION
+# define __SECTION_NAME(prefix) __stringify(__QUITE_UNIQUE_ID(prefix.))
+#else
+# define __SECTION_NAME(prefix) __stringify(prefix)
+#endif
+#endif
+
 /* &a[0] degrades to a pointer: a different type from an array */
 #define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
 
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 04/14] compiler: add unique LABEL_NAME() ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 04/14] compiler: add unique LABEL_NAME()
Date: Fri, 03 Nov 2023 15:59:11 +0000
Message-ID: <db3498efc33b3065a0acb534d034f7d33ad03e19.1699025537.git.tanyuan () tinylab ! org>
--------------------
From: Zhangjin Wu <falcon@tinylab.org>

unique LABEL is required by SHF_LINK_ORDER support.

Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 include/linux/compiler.h | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 5a9cc3209b12..b178f5d51ad6 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -246,6 +246,12 @@ static inline void *offset_to_ptr(const int *off)
 #endif
 #endif
 
+/* Unique Label NAME. */
+/* Label is file scope, __LINE__ is enough, and not change in the same macro call */
+#ifndef __LABEL_NAME
+# define __LABEL_NAME(prefix) __stringify(__PASTE(__PASTE(prefix, _), __LINE__))
+#endif
+
 /* &a[0] degrades to a pointer: a different type from an array */
 #define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
 
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 05/14] DCE/DSE: add HAVE_SECTION_SHF_LINK_ORDER_SUPPORT option ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 05/14] DCE/DSE: add HAVE_SECTION_SHF_LINK_ORDER_SUPPORT option
Date: Fri, 03 Nov 2023 15:59:54 +0000
Message-ID: <141030de2b3d470251d1588b39cb041ec505d84f.1699025537.git.tanyuan () tinylab ! org>
--------------------
SHF_LINK_ORDER requires ld >= 2.35.

LLD supports SHF_LINK_ORDER to, but it does not support riscv
HAVE_LD_DEAD_CODE_DATA_ELIMINATION. Therefore, I haven't tested the
minimum compatible version yet.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 init/Kconfig | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/init/Kconfig b/init/Kconfig
index aa648ce8bca1..1ef5b19918e5 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1462,6 +1462,11 @@ config HAVE_TRIM_UNUSED_SYSCALLS
 	depends on HAVE_LD_DEAD_CODE_DATA_ELIMINATION
 	default n
 
+config HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
+	bool
+	depends on AS_IS_GNU && AS_VERSION >= 23500
+	default y
+
 menuconfig EXPERT
 	bool "Configure standard kernel features (expert users)"
 	# Unhide debug options, to make the on-by-default options visible
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 06/14] DCE/DSE: add HAVE_SECTION_SHF_GROUP_SUPPORT option ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 06/14] DCE/DSE: add HAVE_SECTION_SHF_GROUP_SUPPORT option
Date: Fri, 03 Nov 2023 15:58:35 +0000
Message-ID: <04271c1f3a4c3d369310146faefc0d05144276e9.1699025537.git.tanyuan () tinylab ! org>
--------------------
SHF_GROUP requires ld >= 2.36.

LLD supports SHF_GROUP too, but it does not support riscv
HAVE_LD_DEAD_CODE_DATA_ELIMINATION. Therefore, I haven't tested the
minimum compatible version yet.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 init/Kconfig | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/init/Kconfig b/init/Kconfig
index 1ef5b19918e5..4296c97cfc84 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1467,6 +1467,11 @@ config HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
 	depends on AS_IS_GNU && AS_VERSION >= 23500
 	default y
 
+config HAVE_SECTION_SHF_GROUP_SUPPORT
+	bool
+	depends on AS_IS_GNU && AS_VERSION >= 23600
+	default y
+
 menuconfig EXPERT
 	bool "Configure standard kernel features (expert users)"
 	# Unhide debug options, to make the on-by-default options visible
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 07/14] DCE/DSE: add HAVE_SECTION_NO_KEEP_SUPPORT option ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 07/14] DCE/DSE: add HAVE_SECTION_NO_KEEP_SUPPORT option
Date: Fri, 03 Nov 2023 15:58:35 +0000
Message-ID: <494854689a6f6f91da151ae4bd9a7a6132092271.1699025537.git.tanyuan () tinylab ! org>
--------------------
Once there's SECTION_SHF_LINK_ORDER_SUPPORT or
SECTION_SHF_GROUP_SUPPORT, there won't be any orphan section and won't
need KEEP() anymore.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 init/Kconfig | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/init/Kconfig b/init/Kconfig
index 4296c97cfc84..9834dbb0ddae 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1462,6 +1462,11 @@ config HAVE_TRIM_UNUSED_SYSCALLS
 	depends on HAVE_LD_DEAD_CODE_DATA_ELIMINATION
 	default n
 
+config HAVE_SECTION_NO_KEEP_SUPPORT
+	bool
+	depends on HAVE_SECTION_SHF_LINK_ORDER_SUPPORT || HAVE_SECTION_SHF_GROUP_SUPPORT
+	default y
+
 config HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
 	bool
 	depends on AS_IS_GNU && AS_VERSION >= 23500
-- 
2.34.1

================================================================================

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-kernel
Subject: [PATCH v1 07/14] DCE/DSE: add HAVE_SECTION_NO_KEEP_SUPPORT option
Date: Fri, 03 Nov 2023 15:58:36 +0000
Message-ID: <494854689a6f6f91da151ae4bd9a7a6132092271.1699025537.git.tanyuan () tinylab ! org>
--------------------
Once there's SECTION_SHF_LINK_ORDER_SUPPORT or
SECTION_SHF_GROUP_SUPPORT, there won't be any orphan section and won't
need KEEP() anymore.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 init/Kconfig | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/init/Kconfig b/init/Kconfig
index 4296c97cfc84..9834dbb0ddae 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1462,6 +1462,11 @@ config HAVE_TRIM_UNUSED_SYSCALLS
 	depends on HAVE_LD_DEAD_CODE_DATA_ELIMINATION
 	default n
 
+config HAVE_SECTION_NO_KEEP_SUPPORT
+	bool
+	depends on HAVE_SECTION_SHF_LINK_ORDER_SUPPORT || HAVE_SECTION_SHF_GROUP_SUPPORT
+	default y
+
 config HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
 	bool
 	depends on AS_IS_GNU && AS_VERSION >= 23500
-- 
2.34.1

================================================================================

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 07/14] DCE/DSE: add HAVE_SECTION_NO_KEEP_SUPPORT option
Date: Fri, 03 Nov 2023 15:58:36 +0000
Message-ID: <494854689a6f6f91da151ae4bd9a7a6132092271.1699025537.git.tanyuan () tinylab ! org>
--------------------
Once there's SECTION_SHF_LINK_ORDER_SUPPORT or
SECTION_SHF_GROUP_SUPPORT, there won't be any orphan section and won't
need KEEP() anymore.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 init/Kconfig | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/init/Kconfig b/init/Kconfig
index 4296c97cfc84..9834dbb0ddae 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1462,6 +1462,11 @@ config HAVE_TRIM_UNUSED_SYSCALLS
 	depends on HAVE_LD_DEAD_CODE_DATA_ELIMINATION
 	default n
 
+config HAVE_SECTION_NO_KEEP_SUPPORT
+	bool
+	depends on HAVE_SECTION_SHF_LINK_ORDER_SUPPORT || HAVE_SECTION_SHF_GROUP_SUPPORT
+	default y
+
 config HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
 	bool
 	depends on AS_IS_GNU && AS_VERSION >= 23500
-- 
2.34.1

================================================================================

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-kernel
Subject: [PATCH v1 07/14] DCE/DSE: add HAVE_SECTION_NO_KEEP_SUPPORT option
Date: Fri, 03 Nov 2023 15:58:36 +0000
Message-ID: <494854689a6f6f91da151ae4bd9a7a6132092271.1699025537.git.tanyuan () tinylab ! org>
--------------------
Once there's SECTION_SHF_LINK_ORDER_SUPPORT or
SECTION_SHF_GROUP_SUPPORT, there won't be any orphan section and won't
need KEEP() anymore.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 init/Kconfig | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/init/Kconfig b/init/Kconfig
index 4296c97cfc84..9834dbb0ddae 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1462,6 +1462,11 @@ config HAVE_TRIM_UNUSED_SYSCALLS
 	depends on HAVE_LD_DEAD_CODE_DATA_ELIMINATION
 	default n
 
+config HAVE_SECTION_NO_KEEP_SUPPORT
+	bool
+	depends on HAVE_SECTION_SHF_LINK_ORDER_SUPPORT || HAVE_SECTION_SHF_GROUP_SUPPORT
+	default y
+
 config HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
 	bool
 	depends on AS_IS_GNU && AS_VERSION >= 23500
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 08/14] DCE/DSE: add choice of methods to build reference for orphan sections ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-kernel
Subject: [PATCH v1 08/14] DCE/DSE: add choice of methods to build reference for orphan sections
Date: Fri, 03 Nov 2023 15:58:35 +0000
Message-ID: <c1c9913c0974b96faaab664ef354cf8775cd7554.1699025537.git.tanyuan () tinylab ! org>
--------------------
Due to .pushsection producing orphan sections, the kernel currently uses
`KEEP()` in the linker script to address this issue.

Here we purpose two methods to build reference for pushed section,
SHF_LINK_ORDER method and SECTION_SHF_GROUP method.

The binary files compiled using both methods turn out to be identical,
and it doesn't produce any side effects.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 init/Kconfig | 50 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 50 insertions(+)

diff --git a/init/Kconfig b/init/Kconfig
index 9834dbb0ddae..9599d2de44e8 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1740,6 +1740,56 @@ config USED_SYSCALLS
 
 	  If unsure, please disable TRIM_UNUSED_SYSCALLS.
 
+choice
+	prompt "Trim methods" if EXPERT
+	default RESTRICTED_TRIM_UNUSED_SYSCALLS
+	depends on TRIM_UNUSED_SYSCALLS
+	help
+	  This option selects the method to trim unused syscall wrongly kept.
+
+	  The binary files compiled using both methods are identical.
+
+	  If the trim methods is not specified, some syscalls are kept by
+	  linker script and can not be trimmed.
+
+config RESTRICTED_TRIM_UNUSED_SYSCALLS
+	bool "Leave some kept syscalls (EXPERIMENTAL)" if EXPERT
+	help
+	  Say Y here to trim 'unused' syscalls wrongly kept by __ex_table
+	  like sections in kernel space.
+
+	  Some syscalls are kept by linker script and can not be trimmed.
+
+	  If unsure, choose this.
+
+config SECTION_SHF_LINK_ORDER_SUPPORT
+	bool "Using SHF_LINK_ORDER attribute (EXPERIMENTAL)" if EXPERT
+	depends on HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
+	help
+	  Say Y here to trim more 'unused' syscalls wrongly kept by __ex_table
+	  like sections in kernel space.
+
+	  This option uses the SHF_LINK_ORDER attribute to build references for
+	  orphan sections. Therefore, these sections are no longer kept in the
+	  linker script.
+
+	  If unsure, not choose this.
+
+config SECTION_SHF_GROUP_SUPPORT
+	bool "Using SHF_GROUP attribute (EXPERIMENTAL)" if EXPERT
+	depends on HAVE_SECTION_SHF_GROUP_SUPPORT
+	help
+	  Say Y here to trim more 'unused' syscalls wrongly kept by __ex_table
+	  like sections in kernel space.
+
+	  This option uses the SHF_GROUP attribute to build references for
+	  orphan sections. Therefore, these sections are no longer kept in the
+	  linker script.
+
+	  If unsure, not choose this.
+
+endchoice
+
 config KALLSYMS
 	bool "Load all symbols for debugging/ksymoops" if EXPERT
 	default y
-- 
2.34.1

================================================================================

From: Fangrui Song <i () maskray ! me>
To: linux-sparse
Subject: Re: [PATCH v1 08/14] DCE/DSE: add choice of methods to build reference for orphan sections
Date: Sun, 05 Nov 2023 21:35:11 +0000
Message-ID: <DS7PR12MB576555798778F91D449FD5C9CBABA () DS7PR12MB5765 ! namprd12 ! prod ! outlook ! com>
--------------------
On Fri, Nov 3, 2023 at 9:01â¯AM Yuan Tan <tanyuan@tinylab.org> wrote:
>
> Due to .pushsection producing orphan sections, the kernel currently uses
> `KEEP()` in the linker script to address this issue.
>
> Here we purpose two methods to build reference for pushed section,
> SHF_LINK_ORDER method and SECTION_SHF_GROUP method.
>
> The binary files compiled using both methods turn out to be identical,
> and it doesn't produce any side effects.
>
> Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
> Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
> ---
>  init/Kconfig | 50 ++++++++++++++++++++++++++++++++++++++++++++++++++
>  1 file changed, 50 insertions(+)
>
> diff --git a/init/Kconfig b/init/Kconfig
> index 9834dbb0ddae..9599d2de44e8 100644
> --- a/init/Kconfig
> +++ b/init/Kconfig
> @@ -1740,6 +1740,56 @@ config USED_SYSCALLS
>
>           If unsure, please disable TRIM_UNUSED_SYSCALLS.
>
> +choice
> +       prompt "Trim methods" if EXPERT
> +       default RESTRICTED_TRIM_UNUSED_SYSCALLS
> +       depends on TRIM_UNUSED_SYSCALLS
> +       help
> +         This option selects the method to trim unused syscall wrongly kept.
> +
> +         The binary files compiled using both methods are identical.
> +
> +         If the trim methods is not specified, some syscalls are kept by
> +         linker script and can not be trimmed.
> +
> +config RESTRICTED_TRIM_UNUSED_SYSCALLS
> +       bool "Leave some kept syscalls (EXPERIMENTAL)" if EXPERT
> +       help
> +         Say Y here to trim 'unused' syscalls wrongly kept by __ex_table
> +         like sections in kernel space.
> +
> +         Some syscalls are kept by linker script and can not be trimmed.
> +
> +         If unsure, choose this.
> +
> +config SECTION_SHF_LINK_ORDER_SUPPORT
> +       bool "Using SHF_LINK_ORDER attribute (EXPERIMENTAL)" if EXPERT
> +       depends on HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
> +       help
> +         Say Y here to trim more 'unused' syscalls wrongly kept by __ex_table
> +         like sections in kernel space.

SHF_LINK_ORDER can be used for other metadata sections. The help
message reads as that __ex_table is the only use case.
It can be rephrased to us __ex_table as an example.

> +         This option uses the SHF_LINK_ORDER attribute to build references for
> +         orphan sections. Therefore, these sections are no longer kept in the
> +         linker script.

https://sourceware.org/binutils/docs/ld/Orphan-Sections.html
"Orphan sections are sections present in the input files which are not
explicitly placed into the output file by the linker script."

If the linker script still references the relevant sections, they are
not orphan.
I think it's best to focus on the semantics (metadata sections),
rather than the linker input property (orphan).

Suggest:

This option allows the use of SHF_LINK_ORDER to mark a metadata
section as discardable when the linker discards its referenced
section.
The linker semantics require that the metadata section is not
referenced by any other section.

> +         If unsure, not choose this.
> +


> +config SECTION_SHF_GROUP_SUPPORT
> +       bool "Using SHF_GROUP attribute (EXPERIMENTAL)" if EXPERT
> +       depends on HAVE_SECTION_SHF_GROUP_SUPPORT
> +       help
> +         Say Y here to trim more 'unused' syscalls wrongly kept by __ex_table
> +         like sections in kernel space.
> +
> +         This option uses the SHF_GROUP attribute to build references for
> +         orphan sections. Therefore, these sections are no longer kept in the
> +         linker script.
> +
> +         If unsure, not choose this.
> +
> +endchoice
> +

SHF_GROUP has size overhead in relocatable object files. If
SHF_LINK_ORDER works for __extable, I suggest that we postpone
SECTION_SHF_GROUP_SUPPORT until it is absolutely needed.

As I mentioned in a binutils thread, .attach_to_group is not supported
by LLVM integrated assembler and it could be tricky to implement.
The toolchain requirement (2020) is no better than SHF_LINK_ORDER.

>  config KALLSYMS
>         bool "Load all symbols for debugging/ksymoops" if EXPERT
>         default y
> --
> 2.34.1
>
================================================================================

From: Fangrui Song <i () maskray ! me>
To: linux-kernel
Subject: Re: [PATCH v1 08/14] DCE/DSE: add choice of methods to build reference for orphan sections
Date: Sun, 05 Nov 2023 21:35:11 +0000
Message-ID: <DS7PR12MB576555798778F91D449FD5C9CBABA () DS7PR12MB5765 ! namprd12 ! prod ! outlook ! com>
--------------------
On Fri, Nov 3, 2023 at 9:01â¯AM Yuan Tan <tanyuan@tinylab.org> wrote:
>
> Due to .pushsection producing orphan sections, the kernel currently uses
> `KEEP()` in the linker script to address this issue.
>
> Here we purpose two methods to build reference for pushed section,
> SHF_LINK_ORDER method and SECTION_SHF_GROUP method.
>
> The binary files compiled using both methods turn out to be identical,
> and it doesn't produce any side effects.
>
> Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
> Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
> ---
>  init/Kconfig | 50 ++++++++++++++++++++++++++++++++++++++++++++++++++
>  1 file changed, 50 insertions(+)
>
> diff --git a/init/Kconfig b/init/Kconfig
> index 9834dbb0ddae..9599d2de44e8 100644
> --- a/init/Kconfig
> +++ b/init/Kconfig
> @@ -1740,6 +1740,56 @@ config USED_SYSCALLS
>
>           If unsure, please disable TRIM_UNUSED_SYSCALLS.
>
> +choice
> +       prompt "Trim methods" if EXPERT
> +       default RESTRICTED_TRIM_UNUSED_SYSCALLS
> +       depends on TRIM_UNUSED_SYSCALLS
> +       help
> +         This option selects the method to trim unused syscall wrongly kept.
> +
> +         The binary files compiled using both methods are identical.
> +
> +         If the trim methods is not specified, some syscalls are kept by
> +         linker script and can not be trimmed.
> +
> +config RESTRICTED_TRIM_UNUSED_SYSCALLS
> +       bool "Leave some kept syscalls (EXPERIMENTAL)" if EXPERT
> +       help
> +         Say Y here to trim 'unused' syscalls wrongly kept by __ex_table
> +         like sections in kernel space.
> +
> +         Some syscalls are kept by linker script and can not be trimmed.
> +
> +         If unsure, choose this.
> +
> +config SECTION_SHF_LINK_ORDER_SUPPORT
> +       bool "Using SHF_LINK_ORDER attribute (EXPERIMENTAL)" if EXPERT
> +       depends on HAVE_SECTION_SHF_LINK_ORDER_SUPPORT
> +       help
> +         Say Y here to trim more 'unused' syscalls wrongly kept by __ex_table
> +         like sections in kernel space.

SHF_LINK_ORDER can be used for other metadata sections. The help
message reads as that __ex_table is the only use case.
It can be rephrased to us __ex_table as an example.

> +         This option uses the SHF_LINK_ORDER attribute to build references for
> +         orphan sections. Therefore, these sections are no longer kept in the
> +         linker script.

https://sourceware.org/binutils/docs/ld/Orphan-Sections.html
"Orphan sections are sections present in the input files which are not
explicitly placed into the output file by the linker script."

If the linker script still references the relevant sections, they are
not orphan.
I think it's best to focus on the semantics (metadata sections),
rather than the linker input property (orphan).

Suggest:

This option allows the use of SHF_LINK_ORDER to mark a metadata
section as discardable when the linker discards its referenced
section.
The linker semantics require that the metadata section is not
referenced by any other section.

> +         If unsure, not choose this.
> +


> +config SECTION_SHF_GROUP_SUPPORT
> +       bool "Using SHF_GROUP attribute (EXPERIMENTAL)" if EXPERT
> +       depends on HAVE_SECTION_SHF_GROUP_SUPPORT
> +       help
> +         Say Y here to trim more 'unused' syscalls wrongly kept by __ex_table
> +         like sections in kernel space.
> +
> +         This option uses the SHF_GROUP attribute to build references for
> +         orphan sections. Therefore, these sections are no longer kept in the
> +         linker script.
> +
> +         If unsure, not choose this.
> +
> +endchoice
> +

SHF_GROUP has size overhead in relocatable object files. If
SHF_LINK_ORDER works for __extable, I suggest that we postpone
SECTION_SHF_GROUP_SUPPORT until it is absolutely needed.

As I mentioned in a binutils thread, .attach_to_group is not supported
by LLVM integrated assembler and it could be tricky to implement.
The toolchain requirement (2020) is no better than SHF_LINK_ORDER.

>  config KALLSYMS
>         bool "Load all symbols for debugging/ksymoops" if EXPERT
>         default y
> --
> 2.34.1
>
================================================================================


################################################################################

=== Thread: [PATCH v1 09/14] DCE/DSE: inhibit .size directive for SHF_GROUP ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: Re: [PATCH v1 09/14] DCE/DSE: inhibit .size directive for SHF_GROUP
Date: Mon, 13 Nov 2023 07:19:42 +0000
Message-ID: <20231113071942.35259-1-tanyuan () tinylab ! org>
--------------------
Hi, Fangrui

Thank you for your time :)

On 11/6/2023 4:50 AM, Fangrui Song wrote:
> On Fri, Nov 3, 2023 at 9:01â¯AM Yuan Tan <tanyuan@tinylab.org> wrote:
> >
> > .size directive fails in some functions with SHF_GROUP, this is not
> > really required for normal building, inhibit it to silence the compiling
> > failures with SHF_GROUP.
> >
> > Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
> > Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
> > ---
> >  Makefile | 3 +++
> >  1 file changed, 3 insertions(+)
> >
> > diff --git a/Makefile b/Makefile
> > index a4e522b747cb..f67b6e8d2c45 100644
> > --- a/Makefile
> > +++ b/Makefile
> > @@ -936,6 +936,9 @@ endif
> >  # `rustc`'s `-Zfunction-sections` applies to data too (as of 1.59.0).
> >  ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION
> >  KBUILD_CFLAGS_KERNEL += -ffunction-sections -fdata-sections
> > +ifdef CONFIG_SECTION_SHF_GROUP_SUPPORT
> > +KBUILD_CFLAGS_KERNEL += -finhibit-size-directive
> > +endif
> >  KBUILD_RUSTFLAGS_KERNEL += -Zfunction-sections=y
> >  LDFLAGS_vmlinux += --gc-sections
> >  ifdef CONFIG_LD_DEAD_CODE_DATA_ELIMINATION_DEBUG
> > --
> > 2.34.1
> >
> 
> Clang doesn't support -finhibit-size-directive, so this would break
> Clang builds.

Currently, Clang doesn't support LD_DEAD_CODE_DATA_ELIMINATION. So in this
patch series I didn't take much thought about clang.

> 
> GCC has had this option since 1992, but it is not used in the wild.
> https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-finhibit-size-directive
> says
> 
> > ... This option is used when compiling crtstuff.c; you should not need to use it for anything else.
> 
> What problem have you seen with .size directives (st_size field in
> symbol table entries)?

$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- fs/ioctl.o
/tmp/ccy5E3wN.s: Error: .size expression for __riscv_sys_ioctl does not evaluate to a constant
make[3]: *** [scripts/Makefile.build:243: fs/ioctl.o] Error 1
make[2]: *** [scripts/Makefile.build:480: fs] Error 2
make[1]: *** [/home/tanyuan/projects/linux/Makefile:1916: .] Error 2
make: *** [Makefile:234: __sub-make] Error 2

And the fs/ioctl.s is like
	.section	.text.__riscv_sys_ioctl,"ax",@progbits
	.align	1
	.globl	__riscv_sys_ioctl
	.type	__riscv_sys_ioctl, @function
__riscv_sys_ioctl:
        ...
        ...
	.size	__riscv_sys_ioctl, .-__riscv_sys_ioctl

I cannot understand this error and this option just solve the problem :)

> 
> % cat a.c
> int v;
> void f() {}
> % diff -u0 <(gcc -S a.c -o -) <(gcc -S -finhibit-size-directive a.c -o -)
> --- /proc/self/fd/11    2023-11-05 12:42:51.298618475 -0800
> +++ /proc/self/fd/15    2023-11-05 12:42:51.298618475 -0800
> @@ -7 +6,0 @@
> -       .size   v, 4
> @@ -27 +25,0 @@
> -       .size   f, .-f
> 
> 
================================================================================


################################################################################

=== Thread: [PATCH v1 10/14] DCE/DSE: riscv: make every ex_table's name unique ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 10/14] DCE/DSE: riscv: make every ex_table's name unique
Date: Fri, 03 Nov 2023 15:59:20 +0000
Message-ID: <f0ee9abfd8d7b27489a4efe3196813225ce5680f.1699025537.git.tanyuan () tinylab ! org>
--------------------
gc-sections require section names to be unique.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 arch/riscv/include/asm/asm-extable.h | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/arch/riscv/include/asm/asm-extable.h b/arch/riscv/include/asm/asm-extable.h
index 00a96e7a9664..d0be5a838242 100644
--- a/arch/riscv/include/asm/asm-extable.h
+++ b/arch/riscv/include/asm/asm-extable.h
@@ -9,10 +9,12 @@
 
 #ifdef CONFIG_MMU
 
+#include <linux/compiler.h>
+
 #ifdef __ASSEMBLY__
 
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	.pushsection	__ex_table, "a";		\
+	.pushsection	__SECTION_NAME(__ex_table), "a";		\
 	.balign		4;				\
 	.long		((insn) - .);			\
 	.long		((fixup) - .);			\
@@ -31,7 +33,7 @@
 #include <asm/gpr-num.h>
 
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	".pushsection	__ex_table, \"a\"\n"		\
+	".pushsection "	__SECTION_NAME(__ex_table) ", \"a\"\n"		\
 	".balign	4\n"				\
 	".long		((" insn ") - .)\n"		\
 	".long		((" fixup ") - .)\n"		\
-- 
2.34.1

================================================================================

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-kernel
Subject: [PATCH v1 10/14] DCE/DSE: riscv: make every ex_table's name unique
Date: Fri, 03 Nov 2023 15:59:28 +0000
Message-ID: <f0ee9abfd8d7b27489a4efe3196813225ce5680f.1699025537.git.tanyuan () tinylab ! org>
--------------------
gc-sections require section names to be unique.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 arch/riscv/include/asm/asm-extable.h | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/arch/riscv/include/asm/asm-extable.h b/arch/riscv/include/asm/asm-extable.h
index 00a96e7a9664..d0be5a838242 100644
--- a/arch/riscv/include/asm/asm-extable.h
+++ b/arch/riscv/include/asm/asm-extable.h
@@ -9,10 +9,12 @@
 
 #ifdef CONFIG_MMU
 
+#include <linux/compiler.h>
+
 #ifdef __ASSEMBLY__
 
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	.pushsection	__ex_table, "a";		\
+	.pushsection	__SECTION_NAME(__ex_table), "a";		\
 	.balign		4;				\
 	.long		((insn) - .);			\
 	.long		((fixup) - .);			\
@@ -31,7 +33,7 @@
 #include <asm/gpr-num.h>
 
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	".pushsection	__ex_table, \"a\"\n"		\
+	".pushsection "	__SECTION_NAME(__ex_table) ", \"a\"\n"		\
 	".balign	4\n"				\
 	".long		((" insn ") - .)\n"		\
 	".long		((" fixup ") - .)\n"		\
-- 
2.34.1

================================================================================

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 10/14] DCE/DSE: riscv: make every ex_table's name unique
Date: Fri, 03 Nov 2023 15:59:57 +0000
Message-ID: <f0ee9abfd8d7b27489a4efe3196813225ce5680f.1699025537.git.tanyuan () tinylab ! org>
--------------------
gc-sections require section names to be unique.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 arch/riscv/include/asm/asm-extable.h | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/arch/riscv/include/asm/asm-extable.h b/arch/riscv/include/asm/asm-extable.h
index 00a96e7a9664..d0be5a838242 100644
--- a/arch/riscv/include/asm/asm-extable.h
+++ b/arch/riscv/include/asm/asm-extable.h
@@ -9,10 +9,12 @@
 
 #ifdef CONFIG_MMU
 
+#include <linux/compiler.h>
+
 #ifdef __ASSEMBLY__
 
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	.pushsection	__ex_table, "a";		\
+	.pushsection	__SECTION_NAME(__ex_table), "a";		\
 	.balign		4;				\
 	.long		((insn) - .);			\
 	.long		((fixup) - .);			\
@@ -31,7 +33,7 @@
 #include <asm/gpr-num.h>
 
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	".pushsection	__ex_table, \"a\"\n"		\
+	".pushsection "	__SECTION_NAME(__ex_table) ", \"a\"\n"		\
 	".balign	4\n"				\
 	".long		((" insn ") - .)\n"		\
 	".long		((" fixup ") - .)\n"		\
-- 
2.34.1

================================================================================

From: Fangrui Song <i () maskray ! me>
To: linux-sparse
Subject: Re: [PATCH v1 10/14] DCE/DSE: riscv: make every ex_table's name unique
Date: Sun, 05 Nov 2023 21:13:47 +0000
Message-ID: <DS7PR12MB57652C7C17103B3FF729BD79CBABA () DS7PR12MB5765 ! namprd12 ! prod ! outlook ! com>
--------------------
On Fri, Nov 3, 2023 at 9:02â¯AM Yuan Tan <tanyuan@tinylab.org> wrote:
>
> gc-sections require section names to be unique.

This is not precise, since a monolithic section can be garbage
collected as well.

https://maskray.me/blog/2021-02-28-linker-garbage-collection

"Without the options, the compiler tends to produce monolithic text
and data sections. The large sections make the GC coarse-grained and
they will likely be retained as a whole. ld --gc-sections can still
discard some sections, but the effect is likely very poor."


> Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
> Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
> ---
>  arch/riscv/include/asm/asm-extable.h | 6 ++++--
>  1 file changed, 4 insertions(+), 2 deletions(-)
>
> diff --git a/arch/riscv/include/asm/asm-extable.h b/arch/riscv/include/asm/asm-extable.h
> index 00a96e7a9664..d0be5a838242 100644
> --- a/arch/riscv/include/asm/asm-extable.h
> +++ b/arch/riscv/include/asm/asm-extable.h
> @@ -9,10 +9,12 @@
>
>  #ifdef CONFIG_MMU
>
> +#include <linux/compiler.h>
> +
>  #ifdef __ASSEMBLY__
>
>  #define __ASM_EXTABLE_RAW(insn, fixup, type, data)     \
> -       .pushsection    __ex_table, "a";                \
> +       .pushsection    __SECTION_NAME(__ex_table), "a";                \
>         .balign         4;                              \
>         .long           ((insn) - .);                   \
>         .long           ((fixup) - .);                  \
> @@ -31,7 +33,7 @@
>  #include <asm/gpr-num.h>

__SECTION_NAME is probably added by a previous patch.
An alternative is to use the .section directive's `unique` feature
(binutils>=2.35).

>  #define __ASM_EXTABLE_RAW(insn, fixup, type, data)     \
> -       ".pushsection   __ex_table, \"a\"\n"            \
> +       ".pushsection " __SECTION_NAME(__ex_table) ", \"a\"\n"          \
>         ".balign        4\n"                            \
>         ".long          ((" insn ") - .)\n"             \
>         ".long          ((" fixup ") - .)\n"            \
> --
> 2.34.1
>
================================================================================

From: Fangrui Song <i () maskray ! me>
To: linux-kernel
Subject: Re: [PATCH v1 10/14] DCE/DSE: riscv: make every ex_table's name unique
Date: Sun, 05 Nov 2023 21:13:47 +0000
Message-ID: <DS7PR12MB57652C7C17103B3FF729BD79CBABA () DS7PR12MB5765 ! namprd12 ! prod ! outlook ! com>
--------------------
On Fri, Nov 3, 2023 at 9:02â¯AM Yuan Tan <tanyuan@tinylab.org> wrote:
>
> gc-sections require section names to be unique.

This is not precise, since a monolithic section can be garbage
collected as well.

https://maskray.me/blog/2021-02-28-linker-garbage-collection

"Without the options, the compiler tends to produce monolithic text
and data sections. The large sections make the GC coarse-grained and
they will likely be retained as a whole. ld --gc-sections can still
discard some sections, but the effect is likely very poor."


> Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
> Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
> ---
>  arch/riscv/include/asm/asm-extable.h | 6 ++++--
>  1 file changed, 4 insertions(+), 2 deletions(-)
>
> diff --git a/arch/riscv/include/asm/asm-extable.h b/arch/riscv/include/asm/asm-extable.h
> index 00a96e7a9664..d0be5a838242 100644
> --- a/arch/riscv/include/asm/asm-extable.h
> +++ b/arch/riscv/include/asm/asm-extable.h
> @@ -9,10 +9,12 @@
>
>  #ifdef CONFIG_MMU
>
> +#include <linux/compiler.h>
> +
>  #ifdef __ASSEMBLY__
>
>  #define __ASM_EXTABLE_RAW(insn, fixup, type, data)     \
> -       .pushsection    __ex_table, "a";                \
> +       .pushsection    __SECTION_NAME(__ex_table), "a";                \
>         .balign         4;                              \
>         .long           ((insn) - .);                   \
>         .long           ((fixup) - .);                  \
> @@ -31,7 +33,7 @@
>  #include <asm/gpr-num.h>

__SECTION_NAME is probably added by a previous patch.
An alternative is to use the .section directive's `unique` feature
(binutils>=2.35).

>  #define __ASM_EXTABLE_RAW(insn, fixup, type, data)     \
> -       ".pushsection   __ex_table, \"a\"\n"            \
> +       ".pushsection " __SECTION_NAME(__ex_table) ", \"a\"\n"          \
>         ".balign        4\n"                            \
>         ".long          ((" insn ") - .)\n"             \
>         ".long          ((" fixup ") - .)\n"            \
> --
> 2.34.1
>
================================================================================


################################################################################

=== Thread: [PATCH v1 11/14] DCE/DSE: riscv: build reference for .pushsection in C functions ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 11/14] DCE/DSE: riscv: build reference for .pushsection in C functions
Date: Fri, 03 Nov 2023 16:02:50 +0000
Message-ID: <ab9af3f07b520c8679a586770e3d488cb4866e8e.1699025537.git.tanyuan () tinylab ! org>
--------------------
Add the SECTION_SHF_LINK_ORDER method and the SECTION_SHF_GROUP method
to refactor __ASM_EXTABLE_RAW, so it won't produce orphan sections
anymore.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 arch/riscv/include/asm/asm-extable.h | 34 ++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/arch/riscv/include/asm/asm-extable.h b/arch/riscv/include/asm/asm-extable.h
index d0be5a838242..7164d871e038 100644
--- a/arch/riscv/include/asm/asm-extable.h
+++ b/arch/riscv/include/asm/asm-extable.h
@@ -13,6 +13,21 @@
 
 #ifdef __ASSEMBLY__
 
+#if defined(CONFIG_SECTION_SHF_LINK_ORDER_SUPPORT)
+#define __ASM_EXTABLE_PUSH_SECTION			\
+	__LABEL_NAME(.L__ex_table) :			\
+	.pushsection __SECTION_NAME(__ex_table), "ao", __LABEL_NAME(.L__ex_table)
+
+#elif defined(CONFIG_SECTION_SHF_GROUP_SUPPORT)
+#define __ASM_EXTABLE_PUSH_SECTION			\
+	.attach_to_group __SECTION_NAME(__ex_table);	\
+	.pushsection __SECTION_NAME(__ex_table), "a?"
+
+#else
+#define __ASM_EXTABLE_PUSH_SECTION			\
+	.pushsection __SECTION_NAME(__ex_table), "a"
+#endif
+
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
 	.pushsection	__SECTION_NAME(__ex_table), "a";		\
 	.balign		4;				\
@@ -32,8 +47,23 @@
 #include <linux/stringify.h>
 #include <asm/gpr-num.h>
 
-#define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	".pushsection "	__SECTION_NAME(__ex_table) ", \"a\"\n"		\
+#ifdef CONFIG_SECTION_SHF_LINK_ORDER_SUPPORT
+#define __ASM_EXTABLE_PUSH_SECTION				\
+	__LABEL_NAME(.L__ex_table) ":"				\
+	".pushsection "	__SECTION_NAME(__ex_table) ", \"ao\"," __LABEL_NAME(.L__ex_table) "\n"
+
+#elif defined(CONFIG_SECTION_SHF_GROUP_SUPPORT)
+#define __ASM_EXTABLE_PUSH_SECTION				\
+	".attach_to_group " __SECTION_NAME(__ex_table) "\n"	\
+	".pushsection "	__SECTION_NAME(__ex_table) ", \"a?\"\n"
+
+#else
+#define __ASM_EXTABLE_PUSH_SECTION				\
+	".pushsection "	__SECTION_NAME(__ex_table) ", \"a\"\n"
+#endif
+
+#define __ASM_EXTABLE_RAW(insn, fixup, type, data)		\
+	__ASM_EXTABLE_PUSH_SECTION				\
 	".balign	4\n"				\
 	".long		((" insn ") - .)\n"		\
 	".long		((" fixup ") - .)\n"		\
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 12/14] DCE/DSE: riscv: build reference for .pushsection in assembly ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 12/14] DCE/DSE: riscv: build reference for .pushsection in assembly
Date: Fri, 03 Nov 2023 16:03:15 +0000
Message-ID: <26be8db18604f9a9e5eee9f03cc77ed034059d9a.1699025537.git.tanyuan () tinylab ! org>
--------------------
Add the SECTION_SHF_LINK_ORDER method and the SECTION_SHF_GROUP method
to refactor __ASM_EXTABLE_RAW, so it won't produce orphan sections
anymore.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 arch/riscv/include/asm/asm-extable.h |  7 ++--
 arch/riscv/lib/uaccess.S             | 60 ++++++++++++++--------------
 2 files changed, 32 insertions(+), 35 deletions(-)

diff --git a/arch/riscv/include/asm/asm-extable.h b/arch/riscv/include/asm/asm-extable.h
index 7164d871e038..99e472b7a1be 100644
--- a/arch/riscv/include/asm/asm-extable.h
+++ b/arch/riscv/include/asm/asm-extable.h
@@ -29,7 +29,7 @@
 #endif
 
 #define __ASM_EXTABLE_RAW(insn, fixup, type, data)	\
-	.pushsection	__SECTION_NAME(__ex_table), "a";		\
+	__ASM_EXTABLE_PUSH_SECTION;			\
 	.balign		4;				\
 	.long		((insn) - .);			\
 	.long		((fixup) - .);			\
@@ -37,9 +37,8 @@
 	.short		(data);				\
 	.popsection;
 
-	.macro		_asm_extable, insn, fixup
-	__ASM_EXTABLE_RAW(\insn, \fixup, EX_TYPE_FIXUP, 0)
-	.endm
+#define _asm_extable(insn, fixup)			\
+	__ASM_EXTABLE_RAW(insn, fixup, EX_TYPE_FIXUP, 0)
 
 #else /* __ASSEMBLY__ */
 
diff --git a/arch/riscv/lib/uaccess.S b/arch/riscv/lib/uaccess.S
index 09b47ebacf2e..91c76d3fbe2f 100644
--- a/arch/riscv/lib/uaccess.S
+++ b/arch/riscv/lib/uaccess.S
@@ -4,11 +4,9 @@
 #include <asm/asm-extable.h>
 #include <asm/csr.h>
 
-	.macro fixup op reg addr lbl
-100:
-	\op \reg, \addr
-	_asm_extable	100b, \lbl
-	.endm
+#define fixup(op, reg, addr, lbl)	\
+	100: op reg, addr;		\
+	_asm_extable(100b, lbl)
 
 ENTRY(__asm_copy_to_user)
 ENTRY(__asm_copy_from_user)
@@ -50,9 +48,9 @@ ENTRY(__asm_copy_from_user)
 	beq	a0, t1, .Lskip_align_dst
 1:
 	/* a5 - one byte for copying data */
-	fixup lb      a5, 0(a1), 10f
+	fixup(lb, a5, 0(a1), 10f)
 	addi	a1, a1, 1	/* src */
-	fixup sb      a5, 0(a0), 10f
+	fixup(sb, a5, 0(a0), 10f)
 	addi	a0, a0, 1	/* dst */
 	bltu	a0, t1, 1b	/* t1 - start of aligned dst */
 
@@ -77,22 +75,22 @@ ENTRY(__asm_copy_from_user)
 	 */
 	addi	t0, t0, -(8*SZREG) /* not to over run */
 2:
-	fixup REG_L   a4,        0(a1), 10f
-	fixup REG_L   a5,    SZREG(a1), 10f
-	fixup REG_L   a6,  2*SZREG(a1), 10f
-	fixup REG_L   a7,  3*SZREG(a1), 10f
-	fixup REG_L   t1,  4*SZREG(a1), 10f
-	fixup REG_L   t2,  5*SZREG(a1), 10f
-	fixup REG_L   t3,  6*SZREG(a1), 10f
-	fixup REG_L   t4,  7*SZREG(a1), 10f
-	fixup REG_S   a4,        0(a0), 10f
-	fixup REG_S   a5,    SZREG(a0), 10f
-	fixup REG_S   a6,  2*SZREG(a0), 10f
-	fixup REG_S   a7,  3*SZREG(a0), 10f
-	fixup REG_S   t1,  4*SZREG(a0), 10f
-	fixup REG_S   t2,  5*SZREG(a0), 10f
-	fixup REG_S   t3,  6*SZREG(a0), 10f
-	fixup REG_S   t4,  7*SZREG(a0), 10f
+	fixup(REG_L, a4,        0(a1), 10f)
+	fixup(REG_L, a5,    SZREG(a1), 10f)
+	fixup(REG_L, a6,  2*SZREG(a1), 10f)
+	fixup(REG_L, a7,  3*SZREG(a1), 10f)
+	fixup(REG_L, t1,  4*SZREG(a1), 10f)
+	fixup(REG_L, t2,  5*SZREG(a1), 10f)
+	fixup(REG_L, t3,  6*SZREG(a1), 10f)
+	fixup(REG_L, t4,  7*SZREG(a1), 10f)
+	fixup(REG_S, a4,        0(a0), 10f)
+	fixup(REG_S, a5,    SZREG(a0), 10f)
+	fixup(REG_S, a6,  2*SZREG(a0), 10f)
+	fixup(REG_S, a7,  3*SZREG(a0), 10f)
+	fixup(REG_S, t1,  4*SZREG(a0), 10f)
+	fixup(REG_S, t2,  5*SZREG(a0), 10f)
+	fixup(REG_S, t3,  6*SZREG(a0), 10f)
+	fixup(REG_S, t4,  7*SZREG(a0), 10f)
 	addi	a0, a0, 8*SZREG
 	addi	a1, a1, 8*SZREG
 	bltu	a0, t0, 2b
@@ -130,7 +128,7 @@ ENTRY(__asm_copy_from_user)
 	sub	t4, a5, t3
 
 	/* Load the first word to combine with second word */
-	fixup REG_L   a5, 0(a1), 10f
+	fixup(REG_L, a5, 0(a1), 10f)
 
 3:
 	/* Main shifting copy
@@ -142,11 +140,11 @@ ENTRY(__asm_copy_from_user)
 
 	/* At least one iteration will be executed */
 	srl	a4, a5, t3
-	fixup REG_L   a5, SZREG(a1), 10f
+	fixup(REG_L, a5, SZREG(a1), 10f)
 	addi	a1, a1, SZREG
 	sll	a2, a5, t4
 	or	a2, a2, a4
-	fixup REG_S   a2, 0(a0), 10f
+	fixup(REG_S, a2, 0(a0), 10f)
 	addi	a0, a0, SZREG
 	bltu	a0, t1, 3b
 
@@ -163,9 +161,9 @@ ENTRY(__asm_copy_from_user)
 	 */
 	bgeu	a0, t0, .Lout_copy_user  /* check if end of copy */
 4:
-	fixup lb      a5, 0(a1), 10f
+	fixup(lb, a5, 0(a1), 10f)
 	addi	a1, a1, 1	/* src */
-	fixup sb      a5, 0(a0), 10f
+	fixup(sb, a5, 0(a0), 10f)
 	addi	a0, a0, 1	/* dst */
 	bltu	a0, t0, 4b	/* t0 - end of dst */
 
@@ -205,7 +203,7 @@ ENTRY(__clear_user)
 	bgeu t0, t1, 2f
 	bltu a0, t0, 4f
 1:
-	fixup REG_S, zero, (a0), 11f
+	fixup(REG_S, zero, (a0), 11f)
 	addi a0, a0, SZREG
 	bltu a0, t1, 1b
 2:
@@ -217,12 +215,12 @@ ENTRY(__clear_user)
 	li a0, 0
 	ret
 4: /* Edge case: unalignment */
-	fixup sb, zero, (a0), 11f
+	fixup(sb, zero, (a0), 11f)
 	addi a0, a0, 1
 	bltu a0, t0, 4b
 	j 1b
 5: /* Edge case: remainder */
-	fixup sb, zero, (a0), 11f
+	fixup(sb, zero, (a0), 11f)
 	addi a0, a0, 1
 	bltu a0, a3, 5b
 	j 3b
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v1 14/14] DCE/DSE: vmlinux.lds.h: allow NO_KEEP on __ex_table sections ===

From: Yuan Tan <tanyuan () tinylab ! org>
To: linux-sparse
Subject: [PATCH v1 14/14] DCE/DSE: vmlinux.lds.h: allow NO_KEEP on __ex_table sections
Date: Fri, 03 Nov 2023 16:04:48 +0000
Message-ID: <3acff566dc1818a36b32a34e25b0de58c5118ee6.1699025537.git.tanyuan () tinylab ! org>
--------------------
With SHF_LINK_ORDER or SHF_GROUP, all of the __extable sections are no
longer orphan sections. In this case, KEEP() is no longer needed.

Signed-off-by: Yuan Tan <tanyuan@tinylab.org>
Signed-off-by: Zhangjin Wu <falcon@tinylab.org>
---
 include/asm-generic/vmlinux.lds.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index f10afc42a1ac..e5e5850ea573 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -658,7 +658,7 @@
 #define EXCEPTION_TABLE(align)						\
 	. = ALIGN(align);						\
 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {		\
-		BOUNDED_SECTION_BY(__ex_table, ___ex_table)		\
+		BOUNDED_SECTION_BY(__ex_table, ___ex_table, NO_KEEP)		\
 	}
 
 /*
-- 
2.34.1

================================================================================


################################################################################

=== Thread: [PATCH v2] parse: handle __cleanup__ attribute ===

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH v2] parse: handle __cleanup__ attribute
Date: Mon, 18 Dec 2023 13:51:32 +0000
Message-ID: <troz4beymvsw2m4y4ocghwiidohi4nbj45ry2tfmbekanu2ray () ooravawiynxr>
--------------------
On Thu, Dec 14, 2023 at 04:20:20PM +0300, Dan Carpenter wrote:
> Yep.  Perfect.  Thanks so much!

Pushed now.
-- Luc 

================================================================================


################################################################################

=== Thread: [PATCH v4 18/21] compiler.h: RFC - s/__LINE__/__COUNTER__/ in __UNIQUE_ID fallback ===

From: Jim Cromie <jim.cromie () gmail ! com>
To: linux-sparse
Subject: [PATCH v4 18/21] compiler.h: RFC - s/__LINE__/__COUNTER__/ in __UNIQUE_ID fallback
Date: Thu, 13 Jul 2023 16:36:23 +0000
Message-ID: <20230713163626.31338-19-jim.cromie () gmail ! com>
--------------------
We currently have 3 defns for __UNIQUE_ID(); gcc and clang are using
__COUNTER__ for real uniqueness, 3rd just uses __LINE__, which should
fail on this (and harder to avoid situations):

  DECLARE_FOO(); DECLARE_FOO();

Its 2023, can we haz a no-fallback __UNIQUE_ID ?

NOTE:

This also changes __UNIQUE_ID_ to _kaUID_.  Ive been getting
lkp-reports of collisions on names which should be unique; this
shouldnt happen on gcc & clang, but does on some older ones, on some
platforms, on some allyes & rand-configs.  Like this:

mips64-linux-ld:
drivers/gpu/drm/display/drm_dp_helper.o:(__dyndbg_class_users+0x0):
multiple definition of `__UNIQUE_ID_ddebug_class_user405';
drivers/gpu/drm/drm_gem_shmem_helper.o:(__dyndbg_class_users+0x0):
first defined here

Like above, the collision reports appear to always be 3-digit
counters, which look like line-numbers.  Changing to _kaUID_ in this
defn should make it more obvious (in *.i file) when a fallback has
happened.  To be clear, I havent seen it yet.  Nor have I seen the
multiple-defn problem above since adding this patch.

Lets see what lkp-robot says about this.

CC: Luc Van Oostenryck <luc.vanoostenryck@gmail.com> (maintainer:SPARSE CHECKER)
CC: Nathan Chancellor <nathan@kernel.org> (supporter:CLANG/LLVM BUILD SUPPORT)
CC: Nick Desaulniers <ndesaulniers@google.com> (supporter:CLANG/LLVM BUILD SUPPORT)
CC: Tom Rix <trix@redhat.com> (reviewer:CLANG/LLVM BUILD SUPPORT)
CC: linux-sparse@vger.kernel.org (open list:SPARSE CHECKER)
CC: linux-kernel@vger.kernel.org (open list)
CC: llvm@lists.linux.dev (open list:CLANG/LLVM BUILD SUPPORT)
Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
---
 include/linux/compiler.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index d7779a18b24f..677d6c47cd9e 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -177,9 +177,9 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 	__asm__ ("" : "=r" (var) : "0" (var))
 #endif
 
-/* Not-quite-unique ID. */
+/* JFTI: to fix Not-quite-unique ID */
 #ifndef __UNIQUE_ID
-# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)
+# define __UNIQUE_ID(prefix) __PASTE(__PASTE(_kaUID_, prefix), __COUNTER__)
 #endif
 
 /**
-- 
2.41.0

================================================================================

From: Jim Cromie <jim.cromie () gmail ! com>
To: dri-devel
Subject: [PATCH v4 18/21] compiler.h: RFC - s/__LINE__/__COUNTER__/ in __UNIQUE_ID fallback
Date: Thu, 13 Jul 2023 16:36:23 +0000
Message-ID: <20230713163626.31338-19-jim.cromie () gmail ! com>
--------------------
We currently have 3 defns for __UNIQUE_ID(); gcc and clang are using
__COUNTER__ for real uniqueness, 3rd just uses __LINE__, which should
fail on this (and harder to avoid situations):

  DECLARE_FOO(); DECLARE_FOO();

Its 2023, can we haz a no-fallback __UNIQUE_ID ?

NOTE:

This also changes __UNIQUE_ID_ to _kaUID_.  Ive been getting
lkp-reports of collisions on names which should be unique; this
shouldnt happen on gcc & clang, but does on some older ones, on some
platforms, on some allyes & rand-configs.  Like this:

mips64-linux-ld:
drivers/gpu/drm/display/drm_dp_helper.o:(__dyndbg_class_users+0x0):
multiple definition of `__UNIQUE_ID_ddebug_class_user405';
drivers/gpu/drm/drm_gem_shmem_helper.o:(__dyndbg_class_users+0x0):
first defined here

Like above, the collision reports appear to always be 3-digit
counters, which look like line-numbers.  Changing to _kaUID_ in this
defn should make it more obvious (in *.i file) when a fallback has
happened.  To be clear, I havent seen it yet.  Nor have I seen the
multiple-defn problem above since adding this patch.

Lets see what lkp-robot says about this.

CC: Luc Van Oostenryck <luc.vanoostenryck@gmail.com> (maintainer:SPARSE CHECKER)
CC: Nathan Chancellor <nathan@kernel.org> (supporter:CLANG/LLVM BUILD SUPPORT)
CC: Nick Desaulniers <ndesaulniers@google.com> (supporter:CLANG/LLVM BUILD SUPPORT)
CC: Tom Rix <trix@redhat.com> (reviewer:CLANG/LLVM BUILD SUPPORT)
CC: linux-sparse@vger.kernel.org (open list:SPARSE CHECKER)
CC: linux-kernel@vger.kernel.org (open list)
CC: llvm@lists.linux.dev (open list:CLANG/LLVM BUILD SUPPORT)
Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
---
 include/linux/compiler.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index d7779a18b24f..677d6c47cd9e 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -177,9 +177,9 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 	__asm__ ("" : "=r" (var) : "0" (var))
 #endif
 
-/* Not-quite-unique ID. */
+/* JFTI: to fix Not-quite-unique ID */
 #ifndef __UNIQUE_ID
-# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)
+# define __UNIQUE_ID(prefix) __PASTE(__PASTE(_kaUID_, prefix), __COUNTER__)
 #endif
 
 /**
-- 
2.41.0

================================================================================

From: Jim Cromie <jim.cromie () gmail ! com>
To: linux-kernel
Subject: [PATCH v4 18/21] compiler.h: RFC - s/__LINE__/__COUNTER__/ in __UNIQUE_ID fallback
Date: Thu, 13 Jul 2023 16:36:23 +0000
Message-ID: <20230713163626.31338-19-jim.cromie () gmail ! com>
--------------------
We currently have 3 defns for __UNIQUE_ID(); gcc and clang are using
__COUNTER__ for real uniqueness, 3rd just uses __LINE__, which should
fail on this (and harder to avoid situations):

  DECLARE_FOO(); DECLARE_FOO();

Its 2023, can we haz a no-fallback __UNIQUE_ID ?

NOTE:

This also changes __UNIQUE_ID_ to _kaUID_.  Ive been getting
lkp-reports of collisions on names which should be unique; this
shouldnt happen on gcc & clang, but does on some older ones, on some
platforms, on some allyes & rand-configs.  Like this:

mips64-linux-ld:
drivers/gpu/drm/display/drm_dp_helper.o:(__dyndbg_class_users+0x0):
multiple definition of `__UNIQUE_ID_ddebug_class_user405';
drivers/gpu/drm/drm_gem_shmem_helper.o:(__dyndbg_class_users+0x0):
first defined here

Like above, the collision reports appear to always be 3-digit
counters, which look like line-numbers.  Changing to _kaUID_ in this
defn should make it more obvious (in *.i file) when a fallback has
happened.  To be clear, I havent seen it yet.  Nor have I seen the
multiple-defn problem above since adding this patch.

Lets see what lkp-robot says about this.

CC: Luc Van Oostenryck <luc.vanoostenryck@gmail.com> (maintainer:SPARSE CHECKER)
CC: Nathan Chancellor <nathan@kernel.org> (supporter:CLANG/LLVM BUILD SUPPORT)
CC: Nick Desaulniers <ndesaulniers@google.com> (supporter:CLANG/LLVM BUILD SUPPORT)
CC: Tom Rix <trix@redhat.com> (reviewer:CLANG/LLVM BUILD SUPPORT)
CC: linux-sparse@vger.kernel.org (open list:SPARSE CHECKER)
CC: linux-kernel@vger.kernel.org (open list)
CC: llvm@lists.linux.dev (open list:CLANG/LLVM BUILD SUPPORT)
Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
---
 include/linux/compiler.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index d7779a18b24f..677d6c47cd9e 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -177,9 +177,9 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 	__asm__ ("" : "=r" (var) : "0" (var))
 #endif
 
-/* Not-quite-unique ID. */
+/* JFTI: to fix Not-quite-unique ID */
 #ifndef __UNIQUE_ID
-# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)
+# define __UNIQUE_ID(prefix) __PASTE(__PASTE(_kaUID_, prefix), __COUNTER__)
 #endif
 
 /**
-- 
2.41.0

================================================================================

From: Nathan Chancellor <nathan () kernel ! org>
To: linux-kernel
Subject: Re: [PATCH v4 18/21] compiler.h: RFC - s/__LINE__/__COUNTER__/ in __UNIQUE_ID fallback
Date: Thu, 13 Jul 2023 17:19:01 +0000
Message-ID: <20230713171901.GA4036397 () dev-arch ! thelio-3990X>
--------------------
Hi Jim

On Thu, Jul 13, 2023 at 10:36:23AM -0600, Jim Cromie wrote:
> We currently have 3 defns for __UNIQUE_ID(); gcc and clang are using
> __COUNTER__ for real uniqueness, 3rd just uses __LINE__, which should
> fail on this (and harder to avoid situations):
> 
>   DECLARE_FOO(); DECLARE_FOO();
> 
> Its 2023, can we haz a no-fallback __UNIQUE_ID ?

Yeah, I fail to see how this fallback definition can actually be used
after commit 95207db8166a ("Remove Intel compiler support"); even before
that, it would be pretty unlikely since icc usage has not been visible
for a long time. The kernel only officially supports clang or GCC now,
so the definitions of __UNIQUE_ID() in include/linux/compiler-clang.h
and include/linux/compiler-gcc.h should always be used because of the
include in include/linux/compiler_types.h, right?

I think the correct clean up is to just hoist the definition of
__UNIQUE_ID() out of the individual compiler headers into the common one
here but...

> NOTE:
> 
> This also changes __UNIQUE_ID_ to _kaUID_.  Ive been getting
> lkp-reports of collisions on names which should be unique; this
> shouldnt happen on gcc & clang, but does on some older ones, on some
> platforms, on some allyes & rand-configs.  Like this:
> 
> mips64-linux-ld:
> drivers/gpu/drm/display/drm_dp_helper.o:(__dyndbg_class_users+0x0):
> multiple definition of `__UNIQUE_ID_ddebug_class_user405';
> drivers/gpu/drm/drm_gem_shmem_helper.o:(__dyndbg_class_users+0x0):
> first defined here

This problem cannot be addressed with this patch given the above
information, no? Seems like that might mean that __COUNTER__ has issues
in earlier compilers?

Cheers,
Nathan

> Like above, the collision reports appear to always be 3-digit
> counters, which look like line-numbers.  Changing to _kaUID_ in this
> defn should make it more obvious (in *.i file) when a fallback has
> happened.  To be clear, I havent seen it yet.  Nor have I seen the
> multiple-defn problem above since adding this patch.
> 
> Lets see what lkp-robot says about this.
> 
> CC: Luc Van Oostenryck <luc.vanoostenryck@gmail.com> (maintainer:SPARSE CHECKER)
> CC: Nathan Chancellor <nathan@kernel.org> (supporter:CLANG/LLVM BUILD SUPPORT)
> CC: Nick Desaulniers <ndesaulniers@google.com> (supporter:CLANG/LLVM BUILD SUPPORT)
> CC: Tom Rix <trix@redhat.com> (reviewer:CLANG/LLVM BUILD SUPPORT)
> CC: linux-sparse@vger.kernel.org (open list:SPARSE CHECKER)
> CC: linux-kernel@vger.kernel.org (open list)
> CC: llvm@lists.linux.dev (open list:CLANG/LLVM BUILD SUPPORT)
> Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
> ---
>  include/linux/compiler.h | 4 ++--
>  1 file changed, 2 insertions(+), 2 deletions(-)
> 
> diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> index d7779a18b24f..677d6c47cd9e 100644
> --- a/include/linux/compiler.h
> +++ b/include/linux/compiler.h
> @@ -177,9 +177,9 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
>  	__asm__ ("" : "=r" (var) : "0" (var))
>  #endif
>  
> -/* Not-quite-unique ID. */
> +/* JFTI: to fix Not-quite-unique ID */
>  #ifndef __UNIQUE_ID
> -# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)
> +# define __UNIQUE_ID(prefix) __PASTE(__PASTE(_kaUID_, prefix), __COUNTER__)
>  #endif
>  
>  /**
> -- 
> 2.41.0
> 
================================================================================


################################################################################

=== Thread: [PATCH v8 07/12] landlock: Add network rules support ===

From: =?UTF-8?Q?Micka=c3=abl_Sala=c3=bcn?= <mic () digikod ! net>
To: linux-api
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Fri, 06 Jan 2023 19:22:35 +0000
Message-ID: <47fedda8-a13c-b62f-251f-b62508964bb0 () digikod ! net>
--------------------

On 04/01/2023 12:41, Konstantin Meskhidze (A) wrote:
> 
> 
> 11/17/2022 9:43 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:

[...]

>>>    /**
>>> @@ -79,6 +91,24 @@ struct landlock_path_beneath_attr {
>>>    	 */
>>>    } __attribute__((packed));
>>>
>>> +/**
>>> + * struct landlock_net_service_attr - TCP subnet definition
>>> + *
>>> + * Argument of sys_landlock_add_rule().
>>> + */
>>> +struct landlock_net_service_attr {
>>> +	/**
>>> +	 * @allowed_access: Bitmask of allowed access network for services
>>> +	 * (cf. `Network flags`_).
>>> +	 */
>>> +	__u64 allowed_access;
>>> +	/**
>>> +	 * @port: Network port.
>>> +	 */
>>> +	__u16 port;
>>
>>    From an UAPI point of view, I think the port field should be __be16, as
>> for sockaddr_in->port and other network-related APIs. This will require
>> some kernel changes to please sparse: make C=2 security/landlock/ must
>> not print any warning.
> 
>     I have this errors trying to launch sparse checking:
> 
>     DESCEND objtool
>     DESCEND bpf/resolve_btfids
>     CALL    scripts/checksyscalls.sh
>     CHK     kernel/kheaders_data.tar.xz
>     CC      security/landlock/setup.o
>     CHECK   security/landlock/setup.c
> ./include/asm-generic/rwonce.h:67:16: error: typename in expression
> ./include/asm-generic/rwonce.h:67:16: error: Expected ) in function call
> ./include/asm-generic/rwonce.h:67:16: error: got :
> ./include/linux/list.h:292:16: error: typename in expression
> ./include/linux/list.h:292:16: error: Expected ) in function call
> ./include/linux/list.h:292:16: error: got :
> 
> ....
> 
> ./include/linux/seqlock.h:682:16: error: Expected ) in function call
> ./include/linux/seqlock.h:682:16: error: got :
> ./include/linux/seqlock.h:695:16: error: typename in expression
> ./include/linux/seqlock.h:695:16: error: Expected ) in function call
> ./include/linux/seqlock.h:695:16: error: too many errors
> Segmentation fault (core dumped)
> make[3]: *** [scripts/Makefile.build:250: security/landlock/setup.o]
> Error 139
> make[3]: *** Deleting file 'security/landlock/setup.o'
> make[3]: *** Waiting for unfinished jobs....
> Segmentation fault (core dumped)
> make[3]: *** [scripts/Makefile.build:250: security/landlock/syscalls.o]
> Error 139
> make[3]: *** Deleting file 'security/landlock/syscalls.o'
> make[2]: *** [scripts/Makefile.build:502: security/landlock] Error 2
> make[1]: *** [scripts/Makefile.build:502: security] Error 2
> make[1]: *** Waiting for unfinished jobs....
> make: *** [Makefile:1994: .] Error 2

I don't know about this error. Did you follow the documentation?
https://docs.kernel.org/dev-tools/sparse.html#getting-sparse



>>
>> Using big-endian values as keys (casted to uintptr_t, not strictly
>> __be16) in the rb-tree should not be an issue because there is no port
>> range ordering (for now).
>>
>> A dedicated test should check that endianness is correct, e.g. by using
>> different port encoding. This should include passing and failing tests,
>> but they should work on all architectures (i.e. big or little endian).
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-netdev
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 07:59:43 +0000
Message-ID: <4aa29433-e7f9-f225-5bdf-c80638c936e8 () huawei ! com>
--------------------


1/6/2023 10:22 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> On 04/01/2023 12:41, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 11/17/2022 9:43 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> [...]
> 
>>>>    /**
>>>> @@ -79,6 +91,24 @@ struct landlock_path_beneath_attr {
>>>>    	 */
>>>>    } __attribute__((packed));
>>>>
>>>> +/**
>>>> + * struct landlock_net_service_attr - TCP subnet definition
>>>> + *
>>>> + * Argument of sys_landlock_add_rule().
>>>> + */
>>>> +struct landlock_net_service_attr {
>>>> +	/**
>>>> +	 * @allowed_access: Bitmask of allowed access network for services
>>>> +	 * (cf. `Network flags`_).
>>>> +	 */
>>>> +	__u64 allowed_access;
>>>> +	/**
>>>> +	 * @port: Network port.
>>>> +	 */
>>>> +	__u16 port;
>>>
>>>    From an UAPI point of view, I think the port field should be __be16, as
>>> for sockaddr_in->port and other network-related APIs. This will require
>>> some kernel changes to please sparse: make C=2 security/landlock/ must
>>> not print any warning.
>> 
>>     I have this errors trying to launch sparse checking:
>> 
>>     DESCEND objtool
>>     DESCEND bpf/resolve_btfids
>>     CALL    scripts/checksyscalls.sh
>>     CHK     kernel/kheaders_data.tar.xz
>>     CC      security/landlock/setup.o
>>     CHECK   security/landlock/setup.c
>> ./include/asm-generic/rwonce.h:67:16: error: typename in expression
>> ./include/asm-generic/rwonce.h:67:16: error: Expected ) in function call
>> ./include/asm-generic/rwonce.h:67:16: error: got :
>> ./include/linux/list.h:292:16: error: typename in expression
>> ./include/linux/list.h:292:16: error: Expected ) in function call
>> ./include/linux/list.h:292:16: error: got :
>> 
>> ....
>> 
>> ./include/linux/seqlock.h:682:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:682:16: error: got :
>> ./include/linux/seqlock.h:695:16: error: typename in expression
>> ./include/linux/seqlock.h:695:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:695:16: error: too many errors
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/setup.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/setup.o'
>> make[3]: *** Waiting for unfinished jobs....
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/syscalls.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/syscalls.o'
>> make[2]: *** [scripts/Makefile.build:502: security/landlock] Error 2
>> make[1]: *** [scripts/Makefile.build:502: security] Error 2
>> make[1]: *** Waiting for unfinished jobs....
>> make: *** [Makefile:1994: .] Error 2
> 
> I don't know about this error. Did you follow the documentation?
> https://docs.kernel.org/dev-tools/sparse.html#getting-sparse
> 
   Yes, I did as in the documentation. that's strange.
If you dont mind can you please check it when I sent a new patch?

> 
> 
>>>
>>> Using big-endian values as keys (casted to uintptr_t, not strictly
>>> __be16) in the rb-tree should not be an issue because there is no port
>>> range ordering (for now).
>>>
>>> A dedicated test should check that endianness is correct, e.g. by using
>>> different port encoding. This should include passing and failing tests,
>>> but they should work on all architectures (i.e. big or little endian).
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-sparse
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 07:59:43 +0000
Message-ID: <4aa29433-e7f9-f225-5bdf-c80638c936e8 () huawei ! com>
--------------------


1/6/2023 10:22 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> On 04/01/2023 12:41, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 11/17/2022 9:43 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> [...]
> 
>>>>    /**
>>>> @@ -79,6 +91,24 @@ struct landlock_path_beneath_attr {
>>>>    	 */
>>>>    } __attribute__((packed));
>>>>
>>>> +/**
>>>> + * struct landlock_net_service_attr - TCP subnet definition
>>>> + *
>>>> + * Argument of sys_landlock_add_rule().
>>>> + */
>>>> +struct landlock_net_service_attr {
>>>> +	/**
>>>> +	 * @allowed_access: Bitmask of allowed access network for services
>>>> +	 * (cf. `Network flags`_).
>>>> +	 */
>>>> +	__u64 allowed_access;
>>>> +	/**
>>>> +	 * @port: Network port.
>>>> +	 */
>>>> +	__u16 port;
>>>
>>>    From an UAPI point of view, I think the port field should be __be16, as
>>> for sockaddr_in->port and other network-related APIs. This will require
>>> some kernel changes to please sparse: make C=2 security/landlock/ must
>>> not print any warning.
>> 
>>     I have this errors trying to launch sparse checking:
>> 
>>     DESCEND objtool
>>     DESCEND bpf/resolve_btfids
>>     CALL    scripts/checksyscalls.sh
>>     CHK     kernel/kheaders_data.tar.xz
>>     CC      security/landlock/setup.o
>>     CHECK   security/landlock/setup.c
>> ./include/asm-generic/rwonce.h:67:16: error: typename in expression
>> ./include/asm-generic/rwonce.h:67:16: error: Expected ) in function call
>> ./include/asm-generic/rwonce.h:67:16: error: got :
>> ./include/linux/list.h:292:16: error: typename in expression
>> ./include/linux/list.h:292:16: error: Expected ) in function call
>> ./include/linux/list.h:292:16: error: got :
>> 
>> ....
>> 
>> ./include/linux/seqlock.h:682:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:682:16: error: got :
>> ./include/linux/seqlock.h:695:16: error: typename in expression
>> ./include/linux/seqlock.h:695:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:695:16: error: too many errors
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/setup.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/setup.o'
>> make[3]: *** Waiting for unfinished jobs....
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/syscalls.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/syscalls.o'
>> make[2]: *** [scripts/Makefile.build:502: security/landlock] Error 2
>> make[1]: *** [scripts/Makefile.build:502: security] Error 2
>> make[1]: *** Waiting for unfinished jobs....
>> make: *** [Makefile:1994: .] Error 2
> 
> I don't know about this error. Did you follow the documentation?
> https://docs.kernel.org/dev-tools/sparse.html#getting-sparse
> 
   Yes, I did as in the documentation. that's strange.
If you dont mind can you please check it when I sent a new patch?

> 
> 
>>>
>>> Using big-endian values as keys (casted to uintptr_t, not strictly
>>> __be16) in the rb-tree should not be an issue because there is no port
>>> range ordering (for now).
>>>
>>> A dedicated test should check that endianness is correct, e.g. by using
>>> different port encoding. This should include passing and failing tests,
>>> but they should work on all architectures (i.e. big or little endian).
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-api
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 07:59:43 +0000
Message-ID: <4aa29433-e7f9-f225-5bdf-c80638c936e8 () huawei ! com>
--------------------


1/6/2023 10:22 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> On 04/01/2023 12:41, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 11/17/2022 9:43 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> [...]
> 
>>>>    /**
>>>> @@ -79,6 +91,24 @@ struct landlock_path_beneath_attr {
>>>>    	 */
>>>>    } __attribute__((packed));
>>>>
>>>> +/**
>>>> + * struct landlock_net_service_attr - TCP subnet definition
>>>> + *
>>>> + * Argument of sys_landlock_add_rule().
>>>> + */
>>>> +struct landlock_net_service_attr {
>>>> +	/**
>>>> +	 * @allowed_access: Bitmask of allowed access network for services
>>>> +	 * (cf. `Network flags`_).
>>>> +	 */
>>>> +	__u64 allowed_access;
>>>> +	/**
>>>> +	 * @port: Network port.
>>>> +	 */
>>>> +	__u16 port;
>>>
>>>    From an UAPI point of view, I think the port field should be __be16, as
>>> for sockaddr_in->port and other network-related APIs. This will require
>>> some kernel changes to please sparse: make C=2 security/landlock/ must
>>> not print any warning.
>> 
>>     I have this errors trying to launch sparse checking:
>> 
>>     DESCEND objtool
>>     DESCEND bpf/resolve_btfids
>>     CALL    scripts/checksyscalls.sh
>>     CHK     kernel/kheaders_data.tar.xz
>>     CC      security/landlock/setup.o
>>     CHECK   security/landlock/setup.c
>> ./include/asm-generic/rwonce.h:67:16: error: typename in expression
>> ./include/asm-generic/rwonce.h:67:16: error: Expected ) in function call
>> ./include/asm-generic/rwonce.h:67:16: error: got :
>> ./include/linux/list.h:292:16: error: typename in expression
>> ./include/linux/list.h:292:16: error: Expected ) in function call
>> ./include/linux/list.h:292:16: error: got :
>> 
>> ....
>> 
>> ./include/linux/seqlock.h:682:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:682:16: error: got :
>> ./include/linux/seqlock.h:695:16: error: typename in expression
>> ./include/linux/seqlock.h:695:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:695:16: error: too many errors
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/setup.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/setup.o'
>> make[3]: *** Waiting for unfinished jobs....
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/syscalls.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/syscalls.o'
>> make[2]: *** [scripts/Makefile.build:502: security/landlock] Error 2
>> make[1]: *** [scripts/Makefile.build:502: security] Error 2
>> make[1]: *** Waiting for unfinished jobs....
>> make: *** [Makefile:1994: .] Error 2
> 
> I don't know about this error. Did you follow the documentation?
> https://docs.kernel.org/dev-tools/sparse.html#getting-sparse
> 
   Yes, I did as in the documentation. that's strange.
If you dont mind can you please check it when I sent a new patch?

> 
> 
>>>
>>> Using big-endian values as keys (casted to uintptr_t, not strictly
>>> __be16) in the rb-tree should not be an issue because there is no port
>>> range ordering (for now).
>>>
>>> A dedicated test should check that endianness is correct, e.g. by using
>>> different port encoding. This should include passing and failing tests,
>>> but they should work on all architectures (i.e. big or little endian).
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: netfilter-devel
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 07:59:43 +0000
Message-ID: <4aa29433-e7f9-f225-5bdf-c80638c936e8 () huawei ! com>
--------------------


1/6/2023 10:22 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> On 04/01/2023 12:41, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 11/17/2022 9:43 PM, MickaÃ«l SalaÃ¼n Ð¿Ð¸ÑÐµÑ:
> 
> [...]
> 
>>>>    /**
>>>> @@ -79,6 +91,24 @@ struct landlock_path_beneath_attr {
>>>>    	 */
>>>>    } __attribute__((packed));
>>>>
>>>> +/**
>>>> + * struct landlock_net_service_attr - TCP subnet definition
>>>> + *
>>>> + * Argument of sys_landlock_add_rule().
>>>> + */
>>>> +struct landlock_net_service_attr {
>>>> +	/**
>>>> +	 * @allowed_access: Bitmask of allowed access network for services
>>>> +	 * (cf. `Network flags`_).
>>>> +	 */
>>>> +	__u64 allowed_access;
>>>> +	/**
>>>> +	 * @port: Network port.
>>>> +	 */
>>>> +	__u16 port;
>>>
>>>    From an UAPI point of view, I think the port field should be __be16, as
>>> for sockaddr_in->port and other network-related APIs. This will require
>>> some kernel changes to please sparse: make C=2 security/landlock/ must
>>> not print any warning.
>> 
>>     I have this errors trying to launch sparse checking:
>> 
>>     DESCEND objtool
>>     DESCEND bpf/resolve_btfids
>>     CALL    scripts/checksyscalls.sh
>>     CHK     kernel/kheaders_data.tar.xz
>>     CC      security/landlock/setup.o
>>     CHECK   security/landlock/setup.c
>> ./include/asm-generic/rwonce.h:67:16: error: typename in expression
>> ./include/asm-generic/rwonce.h:67:16: error: Expected ) in function call
>> ./include/asm-generic/rwonce.h:67:16: error: got :
>> ./include/linux/list.h:292:16: error: typename in expression
>> ./include/linux/list.h:292:16: error: Expected ) in function call
>> ./include/linux/list.h:292:16: error: got :
>> 
>> ....
>> 
>> ./include/linux/seqlock.h:682:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:682:16: error: got :
>> ./include/linux/seqlock.h:695:16: error: typename in expression
>> ./include/linux/seqlock.h:695:16: error: Expected ) in function call
>> ./include/linux/seqlock.h:695:16: error: too many errors
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/setup.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/setup.o'
>> make[3]: *** Waiting for unfinished jobs....
>> Segmentation fault (core dumped)
>> make[3]: *** [scripts/Makefile.build:250: security/landlock/syscalls.o]
>> Error 139
>> make[3]: *** Deleting file 'security/landlock/syscalls.o'
>> make[2]: *** [scripts/Makefile.build:502: security/landlock] Error 2
>> make[1]: *** [scripts/Makefile.build:502: security] Error 2
>> make[1]: *** Waiting for unfinished jobs....
>> make: *** [Makefile:1994: .] Error 2
> 
> I don't know about this error. Did you follow the documentation?
> https://docs.kernel.org/dev-tools/sparse.html#getting-sparse
> 
   Yes, I did as in the documentation. that's strange.
If you dont mind can you please check it when I sent a new patch?

> 
> 
>>>
>>> Using big-endian values as keys (casted to uintptr_t, not strictly
>>> __be16) in the rb-tree should not be an issue because there is no port
>>> range ordering (for now).
>>>
>>> A dedicated test should check that endianness is correct, e.g. by using
>>> different port encoding. This should include passing and failing tests,
>>> but they should work on all architectures (i.e. big or little endian).
> .
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 08:58:48 +0000
Message-ID: <Y7vXSAGHf08p2Zbm () kadam>
--------------------
These warnings seem like something I have seen before.  Maybe it was an
issue with _Generic() support?

Are you really sure you're running the latest git version of Sparse?

I tested this patch with the latest version of Sparse on my system and
it worked fine.

regards,
dan carpenter

================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-api
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 08:58:48 +0000
Message-ID: <Y7vXSAGHf08p2Zbm () kadam>
--------------------
These warnings seem like something I have seen before.  Maybe it was an
issue with _Generic() support?

Are you really sure you're running the latest git version of Sparse?

I tested this patch with the latest version of Sparse on my system and
it worked fine.

regards,
dan carpenter

================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-netdev
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 08:58:48 +0000
Message-ID: <Y7vXSAGHf08p2Zbm () kadam>
--------------------
These warnings seem like something I have seen before.  Maybe it was an
issue with _Generic() support?

Are you really sure you're running the latest git version of Sparse?

I tested this patch with the latest version of Sparse on my system and
it worked fine.

regards,
dan carpenter

================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-netdev
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 09:26:52 +0000
Message-ID: <af0d7337-3a92-5eca-7d7c-cc09d5713589 () huawei ! com>
--------------------


1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> These warnings seem like something I have seen before.  Maybe it was an
> issue with _Generic() support?
> 
> Are you really sure you're running the latest git version of Sparse?
> 
> I tested this patch with the latest version of Sparse on my system and
> it worked fine.

  Hi Dan,

  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)

  Is this correct version?

  regards,
  Konstantin.
> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: netfilter-devel
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 09:26:52 +0000
Message-ID: <af0d7337-3a92-5eca-7d7c-cc09d5713589 () huawei ! com>
--------------------


1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> These warnings seem like something I have seen before.  Maybe it was an
> issue with _Generic() support?
> 
> Are you really sure you're running the latest git version of Sparse?
> 
> I tested this patch with the latest version of Sparse on my system and
> it worked fine.

  Hi Dan,

  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)

  Is this correct version?

  regards,
  Konstantin.
> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-api
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 09:26:52 +0000
Message-ID: <af0d7337-3a92-5eca-7d7c-cc09d5713589 () huawei ! com>
--------------------


1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> These warnings seem like something I have seen before.  Maybe it was an
> issue with _Generic() support?
> 
> Are you really sure you're running the latest git version of Sparse?
> 
> I tested this patch with the latest version of Sparse on my system and
> it worked fine.

  Hi Dan,

  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)

  Is this correct version?

  regards,
  Konstantin.
> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-sparse
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 09:26:52 +0000
Message-ID: <af0d7337-3a92-5eca-7d7c-cc09d5713589 () huawei ! com>
--------------------


1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> These warnings seem like something I have seen before.  Maybe it was an
> issue with _Generic() support?
> 
> Are you really sure you're running the latest git version of Sparse?
> 
> I tested this patch with the latest version of Sparse on my system and
> it worked fine.

  Hi Dan,

  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)

  Is this correct version?

  regards,
  Konstantin.
> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: netfilter-devel
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 10:20:38 +0000
Message-ID: <Y7vqdgvxQVNvu6AY () kadam>
--------------------
On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
> 
> 
> 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > These warnings seem like something I have seen before.  Maybe it was an
> > issue with _Generic() support?
> > 
> > Are you really sure you're running the latest git version of Sparse?
> > 
> > I tested this patch with the latest version of Sparse on my system and
> > it worked fine.
> 
>  Hi Dan,
> 
>  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
> 
>  Is this correct version?

Yes, that's correct.  What is your .config?

regards,
dan carpenter

================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-netdev
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 10:20:38 +0000
Message-ID: <Y7vqdgvxQVNvu6AY () kadam>
--------------------
On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
> 
> 
> 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > These warnings seem like something I have seen before.  Maybe it was an
> > issue with _Generic() support?
> > 
> > Are you really sure you're running the latest git version of Sparse?
> > 
> > I tested this patch with the latest version of Sparse on my system and
> > it worked fine.
> 
>  Hi Dan,
> 
>  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
> 
>  Is this correct version?

Yes, that's correct.  What is your .config?

regards,
dan carpenter

================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-api
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 10:20:38 +0000
Message-ID: <Y7vqdgvxQVNvu6AY () kadam>
--------------------
On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
> 
> 
> 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > These warnings seem like something I have seen before.  Maybe it was an
> > issue with _Generic() support?
> > 
> > Are you really sure you're running the latest git version of Sparse?
> > 
> > I tested this patch with the latest version of Sparse on my system and
> > it worked fine.
> 
>  Hi Dan,
> 
>  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
> 
>  Is this correct version?

Yes, that's correct.  What is your .config?

regards,
dan carpenter

================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: netfilter-devel
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 11:39:36 +0000
Message-ID: <0dab9d74-6a41-9cf3-58fb-9fbb265efdd0 () huawei ! com>
--------------------


1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
>> > These warnings seem like something I have seen before.  Maybe it was an
>> > issue with _Generic() support?
>> > 
>> > Are you really sure you're running the latest git version of Sparse?
>> > 
>> > I tested this patch with the latest version of Sparse on my system and
>> > it worked fine.
>> 
>>  Hi Dan,
>> 
>>  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
>> 
>>  Is this correct version?
> 
> Yes, that's correct.  What is your .config?

   What parameters do I need to check in .config?
> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-netdev
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 11:39:36 +0000
Message-ID: <0dab9d74-6a41-9cf3-58fb-9fbb265efdd0 () huawei ! com>
--------------------


1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
>> > These warnings seem like something I have seen before.  Maybe it was an
>> > issue with _Generic() support?
>> > 
>> > Are you really sure you're running the latest git version of Sparse?
>> > 
>> > I tested this patch with the latest version of Sparse on my system and
>> > it worked fine.
>> 
>>  Hi Dan,
>> 
>>  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
>> 
>>  Is this correct version?
> 
> Yes, that's correct.  What is your .config?

   What parameters do I need to check in .config?
> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-sparse
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 11:39:36 +0000
Message-ID: <0dab9d74-6a41-9cf3-58fb-9fbb265efdd0 () huawei ! com>
--------------------


1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
>> > These warnings seem like something I have seen before.  Maybe it was an
>> > issue with _Generic() support?
>> > 
>> > Are you really sure you're running the latest git version of Sparse?
>> > 
>> > I tested this patch with the latest version of Sparse on my system and
>> > it worked fine.
>> 
>>  Hi Dan,
>> 
>>  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
>> 
>>  Is this correct version?
> 
> Yes, that's correct.  What is your .config?

   What parameters do I need to check in .config?
> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-api
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 11:53:05 +0000
Message-ID: <Y7wAITZ/Ae/SwH9m () kadam>
--------------------
On Mon, Jan 09, 2023 at 02:39:36PM +0300, Konstantin Meskhidze (A) wrote:
> 
> 
> 1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
> > > 
> > > 
> > > 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > > > These warnings seem like something I have seen before.  Maybe it was an
> > > > issue with _Generic() support?
> > > > > Are you really sure you're running the latest git version of
> > > Sparse?
> > > > > I tested this patch with the latest version of Sparse on my
> > > system and
> > > > it worked fine.
> > > 
> > >  Hi Dan,
> > > 
> > >  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
> > > 
> > >  Is this correct version?
> > 
> > Yes, that's correct.  What is your .config?
> 
>   What parameters do I need to check in .config?

I don't know.  I was hoping you could just email me the whole thing
and/or the results from make security/landlock/ruleset.i.  That way
we could see what line was making Sparse complain.

regards,
dan carpenter

================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 11:53:05 +0000
Message-ID: <Y7wAITZ/Ae/SwH9m () kadam>
--------------------
On Mon, Jan 09, 2023 at 02:39:36PM +0300, Konstantin Meskhidze (A) wrote:
> 
> 
> 1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
> > > 
> > > 
> > > 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > > > These warnings seem like something I have seen before.  Maybe it was an
> > > > issue with _Generic() support?
> > > > > Are you really sure you're running the latest git version of
> > > Sparse?
> > > > > I tested this patch with the latest version of Sparse on my
> > > system and
> > > > it worked fine.
> > > 
> > >  Hi Dan,
> > > 
> > >  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
> > > 
> > >  Is this correct version?
> > 
> > Yes, that's correct.  What is your .config?
> 
>   What parameters do I need to check in .config?

I don't know.  I was hoping you could just email me the whole thing
and/or the results from make security/landlock/ruleset.i.  That way
we could see what line was making Sparse complain.

regards,
dan carpenter

================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: netfilter-devel
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 11:53:05 +0000
Message-ID: <Y7wAITZ/Ae/SwH9m () kadam>
--------------------
On Mon, Jan 09, 2023 at 02:39:36PM +0300, Konstantin Meskhidze (A) wrote:
> 
> 
> 1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
> > > 
> > > 
> > > 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> > > > These warnings seem like something I have seen before.  Maybe it was an
> > > > issue with _Generic() support?
> > > > > Are you really sure you're running the latest git version of
> > > Sparse?
> > > > > I tested this patch with the latest version of Sparse on my
> > > system and
> > > > it worked fine.
> > > 
> > >  Hi Dan,
> > > 
> > >  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
> > > 
> > >  Is this correct version?
> > 
> > Yes, that's correct.  What is your .config?
> 
>   What parameters do I need to check in .config?

I don't know.  I was hoping you could just email me the whole thing
and/or the results from make security/landlock/ruleset.i.  That way
we could see what line was making Sparse complain.

regards,
dan carpenter

================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: netfilter-devel
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 12:18:35 +0000
Message-ID: <8eed91ae-3a2e-4367-f68b-76c2f5125828 () huawei ! com>
--------------------

1/9/2023 2:53 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> On Mon, Jan 09, 2023 at 02:39:36PM +0300, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
>> > On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
>> > > 
>> > > 
>> > > 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
>> > > > These warnings seem like something I have seen before.  Maybe it was an
>> > > > issue with _Generic() support?
>> > > > > Are you really sure you're running the latest git version of
>> > > Sparse?
>> > > > > I tested this patch with the latest version of Sparse on my
>> > > system and
>> > > > it worked fine.
>> > > 
>> > >  Hi Dan,
>> > > 
>> > >  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
>> > > 
>> > >  Is this correct version?
>> > 
>> > Yes, that's correct.  What is your .config?
>> 
>>   What parameters do I need to check in .config?
> 
> I don't know.  I was hoping you could just email me the whole thing
> and/or the results from make security/landlock/ruleset.i.  That way
> we could see what line was making Sparse complain.

   here is the whole error message:

   make C=2 security/landlock/
   CHECK   scripts/mod/empty.c
   CALL    scripts/checksyscalls.sh
   DESCEND objtool
   DESCEND bpf/resolve_btfids
   CHECK   security/landlock/setup.c
./include/asm-generic/rwonce.h:67:16: error: typename in expression
./include/asm-generic/rwonce.h:67:16: error: Expected ) in function call
./include/asm-generic/rwonce.h:67:16: error: got :
./include/linux/list.h:292:16: error: typename in expression
./include/linux/list.h:292:16: error: Expected ) in function call
./include/linux/list.h:292:16: error: got :
./include/linux/list.h:328:34: error: typename in expression
./include/linux/list.h:328:34: error: Expected ) in function call
./include/linux/list.h:328:34: error: got :
./include/linux/list.h:329:53: error: typename in expression
./include/linux/list.h:329:53: error: Expected ) in function call
./include/linux/list.h:329:53: error: got :
./include/linux/list.h:867:17: error: typename in expression
./include/linux/list.h:867:17: error: Expected ) in function call
./include/linux/list.h:867:17: error: got :
./include/linux/list.h:876:17: error: typename in expression
./include/linux/list.h:876:17: error: Expected ) in function call
./include/linux/list.h:876:17: error: got :
./arch/x86/include/asm/atomic.h:29:16: error: typename in expression
./arch/x86/include/asm/atomic.h:29:16: error: Expected ) in function call
./arch/x86/include/asm/atomic.h:29:16: error: got :
./arch/x86/include/asm/atomic64_64.h:22:16: error: typename in expression
./arch/x86/include/asm/atomic64_64.h:22:16: error: Expected ) in 
function call
./arch/x86/include/asm/atomic64_64.h:22:16: error: got :
./include/linux/atomic/atomic-arch-fallback.h:227:23: error: typename in 
expression
./include/linux/atomic/atomic-arch-fallback.h:227:23: error: Expected ) 
in function call
./include/linux/atomic/atomic-arch-fallback.h:227:23: error: got :
./include/linux/atomic/atomic-arch-fallback.h:1348:23: error: typename 
in expression
./include/linux/atomic/atomic-arch-fallback.h:1348:23: error: Expected ) 
in function call
./include/linux/atomic/atomic-arch-fallback.h:1348:23: error: got :
./include/linux/jump_label.h:286:9: error: Expected ; at end of statement
./include/linux/jump_label.h:286:9: error: got __flags
./include/linux/jump_label.h:302:9: error: Expected ; at end of statement
./include/linux/jump_label.h:302:9: error: got __flags
./include/linux/jump_label.h:319:9: error: Expected ; at end of statement
./include/linux/jump_label.h:319:9: error: got __flags
./include/linux/jump_label.h:322:17: error: Expected ; at end of statement
./include/linux/jump_label.h:322:17: error: got __flags
./include/linux/jump_label.h:330:9: error: Expected ; at end of statement
./include/linux/jump_label.h:330:9: error: got __flags
./include/linux/jump_label.h:333:17: error: Expected ; at end of statement
./include/linux/jump_label.h:333:17: error: got __flags
./include/asm-generic/bitops/generic-non-atomic.h:140:23: error: 
typename in expression
./include/asm-generic/bitops/generic-non-atomic.h:140:23: error: 
Expected ) in function call
./include/asm-generic/bitops/generic-non-atomic.h:140:23: error: got :
./include/linux/bitmap.h:268:17: error: Expected ; at end of statement
./include/linux/bitmap.h:268:17: error: got __flags
./include/linux/thread_info.h:127:16: error: typename in expression
./include/linux/thread_info.h:127:16: error: Expected ) in function call
./include/linux/thread_info.h:127:16: error: got :
./include/linux/thread_info.h:233:13: error: Expected ; at end of statement
./include/linux/thread_info.h:233:13: error: got __flags
./include/linux/llist.h:191:16: error: typename in expression
./include/linux/llist.h:191:16: error: Expected ) in function call
./include/linux/llist.h:191:16: error: got :
./include/linux/rcupdate.h:1073:31: error: typename in expression
./include/linux/rcupdate.h:1073:31: error: Expected ) in function call
./include/linux/rcupdate.h:1073:31: error: got :
./include/linux/rcupdate.h:1077:9: error: Expected ; at end of statement
./include/linux/rcupdate.h:1077:9: error: got __flags
./include/linux/key.h:453:16: error: typename in expression
./include/linux/key.h:453:16: error: Expected ) in function call
./include/linux/key.h:453:16: error: got :
./include/linux/list_bl.h:74:33: error: typename in expression
./include/linux/list_bl.h:74:33: error: Expected ) in function call
./include/linux/list_bl.h:74:33: error: got :
./include/linux/rculist_bl.h:24:33: error: typename in expression
./include/linux/rculist_bl.h:24:33: error: Expected ) in function call
./include/linux/rculist_bl.h:24:33: error: got :
./include/linux/seqlock.h:259:16: error: typename in expression
./include/linux/seqlock.h:259:16: error: Expected ) in function call
./include/linux/seqlock.h:259:16: error: got :
./include/linux/seqlock.h:274:1: error: typename in expression
./include/linux/seqlock.h:274:1: error: Expected ) in function call
./include/linux/seqlock.h:274:1: error: got :
./include/linux/seqlock.h:274:1: error: typename in expression
./include/linux/seqlock.h:274:1: error: Expected ) in function call
./include/linux/seqlock.h:274:1: error: got :
./include/linux/seqlock.h:275:1: error: typename in expression
./include/linux/seqlock.h:275:1: error: Expected ) in function call
./include/linux/seqlock.h:275:1: error: got :
./include/linux/seqlock.h:275:1: error: typename in expression
./include/linux/seqlock.h:275:1: error: Expected ) in function call
./include/linux/seqlock.h:275:1: error: got :
./include/linux/seqlock.h:276:1: error: typename in expression
./include/linux/seqlock.h:276:1: error: Expected ) in function call
./include/linux/seqlock.h:276:1: error: got :
./include/linux/seqlock.h:276:1: error: typename in expression
./include/linux/seqlock.h:276:1: error: Expected ) in function call
./include/linux/seqlock.h:276:1: error: got :
./include/linux/seqlock.h:277:1: error: typename in expression
./include/linux/seqlock.h:277:1: error: Expected ) in function call
./include/linux/seqlock.h:277:1: error: got :
./include/linux/seqlock.h:277:1: error: typename in expression
./include/linux/seqlock.h:277:1: error: Expected ) in function call
./include/linux/seqlock.h:277:1: error: got :
./include/linux/seqlock.h:429:16: error: typename in expression
./include/linux/seqlock.h:429:16: error: Expected ) in function call
./include/linux/seqlock.h:429:16: error: got :
./include/linux/seqlock.h:682:16: error: typename in expression
./include/linux/seqlock.h:682:16: error: Expected ) in function call
./include/linux/seqlock.h:682:16: error: too many errors
Segmentation fault (core dumped)
make[3]: *** [scripts/Makefile.build:251: security/landlock/setup.o] 
Error 139
make[2]: *** [scripts/Makefile.build:502: security/landlock] Error 2
make[1]: *** [scripts/Makefile.build:502: security] Error 2
make: *** [Makefile:1994: .] Error 2

Please tell me if you need some more info.

regards,
Konstantin

> 
> regards,
> dan carpenter
> 
> .
================================================================================

From: "Konstantin Meskhidze (A)" <konstantin.meskhidze () huawei ! com>
To: linux-netdev
Subject: Re: [PATCH v8 07/12] landlock: Add network rules support
Date: Mon, 09 Jan 2023 12:18:35 +0000
Message-ID: <8eed91ae-3a2e-4367-f68b-76c2f5125828 () huawei ! com>
--------------------

1/9/2023 2:53 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
> On Mon, Jan 09, 2023 at 02:39:36PM +0300, Konstantin Meskhidze (A) wrote:
>> 
>> 
>> 1/9/2023 1:20 PM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
>> > On Mon, Jan 09, 2023 at 12:26:52PM +0300, Konstantin Meskhidze (A) wrote:
>> > > 
>> > > 
>> > > 1/9/2023 11:58 AM, Dan Carpenter Ð¿Ð¸ÑÐµÑ:
>> > > > These warnings seem like something I have seen before.  Maybe it was an
>> > > > issue with _Generic() support?
>> > > > > Are you really sure you're running the latest git version of
>> > > Sparse?
>> > > > > I tested this patch with the latest version of Sparse on my
>> > > system and
>> > > > it worked fine.
>> > > 
>> > >  Hi Dan,
>> > > 
>> > >  git is on the master branch now - hash ce1a6720 (dated 27 June 2022)
>> > > 
>> > >  Is this correct version?
>> > 
>> > Yes, that's correct.  What is your .config?
>> 
>>   What parameters do I need to check in .config?
> 
> I don't know.  I was hoping you could just email me the whole thing
> and/or the results from make security/landlock/ruleset.i.  That way
> we could see what line was making Sparse complain.

   here is the whole error message:

   make C=2 security/landlock/
   CHECK   scripts/mod/empty.c
   CALL    scripts/checksyscalls.sh
   DESCEND objtool
   DESCEND bpf/resolve_btfids
   CHECK   security/landlock/setup.c
./include/asm-generic/rwonce.h:67:16: error: typename in expression
./include/asm-generic/rwonce.h:67:16: error: Expected ) in function call
./include/asm-generic/rwonce.h:67:16: error: got :
./include/linux/list.h:292:16: error: typename in expression
./include/linux/list.h:292:16: error: Expected ) in function call
./include/linux/list.h:292:16: error: got :
./include/linux/list.h:328:34: error: typename in expression
./include/linux/list.h:328:34: error: Expected ) in function call
./include/linux/list.h:328:34: error: got :
./include/linux/list.h:329:53: error: typename in expression
./include/linux/list.h:329:53: error: Expected ) in function call
./include/linux/list.h:329:53: error: got :
./include/linux/list.h:867:17: error: typename in expression
./include/linux/list.h:867:17: error: Expected ) in function call
./include/linux/list.h:867:17: error: got :
./include/linux/list.h:876:17: error: typename in expression
./include/linux/list.h:876:17: error: Expected ) in function call
./include/linux/list.h:876:17: error: got :
./arch/x86/include/asm/atomic.h:29:16: error: typename in expression
./arch/x86/include/asm/atomic.h:29:16: error: Expected ) in function call
./arch/x86/include/asm/atomic.h:29:16: error: got :
./arch/x86/include/asm/atomic64_64.h:22:16: error: typename in expression
./arch/x86/include/asm/atomic64_64.h:22:16: error: Expected ) in 
function call
./arch/x86/include/asm/atomic64_64.h:22:16: error: got :
./include/linux/atomic/atomic-arch-fallback.h:227:23: error: typename in 
expression
./include/linux/atomic/atomic-arch-fallback.h:227:23: error: Expected ) 
in function call
./include/linux/atomic/atomic-arch-fallback.h:227:23: error: got :
./include/linux/atomic/atomic-arch-fallback.h:1348:23: error: typename 
in expression
./include/linux/atomic/atomic-arch-fallback.h:1348:23: error: Expected ) 
in function call
./include/linux/atomic/atomic-arch-fallback.h:1348:23: error: got :
./include/linux/jump_label.h:286:9: error: Expected ; at end of statement
./include/linux/jump_label.h:286:9: error: got __flags
./include/linux/jump_label.h:302:9: error: Expected ; at end of statement
./include/linux/jump_label.h:302:9: error: got __flags
./include/linux/jump_label.h:319:9: error: Expected ; at end of statement
./include/linux/jump_label.h:319:9: error: got __flags
./include/linux/jump_label.h:322:17: error: Expected ; at end of statement
./include/linux/jump_label.h:322:17: error: got __flags
./include/linux/jump_label.h:330:9: error: Expected ; at end of statement
./include/linux/jump_label.h:330:9: error: got __flags
./include/linux/jump_label.h:333:17: error: Expected ; at end of statement
./include/linux/jump_label.h:333:17: error: got __flags
./include/asm-generic/bitops/generic-non-atomic.h:140:23: error: 
typename in expression
./include/asm-generic/bitops/generic-non-atomic.h:140:23: error: 
Expected ) in function call
./include/asm-generic/bitops/generic-non-atomic.h:140:23: error: got :
./include/linux/bitmap.h:268:17: error: Expected ; at end of statement
./include/linux/bitmap.h:268:17: error: got __flags
./include/linux/thread_info.h:127:16: error: typename in expression
./include/linux/thread_info.h:127:16: error: Expected ) in function call
./include/linux/thread_info.h:127:16: error: got :
./include/linux/thread_info.h:233:13: error: Expected ; at end of statement
./include/linux/thread_info.h:233:13: error: got __flags
./include/linux/llist.h:191:16: error: typename in expression
./include/linux/llist.h:191:16: error: Expected ) in function call
./include/linux/llist.h:191:16: error: got :
./include/linux/rcupdate.h:1073:31: error: typename in expression
./include/linux/rcupdate.h:1073:31: error: Expected ) in function call
./include/linux/rcupdate.h:1073:31: error: got :
./include/linux/rcupdate.h:1077:9: error: Expected ; at end of statement
./include/linux/rcupdate.h:1077:9: error: got __flags
./include/linux/key.h:453:16: error: typename in expression
./include/linux/key.h:453:16: error: Expected ) in function call
./include/linux/key.h:453:16: error: got :
./include/linux/list_bl.h:74:33: error: typename in expression
./include/linux/list_bl.h:74:33: error: Expected ) in function call
./include/linux/list_bl.h:74:33: error: got :
./include/linux/rculist_bl.h:24:33: error: typename in expression
./include/linux/rculist_bl.h:24:33: error: Expected ) in function call
./include/linux/rculist_bl.h:24:33: error: got :
./include/linux/seqlock.h:259:16: error: typename in expression
./include/linux/seqlock.h:259:16: error: Expected ) in function call
./include/linux/seqlock.h:259:16: error: got :
./include/linux/seqlock.h:274:1: error: typename in expression
./include/linux/seqlock.h:274:1: error: Expected ) in function call
./include/linux/seqlock.h:274:1: error: got :
./include/linux/seqlock.h:274:1: error: typename in expression
./include/linux/seqlock.h:274:1: error: Expected ) in function call
./include/linux/seqlock.h:274:1: error: got :
./include/linux/seqlock.h:275:1: error: typename in expression
./include/linux/seqlock.h:275:1: error: Expected ) in function call
./include/linux/seqlock.h:275:1: error: got :
./include/linux/seqlock.h:275:1: error: typename in expression
./include/linux/seqlock.h:275:1: error: Expected ) in function call
./include/linux/seqlock.h:275:1: error: got :
./include/linux/seqlock.h:276:1: error: typename in expression
./include/linux/seqlock.h:276:1: error: Expected ) in function call
./include/linux/seqlock.h:276:1: error: got :
./include/linux/seqlock.h:276:1: error: typename in expression
./include/linux/seqlock.h:276:1: error: Expected ) in function call
./include/linux/seqlock.h:276:1: error: got :
./include/linux/seqlock.h:277:1: error: typename in expression
./include/linux/seqlock.h:277:1: error: Expected ) in function call
./include/linux/seqlock.h:277:1: error: got :
./include/linux/seqlock.h:277:1: error: typename in expression
./include/linux/seqlock.h:277:1: error: Expected ) in function call
./include/linux/seqlock.h:277:1: error: got :
./include/linux/seqlock.h:429:16: error: typename in expression
./include/linux/seqlock.h:429:16: error: Expected ) in function call
./include/linux/seqlock.h:429:16: error: got :
./include/linux/seqlock.h:682:16: error: typename in expression
./include/linux/seqlock.h:682:16: error: Expected ) in function call
./include/linux/seqlock.h:682:16: error: too many errors
Segmentation fault (core dumped)
make[3]: *** [scripts/Makefile.build:251: security/landlock/setup.o] 
Error 139
make[2]: *** [scripts/Makefile.build:502: security/landlock] Error 2
make[1]: *** [scripts/Makefile.build:502: security] Error 2
make: *** [Makefile:1994: .] Error 2

Please tell me if you need some more info.

regards,
Konstantin

> 
> regards,
> dan carpenter
> 
> .
================================================================================


################################################################################

=== Thread: [PATCH] RISC-V: Add support fo the zihintpause extension ===

From: Palmer Dabbelt <palmer () rivosinc ! com>
To: linux-sparse
Subject: [PATCH] RISC-V: Add support fo the zihintpause extension
Date: Thu, 11 Aug 2022 05:33:56 +0000
Message-ID: <20220811053356.17375-1-palmer () rivosinc ! com>
--------------------
This was recently added to binutils and with any luck will soon be in
Linux, without it sparse will fail when trying to build new kernels on
systems with new toolchains.

Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>
---
I re-indented the other extensions to match, and this one is on top of
the Zicbom patch as I figured that'd be easier.
---
 target-riscv.c | 50 +++++++++++++++++++++++++++-----------------------
 1 file changed, 27 insertions(+), 23 deletions(-)

diff --git a/target-riscv.c b/target-riscv.c
index db0f7e57..23d28d0e 100644
--- a/target-riscv.c
+++ b/target-riscv.c
@@ -5,21 +5,22 @@
 #include <string.h>
 #include <stdio.h>
 
-#define RISCV_32BIT	(1 << 0)
-#define RISCV_64BIT	(1 << 1)
-#define RISCV_MUL	(1 << 2)
-#define RISCV_DIV	(1 << 3)
-#define RISCV_ATOMIC	(1 << 4)
-#define RISCV_FLOAT	(1 << 5)
-#define RISCV_DOUBLE	(1 << 6)
-#define RISCV_FDIV	(1 << 7)
-#define RISCV_COMP	(1 << 8)
-#define RISCV_EMBD	(1 << 9)
-#define RISCV_FPU	(RISCV_FLOAT|RISCV_DOUBLE|RISCV_FDIV)
-#define RISCV_GENERIC	(RISCV_MUL|RISCV_DIV|RISCV_ATOMIC|RISCV_FPU)
-#define RISCV_ZICSR	(1 << 10)
-#define RISCV_ZIFENCEI	(1 << 11)
-#define RISCV_ZICBOM	(1 << 12)
+#define RISCV_32BIT		(1 << 0)
+#define RISCV_64BIT		(1 << 1)
+#define RISCV_MUL		(1 << 2)
+#define RISCV_DIV		(1 << 3)
+#define RISCV_ATOMIC		(1 << 4)
+#define RISCV_FLOAT		(1 << 5)
+#define RISCV_DOUBLE		(1 << 6)
+#define RISCV_FDIV		(1 << 7)
+#define RISCV_COMP		(1 << 8)
+#define RISCV_EMBD		(1 << 9)
+#define RISCV_FPU		(RISCV_FLOAT|RISCV_DOUBLE|RISCV_FDIV)
+#define RISCV_GENERIC		(RISCV_MUL|RISCV_DIV|RISCV_ATOMIC|RISCV_FPU)
+#define RISCV_ZICSR		(1 << 10)
+#define RISCV_ZIFENCEI		(1 << 11)
+#define RISCV_ZICBOM		(1 << 12)
+#define RISCV_ZIHINTPAUSE	(1 << 13)
 
 static unsigned int riscv_flags;
 
@@ -35,14 +36,15 @@ static void parse_march_riscv(const char *arg)
 		{ "rv64i",	RISCV_64BIT },
 		{ "rv64g",	RISCV_64BIT|RISCV_GENERIC },
 	}, extensions[] = {
-		{ "m",		RISCV_MUL|RISCV_DIV },
-		{ "a",		RISCV_ATOMIC },
-		{ "f",		RISCV_FLOAT|RISCV_FDIV|RISCV_ZICSR },
-		{ "d",		RISCV_DOUBLE|RISCV_FDIV|RISCV_ZICSR },
-		{ "c",		RISCV_COMP },
-		{ "_zicsr",	RISCV_ZICSR },
-		{ "_zifencei",	RISCV_ZIFENCEI },
-		{ "_zicbom",	RISCV_ZICBOM },
+		{ "m",			RISCV_MUL|RISCV_DIV },
+		{ "a",			RISCV_ATOMIC },
+		{ "f",			RISCV_FLOAT|RISCV_FDIV|RISCV_ZICSR },
+		{ "d",			RISCV_DOUBLE|RISCV_FDIV|RISCV_ZICSR },
+		{ "c",			RISCV_COMP },
+		{ "_zicsr",		RISCV_ZICSR },
+		{ "_zifencei",		RISCV_ZIFENCEI },
+		{ "_zicbom",		RISCV_ZICBOM },
+		{ "_zihintpause",	RISCV_ZIHINTPAUSE },
 	};
 	int i;
 
@@ -135,6 +137,8 @@ static void predefine_riscv(const struct target *self)
 		predefine("__riscv_zifencei", 1, "1");
 	if (riscv_flags & RISCV_ZICBOM)
 		predefine("__riscv_zicbom", 1, "1");
+	if (riscv_flags & RISCV_ZIHINTPAUSE)
+		predefine("__riscv_zihintpause", 1, "1");
 
 	if (cmodel)
 		predefine_strong("__riscv_cmodel_%s", cmodel);
-- 
2.34.1

================================================================================

From: Geert Uytterhoeven <geert () linux-m68k ! org>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support fo the zihintpause extension
Date: Fri, 15 Dec 2023 12:41:55 +0000
Message-ID: <b26c790-c192-8b70-9947-cb6ff6a9ac55 () linux-m68k ! org>
--------------------
On Wed, 10 Aug 2022, Palmer Dabbelt wrote:
> This was recently added to binutils and with any luck will soon be in
> Linux, without it sparse will fail when trying to build new kernels on
> systems with new toolchains.
>
> Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>

As I've just run into

     .../linux$ make C=1

     [...]

     invalid argument to '-march': '_zicsr_zifencei_zihintpause'

and needed to apply this patch before upgrading sparse:

Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>

Gr{oetje,eeting}s,

 						Geert

--
Geert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k.org

In personal conversations with technical people, I call myself a hacker. But
when I'm talking to journalists I just say "programmer" or something like that.
 							    -- Linus Torvalds

================================================================================

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support fo the zihintpause extension
Date: Mon, 18 Dec 2023 13:59:39 +0000
Message-ID: <ad37cluochfovzbxbvshv4bzjwitnl5ant2bhewohpip3aq5ld () yfmkog3w5kdd>
--------------------
On Wed, Aug 10, 2022 at 10:33:56PM -0700, Palmer Dabbelt wrote:
> This was recently added to binutils and with any luck will soon be in
> Linux, without it sparse will fail when trying to build new kernels on
> systems with new toolchains.
> 
> Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>

Pushed to mainline now. Sorry for this very long delay.
-- Luc

================================================================================


################################################################################

=== Thread: [PATCH] RISC-V: Add support for the zicbom extension ===

From: Conor Dooley <conor.dooley () microchip ! com>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support for the zicbom extension
Date: Fri, 12 Aug 2022 08:25:23 +0000
Message-ID: <YvYOc9Mk8y1dFvnp () wendy>
--------------------
On Wed, Aug 10, 2022 at 08:31:38PM -0700, Palmer Dabbelt wrote:
> This was recently added to binutils and with any luck will soon be in
> Linux, without it sparse will fail when trying to build new kernels on
> systems with new toolchains.
> 

In passing while testing the zihintpause one:
Tested-by: Conor Dooley <conor.dooley@microchip.com>

> Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>
> ---
>  target-riscv.c | 4 ++++
>  1 file changed, 4 insertions(+)
> 
> diff --git a/target-riscv.c b/target-riscv.c
> index 217ab7e8..db0f7e57 100644
> --- a/target-riscv.c
> +++ b/target-riscv.c
> @@ -19,6 +19,7 @@
>  #define RISCV_GENERIC	(RISCV_MUL|RISCV_DIV|RISCV_ATOMIC|RISCV_FPU)
>  #define RISCV_ZICSR	(1 << 10)
>  #define RISCV_ZIFENCEI	(1 << 11)
> +#define RISCV_ZICBOM	(1 << 12)
>  
>  static unsigned int riscv_flags;
>  
> @@ -41,6 +42,7 @@ static void parse_march_riscv(const char *arg)
>  		{ "c",		RISCV_COMP },
>  		{ "_zicsr",	RISCV_ZICSR },
>  		{ "_zifencei",	RISCV_ZIFENCEI },
> +		{ "_zicbom",	RISCV_ZICBOM },
>  	};
>  	int i;
>  
> @@ -131,6 +133,8 @@ static void predefine_riscv(const struct target *self)
>  		predefine("__riscv_zicsr", 1, "1");
>  	if (riscv_flags & RISCV_ZIFENCEI)
>  		predefine("__riscv_zifencei", 1, "1");
> +	if (riscv_flags & RISCV_ZICBOM)
> +		predefine("__riscv_zicbom", 1, "1");
>  
>  	if (cmodel)
>  		predefine_strong("__riscv_cmodel_%s", cmodel);
> -- 
> 2.34.1
> 
================================================================================

From: Conor Dooley <conor () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support for the zicbom extension
Date: Wed, 12 Oct 2022 21:11:58 +0000
Message-ID: <Y0ctngWSXWupub2O () spud>
--------------------
On Fri, Aug 12, 2022 at 09:25:23AM +0100, Conor Dooley wrote:
> On Wed, Aug 10, 2022 at 08:31:38PM -0700, Palmer Dabbelt wrote:
> > This was recently added to binutils and with any luck will soon be in
> > Linux, without it sparse will fail when trying to build new kernels on
> > systems with new toolchains.
> > 
> 
> In passing while testing the zihintpause one:
> Tested-by: Conor Dooley <conor.dooley@microchip.com>

Hey Luc,
Would you be able to take a look at this patch and at
https://lore.kernel.org/linux-sparse/YvYQSdQBuZGSit2s@wendy/T/#t
please? They're causing sparse to fail for recent kernels when the
extensions are used.

Thanks,
Conor.

> 
> > Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>
> > ---
> >  target-riscv.c | 4 ++++
> >  1 file changed, 4 insertions(+)
> > 
> > diff --git a/target-riscv.c b/target-riscv.c
> > index 217ab7e8..db0f7e57 100644
> > --- a/target-riscv.c
> > +++ b/target-riscv.c
> > @@ -19,6 +19,7 @@
> >  #define RISCV_GENERIC	(RISCV_MUL|RISCV_DIV|RISCV_ATOMIC|RISCV_FPU)
> >  #define RISCV_ZICSR	(1 << 10)
> >  #define RISCV_ZIFENCEI	(1 << 11)
> > +#define RISCV_ZICBOM	(1 << 12)
> >  
> >  static unsigned int riscv_flags;
> >  
> > @@ -41,6 +42,7 @@ static void parse_march_riscv(const char *arg)
> >  		{ "c",		RISCV_COMP },
> >  		{ "_zicsr",	RISCV_ZICSR },
> >  		{ "_zifencei",	RISCV_ZIFENCEI },
> > +		{ "_zicbom",	RISCV_ZICBOM },
> >  	};
> >  	int i;
> >  
> > @@ -131,6 +133,8 @@ static void predefine_riscv(const struct target *self)
> >  		predefine("__riscv_zicsr", 1, "1");
> >  	if (riscv_flags & RISCV_ZIFENCEI)
> >  		predefine("__riscv_zifencei", 1, "1");
> > +	if (riscv_flags & RISCV_ZICBOM)
> > +		predefine("__riscv_zicbom", 1, "1");
> >  
> >  	if (cmodel)
> >  		predefine_strong("__riscv_cmodel_%s", cmodel);
> > -- 
> > 2.34.1
> > 
> 
================================================================================

From: Palmer Dabbelt <palmer () rivosinc ! com>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support for the zicbom extension
Date: Wed, 12 Oct 2022 23:34:00 +0000
Message-ID: <mhng-42e79e92-7b14-4539-aed6-f848ac6f10c4 () palmer-ri-x1c9a>
--------------------
On Wed, 12 Oct 2022 14:11:58 PDT (-0700), Conor Dooley wrote:
> On Fri, Aug 12, 2022 at 09:25:23AM +0100, Conor Dooley wrote:
>> On Wed, Aug 10, 2022 at 08:31:38PM -0700, Palmer Dabbelt wrote:
>> > This was recently added to binutils and with any luck will soon be in
>> > Linux, without it sparse will fail when trying to build new kernels on
>> > systems with new toolchains.
>> >
>>
>> In passing while testing the zihintpause one:
>> Tested-by: Conor Dooley <conor.dooley@microchip.com>
>
> Hey Luc,
> Would you be able to take a look at this patch and at
> https://lore.kernel.org/linux-sparse/YvYQSdQBuZGSit2s@wendy/T/#t
> please? They're causing sparse to fail for recent kernels when the
> extensions are used.

Just kind of thinking out loud here, but:

Another option would be to just convert the kernel over to Kconfig-based 
ifdefs and ignore the -march stuff in sparse.  As per the discussion 
over here <https://github.com/riscv/riscv-isa-manual/issues/869> it 
looks like we're going to end up with different string->behavior 
mappings for user-mode vs privileged software and compilers will be 
expected to follow the user-mode mappings, so we'll probably have to do 
this at some point anyway.

That would mean sparse only works right for Linux, I'm not sure if 
that's the design point today or not.  If that's an issue we could still 
convert Linux over and then just have some sort of 
"--sparse-ignore-march-on-riscv" argument so we don't keep coupling 
kernel builds to sparse updates.  There's going to be a ton of new 
extensions so this kind of thing is just going to keep happening.

>
> Thanks,
> Conor.
>
>>
>> > Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>
>> > ---
>> >  target-riscv.c | 4 ++++
>> >  1 file changed, 4 insertions(+)
>> >
>> > diff --git a/target-riscv.c b/target-riscv.c
>> > index 217ab7e8..db0f7e57 100644
>> > --- a/target-riscv.c
>> > +++ b/target-riscv.c
>> > @@ -19,6 +19,7 @@
>> >  #define RISCV_GENERIC	(RISCV_MUL|RISCV_DIV|RISCV_ATOMIC|RISCV_FPU)
>> >  #define RISCV_ZICSR	(1 << 10)
>> >  #define RISCV_ZIFENCEI	(1 << 11)
>> > +#define RISCV_ZICBOM	(1 << 12)
>> >
>> >  static unsigned int riscv_flags;
>> >
>> > @@ -41,6 +42,7 @@ static void parse_march_riscv(const char *arg)
>> >  		{ "c",		RISCV_COMP },
>> >  		{ "_zicsr",	RISCV_ZICSR },
>> >  		{ "_zifencei",	RISCV_ZIFENCEI },
>> > +		{ "_zicbom",	RISCV_ZICBOM },
>> >  	};
>> >  	int i;
>> >
>> > @@ -131,6 +133,8 @@ static void predefine_riscv(const struct target *self)
>> >  		predefine("__riscv_zicsr", 1, "1");
>> >  	if (riscv_flags & RISCV_ZIFENCEI)
>> >  		predefine("__riscv_zifencei", 1, "1");
>> > +	if (riscv_flags & RISCV_ZICBOM)
>> > +		predefine("__riscv_zicbom", 1, "1");
>> >
>> >  	if (cmodel)
>> >  		predefine_strong("__riscv_cmodel_%s", cmodel);
>> > --
>> > 2.34.1
>> >
>>
================================================================================

From: Conor Dooley <conor.dooley () microchip ! com>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support for the zicbom extension
Date: Thu, 13 Oct 2022 11:34:44 +0000
Message-ID: <Y0f31LvsmVePDzo0 () wendy>
--------------------
On Wed, Oct 12, 2022 at 04:34:00PM -0700, Palmer Dabbelt wrote:
> On Wed, 12 Oct 2022 14:11:58 PDT (-0700), Conor Dooley wrote:
> > On Fri, Aug 12, 2022 at 09:25:23AM +0100, Conor Dooley wrote:
> > > On Wed, Aug 10, 2022 at 08:31:38PM -0700, Palmer Dabbelt wrote:
> > > > This was recently added to binutils and with any luck will soon be in
> > > > Linux, without it sparse will fail when trying to build new kernels on
> > > > systems with new toolchains.
> > > >
> > > 
> > > In passing while testing the zihintpause one:
> > > Tested-by: Conor Dooley <conor.dooley@microchip.com>
> > 
> > Hey Luc,
> > Would you be able to take a look at this patch and at
> > https://lore.kernel.org/linux-sparse/YvYQSdQBuZGSit2s@wendy/T/#t
> > please? They're causing sparse to fail for recent kernels when the
> > extensions are used.
> 
> Just kind of thinking out loud here, but:

Wee brain dump in response, dunno if I am missing your point & if so
please correct me...

> 
> Another option would be to just convert the kernel over to Kconfig-based
> ifdefs and ignore the -march stuff in sparse.  As per the discussion over
> here <https://github.com/riscv/riscv-isa-manual/issues/869> it looks like

hmm, gnu tools meetings - are bystanders like myself allowed to attend?
I doubt I'd have anything interesting to say, but given the names it
seems like a good thing to keep an eye on.

To be blunt, if the toolchain people are not clear on what the craic is
with how extensions interact how are the rest of us supposed to get it?
In my naivety I'd expect that sort of distinction to be clear from the
spec docs...

By kconfig based, do you mean w/ the sort of thing I was messing with in
this patchset:
https://lore.kernel.org/linux-riscv/20221006173520.1785507-2-conor@kernel.org/

I really don't like having ifdef-ery, seems to just result in missed
conditions as the recent Zicbom stuff has shown. Since it's thinking-
out-loud o clock - while its not my place to make decisions, I think for
future extension patchsets I am going to try and push people towards as
few conditionally defined variables etc as possible.
I think you said the other day that things like __riscv_zmmul are
conditionally defined based on the toolchain supporting them right?
That'd make sense since older toolchains wouldn't know they existed...
Anyways, what I meant by all that is that instead of ifdef-ery, I'd
rather IS_ENABLED() with unconditionally {defined,defined} variables so
that we don't end up with little pockets of code that end up missed
because of some overlapping extension ifdef hell.

Upstream seems to have a lot of people that run bells & whistles
toolchains with the new & shiny toys available or the standard
riscv-gnu-toolchain builds of something significantly older. I'd just be
a little worried about potentially having poor coverage of some odd
combinations of things with #ifdefs.

> we're going to end up with different string->behavior mappings for user-mode
> vs privileged software and compilers will be expected to follow the
> user-mode mappings, so we'll probably have to do this at some point anyway.

Could you explain this one a little more? Even after reading that issue
I am a little unsure what you mean by different string->behaviour
mappings. Something along the lines of some Zfoo extension could deny
user-mode software from using certain instructions but in kernel-land we
would want to (or need to?) use those instructions?

> That would mean sparse only works right for Linux, I'm not sure if that's
> the design point today or not.  If that's an issue we could still convert
> Linux over and then just have some sort of "--sparse-ignore-march-on-riscv"

Do we ignore march, or could we just chop the string after the single
letter extensions? I am not up on how much of (if any) of the march
string is/would ever be used. I had a quick look at target-riscv.c and
it seems we just use it to predefine __riscv_foo & set xlen. Does that
mean if we used ifdef-ery or IS_ENABLED to gate features we could avoid
having to use new __riscv_foo symbols and therefore not have to
predefine them in sparse? Maybe I am misunderstanding - something,
something out of my depth...

> argument so we don't keep coupling kernel builds to sparse updates.  There's
> going to be a ton of new extensions so this kind of thing is just going to
> keep happening.

Yeah, it'd be nice to avoid having to deal with new march updates
constantly, especially since we cannot expect everyone to run ToT sparse
either. The current situation makes me wonder who outside the pair of us
is even running sparse in the first place?

Thanks,
Conor.



> > > > Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>
> > > > ---
> > > >  target-riscv.c | 4 ++++
> > > >  1 file changed, 4 insertions(+)
> > > >
> > > > diff --git a/target-riscv.c b/target-riscv.c
> > > > index 217ab7e8..db0f7e57 100644
> > > > --- a/target-riscv.c
> > > > +++ b/target-riscv.c
> > > > @@ -19,6 +19,7 @@
> > > >  #define RISCV_GENERIC	(RISCV_MUL|RISCV_DIV|RISCV_ATOMIC|RISCV_FPU)
> > > >  #define RISCV_ZICSR	(1 << 10)
> > > >  #define RISCV_ZIFENCEI	(1 << 11)
> > > > +#define RISCV_ZICBOM	(1 << 12)
> > > >
> > > >  static unsigned int riscv_flags;
> > > >
> > > > @@ -41,6 +42,7 @@ static void parse_march_riscv(const char *arg)
> > > >  		{ "c",		RISCV_COMP },
> > > >  		{ "_zicsr",	RISCV_ZICSR },
> > > >  		{ "_zifencei",	RISCV_ZIFENCEI },
> > > > +		{ "_zicbom",	RISCV_ZICBOM },
> > > >  	};
> > > >  	int i;
> > > >
> > > > @@ -131,6 +133,8 @@ static void predefine_riscv(const struct target *self)
> > > >  		predefine("__riscv_zicsr", 1, "1");
> > > >  	if (riscv_flags & RISCV_ZIFENCEI)
> > > >  		predefine("__riscv_zifencei", 1, "1");
> > > > +	if (riscv_flags & RISCV_ZICBOM)
> > > > +		predefine("__riscv_zicbom", 1, "1");
> > > >
> > > >  	if (cmodel)
> > > >  		predefine_strong("__riscv_cmodel_%s", cmodel);
> > > > --
> > > > 2.34.1
> > > >
> > > 
> 
================================================================================

From: Geert Uytterhoeven <geert () linux-m68k ! org>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support for the zicbom extension
Date: Fri, 15 Dec 2023 12:37:14 +0000
Message-ID: <6bc5bd6-afde-3d5f-6780-97d26f58a33 () linux-m68k ! org>
--------------------
On Fri, 12 Aug 2022, Conor Dooley wrote:
> On Wed, Aug 10, 2022 at 08:31:38PM -0700, Palmer Dabbelt wrote:
>> This was recently added to binutils and with any luck will soon be in
>> Linux, without it sparse will fail when trying to build new kernels on
>> systems with new toolchains.
>>
>
> In passing while testing the zihintpause one:
> Tested-by: Conor Dooley <conor.dooley@microchip.com>

Likewise:
Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>

Gr{oetje,eeting}s,

 						Geert

--
Geert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k.org

In personal conversations with technical people, I call myself a hacker. But
when I'm talking to journalists I just say "programmer" or something like that.
 							    -- Linus Torvalds

================================================================================

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] RISC-V: Add support for the zicbom extension
Date: Mon, 18 Dec 2023 13:58:32 +0000
Message-ID: <33kzvc5b3lo5uk7pkx5n57janjfkvyjimzgym2dbhw5y3rg7fn () quhub5jeh63i>
--------------------
On Wed, Aug 10, 2022 at 08:31:38PM -0700, Palmer Dabbelt wrote:
> This was recently added to binutils and with any luck will soon be in
> Linux, without it sparse will fail when trying to build new kernels on
> systems with new toolchains.
> 
> Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>

Pushed to mainline now. Sorry for this very long delay.
-- Luc

================================================================================


################################################################################

=== Thread: [PATCH] compiler.h: unify __UNIQUE_ID ===

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-sparse
Subject: [PATCH] compiler.h: unify __UNIQUE_ID
Date: Thu, 31 Aug 2023 16:33:40 +0000
Message-ID: <20230831-unique_id-v1-1-28bacd18eb1d () google ! com>
--------------------
commit 6f33d58794ef ("__UNIQUE_ID()")
added a fallback definition of __UNIQUE_ID because gcc 4.2 and older did
not support __COUNTER__.

Also, this commit is effectively a revert of
commit b41c29b0527c ("Kbuild: provide a __UNIQUE_ID for clang")
which mentions clang 2.6+ supporting __COUNTER__.

Documentation/process/changes.rst currently lists the minimum supported
version of these compilers as:
- gcc: 5.1
- clang: 11.0.0
It should be safe to say that __COUNTER__ is well supported by this
point.

Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
---
 include/linux/compiler-clang.h | 5 -----
 include/linux/compiler-gcc.h   | 2 --
 include/linux/compiler.h       | 5 +----
 3 files changed, 1 insertion(+), 11 deletions(-)

diff --git a/include/linux/compiler-clang.h b/include/linux/compiler-clang.h
index 9b673fefcef8..ddab1ef22bee 100644
--- a/include/linux/compiler-clang.h
+++ b/include/linux/compiler-clang.h
@@ -14,11 +14,6 @@
 #undef __cleanup
 #define __cleanup(func) __maybe_unused __attribute__((__cleanup__(func)))
 
-/* same as gcc, this was present in clang-2.6 so we can assume it works
- * with any version that can compile the kernel
- */
-#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
-
 /* all clang versions usable with the kernel support KASAN ABI version 5 */
 #define KASAN_ABI_VERSION 5
 
diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 7af9e34ec261..2ceba3fe4ec1 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -39,8 +39,6 @@
 #define __noretpoline __attribute__((__indirect_branch__("keep")))
 #endif
 
-#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
-
 #if defined(LATENT_ENTROPY_PLUGIN) && !defined(__CHECKER__)
 #define __latent_entropy __attribute__((latent_entropy))
 #endif
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index d7779a18b24f..174099fdc485 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -177,10 +177,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 	__asm__ ("" : "=r" (var) : "0" (var))
 #endif
 
-/* Not-quite-unique ID. */
-#ifndef __UNIQUE_ID
-# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)
-#endif
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
 
 /**
  * data_race - mark an expression as containing intentional data races

---
base-commit: b97d64c722598ffed42ece814a2cb791336c6679
change-id: 20230831-unique_id-483938cc20aa

Best regards,
-- 
Nick Desaulniers <ndesaulniers@google.com>

================================================================================


################################################################################

=== Thread: [PATCH] handle protoype scope ===

From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
To: Unknown
Subject: [PATCH] handle protoype scope
Date: Wed, 20 Dec 2023 22:00:05 +0100
Message-ID: 
--------------------
In C99 and later, the size in an array declaration can be either:
a)	D[ ]
b)	D[ * ]
b)	D[ assignment-expression ]
(each optionally preceded by some qualifiers).

Parsing them correctly when the size is present and not an integer
constant expression requires to have the notion of function prototype scope.

Sparse doesn't have yet such a scope which results in pair of error messages like:
	error: undefined identifier
	error: bad constant expression type

Fix this by adding the notion of prototype scope in the form of a block scope
opened and then closed when parsing the parameter list.

Note:
   It's a bit ugly because it is not known if a function declaration
   is a prototype or the start of a function definition before the function
   body is encountered.
---
 parse.c                      |  8 ++++
 validation/prototype-scope.c | 31 +++++++++++++++
 validation/specifiers2.c     | 73 ++++++++++++++++++++++++++++++++++++
 3 files changed, 112 insertions(+)
 create mode 100644 validation/prototype-scope.c

diff --git a/parse.c b/parse.c
index f868bf63a0f5..b24193e2ee65 100644
--- a/parse.c
+++ b/parse.c
@@ -2593,6 +2593,7 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn)
 {
 	struct symbol_list **list = &fn->arguments;
 
+	start_block_scope();
 	for (;;) {
 		struct symbol *sym;
 
@@ -2611,10 +2612,15 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn)
 			warning(token->pos, "void parameter");
 		}
 		add_symbol(list, sym);
+		// do not bind if there is no ident:
+		// it's ok for declarations, it'll be warned when parsing the body
+		if (sym->ident)
+			bind_symbol(sym, sym->ident, NS_SYMBOL);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
 	}
+	end_block_scope();
 	return token;
 }
 
@@ -2762,6 +2768,8 @@ static void declare_argument(struct symbol *sym, struct symbol *fn)
 				show_ident(sym->ident));
 		}
 	}
+	// They were previously in the prototype scope.
+	sym->bound = 0;
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
 }
 
diff --git a/validation/prototype-scope.c b/validation/prototype-scope.c
new file mode 100644
index 000000000000..19dbd7265602
--- /dev/null
+++ b/validation/prototype-scope.c
@@ -0,0 +1,31 @@
+struct stuff;
+
+int good(int n, int arr[n]);
+int good(int x, int ptr[x]);
+int good(int n, int arr[n]) { return arr[n - 1]; }
+
+int ugly(int arr[n], int n);
+int  bad(int i, int arr[n]);
+
+int test(int n, int arr[])
+{
+	int a = 0;
+
+	a += good(n, arr);
+	a += ugly(arr, n);
+	a +=  bad(n, arr);
+
+       return a;
+}
+
+/*
+ * check-name: prototype-scope
+ * check-command: sparse -Wno-vla $file
+ *
+ * check-error-start
+prototype-scope.c:7:18: error: undefined identifier 'n'
+prototype-scope.c:7:18: error: bad constant expression type
+prototype-scope.c:8:25: error: undefined identifier 'n'
+prototype-scope.c:8:25: error: bad constant expression type
+ * check-error-end
+ */
diff --git a/validation/specifiers2.c b/validation/specifiers2.c
index d5be118bd2ac..cd848386e2a2 100644
--- a/validation/specifiers2.c
+++ b/validation/specifiers2.c
@@ -75,78 +75,151 @@ void void
 );
 /*
  * check-name: invalid specifier combinations
+ * check-command: sparse -fmax-warnings=unlimited -fmax-errors=unlimited $file
  * check-error-start
 specifiers2.c:3:6: error: two or more data types in declaration specifiers
+specifiers2.c:3:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:4:6: error: two or more data types in declaration specifiers
+specifiers2.c:4:1: error: Trying to use reserved word 'int' as identifier
 specifiers2.c:5:6: error: two or more data types in declaration specifiers
+specifiers2.c:5:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:6:6: error: two or more data types in declaration specifiers
+specifiers2.c:6:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:7:6: error: impossible combination of type specifiers: char long
+specifiers2.c:7:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:8:6: error: impossible combination of type specifiers: char short
+specifiers2.c:8:1: error: Trying to use reserved word 'short' as identifier
 specifiers2.c:9:5: error: two or more data types in declaration specifiers
+specifiers2.c:9:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:10:5: error: two or more data types in declaration specifiers
+specifiers2.c:10:1: error: Trying to use reserved word 'int' as identifier
 specifiers2.c:11:5: error: two or more data types in declaration specifiers
+specifiers2.c:11:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:12:5: error: two or more data types in declaration specifiers
+specifiers2.c:12:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:13:8: error: two or more data types in declaration specifiers
+specifiers2.c:13:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:14:8: error: two or more data types in declaration specifiers
+specifiers2.c:14:1: error: Trying to use reserved word 'int' as identifier
 specifiers2.c:15:8: error: two or more data types in declaration specifiers
+specifiers2.c:15:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:16:8: error: two or more data types in declaration specifiers
+specifiers2.c:16:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:17:8: error: impossible combination of type specifiers: double short
+specifiers2.c:17:1: error: Trying to use reserved word 'short' as identifier
 specifiers2.c:18:8: error: impossible combination of type specifiers: double signed
+specifiers2.c:18:1: error: Trying to use reserved word 'signed' as identifier
 specifiers2.c:19:8: error: impossible combination of type specifiers: double unsigned
+specifiers2.c:19:1: error: Trying to use reserved word 'unsigned' as identifier
 specifiers2.c:20:7: error: two or more data types in declaration specifiers
+specifiers2.c:20:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:21:7: error: two or more data types in declaration specifiers
+specifiers2.c:21:1: error: Trying to use reserved word 'int' as identifier
 specifiers2.c:22:7: error: two or more data types in declaration specifiers
+specifiers2.c:22:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:23:7: error: two or more data types in declaration specifiers
+specifiers2.c:23:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:24:7: error: impossible combination of type specifiers: float short
+specifiers2.c:24:1: error: Trying to use reserved word 'short' as identifier
 specifiers2.c:25:7: error: impossible combination of type specifiers: float long
+specifiers2.c:25:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:26:7: error: impossible combination of type specifiers: float signed
+specifiers2.c:26:1: error: Trying to use reserved word 'signed' as identifier
 specifiers2.c:27:7: error: impossible combination of type specifiers: float unsigned
+specifiers2.c:27:1: error: Trying to use reserved word 'unsigned' as identifier
 specifiers2.c:28:7: error: impossible combination of type specifiers: short char
+specifiers2.c:28:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:29:7: error: impossible combination of type specifiers: short double
+specifiers2.c:29:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:30:7: error: impossible combination of type specifiers: short float
+specifiers2.c:30:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:31:7: error: impossible combination of type specifiers: short short
+specifiers2.c:31:1: error: Trying to use reserved word 'short' as identifier
 specifiers2.c:32:7: error: impossible combination of type specifiers: short long
+specifiers2.c:32:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:33:6: error: impossible combination of type specifiers: long char
+specifiers2.c:33:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:34:6: error: impossible combination of type specifiers: long float
+specifiers2.c:34:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:35:6: error: impossible combination of type specifiers: long short
+specifiers2.c:35:1: error: Trying to use reserved word 'short' as identifier
 specifiers2.c:36:8: error: impossible combination of type specifiers: signed double
+specifiers2.c:36:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:37:8: error: impossible combination of type specifiers: signed float
+specifiers2.c:37:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:38:8: error: impossible combination of type specifiers: signed signed
+specifiers2.c:38:1: error: Trying to use reserved word 'signed' as identifier
 specifiers2.c:39:8: error: impossible combination of type specifiers: signed unsigned
+specifiers2.c:39:1: error: Trying to use reserved word 'unsigned' as identifier
 specifiers2.c:40:10: error: impossible combination of type specifiers: unsigned double
+specifiers2.c:40:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:41:10: error: impossible combination of type specifiers: unsigned float
+specifiers2.c:41:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:42:10: error: impossible combination of type specifiers: unsigned signed
+specifiers2.c:42:1: error: Trying to use reserved word 'signed' as identifier
 specifiers2.c:43:10: error: impossible combination of type specifiers: unsigned unsigned
+specifiers2.c:43:1: error: Trying to use reserved word 'unsigned' as identifier
 specifiers2.c:44:10: error: impossible combination of type specifiers: unsigned signed
+specifiers2.c:44:1: error: Trying to use reserved word 'signed' as identifier
 specifiers2.c:45:11: error: impossible combination of type specifiers: long long long
+specifiers2.c:45:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:46:13: error: impossible combination of type specifiers: long long double
+specifiers2.c:46:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:47:11: error: impossible combination of type specifiers: long long double
+specifiers2.c:47:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:48:13: error: impossible combination of type specifiers: long long double
+specifiers2.c:48:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:49:3: error: two or more data types in declaration specifiers
+specifiers2.c:49:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:50:3: error: two or more data types in declaration specifiers
+specifiers2.c:50:1: error: Trying to use reserved word 'int' as identifier
 specifiers2.c:51:3: error: two or more data types in declaration specifiers
+specifiers2.c:51:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:52:3: error: two or more data types in declaration specifiers
+specifiers2.c:52:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:53:3: error: two or more data types in declaration specifiers
+specifiers2.c:53:1: error: Trying to use reserved word 'short' as identifier
 specifiers2.c:54:3: error: two or more data types in declaration specifiers
+specifiers2.c:54:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:55:3: error: two or more data types in declaration specifiers
+specifiers2.c:55:1: error: Trying to use reserved word 'signed' as identifier
 specifiers2.c:56:3: error: two or more data types in declaration specifiers
+specifiers2.c:56:1: error: Trying to use reserved word 'unsigned' as identifier
 specifiers2.c:57:3: error: two or more data types in declaration specifiers
+specifiers2.c:57:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:58:6: error: two or more data types in declaration specifiers
+specifiers2.c:58:1: error: Trying to use reserved word 'char' as identifier
 specifiers2.c:59:6: error: two or more data types in declaration specifiers
+specifiers2.c:59:1: error: Trying to use reserved word 'int' as identifier
 specifiers2.c:60:6: error: two or more data types in declaration specifiers
+specifiers2.c:60:1: error: Trying to use reserved word 'double' as identifier
 specifiers2.c:61:6: error: two or more data types in declaration specifiers
+specifiers2.c:61:1: error: Trying to use reserved word 'float' as identifier
 specifiers2.c:62:6: error: two or more data types in declaration specifiers
+specifiers2.c:62:1: error: Trying to use reserved word 'short' as identifier
 specifiers2.c:63:6: error: two or more data types in declaration specifiers
+specifiers2.c:63:1: error: Trying to use reserved word 'long' as identifier
 specifiers2.c:64:6: error: two or more data types in declaration specifiers
+specifiers2.c:64:1: error: Trying to use reserved word 'signed' as identifier
 specifiers2.c:65:6: error: two or more data types in declaration specifiers
+specifiers2.c:65:1: error: Trying to use reserved word 'unsigned' as identifier
 specifiers2.c:66:6: error: two or more data types in declaration specifiers
+specifiers2.c:66:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:67:5: error: two or more data types in declaration specifiers
+specifiers2.c:67:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:68:8: error: two or more data types in declaration specifiers
+specifiers2.c:68:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:69:7: error: two or more data types in declaration specifiers
+specifiers2.c:69:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:70:7: error: impossible combination of type specifiers: short void
+specifiers2.c:70:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:71:6: error: impossible combination of type specifiers: long void
+specifiers2.c:71:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:72:8: error: impossible combination of type specifiers: signed void
+specifiers2.c:72:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:73:10: error: impossible combination of type specifiers: unsigned void
+specifiers2.c:73:1: error: Trying to use reserved word 'void' as identifier
 specifiers2.c:74:6: error: two or more data types in declaration specifiers
+specifiers2.c:74:1: error: Trying to use reserved word 'void' as identifier
  * check-error-end
  */

base-commit: adceff0ab6e3d8bf43de52e2c2fbebf27db30deb
-- 
2.43.0


================================================================================


################################################################################

=== Thread: [PATCH] linearize.c: fix potential buffer overrun ===

From: Jeff Layton <jlayton () kernel ! org>
To: linux-sparse
Subject: [PATCH] linearize.c: fix potential buffer overrun
Date: Wed, 22 Feb 2023 15:52:44 +0000
Message-ID: <20230222155244.133890-1-jlayton () kernel ! org>
--------------------
The resulting string won't be nearly 64 bytes, but "buf" is only 16
bytes long here, and this causes FORTIFY_SOURCE to barf when given the
right options.

Signed-off-by: Jeff Layton <jlayton@kernel.org>
---
 linearize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index d9aed61b361f..1db2d505a7d4 100644
--- a/linearize.c
+++ b/linearize.c
@@ -91,7 +91,7 @@ const char *show_label(struct basic_block *bb)
 
 	if (!bb)
 		return ".L???";
-	snprintf(buf, 64, ".L%u", bb->nr);
+	snprintf(buf, 16, ".L%u", bb->nr);
 	return buf;
 }
 
-- 
2.39.2

================================================================================

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] linearize.c: fix potential buffer overrun
Date: Mon, 18 Dec 2023 13:56:01 +0000
Message-ID: <q5nxyfe6t4mguhtxtvh7a6wbct4bctj6ynrvd3pftvmiw5rymg () fl4cprexyjhm>
--------------------
On Wed, Feb 22, 2023 at 10:52:44AM -0500, Jeff Layton wrote:
> The resulting string won't be nearly 64 bytes, but "buf" is only 16
> bytes long here, and this causes FORTIFY_SOURCE to barf when given the
> right options.
> 
> Signed-off-by: Jeff Layton <jlayton@kernel.org>

Pushed to mainline now. Sorry for this very long delay.
-- Luc

================================================================================


################################################################################

=== Thread: [PATCH] tools: Rename __fallthrough to fallthrough ===

From: Arnaldo Carvalho de Melo <acme () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] tools: Rename __fallthrough to fallthrough
Date: Thu, 06 Apr 2023 21:35:15 +0000
Message-ID: <ZC87E1QjLjGshw9i () kernel ! org>
--------------------
Em Thu, Apr 06, 2023 at 06:32:42PM -0300, Arnaldo Carvalho de Melo escreveu:
> Em Thu, Apr 06, 2023 at 06:31:32PM -0300, Arnaldo Carvalho de Melo escreveu:
> >                  from /usr/include/glib-2.0/gio/giotypes.h:30,
> >                  from /usr/include/glib-2.0/gio/gio.h:28,
> >                  from /usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h:30,
> >                  from /usr/include/gtk-2.0/gdk/gdk.h:32,
> >                  from /usr/include/gtk-2.0/gtk/gtk.h:32,
> >                  from ui/gtk/gtk.h:8,
> >                  from ui/gtk/helpline.c:6:
> > /usr/include/glib-2.0/glib/gmacros.h:637:28: error: missing ')' after "__has_attribute"
> >   637 | #if g_macro__has_attribute(fallthrough)
> >       |                            ^~~~~~~~~~~
> 
> I'm now trying with:
> 
> diff --git a/tools/perf/ui/gtk/browser.c b/tools/perf/ui/gtk/browser.c
> index 8f3e43d148a8560b..d2dadf3873fbdf41 100644
> --- a/tools/perf/ui/gtk/browser.c
> +++ b/tools/perf/ui/gtk/browser.c
> @@ -1,9 +1,9 @@
>  // SPDX-License-Identifier: GPL-2.0
> +#include "gtk.h"
>  #include "../evsel.h"
>  #include "../sort.h"
>  #include "../hist.h"
>  #include "../helpline.h"
> -#include "gtk.h"

Some more was needed, folding it with your patch.

- Arnaldo

diff --git a/tools/perf/ui/gtk/browser.c b/tools/perf/ui/gtk/browser.c
index 8f3e43d148a8560b..d2dadf3873fbdf41 100644
--- a/tools/perf/ui/gtk/browser.c
+++ b/tools/perf/ui/gtk/browser.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
+#include "gtk.h"
 #include "../evsel.h"
 #include "../sort.h"
 #include "../hist.h"
 #include "../helpline.h"
-#include "gtk.h"
 
 #include <signal.h>
 
diff --git a/tools/perf/ui/gtk/helpline.c b/tools/perf/ui/gtk/helpline.c
index e40a006aead87b9b..8ea95898a5bd0295 100644
--- a/tools/perf/ui/gtk/helpline.c
+++ b/tools/perf/ui/gtk/helpline.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
+#include "gtk.h"
 #include <stdio.h>
 #include <string.h>
 #include <linux/kernel.h>
 
-#include "gtk.h"
 #include "../ui.h"
 #include "../helpline.h"
 
diff --git a/tools/perf/ui/gtk/hists.c b/tools/perf/ui/gtk/hists.c
index c83be2d57f7eb7a7..bae21f336ae6d576 100644
--- a/tools/perf/ui/gtk/hists.c
+++ b/tools/perf/ui/gtk/hists.c
@@ -1,4 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
+#include "gtk.h"
 #include "../evlist.h"
 #include "../callchain.h"
 #include "../evsel.h"
@@ -6,7 +7,6 @@
 #include "../hist.h"
 #include "../helpline.h"
 #include "../string2.h"
-#include "gtk.h"
 #include <signal.h>
 #include <stdlib.h>
 #include <linux/string.h>
================================================================================


################################################################################

=== Thread: [PATCH] xtensa: switch to little endianness ===

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] xtensa: switch to little endianness
Date: Mon, 18 Dec 2023 13:57:05 +0000
Message-ID: <dyhz44tm67zxgdqau7zv4kwpwfphhw6tb2jyhe3ck2uwglt7pv () rk3ycau5cqb7>
--------------------
On Wed, Nov 16, 2022 at 05:55:25PM +0100, Guennadi Liakhovetski wrote:
> Current gcc options only support the little endian mode on Xtensa,
> switch over to it.
> 
> Signed-off-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>

Pushed to mainline now. Sorry for this very long delay.
-- Luc

================================================================================


################################################################################

=== Thread: [error27/smatch] sparse-llvm: Update function calls to use LLVM API changes (PR #6) ===

From: Vladimir Petko <vladimir.petko () canonical ! com>
To: linux-sparse
Subject: Re: [error27/smatch] sparse-llvm: Update function calls to use LLVM API changes (PR #6)
Date: Thu, 04 May 2023 08:01:29 +0000
Message-ID: <CALFf3kc9AcFYXwhu7+g_t5U4U+pD860kW5Tw8dYJb1AjBGp_8Q () mail ! gmail ! com>
--------------------
--0000000000001b51cc05fad99547
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable

Dear Sparse Maintainers,

I am copying the bug report[1] to the mailing list as per the email below.

Building sparse-llvm against LLVM 15 results in test failures due to the
segmentation faults[2].
Would it be possible to consider an attached patch to migrate the
sparse-llvm source code to the opaque pointers [3] at some point?

Best Regards,
 Vladimir.

[1] https://bugzilla.kernel.org/show_bug.cgi?id=3D217153
[2] https://launchpadlibrarian.net/654787464/sparse_0.6.4-3_amd64-2023-03-0=
6T19%3A31%3A07Z.build
[3] https://llvm.org/docs/OpaquePointers.html

On Wed, May 3, 2023 at 2:54=E2=80=AFPM Dan Carpenter <dan.carpenter@linaro.=
org> wrote:
>
> Hi Gleb,
>
> I don't maintain Sparse.
>
> I'm afraid you're going to have to send this as a patch to the Sparse
> mailing list.  They don't do git pulls.
>
> linux-sparse@vger.kernel.org
>
> The documentation for how to send code to Sparse seems to be bad
> because I'm seeing now that Vladimir Petko filed a bugzilla to get
> their LLVM code merged...  Let me add him to the CC list.
>
> regards,
> dan carpenter
>
> On Wed, May 03, 2023 at 05:40:12AM -0700, Gleb Chesnokov wrote:
> > This patch updates sparse-llvm to use the newer LLVM API functions, rep=
lacing the deprecated functions with their updated counterparts:
> >
> > - Replace LLVMConstGEP with LLVMConstGEP2
> > - Replace LLVMBuildInBoundsGEP with LLVMBuildInBoundsGEP2
> > - Replace LLVMBuildLoad with LLVMBuildLoad2
> > - Replace LLVMBuildCall with LLVMBuildCall2
> >
> > The patch also ensures that the correct element types are passed to the=
 new functions as required.
> > You can view, comment on, or merge this pull request online at:
> >
> >   https://github.com/error27/smatch/pull/6
> >
> > -- Commit Summary --
> >
> >   * sparse-llvm: Update function calls to use LLVM API changes
> >
> > -- File Changes --
> >
> >     M sparse-llvm.c (16)
> >
> > -- Patch Links --
> >
> > https://github.com/error27/smatch/pull/6.patch
> > https://github.com/error27/smatch/pull/6.diff
> >
> > --
> > Reply to this email directly or view it on GitHub:
> > https://github.com/error27/smatch/pull/6
> > You are receiving this because you are subscribed to this thread.
> >
> > Message ID: &lt;error27/smatch/pull/6@github.com&gt;

--0000000000001b51cc05fad99547
Content-Type: text/x-patch; charset="US-ASCII"; name="llvm-15.diff"
Content-Disposition: attachment; filename="llvm-15.diff"
Content-Transfer-Encoding: base64
Content-ID: <f_lh8u73010>
X-Attachment-Id: f_lh8u73010

RGVzY3JpcHRpb246IEZpeCBMTFZNIDE1IGRlcHJlY2F0aW9uIHdhcm5pbmdzCiBMTFZNIDE1IHN3
aXRjaGVkIHRvIG9wYXF1ZSBwb2ludGVycyBieSBkZWZhdWx0IGFuZCBubyBsb25nZXIgc3VwcG9y
dHMgdHlwZWQgcG9pbnRlcnMuCiBSZW1vdmUgZGVwcmVjYXRlZCBMTFZNIGNhbGxzLCB1cGRhdGUg
dGVzdCB0byByZW1vdmUgdHlwZWQgcG9pbnRlcnMuCkF1dGhvcjogVmxhZGltaXIgUGV0a28gPHZs
YWRpbWlyLnBldGtvQGNhbm9uaWNhbC5jb20+Ckxhc3QtVXBkYXRlOiAyMDIzLTAzLTA3IAotLS0K
VGhpcyBwYXRjaCBoZWFkZXIgZm9sbG93cyBERVAtMzogaHR0cDovL2RlcC5kZWJpYW4ubmV0L2Rl
cHMvZGVwMy8KLS0tIGEvc3BhcnNlLWxsdm0uYworKysgYi9zcGFyc2UtbGx2bS5jCkBAIC0yOTUs
MTQgKzI5NSwxOCBAQAogCQljYXNlIEVYUFJfU1RSSU5HOiB7CiAJCQljb25zdCBjaGFyICpzID0g
ZXhwci0+c3RyaW5nLT5kYXRhOwogCQkJTExWTVZhbHVlUmVmIGluZGljZXNbXSA9IHsgTExWTUNv
bnN0SW50KExMVk1JbnQ2NFR5cGUoKSwgMCwgMCksIExMVk1Db25zdEludChMTFZNSW50NjRUeXBl
KCksIDAsIDApIH07CisJCQlMTFZNVHlwZVJlZiB0eXBlX3JlZiA9IExMVk1BcnJheVR5cGUoTExW
TUludDhUeXBlKCksIHN0cmxlbihzKSArIDEpOwogCQkJTExWTVZhbHVlUmVmIGRhdGE7CiAKLQkJ
CWRhdGEgPSBMTFZNQWRkR2xvYmFsKG1vZHVsZSwgTExWTUFycmF5VHlwZShMTFZNSW50OFR5cGUo
KSwgc3RybGVuKHMpICsgMSksICIuc3RyIik7CisJCQlkYXRhID0gTExWTUFkZEdsb2JhbChtb2R1
bGUsIHR5cGVfcmVmLCAiLnN0ciIpOwogCQkJTExWTVNldExpbmthZ2UoZGF0YSwgTExWTVByaXZh
dGVMaW5rYWdlKTsKIAkJCUxMVk1TZXRHbG9iYWxDb25zdGFudChkYXRhLCAxKTsKIAkJCUxMVk1T
ZXRJbml0aWFsaXplcihkYXRhLCBMTFZNQ29uc3RTdHJpbmcoc3RyZHVwKHMpLCBzdHJsZW4ocykg
KyAxLCB0cnVlKSk7Ci0KKyNpZiBMTFZNX1ZFUlNJT05fTUFKT1IgPiAxNAorCQkJcmVzdWx0ID0g
TExWTUNvbnN0R0VQMih0eXBlX3JlZiwgZGF0YSwgaW5kaWNlcywgQVJSQVlfU0laRShpbmRpY2Vz
KSk7CisjZWxzZQogCQkJcmVzdWx0ID0gTExWTUNvbnN0R0VQKGRhdGEsIGluZGljZXMsIEFSUkFZ
X1NJWkUoaW5kaWNlcykpOworI2VuZGlmCiAJCQlyZXR1cm4gcmVzdWx0OwogCQl9CiAJCWRlZmF1
bHQ6CkBAIC00MDcsNiArNDExLDE0IEBACiAJY2hhciBuYW1lW01BWF9QU0VVRE9fTkFNRV07CiAK
IAlwc2V1ZG9fbmFtZShwc2V1ZG8sIG5hbWUpOworI2lmIExMVk1fVkVSU0lPTl9NQUpPUiA+IDE0
CisJaWYgKExMVk1HZXRUeXBlS2luZChMTFZNVHlwZU9mKHZhbCkpID09IExMVk1Qb2ludGVyVHlw
ZUtpbmQKKwkJJiYgTExWTUdldFR5cGVLaW5kKGR0eXBlKSA9PSBMTFZNSW50ZWdlclR5cGVLaW5k
KSB7CisJCWR0eXBlID0gTExWTUludFR5cGUoYml0c19pbl9wb2ludGVyKTsKKwkJcmV0dXJuIExM
Vk1CdWlsZFB0clRvSW50KGZuLT5idWlsZGVyLCB2YWwsIGR0eXBlLCBuYW1lKTsKKwl9CisJZWxz
ZQorI2VuZGlmCiAJcmV0dXJuIExMVk1CdWlsZEJpdENhc3QoZm4tPmJ1aWxkZXIsIHZhbCwgZHR5
cGUsIG5hbWUpOwogfQogCkBAIC00ODUsNyArNDk3LDExIEBACiAJLyogY29udmVydCBiYXNlIHRv
IGNoYXIqIHR5cGUgKi8KIAliYXNlID0gTExWTUJ1aWxkUG9pbnRlckNhc3QoYnVpbGRlciwgYmFz
ZSwgYnl0ZXAsIG5hbWUpOwogCS8qIGFkZHIgPSBiYXNlICsgb2ZmICovCisjaWYgTExWTV9WRVJT
SU9OX01BSk9SID4gMTQKKwlhZGRyID0gTExWTUJ1aWxkSW5Cb3VuZHNHRVAyKGJ1aWxkZXIsIExM
Vk1UeXBlT2YoYmFzZSksICBiYXNlLCAmb2ZmLCAxLCBuYW1lKTsKKyNlbHNlCiAJYWRkciA9IExM
Vk1CdWlsZEluQm91bmRzR0VQKGJ1aWxkZXIsIGJhc2UsICZvZmYsIDEsIG5hbWUpOworI2VuZGlm
CiAJLyogY29udmVydCBiYWNrIHRvIHRoZSBhY3R1YWwgcG9pbnRlciB0eXBlICovCiAJYWRkciA9
IExMVk1CdWlsZFBvaW50ZXJDYXN0KGJ1aWxkZXIsIGFkZHIsIHR5cGUsIG5hbWUpOwogCXJldHVy
biBhZGRyOwpAQCAtNTkzLDcgKzYwOSw3IEBACiAJY2FzZSBPUF9GRElWOgogCQl0YXJnZXQgPSBM
TFZNQnVpbGRGRGl2KGZuLT5idWlsZGVyLCBsaHMsIHJocywgdGFyZ2V0X25hbWUpOwogCQlicmVh
azsKLQkKKwogCS8qIExvZ2ljYWwgKi8KIAljYXNlIE9QX0FORDoKIAkJYXNzZXJ0KCFpc19mbG9h
dF90eXBlKGluc24tPnR5cGUpKTsKQEAgLTcxMSw3ICs3MjcsMTEgQEAKIAogCS8qIHBlcmZvcm0g
bG9hZCAqLwogCXBzZXVkb19uYW1lKGluc24tPnRhcmdldCwgbmFtZSk7CisjaWYgTExWTV9WRVJT
SU9OX01BSk9SID4gMTQKKwl0YXJnZXQgPSBMTFZNQnVpbGRMb2FkMihmbi0+YnVpbGRlciwgTExW
TVR5cGVPZihhZGRyKSwgYWRkciwgbmFtZSk7CisjZWxzZQogCXRhcmdldCA9IExMVk1CdWlsZExv
YWQoZm4tPmJ1aWxkZXIsIGFkZHIsIG5hbWUpOworI2VuZGlmCiAKIAlpbnNuLT50YXJnZXQtPnBy
aXYgPSB0YXJnZXQ7CiB9CkBAIC03OTQsNiArODE0LDI5IEBACiAJfSBFTkRfRk9SX0VBQ0hfUFRS
KGptcCk7CiB9CiAKKyNpZiBMTFZNX1ZFUlNJT05fTUFKT1IgPiAxNAorc3RhdGljIExMVk1UeXBl
UmVmIG1ha2VfZnVuY3Rpb25fdHlwZShzdHJ1Y3Qgc3ltYm9sICpyZXQsIExMVk1WYWx1ZVJlZiAq
YXJncywgaW50IG5fYXJnKQoreworCWludCBpOworCUxMVk1UeXBlUmVmIHJldF90eXBlID0gc3lt
Ym9sX3R5cGUocmV0KTsKKwlMTFZNVHlwZVJlZiAqdHlwZXMgPSBjYWxsb2Mobl9hcmcsIHNpemVv
ZihMTFZNVHlwZVJlZikpOworCWZvciAoaSA9IDA7IGkgPCBuX2FyZzsrK2kpCisJCXR5cGVzW2ld
ID0gTExWTVR5cGVPZihhcmdzW2ldKTsKKwlyZXR1cm4gTExWTUZ1bmN0aW9uVHlwZShyZXRfdHlw
ZSwgdHlwZXMsIG5fYXJnLCAwKTsKK30KKworc3RhdGljIExMVk1WYWx1ZVJlZiBidWlsZF9jYWxs
KGNoYXIgKm5hbWUsIExMVk1WYWx1ZVJlZiBmdW5jLAorCXN0cnVjdCBmdW5jdGlvbiAqZm4sIHN0
cnVjdCBpbnN0cnVjdGlvbiAqaW5zbiwgTExWTVZhbHVlUmVmICphcmdzLCBpbnQgbl9hcmcpCit7
CisJTExWTVR5cGVSZWYgZnVuY3Rpb25fdHlwZTsKKwlpZiAoaW5zbi0+ZnVuYy0+dHlwZSA9PSBQ
U0VVRE9fU1lNKQorCQlmdW5jdGlvbl90eXBlID0gc3ltYm9sX3R5cGUoaW5zbi0+ZnVuYy0+c3lt
KTsKKwllbHNlCisJCWZ1bmN0aW9uX3R5cGUgPSBtYWtlX2Z1bmN0aW9uX3R5cGUoaW5zbi0+dHlw
ZSwgYXJncywgbl9hcmcpOworCXJldHVybiBMTFZNQnVpbGRDYWxsMihmbi0+YnVpbGRlciwgZnVu
Y3Rpb25fdHlwZSwgZnVuYywgYXJncywgbl9hcmcsIG5hbWUpOworfQorI2VuZGlmCisKIHN0YXRp
YyB2b2lkIG91dHB1dF9vcF9jYWxsKHN0cnVjdCBmdW5jdGlvbiAqZm4sIHN0cnVjdCBpbnN0cnVj
dGlvbiAqaW5zbikKIHsKIAlMTFZNVmFsdWVSZWYgdGFyZ2V0LCBmdW5jOwpAQCAtODE5LDcgKzg2
MiwxMSBAQAogCUZJTklTSF9QVFJfTElTVChjdHlwZSk7CiAKIAlwc2V1ZG9fbmFtZShpbnNuLT50
YXJnZXQsIG5hbWUpOworI2lmIExMVk1fVkVSU0lPTl9NQUpPUiA+IDE0CisJdGFyZ2V0ID0gYnVp
bGRfY2FsbChuYW1lLCBmdW5jLCBmbiwgaW5zbiwgYXJncywgbl9hcmcpOworI2Vsc2UKIAl0YXJn
ZXQgPSBMTFZNQnVpbGRDYWxsKGZuLT5idWlsZGVyLCBmdW5jLCBhcmdzLCBuX2FyZywgbmFtZSk7
CisjZW5kaWYKIAogCWluc24tPnRhcmdldC0+cHJpdiA9IHRhcmdldDsKIH0KLS0tIGEvdmFsaWRh
dGlvbi9iYWNrZW5kL2NhbGwtdmFyaWFkaWMuYworKysgYi92YWxpZGF0aW9uL2JhY2tlbmQvY2Fs
bC12YXJpYWRpYy5jCkBAIC0xMSwxNyArMTEsOSBAQAogLyoKICAqIGNoZWNrLW5hbWU6IGNhbGwt
dmFyaWFkaWMKICAqIGNoZWNrLWNvbW1hbmQ6IHNwYXJzZS1sbHZtLWRpcyAtbTY0ICRmaWxlCisg
KiBjaGVjay1vdXRwdXQtaWdub3JlCisgKiBjaGVjay1vdXRwdXQtY29udGFpbnM6ICwgLi4uKSBA
cHJpbnQocHRyICVBUkcxLiwgaTMyIDEyMCwgaTMyICVBUkcyLiwgaTMyIDgsIGk2NCAlQVJHMy4s
IGk2NCAwLCBwdHIgJUFSRzQuLCBwdHIgbnVsbCkKKyAqIGNoZWNrLW91dHB1dC1jb250YWluczog
ZGVmaW5lIGkzMiBAZm9vKAorICogY2hlY2stb3V0cHV0LWNvbnRhaW5zOiBkZWNsYXJlIGkzMiBA
cHJpbnQoCiAgKgotICogY2hlY2stb3V0cHV0LXN0YXJ0Ci07IE1vZHVsZUlEID0gJzxzdGRpbj4n
Ci1zb3VyY2VfZmlsZW5hbWUgPSAic3BhcnNlIgotCi1kZWZpbmUgaTMyIEBmb28oaTgqICVBUkcx
LiwgaTMyICVBUkcyLiwgaTY0ICVBUkczLiwgaTMyKiAlQVJHNC4pIHsKLUwwOgotICAlUjUuID0g
Y2FsbCBpMzIgKGk4KiwgLi4uKSBAcHJpbnQoaTgqICVBUkcxLiwgaTMyIDEyMCwgaTMyICVBUkcy
LiwgaTMyIDgsIGk2NCAlQVJHMy4sIGk2NCAwLCBpMzIqICVBUkc0LiwgaTgqIG51bGwpCi0gIHJl
dCBpMzIgJVI1LgotfQotCi1kZWNsYXJlIGkzMiBAcHJpbnQoaTgqLCAuLi4pCi0gKiBjaGVjay1v
dXRwdXQtZW5kCiAgKi8K
--0000000000001b51cc05fad99547--
================================================================================


################################################################################

=== Thread: [linux-next:master] BUILD REGRESSION c503e3eec382ac708ee7adf874add37b77c5d312 ===

From: kernel test robot <lkp () intel ! com>
To: linux-sparse
Subject: [linux-next:master] BUILD REGRESSION c503e3eec382ac708ee7adf874add37b77c5d312
Date: Mon, 30 Oct 2023 20:35:23 +0000
Message-ID: <202310310457.5LusQqF6-lkp () intel ! com>
--------------------
tree/branch: https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git master
branch HEAD: c503e3eec382ac708ee7adf874add37b77c5d312  Add linux-next specific files for 20231030

Error/Warning reports:

https://lore.kernel.org/oe-kbuild-all/202310052201.AnVbpgPr-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310121157.aRky475m-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310171905.azfrKoID-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310261059.USL6VstF-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310302025.Pokm9vEs-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310302043.as36UFED-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310302206.Pkr5eBDi-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310302338.MpPQAr10-lkp@intel.com
https://lore.kernel.org/oe-kbuild-all/202310310055.RDWloNPr-lkp@intel.com

Error/Warning: (recently discovered and may have been fixed)

Warning: MAINTAINERS references a file that doesn't exist: Documentation/devicetree/bindings/iio/imu/bosch,bma400.yaml
aarch64-linux-ld: drivers/cxl/core/pci.c:921:(.text+0xbbc): undefined reference to `pci_print_aer'
arch/loongarch/kvm/mmu.c:411:6: warning: no previous prototype for 'kvm_unmap_gfn_range' [-Wmissing-prototypes]
arch/loongarch/kvm/mmu.c:420:48: error: invalid use of undefined type 'struct kvm_gfn_range'
arch/loongarch/kvm/mmu.c:422:1: error: control reaches end of non-void function [-Werror=return-type]
arch/loongarch/kvm/mmu.c:424:6: warning: no previous prototype for 'kvm_set_spte_gfn' [-Wmissing-prototypes]
arch/loongarch/kvm/mmu.c:456:6: warning: no previous prototype for 'kvm_age_gfn' [-Wmissing-prototypes]
arch/loongarch/kvm/mmu.c:468:6: warning: no previous prototype for 'kvm_test_age_gfn' [-Wmissing-prototypes]
arch/loongarch/kvm/mmu.c:787:24: error: 'struct kvm' has no member named 'mmu_invalidate_seq'; did you mean 'mn_invalidate_lock'?
arch/loongarch/kvm/mmu.c:810:13: error: implicit declaration of function 'mmu_invalidate_retry_hva' [-Werror=implicit-function-declaration]
arch/riscv/include/asm/mmio.h:67:(.text+0xd66): undefined reference to `pci_print_aer'
csky-linux-ld: pci.c:(.text+0x6e8): undefined reference to `pci_print_aer'
drivers/cxl/core/pci.c:921: undefined reference to `pci_print_aer'
drivers/cxl/core/pci.c:921:(.text+0xbc0): undefined reference to `pci_print_aer'
drivers/gpu/drm/amd/amdgpu/../display/dc/clk_mgr/dcn35/dcn35_clk_mgr.c:1105 dcn35_clk_mgr_construct() warn: variable dereferenced before check 'ctx->dc_bios' (see line 1032)
drivers/gpu/drm/amd/amdgpu/../display/dc/clk_mgr/dcn35/dcn35_clk_mgr.c:1105 dcn35_clk_mgr_construct() warn: variable dereferenced before check 'ctx->dc_bios->integrated_info' (see line 1032)
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu13/smu_v13_0_6_ppt.c:286:45: warning: '%s' directive output may be truncated writing up to 29 bytes into a region of size 23 [-Wformat-truncation=]
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu13/smu_v13_0_6_ppt.c:286:52: warning: '%s' directive output may be truncated writing up to 29 bytes into a region of size 23 [-Wformat-truncation=]
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu14/smu_v14_0.c:72:45: warning: '%s' directive output may be truncated writing up to 29 bytes into a region of size 23 [-Wformat-truncation=]
drivers/gpu/drm/amd/amdgpu/../pm/swsmu/smu14/smu_v14_0.c:72:52: warning: '%s' directive output may be truncated writing up to 29 bytes into a region of size 23 [-Wformat-truncation=]
drivers/hwtracing/coresight/coresight-etm4x-core.c:1183:24: warning: result of comparison of constant 256 with expression of type 'u8' (aka 'unsigned char') is always false [-Wtautological-constant-out-of-range-compare]
include/linux/atomic/atomic-arch-fallback.h:384:27: error: implicit declaration of function 'arch_cmpxchg_local'; did you mean 'raw_cmpxchg_local'? [-Werror=implicit-function-declaration]
include/linux/compiler.h:212:29: error: pasting "__addressable_" and "(" does not give a valid preprocessing token
include/linux/export.h:47:9: error: pasting "__export_symbol_" and "(" does not give a valid preprocessing token
include/linux/stddef.h:8:15: error: expected declaration specifiers or '...' before '(' token
include/linux/stddef.h:8:16: error: expected identifier or '(' before 'void'
include/linux/stddef.h:8:23: error: expected ')' before numeric constant
include/linux/stddef.h:8:24: error: pasting ")" and "218" does not give a valid preprocessing token
kernel/bpf/task_iter.c:917:29: error: use of undeclared identifier 'CSS_TASK_ITER_THREADED'
kernel/bpf/task_iter.c:917:7: error: use of undeclared identifier 'CSS_TASK_ITER_PROCS'
kernel/bpf/task_iter.c:919:14: error: 'CSS_TASK_ITER_PROCS' undeclared (first use in this function)
kernel/bpf/task_iter.c:919:36: error: 'CSS_TASK_ITER_THREADED' undeclared (first use in this function)
kernel/bpf/task_iter.c:925:46: error: invalid application of 'sizeof' to an incomplete type 'struct css_task_iter'
kernel/bpf/task_iter.c:927:60: error: invalid application of 'sizeof' to incomplete type 'struct css_task_iter'
kernel/bpf/task_iter.c:928:2: error: call to undeclared function 'css_task_iter_start'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]
kernel/bpf/task_iter.c:930:9: error: implicit declaration of function 'css_task_iter_start'; did you mean 'task_seq_start'? [-Werror=implicit-function-declaration]
kernel/bpf/task_iter.c:938:9: error: call to undeclared function 'css_task_iter_next'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]
kernel/bpf/task_iter.c:938:9: error: incompatible integer to pointer conversion returning 'int' from a function with result type 'struct task_struct *' [-Wint-conversion]
kernel/bpf/task_iter.c:940:16: error: implicit declaration of function 'css_task_iter_next'; did you mean 'class_dev_iter_next'? [-Werror=implicit-function-declaration]
kernel/bpf/task_iter.c:947:2: error: call to undeclared function 'css_task_iter_end'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]
kernel/bpf/task_iter.c:949:9: error: implicit declaration of function 'css_task_iter_end' [-Werror=implicit-function-declaration]
ld: drivers/cxl/core/pci.c:921: undefined reference to `pci_print_aer'
loongarch64-linux-ld: drivers/cxl/core/pci.c:921:(.text+0xa38): undefined reference to `pci_print_aer'
pci.c:(.text+0x662): undefined reference to `pci_print_aer'
powerpc-linux-ld: pci.c:(.text+0xf10): undefined reference to `pci_print_aer'
riscv64-linux-ld: pci.c:(.text+0x11ec): undefined reference to `pci_print_aer'

Unverified Error/Warning (likely false positive, please contact us if interested):

drivers/pci/controller/dwc/pcie-rcar-gen4.c:439:15: warning: cast to smaller integer type 'enum dw_pcie_device_mode' from 'const void *' [-Wvoid-pointer-to-enum-cast]
net/bluetooth/hci_event.c:3274 hci_conn_request_evt() warn: variable dereferenced before check 'hdev' (see line 3264)

Error/Warning ids grouped by kconfigs:

gcc_recent_errors
|-- alpha-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- alpha-buildonly-randconfig-r002-20220223
|   `-- include-linux-compiler_types.h:error:expression-in-static-assertion-is-not-an-integer
|-- arc-randconfig-001-20231030
|   `-- include-linux-atomic-atomic-arch-fallback.h:error:implicit-declaration-of-function-arch_cmpxchg_local
|-- arc-randconfig-r043-20211006
|   |-- include-linux-compiler_types.h:error:call-to-__compiletime_assert_NNN-declared-with-attribute-error:BUILD_BUG_ON-failed:
|   `-- include-linux-compiler_types.h:error:call-to-__compiletime_assert_NNN-declared-with-attribute-error:BUILD_BUG_ON-failed:(PTRS_PER_PTE-sizeof(pte_t))-PAGE_SIZE
|-- arm-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- arm-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- arm64-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- arm64-buildonly-randconfig-r003-20220511
|   `-- aarch64-linux-ld:drivers-cxl-core-pci.c:(.text):undefined-reference-to-pci_print_aer
|-- csky-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- csky-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- csky-randconfig-001-20231030
|   |-- csky-linux-ld:pci.c:(.text):undefined-reference-to-pci_print_aer
|   `-- pci.c:(.text):undefined-reference-to-pci_print_aer
|-- csky-randconfig-002-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- csky-randconfig-r034-20230910
|   `-- standard-input:Error:The-instruction-is-not-recognized.
|-- i386-randconfig-141-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-display-dc-clk_mgr-dcn35-dcn35_clk_mgr.c-dcn35_clk_mgr_construct()-warn:variable-dereferenced-before-check-ctx-dc_bios-(see-line-)
|   |-- drivers-gpu-drm-amd-amdgpu-..-display-dc-clk_mgr-dcn35-dcn35_clk_mgr.c-dcn35_clk_mgr_construct()-warn:variable-dereferenced-before-check-ctx-dc_bios-integrated_info-(see-line-)
|   |-- drivers-gpu-drm-i915-display-intel_dsb.c-_intel_dsb_commit()-warn:always-true-condition-(dewake_scanline-)-(-u32max-)
|   |-- ld:drivers-cxl-core-pci.c:undefined-reference-to-pci_print_aer
|   `-- net-bluetooth-hci_event.c-hci_conn_request_evt()-warn:variable-dereferenced-before-check-hdev-(see-line-)
|-- loongarch-allmodconfig
|   |-- arch-loongarch-kvm-mmu.c:error:control-reaches-end-of-non-void-function
|   |-- arch-loongarch-kvm-mmu.c:error:implicit-declaration-of-function-mmu_invalidate_retry_hva
|   |-- arch-loongarch-kvm-mmu.c:error:invalid-use-of-undefined-type-struct-kvm_gfn_range
|   |-- arch-loongarch-kvm-mmu.c:error:struct-kvm-has-no-member-named-mmu_invalidate_seq
|   |-- arch-loongarch-kvm-mmu.c:warning:no-previous-prototype-for-kvm_age_gfn
|   |-- arch-loongarch-kvm-mmu.c:warning:no-previous-prototype-for-kvm_set_spte_gfn
|   |-- arch-loongarch-kvm-mmu.c:warning:no-previous-prototype-for-kvm_test_age_gfn
|   |-- arch-loongarch-kvm-mmu.c:warning:no-previous-prototype-for-kvm_unmap_gfn_range
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- loongarch-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- loongarch-defconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- loongarch-randconfig-002-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- loongarch-randconfig-r014-20230225
|   `-- drivers-cxl-core-pci.c:(.text):undefined-reference-to-pci_print_aer
|-- loongarch-randconfig-r032-20220926
|   `-- loongarch64-linux-ld:drivers-cxl-core-pci.c:(.text):undefined-reference-to-pci_print_aer
|-- m68k-defconfig
|   `-- kernel-bpf-task_iter.c:error:CSS_TASK_ITER_PROCS-undeclared-(first-use-in-this-function)
|-- microblaze-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- microblaze-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- openrisc-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- openrisc-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- parisc-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- parisc-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- powerpc-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- powerpc-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- powerpc-buildonly-randconfig-r006-20221105
|   |-- arch-powerpc-sysdev-udbg_memcons.c:error:no-previous-prototype-for-memcons_getc
|   |-- arch-powerpc-sysdev-udbg_memcons.c:error:no-previous-prototype-for-memcons_getc_poll
|   `-- arch-powerpc-sysdev-udbg_memcons.c:error:no-previous-prototype-for-memcons_putc
|-- powerpc-randconfig-002-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- powerpc-randconfig-003-20231016
|   `-- powerpc-linux-ld:pci.c:(.text):undefined-reference-to-pci_print_aer
|-- powerpc64-buildonly-randconfig-r001-20220430
|   |-- arch-powerpc-kernel-rtas_pci.c:error:no-previous-prototype-for-rtas_read_config
|   `-- arch-powerpc-kernel-rtas_pci.c:error:no-previous-prototype-for-rtas_write_config
|-- powerpc64-randconfig-003-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- powerpc64-randconfig-r001-20230910
|   `-- ERROR:start_text-address-is-c000000000000d00-should-be-c000000000000200
|-- riscv-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- riscv-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- riscv-randconfig-002-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- riscv-randconfig-r002-20220124
|   `-- arch-riscv-include-asm-mmio.h:(.text):undefined-reference-to-pci_print_aer
|-- riscv-randconfig-r011-20220606
|   `-- riscv64-linux-ld:pci.c:(.text):undefined-reference-to-pci_print_aer
|-- s390-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- s390-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- s390-randconfig-002-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- sh-randconfig-r022-20220318
|   `-- standard-input:Error:offset-to-unaligned-destination
|-- sh-randconfig-r023-20211018
|   |-- standard-input:Warning:overflow-in-branch-to-.L63-converted-into-longer-instruction-sequence
|   `-- standard-input:Warning:overflow-in-branch-to-.L72-converted-into-longer-instruction-sequence
|-- sh-randconfig-r023-20221113
|   |-- arch-sh-mm-cache-sh4.c:error:cached_to_uncached-undeclared-(first-use-in-this-function)
|   |-- arch-sh-mm-cache-sh4.c:error:implicit-declaration-of-function-cpu_context
|   |-- arch-sh-mm-cache-sh4.c:error:implicit-declaration-of-function-pmd_off
|   `-- arch-sh-mm-cache-sh4.c:error:implicit-declaration-of-function-pte_offset_kernel
|-- sparc-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- sparc-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- sparc-randconfig-002-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- sparc64-allmodconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- sparc64-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- sparc64-randconfig-002-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- sparc64-randconfig-r006-20230130
|   `-- include-linux-compiler_types.h:error:call-to-__compiletime_assert_NNN-declared-with-attribute-error:BUILD_BUG_ON-failed:SECTIONS_WIDTH-NODES_WIDTH-ZONES_WIDTH-ilog2(roundup_pow_of_two(NR_CPUS))
|-- sparc64-randconfig-r011-20230520
|   `-- arch-sparc-mm-init_64.c:error:variable-pagecv_flag-set-but-not-used
|-- sparc64-randconfig-r024-20220211
|   |-- arch-sparc-kernel-adi_64.c:error:no-previous-prototype-for-alloc_tag_store
|   |-- arch-sparc-kernel-adi_64.c:error:no-previous-prototype-for-find_tag_store
|   |-- arch-sparc-kernel-module.c:error:variable-strtab-set-but-not-used
|   |-- arch-sparc-kernel-pci_sun4v.c:error:no-previous-prototype-for-dma_4v_iotsb_bind
|   `-- arch-sparc-kernel-traps_64.c:error:no-previous-prototype-for-trap_init
|-- um-randconfig-r016-20230729
|   `-- bin-sh::gcc:not-found
|-- x86_64-allnoconfig
|   `-- Warning:MAINTAINERS-references-a-file-that-doesn-t-exist:Documentation-devicetree-bindings-iio-imu-bosch-bma400.yaml
|-- x86_64-allyesconfig
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-buildonly-randconfig-001-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-buildonly-randconfig-003-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-buildonly-randconfig-006-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-randconfig-001-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-randconfig-003-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-randconfig-004-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-randconfig-071-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   `-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|-- x86_64-randconfig-161-20231030
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu13-smu_v13_0_6_ppt.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   |-- drivers-gpu-drm-amd-amdgpu-..-pm-swsmu-smu14-smu_v14_0.c:warning:s-directive-output-may-be-truncated-writing-up-to-bytes-into-a-region-of-size
|   |-- drivers-gpu-drm-i915-display-intel_dsb.c-_intel_dsb_commit()-warn:always-true-condition-(dewake_scanline-)-(-u32max-)
|   |-- net-bluetooth-hci_event.c-hci_conn_request_evt()-warn:variable-dereferenced-before-check-hdev-(see-line-)
|   `-- net-ipv4-tcp_ao.c-tcp_ao_del_cmd()-error:memcmp()-key-addr-too-small-(-vs-)
|-- x86_64-randconfig-x052-20230810
|   `-- drivers-cxl-core-pci.c:undefined-reference-to-pci_print_aer
|-- xtensa-randconfig-001-20231030
|   |-- kernel-bpf-task_iter.c:error:CSS_TASK_ITER_THREADED-undeclared-(first-use-in-this-function)
|   |-- kernel-bpf-task_iter.c:error:implicit-declaration-of-function-css_task_iter_end
|   |-- kernel-bpf-task_iter.c:error:implicit-declaration-of-function-css_task_iter_next
|   |-- kernel-bpf-task_iter.c:error:implicit-declaration-of-function-css_task_iter_start
|   `-- kernel-bpf-task_iter.c:error:invalid-application-of-sizeof-to-incomplete-type-struct-css_task_iter
|-- xtensa-randconfig-r015-20221109
|   |-- include-linux-compiler.h:error:pasting-__addressable_-and-(-does-not-give-a-valid-preprocessing-token
|   |-- include-linux-export.h:error:pasting-__export_symbol_-and-(-does-not-give-a-valid-preprocessing-token
|   |-- include-linux-stddef.h:error:expected-)-before-numeric-constant
|   |-- include-linux-stddef.h:error:expected-declaration-specifiers-or-...-before-(-token
|   |-- include-linux-stddef.h:error:expected-identifier-or-(-before-void
|   `-- include-linux-stddef.h:error:pasting-)-and-does-not-give-a-valid-preprocessing-token
`-- xtensa-randconfig-r133-20230821
    |-- drivers-gpio-gpio-xtensa.c:Error:unknown-opcode-or-format-name-read_impwire
    |-- drivers-gpio-gpio-xtensa.c:Error:unknown-opcode-or-format-name-rur.expstate
    `-- drivers-gpio-gpio-xtensa.c:Error:unknown-opcode-or-format-name-wrmsk_expstate
clang_recent_errors
|-- arm64-allmodconfig
|   `-- drivers-hwtracing-coresight-coresight-etm4x-core.c:warning:result-of-comparison-of-constant-with-expression-of-type-u8-(aka-unsigned-char-)-is-always-false
|-- hexagon-randconfig-r045-20221230
|   |-- kernel-bpf-task_iter.c:error:call-to-undeclared-function-css_task_iter_end-ISO-C99-and-later-do-not-support-implicit-function-declarations
|   |-- kernel-bpf-task_iter.c:error:call-to-undeclared-function-css_task_iter_next-ISO-C99-and-later-do-not-support-implicit-function-declarations
|   |-- kernel-bpf-task_iter.c:error:call-to-undeclared-function-css_task_iter_start-ISO-C99-and-later-do-not-support-implicit-function-declarations
|   |-- kernel-bpf-task_iter.c:error:incompatible-integer-to-pointer-conversion-returning-int-from-a-function-with-result-type-struct-task_struct
|   |-- kernel-bpf-task_iter.c:error:invalid-application-of-sizeof-to-an-incomplete-type-struct-css_task_iter
|   |-- kernel-bpf-task_iter.c:error:use-of-undeclared-identifier-CSS_TASK_ITER_PROCS
|   |-- kernel-bpf-task_iter.c:error:use-of-undeclared-identifier-CSS_TASK_ITER_THREADED
|   `-- lib-objpool.c:error:call-to-undeclared-function-arch_cmpxchg_local-ISO-C99-and-later-do-not-support-implicit-function-declarations
`-- powerpc64-allmodconfig
    `-- drivers-pci-controller-dwc-pcie-rcar-gen4.c:warning:cast-to-smaller-integer-type-enum-dw_pcie_device_mode-from-const-void

elapsed time: 823m

configs tested: 148
configs skipped: 2

tested configs:
alpha                             allnoconfig   gcc  
alpha                            allyesconfig   gcc  
alpha                               defconfig   gcc  
arc                              allmodconfig   gcc  
arc                               allnoconfig   gcc  
arc                              allyesconfig   gcc  
arc                                 defconfig   gcc  
arc                   randconfig-001-20231030   gcc  
arm                              allmodconfig   gcc  
arm                               allnoconfig   gcc  
arm                              allyesconfig   gcc  
arm                       aspeed_g4_defconfig   clang
arm                                 defconfig   gcc  
arm                            dove_defconfig   clang
arm                         orion5x_defconfig   clang
arm                   randconfig-001-20231030   gcc  
arm                         wpcm450_defconfig   gcc  
arm64                            allmodconfig   gcc  
arm64                             allnoconfig   gcc  
arm64                            allyesconfig   gcc  
arm64                               defconfig   gcc  
csky                             allmodconfig   gcc  
csky                              allnoconfig   gcc  
csky                             allyesconfig   gcc  
csky                                defconfig   gcc  
i386                             allmodconfig   gcc  
i386                              allnoconfig   gcc  
i386                             allyesconfig   gcc  
i386         buildonly-randconfig-001-20231030   gcc  
i386         buildonly-randconfig-002-20231030   gcc  
i386         buildonly-randconfig-003-20231030   gcc  
i386         buildonly-randconfig-005-20231030   gcc  
i386                              debian-10.3   gcc  
i386                                defconfig   gcc  
i386                  randconfig-001-20231030   gcc  
i386                  randconfig-002-20231030   gcc  
i386                  randconfig-003-20231030   gcc  
i386                  randconfig-004-20231030   gcc  
i386                  randconfig-005-20231030   gcc  
i386                  randconfig-006-20231030   gcc  
i386                  randconfig-011-20231030   gcc  
i386                  randconfig-012-20231030   gcc  
i386                  randconfig-013-20231030   gcc  
i386                  randconfig-014-20231030   gcc  
i386                  randconfig-015-20231030   gcc  
i386                  randconfig-016-20231030   gcc  
loongarch                        allmodconfig   gcc  
loongarch                         allnoconfig   gcc  
loongarch                        allyesconfig   gcc  
loongarch                           defconfig   gcc  
loongarch             randconfig-001-20231030   gcc  
m68k                             allmodconfig   gcc  
m68k                              allnoconfig   gcc  
m68k                             allyesconfig   gcc  
m68k                                defconfig   gcc  
m68k                        mvme16x_defconfig   gcc  
microblaze                       allmodconfig   gcc  
microblaze                        allnoconfig   gcc  
microblaze                       allyesconfig   gcc  
microblaze                          defconfig   gcc  
mips                             allmodconfig   gcc  
mips                              allnoconfig   gcc  
mips                             allyesconfig   gcc  
mips                     cu1000-neo_defconfig   clang
mips                        qi_lb60_defconfig   clang
mips                          rm200_defconfig   clang
nios2                            allmodconfig   gcc  
nios2                             allnoconfig   gcc  
nios2                            allyesconfig   gcc  
nios2                               defconfig   gcc  
openrisc                         allmodconfig   gcc  
openrisc                          allnoconfig   gcc  
openrisc                         allyesconfig   gcc  
openrisc                            defconfig   gcc  
parisc                           allmodconfig   gcc  
parisc                            allnoconfig   gcc  
parisc                           allyesconfig   gcc  
parisc                              defconfig   gcc  
parisc64                            defconfig   gcc  
powerpc                          allmodconfig   gcc  
powerpc                           allnoconfig   gcc  
powerpc                          allyesconfig   gcc  
powerpc                   bluestone_defconfig   clang
powerpc                   currituck_defconfig   gcc  
powerpc                  storcenter_defconfig   gcc  
powerpc                         wii_defconfig   gcc  
riscv                            allmodconfig   gcc  
riscv                             allnoconfig   gcc  
riscv                            allyesconfig   gcc  
riscv                               defconfig   gcc  
riscv                 randconfig-001-20231030   gcc  
riscv                          rv32_defconfig   gcc  
s390                             allmodconfig   gcc  
s390                              allnoconfig   gcc  
s390                             allyesconfig   gcc  
s390                                defconfig   gcc  
s390                  randconfig-001-20231030   gcc  
sh                               allmodconfig   gcc  
sh                                allnoconfig   gcc  
sh                               allyesconfig   gcc  
sh                                  defconfig   gcc  
sh                            hp6xx_defconfig   gcc  
sh                          polaris_defconfig   gcc  
sparc                            allmodconfig   gcc  
sparc                             allnoconfig   gcc  
sparc                            allyesconfig   gcc  
sparc                               defconfig   gcc  
sparc                 randconfig-001-20231030   gcc  
sparc                       sparc64_defconfig   gcc  
sparc64                          allmodconfig   gcc  
sparc64                          allyesconfig   gcc  
sparc64                             defconfig   gcc  
um                               allmodconfig   clang
um                                allnoconfig   clang
um                               allyesconfig   clang
um                                  defconfig   gcc  
um                             i386_defconfig   gcc  
um                           x86_64_defconfig   gcc  
x86_64                            allnoconfig   gcc  
x86_64                           allyesconfig   gcc  
x86_64       buildonly-randconfig-001-20231030   gcc  
x86_64       buildonly-randconfig-002-20231030   gcc  
x86_64       buildonly-randconfig-003-20231030   gcc  
x86_64       buildonly-randconfig-004-20231030   gcc  
x86_64       buildonly-randconfig-005-20231030   gcc  
x86_64       buildonly-randconfig-006-20231030   gcc  
x86_64                              defconfig   gcc  
x86_64                randconfig-001-20231030   gcc  
x86_64                randconfig-002-20231030   gcc  
x86_64                randconfig-003-20231030   gcc  
x86_64                randconfig-004-20231030   gcc  
x86_64                randconfig-005-20231030   gcc  
x86_64                randconfig-006-20231030   gcc  
x86_64                randconfig-011-20231030   gcc  
x86_64                randconfig-012-20231030   gcc  
x86_64                randconfig-013-20231030   gcc  
x86_64                randconfig-014-20231030   gcc  
x86_64                randconfig-015-20231030   gcc  
x86_64                randconfig-016-20231030   gcc  
x86_64                randconfig-071-20231030   gcc  
x86_64                randconfig-072-20231030   gcc  
x86_64                randconfig-073-20231030   gcc  
x86_64                randconfig-074-20231030   gcc  
x86_64                randconfig-075-20231030   gcc  
x86_64                randconfig-076-20231030   gcc  
x86_64                          rhel-8.3-rust   clang
x86_64                               rhel-8.3   gcc  
xtensa                generic_kc705_defconfig   gcc  

-- 
0-DAY CI Kernel Test Service
https://github.com/intel/lkp-tests/wiki
================================================================================


################################################################################

=== Thread: [sparse PATCH resend] linearize.c: fix buffer overrun warning from fortify ===

From: Jeff Layton <jlayton () kernel ! org>
To: linux-sparse
Subject: [sparse PATCH resend] linearize.c: fix buffer overrun warning from fortify
Date: Mon, 27 Feb 2023 19:39:27 +0000
Message-ID: <20230227193927.87985-1-jlayton () kernel ! org>
--------------------
The resulting string from snprintf, won't be nearly 64 bytes, but "buf"
is only 16 bytes long here. This causes FORTIFY_SOURCE to complain when
given the right options.

Signed-off-by: Jeff Layton <jlayton@kernel.org>
---
 linearize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index d9aed61b361f..1db2d505a7d4 100644
--- a/linearize.c
+++ b/linearize.c
@@ -91,7 +91,7 @@ const char *show_label(struct basic_block *bb)
 
 	if (!bb)
 		return ".L???";
-	snprintf(buf, 64, ".L%u", bb->nr);
+	snprintf(buf, 16, ".L%u", bb->nr);
 	return buf;
 }
 
-- 
2.39.2

================================================================================


################################################################################

=== Thread: [sparse] forgotten patch ===

From: Guennadi Liakhovetski <guennadi.liakhovetski () linux ! intel ! com>
To: linux-sparse
Subject: Re: [sparse] forgotten patch
Date: Tue, 25 Jul 2023 06:20:53 +0000
Message-ID: <732ac78e-9161-1fe5-f2eb-ec6f773814cb () intel ! com>
--------------------
Hi,

Could you please pull the below patch. We've been using a private branch 
for SOF CI for 8 months now and this isn't a good place to be at: 
https://github.com/thesofproject/sof/blob/a38458dd2276fa24e37f5e60ef0a5613b03cbe00/.github/workflows/sparse-zephyr.yml#L33

Thanks
Guennadi

On Tue, 18 Apr 2023, Guennadi Liakhovetski wrote:

> Hi,
>
> Looks like this patch https://marc.info/?l=linux-sparse&m=166861736724543&w=2 
> has been forgotten? In general - where is the sparse development taking place 
> ATM - the https://git.kernel.org/pub/scm/devel/sparse/sparse.git/ repo seems 
> to not have been updated since last June?
>
> Thanks
> Guennadi
>
================================================================================


################################################################################

=== Thread: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t ===

From: kernel test robot <lkp () intel ! com>
To: linux-kernel
Subject: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Tue, 28 Feb 2023 20:39:24 +0000
Message-ID: <202303010454.jI5Jg2sT-lkp () intel ! com>
--------------------
tree:   https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master
head:   e492250d5252635b6c97d52eddf2792ec26f1ec1
commit: 74ff8864cc842be994853095dba6db48e716400a PCI: hotplug: Allow marking devices as disconnected during bind/unbind
date:   13 days ago
config: loongarch-randconfig-s042-20230226 (https://download.01.org/0day-ci/archive/20230301/202303010454.jI5Jg2sT-lkp@intel.com/config)
compiler: loongarch64-linux-gcc (GCC) 12.1.0
reproduce:
        wget https://raw.githubusercontent.com/intel/lkp-tests/master/sbin/make.cross -O ~/bin/make.cross
        chmod +x ~/bin/make.cross
        # apt-get install sparse
        # sparse version: v0.6.4-39-gce1a6720-dirty
        # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=74ff8864cc842be994853095dba6db48e716400a
        git remote add linus https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
        git fetch --no-tags linus master
        git checkout 74ff8864cc842be994853095dba6db48e716400a
        # save the config file
        mkdir build_dir && cp config build_dir/.config
        COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-12.1.0 make.cross C=1 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__' O=build_dir ARCH=loongarch olddefconfig
        COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-12.1.0 make.cross C=1 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__' O=build_dir ARCH=loongarch SHELL=/bin/bash drivers/

If you fix the issue, kindly add following tag where applicable
| Reported-by: kernel test robot <lkp@intel.com>
| Link: https://lore.kernel.org/oe-kbuild-all/202303010454.jI5Jg2sT-lkp@intel.com/

sparse warnings: (new ones prefixed by >>)
   drivers/pci/pcie/err.c: note: in included file:
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t

vim +325 drivers/pci/pcie/../pci.h

   306	
   307	/**
   308	 * pci_dev_set_io_state - Set the new error state if possible.
   309	 *
   310	 * @dev: PCI device to set new error_state
   311	 * @new: the state we want dev to be in
   312	 *
   313	 * If the device is experiencing perm_failure, it has to remain in that state.
   314	 * Any other transition is allowed.
   315	 *
   316	 * Returns true if state has been changed to the requested state.
   317	 */
   318	static inline bool pci_dev_set_io_state(struct pci_dev *dev,
   319						pci_channel_state_t new)
   320	{
   321		pci_channel_state_t old;
   322	
   323		switch (new) {
   324		case pci_channel_io_perm_failure:
 > 325			xchg(&dev->error_state, pci_channel_io_perm_failure);
   326			return true;
   327		case pci_channel_io_frozen:
   328			old = cmpxchg(&dev->error_state, pci_channel_io_normal,
   329				      pci_channel_io_frozen);
   330			return old != pci_channel_io_perm_failure;
   331		case pci_channel_io_normal:
   332			old = cmpxchg(&dev->error_state, pci_channel_io_frozen,
   333				      pci_channel_io_normal);
   334			return old != pci_channel_io_perm_failure;
   335		default:
   336			return false;
   337		}
   338	}
   339	

-- 
0-DAY CI Kernel Test Service
https://github.com/intel/lkp-tests
================================================================================

From: Lukas Wunner <lukas () wunner ! de>
To: linux-kernel
Subject: Re: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Tue, 28 Feb 2023 21:33:25 +0000
Message-ID: <20230228213325.GA21769 () wunner ! de>
--------------------
Hi Dan,

0-day is reporting sparse warnings introduced by commit 74ff8864cc84
("PCI: hotplug: Allow marking devices as disconnected during
bind/unbind"), which landed in Linus' tree this week.

The warnings are caused by invocations of xchg() and cmpxchg()
on an enum type ("cast from restricted pci_channel_state_t").

It seems they are only reported for architectures whose arch_xchg()
and arch_cmpxchg() macros cast the argument to an unsigned long.
Archictures such as x86 don't do that, but a number of others do.
The 0-day report, reproduced below in full, is for loongarch.

I'm wondering why the cast is necessary at all.  Digging in the
git history, I noticed that it has existed at least on arm since
forever.  I suspect that its use on newer arches such as loongarch
may be due to cargo-culting.

Please advise whether these sparse warnings are false positives which
can be ignored and if they aren't, how to resolve them.  If you happen
to know the rationale for the cast, I'd be grateful if you could shed
some light on it.  Thanks a lot!


On Wed, Mar 01, 2023 at 04:39:24AM +0800, kernel test robot wrote:
> tree:   https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master
> head:   e492250d5252635b6c97d52eddf2792ec26f1ec1
> commit: 74ff8864cc842be994853095dba6db48e716400a PCI: hotplug: Allow marking devices as disconnected during bind/unbind
> date:   13 days ago
> config: loongarch-randconfig-s042-20230226 (https://download.01.org/0day-ci/archive/20230301/202303010454.jI5Jg2sT-lkp@intel.com/config)
> compiler: loongarch64-linux-gcc (GCC) 12.1.0
> reproduce:
>         wget https://raw.githubusercontent.com/intel/lkp-tests/master/sbin/make.cross -O ~/bin/make.cross
>         chmod +x ~/bin/make.cross
>         # apt-get install sparse
>         # sparse version: v0.6.4-39-gce1a6720-dirty
>         # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=74ff8864cc842be994853095dba6db48e716400a
>         git remote add linus https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
>         git fetch --no-tags linus master
>         git checkout 74ff8864cc842be994853095dba6db48e716400a
>         # save the config file
>         mkdir build_dir && cp config build_dir/.config
>         COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-12.1.0 make.cross C=1 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__' O=build_dir ARCH=loongarch olddefconfig
>         COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-12.1.0 make.cross C=1 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__' O=build_dir ARCH=loongarch SHELL=/bin/bash drivers/
> 
> If you fix the issue, kindly add following tag where applicable
> | Reported-by: kernel test robot <lkp@intel.com>
> | Link: https://lore.kernel.org/oe-kbuild-all/202303010454.jI5Jg2sT-lkp@intel.com/
> 
> sparse warnings: (new ones prefixed by >>)
>    drivers/pci/pcie/err.c: note: in included file:
> >> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
> >> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t
> >> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
>    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t
> 
> vim +325 drivers/pci/pcie/../pci.h
> 
>    306	
>    307	/**
>    308	 * pci_dev_set_io_state - Set the new error state if possible.
>    309	 *
>    310	 * @dev: PCI device to set new error_state
>    311	 * @new: the state we want dev to be in
>    312	 *
>    313	 * If the device is experiencing perm_failure, it has to remain in that state.
>    314	 * Any other transition is allowed.
>    315	 *
>    316	 * Returns true if state has been changed to the requested state.
>    317	 */
>    318	static inline bool pci_dev_set_io_state(struct pci_dev *dev,
>    319						pci_channel_state_t new)
>    320	{
>    321		pci_channel_state_t old;
>    322	
>    323		switch (new) {
>    324		case pci_channel_io_perm_failure:
>  > 325			xchg(&dev->error_state, pci_channel_io_perm_failure);
>    326			return true;
>    327		case pci_channel_io_frozen:
>    328			old = cmpxchg(&dev->error_state, pci_channel_io_normal,
>    329				      pci_channel_io_frozen);
>    330			return old != pci_channel_io_perm_failure;
>    331		case pci_channel_io_normal:
>    332			old = cmpxchg(&dev->error_state, pci_channel_io_frozen,
>    333				      pci_channel_io_normal);
>    334			return old != pci_channel_io_perm_failure;
>    335		default:
>    336			return false;
>    337		}
>    338	}
>    339	
> 
> -- 
> 0-DAY CI Kernel Test Service
> https://github.com/intel/lkp-tests
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-kernel
Subject: Re: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Wed, 01 Mar 2023 04:51:25 +0000
Message-ID: <Y/7ZzYyisv1ylrho () kadam>
--------------------
On Wed, Mar 01, 2023 at 07:44:39AM +0300, Dan Carpenter wrote:
> > It seems they are only reported for architectures whose arch_xchg()
> > and arch_cmpxchg() macros cast the argument to an unsigned long.
> > Archictures such as x86 don't do that, but a number of others do.
> > The 0-day report, reproduced below in full, is for loongarch.
> > 
> > I'm wondering why the cast is necessary at all.  Digging in the
> > git history, I noticed that it has existed at least on arm since
> > forever.  I suspect that its use on newer arches such as loongarch
> > may be due to cargo-culting.
> > 
> 
> Speaking as an absolutely newbie and ignoramous, I can't see any point
> to the cast in arch_xchg().  But I am also surprised that silences the
> warning.  I would have thought that removing the cast would change the
> warning from "warning: cast from restricted my_type_t" to
> "warning: incorrect type in argument 1 (different base types)".

Your other option would be to add a __force to the cast.  I don't know
if this is a good option.  I guess first figure out if the __bit_wise
is really required.

regards,
dan carpenter

diff --git a/arch/arm64/include/asm/cmpxchg.h b/arch/arm64/include/asm/cmpxchg.h
index 497acf134d99..387c6af01941 100644
--- a/arch/arm64/include/asm/cmpxchg.h
+++ b/arch/arm64/include/asm/cmpxchg.h
@@ -93,7 +93,7 @@ __XCHG_GEN(_mb)
 ({									\
 	__typeof__(*(ptr)) __ret;					\
 	__ret = (__typeof__(*(ptr)))					\
-		__xchg##sfx((unsigned long)(x), (ptr), sizeof(*(ptr))); \
+		__xchg##sfx((__force unsigned long)(x), (ptr), sizeof(*(ptr))); \
 	__ret;								\
 })
 
================================================================================

From: kernel test robot <lkp () intel ! com>
To: linux-kernel
Subject: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Thu, 30 Nov 2023 19:39:35 +0000
Message-ID: <202312010320.jjetWPe9-lkp () intel ! com>
--------------------
tree:   https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master
head:   3b47bc037bd44f142ac09848e8d3ecccc726be99
commit: 74ff8864cc842be994853095dba6db48e716400a PCI: hotplug: Allow marking devices as disconnected during bind/unbind
date:   10 months ago
config: alpha-randconfig-r034-20230903 (https://download.01.org/0day-ci/archive/20231201/202312010320.jjetWPe9-lkp@intel.com/config)
compiler: alpha-linux-gcc (GCC) 12.3.0
reproduce: (https://download.01.org/0day-ci/archive/20231201/202312010320.jjetWPe9-lkp@intel.com/reproduce)

If you fix the issue in a separate patch/commit (i.e. not just a new version of
the same patch/commit), kindly add following tags
| Reported-by: kernel test robot <lkp@intel.com>
| Closes: https://lore.kernel.org/oe-kbuild-all/202312010320.jjetWPe9-lkp@intel.com/

sparse warnings: (new ones prefixed by >>)
   drivers/pci/pcie/err.c: note: in included file:
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t

vim +325 drivers/pci/pcie/../pci.h

   306	
   307	/**
   308	 * pci_dev_set_io_state - Set the new error state if possible.
   309	 *
   310	 * @dev: PCI device to set new error_state
   311	 * @new: the state we want dev to be in
   312	 *
   313	 * If the device is experiencing perm_failure, it has to remain in that state.
   314	 * Any other transition is allowed.
   315	 *
   316	 * Returns true if state has been changed to the requested state.
   317	 */
   318	static inline bool pci_dev_set_io_state(struct pci_dev *dev,
   319						pci_channel_state_t new)
   320	{
   321		pci_channel_state_t old;
   322	
   323		switch (new) {
   324		case pci_channel_io_perm_failure:
 > 325			xchg(&dev->error_state, pci_channel_io_perm_failure);
   326			return true;
   327		case pci_channel_io_frozen:
   328			old = cmpxchg(&dev->error_state, pci_channel_io_normal,
   329				      pci_channel_io_frozen);
   330			return old != pci_channel_io_perm_failure;
   331		case pci_channel_io_normal:
   332			old = cmpxchg(&dev->error_state, pci_channel_io_frozen,
   333				      pci_channel_io_normal);
   334			return old != pci_channel_io_perm_failure;
   335		default:
   336			return false;
   337		}
   338	}
   339	

-- 
0-DAY CI Kernel Test Service
https://github.com/intel/lkp-tests/wiki
================================================================================

From: Lukas Wunner <lukas () wunner ! de>
To: linux-sparse
Subject: Re: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Sun, 03 Dec 2023 16:59:32 +0000
Message-ID: <20231203165932.GA6480 () wunner ! de>
--------------------
Hi Dan,

0-day has sent out 5 more e-mails about this sparse warning in the last
2 days alone.  That prompted me to take a closer look...


On Wed, Mar 01, 2023 at 07:44:39AM +0300, Dan Carpenter wrote:
> On Tue, Feb 28, 2023 at 10:33:25PM +0100, Lukas Wunner wrote:
> I do smatch, not sparse.  Sparse maintainers are on
> linux-sparse@vger.kernel.org.

Right, sorry for the confusion.  Adding linux-sparse and Luc to cc.
Quoting previous conversation for context, my findings are further below:


> > 0-day is reporting sparse warnings introduced by commit 74ff8864cc84
> > ("PCI: hotplug: Allow marking devices as disconnected during
> > bind/unbind"), which landed in Linus' tree this week.
> > 
> > The warnings are caused by invocations of xchg() and cmpxchg()
> > on an enum type ("cast from restricted pci_channel_state_t").
> 
> pci_channel_state_t is not an enum.  The problem is the __bit_wise.
> 
> > 
> > It seems they are only reported for architectures whose arch_xchg()
> > and arch_cmpxchg() macros cast the argument to an unsigned long.
> > Archictures such as x86 don't do that, but a number of others do.
> > The 0-day report, reproduced below in full, is for loongarch.
> > 
> > I'm wondering why the cast is necessary at all.  Digging in the
> > git history, I noticed that it has existed at least on arm since
> > forever.  I suspect that its use on newer arches such as loongarch
> > may be due to cargo-culting.
> 
> Speaking as an absolutely newbie and ignoramous, I can't see any point
> to the cast in arch_xchg().  But I am also surprised that silences the
> warning.  I would have thought that removing the cast would change the
> warning from "warning: cast from restricted my_type_t" to
> "warning: incorrect type in argument 1 (different base types)".
> 
> > Please advise whether these sparse warnings are false positives which
> > can be ignored and if they aren't, how to resolve them.  If you happen
> > to know the rationale for the cast, I'd be grateful if you could shed
> > some light on it.  Thanks a lot!
> 
> The question is more why is pci_channel_state_t declared as __bit_wise.
> __bit_wise data can only be used through accessor functions, like user
> pointers have to go through copy_from_user() and endian data has to go
> through le32_to_cpu() etc.

__bitwise is not only to ensure endian correctness.  It can be used to
define data types which are integer-based, but treated as a distinct
data type by sparse.  A pci_channel_state_t value cannot be assigned
to an integer variable of a different type, for example.

A few arches define arch_xchg() and arch_cmpxchg() as pure macros.
The sparse warning for pci_channel_state_t does not appear on those
arches.  (These are:  arc csky riscv x86)

All other arches use a mix of macros and static inlines to define
arch_xchg() and arch_cmpxchg().  The static inlines use unsigned long
as argument and return types and the macros cast the argument type to
unsigned long.

Why are the casts necessary?  Because there are callers of xchg() and
cmpxchg() which pass pointers instead of integers as arguments.
Examples include llist_del_all(), __wake_q_add(), mark_oom_victim(),
fsnotify_attach_connector_to_object().  (Note that NULL is defined as
"(void *)0".)

When using xchg() or cmpxchg() with __bitwise arguments (as is done
by commit 74ff8864cc84 in pci_dev_set_io_state()), the arches which
define arch_xchg() and arch_cmpxchg() with static inlines see sparse
warnings because the __bitwise arguments are cast to unsigned long.
Those arches are:  alpha arm arm64 hexagon loongarch m68k mips openrisc
parisc powerpc s390 sh sparc xtensa

Indeed adding __force to the cast, as you suggest, should avoid the
issue.  sparse cannot parse the inline assembler, so it does not
understand that arch_xchg() and arch_cmpxchg() internally perform a
comparison and/or assignment.  By adding __force, we therefore do not
lose any validation coverage.

A better approach might be to teach sparse that arch_xchg() and
arch_cmpxchg() internally perform a comparison and/or assignment.
Then sparse could validate the argument and return value types.

builtin.c in the sparse source code already contains functions
to handle __atomic_exchange() and __atomic_compare_exchange(),
so I think xchg() and cmpxchg() should be handled there as well.

Unfortunately the sparse source code does not feel very approachable
to me:  E.g. the builtins_common[] table wants a return type of the
function, but the return type can be either an integer or a pointer
in this case.  How do I encode this?  Some entries in the table use
NULL as return value, is that a way to tell sparse that the return
type is variable?  NULL does not seem to mean void, because there's
a separate void_ctype for that.  Documentation is nearly non-existent.

Another issue is that the last commit to the sparse repository was
made 17 months ago.  Patches submitted to linux-sparse are ignored,
e.g. this one submitted by you half a year ago:

https://lore.kernel.org/linux-sparse/ZIyt1uUYW%2FYXEluw@moroto/

It appears sparse is unmaintained, so it's unclear if it's worth
investing time to add xchg() / cmpxchg() support.  I cannot blame
the maintainer as the source code seems less than simple to understand.

Suddenly the __force solution you've proposed looks very appealing...

Thoughts?

Thanks,

Lukas

> > On Wed, Mar 01, 2023 at 04:39:24AM +0800, kernel test robot wrote:
> > > tree:   https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master
> > > head:   e492250d5252635b6c97d52eddf2792ec26f1ec1
> > > commit: 74ff8864cc842be994853095dba6db48e716400a PCI: hotplug: Allow marking devices as disconnected during bind/unbind
> > > date:   13 days ago
> > > config: loongarch-randconfig-s042-20230226 (https://download.01.org/0day-ci/archive/20230301/202303010454.jI5Jg2sT-lkp@intel.com/config)
> > > compiler: loongarch64-linux-gcc (GCC) 12.1.0
> > > reproduce:
> > >         wget https://raw.githubusercontent.com/intel/lkp-tests/master/sbin/make.cross -O ~/bin/make.cross
> > >         chmod +x ~/bin/make.cross
> > >         # apt-get install sparse
> > >         # sparse version: v0.6.4-39-gce1a6720-dirty
> > >         # https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=74ff8864cc842be994853095dba6db48e716400a
> > >         git remote add linus https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
> > >         git fetch --no-tags linus master
> > >         git checkout 74ff8864cc842be994853095dba6db48e716400a
> > >         # save the config file
> > >         mkdir build_dir && cp config build_dir/.config
> > >         COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-12.1.0 make.cross C=1 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__' O=build_dir ARCH=loongarch olddefconfig
> > >         COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-12.1.0 make.cross C=1 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__' O=build_dir ARCH=loongarch SHELL=/bin/bash drivers/
> > > 
> > > If you fix the issue, kindly add following tag where applicable
> > > | Reported-by: kernel test robot <lkp@intel.com>
> > > | Link: https://lore.kernel.org/oe-kbuild-all/202303010454.jI5Jg2sT-lkp@intel.com/
> > > 
> > > sparse warnings: (new ones prefixed by >>)
> > >    drivers/pci/pcie/err.c: note: in included file:
> > > >> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
> > > >> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t
> > > >> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
> > >    drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t
> > > 
> > > vim +325 drivers/pci/pcie/../pci.h
> > > 
> > >    306	
> > >    307	/**
> > >    308	 * pci_dev_set_io_state - Set the new error state if possible.
> > >    309	 *
> > >    310	 * @dev: PCI device to set new error_state
> > >    311	 * @new: the state we want dev to be in
> > >    312	 *
> > >    313	 * If the device is experiencing perm_failure, it has to remain in that state.
> > >    314	 * Any other transition is allowed.
> > >    315	 *
> > >    316	 * Returns true if state has been changed to the requested state.
> > >    317	 */
> > >    318	static inline bool pci_dev_set_io_state(struct pci_dev *dev,
> > >    319						pci_channel_state_t new)
> > >    320	{
> > >    321		pci_channel_state_t old;
> > >    322	
> > >    323		switch (new) {
> > >    324		case pci_channel_io_perm_failure:
> > >  > 325			xchg(&dev->error_state, pci_channel_io_perm_failure);
> > >    326			return true;
> > >    327		case pci_channel_io_frozen:
> > >    328			old = cmpxchg(&dev->error_state, pci_channel_io_normal,
> > >    329				      pci_channel_io_frozen);
> > >    330			return old != pci_channel_io_perm_failure;
> > >    331		case pci_channel_io_normal:
> > >    332			old = cmpxchg(&dev->error_state, pci_channel_io_frozen,
> > >    333				      pci_channel_io_normal);
> > >    334			return old != pci_channel_io_perm_failure;
> > >    335		default:
> > >    336			return false;
> > >    337		}
> > >    338	}
> > >    339	
> > > 
> > > -- 
> > > 0-DAY CI Kernel Test Service
> > > https://github.com/intel/lkp-tests

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-kernel
Subject: Re: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Mon, 04 Dec 2023 14:09:32 +0000
Message-ID: <ilupya2l2yaseiokhgal65alkzbubylgz3nkdabqipi3xhbzxi () dkbofpqmuwdn>
--------------------
On Sun, Dec 03, 2023 at 05:59:32PM +0100, Lukas Wunner wrote:
> Hi Dan,
> 
> > > Please advise whether these sparse warnings are false positives which
> > > can be ignored and if they aren't, how to resolve them.  If you happen
> > > to know the rationale for the cast, I'd be grateful if you could shed
> > > some light on it.  Thanks a lot!
> > 
> > The question is more why is pci_channel_state_t declared as __bit_wise.
> > __bit_wise data can only be used through accessor functions, like user
> > pointers have to go through copy_from_user() and endian data has to go
> > through le32_to_cpu() etc.
> 
> __bitwise is not only to ensure endian correctness.  It can be used to
> define data types which are integer-based, but treated as a distinct
> data type by sparse.  A pci_channel_state_t value cannot be assigned
> to an integer variable of a different type, for example.

Correct. It was done on purpose to make a sort of 'strong' enum type,
and thus warn if pci_channel_state_t values are mixed with some other types.
 
> A few arches define arch_xchg() and arch_cmpxchg() as pure macros.
> The sparse warning for pci_channel_state_t does not appear on those
> arches.  (These are:  arc csky riscv x86)
> 
> All other arches use a mix of macros and static inlines to define
> arch_xchg() and arch_cmpxchg().  The static inlines use unsigned long
> as argument and return types and the macros cast the argument type to
> unsigned long.
>
> Why are the casts necessary?  Because there are callers of xchg() and
> cmpxchg() which pass pointers instead of integers as arguments.

Hmmm, I'm missing the precise context but it make me wonder what's happening
on 64-bit archs where enums are usually only 32-bit ...

> Examples include llist_del_all(), __wake_q_add(), mark_oom_victim(),
> fsnotify_attach_connector_to_object().  (Note that NULL is defined as
> "(void *)0".)
> 
> When using xchg() or cmpxchg() with __bitwise arguments (as is done
> by commit 74ff8864cc84 in pci_dev_set_io_state()), the arches which
> define arch_xchg() and arch_cmpxchg() with static inlines see sparse
> warnings because the __bitwise arguments are cast to unsigned long.
> Those arches are:  alpha arm arm64 hexagon loongarch m68k mips openrisc
> parisc powerpc s390 sh sparc xtensa

OK, if the underlying macros do as:
	switch (size) {
	case 1: ...
then things are ok there (but only if the size is given by a sizeof() of
the correct type (not casted to long or something).

> Indeed adding __force to the cast, as you suggest, should avoid the
> issue.  sparse cannot parse the inline assembler, so it does not
> understand that arch_xchg() and arch_cmpxchg() internally perform a
> comparison and/or assignment.  By adding __force, we therefore do not
> lose any validation coverage.

Yes, indeed, using __force inside specific accessors or any low-level macros,
like here these arch_xchg(), is OK. It's done in plenty of similar cases.

> A better approach might be to teach sparse that arch_xchg() and
> arch_cmpxchg() internally perform a comparison and/or assignment.
> Then sparse could validate the argument and return value types.
> 
> builtin.c in the sparse source code already contains functions
> to handle __atomic_exchange() and __atomic_compare_exchange(),
> so I think xchg() and cmpxchg() should be handled there as well.

I don't agree. Sparse shouldn't know about the semantics of functions
in the kernel. Sparse offers some tools (annotations like the __bitwise,
noderef or address_space attributes for __user, __iomem, ... and type
checking stricter than standard/GCC C). By using these annotations, the
kernel can define a stricter semantic, that better suits its needs,
Sparse should know nothing about this, it's not its job.

Best regards,
-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Mon, 04 Dec 2023 14:09:32 +0000
Message-ID: <ilupya2l2yaseiokhgal65alkzbubylgz3nkdabqipi3xhbzxi () dkbofpqmuwdn>
--------------------
On Sun, Dec 03, 2023 at 05:59:32PM +0100, Lukas Wunner wrote:
> Hi Dan,
> 
> > > Please advise whether these sparse warnings are false positives which
> > > can be ignored and if they aren't, how to resolve them.  If you happen
> > > to know the rationale for the cast, I'd be grateful if you could shed
> > > some light on it.  Thanks a lot!
> > 
> > The question is more why is pci_channel_state_t declared as __bit_wise.
> > __bit_wise data can only be used through accessor functions, like user
> > pointers have to go through copy_from_user() and endian data has to go
> > through le32_to_cpu() etc.
> 
> __bitwise is not only to ensure endian correctness.  It can be used to
> define data types which are integer-based, but treated as a distinct
> data type by sparse.  A pci_channel_state_t value cannot be assigned
> to an integer variable of a different type, for example.

Correct. It was done on purpose to make a sort of 'strong' enum type,
and thus warn if pci_channel_state_t values are mixed with some other types.
 
> A few arches define arch_xchg() and arch_cmpxchg() as pure macros.
> The sparse warning for pci_channel_state_t does not appear on those
> arches.  (These are:  arc csky riscv x86)
> 
> All other arches use a mix of macros and static inlines to define
> arch_xchg() and arch_cmpxchg().  The static inlines use unsigned long
> as argument and return types and the macros cast the argument type to
> unsigned long.
>
> Why are the casts necessary?  Because there are callers of xchg() and
> cmpxchg() which pass pointers instead of integers as arguments.

Hmmm, I'm missing the precise context but it make me wonder what's happening
on 64-bit archs where enums are usually only 32-bit ...

> Examples include llist_del_all(), __wake_q_add(), mark_oom_victim(),
> fsnotify_attach_connector_to_object().  (Note that NULL is defined as
> "(void *)0".)
> 
> When using xchg() or cmpxchg() with __bitwise arguments (as is done
> by commit 74ff8864cc84 in pci_dev_set_io_state()), the arches which
> define arch_xchg() and arch_cmpxchg() with static inlines see sparse
> warnings because the __bitwise arguments are cast to unsigned long.
> Those arches are:  alpha arm arm64 hexagon loongarch m68k mips openrisc
> parisc powerpc s390 sh sparc xtensa

OK, if the underlying macros do as:
	switch (size) {
	case 1: ...
then things are ok there (but only if the size is given by a sizeof() of
the correct type (not casted to long or something).

> Indeed adding __force to the cast, as you suggest, should avoid the
> issue.  sparse cannot parse the inline assembler, so it does not
> understand that arch_xchg() and arch_cmpxchg() internally perform a
> comparison and/or assignment.  By adding __force, we therefore do not
> lose any validation coverage.

Yes, indeed, using __force inside specific accessors or any low-level macros,
like here these arch_xchg(), is OK. It's done in plenty of similar cases.

> A better approach might be to teach sparse that arch_xchg() and
> arch_cmpxchg() internally perform a comparison and/or assignment.
> Then sparse could validate the argument and return value types.
> 
> builtin.c in the sparse source code already contains functions
> to handle __atomic_exchange() and __atomic_compare_exchange(),
> so I think xchg() and cmpxchg() should be handled there as well.

I don't agree. Sparse shouldn't know about the semantics of functions
in the kernel. Sparse offers some tools (annotations like the __bitwise,
noderef or address_space attributes for __user, __iomem, ... and type
checking stricter than standard/GCC C). By using these annotations, the
kernel can define a stricter semantic, that better suits its needs,
Sparse should know nothing about this, it's not its job.

Best regards,
-- Luc

================================================================================

From: kernel test robot <lkp () intel ! com>
To: linux-kernel
Subject: drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
Date: Thu, 04 Jan 2024 09:46:14 +0000
Message-ID: <202401041727.wUVRqGHn-lkp () intel ! com>
--------------------
tree:   https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master
head:   ac865f00af293d081356bec56eea90815094a60e
commit: 74ff8864cc842be994853095dba6db48e716400a PCI: hotplug: Allow marking devices as disconnected during bind/unbind
date:   11 months ago
config: mips-randconfig-r036-20230725 (https://download.01.org/0day-ci/archive/20240104/202401041727.wUVRqGHn-lkp@intel.com/config)
compiler: mipsel-linux-gcc (GCC) 12.3.0
reproduce: (https://download.01.org/0day-ci/archive/20240104/202401041727.wUVRqGHn-lkp@intel.com/reproduce)

If you fix the issue in a separate patch/commit (i.e. not just a new version of
the same patch/commit), kindly add following tags
| Reported-by: kernel test robot <lkp@intel.com>
| Closes: https://lore.kernel.org/oe-kbuild-all/202401041727.wUVRqGHn-lkp@intel.com/

sparse warnings: (new ones prefixed by >>)
   drivers/pci/pcie/err.c: note: in included file (through include/linux/mmzone.h, include/linux/gfp.h, include/linux/xarray.h, ...):
   include/linux/page-flags.h:246:46: sparse: sparse: self-comparison always evaluates to false
   drivers/pci/pcie/err.c: note: in included file:
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast from restricted pci_channel_state_t
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast from restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t
>> drivers/pci/pcie/../pci.h:325:17: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:328:23: sparse: sparse: cast to restricted pci_channel_state_t
   drivers/pci/pcie/../pci.h:332:23: sparse: sparse: cast to restricted pci_channel_state_t

vim +325 drivers/pci/pcie/../pci.h

   306	
   307	/**
   308	 * pci_dev_set_io_state - Set the new error state if possible.
   309	 *
   310	 * @dev: PCI device to set new error_state
   311	 * @new: the state we want dev to be in
   312	 *
   313	 * If the device is experiencing perm_failure, it has to remain in that state.
   314	 * Any other transition is allowed.
   315	 *
   316	 * Returns true if state has been changed to the requested state.
   317	 */
   318	static inline bool pci_dev_set_io_state(struct pci_dev *dev,
   319						pci_channel_state_t new)
   320	{
   321		pci_channel_state_t old;
   322	
   323		switch (new) {
   324		case pci_channel_io_perm_failure:
 > 325			xchg(&dev->error_state, pci_channel_io_perm_failure);
   326			return true;
   327		case pci_channel_io_frozen:
   328			old = cmpxchg(&dev->error_state, pci_channel_io_normal,
   329				      pci_channel_io_frozen);
   330			return old != pci_channel_io_perm_failure;
   331		case pci_channel_io_normal:
   332			old = cmpxchg(&dev->error_state, pci_channel_io_frozen,
   333				      pci_channel_io_normal);
   334			return old != pci_channel_io_perm_failure;
   335		default:
   336			return false;
   337		}
   338	}
   339	

-- 
0-DAY CI Kernel Test Service
https://github.com/intel/lkp-tests/wiki

================================================================================


################################################################################

=== Thread: from mariam kouame ===

From: Mariam Kouame <mariamkouame1992 () gmail ! com>
To: linux-sparse
Subject: from mariam kouame
Date: Tue, 18 Apr 2023 05:59:10 +0000
Message-ID: <CADUz=agNY633M0qMXMnAP3Ms7-3rKuWtAZGCOQZKeYpCdBxT_w () mail ! gmail ! com>
--------------------
Dear,

Please grant me permission to share a very crucial discussion with
you. I am looking forward to hearing from you at your earliest
convenience.

Mrs. Mariam Kouame
================================================================================


################################################################################

=== Thread: from nina coulibaly ===

From: nina coulibaly <ninacoulibaly199 () gmail ! com>
To: linux-sparse
Subject: from nina coulibaly
Date: Fri, 19 May 2023 11:18:02 +0000
Message-ID: <CAM7Z2JAs+q6RsD5Hw352ZDFruUVR5ngjAamir+4ZCakNdZyceg () mail ! gmail ! com>
--------------------
Dear,

Please grant me permission to share a very crucial discussion with
you. I am looking forward to hearing from you at your earliest
convenience.

Mrs. Nina Coulibal
================================================================================


################################################################################

=== Thread: my subject ===

From: "Ms Toni" <eiji.i () isono-body ! co ! jp>
To: linux-sparse
Subject: my subject
Date: Tue, 14 Nov 2023 20:34:37 +0000
Message-ID: <20231114203450.15790.qmail () www10 ! jan ! ne ! jp>
--------------------
I'm Toni Harris and I'm looking for a partner to work with in your country. I need assistance investing funds in your country. Email me to discuss this opportunity with you. Contact email: tran24358@gmail.com
================================================================================


################################################################################

=== Thread: sparse fails to build against llvm16 ===

From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: sparse fails to build against llvm16
Date: Sat, 16 Sep 2023 15:49:31 +0000
Message-ID: <e482a4de-55f3-25bd-4938-af05ad553b7d () kleine-koenig ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 4880 and 3156)
--------------7rjyt0HJPJaHf6vVyyhztts0
Content-Type: multipart/mixed; boundary="------------fvt0RQHdDjbr0zwWBGdoNrt3";
 protected-headers="v1"
From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe@kleine-koenig.org>
To: linux-sparse@vger.kernel.org
Message-ID: <e482a4de-55f3-25bd-4938-af05ad553b7d@kleine-koenig.org>
Subject: sparse fails to build against llvm16

--------------fvt0RQHdDjbr0zwWBGdoNrt3
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: base64

SGVsbG8sDQoNCkRlYmlhbiB1cGdyYWRlZCBsbHZtIHRvIHZlcnNpb24gMTYgYW5kIHNwYXJz
ZSBmYWlscyB0byBidWlsZCBhZ2FpbnN0IA0KdGhpcyB3aXRoOg0KDQpnKysgLUwvdXNyL2xp
Yi9sbHZtLTE2L2xpYiAgLVdsLC16LHJlbHJvIC1XbCwteixub3cgLVdsLC0tYXMtbmVlZGVk
IA0Kc3BhcnNlLWxsdm0ubyBsaWJzcGFyc2UuYSAtbExMVk0tMTYgICAtbyBzcGFyc2UtbGx2
bQ0KL3Vzci9iaW4vbGQ6IHNwYXJzZS1sbHZtLm86IGluIGZ1bmN0aW9uIGBnZXRfc3ltX3Zh
bHVlJzoNCi4vLi9zcGFyc2UtbGx2bS5jOjMwNTooLnRleHQrMHg3YjIpOiB1bmRlZmluZWQg
cmVmZXJlbmNlIHRvIGBMTFZNQ29uc3RHRVAnDQovdXNyL2Jpbi9sZDogc3BhcnNlLWxsdm0u
bzogaW4gZnVuY3Rpb24gYGNhbGNfZ2VwJzoNCi4vLi9zcGFyc2UtbGx2bS5jOjQ4ODooLnRl
eHQrMHhlMzcpOiB1bmRlZmluZWQgcmVmZXJlbmNlIHRvIA0KYExMVk1CdWlsZEluQm91bmRz
R0VQJw0KL3Vzci9iaW4vbGQ6IHNwYXJzZS1sbHZtLm86IGluIGZ1bmN0aW9uIGBvdXRwdXRf
b3BfbG9hZCc6DQouLy4vc3BhcnNlLWxsdm0uYzo3MTQ6KC50ZXh0KzB4MjRhOSk6IHVuZGVm
aW5lZCByZWZlcmVuY2UgdG8gYExMVk1CdWlsZExvYWQnDQovdXNyL2Jpbi9sZDogc3BhcnNl
LWxsdm0ubzogaW4gZnVuY3Rpb24gYG91dHB1dF9vcF9jYWxsJzoNCi4vLi9zcGFyc2UtbGx2
bS5jOjgyMjooLnRleHQrMHgyNjJlKTogdW5kZWZpbmVkIHJlZmVyZW5jZSB0byBgTExWTUJ1
aWxkQ2FsbCcNCmNvbGxlY3QyOiBlcnJvcjogbGQgcmV0dXJuZWQgMSBleGl0IHN0YXR1cw0K
DQooU2VlIGh0dHBzOi8vYnVncy5kZWJpYW4ub3JnLzEwNTE4NjQgZm9yIHRoZSBjb3JyZXNw
b25kaW5nIGJ1ZyByZXBvcnQuIEEgDQpxdWljayB3b3JrYXJvdW5kIGNvdWxkIGJlIHRvIGRp
c2FibGUgbGx2bS1zdXBwb3J0IGluIHNwYXJzZSB0byBwcmV2ZW50IA0Kc3BhcnNlIGZyb20g
YmVpbmcgZHJvcHBlZCBmcm9tIERlYmlhbiB1bnN0YWJsZS4pDQoNCkFmdGVyIGEgcXVpY2sg
aW50ZXJuZXQgc2VhcmNoIEkgZGlkbid0IGZpbmQgdGhlIG9idmlvdXMgZml4IGZvciB0aGF0
LiANCkFueSBoaW50cz8NCg0KQmVzdCByZWdhcmRzDQpVd2UNCg==

--------------fvt0RQHdDjbr0zwWBGdoNrt3--

--------------7rjyt0HJPJaHf6vVyyhztts0
Content-Type: application/pgp-signature; name="OpenPGP_signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="OpenPGP_signature"

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEP4GsaTp6HlmJrf7Tj4D7WH0S/k4FAmUFzosACgkQj4D7WH0S
/k6n7Qf+KVdTBpGBphyxWlMKJl1puPKo2sFlovUt/wjUMFXps2R49yPUUi4juNlj
6+WBUu0F//wvUZ7XfQhIokVVrJNF/7imrYUJG9VqLAP/UIA/Me0qs6C3k1pCyktl
eUZHGAIozsFSFc2+LUqcUpGk82+avsQwb+8pEeZDruAUq4uaqef+hor6Fu36MY2P
y3Q0FPLLfPVSC7wf0avx1boPEg39LQwtDSEZ1+RT11rzrZHS9cuBQp48rT2itp90
RP/YBSYPPrnrjusHxXC0AHBYsg3msgD24MXgyfQNEpnvyqEUHrLQN/OdcxEURsKD
k4eZ0R6GUUPJxPf4P5PbOYa19gGXNg==
=dgSL
-----END PGP SIGNATURE-----

--------------7rjyt0HJPJaHf6vVyyhztts0--
================================================================================


################################################################################

=== Thread: sparse feature request: nocast integer types ===

From: Christoph Hellwig <hch () infradead ! org>
To: linux-sparse
Subject: sparse feature request: nocast integer types
Date: Thu, 09 Nov 2023 05:03:34 +0000
Message-ID: <ZUxoJh7NlWw+uBlt () infradead ! org>
--------------------
Hi dear spearse developers,

in a lot of kernel code we have integer types that store offsets and
length in certain units (typically 512 byte disk "sectors", file systems
block sizes, and some weird variations of the same), and we had a fair
amount of bugs beause people get confused about which ones to use.

I wonder if it is possible to add an attribute (say nocast) that works
similar to __attribute__((bitwise)) in that it disallows mixing this
type with other integer types, but unlike __attribute__((bitwise))
allows all the normal arithmetics on it?  That way we could annotate
all the normal conversion helpers with __force overrides and check
where people are otherwise mixing these types.
================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-xfs
Subject: sparse feature request: nocast integer types
Date: Thu, 09 Nov 2023 05:03:34 +0000
Message-ID: <ZUxoJh7NlWw+uBlt () infradead ! org>
--------------------
Hi dear spearse developers,

in a lot of kernel code we have integer types that store offsets and
length in certain units (typically 512 byte disk "sectors", file systems
block sizes, and some weird variations of the same), and we had a fair
amount of bugs beause people get confused about which ones to use.

I wonder if it is possible to add an attribute (say nocast) that works
similar to __attribute__((bitwise)) in that it disallows mixing this
type with other integer types, but unlike __attribute__((bitwise))
allows all the normal arithmetics on it?  That way we could annotate
all the normal conversion helpers with __force overrides and check
where people are otherwise mixing these types.
================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-sparse
Subject: Re: sparse feature request: nocast integer types
Date: Thu, 09 Nov 2023 05:30:11 +0000
Message-ID: <ZUxuY13JnQ8IIFd1 () infradead ! org>
--------------------
On Thu, Nov 09, 2023 at 06:21:05AM +0100, Luc Van Oostenryck wrote:
> Such 'nocast' attribute already exists and seems to do more or less what
> you would like:
> See Sparse docs at https://sparse.docs.kernel.org/en/latest/annotations.html
> :
> nocast <https://sparse.docs.kernel.org/en/latest/annotations.html#nocast>
> 
> This attribute is similar to bitwise but in a much weaker form. It warns
> about explicit or implicit casting to different types. However, it doesnât
> warn about the mixing with other types and it easily gets lost: you can add
> plain integers to __nocast integer types and the result will be plain
> integers.

Hmm, that's a little suboptimal.  But still a lot better than nothing.
I'll see what I can do with them.

Thanks a lot!
================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-sparse
Subject: Re: sparse feature request: nocast integer types
Date: Thu, 09 Nov 2023 05:44:54 +0000
Message-ID: <ZUxx1kvWH7dSIazw () infradead ! org>
--------------------
On Thu, Nov 09, 2023 at 06:43:30AM +0100, Luc Van Oostenryck wrote:
> >
> >> Hmm, that's a little suboptimal.  But still a lot better than nothing.
> >> I'll see what I can do with them.
> >>
> >> Thanks a lot!
> >
> > Yes, something in-between is most probably needed and be clearly specified:
> - does it need to define a new type like done for bitwise?
>   Or can it be used like a specifier/attribute
> - when a warning is required: only out-casting?
> - when __force is needed?

For my use case it'd treat it exactly like __bitwise except for also
allowing arithmetics on it.  Bonus for always allowing 0 withou explicit
__force cast just like __bitwise.

================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: sparse feature request: nocast integer types
Date: Thu, 09 Nov 2023 17:57:47 +0000
Message-ID: <CAHk-=wiq873oXRfSqaM3mZzkoJbncWyWFGyi5yxHAogciRwMBQ () mail ! gmail ! com>
--------------------
On Wed, 8 Nov 2023 at 21:45, Christoph Hellwig <hch@infradead.org> wrote:
>
> For my use case it'd treat it exactly like __bitwise except for also
> allowing arithmetics on it.  Bonus for always allowing 0 withou explicit
> __force cast just like __bitwise.

It's too long for me to really remember, but I think that was the
*intention* of the "nocast" attribute originally.

The whole "nocast" thing goes back to pretty early in sparse (first
few weeks of it, in fact), and is almost entirely undocumented.

The commit that starts parsing it doesn't actually even mention it -
it mentions the *other* attributes it also starts parsing, but not
'nocast'.

Iirc, what happened was that one of the opriginal goals was that I
really wanted to have that "warn about any implicit integer casts",
and added "nocast" quite early, before the sparse type system was even
very strong. But it ended up being almost just a placeholder.

And then later on, Al came in, and he did the much stronger 'bitwise'
thing, which was immediately useful for all the byte order handling,
and 'nocast' ended up falling by the wayside.

Anyway, I think what you ask for is what 'nocast' was always supposed
to be, but just plain isn't.

                   Linus
================================================================================

From: Dan Carpenter <dan.carpenter () linaro ! org>
To: linux-xfs
Subject: Re: sparse feature request: nocast integer types
Date: Mon, 27 Nov 2023 12:51:05 +0000
Message-ID: <3423b42d-fc11-4695-89cc-f1e2d625fa90 () suswa ! mountain>
--------------------
On Wed, Nov 08, 2023 at 09:03:34PM -0800, Christoph Hellwig wrote:
> Hi dear spearse developers,
> 
> in a lot of kernel code we have integer types that store offsets and
> length in certain units (typically 512 byte disk "sectors", file systems
> block sizes, and some weird variations of the same), and we had a fair
> amount of bugs beause people get confused about which ones to use.
> 
> I wonder if it is possible to add an attribute (say nocast) that works
> similar to __attribute__((bitwise)) in that it disallows mixing this
> type with other integer types, but unlike __attribute__((bitwise))
> allows all the normal arithmetics on it?  That way we could annotate
> all the normal conversion helpers with __force overrides and check
> where people are otherwise mixing these types.

I started writing something like this in Smatch for tying variables to
a specific unit.

https://github.com/error27/smatch/blob/master/smatch_units.c

But unfortunately, it doesn't actually work.  The problem is that once
I said x is a byte, then if you have y = x then I would store that in
the database.  If the first "x is a byte" assessment was wrong then the
misinformation gets amplified times 100 and can't be purged without
a mass delete.

The second problem is that Smatch automatically determines that a struct
foo->bar is a byte unit or whatever.  Which generally works, but
sometimes fails catastrophically.  For example, it's not true to
all the registers are used to store byte units.  But some code does
store bytes there and now Smatch thinks the everything stored in
registers is in bytes.

My plan was to go through the false positives and manually edit out
stuff like this.  The problem is that it's a lot of work and I haven't
done it.  I did a similar thing for tracking user data and that works
pretty decently these days.  So it's doable.

I tend to avoid manual annotations, but here it could be good.  Manually
annotating things would avoid the false positives (at the expense of
missing bugs).

I'd prefer an annotation that had the type of the unit built in.

Creating an annotation like that is difficult because you have to
coordinate with GCC and Clang etc.  In the mean time, I could just
create a table in smatch which has stuff like:

	{ "(struct foo)->member", &byte_units },

regards,
dan carpenter

================================================================================

From: Dan Carpenter <dan.carpenter () linaro ! org>
To: linux-sparse
Subject: Re: sparse feature request: nocast integer types
Date: Mon, 27 Nov 2023 12:51:05 +0000
Message-ID: <3423b42d-fc11-4695-89cc-f1e2d625fa90 () suswa ! mountain>
--------------------
On Wed, Nov 08, 2023 at 09:03:34PM -0800, Christoph Hellwig wrote:
> Hi dear spearse developers,
> 
> in a lot of kernel code we have integer types that store offsets and
> length in certain units (typically 512 byte disk "sectors", file systems
> block sizes, and some weird variations of the same), and we had a fair
> amount of bugs beause people get confused about which ones to use.
> 
> I wonder if it is possible to add an attribute (say nocast) that works
> similar to __attribute__((bitwise)) in that it disallows mixing this
> type with other integer types, but unlike __attribute__((bitwise))
> allows all the normal arithmetics on it?  That way we could annotate
> all the normal conversion helpers with __force overrides and check
> where people are otherwise mixing these types.

I started writing something like this in Smatch for tying variables to
a specific unit.

https://github.com/error27/smatch/blob/master/smatch_units.c

But unfortunately, it doesn't actually work.  The problem is that once
I said x is a byte, then if you have y = x then I would store that in
the database.  If the first "x is a byte" assessment was wrong then the
misinformation gets amplified times 100 and can't be purged without
a mass delete.

The second problem is that Smatch automatically determines that a struct
foo->bar is a byte unit or whatever.  Which generally works, but
sometimes fails catastrophically.  For example, it's not true to
all the registers are used to store byte units.  But some code does
store bytes there and now Smatch thinks the everything stored in
registers is in bytes.

My plan was to go through the false positives and manually edit out
stuff like this.  The problem is that it's a lot of work and I haven't
done it.  I did a similar thing for tracking user data and that works
pretty decently these days.  So it's doable.

I tend to avoid manual annotations, but here it could be good.  Manually
annotating things would avoid the false positives (at the expense of
missing bugs).

I'd prefer an annotation that had the type of the unit built in.

Creating an annotation like that is difficult because you have to
coordinate with GCC and Clang etc.  In the mean time, I could just
create a table in smatch which has stuff like:

	{ "(struct foo)->member", &byte_units },

regards,
dan carpenter

================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-xfs
Subject: Re: sparse feature request: nocast integer types
Date: Mon, 27 Nov 2023 16:05:00 +0000
Message-ID: <ZWS+LLCggp70Eav3 () infradead ! org>
--------------------
On Mon, Nov 27, 2023 at 03:51:05PM +0300, Dan Carpenter wrote:
> My plan was to go through the false positives and manually edit out
> stuff like this.  The problem is that it's a lot of work and I haven't
> done it.  I did a similar thing for tracking user data and that works
> pretty decently these days.  So it's doable.

Yes, doing it without specific annotations seems like a pain.  I did a
little prototype with the existing sparse __nocast for one xfs type that
is not very heavily used, and it actually worked pretty good.

The major painpoint is that 0 isn't treated special, but with that 
fixed the amount of churn is mangable.

The next big thing is our stupid 64-bit divison helpers (do_div & co),
which require helpers to do that case. I'm actually kinda tempted to
propose that we drop 32-bit support for xfs to get rid of that and a
lot of other ugly things because of do_div.  That is unless we can
finally agree that the libgcc division helpes might not be great but
good enough that we don't want to inflict do_div on folks unless they
want to optize that case, which would be even better.

Linus, any commens on that?

> I'd prefer an annotation that had the type of the unit built in.

Annotating the type seems really hard.  I think the sparse concept
of simply not alowing different of these types to be mixed is good
enough without needing to know the actual unit in the type system.

================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-sparse
Subject: Re: sparse feature request: nocast integer types
Date: Mon, 27 Nov 2023 16:05:00 +0000
Message-ID: <ZWS+LLCggp70Eav3 () infradead ! org>
--------------------
On Mon, Nov 27, 2023 at 03:51:05PM +0300, Dan Carpenter wrote:
> My plan was to go through the false positives and manually edit out
> stuff like this.  The problem is that it's a lot of work and I haven't
> done it.  I did a similar thing for tracking user data and that works
> pretty decently these days.  So it's doable.

Yes, doing it without specific annotations seems like a pain.  I did a
little prototype with the existing sparse __nocast for one xfs type that
is not very heavily used, and it actually worked pretty good.

The major painpoint is that 0 isn't treated special, but with that 
fixed the amount of churn is mangable.

The next big thing is our stupid 64-bit divison helpers (do_div & co),
which require helpers to do that case. I'm actually kinda tempted to
propose that we drop 32-bit support for xfs to get rid of that and a
lot of other ugly things because of do_div.  That is unless we can
finally agree that the libgcc division helpes might not be great but
good enough that we don't want to inflict do_div on folks unless they
want to optize that case, which would be even better.

Linus, any commens on that?

> I'd prefer an annotation that had the type of the unit built in.

Annotating the type seems really hard.  I think the sparse concept
of simply not alowing different of these types to be mixed is good
enough without needing to know the actual unit in the type system.

================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: sparse feature request: nocast integer types
Date: Mon, 27 Nov 2023 17:26:03 +0000
Message-ID: <CAHk-=whC6fX5U3kfG9zKxw+_G=n=Y0VJYZ-BBF7EQ1KZM2Zb2g () mail ! gmail ! com>
--------------------
On Mon, 27 Nov 2023 at 08:50, Christoph Hellwig <hch@infradead.org> wrote:
>
> Yes, doing it without specific annotations seems like a pain.  I did a
> little prototype with the existing sparse __nocast for one xfs type that
> is not very heavily used, and it actually worked pretty good.
>
> The major painpoint is that 0 isn't treated special, but with that
> fixed the amount of churn is mangable.

I would suggest trying to just treat "__bitwise" as the "nocast" type.
And note that doing a

   typedef uXX __bitwise new_integer_type;

will make a *specific* new integer type that is only compatible with
itself (so not other bitwise types).

Of course, that only works if you are then willing to just use
accessor functions when you actually want to do arithmetic on the
values. If you use a *lot* of arithmetic - as opposed to just passing
values around - it is too painful.

> The next big thing is our stupid 64-bit divison helpers (do_div & co),
> which require helpers to do that case. I'm actually kinda tempted to
> propose that we drop 32-bit support for xfs to get rid of that and a
> lot of other ugly things because of do_div.  That is unless we can
> finally agree that the libgcc division helpes might not be great but
> good enough that we don't want to inflict do_div on folks unless they
> want to optize that case, which would be even better.
>
> Linus, any commens on that?

Some architectures do that, but honestly, we've had *horrendous*
numbers of cases where people did 64x64 divisions without ever
realizing what they did. Having it cause compile failures on x86 -
even if it silently works elsewhere - means that they do get caught
fairly quickly.

Just go to lore, and search for "__divdi3". You will find *tons* of
kernel test robot reports for completely idiotic cases that then never
get to me because of this.

IOW, you may not see it in the resulting kernel, but the reason you
don't see it is *exactly* because we require that do_div() dance for
64-bit divides.

The least one I see is literally from less than a week ago, when media
code tried to do this:

        i = v / (1LL << fraction_bits);

without realizing that a signed 64-bit division is truly *horrendous* here.

So you may never see this, but it's a *constant* churn, and we really
are better for it.  It's not some historical artifact, it's a "the
kernel test robot finds stuff weekly".

                 Linus

================================================================================


################################################################################

=== Thread: sparse regex error ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: sparse regex error
Date: Wed, 20 Dec 2023 00:18:11 +0000
Message-ID: <6f853a6b-9ac3-4bfd-a968-89d43fbcce2a () ramsayjones ! plus ! com>
--------------------
Hi Luc,

Long time no hear! ;)

About 18 months ago, I updated my Linux installation and sparse started
to fail when run during my git build. The reason for the failure was,
ultimately, a change to the 'regex.h' header file as a result of the
update from one Ubuntu LTS base to the current Ubuntu LTS base.
In particular, an update to the libc6-devel package from 2.31 to 2.35
which (in part) looked like this:

.

524a525,548
> #ifndef _REGEX_NELTS
> # if (defined __STDC_VERSION__ && 199901L <= __STDC_VERSION__ \
>       && !defined __STDC_NO_VLA__)
> #  define _REGEX_NELTS(n) n
> # else
> #  define _REGEX_NELTS(n)
> # endif
> #endif
> 

.

645c681,682
<                   regmatch_t __pmatch[_Restrict_arr_],
---
>                   regmatch_t __pmatch[_Restrict_arr_
>                                       _REGEX_NELTS (__nmatch)],

.

The last hunk is the declaration of regexec(), thus:

extern int regexec (const regex_t *_Restrict_ __preg,
                    const char *_Restrict_ __String, size_t __nmatch,
                    regmatch_t __pmatch[_Restrict_arr_
                                        _REGEX_NELTS (__nmatch)],
                    int __eflags);

To fix my build, I added the following to my config.mak file on linux:

    SPARSE_FLAGS += -D__STDC_NO_VLA__

. and immediately started working on a fix to sparse! Oh wait ... :)

I did report the problem and the above workaround on the git ML [1], and
created a test in my sparse repo to demonstrate the problem, thus:

  $ git diff
  diff --git a/validation/restrict-array.c b/validation/restrict-array.c
  index 04bfdad9..86753b7d 100644
  --- a/validation/restrict-array.c
  +++ b/validation/restrict-array.c
  @@ -29,9 +29,19 @@ typedef unsigned long int size_t;
   
   extern int regexec (const regex_t *__restrict __preg,
                      const char *__restrict __string, size_t __nmatch,
  -                   regmatch_t __pmatch[__restrict_arr],
  +                   regmatch_t __pmatch[__restrict_arr __nmatch],
                      int __eflags);
   
  +static int call_regexec(const regex_t *r)
  +{
  +       char s[] = "something to search";
  +       regmatch_t pm[5];
  +
  +       if (regexec(r, s, 5, pm, 0))
  +               return 0;
  +       return 1;
  +}
  +
   /*
    * check-name: restrict array attribute
    */
  $ 

which, similarly to git, shows errors not on the declaration of the
regexec() function, but on each call site (about a dozen in git):

  $ ./sparse validation/restrict-array.c
  validation/restrict-array.c:32:56: error: undefined identifier '__nmatch'
  validation/restrict-array.c:32:56: error: bad constant expression type
  $ 

I have tried to find the time, in the last couple of days, to take a look
and find a fix for this, but I have had to admit defeat and just content
myself with noting the problem here. :(

Maybe I will find some time over the xmas break.

[1] https://lore.kernel.org/git/7498bff0-782f-8c81-5817-ed841f12dbba@ramsayjones.plus.com/

ATB,
Ramsay Jones


================================================================================

From: Luc Van Oostenryck <lucvoo () kernel ! org>
To: linux-sparse
Subject: Re: sparse regex error
Date: Wed, 20 Dec 2023 23:13:38 +0000
Message-ID: <uug4xslokvlxr6z24q52z4pt7nrtiimbzunz2gz3kpilk4kxts () 7jljsksi6baq>
--------------------
On Wed, Dec 20, 2023 at 12:18:11AM +0000, Ramsay Jones wrote:
> Hi Luc,
> 
> Long time no hear! ;)

Hi,

Yes indeed ... 
>   $ git diff
>   diff --git a/validation/restrict-array.c b/validation/restrict-array.c
>   index 04bfdad9..86753b7d 100644
>   --- a/validation/restrict-array.c
>   +++ b/validation/restrict-array.c
>   @@ -29,9 +29,19 @@ typedef unsigned long int size_t;
>    
>    extern int regexec (const regex_t *__restrict __preg,
>                       const char *__restrict __string, size_t __nmatch,
>   -                   regmatch_t __pmatch[__restrict_arr],
>   +                   regmatch_t __pmatch[__restrict_arr __nmatch],
>                       int __eflags);

...    

> which, similarly to git, shows errors not on the declaration of the
> regexec() function, but on each call site (about a dozen in git):
> 
>   $ ./sparse validation/restrict-array.c
>   validation/restrict-array.c:32:56: error: undefined identifier '__nmatch'
>   validation/restrict-array.c:32:56: error: bad constant expression type

Yes, it's because __nmatch should be in the function's prototype scope but
Sparse hasn't such a thing.

The following patch is a bit ugly but should solve the problem here above.
It's hasn't had much testing, only the testsuite.

Cheers,
-- Luc



================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: sparse regex error
Date: Thu, 21 Dec 2023 01:45:41 +0000
Message-ID: <24cb6194-d04d-4c80-bd95-4f7356667884 () ramsayjones ! plus ! com>
--------------------


On 20/12/2023 23:13, Luc Van Oostenryck wrote:
[snip] 
> The following patch is a bit ugly but should solve the problem here above.
> It's hasn't had much testing, only the testsuite.
> 
> Cheers,
> -- Luc
> 
> 
>>From 2d1feff1551a97fdfd1149f4772331c540e638c9 Mon Sep 17 00:00:00 2001
> From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> Date: Wed, 20 Dec 2023 22:00:05 +0100
> Subject: [PATCH] handle protoype scope
> 

Hi Luc,

This looks good and _much_ better than my initial attempt! ;)

I tried your patch and everything looks good on the sparse repo.
On Git, however, things didn't go quite so well, thus:

  $ make V=1 sparse >ssp-out 2>&1
  $ tail -4 ssp-out
  >add-patch.sp
  add-patch.c: note: in included file (through git-compat-util.h):
  /usr/include/regex.h:682:41: error: Variable length array is used.
  make: *** [Makefile:3234: add-patch.sp] Error 1
  $ 

I think this is caused by -Wvla, which git passes to gcc, along with
sparse (perhaps) not supporting a GCC #pragma; just after the _REGEX_NELTS
definition in the header file we find:

  #if defined __GNUC__ && 4 < __GNUC__ + (6 <= __GNUC_MINOR__)
  # pragma GCC diagnostic push
  # pragma GCC diagnostic ignored "-Wvla"
  #endif

But I haven't had time to think about this too deeply. It's nearly 2am
and I need to get some sleep - I just wanted to report this ASAP.

Thanks for the patch.

ATB,
Ramsay Jones


================================================================================

From: Junio C Hamano <junio () pobox ! com>
To: linux-sparse
Subject: Re: sparse regex error
Date: Wed, 17 Jul 2024 18:44:13 +0000
Message-ID: <xmqqzfqf270i.fsf () gitster ! g>
--------------------
Luc Van Oostenryck <lucvoo@kernel.org> writes:

>>   $ git diff
>>   diff --git a/validation/restrict-array.c b/validation/restrict-array.c
>>   index 04bfdad9..86753b7d 100644
>>   --- a/validation/restrict-array.c
>>   +++ b/validation/restrict-array.c
>>   @@ -29,9 +29,19 @@ typedef unsigned long int size_t;
>>    
>>    extern int regexec (const regex_t *__restrict __preg,
>>                       const char *__restrict __string, size_t __nmatch,
>>   -                   regmatch_t __pmatch[__restrict_arr],
>>   +                   regmatch_t __pmatch[__restrict_arr __nmatch],
>>                       int __eflags);
>
> ...    
>
>> which, similarly to git, shows errors not on the declaration of the
>> regexec() function, but on each call site (about a dozen in git):
>> 
>>   $ ./sparse validation/restrict-array.c
>>   validation/restrict-array.c:32:56: error: undefined identifier '__nmatch'
>>   validation/restrict-array.c:32:56: error: bad constant expression type
>
> Yes, it's because __nmatch should be in the function's prototype scope but
> Sparse hasn't such a thing.
>
> The following patch is a bit ugly but should solve the problem here above.
> It's hasn't had much testing, only the testsuite.

The same breakage came up recently on the Git mailing list.

  https://lore.kernel.org/git/xmqqikx42c42.fsf@gitster.g/

The patch seems to fix the problem when locally applyed to the tip
at v0.6.4-67-g3a4c5743 (of course we have to add -Wno-vla in our
Makefile when invoking sparse).

Any plan to polish it to "unugly" it and merge?

Thanks.



================================================================================


################################################################################

=== Thread: sparse: Expected ) at end of cast operator, got __seg_gs ===

From: Dan Carpenter <dan.carpenter () linaro ! org>
To: linux-sparse
Subject: Re: sparse: Expected ) at end of cast operator, got __seg_gs
Date: Fri, 01 Dec 2023 14:51:17 +0000
Message-ID: <17d4d1c1-6b27-4fab-bc94-9b2d734e7b36 () suswa ! mountain>
--------------------
I patched Smatch to just ignore it.  I think Luc is on sabatical and
it's not clear if anyone is applying patches now.

Signed-off-by: Dan Carpenter <dan.carpenter@linaro.org>
---
 parse.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/parse.c b/parse.c
index 6803976a1337..2ddc29acbd33 100644
--- a/parse.c
+++ b/parse.c
@@ -74,6 +74,7 @@ static struct token *parse_range_statement(struct token *token, struct statement
 static struct token *parse_asm_statement(struct token *token, struct statement *stmt);
 static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
 static struct token *parse_static_assert(struct token *token, struct symbol_list **unused);
+static struct token *ignore_seg_gs(struct token *token, struct symbol_list **unused);
 
 typedef struct token *attr_t(struct token *, struct symbol *,
 			     struct decl_state *);
@@ -354,6 +355,10 @@ static struct symbol_op static_assert_op = {
 	.toplevel = parse_static_assert,
 };
 
+static struct symbol_op seg_gs = {
+	.toplevel = ignore_seg_gs,
+};
+
 static struct symbol_op packed_op = {
 	.attribute = attribute_packed,
 };
@@ -521,6 +526,9 @@ static struct init_keyword {
 	N("_Float64x",		&spec_op,	.type = &float64x_ctype),
 	N("_Float128",		&spec_op,	.type = &float128_ctype),
 	N("__float128",		&spec_op,	.type = &float128_ctype),
+
+	N("__seg_gs",		&seg_gs),
+
 }, keywords[] = {
 	/* Statements */
 	N("if",			&if_op),
@@ -2130,6 +2138,11 @@ static struct token *parse_static_assert(struct token *token, struct symbol_list
 	return token;
 }
 
+static struct token *ignore_seg_gs(struct token *token, struct symbol_list **unused)
+{
+	return token->next;
+}
+
 /* Make a statement out of an expression */
 static struct statement *make_statement(struct expression *expr)
 {
-- 
2.42.0


================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse: Expected ) at end of cast operator, got __seg_gs
Date: Mon, 04 Dec 2023 13:05:25 +0000
Message-ID: <v3beizdy56kqr4jv4zhmy6slriifuqcqll2eucqykqjilxfdya () s5v5jaflavwh>
--------------------
On Fri, Dec 01, 2023 at 03:10:35PM +0100, Uros Bizjak wrote:
> > sparse warnings: (new ones prefixed by >>)
> >    kernel/bpf/percpu_freelist.c: note: in included file (through arch/x86/include/asm/preempt.h, include/linux/preempt.h, include/linux/spinlock.h, ...):
> >    arch/x86/include/asm/percpu.h:550:49: sparse: sparse: Expected ) at end of cast operator
> >    arch/x86/include/asm/percpu.h:550:49: sparse: sparse: got __seg_gs
> >    arch/x86/include/asm/percpu.h:564:33: sparse: sparse: Expected ) at end of cast operator
> >    arch/x86/include/asm/percpu.h:564:33: sparse: sparse: got __seg_gs
> 
> sparse is too strict here. The following code is perfectly legal:
> 

It's not that sparse is too strict, it's because it knows nothing about __seg_gs.

What is missing is:
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index 547ea1ff806e..9214f6d54e63 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -23,6 +23,7 @@
 # define __iomem	__attribute__((noderef, address_space(__iomem)))
 # define __percpu	__attribute__((noderef, address_space(__percpu)))
 # define __rcu		__attribute__((noderef, address_space(__rcu)))
+# define __seg_gs	__attribute__((noderef, address_space(__seg_gs)))
 static inline void __chk_user_ptr(const volatile void __user *ptr) { }
 static inline void __chk_io_ptr(const volatile void __iomem *ptr) { }
 /* context/locking */


But with this patch sparse will now complain with 'warning: dereference of noderef expression'
which are quite legit given the noderef and the way __seg_gs is used.
You have two choices quiet these:
1) If variables qualified with __seg_gs should only be dereferenced via some
   special accessor like __raw_cpu_{read,write}() the patch here above is
   correct and you need to fix the typing inside these accessors (using __force or
   casting to unsigned long like already done anyway in __my_cpu_ptr()).
   I think this is the correct solution.
2) If it's OK to dereference __seg_gs qualified variables anywhere in the code
   (I don't think we should), then the 'noderef' in the patch should be removed.

Sorry, I can't currently do any testing or so.
Best regards
 -- Luc

================================================================================

From: Uros Bizjak <ubizjak () gmail ! com>
To: linux-sparse
Subject: Re: sparse: Expected ) at end of cast operator, got __seg_gs
Date: Mon, 04 Dec 2023 13:57:53 +0000
Message-ID: <CAFULd4YMcHhkSR4P5tq3ghLQyUCkiTOKS6PQd1Bec-2NicUiwQ () mail ! gmail ! com>
--------------------
--000000000000d01b16060baf8154
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable

On Mon, Dec 4, 2023 at 2:05=E2=80=AFPM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> On Fri, Dec 01, 2023 at 03:10:35PM +0100, Uros Bizjak wrote:
> > > sparse warnings: (new ones prefixed by >>)
> > >    kernel/bpf/percpu_freelist.c: note: in included file (through arch=
/x86/include/asm/preempt.h, include/linux/preempt.h, include/linux/spinlock=
.h, ...):
> > >    arch/x86/include/asm/percpu.h:550:49: sparse: sparse: Expected ) a=
t end of cast operator
> > >    arch/x86/include/asm/percpu.h:550:49: sparse: sparse: got __seg_gs
> > >    arch/x86/include/asm/percpu.h:564:33: sparse: sparse: Expected ) a=
t end of cast operator
> > >    arch/x86/include/asm/percpu.h:564:33: sparse: sparse: got __seg_gs
> >
> > sparse is too strict here. The following code is perfectly legal:
> >
>
> It's not that sparse is too strict, it's because it knows nothing about _=
_seg_gs.
>
> What is missing is:
> diff --git a/include/linux/compiler_types.h b/include/linux/compiler_type=
s.h
> index 547ea1ff806e..9214f6d54e63 100644
> --- a/include/linux/compiler_types.h
> +++ b/include/linux/compiler_types.h
> @@ -23,6 +23,7 @@
>  # define __iomem       __attribute__((noderef, address_space(__iomem)))
>  # define __percpu      __attribute__((noderef, address_space(__percpu)))
>  # define __rcu         __attribute__((noderef, address_space(__rcu)))
> +# define __seg_gs      __attribute__((noderef, address_space(__seg_gs)))
>  static inline void __chk_user_ptr(const volatile void __user *ptr) { }
>  static inline void __chk_io_ptr(const volatile void __iomem *ptr) { }
>  /* context/locking */
>
>
> But with this patch sparse will now complain with 'warning: dereference o=
f noderef expression'
> which are quite legit given the noderef and the way __seg_gs is used.
> You have two choices quiet these:
> 1) If variables qualified with __seg_gs should only be dereferenced via s=
ome
>    special accessor like __raw_cpu_{read,write}() the patch here above is
>    correct and you need to fix the typing inside these accessors (using _=
_force or
>    casting to unsigned long like already done anyway in __my_cpu_ptr()).
>    I think this is the correct solution.
> 2) If it's OK to dereference __seg_gs qualified variables anywhere in the=
 code
>    (I don't think we should), then the 'noderef' in the patch should be r=
emoved.

__seg_gs qualified variables can be referenced anywhere in the code, e.g.:

--cut here--
__seg_gs int m;

int foo (void)
{
 return m + m;
}
--cut here--

so option 2) should be the correct option here.

These __seg_gs and __seg_fs qualifiers are specific to x86, so I'd put
the definitions in the x86 specific percpu header, as in the attached
patch. The patch solves the reported issue.

Thanks,
Uros.

--000000000000d01b16060baf8154
Content-Type: text/plain; charset="US-ASCII"; name="p.diff.txt"
Content-Disposition: attachment; filename="p.diff.txt"
Content-Transfer-Encoding: base64
Content-ID: <f_lpqz6x0k0>
X-Attachment-Id: f_lpqz6x0k0

ZGlmZiAtLWdpdCBhL2FyY2gveDg2L2luY2x1ZGUvYXNtL3BlcmNwdS5oIGIvYXJjaC94ODYvaW5j
bHVkZS9hc20vcGVyY3B1LmgKaW5kZXggMGYxMmIyMDA0Yjk0Li4zMGU4MjNmNWFiNTUgMTAwNjQ0
Ci0tLSBhL2FyY2gveDg2L2luY2x1ZGUvYXNtL3BlcmNwdS5oCisrKyBiL2FyY2gveDg2L2luY2x1
ZGUvYXNtL3BlcmNwdS5oCkBAIC05NSw2ICs5NSwxMSBAQAogCiAjZW5kaWYgLyogQ09ORklHX1NN
UCAqLwogCisjaWZkZWYgX19DSEVDS0VSX18KKyNkZWZpbmUgX19zZWdfZ3MJCV9fYXR0cmlidXRl
X18oKGFkZHJlc3Nfc3BhY2UoX19zZWdfZ3MpKSkKKyNkZWZpbmUgX19zZWdfZnMJCV9fYXR0cmli
dXRlX18oKGFkZHJlc3Nfc3BhY2UoX19zZWdfZnMpKSkKKyNlbmRpZgorCiAjZGVmaW5lIF9fbXlf
Y3B1X3R5cGUodmFyKQl0eXBlb2YodmFyKSBfX3BlcmNwdV9zZWdfb3ZlcnJpZGUKICNkZWZpbmUg
X19teV9jcHVfcHRyKHB0cikJKF9fbXlfY3B1X3R5cGUoKnB0cikgKikodWludHB0cl90KShwdHIp
CiAjZGVmaW5lIF9fbXlfY3B1X3Zhcih2YXIpCSgqX19teV9jcHVfcHRyKCZ2YXIpKQo=
--000000000000d01b16060baf8154--

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse: Expected ) at end of cast operator, got __seg_gs
Date: Mon, 04 Dec 2023 14:37:37 +0000
Message-ID: <oz64jus6uqtwj76jvc5imywhwnrur4s6vuvcg3lntpj4s7dqna () fd4pecivhf2u>
--------------------
On Mon, Dec 04, 2023 at 02:57:53PM +0100, Uros Bizjak wrote:
> On Mon, Dec 4, 2023 at 2:05â¯PM Luc Van Oostenryck <luc.vanoostenryck@gmail.com> wrote:
> 
> __seg_gs qualified variables can be referenced anywhere in the code, e.g.:
> 
> --cut here--
> __seg_gs int m;
> 
> int foo (void)
> {
>  return m + m;
> }

Yes, of course. But my point was not if they *can* be dereferenced but rather
if *in the kernel, do want or not to use 'naked' __seg_gs qualified variable*.
In other words, do we want to be warned if someone, somewhere try to
dereference such qualified variable without using the accessor function?
And I think the answer to this question should be 'yes'.

-- Luc

================================================================================

From: Uros Bizjak <ubizjak () gmail ! com>
To: linux-sparse
Subject: Re: sparse: Expected ) at end of cast operator, got __seg_gs
Date: Mon, 04 Dec 2023 14:50:20 +0000
Message-ID: <CAFULd4YJ2vC-3Yj648XRquz0rh5jUgJEw6S89JC-h8p5A4-WTg () mail ! gmail ! com>
--------------------
On Mon, Dec 4, 2023 at 3:37=E2=80=AFPM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> On Mon, Dec 04, 2023 at 02:57:53PM +0100, Uros Bizjak wrote:
> > On Mon, Dec 4, 2023 at 2:05=E2=80=AFPM Luc Van Oostenryck <luc.vanooste=
nryck@gmail.com> wrote:
> >
> > __seg_gs qualified variables can be referenced anywhere in the code, e.=
g.:
> >
> > --cut here--
> > __seg_gs int m;
> >
> > int foo (void)
> > {
> >  return m + m;
> > }
>
> Yes, of course. But my point was not if they *can* be dereferenced but ra=
ther
> if *in the kernel, do want or not to use 'naked' __seg_gs qualified varia=
ble*.
> In other words, do we want to be warned if someone, somewhere try to
> dereference such qualified variable without using the accessor function?
> And I think the answer to this question should be 'yes'.

Not really - when used as e.g.:

extern const struct pcpu_hot __seg_gs const_pcpu_hot;

we can use variable directly, e.g.:

return const_pcpu_hot.current_task;

This way, the compiler is able to significantly reduce the number of
loads from current_task, which is not achievable when the accessor is
used to dereference the structure. In the x86/percpu branch, the
number of loads from current_task were reduced from ~4700 to 3201 by
using 'naked' __seg_gs qualified variable. IOW, the benefit of using
__seg_gs is to be able to access the naked variable.

Uros.

================================================================================


################################################################################

