--- Emails for Year 2016 ---

=== Thread: =?UTF-8?B?5Lia55WM5pyA6LGq5Y2O55S15a2Q5ri45oiP5aWX6aSQ77yM5YWo572R55S1?=  =?UTF-8?B?5a2Q5ri46Im65pyA ===

From: miaoweidai <news () taipeifestival ! org>
To: linux-sparse
Subject: =?UTF-8?B?5Lia55WM5pyA6LGq5Y2O55S15a2Q5ri45oiP5aWX6aSQ77yM5YWo572R55S1?=  =?UTF-8?B?5a2Q5ri46Im65pyA
Date: Mon, 29 Aug 2016 09:44:05 +0000
Message-ID: <20160829094405.7B13A2DC8C1 () sfen1 ! ecritel ! net>
--------------------

	miaoweidai <news@taipeifestival.org> sends this message to you :
	Registration Fees
	http://www.sfen.fr/GLOBAL/Registration-Fees
	
	Comments:
	ãæ¾³é¨éæ²éå¢ãå½éè¶³çèç(FIFA)å®æ¹åä½åçï¼æä»¬æä¾è±è¶ãæç²ãå¾·ç²ãè¥¿ç²ãæ³ç²äºå¤§èèµç­ææ³¨çå£ï¼
å®ç½å¼æ·ç½åï¼http://www.834516.com/?linux-sparse@vger.kernel.orgææ³¨ç²¾å½©èµäºï¼è¥é è¾çäººçï¼
æ¥ç»ç°éè¿æ°´1.0%ï¼æä¾æå¨é¢èµååæ»çææ³¨æå¡ï¼æ¯å¨è¶è¿5000åºåç±»ä½è²èµäºï¼æ»è½ä¸ºæ¨è¥é æå¥½çèµçï¼
------------------------------------------
                    è¯»ä¹¦æ¯æå¯ä¸çå¨±ä¹ãæä¸ææ¶é´æµªè´¹äºéåºãèµåæä»»ä½ä¸ç§æ¶å£çæ¸¸æï¼èæå¯¹äºäºä¸çå¤å³ï¼ä»æ¯æç§å¿è¦ï¼ä¸å¦ä¸åã
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: =?utf-8?q?INFORMA=C3=87=C3=83O_IMPORTANTE__RE=3A_Consultoria_de_Investime?= =?utf-8?q?nto_em_sua_Loc ===

From: "Mr. DOUGLAS" <douglascontact6048 () live ! com>
To: linux-sparse
Subject: =?utf-8?q?INFORMA=C3=87=C3=83O_IMPORTANTE__RE=3A_Consultoria_de_Investime?= =?utf-8?q?nto_em_sua_Loc
Date: Sun, 28 Feb 2016 12:38:32 +0000
Message-ID: <20160228133730.167608FD61B () webmail ! cefet-rj ! br>
--------------------
Oi,

Temos planejado investir alguns fundos no seu país.

Responder se você estiver interessado.

Saudações,
Sir Henry Neville Lindley Keswick
Presidente da Jardine Matheson Holdings Ltd
https://en.wikipedia.org/wiki/Keswick_family
==================================================

Hi friend,

Our family is interested in investing funds in your locality.

More information for you interest .

Greetings,
Sir Henry Neville Lindley Keswick
Chairman of Jardine Matheson Holdings Ltd
https://en.wikipedia.org/wiki/Keswick_family
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: A Business Proposal for You ===

From: "Lev" <g_garcia () muniplibre ! gob ! pe>
To: linux-sparse
Subject: A Business Proposal for You
Date: Sat, 21 May 2016 22:22:35 +0000
Message-ID: <20160521221132.D090C18E5C93 () mail ! muniplibre ! gob ! pe>
--------------------
 I have a confidential deal for you,Please contact me now for more details.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Aw: Re: REGRESSION: implied: we have to make the false states match as well ===

From: conchur () web ! de
To: linux-sparse
Subject: Aw: Re: REGRESSION: implied: we have to make the false states match as well
Date: Sun, 20 Mar 2016 16:02:03 +0000
Message-ID: <trinity-678321ec-c898-43b9-9faa-09299b271c17-1458489723757 () 3capp-webde-bap12>
--------------------
> CHECK="smatch -p=kernel --two-passes" cgcc -c -o test.o test.c

cgcc is optional. It is enough to use following command to get the incorrect warning:

    smatch -p=kernel --two-passes test.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Charity Donation ===

From: "Jeff Skoll" <s_w9gc9x () uni-kassel ! de>
To: linux-sparse
Subject: Charity Donation
Date: Sat, 02 Jan 2016 21:12:05 +0000
Message-ID: <auto-000000438728 () mailadmin ! uni-kassel ! de>
--------------------
Hi,
My name is Jeffrey Skoll, a philanthropist and the founder of one of the largest private foundations in the world. I believe strongly in âgiving while living.â I had one idea that never changed in my mind â that you should use your wealth to help people and I have decided to secretly give USD2.498 Million to a randomly selected individual. On receipt of this email, you should count yourself as the individual. Kindly get back to me at your earliest convenience, so I know your email address is valid.

Visit the web page to know more about me: http://www.theglobeandmail.com/news/national/meet-the-canadian-billionaire-whos-giving-it-all-away/article4209888/ or you can read an article of me on Wikipedia.

Regards,
Jeffrey Skoll.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: DO YOU NEED A LOAN?? ===

From: bancoleite () sms ! goiania ! go ! gov ! br
To: linux-sparse
Subject: DO YOU NEED A LOAN??
Date: Tue, 13 Dec 2016 05:41:19 +0000
Message-ID: <20161213054256.7CD7F5F6C70 () zmail ! goiania ! go ! gov ! br>
--------------------
Are you in need of a loan? Apply for more details.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Direct Cash Loans Offer!!! ===

From: Direct cash Loans pty <noreply () mailbox ! com>
To: linux-sparse
Subject: Direct Cash Loans Offer!!!
Date: Wed, 31 Aug 2016 17:20:13 +0000
Message-ID: <169004842.30734263.1472664013379.JavaMail.root () goo ! jp>
--------------------
------=_Part_30734261_893590684.1472664013371
Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit





Good News,

Direct cash Loans is currently giving out loan at 3.5% interest rate. 

Kindly forward the following details your ID Number, Full Names, Occupation, Monthly Income, Type of loan , telephone number and email address via email to this email:  directcashloans_dept@webmail.co.za 

View attached document for more information about our special loan offer or call : +27(0)622 539 768  for more information.

Commission earners can also apply. 


Regards, 

Lydia Smith (Mrs) 

Loan Application Unit/Risk Supervisor.

------=_Part_30734261_893590684.1472664013371
Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document;
 name="Direct Cash Loan Low Rate Offer.docx"
Content-Disposition: attachment;
 filename="Direct Cash Loan Low Rate Offer.docx"
Content-Transfer-Encoding: base64

UEsDBBQABgAIAAAAIQDV27ctxAEAAEwHAAATAAgCW0NvbnRlbnRfVHlwZXNdLnhtbCCiBAIooAAC
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC0
Vctu2zAQvBfoPwi8FhKdHoqisJxDkx7bAHXRXhlyZRPhC9x1Ev99l3IspIYjpTF8ESAROzM7O1zN
Lx+9q+4ho42hFRfNTFQQdDQ2rFrxa/mt/iwqJBWMcjFAK7aA4nLx/t18uU2AFVcHbMWaKH2REvUa
vMImJgh80sXsFfFrXsmk9J1agfw4m32SOgaCQDUVDLGY/2AB2RqoblSm78ozj3yI2cguRgqRABuG
E9XXXV2hboVKyVmtiIXL+2AOSOvYdVaDiXrjmaopcClHDYjcmnfNAP2hQMvF/Ao6tXFUXT+ytp0d
KawOSK0vTZTvXHFMtt4gRf/HO2kJ/E2OCS9OFj+AFjzIZAFHVGdweCB7wqun4TRc2fuJa5vGGMaH
8eTnMXf6oQ4zGYd5w0wHZK9s2Dv0og6krTtHsna4k/QQzJmivUcek8BW9eGUHI2T8wnlyhgwNd+w
g3xOuP/b0vq660DzmpiOg8e6JKjZOfysdqzTPnMIRHzvX0Py7/Ka3CN75EkJxLsRZP88fSP0MJOU
He/Lpbp18Apv/7PtAXpSxAPc/jyb+8/Ax4QMadcxv8GM/X4s1UcyLvt/4eIvAAAA//8DAFBLAwQU
AAYACAAAACEAHpEat/MAAABOAgAACwAIAl9yZWxzLy5yZWxzIKIEAiigAAIAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIyS20oDQQyG7wXfYch9
N9sKItLZ3kihdyLrA4SZ7AF3Dsyk2r69oyC6UNte5vTny0/Wm4Ob1DunPAavYVnVoNibYEffa3ht
t4sHUFnIW5qCZw1HzrBpbm/WLzyRlKE8jDGrouKzhkEkPiJmM7CjXIXIvlS6kBxJCVOPkcwb9Yyr
ur7H9FcDmpmm2lkNaWfvQLXHWDZf1g5dNxp+Cmbv2MuJFcgHYW/ZLmIqbEnGco1qKfUsGmwwzyWd
kWKsCjbgaaLV9UT/X4uOhSwJoQmJz/N8dZwDWl4PdNmiecevOx8hWSwWfXv7Q4OzL2g+AQAA//8D
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
Y3RzLnhtbFBLBQYAAAAAEgASAJ4EAAAeuwAAAAA=
------=_Part_30734261_893590684.1472664013371--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Hello ===

From: program12 () uscombat ! info
To: linux-sparse
Subject: Hello
Date: Sun, 29 May 2016 00:45:00 +0000
Message-ID: <919103.7733.bm () smtp113 ! mail ! ne1 ! yahoo ! com>
--------------------
Hi,
I am Kristi and i saw your contact through google page of your country which impress me and i feel we can be friends to share ideals and reason together for good,if not bad then let us know more about each other and i hope there will be no problem for us to be friend with no bad intention.You can also reply me through email(cplkristibakar@outlook.com) so that i can share details about myself, i will be waiting to hear from you soon. 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: OP_PHISOURCE's phi_users ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: OP_PHISOURCE's phi_users
Date: Wed, 30 Nov 2016 21:51:02 +0000
Message-ID: <20161130215102.GA5604 () macbook ! local>
--------------------
Hi list,

struct instruction has a field, 'phi_users', used for OP_PHISOURCE
to store their users. In other words this field is used to store the
OP_PHIs instruction that use a given OP_PHISOURCE.

I'm wondering if someone would have an example where an OP_PHISOURCE
is used by more than one OP_PHI.

I've searched, not too hard but still and I didn't found any.
To be honest, I don't think it can happen and if it does I'm wondering
what would be the associated meaning.


Luc 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Question regarding anotation ===

From: Nicholas Mc Guire <der.herr () hofr ! at>
To: linux-sparse
Subject: Question regarding anotation
Date: Mon, 22 Aug 2016 17:25:50 +0000
Message-ID: <20160822172550.GA28401 () osadl ! at>
--------------------

Hi !

 A probably very basic sparse question - but I could not figure out a
 satisfying answer. while compile testing a patch for ntb_transfer.c I got

  CHECK   drivers/ntb/ntb_transport.c
drivers/ntb/ntb_transport.c:1583:43: warning: incorrect type in argument 1 (different address spaces)
drivers/ntb/ntb_transport.c:1583:43:    expected void *dst
drivers/ntb/ntb_transport.c:1583:43:    got void [noderef] <asn:2>*offset
drivers/ntb/ntb_transport.c:1583:56: warning: incorrect type in argument 2 (different address spaces)
drivers/ntb/ntb_transport.c:1583:56:    expected void const [noderef] <asn:1>*src
drivers/ntb/ntb_transport.c:1583:56:    got void *buf

 looking at the offending line;

static void ntb_memcpy_tx(struct ntb_queue_entry *entry, void __iomem *offset)
{
#ifdef ARCH_HAS_NOCACHE_UACCESS
        /*
         * Using non-temporal mov to improve performance on non-cached
         * writes, even though we aren't actually copying from user space.
         */
        __copy_from_user_inatomic_nocache(offset, entry->buf, entry->len);

 the absence of a __user in the buf argument seems intentional and the
 dst is not a kernel but __iomem address which triggers the second warning
 So the first warning seems to be a false positive here, the second one
 Im not clear about, but I guess its also a false positive. The question
 is if there is a clean way to anotate this to make sparse happy without 
 any unwanted sideffects ?

 For the first warning using  (void __user *) entry->buf  should do
 and be side-effect free, but how could the second warning be fixed ?

 sparse message is from 4.8.0-rc2 (localversion-next is -next-20160822)
 sparse version is v0.5.0-44

thx!
hofrat
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Van Oostenryck Luc <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Question regarding anotation
Date: Mon, 22 Aug 2016 20:00:26 +0000
Message-ID: <CAExDi1Sa9p1HAx=Og-yaoMSoP0kROEK0egz5Ocg-+w=WabVb6A () mail ! gmail ! com>
--------------------
Hi,

So, the original code that is now part of the #else part was:
memcpy_toio(offset, entry->buf, entry->len);

On Mon, Aug 22, 2016 at 7:25 PM, Nicholas Mc Guire <der.herr@hofr.at> wrote:
>
> Hi !
>
>  A probably very basic sparse question - but I could not figure out a
>  satisfying answer. while compile testing a patch for ntb_transfer.c I got
>
>   CHECK   drivers/ntb/ntb_transport.c
> drivers/ntb/ntb_transport.c:1583:43: warning: incorrect type in argument 1 (different address spaces)
> drivers/ntb/ntb_transport.c:1583:43:    expected void *dst
> drivers/ntb/ntb_transport.c:1583:43:    got void [noderef] <asn:2>*offset
> drivers/ntb/ntb_transport.c:1583:56: warning: incorrect type in argument 2 (different address spaces)
> drivers/ntb/ntb_transport.c:1583:56:    expected void const [noderef] <asn:1>*src
> drivers/ntb/ntb_transport.c:1583:56:    got void *buf
>
>  looking at the offending line;
>
> static void ntb_memcpy_tx(struct ntb_queue_entry *entry, void __iomem *offset)
> {
> #ifdef ARCH_HAS_NOCACHE_UACCESS
>         /*
>          * Using non-temporal mov to improve performance on non-cached
>          * writes, even though we aren't actually copying from user space.
>          */
>         __copy_from_user_inatomic_nocache(offset, entry->buf, entry->len);
>
>  the absence of a __user in the buf argument seems intentional and the
>  dst is not a kernel but __iomem address which triggers the second warning
>  So the first warning seems to be a false positive here, the second one
>  Im not clear about, but I guess its also a false positive. The question
>  is if there is a clean way to anotate this to make sparse happy without
>  any unwanted sideffects ?
>
>  For the first warning using  (void __user *) entry->buf  should do
>  and be side-effect free, but how could the second warning be fixed ?
>
>  sparse message is from 4.8.0-rc2 (localversion-next is -next-20160822)
>  sparse version is v0.5.0-44
>
> thx!
> hofrat
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Question regarding anotation
Date: Mon, 22 Aug 2016 21:02:23 +0000
Message-ID: <20160822210221.GA34545 () macbook ! home>
--------------------
On Mon, Aug 22, 2016 at 05:25:50PM +0000, Nicholas Mc Guire wrote:
> 
> Hi !
> 
>  A probably very basic sparse question - but I could not figure out a
>  satisfying answer. while compile testing a patch for ntb_transfer.c I got
> 
>   CHECK   drivers/ntb/ntb_transport.c
> drivers/ntb/ntb_transport.c:1583:43: warning: incorrect type in argument 1 (different address spaces)
> drivers/ntb/ntb_transport.c:1583:43:    expected void *dst
> drivers/ntb/ntb_transport.c:1583:43:    got void [noderef] <asn:2>*offset
> drivers/ntb/ntb_transport.c:1583:56: warning: incorrect type in argument 2 (different address spaces)
> drivers/ntb/ntb_transport.c:1583:56:    expected void const [noderef] <asn:1>*src
> drivers/ntb/ntb_transport.c:1583:56:    got void *buf
> 
>  looking at the offending line;
> 
> static void ntb_memcpy_tx(struct ntb_queue_entry *entry, void __iomem *offset)
> {
> #ifdef ARCH_HAS_NOCACHE_UACCESS
>         /*
>          * Using non-temporal mov to improve performance on non-cached
>          * writes, even though we aren't actually copying from user space.
>          */
>         __copy_from_user_inatomic_nocache(offset, entry->buf, entry->len);
> 
>  the absence of a __user in the buf argument seems intentional and the
>  dst is not a kernel but __iomem address which triggers the second warning
>  So the first warning seems to be a false positive here, the second one
>  Im not clear about, but I guess its also a false positive. The question
>  is if there is a clean way to anotate this to make sparse happy without 
>  any unwanted sideffects ?
> 
>  For the first warning using  (void __user *) entry->buf  should do
>  and be side-effect free, but how could the second warning be fixed ?

So the original code, now in the #else part was:
	memcpy_toio(offset, entry->buf, entry->len);
which is correct regarding the annotation/extended typing:
	- offset points to IO memory (annotated as void __iomem *)
	- entry->buff is normal kernel memory (no annotation needed)

I have no idea if replacing this by __copy_from_user_inatomic_nocache()
does indeed improve performance or not, but it's a complete abuse of this
function's typing and intent and sparse rightfully complains about both case.

So, I really think that these warnings don't need any fixing and that hiding
them behind a cast is not a good idea at all.
Independently of the validity of using __copy_from_user_inatomic_nocache()
here it would be much better to have something like memcpy_toio_nocache().
Doesn't something like this already exist?
Why not make something using the primitives already used by 
__copy_from_user_inatomic_nocache() (where, if really needed, using a cast
to "adjust" the types is much more justified)?


Regards,
Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Question regarding anotation
Date: Mon, 22 Aug 2016 22:01:15 +0000
Message-ID: <CA+55aFyJ7Xmfbe4MOVdq8OOq77y+iTZD9XHAPR0_K-fVOF2t=w () mail ! gmail ! com>
--------------------
On Mon, Aug 22, 2016 at 10:25 AM, Nicholas Mc Guire <der.herr@hofr.at> wrote:
>
>  A probably very basic sparse question - but I could not figure out a
>  satisfying answer. while compile testing a patch for ntb_transfer.c I got
>
>   CHECK   drivers/ntb/ntb_transport.c
> drivers/ntb/ntb_transport.c:1583:43: warning: incorrect type in argument 1 (different address spaces)
> drivers/ntb/ntb_transport.c:1583:43:    expected void *dst
> drivers/ntb/ntb_transport.c:1583:43:    got void [noderef] <asn:2>*offset
> drivers/ntb/ntb_transport.c:1583:56: warning: incorrect type in argument 2 (different address spaces)
> drivers/ntb/ntb_transport.c:1583:56:    expected void const [noderef] <asn:1>*src
> drivers/ntb/ntb_transport.c:1583:56:    got void *buf

Yes, sparse is correcy, and the ntb code is doing some really dodgy
things that may or may not actually work. In fact, they are pretty
much guaranteed to not work on some architectures.

Playing games with nontemporal stores is almost always a bug anyway. Ugly, ugly.

             Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicholas Mc Guire <der.herr () hofr ! at>
To: linux-sparse
Subject: Re: Question regarding anotation
Date: Tue, 23 Aug 2016 08:58:28 +0000
Message-ID: <20160823085828.GB30833 () osadl ! at>
--------------------
On Mon, Aug 22, 2016 at 11:02:23PM +0200, Luc Van Oostenryck wrote:
> On Mon, Aug 22, 2016 at 05:25:50PM +0000, Nicholas Mc Guire wrote:
> > 
> > Hi !
> > 
> >  A probably very basic sparse question - but I could not figure out a
> >  satisfying answer. while compile testing a patch for ntb_transfer.c I got
> > 
> >   CHECK   drivers/ntb/ntb_transport.c
> > drivers/ntb/ntb_transport.c:1583:43: warning: incorrect type in argument 1 (different address spaces)
> > drivers/ntb/ntb_transport.c:1583:43:    expected void *dst
> > drivers/ntb/ntb_transport.c:1583:43:    got void [noderef] <asn:2>*offset
> > drivers/ntb/ntb_transport.c:1583:56: warning: incorrect type in argument 2 (different address spaces)
> > drivers/ntb/ntb_transport.c:1583:56:    expected void const [noderef] <asn:1>*src
> > drivers/ntb/ntb_transport.c:1583:56:    got void *buf
> > 
> >  looking at the offending line;
> > 
> > static void ntb_memcpy_tx(struct ntb_queue_entry *entry, void __iomem *offset)
> > {
> > #ifdef ARCH_HAS_NOCACHE_UACCESS
> >         /*
> >          * Using non-temporal mov to improve performance on non-cached
> >          * writes, even though we aren't actually copying from user space.
> >          */
> >         __copy_from_user_inatomic_nocache(offset, entry->buf, entry->len);
> > 
> >  the absence of a __user in the buf argument seems intentional and the
> >  dst is not a kernel but __iomem address which triggers the second warning
> >  So the first warning seems to be a false positive here, the second one
> >  Im not clear about, but I guess its also a false positive. The question
> >  is if there is a clean way to anotate this to make sparse happy without 
> >  any unwanted sideffects ?
> > 
> >  For the first warning using  (void __user *) entry->buf  should do
> >  and be side-effect free, but how could the second warning be fixed ?
> 
> So the original code, now in the #else part was:
> 	memcpy_toio(offset, entry->buf, entry->len);
> which is correct regarding the annotation/extended typing:
> 	- offset points to IO memory (annotated as void __iomem *)

but memcpy_toio() also will discard this anotation - atleast on x86
its using (void __force *)dst to "fix" this

> 	- entry->buff is normal kernel memory (no annotation needed)
> 
> I have no idea if replacing this by __copy_from_user_inatomic_nocache()
> does indeed improve performance or not, but it's a complete abuse of this
> function's typing and intent and sparse rightfully complains about both case.
> 
> So, I really think that these warnings don't need any fixing and that hiding
> them behind a cast is not a good idea at all.
> Independently of the validity of using __copy_from_user_inatomic_nocache()
> here it would be much better to have something like memcpy_toio_nocache().
> Doesn't something like this already exist?
> Why not make something using the primitives already used by 
> __copy_from_user_inatomic_nocache() (where, if really needed, using a cast
> to "adjust" the types is much more justified)?
>
users in 4.8,0-rc2 are:

i915_gem.c:i915_gem_phys_pwrite() - correct usage
pmem.h:arch_memcpy_to_pmem() "We are copying between two kernel buffer " 
         and "fixes" it with a (void __user *) cast
i915_gem.c:fast_user_write() - "We can use the cpu mem copy function because 
         this is X86. " (using (void __force*) to make sparse happy)
qxl_ioctl.c:qxl_process_single_command() - which produces sparse warning and 
         seems to be abusing this interface as well
ntb_transport.c:ntb_memcpy_tx() - which is the case at hand

Of the 5 users 1 is using it as intended and 4 are abusing the
interface more or less or making assumptions - i915_gem.c:fast_user_write()
is atleats documented and may be ok. pmem.h is x86 specific so might also
be ok. So pmem and the second i915_gem case probably would need a x86
specific memcpy_nocache() or so... 

And the use in qxl_ioctl/ntb_transport simply seem to be wrong - atleast I
se no reason why this should be x86 only code.

Anyway thanks for you clarifications - given the abuse rate in this
interface it really was hard to make much sense of this all on my own.

thx!
hofrat
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: RE ===

From: Robert <kec.belimbing () muaraenimkab ! go ! id>
To: linux-sparse
Subject: RE: RE
Date: Sat, 19 Mar 2016 10:06:47 +0000
Message-ID: <1131389466.13178.1458382007774.JavaMail.zimbra () muaraenimkab ! go ! id>
--------------------
Please confirm receipt of my previous mail..When can i call you 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: REGRESSION: implied: we have to make the false states match as well ===

From: conchur () web ! de
To: linux-sparse
Subject: REGRESSION: implied: we have to make the false states match as well
Date: Sun, 20 Mar 2016 14:48:23 +0000
Message-ID: <trinity-31872b6a-6152-4832-aeb5-7ad863fb4a89-1458485302988 () 3capp-webde-bap48>
--------------------
Hi,

I've noticed a regression with the commit
0b78084aeb0004db657d6e2d4fa4c17ec9f2e8e5 ("implied: we have to make the
false states match as well"). Now I get multiple false positives when
compiling the kernel with 

make CHECK="smatch -p=kernel --two-passes --file-output"CC="cgcc"

    net/batman-adv/soft-interface.c:894 batadv_softif_slave_add warn: unused return: ret = batadv_hardif_enable_interface()

This would be this function which definitely uses the return

    static int batadv_softif_slave_add(struct net_device *dev,
    				   struct net_device *slave_dev)
    {
    	struct batadv_hard_iface *hard_iface;
    	int ret = -EINVAL;
    
    	hard_iface = batadv_hardif_get_by_netdev(slave_dev);
    	if (!hard_iface || hard_iface->soft_iface)
    		goto out;
    
    	ret = batadv_hardif_enable_interface(hard_iface, dev->name);
    
    out:
    	if (hard_iface)
    		batadv_hardif_put(hard_iface);
    	return ret;
    }

Or:

    net/batman-adv/bat_iv_ogm.c:1481 batadv_iv_ogm_process_per_outif warn: unused return: router_router = batadv_orig_router_get()

which would be this snippet:

    	router = batadv_orig_router_get(orig_node, if_outgoing);
    	if (router) {
    		router_router = batadv_orig_router_get(router->orig_node,
    						       if_outgoing);
    		router_ifinfo = batadv_neigh_ifinfo_get(router, if_outgoing);
    	}
    
    	if ((router_ifinfo && router_ifinfo->bat_iv.tq_avg != 0) &&
    	    (batadv_compare_eth(router->addr, ethhdr->h_source)))
    		is_from_best_next_hop = true;
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [FAIL 0/5] Static lock analysis ===

From: Daniel Wagner <daniel.wagner () bmw-carit ! de>
To: linux-sparse
Subject: [FAIL 0/5] Static lock analysis
Date: Wed, 17 Feb 2016 09:51:30 +0000
Message-ID: <1455702695-6199-1-git-send-email-daniel.wagner () bmw-carit ! de>
--------------------
Hi,

Locking can be tricky to get right and sometimes things go wrong. This
here is/was an attempt to come up with a simple static code analysis tool
which tries to point to problematic looking.

Especially figurering out if an access to variables wihtout holding
the right lock is happenin was of interest for me.

There are alot of small and bigger problems I faced and some of
them I was able to solve a lot of them not. Surprise surprise.

Anyway I learned quite a lot by doing this and maybe this epic fail
helps someone else in some way. :)

Maybe the first 3 patches might be okay to get merged.

cheers,
daniel

Daniel Wagner (5):
  parse: Add comment to struct statement
  inspect: Show context information
  linearize: Add context symbol name when showing context instructions
  parse: Add acquire, release, requires and guarded_by attributes
  test-locks: Add lock tester

 Makefile          |    3 +-
 allocate.c        |    1 +
 allocate.h        |    1 +
 ast-inspect.c     |   27 +-
 lib.c             |    2 +
 lib.h             |    7 +
 linearize.c       |    2 +-
 parse.c           |   64 ++++
 parse.h           |    2 +-
 symbol.c          |    5 +
 symbol.h          |   17 +
 test-locks.c      | 1020 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 validation/caps.c |   80 +++++
 13 files changed, 1227 insertions(+), 4 deletions(-)
 create mode 100644 test-locks.c
 create mode 100644 validation/caps.c

-- 
2.5.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [FAIL 0/5] Static lock analysis
Date: Wed, 17 Feb 2016 23:05:37 +0000
Message-ID: <CANeU7QnTedKHNQM7MS3Q2YB-y6AxGRkmmzFOT1+8PKjY=Chn_w () mail ! gmail ! com>
--------------------
On Wed, Feb 17, 2016 at 1:51 AM, Daniel Wagner
<daniel.wagner@bmw-carit.de> wrote:
>
> Maybe the first 3 patches might be okay to get merged.

Yes, the first 3 looks simple and obvious correct.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: [FAIL 0/5] Static lock analysis
Date: Wed, 17 Feb 2016 23:05:37 +0000
Message-ID: <CANeU7QnTedKHNQM7MS3Q2YB-y6AxGRkmmzFOT1+8PKjY=Chn_w () mail ! gmail ! com>
--------------------
On Wed, Feb 17, 2016 at 1:51 AM, Daniel Wagner
<daniel.wagner@bmw-carit.de> wrote:
>
> Maybe the first 3 patches might be okay to get merged.

Yes, the first 3 looks simple and obvious correct.

Chris
================================================================================


################################################################################

=== Thread: [FAIL 1/5] parse: Add comment to struct statement ===

From: Daniel Wagner <daniel.wagner () bmw-carit ! de>
To: linux-sparse
Subject: [FAIL 1/5] parse: Add comment to struct statement
Date: Wed, 17 Feb 2016 09:51:31 +0000
Message-ID: <1455702695-6199-2-git-send-email-daniel.wagner () bmw-carit ! de>
--------------------
All the other members of the union got a nice comment
what they represent. Let's fix for context as well.

Signed-off-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
---
 parse.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/parse.h b/parse.h
index 0c34ec2..195f0fd 100644
--- a/parse.h
+++ b/parse.h
@@ -51,7 +51,7 @@ struct statement {
 		struct /* declaration */ {
 			struct symbol_list *declaration;
 		};
-		struct {
+		struct /* context */ {
 			struct expression *expression;
 			struct expression *context;
 		};
-- 
2.5.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [FAIL 2/5] inspect: Show context information ===

From: Daniel Wagner <daniel.wagner () bmw-carit ! de>
To: linux-sparse
Subject: [FAIL 2/5] inspect: Show context information
Date: Wed, 17 Feb 2016 09:51:32 +0000
Message-ID: <1455702695-6199-3-git-send-email-daniel.wagner () bmw-carit ! de>
--------------------
Add the function context attributes and the context instruction
to the model.

Signed-off-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
---
 ast-inspect.c | 27 ++++++++++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/ast-inspect.c b/ast-inspect.c
index 24d4a4a..4502575 100644
--- a/ast-inspect.c
+++ b/ast-inspect.c
@@ -83,7 +83,10 @@ void inspect_statement(AstNode *node)
 			ast_append_child(node, "ret_value:", stmt->ret_value, inspect_expression);
 			ast_append_child(node, "ret_target:", stmt->ret_target, inspect_symbol);
 			break;
-
+		case STMT_CONTEXT:
+			ast_append_child(node, "expression:", stmt->expression, inspect_expression);
+			ast_append_child(node, "context:", stmt->context, inspect_expression);
+			break;
 		default:
 			break;
 	}
@@ -96,6 +99,27 @@ void inspect_statement_list(AstNode *node)
 }
 
 
+static const char *unnamed_context = "<unnamed>";
+
+static const char *context_name(struct context *context)
+{
+	if (context->context && context->context->symbol_name)
+		return show_ident(context->context->symbol_name);
+	return unnamed_context;
+}
+
+static void inspect_context(AstNode *node)
+{
+	struct context *context = node->ptr;
+	node->text = g_strdup_printf("%s %s: in %d out %d", node->text,
+				context_name(context), context->in, context->out);
+}
+
+static void inspect_context_list(AstNode *node)
+{
+	inspect_ptr_list(node, "context_list", inspect_context);
+}
+
 static const char *symbol_type_name(enum type type)
 {
 	static const char *type_name[] = {
@@ -134,6 +158,7 @@ void inspect_symbol(AstNode *node)
 		case NS_PREPROCESSOR:
 			break;
 		default:
+			ast_append_child(node, "contexts:", sym->ctype.contexts, inspect_context_list);
 			ast_append_child(node, "arguments:", sym->arguments, inspect_symbol_list);
 			ast_append_child(node, "symbol_list:", sym->symbol_list, inspect_symbol_list);
 			ast_append_child(node, "stmt:", sym->stmt, inspect_statement);
-- 
2.5.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [FAIL 3/5] linearize: Add context symbol name when showing context instructions ===

From: Daniel Wagner <daniel.wagner () bmw-carit ! de>
To: linux-sparse
Subject: [FAIL 3/5] linearize: Add context symbol name when showing context instructions
Date: Wed, 17 Feb 2016 09:51:33 +0000
Message-ID: <1455702695-6199-4-git-send-email-daniel.wagner () bmw-carit ! de>
--------------------
Signed-off-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
---
 linearize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index c6ada1e..da3a190 100644
--- a/linearize.c
+++ b/linearize.c
@@ -441,7 +441,7 @@ const char *show_instruction(struct instruction *insn)
 		break;
 
 	case OP_CONTEXT:
-		buf += sprintf(buf, "%s%d", insn->check ? "check: " : "", insn->increment);
+		buf += sprintf(buf, "%s %s%d", insn->context_expr? show_ident(insn->context_expr->symbol_name) : "",  insn->check ? "check: " : "", insn->increment);
 		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
-- 
2.5.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [FAIL 4/5] parse: Add acquire, release, requires and guarded_by attributes ===

From: Daniel Wagner <daniel.wagner () bmw-carit ! de>
To: linux-sparse
Subject: [FAIL 4/5] parse: Add acquire, release, requires and guarded_by attributes
Date: Wed, 17 Feb 2016 09:51:34 +0000
Message-ID: <1455702695-6199-5-git-send-email-daniel.wagner () bmw-carit ! de>
--------------------
The static clang and also gcc knows this attributes and they
are used to do thread safety analysis.

Signed-off-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
Link: http://clang.llvm.org/docs/ThreadSafetyAnalysis.html
---
 allocate.c |  1 +
 allocate.h |  1 +
 parse.c    | 64 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 symbol.c   |  5 +++++
 symbol.h   | 17 +++++++++++++++++
 5 files changed, 88 insertions(+)

diff --git a/allocate.c b/allocate.c
index f597caf..6506fcd 100644
--- a/allocate.c
+++ b/allocate.c
@@ -130,6 +130,7 @@ void show_allocations(struct allocator_struct *x)
 ALLOCATOR(ident, "identifiers");
 ALLOCATOR(token, "tokens");
 ALLOCATOR(context, "contexts");
+ALLOCATOR(capability, "capability");
 ALLOCATOR(symbol, "symbols");
 ALLOCATOR(expression, "expressions");
 ALLOCATOR(statement, "statements");
diff --git a/allocate.h b/allocate.h
index 9f1dc8c..ce0677d 100644
--- a/allocate.h
+++ b/allocate.h
@@ -65,6 +65,7 @@ extern void show_allocations(struct allocator_struct *);
 DECLARE_ALLOCATOR(ident);
 DECLARE_ALLOCATOR(token);
 DECLARE_ALLOCATOR(context);
+DECLARE_ALLOCATOR(capability);
 DECLARE_ALLOCATOR(symbol);
 DECLARE_ALLOCATOR(expression);
 DECLARE_ALLOCATOR(statement);
diff --git a/parse.c b/parse.c
index b43d683..aef71f1 100644
--- a/parse.c
+++ b/parse.c
@@ -80,6 +80,8 @@ typedef struct token *attr_t(struct token *, struct symbol *,
 static attr_t
 	attribute_packed, attribute_aligned, attribute_modifier,
 	attribute_address_space, attribute_context,
+	attribute_acquire, attribute_release, attribute_requires,
+	attribute_guarded_by,
 	attribute_designated_init,
 	attribute_transparent_union, ignore_attribute,
 	attribute_mode, attribute_force;
@@ -336,6 +338,22 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
+static struct symbol_op acquire_op = {
+	.attribute = attribute_acquire,
+};
+
+static struct symbol_op release_op = {
+	.attribute = attribute_release,
+};
+
+static struct symbol_op requires_op = {
+	.attribute = attribute_requires,
+};
+
+static struct symbol_op guarded_by_op = {
+	.attribute = attribute_guarded_by,
+};
+
 static struct symbol_op designated_init_op = {
 	.attribute = attribute_designated_init,
 };
@@ -476,6 +494,10 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
+	{ "acquire_capability",	NS_KEYWORD,	.op = &acquire_op },
+	{ "release_capability",	NS_KEYWORD,	.op = &release_op },
+	{ "requires_capability",	NS_KEYWORD,	.op = &requires_op },
+	{ "guarded_by", NS_KEYWORD,	.op = &guarded_by_op },
 	{ "designated_init",	NS_KEYWORD,	.op = &designated_init_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 	{ "noreturn",	NS_KEYWORD,	MOD_NORETURN,	.op = &attr_mod_op },
@@ -1197,6 +1219,48 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 	return token;
 }
 
+static const char *cap_ops[] = {
+	[CAP_ACQUIRE] = "after acquire_capability attribute",
+	[CAP_RELEASE] = "after release_capability attribute",
+	[CAP_REQUIRES] = "after requires_capability attribute",
+	[CAP_GUARDED_BY] = "after guarded_by attribute",
+};
+
+static struct token *attribute_capability(struct token *token, struct decl_state *ctx, enum cap_op op)
+{
+	struct expression *expr = NULL;
+	struct capability *cap;
+
+	token = expect(token, '(', cap_ops[op]);
+	token = conditional_expression(token, &expr);
+	cap = alloc_capability();
+	cap->op = op;
+	cap->expr = expr;
+	add_ptr_list(&ctx->ctype.capabilities, cap);
+	token = expect(token, ')', cap_ops[op]);
+	return token;
+}
+
+static struct token *attribute_acquire(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	return attribute_capability(token, ctx, CAP_ACQUIRE);
+}
+
+static struct token *attribute_release(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	return attribute_capability(token, ctx, CAP_RELEASE);
+}
+
+static struct token *attribute_requires(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	return attribute_capability(token, ctx, CAP_REQUIRES);
+}
+
+static struct token *attribute_guarded_by(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	return attribute_capability(token, ctx, CAP_GUARDED_BY);
+}
+
 static struct token *attribute_designated_init(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	if (ctx->ctype.base_type && ctx->ctype.base_type->type == SYM_STRUCT)
diff --git a/symbol.c b/symbol.c
index 0ceff62..12e23b4 100644
--- a/symbol.c
+++ b/symbol.c
@@ -73,6 +73,11 @@ struct context *alloc_context(void)
 	return __alloc_context(0);
 }
 
+struct capability *alloc_capability(void)
+{
+	return __alloc_capability(0);
+}
+
 struct symbol *alloc_symbol(struct position pos, int type)
 {
 	struct symbol *sym = __alloc_symbol(0);
diff --git a/symbol.h b/symbol.h
index ccb5dcb..bcb41b7 100644
--- a/symbol.h
+++ b/symbol.h
@@ -97,10 +97,27 @@ extern struct context *alloc_context(void);
 
 DECLARE_PTR_LIST(context_list, struct context);
 
+enum cap_op {
+	CAP_ACQUIRE,
+	CAP_RELEASE,
+	CAP_REQUIRES,
+	CAP_GUARDED_BY,
+};
+
+struct capability {
+	struct expression *expr;
+	enum cap_op op;
+};
+
+extern struct capability *alloc_capability(void);
+
+DECLARE_PTR_LIST(capability_list, struct capability);
+
 struct ctype {
 	unsigned long modifiers;
 	unsigned long alignment;
 	struct context_list *contexts;
+	struct capability_list *capabilities;
 	unsigned int as;
 	struct symbol *base_type;
 };
-- 
2.5.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [FAIL 5/5] test-locks: Add lock tester ===

From: Daniel Wagner <daniel.wagner () bmw-carit ! de>
To: linux-sparse
Subject: [FAIL 5/5] test-locks: Add lock tester
Date: Wed, 17 Feb 2016 09:51:35 +0000
Message-ID: <1455702695-6199-6-git-send-email-daniel.wagner () bmw-carit ! de>
--------------------
I was playing a bit around to see if it is possible to figure out if a
variable is accessed without holding the corresponding lock. This never
got anywhere and that's why I abandon it. In case someone wants to
use parts of it or whatever, please be my guest.

Example output:

./test-locks validation/caps.c
validation/caps.c:49:13: warning: function 'set_str' not holding 'anon'
validation/caps.c:25:13: warning: leaks lock 'anon'
  frame: ep 0x7f0af437e010 a
  frame: ep 0x7f0af437e0a0 okay1 (call        a)
  frame: ep 0x7f0af437e0d0 bad2 (call        okay1)

validation/caps.c:70:8: warning: leaks lock 'global_lock'
  frame: ep 0x7f0af437e100 wtf_lock
  frame: ep 0x7f0af437e1f0 bad4 (call        wtf_lock, global_lock)

Signed-off-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
---
 Makefile          |    3 +-
 lib.c             |    2 +
 lib.h             |    7 +
 test-locks.c      | 1020 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 validation/caps.c |   80 +++++
 5 files changed, 1111 insertions(+), 1 deletion(-)
 create mode 100644 test-locks.c
 create mode 100644 validation/caps.c

diff --git a/Makefile b/Makefile
index c7031af..db0c343 100644
--- a/Makefile
+++ b/Makefile
@@ -54,7 +54,8 @@ INCLUDEDIR=$(PREFIX)/include
 PKGCONFIGDIR=$(LIBDIR)/pkgconfig
 
 PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse \
-	 test-linearize example test-unssa test-dissect ctags
+	 test-linearize example test-unssa test-dissect ctags \
+	 test-locks
 INST_PROGRAMS=sparse cgcc
 INST_MAN1=sparse.1 cgcc.1
 
diff --git a/lib.c b/lib.c
index 8dc5bcf..7b49e2f 100644
--- a/lib.c
+++ b/lib.c
@@ -244,6 +244,7 @@ int Wvla = 1;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
+int dbg_caps = 0;
 
 int preprocess_only;
 
@@ -518,6 +519,7 @@ static char **handle_switch_W(char *arg, char **next)
 static struct warning debugs[] = {
 	{ "entry", &dbg_entry},
 	{ "dead", &dbg_dead},
+	{ "caps", &dbg_caps},
 };
 
 
diff --git a/lib.h b/lib.h
index 15b69fa..87d1948 100644
--- a/lib.h
+++ b/lib.h
@@ -130,6 +130,7 @@ extern int Wvla;
 
 extern int dbg_entry;
 extern int dbg_dead;
+extern int dbg_caps;
 
 extern int arch_m64;
 
@@ -189,6 +190,12 @@ static inline struct basic_block *first_basic_block(struct basic_block_list *hea
 {
 	return first_ptr_list((struct ptr_list *)head);
 }
+
+static inline struct basic_block *last_basic_block(struct basic_block_list *head)
+{
+	return last_ptr_list((struct ptr_list *)head);
+}
+
 static inline struct instruction *last_instruction(struct instruction_list *head)
 {
 	return last_ptr_list((struct ptr_list *)head);
diff --git a/test-locks.c b/test-locks.c
new file mode 100644
index 0000000..f311f4c
--- /dev/null
+++ b/test-locks.c
@@ -0,0 +1,1020 @@
+/*
+ * This is an miserable attempt in static code analysis. The test
+ * executes the program and maintains a current set of locks. At every
+ * function entry and exit point all the current lock set is attached
+ * to the function and the current calling stack is also added to the lock.
+ *
+ * In the second phase the check_leaking() function then looks at all
+ * locks and the calling stacks and reports all those function which
+ * have an lock in the exit lock set and no other function is calling them.
+ * Obvioysly reallity is much more complex and this simple testing
+ * will not catch a lot of wrong cases.
+ *
+ * There is also the attempt to figure out if a variable has been accessed
+ * without holding the corresponding lock.
+ *
+ * If you want to understand what is doing run it with
+ *
+ *   $ test-locks validation/caps.c -vcaps -v -v -v
+ *
+ * which print a lot of details.
+ *
+ * Copyright (C) 2016  BMW Car IT GmbH.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "flow.h"
+#include "scope.h"
+
+#define dbg_level0 (dbg_caps)
+#define dbg_level1 (dbg_caps && verbose > 0)
+#define dbg_level2 (dbg_caps && verbose > 1)
+#define dbg_level3 (dbg_caps && verbose > 2)
+
+struct frame {
+	struct instruction *insn;
+	struct entrypoint *ep;
+};
+
+ALLOCATOR(frame, "call stack");
+DECLARE_PTR_LIST(frame_list, struct frame);
+
+struct frame *alloc_frame(struct entrypoint *ep, struct instruction *insn)
+{
+	struct frame *frame = __alloc_frame(0);
+
+	frame->ep = ep;
+	frame->insn = insn;
+	return frame;
+}
+
+static inline struct frame *last_frame(struct frame_list *head)
+{
+	return last_ptr_list((struct ptr_list *)head);
+}
+
+static inline struct frame *first_frame(struct frame_list *head)
+{
+	return first_ptr_list((struct ptr_list *)head);
+}
+
+static inline struct frame *delete_last_frame(struct frame_list **head)
+{
+	return delete_ptr_list_last((struct ptr_list **)head);
+}
+
+static inline void add_frame(struct frame_list **list, struct frame *frame)
+{
+	add_ptr_list(list, frame);
+}
+
+static inline struct frame *lookup_frame(struct frame_list *list,
+					struct  entrypoint *ep)
+{
+	struct frame *c;
+
+	FOR_EACH_PTR(list, c) {
+		if (c->ep == ep)
+			return c;
+	} END_FOR_EACH_PTR(c);
+
+	return NULL;
+}
+
+static inline int frame_list_size(struct frame_list *head)
+{
+	return ptr_list_size((struct ptr_list *)head);
+}
+
+static inline int frame_cmp(struct frame *f1, struct frame *f2)
+{
+	return !(f1->ep == f2->ep && f1->insn == f2->insn);
+}
+
+static int stack_cmp(struct frame_list *s1, struct frame_list *s2)
+{
+	struct frame *f1, *f2;
+
+	PREPARE_PTR_LIST(s1, f1);
+	PREPARE_PTR_LIST(s2, f2);
+	for (;;) {
+		if (!f1 || !f2)
+			return 1;
+
+		if (frame_cmp(f1, f2))
+			return 1;
+
+		NEXT_PTR_LIST(f1);
+		NEXT_PTR_LIST(f2);
+	}
+	FINISH_PTR_LIST(f2);
+	FINISH_PTR_LIST(f1);
+
+	return 0;
+}
+
+static int stack_frame_position(struct frame_list *stack, struct entrypoint *ep)
+{
+	struct frame *f;
+	int pos = 0;
+
+	FOR_EACH_PTR(stack, f) {
+		if (f->ep == ep)
+			return pos;
+		pos++;
+	} END_FOR_EACH_PTR(f);
+
+	return -1;
+}
+
+static void copy_stack(struct frame_list *from, struct frame_list **to)
+{
+	struct frame *c;
+
+	FOR_EACH_PTR(from, c) {
+		add_frame(to, alloc_frame(c->ep, c->insn));
+	} END_FOR_EACH_PTR(c);
+}
+
+/* Better naming wouldn't hurt. we could also do a frame_list** in
+ * struct lock but that is really hard to read. Let's wrap it here and
+ * use it as 2 dimensional list.
+ */
+struct stack {
+	struct frame_list *stack;
+};
+ALLOCATOR(stack, "stack list");
+DECLARE_PTR_LIST(stack_list, struct stack);
+
+static inline void add_stack(struct stack_list **list, struct stack *stack)
+{
+	add_ptr_list(list, stack);
+}
+
+struct lock {
+	unsigned int ref;
+	struct symbol *sym;
+	struct capability_list *caps;
+	struct stack_list *stacks;
+};
+
+ALLOCATOR(lock, "lock list");
+DECLARE_PTR_LIST(lock_list, struct lock);
+
+static struct lock *alloc_lock(struct symbol *sym)
+{
+	struct lock *lock = __alloc_lock(0);
+
+	lock->ref = 1;
+	lock->sym = sym;
+
+	return lock;
+};
+
+static inline void ref_lock(struct lock *lock)
+{
+	lock->ref++;
+}
+
+static inline unsigned int unref_lock(struct lock *lock)
+{
+	return --lock->ref;
+}
+
+static inline void add_lock(struct lock_list **list, struct lock *lock)
+{
+	add_ptr_list(list, lock);
+}
+
+static inline void remove_lock(struct lock_list **list, struct lock *lock)
+{
+	delete_ptr_list_entry((struct ptr_list **)list, lock, 1);
+}
+
+static struct lock *lookup_lock(struct lock_list *list, struct symbol *sym)
+{
+	struct lock *l;
+
+	FOR_EACH_PTR(list, l) {
+		if (sym == l->sym)
+			return l;
+	} END_FOR_EACH_PTR(l);
+
+	return NULL;
+}
+
+static struct lock_list *all_locks;
+
+static void add_stack_trace(struct frame_list *stack, struct lock *lock)
+{
+	struct stack *st;
+
+	/* Filter out duplicates */
+	FOR_EACH_PTR(lock->stacks, st) {
+		if (!stack_cmp(stack, st->stack))
+			return;
+	} END_FOR_EACH_PTR(st);
+
+	st = __alloc_stack(0);
+	copy_stack(stack, &st->stack);
+	add_stack(&lock->stacks, st);
+}
+
+/* Copy the current lock set to either the entry or exit list of the
+ * function. Remember also the calling stack. This will be handy
+ * in the second step of the analysis when we check for leaking
+ * locks etc.
+ */
+static void copy_lock_list(struct frame_list *stack,
+				struct lock_list *from, struct lock_list **to)
+{
+	struct lock *lock, *l;
+
+	FOR_EACH_PTR(from, lock) {
+		/* let's colapse symbols with the same addresse to one
+		 * lock and remove duplicates by this.
+		 */
+		l = lookup_lock(all_locks, lock->sym);
+		if (!l) {
+			l = alloc_lock(lock->sym);
+			add_lock(&all_locks, l);
+		} else
+			ref_lock(l);
+
+		if (!lookup_lock(*to, lock->sym))
+			add_lock(to, l);
+
+		add_stack_trace(stack, l);
+	} END_FOR_EACH_PTR(lock);
+}
+
+static inline int lock_list_size(struct lock_list *list)
+{
+	return ptr_list_size((struct ptr_list *)list);
+}
+
+struct bb_info {
+	struct lock_list *entry;
+	struct lock_list *exit;
+};
+ALLOCATOR(bb_info, "bb info");
+
+/* debug printfs helpers */
+
+static void show_call_stack(struct frame_list *list, int level)
+{
+	struct frame *c;
+
+	FOR_EACH_PTR_REVERSE(list, c) {
+		printf("%*sframe: ep %p %s", level * 2, "", c->ep,
+			show_ident(c->ep->name->ident));
+		if (c->insn)
+			printf(" (%s)", show_instruction(c->insn));
+		printf("\n");
+	} END_FOR_EACH_PTR_REVERSE(c);
+}
+
+static void show_short_symbol_list(struct symbol_list *list, const char *name)
+{
+	struct symbol *sym;
+	const char *prepend = "";
+
+	printf("%s:\t", name);
+	FOR_EACH_PTR(list, sym) {
+		printf("%s", prepend);
+		prepend = ", ";
+		printf("%s",  show_ident(sym->ident));
+	} END_FOR_EACH_PTR(sym);
+	puts("");
+}
+
+static void show_pseudo_user_list(struct pseudo_user_list *list,
+				  const char *name)
+{
+	struct pseudo_user *pu;
+
+	if (ptr_list_empty(list))
+		return;
+	printf("%s:\n", name);
+	FOR_EACH_PTR(list, pu) {
+		printf("\t%s used by %p, %s\n",
+			show_pseudo(*pu->userp), pu->insn,
+			show_instruction(pu->insn));
+	} END_FOR_EACH_PTR(pu);
+}
+
+static void show_pseudo_list(struct pseudo_list *list, const char *name)
+{
+	struct pseudo *p;
+	struct symbol *s;
+
+	printf("%s:\n", name);
+	FOR_EACH_PTR(list, p) {
+		printf("\t%s",  show_pseudo(p));
+		switch (p->type) {
+		case PSEUDO_SYM:
+			printf(" (symbol %p scope %p ", p->sym, p->sym->scope);
+			s = p->sym->next_id;
+			while (s) {
+				printf("next_id %p ", s);
+				s = s->next_id;
+			}
+			show_type(p->sym);
+			printf(")\n");
+			break;
+		case PSEUDO_ARG:
+			printf(" (");
+			show_pseudo_user_list(p->users, "users");
+			printf(" )\n");
+			break;
+		default:
+			break;
+		}
+	} END_FOR_EACH_PTR(p);
+}
+
+static void show_basic_block_list(struct basic_block_list *list,
+				  const char *name)
+{
+	struct basic_block *bb;
+	const char *prepend = "";
+
+	printf("%s:\t", name);
+	FOR_EACH_PTR(list, bb) {
+		printf("%s", prepend);
+		prepend = ", ";
+		printf("%p",  bb);
+	} END_FOR_EACH_PTR(bb);
+	puts("");
+}
+
+static const char * const cap_ops[] = {
+	[CAP_ACQUIRE] = "acquire",
+	[CAP_RELEASE] = "release",
+	[CAP_REQUIRES] = "requires",
+	[CAP_GUARDED_BY] = "guarded_by",
+};
+
+static void show_cap(struct capability *cap)
+{
+	printf("cap %p %s '%s'\n", cap,
+		cap_ops[cap->op],
+		cap->expr ? show_ident(cap->expr->symbol_name) : "anon");
+}
+
+static void show_lock(struct lock *lock, const char *prepend,
+		const char *postfix)
+{
+	printf("%ssym %p '%s' %s",
+		prepend, lock->sym,
+		lock->sym ? show_ident(lock->sym->ident) : "anon",
+		postfix);
+}
+
+static void show_lock_list(struct lock_list *locks,
+			const char *prepend, const char *postfix)
+{
+	struct lock *lock;
+
+	FOR_EACH_PTR(locks, lock) {
+		show_lock(lock, prepend, postfix);
+	} END_FOR_EACH_PTR(lock);
+}
+
+static void show_cap_list(struct capability_list *list, const char *name)
+{
+	struct capability *cap;
+	const char *prepend = "";
+
+	printf("%s:\t", name);
+	FOR_EACH_PTR(list, cap) {
+		printf("%s", prepend);
+		prepend = ", ";
+		show_cap(cap);
+	} END_FOR_EACH_PTR(cap);
+	puts("");
+}
+
+static void show_bb_lock_list(struct basic_block_list *list, const char *name)
+{
+	struct basic_block *bb;
+
+	printf("%s:\n", name);
+	FOR_EACH_PTR(list, bb) {
+		struct bb_info *info = bb->priv;
+
+		printf("\tbb %p\n", bb);
+		printf("\t\tlocks entry:\n");
+		show_lock_list(info->entry, "\t\t\t", "\n");
+		printf("\t\tlocks exit:\n");
+		show_lock_list(info->exit, "\t\t\t", "\n");
+	} END_FOR_EACH_PTR(bb);
+}
+
+static void show_entry_lock_list(struct entrypoint *ep, int level)
+{
+	struct basic_block *bb = ep->entry->bb;
+	struct bb_info *info = bb->priv;
+
+	printf("%*slocks entry:", level * 2, "");
+	show_lock_list(info->entry, " ", ",");
+	printf("\n");
+}
+
+static void show_exit_lock_list(struct entrypoint *ep, int level)
+{
+	struct basic_block *bb = last_basic_block(ep->bbs);
+	struct bb_info *info = bb->priv;
+
+	printf("%*slocks exit:", level * 2, "");
+	show_lock_list(info->exit, " ", ",");
+	printf("\n");
+}
+
+static void show_entrypoint(struct entrypoint *ep)
+{
+	printf("ep:\t%s\n", ep->name->ident->name);
+	show_short_symbol_list(ep->name->ctype.base_type->arguments, "args");
+	show_short_symbol_list(ep->syms, "syms");
+	show_pseudo_list(ep->accesses, "accesses");
+	show_basic_block_list(ep->bbs, "bbs");
+	show_pseudo_list(ep->entry->arg_list, "arg_list");
+	show_cap_list(ep->name->ctype.capabilities, "caps");
+	show_bb_lock_list(ep->bbs, "locks");
+}
+
+static struct pseudo *lookup_accesses(struct entrypoint *ep,
+					struct ident *ident)
+{
+	struct pseudo *p;
+
+	if (!ident)
+		return NULL;
+
+	FOR_EACH_PTR(ep->accesses, p) {
+		if (p->ident && !strcmp(p->ident->name, ident->name))
+			return p;
+	} END_FOR_EACH_PTR(p);
+
+	return NULL;
+}
+
+static struct pseudo *get_argument_pseudo(struct pseudo_list *list, int nr)
+{
+	struct pseudo *p;
+	int i = 1;
+
+	FOR_EACH_PTR(list, p) {
+		if (i == nr)
+			return p;
+		i++;
+	} END_FOR_EACH_PTR(p);
+
+	return NULL;
+}
+
+static int get_argument_nr(struct symbol_list *list, struct pseudo *p)
+{
+	int i = 0;
+	struct symbol *sym;
+
+	FOR_EACH_PTR(list, sym) {
+		i++;
+		if (strcmp(sym->ident->name, p->ident->name))
+			continue;
+		return i;
+	} END_FOR_EACH_PTR(sym);
+
+	return -1;
+}
+
+static struct symbol *figure_access(struct pseudo *p, struct frame_list *stack)
+{
+	struct symbol *sym, *type;
+	struct frame *f;
+	int argc = -1;
+
+	FOR_EACH_PTR_REVERSE(stack, f) {
+		if (argc >= 0) {
+			p = get_argument_pseudo(f->insn->arguments, argc);
+			if (!p) {
+				printf("bug bug bug bug for YOUUUUU!!\n");
+				return NULL;
+			}
+
+			argc = -1;
+		}
+
+		if (p->type == PSEUDO_ARG) {
+			/* this is an argument so we can just go on
+			 * frame up and look at the caller.
+			 */
+			argc = p->nr;
+			continue;
+		}
+
+		if (p->type == PSEUDO_SYM) {
+			sym = get_base_type(p->sym);
+			if (is_ptr_type(sym)) {
+				/* so we have a pointer. was it passed
+				 * in as argument?
+				 */
+				type = f->ep->name->ctype.base_type;
+				argc = get_argument_nr(type->arguments, p);
+				continue;
+			} else
+				return p->sym;
+		}
+
+		/* p is not ARG nor SYM, that's the end of the story */
+		break;
+	} END_FOR_EACH_PTR_REVERSE(f);
+
+	return NULL;
+}
+
+static struct symbol *figure_capability(struct capability *cap,
+					struct entrypoint *ep,
+					struct frame_list *stack)
+{
+	struct symbol *sym;
+	struct pseudo *p;
+
+	if (!cap->expr)
+		return NULL;
+
+	if (cap->expr->symbol) {
+		/* so from the linearization step we have a proper symbol,
+		 * just get the pseudo.
+		 */
+		p = lookup_accesses(ep, cap->expr->symbol->ident);
+	} else {
+		/* no luck, we only have the name so let's use that one
+		 * instead.
+		 */
+		p = lookup_accesses(ep, cap->expr->symbol_name);
+	}
+
+	if (p) {
+		/* we found a pseudo in this function, let's try to
+		 * defer it, that is where is defined. note the final
+		 * call frame also handles the global symbols because
+		 * they are also listed in the accesses list.
+		 */
+		sym = figure_access(p, stack);
+	} else {
+		/* the context attributes didn't get the linearize
+		 * treatment, that means the access has not been
+		 * added to the accesses list. first we tried
+		 * to lookup in the accesses list but it is not there
+		 * so we just try to see if it is a global symbol.
+		 */
+		sym = lookup_symbol(cap->expr->symbol_name, NS_SYMBOL);
+	}
+
+	return sym;
+}
+
+static void acquire_lock(struct lock_list **lset, struct entrypoint *ep,
+			struct frame_list *stack, struct capability *cap)
+{
+	struct symbol *sym;
+	struct lock *lock;
+
+	sym = figure_capability(cap, ep, stack);
+	lock = lookup_lock(*lset, sym);
+
+	if (!lock) {
+		lock = alloc_lock(sym);
+		add_lock(lset, lock);
+	} else
+		ref_lock(lock);
+}
+
+static void release_lock(struct lock_list **lset, struct entrypoint *ep,
+			struct frame_list *stack, struct capability *cap)
+{
+	struct symbol *sym;
+	struct lock *lock;
+
+	sym = figure_capability(cap, ep, stack);
+	lock = lookup_lock(*lset, sym);
+
+	if (!lock)
+		return;
+
+	if (!unref_lock(lock)) {
+		remove_lock(lset, lock);
+		__free_lock(lock);
+	}
+}
+
+static void check_cap_requires(struct lock_list **lset,
+				struct entrypoint *ep, struct frame_list *stack)
+{
+	struct capability *cap;
+
+	if (frame_list_size(stack) == 1) {
+		/* there is little point in checking if the caller holds
+		 * the required locks if there is no caller.
+		 */
+		return;
+	}
+
+	/* First step of validation. Let's check if we see
+	 * the required lock in the working set.
+	 */
+	FOR_EACH_PTR(ep->name->ctype.capabilities, cap) {
+		struct symbol *s = figure_capability(cap, ep, stack);
+		struct lock *l;
+
+		switch (cap->op) {
+		case CAP_REQUIRES:
+			l = lookup_lock(*lset, s);
+			if (!l) {
+				warning(ep->name->pos,
+					"function '%s' not holding '%s'",
+					show_ident(ep->name->ident),
+					s ? s->ident->name : "anon");
+			}
+			break;
+		default:
+			break;
+		}
+	} END_FOR_EACH_PTR(cap);
+}
+
+static void update_locks_on_entry(struct lock_list **lset,
+				  struct entrypoint *ep,
+				  struct frame_list *stack,
+				  int level)
+{
+	struct basic_block *bb = ep->entry->bb;
+	struct bb_info *info = bb->priv;
+
+	copy_lock_list(stack, *lset, &info->entry);
+
+	check_cap_requires(lset, ep, stack);
+
+	if (dbg_level0)
+		show_entry_lock_list(ep, level);
+}
+
+static void update_locks_on_exit(struct lock_list **lset,
+				 struct entrypoint *ep,
+				 struct frame_list *stack,
+				 int level)
+{
+	struct basic_block *bb = last_basic_block(ep->bbs);
+	struct bb_info *info = bb->priv;
+	struct capability *cap;
+
+	FOR_EACH_PTR(ep->name->ctype.capabilities, cap) {
+		struct symbol *s = figure_capability(cap, ep, stack);
+		struct lock *l;
+
+		switch (cap->op) {
+		case CAP_ACQUIRE:
+			acquire_lock(lset, ep, stack, cap);
+			break;
+		case CAP_RELEASE:
+			release_lock(lset, ep, stack, cap);
+			break;
+		case CAP_REQUIRES:
+			l = lookup_lock(*lset, s);
+			if (!l) {
+				warning(ep->name->pos,
+					"function '%s' not holding '%s'",
+					show_ident(ep->name->ident),
+					s ? s->ident->name : "anon");
+			}
+			break;
+		default:
+			break;
+		}
+	} END_FOR_EACH_PTR(cap);
+
+	copy_lock_list(stack, *lset, &info->exit);
+
+	if (dbg_level0)
+		show_exit_lock_list(ep, level);
+}
+
+static int function_acquires_lock(struct entrypoint *ep)
+{
+	struct capability *cap;
+
+	FOR_EACH_PTR(ep->name->ctype.capabilities, cap) {
+		if (cap->op == CAP_ACQUIRE)
+			return 1;
+	} END_FOR_EACH_PTR(cap);
+
+	return 0;
+}
+
+static void check_leaking(struct entrypoint *ep)
+{
+	struct basic_block *bb = last_basic_block(ep->bbs);
+	struct bb_info *info = bb->priv;
+	struct lock *lock;
+
+	/* Let's ignore function which acquire locks for the time
+	 * beeing.
+	 */
+	if (function_acquires_lock(ep))
+		return;
+
+	FOR_EACH_PTR(info->exit, lock) {
+		struct stack *st;
+		struct frame_list *leak = NULL;
+		int pos;
+
+		FOR_EACH_PTR(lock->stacks, st) {
+			/* Find a call stack where this ep is the first
+			 * one.
+			 */
+			pos = stack_frame_position(st->stack, ep);
+			if (pos == 0) {
+				if (function_acquires_lock(
+						last_frame(st->stack)->ep)) {
+					leak = st->stack;
+				}
+			} else if (pos > 0) {
+				leak = NULL;
+			}
+		} END_FOR_EACH_PTR(st);
+
+		if (!leak)
+			continue;
+
+		warning(ep->name->pos, "leaks lock '%s'",
+			lock->sym ? show_ident(lock->sym->ident) : "anon");
+		show_call_stack(leak, 1);
+		printf("\n");
+	} END_FOR_EACH_PTR(lock);
+}
+
+static void check_sym_access(struct instruction *insn,
+			struct symbol *sym, struct basic_block *bb,
+			struct lock_list *lset,
+			struct frame_list *stack)
+{
+	struct capability *c;
+	struct lock *l;
+
+	FOR_EACH_PTR(sym->ctype.capabilities, c) {
+		struct symbol *s = figure_capability(c, bb->ep, stack);
+
+		l = lookup_lock(lset, s);
+		if (!l) {
+			warning(insn->pos,
+				"accessing '%s' without holding '%s'",
+				sym->ident->name,
+				s->ident->name);
+		}
+	} END_FOR_EACH_PTR(c);
+}
+
+static void check_bb(struct basic_block *bb, struct lock_list **lset,
+		struct frame_list *stack, unsigned long generation,
+		int level);
+
+static void handle_call(struct instruction *insn, struct lock_list **lset,
+			struct frame_list *stack, int level)
+{
+	struct entrypoint *ep;
+	struct symbol *sym;
+	struct frame *frame;
+
+	if (!insn->func->ident)
+		return;
+
+	sym = lookup_symbol(insn->func->ident, NS_SYMBOL);
+	if (!sym)
+		return;
+	ep = sym->ep;
+
+	/* no code/entrypoint for this symbol, decleration only */
+	if (!ep)
+		return;
+
+	/* prevent recursions */
+	frame = lookup_frame(stack, ep);
+	if (frame)
+		return;
+
+	frame = last_frame(stack);
+	frame->insn = insn;
+	frame = alloc_frame(ep, NULL);
+	add_frame(&stack, frame);
+
+	if (dbg_level0)
+		printf("%*scall %s\n", level * 2, "",
+			show_ident(ep->name->ident));
+	level++;
+	if (dbg_level2)
+		show_call_stack(stack, level);
+
+	update_locks_on_entry(lset, ep, stack, level);
+	check_bb(ep->entry->bb, lset, stack, ++bb_generation, level);
+	update_locks_on_exit(lset, ep, stack, level);
+	level--;
+
+	if (dbg_level0)
+		printf("%*sret %s\n", level * 2, "",
+			show_ident(ep->name->ident));
+
+	frame = delete_last_frame(&stack);
+	__free_frame(frame);
+}
+
+static void check_bb(struct basic_block *bb,
+		struct lock_list **lset, struct frame_list *stack,
+		unsigned long generation, int level)
+{
+	struct instruction *insn;
+	struct multijmp *mj;
+	struct symbol *sym;
+	struct bb_info *info = bb->priv;
+
+	if (!info) {
+		info = __alloc_bb_info(0);
+		bb->priv = info;
+	}
+
+	if (generation == bb->generation)
+		return;
+	bb->generation = generation;
+
+	if (dbg_level2)
+		printf("%*sentry bb %p\n", level * 2, "", bb);
+
+	FOR_EACH_PTR(bb->insns, insn) {
+		switch (insn->opcode) {
+		case OP_CALL:
+			handle_call(insn, lset, stack, level);
+			break;
+		case OP_BR:
+			if (dbg_level2)
+				level++;
+
+			if (insn->bb_true)
+				check_bb(insn->bb_true, lset, stack,
+					 generation, level);
+			if (insn->bb_false)
+				check_bb(insn->bb_false, lset, stack,
+					 generation, level);
+			if (dbg_level2)
+				level--;
+			break;
+		case OP_SWITCH:
+		case OP_COMPUTEDGOTO:
+			/* Note this one might jump backwards, which means
+			 * we need to be careful and not endup in an endless
+			 * loop.
+			 */
+			if (dbg_level2)
+				level++;
+			FOR_EACH_PTR(insn->multijmp_list, mj) {
+				check_bb(mj->target, lset, stack,
+					 generation, level);
+			} END_FOR_EACH_PTR(mj);
+			if (dbg_level2)
+				level--;
+			break;
+
+		case OP_LOAD:
+		case OP_STORE:
+			sym = figure_access(insn->src, stack);
+			if (dbg_level1)
+				printf("%*sld/st: %p %s\n", level * 2, "",
+					sym, sym ? show_ident(sym->ident) : "");
+			if (sym)
+				check_sym_access(insn, sym, bb, *lset, stack);
+			break;
+		}
+	} END_FOR_EACH_PTR(insn);
+
+	if (dbg_level2)
+		printf("%*sexit  bb %p\n", level * 2, "", bb);
+}
+
+static void check_entrypoint(struct entrypoint *ep)
+{
+	struct frame_list *stack;
+	struct frame *frame;
+	struct lock_list *lset = NULL;
+	struct bb_info *info = ep->entry->bb->priv;
+	int level = 0;
+
+	if (!info) {
+		info = __alloc_bb_info(0);
+		ep->entry->bb->priv = info;
+	}
+
+	stack = NULL;
+	frame = alloc_frame(ep, NULL);
+	add_frame(&stack, frame);
+
+	update_locks_on_entry(&lset, ep, stack, level);
+	check_bb(ep->entry->bb, &lset, stack, ++bb_generation, level);
+	update_locks_on_exit(&lset, ep, stack, level);
+
+	frame = delete_last_frame(&stack);
+	__free_frame(frame);
+}
+
+DECLARE_PTR_LIST(entrypoint_list, struct entrypoint);
+
+static inline void add_entrypoint(struct entrypoint_list **list,
+				  struct entrypoint *ep)
+{
+	add_ptr_list(list, ep);
+}
+
+static void check_symbols(struct symbol_list *list)
+{
+	struct entrypoint_list *eps = NULL;
+	struct entrypoint *ep;
+	struct symbol *sym;
+
+	/* First pass collect all locks */
+	FOR_EACH_PTR(list, sym) {
+		expand_symbol(sym);
+		ep = linearize_symbol(sym);
+		if (ep) {
+			if (dbg_level0)
+				printf("\n## %s()\n",
+					show_ident(ep->name->ident));
+
+			/* Call each function and collect all locks
+			 * taken at entry and exit point of function.
+			 */
+			check_entrypoint(ep);
+
+			add_entrypoint(&eps, ep);
+		}
+	} END_FOR_EACH_PTR(sym);
+
+	FOR_EACH_PTR(eps, ep) {
+		if (dbg_level3) {
+			printf("\n## %s()\n",
+				show_ident(ep->name->ident));
+			show_entrypoint(ep);
+			printf("\n");
+		}
+
+		check_leaking(ep);
+	} END_FOR_EACH_PTR(ep);
+}
+
+int main(int argc, char **argv)
+{
+	struct string_list *filelist = NULL;
+	char *file;
+
+	add_pre_buffer("#define __TESTLOCK__ 1\n");
+
+	check_symbols(sparse_initialize(argc, argv, &filelist));
+	FOR_EACH_PTR_NOTAG(filelist, file) {
+		check_symbols(sparse(file));
+	} END_FOR_EACH_PTR_NOTAG(file);
+
+#if 0
+	show_frame_alloc();
+	show_lock_alloc();
+#endif
+	return 0;
+}
diff --git a/validation/caps.c b/validation/caps.c
new file mode 100644
index 0000000..0ffa407
--- /dev/null
+++ b/validation/caps.c
@@ -0,0 +1,80 @@
+#define __must_hold(x)	__attribute__((requires_capability(x)))
+#define __acquires(x)	__attribute__((acquire_capability(x)))
+#define __releases(x)	__attribute__((release_capability(x)))
+#define __guarded_by(x)	__attribute__((guarded_by(x)))
+
+static void a(void) __acquires()
+{
+}
+
+static void r(void) __releases()
+{
+}
+
+static void good1(void)
+{
+	a();
+	r();
+}
+
+static void okay1(void)
+{
+	a();
+}
+
+static void bad2(void)
+{
+	okay1();
+}
+
+struct hello {
+	char *str;
+	int lock;
+};
+
+static struct hello info __guarded_by(info.lock);
+
+static void wtf_lock(int *lock)
+	__acquires(lock)
+{
+	*lock = 1;
+}
+
+static void wtf_unlock(int *lock)
+	__releases(lock)
+{
+	*lock = 0;
+}
+
+static void set_str(struct hello *h)
+	__must_hold(h->lock)
+{
+	h->str = "hello";
+}
+
+static good2(void)
+{
+	wtf_lock(&info.lock);
+	set_str(&info);
+	wtf_unlock(&info.lock);
+}
+
+static int global_lock;
+
+static good3(void)
+{
+	wtf_lock(&global_lock);
+	wtf_unlock(&global_lock);
+}
+
+static bad4(void)
+{
+	wtf_lock(&global_lock);
+}
+
+/*
+ * check-name: Check capabilities
+ *
+ * check-error-start
+ * check-error-end
+ */
-- 
2.5.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] add support for __int128 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] add support for __int128
Date: Fri, 09 Dec 2016 23:03:09 +0000
Message-ID: <20161209230311.36024-1-luc.vanoostenryck () gmail ! com>
--------------------
Add support for this type since there is a proposal to use it
in the Linux kernel.

The first patch first fix a bug related to long long long int,
the second one really add the support.

Luc Van Oostenryck (2):
  fix missing element in types declaration
  add support for __int128

 parse.c             | 12 ++++++++++-
 validation/int128.c | 58 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 69 insertions(+), 1 deletion(-)
 create mode 100644 validation/int128.c

-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] be more generous with ptrlist repacking ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] be more generous with ptrlist repacking
Date: Thu, 17 Nov 2016 17:25:57 +0000
Message-ID: <20161117172559.29417-1-luc.vanoostenryck () gmail ! com>
--------------------
The macros that do the ptrlist walking don't handle empty blocks.
So, when some elements are removed from a list some list rapacking
need to be done to remove the empty blocks. Failure to do this
can result in crashes or data corruption.

This series aims to improve the situation by:
- doing the repacking at the places where some elements are removed
  but no repacking where done.
- to compensate the added cost, mark ptrlists as dirty when some
  element are removed from it and only do the repacking when the list
  is marked as dirty.

Another thing that can be done would be to check the dirty bit at every
list walking but I think this should be reserved for testing/debugging.

In fact, while at first agreeing with the idea of the second patch,
I think less and less that it's the right approach.
What are we looking after here?
* Performance?
  - Will this bit save us a lot of list repacking?
* Robustness?
  - What this bit bring us? Nothing without check at each list walking.
    Is it a good idea to sprinkle some assert() on the macros?
  - I would much prefer to have something that either:
    - can do the list walking with empty blocks, or
    - never leave any empty blocks.
    and this without making the macros heavier :)


I'll try later to propose something but for now ...

Luc Van Oostenryck (2):
  add missing PACK_PTR_LIST()
  mark lists to be repacked as dirty

 cse.c      | 1 +
 evaluate.c | 1 +
 ptrlist.c  | 7 +++++++
 ptrlist.h  | 4 +++-
 4 files changed, 12 insertions(+), 1 deletion(-)

-- 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] be more generous with ptrlist repacking
Date: Thu, 17 Nov 2016 18:17:14 +0000
Message-ID: <CANeU7QnqhZfZtToAhQ8CPniS7DFNdhwYdCp=zZDzsqtpuD=pJQ () mail ! gmail ! com>
--------------------
On Fri, Nov 18, 2016 at 1:40 AM, Linus Torvalds
<torvalds@linux-foundation.org> wrote:
>
> I suspect they should be fairly easy to update to just walk the list
> until they hit a non-empty case (like DO_NEXT() already does, for
> example).

I think you are right, as always. It just need to add four while loops
into first_ptr_list/last_ptr_list/DO_PREPARE/DO_RESET.

Amount those 3 of the place should be able to share a function
(or macro) to find the next not empty entry from list head.

Ptrlist deletion happen so rare, it does not justify the complexity.

Luc, sorry about the bad suggestion.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] be more generous with ptrlist repacking
Date: Thu, 17 Nov 2016 20:25:24 +0000
Message-ID: <20161117202523.GA35194 () macpro ! local>
--------------------
On Thu, Nov 17, 2016 at 09:40:20AM -0800, Linus Torvalds wrote:
> On Thu, Nov 17, 2016 at 9:25 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > The macros that do the ptrlist walking don't handle empty blocks.
> 
> Actually, most of the_do_ handle empty blocks. In particular, the
> normal FOR_EACH_PTR() case should handle it just fine.

Yes, indeed.
 
> The exception is, I think:
> 
>  - first_ptr_list/last_ptr_list
> 
>  - DO_PREPARE/DO_RESET

... 

> I suspect they should be fairly easy to update to just walk the list
> until they hit a non-empty case (like DO_NEXT() already does, for
> example).
> 
>               Linus
> --

Would something like the following be fine?


================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] be more generous with ptrlist repacking
Date: Thu, 17 Nov 2016 22:03:05 +0000
Message-ID: <CA+55aFwsQYAFO+hbSi3pxvkjVA6Jv=DpeZrVHyzj9-RmAuF=tQ () mail ! gmail ! com>
--------------------
On Thu, Nov 17, 2016 at 12:25 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Would something like the following be fine?

This looks good to me, although I didn't actually test it.  But it
looks like what I would have expected.

Some of those inlines look large enough that I wonder how much sense
they make as inlines any more, but I think that's a separate issue.

               Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] be more generous with ptrlist repacking
Date: Fri, 18 Nov 2016 00:29:19 +0000
Message-ID: <20161118002918.GA35373 () macpro ! local>
--------------------
On Thu, Nov 17, 2016 at 02:03:05PM -0800, Linus Torvalds wrote:
> On Thu, Nov 17, 2016 at 12:25 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > Would something like the following be fine?
> 
> This looks good to me, although I didn't actually test it.  But it
> looks like what I would have expected.
> 
> Some of those inlines look large enough that I wonder how much sense
> they make as inlines any more, but I think that's a separate issue.

Oh, I absolutely agree.
What I would like is something more iterator oriented which keep track
of the head-list-nr state. I have a working prototype I made last week
but it still needs some more polishing.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] be more generous with ptrlist repacking
Date: Mon, 28 Nov 2016 21:15:15 +0000
Message-ID: <20161128211514.GA1077 () macbook ! local>
--------------------
On Fri, Nov 18, 2016 at 01:29:19AM +0100, Luc Van Oostenryck wrote:
> On Thu, Nov 17, 2016 at 02:03:05PM -0800, Linus Torvalds wrote:
> > On Thu, Nov 17, 2016 at 12:25 PM, Luc Van Oostenryck
> > <luc.vanoostenryck@gmail.com> wrote:
> > >
> > > Would something like the following be fine?
> > 
> > This looks good to me, although I didn't actually test it.  But it
> > looks like what I would have expected.
> > 
> > Some of those inlines look large enough that I wonder how much sense
> > they make as inlines any more, but I think that's a separate issue.
> 
> Oh, I absolutely agree.
> What I would like is something more iterator oriented which keep track
> of the head-list-nr state. I have a working prototype I made last week
> but it still needs some more polishing.
> 

I've worked a bit more on this. I had a nice, clean & compact
implementation where basically all ptr_list walking was done by
something like:
	struct ptr_iter iter;
	ptr_iter_init(&iter, head);
	while ((ptr = ptr_iter_next(&iter)))
		...

Of course, still hidden under the macros which do the type checking.
This had the advantage that all the logic was in a single place.
It seemed to work well that is until I discovered that at a few places we're
storing null pointers in ptr_lists. It's thus not possible to use the
returned pointer to also check the end of list condition. The situation
is even a bit more complex because the PREPARE/NEXT_PTR_LIST() also
can't work with null pointers.

I've found a few alternative that work in all the cases but they aren't
simple & compact enough to my taste so I'll let things like they are
and maybe just sent a few cleanups later.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] be more generous with ptrlist repacking
Date: Tue, 06 Dec 2016 00:24:00 +0000
Message-ID: <CANeU7QmzbMc9Uairgj6ZAMBOkLj-6mCuZLzU79ZXBo0i9SHRQg () mail ! gmail ! com>
--------------------
On Mon, Nov 28, 2016 at 1:15 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> I've worked a bit more on this. I had a nice, clean & compact
> implementation where basically all ptr_list walking was done by
> something like:
>         struct ptr_iter iter;
>         ptr_iter_init(&iter, head);
>         while ((ptr = ptr_iter_next(&iter)))
>                 ...

Last time I try that, I look at the machine code and realized that
using iter struct is not quite the same as using macro. On each function
boundary, the compiler still try to sync the data register content
into the iter structure in memory. In other words, there is no way to make the
iter variable as register, it always get sync into memory.

I did run a full kernel source check back then, did not find an observable
difference. The time difference is within the variance of each run.
Maybe due to most of the list are very short.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] normalize bb's label names for testing ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] normalize bb's label names for testing
Date: Mon, 21 Nov 2016 04:14:19 +0000
Message-ID: <20161121041421.34576-1-luc.vanoostenryck () gmail ! com>
--------------------
These two patches solves the testing problem of the label names
as emitted by test-linearize and others being not comparable
between runs.

Luc Van Oostenryck (2):
  testsuite: allow commands to use pipes
  testsuite: add a script to normalize label names

 validation/normalize-bb        | 16 ++++++++++++++++
 validation/test-normalize-bb.c | 31 +++++++++++++++++++++++++++++++
 validation/test-pipe-cmd.c     | 13 +++++++++++++
 validation/test-suite          |  6 +++---
 4 files changed, 63 insertions(+), 3 deletions(-)
 create mode 100755 validation/normalize-bb
 create mode 100644 validation/test-normalize-bb.c
 create mode 100644 validation/test-pipe-cmd.c

-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] normalize bb's label names for testing
Date: Tue, 22 Nov 2016 10:02:04 +0000
Message-ID: <CANeU7Q=uNLQh=ynnWPeO0+ahu7qhJ2nxqxOrxbDraR1jo6xEAQ () mail ! gmail ! com>
--------------------
On Mon, Nov 21, 2016 at 12:14 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> These two patches solves the testing problem of the label names
> as emitted by test-linearize and others being not comparable
> between runs.

I think it is much easier just let test-linearize print out label in
a predictable way. e.g. In the "struct basic_block", there is this
two fields "generation" and "priv". The "generation" is used by
flow analyze to store some state. Same as the "priv", which is
used by the back end to store some back end related state.

Since test-linearize can treat as a back end, it is perfectly safe
to store some allocation number into the "priv".

Than we don't need to complicate the test-suit script to do the
label normalization.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] normalize bb's label names for testing
Date: Tue, 22 Nov 2016 13:27:49 +0000
Message-ID: <20161122132748.GB8370 () macbook ! local>
--------------------
On Tue, Nov 22, 2016 at 06:02:04PM +0800, Christopher Li wrote:
> On Mon, Nov 21, 2016 at 12:14 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > These two patches solves the testing problem of the label names
> > as emitted by test-linearize and others being not comparable
> > between runs.
> 
> I think it is much easier just let test-linearize print out label in
> a predictable way.

Absolutely. It's what I'm doing here on my working tree.

> e.g. In the "struct basic_block", there is this
> two fields "generation" and "priv". The "generation" is used by
> flow analyze to store some state. Same as the "priv", which is
> used by the back end to store some back end related state.
> 
> Since test-linearize can treat as a back end, it is perfectly safe
> to store some allocation number into the "priv".

The problem with this 'priv' is that it's, well ... private, if we
reuse it to store labels IDs it possibly can't be used anymore for
this private usage.
I would be more tempted to reuse the 'generation' field which is a long
and don't need much bits.
Of course, the real question is if that's such important to not add a new
field to struct bb.

> Than we don't need to complicate the test-suit script to do the
> label normalization.

Sure.
But it should be noted that this filtering stuff *could* be useful for other
things to (but I have no such uses).

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] normalize bb's label names for testing
Date: Tue, 22 Nov 2016 16:44:36 +0000
Message-ID: <CANeU7Qk+_N7A+DMKrLxoNi1fq8twfpJ8jLeartsc+jsMQiXN0Q () mail ! gmail ! com>
--------------------
On Tue, Nov 22, 2016 at 9:27 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Absolutely. It's what I'm doing here on my working tree.
>

Great.

> The problem with this 'priv' is that it's, well ... private, if we
> reuse it to store labels IDs it possibly can't be used anymore for
> this private usage.
> I would be more tempted to reuse the 'generation' field which is a long
> and don't need much bits.
> Of course, the real question is if that's such important to not add a new
> field to struct bb.

It is private to the back end. If you consider test-linearize as one of
the back end, it compile the C code into readable text form. it is fine
to use it. I assume the label ID is only make sense for test-linearize,
not for other back end?

I am also OK with just introduce one more field ID for basic blocks.
There are far less basic blocks than instructions. So even size of basic
block bump up by a integer is not a big deal.

> Sure.
> But it should be noted that this filtering stuff *could* be useful for other
> things to (but I have no such uses).

We can always deal with it when such usage actually come up.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] normalize bb's label names for testing
Date: Tue, 22 Nov 2016 17:02:31 +0000
Message-ID: <20161122170230.GA8847 () macbook ! local>
--------------------
On Wed, Nov 23, 2016 at 12:44:36AM +0800, Christopher Li wrote:
> 
> It is private to the back end. If you consider test-linearize as one of
> the back end, it compile the C code into readable text form. it is fine
> to use it. I assume the label ID is only make sense for test-linearize,
> not for other back end?

I use it for test-linearize, test-unssa and others stuff I'll coming up
with in the coming weeks I hope. So nothing I consider as 'private',
external or out-of-tree.
 
> I am also OK with just introduce one more field ID for basic blocks.
> There are far less basic blocks than instructions. So even size of basic
> block bump up by a integer is not a big deal.
Yes, I think so too.
But anyway, I already sent a patch which reuse the 'priv' member with
an union. It will always be very easy to remove the union later if needed.
 
> > Sure.
> > But it should be noted that this filtering stuff *could* be useful for other
> > things to (but I have no such uses).
> 
> We can always deal with it when such usage actually come up.
Absolutely.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] simplify binops with identical operands ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] simplify binops with identical operands
Date: Wed, 07 Dec 2016 16:32:55 +0000
Message-ID: <20161207163257.22287-1-luc.vanoostenryck () gmail ! com>
--------------------
This serie add simplification of binops and comparison where
both operands are identical, and add an optional warning for those
comparison.


Luc Van Oostenryck (2):
  simplify '(x op x)' to '0', '1' or 'x'
  add warning option '-Wtautological-compare'

 lib.c                               |  2 ++
 lib.h                               |  1 +
 simplify.c                          | 39 +++++++++++++++++++++++++++++
 validation/optim/binops-same-args.c | 49 +++++++++++++++++++++++++++++++++++++
 validation/tautological-compare.c   | 35 ++++++++++++++++++++++++++
 5 files changed, 126 insertions(+)
 create mode 100644 validation/optim/binops-same-args.c
 create mode 100644 validation/tautological-compare.c

-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] Minor enhancements and fixes ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/3] Minor enhancements and fixes
Date: Tue, 02 Feb 2016 18:54:34 +0000
Message-ID: <CANeU7QmwzNVT07qeXNwyvu9xJ=BCC1nSKm54y7zF8ofpAF=CoA () mail ! gmail ! com>
--------------------
On Thu, Dec 3, 2015 at 2:52 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>
> Any chance of this patchset being committed to sparse?
>

Better late than never. It has been sitting on my laptop for a long
time.

I add some minor modification to the last patch.

Applied and pushed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] fix cast to bool ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] fix cast to bool
Date: Sun, 11 Dec 2016 21:13:25 +0000
Message-ID: <20161211211328.26735-1-luc.vanoostenryck () gmail ! com>
--------------------
This serie fix casting to bool (patch 1) and add two simplifications
which couldn't be done without the fix.

Luc Van Oostenryck (3):
  fix cast to bool
  simplify comparisons followed by an equality test against 0 or 1
  simplify '(x || x)' and '(x && x)'

 evaluate.c                        | 32 +++++++++++++++++
 simplify.c                        | 73 ++++++++++++++++++++++++++++++++++++---
 validation/bool-cast-bad.c        | 27 +++++++++++++++
 validation/bool-cast-explicit.c   | 26 ++++++++++++++
 validation/bool-cast-implicit.c   | 28 +++++++++++++++
 validation/optim/bool-same-args.c | 12 +++++++
 validation/optim/setcc-setcc.c    | 19 ++++++++++
 validation/optim/setcc-seteq.c    | 13 +++++++
 validation/optim/setcc-setne.c    | 13 +++++++
 9 files changed, 239 insertions(+), 4 deletions(-)
 create mode 100644 validation/bool-cast-bad.c
 create mode 100644 validation/bool-cast-explicit.c
 create mode 100644 validation/bool-cast-implicit.c
 create mode 100644 validation/optim/bool-same-args.c
 create mode 100644 validation/optim/setcc-setcc.c
 create mode 100644 validation/optim/setcc-seteq.c
 create mode 100644 validation/optim/setcc-setne.c

-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/6] modifiers inheritance by '&' and 'typeof()' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/6] modifiers inheritance by '&' and 'typeof()'
Date: Thu, 24 Nov 2016 17:09:41 +0000
Message-ID: <20161124170947.14379-1-luc.vanoostenryck () gmail ! com>
--------------------
There is several issues regarding which modifiers is or must be
preserved when using the '&' or 'typeof()' operators. There is
also no explicit tests for these. This serie aims to improve this
situation by:
  - avoid to inherit storage modifiers by '&' (patch 1)
  - simplify an existing test (patch 2 & 3)
  - create a bunch of test cases (patch 4 & 5)
  - partial fix for modifiers needing to be inherited by typeof
    (patch 6)

The last patch is marked as '[RFC]' because it needs some clarification
on the wanted semantics of some modifiers in some situations.
In particular, MOD_NODEREF & MOD_SAFE are for the moment not addressed,
like the address space.
Lastly, especially for what concerns MOD_SAFE, some others changes are
needed.

Luc Van Oostenryck (6):
  storage should not be inherited by pointers
  testsuite: simplify test function-pointer-inheritance
  use a shorter name for function-pointer-modifier-inheritance.c
  testsuite: test modifiers preserved by '&' operator
  testsuite: test modifiers preserved by 'typeof()'
  [RFC] some modifiers need to be preserved by 'typeof()'

 symbol.c                                           |   8 +-
 symbol.h                                           |   4 +-
 validation/function-pointer-inheritance.c          |   9 ++
 validation/function-pointer-modifier-inheritance.c |  18 ----
 validation/nocast.c                                |   2 +-
 validation/ptr-inherit.c                           |  80 +++++++++++++++
 validation/typeof-addresspace.c                    |  20 ++++
 validation/typeof-mods.c                           | 109 +++++++++++++++++++++
 validation/typeof-noderef.c                        |  19 ++++
 validation/typeof-safe.c                           |  23 +++++
 10 files changed, 270 insertions(+), 22 deletions(-)
 create mode 100644 validation/function-pointer-inheritance.c
 delete mode 100644 validation/function-pointer-modifier-inheritance.c
 create mode 100644 validation/ptr-inherit.c
 create mode 100644 validation/typeof-addresspace.c
 create mode 100644 validation/typeof-mods.c
 create mode 100644 validation/typeof-noderef.c
 create mode 100644 validation/typeof-safe.c

-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] add missing PACK_PTR_LIST() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] add missing PACK_PTR_LIST()
Date: Thu, 17 Nov 2016 17:25:58 +0000
Message-ID: <20161117172559.29417-2-luc.vanoostenryck () gmail ! com>
--------------------
At two places in the code, DELETE_PTR() is called on soem list
but PACK_PTR_LIST() is not called at the end of the loop.
This potentially leave empty ptrlist 'blocks' which are not handled
by the usual list walking macros.

No concrete situation have been found where a real problem
occurs but better be safe than sorry and call PACK_PTR_LIST()
here too.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 cse.c      | 1 +
 evaluate.c | 1 +
 2 files changed, 2 insertions(+)

diff --git a/cse.c b/cse.c
index e8fbe344..71325a74 100644
--- a/cse.c
+++ b/cse.c
@@ -260,6 +260,7 @@ static struct instruction * cse_one_instruction(struct instruction *insn, struct
 				if (pu->insn == insn)
 					DELETE_CURRENT_PTR(pu);
 			} END_FOR_EACH_PTR(pu);
+			PACK_PTR_LIST(&phi->users);
 		} END_FOR_EACH_PTR(phi);
 	}
 
diff --git a/evaluate.c b/evaluate.c
index e350c0c0..d1383902 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2521,6 +2521,7 @@ found:
 		excess(e, lclass & TYPE_PTR ? "array" : "struct or union");
 
 	} END_FOR_EACH_PTR(e);
+	PACK_PTR_LIST(&expr->expr_list);
 
 	convert_designators(last);
 	expr->ctype = ctype;
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] compiler.h: add support for malloc attribute ===

From: Rasmus Villemoes <linux () rasmusvillemoes ! dk>
To: linux-sparse
Subject: [PATCH 1/2] compiler.h: add support for malloc attribute
Date: Wed, 23 Mar 2016 23:42:31 +0000
Message-ID: <1458776553-9033-1-git-send-email-linux () rasmusvillemoes ! dk>
--------------------
gcc as far back as at least 3.04 documents the function attribute
__malloc__. Add a shorthand for attaching that to a function
declaration. This was also suggested by Andi Kleen way back in 2002
[1], but didn't get applied, perhaps because gcc at that time
generated the exact same code with and without this attribute.

This attribute tells the compiler that the return value (if non-NULL)
can be assumed not to alias any other valid pointers at the time of
the call.

Please note that the documentation for a range of gcc versions
(starting from around 4.7) contained a somewhat confusing and
self-contradicting text:

  The malloc attribute is used to tell the compiler that a function
  may be treated as if any non-NULL pointer it returns cannot alias
  any other pointer valid when the function returns and *that the
  memory has undefined content*. [...] Standard functions with this
  property include malloc and *calloc*.

(emphasis mine). The intended meaning has later been clarified [2]:

  This tells the compiler that a function is malloc-like, i.e., that
  the pointer P returned by the function cannot alias any other
  pointer valid when the function returns, and moreover no pointers to
  valid objects occur in any storage addressed by P.

What this means is that we can apply the attribute to kmalloc and
friends, and it is ok for the returned memory to have well-defined
contents (__GFP_ZERO). But it is not ok to apply it to kmemdup(), nor
to other functions which both allocate and possibly initialize the
memory with existing pointers. So unless someone is doing something
pretty perverted kstrdup() should also be a fine candidate.

[1] http://thread.gmane.org/gmane.linux.kernel/57172
[2] https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56955

Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
---
 include/linux/compiler-gcc.h | 1 +
 include/linux/compiler.h     | 4 ++++
 2 files changed, 5 insertions(+)

diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 22ab246feed3..9004f153c5ab 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -142,6 +142,7 @@
 
 #if GCC_VERSION >= 30400
 #define __must_check		__attribute__((warn_unused_result))
+#define __malloc		__attribute__((__malloc__))
 #endif
 
 #if GCC_VERSION >= 40000
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index b5ff9881bef8..793c0829e3a3 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -357,6 +357,10 @@ static __always_inline void __write_once_size(volatile void *p, void *res, int s
 #define __deprecated_for_modules
 #endif
 
+#ifndef __malloc
+#define __malloc
+#endif
+
 /*
  * Allow us to avoid 'defined but not used' warnings on functions and data,
  * as well as force them to be emitted to the assembly file.
-- 
2.1.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] fix missing element in types declaration ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] fix missing element in types declaration
Date: Fri, 09 Dec 2016 23:03:10 +0000
Message-ID: <20161209230311.36024-2-luc.vanoostenryck () gmail ! com>
--------------------
In the code doing the parsing of type declaration there is a few
arrays for the each integer size (short, int, long, long long, ...)
The array for the unsigned and explicitely unsigned integer have
entry for 'slllong' & 'ulllong' last element but the one for plain
integer is missing its 'lllong' entry which make sparse crash when
trying to use this type.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/parse.c b/parse.c
index b52c6abe..808a078a 100644
--- a/parse.c
+++ b/parse.c
@@ -1429,7 +1429,7 @@ Catch_all:
 }
 
 static struct symbol * const int_types[] =
-	{&short_ctype, &int_ctype, &long_ctype, &llong_ctype};
+	{&short_ctype, &int_ctype, &long_ctype, &llong_ctype, &lllong_ctype};
 static struct symbol * const signed_types[] =
 	{&sshort_ctype, &sint_ctype, &slong_ctype, &sllong_ctype,
 	 &slllong_ctype};
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] linearize: Emit C99 declarations correctly ===

From: Emily Maier <emily () emilymaier ! net>
To: linux-sparse
Subject: [PATCH 1/2] linearize: Emit C99 declarations correctly
Date: Wed, 04 May 2016 12:39:43 +0000
Message-ID: <1462365584-20536-1-git-send-email-emily () emilymaier ! net>
--------------------
Variables declared with C99 syntax inside a for statement should be
linearized in the loop top, rather than implicitly inside the loop body.

Signed-off-by: Emily Maier <emily@emilymaier.net>
---
 linearize.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/linearize.c b/linearize.c
index c6ada1e..1309c7d 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1946,7 +1946,11 @@ static pseudo_t linearize_iterator(struct entrypoint *ep, struct statement *stmt
 	struct statement  *post_statement = stmt->iterator_post_statement;
 	struct expression *post_condition = stmt->iterator_post_condition;
 	struct basic_block *loop_top, *loop_body, *loop_continue, *loop_end;
+	struct symbol *sym;
 
+	FOR_EACH_PTR(stmt->iterator_syms, sym) {
+		linearize_one_symbol(ep, sym);
+	} END_FOR_EACH_PTR(sym);
 	concat_symbol_list(stmt->iterator_syms, &ep->syms);
 	linearize_statement(ep, pre_statement);
 
-- 
2.5.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] simplify '(x op x)' to '0', '1' or 'x' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] simplify '(x op x)' to '0', '1' or 'x'
Date: Wed, 07 Dec 2016 16:32:56 +0000
Message-ID: <20161207163257.22287-2-luc.vanoostenryck () gmail ! com>
--------------------
Most binops can be simplified when their two operands are
identical. For example '(x ^ x)' can be simplified into '0'.

The cases '(x / x)' and '(x % x)' are not simplified since this
is correct only when x is not zero.
The cases '(x || x)' and '(x && x)' are not simplified because
it's only correct when the operands are booleans/have already
been compared against zero and the linearization don't enforce that.

This patch add the code for these simplifications as well as
their corresponding test cases.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                          | 35 ++++++++++++++++++++++++++
 validation/optim/binops-same-args.c | 49 +++++++++++++++++++++++++++++++++++++
 2 files changed, 84 insertions(+)
 create mode 100644 validation/optim/binops-same-args.c

diff --git a/simplify.c b/simplify.c
index b5cd0ea7..fde72f0a 100644
--- a/simplify.c
+++ b/simplify.c
@@ -488,6 +488,39 @@ static int simplify_constant_binop(struct instruction *insn)
 	return REPEAT_CSE;
 }
 
+static int simplify_binop_same_args(struct instruction *insn, pseudo_t arg)
+{
+	switch (insn->opcode) {
+	case OP_SET_NE:
+	case OP_SET_LT: case OP_SET_GT:
+	case OP_SET_B:  case OP_SET_A:
+	case OP_SUB:
+	case OP_XOR:
+		return replace_with_pseudo(insn, value_pseudo(0));
+
+	case OP_SET_EQ:
+	case OP_SET_LE: case OP_SET_GE:
+	case OP_SET_BE: case OP_SET_AE:
+		return replace_with_pseudo(insn, value_pseudo(1));
+
+	case OP_AND:
+	case OP_OR:
+		return replace_with_pseudo(insn, arg);
+
+	case OP_AND_BOOL:
+	case OP_OR_BOOL:
+		// simplification is correct only if the operands
+		// have already been compared against zero which
+		// is not enforced.
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 static int simplify_binop(struct instruction *insn)
 {
 	if (dead_insn(insn, &insn->src1, &insn->src2, NULL))
@@ -499,6 +532,8 @@ static int simplify_binop(struct instruction *insn)
 	}
 	if (constant(insn->src2))
 		return simplify_constant_rightside(insn);
+	if (insn->src1 == insn->src2)
+		return simplify_binop_same_args(insn, insn->src1);
 	return 0;
 }
 
diff --git a/validation/optim/binops-same-args.c b/validation/optim/binops-same-args.c
new file mode 100644
index 00000000..9285655d
--- /dev/null
+++ b/validation/optim/binops-same-args.c
@@ -0,0 +1,49 @@
+typedef unsigned int u32;
+
+int ssub(int a) { return a - a; }
+u32 usub(u32 a) { return a - a; }
+
+int sdiv(int a) { return a / a; }
+u32 udiv(u32 a) { return a / a; }
+int smod(int a) { return a % a; }
+u32 umod(u32 a) { return a % a; }
+
+int seq(int a) { return a == a; }
+int sne(int a) { return a != a; }
+int slt(int a) { return a < a; }
+int sgt(int a) { return a > a; }
+int sle(int a) { return a <= a; }
+int sge(int a) { return a >= a; }
+
+u32 ueq(u32 a) { return a == a; }
+u32 une(u32 a) { return a != a; }
+u32 ult(u32 a) { return a < a; }
+u32 ugt(u32 a) { return a > a; }
+u32 ule(u32 a) { return a <= a; }
+u32 uge(u32 a) { return a >= a; }
+
+u32 xor(u32 a) { return a ^ a; }
+
+u32 ior(u32 a) { return a | a; }
+u32 and(u32 a) { return a & a; }
+
+/*
+ * check-name: double-unop
+ * check-command: test-linearize -Wno-decl $file
+ * check-output-ignore
+ *
+ * check-output-excludes: sub\\.
+ * check-output-contains: divs\\.
+ * check-output-contains: divu\\.
+ * check-output-contains: mods\\.
+ * check-output-contains: modu\\.
+ * check-output-excludes: seteq\\.
+ * check-output-excludes: setne\\.
+ * check-output-excludes: set[gl]t\\.
+ * check-output-excludes: set[gl]e\\.
+ * check-output-excludes: set[ab]\\.
+ * check-output-excludes: set[ab]e\\.
+ * check-output-excludes: xor\\.
+ * check-output-excludes: or\\.
+ * check-output-excludes: and\\.
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] testsuite: add tag to ignore the output/error ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3] testsuite: add tag to ignore the output/error
Date: Thu, 17 Nov 2016 17:15:00 +0000
Message-ID: <CANeU7QkhkigFzzvq5tNxyxNKnKfvgoKDx4010VOmQiKtHQRYbw () mail ! gmail ! com>
--------------------
Applied.

Chris

On Thu, Nov 10, 2016 at 10:45 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Currently the test suite always check the exit value and the output
> of the command used for the test. This is fine and allow use to catch
> the most common situations:
> - failure or crash (via the exit value)
> - (un)expected output (like when testing the result of the preprocessor)
> - (un)expected errors & warnings (like when testing sparse's warnings)
>
> But sometimes, we're not interested in the output or the output (as is)
> is simply not meaningful for the test or can't be compared textually
> to some reference.
>
> This patch add two new tags (check-output-ignore & check-error-ignore),
> telling to test suite to ignore the content of stdout or stderr when
> testing this file.
>
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  Documentation/test-suite | 6 ++++++
>  validation/test-suite    | 2 ++
>  2 files changed, 8 insertions(+)
>
> diff --git a/Documentation/test-suite b/Documentation/test-suite
> index 6c4f24f6..6936feeb 100644
> --- a/Documentation/test-suite
> +++ b/Documentation/test-suite
> @@ -29,6 +29,12 @@ check-output-start / check-output-end (optional)
>         The expected output (stdout and stderr) of check-command lies between
>         those two tags. It defaults to no output.
>
> +check-output-ignore / check-error-ignore (optional)
> +       Don't check the expected output (stdout or stderr) of check-command
> +       (usefull when this output is not comparable or if you're only interested
> +       in the exit value).
> +       By default this check is done.
> +
>  check-known-to-fail (optional)
>         Mark the test as being known to fail.
>
> diff --git a/validation/test-suite b/validation/test-suite
> index df5a7c60..0d874e07 100755
> --- a/validation/test-suite
> +++ b/validation/test-suite
> @@ -146,6 +146,8 @@ do_test()
>         actual_exit_value=$?
>
>         for stream in output error; do
> +               grep -s -q "check-$stream-ignore" $file && continue
> +
>                 diff -u "$file".$stream.expected "$file".$stream.got > "$file".$stream.diff
>                 if [ "$?" -ne "0" ]; then
>                         error "actual $stream text does not match expected $stream text."
> --
> 2.10.1
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/6] storage should not be inherited by pointers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/6] storage should not be inherited by pointers
Date: Thu, 24 Nov 2016 17:09:42 +0000
Message-ID: <20161124170947.14379-2-luc.vanoostenryck () gmail ! com>
--------------------
Information about storage is needed for objects but once
you take the address of an object, its storage should be
irrelevant for the resulting pointer.

Trying to keep the storage into the pointer's modifiers
(while it will be available in the base type anyway) only
create corner cases later.
An example of the problem it can create is when the pointer
is dereferenced in an inlined function.

Better to simply not put have the storage informations
for the pointer, which is what this patch does.

To better illustrate the situation, suppose you have the
following variable declaration:
	static int var;

var's type should be:
	int static [toplevel] [addressable]

if you take its address the resulting pointer will be of type:
	int static [toplevel] *

while it should simply be:
	int *

Detected-by: Nicolai Stange <nicstange@gmail.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h            | 2 +-
 validation/nocast.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/symbol.h b/symbol.h
index 9b3f1604..afc4e232 100644
--- a/symbol.h
+++ b/symbol.h
@@ -247,7 +247,7 @@ struct symbol {
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG_ALL)
 #define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
 	MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
-#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE | MOD_NORETURN | MOD_NOCAST)
+#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_NORETURN | MOD_NOCAST)
 
 
 /* Current parsing/evaluation function */
diff --git a/validation/nocast.c b/validation/nocast.c
index c28676a3..cc0ab6b7 100644
--- a/validation/nocast.c
+++ b/validation/nocast.c
@@ -160,7 +160,7 @@ nocast.c:34:33:    got unsigned long
 nocast.c:34:33: warning: implicit cast to nocast type
 nocast.c:35:39: warning: incorrect type in initializer (different modifiers)
 nocast.c:35:39:    expected unsigned long *static [toplevel] bad_ptr_from
-nocast.c:35:39:    got unsigned long static [nocast] [toplevel] *<noident>
+nocast.c:35:39:    got unsigned long [nocast] *<noident>
 nocast.c:35:39: warning: implicit cast from nocast type
 nocast.c:50:16: warning: implicit cast from nocast type
 nocast.c:54:16: warning: implicit cast from nocast type
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/6] storage should not be inherited by pointers
Date: Fri, 25 Nov 2016 03:38:18 +0000
Message-ID: <20161125033817.GA14283 () macbook ! local>
--------------------
On Fri, Nov 25, 2016 at 10:09:25AM +0800, Christopher Li wrote:
> On Fri, Nov 25, 2016 at 1:09 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > Information about storage is needed for objects but once
> > you take the address of an object, its storage should be
> > irrelevant for the resulting pointer.
> >
> > Trying to keep the storage into the pointer's modifiers
> > (while it will be available in the base type anyway) only
> > create corner cases later.
> 
> Either way it is going to be very tricky. If you make the pointer
> does not inherent the object storage modifier, you need to change
> all the place that assume the pointer will inherent the object storage.

Thing is that nowhere should sparse assume this and from what I've seen
nowhere is this assumption done.

> Because C mostly deal with pointer, e.g. "a = b;", is actually
> "*(&a) = *(&b);". Pointer is all over the place.  Right now sparse
> make the pointer inherent the storage is convenient but not precise.
> Changing the underlining assumption will touch a lot of code.
> 
> The extremely tricky one is the context and address space
> store in "struct ctype". It is not a modifier but act like one.
> Address space should belong to the storage object. But
> right now address space is propagate to pointer as well.
> Most of the test is done on pointer level.

I'm not sure we're talking about the same thing.
The patch doesn't touch to anything related to address space
which have to be inherited by the '&/adressof' operator.
The patch only concern what must be done with MOD_STATIC,
MOD_EXTERN & MOD_TOPLEVEL when we're taking the address of an object.
This is certainly one point where taking the address of an object
and then later dereferencing the pointer is *not* the same as using
directly the object, it deosn't matter anymore if the object was
static.

I didn't gave an example where the actual situation is causing a problems
but this patch is in my opinion the right solution to the problem
exposed in Nicolai's patch 20/21 (but in this case the problem only
exist because of a combinaison of a very specific case and another
deficiency) which is brievly described just here under.

> > An example of the problem it can create is when the pointer
> > is dereferenced in an inlined function.
> >
> > Better to simply not put have the storage informations
> > for the pointer, which is what this patch does.
> 
> I think there will be other code changes associate with the assumption
> change.
> 
> One thing to verify is if sparse issues different set of warning
> on the Linux kernel check.

I'll will of course carefully check this but I really doubt there will be
any problems.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] add support for __int128 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] add support for __int128
Date: Fri, 09 Dec 2016 23:03:11 +0000
Message-ID: <20161209230311.36024-3-luc.vanoostenryck () gmail ! com>
--------------------
There is already support for __int128_t & __uint128_t but not yet
for GCC's __int128.

This patch add support for it and a couple of test cases.

Note: it's slightly more tricky that it look because contrary to
'__int128_t', '__int128' is not an exact type (it can still receive
the 'unsigned' or 'signed' specifier).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c             | 10 +++++++++
 validation/int128.c | 58 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 68 insertions(+)
 create mode 100644 validation/int128.c

diff --git a/parse.c b/parse.c
index 808a078a..fa46758a 100644
--- a/parse.c
+++ b/parse.c
@@ -101,6 +101,7 @@ enum {
 	Set_Short = 256,
 	Set_Long = 512,
 	Set_Vlong = 1024,
+	Set_Int128 = 2048,
 	Set_Any = Set_T | Set_Short | Set_Long | Set_Signed | Set_Unsigned
 };
 
@@ -253,6 +254,12 @@ static struct symbol_op long_op = {
 	.set = Set_Long,
 };
 
+static struct symbol_op int128_op = {
+	.type = KW_SPECIFIER | KW_LONG,
+	.test = Set_S|Set_T|Set_Char|Set_Short|Set_Int|Set_Float|Set_Double|Set_Long|Set_Vlong|Set_Int128,
+	.set =  Set_T|Set_Int128,
+};
+
 static struct symbol_op if_op = {
 	.statement = parse_if_statement,
 };
@@ -408,6 +415,7 @@ static struct init_keyword {
 	{ "__signed",	NS_TYPEDEF, .op = &signed_op },
 	{ "__signed__",	NS_TYPEDEF, .op = &signed_op },
 	{ "unsigned",	NS_TYPEDEF, .op = &unsigned_op },
+	{ "__int128",	NS_TYPEDEF, .op = &int128_op },
 	{ "_Bool",	NS_TYPEDEF, .type = &bool_ctype, .op = &spec_op },
 
 	/* Predeclared types */
@@ -1496,6 +1504,8 @@ static struct token *declaration_specifiers(struct token *token, struct decl_sta
 			}
 			seen |= s->op->set;
 			class += s->op->class;
+			if (s->op->set & Set_Int128)
+				size = 2;
 			if (s->op->type & KW_SHORT) {
 				size = -1;
 			} else if (s->op->type & KW_LONG && size++) {
diff --git a/validation/int128.c b/validation/int128.c
new file mode 100644
index 00000000..53d678e2
--- /dev/null
+++ b/validation/int128.c
@@ -0,0 +1,58 @@
+typedef		 __int128	 int128_t;
+typedef   signed __int128	sint128_t;
+typedef unsigned __int128	uint128_t;
+
+typedef	__int128 int	badxi;
+typedef int __int128	badix;
+typedef unsigned unsigned __int128 baduu;
+typedef double __int128 baddx;
+typedef __int128 double badxd;
+
+int sizeof_int128(void)
+{
+	return sizeof(__int128);
+}
+
+typedef unsigned long long u64;
+typedef unsigned long      u32;
+
+u64 foo(u64 a, u64 b, u64 c, u32 s)
+{
+       unsigned __int128 tmp;
+
+       tmp = (((uint128_t)a) * b) + c;
+       return (u64) (tmp >> s);
+}
+
+/*
+ * check-name: int128
+ * check-command: test-linearize $file
+ * check-output-ignore
+ *
+ * check-output-contains: ret\\..*\\$16
+ * check-output-contains: mulu\\.128
+ * check-output-contains: add\\.128
+ *
+ * check-error-start
+int128.c:5:18: error: two or more data types in declaration specifiers
+int128.c:5:18: error: Trying to use reserved word 'int' as identifier
+int128.c:5:25: error: Expected ; at end of declaration
+int128.c:5:25: error: got badxi
+int128.c:6:13: error: two or more data types in declaration specifiers
+int128.c:6:13: error: Trying to use reserved word '__int128' as identifier
+int128.c:6:25: error: Expected ; at end of declaration
+int128.c:6:25: error: got badix
+int128.c:7:18: error: impossible combination of type specifiers: unsigned unsigned
+int128.c:7:18: error: Trying to use reserved word 'unsigned' as identifier
+int128.c:7:27: error: Expected ; at end of declaration
+int128.c:7:27: error: got __int128
+int128.c:8:16: error: two or more data types in declaration specifiers
+int128.c:8:16: error: Trying to use reserved word '__int128' as identifier
+int128.c:8:25: error: Expected ; at end of declaration
+int128.c:8:25: error: got baddx
+int128.c:9:18: error: two or more data types in declaration specifiers
+int128.c:9:18: error: Trying to use reserved word 'double' as identifier
+int128.c:9:25: error: Expected ; at end of declaration
+int128.c:9:25: error: got badxd
+ * check-error-end
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] add warning option '-Wtautological-compare' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] add warning option '-Wtautological-compare'
Date: Wed, 07 Dec 2016 16:32:57 +0000
Message-ID: <20161207163257.22287-3-luc.vanoostenryck () gmail ! com>
--------------------
Now that we optimize away expressions like 'x == x' or 'x < x',
also add a warning for it (but disabled by default).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c                             |  2 ++
 lib.h                             |  1 +
 simplify.c                        |  4 ++++
 validation/tautological-compare.c | 35 +++++++++++++++++++++++++++++++++++
 4 files changed, 42 insertions(+)
 create mode 100644 validation/tautological-compare.c

diff --git a/lib.c b/lib.c
index e5b0bb63..6b7a0817 100644
--- a/lib.c
+++ b/lib.c
@@ -236,6 +236,7 @@ int Wptr_subtraction_blows = 0;
 int Wreturn_void = 0;
 int Wshadow = 0;
 int Wsizeof_bool = 0;
+int Wtautological_compare = 0;
 int Wtransparent_union = 0;
 int Wtypesign = 0;
 int Wundef = 0;
@@ -471,6 +472,7 @@ static const struct warning {
 	{ "return-void", &Wreturn_void },
 	{ "shadow", &Wshadow },
 	{ "sizeof-bool", &Wsizeof_bool },
+	{ "tautological-compare", &Wtautological_compare },
 	{ "transparent-union", &Wtransparent_union },
 	{ "typesign", &Wtypesign },
 	{ "undef", &Wundef },
diff --git a/lib.h b/lib.h
index 15b69fa2..130e5b6c 100644
--- a/lib.h
+++ b/lib.h
@@ -122,6 +122,7 @@ extern int Wptr_subtraction_blows;
 extern int Wreturn_void;
 extern int Wshadow;
 extern int Wsizeof_bool;
+extern int Wtautological_compare;
 extern int Wtransparent_union;
 extern int Wtypesign;
 extern int Wundef;
diff --git a/simplify.c b/simplify.c
index fde72f0a..b29b3ebb 100644
--- a/simplify.c
+++ b/simplify.c
@@ -494,6 +494,8 @@ static int simplify_binop_same_args(struct instruction *insn, pseudo_t arg)
 	case OP_SET_NE:
 	case OP_SET_LT: case OP_SET_GT:
 	case OP_SET_B:  case OP_SET_A:
+		if (Wtautological_compare)
+			warning(insn->pos, "self-comparison always evaluates to false");
 	case OP_SUB:
 	case OP_XOR:
 		return replace_with_pseudo(insn, value_pseudo(0));
@@ -501,6 +503,8 @@ static int simplify_binop_same_args(struct instruction *insn, pseudo_t arg)
 	case OP_SET_EQ:
 	case OP_SET_LE: case OP_SET_GE:
 	case OP_SET_BE: case OP_SET_AE:
+		if (Wtautological_compare)
+			warning(insn->pos, "self-comparison always evaluates to true");
 		return replace_with_pseudo(insn, value_pseudo(1));
 
 	case OP_AND:
diff --git a/validation/tautological-compare.c b/validation/tautological-compare.c
new file mode 100644
index 00000000..55a2b463
--- /dev/null
+++ b/validation/tautological-compare.c
@@ -0,0 +1,35 @@
+typedef unsigned int u32;
+
+int seq(int a) { return a == a; }
+int sne(int a) { return a != a; }
+int slt(int a) { return a < a; }
+int sgt(int a) { return a > a; }
+int sle(int a) { return a <= a; }
+int sge(int a) { return a >= a; }
+
+u32 ueq(u32 a) { return a == a; }
+u32 une(u32 a) { return a != a; }
+u32 ult(u32 a) { return a < a; }
+u32 ugt(u32 a) { return a > a; }
+u32 ule(u32 a) { return a <= a; }
+u32 uge(u32 a) { return a >= a; }
+
+/*
+ * check-name: tautological-compare
+ * check-command: sparse -Wno-decl -Wtautological-compare $file
+ *
+ * check-error-start
+tautological-compare.c:3:30: warning: self-comparison always evaluates to true
+tautological-compare.c:4:30: warning: self-comparison always evaluates to false
+tautological-compare.c:5:29: warning: self-comparison always evaluates to false
+tautological-compare.c:6:29: warning: self-comparison always evaluates to false
+tautological-compare.c:7:30: warning: self-comparison always evaluates to true
+tautological-compare.c:8:30: warning: self-comparison always evaluates to true
+tautological-compare.c:10:30: warning: self-comparison always evaluates to true
+tautological-compare.c:11:30: warning: self-comparison always evaluates to false
+tautological-compare.c:12:29: warning: self-comparison always evaluates to false
+tautological-compare.c:13:29: warning: self-comparison always evaluates to false
+tautological-compare.c:14:30: warning: self-comparison always evaluates to true
+tautological-compare.c:15:30: warning: self-comparison always evaluates to true
+ * check-error-end
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] mark lists to be repacked as dirty ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] mark lists to be repacked as dirty
Date: Thu, 17 Nov 2016 17:25:59 +0000
Message-ID: <20161117172559.29417-3-luc.vanoostenryck () gmail ! com>
--------------------
Use a bit in the head of a ptrlist and set it when
DELETE_PTR() is called.
Check the bit when repacking a list and do nothing if the
bit is not set.

Note: delete_ptr_list_entry() & delete_ptr_list_last()
don't need any handling because they either always call
pack_ptr_list() or remove the last block when it becomes empty.

Suggested-by: Christopher Li <sparse@chrisli.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 ptrlist.c | 7 +++++++
 ptrlist.h | 4 +++-
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/ptrlist.c b/ptrlist.c
index 5dc1117c..e817bad1 100644
--- a/ptrlist.c
+++ b/ptrlist.c
@@ -70,6 +70,11 @@ void pack_ptr_list(struct ptr_list **listp)
 
 	if (head) {
 		struct ptr_list *entry = head;
+
+		if (!head->dirty)
+			return;
+		head->dirty = 0;
+
 		do {
 			struct ptr_list *next;
 restart:
@@ -138,6 +143,7 @@ void **__add_ptr_list(struct ptr_list **listp, void *ptr, unsigned long tag)
 			list->prev = newlist;
 			last->next = newlist;
 		}
+		newlist->dirty = 0;
 		last = newlist;
 		nr = 0;
 	}
@@ -188,6 +194,7 @@ void * undo_ptr_list_last(struct ptr_list **head)
 
 	if (!first)
 		return NULL;
+	first->dirty = 1;
 	last = first;
 	do {
 		last = last->prev;
diff --git a/ptrlist.h b/ptrlist.h
index 61e159fd..c24bfb82 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -25,7 +25,8 @@
 #define LIST_NODE_NR (29)
 
 struct ptr_list {
-	int nr;
+	int nr:31;
+	unsigned int dirty:1;		// will need to be repacked
 	struct ptr_list *prev;
 	struct ptr_list *next;
 	void *list[LIST_NODE_NR];
@@ -254,6 +255,7 @@ extern void split_ptr_list_head(struct ptr_list *);
 		__this++;								\
 	}										\
 	*__this = (void *)0xf0f0f0f0;							\
+	__head->dirty = 1;								\
 	__list->nr--; __nr--;								\
 } while (0)
 
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] testsuite: add a script to normalize label names ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] testsuite: add a script to normalize label names
Date: Mon, 21 Nov 2016 04:14:21 +0000
Message-ID: <20161121041421.34576-3-luc.vanoostenryck () gmail ! com>
--------------------
test-linearize displays basic block's labels by using
'.L0x' + plus the address of the bb struct. This is certainly
convenient as an UID but it has the disadvantage that these
labels names are not comparable between runs.

This complicate testing quite a bit.

This script more or less solve this by filtering the output of
test-linearize and change these names to some nice sequential
and comparable '.L1', '.L2', ...

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/normalize-bb        | 16 ++++++++++++++++
 validation/test-normalize-bb.c | 31 +++++++++++++++++++++++++++++++
 2 files changed, 47 insertions(+)
 create mode 100755 validation/normalize-bb
 create mode 100644 validation/test-normalize-bb.c

diff --git a/validation/normalize-bb b/validation/normalize-bb
new file mode 100755
index 00000000..a7c7b73b
--- /dev/null
+++ b/validation/normalize-bb
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+out=$(mktemp)
+sed=$(mktemp)
+
+n=0
+tee $out | grep '^\.L0x' | sort -u | \
+	sed 's/\(.L0x[0-9a-f]*\).*/\1/'	| \
+	while read l; do
+		n=$(($n + 1))
+		echo "s/$l/.L$n/"
+	done > $sed
+
+cat $out | sed -f $sed
+
+rm -f $out $sed
diff --git a/validation/test-normalize-bb.c b/validation/test-normalize-bb.c
new file mode 100644
index 00000000..57a5886e
--- /dev/null
+++ b/validation/test-normalize-bb.c
@@ -0,0 +1,31 @@
+/*
+ * test the normalization of basic block's names
+ */
+
+void use(int);
+void foo(int p);
+void foo(int p)
+{
+	if (p)
+		use(1);
+}
+
+/*
+ * check-name: test-normalize-bb
+ * check-command: test-linearize $file | ./normalize-bb
+ * check-output-start
+foo:
+.L1:
+	<entry-point>
+	br          %arg1, .L2, .L3
+
+.L2:
+	call        use, $1
+	br          .L3
+
+.L3:
+	ret
+
+
+ * check-output-end
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] validation: Check C99 for loop variables ===

From: Emily Maier <emily () emilymaier ! net>
To: linux-sparse
Subject: [PATCH 2/2] validation: Check C99 for loop variables
Date: Wed, 04 May 2016 12:39:44 +0000
Message-ID: <1462365584-20536-2-git-send-email-emily () emilymaier ! net>
--------------------
Previously, sparse would generate incorrect code in the presence of a
C99 variable declaration inside the for statement, completely dropping
the code after the end of the for loop. Check that it's now behaving
correctly by entering a context and not leaving it at the end of the
loop.

Signed-off-by: Emily Maier <emily@emilymaier.net>
---
 validation/c99-for-loop.c | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)
 create mode 100644 validation/c99-for-loop.c

diff --git a/validation/c99-for-loop.c b/validation/c99-for-loop.c
new file mode 100644
index 0000000..42246c5
--- /dev/null
+++ b/validation/c99-for-loop.c
@@ -0,0 +1,33 @@
+int op(int);
+
+static int good(void)
+{
+	__context__(1);
+	for (int i = 0; i < 10; i++) {
+		if (!op(i)) {
+			__context__(-1);
+			return 0;
+		}
+	}
+	__context__(-1);
+	return 1;
+}
+
+static int bad(void)
+{
+	__context__(1);
+	for (int i = 0; i < 10; i++) {
+		if (!op(i)) {
+			__context__(-1);
+			return 0;
+		}
+	}
+	return 1;
+}
+/*
+ * check-name: C99 for loop variable declaration
+ *
+ * check-error-start
+c99-for-loop.c:16:12: warning: context imbalance in 'bad' - different lock contexts for basic block
+ * check-error-end
+ */
-- 
2.5.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] simplify comparisons followed by an equality test against 0 or 1 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] simplify comparisons followed by an equality test against 0 or 1
Date: Sun, 11 Dec 2016 21:13:27 +0000
Message-ID: <20161211211328.26735-3-luc.vanoostenryck () gmail ! com>
--------------------
Expressions involving equality testing against zero are ubiquitious
and can often be simplified with previous comparisons.

For example, when using test-linearize on the following code:
	_Bool foo(int a) { return !(a < 3); }
the following was emitted:
	setlt.32    %r2 <- %arg1, $3
	seteq.32    %r3 <- %r2, $0
	setne.1     %r4 <- %r3, $0
	ret.1       %r4

but this can be simplified into:
	setge.1     %r4 <- %arg1, $3
	ret.1       %r4

Implement this simplification and add associated test cases.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                     | 65 ++++++++++++++++++++++++++++++++++++++++++
 validation/optim/setcc-setcc.c | 19 ++++++++++++
 validation/optim/setcc-seteq.c | 13 +++++++++
 validation/optim/setcc-setne.c | 13 +++++++++
 4 files changed, 110 insertions(+)
 create mode 100644 validation/optim/setcc-setcc.c
 create mode 100644 validation/optim/setcc-seteq.c
 create mode 100644 validation/optim/setcc-setne.c

diff --git a/simplify.c b/simplify.c
index b29b3ebb..d076ebb5 100644
--- a/simplify.c
+++ b/simplify.c
@@ -310,6 +310,67 @@ static int simplify_asr(struct instruction *insn, pseudo_t pseudo, long long val
 	return 0;
 }
 
+static int compare_opcode(int opcode, int inverse)
+{
+	if (!inverse)
+		return opcode;
+
+	switch (opcode) {
+	case OP_SET_EQ:	return OP_SET_NE;
+	case OP_SET_NE:	return OP_SET_EQ;
+
+	case OP_SET_LT:	return OP_SET_GE;
+	case OP_SET_LE:	return OP_SET_GT;
+	case OP_SET_GT:	return OP_SET_LE;
+	case OP_SET_GE:	return OP_SET_LT;
+
+	case OP_SET_A:	return OP_SET_BE;
+	case OP_SET_AE:	return OP_SET_B;
+	case OP_SET_B:	return OP_SET_AE;
+	case OP_SET_BE:	return OP_SET_A;
+
+	default:
+		return opcode;
+	}
+}
+
+static int simplify_seteq_setne(struct instruction *insn, long long value)
+{
+	struct instruction *def = insn->src1->def;
+	pseudo_t src1, src2;
+	int inverse;
+	int opcode;
+
+	if (value != 0 && value != 1)
+		return 0;
+
+	if (!def)
+		return 0;
+
+	inverse = (insn->opcode == OP_SET_NE) == value;
+	opcode = def->opcode;
+	switch (opcode) {
+	case OP_BINCMP ... OP_BINCMP_END:
+		// Convert:
+		//	setcc.n	%t <- %a, %b
+		//	setne.m %r <- %t, $0
+		// into:
+		//	setcc.n	%t <- %a, %b
+		//	setcc.m %r <- %a, $b
+		// and similar for setne/eq ... 0/1
+		src1 = def->src1;
+		src2 = def->src2;
+		remove_usage(insn->src1, &insn->src1);
+		insn->opcode = compare_opcode(opcode, inverse);
+		use_pseudo(insn, src1, &insn->src1);
+		use_pseudo(insn, src2, &insn->src2);
+		return REPEAT_CSE;
+
+	default:
+		return 0;
+	}
+}
+
 static int simplify_constant_rightside(struct instruction *insn)
 {
 	long long value = insn->src2->value;
@@ -342,6 +403,10 @@ static int simplify_constant_rightside(struct instruction *insn)
 		if (!value)
 			return replace_with_pseudo(insn, insn->src2);
 		return 0;
+
+	case OP_SET_NE:
+	case OP_SET_EQ:
+		return simplify_seteq_setne(insn, value);
 	}
 	return 0;
 }
diff --git a/validation/optim/setcc-setcc.c b/validation/optim/setcc-setcc.c
new file mode 100644
index 00000000..fac7520e
--- /dev/null
+++ b/validation/optim/setcc-setcc.c
@@ -0,0 +1,19 @@
+static _Bool blt(int a, int b)	{ return  (a <  b); }
+static _Bool bnge(int a, int b)	{ return !(a >= b); }
+static _Bool bgt(int a, int b)	{ return  (a >  b); }
+static _Bool bnle(int a, int b)	{ return !(a <= b); }
+static _Bool ble(int a, int b)	{ return  (a <= b); }
+static _Bool bngt(int a, int b)	{ return !(a >  b); }
+static _Bool bge(int a, int b)	{ return  (a >= b); }
+static _Bool bnlt(int a, int b)	{ return !(a <  b); }
+
+/*
+ * check-name: optim/setcc-setcc
+ * check-command: test-linearize $file
+ * check-output-ignore
+ *
+ * check-output-excludes: set..\\.32
+ * check-output-excludes: setne\\.1
+ * check-output-excludes: seteq\\.1
+ * check-output-contains: set[gt][te]\\.1
+ */
diff --git a/validation/optim/setcc-seteq.c b/validation/optim/setcc-seteq.c
new file mode 100644
index 00000000..d8765fe1
--- /dev/null
+++ b/validation/optim/setcc-seteq.c
@@ -0,0 +1,13 @@
+static _Bool beq0(int a)	{ return  (a == 0); }
+static _Bool bnotneq0(int a)	{ return !(a != 0); }
+static _Bool bnot(int a)	{ return !a; }
+
+/*
+ * check-name: optim/setcc-seteq
+ * check-command: test-linearize $file
+ * check-output-ignore
+ *
+ * check-output-excludes: set..\\.32
+ * check-output-excludes: setne\\.1
+ * check-output-contains: seteq\\.1
+ */
diff --git a/validation/optim/setcc-setne.c b/validation/optim/setcc-setne.c
new file mode 100644
index 00000000..f982eb34
--- /dev/null
+++ b/validation/optim/setcc-setne.c
@@ -0,0 +1,13 @@
+static _Bool bnoteq0(int a)	{ return !(a == 0); }
+static _Bool bne0(int a)	{ return  (a != 0); }
+static _Bool bnotnot(int a)	{ return !!a; }
+
+/*
+ * check-name: optim/setcc-setne
+ * check-command: test-linearize $file
+ * check-output-ignore
+ *
+ * check-output-excludes: set..\\.32
+ * check-output-excludes: seteq\\.1
+ * check-output-contains: setne\\.1
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/6] testsuite: simplify test function-pointer-inheritance ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/6] testsuite: simplify test function-pointer-inheritance
Date: Thu, 24 Nov 2016 17:09:43 +0000
Message-ID: <20161124170947.14379-3-luc.vanoostenryck () gmail ! com>
--------------------
The function used had so much args that it was hard
to see what's the difference between them.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/function-pointer-modifier-inheritance.c | 13 ++-----------
 1 file changed, 2 insertions(+), 11 deletions(-)

diff --git a/validation/function-pointer-modifier-inheritance.c b/validation/function-pointer-modifier-inheritance.c
index 3428715a..13df6ff7 100644
--- a/validation/function-pointer-modifier-inheritance.c
+++ b/validation/function-pointer-modifier-inheritance.c
@@ -1,15 +1,6 @@
-struct sk_buff;
-struct sock;
+extern int foo(int f(int, void *));
 
-extern int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
-                    int getfrag(void *from, char *to, int offset,
-                    int len,int odd, struct sk_buff *skb),
-                    void *from, int length);
-
-int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
-                    int (*getfrag)(void *from, char *to, int offset,
-                    int len,int odd, struct sk_buff *skb),
-                    void *from, int length)
+int foo(int (*f)(int, void *))
 {
     return 0;
 }
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3 v4] Add Wall_off switch to disable errors and warnings ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 3/3 v4] Add Wall_off switch to disable errors and warnings
Date: Mon, 03 Aug 2015 16:35:59 +0000
Message-ID: <1438619759-14879-1-git-send-email-tcamuso () redhat ! com>
--------------------
Disable all error reporting. Useful when semantic parsing checks are
being done elsewhere or all you need is a tokenizer.

Signed-off-by: Tony Camuso <tcamuso@redhat.com>
---
 lib.c | 27 +++++++++++++++++++++++----
 lib.h |  1 +
 2 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/lib.c b/lib.c
index 8dc5bcf..08f6a6b 100644
--- a/lib.c
+++ b/lib.c
@@ -101,21 +101,26 @@ unsigned int hexval(unsigned int c)
 	return retval;
 }
 
+static int max_warnings = 100;
+static int show_info = 1;
+
 static void do_warn(const char *type, struct position pos, const char * fmt, va_list args)
 {
 	static char buffer[512];
 	const char *name;
 
-	vsprintf(buffer, fmt, args);	
+	if (Wall_off) {
+		max_warnings = 0;
+		return;
+	}
+
+	vsprintf(buffer, fmt, args);
 	name = stream_name(pos.stream);
 		
 	fprintf(stderr, "%s:%d:%d: %s%s\n",
 		name, pos.line, pos.pos, type, buffer);
 }
 
-static int max_warnings = 100;
-static int show_info = 1;
-
 void info(struct position pos, const char * fmt, ...)
 {
 	va_list args;
@@ -130,6 +135,12 @@ void info(struct position pos, const char * fmt, ...)
 static void do_error(struct position pos, const char * fmt, va_list args)
 {
 	static int errors = 0;
+
+	if (Wall_off) {
+		max_warnings = 0;
+		return;
+	}
+
         die_if_error = 1;
 	show_info = 1;
 	/* Shut up warnings after an error */
@@ -241,6 +252,7 @@ int Wtypesign = 0;
 int Wundef = 0;
 int Wuninitialized = 1;
 int Wvla = 1;
+int Wall_off = 0;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
@@ -479,6 +491,13 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
 	char *p = arg + 1;
 	unsigned i;
 
+	if (!strcmp(p, "all_off")) {
+		for (i = 0; i < n; i++)
+			*warnings[i].flag = WARNING_FORCE_OFF;
+		Wall_off = 1;
+		return NULL;
+	}
+
 	if (!strcmp(p, "sparse-all")) {
 		for (i = 0; i < n; i++) {
 			if (*warnings[i].flag != WARNING_FORCE_OFF && warnings[i].flag != &Wsparse_error)
diff --git a/lib.h b/lib.h
index 15b69fa..65e4836 100644
--- a/lib.h
+++ b/lib.h
@@ -127,6 +127,7 @@ extern int Wtypesign;
 extern int Wundef;
 extern int Wuninitialized;
 extern int Wvla;
+extern int Wall_off;
 
 extern int dbg_entry;
 extern int dbg_dead;
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3 v4] Add Wall_off switch to disable errors and warnings
Date: Tue, 05 Jan 2016 01:19:59 +0000
Message-ID: <20160105011958.GA12545 () macpro ! local>
--------------------
On Mon, Aug 03, 2015 at 12:35:59PM -0400, Tony Camuso wrote:
> Disable all error reporting. Useful when semantic parsing checks are
> being done elsewhere or all you need is a tokenizer.
> 
> Signed-off-by: Tony Camuso <tcamuso@redhat.com>
> ---
>  lib.c | 27 +++++++++++++++++++++++----
>  lib.h |  1 +
>  2 files changed, 24 insertions(+), 4 deletions(-)
> 
> diff --git a/lib.c b/lib.c
> index 8dc5bcf..08f6a6b 100644
> --- a/lib.c
> +++ b/lib.c

...

> @@ -130,6 +135,12 @@ void info(struct position pos, const char * fmt, ...)
>  static void do_error(struct position pos, const char * fmt, va_list args)
>  {
>  	static int errors = 0;
> +
> +	if (Wall_off) {
> +		max_warnings = 0;
> +		return;
> +	}
> +

Is this really needed?
The same check in do_warn should be enough to quiet all messages, isn't it?


> @@ -479,6 +491,13 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
>  	char *p = arg + 1;
>  	unsigned i;
>  
> +	if (!strcmp(p, "all_off")) {
> +		for (i = 0; i < n; i++)
> +			*warnings[i].flag = WARNING_FORCE_OFF;
> +		Wall_off = 1;
> +		return NULL;
> +	}
> +

Can't you simply set max_warnings to 0 already here
instead of doing it in do_warn()?

> @@ -127,6 +127,7 @@ extern int Wtypesign;
>  extern int Wundef;
>  extern int Wuninitialized;
>  extern int Wvla;
> +extern int Wall_off;

I think it should be better to use a much more explicit name,
something like "ignore_all_warnings" for example.

Also it would be nice to document this new option in the man page.


Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3 v4] Add Wall_off switch to disable errors and warnings
Date: Wed, 13 Jan 2016 14:39:45 +0000
Message-ID: <569661B1.9030903 () redhat ! com>
--------------------
On 01/04/2016 08:19 PM, Luc Van Oostenryck wrote:
> On Mon, Aug 03, 2015 at 12:35:59PM -0400, Tony Camuso wrote:
>> Disable all error reporting. Useful when semantic parsing checks are
>> being done elsewhere or all you need is a tokenizer.
>>
>> Signed-off-by: Tony Camuso <tcamuso@redhat.com>
>> ---
>>   lib.c | 27 +++++++++++++++++++++++----
>>   lib.h |  1 +
>>   2 files changed, 24 insertions(+), 4 deletions(-)
>>
>> diff --git a/lib.c b/lib.c
>> index 8dc5bcf..08f6a6b 100644
>> --- a/lib.c
>> +++ b/lib.c
>
> ...
>
>> @@ -130,6 +135,12 @@ void info(struct position pos, const char * fmt, ...)
>>   static void do_error(struct position pos, const char * fmt, va_list args)
>>   {
>>   	static int errors = 0;
>> +
>> +	if (Wall_off) {
>> +		max_warnings = 0;
>> +		return;
>> +	}
>> +
>
> Is this really needed?
> The same check in do_warn should be enough to quiet all messages, isn't it?

I'll test again to be certain, but IIRC, I needed it there, too.
If I don't need it there, I will drop it in a new version of the
patch.

>
>> @@ -479,6 +491,13 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
>>   	char *p = arg + 1;
>>   	unsigned i;
>>
>> +	if (!strcmp(p, "all_off")) {
>> +		for (i = 0; i < n; i++)
>> +			*warnings[i].flag = WARNING_FORCE_OFF;
>> +		Wall_off = 1;
>> +		return NULL;
>> +	}
>> +
>
> Can't you simply set max_warnings to 0 already here
> instead of doing it in do_warn()?

Yes, I will do that. It does make more sense in that block.

>> @@ -127,6 +127,7 @@ extern int Wtypesign;
>>   extern int Wundef;
>>   extern int Wuninitialized;
>>   extern int Wvla;
>> +extern int Wall_off;
>
> I think it should be better to use a much more explicit name,
> something like "ignore_all_warnings" for example.

Also will do that.

> Also it would be nice to document this new option in the man page.

I'll add this to the patch.

>
> Regards,
> Luc
>

Ciao,
Tony
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] By default disable '-Wunknown-attribute' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] By default disable '-Wunknown-attribute'
Date: Wed, 02 Nov 2016 21:59:39 +0000
Message-ID: <20161102215939.36765-4-luc.vanoostenryck () gmail ! com>
--------------------
Generally, we won't be interested by the warnings from this flag,
but we can always explicitly ask for them if needed.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c                               | 2 +-
 validation/Wunknown-attribute-def.c | 1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/lib.c b/lib.c
index 138736e7..b4b09a78 100644
--- a/lib.c
+++ b/lib.c
@@ -240,7 +240,7 @@ int Wtransparent_union = 0;
 int Wtypesign = 0;
 int Wundef = 0;
 int Wuninitialized = 1;
-int Wunknown_attribute = 1;
+int Wunknown_attribute = 0;
 int Wvla = 1;
 
 int dbg_entry = 0;
diff --git a/validation/Wunknown-attribute-def.c b/validation/Wunknown-attribute-def.c
index 0c0868d6..defe643d 100644
--- a/validation/Wunknown-attribute-def.c
+++ b/validation/Wunknown-attribute-def.c
@@ -4,6 +4,5 @@ static int foo(void) __attribute__((unknown_attribute));
  * check-name: warn-unknown-attribute
  *
  * check-error-start
-Wunknown-attribute-def.c:1:37: warning: attribute 'unknown_attribute': unknown attribute
  * check-error-end
  */
-- 
2.10.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/3] By default disable '-Wunknown-attribute'
Date: Thu, 17 Nov 2016 16:52:37 +0000
Message-ID: <CANeU7QnpsYS-YwSgqw8tiKO7FUFxjrRbKUoA8bb-gTsjK-YVvA () mail ! gmail ! com>
--------------------
On Thu, Nov 3, 2016 at 5:59 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Generally, we won't be interested by the warnings from this flag,
> but we can always explicitly ask for them if needed.

I don't want to disable it by default. I think default should be on so
that we can collect test case and prepare to add them later one.

I would much rather see a patch to make those attribute parsed
eventually. I think gcc or clang should have a collection of all
the attribute stash some where. I haven't take a closer look myself.

Most of the attribute are trivial to parse correctly. We should have
some thing like empty_int_attribute instead of blindly ignore them.

Also ideally the attribute should be a list instead of member in the
ctype structure. Most of the symbol has at most one attribute any
way. That is a much bigger change though.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3] By default disable '-Wunknown-attribute'
Date: Thu, 17 Nov 2016 18:04:19 +0000
Message-ID: <20161117180418.GB25228 () macpro ! local>
--------------------
On Fri, Nov 18, 2016 at 12:52:37AM +0800, Christopher Li wrote:
> On Thu, Nov 3, 2016 at 5:59 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > Generally, we won't be interested by the warnings from this flag,
> > but we can always explicitly ask for them if needed.
> 
> I don't want to disable it by default. I think default should be on so
> that we can collect test case and prepare to add them later one.
> 
> I would much rather see a patch to make those attribute parsed
> eventually. I think gcc or clang should have a collection of all
> the attribute stash some where. I haven't take a closer look myself.
> 
> Most of the attribute are trivial to parse correctly. We should have
> some thing like empty_int_attribute instead of blindly ignore them.
> 
> Also ideally the attribute should be a list instead of member in the
> ctype structure. Most of the symbol has at most one attribute any
> way. That is a much bigger change though.


I'm not surprised that you don't want to have it disabled by default.
But leaving it on would, in my opinion, miss the point entirely.
Why would sparses *users* be annoyed with warnings that doesn't
concern them? What kind of useful information it gives to them that
sparse doesn't know about this or this new attribute?
Even worse, what the difference for sparse between having this option
disabled by default and just adding yet another attribute to the lists
of known ones (even if it is not in the format of a list)?

I have taken a look at such gcc list before I wrote this serie.
There is a whole bunch of them for exotic uses on exotic architectures
and a more limited number fo them for more common use. But
don't forget that it's also not only the question of the existing
attributes but the fact that each gcc version (and maybe clang) may
add a few new ones and soon or later someone will use them.

Don't take me wrong, if it would make a visible semantic difference
I would be the first to say that such or such attribute need to be
handled correctly. And I think that patches doing the parsing of
some more attributes should be welcomed.
But given what sparse curently do and is used, leaving this option
enabled by default is, in my opinion, useless and just annoyance for
its users.

Also, I don't exagerate too much by saying that during the last 2 years
or so there has been almost as much patches for these new attributes
than anything else. It's a bit ridiculous.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/5] testsuite: report as error tests known to fail but which succeed ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/5] testsuite: report as error tests known to fail but which succeed
Date: Wed, 02 Nov 2016 21:45:07 +0000
Message-ID: <20161102214509.36571-4-luc.vanoostenryck () gmail ! com>
--------------------
Such situation may simply show that what was tested is now fixed
and that it's juste the test annotation which need to be adapted,
but can be a sign that something else is broken.

Reporting the exact result (failure/success, known-to-fail/expect-to-succeed)
make the testsuite more useful and allow to use more efficiently
git-bisect or other automated testing tools.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/validation/test-suite b/validation/test-suite
index df5a7c60..03421a24 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -161,15 +161,26 @@ do_test()
 		test_failed=1
 	fi
 
+	get_tag "check-known-to-fail" $file
+	if [ "$?" -eq "0" ]; then
+		must_fail=1
+		known_ko_tests=`expr $known_ko_tests + 1`
+	else
+		must_fail=0
+	fi
+
 	if [ "$test_failed" -eq "1" ]; then
 		ko_tests=`expr $ko_tests + 1`
-		get_tag "check-known-to-fail" $file
-		if [ "$?" -eq "0" ]; then
+		if [ "$must_fail" -eq "1" ]; then
 			echo "info: test '$file' is known to fail"
-			known_ko_tests=`expr $known_ko_tests + 1`
 		fi
 		return 1
 	else
+		if [ "$must_fail" -eq "1" ]; then
+			echo "info: test '$file' is known to fail but succeed!"
+			ko_tests=`expr $ko_tests + 1`
+			return 1
+		fi
 		ok_tests=`expr $ok_tests + 1`
 		return 0
 	fi
-- 
2.10.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/5] testsuite: report as error tests known to fail but which succeed
Date: Thu, 17 Nov 2016 16:13:58 +0000
Message-ID: <CANeU7QnHYuW7-h+wKFcQZe=6xNUZgNdSAtLnqdAm=OBNARvR-Q () mail ! gmail ! com>
--------------------
--001a113f732a192b460541817a74
Content-Type: text/plain; charset=UTF-8

On Thu, Nov 3, 2016 at 5:45 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Such situation may simply show that what was tested is now fixed
> and that it's juste the test annotation which need to be adapted,
> but can be a sign that something else is broken.
>
> Reporting the exact result (failure/success, known-to-fail/expect-to-succeed)
> make the testsuite more useful and allow to use more efficiently
> git-bisect or other automated testing tools.

I like what you are doing as a result.

But I think the implementation has room to improve.
I don't like deep and messy "else" statement.

I attach a patch which I modify base on yours. I hope it is
easier to read. Care to review it?

Chris

--001a113f732a192b460541817a74
Content-Type: text/x-patch; charset=US-ASCII; name="known-to-fail.patch"
Content-Disposition: attachment; filename="known-to-fail.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_ivmjxzll0

LS0tIC5wYy85NDA5OTE5LTMtNS10ZXN0c3VpdGUtcmVwb3J0LWFzLWVycm9yLXRlc3RzLWtub3du
LXRvLWZhaWwtYnV0LXdoaWNoLXN1Y2NlZWQucGF0Y2gvdmFsaWRhdGlvbi90ZXN0LXN1aXRlCTIw
MTYtMTAtMjQgMTc6Mzc6MjkuMzAzODQ2MDAwICswODAwCisrKyB2YWxpZGF0aW9uL3Rlc3Qtc3Vp
dGUJMjAxNi0xMS0xNyAyMzo1NjozNS40MDQzOTI0NTQgKzA4MDAKQEAgLTE2MSwxOCArMTYxLDI1
IEBAIGRvX3Rlc3QoKQogCQl0ZXN0X2ZhaWxlZD0xCiAJZmkKIAotCWlmIFsgIiR0ZXN0X2ZhaWxl
ZCIgLWVxICIxIiBdOyB0aGVuCi0JCWtvX3Rlc3RzPWBleHByICRrb190ZXN0cyArIDFgCi0JCWdl
dF90YWcgImNoZWNrLWtub3duLXRvLWZhaWwiICRmaWxlCi0JCWlmIFsgIiQ/IiAtZXEgIjAiIF07
IHRoZW4KKwlnZXRfdGFnICJjaGVjay1rbm93bi10by1mYWlsIiAkZmlsZQorCW11c3RfZmFpbD1g
ZXhwciAiJD8iID0gMGAKKwlrbm93bl9rb190ZXN0cz1gZXhwciAka25vd25fa29fdGVzdHMgKyAk
bXVzdF9mYWlsYAorCisJaWYgWyAiJG11c3RfZmFpbCIgLWVxICIxIiBdOyB0aGVuCisJCWlmIFsg
IiR0ZXN0X2ZhaWxlZCIgLWVxICIxIiBdOyB0aGVuCiAJCQllY2hvICJpbmZvOiB0ZXN0ICckZmls
ZScgaXMga25vd24gdG8gZmFpbCIKLQkJCWtub3duX2tvX3Rlc3RzPWBleHByICRrbm93bl9rb190
ZXN0cyArIDFgCisJCWVsc2UKKwkJCWVjaG8gImluZm86IHRlc3QgJyRmaWxlJyBpcyBrbm93biB0
byBmYWlsIGJ1dCBzdWNjZWVkISIKKwkJCXRlc3RfZmFpbGVkPTEKIAkJZmkKLQkJcmV0dXJuIDEK
KwlmaQorCisJaWYgWyAiJHRlc3RfZmFpbGVkIiAtZXEgIjEiIF07IHRoZW4KKwkJa29fdGVzdHM9
YGV4cHIgJGtvX3Rlc3RzICsgMWAKIAllbHNlCiAJCW9rX3Rlc3RzPWBleHByICRva190ZXN0cyAr
IDFgCi0JCXJldHVybiAwCiAJZmkKKwlyZXR1cm4gJHRlc3RfZmFpbGVkCiB9CiAKIGRvX3Rlc3Rf
c3VpdGUoKQo=
--001a113f732a192b460541817a74--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 3/5] testsuite: report as error tests known to fail but which succeed
Date: Fri, 18 Nov 2016 12:52:51 +0000
Message-ID: <20161118125251.GA17412 () macpro ! local>
--------------------
On Fri, Nov 18, 2016 at 12:13:58AM +0800, Christopher Li wrote:
> On Thu, Nov 3, 2016 at 5:45 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > Such situation may simply show that what was tested is now fixed
> > and that it's juste the test annotation which need to be adapted,
> > but can be a sign that something else is broken.
> >
> > Reporting the exact result (failure/success, known-to-fail/expect-to-succeed)
> > make the testsuite more useful and allow to use more efficiently
> > git-bisect or other automated testing tools.
> 
> I like what you are doing as a result.
> 
> But I think the implementation has room to improve.
> I don't like deep and messy "else" statement.
> 
> I attach a patch which I modify base on yours. I hope it is
> easier to read. Care to review it?

Yes, I much prefer like this. Thanks.

But there is something I would like to check but I can't do that now.
I'll come back on it later.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/5] testsuite: report as error tests known to fail but which succeed
Date: Sun, 20 Nov 2016 01:43:17 +0000
Message-ID: <CANeU7Qk8J5wft5-7ePR=ZcvQPexRrv6qTOUrPOixaJVFwU1dqA () mail ! gmail ! com>
--------------------
On Sat, Nov 19, 2016 at 8:44 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Like I said I prefer your version, but could you add the following patch
> on top of yours?

So you want a return code from test-suit if the test-suit does not
run as expected.

Applied and squashed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/6] use a shorter name for function-pointer-modifier-inheritance.c ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/6] use a shorter name for function-pointer-modifier-inheritance.c
Date: Thu, 24 Nov 2016 17:09:44 +0000
Message-ID: <20161124170947.14379-4-luc.vanoostenryck () gmail ! com>
--------------------
The test file name is a bit longish which is annoying in test reports.
Rename it to simply 'function-pointer-inheritance.c'

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 ...on-pointer-modifier-inheritance.c => function-pointer-inheritance.c} | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
 rename validation/{function-pointer-modifier-inheritance.c => function-pointer-inheritance.c} (63%)

diff --git a/validation/function-pointer-modifier-inheritance.c b/validation/function-pointer-inheritance.c
similarity index 63%
rename from validation/function-pointer-modifier-inheritance.c
rename to validation/function-pointer-inheritance.c
index 13df6ff7..0b24e458 100644
--- a/validation/function-pointer-modifier-inheritance.c
+++ b/validation/function-pointer-inheritance.c
@@ -5,5 +5,5 @@ int foo(int (*f)(int, void *))
     return 0;
 }
 /*
- * check-name: Function pointer modifier inheritance
+ * check-name: Function pointer inheritance
  */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/6] testsuite: test modifiers preserved by 'typeof()' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/6] testsuite: test modifiers preserved by 'typeof()'
Date: Thu, 24 Nov 2016 17:09:46 +0000
Message-ID: <20161124170947.14379-6-luc.vanoostenryck () gmail ! com>
--------------------
Note: address space, 'safe' & 'noderef' have their own test file
because they have others issues or need to be handled differently.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/typeof-addresspace.c |  20 ++++++++
 validation/typeof-mods.c        | 109 ++++++++++++++++++++++++++++++++++++++++
 validation/typeof-noderef.c     |  19 +++++++
 validation/typeof-safe.c        |  23 +++++++++
 4 files changed, 171 insertions(+)
 create mode 100644 validation/typeof-addresspace.c
 create mode 100644 validation/typeof-mods.c
 create mode 100644 validation/typeof-noderef.c
 create mode 100644 validation/typeof-safe.c

diff --git a/validation/typeof-addresspace.c b/validation/typeof-addresspace.c
new file mode 100644
index 00000000..a94f77a3
--- /dev/null
+++ b/validation/typeof-addresspace.c
@@ -0,0 +1,20 @@
+#define	__as		__attribute__((address_space(1)))
+
+static void test_as(void)
+{
+	int __as obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;	/* check-should-pass */
+	typeof(obj) *ptr4 = ptr;	/* check-should-pass */
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+/*
+ * check-name: typeof-addresspace.c
+ * check-known-to-fail
+ */
diff --git a/validation/typeof-mods.c b/validation/typeof-mods.c
new file mode 100644
index 00000000..8c98ab8c
--- /dev/null
+++ b/validation/typeof-mods.c
@@ -0,0 +1,109 @@
+#define	__noderef	__attribute__((noderef))
+#define	__bitwise	__attribute__((bitwise))
+#define	__nocast	__attribute__((nocast))
+#define	__safe		__attribute__((safe))
+
+static void test_spec(void)
+{
+	unsigned int obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+static void test_const(void)
+{
+	const int obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	ptr = ptr;
+	ptr = &obj;
+}
+
+static void test_volatile(void)
+{
+	volatile int obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+static void test_bitwise(void)
+{
+	typedef int __bitwise type_t;
+	type_t obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+static void test_static(void)
+{
+	static int obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+static void test_tls(void)
+{
+	__thread int obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+static void test_nocast(void)
+{
+	int __nocast obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+/*
+ * check-name: typeof-mods
+ * check-known-to-fail
+ *
+ * check-error-start
+ * check-error-end
+ */
diff --git a/validation/typeof-noderef.c b/validation/typeof-noderef.c
new file mode 100644
index 00000000..e95a53ad
--- /dev/null
+++ b/validation/typeof-noderef.c
@@ -0,0 +1,19 @@
+#define	__noderef	__attribute__((noderef))
+
+static void test_noderef(void)
+{
+	int __noderef obj, *ptr;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	ptr = ptr;
+	ptr = &obj;
+}
+
+/*
+ * check-name: typeof-noderef
+ * check-known-to-fail
+ *
+ * check-error-start
+ * check-error-end
+ */
diff --git a/validation/typeof-safe.c b/validation/typeof-safe.c
new file mode 100644
index 00000000..614863fb
--- /dev/null
+++ b/validation/typeof-safe.c
@@ -0,0 +1,23 @@
+#define	__safe		__attribute__((safe))
+
+static void test_safe(void)
+{
+	int __safe obj, *ptr;
+	typeof(obj) var = obj;
+	typeof(ptr) ptr2 = ptr;
+	typeof(*ptr) var2 = obj;
+	typeof(*ptr) *ptr3 = ptr;
+	typeof(obj) *ptr4 = ptr;
+	obj = obj;
+	ptr = ptr;
+	ptr = &obj;
+	obj = *ptr;
+}
+
+/*
+ * check-name: typeof-safe
+ * check-known-to-fail
+ *
+ * check-error-start
+ * check-error-end
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/6] [RFC] some modifiers need to be preserved by 'typeof()' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 6/6] [RFC] some modifiers need to be preserved by 'typeof()'
Date: Thu, 24 Nov 2016 17:09:47 +0000
Message-ID: <20161124170947.14379-7-luc.vanoostenryck () gmail ! com>
--------------------
Currently when we use typeof() all the modifiers from the source
type are ignored and thus not present in the resulting type.

This give all sort of problems. One simple example is:
	const int obj;
	typeof(obj) *ptr;
	*ptr = 0;

We can expect that 'ptr' will have the type 'const int *' and thus
that sparse will warn on the assignment in the last line but it's
not case because 'ptr' has in fact the type 'int *'.

The patch fix this by preserving some of the modifiers when using
typeof().

WARNING: it may be that the old behaviour was so more or less on
  purpose as it provide a way to remove some modifiers by casting
  while still being able to use generic macros. For exmaple, it
  was possible to write the following macro:
	#define noconst(x) (typeof(x))
  and use 'noconst()' as a cast to remove 'const' from types.
  Of course, the problem with this macros is that it remove
  *all* modifiers, not only 'const'.
  With the patch, it won't be possible anymore to do this sort of
  things, which maybe is fine for 'const' but it's why MOD_NOREFREF
  is still dropped as it create problems in the Linew kernel, for example
  in the macro to convert back a percpu variable into a plain one.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c                 | 8 ++++++--
 symbol.h                 | 2 ++
 validation/typeof-mods.c | 1 -
 3 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/symbol.c b/symbol.c
index 92a7a625..a65ad17b 100644
--- a/symbol.c
+++ b/symbol.c
@@ -466,12 +466,16 @@ struct symbol *examine_symbol_type(struct symbol * sym)
 	case SYM_TYPEOF: {
 		struct symbol *base = evaluate_expression(sym->initializer);
 		if (base) {
+			unsigned long mod = 0;
+
 			if (is_bitfield_type(base))
 				warning(base->pos, "typeof applied to bitfield type");
-			if (base->type == SYM_NODE)
+			if (base->type == SYM_NODE) {
+				mod |= base->ctype.modifiers & MOD_TYPEOF;
 				base = base->ctype.base_type;
+			}
 			sym->type = SYM_NODE;
-			sym->ctype.modifiers = 0;
+			sym->ctype.modifiers = mod;
 			sym->ctype.base_type = base;
 			return examine_node_type(sym);
 		}
diff --git a/symbol.h b/symbol.h
index afc4e232..51be81fb 100644
--- a/symbol.h
+++ b/symbol.h
@@ -248,6 +248,8 @@ struct symbol {
 #define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
 	MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
 #define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_NORETURN | MOD_NOCAST)
+/* modifiers preserved by typeof() operator */
+#define MOD_TYPEOF	(MOD_VOLATILE | MOD_CONST | MOD_NOCAST | MOD_SPECIFIER)
 
 
 /* Current parsing/evaluation function */
diff --git a/validation/typeof-mods.c b/validation/typeof-mods.c
index 8c98ab8c..9822e96f 100644
--- a/validation/typeof-mods.c
+++ b/validation/typeof-mods.c
@@ -102,7 +102,6 @@ static void test_nocast(void)
 
 /*
  * check-name: typeof-mods
- * check-known-to-fail
  *
  * check-error-start
  * check-error-end
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 00/13] improve constexpr handling ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Mon, 11 Jan 2016 17:46:35 +0000
Message-ID: <20160111174634.GB2972 () macpro ! local>
--------------------
On Sat, Jan 09, 2016 at 11:05:21PM +0100, Nicolai Stange wrote:
> Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:
> 
> > On Wed, Jul 22, 2015 at 05:37:57PM -0700, josh@joshtriplett.org wrote:
> >> [Side note: for some reason, your mail had your message ordered *after*
> >> your attached diff, so replies quote the diff before the message.]
> >> 
> >> On Thu, Jul 23, 2015 at 12:54:25AM +0200, Nicolai Stange wrote:
> >> > My initial intent was to rework the current integer constant expression
> >> > handling in order to allow for the recognition of constant subexpressions
> >> > built up by means of __builtin_choose_expr(). Hence the first part.
> >> > 
> >> > However, since I had to touch the whole constant expression handling
> >> > code anyways, I decided to experimentally extend it to support
> >> > arithmetic constant expressions and address constants as well. Hence
> >> > the second part.
> >> > 
> >> > Since the additional information on expressions obtained through the
> >> > first two parts is rather pointless without making any use of it, I
> >> > implemented part three, the checking of static storage duration
> >> > objects' initializers for constness.
> >> > This part is the reason why there is a 'RFC' tag in the subject.
> >> > It is up to you to decide whether letting sparse check for C99
> >> > conformity is a valuable thing to have or whether being stricter than
> >> > GCC is counter-productive/completely idiotic.
> >> 
> >> I think it's absolutely a valuable thing to have.  It may or may not be
> >> the right *default* behavior, but having an appropriate -W option to
> >> enable it would be a good start.
> >> 
> >> I've seen kernel maintainers ask people to not rely on GCC's lax
> >> enforcement of constant initializers.
> >
> > I also think it's a very valuable thing to have.
> > After all, it's the raison d'etre of sparse to make stricter checks
> > than the standard or GCC.
> 
> First of all, thank you very much for your review, Luc!

I'm glad to help to make things move on.
 
> >
> > But then I wonder what's must be done for things like GCC's builtins?
> > Shouldn't, for example, __builtin_bswap32(..) always propagte the constantness
> > of it's argument or it specifically this sort of things that are the target of
> > this patch serie?
> 
> Hmm. I guess it depends on the particular __builtin_*() thingie at hand.
> In general, unless explicitly documented, I personally would neither
> assume consistent constness rules nor that those are stable across GCC
> releases and architectures.

Yes, indeed.
 
> In the case of __builtin_bswap32(..), the kernel seems to follow that line
> of reasoning: for example in include/uapi/linux/swab.h, we have
> 
>   #define __swab32(x)                             \
>           (__builtin_constant_p((__u32)(x)) ?     \
>           ___constant_swab32(x) :                 \
>           __fswab32(x))
> 
> where __fswap32(..) is essentially just a wrapper around
> __builtin_bswap32(..).
> 
> 
> But of course, if one decides that some __builtin_foo(<constexpr>) is a
> constexpr again, we would have to teach it sparse explicitly. AFAICS,
> this is nothing new introduced by this patch series though.

Yes, sure. I was wondering if it is wanted or not to do so.


Yours,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 01/13] expression: introduce additional expression constness tracking flags ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 01/13] expression: introduce additional expression constness tracking flags
Date: Wed, 22 Jul 2015 23:11:36 +0000
Message-ID: <87r3nzkct3.fsf () gmail ! com>
--------------------
Prepare for a more fine-grained tracking of expression constness in the
sense of C99 [6.4.4, 6.6].

User-visible behaviour remains unchanged.

The current implementation tags an expression with either combination
of the flags Int_const_expr and Float_literal, the latter being only
used to tell that
  (int).0
is indeed an integer constant expression.

Even if sparse attempted to verify that initializers for static storage
duration objects are constant expressions [6.7.8(4)] (which it
currently does not), it could not tell reliably.
Examples:
1.)
  static float a = { (float)0 }; /* allowed by C99 */
  '(float)0' is not an integer constant expression, but an arithmetic
  one.
2.)
  enum { b = 0 };
  static void *c = { (void*)b }; /* disallowed by C99 */
  References to enum members are not allowed in address constants
  [6.6(9)] and thus, the initializer is not a constant expression at
  all.

Introduce a broader set of constness tracking flags, resembling the
four types of constants [6.4.4] (integer, floating, enumeration,
character) and the three types of constant expressions [6.6] (integer,
arithmetic, address). Use helper functions to consistently set and
clear these flags as they are not completely independent.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c   |  69 ++++++++++++++++++-------------
 expand.c     |   2 +-
 expression.c |  66 ++++++++++++++++++-----------
 expression.h | 133 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 4 files changed, 212 insertions(+), 58 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 035e448..7324fb4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -400,7 +400,7 @@ static struct symbol *bad_expr_type(struct expression *expr)
 		break;
 	}
 
-	expr->flags = 0;
+	expr->flags = EXPR_FLAG_NONE;
 	return expr->ctype = &bad_ctype;
 }
 
@@ -880,8 +880,9 @@ static struct symbol *evaluate_logical(struct expression *expr)
 	/* the result is int [6.5.13(3), 6.5.14(3)] */
 	expr->ctype = &int_ctype;
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 	return &int_ctype;
 }
@@ -894,8 +895,9 @@ static struct symbol *evaluate_binop(struct expression *expr)
 	int op = expr->op;
 
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	/* number op number */
@@ -986,7 +988,7 @@ static inline int is_null_pointer_constant(struct expression *e)
 {
 	if (e->ctype == &null_ctype)
 		return 1;
-	if (!(e->flags & Int_const_expr))
+	if (!(e->flags & EXPR_FLAG_INT_CONST_EXPR))
 		return 0;
 	return is_zero_constant(e) ? 2 : 0;
 }
@@ -1001,8 +1003,9 @@ static struct symbol *evaluate_compare(struct expression *expr)
 	const char *typediff;
 
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	/* Type types? */
@@ -1120,10 +1123,11 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	}
 
 	if (expr->flags) {
-		int flags = expr->conditional->flags & Int_const_expr;
+		int flags = (expr->conditional->flags &
+			expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR));
 		flags &= (*true)->flags & expr->cond_false->flags;
 		if (!flags)
-			expr->flags = 0;
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	lclass = classify_type(ltype, &ltype);
@@ -1681,7 +1685,7 @@ static struct symbol *evaluate_addressof(struct expression *expr)
 	}
 	ctype = op->ctype;
 	*expr = *op->unop;
-	expr->flags = 0;
+	expr->flags = EXPR_FLAG_NONE;
 
 	if (expr->type == EXPR_SYMBOL) {
 		struct symbol *sym = expr->symbol;
@@ -1709,7 +1713,7 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 	/* Simplify: *&(expr) => (expr) */
 	if (op->type == EXPR_PREOP && op->op == '&') {
 		*expr = *op->unop;
-		expr->flags = 0;
+		expr->flags = EXPR_FLAG_NONE;
 		return expr->ctype;
 	}
 
@@ -1799,8 +1803,8 @@ static struct symbol *evaluate_sign(struct expression *expr)
 {
 	struct symbol *ctype = expr->unop->ctype;
 	int class = classify_type(ctype, &ctype);
-	if (expr->flags && !(expr->unop->flags & Int_const_expr))
-		expr->flags = 0;
+	if (expr->flags && !(expr->unop->flags & EXPR_FLAG_INT_CONST_EXPR))
+		expr->flags = EXPR_FLAG_NONE;
 	/* should be an arithmetic type */
 	if (!(class & TYPE_NUM))
 		return bad_expr_type(expr);
@@ -1854,8 +1858,9 @@ static struct symbol *evaluate_preop(struct expression *expr)
 		return evaluate_postop(expr);
 
 	case '!':
-		if (expr->flags && !(expr->unop->flags & Int_const_expr))
-			expr->flags = 0;
+		if (expr->flags && !(expr->unop->flags &
+					EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 		if (is_safe_type(ctype))
 			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
@@ -2734,14 +2739,19 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 	class1 = classify_type(ctype, &t1);
 
-	/* cast to non-integer type -> not an integer constant expression */
-	if (!is_int(class1))
-		expr->flags = 0;
+	/* cast to non-numeric type -> not an arithmetic expression */
+	if (!(class1 & TYPE_NUM))
+		expr->flags &=
+			~expr_clear_flag_mask(EXPR_FLAG_ARITH_CONST_EXPR);
+	/* cast to float type -> not an integer constant expression */
+	else if (class1 & TYPE_FLOAT)
+		expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	/* if argument turns out to be not an integer constant expression *and*
 	   it was not a floating literal to start with -> too bad */
-	else if (expr->flags == Int_const_expr &&
-		!(target->flags & Int_const_expr))
-		expr->flags = 0;
+	else if (!(target->flags &
+			(EXPR_FLAG_INT_CONST_EXPR | EXPR_FLAG_FP_CONST)))
+		expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
+
 	/*
 	 * You can always throw a value away by casting to
 	 * "void" - that's an implicit "force". Note that
@@ -2803,7 +2813,7 @@ static struct symbol *evaluate_cast(struct expression *expr)
 			"cast adds address space to expression (<asn:%d>)", as1);
 
 	if (!(t1->ctype.modifiers & MOD_PTRINHERIT) && class1 == TYPE_PTR &&
-	    !as1 && (target->flags & Int_const_expr)) {
+	    !as1 && (target->flags & EXPR_FLAG_INT_CONST_EXPR)) {
 		if (t1->ctype.base_type == &void_ctype) {
 			if (is_zero_constant(target)) {
 				/* NULL */
@@ -2933,7 +2943,7 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		}
 		ctype = field;
 		expr->type = EXPR_VALUE;
-		expr->flags = Int_const_expr;
+		expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		expr->value = offset;
 		expr->taint = 0;
 		expr->ctype = size_t_ctype;
@@ -2951,7 +2961,8 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		ctype = ctype->ctype.base_type;
 		if (!expr->index) {
 			expr->type = EXPR_VALUE;
-			expr->flags = Int_const_expr;
+			expr->flags
+				= expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			expr->value = 0;
 			expr->taint = 0;
 			expr->ctype = size_t_ctype;
@@ -2968,13 +2979,14 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 			m = alloc_const_expression(expr->pos,
 						   bits_to_bytes(ctype->bit_size));
 			m->ctype = size_t_ctype;
-			m->flags = Int_const_expr;
+			m->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			expr->type = EXPR_BINOP;
 			expr->left = idx;
 			expr->right = m;
 			expr->op = '*';
 			expr->ctype = size_t_ctype;
-			expr->flags = m->flags & idx->flags & Int_const_expr;
+			expr->flags = m->flags & idx->flags &
+				expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		}
 	}
 	if (e) {
@@ -2985,7 +2997,8 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		if (!evaluate_expression(e))
 			return NULL;
 		expr->type = EXPR_BINOP;
-		expr->flags = e->flags & copy->flags & Int_const_expr;
+		expr->flags = e->flags & copy->flags &
+			expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		expr->op = '+';
 		expr->ctype = size_t_ctype;
 		expr->left = copy;
diff --git a/expand.c b/expand.c
index 0f6720c..afca611 100644
--- a/expand.c
+++ b/expand.c
@@ -1212,7 +1212,7 @@ static int expand_statement(struct statement *stmt)
 
 static inline int bad_integer_constant_expression(struct expression *expr)
 {
-	if (!(expr->flags & Int_const_expr))
+	if (!(expr->flags & EXPR_FLAG_INT_CONST_EXPR))
 		return 1;
 	if (expr->taint & Taint_comma)
 		return 1;
diff --git a/expression.c b/expression.c
index 7293d47..8582dc9 100644
--- a/expression.c
+++ b/expression.c
@@ -131,7 +131,8 @@ static struct token *parse_type(struct token *token, struct expression **tree)
 {
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
-	(*tree)->flags = Int_const_expr; /* sic */
+	(*tree)->flags
+		= expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR); /* sic */
 	token = typename(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
@@ -146,7 +147,7 @@ static struct token *builtin_types_compatible_p_expr(struct token *token,
 {
 	struct expression *expr = alloc_expression(
 		token->pos, EXPR_COMPARE);
-	expr->flags = Int_const_expr;
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	expr->op = SPECIAL_EQUAL;
 	token = token->next;
 	if (!match_op(token, '('))
@@ -200,7 +201,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 			return expect(token, ')', "at end of __builtin_offset");
 		case SPECIAL_DEREFERENCE:
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			e->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			*p = e;
 			p = &e->down;
@@ -208,7 +209,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '.':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			e->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '.';
 			if (token_type(token) != TOKEN_IDENT) {
 				sparse_error(token->pos, "Expected member name");
@@ -220,7 +221,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '[':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			e->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			token = parse_expression(token, &e->index);
 			token = expect(token, ']',
@@ -336,7 +337,7 @@ got_it:
 			"likely to produce unsigned long (and a warning) here",
 			show_token(token));
         expr->type = EXPR_VALUE;
-	expr->flags = Int_const_expr;
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST);
         expr->ctype = ctype_integer(size, want_unsigned);
         expr->value = value;
 	return;
@@ -361,7 +362,7 @@ Float:
 	else
 		goto Enoint;
 
-	expr->flags = Float_literal;
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_FP_CONST);
 	expr->type = EXPR_FVALUE;
 	return;
 
@@ -376,7 +377,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 	switch (token_type(token)) {
 	case TOKEN_CHAR ... TOKEN_WIDE_CHAR_EMBEDDED_3:
 		expr = alloc_expression(token->pos, EXPR_VALUE);   
-		expr->flags = Int_const_expr;
+		expr->flags = expr_set_flag_mask(EXPR_FLAG_CHAR_CONST);
 		expr->ctype = token_type(token) < TOKEN_WIDE_CHAR ? &int_ctype : &long_ctype;
 		get_char_constant(token, &expr->value);
 		token = token->next;
@@ -390,7 +391,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 
 	case TOKEN_ZERO_IDENT: {
 		expr = alloc_expression(token->pos, EXPR_SYMBOL);
-		expr->flags = Int_const_expr;
+		expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		expr->ctype = &int_ctype;
 		expr->symbol = &zero_int;
 		expr->symbol_name = token->ident;
@@ -417,7 +418,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 			*expr = *sym->initializer;
 			/* we want the right position reported, thus the copy */
 			expr->pos = token->pos;
-			expr->flags = Int_const_expr;
+			expr->flags = expr_set_flag_mask(EXPR_FLAG_ENUM_CONST);
 			token = next;
 			break;
 		}
@@ -457,7 +458,9 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		}
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
-			expr->flags = Int_const_expr; /* sic */
+			/* sic */
+			expr->flags
+				= expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			token = typename(token->next, &expr->symbol, NULL);
 			token = expect(token, ']', "in type expression");
 			break;
@@ -573,7 +576,8 @@ static struct token *type_info_expression(struct token *token,
 	struct token *p;
 
 	*tree = expr;
-	expr->flags = Int_const_expr; /* XXX: VLA support will need that changed */
+	/* XXX: VLA support will need that changed */
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	token = token->next;
 	if (!match_op(token, '(') || !lookup_type(token->next))
 		return unary_expression(token, &expr->cast_expression);
@@ -662,7 +666,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 			unary = alloc_expression(token->pos, EXPR_PREOP);
 			unary->op = token->special;
 			unary->unop = unop;
-			unary->flags = unop->flags & Int_const_expr;
+			unary->flags = expr_flags_decay_consts(unop->flags);
 			*tree = unary;
 			return next;
 		}
@@ -720,10 +724,24 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			if (!v)
 				return token;
 			cast->cast_expression = v;
-			if (v->flags & Int_const_expr)
-				cast->flags = Int_const_expr;
-			else if (v->flags & Float_literal) /* and _not_ int */
-				cast->flags = Int_const_expr | Float_literal;
+
+			cast->flags = expr_flags_decay_consts(v->flags);
+			/*
+			 * Up to now, we missed the (int).0 case here
+			 * which should really get a
+			 * EXPR_FLAG_INT_CONST_EXPR marker. Also,
+			 * conversion to non-numeric types is not
+			 * properly reflected up to this point.
+			 * However, we do not know until evaluation.
+			 * For the moment, in order to preserve
+			 * semantics, speculatively set
+			 * EXPR_FLAG_INT_CONST_EXPR if
+			 * EXPR_FLAG_FP_CONST is set. evaluate_cast()
+			 * will unset inappropriate flags again after
+			 * examining type information.
+			 */
+			if (v->flags & EXPR_FLAG_FP_CONST)
+				cast->flags |= EXPR_FLAG_INT_CONST_EXPR;
 			return token;
 		}
 	}
@@ -760,8 +778,9 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 				sparse_error(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
-			top->flags = left->flags & right->flags		\
-						& Int_const_expr;	\
+			top->flags					\
+				= expr_flags_decay_consts(left->flags	\
+							& right->flags); \
 			top->op = op;					\
 			top->left = left;				\
 			top->right = right;				\
@@ -865,12 +884,11 @@ struct token *conditional_expression(struct token *token, struct expression **tr
 		token = expect(token, ':', "in conditional expression");
 		token = conditional_expression(token, &expr->cond_false);
 		if (expr->left && expr->cond_false) {
-			int is_const = expr->left->flags &
-					expr->cond_false->flags &
-					Int_const_expr;
+			enum expression_flags flags = expr->left->flags &
+				expr->cond_false->flags;
 			if (expr->cond_true)
-				is_const &= expr->cond_true->flags;
-			expr->flags = is_const;
+				flags &= expr->cond_true->flags;
+			expr->flags = expr_flags_decay_consts(flags);
 		}
 	}
 	return token;
diff --git a/expression.h b/expression.h
index 80b3be5..1c8a563 100644
--- a/expression.h
+++ b/expression.h
@@ -66,10 +66,133 @@ enum expression_type {
 	EXPR_OFFSETOF,
 };
 
-enum {
-	Int_const_expr = 1,
-	Float_literal = 2,
-}; /* for expr->flags */
+
+/*
+ * Flags for tracking the promotion of various attributes from
+ * subexpressions to their parents.
+ *
+ * Currently, they only cope with an expression's constness as defined
+ * by C99.
+ *
+ * The flags are not independent as one might imply another. Use
+ * expr_set_flag_mask() and expr_clear_flag_mask() for setting and
+ * clearing a particular flag.
+ */
+enum expression_flags {
+	EXPR_FLAG_NONE = 0,
+	/*
+	 * A constant in the sense of [6.4.4]:
+	 * - Integer constant [6.4.4.1]
+	 * - Floating point constant [6.4.4.2]
+	 * - Enumeration constant [6.4.4.3]
+	 * - Character constant [6.4.4.4]
+	 */
+	EXPR_FLAG_INT_CONST = (1 << 0),
+	EXPR_FLAG_FP_CONST = (1 << 1),
+	EXPR_FLAG_ENUM_CONST = (1 << 2),
+	EXPR_FLAG_CHAR_CONST = (1 << 3),
+
+	/*
+	 * A constant expression in the sense of [6.6]:
+	 * - integer constant expression [6.6(6)]
+	 * - arithmetic constant expression [6.6(8)]
+	 * - address constanr [6.6(9)]
+	 */
+	EXPR_FLAG_INT_CONST_EXPR = (1 << 4),
+	EXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
+	EXPR_FLAG_ADDR_CONST_EXPR = (1 << 6),
+};
+
+/*
+ * Calculate a mask to be or'ed in in order to set a particular
+ * expression flag.
+ *
+ * Only one single flag from enum expression_flags is allowed at a
+ * time.
+ */
+static inline enum expression_flags expr_set_flag_mask
+	(const enum expression_flags flag)
+{
+	/* obey the implications */
+	enum expression_flags implied_flags = EXPR_FLAG_NONE;
+
+	switch (flag) {
+	case EXPR_FLAG_INT_CONST:
+	case EXPR_FLAG_ENUM_CONST:
+	case EXPR_FLAG_CHAR_CONST:
+		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
+	/* fallthrough */
+	case EXPR_FLAG_FP_CONST:
+	case EXPR_FLAG_INT_CONST_EXPR:
+		implied_flags |= EXPR_FLAG_ARITH_CONST_EXPR;
+	/* fallthrough */
+	case EXPR_FLAG_ARITH_CONST_EXPR:
+	case EXPR_FLAG_ADDR_CONST_EXPR:
+	case EXPR_FLAG_NONE:
+		break;
+	}
+
+	return (implied_flags | flag);
+}
+
+/*
+ * Calculate a mask to be negated and and'ed in in order to clear a
+ * particular expression flag.
+ *
+ * Only one single flag from enum expression_flags is allowed at a
+ * time.
+ */
+static inline enum expression_flags expr_clear_flag_mask
+	(const enum expression_flags flag)
+{
+	/* obey the implications */
+	enum expression_flags implied_flags = EXPR_FLAG_NONE;
+
+	switch (flag) {
+	case EXPR_FLAG_ARITH_CONST_EXPR:
+		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
+		implied_flags |= EXPR_FLAG_FP_CONST;
+	/* fallthrough */
+	case EXPR_FLAG_INT_CONST_EXPR:
+		implied_flags |= EXPR_FLAG_INT_CONST;
+		implied_flags |= EXPR_FLAG_ENUM_CONST;
+		implied_flags |= EXPR_FLAG_CHAR_CONST;
+	/* fallthrough */
+	case EXPR_FLAG_ADDR_CONST_EXPR:
+	case EXPR_FLAG_INT_CONST:
+	case EXPR_FLAG_FP_CONST:
+	case EXPR_FLAG_ENUM_CONST:
+	case EXPR_FLAG_CHAR_CONST:
+	case EXPR_FLAG_NONE:
+		break;
+	}
+
+	return (implied_flags | flag);
+}
+
+/*
+ *  Remove any "Constant" [6.4.4] flag, but retain the "constant
+ * expression" [6.6] flags.
+ * Used to merge the constantness flags of primary subexpressions
+ * into their parent expressions' ones.
+ */
+static inline enum expression_flags expr_flags_decay_consts
+	(enum expression_flags flags)
+{
+	return (flags & ~(expr_clear_flag_mask(EXPR_FLAG_INT_CONST)
+			  | expr_clear_flag_mask(EXPR_FLAG_FP_CONST)
+			  | expr_clear_flag_mask(EXPR_FLAG_ENUM_CONST)
+			  | expr_clear_flag_mask(EXPR_FLAG_CHAR_CONST)));
+}
+
+/* Purge any constantness related flag. */
+static inline enum expression_flags expr_flags_remove_consts
+	(enum expression_flags flags)
+{
+	return (flags &
+		~(expr_clear_flag_mask(EXPR_FLAG_ARITH_CONST_EXPR)
+		  | expr_clear_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR)));
+}
 
 enum {
 	Taint_comma = 1,
@@ -77,7 +200,7 @@ enum {
 
 struct expression {
 	enum expression_type type:8;
-	unsigned flags:8;
+	enum expression_flags flags:8;
 	int op;
 	struct position pos;
 	struct symbol *ctype;
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [PATCH RFC 01/13] expression: introduce additional expression constness tracking flags
Date: Sat, 01 Aug 2015 13:00:44 +0000
Message-ID: <20150801130044.GB23735 () ravnborg ! org>
--------------------
On Thu, Jul 23, 2015 at 01:11:36AM +0200, Nicolai Stange wrote:
> Prepare for a more fine-grained tracking of expression constness in the
> sense of C99 [6.4.4, 6.6].
> 
> User-visible behaviour remains unchanged.

Do this imply that you cannot write any testcase that fails before but is
fixed with this serie?

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 01/13] expression: introduce additional expression constness tracking flags
Date: Sat, 09 Jan 2016 17:03:29 +0000
Message-ID: <20160109170328.GA8655 () macpro ! local>
--------------------
On Thu, Jul 23, 2015 at 01:11:36AM +0200, Nicolai Stange wrote:
> Prepare for a more fine-grained tracking of expression constness in the
> sense of C99 [6.4.4, 6.6].
> 

I have a few remarks/questions/suggestions here under.

> +/*
> + * Flags for tracking the promotion of various attributes from
> + * subexpressions to their parents.
> + *
> + * Currently, they only cope with an expression's constness as defined
> + * by C99.
> + *
> + * The flags are not independent as one might imply another. Use
> + * expr_set_flag_mask() and expr_clear_flag_mask() for setting and
> + * clearing a particular flag.
> + */
> +enum expression_flags {
> +	EXPR_FLAG_NONE = 0,
> +	/*
> +	 * A constant in the sense of [6.4.4]:
> +	 * - Integer constant [6.4.4.1]
> +	 * - Floating point constant [6.4.4.2]
> +	 * - Enumeration constant [6.4.4.3]
> +	 * - Character constant [6.4.4.4]
> +	 */
> +	EXPR_FLAG_INT_CONST = (1 << 0),
> +	EXPR_FLAG_FP_CONST = (1 << 1),
> +	EXPR_FLAG_ENUM_CONST = (1 << 2),
> +	EXPR_FLAG_CHAR_CONST = (1 << 3),
> +
> +	/*
> +	 * A constant expression in the sense of [6.6]:
> +	 * - integer constant expression [6.6(6)]
> +	 * - arithmetic constant expression [6.6(8)]
> +	 * - address constanr [6.6(9)]
> +	 */
> +	EXPR_FLAG_INT_CONST_EXPR = (1 << 4),
> +	EXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
> +	EXPR_FLAG_ADDR_CONST_EXPR = (1 << 6),
> +};
> +
> +/*
> + * Calculate a mask to be or'ed in in order to set a particular
> + * expression flag.
> + *
> + * Only one single flag from enum expression_flags is allowed at a
> + * time.
> + */
> +static inline enum expression_flags expr_set_flag_mask
> +	(const enum expression_flags flag)
> +{
> +	/* obey the implications */
> +	enum expression_flags implied_flags = EXPR_FLAG_NONE;
> +
> +	switch (flag) {
> +	case EXPR_FLAG_INT_CONST:
> +	case EXPR_FLAG_ENUM_CONST:
> +	case EXPR_FLAG_CHAR_CONST:
> +		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
> +	/* fallthrough */
> +	case EXPR_FLAG_FP_CONST:
> +	case EXPR_FLAG_INT_CONST_EXPR:
> +		implied_flags |= EXPR_FLAG_ARITH_CONST_EXPR;
> +	/* fallthrough */
> +	case EXPR_FLAG_ARITH_CONST_EXPR:
> +	case EXPR_FLAG_ADDR_CONST_EXPR:
> +	case EXPR_FLAG_NONE:
> +		break;
> +	}
> +
> +	return (implied_flags | flag);
> +}
> +
> +/*
> + * Calculate a mask to be negated and and'ed in in order to clear a
> + * particular expression flag.
> + *
> + * Only one single flag from enum expression_flags is allowed at a
> + * time.
> + */
> +static inline enum expression_flags expr_clear_flag_mask
> +	(const enum expression_flags flag)
> +{
> +	/* obey the implications */
> +	enum expression_flags implied_flags = EXPR_FLAG_NONE;
> +
> +	switch (flag) {
> +	case EXPR_FLAG_ARITH_CONST_EXPR:
> +		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
> +		implied_flags |= EXPR_FLAG_FP_CONST;
> +	/* fallthrough */
> +	case EXPR_FLAG_INT_CONST_EXPR:
> +		implied_flags |= EXPR_FLAG_INT_CONST;
> +		implied_flags |= EXPR_FLAG_ENUM_CONST;
> +		implied_flags |= EXPR_FLAG_CHAR_CONST;
> +	/* fallthrough */
> +	case EXPR_FLAG_ADDR_CONST_EXPR:
> +	case EXPR_FLAG_INT_CONST:
> +	case EXPR_FLAG_FP_CONST:
> +	case EXPR_FLAG_ENUM_CONST:
> +	case EXPR_FLAG_CHAR_CONST:
> +	case EXPR_FLAG_NONE:
> +		break;
> +	}
> +
> +	return (implied_flags | flag);
> +}

Shouldn't the following be more explicit?
	flag = expr_set_flag_mask(0, ...);
	flag = expr_set_flag_mask(in_flag, ...);
	flag = expr_clear_flag_mask(in_flag, ...);
Yes, I know, it would need to duplicate the expr->flags at almost all calls.

Couldn't we get rid of those two function by separating the exclusive "bits"
from the "sets"?
Something like:
	#define	__EXPR_FLAG_INT_CONST	(1 << 0)
	#define	__EXPR_FLAG_FP_CONST	(1 << 1)
	...
	#define	EXPR_FLAG_INT_CONST	(__EXPR_FLAG_INT_CONST |
					 __EXPR_FLAG_INT_CONST_EXPR |
					 __EXPR_FLAG_ARITH_CONST)

> +/*
> + *  Remove any "Constant" [6.4.4] flag, but retain the "constant
> + * expression" [6.6] flags.
> + * Used to merge the constantness flags of primary subexpressions
> + * into their parent expressions' ones.
> + */
> +static inline enum expression_flags expr_flags_decay_consts
> +	(enum expression_flags flags)
> +{
> +	return (flags & ~(expr_clear_flag_mask(EXPR_FLAG_INT_CONST)
> +			  | expr_clear_flag_mask(EXPR_FLAG_FP_CONST)
> +			  | expr_clear_flag_mask(EXPR_FLAG_ENUM_CONST)
> +			  | expr_clear_flag_mask(EXPR_FLAG_CHAR_CONST)));
> +}

How is that different from:
	return flags & ~(EXPR_FLAG_INT_CONST
			|EXPR_FLAG_FP_CONST
			|EXPR_FLAG_ENUM_CONST
			|EXPR_FLAG_CHAR_CONST)?
Shouldn't this more directly implement the desciption of the function:
	"Remove any 'Constant' flag but retain ... ?

> +/* Purge any constantness related flag. */
> +static inline enum expression_flags expr_flags_remove_consts
> +	(enum expression_flags flags)
> +{
> +	return (flags &
> +		~(expr_clear_flag_mask(EXPR_FLAG_ARITH_CONST_EXPR)
> +		  | expr_clear_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR)));
> +}

Same as above with the appropriate changes.


Yours,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 01/13] expression: introduce additional expression constness tracking flags
Date: Sat, 09 Jan 2016 22:20:27 +0000
Message-ID: <87a8oewg2c.fsf () gmail ! com>
--------------------
Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

> On Thu, Jul 23, 2015 at 01:11:36AM +0200, Nicolai Stange wrote:
>> Prepare for a more fine-grained tracking of expression constness in the
>> sense of C99 [6.4.4, 6.6].
>> 
>
> I have a few remarks/questions/suggestions here under.
>
>> +/*
>> + * Flags for tracking the promotion of various attributes from
>> + * subexpressions to their parents.
>> + *
>> + * Currently, they only cope with an expression's constness as defined
>> + * by C99.
>> + *
>> + * The flags are not independent as one might imply another. Use
>> + * expr_set_flag_mask() and expr_clear_flag_mask() for setting and
>> + * clearing a particular flag.
>> + */
>> +enum expression_flags {
>> +	EXPR_FLAG_NONE = 0,
>> +	/*
>> +	 * A constant in the sense of [6.4.4]:
>> +	 * - Integer constant [6.4.4.1]
>> +	 * - Floating point constant [6.4.4.2]
>> +	 * - Enumeration constant [6.4.4.3]
>> +	 * - Character constant [6.4.4.4]
>> +	 */
>> +	EXPR_FLAG_INT_CONST = (1 << 0),
>> +	EXPR_FLAG_FP_CONST = (1 << 1),
>> +	EXPR_FLAG_ENUM_CONST = (1 << 2),
>> +	EXPR_FLAG_CHAR_CONST = (1 << 3),
>> +
>> +	/*
>> +	 * A constant expression in the sense of [6.6]:
>> +	 * - integer constant expression [6.6(6)]
>> +	 * - arithmetic constant expression [6.6(8)]
>> +	 * - address constanr [6.6(9)]
>> +	 */
>> +	EXPR_FLAG_INT_CONST_EXPR = (1 << 4),
>> +	EXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
>> +	EXPR_FLAG_ADDR_CONST_EXPR = (1 << 6),
>> +};
>> +
>> +/*
>> + * Calculate a mask to be or'ed in in order to set a particular
>> + * expression flag.
>> + *
>> + * Only one single flag from enum expression_flags is allowed at a
>> + * time.
>> + */
>> +static inline enum expression_flags expr_set_flag_mask
>> +	(const enum expression_flags flag)
>> +{
>> +	/* obey the implications */
>> +	enum expression_flags implied_flags = EXPR_FLAG_NONE;
>> +
>> +	switch (flag) {
>> +	case EXPR_FLAG_INT_CONST:
>> +	case EXPR_FLAG_ENUM_CONST:
>> +	case EXPR_FLAG_CHAR_CONST:
>> +		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
>> +	/* fallthrough */
>> +	case EXPR_FLAG_FP_CONST:
>> +	case EXPR_FLAG_INT_CONST_EXPR:
>> +		implied_flags |= EXPR_FLAG_ARITH_CONST_EXPR;
>> +	/* fallthrough */
>> +	case EXPR_FLAG_ARITH_CONST_EXPR:
>> +	case EXPR_FLAG_ADDR_CONST_EXPR:
>> +	case EXPR_FLAG_NONE:
>> +		break;
>> +	}
>> +
>> +	return (implied_flags | flag);
>> +}
>> +
>> +/*
>> + * Calculate a mask to be negated and and'ed in in order to clear a
>> + * particular expression flag.
>> + *
>> + * Only one single flag from enum expression_flags is allowed at a
>> + * time.
>> + */
>> +static inline enum expression_flags expr_clear_flag_mask
>> +	(const enum expression_flags flag)
>> +{
>> +	/* obey the implications */
>> +	enum expression_flags implied_flags = EXPR_FLAG_NONE;
>> +
>> +	switch (flag) {
>> +	case EXPR_FLAG_ARITH_CONST_EXPR:
>> +		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
>> +		implied_flags |= EXPR_FLAG_FP_CONST;
>> +	/* fallthrough */
>> +	case EXPR_FLAG_INT_CONST_EXPR:
>> +		implied_flags |= EXPR_FLAG_INT_CONST;
>> +		implied_flags |= EXPR_FLAG_ENUM_CONST;
>> +		implied_flags |= EXPR_FLAG_CHAR_CONST;
>> +	/* fallthrough */
>> +	case EXPR_FLAG_ADDR_CONST_EXPR:
>> +	case EXPR_FLAG_INT_CONST:
>> +	case EXPR_FLAG_FP_CONST:
>> +	case EXPR_FLAG_ENUM_CONST:
>> +	case EXPR_FLAG_CHAR_CONST:
>> +	case EXPR_FLAG_NONE:
>> +		break;
>> +	}
>> +
>> +	return (implied_flags | flag);
>> +}
>
> Shouldn't the following be more explicit?
> 	flag = expr_set_flag_mask(0, ...);
> 	flag = expr_set_flag_mask(in_flag, ...);
> 	flag = expr_clear_flag_mask(in_flag, ...);
> Yes, I know, it would need to duplicate the expr->flags at almost all calls.

Admittedly, this looks way better.

I'll change that to
  void expr_set_flag(unsigned *flag, ...);
and likewise for the clearing guy.

>
> Couldn't we get rid of those two function by separating the exclusive "bits"
> from the "sets"?
> Something like:
> 	#define	__EXPR_FLAG_INT_CONST	(1 << 0)
> 	#define	__EXPR_FLAG_FP_CONST	(1 << 1)
> 	...
> 	#define	EXPR_FLAG_INT_CONST	(__EXPR_FLAG_INT_CONST |
> 					 __EXPR_FLAG_INT_CONST_EXPR |
> 					 __EXPR_FLAG_ARITH_CONST)

No, this won't work since the "implied" bit masks are in general different for
setting and clearing a flag.

For example, "integer constant" (i.e. integer literal) implies "integer
constant expression", but "not a integer constant" does not imply "not a
integer constant expression".


>
>> +/*
>> + *  Remove any "Constant" [6.4.4] flag, but retain the "constant
>> + * expression" [6.6] flags.
>> + * Used to merge the constantness flags of primary subexpressions
>> + * into their parent expressions' ones.
>> + */
>> +static inline enum expression_flags expr_flags_decay_consts
>> +	(enum expression_flags flags)
>> +{
>> +	return (flags & ~(expr_clear_flag_mask(EXPR_FLAG_INT_CONST)
>> +			  | expr_clear_flag_mask(EXPR_FLAG_FP_CONST)
>> +			  | expr_clear_flag_mask(EXPR_FLAG_ENUM_CONST)
>> +			  | expr_clear_flag_mask(EXPR_FLAG_CHAR_CONST)));
>> +}
>
> How is that different from:
> 	return flags & ~(EXPR_FLAG_INT_CONST
> 			|EXPR_FLAG_FP_CONST
> 			|EXPR_FLAG_ENUM_CONST
> 			|EXPR_FLAG_CHAR_CONST)?

Not at all.

> Shouldn't this more directly implement the desciption of the function:
> 	"Remove any 'Constant' flag but retain ... ?

Yes. I will change this.


>> +/* Purge any constantness related flag. */
>> +static inline enum expression_flags expr_flags_remove_consts
>> +	(enum expression_flags flags)
>> +{
>> +	return (flags &
>> +		~(expr_clear_flag_mask(EXPR_FLAG_ARITH_CONST_EXPR)
>> +		  | expr_clear_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR)));
>> +}
>
> Same as above with the appropriate changes.
>

Ditto.

> Yours,
> Luc

Again, thank you very much for your valuable review!
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness
Date: Wed, 22 Jul 2015 23:19:09 +0000
Message-ID: <871tfzkcgi.fsf () gmail ! com>
--------------------
Initializers of static storage duration objects shall be constant
expressions [6.7.8(4)].

Warn if that requirement is not met.

Identify static storage duration objects by having either of
MOD_TOPLEVEL or MOD_STATIC set.

Check an initializer's constness at the lowest possible subobject
level, i.e. at the level of the "assignment-expression" production
in [6.7.8].

For compound objects, make handle_list_initializer() pass the
surrounding object's storage duration modifiers down to
handle_simple_initializer() at subobject initializer evaluation.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                  |  25 +++++++++-
 validation/constexpr-init.c | 109 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 133 insertions(+), 1 deletion(-)
 create mode 100644 validation/constexpr-init.c

diff --git a/evaluate.c b/evaluate.c
index c38b893..a65cc0c 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2466,6 +2466,7 @@ static void handle_list_initializer(struct expression *expr,
 {
 	struct expression *e, *last = NULL, *top = NULL, *next;
 	int jumped = 0;
+	unsigned long old_modifiers;
 
 	FOR_EACH_PTR(expr->expr_list, e) {
 		struct expression **v;
@@ -2520,8 +2521,21 @@ found:
 		else
 			v = &top->ident_expression;
 
-		if (handle_simple_initializer(v, 1, lclass, top->ctype))
+		/*
+		 * Temporarily copy storage modifiers down from
+		 * surrounding type such that
+		 * handle_simple_initializer() can check
+		 * initializations of subobjects with static storage
+		 * duration.
+		 */
+		old_modifiers = top->ctype->ctype.modifiers;
+		top->ctype->ctype.modifiers =
+			old_modifiers | (ctype->ctype.modifiers & MOD_STORAGE);
+		if (handle_simple_initializer(v, 1, lclass, top->ctype)) {
+			top->ctype->ctype.modifiers = old_modifiers;
 			continue;
+		}
+		top->ctype->ctype.modifiers = old_modifiers;
 
 		if (!(lclass & TYPE_COMPOUND)) {
 			warning(e->pos, "bogus scalar initializer");
@@ -2631,6 +2645,15 @@ static int handle_simple_initializer(struct expression **ep, int nested,
 		if (!evaluate_expression(e))
 			return 1;
 		compatible_assignment_types(e, ctype, ep, "initializer");
+		/*
+		 * Initializers for static storage duration objects
+		 * shall be constant expressions or a string literal [6.7.8(4)].
+		 */
+		if ((ctype->ctype.modifiers & (MOD_TOPLEVEL | MOD_STATIC)) &&
+			!(e->flags & (EXPR_FLAG_ARITH_CONST_EXPR
+					| EXPR_FLAG_ADDR_CONST_EXPR)))
+			warning(e->pos, "initializer for static storage duration object is not a constant expression");
+
 		return 1;
 	}
 
diff --git a/validation/constexpr-init.c b/validation/constexpr-init.c
new file mode 100644
index 0000000..6c412b8
--- /dev/null
+++ b/validation/constexpr-init.c
@@ -0,0 +1,109 @@
+static int a = 1;					// OK
+static int b[2] = {1, 1};				// OK
+static void c(void) {}
+
+static int *d = &a;					// OK
+static int *e = &b[1];					// OK
+static int *f = b;					// OK
+static void (*g)(void) = c;				// OK
+static void (*h)(void) = &c;				// OK
+static int *i = (int*)0;				// OK
+static int *j = d;					// KO
+static int *k = (int*)0 + 1;				// OK
+
+static int *l = &a + 1;				// OK
+static int *m = &b[1] + 1;				// OK
+static int *n = b + 1;					// OK
+static int *o = d + 1;					// KO
+
+static int *p = &*&a;					// OK
+static int *q = &*&b[1];				// OK
+static int *r = &*b;					// OK
+static int *s = &*d;					// KO
+
+static int *t = &*(&a + 1);				// OK
+static int *u = &*(&b[1] + 1);				// OK
+static int *v = &*(b + 1);				// OK
+static int *w = &*(d + 1);				// KO
+
+
+struct A {
+	int a;
+	int b[2];
+};
+
+struct B {
+	int c;
+	struct A d;
+};
+
+static struct B x= {1, {1, {1, 1}}};				// OK
+static struct B y= {a, {1, {1, 1}}};				// KO
+static struct B z= {1, {a, {1, 1}}};				// KO
+static struct B aa= {1, {1, {a, 1}}};				// KO
+static struct B ab= {1, {1, {1, a}}};				// KO
+static struct B ac= {.c = 1, .d = {.a = 1, .b = {1, 1}}};	// OK
+static struct B ad= {.c = a, .d = {.a = 1, .b = {1, 1}}};	// KO
+static struct B ae= {.c = 1, .d = {.a = a, .b = {1, 1}}};	// KO
+static struct B af= {.c = 1, .d = {.a = 1, .b = {a, 1}}};	// KO
+static struct B ag= {.c = 1, .d = {.a = 1, .b = {1, a}}};	// KO
+
+static int *ah = &x.d.a;		// OK
+static int *ai = &(&x.d)->a;		// OK
+static int *aj = x.d.b;		// OK
+static int *ak = (&x.d)->b;		// OK
+static int *al = &x.d.b[1];		// OK
+static int *am = &(&x.d)->b[1];	// OK
+
+static int an[] = {a, 1};				// KO
+static int ao[] = {1, a};				// KO
+static int ap[] = {[0] = a, [1] = 1};			// KO
+static int aq[] = {[0] = 1, [1] = a};			// KO
+
+static char *ar = "foobar";				// OK
+
+static void as(void) {
+	int a = 0;
+	int b = a;		// OK
+}
+
+static void at(void) {
+	int a = 1;
+	static int b = a;	// KO
+}
+
+static void au(void) {
+	int a = 1;
+	static int *b = &a;	// KO
+}
+
+static void av(void) {
+	static int a = 1;
+	static int *b = &a;	// OK
+}
+
+
+/*
+ * check-name: Static storage object initializer constness verification.
+ *
+ * check-error-start
+constexpr-init.c:11:17: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:17:19: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:22:19: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:27:22: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:41:21: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:42:25: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:43:30: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:44:33: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:46:27: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:47:41: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:48:50: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:49:53: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:58:20: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:59:23: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:60:26: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:61:35: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:72:24: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:77:26: warning: initializer for static storage duration object is not a constant expression
+ * check-error-end
+ */
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness
Date: Sat, 09 Jan 2016 18:04:51 +0000
Message-ID: <20160109180450.GA2718 () macpro ! local>
--------------------
On Thu, Jul 23, 2015 at 01:19:09AM +0200, Nicolai Stange wrote:
> Initializers of static storage duration objects shall be constant
> expressions [6.7.8(4)].
> 
> Warn if that requirement is not met.
> 
> Identify static storage duration objects by having either of
> MOD_TOPLEVEL or MOD_STATIC set.
> 
> Check an initializer's constness at the lowest possible subobject
> level, i.e. at the level of the "assignment-expression" production
> in [6.7.8].
> 
> For compound objects, make handle_list_initializer() pass the
> surrounding object's storage duration modifiers down to
> handle_simple_initializer() at subobject initializer evaluation.


This patch makes validation/{builtin_bswap,choose_expr}.c fail.
Of course, it's directly related to the purpose of the patch but
then the test should be adapted.


Yours,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness
Date: Sat, 09 Jan 2016 22:28:08 +0000
Message-ID: <8737u6wfpj.fsf () gmail ! com>
--------------------
Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

> On Thu, Jul 23, 2015 at 01:19:09AM +0200, Nicolai Stange wrote:
>> Initializers of static storage duration objects shall be constant
>> expressions [6.7.8(4)].
>> 
>> Warn if that requirement is not met.
>> 
>> Identify static storage duration objects by having either of
>> MOD_TOPLEVEL or MOD_STATIC set.
>> 
>> Check an initializer's constness at the lowest possible subobject
>> level, i.e. at the level of the "assignment-expression" production
>> in [6.7.8].
>> 
>> For compound objects, make handle_list_initializer() pass the
>> surrounding object's storage duration modifiers down to
>> handle_simple_initializer() at subobject initializer evaluation.
>
>
> This patch makes validation/{builtin_bswap,choose_expr}.c fail.
> Of course, it's directly related to the purpose of the patch but
> then the test should be adapted.
>

Yes, you are absolutely right. However, as mentioned in this RFC series'
cover letter, I decided to leave these two failers as is "for the
moment". Certainly this is anything but best practice and I can only
apologize for sending you half (well 97%) baken patches -- and promise
to never do it again...
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness
Date: Mon, 11 Jan 2016 18:02:05 +0000
Message-ID: <20160111180205.GD2972 () macpro ! local>
--------------------
On Sat, Jan 09, 2016 at 11:28:08PM +0100, Nicolai Stange wrote:
> Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:
> 
> > On Thu, Jul 23, 2015 at 01:19:09AM +0200, Nicolai Stange wrote:
> >> Initializers of static storage duration objects shall be constant
> >> expressions [6.7.8(4)].
> >> 
> >> Warn if that requirement is not met.
> >> 
> >> Identify static storage duration objects by having either of
> >> MOD_TOPLEVEL or MOD_STATIC set.
> >> 
> >> Check an initializer's constness at the lowest possible subobject
> >> level, i.e. at the level of the "assignment-expression" production
> >> in [6.7.8].
> >> 
> >> For compound objects, make handle_list_initializer() pass the
> >> surrounding object's storage duration modifiers down to
> >> handle_simple_initializer() at subobject initializer evaluation.
> >
> >
> > This patch makes validation/{builtin_bswap,choose_expr}.c fail.
> > Of course, it's directly related to the purpose of the patch but
> > then the test should be adapted.
> >
> 
> Yes, you are absolutely right. However, as mentioned in this RFC series'
> cover letter, I decided to leave these two failers as is "for the moment".

It's fine then.
I just wanted to be sure that you was aware of it.

> Certainly this is anything but best practice and I can only
> apologize for sending you half (well 97%) baken patches -- and promise
> to never do it again...

Personally, I think that drafts are very fine.
They're the basis on which we, developers, can exchange ideas.
And your patches are far from drafts, they are already finely coocked.

But just to be sure to avoid any misunderstanding:
you know that I'm not the maintainer, just a reviewer. Right?


Yours,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness
Date: Mon, 11 Jan 2016 19:28:13 +0000
Message-ID: <20160111192813.GA27713 () cloud>
--------------------
On Mon, Jan 11, 2016 at 07:15:33PM +0100, Nicolai Stange wrote:
> Btw, this remembers me of the fact that Josh Triplett is still listed as
> a maintainer in sparse.1
> 
> Either of {web,man}page is wrong about that. Or both are incomplete and
> we have actually got two maintainers here?

I'm definitely not the maintainer anymore.  I just hang around and
participate sporadically. :)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 0/5] unssa improvements ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 0/5] unssa improvements
Date: Mon, 12 Dec 2016 15:28:56 +0000
Message-ID: <20161212152901.24948-1-luc.vanoostenryck () gmail ! com>
--------------------
This serie improves the out-of-SSA step by:
* simplify the conversion of the phi-nodes & phi-sources into copies
* eliminate some copies which are trivially not needed.

The elimination step is significant since on a small corpus which
produced 267 copies, after the patch only 165 remain.


Changes since v1:
  * during unSSA, do not use kill_instruction() on OP_PHI
  * fix related to the fact that after unSSA, pseudos *can*
    again be defined by several instructions. If it's effectively the
    case, their ->def is set to NULL (and must, of course, not be used).

Note: this serie depends on the serie 'fix uses of killed instructions'
    and on the changes to the testsuite for checking after some patterns
    in the output.

This serie can also be found on github:
	https://github.com/lucvoo/sparse/tree/sent/unssa-simple

Luc Van Oostenryck (5):
  unssa: do not try to update liveness
  unssa: simplify rewrite of OP_PHISOURCE
  unssa: try to avoid some OP_PHI copies
  unssa: eliminate trivial phisrc copies
  unssa: update comment about the unneeded copies

 unssa.c | 142 ++++++++++++++++++++++++++++++++++------------------------------
 1 file changed, 75 insertions(+), 67 deletions(-)

-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 00/13] improve constexpr handling ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 00/13] improve constexpr handling
Date: Mon, 25 Jan 2016 14:47:51 +0000
Message-ID: <87twm1g1go.fsf () gmail ! com>
--------------------
This is the second attempt to clean up and improve sparse's handling
of constant expressions. After I got some helpful reviews from
Josh Triplett and Luc Van Oostenryck on my initial RFC series, I feel
quite comfortable with this now and dropped the 'RFC' tag in favour of
'v2'.

Quote from my initial 'RFC' cover letter regarding the structure of
this series:

  This patch series is split into four parts:
  - The first part deals with the refactorization of the current integer
    constant expression handling and introduces some support for
    recognizing arithmetic expressions. [1-5/13]
  - The second part introduces support for recognizing address constants.
    [6/13]
  - The third part introduces a check for the constness of static storage
    duration objects' initializers. [7/13]
  - The last part stems from my tests with the kernel. It contains things
    I missed in the first [9-10/13] and second [8,12/13] parts and
    relaxes some of the constraints on constant expressions [11/13].
    For the last patch [13/13], please see below. 
  [...]
  Although the patches of the fourth part, the fixup part, fit very well
  into the first two categories, their associated testcases, if any,
  depend on [7/13]. Thus, I dediced to keep the order as is.

Quote end.


The question from the initial 'RFC' series whether or not to relax the
constexpr constraints, meaning that

  a difference of address constants may yield an integer constant

in order to make the kernel's ACPI_OFFSET macro happy, is still
unaddressed. However, if it turns out that we actually want to do so,
this single issue can be easily handled by some follow up patch.


Changes made between v2 and the initial, 'RFC' tagged series:
 - As suggested by Josh Triplett,
   [7/13] ("check static storage duration objects' intializers' constness")
   only warns now if -Wstatic-initializer-not-const is given.
   This option is not enabled by default and thus, the two testsuite
   failers reported by Luc Van Oostenryck cease to fail.
 - Luc Van Oostenryck didn't like the way the setting and clearing of
   flags is handled. I did not completely follow his advice of
   introducing predefined sets of masks to or in/and out resp., because
   setting and clearing is kind of different. However, I tried to
   address his concerns by changing expr_{set,clear}_flag_mask(...)
   into expr_{set,clear}_flag(...) whose interfaces are (hopefully) much
   saner.


Nicolai Stange (13):
  expression: introduce additional expression constness tracking flags
  expression: examine constness of casts at evaluation only
  expression: examine constness of binops and alike at evaluation only
  expression: examine constness of preops at evaluation only
  expression: examine constness of conditionals at evaluation only
  expression, evaluate: add support for recognizing address constants
  evaluate: check static storage duration objects' intializers'
    constness
  expression: recognize references to labels as address constants
  expression: examine constness of __builtin_offsetof at evaluation only
  symbol: flag builtins constant_p, safe_p and warning as constexprs
  evaluate: relax some constant expression rules for pointer expressions
  expression, evaluate: support compound literals as address constants
  symbol: do not inherit storage modifiers from base types at
    examination

 evaluate.c                              | 188 ++++++++++++++++++++++++--------
 expand.c                                |   2 +-
 expression.c                            |  52 ++++-----
 expression.h                            | 123 ++++++++++++++++++++-
 lib.c                                   |   2 +
 lib.h                                   |   2 +-
 sparse.1                                |   7 ++
 symbol.c                                |  12 +-
 validation/constexpr-binop.c            |  33 ++++++
 validation/constexpr-cast.c             |  25 +++++
 validation/constexpr-compound-literal.c |  19 ++++
 validation/constexpr-conditional.c      |  34 ++++++
 validation/constexpr-init.c             | 110 +++++++++++++++++++
 validation/constexpr-offsetof.c         |  21 ++++
 validation/constexpr-preop.c            |  29 +++++
 15 files changed, 575 insertions(+), 84 deletions(-)
 create mode 100644 validation/constexpr-binop.c
 create mode 100644 validation/constexpr-cast.c
 create mode 100644 validation/constexpr-compound-literal.c
 create mode 100644 validation/constexpr-conditional.c
 create mode 100644 validation/constexpr-init.c
 create mode 100644 validation/constexpr-offsetof.c
 create mode 100644 validation/constexpr-preop.c

-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 00/13] improve constexpr handling
Date: Mon, 25 Jan 2016 21:01:07 +0000
Message-ID: <20160125210106.GB43341 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:47:51PM +0100, Nicolai Stange wrote:
> This is the second attempt to clean up and improve sparse's handling
> of constant expressions. After I got some helpful reviews from
> Josh Triplett and Luc Van Oostenryck on my initial RFC series, I feel
> quite comfortable with this now and dropped the 'RFC' tag in favour of
> 'v2'.

Great.
 
> Quote from my initial 'RFC' cover letter regarding the structure of
> this series:
> 
>   This patch series is split into four parts:
>   - The first part deals with the refactorization of the current integer
>     constant expression handling and introduces some support for
>     recognizing arithmetic expressions. [1-5/13]
>   - The second part introduces support for recognizing address constants.
>     [6/13]
>   - The third part introduces a check for the constness of static storage
>     duration objects' initializers. [7/13]
>   - The last part stems from my tests with the kernel. It contains things
>     I missed in the first [9-10/13] and second [8,12/13] parts and
>     relaxes some of the constraints on constant expressions [11/13].
>     For the last patch [13/13], please see below. 
>   [...]
>   Although the patches of the fourth part, the fixup part, fit very well
>   into the first two categories, their associated testcases, if any,
>   depend on [7/13]. Thus, I dediced to keep the order as is.

Yes, it's fine. certainly so since you now added the -W flag.
I really consider your [13/13] as a totally separate patch
but it needs this series to see its effect.

> Quote end.
> 
> 
> The question from the initial 'RFC' series whether or not to relax the
> constexpr constraints, meaning that
> 
>   a difference of address constants may yield an integer constant
> 
> in order to make the kernel's ACPI_OFFSET macro happy, is still
> unaddressed. However, if it turns out that we actually want to do so,
> this single issue can be easily handled by some follow up patch.

Yes, indeed.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 00/13] improve constexpr handling
Date: Mon, 25 Jan 2016 21:26:35 +0000
Message-ID: <877fix5p10.fsf () gmail ! com>
--------------------
Hi Luc,

thank you once again!

Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

> On Mon, Jan 25, 2016 at 03:47:51PM +0100, Nicolai Stange wrote:
>> This is the second attempt to clean up and improve sparse's handling
>> of constant expressions. After I got some helpful reviews from
>> Josh Triplett and Luc Van Oostenryck on my initial RFC series, I feel
>> quite comfortable with this now and dropped the 'RFC' tag in favour of
>> 'v2'.
>
> Great.
>  
>> Quote from my initial 'RFC' cover letter regarding the structure of
>> this series:
>> 
>>   This patch series is split into four parts:
>>   - The first part deals with the refactorization of the current integer
>>     constant expression handling and introduces some support for
>>     recognizing arithmetic expressions. [1-5/13]
>>   - The second part introduces support for recognizing address constants.
>>     [6/13]
>>   - The third part introduces a check for the constness of static storage
>>     duration objects' initializers. [7/13]
>>   - The last part stems from my tests with the kernel. It contains things
>>     I missed in the first [9-10/13] and second [8,12/13] parts and
>>     relaxes some of the constraints on constant expressions [11/13].
>>     For the last patch [13/13], please see below. 
>>   [...]
>>   Although the patches of the fourth part, the fixup part, fit very well
>>   into the first two categories, their associated testcases, if any,
>>   depend on [7/13]. Thus, I dediced to keep the order as is.
>
> Yes, it's fine. certainly so since you now added the -W flag.
> I really consider your [13/13] as a totally separate patch
> but it needs this series to see its effect.

You're right, it somehow feels like it could go separately. However, it
is strictly needed in this form or another in order to avoid false
positives with -Wstatic-initializer-not-const (see the commit message of
[13/13] for an example). Because of that, I'd prefer to keep it with
this series.

>> Quote end.
>> 
>> 
>> The question from the initial 'RFC' series whether or not to relax the
>> constexpr constraints, meaning that
>> 
>>   a difference of address constants may yield an integer constant
>> 
>> in order to make the kernel's ACPI_OFFSET macro happy, is still
>> unaddressed. However, if it turns out that we actually want to do so,
>> this single issue can be easily handled by some follow up patch.
>
> Yes, indeed.
>
>
> Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 01/13] expression: introduce additional expression constness tracking flags ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 01/13] expression: introduce additional expression constness tracking flags
Date: Mon, 25 Jan 2016 14:49:28 +0000
Message-ID: <87powpg1dz.fsf () gmail ! com>
--------------------
Prepare for a more fine-grained tracking of expression constness in the
sense of C99 [6.4.4, 6.6].

User-visible behaviour remains unchanged.

The current implementation tags an expression with either combination
of the flags Int_const_expr and Float_literal, the latter being only
used to tell that
  (int).0
is indeed an integer constant expression.

Even if sparse attempted to verify that initializers for static storage
duration objects are constant expressions [6.7.8(4)] (which it
currently does not), it could not tell reliably.
Examples:
1.)
  static float a = { (float)0 }; /* allowed by C99 */
  '(float)0' is not an integer constant expression, but an arithmetic
  one.
2.)
  enum { b = 0 };
  static void *c = { (void*)b }; /* disallowed by C99 */
  References to enum members are not allowed in address constants
  [6.6(9)] and thus, the initializer is not a constant expression at
  all.

Introduce a broader set of constness tracking flags, resembling the
four types of constants [6.4.4] (integer, floating, enumeration,
character) and the three types of constant expressions [6.6] (integer,
arithmetic, address). Use helper functions to consistently set and
clear these flags as they are not completely independent.
Finally, make alloc_expression() and alloc_const_expression()
initialize the new expression's flags to zero.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c   |  72 ++++++++++++++++++++--------------
 expand.c     |   2 +-
 expression.c |  67 ++++++++++++++++++++------------
 expression.h | 123 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 4 files changed, 206 insertions(+), 58 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 035e448..0cf85ae 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -400,7 +400,7 @@ static struct symbol *bad_expr_type(struct expression *expr)
 		break;
 	}
 
-	expr->flags = 0;
+	expr->flags = EXPR_FLAG_NONE;
 	return expr->ctype = &bad_ctype;
 }
 
@@ -880,8 +880,9 @@ static struct symbol *evaluate_logical(struct expression *expr)
 	/* the result is int [6.5.13(3), 6.5.14(3)] */
 	expr->ctype = &int_ctype;
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 	return &int_ctype;
 }
@@ -894,8 +895,9 @@ static struct symbol *evaluate_binop(struct expression *expr)
 	int op = expr->op;
 
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	/* number op number */
@@ -986,7 +988,7 @@ static inline int is_null_pointer_constant(struct expression *e)
 {
 	if (e->ctype == &null_ctype)
 		return 1;
-	if (!(e->flags & Int_const_expr))
+	if (!(e->flags & EXPR_FLAG_INT_CONST_EXPR))
 		return 0;
 	return is_zero_constant(e) ? 2 : 0;
 }
@@ -1001,8 +1003,9 @@ static struct symbol *evaluate_compare(struct expression *expr)
 	const char *typediff;
 
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	/* Type types? */
@@ -1120,10 +1123,14 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	}
 
 	if (expr->flags) {
-		int flags = expr->conditional->flags & Int_const_expr;
+		unsigned char flags_mask = 0;
+		unsigned char flags;
+
+		expr_set_flag(&flags_mask, EXPR_FLAG_INT_CONST_EXPR);
+		flags = (expr->conditional->flags & flags_mask);
 		flags &= (*true)->flags & expr->cond_false->flags;
 		if (!flags)
-			expr->flags = 0;
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	lclass = classify_type(ltype, &ltype);
@@ -1681,7 +1688,7 @@ static struct symbol *evaluate_addressof(struct expression *expr)
 	}
 	ctype = op->ctype;
 	*expr = *op->unop;
-	expr->flags = 0;
+	expr->flags = EXPR_FLAG_NONE;
 
 	if (expr->type == EXPR_SYMBOL) {
 		struct symbol *sym = expr->symbol;
@@ -1709,7 +1716,7 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 	/* Simplify: *&(expr) => (expr) */
 	if (op->type == EXPR_PREOP && op->op == '&') {
 		*expr = *op->unop;
-		expr->flags = 0;
+		expr->flags = EXPR_FLAG_NONE;
 		return expr->ctype;
 	}
 
@@ -1799,8 +1806,8 @@ static struct symbol *evaluate_sign(struct expression *expr)
 {
 	struct symbol *ctype = expr->unop->ctype;
 	int class = classify_type(ctype, &ctype);
-	if (expr->flags && !(expr->unop->flags & Int_const_expr))
-		expr->flags = 0;
+	if (expr->flags && !(expr->unop->flags & EXPR_FLAG_INT_CONST_EXPR))
+		expr->flags = EXPR_FLAG_NONE;
 	/* should be an arithmetic type */
 	if (!(class & TYPE_NUM))
 		return bad_expr_type(expr);
@@ -1854,8 +1861,9 @@ static struct symbol *evaluate_preop(struct expression *expr)
 		return evaluate_postop(expr);
 
 	case '!':
-		if (expr->flags && !(expr->unop->flags & Int_const_expr))
-			expr->flags = 0;
+		if (expr->flags && !(expr->unop->flags &
+					EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 		if (is_safe_type(ctype))
 			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
@@ -2734,14 +2742,18 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 	class1 = classify_type(ctype, &t1);
 
-	/* cast to non-integer type -> not an integer constant expression */
-	if (!is_int(class1))
-		expr->flags = 0;
+	/* cast to non-numeric type -> not an arithmetic expression */
+	if (!(class1 & TYPE_NUM))
+		expr_clear_flag(&expr->flags, EXPR_FLAG_ARITH_CONST_EXPR);
+	/* cast to float type -> not an integer constant expression */
+	else if (class1 & TYPE_FLOAT)
+		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 	/* if argument turns out to be not an integer constant expression *and*
 	   it was not a floating literal to start with -> too bad */
-	else if (expr->flags == Int_const_expr &&
-		!(target->flags & Int_const_expr))
-		expr->flags = 0;
+	else if (!(target->flags &
+			(EXPR_FLAG_INT_CONST_EXPR | EXPR_FLAG_FP_CONST)))
+		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
+
 	/*
 	 * You can always throw a value away by casting to
 	 * "void" - that's an implicit "force". Note that
@@ -2803,7 +2815,7 @@ static struct symbol *evaluate_cast(struct expression *expr)
 			"cast adds address space to expression (<asn:%d>)", as1);
 
 	if (!(t1->ctype.modifiers & MOD_PTRINHERIT) && class1 == TYPE_PTR &&
-	    !as1 && (target->flags & Int_const_expr)) {
+	    !as1 && (target->flags & EXPR_FLAG_INT_CONST_EXPR)) {
 		if (t1->ctype.base_type == &void_ctype) {
 			if (is_zero_constant(target)) {
 				/* NULL */
@@ -2933,7 +2945,8 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		}
 		ctype = field;
 		expr->type = EXPR_VALUE;
-		expr->flags = Int_const_expr;
+		expr->flags = EXPR_FLAG_NONE;
+		expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 		expr->value = offset;
 		expr->taint = 0;
 		expr->ctype = size_t_ctype;
@@ -2951,7 +2964,8 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		ctype = ctype->ctype.base_type;
 		if (!expr->index) {
 			expr->type = EXPR_VALUE;
-			expr->flags = Int_const_expr;
+			expr->flags = EXPR_FLAG_NONE;
+			expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 			expr->value = 0;
 			expr->taint = 0;
 			expr->ctype = size_t_ctype;
@@ -2968,24 +2982,26 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 			m = alloc_const_expression(expr->pos,
 						   bits_to_bytes(ctype->bit_size));
 			m->ctype = size_t_ctype;
-			m->flags = Int_const_expr;
+			expr_set_flag(&m->flags, EXPR_FLAG_INT_CONST_EXPR);
 			expr->type = EXPR_BINOP;
 			expr->left = idx;
 			expr->right = m;
 			expr->op = '*';
 			expr->ctype = size_t_ctype;
-			expr->flags = m->flags & idx->flags & Int_const_expr;
+			expr->flags = m->flags & idx->flags;
 		}
 	}
 	if (e) {
 		struct expression *copy = __alloc_expression(0);
+		unsigned char flags_mask = EXPR_FLAG_NONE;
 		*copy = *expr;
 		if (e->type == EXPR_OFFSETOF)
 			e->in = ctype;
 		if (!evaluate_expression(e))
 			return NULL;
 		expr->type = EXPR_BINOP;
-		expr->flags = e->flags & copy->flags & Int_const_expr;
+		expr_set_flag(&flags_mask, EXPR_FLAG_INT_CONST_EXPR);
+		expr->flags = e->flags & copy->flags & flags_mask;
 		expr->op = '+';
 		expr->ctype = size_t_ctype;
 		expr->left = copy;
diff --git a/expand.c b/expand.c
index 0f6720c..afca611 100644
--- a/expand.c
+++ b/expand.c
@@ -1212,7 +1212,7 @@ static int expand_statement(struct statement *stmt)
 
 static inline int bad_integer_constant_expression(struct expression *expr)
 {
-	if (!(expr->flags & Int_const_expr))
+	if (!(expr->flags & EXPR_FLAG_INT_CONST_EXPR))
 		return 1;
 	if (expr->taint & Taint_comma)
 		return 1;
diff --git a/expression.c b/expression.c
index 7293d47..eccdb5a 100644
--- a/expression.c
+++ b/expression.c
@@ -131,7 +131,7 @@ static struct token *parse_type(struct token *token, struct expression **tree)
 {
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
-	(*tree)->flags = Int_const_expr; /* sic */
+	expr_set_flag(&(*tree)->flags, EXPR_FLAG_INT_CONST_EXPR); /* sic */
 	token = typename(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
@@ -146,7 +146,7 @@ static struct token *builtin_types_compatible_p_expr(struct token *token,
 {
 	struct expression *expr = alloc_expression(
 		token->pos, EXPR_COMPARE);
-	expr->flags = Int_const_expr;
+	expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 	expr->op = SPECIAL_EQUAL;
 	token = token->next;
 	if (!match_op(token, '('))
@@ -200,7 +200,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 			return expect(token, ')', "at end of __builtin_offset");
 		case SPECIAL_DEREFERENCE:
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			expr_set_flag(&e->flags, EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			*p = e;
 			p = &e->down;
@@ -208,7 +208,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '.':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			expr_set_flag(&e->flags, EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '.';
 			if (token_type(token) != TOKEN_IDENT) {
 				sparse_error(token->pos, "Expected member name");
@@ -220,7 +220,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '[':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			expr_set_flag(&e->flags, EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			token = parse_expression(token, &e->index);
 			token = expect(token, ']',
@@ -336,7 +336,8 @@ got_it:
 			"likely to produce unsigned long (and a warning) here",
 			show_token(token));
         expr->type = EXPR_VALUE;
-	expr->flags = Int_const_expr;
+	expr->flags = EXPR_FLAG_NONE;
+	expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST);
         expr->ctype = ctype_integer(size, want_unsigned);
         expr->value = value;
 	return;
@@ -361,7 +362,8 @@ Float:
 	else
 		goto Enoint;
 
-	expr->flags = Float_literal;
+	expr->flags = EXPR_FLAG_NONE;
+	expr_set_flag(&expr->flags, EXPR_FLAG_FP_CONST);
 	expr->type = EXPR_FVALUE;
 	return;
 
@@ -376,7 +378,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 	switch (token_type(token)) {
 	case TOKEN_CHAR ... TOKEN_WIDE_CHAR_EMBEDDED_3:
 		expr = alloc_expression(token->pos, EXPR_VALUE);   
-		expr->flags = Int_const_expr;
+		expr_set_flag(&expr->flags, EXPR_FLAG_CHAR_CONST);
 		expr->ctype = token_type(token) < TOKEN_WIDE_CHAR ? &int_ctype : &long_ctype;
 		get_char_constant(token, &expr->value);
 		token = token->next;
@@ -390,7 +392,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 
 	case TOKEN_ZERO_IDENT: {
 		expr = alloc_expression(token->pos, EXPR_SYMBOL);
-		expr->flags = Int_const_expr;
+		expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 		expr->ctype = &int_ctype;
 		expr->symbol = &zero_int;
 		expr->symbol_name = token->ident;
@@ -417,7 +419,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 			*expr = *sym->initializer;
 			/* we want the right position reported, thus the copy */
 			expr->pos = token->pos;
-			expr->flags = Int_const_expr;
+			expr_set_flag(&expr->flags, EXPR_FLAG_ENUM_CONST);
 			token = next;
 			break;
 		}
@@ -457,7 +459,8 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		}
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
-			expr->flags = Int_const_expr; /* sic */
+			/* sic */
+			expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 			token = typename(token->next, &expr->symbol, NULL);
 			token = expect(token, ']', "in type expression");
 			break;
@@ -573,7 +576,8 @@ static struct token *type_info_expression(struct token *token,
 	struct token *p;
 
 	*tree = expr;
-	expr->flags = Int_const_expr; /* XXX: VLA support will need that changed */
+	/* XXX: VLA support will need that changed */
+	expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 	token = token->next;
 	if (!match_op(token, '(') || !lookup_type(token->next))
 		return unary_expression(token, &expr->cast_expression);
@@ -662,7 +666,8 @@ static struct token *unary_expression(struct token *token, struct expression **t
 			unary = alloc_expression(token->pos, EXPR_PREOP);
 			unary->op = token->special;
 			unary->unop = unop;
-			unary->flags = unop->flags & Int_const_expr;
+			unary->flags = unop->flags;
+			expr_flags_decay_consts(&unary->flags);
 			*tree = unary;
 			return next;
 		}
@@ -720,10 +725,25 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			if (!v)
 				return token;
 			cast->cast_expression = v;
-			if (v->flags & Int_const_expr)
-				cast->flags = Int_const_expr;
-			else if (v->flags & Float_literal) /* and _not_ int */
-				cast->flags = Int_const_expr | Float_literal;
+
+			cast->flags = v->flags;
+			expr_flags_decay_consts(&cast->flags);
+			/*
+			 * Up to now, we missed the (int).0 case here
+			 * which should really get a
+			 * EXPR_FLAG_INT_CONST_EXPR marker. Also,
+			 * conversion to non-numeric types is not
+			 * properly reflected up to this point.
+			 * However, we do not know until evaluation.
+			 * For the moment, in order to preserve
+			 * semantics, speculatively set
+			 * EXPR_FLAG_INT_CONST_EXPR if
+			 * EXPR_FLAG_FP_CONST is set. evaluate_cast()
+			 * will unset inappropriate flags again after
+			 * examining type information.
+			 */
+			if (v->flags & EXPR_FLAG_FP_CONST)
+				cast->flags |= EXPR_FLAG_INT_CONST_EXPR;
 			return token;
 		}
 	}
@@ -760,8 +780,8 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 				sparse_error(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
-			top->flags = left->flags & right->flags		\
-						& Int_const_expr;	\
+			top->flags = left->flags & right->flags;	\
+			expr_flags_decay_consts(&top->flags);		\
 			top->op = op;					\
 			top->left = left;				\
 			top->right = right;				\
@@ -865,12 +885,11 @@ struct token *conditional_expression(struct token *token, struct expression **tr
 		token = expect(token, ':', "in conditional expression");
 		token = conditional_expression(token, &expr->cond_false);
 		if (expr->left && expr->cond_false) {
-			int is_const = expr->left->flags &
-					expr->cond_false->flags &
-					Int_const_expr;
+			expr->flags = expr->left->flags &
+				expr->cond_false->flags;
 			if (expr->cond_true)
-				is_const &= expr->cond_true->flags;
-			expr->flags = is_const;
+				expr->flags &= expr->cond_true->flags;
+			expr_flags_decay_consts(&expr->flags);
 		}
 	}
 	return token;
diff --git a/expression.h b/expression.h
index 80b3be5..b9f6f08 100644
--- a/expression.h
+++ b/expression.h
@@ -66,10 +66,121 @@ enum expression_type {
 	EXPR_OFFSETOF,
 };
 
-enum {
-	Int_const_expr = 1,
-	Float_literal = 2,
-}; /* for expr->flags */
+
+/*
+ * Flags for tracking the promotion of various attributes from
+ * subexpressions to their parents.
+ *
+ * Currently, they only cope with an expression's constness as defined
+ * by C99.
+ *
+ * The flags are not independent as one might imply another. Use
+ * expr_set_flag() and expr_clear_flag() for setting and clearing a
+ * particular flag.
+ */
+enum expression_flags {
+	EXPR_FLAG_NONE = 0,
+	/*
+	 * A constant in the sense of [6.4.4]:
+	 * - Integer constant [6.4.4.1]
+	 * - Floating point constant [6.4.4.2]
+	 * - Enumeration constant [6.4.4.3]
+	 * - Character constant [6.4.4.4]
+	 */
+	EXPR_FLAG_INT_CONST = (1 << 0),
+	EXPR_FLAG_FP_CONST = (1 << 1),
+	EXPR_FLAG_ENUM_CONST = (1 << 2),
+	EXPR_FLAG_CHAR_CONST = (1 << 3),
+
+	/*
+	 * A constant expression in the sense of [6.6]:
+	 * - integer constant expression [6.6(6)]
+	 * - arithmetic constant expression [6.6(8)]
+	 * - address constanr [6.6(9)]
+	 */
+	EXPR_FLAG_INT_CONST_EXPR = (1 << 4),
+	EXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
+	EXPR_FLAG_ADDR_CONST_EXPR = (1 << 6),
+};
+
+/*
+ * Set a particular flag among an expression's ones.
+ *
+ * The set of flags defined is not completely independent. Take care
+ * that implications keep obeyed.
+ *
+ * Only one single flag from enum expression_flags is allowed for
+ * the flag argument at a time.
+ */
+static inline void expr_set_flag(unsigned char * const flags,
+				enum expression_flags flag)
+{
+	/* obey the implications */
+	switch (flag) {
+	case EXPR_FLAG_INT_CONST:
+	case EXPR_FLAG_ENUM_CONST:
+	case EXPR_FLAG_CHAR_CONST:
+		flag |= EXPR_FLAG_INT_CONST_EXPR;
+	/* fallthrough */
+	case EXPR_FLAG_FP_CONST:
+	case EXPR_FLAG_INT_CONST_EXPR:
+		flag |= EXPR_FLAG_ARITH_CONST_EXPR;
+	/* fallthrough */
+	case EXPR_FLAG_ARITH_CONST_EXPR:
+	case EXPR_FLAG_ADDR_CONST_EXPR:
+	case EXPR_FLAG_NONE:
+		break;
+	}
+
+	*flags |= flag;
+}
+
+/*
+ * Clear a particular flag among an expression's ones.
+ *
+ * The set of flags defined is not completely independent. Take care
+ * that implications keep obeyed.
+ *
+ * Only one single flag from enum expression_flags is allowed for
+ * the flag argument at a time.
+ */
+static inline void expr_clear_flag(unsigned char * const flags,
+				enum expression_flags flag)
+{
+	/* obey the implications */
+	switch (flag) {
+	case EXPR_FLAG_ARITH_CONST_EXPR:
+		flag |= EXPR_FLAG_INT_CONST_EXPR;
+		flag |= EXPR_FLAG_FP_CONST;
+	/* fallthrough */
+	case EXPR_FLAG_INT_CONST_EXPR:
+		flag |= EXPR_FLAG_INT_CONST;
+		flag |= EXPR_FLAG_ENUM_CONST;
+		flag |= EXPR_FLAG_CHAR_CONST;
+	/* fallthrough */
+	case EXPR_FLAG_ADDR_CONST_EXPR:
+	case EXPR_FLAG_INT_CONST:
+	case EXPR_FLAG_FP_CONST:
+	case EXPR_FLAG_ENUM_CONST:
+	case EXPR_FLAG_CHAR_CONST:
+	case EXPR_FLAG_NONE:
+		break;
+	}
+
+	*flags &= ~flag;
+}
+
+/*
+ * Remove any "Constant" [6.4.4] flag, but retain the "constant
+ * expression" [6.6] flags.
+ * Used to merge the constantness flags of primary subexpressions
+ * into their parent expressions' ones.
+ */
+static inline void expr_flags_decay_consts(unsigned char * const flags)
+{
+	*flags &= ~(EXPR_FLAG_INT_CONST | EXPR_FLAG_FP_CONST |
+		EXPR_FLAG_ENUM_CONST | EXPR_FLAG_CHAR_CONST);
+}
 
 enum {
 	Taint_comma = 1,
@@ -77,7 +188,7 @@ enum {
 
 struct expression {
 	enum expression_type type:8;
-	unsigned flags:8;
+	unsigned char flags;
 	int op;
 	struct position pos;
 	struct symbol *ctype;
@@ -199,6 +310,7 @@ static inline struct expression *alloc_expression(struct position pos, int type)
 {
 	struct expression *expr = __alloc_expression(0);
 	expr->type = type;
+	expr->flags = EXPR_FLAG_NONE;
 	expr->pos = pos;
 	return expr;
 }
@@ -207,6 +319,7 @@ static inline struct expression *alloc_const_expression(struct position pos, int
 {
 	struct expression *expr = __alloc_expression(0);
 	expr->type = EXPR_VALUE;
+	expr->flags = EXPR_FLAG_NONE;
 	expr->pos = pos;
 	expr->value = value;
 	expr->ctype = &int_ctype;
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 01/13] expression: introduce additional expression constness tracking flags
Date: Mon, 25 Jan 2016 21:51:36 +0000
Message-ID: <20160125215135.GC43341 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:49:28PM +0100, Nicolai Stange wrote:
> Prepare for a more fine-grained tracking of expression constness in the
> sense of C99 [6.4.4, 6.6].

This part could be moved at the end of the patch description
> User-visible behaviour remains unchanged.
> 
> The current implementation tags an expression with either combination
> of the flags Int_const_expr and Float_literal, the latter being only
> used to tell that
>   (int).0
> is indeed an integer constant expression.

This part should be dropped, I think, and maybe moved to the cover letter.

> Even if sparse attempted to verify that initializers for static storage
> duration objects are constant expressions [6.7.8(4)] (which it
> currently does not), it could not tell reliably.
> Examples:
> 1.)
>   static float a = { (float)0 }; /* allowed by C99 */
>   '(float)0' is not an integer constant expression, but an arithmetic
>   one.
> 2.)
>   enum { b = 0 };
>   static void *c = { (void*)b }; /* disallowed by C99 */
>   References to enum members are not allowed in address constants
>   [6.6(9)] and thus, the initializer is not a constant expression at
>   all.

This could be moved to the top of the patch description 
> Introduce a broader set of constness tracking flags, resembling the
> four types of constants [6.4.4] (integer, floating, enumeration,
> character) and the three types of constant expressions [6.6] (integer,
> arithmetic, address). Use helper functions to consistently set and
> clear these flags as they are not completely independent.
> Finally, make alloc_expression() and alloc_const_expression()
> initialize the new expression's flags to zero.

I think this patch should be split into 2-4 smaller patches:
0) introduce the new flags, maybe first only NONE, INT_EXPR & FP_CONST
1) replace the old use of 0, Int_const_expr, ... (can be folded with 0)
2) initialize the flag in alloc_expression() (can be folded with 1)..
3) introduce the the new flags if needed, the expr_..._flag() helpers
   and begin them


> --- a/expression.c
> +++ b/expression.c
> @@ -131,7 +131,7 @@ static struct token *parse_type(struct token *token, struct expression **tree)
>  {
>  	struct symbol *sym;
>  	*tree = alloc_expression(token->pos, EXPR_TYPE);
> -	(*tree)->flags = Int_const_expr; /* sic */
> +	expr_set_flag(&(*tree)->flags, EXPR_FLAG_INT_CONST_EXPR); /* sic */

Better to remove those 'sic'. To which text do they refer?

> @@ -457,7 +459,8 @@ struct token *primary_expression(struct token *token, struct expression **tree)
>  		}
>  		if (token->special == '[' && lookup_type(token->next)) {
>  			expr = alloc_expression(token->pos, EXPR_TYPE);
> -			expr->flags = Int_const_expr; /* sic */
> +			/* sic */
> +			expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);

Ditto for the 'sic'

> +
> +/*
> + * Set a particular flag among an expression's ones.
> + *
> + * The set of flags defined is not completely independent. Take care
> + * that implications keep obeyed.
> + *
> + * Only one single flag from enum expression_flags is allowed for
> + * the flag argument at a time.
> + */
> +static inline void expr_set_flag(unsigned char * const flags,
> +				enum expression_flags flag)
> +{
> +	/* obey the implications */
> +	switch (flag) {
> +	case EXPR_FLAG_INT_CONST:
> +	case EXPR_FLAG_ENUM_CONST:
> +	case EXPR_FLAG_CHAR_CONST:
> +		flag |= EXPR_FLAG_INT_CONST_EXPR;
> +	/* fallthrough */
> +	case EXPR_FLAG_FP_CONST:
> +	case EXPR_FLAG_INT_CONST_EXPR:
> +		flag |= EXPR_FLAG_ARITH_CONST_EXPR;
> +	/* fallthrough */
> +	case EXPR_FLAG_ARITH_CONST_EXPR:
> +	case EXPR_FLAG_ADDR_CONST_EXPR:
> +	case EXPR_FLAG_NONE:
> +		break;
> +	}
> +
> +	*flags |= flag;
> +}
> +
> +/*
> + * Clear a particular flag among an expression's ones.
> + *
> + * The set of flags defined is not completely independent. Take care
> + * that implications keep obeyed.
> + *
> + * Only one single flag from enum expression_flags is allowed for
> + * the flag argument at a time.
> + */
> +static inline void expr_clear_flag(unsigned char * const flags,
> +				enum expression_flags flag)
> +{
> +	/* obey the implications */
> +	switch (flag) {
> +	case EXPR_FLAG_ARITH_CONST_EXPR:
> +		flag |= EXPR_FLAG_INT_CONST_EXPR;
> +		flag |= EXPR_FLAG_FP_CONST;
> +	/* fallthrough */
> +	case EXPR_FLAG_INT_CONST_EXPR:
> +		flag |= EXPR_FLAG_INT_CONST;
> +		flag |= EXPR_FLAG_ENUM_CONST;
> +		flag |= EXPR_FLAG_CHAR_CONST;
> +	/* fallthrough */
> +	case EXPR_FLAG_ADDR_CONST_EXPR:
> +	case EXPR_FLAG_INT_CONST:
> +	case EXPR_FLAG_FP_CONST:
> +	case EXPR_FLAG_ENUM_CONST:
> +	case EXPR_FLAG_CHAR_CONST:
> +	case EXPR_FLAG_NONE:
> +		break;
> +	}
> +
> +	*flags &= ~flag;
> +}
> +
> +/*
> + * Remove any "Constant" [6.4.4] flag, but retain the "constant
> + * expression" [6.6] flags.
> + * Used to merge the constantness flags of primary subexpressions
> + * into their parent expressions' ones.
> + */
> +static inline void expr_flags_decay_consts(unsigned char * const flags)
> +{
> +	*flags &= ~(EXPR_FLAG_INT_CONST | EXPR_FLAG_FP_CONST |
> +		EXPR_FLAG_ENUM_CONST | EXPR_FLAG_CHAR_CONST);
> +}
  

I think it's already much better so!
But honestly, I still think that it could be improved:
- the fact that it need a pointer for the update, means that it can only be used
  with a specific type, here unsigned char, and not arbitrary expressions
- expr_flags_decay_consts(flags) could be simply be replaced by something like:
	#define EXPR_FLAG_CONSTANTS (EXPR_FLAG_INT_CONST|EXPR_FLAG_FP_CONST|...)
	flags &= ~EXPR_FLAG_CONSTANTS;
- expr_clear_flag() is only used 5 times:
  -) 4 times with ADDR_CONST_EXPR where it can be replaced by a simple &= ~
  -) once with INT_CONST_EXPR 
 
So, with only a few defines for the set/union, one for the 'clear' and one
one for the decay you can get rid of these helpers wich IMO improve readability
and is consistent that elsewhere in the code there is anyway manipulations of
expr->flags done simply with '|' and '&'.

>  enum {
>  	Taint_comma = 1,
> @@ -77,7 +188,7 @@ enum {
>  
>  struct expression {
>  	enum expression_type type:8;
> -	unsigned flags:8;
> +	unsigned char flags;

I suppose that initialy this 'flags' was foreseen for other things than
'Int_const_expr' & 'Float_literal' but now I think it should be better
to rename it with something more explicit, like 'constness' or something
(same then for the EXPR_FLAG_... of course).


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 02/13] expression: examine constness of casts at evaluation only ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 02/13] expression: examine constness of casts at evaluation only
Date: Mon, 25 Jan 2016 14:51:03 +0000
Message-ID: <87lh7dg1bc.fsf () gmail ! com>
--------------------
Currently, the propagation of expressions' constness flags through
cast expressions is done in two steps:
- Several flags are speculatively set at cast expression parsing time
- and possibly cleared again at evaluation time.

Set aside this unfortunate split of code, the early propagation of
constness flags is not able to recognize constant expressions such as
  (int)__builtin_choose_expr(0, 0, 0)
since the final expression to be thrown into the cast is known only
after evaluation.

Move the whole calculation of cast expressions' constness flags to the
evaluation phase.

Introduce support for tracking arithmetic constness propagation through
cast expressions.

Introduce support for recognizing address constants created by casting
an integer constant to pointer type.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                  | 42 ++++++++++++++++++++++++++++++------------
 expression.c                | 19 -------------------
 validation/constexpr-cast.c | 25 +++++++++++++++++++++++++
 3 files changed, 55 insertions(+), 31 deletions(-)
 create mode 100644 validation/constexpr-cast.c

diff --git a/evaluate.c b/evaluate.c
index 0cf85ae..11917ee 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -323,7 +323,6 @@ static struct expression * cast_to(struct expression *old, struct symbol *type)
 	}
 
 	expr = alloc_expression(old->pos, EXPR_IMPLIED_CAST);
-	expr->flags = old->flags;
 	expr->ctype = type;
 	expr->cast_type = type;
 	expr->cast_expression = old;
@@ -2742,17 +2741,36 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 	class1 = classify_type(ctype, &t1);
 
-	/* cast to non-numeric type -> not an arithmetic expression */
-	if (!(class1 & TYPE_NUM))
-		expr_clear_flag(&expr->flags, EXPR_FLAG_ARITH_CONST_EXPR);
-	/* cast to float type -> not an integer constant expression */
-	else if (class1 & TYPE_FLOAT)
-		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
-	/* if argument turns out to be not an integer constant expression *and*
-	   it was not a floating literal to start with -> too bad */
-	else if (!(target->flags &
-			(EXPR_FLAG_INT_CONST_EXPR | EXPR_FLAG_FP_CONST)))
-		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
+	if (!(class1 & TYPE_NUM)) {
+		/*
+		 * Casts of integer literals to pointer type yield
+		 * address constants [6.6(9)].
+		 */
+		if (class1 & TYPE_PTR &&
+			(target->flags & EXPR_FLAG_INT_CONST)) {
+			expr_set_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
+		}
+	} else {
+		expr->flags = target->flags;
+		expr_flags_decay_consts(&expr->flags);
+		/*
+		 * Casts to numeric types never result in address
+		 * constants [6.6(9)].
+		 */
+		expr_clear_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
+		/*
+		 * Cast to float type -> not an integer constant
+		 * expression [6.6(6)].
+		 */
+		if (class1 & TYPE_FLOAT)
+			expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
+		/*
+		 * Casts of float literals to integer type results in
+		 * a constant integer expression [6.6(6)].
+		 */
+		else if (target->flags & EXPR_FLAG_FP_CONST)
+			expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
+	}
 
 	/*
 	 * You can always throw a value away by casting to
diff --git a/expression.c b/expression.c
index eccdb5a..33f4581 100644
--- a/expression.c
+++ b/expression.c
@@ -725,25 +725,6 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			if (!v)
 				return token;
 			cast->cast_expression = v;
-
-			cast->flags = v->flags;
-			expr_flags_decay_consts(&cast->flags);
-			/*
-			 * Up to now, we missed the (int).0 case here
-			 * which should really get a
-			 * EXPR_FLAG_INT_CONST_EXPR marker. Also,
-			 * conversion to non-numeric types is not
-			 * properly reflected up to this point.
-			 * However, we do not know until evaluation.
-			 * For the moment, in order to preserve
-			 * semantics, speculatively set
-			 * EXPR_FLAG_INT_CONST_EXPR if
-			 * EXPR_FLAG_FP_CONST is set. evaluate_cast()
-			 * will unset inappropriate flags again after
-			 * examining type information.
-			 */
-			if (v->flags & EXPR_FLAG_FP_CONST)
-				cast->flags |= EXPR_FLAG_INT_CONST_EXPR;
 			return token;
 		}
 	}
diff --git a/validation/constexpr-cast.c b/validation/constexpr-cast.c
new file mode 100644
index 0000000..2706961
--- /dev/null
+++ b/validation/constexpr-cast.c
@@ -0,0 +1,25 @@
+static int a[] = {
+	[(int)0] = 0,		// OK
+	[(int)(int)0] = 0,	// OK
+	[(int)0.] = 0,		// OK
+	[(int)(int)0.] = 0,	// OK
+	[(int)__builtin_choose_expr(0, 0, 0)] = 0,	// OK
+	[(int)__builtin_choose_expr(0, 0, 0.)] = 0,	// OK
+
+	[(int)(float)0] = 0,	// KO
+	[(int)(float)0.] = 0,	// KO
+
+	[(int)(void*)0] = 0,	// KO
+	[(int)(void*)0.] = 0,	// KO
+
+};
+/*
+ * check-name: Expression constness propagation in casts
+ *
+ * check-error-start
+constexpr-cast.c:9:11: error: bad integer constant expression
+constexpr-cast.c:10:11: error: bad integer constant expression
+constexpr-cast.c:12:11: error: bad integer constant expression
+constexpr-cast.c:13:11: error: bad integer constant expression
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 02/13] expression: examine constness of casts at evaluation only
Date: Mon, 25 Jan 2016 22:02:40 +0000
Message-ID: <20160125220239.GD43341 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:51:03PM +0100, Nicolai Stange wrote:
> Currently, the propagation of expressions' constness flags through
> cast expressions is done in two steps:
> - Several flags are speculatively set at cast expression parsing time
> - and possibly cleared again at evaluation time.
> 
> Set aside this unfortunate split of code, the early propagation of
> constness flags is not able to recognize constant expressions such as
>   (int)__builtin_choose_expr(0, 0, 0)
> since the final expression to be thrown into the cast is known only
> after evaluation.
> 
> Move the whole calculation of cast expressions' constness flags to the
> evaluation phase.
> 
> Introduce support for tracking arithmetic constness propagation through
> cast expressions.
> 
> Introduce support for recognizing address constants created by casting
> an integer constant to pointer type.


The description show that 3 things are done in the patch.
Can it be splitted in 3?

Also, it describes the current situation and what is changed but the
'why' part is not so clear.


The changes themselves are very fine.
And the comments help :)

Luc
 
> Signed-off-by: Nicolai Stange <nicstange@gmail.com>
> ---
>  evaluate.c                  | 42 ++++++++++++++++++++++++++++++------------
>  expression.c                | 19 -------------------
>  validation/constexpr-cast.c | 25 +++++++++++++++++++++++++
>  3 files changed, 55 insertions(+), 31 deletions(-)
>  create mode 100644 validation/constexpr-cast.c
> 
> diff --git a/evaluate.c b/evaluate.c
> index 0cf85ae..11917ee 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -323,7 +323,6 @@ static struct expression * cast_to(struct expression *old, struct symbol *type)
>  	}
>  
>  	expr = alloc_expression(old->pos, EXPR_IMPLIED_CAST);
> -	expr->flags = old->flags;
>  	expr->ctype = type;
>  	expr->cast_type = type;
>  	expr->cast_expression = old;
> @@ -2742,17 +2741,36 @@ static struct symbol *evaluate_cast(struct expression *expr)
>  
>  	class1 = classify_type(ctype, &t1);
>  
> -	/* cast to non-numeric type -> not an arithmetic expression */
> -	if (!(class1 & TYPE_NUM))
> -		expr_clear_flag(&expr->flags, EXPR_FLAG_ARITH_CONST_EXPR);
> -	/* cast to float type -> not an integer constant expression */
> -	else if (class1 & TYPE_FLOAT)
> -		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
> -	/* if argument turns out to be not an integer constant expression *and*
> -	   it was not a floating literal to start with -> too bad */
> -	else if (!(target->flags &
> -			(EXPR_FLAG_INT_CONST_EXPR | EXPR_FLAG_FP_CONST)))
> -		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
> +	if (!(class1 & TYPE_NUM)) {
> +		/*
> +		 * Casts of integer literals to pointer type yield
> +		 * address constants [6.6(9)].
> +		 */
> +		if (class1 & TYPE_PTR &&
> +			(target->flags & EXPR_FLAG_INT_CONST)) {
> +			expr_set_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
> +		}
> +	} else {
> +		expr->flags = target->flags;
> +		expr_flags_decay_consts(&expr->flags);
> +		/*
> +		 * Casts to numeric types never result in address
> +		 * constants [6.6(9)].
> +		 */
> +		expr_clear_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
> +		/*
> +		 * Cast to float type -> not an integer constant
> +		 * expression [6.6(6)].
> +		 */
> +		if (class1 & TYPE_FLOAT)
> +			expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
> +		/*
> +		 * Casts of float literals to integer type results in
> +		 * a constant integer expression [6.6(6)].
> +		 */
> +		else if (target->flags & EXPR_FLAG_FP_CONST)
> +			expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
> +	}
>  
>  	/*
>  	 * You can always throw a value away by casting to
> diff --git a/expression.c b/expression.c
> index eccdb5a..33f4581 100644
> --- a/expression.c
> +++ b/expression.c
> @@ -725,25 +725,6 @@ static struct token *cast_expression(struct token *token, struct expression **tr
>  			if (!v)
>  				return token;
>  			cast->cast_expression = v;
> -
> -			cast->flags = v->flags;
> -			expr_flags_decay_consts(&cast->flags);
> -			/*
> -			 * Up to now, we missed the (int).0 case here
> -			 * which should really get a
> -			 * EXPR_FLAG_INT_CONST_EXPR marker. Also,
> -			 * conversion to non-numeric types is not
> -			 * properly reflected up to this point.
> -			 * However, we do not know until evaluation.
> -			 * For the moment, in order to preserve
> -			 * semantics, speculatively set
> -			 * EXPR_FLAG_INT_CONST_EXPR if
> -			 * EXPR_FLAG_FP_CONST is set. evaluate_cast()
> -			 * will unset inappropriate flags again after
> -			 * examining type information.
> -			 */
> -			if (v->flags & EXPR_FLAG_FP_CONST)
> -				cast->flags |= EXPR_FLAG_INT_CONST_EXPR;
>  			return token;
>  		}
>  	}
> diff --git a/validation/constexpr-cast.c b/validation/constexpr-cast.c
> new file mode 100644
> index 0000000..2706961
> --- /dev/null
> +++ b/validation/constexpr-cast.c
> @@ -0,0 +1,25 @@
> +static int a[] = {
> +	[(int)0] = 0,		// OK
> +	[(int)(int)0] = 0,	// OK
> +	[(int)0.] = 0,		// OK
> +	[(int)(int)0.] = 0,	// OK
> +	[(int)__builtin_choose_expr(0, 0, 0)] = 0,	// OK
> +	[(int)__builtin_choose_expr(0, 0, 0.)] = 0,	// OK
> +
> +	[(int)(float)0] = 0,	// KO
> +	[(int)(float)0.] = 0,	// KO
> +
> +	[(int)(void*)0] = 0,	// KO
> +	[(int)(void*)0.] = 0,	// KO
> +
> +};
> +/*
> + * check-name: Expression constness propagation in casts
> + *
> + * check-error-start
> +constexpr-cast.c:9:11: error: bad integer constant expression
> +constexpr-cast.c:10:11: error: bad integer constant expression
> +constexpr-cast.c:12:11: error: bad integer constant expression
> +constexpr-cast.c:13:11: error: bad integer constant expression
> + * check-error-end
> + */
> -- 
> 2.7.0
> 
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 02/13] expression: examine constness of casts at evaluation only
Date: Tue, 26 Jan 2016 16:11:23 +0000
Message-ID: <87fuxkb9sk.fsf () gmail ! com>
--------------------
Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

> On Mon, Jan 25, 2016 at 03:51:03PM +0100, Nicolai Stange wrote:
>> Currently, the propagation of expressions' constness flags through
>> cast expressions is done in two steps:
>> - Several flags are speculatively set at cast expression parsing time
>> - and possibly cleared again at evaluation time.
>> 
>> Set aside this unfortunate split of code, the early propagation of
>> constness flags is not able to recognize constant expressions such as
>>   (int)__builtin_choose_expr(0, 0, 0)
>> since the final expression to be thrown into the cast is known only
>> after evaluation.
>> 
>> Move the whole calculation of cast expressions' constness flags to the
>> evaluation phase.
>> 
>> Introduce support for tracking arithmetic constness propagation through
>> cast expressions.
>> 
>> Introduce support for recognizing address constants created by casting
>> an integer constant to pointer type.
>
>
> The description show that 3 things are done in the patch.
> Can it be splitted in 3?

That tracking "arithmetic constness propagation" is a stupid assertion anyway
since it is an implication of the change listed before ("calculate
constness at evaluation"). I'll drop that or rewrite it.

And yes, the third thing should be a separate patch.

>
> Also, it describes the current situation and what is changed but the
> 'why' part is not so clear.
>

Well, because I want (int)__builtin_choose_expr(0, 0, 0) to being
recognized as being a constant expression?


> The changes themselves are very fine.
> And the comments help :)
>
> Luc
>  
>> Signed-off-by: Nicolai Stange <nicstange@gmail.com>
>> ---
>>  evaluate.c                  | 42 ++++++++++++++++++++++++++++++------------
>>  expression.c                | 19 -------------------
>>  validation/constexpr-cast.c | 25 +++++++++++++++++++++++++
>>  3 files changed, 55 insertions(+), 31 deletions(-)
>>  create mode 100644 validation/constexpr-cast.c
>> 
>> diff --git a/evaluate.c b/evaluate.c
>> index 0cf85ae..11917ee 100644
>> --- a/evaluate.c
>> +++ b/evaluate.c
>> @@ -323,7 +323,6 @@ static struct expression * cast_to(struct expression *old, struct symbol *type)
>>  	}
>>  
>>  	expr = alloc_expression(old->pos, EXPR_IMPLIED_CAST);
>> -	expr->flags = old->flags;
>>  	expr->ctype = type;
>>  	expr->cast_type = type;
>>  	expr->cast_expression = old;
>> @@ -2742,17 +2741,36 @@ static struct symbol *evaluate_cast(struct expression *expr)
>>  
>>  	class1 = classify_type(ctype, &t1);
>>  
>> -	/* cast to non-numeric type -> not an arithmetic expression */
>> -	if (!(class1 & TYPE_NUM))
>> -		expr_clear_flag(&expr->flags, EXPR_FLAG_ARITH_CONST_EXPR);
>> -	/* cast to float type -> not an integer constant expression */
>> -	else if (class1 & TYPE_FLOAT)
>> -		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
>> -	/* if argument turns out to be not an integer constant expression *and*
>> -	   it was not a floating literal to start with -> too bad */
>> -	else if (!(target->flags &
>> -			(EXPR_FLAG_INT_CONST_EXPR | EXPR_FLAG_FP_CONST)))
>> -		expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
>> +	if (!(class1 & TYPE_NUM)) {
>> +		/*
>> +		 * Casts of integer literals to pointer type yield
>> +		 * address constants [6.6(9)].
>> +		 */
>> +		if (class1 & TYPE_PTR &&
>> +			(target->flags & EXPR_FLAG_INT_CONST)) {
>> +			expr_set_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
>> +		}
>> +	} else {
>> +		expr->flags = target->flags;
>> +		expr_flags_decay_consts(&expr->flags);
>> +		/*
>> +		 * Casts to numeric types never result in address
>> +		 * constants [6.6(9)].
>> +		 */
>> +		expr_clear_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
>> +		/*
>> +		 * Cast to float type -> not an integer constant
>> +		 * expression [6.6(6)].
>> +		 */
>> +		if (class1 & TYPE_FLOAT)
>> +			expr_clear_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
>> +		/*
>> +		 * Casts of float literals to integer type results in
>> +		 * a constant integer expression [6.6(6)].
>> +		 */
>> +		else if (target->flags & EXPR_FLAG_FP_CONST)
>> +			expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
>> +	}
>>  
>>  	/*
>>  	 * You can always throw a value away by casting to
>> diff --git a/expression.c b/expression.c
>> index eccdb5a..33f4581 100644
>> --- a/expression.c
>> +++ b/expression.c
>> @@ -725,25 +725,6 @@ static struct token *cast_expression(struct token *token, struct expression **tr
>>  			if (!v)
>>  				return token;
>>  			cast->cast_expression = v;
>> -
>> -			cast->flags = v->flags;
>> -			expr_flags_decay_consts(&cast->flags);
>> -			/*
>> -			 * Up to now, we missed the (int).0 case here
>> -			 * which should really get a
>> -			 * EXPR_FLAG_INT_CONST_EXPR marker. Also,
>> -			 * conversion to non-numeric types is not
>> -			 * properly reflected up to this point.
>> -			 * However, we do not know until evaluation.
>> -			 * For the moment, in order to preserve
>> -			 * semantics, speculatively set
>> -			 * EXPR_FLAG_INT_CONST_EXPR if
>> -			 * EXPR_FLAG_FP_CONST is set. evaluate_cast()
>> -			 * will unset inappropriate flags again after
>> -			 * examining type information.
>> -			 */
>> -			if (v->flags & EXPR_FLAG_FP_CONST)
>> -				cast->flags |= EXPR_FLAG_INT_CONST_EXPR;
>>  			return token;
>>  		}
>>  	}
>> diff --git a/validation/constexpr-cast.c b/validation/constexpr-cast.c
>> new file mode 100644
>> index 0000000..2706961
>> --- /dev/null
>> +++ b/validation/constexpr-cast.c
>> @@ -0,0 +1,25 @@
>> +static int a[] = {
>> +	[(int)0] = 0,		// OK
>> +	[(int)(int)0] = 0,	// OK
>> +	[(int)0.] = 0,		// OK
>> +	[(int)(int)0.] = 0,	// OK
>> +	[(int)__builtin_choose_expr(0, 0, 0)] = 0,	// OK
>> +	[(int)__builtin_choose_expr(0, 0, 0.)] = 0,	// OK
>> +
>> +	[(int)(float)0] = 0,	// KO
>> +	[(int)(float)0.] = 0,	// KO
>> +
>> +	[(int)(void*)0] = 0,	// KO
>> +	[(int)(void*)0.] = 0,	// KO
>> +
>> +};
>> +/*
>> + * check-name: Expression constness propagation in casts
>> + *
>> + * check-error-start
>> +constexpr-cast.c:9:11: error: bad integer constant expression
>> +constexpr-cast.c:10:11: error: bad integer constant expression
>> +constexpr-cast.c:12:11: error: bad integer constant expression
>> +constexpr-cast.c:13:11: error: bad integer constant expression
>> + * check-error-end
>> + */
>> -- 
>> 2.7.0
>> 
>> --
>> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
>> the body of a message to majordomo@vger.kernel.org
>> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 03/13] expression: examine constness of binops and alike at evaluation only ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 03/13] expression: examine constness of binops and alike at evaluation only
Date: Mon, 25 Jan 2016 14:52:14 +0000
Message-ID: <87h9i1g19d.fsf () gmail ! com>
--------------------
Currently, the propagation of expressions' constness flags through
binary operations, compare and logical expressions is done in two
steps:
- Several flags are speculatively set at expression parsing time
- and possibly cleared again at evaluation time.

Set aside this unfortunate split of code, the early propagation of
constness flags is not able to recognize constant expressions such as
  0 + __builtin_choose_expr(0, 0, 0)
  0 < __builtin_choose_expr(0, 0, 0)
  0 && __builtin_choose_expr(0, 0, 0)
since the final expression to be thrown into the binop-like expression
is known only after evaluation.

Move the whole calculation of binary operations', compare and logical
expressions' constness flags to the evaluation phase.

Introduce support for tracking arithmetic constness propagation through
binop-like expressions.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                   | 25 +++++++++----------------
 expression.c                 |  3 ---
 validation/constexpr-binop.c | 33 +++++++++++++++++++++++++++++++++
 3 files changed, 42 insertions(+), 19 deletions(-)
 create mode 100644 validation/constexpr-binop.c

diff --git a/evaluate.c b/evaluate.c
index 11917ee..5e3e2ca 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -878,11 +878,9 @@ static struct symbol *evaluate_logical(struct expression *expr)
 
 	/* the result is int [6.5.13(3), 6.5.14(3)] */
 	expr->ctype = &int_ctype;
-	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags &
-				EXPR_FLAG_INT_CONST_EXPR))
-			expr->flags = EXPR_FLAG_NONE;
-	}
+	expr->flags = expr->left->flags & expr->right->flags;
+	expr_flags_decay_consts(&expr->flags);
+	expr_clear_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
 	return &int_ctype;
 }
 
@@ -893,14 +891,11 @@ static struct symbol *evaluate_binop(struct expression *expr)
 	int rclass = classify_type(expr->right->ctype, &rtype);
 	int op = expr->op;
 
-	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags &
-				EXPR_FLAG_INT_CONST_EXPR))
-			expr->flags = EXPR_FLAG_NONE;
-	}
-
 	/* number op number */
 	if (lclass & rclass & TYPE_NUM) {
+		expr->flags = expr->left->flags & expr->right->flags;
+		expr_flags_decay_consts(&expr->flags);
+
 		if ((lclass | rclass) & TYPE_FLOAT) {
 			switch (op) {
 			case '+': case '-': case '*': case '/':
@@ -1001,11 +996,9 @@ static struct symbol *evaluate_compare(struct expression *expr)
 	struct symbol *ctype;
 	const char *typediff;
 
-	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags &
-				EXPR_FLAG_INT_CONST_EXPR))
-			expr->flags = EXPR_FLAG_NONE;
-	}
+	expr->flags = left->flags & right->flags;
+	expr_flags_decay_consts(&expr->flags);
+	expr_clear_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
 
 	/* Type types? */
 	if (is_type_type(ltype) && is_type_type(rtype))
diff --git a/expression.c b/expression.c
index 33f4581..e49a19d 100644
--- a/expression.c
+++ b/expression.c
@@ -146,7 +146,6 @@ static struct token *builtin_types_compatible_p_expr(struct token *token,
 {
 	struct expression *expr = alloc_expression(
 		token->pos, EXPR_COMPARE);
-	expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 	expr->op = SPECIAL_EQUAL;
 	token = token->next;
 	if (!match_op(token, '('))
@@ -761,8 +760,6 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 				sparse_error(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
-			top->flags = left->flags & right->flags;	\
-			expr_flags_decay_consts(&top->flags);		\
 			top->op = op;					\
 			top->left = left;				\
 			top->right = right;				\
diff --git a/validation/constexpr-binop.c b/validation/constexpr-binop.c
new file mode 100644
index 0000000..85a88e3
--- /dev/null
+++ b/validation/constexpr-binop.c
@@ -0,0 +1,33 @@
+static int a[] = {
+	[0 + 0] = 0,						// OK
+	[0 + 0.] = 0,						// KO
+	[(void*)0 + 0] = 0,					// KO
+	[0 + __builtin_choose_expr(0, 0, 0)] = 0,		// OK
+	[0 + __builtin_choose_expr(0, 0., 0)] = 0,		// OK
+	[0 + __builtin_choose_expr(0, 0, 0.)] = 0,		// KO
+	[0 < 0] = 0,						// OK
+	[0 < 0.] = 0,						// KO
+	[0 < __builtin_choose_expr(0, 0, 0)] = 0,		// OK
+	[0 < __builtin_choose_expr(0, 0., 0)] = 0,		// OK
+	[0 < __builtin_choose_expr(0, 0, 0.)] = 0,		// KO
+	[0 && 0] = 0,						// OK
+	[0 && 0.] = 0,						// KO
+	[0 && __builtin_choose_expr(0, 0, 0)] = 0,		// OK
+	[0 && __builtin_choose_expr(0, 0., 0)] = 0,		// OK
+	[0 && __builtin_choose_expr(0, 0, 0.)] = 0,		// KO
+	[0 + __builtin_types_compatible_p(int, float)] = 0,	// OK
+};
+
+/*
+ * check-name: Expression constness propagation in binops and alike
+ *
+ * check-error-start
+constexpr-binop.c:3:12: error: bad constant expression
+constexpr-binop.c:4:19: error: bad integer constant expression
+constexpr-binop.c:7:12: error: bad constant expression
+constexpr-binop.c:9:12: error: bad integer constant expression
+constexpr-binop.c:12:12: error: bad integer constant expression
+constexpr-binop.c:14:12: error: bad integer constant expression
+constexpr-binop.c:17:12: error: bad integer constant expression
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 03/13] expression: examine constness of binops and alike at evaluation only
Date: Tue, 26 Jan 2016 00:59:32 +0000
Message-ID: <20160126005931.GA46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:52:14PM +0100, Nicolai Stange wrote:
> @@ -1001,11 +996,9 @@ static struct symbol *evaluate_compare(struct expression *expr)
>  	struct symbol *ctype;
>  	const char *typediff;
>  
> -	if (expr->flags) {
> -		if (!(expr->left->flags & expr->right->flags &
> -				EXPR_FLAG_INT_CONST_EXPR))
> -			expr->flags = EXPR_FLAG_NONE;
> -	}
> +	expr->flags = left->flags & right->flags;
> +	expr_flags_decay_consts(&expr->flags);
> +	expr_clear_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);

Related to the [0 < 0.0] test case, shouldn't this be (re) done after
the call to usual_conversions() ?


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 03/13] expression: examine constness of binops and alike at evaluation only
Date: Tue, 26 Jan 2016 17:24:40 +0000
Message-ID: <20160126172438.GA989 () macpro ! local>
--------------------
On Tue, Jan 26, 2016 at 04:50:07PM +0100, Nicolai Stange wrote:
> Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:
> 
> > On Mon, Jan 25, 2016 at 03:52:14PM +0100, Nicolai Stange wrote:
> >> +	[0 < 0.] = 0,						// KO
> >
> > It's not clear to me what the standrad says about this case.
> > What about the constness of 'usual artihmetic conversions' ?
> > Also GCC don't complain on this one.
> 
> Within the square brackets, an integer constant expression is needed.
> 
> That's 6.6(6). "Floating constants that are immediate operands of casts"
> are allowed. Implicitly promoted types are not, at least to my
> interpretation.

Yes, I saw that the standard isn't explicit about it.
The way I see things is:
- I don't see any reason why an explicit conversion would preserve
  constness while an implicit one would not.
- intuitively, when I read the code I see that the result of this
  expression is can be known at compile time.

But well ... I have the same issue with [(int) (0 + 0.0)] which
is clearly not allowed by the standard while [(int) 0.0] is.

Maybe those should be relaxed latter and we can invoke 6.6(10):
	An implementation may accept other forms of constant expressions

OTOH, who cares about floats ;)


Reading a bit more about it ...

For the designator in the array initializer (but also probably elsewhere)
6.7.8(6) first uses 
	 [ <i>constant-expression<\i> ]
and then
	and the expression shall be an integer constant expression.

Can this last 'integer constant expression' be interpreted as 'constant
expression of integer type'?
This could be considered to be coherent with the footnote 99) in 6.6(6)
followed by 6.6(7).

I don't know, it's something for language lawyers.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 03/13] expression: examine constness of binops and alike at evaluation only
Date: Wed, 27 Jan 2016 18:00:03 +0000
Message-ID: <20160127180000.GA13556 () macbook ! lan>
--------------------
On Wed, Jan 27, 2016 at 11:42:32AM +0100, Nicolai Stange wrote:
> Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

...

> > Maybe those should be relaxed latter and we can invoke 6.6(10):
> > 	An implementation may accept other forms of constant expressions
> >
> > OTOH, who cares about floats ;)
> 
> A true word. Thus, I suggest not to introduce any additional form of
> constness at this moment. In the end, we wanted to be stricter than gcc.
> 
> If real world problems arise, we can easily return to that question.

It's exactly what I meant.
 
...

> I'm sure that if the standard authors' real intents had been to allow
> arithmetic constant expressions of integer types at this place, they
> would have said so and not used the well defined term "integer constant
> expression" at this point.

I would definitively appreciate the standard being less ambiguous.
And I find the footnote 99) in 6.6 really confusing.
 
> > This could be considered to be coherent with the footnote 99) in 6.6(6)
> > followed by 6.6(7).
> >
> > I don't know, it's something for language lawyers.
> 
> If you don't agree with my interpretation, we could very well try to get
> some language layer into our boat.
> 
> OTOH, if you agree that we could safely leave the semantics as they
> currently are, I could just go on and prepare v3...

It's not that I really disagree with your interpretation, nor that I totally agree
with it. It's more me playing devil's advocate, insuring that the reasonable cases
are well covered.
It's the fact that GCC and your code differ on this point that made me stop at it
because it could make your changes less valuable which we don't want.

My remark about a language lawyer was not a serious one, it was more a way to say
	"let's not spend more time on it for now".

Please go on.
And with what you have put in place for the expression constness it will be very easy
to relax some of the rules when there will be some needs for it.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 04/13] expression: examine constness of preops at evaluation only ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 04/13] expression: examine constness of preops at evaluation only
Date: Tue, 26 Jan 2016 01:10:18 +0000
Message-ID: <20160126011017.GB46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:53:38PM +0100, Nicolai Stange wrote:
> Currently, the propagation of expressions' constness flags through
> prefix expressions is done in two steps:
> - Several flags are speculatively set at expression parsing time
> - and possibly cleared again at evaluation time.
> 
> Set aside this unfortunate split of code, the early propagation of
> constness flags is not able to recognize constant expressions such as
>   -__builtin_choose_expr(0, 0, 0)
>   ~__builtin_choose_expr(0, 0, 0)
>   !__builtin_choose_expr(0, 0, 0)
> since the final expression to be thrown into the prefix expression is
> known only after evaluation.
> 
> Move the whole calculation of prefix expressions' constness flags to
> the evaluation phase.
> 
> Introduce support for tracking arithmetic constness propagation through
> prefix expressions.

What about replacing the whole description with something::
	Move the whole calculation of prefix expressions' constness flags to
	the evaluation phase so that we can now recognize constant expressions
	such as
	      -__builtin_choose_expr(0, 0, 0)
	      ~__builtin_choose_expr(0, 0, 0)
	      !__builtin_choose_expr(0, 0, 0)

	and adding further explanation after this, if really needed?


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 05/13] expression: examine constness of conditionals at evaluation only ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 05/13] expression: examine constness of conditionals at evaluation only
Date: Tue, 26 Jan 2016 01:16:30 +0000
Message-ID: <20160126011629.GC46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:55:09PM +0100, Nicolai Stange wrote:
> Currently, the propagation of expressions' constness flags through
> conditional expressions is done in two steps:
> - Several flags are speculatively set at expression parsing time
> - and possibly cleared again at evaluation time.
> 
> Set aside this unfortunate split of code, the early propagation of
> constness flags is not able to recognize constant expressions such as
>   0 ? __builtin_choose_expr(0, 0, 0) : 0
>   0 ? 0 : __builtin_choose_expr(0, 0, 0)
> since the final expression to be thrown into the conditional
> expression is known only after evaluation.
> 
> Move the whole calculation of conditional expressions' constness flags
> to the evaluation phase.
> 
> Introduce support for tracking arithmetic constness propagation through
> conditional expressions.

Same comments about the description as for the previous patches.

Good otherwise.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 06/13] expression, evaluate: add support for recognizing address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 06/13] expression, evaluate: add support for recognizing address constants
Date: Mon, 25 Jan 2016 14:56:23 +0000
Message-ID: <874me1g12g.fsf () gmail ! com>
--------------------
Address constants [6.6(9)] constitute one of the types of constant
expressions allowed in initializers [6.6(7)] for static storage
duration objects [6.7.8(4)].

Introduce support for recognizing address constants created either
- explicitly by referencing a static storage duration object by means
  of the unary & operator
- or implicitly by the use of an expression of array or function type.

Treat string literals as address constants.

Initially tag an expression as being an address constant at the
primary expression level, i.e. upon encountering a symbol designating
an object of static storage duration in primary_expression().

Carry these flags over to the *-preop wrapped expression created by
evaluate_symbol_expression().

For the special case of string literals, tag them as address constants
in evaluate_string().

Take care in evaluate_ptr_add() and evaluate_offset()
to properly propagate the address constness flags from
subexpressions to their parent expressions, namely the array ([])
or structure member dereference (->, .) expressions.

Finally, do not strip away an *-preop wrapped expression's constness
flags in evaluate_addressof().

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c   | 18 +++++++++++++++++-
 expression.c |  8 ++++++++
 2 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index 97da51d..70f419f 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -70,9 +70,11 @@ static struct symbol *evaluate_symbol_expression(struct expression *expr)
 	addr->symbol = sym;
 	addr->symbol_name = expr->symbol_name;
 	addr->ctype = &lazy_ptr_ctype;	/* Lazy evaluation: we need to do a proper job if somebody does &sym */
+	addr->flags = expr->flags;
 	expr->type = EXPR_PREOP;
 	expr->op = '*';
 	expr->unop = addr;
+	expr->flags = EXPR_FLAG_NONE;
 
 	/* The type of a symbol is the symbol itself! */
 	expr->ctype = sym;
@@ -106,6 +108,7 @@ static struct symbol *evaluate_string(struct expression *expr)
 	
 	addr->symbol = sym;
 	addr->ctype = &lazy_ptr_ctype;
+	expr_set_flag(&addr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
 
 	expr->type = EXPR_PREOP;
 	expr->op = '*';
@@ -563,6 +566,14 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
 	classify_type(degenerate(expr->left), &ctype);
 	base = examine_pointer_target(ctype);
 
+	/*
+	 * An address constant +/- an integer constant expression
+	 * yields an address constant again [6.6(7)].
+	 */
+	if((expr->left->flags & EXPR_FLAG_ADDR_CONST_EXPR) &&
+		(expr->right->flags & EXPR_FLAG_INT_CONST_EXPR))
+		expr_set_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
+
 	if (!base) {
 		expression_error(expr, "missing type information");
 		return NULL;
@@ -1678,7 +1689,6 @@ static struct symbol *evaluate_addressof(struct expression *expr)
 	}
 	ctype = op->ctype;
 	*expr = *op->unop;
-	expr->flags = EXPR_FLAG_NONE;
 
 	if (expr->type == EXPR_SYMBOL) {
 		struct symbol *sym = expr->symbol;
@@ -1945,6 +1955,12 @@ static struct expression *evaluate_offset(struct expression *expr, unsigned long
 	 * we ever take the address of this member dereference..
 	 */
 	add->ctype = &lazy_ptr_ctype;
+	/*
+	 * An address constant +/- an integer constant expression
+	 * yields an address constant again [6.6(7)].
+	 */
+	add->flags |= expr->flags;
+
 	return add;
 }
 
diff --git a/expression.c b/expression.c
index 792c2a5..afc4f39 100644
--- a/expression.c
+++ b/expression.c
@@ -437,6 +437,14 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		}
 		expr->symbol_name = token->ident;
 		expr->symbol = sym;
+
+		/*
+		 * A pointer to an lvalue designating a static storage
+		 * duration object is an address constant [6.6(9)].
+		 */
+		if(sym && (sym->ctype.modifiers & (MOD_TOPLEVEL | MOD_STATIC)))
+			expr_set_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
+
 		token = next;
 		break;
 	}
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 06/13] expression, evaluate: add support for recognizing address constants
Date: Tue, 26 Jan 2016 01:27:12 +0000
Message-ID: <20160126012711.GD46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:56:23PM +0100, Nicolai Stange wrote:
> Address constants [6.6(9)] constitute one of the types of constant
> expressions allowed in initializers [6.6(7)] for static storage
> duration objects [6.7.8(4)].
> 
> Introduce support for recognizing address constants created either
> - explicitly by referencing a static storage duration object by means
>   of the unary & operator
> - or implicitly by the use of an expression of array or function type.
> 
> Treat string literals as address constants.
> 
> Initially tag an expression as being an address constant at the
> primary expression level, i.e. upon encountering a symbol designating
> an object of static storage duration in primary_expression().
> 
> Carry these flags over to the *-preop wrapped expression created by
> evaluate_symbol_expression().
> 
> For the special case of string literals, tag them as address constants
> in evaluate_string().
> 
> Take care in evaluate_ptr_add() and evaluate_offset()
> to properly propagate the address constness flags from
> subexpressions to their parent expressions, namely the array ([])
> or structure member dereference (->, .) expressions.
> 
> Finally, do not strip away an *-preop wrapped expression's constness
> flags in evaluate_addressof().

There is two much thing in the description, this is a sure sign that the patch
should be splitted, like putting the part concerning strings in a separate one.

> @@ -1678,7 +1689,6 @@ static struct symbol *evaluate_addressof(struct expression *expr)
>  	}
>  	ctype = op->ctype;
>  	*expr = *op->unop;
> -	expr->flags = EXPR_FLAG_NONE;

Is this because it's already initialized so by the allocator?
if so, it can be moved to the patch that add this initialization
(because it's unrelated to the current change).


Good otherwise.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 06/13] expression, evaluate: add support for recognizing address constants
Date: Tue, 26 Jan 2016 03:10:49 +0000
Message-ID: <20160126031048.GL46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 03:56:23PM +0100, Nicolai Stange wrote:
> @@ -563,6 +566,14 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
>  	classify_type(degenerate(expr->left), &ctype);
>  	base = examine_pointer_target(ctype);
>  
> +	/*
> +	 * An address constant +/- an integer constant expression
> +	 * yields an address constant again [6.6(7)].
> +	 */
> +	if((expr->left->flags & EXPR_FLAG_ADDR_CONST_EXPR) &&

Missing ' ' in 'if('

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 07/13] evaluate: check static storage duration objects' intializers' constness ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 07/13] evaluate: check static storage duration objects' intializers' constness
Date: Tue, 26 Jan 2016 20:18:31 +0000
Message-ID: <20160126201830.GA2099 () macpro ! local>
--------------------
On Tue, Jan 26, 2016 at 06:56:39PM +0100, Luc Van Oostenryck wrote:
> On Tue, Jan 26, 2016 at 05:08:16PM +0100, Nicolai Stange wrote:
> 
> > The -Wstatic-initializer-not-const choice made in the current series is
> > simply a workaround, any better suggestions welcome!
> > 
> > I'm also fine with -Wstatic-initializer.
> > 
> > Comments?
> 
> I dunno.
> Better to leave it so for now, I think.

I see that clang has -Wconstexpr-not-const, which is not too long
and still quite explicit and can be used for others things than
initializers.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 08/13] expression: recognize references to labels as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 08/13] expression: recognize references to labels as address constants
Date: Mon, 25 Jan 2016 14:59:37 +0000
Message-ID: <87vb6hemcm.fsf () gmail ! com>
--------------------
As an extension, GCC allows labels to be referenced a la
  label1:
  ...

  void *ptr = &&label1;

Tag these label references as being address constants allowing them
to be used as initializers for objects of static storage duration.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 expression.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/expression.c b/expression.c
index afc4f39..b82a036 100644
--- a/expression.c
+++ b/expression.c
@@ -683,6 +683,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 				sym->ctype.modifiers |= MOD_ADDRESSABLE;
 				add_symbol(&function_computed_target_list, sym);
 			}
+			expr_set_flag(&label->flags, EXPR_FLAG_ADDR_CONST_EXPR);
 			label->label_symbol = sym;
 			*tree = label;
 			return token->next->next;
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 09/13] expression: examine constness of __builtin_offsetof at evaluation only ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 09/13] expression: examine constness of __builtin_offsetof at evaluation only
Date: Mon, 25 Jan 2016 15:00:48 +0000
Message-ID: <87r3h5eman.fsf () gmail ! com>
--------------------
Currently, the determination of a __builtin_offsetof() expressions'
constness flags is done in two steps:
- Several flags are speculatively set at expression parsing time
- and possibly cleared again at evaluation if the member expression
  includes a non-const array index like in
    __builtin_offsetof(struct A, a.b[non_const_foo])

For consistency with other expression types' evaluation, defer the
determination of a __builtin_offsetof() expression's constness to
evaluation time, too.

Furthermore, carry an array index expression's constness flags
through the implicit cast to size_t type.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                      | 13 ++++++++-----
 expression.c                    |  3 ---
 validation/constexpr-offsetof.c | 21 +++++++++++++++++++++
 3 files changed, 29 insertions(+), 8 deletions(-)
 create mode 100644 validation/constexpr-offsetof.c

diff --git a/evaluate.c b/evaluate.c
index e3b08e4..d32f5a4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3001,7 +3001,6 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		}
 		ctype = field;
 		expr->type = EXPR_VALUE;
-		expr->flags = EXPR_FLAG_NONE;
 		expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 		expr->value = offset;
 		expr->taint = 0;
@@ -3020,7 +3019,6 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		ctype = ctype->ctype.base_type;
 		if (!expr->index) {
 			expr->type = EXPR_VALUE;
-			expr->flags = EXPR_FLAG_NONE;
 			expr_set_flag(&expr->flags, EXPR_FLAG_INT_CONST_EXPR);
 			expr->value = 0;
 			expr->taint = 0;
@@ -3028,13 +3026,18 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		} else {
 			struct expression *idx = expr->index, *m;
 			struct symbol *i_type = evaluate_expression(idx);
+			unsigned old_idx_flags;
 			int i_class = classify_type(i_type, &i_type);
+
 			if (!is_int(i_class)) {
 				expression_error(expr, "non-integer index");
 				return NULL;
 			}
 			unrestrict(idx, i_class, &i_type);
+			old_idx_flags = idx->flags;
 			idx = cast_to(idx, size_t_ctype);
+			idx->flags |= old_idx_flags;
+			expr_flags_decay_consts(&idx->flags);
 			m = alloc_const_expression(expr->pos,
 						   bits_to_bytes(ctype->bit_size));
 			m->ctype = size_t_ctype;
@@ -3045,19 +3048,19 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 			expr->op = '*';
 			expr->ctype = size_t_ctype;
 			expr->flags = m->flags & idx->flags;
+			expr_flags_decay_consts(&expr->flags);
 		}
 	}
 	if (e) {
 		struct expression *copy = __alloc_expression(0);
-		unsigned char flags_mask = EXPR_FLAG_NONE;
 		*copy = *expr;
 		if (e->type == EXPR_OFFSETOF)
 			e->in = ctype;
 		if (!evaluate_expression(e))
 			return NULL;
 		expr->type = EXPR_BINOP;
-		expr_set_flag(&flags_mask, EXPR_FLAG_INT_CONST_EXPR);
-		expr->flags = e->flags & copy->flags & flags_mask;
+		expr->flags = e->flags & copy->flags;
+		expr_flags_decay_consts(&expr->flags);
 		expr->op = '+';
 		expr->ctype = size_t_ctype;
 		expr->left = copy;
diff --git a/expression.c b/expression.c
index b82a036..4ecc865 100644
--- a/expression.c
+++ b/expression.c
@@ -199,7 +199,6 @@ static struct token *builtin_offsetof_expr(struct token *token,
 			return expect(token, ')', "at end of __builtin_offset");
 		case SPECIAL_DEREFERENCE:
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			expr_set_flag(&e->flags, EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			*p = e;
 			p = &e->down;
@@ -207,7 +206,6 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '.':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			expr_set_flag(&e->flags, EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '.';
 			if (token_type(token) != TOKEN_IDENT) {
 				sparse_error(token->pos, "Expected member name");
@@ -219,7 +217,6 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '[':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			expr_set_flag(&e->flags, EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			token = parse_expression(token, &e->index);
 			token = expect(token, ']',
diff --git a/validation/constexpr-offsetof.c b/validation/constexpr-offsetof.c
new file mode 100644
index 0000000..d1697b0
--- /dev/null
+++ b/validation/constexpr-offsetof.c
@@ -0,0 +1,21 @@
+struct A {
+	int a[1];
+	int b;
+};
+
+extern int c;
+
+static int o[] = {
+	[__builtin_offsetof(struct A, b)] = 0,		// OK
+	[__builtin_offsetof(struct A, a[0])] = 0,	// OK
+	[__builtin_offsetof(struct A, a[0*0])] = 0,	// OK
+	[__builtin_offsetof(struct A, a[c])] = 0	// KO
+};
+
+/*
+ * check-name: __builtin_offsetof() constness verification.
+ *
+ * check-error-start
+constexpr-offsetof.c:12:39: error: bad constant expression
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 09/13] expression: examine constness of __builtin_offsetof at evaluation only
Date: Tue, 26 Jan 2016 01:57:09 +0000
Message-ID: <20160126015708.GG46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 04:00:48PM +0100, Nicolai Stange wrote:
> Currently, the determination of a __builtin_offsetof() expressions'
> constness flags is done in two steps:
> - Several flags are speculatively set at expression parsing time
> - and possibly cleared again at evaluation if the member expression
>   includes a non-const array index like in
>     __builtin_offsetof(struct A, a.b[non_const_foo])
> 
> For consistency with other expression types' evaluation, defer the
> determination of a __builtin_offsetof() expression's constness to
> evaluation time, too.
> 
> Furthermore, carry an array index expression's constness flags
> through the implicit cast to size_t type.

Better to split this into two patches.
 
> @@ -3028,13 +3026,18 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
>  		} else {
>  			struct expression *idx = expr->index, *m;
>  			struct symbol *i_type = evaluate_expression(idx);
> +			unsigned old_idx_flags;
>  			int i_class = classify_type(i_type, &i_type);
> +
>  			if (!is_int(i_class)) {
>  				expression_error(expr, "non-integer index");
>  				return NULL;
>  			}
>  			unrestrict(idx, i_class, &i_type);
> +			old_idx_flags = idx->flags;
>  			idx = cast_to(idx, size_t_ctype);
> +			idx->flags |= old_idx_flags;
> +			expr_flags_decay_consts(&idx->flags);
>  			m = alloc_const_expression(expr->pos,
>  						   bits_to_bytes(ctype->bit_size));
>  			m->ctype = size_t_ctype;

It's not clear at all to me why this is needed.
Why cast_to() can't set itself the right value for idx->flags?


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 09/13] expression: examine constness of __builtin_offsetof at evaluation only
Date: Mon, 01 Feb 2016 03:06:49 +0000
Message-ID: <87twltf7sm.fsf () gmail ! com>
--------------------
Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

> On Mon, Jan 25, 2016 at 04:00:48PM +0100, Nicolai Stange wrote:
>> Currently, the determination of a __builtin_offsetof() expressions'
>> constness flags is done in two steps:
>> - Several flags are speculatively set at expression parsing time
>> - and possibly cleared again at evaluation if the member expression
>>   includes a non-const array index like in
>>     __builtin_offsetof(struct A, a.b[non_const_foo])
>> 
>> For consistency with other expression types' evaluation, defer the
>> determination of a __builtin_offsetof() expression's constness to
>> evaluation time, too.
>> 
>> Furthermore, carry an array index expression's constness flags
>> through the implicit cast to size_t type.
>
> Better to split this into two patches.
>  
>> @@ -3028,13 +3026,18 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
>>  		} else {
>>  			struct expression *idx = expr->index, *m;
>>  			struct symbol *i_type = evaluate_expression(idx);
>> +			unsigned old_idx_flags;
>>  			int i_class = classify_type(i_type, &i_type);
>> +
>>  			if (!is_int(i_class)) {
>>  				expression_error(expr, "non-integer index");
>>  				return NULL;
>>  			}
>>  			unrestrict(idx, i_class, &i_type);
>> +			old_idx_flags = idx->flags;
>>  			idx = cast_to(idx, size_t_ctype);
>> +			idx->flags |= old_idx_flags;
>> +			expr_flags_decay_consts(&idx->flags);
>>  			m = alloc_const_expression(expr->pos,
>>  						   bits_to_bytes(ctype->bit_size));
>>  			m->ctype = size_t_ctype;
>
> It's not clear at all to me why this is needed.
> Why cast_to() can't set itself the right value for idx->flags?

cast_to() is for implicit casts and to be honest, I don't know what the
->flags should be set to.

Also, this is the only place in the whole code where preserving the
flags over a cast_to() call is needed.

Furthermore, we could get rid of the flags' save and restore by moving
the calculation of expr->flags in front of the cast_to() invocation --
all other cast_to() actually do it this way.

However, I think, it's better to have the assignment to expr->flags
grouped with the rest of the assignments to expr's members.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 09/13] expression: examine constness of __builtin_offsetof at evaluation only
Date: Mon, 01 Feb 2016 03:06:49 +0000
Message-ID: <87twltf7sm.fsf () gmail ! com>
--------------------
Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

> On Mon, Jan 25, 2016 at 04:00:48PM +0100, Nicolai Stange wrote:
>> Currently, the determination of a __builtin_offsetof() expressions'
>> constness flags is done in two steps:
>> - Several flags are speculatively set at expression parsing time
>> - and possibly cleared again at evaluation if the member expression
>>   includes a non-const array index like in
>>     __builtin_offsetof(struct A, a.b[non_const_foo])
>> 
>> For consistency with other expression types' evaluation, defer the
>> determination of a __builtin_offsetof() expression's constness to
>> evaluation time, too.
>> 
>> Furthermore, carry an array index expression's constness flags
>> through the implicit cast to size_t type.
>
> Better to split this into two patches.
>  
>> @@ -3028,13 +3026,18 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
>>  		} else {
>>  			struct expression *idx = expr->index, *m;
>>  			struct symbol *i_type = evaluate_expression(idx);
>> +			unsigned old_idx_flags;
>>  			int i_class = classify_type(i_type, &i_type);
>> +
>>  			if (!is_int(i_class)) {
>>  				expression_error(expr, "non-integer index");
>>  				return NULL;
>>  			}
>>  			unrestrict(idx, i_class, &i_type);
>> +			old_idx_flags = idx->flags;
>>  			idx = cast_to(idx, size_t_ctype);
>> +			idx->flags |= old_idx_flags;
>> +			expr_flags_decay_consts(&idx->flags);
>>  			m = alloc_const_expression(expr->pos,
>>  						   bits_to_bytes(ctype->bit_size));
>>  			m->ctype = size_t_ctype;
>
> It's not clear at all to me why this is needed.
> Why cast_to() can't set itself the right value for idx->flags?

cast_to() is for implicit casts and to be honest, I don't know what the
->flags should be set to.

Also, this is the only place in the whole code where preserving the
flags over a cast_to() call is needed.

Furthermore, we could get rid of the flags' save and restore by moving
the calculation of expr->flags in front of the cast_to() invocation --
all other cast_to() actually do it this way.

However, I think, it's better to have the assignment to expr->flags
grouped with the rest of the assignments to expr's members.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS ===

From: Petr Mladek <pmladek () suse ! com>
To: linux-arm-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:24:21 +0000
Message-ID: <20160708152421.GG3556 () pathway ! suse ! cz>
--------------------
On Fri 2016-07-08 17:07:09, Torsten Duwe wrote:
> On Fri, Jul 08, 2016 at 04:58:00PM +0200, Petr Mladek wrote:
> > On Mon 2016-06-27 17:17:17, Torsten Duwe wrote:
> > > Once gcc is enhanced to optionally generate NOPs at the beginning
> > > of each function, like the concept proven in
> > > https://gcc.gnu.org/ml/gcc-patches/2016-04/msg01671.html
> > > (sans the "fprintf (... pad_size);", which spoils the data structure
> > > for kernel use), the generated pads can nicely be used to reroute
> > > function calls for tracing/profiling, or live patching.
> > > diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c
> > > index ebecf9a..917065c 100644
> > > --- a/arch/arm64/kernel/ftrace.c
> > > +++ b/arch/arm64/kernel/ftrace.c
> > > @@ -39,6 +39,12 @@ static int ftrace_modify_code(unsigned long pc, u32 old, u32 new,
> > >  		if (aarch64_insn_read((void *)pc, &replaced))
> > >  			return -EFAULT;
> > >  
> > > +		/* If we already have what we'll finally want,
> > > +		 * report success. This is needed on startup.
> > > +		 */
> > > +		if (replaced == new)
> > > +			return 0;
> > 
> > This looks strange. I wonder if it actually hides a real bug that we
> > modify the code twice or so.
> 
> Not at all. All "profilers" we abused so far generate code that needs to
> be disabled on boot first. prolog-pad generates nops, initially.

Yeah, but I cannot find this kind of check in other architectures.
I checked arch/x86/kernel/ftrace.c, arch/s390/kernel/ftrace.c, and
arch/powerpc/kernel/ftrace.c. These all support ftrace with
regs and livepatching.

Best Regards,
Petr

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Josh Poimboeuf <jpoimboe () redhat ! com>
To: linux-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:48:24 +0000
Message-ID: <20160708154824.ikq45dgk2auigqn7 () treble>
--------------------
On Fri, Jul 08, 2016 at 05:24:21PM +0200, Petr Mladek wrote:
> On Fri 2016-07-08 17:07:09, Torsten Duwe wrote:
> > On Fri, Jul 08, 2016 at 04:58:00PM +0200, Petr Mladek wrote:
> > > On Mon 2016-06-27 17:17:17, Torsten Duwe wrote:
> > > > Once gcc is enhanced to optionally generate NOPs at the beginning
> > > > of each function, like the concept proven in
> > > > https://gcc.gnu.org/ml/gcc-patches/2016-04/msg01671.html
> > > > (sans the "fprintf (... pad_size);", which spoils the data structure
> > > > for kernel use), the generated pads can nicely be used to reroute
> > > > function calls for tracing/profiling, or live patching.
> > > > diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c
> > > > index ebecf9a..917065c 100644
> > > > --- a/arch/arm64/kernel/ftrace.c
> > > > +++ b/arch/arm64/kernel/ftrace.c
> > > > @@ -39,6 +39,12 @@ static int ftrace_modify_code(unsigned long pc, u32 old, u32 new,
> > > >  		if (aarch64_insn_read((void *)pc, &replaced))
> > > >  			return -EFAULT;
> > > >  
> > > > +		/* If we already have what we'll finally want,
> > > > +		 * report success. This is needed on startup.
> > > > +		 */
> > > > +		if (replaced == new)
> > > > +			return 0;
> > > 
> > > This looks strange. I wonder if it actually hides a real bug that we
> > > modify the code twice or so.
> > 
> > Not at all. All "profilers" we abused so far generate code that needs to
> > be disabled on boot first. prolog-pad generates nops, initially.
> 
> Yeah, but I cannot find this kind of check in other architectures.
> I checked arch/x86/kernel/ftrace.c, arch/s390/kernel/ftrace.c, and
> arch/powerpc/kernel/ftrace.c. These all support ftrace with
> regs and livepatching.

My understanding is that other arches don't need this check because they
use -mfentry, so they have to modify the "call fentry" instruction to a
nop on startup.

Here, with -fprolog-pad, it's already a nop, so no change is needed.

-- 
Josh
================================================================================

From: Josh Poimboeuf <jpoimboe () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:48:24 +0000
Message-ID: <20160708154824.ikq45dgk2auigqn7 () treble>
--------------------
On Fri, Jul 08, 2016 at 05:24:21PM +0200, Petr Mladek wrote:
> On Fri 2016-07-08 17:07:09, Torsten Duwe wrote:
> > On Fri, Jul 08, 2016 at 04:58:00PM +0200, Petr Mladek wrote:
> > > On Mon 2016-06-27 17:17:17, Torsten Duwe wrote:
> > > > Once gcc is enhanced to optionally generate NOPs at the beginning
> > > > of each function, like the concept proven in
> > > > https://gcc.gnu.org/ml/gcc-patches/2016-04/msg01671.html
> > > > (sans the "fprintf (... pad_size);", which spoils the data structure
> > > > for kernel use), the generated pads can nicely be used to reroute
> > > > function calls for tracing/profiling, or live patching.
> > > > diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c
> > > > index ebecf9a..917065c 100644
> > > > --- a/arch/arm64/kernel/ftrace.c
> > > > +++ b/arch/arm64/kernel/ftrace.c
> > > > @@ -39,6 +39,12 @@ static int ftrace_modify_code(unsigned long pc, u32 old, u32 new,
> > > >  		if (aarch64_insn_read((void *)pc, &replaced))
> > > >  			return -EFAULT;
> > > >  
> > > > +		/* If we already have what we'll finally want,
> > > > +		 * report success. This is needed on startup.
> > > > +		 */
> > > > +		if (replaced == new)
> > > > +			return 0;
> > > 
> > > This looks strange. I wonder if it actually hides a real bug that we
> > > modify the code twice or so.
> > 
> > Not at all. All "profilers" we abused so far generate code that needs to
> > be disabled on boot first. prolog-pad generates nops, initially.
> 
> Yeah, but I cannot find this kind of check in other architectures.
> I checked arch/x86/kernel/ftrace.c, arch/s390/kernel/ftrace.c, and
> arch/powerpc/kernel/ftrace.c. These all support ftrace with
> regs and livepatching.

My understanding is that other arches don't need this check because they
use -mfentry, so they have to modify the "call fentry" instruction to a
nop on startup.

Here, with -fprolog-pad, it's already a nop, so no change is needed.

-- 
Josh
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Poimboeuf <jpoimboe () redhat ! com>
To: linux-arch
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:48:24 +0000
Message-ID: <20160708154824.ikq45dgk2auigqn7 () treble>
--------------------
On Fri, Jul 08, 2016 at 05:24:21PM +0200, Petr Mladek wrote:
> On Fri 2016-07-08 17:07:09, Torsten Duwe wrote:
> > On Fri, Jul 08, 2016 at 04:58:00PM +0200, Petr Mladek wrote:
> > > On Mon 2016-06-27 17:17:17, Torsten Duwe wrote:
> > > > Once gcc is enhanced to optionally generate NOPs at the beginning
> > > > of each function, like the concept proven in
> > > > https://gcc.gnu.org/ml/gcc-patches/2016-04/msg01671.html
> > > > (sans the "fprintf (... pad_size);", which spoils the data structure
> > > > for kernel use), the generated pads can nicely be used to reroute
> > > > function calls for tracing/profiling, or live patching.
> > > > diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c
> > > > index ebecf9a..917065c 100644
> > > > --- a/arch/arm64/kernel/ftrace.c
> > > > +++ b/arch/arm64/kernel/ftrace.c
> > > > @@ -39,6 +39,12 @@ static int ftrace_modify_code(unsigned long pc, u32 old, u32 new,
> > > >  		if (aarch64_insn_read((void *)pc, &replaced))
> > > >  			return -EFAULT;
> > > >  
> > > > +		/* If we already have what we'll finally want,
> > > > +		 * report success. This is needed on startup.
> > > > +		 */
> > > > +		if (replaced == new)
> > > > +			return 0;
> > > 
> > > This looks strange. I wonder if it actually hides a real bug that we
> > > modify the code twice or so.
> > 
> > Not at all. All "profilers" we abused so far generate code that needs to
> > be disabled on boot first. prolog-pad generates nops, initially.
> 
> Yeah, but I cannot find this kind of check in other architectures.
> I checked arch/x86/kernel/ftrace.c, arch/s390/kernel/ftrace.c, and
> arch/powerpc/kernel/ftrace.c. These all support ftrace with
> regs and livepatching.

My understanding is that other arches don't need this check because they
use -mfentry, so they have to modify the "call fentry" instruction to a
nop on startup.

Here, with -fprolog-pad, it's already a nop, so no change is needed.

-- 
Josh
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arm-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:49:38 +0000
Message-ID: <20160708114938.49052cee () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 17:24:21 +0200
Petr Mladek <pmladek@suse.com> wrote:

> On Fri 2016-07-08 17:07:09, Torsten Duwe wrote:
> > On Fri, Jul 08, 2016 at 04:58:00PM +0200, Petr Mladek wrote:  
> > > On Mon 2016-06-27 17:17:17, Torsten Duwe wrote:  
> > > > Once gcc is enhanced to optionally generate NOPs at the beginning
> > > > of each function, like the concept proven in
> > > > https://gcc.gnu.org/ml/gcc-patches/2016-04/msg01671.html
> > > > (sans the "fprintf (... pad_size);", which spoils the data structure
> > > > for kernel use), the generated pads can nicely be used to reroute
> > > > function calls for tracing/profiling, or live patching.
> > > > diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c
> > > > index ebecf9a..917065c 100644
> > > > --- a/arch/arm64/kernel/ftrace.c
> > > > +++ b/arch/arm64/kernel/ftrace.c
> > > > @@ -39,6 +39,12 @@ static int ftrace_modify_code(unsigned long pc, u32 old, u32 new,
> > > >  		if (aarch64_insn_read((void *)pc, &replaced))
> > > >  			return -EFAULT;
> > > >  
> > > > +		/* If we already have what we'll finally want,
> > > > +		 * report success. This is needed on startup.
> > > > +		 */
> > > > +		if (replaced == new)
> > > > +			return 0;  
> > > 
> > > This looks strange. I wonder if it actually hides a real bug that we
> > > modify the code twice or so.  
> > 
> > Not at all. All "profilers" we abused so far generate code that needs to
> > be disabled on boot first. prolog-pad generates nops, initially.  
> 
> Yeah, but I cannot find this kind of check in other architectures.
> I checked arch/x86/kernel/ftrace.c, arch/s390/kernel/ftrace.c, and
> arch/powerpc/kernel/ftrace.c. These all support ftrace with
> regs and livepatching.

I guess the question is, with this approach, there's no call to mcount
or fentry at compile time? Just nops are added? In this case perhaps the
if statement should be more defined:

	/*
	 * On boot, with the prologue code, the code will already
	 * be a nop.
	 */
	if (replace == new && new == NOP)
		return 0;

And perhaps you can even pass in addr and check if it equals the nop
address. Maybe even not call this code then? That is, if addr ==
MCOUNT_ADDR passed in by ftrace_code_disable() have ftrace_make_nop()
simple return 0 without doing anything.

-- Steve

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arch
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:49:38 +0000
Message-ID: <20160708114938.49052cee () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 17:24:21 +0200
Petr Mladek <pmladek@suse.com> wrote:

> On Fri 2016-07-08 17:07:09, Torsten Duwe wrote:
> > On Fri, Jul 08, 2016 at 04:58:00PM +0200, Petr Mladek wrote:  
> > > On Mon 2016-06-27 17:17:17, Torsten Duwe wrote:  
> > > > Once gcc is enhanced to optionally generate NOPs at the beginning
> > > > of each function, like the concept proven in
> > > > https://gcc.gnu.org/ml/gcc-patches/2016-04/msg01671.html
> > > > (sans the "fprintf (... pad_size);", which spoils the data structure
> > > > for kernel use), the generated pads can nicely be used to reroute
> > > > function calls for tracing/profiling, or live patching.
> > > > diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c
> > > > index ebecf9a..917065c 100644
> > > > --- a/arch/arm64/kernel/ftrace.c
> > > > +++ b/arch/arm64/kernel/ftrace.c
> > > > @@ -39,6 +39,12 @@ static int ftrace_modify_code(unsigned long pc, u32 old, u32 new,
> > > >  		if (aarch64_insn_read((void *)pc, &replaced))
> > > >  			return -EFAULT;
> > > >  
> > > > +		/* If we already have what we'll finally want,
> > > > +		 * report success. This is needed on startup.
> > > > +		 */
> > > > +		if (replaced == new)
> > > > +			return 0;  
> > > 
> > > This looks strange. I wonder if it actually hides a real bug that we
> > > modify the code twice or so.  
> > 
> > Not at all. All "profilers" we abused so far generate code that needs to
> > be disabled on boot first. prolog-pad generates nops, initially.  
> 
> Yeah, but I cannot find this kind of check in other architectures.
> I checked arch/x86/kernel/ftrace.c, arch/s390/kernel/ftrace.c, and
> arch/powerpc/kernel/ftrace.c. These all support ftrace with
> regs and livepatching.

I guess the question is, with this approach, there's no call to mcount
or fentry at compile time? Just nops are added? In this case perhaps the
if statement should be more defined:

	/*
	 * On boot, with the prologue code, the code will already
	 * be a nop.
	 */
	if (replace == new && new == NOP)
		return 0;

And perhaps you can even pass in addr and check if it equals the nop
address. Maybe even not call this code then? That is, if addr ==
MCOUNT_ADDR passed in by ftrace_code_disable() have ftrace_make_nop()
simple return 0 without doing anything.

-- Steve
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-sparse
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:49:38 +0000
Message-ID: <20160708114938.49052cee () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 17:24:21 +0200
Petr Mladek <pmladek@suse.com> wrote:

> On Fri 2016-07-08 17:07:09, Torsten Duwe wrote:
> > On Fri, Jul 08, 2016 at 04:58:00PM +0200, Petr Mladek wrote:  
> > > On Mon 2016-06-27 17:17:17, Torsten Duwe wrote:  
> > > > Once gcc is enhanced to optionally generate NOPs at the beginning
> > > > of each function, like the concept proven in
> > > > https://gcc.gnu.org/ml/gcc-patches/2016-04/msg01671.html
> > > > (sans the "fprintf (... pad_size);", which spoils the data structure
> > > > for kernel use), the generated pads can nicely be used to reroute
> > > > function calls for tracing/profiling, or live patching.
> > > > diff --git a/arch/arm64/kernel/ftrace.c b/arch/arm64/kernel/ftrace.c
> > > > index ebecf9a..917065c 100644
> > > > --- a/arch/arm64/kernel/ftrace.c
> > > > +++ b/arch/arm64/kernel/ftrace.c
> > > > @@ -39,6 +39,12 @@ static int ftrace_modify_code(unsigned long pc, u32 old, u32 new,
> > > >  		if (aarch64_insn_read((void *)pc, &replaced))
> > > >  			return -EFAULT;
> > > >  
> > > > +		/* If we already have what we'll finally want,
> > > > +		 * report success. This is needed on startup.
> > > > +		 */
> > > > +		if (replaced == new)
> > > > +			return 0;  
> > > 
> > > This looks strange. I wonder if it actually hides a real bug that we
> > > modify the code twice or so.  
> > 
> > Not at all. All "profilers" we abused so far generate code that needs to
> > be disabled on boot first. prolog-pad generates nops, initially.  
> 
> Yeah, but I cannot find this kind of check in other architectures.
> I checked arch/x86/kernel/ftrace.c, arch/s390/kernel/ftrace.c, and
> arch/powerpc/kernel/ftrace.c. These all support ftrace with
> regs and livepatching.

I guess the question is, with this approach, there's no call to mcount
or fentry at compile time? Just nops are added? In this case perhaps the
if statement should be more defined:

	/*
	 * On boot, with the prologue code, the code will already
	 * be a nop.
	 */
	if (replace == new && new == NOP)
		return 0;

And perhaps you can even pass in addr and check if it equals the nop
address. Maybe even not call this code then? That is, if addr ==
MCOUNT_ADDR passed in by ftrace_code_disable() have ftrace_make_nop()
simple return 0 without doing anything.

-- Steve
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arch
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:57:10 +0000
Message-ID: <20160708115710.5c657b5f () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 10:48:24 -0500
Josh Poimboeuf <jpoimboe@redhat.com> wrote:


> My understanding is that other arches don't need this check because they
> use -mfentry, so they have to modify the "call fentry" instruction to a
> nop on startup.
> 
> Here, with -fprolog-pad, it's already a nop, so no change is needed.
> 

That's what I was thinking. But as I stated in another email (probably
in the air when you wrote this), the call to ftrace_modify_code() may be
completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.

-- Steve
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-sparse
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:57:10 +0000
Message-ID: <20160708115710.5c657b5f () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 10:48:24 -0500
Josh Poimboeuf <jpoimboe@redhat.com> wrote:


> My understanding is that other arches don't need this check because they
> use -mfentry, so they have to modify the "call fentry" instruction to a
> nop on startup.
> 
> Here, with -fprolog-pad, it's already a nop, so no change is needed.
> 

That's what I was thinking. But as I stated in another email (probably
in the air when you wrote this), the call to ftrace_modify_code() may be
completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.

-- Steve
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arm-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 15:57:10 +0000
Message-ID: <20160708115710.5c657b5f () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 10:48:24 -0500
Josh Poimboeuf <jpoimboe@redhat.com> wrote:


> My understanding is that other arches don't need this check because they
> use -mfentry, so they have to modify the "call fentry" instruction to a
> nop on startup.
> 
> Here, with -fprolog-pad, it's already a nop, so no change is needed.
> 

That's what I was thinking. But as I stated in another email (probably
in the air when you wrote this), the call to ftrace_modify_code() may be
completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.

-- Steve

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-arch
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 20:24:55 +0000
Message-ID: <20160708202455.GA4580 () lst ! de>
--------------------
On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> On Fri, 8 Jul 2016 10:48:24 -0500
> Josh Poimboeuf <jpoimboe@redhat.com> wrote:
> > 
> > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > 

Yes, exactly.

> That's what I was thinking. But as I stated in another email (probably
> in the air when you wrote this), the call to ftrace_modify_code() may be
> completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.

Only on the _first_ invocation. Later on, tracing can be switched on and off,
and then the instructions need to be changed just like with fentry (or
profile-kernel ;-)

	Torsten

--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 20:24:55 +0000
Message-ID: <20160708202455.GA4580 () lst ! de>
--------------------
On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> On Fri, 8 Jul 2016 10:48:24 -0500
> Josh Poimboeuf <jpoimboe@redhat.com> wrote:
> > 
> > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > 

Yes, exactly.

> That's what I was thinking. But as I stated in another email (probably
> in the air when you wrote this), the call to ftrace_modify_code() may be
> completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.

Only on the _first_ invocation. Later on, tracing can be switched on and off,
and then the instructions need to be changed just like with fentry (or
profile-kernel ;-)

	Torsten

================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-arm-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 20:24:55 +0000
Message-ID: <20160708202455.GA4580 () lst ! de>
--------------------
On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> On Fri, 8 Jul 2016 10:48:24 -0500
> Josh Poimboeuf <jpoimboe@redhat.com> wrote:
> > 
> > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > 

Yes, exactly.

> That's what I was thinking. But as I stated in another email (probably
> in the air when you wrote this), the call to ftrace_modify_code() may be
> completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.

Only on the _first_ invocation. Later on, tracing can be switched on and off,
and then the instructions need to be changed just like with fentry (or
profile-kernel ;-)

	Torsten


_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arm-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 21:08:08 +0000
Message-ID: <20160708170808.1ab70ce3 () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 22:24:55 +0200
Torsten Duwe <duwe@lst.de> wrote:

> On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> > On Fri, 8 Jul 2016 10:48:24 -0500
> > Josh Poimboeuf <jpoimboe@redhat.com> wrote:  
> > > 
> > > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > >   
> 
> Yes, exactly.
> 
> > That's what I was thinking. But as I stated in another email (probably
> > in the air when you wrote this), the call to ftrace_modify_code() may be
> > completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.  
> 
> Only on the _first_ invocation. Later on, tracing can be switched on and off,
> and then the instructions need to be changed just like with fentry (or
> profile-kernel ;-)
> 

Understood, but ftrace_modify_code() will only receive addr ==
MCOUNT_ADDR on boot up or when a module is loaded. In both cases, with
-fprolog-pad it will already be a nop, hence no need to call
ftrace_modify_code(), in those cases.

In all other cases, addr will point to a ftrace trampoline.

-- Steve

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arch
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 21:08:08 +0000
Message-ID: <20160708170808.1ab70ce3 () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 22:24:55 +0200
Torsten Duwe <duwe@lst.de> wrote:

> On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> > On Fri, 8 Jul 2016 10:48:24 -0500
> > Josh Poimboeuf <jpoimboe@redhat.com> wrote:  
> > > 
> > > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > >   
> 
> Yes, exactly.
> 
> > That's what I was thinking. But as I stated in another email (probably
> > in the air when you wrote this), the call to ftrace_modify_code() may be
> > completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.  
> 
> Only on the _first_ invocation. Later on, tracing can be switched on and off,
> and then the instructions need to be changed just like with fentry (or
> profile-kernel ;-)
> 

Understood, but ftrace_modify_code() will only receive addr ==
MCOUNT_ADDR on boot up or when a module is loaded. In both cases, with
-fprolog-pad it will already be a nop, hence no need to call
ftrace_modify_code(), in those cases.

In all other cases, addr will point to a ftrace trampoline.

-- Steve
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 08 Jul 2016 21:08:08 +0000
Message-ID: <20160708170808.1ab70ce3 () gandalf ! local ! home>
--------------------
On Fri, 8 Jul 2016 22:24:55 +0200
Torsten Duwe <duwe@lst.de> wrote:

> On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> > On Fri, 8 Jul 2016 10:48:24 -0500
> > Josh Poimboeuf <jpoimboe@redhat.com> wrote:  
> > > 
> > > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > >   
> 
> Yes, exactly.
> 
> > That's what I was thinking. But as I stated in another email (probably
> > in the air when you wrote this), the call to ftrace_modify_code() may be
> > completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.  
> 
> Only on the _first_ invocation. Later on, tracing can be switched on and off,
> and then the instructions need to be changed just like with fentry (or
> profile-kernel ;-)
> 

Understood, but ftrace_modify_code() will only receive addr ==
MCOUNT_ADDR on boot up or when a module is loaded. In both cases, with
-fprolog-pad it will already be a nop, hence no need to call
ftrace_modify_code(), in those cases.

In all other cases, addr will point to a ftrace trampoline.

-- Steve
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-sparse
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Sat, 09 Jul 2016 09:06:32 +0000
Message-ID: <20160709090632.GA2598 () lst ! de>
--------------------
On Fri, Jul 08, 2016 at 05:08:08PM -0400, Steven Rostedt wrote:
> On Fri, 8 Jul 2016 22:24:55 +0200
> Torsten Duwe <duwe@lst.de> wrote:
> 
> > On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> > > On Fri, 8 Jul 2016 10:48:24 -0500
> > > Josh Poimboeuf <jpoimboe@redhat.com> wrote:  
> > > > 
> > > > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > > >   
> > 
> > Yes, exactly.
> > 
> > > That's what I was thinking. But as I stated in another email (probably
> > > in the air when you wrote this), the call to ftrace_modify_code() may be
> > > completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.  
> > 
> > Only on the _first_ invocation. Later on, tracing can be switched on and off,
> > and then the instructions need to be changed just like with fentry (or
> > profile-kernel ;-)
> > 
> 
> Understood, but ftrace_modify_code() will only receive addr ==
> MCOUNT_ADDR on boot up or when a module is loaded. In both cases, with
> -fprolog-pad it will already be a nop, hence no need to call
> ftrace_modify_code(), in those cases.
> 
> In all other cases, addr will point to a ftrace trampoline.

Maybe the code in question can be replaced with the change below, now that
there is a preprocessor define in V2?
(untested)

diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 3f743b1..695a646 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -2423,6 +2423,12 @@ ftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)
 	if (unlikely(ftrace_disabled))
 		return 0;
 
+#ifdef CC_USING_PROLOG_PAD
+	/* If the compiler already generated NOPs instead of
+	 * calls to mcount, we're done here.
+	*/
+	return 1;
+#endif
 	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
 	if (ret) {
 		ftrace_bug(ret, rec);
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-arch
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Sat, 09 Jul 2016 09:06:32 +0000
Message-ID: <20160709090632.GA2598 () lst ! de>
--------------------
On Fri, Jul 08, 2016 at 05:08:08PM -0400, Steven Rostedt wrote:
> On Fri, 8 Jul 2016 22:24:55 +0200
> Torsten Duwe <duwe@lst.de> wrote:
> 
> > On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> > > On Fri, 8 Jul 2016 10:48:24 -0500
> > > Josh Poimboeuf <jpoimboe@redhat.com> wrote:  
> > > > 
> > > > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > > >   
> > 
> > Yes, exactly.
> > 
> > > That's what I was thinking. But as I stated in another email (probably
> > > in the air when you wrote this), the call to ftrace_modify_code() may be
> > > completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.  
> > 
> > Only on the _first_ invocation. Later on, tracing can be switched on and off,
> > and then the instructions need to be changed just like with fentry (or
> > profile-kernel ;-)
> > 
> 
> Understood, but ftrace_modify_code() will only receive addr ==
> MCOUNT_ADDR on boot up or when a module is loaded. In both cases, with
> -fprolog-pad it will already be a nop, hence no need to call
> ftrace_modify_code(), in those cases.
> 
> In all other cases, addr will point to a ftrace trampoline.

Maybe the code in question can be replaced with the change below, now that
there is a preprocessor define in V2?
(untested)

diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 3f743b1..695a646 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -2423,6 +2423,12 @@ ftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)
 	if (unlikely(ftrace_disabled))
 		return 0;
 
+#ifdef CC_USING_PROLOG_PAD
+	/* If the compiler already generated NOPs instead of
+	 * calls to mcount, we're done here.
+	*/
+	return 1;
+#endif
 	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
 	if (ret) {
 		ftrace_bug(ret, rec);
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-arm-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Sat, 09 Jul 2016 09:06:32 +0000
Message-ID: <20160709090632.GA2598 () lst ! de>
--------------------
On Fri, Jul 08, 2016 at 05:08:08PM -0400, Steven Rostedt wrote:
> On Fri, 8 Jul 2016 22:24:55 +0200
> Torsten Duwe <duwe@lst.de> wrote:
> 
> > On Fri, Jul 08, 2016 at 11:57:10AM -0400, Steven Rostedt wrote:
> > > On Fri, 8 Jul 2016 10:48:24 -0500
> > > Josh Poimboeuf <jpoimboe@redhat.com> wrote:  
> > > > 
> > > > Here, with -fprolog-pad, it's already a nop, so no change is needed.
> > > >   
> > 
> > Yes, exactly.
> > 
> > > That's what I was thinking. But as I stated in another email (probably
> > > in the air when you wrote this), the call to ftrace_modify_code() may be
> > > completely circumvented by ftrace_make_nop() if the addr is MCOUNT_ADDR.  
> > 
> > Only on the _first_ invocation. Later on, tracing can be switched on and off,
> > and then the instructions need to be changed just like with fentry (or
> > profile-kernel ;-)
> > 
> 
> Understood, but ftrace_modify_code() will only receive addr ==
> MCOUNT_ADDR on boot up or when a module is loaded. In both cases, with
> -fprolog-pad it will already be a nop, hence no need to call
> ftrace_modify_code(), in those cases.
> 
> In all other cases, addr will point to a ftrace trampoline.

Maybe the code in question can be replaced with the change below, now that
there is a preprocessor define in V2?
(untested)

diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 3f743b1..695a646 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -2423,6 +2423,12 @@ ftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)
 	if (unlikely(ftrace_disabled))
 		return 0;
 
+#ifdef CC_USING_PROLOG_PAD
+	/* If the compiler already generated NOPs instead of
+	 * calls to mcount, we're done here.
+	*/
+	return 1;
+#endif
 	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
 	if (ret) {
 		ftrace_bug(ret, rec);

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 15 Jul 2016 18:36:16 +0000
Message-ID: <20160715143616.5b3d063e () gandalf ! local ! home>
--------------------
On Sat, 9 Jul 2016 11:06:32 +0200
Torsten Duwe <duwe@lst.de> wrote:


> Maybe the code in question can be replaced with the change below, now that
> there is a preprocessor define in V2?
> (untested)
> 
> diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
> index 3f743b1..695a646 100644
> --- a/kernel/trace/ftrace.c
> +++ b/kernel/trace/ftrace.c
> @@ -2423,6 +2423,12 @@ ftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)
>  	if (unlikely(ftrace_disabled))
>  		return 0;
>  
> +#ifdef CC_USING_PROLOG_PAD
> +	/* If the compiler already generated NOPs instead of
> +	 * calls to mcount, we're done here.
> +	*/
> +	return 1;
> +#endif

I really hate adding #ifdef's like this in generic code if the arch can
handle it with some other means.

-- Steve


>  	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
>  	if (ret) {
>  		ftrace_bug(ret, rec);

================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arch
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 15 Jul 2016 18:36:16 +0000
Message-ID: <20160715143616.5b3d063e () gandalf ! local ! home>
--------------------
On Sat, 9 Jul 2016 11:06:32 +0200
Torsten Duwe <duwe@lst.de> wrote:


> Maybe the code in question can be replaced with the change below, now that
> there is a preprocessor define in V2?
> (untested)
> 
> diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
> index 3f743b1..695a646 100644
> --- a/kernel/trace/ftrace.c
> +++ b/kernel/trace/ftrace.c
> @@ -2423,6 +2423,12 @@ ftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)
>  	if (unlikely(ftrace_disabled))
>  		return 0;
>  
> +#ifdef CC_USING_PROLOG_PAD
> +	/* If the compiler already generated NOPs instead of
> +	 * calls to mcount, we're done here.
> +	*/
> +	return 1;
> +#endif

I really hate adding #ifdef's like this in generic code if the arch can
handle it with some other means.

-- Steve


>  	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
>  	if (ret) {
>  		ftrace_bug(ret, rec);

--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-arm-kernel
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 15 Jul 2016 18:36:16 +0000
Message-ID: <20160715143616.5b3d063e () gandalf ! local ! home>
--------------------
On Sat, 9 Jul 2016 11:06:32 +0200
Torsten Duwe <duwe@lst.de> wrote:


> Maybe the code in question can be replaced with the change below, now that
> there is a preprocessor define in V2?
> (untested)
> 
> diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
> index 3f743b1..695a646 100644
> --- a/kernel/trace/ftrace.c
> +++ b/kernel/trace/ftrace.c
> @@ -2423,6 +2423,12 @@ ftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)
>  	if (unlikely(ftrace_disabled))
>  		return 0;
>  
> +#ifdef CC_USING_PROLOG_PAD
> +	/* If the compiler already generated NOPs instead of
> +	 * calls to mcount, we're done here.
> +	*/
> +	return 1;
> +#endif

I really hate adding #ifdef's like this in generic code if the arch can
handle it with some other means.

-- Steve


>  	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
>  	if (ret) {
>  		ftrace_bug(ret, rec);


_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Steven Rostedt <rostedt () goodmis ! org>
To: linux-sparse
Subject: Re: [PATCH v2 1/2] arm64: implement FTRACE_WITH_REGS
Date: Fri, 15 Jul 2016 18:36:16 +0000
Message-ID: <20160715143616.5b3d063e () gandalf ! local ! home>
--------------------
On Sat, 9 Jul 2016 11:06:32 +0200
Torsten Duwe <duwe@lst.de> wrote:


> Maybe the code in question can be replaced with the change below, now that
> there is a preprocessor define in V2?
> (untested)
> 
> diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
> index 3f743b1..695a646 100644
> --- a/kernel/trace/ftrace.c
> +++ b/kernel/trace/ftrace.c
> @@ -2423,6 +2423,12 @@ ftrace_code_disable(struct module *mod, struct dyn_ftrace *rec)
>  	if (unlikely(ftrace_disabled))
>  		return 0;
>  
> +#ifdef CC_USING_PROLOG_PAD
> +	/* If the compiler already generated NOPs instead of
> +	 * calls to mcount, we're done here.
> +	*/
> +	return 1;
> +#endif

I really hate adding #ifdef's like this in generic code if the arch can
handle it with some other means.

-- Steve


>  	ret = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
>  	if (ret) {
>  		ftrace_bug(ret, rec);

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 1/5] unssa: do not try to update liveness ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 1/5] unssa: do not try to update liveness
Date: Mon, 12 Dec 2016 15:28:57 +0000
Message-ID: <20161212152901.24948-2-luc.vanoostenryck () gmail ! com>
--------------------
The unSSA step used to try to maintain the liveness info
while creating the copies but this can't be done so simply
(what is updated is only the liveness for the current bb
while it needs to be done for all concerned bbs).

If/when liveness is needed after this step, it need to be
redone by calling track_pseudo_liveness().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 unssa.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/unssa.c b/unssa.c
index 382095d7..85b1388d 100644
--- a/unssa.c
+++ b/unssa.c
@@ -49,9 +49,6 @@ static void replace_phi_node(struct instruction *phi)
 	tmp->ident = phi->target->ident;
 	tmp->def = NULL;		// defined by all the phisrc
 	
-	// update the current liveness
-	remove_pseudo(&phi->bb->needs, phi->target);
-	add_pseudo(&phi->bb->needs, tmp);
 	track_phi_uses(phi);
 
 	phi->opcode = OP_COPY;
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 10/13] symbol: flag builtins constant_p, safe_p and warning as constexprs ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 10/13] symbol: flag builtins constant_p, safe_p and warning as constexprs
Date: Tue, 26 Jan 2016 02:00:11 +0000
Message-ID: <20160126020010.GH46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 04:02:06PM +0100, Nicolai Stange wrote:
> Unconditionally flag the expressions
>   __builtin_constant_p(),
>   __builtin_safe_p(),
>   __builtin_warning()
> as being integer constant expressions.


Good! 

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 11/13] evaluate: relax some constant expression rules for pointer expressions ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 11/13] evaluate: relax some constant expression rules for pointer expressions
Date: Mon, 25 Jan 2016 15:03:26 +0000
Message-ID: <87io2hem69.fsf () gmail ! com>
--------------------
The official constraints on constant expressions [6.6] are insanely
strict in that they do not allow some constructs commonly used in the
wild.

Relax them by treating
- address constants cast to different pointer type as address constants
  again,
- address constants cast to integer type as integer constant
  expressions
- conditional expressions whose true and false branches both yield
  address constants as address constants,
- and conditional expressions whose condition is an address constant
  as an constant expression to the extent their true and false branches
  allow.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c | 35 ++++++++++++++++++++++++++++++-----
 1 file changed, 30 insertions(+), 5 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index d32f5a4..2b60294 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1125,14 +1125,23 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 		true = &expr->cond_true;
 	}
 
-	expr->flags = (expr->conditional->flags & (*true)->flags &
-		expr->cond_false->flags);
-	expr_flags_decay_consts(&expr->flags);
 	/*
+	 * A conditional operator yields a particular constant
+	 * expression type only if all of its three subexpressions are
+	 * of that type [6.6(6), 6.6(8)].
+	 * As an extension, relax this restriction by allowing any
+	 * constant expression type for the condition expression.
+	 *
 	 * A conditional operator never yields an address constant
 	 * [6.6(9)].
+	 * However, as an extension, if the condition is any constant
+	 * expression, and the true and false expressions are both
+	 * address constants, mark the result as an address constant.
 	 */
-	expr_clear_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
+	if (expr->conditional->flags & (EXPR_FLAG_ARITH_CONST_EXPR |
+						EXPR_FLAG_ADDR_CONST_EXPR))
+		expr->flags = (*true)->flags &expr->cond_false->flags;
+	expr_flags_decay_consts(&expr->flags);
 
 	lclass = classify_type(ltype, &ltype);
 	rclass = classify_type(rtype, &rtype);
@@ -2783,14 +2792,30 @@ static struct symbol *evaluate_cast(struct expression *expr)
 		/*
 		 * Casts of integer literals to pointer type yield
 		 * address constants [6.6(9)].
+		 *
+		 * As an extension, treat address constants cast to a
+		 * different pointer type as adress constants again.
+		 *
+		 * As another extension, treat integer constant
+		 * expressions (in contrast to literals) cast to
+		 * pointer type as address constants.
 		 */
 		if (class1 & TYPE_PTR &&
-			(target->flags & EXPR_FLAG_INT_CONST)) {
+			((target->flags & EXPR_FLAG_INT_CONST_EXPR) ||
+				(target->flags & EXPR_FLAG_ADDR_CONST_EXPR))) {
 			expr_set_flag(&expr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
+
 		}
 	} else {
 		expr->flags = target->flags;
 		expr_flags_decay_consts(&expr->flags);
+
+		/*
+		 * As an extension, treat address constants cast to
+		 * integer type as an arithmetic constant.
+		 */
+		if (expr->flags & EXPR_FLAG_ADDR_CONST_EXPR)
+			expr_set_flag(&expr->flags, EXPR_FLAG_ARITH_CONST_EXPR);
 		/*
 		 * Casts to numeric types never result in address
 		 * constants [6.6(9)].
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 12/13] expression, evaluate: support compound literals as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 12/13] expression, evaluate: support compound literals as address constants
Date: Mon, 25 Jan 2016 15:04:28 +0000
Message-ID: <87egd5em4j.fsf () gmail ! com>
--------------------
Toplevel compound literals have got static storage duration
[6.5.2.5(6)].

This implies that
1. their addresses are address constants [6.6(9)] and
2. their initializers must contain constant expressions only
   [6.5.2.5(3), 6.7.8(4)] .

Flag the anonymous symbol created at expression parsing time as having
static storage duration if the compound literal occurs at top level
scope.

Flag the whole expression as being an address constant at evaluation
time if its corresponding anonymous symbol had been previously marked
as having static storage duration.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                              |  2 ++
 expression.c                            |  2 ++
 validation/constexpr-compound-literal.c | 19 +++++++++++++++++++
 3 files changed, 23 insertions(+)
 create mode 100644 validation/constexpr-compound-literal.c

diff --git a/evaluate.c b/evaluate.c
index 2b60294..ec19fe4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2770,6 +2770,8 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 		addr->ctype = &lazy_ptr_ctype;	/* Lazy eval */
 		addr->symbol = sym;
+		if (sym->ctype.modifiers & MOD_TOPLEVEL)
+			expr_set_flag(&addr->flags, EXPR_FLAG_ADDR_CONST_EXPR);
 
 		expr->type = EXPR_PREOP;
 		expr->op = '*';
diff --git a/expression.c b/expression.c
index 4ecc865..789353a 100644
--- a/expression.c
+++ b/expression.c
@@ -713,6 +713,8 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			cast->cast_type = sym;
 			token = expect(token, ')', "at end of cast operator");
 			if (match_op(token, '{')) {
+				if (toplevel(block_scope))
+					sym->ctype.modifiers |= MOD_TOPLEVEL;
 				if (is_force)
 					warning(sym->pos,
 						"[force] in compound literal");
diff --git a/validation/constexpr-compound-literal.c b/validation/constexpr-compound-literal.c
new file mode 100644
index 0000000..0892183
--- /dev/null
+++ b/validation/constexpr-compound-literal.c
@@ -0,0 +1,19 @@
+static int *a = &(int){ 1 };	// OK
+static int *b = &(int){ *a };	// KO
+
+static void foo(void)
+{
+	int *b = &(int){ 1 };		// OK
+	int *c = &(int){ *a };		// OK
+	static int *d = &(int){ 1 };	// KO
+}
+
+/*
+ * check-name: compound literal address constness verification
+ * check-command: sparse -Wstatic-initializer-not-const $file
+ *
+ * check-error-start
+constexpr-compound-literal.c:2:25: warning: initializer for static storage duration object is not a constant expression
+constexpr-compound-literal.c:8:27: warning: initializer for static storage duration object is not a constant expression
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 12/13] expression, evaluate: support compound literals as address constants
Date: Tue, 26 Jan 2016 02:07:50 +0000
Message-ID: <20160126020749.GJ46188 () macpro ! local>
--------------------
On Mon, Jan 25, 2016 at 04:04:28PM +0100, Nicolai Stange wrote:
> Toplevel compound literals have got static storage duration
> [6.5.2.5(6)].
> 
> This implies that
> 1. their addresses are address constants [6.6(9)] and
> 2. their initializers must contain constant expressions only
>    [6.5.2.5(3), 6.7.8(4)] .
> 
> Flag the anonymous symbol created at expression parsing time as having
> static storage duration if the compound literal occurs at top level
> scope.
> 
> Flag the whole expression as being an address constant at evaluation
> time if its corresponding anonymous symbol had been previously marked
> as having static storage duration.


Good.

Luc 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 2/2] arm64: implement live patching ===

From: Torsten Duwe <duwe () lst ! de>
To: linux-sparse
Subject: [PATCH v2 2/2] arm64: implement live patching
Date: Mon, 27 Jun 2016 15:17:22 +0000
Message-ID: <20160627151722.B81C968D29 () newverein ! lst ! de>
--------------------
On top of FTRACE_WITH_REGS and the klp changes that go into v4.7
this is straightforward.

Signed-off-by: Torsten Duwe <duwe@suse.de>
---
 arch/arm64/Kconfig                 |  3 +++
 arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
 arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
 3 files changed, 53 insertions(+)
 create mode 100644 arch/arm64/include/asm/livepatch.h

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 36a0e26..cb5adf3 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -80,6 +80,7 @@ config ARM64
 	select HAVE_GENERIC_DMA_COHERENT
 	select HAVE_HW_BREAKPOINT if PERF_EVENTS
 	select HAVE_IRQ_TIME_ACCOUNTING
+	select HAVE_LIVEPATCH
 	select HAVE_MEMBLOCK
 	select HAVE_MEMBLOCK_NODE_MAP if NUMA
 	select HAVE_PATA_PLATFORM
@@ -1042,4 +1043,6 @@ if CRYPTO
 source "arch/arm64/crypto/Kconfig"
 endif
 
+source "kernel/livepatch/Kconfig"
+
 source "lib/Kconfig"
diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
new file mode 100644
index 0000000..6b9a3d1
--- /dev/null
+++ b/arch/arm64/include/asm/livepatch.h
@@ -0,0 +1,37 @@
+/*
+ * livepatch.h - arm64-specific Kernel Live Patching Core
+ *
+ * Copyright (C) 2016 SUSE
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _ASM_ARM64_LIVEPATCH_H
+#define _ASM_ARM64_LIVEPATCH_H
+
+#include <linux/module.h>
+#include <linux/ftrace.h>
+
+#ifdef CONFIG_LIVEPATCH
+static inline int klp_check_compiler_support(void)
+{
+	return 0;
+}
+
+static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
+{
+	regs->pc = ip;
+}
+#endif /* CONFIG_LIVEPATCH */
+
+#endif /* _ASM_ARM64_LIVEPATCH_H */
diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
index 3ebe791..b166cbf 100644
--- a/arch/arm64/kernel/entry-ftrace.S
+++ b/arch/arm64/kernel/entry-ftrace.S
@@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
 	str	x9, [sp, #S_LR]
 	/* The program counter just after the ftrace call site */
 	str	lr, [sp, #S_PC]
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	mov	x19,lr          /* remember old return address */
+#endif
 	/* The stack pointer as it was on ftrace_caller entry... */
 	add	x29, sp, #S_FRAME_SIZE+16	/* ...is also our new FP */
 	str	x29, [sp, #S_SP]
@@ -219,6 +222,16 @@ ftrace_call:
 
 	bl	ftrace_stub
 
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	/* Is the trace function a live patcher an has messed with
+	 * the return address?
+	*/
+	ldr	x9, [sp, #S_PC]
+	cmp	x9, x19		/* compare with the value we remembered */
+	/* to not call graph tracer's "call" mechanism twice! */
+	b.eq	ftrace_regs_return
+#endif
+
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 	.global ftrace_graph_call
 ftrace_graph_call:			// ftrace_graph_caller();
-- 
2.6.6

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-arch
Subject: [PATCH v2 2/2] arm64: implement live patching
Date: Mon, 27 Jun 2016 15:17:22 +0000
Message-ID: <20160627151722.B81C968D29 () newverein ! lst ! de>
--------------------
On top of FTRACE_WITH_REGS and the klp changes that go into v4.7
this is straightforward.

Signed-off-by: Torsten Duwe <duwe@suse.de>
---
 arch/arm64/Kconfig                 |  3 +++
 arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
 arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
 3 files changed, 53 insertions(+)
 create mode 100644 arch/arm64/include/asm/livepatch.h

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 36a0e26..cb5adf3 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -80,6 +80,7 @@ config ARM64
 	select HAVE_GENERIC_DMA_COHERENT
 	select HAVE_HW_BREAKPOINT if PERF_EVENTS
 	select HAVE_IRQ_TIME_ACCOUNTING
+	select HAVE_LIVEPATCH
 	select HAVE_MEMBLOCK
 	select HAVE_MEMBLOCK_NODE_MAP if NUMA
 	select HAVE_PATA_PLATFORM
@@ -1042,4 +1043,6 @@ if CRYPTO
 source "arch/arm64/crypto/Kconfig"
 endif
 
+source "kernel/livepatch/Kconfig"
+
 source "lib/Kconfig"
diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
new file mode 100644
index 0000000..6b9a3d1
--- /dev/null
+++ b/arch/arm64/include/asm/livepatch.h
@@ -0,0 +1,37 @@
+/*
+ * livepatch.h - arm64-specific Kernel Live Patching Core
+ *
+ * Copyright (C) 2016 SUSE
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _ASM_ARM64_LIVEPATCH_H
+#define _ASM_ARM64_LIVEPATCH_H
+
+#include <linux/module.h>
+#include <linux/ftrace.h>
+
+#ifdef CONFIG_LIVEPATCH
+static inline int klp_check_compiler_support(void)
+{
+	return 0;
+}
+
+static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
+{
+	regs->pc = ip;
+}
+#endif /* CONFIG_LIVEPATCH */
+
+#endif /* _ASM_ARM64_LIVEPATCH_H */
diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
index 3ebe791..b166cbf 100644
--- a/arch/arm64/kernel/entry-ftrace.S
+++ b/arch/arm64/kernel/entry-ftrace.S
@@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
 	str	x9, [sp, #S_LR]
 	/* The program counter just after the ftrace call site */
 	str	lr, [sp, #S_PC]
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	mov	x19,lr          /* remember old return address */
+#endif
 	/* The stack pointer as it was on ftrace_caller entry... */
 	add	x29, sp, #S_FRAME_SIZE+16	/* ...is also our new FP */
 	str	x29, [sp, #S_SP]
@@ -219,6 +222,16 @@ ftrace_call:
 
 	bl	ftrace_stub
 
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	/* Is the trace function a live patcher an has messed with
+	 * the return address?
+	*/
+	ldr	x9, [sp, #S_PC]
+	cmp	x9, x19		/* compare with the value we remembered */
+	/* to not call graph tracer's "call" mechanism twice! */
+	b.eq	ftrace_regs_return
+#endif
+
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 	.global ftrace_graph_call
 ftrace_graph_call:			// ftrace_graph_caller();
-- 
2.6.6

--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-kernel
Subject: [PATCH v2 2/2] arm64: implement live patching
Date: Mon, 27 Jun 2016 15:17:22 +0000
Message-ID: <20160627151722.B81C968D29 () newverein ! lst ! de>
--------------------
On top of FTRACE_WITH_REGS and the klp changes that go into v4.7
this is straightforward.

Signed-off-by: Torsten Duwe <duwe@suse.de>
---
 arch/arm64/Kconfig                 |  3 +++
 arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
 arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
 3 files changed, 53 insertions(+)
 create mode 100644 arch/arm64/include/asm/livepatch.h

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 36a0e26..cb5adf3 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -80,6 +80,7 @@ config ARM64
 	select HAVE_GENERIC_DMA_COHERENT
 	select HAVE_HW_BREAKPOINT if PERF_EVENTS
 	select HAVE_IRQ_TIME_ACCOUNTING
+	select HAVE_LIVEPATCH
 	select HAVE_MEMBLOCK
 	select HAVE_MEMBLOCK_NODE_MAP if NUMA
 	select HAVE_PATA_PLATFORM
@@ -1042,4 +1043,6 @@ if CRYPTO
 source "arch/arm64/crypto/Kconfig"
 endif
 
+source "kernel/livepatch/Kconfig"
+
 source "lib/Kconfig"
diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
new file mode 100644
index 0000000..6b9a3d1
--- /dev/null
+++ b/arch/arm64/include/asm/livepatch.h
@@ -0,0 +1,37 @@
+/*
+ * livepatch.h - arm64-specific Kernel Live Patching Core
+ *
+ * Copyright (C) 2016 SUSE
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _ASM_ARM64_LIVEPATCH_H
+#define _ASM_ARM64_LIVEPATCH_H
+
+#include <linux/module.h>
+#include <linux/ftrace.h>
+
+#ifdef CONFIG_LIVEPATCH
+static inline int klp_check_compiler_support(void)
+{
+	return 0;
+}
+
+static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
+{
+	regs->pc = ip;
+}
+#endif /* CONFIG_LIVEPATCH */
+
+#endif /* _ASM_ARM64_LIVEPATCH_H */
diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
index 3ebe791..b166cbf 100644
--- a/arch/arm64/kernel/entry-ftrace.S
+++ b/arch/arm64/kernel/entry-ftrace.S
@@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
 	str	x9, [sp, #S_LR]
 	/* The program counter just after the ftrace call site */
 	str	lr, [sp, #S_PC]
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	mov	x19,lr          /* remember old return address */
+#endif
 	/* The stack pointer as it was on ftrace_caller entry... */
 	add	x29, sp, #S_FRAME_SIZE+16	/* ...is also our new FP */
 	str	x29, [sp, #S_SP]
@@ -219,6 +222,16 @@ ftrace_call:
 
 	bl	ftrace_stub
 
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	/* Is the trace function a live patcher an has messed with
+	 * the return address?
+	*/
+	ldr	x9, [sp, #S_PC]
+	cmp	x9, x19		/* compare with the value we remembered */
+	/* to not call graph tracer's "call" mechanism twice! */
+	b.eq	ftrace_regs_return
+#endif
+
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 	.global ftrace_graph_call
 ftrace_graph_call:			// ftrace_graph_caller();
-- 
2.6.6

================================================================================

From: Miroslav Benes <mbenes () suse ! cz>
To: linux-kernel
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Mon, 11 Jul 2016 14:03:08 +0000
Message-ID: <alpine.LNX.2.00.1607111556320.27989 () pobox ! suse ! cz>
--------------------
On Mon, 27 Jun 2016, Torsten Duwe wrote:

> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>
> +
> +#ifdef CONFIG_LIVEPATCH

A nit but we removed such guards in the other header files.

> +static inline int klp_check_compiler_support(void)
> +{
> +	return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +	regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */

I also checked mod_arch_specific structure because of the way we deal 
with relocations. It is defined only if CONFIG_ARM64_MODULE_PLTS is 
enabled and there is a pointer to 'struct elf64_shdr' called plt. It is 
used indirectly in apply_relocate_add() so we need it to stay. However it 
points to an existing Elf section and SHF_ALLOC is added to its sh_flags 
in module_frob_arch_sections() (arch/arm64/kernel/module-plts.c). 
Therefore we should be ok.

Jessica, could you check it as well, please?

Thanks,
Miroslav
================================================================================

From: Miroslav Benes <mbenes () suse ! cz>
To: linux-sparse
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Mon, 11 Jul 2016 14:03:08 +0000
Message-ID: <alpine.LNX.2.00.1607111556320.27989 () pobox ! suse ! cz>
--------------------
On Mon, 27 Jun 2016, Torsten Duwe wrote:

> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>
> +
> +#ifdef CONFIG_LIVEPATCH

A nit but we removed such guards in the other header files.

> +static inline int klp_check_compiler_support(void)
> +{
> +	return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +	regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */

I also checked mod_arch_specific structure because of the way we deal 
with relocations. It is defined only if CONFIG_ARM64_MODULE_PLTS is 
enabled and there is a pointer to 'struct elf64_shdr' called plt. It is 
used indirectly in apply_relocate_add() so we need it to stay. However it 
points to an existing Elf section and SHF_ALLOC is added to its sh_flags 
in module_frob_arch_sections() (arch/arm64/kernel/module-plts.c). 
Therefore we should be ok.

Jessica, could you check it as well, please?

Thanks,
Miroslav
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Miroslav Benes <mbenes () suse ! cz>
To: linux-arch
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Mon, 11 Jul 2016 14:03:08 +0000
Message-ID: <alpine.LNX.2.00.1607111556320.27989 () pobox ! suse ! cz>
--------------------
On Mon, 27 Jun 2016, Torsten Duwe wrote:

> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>
> +
> +#ifdef CONFIG_LIVEPATCH

A nit but we removed such guards in the other header files.

> +static inline int klp_check_compiler_support(void)
> +{
> +	return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +	regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */

I also checked mod_arch_specific structure because of the way we deal 
with relocations. It is defined only if CONFIG_ARM64_MODULE_PLTS is 
enabled and there is a pointer to 'struct elf64_shdr' called plt. It is 
used indirectly in apply_relocate_add() so we need it to stay. However it 
points to an existing Elf section and SHF_ALLOC is added to its sh_flags 
in module_frob_arch_sections() (arch/arm64/kernel/module-plts.c). 
Therefore we should be ok.

Jessica, could you check it as well, please?

Thanks,
Miroslav
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Miroslav Benes <mbenes () suse ! cz>
To: linux-arm-kernel
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Mon, 11 Jul 2016 14:03:08 +0000
Message-ID: <alpine.LNX.2.00.1607111556320.27989 () pobox ! suse ! cz>
--------------------
On Mon, 27 Jun 2016, Torsten Duwe wrote:

> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>
> +
> +#ifdef CONFIG_LIVEPATCH

A nit but we removed such guards in the other header files.

> +static inline int klp_check_compiler_support(void)
> +{
> +	return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +	regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */

I also checked mod_arch_specific structure because of the way we deal 
with relocations. It is defined only if CONFIG_ARM64_MODULE_PLTS is 
enabled and there is a pointer to 'struct elf64_shdr' called plt. It is 
used indirectly in apply_relocate_add() so we need it to stay. However it 
points to an existing Elf section and SHF_ALLOC is added to its sh_flags 
in module_frob_arch_sections() (arch/arm64/kernel/module-plts.c). 
Therefore we should be ok.

Jessica, could you check it as well, please?

Thanks,
Miroslav

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Paul Gortmaker <paul.gortmaker () windriver ! com>
To: linux-kernel
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Fri, 15 Jul 2016 16:03:08 +0000
Message-ID: <CAP=VYLocwooC+4oODKU6ER5v+cTo3oH6ReKC3VwD-juwvfpErw () mail ! gmail ! com>
--------------------
On Mon, Jun 27, 2016 at 11:17 AM, Torsten Duwe <duwe@lst.de> wrote:
> On top of FTRACE_WITH_REGS and the klp changes that go into v4.7
> this is straightforward.
>
> Signed-off-by: Torsten Duwe <duwe@suse.de>
> ---
>  arch/arm64/Kconfig                 |  3 +++
>  arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
>  arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
>  3 files changed, 53 insertions(+)
>  create mode 100644 arch/arm64/include/asm/livepatch.h
>
> diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
> index 36a0e26..cb5adf3 100644
> --- a/arch/arm64/Kconfig
> +++ b/arch/arm64/Kconfig
> @@ -80,6 +80,7 @@ config ARM64
>         select HAVE_GENERIC_DMA_COHERENT
>         select HAVE_HW_BREAKPOINT if PERF_EVENTS
>         select HAVE_IRQ_TIME_ACCOUNTING
> +       select HAVE_LIVEPATCH
>         select HAVE_MEMBLOCK
>         select HAVE_MEMBLOCK_NODE_MAP if NUMA
>         select HAVE_PATA_PLATFORM
> @@ -1042,4 +1043,6 @@ if CRYPTO
>  source "arch/arm64/crypto/Kconfig"
>  endif
>
> +source "kernel/livepatch/Kconfig"
> +
>  source "lib/Kconfig"
> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>

These includes don't look right.  It would seem all you need is the one
for struct pt_regs.

Paul.
--

> +
> +#ifdef CONFIG_LIVEPATCH
> +static inline int klp_check_compiler_support(void)
> +{
> +       return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +       regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */
> +
> +#endif /* _ASM_ARM64_LIVEPATCH_H */
> diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
> index 3ebe791..b166cbf 100644
> --- a/arch/arm64/kernel/entry-ftrace.S
> +++ b/arch/arm64/kernel/entry-ftrace.S
> @@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
>         str     x9, [sp, #S_LR]
>         /* The program counter just after the ftrace call site */
>         str     lr, [sp, #S_PC]
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       mov     x19,lr          /* remember old return address */
> +#endif
>         /* The stack pointer as it was on ftrace_caller entry... */
>         add     x29, sp, #S_FRAME_SIZE+16       /* ...is also our new FP */
>         str     x29, [sp, #S_SP]
> @@ -219,6 +222,16 @@ ftrace_call:
>
>         bl      ftrace_stub
>
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       /* Is the trace function a live patcher an has messed with
> +        * the return address?
> +       */
> +       ldr     x9, [sp, #S_PC]
> +       cmp     x9, x19         /* compare with the value we remembered */
> +       /* to not call graph tracer's "call" mechanism twice! */
> +       b.eq    ftrace_regs_return
> +#endif
> +
>  #ifdef CONFIG_FUNCTION_GRAPH_TRACER
>         .global ftrace_graph_call
>  ftrace_graph_call:                     // ftrace_graph_caller();
> --
> 2.6.6
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-arch" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Paul Gortmaker <paul.gortmaker () windriver ! com>
To: linux-arch
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Fri, 15 Jul 2016 16:03:08 +0000
Message-ID: <CAP=VYLocwooC+4oODKU6ER5v+cTo3oH6ReKC3VwD-juwvfpErw () mail ! gmail ! com>
--------------------
On Mon, Jun 27, 2016 at 11:17 AM, Torsten Duwe <duwe@lst.de> wrote:
> On top of FTRACE_WITH_REGS and the klp changes that go into v4.7
> this is straightforward.
>
> Signed-off-by: Torsten Duwe <duwe@suse.de>
> ---
>  arch/arm64/Kconfig                 |  3 +++
>  arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
>  arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
>  3 files changed, 53 insertions(+)
>  create mode 100644 arch/arm64/include/asm/livepatch.h
>
> diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
> index 36a0e26..cb5adf3 100644
> --- a/arch/arm64/Kconfig
> +++ b/arch/arm64/Kconfig
> @@ -80,6 +80,7 @@ config ARM64
>         select HAVE_GENERIC_DMA_COHERENT
>         select HAVE_HW_BREAKPOINT if PERF_EVENTS
>         select HAVE_IRQ_TIME_ACCOUNTING
> +       select HAVE_LIVEPATCH
>         select HAVE_MEMBLOCK
>         select HAVE_MEMBLOCK_NODE_MAP if NUMA
>         select HAVE_PATA_PLATFORM
> @@ -1042,4 +1043,6 @@ if CRYPTO
>  source "arch/arm64/crypto/Kconfig"
>  endif
>
> +source "kernel/livepatch/Kconfig"
> +
>  source "lib/Kconfig"
> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>

These includes don't look right.  It would seem all you need is the one
for struct pt_regs.

Paul.
--

> +
> +#ifdef CONFIG_LIVEPATCH
> +static inline int klp_check_compiler_support(void)
> +{
> +       return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +       regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */
> +
> +#endif /* _ASM_ARM64_LIVEPATCH_H */
> diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
> index 3ebe791..b166cbf 100644
> --- a/arch/arm64/kernel/entry-ftrace.S
> +++ b/arch/arm64/kernel/entry-ftrace.S
> @@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
>         str     x9, [sp, #S_LR]
>         /* The program counter just after the ftrace call site */
>         str     lr, [sp, #S_PC]
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       mov     x19,lr          /* remember old return address */
> +#endif
>         /* The stack pointer as it was on ftrace_caller entry... */
>         add     x29, sp, #S_FRAME_SIZE+16       /* ...is also our new FP */
>         str     x29, [sp, #S_SP]
> @@ -219,6 +222,16 @@ ftrace_call:
>
>         bl      ftrace_stub
>
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       /* Is the trace function a live patcher an has messed with
> +        * the return address?
> +       */
> +       ldr     x9, [sp, #S_PC]
> +       cmp     x9, x19         /* compare with the value we remembered */
> +       /* to not call graph tracer's "call" mechanism twice! */
> +       b.eq    ftrace_regs_return
> +#endif
> +
>  #ifdef CONFIG_FUNCTION_GRAPH_TRACER
>         .global ftrace_graph_call
>  ftrace_graph_call:                     // ftrace_graph_caller();
> --
> 2.6.6
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-arch" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Paul Gortmaker <paul.gortmaker () windriver ! com>
To: linux-sparse
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Fri, 15 Jul 2016 16:03:08 +0000
Message-ID: <CAP=VYLocwooC+4oODKU6ER5v+cTo3oH6ReKC3VwD-juwvfpErw () mail ! gmail ! com>
--------------------
On Mon, Jun 27, 2016 at 11:17 AM, Torsten Duwe <duwe@lst.de> wrote:
> On top of FTRACE_WITH_REGS and the klp changes that go into v4.7
> this is straightforward.
>
> Signed-off-by: Torsten Duwe <duwe@suse.de>
> ---
>  arch/arm64/Kconfig                 |  3 +++
>  arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
>  arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
>  3 files changed, 53 insertions(+)
>  create mode 100644 arch/arm64/include/asm/livepatch.h
>
> diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
> index 36a0e26..cb5adf3 100644
> --- a/arch/arm64/Kconfig
> +++ b/arch/arm64/Kconfig
> @@ -80,6 +80,7 @@ config ARM64
>         select HAVE_GENERIC_DMA_COHERENT
>         select HAVE_HW_BREAKPOINT if PERF_EVENTS
>         select HAVE_IRQ_TIME_ACCOUNTING
> +       select HAVE_LIVEPATCH
>         select HAVE_MEMBLOCK
>         select HAVE_MEMBLOCK_NODE_MAP if NUMA
>         select HAVE_PATA_PLATFORM
> @@ -1042,4 +1043,6 @@ if CRYPTO
>  source "arch/arm64/crypto/Kconfig"
>  endif
>
> +source "kernel/livepatch/Kconfig"
> +
>  source "lib/Kconfig"
> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>

These includes don't look right.  It would seem all you need is the one
for struct pt_regs.

Paul.
--

> +
> +#ifdef CONFIG_LIVEPATCH
> +static inline int klp_check_compiler_support(void)
> +{
> +       return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +       regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */
> +
> +#endif /* _ASM_ARM64_LIVEPATCH_H */
> diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
> index 3ebe791..b166cbf 100644
> --- a/arch/arm64/kernel/entry-ftrace.S
> +++ b/arch/arm64/kernel/entry-ftrace.S
> @@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
>         str     x9, [sp, #S_LR]
>         /* The program counter just after the ftrace call site */
>         str     lr, [sp, #S_PC]
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       mov     x19,lr          /* remember old return address */
> +#endif
>         /* The stack pointer as it was on ftrace_caller entry... */
>         add     x29, sp, #S_FRAME_SIZE+16       /* ...is also our new FP */
>         str     x29, [sp, #S_SP]
> @@ -219,6 +222,16 @@ ftrace_call:
>
>         bl      ftrace_stub
>
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       /* Is the trace function a live patcher an has messed with
> +        * the return address?
> +       */
> +       ldr     x9, [sp, #S_PC]
> +       cmp     x9, x19         /* compare with the value we remembered */
> +       /* to not call graph tracer's "call" mechanism twice! */
> +       b.eq    ftrace_regs_return
> +#endif
> +
>  #ifdef CONFIG_FUNCTION_GRAPH_TRACER
>         .global ftrace_graph_call
>  ftrace_graph_call:                     // ftrace_graph_caller();
> --
> 2.6.6
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-arch" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Paul Gortmaker <paul.gortmaker () windriver ! com>
To: linux-arm-kernel
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Fri, 15 Jul 2016 16:03:08 +0000
Message-ID: <CAP=VYLocwooC+4oODKU6ER5v+cTo3oH6ReKC3VwD-juwvfpErw () mail ! gmail ! com>
--------------------
On Mon, Jun 27, 2016 at 11:17 AM, Torsten Duwe <duwe@lst.de> wrote:
> On top of FTRACE_WITH_REGS and the klp changes that go into v4.7
> this is straightforward.
>
> Signed-off-by: Torsten Duwe <duwe@suse.de>
> ---
>  arch/arm64/Kconfig                 |  3 +++
>  arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
>  arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
>  3 files changed, 53 insertions(+)
>  create mode 100644 arch/arm64/include/asm/livepatch.h
>
> diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
> index 36a0e26..cb5adf3 100644
> --- a/arch/arm64/Kconfig
> +++ b/arch/arm64/Kconfig
> @@ -80,6 +80,7 @@ config ARM64
>         select HAVE_GENERIC_DMA_COHERENT
>         select HAVE_HW_BREAKPOINT if PERF_EVENTS
>         select HAVE_IRQ_TIME_ACCOUNTING
> +       select HAVE_LIVEPATCH
>         select HAVE_MEMBLOCK
>         select HAVE_MEMBLOCK_NODE_MAP if NUMA
>         select HAVE_PATA_PLATFORM
> @@ -1042,4 +1043,6 @@ if CRYPTO
>  source "arch/arm64/crypto/Kconfig"
>  endif
>
> +source "kernel/livepatch/Kconfig"
> +
>  source "lib/Kconfig"
> diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
> new file mode 100644
> index 0000000..6b9a3d1
> --- /dev/null
> +++ b/arch/arm64/include/asm/livepatch.h
> @@ -0,0 +1,37 @@
> +/*
> + * livepatch.h - arm64-specific Kernel Live Patching Core
> + *
> + * Copyright (C) 2016 SUSE
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License
> + * as published by the Free Software Foundation; either version 2
> + * of the License, or (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> + */
> +#ifndef _ASM_ARM64_LIVEPATCH_H
> +#define _ASM_ARM64_LIVEPATCH_H
> +
> +#include <linux/module.h>
> +#include <linux/ftrace.h>

These includes don't look right.  It would seem all you need is the one
for struct pt_regs.

Paul.
--

> +
> +#ifdef CONFIG_LIVEPATCH
> +static inline int klp_check_compiler_support(void)
> +{
> +       return 0;
> +}
> +
> +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
> +{
> +       regs->pc = ip;
> +}
> +#endif /* CONFIG_LIVEPATCH */
> +
> +#endif /* _ASM_ARM64_LIVEPATCH_H */
> diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
> index 3ebe791..b166cbf 100644
> --- a/arch/arm64/kernel/entry-ftrace.S
> +++ b/arch/arm64/kernel/entry-ftrace.S
> @@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
>         str     x9, [sp, #S_LR]
>         /* The program counter just after the ftrace call site */
>         str     lr, [sp, #S_PC]
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       mov     x19,lr          /* remember old return address */
> +#endif
>         /* The stack pointer as it was on ftrace_caller entry... */
>         add     x29, sp, #S_FRAME_SIZE+16       /* ...is also our new FP */
>         str     x29, [sp, #S_SP]
> @@ -219,6 +222,16 @@ ftrace_call:
>
>         bl      ftrace_stub
>
> +#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
> +       /* Is the trace function a live patcher an has messed with
> +        * the return address?
> +       */
> +       ldr     x9, [sp, #S_PC]
> +       cmp     x9, x19         /* compare with the value we remembered */
> +       /* to not call graph tracer's "call" mechanism twice! */
> +       b.eq    ftrace_regs_return
> +#endif
> +
>  #ifdef CONFIG_FUNCTION_GRAPH_TRACER
>         .global ftrace_graph_call
>  ftrace_graph_call:                     // ftrace_graph_caller();
> --
> 2.6.6
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-arch" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-kernel
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Thu, 11 Aug 2016 16:46:03 +0000
Message-ID: <20160811164603.GA24751 () lst ! de>
--------------------
On Mon, Jul 11, 2016 at 04:03:08PM +0200, Miroslav Benes wrote:
> On Mon, 27 Jun 2016, Torsten Duwe wrote:
> > +
> > +#ifdef CONFIG_LIVEPATCH
> 
> A nit but we removed such guards in the other header files.

I just notice this has fallen between the cracks :-/

	Torsten

================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-sparse
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Thu, 11 Aug 2016 16:46:03 +0000
Message-ID: <20160811164603.GA24751 () lst ! de>
--------------------
On Mon, Jul 11, 2016 at 04:03:08PM +0200, Miroslav Benes wrote:
> On Mon, 27 Jun 2016, Torsten Duwe wrote:
> > +
> > +#ifdef CONFIG_LIVEPATCH
> 
> A nit but we removed such guards in the other header files.

I just notice this has fallen between the cracks :-/

	Torsten

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-arch
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Thu, 11 Aug 2016 16:46:03 +0000
Message-ID: <20160811164603.GA24751 () lst ! de>
--------------------
On Mon, Jul 11, 2016 at 04:03:08PM +0200, Miroslav Benes wrote:
> On Mon, 27 Jun 2016, Torsten Duwe wrote:
> > +
> > +#ifdef CONFIG_LIVEPATCH
> 
> A nit but we removed such guards in the other header files.

I just notice this has fallen between the cracks :-/

	Torsten

--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-arm-kernel
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Thu, 11 Aug 2016 16:46:03 +0000
Message-ID: <20160811164603.GA24751 () lst ! de>
--------------------
On Mon, Jul 11, 2016 at 04:03:08PM +0200, Miroslav Benes wrote:
> On Mon, 27 Jun 2016, Torsten Duwe wrote:
> > +
> > +#ifdef CONFIG_LIVEPATCH
> 
> A nit but we removed such guards in the other header files.

I just notice this has fallen between the cracks :-/

	Torsten


_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Torsten Duwe <duwe () lst ! de>
To: linux-sparse
Subject: Re: [PATCH v2 2/2] arm64: implement live patching
Date: Thu, 11 Aug 2016 16:46:03 +0000
Message-ID: <20160811164603.GA24751 () lst ! de>
--------------------
On Mon, Jul 11, 2016 at 04:03:08PM +0200, Miroslav Benes wrote:
> On Mon, 27 Jun 2016, Torsten Duwe wrote:
> > +
> > +#ifdef CONFIG_LIVEPATCH
> 
> A nit but we removed such guards in the other header files.

I just notice this has fallen between the cracks :-/

	Torsten

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 3/5] unssa: try to avoid some OP_PHI copies ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 3/5] unssa: try to avoid some OP_PHI copies
Date: Mon, 12 Dec 2016 15:28:59 +0000
Message-ID: <20161212152901.24948-4-luc.vanoostenryck () gmail ! com>
--------------------
OP_PHI's target can interfer with it's own source swhen defined
in the same basic block. Such interference can create problem
like the 'swap problem' (which only exist if the phi-node are
'processed' sequentially if they're processed in parallel such
problems don't exist) when phi-nodes are destructed. To avoid
such problems OP_PHI are rewritten as OP_COPY.

if an OP_PHI and it's OP_PHISOURCE are in different basic blocks
no such interference is possible and the copy is not needed.

This patch detect such situation and eliminate these unneeded copies.

Note: during unSSA we're removing the OP_PHI & OP_PHISOURCE
  but we need to use the def-use chains between them. We must
  thus not use kill_instruction() in OP_PHI (this would break
  def-use chains and leave stray OP_PHISOURCE), it's enough
  to set their bb to NULL.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 unssa.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/unssa.c b/unssa.c
index 2660e94c..50782352 100644
--- a/unssa.c
+++ b/unssa.c
@@ -30,6 +30,32 @@
 #include <assert.h>
 
 
+static int simplify_phi_node(struct instruction *phi, pseudo_t tmp)
+{
+	pseudo_t target = phi->target;
+	struct pseudo_user *pu;
+	pseudo_t src;
+
+	// verify if this phi can be simplified
+	FOR_EACH_PTR(phi->phi_list, src) {
+		struct instruction *def = src->def;
+
+		if (!def)
+			continue;
+		if (def->bb == phi->bb)
+			return 0;
+	} END_FOR_EACH_PTR(src);
+
+	// no need to make a copy of this one
+	// -> replace the target pseudo by the tmp
+	FOR_EACH_PTR(target->users, pu) {
+		use_pseudo(pu->insn, tmp, pu->userp);
+	} END_FOR_EACH_PTR(pu);
+
+	phi->bb = NULL;
+	return 1;
+}
+
 static void replace_phi_node(struct instruction *phi)
 {
 	pseudo_t tmp;
@@ -40,6 +66,9 @@ static void replace_phi_node(struct instruction *phi)
 	tmp->ident = phi->target->ident;
 	tmp->def = NULL;		// defined by all the phisrc
 
+	// can we avoid to make of copy?
+	simplify_phi_node(phi, tmp);
+
 	// rewrite all it's phi_src to copy to a new tmp
 	FOR_EACH_PTR(phi->phi_list, p) {
 		struct instruction *def = p->def;
@@ -53,6 +82,9 @@ static void replace_phi_node(struct instruction *phi)
 		def->target = tmp;
 	} END_FOR_EACH_PTR(p);
 
+	if (!phi->bb)
+		return;
+
 	// rewrite the phi node:
 	//	phi	%rt, ...
 	// to:
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 4/5] unssa: eliminate trivial phisrc copies ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 4/5] unssa: eliminate trivial phisrc copies
Date: Mon, 12 Dec 2016 15:29:00 +0000
Message-ID: <20161212152901.24948-5-luc.vanoostenryck () gmail ! com>
--------------------
A OP_PHISOURCE which is the only user of its operand
can be trivially eliminated. For example, in:
	add	%r6, ...
	...
	phisrc	%rt, %r6
the phisrc can safely be eliminated if no other instruction use %r6.
With this patch it's rewritten as:
	add	%rt, ...
	...

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 unssa.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/unssa.c b/unssa.c
index 50782352..a7085ca0 100644
--- a/unssa.c
+++ b/unssa.c
@@ -30,6 +30,11 @@
 #include <assert.h>
 
 
+static inline int nbr_pseudo_users(pseudo_t p)
+{
+	return ptr_list_size((struct ptr_list *)p->users);
+}
+
 static int simplify_phi_node(struct instruction *phi, pseudo_t tmp)
 {
 	pseudo_t target = phi->target;
@@ -72,6 +77,7 @@ static void replace_phi_node(struct instruction *phi)
 	// rewrite all it's phi_src to copy to a new tmp
 	FOR_EACH_PTR(phi->phi_list, p) {
 		struct instruction *def = p->def;
+		pseudo_t src;
 
 		if (p == VOID)
 			continue;
@@ -80,6 +86,22 @@ static void replace_phi_node(struct instruction *phi)
 
 		def->opcode = OP_COPY;
 		def->target = tmp;
+
+		// can we eliminate the copy?
+		src = def->phi_src;
+		if (src->type != PSEUDO_REG)
+			continue;
+		switch (nbr_pseudo_users(src)) {
+			struct instruction *insn;
+		case 1:
+			insn = src->def;
+			if (!insn)
+				break;
+			insn->target = tmp;
+		case 0:
+			kill_instruction(def);
+			def->bb = NULL;
+		}
 	} END_FOR_EACH_PTR(p);
 
 	if (!phi->bb)
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 5/5] unssa: update comment about the unneeded copies ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 5/5] unssa: update comment about the unneeded copies
Date: Mon, 12 Dec 2016 15:29:01 +0000
Message-ID: <20161212152901.24948-6-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 unssa.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/unssa.c b/unssa.c
index a7085ca0..e7c9154d 100644
--- a/unssa.c
+++ b/unssa.c
@@ -15,10 +15,14 @@
  * as the corresponding OP_PHISOURCE.
  *
  * While very simple this method create a lot more copies that really necessary.
+ * We eliminate some of these copies but most probably most of them are still
+ * useless.
  * Ideally, "Sreedhar method III" should be used:
  * "Translating Out of Static Single Assignment Form", V. C. Sreedhar, R. D.-C. Ju,
  * D. M. Gillies and V. Santhanam.  SAS'99, Vol. 1694 of Lecture Notes in Computer
  * Science, Springer-Verlag, pp. 194-210, 1999.
+ * But for this we need precise liveness, on each %phi and not only on OP_PHI's
+ * target pseudos.
  *
  * Copyright (C) 2005 Luc Van Oostenryck
  */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] sparse: add support for static assert ===

From: Lance Richardson <lrichard () redhat ! com>
To: linux-sparse
Subject: [PATCH v2] sparse: add support for static assert
Date: Mon, 11 Jan 2016 22:31:22 +0000
Message-ID: <1452551482-1250-1-git-send-email-lrichard () redhat ! com>
--------------------
This patch introduces support for _Static_assert() in global,
function, and struct/union declaration contexts (as currently supported
by gcc).

Tested via:
   - kernel build with C=1 CF=-D__CHECK_ENDIAN__
   - build/check large code base making heavy use of _Static_assert()
   - "make check" with added test cases for static assert support

Signed-off-by: Lance Richardson <lrichard@redhat.com>
---
v2: add additional test cases
    add additional validation for parameters to _Static_assert()
    rework implementation to avoid impacting struct/union definition handling

 parse.c                    | 65 +++++++++++++++++++++++++++++++++++++++++++++-
 symbol.h                   |  1 +
 validation/static_assert.c | 62 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 127 insertions(+), 1 deletion(-)
 create mode 100644 validation/static_assert.c

diff --git a/parse.c b/parse.c
index b43d683..866c99d 100644
--- a/parse.c
+++ b/parse.c
@@ -57,7 +57,8 @@ static declarator_t
 	attribute_specifier, typeof_specifier, parse_asm_declarator,
 	typedef_specifier, inline_specifier, auto_specifier,
 	register_specifier, static_specifier, extern_specifier,
-	thread_specifier, const_qualifier, volatile_qualifier;
+	thread_specifier, const_qualifier, volatile_qualifier,
+	static_assert_declarator;
 
 static struct token *parse_if_statement(struct token *token, struct statement *stmt);
 static struct token *parse_return_statement(struct token *token, struct statement *stmt);
@@ -73,6 +74,8 @@ static struct token *parse_context_statement(struct token *token, struct stateme
 static struct token *parse_range_statement(struct token *token, struct statement *stmt);
 static struct token *parse_asm_statement(struct token *token, struct statement *stmt);
 static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
+static struct token *parse_static_assert_statement(struct token *token, struct statement *stmt);
+static struct token *toplevel_static_assert(struct token *token, struct symbol_list **list);
 
 typedef struct token *attr_t(struct token *, struct symbol *,
 			     struct decl_state *);
@@ -308,6 +311,13 @@ static struct symbol_op asm_op = {
 	.toplevel = toplevel_asm_declaration,
 };
 
+static struct symbol_op static_assert_op = {
+	.type = KW_ST_ASSERT,
+	.declarator = static_assert_declarator,
+	.statement = parse_static_assert_statement,
+	.toplevel = toplevel_static_assert,
+};
+
 static struct symbol_op packed_op = {
 	.attribute = attribute_packed,
 };
@@ -437,6 +447,10 @@ static struct init_keyword {
 	{ "__restrict",	NS_TYPEDEF, .op = &restrict_op},
 	{ "__restrict__",	NS_TYPEDEF, .op = &restrict_op},
 
+
+	/* Static assertion */
+	{ "_Static_assert", NS_KEYWORD, .op = &static_assert_op },
+
 	/* Storage class */
 	{ "auto",	NS_TYPEDEF, .op = &auto_op },
 	{ "register",	NS_TYPEDEF, .op = &register_op },
@@ -1856,6 +1870,13 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 static struct token *struct_declaration_list(struct token *token, struct symbol_list **list)
 {
 	while (!match_op(token, '}')) {
+		struct symbol *keyword;
+
+		if (token_type(token) == TOKEN_IDENT) {
+			keyword = lookup_keyword(token->ident, NS_KEYWORD);
+			if (keyword && keyword->op->type == KW_ST_ASSERT)
+				token = keyword->op->declarator(token, NULL);
+		}
 		if (!match_op(token, ';'))
 			token = declaration_list(token, list);
 		if (!match_op(token, ';')) {
@@ -2004,6 +2025,48 @@ static struct token *parse_asm_declarator(struct token *token, struct decl_state
 	return token;
 }
 
+
+static struct token *parse_static_assert(struct token *token, int expect_semi)
+{
+	struct expression *expr1 = NULL, *expr2 = NULL;
+	int val;
+
+	token = expect(token, '(', "after _Static_assert");
+	token = constant_expression(token, &expr1);
+	token = expect(token, ',', "after first argument of _Static_assert");
+	token = parse_expression(token, &expr2);
+	token = expect(token, ')', "after second argument of _Static_assert");
+
+	if (expect_semi)
+		token = expect(token, ';', "after _Static_assert()");
+
+	val = const_expression_value(expr1);
+
+	if (expr2->type != EXPR_STRING)
+		sparse_error(expr2->pos, "bad string literal");
+	else if (expr1 && (expr1->type == EXPR_VALUE)) {
+		if (!val)
+			sparse_error(expr1->pos, "static assertion failed: %s",
+				     show_string(expr2->string));
+	}
+
+	return token;
+}
+
+static struct token *static_assert_declarator(struct token *token, struct decl_state *ctx)
+{
+	return parse_static_assert(token->next, 0);
+}
+
+static struct token *parse_static_assert_statement(struct token *token, struct statement *stmt)
+{
+	return parse_static_assert(token->next, 1);
+}
+static struct token *toplevel_static_assert(struct token *token, struct symbol_list **list)
+{
+	return parse_static_assert(token->next, 1);
+}
+
 /* Make a statement out of an expression */
 static struct statement *make_statement(struct expression *expr)
 {
diff --git a/symbol.h b/symbol.h
index ccb5dcb..2822b0a 100644
--- a/symbol.h
+++ b/symbol.h
@@ -86,6 +86,7 @@ enum keyword {
 	KW_SHORT	= 1 << 7,
 	KW_LONG		= 1 << 8,
 	KW_EXACT	= 1 << 9,
+	KW_ST_ASSERT	= 1 << 10,
 };
 
 struct context {
diff --git a/validation/static_assert.c b/validation/static_assert.c
new file mode 100644
index 0000000..d3da954
--- /dev/null
+++ b/validation/static_assert.c
@@ -0,0 +1,62 @@
+_Static_assert(1, "global ok");
+
+struct foo {
+	_Static_assert(1, "struct ok");
+};
+
+void bar(void)
+{
+	_Static_assert(1, " func ok");
+}
+
+_Static_assert(0, "expected assertion failure");
+
+static int f;
+_Static_assert(f, "non-constant expression");
+
+static int *p;
+_Static_assert(p, "non-integer expression");
+
+_Static_assert(0.1, "float expression");
+        
+_Static_assert(!0 == 1, "non-trivial expression");
+        
+static char array[4];
+_Static_assert(sizeof(array) == 4, "sizeof expression");
+        
+static const char non_literal_string[] = "non literal string";
+_Static_assert(0, non_literal_string);
+
+_Static_assert(1 / 0, "invalid expression: should not show up?");
+
+struct s {
+	char arr[16];
+	_Static_assert(1, "inside struct");
+};
+
+struct s2 {
+	char c;
+	_Static_assert(sizeof(struct s2) == 1, "struct sizeof");
+};
+
+union u {
+	char c;
+	int  i;
+	_Static_assert(1, "inside union");
+};
+
+_Static_assert(sizeof(struct s) == 16, "sizeof assertion");
+
+/*
+ * check-name: static assertion
+ *
+ * check-error-start
+static_assert.c:12:16: error: static assertion failed: "expected assertion failure"
+static_assert.c:15:16: error: bad constant expression
+static_assert.c:18:16: error: bad constant expression
+static_assert.c:20:16: error: bad constant expression
+static_assert.c:28:19: error: bad string literal
+static_assert.c:30:18: error: bad constant expression
+ * check-error-end
+ */
+
-- 
1.9.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2] sparse: add support for static assert
Date: Mon, 25 Jan 2016 18:48:06 +0000
Message-ID: <20160125184804.GA43341 () macpro ! local>
--------------------
On Mon, Jan 11, 2016 at 05:31:22PM -0500, Lance Richardson wrote:


Hi,

I don't understand why tha parsing part have changed so much since v1.
Is it because I said
   > It seems a bit strange to me to use NS_TYPEDEF, as this is unrelated types.
   > OTOH, the other namespaces deosn't seems better suited,
   > and yes C11 define this as sort of declaration, so ...
or because something related to handling it inside structs and unions or
for some other reason?

If because of the NS_TYPEDEF thing, sorry if I wasn't clear but I really think
it was fine, just that at first sight I found it strange.
If because the structs & unions, please explain why is it needed, what was wrong
with v1 and is fine now.


> diff --git a/validation/static_assert.c b/validation/static_assert.c
> new file mode 100644
> index 0000000..d3da954
> --- /dev/null
> +++ b/validation/static_assert.c
...
> +struct s2 {
> +	char c;
> +	_Static_assert(sizeof(struct s2) == 1, "struct sizeof");
> +};

This succeed but
	struct s2 {
		char c;
		_Static_assert(sizeof(struct s2) == 1, "struct sizeof");
		char d;
		_Static_assert(sizeof(struct s2) == 2, "struct sizeof");
	};
succeed also wich seems certainly very odd.

However it's not a problem with your patch but because of:
1) sparse is fine with the evaluation of sizeof(struct ...) while the struct
   is not yet completed (which is maybe usefull but certainly can also be
   considered as a bug)
2) those assertions are evaluated at parse time and not at some later time.
   My first thought was that we really should move the checking of those
   assertions at a later time, maybe after linearization and by introducing
   a new operation for it (like OP_ASSERT or so).
   But this is not a solution for the assertions inside structs & unions.
   I'll add a separate test case showing the problem and it's probably better
   to not put this test in your test cases.

Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2] sparse: add support for static assert
Date: Fri, 29 Jan 2016 16:15:56 +0000
Message-ID: <20160129161554.GA730 () macbook ! lan>
--------------------
On Thu, Jan 28, 2016 at 09:53:29AM -0500, Lance Richardson wrote:
> ----- Original Message -----
> > On Mon, Jan 11, 2016 at 05:31:22PM -0500, Lance Richardson wrote:
> > 
> > 
> > Hi,
> > 
> > I don't understand why tha parsing part have changed so much since v1.
> 
> I discovered as I was adding additional test cases that the NS_TYPEDEF
> approach was causing sizeof to report a zero size for structures with
> embedded _Static_assert(); as part of processing NS_TYPEDEF within
> a structure for _Static_assert(), a unnamed field with unknown size
> was being attached to the structure definition.
> 
> So I decided to take a different approach, one that hopefully makes
> more sense than handling _Static_assert() via NS_TYPEDEF. 
> 
> Apologies for not providing these details in the v2 commit log. 

OK, I understand.
Yes, it's certainly worth to add that in the patch description.

> > > +struct s2 {
> > > +	char c;
> > > +	_Static_assert(sizeof(struct s2) == 1, "struct sizeof");
> > > +};
> > 
> > This succeed but
> > 	struct s2 {
> > 		char c;
> > 		_Static_assert(sizeof(struct s2) == 1, "struct sizeof");
> > 		char d;
> > 		_Static_assert(sizeof(struct s2) == 2, "struct sizeof");
> > 	};
> > succeed also wich seems certainly very odd.
> > 
> 
> Yes, I believe they should both fail with something like "invalid use of
> sizeof on incomplete type".

> 
> I think it's a bug.
> 

Absolutely.
 
> 
> OK, I'll post a v3 with the invalid test case removed. Thanks for looking
> at this.
> 
>    Lance

Good.
Please also add the explanation about the parsing in the patch description.

Luc 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] sparse: ignore __assume_aligned__ attribute ===

From: Lance Richardson <lrichard () redhat ! com>
To: linux-sparse
Subject: [PATCH v2] sparse: ignore __assume_aligned__ attribute
Date: Wed, 28 Sep 2016 18:41:05 +0000
Message-ID: <1475088065-31142-1-git-send-email-lrichard () redhat ! com>
--------------------
The __assume_aligned__ attribute can be safely ignored, add it
to the list of ignored attributes and add a test to verify that
this attribute is ignored.

Signed-off-by: Lance Richardson <lrichard@redhat.com>
---
v2: Added test case.

 parse.c                   | 2 ++
 validation/attr_aligned.c | 5 +++++
 2 files changed, 7 insertions(+)
 create mode 100644 validation/attr_aligned.c

diff --git a/parse.c b/parse.c
index 4e38f3f..634f109 100644
--- a/parse.c
+++ b/parse.c
@@ -510,6 +510,8 @@ const char *ignored_attributes[] = {
 	"__always_inline__",
 	"artificial",
 	"__artificial__",
+	"assume_aligned",
+	"__assume_aligned__",
 	"bounded",
 	"__bounded__",
 	"cdecl",
diff --git a/validation/attr_aligned.c b/validation/attr_aligned.c
new file mode 100644
index 0000000..af2c363
--- /dev/null
+++ b/validation/attr_aligned.c
@@ -0,0 +1,5 @@
+void *foo(void) __attribute__((__assume_aligned__(4096)));
+/*
+ * check-name: attribute assume_aligned
+ */
+
-- 
2.5.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v2] sparse: ignore __assume_aligned__ attribute
Date: Wed, 28 Sep 2016 20:27:58 +0000
Message-ID: <CANeU7Qn_QODHq1mp-K7o-h5qbhoVdAQqdOGo9ncEYTH6hGF+ww () mail ! gmail ! com>
--------------------
On Wed, Sep 28, 2016 at 11:41 AM, Lance Richardson <lrichard@redhat.com> wrote:
> The __assume_aligned__ attribute can be safely ignored, add it
> to the list of ignored attributes and add a test to verify that
> this attribute is ignored.

That looks good. I might duplicate one test case  for "assume_aligned"
in the finial commit.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 0/2] arm64 live patching ===

From: Torsten Duwe <duwe () lst ! de>
To: linux-sparse
Subject: [PATCH v3 0/2] arm64 live patching
Date: Thu, 11 Aug 2016 16:34:51 +0000
Message-ID: <20160811163451.D455C68C43 () newverein ! lst ! de>
--------------------

V3, including suggestions from the replies and 2 fixes.

Reminder: make sure you have a prolog-pad gcc, and this in your
top level Makefile:

ifdef CONFIG_LIVEPATCH
KBUILD_CFLAGS	+= $(call cc-option,-fno-ipa-ra)
endif

Tested with v4.8-rc1 + gcc-6.1

Changes since v2:
  * Do not skip initial NOP conversion for CC_USING_PROLOG_PAD,
    in other words: don't introduce new #ifdefs into generic code.
    (as requested by Steven Rostedt after my intermediate suggestion)
    Instead, check in arm64 whether a call to mcount is to be NOPed,
    and be strict again about the expected "old" instructions.
  * issue a warning should the compiler not know about -fprolog-pad=
    (as suggested by Josh Poimboeuf)
    Only strip the compiler flag proper, not the cpp flag, for critical
    files.
  * fix thinko / bummer in live patch return address change detection.
    Skip the graph caller if the addresses are _not_ equal!

Changes since v1:
  * instead of a comment "should be CC_USING_PROLOG_PAD":
    do it. CC_FLAGS_FTRACE holds it now, and the IPA
    disabler has become a separate issue (see above).

Torsten Duwe (2):
  arm64: implement FTRACE_WITH_REGS
  arm64: implement live patching

 arch/arm64/Kconfig                 |   4 ++
 arch/arm64/Makefile                |   9 ++++
 arch/arm64/include/asm/ftrace.h    |   8 +++
 arch/arm64/include/asm/livepatch.h |  37 ++++++++++++++
 arch/arm64/kernel/Makefile         |   6 +--
 arch/arm64/kernel/entry-ftrace.S   | 102 +++++++++++++++++++++++++++++++++++++
 arch/arm64/kernel/ftrace.c         |  45 ++++++++++++++--
 include/asm-generic/vmlinux.lds.h  |   2 +-
 include/linux/compiler.h           |   4 ++
 9 files changed, 209 insertions(+), 8 deletions(-)
 create mode 100644 arch/arm64/include/asm/livepatch.h

-- 
2.6.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 00/21] improve constexpr handling ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 00/21] improve constexpr handling
Date: Mon, 01 Feb 2016 02:28:38 +0000
Message-ID: <87lh75jh9l.fsf () gmail ! com>
--------------------
Here comes the greatly enhanced v3 of this series.

Luc's suggestions about splitting some patches turned out to be very fruitful!

Former [01/13] ("expression: introduce additional expression constness tracking flags")
has been split into
- [01/21] ("expression: introduce additional expression constness tracking flags")
- [02/21] ("expression: init constexpr_flags at expression allocation")
- [07/21] ("expression: add support for tagging arithmetic constant expressions")

In particular, the introduction of the arithmetic constant expression
flag is deferred until the last one of these three. This addresses
Luc's concerns that the arithmetic constant expression handlings
within the v2 "examine constness of XXX at evaluation only"-patches
should better get split off into a separate patch each.


Former [06/13] ("expression, evaluate: add support for recognizing address constants")
has been split into
- [08/21] ("expression, evaluate: add support for tagging address constants")
- [10/21] ("expression, evaluate: recognize static objects as address constants")
- [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
- [13/21] ("evaluate: recognize members of static compound objects as address constants")
- [14/21] ("evaluate: recognize string literals as address constants")

The address constant handling part from former
[02/13] ("expression: examine constness of casts at evaluation only")
has been extracted into a patch on its own, namely
[11/21] ("evaluate: recognize address constants created through casts")

Patches [10-14/21] have been placed just until after static initializer checking
has been introduced in
[09/21] ("evaluate: check static storage duration objects' intializers' constness").
This way, the monster testcase from former
[07/13] ("evaluate: check static storage duration objects' intializers' constness")
can be split and the individual tests attached to the different
patches as appropriate.


Note that we still have got this
[20/21] ("symbol: do not inherit storage modifiers from base types at examination")
thing.


Detailed changes:
[01/21] ("expression: introduce additional expression constness tracking flags"):
  - The expr_{set,clear}_flag() helpers have been replaced by bitmasks
    to be ored in or anded outnow.
  - Renamed ->flags to ->constexpr_flags
  - ->constexpr_flags initialization at expression allocation has been
    extracted into
    [02/21] ("expression: init constexpr_flags at expression allocation")
  - neither of the arithmetic constant expression flag nor address nor the
    address constant flag gets introduced by this patch anymore.
    They get introduced in 
    [07/21] ("expression: add support for tagging arithmetic constant expressions")
    [08/21] ("expression, evaluate: add support for tagging address constants")
    as needed.
  - Luc's remarks about the 'sic' comments carried over from the original
    code have been addressed in the new 
    [21/21] ("evaluation: treat comparsions between types as integer constexpr")
  - Changes to patch description as suggested by Luc.
  - Tag a TOKEN_ZERO_IDENT by integer constant instead of integer
    constant expression. Feels more natural but should not matter.

[02/21] ("expression: init constexpr_flags at expression allocation")
  This one is new. Split off from former [01/13].

[03-06/21] ("expression: examine constness of XXX at evaluation only")
  Adjusted patch descriptions as suggested by Luc.

[07/21] ("expression: add support for tagging arithmetic constant expressions")
  This one is new. Split off from former [01/13].

[08/21] ("expression, evaluate: add support for tagging address constants")
  Split off actual recognition of various address constant forms into
  separate patches [10-14/21]

[09/21] ("evaluate: check static storage duration objects' intializers' constness").
  - -W-flag has been renamed to -Wconstexpr-not-const
  - the associated warning message has been shortened to
    "non-constant initializer for static object".
  - the attached testcase has been greatly reduced as the tests are now
    attached to the patches [10-14/21].

[10-14/21]
  These ones are new and split off from former
  [06/13] ("expression, evaluate: add support for tagging address constants")
  They implement actual address constant recognition functionality.
  
  In
  [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
  a whitespace issue from former
  [06/13] ("expression, evaluate: add support for recognizing address constants")
  in an if-clause has been fixed.


[15/21] ("expression: recognize references to labels as address constants")
  A testcase for has been added.


[19/21] ("evaluate: relax some constant expression rules for pointer expressions")
  A typo ("adress") has been fixed.

[21/21] ("evaluation: treat comparsions between types as integer constexpr")
  This one is new.


Nicolai Stange (21):
  expression: introduce additional expression constness tracking flags
  expression: init constexpr_flags at expression allocation
  expression: examine constness of casts at evaluation only
  expression: examine constness of binops and alike at evaluation only
  expression: examine constness of preops at evaluation only
  expression: examine constness of conditionals at evaluation only
  expression: add support for tagging arithmetic constant expressions
  expression, evaluate: add support for tagging address constants
  evaluate: check static storage duration objects' intializers'
    constness
  expression, evaluate: recognize static objects as address constants
  evaluate: recognize address constants created through casts
  evaluate: recognize address constants created through pointer
    arithmetic
  evaluate: recognize members of static compound objects as address
    constants
  evaluate: recognize string literals as address constants
  expression: recognize references to labels as address constants
  expression: examine constness of __builtin_offsetof at evaluation only
  symbol: flag builtins constant_p, safe_p and warning as constexprs
  evaluate: relax some constant expression rules for pointer expressions
  expression, evaluate: support compound literals as address constants
  symbol: do not inherit storage modifiers from base types at
    examination
  evaluation: treat comparsions between types as integer constexpr

 evaluate.c                                   | 207 +++++++++++++++++++++------
 expand.c                                     |  10 +-
 expression.c                                 |  50 +++----
 expression.h                                 |  83 ++++++++++-
 lib.c                                        |   2 +
 lib.h                                        |   1 +
 sparse.1                                     |   9 ++
 symbol.c                                     |  12 +-
 validation/constexpr-addr-of-static-member.c |  26 ++++
 validation/constexpr-addr-of-static.c        |  36 +++++
 validation/constexpr-binop.c                 |  33 +++++
 validation/constexpr-cast.c                  |  25 ++++
 validation/constexpr-compound-literal.c      |  19 +++
 validation/constexpr-conditional.c           |  34 +++++
 validation/constexpr-init.c                  |  60 ++++++++
 validation/constexpr-labelref.c              |  15 ++
 validation/constexpr-offsetof.c              |  21 +++
 validation/constexpr-pointer-arith.c         |  28 ++++
 validation/constexpr-pointer-cast.c          |  13 ++
 validation/constexpr-preop.c                 |  29 ++++
 validation/constexpr-string.c                |   9 ++
 validation/constexpr-types-compatible-p.c    |   9 ++
 22 files changed, 640 insertions(+), 91 deletions(-)
 create mode 100644 validation/constexpr-addr-of-static-member.c
 create mode 100644 validation/constexpr-addr-of-static.c
 create mode 100644 validation/constexpr-binop.c
 create mode 100644 validation/constexpr-cast.c
 create mode 100644 validation/constexpr-compound-literal.c
 create mode 100644 validation/constexpr-conditional.c
 create mode 100644 validation/constexpr-init.c
 create mode 100644 validation/constexpr-labelref.c
 create mode 100644 validation/constexpr-offsetof.c
 create mode 100644 validation/constexpr-pointer-arith.c
 create mode 100644 validation/constexpr-pointer-cast.c
 create mode 100644 validation/constexpr-preop.c
 create mode 100644 validation/constexpr-string.c
 create mode 100644 validation/constexpr-types-compatible-p.c

-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 00/21] improve constexpr handling
Date: Mon, 01 Feb 2016 02:28:38 +0000
Message-ID: <87lh75jh9l.fsf () gmail ! com>
--------------------
Here comes the greatly enhanced v3 of this series.

Luc's suggestions about splitting some patches turned out to be very fruitful!

Former [01/13] ("expression: introduce additional expression constness tracking flags")
has been split into
- [01/21] ("expression: introduce additional expression constness tracking flags")
- [02/21] ("expression: init constexpr_flags at expression allocation")
- [07/21] ("expression: add support for tagging arithmetic constant expressions")

In particular, the introduction of the arithmetic constant expression
flag is deferred until the last one of these three. This addresses
Luc's concerns that the arithmetic constant expression handlings
within the v2 "examine constness of XXX at evaluation only"-patches
should better get split off into a separate patch each.


Former [06/13] ("expression, evaluate: add support for recognizing address constants")
has been split into
- [08/21] ("expression, evaluate: add support for tagging address constants")
- [10/21] ("expression, evaluate: recognize static objects as address constants")
- [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
- [13/21] ("evaluate: recognize members of static compound objects as address constants")
- [14/21] ("evaluate: recognize string literals as address constants")

The address constant handling part from former
[02/13] ("expression: examine constness of casts at evaluation only")
has been extracted into a patch on its own, namely
[11/21] ("evaluate: recognize address constants created through casts")

Patches [10-14/21] have been placed just until after static initializer checking
has been introduced in
[09/21] ("evaluate: check static storage duration objects' intializers' constness").
This way, the monster testcase from former
[07/13] ("evaluate: check static storage duration objects' intializers' constness")
can be split and the individual tests attached to the different
patches as appropriate.


Note that we still have got this
[20/21] ("symbol: do not inherit storage modifiers from base types at examination")
thing.


Detailed changes:
[01/21] ("expression: introduce additional expression constness tracking flags"):
  - The expr_{set,clear}_flag() helpers have been replaced by bitmasks
    to be ored in or anded outnow.
  - Renamed ->flags to ->constexpr_flags
  - ->constexpr_flags initialization at expression allocation has been
    extracted into
    [02/21] ("expression: init constexpr_flags at expression allocation")
  - neither of the arithmetic constant expression flag nor address nor the
    address constant flag gets introduced by this patch anymore.
    They get introduced in 
    [07/21] ("expression: add support for tagging arithmetic constant expressions")
    [08/21] ("expression, evaluate: add support for tagging address constants")
    as needed.
  - Luc's remarks about the 'sic' comments carried over from the original
    code have been addressed in the new 
    [21/21] ("evaluation: treat comparsions between types as integer constexpr")
  - Changes to patch description as suggested by Luc.
  - Tag a TOKEN_ZERO_IDENT by integer constant instead of integer
    constant expression. Feels more natural but should not matter.

[02/21] ("expression: init constexpr_flags at expression allocation")
  This one is new. Split off from former [01/13].

[03-06/21] ("expression: examine constness of XXX at evaluation only")
  Adjusted patch descriptions as suggested by Luc.

[07/21] ("expression: add support for tagging arithmetic constant expressions")
  This one is new. Split off from former [01/13].

[08/21] ("expression, evaluate: add support for tagging address constants")
  Split off actual recognition of various address constant forms into
  separate patches [10-14/21]

[09/21] ("evaluate: check static storage duration objects' intializers' constness").
  - -W-flag has been renamed to -Wconstexpr-not-const
  - the associated warning message has been shortened to
    "non-constant initializer for static object".
  - the attached testcase has been greatly reduced as the tests are now
    attached to the patches [10-14/21].

[10-14/21]
  These ones are new and split off from former
  [06/13] ("expression, evaluate: add support for tagging address constants")
  They implement actual address constant recognition functionality.
  
  In
  [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
  a whitespace issue from former
  [06/13] ("expression, evaluate: add support for recognizing address constants")
  in an if-clause has been fixed.


[15/21] ("expression: recognize references to labels as address constants")
  A testcase for has been added.


[19/21] ("evaluate: relax some constant expression rules for pointer expressions")
  A typo ("adress") has been fixed.

[21/21] ("evaluation: treat comparsions between types as integer constexpr")
  This one is new.


Nicolai Stange (21):
  expression: introduce additional expression constness tracking flags
  expression: init constexpr_flags at expression allocation
  expression: examine constness of casts at evaluation only
  expression: examine constness of binops and alike at evaluation only
  expression: examine constness of preops at evaluation only
  expression: examine constness of conditionals at evaluation only
  expression: add support for tagging arithmetic constant expressions
  expression, evaluate: add support for tagging address constants
  evaluate: check static storage duration objects' intializers'
    constness
  expression, evaluate: recognize static objects as address constants
  evaluate: recognize address constants created through casts
  evaluate: recognize address constants created through pointer
    arithmetic
  evaluate: recognize members of static compound objects as address
    constants
  evaluate: recognize string literals as address constants
  expression: recognize references to labels as address constants
  expression: examine constness of __builtin_offsetof at evaluation only
  symbol: flag builtins constant_p, safe_p and warning as constexprs
  evaluate: relax some constant expression rules for pointer expressions
  expression, evaluate: support compound literals as address constants
  symbol: do not inherit storage modifiers from base types at
    examination
  evaluation: treat comparsions between types as integer constexpr

 evaluate.c                                   | 207 +++++++++++++++++++++------
 expand.c                                     |  10 +-
 expression.c                                 |  50 +++----
 expression.h                                 |  83 ++++++++++-
 lib.c                                        |   2 +
 lib.h                                        |   1 +
 sparse.1                                     |   9 ++
 symbol.c                                     |  12 +-
 validation/constexpr-addr-of-static-member.c |  26 ++++
 validation/constexpr-addr-of-static.c        |  36 +++++
 validation/constexpr-binop.c                 |  33 +++++
 validation/constexpr-cast.c                  |  25 ++++
 validation/constexpr-compound-literal.c      |  19 +++
 validation/constexpr-conditional.c           |  34 +++++
 validation/constexpr-init.c                  |  60 ++++++++
 validation/constexpr-labelref.c              |  15 ++
 validation/constexpr-offsetof.c              |  21 +++
 validation/constexpr-pointer-arith.c         |  28 ++++
 validation/constexpr-pointer-cast.c          |  13 ++
 validation/constexpr-preop.c                 |  29 ++++
 validation/constexpr-string.c                |   9 ++
 validation/constexpr-types-compatible-p.c    |   9 ++
 22 files changed, 640 insertions(+), 91 deletions(-)
 create mode 100644 validation/constexpr-addr-of-static-member.c
 create mode 100644 validation/constexpr-addr-of-static.c
 create mode 100644 validation/constexpr-binop.c
 create mode 100644 validation/constexpr-cast.c
 create mode 100644 validation/constexpr-compound-literal.c
 create mode 100644 validation/constexpr-conditional.c
 create mode 100644 validation/constexpr-init.c
 create mode 100644 validation/constexpr-labelref.c
 create mode 100644 validation/constexpr-offsetof.c
 create mode 100644 validation/constexpr-pointer-arith.c
 create mode 100644 validation/constexpr-pointer-cast.c
 create mode 100644 validation/constexpr-preop.c
 create mode 100644 validation/constexpr-string.c
 create mode 100644 validation/constexpr-types-compatible-p.c

-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 00/21] improve constexpr handling
Date: Mon, 01 Feb 2016 02:28:38 +0000
Message-ID: <87lh75jh9l.fsf () gmail ! com>
--------------------
Here comes the greatly enhanced v3 of this series.

Luc's suggestions about splitting some patches turned out to be very fruitful!

Former [01/13] ("expression: introduce additional expression constness tracking flags")
has been split into
- [01/21] ("expression: introduce additional expression constness tracking flags")
- [02/21] ("expression: init constexpr_flags at expression allocation")
- [07/21] ("expression: add support for tagging arithmetic constant expressions")

In particular, the introduction of the arithmetic constant expression
flag is deferred until the last one of these three. This addresses
Luc's concerns that the arithmetic constant expression handlings
within the v2 "examine constness of XXX at evaluation only"-patches
should better get split off into a separate patch each.


Former [06/13] ("expression, evaluate: add support for recognizing address constants")
has been split into
- [08/21] ("expression, evaluate: add support for tagging address constants")
- [10/21] ("expression, evaluate: recognize static objects as address constants")
- [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
- [13/21] ("evaluate: recognize members of static compound objects as address constants")
- [14/21] ("evaluate: recognize string literals as address constants")

The address constant handling part from former
[02/13] ("expression: examine constness of casts at evaluation only")
has been extracted into a patch on its own, namely
[11/21] ("evaluate: recognize address constants created through casts")

Patches [10-14/21] have been placed just until after static initializer checking
has been introduced in
[09/21] ("evaluate: check static storage duration objects' intializers' constness").
This way, the monster testcase from former
[07/13] ("evaluate: check static storage duration objects' intializers' constness")
can be split and the individual tests attached to the different
patches as appropriate.


Note that we still have got this
[20/21] ("symbol: do not inherit storage modifiers from base types at examination")
thing.


Detailed changes:
[01/21] ("expression: introduce additional expression constness tracking flags"):
  - The expr_{set,clear}_flag() helpers have been replaced by bitmasks
    to be ored in or anded outnow.
  - Renamed ->flags to ->constexpr_flags
  - ->constexpr_flags initialization at expression allocation has been
    extracted into
    [02/21] ("expression: init constexpr_flags at expression allocation")
  - neither of the arithmetic constant expression flag nor address nor the
    address constant flag gets introduced by this patch anymore.
    They get introduced in 
    [07/21] ("expression: add support for tagging arithmetic constant expressions")
    [08/21] ("expression, evaluate: add support for tagging address constants")
    as needed.
  - Luc's remarks about the 'sic' comments carried over from the original
    code have been addressed in the new 
    [21/21] ("evaluation: treat comparsions between types as integer constexpr")
  - Changes to patch description as suggested by Luc.
  - Tag a TOKEN_ZERO_IDENT by integer constant instead of integer
    constant expression. Feels more natural but should not matter.

[02/21] ("expression: init constexpr_flags at expression allocation")
  This one is new. Split off from former [01/13].

[03-06/21] ("expression: examine constness of XXX at evaluation only")
  Adjusted patch descriptions as suggested by Luc.

[07/21] ("expression: add support for tagging arithmetic constant expressions")
  This one is new. Split off from former [01/13].

[08/21] ("expression, evaluate: add support for tagging address constants")
  Split off actual recognition of various address constant forms into
  separate patches [10-14/21]

[09/21] ("evaluate: check static storage duration objects' intializers' constness").
  - -W-flag has been renamed to -Wconstexpr-not-const
  - the associated warning message has been shortened to
    "non-constant initializer for static object".
  - the attached testcase has been greatly reduced as the tests are now
    attached to the patches [10-14/21].

[10-14/21]
  These ones are new and split off from former
  [06/13] ("expression, evaluate: add support for tagging address constants")
  They implement actual address constant recognition functionality.
  
  In
  [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
  a whitespace issue from former
  [06/13] ("expression, evaluate: add support for recognizing address constants")
  in an if-clause has been fixed.


[15/21] ("expression: recognize references to labels as address constants")
  A testcase for has been added.


[19/21] ("evaluate: relax some constant expression rules for pointer expressions")
  A typo ("adress") has been fixed.

[21/21] ("evaluation: treat comparsions between types as integer constexpr")
  This one is new.


Nicolai Stange (21):
  expression: introduce additional expression constness tracking flags
  expression: init constexpr_flags at expression allocation
  expression: examine constness of casts at evaluation only
  expression: examine constness of binops and alike at evaluation only
  expression: examine constness of preops at evaluation only
  expression: examine constness of conditionals at evaluation only
  expression: add support for tagging arithmetic constant expressions
  expression, evaluate: add support for tagging address constants
  evaluate: check static storage duration objects' intializers'
    constness
  expression, evaluate: recognize static objects as address constants
  evaluate: recognize address constants created through casts
  evaluate: recognize address constants created through pointer
    arithmetic
  evaluate: recognize members of static compound objects as address
    constants
  evaluate: recognize string literals as address constants
  expression: recognize references to labels as address constants
  expression: examine constness of __builtin_offsetof at evaluation only
  symbol: flag builtins constant_p, safe_p and warning as constexprs
  evaluate: relax some constant expression rules for pointer expressions
  expression, evaluate: support compound literals as address constants
  symbol: do not inherit storage modifiers from base types at
    examination
  evaluation: treat comparsions between types as integer constexpr

 evaluate.c                                   | 207 +++++++++++++++++++++------
 expand.c                                     |  10 +-
 expression.c                                 |  50 +++----
 expression.h                                 |  83 ++++++++++-
 lib.c                                        |   2 +
 lib.h                                        |   1 +
 sparse.1                                     |   9 ++
 symbol.c                                     |  12 +-
 validation/constexpr-addr-of-static-member.c |  26 ++++
 validation/constexpr-addr-of-static.c        |  36 +++++
 validation/constexpr-binop.c                 |  33 +++++
 validation/constexpr-cast.c                  |  25 ++++
 validation/constexpr-compound-literal.c      |  19 +++
 validation/constexpr-conditional.c           |  34 +++++
 validation/constexpr-init.c                  |  60 ++++++++
 validation/constexpr-labelref.c              |  15 ++
 validation/constexpr-offsetof.c              |  21 +++
 validation/constexpr-pointer-arith.c         |  28 ++++
 validation/constexpr-pointer-cast.c          |  13 ++
 validation/constexpr-preop.c                 |  29 ++++
 validation/constexpr-string.c                |   9 ++
 validation/constexpr-types-compatible-p.c    |   9 ++
 22 files changed, 640 insertions(+), 91 deletions(-)
 create mode 100644 validation/constexpr-addr-of-static-member.c
 create mode 100644 validation/constexpr-addr-of-static.c
 create mode 100644 validation/constexpr-binop.c
 create mode 100644 validation/constexpr-cast.c
 create mode 100644 validation/constexpr-compound-literal.c
 create mode 100644 validation/constexpr-conditional.c
 create mode 100644 validation/constexpr-init.c
 create mode 100644 validation/constexpr-labelref.c
 create mode 100644 validation/constexpr-offsetof.c
 create mode 100644 validation/constexpr-pointer-arith.c
 create mode 100644 validation/constexpr-pointer-cast.c
 create mode 100644 validation/constexpr-preop.c
 create mode 100644 validation/constexpr-string.c
 create mode 100644 validation/constexpr-types-compatible-p.c

-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 19 Feb 2016 08:22:50 +0000
Message-ID: <87y4ahun1h.fsf () gmail ! com>
--------------------
Nicolai Stange <nicstange@gmail.com> writes:

> Here comes the greatly enhanced v3 of this series.

Just a gently push to get some reviews on this...


>
> Luc's suggestions about splitting some patches turned out to be very fruitful!
>
> Former [01/13] ("expression: introduce additional expression constness tracking flags")
> has been split into
> - [01/21] ("expression: introduce additional expression constness tracking flags")
> - [02/21] ("expression: init constexpr_flags at expression allocation")
> - [07/21] ("expression: add support for tagging arithmetic constant expressions")
>
> In particular, the introduction of the arithmetic constant expression
> flag is deferred until the last one of these three. This addresses
> Luc's concerns that the arithmetic constant expression handlings
> within the v2 "examine constness of XXX at evaluation only"-patches
> should better get split off into a separate patch each.
>
>
> Former [06/13] ("expression, evaluate: add support for recognizing address constants")
> has been split into
> - [08/21] ("expression, evaluate: add support for tagging address constants")
> - [10/21] ("expression, evaluate: recognize static objects as address constants")
> - [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
> - [13/21] ("evaluate: recognize members of static compound objects as address constants")
> - [14/21] ("evaluate: recognize string literals as address constants")
>
> The address constant handling part from former
> [02/13] ("expression: examine constness of casts at evaluation only")
> has been extracted into a patch on its own, namely
> [11/21] ("evaluate: recognize address constants created through casts")
>
> Patches [10-14/21] have been placed just until after static initializer checking
> has been introduced in
> [09/21] ("evaluate: check static storage duration objects' intializers' constness").
> This way, the monster testcase from former
> [07/13] ("evaluate: check static storage duration objects' intializers' constness")
> can be split and the individual tests attached to the different
> patches as appropriate.
>
>
> Note that we still have got this
> [20/21] ("symbol: do not inherit storage modifiers from base types at examination")
> thing.
>
>
> Detailed changes:
> [01/21] ("expression: introduce additional expression constness tracking flags"):
>   - The expr_{set,clear}_flag() helpers have been replaced by bitmasks
>     to be ored in or anded outnow.
>   - Renamed ->flags to ->constexpr_flags
>   - ->constexpr_flags initialization at expression allocation has been
>     extracted into
>     [02/21] ("expression: init constexpr_flags at expression allocation")
>   - neither of the arithmetic constant expression flag nor address nor the
>     address constant flag gets introduced by this patch anymore.
>     They get introduced in 
>     [07/21] ("expression: add support for tagging arithmetic constant expressions")
>     [08/21] ("expression, evaluate: add support for tagging address constants")
>     as needed.
>   - Luc's remarks about the 'sic' comments carried over from the original
>     code have been addressed in the new 
>     [21/21] ("evaluation: treat comparsions between types as integer constexpr")
>   - Changes to patch description as suggested by Luc.
>   - Tag a TOKEN_ZERO_IDENT by integer constant instead of integer
>     constant expression. Feels more natural but should not matter.
>
> [02/21] ("expression: init constexpr_flags at expression allocation")
>   This one is new. Split off from former [01/13].
>
> [03-06/21] ("expression: examine constness of XXX at evaluation only")
>   Adjusted patch descriptions as suggested by Luc.
>
> [07/21] ("expression: add support for tagging arithmetic constant expressions")
>   This one is new. Split off from former [01/13].
>
> [08/21] ("expression, evaluate: add support for tagging address constants")
>   Split off actual recognition of various address constant forms into
>   separate patches [10-14/21]
>
> [09/21] ("evaluate: check static storage duration objects' intializers' constness").
>   - -W-flag has been renamed to -Wconstexpr-not-const
>   - the associated warning message has been shortened to
>     "non-constant initializer for static object".
>   - the attached testcase has been greatly reduced as the tests are now
>     attached to the patches [10-14/21].
>
> [10-14/21]
>   These ones are new and split off from former
>   [06/13] ("expression, evaluate: add support for tagging address constants")
>   They implement actual address constant recognition functionality.
>   
>   In
>   [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
>   a whitespace issue from former
>   [06/13] ("expression, evaluate: add support for recognizing address constants")
>   in an if-clause has been fixed.
>
>
> [15/21] ("expression: recognize references to labels as address constants")
>   A testcase for has been added.
>
>
> [19/21] ("evaluate: relax some constant expression rules for pointer expressions")
>   A typo ("adress") has been fixed.
>
> [21/21] ("evaluation: treat comparsions between types as integer constexpr")
>   This one is new.
>
>
> Nicolai Stange (21):
>   expression: introduce additional expression constness tracking flags
>   expression: init constexpr_flags at expression allocation
>   expression: examine constness of casts at evaluation only
>   expression: examine constness of binops and alike at evaluation only
>   expression: examine constness of preops at evaluation only
>   expression: examine constness of conditionals at evaluation only
>   expression: add support for tagging arithmetic constant expressions
>   expression, evaluate: add support for tagging address constants
>   evaluate: check static storage duration objects' intializers'
>     constness
>   expression, evaluate: recognize static objects as address constants
>   evaluate: recognize address constants created through casts
>   evaluate: recognize address constants created through pointer
>     arithmetic
>   evaluate: recognize members of static compound objects as address
>     constants
>   evaluate: recognize string literals as address constants
>   expression: recognize references to labels as address constants
>   expression: examine constness of __builtin_offsetof at evaluation only
>   symbol: flag builtins constant_p, safe_p and warning as constexprs
>   evaluate: relax some constant expression rules for pointer expressions
>   expression, evaluate: support compound literals as address constants
>   symbol: do not inherit storage modifiers from base types at
>     examination
>   evaluation: treat comparsions between types as integer constexpr
>
>  evaluate.c                                   | 207 +++++++++++++++++++++------
>  expand.c                                     |  10 +-
>  expression.c                                 |  50 +++----
>  expression.h                                 |  83 ++++++++++-
>  lib.c                                        |   2 +
>  lib.h                                        |   1 +
>  sparse.1                                     |   9 ++
>  symbol.c                                     |  12 +-
>  validation/constexpr-addr-of-static-member.c |  26 ++++
>  validation/constexpr-addr-of-static.c        |  36 +++++
>  validation/constexpr-binop.c                 |  33 +++++
>  validation/constexpr-cast.c                  |  25 ++++
>  validation/constexpr-compound-literal.c      |  19 +++
>  validation/constexpr-conditional.c           |  34 +++++
>  validation/constexpr-init.c                  |  60 ++++++++
>  validation/constexpr-labelref.c              |  15 ++
>  validation/constexpr-offsetof.c              |  21 +++
>  validation/constexpr-pointer-arith.c         |  28 ++++
>  validation/constexpr-pointer-cast.c          |  13 ++
>  validation/constexpr-preop.c                 |  29 ++++
>  validation/constexpr-string.c                |   9 ++
>  validation/constexpr-types-compatible-p.c    |   9 ++
>  22 files changed, 640 insertions(+), 91 deletions(-)
>  create mode 100644 validation/constexpr-addr-of-static-member.c
>  create mode 100644 validation/constexpr-addr-of-static.c
>  create mode 100644 validation/constexpr-binop.c
>  create mode 100644 validation/constexpr-cast.c
>  create mode 100644 validation/constexpr-compound-literal.c
>  create mode 100644 validation/constexpr-conditional.c
>  create mode 100644 validation/constexpr-init.c
>  create mode 100644 validation/constexpr-labelref.c
>  create mode 100644 validation/constexpr-offsetof.c
>  create mode 100644 validation/constexpr-pointer-arith.c
>  create mode 100644 validation/constexpr-pointer-cast.c
>  create mode 100644 validation/constexpr-preop.c
>  create mode 100644 validation/constexpr-string.c
>  create mode 100644 validation/constexpr-types-compatible-p.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 19 Feb 2016 08:22:50 +0000
Message-ID: <87y4ahun1h.fsf () gmail ! com>
--------------------
Nicolai Stange <nicstange@gmail.com> writes:

> Here comes the greatly enhanced v3 of this series.

Just a gently push to get some reviews on this...


>
> Luc's suggestions about splitting some patches turned out to be very fruitful!
>
> Former [01/13] ("expression: introduce additional expression constness tracking flags")
> has been split into
> - [01/21] ("expression: introduce additional expression constness tracking flags")
> - [02/21] ("expression: init constexpr_flags at expression allocation")
> - [07/21] ("expression: add support for tagging arithmetic constant expressions")
>
> In particular, the introduction of the arithmetic constant expression
> flag is deferred until the last one of these three. This addresses
> Luc's concerns that the arithmetic constant expression handlings
> within the v2 "examine constness of XXX at evaluation only"-patches
> should better get split off into a separate patch each.
>
>
> Former [06/13] ("expression, evaluate: add support for recognizing address constants")
> has been split into
> - [08/21] ("expression, evaluate: add support for tagging address constants")
> - [10/21] ("expression, evaluate: recognize static objects as address constants")
> - [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
> - [13/21] ("evaluate: recognize members of static compound objects as address constants")
> - [14/21] ("evaluate: recognize string literals as address constants")
>
> The address constant handling part from former
> [02/13] ("expression: examine constness of casts at evaluation only")
> has been extracted into a patch on its own, namely
> [11/21] ("evaluate: recognize address constants created through casts")
>
> Patches [10-14/21] have been placed just until after static initializer checking
> has been introduced in
> [09/21] ("evaluate: check static storage duration objects' intializers' constness").
> This way, the monster testcase from former
> [07/13] ("evaluate: check static storage duration objects' intializers' constness")
> can be split and the individual tests attached to the different
> patches as appropriate.
>
>
> Note that we still have got this
> [20/21] ("symbol: do not inherit storage modifiers from base types at examination")
> thing.
>
>
> Detailed changes:
> [01/21] ("expression: introduce additional expression constness tracking flags"):
>   - The expr_{set,clear}_flag() helpers have been replaced by bitmasks
>     to be ored in or anded outnow.
>   - Renamed ->flags to ->constexpr_flags
>   - ->constexpr_flags initialization at expression allocation has been
>     extracted into
>     [02/21] ("expression: init constexpr_flags at expression allocation")
>   - neither of the arithmetic constant expression flag nor address nor the
>     address constant flag gets introduced by this patch anymore.
>     They get introduced in 
>     [07/21] ("expression: add support for tagging arithmetic constant expressions")
>     [08/21] ("expression, evaluate: add support for tagging address constants")
>     as needed.
>   - Luc's remarks about the 'sic' comments carried over from the original
>     code have been addressed in the new 
>     [21/21] ("evaluation: treat comparsions between types as integer constexpr")
>   - Changes to patch description as suggested by Luc.
>   - Tag a TOKEN_ZERO_IDENT by integer constant instead of integer
>     constant expression. Feels more natural but should not matter.
>
> [02/21] ("expression: init constexpr_flags at expression allocation")
>   This one is new. Split off from former [01/13].
>
> [03-06/21] ("expression: examine constness of XXX at evaluation only")
>   Adjusted patch descriptions as suggested by Luc.
>
> [07/21] ("expression: add support for tagging arithmetic constant expressions")
>   This one is new. Split off from former [01/13].
>
> [08/21] ("expression, evaluate: add support for tagging address constants")
>   Split off actual recognition of various address constant forms into
>   separate patches [10-14/21]
>
> [09/21] ("evaluate: check static storage duration objects' intializers' constness").
>   - -W-flag has been renamed to -Wconstexpr-not-const
>   - the associated warning message has been shortened to
>     "non-constant initializer for static object".
>   - the attached testcase has been greatly reduced as the tests are now
>     attached to the patches [10-14/21].
>
> [10-14/21]
>   These ones are new and split off from former
>   [06/13] ("expression, evaluate: add support for tagging address constants")
>   They implement actual address constant recognition functionality.
>   
>   In
>   [12/21] ("evaluate: recognize address constants created through pointer arithmetic")
>   a whitespace issue from former
>   [06/13] ("expression, evaluate: add support for recognizing address constants")
>   in an if-clause has been fixed.
>
>
> [15/21] ("expression: recognize references to labels as address constants")
>   A testcase for has been added.
>
>
> [19/21] ("evaluate: relax some constant expression rules for pointer expressions")
>   A typo ("adress") has been fixed.
>
> [21/21] ("evaluation: treat comparsions between types as integer constexpr")
>   This one is new.
>
>
> Nicolai Stange (21):
>   expression: introduce additional expression constness tracking flags
>   expression: init constexpr_flags at expression allocation
>   expression: examine constness of casts at evaluation only
>   expression: examine constness of binops and alike at evaluation only
>   expression: examine constness of preops at evaluation only
>   expression: examine constness of conditionals at evaluation only
>   expression: add support for tagging arithmetic constant expressions
>   expression, evaluate: add support for tagging address constants
>   evaluate: check static storage duration objects' intializers'
>     constness
>   expression, evaluate: recognize static objects as address constants
>   evaluate: recognize address constants created through casts
>   evaluate: recognize address constants created through pointer
>     arithmetic
>   evaluate: recognize members of static compound objects as address
>     constants
>   evaluate: recognize string literals as address constants
>   expression: recognize references to labels as address constants
>   expression: examine constness of __builtin_offsetof at evaluation only
>   symbol: flag builtins constant_p, safe_p and warning as constexprs
>   evaluate: relax some constant expression rules for pointer expressions
>   expression, evaluate: support compound literals as address constants
>   symbol: do not inherit storage modifiers from base types at
>     examination
>   evaluation: treat comparsions between types as integer constexpr
>
>  evaluate.c                                   | 207 +++++++++++++++++++++------
>  expand.c                                     |  10 +-
>  expression.c                                 |  50 +++----
>  expression.h                                 |  83 ++++++++++-
>  lib.c                                        |   2 +
>  lib.h                                        |   1 +
>  sparse.1                                     |   9 ++
>  symbol.c                                     |  12 +-
>  validation/constexpr-addr-of-static-member.c |  26 ++++
>  validation/constexpr-addr-of-static.c        |  36 +++++
>  validation/constexpr-binop.c                 |  33 +++++
>  validation/constexpr-cast.c                  |  25 ++++
>  validation/constexpr-compound-literal.c      |  19 +++
>  validation/constexpr-conditional.c           |  34 +++++
>  validation/constexpr-init.c                  |  60 ++++++++
>  validation/constexpr-labelref.c              |  15 ++
>  validation/constexpr-offsetof.c              |  21 +++
>  validation/constexpr-pointer-arith.c         |  28 ++++
>  validation/constexpr-pointer-cast.c          |  13 ++
>  validation/constexpr-preop.c                 |  29 ++++
>  validation/constexpr-string.c                |   9 ++
>  validation/constexpr-types-compatible-p.c    |   9 ++
>  22 files changed, 640 insertions(+), 91 deletions(-)
>  create mode 100644 validation/constexpr-addr-of-static-member.c
>  create mode 100644 validation/constexpr-addr-of-static.c
>  create mode 100644 validation/constexpr-binop.c
>  create mode 100644 validation/constexpr-cast.c
>  create mode 100644 validation/constexpr-compound-literal.c
>  create mode 100644 validation/constexpr-conditional.c
>  create mode 100644 validation/constexpr-init.c
>  create mode 100644 validation/constexpr-labelref.c
>  create mode 100644 validation/constexpr-offsetof.c
>  create mode 100644 validation/constexpr-pointer-arith.c
>  create mode 100644 validation/constexpr-pointer-cast.c
>  create mode 100644 validation/constexpr-preop.c
>  create mode 100644 validation/constexpr-string.c
>  create mode 100644 validation/constexpr-types-compatible-p.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 24 Feb 2016 09:45:22 +0000
Message-ID: <CANeU7QmexP2=N49uP3fgWQDvqaFSO_APr+DD6C2_exBSTfyW+A () mail ! gmail ! com>
--------------------
Sorry for the late reply.

I take a look of your V3 patches.

May I ask a few questions regarding the constant expression.

+       CONSTEXPR_FLAG_INT_CONST = (1 << 0),
+       CONSTEXPR_FLAG_FP_CONST = (1 << 1),
+       CONSTEXPR_FLAG_ENUM_CONST = (1 << 2),
+       CONSTEXPR_FLAG_CHAR_CONST = (1 << 3),

Can I say each of the above constant type are elusive to each other?
e.g. the floating point constant can not be a integer constant at the
same time.

+
+       /*
+        * A constant expression in the sense of [6.6]:
+        * - integer constant expression [6.6(6)]
+        */
+       CONSTEXPR_FLAG_INT_CONST_EXPR = (1 << 4),

Can we express the const expression in terms of above constant flags?
Each expression will have a ctype associate with it. It can be one of the
int/fp/enum/char type.

e.g. "1.0 + 1" is a floating type expression according to the C rules.

In other words, it seems to me that the constant expression
should have a deterministic ctype. We should be able to reuse the above
constant flag without adding a new one. If not, please give some example
to help me understand the issue.

I am not suggesting to change your patches at this stage. It just
help me understand your patch.

Thanks

Chris



On Fri, Feb 19, 2016 at 4:22 PM, Nicolai Stange <nicstange@gmail.com> wrote:
> Nicolai Stange <nicstange@gmail.com> writes:
>
>> Here comes the greatly enhanced v3 of this series.
>
> Just a gently push to get some reviews on this...
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 24 Feb 2016 12:13:07 +0000
Message-ID: <87si0il31o.fsf () gmail ! com>
--------------------
Hi Chris,

Christopher Li <sparse@chrisli.org> writes:

> Sorry for the late reply.

no problem, I just wanted to make sure that this series doesn't orphan
in the end.

> I take a look of your V3 patches.
>
> May I ask a few questions regarding the constant expression.
>
> +       CONSTEXPR_FLAG_INT_CONST = (1 << 0),
> +       CONSTEXPR_FLAG_FP_CONST = (1 << 1),
> +       CONSTEXPR_FLAG_ENUM_CONST = (1 << 2),
> +       CONSTEXPR_FLAG_CHAR_CONST = (1 << 3),
>
> Can I say each of the above constant type are elusive to each other?
> e.g. the floating point constant can not be a integer constant at the
> same time.

Yes, that's correct, they are all exclusive to each other.
To make it explicit: the above flags apply to literals.

>
> +
> +       /*
> +        * A constant expression in the sense of [6.6]:
> +        * - integer constant expression [6.6(6)]
> +        */
> +       CONSTEXPR_FLAG_INT_CONST_EXPR = (1 << 4),
>
> Can we express the const expression in terms of above constant flags?
> Each expression will have a ctype associate with it. It can be one of the
> int/fp/enum/char type.
>
> e.g. "1.0 + 1" is a floating type expression according to the C rules.

Yes, it is an arithmetic constant expression of floating point type.

Just like (int)(1.0 + 1) is an arithmetic constant expression of integer
type, but *not* and integer constant expression: floating constants are
allowed in integer constant expressions only if they are the *immediate*
operands of casts [6.6(6)].

>
> In other words, it seems to me that the constant expression
> should have a deterministic ctype. We should be able to reuse the above
> constant flag without adding a new one. If not, please give some example
> to help me understand the issue.

I.
In the first place, we really need to distinguish between the higher
level constant expression productions
- integer constant expressions
- arithmetic constant expressions
- address constants

Example:
  int a[] = { [(int)(0.0 + 0)] = 0 };

is not valid C code, since (int)(0.0 + 0) is not an integer constant
expression (see above).

OTOH, (int)0.0 *is* an integer constant expression.

Thus, it is not enough to tag floating constants as simply being an
arithmetic constant expression, the distinction is really needed here.


II.
For the case of integer constant literals vs. integer constant
expressions: in theory, the distinction between integer constant
literals and enum/char constants is necessary, because

  (void*)0

qualifies as an address constant, but

  enum foo { bar = 0, };
  (void*)bar

does not [6.6(9)].

To be honest, this overly strict requirement on address constants is
relaxed in
  [18/21] ("evaluate: relax some constant expression rules for pointer expressions")
again. However, this relaxation allows for constructs such as
  (void *)(int)0.0
qualifying as an address constant which might not be the desired behaviour.


Conclusion: As it stands, we should be able to do
  #define CONSTEXPR_FLAG_INT_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
  #define CONSTEXPR_FLAG_ENUM_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
  #define CONSTEXPR_FLAG_CHAR_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
since we do not distinguish between integer constant expressions and
integer constant literals. However this ignorance violates the C
standard, in particular [6.6(9)] and we might want to be able to easily
change this in the future. And yes, we could certainly distinguish
between a char/enum constant and an integer constant literal based on
its ctype. However, I personally don't like to treat integer, enum and
char consts different than floating point consts, since they are kind of
at the same level logically.

>
> I am not suggesting to change your patches at this stage. It just
> help me understand your patch.


Thank you for reviewing!

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 24 Feb 2016 12:13:07 +0000
Message-ID: <87si0il31o.fsf () gmail ! com>
--------------------
Hi Chris,

Christopher Li <sparse@chrisli.org> writes:

> Sorry for the late reply.

no problem, I just wanted to make sure that this series doesn't orphan
in the end.

> I take a look of your V3 patches.
>
> May I ask a few questions regarding the constant expression.
>
> +       CONSTEXPR_FLAG_INT_CONST = (1 << 0),
> +       CONSTEXPR_FLAG_FP_CONST = (1 << 1),
> +       CONSTEXPR_FLAG_ENUM_CONST = (1 << 2),
> +       CONSTEXPR_FLAG_CHAR_CONST = (1 << 3),
>
> Can I say each of the above constant type are elusive to each other?
> e.g. the floating point constant can not be a integer constant at the
> same time.

Yes, that's correct, they are all exclusive to each other.
To make it explicit: the above flags apply to literals.

>
> +
> +       /*
> +        * A constant expression in the sense of [6.6]:
> +        * - integer constant expression [6.6(6)]
> +        */
> +       CONSTEXPR_FLAG_INT_CONST_EXPR = (1 << 4),
>
> Can we express the const expression in terms of above constant flags?
> Each expression will have a ctype associate with it. It can be one of the
> int/fp/enum/char type.
>
> e.g. "1.0 + 1" is a floating type expression according to the C rules.

Yes, it is an arithmetic constant expression of floating point type.

Just like (int)(1.0 + 1) is an arithmetic constant expression of integer
type, but *not* and integer constant expression: floating constants are
allowed in integer constant expressions only if they are the *immediate*
operands of casts [6.6(6)].

>
> In other words, it seems to me that the constant expression
> should have a deterministic ctype. We should be able to reuse the above
> constant flag without adding a new one. If not, please give some example
> to help me understand the issue.

I.
In the first place, we really need to distinguish between the higher
level constant expression productions
- integer constant expressions
- arithmetic constant expressions
- address constants

Example:
  int a[] = { [(int)(0.0 + 0)] = 0 };

is not valid C code, since (int)(0.0 + 0) is not an integer constant
expression (see above).

OTOH, (int)0.0 *is* an integer constant expression.

Thus, it is not enough to tag floating constants as simply being an
arithmetic constant expression, the distinction is really needed here.


II.
For the case of integer constant literals vs. integer constant
expressions: in theory, the distinction between integer constant
literals and enum/char constants is necessary, because

  (void*)0

qualifies as an address constant, but

  enum foo { bar = 0, };
  (void*)bar

does not [6.6(9)].

To be honest, this overly strict requirement on address constants is
relaxed in
  [18/21] ("evaluate: relax some constant expression rules for pointer expressions")
again. However, this relaxation allows for constructs such as
  (void *)(int)0.0
qualifying as an address constant which might not be the desired behaviour.


Conclusion: As it stands, we should be able to do
  #define CONSTEXPR_FLAG_INT_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
  #define CONSTEXPR_FLAG_ENUM_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
  #define CONSTEXPR_FLAG_CHAR_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
since we do not distinguish between integer constant expressions and
integer constant literals. However this ignorance violates the C
standard, in particular [6.6(9)] and we might want to be able to easily
change this in the future. And yes, we could certainly distinguish
between a char/enum constant and an integer constant literal based on
its ctype. However, I personally don't like to treat integer, enum and
char consts different than floating point consts, since they are kind of
at the same level logically.

>
> I am not suggesting to change your patches at this stage. It just
> help me understand your patch.


Thank you for reviewing!

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 24 Feb 2016 12:13:07 +0000
Message-ID: <87si0il31o.fsf () gmail ! com>
--------------------
Hi Chris,

Christopher Li <sparse@chrisli.org> writes:

> Sorry for the late reply.

no problem, I just wanted to make sure that this series doesn't orphan
in the end.

> I take a look of your V3 patches.
>
> May I ask a few questions regarding the constant expression.
>
> +       CONSTEXPR_FLAG_INT_CONST = (1 << 0),
> +       CONSTEXPR_FLAG_FP_CONST = (1 << 1),
> +       CONSTEXPR_FLAG_ENUM_CONST = (1 << 2),
> +       CONSTEXPR_FLAG_CHAR_CONST = (1 << 3),
>
> Can I say each of the above constant type are elusive to each other?
> e.g. the floating point constant can not be a integer constant at the
> same time.

Yes, that's correct, they are all exclusive to each other.
To make it explicit: the above flags apply to literals.

>
> +
> +       /*
> +        * A constant expression in the sense of [6.6]:
> +        * - integer constant expression [6.6(6)]
> +        */
> +       CONSTEXPR_FLAG_INT_CONST_EXPR = (1 << 4),
>
> Can we express the const expression in terms of above constant flags?
> Each expression will have a ctype associate with it. It can be one of the
> int/fp/enum/char type.
>
> e.g. "1.0 + 1" is a floating type expression according to the C rules.

Yes, it is an arithmetic constant expression of floating point type.

Just like (int)(1.0 + 1) is an arithmetic constant expression of integer
type, but *not* and integer constant expression: floating constants are
allowed in integer constant expressions only if they are the *immediate*
operands of casts [6.6(6)].

>
> In other words, it seems to me that the constant expression
> should have a deterministic ctype. We should be able to reuse the above
> constant flag without adding a new one. If not, please give some example
> to help me understand the issue.

I.
In the first place, we really need to distinguish between the higher
level constant expression productions
- integer constant expressions
- arithmetic constant expressions
- address constants

Example:
  int a[] = { [(int)(0.0 + 0)] = 0 };

is not valid C code, since (int)(0.0 + 0) is not an integer constant
expression (see above).

OTOH, (int)0.0 *is* an integer constant expression.

Thus, it is not enough to tag floating constants as simply being an
arithmetic constant expression, the distinction is really needed here.


II.
For the case of integer constant literals vs. integer constant
expressions: in theory, the distinction between integer constant
literals and enum/char constants is necessary, because

  (void*)0

qualifies as an address constant, but

  enum foo { bar = 0, };
  (void*)bar

does not [6.6(9)].

To be honest, this overly strict requirement on address constants is
relaxed in
  [18/21] ("evaluate: relax some constant expression rules for pointer expressions")
again. However, this relaxation allows for constructs such as
  (void *)(int)0.0
qualifying as an address constant which might not be the desired behaviour.


Conclusion: As it stands, we should be able to do
  #define CONSTEXPR_FLAG_INT_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
  #define CONSTEXPR_FLAG_ENUM_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
  #define CONSTEXPR_FLAG_CHAR_CONST CONSTEXPR_FLAG_INT_CONST_EXPR
since we do not distinguish between integer constant expressions and
integer constant literals. However this ignorance violates the C
standard, in particular [6.6(9)] and we might want to be able to easily
change this in the future. And yes, we could certainly distinguish
between a char/enum constant and an integer constant literal based on
its ctype. However, I personally don't like to treat integer, enum and
char consts different than floating point consts, since they are kind of
at the same level logically.

>
> I am not suggesting to change your patches at this stage. It just
> help me understand your patch.


Thank you for reviewing!

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 15 Mar 2016 16:54:41 +0000
Message-ID: <20160315165440.GA1283 () macpro ! local>
--------------------
On Fri, Feb 19, 2016 at 09:22:50AM +0100, Nicolai Stange wrote:
> Nicolai Stange <nicstange@gmail.com> writes:
> 
> > Here comes the greatly enhanced v3 of this series.
> 
> Just a gently push to get some reviews on this...
> 

Sorry for haven't been able to comment on this earlier.
I'm catching up.


Regards,
Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 15 Mar 2016 16:54:41 +0000
Message-ID: <20160315165440.GA1283 () macpro ! local>
--------------------
On Fri, Feb 19, 2016 at 09:22:50AM +0100, Nicolai Stange wrote:
> Nicolai Stange <nicstange@gmail.com> writes:
> 
> > Here comes the greatly enhanced v3 of this series.
> 
> Just a gently push to get some reviews on this...
> 

Sorry for haven't been able to comment on this earlier.
I'm catching up.


Regards,
Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 15 Mar 2016 22:36:17 +0000
Message-ID: <20160315223616.GB2679 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:28:38AM +0100, Nicolai Stange wrote:
> Here comes the greatly enhanced v3 of this series.
> 


I had a few remarks and some questions in some of the patches
but I think it's turning pretty good.

I'm wondering if you have already tried to use it on something of
interesting size like the kernel? If yes, did it gave something useful?


Chris, I have reviewed this rather deeply. I think the approach is sound
and sane et the code seems quite correct. Do you think you will have
some time soon to look at it?


Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 15 Mar 2016 22:36:17 +0000
Message-ID: <20160315223616.GB2679 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:28:38AM +0100, Nicolai Stange wrote:
> Here comes the greatly enhanced v3 of this series.
> 


I had a few remarks and some questions in some of the patches
but I think it's turning pretty good.

I'm wondering if you have already tried to use it on something of
interesting size like the kernel? If yes, did it gave something useful?


Chris, I have reviewed this rather deeply. I think the approach is sound
and sane et the code seems quite correct. Do you think you will have
some time soon to look at it?


Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 28 Oct 2016 20:28:28 +0000
Message-ID: <20161028202827.GA2185 () macbook ! local>
--------------------
On Tue, Mar 15, 2016 at 11:36:17PM +0100, Luc Van Oostenryck wrote:
> On Mon, Feb 01, 2016 at 03:28:38AM +0100, Nicolai Stange wrote:
> > Here comes the greatly enhanced v3 of this series.
> > 
> 
> 
> I had a few remarks and some questions in some of the patches
> but I think it's turning pretty good.
> 
> I'm wondering if you have already tried to use it on something of
> interesting size like the kernel? If yes, did it gave something useful?
> 
> 
> Chris, I have reviewed this rather deeply. I think the approach is sound
> and sane et the code seems quite correct. Do you think you will have
> some time soon to look at it?
> 
Chris, is it possible to have some feedback on this, please?

Is there anything more I can do to help?


Best regards,

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 03:12:02 +0000
Message-ID: <CANeU7QnzjJ5g+nGik21qsFAZ_5La3GOKVcTAx6=NOhVrVmrEQA () mail ! gmail ! com>
--------------------
On Mon, Feb 1, 2016 at 10:28 AM, Nicolai Stange <nicstange@gmail.com> wrote:
> Here comes the greatly enhanced v3 of this series.
>
> Luc's suggestions about splitting some patches turned out to be very fruitful!

OK, I am taking a stab at his again. Sorry for the long hold off.
I will reply from this thread instead of finding the right patch email
to reply on.

+++ validation/constexpr-cast.c 2016-11-23 09:57:37.638646787 +0800
@@ -0,0 +1,25 @@
+static int a[] = {
+       [(int)0] = 0,           // OK
+       [(int)(int)0] = 0,      // OK
+       [(int)0.] = 0,          // OK
+       [(int)(int)0.] = 0,     // OK
+       [(int)__builtin_choose_expr(0, 0, 0)] = 0,      // OK
+       [(int)__builtin_choose_expr(0, 0, 0.)] = 0,     // OK
+
+       [(int)(float)0] = 0,    // KO

Why is this one KO? It seems perfectly fine to force a floating
type into a integer constant expression.

per [6.6.6]  quote: on integer constant expression:
 " and floating constants that are the
immediate operands of casts. Cast operators in an integer constant
expression shall only
convert arithmetic types to integer types,"

+       [(int)(float)0.] = 0,   // KO
+
+       [(int)(void*)0] = 0,    // KO

Also this one should be fine?

[6.7.8.6] quote as
" If a designator has the form
[ constant-expression ]
then the current object (defined below) shall have array type and the
expression shall be
an *integer constant expression*."

So it seems the only requirement is *integer constant expression*.
why (int)(void*)0 is not integer constant expression? Sure there is
a warning about converting the (void*) into (int) for a different size.
But that is a separate issue.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 03:12:02 +0000
Message-ID: <CANeU7QnzjJ5g+nGik21qsFAZ_5La3GOKVcTAx6=NOhVrVmrEQA () mail ! gmail ! com>
--------------------
On Mon, Feb 1, 2016 at 10:28 AM, Nicolai Stange <nicstange@gmail.com> wrote:
> Here comes the greatly enhanced v3 of this series.
>
> Luc's suggestions about splitting some patches turned out to be very fruitful!

OK, I am taking a stab at his again. Sorry for the long hold off.
I will reply from this thread instead of finding the right patch email
to reply on.

+++ validation/constexpr-cast.c 2016-11-23 09:57:37.638646787 +0800
@@ -0,0 +1,25 @@
+static int a[] = {
+       [(int)0] = 0,           // OK
+       [(int)(int)0] = 0,      // OK
+       [(int)0.] = 0,          // OK
+       [(int)(int)0.] = 0,     // OK
+       [(int)__builtin_choose_expr(0, 0, 0)] = 0,      // OK
+       [(int)__builtin_choose_expr(0, 0, 0.)] = 0,     // OK
+
+       [(int)(float)0] = 0,    // KO

Why is this one KO? It seems perfectly fine to force a floating
type into a integer constant expression.

per [6.6.6]  quote: on integer constant expression:
 " and floating constants that are the
immediate operands of casts. Cast operators in an integer constant
expression shall only
convert arithmetic types to integer types,"

+       [(int)(float)0.] = 0,   // KO
+
+       [(int)(void*)0] = 0,    // KO

Also this one should be fine?

[6.7.8.6] quote as
" If a designator has the form
[ constant-expression ]
then the current object (defined below) shall have array type and the
expression shall be
an *integer constant expression*."

So it seems the only requirement is *integer constant expression*.
why (int)(void*)0 is not integer constant expression? Sure there is
a warning about converting the (void*) into (int) for a different size.
But that is a separate issue.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 03:12:02 +0000
Message-ID: <CANeU7QnzjJ5g+nGik21qsFAZ_5La3GOKVcTAx6=NOhVrVmrEQA () mail ! gmail ! com>
--------------------
On Mon, Feb 1, 2016 at 10:28 AM, Nicolai Stange <nicstange@gmail.com> wrote:
> Here comes the greatly enhanced v3 of this series.
>
> Luc's suggestions about splitting some patches turned out to be very fruitful!

OK, I am taking a stab at his again. Sorry for the long hold off.
I will reply from this thread instead of finding the right patch email
to reply on.

+++ validation/constexpr-cast.c 2016-11-23 09:57:37.638646787 +0800
@@ -0,0 +1,25 @@
+static int a[] = {
+       [(int)0] = 0,           // OK
+       [(int)(int)0] = 0,      // OK
+       [(int)0.] = 0,          // OK
+       [(int)(int)0.] = 0,     // OK
+       [(int)__builtin_choose_expr(0, 0, 0)] = 0,      // OK
+       [(int)__builtin_choose_expr(0, 0, 0.)] = 0,     // OK
+
+       [(int)(float)0] = 0,    // KO

Why is this one KO? It seems perfectly fine to force a floating
type into a integer constant expression.

per [6.6.6]  quote: on integer constant expression:
 " and floating constants that are the
immediate operands of casts. Cast operators in an integer constant
expression shall only
convert arithmetic types to integer types,"

+       [(int)(float)0.] = 0,   // KO
+
+       [(int)(void*)0] = 0,    // KO

Also this one should be fine?

[6.7.8.6] quote as
" If a designator has the form
[ constant-expression ]
then the current object (defined below) shall have array type and the
expression shall be
an *integer constant expression*."

So it seems the only requirement is *integer constant expression*.
why (int)(void*)0 is not integer constant expression? Sure there is
a warning about converting the (void*) into (int) for a different size.
But that is a separate issue.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 04:05:29 +0000
Message-ID: <20161123040528.GA74337 () macpro ! local>
--------------------
On Wed, Nov 23, 2016 at 11:12:02AM +0800, Christopher Li wrote:
> +static int a[] = {
> +       [(int)0] = 0,           // OK
> +       [(int)(int)0] = 0,      // OK
> +       [(int)0.] = 0,          // OK
> +       [(int)(int)0.] = 0,     // OK
> +       [(int)__builtin_choose_expr(0, 0, 0)] = 0,      // OK
> +       [(int)__builtin_choose_expr(0, 0, 0.)] = 0,     // OK
> +
> +       [(int)(float)0] = 0,    // KO
> 
> Why is this one KO? It seems perfectly fine to force a floating
> type into a integer constant expression.
> 
> per [6.6.6]  quote: on integer constant expression:
>  " and floating constants that are the
> immediate operands of casts. Cast operators in an integer constant
> expression shall only
> convert arithmetic types to integer types,"

But, quoting the beginning of 6.6/6:
    An integer constant expression shall have integer type and shall
    only have operands that are integer constants, enumeration constants,
    character constants, sizeof expressions whose results are integer
    constants, and **floating constants** that are the immediate operands
    of casts.

and the part '(float) 0' is none of these.

> +       [(int)(float)0.] = 0,   // KO
> +
> +       [(int)(void*)0] = 0,    // KO
> Also this one should be fine?

same for '(void *) 0'.

It's obvious for me and you that those once casted to (int) should
evaluate to '0' and thus are constant expression but the strict
interpretation of the standard say something else.

And to be honest, I find ridiculous that '(int) 0.0' is a integer
constant expression and '(int)(float)0' is not.

IIRC, Nicolai had foreseen to relax those if needed, possibly even
in one of the later patch or to introduce a '-Wstrict' option or
something like this.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 04:05:29 +0000
Message-ID: <20161123040528.GA74337 () macpro ! local>
--------------------
On Wed, Nov 23, 2016 at 11:12:02AM +0800, Christopher Li wrote:
> +static int a[] = {
> +       [(int)0] = 0,           // OK
> +       [(int)(int)0] = 0,      // OK
> +       [(int)0.] = 0,          // OK
> +       [(int)(int)0.] = 0,     // OK
> +       [(int)__builtin_choose_expr(0, 0, 0)] = 0,      // OK
> +       [(int)__builtin_choose_expr(0, 0, 0.)] = 0,     // OK
> +
> +       [(int)(float)0] = 0,    // KO
> 
> Why is this one KO? It seems perfectly fine to force a floating
> type into a integer constant expression.
> 
> per [6.6.6]  quote: on integer constant expression:
>  " and floating constants that are the
> immediate operands of casts. Cast operators in an integer constant
> expression shall only
> convert arithmetic types to integer types,"

But, quoting the beginning of 6.6/6:
    An integer constant expression shall have integer type and shall
    only have operands that are integer constants, enumeration constants,
    character constants, sizeof expressions whose results are integer
    constants, and **floating constants** that are the immediate operands
    of casts.

and the part '(float) 0' is none of these.

> +       [(int)(float)0.] = 0,   // KO
> +
> +       [(int)(void*)0] = 0,    // KO
> Also this one should be fine?

same for '(void *) 0'.

It's obvious for me and you that those once casted to (int) should
evaluate to '0' and thus are constant expression but the strict
interpretation of the standard say something else.

And to be honest, I find ridiculous that '(int) 0.0' is a integer
constant expression and '(int)(float)0' is not.

IIRC, Nicolai had foreseen to relax those if needed, possibly even
in one of the later patch or to introduce a '-Wstrict' option or
something like this.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 06:49:17 +0000
Message-ID: <CANeU7Qm9FLZUexqu92mUSEojzrbi9SpsYrDMCP7J8qmskHcBFA () mail ! gmail ! com>
--------------------
On Wed, Nov 23, 2016 at 12:05 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> But, quoting the beginning of 6.6/6:
>     An integer constant expression shall have integer type and shall
>     only have operands that are integer constants, enumeration constants,
>     character constants, sizeof expressions whose results are integer
>     constants, and **floating constants** that are the immediate operands
>     of casts.
>
> and the part '(float) 0' is none of these.

I see, thanks for pointing it out.

>> +       [(int)(float)0.] = 0,   // KO
>> +
>> +       [(int)(void*)0] = 0,    // KO
>> Also this one should be fine?
>
> same for '(void *) 0'.
>

Good to know

Another question:
Is there any real reason to distinguish between "const enum/char" and
"const integer"?
Can we roll "const enum/char" as one type of "const integer" as well?

I think the patch can be simpler. The dance of CONSTEXPR_SET and MASK etc is
really messy.

The way I see it, there are three basic type of const elements.
Int ( including enum/char), Float, Address.

Either of which does not has any overlap with each other.

Then each of the matching requirement is just a sets consist of the
above element.
I am not sure there is need to distinguish integer const expression vs arthritic
const expression. (Example please?) If it does, add one more bit as
arthritic operations.

I think the real messy part of the original patch is that,
CONSTEXPR_FLAG_INT_CONST_EXPR
and CONSTEXPR_FLAG_ARITH_CONST_EXPR are two separate bit need to be maintained.
It does not need to be if we treat them as set of the elements.

We only need to keep track of "Int_const_expr, Float_literal, Addr_const_expr"
three bits. May be Arthritic_const_expr if we have need for that.
This patch series really make a difference on adding the "Addr_const_expr".

I am working on a patch on top of the patch series to test it out.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 06:49:17 +0000
Message-ID: <CANeU7Qm9FLZUexqu92mUSEojzrbi9SpsYrDMCP7J8qmskHcBFA () mail ! gmail ! com>
--------------------
On Wed, Nov 23, 2016 at 12:05 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> But, quoting the beginning of 6.6/6:
>     An integer constant expression shall have integer type and shall
>     only have operands that are integer constants, enumeration constants,
>     character constants, sizeof expressions whose results are integer
>     constants, and **floating constants** that are the immediate operands
>     of casts.
>
> and the part '(float) 0' is none of these.

I see, thanks for pointing it out.

>> +       [(int)(float)0.] = 0,   // KO
>> +
>> +       [(int)(void*)0] = 0,    // KO
>> Also this one should be fine?
>
> same for '(void *) 0'.
>

Good to know

Another question:
Is there any real reason to distinguish between "const enum/char" and
"const integer"?
Can we roll "const enum/char" as one type of "const integer" as well?

I think the patch can be simpler. The dance of CONSTEXPR_SET and MASK etc is
really messy.

The way I see it, there are three basic type of const elements.
Int ( including enum/char), Float, Address.

Either of which does not has any overlap with each other.

Then each of the matching requirement is just a sets consist of the
above element.
I am not sure there is need to distinguish integer const expression vs arthritic
const expression. (Example please?) If it does, add one more bit as
arthritic operations.

I think the real messy part of the original patch is that,
CONSTEXPR_FLAG_INT_CONST_EXPR
and CONSTEXPR_FLAG_ARITH_CONST_EXPR are two separate bit need to be maintained.
It does not need to be if we treat them as set of the elements.

We only need to keep track of "Int_const_expr, Float_literal, Addr_const_expr"
three bits. May be Arthritic_const_expr if we have need for that.
This patch series really make a difference on adding the "Addr_const_expr".

I am working on a patch on top of the patch series to test it out.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 06:49:17 +0000
Message-ID: <CANeU7Qm9FLZUexqu92mUSEojzrbi9SpsYrDMCP7J8qmskHcBFA () mail ! gmail ! com>
--------------------
On Wed, Nov 23, 2016 at 12:05 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> But, quoting the beginning of 6.6/6:
>     An integer constant expression shall have integer type and shall
>     only have operands that are integer constants, enumeration constants,
>     character constants, sizeof expressions whose results are integer
>     constants, and **floating constants** that are the immediate operands
>     of casts.
>
> and the part '(float) 0' is none of these.

I see, thanks for pointing it out.

>> +       [(int)(float)0.] = 0,   // KO
>> +
>> +       [(int)(void*)0] = 0,    // KO
>> Also this one should be fine?
>
> same for '(void *) 0'.
>

Good to know

Another question:
Is there any real reason to distinguish between "const enum/char" and
"const integer"?
Can we roll "const enum/char" as one type of "const integer" as well?

I think the patch can be simpler. The dance of CONSTEXPR_SET and MASK etc is
really messy.

The way I see it, there are three basic type of const elements.
Int ( including enum/char), Float, Address.

Either of which does not has any overlap with each other.

Then each of the matching requirement is just a sets consist of the
above element.
I am not sure there is need to distinguish integer const expression vs arthritic
const expression. (Example please?) If it does, add one more bit as
arthritic operations.

I think the real messy part of the original patch is that,
CONSTEXPR_FLAG_INT_CONST_EXPR
and CONSTEXPR_FLAG_ARITH_CONST_EXPR are two separate bit need to be maintained.
It does not need to be if we treat them as set of the elements.

We only need to keep track of "Int_const_expr, Float_literal, Addr_const_expr"
three bits. May be Arthritic_const_expr if we have need for that.
This patch series really make a difference on adding the "Addr_const_expr".

I am working on a patch on top of the patch series to test it out.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 08:39:57 +0000
Message-ID: <87a8cqlhcy.fsf () gmail ! com>
--------------------
Hi Christopher,

Christopher Li <sparse@chrisli.org> writes:

> On Wed, Nov 23, 2016 at 12:05 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> But, quoting the beginning of 6.6/6:
>>     An integer constant expression shall have integer type and shall
>>     only have operands that are integer constants, enumeration constants,
>>     character constants, sizeof expressions whose results are integer
>>     constants, and **floating constants** that are the immediate operands
>>     of casts.
>>
>> and the part '(float) 0' is none of these.
>
> I see, thanks for pointing it out.
>
>>> +       [(int)(float)0.] = 0,   // KO
>>> +
>>> +       [(int)(void*)0] = 0,    // KO
>>> Also this one should be fine?
>>
>> same for '(void *) 0'.
>>
>
> Good to know
>
> Another question:
> Is there any real reason to distinguish between "const enum/char" and
> "const integer"?
> Can we roll "const enum/char" as one type of "const integer" as well?

(void*)'a' doesn't qualify as an address constant, (void *)0 does.

So while we certainly won't need to distinguish enum and char constants
(literals), we have to do so for integer constants (literals) vs
enum/char constants (literals).

Maybe it suffices to simply tag the latter as "integer constant
expression" though. I will have a look on whether the standard allows
character/enum constants at places where it forbids the use of integer
constant expressions.


> I think the patch can be simpler. The dance of CONSTEXPR_SET and MASK etc is
> really messy.
>
> The way I see it, there are three basic type of const elements.
> Int ( including enum/char), Float, Address.
>
> Either of which does not has any overlap with each other.
>
> Then each of the matching requirement is just a sets consist of the
> above element.

Sorry, I don't understand that last sentence. "Set" in the mathematical
sense? How would that look like?


> I am not sure there is need to distinguish integer const expression vs arthritic
> const expression. (Example please?) If it does, add one more bit as
> arthritic operations.

An example would be initialization with designators as shown in the
testcase you quoted above. C.f. 6.7.8(6): only integer constant
expressions are allowed there, but not arithmetic ones.


> I think the real messy part of the original patch is that,
> CONSTEXPR_FLAG_INT_CONST_EXPR
> and CONSTEXPR_FLAG_ARITH_CONST_EXPR are two separate bit need to be maintained.
> It does not need to be if we treat them as set of the elements.
>
> We only need to keep track of "Int_const_expr, Float_literal, Addr_const_expr"
> three bits. May be Arthritic_const_expr if we have need for that.
> This patch series really make a difference on adding the "Addr_const_expr".
>
> I am working on a patch on top of the patch series to test it out.

Prove me wrong, but AFAICS, in the context of error catching, the
standard mandates that we need to distinguish between

- integer literals
- (maybe char/enum integer constants)
- floating point literals
- integer constant expressions
- arithmetic constant expressions
- address constants

somehow...


Thanks,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 08:39:57 +0000
Message-ID: <87a8cqlhcy.fsf () gmail ! com>
--------------------
Hi Christopher,

Christopher Li <sparse@chrisli.org> writes:

> On Wed, Nov 23, 2016 at 12:05 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> But, quoting the beginning of 6.6/6:
>>     An integer constant expression shall have integer type and shall
>>     only have operands that are integer constants, enumeration constants,
>>     character constants, sizeof expressions whose results are integer
>>     constants, and **floating constants** that are the immediate operands
>>     of casts.
>>
>> and the part '(float) 0' is none of these.
>
> I see, thanks for pointing it out.
>
>>> +       [(int)(float)0.] = 0,   // KO
>>> +
>>> +       [(int)(void*)0] = 0,    // KO
>>> Also this one should be fine?
>>
>> same for '(void *) 0'.
>>
>
> Good to know
>
> Another question:
> Is there any real reason to distinguish between "const enum/char" and
> "const integer"?
> Can we roll "const enum/char" as one type of "const integer" as well?

(void*)'a' doesn't qualify as an address constant, (void *)0 does.

So while we certainly won't need to distinguish enum and char constants
(literals), we have to do so for integer constants (literals) vs
enum/char constants (literals).

Maybe it suffices to simply tag the latter as "integer constant
expression" though. I will have a look on whether the standard allows
character/enum constants at places where it forbids the use of integer
constant expressions.


> I think the patch can be simpler. The dance of CONSTEXPR_SET and MASK etc is
> really messy.
>
> The way I see it, there are three basic type of const elements.
> Int ( including enum/char), Float, Address.
>
> Either of which does not has any overlap with each other.
>
> Then each of the matching requirement is just a sets consist of the
> above element.

Sorry, I don't understand that last sentence. "Set" in the mathematical
sense? How would that look like?


> I am not sure there is need to distinguish integer const expression vs arthritic
> const expression. (Example please?) If it does, add one more bit as
> arthritic operations.

An example would be initialization with designators as shown in the
testcase you quoted above. C.f. 6.7.8(6): only integer constant
expressions are allowed there, but not arithmetic ones.


> I think the real messy part of the original patch is that,
> CONSTEXPR_FLAG_INT_CONST_EXPR
> and CONSTEXPR_FLAG_ARITH_CONST_EXPR are two separate bit need to be maintained.
> It does not need to be if we treat them as set of the elements.
>
> We only need to keep track of "Int_const_expr, Float_literal, Addr_const_expr"
> three bits. May be Arthritic_const_expr if we have need for that.
> This patch series really make a difference on adding the "Addr_const_expr".
>
> I am working on a patch on top of the patch series to test it out.

Prove me wrong, but AFAICS, in the context of error catching, the
standard mandates that we need to distinguish between

- integer literals
- (maybe char/enum integer constants)
- floating point literals
- integer constant expressions
- arithmetic constant expressions
- address constants

somehow...


Thanks,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 08:39:57 +0000
Message-ID: <87a8cqlhcy.fsf () gmail ! com>
--------------------
Hi Christopher,

Christopher Li <sparse@chrisli.org> writes:

> On Wed, Nov 23, 2016 at 12:05 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> But, quoting the beginning of 6.6/6:
>>     An integer constant expression shall have integer type and shall
>>     only have operands that are integer constants, enumeration constants,
>>     character constants, sizeof expressions whose results are integer
>>     constants, and **floating constants** that are the immediate operands
>>     of casts.
>>
>> and the part '(float) 0' is none of these.
>
> I see, thanks for pointing it out.
>
>>> +       [(int)(float)0.] = 0,   // KO
>>> +
>>> +       [(int)(void*)0] = 0,    // KO
>>> Also this one should be fine?
>>
>> same for '(void *) 0'.
>>
>
> Good to know
>
> Another question:
> Is there any real reason to distinguish between "const enum/char" and
> "const integer"?
> Can we roll "const enum/char" as one type of "const integer" as well?

(void*)'a' doesn't qualify as an address constant, (void *)0 does.

So while we certainly won't need to distinguish enum and char constants
(literals), we have to do so for integer constants (literals) vs
enum/char constants (literals).

Maybe it suffices to simply tag the latter as "integer constant
expression" though. I will have a look on whether the standard allows
character/enum constants at places where it forbids the use of integer
constant expressions.


> I think the patch can be simpler. The dance of CONSTEXPR_SET and MASK etc is
> really messy.
>
> The way I see it, there are three basic type of const elements.
> Int ( including enum/char), Float, Address.
>
> Either of which does not has any overlap with each other.
>
> Then each of the matching requirement is just a sets consist of the
> above element.

Sorry, I don't understand that last sentence. "Set" in the mathematical
sense? How would that look like?


> I am not sure there is need to distinguish integer const expression vs arthritic
> const expression. (Example please?) If it does, add one more bit as
> arthritic operations.

An example would be initialization with designators as shown in the
testcase you quoted above. C.f. 6.7.8(6): only integer constant
expressions are allowed there, but not arithmetic ones.


> I think the real messy part of the original patch is that,
> CONSTEXPR_FLAG_INT_CONST_EXPR
> and CONSTEXPR_FLAG_ARITH_CONST_EXPR are two separate bit need to be maintained.
> It does not need to be if we treat them as set of the elements.
>
> We only need to keep track of "Int_const_expr, Float_literal, Addr_const_expr"
> three bits. May be Arthritic_const_expr if we have need for that.
> This patch series really make a difference on adding the "Addr_const_expr".
>
> I am working on a patch on top of the patch series to test it out.

Prove me wrong, but AFAICS, in the context of error catching, the
standard mandates that we need to distinguish between

- integer literals
- (maybe char/enum integer constants)
- floating point literals
- integer constant expressions
- arithmetic constant expressions
- address constants

somehow...


Thanks,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 15:36:02 +0000
Message-ID: <CANeU7QkzefYMpkNgemsJ8WPUsj7fg8zUgKN8kth-0x7c85bK3w () mail ! gmail ! com>
--------------------
On Wed, Nov 23, 2016 at 4:39 PM, Nicolai Stange <nicstange@gmail.com> wrote:
> (void*)'a' doesn't qualify as an address constant, (void *)0 does.
>
> So while we certainly won't need to distinguish enum and char constants
> (literals), we have to do so for integer constants (literals) vs
> enum/char constants (literals).

Good. That is exactly the corner case condition I am looking for.
(void*)'a' is not an address constant, is it still consider constant expression?

How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
or not?

So I assume (void*) Enum_member is not address constant either,
right?

>> The way I see it, there are three basic type of const elements.
>> Int ( including enum/char), Float, Address.
>>
>> Either of which does not has any overlap with each other.
>>
>> Then each of the matching requirement is just a sets consist of the
>> above element.
>
> Sorry, I don't understand that last sentence. "Set" in the mathematical
> sense? How would that look like?

Yes, "Set" in the mathematical sense. Maybe it is easier to show the code.
I will try to explain here.

Basically, there are six bits as basic element. One bit per element.
Integer constant, enum constant, char constant, float constant,
address constant,
arithmetic constant.

The integer const expression can be test as a function, which use set
operation base on the previous six bits. e.g.
is_int_const_expr(flag) (flag & (Int | Enum | Char)) && !(flag &
(Float | Addr | Arith)))

In other words, the is_int_const_expr() can be deduce from the six element
bits. It does not need to maintain and propagate as a separate bit in
the expr->flags.
We can calculate that result when it is needed.

Maintain and propagate the six const bits become easier because it
does not need to
re-adjust the CONSTEXPR_FLAG_INT_CONST_EXPR  bit all the time. At least
that is what I am hoping for. We will see if this can work out or not.

>
>
>> I am not sure there is need to distinguish integer const expression vs arthritic
>> const expression. (Example please?) If it does, add one more bit as
>> arthritic operations.
>
> An example would be initialization with designators as shown in the
> testcase you quoted above. C.f. 6.7.8(6): only integer constant
> expressions are allowed there, but not arithmetic ones.

Good, another corner case condition. That meas the arithmetic bits is here
to stay. BTW, your test case is very good.

> Prove me wrong, but AFAICS, in the context of error catching, the
> standard mandates that we need to distinguish between

Yes, we can still distinguish them, no disagreement there. I just try
to make the internal representation cleaner. I will find out more soon.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 16:43:09 +0000
Message-ID: <87polm5eqq.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Wed, Nov 23, 2016 at 4:39 PM, Nicolai Stange <nicstange@gmail.com> wrote:
>> (void*)'a' doesn't qualify as an address constant, (void *)0 does.
>>
>> So while we certainly won't need to distinguish enum and char constants
>> (literals), we have to do so for integer constants (literals) vs
>> enum/char constants (literals).
>
> Good. That is exactly the corner case condition I am looking for.
> (void*)'a' is not an address constant, is it still consider constant expression?

I don't think that this would qualify as a constant expression of any
type.

> How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
> or not?

Strictly speaking, neither of them is.

Despite of this, we would (hopefully) mark the second case as an address
constant though.

Reason: this series flags address constants as such because they may be
used as a "constant expression in an initializer", i.e. as initializers
for static storage duration variables.

C.f. 6.6(7).

This paragraphs says that "an address constant for an object type plus
or minus an integer constant expression" is allowed as a constant
expression in an initializer.

Thus, after this series, sparse would tag (void*)0 + 'a' as being an
address constant although it's really an address constant plus/minus an
integer constant expression.


> So I assume (void*) Enum_member is not address constant either,
> right?

Right. The rule reads as "integer constant cast to pointer type", not
"integer constant *expression* cast to pointer type".

For the same reason, (void*)(0 + 'a') isn't an address constant either.


>
>>> The way I see it, there are three basic type of const elements.
>>> Int ( including enum/char), Float, Address.
>>>
>>> Either of which does not has any overlap with each other.
>>>
>>> Then each of the matching requirement is just a sets consist of the
>>> above element.
>>
>> Sorry, I don't understand that last sentence. "Set" in the mathematical
>> sense? How would that look like?
>
> Yes, "Set" in the mathematical sense. Maybe it is easier to show the code.
> I will try to explain here.
>
> Basically, there are six bits as basic element. One bit per element.
> Integer constant, enum constant, char constant, float constant,
> address constant,
> arithmetic constant.

+ integer constant *expression*

Take 0 + 0, for example: this is not an integer constant, but an integer
constant *expression* (and an arithmetic constant expression as well).


>
> The integer const expression can be test as a function, which use set
> operation base on the previous six bits. e.g.
> is_int_const_expr(flag) (flag & (Int | Enum | Char)) && !(flag &
> (Float | Addr | Arith)))
>
> In other words, the is_int_const_expr() can be deduce from the six element
> bits. It does not need to maintain and propagate as a separate bit in
> the expr->flags.
> We can calculate that result when it is needed.
>
> Maintain and propagate the six const bits become easier because it
> does not need to
> re-adjust the CONSTEXPR_FLAG_INT_CONST_EXPR  bit all the time. At least
> that is what I am hoping for. We will see if this can work out or not.
>
>>
>>
>>> I am not sure there is need to distinguish integer const expression vs arthritic
>>> const expression. (Example please?) If it does, add one more bit as
>>> arthritic operations.
>>
>> An example would be initialization with designators as shown in the
>> testcase you quoted above. C.f. 6.7.8(6): only integer constant
>> expressions are allowed there, but not arithmetic ones.
>
> Good, another corner case condition. That meas the arithmetic bits is here
> to stay. BTW, your test case is very good.

Thanks :)


Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 16:43:09 +0000
Message-ID: <87polm5eqq.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Wed, Nov 23, 2016 at 4:39 PM, Nicolai Stange <nicstange@gmail.com> wrote:
>> (void*)'a' doesn't qualify as an address constant, (void *)0 does.
>>
>> So while we certainly won't need to distinguish enum and char constants
>> (literals), we have to do so for integer constants (literals) vs
>> enum/char constants (literals).
>
> Good. That is exactly the corner case condition I am looking for.
> (void*)'a' is not an address constant, is it still consider constant expression?

I don't think that this would qualify as a constant expression of any
type.

> How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
> or not?

Strictly speaking, neither of them is.

Despite of this, we would (hopefully) mark the second case as an address
constant though.

Reason: this series flags address constants as such because they may be
used as a "constant expression in an initializer", i.e. as initializers
for static storage duration variables.

C.f. 6.6(7).

This paragraphs says that "an address constant for an object type plus
or minus an integer constant expression" is allowed as a constant
expression in an initializer.

Thus, after this series, sparse would tag (void*)0 + 'a' as being an
address constant although it's really an address constant plus/minus an
integer constant expression.


> So I assume (void*) Enum_member is not address constant either,
> right?

Right. The rule reads as "integer constant cast to pointer type", not
"integer constant *expression* cast to pointer type".

For the same reason, (void*)(0 + 'a') isn't an address constant either.


>
>>> The way I see it, there are three basic type of const elements.
>>> Int ( including enum/char), Float, Address.
>>>
>>> Either of which does not has any overlap with each other.
>>>
>>> Then each of the matching requirement is just a sets consist of the
>>> above element.
>>
>> Sorry, I don't understand that last sentence. "Set" in the mathematical
>> sense? How would that look like?
>
> Yes, "Set" in the mathematical sense. Maybe it is easier to show the code.
> I will try to explain here.
>
> Basically, there are six bits as basic element. One bit per element.
> Integer constant, enum constant, char constant, float constant,
> address constant,
> arithmetic constant.

+ integer constant *expression*

Take 0 + 0, for example: this is not an integer constant, but an integer
constant *expression* (and an arithmetic constant expression as well).


>
> The integer const expression can be test as a function, which use set
> operation base on the previous six bits. e.g.
> is_int_const_expr(flag) (flag & (Int | Enum | Char)) && !(flag &
> (Float | Addr | Arith)))
>
> In other words, the is_int_const_expr() can be deduce from the six element
> bits. It does not need to maintain and propagate as a separate bit in
> the expr->flags.
> We can calculate that result when it is needed.
>
> Maintain and propagate the six const bits become easier because it
> does not need to
> re-adjust the CONSTEXPR_FLAG_INT_CONST_EXPR  bit all the time. At least
> that is what I am hoping for. We will see if this can work out or not.
>
>>
>>
>>> I am not sure there is need to distinguish integer const expression vs arthritic
>>> const expression. (Example please?) If it does, add one more bit as
>>> arthritic operations.
>>
>> An example would be initialization with designators as shown in the
>> testcase you quoted above. C.f. 6.7.8(6): only integer constant
>> expressions are allowed there, but not arithmetic ones.
>
> Good, another corner case condition. That meas the arithmetic bits is here
> to stay. BTW, your test case is very good.

Thanks :)


Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 16:43:09 +0000
Message-ID: <87polm5eqq.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Wed, Nov 23, 2016 at 4:39 PM, Nicolai Stange <nicstange@gmail.com> wrote:
>> (void*)'a' doesn't qualify as an address constant, (void *)0 does.
>>
>> So while we certainly won't need to distinguish enum and char constants
>> (literals), we have to do so for integer constants (literals) vs
>> enum/char constants (literals).
>
> Good. That is exactly the corner case condition I am looking for.
> (void*)'a' is not an address constant, is it still consider constant expression?

I don't think that this would qualify as a constant expression of any
type.

> How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
> or not?

Strictly speaking, neither of them is.

Despite of this, we would (hopefully) mark the second case as an address
constant though.

Reason: this series flags address constants as such because they may be
used as a "constant expression in an initializer", i.e. as initializers
for static storage duration variables.

C.f. 6.6(7).

This paragraphs says that "an address constant for an object type plus
or minus an integer constant expression" is allowed as a constant
expression in an initializer.

Thus, after this series, sparse would tag (void*)0 + 'a' as being an
address constant although it's really an address constant plus/minus an
integer constant expression.


> So I assume (void*) Enum_member is not address constant either,
> right?

Right. The rule reads as "integer constant cast to pointer type", not
"integer constant *expression* cast to pointer type".

For the same reason, (void*)(0 + 'a') isn't an address constant either.


>
>>> The way I see it, there are three basic type of const elements.
>>> Int ( including enum/char), Float, Address.
>>>
>>> Either of which does not has any overlap with each other.
>>>
>>> Then each of the matching requirement is just a sets consist of the
>>> above element.
>>
>> Sorry, I don't understand that last sentence. "Set" in the mathematical
>> sense? How would that look like?
>
> Yes, "Set" in the mathematical sense. Maybe it is easier to show the code.
> I will try to explain here.
>
> Basically, there are six bits as basic element. One bit per element.
> Integer constant, enum constant, char constant, float constant,
> address constant,
> arithmetic constant.

+ integer constant *expression*

Take 0 + 0, for example: this is not an integer constant, but an integer
constant *expression* (and an arithmetic constant expression as well).


>
> The integer const expression can be test as a function, which use set
> operation base on the previous six bits. e.g.
> is_int_const_expr(flag) (flag & (Int | Enum | Char)) && !(flag &
> (Float | Addr | Arith)))
>
> In other words, the is_int_const_expr() can be deduce from the six element
> bits. It does not need to maintain and propagate as a separate bit in
> the expr->flags.
> We can calculate that result when it is needed.
>
> Maintain and propagate the six const bits become easier because it
> does not need to
> re-adjust the CONSTEXPR_FLAG_INT_CONST_EXPR  bit all the time. At least
> that is what I am hoping for. We will see if this can work out or not.
>
>>
>>
>>> I am not sure there is need to distinguish integer const expression vs arthritic
>>> const expression. (Example please?) If it does, add one more bit as
>>> arthritic operations.
>>
>> An example would be initialization with designators as shown in the
>> testcase you quoted above. C.f. 6.7.8(6): only integer constant
>> expressions are allowed there, but not arithmetic ones.
>
> Good, another corner case condition. That meas the arithmetic bits is here
> to stay. BTW, your test case is very good.

Thanks :)


Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 17:38:45 +0000
Message-ID: <CANeU7QmsdVoccP0pN9RKkKC+-0mPSbfB59wQ5ngC3qEi4EY1+g () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 12:43 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>
> I don't think that this would qualify as a constant expression of any
> type.
>
>> How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
>> or not?
>
> Strictly speaking, neither of them is.
>
> Despite of this, we would (hopefully) mark the second case as an address
> constant though.
>
> Reason: this series flags address constants as such because they may be
> used as a "constant expression in an initializer", i.e. as initializers
> for static storage duration variables.

That is good info. Thanks for the clarify.

BTW, gcc does not seem to complain about const integer issue on,
         [(int)(float)0] = 0,    // KO
         [(int)(void*)0] = 0,    // KO
gcc seems does what make snese rather than stick to the book.


In your patch:

static struct token *builtin_types_compatible_p_expr(struct token *token,
                                                     struct expression **tree)
 {
        struct expression *expr = alloc_expression(
                token->pos, EXPR_COMPARE);
-       expr->flags = Int_const_expr;
        expr->op = SPECIAL_EQUAL;
        token = token->next;
        if (!match_op(token, '('))

I think __builtin_xxx function expand similar to the processor
macro. In that sense, we might want to the consider this expression
as integer constant express as if the __builtin_xxx call is either 0 or 1.

Again, gcc does not complain about:
       [__builtin_types_compatible_p(typeof(1), int)] = 0,   // KO

This makes sense, but not according the "strict" rules.

>>
>> Basically, there are six bits as basic element. One bit per element.
>> Integer constant, enum constant, char constant, float constant,
>> address constant,
>> arithmetic constant.
>
> + integer constant *expression*
>
> Take 0 + 0, for example: this is not an integer constant, but an integer
> constant *expression* (and an arithmetic constant expression as well).

Ah, I see. I change my plan according this. The six basic element define as:
Integer constant, enum constant, char constant, float constant,
address constant, composite op.

The composite op bit get set after binary operation or uniop.
The flags can have more than one bit set for the expression.

Integer constant expression can be tested as:

!(flags & ( Addr | Float) ) && flag

Arithmetic constant expression can be tested as:

!(flags & Addr) ) && flag

Do you see any problem with this internal representation?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 17:38:45 +0000
Message-ID: <CANeU7QmsdVoccP0pN9RKkKC+-0mPSbfB59wQ5ngC3qEi4EY1+g () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 12:43 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>
> I don't think that this would qualify as a constant expression of any
> type.
>
>> How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
>> or not?
>
> Strictly speaking, neither of them is.
>
> Despite of this, we would (hopefully) mark the second case as an address
> constant though.
>
> Reason: this series flags address constants as such because they may be
> used as a "constant expression in an initializer", i.e. as initializers
> for static storage duration variables.

That is good info. Thanks for the clarify.

BTW, gcc does not seem to complain about const integer issue on,
         [(int)(float)0] = 0,    // KO
         [(int)(void*)0] = 0,    // KO
gcc seems does what make snese rather than stick to the book.


In your patch:

static struct token *builtin_types_compatible_p_expr(struct token *token,
                                                     struct expression **tree)
 {
        struct expression *expr = alloc_expression(
                token->pos, EXPR_COMPARE);
-       expr->flags = Int_const_expr;
        expr->op = SPECIAL_EQUAL;
        token = token->next;
        if (!match_op(token, '('))

I think __builtin_xxx function expand similar to the processor
macro. In that sense, we might want to the consider this expression
as integer constant express as if the __builtin_xxx call is either 0 or 1.

Again, gcc does not complain about:
       [__builtin_types_compatible_p(typeof(1), int)] = 0,   // KO

This makes sense, but not according the "strict" rules.

>>
>> Basically, there are six bits as basic element. One bit per element.
>> Integer constant, enum constant, char constant, float constant,
>> address constant,
>> arithmetic constant.
>
> + integer constant *expression*
>
> Take 0 + 0, for example: this is not an integer constant, but an integer
> constant *expression* (and an arithmetic constant expression as well).

Ah, I see. I change my plan according this. The six basic element define as:
Integer constant, enum constant, char constant, float constant,
address constant, composite op.

The composite op bit get set after binary operation or uniop.
The flags can have more than one bit set for the expression.

Integer constant expression can be tested as:

!(flags & ( Addr | Float) ) && flag

Arithmetic constant expression can be tested as:

!(flags & Addr) ) && flag

Do you see any problem with this internal representation?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 18:23:35 +0000
Message-ID: <CANeU7Q=aoP_ZBVHcZ8qYOBN9zt-y_k_CYY1nSjLd4OqQz7XDcw () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 1:38 AM, Christopher Li <sparse@chrisli.org> wrote:

> In your patch:
>
> static struct token *builtin_types_compatible_p_expr(struct token *token,
>                                                      struct expression **tree)
>  {
>         struct expression *expr = alloc_expression(
>                 token->pos, EXPR_COMPARE);
> -       expr->flags = Int_const_expr;
>         expr->op = SPECIAL_EQUAL;
>         token = token->next;
>         if (!match_op(token, '('))
>
> I think __builtin_xxx function expand similar to the processor
> macro. In that sense, we might want to the consider this expression
> as integer constant express as if the __builtin_xxx call is either 0 or 1.

Never mind, I think you move it to the evaluation phase.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 18:23:35 +0000
Message-ID: <CANeU7Q=aoP_ZBVHcZ8qYOBN9zt-y_k_CYY1nSjLd4OqQz7XDcw () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 1:38 AM, Christopher Li <sparse@chrisli.org> wrote:

> In your patch:
>
> static struct token *builtin_types_compatible_p_expr(struct token *token,
>                                                      struct expression **tree)
>  {
>         struct expression *expr = alloc_expression(
>                 token->pos, EXPR_COMPARE);
> -       expr->flags = Int_const_expr;
>         expr->op = SPECIAL_EQUAL;
>         token = token->next;
>         if (!match_op(token, '('))
>
> I think __builtin_xxx function expand similar to the processor
> macro. In that sense, we might want to the consider this expression
> as integer constant express as if the __builtin_xxx call is either 0 or 1.

Never mind, I think you move it to the evaluation phase.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 18:23:35 +0000
Message-ID: <CANeU7Q=aoP_ZBVHcZ8qYOBN9zt-y_k_CYY1nSjLd4OqQz7XDcw () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 1:38 AM, Christopher Li <sparse@chrisli.org> wrote:

> In your patch:
>
> static struct token *builtin_types_compatible_p_expr(struct token *token,
>                                                      struct expression **tree)
>  {
>         struct expression *expr = alloc_expression(
>                 token->pos, EXPR_COMPARE);
> -       expr->flags = Int_const_expr;
>         expr->op = SPECIAL_EQUAL;
>         token = token->next;
>         if (!match_op(token, '('))
>
> I think __builtin_xxx function expand similar to the processor
> macro. In that sense, we might want to the consider this expression
> as integer constant express as if the __builtin_xxx call is either 0 or 1.

Never mind, I think you move it to the evaluation phase.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 18:33:01 +0000
Message-ID: <87lgwa59nm.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Thu, Nov 24, 2016 at 12:43 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>>
>> I don't think that this would qualify as a constant expression of any
>> type.
>>
>>> How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
>>> or not?
>>
>> Strictly speaking, neither of them is.
>>
>> Despite of this, we would (hopefully) mark the second case as an address
>> constant though.
>>
>> Reason: this series flags address constants as such because they may be
>> used as a "constant expression in an initializer", i.e. as initializers
>> for static storage duration variables.
>
> That is good info. Thanks for the clarify.
>
> BTW, gcc does not seem to complain about const integer issue on,
>          [(int)(float)0] = 0,    // KO
>          [(int)(void*)0] = 0,    // KO
> gcc seems does what make snese rather than stick to the book.

To give you some background: when I started this, my initial intent was
to move the constness inspection from the expression building stage in
expression.c to their evaluation in evaluation.c. This would be needed
in order to decide whether the outcome of __builtin_choose_expr() is a
constant expression, for example.

While doing this, I recognized that sparse's current constant expression
tagging scheme was quite limited and I had to touch everything related
to it anyway. So I asked on this list on whether it would be a good
thing to let sparse be more strict than gcc in this regard and the
feedback was that it certainly would (at user option).


> In your patch:

Can you tell which one? If not, would resending this series help?

> static struct token *builtin_types_compatible_p_expr(struct token *token,
>                                                      struct expression **tree)
>  {
>         struct expression *expr = alloc_expression(
>                 token->pos, EXPR_COMPARE);
> -       expr->flags = Int_const_expr;
>         expr->op = SPECIAL_EQUAL;
>         token = token->next;
>         if (!match_op(token, '('))
>
> I think __builtin_xxx function expand similar to the processor
> macro. In that sense, we might want to the consider this expression
> as integer constant express as if the __builtin_xxx call is either 0 or 1.
>
> Again, gcc does not complain about:
>        [__builtin_types_compatible_p(typeof(1), int)] = 0,   // KO
>
> This makes sense, but not according the "strict" rules.

After [21/21] ("evaluation: treat comparsions between types as integer
constexpr"), sparse should treat __builtin_types_compatible_p() as an
integer constant expression, just as gcc does.

After all, the standard doesn't say anything about
__builtin_types_compatible_p()...

So, if the above testcase really fails after this series, it's either a
bug or an artifact of having this typeof() in there (or both), I
think.


>>>
>>> Basically, there are six bits as basic element. One bit per element.
>>> Integer constant, enum constant, char constant, float constant,
>>> address constant,
>>> arithmetic constant.
>>
>> + integer constant *expression*
>>
>> Take 0 + 0, for example: this is not an integer constant, but an integer
>> constant *expression* (and an arithmetic constant expression as well).
>
> Ah, I see. I change my plan according this. The six basic element define as:
> Integer constant, enum constant, char constant, float constant,
> address constant, composite op.
>
> The composite op bit get set after binary operation or uniop.
> The flags can have more than one bit set for the expression.
>
> Integer constant expression can be tested as:
>
> !(flags & ( Addr | Float) ) && flag
>
> Arithmetic constant expression can be tested as:
>
> !(flags & Addr) ) && flag
>
> Do you see any problem with this internal representation?

(int)0.0 is an integer constant expression.

In your scheme, it would have "composite op" and "float" set?
The integer constant expression test you proposed above would
fail in this case.


Thanks,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 23 Nov 2016 18:33:01 +0000
Message-ID: <87lgwa59nm.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Thu, Nov 24, 2016 at 12:43 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>>
>> I don't think that this would qualify as a constant expression of any
>> type.
>>
>>> How about (void*)(0 + 'a') and (void*)0 + 'a', are they address constant
>>> or not?
>>
>> Strictly speaking, neither of them is.
>>
>> Despite of this, we would (hopefully) mark the second case as an address
>> constant though.
>>
>> Reason: this series flags address constants as such because they may be
>> used as a "constant expression in an initializer", i.e. as initializers
>> for static storage duration variables.
>
> That is good info. Thanks for the clarify.
>
> BTW, gcc does not seem to complain about const integer issue on,
>          [(int)(float)0] = 0,    // KO
>          [(int)(void*)0] = 0,    // KO
> gcc seems does what make snese rather than stick to the book.

To give you some background: when I started this, my initial intent was
to move the constness inspection from the expression building stage in
expression.c to their evaluation in evaluation.c. This would be needed
in order to decide whether the outcome of __builtin_choose_expr() is a
constant expression, for example.

While doing this, I recognized that sparse's current constant expression
tagging scheme was quite limited and I had to touch everything related
to it anyway. So I asked on this list on whether it would be a good
thing to let sparse be more strict than gcc in this regard and the
feedback was that it certainly would (at user option).


> In your patch:

Can you tell which one? If not, would resending this series help?

> static struct token *builtin_types_compatible_p_expr(struct token *token,
>                                                      struct expression **tree)
>  {
>         struct expression *expr = alloc_expression(
>                 token->pos, EXPR_COMPARE);
> -       expr->flags = Int_const_expr;
>         expr->op = SPECIAL_EQUAL;
>         token = token->next;
>         if (!match_op(token, '('))
>
> I think __builtin_xxx function expand similar to the processor
> macro. In that sense, we might want to the consider this expression
> as integer constant express as if the __builtin_xxx call is either 0 or 1.
>
> Again, gcc does not complain about:
>        [__builtin_types_compatible_p(typeof(1), int)] = 0,   // KO
>
> This makes sense, but not according the "strict" rules.

After [21/21] ("evaluation: treat comparsions between types as integer
constexpr"), sparse should treat __builtin_types_compatible_p() as an
integer constant expression, just as gcc does.

After all, the standard doesn't say anything about
__builtin_types_compatible_p()...

So, if the above testcase really fails after this series, it's either a
bug or an artifact of having this typeof() in there (or both), I
think.


>>>
>>> Basically, there are six bits as basic element. One bit per element.
>>> Integer constant, enum constant, char constant, float constant,
>>> address constant,
>>> arithmetic constant.
>>
>> + integer constant *expression*
>>
>> Take 0 + 0, for example: this is not an integer constant, but an integer
>> constant *expression* (and an arithmetic constant expression as well).
>
> Ah, I see. I change my plan according this. The six basic element define as:
> Integer constant, enum constant, char constant, float constant,
> address constant, composite op.
>
> The composite op bit get set after binary operation or uniop.
> The flags can have more than one bit set for the expression.
>
> Integer constant expression can be tested as:
>
> !(flags & ( Addr | Float) ) && flag
>
> Arithmetic constant expression can be tested as:
>
> !(flags & Addr) ) && flag
>
> Do you see any problem with this internal representation?

(int)0.0 is an integer constant expression.

In your scheme, it would have "composite op" and "float" set?
The integer constant expression test you proposed above would
fail in this case.


Thanks,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 01:18:20 +0000
Message-ID: <CANeU7Qm21LCu2GgdTLbcDERBbgdYWoX_wp4DTKaFdi=G1ZcqAQ () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 2:33 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>
> While doing this, I recognized that sparse's current constant expression
> tagging scheme was quite limited and I had to touch everything related
> to it anyway. So I asked on this list on whether it would be a good
> thing to let sparse be more strict than gcc in this regard and the
> feedback was that it certainly would (at user option).

Good. Thanks for reminding of that. So ideally this is under a more
strict options.

>
> Can you tell which one? If not, would resending this series help?
>
Yes, I can. But never mind that point as I reply in previous email.
I figure you do the same work in the evaluation stage now.

No, please don't send the series again. I have a script system to
process the patches now. So no patch will be missed from now on.


> So, if the above testcase really fails after this series, it's either a
> bug or an artifact of having this typeof() in there (or both), I
> think.

Never mind that.

>> Integer constant expression can be tested as:
>>
>> !(flags & ( Addr | Float) ) && flag
>>
>> Arithmetic constant expression can be tested as:
>>
>> !(flags & Addr) ) && flag
>>
>> Do you see any problem with this internal representation?
>
> (int)0.0 is an integer constant expression.
>
> In your scheme, it would have "composite op" and "float" set?
> The integer constant expression test you proposed above would
> fail in this case.
>

(int) 0.0 will express as "Composite op" and "Int const" set.
Cast is a special operation it will strip the "float" and convert it
to "int". After all that is what cast does.

It will not change your patch behavior and warning etc, it is just
a internal representation difference. How the constant expression
bits are store and interpreted.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 01:18:20 +0000
Message-ID: <CANeU7Qm21LCu2GgdTLbcDERBbgdYWoX_wp4DTKaFdi=G1ZcqAQ () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 2:33 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>
> While doing this, I recognized that sparse's current constant expression
> tagging scheme was quite limited and I had to touch everything related
> to it anyway. So I asked on this list on whether it would be a good
> thing to let sparse be more strict than gcc in this regard and the
> feedback was that it certainly would (at user option).

Good. Thanks for reminding of that. So ideally this is under a more
strict options.

>
> Can you tell which one? If not, would resending this series help?
>
Yes, I can. But never mind that point as I reply in previous email.
I figure you do the same work in the evaluation stage now.

No, please don't send the series again. I have a script system to
process the patches now. So no patch will be missed from now on.


> So, if the above testcase really fails after this series, it's either a
> bug or an artifact of having this typeof() in there (or both), I
> think.

Never mind that.

>> Integer constant expression can be tested as:
>>
>> !(flags & ( Addr | Float) ) && flag
>>
>> Arithmetic constant expression can be tested as:
>>
>> !(flags & Addr) ) && flag
>>
>> Do you see any problem with this internal representation?
>
> (int)0.0 is an integer constant expression.
>
> In your scheme, it would have "composite op" and "float" set?
> The integer constant expression test you proposed above would
> fail in this case.
>

(int) 0.0 will express as "Composite op" and "Int const" set.
Cast is a special operation it will strip the "float" and convert it
to "int". After all that is what cast does.

It will not change your patch behavior and warning etc, it is just
a internal representation difference. How the constant expression
bits are store and interpreted.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 09:45:08 +0000
Message-ID: <87h96x5hzv.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Thu, Nov 24, 2016 at 2:33 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>>
>> While doing this, I recognized that sparse's current constant expression
>> tagging scheme was quite limited and I had to touch everything related
>> to it anyway. So I asked on this list on whether it would be a good
>> thing to let sparse be more strict than gcc in this regard and the
>> feedback was that it certainly would (at user option).
>
> Good. Thanks for reminding of that. So ideally this is under a more
> strict options.

As it stands, [09/21] ("evaluate: check static storage duration objects'
intializers' constness"), introduces the opt-in -Wconstexpr-not-const.
This affects only initializers for objects of static storage duration.

So, there is currently no way to opt out from the stricter integer
constant expression checks etc. introduced with this series.

I ran sparse with this series applied on the kernel back then and if I
remember correctly, there was no spectacular difference though.

If these stricter semantics nevertheless became a problem, this would be
easily "fixable" by further relaxing them at user option, I think.


> No, please don't send the series again. I have a script system to
> process the patches now. So no patch will be missed from now on.

Alright. May I further ask whether you've got all these precious
Reviewed-by tags from Luc carried over? He did a great amount of review
work on this series and it would be quite sad if these got lost.
I still have them, so just tell me if you need a list. If not:
nevermind.


>>> Integer constant expression can be tested as:
>>>
>>> !(flags & ( Addr | Float) ) && flag
>>>
>>> Arithmetic constant expression can be tested as:
>>>
>>> !(flags & Addr) ) && flag
>>>
>>> Do you see any problem with this internal representation?
>>
>> (int)0.0 is an integer constant expression.
>>
>> In your scheme, it would have "composite op" and "float" set?
>> The integer constant expression test you proposed above would
>> fail in this case.
>>
>
> (int) 0.0 will express as "Composite op" and "Int const" set.
> Cast is a special operation it will strip the "float" and convert it
> to "int". After all that is what cast does.

Ah ok, i mistook you in the semantics of the composite op flag.


> It will not change your patch behavior and warning etc, it is just
> a internal representation difference. How the constant expression
> bits are store and interpreted.

Yes, yes got that. Don't get me wrong, I'm not defending my particular
choice of flags. If yours leads to cleaner/less code, I will be very
happy.

That being said, here's the next "corner case":

  0 + 'a'

Which flags would be set for this binary expression? All of "composite
op", "integer const", "char const"?

That would work with your test for integer constant expressions.

I think, it wouldn't be enough to just set "composite op" flag w/o
anything else since the above integer constant expression needs to get
distinguished from

  0 + 0.0

which is an arithmetic constant expression only. Thus, considering your
tests for integer vs. arithmetic constant expressions, this would need
to have at least its "float constant" flag set?


Thank you,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 09:45:08 +0000
Message-ID: <87h96x5hzv.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Thu, Nov 24, 2016 at 2:33 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>>
>> While doing this, I recognized that sparse's current constant expression
>> tagging scheme was quite limited and I had to touch everything related
>> to it anyway. So I asked on this list on whether it would be a good
>> thing to let sparse be more strict than gcc in this regard and the
>> feedback was that it certainly would (at user option).
>
> Good. Thanks for reminding of that. So ideally this is under a more
> strict options.

As it stands, [09/21] ("evaluate: check static storage duration objects'
intializers' constness"), introduces the opt-in -Wconstexpr-not-const.
This affects only initializers for objects of static storage duration.

So, there is currently no way to opt out from the stricter integer
constant expression checks etc. introduced with this series.

I ran sparse with this series applied on the kernel back then and if I
remember correctly, there was no spectacular difference though.

If these stricter semantics nevertheless became a problem, this would be
easily "fixable" by further relaxing them at user option, I think.


> No, please don't send the series again. I have a script system to
> process the patches now. So no patch will be missed from now on.

Alright. May I further ask whether you've got all these precious
Reviewed-by tags from Luc carried over? He did a great amount of review
work on this series and it would be quite sad if these got lost.
I still have them, so just tell me if you need a list. If not:
nevermind.


>>> Integer constant expression can be tested as:
>>>
>>> !(flags & ( Addr | Float) ) && flag
>>>
>>> Arithmetic constant expression can be tested as:
>>>
>>> !(flags & Addr) ) && flag
>>>
>>> Do you see any problem with this internal representation?
>>
>> (int)0.0 is an integer constant expression.
>>
>> In your scheme, it would have "composite op" and "float" set?
>> The integer constant expression test you proposed above would
>> fail in this case.
>>
>
> (int) 0.0 will express as "Composite op" and "Int const" set.
> Cast is a special operation it will strip the "float" and convert it
> to "int". After all that is what cast does.

Ah ok, i mistook you in the semantics of the composite op flag.


> It will not change your patch behavior and warning etc, it is just
> a internal representation difference. How the constant expression
> bits are store and interpreted.

Yes, yes got that. Don't get me wrong, I'm not defending my particular
choice of flags. If yours leads to cleaner/less code, I will be very
happy.

That being said, here's the next "corner case":

  0 + 'a'

Which flags would be set for this binary expression? All of "composite
op", "integer const", "char const"?

That would work with your test for integer constant expressions.

I think, it wouldn't be enough to just set "composite op" flag w/o
anything else since the above integer constant expression needs to get
distinguished from

  0 + 0.0

which is an arithmetic constant expression only. Thus, considering your
tests for integer vs. arithmetic constant expressions, this would need
to have at least its "float constant" flag set?


Thank you,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 11:24:51 +0000
Message-ID: <CANeU7Q=xDWBYSWsb8NXfWYy=LDLufp4QZ+qjdn3DHBpcVZh4oQ () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 5:45 PM, Nicolai Stange <nicstange@gmail.com> wrote:
> As it stands, [09/21] ("evaluate: check static storage duration objects'
> intializers' constness"), introduces the opt-in -Wconstexpr-not-const.
> This affects only initializers for objects of static storage duration.
>
> So, there is currently no way to opt out from the stricter integer
> constant expression checks etc. introduced with this series.
>
> I ran sparse with this series applied on the kernel back then and if I
> remember correctly, there was no spectacular difference though.
>
> If these stricter semantics nevertheless became a problem, this would be
> easily "fixable" by further relaxing them at user option, I think.

That is fine for now. We can always add the option later.

> Alright. May I further ask whether you've got all these precious
> Reviewed-by tags from Luc carried over? He did a great amount of review
> work on this series and it would be quite sad if these got lost.
> I still have them, so just tell me if you need a list. If not:
> nevermind.

Luc's review tag should be apply when it is accepted.The script does
not add review tags by itself.  I usually add it by hand.

If yo want to add the tags in the patch, you are welcome resend the patch
with the new review tags. I just said don't need to send they if they are
exactly the same.

In this case, it is likely to have new around of patches series. We can
hold it off a bit.
>
> Yes, yes got that. Don't get me wrong, I'm not defending my particular
> choice of flags. If yours leads to cleaner/less code, I will be very
> happy.
>
> That being said, here's the next "corner case":
>
>   0 + 'a'
>
> Which flags would be set for this binary expression? All of "composite
> op", "integer const", "char const"?
>
> That would work with your test for integer constant expressions.
Yes. That is right.

For binary op, most of the case it just need to do:
new flags = left flags | right flags;

Then check if the combined result has invalid result.

> I think, it wouldn't be enough to just set "composite op" flag w/o
> anything else since the above integer constant expression needs to get
> distinguished from
>
>   0 + 0.0
>
> which is an arithmetic constant expression only. Thus, considering your
> tests for integer vs. arithmetic constant expressions, this would need
> to have at least its "float constant" flag set?

Yes, it would need to have "float constant" set on the final flag.

First of all, I think sparse will do implicit cast operation which will
add the "float constant" flag. It is the case for non-constant operations.
I need to dig deeper for constant case.

Even if there is no implicit cast operations, on the left hand you have "Int",
on the right hand you have "Float". So the combination will have "Int", "Float",
"composite op".

Base on my previous define for the arithmetic constant expressions:

>>> Integer constant expression can be tested as:
>>>
>>> !(flags & ( Addr | Float) ) && flag

The result has "Float" so it is not a integer constant expression.

>>>
>>> Arithmetic constant expression can be tested as:
>>>
>>> !(flags & Addr) ) && flag
>>>

The result does not have "Addr" so it is an arithmetic constant
expression. Your example does not break my representation.

We can still adjust the final result as needed. For most of the case
it does not need to adjust.

Other creative corner case are very welcome.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 11:24:51 +0000
Message-ID: <CANeU7Q=xDWBYSWsb8NXfWYy=LDLufp4QZ+qjdn3DHBpcVZh4oQ () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 5:45 PM, Nicolai Stange <nicstange@gmail.com> wrote:
> As it stands, [09/21] ("evaluate: check static storage duration objects'
> intializers' constness"), introduces the opt-in -Wconstexpr-not-const.
> This affects only initializers for objects of static storage duration.
>
> So, there is currently no way to opt out from the stricter integer
> constant expression checks etc. introduced with this series.
>
> I ran sparse with this series applied on the kernel back then and if I
> remember correctly, there was no spectacular difference though.
>
> If these stricter semantics nevertheless became a problem, this would be
> easily "fixable" by further relaxing them at user option, I think.

That is fine for now. We can always add the option later.

> Alright. May I further ask whether you've got all these precious
> Reviewed-by tags from Luc carried over? He did a great amount of review
> work on this series and it would be quite sad if these got lost.
> I still have them, so just tell me if you need a list. If not:
> nevermind.

Luc's review tag should be apply when it is accepted.The script does
not add review tags by itself.  I usually add it by hand.

If yo want to add the tags in the patch, you are welcome resend the patch
with the new review tags. I just said don't need to send they if they are
exactly the same.

In this case, it is likely to have new around of patches series. We can
hold it off a bit.
>
> Yes, yes got that. Don't get me wrong, I'm not defending my particular
> choice of flags. If yours leads to cleaner/less code, I will be very
> happy.
>
> That being said, here's the next "corner case":
>
>   0 + 'a'
>
> Which flags would be set for this binary expression? All of "composite
> op", "integer const", "char const"?
>
> That would work with your test for integer constant expressions.
Yes. That is right.

For binary op, most of the case it just need to do:
new flags = left flags | right flags;

Then check if the combined result has invalid result.

> I think, it wouldn't be enough to just set "composite op" flag w/o
> anything else since the above integer constant expression needs to get
> distinguished from
>
>   0 + 0.0
>
> which is an arithmetic constant expression only. Thus, considering your
> tests for integer vs. arithmetic constant expressions, this would need
> to have at least its "float constant" flag set?

Yes, it would need to have "float constant" set on the final flag.

First of all, I think sparse will do implicit cast operation which will
add the "float constant" flag. It is the case for non-constant operations.
I need to dig deeper for constant case.

Even if there is no implicit cast operations, on the left hand you have "Int",
on the right hand you have "Float". So the combination will have "Int", "Float",
"composite op".

Base on my previous define for the arithmetic constant expressions:

>>> Integer constant expression can be tested as:
>>>
>>> !(flags & ( Addr | Float) ) && flag

The result has "Float" so it is not a integer constant expression.

>>>
>>> Arithmetic constant expression can be tested as:
>>>
>>> !(flags & Addr) ) && flag
>>>

The result does not have "Addr" so it is an arithmetic constant
expression. Your example does not break my representation.

We can still adjust the final result as needed. For most of the case
it does not need to adjust.

Other creative corner case are very welcome.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 11:24:51 +0000
Message-ID: <CANeU7Q=xDWBYSWsb8NXfWYy=LDLufp4QZ+qjdn3DHBpcVZh4oQ () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 5:45 PM, Nicolai Stange <nicstange@gmail.com> wrote:
> As it stands, [09/21] ("evaluate: check static storage duration objects'
> intializers' constness"), introduces the opt-in -Wconstexpr-not-const.
> This affects only initializers for objects of static storage duration.
>
> So, there is currently no way to opt out from the stricter integer
> constant expression checks etc. introduced with this series.
>
> I ran sparse with this series applied on the kernel back then and if I
> remember correctly, there was no spectacular difference though.
>
> If these stricter semantics nevertheless became a problem, this would be
> easily "fixable" by further relaxing them at user option, I think.

That is fine for now. We can always add the option later.

> Alright. May I further ask whether you've got all these precious
> Reviewed-by tags from Luc carried over? He did a great amount of review
> work on this series and it would be quite sad if these got lost.
> I still have them, so just tell me if you need a list. If not:
> nevermind.

Luc's review tag should be apply when it is accepted.The script does
not add review tags by itself.  I usually add it by hand.

If yo want to add the tags in the patch, you are welcome resend the patch
with the new review tags. I just said don't need to send they if they are
exactly the same.

In this case, it is likely to have new around of patches series. We can
hold it off a bit.
>
> Yes, yes got that. Don't get me wrong, I'm not defending my particular
> choice of flags. If yours leads to cleaner/less code, I will be very
> happy.
>
> That being said, here's the next "corner case":
>
>   0 + 'a'
>
> Which flags would be set for this binary expression? All of "composite
> op", "integer const", "char const"?
>
> That would work with your test for integer constant expressions.
Yes. That is right.

For binary op, most of the case it just need to do:
new flags = left flags | right flags;

Then check if the combined result has invalid result.

> I think, it wouldn't be enough to just set "composite op" flag w/o
> anything else since the above integer constant expression needs to get
> distinguished from
>
>   0 + 0.0
>
> which is an arithmetic constant expression only. Thus, considering your
> tests for integer vs. arithmetic constant expressions, this would need
> to have at least its "float constant" flag set?

Yes, it would need to have "float constant" set on the final flag.

First of all, I think sparse will do implicit cast operation which will
add the "float constant" flag. It is the case for non-constant operations.
I need to dig deeper for constant case.

Even if there is no implicit cast operations, on the left hand you have "Int",
on the right hand you have "Float". So the combination will have "Int", "Float",
"composite op".

Base on my previous define for the arithmetic constant expressions:

>>> Integer constant expression can be tested as:
>>>
>>> !(flags & ( Addr | Float) ) && flag

The result has "Float" so it is not a integer constant expression.

>>>
>>> Arithmetic constant expression can be tested as:
>>>
>>> !(flags & Addr) ) && flag
>>>

The result does not have "Addr" so it is an arithmetic constant
expression. Your example does not break my representation.

We can still adjust the final result as needed. For most of the case
it does not need to adjust.

Other creative corner case are very welcome.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 17:22:15 +0000
Message-ID: <20161124172213.GA14515 () macpro ! local>
--------------------
On Thu, Nov 24, 2016 at 07:24:51PM +0800, Christopher Li wrote:
> On Thu, Nov 24, 2016 at 5:45 PM, Nicolai Stange <nicstange@gmail.com> wrote:
> > Alright. May I further ask whether you've got all these precious
> > Reviewed-by tags from Luc carried over? He did a great amount of review
> > work on this series and it would be quite sad if these got lost.
> > I still have them, so just tell me if you need a list. If not:
> > nevermind.
> 
> Luc's review tag should be apply when it is accepted.The script does
> not add review tags by itself.  I usually add it by hand.
> 
> If yo want to add the tags in the patch, you are welcome resend the patch
> with the new review tags. I just said don't need to send they if they are
> exactly the same.

I appreciate your concerns but, please, don't bother much with this.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Thu, 24 Nov 2016 17:22:15 +0000
Message-ID: <20161124172213.GA14515 () macpro ! local>
--------------------
On Thu, Nov 24, 2016 at 07:24:51PM +0800, Christopher Li wrote:
> On Thu, Nov 24, 2016 at 5:45 PM, Nicolai Stange <nicstange@gmail.com> wrote:
> > Alright. May I further ask whether you've got all these precious
> > Reviewed-by tags from Luc carried over? He did a great amount of review
> > work on this series and it would be quite sad if these got lost.
> > I still have them, so just tell me if you need a list. If not:
> > nevermind.
> 
> Luc's review tag should be apply when it is accepted.The script does
> not add review tags by itself.  I usually add it by hand.
> 
> If yo want to add the tags in the patch, you are welcome resend the patch
> with the new review tags. I just said don't need to send they if they are
> exactly the same.

I appreciate your concerns but, please, don't bother much with this.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 06 Dec 2016 06:00:50 +0000
Message-ID: <CANeU7Qn4ATFNP=tsUXPtxk2CuTGcp-PyLGT6UW8zxYfxiODaBg () mail ! gmail ! com>
--------------------
Hi Nicolai,

I finally finish up my more serious review of your patch series.
So this email is going to be long. Sorry for the long delay.

Over all pretty good.

One thing has been puzzling me when I first read the patches,
is about how the bits are used. Why there are some many bits
need to be set when the expression is a very simple integer constant.
Now I understand, the series basically treat each condition
(is it a int constant, is it a constant expression) as a bit. So when
you modify the int constant, the bits for other personality
(int expression, arithmetic expression) has to be set as well.
All this is for the optimization when you merge the binary operation
when left and right expression.

I still see the multiple personality for constant expression (it can be
both int constant and int expression etc) is a bit more complicate
than it needs to, at least I now understand why you did it that way.

The detail review follows:

1)  name of constexpr_flags is too long.

 struct expression {
        enum expression_type type:8;
-       unsigned flags:8;
+       unsigned constexpr_flags:8;

I actually thing that the more generic name "flags" are fine
without changing. If we need to add other flags not related to
constant, we will need to rename it all over again.

If you still feel strongly about the flags being too generic.
I suggest some thing shorter like "constant". The member
is in an expression struct, so the "expr" is not needed.

2) CONSTEXPR_FLAG_XXX are being too long.
+       CONSTEXPR_FLAG_INT_CONST = (1 << 0),
+       CONSTEXPR_FLAG_FP_CONST = (1 << 1),
+       CONSTEXPR_FLAG_ENUM_CONST = (1 << 2),
+       CONSTEXPR_FLAG_CHAR_CONST = (1 << 3),
+
+       /*
+        * A constant expression in the sense of [6.6]:
+        * - integer constant expression [6.6(6)]
+        * - arithmetic constant expression [6.6(8)]
+        * - address constant [6.6(9)]
+        */
+       CONSTEXPR_FLAG_INT_CONST_EXPR = (1 << 4),
+       CONSTEXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
+       CONSTEXPR_FLAG_ADDR_CONST = (1 << 6),

This is really nick pick. Look at this defines,  they all contain
"CONSTEXPR_FLAG" and "_CONST", The only different is
a very short word "INT", "FP", "CHAR" etc. The signal ratio
is pretty low.

I found it harder to read compare to the original enum value:

-enum {
-       Int_const_expr = 1,
-       Float_literal = 2,
-}; /* for expr->flags */


3) I think this is a typo, in the 01/21 patch
+/*
+ * Remove any "Constant" [6.4.4] flag, but retain the "constant
+ * expression" [6.6] flags.
+ */
+#define CONSTEXPR_FLAG_DECAY_CONSTS_MASK                               \
+       (CONSTEXPR_FLAG_INT_CONST | CONSTEXPR_FLAG_INT_CONST |          \
+               CONSTEXPR_FLAG_FP_CONST | CONSTEXPR_FLAG_CHAR_CONST)

Did any one spot there are *two* duplicate CONSTEXPR_FLAG_INT_CONST there?

This is the point I try to make in 2), the very verbose long name actually hurt
the readability. The eye need to move between long capital words try to extract
the key difference. The key difference here is "INT" vs "FP" vs "CHAR".

I think if it was written as:

              (Int_literal | Int_literal |
                   Float_literal | Char_literal)

 The bug maybe would be easier to spot?


4) in patch 12:
 static struct symbol *evaluate_ptr_add(struct expression *expr,
struct symbol *itype)
 {
        struct expression *index = expr->right;
        struct symbol *ctype, *base;
        int multiply;

        classify_type(degenerate(expr->left), &ctype);
        base = examine_pointer_target(ctype);

+       /*
+        * An address constant +/- an integer constant expression
+        * yields an address constant again [6.6(7)].
+        */
+       if ((expr->left->constexpr_flags & CONSTEXPR_FLAG_ADDR_CONST) &&
+               (expr->right->constexpr_flags & CONSTEXPR_FLAG_INT_CONST_EXPR))
+               expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
+
The constant flags should be set regardless. Otherwise it is not consistent
with the rest of the code.

Also I found that code hard to read. Because the expression is really long, it
break into a few lines.

I suggest move this code into a function:
           expr->const = evaluate_const_ptr_add(expr->right, expr->left);

Then inside  evaluate_const_ptr_add() you can use early return to make
the code does not need to use that long expression.

int evaluate_const_ptr_add(struct expression *left, struct expression *right)
{
          if (!(left->constant & Addr_const))
                   return 0;
          if (!(right->constant & Int_const_expr))
                   return 0;
          return Addr_const;
}

The same pattern can apply to a lot of the constant expression evaluation.
A lot of them share the same function e.g. convert into constant int expression.


5) in Patch 1,4,8, a few patch combine into this result.
 static struct symbol *evaluate_logical(struct expression *expr)
 {
        if (!evaluate_conditional(expr->left, 0))
                return NULL;
        if (!evaluate_conditional(expr->right, 0))
                return NULL;

        /* the result is int [6.5.13(3), 6.5.14(3)] */
        expr->ctype = &int_ctype;
-       if (expr->flags) {
-               if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-                       expr->flags = 0;
-       }
+       expr->constexpr_flags = expr->left->constexpr_flags &
+               expr->right->constexpr_flags &
+               ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK &
+               ~CONSTEXPR_FLAG_ADDR_CONST;
        return &int_ctype;
 }

Again, with this complaxity and lone line, I suggest move into a function
evaluate_const_int_expr(expr->left, expr->right)

Also this evaluate_const_int_expr() will be share by many similar caller.
e.g. evaluate_compare etc.

6) In evaluate_conditional_expression cover by patch 3,8,11,18
+       /*
+        * A conditional operator yields a particular constant
+        * expression type only if all of its three subexpressions are
+        * of that type [6.6(6), 6.6(8)].
+        * As an extension, relax this restriction by allowing any
+        * constant expression type for the condition expression.
+        *
+        * A conditional operator never yields an address constant
+        * [6.6(9)].
+        * However, as an extension, if the condition is any constant
+        * expression, and the true and false expressions are both
+        * address constants, mark the result as an address constant.
+        */
+       if (expr->conditional->constexpr_flags &
+               (CONSTEXPR_FLAG_ARITH_CONST_EXPR | CONSTEXPR_FLAG_ADDR_CONST))
+               expr->constexpr_flags = (*true)->constexpr_flags &
+                       expr->cond_false->constexpr_flags &
+                       ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK;

This is another place hard to read. I also suggest always set the
expr->constant flag. Also us3 a small function to wrap the complicate condition.
The long expression really hurts here.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 06 Dec 2016 06:00:50 +0000
Message-ID: <CANeU7Qn4ATFNP=tsUXPtxk2CuTGcp-PyLGT6UW8zxYfxiODaBg () mail ! gmail ! com>
--------------------
Hi Nicolai,

I finally finish up my more serious review of your patch series.
So this email is going to be long. Sorry for the long delay.

Over all pretty good.

One thing has been puzzling me when I first read the patches,
is about how the bits are used. Why there are some many bits
need to be set when the expression is a very simple integer constant.
Now I understand, the series basically treat each condition
(is it a int constant, is it a constant expression) as a bit. So when
you modify the int constant, the bits for other personality
(int expression, arithmetic expression) has to be set as well.
All this is for the optimization when you merge the binary operation
when left and right expression.

I still see the multiple personality for constant expression (it can be
both int constant and int expression etc) is a bit more complicate
than it needs to, at least I now understand why you did it that way.

The detail review follows:

1)  name of constexpr_flags is too long.

 struct expression {
        enum expression_type type:8;
-       unsigned flags:8;
+       unsigned constexpr_flags:8;

I actually thing that the more generic name "flags" are fine
without changing. If we need to add other flags not related to
constant, we will need to rename it all over again.

If you still feel strongly about the flags being too generic.
I suggest some thing shorter like "constant". The member
is in an expression struct, so the "expr" is not needed.

2) CONSTEXPR_FLAG_XXX are being too long.
+       CONSTEXPR_FLAG_INT_CONST = (1 << 0),
+       CONSTEXPR_FLAG_FP_CONST = (1 << 1),
+       CONSTEXPR_FLAG_ENUM_CONST = (1 << 2),
+       CONSTEXPR_FLAG_CHAR_CONST = (1 << 3),
+
+       /*
+        * A constant expression in the sense of [6.6]:
+        * - integer constant expression [6.6(6)]
+        * - arithmetic constant expression [6.6(8)]
+        * - address constant [6.6(9)]
+        */
+       CONSTEXPR_FLAG_INT_CONST_EXPR = (1 << 4),
+       CONSTEXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
+       CONSTEXPR_FLAG_ADDR_CONST = (1 << 6),

This is really nick pick. Look at this defines,  they all contain
"CONSTEXPR_FLAG" and "_CONST", The only different is
a very short word "INT", "FP", "CHAR" etc. The signal ratio
is pretty low.

I found it harder to read compare to the original enum value:

-enum {
-       Int_const_expr = 1,
-       Float_literal = 2,
-}; /* for expr->flags */


3) I think this is a typo, in the 01/21 patch
+/*
+ * Remove any "Constant" [6.4.4] flag, but retain the "constant
+ * expression" [6.6] flags.
+ */
+#define CONSTEXPR_FLAG_DECAY_CONSTS_MASK                               \
+       (CONSTEXPR_FLAG_INT_CONST | CONSTEXPR_FLAG_INT_CONST |          \
+               CONSTEXPR_FLAG_FP_CONST | CONSTEXPR_FLAG_CHAR_CONST)

Did any one spot there are *two* duplicate CONSTEXPR_FLAG_INT_CONST there?

This is the point I try to make in 2), the very verbose long name actually hurt
the readability. The eye need to move between long capital words try to extract
the key difference. The key difference here is "INT" vs "FP" vs "CHAR".

I think if it was written as:

              (Int_literal | Int_literal |
                   Float_literal | Char_literal)

 The bug maybe would be easier to spot?


4) in patch 12:
 static struct symbol *evaluate_ptr_add(struct expression *expr,
struct symbol *itype)
 {
        struct expression *index = expr->right;
        struct symbol *ctype, *base;
        int multiply;

        classify_type(degenerate(expr->left), &ctype);
        base = examine_pointer_target(ctype);

+       /*
+        * An address constant +/- an integer constant expression
+        * yields an address constant again [6.6(7)].
+        */
+       if ((expr->left->constexpr_flags & CONSTEXPR_FLAG_ADDR_CONST) &&
+               (expr->right->constexpr_flags & CONSTEXPR_FLAG_INT_CONST_EXPR))
+               expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
+
The constant flags should be set regardless. Otherwise it is not consistent
with the rest of the code.

Also I found that code hard to read. Because the expression is really long, it
break into a few lines.

I suggest move this code into a function:
           expr->const = evaluate_const_ptr_add(expr->right, expr->left);

Then inside  evaluate_const_ptr_add() you can use early return to make
the code does not need to use that long expression.

int evaluate_const_ptr_add(struct expression *left, struct expression *right)
{
          if (!(left->constant & Addr_const))
                   return 0;
          if (!(right->constant & Int_const_expr))
                   return 0;
          return Addr_const;
}

The same pattern can apply to a lot of the constant expression evaluation.
A lot of them share the same function e.g. convert into constant int expression.


5) in Patch 1,4,8, a few patch combine into this result.
 static struct symbol *evaluate_logical(struct expression *expr)
 {
        if (!evaluate_conditional(expr->left, 0))
                return NULL;
        if (!evaluate_conditional(expr->right, 0))
                return NULL;

        /* the result is int [6.5.13(3), 6.5.14(3)] */
        expr->ctype = &int_ctype;
-       if (expr->flags) {
-               if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-                       expr->flags = 0;
-       }
+       expr->constexpr_flags = expr->left->constexpr_flags &
+               expr->right->constexpr_flags &
+               ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK &
+               ~CONSTEXPR_FLAG_ADDR_CONST;
        return &int_ctype;
 }

Again, with this complaxity and lone line, I suggest move into a function
evaluate_const_int_expr(expr->left, expr->right)

Also this evaluate_const_int_expr() will be share by many similar caller.
e.g. evaluate_compare etc.

6) In evaluate_conditional_expression cover by patch 3,8,11,18
+       /*
+        * A conditional operator yields a particular constant
+        * expression type only if all of its three subexpressions are
+        * of that type [6.6(6), 6.6(8)].
+        * As an extension, relax this restriction by allowing any
+        * constant expression type for the condition expression.
+        *
+        * A conditional operator never yields an address constant
+        * [6.6(9)].
+        * However, as an extension, if the condition is any constant
+        * expression, and the true and false expressions are both
+        * address constants, mark the result as an address constant.
+        */
+       if (expr->conditional->constexpr_flags &
+               (CONSTEXPR_FLAG_ARITH_CONST_EXPR | CONSTEXPR_FLAG_ADDR_CONST))
+               expr->constexpr_flags = (*true)->constexpr_flags &
+                       expr->cond_false->constexpr_flags &
+                       ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK;

This is another place hard to read. I also suggest always set the
expr->constant flag. Also us3 a small function to wrap the complicate condition.
The long expression really hurts here.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 06 Dec 2016 06:00:50 +0000
Message-ID: <CANeU7Qn4ATFNP=tsUXPtxk2CuTGcp-PyLGT6UW8zxYfxiODaBg () mail ! gmail ! com>
--------------------
Hi Nicolai,

I finally finish up my more serious review of your patch series.
So this email is going to be long. Sorry for the long delay.

Over all pretty good.

One thing has been puzzling me when I first read the patches,
is about how the bits are used. Why there are some many bits
need to be set when the expression is a very simple integer constant.
Now I understand, the series basically treat each condition
(is it a int constant, is it a constant expression) as a bit. So when
you modify the int constant, the bits for other personality
(int expression, arithmetic expression) has to be set as well.
All this is for the optimization when you merge the binary operation
when left and right expression.

I still see the multiple personality for constant expression (it can be
both int constant and int expression etc) is a bit more complicate
than it needs to, at least I now understand why you did it that way.

The detail review follows:

1)  name of constexpr_flags is too long.

 struct expression {
        enum expression_type type:8;
-       unsigned flags:8;
+       unsigned constexpr_flags:8;

I actually thing that the more generic name "flags" are fine
without changing. If we need to add other flags not related to
constant, we will need to rename it all over again.

If you still feel strongly about the flags being too generic.
I suggest some thing shorter like "constant". The member
is in an expression struct, so the "expr" is not needed.

2) CONSTEXPR_FLAG_XXX are being too long.
+       CONSTEXPR_FLAG_INT_CONST = (1 << 0),
+       CONSTEXPR_FLAG_FP_CONST = (1 << 1),
+       CONSTEXPR_FLAG_ENUM_CONST = (1 << 2),
+       CONSTEXPR_FLAG_CHAR_CONST = (1 << 3),
+
+       /*
+        * A constant expression in the sense of [6.6]:
+        * - integer constant expression [6.6(6)]
+        * - arithmetic constant expression [6.6(8)]
+        * - address constant [6.6(9)]
+        */
+       CONSTEXPR_FLAG_INT_CONST_EXPR = (1 << 4),
+       CONSTEXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
+       CONSTEXPR_FLAG_ADDR_CONST = (1 << 6),

This is really nick pick. Look at this defines,  they all contain
"CONSTEXPR_FLAG" and "_CONST", The only different is
a very short word "INT", "FP", "CHAR" etc. The signal ratio
is pretty low.

I found it harder to read compare to the original enum value:

-enum {
-       Int_const_expr = 1,
-       Float_literal = 2,
-}; /* for expr->flags */


3) I think this is a typo, in the 01/21 patch
+/*
+ * Remove any "Constant" [6.4.4] flag, but retain the "constant
+ * expression" [6.6] flags.
+ */
+#define CONSTEXPR_FLAG_DECAY_CONSTS_MASK                               \
+       (CONSTEXPR_FLAG_INT_CONST | CONSTEXPR_FLAG_INT_CONST |          \
+               CONSTEXPR_FLAG_FP_CONST | CONSTEXPR_FLAG_CHAR_CONST)

Did any one spot there are *two* duplicate CONSTEXPR_FLAG_INT_CONST there?

This is the point I try to make in 2), the very verbose long name actually hurt
the readability. The eye need to move between long capital words try to extract
the key difference. The key difference here is "INT" vs "FP" vs "CHAR".

I think if it was written as:

              (Int_literal | Int_literal |
                   Float_literal | Char_literal)

 The bug maybe would be easier to spot?


4) in patch 12:
 static struct symbol *evaluate_ptr_add(struct expression *expr,
struct symbol *itype)
 {
        struct expression *index = expr->right;
        struct symbol *ctype, *base;
        int multiply;

        classify_type(degenerate(expr->left), &ctype);
        base = examine_pointer_target(ctype);

+       /*
+        * An address constant +/- an integer constant expression
+        * yields an address constant again [6.6(7)].
+        */
+       if ((expr->left->constexpr_flags & CONSTEXPR_FLAG_ADDR_CONST) &&
+               (expr->right->constexpr_flags & CONSTEXPR_FLAG_INT_CONST_EXPR))
+               expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
+
The constant flags should be set regardless. Otherwise it is not consistent
with the rest of the code.

Also I found that code hard to read. Because the expression is really long, it
break into a few lines.

I suggest move this code into a function:
           expr->const = evaluate_const_ptr_add(expr->right, expr->left);

Then inside  evaluate_const_ptr_add() you can use early return to make
the code does not need to use that long expression.

int evaluate_const_ptr_add(struct expression *left, struct expression *right)
{
          if (!(left->constant & Addr_const))
                   return 0;
          if (!(right->constant & Int_const_expr))
                   return 0;
          return Addr_const;
}

The same pattern can apply to a lot of the constant expression evaluation.
A lot of them share the same function e.g. convert into constant int expression.


5) in Patch 1,4,8, a few patch combine into this result.
 static struct symbol *evaluate_logical(struct expression *expr)
 {
        if (!evaluate_conditional(expr->left, 0))
                return NULL;
        if (!evaluate_conditional(expr->right, 0))
                return NULL;

        /* the result is int [6.5.13(3), 6.5.14(3)] */
        expr->ctype = &int_ctype;
-       if (expr->flags) {
-               if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-                       expr->flags = 0;
-       }
+       expr->constexpr_flags = expr->left->constexpr_flags &
+               expr->right->constexpr_flags &
+               ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK &
+               ~CONSTEXPR_FLAG_ADDR_CONST;
        return &int_ctype;
 }

Again, with this complaxity and lone line, I suggest move into a function
evaluate_const_int_expr(expr->left, expr->right)

Also this evaluate_const_int_expr() will be share by many similar caller.
e.g. evaluate_compare etc.

6) In evaluate_conditional_expression cover by patch 3,8,11,18
+       /*
+        * A conditional operator yields a particular constant
+        * expression type only if all of its three subexpressions are
+        * of that type [6.6(6), 6.6(8)].
+        * As an extension, relax this restriction by allowing any
+        * constant expression type for the condition expression.
+        *
+        * A conditional operator never yields an address constant
+        * [6.6(9)].
+        * However, as an extension, if the condition is any constant
+        * expression, and the true and false expressions are both
+        * address constants, mark the result as an address constant.
+        */
+       if (expr->conditional->constexpr_flags &
+               (CONSTEXPR_FLAG_ARITH_CONST_EXPR | CONSTEXPR_FLAG_ADDR_CONST))
+               expr->constexpr_flags = (*true)->constexpr_flags &
+                       expr->cond_false->constexpr_flags &
+                       ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK;

This is another place hard to read. I also suggest always set the
expr->constant flag. Also us3 a small function to wrap the complicate condition.
The long expression really hurts here.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 06 Dec 2016 16:54:58 +0000
Message-ID: <20161206165456.GA19255 () macbook ! local>
--------------------
On Tue, Dec 06, 2016 at 02:00:50PM +0800, Christopher Li wrote:
> 1)  name of constexpr_flags is too long.
> 
>  struct expression {
>         enum expression_type type:8;
> -       unsigned flags:8;
> +       unsigned constexpr_flags:8;
> 
> I actually thing that the more generic name "flags" are fine
> without changing. If we need to add other flags not related to
> constant, we will need to rename it all over again.

I'd suggest to also add on th same line a comment like:
	// used for the kinds of constant expression 

- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Tue, 06 Dec 2016 16:54:58 +0000
Message-ID: <20161206165456.GA19255 () macbook ! local>
--------------------
On Tue, Dec 06, 2016 at 02:00:50PM +0800, Christopher Li wrote:
> 1)  name of constexpr_flags is too long.
> 
>  struct expression {
>         enum expression_type type:8;
> -       unsigned flags:8;
> +       unsigned constexpr_flags:8;
> 
> I actually thing that the more generic name "flags" are fine
> without changing. If we need to add other flags not related to
> constant, we will need to rename it all over again.

I'd suggest to also add on th same line a comment like:
	// used for the kinds of constant expression 

- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 29 Mar 2017 14:42:35 +0000
Message-ID: <20170329144233.7hjyhshb72pbtv7s () macpro ! local>
--------------------
On Tue, Dec 06, 2016 at 02:00:50PM +0800, Christopher Li wrote:
> Hi Nicolai,
> 
> I finally finish up my more serious review of your patch series.
> So this email is going to be long. Sorry for the long delay.
> 
> Over all pretty good.
> 
...
> 
> 4) in patch 12:
>  static struct symbol *evaluate_ptr_add(struct expression *expr,
> struct symbol *itype)
>  {
>         struct expression *index = expr->right;
>         struct symbol *ctype, *base;
>         int multiply;
> 
>         classify_type(degenerate(expr->left), &ctype);
>         base = examine_pointer_target(ctype);
> 
> +       /*
> +        * An address constant +/- an integer constant expression
> +        * yields an address constant again [6.6(7)].
> +        */
> +       if ((expr->left->constexpr_flags & CONSTEXPR_FLAG_ADDR_CONST) &&
> +               (expr->right->constexpr_flags & CONSTEXPR_FLAG_INT_CONST_EXPR))
> +               expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
> +
> The constant flags should be set regardless. Otherwise it is not consistent
> with the rest of the code.

Chris, I don't really understand your remark here (regardless what ?).
Can you explain it a bit more please?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Wed, 29 Mar 2017 14:42:35 +0000
Message-ID: <20170329144233.7hjyhshb72pbtv7s () macpro ! local>
--------------------
On Tue, Dec 06, 2016 at 02:00:50PM +0800, Christopher Li wrote:
> Hi Nicolai,
> 
> I finally finish up my more serious review of your patch series.
> So this email is going to be long. Sorry for the long delay.
> 
> Over all pretty good.
> 
...
> 
> 4) in patch 12:
>  static struct symbol *evaluate_ptr_add(struct expression *expr,
> struct symbol *itype)
>  {
>         struct expression *index = expr->right;
>         struct symbol *ctype, *base;
>         int multiply;
> 
>         classify_type(degenerate(expr->left), &ctype);
>         base = examine_pointer_target(ctype);
> 
> +       /*
> +        * An address constant +/- an integer constant expression
> +        * yields an address constant again [6.6(7)].
> +        */
> +       if ((expr->left->constexpr_flags & CONSTEXPR_FLAG_ADDR_CONST) &&
> +               (expr->right->constexpr_flags & CONSTEXPR_FLAG_INT_CONST_EXPR))
> +               expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
> +
> The constant flags should be set regardless. Otherwise it is not consistent
> with the rest of the code.

Chris, I don't really understand your remark here (regardless what ?).
Can you explain it a bit more please?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 05:06:24 +0000
Message-ID: <CANeU7QkuDjEeD=MvcLVz_DfAk5AsjRBqgCTcHnG5u1aHzEs-bA () mail ! gmail ! com>
--------------------
On Wed, Mar 29, 2017 at 10:42 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Tue, Dec 06, 2016 at 02:00:50PM +0800, Christopher Li wrote:
>> The constant flags should be set regardless. Otherwise it is not consistent
>> with the rest of the code.
>
> Chris, I don't really understand your remark here (regardless what ?).
> Can you explain it a bit more please?

In has been a while. The currently code only touch the result constexpr_flags if
left and right are pointer and integer.  Otherwise, the
constantexpr_flags are not
touch at all. It is not obvious what is the previous state of the
constantexpr_flags.
I mean maybe it should clear it is that is not a constant? Most of the
evaluate_xxx
function will just set the new constexpr_flags.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 05:06:24 +0000
Message-ID: <CANeU7QkuDjEeD=MvcLVz_DfAk5AsjRBqgCTcHnG5u1aHzEs-bA () mail ! gmail ! com>
--------------------
On Wed, Mar 29, 2017 at 10:42 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Tue, Dec 06, 2016 at 02:00:50PM +0800, Christopher Li wrote:
>> The constant flags should be set regardless. Otherwise it is not consistent
>> with the rest of the code.
>
> Chris, I don't really understand your remark here (regardless what ?).
> Can you explain it a bit more please?

In has been a while. The currently code only touch the result constexpr_flags if
left and right are pointer and integer.  Otherwise, the
constantexpr_flags are not
touch at all. It is not obvious what is the previous state of the
constantexpr_flags.
I mean maybe it should clear it is that is not a constant? Most of the
evaluate_xxx
function will just set the new constexpr_flags.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 08:55:00 +0000
Message-ID: <CAExDi1T4_0Jpi4vYmBr0B=SaG77tQLkeCpH-BbT0HbC+KFtz7w () mail ! gmail ! com>
--------------------
On Fri, Mar 31, 2017 at 7:06 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Wed, Mar 29, 2017 at 10:42 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> On Tue, Dec 06, 2016 at 02:00:50PM +0800, Christopher Li wrote:
>>> The constant flags should be set regardless. Otherwise it is not consistent
>>> with the rest of the code.
>>
>> Chris, I don't really understand your remark here (regardless what ?).
>> Can you explain it a bit more please?
>
> In has been a while. The currently code only touch the result constexpr_flags if
> left and right are pointer and integer.  Otherwise, the
> constantexpr_flags are not
> touch at all. It is not obvious what is the previous state of the
> constantexpr_flags.
> I mean maybe it should clear it is that is not a constant? Most of the
> evaluate_xxx
> function will just set the new constexpr_flags.

The very first patch of the series insure that all flags are
initialized to the default 'NONE'. Then the next patches build
on this and add info/bits to flags case by case.

As far as I can see the patch was correct.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 10:40:26 +0000
Message-ID: <CANeU7QmsZ1rd_P3O45FuZ1y3tO8fOAOgp-+iqiJs400cQOCWsg () mail ! gmail ! com>
--------------------
On Fri, Mar 31, 2017 at 4:55 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The very first patch of the series insure that all flags are
> initialized to the default 'NONE'. Then the next patches build
> on this and add info/bits to flags case by case.
>
> As far as I can see the patch was correct.

How about a different test case. The right hand side is a const
expression but not an int const expression.
So the result is not an address constant.  The result should be some
other kind of constant since both
left hand side and right hand side are both constant expression. If
the result has NONE then it is wrong.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 10:40:26 +0000
Message-ID: <CANeU7QmsZ1rd_P3O45FuZ1y3tO8fOAOgp-+iqiJs400cQOCWsg () mail ! gmail ! com>
--------------------
On Fri, Mar 31, 2017 at 4:55 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The very first patch of the series insure that all flags are
> initialized to the default 'NONE'. Then the next patches build
> on this and add info/bits to flags case by case.
>
> As far as I can see the patch was correct.

How about a different test case. The right hand side is a const
expression but not an int const expression.
So the result is not an address constant.  The result should be some
other kind of constant since both
left hand side and right hand side are both constant expression. If
the result has NONE then it is wrong.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 10:40:26 +0000
Message-ID: <CANeU7QmsZ1rd_P3O45FuZ1y3tO8fOAOgp-+iqiJs400cQOCWsg () mail ! gmail ! com>
--------------------
On Fri, Mar 31, 2017 at 4:55 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The very first patch of the series insure that all flags are
> initialized to the default 'NONE'. Then the next patches build
> on this and add info/bits to flags case by case.
>
> As far as I can see the patch was correct.

How about a different test case. The right hand side is a const
expression but not an int const expression.
So the result is not an address constant.  The result should be some
other kind of constant since both
left hand side and right hand side are both constant expression. If
the result has NONE then it is wrong.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 19:47:17 +0000
Message-ID: <CAExDi1SQ1gHF10xkJWhPfmSyAt03_d-jk3Eyjk3ofZ3K73zrNA () mail ! gmail ! com>
--------------------
On Fri, Mar 31, 2017 at 12:40 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Fri, Mar 31, 2017 at 4:55 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> The very first patch of the series insure that all flags are
>> initialized to the default 'NONE'. Then the next patches build
>> on this and add info/bits to flags case by case.
>>
>> As far as I can see the patch was correct.
>
> How about a different test case. The right hand side is a const
> expression but not an int const expression.
> So the result is not an address constant.  The result should be some
> other kind of constant since both
> left hand side and right hand side are both constant expression. If
> the result has NONE then it is wrong.

OK, I think I begin to understand.
It's important that the standard is not coherent on the notion of
constant vs. constant expression.
This distinction exists for integers:
- a case in a switch statement requires an integer constant
- initializers are happy with integer constant expressions.
For address, no such distinction exists, the standard specifically
states in [6.6.9]:
    An address constant is a null pointer, a pointer to an lvalue
    designating an object of static storage duration, or a pointer
    to a function designator; it shall be created explicitly using
    the unary & operator or an integer constant cast to pointer type,
    or implicitly by the use of an expression of array or function type.
    The array-subscript [] and member-access . and -> operators,
    the address & and indirection * unary operators, and pointer casts
    may be used in the creation of an address constant, but the value
    of an object shall not be accessed by use of these operators.

If the LHS is not an address constant, the result will not be any kind
of constexprs. And if the LHS is an address constant but the RHS is
not an integer constant expression then the result will also not be any
kind of constexprs. Which leave us with the case covered here.
Am I missing something?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/21] improve constexpr handling
Date: Fri, 31 Mar 2017 19:47:17 +0000
Message-ID: <CAExDi1SQ1gHF10xkJWhPfmSyAt03_d-jk3Eyjk3ofZ3K73zrNA () mail ! gmail ! com>
--------------------
On Fri, Mar 31, 2017 at 12:40 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Fri, Mar 31, 2017 at 4:55 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> The very first patch of the series insure that all flags are
>> initialized to the default 'NONE'. Then the next patches build
>> on this and add info/bits to flags case by case.
>>
>> As far as I can see the patch was correct.
>
> How about a different test case. The right hand side is a const
> expression but not an int const expression.
> So the result is not an address constant.  The result should be some
> other kind of constant since both
> left hand side and right hand side are both constant expression. If
> the result has NONE then it is wrong.

OK, I think I begin to understand.
It's important that the standard is not coherent on the notion of
constant vs. constant expression.
This distinction exists for integers:
- a case in a switch statement requires an integer constant
- initializers are happy with integer constant expressions.
For address, no such distinction exists, the standard specifically
states in [6.6.9]:
    An address constant is a null pointer, a pointer to an lvalue
    designating an object of static storage duration, or a pointer
    to a function designator; it shall be created explicitly using
    the unary & operator or an integer constant cast to pointer type,
    or implicitly by the use of an expression of array or function type.
    The array-subscript [] and member-access . and -> operators,
    the address & and indirection * unary operators, and pointer casts
    may be used in the creation of an address constant, but the value
    of an object shall not be accessed by use of these operators.

If the LHS is not an address constant, the result will not be any kind
of constexprs. And if the LHS is an address constant but the RHS is
not an integer constant expression then the result will also not be any
kind of constexprs. Which leave us with the case covered here.
Am I missing something?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 01/21] expression: introduce additional expression constness tracking flags ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 01/21] expression: introduce additional expression constness tracking flags
Date: Tue, 15 Mar 2016 21:23:18 +0000
Message-ID: <20160315212316.GA2679 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:29:40AM +0100, Nicolai Stange wrote:
> Even if sparse attempted to verify that initializers for static storage
> duration objects are constant expressions [6.7.8(4)] (which it
> currently does not), it could not tell reliably.
> Example:
> 
>   enum { b = 0 };
>   static void *c = { (void*)b }; /* disallowed by C99 */
> 
> References to enum members are not allowed in address constants [6.6(9)] and thus,
> the initializer is not a constant expression at all.
> 
> Prepare for a more fine-grained tracking of expression constness in the
> sense of C99 [6.4.4, 6.6].
> 
> Introduce a broader set of constness tracking flags, resembling the
> four types of primary expression constants [6.4.4] (integer, floating, enumeration,
> character). Define helper macros to consistently set and clear these flags as they
> are not completely independent.
> 
> In particular, introduce the following flags for tagging expression constness at
> the level of primary expressions:
> - CONSTEXPR_FLAG_INT_CONST: integer constant, i.e. literal
> - CONSTEXPR_FLAG_FP_CONST: floating point constant, equivalent to the former
>                            Float_literal flag
> - CONSTEXPR_FLAG_ENUM_CONST: enumeration constant
> - CONSTEXPR_FLAG_CHAR_CONST: character constant
> 
> Introduce the CONSTEXPR_FLAG_INT_CONST_EXPR flag meant for tagging integer constant
> expressions. It is equivalent to the former Int_const_expr flag.
> Note that the new CONSTEXPR_FLAG_INT_CONST, CONSTEXPR_FLAG_ENUM_CONST and
> CONSTEXPR_FLAG_CHAR_CONST flags imply CONSTEXPR_FLAG_INT_CONST_EXPR being set.
> 
> Finally, rename ->flags to ->constexpr_flags because they are solely used for the
> purpose of tracking an expression's constness.
> 

The changes are, in themselves, fine to me but I have a few remarks:

*) I think the patch would be nicer (abd certainly easier to review) if
   it would be splitted so that changes that can't possibly go wrong are
   not mixed with others which changes behaviour/semantics.
   So you can mechanically replace Int_const_expr by CONSTEXPR_...
   then ->flags by ...
   And only then replace ..._EXPR by ..._SET_MASK and so on

*) you will probably hate me for this but ...
   I think that the names you're using are way too long.
   It doesn't help readability at all, especially when because of the length
   you need to fole lines in if-expression
   'CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK', that's already really long
   and the change 'flags' to 'constexpr_flags' doesn't help either
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 02/21] expression: init constexpr_flags at expression allocation ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 02/21] expression: init constexpr_flags at expression allocation
Date: Tue, 15 Mar 2016 16:59:16 +0000
Message-ID: <20160315165915.GB1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:30:49AM +0100, Nicolai Stange wrote:
> Currently, the expression evaluation code explicitly opts out from
> constness at evaluation if certain criteria regarding the subexpressions
> are not matched.
> 
> Instead of this active opt-out, we want to have subexpression constness
> attributes to get propagated from child expressions to their parents in
> the future.
> 
> A prerequisite is that each expression's ->constexpr_flags is in a defined
> state at all times.
> 
> Set ->constexpr_flags to CONSTEXPR_FLAG_NONE at expression allocation time,
> i.e. in alloc_expression() as well as in alloc_const_expression().
> 
> Signed-off-by: Nicolai Stange <nicstange@gmail.com>
> ---
>  expression.h | 2 ++
>  1 file changed, 2 insertions(+)
> 
> diff --git a/expression.h b/expression.h
> index 3725a73..8a943a4 100644
> --- a/expression.h
> +++ b/expression.h
> @@ -255,6 +255,7 @@ static inline struct expression *alloc_expression(struct position pos, int type)
>  	struct expression *expr = __alloc_expression(0);
>  	expr->type = type;
>  	expr->pos = pos;
> +	expr->constexpr_flags = CONSTEXPR_FLAG_NONE;
>  	return expr;
>  }
>  
> @@ -265,6 +266,7 @@ static inline struct expression *alloc_const_expression(struct position pos, int
>  	expr->pos = pos;
>  	expr->value = value;
>  	expr->ctype = &int_ctype;
> +	expr->constexpr_flags = CONSTEXPR_FLAG_NONE;
>  	return expr;
>  }

Fine for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 05/21] expression: examine constness of preops at evaluation only ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 05/21] expression: examine constness of preops at evaluation only
Date: Tue, 15 Mar 2016 17:09:22 +0000
Message-ID: <20160315170921.GD1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:33:38AM +0100, Nicolai Stange wrote:
> Move the whole calculation of prefix expressions' constness flags to
> the evaluation phase such that expressions like
> 
>   -__builtin_choose_expr(0, 0, 0)
>   ~__builtin_choose_expr(0, 0, 0)
>   !__builtin_choose_expr(0, 0, 0)
> 
> can now be recognized as qualifying as integer constant expressions.


Fien for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 07/21] expression: add support for tagging arithmetic constant expressions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 07/21] expression: add support for tagging arithmetic constant expressions
Date: Tue, 15 Mar 2016 17:13:00 +0000
Message-ID: <20160315171259.GF1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:35:27AM +0100, Nicolai Stange wrote:
> Arithmetic constant expressions may be either of (6.6(8)):
> - integer constant expressions
> - floating point constants
> or any arithmetic expression build up from them.
> Furthermore, casts with arithmetic destination types preserve arithmetic
> constness.
> 
> Arithmetic constant expressions may be used as initializers for objects of
> static storage duration.
> 
> Introduce a new constexpr_flag CONSTEXPR_FLAG_ARITH_CONST_EXPR.
> 
> Modify CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK and
> CONSTEXPR_FLAG_FP_CONST_SET_MASK to also include that new bit.
> Thus, whenever an integer constant expression or a floating point constant
> is recognized, it is automatically tagged as an arithmetic constant
> expression.
> 
> Note that everything has already been set up such that the new
> CONSTEXPR_FLAG_ARITH_CONST_EXPR flag propagates nicely from subexpressions
> to parent expressions at evaluation.
> 

Fine for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 09/21] evaluate: check static storage duration objects' intializers' constness ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 09/21] evaluate: check static storage duration objects' intializers' constness
Date: Tue, 15 Mar 2016 17:28:35 +0000
Message-ID: <20160315172834.GH1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:37:18AM +0100, Nicolai Stange wrote:
> Initializers of static storage duration objects shall be constant
> expressions [6.7.8(4)].
> 
> Warn if that requirement is not met and the -Wstatic-initializer-not-const
> flag has been given on sparse's command line.


"-Wstatic-initializer-not-const" s not what is used further in the code.

Also, I think it should be better to introduce this new -W flag in a separate
patch.
 
> Identify static storage duration objects by having either of
> MOD_TOPLEVEL or MOD_STATIC set.
> 
> Check an initializer's constness at the lowest possible subobject
> level, i.e. at the level of the "assignment-expression" production
> in [6.7.8].
> 
> For compound objects, make handle_list_initializer() pass the
> surrounding object's storage duration modifiers down to
> handle_simple_initializer() at subobject initializer evaluation.
> 
> Signed-off-by: Nicolai Stange <nicstange@gmail.com>
> ---
> diff --git a/evaluate.c b/evaluate.c
> index dd44cd5..300bfbe 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -2509,8 +2510,21 @@ found:
>  		else
>  			v = &top->ident_expression;
>  
> -		if (handle_simple_initializer(v, 1, lclass, top->ctype))
> +		/*
> +		 * Temporarily copy storage modifiers down from
> +		 * surrounding type such that
> +		 * handle_simple_initializer() can check
> +		 * initializations of subobjects with static storage
> +		 * duration.
> +		 */
> +		old_modifiers = top->ctype->ctype.modifiers;
> +		top->ctype->ctype.modifiers =
> +			old_modifiers | (ctype->ctype.modifiers & MOD_STORAGE);
> +		if (handle_simple_initializer(v, 1, lclass, top->ctype)) {
> +			top->ctype->ctype.modifiers = old_modifiers;
>  			continue;
> +		}
> +		top->ctype->ctype.modifiers = old_modifiers;

This saving/restoring of the modifiers is not very nice.
Hadn't we talked about adding an arg to handle_simple_initializer() or so?
  
>  		if (!(lclass & TYPE_COMPOUND)) {
>  			warning(e->pos, "bogus scalar initializer");
> @@ -2620,6 +2634,16 @@ static int handle_simple_initializer(struct expression **ep, int nested,
>  		if (!evaluate_expression(e))
>  			return 1;
>  		compatible_assignment_types(e, ctype, ep, "initializer");
> +		/*
> +		 * Initializers for static storage duration objects
> +		 * shall be constant expressions or a string literal [6.7.8(4)].
> +		 */
> +		if ((ctype->ctype.modifiers & (MOD_TOPLEVEL | MOD_STATIC)) &&
> +			!(e->constexpr_flags & (CONSTEXPR_FLAG_ARITH_CONST_EXPR
> +					| CONSTEXPR_FLAG_ADDR_CONST)) &&
> +			Wconstexpr_not_const)

This last line whould be more indented, maybe like the previous line.

> +			warning(e->pos, "non-constant initializer for static object");
> +
>  		return 1;
>  	}
>  
> diff --git a/lib.c b/lib.c
> index 8dc5bcf..75cea42 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -219,6 +219,7 @@ int Waddress_space = 1;
>  int Wbitwise = 0;
>  int Wcast_to_as = 0;
>  int Wcast_truncate = 1;
> +int Wconstexpr_not_const = 0;


This name is quite good.


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 1/2] arm64: implement FTRACE_WITH_REGS ===

From: kbuild test robot <lkp () intel ! com>
To: linux-sparse
Subject: Re: [PATCH v3 1/2] arm64: implement FTRACE_WITH_REGS
Date: Thu, 11 Aug 2016 19:32:44 +0000
Message-ID: <201608120337.ncJVDfVQ%fengguang.wu () intel ! com>
--------------------

--Nq2Wo0NMKNjxTN9z
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

Hi Torsten,

[auto build test ERROR on arm64/for-next/core]
[also build test ERROR on v4.8-rc1 next-20160811]
[if your patch is applied to the wrong git tree, please drop us a note to help improve the system]

url:    https://github.com/0day-ci/linux/commits/Torsten-Duwe/arm64-live-patching/20160812-004131
base:   https://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux.git for-next/core
config: arm64-allmodconfig (attached as .config)
compiler: aarch64-linux-gnu-gcc (Debian 5.4.0-6) 5.4.0 20160609
reproduce:
        wget https://git.kernel.org/cgit/linux/kernel/git/wfg/lkp-tests.git/plain/sbin/make.cross -O ~/bin/make.cross
        chmod +x ~/bin/make.cross
        # save the attached .config to linux build tree
        make.cross ARCH=arm64 

All errors (new ones prefixed by >>):

   arch/arm64/Makefile:61: Cannot use CONFIG_DYNAMIC_FTRACE_WITH_REGS: -fprolog-pad not supported by compiler
   Makefile:687: Cannot use CONFIG_KCOV: -fsanitize-coverage=trace-pc is not supported by compiler
>> aarch64-linux-gnu-gcc: error: unrecognized command line option '-fprolog-pad=2'
   make[2]: *** [kernel/bounds.s] Error 1
   make[2]: Target '__build' not remade because of errors.
   make[1]: *** [prepare0] Error 2
   make[1]: Target 'prepare' not remade because of errors.
   make: *** [sub-make] Error 2

---
0-DAY kernel test infrastructure                Open Source Technology Center
https://lists.01.org/pipermail/kbuild-all                   Intel Corporation

--Nq2Wo0NMKNjxTN9z
Content-Type: application/octet-stream
Content-Disposition: attachment; filename=".config.gz"
Content-Transfer-Encoding: base64

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
XeT/AdimN/bZFQMA

--Nq2Wo0NMKNjxTN9z--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 10/21] expression, evaluate: recognize static objects as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 10/21] expression, evaluate: recognize static objects as address constants
Date: Mon, 01 Feb 2016 02:38:24 +0000
Message-ID: <87egcxi28v.fsf () gmail ! com>
--------------------
Introduce support for recognizing address constants created either
- explicitly by referencing a static storage duration object by means
  of the unary & operator,
- implicitly by the use of an expression of array or function type.

Initially tag an expression as being an address constant at the primary
expression level, i.e. upon encountering a symbol designating an object of
static storage duration in primary_expression().

Carry the address constant flag over to the *-preop wrapped expression
created by evaluate_symbol_expression().

When dereferencing such a *-preop wrapped expression, make
evaluate_addressof() keep any address constant flag for the unwrapped
expression.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                            |  3 ++-
 expression.c                          |  8 ++++++++
 validation/constexpr-addr-of-static.c | 36 +++++++++++++++++++++++++++++++++++
 3 files changed, 46 insertions(+), 1 deletion(-)
 create mode 100644 validation/constexpr-addr-of-static.c

diff --git a/evaluate.c b/evaluate.c
index 300bfbe..91f89f4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -70,9 +70,11 @@ static struct symbol *evaluate_symbol_expression(struct expression *expr)
 	addr->symbol = sym;
 	addr->symbol_name = expr->symbol_name;
 	addr->ctype = &lazy_ptr_ctype;	/* Lazy evaluation: we need to do a proper job if somebody does &sym */
+	addr->constexpr_flags = expr->constexpr_flags;
 	expr->type = EXPR_PREOP;
 	expr->op = '*';
 	expr->unop = addr;
+	expr->constexpr_flags = CONSTEXPR_FLAG_NONE;
 
 	/* The type of a symbol is the symbol itself! */
 	expr->ctype = sym;
@@ -1682,7 +1684,6 @@ static struct symbol *evaluate_addressof(struct expression *expr)
 	}
 	ctype = op->ctype;
 	*expr = *op->unop;
-	expr->constexpr_flags = CONSTEXPR_FLAG_NONE;
 
 	if (expr->type == EXPR_SYMBOL) {
 		struct symbol *sym = expr->symbol;
diff --git a/expression.c b/expression.c
index b2d5eb4..11fb9cd 100644
--- a/expression.c
+++ b/expression.c
@@ -440,6 +440,14 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		}
 		expr->symbol_name = token->ident;
 		expr->symbol = sym;
+
+		/*
+		 * A pointer to an lvalue designating a static storage
+		 * duration object is an address constant [6.6(9)].
+		 */
+		if(sym && (sym->ctype.modifiers & (MOD_TOPLEVEL | MOD_STATIC)))
+			expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
+
 		token = next;
 		break;
 	}
diff --git a/validation/constexpr-addr-of-static.c b/validation/constexpr-addr-of-static.c
new file mode 100644
index 0000000..a3af99a
--- /dev/null
+++ b/validation/constexpr-addr-of-static.c
@@ -0,0 +1,36 @@
+static int a = 1;
+static int b[2] = {1, 1};
+static void c(void) {}
+
+static int *d = &a;		// OK
+static int *e = d;		// KO
+static int *f = b;		// OK
+
+static void (*g)(void) = c;	// OK
+static void (*h)(void) = &c;	// OK
+
+static int *i = &*&a;		// OK
+static int *j = &*b;		// OK
+static int *k = &*d;		// KO
+
+
+static void l(void) {
+	int a = 1;
+	static int *b = &a;	// KO
+}
+
+static void m(void) {
+	static int a = 1;
+	static int *b = &a;	// OK
+}
+
+/*
+ * check-name: address of static object constness verification.
+ * check-command: sparse -Wconstexpr-not-const $file
+ *
+ * check-error-start
+constexpr-addr-of-static.c:6:17: warning: non-constant initializer for static object
+constexpr-addr-of-static.c:14:19: warning: non-constant initializer for static object
+constexpr-addr-of-static.c:19:26: warning: non-constant initializer for static object
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 11/21] evaluate: recognize address constants created through casts ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 11/21] evaluate: recognize address constants created through casts
Date: Tue, 15 Mar 2016 17:44:56 +0000
Message-ID: <20160315174455.GJ1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:39:09AM +0100, Nicolai Stange wrote:
> According to 6.6(9), an address constant may get created by casting
> an integer constant to pointer type.
> 
> Make evaluate_cast() handle this case, that is tag a cast expression
> as being an address constant if the target is a integer constant and
> the destination is of pointer type.
> 
> Signed-off-by: Nicolai Stange <nicstange@gmail.com>
> ---
>  evaluate.c                          | 10 +++++++++-
>  validation/constexpr-pointer-cast.c | 13 +++++++++++++
>  2 files changed, 22 insertions(+), 1 deletion(-)
>  create mode 100644 validation/constexpr-pointer-cast.c
> 
> diff --git a/evaluate.c b/evaluate.c
> index 91f89f4..a740474 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -2767,7 +2767,15 @@ static struct symbol *evaluate_cast(struct expression *expr)
>  
>  	class1 = classify_type(ctype, &t1);
>  
> -	if (class1 & TYPE_NUM) {
> +	if (!(class1 & TYPE_NUM)) {
> +		/*
> +		 * Casts of integer literals to pointer type yield
> +		 * address constants [6.6(9)].
> +		 */
> +		if (class1 & TYPE_PTR &&

Better put "class1 & TYPE_PTR" between parenthesis.

> +			(target->constexpr_flags & CONSTEXPR_FLAG_INT_CONST))
> +			expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
> +	} else {

I would have put as the else clause instead of changing the condition.
Not that it really matters though.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 12/21] evaluate: recognize address constants created through pointer arithmetic ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 12/21] evaluate: recognize address constants created through pointer arithmetic
Date: Mon, 01 Feb 2016 02:39:58 +0000
Message-ID: <8760y9i269.fsf () gmail ! com>
--------------------
An address constant +/- an integer constant expression qualifies as an
address constant again.
Furthermore, the array-subscript operator "[]" may be used in the creation
of address constant.

Handle both cases by making evaluate_ptr_add() check whether an integer
constant expression is added to an address constant and tag the result as
being an address constant again if so.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                           |  8 ++++++++
 validation/constexpr-pointer-arith.c | 28 ++++++++++++++++++++++++++++
 2 files changed, 36 insertions(+)
 create mode 100644 validation/constexpr-pointer-arith.c

diff --git a/evaluate.c b/evaluate.c
index a740474..16b4ce0 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -565,6 +565,14 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
 	classify_type(degenerate(expr->left), &ctype);
 	base = examine_pointer_target(ctype);
 
+	/*
+	 * An address constant +/- an integer constant expression
+	 * yields an address constant again [6.6(7)].
+	 */
+	if ((expr->left->constexpr_flags & CONSTEXPR_FLAG_ADDR_CONST) &&
+		(expr->right->constexpr_flags & CONSTEXPR_FLAG_INT_CONST_EXPR))
+		expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
+
 	if (!base) {
 		expression_error(expr, "missing type information");
 		return NULL;
diff --git a/validation/constexpr-pointer-arith.c b/validation/constexpr-pointer-arith.c
new file mode 100644
index 0000000..a922028
--- /dev/null
+++ b/validation/constexpr-pointer-arith.c
@@ -0,0 +1,28 @@
+static int a = 1;
+static int b[2] = {1, 1};
+
+static int *c = &b[1];					// OK
+static int *d = (int*)0 + 1;				// OK
+static int *e = &b[1] + 1;				// OK
+static int *f = b + 1;					// OK
+static int *g = d + 1;					// KO
+static int *h = &a + 1;				// OK
+static int *i = &b[1] + 1;				// OK
+static int *j = b + 1;					// OK
+static int *k = d + 1;					// KO
+static int *l = &*&b[1];				// OK
+static int *m = &*(&a + 1);				// OK
+static int *n = &*(&b[1] + 1);				// OK
+static int *o = &*(b + 1);				// OK
+static int *p = &*(d + 1);				// KO
+
+/*
+ * check-name: pointer arithmetic constness verification.
+ * check-command: sparse -Wconstexpr-not-const $file
+ *
+ * check-error-start
+constexpr-pointer-arith.c:8:19: warning: non-constant initializer for static object
+constexpr-pointer-arith.c:12:19: warning: non-constant initializer for static object
+constexpr-pointer-arith.c:17:22: warning: non-constant initializer for static object
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 12/21] evaluate: recognize address constants created through pointer arithmetic
Date: Tue, 15 Mar 2016 17:46:00 +0000
Message-ID: <20160315174559.GK1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:39:58AM +0100, Nicolai Stange wrote:
> An address constant +/- an integer constant expression qualifies as an
> address constant again.
> Furthermore, the array-subscript operator "[]" may be used in the creation
> of address constant.
> 
> Handle both cases by making evaluate_ptr_add() check whether an integer
> constant expression is added to an address constant and tag the result as
> being an address constant again if so.
> 

Fine for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 13/21] evaluate: recognize members of static compound objects as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 13/21] evaluate: recognize members of static compound objects as address constants
Date: Mon, 01 Feb 2016 02:40:42 +0000
Message-ID: <871t8xi251.fsf () gmail ! com>
--------------------
According to 6.6(9), the member access operators "." and "->" may be used
in the creation of address constants.

Uses of both operators amount to the creation of EXPR_DEREF expressions
which are eventually fed into evaluate_offset() at evaluation.

Make evaluate_offset() propagate any address constant flag of the object
containing the referenced member to the newly created pointer addition
expression.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                                   |  6 ++++++
 validation/constexpr-addr-of-static-member.c | 26 ++++++++++++++++++++++++++
 2 files changed, 32 insertions(+)
 create mode 100644 validation/constexpr-addr-of-static-member.c

diff --git a/evaluate.c b/evaluate.c
index 16b4ce0..f31ba9c 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1957,6 +1957,12 @@ static struct expression *evaluate_offset(struct expression *expr, unsigned long
 	 * we ever take the address of this member dereference..
 	 */
 	add->ctype = &lazy_ptr_ctype;
+	/*
+	 * The resulting address of a member access through an address
+	 * constant is an address constant again [6.6(9)].
+	 */
+	add->constexpr_flags = expr->constexpr_flags;
+
 	return add;
 }
 
diff --git a/validation/constexpr-addr-of-static-member.c b/validation/constexpr-addr-of-static-member.c
new file mode 100644
index 0000000..f944f21
--- /dev/null
+++ b/validation/constexpr-addr-of-static-member.c
@@ -0,0 +1,26 @@
+struct A {
+	int a;
+	int b[2];
+};
+
+struct B {
+	int c;
+	struct A d;
+};
+
+static struct B a= {1, {1, {1, 1}}};
+
+static int *b = &a.d.a;	// OK
+static int *c = &(&a.d)->a;	// OK
+static int *d = a.d.b;		// OK
+static int *e = (&a.d)->b;	// OK
+static int *f = &a.d.b[1];	// OK
+static int *g = &(&a.d)->b[1];	// OK
+
+/*
+ * check-name: address of static object's member constness verification.
+ * check-command: sparse -Wconstexpr-not-const $file
+ *
+ * check-error-start
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 14/21] evaluate: recognize string literals as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 14/21] evaluate: recognize string literals as address constants
Date: Mon, 01 Feb 2016 02:41:24 +0000
Message-ID: <87wpqpgnjf.fsf () gmail ! com>
--------------------
Introduce support for recognizing string literals as address constants.

Make evaluate_string() unconditionally tag the *-preop wrapped symbol
expression as being an address constant.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                    | 1 +
 validation/constexpr-string.c | 9 +++++++++
 2 files changed, 10 insertions(+)
 create mode 100644 validation/constexpr-string.c

diff --git a/evaluate.c b/evaluate.c
index f31ba9c..7a4af39 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -108,6 +108,7 @@ static struct symbol *evaluate_string(struct expression *expr)
 	
 	addr->symbol = sym;
 	addr->ctype = &lazy_ptr_ctype;
+	addr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
 
 	expr->type = EXPR_PREOP;
 	expr->op = '*';
diff --git a/validation/constexpr-string.c b/validation/constexpr-string.c
new file mode 100644
index 0000000..e641a83
--- /dev/null
+++ b/validation/constexpr-string.c
@@ -0,0 +1,9 @@
+static char *a = "foobar";	// OK
+
+/*
+ * check-name: string literal constness verification.
+ * check-command: sparse -Wconstexpr-not-const $file
+ *
+ * check-error-start
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 14/21] evaluate: recognize string literals as address constants
Date: Tue, 15 Mar 2016 17:46:51 +0000
Message-ID: <20160315174650.GM1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:41:24AM +0100, Nicolai Stange wrote:
> Introduce support for recognizing string literals as address constants.
> 
> Make evaluate_string() unconditionally tag the *-preop wrapped symbol
> expression as being an address constant.
> 

Fine for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 15/21] expression: recognize references to labels as address constants ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 15/21] expression: recognize references to labels as address constants
Date: Tue, 15 Mar 2016 17:47:14 +0000
Message-ID: <20160315174713.GN1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:42:10AM +0100, Nicolai Stange wrote:
> As an extension, GCC allows labels to be referenced a la
>   label1:
>   ...
> 
>   void *ptr = &&label1;
> 
> Tag these label references as being address constants allowing them
> to be used as initializers for objects of static storage duration.
> 

Fine for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 16/21] expression: examine constness of __builtin_offsetof at evaluation only ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 16/21] expression: examine constness of __builtin_offsetof at evaluation only
Date: Mon, 01 Feb 2016 02:42:59 +0000
Message-ID: <87oac1gngs.fsf () gmail ! com>
--------------------
Currently, the determination of a __builtin_offsetof() expressions'
constness flags is done in two steps:
- Several flags are speculatively set at expression parsing time
- and possibly cleared again at evaluation if the member expression
  includes a non-const array index like in
    __builtin_offsetof(struct A, a.b[non_const_foo])

For consistency with other expression types' evaluation, defer the
determination of a __builtin_offsetof() expression's constness to
evaluation time, too.

Furthermore, carry an array index expression's constness flags
through the implicit cast to size_t type.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                      | 10 +++++++---
 expression.c                    |  6 ------
 validation/constexpr-offsetof.c | 21 +++++++++++++++++++++
 3 files changed, 28 insertions(+), 9 deletions(-)
 create mode 100644 validation/constexpr-offsetof.c

diff --git a/evaluate.c b/evaluate.c
index 7a4af39..0101e61 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3031,25 +3031,29 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		} else {
 			struct expression *idx = expr->index, *m;
 			struct symbol *i_type = evaluate_expression(idx);
+			unsigned old_idx_flags;
 			int i_class = classify_type(i_type, &i_type);
+
 			if (!is_int(i_class)) {
 				expression_error(expr, "non-integer index");
 				return NULL;
 			}
 			unrestrict(idx, i_class, &i_type);
+			old_idx_flags = idx->constexpr_flags;
 			idx = cast_to(idx, size_t_ctype);
+			idx->constexpr_flags = old_idx_flags;
 			m = alloc_const_expression(expr->pos,
 						   bits_to_bytes(ctype->bit_size));
 			m->ctype = size_t_ctype;
-			m->constexpr_flags |=
-				CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK;
+			m->constexpr_flags = CONSTEXPR_FLAG_INT_CONST_SET_MASK;
 			expr->type = EXPR_BINOP;
 			expr->left = idx;
 			expr->right = m;
 			expr->op = '*';
 			expr->ctype = size_t_ctype;
 			expr->constexpr_flags = m->constexpr_flags &
-				idx->constexpr_flags;
+				idx->constexpr_flags &
+				~CONSTEXPR_FLAG_DECAY_CONSTS_MASK;
 		}
 	}
 	if (e) {
diff --git a/expression.c b/expression.c
index ac6cf43..c3d54fe 100644
--- a/expression.c
+++ b/expression.c
@@ -200,8 +200,6 @@ static struct token *builtin_offsetof_expr(struct token *token,
 			return expect(token, ')', "at end of __builtin_offset");
 		case SPECIAL_DEREFERENCE:
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->constexpr_flags =
-				CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK;
 			e->op = '[';
 			*p = e;
 			p = &e->down;
@@ -209,8 +207,6 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '.':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->constexpr_flags =
-				CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK;
 			e->op = '.';
 			if (token_type(token) != TOKEN_IDENT) {
 				sparse_error(token->pos, "Expected member name");
@@ -222,8 +218,6 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '[':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->constexpr_flags =
-				CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK;
 			e->op = '[';
 			token = parse_expression(token, &e->index);
 			token = expect(token, ']',
diff --git a/validation/constexpr-offsetof.c b/validation/constexpr-offsetof.c
new file mode 100644
index 0000000..d1697b0
--- /dev/null
+++ b/validation/constexpr-offsetof.c
@@ -0,0 +1,21 @@
+struct A {
+	int a[1];
+	int b;
+};
+
+extern int c;
+
+static int o[] = {
+	[__builtin_offsetof(struct A, b)] = 0,		// OK
+	[__builtin_offsetof(struct A, a[0])] = 0,	// OK
+	[__builtin_offsetof(struct A, a[0*0])] = 0,	// OK
+	[__builtin_offsetof(struct A, a[c])] = 0	// KO
+};
+
+/*
+ * check-name: __builtin_offsetof() constness verification.
+ *
+ * check-error-start
+constexpr-offsetof.c:12:39: error: bad constant expression
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 16/21] expression: examine constness of __builtin_offsetof at evaluation only
Date: Tue, 15 Mar 2016 19:52:46 +0000
Message-ID: <20160315195245.GS1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:42:59AM +0100, Nicolai Stange wrote:
> Currently, the determination of a __builtin_offsetof() expressions'
> constness flags is done in two steps:
> - Several flags are speculatively set at expression parsing time
> - and possibly cleared again at evaluation if the member expression
>   includes a non-const array index like in
>     __builtin_offsetof(struct A, a.b[non_const_foo])
> 
> For consistency with other expression types' evaluation, defer the
> determination of a __builtin_offsetof() expression's constness to
> evaluation time, too.

I don't think that consistency is the good/real reason,
you're doing it for the same reason as the others: so that
the expression is recognized as an integer constant expression.
 
> Furthermore, carry an array index expression's constness flags
> through the implicit cast to size_t type.
> 
> Signed-off-by: Nicolai Stange <nicstange@gmail.com>
> ---
> diff --git a/evaluate.c b/evaluate.c
> index 7a4af39..0101e61 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -3031,25 +3031,29 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
>  		} else {
>  			struct expression *idx = expr->index, *m;
>  			struct symbol *i_type = evaluate_expression(idx);
> +			unsigned old_idx_flags;
>  			int i_class = classify_type(i_type, &i_type);
> +
>  			if (!is_int(i_class)) {
>  				expression_error(expr, "non-integer index");
>  				return NULL;
>  			}
>  			unrestrict(idx, i_class, &i_type);
> +			old_idx_flags = idx->constexpr_flags;
>  			idx = cast_to(idx, size_t_ctype);
> +			idx->constexpr_flags = old_idx_flags;

This saving/restoring of teh flags is annoying.
Why is it needed? Can it be solved in another way?

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 17/21] symbol: flag builtins constant_p, safe_p and warning as constexprs ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 17/21] symbol: flag builtins constant_p, safe_p and warning as constexprs
Date: Mon, 01 Feb 2016 02:43:53 +0000
Message-ID: <87k2mpgnfa.fsf () gmail ! com>
--------------------
Unconditionally flag the expressions
  __builtin_constant_p(),
  __builtin_safe_p(),
  __builtin_warning()
as being integer constant expressions.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 symbol.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/symbol.c b/symbol.c
index 0ceff62..42e6a8f 100644
--- a/symbol.c
+++ b/symbol.c
@@ -642,9 +642,10 @@ struct symbol *create_symbol(int stream, const char *name, int type, int namespa
 	return sym;
 }
 
-static int evaluate_to_integer(struct expression *expr)
+static int evaluate_to_int_const_expr(struct expression *expr)
 {
 	expr->ctype = &int_ctype;
+	expr->constexpr_flags |= CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK;
 	return 1;
 }
 
@@ -749,17 +750,17 @@ out:
 }
 
 static struct symbol_op constant_p_op = {
-	.evaluate = evaluate_to_integer,
+	.evaluate = evaluate_to_int_const_expr,
 	.expand = expand_constant_p
 };
 
 static struct symbol_op safe_p_op = {
-	.evaluate = evaluate_to_integer,
+	.evaluate = evaluate_to_int_const_expr,
 	.expand = expand_safe_p
 };
 
 static struct symbol_op warning_op = {
-	.evaluate = evaluate_to_integer,
+	.evaluate = evaluate_to_int_const_expr,
 	.expand = expand_warning
 };
 
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 17/21] symbol: flag builtins constant_p, safe_p and warning as constexprs
Date: Tue, 15 Mar 2016 19:45:22 +0000
Message-ID: <20160315194521.GR1283 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:43:53AM +0100, Nicolai Stange wrote:
> Unconditionally flag the expressions
>   __builtin_constant_p(),
>   __builtin_safe_p(),
>   __builtin_warning()
> as being integer constant expressions.
> 

Fine for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 18/21] evaluate: relax some constant expression rules for pointer expressions ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 18/21] evaluate: relax some constant expression rules for pointer expressions
Date: Mon, 01 Feb 2016 02:44:38 +0000
Message-ID: <87fuxdgne1.fsf () gmail ! com>
--------------------
The official constraints on constant expressions [6.6] are insanely
strict in that they do not allow some constructs commonly used in the
wild.

Relax them by treating
- address constants cast to different pointer type as address constants
  again,
- address constants cast to arithmetic type as arithmetic constant
  expressions
- conditional expressions whose true and false branches both yield
  address constants as address constants,
- and conditional expressions whose condition is an address constant
  as an constant expression to the extent their true and false branches
  allow.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c | 38 ++++++++++++++++++++++++++++++++------
 1 file changed, 32 insertions(+), 6 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 0101e61..ff51d84 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1129,14 +1129,23 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	}
 
 	/*
+	 * A conditional operator yields a particular constant
+	 * expression type only if all of its three subexpressions are
+	 * of that type [6.6(6), 6.6(8)].
+	 * As an extension, relax this restriction by allowing any
+	 * constant expression type for the condition expression.
+	 *
 	 * A conditional operator never yields an address constant
 	 * [6.6(9)].
+	 * However, as an extension, if the condition is any constant
+	 * expression, and the true and false expressions are both
+	 * address constants, mark the result as an address constant.
 	 */
-	expr->constexpr_flags = (expr->conditional->constexpr_flags &
-				(*true)->constexpr_flags &
-				expr->cond_false->constexpr_flags &
-				~CONSTEXPR_FLAG_DECAY_CONSTS_MASK &
-				~CONSTEXPR_FLAG_ADDR_CONST);
+	if (expr->conditional->constexpr_flags &
+		(CONSTEXPR_FLAG_ARITH_CONST_EXPR | CONSTEXPR_FLAG_ADDR_CONST))
+		expr->constexpr_flags = (*true)->constexpr_flags &
+			expr->cond_false->constexpr_flags &
+			~CONSTEXPR_FLAG_DECAY_CONSTS_MASK;
 
 	lclass = classify_type(ltype, &ltype);
 	rclass = classify_type(rtype, &rtype);
@@ -2786,9 +2795,18 @@ static struct symbol *evaluate_cast(struct expression *expr)
 		/*
 		 * Casts of integer literals to pointer type yield
 		 * address constants [6.6(9)].
+		 *
+		 * As an extension, treat address constants cast to a
+		 * different pointer type as address constants again.
+		 *
+		 * As another extension, treat integer constant
+		 * expressions (in contrast to literals) cast to
+		 * pointer type as address constants.
 		 */
 		if (class1 & TYPE_PTR &&
-			(target->constexpr_flags & CONSTEXPR_FLAG_INT_CONST))
+			(target->constexpr_flags &
+				(CONSTEXPR_FLAG_INT_CONST_EXPR |
+					CONSTEXPR_FLAG_ADDR_CONST)))
 			expr->constexpr_flags = CONSTEXPR_FLAG_ADDR_CONST;
 	} else {
 		/*
@@ -2798,6 +2816,14 @@ static struct symbol *evaluate_cast(struct expression *expr)
 		expr->constexpr_flags = target->constexpr_flags &
 			~CONSTEXPR_FLAG_DECAY_CONSTS_MASK &
 			~CONSTEXPR_FLAG_ADDR_CONST;
+
+		/*
+		 * As an extension, treat address constants cast to
+		 * integer type as an arithmetic constant.
+		 */
+		if (target->constexpr_flags & CONSTEXPR_FLAG_ADDR_CONST)
+			expr->constexpr_flags = CONSTEXPR_FLAG_ARITH_CONST_EXPR;
+
 		/*
 		 * Cast to float type -> not an integer constant
 		 * expression [6.6(6)].
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 19/21] expression, evaluate: support compound literals as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 19/21] expression, evaluate: support compound literals as address constants
Date: Mon, 01 Feb 2016 02:45:27 +0000
Message-ID: <87bn81gnco.fsf () gmail ! com>
--------------------
Toplevel compound literals have got static storage duration
[6.5.2.5(6)].

This implies that
1. their addresses are address constants [6.6(9)] and
2. their initializers must contain constant expressions only
   [6.5.2.5(3), 6.7.8(4)] .

Flag the anonymous symbol created at expression parsing time as having
static storage duration if the compound literal occurs at top level
scope.

Flag the whole expression as being an address constant at evaluation
time if its corresponding anonymous symbol had been previously marked
as having static storage duration.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                              |  2 ++
 expression.c                            |  2 ++
 validation/constexpr-compound-literal.c | 19 +++++++++++++++++++
 3 files changed, 23 insertions(+)
 create mode 100644 validation/constexpr-compound-literal.c

diff --git a/evaluate.c b/evaluate.c
index ff51d84..06c360f 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2773,6 +2773,8 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 		addr->ctype = &lazy_ptr_ctype;	/* Lazy eval */
 		addr->symbol = sym;
+		if (sym->ctype.modifiers & MOD_TOPLEVEL)
+			addr->constexpr_flags |= CONSTEXPR_FLAG_ADDR_CONST;
 
 		expr->type = EXPR_PREOP;
 		expr->op = '*';
diff --git a/expression.c b/expression.c
index c3d54fe..f49c8f6 100644
--- a/expression.c
+++ b/expression.c
@@ -714,6 +714,8 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			cast->cast_type = sym;
 			token = expect(token, ')', "at end of cast operator");
 			if (match_op(token, '{')) {
+				if (toplevel(block_scope))
+					sym->ctype.modifiers |= MOD_TOPLEVEL;
 				if (is_force)
 					warning(sym->pos,
 						"[force] in compound literal");
diff --git a/validation/constexpr-compound-literal.c b/validation/constexpr-compound-literal.c
new file mode 100644
index 0000000..d7f21ad
--- /dev/null
+++ b/validation/constexpr-compound-literal.c
@@ -0,0 +1,19 @@
+static int *a = &(int){ 1 };	// OK
+static int *b = &(int){ *a };	// KO
+
+static void foo(void)
+{
+	int *b = &(int){ 1 };		// OK
+	int *c = &(int){ *a };		// OK
+	static int *d = &(int){ 1 };	// KO
+}
+
+/*
+ * check-name: compound literal address constness verification
+ * check-command: sparse -Wconstexpr-not-const $file
+ *
+ * check-error-start
+constexpr-compound-literal.c:2:25: warning: non-constant initializer for static object
+constexpr-compound-literal.c:8:27: warning: non-constant initializer for static object
+ * check-error-end
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 19/21] expression, evaluate: support compound literals as address constants
Date: Tue, 15 Mar 2016 20:02:53 +0000
Message-ID: <20160315200252.GA2417 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:45:27AM +0100, Nicolai Stange wrote:
> Toplevel compound literals have got static storage duration
> [6.5.2.5(6)].
> 
> This implies that
> 1. their addresses are address constants [6.6(9)] and
> 2. their initializers must contain constant expressions only
>    [6.5.2.5(3), 6.7.8(4)] .
> 
> Flag the anonymous symbol created at expression parsing time as having
> static storage duration if the compound literal occurs at top level
> scope.
> 
> Flag the whole expression as being an address constant at evaluation
> time if its corresponding anonymous symbol had been previously marked
> as having static storage duration.
> 

...

> diff --git a/validation/constexpr-compound-literal.c b/validation/constexpr-compound-literal.c
> --- /dev/null
> +++ b/validation/constexpr-compound-literal.c
> @@ -0,0 +1,19 @@
> +static int *a = &(int){ 1 };	// OK
> +static int *b = &(int){ *a };	// KO
> +
> +static void foo(void)
> +{
> +	int *b = &(int){ 1 };		// OK
> +	int *c = &(int){ *a };		// OK
> +	static int *d = &(int){ 1 };	// KO

Humm ... why is this last one different than the corresponding 
top level one @ line 1?

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 2/2] arm64: implement live patching ===

From: Torsten Duwe <duwe () lst ! de>
To: linux-sparse
Subject: [PATCH v3 2/2] arm64: implement live patching
Date: Thu, 11 Aug 2016 16:36:40 +0000
Message-ID: <20160811163640.4CE7F68C44 () newverein ! lst ! de>
--------------------
straightforward on top of FTRACE_WITH_REGS.

Signed-off-by: Torsten Duwe <duwe@suse.de>
---
 arch/arm64/Kconfig                 |  3 +++
 arch/arm64/include/asm/livepatch.h | 37 +++++++++++++++++++++++++++++++++++++
 arch/arm64/kernel/entry-ftrace.S   | 13 +++++++++++++
 3 files changed, 53 insertions(+)
 create mode 100644 arch/arm64/include/asm/livepatch.h

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 36a0e26..3aae199 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -80,6 +80,7 @@ config ARM64
 	select HAVE_GENERIC_DMA_COHERENT
 	select HAVE_HW_BREAKPOINT if PERF_EVENTS
 	select HAVE_IRQ_TIME_ACCOUNTING
+	select HAVE_LIVEPATCH
 	select HAVE_MEMBLOCK
 	select HAVE_MEMBLOCK_NODE_MAP if NUMA
 	select HAVE_PATA_PLATFORM
@@ -1042,4 +1043,6 @@ if CRYPTO
 source "arch/arm64/crypto/Kconfig"
 endif
 
+source "kernel/livepatch/Kconfig"
+
 source "lib/Kconfig"
diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
new file mode 100644
index 0000000..6b9a3d1
--- /dev/null
+++ b/arch/arm64/include/asm/livepatch.h
@@ -0,0 +1,37 @@
+/*
+ * livepatch.h - arm64-specific Kernel Live Patching Core
+ *
+ * Copyright (C) 2016 SUSE
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _ASM_ARM64_LIVEPATCH_H
+#define _ASM_ARM64_LIVEPATCH_H
+
+#include <linux/module.h>
+#include <linux/ftrace.h>
+
+#ifdef CONFIG_LIVEPATCH
+static inline int klp_check_compiler_support(void)
+{
+	return 0;
+}
+
+static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long ip)
+{
+	regs->pc = ip;
+}
+#endif /* CONFIG_LIVEPATCH */
+
+#endif /* _ASM_ARM64_LIVEPATCH_H */
diff --git a/arch/arm64/kernel/entry-ftrace.S b/arch/arm64/kernel/entry-ftrace.S
index 3ebe791..2108f0e 100644
--- a/arch/arm64/kernel/entry-ftrace.S
+++ b/arch/arm64/kernel/entry-ftrace.S
@@ -204,6 +204,9 @@ ENTRY(ftrace_caller)
 	str	x9, [sp, #S_LR]
 	/* The program counter just after the ftrace call site */
 	str	lr, [sp, #S_PC]
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	mov	x19,lr          /* remember old return address */
+#endif
 	/* The stack pointer as it was on ftrace_caller entry... */
 	add	x29, sp, #S_FRAME_SIZE+16	/* ...is also our new FP */
 	str	x29, [sp, #S_SP]
@@ -219,6 +222,16 @@ ftrace_call:
 
 	bl	ftrace_stub
 
+#if defined(CONFIG_LIVEPATCH) && defined(CONFIG_FUNCTION_GRAPH_TRACER)
+	/* Is the trace function a live patcher an has messed with
+	 * the return address?
+	*/
+	ldr	x9, [sp, #S_PC]
+	cmp	x9, x19		/* compare with the value we remembered */
+	/* to not call graph tracer's "call" mechanism twice! */
+	b.ne	ftrace_regs_return
+#endif
+
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 	.global ftrace_graph_call
 ftrace_graph_call:			// ftrace_graph_caller();
-- 
2.6.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 20/21] symbol: do not inherit storage modifiers from base types at examination ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 20/21] symbol: do not inherit storage modifiers from base types at examination
Date: Mon, 01 Feb 2016 02:46:31 +0000
Message-ID: <877fipgnaw.fsf () gmail ! com>
--------------------
Consider the following code snippet:
  static inline foo(int dummy, ...) {}
  static int a = 0;
  static void bar(void)
  {
  	foo(0, a);
  }

Sparse moans:
  test.c:5:9: warning: initializer for static storage duration object
              is not a constant expression

The cause can be tracked down as follows:
The anonymous node created by inline_function() for the variadic
argument will get assigned to its base_type whatever the passed
expression's ctype is. For the special case of a primary expression
referencing a symbol, this ctype is the referenced symbol itself.
Furthermore, inline_function() sets that symbol node's initializer
to this expression.

Now, when the anonymous symbol node is evaluated, its base_type is
handled in examine_base_type(). This applies the base_type's modifiers,
i.e. the referenced symbol's MOD_STATIC in this case, to the inheriting
ctype, that of the anonymous node, itself.
This in turn instructs the evaluation of the symbol's initializer to
allow constant expressions only.

Do not inherit a base_type's storage related modifiers in
examine_base_type().

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 symbol.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/symbol.c b/symbol.c
index 42e6a8f..4766adb 100644
--- a/symbol.c
+++ b/symbol.c
@@ -214,7 +214,8 @@ static struct symbol *examine_base_type(struct symbol *sym)
 	if (!base_type || base_type->type == SYM_PTR)
 		return base_type;
 	sym->ctype.as |= base_type->ctype.as;
-	sym->ctype.modifiers |= base_type->ctype.modifiers & MOD_PTRINHERIT;
+	sym->ctype.modifiers |= base_type->ctype.modifiers & MOD_PTRINHERIT &
+		~MOD_STORAGE;
 	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
 			(struct ptr_list **)&sym->ctype.contexts);
 	if (base_type->type == SYM_NODE) {
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 21/21] evaluation: treat comparsions between types as integer constexpr ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 21/21] evaluation: treat comparsions between types as integer constexpr
Date: Mon, 01 Feb 2016 02:47:16 +0000
Message-ID: <8737tdgn9n.fsf () gmail ! com>
--------------------
The expression parsing code builds an EXPR_COMPARE expression around two
EXPR_TYPE expressions for __builtin_types_compatible_p().

The EXPR_TYPE expressions are tagged as being integer constant expressions
in order to trick the generic comparison evaluation code into flagging the
result as an integer constant expression again.

Avoid this trickery by making evaluate_compare() unconditionally tag a
comparsion between types as an integer constant expression.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                                | 16 +++++++++++-----
 expression.c                              |  5 -----
 validation/constexpr-types-compatible-p.c |  9 +++++++++
 3 files changed, 20 insertions(+), 10 deletions(-)
 create mode 100644 validation/constexpr-types-compatible-p.c

diff --git a/evaluate.c b/evaluate.c
index 06c360f..31ac4e1 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1010,17 +1010,23 @@ static struct symbol *evaluate_compare(struct expression *expr)
 	struct symbol *ctype;
 	const char *typediff;
 
-	expr->constexpr_flags = left->constexpr_flags &
-		right->constexpr_flags & ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK &
-		~CONSTEXPR_FLAG_ADDR_CONST;
-
 	/* Type types? */
-	if (is_type_type(ltype) && is_type_type(rtype))
+	if (is_type_type(ltype) && is_type_type(rtype)) {
+		/*
+		 * __builtin_types_compatible_p() yields an integer
+		 * constant expression
+		 */
+		expr->constexpr_flags = CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK;
 		goto OK;
+	}
 
 	if (is_safe_type(left->ctype) || is_safe_type(right->ctype))
 		warning(expr->pos, "testing a 'safe expression'");
 
+	expr->constexpr_flags = left->constexpr_flags &
+		right->constexpr_flags & ~CONSTEXPR_FLAG_DECAY_CONSTS_MASK &
+		~CONSTEXPR_FLAG_ADDR_CONST;
+
 	/* number on number */
 	if (lclass & rclass & TYPE_NUM) {
 		ctype = usual_conversions(expr->op, expr->left, expr->right,
diff --git a/expression.c b/expression.c
index f49c8f6..4285cc8 100644
--- a/expression.c
+++ b/expression.c
@@ -131,8 +131,6 @@ static struct token *parse_type(struct token *token, struct expression **tree)
 {
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
-	(*tree)->constexpr_flags =
-		CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK; /* sic */
 	token = typename(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
@@ -461,9 +459,6 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		}
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
-			/* sic */
-			expr->constexpr_flags =
-				CONSTEXPR_FLAG_INT_CONST_EXPR_SET_MASK;
 			token = typename(token->next, &expr->symbol, NULL);
 			token = expect(token, ']', "in type expression");
 			break;
diff --git a/validation/constexpr-types-compatible-p.c b/validation/constexpr-types-compatible-p.c
new file mode 100644
index 0000000..78c37b4
--- /dev/null
+++ b/validation/constexpr-types-compatible-p.c
@@ -0,0 +1,9 @@
+static int a[] = {[__builtin_types_compatible_p(int, int)] = 0};
+
+/*
+ * check-name: __builtin_types_compatible_p() constness verification.
+ *
+ * check-error-start
+ * check-error-end
+ */
+
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 21/21] evaluation: treat comparsions between types as integer constexpr
Date: Tue, 15 Mar 2016 20:34:29 +0000
Message-ID: <20160315203428.GC2417 () macpro ! local>
--------------------
On Mon, Feb 01, 2016 at 03:47:16AM +0100, Nicolai Stange wrote:
> The expression parsing code builds an EXPR_COMPARE expression around two
> EXPR_TYPE expressions for __builtin_types_compatible_p().
> 
> The EXPR_TYPE expressions are tagged as being integer constant expressions
> in order to trick the generic comparison evaluation code into flagging the
> result as an integer constant expression again.
> 
> Avoid this trickery by making evaluate_compare() unconditionally tag a
> comparsion between types as an integer constant expression.

Fine for me.

Feel free to add
  Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3] fix typing error in compound assignment ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3] fix typing error in compound assignment
Date: Sat, 10 Dec 2016 22:43:17 +0000
Message-ID: <20161210224317.40672-1-luc.vanoostenryck () gmail ! com>
--------------------
A compound assignment like, for example:
	x /= a;
should have the same effect as the operation followed by the
assignment except that the left side should only be evaluated
once. So the statement above (assuming 'x' free of side-effects)
should have the same effect as:
	x = x / a;

In particular, the usual conversions should applied. So, if the
type of 'x' and 'a' is, respectively, 'unsigned int' (32 bit) and
'long' (64 bit), the statement above should be equivalent to:
	x = (unsigned int) ((long) x / a);

But what is really done currently is something like:
	x = x / (unsigned int) a;
In other words, the right-hand side is casted to the same type as the
lhs and the operation is always done with this type, neglecting the
usual conversions and thus forcing the operation to always be done
with the lhs type, here 'unsigned int' instead of 'long'.
For example, with the values:
        unsigned int x = 1;
        long a = -1;

We have:
	x = 1 / (unsigned int) (-1L);
	x = 1 / 0xffffffff;
	x = 0;
instead of the expected:
	x = (unsigned int) ((long)1 / -1L);
	x = (unsigned int) (-1L);
	x = 0xffffffff;

The patch fix this by first calculating the type corresponding to
the usual conversion and then casting the right-hand side to this
type, which is fine since it's a rvalue anyway.
Later steps will then use the rhs type when doing the operation.
On the example above, the cast will be a no-op and the operation will
be done with the correct type:
	x = x / (long) a;
which, at linearization, will become:
	x = (unsigned int) ((long) x / (long) a);
and with unneeded casts optimized away:
	x = (unsigned int) ((long) x / a);
Which will give us the expected result.

If the types where in the other order, the result will also be done
with the correct type:
	long x;
	unsigned int a;
	...
	x /= a;
will become:
	x = x / (long) a;
and, at linearization:
	x = (long) ((long) x / (long) a);
and with unneeded casts optimized away:
	x = (x / (long) a);

Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Ramsay Jones <ramsay@ramsayjones.plus.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---

Changes since v2:
 - no change in the patch itself
 - fix left-right mixup in the description, thanks to Ramsay Jones.
 - fix the test case which passed on sparse-next which doesn't yet
   have the contains/excludes patch *sigh*

Changes since v1:
 - no change in the patch itself
 - change the description with a more interesting example, thanks
   to Alexander Viro (a division instead of an addition where
   2-complement arithmetic which gave the same end result anyway).
 - adapt the test case to match the patch description.


 evaluate.c                        |  5 ++++-
 linearize.c                       | 10 ++++++----
 validation/compound-assign-type.c | 15 +++++++++++++++
 3 files changed, 25 insertions(+), 5 deletions(-)
 create mode 100644 validation/compound-assign-type.c

diff --git a/evaluate.c b/evaluate.c
index e350c0c0..0ea3e866 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1258,7 +1258,7 @@ static int evaluate_assign_op(struct expression *expr)
 			if (!restricted_value(expr->right, t))
 				return 1;
 		} else if (!(sclass & TYPE_RESTRICT))
-			goto Cast;
+			goto usual;
 		/* source and target would better be identical restricted */
 		if (t == s)
 			return 1;
@@ -1281,6 +1281,9 @@ static int evaluate_assign_op(struct expression *expr)
 	expression_error(expr, "invalid assignment");
 	return 0;
 
+usual:
+	target = usual_conversions(op, expr->left, expr->right,
+				tclass, sclass, target, source);
 Cast:
 	expr->right = cast_to(expr->right, target);
 	return 1;
diff --git a/linearize.c b/linearize.c
index cb252282..3f1b0d3c 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1156,6 +1156,7 @@ static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *e
 	struct access_data ad = { NULL, };
 	struct expression *target = expr->left;
 	struct expression *src = expr->right;
+	struct symbol *ctype;
 	pseudo_t value;
 
 	value = linearize_expression(ep, src);
@@ -1181,10 +1182,11 @@ static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *e
 		if (!src)
 			return VOID;
 
-		oldvalue = cast_pseudo(ep, oldvalue, src->ctype, expr->ctype);
-		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], src->ctype);
-		dst = add_binary_op(ep, src->ctype, opcode, oldvalue, value);
-		value = cast_pseudo(ep, dst, expr->ctype, src->ctype);
+		ctype = src->ctype;
+		oldvalue = cast_pseudo(ep, oldvalue, target->ctype, ctype);
+		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], ctype);
+		dst = add_binary_op(ep, ctype, opcode, oldvalue, value);
+		value = cast_pseudo(ep, dst, ctype, expr->ctype);
 	}
 	value = linearize_store_gen(ep, value, &ad);
 	finish_address_gen(ep, &ad);
diff --git a/validation/compound-assign-type.c b/validation/compound-assign-type.c
new file mode 100644
index 00000000..450fa26d
--- /dev/null
+++ b/validation/compound-assign-type.c
@@ -0,0 +1,15 @@
+static unsigned int foo(unsigned int x, long a)
+{
+	x /= a;
+	return x;
+}
+
+/*
+ * check-name: compound-assign-type
+ * check-command: test-linearize -m64 $file
+ * check-output-ignore
+ *
+ * check-output-excludes: divu\\.32
+ * check-output-contains: divs\\.64
+ * check-output-contains: scast\\.32
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Do not drop 'nocast' modifier when taking the address. ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] Do not drop 'nocast' modifier when taking the address.
Date: Tue, 05 Jan 2016 16:25:53 +0000
Message-ID: <20160105162552.GA3478 () macpro ! local>
--------------------
With the following code:
	typedef unsigned long __nocast cputime_t;

	void task_cputime_adjusted(cputime_t *);

	void current_task_runtime_100ns(void)
	{
	        cputime_t utime;

	        task_cputime_adjusted(&utime);
	}

sparse emits the following message:
	x.c:16:32: warning: incorrect type in argument 1 (different modifiers)
	x.c:16:32:    expected unsigned long [nocast] [usertype] *<noident>
	x.c:16:32:    got unsigned long *<noident>
	x.c:16:32: warning: implicit cast to nocast type

In other words, when taking the address of 'utime', sparse drops the 'nocast'
modifier and then complains that task_cputime_adjusted() is not given a
'nocast' pointer as expected ...

This feels wrong to me.

The proposed fix is to simply not dropping the 'nocast' modifier when
taking the address, like done for a normal type qualifier.
This gives very reasonable behaviour for all the test cases I could
think of:
	- taking the address or dereferencing doesn't drop the nocast
	- arithmetic operations on nocast give a nocast result.
	- implicit to/from cast is OK only if the base type are the same
	- implicit to/from pointer cast is OK only if the base type are the same

This still gives a "leaky" semantic: the nocast modifier can be lost via
an implicit cast to a non-qualified value.

Explicit cast to or from nocast values doesn't give any warning, maybe
it's OK, maybe it's not but it's orthogonal to the current issue.

Is this the wanted semantic for the nocast modifier?

Reported-by: Roman Kagan <rkagan@virtuozzo.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h            |   2 +-
 validation/nocast.c | 197 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 198 insertions(+), 1 deletion(-)
 create mode 100644 validation/nocast.c

diff --git a/symbol.h b/symbol.h
index ccb5dcb9..9b3f1604 100644
--- a/symbol.h
+++ b/symbol.h
@@ -247,7 +247,7 @@ struct symbol {
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG_ALL)
 #define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
 	MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
-#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE | MOD_NORETURN)
+#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE | MOD_NORETURN | MOD_NOCAST)
 
 
 /* Current parsing/evaluation function */
diff --git a/validation/nocast.c b/validation/nocast.c
new file mode 100644
index 00000000..c28676a3
--- /dev/null
+++ b/validation/nocast.c
@@ -0,0 +1,197 @@
+#define	__nocast	__attribute__((nocast))
+typedef unsigned long __nocast ulong_nc_t;
+
+extern void use_val(ulong_nc_t);
+extern void use_ptr(ulong_nc_t *);
+
+/* use address */
+static void good_use_address(void)
+{
+	ulong_nc_t t;
+
+	use_ptr(&t);
+}
+
+static ulong_nc_t *good_ret_address(void)
+{
+	static ulong_nc_t t;
+
+	return &t;
+}
+
+static ulong_nc_t good_deref(ulong_nc_t *t)
+{
+	return *t;
+}
+
+/* assign value */
+static ulong_nc_t t;
+static ulong_nc_t good_assign_self = t;
+static unsigned long good_assign_sametype = t;
+
+/* assign pointer */
+static ulong_nc_t *good_ptr = &t;
+static ulong_nc_t *bad_ptr_to = 1UL;
+static unsigned long *bad_ptr_from = &t;
+
+/* arithmetic operation */
+static ulong_nc_t good_arith(ulong_nc_t t, unsigned int n)
+{
+	return t + n;
+}
+
+/* implicit cast to other types */
+static unsigned long good_ret_samecast(ulong_nc_t t)
+{
+	return t;
+}
+static unsigned long long bad_ret_biggercast(ulong_nc_t t)
+{
+	return t;
+}
+static long bad_ret_signcast(ulong_nc_t t)
+{
+	return t;
+}
+static short bad_ret_smallercast(ulong_nc_t t)
+{
+	return t;
+}
+
+static void assign_val(ulong_nc_t t)
+{
+	ulong_nc_t good_c = t;
+	unsigned long good_ul = t;
+	unsigned long long bad_ull = t;
+	long bad_l = t;
+	short bad_i = t;
+}
+
+static void assign_via_ptr(ulong_nc_t *t)
+{
+	ulong_nc_t good_c = *t;
+	unsigned long good_ul = *t;
+	unsigned long long bad_ull = *t;
+	long bad_l = *t;
+	short bad_i = *t;
+}
+
+static void assign_ptr(ulong_nc_t *t)
+{
+	ulong_nc_t *good_same_type = t;
+	unsigned long *bad_mod = t;
+	unsigned long long __nocast *bad_size = t;
+	short __nocast *bad_i = t;
+	long __nocast *bad_l = t;
+}
+
+/* implicit cast to nocast */
+static void implicit_assign_to(void)
+{
+	ulong_nc_t t;
+	unsigned long ul = 1;
+	unsigned short us = 1;
+	unsigned long long ull = 1;
+	long l = 1;
+
+	t = ul;		/* implicit to nocast from same type: OK? */
+	t = us;
+	t = ull;
+	t = l;
+}
+
+static void bad_implicit_arg_to(void)
+{
+	unsigned long ul = 1;
+	unsigned short us = 1;
+	unsigned long long ull = 1;
+	long l = 1;
+
+	use_val(ul);	/* implicit to nocast from same type: OK? */
+	use_val(us);
+	use_val(ull);
+	use_val(l);
+}
+
+/* implicit cast from nocast */
+static unsigned long good_implicit_ret_ul(ulong_nc_t t)
+{
+	return t;	/* implicit to nocast from same type: OK? */
+}
+
+static unsigned short bad_implicit_ret_us(ulong_nc_t t)
+{
+	return t;
+}
+
+static unsigned long long bad_implicit_ret_ull(ulong_nc_t t)
+{
+	return t;
+}
+
+static long bad_implicit_ret_l(ulong_nc_t t)
+{
+	return t;
+}
+
+/* FIXME: explicit cast: should we complain? */
+static ulong_nc_t good_samecast(ulong_nc_t v)
+{
+	return (ulong_nc_t) v;
+}
+
+static ulong_nc_t bad_tocast(unsigned long v)
+{
+	return (ulong_nc_t) v;
+}
+
+static unsigned long bad_fromcast(ulong_nc_t v)
+{
+	return (unsigned long) v;
+}
+
+/*
+ * check-name: nocast.c
+ *
+ * check-error-start
+nocast.c:34:33: warning: incorrect type in initializer (different base types)
+nocast.c:34:33:    expected unsigned long [nocast] [usertype] *static [toplevel] bad_ptr_to
+nocast.c:34:33:    got unsigned long
+nocast.c:34:33: warning: implicit cast to nocast type
+nocast.c:35:39: warning: incorrect type in initializer (different modifiers)
+nocast.c:35:39:    expected unsigned long *static [toplevel] bad_ptr_from
+nocast.c:35:39:    got unsigned long static [nocast] [toplevel] *<noident>
+nocast.c:35:39: warning: implicit cast from nocast type
+nocast.c:50:16: warning: implicit cast from nocast type
+nocast.c:54:16: warning: implicit cast from nocast type
+nocast.c:58:16: warning: implicit cast from nocast type
+nocast.c:65:38: warning: implicit cast from nocast type
+nocast.c:66:22: warning: implicit cast from nocast type
+nocast.c:67:23: warning: implicit cast from nocast type
+nocast.c:74:38: warning: implicit cast from nocast type
+nocast.c:75:22: warning: implicit cast from nocast type
+nocast.c:76:23: warning: implicit cast from nocast type
+nocast.c:82:34: warning: incorrect type in initializer (different modifiers)
+nocast.c:82:34:    expected unsigned long *bad_mod
+nocast.c:82:34:    got unsigned long [nocast] [usertype] *t
+nocast.c:82:34: warning: implicit cast from nocast type
+nocast.c:83:49: warning: incorrect type in initializer (different type sizes)
+nocast.c:83:49:    expected unsigned long long [nocast] *bad_size
+nocast.c:83:49:    got unsigned long [nocast] [usertype] *t
+nocast.c:83:49: warning: implicit cast to/from nocast type
+nocast.c:84:33: warning: incorrect type in initializer (different type sizes)
+nocast.c:84:33:    expected short [nocast] *bad_i
+nocast.c:84:33:    got unsigned long [nocast] [usertype] *t
+nocast.c:84:33: warning: implicit cast to/from nocast type
+nocast.c:85:32: warning: implicit cast to/from nocast type
+nocast.c:98:13: warning: implicit cast to nocast type
+nocast.c:99:13: warning: implicit cast to nocast type
+nocast.c:100:13: warning: implicit cast to nocast type
+nocast.c:111:17: warning: implicit cast to nocast type
+nocast.c:112:17: warning: implicit cast to nocast type
+nocast.c:113:17: warning: implicit cast to nocast type
+nocast.c:124:16: warning: implicit cast from nocast type
+nocast.c:129:16: warning: implicit cast from nocast type
+nocast.c:134:16: warning: implicit cast from nocast type
+ * check-error-end
+ */
-- 
2.6.4


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] Do not drop 'nocast' modifier when taking the address.
Date: Tue, 05 Jan 2016 16:25:53 +0000
Message-ID: <20160105162552.GA3478 () macpro ! local>
--------------------
With the following code:
	typedef unsigned long __nocast cputime_t;

	void task_cputime_adjusted(cputime_t *);

	void current_task_runtime_100ns(void)
	{
	        cputime_t utime;

	        task_cputime_adjusted(&utime);
	}

sparse emits the following message:
	x.c:16:32: warning: incorrect type in argument 1 (different modifiers)
	x.c:16:32:    expected unsigned long [nocast] [usertype] *<noident>
	x.c:16:32:    got unsigned long *<noident>
	x.c:16:32: warning: implicit cast to nocast type

In other words, when taking the address of 'utime', sparse drops the 'nocast'
modifier and then complains that task_cputime_adjusted() is not given a
'nocast' pointer as expected ...

This feels wrong to me.

The proposed fix is to simply not dropping the 'nocast' modifier when
taking the address, like done for a normal type qualifier.
This gives very reasonable behaviour for all the test cases I could
think of:
	- taking the address or dereferencing doesn't drop the nocast
	- arithmetic operations on nocast give a nocast result.
	- implicit to/from cast is OK only if the base type are the same
	- implicit to/from pointer cast is OK only if the base type are the same

This still gives a "leaky" semantic: the nocast modifier can be lost via
an implicit cast to a non-qualified value.

Explicit cast to or from nocast values doesn't give any warning, maybe
it's OK, maybe it's not but it's orthogonal to the current issue.

Is this the wanted semantic for the nocast modifier?

Reported-by: Roman Kagan <rkagan@virtuozzo.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h            |   2 +-
 validation/nocast.c | 197 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 198 insertions(+), 1 deletion(-)
 create mode 100644 validation/nocast.c

diff --git a/symbol.h b/symbol.h
index ccb5dcb9..9b3f1604 100644
--- a/symbol.h
+++ b/symbol.h
@@ -247,7 +247,7 @@ struct symbol {
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG_ALL)
 #define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
 	MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
-#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE | MOD_NORETURN)
+#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE | MOD_NORETURN | MOD_NOCAST)
 
 
 /* Current parsing/evaluation function */
diff --git a/validation/nocast.c b/validation/nocast.c
new file mode 100644
index 00000000..c28676a3
--- /dev/null
+++ b/validation/nocast.c
@@ -0,0 +1,197 @@
+#define	__nocast	__attribute__((nocast))
+typedef unsigned long __nocast ulong_nc_t;
+
+extern void use_val(ulong_nc_t);
+extern void use_ptr(ulong_nc_t *);
+
+/* use address */
+static void good_use_address(void)
+{
+	ulong_nc_t t;
+
+	use_ptr(&t);
+}
+
+static ulong_nc_t *good_ret_address(void)
+{
+	static ulong_nc_t t;
+
+	return &t;
+}
+
+static ulong_nc_t good_deref(ulong_nc_t *t)
+{
+	return *t;
+}
+
+/* assign value */
+static ulong_nc_t t;
+static ulong_nc_t good_assign_self = t;
+static unsigned long good_assign_sametype = t;
+
+/* assign pointer */
+static ulong_nc_t *good_ptr = &t;
+static ulong_nc_t *bad_ptr_to = 1UL;
+static unsigned long *bad_ptr_from = &t;
+
+/* arithmetic operation */
+static ulong_nc_t good_arith(ulong_nc_t t, unsigned int n)
+{
+	return t + n;
+}
+
+/* implicit cast to other types */
+static unsigned long good_ret_samecast(ulong_nc_t t)
+{
+	return t;
+}
+static unsigned long long bad_ret_biggercast(ulong_nc_t t)
+{
+	return t;
+}
+static long bad_ret_signcast(ulong_nc_t t)
+{
+	return t;
+}
+static short bad_ret_smallercast(ulong_nc_t t)
+{
+	return t;
+}
+
+static void assign_val(ulong_nc_t t)
+{
+	ulong_nc_t good_c = t;
+	unsigned long good_ul = t;
+	unsigned long long bad_ull = t;
+	long bad_l = t;
+	short bad_i = t;
+}
+
+static void assign_via_ptr(ulong_nc_t *t)
+{
+	ulong_nc_t good_c = *t;
+	unsigned long good_ul = *t;
+	unsigned long long bad_ull = *t;
+	long bad_l = *t;
+	short bad_i = *t;
+}
+
+static void assign_ptr(ulong_nc_t *t)
+{
+	ulong_nc_t *good_same_type = t;
+	unsigned long *bad_mod = t;
+	unsigned long long __nocast *bad_size = t;
+	short __nocast *bad_i = t;
+	long __nocast *bad_l = t;
+}
+
+/* implicit cast to nocast */
+static void implicit_assign_to(void)
+{
+	ulong_nc_t t;
+	unsigned long ul = 1;
+	unsigned short us = 1;
+	unsigned long long ull = 1;
+	long l = 1;
+
+	t = ul;		/* implicit to nocast from same type: OK? */
+	t = us;
+	t = ull;
+	t = l;
+}
+
+static void bad_implicit_arg_to(void)
+{
+	unsigned long ul = 1;
+	unsigned short us = 1;
+	unsigned long long ull = 1;
+	long l = 1;
+
+	use_val(ul);	/* implicit to nocast from same type: OK? */
+	use_val(us);
+	use_val(ull);
+	use_val(l);
+}
+
+/* implicit cast from nocast */
+static unsigned long good_implicit_ret_ul(ulong_nc_t t)
+{
+	return t;	/* implicit to nocast from same type: OK? */
+}
+
+static unsigned short bad_implicit_ret_us(ulong_nc_t t)
+{
+	return t;
+}
+
+static unsigned long long bad_implicit_ret_ull(ulong_nc_t t)
+{
+	return t;
+}
+
+static long bad_implicit_ret_l(ulong_nc_t t)
+{
+	return t;
+}
+
+/* FIXME: explicit cast: should we complain? */
+static ulong_nc_t good_samecast(ulong_nc_t v)
+{
+	return (ulong_nc_t) v;
+}
+
+static ulong_nc_t bad_tocast(unsigned long v)
+{
+	return (ulong_nc_t) v;
+}
+
+static unsigned long bad_fromcast(ulong_nc_t v)
+{
+	return (unsigned long) v;
+}
+
+/*
+ * check-name: nocast.c
+ *
+ * check-error-start
+nocast.c:34:33: warning: incorrect type in initializer (different base types)
+nocast.c:34:33:    expected unsigned long [nocast] [usertype] *static [toplevel] bad_ptr_to
+nocast.c:34:33:    got unsigned long
+nocast.c:34:33: warning: implicit cast to nocast type
+nocast.c:35:39: warning: incorrect type in initializer (different modifiers)
+nocast.c:35:39:    expected unsigned long *static [toplevel] bad_ptr_from
+nocast.c:35:39:    got unsigned long static [nocast] [toplevel] *<noident>
+nocast.c:35:39: warning: implicit cast from nocast type
+nocast.c:50:16: warning: implicit cast from nocast type
+nocast.c:54:16: warning: implicit cast from nocast type
+nocast.c:58:16: warning: implicit cast from nocast type
+nocast.c:65:38: warning: implicit cast from nocast type
+nocast.c:66:22: warning: implicit cast from nocast type
+nocast.c:67:23: warning: implicit cast from nocast type
+nocast.c:74:38: warning: implicit cast from nocast type
+nocast.c:75:22: warning: implicit cast from nocast type
+nocast.c:76:23: warning: implicit cast from nocast type
+nocast.c:82:34: warning: incorrect type in initializer (different modifiers)
+nocast.c:82:34:    expected unsigned long *bad_mod
+nocast.c:82:34:    got unsigned long [nocast] [usertype] *t
+nocast.c:82:34: warning: implicit cast from nocast type
+nocast.c:83:49: warning: incorrect type in initializer (different type sizes)
+nocast.c:83:49:    expected unsigned long long [nocast] *bad_size
+nocast.c:83:49:    got unsigned long [nocast] [usertype] *t
+nocast.c:83:49: warning: implicit cast to/from nocast type
+nocast.c:84:33: warning: incorrect type in initializer (different type sizes)
+nocast.c:84:33:    expected short [nocast] *bad_i
+nocast.c:84:33:    got unsigned long [nocast] [usertype] *t
+nocast.c:84:33: warning: implicit cast to/from nocast type
+nocast.c:85:32: warning: implicit cast to/from nocast type
+nocast.c:98:13: warning: implicit cast to nocast type
+nocast.c:99:13: warning: implicit cast to nocast type
+nocast.c:100:13: warning: implicit cast to nocast type
+nocast.c:111:17: warning: implicit cast to nocast type
+nocast.c:112:17: warning: implicit cast to nocast type
+nocast.c:113:17: warning: implicit cast to nocast type
+nocast.c:124:16: warning: implicit cast from nocast type
+nocast.c:129:16: warning: implicit cast from nocast type
+nocast.c:134:16: warning: implicit cast from nocast type
+ * check-error-end
+ */
-- 
2.6.4


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Do not drop 'nocast' modifier when taking the address.
Date: Wed, 03 Feb 2016 03:43:58 +0000
Message-ID: <20160203034357.GA3332 () macbook ! lan>
--------------------
On Wed, Feb 03, 2016 at 04:25:44AM +0800, Christopher Li wrote:
> On Wed, Jan 6, 2016 at 12:25 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > With the following code:
> >         typedef unsigned long __nocast cputime_t;
> >
> >         void task_cputime_adjusted(cputime_t *);
> >
> >         void current_task_runtime_100ns(void)
> >         {
> >                 cputime_t utime;
> >
> >                 task_cputime_adjusted(&utime);
> >         }
> >
> > sparse emits the following message:
> >         x.c:16:32: warning: incorrect type in argument 1 (different modifiers)
> >         x.c:16:32:    expected unsigned long [nocast] [usertype] *<noident>
> >         x.c:16:32:    got unsigned long *<noident>
> >         x.c:16:32: warning: implicit cast to nocast type
> >
> > In other words, when taking the address of 'utime', sparse drops the 'nocast'
> > modifier and then complains that task_cputime_adjusted() is not given a
> > 'nocast' pointer as expected ...
> 
> I think there is a bug some where else. In the above example,
> "cputime_t *" and "&utime" should have the same type regardless
> pointer inherent the nocast attribute or not. I haven't fully understand
> where the nocast attribute get dropped.

The nocast mod is dropped and lost in the function create_pointer().
In the example above, "cputime_t *" has type :
	unsigned long [nocast] [usertype] *
while &utime is just:
	unsigned long *

So, for sparse and its extended notion of type, the type we get when
taking the address of a [variable of some] type X is not the same as
directly using a pointer to the type X.
Which is very fine, just that MOD_NOCAST is dropped while the example
shows that it should not.
OTOH, MOD_STORAGE is kept but I think should be dropped; but that's
another story.


Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Do not drop 'nocast' modifier when taking the address.
Date: Wed, 03 Feb 2016 09:15:56 +0000
Message-ID: <20160203091555.GA3563 () macbook ! lan>
--------------------
On Wed, Feb 03, 2016 at 12:09:16PM +0800, Christopher Li wrote:
> On Wed, Feb 3, 2016 at 11:43 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> pped.
> >
> > The nocast mod is dropped and lost in the function create_pointer().
> > In the example above, "cputime_t *" has type :
> >         unsigned long [nocast] [usertype] *
> > while &utime is just:
> >         unsigned long *
> 
> That is my point. Why does "&utime" get drop but "cputime_t *" does not?
> They both are pointer of a base type. They both create pointers.

Well with "cputime_t *" you got the pointer directly, by its own declaration;
with "&utime" you really _create_ one with the "&"/"addressof" operator.

The function "create_pointer()" is only called when evaluating an expression
using the addressof operator or when when an array of a function is degenerated
into a pointer.

> It seems to me the bug is sparse not treating this two case consistently.
> 
> > So, for sparse and its extended notion of type, the type we get when
> > taking the address of a [variable of some] type X is not the same as
> > directly using a pointer to the type X.
> 
> In C language type system,  these two should be the same type. It is a
> bug in sparse if they are not. I would rather get that bug fixed.

They _have_ the same type if we limit ourselves to the pure C type system,
but they differ once we look also at the sparse & gcc extension to the
type system, like the nocast attribute here.
 
Now, whether they should be the same or not is a question of defining the
semantic of the addressof operator on sparse's type extension.

> > Which is very fine, just that MOD_NOCAST is dropped while the example
> > shows that it should not.
> 
> I think that is a separate issue weather MOD_NOCAST should be inherent
> from pointer base type.

I'm not sure to understand you here.

> Same with MOD_STORAGE.
> 
> Chris

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Do not drop 'nocast' modifier when taking the address.
Date: Mon, 22 Feb 2016 18:41:34 +0000
Message-ID: <CANeU7QkYdQrXpS8+bCNE3nXyW556_63-PUGJDFQb56nX-DcFpg () mail ! gmail ! com>
--------------------
On Wed, Feb 3, 2016 at 5:15 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Well with "cputime_t *" you got the pointer directly, by its own declaration;
> with "&utime" you really _create_ one with the "&"/"addressof" operator.
>
> The function "create_pointer()" is only called when evaluating an expression
> using the addressof operator or when when an array of a function is degenerated
> into a pointer.

Yes, I take a closer look. My previous understanding of how the MOD_PTRINHERIT
works was wrong.

Now I see the pointer is created differently. In the parsing stage, it is
created by the "pointer" function. In the evaluation stage it is created
by the "create_pointer" function. The "pointer" function has no treatment for
MOD_PTRINHERIT at all.

Ideally it would be nice to unify the pointer create some how. It is
easier to have
inconsistent modifier other than MOD_NOCAST. As a simply fix, your patch is
fine. Applied.

>
> They _have_ the same type if we limit ourselves to the pure C type system,
> but they differ once we look also at the sparse & gcc extension to the
> type system, like the nocast attribute here.
>
> Now, whether they should be the same or not is a question of defining the
> semantic of the addressof operator on sparse's type extension.

I think sparse should treat them with same semantic. It does not make sense
if they are not the same.

Thanks.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix context checking detection of a reversed lock-pair within a basic block ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Fix context checking detection of a reversed lock-pair within a basic block
Date: Tue, 05 Jan 2016 13:23:46 +0000
Message-ID: <20160105132345.GA1044 () macpro ! local>
--------------------
On Tue, Nov 17, 2015 at 12:17:58PM -0500, David Holmer wrote:
> This commit adds a new validation test case with a simple lock context
> issue that was not previously caught by sparse. This test case is a simple
> "reversed" lock pair (unlock/lock instead of lock/unlock):
> +static void warn_reverse(void)
> +{
> +    r();
> +    a();
> +}
> 
> Previously, sparse would not flag this context imbalance because it happens
> WITHIN a single basic block and imbalance checking was only done at the
> boundaries of basic blocks. In this case, the lock following the unlock
> results in a net context change of zero for this basic block, so checking
> only at the boundaries of basic blocks is insufficient.
 
Indeed, nice catch.

I have a few remarks and suggestions here under.

> Primarily, this commit moves the checking for "unexpected unlock" inside
> the context_increase function where it can correctly detect the new test
> case as well as all other existing test cases.
> 
> In order to accommodate the primary change, some additional ancillary
> changes are made:
> * The entry point is added as an argument to context_increase() so that it
>   can be passed to imbalance() if needed.

This is not needed because a basic block's entry point is available as bb->ep.

> * The two arguments entry and exit are removed from imbalance() as they are
>   currently unused in the function and it simplifies calling it in the new
>   location (all call sites of imbalance() are changed).

Better put this is a separate patch.

> * A prototype for imbalance() is added at top of the file as a call is now
>   made before the function is defined.
> 
> Signed-off-by: David Holmer <odinguru@gmail.com>
> ---
>  sparse.c             | 19 ++++++++++++-------
>  validation/context.c |  8 ++++++++
>  2 files changed, 20 insertions(+), 7 deletions(-)
> 
> diff --git a/sparse.c b/sparse.c
> index 6b3324c..85b92e9 100644
> --- a/sparse.c
> +++ b/sparse.c
> @@ -40,7 +40,9 @@
>  #include "expression.h"
>  #include "linearize.h"
>  
> -static int context_increase(struct basic_block *bb, int entry)
> +static int imbalance(struct entrypoint *ep, struct basic_block *bb, const char *why);
> +
> +static int context_increase(struct entrypoint *ep, struct basic_block *bb, int entry)
>  {
>  	int sum = 0;
>  	struct instruction *insn;
> @@ -61,11 +63,15 @@ static int context_increase(struct basic_block *bb, int entry)
>  			continue;
>  		}
>  		sum += val;
> +		if (entry + sum < 0) {
> +			imbalance(ep, bb, "unexpected unlock");
> +			return sum;

This early return is wrong to me.
We want to check the other instructions too and have the correct value for
the basic block's net context change.

> @@ -103,12 +109,11 @@ static int check_bb_context(struct entrypoint *ep, struct basic_block *bb, int e
>  
>  	/* Now that's not good.. */
>  	if (bb->context >= 0)
> -		return imbalance(ep, bb, entry, bb->context, "different lock contexts for basic block");
> +		return imbalance(ep, bb, "different lock contexts for basic block");
>  
>  	bb->context = entry;
> -	entry += context_increase(bb, entry);
> -	if (entry < 0)
> -		return imbalance(ep, bb, entry, exit, "unexpected unlock");
> +	entry += context_increase(ep, bb, entry);
> +	if (entry < 0) return -1;

1) Better leave the 'if' and the 'return' on separate lines, like they were.
2) Without the early return here above, the return -1 is nor needed, nor desirable.
   What I would suggest is:
   - to leave the call to imbalance() here; it give a warning message about a
     *basic block* imbalance (non-zero net context change).
   - add another small helper to give a warning message about other kind
     of context errors, using the position on the offending *instruction*,
     Use this one in your new check in context_increase(), maybe using a message
     stating more explicitly that we're trying to unlock a lock that is not held.


> diff --git a/validation/context.c b/validation/context.c
> index 33b70b8..c0a5357 100644
> --- a/validation/context.c
> +++ b/validation/context.c
> @@ -314,6 +314,13 @@ static void warn_cond_lock1(void)
>          condition2 = 1; /* do stuff */
>      r();
>  }
> +
> +static void warn_reverse(void)
> +{
> +    r();
> +    a();
> +}
> +

It would be nice to also add a case for when the function is annotated
with context entry and exit values; something like
	+static void warn_reverse2(void)__attribute__((context(0,0)))
	+{
	+    r();
	+    a();
	+}
	+
	+static void good_reverse2(void)__attribute__((context(1,1)))
	+{
	+    r();
	+    a();
	+}
	+


Yours,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix size calculation of unsized bool array ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] Fix size calculation of unsized bool array
Date: Thu, 07 Jan 2016 01:47:09 +0000
Message-ID: <1452131229-29756-1-git-send-email-luc.vanoostenryck () gmail ! com>
--------------------
This stops sparse from issuing the error message
	"error: cannot size expression"
for code like:
	static _Bool boolarray[] = {
		0,
		1,
	};
	static int n = sizeof(boolarray);

The fix consists of using array_element_offset() for calculating
the size of unsized arrays, like it is done elsewhere for sized ones.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c                |  2 +-
 validation/bool-array.c | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 48 insertions(+), 1 deletion(-)
 create mode 100644 validation/bool-array.c

diff --git a/symbol.c b/symbol.c
index 0ceff628..92a7a625 100644
--- a/symbol.c
+++ b/symbol.c
@@ -393,7 +393,7 @@ static struct symbol * examine_node_type(struct symbol *sym)
 			int count = count_array_initializer(node_type, initializer);
 
 			if (node_type && node_type->bit_size >= 0)
-				bit_size = node_type->bit_size * count;
+				bit_size = array_element_offset(node_type->bit_size, count);
 		}
 	}
 	
diff --git a/validation/bool-array.c b/validation/bool-array.c
new file mode 100644
index 00000000..6c4c8723
--- /dev/null
+++ b/validation/bool-array.c
@@ -0,0 +1,47 @@
+static _Bool boolarray_d1[1];
+static _Bool boolarray_d8[8];
+static _Bool boolarray_i2[2] = {
+	0,
+	1,
+};
+static int nd1 = sizeof(boolarray_d1);
+static int nd8 = sizeof(boolarray_d8);
+static int ni2 = sizeof(boolarray_i2);
+
+
+static long longarray_u2[] = {
+	0,
+	1,
+};
+static int nl2 = sizeof(longarray_u2);
+
+/*
+ * Used to get "warning: excessive elements in array initializer"
+ * for all elements but the first one.
+ * Note: only occurs if nbr of elements is a multiple of 8
+ *       (if not, theer was another problem)
+ */
+static _Bool boolarray_u8[] = {
+	0,
+	1,
+	0,
+	1,
+	0,
+	1,
+	0,
+	1,
+};
+
+/*
+ * Used to get "error: cannot size expression" for the sizeof.
+ */
+static _Bool boolarray_u2[] = {
+	0,
+	1,
+};
+static int nu2 = sizeof(boolarray_u2);
+
+/*
+ * check-name: sizeof(bool array)
+ * check-command: sparse -Wno-sizeof-bool $file
+ */
-- 
2.7.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix size calculation of unsized bool array
Date: Thu, 04 Feb 2016 16:10:15 +0000
Message-ID: <CANeU7Q=bsRJP_7NtiDh9Lhda1yqcnYPLjH4VP-S9QW2sFMAS1w () mail ! gmail ! com>
--------------------
On Thu, Jan 7, 2016 at 9:47 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This stops sparse from issuing the error message
>         "error: cannot size expression"
> for code like:
>         static _Bool boolarray[] = {
>                 0,
>                 1,
>         };
>         static int n = sizeof(boolarray);

This patch looks great. Applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix type checking of variadic functions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Fix type checking of variadic functions
Date: Fri, 18 Nov 2016 12:30:06 +0000
Message-ID: <20161118123005.GB476 () macbook ! local>
--------------------
On Thu, Nov 17, 2016 at 08:06:41AM +0800, Christopher Li wrote:
> Speaking of the test case, there are two case can be added:
> 
> void arg_incomplete();
> void arg_incomplete(int a) {} /* check-should-pass */
> 
> void arg_incomplete_vararg();
> void arg_incomplete_vararg(int a, ...) {} /* check-should-fail */
> 
> Sparse handle the first one incorrectly. But that is a separate issue,
> we can address it in a different patch.
> 
> Will apply.
> 
> Chris
> --

Yes. I'll look at this later.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] OP_SWITCH should use 'insn->cond' instead of 'insn->target' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] OP_SWITCH should use 'insn->cond' instead of 'insn->target'
Date: Tue, 22 Nov 2016 16:32:33 +0000
Message-ID: <20161122163233.3765-1-luc.vanoostenryck () gmail ! com>
--------------------
From: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

show_instruction() uses the field 'target' to display OP_SWITCH
instruction instead of 'cond' like OP_BR does.
It doesn't change anything since these two fields use the same
storage inside struct instruction but better to use the right field
to keep consistent.
---
 linearize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index c6ada1e8..31d2a6cd 100644
--- a/linearize.c
+++ b/linearize.c
@@ -357,7 +357,7 @@ const char *show_instruction(struct instruction *insn)
 	}
 	case OP_SWITCH: {
 		struct multijmp *jmp;
-		buf += sprintf(buf, "%s", show_pseudo(insn->target));
+		buf += sprintf(buf, "%s", show_pseudo(insn->cond));
 		FOR_EACH_PTR(insn->multijmp_list, jmp) {
 			if (jmp->begin == jmp->end)
 				buf += sprintf(buf, ", %d -> .L%p", jmp->begin, jmp->target);
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] OP_SWITCH should use 'insn->cond' instead of 'insn->target'
Date: Wed, 23 Nov 2016 01:16:57 +0000
Message-ID: <CANeU7QmTuzPMY2+6yk2zjaxYWx6BXvq=MU-bv-+r48pRnkXhtw () mail ! gmail ! com>
--------------------
On Wed, Nov 23, 2016 at 12:32 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> From: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>
>
> show_instruction() uses the field 'target' to display OP_SWITCH
> instruction instead of 'cond' like OP_BR does.
> It doesn't change anything since these two fields use the same
> storage inside struct instruction but better to use the right field
> to keep consistent.

Looks good to me. Will apply.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] OP_SWITCH should use 'insn->cond' instead of 'insn->target'
Date: Mon, 06 Feb 2017 23:16:21 +0000
Message-ID: <CANeU7Q=pxdgu5iwN49BiwQXiDKo04fG9PQO9kjMT-Bq8sEafxQ () mail ! gmail ! com>
--------------------
On Tue, Feb 7, 2017 at 4:33 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Here is my s-o-b that I had forgot to add:
>     Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

The sparse-next branch has been updated to include your s-o-b with other
two patches.

Thanks for all the patches.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Remove unneeded variable in integer_promotion() ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Remove unneeded variable in integer_promotion()
Date: Thu, 17 Nov 2016 16:56:05 +0000
Message-ID: <CANeU7QnAndq6D4XcvKbp5fV5-P-A0pKL7WWtUmc04+Taxb3paQ () mail ! gmail ! com>
--------------------
On Thu, Nov 3, 2016 at 6:11 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Following some previous simplification done on the function,
> the variable 'orig_type' is now always the same as 'type'.
>
> To avoid possible confusion, only use 'type' and remove
> the declaration of 'orig_type'.

Indeed. Applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Update maintainers in the manpage ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] Update maintainers in the manpage
Date: Thu, 08 Dec 2016 05:43:44 +0000
Message-ID: <20161208054343.vvmc2nfruwy53dez () x>
--------------------
On Thu, Dec 08, 2016 at 05:48:56AM +0100, Luc Van Oostenryck wrote:
> The manpage still mentioned Josh Triplett as the maintainer
> while Christopher is the maintainer since 2009.
> 
> CC: Christopher Li <sparse@chrisli.org>
> CC: Josh Triplett <josh@joshtriplett.org>
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

Reviewed-by: Josh Triplett <josh@joshtriplett.org>

>  sparse.1 | 2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
> 
> diff --git a/sparse.1 b/sparse.1
> index ccae55cc..4aeb0039 100644
> --- a/sparse.1
> +++ b/sparse.1
> @@ -364,4 +364,4 @@ https://sparse.wiki.kernel.org/
>  linux-sparse@vger.kernel.org
>  .
>  .SH MAINTAINER
> -Josh Triplett <josh@kernel.org>
> +Christopher Li <sparse@chrisli.org>
> -- 
> 2.10.2
> 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] add test case for builtin bswap with constant args ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] add test case for builtin bswap with constant args
Date: Thu, 24 Nov 2016 13:00:09 +0000
Message-ID: <20161124130007.GA12488 () macbook ! local>
--------------------
On Thu, Nov 24, 2016 at 01:30:14PM +0800, Christopher Li wrote:
> On Thu, Nov 24, 2016 at 4:38 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > ---
> >  validation/builtin-constant-eval.c | 28 ++++++++++++++++++++++++++++
> >  1 file changed, 28 insertions(+)
> >  create mode 100644 validation/builtin-constant-eval.c
> 
> Can you reply with a sign off line?
> 
> Thanks
> 
> Chris
> --

Oh yes, I forgot this. Sorry.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] allow to launch the test suite from the project root dir ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] allow to launch the test suite from the project root dir
Date: Wed, 02 Nov 2016 23:22:24 +0000
Message-ID: <20161102232224.74747-1-luc.vanoostenryck () gmail ! com>
--------------------
The test suite must be run from the validation/ dir
which is sometimes slightly annoying.

Change that by letting the script to first do a cd to
the validation dir.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/validation/test-suite b/validation/test-suite
index 03421a24..9a033439 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -2,6 +2,8 @@
 
 #set -x
 
+cd $(dirname "$0")
+
 default_path=".."
 default_cmd="sparse \$file"
 tests_list=`find . -name '*.c' | sed -e 's#^\./\(.*\)#\1#' | sort`
-- 
2.10.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] allow to launch the test suite from the project root dir
Date: Thu, 17 Nov 2016 17:10:11 +0000
Message-ID: <CANeU7Q=OzuHLgmsJ3JH5G0+uTgj6w3k2x3-kdvduXPC9Mh_waw () mail ! gmail ! com>
--------------------
On Thu, Nov 3, 2016 at 7:22 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The test suite must be run from the validation/ dir
> which is sometimes slightly annoying.
>
> Change that by letting the script to first do a cd to
> the validation dir.

Applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] arm64: take SHN_LIVEPATCH syms into account when calculating plt_max_entries ===

From: Miroslav Benes <mbenes () suse ! cz>
To: linux-sparse
Subject: Re: [PATCH] arm64: take SHN_LIVEPATCH syms into account when calculating plt_max_entries
Date: Wed, 17 Aug 2016 09:38:27 +0000
Message-ID: <alpine.LNX.2.00.1608171135360.29236 () pobox ! suse ! cz>
--------------------
On Tue, 12 Jul 2016, Jessica Yu wrote:

> SHN_LIVEPATCH symbols are technically a subset of SHN_UNDEF/undefined
> symbols, except that their addresses are resolved by livepatch at runtime.
> Therefore, when calculating the upper-bound for the number of plt entries
> to allocate, make sure to take livepatch symbols into account as well.
> 
> Signed-off-by: Jessica Yu <jeyu@redhat.com>

FWIW, I think the patch does what we want, but it's for arm people to 
judge. It might be better to include it to Torsten's patch set.

Miroslav

> ---
> arch/arm64/kernel/module-plts.c | 3 ++-
> 1 file changed, 2 insertions(+), 1 deletion(-)
> 
> diff --git a/arch/arm64/kernel/module-plts.c b/arch/arm64/kernel/module-plts.c
> index 1ce90d8..1e95dc1 100644
> --- a/arch/arm64/kernel/module-plts.c
> +++ b/arch/arm64/kernel/module-plts.c
> @@ -122,7 +122,8 @@ static unsigned int count_plts(Elf64_Sym *syms, Elf64_Rela
> *rela, int num)
>                         * as well, so modules can never grow beyond that
> limit.
>                         */
>                        s = syms + ELF64_R_SYM(rela[i].r_info);
> -                       if (s->st_shndx != SHN_UNDEF)
> +                       if (s->st_shndx != SHN_UNDEF &&
> +                           s->st_shndx != SHN_LIVEPATCH)
>                                break;
> 
>                        /*
> -- 
> 2.5.5
> 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] byteswap: don't use __builtin_bswap*() with sparse ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: [PATCH] byteswap: don't use __builtin_bswap*() with sparse
Date: Thu, 11 Aug 2016 11:15:02 +0000
Message-ID: <1470914102-26389-1-git-send-email-johannes () sipsolutions ! net>
--------------------
From: Johannes Berg <johannes.berg@intel.com>

Although sparse declares __builtin_bswap*(), it can't actually
do constant folding inside them (yet). As such, things like

  switch (protocol) {
  case htons(ETH_P_IP):
          break;
  }

which we do all over the place cause sparse to warn that it
expects a constant instead of a function call.

Disable __HAVE_BUILTIN_BSWAP*__ if __CHECKER__ is defined to
avoid this.

Cc: Arnd Bergmann <arnd@arndb.de>
Fixes: 7322dd755e7d ("byteswap: try to avoid __builtin_constant_p gcc bug")
Signed-off-by: Johannes Berg <johannes.berg@intel.com>
---
 include/linux/compiler-gcc.h | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index e2949397c19b..8dbc8929a6a0 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -242,7 +242,11 @@
  */
 #define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
 
-#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+/*
+ * sparse (__CHECKER__) pretends to be gcc, but can't do constant
+ * folding in __builtin_bswap*() (yet), so don't set these for it.
+ */
+#if defined(CONFIG_ARCH_USE_BUILTIN_BSWAP) && !defined(__CHECKER__)
 #if GCC_VERSION >= 40400
 #define __HAVE_BUILTIN_BSWAP32__
 #define __HAVE_BUILTIN_BSWAP64__
@@ -250,7 +254,7 @@
 #if GCC_VERSION >= 40800
 #define __HAVE_BUILTIN_BSWAP16__
 #endif
-#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP && !__CHECKER__ */
 
 #if GCC_VERSION >= 50000
 #define KASAN_ABI_VERSION 4
-- 
2.8.1

================================================================================

From: Arnd Bergmann <arnd () arndb ! de>
To: linux-sparse
Subject: Re: [PATCH] byteswap: don't use __builtin_bswap*() with sparse
Date: Thu, 11 Aug 2016 11:55:48 +0000
Message-ID: <2133648.lb1RCaYlXp () wuerfel>
--------------------
On Thursday, August 11, 2016 1:15:02 PM CEST Johannes Berg wrote:
> From: Johannes Berg <johannes.berg@intel.com>
> 
> Although sparse declares __builtin_bswap*(), it can't actually
> do constant folding inside them (yet). As such, things like
> 
>   switch (protocol) {
>   case htons(ETH_P_IP):
>           break;
>   }
> 
> which we do all over the place cause sparse to warn that it
> expects a constant instead of a function call.
> 
> Disable __HAVE_BUILTIN_BSWAP*__ if __CHECKER__ is defined to
> avoid this.
> 
> Cc: Arnd Bergmann <arnd@arndb.de>
> Fixes: 7322dd755e7d ("byteswap: try to avoid __builtin_constant_p gcc bug")
> Signed-off-by: Johannes Berg <johannes.berg@intel.com>

Looks good, thanks for addressing this!

Acked-by: Arnd Bergmann <arnd@arndb.de>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnd Bergmann <arnd () arndb ! de>
To: linux-kernel
Subject: Re: [PATCH] byteswap: don't use __builtin_bswap*() with sparse
Date: Thu, 11 Aug 2016 11:55:48 +0000
Message-ID: <2133648.lb1RCaYlXp () wuerfel>
--------------------
On Thursday, August 11, 2016 1:15:02 PM CEST Johannes Berg wrote:
> From: Johannes Berg <johannes.berg@intel.com>
> 
> Although sparse declares __builtin_bswap*(), it can't actually
> do constant folding inside them (yet). As such, things like
> 
>   switch (protocol) {
>   case htons(ETH_P_IP):
>           break;
>   }
> 
> which we do all over the place cause sparse to warn that it
> expects a constant instead of a function call.
> 
> Disable __HAVE_BUILTIN_BSWAP*__ if __CHECKER__ is defined to
> avoid this.
> 
> Cc: Arnd Bergmann <arnd@arndb.de>
> Fixes: 7322dd755e7d ("byteswap: try to avoid __builtin_constant_p gcc bug")
> Signed-off-by: Johannes Berg <johannes.berg@intel.com>

Looks good, thanks for addressing this!

Acked-by: Arnd Bergmann <arnd@arndb.de>
================================================================================


################################################################################

=== Thread: [PATCH] cgcc should not define non-reserved identifiers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] cgcc should not define non-reserved identifiers
Date: Thu, 22 Dec 2016 00:44:33 +0000
Message-ID: <20161222004433.563-1-luc.vanoostenryck () gmail ! com>
--------------------
Since the original x86-64 support in cgcc
(commit 0fcbcbf4: "Implement x86-64 support in cgcc")
cgcc define some non-reserved identifiers like i386, x86_64, ...
It should not since these are valid identifiers which could be used
for some variable names.

Current versions of gcc only define those prefixed with a double
underscore and cgcc also define those. So ...

Remove the defines of the non-prefixed ones.

Reported-by: Joe Lawrence <joe.lawrence@redhat.com>
Investigated-by: Joe Lawrence <joe.lawrence@redhat.com>
Originally-From: Linus Torvalds <torvalds@linux-foundation.org>
Tested-by: Joe Lawrence <joe.lawrence@redhat.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 cgcc | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cgcc b/cgcc
index d7b1c99c..c29fa587 100755
--- a/cgcc
+++ b/cgcc
@@ -250,25 +250,25 @@ sub add_specs {
 	    " -D'__fastcall=__attribute__((__fastcall__))'" .
 	    " -D'__declspec(x)=__attribute__((x))'";
     } elsif ($spec eq 'i86') {
-	return (' -Di386=1 -D__i386=1 -D__i386__=1' .
+	return (' -D__i386=1 -D__i386__=1' .
 		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
 		&float_types (1, 1, 21, [24,8], [53,11], [64,15]) .
 		&define_size_t ($m64 ? "long unsigned int" : "unsigned int") .
 		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
     } elsif ($spec eq 'sparc') {
-	return (' -Dsparc=1 -D__sparc=1 -D__sparc__=1' .
+	return (' -D__sparc=1 -D__sparc__=1' .
 		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
 		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
 		&define_size_t ($m64 ? "long unsigned int" : "unsigned int") .
 		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
     } elsif ($spec eq 'sparc64') {
-	return (' -Dsparc=1 -D__sparc=1 -D__sparc__=1 -D__sparcv9__=1 -D__sparc64__=1 -D__arch64__=1 -D__LP64__=1' .
+	return (' -D__sparc=1 -D__sparc__=1 -D__sparcv9__=1 -D__sparc64__=1 -D__arch64__=1 -D__LP64__=1' .
 		&integer_types (8, 16, 32, 64, 64, 128) .
 		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
 		&define_size_t ("long unsigned int") .
 		' -D__SIZEOF_POINTER__=8');
     } elsif ($spec eq 'x86_64') {
-	return (' -Dx86_64=1 -D__x86_64=1 -D__x86_64__=1' . ($m32 ? '' : ' -D__LP64__=1') .
+	return (' -D__x86_64=1 -D__x86_64__=1' . ($m32 ? '' : ' -D__LP64__=1') .
 		&integer_types (8, 16, 32, $m32 ? 32 : 64, 64, 128) .
 		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
 		&define_size_t ($m32 ? "unsigned int" : "long unsigned int") .
-- 
2.9.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] dissect: s/mode_t/usage_t/ in report_member() ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: s/mode_t/usage_t/ in report_member()
Date: Thu, 11 Feb 2016 22:47:10 +0000
Message-ID: <20160211224710.GA4989 () redhat ! com>
--------------------
Cosmetic, fix the typo.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dissect.c b/dissect.c
index 2d13d2a..67428ec 100644
--- a/dissect.c
+++ b/dissect.c
@@ -130,7 +130,7 @@ static inline struct symbol *no_member(struct ident *name)
 	return &sym;
 }
 
-static struct symbol *report_member(mode_t mode, struct position *pos,
+static struct symbol *report_member(usage_t mode, struct position *pos,
 					struct symbol *type, struct symbol *mem)
 {
 	struct symbol *ret = mem->ctype.base_type;
-- 
2.5.0


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: s/mode_t/usage_t/ in report_member()
Date: Thu, 11 Feb 2016 22:47:10 +0000
Message-ID: <20160211224710.GA4989 () redhat ! com>
--------------------
Cosmetic, fix the typo.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dissect.c b/dissect.c
index 2d13d2a..67428ec 100644
--- a/dissect.c
+++ b/dissect.c
@@ -130,7 +130,7 @@ static inline struct symbol *no_member(struct ident *name)
 	return &sym;
 }
 
-static struct symbol *report_member(mode_t mode, struct position *pos,
+static struct symbol *report_member(usage_t mode, struct position *pos,
 					struct symbol *type, struct symbol *mem)
 {
 	struct symbol *ret = mem->ctype.base_type;
-- 
2.5.0


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: s/mode_t/usage_t/ in report_member()
Date: Mon, 26 Sep 2016 16:26:04 +0000
Message-ID: <20160926162603.GA6782 () redhat ! com>
--------------------
On 09/23, Lance Richardson wrote:
>
> Better late than never:
>
> Acked-by: Lance Richardson <lrichard@redhat.com>

Thanks, perhaps you can also ack other patches I sent by that time ;)
Although it seems that nobody cares anyway.

Oleg.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] dissect: s/mode_t/usage_t/ in report_member()
Date: Mon, 26 Sep 2016 21:21:16 +0000
Message-ID: <CANeU7Qku=B+C8G=5yb4_pTOZMoob=_90ufErLj3wnDr_UV+FbQ () mail ! gmail ! com>
--------------------
On Mon, Sep 26, 2016 at 9:26 AM, Oleg Nesterov <oleg@redhat.com> wrote:
> On 09/23, Lance Richardson wrote:
>>
>> Better late than never:
>>
>> Acked-by: Lance Richardson <lrichard@redhat.com>
>
> Thanks, perhaps you can also ack other patches I sent by that time ;)
> Although it seems that nobody cares anyway.

Err, better late than never. Let me pick this up again.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: s/mode_t/usage_t/ in report_member()
Date: Wed, 02 Nov 2016 14:17:09 +0000
Message-ID: <20161102141708.GA9163 () macpro ! local>
--------------------
On Thu, Feb 11, 2016 at 11:47:10PM +0100, Oleg Nesterov wrote:
> Cosmetic, fix the typo.
> 
> Signed-off-by: Oleg Nesterov <oleg@redhat.com>
> ---
>  dissect.c | 2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
> 
> diff --git a/dissect.c b/dissect.c
> index 2d13d2a..67428ec 100644
> --- a/dissect.c
> +++ b/dissect.c
> @@ -130,7 +130,7 @@ static inline struct symbol *no_member(struct ident *name)
>  	return &sym;
>  }
>  
> -static struct symbol *report_member(mode_t mode, struct position *pos,
> +static struct symbol *report_member(usage_t mode, struct position *pos,
>  					struct symbol *type, struct symbol *mem)
>  {
>  	struct symbol *ret = mem->ctype.base_type;
> -- 

For what it's worth:
Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] dissect: teach do_expression() to handle EXPR_OFFSETOF ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: teach do_expression() to handle EXPR_OFFSETOF
Date: Mon, 08 Feb 2016 13:26:57 +0000
Message-ID: <20160208132657.GA19007 () redhat ! com>
--------------------
Starting from a194f3e0 "implement __builtin_offsetof()" sparse handles
offsetof() internally but dissect.c wasn't updated.

Test case:

	struct S { int m; };

	void func(void)
	{
		__builtin_offsetof(struct S, m);
	}

before this patch:

	3:6   g def  func                             void ( ... )
	T.c:5:38: warning: bad expr->type: 30

after:

	3:6   g def  func                             void ( ... )
	1:8   s def  S
	5:38  s ---  S.m                              int

While at it, update my email.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/dissect.c b/dissect.c
index d211bca..19f3276 100644
--- a/dissect.c
+++ b/dissect.c
@@ -1,7 +1,7 @@
 /*
  * sparse/dissect.c
  *
- * Started by Oleg Nesterov <oleg@tv-sign.ru>
+ * Started by Oleg Nesterov <oleg@redhat.com>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -429,6 +429,20 @@ again:
 			lookup_member(p_type, expr->member, NULL));
 	}
 
+	break; case EXPR_OFFSETOF: {
+		struct symbol *in = base_type(expr->in);
+
+		do {
+			if (expr->op == '.') {
+				in = report_member(U_VOID, &expr->pos, in,
+					lookup_member(in, expr->ident, NULL));
+			} else {
+				do_expression(U_R_VAL, expr->index);
+				in = in->ctype.base_type;
+			}
+		} while ((expr = expr->down));
+	}
+
 	break; case EXPR_SYMBOL:
 		ret = report_symbol(mode, expr);
 	}
-- 
2.5.0


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] dissect: teach do_initializer() to handle the nested EXPR_IDENTIFIER's ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: teach do_initializer() to handle the nested EXPR_IDENTIFIER's
Date: Mon, 08 Feb 2016 15:13:28 +0000
Message-ID: <20160208151328.GA24783 () redhat ! com>
--------------------
do_initializer() is very limited/buggy but it was able to parse the kernel
code until ftrace started to use ".a.b = x" rather than ".a = { .b = x }"
in initializers.

Test-case:

	struct O {
		struct I {
			int mem;
		} inn;
		int end;
	} var = {
		.inn.mem = 0,
		0,
	};

before the patch:

	1:8   s def  O
	2:16  s def  I
	6:3   g def  var                              struct O
	6:3   g -w-  var                              struct O
	7:10  s -w-  O.inn                            struct I
	7:10  s -w-  I.*                              struct I
	I.c:7:14: warning: bad expr->type: 25
	8:9   s -w-  O.end                            int

after:

	1:8   s def  O
	2:16  s def  I
	6:3   g def  var                              struct O
	6:3   g -w-  var                              struct O
	7:10  s -w-  O.inn                            struct I
	7:14  s -w-  I.mem                            int
	8:9   s -w-  O.end                            int

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/dissect.c b/dissect.c
index 19f3276..2d13d2a 100644
--- a/dissect.c
+++ b/dissect.c
@@ -547,18 +547,23 @@ static struct symbol *do_initializer(struct symbol *type, struct expression *exp
 				if (m_expr->type == EXPR_INDEX)
 					m_expr = m_expr->idx_expression;
 			} else {
-				struct position *pos = &m_expr->pos;
-				struct ident *m_name = NULL;
+				int *m_atop = &m_addr;
 
-				if (m_expr->type == EXPR_IDENTIFIER) {
-					m_name = m_expr->expr_ident;
+				m_type = type;
+				while (m_expr->type == EXPR_IDENTIFIER) {
+					m_type = report_member(U_W_VAL, &m_expr->pos, m_type,
+							lookup_member(m_type, m_expr->expr_ident, m_atop));
 					m_expr = m_expr->ident_expression;
+					m_atop = NULL;
+				}
+
+				if (m_atop) {
+					m_type = report_member(U_W_VAL, &m_expr->pos, m_type,
+							lookup_member(m_type, NULL, m_atop));
 				}
 
-				m_type = report_member(U_W_VAL, pos, type,
-						lookup_member(type, m_name, &m_addr));
 				if (m_expr->type != EXPR_INITIALIZER)
-					report_implicit(U_W_VAL, pos, m_type);
+					report_implicit(U_W_VAL, &m_expr->pos, m_type);
 			}
 			do_initializer(m_type, m_expr);
 			m_addr++;
-- 
2.5.0


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix typing error in compound assignment ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix typing error in compound assignment
Date: Wed, 07 Dec 2016 14:33:42 +0000
Message-ID: <20161207143342.88825-1-luc.vanoostenryck () gmail ! com>
--------------------
A compound assignment like, for example:
	x += a;
should have the same effect as the operation followed by the
assignment except that the left side should only be evaluated
once. So the statement above (assuming 'x' free of side-effects)
should have the same effect as:
	x = x + a;

In particular, the usual conversions should applied. So, if
the type of 'x' and 'a' is, respectively, 'int' and 'long',
the statement above should be equivalent to:
	x = (int) ((long) x + a);

But what is really done currently is something like:
	x = x + (typeof(x)) a;
In other words, the left-hand side is casted to the same type as the
rhs and the operation is always done with this type, neglecting the
usual conversions and thus forcing the operation to always be done
with the rhs type, here 'int' instead of 'long'.

The patch fix this by first calculating the type corresponding to
the usual conversion and then casting the right-hand side to this
type, which is fine, since it's a rvalue anyway.
Later steps will then use the rhs type when doing the operation.
On the example above, the cast will be a no-op and the operation will
be done with the correct type:
	x = x + (long) a;
which, at linearization, will become:
	x = (int) ((long) x + (long) a);

If the types where in the other order, the result will also be done
with the correct type:
	long a;
	int x;
	...
	a += x;
will become:
	a = a + (long) x;
and, at linearization:
	a = (int) ((long) a + (long) x);

Cc: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                        |  5 ++++-
 linearize.c                       | 10 ++++++----
 validation/compound-assign-type.c | 15 +++++++++++++++
 3 files changed, 25 insertions(+), 5 deletions(-)
 create mode 100644 validation/compound-assign-type.c

diff --git a/evaluate.c b/evaluate.c
index e350c0c0..0ea3e866 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1258,7 +1258,7 @@ static int evaluate_assign_op(struct expression *expr)
 			if (!restricted_value(expr->right, t))
 				return 1;
 		} else if (!(sclass & TYPE_RESTRICT))
-			goto Cast;
+			goto usual;
 		/* source and target would better be identical restricted */
 		if (t == s)
 			return 1;
@@ -1281,6 +1281,9 @@ static int evaluate_assign_op(struct expression *expr)
 	expression_error(expr, "invalid assignment");
 	return 0;
 
+usual:
+	target = usual_conversions(op, expr->left, expr->right,
+				tclass, sclass, target, source);
 Cast:
 	expr->right = cast_to(expr->right, target);
 	return 1;
diff --git a/linearize.c b/linearize.c
index c6ada1e8..e0166128 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1154,6 +1154,7 @@ static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *e
 	struct access_data ad = { NULL, };
 	struct expression *target = expr->left;
 	struct expression *src = expr->right;
+	struct symbol *ctype;
 	pseudo_t value;
 
 	value = linearize_expression(ep, src);
@@ -1179,10 +1180,11 @@ static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *e
 		if (!src)
 			return VOID;
 
-		oldvalue = cast_pseudo(ep, oldvalue, src->ctype, expr->ctype);
-		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], src->ctype);
-		dst = add_binary_op(ep, src->ctype, opcode, oldvalue, value);
-		value = cast_pseudo(ep, dst, expr->ctype, src->ctype);
+		ctype = src->ctype;
+		oldvalue = cast_pseudo(ep, oldvalue, target->ctype, ctype);
+		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], ctype);
+		dst = add_binary_op(ep, ctype, opcode, oldvalue, value);
+		value = cast_pseudo(ep, dst, ctype, expr->ctype);
 	}
 	value = linearize_store_gen(ep, value, &ad);
 	finish_address_gen(ep, &ad);
diff --git a/validation/compound-assign-type.c b/validation/compound-assign-type.c
new file mode 100644
index 00000000..8e7efb4a
--- /dev/null
+++ b/validation/compound-assign-type.c
@@ -0,0 +1,15 @@
+static int foo(int x, long a)
+{
+	x += a;
+	return x;
+}
+
+/*
+ * check-name: compound-assign-type
+ * check-command: test-linearize -m64 $file
+ * check-output-ignore
+ *
+ * check-output-excludes: add\\.32
+ * check-output-contains: add\\.64
+ * check-output-contains: scast\\.64
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] fix typing error in compound assignment
Date: Sat, 10 Dec 2016 06:25:14 +0000
Message-ID: <20161210062513.GA5558 () macbook ! local>
--------------------
On Sat, Dec 10, 2016 at 02:14:00AM +0000, Al Viro wrote:
> On Wed, Dec 07, 2016 at 03:33:42PM +0100, Luc Van Oostenryck wrote:
> > But what is really done currently is something like:
> > 	x = x + (typeof(x)) a;
> > In other words, the left-hand side is casted to the same type as the
> > rhs and the operation is always done with this type, neglecting the
> > usual conversions and thus forcing the operation to always be done
> > with the rhs type, here 'int' instead of 'long'.
> 
> Addition is a bad example, actually - your variant (promotions + operaton +
> cast down to the first argument due to assignment) will yield the same value.
> It's division where the real trouble happens -
> 	unsigned n1 = 1, n2 = 1;
> 	long v = -1;
> 	n1 /= v;
> 	n2 /= (unsigned)v;
> 
> should yield n1 == ~0U, n2 == 0.  And yes, the current logics in sparse
> does not distinguish between those.  So ACK on the fix, but you want
> a better testcase.

Absolutely. In fact, I found the problem when a was a double and
I saw that the addition was still done with a 32bit wide operation.
I used this example because there is too much problems with floating-point
operations.
I'll reuse your example, which is more 'dramatic' that mine.

Thanks for the review.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix typing error in compound assignment
Date: Sat, 10 Dec 2016 09:52:21 +0000
Message-ID: <20161210095221.1641-1-luc.vanoostenryck () gmail ! com>
--------------------
A compound assignment like, for example:
	x /= a;
should have the same effect as the operation followed by the
assignment except that the left side should only be evaluated
once. So the statement above (assuming 'x' free of side-effects)
should have the same effect as:
	x = x / a;

In particular, the usual conversions should applied. So, if the
type of 'x' and 'a' is, respectively, 'unsigned int' (32 bit) and
'long' (64 bit), the statement above should be equivalent to:
	x = (unsigned int) ((long) x / a);

But what is really done currently is something like:
	x = x / (unsigned int) a;
In other words, the left-hand side is casted to the same type as the
rhs and the operation is always done with this type, neglecting the
usual conversions and thus forcing the operation to always be done
with the rhs type, here 'unsigned int' instead of 'long'.
For example, with the values:
        unsigned int x;
        long a = -1;

We have:
	x = 1 / (unsigned int) (-1);
	x = 1 / 0xffffffff;
	x = 0;
instead of the expected:
	x = (unsigned int) (1L / -1L);
	x = (unsigned int) (-1L);
	x = 0xffffffff;

The patch fix this by first calculating the type corresponding to
the usual conversion and then casting the right-hand side to this
type, which is fine, since it's a rvalue anyway.
Later steps will then use the rhs type when doing the operation.
On the example above, the cast will be a no-op and the operation will
be done with the correct type:
	x = x / (long) a;
which, at linearization, will become:
	x = (unsigned int) ((long) x / (long) a);
and with unneeded casts optimized away:
	x = (unsigned int) ((long) x / a);
Which will give us the expected result.

If the types where in the other order, the result will also be done
with the correct type:
	long x;
	unsigned int a;
	...
	x /= a;
will become:
	x = x / (long) a;
and, at linearization:
	x = (long) ((long) x / (long) a);
and with unneeded casts optimized away:
	x = (x / (long) a);

Cc: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---

Changes since v1:
 - no change in the patch itself
 - change the description with a more interesting example, thanks
   to Alexander Viro (a division instead of an addition where
   2-complement arithmetic which gave the same end result anyway).
 - adapt the test case to match the patch description.


 evaluate.c                        |  5 ++++-
 linearize.c                       | 10 ++++++----
 validation/compound-assign-type.c | 15 +++++++++++++++
 3 files changed, 25 insertions(+), 5 deletions(-)
 create mode 100644 validation/compound-assign-type.c

diff --git a/evaluate.c b/evaluate.c
index e350c0c0..0ea3e866 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1258,7 +1258,7 @@ static int evaluate_assign_op(struct expression *expr)
 			if (!restricted_value(expr->right, t))
 				return 1;
 		} else if (!(sclass & TYPE_RESTRICT))
-			goto Cast;
+			goto usual;
 		/* source and target would better be identical restricted */
 		if (t == s)
 			return 1;
@@ -1281,6 +1281,9 @@ static int evaluate_assign_op(struct expression *expr)
 	expression_error(expr, "invalid assignment");
 	return 0;
 
+usual:
+	target = usual_conversions(op, expr->left, expr->right,
+				tclass, sclass, target, source);
 Cast:
 	expr->right = cast_to(expr->right, target);
 	return 1;
diff --git a/linearize.c b/linearize.c
index c6ada1e8..e0166128 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1154,6 +1154,7 @@ static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *e
 	struct access_data ad = { NULL, };
 	struct expression *target = expr->left;
 	struct expression *src = expr->right;
+	struct symbol *ctype;
 	pseudo_t value;
 
 	value = linearize_expression(ep, src);
@@ -1179,10 +1180,11 @@ static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *e
 		if (!src)
 			return VOID;
 
-		oldvalue = cast_pseudo(ep, oldvalue, src->ctype, expr->ctype);
-		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], src->ctype);
-		dst = add_binary_op(ep, src->ctype, opcode, oldvalue, value);
-		value = cast_pseudo(ep, dst, expr->ctype, src->ctype);
+		ctype = src->ctype;
+		oldvalue = cast_pseudo(ep, oldvalue, target->ctype, ctype);
+		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], ctype);
+		dst = add_binary_op(ep, ctype, opcode, oldvalue, value);
+		value = cast_pseudo(ep, dst, ctype, expr->ctype);
 	}
 	value = linearize_store_gen(ep, value, &ad);
 	finish_address_gen(ep, &ad);
diff --git a/validation/compound-assign-type.c b/validation/compound-assign-type.c
new file mode 100644
index 00000000..ef7861b2
--- /dev/null
+++ b/validation/compound-assign-type.c
@@ -0,0 +1,15 @@
+static unsigned int foo(unsigned int x, long a)
+{
+	x /= a;
+	return x;
+}
+
+/*
+ * check-name: compound-assign-type
+ * check-command: test-linearize -m64 $file
+ * check-output-ignore
+ *
+ * check-output-excludes: divu\\.32
+ * check-output-contains: divs\\.64
+ * check-output-contains: scast\\.64
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH] fix typing error in compound assignment
Date: Sat, 10 Dec 2016 21:22:52 +0000
Message-ID: <2d5af300-0a96-aec0-27a9-61efd768cdd2 () ramsayjones ! plus ! com>
--------------------


On 10/12/16 09:52, Luc Van Oostenryck wrote:
> A compound assignment like, for example:
> 	x /= a;
> should have the same effect as the operation followed by the
> assignment except that the left side should only be evaluated
> once. So the statement above (assuming 'x' free of side-effects)
> should have the same effect as:
> 	x = x / a;
> 
> In particular, the usual conversions should applied. So, if the
> type of 'x' and 'a' is, respectively, 'unsigned int' (32 bit) and
> 'long' (64 bit), the statement above should be equivalent to:
> 	x = (unsigned int) ((long) x / a);
> 
> But what is really done currently is something like:
> 	x = x / (unsigned int) a;
> In other words, the left-hand side is casted to the same type as the
> rhs and the operation is always done with this type, neglecting the
> usual conversions and thus forcing the operation to always be done
> with the rhs type, here 'unsigned int' instead of 'long'.

I have read this paragraph repeatedly, but I just can't understand
what you are saying, unless I swap left-hand-side for right-hand-side
and vice-versa. :-P

> For example, with the values:
>         unsigned int x;
          ^^^^^^^^^^^^^^^
          unsigned int x = 1;

>         long a = -1;
> 
> We have:
> 	x = 1 / (unsigned int) (-1);
> 	x = 1 / 0xffffffff;
> 	x = 0;
> instead of the expected:
> 	x = (unsigned int) (1L / -1L);

        x = (unsigned int) ((long)1 / -1L);

> 	x = (unsigned int) (-1L);
> 	x = 0xffffffff;
> 

ATB,
Ramsay Jones


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] implement constant-folding in __builtin_bswap*() ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH] implement constant-folding in __builtin_bswap*()
Date: Thu, 11 Aug 2016 10:39:39 +0000
Message-ID: <1470911979-15068-1-git-send-email-johannes () sipsolutions ! net>
--------------------
Since gcc does this, it's apparently valid to write

 switch (x) {
 case __builtin_bswap16(12):
   break;
 }

but sparse will flag it as an error today.

The constant folding used to be done in the kernel's htons() and
friends, but due to gcc bugs that isn't done anymore since
commit 7322dd755e7d ("byteswap: try to avoid __builtin_constant_p
gcc bug").

To get rid of the sparse errors on every such instance now, just
add constant folding to __builtin_bswap*() in sparse.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 lib.c | 35 ++++++++++++++++++++++++++++++++---
 1 file changed, 32 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index 8dc5bcf9dc18..7cab95ede318 100644
--- a/lib.c
+++ b/lib.c
@@ -818,9 +818,38 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern int __builtin_popcountll(unsigned long long);\n");
 
 	/* And byte swaps.. */
-	add_pre_buffer("extern unsigned short __builtin_bswap16(unsigned short);\n");
-	add_pre_buffer("extern unsigned int __builtin_bswap32(unsigned int);\n");
-	add_pre_buffer("extern unsigned long long __builtin_bswap64(unsigned long long);\n");
+	add_pre_buffer("extern unsigned short ____builtin_bswap16(unsigned short);\n");
+	add_pre_buffer("extern unsigned int ____builtin_bswap32(unsigned int);\n");
+	add_pre_buffer("extern unsigned long long ____builtin_bswap64(unsigned long long);\n");
+	add_pre_buffer("#define __sparse_constant_swab16(x) ((unsigned short)("
+		       "	(((unsigned short)(x) & (unsigned short)0x00ffU) << 8) |"
+		       "	(((unsigned short)(x) & (unsigned short)0xff00U) >> 8)))\n");
+	add_pre_buffer("#define __sparse_constant_swab32(x) ((unsigned int)("
+		       "	(((unsigned int)(x) & (unsigned int)0x000000ffUL) << 24) |"
+		       "	(((unsigned int)(x) & (unsigned int)0x0000ff00UL) <<  8) |"
+		       "	(((unsigned int)(x) & (unsigned int)0x00ff0000UL) >>  8) |"
+		       "	(((unsigned int)(x) & (unsigned int)0xff000000UL) >> 24)))\n");
+	add_pre_buffer("#define __sparse_constant_swab64(x) ((unsigned long long)("
+		       "	(((unsigned long long)(x) & (unsigned long long)0x00000000000000ffULL) << 56) |"
+		       "	(((unsigned long long)(x) & (unsigned long long)0x000000000000ff00ULL) << 40) |"
+		       "	(((unsigned long long)(x) & (unsigned long long)0x0000000000ff0000ULL) << 24) |"
+		       "	(((unsigned long long)(x) & (unsigned long long)0x00000000ff000000ULL) <<  8) |"
+		       "	(((unsigned long long)(x) & (unsigned long long)0x000000ff00000000ULL) >>  8) |"
+		       "	(((unsigned long long)(x) & (unsigned long long)0x0000ff0000000000ULL) >> 24) |"
+		       "	(((unsigned long long)(x) & (unsigned long long)0x00ff000000000000ULL) >> 40) |"
+		       "	(((unsigned long long)(x) & (unsigned long long)0xff00000000000000ULL) >> 56)))\n");
+	add_pre_buffer("#define __builtin_bswap16(x)"
+		       "	(__builtin_constant_p((unsigned short)(x)) ?"
+		       "	__sparse_constant_swab16(x) :"
+		       "	____builtin_bswap16(x))\n");
+	add_pre_buffer("#define __builtin_bswap32(x)"
+		       "	(__builtin_constant_p((unsigned int)(x)) ?"
+		       "	__sparse_constant_swab32(x) :"
+		       "	____builtin_bswap32(x))\n");
+	add_pre_buffer("#define __builtin_bswap64(x)"
+		       "	(__builtin_constant_p((unsigned long long)(x)) ?"
+		       "	__sparse_constant_swab64(x) :"
+		       "	____builtin_bswap64(x))\n");
 
 	/* And atomic memory access functions.. */
 	add_pre_buffer("extern int __sync_fetch_and_add(void *, ...);\n");
-- 
2.8.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] let "compile" not crash on bools ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] let "compile" not crash on bools
Date: Mon, 21 Nov 2016 03:49:33 +0000
Message-ID: <20161121034933.34194-1-luc.vanoostenryck () gmail ! com>
--------------------
"compile" & "compile-i386" have never been adapted to use
bits_to_bytes() and crash when processing a bool because
it doesn't find a suffix for 1-bit instructions ('b', 'w', 'l', 'q').

Sprinkling a dozen "bit_to_bytes()" and adjusting a few shifts
would fix it but letting bits_in_bool be equal to 8 is much simpler.

Note: with this patch, "compile" crashes 'only' 25 times when used
on the testsuite files, instead of 27 without it.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
CC: Jeff Layton <jlayton@redhat.com>
---
 compile.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/compile.c b/compile.c
index 48f9c700..eeb996ab 100644
--- a/compile.c
+++ b/compile.c
@@ -56,6 +56,8 @@ int main(int argc, char **argv)
 	char *file;
 	struct string_list *filelist = NULL;
 
+	bits_in_bool = 8;
+
 	clean_up_symbols(sparse_initialize(argc, argv, &filelist));
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		struct symbol_list *list;
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] lib: __builtin_object_size should accept void * ===

From: "Michael S. Tsirkin" <mst () redhat ! com>
To: linux-sparse
Subject: [PATCH] lib: __builtin_object_size should accept void *
Date: Wed, 23 Nov 2016 20:24:41 +0000
Message-ID: <1479932572-12543-1-git-send-email-mst () redhat ! com>
--------------------
I'm seeing these warnings with current Linux:
./arch/x86/include/asm/uaccess.h:705:18: warning: incorrect type in argument 1 (different modifiers)
./arch/x86/include/asm/uaccess.h:705:18:    expected void *<noident>
./arch/x86/include/asm/uaccess.h:705:18:    got void const *from

Because of this code:

static __always_inline unsigned long __must_check
copy_to_user(void __user *to, const void *from, unsigned long n)
{
        int sz = __compiletime_object_size(from);

...
}

where we have

# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)

to fix, mark the argument as const void *.

Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
---

Sorry if this has already been reported/fixed.

 lib.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib.c b/lib.c
index d5b56b0..2d66aa0 100644
--- a/lib.c
+++ b/lib.c
@@ -888,7 +888,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long double __builtin_nanl(const char *);\n");
 
 	/* And some __FORTIFY_SOURCE ones.. */
-	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(void *, int);\n");
+	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(const void *, int);\n");
 	add_pre_buffer ("extern void * __builtin___memcpy_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
 	add_pre_buffer ("extern void * __builtin___memmove_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
 	add_pre_buffer ("extern void * __builtin___mempcpy_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
-- 
MST
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] lib: __builtin_object_size should accept void *
Date: Thu, 24 Nov 2016 00:16:24 +0000
Message-ID: <CANeU7Qm4Q7fawnTkGgsgQoiLJXwJLJng+4Y60+n5c_nbK-vRgQ () mail ! gmail ! com>
--------------------
A similar patch has been applied:

Chris

commit f2bf519e1da89779380fd781c0eb28aae415979d
Author: Lance Richardson <lrichard@redhat.com>
Date:   Wed Sep 21 10:13:58 2016 -0400

    sparse: update __builtin_object_size() prototype

    Sparse emits a large number of warnings for the linux kernel source
    tree of the form:
        ./arch/x86/include/asm/uaccess.h:735:18: \
            warning: incorrect type in argument 1 (different modifiers)
        ./arch/x86/include/asm/uaccess.h:735:18:    expected void *<noident>
        ./arch/x86/include/asm/uaccess.h:735:18:    got void const *from

    Fix by making the first parameter to __builtin_object_size()
    type "const void *" instead of "void *", which is consistent with GCC
    behavior (the prototype for this builtin in GCC documentation is evidently
    incorrect).

    Signed-off-by: Lance Richardson <lrichard@redhat.com>
    Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Christopher Li <sparse@chrisli.org>

diff --git a/lib.c b/lib.c
index d5b56b0..2d66aa0 100644
--- a/lib.c
+++ b/lib.c
@@ -888,7 +888,7 @@ void declare_builtin_functions(void)
        add_pre_buffer("extern long double __builtin_nanl(const char *);\n");

        /* And some __FORTIFY_SOURCE ones.. */
-       add_pre_buffer ("extern __SIZE_TYPE__
__builtin_object_size(void *, int);\n");
+       add_pre_buffer ("extern __SIZE_TYPE__
__builtin_object_size(const void *, int);\n");
        add_pre_buffer ("extern void * __builtin___memcpy_chk(void *,
const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
        add_pre_buffer ("extern void * __builtin___memmove_chk(void *,
const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
        add_pre_buffer ("extern void * __builtin___mempcpy_chk(void *,
const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");



On Thu, Nov 24, 2016 at 4:24 AM, Michael S. Tsirkin <mst@redhat.com> wrote:
> I'm seeing these warnings with current Linux:
> ./arch/x86/include/asm/uaccess.h:705:18: warning: incorrect type in argument 1 (different modifiers)
> ./arch/x86/include/asm/uaccess.h:705:18:    expected void *<noident>
> ./arch/x86/include/asm/uaccess.h:705:18:    got void const *from
>
> Because of this code:
>
> static __always_inline unsigned long __must_check
> copy_to_user(void __user *to, const void *from, unsigned long n)
> {
>         int sz = __compiletime_object_size(from);
>
> ...
> }
>
> where we have
>
> # define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
>
> to fix, mark the argument as const void *.
>
> Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
> ---
>
> Sorry if this has already been reported/fixed.
>
>  lib.c | 2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
>
> diff --git a/lib.c b/lib.c
> index d5b56b0..2d66aa0 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -888,7 +888,7 @@ void declare_builtin_functions(void)
>         add_pre_buffer("extern long double __builtin_nanl(const char *);\n");
>
>         /* And some __FORTIFY_SOURCE ones.. */
> -       add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(void *, int);\n");
> +       add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(const void *, int);\n");
>         add_pre_buffer ("extern void * __builtin___memcpy_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
>         add_pre_buffer ("extern void * __builtin___memmove_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
>         add_pre_buffer ("extern void * __builtin___mempcpy_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
> --
> MST
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] lib: __builtin_object_size should accept void *
Date: Thu, 24 Nov 2016 04:01:21 +0000
Message-ID: <CANeU7Q=tRrCDxo25xgQC8qAQJsA27dEUiJ8sjDTXU-HAL3_h6w () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 11:28 AM, Michael S. Tsirkin <mst@redhat.com> wrote:
> Doesn't seem to be pushed yet - at least I don't see it in master
> on git://git.kernel.org/pub/scm/devel/sparse/sparse.git

That is right. I haven't push them out yet. The last few days have been a bit
hectic for me in terms patch apply and modify.  I am considering setup
a linux-next
like staging repository for sparse. Maybe sparse-next?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] lib: __builtin_object_size should accept void *
Date: Thu, 24 Nov 2016 05:03:32 +0000
Message-ID: <CANeU7QkS2QTrQ40JYTXmzi19s4JyL+T15+3y9y0vQBmBTNCEKw () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 12:35 PM, Josh Triplett <josh@kernel.org> wrote:
> Probably doesn't need a separate integration repository; if you want to
> stage changes that you don't know you want to ship yet, a "next" branch
> in the main repository would be easier for people to find and use.  If
> you just want to give changes time to stabilize, you can probably put
> them on "master" and just not release them yet.

I want a branch I can publish for others to review and test.
At the same time I want to be able to go back and modify the history
of the patch, merge and squash fix for the already applied patch.

That "next" branch will not be pull stable, is it acceptable?
I saw linux-next has a separate repository and the master branch
is not pull stable. At the same time there are tag like next-20161121
to reference old branch.

I assume I can do the similar thing. The question is that does it
need to be a separate repository?

As long as people don't expect pull stable from that "next" branch,
I am fine with putting it under the sparse main repository.

I guess there is other implications on the git repository size. If the
repository get rewind and modify very often, it might cause the git
pack file contain a lot of useless head not part of the stable master
branch. I don't think sparse next branch will rewind that often, but
that is some thing to consider as a separate repository.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] lib: __builtin_object_size should accept void *
Date: Thu, 24 Nov 2016 05:49:17 +0000
Message-ID: <CANeU7Qn0AhfBJszBYMqv+ewP3aZmNYmXmvRbPtF1zGF1Y_1WMw () mail ! gmail ! com>
--------------------
On Thu, Nov 24, 2016 at 1:19 PM, Josh Triplett <josh@kernel.org> wrote:
> Rebasing a "next" branch, as long as you clearly document that, seems
> fine.

Great. Here is the sparse-next branch. This branch contain the latest patch
I applied. It can be rebased from time to time.

https://git.kernel.org/cgit/devel/sparse/sparse.git/log/?h=sparse-next

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] llvm: fix typing when comparing to a constant ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] llvm: fix typing when comparing to a constant
Date: Sun, 11 Dec 2016 09:49:19 +0000
Message-ID: <20161211094919.20894-1-luc.vanoostenryck () gmail ! com>
--------------------
In translation to LLVM, comparisons are processed like usual binary
operations. But contrary to, for example, an addition where the
result type and the type of both operands are all the same, a
comparison always returns an integer result (with boolean values)
which shouldn't depends on the type/size of its operands.

There is currently a bug regarding this when an operand of a
comparison is an integer constant:
    the type of this constant is assumed to be the type of the result
    of the comparison (in sparse's IR, the constants are typeless,
    we thus need to guess/retrieve their type from the context)

For example, with the following C code:
	_Bool foo(int a) { return a != 3; }

After linearization we can have the following very straightforward:
	setne.1    %rd <- %arg1, $3

And we expect the following LLVM IR:
	%rd = icmp ne i32 %0, 3

But what is built is the illegal:
	%rd = icmp ne i32 %0, i1 true
because is constant '3' is translated to 'i1 true' since
'setne.1' result type is boolean (i1 in LLVM parlance).

Fix this by separating the code for comparison from the others
binary operations and using the left-hand side type to interpret
the type of the constant (which is fine because the usual conversion
insure that both types match and there is never a constant on the lhs).

Cc: Azat Khuzhin <a3at.mail@gmail.com>
Cc: Xi Wang <xi.wang@gmail.com>
Cc: Pekka Enberg <penberg@kernel.org>
Cc: Jeff Garzik <jeff@garzik.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 sparse-llvm.c | 53 ++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 34 insertions(+), 19 deletions(-)

diff --git a/sparse-llvm.c b/sparse-llvm.c
index 6b41afd8..29b7cae0 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -535,24 +535,6 @@ static void output_op_binary(struct function *fn, struct instruction *insn)
 		target = LLVMBuildZExt(fn->builder, target, dst_type, target_name);
 		break;
 	}
-
-	/* Binary comparison */
-	case OP_BINCMP ... OP_BINCMP_END: {
-		LLVMTypeRef dst_type = insn_symbol_type(fn->module, insn);
-
-		if (LLVMGetTypeKind(LLVMTypeOf(lhs)) == LLVMIntegerTypeKind) {
-			LLVMIntPredicate op = translate_op(insn->opcode);
-
-			target = LLVMBuildICmp(fn->builder, op, lhs, rhs, target_name);
-		} else {
-			LLVMRealPredicate op = translate_fop(insn->opcode);
-
-			target = LLVMBuildFCmp(fn->builder, op, lhs, rhs, target_name);
-		}
-
-		target = LLVMBuildZExt(fn->builder, target, dst_type, target_name);
-		break;
-	}
 	default:
 		assert(0);
 		break;
@@ -561,6 +543,37 @@ static void output_op_binary(struct function *fn, struct instruction *insn)
 	insn->target->priv = target;
 }
 
+static void output_op_compare(struct function *fn, struct instruction *insn)
+{
+	LLVMValueRef lhs, rhs, target;
+	char target_name[64];
+
+	lhs = pseudo_to_value(fn, insn, insn->src1);
+
+	if (insn->src2->type == PSEUDO_VAL)
+		rhs = LLVMConstInt(LLVMTypeOf(lhs), insn->src2->value, 1);
+	else
+		rhs = pseudo_to_value(fn, insn, insn->src2);
+
+	pseudo_name(insn->target, target_name);
+
+	LLVMTypeRef dst_type = insn_symbol_type(fn->module, insn);
+
+	if (LLVMGetTypeKind(LLVMTypeOf(lhs)) == LLVMIntegerTypeKind) {
+		LLVMIntPredicate op = translate_op(insn->opcode);
+
+		target = LLVMBuildICmp(fn->builder, op, lhs, rhs, target_name);
+	} else {
+		LLVMRealPredicate op = translate_fop(insn->opcode);
+
+		target = LLVMBuildFCmp(fn->builder, op, lhs, rhs, target_name);
+	}
+
+	target = LLVMBuildZExt(fn->builder, target, dst_type, target_name);
+
+	insn->target->priv = target;
+}
+
 static void output_op_ret(struct function *fn, struct instruction *insn)
 {
 	pseudo_t pseudo = insn->src;
@@ -874,9 +887,11 @@ static void output_insn(struct function *fn, struct instruction *insn)
 		output_op_ptrcast(fn, insn);
 		break;
 	case OP_BINARY ... OP_BINARY_END:
-	case OP_BINCMP ... OP_BINCMP_END:
 		output_op_binary(fn, insn);
 		break;
+	case OP_BINCMP ... OP_BINCMP_END:
+		output_op_compare(fn, insn);
+		break;
 	case OP_SEL:
 		output_op_sel(fn, insn);
 		break;
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] llvm: remove unneeded OP_COPY support ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] llvm: remove unneeded OP_COPY support
Date: Sun, 11 Dec 2016 10:17:29 +0000
Message-ID: <20161211101729.26791-1-luc.vanoostenryck () gmail ! com>
--------------------
OP_COPY instructions are only introduced by the 'unSSA' phase
which is not used by sparse-llvm.

Remove the code which tried to handle this.

Cc: Azat Khuzhin <a3at.mail@gmail.com>
Cc: Xi Wang <xi.wang@gmail.com>
Cc: Pekka Enberg <penberg@kernel.org>
Cc: Jeff Garzik <jeff@garzik.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 sparse-llvm.c | 30 +-----------------------------
 1 file changed, 1 insertion(+), 29 deletions(-)

diff --git a/sparse-llvm.c b/sparse-llvm.c
index 6b41afd8..5af473a3 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -788,34 +788,6 @@ static void output_op_cast(struct function *fn, struct instruction *insn, LLVMOp
 	insn->target->priv = target;
 }
 
-static void output_op_copy(struct function *fn, struct instruction *insn,
-			   pseudo_t pseudo)
-{
-	LLVMValueRef src, target;
-	LLVMTypeRef const_type;
-	char target_name[64];
-
-	pseudo_name(insn->target, target_name);
-	src = pseudo_to_value(fn, insn, pseudo);
-	const_type = insn_symbol_type(fn->module, insn);
-
-	/*
-	 * This is nothing more than 'target = src'
-	 *
-	 * TODO: find a better way to provide an identity function,
-	 * than using "X + 0" simply to produce a new LLVM pseudo
-	 */
-
-	if (symbol_is_fp_type(insn->type))
-		target = LLVMBuildFAdd(fn->builder, src,
-			LLVMConstReal(const_type, 0.0), target_name);
-	else
-		target = LLVMBuildAdd(fn->builder, src,
-			LLVMConstInt(const_type, 0, 0), target_name);
-
-	insn->target->priv = target;
-}
-
 static void output_insn(struct function *fn, struct instruction *insn)
 {
 	switch (insn->opcode) {
@@ -914,7 +886,7 @@ static void output_insn(struct function *fn, struct instruction *insn)
 		assert(0);
 		break;
 	case OP_COPY:
-		output_op_copy(fn, insn, insn->src);
+		assert(0);
 		break;
 	default:
 		break;
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] make -m32/-m64 more useful ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] make -m32/-m64 more useful
Date: Wed, 07 Dec 2016 17:38:02 +0000
Message-ID: <20161207173802.23314-1-luc.vanoostenryck () gmail ! com>
--------------------
The option -m64 to just set the size of longs & pointers to 64 bits.

This patch makes this option much more effective by:
- adding define for LONG_MAX & SIZEOF_POINTER
- define __LP64__
- let the dual option, -m32, do the same as -m64 but for 32 bit
---
 lib.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/lib.c b/lib.c
index d5b56b01..e5b0bb63 100644
--- a/lib.c
+++ b/lib.c
@@ -402,9 +402,21 @@ static void handle_arch_m64_finalize(void)
 		pointer_alignment = 8;
 		size_t_ctype = &ulong_ctype;
 		ssize_t_ctype = &long_ctype;
+		add_pre_buffer("#weak_define __LONG_MAX__ 0x7fffffffffffffff\n");
+		add_pre_buffer("#weak_define __SIZEOF_POINTER__ 8\n");
+		add_pre_buffer("#weak_define __LP64__ 1\n");
 #ifdef __x86_64__
 		add_pre_buffer("#weak_define __x86_64__ 1\n");
 #endif
+	} else {
+		bits_in_long = 32;
+		max_int_alignment = 4;
+		bits_in_pointer = 32;
+		pointer_alignment = 4;
+		size_t_ctype = &ulong_ctype;
+		ssize_t_ctype = &long_ctype;
+		add_pre_buffer("#weak_define __LONG_MAX__ 0x7fffffff\n");
+		add_pre_buffer("#weak_define __SIZEOF_POINTER__ 4\n");
 	}
 }
 
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] make ptrlist walking against robust against empty blocks ===

From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
To: Unknown
Subject: [PATCH] make ptrlist walking against robust against empty blocks
Date: Thu, 17 Nov 2016 20:59:18 +0100
Message-ID: 
--------------------
Not all macros or function involved in the ptrlist walking
can handle a ptrlist containing some empty blocks.

Fix this by:
- add the proper check & looping to first & last_ptr_list().
- add a safe version of PTR_ENTRY doing the needed check & looping.
- use this safe version for DO_PREPARE() & DO_RESET()

Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
CC: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

---
I've quickly checked it on the testsuite (and it seems to pass ;).
I'll validate this more thoroughly but I won't be able to do this
just now.
---
 ptrlist.h | 29 ++++++++++++++++++++++++++---
 1 file changed, 26 insertions(+), 3 deletions(-)

diff --git a/ptrlist.h b/ptrlist.h
index 61e159fd..d09be2f5 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -67,28 +67,51 @@ extern int linearize_ptr_list(struct ptr_list *, void **, int);
 
 static inline void *first_ptr_list(struct ptr_list *list)
 {
+	struct ptr_list *head = list;
+
 	if (!list)
 		return NULL;
+
+	while (list->nr == 0) {
+		list = list->next;
+		if (list == head)
+			return NULL;
+	}
 	return PTR_ENTRY(list, 0);
 }
 
 static inline void *last_ptr_list(struct ptr_list *list)
 {
+	struct ptr_list *head = list;
 
 	if (!list)
 		return NULL;
 	list = list->prev;
+	while (list->nr == 0) {
+		if (list == head)
+			return NULL;
+		list = list->prev;
+	}
 	return PTR_ENTRY(list, list->nr-1);
 }
 
+#define PTR_DEREF(__head, idx, PTR_ENTRY) ({						\
+	struct ptr_list *__list = __head;						\
+	while (__list && __list->nr == 0) {						\
+		__list = __list->next;							\
+		if (__list == __head)							\
+			__list = NULL;							\
+	}										\
+	__list ? PTR_ENTRY(__list, idx) : NULL;						\
+})
+
 #define DO_PREPARE(head, ptr, __head, __list, __nr, PTR_ENTRY)				\
 	do {										\
 		struct ptr_list *__head = (struct ptr_list *) (head);			\
 		struct ptr_list *__list = __head;					\
 		int __nr = 0;								\
 		CHECK_TYPE(head,ptr);							\
-		if (__head) ptr = PTR_ENTRY(__head, 0);					\
-		else ptr = NULL
+		ptr = PTR_DEREF(__head, 0, PTR_ENTRY);					\
 
 #define DO_NEXT(ptr, __head, __list, __nr, PTR_ENTRY)					\
 		if (ptr) {								\
@@ -110,7 +133,7 @@ static inline void *last_ptr_list(struct ptr_list *list)
 	do {										\
 		__nr = 0;								\
 		__list = __head;							\
-		if (__head) ptr = PTR_ENTRY(__head, 0);					\
+		if (__head) ptr = PTR_DEREF(__head, 0, PTR_ENTRY);			\
 	} while (0)
 
 #define DO_FINISH(ptr, __head, __list, __nr)						\
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] recursive phi_defines cannot happen ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] recursive phi_defines cannot happen
Date: Thu, 08 Dec 2016 03:34:38 +0000
Message-ID: <20161208033438.7607-1-luc.vanoostenryck () gmail ! com>
--------------------
The function phi_defines() does the liveness tracking of phi-pseudos
(pseudos in OP_PHIs args). While doing this, the function is
recursively called when the pseudo would be defined by another phi-node;
but this condition is impossible because all phi-pseudos are defined
by OP_PHISOURCE instructions.

This patch remove the recursive call and its associated test.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 liveness.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/liveness.c b/liveness.c
index eeff0f79..fb696720 100644
--- a/liveness.c
+++ b/liveness.c
@@ -23,10 +23,6 @@ static void phi_defines(struct instruction * phi_node, pseudo_t target,
 		def = phi->def;
 		if (!def || !def->bb)
 			continue;
-		if (def->opcode == OP_PHI) {
-			phi_defines(def, target, defines);
-			continue;
-		}
 		defines(def->bb, phi->def, target);
 	} END_FOR_EACH_PTR(phi);
 }
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] remove unused arg in uses/defs functions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] remove unused arg in uses/defs functions
Date: Thu, 08 Dec 2016 03:46:18 +0000
Message-ID: <20161208034618.7910-1-luc.vanoostenryck () gmail ! com>
--------------------
In the liveness analysis, the use/def methods have a
'struct instruction *' argument.
This arg is never used and it's not clear for what it
could be used, what it would represent.

This patch remove this argument from all the concerned
functions.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 liveness.c | 30 +++++++++++++++---------------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/liveness.c b/liveness.c
index fb696720..2e513943 100644
--- a/liveness.c
+++ b/liveness.c
@@ -13,7 +13,7 @@
 #include "flow.h"
 
 static void phi_defines(struct instruction * phi_node, pseudo_t target,
-	void (*defines)(struct basic_block *, struct instruction *, pseudo_t))
+	void (*defines)(struct basic_block *, pseudo_t))
 {
 	pseudo_t phi;
 	FOR_EACH_PTR(phi_node->phi_list, phi) {
@@ -23,33 +23,33 @@ static void phi_defines(struct instruction * phi_node, pseudo_t target,
 		def = phi->def;
 		if (!def || !def->bb)
 			continue;
-		defines(def->bb, phi->def, target);
+		defines(def->bb, target);
 	} END_FOR_EACH_PTR(phi);
 }
 
 static void asm_liveness(struct basic_block *bb, struct instruction *insn,
-	void (*def)(struct basic_block *, struct instruction *, pseudo_t),
-	void (*use)(struct basic_block *, struct instruction *, pseudo_t))
+	void (*def)(struct basic_block *, pseudo_t),
+	void (*use)(struct basic_block *, pseudo_t))
 {
 	struct asm_constraint *entry;
 
 	FOR_EACH_PTR(insn->asm_rules->inputs, entry) {
-		use(bb, insn, entry->pseudo);
+		use(bb, entry->pseudo);
 	} END_FOR_EACH_PTR(entry);
 		
 	FOR_EACH_PTR(insn->asm_rules->outputs, entry) {
-		def(bb, insn, entry->pseudo);
+		def(bb, entry->pseudo);
 	} END_FOR_EACH_PTR(entry);
 }
 
 static void track_instruction_usage(struct basic_block *bb, struct instruction *insn,
-	void (*def)(struct basic_block *, struct instruction *, pseudo_t),
-	void (*use)(struct basic_block *, struct instruction *, pseudo_t))
+	void (*def)(struct basic_block *, pseudo_t),
+	void (*use)(struct basic_block *, pseudo_t))
 {
 	pseudo_t pseudo;
 
-	#define USES(x)		use(bb, insn, insn->x)
-	#define DEFINES(x)	def(bb, insn, insn->x)
+	#define USES(x)		use(bb, insn->x)
+	#define DEFINES(x)	def(bb, insn->x)
 
 	switch (insn->opcode) {
 	case OP_RET:
@@ -122,7 +122,7 @@ static void track_instruction_usage(struct basic_block *bb, struct instruction *
 		if (insn->target != VOID)
 			DEFINES(target);
 		FOR_EACH_PTR(insn->arguments, pseudo) {
-			use(bb, insn, pseudo);
+			use(bb, pseudo);
 		} END_FOR_EACH_PTR(pseudo);
 		break;
 
@@ -180,7 +180,7 @@ static inline int trackable_pseudo(pseudo_t pseudo)
 	return pseudo && (pseudo->type == PSEUDO_REG || pseudo->type == PSEUDO_ARG);
 }
 
-static void insn_uses(struct basic_block *bb, struct instruction *insn, pseudo_t pseudo)
+static void insn_uses(struct basic_block *bb, pseudo_t pseudo)
 {
 	if (trackable_pseudo(pseudo)) {
 		struct instruction *def = pseudo->def;
@@ -189,7 +189,7 @@ static void insn_uses(struct basic_block *bb, struct instruction *insn, pseudo_t
 	}
 }
 
-static void insn_defines(struct basic_block *bb, struct instruction *insn, pseudo_t pseudo)
+static void insn_defines(struct basic_block *bb, pseudo_t pseudo)
 {
 	assert(trackable_pseudo(pseudo));
 	add_pseudo(&bb->defines, pseudo);
@@ -300,11 +300,11 @@ static void track_bb_phi_uses(struct basic_block *bb)
 static struct pseudo_list **live_list;
 static struct pseudo_list *dead_list;
 
-static void death_def(struct basic_block *bb, struct instruction *insn, pseudo_t pseudo)
+static void death_def(struct basic_block *bb, pseudo_t pseudo)
 {
 }
 
-static void death_use(struct basic_block *bb, struct instruction *insn, pseudo_t pseudo)
+static void death_use(struct basic_block *bb, pseudo_t pseudo)
 {
 	if (trackable_pseudo(pseudo) && !pseudo_in_list(*live_list, pseudo)) {
 		add_pseudo(&dead_list, pseudo);
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] remove unused field 'multijump' in struct instruction ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] remove unused field 'multijump' in struct instruction
Date: Tue, 22 Nov 2016 16:43:30 +0000
Message-ID: <20161122164330.3953-1-luc.vanoostenryck () gmail ! com>
--------------------
This field was introduced (I think) for OP_SWITCH but is
not needed anymore as OP_SWITCH has its own entry with a field
fOr multijump list.
---
 linearize.h | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/linearize.h b/linearize.h
index 61fbd831..e3e67dde 100644
--- a/linearize.h
+++ b/linearize.h
@@ -106,9 +106,6 @@ struct instruction {
 			pseudo_t base;
 			unsigned from, len;
 		};
-		struct /* multijump */ {
-			int begin, end;
-		};
 		struct /* setval */ {
 			pseudo_t symbol;		/* Subtle: same offset as "src" !! */
 			struct expression *val;
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] remove unused fields in struct instruction ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] remove unused fields in struct instruction
Date: Thu, 08 Dec 2016 03:13:27 +0000
Message-ID: <20161208031327.1631-1-luc.vanoostenryck () gmail ! com>
--------------------
The fields 'begin' & 'end' (multijmp) are unused since commit
0b67ecb622146f71aa6e43379f526d11bdd48b37 which introduced
the field 'multijmp_list'.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.h | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/linearize.h b/linearize.h
index 61fbd831..e3e67dde 100644
--- a/linearize.h
+++ b/linearize.h
@@ -106,9 +106,6 @@ struct instruction {
 			pseudo_t base;
 			unsigned from, len;
 		};
-		struct /* multijump */ {
-			int begin, end;
-		};
 		struct /* setval */ {
 			pseudo_t symbol;		/* Subtle: same offset as "src" !! */
 			struct expression *val;
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] simplify '(x || 1)' to '1' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] simplify '(x || 1)' to '1'
Date: Wed, 07 Dec 2016 16:13:24 +0000
Message-ID: <20161207161324.15619-1-luc.vanoostenryck () gmail ! com>
--------------------
There is simplifications for:
	(x && 0) => 0
	(x && 1) => x
	(x || 0) => x
but the fourth case '(x || 1)' is missing.

This patch add the missing simplification and a small test case.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                       |  7 +++++-
 validation/optim/bool-simplify.c | 51 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 57 insertions(+), 1 deletion(-)
 create mode 100644 validation/optim/bool-simplify.c

diff --git a/simplify.c b/simplify.c
index b5cd0ea7..da12ebe8 100644
--- a/simplify.c
+++ b/simplify.c
@@ -315,6 +315,11 @@ static int simplify_constant_rightside(struct instruction *insn)
 	long long value = insn->src2->value;
 
 	switch (insn->opcode) {
+	case OP_OR_BOOL:
+		if (value == 1)
+			return replace_with_pseudo(insn, insn->src2);
+		goto case_neutral_zero;
+
 	case OP_SUB:
 		if (value) {
 			insn->opcode = OP_ADD;
@@ -324,9 +329,9 @@ static int simplify_constant_rightside(struct instruction *insn)
 	/* Fall through */
 	case OP_ADD:
 	case OP_OR: case OP_XOR:
-	case OP_OR_BOOL:
 	case OP_SHL:
 	case OP_LSR:
+	case_neutral_zero:
 		if (!value)
 			return replace_with_pseudo(insn, insn->src1);
 		return 0;
diff --git a/validation/optim/bool-simplify.c b/validation/optim/bool-simplify.c
new file mode 100644
index 00000000..e0ff1c2d
--- /dev/null
+++ b/validation/optim/bool-simplify.c
@@ -0,0 +1,51 @@
+int and_0(int a)
+{
+	return a && 0;
+}
+
+int and_1(int a)
+{
+	return a && 1;
+}
+
+int or_0(int a)
+{
+	return a || 0;
+}
+
+int or_1(int a)
+{
+	return a || 1;
+}
+
+/*
+ * check-name: bool-simplify
+ * check-command: test-linearize -Wno-decl $file
+ *
+ * check-output-start
+and_0:
+.L0:
+	<entry-point>
+	ret.32      $0
+
+
+and_1:
+.L2:
+	<entry-point>
+	ret.32      %arg1
+
+
+or_0:
+.L4:
+	<entry-point>
+	ret.32      %arg1
+
+
+or_1:
+.L6:
+	<entry-point>
+	ret.32      $1
+
+
+ * check-output-end
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] simplify '~(~x)' and '-(-x)' to 'x' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] simplify '~(~x)' and '-(-x)' to 'x'
Date: Wed, 07 Dec 2016 16:05:47 +0000
Message-ID: <20161207160547.9821-1-luc.vanoostenryck () gmail ! com>
--------------------
Currently those double operations are not simplified.

This patch add those simplifications and some small test cases.

Note: the 'boolean not': '!(!x)' is not handled by this patch
because this operator is processed differently (it doesn't generate
an unop instruction but directly generates 'seteq' operations).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---

WARNING: the test cases, to give the correct results, need the patches
from the serie "fix uses of killed instructions" sent previously.


 simplify.c                     | 17 +++++++++++++++++
 validation/optim/double-unop.c | 15 +++++++++++++++
 2 files changed, 32 insertions(+)
 create mode 100644 validation/optim/double-unop.c

diff --git a/simplify.c b/simplify.c
index b5cd0ea7..7e4bce5b 100644
--- a/simplify.c
+++ b/simplify.c
@@ -588,6 +588,23 @@ static int simplify_unop(struct instruction *insn)
 		return REPEAT_CSE;
 	if (constant(insn->src1))
 		return simplify_constant_unop(insn);
+
+	switch (insn->opcode) {
+		struct instruction *def;
+
+	case OP_NOT:
+		def = insn->src->def;
+		if (def && def->opcode == OP_NOT)
+			return replace_with_pseudo(insn, def->src);
+		break;
+	case OP_NEG:
+		def = insn->src->def;
+		if (def && def->opcode == OP_NEG)
+			return replace_with_pseudo(insn, def->src);
+		break;
+	default:
+		return 0;
+	}
 	return 0;
 }
 
diff --git a/validation/optim/double-unop.c b/validation/optim/double-unop.c
new file mode 100644
index 00000000..f0e6d94f
--- /dev/null
+++ b/validation/optim/double-unop.c
@@ -0,0 +1,15 @@
+typedef unsigned int u32;
+
+u32 unotnot(u32 a) { return ~(~a); }
+int snotnot(int a) { return ~(~a); }
+u32 unegneg(int a) { return -(-a); }
+int snegneg(int a) { return -(-a); }
+
+/*
+ * check-name: double-unop
+ * check-command: test-linearize -Wno-decl $file
+ * check-output-ignore
+ *
+ * check-output-excludes: not\\.
+ * check-output-excludes: neg\\.
+ */
-- 
2.10.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: add support for static assert ===

From: Lance Richardson <lrichard () redhat ! com>
To: linux-sparse
Subject: [PATCH] sparse: add support for static assert
Date: Wed, 06 Jan 2016 18:35:17 +0000
Message-ID: <1452105317-5828-1-git-send-email-lrichard () redhat ! com>
--------------------
This patch introduces support for _Static_assert() in global,
function, and struct/union declaration contexts (as currently supported
by gcc).

Tested via:
   - kernel build with C=1 CF=-D__CHECK_ENDIAN__
   - build/check large code base making heavy use of _Static_assert()
   - "make check" with added test case for static assert support

Signed-off-by: Lance Richardson <lrichard@redhat.com>
---
 parse.c                    | 33 ++++++++++++++++++++++++++++++++-
 validation/static_assert.c | 20 ++++++++++++++++++++
 2 files changed, 52 insertions(+), 1 deletion(-)
 create mode 100644 validation/static_assert.c

diff --git a/parse.c b/parse.c
index b43d683..0b1a7f2 100644
--- a/parse.c
+++ b/parse.c
@@ -57,7 +57,8 @@ static declarator_t
 	attribute_specifier, typeof_specifier, parse_asm_declarator,
 	typedef_specifier, inline_specifier, auto_specifier,
 	register_specifier, static_specifier, extern_specifier,
-	thread_specifier, const_qualifier, volatile_qualifier;
+	thread_specifier, const_qualifier, volatile_qualifier,
+	static_assert_specifier;
 
 static struct token *parse_if_statement(struct token *token, struct statement *stmt);
 static struct token *parse_return_statement(struct token *token, struct statement *stmt);
@@ -308,6 +309,11 @@ static struct symbol_op asm_op = {
 	.toplevel = toplevel_asm_declaration,
 };
 
+static struct symbol_op static_assert_op = {
+	.type = KW_ATTRIBUTE,
+	.declarator = static_assert_specifier,
+};
+
 static struct symbol_op packed_op = {
 	.attribute = attribute_packed,
 };
@@ -437,6 +443,10 @@ static struct init_keyword {
 	{ "__restrict",	NS_TYPEDEF, .op = &restrict_op},
 	{ "__restrict__",	NS_TYPEDEF, .op = &restrict_op},
 
+
+	/* Static assertion */
+	{ "_Static_assert", NS_TYPEDEF, .op = &static_assert_op },
+
 	/* Storage class */
 	{ "auto",	NS_TYPEDEF, .op = &auto_op },
 	{ "register",	NS_TYPEDEF, .op = &register_op },
@@ -2004,6 +2014,27 @@ static struct token *parse_asm_declarator(struct token *token, struct decl_state
 	return token;
 }
 
+
+static struct token *static_assert_specifier(struct token *token, struct decl_state *ctx)
+{
+	struct expression *expr = NULL;
+	int val;
+
+	token = constant_expression(token->next, &expr);
+	if (!expr)
+		sparse_error(token->pos, "Expected constant expression");
+	val = get_expression_value(expr);
+	token = expect(token, ',', "after first argument of _Static_assert");
+	token = parse_expression(token, &expr);
+	token = expect(token, ')', "after second argument of _Static_assert");
+
+	if (!val)
+		sparse_error(token->pos, "static assertion failed: %s",
+                             show_string(expr->string));
+
+	return token;
+}
+
 /* Make a statement out of an expression */
 static struct statement *make_statement(struct expression *expr)
 {
diff --git a/validation/static_assert.c b/validation/static_assert.c
new file mode 100644
index 0000000..baab346
--- /dev/null
+++ b/validation/static_assert.c
@@ -0,0 +1,20 @@
+_Static_assert(1, "global ok");
+
+struct foo {
+	_Static_assert(1, "struct ok");
+};
+
+void bar(void)
+{
+	_Static_assert(1, " func ok");
+}
+
+_Static_assert(0, "expected failure");
+/*
+ * check-name: static assertion
+ *
+ * check-error-start
+static_assert.c:12:38: error: static assertion failed: "expected failure"
+ * check-error-end
+ */
+
-- 
2.5.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] sparse: add support for static assert
Date: Sat, 09 Jan 2016 13:54:41 +0000
Message-ID: <20160109135440.GA6833 () macpro ! local>
--------------------
On Wed, Jan 06, 2016 at 01:35:17PM -0500, Lance Richardson wrote:
> This patch introduces support for _Static_assert() in global,
> function, and struct/union declaration contexts (as currently supported
> by gcc).
> 
> Tested via:
>    - kernel build with C=1 CF=-D__CHECK_ENDIAN__
>    - build/check large code base making heavy use of _Static_assert()
>    - "make check" with added test case for static assert support

Nice, it was something that was indeed missing.

I have a few remarks, mostly nitpicking, here under.


Luc

> @@ -437,6 +443,10 @@ static struct init_keyword {
>  	{ "__restrict",	NS_TYPEDEF, .op = &restrict_op},
>  	{ "__restrict__",	NS_TYPEDEF, .op = &restrict_op},
>  
> +
> +	/* Static assertion */
> +	{ "_Static_assert", NS_TYPEDEF, .op = &static_assert_op },
> +

It seems a bit strange to me to use NS_TYPEDEF, as this is unrelated types.
OTOH, the other namespaces deosn't seems better suited,
and yes C11 define this as sort of declaration, so ...

> @@ -2004,6 +2014,27 @@ static struct token *parse_asm_declarator(struct token *token, struct decl_state
>  	return token;
>  }
>  
> +
> +static struct token *static_assert_specifier(struct token *token, struct decl_state *ctx)
> +{
> +	struct expression *expr = NULL;
> +	int val;
> +
> +	token = constant_expression(token->next, &expr);
> +	if (!expr)
> +		sparse_error(token->pos, "Expected constant expression");
> +	val = get_expression_value(expr);
> +	token = expect(token, ',', "after first argument of _Static_assert");
> +	token = parse_expression(token, &expr);
> +	token = expect(token, ')', "after second argument of _Static_assert");
> +
> +	if (!val)
> +		sparse_error(token->pos, "static assertion failed: %s",
> +                             show_string(expr->string));

By using token->pos here, the error message will indicate that the problem is
situated at the very end of the assertion; more exactly, at the ending ";".
This is a little annoying I find.
It would be better to use the some position as the expression
(expr->pos, or the same as for "Expected constant expression").

I find also a bit strange to have this sort of semantic check inside the parser.
 
> diff --git a/validation/static_assert.c b/validation/static_assert.c
> new file mode 100644
> index 0000000..baab346
> --- /dev/null
> +++ b/validation/static_assert.c
> @@ -0,0 +1,20 @@
> +_Static_assert(1, "global ok");
> +
> +struct foo {
> +	_Static_assert(1, "struct ok");
> +};
> +
> +void bar(void)
> +{
> +	_Static_assert(1, " func ok");
> +}
> +
> +_Static_assert(0, "expected failure");
> +/*
> + * check-name: static assertion
> + *
> + * check-error-start
> +static_assert.c:12:38: error: static assertion failed: "expected failure"
> + * check-error-end
> + */

It would be nice to add a few more test cases,
I'm thinbking to things like:
	static int f;
	_Static_assert(f, "non-constant expression");
	static int *p;
	_Static_assert(p, "non-integer expression");
	_Static_assert(0.1, "float expression");
	
	_Static_assert(!0 == 1, "non-trivial expression");
	
	static int array[4];
	_Static_assert(sizeof(array), "sizeof expression");
	
	static const char non_literal_string[] = "non literal string";
	_Static_assert(0, non_literal_string);

Also, what should happen with:
	_Static_assert(1 / 0, "invalid expression: should not show up?");
(The C11 standard is not clear to me, GCC outputs an "invalid expression"
message and ignore the assertion).

Finally, the standard also allow to place the assertion
inside a struct or union declaration; like:
	struct s {
		char c;
		_Static_assert(1, "inside struct");
	};
which is working fine.
And also, I think:
	struct s2 {
		char c;
		_Static_assert(sizeof(struct s) == 1, "own struct sizeof");
	};
which doesn't.


Yours,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Lance Richardson <lrichard () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] sparse: add support for static assert
Date: Mon, 11 Jan 2016 02:54:24 +0000
Message-ID: <1249921583.11998072.1452480864238.JavaMail.zimbra () redhat ! com>
--------------------
----- Original Message -----
> On Wed, Jan 06, 2016 at 01:35:17PM -0500, Lance Richardson wrote:
> > This patch introduces support for _Static_assert() in global,
> > function, and struct/union declaration contexts (as currently supported
> > by gcc).
> > 
> > Tested via:
> >    - kernel build with C=1 CF=-D__CHECK_ENDIAN__
> >    - build/check large code base making heavy use of _Static_assert()
> >    - "make check" with added test case for static assert support
> 
> Nice, it was something that was indeed missing.
> 
> I have a few remarks, mostly nitpicking, here under.

Hi Luc, thanks for taking the time to review this.

> 
> 
> Luc
> 
> > @@ -437,6 +443,10 @@ static struct init_keyword {
> >  	{ "__restrict",	NS_TYPEDEF, .op = &restrict_op},
> >  	{ "__restrict__",	NS_TYPEDEF, .op = &restrict_op},
> >  
> > +
> > +	/* Static assertion */
> > +	{ "_Static_assert", NS_TYPEDEF, .op = &static_assert_op },
> > +
> 
> It seems a bit strange to me to use NS_TYPEDEF, as this is unrelated types.
> OTOH, the other namespaces deosn't seems better suited,
> and yes C11 define this as sort of declaration, so ...

Agreed.

> 
> > @@ -2004,6 +2014,27 @@ static struct token *parse_asm_declarator(struct
> > token *token, struct decl_state
> >  	return token;
> >  }
> >  
> > +
> > +static struct token *static_assert_specifier(struct token *token, struct
> > decl_state *ctx)
> > +{
> > +	struct expression *expr = NULL;
> > +	int val;
> > +
> > +	token = constant_expression(token->next, &expr);
> > +	if (!expr)
> > +		sparse_error(token->pos, "Expected constant expression");
> > +	val = get_expression_value(expr);
> > +	token = expect(token, ',', "after first argument of _Static_assert");
> > +	token = parse_expression(token, &expr);
> > +	token = expect(token, ')', "after second argument of _Static_assert");
> > +
> > +	if (!val)
> > +		sparse_error(token->pos, "static assertion failed: %s",
> > +                             show_string(expr->string));
> 
> By using token->pos here, the error message will indicate that the problem is
> situated at the very end of the assertion; more exactly, at the ending ";".
> This is a little annoying I find.
> It would be better to use the some position as the expression
> (expr->pos, or the same as for "Expected constant expression").

Will fix in v2.

> 
> I find also a bit strange to have this sort of semantic check inside the
> parser.

This prompted me to look at the gcc implementation, it appears that gcc also
processes _Static_assert() during parsing.

>  
> > diff --git a/validation/static_assert.c b/validation/static_assert.c
> > new file mode 100644
> > index 0000000..baab346
> > --- /dev/null
> > +++ b/validation/static_assert.c
> > @@ -0,0 +1,20 @@
> > +_Static_assert(1, "global ok");
> > +
> > +struct foo {
> > +	_Static_assert(1, "struct ok");
> > +};
> > +
> > +void bar(void)
> > +{
> > +	_Static_assert(1, " func ok");
> > +}
> > +
> > +_Static_assert(0, "expected failure");
> > +/*
> > + * check-name: static assertion
> > + *
> > + * check-error-start
> > +static_assert.c:12:38: error: static assertion failed: "expected failure"
> > + * check-error-end
> > + */
> 
> It would be nice to add a few more test cases,
> I'm thinbking to things like:
> 	static int f;
> 	_Static_assert(f, "non-constant expression");
> 	static int *p;
> 	_Static_assert(p, "non-integer expression");
> 	_Static_assert(0.1, "float expression");
> 	
> 	_Static_assert(!0 == 1, "non-trivial expression");
> 	
> 	static int array[4];
> 	_Static_assert(sizeof(array), "sizeof expression");
> 	
> 	static const char non_literal_string[] = "non literal string";
> 	_Static_assert(0, non_literal_string);
> 

Will do.

> Also, what should happen with:
> 	_Static_assert(1 / 0, "invalid expression: should not show up?");
> (The C11 standard is not clear to me, GCC outputs an "invalid expression"
> message and ignore the assertion).

v2 will output something like "invalid constant integer expression".

> 
> Finally, the standard also allow to place the assertion
> inside a struct or union declaration; like:
> 	struct s {
> 		char c;
> 		_Static_assert(1, "inside struct");
> 	};
> which is working fine.
> And also, I think:
> 	struct s2 {
> 		char c;
> 		_Static_assert(sizeof(struct s) == 1, "own struct sizeof");
> 	};
> which doesn't.

The second case should work (unless you intended "sizeof(struct s2)"), the v2
implementation will be a little different to address this issue.

> 
> 
> Yours,
> Luc
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 

Thanks again for the feedback, I'll send v2 of the patch in the next few days.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: update __builtin_object_size() prototype ===

From: Lance Richardson <lrichard () redhat ! com>
To: linux-sparse
Subject: [PATCH] sparse: update __builtin_object_size() prototype
Date: Wed, 21 Sep 2016 14:13:58 +0000
Message-ID: <1474467238-20939-1-git-send-email-lrichard () redhat ! com>
--------------------
Sparse emits a large number of warnings for the linux kernel source
tree of the form:
    ./arch/x86/include/asm/uaccess.h:735:18: \
        warning: incorrect type in argument 1 (different modifiers)
    ./arch/x86/include/asm/uaccess.h:735:18:    expected void *<noident>
    ./arch/x86/include/asm/uaccess.h:735:18:    got void const *from

Fix by making the first parameter to __builtin_object_size()
type "const void *" instead of "void *", which is consistent with GCC
behavior (the prototype for this builtin in GCC documentation is evidently
incorrect).

Signed-off-by: Lance Richardson <lrichard@redhat.com>
---
 lib.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib.c b/lib.c
index aa2af68..122dd6f 100644
--- a/lib.c
+++ b/lib.c
@@ -917,7 +917,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long double __builtin_nanl(const char *);\n");
 
 	/* And some __FORTIFY_SOURCE ones.. */
-	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(void *, int);\n");
+	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(const void *, int);\n");
 	add_pre_buffer ("extern void * __builtin___memcpy_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
 	add_pre_buffer ("extern void * __builtin___memmove_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
 	add_pre_buffer ("extern void * __builtin___mempcpy_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
-- 
2.5.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC v2 0/3] sparse: Introduce __private to privatize members of structs ===

From: "Paul E. McKenney" <paulmck () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC v2 0/3] sparse: Introduce __private to privatize members of structs
Date: Mon, 04 Jan 2016 22:21:53 +0000
Message-ID: <20160104222153.GH32217 () linux ! vnet ! ibm ! com>
--------------------
On Tue, Dec 29, 2015 at 12:18:45PM +0800, Boqun Feng wrote:
> Hi all,
> 
> This is v2 of __private.
> 
> Link for v1: http://marc.info/?l=linux-sparse&m=144988906932520&w=2
> 
> Change since v1:
> 
> *	#undef __irqd_to_state after used (Peter Zijlstra)
> 
> 
> This patchset introduces a __private modifier for sparse to detect misuses of
> private members of structs. This could make maintenace a little easier and
> prevent some potential bugs.
> 
> 
> This patchset consists of three patches:
> 
> 1.	Introduce __private and related macro, also improve compiler.h a litte
> 	bit
> 
> 2.	Privatize rcu_node::lock
> 
> 3.	Privatize irq_common_data::state_use_accessors
> 
> This patchset is against
> 
> 	-rcu/rcu/next	c95a158356397844a5a6deb0bd58758084f891df
> 
> because it depends on commits:
> 	
> 	"rcu: Create transitive rnp->lock acquisition functions"
> and
> 	"rcu: Add transitivity to remaining rcu_node ->lock acquisitions
> 
> 
> Tested by 0day.
> 
> Looking forward to any suggestion, question and comment ;-)

Queued for review and testing, along with Thomas's Reviewed-by.  If all
goes well, I expect to send them upstream in the 4.6 merge window.

							Thanx, Paul

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [kbuild-all] [kvm:queue 27/38] arch/x86/kvm/hyperv.c:186:41: sparse: incorrect type in argument ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [kbuild-all] [kvm:queue 27/38] arch/x86/kvm/hyperv.c:186:41: sparse: incorrect type in argument 
Date: Tue, 05 Jan 2016 13:51:57 +0000
Message-ID: <20160105135156.GB1044 () macpro ! local>
--------------------
On Fri, Sep 18, 2015 at 11:06:44PM +0800, Fengguang Wu wrote:
> [CC sparse people]
> 
> On Fri, Sep 18, 2015 at 04:41:56PM +0200, Paolo Bonzini wrote:
> > 
> > 
> > On 18/09/2015 16:40, Roman Kagan wrote:
> > > typedef unsigned long __nocast cputime_t;
> > > 
> > > extern void task_cputime_adjusted(cputime_t *);
> > > extern void current_task_runtime_100ns(void);
> > > 
> > > void current_task_runtime_100ns(void)
> > > {
> > >         cputime_t utime;
> > > 
> > >         task_cputime_adjusted(&utime);
> > > }
> > > %%% gcc -c x.c -Wall -Werror -O2; echo $?
> > > 0
> > > %%% sparse x.c
> > > x.c:16:32: warning: incorrect type in argument 1 (different modifiers)
> > > x.c:16:32:    expected unsigned long [nocast] [usertype] *<noident>
> > > x.c:16:32:    got unsigned long *<noident>
> > > x.c:16:32: warning: implicit cast to nocast type
> > > 
> > > Looks like a sparse bug to me.
> > 
> > Indeed...
> > 
> > Paolo

The problem is that the intent and semantic of 'nocast' is not clear at all.
There is an explanation about 'nocast' vs. 'bitwise' here:
	https://git.kernel.org/cgit/devel/sparse/sparse.git/tree/Documentation/sparse.txt
but it doesn't give much info about the exact wanted behaviour.

Since for the kernel 'nocast' is only used for cputime_t & cputime64_t,
I think it should be clarified and fixed if needed.
A patch proposal is following.

Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: arm64: implement live patching ===

From: Miroslav Benes <mbenes () suse ! cz>
To: linux-sparse
Subject: Re: arm64: implement live patching
Date: Tue, 12 Jul 2016 09:47:41 +0000
Message-ID: <alpine.LNX.2.00.1607121141480.16277 () pobox ! suse ! cz>
--------------------
On Mon, 11 Jul 2016, Jessica Yu wrote:

> +++ Miroslav Benes [11/07/16 16:03 +0200]:
> > On Mon, 27 Jun 2016, Torsten Duwe wrote:
> > 
> > > diff --git a/arch/arm64/include/asm/livepatch.h
> > > b/arch/arm64/include/asm/livepatch.h
> > > new file mode 100644
> > > index 0000000..6b9a3d1
> > > --- /dev/null
> > > +++ b/arch/arm64/include/asm/livepatch.h
> > > @@ -0,0 +1,37 @@
> > > +/*
> > > + * livepatch.h - arm64-specific Kernel Live Patching Core
> > > + *
> > > + * Copyright (C) 2016 SUSE
> > > + *
> > > + * This program is free software; you can redistribute it and/or
> > > + * modify it under the terms of the GNU General Public License
> > > + * as published by the Free Software Foundation; either version 2
> > > + * of the License, or (at your option) any later version.
> > > + *
> > > + * This program is distributed in the hope that it will be useful,
> > > + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> > > + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> > > + * GNU General Public License for more details.
> > > + *
> > > + * You should have received a copy of the GNU General Public License
> > > + * along with this program; if not, see <http://www.gnu.org/licenses/>.
> > > + */
> > > +#ifndef _ASM_ARM64_LIVEPATCH_H
> > > +#define _ASM_ARM64_LIVEPATCH_H
> > > +
> > > +#include <linux/module.h>
> > > +#include <linux/ftrace.h>
> > > +
> > > +#ifdef CONFIG_LIVEPATCH
> > 
> > A nit but we removed such guards in the other header files.
> > 
> > > +static inline int klp_check_compiler_support(void)
> > > +{
> > > +	return 0;
> > > +}
> > > +
> > > +static inline void klp_arch_set_pc(struct pt_regs *regs, unsigned long
> > > ip)
> > > +{
> > > +	regs->pc = ip;
> > > +}
> > > +#endif /* CONFIG_LIVEPATCH */
> > 
> > I also checked mod_arch_specific structure because of the way we deal
> > with relocations. It is defined only if CONFIG_ARM64_MODULE_PLTS is
> > enabled and there is a pointer to 'struct elf64_shdr' called plt. It is
> > used indirectly in apply_relocate_add() so we need it to stay. However it
> > points to an existing Elf section and SHF_ALLOC is added to its sh_flags
> > in module_frob_arch_sections() (arch/arm64/kernel/module-plts.c).
> > Therefore we should be ok.
> > 
> > Jessica, could you check it as well, please?
> 
> That sounds right, the plt will remain in module core memory, so we
> are fine there.
> 
> However I think the plt->sh_size calculation will be incorrect for
> livepatch modules. In calculating mod->arch.plt_max_entries (see:
> module-plts.c), count_plts() is called for every rela section.
> For livepatch modules, this means count_plts() will also be called for
> our .klp.rela sections, which is correct behavior. However,
> count_plts() only considers relas referring to SHN_UNDEF symbols, and
> since every rela in a klp rela section refers to a SHN_LIVEPATCH
> symbol, these are all ignored. So count_plts() may return an incorrect
> value for a klp rela section.

You're right. During the patch module creation we basically transform all 
SHN_UNDEF relas to SHN_LIVEPATCH, right? We must take it into account 
here.
 
> Miroslav, can you confirm the issue? I think the fix would be easy
> though; we can just add an additional check for SHN_LIVEPATCH in
> count_plts(). 

Yes, such a check should be sufficient.

Thanks for looking into it.
Miroslav
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: cgcc and -Dx86_64 ===

From: Joe Lawrence <joe.lawrence () redhat ! com>
To: linux-sparse
Subject: cgcc and -Dx86_64
Date: Wed, 21 Dec 2016 16:07:44 +0000
Message-ID: <13736b0d-b29a-0118-6846-f08bb3bb76f4 () redhat ! com>
--------------------
Hello linux-sparse,

I was trying to run sparse against the upstream kpatch project and ran
into problems with an include file that defined an "x86_64" variable:

% git clone https://github.com/dynup/kpatch
% cd kpatch/kpatch-build

% ~/sparse/cgcc -v -MMD -MP -I../kmod/patch -Iinsn -Wall -g -Werror -c
-o create-diff-object.o create-diff-object.c

sparse -v --debug -MMD -MP -I../kmod/patch -Iinsn -Wall -g -Werror -c -o
create-diff-object.o create-diff-object.c -Dx86_64=1 -D__x86_64=1
-D__x86_64__=1 -D__LP64__=1 -D__CHAR_BIT__=8 -D__SCHAR_MAX__=127
-D__SHRT_MAX__=32767 -D__INT_MAX__=2147483647
-D__LONG_MAX__=9223372036854775807L
-D__LONG_LONG_MAX__=9223372036854775807LL
-D__LONG_LONG_LONG_MAX__=170141183460469231731687303715884105727LLL
-D__FLT_RADIX__=2 -D__FINITE_MATH_ONLY__=0 -D__DECIMAL_DIG__=33
-D__FLT_MANT_DIG__=24 -D__FLT_DIG__=6 -D__FLT_MIN_EXP__='(-125)'
-D__FLT_MAX_EXP__=128 -D__FLT_MIN_10_EXP__='(-37)'
-D__FLT_MAX_10_EXP__=38 -D__FLT_HAS_INFINITY__=1
-D__FLT_HAS_QUIET_NAN__=1 -D__FLT_DENORM_MIN__=1.40129846e-45F
-D__FLT_EPSILON__=1.19209290e-7F -D__FLT_MAX__=3.40282347e+38F
-D__FLT_MIN__=1.17549435e-38F -D__DBL_MANT_DIG__=53 -D__DBL_DIG__=15
-D__DBL_MIN_EXP__='(-1021)' -D__DBL_MAX_EXP__=1024
-D__DBL_MIN_10_EXP__='(-307)' -D__DBL_MAX_10_EXP__=308
-D__DBL_HAS_INFINITY__=1 -D__DBL_HAS_QUIET_NAN__=1
-D__DBL_DENORM_MIN__=4.9406564584124654e-324
-D__DBL_EPSILON__=2.2204460492503131e-16
-D__DBL_MAX__=1.7976931348623157e+308
-D__DBL_MIN__=2.2250738585072014e-308 -D__LDBL_MANT_DIG__=113
-D__LDBL_DIG__=33 -D__LDBL_MIN_EXP__='(-16381)' -D__LDBL_MAX_EXP__=16384
-D__LDBL_MIN_10_EXP__='(-4931)' -D__LDBL_MAX_10_EXP__=4932
-D__LDBL_HAS_INFINITY__=1 -D__LDBL_HAS_QUIET_NAN__=1
-D__LDBL_DENORM_MIN__=6.47517511943802511092443895822764655e-4966L
-D__LDBL_EPSILON__=1.92592994438723585305597794258492732e-34L
-D__LDBL_MAX__=1.18973149535723176508575932662800702e+4932L
-D__LDBL_MIN__=3.36210314311209350626267781732175260e-4932L
-U__SIZE_TYPE__ -D__SIZE_TYPE__=long\ unsigned\ int
-D__SIZEOF_POINTER__=8 -Dunix=1 -D__unix=1 -D__unix__=1 -D__linux__=1
-D__linux=1 -Dlinux=linux -gcc-base-dir /usr/lib/gcc/x86_64-linux-gnu/5/
-multiarch-dir x86_64-linux-gnu

insn/asm/insn.h:65:23: error: expected ; at end of declaration
insn/asm/insn.h:65:23: error: Expected } at end of
struct-union-enum-specifier
insn/asm/insn.h:65:23: error: got 1
insn/asm/insn.h:69:1: error: Expected ; at the end of type declaration
insn/asm/insn.h:69:1: error: got }
insn/asm/insn.h:99:65: error: Expected ) in function declarator
insn/asm/insn.h:99:65: error: got 1
create-diff-object.c:914:53: error: no member 'next_byte' in struct insn


I can avoid this by renaming the structure member to something like
"foo_x86_64".  I believe the problem stems from cgcc passing "-Dx86_64"
to gcc... sparse later gets confused as there is now a preprocessor
variable defined with the same name.

We could s/x86_64/something_else/g across the whole project to avoid
this glitch, but was wondering if there was a better way.  IMHO,
"x86_64" is a reasonable name that a developer might want to use... I
can't find any documentation that this is a (gcc) reserved keyword.

Advice appreciated... thanks!

-- Joe
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: dissect: teach do_expression() to handle EXPR_OFFSETOF ===

From: Lance Richardson <lrichard () redhat ! com>
To: linux-sparse
Subject: Re: dissect: teach do_expression() to handle EXPR_OFFSETOF
Date: Mon, 26 Sep 2016 17:52:15 +0000
Message-ID: <20160926175213.GA31182 () thinkcentre>
--------------------
+++ Oleg Nesterov [08/02/16 14:26 +0100]:
>Starting from a194f3e0 "implement __builtin_offsetof()" sparse handles
>offsetof() internally but dissect.c wasn't updated.
>
>Test case:
>
>	struct S { int m; };
>
>	void func(void)
>	{
>		__builtin_offsetof(struct S, m);
>	}
>
>before this patch:
>
>	3:6   g def  func                             void ( ... )
>	T.c:5:38: warning: bad expr->type: 30
>
>after:
>
>	3:6   g def  func                             void ( ... )
>	1:8   s def  S
>	5:38  s ---  S.m                              int
>
>While at it, update my email.
>
>Signed-off-by: Oleg Nesterov <oleg@redhat.com>

LGTM, builds and test case works as expected.
Acked-by: Lance Richardson <lrichard@redhat.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: dissect: teach do_initializer() to handle the nested EXPR_IDENTIFIER's ===

From: Lance Richardson <lrichard () redhat ! com>
To: linux-sparse
Subject: Re: dissect: teach do_initializer() to handle the nested EXPR_IDENTIFIER's
Date: Mon, 26 Sep 2016 17:54:52 +0000
Message-ID: <20160926175450.GA31313 () thinkcentre>
--------------------
+++ Oleg Nesterov [08/02/16 16:13 +0100]:
>do_initializer() is very limited/buggy but it was able to parse the kernel
>code until ftrace started to use ".a.b = x" rather than ".a = { .b = x }"
>in initializers.
>
>Test-case:
>
>	struct O {
>		struct I {
>			int mem;
>		} inn;
>		int end;
>	} var = {
>		.inn.mem = 0,
>		0,
>	};
>
>before the patch:
>
>	1:8   s def  O
>	2:16  s def  I
>	6:3   g def  var                              struct O
>	6:3   g -w-  var                              struct O
>	7:10  s -w-  O.inn                            struct I
>	7:10  s -w-  I.*                              struct I
>	I.c:7:14: warning: bad expr->type: 25
>	8:9   s -w-  O.end                            int
>
>after:
>
>	1:8   s def  O
>	2:16  s def  I
>	6:3   g def  var                              struct O
>	6:3   g -w-  var                              struct O
>	7:10  s -w-  O.inn                            struct I
>	7:14  s -w-  I.mem                            int
>	8:9   s -w-  O.end                            int
>
>Signed-off-by: Oleg Nesterov <oleg@redhat.com>
>---
LGTM, builds and test case works as expected.
Acked-by: Lance Richardson <lrichard@redhat.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: error: ctype on uninitialized symbol ===

From: Bob Copeland <me () bobcopeland ! com>
To: linux-sparse
Subject: error: ctype on uninitialized symbol
Date: Mon, 01 Feb 2016 19:44:09 +0000
Message-ID: <20160201194409.GA15047 () localhost>
--------------------
Hi all,

I'm seeing the following error when running sparse with latest HEAD,
against the small test case at the end:

$ sparse sparse-test.c
[garbage]:0:0: error: ctype on uninitialized symbol 0x696ec0

I am getting this with calls to time_after(..., msecs_to_jiffies()) in my
kernel build.

Below, the "1UL + 1L" is a stand-in for MAX_JIFFY_OFFSET, and the value
has to be some operation on two different types to trigger for me (e.g.
1UL + 1UL will run without error).  Taking out the typecheck macro will
also remove the error.

Any thoughts?

$ sparse --version
v0.5.0-44-g40791b9

sparse-test.c:

#define typecheck(type,x) \
({	type __dummy; \
	typeof(x) __dummy2; \
	(void)(&__dummy == &__dummy2); \
	1; \
})

#define time_after(a,b)		\
	(typecheck(unsigned long, a) && \
	 typecheck(unsigned long, b) && \
	 ((long)((b) - (a)) < 0))

static inline unsigned long y(void)
{
	return 1UL+1L;
}

static void x(void)
{
	int c = time_after(1UL, y());
}

-- 
Bob Copeland %% http://bobcopeland.com/
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

