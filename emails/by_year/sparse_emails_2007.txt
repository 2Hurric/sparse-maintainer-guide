--- Emails for Year 2007 ---

=== Thread: '$' as "valid" character in identifiers ===

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Wed, 23 May 2007 22:00:28 +0000
Message-ID: <4654B97C.7090100 () redhat ! com>
--------------------
Michael Stefaniuc wrote:
> echo 'int dollar$ = 1;' > /tmp/dollar.c
> gcc -c -Wall -Wextra -o /tmp/dollar.o /tmp/dollar.c
> echo $?
> 0
> No comment ...
> 
> I didn't find '$' as valid identifier character in "The C Programming
> Language (ANSI C)" nor does http://c0x.coding-guidelines.com/5.2.1.html
> allow it as valid char in the "source character set".
> 
> I found it because sparse tripped over that in the Wine source code.
> Yes, i already sent a patch to fix that in Wine.
> 
> Not sure if sparse should change its behavior here;
> cgcc -c -Wall -Wextra -o /tmp/dollar.o /tmp/dollar.c
> /tmp/dollar.c:1:11: error: Expected ; at end of declaration
> /tmp/dollar.c:1:11: error: got $
> is a adequate response.
On a second thought something like:
/tmp/dollar.c:1:11: error: Invalid character '%c' in identifier
would be a better answer and make it more obvious what the problem is.

bye
	michael
-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Wed, 23 May 2007 22:10:57 +0000
Message-ID: <alpine.LFD.0.98.0705231501430.3890 () woody ! linux-foundation ! org>
--------------------


On Wed, 23 May 2007, Michael Stefaniuc wrote:
> 
> I didn't find '$' as valid identifier character in "The C Programming
> Language (ANSI C)" nor does http://c0x.coding-guidelines.com/5.2.1.html
> allow it as valid char in the "source character set".

I think it was a common extension for some strange operating systems 
(read: VMS), where system symbols have "$" embedded in the name. So you'd 
have names like "sys$function()" for system functions.

It's possible others did it too - gcc says it's "traditional", but the 
only case I've seen it is from VMS (and thus from DEC->Compaq->HP C 
compilers).

But I certainly wouldn't object to sparse supporting it, although I would 
suggest that it at least warn by default.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 10:04:33 +0000
Message-ID: <20070524100433.GE4095 () ftp ! linux ! org ! uk>
--------------------
On Wed, May 23, 2007 at 03:10:57PM -0700, Linus Torvalds wrote:
> 
> 
> On Wed, 23 May 2007, Michael Stefaniuc wrote:
> > 
> > I didn't find '$' as valid identifier character in "The C Programming
> > Language (ANSI C)" nor does http://c0x.coding-guidelines.com/5.2.1.html
> > allow it as valid char in the "source character set".
> 
> I think it was a common extension for some strange operating systems 
> (read: VMS), where system symbols have "$" embedded in the name. So you'd 
> have names like "sys$function()" for system functions.
> 
> It's possible others did it too - gcc says it's "traditional", but the 
> only case I've seen it is from VMS (and thus from DEC->Compaq->HP C 
> compilers).
> 
> But I certainly wouldn't object to sparse supporting it, although I would 
> suggest that it at least warn by default.

The question is how do they treat $ in preprocessor tokens.  Is it a full
equivalent of letter?  I.e. is $x a valid identifier?  If it is, that's
easy - all we need is to add it cclass[] in tokenize.c as a letter and be
done with that.  If not (i.e. if it can only appear after the first
letter), we probably want to either classify it as digit or split the
"Digit" bit in two and modify the code checking for it.  In any case,
we need to figure out what to do with

#define A(x,y) x##y
A(a,$b)

Either $b is an identifier, or it would better be a valid pp-number; otherwise,
we'll get the second argument split in two tokens and get a$ b out of that
macro.

So far it's easy, but... generating a warning will be the nasty part.  We
certainly don't want it to be generated in tokenizer; after all,

#define A(x) #x
A($)

is legitimate, so we can't do anything until we are past preprocessor.
In any case, generating a warning on each instance of such identifier
would be an overkill.  So we'd have to do it somewhere around insertion
into symbol table.  And doing essentially strchr() in there is not
a nice thing - it's a hot path...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 11:14:03 +0000
Message-ID: <4655737B.7010701 () knosof ! co ! uk>
--------------------
Al,

> The question is how do they treat $ in preprocessor tokens.  Is it a full
> equivalent of letter?  I.e. is $x a valid identifier?  If it is, that's
> easy - all we need is to add it cclass[] in tokenize.c as a letter and be
> done with that.  If not (i.e. if it can only appear after the first
> letter), we probably want to either classify it as digit or split the
> "Digit" bit in two and modify the code checking for it.  In any case,
> we need to figure out what to do with
> 
> #define A(x,y) x##y
> A(a,$b)
> 
> Either $b is an identifier, or it would better be a valid pp-number; otherwise,
> we'll get the second argument split in two tokens and get a$ b out of that
> macro.

Item 10 of http://www.open-std.org/jtc1/sc22/wg14/www/docs/n861.htm
gives some history and possible solutions.

If an implementation supports $ in identifiers, then it is an extension.
Implementation extensions are blessed in C99 provided they don't change
the behavior of strictly conforming programs.  Since $ is not in the
basic source character set a program that contains them is not strictly
conforming.

If sparse supports $ then it just has to do what the implementation it
is mimicing does.  There is no C Standard behavior as such to worry about.

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 13:18:11 +0000
Message-ID: <46559093.5060908 () knosof ! co ! uk>
--------------------
Al,

> And now for reality: of course if we set out to imitate the implementation
> allowing $, we'd better imitate it.  The question is what to watch out
> for and how to avoid buggering the tokenizer in process.

If sparse is going to imitate a VAX implementation then how $ is glued
is probably the least of the implemention worries.

VAX C supported a whole host of extensions (eg, the ability to
glue comments, 8 & 9 in octal constants).

I have a pdf of the DEC C language reference manual for Tru64 which
people are welcome to a copy of.

> I don't have access to VMS boxen (thanks $DEITY);

Continuing in the vein of Irrelevant, AFAICS.  You can access various
Crays here: http://www.cray-cyber.org/access/index.php

Perhaps there is a similar site available for Vaxes?

> IOW, we need documentation of the native compilers to find out which kind
> of behaviour is expected.

I collect old C compiler manuals, if anybody locates a ps or pdf of
an original VAC C compiler manual, please forward me a copy.

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 14:10:15 +0000
Message-ID: <20070524141015.GG4095 () ftp ! linux ! org ! uk>
--------------------
On Thu, May 24, 2007 at 02:18:11PM +0100, Derek M Jones wrote:
> Al,
> 
> >And now for reality: of course if we set out to imitate the implementation
> >allowing $, we'd better imitate it.  The question is what to watch out
> >for and how to avoid buggering the tokenizer in process.
> 
> If sparse is going to imitate a VAX implementation then how $ is glued
> is probably the least of the implemention worries.

I suspect that the real issue is whatever stuff Windows uses (and no,
I don't have Windows boxen either).  Anybody who wants to work on
code that last compiled on VAX is not going to be happy with what
sparse will say about it, anyway.  More realistic case is a codebase
with some VMS ancestry that got moved to Windows.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 14:26:08 +0000
Message-ID: <20070524142608.GJ2547 () daikokuya ! co ! uk>
--------------------
Al Viro wrote:-

> > I think it was a common extension for some strange operating systems 
> > (read: VMS), where system symbols have "$" embedded in the name. So you'd 
> > have names like "sys$function()" for system functions.
> > 
> > It's possible others did it too - gcc says it's "traditional", but the 
> > only case I've seen it is from VMS (and thus from DEC->Compaq->HP C 
> > compilers).
> > 
> > But I certainly wouldn't object to sparse supporting it, although I would 
> > suggest that it at least warn by default.
> 
> The question is how do they treat $ in preprocessor tokens.  Is it a full
> equivalent of letter?  I.e. is $x a valid identifier?  If it is, that's

Apparently yes:

http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V50_HTML/ARH9NATE/DOCU_026.HTM

My personal opinion is we don't want to encourage $ in identifiers,
and so I'd urge you to drop the idea :).  Too many poor mis-featured
extensions in GCC already.  At least if you do go ahead it seems the
implementation is trivial (assembler aside).

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 14:35:14 +0000
Message-ID: <20070524143514.GK2547 () daikokuya ! co ! uk>
--------------------
Neil Booth wrote:-

> Apparently yes:
> 
> http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V50_HTML/ARH9NATE/DOCU_026.HTM

This one is more explicit:

http://www.kednos.com/pli/docs/REFERENCE_MANUAL/6291pro.html

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 14:36:56 +0000
Message-ID: <20070524143656.GL2547 () daikokuya ! co ! uk>
--------------------
> This one is more explicit:
> 
> http://www.kednos.com/pli/docs/REFERENCE_MANUAL/6291pro.html

Bah, never mind!  PL/I.

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 14:43:43 +0000
Message-ID: <4655A49F.4010300 () knosof ! co ! uk>
--------------------
Al,

> I suspect that the real issue is whatever stuff Windows uses (and no,
> I don't have Windows boxen either).  Anybody who wants to work on

I do wish I had kept all my old Microsoft C compiler manuals.
Microsoft do a very poor job of documenting the extensions they
support (which has changed over time).  This may be intentional
as a way of limiting use of those features (apparently when
British rial want to kill off a service they first remove all
details of it from the time tables; passenger numbers then drop
and they can kill the service off on the basis of low passenger
numbers travelling that route).

Does anybody here have any old (ie, versions 1-5) Microsoft C
compiler manuals?

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: '$' as "valid" character in identifiers
Date: Thu, 24 May 2007 14:50:15 +0000
Message-ID: <4655A627.2050403 () redhat ! com>
--------------------
Al Viro wrote:
> On Thu, May 24, 2007 at 02:18:11PM +0100, Derek M Jones wrote:
>>> And now for reality: of course if we set out to imitate the implementation
>>> allowing $, we'd better imitate it.  The question is what to watch out
>>> for and how to avoid buggering the tokenizer in process.
>> If sparse is going to imitate a VAX implementation then how $ is glued
>> is probably the least of the implemention worries.
> 
> I suspect that the real issue is whatever stuff Windows uses (and no,
> I don't have Windows boxen either).  Anybody who wants to work on
I do not know what VC++ is doing but the Win32 API has _no_ $ in 
identifiers whatsoever. The code over which sparse tripped was a 
variable defined in an else block in the winedump utility. And that is 
not even a Win32 application but a pure standard C one. I sent a patch 
to Wine to fix that (todays commit session didn't happen yet).

 From Wine point of view we do not need to handle the '$'.

> code that last compiled on VAX is not going to be happy with what
> sparse will say about it, anyway.  More realistic case is a codebase
> with some VMS ancestry that got moved to Windows.
Wine is not supported on VMS ;)

bye
	michael
-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Another sparse warning... ===

From: Anton Altaparmakov <aia21 () cam ! ac ! uk>
To: linux-sparse
Subject: Another sparse warning...
Date: Mon, 12 Feb 2007 10:23:38 +0000
Message-ID: <4975FCBA-D3D4-4DF2-AC20-C11A5F97DE51 () cam ! ac ! uk>
--------------------
Hi,

Again, using latest code from git://git.kernel.org/pub/scm/linux/ 
kernel/git/josh/sparse.git

When I run:  make CHECKFLAGS="-D__CHECK_ENDIAN__" C=2 modules

I get this warning:

   CHECK   fs/ntfs/super.c
fs/ntfs/super.c:3003:2: warning: context imbalance in  
'ntfs_fill_super' - unexpected unlock

And ntfs_fill_super does on entry:

unlock_kernel();

And then does "lock_kernel();" on exit.

Which is what causes the warning as the warning goes away if I remove  
it...

The unlock+lock was added by Ingo Molnar IIRC because ntfs_fill_super 
() was causing a huge latency which is bad for RT code...

It is a perfectly legitimate thing to do as the kernel lock is held  
by the VFS but NTFS does not need it as it locks everything  
appropriately internally.

What can I do to tell sparse that this code is ok and there should  
not be a warning?  Is there a "__ignore_context_imbalance" or  
something that I can mark up the {un,}lock_kernel() with or something  
like that?

Thanks a lot in advance!

Best regards,

	Anton
-- 
Anton Altaparmakov <aia21 at cam.ac.uk> (replace at with @)
Unix Support, Computing Service, University of Cambridge, CB2 3QH, UK
Linux NTFS maintainer, http://www.linux-ntfs.org/


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Another sparse warning...
Date: Mon, 12 Feb 2007 15:50:24 +0000
Message-ID: <Pine.LNX.4.64.0702120742030.8424 () woody ! linux-foundation ! org>
--------------------


On Mon, 12 Feb 2007, Anton Altaparmakov wrote:
> 
> What can I do to tell sparse that this code is ok and there should not be a
> warning?  Is there a "__ignore_context_imbalance" or something that I can mark
> up the {un,}lock_kernel() with or something like that?

No, you should annotate the function as already having the lock when 
entered.

What sparse warns about is not a locking imbalance (it's all balanced) but 
the fact that locking counts go negative (which is always a bug). And they 
go negative because you drop a lock that git didn't even know about 
(because it doesn't do global analysis - just per-function).

Now, you can either try to make sparsedo global analysis (which some 
people apparently really _are_ trying to do), or you can tell sparse that 
it holds a certain lock on entry, and is _supposed_ to release it. You can 
do that by annotating the function with __acquires/__releases():

	int myfunction(..)
		__releases(kernel_lock)
		__acquires(kernel_lock)
	{
		unlock_kernel();
		..
		lock_kernel();
	}

which does two things:

 - it shows the *programmer* that the function is doing somethign 
   "strange" (not really strange, but still: it's basically a fairly 
   readable way that it's doing locking in a weird way).

 - it tells sparse that the function is actually supposed to release the 
   lock and then re-acquire it.

This would also be how you annotate functions that really *are* 
unbalanced. Some functions get entered with a lock held, and release it, 
or the other way around (the simplest example of that is obviously the 
"__raw_spin_[un]lock()" functions themselves, but it's pretty common in 
"locking helper functions" too).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Anton Altaparmakov <aia21 () cam ! ac ! uk>
To: linux-sparse
Subject: Re: Another sparse warning...
Date: Mon, 12 Feb 2007 15:55:46 +0000
Message-ID: <BA2EBAD3-5474-44C5-B93B-34A40A8A0722 () cam ! ac ! uk>
--------------------
Hi Linus,

On 12 Feb 2007, at 15:50, Linus Torvalds wrote:
> On Mon, 12 Feb 2007, Anton Altaparmakov wrote:
>>
>> What can I do to tell sparse that this code is ok and there should  
>> not be a
>> warning?  Is there a "__ignore_context_imbalance" or something  
>> that I can mark
>> up the {un,}lock_kernel() with or something like that?
>
> No, you should annotate the function as already having the lock when
> entered.
[snip]
> 	int myfunction(..)
> 		__releases(kernel_lock)
> 		__acquires(kernel_lock)
> 	{
> 		unlock_kernel();
> 		..
> 		lock_kernel();
> 	}

Great, thanks!  That works a treat. (-:

Best regards,

	Anton
-- 
Anton Altaparmakov <aia21 at cam.ac.uk> (replace at with @)
Unix Support, Computing Service, University of Cambridge, CB2 3QH, UK
Linux NTFS maintainer, http://www.linux-ntfs.org/


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Another sparse warning...
Date: Tue, 13 Feb 2007 02:00:54 +0000
Message-ID: <20070213020054.GB2922 () chrisli ! org>
--------------------
On Mon, Feb 12, 2007 at 07:50:24AM -0800, Linus Torvalds wrote:
> 
> Now, you can either try to make sparsedo global analysis (which some 
> people apparently really _are_ trying to do), or you can tell sparse that 
> it holds a certain lock on entry, and is _supposed_ to release it. You can 
> do that by annotating the function with __acquires/__releases():
> 
> 	int myfunction(..)
> 		__releases(kernel_lock)
> 		__acquires(kernel_lock)

Aha. That is the purpose of ctype member "context_list *context".
I was puzzling about it when I am reading the context checking code.

Without knowing the input/output context stuff, this syntax is
really cryptic.

# define __acquire(x)	__context__(x,1)
# define __acquires(x)	__attribute__((context(x,0,1)))
# define __releases(x)	__attribute__((context(x,1,0)))

>  - it shows the *programmer* that the function is doing somethign 
>    "strange" (not really strange, but still: it's basically a fairly 
>    readable way that it's doing locking in a weird way).

Should the function declare in the header file has that as well?
When call one of those functions, it can know that function will change
context.  That might be a way to solve the problem that some of the
spinlock function is not a inline function at all.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Another sparse warning...
Date: Tue, 13 Feb 2007 04:21:52 +0000
Message-ID: <20070213042152.GC2922 () chrisli ! org>
--------------------
On Mon, Feb 12, 2007 at 07:48:18PM -0800, Linus Torvalds wrote:
> > When call one of those functions, it can know that function will change
> > context.  That might be a way to solve the problem that some of the
> > spinlock function is not a inline function at all.
> 
> I thought we did that already. I'm fairly sure I had this working at some 
> point - exactly by having the calls just add up the (known) lock/unlock 
> offsets.
>

You are right. It is already there. I never see it before because my ctags
get confused about the context annotation:

void __lockfunc _spin_lock(spinlock_t *lock)		__acquires(lock); 

It generate tags for "lock" instead of "_spin_lock".

When I look up _spin_lock, it only shows the UP version. I never see
the SMP version of the _spin_lock.

Exactly why I want to have a ctags from sparse.

Chris
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Another sparse warning...
Date: Tue, 13 Feb 2007 08:38:44 +0000
Message-ID: <45D17914.8040608 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig74FE9788F21B90D903351BAA
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Linus Torvalds wrote:
> On Mon, 12 Feb 2007, Christopher Li wrote:
>>>  - it shows the *programmer* that the function is doing somethign=20
>>>    "strange" (not really strange, but still: it's basically a fairly =

>>>    readable way that it's doing locking in a weird way).
>> Should the function declare in the header file has that as well?
>=20
> Yes.
>=20
>> When call one of those functions, it can know that function will chang=
e
>> context.  That might be a way to solve the problem that some of the
>> spinlock function is not a inline function at all.
>=20
> I thought we did that already. I'm fairly sure I had this working at so=
me=20
> point - exactly by having the calls just add up the (known) lock/unlock=
=20
> offsets.

On the other hand, the code currently does not check the context precondi=
tions
of the callee; Sparse *could* check that any function requiring you to ho=
ld a
lock (have a context of 1) must only get called from a context in which y=
ou
hold that lock (have that context).  Instead, Sparse only checks the cont=
ext
change, rather than the incoming context value at the call site.  It seem=
s
trivial to add a check for context preconditions, and Linux could then ha=
ve a
new annotation for __must_hold(lock) (usable on both functions and data),=
 but
that check would also add numerous false positives caused by lack of
annotation, and that problem seems better solved by interprocedural analy=
sis
than pervasive annotation.

Thoughts?

- Josh Triplett



--------------enig74FE9788F21B90D903351BAA
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF0XkUGJuZRtD+evsRAvTnAJ9i0i/WDxFMBT7E7ROTCjoNyuEA8QCfTvbq
JlCbXyHApGvxKwyZf6iEW68=
=GPHA
-----END PGP SIGNATURE-----

--------------enig74FE9788F21B90D903351BAA--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Another sparse warning...
Date: Tue, 13 Feb 2007 08:49:04 +0000
Message-ID: <45D17B80.8040905 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig357FA0243CC6AD10357C30B0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> On Mon, Feb 12, 2007 at 07:48:18PM -0800, Linus Torvalds wrote:
>>> When call one of those functions, it can know that function will chan=
ge
>>> context.  That might be a way to solve the problem that some of the
>>> spinlock function is not a inline function at all.
>> I thought we did that already. I'm fairly sure I had this working at s=
ome=20
>> point - exactly by having the calls just add up the (known) lock/unloc=
k=20
>> offsets.
>=20
> You are right. It is already there. I never see it before because my ct=
ags
> get confused about the context annotation:
>=20
> void __lockfunc _spin_lock(spinlock_t *lock)		__acquires(lock);=20
>=20
> It generate tags for "lock" instead of "_spin_lock".

Interesting behavior. :)  That makes sense, given ctags' regex-based pars=
ing.

About that syntax: I chose to use the parameter name there because I want=
ed to
use arbitrary expressions (like param_struct->lock) for a context, rather=
 than
a parameter number (as used in printf annotations).  I'd love to see any
thoughts you might have on how best to parse that expression into somethi=
ng
with "placeholders" for formal parameters, and then easily substitute the=

actual parameters at each call site to determine the expression for the
acquired or released context.  Then we need a solution for the more diffi=
cult
problem: unifying and tracking context expressions in the face of changin=
g
data in those expressions.

- Josh Triplett


--------------enig357FA0243CC6AD10357C30B0
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF0XuAGJuZRtD+evsRAj5uAKCGKKubJoFsJ5KkNvq3CeCYRjm32gCguSWP
pYUXwCE+JRMUq9LxrF/MDIQ=
=fJFP
-----END PGP SIGNATURE-----

--------------enig357FA0243CC6AD10357C30B0--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Antwort: Re: Differences in the behaviour of sparse and gcc within ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Antwort: Re: Differences in the behaviour of sparse and gcc within
Date: Mon, 21 May 2007 23:16:08 +0000
Message-ID: <46522838.4010407 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig9341BA9B30E416631F2F3C48
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Thomas Schmid wrote:
> I also tried to pre-process that code with cpp - but then I lose the=20
> position-data of the declarations i try to get info from.
> It's not possible to use cpp integrated in sparse, isn't it?

In theory, we could add support for the line-number information provided =
by
the GCC preprocessor.  That seems useful, though it can't provide as much=

information as Sparse's usual line-and-character information.

- Josh Triplett



--------------enig9341BA9B30E416631F2F3C48
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGUig4GJuZRtD+evsRAqsRAJ9r4By91rWeaPA5YFKqexWlqeBe1ACfUDGp
np/7rVspQNnO/MhEVVEp3As=
=O4Y4
-----END PGP SIGNATURE-----

--------------enig9341BA9B30E416631F2F3C48--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Antwort: Re: Differences in the behaviour of sparse and gcc within cygwin ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Antwort: Re: Differences in the behaviour of sparse and gcc within cygwin
Date: Mon, 21 May 2007 13:20:22 +0000
Message-ID: <OF74B9333A.379DA3FD-ONC12572E2.00493908-C12572E2.004946CC () br-automation ! com>
--------------------
linux-sparse-owner@vger.kernel.org schrieb am 18.05.2007 22:47:35:

> On Fri, May 18, 2007 at 01:43:11PM +0200, Thomas Schmid wrote:
> > 1. Symbolnames with "$" are accepted by gcc but not by sparse
> 
> ewww...  It's not hard to change, but I strongly recommend making it
> ifdefed and *not* included on sane boxen.  Rationale: that affects one
> of the hottest paths in the entire thing.
> 
> Who uses $ in identifiers, anyway, when it's guaranteed to be 
non-portable?
> gcc accepts it as a bloody misguided extension, but it's not standard C 
by
> any stretch of imagination.  What are you working with, a bunch of old 
code
> originating on VMS?
> 
> > 2. #include "..\plc.h" is accepted by gcc but not by sparse => "\" is 
> > interpreted as escape- character
> > 3. #include "D:\plc.h" is accepted by gcc but not by sparse
> 
> *argh*
;-) Really that bad?
> 
> sparse takes a shortcut - it treats header-name as string-literal.  In
> principle, these are distinct tokens.  We could try to change that, 
but...
> that makes tokenizer context-dependent in a fairly upleasant way.
> 
> Note that \ in header-name is explicitly undefined behaviour (6.4.7(3)),
> and compilers I've seen on weird systems of that kind tend to remap / on 
\
> in header names anyway before trying to look for files to include.

The code which I like to use sparse with, is some sort of living 3rd party 
thing. 
I fear, these are not the only "misguided extensions" used, which work 
with cygwin GCC 2.95.3.

I also tried to pre-process that code with cpp - but then I lose the 
position-data of the declarations i try to get info from.
It's not possible to use cpp integrated in sparse, isn't it?


Best regards 
Thomas Schmid
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Antwort: Re: Finding all typedefs ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Antwort: Re: Finding all typedefs
Date: Thu, 02 Aug 2007 07:31:34 +0000
Message-ID: <OF8B0579A2.47A003A7-ONC125732B.00280B65-C125732B.00295803 () br-automation ! com>
--------------------
linux-sparse-owner@vger.kernel.org schrieb am 02.08.2007 02:15:34:

> Another annoying thing is that the types are always resolved for
> typedefs. i.e. for
> 
> typedef int foo;
> foo bar;
> 
> the symbol for bar has a base type of int.

...and a base_type->ident named "foo". But if you add another typedef on 
"int", i.e.

        typedef int DINT; 

base_type->ident changes to "DINT", now there's no way to get out, that 
symbol "bar" was declared with "foo".
Tell me if I'm wrong, but a solution for this would also help me on that:
http://marc.info/?l=linux-sparse&m=118171213001092&w=2

> Any suggestions for how to solve this would be greatly appreciated :)
I agree! ;-)

Best regards,
Thomas Schmid
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rob Taylor <rob.taylor () codethink ! co ! uk>
To: linux-sparse
Subject: Re: Antwort: Re: Finding all typedefs
Date: Fri, 03 Aug 2007 00:49:19 +0000
Message-ID: <46B27B8F.2040008 () codethink ! co ! uk>
--------------------
This is a multi-part message in MIME format.
--------------010001070006030601080307
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

Thomas Schmid wrote:
> linux-sparse-owner@vger.kernel.org schrieb am 02.08.2007 02:15:34:
> 
>> Another annoying thing is that the types are always resolved for
>> typedefs. i.e. for
>>
>> typedef int foo;
>> foo bar;
>>
>> the symbol for bar has a base type of int.
> 
> ...and a base_type->ident named "foo". But if you add another typedef on 
> "int", i.e.
> 
>         typedef int DINT; 
> 
> base_type->ident changes to "DINT", now there's no way to get out, that 
> symbol "bar" was declared with "foo".
> Tell me if I'm wrong, but a solution for this would also help me on that:
> http://marc.info/?l=linux-sparse&m=118171213001092&w=2
> 
>> Any suggestions for how to solve this would be greatly appreciated :)
> I agree! ;-)


Ok, I've hacked up a little patch that does a small bit of the job
(attached), but this breaks comparisons to abstract types (and probably
a whole load more besides). I'll carry on hacking this some more and see
if I can sort those issues, but I'd greatly appreciate some input from
anyone with deeper knowledge!

Thanks,
Rob Taylor

--------------010001070006030601080307
Content-Type: text/x-patch;
 name="0001-cracked-ideas-to-track-user-types.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="0001-cracked-ideas-to-track-user-types.patch"


================================================================================


################################################################################

=== Thread: Antwort: Re: Re: [PATCH 15/16] deal with enum members without excessive ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Antwort: Re: Re: [PATCH 15/16] deal with enum members without excessive
Date: Mon, 17 Dec 2007 13:15:19 +0000
Message-ID: <OF0F2A6E0A.ED6B87EA-ONC12573B4.004679D1-C12573B4.0048D048 () br-automation ! com>
--------------------
christ.li@gmail.com schrieb am 14.12.2007 22:01:03:

> Can you try the attached patch?
> 
> Chris
> [Anhang "enum-members" gel√∂scht von Thomas Schmid/Graz/AT/B&R] 

Thank you very much, works like expected!
What's the procedure to get this patch into the git-tree?

Best regards,
Thomas Schmid

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Antwort: Re: [PATCH 15/16] deal with enum members without excessive PITA ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Antwort: Re: [PATCH 15/16] deal with enum members without excessive PITA
Date: Fri, 14 Dec 2007 12:09:25 +0000
Message-ID: <OF6BBF04CB.C9CFEDC1-ONC12573B1.003FBE96-C12573B1.0042C7E1 () br-automation ! com>
--------------------
linux-sparse-owner@vger.kernel.org schrieb am 14.12.2007 01:18:21:

> It seems there is not good way to get the enum members from the parent 
symbol.
How about the idea, looping over the syms within global_scope?

> It should be trivial make a patch to add members to the parent
> symbol->symbol_list though.
Would you possibly?

Best regards
Thomas Schmid
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Apostrophes confuse preprocessor ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Apostrophes confuse preprocessor
Date: Thu, 12 Jul 2007 16:33:47 +0000
Message-ID: <1184258027.9594.9.camel () dv>
--------------------
Hello!

Sparse reports errors for apostrophes in preprocessor directives.  To
make things worse, it suppresses all useful warnings in the file.

$ cat test.c
#error Don't do it
$ sparse test.c 
test.c:1:13: error: Bad character constant
test.c:1:2: error: Don do it
$ gcc test.c
test.c:1:2: error: #error Don't do it
$

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: BUG: sparse redeclaration warning when assigning to a declared ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: BUG: sparse redeclaration warning when assigning to a declared
Date: Thu, 08 Mar 2007 18:06:30 +0000
Message-ID: <Pine.LNX.4.64.0703081003400.10832 () woody ! linux-foundation ! org>
--------------------


On Thu, 8 Mar 2007, Blaisorblade wrote:
>
> Code giving one of these warnings (kernel tree 2.6.20.1), other warnings are 
> like this. I.e.:
> ret = something()
> is seen as redeclaration.

No. Sparse is actually correct, but you didn't notice that there is 
*another* "ret" there.

See how TestClearPageWriteback() is declared in <linux/page-flags.h>. THAT 
is the "ret" that shadows an earlier one..

(And no, a macro should not use a common name like that - imagine if you 
call it with an argument that really is "struct page *ret", and thing what 
happens to the TestClearPageWritepage expansion..)

So sparse in this case does seem to be pointing out a potentially 
dangerous situation, where a macro declares a local variable with the same 
name as a user of that macro.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: BUG: sparse redeclaration warning when assigning to a declared variable! ===

From: Blaisorblade <blaisorblade () yahoo ! it>
To: linux-sparse
Subject: BUG: sparse redeclaration warning when assigning to a declared variable!
Date: Thu, 08 Mar 2007 17:53:15 +0000
Message-ID: <200703081853.15693.blaisorblade () yahoo ! it>
--------------------
What I saw running sparse on Linux source tree:

paolo [linux-2.6.20] $ make C=2 mm/page-writeback.o
  CHK     include/linux/version.h
  CHK     include/linux/utsrelease.h
  CHECK   scripts/mod/empty.c
  CHECK   mm/page-writeback.c
mm/page-writeback.c:912:9: warning: symbol 'ret' shadows an earlier one
mm/page-writeback.c:906:6: originally declared here
mm/page-writeback.c:919:9: warning: symbol 'ret' shadows an earlier one
mm/page-writeback.c:906:6: originally declared here
mm/page-writeback.c:933:9: warning: symbol 'ret' shadows an earlier one
mm/page-writeback.c:927:6: originally declared here
mm/page-writeback.c:944:9: warning: symbol 'ret' shadows an earlier one
mm/page-writeback.c:927:6: originally declared here
  CC      mm/page-writeback.o

Code giving one of these warnings (kernel tree 2.6.20.1), other warnings are 
like this. I.e.:
ret = something()
is seen as redeclaration.

int test_set_page_writeback(struct page *page)
{
        struct address_space *mapping = page_mapping(page);
        int ret;

        if (mapping) {
                unsigned long flags;

                write_lock_irqsave(&mapping->tree_lock, flags);
                ret = TestSetPageWriteback(page);
                if (!ret)
                        radix_tree_tag_set(&mapping->page_tree,
                                                page_index(page),
                                                PAGECACHE_TAG_WRITEBACK);
                if (!PageDirty(page))
                        radix_tree_tag_clear(&mapping->page_tree,
                                                page_index(page),
                                                PAGECACHE_TAG_DIRTY);
                write_unlock_irqrestore(&mapping->tree_lock, flags);
        } else {
                ret = TestSetPageWriteback(page);
        }
        return ret;

}

Tested with both sparse v0.2 and my git HEAD, where I get:

sparse.git $ git-describe
0.2-41-g309f380

Bye
-- 
Inform me of my mistakes, so I can add them to my list!
Paolo Giarrusso, aka Blaisorblade
http://www.user-mode-linux.org/~blaisorblade
Chiacchiera con i tuoi amici in tempo reale! 
 http://it.yahoo.com/mail_it/foot/*http://it.messenger.yahoo.com 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Backend projects for Sparse ===

From: nkavv () physics ! auth ! gr
To: linux-sparse
Subject: Backend projects for Sparse
Date: Wed, 28 Nov 2007 09:53:00 +0000
Message-ID: <1196243580.474d3a7c9895b () mail ! physics ! auth ! gr>
--------------------
Hi all

i came across Sparse a few months ago and looks really interesting. Now, I have
a few questions regarding the sparse infrastructure:

1) Regarding the intermediate representation dumps that can be generated (via
"test-linearize" i think). Do you support canonical SSA form (as defined in the
classical books/papers)?

2) Is it possible to generate a self-contained IR dump, so that it could be
possible to feed it to external (third-party) code selectors?
In my mind a single C program file (actually read: translation unit) would be
translated to something like the following structure:

struct CTranslationUnit {
  struct GlobalVars; // is a List of global variables (scalars, arrays etc)
  struct ProcedureList;
}

struct ProcedureList
{
  struct LocalVars;  // local variable list
  List   ThreeAddressCodeInstr; // three-address code operations (4-tuples)
}

There a couple of frontends that can do this (the proprietary/no cost for
research only LANCE compiler frontend).

3) What does the c2xml backend exactly do?

4) Is there anyone working on a RISC-like processor backend project. I feel that
 if the entire backend can be contained in something like "compile-i386.c" then
it could be even possible to automate the generation of such file from a more
compact specification file. (plus some hand-written intrinsics probably).

5) Is there any documentation covering the API and linked tools to the sparse
library (something more than the man pages)?

6) Sparse looks good. I like the IR dumps a lot. That's a comment ^_^

Kind regards,
Nikolaos Kavvadias

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Backend projects for Sparse
Date: Wed, 28 Nov 2007 18:53:23 +0000
Message-ID: <70318cbf0711281053k6dc561c5ge540ccd99a6a922e () mail ! gmail ! com>
--------------------
On Nov 28, 2007 1:53 AM,  <nkavv@physics.auth.gr> wrote:
> 1) Regarding the intermediate representation dumps that can be generated (via
> "test-linearize" i think). Do you support canonical SSA form (as defined in the
> classical books/papers)?

It does support SSA from for internal variable(pseudo in
linearization). Not sure
what kind of "canonical SSA" do you have in mind.

>
> 2) Is it possible to generate a self-contained IR dump, so that it could be
> possible to feed it to external (third-party) code selectors?

Not as it is in the git tree. I think the current state, the easiest
way to experiment
your back end is to have third-party code call to sparse lib. Once you have
the linearized byte code, you can start from there.

> In my mind a single C program file (actually read: translation unit) would be
> translated to something like the following structure:

The sparse front end generate list of symbols. Functions is symbol as well.
So it have one single list of symbols that your back end should care about.
You need to look into the symbol type to find out this symbol is a function.
But that is just details.

Inside each function, there is list of symbol access by this functions as well.
I think it is sym->symbol_list.

>
> 3) What does the c2xml backend exactly do?

Dump the symbol table into XML form. It seems it does not support the statement
and expression yet.

> 4) Is there anyone working on a RISC-like processor backend project. I feel that
>  if the entire backend can be contained in something like "compile-i386.c" then
> it could be even possible to automate the generation of such file from a more
> compact specification file. (plus some hand-written intrinsics probably).

It should have some different levels. Some basic back end transformation is
architecture independent. The other is. Emit into platform specific instruction
too early is not ideal either.

There is already compile-i386.c in the project. But it is not a good
place to start.
It does not use the linearized byte code at all. The compile.c written by Linus
is a better place to start.

> 5) Is there any documentation covering the API and linked tools to the sparse
> library (something more than the man pages)?

Not that I know of. If you need that much detail to perform the back end work,
you have to read some source code. I think you can ignore a lot of the parser
details and focus on the linearized byte code.

sparse.c is another example of using those linearized byte code, it
only look for
specific subset in the linearized code though.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nikolaos Kavvadias <nkavv () physics ! auth ! gr>
To: linux-sparse
Subject: Re: Backend projects for Sparse
Date: Wed, 28 Nov 2007 19:00:03 +0000
Message-ID: <474DBAB3.60400 () physics ! auth ! gr>
--------------------
Christopher Li wrote:
> It does support SSA from for internal variable(pseudo in
> linearization). Not sure
> what kind of "canonical SSA" do you have in mind.
>   
Hi Christopher

first of all, thanks for your specific answers. The SSA form that i 
think of uses only PHI functions. Guard variables (conditionals for 
selecting a specific usage) may or may not be explicit. Usually, most 
SSA forms just specify which uses are merged. The conditionals can be 
inferred by control-flow analysis.

>> In my mind a single C program file (actually read: translation unit) would be
>> translated to something like the following structure:
>>     
>
> The sparse front end generate list of symbols. Functions is symbol as well.
> So it have one single list of symbols that your back end should care about.
> You need to look into the symbol type to find out this symbol is a function.
> But that is just details.
>
> Inside each function, there is list of symbol access by this functions as well.
> I think it is sym->symbol_list.
>   
OK.

>> 4) Is there anyone working on a RISC-like processor backend project. I feel that
>>  if the entire backend can be contained in something like "compile-i386.c" then
>> it could be even possible to automate the generation of such file from a more
>> compact specification file. (plus some hand-written intrinsics probably).
>>     
>
>   

OK, thank you for this one. I'll have a good look to "compile.c".

>> 5) Is there any documentation covering the API and linked tools to the sparse
>> library (something more than the man pages)?
>>     
>
> Not that I know of. If you need that much detail to perform the back end work,
> you have to read some source code. I think you can ignore a lot of the parser
> details and focus on the linearized byte code.
>
> sparse.c is another example of using those linearized byte code, it
> only look for
> specific subset in the linearized code though.
>
> Chris
>   

Kind regards
Nikolaos Kavvadias

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Backend projects for Sparse
Date: Wed, 28 Nov 2007 19:25:34 +0000
Message-ID: <70318cbf0711281125u6cc168dfv11d118741a535167 () mail ! gmail ! com>
--------------------
On Nov 28, 2007 11:00 AM, Nikolaos Kavvadias <nkavv@physics.auth.gr> wrote:
> first of all, thanks for your specific answers. The SSA form that i
> think of uses only PHI functions. Guard variables (conditionals for
> selecting a specific usage) may or may not be explicit. Usually, most
> SSA forms just specify which uses are merged. The conditionals can be
> inferred by control-flow analysis.

We have PHI node embed in the instruction list as one of the fake instruction.
Then we have the PHI source node to indicate the output edge of the PHI node.

It seems that should fit your need.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: Backend projects for Sparse
Date: Wed, 28 Nov 2007 19:45:13 +0000
Message-ID: <474DC549.2030000 () garzik ! org>
--------------------
Christopher Li wrote:
> There is already compile-i386.c in the project. But it is not a good
> place to start.

Agreed.  That was generating code directly from the parse tree, rather 
than from the linearized form.


> It does not use the linearized byte code at all. The compile.c written by Linus
> is a better place to start.

test-linearize.c maybe?  compile.c is part of compile-i386.


>> 5) Is there any documentation covering the API and linked tools to the sparse
>> library (something more than the man pages)?
> 
> Not that I know of. If you need that much detail to perform the back end work,
> you have to read some source code. I think you can ignore a lot of the parser
> details and focus on the linearized byte code.

Agreed.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: nkavv () physics ! auth ! gr
To: linux-sparse
Subject: Re: Backend projects for Sparse
Date: Thu, 29 Nov 2007 09:09:20 +0000
Message-ID: <1196327360.474e81c0546d7 () mail ! physics ! auth ! gr>
--------------------
Quoting Christopher Li <sparse@chrisli.org>:

> On Nov 28, 2007 11:00 AM, Nikolaos Kavvadias <nkavv@physics.auth.gr> wrote:
> > first of all, thanks for your specific answers. The SSA form that i
> > think of uses only PHI functions. Guard variables (conditionals for
> > selecting a specific usage) may or may not be explicit. Usually, most
> > SSA forms just specify which uses are merged. The conditionals can be
> > inferred by control-flow analysis.
>
> We have PHI node embed in the instruction list as one of the fake
> instruction.
> Then we have the PHI source node to indicate the output edge of the PHI node.
>
> It seems that should fit your need.
>
> Chris

OK, so it marks where the uses are merged.

Jeff: thanks for clearing up the "linearize" issue.

Nikolaos Kavvadias




-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bogus 'not declared' warning ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Bogus 'not declared' warning
Date: Tue, 13 Nov 2007 12:13:32 +0000
Message-ID: <473994EC.8080306 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigBC9F2E1B7F13980552FEDD94
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Josh Triplett wrote:
> Matthew Wilcox wrote:
>> Seems to me that sparse ignores 'static' forward declarations, leading=

>> to false warnings like this:
>>
>> /home/willy/kernel/linux-2.6/drivers/scsi/sym53c8xx_2/sym_hipd.c:3786:=
5: warning: symbol 'sym_compute_residual' was not declared. Should it be =
static?
>>
>> $ grep -n sym_compute_residual drivers/scsi/sym53c8xx_2/*
>> drivers/scsi/sym53c8xx_2/sym_hipd.c:61:static int sym_compute_residual=
(struct sym_hcb *np, struct sym_ccb *cp);
>> drivers/scsi/sym53c8xx_2/sym_hipd.c:3033:               cp->sv_resid =3D=
 sym_compute_residual(np, cp);
>> drivers/scsi/sym53c8xx_2/sym_hipd.c:3786:int sym_compute_residual(stru=
ct sym_hcb *np, struct sym_ccb *cp)
>=20
> Interesting; yes, it looks like the routine emitting that warning
> doesn't check for a symbol marked static by having a previous static
> declaration.  That warning comes from check_duplicates in evaluate.c.
> Seeing it means Sparse didn't see any previous declaration of the
> symbol by checking the same_symbol linked list, which seems wrong.
> check_declaration in symbol.c hooks symbols into those lists.  That
> implies 1) the scopes don't match and 2) one or the other symbol
> doesn't have extern.  The latter should clearly hold true (that case,
> IIRC, handles letting you put extern declarations inside inner
> scopes).  I think the former occurs because one declaration has file
> scope and the other one global scope, but that has a chicken-and-egg
> issue in the case of a static forward declaration: the static forward
> declaration applies, and makes the later declaration have file scope.
>=20
> I *think* the right fix involves changing check_declaration to check
> for this case specifically:
> if (next->scope =3D=3D file_scope && sym->scope =3D=3D global_scope) {
> 	sym->scope =3D file_scope;
> 	sym->same_symbol =3D next;
> 	return;
> }

Turns out this will take a bit more work to fix.  check_declaration
seems like the wrong place for this check, and in any case the code
above won't properly hook the symbol into its scope since it doesn't
call bind_symbol.  bind_symbol in turn has some dead code and other
problems.  I don't plan to address this for the 0.4.1 release,
other than by adding a test case for this, because I don't want to
further delay the other bugfixes in 0.4.1.

- Josh Triplett


--------------enigBC9F2E1B7F13980552FEDD94
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHOZTsGJuZRtD+evsRAksWAJ4oRCgSEnKquC99xEochMfmo+RJHACfbejZ
ip8DA4O0dDj3xbq/vxiDNyw=
=3BDM
-----END PGP SIGNATURE-----

--------------enigBC9F2E1B7F13980552FEDD94--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bogus locking warnings ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Bogus locking warnings
Date: Tue, 27 Feb 2007 01:42:32 +0000
Message-ID: <1172540552.5835.41.camel () dv>
--------------------
Hello!

The current sparse issues a warning about this file:

void my_lock(void) __attribute__ ((context(lock, 0, 1)));
void my_unlock(void) __attribute__ ((context(lock, 1, 0)));
void foo(void);
static void bar(const int locked)
{
	if (!locked)
		my_lock();
	foo();
	if (!locked)
		my_unlock();
}


$ sparse test.c 
test.c:10:3: warning: context imbalance in 'bar' - unexpected unlock

Commenting out foo() call eliminated the warning.  I understand that
sparse suspects that foo() could change "locked".

Changing "int locked" to "const int locked" makes no difference.  I
don't see what else could be done to tell sparse that "locked" won't
change throughout the function call.

Something interesting happens if I change "!locked" to "locked" in both
places:

$ sparse test.c 
test.c:9:2: warning: context imbalance in 'bar' - different lock
contexts for basic block

Although sparse doesn't know anything about the semantic of "locked", it
issues different warnings whether the variable is used "positively" or
"negatively".  No amount of paranoia about foo() can excuse this
inconsistency.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Bogus locking warnings
Date: Tue, 27 Feb 2007 04:19:36 +0000
Message-ID: <Pine.LNX.4.64.0702262000460.12485 () woody ! linux-foundation ! org>
--------------------


On Mon, 26 Feb 2007, Pavel Roskin wrote:
> 
> The current sparse issues a warning about this file:
> 
> void my_lock(void) __attribute__ ((context(lock, 0, 1)));
> void my_unlock(void) __attribute__ ((context(lock, 1, 0)));
> void foo(void);
> static void bar(const int locked)
> {
> 	if (!locked)
> 		my_lock();
> 	foo();
> 	if (!locked)
> 		my_unlock();
> }
> 
> 
> $ sparse test.c 
> test.c:10:3: warning: context imbalance in 'bar' - unexpected unlock
> 
> Commenting out foo() call eliminated the warning.  I understand that
> sparse suspects that foo() could change "locked".

Well, it's more complex than that.

Commenting out the "foo()" call actually allows sparse to do some trivial 
jump-following optimizations, so sparse will turn

	if (!locked)
		my_lock();
	if (!locked)
		my_unlock();

into just conditional branches, and notice that there is a conditional 
branch to an identical conditional, and basically just turn it into

	if (!locked) {
		mu_lock();
		my_unlock();
	}

and at that point sparse will see that there is obviously no problem.

HOWEVER. Sparse will *never* actually do any real dynamic "ahh, that lock 
depends on that conditional", and match up locks and unlocks under the 
same conditional with each other. 

> Changing "int locked" to "const int locked" makes no difference.  I
> don't see what else could be done to tell sparse that "locked" won't
> change throughout the function call.

Sparse sees perfectly well that "locked" doesn't change. There's just one 
assignment (the passing in of the argument), and that isn't the problem. 
It's simply that sparse does not do *any* dynamic analysis at all. 
Everything sparse does is purely static, and that very much includes code 
flow.

Yes, I could expand the flow graph, and make

	if (!locked)
		my_lock();
	call();
	if (!locked)
		my_unlock();

expand to

	if (!locked) {
		my_lock();
		call();
		my_unlock();
	} else {
		call();
	}

but the fact is, sparse doesn't do that (and doing it would be a disaster 
anyway, since in most real-world cases that kind of expansion thing is 
exponential in the conditionals, and you can't really do it for backwards 
jumps aka loops anyway).

So I would suggest that YOU make the code more amenable to static 
analysis. In other words, you can make locking more obvious by using 
clearer functions and doing conversions like the above explicitly. Not 
only will sparse stop complaining, because it will understand it better, 
but _people_ will usually understand conditional locking sequences better 
too if there is just _one_ conditional.

In general, doing flag-based stuff is crap. It generates worse code, and 
it's harder to debug, and we try to avoid it in the kernel. We did so even 
before sparse, but if you want to do lock analysis with sparse, it's 
doubly important.

> Something interesting happens if I change "!locked" to "locked" in both
> places:
> 
> $ sparse test.c 
> test.c:9:2: warning: context imbalance in 'bar' - different lock
> contexts for basic block
> 
> Although sparse doesn't know anything about the semantic of "locked", it
> issues different warnings whether the variable is used "positively" or
> "negatively".  No amount of paranoia about foo() can excuse this
> inconsistency.

That's a totally different thing. It just changes the order that the thing 
is linearized in, and you actually have TWO DIFFERENT BUGS as far as 
sparse is concerned:

	if (!locked)
		my_unlock();

will unlock something that HAS NOT BEEN STATICALLY SEEN TO BE LOCKED! In 
other words, as far as sparse is concerned, you are possibly unlocking 
something that isn't locked. The warning for that is "unexpected unlock".

But you have ANOTHER problem, as far as sparse can see, which is that when 
you do

	if (!locked)
		my_lock();
	call();

the basic block that contains the "call()" part will be entered either 
lockedor unlocked, and sparse tells you that you are doing something 
stupid by telling you that there is a context imbalance, and that the 
very same basic block is entered with two _different_ locking contexts. 

Which is really also true. The fact that you do so intentionally (and it 
may work out _dynamically_ correctly) doesn't matter to sparse. Sparse 
does static checking for correctness, it doesn't check that dynamic 
conditions hold true.

So depending on which basic block sparse happens to start looking at first 
(which in turn depends on what order it decided to linearize things in, 
which in turn depends on things like "was the conditional expression 
negated"), you get different warnings - but sparse will just show you one 
warning, because once it's shown one warning the others are irrelevant.

So sparse is right. If you want to check locks, do something like

 - write the "work function" to be always called with the lock held.

 - do a conditional helper function that is _statically_ seen to be ok 
   locking-wise:

	helper_function(..)
	{
		if (needs_lock) {
			int retval;
		
			my_lock();
			retval = work_function();
			my_unlock();
			return retval;
		}
		return work_function();
	}

   where now the locking is much easier to verify statically (not just for 
   sparse, either - it's more human-readable too, and quite possible will 
   even generate better code!)

and don't expect sparse to do any dynamic checking. It's expressly 
designed to *not* do that, although some of the static optimizations are 
clever enough that sometimes you are fooled into *thinking* that it 
actually understands dynamic behaviour (ie being able to statically follow 
a conditional jump to another identical conditional jump and simplify it 
to a single branch).

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Bogus locking warnings
Date: Tue, 27 Feb 2007 07:24:26 +0000
Message-ID: <1172561066.19312.28.camel () dv>
--------------------
On Mon, 2007-02-26 at 20:19 -0800, Linus Torvalds wrote:

> and don't expect sparse to do any dynamic checking. It's expressly 
> designed to *not* do that, although some of the static optimizations
> are 
> clever enough that sometimes you are fooled into *thinking* that it 
> actually understands dynamic behaviour (ie being able to statically
> follow 
> a conditional jump to another identical conditional jump and simplify
> it 
> to a single branch).

It has been fooling me until now.  Anyway, thanks for the detailed
answer!  I'll try to do what you are suggesting.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bogus sparse warning? ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Bogus sparse warning?
Date: Tue, 13 Feb 2007 23:01:00 +0000
Message-ID: <45D2432C.6020002 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigD3DDD83FE20EE1C70FC87860
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> On Tue, Feb 13, 2007 at 12:22:44AM -0800, Josh Triplett wrote:
>> Anton reported success with this revision of your patch, so I'd like t=
o apply
>> it to the sparse tree; could you please supply a Signed-off-by so I ca=
n do so?
>=20
> Bug fix in pointer modifiers inherent at function degeneration.
>=20
> In reply to Randy's email:
>=20
> The following case cause warning about different signedness of pointer.=

> The pointer should not have signedness at all.
>=20
> struct sk_buff;
> struct sock;
>=20
> extern int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb=
,
> 			int getfrag(void *from, char *to, int offset,
> 			int len,int odd, struct sk_buff *skb),
> 			void *from, int length);
>=20
> int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
> 			int (*getfrag)(void *from, char *to, int offset,
> 			int len,int odd, struct sk_buff *skb),
> 			void *from, int length)
>=20
> {
> 	return 0;
> }
>=20
> Singed-Off-By: Christopher Li <sparse@chrisli.org>
> Acked-By: Linus Torvalds <torvalds@linux-foundation.org>

Applied.  I also added this test case to the validation directory.

Thanks.

- Josh Triplett


--------------enigD3DDD83FE20EE1C70FC87860
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF0kMsGJuZRtD+evsRAob8AJoC9S7+NQ7jC8HANqox7OYvPzOCdQCeMll+
GToZ/5LDMSZSjywJHrXbo+E=
=YdHT
-----END PGP SIGNATURE-----

--------------enigD3DDD83FE20EE1C70FC87860--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Booleans, what a wonderful type! ===

From: ricknu-0 () student ! ltu ! se
To: linux-sparse
Subject: Booleans, what a wonderful type!
Date: Wed, 18 Jul 2007 01:43:39 +0000
Message-ID: <1184723019.469d704b6111b () portal ! student ! luth ! se>
--------------------
Good morning to you all!

As most of you do not know, I am on Google's SoC
<http://code.google.com/soc/2007/sparse/appinfo.html?csaid=CB0974F67B64AD0C> to
add the ability to suggestions when booleans could/should be used.

Unforunatly, you need both a working internet connection and computer to work on
this, which I now appriciate how difficult it can be to manage, otherwise this
would have been sent _much_ earlier.


Anyhow, I would like any and all ideas on these:

* Should it make all the suggestions at the "same time" or should it first just
suggest the "source" of the boolean-change and then, when converted, suggest the
"users" of the source to change over?

* Should it really be handled by a -W-flag? After all, it is more of a
suggestion then a warning.


... and some questions:

* Most likly a _really_ stupid newbie question, but I have seen several of this
form:
<function>
{
        <variable> a;
        <doing something useful (no sign of 'a')>
        a = <some value/variable>;
        <exit>
}
How is this variable useful?

* Why is there no va_end() after va_start()?

According to the manual (STDARG(3)):
va_end
       Each invocation of va_start() must be matched by a corresponding  invo-
       cation  of va_end() in the same function. After the call va_end(ap) the
       variable ap is undefined.  Multiple  transversals  of  the  list,  each
       bracketed  by  va_start() and va_end() are possible.  va_end() may be a
       macro or a function.


* Is there any advantage of "for (;;)" instead of ex "while (true)"?

* Why is it written in C and not C++. Easier access to kernel-developers? (just
curious)


Have a good night.
Richard Knutsson

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Booleans, what a wonderful type!
Date: Wed, 18 Jul 2007 02:19:08 +0000
Message-ID: <20070718021907.GS21668 () ftp ! linux ! org ! uk>
--------------------
On Wed, Jul 18, 2007 at 03:43:39AM +0200, ricknu-0@student.ltu.se wrote:
 
> * Most likly a _really_ stupid newbie question, but I have seen several of this
> form:
> <function>
> {
>         <variable> a;
>         <doing something useful (no sign of 'a')>
>         a = <some value/variable>;
>         <exit>
> }
> How is this variable useful?

Explain, please.  If you mean moving the declaration down - it's not
idiomatic in C and frankly, C++ style tends to make declarations harder
to find when you read the code.
 
> * Why is there no va_end() after va_start()?

Where?

> According to the manual (STDARG(3)):
> va_end
>        Each invocation of va_start() must be matched by a corresponding  invo-
>        cation  of va_end() in the same function. After the call va_end(ap) the
>        variable ap is undefined.  Multiple  transversals  of  the  list,  each
>        bracketed  by  va_start() and va_end() are possible.  va_end() may be a
>        macro or a function.

Yes, and AFAICS uses of va_start()/va_end() in sparse are correct.  If you
see any broken one - yell.

> * Is there any advantage of "for (;;)" instead of ex "while (true)"?

It's more idiomatic and faster recognized by readers.  while (1) is also
quite common; while (true) will be understood, but will distract since it
will take more conscious effort to recognize.
 
> * Why is it written in C and not C++. Easier access to kernel-developers? (just
> curious)

Generally saner language?  Turn the question around - what in sparse would
be inherently cleaner in C++?
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Booleans, what a wonderful type!
Date: Wed, 18 Jul 2007 02:25:19 +0000
Message-ID: <20070718022519.GT21668 () ftp ! linux ! org ! uk>
--------------------
On Wed, Jul 18, 2007 at 03:43:39AM +0200, ricknu-0@student.ltu.se wrote:
> Good morning to you all!
> 
> As most of you do not know, I am on Google's SoC
> <http://code.google.com/soc/2007/sparse/appinfo.html?csaid=CB0974F67B64AD0C> to
> add the ability to suggestions when booleans could/should be used.

Er...  Of _course_ booleans are values.  And yes, you can say true + false.
Guaranteed to evaluate to int, value of expression being 1.  It's perfectly
correct C99.  Same as true + true is guaranteed to be 2 (int, again); assigning
that to _Bool variable is guaranteed to give 1, aka true (see the rules
for conversion to _Bool).

Now, sparse handling of _Bool sucks in quite a few places (e.g. conversion
to it is not reduction modulo 2, it's comparison with 0), but I wonder if
that's what you have in mind...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Brett Nash <nash () fst ! net>
To: linux-sparse
Subject: Re: Booleans, what a wonderful type!
Date: Wed, 18 Jul 2007 02:40:21 +0000
Message-ID: <1184726421.29594.4.camel () baboon ! fluffyspider ! com ! au>
--------------------
On Wed, 2007-07-18 at 03:19 +0100, Al Viro wrote:

> Yes, and AFAICS uses of va_start()/va_end() in sparse are correct.  If you
> see any broken one - yell.

As an aside; how hard is to get sparse to check for this?

Would the general lock structure do enough with the right declaration of
va_start/va_end?   

	Regards,
	nash

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Booleans, what a wonderful type!
Date: Wed, 18 Jul 2007 16:33:18 +0000
Message-ID: <1184776398.2640.8.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Wed, 2007-07-18 at 03:19 +0100, Al Viro wrote:
> On Wed, Jul 18, 2007 at 03:43:39AM +0200, ricknu-0@student.ltu.se wrote:
> 
> > * Most likly a _really_ stupid newbie question, but I have seen several of this
> > form:
> > <function>
> > {
> >         <variable> a;
> >         <doing something useful (no sign of 'a')>
> >         a = <some value/variable>;
> >         <exit>
> > }
> > How is this variable useful?
> 
> Explain, please.  If you mean moving the declaration down - it's not
> idiomatic in C and frankly, C++ style tends to make declarations harder
> to find when you read the code.

Judging by that pseudocode, I would guess that he means the function
never uses the value of a after assigning to it.  That would generally
represent a bug.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: ricknu-0 () student ! ltu ! se
To: linux-sparse
Subject: Re: Booleans, what a wonderful type!
Date: Thu, 19 Jul 2007 00:23:07 +0000
Message-ID: <1184804587.469eaeebb670c () portal ! student ! luth ! se>
--------------------
Citerar Josh Triplett <josht@linux.vnet.ibm.com>:

> On Wed, 2007-07-18 at 03:19 +0100, Al Viro wrote:
> > On Wed, Jul 18, 2007 at 03:43:39AM +0200, ricknu-0@student.ltu.se wrote:
> > 
> > > * Most likly a _really_ stupid newbie question, but I have seen several
> of this
> > > form:
> > > <function>
> > > {
> > >         <variable> a;
> > >         <doing something useful (no sign of 'a')>
> > >         a = <some value/variable>;
> > >         <exit>
> > > }
> > > How is this variable useful?
> > 
> > Explain, please.  If you mean moving the declaration down - it's not
> > idiomatic in C and frankly, C++ style tends to make declarations harder
> > to find when you read the code.
> 
> Judging by that pseudocode, I would guess that he means the function
> never uses the value of a after assigning to it.  That would generally
> represent a bug.
> 
Yes exactly :)

Ok, then I know. Worrid it was some magic I could not get my mind around.

Thanks
Richard
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: ricknu-0 () student ! ltu ! se
To: linux-sparse
Subject: Re: Booleans, what a wonderful type!
Date: Thu, 19 Jul 2007 00:38:23 +0000
Message-ID: <1184805503.469eb27f82f96 () portal ! student ! luth ! se>
--------------------
Citerar Al Viro <viro@ftp.linux.org.uk>:

> On Wed, Jul 18, 2007 at 03:43:39AM +0200, ricknu-0@student.ltu.se wrote:
> > Good morning to you all!
> > 
> > As most of you do not know, I am on Google's SoC
> >
> <http://code.google.com/soc/2007/sparse/appinfo.html?csaid=CB0974F67B64AD0C>
> to
> > add the ability to suggestions when booleans could/should be used.
> 
> Er...  Of _course_ booleans are values.  And yes, you can say true + false.
> Guaranteed to evaluate to int, value of expression being 1.  It's perfectly
> correct C99.  Same as true + true is guaranteed to be 2 (int, again);
> assigning
> that to _Bool variable is guaranteed to give 1, aka true (see the rules
> for conversion to _Bool).
Can you really say it really is a value? With C definition: ex an positiv
integer value => 'true' => value not zero, if converted from integer to boolean
and back. A value would return a specific value on the secound step, right?
> 
> Now, sparse handling of _Bool sucks in quite a few places (e.g. conversion
> to it is not reduction modulo 2, it's comparison with 0), but I wonder if
> that's what you have in mind...
My main goal is to make it able to find possible places where an integer is used
as an boolean.

Richard Knutsson

PS
Believe I used "Reply" instead of "Reply all" when I answeared your other mail.
So if you won't reply to any, could you please forward a copy to the list? Thanks.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Differences in the behaviour of sparse and gcc within cygwin environment ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Differences in the behaviour of sparse and gcc within cygwin environment
Date: Fri, 18 May 2007 20:47:35 +0000
Message-ID: <20070518204735.GY4095 () ftp ! linux ! org ! uk>
--------------------
On Fri, May 18, 2007 at 01:43:11PM +0200, Thomas Schmid wrote:
> I use sparse in a cygwin environment to obtain pre-build info from 
> sourcefiles which get comiled with gcc (also compiled with cygwin).
> 
> After some time of using sparse, I noticed some differences in the 
> behaviour of sparse and gcc:
> 1. Symbolnames with "$" are accepted by gcc but not by sparse

ewww...  It's not hard to change, but I strongly recommend making it
ifdefed and *not* included on sane boxen.  Rationale: that affects one
of the hottest paths in the entire thing.

Who uses $ in identifiers, anyway, when it's guaranteed to be non-portable?
gcc accepts it as a bloody misguided extension, but it's not standard C by
any stretch of imagination.  What are you working with, a bunch of old code
originating on VMS?

> 2. #include "..\plc.h" is accepted by gcc but not by sparse => "\" is 
> interpreted as escape- character
> 3. #include "D:\plc.h" is accepted by gcc but not by sparse

*argh*

sparse takes a shortcut - it treats header-name as string-literal.  In
principle, these are distinct tokens.  We could try to change that, but...
that makes tokenizer context-dependent in a fairly upleasant way.

Note that \ in header-name is explicitly undefined behaviour (6.4.7(3)),
and compilers I've seen on weird systems of that kind tend to remap / on \
in header names anyway before trying to look for files to include.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Finding all typedefs ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Finding all typedefs
Date: Fri, 27 Jul 2007 22:08:31 +0000
Message-ID: <1185574111.2029.10.camel () dv>
--------------------
Hello!

I'm trying to write a wrapper around GNU indent to make the output
result satisfy checkpatch.pl.  Unfortunately, GNU indent is bad at
recognizing types if they are just bare words defined by typedef.  Such
types should be supplied using the "-T" option to indent.

I would prefer to rely on sparse for finding all typedefs, since it's
better at parsing C code than any script I could write.

Is there any way to make sparse dump all type names declared with a
typedef?  I don't see any of the programs in sparse sources do anything
like that.  I think c2xml could be a good candidate, as it outputs the
symbol, but it doesn't give any indication that it's a typedef-defined
type:

$ make C=2 CHECK=/home/proski/src/sparse/c2xml |grep foo_t
  <symbol type="node" id="_29" ident="foo_t"
file="/home/proski/src/at76/at76_usb.c" start-line="41" start-col="13"
end-line="41" end-col="18" bit-size="32" alignment="4" offset="0"
base-type-builtin="int"/>

Another nice thing would be to have a list of labels.  Although they are
easier to find by scripts, I would prefer to find them in the same run.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: Finding all typedefs
Date: Fri, 27 Jul 2007 22:56:40 +0000
Message-ID: <20070727160147.6ecbfd86.rdunlap () xenotime ! net>
--------------------
This is a multi-part message in MIME format.

--Multipart=_Fri__27_Jul_2007_16_01_47_-0700_BHwt=.kyYmHUU=YN
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit

On Fri, 27 Jul 2007 18:08:31 -0400 Pavel Roskin wrote:

> Hello!
> 
> I'm trying to write a wrapper around GNU indent to make the output
> result satisfy checkpatch.pl.  Unfortunately, GNU indent is bad at
> recognizing types if they are just bare words defined by typedef.  Such
> types should be supplied using the "-T" option to indent.
> 
> I would prefer to rely on sparse for finding all typedefs, since it's
> better at parsing C code than any script I could write.
> 
> Is there any way to make sparse dump all type names declared with a
> typedef?  I don't see any of the programs in sparse sources do anything
> like that.  I think c2xml could be a good candidate, as it outputs the
> symbol, but it doesn't give any indication that it's a typedef-defined
> type:
> 
> $ make C=2 CHECK=/home/proski/src/sparse/c2xml |grep foo_t
>   <symbol type="node" id="_29" ident="foo_t"
> file="/home/proski/src/at76/at76_usb.c" start-line="41" start-col="13"
> end-line="41" end-col="18" bit-size="32" alignment="4" offset="0"
> base-type-builtin="int"/>
> 
> Another nice thing would be to have a list of labels.  Although they are
> easier to find by scripts, I would prefer to find them in the same run.

I asked Linus about 3 years ago for something that would dump
global data sizes.  It's attached (updated to recent sparse;
it also has '-keywords' to warn about using C++ keywords, but you
can ignore/delete that part).  It may be fixable to do what you want,
although I have no info on sparse symbol struct contents.
Or maybe Josh et al can do what you want rather easily... :)


use:
make C=2 CF=-list-symbols arch/i386/kernel/smp.o

gives:
arch/i386/kernel/smp.c:107:1: struct tlb_state [addressable] [toplevel] per_cpu__cpu_tlbstate: compound size 128, alignment 128
arch/i386/kernel/smp.c:247:18: struct cpumask_t static [addressable] [toplevel] [usertype] flush_cpumask: compound size 4, alignment 4
arch/i386/kernel/smp.c:248:25: struct mm_struct *static [toplevel] [assigned] flush_mm: compound size 4, alignment 4
arch/i386/kernel/smp.c:250:8: struct spinlock_t static [addressable] [toplevel] [usertype] tlbstate_lock: compound size 8, alignment 4
arch/i386/kernel/smp.c:450:1: char static const [toplevel] __kstrtab_flush_tlb_page[0]: compound size 15, alignment 1
arch/i386/kernel/smp.c:450:1: struct kernel_symbol static const [toplevel] __ksymtab_flush_tlb_page: compound size 8, alignment 4
arch/i386/kernel/smp.c:481:8: struct spinlock_t static [addressable] [toplevel] [usertype] call_lock: compound size 8, alignment 4
arch/i386/kernel/smp.c:501:32: struct call_data_struct *static [toplevel] [assigned] call_data: compound size 4, alignment 4
arch/i386/kernel/smp.c:698:16: struct smp_ops [addressable] [toplevel] smp_ops: compound size 28, alignment 4


---
~Randy

--Multipart=_Fri__27_Jul_2007_16_01_47_-0700_BHwt=.kyYmHUU=YN
Content-Type: text/x-patch;
 name="sparse-keywords-sizes.patch"
Content-Disposition: attachment;
 filename="sparse-keywords-sizes.patch"
Content-Transfer-Encoding: 7bit

From: Randy Dunlap <rdunlap@xenotime.net>
with help from Linus.

sparse additions to:
- check for C/C++ keywords: usage: -keywords
- print all global data symbols and their sizes: usage: -list-symbols
  Example of -list-symbols:
  make C=2 CF="-list-symbols" arch/x86_64/kernel/smpboot.o
  arch/x86_64/kernel/smpboot.c:90:20: struct cpuinfo_x86 [addressable] [toplevel] [assigned] cpu_data[8]: compound size 1344, alignment 64

Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
---
 lib.c    |   31 +++++++++++++++++++++++++++++++
 sparse.c |   47 ++++++++++++++++++++++++++++++++++++++++++++++-
 symbol.c |   33 ++++++++++++++++++++++++++++++---
 3 files changed, 107 insertions(+), 4 deletions(-)

--- sparse-2007-07-24.orig/sparse.c
+++ sparse-2007-07-24/sparse.c
@@ -20,6 +20,7 @@
 #include "allocate.h"
 #include "token.h"
 #include "parse.h"
+#include "scope.h"
 #include "symbol.h"
 #include "expression.h"
 #include "linearize.h"
@@ -273,6 +274,42 @@ static void check_symbols(struct symbol_
 	} END_FOR_EACH_PTR(sym);
 }
 
+extern int list_symbols;
+
+static void list_all_symbols(struct symbol_list *list)
+{
+	struct symbol *sym;
+
+	FOR_EACH_PTR(list, sym) {
+		/* Only show arrays, structures, unions, enums, & typedefs */
+		if (!(sym->namespace & (NS_STRUCT | NS_TYPEDEF | NS_SYMBOL)))
+			continue;
+		/* Only show types we actually examined (ie used) */
+		if (!sym->bit_size)
+			continue;
+		if (sym->type == SYM_FN || sym->type == SYM_ENUM)
+			continue;
+		if (!sym->ctype.base_type)
+			continue;
+		if (sym->ctype.base_type->type == SYM_FN)
+			continue;
+		if (sym->ctype.base_type->type == SYM_ENUM)
+			continue;
+		if (sym->ctype.base_type->type == SYM_BASETYPE)
+			continue;
+		/* Don't show unnamed types */
+		if (!sym->ident)
+			continue;
+		///printf("%s: size %u, alignment %lu\n",
+		///info(sym->pos, "%s (0x%x:base 0x%x): compound size %u, alignment %lu",
+		info(sym->pos, "%s: compound size %u, alignment %lu",
+			show_typename(sym), ///sym->type,
+			///sym->ctype.base_type->type,
+			sym->bit_size >> 3,
+			sym->ctype.alignment);
+	} END_FOR_EACH_PTR(sym);
+}
+
 int main(int argc, char **argv)
 {
 	struct string_list *filelist = NULL;
@@ -281,7 +318,15 @@ int main(int argc, char **argv)
 	// Expand, linearize and show it.
 	check_symbols(sparse_initialize(argc, argv, &filelist));
 	FOR_EACH_PTR_NOTAG(filelist, file) {
-		check_symbols(sparse(file));
+		struct symbol_list *res = sparse(file);
+
+		check_symbols(res);
+
+		// List all symbols...
+		if (list_symbols)
+			///list_all_symbols(block_scope->symbols);
+			list_all_symbols(res);
 	} END_FOR_EACH_PTR_NOTAG(file);
+
 	return 0;
 }
--- sparse-2007-07-24.orig/lib.c
+++ sparse-2007-07-24/lib.c
@@ -213,6 +213,8 @@ int dbg_entry = 0;
 int dbg_dead = 0;
 
 int preprocess_only;
+int list_symbols = 0;
+int keywords_all = 0;
 
 #define CMDLINE_INCLUDE 20
 int cmdline_include_nr = 0;
@@ -308,6 +310,31 @@ static char **handle_switch_i(char *arg,
 	return next;
 }
 
+void handle_switch_pre(int argc, char **argv)
+{
+	char **args = argv;
+
+	for (;;) {
+		char *arg = *++args;
+		if (!arg)
+			break;
+
+		if (arg[0] == '-' && arg[1]) {
+			if (!strcmp(arg + 1, "keywords")) {
+				keywords_all = 1;
+				continue;
+			}
+		}
+	}
+}
+
+char **handle_switch_l(char *arg, char **next)
+{
+	if (!strcmp(arg, "list-symbols"))
+		list_symbols = 1;
+	return next;
+}
+
 static char **handle_switch_M(char *arg, char **next)
 {
 	if (!strcmp(arg, "MF") || !strcmp(arg,"MQ") || !strcmp(arg,"MT")) {
@@ -529,6 +556,7 @@ char **handle_switch(char *arg, char **n
 	case 'E': return handle_switch_E(arg, next);
 	case 'I': return handle_switch_I(arg, next);
 	case 'i': return handle_switch_i(arg, next);
+	case 'l': return handle_switch_l(arg, next);
 	case 'M': return handle_switch_M(arg, next);
 	case 'm': return handle_switch_m(arg, next);
 	case 'o': return handle_switch_o(arg, next);
@@ -710,6 +738,9 @@ struct symbol_list *sparse_initialize(in
 	char **args;
 	struct symbol_list *list;
 
+	// allow some switches (like "keywords") before init_symbols();
+	handle_switch_pre(argc, argv);
+
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
 
--- sparse-2007-07-24.orig/symbol.c
+++ sparse-2007-07-24/symbol.c
@@ -545,7 +545,7 @@ void bind_symbol(struct symbol *sym, str
 	}
 	if (ident->reserved && (ns & (NS_TYPEDEF | NS_STRUCT | NS_LABEL | NS_SYMBOL))) {
 		sparse_error(sym->pos, "Trying to use reserved word '%s' as identifier", show_ident(ident));
-		return;
+		///return;
 	}
 	sym->namespace = ns;
 	sym->next_id = ident->symbols;
@@ -694,12 +694,13 @@ out:
  *
  * "double" == "long float", "long double" == "long long float"
  */
-static struct sym_init {
+struct sym_init {
 	const char *name;
 	struct symbol *base_type;
 	unsigned int modifiers;
 	struct symbol_op *op;
-} symbol_init_table[] = {
+};
+static struct sym_init symbol_init_table[] = {
 	/* Storage class */
 	{ "auto",	NULL,		MOD_AUTO },
 	{ "register",	NULL,		MOD_REGISTER },
@@ -727,6 +728,24 @@ static struct sym_init {
 	{ NULL,		NULL,		0 }
 };
 
+extern int keywords_all;
+const char * all_keywords[] = {
+/* more c_keywords[] */
+	"_Complex", "_Imaginary", "__thread",
+/* and cpp_keywords[] */
+	"bool", "catch", "class",
+	"complex", "__complex__", "const_cast",
+	"delete", "dynamic_cast",
+	"explicit", "export",
+	"false", "friend",
+	"mutable", "namespace", "new",
+	"operator", "private", "protected", "public",
+	"reinterpret_cast", "static_cast",
+	"template", "this", "throw",
+	"true", "try", "typeid", "typename",
+	"using", "virtual", "wchar_t",
+};
+
 static struct symbol_op constant_p_op = {
 	.evaluate = evaluate_to_integer,
 	.expand = expand_constant_p
@@ -812,6 +831,14 @@ void init_symbols(void)
 		sym->ctype.base_type = ptr->base_type;
 		sym->ctype.modifiers = ptr->modifiers;
 	}
+	if (keywords_all) {
+		int kx;
+
+		for (kx = 0; kx < sizeof(all_keywords) / sizeof(char *); kx++) {
+			struct ident *ident = built_in_ident(all_keywords [kx]);
+			ident->reserved = 1;
+		}
+	}
 
 	builtin_fn_type.variadic = 1;
 	for (ptr = eval_init_table; ptr->name; ptr++) {

--Multipart=_Fri__27_Jul_2007_16_01_47_-0700_BHwt=.kyYmHUU=YN--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Finding all typedefs
Date: Wed, 01 Aug 2007 15:45:12 +0000
Message-ID: <1185983112.2425.12.camel () dv>
--------------------
Hello, Randy!

On Fri, 2007-07-27 at 16:01 -0700, Randy Dunlap wrote:

> I asked Linus about 3 years ago for something that would dump
> global data sizes.  It's attached (updated to recent sparse;
> it also has '-keywords' to warn about using C++ keywords, but you
> can ignore/delete that part).  It may be fixable to do what you want,
> although I have no info on sparse symbol struct contents.
> Or maybe Josh et al can do what you want rather easily... :)

Sorry for delay.  Thank you!  I'm not sure I can reuse anything from
that code to dump typedefs.

My point is, I want to write a script that would use existing software
to produce checkpatch.pl conforming code.  If I need to hack anything,
I'd rather contribute to indent or astyle.  In fact, it would be a much
better approach to recognize argument lists and format them differently,
rather than deal with a list of typedefs.

I hoped that c2xml would give me typedefs, but it doesn't.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Finding all typedefs
Date: Wed, 01 Aug 2007 15:45:12 +0000
Message-ID: <1185983112.2425.12.camel () dv>
--------------------
Hello, Randy!

On Fri, 2007-07-27 at 16:01 -0700, Randy Dunlap wrote:

> I asked Linus about 3 years ago for something that would dump
> global data sizes.  It's attached (updated to recent sparse;
> it also has '-keywords' to warn about using C++ keywords, but you
> can ignore/delete that part).  It may be fixable to do what you want,
> although I have no info on sparse symbol struct contents.
> Or maybe Josh et al can do what you want rather easily... :)

Sorry for delay.  Thank you!  I'm not sure I can reuse anything from
that code to dump typedefs.

My point is, I want to write a script that would use existing software
to produce checkpatch.pl conforming code.  If I need to hack anything,
I'd rather contribute to indent or astyle.  In fact, it would be a much
better approach to recognize argument lists and format them differently,
rather than deal with a list of typedefs.

I hoped that c2xml would give me typedefs, but it doesn't.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Finding all typedefs
Date: Wed, 01 Aug 2007 17:01:31 +0000
Message-ID: <1185987691.3123.33.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Wed, 2007-08-01 at 11:45 -0400, Pavel Roskin wrote:
> On Fri, 2007-07-27 at 16:01 -0700, Randy Dunlap wrote:
> > I asked Linus about 3 years ago for something that would dump
> > global data sizes.  It's attached (updated to recent sparse;
> > it also has '-keywords' to warn about using C++ keywords, but you
> > can ignore/delete that part).  It may be fixable to do what you want,
> > although I have no info on sparse symbol struct contents.
> > Or maybe Josh et al can do what you want rather easily... :)
> 
> Sorry for delay.  Thank you!  I'm not sure I can reuse anything from
> that code to dump typedefs.
> 
> My point is, I want to write a script that would use existing software
> to produce checkpatch.pl conforming code.  If I need to hack anything,
> I'd rather contribute to indent or astyle.  In fact, it would be a much
> better approach to recognize argument lists and format them differently,
> rather than deal with a list of typedefs.
> 
> I hoped that c2xml would give me typedefs, but it doesn't.

It certainly should; I didn't realize that it didn't.  I'll look into it
and see if I can change that.

CCing Rob (the author of c2xml) to see if he has any thoughts on this.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rob Taylor <rob.taylor () codethink ! co ! uk>
To: linux-sparse
Subject: Re: Finding all typedefs
Date: Thu, 02 Aug 2007 00:15:34 +0000
Message-ID: <46B12226.1070802 () codethink ! co ! uk>
--------------------
Josh Triplett wrote:
> On Wed, 2007-08-01 at 11:45 -0400, Pavel Roskin wrote:
>> On Fri, 2007-07-27 at 16:01 -0700, Randy Dunlap wrote:
>>> I asked Linus about 3 years ago for something that would dump
>>> global data sizes.  It's attached (updated to recent sparse;
>>> it also has '-keywords' to warn about using C++ keywords, but you
>>> can ignore/delete that part).  It may be fixable to do what you want,
>>> although I have no info on sparse symbol struct contents.
>>> Or maybe Josh et al can do what you want rather easily... :)
>> Sorry for delay.  Thank you!  I'm not sure I can reuse anything from
>> that code to dump typedefs.
>>
>> My point is, I want to write a script that would use existing software
>> to produce checkpatch.pl conforming code.  If I need to hack anything,
>> I'd rather contribute to indent or astyle.  In fact, it would be a much
>> better approach to recognize argument lists and format them differently,
>> rather than deal with a list of typedefs.
>>
>> I hoped that c2xml would give me typedefs, but it doesn't.
> 
> It certainly should; I didn't realize that it didn't.  I'll look into it
> and see if I can change that.
> 
> CCing Rob (the author of c2xml) to see if he has any thoughts on this.

Well, the way a typedef appears in the c2xml output is a symbol with
type="node" and user-type="1", but this also applies to nodes that are
instances of typedefs. I still haven't figured out why I never get any
symbols with MOD_TYPEDEF set. I suspect parse.c:1225:8, though I don't
really understand this bit of code.

Another annoying thing is that the types are always resolved for
typedefs. i.e. for

typedef int foo;
foo bar;

the symbol for bar has a base type of int.

Any suggestions for how to solve this would be greatly appreciated :)

Thanks,
Rob Taylor
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rob Taylor <rob.taylor () codethink ! co ! uk>
To: linux-sparse
Subject: Re: Finding all typedefs
Date: Thu, 02 Aug 2007 00:15:34 +0000
Message-ID: <46B12226.1070802 () codethink ! co ! uk>
--------------------
Josh Triplett wrote:
> On Wed, 2007-08-01 at 11:45 -0400, Pavel Roskin wrote:
>> On Fri, 2007-07-27 at 16:01 -0700, Randy Dunlap wrote:
>>> I asked Linus about 3 years ago for something that would dump
>>> global data sizes.  It's attached (updated to recent sparse;
>>> it also has '-keywords' to warn about using C++ keywords, but you
>>> can ignore/delete that part).  It may be fixable to do what you want,
>>> although I have no info on sparse symbol struct contents.
>>> Or maybe Josh et al can do what you want rather easily... :)
>> Sorry for delay.  Thank you!  I'm not sure I can reuse anything from
>> that code to dump typedefs.
>>
>> My point is, I want to write a script that would use existing software
>> to produce checkpatch.pl conforming code.  If I need to hack anything,
>> I'd rather contribute to indent or astyle.  In fact, it would be a much
>> better approach to recognize argument lists and format them differently,
>> rather than deal with a list of typedefs.
>>
>> I hoped that c2xml would give me typedefs, but it doesn't.
> 
> It certainly should; I didn't realize that it didn't.  I'll look into it
> and see if I can change that.
> 
> CCing Rob (the author of c2xml) to see if he has any thoughts on this.

Well, the way a typedef appears in the c2xml output is a symbol with
type="node" and user-type="1", but this also applies to nodes that are
instances of typedefs. I still haven't figured out why I never get any
symbols with MOD_TYPEDEF set. I suspect parse.c:1225:8, though I don't
really understand this bit of code.

Another annoying thing is that the types are always resolved for
typedefs. i.e. for

typedef int foo;
foo bar;

the symbol for bar has a base type of int.

Any suggestions for how to solve this would be greatly appreciated :)

Thanks,
Rob Taylor
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Format-string sanity checks ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Format-string sanity checks
Date: Thu, 11 Oct 2007 07:57:21 +0000
Message-ID: <70318cbf0710110057ya8ba529o7379425628e68be1 () mail ! gmail ! com>
--------------------
If you use linearized code instead of the symbol tree. That will
save you a lot of trouble. The best example is sparse.c. Please take
a look at check_call_instruction() and check_memset().

You can add your printk check in similar ways.

Chris

On 10/10/07, Vegard Nossum <vegard.nossum@gmail.com> wrote:
> Hey,
>
> As part of my project to make printk() in the kernel a bit safer, I've
> written this program using sparse to detect unsafe/unwise uses of
> printk.
>
> Basically, I want all format strings of printk() to be literal strings.
>
> This is a very early version. It can probably be written a bit nicer,
> for instance by including it in evaluate_call(), dropping a few of the
> checks (I am not so familiar with sparse, and wanted to be on the safe
> side), and also check all functions marked with the gcc printf attribute
> instead of just "printk". But it works for my purposes.
>
> This code is under the same license as sparse itself.
>
> Kind regards,
> Vegard
>
>
>
> /* Copyright (C) 2007  Vegard Nossum <vegard.nossum@gmail.com> */
>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
>
> #include "lib.h"
> #include "allocate.h"
> #include "token.h"
> #include "parse.h"
> #include "symbol.h"
> #include "expression.h"
> #include "linearize.h"
>
> static void check_stmt(struct statement *stmt);
> static void check_stmts(struct statement_list *stmts);
> static void check_sym(struct symbol *sym);
> static void check_syms(struct symbol_list *syms);
> static void check_expr(struct expression *expr);
> static void check_exprs(struct expression_list *exprs);
>
> static void
> check_printk(struct position pos, struct expression *expr)
> {
>         struct expression_list *args = expr->args;
>         struct expression *format;
>         struct symbol *symbol;
>         struct symbol *base;
>         struct expression *initializer;
>         struct string *string;
>         unsigned int i;
>
>         format = first_ptr_list(args);
>         if(!format) {
>                 warning(pos, "function call has no arguments");
>                 return;
>         }
>
>         if(format->type != EXPR_SYMBOL) {
>                 warning(pos, "format string has wrong type");
>                 return;
>         }
>
>         if(format->symbol_name) {
>                 warning(pos, "format string is a named symbol");
>                 return;
>         }
>
>         symbol = format->symbol;
>         if(symbol->namespace == NS_SYMBOL) {
>                 warning(pos, "format string is not a string literal");
>                 return;
>         }
>
>         if(!symbol->string) {
>                 warning(pos, "format string is not a string");
>                 return;
>         }
>
>         base = symbol->ctype.base_type;
>         if(base->type != SYM_ARRAY) {
>                 warning(pos, "format string is not an array");
>                 return;
>         }
>
>         initializer = symbol->initializer;
>         if(!initializer) {
>                 warning(pos, "format string does not have an initializer");
>                 return;
>         }
>
>         if(initializer->type != EXPR_STRING) {
>                 warning(pos, "format string is not a string literal");
>                 return;
>         }
>
>         string = initializer->string;
>         for(i = 0; i < string->length; ++i) {
>                 if(string->data[i] == '\n'
>                         && i != string->length - 2)
>                 {
>                         warning(pos, "format string contains newline");
>                         return;
>                 }
>         }
> }
>
> static void
> check_expr(struct expression *expr)
> {
>         if(!expr)
>                 return;
>
>         /* XXX: This needs some work... Maybe use evaluate? */
>         switch(expr->type) {
>         case EXPR_VALUE:
>         case EXPR_FVALUE:
>         case EXPR_STRING:
>                 break;
>         case EXPR_SYMBOL:
>         case EXPR_TYPE:
>                 //check_sym(expr->symbol);
>                 break;
>         case EXPR_BINOP:
>         case EXPR_ASSIGNMENT:
>         case EXPR_LOGICAL:
>         case EXPR_COMMA:
>         case EXPR_COMPARE:
>                 check_expr(expr->left);
>                 check_expr(expr->right);
>                 break;
>         case EXPR_DEREF:
>                 check_expr(expr->deref);
>                 break;
>         case EXPR_PREOP:
>         case EXPR_POSTOP:
>                 check_expr(expr->unop);
>                 break;
>         case EXPR_CAST:
>         case EXPR_FORCE_CAST:
>         case EXPR_IMPLIED_CAST:
>                 /* XXX: Hmm? */
>                 check_expr(expr->cast_expression);
>                 break;
>         case EXPR_SIZEOF:
>                 break;
>         case EXPR_ALIGNOF:
>                 break;
>         case EXPR_PTRSIZEOF:
>                 break;
>         case EXPR_CONDITIONAL:
>         case EXPR_SELECT:
>                 check_expr(expr->conditional);
>                 check_expr(expr->cond_true);
>                 check_expr(expr->cond_false);
>                 break;
>         case EXPR_STATEMENT:
>                 check_stmt(expr->statement);
>                 break;
>         case EXPR_CALL:
>                 check_expr(expr->fn);
>                 check_exprs(expr->args);
>                 break;
>         case EXPR_LABEL:
>                 //check_sym(expr->label_symbol);
>                 break;
>         case EXPR_INITIALIZER:
>                 check_exprs(expr->expr_list);
>                 break;
>         case EXPR_IDENTIFIER:
>                 check_expr(expr->ident_expression);
>                 break;
>         case EXPR_INDEX:
>                 check_expr(expr->idx_expression);
>                 break;
>         case EXPR_POS:
>                 check_expr(expr->init_expr);
>                 break;
>         case EXPR_SLICE:
>                 check_expr(expr->base);
>                 break;
>         case EXPR_OFFSETOF:
>                 check_expr(expr->down);
>                 break;
>         }
>
>         if(expr->type == EXPR_CALL) {
>                 struct expression *fn = expr->fn;
>
>                 if(fn->type == EXPR_PREOP)
>                         fn = fn->unop;
>
>                 if(fn->type == EXPR_SYMBOL) {
>                         if(!strcmp(fn->symbol_name->name, "printk"))
>                                 check_printk(fn->pos, expr);
>                 } else {
> #if 0
>                         printf("%d: Function in call expression has "
>                                 "unhandled type %d\n",
>                                 fn->pos.line,
>                                 fn->type);
> #endif
>                 }
>         }
> }
>
> static void
> check_exprs(struct expression_list *exprs)
> {
>         struct expression *expr;
>
>         if(!exprs)
>                 return;
>
>         FOR_EACH_PTR(exprs, expr) {
>                 check_expr(expr);
>         } END_FOR_EACH_PTR(expr);
> }
>
> static void
> check_stmt(struct statement *stmt)
> {
>         if(!stmt)
>                 return;
>
>         switch(stmt->type) {
>         case STMT_NONE:
>                 break;
>         case STMT_DECLARATION:
>                 break;
>         case STMT_EXPRESSION:
>                 check_expr(stmt->expression);
>                 break;
>         case STMT_COMPOUND:
>                 check_stmts(stmt->stmts);
>                 break;
>         case STMT_IF:
>                 check_expr(stmt->if_conditional);
>                 check_stmt(stmt->if_true);
>                 check_stmt(stmt->if_false);
>                 break;
>         case STMT_RETURN:
>                 check_expr(stmt->ret_value);
>                 break;
>         case STMT_CASE:
>                 check_expr(stmt->case_expression);
>                 break;
>         case STMT_SWITCH:
>                 check_expr(stmt->switch_expression);
>                 check_stmt(stmt->switch_statement);
>                 break;
>         case STMT_ITERATOR:
>                 check_stmt(stmt->iterator_pre_statement);
>                 check_expr(stmt->iterator_pre_condition);
>                 check_stmt(stmt->iterator_statement);
>                 check_stmt(stmt->iterator_post_statement);
>                 check_expr(stmt->iterator_post_condition);
>                 break;
>         case STMT_LABEL:
>                 break;
>         case STMT_GOTO:
>                 check_expr(stmt->goto_expression);
>                 break;
>         case STMT_ASM:
>                 check_expr(stmt->asm_string);
>                 check_exprs(stmt->asm_outputs);
>                 check_exprs(stmt->asm_inputs);
>                 check_exprs(stmt->asm_clobbers);
>                 break;
>         case STMT_CONTEXT:
>                 break;
>         case STMT_RANGE:
>                 check_expr(stmt->range_expression);
>                 check_expr(stmt->range_low);
>                 check_expr(stmt->range_high);
>                 break;
>         }
> }
>
> static void
> check_stmts(struct statement_list *stmts)
> {
>         struct statement *stmt;
>
>         if(!stmts)
>                 return;
>
>         FOR_EACH_PTR(stmts, stmt) {
>                 check_stmt(stmt);
>         } END_FOR_EACH_PTR(stmt);
> }
>
> static void
> check_sym(struct symbol *sym)
> {
>         if(sym->ctype.base_type)
>                 sym = sym->ctype.base_type;
>
>         if(sym->type == SYM_FN)
>                 check_stmt(sym->stmt);
> }
>
> static void
> check_syms(struct symbol_list *syms)
> {
>         struct symbol *sym;
>
>         FOR_EACH_PTR_NOTAG(syms, sym) {
>                 check_sym(sym);
>         } END_FOR_EACH_PTR_NOTAG(sym);
> }
>
> int
> main(int argc, char *argv[])
> {
>         struct string_list *files = NULL;
>         char *file;
>
>         sparse_initialize(argc, argv, &files);
>
>         FOR_EACH_PTR_NOTAG(files, file) {
>                 check_syms(sparse(file));
>         } END_FOR_EACH_PTR_NOTAG(file);
>
>         return 0;
> }
>
>
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Fun with Linux 2.6.21-rc1 ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Fun with Linux 2.6.21-rc1
Date: Fri, 23 Feb 2007 17:25:18 +0000
Message-ID: <1172251518.6229.6.camel () dv>
--------------------
Hello!

The current sparse reports many errors with Linux 2.6.21-rc1.  There are
screenfuls of errors for every file.  I have reduced one of them to this
simple file:

struct st {
	char c;
} __attribute__ ((aligned(2)));
struct st s1;
struct st s2;

$ sparse test.c 
test.c:5:18: error: Expected ( after asm
test.c:5:18: error: got s2
test.c:5:20: error: Expected ) after asm
test.c:5:20: error: got ;
builtin:0:0: error: expected declaration

The strange thing is that there is no "asm" here at all.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Fun with Linux 2.6.21-rc1
Date: Fri, 23 Feb 2007 19:59:26 +0000
Message-ID: <1172260766.14431.3.camel () dv>
--------------------
On Fri, 2007-02-23 at 12:25 -0500, Pavel Roskin wrote:
> Hello!
> 
> The current sparse reports many errors with Linux 2.6.21-rc1.  There are
> screenfuls of errors for every file.  I have reduced one of them to this
> simple file:
> 
> struct st {
> 	char c;
> } __attribute__ ((aligned(2)));
> struct st s1;
> struct st s2;

P.S. The breakage has nothing to do to Linux changes.  It was caused by
the patch called "Make the ptrlist using the sparse allocator".  Undoing
the patch fixes the problem.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Git mirror delay ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Git mirror delay
Date: Wed, 28 Feb 2007 02:55:42 +0000
Message-ID: <45E4EF2E.4050101 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig6115B4874904AD417E3FEEB5
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Pavel Roskin wrote:
> On Tue, 2007-02-27 at 10:40 -0800, Josh Triplett wrote:
>> Oleg Nesterov wrote:
>>> Change examine_sym_node() to recursively inspect the members of SYM_S=
TRUCT.
>>> This allows us to simplify lookup_member(): no need to do examine_sym=
_node(),
>>> the member was already examined.
>>>
>>> This is also good because now ->r_symdef(member) is called on declara=
tion,
>>> not when dissect detects the first usage of ->member.
>>>
>>> Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
>> Applied.
>=20
> Josh, I'll really appreciate if you push your changes to the publicly
> available repository as soon as you post "applied".  This way, when I
> have some time for sparse, I read the list, see your post, update spars=
e
> and see how it's affecting my projects.
>=20
> If the changes are only available the next day, I'll probably be busy
> with other things.

To the best of my knowledge, I always push out changes before I send the
corresponding "applied" mail.  However, I often send the mail a few momen=
ts
after pushing out the change, and the kernel.org mirroring processes do n=
ot
run the instant I push changes out.  In particular, I just confirmed that=
 a
fresh clone of git://git.kernel.org/pub/scm/linux/kernel/git/josh/sparse.=
git
did not include the changes I've pushed about 8 hours ago today.

The new git.kernel.org server may help alleviate some of the issues that =
lead
to this high mirroring delay.

- Josh Triplett


--------------enig6115B4874904AD417E3FEEB5
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5O8uGJuZRtD+evsRAtT7AJ41Wr+NzYCFHwGxkYKDK/oaG17JBwCgjS1v
hR4Mr74CgGthqRQufdAp9d4=
=b2Dz
-----END PGP SIGNATURE-----

--------------enig6115B4874904AD417E3FEEB5--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Ignore the cdecl and stdcall attributes for now. ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Ignore the cdecl and stdcall attributes for now.
Date: Tue, 22 May 2007 22:39:16 +0000
Message-ID: <46537114.50109 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig35DC84B008BCD1E5C2DF5FA9
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Michael Stefaniuc wrote:
> The output is still big. But i have a test case for the next big proble=
m=20
> generator in Wine. It's attached as a git patch to=20
> validate/calling-convention-attributes.c (I can send it separately to=20
> the linux-sparse mailing list if you want). Sparse gives:
> calling-convention-attributes.c:7:12: error: Expected ; at end of=20
> declaration
> calling-convention-attributes.c:7:12: error: got f5ptr

I just applied a patch from Ramsay Jones which fixes this test case, and =
I've
applied your test case patch.

- Josh Triplett


--------------enig35DC84B008BCD1E5C2DF5FA9
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU3EUGJuZRtD+evsRAh71AJ9FMYVV9pDeNMnUR0arVI5Aqe1bnACgoo3K
ywOePQaaz6p7pkTFxUM+xZo=
=PzjO
-----END PGP SIGNATURE-----

--------------enig35DC84B008BCD1E5C2DF5FA9--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: OT ===

From: David Miller <davem () davemloft ! net>
To: linux-sparse
Subject: Re: OT
Date: Fri, 09 Mar 2007 02:15:38 +0000
Message-ID: <20070308.181538.51844021.davem () davemloft ! net>
--------------------
From: "Tommy Thorn" <tommy@numba-tu.com>
Date: Thu, 8 Mar 2007 17:12:44 -0800 (PST)

> Linus Torvalds said:
> ....
> > Thus endeth Linus' "games with bits" lecture. It was probably more than you
> > really wanted to know. There's a ton of games you can play with simple "x-1"
> and
> > bitmasking ops like this).
> 
> For anyone who enjoy this stuff (don't we all?), I heartily recommend Knuth's
> recent "Bitwise Tricks and Techniques" Pre-Fascicle:
> http://www-cs-faculty.stanford.edu/~knuth/news.html

Or "Hacker's Delight" which comes up from time to time on these
lists as well.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: OT [Re: sparse using insane amounts of memory] ===

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: OT [Re: sparse using insane amounts of memory]
Date: Fri, 09 Mar 2007 01:12:44 +0000
Message-ID: <44121.209.213.198.25.1173402764.squirrel () numba-tu ! com>
--------------------
Linus Torvalds said:
....
> Thus endeth Linus' "games with bits" lecture. It was probably more than you
> really wanted to know. There's a ton of games you can play with simple "x-1"
and
> bitmasking ops like this).

For anyone who enjoy this stuff (don't we all?), I heartily recommend Knuth's
recent "Bitwise Tricks and Techniques" Pre-Fascicle:
http://www-cs-faculty.stanford.edu/~knuth/news.html

Regards,
Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Over-eager code elimination? ===

From: Dan Sheridan <djs () postman ! org ! uk>
To: linux-sparse
Subject: Over-eager code elimination?
Date: Tue, 20 Feb 2007 10:38:22 +0000
Message-ID: <1171967902.5848.2.camel () localhost ! localdomain>
--------------------
Running test-linearize on some of my code, I seem to be losing an
assignment after a break.

In this minimal test code, y should have the previous iteration's value
of x, so the value returned is the difference between the final two
values from fetch():

int fetch(int);
int test(int v) {
  int x, y;
  for (int i=0; ; i++) {
    x = fetch(i);
    if (v < x) break;
    y = x;
  }
  return x-y;
}

test-linearize produces:
test:
.L0xb7db300c:
        <entry-point>
        br          .L0xb7db3034

.L0xb7db3034:
        call.32     %r2 <- fetch, $0
        setlt.32    %r5 <- %arg1, %r2
        dead        %r5
        br          %r5, .L0xb7db3084, .L0xb7db3034

.L0xb7db3084:
        dead        %r2
        sub.32      %r11 <- %r2, %r2
        dead        %r11
        ret.32      %r11

So it thinks that both x and y are in %r2. However, if y is initialised,
the assignment happens as expected.

Any ideas?

	Dan.



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Over-eager code elimination?
Date: Tue, 20 Feb 2007 17:30:53 +0000
Message-ID: <Pine.LNX.4.64.0702200818020.20368 () woody ! linux-foundation ! org>
--------------------


On Tue, 20 Feb 2007, Dan Sheridan wrote:
> 
> So it thinks that both x and y are in %r2. However, if y is initialised,
> the assignment happens as expected.
> 
> Any ideas?

Heh. I think you found a nasty nasty bug.

I didn't look very closely, but using "-vv" shows the loads of 'y' have 
been turned into lnop's, which means that the dominance analysis decided 
that it could just replace all uses of 'y' with the (single) assignment to 
it. Basically, it decides that the 

	y = x;

assignment always dominates the use ("return x-y"), so it will happily 
have turned it into "return x-x" (and then it *should* have simplified 
that, but didn't - it's not a simplification pattern I ever added).

Looks like some totally nasty, and probably very fundamental dominance 
analysis bug. I *suspect* that what happens is simply that we create a 
phi-node for the load (rewrite_load_instruction), but then since there is 
only a single phi source associated with it, we simplify it to just use 
the pseudo directly.

Which is why adding the initialization hides the bug: suddenly there is 
more than one dominator, and the bogus optimization goes away.

(It's possible that the optimization happened even before the PHI node was 
even created: we have several layers of this, and I think you may even be 
hitting the "we have a single def for this variable, so replace all loads 
with that def even without doing any dominance analysis AT ALL" case)

I'll try to look at it, but I may not have the time. It looks like a 
fairly fundamental thinko, though.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Over-eager code elimination?
Date: Wed, 21 Feb 2007 08:09:01 +0000
Message-ID: <20070221080901.GA3893 () chrisli ! org>
--------------------
On Tue, Feb 20, 2007 at 09:30:53AM -0800, Linus Torvalds wrote:
> 
> Looks like some totally nasty, and probably very fundamental dominance 
> analysis bug. I *suspect* that what happens is simply that we create a 
> phi-node for the load (rewrite_load_instruction), but then since there is 
> only a single phi source associated with it, we simplify it to just use 
> the pseudo directly.
> 
> Which is why adding the initialization hides the bug: suddenly there is 
> more than one dominator, and the bogus optimization goes away.

I think there is two problem here:

The first one is minor, 'y' can be used without initialized. 
We always give the 'y' the value as its last defined value.
Since not initialized value is not defined, I guess use the last
define one should be fine.

The second one is the bigger issue:

In simplify_one_symbol, we find out that the address of 'y' is not
taken, and y has only one store. So we happily go ahead replace
all the load with the define pseudo.

	/*
	 * Goodie, we have a single store (if even that) in the whole
	 * thing. Replace all loads with moves from the pseudo,
	 * replace the store with a def.
	 */

Notice that in this path, it uses convert_load_instruction instead
of rewrite_load_instruction. It does not do the phi stuff.

> (It's possible that the optimization happened even before the PHI node was 
> even created: we have several layers of this, and I think you may even be 
> hitting the "we have a single def for this variable, so replace all loads 
> with that def even without doing any dominance analysis AT ALL" case)

That is exactly what happened. But even if we use phi node here, it is
not correct. Because when it using the value of 'y', it is not using the latest
value of the phi node 'x'. It is using a old version of 'x' when "y = x;" happens.

It seems that we have to use a copy instruction here to save the old value of 'x'.

> I'll try to look at it, but I may not have the time. It looks like a 
> fairly fundamental thinko, though.

I take that as "I hope somebody else fix this so I don't have to." ;-)

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Please make "no member" error more informative ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Please make "no member" error more informative
Date: Thu, 31 May 2007 05:30:21 +0000
Message-ID: <1180589421.4159.58.camel () dv>
--------------------
Hello!

sparse reports the same error for two different situations.  Suppose
file test.c is:

struct ctl_table {
	int foo;
};

void test(struct ctl_table *sc)
{
	sc->ctl_name = 0;
}

$ sparse -Wall test.c 
test.c:7:4: error: no member 'ctl_name' in struct ctl_table

Rename the first ctl_table to ctl_table1, and the error will be the
same.

In the first case, the structure is known and lacks the requested
member.  In the second case, the structure is unknown.

I'll appreciate if somebody makes the messages different.  The message
is printed in evaluate_member_dereference() in evaluate.c.

Please test the case when only a forward declaration is available.  This
should be reported like the undeclared case.  Another test case is a
structure with no members.  It should be treated as declared.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re: [PATCH 15/16] deal with enum members without excessive PITA ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Re: [PATCH 15/16] deal with enum members without excessive PITA
Date: Fri, 14 Dec 2007 21:01:03 +0000
Message-ID: <70318cbf0712141301s7bafda84ta7d7b087a0f13685 () mail ! gmail ! com>
--------------------
------=_Part_2312_23891321.1197666063318
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Dec 14, 2007 4:09 AM, Thomas Schmid <Thomas.Schmid@br-automation.com> wrote:
> How about the idea, looping over the syms within global_scope?

I think that will work too.

> > > It should be trivial make a patch to add members to the parent
> > symbol->symbol_list though.
> Would you possibly?

Can you try the attached patch?

Chris

------=_Part_2312_23891321.1197666063318
Content-Type: application/octet-stream; name=enum-members
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fa77eyb80
Content-Disposition: attachment; filename=enum-members

QWRkIGVudW0gbWVtYmVyIGxpc3QgdG8gdGhlIHBhcmVudAoKU2lnbmVkLU9mZi1CeTogQ2hyaXN0
b3BoZXIgTGkgPHNwYXJzZUBjaHJpc2xpLm9yZz4KCkluZGV4OiBzcGFyc2UvcGFyc2UuYwo9PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09Ci0tLSBzcGFyc2Uub3JpZy9wYXJzZS5jCTIwMDctMTItMTQgMTI6MzM6MDUuMDAwMDAw
MDAwIC0wODAwCisrKyBzcGFyc2UvcGFyc2UuYwkyMDA3LTEyLTE0IDEyOjQyOjM5LjAwMDAwMDAw
MCAtMDgwMApAQCAtNjUxLDcgKzY1MSw2IEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKnBhcnNlX2Vu
dW1fZGVjbGFyYXQKIAl1bnNpZ25lZCBsb25nIGxvbmcgbGFzdHZhbCA9IDA7CiAJc3RydWN0IHN5
bWJvbCAqY3R5cGUgPSBOVUxMLCAqYmFzZV90eXBlID0gTlVMTDsKIAlOdW0gdXBwZXIgPSB7LTEs
IDB9LCBsb3dlciA9IHsxLCAwfTsKLQlzdHJ1Y3Qgc3ltYm9sX2xpc3QgKmVudHJpZXMgPSBOVUxM
OwogCiAJcGFyZW50LT5leGFtaW5lZCA9IDE7CiAJcGFyZW50LT5jdHlwZS5iYXNlX3R5cGUgPSAm
aW50X2N0eXBlOwpAQCAtNjg3LDcgKzY4Niw3IEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKnBhcnNl
X2VudW1fZGVjbGFyYXQKIAkJc3ltLT5pbml0aWFsaXplciA9IGV4cHI7CiAJCXN5bS0+ZW51bV9t
ZW1iZXIgPSAxOwogCQlzeW0tPmN0eXBlLmJhc2VfdHlwZSA9IHBhcmVudDsKLQkJYWRkX3B0cl9s
aXN0KCZlbnRyaWVzLCBzeW0pOworCQlhZGRfcHRyX2xpc3QoJnBhcmVudC0+c3ltYm9sX2xpc3Qs
IHN5bSk7CiAKIAkJaWYgKGJhc2VfdHlwZSAhPSAmYmFkX2N0eXBlKSB7CiAJCQlpZiAoY3R5cGUt
PnR5cGUgPT0gU1lNX05PREUpCkBAIC03NjMsOCArNzYyLDcgQEAgc3RhdGljIHN0cnVjdCB0b2tl
biAqcGFyc2VfZW51bV9kZWNsYXJhdAogCXBhcmVudC0+Y3R5cGUubW9kaWZpZXJzIHw9IChiYXNl
X3R5cGUtPmN0eXBlLm1vZGlmaWVycyAmIE1PRF9VTlNJR05FRCk7CiAJcGFyZW50LT5leGFtaW5l
ZCA9IDA7CiAKLQljYXN0X2VudW1fbGlzdChlbnRyaWVzLCBiYXNlX3R5cGUpOwotCWZyZWVfcHRy
X2xpc3QoJmVudHJpZXMpOworCWNhc3RfZW51bV9saXN0KHBhcmVudC0+c3ltYm9sX2xpc3QsIGJh
c2VfdHlwZSk7CiAKIAlyZXR1cm4gdG9rZW47CiB9Cg==
------=_Part_2312_23891321.1197666063318--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Running sparse on the Wine code (Was: Re: Ignore the cdecl and ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Running sparse on the Wine code (Was: Re: Ignore the cdecl and
Date: Wed, 23 May 2007 02:01:48 +0000
Message-ID: <4653A08C.40700 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigB74E50F6B9A13F6732E9E66B
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Michael Stefaniuc wrote:
> Josh Triplett wrote:
>> Michael Stefaniuc wrote:
>>> Josh Triplett wrote:
>>>> Don't pass -Wall to sparse unless you really mean it.  cgcc filters =
it out for
>>>> a reason; just because you have -Wall in CFLAGS for GCC doesn't mean=
 you want
>>>> -Wall for sparse.  Sparse -Wall includes some warnings with high fal=
se
>>>> positive rates that you probably don't want.
>>> Ok good to know. I went the easy way just duplicating the gcc command=
=20
>>> line and replacing gcc with sparse and adding -D__i386___ as Wine won=
't=20
>>> build without a processor type defined.
>> cgcc will define the processor type too.
>>
>> I highly recommend trying a build with CC=3Dcgcc.  You can then pass s=
parse
>> flags in CFLAGS, and cgcc will filter them out before calling CC; you =
can
>> also specify CHECK=3D"sparse -Wfoo -Wno-bar" if you prefer not to chan=
ge
>> CFLAGS.
> Hmm ... somehow i have confused cgcc with the code generating backend
> that Jeff Garzik planned to write for sparse. With cgcc i won't need my=

> Wine build hack anymore and makes things even easier for me.

Glad to hear it.

>>> I'm still trying to figure out=20
>>> if sparse is useful (signal to noise ratio) for Wine.
>> It will likely take some time and Sparse modifications in order to par=
se
>> Wine; however, I want Sparse to handle as much code as it can, not jus=
t
> With cgcc Wine builds just fine (I didn't try yet the configure and mak=
e
> depend stage of the build process). The only nitpick is that the ccache=

> cache from a normal build isn't valid anymore for the CC=3Dcgcc run. I'=
ll
> have a look into it the next time i'll have to wait for the build to fi=
nish.

This might happen due to differing compilation flags.  ccache records the=

compiler command line.

>> Linux.  I appreciate you trying it on Wine; I think working on this wi=
ll
>> help both Wine and Sparse.
>>
>>> Wine has some=20
>>> constraints (having to follow an existing old grown API; compatibilit=
y=20
>>> with other C processors on non Linux OSes) that aren't a burden for t=
he=20
>>> Linux Kernel. E.g. a patch to move to C99 struct initializer was=20
>>> recently rejected due to compatibility concerns with other C compiler=
s.
>> I just committed support for a -Wno-old-initializer flag to turn off t=
he
>> sparse warning on non-C99 initializers.
> That was fast and I didn't even request it :)

:)

>>>> The undefined preprocessor identifiers from limits.h come from not u=
sing cgcc,
>>>> which defines them.  Sparse should ideally define those itself.  You=
 can work
>>>> around the problem by using cgcc or by defining the symbols on the s=
parse
>>>> command line as cgcc does.
>>> I'll do a run with cgcc tonight instead of sparse and check the diffe=
rence.
> Updated
> http://people.redhat.com/mstefani/wine/download/wine+sparse-make.output=
=2Ebz2
> That is the result of:
> make clean; CHECK=3D'sparse -Wno-transparent-union -Wno-old-initializer=
'
> make CC=3Dcgcc > make.out 2>&1
> The output is with latest git sparse including the fix for the typedefs=

> to functions with a stdcall attribute.
> I didn't look at the output yet as it is past bed time around here.

Looks much better.

I've added a new -Wno-non-pointer-null flag which will turn off the "Usin=
g
plain integer as NULL pointer" warning, though unless you have a good rea=
son I
suggest fixing those warnings by using a pointer type like NULL rather th=
an 0.

"Bad character constant" seems to come from lines like this:
#define PROFILE_LINKED   'LINK'
The C standard says:
> The value of an integer character constant containing more than one
> character (e.g., 'ab'), or containing a character or escape sequence th=
at
> does not map to a single-byte execution character, is
> implementation-defined.
(http://c0x.coding-guidelines.com/6.4.4.4.html#879)
GCC seems to treat it as an integer, but GCC warns about it too.  If you =
want
to supply a patch to parse it the same way GCC does and generate an optio=
nal
warning, that seems reasonable.

The yacc-generated source seems to have some non-ANSI function declaratio=
ns.
I don't know if you can make it generate properly prototyped declarations=
=2E

I added __builtin_strcat and __builtin_strncat.  Wine seems to want the
latter, so this should fix several errors.

I added the constructor and destructor attributes, which Wine seems to wa=
nt.
That should fix a few errors.

You can turn off "do-while statement is not a compound statement" with
-Wno-do-while, but I'd recommend just fixing such loops to use compound
statements.  That said, I don't know why that warning occurs by default;
possibly it shouldn't.

You can fix the "preprocessor token SYMBOL redefined" warnings by using:
#ifndef SYMBOL
#define SYMBOL ...
#endif
You might manage to talk me into a -Wno-redefined-preprocessor, though.

Unknown escape warnings for \? and \E seem odd.  What does Wine expect
those to do?

"warning: crazy programmer" needs a better description, as soon as I
figure out what it means. :)

- Josh Triplett


--------------enigB74E50F6B9A13F6732E9E66B
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU6CMGJuZRtD+evsRAr2OAKCgQnZZnOdvvE2sqvxlJp67yoTSugCgq110
xwA6EL4eYH348Z2DzY0pnHw=
=QQWy
-----END PGP SIGNATURE-----

--------------enigB74E50F6B9A13F6732E9E66B--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Running sparse on the Wine code (Was: Re: Ignore the cdecl and stdcall ===

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Running sparse on the Wine code (Was: Re: Ignore the cdecl and stdcall
Date: Tue, 22 May 2007 23:44:13 +0000
Message-ID: <4653804D.3040306 () redhat ! com>
--------------------
Josh Triplett wrote:
> Michael Stefaniuc wrote:
>> Josh Triplett wrote:
>>> Don't pass -Wall to sparse unless you really mean it.  cgcc filters it out for
>>> a reason; just because you have -Wall in CFLAGS for GCC doesn't mean you want
>>> -Wall for sparse.  Sparse -Wall includes some warnings with high false
>>> positive rates that you probably don't want.
>> Ok good to know. I went the easy way just duplicating the gcc command 
>> line and replacing gcc with sparse and adding -D__i386___ as Wine won't 
>> build without a processor type defined.
> 
> cgcc will define the processor type too.
> 
> I highly recommend trying a build with CC=cgcc.  You can then pass sparse
> flags in CFLAGS, and cgcc will filter them out before calling CC; you can
> also specify CHECK="sparse -Wfoo -Wno-bar" if you prefer not to change
> CFLAGS.
Hmm ... somehow i have confused cgcc with the code generating backend
that Jeff Garzik planned to write for sparse. With cgcc i won't need my
Wine build hack anymore and makes things even easier for me.

>> I'm still trying to figure out 
>> if sparse is useful (signal to noise ratio) for Wine.
> 
> It will likely take some time and Sparse modifications in order to parse
> Wine; however, I want Sparse to handle as much code as it can, not just
With cgcc Wine builds just fine (I didn't try yet the configure and make
depend stage of the build process). The only nitpick is that the ccache
cache from a normal build isn't valid anymore for the CC=cgcc run. I'll
have a look into it the next time i'll have to wait for the build to finish.

> Linux.  I appreciate you trying it on Wine; I think working on this will
> help both Wine and Sparse.
> 
>> Wine has some 
>> constraints (having to follow an existing old grown API; compatibility 
>> with other C processors on non Linux OSes) that aren't a burden for the 
>> Linux Kernel. E.g. a patch to move to C99 struct initializer was 
>> recently rejected due to compatibility concerns with other C compilers.
> 
> I just committed support for a -Wno-old-initializer flag to turn off the
> sparse warning on non-C99 initializers.
That was fast and I didn't even request it :)

>>> The undefined preprocessor identifiers from limits.h come from not using cgcc,
>>> which defines them.  Sparse should ideally define those itself.  You can work
>>> around the problem by using cgcc or by defining the symbols on the sparse
>>> command line as cgcc does.
>> I'll do a run with cgcc tonight instead of sparse and check the difference.
Updated
http://people.redhat.com/mstefani/wine/download/wine+sparse-make.output.bz2
That is the result of:
make clean; CHECK='sparse -Wno-transparent-union -Wno-old-initializer'
make CC=cgcc > make.out 2>&1
The output is with latest git sparse including the fix for the typedefs
to functions with a stdcall attribute.
I didn't look at the output yet as it is past bed time around here.

bye
	michael
-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Signed divides vs shifts (Re: [Security] /dev/urandom uses ===

From: Eric Dumazet <dada1 () cosmosbay ! com>
To: linux-kernel
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses
Date: Mon, 17 Dec 2007 17:55:57 +0000
Message-ID: <20071217185557.0b501e23.dada1 () cosmosbay ! com>
--------------------
On Mon, 17 Dec 2007 09:28:57 -0800 (PST)
Linus Torvalds <torvalds@linux-foundation.org> wrote:

> 
> 
> On Sat, 15 Dec 2007, Herbert Xu wrote:
> > 
> > There ought to be a warning about this sort of thing.
> 
> We could add it to sparse. The appended (untested) patch seems to say 
> there's a lot of those signed divides-by-power-of-twos.
> 
> However, the problem with such warnings is that it encourages people to do 
> the simple fix that may be *wrong*. For example, you fixed it with patches 
> like
> 
> > -		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
> > +		int rsvd = r->limit ? 0 : random_read_wakeup_thresh / 4u;
> 
> which is really quite dangerous for several reasons:
> 
>  - it depends intimately on the type of the thing being divided (try it: 
>    it will do nothing at all if the thing you divide is larger than 
>    "unsigned int", since then the "4u" will be turned into a _signed_ 
>    larger type by the C type expansion).
> 

I was looking at lib/extable.c which does emit a signed divide on i386 but not on x86_64:

mid = (last - first) / 2 + first;

So I tried to compiled this on x86_64 :

long *mid(long *a, long *b)
{
	return ((a - b) / 2 + a);
}

It gave :
mid:
        movq    %rdi, %rdx
        subq    %rsi, %rdx
        sarq    $3, %rdx
        movq    %rdx, %rax
        shrq    $63, %rax
        addq    %rdx, %rax
        sarq    %rax
        leaq    (%rdi,%rax,8), %rax
        ret

while 

long *mid(long *a, long *b)
{
	return ((a - b) / 2u + a);
}

gave :
mid:
        movq    %rdi, %rdx
        subq    %rsi, %rdx
        sarq    $3, %rdx
        movq    %rdx, %rax
        shrq    $63, %rax
        addq    %rdx, %rax
        sarq    %rax
        leaq    (%rdi,%rax,8), %rax
        ret

and while :

long *mid(long *a, long *b)
{
	return (((unsigned long)(a - b)) / 2 + a);
}

gave :
mid:
        movq    %rdi, %rax
        subq    %rsi, %rax
        sarq    %rax
        andq    $-8, %rax
        addq    %rdi, %rax
        ret


But I found this cast ugly so I cooked this patch.

[PATCH] Avoid signed arithmetics in search_extable()

On i386 and gcc-4.2.{1|2}, search_extable() currently does integer divides (by 2 !!!), while
we can certainly use a right shift. This looks more a typical bsearch() implementation.

Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>

diff --git a/lib/extable.c b/lib/extable.c
index 463f456..03a81bd 100644
--- a/lib/extable.c
+++ b/lib/extable.c
@@ -54,20 +54,20 @@ search_extable(const struct exception_table_entry *first,
 	       const struct exception_table_entry *last,
 	       unsigned long value)
 {
-	while (first <= last) {
-		const struct exception_table_entry *mid;
+	unsigned long mid, low = 0, high = (last - first);
 
-		mid = (last - first) / 2 + first;
+	while (low <= high) {
+		mid = (low + high) / 2;
 		/*
 		 * careful, the distance between entries can be
-		 * larger than 2GB:
+		 * larger than MAX_LONG:
 		 */
-		if (mid->insn < value)
-			first = mid + 1;
-		else if (mid->insn > value)
-			last = mid - 1;
+		if (first[mid].insn < value)
+			low = mid + 1;
+		else if (first[mid].insn > value)
+			high = mid - 1;
 		else
-			return mid;
+			return first + mid;
         }
         return NULL;
 }
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Eric Dumazet <dada1 () cosmosbay ! com>
To: linux-sparse
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses
Date: Mon, 17 Dec 2007 18:10:17 +0000
Message-ID: <20071217191017.117c61ff.dada1 () cosmosbay ! com>
--------------------
On Mon, 17 Dec 2007 10:05:35 -0800
"Ray Lee" <ray-lk@madrabbit.org> wrote:

> On Dec 17, 2007 9:55 AM, Eric Dumazet <dada1@cosmosbay.com> wrote:
> > -               mid = (last - first) / 2 + first;
> > +       while (low <= high) {
> > +               mid = (low + high) / 2;
> 
> I think you just introduced a bug. Think about what happens if
> low=high=MAX_LONG/2 + 1.
> 

Fortunatly this is not possible :)

Hint : sizeof(struct exception_table_entry) is >= 8

so high is garanteed to be <= MAX_LONG/8

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-kernel
Subject: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit
Date: Mon, 17 Dec 2007 17:28:57 +0000
Message-ID: <alpine.LFD.0.9999.0712170856050.21557 () woody ! linux-foundation ! org>
--------------------


On Sat, 15 Dec 2007, Herbert Xu wrote:
> 
> There ought to be a warning about this sort of thing.

We could add it to sparse. The appended (untested) patch seems to say 
there's a lot of those signed divides-by-power-of-twos.

However, the problem with such warnings is that it encourages people to do 
the simple fix that may be *wrong*. For example, you fixed it with patches 
like

> -		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
> +		int rsvd = r->limit ? 0 : random_read_wakeup_thresh / 4u;

which is really quite dangerous for several reasons:

 - it depends intimately on the type of the thing being divided (try it: 
   it will do nothing at all if the thing you divide is larger than 
   "unsigned int", since then the "4u" will be turned into a _signed_ 
   larger type by the C type expansion).

   So in general, the above doesn't even do what it's supposed to do on a 
   64-bit architecture if the thing to be divided is 64-bit!

 - it changes behaviour. If that thing really is signed and can be 
   negative, that "trivial" patch just changed the divide to be 
   fundamentally something totally different.

so I think this patch is horribly wrong.

The *correct* way to fix signed divisions is by doing one of two things:

 - really make the data we divide be unsigned. With all the thinking that 
   involves!

   This is the good change, but it does involve making sure that there are 
   no tests against zero and that the value really cannot go negative. 
   Usually the unsigned types are (a) faster and (b) more robust, but if 
   somebody is depending on signs, unsigned types are obviously not 
   appropriate.

 - change a divide-by-power-of-2 into a signed shift instead.

   Yes, this also changes the end result for negative values, but it 
   changes it in a sane and generally good way (ie it will still be a 
   "valid" divide, it will just be a divide that rounds differently, and 
   is more likely than turning it into an unsigned divide to generally 
   result in working code).

Hmm?

			Linus
---
 simplify.c |   30 ++++++++++++++++++++++++++++++
 1 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/simplify.c b/simplify.c
index 94e14d2..91f1120 100644
--- a/simplify.c
+++ b/simplify.c
@@ -286,6 +286,36 @@ static int simplify_constant_rightside(struct instruction *insn)
 		if (!value)
 			return replace_with_pseudo(insn, insn->src2);
 		return 0;
+
+	case OP_DIVU: case OP_DIVS:
+		if (!value)
+			break;
+		if (value == 1)
+			return replace_with_pseudo(insn, insn->src1);
+		/* Power-of-two? */
+		if (!(value & (value-1))) {
+			int log2 = -1;
+			do {
+				log2++;
+				value >>= 1;
+			} while (value);
+
+			/* Turn unsigned divides into shifts */
+			if (insn->opcode == OP_DIVU) {
+				insn->src2->value = log2;
+				insn->opcode = OP_LSR;
+				return 1;
+			}
+
+			/*
+			 * This is incorrect, but we care more about
+			 * the warning than the code generation
+			 */
+			warning(insn->pos, "expensive signed divide");
+			insn->src2->value = log2;
+			insn->opcode = OP_ASR;
+			return 1;
+		}
 	}
 	return 0;
 }
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit
Date: Mon, 17 Dec 2007 17:28:57 +0000
Message-ID: <alpine.LFD.0.9999.0712170856050.21557 () woody ! linux-foundation ! org>
--------------------


On Sat, 15 Dec 2007, Herbert Xu wrote:
> 
> There ought to be a warning about this sort of thing.

We could add it to sparse. The appended (untested) patch seems to say 
there's a lot of those signed divides-by-power-of-twos.

However, the problem with such warnings is that it encourages people to do 
the simple fix that may be *wrong*. For example, you fixed it with patches 
like

> -		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
> +		int rsvd = r->limit ? 0 : random_read_wakeup_thresh / 4u;

which is really quite dangerous for several reasons:

 - it depends intimately on the type of the thing being divided (try it: 
   it will do nothing at all if the thing you divide is larger than 
   "unsigned int", since then the "4u" will be turned into a _signed_ 
   larger type by the C type expansion).

   So in general, the above doesn't even do what it's supposed to do on a 
   64-bit architecture if the thing to be divided is 64-bit!

 - it changes behaviour. If that thing really is signed and can be 
   negative, that "trivial" patch just changed the divide to be 
   fundamentally something totally different.

so I think this patch is horribly wrong.

The *correct* way to fix signed divisions is by doing one of two things:

 - really make the data we divide be unsigned. With all the thinking that 
   involves!

   This is the good change, but it does involve making sure that there are 
   no tests against zero and that the value really cannot go negative. 
   Usually the unsigned types are (a) faster and (b) more robust, but if 
   somebody is depending on signs, unsigned types are obviously not 
   appropriate.

 - change a divide-by-power-of-2 into a signed shift instead.

   Yes, this also changes the end result for negative values, but it 
   changes it in a sane and generally good way (ie it will still be a 
   "valid" divide, it will just be a divide that rounds differently, and 
   is more likely than turning it into an unsigned divide to generally 
   result in working code).

Hmm?

			Linus
---
 simplify.c |   30 ++++++++++++++++++++++++++++++
 1 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/simplify.c b/simplify.c
index 94e14d2..91f1120 100644
--- a/simplify.c
+++ b/simplify.c
@@ -286,6 +286,36 @@ static int simplify_constant_rightside(struct instruction *insn)
 		if (!value)
 			return replace_with_pseudo(insn, insn->src2);
 		return 0;
+
+	case OP_DIVU: case OP_DIVS:
+		if (!value)
+			break;
+		if (value == 1)
+			return replace_with_pseudo(insn, insn->src1);
+		/* Power-of-two? */
+		if (!(value & (value-1))) {
+			int log2 = -1;
+			do {
+				log2++;
+				value >>= 1;
+			} while (value);
+
+			/* Turn unsigned divides into shifts */
+			if (insn->opcode == OP_DIVU) {
+				insn->src2->value = log2;
+				insn->opcode = OP_LSR;
+				return 1;
+			}
+
+			/*
+			 * This is incorrect, but we care more about
+			 * the warning than the code generation
+			 */
+			warning(insn->pos, "expensive signed divide");
+			insn->src2->value = log2;
+			insn->opcode = OP_ASR;
+			return 1;
+		}
 	}
 	return 0;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data) ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-kernel
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 17:48:06 +0000
Message-ID: <20071217174806.GC8181 () ftp ! linux ! org ! uk>
--------------------
On Mon, Dec 17, 2007 at 09:28:57AM -0800, Linus Torvalds wrote:
> 
> 
> On Sat, 15 Dec 2007, Herbert Xu wrote:
> > 
> > There ought to be a warning about this sort of thing.
> 
> We could add it to sparse. The appended (untested) patch seems to say 
> there's a lot of those signed divides-by-power-of-twos.

I'm not sure that you are warning about the right things.  If you want
a real nightmare scenario in that area, consider this:

	int x[20];

	int *p = x + n;
	int *q = x + m;

	p - q
	((char *)p - (char *)q)/4
	((char *)p - (char *)q)/sizeof(int)

The first two are equivalent on all targets we care about.  However, an
attempt to make the second one "more portable" silently creates the
code that'll do something entirely different as soon as we get m > n...
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 17:48:06 +0000
Message-ID: <20071217174806.GC8181 () ftp ! linux ! org ! uk>
--------------------
On Mon, Dec 17, 2007 at 09:28:57AM -0800, Linus Torvalds wrote:
> 
> 
> On Sat, 15 Dec 2007, Herbert Xu wrote:
> > 
> > There ought to be a warning about this sort of thing.
> 
> We could add it to sparse. The appended (untested) patch seems to say 
> there's a lot of those signed divides-by-power-of-twos.

I'm not sure that you are warning about the right things.  If you want
a real nightmare scenario in that area, consider this:

	int x[20];

	int *p = x + n;
	int *q = x + m;

	p - q
	((char *)p - (char *)q)/4
	((char *)p - (char *)q)/sizeof(int)

The first two are equivalent on all targets we care about.  However, an
attempt to make the second one "more portable" silently creates the
code that'll do something entirely different as soon as we get m > n...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Ray Lee" <ray-lk () madrabbit ! org>
To: linux-sparse
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 18:05:35 +0000
Message-ID: <2c0942db0712171005w65bbb512p71a4f9b1fc65c6a7 () mail ! gmail ! com>
--------------------
On Dec 17, 2007 9:55 AM, Eric Dumazet <dada1@cosmosbay.com> wrote:
> -               mid = (last - first) / 2 + first;
> +       while (low <= high) {
> +               mid = (low + high) / 2;

I think you just introduced a bug. Think about what happens if
low=high=MAX_LONG/2 + 1.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Ray Lee" <ray-lk () madrabbit ! org>
To: linux-kernel
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 18:05:35 +0000
Message-ID: <2c0942db0712171005w65bbb512p71a4f9b1fc65c6a7 () mail ! gmail ! com>
--------------------
On Dec 17, 2007 9:55 AM, Eric Dumazet <dada1@cosmosbay.com> wrote:
> -               mid = (last - first) / 2 + first;
> +       while (low <= high) {
> +               mid = (low + high) / 2;

I think you just introduced a bug. Think about what happens if
low=high=MAX_LONG/2 + 1.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "Ray Lee" <ray-lk () madrabbit ! org>
To: linux-sparse
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 18:12:47 +0000
Message-ID: <2c0942db0712171012o613b2596x81f4a867e2b5c01 () mail ! gmail ! com>
--------------------
On Dec 17, 2007 10:10 AM, Eric Dumazet <dada1@cosmosbay.com> wrote:
> On Mon, 17 Dec 2007 10:05:35 -0800
> "Ray Lee" <ray-lk@madrabbit.org> wrote:
>
> > On Dec 17, 2007 9:55 AM, Eric Dumazet <dada1@cosmosbay.com> wrote:
> > > -               mid = (last - first) / 2 + first;
> > > +       while (low <= high) {
> > > +               mid = (low + high) / 2;
> >
> > I think you just introduced a bug. Think about what happens if
> > low=high=MAX_LONG/2 + 1.
> >
>
> Fortunatly this is not possible :)
>
> Hint : sizeof(struct exception_table_entry) is >= 8
>
> so high is garanteed to be <= MAX_LONG/8

Ah, my bad. One of these days I'll learn to not post before coffee.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Ray Lee" <ray-lk () madrabbit ! org>
To: linux-kernel
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 18:12:47 +0000
Message-ID: <2c0942db0712171012o613b2596x81f4a867e2b5c01 () mail ! gmail ! com>
--------------------
On Dec 17, 2007 10:10 AM, Eric Dumazet <dada1@cosmosbay.com> wrote:
> On Mon, 17 Dec 2007 10:05:35 -0800
> "Ray Lee" <ray-lk@madrabbit.org> wrote:
>
> > On Dec 17, 2007 9:55 AM, Eric Dumazet <dada1@cosmosbay.com> wrote:
> > > -               mid = (last - first) / 2 + first;
> > > +       while (low <= high) {
> > > +               mid = (low + high) / 2;
> >
> > I think you just introduced a bug. Think about what happens if
> > low=high=MAX_LONG/2 + 1.
> >
>
> Fortunatly this is not possible :)
>
> Hint : sizeof(struct exception_table_entry) is >= 8
>
> so high is garanteed to be <= MAX_LONG/8

Ah, my bad. One of these days I'll learn to not post before coffee.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-kernel
Subject: Re: Signed divides vs shifts (Re: [Security] /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 18:23:12 +0000
Message-ID: <20071217182312.GD8181 () ftp ! linux ! org ! uk>
--------------------
On Mon, Dec 17, 2007 at 06:55:57PM +0100, Eric Dumazet wrote:

> long *mid(long *a, long *b)
> {
> 	return ((a - b) / 2 + a);
> }

... is not actually a middle (you'd want b-a, not a-b there), but anyway

> It gave :
> mid:
>         movq    %rdi, %rdx
>         subq    %rsi, %rdx
>         sarq    $3, %rdx
>         movq    %rdx, %rax
>         shrq    $63, %rax
>         addq    %rdx, %rax
>         sarq    %rax
>         leaq    (%rdi,%rax,8), %rax
>         ret
> 
> while 
> 
> long *mid(long *a, long *b)
> {
> 	return ((a - b) / 2u + a);
> }

... undefined behaviour if a < b

> and while :
> 
> long *mid(long *a, long *b)
> {
> 	return (((unsigned long)(a - b)) / 2 + a);
> }

undefined behaviour, again.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: Sparse 0.4.1 released ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Sparse 0.4.1 released
Date: Tue, 13 Nov 2007 12:39:27 +0000
Message-ID: <47399AFF.7040009 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig282CC6C74F817FF5396D3740
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I have tagged and tarballed Sparse 0.4.1, now available from
<http://kernel.org/pub/software/devel/sparse/dist/sparse-0.4.1.tar.gz>,
with sha1sum `14085c5317cd7f2c8392fb762969906fa91888ef`.

This bugfix release fixes a Sparse assertion which recent Linux kernels s=
tarted
triggering, along with a few other fixes.

Several outstanding patches exist which need to go into the Sparse tree, =
but
this release does not contain those patches because people wouldn't have
had the opportunity to test them enough.

Full changelog:

Christopher Li (1):
      Perform local label lookup

Emil Medve (1):
      Handle ignored attribute malloc

Josh Triplett (4):
      Add comment on taint flags enum referencing expr->taint
      Add test-suite metadata to validation/local-label.c
      Add known-to-fail test case for a static forward declaration
      Makefile: VERSION=3D0.4.1

Mike Frysinger (1):
      fix install perms of manpages

Tilman Sauerbeck (1):
      Added a prototype for mempcpy().

-- Josh Triplett


--------------enig282CC6C74F817FF5396D3740
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHOZr/GJuZRtD+evsRAu4eAKCN2KkNVsuBs78U1urytpQVzWqCpwCePKe4
0VrCtoW8cmV0yK/9BPNTSoc=
=pqOj
-----END PGP SIGNATURE-----

--------------enig282CC6C74F817FF5396D3740--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse RFC ===

From: "Darren Jenkins\\" <darrenrjenkins () gmail ! com>
To: linux-sparse
Subject: Sparse RFC
Date: Mon, 26 Mar 2007 13:29:35 +0000
Message-ID: <1174915776.1142.21.camel () localhost ! localdomain>
--------------------
G'day people,

I have been playing around with the sparse code, and was thinking of
adding a few of the checks that my company uses from other code
checkers, starting with checking that macro arguments have brackets
around them. (Because this is the test my/other code most often fails)

I have put together a quick patch to see what everyone thinks of it. It
is obviously not a finished product but I wanted to see peoples
reactions to this type of thing.

I also have a few questions;

1) Do we want to add a Wdescription switch for each test sparse
performs ? or do we want to group tests under Wstyle Wefficiency
WCodingStandard type group switches ?

2) For the macro argument checking would it be better if I checked for
either a bracket or low precedence operator on both sides of the
argument ? like either a comma or a type of assignment operator? it
would not be a foolproof check then but would seem more sensible to me,
and might be more acceptable to users.

Anyway here is the patch 


diff --git a/lib.c b/lib.c
index 79a5c55..27c9fe1 100644
--- a/lib.c
+++ b/lib.c
@@ -204,6 +204,7 @@ int Waddress_space = 1;
 int Wenum_mismatch = 1;
 int Wdo_while = 1;
 int Wuninitialized = 1;
+int Wmacro_argument_brackets = 1;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
diff --git a/lib.h b/lib.h
index 472624d..2657ce3 100644
--- a/lib.h
+++ b/lib.h
@@ -98,6 +98,7 @@ extern int Wshadow;
 extern int Wcast_truncate;
 extern int Wdo_while;
 extern int Wuninitialized;
+extern int Wmacro_argument_brackets;
 
 extern int dbg_entry;
 extern int dbg_dead;
diff --git a/pre-process.c b/pre-process.c
index afae77a..a04a157 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -1034,7 +1034,9 @@ static struct token *parse_expansion(str
 		} else if (match_op(token->next, SPECIAL_HASHHASH)) {
 			try_arg(token, TOKEN_QUOTED_ARGUMENT, arglist);
 		} else {
-			try_arg(token, TOKEN_MACRO_ARGUMENT, arglist);
+			int argument = try_arg(token, TOKEN_MACRO_ARGUMENT, arglist);
+			if (argument  == 1 && Wmacro_argument_brackets && (!match_op(token->next, ')') || !match_op(last, '(')) )
+				warning(token->pos, "Macro argument is not bracketed in expansion");
 		}
 		if (token_type(token) == TOKEN_ERROR)
 			goto Earg;
diff --git a/token.h b/token.h
diff --git a/tokenize.c b/tokenize.c

 

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: Sparse RFC
Date: Mon, 26 Mar 2007 16:15:23 +0000
Message-ID: <4607F19B.6080303 () knosof ! co ! uk>
--------------------
Darren,

> I have been playing around with the sparse code, and was thinking of
> adding a few of the checks that my company uses from other code
> checkers, starting with checking that macro arguments have brackets
> around them. (Because this is the test my/other code most often fails)

This is a useful check.  However, you need to make sure that
cases where the presence of () have no impact are not flagged
if the parameter is always used in such contexts.  Otherwise the
noise can be excessive.

> 2) For the macro argument checking would it be better if I checked for
> either a bracket or low precedence operator on both sides of the
> argument ? like either a comma or a type of assignment operator? it
> would not be a foolproof check then but would seem more sensible to me,
> and might be more acceptable to users.

Don't make the assumption that everybody knows the precedence
of binary operators.  An experiment I ran last year with experienced
developers (average over 10 years) threw up some unexpected results.
See: http://www.knosof.co.uk/cbook/accu06a.pdf

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Sparse RFC
Date: Mon, 26 Mar 2007 21:21:26 +0000
Message-ID: <Pine.LNX.4.64.0703261414400.6730 () woody ! linux-foundation ! org>
--------------------


On Mon, 26 Mar 2007, Derek M Jones wrote:
> 
> > I have been playing around with the sparse code, and was thinking of
> > adding a few of the checks that my company uses from other code
> > checkers, starting with checking that macro arguments have brackets
> > around them. (Because this is the test my/other code most often fails)
> 
> This is a useful check.  However, you need to make sure that
> cases where the presence of () have no impact are not flagged
> if the parameter is always used in such contexts.  Otherwise the
> noise can be excessive.

Indeed. In the kernel, for example, we sometimes use nested macros for the 
complex cases, and there one of the cases is where the "outer" or inner 
macro adds all required brackets. Ie something like

	#define ALIGN(x,a)              __ALIGN_MASK(x,(typeof(x))(a)-1)
	#define __ALIGN_MASK(x,mask)    (((x)+(mask))&~(mask))

where ALIGN() uses 'x' without any brackets, because it knows the inner 
macro is safe (and a comma expression must have had any brackets of its 
own, otherwise it wouldn't have parsed as a single macro argument anyway!)

> > 2) For the macro argument checking would it be better if I checked for
> > either a bracket or low precedence operator on both sides of the
> > argument ? like either a comma or a type of assignment operator? it
> > would not be a foolproof check then but would seem more sensible to me,
> > and might be more acceptable to users.
> 
> Don't make the assumption that everybody knows the precedence
> of binary operators.  An experiment I ran last year with experienced
> developers (average over 10 years) threw up some unexpected results.
> See: http://www.knosof.co.uk/cbook/accu06a.pdf

Yeah. The only exception is literally the comma expression, because of the 
syntax of macro expansion itself (ie a comma would break a macro argument, 
unless it is bracketed). Pretty much all other precedence rules can pretty 
much be expected to be confused by somebody.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Darren Jenkins" <darrenrjenkins () gmail ! com>
To: linux-sparse
Subject: Re: Sparse RFC
Date: Tue, 27 Mar 2007 03:07:53 +0000
Message-ID: <82faac5b0703262007u71a95cfcre64ff29c5df62b38 () mail ! gmail ! com>
--------------------
On 3/27/07, Linus Torvalds <torvalds@linux-foundation.org> wrote:
> On Mon, 26 Mar 2007, Derek M Jones wrote:
>
> > This is a useful check.  However, you need to make sure that
> > cases where the presence of () have no impact are not flagged
> > if the parameter is always used in such contexts.  Otherwise the
> > noise can be excessive.
>
> Indeed. In the kernel, for example, we sometimes use nested macros for the
> complex cases, and there one of the cases is where the "outer" or inner
> macro adds all required brackets. Ie something like
>
>         #define ALIGN(x,a)              __ALIGN_MASK(x,(typeof(x))(a)-1)
>         #define __ALIGN_MASK(x,mask)    (((x)+(mask))&~(mask))
>
> where ALIGN() uses 'x' without any brackets, because it knows the inner
> macro is safe (and a comma expression must have had any brackets of its
> own, otherwise it wouldn't have parsed as a single macro argument anyway!)

Hmm it looks like a 'bracket or comma' check wouid correcly ignore
this particular example.

It is obvious however that I need to think about this a bit more.


> > > 2) For the macro argument checking would it be better if I checked for
> > > either a bracket or low precedence operator on both sides of the
> > > argument ? like either a comma or a type of assignment operator? it
> > > would not be a foolproof check then but would seem more sensible to me,
> > > and might be more acceptable to users.
> >
> > Don't make the assumption that everybody knows the precedence
> > of binary operators.  An experiment I ran last year with experienced
> > developers (average over 10 years) threw up some unexpected results.
> > See: http://www.knosof.co.uk/cbook/accu06a.pdf

Yep I am guilty of getting them wrong before.

> Yeah. The only exception is literally the comma expression, because of the
> syntax of macro expansion itself (ie a comma would break a macro argument,
> unless it is bracketed). Pretty much all other precedence rules can pretty
> much be expected to be confused by somebody.

I didn't look into it but I was thinking that something that evaluated
into a comma, after the initial macro expansion would still be
passible/an issue.



Thanks for the feedback guys. I guess I will keep tinkering with it.

Darren J.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?=
To: linux-sparse
Subject: Re: Sparse RFC
Date: Tue, 27 Mar 2007 12:04:45 +0000
Message-ID: <20070327120445.GD12178 () informatik ! uni-freiburg ! de>
--------------------
Hi Darren,


Derek M Jones wrote:
> Darren,

> >I have been playing around with the sparse code, and was thinking of
> >adding a few of the checks that my company uses from other code
> >checkers, starting with checking that macro arguments have brackets
> >around them. (Because this is the test my/other code most often fails)

> This is a useful check.  However, you need to make sure that
> cases where the presence of () have no impact are not flagged
> if the parameter is always used in such contexts.  Otherwise the
> noise can be excessive.

> >2) For the macro argument checking would it be better if I checked for
> >either a bracket or low precedence operator on both sides of the
> >argument ? like either a comma or a type of assignment operator? it
> >would not be a foolproof check then but would seem more sensible to me,
> >and might be more acceptable to users.
You have to consider ## and #, too.  E.g. look at
include/linux/stringify.h, or SOCKCALL_WRAP in include/linux/net.h

BTW, SOCKCALL_WRAP is funny anyhow, because the last two arguments are
supposed to be function arguments (resp. their type list).

Best regards
Uwe


-- 
Uwe Kleine-K√∂nig

http://www.google.com/search?q=5%2B7
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse fooled by double semicolon ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Sparse fooled by double semicolon
Date: Wed, 31 Jan 2007 04:50:27 +0000
Message-ID: <1170219027.11455.68.camel () dv>
--------------------
Hello!

I have reduced a spurious sparse message to the following test:

#include <string.h>
void test(void)
{
	struct { int foo;; } val;
	memset(&val, 0, sizeof(val));
}

Running sparse on this code gives:

test.c:5:8: warning: memset with byte count of 0

Replacing two semicolons with one fixes the warning.  That's the current
sparse (006eff06c7adcfb0d06c6fadf6e9b64f0488b2bf) with no local changes.

-- 
Regards,
Pavel Roskin


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse homepage moved; Git repository moving soon [Re: update ===

From: "H. Peter Anvin" <hpa () zytor ! com>
To: linux-sparse
Subject: Re: Sparse homepage moved; Git repository moving soon [Re: update
Date: Tue, 13 Mar 2007 23:31:55 +0000
Message-ID: <45F7346B.6040605 () zytor ! com>
--------------------
Josh Triplett wrote:
> 
> However, I know that other people sometimes maintain Sparse Git repositories,
> and as far as I can tell, "people" directories only exist under
> /pub/linux/kernel/people.  Where should people keep Sparse repos, if not
> there?
> 

What we do is to, on request, create directories like 
/pub/scm/devel/sparse/<username> for that kind of stuff.  Let us know 
who needs them.  (This is one of many reasons you tend to see 
/pub/scm/foo/bar/bar.git as the repository path, another one is so the 
maintainer can create additional repositories as needed.)

> Also, if possible, I'd like to have an HTTP 301 redirect from
> http://kernel.org/pub/linux/kernel/people/josh/sparse (and everything under
> it, via RedirectMatch) to the corresponding page under the new homepage at
> http://kernel.org/pub/software/devel/sparse .  Could someone with the
> appropriate access please do so, or let me know if I can do so somehow?

I *think* you can just put an .htaccess file in your directory to have 
that happen.  However, please note that the URL should be 
http://www.kernel.org/... ; it may matter in the future.

	-hpa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "H. Peter Anvin" <hpa () zytor ! com>
To: linux-sparse
Subject: Re: Sparse homepage moved; Git repository moving soon [Re: update
Date: Mon, 19 Mar 2007 01:21:31 +0000
Message-ID: <45FDE59B.6030702 () zytor ! com>
--------------------
Josh Triplett wrote:
> H. Peter Anvin wrote:
>> Josh Triplett wrote:
>>> Also, if possible, I'd like to have an HTTP 301 redirect from
>>> http://kernel.org/pub/linux/kernel/people/josh/sparse (and everything under
>>> it, via RedirectMatch) to the corresponding page under the new homepage at
>>> http://kernel.org/pub/software/devel/sparse .  Could someone with the
>>> appropriate access please do so, or let me know if I can do so somehow?
>> I *think* you can just put an .htaccess file in your directory to have 
>> that happen.
> 
> That doesn't seem to work.  The .htaccess file
> (/pub/linux/kernel/people/josh/sparse/.htaccess) gets mirrored, but seems to
> get ignored.  It contains the following:
> 
> Redirect /pub/linux/kernel/people/josh/sparse http://www.kernel.org/pub/software/devel/sparse
> 

That should be fixed, but you want to change that to "Redirect permanent 
..." otherwise you get a 302 redirect, not 301.

	-hpa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () kernel ! org>
To: linux-sparse
Subject: Re: Sparse homepage moved; Git repository moving soon [Re: update
Date: Mon, 19 Mar 2007 01:38:35 +0000
Message-ID: <45FDE99B.20909 () kernel ! org>
--------------------
H. Peter Anvin wrote:
> Josh Triplett wrote:
>> H. Peter Anvin wrote:
>>> Josh Triplett wrote:
>>>> Also, if possible, I'd like to have an HTTP 301 redirect from
>>>> http://kernel.org/pub/linux/kernel/people/josh/sparse (and everything under
>>>> it, via RedirectMatch) to the corresponding page under the new homepage at
>>>> http://kernel.org/pub/software/devel/sparse .  Could someone with the
>>>> appropriate access please do so, or let me know if I can do so somehow?
>>> I *think* you can just put an .htaccess file in your directory to have 
>>> that happen.
>> That doesn't seem to work.  The .htaccess file
>> (/pub/linux/kernel/people/josh/sparse/.htaccess) gets mirrored, but seems to
>> get ignored.  It contains the following:
>>
>> Redirect /pub/linux/kernel/people/josh/sparse http://www.kernel.org/pub/software/devel/sparse
> 
> That should be fixed,

Thanks!  Seems to work now.

> but you want to change that to "Redirect permanent 
> ..." otherwise you get a 302 redirect, not 301.

Argh; I noted that when doublechecking the syntax in the Apache documentation,
and promptly failed to do it when writing the .htaccess file.  Fixed, and
thanks for noticing.

- Josh Triplett
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse homepage moved; Git repository moving soon [Re: update 'getting ===

From: Josh Triplett <josh () kernel ! org>
To: linux-sparse
Subject: Sparse homepage moved; Git repository moving soon [Re: update 'getting
Date: Tue, 13 Mar 2007 23:27:13 +0000
Message-ID: <45F73351.5080505 () kernel ! org>
--------------------
H. Peter Anvin wrote:
> Linus Torvalds wrote:
>> On Thu, 8 Mar 2007, H. Peter Anvin wrote:
>>> Please don't put non-kernel software in /pub/linux/kernel and
>>> /pub/scm/linux/kernel on kernel.org.
>>>
>>> IN PARTICULAR, if Josh is the new sparse maintainer, please contact
>>> ftpadmin@kernel.org so we can either create a group or simply chown the
>>> standard locations (/pub/software/devel/sparse, /pub/scm/devel/sparse) to him
>>> instead of leaving stale stuff where people can find it!
>> Yes, let's just do that. Whoever has the right magic touch, please just 
>> chown those things to Josh.
> 
> Done.

I have moved the Sparse homepage to
http://kernel.org/pub/software/devel/sparse .  (That location previously
contained an old BK repo of Sparse; I tarred that up and saved it if anyone
wants it for some reason, but I think the Git repo contains the history.)

I will soon move the Git repository as well, to the original location at
/pub/scm/devel/sparse/sparse.git .  I will likely maintain a symlink from my
current repo's location, to avoid gratuitously breaking people's checkouts or
automated scripts.

However, I know that other people sometimes maintain Sparse Git repositories,
and as far as I can tell, "people" directories only exist under
/pub/linux/kernel/people.  Where should people keep Sparse repos, if not
there?

Also, if possible, I'd like to have an HTTP 301 redirect from
http://kernel.org/pub/linux/kernel/people/josh/sparse (and everything under
it, via RedirectMatch) to the corresponding page under the new homepage at
http://kernel.org/pub/software/devel/sparse .  Could someone with the
appropriate access please do so, or let me know if I can do so somehow?

- Josh Triplett
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse just seg faulted on me! ===

From: Anton Altaparmakov <aia21 () cam ! ac ! uk>
To: linux-sparse
Subject: Sparse just seg faulted on me!
Date: Wed, 14 Feb 2007 09:04:48 +0000
Message-ID: <9C17AC42-0C51-44D9-B126-1FB781DE0ECA () cam ! ac ! uk>
--------------------
I typoed (see CTL_UNNUMBRED should be CTL_UNNUMBERED) and got an  
error which is fine but then sparse seg faulted!  I think that is a  
bug...

$ make CHECKFLAGS="-D__CHECK_ENDIAN__" C=2 modules
[snip]
  CHECK   fs/ntfs/sysctl.c
fs/ntfs/sysctl.c:38:15: error: undefined identifier 'CTL_UNNUMBRED'
/bin/sh: line 1: 26154 Segmentation fault      sparse - 
D__CHECK_ENDIAN__ -Wp,-MD,fs/ntfs/.sysctl.o.d -nostdinc -isystem /usr/ 
lib/gcc/i586-suse-linux/4.1.0/include -D__KERNEL__ -Iinclude -include  
include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno- 
trigraphs -fno-strict-aliasing -fno-common -Os -pipe -msoft-float - 
mregparm=3 -mpreferred-stack-boundary=2 -march=i686 -mtune=pentium4 - 
ffreestanding -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 - 
DCONFIG_AS_CFI_SIGNAL_FRAME=1 -Iinclude/asm-i386/mach-default -fno- 
omit-frame-pointer -fno-optimize-sibling-calls -g -fno-stack- 
protector -Wdeclaration-after-statement -Wno-pointer-sign - 
DNTFS_VERSION=\"2.3\" -DDEBUG -DNTFS_RW -DMODULE -D"KBUILD_STR(s)=#s"  
-D"KBUILD_BASENAME=KBUILD_STR(sysctl)" -D"KBUILD_MODNAME=KBUILD_STR 
(ntfs)" fs/ntfs/sysctl.c
make[2]: *** [fs/ntfs/sysctl.o] Error 139
make[1]: *** [fs/ntfs] Error 2
make: *** [fs] Error 2

This is the code snippet should allow you to reproduce it:

#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/sysctl.h>

extern int debug_msgs;

/* Definition of the ntfs sysctl. */
static ctl_table ntfs_sysctls[] = {
         {
                 .ctl_name = CTL_UNNUMBRED,      /* No binary ID. */
                 .procname = "ntfs-debug",       /* Text ID. */
                 .data = &debug_msgs,            /* Data pointer and  
size. */
                 .maxlen = sizeof(debug_msgs),
                 .mode = 0644,                   /* Mode. */
                 .proc_handler = &proc_dointvec, /* Proc handler. */
         },
         {}
};

Fixing the typo allows it to complete:

   CHECK   fs/ntfs/sysctl.c
   CC [M]  fs/ntfs/sysctl.o

Best regards,

	Anton
-- 
Anton Altaparmakov <aia21 at cam.ac.uk> (replace at with @)
Unix Support, Computing Service, University of Cambridge, CB2 3QH, UK
Linux NTFS maintainer, http://www.linux-ntfs.org/


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse participating in Google Summer of Code 2007; apply by March ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Sparse participating in Google Summer of Code 2007; apply by March
Date: Tue, 20 Mar 2007 23:48:05 +0000
Message-ID: <460072B5.9060104 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigD4DDABB1E6D8CA751CDD9A37
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

[Sending this to LKML as well, to reach more of Sparse's user community.]=


Google has accepted Sparse as a mentoring organization for Summer of Code=

2007.  Interested students can propose work on Sparse-related projects, w=
ork
on those projects over the summer, and receive a stipend from Google for =
their
work.

Student application deadline: March 24th

Sparse, the semantic parser, provides a compiler frontend capable of pars=
ing
most of ANSI C as well as many GCC extensions, and a collection of sample=

compiler backends, including a static analyzer also called 'sparse'. Spar=
se
provides a set of annotations designed to convey semantic information abo=
ut
types, such as what address space pointers point to, or what locks a func=
tion
acquires or releases.  The Linux kernel community uses Sparse to check fo=
r
common errors in kernel source code.  Other projects, such as X.org, have=

begun to use Sparse as well.

Working on a Sparse project gives students the opportunity to put many co=
re CS
skills into practice on a real-world compiler and static analyzer, and ga=
in
some recognition within the prominent community of Free and Open Source
Software developers working on the Linux kernel.

You can see the current Summer of Code project list for Sparse at
<http://www.kernel.org/pub/software/devel/sparse/soc.html>, or propose an=
 idea
of your own.

Students need to apply by March 24th.  You can apply at
<http://code.google.com/soc>.

Any Sparse developers interested in mentoring projects over the summer (w=
hich
primarily consists of answering questions about Sparse, such as on the ma=
iling
list), please apply via the Google Summer of Code mentorship application =
at
http://code.google.com/soc/mentor.html , and check the "Sparse" box.  Ple=
ase
also mail me with details.

Any Linux developers interested in seeing Sparse do something that it can=
't
currently do, please propose possible Summer of Code projects as soon as =
you
can, and I'll add them to
http://www.kernel.org/pub/software/devel/sparse/soc.html .

- Josh Triplett


--------------enigD4DDABB1E6D8CA751CDD9A37
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGAHK1GJuZRtD+evsRAiOnAJ9LM0ykguk7Kl+jisIOfIFqoBgLgwCgjUAM
E+J84cpgjYtp51vT2/3p6/4=
=HjPE
-----END PGP SIGNATURE-----

--------------enigD4DDABB1E6D8CA751CDD9A37--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Test that causes sparse to hang ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Test that causes sparse to hang
Date: Wed, 16 May 2007 07:11:28 +0000
Message-ID: <464AAEA0.9020300 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig1DBED4F3C83FB6F70FB34BC8
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

While poking at the GCC testsuite, I found a source file that hangs Spars=
e.  I
cut it down to the following minimal test case:

#if L'\x1234' !=3D 0x1234
#endif
#if ''
#endif

Documenting this on-list in case someone wants to look at it before I can=
 get
to it later.

- Josh Triplett


--------------enig1DBED4F3C83FB6F70FB34BC8
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGSq6gGJuZRtD+evsRAugOAKCTDgj0xJKs0AzL2QWxApQ2/bKWPACfZULt
9ETaR898ry+vq8EZvBmkAAM=
=sM0x
-----END PGP SIGNATURE-----

--------------enig1DBED4F3C83FB6F70FB34BC8--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Test that causes sparse to hang
Date: Wed, 16 May 2007 07:17:16 +0000
Message-ID: <20070516071716.GJ4095 () ftp ! linux ! org ! uk>
--------------------
On Wed, May 16, 2007 at 12:11:28AM -0700, Josh Triplett wrote:
> While poking at the GCC testsuite, I found a source file that hangs Sparse.  I
> cut it down to the following minimal test case:
> 
> #if L'\x1234' != 0x1234
> #endif
> #if ''
> #endif
> 
> Documenting this on-list in case someone wants to look at it before I can get
> to it later.

No wide characters, so don't expect the identical behaviour...  Shouldn't
hang, obviously.  BTW, I wouldn't be too surprised if wide chars blow not
only in preprocessor.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Warnings while compiling sparse ===

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: Warnings while compiling sparse
Date: Mon, 30 Jul 2007 22:06:11 +0000
Message-ID: <46AE60D3.1050602 () redhat ! com>
--------------------
Josh Triplett wrote:
> On Mon, 2007-07-30 at 22:30 +0200, Michael Stefaniuc wrote:
>> Hell Josh,
> 
> Hello to you too. :)
Duh ... I'm really sorry about that.
/me blames it on the cut'n'paste from thunderbird to mutt

bye
	michael

>> commit 06bcf19cb8eb3cc3154ba6131477d742a9f0b4b6
>> Author: Josh Triplett <josh@freedesktop.org>
>> Date:   Sun Jul 29 20:20:38 2007 -0700
>>
>>     Makefile: Use -O2 -finline-functions, not just -O
>>
>>     introduces warnings while compiling sparse on my machine (FC6, x86,
>>     gcc version 4.1.2 20070626 (Red Hat 4.1.2-13)):
> 
> Yes, it does here too.  All of this comes from the ptrlist code, which
> does indeed break the C99 strict-aliasing rules in its pointer casts.
> Either we need -fno-strict-aliasing or we need to type-pun through a
> union; we most likely want the latter, though it'll uglify the ptrlist
> code.


-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
--------------------------------------------------------------------
Reg. Adresse: Red Hat GmbH, Hauptst√É¬§tter Strasse 58, 70178 Stuttgart
Handelsregister: Amtsgericht Stuttgart HRB 153243
Gesch√É¬§ftsf√É¬ºhrer: Brendan Lane, Charlie Peters, Michael Cunningham,
                 Werner Knoblich
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [ANNOUNCE] sparse-0.2-cl2 is now available ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sat, 10 Feb 2007 00:00:55 +0000
Message-ID: <20070210000055.GA19968 () chrisli ! org>
--------------------

Temporarily at:
    http://userweb.kernel.org/~chrisl/sparse-0.2-cl2

Will appear later at:
    http://ftp.kernel.org//pub/linux/kernel/people/chrisl/patches/sparse/sparse-0.2-cl2/


I have been play with sparse to add more Stanford checker style
of checking. The paper is "Checking System Rules Using System-
Specific, Programmer-Written Compiler Extensions" by Dawson Engler
etc.

Unlike the Stanford checker and smatch, this checker is working on
the linearization level instead of AST level. Linearization code
can be very convenient (when it works) to trace the data flow because
pseudo is in SSA form. There is define/user chain to avoid scan
every instruction.

I take the malloc checking for example to explain how the checker
works. The checking usually happen in three step:

The first step is scanning the linearize instruction. It look for
relevant operations. For malloc checker, the task is find out
the malloc/free function call and usage of malloced pointer.

The second step is converting the relevant operations into checker
instruction. The checker instruction is a simplification of the whole
program, only contain the operation relevant to checker.

The third step is executing the checker instruction. It try to execute
every possible execution flow in the function. The execution engine
will let the checker instruction perform state changes.

Thanks to step two, the size and complexity of the of program has been
greatly reduced.

The new checking has been very fast, it add a few seconds to the make C=1
run.

Again, comment and feed back are always welcome.

Chris

Change log in sparse-0.2-cl2:
 - adding pointer signedness fix
 - adding spinlock checking

Change log in sparse-0.2-cl1:
  The most interesting part is the inline function annotation.
  The new checker can find out inlined function usage. The interrupt
  checker does not depend on x86 asm instruction any more.


origin.patch
    006eff06c7adcfb0d06c6fadf6e9b64f0488b2bf URL: git://git.kernel.org/pub/scm/linux/kernel/git/josh/sparse.git
incompatible-ptr-signess
    Bug fix in pointer modifiers inherent at function degeneration.
sizeof-incomplete
    Fix double semicolon in struct declare
anon-symbol
    Fix core dump on anonymous symbol.
instruction-buffer-size
    Fix core dump on huge switch
debug-checker
    Adding debug option for showing the linearized instruction.
no-dead-instruction
    Disable liveness "dead" instruction by default.
ptr-allocator
    Make the ptrlist using the sparse allocator.
annotate-inline-2
    Add annotation for inline function call.
malloc-checker
    Adding the malloc NULL pointer checker.
interrupt-checker
    Adding the interrupt checker
spinlock-checker
    Adding spinlock checker


Total 12 patches


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-sparse
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sat, 10 Feb 2007 16:33:27 +0000
Message-ID: <p73hctthq8q.fsf () bingen ! suse ! de>
--------------------
Christopher Li <sparse@chrisli.org> writes:
> 
> Change log in sparse-0.2-cl2:
>  - adding pointer signedness fix
>  - adding spinlock checking


Interesting. Did you find any kernel bugs with this?

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-kernel
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sat, 10 Feb 2007 16:35:06 +0000
Message-ID: <p73hctthq8q.fsf () bingen ! suse ! de>
--------------------
Christopher Li <sparse@chrisli.org> writes:
> 
> Change log in sparse-0.2-cl2:
>  - adding pointer signedness fix
>  - adding spinlock checking


Interesting. Did you find any kernel bugs with this?

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sun, 11 Feb 2007 05:17:58 +0000
Message-ID: <20070211051758.GA2113 () chrisli ! org>
--------------------
On Sat, Feb 10, 2007 at 06:33:25PM +0100, Andi Kleen wrote:
> Interesting. Did you find any kernel bugs with this?

In short, not very useful yet.

The current run of of sparse-0.2-cl2 on git default i386 config
will find about 6 place kernel using allocated memory without NULL
check. But Linus said most of them is not worthy checking because
it is in the early stage of the kernel initializations.
It just can't fail on those small memory allocation. May be one
of them worth adding the NULL check.

For interrupt and spinlock checking, it less noisier than the current
sparse context level checking. The new checker code can identify inline
function call, so it has more information. But it is still too noisy.
I did not look at every interrupt and spinlock warning. From what I saw,
it show limit of the checker itself rather than a bug in kernel.

A lot of false positive is come from we don't have enough information
inside a single function.

e.g. sparse has not way to know some function only get called with interrupt
disabled (or some lock already hold). So it assume interrupt is still
enable and generate wrong warnings. Another example is that some helper
function will wrap the locking function. Complain about the exit with locking
hold is wrong.

I am hoping adding the cross function checking will reduce those false positive.
Any way, it need more information to reduce false positive.

I am still working on the cross function checking. May be it will become
more useful one day.

Chris


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sun, 11 Feb 2007 05:17:58 +0000
Message-ID: <20070211051758.GA2113 () chrisli ! org>
--------------------
On Sat, Feb 10, 2007 at 06:33:25PM +0100, Andi Kleen wrote:
> Interesting. Did you find any kernel bugs with this?

In short, not very useful yet.

The current run of of sparse-0.2-cl2 on git default i386 config
will find about 6 place kernel using allocated memory without NULL
check. But Linus said most of them is not worthy checking because
it is in the early stage of the kernel initializations.
It just can't fail on those small memory allocation. May be one
of them worth adding the NULL check.

For interrupt and spinlock checking, it less noisier than the current
sparse context level checking. The new checker code can identify inline
function call, so it has more information. But it is still too noisy.
I did not look at every interrupt and spinlock warning. From what I saw,
it show limit of the checker itself rather than a bug in kernel.

A lot of false positive is come from we don't have enough information
inside a single function.

e.g. sparse has not way to know some function only get called with interrupt
disabled (or some lock already hold). So it assume interrupt is still
enable and generate wrong warnings. Another example is that some helper
function will wrap the locking function. Complain about the exit with locking
hold is wrong.

I am hoping adding the cross function checking will reduce those false positive.
Any way, it need more information to reduce false positive.

I am still working on the cross function checking. May be it will become
more useful one day.

Chris


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-kernel
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sun, 11 Feb 2007 05:50:15 +0000
Message-ID: <20070211055015.GR10050 () ftp ! linux ! org ! uk>
--------------------
On Sat, Feb 10, 2007 at 09:17:58PM -0800, Christopher Li wrote:
> e.g. sparse has not way to know some function only get called with interrupt
> disabled (or some lock already hold). So it assume interrupt is still
> enable and generate wrong warnings. Another example is that some helper
> function will wrap the locking function. Complain about the exit with locking
> hold is wrong.
> 
> I am hoping adding the cross function checking will reduce those false positive.
> Any way, it need more information to reduce false positive.
> 
> I am still working on the cross function checking. May be it will become
> more useful one day.

I have some stuff in that direction, but it take some resurrecting...
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sun, 11 Feb 2007 06:02:55 +0000
Message-ID: <20070211060255.GA2312 () chrisli ! org>
--------------------
On Sun, Feb 11, 2007 at 05:50:15AM +0000, Al Viro wrote:
> 
> I have some stuff in that direction, but it take some resurrecting...

OK, we should talk.

Here is what I have:

Linearize bytecode writer, which produce the binary linearized code.
The uncompress size is about 10 times the i386 .o file. I don't have
the loader ready to verify it yet. It is aim at fast loading bytecode
and simple, I havn't done much toward optimized the code size.

If we keep it 10 times over head, my home computer can load the full linux
kernel and have some spare for checking.

I am still working on the bytecode loader and linker for merging symbols.
It need to answer the question:

Which file define which function.
Which external symbol does this function use.

Once we get the function user/define chain, it can enable a lot of new checking.

The current linearized code is not very friendly to linking because we
keep abstract declare and real declare as different node. Depend on the
position, the caller will get different node even in one file.
 
I am going to take out the LKML on later email because discussion is
more sparse specific now.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sun, 11 Feb 2007 06:02:55 +0000
Message-ID: <20070211060255.GA2312 () chrisli ! org>
--------------------
On Sun, Feb 11, 2007 at 05:50:15AM +0000, Al Viro wrote:
> 
> I have some stuff in that direction, but it take some resurrecting...

OK, we should talk.

Here is what I have:

Linearize bytecode writer, which produce the binary linearized code.
The uncompress size is about 10 times the i386 .o file. I don't have
the loader ready to verify it yet. It is aim at fast loading bytecode
and simple, I havn't done much toward optimized the code size.

If we keep it 10 times over head, my home computer can load the full linux
kernel and have some spare for checking.

I am still working on the bytecode loader and linker for merging symbols.
It need to answer the question:

Which file define which function.
Which external symbol does this function use.

Once we get the function user/define chain, it can enable a lot of new checking.

The current linearized code is not very friendly to linking because we
keep abstract declare and real declare as different node. Depend on the
position, the caller will get different node even in one file.
 
I am going to take out the LKML on later email because discussion is
more sparse specific now.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-sparse
Subject: Re: [ANNOUNCE] sparse-0.2-cl2 is now available
Date: Sun, 11 Feb 2007 10:41:54 +0000
Message-ID: <200702111141.54900.ak () suse ! de>
--------------------

> 
> If we keep it 10 times over head, my home computer can load the full linux
> kernel and have some spare for checking.
> 
> I am still working on the bytecode loader and linker for merging symbols.
> It need to answer the question:
> 
> Which file define which function.
> Which external symbol does this function use.
> 
> Once we get the function user/define chain, it can enable a lot of new checking.

At least for interrupts on/off you'll likely need new annotations because
this state can be changed in assembly files before/after calling out to 
C.

For locks this fortunately cannot happen (at least not on x86*) 

-Andi

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] Improved flow graphs ===

From: Dan Sheridan <djs () postman ! org ! uk>
To: linux-sparse
Subject: [PATCH 0/2] Improved flow graphs
Date: Wed, 16 May 2007 10:11:21 +0000
Message-ID: <1179310281.31308.54.camel () localhost ! localdomain>
--------------------
Dear all,

It doesn't look like this 0/2 made it the first time round...

These two patches are the first of several implementing improved graph
generation for Sparse. Initially, I am dealing with straight-forward
control flow. Forthcoming patches will add program dependency graphs (a
control and data flow representation suitable for program slicing) and
simple pointer alias analysis (for handling indirect calls).

I've tried to keep the C part of the flow graph relatively simple, and
put the hard stuff (like return edges and subgraph processing) in
post-processing scripts. 

Example graph can be seen at
http://www.postman.org.uk/djs52/example.png, generated with

  ./graph validation/context.c | gvpr -f gvpr/return-paths | \
    gvpr -f gvpr/subg-fwd -a good_while3 | dot -Tpng > /tmp/example.png

Comments welcome.

	Dan Sheridan.

-- 
Daniel Sheridan (djs@adelard.com), Consultant
Adelard LLP, College Building, Northampton Square, London  EC1V 0HB, UK
Tel: +44 (0)20 7490 9455, Fax: +44 (0)20 7490 9451, 
Web: http://www.adelard.com

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Anderson Lizardo" <anderson.lizardo () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] Improved flow graphs
Date: Wed, 16 May 2007 18:03:36 +0000
Message-ID: <5b5833aa0705161103w5748cc84l7c733e010307259d () mail ! gmail ! com>
--------------------
On 5/16/07, Dan Sheridan <djs@postman.org.uk> wrote:
> Example graph can be seen at
> http://www.postman.org.uk/djs52/example.png, generated with
>
>   ./graph validation/context.c | gvpr -f gvpr/return-paths | \
>     gvpr -f gvpr/subg-fwd -a good_while3 | dot -Tpng > /tmp/example.png

Hi,

I have a question regarding this specific example:

If I understand the code correctly, the node name is the stream line
number of the first instruction of the BB right? Is that why the call
edge for r() comes from 169/173 (and not from 170/174, as I would
expect)?

Nice work BTW.

Regards,
-- 
Anderson Lizardo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] Improved flow graphs
Date: Tue, 22 May 2007 22:11:50 +0000
Message-ID: <46536AA6.20604 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig16A6B52E7B2B3821DD060D7A
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Dan Sheridan wrote:
> These two patches are the first of several implementing improved graph
> generation for Sparse.

Very nice work.  I've applied both patches in this series.

I also added shebangs to the gvpr scripts and made them executable, so yo=
u
can just run graph ... | gvpr/return-paths | dot ...

I noticed one minor issue: gvpr/return-paths seems to turn some internal
edges in functions into dotted-line return paths.

Also, unprocessed graphs have now become far more messy; for instance,
graphing validation/context.c generates numerous edges to a() and r().  A=
ny
way you could prevent these edges from crossing other subgraphs?  Any way=
 to
make these edges just point to a separate node "a()" and let people look =
up
a() themselves, removing the excess edges?  Perhaps with a gvpr script?

> Initially, I am dealing with straight-forward
> control flow. Forthcoming patches will add program dependency graphs (a=

> control and data flow representation suitable for program slicing) and
> simple pointer alias analysis (for handling indirect calls).

I look forward to seeing these future enhancements.  Pointer alias analys=
is
would help greatly with many other things in Sparse.

> I've tried to keep the C part of the flow graph relatively simple, and
> put the hard stuff (like return edges and subgraph processing) in
> post-processing scripts.=20
>=20
> Example graph can be seen at
> http://www.postman.org.uk/djs52/example.png, generated with
>=20
>   ./graph validation/context.c | gvpr -f gvpr/return-paths | \
>     gvpr -f gvpr/subg-fwd -a good_while3 | dot -Tpng > /tmp/example.png=


Impressive work.

- Josh Triplett


--------------enig16A6B52E7B2B3821DD060D7A
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU2qmGJuZRtD+evsRAh/HAJ9HrNRpSYtOt0hSBuN/RSUoPu12NACglDW3
KRGCRa8hTXz3k35LxgustaA=
=1NvT
-----END PGP SIGNATURE-----

--------------enig16A6B52E7B2B3821DD060D7A--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Sheridan <djs () postman ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 0/2] Improved flow graphs
Date: Tue, 29 May 2007 16:05:10 +0000
Message-ID: <1180454712.5068.49.camel () localhost ! localdomain>
--------------------
On Tue, 2007-05-22 at 15:11 -0700, Josh Triplett wrote:
> Dan Sheridan wrote:
> > These two patches are the first of several implementing improved graph
> > generation for Sparse.
> 
> Very nice work.  I've applied both patches in this series.

Thanks.

> I noticed one minor issue: gvpr/return-paths seems to turn some internal
> edges in functions into dotted-line return paths.

I think you are talking about the edges which connect call sites to
return sites. These are needed to keep the layout of the graph sane, but
could be made invisible. It would at least help if they looked different
to the return edges.

> Also, unprocessed graphs have now become far more messy; for instance,
> graphing validation/context.c generates numerous edges to a() and r().  Any
> way you could prevent these edges from crossing other subgraphs? 

Probably not. There's a lot of tweaking possible with weights, which
I'll experiment with a bit, but your suggestion of separate a() and r()
nodes might be simpler. Should be very easy to obtain with a gvpr
script.

	Dan.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/5] Sparse on Cygwin (and git). ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: [PATCH 0/5] Sparse on Cygwin (and git).
Date: Tue, 22 May 2007 17:56:29 +0000
Message-ID: <46532ECD.2020502 () ramsay1 ! demon ! co ! uk>
--------------------
This is a multi-part message in MIME format.
--------------090005050409000709090104
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

Hi Josh,

Since git uses sparse in it's "check" make target, I decided to download the
(then current) 0.2 tar-ball and see what sparse was about. Unfortunately, at present,
I am using cygwin on win32 until I get around to installing Linux. ;-)
Hence, the following patch series...

0001-Add-support-for-WIN32-attribute-names.patch
0002-Fix-an-__attribute__-parsing-error.patch
0003-Add-cygwin-support-to-cgcc.patch
0004-Fix-a-Wtypesign-bug.patch

Well, when the 0.3 tar-ball was released, I had to update the patch series.
Changes to the attribute parsing code meant an update to patch 0001 was
required. Patch 0004 now seems to be unnecessary (probably due to commit
ef2596162115bfdc2a1d3639ac99dd3ba2a71af2). Also compilation errors lead to
the introduction of two new patches (1&2/5), as follows ...

0001-Fix-an-attribute-__sentinel__-unknown-warning.patch
0002-Fix-some-enum-value-XXX-not-handled-in-switch-wa.patch
0003-Add-support-for-WIN32-attribute-names.patch
0004-Fix-an-__attribute__-parsing-error.patch
0005-Add-cygwin-support-to-cgcc.patch

As I am somewhat bandwidth challenged, until recently, I had never cloned a
git repository (not even the git repo). So, last week I cloned the sparse
repository; thankfully it only took about ten minutes (yep a slow pipe!).
Thus, again I had to update the patch series. Patch 0003 overlapped a
recent commit (baf2c5a8) by Michael Stefaniuc and patch 0004 required an
update due to handle_attributes() gaining a third parameter. So the final
patch series is:

0001-Fix-an-__sentinel__-attribute-directive-ignored.patch
0002-Fix-some-enum-value-XXX-not-handled-in-switch-wa.patch
0003-Add-more-support-for-WIN32-attribute-names.patch
0004-Fix-an-__attribute__-parsing-error.patch
0005-Add-cygwin-support-to-cgcc.patch

which was built on top of: 0.3-15-gb5bd30f

I have attached "0004-Fix-a-Wtypesign-bug.patch" simply out of interest, as
it does not require the parameter type of "function returning..." to decay to
"pointer to function returning...".  The test case comes from git:

$cat tsb.c

typedef int erf(const char *r, const unsigned char *s, int f, void *c);

extern int fer(erf, void *);

static int ar(const char *r, const unsigned char *s, int f, void *c)
{
	return 0;
}

int main (int argc, char *argv[])
{
	fer(ar, (void *)0);
}

$

Hope you find this useful.

All the best,

Ramsay Jones


--------------090005050409000709090104
Content-Type: application/xxxxx;
 name="0004-Fix-a-Wtypesign-bug.patch"
Content-Transfer-Encoding: base64
Content-Disposition: inline;
 filename="0004-Fix-a-Wtypesign-bug.patch"

RnJvbSA5OWIzYTE4ZjgyY2RlYjIyMWFlMGI4MTdlMGM1ZDcxYmEzMWZkMjczIE1vbiBTZXAg
MTcgMDA6MDA6MDAgMjAwMQpGcm9tOiBSYW1zYXkgSm9uZXMgPHJhbXNheUByYW1zYXkxLmRl
bW9uLmNvLnVrPgpEYXRlOiBNb24sIDIxIE1heSAyMDA3IDE1OjQ4OjUyICswMTAwClN1Ympl
Y3Q6IFtQQVRDSF0gRml4IGEgLVd0eXBlc2lnbiBidWcuCgoKU2lnbmVkLW9mZi1ieTogUmFt
c2F5IEpvbmVzIDxyYW1zYXlAcmFtc2F5MS5kZW1vbi5jby51az4KLS0tCiBldmFsdWF0ZS5j
IHwgICAgNiArKysrLS0KIDEgZmlsZXMgY2hhbmdlZCwgNCBpbnNlcnRpb25zKCspLCAyIGRl
bGV0aW9ucygtKQoKZGlmZiAtLWdpdCBhL2V2YWx1YXRlLmMgYi9ldmFsdWF0ZS5jCmluZGV4
IGNhNDllZDAuLjUzMDg4MjcgMTAwNjQ0Ci0tLSBhL2V2YWx1YXRlLmMKKysrIGIvZXZhbHVh
dGUuYwpAQCAtNjY5LDcgKzY2OSw3IEBAIGNvbnN0IGNoYXIgKiB0eXBlX2RpZmZlcmVuY2Uo
c3RydWN0IHN5bWJvbCAqdGFyZ2V0LCBzdHJ1Y3Qgc3ltYm9sICpzb3VyY2UsCiAJCQl0YXJn
ZXQgPSB0YXJnZXQtPmN0eXBlLmJhc2VfdHlwZTsKIAkJCWlmICghdGFyZ2V0KQogCQkJCXJl
dHVybiAiYmFkIHR5cGVzIjsKLQkJCWlmICh0YXJnZXQtPnR5cGUgPT0gU1lNX1BUUikgewor
CQkJaWYgKHRhcmdldC0+dHlwZSA9PSBTWU1fUFRSIHx8IHRhcmdldC0+dHlwZSA9PSBTWU1f
Rk4pIHsKIAkJCQltb2QxID0gMDsKIAkJCQlhczEgPSAwOwogCQkJfQkKQEAgLTY4MCw3ICs2
ODAsNyBAQCBjb25zdCBjaGFyICogdHlwZV9kaWZmZXJlbmNlKHN0cnVjdCBzeW1ib2wgKnRh
cmdldCwgc3RydWN0IHN5bWJvbCAqc291cmNlLAogCQkJc291cmNlID0gc291cmNlLT5jdHlw
ZS5iYXNlX3R5cGU7CiAJCQlpZiAoIXNvdXJjZSkKIAkJCQlyZXR1cm4gImJhZCB0eXBlcyI7
Ci0JCQlpZiAoc291cmNlLT50eXBlID09IFNZTV9QVFIpIHsKKwkJCWlmIChzb3VyY2UtPnR5
cGUgPT0gU1lNX1BUUiB8fCBzb3VyY2UtPnR5cGUgPT0gU1lNX0ZOKSB7CiAJCQkJbW9kMiA9
IDA7CiAJCQkJYXMyID0gMDsKIAkJCX0KQEAgLTcxOCw2ICs3MTgsNyBAQCBjb25zdCBjaGFy
ICogdHlwZV9kaWZmZXJlbmNlKHN0cnVjdCBzeW1ib2wgKnRhcmdldCwgc3RydWN0IHN5bWJv
bCAqc291cmNlLAogCQkJY2FzZSBTWU1fRk46CiAJCQkJdHlwZTEgPSBTWU1fRk47CiAJCQkJ
dGFyZ2V0ID0gYmFzZTE7CisJCQkJbW9kMSA9IHRhcmdldC0+Y3R5cGUubW9kaWZpZXJzOwog
CQkJCWJhc2UxID0gYmFzZTEtPmN0eXBlLmJhc2VfdHlwZTsKIAkJCWRlZmF1bHQ6CiAJCQkJ
Lyogbm90aGluZyAqLzsKQEAgLTcyOSw2ICs3MzAsNyBAQCBjb25zdCBjaGFyICogdHlwZV9k
aWZmZXJlbmNlKHN0cnVjdCBzeW1ib2wgKnRhcmdldCwgc3RydWN0IHN5bWJvbCAqc291cmNl
LAogCQkJY2FzZSBTWU1fRk46CiAJCQkJdHlwZTIgPSBTWU1fRk47CiAJCQkJc291cmNlID0g
YmFzZTI7CisJCQkJbW9kMiA9IHNvdXJjZS0+Y3R5cGUubW9kaWZpZXJzOwogCQkJCWJhc2Uy
ID0gYmFzZTItPmN0eXBlLmJhc2VfdHlwZTsKIAkJCWRlZmF1bHQ6CiAJCQkJLyogbm90aGlu
ZyAqLzsKLS0gCjEuNS4xCgo=
--------------090005050409000709090104
Content-Type: text/plain;
 name="tsb.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="tsb.c"


typedef int erf(const char *r, const unsigned char *s, int f, void *c);

extern int fer(erf, void *);

static int ar(const char *r, const unsigned char *s, int f, void *c)
{
	return 0;
}

int main (int argc, char *argv[])
{
	fer(ar, (void *)0);
}


--------------090005050409000709090104--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 0/5] Sparse on Cygwin (and git).
Date: Tue, 22 May 2007 23:44:43 +0000
Message-ID: <4653806B.1000901 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig8F6971FE1A14A5E57941EF6E
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Ramsay Jones wrote:
> Since git uses sparse in it's "check" make target,

Cool; I didn't know that. :)

> I decided to download the
> (then current) 0.2 tar-ball and see what sparse was about.

Great!

> Unfortunately, at present,
> I am using cygwin on win32 until I get around to installing Linux. ;-)

Fortunately, that resulted in some excellent patches. :)

[...]
> As I am somewhat bandwidth challenged, until recently, I had never clon=
ed a
> git repository (not even the git repo). So, last week I cloned the spar=
se
> repository; thankfully it only took about ten minutes (yep a slow pipe!=
).

I think you'll find that keeping the git repo up-to-date requires quite a=
 bit
less bandwidth than the initial checkout.

> Thus, again I had to update the patch series.

In general, you'll probably run into conflicts if you try to generate pat=
ches
from the last release tarball, especially on frequently changed files lik=
e
ident-list.h and the attribute table.

> Patch 0003 overlapped a
> recent commit (baf2c5a8) by Michael Stefaniuc and patch 0004 required a=
n
> update due to handle_attributes() gaining a third parameter. So the fin=
al
> patch series is:
>=20
> 0001-Fix-an-__sentinel__-attribute-directive-ignored.patch
> 0002-Fix-some-enum-value-XXX-not-handled-in-switch-wa.patch
> 0003-Add-more-support-for-WIN32-attribute-names.patch
> 0004-Fix-an-__attribute__-parsing-error.patch
> 0005-Add-cygwin-support-to-cgcc.patch
>=20
> which was built on top of: 0.3-15-gb5bd30f

Looks like a good set of patches.  However, only patches 3 and 4 seem to =
have
hit the list.

- Josh Triplett



--------------enig8F6971FE1A14A5E57941EF6E
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU4BrGJuZRtD+evsRArnHAJ959Eb1+3211w1xuI2ilQzXONXONQCfTNVj
pTjAFJGCnwvcAmJFUrhkl2w=
=K3gl
-----END PGP SIGNATURE-----

--------------enig8F6971FE1A14A5E57941EF6E--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 0/5] Sparse on Cygwin (and git).
Date: Thu, 24 May 2007 17:11:06 +0000
Message-ID: <4655C72A.3010106 () ramsay1 ! demon ! co ! uk>
--------------------
Josh Triplett wrote:
> Ramsay Jones wrote:
>> Since git uses sparse in it's "check" make target,
> 
> Cool; I didn't know that. :)
heh, I don't know how often git developers "make check" ;-)

[...]
>> Unfortunately, at present,
>> I am using cygwin on win32 until I get around to installing Linux. ;-)
> 
> Fortunately, that resulted in some excellent patches. :)
> 
Apart from the whitespace breakage!

> [...]
>> 0001-Fix-an-__sentinel__-attribute-directive-ignored.patch
>> 0002-Fix-some-enum-value-...-not-handled-in-switch-wa.patch
>> 0003-Add-more-support-for-WIN32-attribute-names.patch
>> 0004-Fix-an-__attribute__-parsing-error.patch
>> 0005-Add-cygwin-support-to-cgcc.patch
>>
>> which was built on top of: 0.3-15-gb5bd30f
> 
> Looks like a good set of patches.  However, only patches 3 and 4 seem to have
> hit the list.
> 
Patch 2 was bounced by the vger spam blocker (because of the 3 uppercase x chars).

ATB,

Ramsay Jones


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/5] keyword driven parsing ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 0/5] keyword driven parsing
Date: Wed, 07 Mar 2007 10:01:09 +0000
Message-ID: <20070307100109.GA10577 () chrisli ! org>
--------------------
Here is an attempt to use keyword driven parsing.

The effect is that, we don't need to keep on adding keyword to
ident-list any more.

It might be marginally faster because it does not do a series
of testing for ident any more. I can't really tell because
sparse is already fast.

It almost remove the usage match_idents(). The only place
for using it now is parse_asm().

BTW, why asm is a statement not an expression? If it is an
expression, it seems make sense to merge the volatile to the
ctype modifiers.

Feel back is welcome.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 0/5] keyword driven parsing
Date: Wed, 07 Mar 2007 15:45:35 +0000
Message-ID: <Pine.LNX.4.64.0703070742290.5963 () woody ! linux-foundation ! org>
--------------------


On Wed, 7 Mar 2007, Christopher Li wrote:
>
> Here is an attempt to use keyword driven parsing.

Ack, looks good to me.

> BTW, why asm is a statement not an expression? If it is an
> expression, it seems make sense to merge the volatile to the
> ctype modifiers.

I personally certainly wouldn't mind at all making asm's expressions 
instead. In fact, I think it would potentially be a good idea to make 
*everything* an expression, ie a C statement would be just an expression 
that returns "void".

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 0/5] keyword driven parsing
Date: Thu, 08 Mar 2007 06:55:07 +0000
Message-ID: <45EFB34B.6030101 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig252D306692A8E1D2C2964973
Content-Type: multipart/mixed;
 boundary="------------070109080502000806030206"

This is a multi-part message in MIME format.
--------------070109080502000806030206
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> Here is an attempt to use keyword driven parsing.
>=20
> The effect is that, we don't need to keep on adding keyword to
> ident-list any more.

Beautiful!  Looks far more elegant and maintainable; thanks.

I've applied the first four patches in this series.  The fifth causes a
regression in validation/context.c; see the attached diff of the output f=
rom
the fourth to the fifth patches.

- Josh Triplett


--------------070109080502000806030206
Content-Type: text/plain;
 name="sparse-validation-output.diff"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline;
 filename="sparse-validation-output.diff"

--- sparse-validation-output-4	2007-03-07 22:06:53.000000000 -0800
+++ sparse-validation-output-5	2007-03-07 22:06:29.000000000 -0800
@@ -49,20 +49,40 @@
 validation/choose_expr.c:4:17: warning: division by zero
 validation/cond_expr.c:10:9: error: incompatible types for operation (~)=

 validation/cond_expr.c:10:9:    argument has type double=20
-validation/context.c:69:13: warning: context imbalance in 'warn_lock1' -=
 wrong count at exit
-validation/context.c:74:13: warning: context imbalance in 'warn_lock2' -=
 wrong count at exit
-validation/context.c:81:13: warning: context imbalance in 'warn_lock3' -=
 wrong count at exit
-validation/context.c:88:13: warning: context imbalance in 'warn_unlock1'=
 - unexpected unlock
+validation/context.c:3:13: warning: context imbalance in 'a' - wrong cou=
nt at exit
+validation/context.c:8:13: warning: context imbalance in 'r' - unexpecte=
d unlock
+validation/context.c:16:13: warning: context imbalance in 'good_paired1'=
 - unexpected unlock
+validation/context.c:22:13: warning: context imbalance in 'good_paired2'=
 - unexpected unlock
+validation/context.c:30:13: warning: context imbalance in 'good_paired3'=
 - unexpected unlock
+validation/context.c:43:13: warning: context imbalance in 'good_lock2' -=
 unexpected unlock
+validation/context.c:50:13: warning: context imbalance in 'good_lock3' -=
 unexpected unlock
+validation/context.c:62:13: warning: context imbalance in 'good_unlock2'=
 - unexpected unlock
+validation/context.c:69:13: warning: context imbalance in 'warn_lock1' -=
 unexpected unlock
+validation/context.c:74:13: warning: context imbalance in 'warn_lock2' -=
 unexpected unlock
+validation/context.c:81:13: warning: context imbalance in 'warn_lock3' -=
 unexpected unlock
 validation/context.c:93:13: warning: context imbalance in 'warn_unlock2'=
 - unexpected unlock
-validation/context.c:131:12: warning: context imbalance in 'warn_if1' - =
wrong count at exit
-validation/context.c:140:12: warning: context imbalance in 'warn_if2' - =
different lock contexts for basic block
-validation/context.c:202:2: warning: context imbalance in 'warn_while1' =
- different lock contexts for basic block
-validation/context.c:210:3: warning: context imbalance in 'warn_while2' =
- unexpected unlock
-validation/context.c:216:2: warning: context imbalance in 'warn_while3' =
- wrong count at exit
-validation/context.c:274:13: warning: context imbalance in 'warn_goto1' =
- wrong count at exit
-validation/context.c:283:13: warning: context imbalance in 'warn_goto2' =
- wrong count at exit
-validation/context.c:300:5: warning: context imbalance in 'warn_goto3' -=
 different lock contexts for basic block
-validation/context.c:315:5: warning: context imbalance in 'warn_cond_loc=
k1' - different lock contexts for basic block
+validation/context.c:102:12: warning: context imbalance in 'good_if1' - =
unexpected unlock
+validation/context.c:116:3: warning: context imbalance in 'good_if2' - u=
nexpected unlock
+validation/context.c:121:13: warning: context imbalance in 'good_if3' - =
unexpected unlock
+validation/context.c:131:12: warning: context imbalance in 'warn_if1' - =
unexpected unlock
+validation/context.c:140:12: warning: context imbalance in 'warn_if2' - =
unexpected unlock
+validation/context.c:150:13: warning: context imbalance in 'good_while1'=
 - unexpected unlock
+validation/context.c:161:3: warning: context imbalance in 'good_while2' =
- unexpected unlock
+validation/context.c:169:3: warning: context imbalance in 'good_while3' =
- unexpected unlock
+validation/context.c:178:13: warning: context imbalance in 'good_while4'=
 - unexpected unlock
+validation/context.c:189:13: warning: context imbalance in 'good_while5'=
 - unexpected unlock
+validation/context.c:203:3: warning: context imbalance in 'warn_while1' =
- unexpected unlock
+validation/context.c:217:3: warning: context imbalance in 'warn_while3' =
- unexpected unlock
+validation/context.c:224:13: warning: context imbalance in 'good_goto1' =
- unexpected unlock
+validation/context.c:232:13: warning: context imbalance in 'good_goto2' =
- unexpected unlock
+validation/context.c:242:13: warning: context imbalance in 'good_goto3' =
- unexpected unlock
+validation/context.c:257:5: warning: context imbalance in 'good_goto4' -=
 unexpected unlock
+validation/context.c:263:13: warning: context imbalance in 'good_goto5' =
- unexpected unlock
+validation/context.c:274:13: warning: context imbalance in 'warn_goto1' =
- unexpected unlock
+validation/context.c:283:13: warning: context imbalance in 'warn_goto2' =
- unexpected unlock
+validation/context.c:293:13: warning: context imbalance in 'warn_goto3' =
- unexpected unlock
+validation/context.c:305:5: warning: context imbalance in 'good_cond_loc=
k1' - wrong count at exit
+validation/context.c:315:5: warning: context imbalance in 'warn_cond_loc=
k1' - wrong count at exit
 /usr/include/features.h:265:5: warning: undefined preprocessor identifie=
r '_FORTIFY_SOURCE'
 /usr/include/string.h:420:6: warning: undefined preprocessor identifier =
'__USE_FORTIFY_LEVEL'
 validation/foul-bitwise.c:9:9: warning: restricted degrades to integer

--------------070109080502000806030206--

--------------enig252D306692A8E1D2C2964973
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF77NLGJuZRtD+evsRAiseAKCiz9RLScu1A6V0fTZPcwjkoHo6HwCfVrT0
MZ6WLx6JbZ0xSZwRQ8YJPwU=
=ZRTA
-----END PGP SIGNATURE-----

--------------enig252D306692A8E1D2C2964973--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/4] add end position to symbols ===

From: Rob Taylor <rob.taylor@codethink.co.uk>
To: Unknown
Subject: [PATCH 1/4] add end position to symbols
Date: Fri, 29 Jun 2007 17:25:51 +0100
Message-ID: 
--------------------
This adds a field in the symbol struct for the position of the end of the
symbol and code to parse.c to fill this in for the various symbol types when
parsing.

Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
---
 parse.c  |   21 ++++++++++++++++++++-
 symbol.c |    1 +
 symbol.h |    1 +
 3 files changed, 22 insertions(+), 1 deletions(-)

diff --git a/parse.c b/parse.c
index cb9f87a..ae14642 100644
--- a/parse.c
+++ b/parse.c
@@ -505,6 +505,7 @@ static struct token *struct_union_enum_specifier(enum type type,
 
 			// Mark the structure as needing re-examination
 			sym->examined = 0;
+			sym->endpos = token->pos;
 		}
 		return token;
 	}
@@ -519,7 +520,10 @@ static struct token *struct_union_enum_specifier(enum type type,
 	sym = alloc_symbol(token->pos, type);
 	token = parse(token->next, sym);
 	ctype->base_type = sym;
-	return expect(token, '}', "at end of specifier");
+	token =  expect(token, '}', "at end of specifier");
+	sym->endpos = token->pos;
+
+	return token;
 }
 
 static struct token *parse_struct_declaration(struct token *token, struct symbol *sym)
@@ -712,6 +716,9 @@ static struct token *parse_enum_declaration(struct token *token, struct symbol *
 			lower_boundary(&lower, &v);
 		}
 		token = next;
+
+		sym->endpos = token->pos;
+
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -775,6 +782,7 @@ static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
 		token = parse_expression(token->next, &typeof_sym->initializer);
 
 		ctype->modifiers = 0;
+		typeof_sym->endpos = token->pos;
 		ctype->base_type = typeof_sym;
 	}		
 	return expect(token, ')', "after typeof");
@@ -1193,12 +1201,14 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
 			sym = alloc_indirect_symbol(token->pos, ctype, SYM_FN);
 			token = parameter_type_list(next, sym, p);
 			token = expect(token, ')', "in function declarator");
+			sym->endpos = token->pos;
 			continue;
 		}
 		if (token->special == '[') {
 			struct symbol *array = alloc_indirect_symbol(token->pos, ctype, SYM_ARRAY);
 			token = abstract_array_declarator(token->next, array);
 			token = expect(token, ']', "in abstract_array_declarator");
+			array->endpos = token->pos;
 			ctype = &array->ctype;
 			continue;
 		}
@@ -1232,6 +1242,7 @@ static struct token *pointer(struct token *token, struct ctype *ctype)
 
 		token = declaration_specifiers(token->next, ctype, 1);
 		modifiers = ctype->modifiers;
+		ctype->base_type->endpos = token->pos;
 	}
 	return token;
 }
@@ -1286,6 +1297,7 @@ static struct token *handle_bitfield(struct token *token, struct symbol *decl)
 		}
 	}
 	bitfield->bit_size = width;
+	bitfield->endpos = token->pos;
 	return token;
 }
 
@@ -1306,6 +1318,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 		}
 		apply_modifiers(token->pos, &decl->ctype);
 		add_symbol(list, decl);
+		decl->endpos = token->pos;
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -1340,6 +1353,7 @@ static struct token *parameter_declaration(struct token *token, struct symbol **
 	token = declarator(token, sym, &ident);
 	sym->ident = ident;
 	apply_modifiers(token->pos, &sym->ctype);
+	sym->endpos = token->pos;
 	return token;
 }
 
@@ -1350,6 +1364,7 @@ struct token *typename(struct token *token, struct symbol **p)
 	token = declaration_specifiers(token, &sym->ctype, 0);
 	token = declarator(token, sym, NULL);
 	apply_modifiers(token->pos, &sym->ctype);
+	sym->endpos = token->pos;
 	return token;
 }
 
@@ -1818,6 +1833,7 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn,
 			warning(token->pos, "void parameter");
 		}
 		add_symbol(list, sym);
+		sym->endpos = token->pos;
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -2104,6 +2120,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	token = declarator(token, decl, &ident);
 	apply_modifiers(token->pos, &decl->ctype);
 
+	decl->endpos = token->pos;
+
 	/* Just a type declaration? */
 	if (!ident)
 		return expect(token, ';', "end of type declaration");
@@ -2164,6 +2182,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, decl, &ident);
 		apply_modifiers(token->pos, &decl->ctype);
+		decl->endpos = token->pos;
 		if (!ident) {
 			sparse_error(token->pos, "expected identifier name in type definition");
 			return token;
diff --git a/symbol.c b/symbol.c
index 329fed9..7585978 100644
--- a/symbol.c
+++ b/symbol.c
@@ -62,6 +62,7 @@ struct symbol *alloc_symbol(struct position pos, int type)
 	struct symbol *sym = __alloc_symbol(0);
 	sym->type = type;
 	sym->pos = pos;
+	sym->endpos.type = 0;
 	return sym;
 }
 
diff --git a/symbol.h b/symbol.h
index 2bde84d..be5e6b1 100644
--- a/symbol.h
+++ b/symbol.h
@@ -111,6 +111,7 @@ struct symbol {
 	enum namespace namespace:9;
 	unsigned char used:1, attr:2, enum_member:1;
 	struct position pos;		/* Where this symbol was declared */
+	struct position endpos;		/* Where this symbol ends*/
 	struct ident *ident;		/* What identifier this symbol is associated with */
 	struct symbol *next_id;		/* Next semantic symbol that shares this identifier */
 	struct symbol **id_list;	/* Back pointer to symbol list head */
-- 
1.5.2-rc3.GIT


--------------040700010305000000020101
Content-Type: text/x-patch;
 name="0002-add-sparse_keep_tokens-api-to-lib.h.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="0002-add-sparse_keep_tokens-api-to-lib.h.patch"


================================================================================


################################################################################

=== Thread: [PATCH 1/5] Fix an "'__sentinel__' attribute directive ignored" warning ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: [PATCH 1/5] Fix an "'__sentinel__' attribute directive ignored" warning
Date: Tue, 22 May 2007 17:58:47 +0000
Message-ID: <46532F57.1060806 () ramsay1 ! demon ! co ! uk>
--------------------

This attribute was introduced in gcc 3.5. My Cygwin install, which
is not that old, is using gcc 3.4.4.

Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>
---
  lib.h |    6 ++++++
  1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/lib.h b/lib.h
index df9cfc4..6902f91 100644
--- a/lib.h
+++ b/lib.h
@@ -68,10 +68,16 @@ typedef struct pseudo *pseudo_t;
  struct token *skip_to(struct token *, int);
  struct token *expect(struct token *, int, const char *);
  #ifdef __GNUC__
+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC__MINOR__)
  #define FORMAT_ATTR(pos) __attribute__ ((__format__ (__printf__, pos, pos+1)))
  #define NORETURN_ATTR __attribute__ ((__noreturn__))
+/* __sentinel__ attribute was introduced in gcc 3.5 */
+#if (GCC_VERSION >= 3005)
  #define SENTINEL_ATTR __attribute__ ((__sentinel__))
  #else
+#define SENTINEL_ATTR
+#endif /* gcc >= 3.5 */
+#else
  #define FORMAT_ATTR(pos)
  #define NORETURN_ATTR
  #define SENTINEL_ATTR
-- 
1.5.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/5] Moving statement parsing into smaller functions. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 1/5] Moving statement parsing into smaller functions.
Date: Wed, 07 Mar 2007 10:03:08 +0000
Message-ID: <20070307100308.GB10577 () chrisli ! org>
--------------------

This is the preparation step for the keyword table driven
parsing. Those statement parsing function will later
turn into function call back.

The patch should not introduce any functional changes.

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-02-28 16:41:57.000000000 -0800
+++ sparse/parse.c	2007-02-28 17:22:38.000000000 -0800
@@ -1118,6 +1118,7 @@ static struct token *parse_asm_clobbers(
 
 static struct token *parse_asm(struct token *token, struct statement *stmt)
 {
+	token = token->next;
 	stmt->type = STMT_ASM;
 	if (match_idents(token, &__volatile___ident, &__volatile_ident, &volatile_ident, NULL)) {
 		token = token->next;
@@ -1345,56 +1346,125 @@ static struct token *parse_do_statement(
 	return expect(token, ';', "after statement");
 }
 
+static struct token *parse_if_statement(struct token *token, struct statement *stmt)
+{
+	stmt->type = STMT_IF;
+	token = parens_expression(token->next, &stmt->if_conditional, "after if");
+	token = statement(token, &stmt->if_true);
+	if (token_type(token) != TOKEN_IDENT)
+		return token;
+	if (token->ident != &else_ident)
+		return token;
+	return statement(token->next, &stmt->if_false);
+}
+
+static inline struct token *case_statement(struct token *token, struct statement *stmt)
+{
+	stmt->type = STMT_CASE;
+	token = expect(token, ':', "after default/case");
+	add_case_statement(stmt);
+	return statement(token, &stmt->case_statement);
+}
+
+static struct token *parse_case_statement(struct token *token, struct statement *stmt)
+{
+	token = parse_expression(token->next, &stmt->case_expression);
+	if (match_op(token, SPECIAL_ELLIPSIS))
+		token = parse_expression(token->next, &stmt->case_to);
+	return case_statement(token, stmt);
+}
+
+static struct token *parse_default_statement(struct token *token, struct statement *stmt)
+{
+	return case_statement(token->next, stmt); 
+}
+
+static struct token *parse_loop_iterator(struct token *token, struct statement *stmt)
+{
+	struct symbol *target = lookup_symbol(token->ident, NS_ITERATOR);
+	stmt->type = STMT_GOTO;
+	stmt->goto_label = target;
+	if (!target)
+		sparse_error(stmt->pos, "break/continue not in iterator scope");
+	return expect(token->next, ';', "at end of statement");
+}
+
+static struct token *parse_switch_statement(struct token *token, struct statement *stmt)
+{
+	stmt->type = STMT_SWITCH;
+	start_switch(stmt);
+	token = parens_expression(token->next, &stmt->switch_expression, "after 'switch'");
+	token = statement(token, &stmt->switch_statement);
+	end_switch(stmt);
+	return token;
+}
+
+static struct token *parse_goto_statement(struct token *token, struct statement *stmt)
+{
+	stmt->type = STMT_GOTO;
+	token = token->next;
+	if (match_op(token, '*')) {
+		token = parse_expression(token->next, &stmt->goto_expression);
+		add_statement(&function_computed_goto_list, stmt);
+	} else if (token_type(token) == TOKEN_IDENT) {
+		stmt->goto_label = label_symbol(token);
+		token = token->next;
+	} else {
+		sparse_error(token->pos, "Expected identifier or goto expression");
+	}
+	return expect(token, ';', "at end of statement");
+}
+
+static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+{
+	stmt->type = STMT_CONTEXT;
+	token = parse_expression(token->next, &stmt->expression);
+	if(stmt->expression->type == EXPR_PREOP
+	   && stmt->expression->op == '('
+	   && stmt->expression->unop->type == EXPR_COMMA) {
+		struct expression *expr;
+		expr = stmt->expression->unop;
+		stmt->context = expr->left;
+		stmt->expression = expr->right;
+	}
+	return expect(token, ';', "at end of statement");
+}
+
+static struct token *parse_range_statement(struct token *token, struct statement *stmt)
+{
+	stmt->type = STMT_RANGE;
+	token = assignment_expression(token->next, &stmt->range_expression);
+	token = expect(token, ',', "after range expression");
+	token = assignment_expression(token, &stmt->range_low);
+	token = expect(token, ',', "after low range");
+	token = assignment_expression(token, &stmt->range_high);
+	return expect(token, ';', "after range statement");
+}
+
 static struct token *statement(struct token *token, struct statement **tree)
 {
 	struct statement *stmt = alloc_statement(token->pos, STMT_NONE);
 
 	*tree = stmt;
 	if (token_type(token) == TOKEN_IDENT) {
-		if (token->ident == &if_ident) {
-			stmt->type = STMT_IF;
-			token = parens_expression(token->next, &stmt->if_conditional, "after if");
-			token = statement(token, &stmt->if_true);
-			if (token_type(token) != TOKEN_IDENT)
-				return token;
-			if (token->ident != &else_ident)
-				return token;
-			return statement(token->next, &stmt->if_false);
-		}
+		if (token->ident == &if_ident)
+			return parse_if_statement(token, stmt);
 
 		if (token->ident == &return_ident)
 			return parse_return_statement(token, stmt);
 
-		if (token->ident == &break_ident || token->ident == &continue_ident) {
-			struct symbol *target = lookup_symbol(token->ident, NS_ITERATOR);
-			stmt->type = STMT_GOTO;
-			stmt->goto_label = target;
-			if (!target)
-				sparse_error(stmt->pos, "break/continue not in iterator scope");
-			return expect(token->next, ';', "at end of statement");
-		}
-		if (token->ident == &default_ident) {
-			token = token->next;
-			goto default_statement;
-		}
-		if (token->ident == &case_ident) {
-			token = parse_expression(token->next, &stmt->case_expression);
-			if (match_op(token, SPECIAL_ELLIPSIS))
-				token = parse_expression(token->next, &stmt->case_to);
-default_statement:
-			stmt->type = STMT_CASE;
-			token = expect(token, ':', "after default/case");
-			add_case_statement(stmt);
-			return statement(token, &stmt->case_statement);
-		}
-		if (token->ident == &switch_ident) {
-			stmt->type = STMT_SWITCH;
-			start_switch(stmt);
-			token = parens_expression(token->next, &stmt->switch_expression, "after 'switch'");
-			token = statement(token, &stmt->switch_statement);
-			end_switch(stmt);
-			return token;
-		}
+		if (token->ident == &break_ident || token->ident == &continue_ident)
+			return parse_loop_iterator(token, stmt);
+
+		if (token->ident == &default_ident)
+			return parse_default_statement(token, stmt);
+
+		if (token->ident == &case_ident)
+			return parse_case_statement(token, stmt);
+
+		if (token->ident == &switch_ident)
+			return parse_switch_statement(token, stmt);
+
 		if (token->ident == &for_ident)
 			return parse_for_statement(token, stmt);
 
@@ -1404,45 +1474,18 @@ default_statement:
 		if (token->ident == &do_ident)
 			return parse_do_statement(token, stmt);
 
-		if (token->ident == &goto_ident) {
-			stmt->type = STMT_GOTO;
-			token = token->next;
-			if (match_op(token, '*')) {
-				token = parse_expression(token->next, &stmt->goto_expression);
-				add_statement(&function_computed_goto_list, stmt);
-			} else if (token_type(token) == TOKEN_IDENT) {
-				stmt->goto_label = label_symbol(token);
-				token = token->next;
-			} else {
-				sparse_error(token->pos, "Expected identifier or goto expression");
-			}
-			return expect(token, ';', "at end of statement");
-		}
-		if (match_idents(token, &asm_ident, &__asm___ident, &__asm_ident, NULL)) {
-			return parse_asm(token->next, stmt);
-		}
-		if (token->ident == &__context___ident) {
-			stmt->type = STMT_CONTEXT;
-			token = parse_expression(token->next, &stmt->expression);
-			if(stmt->expression->type == EXPR_PREOP
-			   && stmt->expression->op == '('
-			   && stmt->expression->unop->type == EXPR_COMMA) {
-				struct expression *expr;
-				expr = stmt->expression->unop;
-				stmt->context = expr->left;
-				stmt->expression = expr->right;
-			}
-			return expect(token, ';', "at end of statement");
-		}
-		if (token->ident == &__range___ident) {
-			stmt->type = STMT_RANGE;
-			token = assignment_expression(token->next, &stmt->range_expression);
-			token = expect(token, ',', "after range expression");
-			token = assignment_expression(token, &stmt->range_low);
-			token = expect(token, ',', "after low range");
-			token = assignment_expression(token, &stmt->range_high);
-			return expect(token, ';', "after range statement");
-		}
+		if (token->ident == &goto_ident)
+			return parse_goto_statement(token, stmt);
+
+		if (match_idents(token, &asm_ident, &__asm___ident, &__asm_ident, NULL))
+			return parse_asm(token, stmt);
+
+		if (token->ident == &__context___ident)
+			return parse_context_statement(token, stmt);
+
+		if (token->ident == &__range___ident)
+			return parse_range_statement(token, stmt);
+
 		if (match_op(token->next, ':')) {
 			stmt->type = STMT_LABEL;
 			stmt->label_identifier = label_symbol(token);
@@ -1768,6 +1811,21 @@ static struct token *parse_k_r_arguments
 	return parse_function_body(token, decl, list);
 }
 
+static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list)
+{
+	struct symbol *anon = alloc_symbol(token->pos, SYM_NODE);
+	struct symbol *fn = alloc_symbol(token->pos, SYM_FN);
+	struct statement *stmt;
+
+	anon->ctype.base_type = fn;
+	stmt = alloc_statement(token->pos, STMT_NONE);
+	fn->stmt = stmt;
+	
+	token = parse_asm(token, stmt);
+
+	add_symbol(list, anon);
+	return token;
+}
 
 struct token *external_declaration(struct token *token, struct symbol_list **list)
 {
@@ -1778,20 +1836,8 @@ struct token *external_declaration(struc
 	int is_typedef;
 
 	/* Top-level inline asm? */
-	if (match_idents(token, &asm_ident, &__asm___ident, &__asm_ident, NULL)) {
-		struct symbol *anon = alloc_symbol(token->pos, SYM_NODE);
-		struct symbol *fn = alloc_symbol(token->pos, SYM_FN);
-		struct statement *stmt;
-
-		anon->ctype.base_type = fn;
-		stmt = alloc_statement(token->pos, STMT_NONE);
-		fn->stmt = stmt;
-		
-		token = parse_asm(token->next, stmt);
-
-		add_symbol(list, anon);
-		return token;
-	}
+	if (match_idents(token, &asm_ident, &__asm___ident, &__asm_ident, NULL))
+		return toplevel_asm_declaration(token, list);
 
 	/* Parse declaration-specifiers, if any */
 	token = declaration_specifiers(token, &ctype, 0);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 10] Marking anonymous string. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 10] Marking anonymous string.
Date: Wed, 17 Jan 2007 02:45:45 +0000
Message-ID: <20070117024545.GK962 () chrisli ! org>
--------------------

The back end need to generate some storage for anonymous string. 
This simplify testing of anonymous string.

Signed-off-by: Christopher Li <sparse@chrisli.org>

Index: sparse/symbol.h
===================================================================
--- sparse.orig/symbol.h	2006-12-12 02:04:05.000000000 -0800
+++ sparse/symbol.h	2006-12-12 02:05:24.000000000 -0800
@@ -118,7 +118,8 @@ struct symbol {
 					initialized:1,
 					examined:1,
 					expanding:1,
-					evaluated:1;
+					evaluated:1,
+					string:1;
 			struct expression *array_size;
 			struct ctype ctype;
 			struct symbol_list *arguments;
Index: sparse/evaluate.c
===================================================================
--- sparse.orig/evaluate.c	2006-12-12 02:04:05.000000000 -0800
+++ sparse/evaluate.c	2006-12-12 02:05:24.000000000 -0800
@@ -74,6 +74,7 @@ static struct symbol *evaluate_string(st
 	sym->array_size = alloc_const_expression(expr->pos, length);
 	sym->bit_size = bits_in_char * length;
 	sym->ctype.alignment = 1;
+	sym->string = 1;
 	sym->ctype.modifiers = MOD_STATIC;
 	sym->ctype.base_type = array;
 	sym->initializer = initstr;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 10] Marking anonymous string.
Date: Sat, 27 Jan 2007 09:32:05 +0000
Message-ID: <45BB1C15.9060509 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig50463CD71B9AAD9F7255C1AA
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> The back end need to generate some storage for anonymous string.=20
> This simplify testing of anonymous string.

Applied; thanks.

- Josh Triplett



--------------enig50463CD71B9AAD9F7255C1AA
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFuxwVGJuZRtD+evsRAqE5AJ4uVkVWv6cpdoBIoWU2NGPwH9gACgCggw5y
aCIJl4oER4IwygaeA98Bxi4=
=JZrz
-----END PGP SIGNATURE-----

--------------enig50463CD71B9AAD9F7255C1AA--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 11] Make the ptrlist using the sparse allocator. ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 11] Make the ptrlist using the sparse allocator.
Date: Fri, 23 Feb 2007 03:54:12 +0000
Message-ID: <45DE6564.6040908 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE0C982C100A10E0D61F9CA0B
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> We can drop the whole allocator without freeing the
> ptrlist one by one.
>=20
> Signed-off-by: Christopher Li <sparse@chrisli.org>

Applied, though I'd love to see more descriptive names for __DO_ALLOCATOR=
 and
__ALLOCATOR.

- Josh Triplett


--------------enigE0C982C100A10E0D61F9CA0B
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3mVkGJuZRtD+evsRAp1UAKCej2g/4DstdTgETeKyNUi0N4XdZgCeOCXl
cgpLN6D4sf+cS402aJlMg9w=
=zxog
-----END PGP SIGNATURE-----

--------------enigE0C982C100A10E0D61F9CA0B--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 15/16] deal with enum members without excessive PITA ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 15/16] deal with enum members without excessive PITA
Date: Sun, 24 Jun 2007 08:05:41 +0000
Message-ID: <E1I2N6L-0003fT-82 () ZenIV ! linux ! org ! uk>
--------------------

mark symbols for enum members, have primary_expression() copy their
->initializer instead of dancing through the EXRP_SYMBOL with
expand_expression() finally getting to the damn thing.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 expression.c |    7 +++++++
 parse.c      |    1 +
 symbol.h     |    2 +-
 3 files changed, 9 insertions(+), 1 deletions(-)

diff --git a/expression.c b/expression.c
index cf076a9..a40ab2b 100644
--- a/expression.c
+++ b/expression.c
@@ -359,6 +359,13 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 				token = builtin_types_compatible_p_expr(token, &expr);
 				break;
 			}
+		} else if (sym->enum_member) {
+			expr = alloc_expression(token->pos, EXPR_VALUE);
+			*expr = *sym->initializer;
+			/* we want the right position reported, thus the copy */
+			expr->pos = token->pos;
+			token = next;
+			break;
 		}
 
 		expr = alloc_expression(token->pos, EXPR_SYMBOL);
diff --git a/parse.c b/parse.c
index cfbf190..4e8a18b 100644
--- a/parse.c
+++ b/parse.c
@@ -667,6 +667,7 @@ static struct token *parse_enum_declaration(struct token *token, struct symbol *
 		}
 
 		sym->initializer = expr;
+		sym->enum_member = 1;
 		sym->ctype.base_type = parent;
 		add_ptr_list(&entries, sym);
 
diff --git a/symbol.h b/symbol.h
index 157346d..2bde84d 100644
--- a/symbol.h
+++ b/symbol.h
@@ -109,7 +109,7 @@ extern int expand_constant_p(struct expression *expr, int cost);
 struct symbol {
 	enum type type:8;
 	enum namespace namespace:9;
-	unsigned char used:1, attr:2;
+	unsigned char used:1, attr:2, enum_member:1;
 	struct position pos;		/* Where this symbol was declared */
 	struct ident *ident;		/* What identifier this symbol is associated with */
 	struct symbol *next_id;		/* Next semantic symbol that shares this identifier */
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Re: [PATCH 15/16] deal with enum members without excessive PITA
Date: Thu, 13 Dec 2007 14:21:32 +0000
Message-ID: <OFAE867B27.E1902CE8-ONC12573B0.004D30CA-C12573B0.004EE4A1 () br-automation ! com>
--------------------
Hello Al,

I just saw your patch for enum members, really late, I know.

But i've got a question: If I've got the symbol for a global enum - how do 
I get from this to the symbols for the enum members?
If there is no way, I've got to loop over all symbols within global_scope, 
right?

Best regards
Thomas Schmid
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 15/16] deal with enum members without excessive PITA
Date: Fri, 14 Dec 2007 00:18:21 +0000
Message-ID: <70318cbf0712131618k6b3ffc98ibbf68156dc67b52e () mail ! gmail ! com>
--------------------
It seems there is not good way to get the enum members from the parent symbol.
It should be trivial make a patch to add members to the parent
symbol->symbol_list though.

Chris


On Dec 13, 2007 6:21 AM, Thomas Schmid <Thomas.Schmid@br-automation.com> wrote:
> Hello Al,
>
> I just saw your patch for enum members, really late, I know.
>
> But i've got a question: If I've got the symbol for a global enum - how do
> I get from this to the symbols for the enum members?
> If there is no way, I've got to loop over all symbols within global_scope,
> right?
>
> Best regards
> Thomas Schmid
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1] Adding debug option for showing the linearized instruction. ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1] Adding debug option for showing the linearized instruction.
Date: Sun, 25 Feb 2007 22:53:50 +0000
Message-ID: <45E2137E.2080905 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE8849A5B3064572FCA5021C2
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> On Thu, Feb 22, 2007 at 08:28:25PM -0800, Josh Triplett wrote:
>> Looks reasonable; debug information does seem like a logical extension=
 of verbosity.
>>
>> Could I get a signoff, please?
>>
>> - Josh Triplett
>>
>=20
> Adding debug option for showing the linearized instruction.
>=20
> Signed-Off-By: Christopher Li <sparse@chrisli.org>

Applied.

- Josh Triplett



--------------enigE8849A5B3064572FCA5021C2
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF4hN+GJuZRtD+evsRAnmZAKCGIrnVIzwcMsZeT32hzxd4jjVm4wCdHX0l
meXcHo1nMr21XWjlx0fHWY0=
=lxqw
-----END PGP SIGNATURE-----

--------------enigE8849A5B3064572FCA5021C2--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1] The updated sparse ctags ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1] The updated sparse ctags
Date: Wed, 17 Jan 2007 04:33:04 +0000
Message-ID: <45ADA700.9040104 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig7E1F01AE53B0836D9FEAA498
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> This is the updated ctags that actually generate output to tags file.
>=20
> Signed-Off-By: Christopher Li<sparse@chrisli.org>

Merged, along with a Makefile fix, a .gitignore entry for ctags, some min=
or
typo fixes, and the full description from your original commit message.

- Josh Triplett


--------------enig7E1F01AE53B0836D9FEAA498
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD4DBQFFracKGJuZRtD+evsRAhTYAJUbGZ9gbWRVMnl2ZmFDWun/J+hzAJ9uDF4G
roY/hjPQHTGq2SYpX676+w==
=UqQe
-----END PGP SIGNATURE-----

--------------enig7E1F01AE53B0836D9FEAA498--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/4] add sparse_keep_tokens api to lib.h ===

From: Rob Taylor <rob.taylor@codethink.co.uk>
To: Unknown
Subject: [PATCH 2/4] add sparse_keep_tokens api to lib.h
Date: Fri, 29 Jun 2007 17:33:29 +0100
Message-ID: 
--------------------
Adds sparse_keep_tokens, which is the same as __sparse, but doesn't free the
tokens after parsing. Useful fow ehen you want to inspect macro symbols after
parsing.

Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
---
 lib.c |   13 ++++++++++++-
 lib.h |    1 +
 2 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/lib.c b/lib.c
index 7fea474..aba547a 100644
--- a/lib.c
+++ b/lib.c
@@ -741,7 +741,7 @@ struct symbol_list *sparse_initialize(int argc, char **argv, struct string_list
 	return list;
 }
 
-struct symbol_list * __sparse(char *filename)
+struct symbol_list * sparse_keep_tokens(char *filename)
 {
 	struct symbol_list *res;
 
@@ -751,6 +751,17 @@ struct symbol_list * __sparse(char *filename)
 	new_file_scope();
 	res = sparse_file(filename);
 
+	/* And return it */
+	return res;
+}
+
+
+struct symbol_list * __sparse(char *filename)
+{
+	struct symbol_list *res;
+
+	res = sparse_keep_tokens(filename);
+
 	/* Drop the tokens for this file after parsing */
 	clear_token_alloc();
 
diff --git a/lib.h b/lib.h
index bc2a8c2..aacafea 100644
--- a/lib.h
+++ b/lib.h
@@ -113,6 +113,7 @@ extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
 extern struct symbol_list *sparse_initialize(int argc, char **argv, struct string_list **files);
 extern struct symbol_list *__sparse(char *filename);
+extern struct symbol_list *sparse_keep_tokens(char *filename);
 extern struct symbol_list *sparse(char *filename);
 
 static inline int symbol_list_size(struct symbol_list *list)
-- 
1.5.2-rc3.GIT


--------------040700010305000000020101
Content-Type: text/x-patch;
 name="0003-new-get_type_name-function.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="0003-new-get_type_name-function.patch"


================================================================================


################################################################################

=== Thread: [PATCH 2/5] Free up some special bits in modifiers. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 2/5] Free up some special bits in modifiers.
Date: Wed, 07 Mar 2007 10:06:19 +0000
Message-ID: <20070307100619.GC10577 () chrisli ! org>
--------------------
This change using symbol_op to contain the specifier parsing
function. It is easier to add new specifiers. We don't need
special bits any more.

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/parse.h
===================================================================
--- sparse.orig/parse.h	2007-03-05 00:27:18.000000000 -0800
+++ sparse/parse.h	2007-03-05 00:33:03.000000000 -0800
@@ -133,5 +133,6 @@ extern struct symbol *ctype_fp(unsigned 
 extern void copy_statement(struct statement *src, struct statement *dst);
 extern int inline_function(struct expression *expr, struct symbol *sym);
 extern void uninline(struct symbol *sym);
+extern void init_parser(int);
 
 #endif /* PARSE_H */
Index: sparse/symbol.c
===================================================================
--- sparse.orig/symbol.c	2007-03-05 00:27:18.000000000 -0800
+++ sparse/symbol.c	2007-03-05 00:33:03.000000000 -0800
@@ -678,43 +678,9 @@ static struct sym_init {
 	{ "__label__",	&label_ctype,	MOD_LABEL | MOD_UNSIGNED },
 	{ "_Bool",	&bool_ctype,	MOD_UNSIGNED },
 
-	/* Type qualifiers */
-	{ "const",	NULL,		MOD_CONST },
-	{ "__const",	NULL,		MOD_CONST },
-	{ "__const__",	NULL,		MOD_CONST },
-	{ "volatile",	NULL,		MOD_VOLATILE },
-	{ "__volatile",	NULL,		MOD_VOLATILE },
-	{ "__volatile__", NULL,		MOD_VOLATILE },
-
 	/* Predeclared types */
 	{ "__builtin_va_list", &int_type, 0 },
 
-	/* Typedef.. */
-	{ "typedef",	NULL,		MOD_TYPEDEF },
-
-	/* Extended types */
-	{ "typeof",	NULL,		MOD_TYPEOF },
-	{ "__typeof",	NULL,		MOD_TYPEOF },
-	{ "__typeof__",	NULL,		MOD_TYPEOF },
-
-#if 0
-	{ "attribute",	NULL,		MOD_ATTRIBUTE },
-#endif
-	{ "__attribute", NULL,		MOD_ATTRIBUTE },
-	{ "__attribute__", NULL,	MOD_ATTRIBUTE },
-
-	{ "struct",	NULL,		MOD_STRUCTOF },
-	{ "union",	NULL,		MOD_UNIONOF },
-	{ "enum",	NULL,		MOD_ENUMOF },
-
-	{ "inline",	NULL,		MOD_INLINE },
-	{ "__inline",	NULL,		MOD_INLINE },
-	{ "__inline__",	NULL,		MOD_INLINE },
-
-	/* Ignored for now.. */
-	{ "restrict",	NULL,		0 },
-	{ "__restrict",	NULL,		0 },
-
 	{ NULL,		NULL,		0 }
 };
 
@@ -794,6 +760,7 @@ void init_symbols(void)
 	hash_ident(&n)
 #include "ident-list.h"
 
+	init_parser(stream);
 	for (ptr = symbol_init_table; ptr->name; ptr++) {
 		struct symbol *sym;
 		sym = create_symbol(stream, ptr->name, SYM_NODE, NS_TYPEDEF);
Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-03-05 00:32:57.000000000 -0800
+++ sparse/parse.c	2007-03-05 00:33:21.000000000 -0800
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 2003 Transmeta Corp.
  *               2003-2004 Linus Torvalds
+ * Copyright (C) 2004 Christopher Li
  *
  *  Licensed under the Open Software License version 1.1
  */
@@ -36,6 +37,96 @@ struct statement_list *function_computed
 static struct token *statement(struct token *token, struct statement **tree);
 static struct token *handle_attributes(struct token *token, struct ctype *ctype);
 
+static struct token *struct_specifier(struct token *token, struct ctype *ctype);
+static struct token *union_specifier(struct token *token, struct ctype *ctype);
+static struct token *enum_specifier(struct token *token, struct ctype *ctype);
+static struct token *attribute_specifier(struct token *token, struct ctype *ctype);
+static struct token *typeof_specifier(struct token *token, struct ctype *ctype);
+
+
+static struct symbol_op modifier_op = {
+	.type = KW_MODIFIER,
+};
+
+static struct symbol_op qualifier_op = {
+	.type = KW_QUALIFIER,
+};
+
+static struct symbol_op typeof_op = {
+	.type = KW_TYPEOF,
+	.declarator = typeof_specifier,
+};
+
+static struct symbol_op attribute_op = {
+	.type = KW_ATTRIBUTE,
+	.declarator = attribute_specifier,
+};
+
+static struct symbol_op struct_op = {
+	.type = KW_SPECIFIER,
+	.declarator = struct_specifier, 
+};
+
+static struct symbol_op union_op = {
+	.type = KW_SPECIFIER,
+	.declarator = union_specifier,
+};
+
+static struct symbol_op enum_op = {
+	.type = KW_SPECIFIER,
+	.declarator = enum_specifier,
+};
+
+static struct init_keyword {
+	const char *name;
+	enum namespace ns;
+	unsigned long modifiers;
+	struct symbol_op *op;
+} keyword_table[] = {
+	/* Type qualifiers */
+	{ "const",	NS_TYPEDEF, MOD_CONST, .op = &qualifier_op },
+	{ "__const",	NS_TYPEDEF, MOD_CONST, .op = &qualifier_op },
+	{ "__const__",	NS_TYPEDEF, MOD_CONST, .op = &qualifier_op },
+	{ "volatile",	NS_TYPEDEF, MOD_VOLATILE, .op = &qualifier_op },
+	{ "__volatile",		NS_TYPEDEF, MOD_VOLATILE, .op = &qualifier_op },
+	{ "__volatile__", 	NS_TYPEDEF, MOD_VOLATILE, .op = &qualifier_op },
+
+	/* Typedef.. */
+	{ "typedef",	NS_TYPEDEF, MOD_TYPEDEF, .op = &modifier_op },
+
+	/* Extended types */
+	{ "typeof", 	NS_TYPEDEF, .op = &typeof_op },
+	{ "__typeof", 	NS_TYPEDEF, .op = &typeof_op },
+	{ "__typeof__",	NS_TYPEDEF, .op = &typeof_op },
+
+	{ "__attribute",   NS_TYPEDEF, .op = &attribute_op },
+	{ "__attribute__", NS_TYPEDEF, .op = &attribute_op },
+
+	{ "struct",	NS_TYPEDEF, .op = &struct_op },
+	{ "union", 	NS_TYPEDEF, .op = &union_op },
+	{ "enum", 	NS_TYPEDEF, .op = &enum_op },
+
+	{ "inline",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
+	{ "__inline",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
+	{ "__inline__",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
+
+	/* Ignored for now.. */
+	{ "restrict",	NS_TYPEDEF, .op = &qualifier_op},
+	{ "__restrict",	NS_TYPEDEF, .op = &qualifier_op},
+};
+
+void init_parser(int stream)
+{
+	int i;
+	for (i = 0; i < sizeof keyword_table/sizeof keyword_table[0]; i++) {
+		struct init_keyword *ptr = keyword_table + i;
+		struct symbol *sym = create_symbol(stream, ptr->name, SYM_KEYWORD, ptr->ns);
+		sym->ident->keyword = 1;
+		sym->ctype.modifiers = ptr->modifiers;
+		sym->op = ptr->op;
+	}
+}
+
 // Add a symbol to the list of function-local symbols
 static void fn_local_symbol(struct symbol *sym)
 {
@@ -115,7 +206,7 @@ static int apply_modifiers(struct positi
 	return 0;
 }
 
-static struct symbol * indirect(struct position pos, struct ctype *ctype, int type)
+static struct symbol * alloc_indirect_symbol(struct position pos, struct ctype *ctype, int type)
 {
 	struct symbol *sym = alloc_symbol(pos, type);
 
@@ -207,11 +298,17 @@ static struct token *parse_struct_declar
 	return struct_declaration_list(token, &sym->symbol_list);
 }
 
-static struct token *struct_or_union_specifier(enum type type, struct token *token, struct ctype *ctype)
+static struct token *struct_specifier(struct token *token, struct ctype *ctype)
+{
+	return struct_union_enum_specifier(SYM_STRUCT, token, ctype, parse_struct_declaration);
+}
+
+static struct token *union_specifier(struct token *token, struct ctype *ctype)
 {
-	return struct_union_enum_specifier(type, token, ctype, parse_struct_declaration);
+	return struct_union_enum_specifier(SYM_UNION, token, ctype, parse_struct_declaration);
 }
 
+
 typedef struct {
 	int x;
 	unsigned long long y;
@@ -744,14 +841,11 @@ static void apply_ctype(struct position 
 static void check_modifiers(struct position *pos, struct symbol *s, unsigned long mod)
 {
 	unsigned long banned, wrong;
-	unsigned long this_mod = s->ctype.modifiers;
 	const unsigned long BANNED_SIZE = MOD_LONG | MOD_LONGLONG | MOD_SHORT;
 	const unsigned long BANNED_SIGN = MOD_SIGNED | MOD_UNSIGNED;
 
-	if (this_mod & (MOD_STRUCTOF | MOD_UNIONOF | MOD_ENUMOF))
-		banned = BANNED_SIZE | BANNED_SIGN;
-	else if (this_mod & MOD_SPECIALBITS)
-		banned = 0;
+	if (s->type == SYM_KEYWORD)
+		banned = s->op->type == KW_SPECIFIER ? (BANNED_SIZE | BANNED_SIGN) : 0;
 	else if (s->ctype.base_type == &fp_type)
 		banned = BANNED_SIGN;
 	else if (s->ctype.base_type == &int_type || !s->ctype.base_type || is_int_type (s))
@@ -790,19 +884,14 @@ static struct token *declaration_specifi
 			break;
 		thistype = s->ctype;
 		mod = thistype.modifiers;
-		if (qual && (mod & ~(MOD_ATTRIBUTE | MOD_CONST | MOD_VOLATILE)))
-			break;
-		if (mod & MOD_SPECIALBITS) {
-			if (mod & MOD_STRUCTOF)
-				next = struct_or_union_specifier(SYM_STRUCT, next, &thistype);
-			else if (mod & MOD_UNIONOF)
-				next = struct_or_union_specifier(SYM_UNION, next, &thistype);
-			else if (mod & MOD_ENUMOF)
-				next = enum_specifier(next, &thistype);
-			else if (mod & MOD_ATTRIBUTE)
-				next = attribute_specifier(next, &thistype);
-			else if (mod & MOD_TYPEOF)
-				next = typeof_specifier(next, &thistype);
+		if (qual) {
+			if (s->type != SYM_KEYWORD)
+				break;
+			if (!(s->op->type & (KW_ATTRIBUTE | KW_QUALIFIER)))
+				break;
+		}
+		if (s->type == SYM_KEYWORD && s->op->declarator) {
+			next = s->op->declarator(next, &thistype);
 			mod = thistype.modifiers;
 		}
 		type = thistype.base_type;
@@ -910,13 +999,13 @@ static struct token *direct_declarator(s
 				continue;
 			}
 
-			sym = indirect(token->pos, ctype, SYM_FN);
+			sym = alloc_indirect_symbol(token->pos, ctype, SYM_FN);
 			token = parameter_type_list(next, sym, p);
 			token = expect(token, ')', "in function declarator");
 			continue;
 		}
 		if (token->special == '[') {
-			struct symbol *array = indirect(token->pos, ctype, SYM_ARRAY);
+			struct symbol *array = alloc_indirect_symbol(token->pos, ctype, SYM_ARRAY);
 			token = abstract_array_declarator(token->next, array);
 			token = expect(token, ']', "in abstract_array_declarator");
 			ctype = &array->ctype;
@@ -932,7 +1021,7 @@ static struct token *pointer(struct toke
 	unsigned long modifiers;
 	struct symbol *base_type;
 
-	modifiers = ctype->modifiers & ~(MOD_TYPEDEF | MOD_ATTRIBUTE);
+	modifiers = ctype->modifiers & ~MOD_TYPEDEF;
 	base_type = ctype->base_type;
 	ctype->modifiers = modifiers;
 	
@@ -976,7 +1065,7 @@ static struct token *handle_bitfield(str
 		return conditional_expression(token->next, &expr);
 	}
 
-	bitfield = indirect(token->pos, ctype, SYM_BITFIELD);
+	bitfield = alloc_indirect_symbol(token->pos, ctype, SYM_BITFIELD);
 	token = conditional_expression(token->next, &expr);
 	width = get_expression_value(expr);
 	bitfield->bit_size = width;
Index: sparse/symbol.h
===================================================================
--- sparse.orig/symbol.h	2007-03-05 00:27:18.000000000 -0800
+++ sparse/symbol.h	2007-03-05 00:33:21.000000000 -0800
@@ -33,6 +33,7 @@ enum namespace {
 	NS_ITERATOR = 32,
 	NS_PREPROCESSOR = 64,
 	NS_UNDEF = 128,
+	NS_KEYWORD = 256,
 };
 
 enum type {
@@ -53,9 +54,18 @@ enum type {
 	SYM_LABEL,
 	SYM_RESTRICT,
 	SYM_FOULED,
+	SYM_KEYWORD,
 	SYM_BAD,
 };
 
+enum keyword {
+	KW_SPECIFIER 	= 1 << 0,
+	KW_MODIFIER	= 1 << 1,
+	KW_QUALIFIER	= 1 << 2,
+	KW_ATTRIBUTE	= 1 << 3,
+	KW_TYPEOF	= 1 << 4,
+};
+
 struct context {
 	struct expression *context;
 	unsigned int in, out;
@@ -74,9 +84,13 @@ struct ctype {
 };
 
 struct symbol_op {
+	enum keyword type;
 	int (*evaluate)(struct expression *);
 	int (*expand)(struct expression *, int);
 	int (*args)(struct expression *);
+
+	/* keywrods */
+	struct token *(*declarator)(struct token *token, struct ctype *ctype);
 };	
 
 extern int expand_safe_p(struct expression *expr, int cost);
@@ -87,8 +101,8 @@ extern int expand_constant_p(struct expr
 #define SYM_ATTR_STRONG		2
 
 struct symbol {
-	enum namespace namespace:8;
 	enum type type:8;
+	enum namespace namespace:9;
 	unsigned char used:1, attr:2;
 	struct position pos;		/* Where this symbol was declared */
 	struct ident *ident;		/* What identifier this symbol is associated with */
@@ -159,12 +173,7 @@ struct symbol {
 #define MOD_LONGLONG	0x0800
 
 #define MOD_TYPEDEF	0x1000
-#define MOD_STRUCTOF	0x2000
-#define MOD_UNIONOF	0x4000
-#define MOD_ENUMOF	0x8000
 
-#define MOD_TYPEOF	0x10000
-#define MOD_ATTRIBUTE	0x20000
 #define MOD_INLINE	0x40000
 #define MOD_ADDRESSABLE	0x80000
 
@@ -185,7 +194,6 @@ struct symbol {
 
 #define MOD_NONLOCAL	(MOD_EXTERN | MOD_TOPLEVEL)
 #define MOD_STORAGE	(MOD_AUTO | MOD_REGISTER | MOD_STATIC | MOD_EXTERN | MOD_INLINE | MOD_TOPLEVEL)
-#define MOD_SPECIALBITS (MOD_STRUCTOF | MOD_UNIONOF | MOD_ENUMOF | MOD_ATTRIBUTE | MOD_TYPEOF)
 #define MOD_SIGNEDNESS	(MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED)
 #define MOD_SPECIFIER	(MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG | MOD_SIGNEDNESS)
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG)
Index: sparse/lib.c
===================================================================
Index: sparse/token.h
===================================================================
--- sparse.orig/token.h	2007-03-05 00:27:18.000000000 -0800
+++ sparse/token.h	2007-03-05 00:33:03.000000000 -0800
@@ -54,7 +54,8 @@ struct ident {
 	struct symbol *symbols;	/* Pointer to semantic meaning list */
 	unsigned char len;	/* Length of identifier name */
 	unsigned char tainted:1,
-	              reserved:1;
+	              reserved:1,
+		      keyword:1;
 	char name[];		/* Actual identifier */
 };
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2] Fix core dump on anonymous symbol. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 2] Fix core dump on anonymous symbol.
Date: Sat, 10 Feb 2007 00:15:40 +0000
Message-ID: <20070210001540.GA20644 () chrisli ! org>
--------------------

Using the following can generate anonymous symbol without
initializer expression.

	return (struct foo) {};

It would be nice if sparse does not crash on it.

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/linearize.c
===================================================================
--- sparse.orig/linearize.c	2007-01-30 19:47:10.000000000 -0800
+++ sparse/linearize.c	2007-01-30 19:47:54.000000000 -0800
@@ -116,14 +116,16 @@ const char *show_pseudo(pseudo_t pseudo)
 		}
 		expr = sym->initializer;
 		snprintf(buf, 64, "<anon symbol:%p>", sym);
-		switch (expr->type) {
-		case EXPR_VALUE:
-			snprintf(buf, 64, "<symbol value: %lld>", expr->value);
-			break;
-		case EXPR_STRING:
-			return show_string(expr->string);
-		default:
-			break;
+		if (expr) {
+			switch (expr->type) {
+			case EXPR_VALUE:
+				snprintf(buf, 64, "<symbol value: %lld>", expr->value);
+				break;
+			case EXPR_STRING:
+				return show_string(expr->string);
+			default:
+				break;
+			}
 		}
 		break;
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 2] Fix core dump on anonymous symbol.
Date: Fri, 23 Feb 2007 04:33:04 +0000
Message-ID: <45DE6E80.7040805 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig05AD06A65BAAF25CEE704AF0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> Using the following can generate anonymous symbol without
> initializer expression.
>=20
> 	return (struct foo) {};
>=20
> It would be nice if sparse does not crash on it.
>=20
> Signed-Off-By: Christopher Li <sparse@chrisli.org>

I tried several variants of the code you suggest, but I couldn't seem to
reproduce the problem this solves.  Could you supply a full .c file for a=
 test
case?

In any case, applied.

- Josh Triplett


--------------enig05AD06A65BAAF25CEE704AF0
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3m6AGJuZRtD+evsRAm+IAKCQC3wWnL9awpNX6xz/Ypno9Nn2CQCffLZZ
wryidlf9FjVxPr52MJn1lTU=
=Lx6h
-----END PGP SIGNATURE-----

--------------enig05AD06A65BAAF25CEE704AF0--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/4] new get_type_name function ===

From: Rob Taylor <rob.taylor@codethink.co.uk>
To: Unknown
Subject: [PATCH 3/4] new get_type_name function
Date: Mon, 2 Jul 2007 13:26:42 +0100
Message-ID: 
--------------------
Adds function get_type_name to symbol.h to get a string representation of a given type.

Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
---
 symbol.c |   29 +++++++++++++++++++++++++++++
 symbol.h |    1 +
 2 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/symbol.c b/symbol.c
index 7585978..516c50f 100644
--- a/symbol.c
+++ b/symbol.c
@@ -444,6 +444,35 @@ struct symbol *examine_symbol_type(struct symbol * sym)
 	return sym;
 }
 
+const char* get_type_name(enum type type)
+{
+	const char *type_lookup[] = {
+	[SYM_UNINITIALIZED] = "uninitialized",
+	[SYM_PREPROCESSOR] = "preprocessor",
+	[SYM_BASETYPE] = "basetype",
+	[SYM_NODE] = "node",
+	[SYM_PTR] = "pointer",
+	[SYM_FN] = "function",
+	[SYM_ARRAY] = "array",
+	[SYM_STRUCT] = "struct",
+	[SYM_UNION] = "union",
+	[SYM_ENUM] = "enum",
+	[SYM_TYPEDEF] = "typedef",
+	[SYM_TYPEOF] = "typeof",
+	[SYM_MEMBER] = "member",
+	[SYM_BITFIELD] = "bitfield",
+	[SYM_LABEL] = "label",
+	[SYM_RESTRICT] = "restrict",
+	[SYM_FOULED] = "fouled",
+	[SYM_KEYWORD] = "keyword",
+	[SYM_BAD] = "bad"};
+
+	if (type <= SYM_BAD)
+		return type_lookup[type];
+	else
+		return NULL;
+}
+
 static struct symbol_list *restr, *fouled;
 
 void create_fouled(struct symbol *type)
diff --git a/symbol.h b/symbol.h
index be5e6b1..c651a84 100644
--- a/symbol.h
+++ b/symbol.h
@@ -267,6 +267,7 @@ extern void examine_simple_symbol_type(struct symbol *);
 extern const char *show_typename(struct symbol *sym);
 extern const char *builtin_typename(struct symbol *sym);
 extern const char *builtin_ctypename(struct ctype *ctype);
+extern const char* get_type_name(enum type type);
 
 extern void debug_symbol(struct symbol *);
 extern void merge_type(struct symbol *sym, struct symbol *base_type);
-- 
1.5.2-rc3.GIT


--------------040700010305000000020101
Content-Type: text/x-patch;
 name="0004-add-c2xml-program.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="0004-add-c2xml-program.patch"


================================================================================


################################################################################

=== Thread: [PATCH 3/5] Add (more) support for WIN32 attribute names ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: [PATCH 3/5] Add (more) support for WIN32 attribute names
Date: Tue, 22 May 2007 18:00:53 +0000
Message-ID: <46532FD5.6000307 () ramsay1 ! demon ! co ! uk>
--------------------

In particular, the following identifiers (along with their __X__ variants)
are now accepted as attribute names: fastcall, dllimport and dllexport.
(cdecl and stdcall were added in baf2c5a84e by Michael Stefaniuc).
For now, at least, these attributes are just ignored.

Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>
---
  ident-list.h |    7 +++++++
  parse.c      |    6 ++++++
  2 files changed, 13 insertions(+), 0 deletions(-)

diff --git a/ident-list.h b/ident-list.h
index 7633a2f..d09c2ab 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -70,6 +70,13 @@ IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
  IDENT(__deprecated__);
  IDENT(__warn_unused_result__);

+/* WIN32 specific Attribute names */
+IDENT(cdecl); IDENT(__cdecl__);
+IDENT(stdcall); IDENT(__stdcall__);
+IDENT(fastcall); IDENT(__fastcall__);
+IDENT(dllimport); IDENT(__dllimport__);
+IDENT(dllexport); IDENT(__dllexport__);
+
  /* Preprocessor idents */
  __IDENT(pragma_ident, "__pragma__", 0);
  __IDENT(__VA_ARGS___ident, "__VA_ARGS__", 0);
diff --git a/parse.c b/parse.c
index b74c7c0..db5c9e6 100644
--- a/parse.c
+++ b/parse.c
@@ -327,6 +327,12 @@ static struct init_keyword {
  	{ "__cdecl__",	NS_KEYWORD,	.op = &ignore_attr_op },
  	{ "stdcall",	NS_KEYWORD,	.op = &ignore_attr_op },
  	{ "__stdcall__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "fastcall",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__fastcall__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "dllimport",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__dllimport__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "dllexport",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__dllexport__",	NS_KEYWORD,	.op = &ignore_attr_op },
  };

  void init_parser(int stream)
-- 
1.5.1


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 3/5] Add (more) support for WIN32 attribute names
Date: Tue, 22 May 2007 22:50:57 +0000
Message-ID: <465373D1.9060303 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig0C92E01C6FB1A3A7CA659B0A
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Ramsay Jones wrote:
> In particular, the following identifiers (along with their __X__ varian=
ts)
> are now accepted as attribute names: fastcall, dllimport and dllexport.=

> (cdecl and stdcall were added in baf2c5a84e by Michael Stefaniuc).
> For now, at least, these attributes are just ignored.

Your patch seems to have some whitespace damage in the form of extra lead=
ing
spaces.  I've manually modified it to apply this time, but please figure =
out
what causes these patches to break and fix it.  You may want to test by
sending patches to yourself and trying to apply them.  I notice that you =
use
Thunderbird; format=3Dflowed may cause the problem, so try turning it off=
 by
disabling the preference mailnews.send_plaintext_flowed .  You can do so
either via Edit -> Preferences -> Advanced -> Config Editor; alternativel=
y, if
you have Enigmail installed, it offers a checkbox to turn off format=3Dfl=
owed in
its preferneces.

- Josh Triplett



--------------enig0C92E01C6FB1A3A7CA659B0A
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU3PRGJuZRtD+evsRAvcJAKCIWuWA/LZakE3EqqNtNQ4eBrjR1ACgtlzZ
w61+4k2RCEppxaR69Cz0k9U=
=flOr
-----END PGP SIGNATURE-----

--------------enig0C92E01C6FB1A3A7CA659B0A--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: [PATCH 3/5] Add (more) support for WIN32 attribute names
Date: Thu, 24 May 2007 17:24:14 +0000
Message-ID: <20070524102414.a3c177c7.rdunlap () xenotime ! net>
--------------------
On Thu, 24 May 2007 16:59:03 +0100 Ramsay Jones wrote:

> Indeed, all 5 patches have whitespace damage ;-(
> Sorry for messing that up. I was under the (false) impression that I had knocked
> Thunderbird into submission on this issue; my git patch submissions had not been
> rejected, so I just assumed everything was OK. However, it appears that, after
> inspecting the git patch e-mails left in my sent folder, all my git patches have
> suffered the same problem. (ie Junio has been silently fixing them up! - oops).
> 
> After much study last night, it seems that the pattern of corruption is: for all
> lines that start with a space, insert an extra space, except for lines which
> consist of a single space, which is removed instead. 8-)
> 
> However, it seems that after setting "mailnews.send_plaintext_flowed" as you
> suggest above, the extra space is no longer being inserted. The elimination of
> the lone space is still happening, but git-apply seems to be OK with it!

This may help with tbird:
http://mbligh.org/linuxdocs/Email/Clients/Thunderbird

---
~Randy
*** Remember to use Documentation/SubmitChecklist when testing your code ***
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/8] integer_promotions() can't get SYM_NODE ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 3/8] integer_promotions() can't get SYM_NODE
Date: Fri, 13 Jul 2007 17:44:47 +0000
Message-ID: <E1I9PCB-0000EF-51 () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |    9 ++-------
 1 files changed, 2 insertions(+), 7 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 7669c9a..88435da 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -98,17 +98,12 @@ static struct symbol *evaluate_string(struct expression *expr)
 	return sym;
 }
 
+/* type has come from classify_type and is an integer type */
 static inline struct symbol *integer_promotion(struct symbol *type)
 {
 	struct symbol *orig_type = type;
 	unsigned long mod =  type->ctype.modifiers;
-	int width;
-
-	if (type->type == SYM_NODE)
-		type = type->ctype.base_type;
-	if (type->type == SYM_ENUM)
-		type = type->ctype.base_type;
-	width = type->bit_size;
+	int width = type->bit_size;
 
 	/*
 	 * Bitfields always promote to the base type,
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH 3/8] integer_promotions() can't get SYM_NODE
Date: Fri, 13 Jul 2007 18:04:58 +0000
Message-ID: <1184349898.2616.42.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-13 at 18:44 +0100, Al Viro wrote:
> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
> ---
>  evaluate.c |    9 ++-------
>  1 files changed, 2 insertions(+), 7 deletions(-)
> 
> diff --git a/evaluate.c b/evaluate.c
> index 7669c9a..88435da 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -98,17 +98,12 @@ static struct symbol *evaluate_string(struct expression *expr)
>  	return sym;
>  }
> 
> +/* type has come from classify_type and is an integer type */
>  static inline struct symbol *integer_promotion(struct symbol *type)
>  {
>  	struct symbol *orig_type = type;
>  	unsigned long mod =  type->ctype.modifiers;
> -	int width;
> -
> -	if (type->type == SYM_NODE)
> -		type = type->ctype.base_type;
> -	if (type->type == SYM_ENUM)
> -		type = type->ctype.base_type;
> -	width = type->bit_size;
> +	int width = type->bit_size;
> 
>  	/*
>  	 * Bitfields always promote to the base type,

In addition to SYM_NODE as mentioned in the commit message, this also
removes SYM_ENUM as classify_type handles that too.  I'll append that to
the commit message.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3] Add instruction to pseudo user tracking. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 3] Add instruction to pseudo user tracking.
Date: Wed, 17 Jan 2007 02:36:16 +0000
Message-ID: <20070117023616.GC962 () chrisli ! org>
--------------------
The current way of tracking pseudo register user is by
keeping a list of the address of the pseudo_t member.
This address can be in part of the instruction member, the
worse case is in the argument list of the call instruction.

As the comment for address_taken() said, using the container
to get instruction pointer is wrong. It use to work with instruction
that relate to symbol address. But that is not true any more. Even
worse, it is very hard to track the pseudo usage other than symbol
address. The only reason symbol address used to works for call instruction
is because call instruction did not directly use the symbol address.

I bit the bullet and just add the instruction pointer to pair with
the pseudo user pointer. So it will work with the case that the
user instruction is call as well.

Testing:

I compare the linearize result with/without the patch on a few
sparse source file it self. The linearize generate exactly
the same result except the symbol address changes. Which is
predictable different because the pseudo user structure allocate
memory.

Singed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/flow.c
===================================================================
--- sparse.orig/flow.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/flow.c	2006-12-18 13:58:32.000000000 -0800
@@ -229,27 +229,27 @@ int simplify_flow(struct entrypoint *ep)
 	return simplify_branch_nodes(ep);
 }
 
-static inline void concat_user_list(struct pseudo_ptr_list *src, struct pseudo_ptr_list **dst)
+static inline void concat_user_list(struct pseudo_user_list *src, struct pseudo_user_list **dst)
 {
 	concat_ptr_list((struct ptr_list *)src, (struct ptr_list **)dst);
 }
 
 void convert_instruction_target(struct instruction *insn, pseudo_t src)
 {
-	pseudo_t target, *usep;
-
+	pseudo_t target;
+	struct pseudo_user *pu;
 	/*
 	 * Go through the "insn->users" list and replace them all..
 	 */
 	target = insn->target;
 	if (target == src)
 		return;
-	FOR_EACH_PTR(target->users, usep) {
-		if (*usep != VOID) {
-			assert(*usep == target);
-			*usep = src;
+	FOR_EACH_PTR(target->users, pu) {
+		if (*pu->userp != VOID) {
+			assert(*pu->userp == target);
+			*pu->userp = src;
 		}
-	} END_FOR_EACH_PTR(usep);
+	} END_FOR_EACH_PTR(pu);
 	concat_user_list(target->users, &src->users);
 	target->users = NULL;
 }
@@ -360,7 +360,7 @@ found_dominator:
 		phi = alloc_phi(parent, one->target, one->size);
 		phi->ident = phi->ident ? : pseudo->ident;
 		add_instruction(&parent->insns, br);
-		use_pseudo(phi, add_pseudo(dominators, phi));
+		use_pseudo(insn, phi, add_pseudo(dominators, phi));
 	} END_FOR_EACH_PTR(parent);
 	return 1;
 }		
@@ -592,7 +592,8 @@ void check_access(struct instruction *in
 
 static void simplify_one_symbol(struct entrypoint *ep, struct symbol *sym)
 {
-	pseudo_t pseudo, src, *pp;
+	pseudo_t pseudo, src;
+	struct pseudo_user *pu;
 	struct instruction *def;
 	unsigned long mod;
 	int all, stores, complex;
@@ -614,9 +615,9 @@ static void simplify_one_symbol(struct e
 	def = NULL;
 	stores = 0;
 	complex = 0;
-	FOR_EACH_PTR(pseudo->users, pp) {
+	FOR_EACH_PTR(pseudo->users, pu) {
 		/* We know that the symbol-pseudo use is the "src" in the instruction */
-		struct instruction *insn = container(pp, struct instruction, src);
+		struct instruction *insn = pu->insn;
 
 		switch (insn->opcode) {
 		case OP_STORE:
@@ -639,7 +640,7 @@ static void simplify_one_symbol(struct e
 			warning(sym->pos, "symbol '%s' pseudo used in unexpected way", show_ident(sym->ident));
 		}
 		complex |= insn->offset;
-	} END_FOR_EACH_PTR(pp);
+	} END_FOR_EACH_PTR(pu);
 
 	if (complex)
 		goto complex_def;
@@ -655,13 +656,13 @@ static void simplify_one_symbol(struct e
 	if (def)
 		src = def->target;
 
-	FOR_EACH_PTR(pseudo->users, pp) {
-		struct instruction *insn = container(pp, struct instruction, src);
+	FOR_EACH_PTR(pseudo->users, pu) {
+		struct instruction *insn = pu->insn;
 		if (insn->opcode == OP_LOAD) {
 			check_access(insn);
 			convert_load_instruction(insn, src);
 		}
-	} END_FOR_EACH_PTR(pp);
+	} END_FOR_EACH_PTR(pu);
 
 	/* Turn the store into a no-op */
 	kill_store(def);
@@ -671,29 +672,29 @@ multi_def:
 complex_def:
 external_visibility:
 	all = 1;
-	FOR_EACH_PTR_REVERSE(pseudo->users, pp) {
-		struct instruction *insn = container(pp, struct instruction, src);
+	FOR_EACH_PTR_REVERSE(pseudo->users, pu) {
+		struct instruction *insn = pu->insn;
 		if (insn->opcode == OP_LOAD)
 			all &= find_dominating_stores(pseudo, insn, ++bb_generation, !mod);
-	} END_FOR_EACH_PTR_REVERSE(pp);
+	} END_FOR_EACH_PTR_REVERSE(pu);
 
 	/* If we converted all the loads, remove the stores. They are dead */
 	if (all && !mod) {
-		FOR_EACH_PTR(pseudo->users, pp) {
-			struct instruction *insn = container(pp, struct instruction, src);
+		FOR_EACH_PTR(pseudo->users, pu) {
+			struct instruction *insn = pu->insn;
 			if (insn->opcode == OP_STORE)
 				kill_store(insn);
-		} END_FOR_EACH_PTR(pp);
+		} END_FOR_EACH_PTR(pu);
 	} else {
 		/*
 		 * If we couldn't take the shortcut, see if we can at least kill some
 		 * of them..
 		 */
-		FOR_EACH_PTR(pseudo->users, pp) {
-			struct instruction *insn = container(pp, struct instruction, src);
+		FOR_EACH_PTR(pseudo->users, pu) {
+			struct instruction *insn = pu->insn;
 			if (insn->opcode == OP_STORE)
 				kill_dominated_stores(pseudo, insn, ++bb_generation, insn->bb, !mod, 0);
-		} END_FOR_EACH_PTR(pp);
+		} END_FOR_EACH_PTR(pu);
 
 		if (!(mod & (MOD_NONLOCAL | MOD_STATIC))) {
 			struct basic_block *bb;
Index: sparse/simplify.c
===================================================================
--- sparse.orig/simplify.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/simplify.c	2006-12-18 13:58:32.000000000 -0800
@@ -146,10 +146,27 @@ static int clean_up_phi(struct instructi
 	return if_convert_phi(insn);
 }
 
+int delete_pseudo_user_list_entry(struct pseudo_user_list **list, pseudo_t *entry, int count)
+{
+	struct pseudo_user *pu;
+
+	FOR_EACH_PTR(*list, pu) {
+		if (pu->userp == entry) {
+			DELETE_CURRENT_PTR(pu);
+			if (!--count)
+				goto out;
+		}
+	} END_FOR_EACH_PTR(pu);
+	assert(count <= 0);
+out:
+	pack_ptr_list((struct ptr_list **)list);
+	return count;
+}
+
 static inline void remove_usage(pseudo_t p, pseudo_t *usep)
 {
 	if (has_use_list(p)) {
-		delete_ptr_list_entry((struct ptr_list **)&p->users, usep, 1);
+		delete_pseudo_user_list_entry(&p->users, usep, 1);
 		if (!p->users)
 			kill_instruction(p->def);
 	}
@@ -208,11 +225,11 @@ void kill_instruction(struct instruction
  */
 static int dead_insn(struct instruction *insn, pseudo_t *src1, pseudo_t *src2, pseudo_t *src3)
 {
-	pseudo_t *usep;
-	FOR_EACH_PTR(insn->target->users, usep) {
-		if (*usep != VOID)
+	struct pseudo_user *pu;
+	FOR_EACH_PTR(insn->target->users, pu) {
+		if (*pu->userp != VOID)
 			return 0;
-	} END_FOR_EACH_PTR(usep);
+	} END_FOR_EACH_PTR(pu);
 
 	insn->bb = NULL;
 	kill_use(src1);
@@ -419,12 +436,12 @@ static int simplify_binop(struct instruc
 	return 0;
 }
 
-static void switch_pseudo(pseudo_t *pp1, pseudo_t *pp2)
+static void switch_pseudo(struct instruction *insn1, pseudo_t *pp1, struct instruction *insn2, pseudo_t *pp2)
 {
 	pseudo_t p1 = *pp1, p2 = *pp2;
 
-	use_pseudo(p2, pp1);
-	use_pseudo(p1, pp2);
+	use_pseudo(insn1, p2, pp1);
+	use_pseudo(insn2, p1, pp2);
 	remove_usage(p1, pp1);
 	remove_usage(p2, pp2);
 }
@@ -444,7 +461,7 @@ static int canonical_order(pseudo_t p1, 
 static int simplify_commutative_binop(struct instruction *insn)
 {
 	if (!canonical_order(insn->src1, insn->src2)) {
-		switch_pseudo(&insn->src1, &insn->src2);
+		switch_pseudo(insn, &insn->src1, insn, &insn->src2);
 		return REPEAT_CSE;
 	}
 	return 0;
@@ -473,7 +490,7 @@ static int simplify_associative_binop(st
 		return 0;
 	if (ptr_list_size((struct ptr_list *)def->target->users) != 1)
 		return 0;
-	switch_pseudo(&def->src1, &insn->src2);
+	switch_pseudo(def, &def->src1, insn, &insn->src2);
 	return REPEAT_CSE;
 }
 
@@ -517,7 +534,7 @@ static int simplify_one_memop(struct ins
 		struct instruction *def = addr->def;
 		if (def->opcode == OP_SYMADDR && def->src) {
 			kill_use(&insn->src);
-			use_pseudo(def->src, &insn->src);
+			use_pseudo(insn, def->src, &insn->src);
 			return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
 		}
 		if (def->opcode == OP_ADD) {
@@ -543,7 +560,7 @@ offset:
 		warning(insn->pos, "crazy programmer");
 	}
 	insn->offset += off->value;
-	use_pseudo(new, &insn->src);
+	use_pseudo(insn, new, &insn->src);
 	remove_usage(addr, &insn->src);
 	return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
 }
@@ -699,7 +716,7 @@ static int simplify_range(struct instruc
  */
 static int simplify_cond_branch(struct instruction *br, pseudo_t cond, struct instruction *def, pseudo_t *pp)
 {
-	use_pseudo(*pp, &br->cond);
+	use_pseudo(br, *pp, &br->cond);
 	remove_usage(cond, &br->cond);
 	if (def->opcode == OP_SET_EQ) {
 		struct basic_block *true = br->bb_true;
@@ -763,7 +780,7 @@ static int simplify_branch(struct instru
 					insn->bb_false = true;
 					insn->bb_true = false;
 				}
-				use_pseudo(def->src1, &insn->cond);
+				use_pseudo(insn, def->src1, &insn->cond);
 				remove_usage(cond, &insn->cond);
 				return REPEAT_CSE;
 			}
@@ -771,7 +788,7 @@ static int simplify_branch(struct instru
 		if (def->opcode == OP_CAST || def->opcode == OP_SCAST) {
 			int orig_size = def->orig_type ? def->orig_type->bit_size : 0;
 			if (def->size > orig_size) {
-				use_pseudo(def->src, &insn->cond);
+				use_pseudo(insn, def->src, &insn->cond);
 				remove_usage(cond, &insn->cond);
 				return REPEAT_CSE;
 			}
Index: sparse/memops.c
===================================================================
--- sparse.orig/memops.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/memops.c	2006-12-18 13:58:32.000000000 -0800
@@ -59,31 +59,19 @@ found_dominator:
 		phi = alloc_phi(parent, one->target, one->size);
 		phi->ident = phi->ident ? : one->target->ident;
 		add_instruction(&parent->insns, br);
-		use_pseudo(phi, add_pseudo(dominators, phi));
+		use_pseudo(insn, phi, add_pseudo(dominators, phi));
 	} END_FOR_EACH_PTR(parent);
 	return 1;
 }		
 
-/*
- * FIXME! This is wrong. Since we now distribute out the OP_SYMADDR,
- * we can no longer really use "container()" to get from a user to
- * the instruction that uses it.
- *
- * This happens to work, simply because the likelihood of the
- * (possibly non-instruction) containing the right bitpattern
- * in the right place is pretty low. But this is still wrong.
- *
- * We should make symbol-pseudos count non-load/store usage,
- * or something.
- */
 static int address_taken(pseudo_t pseudo)
 {
-	pseudo_t *usep;
-	FOR_EACH_PTR(pseudo->users, usep) {
-		struct instruction *insn = container(usep, struct instruction, src);
+	struct pseudo_user *pu;
+	FOR_EACH_PTR(pseudo->users, pu) {
+		struct instruction *insn = pu->insn;
 		if (insn->bb && (insn->opcode != OP_LOAD || insn->opcode != OP_STORE))
 			return 1;
-	} END_FOR_EACH_PTR(usep);
+	} END_FOR_EACH_PTR(pu);
 	return 0;
 }
 
Index: sparse/linearize.h
===================================================================
--- sparse.orig/linearize.h	2006-12-18 13:58:01.000000000 -0800
+++ sparse/linearize.h	2006-12-19 16:12:49.000000000 -0800
@@ -9,6 +9,15 @@
 struct instruction;
 DECLARE_PTR_LIST(pseudo_ptr_list, pseudo_t);
 
+struct pseudo_user {
+	struct instruction *insn;
+	pseudo_t *userp;
+};
+
+DECLARE_ALLOCATOR(pseudo_user);
+DECLARE_PTR_LIST(pseudo_user_list, struct pseudo_user);
+
+
 enum pseudo_type {
 	PSEUDO_VOID,
 	PSEUDO_REG,
@@ -21,7 +30,7 @@ enum pseudo_type {
 struct pseudo {
 	int nr;
 	enum pseudo_type type;
-	struct pseudo_ptr_list *users;
+	struct pseudo_user_list *users;
 	struct ident *ident;
 	union {
 		struct symbol *sym;
@@ -268,16 +277,29 @@ static inline void add_pseudo_ptr(pseudo
 	add_ptr_list(list, ptr);
 }
 
+static inline void add_pseudo_user_ptr(struct pseudo_user *user, struct pseudo_user_list **list)
+{
+	add_ptr_list(list, user);
+}
+
 static inline int has_use_list(pseudo_t p)
 {
 	return (p && p->type != PSEUDO_VOID && p->type != PSEUDO_VAL);
 }
 
-static inline void use_pseudo(pseudo_t p, pseudo_t *pp)
+static inline struct pseudo_user* alloc_pseudo_user(struct instruction *insn, pseudo_t *pp)
+{
+	struct pseudo_user *user = __alloc_pseudo_user(0);
+	user->userp = pp;
+	user->insn = insn;
+	return user;
+}
+
+static inline void use_pseudo(struct instruction *insn, pseudo_t p, pseudo_t *pp)
 {
 	*pp = p;
 	if (has_use_list(p))
-		add_pseudo_ptr(pp, &p->users);
+		add_pseudo_user_ptr(alloc_pseudo_user(insn, pp), &p->users);
 }
 
 static inline void remove_bb_from_list(struct basic_block_list **list, struct basic_block *entry, int count)
Index: sparse/linearize.c
===================================================================
--- sparse.orig/linearize.c	2006-12-18 13:58:01.000000000 -0800
+++ sparse/linearize.c	2006-12-19 16:13:29.000000000 -0800
@@ -37,6 +37,8 @@ struct pseudo void_pseudo = {};
 
 static struct position current_pos;
 
+ALLOCATOR(pseudo_user, "pseudo_user");
+
 static struct instruction *alloc_instruction(int opcode, int size)
 {
 	struct instruction * insn = __alloc_instruction(0);
@@ -517,12 +519,12 @@ void show_bb(struct basic_block *bb)
 
 static void show_symbol_usage(pseudo_t pseudo)
 {
+	struct pseudo_user *pu;
+
 	if (pseudo) {
-		pseudo_t *pp;
-		FOR_EACH_PTR(pseudo->users, pp) {
-			struct instruction *insn = container(pp, struct instruction, src);
-			printf("\t%s\n", show_instruction(insn));
-		} END_FOR_EACH_PTR(pp);
+		FOR_EACH_PTR(pseudo->users, pu) {
+			printf("\t%s\n", show_instruction(pu->insn));
+		} END_FOR_EACH_PTR(pu);
 	}
 }
 
@@ -667,15 +669,15 @@ void insert_select(struct basic_block *b
 	select->bb = bb;
 
 	assert(br->cond);
-	use_pseudo(br->cond, &select->src1);
+	use_pseudo(select, br->cond, &select->src1);
 
 	target = phi_node->target;
 	assert(target->def == phi_node);
 	select->target = target;
 	target->def = select;
 
-	use_pseudo(true, &select->src2);
-	use_pseudo(false, &select->src3);
+	use_pseudo(select, true, &select->src2);
+	use_pseudo(select, false, &select->src3);
 
 	add_instruction(&bb->insns, select);
 	add_instruction(&bb->insns, br);
@@ -711,7 +713,7 @@ static void add_branch(struct entrypoint
 
 	if (bb_reachable(bb)) {
        		br = alloc_instruction(OP_BR, 0);
-		use_pseudo(cond, &br->cond);
+		use_pseudo(br, cond, &br->cond);
 		br->bb_true = bb_true;
 		br->bb_false = bb_false;
 		add_bb(&bb_true->parents, bb);
@@ -809,7 +811,7 @@ pseudo_t alloc_phi(struct basic_block *s
 	phi->nr = ++nr;
 	phi->def = insn;
 
-	use_pseudo(pseudo, &insn->phi_src);
+	use_pseudo(insn, pseudo, &insn->phi_src);
 	insn->bb = source;
 	insn->target = phi;
 	add_instruction(&source->insns, insn);
@@ -905,7 +907,7 @@ static pseudo_t add_load(struct entrypoi
 
 	insn->target = new;
 	insn->offset = ad->offset;
-	use_pseudo(ad->address, &insn->src);
+	use_pseudo(insn, ad->address, &insn->src);
 	add_one_insn(ep, insn);
 	return new;
 }
@@ -917,8 +919,8 @@ static void add_store(struct entrypoint 
 	if (bb_reachable(bb)) {
 		struct instruction *store = alloc_typed_instruction(OP_STORE, ad->source_type);
 		store->offset = ad->offset;
-		use_pseudo(value, &store->target);
-		use_pseudo(ad->address, &store->src);
+		use_pseudo(store, value, &store->target);
+		use_pseudo(store, ad->address, &store->src);
 		add_one_insn(ep, store);
 	}
 }
@@ -950,8 +952,8 @@ static pseudo_t add_binary_op(struct ent
 	struct instruction *insn = alloc_typed_instruction(op, ctype);
 	pseudo_t target = alloc_pseudo(insn);
 	insn->target = target;
-	use_pseudo(left, &insn->src1);
-	use_pseudo(right, &insn->src2);
+	use_pseudo(insn, left, &insn->src1);
+	use_pseudo(insn, right, &insn->src2);
 	add_one_insn(ep, insn);
 	return target;
 }
@@ -972,7 +974,7 @@ static pseudo_t add_symbol_address(struc
 	pseudo_t target = alloc_pseudo(insn);
 
 	insn->target = target;
-	use_pseudo(symbol_pseudo(ep, sym), &insn->symbol);
+	use_pseudo(insn, symbol_pseudo(ep, sym), &insn->symbol);
 	add_one_insn(ep, insn);
 	return target;
 }
@@ -1026,7 +1028,7 @@ static pseudo_t add_uniop(struct entrypo
 	pseudo_t new = alloc_pseudo(insn);
 
 	insn->target = new;
-	use_pseudo(src, &insn->src1);
+	use_pseudo(insn, src, &insn->src1);
 	add_one_insn(ep, insn);
 	return new;
 }
@@ -1040,7 +1042,7 @@ static pseudo_t linearize_slice(struct e
 	insn->target = new;
 	insn->from = expr->r_bitpos;
 	insn->len = expr->r_nrbits;
-	use_pseudo(pre, &insn->base);
+	use_pseudo(insn, pre, &insn->base);
 	add_one_insn(ep, insn);
 	return new;
 }
@@ -1122,7 +1124,7 @@ static pseudo_t cast_pseudo(struct entry
 	result = alloc_pseudo(insn);
 	insn->target = result;
 	insn->orig_type = from;
-	use_pseudo(src, &insn->src);
+	use_pseudo(insn, src, &insn->src);
 	add_one_insn(ep, insn);
 	return result;
 }
@@ -1193,7 +1195,7 @@ static pseudo_t linearize_call_expressio
 
 	FOR_EACH_PTR(expr->args, arg) {
 		pseudo_t new = linearize_expression(ep, arg);
-		use_pseudo(new, add_pseudo(&insn->arguments, new));
+		use_pseudo(insn, new, add_pseudo(&insn->arguments, new));
 	} END_FOR_EACH_PTR(arg);
 
 	fn = expr->fn;
@@ -1213,7 +1215,7 @@ static pseudo_t linearize_call_expressio
 	} else {
 		call = linearize_expression(ep, fn);
 	}
-	use_pseudo(call, &insn->func);
+	use_pseudo(insn, call, &insn->func);
 	retval = VOID;
 	if (expr->ctype != &void_ctype)
 		retval = alloc_pseudo(insn);
@@ -1286,9 +1288,9 @@ static pseudo_t linearize_select(struct 
 	insn = alloc_typed_instruction(OP_SEL, expr->ctype);
 	if (!expr->cond_true)
 		true = cond;
-	use_pseudo(cond, &insn->src1);
-	use_pseudo(true, &insn->src2);
-	use_pseudo(false, &insn->src3);
+	use_pseudo(insn, cond, &insn->src1);
+	use_pseudo(insn, true, &insn->src2);
+	use_pseudo(insn, false, &insn->src3);
 
 	res = alloc_pseudo(insn);
 	insn->target = res;
@@ -1308,8 +1310,8 @@ static pseudo_t add_join_conditional(str
 		return phi1;
 
 	phi_node = alloc_typed_instruction(OP_PHI, expr->ctype);
-	use_pseudo(phi1, add_pseudo(&phi_node->phi_list, phi1));
-	use_pseudo(phi2, add_pseudo(&phi_node->phi_list, phi2));
+	use_pseudo(phi_node, phi1, add_pseudo(&phi_node->phi_list, phi1));
+	use_pseudo(phi_node, phi2, add_pseudo(&phi_node->phi_list, phi2));
 	phi_node->target = target = alloc_pseudo(phi_node);
 	add_one_insn(ep, phi_node);
 	return target;
@@ -1652,9 +1654,9 @@ static pseudo_t linearize_range(struct e
 {
 	struct instruction *insn = alloc_instruction(OP_RANGE, 0);
 
-	use_pseudo(linearize_expression(ep, stmt->range_expression), &insn->src1);
-	use_pseudo(linearize_expression(ep, stmt->range_low), &insn->src2);
-	use_pseudo(linearize_expression(ep, stmt->range_high), &insn->src3);
+	use_pseudo(insn, linearize_expression(ep, stmt->range_expression), &insn->src1);
+	use_pseudo(insn, linearize_expression(ep, stmt->range_low), &insn->src2);
+	use_pseudo(insn, linearize_expression(ep, stmt->range_high), &insn->src3);
 	add_one_insn(ep, insn);
 	return VOID;
 }
@@ -1670,7 +1672,7 @@ static void add_asm_input(struct entrypo
 
 	rule->ident = ident;
 	rule->constraint = constraint;
-	use_pseudo(pseudo, &rule->pseudo);
+	use_pseudo(insn, pseudo, &rule->pseudo);
 	add_ptr_list(&insn->asm_rules->inputs, rule);
 }
 
@@ -1688,7 +1690,7 @@ static void add_asm_output(struct entryp
 	rule = __alloc_asm_constraint(0);
 	rule->ident = ident;
 	rule->constraint = constraint;
-	use_pseudo(pseudo, &rule->pseudo);
+	use_pseudo(insn, pseudo, &rule->pseudo);
 	add_ptr_list(&insn->asm_rules->outputs, rule);
 }
 
@@ -1847,7 +1849,7 @@ pseudo_t linearize_statement(struct entr
 			}
 			phi = alloc_phi(active, src, type_size(expr->ctype));
 			phi->ident = &return_ident;
-			use_pseudo(phi, add_pseudo(&phi_node->phi_list, phi));
+			use_pseudo(phi_node, phi, add_pseudo(&phi_node->phi_list, phi));
 		}
 		add_goto(ep, bb_return);
 		return VOID;
@@ -1897,7 +1899,7 @@ pseudo_t linearize_statement(struct entr
 
 		pseudo = linearize_expression(ep, expr);
 		goto_ins = alloc_instruction(OP_COMPUTEDGOTO, 0);
-		use_pseudo(pseudo, &goto_ins->target);
+		use_pseudo(goto_ins, pseudo, &goto_ins->target);
 		add_one_insn(ep, goto_ins);
 
 		FOR_EACH_PTR(stmt->target_list, sym) {
@@ -1956,7 +1958,7 @@ pseudo_t linearize_statement(struct entr
 			break;
 
 		switch_ins = alloc_instruction(OP_SWITCH, 0);
-		use_pseudo(pseudo, &switch_ins->cond);
+		use_pseudo(switch_ins, pseudo, &switch_ins->cond);
 		add_one_insn(ep, switch_ins);
 		finish_block(ep);
 
@@ -2086,7 +2088,7 @@ static struct entrypoint *linearize_fn(s
 		struct instruction *insn = alloc_typed_instruction(OP_RET, ret_type);
 
 		if (type_size(ret_type) > 0)
-			use_pseudo(result, &insn->src);
+			use_pseudo(insn, result, &insn->src);
 		add_one_insn(ep, insn);
 	}
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 3] Add instruction to pseudo user tracking.
Date: Wed, 17 Jan 2007 04:48:21 +0000
Message-ID: <45ADAA95.4010202 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig27B1237A61A6E700918B985C
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> The current way of tracking pseudo register user is by
> keeping a list of the address of the pseudo_t member.
> This address can be in part of the instruction member, the
> worse case is in the argument list of the call instruction.
>=20
> As the comment for address_taken() said, using the container
> to get instruction pointer is wrong. It use to work with instruction
> that relate to symbol address. But that is not true any more. Even
> worse, it is very hard to track the pseudo usage other than symbol
> address. The only reason symbol address used to works for call instruct=
ion
> is because call instruction did not directly use the symbol address.
>=20
> I bit the bullet and just add the instruction pointer to pair with
> the pseudo user pointer. So it will work with the case that the
> user instruction is call as well.

Good call; merged.  Thanks.

- Josh Triplett



--------------enig27B1237A61A6E700918B985C
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFraqVGJuZRtD+evsRAlh0AJ9Un+x/psiHx4lDXdtvxjeM80DDSACeIG7X
kGoOPIJ1IUZ5TVPtmqAVO8Q=
=ydMI
-----END PGP SIGNATURE-----

--------------enig27B1237A61A6E700918B985C--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/4] add c2xml program ===

From: Rob Taylor <rob.taylor@codethink.co.uk>
To: Unknown
Subject: [PATCH 4/4] add c2xml program
Date: Mon, 2 Jul 2007 13:27:46 +0100
Message-ID: 
--------------------
Adds new c2xml program which dumps out the parse tree for a given file as well formed xml. A DTD for the format is included as parse.dtd.

Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
---
 Makefile  |   15 +++
 c2xml.c   |  324 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 parse.dtd |   48 +++++++++
 3 files changed, 387 insertions(+), 0 deletions(-)
 create mode 100644 c2xml.c
 create mode 100644 parse.dtd

diff --git a/Makefile b/Makefile
index 039fe38..67da31f 100644
--- a/Makefile
+++ b/Makefile
@@ -7,6 +7,8 @@ CFLAGS=-O -g -Wall -Wwrite-strings -fpic
 LDFLAGS=-g
 AR=ar
 
+HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 && echo 'yes')
+
 #
 # For debugging, uncomment the next one
 #
@@ -21,8 +23,15 @@ PKGCONFIGDIR=$(LIBDIR)/pkgconfig
 
 PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize example \
 	 test-unssa test-dissect ctags
+
+
 INST_PROGRAMS=sparse cgcc
 
+ifeq ($(HAVE_LIBXML),yes)
+PROGRAMS+=c2xml
+INST_PROGRAMS+=c2xml
+endif
+
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
 	  storage.h ptrlist.h dissect.h
@@ -107,6 +116,12 @@ test-dissect: test-dissect.o $(LIBS)
 ctags: ctags.o $(LIBS)
 	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+ifeq ($(HAVE_LIBXML),yes)
+c2xml: c2xml.c $(LIBS) $(LIB_H)
+	$(CC) $(LDFLAGS) `pkg-config --cflags --libs libxml-2.0` -o $@ $< $(LIBS)
+
+endif
+
 $(LIB_FILE): $(LIB_OBJS)
 	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)
 
diff --git a/c2xml.c b/c2xml.c
new file mode 100644
index 0000000..25d1c40
--- /dev/null
+++ b/c2xml.c
@@ -0,0 +1,324 @@
+/*
+ * Sparse c2xml
+ *
+ * Dumps the parse tree as an xml document
+ *
+ * Copyright (C) 2007 Rob Taylor
+ *
+ * Licensed under the Open Software License version 1.1
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+
+#include "parse.h"
+#include "scope.h"
+#include "symbol.h"
+
+xmlDocPtr doc = NULL;       /* document pointer */
+xmlNodePtr root_node = NULL;/* root node pointer */
+xmlDtdPtr dtd = NULL;       /* DTD pointer */
+xmlNsPtr ns = NULL;         /* namespace pointer */
+int idcount = 0;
+
+static struct symbol_list *taglist = NULL;
+
+static void examine_symbol(struct symbol *sym, xmlNodePtr node);
+
+static xmlAttrPtr newNumProp(xmlNodePtr node, const xmlChar * name, int value)
+{
+	char buf[256];
+	snprintf(buf, 256, "%d", value);
+	return xmlNewProp(node, name, buf);
+}
+
+static xmlAttrPtr newIdProp(xmlNodePtr node, const xmlChar * name, unsigned int id)
+{
+	char buf[256];
+	snprintf(buf, 256, "_%d", id);
+	return xmlNewProp(node, name, buf);
+}
+
+static xmlNodePtr new_sym_node(struct symbol *sym, const char *name, xmlNodePtr parent)
+{
+	xmlNodePtr node;
+	const char *ident = show_ident(sym->ident);
+
+	assert(name != NULL);
+	assert(sym != NULL);
+	assert(parent != NULL);
+
+	node = xmlNewChild(parent, NULL, "symbol", NULL);
+
+	xmlNewProp(node, "type",  name);
+
+	newIdProp(node, "id", idcount);
+
+	if (sym->ident && ident)
+		xmlNewProp(node, "ident", ident);
+	xmlNewProp(node, "file", stream_name(sym->pos.stream));
+
+	newNumProp(node, "start-line", sym->pos.line);
+	newNumProp(node, "start-col", sym->pos.pos);
+
+	if (sym->endpos.type) {
+		newNumProp(node, "end-line", sym->endpos.line);
+		newNumProp(node, "end-col", sym->endpos.pos);
+		if (sym->pos.stream != sym->endpos.stream)
+			xmlNewProp(node, "end-file", stream_name(sym->endpos.stream));
+        }
+	sym->aux = node;
+
+	idcount++;
+
+	return node;
+}
+
+static inline void examine_members(struct symbol_list *list, xmlNodePtr node)
+{
+	struct symbol *sym;
+	xmlNodePtr child;
+	char buf[256];
+
+	FOR_EACH_PTR(list, sym) {
+		examine_symbol(sym, node);
+	} END_FOR_EACH_PTR(sym);
+}
+
+static void examine_modifiers(struct symbol *sym, xmlNodePtr node)
+{
+	const char *modifiers[] = {
+			"auto",
+			"register",
+			"static",
+			"extern",
+			"const",
+			"volatile",
+			"signed",
+			"unsigned",
+			"char",
+			"short",
+			"long",
+			"long-long",
+			"typedef",
+			NULL,
+			NULL,
+			NULL,
+			NULL,
+			NULL,
+			"inline",
+			"addressable",
+			"nocast",
+			"noderef",
+			"accessed",
+			"toplevel",
+			"label",
+			"assigned",
+			"type-type",
+			"safe",
+			"user-type",
+			"force",
+			"explicitly-signed",
+			"bitwise"};
+
+	int i;
+
+	if (sym->namespace != NS_SYMBOL)
+		return;
+
+	/*iterate over the 32 bit bitfield*/
+	for (i=0; i < 32; i++) {
+		if ((sym->ctype.modifiers & 1<<i) && modifiers[i])
+			xmlNewProp(node, modifiers[i], "1");
+	}
+}
+
+static void
+examine_layout(struct symbol *sym, xmlNodePtr node)
+{
+	char buf[256];
+
+	examine_symbol_type(sym);
+
+	newNumProp(node, "bit-size", sym->bit_size);
+	newNumProp(node, "alignment", sym->ctype.alignment);
+	newNumProp(node, "offset", sym->offset);
+	if (is_bitfield_type(sym)) {
+		newNumProp(node, "bit-offset", sym->bit_offset);
+	}
+}
+
+static void examine_symbol(struct symbol *sym, xmlNodePtr node)
+{
+	xmlNodePtr child = NULL;
+	const char *base;
+	int array_size;
+	char buf[256];
+
+	if (!sym)
+		return;
+	if (sym->aux)		/*already visited */
+		return;
+
+	if (sym->ident && sym->ident->reserved)
+		return;
+
+	child = new_sym_node(sym, get_type_name(sym->type), node);
+	examine_modifiers(sym, child);
+	examine_layout(sym, child);
+
+	if (sym->ctype.base_type) {
+		if ((base = builtin_typename(sym->ctype.base_type)) == NULL) {
+			if (!sym->ctype.base_type->aux) {
+				examine_symbol(sym->ctype.base_type, root_node);
+			}
+			xmlNewProp(child, "base-type", 
+				xmlGetProp((xmlNodePtr)sym->ctype.base_type->aux, "id"));
+		} else {
+			xmlNewProp(child, "base-type-builtin", base);
+		}
+	}
+	if (sym->array_size) {
+		/* TODO: modify get_expression_value to give error return */
+		array_size = get_expression_value(sym->array_size);
+		newNumProp(child, "array-size", array_size);
+	}
+
+
+	switch (sym->type) {
+	case SYM_STRUCT:
+	case SYM_UNION:
+		examine_members(sym->symbol_list, child);
+		break;
+	case SYM_FN:
+		examine_members(sym->arguments, child);
+		break;
+	case SYM_UNINITIALIZED:
+		xmlNewProp(child, "base-type-builtin", builtin_typename(sym));
+		break;
+	}
+	return;
+}
+
+static struct position *get_expansion_end (struct token *token)
+{
+	struct token *p1, *p2;
+
+	for (p1=NULL, p2=NULL;
+	     !eof_token(token);
+	     p2 = p1, p1 = token, token = token->next);
+
+	if (p2)
+		return &(p2->pos);
+	else
+		return NULL;
+}
+
+static void examine_macro(struct symbol *sym, xmlNodePtr node)
+{
+	xmlNodePtr child;
+	struct position *pos;
+	char buf[256];
+
+	/* this should probably go in the main codebase*/
+	pos = get_expansion_end(sym->expansion);
+	if (pos)
+		sym->endpos = *pos;
+	else
+		sym->endpos = sym->pos;
+
+	child = new_sym_node(sym, "macro", node);
+}
+
+static void examine_namespace(struct symbol *sym)
+{
+	xmlChar *namespace_type = NULL;
+
+	if (sym->ident && sym->ident->reserved)
+		return;
+
+	switch(sym->namespace) {
+	case NS_MACRO:
+		examine_macro(sym, root_node);
+		break;
+	case NS_TYPEDEF:
+	case NS_STRUCT:
+	case NS_SYMBOL:
+		examine_symbol(sym, root_node);
+		break;
+	case NS_NONE:
+	case NS_LABEL:
+	case NS_ITERATOR:
+	case NS_UNDEF:
+	case NS_PREPROCESSOR:
+	case NS_KEYWORD:
+		break;
+	default:
+		die("Unrecognised namespace type %d",sym->namespace);
+	}
+
+}
+
+static int get_stream_id (const char *name)
+{
+	int i;
+	for (i=0; i<input_stream_nr; i++) {
+		if (strcmp(name, stream_name(i))==0)
+			return i;
+	}
+	return -1;
+}
+
+static inline void examine_symbol_list(const char *file, struct symbol_list *list)
+{
+	struct symbol *sym;
+	int stream_id = get_stream_id (file);
+
+	if (!list)
+		return;
+	FOR_EACH_PTR(list, sym) {
+		if (sym->pos.stream == stream_id)
+			examine_namespace(sym);
+	} END_FOR_EACH_PTR(sym);
+}
+
+int main(int argc, char **argv)
+{
+	struct string_list *filelist = NULL;
+	struct symbol_list *symlist = NULL;
+	char *file;
+
+	doc = xmlNewDoc("1.0");
+	root_node = xmlNewNode(NULL, "parse");
+	xmlDocSetRootElement(doc, root_node);
+
+/* - A DTD is probably unnecessary for something like this
+ 
+	dtd = xmlCreateIntSubset(doc, "parse", "http://www.kernel.org/pub/software/devel/sparse/parse.dtd" NULL, "parse.dtd");
+
+	ns = xmlNewNs (root_node, "http://www.kernel.org/pub/software/devel/sparse/parse.dtd", NULL);
+
+	xmlSetNs(root_node, ns);
+*/
+	symlist = sparse_initialize(argc, argv, &filelist);
+
+	FOR_EACH_PTR_NOTAG(filelist, file) {
+		examine_symbol_list(file, symlist);
+		sparse_keep_tokens(file);
+		examine_symbol_list(file, file_scope->symbols);
+		examine_symbol_list(file, global_scope->symbols);
+	} END_FOR_EACH_PTR_NOTAG(file);
+
+
+	xmlSaveFormatFileEnc("-", doc, "UTF-8", 1);
+	xmlFreeDoc(doc);
+	xmlCleanupParser();
+
+	return 0;
+}
+
diff --git a/parse.dtd b/parse.dtd
new file mode 100644
index 0000000..0cbd1b4
--- /dev/null
+++ b/parse.dtd
@@ -0,0 +1,48 @@
+<!ELEMENT parse (symbol+) >
+
+<!ELEMENT symbol (symbol*) >
+
+<!ATTLIST symbol type (uninitialized|preprocessor|basetype|node|pointer|function|array|struct|union|enum|typedef|typeof|member|bitfield|label|restrict|fouled|keyword|bad) #REQUIRED
+                 id ID #REQUIRED
+		 file CDATA #REQUIRED
+		 start CDATA #REQUIRED
+		 end CDATA #IMPLIED
+
+		 ident CDATA #IMPLIED
+		 base-type IDREF #IMPLIED
+		 base-type-builtin (char|signed char|unsigned char|short|signed short|unsigned short|int|signed int|unsigned int|signed long|long|unsigned long|long long|signed long long|unsigned long long|void|bool|string|float|double|long double|incomplete type|abstract int|abstract fp|label type|bad type) #IMPLIED
+
+		 array-size CDATA #IMPLIED
+
+		 bit-size CDATA #IMPLIED
+		 alignment CDATA #IMPLIED
+		 offset CDATA #IMPLIED
+		 bit-offset CDATA #IMPLIED
+
+		 auto (0|1) #IMPLIED
+		 register (0|1) #IMPLIED
+		 static (0|1) #IMPLIED
+		 extern (0|1) #IMPLIED
+		 const (0|1) #IMPLIED
+		 volatile (0|1) #IMPLIED
+		 signed (0|1) #IMPLIED
+		 unsigned (0|1) #IMPLIED
+		 char (0|1) #IMPLIED
+		 short (0|1) #IMPLIED
+		 long (0|1) #IMPLIED
+		 long-long (0|1) #IMPLIED
+		 typedef (0|1) #IMPLIED
+		 inline (0|1) #IMPLIED
+		 addressable (0|1) #IMPLIED
+		 nocast (0|1) #IMPLIED
+		 noderef (0|1) #IMPLIED
+		 accessed (0|1) #IMPLIED
+		 toplevel (0|1) #IMPLIED
+		 label (0|1) #IMPLIED
+		 assigned (0|1) #IMPLIED
+		 type-type (0|1) #IMPLIED
+		 safe (0|1) #IMPLIED
+		 usertype (0|1) #IMPLIED
+		 force (0|1) #IMPLIED
+		 explicitly-signed (0|1) #IMPLIED
+		 bitwise (0|1) #IMPLIED >
-- 
1.5.2-rc3.GIT


--------------040700010305000000020101--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] Fix an __attribute__() parsing error ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: [PATCH 4/5] Fix an __attribute__() parsing error
Date: Tue, 22 May 2007 18:11:47 +0000
Message-ID: <46533263.3010108 () ramsay1 ! demon ! co ! uk>
--------------------
This is a multi-part message in MIME format.
--------------070606050006040203050907
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit



Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>
---

When updating this patch from the 0.3 version, I made the (new) third parameter
KW_ATTRIBUTE only, rather than (KW_ATTRIBUTE | KW_ASM), since it did not seem
correct to allow an asm there; is that correct?

The test case for this was abstracted from an example in the "expat.h" header file.

$cat ape.c

typedef void (__attribute__((__cdecl__)) *FP)(void *u, const char *n);

void set_FP(void *cb, FP f);

$

  parse.c |    5 ++++-
  1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/parse.c b/parse.c
index db5c9e6..16a6dce 100644
--- a/parse.c
+++ b/parse.c
@@ -1149,7 +1149,10 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
  		if (token->special == '(') {
  			struct symbol *sym;
  			struct token *next = token->next;
-			int fn = (p && *p) || match_op(next, ')') || lookup_type(next);
+			int fn;
+
+			next = handle_attributes(next, ctype, KW_ATTRIBUTE);
+			fn = (p && *p) || match_op(next, ')') || lookup_type(next);

  			if (!fn) {
  				struct symbol *base_type = ctype->base_type;
-- 
1.5.1


--------------070606050006040203050907
Content-Type: text/plain;
 name="ape.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="ape.c"


typedef void (__attribute__((__cdecl__)) *FP)(void *u, const char *n);

void set_FP(void *cb, FP f);


--------------070606050006040203050907--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 4/5] Fix an __attribute__() parsing error
Date: Tue, 22 May 2007 22:37:54 +0000
Message-ID: <465370C2.3010801 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigF4AFA16710DDD1873819C2F4
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Ramsay Jones wrote:
>=20
> When updating this patch from the 0.3 version, I made the (new) third p=
arameter
> KW_ATTRIBUTE only, rather than (KW_ATTRIBUTE | KW_ASM), since it did no=
t seem
> correct to allow an asm there; is that correct?

Correct; I don't think you can have an asm there.

> The test case for this was abstracted from an example in the "expat.h" =
header file.
>=20
> $cat ape.c
>=20
> typedef void (__attribute__((__cdecl__)) *FP)(void *u, const char *n);
>=20
> void set_FP(void *cb, FP f);

Applied.  I think you just made a Wine developer very happy.  Michael, th=
is
patch fixes the test case you provided for Wine; I applied your patch for=
 the
new test case.

Thanks, Ramsay!

- Josh Triplett



--------------enigF4AFA16710DDD1873819C2F4
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU3DCGJuZRtD+evsRAjpyAJ4poV1wOyx8Wlrieg7+hLBB8HrZ7ACcDhoS
3YI2EBgL5cihCFl2v9q6y4o=
=Cgr8
-----END PGP SIGNATURE-----

--------------enigF4AFA16710DDD1873819C2F4--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 4/5] Fix an __attribute__() parsing error
Date: Thu, 24 May 2007 15:27:32 +0000
Message-ID: <4655AEE4.5070808 () ramsay1 ! demon ! co ! uk>
--------------------
Josh Triplett wrote:
> Ramsay Jones wrote:
>> When updating this patch from the 0.3 version, I made the (new) third parameter
>> KW_ATTRIBUTE only, rather than (KW_ATTRIBUTE | KW_ASM), since it did not seem
>> correct to allow an asm there; is that correct?
> 
> Correct; I don't think you can have an asm there.
> 
OK, good.

>> The test case for this was abstracted from an example in the "expat.h" header file.
>>
>> $cat ape.c
>>
>> typedef void (__attribute__((__cdecl__)) *FP)(void *u, const char *n);
>>
>> void set_FP(void *cb, FP f);
> 
> Applied.  I think you just made a Wine developer very happy.  Michael, this
> patch fixes the test case you provided for Wine; I applied your patch for the
> new test case.
> 
> Thanks, Ramsay!
> 

My pleasure.

ATB,
Ramsay Jones

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 4/5] Fix an __attribute__() parsing error
Date: Thu, 24 May 2007 17:07:25 +0000
Message-ID: <4655C64D.4000704 () ramsay1 ! demon ! co ! uk>
--------------------
Michael Stefaniuc wrote:
> Josh Triplett wrote:
>> Ramsay Jones wrote:

>> Applied.  I think you just made a Wine developer very happy.  Michael, this
>> patch fixes the test case you provided for Wine; I applied your patch for the
>> new test case.
> Cool, thanks. Was just running a Wine build with cgcc when I have seen
> this so i've stopped it and run it again with the latest git checkout.
> And indeed it looks definitely better; the "error: too many errors"
> count went down from 1459 to 7.
> 
>> Thanks, Ramsay!
> Thanks indeed.

My pleasure; glad to be of help.

All the Best,

Ramsay Jones


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] Introduce top level parsing for asm parsing. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 4/5] Introduce top level parsing for asm parsing.
Date: Wed, 07 Mar 2007 10:09:29 +0000
Message-ID: <20070307100929.GE10577 () chrisli ! org>
--------------------

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/parse.h
===================================================================
Index: sparse/symbol.c
===================================================================
Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-03-07 00:03:18.000000000 -0800
+++ sparse/parse.c	2007-03-07 00:03:50.000000000 -0800
@@ -56,6 +56,7 @@ static struct token *parse_goto_statemen
 static struct token *parse_context_statement(struct token *token, struct statement *stmt);
 static struct token *parse_range_statement(struct token *token, struct statement *stmt);
 static struct token *parse_asm(struct token *token, struct statement *stmt);
+static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
 
 
 static struct symbol_op modifier_op = {
@@ -143,6 +144,7 @@ static struct symbol_op range_op = {
 
 static struct symbol_op asm_op = {
 	.statement = parse_asm,
+	.toplevel = toplevel_asm_declaration,
 };
 
 static struct init_keyword {
@@ -1977,8 +1979,11 @@ struct token *external_declaration(struc
 	int is_typedef;
 
 	/* Top-level inline asm? */
-	if (match_idents(token, &asm_ident, &__asm___ident, &__asm_ident, NULL))
-		return toplevel_asm_declaration(token, list);
+	if (token_type(token) == TOKEN_IDENT) {
+		struct symbol *s = lookup_keyword(token->ident, NS_KEYWORD);
+		if (s && s->op->toplevel)
+			return s->op->toplevel(token, list);
+	}
 
 	/* Parse declaration-specifiers, if any */
 	token = declaration_specifiers(token, &ctype, 0);
Index: sparse/symbol.h
===================================================================
--- sparse.orig/symbol.h	2007-03-07 00:03:18.000000000 -0800
+++ sparse/symbol.h	2007-03-07 00:03:20.000000000 -0800
@@ -93,6 +93,7 @@ struct symbol_op {
 	/* keywrods */
 	struct token *(*declarator)(struct token *token, struct ctype *ctype);
 	struct token *(*statement)(struct token *token, struct statement *stmt);
+	struct token *(*toplevel)(struct token *token, struct symbol_list **list);
 };	
 
 extern int expand_safe_p(struct expression *expr, int cost);
Index: sparse/lib.c
===================================================================
Index: sparse/ident-list.h
===================================================================
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/8] start cleaning type_difference() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 4/8] start cleaning type_difference()
Date: Fri, 13 Jul 2007 17:44:57 +0000
Message-ID: <E1I9PCL-0000EV-5G () ZenIV ! linux ! org ! uk>
--------------------

a) examine_fn_arguments() when comparing SYM_FN nodes; then
we won't need to try implementing argument adjustment as
part of the main loop.  SYM_ARRAY->SYM_PTR and SYM_FN/SYM_PTR
interactions go away (and we stop getting nonsense results
like "int * and int [1] are the same thing").  All callers
are already happy with that.

b) different structs or unions are incompatible.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |   34 +++++++++-------------------------
 1 files changed, 9 insertions(+), 25 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 88435da..91c7f74 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -619,6 +619,8 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *c
 	return ctype;
 }
 
+static void examine_fn_arguments(struct symbol *fn);
+
 const char * type_difference(struct symbol *target, struct symbol *source,
 	unsigned long target_mod_ignore, unsigned long source_mod_ignore)
 {
@@ -687,34 +689,14 @@ const char * type_difference(struct symbol *target, struct symbol *source,
 		/*
 		 * Pointers to functions compare as the function itself
 		 */
-		if (type1 == SYM_PTR && base1) {
+		if (type1 == SYM_PTR && base1)
 			base1 = examine_symbol_type(base1);
-			switch (base1->type) {
-			case SYM_FN:
-				type1 = SYM_FN;
-				target = base1;
-				base1 = base1->ctype.base_type;
-			default:
-				/* nothing */;
-			}
-		}
-		if (type2 == SYM_PTR && base2) {
-			base2 = examine_symbol_type(base2);
-			switch (base2->type) {
-			case SYM_FN:
-				type2 = SYM_FN;
-				source = base2;
-				base2 = base2->ctype.base_type;
-			default:
-				/* nothing */;
-			}
-		}
 
-		/* Arrays degenerate to pointers for type comparisons */
-		type1 = (type1 == SYM_ARRAY) ? SYM_PTR : type1;
-		type2 = (type2 == SYM_ARRAY) ? SYM_PTR : type2;
+		if (type2 == SYM_PTR && base2)
+			base2 = examine_symbol_type(base2);
 
-		if (type1 != type2 || type1 == SYM_RESTRICT)
+		if (type1 != type2 || type1 == SYM_RESTRICT ||
+		    type1 == SYM_UNION || type1 == SYM_STRUCT)
 			return "different base types";
 
 		/* Must be same address space to be comparable */
@@ -755,6 +737,8 @@ const char * type_difference(struct symbol *target, struct symbol *source,
 			struct symbol *arg1, *arg2;
 			if (base1->variadic != base2->variadic)
 				return "incompatible variadic arguments";
+			examine_fn_arguments(target);
+			examine_fn_arguments(source);
 			PREPARE_PTR_LIST(target->arguments, arg1);
 			PREPARE_PTR_LIST(source->arguments, arg2);
 			i = 1;
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4] Disable liveness "dead" instruction by default. ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 4] Disable liveness "dead" instruction by default.
Date: Wed, 28 Feb 2007 19:46:36 +0000
Message-ID: <45E5DC1C.4050000 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig91BF94D50E726FF54782326C
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> The liveness instruction take up about 10% of the bytecode bloat file.
> It is not very useful, it is duplicate information can be obtain
> from the def/user chain.
>=20
> This change disable the liveness instruction by default.
> The caller can track_pseudo_death() if needed.
>=20
> Signed-Off-By: Christopher Li <sparse@chrisli.org>

Good idea; applied.

- Josh Triplett



--------------enig91BF94D50E726FF54782326C
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD4DBQFF5dwcGJuZRtD+evsRAtPJAJj1v64DTHFxJezlLerOU9x5zGN+AJ42bjv5
bvktUlD+PdK86hX3/Gkq9g==
=fi2M
-----END PGP SIGNATURE-----

--------------enig91BF94D50E726FF54782326C--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4] Update usage chain for dead instruction ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 4] Update usage chain for dead instruction
Date: Wed, 17 Jan 2007 05:20:14 +0000
Message-ID: <45ADB20E.60002 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig150BFF8398D2B2AF37D85E2D
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> This patch address some of the dead instruction
> left in the usage chain.

Merged.

One minor style note:

> --- sparse.orig/simplify.c	2006-12-21 14:35:18.000000000 -0800
> +++ sparse/simplify.c	2006-12-21 14:35:55.000000000 -0800
> @@ -217,6 +217,11 @@ void kill_instruction(struct instruction
>  		kill_use(&insn->src2);
>  		kill_use(&insn->src3);
>  		return;
> +	case OP_BR:
> +		insn->bb =3D NULL;
> +		repeat_phase |=3D REPEAT_CSE;
> +		if (insn->cond)
> +			kill_use(&insn->cond);
>  	}
>  }

Despite redundancy, please include return or break statements in the last=
 case
of a switch, to make modifications less error-prone.

- Josh Triplett


--------------enig150BFF8398D2B2AF37D85E2D
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFrbIOGJuZRtD+evsRAuDAAJ9BQ8FjN7hC4LJg6pkBYNC6yR4g4wCfQ1Cl
WUJlJNp9GzzqbYlmeQGoawY=
=5x0m
-----END PGP SIGNATURE-----

--------------enig150BFF8398D2B2AF37D85E2D--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5] Add annotation for inline function call. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 5] Add annotation for inline function call.
Date: Sat, 10 Feb 2007 00:19:12 +0000
Message-ID: <20070210001912.GD20644 () chrisli ! org>
--------------------

Sparse inline function body at evaluation. It very hard
to find out the original function call. This change try
to preserved the original call is preserved as annotation.

Index: sparse/parse.h
===================================================================
--- sparse.orig/parse.h	2007-02-01 00:55:07.000000000 -0800
+++ sparse/parse.h	2007-02-02 01:24:11.000000000 -0800
@@ -55,6 +55,8 @@ struct statement {
 		struct /* compound_struct */ {
 			struct statement_list *stmts;
 			struct symbol *ret;
+			struct symbol *inline_fn;
+			struct statement *args;
 		};
 		struct /* labeled_struct */ {
 			struct symbol *label_identifier;
Index: sparse/expression.h
===================================================================
Index: sparse/evaluate.c
===================================================================
--- sparse.orig/evaluate.c	2007-02-01 00:55:07.000000000 -0800
+++ sparse/evaluate.c	2007-02-02 01:24:11.000000000 -0800
@@ -2791,7 +2791,7 @@ struct symbol *evaluate_statement(struct
 		 * Then, evaluate each statement, making the type of the
 		 * compound statement be the type of the last statement
 		 */
-		type = NULL;
+		type = evaluate_statement(stmt->args);
 		FOR_EACH_PTR(stmt->stmts, s) {
 			type = evaluate_statement(s);
 		} END_FOR_EACH_PTR(s);
Index: sparse/inline.c
===================================================================
--- sparse.orig/inline.c	2007-02-01 00:55:07.000000000 -0800
+++ sparse/inline.c	2007-02-02 01:24:11.000000000 -0800
@@ -443,8 +443,9 @@ void copy_statement(struct statement *sr
 	FOR_EACH_PTR(src->stmts, stmt) {
 		add_statement(&dst->stmts, copy_one_statement(stmt));
 	} END_FOR_EACH_PTR(stmt);
-
+	dst->args = copy_one_statement(src->args);
 	dst->ret = copy_symbol(src->pos, src->ret);
+	dst->inline_fn = src->inline_fn;
 }
 
 static struct symbol *create_copy_symbol(struct symbol *orig)
@@ -489,6 +490,7 @@ int inline_function(struct expression *e
 	}
 	if (fn->expanding)
 		return 0;
+
 	fn->expanding = 1;
 
 	name_list = fn->arguments;
@@ -517,13 +519,14 @@ int inline_function(struct expression *e
 	} END_FOR_EACH_PTR(arg);
 	FINISH_PTR_LIST(name);
 
+	copy_statement(fn->inline_stmt, stmt);
+
 	if (arg_decl) {
 		struct statement *decl = alloc_statement(expr->pos, STMT_DECLARATION);
 		decl->declaration = arg_decl;
-		add_statement(&stmt->stmts, decl);
+		stmt->args = decl;
 	}
-
-	copy_statement(fn->inline_stmt, stmt);
+	stmt->inline_fn = sym;
 
 	unset_replace_list(fn_symbol_list);
 
Index: sparse/expand.c
===================================================================
--- sparse.orig/expand.c	2007-02-01 00:55:07.000000000 -0800
+++ sparse/expand.c	2007-02-02 01:24:11.000000000 -0800
@@ -1053,9 +1053,9 @@ static int expand_compound(struct statem
 	if (stmt->ret)
 		expand_symbol(stmt->ret);
 
-	cost = 0;
-	last = NULL;
-	statements = 0;
+	last = stmt->args;
+	cost = expand_statement(last);
+	statements = last != NULL;
 	FOR_EACH_PTR(stmt->stmts, s) {
 		statements++;
 		last = s;
Index: sparse/show-parse.c
===================================================================
--- sparse.orig/show-parse.c	2007-02-01 00:55:07.000000000 -0800
+++ sparse/show-parse.c	2007-02-02 01:24:11.000000000 -0800
@@ -485,6 +485,10 @@ int show_statement(struct statement *stm
 		struct statement *s;
 		int last = 0;
 
+		if (stmt->inline_fn) {
+			show_statement(stmt->args);
+			printf("\tbegin_inline \t%s\n", show_ident(stmt->inline_fn->ident));
+		}
 		FOR_EACH_PTR(stmt->stmts, s) {
 			last = show_statement(s);
 		} END_FOR_EACH_PTR(s);
@@ -496,6 +500,8 @@ int show_statement(struct statement *stm
 			last = new_pseudo();
 			printf("\tld.%d\t\tv%d,[v%d]\n", bits, last, addr);
 		}
+		if (stmt->inline_fn)
+			printf("\tend_inlined\t%s\n", show_ident(stmt->inline_fn->ident));
 		return last;
 	}
 
Index: sparse/linearize.h
===================================================================
--- sparse.orig/linearize.h	2007-02-01 00:55:07.000000000 -0800
+++ sparse/linearize.h	2007-02-02 01:24:11.000000000 -0800
@@ -196,6 +196,7 @@ enum opcode {
 	OP_SCAST,
 	OP_FPCAST,
 	OP_PTRCAST,
+	OP_INLINED_CALL,
 	OP_CALL,
 	OP_VANEXT,
 	OP_VAARG,
Index: sparse/linearize.c
===================================================================
--- sparse.orig/linearize.c	2007-02-02 01:23:59.000000000 -0800
+++ sparse/linearize.c	2007-02-02 01:24:11.000000000 -0800
@@ -27,11 +27,11 @@ pseudo_t linearize_expression(struct ent
 
 static pseudo_t add_binary_op(struct entrypoint *ep, struct symbol *ctype, int op, pseudo_t left, pseudo_t right);
 static pseudo_t add_setval(struct entrypoint *ep, struct symbol *ctype, struct expression *val);
-static void linearize_one_symbol(struct entrypoint *ep, struct symbol *sym);
+static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym);
 
 struct access_data;
 static pseudo_t add_load(struct entrypoint *ep, struct access_data *);
-pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *);
+static pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *);
 
 struct pseudo void_pseudo = {};
 
@@ -226,6 +226,7 @@ static const char *opcodes[] = {
 	[OP_SCAST] = "scast",
 	[OP_FPCAST] = "fpcast",
 	[OP_PTRCAST] = "ptrcast",
+	[OP_INLINED_CALL] = "# call",
 	[OP_CALL] = "call",
 	[OP_VANEXT] = "va_next",
 	[OP_VAARG] = "va_arg",
@@ -399,6 +400,7 @@ const char *show_instruction(struct inst
 	case OP_STORE: case OP_SNOP:
 		buf += sprintf(buf, "%s -> %d[%s]", show_pseudo(insn->target), insn->offset, show_pseudo(insn->src));
 		break;
+	case OP_INLINED_CALL:
 	case OP_CALL: {
 		struct pseudo *arg;
 		if (insn->target && insn->target != VOID)
@@ -1487,7 +1489,7 @@ static pseudo_t linearize_position(struc
 	return linearize_initializer(ep, init_expr, ad);
 }
 
-pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *ad)
+static pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *ad)
 {
 	switch (initializer->type) {
 	case EXPR_INITIALIZER: {
@@ -1505,6 +1507,7 @@ pseudo_t linearize_initializer(struct en
 		ad->source_type = base_type(initializer->ctype);
 		ad->result_type = initializer->ctype;
 		linearize_store_gen(ep, value, ad);
+		return value;
 	}
 	}
 
@@ -1595,21 +1598,23 @@ pseudo_t linearize_expression(struct ent
 	return VOID;
 }
 
-static void linearize_one_symbol(struct entrypoint *ep, struct symbol *sym)
+static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym)
 {
 	struct access_data ad = { NULL, };
+	pseudo_t value;
 
 	if (!sym || !sym->initializer || sym->initialized)
-		return;
+		return VOID;
 
 	/* We need to output these puppies some day too.. */
 	if (sym->ctype.modifiers & (MOD_STATIC | MOD_TOPLEVEL))
-		return;
+		return VOID;
 
 	sym->initialized = 1;
 	ad.address = symbol_pseudo(ep, sym);
-	linearize_initializer(ep, sym->initializer, &ad);
+	value = linearize_initializer(ep, sym->initializer, &ad);
 	finish_address_gen(ep, &ad);
+	return value;
 }
 
 static pseudo_t linearize_compound_statement(struct entrypoint *ep, struct statement *stmt)
@@ -1637,6 +1642,29 @@ static pseudo_t linearize_compound_state
 		}
 		return phi_node->target;
 	}
+
+	return pseudo;
+}
+
+static pseudo_t linearize_inlined_call(struct entrypoint *ep, struct statement *stmt)
+{
+	struct instruction *insn = alloc_instruction(OP_INLINED_CALL, 0);
+	struct statement *args = stmt->args;
+	pseudo_t pseudo;
+
+	if (args) {
+		struct symbol *sym;
+
+		concat_symbol_list(args->declaration, &ep->syms);
+		FOR_EACH_PTR(args->declaration, sym) {
+			pseudo_t value = linearize_one_symbol(ep, sym);
+			use_pseudo(insn, value, add_pseudo(&insn->arguments, value));
+		} END_FOR_EACH_PTR(sym);
+	}
+
+	insn->target = pseudo = linearize_compound_statement(ep, stmt);
+	use_pseudo(insn, symbol_pseudo(ep, stmt->inline_fn), &insn->func);
+	add_one_insn(ep, insn);
 	return pseudo;
 }
 
@@ -1920,6 +1948,8 @@ pseudo_t linearize_statement(struct entr
 	}
 
 	case STMT_COMPOUND:
+		if (stmt->inline_fn)
+			return linearize_inlined_call(ep, stmt);
 		return linearize_compound_statement(ep, stmt);
 
 	/*
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5] Adding the NULL pointer checker. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 5] Adding the NULL pointer checker.
Date: Wed, 17 Jan 2007 02:41:30 +0000
Message-ID: <20070117024130.GH962 () chrisli ! org>
--------------------
Oops, this should be [PATCH 6] instead.

Chris

On Tue, Jan 16, 2007 at 06:39:18PM -0800, Christopher Li wrote:
> 
> Changelog:
>  - Using pseudo user list to find out the calling function.
>    It doesn't scan instruction one by one any more.
> 
> This patch add the kmalloc null pointer checking. It also
> try to track the double free as well. It knows a few kmalloc like
> functions and kfree etc.
> 
> The interrupt checking is just a toy. Without cross function checking,
> it is way too many false positive. 
> 
> Signed-off-by: Christopher Li<sparse@chrisli.org>
> 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 5] Adding the NULL pointer checker.
Date: Sat, 27 Jan 2007 08:20:53 +0000
Message-ID: <45BB0B65.7060403 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig41EEDC462E39A3E0F388E1D6
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Somehow I managed to compose and not send these comments; sorry.

Christopher Li wrote:
> This patch add the kmalloc null pointer checking. It also
> try to track the double free as well. It knows a few kmalloc like
> functions and kfree etc.

Overall, this patch looks good, and I really like the idea of doing mallo=
c
checking with Sparse.  I have a few comments, interspersed below.

The main issue, however: I can't seem to get it to generate any warnings.=

I've tried running it on the following program, and it produces nothing:

#include <stdlib.h>
int main(int argc, char *argv[])
{
	int *i =3D malloc(sizeof(int));
	return *i;
}

Shouldn't this program provoke some warnings?  And could you supply some
test code which does provoke warnings?

Also, you need a new warning switch to control each of these two checks.

> The interrupt checking is just a toy. Without cross function checking,
> it is way too many false positive.=20

I don't mind including it in an early stage, defaulting to off.

> --- sparse.orig/checker.h	2007-01-16 11:13:28.000000000 -0800
> +++ sparse/checker.h	2007-01-16 11:57:29.000000000 -0800
> @@ -0,0 +1,108 @@
> +#ifndef _CHECKER_H_
> +#define _CHECKER_H_
> +
> +struct blob {
> +	int len;

size_t len, please.

> +	unsigned char data[0];
> +};
[...]
> --- sparse.orig/expand.c	2007-01-16 11:13:18.000000000 -0800
> +++ sparse/expand.c	2007-01-16 11:13:28.000000000 -0800
> @@ -29,8 +29,8 @@
>  /* Random cost numbers */
>  #define SIDE_EFFECTS 10000	/* The expression has side effects */
>  #define UNSAFE 100		/* The expression may be "infinitely costly" due t=
o exceptions */
> -#define SELECT_COST 20		/* Cut-off for turning a conditional into a se=
lect */
> -#define BRANCH_COST 10		/* Cost of a conditional branch */
> +#define SELECT_COST 0		/* Cut-off for turning a conditional into a sel=
ect */
> +#define BRANCH_COST 0		/* Cost of a conditional branch */

OK, I *think* that won't cause any harm.

> --- sparse.orig/sparse.c	2007-01-16 11:13:18.000000000 -0800
> +++ sparse/sparse.c	2007-01-16 11:13:28.000000000 -0800
>  };
[...]
>  static void check_call_instruction(struct instruction *insn)
>  {
>  	pseudo_t fn =3D insn->func;
> -	struct ident *ident;
> -	static const struct checkfn check_fn[] =3D {
> +	static const struct checkfn *entry, check_fn[] =3D {
>  		{ &memset_ident, check_memset },
>  		{ &memcpy_ident, check_memcpy },
>  		{ &copy_to_user_ident, check_ctu },
>  		{ &copy_from_user_ident, check_cfu },
> +		{ NULL },
>  	};
> -	int i;
> =20
>  	if (fn->type !=3D PSEUDO_SYM)
>  		return;
> -	ident =3D fn->sym->ident;
> -	if (!ident)
> -		return;
> -	for (i =3D 0; i < sizeof(check_fn)/sizeof(struct checkfn) ; i++) {
> -		if (check_fn[i].id !=3D ident)
> -			continue;
> -		check_fn[i].check(insn);
> -		break;
> -	}
> +	entry =3D match_function(check_fn, fn->sym);
> +	if (entry)
> +		entry->check(insn);
>  }

Why this change, to use a NULL-terminated iteration rather than a counted=

iteration?  I don't see the benefit.

> @@ -211,14 +213,19 @@ enum opcode {
> =20
>  	/* Needed to translate SSA back to normal form */
>  	OP_COPY,
> +	OP_LAST,
>  };

Hmmm...

> --- sparse.orig/check-interrupt.c	2007-01-16 11:13:28.000000000 -0800
> +++ sparse/check-interrupt.c	2007-01-16 11:13:28.000000000 -0800
[...]
> +enum {
> +	OP_CLI =3D OP_LAST,
> +	OP_STI,
> +	OP_RESTORE,
> +};

Ouch.  This will break if anything else attempts to extend the opcode lis=
t
in the same way.

Have you considered attempting to express interrupts as another form of
context?  Now that the basic framework for multiple types of context exis=
ts,
perhaps you could treat interrupts as another kind of context?

> +static inline void scan_interrupt_insn(struct entrypoint *ep)
> +{
> +	struct basic_block *bb;
> +	struct instruction *insn;
> +
> +	FOR_EACH_PTR(ep->bbs, bb) {
> +		struct bb_state *bbs =3D bb->state;
> +		FOR_EACH_PTR(bb->insns, insn) {
> +			if (!insn->bb)
> +				continue;
> +			if (insn->opcode =3D=3D OP_RET) {
> +				add_instruction(&bbs->insns, insn);
> +				continue;
> +			}
> +			else if (insn->opcode !=3D OP_ASM)
> +				continue;
> +			if (!strcmp(insn->string, "cli"))
> +				add_instruction(&bbs->insns, checker_instruction(insn, OP_CLI, NUL=
L));
> +			else if (!strcmp(insn->string, "sti"))
> +				add_instruction(&bbs->insns, checker_instruction(insn, OP_STI, NUL=
L));
> +			else if (!strcmp(insn->string, "pushl %0 ; popfl"))
> +				add_instruction(&bbs->insns, checker_instruction(insn, OP_RESTORE,=
 NULL));

Ouch.  x86-specific, and specific to the exact strings from the Linux inl=
ine
assembly.

We really need the metalanguage part of Engler's paper that you reference=
d.
This kind of thing seems reasonable for random scripts written to check
particular problems and interpreted by Sparse, but not for code going int=
o
Sparse itself.

Also, modifying the instructions in bbs seems like it would conflict with=
 the
use of other checkers, due to the enum collision described above.

[...]
> +enum {
> +	OP_DEF_PTR =3D OP_LAST,
> +	OP_USE_PTR,
> +	OP_FREE_PTR
> +};

Same problem as above.

> +static inline void execute_pointer_usage(struct instruction *insn)
> +{
> +	if (reg_state(insn->src) & PTR_NULL)
> +		warning(insn->pos, "funcion %s possible using NULL pointer",
> +			show_ident(insn->bb->ep->name->ident));

s/funcion/function/; s/possible/possibly/.

> +	if (reg_state(insn->src) & PTR_FREE)
> +		warning(insn->pos, "funcion %s possible using pointer after free",
> +			show_ident(insn->bb->ep->name->ident));

Likewise.


> +static inline void execute_pointer_free(struct instruction *insn)
> +{
> +	if (reg_state(insn->src) & PTR_FREE)
> +		warning(insn->pos, "funcion %s possible double free pointer",
> +			show_ident(insn->bb->ep->name->ident));

Likewise.

> +	if (bbs->branch) {
> +		struct instruction *br =3D bbs->branch;
> +		unsigned char orig =3D reg_state(br->cond);
> +		check_bb_cond(br->bb_true, br->cond, orig & ~PTR_NULL);
> +		check_bb_cond(br->bb_false, br->cond, orig & ~PTR_NOTNULL);

*Awesome*.

Something like this might work for conditional locking primitives, too.

> +void init_check_null_ptr(void)
> +{
> +	static const char *malloc_name[] =3D {
> +		"malloc",
> +		"__kmalloc",
> +		"__kmalloc_node",
> +		"__kzalloc",
> +		"kmem_cache_alloc",
> +		"kmem_cache_zalloc",
> +		"kmem_cache_alloc_node",
> +		"vmalloc",
> +		"vmalloc_user",
> +		"vmalloc_node",
> +		"vmalloc_32",
> +		"vmalloc_32_user",
> +		"__vmalloc",
> +		NULL,
> +	};
> +	static const char *free_name[] =3D {
> +		"free",
> +		"kfree",
> +		"kmem_cache_free",
> +		"vfree",
> +		NULL,
> +	};

Idea for future work (not for this patch): we might want to make sure tha=
t
memory allocated with a given malloc gets freed with a given free.

> +	static const char *noret[] =3D {
> +		"panic",
> +		NULL,
> +	};

We already have __attribute__((noreturn)); please use that rather than
matching against a list here.

- Josh Triplett


--------------enig41EEDC462E39A3E0F388E1D6
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFuwttGJuZRtD+evsRAgZsAJ48qwJoImhRVVlRqb1OXyGhUGfQAwCfQwaQ
eUSEJMC7+vFrQ3q1qzR4XrM=
=70hJ
-----END PGP SIGNATURE-----

--------------enig41EEDC462E39A3E0F388E1D6--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5] Update usage chain for dead instruction. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 5] Update usage chain for dead instruction.
Date: Wed, 17 Jan 2007 02:38:04 +0000
Message-ID: <20070117023804.GE962 () chrisli ! org>
--------------------

Branch like that:
br %c, 0x10, 0x10

Will be simplify and removed. But the usage information is not updated.

Signed-Off-By: Christopher Li<sparse@chrisli.org>

Index: sparse/flow.c
===================================================================
--- sparse.orig/flow.c	2006-12-21 20:48:07.000000000 -0800
+++ sparse/flow.c	2006-12-21 22:20:44.000000000 -0800
@@ -987,7 +987,7 @@ out:
 			replace_bb_in_list(&child->parents, bb, parent, 0);
 		} END_FOR_EACH_PTR(child);
 
-		delete_last_instruction(&parent->insns);
+		kill_instruction(delete_last_instruction(&parent->insns));
 		FOR_EACH_PTR(bb->insns, insn) {
 			if (insn->bb) {
 				assert(insn->bb == bb);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 5] Update usage chain for dead instruction.
Date: Wed, 17 Jan 2007 05:20:32 +0000
Message-ID: <45ADB220.8020509 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig6B6920FCF5B859177C83F691
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> Branch like that:
> br %c, 0x10, 0x10
>=20
> Will be simplify and removed. But the usage information is not updated.=


Merged.

- Josh Triplett



--------------enig6B6920FCF5B859177C83F691
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFrbIgGJuZRtD+evsRAi3tAJ9QvQeEqKA2QLnqnN8SfFo2HrP2lQCfezRy
sa/ASBJ4OMARl7GLR+M1/VY=
=VpVy
-----END PGP SIGNATURE-----

--------------enig6B6920FCF5B859177C83F691--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/8] fix the sanity check in evaluate_ptr_sub() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 6/8] fix the sanity check in evaluate_ptr_sub()
Date: Fri, 13 Jul 2007 17:45:17 +0000
Message-ID: <E1I9PCf-0000F5-5e () ZenIV ! linux ! org ! uk>
--------------------

We are checking the wrong thing - the arguments have already
degenerated, so we won't see SYM_FN there (or SYM_ARRAY, for
that matter).  That check should be done to the target of
pointer, not to the pointer itself and it should simply check
for SYM_FN - that's what we'll get there both from decayed
functions _and_ pointers to functions.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |   13 +++++++------
 1 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 44a4da4..8df2042 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -785,24 +785,25 @@ static struct symbol *evaluate_ptr_sub(struct expression *expr)
 	struct symbol *ltype, *rtype;
 	struct expression *l = expr->left;
 	struct expression *r = expr->right;
+	struct symbol *lbase, *rbase;
 
-	ltype = degenerate(l);
-	rtype = degenerate(r);
+	classify_type(degenerate(l), &ltype);
+	classify_type(degenerate(r), &rtype);
 
-	ctype = ltype;
+	lbase = get_base_type(ltype);
+	rbase = get_base_type(rtype);
 	typediff = type_difference(ltype, rtype, ~MOD_SIZE, ~MOD_SIZE);
 	if (typediff)
 		expression_error(expr, "subtraction of different types can't work (%s)", typediff);
-	examine_symbol_type(ctype);
 
+	ctype = lbase;
 	/* Figure out the base type we point to */
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
-	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
+	if (ctype->type == SYM_FN) {
 		expression_error(expr, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
-	ctype = get_base_type(ctype);
 
 	expr->ctype = ssize_t_ctype;
 	if (ctype->bit_size > bits_in_char) {
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6] Adding the malloc NULL pointer checker. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 6] Adding the malloc NULL pointer checker.
Date: Sat, 10 Feb 2007 00:20:19 +0000
Message-ID: <20070210002019.GE20644 () chrisli ! org>
--------------------

Changelog:
 - Using inline annotation.
 - Using pseudo user list to find out the calling function.
   It doesn't scan instruction one by one any more.

This patch add the kmalloc null pointer checking. It also
try to track the double free as well. It knows a few kmalloc like
functions and kfree etc.

Signed-off-by: Christopher Li<sparse@chrisli.org>

Index: sparse/blobhash.c
===================================================================
--- sparse.orig/blobhash.c	2007-02-06 03:34:46.000000000 -0800
+++ sparse/blobhash.c	2007-02-06 03:34:46.000000000 -0800
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2006 Christopher Li <sparse@chrisli.org>
+ * Copyright (C) 2003 Transmeta Corp.
+ *               2003 Linus Torvalds
+ *
+ *  Licensed under the Open Software License version 1.1
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "storage.h"
+#include "checker.h"
+
+/*
+ * steal from tokenize.c 
+ */
+#define BLOB_HASH_BITS (13)
+#define BLOB_HASH_SIZE (1<<BLOB_HASH_BITS)
+#define BLOB_HASH_MASK (BLOB_HASH_SIZE-1)
+
+#define blob_hash_init(c)		(c)
+#define blob_hash_add(oldhash,c)	((oldhash)*11 + (c))
+#define blob_hash_end(hash)		((((hash) >> BLOB_HASH_BITS) + (hash)) & BLOB_HASH_MASK)
+
+ALLOCATOR(blob, "pseudo state blob");
+ALLOCATOR(bb_state, "basic block state");
+ALLOCATOR(state, "one state");
+
+
+static struct blob_list *blob_hash_table[BLOB_HASH_SIZE];
+
+static unsigned long blob_hash(const unsigned char *data, int len)
+{
+	unsigned long hash;
+	const unsigned char *p = data;
+
+	hash = blob_hash_init(0);
+	while (len--) {
+		unsigned int i = *p++;
+		hash = blob_hash_add(hash, i);
+	}
+	return blob_hash_end(hash);
+}
+
+struct blob *lookup_blob(const unsigned char *data, int len)
+{
+	struct blob_list *list = blob_hash_table[blob_hash(data, len)];
+	struct blob *blob;
+
+	FOR_EACH_PTR(list, blob) {
+		if (blob->len == len && !memcmp(blob->data, data, len))
+			return blob;
+	} END_FOR_EACH_PTR(blob);
+	return NULL;
+}
+
+struct blob *create_hashed_blob(const unsigned char *data, int len)
+{
+	struct blob_list **list = blob_hash_table + blob_hash(data, len);
+	struct blob *blob;
+	FOR_EACH_PTR(*list, blob) {
+		if (blob->len == len && !memcmp(blob->data, data, len))
+			return blob;
+	} END_FOR_EACH_PTR(blob);
+	blob = alloc_blob(len);
+	memcpy(blob->data, data, len);
+	add_blob(list, blob);
+	return blob;
+}
+
+void free_blob(void)
+{
+	int i;
+
+	for (i = 0; i < BLOB_HASH_SIZE; i++) {
+		free_ptr_list(blob_hash_table + i);
+	}
+	clear_blob_alloc();
+}
+
Index: sparse/ptrlist.h
===================================================================
--- sparse.orig/ptrlist.h	2007-02-05 12:21:26.000000000 -0800
+++ sparse/ptrlist.h	2007-02-06 03:34:46.000000000 -0800
@@ -45,6 +45,8 @@ extern void concat_ptr_list(struct ptr_l
 extern void __free_ptr_list(struct ptr_list **);
 extern int ptr_list_size(struct ptr_list *);
 extern int linearize_ptr_list(struct ptr_list *, void **, int);
+extern int find_ptr_in_list(struct ptr_list* list, void *ptr);
+extern int find_ptr_index(struct ptr_list* list, void *ptr);
 
 /*
  * Hey, who said that you can't do overloading in C?
Index: sparse/lib.c
===================================================================
--- sparse.orig/lib.c	2007-02-06 03:34:45.000000000 -0800
+++ sparse/lib.c	2007-02-09 14:14:33.000000000 -0800
@@ -190,6 +190,7 @@ int Waddress_space = 1;
 int Wenum_mismatch = 1;
 int Wdo_while = 1;
 int Wuninitialized = 1;
+int Wmalloc = 1;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
@@ -339,6 +340,7 @@ static const struct warning {
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "do-while", &Wdo_while },
 	{ "uninitialized", &Wuninitialized },
+	{ "malloc", &Wmalloc},
 };
 
 enum {
Index: sparse/Makefile
===================================================================
--- sparse.orig/Makefile	2007-02-05 12:21:26.000000000 -0800
+++ sparse/Makefile	2007-02-09 14:14:33.000000000 -0800
@@ -28,12 +28,13 @@ INST_PROGRAMS=sparse cgcc
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
-	  storage.h ptrlist.h dissect.h
+	  storage.h ptrlist.h dissect.h checker.h
 
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
-	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o
+	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o \
+	  blobhash.o check-nullptr.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -136,6 +137,8 @@ example.o: $(LIB_H)
 storage.o: $(LIB_H)
 dissect.o: $(LIB_H)
 graph.o: $(LIB_H)
+blobstate.o: $(LIB_H)
+check-nullptr.o: $(LIB_H)
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
Index: sparse/checker.h
===================================================================
--- sparse.orig/checker.h	2007-02-06 03:34:46.000000000 -0800
+++ sparse/checker.h	2007-02-09 14:14:53.000000000 -0800
@@ -0,0 +1,142 @@
+#ifndef _CHECKER_H_
+#define _CHECKER_H_
+
+#include <assert.h>
+#include "allocate.h"
+#include "lib.h"
+#include "linearize.h"
+
+struct blob {
+	unsigned int len;
+	unsigned char data[0];
+};
+
+struct bb_state;
+
+DECLARE_PTR_LIST(blob_list, struct blob);
+
+struct bb_state {
+	unsigned long generation;
+	struct instruction_list *insns;	// instruction relate to state.
+	struct blob_list *cached_state;
+	struct instruction *branch;
+	unsigned noret:1;
+};
+
+struct state {
+	unsigned char *statep;
+	unsigned long value;
+};
+
+DECLARE_ALLOCATOR(blob);
+DECLARE_ALLOCATOR(bb_state);
+DECLARE_ALLOCATOR(state);
+DECLARE_PTR_LIST(state_list, struct state);
+
+struct blob *lookup_blob(const unsigned char *data, int len);
+struct blob *create_hashed_blob(const unsigned char *data, int len);
+
+static inline struct blob* alloc_blob(int len)
+{
+	struct blob *blob = __alloc_blob(len);
+	blob->len = len;
+	return blob;
+}
+
+static inline void add_blob(struct blob_list **list, struct blob *blob)
+{
+	add_ptr_list(list, blob);
+}
+
+static inline struct bb_state* alloc_bb_state(void)
+{
+	return __alloc_bb_state(0);
+}
+
+#define new_state(list, p, v)						\
+	do {								\
+		typeof(p) __p = p;					\
+		struct state *__state = __alloc_state(0);		\
+		__state->statep = __p;					\
+		__state->value = *__p;					\
+		*__p = (v);						\
+		add_ptr_list(list, __state);				\
+	} while (0)
+
+
+#define revert_state(type, list, size)					\
+	do {								\
+		struct state *__state;					\
+		struct ptr_list **__list = (struct ptr_list **)(list);	\
+		type *__p;						\
+		while (ptr_list_size(*__list) > (size)) {		\
+			__state = undo_ptr_list_last(__list);		\
+			__p = __state->statep;				\
+			*__p = (type)__state->value;			\
+			__free_state(__state);				\
+		}							\
+	} while (0)
+
+
+#define FOR_EACH_FUNC_CALL(p, i)							\
+	do {										\
+		struct pseudo_user *__pu_##i;						\
+		FOR_EACH_PTR((p)->users, __pu_##i) {					\
+			(i) = __pu_##i->insn;						\
+			if (!(i)->bb)							\
+				continue;						\
+			if ((i)->opcode != OP_CALL && (i)->opcode != OP_INLINED_CALL)	\
+				continue;						\
+			if (__pu_##i->userp != &(i)->func)				\
+				continue;						\
+
+#define END_FOR_EACH_FUNC_CALL(i)							\
+		} END_FOR_EACH_PTR(__pu_##i);						\
+	} while (0)
+
+static inline struct instruction *checker_instruction(struct instruction *insn, int opcode, pseudo_t src)
+{
+	struct instruction *new = __alloc_instruction(0);
+	new->opcode = opcode;
+	new->pos = insn->pos;
+	new->bb = insn->bb;
+	new->src = src;
+	new->offset = find_ptr_index((struct ptr_list *)insn->bb->insns, insn);
+	return new;
+}
+
+static inline struct ptr_list *__build_ident_list(const char *names[], int size)
+{
+	int i;
+	struct ptr_list *idents = NULL;
+	for (i = 0; i < size; i++) {
+		void* name = (void*) built_in_ident(names[i]);
+		add_ptr_list(&idents, name);
+	}
+	return idents;
+}
+
+#define build_ident_list(x) __build_ident_list(x, sizeof x/sizeof x[0])
+
+static inline int match_call_function(struct instruction *insn, struct ptr_list *list)
+{
+	struct ident *ident;
+	pseudo_t fn;
+
+	assert(insn->opcode == OP_CALL || insn->opcode == OP_INLINED_CALL);
+
+	fn = insn->func;
+	if (fn->type != PSEUDO_SYM)
+		return 0;
+	ident = fn->sym->ident;
+	if (!ident)
+		return 0;
+	return find_ptr_in_list(list, ident);
+}
+
+
+extern void check_null_ptr_init(void);
+extern void check_null_ptr(struct entrypoint *ep);
+
+#endif
+
Index: sparse/expand.c
===================================================================
--- sparse.orig/expand.c	2007-02-06 03:34:46.000000000 -0800
+++ sparse/expand.c	2007-02-06 03:34:46.000000000 -0800
@@ -29,8 +29,8 @@
 /* Random cost numbers */
 #define SIDE_EFFECTS 10000	/* The expression has side effects */
 #define UNSAFE 100		/* The expression may be "infinitely costly" due to exceptions */
-#define SELECT_COST 20		/* Cut-off for turning a conditional into a select */
-#define BRANCH_COST 10		/* Cost of a conditional branch */
+#define SELECT_COST 0		/* Cut-off for turning a conditional into a select */
+#define BRANCH_COST 0		/* Cost of a conditional branch */
 
 static int expand_expression(struct expression *);
 static int expand_statement(struct statement *);
Index: sparse/lib.h
===================================================================
--- sparse.orig/lib.h	2007-02-06 03:34:45.000000000 -0800
+++ sparse/lib.h	2007-02-09 14:14:33.000000000 -0800
@@ -96,6 +96,7 @@ extern int Wshadow;
 extern int Wcast_truncate;
 extern int Wdo_while;
 extern int Wuninitialized;
+extern int Wmalloc;
 
 extern int dbg_entry;
 extern int dbg_dead;
Index: sparse/sparse.c
===================================================================
--- sparse.orig/sparse.c	2007-02-06 03:34:45.000000000 -0800
+++ sparse/sparse.c	2007-02-09 14:14:33.000000000 -0800
@@ -23,6 +23,8 @@
 #include "symbol.h"
 #include "expression.h"
 #include "linearize.h"
+#include "storage.h"
+#include "checker.h"
 
 static int context_increase(struct basic_block *bb, int entry)
 {
@@ -269,6 +271,8 @@ static void check_symbols(struct symbol_
 				show_entry(ep);
 
 			check_context(ep);
+			if (Wmalloc)
+				check_null_ptr(ep);
 		}
 	} END_FOR_EACH_PTR(sym);
 }
@@ -280,6 +284,9 @@ int main(int argc, char **argv)
 
 	// Expand, linearize and show it.
 	check_symbols(sparse_initialize(argc, argv, &filelist));
+
+	check_null_ptr_init();
+	check_interrupt_init();
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		check_symbols(sparse(file));
 	} END_FOR_EACH_PTR_NOTAG(file);
Index: sparse/linearize.h
===================================================================
--- sparse.orig/linearize.h	2007-02-06 03:34:46.000000000 -0800
+++ sparse/linearize.h	2007-02-06 03:34:46.000000000 -0800
@@ -30,7 +30,9 @@ enum pseudo_type {
 
 struct pseudo {
 	int nr;
-	enum pseudo_type type;
+	enum pseudo_type type:8;
+	unsigned state_index:16;
+	unsigned tracking:1;
 	struct pseudo_user_list *users;
 	struct ident *ident;
 	union {
@@ -213,14 +215,19 @@ enum opcode {
 
 	/* Needed to translate SSA back to normal form */
 	OP_COPY,
+	OP_LAST,
 };
 
 struct basic_block_list;
 struct instruction_list;
+struct bb_state;
 
 struct basic_block {
 	struct position pos;
-	unsigned long generation;
+	union {
+		unsigned long generation;
+		struct bb_state *state;
+	};
 	int context;
 	struct entrypoint *ep;
 	struct basic_block_list *parents; /* sources */
Index: sparse/check-nullptr.c
===================================================================
--- sparse.orig/check-nullptr.c	2007-02-06 03:34:46.000000000 -0800
+++ sparse/check-nullptr.c	2007-02-06 03:34:46.000000000 -0800
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2006 Christopher Li <sparse@chrisli.org>
+ *
+ *  Licensed under the Open Software License version 1.1
+ */
+
+#include <stdio.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "storage.h"
+#include "checker.h"
+
+
+static int state_count = 0;
+static struct ptr_list *malloc_ident_list = NULL;
+static struct ptr_list *free_ident_list = NULL;
+static struct ptr_list *noret_ident_list = NULL;
+
+static struct blob *current;
+static struct blob *hashed_state;
+static struct state_list *state_stack;
+static void check_bb(struct basic_block *bb);
+
+#define alloc_state() alloc_blob(state_count)
+#define reg_state(pseudo) ((current)->data[pseudo->state_index])
+
+#define PTR_NULL		1
+#define PTR_NOTNULL		2
+#define PTR_FREE		4
+
+enum {
+	OP_DEF_PTR = OP_LAST,
+	OP_USE_PTR,
+	OP_FREE_PTR
+};
+
+static int cmp_insn_pos(const void *a, const void *b)
+{
+	int a1 = ((struct instruction *)a)->offset, b1 = ((struct instruction *)b)->offset;
+	if (a1 == b1)
+		return 0;
+	return a1 > b1 ? 1 : -1;
+}
+
+static void check_bb_cond(struct basic_block *bb, pseudo_t cond, unsigned value)
+{
+	new_state(&state_stack, &reg_state(cond), value);
+	hashed_state = NULL;
+	check_bb(bb);
+}
+
+
+static inline void execute_pointer_define(struct instruction *insn)
+{
+	new_state(&state_stack, &reg_state(insn->src), PTR_NULL | PTR_NOTNULL); 
+	hashed_state = NULL;
+}
+
+static inline void execute_pointer_usage(struct instruction *insn)
+{
+	if (reg_state(insn->src) & PTR_NULL)
+		warning(insn->pos, "function %s possibly using NULL pointer",
+			show_ident(insn->bb->ep->name->ident));
+	if (reg_state(insn->src) & PTR_FREE)
+		warning(insn->pos, "function %s possibly using pointer after free",
+			show_ident(insn->bb->ep->name->ident));
+}
+
+static inline void execute_pointer_free(struct instruction *insn)
+{
+	if (reg_state(insn->src) & PTR_FREE)
+		warning(insn->pos, "function %s possibly double free pointer",
+			show_ident(insn->bb->ep->name->ident));
+	new_state(&state_stack, &reg_state(insn->src), reg_state(insn->src) | PTR_FREE); 
+	hashed_state = NULL;
+
+}
+
+static void check_bb(struct basic_block *bb)
+{
+	struct bb_state *bbs = bb->state;
+	struct instruction *insn;
+	int stacksize = ptr_list_size((struct ptr_list*)state_stack);
+
+	if (bbs->generation)
+		return;
+
+	if (!hashed_state)
+		hashed_state = create_hashed_blob(current->data, state_count);
+
+	/*
+	 * Try to find out if we execute the same state before. If the state is
+	 * same, there is not point try to execute it again.
+	 */
+	if (find_ptr_in_list((struct ptr_list*)bbs->cached_state, hashed_state))
+		return;
+
+	add_ptr_list(&bbs->cached_state, hashed_state);
+
+	bbs->generation = 1;
+
+	FOR_EACH_PTR(bbs->insns, insn) {
+		switch (insn->opcode) {
+		case OP_DEF_PTR:
+			execute_pointer_define(insn);
+			break;
+		case OP_USE_PTR:
+			execute_pointer_usage(insn);
+			break;
+		case OP_FREE_PTR:
+			execute_pointer_free(insn);
+			break;
+		}
+	} END_FOR_EACH_PTR(insn);
+
+	if (bbs->noret)
+		goto exit_bb;
+
+	if (bbs->branch) {
+		struct instruction *br = bbs->branch;
+		unsigned char orig = reg_state(br->cond);
+		check_bb_cond(br->bb_true, br->cond, orig & ~PTR_NULL);
+		check_bb_cond(br->bb_false, br->cond, orig & ~PTR_NOTNULL);
+	} else {
+		struct basic_block *child;
+		
+		FOR_EACH_PTR(bb->children, child) {
+			check_bb(child);
+		} END_FOR_EACH_PTR(child);
+	}
+
+exit_bb:
+	if (ptr_list_size((struct ptr_list*)state_stack) > stacksize) {
+		revert_state(unsigned char, &state_stack, stacksize);
+		hashed_state = NULL;
+	}
+	bbs->generation = 0;
+}
+
+static void follow_pointer_usage(struct instruction *insn, pseudo_t pseudo, int index)
+{
+	struct pseudo_user *pu;
+
+	pseudo->tracking = 1;
+	pseudo->state_index = index;
+
+	FOR_EACH_PTR(pseudo->users, pu) {
+		struct instruction *useri = pu->insn;
+		struct basic_block *bb = useri->bb;
+		struct bb_state *bb_state;
+		if (!bb)
+			continue;
+		bb_state = bb->state;
+
+		switch(useri->opcode) {
+		case OP_CAST: case OP_SCAST: case OP_PTRCAST:
+			/* cast a pointer does not change the pointer state, it is just alias */
+			follow_pointer_usage(useri, useri->target, index);
+			break;
+		case OP_STORE:
+		case OP_LOAD:
+			if (pseudo == useri->src) {
+				struct instruction *use = checker_instruction(useri, OP_USE_PTR,
+									      pseudo);
+				add_instruction(&bb_state->insns, use);
+			}
+			break;
+		case OP_CALL:
+		case OP_INLINED_CALL:
+			if (match_call_function(useri, free_ident_list)) {
+				struct instruction *fr = checker_instruction(useri, OP_FREE_PTR,
+									      pseudo);
+				add_instruction(&bb_state->insns, fr);
+			}
+			break;
+		case OP_BR:
+			bb_state->branch = useri;
+			break;
+ 		case OP_SWITCH:
+			warning(insn->pos, "switch on pointer not implemented\n");
+			break;
+		}
+	} END_FOR_EACH_PTR(pu);
+}
+		
+static inline void scan_pointer_define(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+	struct instruction *insn;
+	pseudo_t pseudo;
+
+	FOR_EACH_PTR(ep->accesses, pseudo) {
+		struct ident *ident = pseudo->sym->ident;
+		if (!ident)
+			continue;
+		if (find_ptr_in_list(noret_ident_list, ident)) {
+			FOR_EACH_FUNC_CALL(pseudo, insn) {
+				insn->bb->state->noret = 1;
+			} END_FOR_EACH_FUNC_CALL(insn);
+		}
+		if (find_ptr_in_list(malloc_ident_list, ident)) {
+			FOR_EACH_FUNC_CALL(pseudo, insn) {
+				struct instruction *def = checker_instruction(insn, OP_DEF_PTR, insn->target);
+				add_instruction(&insn->bb->state->insns, def);
+				follow_pointer_usage(insn, insn->target, state_count++);
+			} END_FOR_EACH_FUNC_CALL(insn);
+		}
+		
+	} END_FOR_EACH_PTR(pseudo);
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		sort_list((struct ptr_list **)&bb->state->insns, cmp_insn_pos);
+	} END_FOR_EACH_PTR(bb);
+}
+
+void check_null_ptr(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	state_count = 0;
+	
+	FOR_EACH_PTR(ep->bbs, bb) {
+		bb->state = alloc_bb_state();
+	} END_FOR_EACH_PTR(bb);
+
+	scan_pointer_define(ep);
+	current = alloc_state();
+	check_bb(ep->entry->bb);
+}
+
+void check_null_ptr_init(void)
+{
+	static const char *malloc_name[] = {
+		"malloc",
+		"kmalloc_node",
+		"kzalloc",
+		"kmem_cache_alloc",
+		"kmem_cache_zalloc",
+		"kmem_cache_alloc_node",
+		"vmalloc",
+		"vmalloc_user",
+		"vmalloc_node",
+		"vmalloc_32",
+		"vmalloc_32_user",
+	};
+	static const char *free_name[] = {
+		"free",
+		"kfree",
+		"kmem_cache_free",
+		"vfree",
+	};
+	static const char *noret[] = {
+		"panic",
+	};
+
+	malloc_ident_list = build_ident_list(malloc_name);
+	free_ident_list = build_ident_list(free_name);
+	noret_ident_list = build_ident_list(noret);
+}
+
Index: sparse/ptrlist.c
===================================================================
--- sparse.orig/ptrlist.c	2007-02-06 03:34:46.000000000 -0800
+++ sparse/ptrlist.c	2007-02-06 03:34:46.000000000 -0800
@@ -246,3 +246,29 @@ void __free_ptr_list(struct ptr_list **l
 
 	*listp = NULL;
 }
+
+int find_ptr_in_list(struct ptr_list* list, void *ptr)
+{
+	void *p;
+	FOR_EACH_PTR(list, p) {
+		if (p == ptr)
+			return 1;
+	} END_FOR_EACH_PTR(p);
+	return 0;
+}
+
+int find_ptr_index(struct ptr_list* list, void *ptr)
+{
+	void *p;
+	int i = 0;
+	FOR_EACH_PTR(list, p) {
+		if (p == ptr)
+			return i;
+		i++;
+	} END_FOR_EACH_PTR(p);
+	return -1;
+}
+
+
+
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/8] rewrite type_difference() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 7/8] rewrite type_difference()
Date: Fri, 13 Jul 2007 17:45:27 +0000
Message-ID: <E1I9PCp-0000FJ-5s () ZenIV ! linux ! org ! uk>
--------------------

a) qualifiers should not be ignored beyond the top layer
b) qualifiers *should* be ignored in top layer of function arguments
c) change prototype - pass ctype * instead of symbol * and pass
"what to add to modifiers in that ctype" instead of "what to ignore".

We are still not quite done (there are incomplete types, there
are array size comparisons, there is lifting of signedness logics
into compatible_assignment_types()), but it's a much better approximation.

BTW, it's already good enough for kernel ARRAY_SIZE(), which
has become a major source of noise lately...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |  272 +++++++++++++++++++++++++++++++++--------------------------
 expand.c   |    6 +-
 symbol.h   |    2 +-
 3 files changed, 157 insertions(+), 123 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 8df2042..213039b 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -621,92 +621,145 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *c
 
 static void examine_fn_arguments(struct symbol *fn);
 
-const char * type_difference(struct symbol *target, struct symbol *source,
-	unsigned long target_mod_ignore, unsigned long source_mod_ignore)
+#define MOD_IGN (MOD_VOLATILE | MOD_CONST)
+
+const char *type_difference(struct ctype *c1, struct ctype *c2,
+	unsigned long mod1, unsigned long mod2)
 {
+	unsigned long as1 = c1->as, as2 = c2->as;
+	struct symbol *t1 = c1->base_type;
+	struct symbol *t2 = c2->base_type;
+	int move1 = 1, move2 = 1;
+	mod1 |= c1->modifiers;
+	mod2 |= c2->modifiers;
 	for (;;) {
-		unsigned long mod1, mod2, diff;
-		unsigned long as1, as2;
-		int type1, type2;
-		struct symbol *base1, *base2;
+		unsigned long diff;
+		int type;
+		struct symbol *base1 = t1->ctype.base_type;
+		struct symbol *base2 = t2->ctype.base_type;
 
-		if (target == source)
-			break;
-		if (!target || !source)
-			return "different types";
 		/*
-		 * Peel of per-node information.
-		 * FIXME! Check alignment and context too here!
+		 * FIXME! Collect alignment and context too here!
 		 */
-		mod1 = target->ctype.modifiers;
-		as1 = target->ctype.as;
-		mod2 = source->ctype.modifiers;
-		as2 = source->ctype.as; 
-		if (target->type == SYM_NODE) {
-			target = target->ctype.base_type;
-			if (!target)
-				return "bad types";
-			if (target->type == SYM_PTR) {
-				mod1 = 0;
-				as1 = 0;
-			}	
-			mod1 |= target->ctype.modifiers;
-			as1 |= target->ctype.as;
-		}
-		if (source->type == SYM_NODE) {
-			source = source->ctype.base_type;
-			if (!source)
-				return "bad types";
-			if (source->type == SYM_PTR) {
-				mod2 = 0;
-				as2 = 0;
+		if (move1) {
+			if (t1 && t1->type != SYM_PTR) {
+				mod1 |= t1->ctype.modifiers;
+				as1 |= t1->ctype.as;
 			}
-			mod2 |= source->ctype.modifiers;
-			as2 |= source->ctype.as; 
-		}
-		if (target->type == SYM_ENUM) {
-			target = target->ctype.base_type;
-			if (!target)
-				return "bad types";
+			move1 = 0;
 		}
-		if (source->type == SYM_ENUM) {
-			source = source->ctype.base_type;
-			if (!source)
-				return "bad types";
+
+		if (move2) {
+			if (t2 && t2->type != SYM_PTR) {
+				mod2 |= t2->ctype.modifiers;
+				as2 |= t2->ctype.as;
+			}
+			move2 = 0;
 		}
 
-		if (target == source)
+		if (t1 == t2)
 			break;
-		if (!target || !source)
+		if (!t1 || !t2)
 			return "different types";
 
-		type1 = target->type;
-		base1 = target->ctype.base_type;
-
-		type2 = source->type;
-		base2 = source->ctype.base_type;
+		if (t1->type == SYM_NODE || t1->type == SYM_ENUM) {
+			t1 = base1;
+			move1 = 1;
+			if (!t1)
+				return "bad types";
+			continue;
+		}
 
-		/*
-		 * Pointers to functions compare as the function itself
-		 */
-		if (type1 == SYM_PTR && base1)
-			base1 = examine_symbol_type(base1);
+		if (t2->type == SYM_NODE || t2->type == SYM_ENUM) {
+			t2 = base2;
+			move2 = 1;
+			if (!t2)
+				return "bad types";
+			continue;
+		}
 
-		if (type2 == SYM_PTR && base2)
-			base2 = examine_symbol_type(base2);
+		move1 = move2 = 1;
+		type = t1->type;
+		if (type != t2->type)
+			return "different base types";
 
-		if (type1 != type2 || type1 == SYM_RESTRICT ||
-		    type1 == SYM_UNION || type1 == SYM_STRUCT)
+		switch (type) {
+		default:
+			sparse_error(t1->pos,
+				     "internal error: bad type in derived(%d)",
+				     type);
+			return "bad types";
+		case SYM_RESTRICT:
+		case SYM_UNION:
+		case SYM_STRUCT:
 			return "different base types";
+		case SYM_ARRAY:
+			/* XXX: we ought to compare sizes */
+			break;
+		case SYM_PTR:
+			if (Waddress_space && as1 != as2)
+				return "different address spaces";
+			/* MOD_SPECIFIER is due to idiocy in parse.c */
+			if ((mod1 ^ mod2) & ~MOD_IGNORE & ~MOD_SPECIFIER)
+				return "different modifiers";
+			/* we could be lazier here */
+			mod1 = t1->ctype.modifiers;
+			as1 = t1->ctype.as;
+			mod2 = t2->ctype.modifiers;
+			as2 = t2->ctype.as;
+			base1 = examine_symbol_type(base1);
+			base2 = examine_symbol_type(base2);
+			break;
+		case SYM_FN: {
+			struct symbol *arg1, *arg2;
+			int i;
 
-		/* Must be same address space to be comparable */
-		if (Waddress_space && as1 != as2)
-			return "different address spaces";
+			if (Waddress_space && as1 != as2)
+				return "different address spaces";
+			if ((mod1 ^ mod2) & ~MOD_IGNORE & ~MOD_SIGNEDNESS)
+				return "different modifiers";
+			mod1 = t1->ctype.modifiers;
+			as1 = t1->ctype.as;
+			mod2 = t2->ctype.modifiers;
+			as2 = t2->ctype.as;
 
-		/* Ignore differences in storage types or addressability */
-		diff = (mod1 ^ mod2) & ~MOD_IGNORE;
-		diff &= (mod1 & ~target_mod_ignore) | (mod2 & ~source_mod_ignore);
-		if (diff) {
+			if (base1->variadic != base2->variadic)
+				return "incompatible variadic arguments";
+			examine_fn_arguments(t1);
+			examine_fn_arguments(t2);
+			PREPARE_PTR_LIST(t1->arguments, arg1);
+			PREPARE_PTR_LIST(t2->arguments, arg2);
+			i = 1;
+			for (;;) {
+				const char *diffstr;
+				if (!arg1 && !arg2)
+					break;
+				if (!arg1 || !arg2)
+					return "different argument counts";
+				diffstr = type_difference(&arg1->ctype,
+							  &arg2->ctype,
+							  MOD_IGN, MOD_IGN);
+				if (diffstr) {
+					static char argdiff[80];
+					sprintf(argdiff, "incompatible argument %d (%s)", i, diffstr);
+					return argdiff;
+				}
+				NEXT_PTR_LIST(arg1);
+				NEXT_PTR_LIST(arg2);
+				i++;
+			}
+			FINISH_PTR_LIST(arg2);
+			FINISH_PTR_LIST(arg1);
+			break;
+		}
+		case SYM_BASETYPE:
+			if (Waddress_space && as1 != as2)
+				return "different address spaces";
+			if (base1 != base2)
+				return "different base types";
+			diff = (mod1 ^ mod2) & ~MOD_IGNORE;
+			if (!diff)
+				return NULL;
 			if (diff & MOD_SIZE)
 				return "different type sizes";
 			if (diff & ~MOD_SIGNEDNESS)
@@ -730,39 +783,15 @@ const char * type_difference(struct symbol *target, struct symbol *source,
 				if (!(mod1 & MOD_CHAR))
 					return "different signedness";
 			}
+			return NULL;
 		}
-
-		if (type1 == SYM_FN) {
-			int i;
-			struct symbol *arg1, *arg2;
-			if (base1->variadic != base2->variadic)
-				return "incompatible variadic arguments";
-			examine_fn_arguments(target);
-			examine_fn_arguments(source);
-			PREPARE_PTR_LIST(target->arguments, arg1);
-			PREPARE_PTR_LIST(source->arguments, arg2);
-			i = 1;
-			for (;;) {
-				const char *diffstr;
-				diffstr = type_difference(arg1, arg2, 0, 0);
-				if (diffstr) {
-					static char argdiff[80];
-					sprintf(argdiff, "incompatible argument %d (%s)", i, diffstr);
-					return argdiff;
-				}
-				if (!arg1)
-					break;
-				NEXT_PTR_LIST(arg1);
-				NEXT_PTR_LIST(arg2);
-				i++;
-			}
-			FINISH_PTR_LIST(arg2);
-			FINISH_PTR_LIST(arg1);
-		}
-
-		target = base1;
-		source = base2;
+		t1 = base1;
+		t2 = base2;
 	}
+	if (Waddress_space && as1 != as2)
+		return "different address spaces";
+	if ((mod1 ^ mod2) & ~MOD_IGNORE & ~MOD_SIGNEDNESS)
+		return "different modifiers";
 	return NULL;
 }
 
@@ -772,12 +801,6 @@ static void bad_null(struct expression *expr)
 		warning(expr->pos, "Using plain integer as NULL pointer");
 }
 
-/*
- * Ignore differences in "volatile" and "const"ness when
- * subtracting pointers
- */
-#define MOD_IGN (MOD_VOLATILE | MOD_CONST)
-
 static struct symbol *evaluate_ptr_sub(struct expression *expr)
 {
 	const char *typediff;
@@ -792,7 +815,8 @@ static struct symbol *evaluate_ptr_sub(struct expression *expr)
 
 	lbase = get_base_type(ltype);
 	rbase = get_base_type(rtype);
-	typediff = type_difference(ltype, rtype, ~MOD_SIZE, ~MOD_SIZE);
+	typediff = type_difference(&ltype->ctype, &rtype->ctype,
+				   MOD_IGN, MOD_IGN);
 	if (typediff)
 		expression_error(expr, "subtraction of different types can't work (%s)", typediff);
 
@@ -965,7 +989,7 @@ static inline int is_null_pointer_constant(struct expression *e)
 static struct symbol *evaluate_compare(struct expression *expr)
 {
 	struct expression *left = expr->left, *right = expr->right;
-	struct symbol *ltype, *rtype;
+	struct symbol *ltype, *rtype, *lbase, *rbase;
 	int lclass = classify_type(degenerate(left), &ltype);
 	int rclass = classify_type(degenerate(right), &rtype);
 	struct symbol *ctype;
@@ -1020,24 +1044,31 @@ static struct symbol *evaluate_compare(struct expression *expr)
 			right = cast_to(right, ltype);
 			goto OK;
 		}
-		/* they also have special treatment for pointers to void */
-		if (lclass & rclass & TYPE_PTR) {
-			if (get_base_type(ltype) == &void_ctype) {
+	}
+	/* both should be pointers */
+	if (!(lclass & rclass & TYPE_PTR))
+		return bad_expr_type(expr);
+	expr->op = modify_for_unsigned(expr->op);
+
+	lbase = get_base_type(ltype);
+	rbase = get_base_type(rtype);
+
+	/* they also have special treatment for pointers to void */
+	if (expr->op == SPECIAL_EQUAL || expr->op == SPECIAL_NOTEQUAL) {
+		if (ltype->ctype.as == rtype->ctype.as) {
+			if (lbase == &void_ctype) {
 				right = cast_to(right, ltype);
 				goto OK;
 			}
-			if (get_base_type(rtype) == &void_ctype) {
+			if (rbase == &void_ctype) {
 				left = cast_to(left, rtype);
 				goto OK;
 			}
 		}
 	}
-	/* both should be pointers */
-	if (!(lclass & rclass & TYPE_PTR))
-		return bad_expr_type(expr);
 
-	expr->op = modify_for_unsigned(expr->op);
-	typediff = type_difference(ltype, rtype, MOD_IGN, MOD_IGN);
+	typediff = type_difference(&ltype->ctype, &rtype->ctype,
+				   MOD_IGN, MOD_IGN);
 	if (!typediff)
 		goto OK;
 
@@ -1151,7 +1182,8 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 		}
 		/* XXX: that should be pointer to composite */
 		ctype = ltype;
-		typediff = type_difference(lbase, rbase, MOD_IGN, MOD_IGN);
+		typediff = type_difference(&ltype->ctype, &rtype->ctype,
+					   MOD_IGN, MOD_IGN);
 		if (!typediff)
 			goto Qual;
 		goto Err;
@@ -1304,8 +1336,8 @@ static int compatible_assignment_types(struct expression *expr, struct symbol *t
 			goto Cast;
 		}
 		/* It's OK if the target is more volatile or const than the source */
-		typediff = type_difference(target, source,
-					   MOD_VOLATILE | MOD_CONST, 0);
+		typediff = type_difference(&t->ctype, &s->ctype,
+					   0, mod1 & MOD_IGN);
 		if (typediff)
 			goto Err;
 		return 1;
@@ -2926,7 +2958,7 @@ static void check_duplicates(struct symbol *sym)
 		const char *typediff;
 		evaluate_symbol(next);
 		declared++;
-		typediff = type_difference(sym, next, 0, 0);
+		typediff = type_difference(&sym->ctype, &next->ctype, 0, 0);
 		if (typediff) {
 			sparse_error(sym->pos, "symbol '%s' redeclared with different type (originally declared at %s:%d) - %s",
 				show_ident(sym->ident),
diff --git a/expand.c b/expand.c
index 06b8127..72d9be6 100644
--- a/expand.c
+++ b/expand.c
@@ -460,11 +460,13 @@ static int expand_comma(struct expression *expr)
 
 static int compare_types(int op, struct symbol *left, struct symbol *right)
 {
+	struct ctype c1 = {.base_type = left};
+	struct ctype c2 = {.base_type = right};
 	switch (op) {
 	case SPECIAL_EQUAL:
-		return !type_difference(left, right, MOD_IGN, MOD_IGN);
+		return !type_difference(&c1, &c2, MOD_IGN, MOD_IGN);
 	case SPECIAL_NOTEQUAL:
-		return type_difference(left, right, MOD_IGN, MOD_IGN) != NULL;
+		return type_difference(&c1, &c2, MOD_IGN, MOD_IGN) != NULL;
 	case '<':
 		return left->bit_size < right->bit_size;
 	case '>':
diff --git a/symbol.h b/symbol.h
index 4d8d328..bf5b675 100644
--- a/symbol.h
+++ b/symbol.h
@@ -245,7 +245,7 @@ extern struct symbol_list *translation_unit_used_list;
 
 extern void access_symbol(struct symbol *);
 
-extern const char * type_difference(struct symbol *target, struct symbol *source,
+extern const char * type_difference(struct ctype *c1, struct ctype *c2,
 	unsigned long target_mod_ignore, unsigned long source_mod_ignore);
 
 extern struct symbol *lookup_symbol(struct ident *, enum namespace);
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH 7/8] rewrite type_difference()
Date: Fri, 13 Jul 2007 18:16:43 +0000
Message-ID: <1184350603.2616.47.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-13 at 18:45 +0100, Al Viro wrote:
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -621,92 +621,145 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *c
> 
>  static void examine_fn_arguments(struct symbol *fn);
> 
> -const char * type_difference(struct symbol *target, struct symbol *source,
> -	unsigned long target_mod_ignore, unsigned long source_mod_ignore)
> +#define MOD_IGN (MOD_VOLATILE | MOD_CONST)
> +
> +const char *type_difference(struct ctype *c1, struct ctype *c2,
> +	unsigned long mod1, unsigned long mod2)
[...]
> --- a/symbol.h
> +++ b/symbol.h
> @@ -245,7 +245,7 @@ extern struct symbol_list *translation_unit_used_list;
> 
>  extern void access_symbol(struct symbol *);
> 
> -extern const char * type_difference(struct symbol *target, struct symbol *source,
> +extern const char * type_difference(struct ctype *c1, struct ctype *c2,
>  	unsigned long target_mod_ignore, unsigned long source_mod_ignore);

You didn't update the third and fourth arguments in this prototype.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 7/8] rewrite type_difference()
Date: Fri, 13 Jul 2007 18:19:05 +0000
Message-ID: <20070713181904.GC21668 () ftp ! linux ! org ! uk>
--------------------
On Fri, Jul 13, 2007 at 11:16:43AM -0700, Josh Triplett wrote:
> On Fri, 2007-07-13 at 18:45 +0100, Al Viro wrote:
> > --- a/evaluate.c
> > +++ b/evaluate.c
> > @@ -621,92 +621,145 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *c
> > 
> >  static void examine_fn_arguments(struct symbol *fn);
> > 
> > -const char * type_difference(struct symbol *target, struct symbol *source,
> > -	unsigned long target_mod_ignore, unsigned long source_mod_ignore)
> > +#define MOD_IGN (MOD_VOLATILE | MOD_CONST)
> > +
> > +const char *type_difference(struct ctype *c1, struct ctype *c2,
> > +	unsigned long mod1, unsigned long mod2)
> [...]
> > --- a/symbol.h
> > +++ b/symbol.h
> > @@ -245,7 +245,7 @@ extern struct symbol_list *translation_unit_used_list;
> > 
> >  extern void access_symbol(struct symbol *);
> > 
> > -extern const char * type_difference(struct symbol *target, struct symbol *source,
> > +extern const char * type_difference(struct ctype *c1, struct ctype *c2,
> >  	unsigned long target_mod_ignore, unsigned long source_mod_ignore);
> 
> You didn't update the third and fourth arguments in this prototype.

Do you want their renaming as a followup patch or as a resend?  (Or just
rename them in the patch or upon commit - it won't clash with any later
changes).
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH 7/8] rewrite type_difference()
Date: Fri, 13 Jul 2007 18:30:31 +0000
Message-ID: <1184351431.2616.50.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-13 at 19:19 +0100, Al Viro wrote:
> On Fri, Jul 13, 2007 at 11:16:43AM -0700, Josh Triplett wrote:
> > On Fri, 2007-07-13 at 18:45 +0100, Al Viro wrote:
> > > --- a/evaluate.c
> > > +++ b/evaluate.c
> > > @@ -621,92 +621,145 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *c
> > > 
> > >  static void examine_fn_arguments(struct symbol *fn);
> > > 
> > > -const char * type_difference(struct symbol *target, struct symbol *source,
> > > -	unsigned long target_mod_ignore, unsigned long source_mod_ignore)
> > > +#define MOD_IGN (MOD_VOLATILE | MOD_CONST)
> > > +
> > > +const char *type_difference(struct ctype *c1, struct ctype *c2,
> > > +	unsigned long mod1, unsigned long mod2)
> > [...]
> > > --- a/symbol.h
> > > +++ b/symbol.h
> > > @@ -245,7 +245,7 @@ extern struct symbol_list *translation_unit_used_list;
> > > 
> > >  extern void access_symbol(struct symbol *);
> > > 
> > > -extern const char * type_difference(struct symbol *target, struct symbol *source,
> > > +extern const char * type_difference(struct ctype *c1, struct ctype *c2,
> > >  	unsigned long target_mod_ignore, unsigned long source_mod_ignore);
> > 
> > You didn't update the third and fourth arguments in this prototype.
> 
> Do you want their renaming as a followup patch or as a resend?  (Or just
> rename them in the patch or upon commit - it won't clash with any later
> changes).

I'll fix them manually as part of that commit.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7] Adding the interrupt checker ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 7] Adding the interrupt checker
Date: Sat, 10 Feb 2007 00:26:04 +0000
Message-ID: <20070210002604.GA20748 () chrisli ! org>
--------------------
Changelog:
 - Using the new inline function calling annotation to find
   out the irq related call. It now works both inline and
   external functions. Bonus is no more x86 asm any more.
 - The noise level of interrupt check drop considerably.
   I think it is less nosier than the context checking.

Signed-off-by: Christopher Li<sparse@chrisli.org>

Index: sparse/lib.c
===================================================================
--- sparse.orig/lib.c	2007-02-09 14:14:33.000000000 -0800
+++ sparse/lib.c	2007-02-09 14:15:08.000000000 -0800
@@ -191,6 +191,7 @@ int Wenum_mismatch = 1;
 int Wdo_while = 1;
 int Wuninitialized = 1;
 int Wmalloc = 1;
+int Winterrupt = 1;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
@@ -341,6 +342,7 @@ static const struct warning {
 	{ "do-while", &Wdo_while },
 	{ "uninitialized", &Wuninitialized },
 	{ "malloc", &Wmalloc},
+	{ "interrupt", &Winterrupt},
 };
 
 enum {
Index: sparse/Makefile
===================================================================
--- sparse.orig/Makefile	2007-02-09 14:14:33.000000000 -0800
+++ sparse/Makefile	2007-02-09 14:15:08.000000000 -0800
@@ -34,7 +34,7 @@ LIB_OBJS= target.o parse.o tokenize.o pr
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
 	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o \
-	  blobhash.o check-nullptr.o
+	  blobhash.o check-nullptr.o check-interrupt.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -139,6 +139,7 @@ dissect.o: $(LIB_H)
 graph.o: $(LIB_H)
 blobstate.o: $(LIB_H)
 check-nullptr.o: $(LIB_H)
+check-interrupt.o: $(LIB_H)
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
Index: sparse/checker.h
===================================================================
--- sparse.orig/checker.h	2007-02-09 14:14:53.000000000 -0800
+++ sparse/checker.h	2007-02-09 14:15:27.000000000 -0800
@@ -137,6 +137,8 @@ static inline int match_call_function(st
 
 extern void check_null_ptr_init(void);
 extern void check_null_ptr(struct entrypoint *ep);
+extern void check_interrupt(struct entrypoint *ep);
+extern void check_interrupt_init(void);
 
 #endif
 
Index: sparse/lib.h
===================================================================
--- sparse.orig/lib.h	2007-02-09 14:14:33.000000000 -0800
+++ sparse/lib.h	2007-02-09 14:15:08.000000000 -0800
@@ -97,6 +97,7 @@ extern int Wcast_truncate;
 extern int Wdo_while;
 extern int Wuninitialized;
 extern int Wmalloc;
+extern int Winterrupt;
 
 extern int dbg_entry;
 extern int dbg_dead;
Index: sparse/sparse.c
===================================================================
--- sparse.orig/sparse.c	2007-02-09 14:14:33.000000000 -0800
+++ sparse/sparse.c	2007-02-09 14:15:08.000000000 -0800
@@ -273,6 +273,8 @@ static void check_symbols(struct symbol_
 			check_context(ep);
 			if (Wmalloc)
 				check_null_ptr(ep);
+			if (Winterrupt)
+				check_interrupt(ep);
 		}
 	} END_FOR_EACH_PTR(sym);
 }
Index: sparse/check-interrupt.c
===================================================================
--- sparse.orig/check-interrupt.c	2007-02-09 14:15:08.000000000 -0800
+++ sparse/check-interrupt.c	2007-02-09 14:15:08.000000000 -0800
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2006 Christopher Li <sparse@chrisli.org>
+ *
+ *  Licensed under the Open Software License version 1.1
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "storage.h"
+#include "checker.h"
+
+
+static unsigned char current;
+static struct blob *hashed_state;
+static struct state_list *state_stack = NULL;
+static struct ptr_list *irq_enable_list;
+static struct ptr_list *irq_disable_list;
+static struct ptr_list *irq_restore_list;
+
+enum {
+	OP_IRQ_ENABLE = OP_LAST,
+	OP_IRQ_DISABLE,
+	OP_IRQ_RESTORE,
+};
+
+enum {
+	INTR_ENABLE,
+	INTR_DISABLE,
+};
+
+static inline void execute_enable(struct instruction *insn)
+{
+	if (current == INTR_ENABLE) {
+		warning(insn->pos, "checker function %s double enable",
+			show_ident(insn->bb->ep->name->ident));
+		return;
+	}
+	new_state(&state_stack, &current, INTR_ENABLE); 
+	hashed_state = NULL;
+}
+
+static inline void execute_disable(struct instruction *insn)
+{
+	if (current == INTR_DISABLE) {
+		warning(insn->pos, "checker function %s double enable",
+			show_ident(insn->bb->ep->name->ident));
+		return;
+	}
+	new_state(&state_stack, &current, INTR_DISABLE); 
+	hashed_state = NULL;
+}
+
+static inline void execute_ret(struct instruction *insn)
+{
+	if (current == INTR_DISABLE)
+		warning(insn->pos, "checker function %s exit with interrupt disabled",
+			show_ident(insn->bb->ep->name->ident));
+}
+
+static void check_bb(struct basic_block *bb)
+{
+	struct bb_state *bbs = bb->state;
+	struct instruction *insn;
+	int stacksize = ptr_list_size((struct ptr_list*)state_stack);
+	struct basic_block *child;
+
+	if (bbs->generation)
+		return;
+
+	if (!hashed_state)
+		hashed_state = create_hashed_blob(&current, 1);
+
+	/*
+	 * Try to find out if we execute the same state before. If the state is
+	 * same, there is not point try to execute it again.
+	 */
+	if (find_ptr_in_list((struct ptr_list*)bbs->cached_state, hashed_state))
+		return;
+
+	add_ptr_list(&bbs->cached_state, hashed_state);
+
+	bbs->generation = 1;
+
+	FOR_EACH_PTR(bbs->insns, insn) {
+		switch (insn->opcode) {
+		case OP_IRQ_DISABLE:
+			execute_disable(insn);
+			break;
+		case OP_IRQ_ENABLE:
+		case OP_IRQ_RESTORE:
+			execute_enable(insn);
+			break;
+		case OP_RET:
+			execute_ret(insn);
+			break;
+		}
+	} END_FOR_EACH_PTR(insn);
+
+	if (bbs->noret)
+		goto exit_bb;
+
+		
+	FOR_EACH_PTR(bb->children, child) {
+		check_bb(child);
+	} END_FOR_EACH_PTR(child);
+
+exit_bb:
+	if (ptr_list_size((struct ptr_list*)state_stack) > stacksize) {
+		revert_state(unsigned char, &state_stack, stacksize);
+		hashed_state = NULL;
+	}
+	bbs->generation = 0;
+}
+
+static inline void scan_call_instruction(struct bb_state *bbs, struct instruction *insn)
+{
+	pseudo_t fn = insn->func;
+	struct ident *name;
+
+	if (fn->type != PSEUDO_SYM)
+		return;
+ 	name = fn->sym->ident;
+	if (find_ptr_in_list(irq_enable_list, name))
+		add_instruction(&bbs->insns, checker_instruction(insn, OP_IRQ_ENABLE, NULL));
+	else if (find_ptr_in_list(irq_disable_list, name))
+		add_instruction(&bbs->insns, checker_instruction(insn, OP_IRQ_DISABLE, NULL));
+	else if (find_ptr_in_list(irq_restore_list, name))
+		add_instruction(&bbs->insns, checker_instruction(insn, OP_IRQ_RESTORE, NULL));
+}
+
+static inline void scan_interrupt_insn(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+	struct instruction *insn;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		struct bb_state *bbs = bb->state;
+		FOR_EACH_PTR(bb->insns, insn) {
+			if (!insn->bb)
+				continue;
+
+			switch (insn->opcode) {
+			case OP_RET:
+				add_instruction(&bbs->insns, insn);
+				break;
+			case OP_INLINED_CALL:
+			case OP_CALL:
+				scan_call_instruction(bbs, insn);
+				break;
+			}
+		} END_FOR_EACH_PTR(insn);
+	} END_FOR_EACH_PTR(bb);
+}
+
+void check_interrupt_init(void)
+{
+	static const char *enable[] = {
+		"raw_local_irq_enable",
+		"raw_safe_halt",
+		"_spin_unlock_irq",
+		"_read_unlock_irq",
+		"_write_unlock_irq",
+		"schedule",		// XXX: is it always true?
+	};
+	static const char *disable[] = {
+		"raw_local_irq_disable",
+		"_spin_lock_irq",
+		"task_rq_lock",
+		"_spin_lock_irqsave",
+		"_read_lock_irq",
+		"_read_lock_irqsave",
+		"_write_lock_irq",
+		"_write_lock_irqsave",
+		"lock_timer_base",
+		"lock_timer",
+	};
+	static const char *restore[] = {
+		"raw_local_irq_restore",
+		"_spin_unlock_irqrestore",
+		"_read_unlock_irqrestore",
+		"_write_unlock_irqrestore",
+	};
+	
+	irq_enable_list = build_ident_list(enable);
+	irq_disable_list = build_ident_list(disable);
+	irq_restore_list = build_ident_list(restore);
+}
+
+void check_interrupt(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		bb->state = alloc_bb_state();
+	} END_FOR_EACH_PTR(bb);
+
+	current = INTR_ENABLE;
+	hashed_state = NULL;
+	scan_interrupt_insn(ep);
+	check_bb(ep->entry->bb);
+}
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 7] Adding the interrupt checker
Date: Sat, 10 Feb 2007 00:26:04 +0000
Message-ID: <20070210002604.GA20748 () chrisli ! org>
--------------------
Changelog:
 - Using the new inline function calling annotation to find
   out the irq related call. It now works both inline and
   external functions. Bonus is no more x86 asm any more.
 - The noise level of interrupt check drop considerably.
   I think it is less nosier than the context checking.

Signed-off-by: Christopher Li<sparse@chrisli.org>

Index: sparse/lib.c
===================================================================
--- sparse.orig/lib.c	2007-02-09 14:14:33.000000000 -0800
+++ sparse/lib.c	2007-02-09 14:15:08.000000000 -0800
@@ -191,6 +191,7 @@ int Wenum_mismatch = 1;
 int Wdo_while = 1;
 int Wuninitialized = 1;
 int Wmalloc = 1;
+int Winterrupt = 1;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
@@ -341,6 +342,7 @@ static const struct warning {
 	{ "do-while", &Wdo_while },
 	{ "uninitialized", &Wuninitialized },
 	{ "malloc", &Wmalloc},
+	{ "interrupt", &Winterrupt},
 };
 
 enum {
Index: sparse/Makefile
===================================================================
--- sparse.orig/Makefile	2007-02-09 14:14:33.000000000 -0800
+++ sparse/Makefile	2007-02-09 14:15:08.000000000 -0800
@@ -34,7 +34,7 @@ LIB_OBJS= target.o parse.o tokenize.o pr
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
 	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o \
-	  blobhash.o check-nullptr.o
+	  blobhash.o check-nullptr.o check-interrupt.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -139,6 +139,7 @@ dissect.o: $(LIB_H)
 graph.o: $(LIB_H)
 blobstate.o: $(LIB_H)
 check-nullptr.o: $(LIB_H)
+check-interrupt.o: $(LIB_H)
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
Index: sparse/checker.h
===================================================================
--- sparse.orig/checker.h	2007-02-09 14:14:53.000000000 -0800
+++ sparse/checker.h	2007-02-09 14:15:27.000000000 -0800
@@ -137,6 +137,8 @@ static inline int match_call_function(st
 
 extern void check_null_ptr_init(void);
 extern void check_null_ptr(struct entrypoint *ep);
+extern void check_interrupt(struct entrypoint *ep);
+extern void check_interrupt_init(void);
 
 #endif
 
Index: sparse/lib.h
===================================================================
--- sparse.orig/lib.h	2007-02-09 14:14:33.000000000 -0800
+++ sparse/lib.h	2007-02-09 14:15:08.000000000 -0800
@@ -97,6 +97,7 @@ extern int Wcast_truncate;
 extern int Wdo_while;
 extern int Wuninitialized;
 extern int Wmalloc;
+extern int Winterrupt;
 
 extern int dbg_entry;
 extern int dbg_dead;
Index: sparse/sparse.c
===================================================================
--- sparse.orig/sparse.c	2007-02-09 14:14:33.000000000 -0800
+++ sparse/sparse.c	2007-02-09 14:15:08.000000000 -0800
@@ -273,6 +273,8 @@ static void check_symbols(struct symbol_
 			check_context(ep);
 			if (Wmalloc)
 				check_null_ptr(ep);
+			if (Winterrupt)
+				check_interrupt(ep);
 		}
 	} END_FOR_EACH_PTR(sym);
 }
Index: sparse/check-interrupt.c
===================================================================
--- sparse.orig/check-interrupt.c	2007-02-09 14:15:08.000000000 -0800
+++ sparse/check-interrupt.c	2007-02-09 14:15:08.000000000 -0800
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2006 Christopher Li <sparse@chrisli.org>
+ *
+ *  Licensed under the Open Software License version 1.1
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "storage.h"
+#include "checker.h"
+
+
+static unsigned char current;
+static struct blob *hashed_state;
+static struct state_list *state_stack = NULL;
+static struct ptr_list *irq_enable_list;
+static struct ptr_list *irq_disable_list;
+static struct ptr_list *irq_restore_list;
+
+enum {
+	OP_IRQ_ENABLE = OP_LAST,
+	OP_IRQ_DISABLE,
+	OP_IRQ_RESTORE,
+};
+
+enum {
+	INTR_ENABLE,
+	INTR_DISABLE,
+};
+
+static inline void execute_enable(struct instruction *insn)
+{
+	if (current == INTR_ENABLE) {
+		warning(insn->pos, "checker function %s double enable",
+			show_ident(insn->bb->ep->name->ident));
+		return;
+	}
+	new_state(&state_stack, &current, INTR_ENABLE); 
+	hashed_state = NULL;
+}
+
+static inline void execute_disable(struct instruction *insn)
+{
+	if (current == INTR_DISABLE) {
+		warning(insn->pos, "checker function %s double enable",
+			show_ident(insn->bb->ep->name->ident));
+		return;
+	}
+	new_state(&state_stack, &current, INTR_DISABLE); 
+	hashed_state = NULL;
+}
+
+static inline void execute_ret(struct instruction *insn)
+{
+	if (current == INTR_DISABLE)
+		warning(insn->pos, "checker function %s exit with interrupt disabled",
+			show_ident(insn->bb->ep->name->ident));
+}
+
+static void check_bb(struct basic_block *bb)
+{
+	struct bb_state *bbs = bb->state;
+	struct instruction *insn;
+	int stacksize = ptr_list_size((struct ptr_list*)state_stack);
+	struct basic_block *child;
+
+	if (bbs->generation)
+		return;
+
+	if (!hashed_state)
+		hashed_state = create_hashed_blob(&current, 1);
+
+	/*
+	 * Try to find out if we execute the same state before. If the state is
+	 * same, there is not point try to execute it again.
+	 */
+	if (find_ptr_in_list((struct ptr_list*)bbs->cached_state, hashed_state))
+		return;
+
+	add_ptr_list(&bbs->cached_state, hashed_state);
+
+	bbs->generation = 1;
+
+	FOR_EACH_PTR(bbs->insns, insn) {
+		switch (insn->opcode) {
+		case OP_IRQ_DISABLE:
+			execute_disable(insn);
+			break;
+		case OP_IRQ_ENABLE:
+		case OP_IRQ_RESTORE:
+			execute_enable(insn);
+			break;
+		case OP_RET:
+			execute_ret(insn);
+			break;
+		}
+	} END_FOR_EACH_PTR(insn);
+
+	if (bbs->noret)
+		goto exit_bb;
+
+		
+	FOR_EACH_PTR(bb->children, child) {
+		check_bb(child);
+	} END_FOR_EACH_PTR(child);
+
+exit_bb:
+	if (ptr_list_size((struct ptr_list*)state_stack) > stacksize) {
+		revert_state(unsigned char, &state_stack, stacksize);
+		hashed_state = NULL;
+	}
+	bbs->generation = 0;
+}
+
+static inline void scan_call_instruction(struct bb_state *bbs, struct instruction *insn)
+{
+	pseudo_t fn = insn->func;
+	struct ident *name;
+
+	if (fn->type != PSEUDO_SYM)
+		return;
+ 	name = fn->sym->ident;
+	if (find_ptr_in_list(irq_enable_list, name))
+		add_instruction(&bbs->insns, checker_instruction(insn, OP_IRQ_ENABLE, NULL));
+	else if (find_ptr_in_list(irq_disable_list, name))
+		add_instruction(&bbs->insns, checker_instruction(insn, OP_IRQ_DISABLE, NULL));
+	else if (find_ptr_in_list(irq_restore_list, name))
+		add_instruction(&bbs->insns, checker_instruction(insn, OP_IRQ_RESTORE, NULL));
+}
+
+static inline void scan_interrupt_insn(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+	struct instruction *insn;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		struct bb_state *bbs = bb->state;
+		FOR_EACH_PTR(bb->insns, insn) {
+			if (!insn->bb)
+				continue;
+
+			switch (insn->opcode) {
+			case OP_RET:
+				add_instruction(&bbs->insns, insn);
+				break;
+			case OP_INLINED_CALL:
+			case OP_CALL:
+				scan_call_instruction(bbs, insn);
+				break;
+			}
+		} END_FOR_EACH_PTR(insn);
+	} END_FOR_EACH_PTR(bb);
+}
+
+void check_interrupt_init(void)
+{
+	static const char *enable[] = {
+		"raw_local_irq_enable",
+		"raw_safe_halt",
+		"_spin_unlock_irq",
+		"_read_unlock_irq",
+		"_write_unlock_irq",
+		"schedule",		// XXX: is it always true?
+	};
+	static const char *disable[] = {
+		"raw_local_irq_disable",
+		"_spin_lock_irq",
+		"task_rq_lock",
+		"_spin_lock_irqsave",
+		"_read_lock_irq",
+		"_read_lock_irqsave",
+		"_write_lock_irq",
+		"_write_lock_irqsave",
+		"lock_timer_base",
+		"lock_timer",
+	};
+	static const char *restore[] = {
+		"raw_local_irq_restore",
+		"_spin_unlock_irqrestore",
+		"_read_unlock_irqrestore",
+		"_write_unlock_irqrestore",
+	};
+	
+	irq_enable_list = build_ident_list(enable);
+	irq_disable_list = build_ident_list(disable);
+	irq_restore_list = build_ident_list(restore);
+}
+
+void check_interrupt(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		bb->state = alloc_bb_state();
+	} END_FOR_EACH_PTR(bb);
+
+	current = INTR_ENABLE;
+	hashed_state = NULL;
+	scan_interrupt_insn(ep);
+	check_bb(ep->entry->bb);
+}
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH 7] Adding the interrupt checker
Date: Thu, 01 Mar 2007 06:07:06 +0000
Message-ID: <1172729226.2337.31.camel () dv>
--------------------
Hello!

On Fri, 2007-02-09 at 16:26 -0800, Christopher Li wrote:
> Changelog:
>  - Using the new inline function calling annotation to find
>    out the irq related call. It now works both inline and
>    external functions. Bonus is no more x86 asm any more.
>  - The noise level of interrupt check drop considerably.
>    I think it is less nosier than the context checking.
> 
> Signed-off-by: Christopher Li<sparse@chrisli.org>
[skip]
> +	static const char *enable[] = {
> +		"raw_local_irq_enable",
> +		"raw_safe_halt",
> +		"_spin_unlock_irq",
> +		"_read_unlock_irq",
> +		"_write_unlock_irq",
> +		"schedule",		// XXX: is it always true?
> +	};

Sorry for late comments.  I actually applied the series to my copy of
sparse, and I found today that it catches schedule() for no reason.

"schedule" doesn't belong here.  It doesn't enable or disable
interrupts.  However, it requires interrupts to be enabled.  Annotating
functions requiring a specific context is not covered by your patch, so
I think it would be better to drop "schedule" from this list.

This patch helped me find some places where interrupts were disabled and
enabled twice.  But the output is confusing:

/home/proski/src/madwifi/net80211/ieee80211_node.c:1631:2: warning:
checker function ieee80211_timeout_stations double enable

It's not even clear that the message is about interrupts.  And the
"checker function" part is quite useless.  See other sparse warnings to
compare the style.

I think the patch is mildly useful, but shouldn't be applied as is.

Moreover, I think that incorrect use of locking is a remaining major
issue not covered by sparse.  Runtime checks only cover the code that is
executed.  Besides, the don't enforce better coding style.

I think all functions capable of supporting atomic contexts should be
annotated as such, and sparse should be always aware of the allowed
locking contexts for the code.

This would be a major, major change, perhaps more intrusive than the
endianess annotation.  But I think it would be worth the trouble.  It
would probably catch hundreds of bugs capable of hosing a working
system.

Another nice feature would be to annotate data so that it can be
accessed with certain locks held.  That would catch even more bugs, but
first sparse should be made lock aware.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7] Allow more than one command line include file. ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 7] Allow more than one command line include file.
Date: Sat, 27 Jan 2007 08:39:40 +0000
Message-ID: <45BB0FCC.1090700 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig987E834EAE79D39E6096FEE4
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> --- sparse.orig/lib.c	2006-12-05 16:17:39.000000000 -0800
> +++ sparse/lib.c	2006-12-22 01:51:00.000000000 -0800
> @@ -192,7 +192,10 @@ int Wdo_while =3D 1;
>  int Wuninitialized =3D 1;
>  int preprocess_only;
>  char *include;
> -int include_fd =3D -1;
> +
> +#define CMDLINE_INCLUDE 20
> +int cmdline_include_nr =3D 0;
> +struct cmdline_include cmdline_include[CMDLINE_INCLUDE];
[...]

I've accepted this patch for now, since a larger finite limit will solve =
the
current problem.  I'd really like to see something which handles an arbit=
rary
number of include files, though.  Also, ideally Sparse could read each
filename, parse that include file, and close it, rather than keeping all =
the
include files open; doing something like that might even avoid the need t=
o
keep them around in an array.

- Josh Triplett


--------------enig987E834EAE79D39E6096FEE4
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFuw/MGJuZRtD+evsRAmq5AKChARekVR96pXtHwLqkYbCoP+0JrQCdHKWZ
G1iksfcGFYmFPjwDU83t22s=
=6qGB
-----END PGP SIGNATURE-----

--------------enig987E834EAE79D39E6096FEE4--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 8/8] deal correctly with qualifiers on arrays ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 8/8] deal correctly with qualifiers on arrays
Date: Fri, 13 Jul 2007 17:45:37 +0000
Message-ID: <E1I9PCz-0000FX-65 () ZenIV ! linux ! org ! uk>
--------------------

* new helper: examine_pointer_target().  Examine target, find address_space
et.al.  If the target is SYM_NODE - merge it, etc.
* new helper: target_qualifiers().  Pointers to any array are considered
as pointers to unqualified type as far as implicit conversions are
concerned; handle that right.
* SYM_TYPEOF can be handled sanely now: don't copy the node, just convert
SYM_TYPEOF to SYM_NODE and examine that.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |   71 +++++++++++++++++++++++++++++++----------------------------
 symbol.c   |   37 ++++++++++++++++---------------
 symbol.h   |    1 +
 3 files changed, 57 insertions(+), 52 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 213039b..db33442 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -703,12 +703,12 @@ const char *type_difference(struct ctype *c1, struct ctype *c2,
 			if ((mod1 ^ mod2) & ~MOD_IGNORE & ~MOD_SPECIFIER)
 				return "different modifiers";
 			/* we could be lazier here */
+			base1 = examine_pointer_target(t1);
+			base2 = examine_pointer_target(t2);
 			mod1 = t1->ctype.modifiers;
 			as1 = t1->ctype.as;
 			mod2 = t2->ctype.modifiers;
 			as2 = t2->ctype.as;
-			base1 = examine_symbol_type(base1);
-			base2 = examine_symbol_type(base2);
 			break;
 		case SYM_FN: {
 			struct symbol *arg1, *arg2;
@@ -801,10 +801,17 @@ static void bad_null(struct expression *expr)
 		warning(expr->pos, "Using plain integer as NULL pointer");
 }
 
+static unsigned long target_qualifiers(struct symbol *type)
+{
+	unsigned long mod = type->ctype.modifiers & MOD_IGN;
+	if (type->ctype.base_type && type->ctype.base_type->type == SYM_ARRAY)
+		mod = 0;
+	return mod;
+}
+
 static struct symbol *evaluate_ptr_sub(struct expression *expr)
 {
 	const char *typediff;
-	struct symbol *ctype;
 	struct symbol *ltype, *rtype;
 	struct expression *l = expr->left;
 	struct expression *r = expr->right;
@@ -813,28 +820,25 @@ static struct symbol *evaluate_ptr_sub(struct expression *expr)
 	classify_type(degenerate(l), &ltype);
 	classify_type(degenerate(r), &rtype);
 
-	lbase = get_base_type(ltype);
-	rbase = get_base_type(rtype);
+	lbase = examine_pointer_target(ltype);
+	rbase = examine_pointer_target(rtype);
 	typediff = type_difference(&ltype->ctype, &rtype->ctype,
-				   MOD_IGN, MOD_IGN);
+				   target_qualifiers(rtype),
+				   target_qualifiers(ltype));
 	if (typediff)
 		expression_error(expr, "subtraction of different types can't work (%s)", typediff);
 
-	ctype = lbase;
-	/* Figure out the base type we point to */
-	if (ctype->type == SYM_NODE)
-		ctype = ctype->ctype.base_type;
-	if (ctype->type == SYM_FN) {
+	if (lbase->type == SYM_FN) {
 		expression_error(expr, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 
 	expr->ctype = ssize_t_ctype;
-	if (ctype->bit_size > bits_in_char) {
+	if (lbase->bit_size > bits_in_char) {
 		struct expression *sub = alloc_expression(expr->pos, EXPR_BINOP);
 		struct expression *div = expr;
 		struct expression *val = alloc_expression(expr->pos, EXPR_VALUE);
-		unsigned long value = ctype->bit_size >> 3;
+		unsigned long value = lbase->bit_size >> 3;
 
 		val->ctype = size_t_ctype;
 		val->value = value;
@@ -1050,8 +1054,8 @@ static struct symbol *evaluate_compare(struct expression *expr)
 		return bad_expr_type(expr);
 	expr->op = modify_for_unsigned(expr->op);
 
-	lbase = get_base_type(ltype);
-	rbase = get_base_type(rtype);
+	lbase = examine_pointer_target(ltype);
+	rbase = examine_pointer_target(rtype);
 
 	/* they also have special treatment for pointers to void */
 	if (expr->op == SPECIAL_EQUAL || expr->op == SPECIAL_NOTEQUAL) {
@@ -1068,7 +1072,8 @@ static struct symbol *evaluate_compare(struct expression *expr)
 	}
 
 	typediff = type_difference(&ltype->ctype, &rtype->ctype,
-				   MOD_IGN, MOD_IGN);
+				   target_qualifiers(rtype),
+				   target_qualifiers(ltype));
 	if (!typediff)
 		goto OK;
 
@@ -1164,10 +1169,9 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 		}
 
 		/* need to be lazier here */
-		lbase = get_base_type(ltype);
-		rbase = get_base_type(rtype);
-		qual = ltype->ctype.modifiers | rtype->ctype.modifiers;
-		qual &= MOD_CONST | MOD_VOLATILE;
+		lbase = examine_pointer_target(ltype);
+		rbase = examine_pointer_target(rtype);
+		qual = target_qualifiers(ltype) | target_qualifiers(rtype);
 
 		if (lbase == &void_ctype) {
 			/* XXX: pointers to function should warn here */
@@ -1183,7 +1187,7 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 		/* XXX: that should be pointer to composite */
 		ctype = ltype;
 		typediff = type_difference(&ltype->ctype, &rtype->ctype,
-					   MOD_IGN, MOD_IGN);
+					   qual, qual);
 		if (!typediff)
 			goto Qual;
 		goto Err;
@@ -1314,11 +1318,10 @@ static int compatible_assignment_types(struct expression *expr, struct symbol *t
 			typediff = "different base types";
 			goto Err;
 		}
-		/* we should be more lazy here */
-		mod1 = t->ctype.modifiers;
-		mod2 = s->ctype.modifiers;
-		b1 = get_base_type(t);
-		b2 = get_base_type(s);
+		b1 = examine_pointer_target(t);
+		b2 = examine_pointer_target(s);
+		mod1 = target_qualifiers(t);
+		mod2 = target_qualifiers(s);
 		if (b1 == &void_ctype || b2 == &void_ctype) {
 			/*
 			 * assignments to/from void * are OK, provided that
@@ -1329,15 +1332,14 @@ static int compatible_assignment_types(struct expression *expr, struct symbol *t
 				typediff = "different address spaces";
 				goto Err;
 			}
-			if (mod2 & ~mod1 & MOD_IGN) {
+			if (mod2 & ~mod1) {
 				typediff = "different modifiers";
 				goto Err;
 			}
 			goto Cast;
 		}
 		/* It's OK if the target is more volatile or const than the source */
-		typediff = type_difference(&t->ctype, &s->ctype,
-					   0, mod1 & MOD_IGN);
+		typediff = type_difference(&t->ctype, &s->ctype, 0, mod1);
 		if (typediff)
 			goto Err;
 		return 1;
@@ -2623,9 +2625,6 @@ static struct symbol *evaluate_cast(struct expression *expr)
 	if (class1 & TYPE_COMPOUND)
 		warning(expr->pos, "cast to non-scalar");
 
-	if (class1 == TYPE_PTR)
-		get_base_type(t1);
-
 	t2 = target->ctype;
 	if (!t2) {
 		expression_error(expr, "cast from unknown type");
@@ -2652,13 +2651,17 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 	if (t1 == &ulong_ctype)
 		as1 = -1;
-	else if (class1 == TYPE_PTR)
+	else if (class1 == TYPE_PTR) {
+		examine_pointer_target(t1);
 		as1 = t1->ctype.as;
+	}
 
 	if (t2 == &ulong_ctype)
 		as2 = -1;
-	else if (class2 == TYPE_PTR)
+	else if (class2 == TYPE_PTR) {
+		examine_pointer_target(t2);
 		as2 = t2->ctype.as;
+	}
 
 	if (!as1 && as2 > 0)
 		warning(expr->pos, "cast removes address space of expression");
diff --git a/symbol.c b/symbol.c
index 9dfeb41..a64815c 100644
--- a/symbol.c
+++ b/symbol.c
@@ -193,13 +193,16 @@ static struct symbol *examine_base_type(struct symbol *sym)
 	struct symbol *base_type;
 
 	/* Check the base type */
-	base_type = sym->ctype.base_type;
-	if (base_type) {
-		base_type = examine_symbol_type(base_type);
-
-		/* "typeof" can cause this */
-		if (base_type && base_type->type == SYM_NODE)
-			merge_type(sym, base_type);
+	base_type = examine_symbol_type(sym->ctype.base_type);
+	if (!base_type || base_type->type == SYM_PTR)
+		return base_type;
+	sym->ctype.as |= base_type->ctype.as;
+	sym->ctype.modifiers |= base_type->ctype.modifiers & MOD_PTRINHERIT;
+	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
+			(struct ptr_list **)&sym->ctype.contexts);
+	if (base_type->type == SYM_NODE) {
+		base_type = base_type->ctype.base_type;
+		sym->ctype.base_type = base_type;
 	}
 	return base_type;
 }
@@ -410,17 +413,10 @@ struct symbol *examine_symbol_type(struct symbol * sym)
 				warning(base->pos, "typeof applied to bitfield type");
 			if (base->type == SYM_NODE)
 				base = base->ctype.base_type;
-			switch (base->type) {
-			case SYM_RESTRICT:
-			case SYM_UNION:
-			case SYM_STRUCT:
-				sym->type = SYM_NODE;
-				sym->ctype.modifiers = 0;
-				sym->ctype.base_type = base;
-				return examine_node_type(sym);
-			}
-			*sym = *base;
-			break;
+			sym->type = SYM_NODE;
+			sym->ctype.modifiers = 0;
+			sym->ctype.base_type = base;
+			return examine_node_type(sym);
 		}
 		break;
 	}
@@ -443,6 +439,11 @@ struct symbol *examine_symbol_type(struct symbol * sym)
 	return sym;
 }
 
+struct symbol *examine_pointer_target(struct symbol *sym)
+{
+	return examine_base_type(sym);
+}
+
 static struct symbol_list *restr, *fouled;
 
 void create_fouled(struct symbol *type)
diff --git a/symbol.h b/symbol.h
index bf5b675..9b24f40 100644
--- a/symbol.h
+++ b/symbol.h
@@ -263,6 +263,7 @@ extern void add_symbol(struct symbol_list **, struct symbol *);
 extern void bind_symbol(struct symbol *, struct ident *, enum namespace);
 
 extern struct symbol *examine_symbol_type(struct symbol *);
+extern struct symbol *examine_pointer_target(struct symbol *);
 extern void examine_simple_symbol_type(struct symbol *);
 extern const char *show_typename(struct symbol *sym);
 extern const char *builtin_typename(struct symbol *sym);
-- 
1.5.0-rc2.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 8] Enhance debug information. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 8] Enhance debug information.
Date: Wed, 17 Jan 2007 02:42:39 +0000
Message-ID: <20070117024239.GI962 () chrisli ! org>
--------------------
I found it very useful for debug_symbol to show the builtin
type name.

Signed-off-by: Christopher Li<sparse@chrisli.org>

Index: sparse/symbol.h
===================================================================
--- sparse.orig/symbol.h	2006-12-14 20:26:32.000000000 -0800
+++ sparse/symbol.h	2006-12-14 20:28:01.000000000 -0800
@@ -239,6 +239,8 @@ extern void bind_symbol(struct symbol *,
 extern struct symbol *examine_symbol_type(struct symbol *);
 extern void examine_simple_symbol_type(struct symbol *);
 extern const char *show_typename(struct symbol *sym);
+extern const char* builtin_typename(struct symbol *sym);
+extern const char* builtin_ctypename(struct ctype *ctype);
 
 extern void debug_symbol(struct symbol *);
 extern void merge_type(struct symbol *sym, struct symbol *base_type);
Index: sparse/show-parse.c
===================================================================
--- sparse.orig/show-parse.c	2006-12-14 20:26:32.000000000 -0800
+++ sparse/show-parse.c	2006-12-14 20:28:01.000000000 -0800
@@ -56,11 +56,12 @@ static void do_debug_symbol(struct symbo
 
 	if (!sym)
 		return;
-	fprintf(stderr, "%.*s%s%3d:%lu %lx %s (as: %d) %p (%s:%d:%d)\n",
+	fprintf(stderr, "%.*s%s%3d:%lu %s %s (as: %d) %p (%s:%d:%d) %s\n",
 		indent, indent_string, typestr[sym->type],
 		sym->bit_size, sym->ctype.alignment,
-		sym->ctype.modifiers, show_ident(sym->ident), sym->ctype.as,
-		sym, stream_name(sym->pos.stream), sym->pos.line, sym->pos.pos);
+		modifier_string(sym->ctype.modifiers), show_ident(sym->ident), sym->ctype.as,
+		sym, stream_name(sym->pos.stream), sym->pos.line, sym->pos.pos,
+		builtin_typename(sym) ?: "");
 	i = 0;
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
 		/* FIXME: should print context expression */
@@ -98,7 +99,7 @@ const char *modifier_string(unsigned lon
 	const char *res,**ptr, *names[] = {
 		"auto", "register", "static", "extern",
 		"const", "volatile", "[signed]", "[unsigned]",
-		"[char]", "[short]", "[long]", "[long]",
+		"[char]", "[short]", "[long]", "[long long]",
 		"[typdef]", "[structof]", "[unionof]", "[enum]",
 		"[typeof]", "[attribute]", "inline", "[addressable]",
 		"[nocast]", "[noderef]", "[accessed]", "[toplevel]",
@@ -171,53 +172,74 @@ static void append(struct type_name *nam
 	name->end += n;
 }
 
+static struct ctype_name {
+	struct symbol *sym;
+	const char *name;
+} typenames[] = {
+	{ & char_ctype,  "char" },
+	{ &schar_ctype,  "signed char" },
+	{ &uchar_ctype,  "unsigned char" },
+	{ & short_ctype, "short" },
+	{ &sshort_ctype, "signed short" },
+	{ &ushort_ctype, "unsigned short" },
+	{ & int_ctype,   "int" },
+	{ &sint_ctype,   "signed int" },
+	{ &uint_ctype,   "unsigned int" },
+	{ &slong_ctype,  "signed long" },
+	{ & long_ctype,  "long" },
+	{ &ulong_ctype,  "unsigned long" },
+	{ & llong_ctype, "long long" },
+	{ &sllong_ctype, "signed long long" },
+	{ &ullong_ctype, "unsigned long long" },
+
+	{ &void_ctype,   "void" },
+	{ &bool_ctype,   "bool" },
+	{ &string_ctype, "string" },
+
+	{ &float_ctype,  "float" },
+	{ &double_ctype, "double" },
+	{ &ldouble_ctype,"long double" },
+	{ &incomplete_ctype, "incomplete type" },
+	{ &int_type, "abstract int" },
+	{ &fp_type, "abstract fp" },
+	{ &label_ctype, "label type" },
+	{ &bad_ctype, "bad type" },
+};
+
+const char* builtin_typename(struct symbol *sym)
+{
+	int i;
+
+	for (i = 0; i < sizeof(typenames)/sizeof(typenames[0]); i++)
+		if (typenames[i].sym == sym)
+			return typenames[i].name;
+	return NULL;
+}
+
+const char* builtin_ctypename(struct ctype *ctype)
+{
+	int i;
+
+	for (i = 0; i < sizeof(typenames)/sizeof(typenames[0]); i++)
+		if (&typenames[i].sym->ctype == ctype)
+			return typenames[i].name;
+	return NULL;
+}
+
 static void do_show_type(struct symbol *sym, struct type_name *name)
 {
-	int i, modlen;
+	int modlen;
 	const char *mod;
-	static struct ctype_name {
-		struct symbol *sym;
-		const char *name;
-	} typenames[] = {
-		{ & char_ctype,  "char" },
-		{ &schar_ctype,  "signed char" },
-		{ &uchar_ctype,  "unsigned char" },
-		{ & short_ctype, "short" },
-		{ &sshort_ctype, "signed short" },
-		{ &ushort_ctype, "unsigned short" },
-		{ & int_ctype,   "int" },
-		{ &sint_ctype,   "signed int" },
-		{ &uint_ctype,   "unsigned int" },
-		{ &slong_ctype,  "signed long" },
-		{ & long_ctype,  "long" },
-		{ &ulong_ctype,  "unsigned long" },
-		{ & llong_ctype, "long long" },
-		{ &sllong_ctype, "signed long long" },
-		{ &ullong_ctype, "unsigned long long" },
-
-		{ &void_ctype,   "void" },
-		{ &bool_ctype,   "bool" },
-		{ &string_ctype, "string" },
-
-		{ &float_ctype,  "float" },
-		{ &double_ctype, "double" },
-		{ &ldouble_ctype,"long double" },
-		{ &incomplete_ctype, "incomplete type" },
-		{ &label_ctype, "label type" },
-		{ &bad_ctype, "bad type" },
-	};
-
+	const char *typename;
 	if (!sym)
 		return;
 
-	for (i = 0; i < sizeof(typenames)/sizeof(typenames[0]); i++) {
-		if (typenames[i].sym == sym) {
-			int len = strlen(typenames[i].name);
-			*--name->start = ' ';
-			name->start -= len;
-			memcpy(name->start, typenames[i].name, len);
-			return;
-		}
+	if ((typename = builtin_typename(sym))) {
+		int len = strlen(typename);
+		*--name->start = ' ';
+		name->start -= len;
+		memcpy(name->start, typename, len);
+		return;
 	}
 
 	/* Prepend */
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 8] Enhance debug information.
Date: Sat, 27 Jan 2007 08:48:42 +0000
Message-ID: <45BB11EA.4060409 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig518AAA67EF57DB87D55ED583
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> I found it very useful for debug_symbol to show the builtin
> type name.

Applied, with one minor style fix noted below.

> Signed-off-by: Christopher Li<sparse@chrisli.org>
>=20
> Index: sparse/symbol.h
> =3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
> --- sparse.orig/symbol.h	2006-12-14 20:26:32.000000000 -0800
> +++ sparse/symbol.h	2006-12-14 20:28:01.000000000 -0800
> @@ -239,6 +239,8 @@ extern void bind_symbol(struct symbol *,
>  extern struct symbol *examine_symbol_type(struct symbol *);
>  extern void examine_simple_symbol_type(struct symbol *);
>  extern const char *show_typename(struct symbol *sym);
> +extern const char* builtin_typename(struct symbol *sym);
> +extern const char* builtin_ctypename(struct ctype *ctype);

The * goes next to the name, not the type:
=2E..char *builtin_..., not ...char* builtin_...

(The same issue applied to the definition of these two functions as well.=
)

- Josh Triplett



--------------enig518AAA67EF57DB87D55ED583
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFuxHqGJuZRtD+evsRAhu/AJ9ANfkprub1uscnmWpFPCirKL9OpACeMtBv
qclQxEvd0y8nOARoJD4WwWA=
=a4vu
-----END PGP SIGNATURE-----

--------------enig518AAA67EF57DB87D55ED583--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr. ===

From: "Russ Cox" <rsc () swtch ! com>
To: linux-kernel
Subject: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr.
Date: Mon, 26 Mar 2007 15:23:56 +0000
Message-ID: <ee9e417a0703260823k55c6de8ay715be1db11692355 () mail ! gmail ! com>
--------------------
Change prototypes for  __chk_user_ptr and __chk_io_ptr
to take const void* instead of void*, so that code can pass
const void* to them.  (Right now sparse does not warn
about passing const void* to void* functions, but that
is a separate bug that I believe Josh is working on,
and once sparse does check this, the changed prototypes
will be necessary.)

Signed-off-by: Russ Cox <rsc@swtch.com>
Signed-off-by: Josh Triplett <josh@freedesktop.org>

---

 include/linux/compiler.h |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

e5174dfa73190036ae1086110292594a3ffb3752
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index aca6698..3b6949b 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -15,8 +15,8 @@
 # define __acquire(x)	__context__(x,1)
 # define __release(x)	__context__(x,-1)
 # define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
-extern void __chk_user_ptr(void __user *);
-extern void __chk_io_ptr(void __iomem *);
+extern void __chk_user_ptr(const void __user *);
+extern void __chk_io_ptr(const void __iomem *);
 #else
 # define __user
 # define __kernel
-- 
1.1.3
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr.
Date: Mon, 26 Mar 2007 18:01:55 +0000
Message-ID: <20070326180155.GA24764 () chrisli ! org>
--------------------
On Mon, Mar 26, 2007 at 11:23:56AM -0400, Russ Cox wrote:
> Change prototypes for  __chk_user_ptr and __chk_io_ptr
> to take const void* instead of void*, so that code can pass
> const void* to them.  (Right now sparse does not warn
> about passing const void* to void* functions, but that
> is a separate bug that I believe Josh is working on,
> and once sparse does check this, the changed prototypes
> will be necessary.)

I don't think it is needed. The __user has noderef attribute.
Which means it is not allow to dereference the pointer. The
const qualifier allow read dereference, only write is not allowed.

Adding const here will likely force the caller to do a cast at
the pointer arguments. Which defeats the checker.

Sparse allow passing const void* to void* is a different issue.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr.
Date: Mon, 26 Mar 2007 18:01:55 +0000
Message-ID: <20070326180155.GA24764 () chrisli ! org>
--------------------
On Mon, Mar 26, 2007 at 11:23:56AM -0400, Russ Cox wrote:
> Change prototypes for  __chk_user_ptr and __chk_io_ptr
> to take const void* instead of void*, so that code can pass
> const void* to them.  (Right now sparse does not warn
> about passing const void* to void* functions, but that
> is a separate bug that I believe Josh is working on,
> and once sparse does check this, the changed prototypes
> will be necessary.)

I don't think it is needed. The __user has noderef attribute.
Which means it is not allow to dereference the pointer. The
const qualifier allow read dereference, only write is not allowed.

Adding const here will likely force the caller to do a cast at
the pointer arguments. Which defeats the checker.

Sparse allow passing const void* to void* is a different issue.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr.
Date: Mon, 26 Mar 2007 18:46:56 +0000
Message-ID: <20070326184656.GB24841 () chrisli ! org>
--------------------
On Mon, Mar 26, 2007 at 02:59:39PM -0400, Russ Cox wrote:
> No, you have it backward.
> It is valid to pass void* to a const void* function.
> It is *not* valid to pass const void* to a void* function.
> 
> Right now __chk_user_ptr is a void* function, meaning
> that all the places where it gets passed a const void*
> are technically illegal -- gcc would warn about these, and
> it is a (separate, as you observed) bug that sparse does not.
> 
> The patch changes __chk_user_ptr to be a const void*
> function, meaning that it will be legal to pass either void*
> or const void* to it.  This is the correct semantics.

Hah, I see. Thanks for the explain.

Ack.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr.
Date: Mon, 26 Mar 2007 18:46:56 +0000
Message-ID: <20070326184656.GB24841 () chrisli ! org>
--------------------
On Mon, Mar 26, 2007 at 02:59:39PM -0400, Russ Cox wrote:
> No, you have it backward.
> It is valid to pass void* to a const void* function.
> It is *not* valid to pass const void* to a void* function.
> 
> Right now __chk_user_ptr is a void* function, meaning
> that all the places where it gets passed a const void*
> are technically illegal -- gcc would warn about these, and
> it is a (separate, as you observed) bug that sparse does not.
> 
> The patch changes __chk_user_ptr to be a const void*
> function, meaning that it will be legal to pass either void*
> or const void* to it.  This is the correct semantics.

Hah, I see. Thanks for the explain.

Ack.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Russ Cox" <rsc () swtch ! com>
To: linux-sparse
Subject: Re: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr.
Date: Mon, 26 Mar 2007 18:59:39 +0000
Message-ID: <ee9e417a0703261159g6aeed343t58a98c5f45141c53 () mail ! gmail ! com>
--------------------
On 3/26/07, Christopher Li <sparse@chrisli.org> wrote:
> On Mon, Mar 26, 2007 at 11:23:56AM -0400, Russ Cox wrote:
> > Change prototypes for  __chk_user_ptr and __chk_io_ptr
> > to take const void* instead of void*, so that code can pass
> > const void* to them.  (Right now sparse does not warn
> > about passing const void* to void* functions, but that
> > is a separate bug that I believe Josh is working on,
> > and once sparse does check this, the changed prototypes
> > will be necessary.)
>
> I don't think it is needed. The __user has noderef attribute.
> Which means it is not allow to dereference the pointer. The
> const qualifier allow read dereference, only write is not allowed.
>
> Adding const here will likely force the caller to do a cast at
> the pointer arguments. Which defeats the checker.

No, you have it backward.
It is valid to pass void* to a const void* function.
It is *not* valid to pass const void* to a void* function.

Right now __chk_user_ptr is a void* function, meaning
that all the places where it gets passed a const void*
are technically illegal -- gcc would warn about these, and
it is a (separate, as you observed) bug that sparse does not.

The patch changes __chk_user_ptr to be a const void*
function, meaning that it will be legal to pass either void*
or const void* to it.  This is the correct semantics.

Russ
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Russ Cox" <rsc () swtch ! com>
To: linux-kernel
Subject: Re: [PATCH] Add const to pointer qualifiers for __chk_user_ptr and __chk_io_ptr.
Date: Mon, 26 Mar 2007 18:59:39 +0000
Message-ID: <ee9e417a0703261159g6aeed343t58a98c5f45141c53 () mail ! gmail ! com>
--------------------
On 3/26/07, Christopher Li <sparse@chrisli.org> wrote:
> On Mon, Mar 26, 2007 at 11:23:56AM -0400, Russ Cox wrote:
> > Change prototypes for  __chk_user_ptr and __chk_io_ptr
> > to take const void* instead of void*, so that code can pass
> > const void* to them.  (Right now sparse does not warn
> > about passing const void* to void* functions, but that
> > is a separate bug that I believe Josh is working on,
> > and once sparse does check this, the changed prototypes
> > will be necessary.)
>
> I don't think it is needed. The __user has noderef attribute.
> Which means it is not allow to dereference the pointer. The
> const qualifier allow read dereference, only write is not allowed.
>
> Adding const here will likely force the caller to do a cast at
> the pointer arguments. Which defeats the checker.

No, you have it backward.
It is valid to pass void* to a const void* function.
It is *not* valid to pass const void* to a void* function.

Right now __chk_user_ptr is a void* function, meaning
that all the places where it gets passed a const void*
are technically illegal -- gcc would warn about these, and
it is a (separate, as you observed) bug that sparse does not.

The patch changes __chk_user_ptr to be a const void*
function, meaning that it will be legal to pass either void*
or const void* to it.  This is the correct semantics.

Russ
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH] Beautify all & install Makefile targets ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Beautify all & install Makefile targets
Date: Mon, 21 May 2007 00:35:16 +0000
Message-ID: <4650E944.1060506 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigC8F22DA68C6A6654BECB0D54
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Damien Lespiau wrote:
> Beautify make's output like kbuild or git. The install
> target is especially much more readable.
> make V=3D1 (install) to get back to the old behaviour.

The Makefile currently doesn't require anything particularly special from=

make, and in theory should work with any reasonable make, not just GNU ma=
ke.
I hestitate to change that for purely aesthetic purposes.  The % rules se=
em
easy enough to replace with a suffix rule .c.o.  You can use substitution=
 to
check V, like this:

josh@josh-mobile:/tmp$ cat Makefile=20
V=3D@
Q=3D$(V:1=3D)
QUIET_SOMETHING=3D$(Q:@=3D@echo SOMETHING;)
#...

test:
        @echo V=3D$(V)
        @echo Q=3D$(Q)
        @echo QUIET_SOMETHING=3D$(QUIET_SOMETHING)
josh@josh-mobile:/tmp$ make
V=3D@
Q=3D@
QUIET_SOMETHING=3D@echo SOMETHING
josh@josh-mobile:/tmp$ make V=3D1
V=3D1
Q=3D
QUIET_SOMETHING=3D

You can write more rules of the form QUIET_SOMETHING=3D$(Q:@=3Dvalue if q=
uiet)

I'd also like to hear from other people on whether or not they prefer thi=
s
style of output.  It doesn't matter much to me either way.

> +	QUIET_LD       =3D @echo    '   ' LD'      '$@;

This always seems misleading to me, given that the corresponding rules ru=
n CC,
not LD.

> +	QUIET_INST_SH  =3D echo -n  '   ' INSTALL '';
> +	QUIET_INST     =3D @echo -n '   ' INSTALL '';

This doesn't appear to output the installed file; it took a minute to fig=
ure
out that install -v provides the output.  Could you add a comment about t=
hat?
Also, why not write these strings as (for example):

echo -n '    INSTALL '

? That seems cleaner than breaking the lines up into quoted whitespace an=
d
unquoted text.

> +%.o: %.c
> +	$(QUIET_CC)$(CC) -o $*.o -c $(CFLAGS) $<

I think you can use $@ here rather than $*.o .  Also, as mentioned above,=
 this
should become a suffix rule.

- Josh Triplett


--------------enigC8F22DA68C6A6654BECB0D54
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGUOlEGJuZRtD+evsRAga3AKCEYdfEMyi/6HE5qPbGOCpNTwzm/QCgmpgU
/o0Qmh/mJ0sTcMAZrJelIlo=
=K7NP
-----END PGP SIGNATURE-----

--------------enigC8F22DA68C6A6654BECB0D54--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Damien Lespiau" <damien.lespiau () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Beautify all & install Makefile targets
Date: Tue, 22 May 2007 18:28:11 +0000
Message-ID: <cbf3148c0705221128s884ad1l9a0986cee98445bb () mail ! gmail ! com>
--------------------
> I'd also like to hear from other people on whether or not they prefer this
> style of output.  It doesn't matter much to me either way.

That won't prevent me from resending a more decent patch :p

> > +     QUIET_LD       = @echo    '   ' LD'      '$@;
>
> This always seems misleading to me, given that the corresponding rules run CC,
> not LD.

Well, calling the linker through gcc front-end does not change the fact
that we are linking. To me CC or LD are just saying we are compiling
or linking.

I'll resend a patch, trying to take care of your comments.

-- 
Damien
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Change sparse homepage in ctags headers. ===

From: Damien Lespiau <damien.lespiau () gmail ! com>
To: linux-sparse
Subject: [PATCH] Change sparse homepage in ctags headers.
Date: Sun, 20 May 2007 21:59:06 +0000
Message-ID: <1179698346505-git-send-email-damien.lespiau () gmail ! com>
--------------------

Yup, sparse homepage changed.

Signed-off-by: Damien Lespiau <damien.lespiau@gmail.com>
---
 ctags.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/ctags.c b/ctags.c
index bdddcf7..cccee0a 100644
--- a/ctags.c
+++ b/ctags.c
@@ -45,7 +45,7 @@ static void show_tag_header(FILE *fp)
 	fprintf(fp, "!_TAG_FILE_SORTED\t0\t/0=unsorted, 1=sorted, 2=foldcase/\n");
 	fprintf(fp, "!_TAG_PROGRAM_AUTHOR\tChristopher Li\t/sparse@chrisli.org/\n");
 	fprintf(fp, "!_TAG_PROGRAM_NAME\tSparse Ctags\t//\n");
-	fprintf(fp, "!_TAG_PROGRAM_URL\thttp://kernel.org/pub/linux/kernel/people/josh/sparse/\t/official site/\n");
+	fprintf(fp, "!_TAG_PROGRAM_URL\thttp://www.kernel.org/pub/software/devel/sparse/\t/official site/\n");
 	fprintf(fp, "!_TAG_PROGRAM_VERSION\t0.01\t//\n");
 }
 
-- 
1.5.2.rc3.87.g404fd


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Change sparse homepage in ctags headers.
Date: Sun, 20 May 2007 22:26:22 +0000
Message-ID: <4650CB0E.8000306 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE363695F8A120F91CF0E8C37
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Damien Lespiau wrote:
> Yup, sparse homepage changed.

Applied; thanks!

- Josh Triplett



--------------enigE363695F8A120F91CF0E8C37
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGUMsOGJuZRtD+evsRAqJYAJ96ANrlMHxh+6aE899UrDljI7ef/QCdFX3Q
6Xqj1tl7DrrIDCm25Q4L/pc=
=Cpz8
-----END PGP SIGNATURE-----

--------------enigE363695F8A120F91CF0E8C37--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Change the symbol access list to pseudo list ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Change the symbol access list to pseudo list
Date: Wed, 17 Jan 2007 02:34:41 +0000
Message-ID: <20070117023441.GB962 () chrisli ! org>
--------------------
The pseudo list contain more information. It can
get to the symbol as well as the usage information.
Now it is much easier to answer the question like:
"what function does this functions calls to."

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/flow.c
===================================================================
--- sparse.orig/flow.c	2007-01-16 11:06:05.000000000 -0800
+++ sparse/flow.c	2007-01-16 11:07:09.000000000 -0800
@@ -709,11 +709,11 @@ external_visibility:
 
 void simplify_symbol_usage(struct entrypoint *ep)
 {
-	struct symbol *sym;
+	pseudo_t pseudo;
 
-	FOR_EACH_PTR(ep->accesses, sym) {
-		simplify_one_symbol(ep, sym);
-	} END_FOR_EACH_PTR(sym);
+	FOR_EACH_PTR(ep->accesses, pseudo) {
+		simplify_one_symbol(ep, pseudo->sym);
+	} END_FOR_EACH_PTR(pseudo);
 }
 
 static void mark_bb_reachable(struct basic_block *bb, unsigned long generation)
Index: sparse/linearize.h
===================================================================
--- sparse.orig/linearize.h	2007-01-16 11:06:05.000000000 -0800
+++ sparse/linearize.h	2007-01-16 11:07:09.000000000 -0800
@@ -294,7 +294,7 @@ static inline void replace_bb_in_list(st
 struct entrypoint {
 	struct symbol *name;
 	struct symbol_list *syms;
-	struct symbol_list *accesses;
+	struct pseudo_list *accesses;
 	struct basic_block_list *bbs;
 	struct basic_block *active;
 	struct instruction *entry;
Index: sparse/linearize.c
===================================================================
--- sparse.orig/linearize.c	2007-01-16 11:06:05.000000000 -0800
+++ sparse/linearize.c	2007-01-16 11:07:09.000000000 -0800
@@ -735,11 +735,11 @@ pseudo_t alloc_pseudo(struct instruction
 
 static void clear_symbol_pseudos(struct entrypoint *ep)
 {
-	struct symbol *sym;
+	pseudo_t pseudo;
 
-	FOR_EACH_PTR(ep->accesses, sym) {
-		sym->pseudo = NULL;
-	} END_FOR_EACH_PTR(sym);
+	FOR_EACH_PTR(ep->accesses, pseudo) {
+		pseudo->sym->pseudo = NULL;
+	} END_FOR_EACH_PTR(pseudo);
 }
 
 static pseudo_t symbol_pseudo(struct entrypoint *ep, struct symbol *sym)
@@ -757,7 +757,7 @@ static pseudo_t symbol_pseudo(struct ent
 		pseudo->sym = sym;
 		pseudo->ident = sym->ident;
 		sym->pseudo = pseudo;
-		add_symbol(&ep->accesses, sym);
+		add_pseudo(&ep->accesses, pseudo);
 	}
 	/* Symbol pseudos have neither nr, usage nor def */
 	return pseudo;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Change the symbol access list to pseudo list
Date: Wed, 17 Jan 2007 04:43:48 +0000
Message-ID: <45ADA984.6060509 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigBC50E0216E8DD22F176526AF
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> The pseudo list contain more information. It can
> get to the symbol as well as the usage information.
> Now it is much easier to answer the question like:
> "what function does this functions calls to."
>=20
> Signed-Off-By: Christopher Li <sparse@chrisli.org>

Good idea.  Merged.

- Josh Triplett



--------------enigBC50E0216E8DD22F176526AF
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFramEGJuZRtD+evsRAir1AKCzUZqo2rqWqg/5UTCpdOqjE+3WZwCgtDLA
+PY2S4pl6F8LzKhBHTTX/hg=
=aZsy
-----END PGP SIGNATURE-----

--------------enigBC50E0216E8DD22F176526AF--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] CodingStyle: proscribe do-while without braces. ===

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Thu, 26 Jul 2007 21:44:06 +0000
Message-ID: <20070726144406.63c07909.akpm () linux-foundation ! org>
--------------------
On Thu, 26 Jul 2007 14:37:02 -0700 Josh Triplett <josht@linux.vnet.ibm.com> wrote:

> Sparse warns about do-while loops without braces; Linus's rationale from the
> Sparse Git changelog:
> > Add warning message for naked do-while
> >
> > Does it necessarily make sense? Dunno, but it does tend to be bad
> > practice, or at least result in code that can be hard to mentally parse.
> >
> > Maybe that mental parsing is just me.	 Or maybe it should be warned
> > about. You decide.
> 
> Signed-off-by: Josh Triplett <josh@kernel.org>
> ---
>  Documentation/CodingStyle |    7 +++++++
>  1 files changed, 7 insertions(+), 0 deletions(-)
> 
> diff --git a/Documentation/CodingStyle b/Documentation/CodingStyle
> index 7f1730f..f12e4b8 100644
> --- a/Documentation/CodingStyle
> +++ b/Documentation/CodingStyle
> @@ -175,6 +175,13 @@ if (condition) {
>  	otherwise();
>  }
>  
> +This also does not apply to a do-while loop; always use braces with a do-while,
> +even if it contains a single statement:
> +
> +do {
> +	this();
> +} while(condition);
> +

err, your example has broken coding style.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Thu, 26 Jul 2007 21:44:06 +0000
Message-ID: <20070726144406.63c07909.akpm () linux-foundation ! org>
--------------------
On Thu, 26 Jul 2007 14:37:02 -0700 Josh Triplett <josht@linux.vnet.ibm.com> wrote:

> Sparse warns about do-while loops without braces; Linus's rationale from the
> Sparse Git changelog:
> > Add warning message for naked do-while
> >
> > Does it necessarily make sense? Dunno, but it does tend to be bad
> > practice, or at least result in code that can be hard to mentally parse.
> >
> > Maybe that mental parsing is just me.	 Or maybe it should be warned
> > about. You decide.
> 
> Signed-off-by: Josh Triplett <josh@kernel.org>
> ---
>  Documentation/CodingStyle |    7 +++++++
>  1 files changed, 7 insertions(+), 0 deletions(-)
> 
> diff --git a/Documentation/CodingStyle b/Documentation/CodingStyle
> index 7f1730f..f12e4b8 100644
> --- a/Documentation/CodingStyle
> +++ b/Documentation/CodingStyle
> @@ -175,6 +175,13 @@ if (condition) {
>  	otherwise();
>  }
>  
> +This also does not apply to a do-while loop; always use braces with a do-while,
> +even if it contains a single statement:
> +
> +do {
> +	this();
> +} while(condition);
> +

err, your example has broken coding style.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Thu, 26 Jul 2007 21:54:55 +0000
Message-ID: <1185486895.4459.3.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-26 at 14:44 -0700, Andrew Morton wrote:
> On Thu, 26 Jul 2007 14:37:02 -0700 Josh Triplett <josht@linux.vnet.ibm.com> wrote:
> 
> > Sparse warns about do-while loops without braces; Linus's rationale from the
> > Sparse Git changelog:
> > > Add warning message for naked do-while
> > >
> > > Does it necessarily make sense? Dunno, but it does tend to be bad
> > > practice, or at least result in code that can be hard to mentally parse.
> > >
> > > Maybe that mental parsing is just me.	 Or maybe it should be warned
> > > about. You decide.
> > 
> > Signed-off-by: Josh Triplett <josh@kernel.org>
> > ---
> >  Documentation/CodingStyle |    7 +++++++
> >  1 files changed, 7 insertions(+), 0 deletions(-)
> > 
> > diff --git a/Documentation/CodingStyle b/Documentation/CodingStyle
> > index 7f1730f..f12e4b8 100644
> > --- a/Documentation/CodingStyle
> > +++ b/Documentation/CodingStyle
> > @@ -175,6 +175,13 @@ if (condition) {
> >  	otherwise();
> >  }
> >  
> > +This also does not apply to a do-while loop; always use braces with a do-while,
> > +even if it contains a single statement:
> > +
> > +do {
> > +	this();
> > +} while(condition);
> > +
> 
> err, your example has broken coding style.

Oops; thanks for catching that. :)

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Thu, 26 Jul 2007 21:54:55 +0000
Message-ID: <1185486895.4459.3.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-26 at 14:44 -0700, Andrew Morton wrote:
> On Thu, 26 Jul 2007 14:37:02 -0700 Josh Triplett <josht@linux.vnet.ibm.com> wrote:
> 
> > Sparse warns about do-while loops without braces; Linus's rationale from the
> > Sparse Git changelog:
> > > Add warning message for naked do-while
> > >
> > > Does it necessarily make sense? Dunno, but it does tend to be bad
> > > practice, or at least result in code that can be hard to mentally parse.
> > >
> > > Maybe that mental parsing is just me.	 Or maybe it should be warned
> > > about. You decide.
> > 
> > Signed-off-by: Josh Triplett <josh@kernel.org>
> > ---
> >  Documentation/CodingStyle |    7 +++++++
> >  1 files changed, 7 insertions(+), 0 deletions(-)
> > 
> > diff --git a/Documentation/CodingStyle b/Documentation/CodingStyle
> > index 7f1730f..f12e4b8 100644
> > --- a/Documentation/CodingStyle
> > +++ b/Documentation/CodingStyle
> > @@ -175,6 +175,13 @@ if (condition) {
> >  	otherwise();
> >  }
> >  
> > +This also does not apply to a do-while loop; always use braces with a do-while,
> > +even if it contains a single statement:
> > +
> > +do {
> > +	this();
> > +} while(condition);
> > +
> 
> err, your example has broken coding style.

Oops; thanks for catching that. :)

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Krzysztof Halasa <khc () pm ! waw ! pl>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 00:18:34 +0000
Message-ID: <m3abtir95x.fsf () maximus ! localdomain>
--------------------
Josh Triplett <josht@linux.vnet.ibm.com> writes:

> +This also does not apply to a do-while loop; always use braces with a do-while,
> +even if it contains a single statement:

I can't see anything wrong with

do
	abc;
while (xyz);


and even if I could, "always use" seems way too strong in this case.
-- 
Krzysztof Halasa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Krzysztof Halasa <khc () pm ! waw ! pl>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 00:18:34 +0000
Message-ID: <m3abtir95x.fsf () maximus ! localdomain>
--------------------
Josh Triplett <josht@linux.vnet.ibm.com> writes:

> +This also does not apply to a do-while loop; always use braces with a do-while,
> +even if it contains a single statement:

I can't see anything wrong with

do
	abc;
while (xyz);


and even if I could, "always use" seems way too strong in this case.
-- 
Krzysztof Halasa
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 00:35:01 +0000
Message-ID: <20070726173501.9ba466ba.akpm () linux-foundation ! org>
--------------------
On Fri, 27 Jul 2007 02:18:34 +0200 Krzysztof Halasa <khc@pm.waw.pl> wrote:

> Josh Triplett <josht@linux.vnet.ibm.com> writes:
> 
> > +This also does not apply to a do-while loop; always use braces with a do-while,
> > +even if it contains a single statement:
> 
> I can't see anything wrong with
> 
> do
> 	abc;
> while (xyz);
> 

Me either, but whatever.

> and even if I could, "always use" seems way too strong in this case.

it's better that we all do things the same way.  What that way _is_ is
actually less important, unless it's something stupid, of course.

In this case, most of the code I've seen uses the braces (I think).

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Stefan Richter <stefanr () s5r6 ! in-berlin ! de>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 00:42:58 +0000
Message-ID: <46A93F92.6050708 () s5r6 ! in-berlin ! de>
--------------------
Krzysztof Halasa wrote:
> and even if I could, "always use" seems way too strong in this case.

Besides, how about reorienting the CodingStyle text to the essential?

(But leave the humorous language in --- the few parts that are inherited
from old versions of that file, now more and more being buried in dry
nitpicking.)
-- 
Stefan Richter
-=====-=-=== -=== ==-==
http://arcgraph.de/sr/
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 00:59:29 +0000
Message-ID: <20070726175929.730fc0be.akpm () linux-foundation ! org>
--------------------
On Fri, 27 Jul 2007 02:42:58 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:

> Krzysztof Halasa wrote:
> > and even if I could, "always use" seems way too strong in this case.
> 
> Besides, how about reorienting the CodingStyle text to the essential?
> 
> (But leave the humorous language in --- the few parts that are inherited
> from old versions of that file, now more and more being buried in dry
> nitpicking.)

If sparse has gone and added a warning for this then it is more than
nitpicking.  Reducing the amount of noise coming out of sparse is useful.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 00:59:29 +0000
Message-ID: <20070726175929.730fc0be.akpm () linux-foundation ! org>
--------------------
On Fri, 27 Jul 2007 02:42:58 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:

> Krzysztof Halasa wrote:
> > and even if I could, "always use" seems way too strong in this case.
> 
> Besides, how about reorienting the CodingStyle text to the essential?
> 
> (But leave the humorous language in --- the few parts that are inherited
> from old versions of that file, now more and more being buried in dry
> nitpicking.)

If sparse has gone and added a warning for this then it is more than
nitpicking.  Reducing the amount of noise coming out of sparse is useful.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Randy Dunlap <randy.dunlap () oracle ! com>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 01:17:10 +0000
Message-ID: <20070726181710.126d90ff.randy.dunlap () oracle ! com>
--------------------
On Fri, 27 Jul 2007 02:42:58 +0200 Stefan Richter wrote:

> Krzysztof Halasa wrote:
> > and even if I could, "always use" seems way too strong in this case.
> 
> Besides, how about reorienting the CodingStyle text to the essential?

I don't mind that.  Send patch(es).

> (But leave the humorous language in --- the few parts that are inherited
> from old versions of that file, now more and more being buried in dry
> nitpicking.)

---
~Randy
*** Remember to use Documentation/SubmitChecklist when testing your code ***
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Stefan Richter <stefanr () s5r6 ! in-berlin ! de>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 07:41:01 +0000
Message-ID: <46A9A18D.2050401 () s5r6 ! in-berlin ! de>
--------------------
Andrew Morton wrote:
> On Fri, 27 Jul 2007 02:42:58 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:
>> Besides, how about reorienting the CodingStyle text to the essential?
...
> If sparse has gone and added a warning for this then it is more than
> nitpicking.  Reducing the amount of noise coming out of sparse is useful.

Sure, that'd be useful.  But then, SubmitChecklist already tells us to
check with sparse before submission.
-- 
Stefan Richter
-=====-=-=== -=== ==-==
http://arcgraph.de/sr/
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Stefan Richter <stefanr () s5r6 ! in-berlin ! de>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 07:41:01 +0000
Message-ID: <46A9A18D.2050401 () s5r6 ! in-berlin ! de>
--------------------
Andrew Morton wrote:
> On Fri, 27 Jul 2007 02:42:58 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:
>> Besides, how about reorienting the CodingStyle text to the essential?
...
> If sparse has gone and added a warning for this then it is more than
> nitpicking.  Reducing the amount of noise coming out of sparse is useful.

Sure, that'd be useful.  But then, SubmitChecklist already tells us to
check with sparse before submission.
-- 
Stefan Richter
-=====-=-=== -=== ==-==
http://arcgraph.de/sr/
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 07:53:49 +0000
Message-ID: <20070727005349.512c2f8d.akpm () linux-foundation ! org>
--------------------
On Fri, 27 Jul 2007 09:41:01 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:

> Andrew Morton wrote:
> > On Fri, 27 Jul 2007 02:42:58 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:
> >> Besides, how about reorienting the CodingStyle text to the essential?
> ...
> > If sparse has gone and added a warning for this then it is more than
> > nitpicking.  Reducing the amount of noise coming out of sparse is useful.
> 
> Sure, that'd be useful.  But then, SubmitChecklist already tells us to
> check with sparse before submission.

rofl.  First we have to talk everyone into checking their stuff with gcc.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 07:53:49 +0000
Message-ID: <20070727005349.512c2f8d.akpm () linux-foundation ! org>
--------------------
On Fri, 27 Jul 2007 09:41:01 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:

> Andrew Morton wrote:
> > On Fri, 27 Jul 2007 02:42:58 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:
> >> Besides, how about reorienting the CodingStyle text to the essential?
> ...
> > If sparse has gone and added a warning for this then it is more than
> > nitpicking.  Reducing the amount of noise coming out of sparse is useful.
> 
> Sure, that'd be useful.  But then, SubmitChecklist already tells us to
> check with sparse before submission.

rofl.  First we have to talk everyone into checking their stuff with gcc.

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Krzysztof Halasa <khc () pm ! waw ! pl>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 16:00:33 +0000
Message-ID: <m3bqdx6dlq.fsf () maximus ! localdomain>
--------------------
Andrew Morton <akpm@linux-foundation.org> writes:

> it's better that we all do things the same way.  What that way _is_ is
> actually less important, unless it's something stupid, of course.

It's certainly true WRT things like indentation but IMHO it shouldn't
go that far, and if it goes, it should be non-braced version.

If we prefer non-braced versions of "if" and "while", it would be
a bit strange to require braces with "do while", wouldn't it?

Sparse warnings... I think it shouldn't complain either, unless
called with extra parameter.


Perhaps some pointer to a bad-looking example so I can see for myself?
-- 
Krzysztof Halasa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 17:05:16 +0000
Message-ID: <1185555916.2642.8.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-27 at 18:00 +0200, Krzysztof Halasa wrote:
> Andrew Morton <akpm@linux-foundation.org> writes:
> 
> > it's better that we all do things the same way.  What that way _is_ is
> > actually less important, unless it's something stupid, of course.
> 
> It's certainly true WRT things like indentation but IMHO it shouldn't
> go that far, and if it goes, it should be non-braced version.
> 
> If we prefer non-braced versions of "if" and "while", it would be
> a bit strange to require braces with "do while", wouldn't it?

Perhaps, but
     1. Existing kernel style uses braces with single-statement
        do-while.
     2. Linus prefers (or at least preferred in October of 2006) braces
        with single-statement do-while.

> Sparse warnings... I think it shouldn't complain either, unless
> called with extra parameter.

Good point; Sparse shouldn't warn about this by default.  I've turned
that off in latest Sparse from Git, so you need to give -Wdo-while or
-Wall to get warnings about that.  However, the kernel gives -Wall, so
you'll still see the warnings there.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 17:05:16 +0000
Message-ID: <1185555916.2642.8.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-27 at 18:00 +0200, Krzysztof Halasa wrote:
> Andrew Morton <akpm@linux-foundation.org> writes:
> 
> > it's better that we all do things the same way.  What that way _is_ is
> > actually less important, unless it's something stupid, of course.
> 
> It's certainly true WRT things like indentation but IMHO it shouldn't
> go that far, and if it goes, it should be non-braced version.
> 
> If we prefer non-braced versions of "if" and "while", it would be
> a bit strange to require braces with "do while", wouldn't it?

Perhaps, but
     1. Existing kernel style uses braces with single-statement
        do-while.
     2. Linus prefers (or at least preferred in October of 2006) braces
        with single-statement do-while.

> Sparse warnings... I think it shouldn't complain either, unless
> called with extra parameter.

Good point; Sparse shouldn't warn about this by default.  I've turned
that off in latest Sparse from Git, so you need to give -Wdo-while or
-Wall to get warnings about that.  However, the kernel gives -Wall, so
you'll still see the warnings there.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Stefan Richter <stefanr () s5r6 ! in-berlin ! de>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 17:13:28 +0000
Message-ID: <46AA27B8.8060701 () s5r6 ! in-berlin ! de>
--------------------
Andrew Morton wrote:
> On Fri, 27 Jul 2007 09:41:01 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:
...
>> SubmitChecklist already tells us to check with sparse before submission.
> 
> rofl.  First we have to talk everyone into checking their stuff with gcc.

Ah, I forgot --- Real Submitters don't compile their code before
submission.  But wait, they also don't track CodingStyle.

Seriously though:  Precise rules are a priori welcome.  But the more
rules there are, the less of them we (authors, reviewers) can memorize.
If we go for having many rules, then we need to rely more on checkpatch
and sparse.  When growing into a catch-all rule book, the utility of
CodingStyle will shift from an author's guide to a specification for
code checking tools.
-- 
Stefan Richter
-=====-=-=== -=== ==-==
http://arcgraph.de/sr/
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Stefan Richter <stefanr () s5r6 ! in-berlin ! de>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 17:13:28 +0000
Message-ID: <46AA27B8.8060701 () s5r6 ! in-berlin ! de>
--------------------
Andrew Morton wrote:
> On Fri, 27 Jul 2007 09:41:01 +0200 Stefan Richter <stefanr@s5r6.in-berlin.de> wrote:
...
>> SubmitChecklist already tells us to check with sparse before submission.
> 
> rofl.  First we have to talk everyone into checking their stuff with gcc.

Ah, I forgot --- Real Submitters don't compile their code before
submission.  But wait, they also don't track CodingStyle.

Seriously though:  Precise rules are a priori welcome.  But the more
rules there are, the less of them we (authors, reviewers) can memorize.
If we go for having many rules, then we need to rely more on checkpatch
and sparse.  When growing into a catch-all rule book, the utility of
CodingStyle will shift from an author's guide to a specification for
code checking tools.
-- 
Stefan Richter
-=====-=-=== -=== ==-==
http://arcgraph.de/sr/
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Krzysztof Halasa <khc () pm ! waw ! pl>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 17:44:41 +0000
Message-ID: <m3r6mt4u7q.fsf () maximus ! localdomain>
--------------------
Josh Triplett <josht@linux.vnet.ibm.com> writes:

> Perhaps, but
>      1. Existing kernel style uses braces with single-statement
>         do-while.
>      2. Linus prefers (or at least preferred in October of 2006) braces
>         with single-statement do-while.

Fine with me, but it should IMHO be maintainer's call.

Things which a) are clearly better, and/or b) would require massive
reformatting when new maintainer steps in, should be documented
in CodingStyle and perhaps checked for by scripts and sparse.

Other things... sometimes there are multiple ways to do something
well, and humans aren't, and shouldn't be that deterministic.
-- 
Krzysztof Halasa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Krzysztof Halasa <khc () pm ! waw ! pl>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 17:44:41 +0000
Message-ID: <m3r6mt4u7q.fsf () maximus ! localdomain>
--------------------
Josh Triplett <josht@linux.vnet.ibm.com> writes:

> Perhaps, but
>      1. Existing kernel style uses braces with single-statement
>         do-while.
>      2. Linus prefers (or at least preferred in October of 2006) braces
>         with single-statement do-while.

Fine with me, but it should IMHO be maintainer's call.

Things which a) are clearly better, and/or b) would require massive
reformatting when new maintainer steps in, should be documented
in CodingStyle and perhaps checked for by scripts and sparse.

Other things... sometimes there are multiple ways to do something
well, and humans aren't, and shouldn't be that deterministic.
-- 
Krzysztof Halasa
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 18:27:23 +0000
Message-ID: <20070727112723.131753f9.akpm () linux-foundation ! org>
--------------------
On Fri, 27 Jul 2007 10:05:16 -0700
Josh Triplett <josht@linux.vnet.ibm.com> wrote:

> > Sparse warnings... I think it shouldn't complain either, unless
> > called with extra parameter.
> 
> Good point; Sparse shouldn't warn about this by default.  I've turned
> that off in latest Sparse from Git, so you need to give -Wdo-while or
> -Wall to get warnings about that.  However, the kernel gives -Wall, so
> you'll still see the warnings there.

I believe reeducating sparse was the best fix here.  I think I'll now
have a quiet accident with codingstyle-proscribe-do-while-without-braces.patch
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 18:27:23 +0000
Message-ID: <20070727112723.131753f9.akpm () linux-foundation ! org>
--------------------
On Fri, 27 Jul 2007 10:05:16 -0700
Josh Triplett <josht@linux.vnet.ibm.com> wrote:

> > Sparse warnings... I think it shouldn't complain either, unless
> > called with extra parameter.
> 
> Good point; Sparse shouldn't warn about this by default.  I've turned
> that off in latest Sparse from Git, so you need to give -Wdo-while or
> -Wall to get warnings about that.  However, the kernel gives -Wall, so
> you'll still see the warnings there.

I believe reeducating sparse was the best fix here.  I think I'll now
have a quiet accident with codingstyle-proscribe-do-while-without-braces.patch
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: [PATCH] CodingStyle: proscribe do-while without braces.
Date: Fri, 27 Jul 2007 18:52:10 +0000
Message-ID: <1185562330.2642.13.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-27 at 11:27 -0700, Andrew Morton wrote:
> On Fri, 27 Jul 2007 10:05:16 -0700
> Josh Triplett <josht@linux.vnet.ibm.com> wrote:
> 
> > > Sparse warnings... I think it shouldn't complain either, unless
> > > called with extra parameter.
> > 
> > Good point; Sparse shouldn't warn about this by default.  I've turned
> > that off in latest Sparse from Git, so you need to give -Wdo-while or
> > -Wall to get warnings about that.  However, the kernel gives -Wall, so
> > you'll still see the warnings there.
> 
> I believe reeducating sparse was the best fix here.  I think I'll now
> have a quiet accident with codingstyle-proscribe-do-while-without-braces.patch

I didn't just submit the patch because Sparse warns about it.  I
submitted the patch because of the coding style preference that led to
the Sparse warning.

Also, if this really *shouldn't* form part of the kernel style, then the
kernel should use -Wno-do-while with -Wall, or should stop using -Wall.

That said, I don't care all that much about the patch, so I won't push
further for it one way or another.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH] Fix compilation warning on 64 bits platforms ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix compilation warning on 64 bits platforms
Date: Mon, 21 May 2007 00:28:37 +0000
Message-ID: <4650E7B5.4030207 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigFE3722DEB25DE510DA75CB3A
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Damien Lespiau wrote:
> Fix: format '%d' expects type 'int', but argument 2 has type 'long int'=

[...]
> @@ -461,7 +461,7 @@ const char *show_instruction(struct instruction *in=
sn)
>  	}
> =20
>  	if (buf >=3D buffer + sizeof(buffer))
> -		die("instruction buffer overflowed %d\n", buf - buffer);
> +		die("instruction buffer overflowed %d\n", (int)(buf - buffer));

A cast doesn't seem like the right fix.  The difference between two point=
ers
has type ptrdiff_t.  sizeof(ptrdiff_t) =3D=3D 8 on 64-bit platforms, lead=
ing to
the legitimate warning you saw.  This cast would truncate the difference =
to 32
bits.  glibc supplies a "t" length modifier for ptrdiff_t, but I don't th=
ink
sparse can't portably use that.  I don't think we can portably use %llu
either, even though we use long long.  On the other hand, sparse already =
seems
to use %llu.

Obviously 32-bit overflow seems unlikely here, but I don't like using a c=
ast
to shut GCC up when it has a legitimate complaint; I'd prefer to have the=

right fix.

The ideal fix, so we don't have to worry about printf format-string
portability: change this function to cleanly *prevent* instruction buffer=

overflows rather than detecting them after the fact. :)

- Josh Triplett



--------------enigFE3722DEB25DE510DA75CB3A
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGUOe1GJuZRtD+evsRAskIAJ9FISIvSHyIRWYNTsK86LBtlnLMggCfUHTp
uakoVZY7F0mDqXkHkjloKMo=
=f9EP
-----END PGP SIGNATURE-----

--------------enigFE3722DEB25DE510DA75CB3A--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix compilation warning on 64 bits platforms
Date: Mon, 21 May 2007 00:36:32 +0000
Message-ID: <4650E990.3020305 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig311CED162DC78BF801F3E8FA
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> On Sun, May 20, 2007 at 05:28:37PM -0700, Josh Triplett wrote:
>> Damien Lespiau wrote:
>>> Fix: format '%d' expects type 'int', but argument 2 has type 'long in=
t'
>> [...]
>>> @@ -461,7 +461,7 @@ const char *show_instruction(struct instruction *=
insn)
>>>  	}
>>> =20
>>>  	if (buf >=3D buffer + sizeof(buffer))
>>> -		die("instruction buffer overflowed %d\n", buf - buffer);
>>> +		die("instruction buffer overflowed %d\n", (int)(buf - buffer));
>> A cast doesn't seem like the right fix.  The difference between two po=
inters
>> has type ptrdiff_t.  sizeof(ptrdiff_t) =3D=3D 8 on 64-bit platforms, l=
eading to
>> the legitimate warning you saw.  This cast would truncate the differen=
ce to 32
>> bits.  glibc supplies a "t" length modifier for ptrdiff_t, but I don't=
 think
>> sparse can't portably use that.
>=20
> Not just glibc; it's in C99.  So yes, I'd say we should use %td here.

Ah, perfect.  Yes, we should use %td.

- Josh Triplett



--------------enig311CED162DC78BF801F3E8FA
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGUOmQGJuZRtD+evsRAqxkAJ9oloEKZNS7WUB00HdXy6KdO+MijQCgqKs7
CNqte2bCdJfof/hsGJ7URO4=
=TvVZ
-----END PGP SIGNATURE-----

--------------enig311CED162DC78BF801F3E8FA--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Damien Lespiau" <damien.lespiau () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Fix compilation warning on 64 bits platforms
Date: Tue, 22 May 2007 18:06:34 +0000
Message-ID: <cbf3148c0705221106n68cacf3g82faeba38d964945 () mail ! gmail ! com>
--------------------
> Al Viro wrote:
> > Not just glibc; it's in C99.  So yes, I'd say we should use %td here.

Much better than my ugly cast. I feel stupid to "sign" a one letter patch
that is not mine, but I guess you expect me to resend it.

-- 
Damien
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix compilation warning on 64 bits platforms
Date: Tue, 22 May 2007 21:20:14 +0000
Message-ID: <46535E8E.10504 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig3CC447EA13ACE77FB52EFA25
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Damien Lespiau wrote:
>> Al Viro wrote:
>>> Not just glibc; it's in C99.  So yes, I'd say we should use %td here.=

>=20
> Much better than my ugly cast. I feel stupid to "sign" a one letter pat=
ch
> that is not mine, but I guess you expect me to resend it.

Don't worry about it.  I went ahead and made the change:

=46rom 3195f83203cfd6d05cd56829c02c16b5dc5c274d Mon Sep 17 00:00:00 2001
From: Josh Triplett <josh@freedesktop.org>
Date: Tue, 22 May 2007 14:18:28 -0700
Subject: [PATCH] Use %td when printing a ptrdiff_t to avoid problems on 6=
4-bit platforms

Thanks to Damien Lespiau for reporting the problem.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 linearize.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linearize.c b/linearize.c
index d428d92..c38dd7d 100644
--- a/linearize.c
+++ b/linearize.c
@@ -461,7 +461,7 @@ const char *show_instruction(struct instruction *insn=
)
 	}
=20
 	if (buf >=3D buffer + sizeof(buffer))
-		die("instruction buffer overflowed %d\n", buf - buffer);
+		die("instruction buffer overflowed %td\n", buf - buffer);
 	do { --buf; } while (*buf =3D=3D ' ');
 	*++buf =3D 0;
 	return buffer;

- Josh Triplett


--------------enig3CC447EA13ACE77FB52EFA25
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU16OGJuZRtD+evsRAoYmAJ9k2Xg/3J/MSbyKgadybCtrNBmDlwCgn6P3
ljgm9ZLDM5mMULelXsDSBtI=
=c1P9
-----END PGP SIGNATURE-----

--------------enig3CC447EA13ACE77FB52EFA25--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix compilation warning on 64 bits platforms v2 ===

From: Damien Lespiau <damien.lespiau () gmail ! com>
To: linux-sparse
Subject: [PATCH] Fix compilation warning on 64 bits platforms v2
Date: Tue, 22 May 2007 18:07:37 +0000
Message-ID: <11798572573555-git-send-email-damien.lespiau () gmail ! com>
--------------------
Fix: format '%d' expects type 'int', but argument 2 has type 'long int'

Signed-off-by: Damien Lespiau <damien.lespiau@gmail.com>
---
 linearize.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linearize.c b/linearize.c
index d428d92..c38dd7d 100644
--- a/linearize.c
+++ b/linearize.c
@@ -461,7 +461,7 @@ const char *show_instruction(struct instruction *insn)
 	}
 
 	if (buf >= buffer + sizeof(buffer))
-		die("instruction buffer overflowed %d\n", buf - buffer);
+		die("instruction buffer overflowed %td\n", buf - buffer);
 	do { --buf; } while (*buf == ' ');
 	*++buf = 0;
 	return buffer;
-- 
1.5.2.rc3.87.g404fd


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix mistaken comparison that becomes a no-op. ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix mistaken comparison that becomes a no-op.
Date: Sat, 27 Jan 2007 09:39:50 +0000
Message-ID: <45BB1DE6.5060706 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigAEAD2C143C0C43ABB41AEFAE
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

James Westby wrote:
> Fix a mistake in same_cast_type where the second test became a no-op as=
 it
> compared a value to itself, rather than to the second operand.

Applied; good catch!

- Josh Triplett



--------------enigAEAD2C143C0C43ABB41AEFAE
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFFux3mGJuZRtD+evsRAuC6AKCktte4aaX2lmxfOD1YFrLQLcaxygCfUB+3
LDOId98F5lCTIafiks/tWMg=
=T2xE
-----END PGP SIGNATURE-----

--------------enigAEAD2C143C0C43ABB41AEFAE--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix the annotated inline call position ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Fix the annotated inline call position
Date: Fri, 23 Mar 2007 23:08:17 +0000
Message-ID: <20070323230817.GC27992 () chrisli ! org>
--------------------

Here is some diff comparing output between the sparse 0.2 and the tip of git.

-mm/mmap.c:1631:2: warning: context imbalance in 'expand_stack' - different lock
 contexts for basic block
+include/linux/rmap.h:55:2: warning: context imbalance in 'expand_stack' - diffe

The change is introduced by the inline annotate instruction,
which mark the bb->pos to the inline function.

This change make it back to the caller position.

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/linearize.c
===================================================================
--- sparse.orig/linearize.c	2007-03-22 14:11:40.000000000 -0700
+++ sparse/linearize.c	2007-03-23 13:15:28.000000000 -0700
@@ -1650,6 +1650,7 @@ static pseudo_t linearize_inlined_call(s
 {
 	struct instruction *insn = alloc_instruction(OP_INLINED_CALL, 0);
 	struct statement *args = stmt->args;
+	struct basic_block *bb;
 	pseudo_t pseudo;
 
 	if (args) {
@@ -1664,6 +1665,9 @@ static pseudo_t linearize_inlined_call(s
 
 	insn->target = pseudo = linearize_compound_statement(ep, stmt);
 	use_pseudo(insn, symbol_pseudo(ep, stmt->inline_fn), &insn->func);
+	bb = ep->active;
+	if (bb && !bb->insns)
+		bb->pos = stmt->pos;
 	add_one_insn(ep, insn);
 	return pseudo;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Handle ignored attribute malloc ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Handle ignored attribute malloc
Date: Fri, 26 Oct 2007 03:16:00 +0000
Message-ID: <70318cbf0710252016x5c41ac82o2456bfa5b392d0f4 () mail ! gmail ! com>
--------------------
Which kernel source code triggers this?

If nobody is using malloc_ident directly. You don't need to add it
to ident-list.h.

Having a test case in validations directory will be nice too.

Chris

On 10/25/07, Emil Medve <Emilian.Medve@freescale.com> wrote:
> This avoids error messages like this:
>
> error: attribute 'malloc': unknown attribute
>
> Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
> ---
>
> Please copy me in replies as I'm not subscribed to the list
>
>  ident-list.h |    1 +
>  parse.c      |    1 +
>  2 files changed, 2 insertions(+), 0 deletions(-)
>
> diff --git a/ident-list.h b/ident-list.h
> index b183eac..8fcd7de 100644
> --- a/ident-list.h
> +++ b/ident-list.h
> @@ -69,6 +69,7 @@ IDENT(model); IDENT(__model__);
>  IDENT(format_arg); IDENT(__format_arg__);
>  IDENT(nothrow); IDENT(__nothrow); IDENT(__nothrow__);
>  IDENT(__transparent_union__);
> +IDENT(malloc);
>  IDENT(__malloc__);
>  IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
>  IDENT(constructor); IDENT(__constructor__);
> diff --git a/parse.c b/parse.c
> index 47b5204..a41939d 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -283,6 +283,7 @@ static struct init_keyword {
>         { "nothrow",    NS_KEYWORD,     .op = &ignore_attr_op },
>         { "__nothrow",  NS_KEYWORD,     .op = &ignore_attr_op },
>         { "__nothrow__",        NS_KEYWORD,     .op = &ignore_attr_op },
> +       { "malloc",     NS_KEYWORD,     .op = &ignore_attr_op },
>         { "__malloc__", NS_KEYWORD,     .op = &ignore_attr_op },
>         { "nonnull",    NS_KEYWORD,     .op = &ignore_attr_op },
>         { "__nonnull",  NS_KEYWORD,     .op = &ignore_attr_op },
> --
> 1.5.3.GIT
>
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Medve Emilian-EMMEDVE1" <Emilian.Medve () freescale ! com>
To: linux-sparse
Subject: RE: [PATCH] Handle ignored attribute malloc
Date: Fri, 26 Oct 2007 20:11:35 +0000
Message-ID: <598D5675D34BE349929AF5EDE9B03E27016E5CDF () az33exm24 ! fsl ! freescale ! net>
--------------------
Hi Chris,


It's not the kernel, but some other code I'm writing. However, I expect
it could be used for kmalloc() and friends.

Nobody is using malloc_ident yet, but I noticed other xxx_ident that are
not used nad are present in ident-list.h so I assumed it would be ok.

I'll try to add a test case.


Cheers,
Emil.


This e-mail, and any associated attachments have been classified as:
--------------------------------------------------------------------
[ ] Public
[x] Freescale Semiconductor Internal Use Only
[ ] Freescale Semiconductor Confidential Proprietary


> -----Original Message-----
> From: christ.li@gmail.com [mailto:christ.li@gmail.com] On 
> Behalf Of Christopher Li
> Sent: Thursday, October 25, 2007 10:16 PM
> To: Medve Emilian-EMMEDVE1
> Cc: josh@freedesktop.org; linux-sparse@vger.kernel.org
> Subject: Re: [PATCH] Handle ignored attribute malloc
> 
> Which kernel source code triggers this?
> 
> If nobody is using malloc_ident directly. You don't need to add it
> to ident-list.h.
> 
> Having a test case in validations directory will be nice too.
> 
> Chris
> 
> On 10/25/07, Emil Medve <Emilian.Medve@freescale.com> wrote:
> > This avoids error messages like this:
> >
> > error: attribute 'malloc': unknown attribute
> >
> > Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
> > ---
> >
> > Please copy me in replies as I'm not subscribed to the list
> >
> >  ident-list.h |    1 +
> >  parse.c      |    1 +
> >  2 files changed, 2 insertions(+), 0 deletions(-)
> >
> > diff --git a/ident-list.h b/ident-list.h
> > index b183eac..8fcd7de 100644
> > --- a/ident-list.h
> > +++ b/ident-list.h
> > @@ -69,6 +69,7 @@ IDENT(model); IDENT(__model__);
> >  IDENT(format_arg); IDENT(__format_arg__);
> >  IDENT(nothrow); IDENT(__nothrow); IDENT(__nothrow__);
> >  IDENT(__transparent_union__);
> > +IDENT(malloc);
> >  IDENT(__malloc__);
> >  IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
> >  IDENT(constructor); IDENT(__constructor__);
> > diff --git a/parse.c b/parse.c
> > index 47b5204..a41939d 100644
> > --- a/parse.c
> > +++ b/parse.c
> > @@ -283,6 +283,7 @@ static struct init_keyword {
> >         { "nothrow",    NS_KEYWORD,     .op = &ignore_attr_op },
> >         { "__nothrow",  NS_KEYWORD,     .op = &ignore_attr_op },
> >         { "__nothrow__",        NS_KEYWORD,     .op = 
> &ignore_attr_op },
> > +       { "malloc",     NS_KEYWORD,     .op = &ignore_attr_op },
> >         { "__malloc__", NS_KEYWORD,     .op = &ignore_attr_op },
> >         { "nonnull",    NS_KEYWORD,     .op = &ignore_attr_op },
> >         { "__nonnull",  NS_KEYWORD,     .op = &ignore_attr_op },
> > --
> > 1.5.3.GIT
> >
> > -
> > To unsubscribe from this list: send the line "unsubscribe 
> linux-sparse" in
> > the body of a message to majordomo@vger.kernel.org
> > More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Handle ignored attribute malloc
Date: Tue, 13 Nov 2007 12:13:39 +0000
Message-ID: <473994F3.1000505 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig7B57743BE2E2354D65EF85FE
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Emil Medve wrote:
> This avoids error messages like this:
>=20
> error: attribute 'malloc': unknown attribute
>=20
> Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>

Patch applied; thanks!

I decided to ignore the issue of the extra ident, for now;
the rest of the idents need a cleanup pass anyway.

- Josh Triplett



--------------enig7B57743BE2E2354D65EF85FE
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHOZTzGJuZRtD+evsRAmYbAJ4tyFJzej8Y+QCY1YSlOGHwLsO/PgCghyRk
97oF0o4jDODmTj9J7P8pm1Q=
=NnPb
-----END PGP SIGNATURE-----

--------------enig7B57743BE2E2354D65EF85FE--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Handle ignored attribute malloc
Date: Tue, 13 Nov 2007 12:13:39 +0000
Message-ID: <473994F3.1000505 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig7B57743BE2E2354D65EF85FE
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Emil Medve wrote:
> This avoids error messages like this:
>=20
> error: attribute 'malloc': unknown attribute
>=20
> Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>

Patch applied; thanks!

I decided to ignore the issue of the extra ident, for now;
the rest of the idents need a cleanup pass anyway.

- Josh Triplett



--------------enig7B57743BE2E2354D65EF85FE
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHOZTzGJuZRtD+evsRAmYbAJ4tyFJzej8Y+QCY1YSlOGHwLsO/PgCghyRk
97oF0o4jDODmTj9J7P8pm1Q=
=NnPb
-----END PGP SIGNATURE-----

--------------enig7B57743BE2E2354D65EF85FE--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Introduce expression_error ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Introduce expression_error
Date: Tue, 27 Feb 2007 08:58:22 +0000
Message-ID: <20070227085822.GA6059 () chrisli ! org>
--------------------
Adding a new function expression_error, it works just like
sparse_error but it also install a bad_ctype on expression.

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/lib.c
===================================================================
--- sparse.orig/lib.c	2007-02-26 03:31:23.000000000 -0800
+++ sparse/lib.c	2007-02-27 01:04:19.000000000 -0800
@@ -126,10 +126,9 @@ void warning(struct position pos, const 
 	va_end(args);
 }	
 
-void sparse_error(struct position pos, const char * fmt, ...)
+void do_error(struct position pos, const char * fmt, va_list args)
 {
 	static int errors = 0;
-	va_list args;
         die_if_error = 1;
 	show_info = 1;
 	/* Shut up warnings after an error */
@@ -143,12 +142,27 @@ void sparse_error(struct position pos, c
 		once = 1;
 	}
 
-	va_start(args, fmt);
 	do_warn("error: ", pos, fmt, args);
-	va_end(args);
 	errors++;
 }	
 
+void sparse_error(struct position pos, const char * fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	do_error(pos, fmt, args);
+	va_end(args);
+}
+
+void expression_error(struct expression *expr, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	do_error(expr->pos, fmt, args);
+	va_end(args);
+	expr->ctype = &bad_ctype;
+}
+
 void error_die(struct position pos, const char * fmt, ...)
 {
 	va_list args;
Index: sparse/evaluate.c
===================================================================
--- sparse.orig/evaluate.c	2007-02-26 03:31:23.000000000 -0800
+++ sparse/evaluate.c	2007-02-27 01:12:46.000000000 -0800
@@ -38,7 +38,7 @@ static struct symbol *evaluate_symbol_ex
 	struct symbol *base_type;
 
 	if (!sym) {
-		sparse_error(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
+		expression_error(expr, "undefined identifier '%s'", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -46,7 +46,7 @@ static struct symbol *evaluate_symbol_ex
 
 	base_type = get_base_type(sym);
 	if (!base_type) {
-		sparse_error(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
+		expression_error(expr, "identifier '%s' has no type", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -597,7 +597,7 @@ static struct symbol *evaluate_ptr_add(s
 	examine_symbol_type(ctype);
 
 	if (!ctype->ctype.base_type) {
-		sparse_error(expr->pos, "missing type information");
+		expression_error(expr, "missing type information");
 		return NULL;
 	}
 
@@ -855,7 +855,7 @@ static struct symbol *evaluate_ptr_sub(s
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			sparse_error(expr->pos, "subtraction of different types can't work (%s)", typediff);
+			expression_error(expr, "subtraction of different types can't work (%s)", typediff);
 			return NULL;
 		}
 	}
@@ -865,7 +865,7 @@ static struct symbol *evaluate_ptr_sub(s
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		sparse_error(expr->pos, "subtraction of functions? Share your drugs");
+		expression_error(expr, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = get_base_type(ctype);
@@ -1106,7 +1106,7 @@ static struct symbol *evaluate_condition
 	typediff = type_difference(ltype, rtype, MOD_IGN, MOD_IGN);
 	if (!typediff)
 		goto out;
-	sparse_error(expr->pos, "incompatible types in conditional expression (%s)", typediff);
+	expression_error(expr, "incompatible types in conditional expression (%s)", typediff);
 	return NULL;
 
 out:
@@ -1135,12 +1135,12 @@ static int compatible_assignment_types(s
 
 	if (tclass & sclass & TYPE_NUM) {
 		if (tclass & TYPE_FLOAT && !compatible_float_op(op)) {
-			sparse_error(expr->pos, "invalid assignment");
+			expression_error(expr, "invalid assignment");
 			return 0;
 		}
 		if (tclass & TYPE_RESTRICT) {
 			if (!restricted_binop(op, target)) {
-				sparse_error(expr->pos, "bad restricted assignment");
+				expression_error(expr, "bad restricted assignment");
 				return 0;
 			}
 			/* allowed assignments unfoul */
@@ -1156,11 +1156,11 @@ static int compatible_assignment_types(s
 			return 1;
 		}
 		if (op != '=') {
-			sparse_error(expr->pos, "invalid pointer assignment");
+			expression_error(expr, "invalid pointer assignment");
 			return 0;
 		}
 	} else if (op != '=') {
-		sparse_error(expr->pos, "invalid assignment");
+		expression_error(expr, "invalid assignment");
 		return 0;
 	}
 
@@ -1234,7 +1234,7 @@ static void mark_assigned(struct express
 static void evaluate_assign_to(struct expression *left, struct symbol *type)
 {
 	if (type->ctype.modifiers & MOD_CONST)
-		sparse_error(left->pos, "assignment to const expression");
+		expression_error(left, "assignment to const expression");
 
 	/* We know left is an lvalue, so it's a "preop-*" */
 	mark_assigned(left->unop);
@@ -1247,7 +1247,7 @@ static struct symbol *evaluate_assignmen
 	struct symbol *ltype, *rtype;
 
 	if (!lvalue_expression(left)) {
-		sparse_error(expr->pos, "not an lvalue");
+		expression_error(expr, "not an lvalue");
 		return NULL;
 	}
 
@@ -1412,7 +1412,7 @@ static struct symbol *degenerate(struct 
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			sparse_error(expr->pos, "strange non-value function or array");
+			expression_error(expr, "strange non-value function or array");
 			return &bad_ctype;
 		}
 		*expr = *expr->unop;
@@ -1430,7 +1430,7 @@ static struct symbol *evaluate_addressof
 	struct symbol *ctype;
 
 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		sparse_error(expr->pos, "not addressable");
+		expression_error(expr, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1474,7 +1474,7 @@ static struct symbol *evaluate_dereferen
 
 	switch (ctype->type) {
 	default:
-		sparse_error(expr->pos, "cannot dereference this type");
+		expression_error(expr, "cannot dereference this type");
 		return NULL;
 	case SYM_PTR:
 		node->ctype.modifiers = target->ctype.modifiers & MOD_SPECIFIER;
@@ -1483,7 +1483,7 @@ static struct symbol *evaluate_dereferen
 
 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			sparse_error(op->pos, "non-lvalue array??");
+			expression_error(op, "non-lvalue array??");
 			return NULL;
 		}
 
@@ -1515,14 +1515,14 @@ static struct symbol *evaluate_postop(st
 	struct symbol *ctype = op->ctype;
 
 	if (!lvalue_expression(expr->unop)) {
-		sparse_error(expr->pos, "need lvalue expression for ++/--");
+		expression_error(expr, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, &ctype)) {
-		sparse_error(expr->pos, "bad operation on restricted");
+		expression_error(expr, "bad operation on restricted");
 		return NULL;
 	} else if (is_fouled_type(ctype) && restricted_unop(expr->op, &ctype)) {
-		sparse_error(expr->pos, "bad operation on restricted");
+		expression_error(expr, "bad operation on restricted");
 		return NULL;
 	}
 
@@ -1685,7 +1685,7 @@ static struct symbol *evaluate_member_de
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		sparse_error(expr->pos, "bad member name");
+		expression_error(expr, "bad member name");
 		return NULL;
 	}
 
@@ -1698,7 +1698,7 @@ static struct symbol *evaluate_member_de
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		sparse_error(expr->pos, "expected structure or union");
+		expression_error(expr, "expected structure or union");
 		return NULL;
 	}
 	examine_symbol_type(ctype);
@@ -1712,7 +1712,7 @@ static struct symbol *evaluate_member_de
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		sparse_error(expr->pos, "no member '%s' in %s %.*s",
+		expression_error(expr, "no member '%s' in %s %.*s",
 			show_ident(ident), type, namelen, name);
 		return NULL;
 	}
@@ -1804,7 +1804,7 @@ static struct symbol *evaluate_type_info
 	}
 	examine_symbol_type(sym);
 	if (is_bitfield_type(sym)) {
-		sparse_error(expr->pos, "trying to examine bitfield type");
+		expression_error(expr, "trying to examine bitfield type");
 		return NULL;
 	}
 	return sym;
@@ -1821,7 +1821,7 @@ static struct symbol *evaluate_sizeof(st
 
 	size = type->bit_size;
 	if ((size < 0) || (size & 7))
-		sparse_error(expr->pos, "cannot size expression");
+		expression_error(expr, "cannot size expression");
 	expr->type = EXPR_VALUE;
 	expr->value = size >> 3;
 	expr->ctype = size_t_ctype;
@@ -1849,7 +1849,7 @@ static struct symbol *evaluate_ptrsizeof
 		if (type)
 			break;
 	default:
-		sparse_error(expr->pos, "expected pointer expression");
+		expression_error(expr, "expected pointer expression");
 		return NULL;
 	}
 	size = type->bit_size;
@@ -1968,7 +1968,7 @@ static void evaluate_array_initializer(s
 static void evaluate_scalar_initializer(struct symbol *ctype, struct expression *expr)
 {
 	if (expression_list_size(expr->expr_list) != 1) {
-		sparse_error(expr->pos, "unexpected compound initializer");
+		expression_error(expr, "unexpected compound initializer");
 		return;
 	}
 	evaluate_array_initializer(ctype, expr);
@@ -1994,7 +1994,7 @@ static int evaluate_one_struct_initializ
 	unsigned long offset;
 
 	if (!sym) {
-		sparse_error(entry->pos, "unknown named initializer");
+		expression_error(entry, "unknown named initializer");
 		return -1;
 	}
 
@@ -2103,7 +2103,7 @@ static void evaluate_initializer(struct 
 		if (ctype->type == SYM_NODE)
 			ctype = ctype->ctype.base_type;
 		if (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION) {
-			sparse_error(expr->pos, "expected structure or union for '%s' dereference", show_ident(expr->expr_ident));
+			expression_error(expr, "expected structure or union for '%s' dereference", show_ident(expr->expr_ident));
 			show_symbol(ctype);
 			return;
 		}
@@ -2115,7 +2115,7 @@ static void evaluate_initializer(struct 
 		if (ctype->type == SYM_NODE)
 			ctype = ctype->ctype.base_type;
 		if (ctype->type != SYM_ARRAY) {
-			sparse_error(expr->pos, "expected array");
+			expression_error(expr, "expected array");
 			return;
 		}
 		evaluate_one_array_initializer(ctype->ctype.base_type, ep, 0);
@@ -2247,7 +2247,7 @@ static struct symbol *evaluate_cast(stru
 
 	t2 = target->ctype;
 	if (!t2) {
-		sparse_error(expr->pos, "cast from unknown type");
+		expression_error(expr, "cast from unknown type");
 		goto out;
 	}
 	class2 = classify_type(t2, &t2);
@@ -2342,18 +2342,18 @@ static struct symbol *evaluate_call(stru
 		if (!evaluate_arguments(sym, ctype, arglist))
 			return NULL;
 		if (ctype->type != SYM_FN) {
-			sparse_error(expr->pos, "not a function %s",
+			expression_error(expr, "not a function %s",
 				     show_ident(sym->ident));
 			return NULL;
 		}
 		args = expression_list_size(expr->args);
 		fnargs = symbol_list_size(ctype->arguments);
 		if (args < fnargs)
-			sparse_error(expr->pos,
+			expression_error(expr,
 				     "not enough arguments for function %s",
 				     show_ident(sym->ident));
 		if (args > fnargs && !ctype->variadic)
-			sparse_error(expr->pos,
+			expression_error(expr,
 				     "too many arguments for function %s",
 				     show_ident(sym->ident));
 	}
@@ -2375,7 +2375,7 @@ struct symbol *evaluate_expression(struc
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		sparse_error(expr->pos, "value expression without a type");
+		expression_error(expr, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2450,10 +2450,10 @@ struct symbol *evaluate_expression(struc
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		sparse_error(expr->pos, "internal front-end error: initializer in expression");
+		expression_error(expr, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		sparse_error(expr->pos, "internal front-end error: SLICE re-evaluated");
+		expression_error(expr, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
@@ -2547,7 +2547,7 @@ static struct symbol *evaluate_return_ex
 	fntype = current_fn->ctype.base_type;
 	if (!fntype || fntype == &void_ctype) {
 		if (expr && ctype != &void_ctype)
-			sparse_error(expr->pos, "return expression in %s function", fntype?"void":"typeless");
+			expression_error(expr, "return expression in %s function", fntype?"void":"typeless");
 		return NULL;
 	}
 
@@ -2587,7 +2587,7 @@ static void verify_output_constraint(str
 	case '+':	/* Update */
 		break;
 	default:
-		sparse_error(expr->pos, "output constraint is not an assignment constraint (\"%s\")", constraint);
+		expression_error(expr, "output constraint is not an assignment constraint (\"%s\")", constraint);
 	}
 }
 
@@ -2596,7 +2596,7 @@ static void verify_input_constraint(stru
 	switch (*constraint) {
 	case '=':	/* Assignment */
 	case '+':	/* Update */
-		sparse_error(expr->pos, "input constraint with assignment (\"%s\")", constraint);
+		expression_error(expr, "input constraint with assignment (\"%s\")", constraint);
 	}
 }
 
@@ -2677,7 +2677,7 @@ static void evaluate_asm_statement(struc
 		}
 		if (expr->type == EXPR_STRING)
 			continue;
-		sparse_error(expr->pos, "asm clobber is not a string");
+		expression_error(expr, "asm clobber is not a string");
 	} END_FOR_EACH_PTR(expr);
 }
 
@@ -2732,7 +2732,7 @@ static void check_case_type(struct expre
 	return;
 
 Bad:
-	sparse_error(case_expr->pos, "incompatible types for 'case' statement");
+	expression_error(case_expr, "incompatible types for 'case' statement");
 }
 
 static void evaluate_switch_statement(struct statement *stmt)
Index: sparse/expand.c
===================================================================
--- sparse.orig/expand.c	2007-02-26 03:31:23.000000000 -0800
+++ sparse/expand.c	2007-02-27 01:04:49.000000000 -0800
@@ -765,7 +765,7 @@ static int expand_call(struct expression
 	cost = expand_arguments(expr->args);
 	sym = fn->ctype;
 	if (!sym) {
-		sparse_error(expr->pos, "function has no type");
+		expression_error(expr, "function has no type");
 		return SIDE_EFFECTS;
 	}
 	if (sym->type == SYM_NODE)
@@ -964,7 +964,7 @@ static int expand_expression(struct expr
 	case EXPR_SIZEOF:
 	case EXPR_PTRSIZEOF:
 	case EXPR_ALIGNOF:
-		sparse_error(expr->pos, "internal front-end error: sizeof in expansion?");
+		expression_error(expr, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -975,7 +975,7 @@ static void expand_const_expression(stru
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			sparse_error(expr->pos, "Expected constant expression in %s", where);
+			expression_error(expr, "Expected constant expression in %s", where);
 	}
 }
 
@@ -1148,12 +1148,12 @@ long long get_expression_value(struct ex
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		sparse_error(expr->pos, "bad constant expression type");
+		expression_error(expr, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		sparse_error(expr->pos, "bad constant expression");
+		expression_error(expr, "bad constant expression");
 		return 0;
 	}
 
Index: sparse/lib.h
===================================================================
--- sparse.orig/lib.h	2007-02-26 03:31:23.000000000 -0800
+++ sparse/lib.h	2007-02-27 01:16:07.000000000 -0800
@@ -76,6 +76,7 @@ extern void info(struct position, const 
 extern void warning(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void sparse_error(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void error_die(struct position, const char *, ...) FORMAT_ATTR(2);
+extern void expression_error(struct expression *, const char *, ...) FORMAT_ATTR(2);
 #undef FORMAT_ATTR
 
 extern char **handle_switch(char *arg, char **next);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Introduce expression_error
Date: Tue, 27 Feb 2007 17:45:56 +0000
Message-ID: <45E46E54.7090507 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig502065887FA76D706ED6BE5E
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> Adding a new function expression_error, it works just like
> sparse_error but it also install a bad_ctype on expression.
>=20
> Signed-Off-By: Christopher Li <sparse@chrisli.org>

This patch makes "sparse -Wall validation/badtype4.c" segfault.

- Josh Triplett


--------------enig502065887FA76D706ED6BE5E
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5G5dGJuZRtD+evsRAgxKAKC9giWT3VGxEVjFAk1nbJvLJYBxnwCeNxDt
ETpCyJe5heduYCoPr+Oj2kk=
=Gasg
-----END PGP SIGNATURE-----

--------------enig502065887FA76D706ED6BE5E--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Introduce expression_error
Date: Wed, 28 Feb 2007 00:27:25 +0000
Message-ID: <45E4CC6D.9000808 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigAB3D245DABD86B69A11AE839
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> On Tue, Feb 27, 2007 at 09:45:56AM -0800, Josh Triplett wrote:
>> Christopher Li wrote:
>> This patch makes "sparse -Wall validation/badtype4.c" segfault.
>=20
> This version should fix it. But I am still not brave enough to
> remove the test for !expr->ctype yet.
>=20
> Chris
>=20
> Adding a new function expression_error, it works just like
> sparse_error but it also install a bad_ctype on expression.
>=20
> Signed-Off-By: Christopher Li <sparse@chrisli.org>

Applied.

- Josh Triplett



--------------enigAB3D245DABD86B69A11AE839
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5MxtGJuZRtD+evsRAntTAJ401DLsVdvVxOnZWyJlqH8sZmpC3ACaA6ZT
/zenEeASqG7xyHiWeIMxbPg=
=E2PK
-----END PGP SIGNATURE-----

--------------enigAB3D245DABD86B69A11AE839--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: Fun with Linux 2.6.21-rc1 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Re: Fun with Linux 2.6.21-rc1
Date: Fri, 23 Feb 2007 22:30:27 +0000
Message-ID: <20070223223027.GA5671 () chrisli ! org>
--------------------
On Fri, Feb 23, 2007 at 02:59:26PM -0500, Pavel Roskin wrote:
> P.S. The breakage has nothing to do to Linux changes.  It was caused by
> the patch called "Make the ptrlist using the sparse allocator".  Undoing
> the patch fixes the problem.
>

No, that was not it. The bug does not trigger if I remove "-O" or remove
the recent struct attribute patch.

You make me guilt for 5 mins. But the real bugs is match_idents did not
end with NULL.

This patch should fix it:

Chris

Fix a bug that match_idents forget to end with NULL

Pavel Roskin manage to hit this bug with

struct st {
       char c;
} __attribute__ ((aligned(2)));
struct st s1;
struct st s2;

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-02-23 14:33:28.000000000 -0800
+++ sparse/parse.c	2007-02-23 14:36:16.000000000 -0800
@@ -861,7 +861,7 @@ static struct token *handle_attributes(s
 			apply_ctype(token->pos, &thistype, ctype);
 			continue;
 		}
-		if (match_idents(token, &asm_ident, &__asm_ident, &__asm___ident)) {
+		if (match_idents(token, &asm_ident, &__asm_ident, &__asm___ident, NULL)) {
 			struct expression *expr;
 			token = expect(token->next, '(', "after asm");
 			token = parse_expression(token->next, &expr);



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: Sparse just seg faulted on me! ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Re: Sparse just seg faulted on me!
Date: Wed, 14 Feb 2007 17:29:05 +0000
Message-ID: <20070214172905.GA17959 () chrisli ! org>
--------------------
> fs/ntfs/sysctl.c:38:15: error: undefined identifier 'CTL_UNNUMBRED'
Sparse left empty ctype when error happen. Sparse should skip
the expand_symbol() at all if error happen. 

Please try this patch:

Fix the segfault when initializer has unknown symbol

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/expand.c
===================================================================
--- sparse.orig/expand.c	2007-02-14 09:28:57.000000000 -0800
+++ sparse/expand.c	2007-02-14 09:44:59.000000000 -0800
@@ -872,7 +872,7 @@ static void verify_nonoverlapping(struct
 	struct expression *b;
 
 	FOR_EACH_PTR(*list, b) {
-		if (a && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
+		if (a && a->ctype && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
 			sparse_error(a->pos, "Initializer entry defined twice");
 			info(b->pos, "  also defined here");
 			return;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Sparse just seg faulted on me!
Date: Wed, 14 Feb 2007 18:24:09 +0000
Message-ID: <Pine.LNX.4.64.0702141022570.3604 () woody ! linux-foundation ! org>
--------------------


On Wed, 14 Feb 2007, Christopher Li wrote:
>
> > fs/ntfs/sysctl.c:38:15: error: undefined identifier 'CTL_UNNUMBRED'
>
> Sparse left empty ctype when error happen. Sparse should skip
> the expand_symbol() at all if error happen. 

Actually, it's often better to just explicitly make "ctype" be 
"&bad_ctype" instead.

It's nice if a NULL type means "type has not been evaluated yet", and then 
using "&bad_ctype" to mean "type evaluated to crap".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Sparse just seg faulted on me!
Date: Wed, 14 Feb 2007 19:54:47 +0000
Message-ID: <20070214195447.GA18753 () chrisli ! org>
--------------------
On Wed, Feb 14, 2007 at 10:24:09AM -0800, Linus Torvalds wrote:
> Actually, it's often better to just explicitly make "ctype" be 
> "&bad_ctype" instead.
> 
> It's nice if a NULL type means "type has not been evaluated yet", and then 
> using "&bad_ctype" to mean "type evaluated to crap".

Good idea. Some of the code already doing that. I am making it as a separate
patch because touch a lot of code.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Sparse just seg faulted on me!
Date: Wed, 14 Feb 2007 20:18:55 +0000
Message-ID: <20070214201855.GC18753 () chrisli ! org>
--------------------
On Wed, Feb 14, 2007 at 11:54:47AM -0800, Christopher Li wrote:
> On Wed, Feb 14, 2007 at 10:24:09AM -0800, Linus Torvalds wrote:
> > Actually, it's often better to just explicitly make "ctype" be 
> > "&bad_ctype" instead.
> > 
> > It's nice if a NULL type means "type has not been evaluated yet", and then 
> > using "&bad_ctype" to mean "type evaluated to crap".
> 
> Good idea. Some of the code already doing that. I am making it as a separate
> patch because touch a lot of code.

This is very messy. The current evaluate_* functions are assuming NULL means for
"some error happen in this expression, I can't get the ctype". It is all over the
place.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Sparse just seg faulted on me!
Date: Wed, 14 Feb 2007 20:36:55 +0000
Message-ID: <20070214203655.GD18753 () chrisli ! org>
--------------------
On Wed, Feb 14, 2007 at 12:48:17PM -0800, Linus Torvalds wrote:
> Yeah. I started out leaving bad stuff as NULL originally, but over time, 
> as I noticed SIGSEGV's, I mostly changed the ones that I ended up having 
> trigger to &bad_ctype.
> 
> Otherwise we either need to test for NULL all the time (and especially 
> since NULL under _some_ circumstances is ok and means "not evaluated yet", 
> that can be confusing), and having to pass up errors higher and higher up.

I think I run into the exact same situations. It start out as simple
rules "&bad_ctype" means error. But then all the test against NULL need
to change to test against &bad_ctpye as well. It is getting subtle for
some place NULL means not evaluated yet.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Sparse just seg faulted on me!
Date: Fri, 23 Feb 2007 02:25:30 +0000
Message-ID: <45DE509A.4040002 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig086CD6A19DAFEA85E3A6CADC
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> On Wed, Feb 14, 2007 at 11:54:47AM -0800, Christopher Li wrote:
>> On Wed, Feb 14, 2007 at 10:24:09AM -0800, Linus Torvalds wrote:
>>> Actually, it's often better to just explicitly make "ctype" be=20
>>> "&bad_ctype" instead.
>>>
>>> It's nice if a NULL type means "type has not been evaluated yet", and=
 then=20
>>> using "&bad_ctype" to mean "type evaluated to crap".
>> Good idea. Some of the code already doing that. I am making it as a se=
parate
>> patch because touch a lot of code.
>=20
> This is very messy. The current evaluate_* functions are assuming NULL =
means for
> "some error happen in this expression, I can't get the ctype". It is al=
l over the
> place.

In that case, I will go ahead and apply your patch to eliminate the segfa=
ult, and
I can merge a new patch that uses &bad_ctype later.

- Josh Triplett


--------------enig086CD6A19DAFEA85E3A6CADC
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3lCaGJuZRtD+evsRAsSjAKCChxNuMiEQedy5p03nO/Sw5/uJEACfYefN
TWt3D/RZ8MJzeEqOMC8oGIE=
=xxni
-----END PGP SIGNATURE-----

--------------enig086CD6A19DAFEA85E3A6CADC--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Sparse just seg faulted on me!
Date: Fri, 23 Feb 2007 02:42:46 +0000
Message-ID: <45DE54A6.7090109 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigC99EB487981CAE8023E816E1
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
>> fs/ntfs/sysctl.c:38:15: error: undefined identifier 'CTL_UNNUMBRED'
> Sparse left empty ctype when error happen. Sparse should skip
> the expand_symbol() at all if error happen.=20
>=20
> Please try this patch:
>=20
> Fix the segfault when initializer has unknown symbol

Applied.

- Josh Triplett



--------------enigC99EB487981CAE8023E816E1
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3lSmGJuZRtD+evsRAiBYAJ0Yn2SSC5nfKcollEgZf/PhVetSJgCgl+Uc
GBBL+lkENAZSgiThmMEXY64=
=/B4e
-----END PGP SIGNATURE-----

--------------enigC99EB487981CAE8023E816E1--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: __attribute__ annotations and struct types ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Re: __attribute__ annotations and struct types
Date: Wed, 14 Feb 2007 20:15:49 +0000
Message-ID: <20070214201549.GB18753 () chrisli ! org>
--------------------
On Wed, Feb 14, 2007 at 03:01:54PM -0500, Daniel Drake wrote:
> sparse doesn't like it:
> 
> 	test.c:7:8: error: Trying to use reserved word '__attribute__' 
> 	as identifier

Can you please try this:

Chris

Handle structure attribute.

struct __attribute__((__aligned__(16))) foo {
    int a;
};

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-02-14 12:37:17.000000000 -0800
+++ sparse/parse.c	2007-02-14 12:40:48.000000000 -0800
@@ -34,6 +34,7 @@ struct symbol_list *function_computed_ta
 struct statement_list *function_computed_goto_list;
 
 static struct token *statement(struct token *token, struct statement **tree);
+static struct token *handle_attributes(struct token *token, struct ctype *ctype);
 
 // Add a symbol to the list of function-local symbols
 static void fn_local_symbol(struct symbol *sym)
@@ -156,6 +157,7 @@ static struct token *struct_union_enum_s
 	struct position *repos;
 
 	ctype->modifiers = 0;
+	token = handle_attributes(token, ctype);
 	if (token_type(token) == TOKEN_IDENT) {
 		sym = lookup_symbol(token->ident, NS_STRUCT);
 		if (!sym ||
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Drake <ddrake () brontes3d ! com>
To: linux-sparse
Subject: Re: [PATCH] Re: __attribute__ annotations and struct types
Date: Wed, 14 Feb 2007 21:02:07 +0000
Message-ID: <1171486927.8554.0.camel () systems03 ! mmm ! com>
--------------------
On Wed, 2007-02-14 at 12:15 -0800, Christopher Li wrote:
> On Wed, Feb 14, 2007 at 03:01:54PM -0500, Daniel Drake wrote:
> > sparse doesn't like it:
> > 
> > 	test.c:7:8: error: Trying to use reserved word '__attribute__' 
> > 	as identifier
> 
> Can you please try this:
> 
> Chris
> 
> Handle structure attribute.

Thanks for the quick response, works nicely!

-- 
Daniel Drake
Brontes Technologies, A 3M Company

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: __attribute__ annotations and struct types
Date: Fri, 23 Feb 2007 02:23:19 +0000
Message-ID: <45DE5017.6030202 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig796E47C6493C99BEFA6726E8
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Daniel Drake wrote:
> On Wed, 2007-02-14 at 12:15 -0800, Christopher Li wrote:
>> On Wed, Feb 14, 2007 at 03:01:54PM -0500, Daniel Drake wrote:
>>> sparse doesn't like it:
>>>
>>> 	test.c:7:8: error: Trying to use reserved word '__attribute__'=20
>>> 	as identifier
>> Can you please try this:
>>
>> Chris
>>
>> Handle structure attribute.
>=20
> Thanks for the quick response, works nicely!

Applied, along with a test case.

- Josh Triplett



--------------enig796E47C6493C99BEFA6726E8
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3lAXGJuZRtD+evsRAvT8AJ9w7E+YbG6HitjflQCkK54UkapEHgCeJJFJ
/xT9gTmvBLXTvr7U9zQWUq0=
=eRFk
-----END PGP SIGNATURE-----

--------------enig796E47C6493C99BEFA6726E8--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: segfaults in pathological cases from gcc testsuite ===

From: "Chris Li" <christ.li () gmail ! com>
To: linux-sparse
Subject: [PATCH] Re: segfaults in pathological cases from gcc testsuite
Date: Tue, 30 Oct 2007 23:24:40 +0000
Message-ID: <70318cbf0710301624n6759142as715f60493e886b98 () mail ! gmail ! com>
--------------------
------=_Part_914_26085076.1193786680621
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

I fix the second one as it is easier to reproduce and makes
more sense to fix.

Please see the patch attached.

A side note is that, I don't believe you can hit this using
real life C code. Maybe some programing generated C code.
There is not thing wrong in sparse except its recursion
is very deep. The patch special handle this test case.

The first one is even less interesting to fix.

Chris

On Oct 22, 2007 8:24 AM, Alexey Dobriyan <adobriyan@sw.ru> wrote:
> FWIW, I fed full gcc tree to sparse not only testsuite. Suprisingly it
> crashed only in two places:
> void q19_func (long i)
> {
>   switch (i) {
>     LIM5 (case 1)
>       break;
>   }
> }

------=_Part_914_26085076.1193786680621
Content-Type: application/octet-stream; name=label-parsing-1
Content-Transfer-Encoding: base64
X-Attachment-Id: f_f8f1m5jf0
Content-Disposition: attachment; filename=label-parsing-1

QXZvaWQgZGVlcCByZWN1cnNpb24gaW4gZW1wdHkgY2FzZSBsYWJlbHMuCgpUaGlzIHBhdGNoIHRh
a2UgdGhlIGVtcHR5IGNhc2UgbGFiZWwgYXMgc3BlY2lhbCBjYXNlLAphdm9pZCBkZWVwIHJlY3Vy
c2lvbiBvbiBib3RoIHBhcnNpbmcgYW5kIGxpbmVhcml6aW9uLgoKU2lnbmVkLU9mZi1CeTogQ2hy
aXN0b3BoZXIgTGk8c3BhcnNlQGNocmlzbGkub3JnPgoKSW5kZXg6IHNwYXJzZS9wYXJzZS5jCj09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL3BhcnNlLmMJMjAwNy0xMC0zMCAxMzo0ODoyOC4wMDAw
MDAwMDAgLTA3MDAKKysrIHNwYXJzZS9wYXJzZS5jCTIwMDctMTAtMzAgMTM6NDk6MTcuMDAwMDAw
MDAwIC0wNzAwCkBAIC0xNjc4LDI1ICsxNjc4LDMwIEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKnBh
cnNlX2lmX3N0YXRlbWVudCgKIAlyZXR1cm4gc3RhdGVtZW50KHRva2VuLT5uZXh0LCAmc3RtdC0+
aWZfZmFsc2UpOwogfQogCi1zdGF0aWMgaW5saW5lIHN0cnVjdCB0b2tlbiAqY2FzZV9zdGF0ZW1l
bnQoc3RydWN0IHRva2VuICp0b2tlbiwgc3RydWN0IHN0YXRlbWVudCAqc3RtdCkKLXsKLQlzdG10
LT50eXBlID0gU1RNVF9DQVNFOwotCXRva2VuID0gZXhwZWN0KHRva2VuLCAnOicsICJhZnRlciBk
ZWZhdWx0L2Nhc2UiKTsKLQlhZGRfY2FzZV9zdGF0ZW1lbnQoc3RtdCk7Ci0JcmV0dXJuIHN0YXRl
bWVudCh0b2tlbiwgJnN0bXQtPmNhc2Vfc3RhdGVtZW50KTsKLX0KLQogc3RhdGljIHN0cnVjdCB0
b2tlbiAqcGFyc2VfY2FzZV9zdGF0ZW1lbnQoc3RydWN0IHRva2VuICp0b2tlbiwgc3RydWN0IHN0
YXRlbWVudCAqc3RtdCkKIHsKLQl0b2tlbiA9IHBhcnNlX2V4cHJlc3Npb24odG9rZW4tPm5leHQs
ICZzdG10LT5jYXNlX2V4cHJlc3Npb24pOwotCWlmIChtYXRjaF9vcCh0b2tlbiwgU1BFQ0lBTF9F
TExJUFNJUykpCi0JCXRva2VuID0gcGFyc2VfZXhwcmVzc2lvbih0b2tlbi0+bmV4dCwgJnN0bXQt
PmNhc2VfdG8pOwotCXJldHVybiBjYXNlX3N0YXRlbWVudCh0b2tlbiwgc3RtdCk7CisJZm9yICg7
OykgeworCQl0b2tlbiA9IHBhcnNlX2V4cHJlc3Npb24odG9rZW4tPm5leHQsICZzdG10LT5jYXNl
X2V4cHJlc3Npb24pOworCQlpZiAobWF0Y2hfb3AodG9rZW4sIFNQRUNJQUxfRUxMSVBTSVMpKQor
CQkJdG9rZW4gPSBwYXJzZV9leHByZXNzaW9uKHRva2VuLT5uZXh0LCAmc3RtdC0+Y2FzZV90byk7
CisJCXN0bXQtPnR5cGUgPSBTVE1UX0NBU0U7CisJCXRva2VuID0gZXhwZWN0KHRva2VuLCAnOics
ICJhZnRlciBjYXNlIik7CisJCWFkZF9jYXNlX3N0YXRlbWVudChzdG10KTsKKwkJaWYgKCFtYXRj
aF9pZGVudCh0b2tlbiwgJmNhc2VfaWRlbnQpKQorCQkJYnJlYWs7CisJCXN0bXQtPmNhc2Vfc3Rh
dGVtZW50ID0gYWxsb2Nfc3RhdGVtZW50KHRva2VuLT5wb3MsIFNUTVRfQ0FTRSk7CisJCXN0bXQg
PSBzdG10LT5jYXNlX3N0YXRlbWVudDsKKwkJdG9rZW4gPSB0b2tlbi0+bmV4dDsKKwl9CisJcmV0
dXJuIHN0YXRlbWVudCh0b2tlbiwgJnN0bXQtPmNhc2Vfc3RhdGVtZW50KTsKIH0KIAogc3RhdGlj
IHN0cnVjdCB0b2tlbiAqcGFyc2VfZGVmYXVsdF9zdGF0ZW1lbnQoc3RydWN0IHRva2VuICp0b2tl
biwgc3RydWN0IHN0YXRlbWVudCAqc3RtdCkKIHsKLQlyZXR1cm4gY2FzZV9zdGF0ZW1lbnQodG9r
ZW4tPm5leHQsIHN0bXQpOworCXN0bXQtPnR5cGUgPSBTVE1UX0NBU0U7CisJdG9rZW4gPSBleHBl
Y3QodG9rZW4tPm5leHQsICc6JywgImFmdGVyIGRlZmF1bHQiKTsKKwlhZGRfY2FzZV9zdGF0ZW1l
bnQoc3RtdCk7CisJcmV0dXJuIHN0YXRlbWVudCh0b2tlbiwgJnN0bXQtPmNhc2Vfc3RhdGVtZW50
KTsKIH0KIAogc3RhdGljIHN0cnVjdCB0b2tlbiAqcGFyc2VfbG9vcF9pdGVyYXRvcihzdHJ1Y3Qg
dG9rZW4gKnRva2VuLCBzdHJ1Y3Qgc3RhdGVtZW50ICpzdG10KQpJbmRleDogc3BhcnNlL2xpbmVh
cml6ZS5jCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL2xpbmVhcml6ZS5jCTIwMDctMTAtMzAg
MTM6NDg6MjguMDAwMDAwMDAwIC0wNzAwCisrKyBzcGFyc2UvbGluZWFyaXplLmMJMjAwNy0xMC0z
MCAxMzo1NToyNi4wMDAwMDAwMDAgLTA3MDAKQEAgLTE4OTQsNyArMTg5NCwxMiBAQCBwc2V1ZG9f
dCBsaW5lYXJpemVfc3RhdGVtZW50KHN0cnVjdCBlbnRyCiAJfQogCiAJY2FzZSBTVE1UX0NBU0U6
IHsKLQkJYWRkX2xhYmVsKGVwLCBzdG10LT5jYXNlX2xhYmVsKTsKKwkJZm9yICg7OykgeworCQkJ
YWRkX2xhYmVsKGVwLCBzdG10LT5jYXNlX2xhYmVsKTsKKwkJCWlmIChzdG10LT5jYXNlX3N0YXRl
bWVudC0+dHlwZSAhPSBTVE1UX0NBU0UpCisJCQkJYnJlYWs7CisJCQlzdG10ID0gc3RtdC0+Y2Fz
ZV9zdGF0ZW1lbnQ7CisJCX0KIAkJbGluZWFyaXplX3N0YXRlbWVudChlcCwgc3RtdC0+Y2FzZV9z
dGF0ZW1lbnQpOwogCQlicmVhazsKIAl9CkluZGV4OiBzcGFyc2UvdmFsaWRhdGlvbi9saW1pdHMt
Y2FzZWxhYmVscy5jCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL3ZhbGlkYXRpb24vbGltaXRz
LWNhc2VsYWJlbHMuYwkyMDA3LTEwLTMwIDEzOjUwOjE5LjAwMDAwMDAwMCAtMDcwMAorKysgc3Bh
cnNlL3ZhbGlkYXRpb24vbGltaXRzLWNhc2VsYWJlbHMuYwkyMDA3LTEwLTMwIDEzOjU3OjAxLjAw
MDAwMDAwMCAtMDcwMApAQCAtMCwwICsxLDI3IEBACisjZGVmaW5lIExJTTEoeCkgeCMjMDogeCMj
MTogeCMjMjogeCMjMzogeCMjNDogeCMjNTogeCMjNjogeCMjNzogeCMjODogeCMjOToKKyNkZWZp
bmUgTElNMih4KSBMSU0xKHgjIzApIExJTTEoeCMjMSkgTElNMSh4IyMyKSBMSU0xKHgjIzMpIExJ
TTEoeCMjNCkgXAorICAgICAgICAgICAgICAgTElNMSh4IyM1KSBMSU0xKHgjIzYpIExJTTEoeCMj
NykgTElNMSh4IyM4KSBMSU0xKHgjIzkpCisjZGVmaW5lIExJTTMoeCkgTElNMih4IyMwKSBMSU0y
KHgjIzEpIExJTTIoeCMjMikgTElNMih4IyMzKSBMSU0yKHgjIzQpIFwKKyAgICAgICAgICAgICAg
IExJTTIoeCMjNSkgTElNMih4IyM2KSBMSU0yKHgjIzcpIExJTTIoeCMjOCkgTElNMih4IyM5KQor
I2RlZmluZSBMSU00KHgpIExJTTMoeCMjMCkgTElNMyh4IyMxKSBMSU0zKHgjIzIpIExJTTMoeCMj
MykgTElNMyh4IyM0KSBcCisgICAgICAgICAgICAgICBMSU0zKHgjIzUpIExJTTMoeCMjNikgTElN
Myh4IyM3KSBMSU0zKHgjIzgpIExJTTMoeCMjOSkKKyNkZWZpbmUgTElNNSh4KSBMSU00KHgjIzAp
IExJTTQoeCMjMSkgTElNNCh4IyMyKSBMSU00KHgjIzMpIExJTTQoeCMjNCkgXAorICAgICAgICAg
ICAgICAgTElNNCh4IyM1KSBMSU00KHgjIzYpIExJTTQoeCMjNykgTElNNCh4IyM4KSBMSU00KHgj
IzkpCisjZGVmaW5lIExJTTYoeCkgTElNNSh4IyMwKSBMSU01KHgjIzEpIExJTTUoeCMjMikgTElN
NSh4IyMzKSBMSU01KHgjIzQpIFwKKyAgICAgICAgICAgICAgIExJTTUoeCMjNSkgTElNNSh4IyM2
KSBMSU01KHgjIzcpIExJTTUoeCMjOCkgTElNNSh4IyM5KQorI2RlZmluZSBMSU03KHgpIExJTTYo
eCMjMCkgTElNNih4IyMxKSBMSU02KHgjIzIpIExJTTYoeCMjMykgTElNNih4IyM0KSBcCisgICAg
ICAgICAgICAgICBMSU02KHgjIzUpIExJTTYoeCMjNikgTElNNih4IyM3KSBMSU02KHgjIzgpIExJ
TTYoeCMjOSkKKwordm9pZCBxMTlfZnVuYyAobG9uZyBpKTsKK3ZvaWQgcTE5X2Z1bmMgKGxvbmcg
aSkKK3sKKyBzd2l0Y2ggKGkpIHsKKyAgIExJTTUgKGNhc2UgMSkKKyAgICAgYnJlYWs7CisgfQor
fQorCisvKgorICogY2hlY2stbmFtZTogRW1wdHkgY2FzZSBsYWJlbCBsaW1pdHMuCisgKi8KKwo=

------=_Part_914_26085076.1193786680621--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: sparse breakage triggered by rcu_read_lock() lockdep ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-kernel
Subject: Re: [PATCH] Re: sparse breakage triggered by rcu_read_lock() lockdep
Date: Sun, 21 Oct 2007 03:34:04 +0000
Message-ID: <471AC8AC.7020701 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE744594351A95E063B70FA5E
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> OK, I get a trivial fix after all. The test case is fixed now.
> I haven't done much test otherwise.
>=20
> See the patch attached.

Nice work Chris!  Patch applied and pushed out.

I may roll an 0.4.1 release in the near future to fix kernel
builds with Sparse.

- Josh Triplett



--------------enigE744594351A95E063B70FA5E
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHGsisGJuZRtD+evsRAvRoAJ4pMW/OVO7I2SoWCSIlW11pNx5FqACgjG3m
FdZN8gvX5eRftrcuMsjnTgk=
=a/D+
-----END PGP SIGNATURE-----

--------------enigE744594351A95E063B70FA5E--
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH] Re: sparse breakage triggered by rcu_read_lock() lockdep annotations ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Re: sparse breakage triggered by rcu_read_lock() lockdep annotations
Date: Fri, 19 Oct 2007 21:08:16 +0000
Message-ID: <70318cbf0710191408mfb372bah292028f7bafb6eec () mail ! gmail ! com>
--------------------
------=_Part_5118_17916161.1192828096056
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

OK, I get a trivial fix after all. The test case is fixed now.
I haven't done much test otherwise.

See the patch attached.

Chris


On 10/19/07, Chris Li <christ.li@gmail.com> wrote:
> Err,
>
> Sparse does not support the local label syntax yet. It just treats the
> second label "x:" as the same as the first one. Then the linearize
> code gets serious confused when it saw one label get define in two
> places.
>
> The fix seems not trivial from the first look.
>
> Chris
>
> On 10/16/07, Alexey Dobriyan <adobriyan@sw.ru> wrote:
> > FWIW, commit 851a67b825540a8e00c0be3ee25e4627ba8b133b
> > aka "lockdep: annotate rcu_read_{,un}lock{,_bh}"
> > causes sparse to trigger internal assertion in quite a few places over
> > allyesconfig run.
> >
> >         sparse: flow.c:805: rewrite_parent_branch: Assertion `changed' failed.
> >
> > Trimmed down testcase:
> >
> >         void f(unsigned long ip);
> >         static void g(void)
> >         {
> >                 if (1) {
> >                       f(({ __label__ x; x: (unsigned long)&&x; }));
> >                 }
> >                 f(({ __label__ x; x: (unsigned long)&&x; }));
> >         }
> >
> > #0  0x4001c410 in __kernel_vsyscall ()
> > (gdb) bt
> > #0  0x4001c410 in __kernel_vsyscall ()
> > #1  0x40050701 in raise () from /lib/libc.so.6
> > #2  0x40051e38 in abort () from /lib/libc.so.6
> > #3  0x40049fcc in __assert_fail () from /lib/libc.so.6
> > #4  0x08064947 in pack_basic_blocks (ep=0x411a1c6c) at flow.c:812
> > #5  0x0805ffbf in linearize_symbol (sym=0x4103ec8c) at linearize.c:2154
> > #6  0x080492a3 in main (argc=Cannot access memory at address 0x274d) at sparse.c:266
> >
> > -
> > To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> > the body of a message to majordomo@vger.kernel.org
> > More majordomo info at  http://vger.kernel.org/majordomo-info.html
> >
>

------=_Part_5118_17916161.1192828096056
Content-Type: application/octet-stream; name=local-label
Content-Transfer-Encoding: base64
X-Attachment-Id: f_f7z6uyun
Content-Disposition: attachment; filename=local-label

UGVyZm9ybSBsb2NhbCBsYWJlbCBsb29rdXAKClRoaXMgcGF0Y2ggZml4IHRoZSBzcGFyc2UgYnJl
YWthZ2UgdHJpZ2dlcmVkIGJ5CnJjdV9yZWFkX2xvY2soKSBsb2NrZGVwIGFubm90YXRpb25zLgoK
Tm93IHNwYXJzZSBsb29rIHVwIHRoZSBsb2NhbCBsYWJlbCBpbiBzeW1ib2wgbm9kZQpuYW1lIHNw
YWNlIGFzIHdlbGwsIGp1c3QgbGlrZSBsb29raW5nIHVwIGEgbm9ybWFsCnN5bWJvbCBub2RlLiBO
b3cgYSBsYWJsZSBzeW1ib2wgY2FuIGJlIGJvdGgKdHlwZSBTWU1fTEFCRUwgb3IgU1lNX05PREUg
d2l0aCBNT0RfTEFCRUwuCgpTaW5nZWQtT2ZmLUJ5OiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNo
cmlzbGkub3JnPgoKSW5kZXg6IHNwYXJzZS9wYXJzZS5jCj09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5v
cmlnL3BhcnNlLmMJMjAwNy0xMC0xOSAxMzo1MjozNy4wMDAwMDAwMDAgLTA3MDAKKysrIHNwYXJz
ZS9wYXJzZS5jCTIwMDctMTAtMTkgMTM6NTU6MjMuMDAwMDAwMDAwIC0wNzAwCkBAIC00NTksNiAr
NDU5LDE2IEBAIHN0YXRpYyBzdHJ1Y3Qgc3ltYm9sICpsb29rdXBfb3JfY3JlYXRlX3MKIAlyZXR1
cm4gc3ltOwogfQogCitzdGF0aWMgc3RydWN0IHN5bWJvbCAqIGxvY2FsX2xhYmVsKHN0cnVjdCB0
b2tlbiAqdG9rZW4pCit7CisJc3RydWN0IHN5bWJvbCAqc3ltID0gbG9va3VwX3N5bWJvbCh0b2tl
bi0+aWRlbnQsIE5TX1NZTUJPTCk7CisKKwlpZiAoc3ltICYmIHN5bS0+Y3R5cGUubW9kaWZpZXJz
ICYgTU9EX0xBQkVMKQorCQlyZXR1cm4gc3ltOworCisJcmV0dXJuIE5VTEw7Cit9CisKIC8qCiAg
KiBOT1RFISBOU19MQUJFTCBpcyBub3QganVzdCBhIGRpZmZlcmVudCBuYW1lc3BhY2UsCiAgKiBp
dCBhbHNvIGVuZHMgdXAgdXNpbmcgZnVuY3Rpb24gc2NvcGUgaW5zdGVhZCBvZiB0aGUKQEAgLTQ2
Niw2ICs0NzYsOSBAQCBzdGF0aWMgc3RydWN0IHN5bWJvbCAqbG9va3VwX29yX2NyZWF0ZV9zCiAg
Ki8KIHN0cnVjdCBzeW1ib2wgKmxhYmVsX3N5bWJvbChzdHJ1Y3QgdG9rZW4gKnRva2VuKQogewor
CXN0cnVjdCBzeW1ib2wgKnN5bSA9IGxvY2FsX2xhYmVsKHRva2VuKTsKKwlpZiAoc3ltKQorCQly
ZXR1cm4gc3ltOwogCXJldHVybiBsb29rdXBfb3JfY3JlYXRlX3N5bWJvbChOU19MQUJFTCwgU1lN
X0xBQkVMLCB0b2tlbik7CiB9CiAKSW5kZXg6IHNwYXJzZS92YWxpZGF0aW9uL2xvY2FsLWxhYmVs
LmMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PQotLS0gc3BhcnNlLm9yaWcvdmFsaWRhdGlvbi9sb2NhbC1sYWJlbC5jCTIw
MDctMTAtMTkgMTM6NTI6NDAuMDAwMDAwMDAwIC0wNzAwCisrKyBzcGFyc2UvdmFsaWRhdGlvbi9s
b2NhbC1sYWJlbC5jCTIwMDctMTAtMTkgMTM6NTI6NDAuMDAwMDAwMDAwIC0wNzAwCkBAIC0wLDAg
KzEsOCBAQAordm9pZCBmKHVuc2lnbmVkIGxvbmcgaXApOworc3RhdGljIHZvaWQgZyh2b2lkKQor
eworICAgICAgIGlmICgxKSB7CisJICAgICBmKCh7IF9fbGFiZWxfXyB4OyB4OiAodW5zaWduZWQg
bG9uZykmJng7IH0pKTsKKyAgICAgICB9CisgICAgICAgZigoeyBfX2xhYmVsX18geDsgeDogKHVu
c2lnbmVkIGxvbmcpJiZ4OyB9KSk7Cit9Cg==
------=_Part_5118_17916161.1192828096056--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Sparse fooled by double semicolon ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Sparse fooled by double semicolon
Date: Wed, 31 Jan 2007 06:58:38 +0000
Message-ID: <20070131065838.GA23326 () chrisli ! org>
--------------------
Good catch, can you please try the following patch?

Chris

Fix double semicolon in struct declare

Pavel discover this test case:
#include <string.h>
void test(void)
{
       struct { int foo;; } val;
       memset(&val, 0, sizeof(val));
}

Sparse creates a member with empty ctype. We should skip that.

Signed-Off-By: Christopher Li<spase@chrisli.org>

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-01-29 14:46:09.000000000 -0800
+++ sparse/parse.c	2007-01-30 23:11:42.000000000 -0800
@@ -1039,7 +1039,8 @@ static struct token *struct_declaration_
 			sparse_error(token->pos, "expected ; at end of declaration");
 			break;
 		}
-		token = token->next;
+		while(match_op(token, ';'))
+			token = token->next;
 	}
 	return token;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH] Sparse fooled by double semicolon
Date: Wed, 31 Jan 2007 07:43:03 +0000
Message-ID: <1170229383.11455.102.camel () dv>
--------------------
On Tue, 2007-01-30 at 22:58 -0800, Christopher Li wrote:
> Good catch, can you please try the following patch?

Good fix, it's working!  Even on the original code.  Thank you!

-- 
Regards,
Pavel Roskin


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Update README to match changes in the initialization ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Update README to match changes in the initialization
Date: Tue, 27 Feb 2007 19:05:53 +0000
Message-ID: <45E48111.2000107 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigDA51990BCB93A91B4CA6C433
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

James Westby wrote:
> On (18/12/06 17:01), James Westby wrote:
>> There have been changes in the functions to call to get the parse tree=

>> from sparse, so update the README file to reflect these changes.
>=20
> My apologies, I didn't think that this message had made it, and the
> patch is incorrect anyway. My other patch supercedes this one.

OK.  I've applied your superseding patch, so I'll ignore this one.

- Josh Triplett



--------------enigDA51990BCB93A91B4CA6C433
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5IERGJuZRtD+evsRAqnoAKCwl6RZzzQAeDeG2zxZtKI/pAJ3CgCgkPAo
csl0VOhLEMfZNFsy24hCrOw=
=purs
-----END PGP SIGNATURE-----

--------------enigDA51990BCB93A91B4CA6C433--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Update the information in README about using the library. ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] Update the information in README about using the library.
Date: Tue, 27 Feb 2007 19:05:47 +0000
Message-ID: <45E4810B.2030301 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig0499B392E29F4A0D8C1B2EC0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

James Westby wrote:
> Changes in the library have left the README giving out of date informat=
ion
> on how to intialise the library and get the symbols out of it. Update t=
he
> documentation to match the latest functions.
>=20
> Signed-off-by: James Westby <jw+debian@jameswestby.net>

Applied.

- Josh Triplett



--------------enig0499B392E29F4A0D8C1B2EC0
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5IELGJuZRtD+evsRAotAAKCNaS7Ep5+pXFwgMNGEax15rI17pQCgozGH
QPsdgLztE2uiPI/dhn6NYTM=
=y8MY
-----END PGP SIGNATURE-----

--------------enig0499B392E29F4A0D8C1B2EC0--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] __DATE__ & __TIME expansion v2 ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] __DATE__ & __TIME expansion v2
Date: Mon, 21 May 2007 00:40:18 +0000
Message-ID: <4650EA72.7010101 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig3C6955A7CFA9659BB6BACE23
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Damien Lespiau wrote:
> Makes __DATE__expand to a character string literal of
> the form "Mmm dd yyyy" where the names of the months
> are the same as those generated by the asctime function,
> and the first character of dd is a space character if the
> value is less than 10.
> Makes __TIME__ expand to a a character string literal of
> the form "hh:mm:ss" as in the time generated by the
> asctime function.

Applied, thanks!

$ ./sparse -E /dev/stdin <<<'__DATE__ __TIME__' ; date

"May 20 2007" "17:39:38"
Sun May 20 17:39:38 PDT 2007

- Josh Triplett



--------------enig3C6955A7CFA9659BB6BACE23
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGUOpyGJuZRtD+evsRAm9WAJ9u5ANhl8z4BdT20TEupn+pwIECsACgk57d
dqRGTaonr2PCATWxAWBKYl4=
=eO+Y
-----END PGP SIGNATURE-----

--------------enig3C6955A7CFA9659BB6BACE23--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] add __builtin_labs() ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] add __builtin_labs()
Date: Thu, 23 Aug 2007 02:19:44 +0000
Message-ID: <46CCEEC0.5040606 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigC2FDBA43673B91AE2C4E567D
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Randy Dunlap wrote:
> From: Randy Dunlap <randy.dunlap@oracle.com>
>=20
> 2.6.23-rc3-mm1 has added a user of __builtin_labs(), so add this functi=
on
> to sparse lib.c to avoid the error messages.
>=20
>   CHECK   kernel/unwind.c
> kernel/unwind.c:1016:31: error: undefined identifier '__builtin_labs'
> kernel/unwind.c:1232:25: error: undefined identifier '__builtin_labs'
>=20
> Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>

Applied, thanks.

- Josh Triplett


--------------enigC2FDBA43673B91AE2C4E567D
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGzO7BGJuZRtD+evsRAuC0AJwPxry+Aw9O9UhXsPGqQ4NecNeYUgCfR4Yo
oHf79ukhTMlqF41qA4JSjU8=
=2ozB
-----END PGP SIGNATURE-----

--------------enigC2FDBA43673B91AE2C4E567D--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] allow ifdef in macro arguments ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] allow ifdef in macro arguments
Date: Sun, 21 Oct 2007 09:07:15 +0000
Message-ID: <70318cbf0710210207t587f8d2enf024a56e1d10a5df () mail ! gmail ! com>
--------------------
------=_Part_6650_21251426.1192957635261
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

I think some one report it long time ago.

Chris

------=_Part_6650_21251426.1192957635261
Content-Type: application/octet-stream; name=ifdef-macro-arg
Content-Transfer-Encoding: base64
X-Attachment-Id: f_f81bw7u2
Content-Disposition: attachment; filename=ifdef-macro-arg

QWxsb3cgI2lmZGVmIGluIG1hY3JvIGFyZ3VtZW50cwoKQXMgdGhlIGNhc2Ugc2hvd3MuIFNwYXJz
ZSBkb2VzIG5vdCBoYW5kbGUgcHJlLXByb2Nlc3MgaW4KbWFjcm8gYXJndW1lbnRzLgoKVGhpcyBw
YXRjaCBhbGxvdyB0aGUgcHJlLXByb2Nlc3MgY2FuIGhhcHBlbiBpbiBtYWNybyBhcmd1bWVudHMu
CgpTaWduZWQtT2ZmLUJ5OiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgoKSW5k
ZXg6IHNwYXJzZS9wcmUtcHJvY2Vzcy5jCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL3ByZS1w
cm9jZXNzLmMJMjAwNy0xMC0yMSAwMDo1NjozNy4wMDAwMDAwMDAgLTA3MDAKKysrIHNwYXJzZS9w
cmUtcHJvY2Vzcy5jCTIwMDctMTAtMjEgMDE6NTc6MDEuMDAwMDAwMDAwIC0wNzAwCkBAIC04Myw2
ICs4Myw3IEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKmFsbG9jX3Rva2VuKHN0cnVjdCAKIH0KIAog
c3RhdGljIGNvbnN0IGNoYXIgKnNob3dfdG9rZW5fc2VxdWVuY2Uoc3RydWN0IHRva2VuICp0b2tl
bik7CitzdGF0aWMgaW5saW5lIHN0cnVjdCB0b2tlbiAqbmV4dF9wcmVwcm9jZXNzX3Rva2VuKHN0
cnVjdCB0b2tlbiAqKmxpc3QpOwogCiAvKiBFeHBhbmQgc3ltYm9sICdzeW0nIGF0ICcqbGlzdCcg
Ki8KIHN0YXRpYyBpbnQgZXhwYW5kKHN0cnVjdCB0b2tlbiAqKiwgc3RydWN0IHN5bWJvbCAqKTsK
QEAgLTE5OSw3ICsyMDAsNyBAQCBzdGF0aWMgc3RydWN0IHRva2VuICpjb2xsZWN0X2FyZyhzdHJ1
Y3QgCiAJc3RydWN0IHRva2VuICpuZXh0OwogCWludCBuZXN0aW5nID0gMDsKIAotCXdoaWxlICgh
ZW9mX3Rva2VuKG5leHQgPSBzY2FuX25leHQocCkpKSB7CisJd2hpbGUgKChuZXh0ID0gbmV4dF9w
cmVwcm9jZXNzX3Rva2VuKHApKSkgewogCQlpZiAobWF0Y2hfb3AobmV4dCwgJygnKSkgewogCQkJ
bmVzdGluZysrOwogCQl9IGVsc2UgaWYgKG1hdGNoX29wKG5leHQsICcpJykpIHsKQEAgLTE3MDIs
NyArMTcwMyw3IEBAIHN0YXRpYyB2b2lkIHByZXByb2Nlc3Nvcl9saW5lKHN0cnVjdCBzdHIKIAlo
YW5kbGVfcHJlcHJvY2Vzc29yX2xpbmUoc3RyZWFtLCBsaW5lLCBzdGFydCk7CiB9CiAKLXN0YXRp
YyB2b2lkIGRvX3ByZXByb2Nlc3Moc3RydWN0IHRva2VuICoqbGlzdCkKK3N0YXRpYyBpbmxpbmUg
c3RydWN0IHRva2VuICpuZXh0X3ByZXByb2Nlc3NfdG9rZW4oc3RydWN0IHRva2VuICoqbGlzdCkK
IHsKIAlzdHJ1Y3QgdG9rZW4gKm5leHQ7CiAKQEAgLTE3NDAsMTEgKzE3NDEsMjIgQEAgc3RhdGlj
IHZvaWQgZG9fcHJlcHJvY2VzcyhzdHJ1Y3QgdG9rZW4gKgogCQkJCV9fZnJlZV90b2tlbihuZXh0
KTsKIAkJCQljb250aW51ZTsKIAkJCX0KLQotCQkJaWYgKHRva2VuX3R5cGUobmV4dCkgIT0gVE9L
RU5fSURFTlQgfHwKLQkJCSAgICBleHBhbmRfb25lX3N5bWJvbChsaXN0KSkKLQkJCQlsaXN0ID0g
Jm5leHQtPm5leHQ7CiAJCX0KKwkJcmV0dXJuIG5leHQ7CisJfQorCisJcmV0dXJuIE5VTEw7Cit9
CisKKworc3RhdGljIHZvaWQgZG9fcHJlcHJvY2VzcyhzdHJ1Y3QgdG9rZW4gKipsaXN0KQorewor
CXN0cnVjdCB0b2tlbiAqbmV4dDsKKworCXdoaWxlICgobmV4dCA9IG5leHRfcHJlcHJvY2Vzc190
b2tlbihsaXN0KSkpIHsKKwkJaWYgKHRva2VuX3R5cGUobmV4dCkgIT0gVE9LRU5fSURFTlQgfHwK
KwkJICAgIGV4cGFuZF9vbmVfc3ltYm9sKGxpc3QpKQorCQkJbGlzdCA9ICZuZXh0LT5uZXh0Owog
CX0KIH0KIApJbmRleDogc3BhcnNlL3ZhbGlkYXRpb24vbWFjcm8tYXJndW1lbnQtaWZkZWYuYwo9
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09Ci0tLSBzcGFyc2Uub3JpZy92YWxpZGF0aW9uL21hY3JvLWFyZ3VtZW50LWlmZGVm
LmMJMjAwNy0xMC0yMSAwMTo1NzowMS4wMDAwMDAwMDAgLTA3MDAKKysrIHNwYXJzZS92YWxpZGF0
aW9uL21hY3JvLWFyZ3VtZW50LWlmZGVmLmMJMjAwNy0xMC0yMSAwMTo1NzowMS4wMDAwMDAwMDAg
LTA3MDAKQEAgLTAsMCArMSwxNyBAQAorI2RlZmluZSBmb28oYSxiLGMpIGJhcihhLGIsYykKKwor
c3RhdGljIHZvaWQgYmFyKGludCBhLCBpbnQgYiwgaW50IGMpCit7Cit9CisKK3N0YXRpYyB2b2lk
IHRlc3Qodm9pZCkKK3sKKwlmb28oMSwKKyNpZmRlZiBOT1QKKwkyLAorI2Vsc2UKKwkzLAorI2Vu
ZGlmCisJNCk7Cit9CisK
------=_Part_6650_21251426.1192957635261--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Re: [PATCH] allow ifdef in macro arguments
Date: Sun, 21 Oct 2007 09:18:33 +0000
Message-ID: <20071021091833.GB12794 () ins ! uni-bonn ! de>
--------------------
Hello Christopher,

* Christopher Li wrote on Sun, Oct 21, 2007 at 11:07:15AM CEST:
> I think some one report it long time ago.

FWIW, embedding directives within macro arguments is not portable
(warned by with gcc -pedantic), and causes undefined behavior according
to C99:6.10.3p11.

Cheers,
Ralf
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] allow ifdef in macro arguments
Date: Mon, 22 Oct 2007 00:03:52 +0000
Message-ID: <471BE8E8.3020200 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig8E07F4C445635B06C7655F00
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> On Sun, Oct 21, 2007 at 02:07:15AM -0700, Christopher Li wrote:
>> I think some one report it long time ago.
>=20
> It should not accept those.  Undefined behaviour and if you try to actu=
ally
> define the semantics for it, you run into such a pile of corner cases t=
hat
> it's not worth even trying.

Do you think the cases handled by GCC warrant making an attempt and
warning about it, or should Sparse just throw up its hands and give
up?

If the latter, should Sparse make any attempt at all to detect
preprocessor conditionals in macro arguments so it can give a more
specific warning?

- Josh Triplett


--------------enig8E07F4C445635B06C7655F00
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHG+joGJuZRtD+evsRAugsAKC+39p7x7UydUEYj/3G/V5pKMXKjwCfS3iU
sz9IzTb7++T1snPs+UcT8jA=
=a+v5
-----END PGP SIGNATURE-----

--------------enig8E07F4C445635B06C7655F00--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] allow ifdef in macro arguments
Date: Mon, 22 Oct 2007 16:13:02 +0000
Message-ID: <70318cbf0710220913y35ab6128jeb0c0c413e40f22e () mail ! gmail ! com>
--------------------
I want to know the answer too so I can try a different patch
or just forget about it.

Chris

On 10/21/07, Josh Triplett <josh@freedesktop.org> wrote:
> Al Viro wrote:
> > On Sun, Oct 21, 2007 at 02:07:15AM -0700, Christopher Li wrote:
> >> I think some one report it long time ago.
> >
> > It should not accept those.  Undefined behaviour and if you try to actually
> > define the semantics for it, you run into such a pile of corner cases that
> > it's not worth even trying.
>
> Do you think the cases handled by GCC warrant making an attempt and
> warning about it, or should Sparse just throw up its hands and give
> up?
>
> If the latter, should Sparse make any attempt at all to detect
> preprocessor conditionals in macro arguments so it can give a more
> specific warning?
>
> - Josh Triplett
>
>
>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] better recovery from bad operations on bitwise ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] better recovery from bad operations on bitwise
Date: Fri, 25 May 2007 03:57:54 +0000
Message-ID: <E1HrQw6-000194-JQ () ZenIV ! linux ! org ! uk>
--------------------

degrade to integer type, generate a warning and move on...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c |   29 ++++++++++++++++++++---------
 1 files changed, 20 insertions(+), 9 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index e44426b..80ac7d1 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -582,16 +582,32 @@ static int ptr_object_size(struct symbol *ptr_type)
 	return ptr_type->bit_size;
 }
 
+static inline int want_int(struct expression **expr, struct symbol **ctype)
+{
+	int class = classify_type((*expr)->ctype, ctype);
+
+	if (!(class & TYPE_NUM))
+		return 0;
+	if (!(class & TYPE_RESTRICT))
+		return 1;
+	warning((*expr)->pos, "restricted degrades to integer");
+	if (class & TYPE_FOULED)	/* unfoul it first */
+		(*ctype) = (*ctype)->ctype.base_type;
+	(*ctype) = (*ctype)->ctype.base_type;	/* get to arithmetic type */
+	*expr = cast_to(*expr, *ctype);
+	return 1;
+}
+
 static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *ctype, struct expression **ip)
 {
 	struct expression *i = *ip;
-	struct symbol *ptr_type = ctype;
+	struct symbol *ptr_type = ctype, *itype;
 	int bit_size;
 
 	if (ptr_type->type == SYM_NODE)
 		ptr_type = ptr_type->ctype.base_type;
 
-	if (!is_int_type(i->ctype))
+	if (!want_int(&i, &itype))
 		return bad_expr_type(expr);
 
 	examine_symbol_type(ctype);
@@ -943,14 +959,9 @@ static struct symbol *evaluate_logical(struct expression *expr)
 
 static struct symbol *evaluate_shift(struct expression *expr)
 {
-	struct expression *left = expr->left, *right = expr->right;
-	struct symbol *ltype = left->ctype, *rtype = right->ctype;
+	struct symbol *ltype, *rtype;
 
-	if (ltype->type == SYM_NODE)
-		ltype = ltype->ctype.base_type;
-	if (rtype->type == SYM_NODE)
-		rtype = rtype->ctype.base_type;
-	if (is_int_type(ltype) && is_int_type(rtype)) {
+	if (want_int(&expr->left, &ltype) && want_int(&expr->right, &rtype)) {
 		struct symbol *ctype = integer_promotion(ltype);
 		expr->left = cast_to(expr->left, ctype);
 		expr->ctype = ctype;
-- 
1.5.0-rc2.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] c2xml ===

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] c2xml
Date: Wed, 27 Jun 2007 18:49:47 +0000
Message-ID: <1182970187.8970.145.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Wed, 2007-06-27 at 14:51 +0100, Rob Taylor wrote:
> Here's something I've hacked up for my work on gobject-introspection
> [1]. It basically dumps the parse tree for a given file as simplistic
> xml, suitable for further transformation by something else (in my case,
> some python).
> 
> I'd expect this to also be useful for code navigation in editors and c
> refactoring tools, but I've really only focused on my needs for c api
> description.
> 
> There are 3 patches here. The first introduces a field in the symbol
> struct for the end position of the symbol. I've added this in my case
> for documentation generation, but again I think it'd be useful in other
> cases. The next introduces a sparse_keep_tokens, which parses a file,
> but doesn't free the tokens after parsing. The final one adds c2xml and
> the DTD for the xml format. It builds conditionally on whether libxml2
> is available.
> 
> All feedback appreciated!

Wow.  Very nice.  I can already think of several other uses for this.

A few suggestions:

      * Please sign off your patches.  See
        http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;hb=HEAD;f=Documentation/SubmittingPatches , section "Sign your work", for details on the Developer's Certificate of Origin and the Signed-off-by convention.  I really need to include some documentation in the Sparse source tree, though.
      * Rather than specifying start="line:col" end="line:col", how
        about splitting those up into start-line, start-col, end-line,
        and end-col?  That would avoid the need to do string parsing
        after reading the XML.
      * Positions have file information associated with them.  A symbol
        might potentially start in one file and end in another, if
        people play crazy games with #include.  start-file and end-file?
      * Typo in examine_namespace: "Unregonized namespace".
      * get_type_name seems generally useful, and several other parts of
        Sparse (such as in evaluate.c and show-parse.c) could become
        simpler by using it.  How about putting it in symbol.c and
        exposing it via symbol.h?  Can you do that in a separate patch,
        please?
      * Also, should get_type_name perhaps look up the string in an
        array rather than using switch?  (I don't know which makes more
        sense.)
      * I don't know how much work this would require, but it doesn't
        seem like c2xml gets much value out of using libxml, so would it
        make things very painful to just print XML directly?  It would
        certainly make things like BAD_CAST and having to snprintf to
        local buffers go away.  If you count on libxml for some form of
        escaping or similar, please ignore this; however, as far as I
        can tell, all of the strings that c2xml works with (such as
        identifiers) can't have unusual characters in them.
      * Please don't include vim modelines in source files.  (Same goes
        for emacs and similar.)
      * Please explicitly limit the possible values of the type
        attribute to those that Sparse produces, rather than allowing
        any arbitrary CDATA.  The same goes for a few other 
      * Please consider including information from the context and
        address space attributes.
      * In examine_modifiers, please use C99-style designated assignment
        for the modifiers array, for clarity and robustness.
      * I suspect several of the modifiers in examine_modifiers don't
        need to generate output; I think you want to ignore everything
        in MOD_IGNORE.
      * Rather than the current base-type and base-type-builtin
        mechanism, you might consider having designated IDs for the base
        types and using those in base-type.  You could even output the
        builtin types if you want.  I don't know if this makes things
        easier or harder for consumers of the output; what do you think?
      * I don't know if sparse_keep_symbols seems like the right API.
        Sparse's approach to memory management (or lack thereof) bugs me
        a bit.  More importantly, though, it makes the hierarchy of
        functions sparse(), then __sparse(), then sparse_keep_symbols(),
        which seems strange.  I don't know a better solution offhand,
        though; don't worry too much about addressing this.

Note that you don't need to address all of these before resending.  In
particular, I'd love to merge the first patch, and I just need a signoff
for it.

Thanks again for this work; it looks great, and highly useful.

- Josh Triplett

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rob Taylor <rob.taylor () codethink ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH] c2xml
Date: Thu, 28 Jun 2007 10:59:38 +0000
Message-ID: <468394EB.5070608 () codethink ! co ! uk>
--------------------
Josh Triplett wrote:
> Josh Triplett wrote:
>> On Wed, 2007-06-27 at 14:51 +0100, Rob Taylor wrote:
>>> Here's something I've hacked up for my work on gobject-introspection
>>> [1]. It basically dumps the parse tree for a given file as simplistic
>>> xml, suitable for further transformation by something else (in my case,
>>> some python).
>>>
>>> I'd expect this to also be useful for code navigation in editors and c
>>> refactoring tools, but I've really only focused on my needs for c api
>>> description.
>>>
>>> There are 3 patches here. The first introduces a field in the symbol
>>> struct for the end position of the symbol. I've added this in my case
>>> for documentation generation, but again I think it'd be useful in other
>>> cases. The next introduces a sparse_keep_tokens, which parses a file,
>>> but doesn't free the tokens after parsing. The final one adds c2xml and
>>> the DTD for the xml format. It builds conditionally on whether libxml2
>>> is available.
>>>
>>> All feedback appreciated!
>> Wow.  Very nice.  I can already think of several other uses for this.
> [...]
>>       * Please consider including information from the context and
>>         address space attributes.
> 
> Actually, don't worry about that one; we can always add it later, and I'd love
> to see this get merged as soon as possible.

Yes, I was about to say I deliberately left this out as I don't need it
for my use case, but it shouldn't be difficult to add if the need arises
for it.

>>       * Rather than the current base-type and base-type-builtin
>>         mechanism, you might consider having designated IDs for the base
>>         types and using those in base-type.  You could even output the
>>         builtin types if you want.  I don't know if this makes things
>>         easier or harder for consumers of the output; what do you think?
> 
> On second thought, ignore this.  We can always change it later, but having a
> special syntax for the base types makes sense to me.  Anything that cares
> about types will need to understand the base types.

Agreed.

>>       * I don't know if sparse_keep_symbols seems like the right API.
>>         Sparse's approach to memory management (or lack thereof) bugs me
>>         a bit.  More importantly, though, it makes the hierarchy of
>>         functions sparse(), then __sparse(), then sparse_keep_symbols(),
>>         which seems strange.  I don't know a better solution offhand,
>>         though; don't worry too much about addressing this.
> 
> Ignore this too.  The API you propose will work fine for now, and I don't want
> to hold up merging the patch on trying to think of the perfect API for
> something not directly related to the point of your patch.

Heh, yeah, sorting out memory management is quite a scary prospect :) I
think we'd basically need to go for some sort of reference counting
scheme, but that'd need some very careful work to deal with potential
cycles.

>> Thanks again for this work; it looks great, and highly useful.

Thanks!

Rob
Rob

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rob Taylor <rob.taylor () codethink ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH] c2xml
Date: Mon, 02 Jul 2007 12:32:26 +0000
Message-ID: <4688F05A.5010801 () codethink ! co ! uk>
--------------------
This is a multi-part message in MIME format.
--------------040700010305000000020101
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

Josh Triplett wrote:
> On Wed, 2007-06-27 at 14:51 +0100, Rob Taylor wrote:
>> Here's something I've hacked up for my work on gobject-introspection
>> [1]. It basically dumps the parse tree for a given file as simplistic
>> xml, suitable for further transformation by something else (in my case,
>> some python).
>>
>> I'd expect this to also be useful for code navigation in editors and c
>> refactoring tools, but I've really only focused on my needs for c api
>> description.
>>
>> There are 3 patches here. The first introduces a field in the symbol
>> struct for the end position of the symbol. I've added this in my case
>> for documentation generation, but again I think it'd be useful in other
>> cases. The next introduces a sparse_keep_tokens, which parses a file,
>> but doesn't free the tokens after parsing. The final one adds c2xml and
>> the DTD for the xml format. It builds conditionally on whether libxml2
>> is available.
>>
>> All feedback appreciated!
> 
> Wow.  Very nice.  I can already think of several other uses for this.

Glad you like it :) OOI, what other uses are you thinking of?

> A few suggestions:
> 
>       * Please sign off your patches.  See
>         http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;hb=HEAD;f=Documentation/SubmittingPatches , section "Sign your work", for details on the Developer's Certificate of Origin and the Signed-off-by convention.  I really need to include some documentation in the Sparse source tree, though.

Ah, I did wonder what the 'signed-off-by' signified.

>       * Rather than specifying start="line:col" end="line:col", how
>         about splitting those up into start-line, start-col, end-line,
>         and end-col?  That would avoid the need to do string parsing
>         after reading the XML.

Yes. I originally had a more human-readable form, and this is a hangover
from that approach.

>       * Positions have file information associated with them.  A symbol
>         might potentially start in one file and end in another, if
>         people play crazy games with #include.  start-file and end-file?

Yes, optional end-file would be sensible. Hopefully it wouldn't occur
very often ;)

>       * Typo in examine_namespace: "Unregonized namespace".
yes.

>       * get_type_name seems generally useful, and several other parts of
>         Sparse (such as in evaluate.c and show-parse.c) could become
>         simpler by using it.  How about putting it in symbol.c and
>         exposing it via symbol.h?  Can you do that in a separate patch,
>         please?

Sure.
>       * Also, should get_type_name perhaps look up the string in an
>         array rather than using switch?  (I don't know which makes more
>         sense.)

Yeah, an array lookup would be better.

>       * I don't know how much work this would require, but it doesn't
>         seem like c2xml gets much value out of using libxml, so would it
>         make things very painful to just print XML directly?  It would
>         certainly make things like BAD_CAST and having to snprintf to
>         local buffers go away.  If you count on libxml for some form of
>         escaping or similar, please ignore this; however, as far as I
>         can tell, all of the strings that c2xml works with (such as
>         identifiers) can't have unusual characters in them.

Well, I'm using the tree builder. It would be non-trivial to rewrite
without it - see in examine_symbol where I add new nodes to the root
node and recurse from there.

>       * Please don't include vim modelines in source files.  (Same goes
>         for emacs and similar.)

Sure

>       * Please explicitly limit the possible values of the type
>         attribute to those that Sparse produces, rather than allowing
>         any arbitrary CDATA.  The same goes for a few other 

Ah, yes, good idea.

<snip>

>       * In examine_modifiers, please use C99-style designated assignment
>         for the modifiers array, for clarity and robustness.

Hmm, not sure how best to do this. Redefine MOD_* in terms of shifts of
some linearly assigned constants?

>       * I suspect several of the modifiers in examine_modifiers don't
>         need to generate output; I think you want to ignore everything
>         in MOD_IGNORE.

Do we really want to not emit any from MOD_STORAGE? I guess if we have
scoping info at a later date, we can certainly drop MOD_TOPLEVEL, but
that seems useful ATM. MOD_ADDRESSABLE seems useful. MOD_ASSIGNED,
MOD_USERTYPE, MOD_FORCE, MOD_ACCESSED and MOD_EXPLICTLY_SIGNED don't
seem very useful though.

I think MOD_TYPEDEF would be useful,but I never actually see it. Do you
know what's going on here?


Attached you should find the updated patchset with all the changes
discussed apart from the modifiers stuff discussed above.

<snip>

> 
> Note that you don't need to address all of these before resending.  In
> particular, I'd love to merge the first patch, and I just need a signoff
> for it.
> 
> Thanks again for this work; it looks great, and highly useful.

Thanks to you too!

Rob Taylor


--------------040700010305000000020101
Content-Type: text/x-patch;
 name="0001-add-end-position-to-symbols.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="0001-add-end-position-to-symbols.patch"


================================================================================

From: Rob Taylor <rob.taylor () codethink ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH] c2xml
Date: Fri, 13 Jul 2007 15:50:35 +0000
Message-ID: <46979F4B.9050307 () codethink ! co ! uk>
--------------------
Any followups on this?

Thanks,
Rob

Rob Taylor wrote:
> Josh Triplett wrote:
>> On Wed, 2007-06-27 at 14:51 +0100, Rob Taylor wrote:
>>> Here's something I've hacked up for my work on gobject-introspection
>>> [1]. It basically dumps the parse tree for a given file as simplistic
>>> xml, suitable for further transformation by something else (in my case,
>>> some python).
>>>
>>> I'd expect this to also be useful for code navigation in editors and c
>>> refactoring tools, but I've really only focused on my needs for c api
>>> description.
>>>
>>> There are 3 patches here. The first introduces a field in the symbol
>>> struct for the end position of the symbol. I've added this in my case
>>> for documentation generation, but again I think it'd be useful in other
>>> cases. The next introduces a sparse_keep_tokens, which parses a file,
>>> but doesn't free the tokens after parsing. The final one adds c2xml and
>>> the DTD for the xml format. It builds conditionally on whether libxml2
>>> is available.
>>>
>>> All feedback appreciated!
>> Wow.  Very nice.  I can already think of several other uses for this.
> 
> Glad you like it :) OOI, what other uses are you thinking of?
> 
>> A few suggestions:
>>
>>       * Please sign off your patches.  See
>>         http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;hb=HEAD;f=Documentation/SubmittingPatches , section "Sign your work", for details on the Developer's Certificate of Origin and the Signed-off-by convention.  I really need to include some documentation in the Sparse source tree, though.
> 
> Ah, I did wonder what the 'signed-off-by' signified.
> 
>>       * Rather than specifying start="line:col" end="line:col", how
>>         about splitting those up into start-line, start-col, end-line,
>>         and end-col?  That would avoid the need to do string parsing
>>         after reading the XML.
> 
> Yes. I originally had a more human-readable form, and this is a hangover
> from that approach.
> 
>>       * Positions have file information associated with them.  A symbol
>>         might potentially start in one file and end in another, if
>>         people play crazy games with #include.  start-file and end-file?
> 
> Yes, optional end-file would be sensible. Hopefully it wouldn't occur
> very often ;)
> 
>>       * Typo in examine_namespace: "Unregonized namespace".
> yes.
> 
>>       * get_type_name seems generally useful, and several other parts of
>>         Sparse (such as in evaluate.c and show-parse.c) could become
>>         simpler by using it.  How about putting it in symbol.c and
>>         exposing it via symbol.h?  Can you do that in a separate patch,
>>         please?
> 
> Sure.
>>       * Also, should get_type_name perhaps look up the string in an
>>         array rather than using switch?  (I don't know which makes more
>>         sense.)
> 
> Yeah, an array lookup would be better.
> 
>>       * I don't know how much work this would require, but it doesn't
>>         seem like c2xml gets much value out of using libxml, so would it
>>         make things very painful to just print XML directly?  It would
>>         certainly make things like BAD_CAST and having to snprintf to
>>         local buffers go away.  If you count on libxml for some form of
>>         escaping or similar, please ignore this; however, as far as I
>>         can tell, all of the strings that c2xml works with (such as
>>         identifiers) can't have unusual characters in them.
> 
> Well, I'm using the tree builder. It would be non-trivial to rewrite
> without it - see in examine_symbol where I add new nodes to the root
> node and recurse from there.
> 
>>       * Please don't include vim modelines in source files.  (Same goes
>>         for emacs and similar.)
> 
> Sure
> 
>>       * Please explicitly limit the possible values of the type
>>         attribute to those that Sparse produces, rather than allowing
>>         any arbitrary CDATA.  The same goes for a few other 
> 
> Ah, yes, good idea.
> 
> <snip>
> 
>>       * In examine_modifiers, please use C99-style designated assignment
>>         for the modifiers array, for clarity and robustness.
> 
> Hmm, not sure how best to do this. Redefine MOD_* in terms of shifts of
> some linearly assigned constants?
> 
>>       * I suspect several of the modifiers in examine_modifiers don't
>>         need to generate output; I think you want to ignore everything
>>         in MOD_IGNORE.
> 
> Do we really want to not emit any from MOD_STORAGE? I guess if we have
> scoping info at a later date, we can certainly drop MOD_TOPLEVEL, but
> that seems useful ATM. MOD_ADDRESSABLE seems useful. MOD_ASSIGNED,
> MOD_USERTYPE, MOD_FORCE, MOD_ACCESSED and MOD_EXPLICTLY_SIGNED don't
> seem very useful though.
> 
> I think MOD_TYPEDEF would be useful,but I never actually see it. Do you
> know what's going on here?
> 
> 
> Attached you should find the updated patchset with all the changes
> discussed apart from the modifiers stuff discussed above.
> 
> <snip>
> 
>> Note that you don't need to address all of these before resending.  In
>> particular, I'd love to merge the first patch, and I just need a signoff
>> for it.
>>
>> Thanks again for this work; it looks great, and highly useful.
> 
> Thanks to you too!
> 
> Rob Taylor
> 
> 
> 
> ------------------------------------------------------------------------
> 
> From d794c936d62279f37e2e894af3d2297286384dce Mon Sep 17 00:00:00 2001
> From: Rob Taylor <rob.taylor@codethink.co.uk>
> Date: Fri, 29 Jun 2007 17:25:51 +0100
> Subject: [PATCH 1/4] add end position to symbols
> 
> This adds a field in the symbol struct for the position of the end of the
> symbol and code to parse.c to fill this in for the various symbol types when
> parsing.
> 
> Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
> ---
>  parse.c  |   21 ++++++++++++++++++++-
>  symbol.c |    1 +
>  symbol.h |    1 +
>  3 files changed, 22 insertions(+), 1 deletions(-)
> 
> diff --git a/parse.c b/parse.c
> index cb9f87a..ae14642 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -505,6 +505,7 @@ static struct token *struct_union_enum_specifier(enum type type,
>  
>  			// Mark the structure as needing re-examination
>  			sym->examined = 0;
> +			sym->endpos = token->pos;
>  		}
>  		return token;
>  	}
> @@ -519,7 +520,10 @@ static struct token *struct_union_enum_specifier(enum type type,
>  	sym = alloc_symbol(token->pos, type);
>  	token = parse(token->next, sym);
>  	ctype->base_type = sym;
> -	return expect(token, '}', "at end of specifier");
> +	token =  expect(token, '}', "at end of specifier");
> +	sym->endpos = token->pos;
> +
> +	return token;
>  }
>  
>  static struct token *parse_struct_declaration(struct token *token, struct symbol *sym)
> @@ -712,6 +716,9 @@ static struct token *parse_enum_declaration(struct token *token, struct symbol *
>  			lower_boundary(&lower, &v);
>  		}
>  		token = next;
> +
> +		sym->endpos = token->pos;
> +
>  		if (!match_op(token, ','))
>  			break;
>  		token = token->next;
> @@ -775,6 +782,7 @@ static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
>  		token = parse_expression(token->next, &typeof_sym->initializer);
>  
>  		ctype->modifiers = 0;
> +		typeof_sym->endpos = token->pos;
>  		ctype->base_type = typeof_sym;
>  	}		
>  	return expect(token, ')', "after typeof");
> @@ -1193,12 +1201,14 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
>  			sym = alloc_indirect_symbol(token->pos, ctype, SYM_FN);
>  			token = parameter_type_list(next, sym, p);
>  			token = expect(token, ')', "in function declarator");
> +			sym->endpos = token->pos;
>  			continue;
>  		}
>  		if (token->special == '[') {
>  			struct symbol *array = alloc_indirect_symbol(token->pos, ctype, SYM_ARRAY);
>  			token = abstract_array_declarator(token->next, array);
>  			token = expect(token, ']', "in abstract_array_declarator");
> +			array->endpos = token->pos;
>  			ctype = &array->ctype;
>  			continue;
>  		}
> @@ -1232,6 +1242,7 @@ static struct token *pointer(struct token *token, struct ctype *ctype)
>  
>  		token = declaration_specifiers(token->next, ctype, 1);
>  		modifiers = ctype->modifiers;
> +		ctype->base_type->endpos = token->pos;
>  	}
>  	return token;
>  }
> @@ -1286,6 +1297,7 @@ static struct token *handle_bitfield(struct token *token, struct symbol *decl)
>  		}
>  	}
>  	bitfield->bit_size = width;
> +	bitfield->endpos = token->pos;
>  	return token;
>  }
>  
> @@ -1306,6 +1318,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
>  		}
>  		apply_modifiers(token->pos, &decl->ctype);
>  		add_symbol(list, decl);
> +		decl->endpos = token->pos;
>  		if (!match_op(token, ','))
>  			break;
>  		token = token->next;
> @@ -1340,6 +1353,7 @@ static struct token *parameter_declaration(struct token *token, struct symbol **
>  	token = declarator(token, sym, &ident);
>  	sym->ident = ident;
>  	apply_modifiers(token->pos, &sym->ctype);
> +	sym->endpos = token->pos;
>  	return token;
>  }
>  
> @@ -1350,6 +1364,7 @@ struct token *typename(struct token *token, struct symbol **p)
>  	token = declaration_specifiers(token, &sym->ctype, 0);
>  	token = declarator(token, sym, NULL);
>  	apply_modifiers(token->pos, &sym->ctype);
> +	sym->endpos = token->pos;
>  	return token;
>  }
>  
> @@ -1818,6 +1833,7 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn,
>  			warning(token->pos, "void parameter");
>  		}
>  		add_symbol(list, sym);
> +		sym->endpos = token->pos;
>  		if (!match_op(token, ','))
>  			break;
>  		token = token->next;
> @@ -2104,6 +2120,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>  	token = declarator(token, decl, &ident);
>  	apply_modifiers(token->pos, &decl->ctype);
>  
> +	decl->endpos = token->pos;
> +
>  	/* Just a type declaration? */
>  	if (!ident)
>  		return expect(token, ';', "end of type declaration");
> @@ -2164,6 +2182,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>  		token = declaration_specifiers(token, &decl->ctype, 1);
>  		token = declarator(token, decl, &ident);
>  		apply_modifiers(token->pos, &decl->ctype);
> +		decl->endpos = token->pos;
>  		if (!ident) {
>  			sparse_error(token->pos, "expected identifier name in type definition");
>  			return token;
> diff --git a/symbol.c b/symbol.c
> index 329fed9..7585978 100644
> --- a/symbol.c
> +++ b/symbol.c
> @@ -62,6 +62,7 @@ struct symbol *alloc_symbol(struct position pos, int type)
>  	struct symbol *sym = __alloc_symbol(0);
>  	sym->type = type;
>  	sym->pos = pos;
> +	sym->endpos.type = 0;
>  	return sym;
>  }
>  
> diff --git a/symbol.h b/symbol.h
> index 2bde84d..be5e6b1 100644
> --- a/symbol.h
> +++ b/symbol.h
> @@ -111,6 +111,7 @@ struct symbol {
>  	enum namespace namespace:9;
>  	unsigned char used:1, attr:2, enum_member:1;
>  	struct position pos;		/* Where this symbol was declared */
> +	struct position endpos;		/* Where this symbol ends*/
>  	struct ident *ident;		/* What identifier this symbol is associated with */
>  	struct symbol *next_id;		/* Next semantic symbol that shares this identifier */
>  	struct symbol **id_list;	/* Back pointer to symbol list head */
> 
> 
> ------------------------------------------------------------------------
> 
> From c0cf0ff431197fe02839ed05cd2e7dd2b6d5cdae Mon Sep 17 00:00:00 2001
> From: Rob Taylor <rob.taylor@codethink.co.uk>
> Date: Fri, 29 Jun 2007 17:33:29 +0100
> Subject: [PATCH 2/4] add sparse_keep_tokens api to lib.h
> 
> Adds sparse_keep_tokens, which is the same as __sparse, but doesn't free the
> tokens after parsing. Useful fow ehen you want to inspect macro symbols after
> parsing.
> 
> Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
> ---
>  lib.c |   13 ++++++++++++-
>  lib.h |    1 +
>  2 files changed, 13 insertions(+), 1 deletions(-)
> 
> diff --git a/lib.c b/lib.c
> index 7fea474..aba547a 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -741,7 +741,7 @@ struct symbol_list *sparse_initialize(int argc, char **argv, struct string_list
>  	return list;
>  }
>  
> -struct symbol_list * __sparse(char *filename)
> +struct symbol_list * sparse_keep_tokens(char *filename)
>  {
>  	struct symbol_list *res;
>  
> @@ -751,6 +751,17 @@ struct symbol_list * __sparse(char *filename)
>  	new_file_scope();
>  	res = sparse_file(filename);
>  
> +	/* And return it */
> +	return res;
> +}
> +
> +
> +struct symbol_list * __sparse(char *filename)
> +{
> +	struct symbol_list *res;
> +
> +	res = sparse_keep_tokens(filename);
> +
>  	/* Drop the tokens for this file after parsing */
>  	clear_token_alloc();
>  
> diff --git a/lib.h b/lib.h
> index bc2a8c2..aacafea 100644
> --- a/lib.h
> +++ b/lib.h
> @@ -113,6 +113,7 @@ extern void declare_builtin_functions(void);
>  extern void create_builtin_stream(void);
>  extern struct symbol_list *sparse_initialize(int argc, char **argv, struct string_list **files);
>  extern struct symbol_list *__sparse(char *filename);
> +extern struct symbol_list *sparse_keep_tokens(char *filename);
>  extern struct symbol_list *sparse(char *filename);
>  
>  static inline int symbol_list_size(struct symbol_list *list)
> 
> 
> ------------------------------------------------------------------------
> 
> From d809173f376d5cb6281832aec57c4f31c0447020 Mon Sep 17 00:00:00 2001
> From: Rob Taylor <rob.taylor@codethink.co.uk>
> Date: Mon, 2 Jul 2007 13:26:42 +0100
> Subject: [PATCH 3/4] new get_type_name function
> 
> Adds function get_type_name to symbol.h to get a string representation of a given type.
> 
> Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
> ---
>  symbol.c |   29 +++++++++++++++++++++++++++++
>  symbol.h |    1 +
>  2 files changed, 30 insertions(+), 0 deletions(-)
> 
> diff --git a/symbol.c b/symbol.c
> index 7585978..516c50f 100644
> --- a/symbol.c
> +++ b/symbol.c
> @@ -444,6 +444,35 @@ struct symbol *examine_symbol_type(struct symbol * sym)
>  	return sym;
>  }
>  
> +const char* get_type_name(enum type type)
> +{
> +	const char *type_lookup[] = {
> +	[SYM_UNINITIALIZED] = "uninitialized",
> +	[SYM_PREPROCESSOR] = "preprocessor",
> +	[SYM_BASETYPE] = "basetype",
> +	[SYM_NODE] = "node",
> +	[SYM_PTR] = "pointer",
> +	[SYM_FN] = "function",
> +	[SYM_ARRAY] = "array",
> +	[SYM_STRUCT] = "struct",
> +	[SYM_UNION] = "union",
> +	[SYM_ENUM] = "enum",
> +	[SYM_TYPEDEF] = "typedef",
> +	[SYM_TYPEOF] = "typeof",
> +	[SYM_MEMBER] = "member",
> +	[SYM_BITFIELD] = "bitfield",
> +	[SYM_LABEL] = "label",
> +	[SYM_RESTRICT] = "restrict",
> +	[SYM_FOULED] = "fouled",
> +	[SYM_KEYWORD] = "keyword",
> +	[SYM_BAD] = "bad"};
> +
> +	if (type <= SYM_BAD)
> +		return type_lookup[type];
> +	else
> +		return NULL;
> +}
> +
>  static struct symbol_list *restr, *fouled;
>  
>  void create_fouled(struct symbol *type)
> diff --git a/symbol.h b/symbol.h
> index be5e6b1..c651a84 100644
> --- a/symbol.h
> +++ b/symbol.h
> @@ -267,6 +267,7 @@ extern void examine_simple_symbol_type(struct symbol *);
>  extern const char *show_typename(struct symbol *sym);
>  extern const char *builtin_typename(struct symbol *sym);
>  extern const char *builtin_ctypename(struct ctype *ctype);
> +extern const char* get_type_name(enum type type);
>  
>  extern void debug_symbol(struct symbol *);
>  extern void merge_type(struct symbol *sym, struct symbol *base_type);
> 
> 
> ------------------------------------------------------------------------
> 
> From 51785f1c32ab857432f4fb4a5c99bda4d80bc51f Mon Sep 17 00:00:00 2001
> From: Rob Taylor <rob.taylor@codethink.co.uk>
> Date: Mon, 2 Jul 2007 13:27:46 +0100
> Subject: [PATCH 4/4] add c2xml program
> 
> Adds new c2xml program which dumps out the parse tree for a given file as well formed xml. A DTD for the format is included as parse.dtd.
> 
> Signed-off-by: Rob Taylor <rob.taylor@codethink.co.uk>
> ---
>  Makefile  |   15 +++
>  c2xml.c   |  324 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>  parse.dtd |   48 +++++++++
>  3 files changed, 387 insertions(+), 0 deletions(-)
>  create mode 100644 c2xml.c
>  create mode 100644 parse.dtd
> 
> diff --git a/Makefile b/Makefile
> index 039fe38..67da31f 100644
> --- a/Makefile
> +++ b/Makefile
> @@ -7,6 +7,8 @@ CFLAGS=-O -g -Wall -Wwrite-strings -fpic
>  LDFLAGS=-g
>  AR=ar
>  
> +HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 && echo 'yes')
> +
>  #
>  # For debugging, uncomment the next one
>  #
> @@ -21,8 +23,15 @@ PKGCONFIGDIR=$(LIBDIR)/pkgconfig
>  
>  PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize example \
>  	 test-unssa test-dissect ctags
> +
> +
>  INST_PROGRAMS=sparse cgcc
>  
> +ifeq ($(HAVE_LIBXML),yes)
> +PROGRAMS+=c2xml
> +INST_PROGRAMS+=c2xml
> +endif
> +
>  LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
>  	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
>  	  storage.h ptrlist.h dissect.h
> @@ -107,6 +116,12 @@ test-dissect: test-dissect.o $(LIBS)
>  ctags: ctags.o $(LIBS)
>  	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
>  
> +ifeq ($(HAVE_LIBXML),yes)
> +c2xml: c2xml.c $(LIBS) $(LIB_H)
> +	$(CC) $(LDFLAGS) `pkg-config --cflags --libs libxml-2.0` -o $@ $< $(LIBS)
> +
> +endif
> +
>  $(LIB_FILE): $(LIB_OBJS)
>  	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)
>  
> diff --git a/c2xml.c b/c2xml.c
> new file mode 100644
> index 0000000..25d1c40
> --- /dev/null
> +++ b/c2xml.c
> @@ -0,0 +1,324 @@
> +/*
> + * Sparse c2xml
> + *
> + * Dumps the parse tree as an xml document
> + *
> + * Copyright (C) 2007 Rob Taylor
> + *
> + * Licensed under the Open Software License version 1.1
> + */
> +#include <stdlib.h>
> +#include <stdio.h>
> +#include <string.h>
> +#include <unistd.h>
> +#include <fcntl.h>
> +#include <assert.h>
> +#include <libxml/parser.h>
> +#include <libxml/tree.h>
> +
> +#include "parse.h"
> +#include "scope.h"
> +#include "symbol.h"
> +
> +xmlDocPtr doc = NULL;       /* document pointer */
> +xmlNodePtr root_node = NULL;/* root node pointer */
> +xmlDtdPtr dtd = NULL;       /* DTD pointer */
> +xmlNsPtr ns = NULL;         /* namespace pointer */
> +int idcount = 0;
> +
> +static struct symbol_list *taglist = NULL;
> +
> +static void examine_symbol(struct symbol *sym, xmlNodePtr node);
> +
> +static xmlAttrPtr newNumProp(xmlNodePtr node, const xmlChar * name, int value)
> +{
> +	char buf[256];
> +	snprintf(buf, 256, "%d", value);
> +	return xmlNewProp(node, name, buf);
> +}
> +
> +static xmlAttrPtr newIdProp(xmlNodePtr node, const xmlChar * name, unsigned int id)
> +{
> +	char buf[256];
> +	snprintf(buf, 256, "_%d", id);
> +	return xmlNewProp(node, name, buf);
> +}
> +
> +static xmlNodePtr new_sym_node(struct symbol *sym, const char *name, xmlNodePtr parent)
> +{
> +	xmlNodePtr node;
> +	const char *ident = show_ident(sym->ident);
> +
> +	assert(name != NULL);
> +	assert(sym != NULL);
> +	assert(parent != NULL);
> +
> +	node = xmlNewChild(parent, NULL, "symbol", NULL);
> +
> +	xmlNewProp(node, "type",  name);
> +
> +	newIdProp(node, "id", idcount);
> +
> +	if (sym->ident && ident)
> +		xmlNewProp(node, "ident", ident);
> +	xmlNewProp(node, "file", stream_name(sym->pos.stream));
> +
> +	newNumProp(node, "start-line", sym->pos.line);
> +	newNumProp(node, "start-col", sym->pos.pos);
> +
> +	if (sym->endpos.type) {
> +		newNumProp(node, "end-line", sym->endpos.line);
> +		newNumProp(node, "end-col", sym->endpos.pos);
> +		if (sym->pos.stream != sym->endpos.stream)
> +			xmlNewProp(node, "end-file", stream_name(sym->endpos.stream));
> +        }
> +	sym->aux = node;
> +
> +	idcount++;
> +
> +	return node;
> +}
> +
> +static inline void examine_members(struct symbol_list *list, xmlNodePtr node)
> +{
> +	struct symbol *sym;
> +	xmlNodePtr child;
> +	char buf[256];
> +
> +	FOR_EACH_PTR(list, sym) {
> +		examine_symbol(sym, node);
> +	} END_FOR_EACH_PTR(sym);
> +}
> +
> +static void examine_modifiers(struct symbol *sym, xmlNodePtr node)
> +{
> +	const char *modifiers[] = {
> +			"auto",
> +			"register",
> +			"static",
> +			"extern",
> +			"const",
> +			"volatile",
> +			"signed",
> +			"unsigned",
> +			"char",
> +			"short",
> +			"long",
> +			"long-long",
> +			"typedef",
> +			NULL,
> +			NULL,
> +			NULL,
> +			NULL,
> +			NULL,
> +			"inline",
> +			"addressable",
> +			"nocast",
> +			"noderef",
> +			"accessed",
> +			"toplevel",
> +			"label",
> +			"assigned",
> +			"type-type",
> +			"safe",
> +			"user-type",
> +			"force",
> +			"explicitly-signed",
> +			"bitwise"};
> +
> +	int i;
> +
> +	if (sym->namespace != NS_SYMBOL)
> +		return;
> +
> +	/*iterate over the 32 bit bitfield*/
> +	for (i=0; i < 32; i++) {
> +		if ((sym->ctype.modifiers & 1<<i) && modifiers[i])
> +			xmlNewProp(node, modifiers[i], "1");
> +	}
> +}
> +
> +static void
> +examine_layout(struct symbol *sym, xmlNodePtr node)
> +{
> +	char buf[256];
> +
> +	examine_symbol_type(sym);
> +
> +	newNumProp(node, "bit-size", sym->bit_size);
> +	newNumProp(node, "alignment", sym->ctype.alignment);
> +	newNumProp(node, "offset", sym->offset);
> +	if (is_bitfield_type(sym)) {
> +		newNumProp(node, "bit-offset", sym->bit_offset);
> +	}
> +}
> +
> +static void examine_symbol(struct symbol *sym, xmlNodePtr node)
> +{
> +	xmlNodePtr child = NULL;
> +	const char *base;
> +	int array_size;
> +	char buf[256];
> +
> +	if (!sym)
> +		return;
> +	if (sym->aux)		/*already visited */
> +		return;
> +
> +	if (sym->ident && sym->ident->reserved)
> +		return;
> +
> +	child = new_sym_node(sym, get_type_name(sym->type), node);
> +	examine_modifiers(sym, child);
> +	examine_layout(sym, child);
> +
> +	if (sym->ctype.base_type) {
> +		if ((base = builtin_typename(sym->ctype.base_type)) == NULL) {
> +			if (!sym->ctype.base_type->aux) {
> +				examine_symbol(sym->ctype.base_type, root_node);
> +			}
> +			xmlNewProp(child, "base-type", 
> +				xmlGetProp((xmlNodePtr)sym->ctype.base_type->aux, "id"));
> +		} else {
> +			xmlNewProp(child, "base-type-builtin", base);
> +		}
> +	}
> +	if (sym->array_size) {
> +		/* TODO: modify get_expression_value to give error return */
> +		array_size = get_expression_value(sym->array_size);
> +		newNumProp(child, "array-size", array_size);
> +	}
> +
> +
> +	switch (sym->type) {
> +	case SYM_STRUCT:
> +	case SYM_UNION:
> +		examine_members(sym->symbol_list, child);
> +		break;
> +	case SYM_FN:
> +		examine_members(sym->arguments, child);
> +		break;
> +	case SYM_UNINITIALIZED:
> +		xmlNewProp(child, "base-type-builtin", builtin_typename(sym));
> +		break;
> +	}
> +	return;
> +}
> +
> +static struct position *get_expansion_end (struct token *token)
> +{
> +	struct token *p1, *p2;
> +
> +	for (p1=NULL, p2=NULL;
> +	     !eof_token(token);
> +	     p2 = p1, p1 = token, token = token->next);
> +
> +	if (p2)
> +		return &(p2->pos);
> +	else
> +		return NULL;
> +}
> +
> +static void examine_macro(struct symbol *sym, xmlNodePtr node)
> +{
> +	xmlNodePtr child;
> +	struct position *pos;
> +	char buf[256];
> +
> +	/* this should probably go in the main codebase*/
> +	pos = get_expansion_end(sym->expansion);
> +	if (pos)
> +		sym->endpos = *pos;
> +	else
> +		sym->endpos = sym->pos;
> +
> +	child = new_sym_node(sym, "macro", node);
> +}
> +
> +static void examine_namespace(struct symbol *sym)
> +{
> +	xmlChar *namespace_type = NULL;
> +
> +	if (sym->ident && sym->ident->reserved)
> +		return;
> +
> +	switch(sym->namespace) {
> +	case NS_MACRO:
> +		examine_macro(sym, root_node);
> +		break;
> +	case NS_TYPEDEF:
> +	case NS_STRUCT:
> +	case NS_SYMBOL:
> +		examine_symbol(sym, root_node);
> +		break;
> +	case NS_NONE:
> +	case NS_LABEL:
> +	case NS_ITERATOR:
> +	case NS_UNDEF:
> +	case NS_PREPROCESSOR:
> +	case NS_KEYWORD:
> +		break;
> +	default:
> +		die("Unrecognised namespace type %d",sym->namespace);
> +	}
> +
> +}
> +
> +static int get_stream_id (const char *name)
> +{
> +	int i;
> +	for (i=0; i<input_stream_nr; i++) {
> +		if (strcmp(name, stream_name(i))==0)
> +			return i;
> +	}
> +	return -1;
> +}
> +
> +static inline void examine_symbol_list(const char *file, struct symbol_list *list)
> +{
> +	struct symbol *sym;
> +	int stream_id = get_stream_id (file);
> +
> +	if (!list)
> +		return;
> +	FOR_EACH_PTR(list, sym) {
> +		if (sym->pos.stream == stream_id)
> +			examine_namespace(sym);
> +	} END_FOR_EACH_PTR(sym);
> +}
> +
> +int main(int argc, char **argv)
> +{
> +	struct string_list *filelist = NULL;
> +	struct symbol_list *symlist = NULL;
> +	char *file;
> +
> +	doc = xmlNewDoc("1.0");
> +	root_node = xmlNewNode(NULL, "parse");
> +	xmlDocSetRootElement(doc, root_node);
> +
> +/* - A DTD is probably unnecessary for something like this
> + 
> +	dtd = xmlCreateIntSubset(doc, "parse", "http://www.kernel.org/pub/software/devel/sparse/parse.dtd" NULL, "parse.dtd");
> +
> +	ns = xmlNewNs (root_node, "http://www.kernel.org/pub/software/devel/sparse/parse.dtd", NULL);
> +
> +	xmlSetNs(root_node, ns);
> +*/
> +	symlist = sparse_initialize(argc, argv, &filelist);
> +
> +	FOR_EACH_PTR_NOTAG(filelist, file) {
> +		examine_symbol_list(file, symlist);
> +		sparse_keep_tokens(file);
> +		examine_symbol_list(file, file_scope->symbols);
> +		examine_symbol_list(file, global_scope->symbols);
> +	} END_FOR_EACH_PTR_NOTAG(file);
> +
> +
> +	xmlSaveFormatFileEnc("-", doc, "UTF-8", 1);
> +	xmlFreeDoc(doc);
> +	xmlCleanupParser();
> +
> +	return 0;
> +}
> +
> diff --git a/parse.dtd b/parse.dtd
> new file mode 100644
> index 0000000..0cbd1b4
> --- /dev/null
> +++ b/parse.dtd
> @@ -0,0 +1,48 @@
> +<!ELEMENT parse (symbol+) >
> +
> +<!ELEMENT symbol (symbol*) >
> +
> +<!ATTLIST symbol type (uninitialized|preprocessor|basetype|node|pointer|function|array|struct|union|enum|typedef|typeof|member|bitfield|label|restrict|fouled|keyword|bad) #REQUIRED
> +                 id ID #REQUIRED
> +		 file CDATA #REQUIRED
> +		 start CDATA #REQUIRED
> +		 end CDATA #IMPLIED
> +
> +		 ident CDATA #IMPLIED
> +		 base-type IDREF #IMPLIED
> +		 base-type-builtin (char|signed char|unsigned char|short|signed short|unsigned short|int|signed int|unsigned int|signed long|long|unsigned long|long long|signed long long|unsigned long long|void|bool|string|float|double|long double|incomplete type|abstract int|abstract fp|label type|bad type) #IMPLIED
> +
> +		 array-size CDATA #IMPLIED
> +
> +		 bit-size CDATA #IMPLIED
> +		 alignment CDATA #IMPLIED
> +		 offset CDATA #IMPLIED
> +		 bit-offset CDATA #IMPLIED
> +
> +		 auto (0|1) #IMPLIED
> +		 register (0|1) #IMPLIED
> +		 static (0|1) #IMPLIED
> +		 extern (0|1) #IMPLIED
> +		 const (0|1) #IMPLIED
> +		 volatile (0|1) #IMPLIED
> +		 signed (0|1) #IMPLIED
> +		 unsigned (0|1) #IMPLIED
> +		 char (0|1) #IMPLIED
> +		 short (0|1) #IMPLIED
> +		 long (0|1) #IMPLIED
> +		 long-long (0|1) #IMPLIED
> +		 typedef (0|1) #IMPLIED
> +		 inline (0|1) #IMPLIED
> +		 addressable (0|1) #IMPLIED
> +		 nocast (0|1) #IMPLIED
> +		 noderef (0|1) #IMPLIED
> +		 accessed (0|1) #IMPLIED
> +		 toplevel (0|1) #IMPLIED
> +		 label (0|1) #IMPLIED
> +		 assigned (0|1) #IMPLIED
> +		 type-type (0|1) #IMPLIED
> +		 safe (0|1) #IMPLIED
> +		 usertype (0|1) #IMPLIED
> +		 force (0|1) #IMPLIED
> +		 explicitly-signed (0|1) #IMPLIED
> +		 bitwise (0|1) #IMPLIED >

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] c2xml
Date: Fri, 13 Jul 2007 17:55:48 +0000
Message-ID: <1184349348.2616.34.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-13 at 16:50 +0100, Rob Taylor wrote:
> Any followups on this?

I actually committed the first three patches this morning, before you
sent this.  I would like to commit the fourth patch this evening.  I
want to think a bit about how to address one issue: I'd really love to
avoid constructs specific to GNU make, such as ifeq and $(shell).  I
managed to find a way to do that for the patch adding clean kernel-style
build output, by using the text substitution feature of make variable
expansion.  However, I haven't yet figured out a way to avoid $(shell)
with this patch.  The c2xml target can just always exist, so no
conditionals needed there.  However, without $(shell), I don't see any
way to handle adding c2xml to PROGRAMS and INST_PROGRAMS without
$(shell); backquotes will only work in the commands of a target, not the
prerequisites.  (Obviously, just leaving c2xml out of the all and
install targets would solve the problem, but that seems quite
suboptimal.)  I want to think about this problem for a bit, and if I
don't come up with anything and don't get any good suggestions, I may
just go ahead and require GNU make.

Also, you didn't update the dtd for the changes to the position
handling; it doesn't have end-file, and it still has start and end
rather than {start,end}-{line,col}.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] c2xml
Date: Sat, 14 Jul 2007 06:24:38 +0000
Message-ID: <46986C26.9040804 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig6A9A10F414CFE08261A09E44
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Josh Triplett wrote:
> On Fri, 2007-07-13 at 16:50 +0100, Rob Taylor wrote:
>> Any followups on this?
>=20
> I actually committed the first three patches this morning, before you
> sent this.  I would like to commit the fourth patch this evening.  I
> want to think a bit about how to address one issue: I'd really love to
> avoid constructs specific to GNU make, such as ifeq and $(shell).  I
> managed to find a way to do that for the patch adding clean kernel-styl=
e
> build output, by using the text substitution feature of make variable
> expansion.  However, I haven't yet figured out a way to avoid $(shell)
> with this patch.  The c2xml target can just always exist, so no
> conditionals needed there.  However, without $(shell), I don't see any
> way to handle adding c2xml to PROGRAMS and INST_PROGRAMS without
> $(shell); backquotes will only work in the commands of a target, not th=
e
> prerequisites.  (Obviously, just leaving c2xml out of the all and
> install targets would solve the problem, but that seems quite
> suboptimal.)  I want to think about this problem for a bit, and if I
> don't come up with anything and don't get any good suggestions, I may
> just go ahead and require GNU make.

OK, forget it.  Anyone who wants Sparse to work with non-GNU make gets to=
 rack
*their* brain thinking about how to do without useful GNU make features.
Patch applied...

> Also, you didn't update the dtd for the changes to the position
> handling; it doesn't have end-file, and it still has start and end
> rather than {start,end}-{line,col}.

=2E.. and I fixed this myself.

Thanks again for some most impressive work.

- Josh Triplett


--------------enig6A9A10F414CFE08261A09E44
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGmGw1GJuZRtD+evsRAoRPAKC6hRtewg992uo/RRt7iWpETU2cGwCggf7w
shdw/kpRJ2bVVRkjzTvXDS4=
=Pz4E
-----END PGP SIGNATURE-----

--------------enig6A9A10F414CFE08261A09E44--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rob Taylor <rob.taylor () codethink ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH] c2xml
Date: Sat, 14 Jul 2007 23:54:01 +0000
Message-ID: <46996219.8030602 () codethink ! co ! uk>
--------------------
Josh Triplett wrote:
> Josh Triplett wrote:
>> On Fri, 2007-07-13 at 16:50 +0100, Rob Taylor wrote:
>>> Any followups on this?
>> I actually committed the first three patches this morning, before you
>> sent this.  I would like to commit the fourth patch this evening.  I
>> want to think a bit about how to address one issue: I'd really love to
>> avoid constructs specific to GNU make, such as ifeq and $(shell).  I
>> managed to find a way to do that for the patch adding clean kernel-style
>> build output, by using the text substitution feature of make variable
>> expansion.  However, I haven't yet figured out a way to avoid $(shell)
>> with this patch.  The c2xml target can just always exist, so no
>> conditionals needed there.  However, without $(shell), I don't see any
>> way to handle adding c2xml to PROGRAMS and INST_PROGRAMS without
>> $(shell); backquotes will only work in the commands of a target, not the
>> prerequisites.  (Obviously, just leaving c2xml out of the all and
>> install targets would solve the problem, but that seems quite
>> suboptimal.)  I want to think about this problem for a bit, and if I
>> don't come up with anything and don't get any good suggestions, I may
>> just go ahead and require GNU make.
> 
> OK, forget it.  Anyone who wants Sparse to work with non-GNU make gets to rack
> *their* brain thinking about how to do without useful GNU make features.
> Patch applied...

Heh, I think that's a fair enough stance now-a-days :)

>> Also, you didn't update the dtd for the changes to the position
>> handling; it doesn't have end-file, and it still has start and end
>> rather than {start,end}-{line,col}.
> 
> ... and I fixed this myself.

Brilliant!

> Thanks again for some most impressive work.

Thanks for putting the time in on it yourself!

Now to go and write interesting things using c2xml :)

Thanks,
Rob

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] cracked ideas to track user types. ===

From: Rob Taylor <rob.taylor@codethink.co.uk>
To: Unknown
Subject: [PATCH] cracked ideas to track user types.
Date: Fri, 3 Aug 2007 01:37:58 +0100
Message-ID: 
--------------------
---
 c2xml.c |    6 ++++--
 parse.c |    7 +++++--
 2 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/c2xml.c b/c2xml.c
index 37f29cf..42f059e 100644
--- a/c2xml.c
+++ b/c2xml.c
@@ -166,8 +166,6 @@ static void examine_symbol(struct symbol *sym, xmlNodePtr node)
 		return;
 
 	child = new_sym_node(sym, get_type_name(sym->type), node);
-	examine_modifiers(sym, child);
-	examine_layout(sym, child);
 
 	if (sym->ctype.base_type) {
 		if ((base = builtin_typename(sym->ctype.base_type)) == NULL) {
@@ -199,6 +197,10 @@ static void examine_symbol(struct symbol *sym, xmlNodePtr node)
 		newProp(child, "base-type-builtin", builtin_typename(sym));
 		break;
 	}
+
+	examine_modifiers(sym, child);
+	examine_layout(sym, child);
+
 	return;
 }
 
diff --git a/parse.c b/parse.c
index f452042..1ac7586 100644
--- a/parse.c
+++ b/parse.c
@@ -1101,12 +1101,15 @@ static struct token *declaration_specifiers(struct token *next, struct ctype *ct
 				break;
 			if (ctype->base_type)
 				break;
-			/* User types only mix with qualifiers */
 			if (mod & MOD_USERTYPE) {
+				/* User types only mix with qualifiers */
 				if (ctype->modifiers & MOD_SPECIFIER)
 					break;
+				/* Point to the user type */
+				ctype->base_type = s;
 			}
-			ctype->base_type = type;
+			else
+				ctype->base_type = type;
 		}
 
 		check_modifiers(&token->pos, s, ctype->modifiers);
-- 
1.5.3.GIT


--------------010001070006030601080307--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] dissect: fix multidimensional array initializer ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] dissect: fix multidimensional array initializer
Date: Fri, 23 Feb 2007 05:27:39 +0000
Message-ID: <45DE7B4B.4080100 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig9F0ED00F7E23FB8A49F277C7
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Oleg Nesterov wrote:
> dissect can't parse initializers like
>=20
> 	struct T { int i; } a[2][3] =3D { [0][0] =3D {123} };
>=20
> , output is:
>=20
> 	   1:8   s def  T
> 	   1:21  g def  a                                struct T [3][2]
> 	   1:21  g -w-  a                                struct T [3][2]
> 	T.c:1:37: warning: bad expr->type: 25
>=20
> with this patch applied:
>=20
> 	   1:8   s def  T
> 	   1:21  g def  a                                struct T [3][2]
> 	   1:21  g -w-  a                                struct T [3][2]
> 	   1:43  s -w-  T.i                              int
>=20
> Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

Applied.

- Josh Triplett



--------------enig9F0ED00F7E23FB8A49F277C7
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3ntLGJuZRtD+evsRAqz0AJ0cg65lrPd2R8He7cCb+vWf3sWi/QCggc/d
2LiOaGSzi8iNdn3vx5HnxFA=
=+sje
-----END PGP SIGNATURE-----

--------------enig9F0ED00F7E23FB8A49F277C7--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] dissect: simplify lookup_member() ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH] dissect: simplify lookup_member()
Date: Thu, 14 Dec 2006 21:37:15 +0000
Message-ID: <20061214213715.GB422 () tv-sign ! ru>
--------------------
Change examine_sym_node() to recursively inspect the members of SYM_STRUCT.
This allows us to simplify lookup_member(): no need to do examine_sym_node(),
the member was already examined.

This is also good because now ->r_symdef(member) is called on declaration,
not when dissect detects the first usage of ->member.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- DS/dissect.c~	2006-04-20 23:49:03.000000000 +0400
+++ DS/dissect.c	2006-04-21 00:04:18.000000000 +0400
@@ -210,13 +210,16 @@ static void examine_sym_node(struct symb
 		case SYM_STRUCT: case SYM_UNION: //case SYM_ENUM:
 			if (base->evaluated)
 				return;
+			if (!base->symbol_list)
+				return;
+			base->evaluated = 1;
+
 			if (!base->ident && name)
 				base->ident = mk_name(root, name);
-			if (!base->ident || !base->symbol_list)
-				return;
-			if (reporter->r_symdef)
+			if (base->ident && reporter->r_symdef)
 				reporter->r_symdef(base);
-			base->evaluated = 1;
+			DO_LIST(base->symbol_list, mem,
+				examine_sym_node(mem, base->ident ?: root));
 		default:
 			return;
 		}
@@ -263,14 +266,8 @@ found:
 
 static struct symbol *lookup_member(struct symbol *type, struct ident *name, int *addr)
 {
-	struct symbol *node = __lookup_member(type, name, addr);
-
-	if (node != NULL)
-		examine_sym_node(node, type->ident);
-	else
-		node = no_member(name);
-
-	return node;
+	return __lookup_member(type, name, addr)
+		?: no_member(name);
 }
 
 static struct expression *peek_preop(struct expression *expr, int op)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] dissect: simplify lookup_member()
Date: Tue, 27 Feb 2007 18:40:38 +0000
Message-ID: <45E47B26.8010006 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig0A890C89307AFA9E50B8FCA9
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Oleg Nesterov wrote:
> Change examine_sym_node() to recursively inspect the members of SYM_STR=
UCT.
> This allows us to simplify lookup_member(): no need to do examine_sym_n=
ode(),
> the member was already examined.
>=20
> This is also good because now ->r_symdef(member) is called on declarati=
on,
> not when dissect detects the first usage of ->member.
>=20
> Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

Applied.

- Josh Triplett



--------------enig0A890C89307AFA9E50B8FCA9
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5HsmGJuZRtD+evsRAk5vAJ4zxjmchvhxnf+W5vkeFqp3LoHs6ACfXfXM
cT7movajs0v7QfTyXNMoHDs=
=tMEQ
-----END PGP SIGNATURE-----

--------------enig0A890C89307AFA9E50B8FCA9--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] expression.c: Adding va_end(). ===

From: ricknu-0 () student ! ltu ! se
To: linux-sparse
Subject: [PATCH] expression.c: Adding va_end().
Date: Thu, 19 Jul 2007 00:02:55 +0000
Message-ID: <1184803375.469eaa2f8bff0 () portal ! student ! luth ! se>
--------------------
Adding va_end().

Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
---
According to the manual, it needs a va_end() in the same function.

diff --git a/expression.c b/expression.c
index 77d665d..857ec08 100644
--- a/expression.c
+++ b/expression.c
@@ -30,15 +30,15 @@
 static int match_oplist(int op, ...)
 {
 	va_list args;
+	int nextop;
 
 	va_start(args, op);
-	for (;;) {
-		int nextop = va_arg(args, int);
-		if (!nextop)
-			return 0;
-		if (op == nextop)
-			return 1;
-	}
+	do {
+		nextop = va_arg(args, int);
+	} while (nextop != 0 && nextop != op);
+	va_end(args);
+
+	return nextop != 0;
 }
 
 static struct token *comma_expression(struct token *, struct expression **);

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] expression.c: Adding va_end().
Date: Wed, 25 Jul 2007 04:48:29 +0000
Message-ID: <46A6D61D.70503 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig25851DC81387F38BF684729A
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

ricknu-0@student.ltu.se wrote:
> Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
> ---
> According to the manual, it needs a va_end() in the same function.

It does indeed; good catch.  Applied.

- Josh Triplett



--------------enig25851DC81387F38BF684729A
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGptYdGJuZRtD+evsRAmKVAJ9WYmVAKvwPn98j7tfv3G5pU/qQwQCdFhZy
ldnz5es8Yk/TvixNSbA50/Y=
=mhdB
-----END PGP SIGNATURE-----

--------------enig25851DC81387F38BF684729A--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix alignment for _Bool ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] fix alignment for _Bool
Date: Fri, 25 May 2007 03:57:44 +0000
Message-ID: <E1HrQvw-00018c-J7 () ZenIV ! linux ! org ! uk>
--------------------

_Bool ends up with 0 for alignment, which means that _Bool member in a struct
resets the next field offset to 0.  Should be (at least) 1...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 symbol.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/symbol.c b/symbol.c
index 45d40ee..20a04f3 100644
--- a/symbol.c
+++ b/symbol.c
@@ -832,7 +832,7 @@ void init_ctype(void)
 		struct symbol *sym = ctype->ptr;
 		unsigned long bit_size = ctype->bit_size ? *ctype->bit_size : -1;
 		unsigned long maxalign = ctype->maxalign ? *ctype->maxalign : 0;
-		unsigned long alignment = bit_size >> 3;
+		unsigned long alignment = (bit_size + 7) >> 3;
 
 		if (alignment > maxalign)
 			alignment = maxalign;
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix handling of address_space in casts and assignments ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] fix handling of address_space in casts and assignments
Date: Mon, 09 Jul 2007 22:13:06 +0000
Message-ID: <20070709221306.GP21668 () ftp ! linux ! org ! uk>
--------------------
Turn FORCE_MOD into storage class specifier (that's how it's
actually used and that makes for much simpler logics).

Introduce explicit EXPR_FORCE_CAST for forced casts; handle it
properly.

Kill the idiocy in get_as() (we end up picking the oddest things
for address space - e.g. if we have int __attribute__((address_space(1))) *p,
we'll get warnings about removal of address space when we do things like
(unsigned short)*p.  Fixed.  BTW, that had caught a bunch of very odd
bogosities in the kernel and eliminated several false positives in there.

As the result, get_as() is gone now and evaluate_cast() got simpler.

Kill the similar idiocy in handling pointer assignments; while we are at it,
fix the qualifiers check for assignments to/from void * (you can't assign
const int * to void * - qualifiers on the left side should be no less than
on the right one; for normal codepath we get that checked, but the special
case of void * skips these checks).

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 compile-i386.c |    1 +
 dissect.c      |    2 +-
 evaluate.c     |   91 +++++++++++++++++++++++---------------------------------
 expand.c       |    1 +
 expression.c   |   18 ++++++++---
 expression.h   |    3 +-
 inline.c       |    1 +
 linearize.c    |    1 +
 parse.c        |    7 +++-
 show-parse.c   |    1 +
 symbol.h       |    4 +-
 11 files changed, 65 insertions(+), 65 deletions(-)

diff --git a/compile-i386.c b/compile-i386.c
index 425a1bc..8526408 100644
--- a/compile-i386.c
+++ b/compile-i386.c
@@ -2351,6 +2351,7 @@ static struct storage *x86_expression(struct expression *expr)
 		warning(expr->pos, "invalid expression after evaluation");
 		return NULL;
 	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
 	case EXPR_IMPLIED_CAST:
 		return emit_cast_expr(expr);
 	case EXPR_VALUE:
diff --git a/dissect.c b/dissect.c
index 9dc3df9..61240d7 100644
--- a/dissect.c
+++ b/dissect.c
@@ -317,7 +317,7 @@ again:
 		do_expression(U_VOID, expr->left);
 		ret = do_expression(mode, expr->right);
 
-	break; case EXPR_CAST: //case EXPR_IMPLIED_CAST:
+	break; case EXPR_CAST: case EXPR_FORCE_CAST: //case EXPR_IMPLIED_CAST:
 		ret = base_type(expr->cast_type);
 		do_initializer(ret, expr->cast_expression);
 
diff --git a/evaluate.c b/evaluate.c
index b97a4d7..d505007 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1276,6 +1276,22 @@ static int compatible_assignment_types(struct expression *expr, struct symbol *t
 				bad_null(*rp);
 			goto Cast;
 		}
+		if (sclass & TYPE_PTR && t->ctype.as == s->ctype.as) {
+			/* we should be more lazy here */
+			int mod1 = t->ctype.modifiers;
+			int mod2 = s->ctype.modifiers;
+			s = get_base_type(s);
+			t = get_base_type(t);
+
+			/*
+			 * assignments to/from void * are OK, provided that
+			 * we do not remove qualifiers from pointed to [C]
+			 * or mix address spaces [sparse].
+			 */
+			if (!(mod2 & ~mod1 & (MOD_VOLATILE | MOD_CONST)))
+				if (s == &void_ctype || t == &void_ctype)
+					goto Cast;
+		}
 	}
 
 	/* It's OK if the target is more volatile or const than the source */
@@ -1283,22 +1299,6 @@ static int compatible_assignment_types(struct expression *expr, struct symbol *t
 	if (!typediff)
 		return 1;
 
-	/* Pointer destination? */
-	if (tclass & TYPE_PTR) {
-		int source_as;
-		int target_as;
-
-		/* "void *" matches anything as long as the address space is OK */
-		target_as = t->ctype.as | target->ctype.as;
-		source_as = s->ctype.as | source->ctype.as;
-		if (source_as == target_as && (s->type == SYM_PTR || s->type == SYM_ARRAY)) {
-			s = get_base_type(s);
-			t = get_base_type(t);
-			if (s == &void_ctype || t == &void_ctype)
-				goto Cast;
-		}
-	}
-
 	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
@@ -1330,6 +1330,7 @@ static void mark_assigned(struct expression *expr)
 		mark_assigned(expr->right);
 		return;
 	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
 		mark_assigned(expr->cast_expression);
 		return;
 	case EXPR_SLICE:
@@ -2496,46 +2497,13 @@ static void evaluate_initializer(struct symbol *ctype, struct expression **ep)
 		expression_error(*ep, "invalid initializer");
 }
 
-static int get_as(struct symbol *sym)
-{
-	int as;
-	unsigned long mod;
-
-	if (!sym)
-		return 0;
-	as = sym->ctype.as;
-	mod = sym->ctype.modifiers;
-	if (sym->type == SYM_NODE) {
-		sym = sym->ctype.base_type;
-		as |= sym->ctype.as;
-		mod |= sym->ctype.modifiers;
-	}
-
-	/*
-	 * At least for now, allow casting to a "unsigned long".
-	 * That's how we do things like pointer arithmetic and
-	 * store pointers to registers.
-	 */
-	if (sym == &ulong_ctype)
-		return -1;
-
-	if (sym && sym->type == SYM_PTR) {
-		sym = get_base_type(sym);
-		as |= sym->ctype.as;
-		mod |= sym->ctype.modifiers;
-	}
-	if (mod & MOD_FORCE)
-		return -1;
-	return as;
-}
-
 static struct symbol *evaluate_cast(struct expression *expr)
 {
 	struct expression *target = expr->cast_expression;
 	struct symbol *ctype;
 	struct symbol *t1, *t2;
 	int class1, class2;
-	int as1, as2;
+	int as1 = 0, as2 = 0;
 
 	if (!target)
 		return NULL;
@@ -2596,6 +2564,9 @@ static struct symbol *evaluate_cast(struct expression *expr)
 	if (class1 & TYPE_COMPOUND)
 		warning(expr->pos, "cast to non-scalar");
 
+	if (class1 == TYPE_PTR)
+		get_base_type(t1);
+
 	t2 = target->ctype;
 	if (!t2) {
 		expression_error(expr, "cast from unknown type");
@@ -2606,19 +2577,30 @@ static struct symbol *evaluate_cast(struct expression *expr)
 	if (class2 & TYPE_COMPOUND)
 		warning(expr->pos, "cast from non-scalar");
 
+	if (expr->type == EXPR_FORCE_CAST)
+		goto out;
+
 	/* allowed cast unfouls */
 	if (class2 & TYPE_FOULED)
 		t2 = t2->ctype.base_type;
 
-	if (!(ctype->ctype.modifiers & MOD_FORCE) && t1 != t2) {
+	if (t1 != t2) {
 		if (class1 & TYPE_RESTRICT)
 			warning(expr->pos, "cast to restricted type");
 		if (class2 & TYPE_RESTRICT)
 			warning(expr->pos, "cast from restricted type");
 	}
 
-	as1 = get_as(ctype);
-	as2 = get_as(target->ctype);
+	if (t1 == &ulong_ctype)
+		as1 = -1;
+	else if (class1 == TYPE_PTR)
+		as1 = t1->ctype.as;
+
+	if (t2 == &ulong_ctype)
+		as2 = -1;
+	else if (class2 == TYPE_PTR)
+		as2 = t2->ctype.as;
+
 	if (!as1 && as2 > 0)
 		warning(expr->pos, "cast removes address space of expression");
 	if (as1 > 0 && as2 > 0 && as1 != as2)
@@ -2628,7 +2610,7 @@ static struct symbol *evaluate_cast(struct expression *expr)
 		warning(expr->pos,
 			"cast adds address space to expression (<asn:%d>)", as1);
 
-	if (!(ctype->ctype.modifiers & MOD_PTRINHERIT) && class1 == TYPE_PTR &&
+	if (!(t1->ctype.modifiers & MOD_PTRINHERIT) && class1 == TYPE_PTR &&
 	    !as1 && (target->flags & Int_const_expr)) {
 		if (t1->ctype.base_type == &void_ctype) {
 			if (is_zero_constant(target)) {
@@ -2860,6 +2842,7 @@ struct symbol *evaluate_expression(struct expression *expr)
 			return NULL;
 		return evaluate_postop(expr);
 	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
 	case EXPR_IMPLIED_CAST:
 		return evaluate_cast(expr);
 	case EXPR_SIZEOF:
diff --git a/expand.c b/expand.c
index b2eeef8..06b8127 100644
--- a/expand.c
+++ b/expand.c
@@ -955,6 +955,7 @@ static int expand_expression(struct expression *expr)
 		return expand_postop(expr);
 
 	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
 	case EXPR_IMPLIED_CAST:
 		return expand_cast(expr);
 
diff --git a/expression.c b/expression.c
index 65f959e..77d665d 100644
--- a/expression.c
+++ b/expression.c
@@ -118,7 +118,7 @@ static struct token *parse_type(struct token *token, struct expression **tree)
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
 	(*tree)->flags = Int_const_expr; /* sic */
-	token = typename(token, &sym);
+	token = typename(token, &sym, 0);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -167,7 +167,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		return expect(token, '(', "after __builtin_offset");
 
 	token = token->next;
-	token = typename(token, &sym);
+	token = typename(token, &sym, 0);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -482,7 +482,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
 			expr->flags = Int_const_expr; /* sic */
-			token = typename(token->next, &expr->symbol);
+			token = typename(token->next, &expr->symbol, 0);
 			token = expect(token, ']', "in type expression");
 			break;
 		}
@@ -600,7 +600,7 @@ static struct token *type_info_expression(struct token *token,
 	token = token->next;
 	if (!match_op(token, '(') || !lookup_type(token->next))
 		return unary_expression(token, &expr->cast_expression);
-	token = typename(token->next, &expr->cast_type);
+	token = typename(token->next, &expr->cast_type, 0);
 
 	if (!match_op(token, ')')) {
 		static const char * error[] = {
@@ -715,15 +715,23 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			struct expression *cast = alloc_expression(next->pos, EXPR_CAST);
 			struct expression *v;
 			struct symbol *sym;
+			int is_force;
 
-			token = typename(next, &sym);
+			token = typename(next, &sym, MOD_FORCE);
 			cast->cast_type = sym;
+			is_force = sym->ctype.modifiers & MOD_FORCE;
+			sym->ctype.modifiers &= ~MOD_FORCE;
 			token = expect(token, ')', "at end of cast operator");
 			if (match_op(token, '{')) {
+				if (is_force)
+					warning(sym->pos,
+						"[force] in compound literal");
 				token = initializer(&cast->cast_expression, token);
 				return postfix_expression(token, tree, cast);
 			}
 			*tree = cast;
+			if (is_force)
+				cast->type = EXPR_FORCE_CAST;
 			token = cast_expression(token, &v);
 			if (!v)
 				return token;
diff --git a/expression.h b/expression.h
index 02eec02..fa5039a 100644
--- a/expression.h
+++ b/expression.h
@@ -27,6 +27,7 @@ enum expression_type {
 	EXPR_PREOP,
 	EXPR_POSTOP,
 	EXPR_CAST,
+	EXPR_FORCE_CAST,
 	EXPR_IMPLIED_CAST,
 	EXPR_SIZEOF,
 	EXPR_ALIGNOF,
@@ -190,7 +191,7 @@ static inline struct expression *alloc_const_expression(struct position pos, int
 }
 
 /* Type name parsing */
-struct token *typename(struct token *, struct symbol **);
+struct token *typename(struct token *, struct symbol **, int);
 
 static inline int lookup_type(struct token *token)
 {
diff --git a/inline.c b/inline.c
index 061261a..860c0ee 100644
--- a/inline.c
+++ b/inline.c
@@ -145,6 +145,7 @@ static struct expression * copy_expression(struct expression *expr)
 			*expr->cast_type = *sym;
 			break;
 		}
+	case EXPR_FORCE_CAST:
 	case EXPR_IMPLIED_CAST:
 	case EXPR_SIZEOF: 
 	case EXPR_PTRSIZEOF:
diff --git a/linearize.c b/linearize.c
index 3a07823..8a68f05 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1581,6 +1581,7 @@ pseudo_t linearize_expression(struct entrypoint *ep, struct expression *expr)
 		return linearize_postop(ep, expr);
 
 	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
 	case EXPR_IMPLIED_CAST:
 		return linearize_cast(ep, expr);
 	
diff --git a/parse.c b/parse.c
index ab3a096..68f1dac 100644
--- a/parse.c
+++ b/parse.c
@@ -768,7 +768,7 @@ static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
 		return token;
 	}
 	if (lookup_type(token->next)) {
-		token = typename(token->next, &sym);
+		token = typename(token->next, &sym, 0);
 		*ctype = sym->ctype;
 	} else {
 		struct symbol *typeof_sym = alloc_symbol(token->pos, SYM_TYPEOF);
@@ -1343,13 +1343,16 @@ static struct token *parameter_declaration(struct token *token, struct symbol **
 	return token;
 }
 
-struct token *typename(struct token *token, struct symbol **p)
+struct token *typename(struct token *token, struct symbol **p, int mod)
 {
 	struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
 	*p = sym;
 	token = declaration_specifiers(token, &sym->ctype, 0);
 	token = declarator(token, sym, NULL);
 	apply_modifiers(token->pos, &sym->ctype);
+	if (sym->ctype.modifiers & MOD_STORAGE & ~mod)
+		warning(sym->pos, "storage class in typename (%s)",
+			show_typename(sym));
 	return token;
 }
 
diff --git a/show-parse.c b/show-parse.c
index 07ee763..aae8b74 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -1053,6 +1053,7 @@ int show_expression(struct expression *expr)
 		warning(expr->pos, "invalid expression after evaluation");
 		return 0;
 	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
 	case EXPR_IMPLIED_CAST:
 		return show_cast_expr(expr);
 	case EXPR_VALUE:
diff --git a/symbol.h b/symbol.h
index a59feee..4d8d328 100644
--- a/symbol.h
+++ b/symbol.h
@@ -204,12 +204,12 @@ struct symbol {
 #define MOD_BITWISE	0x80000000
 
 #define MOD_NONLOCAL	(MOD_EXTERN | MOD_TOPLEVEL)
-#define MOD_STORAGE	(MOD_AUTO | MOD_REGISTER | MOD_STATIC | MOD_EXTERN | MOD_INLINE | MOD_TOPLEVEL)
+#define MOD_STORAGE	(MOD_AUTO | MOD_REGISTER | MOD_STATIC | MOD_EXTERN | MOD_INLINE | MOD_TOPLEVEL | MOD_FORCE)
 #define MOD_SIGNEDNESS	(MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED)
 #define MOD_SPECIFIER	(MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG | MOD_SIGNEDNESS)
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG)
 #define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
-	MOD_ASSIGNED | MOD_USERTYPE | MOD_FORCE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
+	MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
 #define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE)
 
 
-- 
1.5.0-rc2.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] fix handling of address_space in casts and assignments
Date: Thu, 12 Jul 2007 06:44:05 +0000
Message-ID: <4695CDB5.5080605 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig0D4A85A1BCF35F7EFF0B437E
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> Turn FORCE_MOD into storage class specifier (that's how it's
> actually used and that makes for much simpler logics).
>=20
> Introduce explicit EXPR_FORCE_CAST for forced casts; handle it
> properly.
>=20
> Kill the idiocy in get_as() (we end up picking the oddest things
> for address space - e.g. if we have int __attribute__((address_space(1)=
)) *p,
> we'll get warnings about removal of address space when we do things lik=
e
> (unsigned short)*p.  Fixed.  BTW, that had caught a bunch of very odd
> bogosities in the kernel and eliminated several false positives in ther=
e.
>=20
> As the result, get_as() is gone now and evaluate_cast() got simpler.
>=20
> Kill the similar idiocy in handling pointer assignments; while we are a=
t it,
> fix the qualifiers check for assignments to/from void * (you can't assi=
gn
> const int * to void * - qualifiers on the left side should be no less t=
han
> on the right one; for normal codepath we get that checked, but the spec=
ial
> case of void * skips these checks).

Applied (yesterday); thanks!

- Josh Triplett



--------------enig0D4A85A1BCF35F7EFF0B437E
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGlc3AGJuZRtD+evsRAlREAKC/aXcIo2mYNOb6nG6tfwhxHM+Z4QCgm3kO
qXuoWeh3LGGJM8E/0wlnnZ0=
=wCQp
-----END PGP SIGNATURE-----

--------------enig0D4A85A1BCF35F7EFF0B437E--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix handling of pointers in ?: ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] fix handling of pointers in ?:
Date: Tue, 10 Jul 2007 01:07:33 +0000
Message-ID: <20070710010733.GQ21668 () ftp ! linux ! org ! uk>
--------------------
a) qualifiers are joined (const int * / volatile int * -> const volatile int *)
b) pointer to void / pointer to T => pointer to void (with all qualifiers)

testcase added

Still missing: T1 * / T2 * => pointer to composite type of T1 and T2

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c              |   82 ++++++++++++++++++++++++++++-------------------
 validation/cond_expr2.c |   23 +++++++++++++
 2 files changed, 72 insertions(+), 33 deletions(-)
 create mode 100644 validation/cond_expr2.c

diff --git a/evaluate.c b/evaluate.c
index d505007..9f543fe 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1070,31 +1070,6 @@ OK:
 }
 
 /*
- * FIXME!! This should do casts, array degeneration etc..
- */
-static struct symbol *compatible_ptr_type(struct expression *left, struct expression *right)
-{
-	struct symbol *ltype = left->ctype, *rtype = right->ctype;
-
-	if (ltype->type == SYM_NODE)
-		ltype = ltype->ctype.base_type;
-
-	if (rtype->type == SYM_NODE)
-		rtype = rtype->ctype.base_type;
-
-	if (ltype->type == SYM_PTR) {
-		if (rtype->ctype.base_type == &void_ctype)
-			return ltype;
-	}
-
-	if (rtype->type == SYM_PTR) {
-		if (ltype->ctype.base_type == &void_ctype)
-			return rtype;
-	}
-	return NULL;
-}
-
-/*
  * NOTE! The degenerate case of "x ? : y", where we don't
  * have a true case, this will possibly promote "x" to the
  * same type as "y", and thus _change_ the conditional
@@ -1104,9 +1079,10 @@ static struct symbol *compatible_ptr_type(struct expression *left, struct expres
 static struct symbol *evaluate_conditional_expression(struct expression *expr)
 {
 	struct expression **true;
-	struct symbol *ctype, *ltype, *rtype;
+	struct symbol *ctype, *ltype, *rtype, *lbase, *rbase;
 	int lclass, rclass;
 	const char * typediff;
+	int qual;
 
 	if (!evaluate_conditional(expr->conditional, 0))
 		return NULL;
@@ -1141,9 +1117,11 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 		expr->cond_false = cast_to(expr->cond_false, ctype);
 		goto out;
 	}
+
 	if ((lclass | rclass) & TYPE_PTR) {
 		int is_null1 = is_null_pointer_constant(*true);
 		int is_null2 = is_null_pointer_constant(expr->cond_false);
+
 		if (is_null1 && is_null2) {
 			*true = cast_to(*true, &ptr_ctype);
 			expr->cond_false = cast_to(expr->cond_false, &ptr_ctype);
@@ -1169,15 +1147,42 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 			goto Err;
 		}
 		/* OK, it's pointer on pointer */
-		/* XXX - we need to handle qualifiers */
-		ctype = compatible_ptr_type(*true, expr->cond_false);
-		if (ctype)
-			goto out;
+		if (ltype->ctype.as != rtype->ctype.as) {
+			typediff = "different address spaces";
+			goto Err;
+		}
+
+		/* need to be lazier here */
+		lbase = get_base_type(ltype);
+		rbase = get_base_type(rtype);
+		qual = ltype->ctype.modifiers | rtype->ctype.modifiers;
+		qual &= MOD_CONST | MOD_VOLATILE;
+
+		if (lbase == &void_ctype) {
+			/* XXX: pointers to function should warn here */
+			ctype = ltype;
+			goto Qual;
+
+		}
+		if (rbase == &void_ctype) {
+			/* XXX: pointers to function should warn here */
+			ctype = rtype;
+			goto Qual;
+		}
+		/* XXX: that should be pointer to composite */
+		ctype = ltype;
+		typediff = type_difference(lbase, rbase, MOD_IGN, MOD_IGN);
+		if (!typediff)
+			goto Qual;
+		goto Err;
 	}
-	ctype = ltype;
-	typediff = type_difference(ltype, rtype, MOD_IGN, MOD_IGN);
-	if (!typediff)
+
+	/* void on void, struct on same struct, union on same union */
+	if (ltype == rtype) {
+		ctype = ltype;
 		goto out;
+	}
+	typediff = "different base types";
 
 Err:
 	expression_error(expr, "incompatible types in conditional expression (%s)", typediff);
@@ -1186,6 +1191,17 @@ Err:
 out:
 	expr->ctype = ctype;
 	return ctype;
+
+Qual:
+	if (qual & ~ctype->ctype.modifiers) {
+		struct symbol *sym = alloc_symbol(ctype->pos, SYM_PTR);
+		*sym = *ctype;
+		sym->ctype.modifiers |= qual;
+		ctype = sym;
+	}
+	*true = cast_to(*true, ctype);
+	expr->cond_false = cast_to(expr->cond_false, ctype);
+	goto out;
 }
 
 /* FP assignments can not do modulo or bit operations */
diff --git a/validation/cond_expr2.c b/validation/cond_expr2.c
new file mode 100644
index 0000000..e53cd13
--- /dev/null
+++ b/validation/cond_expr2.c
@@ -0,0 +1,23 @@
+extern const int *p;
+extern volatile void *q;
+extern volatile int *r;
+static void f(void)
+{
+	q = 1 ? p : q;	// warn: const volatile void * -> const int *
+	r = 1 ? r : q;	// OK: volatile void * -> volatile int *
+	r = 1 ? r : p;	// warn: const volatile int * -> volatile int *
+}
+/*
+ * check-name: type of conditional expression
+ * check-description: Used to miss qualifier mixing and mishandle void *
+ * check-command: sparse $file
+ *
+ * check-output-start
+cond_expr2.c:6:4: warning: incorrect type in assignment (different modifiers)
+cond_expr2.c:6:4:    expected void volatile *extern [addressable] [toplevel] q
+cond_expr2.c:6:4:    got void const volatile *
+cond_expr2.c:8:4: warning: incorrect type in assignment (different modifiers)
+cond_expr2.c:8:4:    expected int volatile *extern [addressable] [toplevel] [assigned] r
+cond_expr2.c:8:4:    got int const volatile *
+ * check-output-end
+ */
-- 
1.5.0-rc2.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix interaction of typeof with bitwise types ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] fix interaction of typeof with bitwise types
Date: Fri, 25 May 2007 03:57:49 +0000
Message-ID: <E1HrQw1-00018q-JI () ZenIV ! linux ! org ! uk>
--------------------

typeof(bitwise) should resolve to the same SYM_RESTRICT type node, not just
to a copy of its contents.  Similar problem exists for struct and union,
BTW, but that's a separate story.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 symbol.c                       |    6 ++++++
 validation/restricted-typeof.c |    4 ++++
 2 files changed, 10 insertions(+), 0 deletions(-)
 create mode 100644 validation/restricted-typeof.c

diff --git a/symbol.c b/symbol.c
index 20a04f3..abdc734 100644
--- a/symbol.c
+++ b/symbol.c
@@ -408,6 +408,12 @@ struct symbol *examine_symbol_type(struct symbol * sym)
 				warning(base->pos, "typeof applied to bitfield type");
 			if (base->type == SYM_NODE)
 				base = base->ctype.base_type;
+			if (base->type == SYM_RESTRICT) {
+				sym->type = SYM_NODE;
+				sym->ctype.modifiers = 0;
+				sym->ctype.base_type = base;
+				return examine_node_type(sym);
+			}
 			*sym = *base;
 			break;
 		}
diff --git a/validation/restricted-typeof.c b/validation/restricted-typeof.c
new file mode 100644
index 0000000..be77af8
--- /dev/null
+++ b/validation/restricted-typeof.c
@@ -0,0 +1,4 @@
+typedef unsigned __attribute__((bitwise)) A;
+A x;
+__typeof__(x) y;
+A *p = &y;
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] handle __alignof as equivalent of __alignof__ ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] handle __alignof as equivalent of __alignof__
Date: Fri, 25 May 2007 03:57:29 +0000
Message-ID: <E1HrQvh-00018A-IV () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 expression.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/expression.c b/expression.c
index 457e1fd..cf076a9 100644
--- a/expression.c
+++ b/expression.c
@@ -544,6 +544,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 			} type_information[] = {
 				{ &sizeof_ident, EXPR_SIZEOF },
 				{ &__alignof___ident, EXPR_ALIGNOF },
+				{ &__alignof_ident, EXPR_ALIGNOF },
 				{ &__sizeof_ptr___ident, EXPR_PTRSIZEOF },
 			};
 			int i;
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] handle label attributes ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] handle label attributes
Date: Fri, 23 Mar 2007 23:10:08 +0000
Message-ID: <20070323231008.GD27992 () chrisli ! org>
--------------------
On Fri, Mar 23, 2007 at 03:04:59PM -0700, Randy Dunlap wrote:
> 1.  net/sched/cls_api.c, lines 593-611:
> 
> 	return 0;
> rtattr_failure: __attribute__ ((unused))
> 	return -1;
> }


Singed-Off-By: Christopher Li<sparse@chrisli.org>

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-03-23 16:09:39.000000000 -0700
+++ sparse/parse.c	2007-03-23 16:10:00.000000000 -0700
@@ -1701,7 +1701,8 @@ static struct token *statement(struct to
 		if (match_op(token->next, ':')) {
 			stmt->type = STMT_LABEL;
 			stmt->label_identifier = label_symbol(token);
-			return statement(token->next->next, &stmt->label_statement);
+			token = handle_attributes(token->next->next, &stmt->label_identifier->ctype);
+			return statement(token, &stmt->label_statement);
 		}
 	}
 
Index: sparse/validation/label-attr.c
===================================================================
--- sparse.orig/validation/label-attr.c	2007-03-23 16:10:00.000000000 -0700
+++ sparse/validation/label-attr.c	2007-03-23 16:10:00.000000000 -0700
@@ -0,0 +1,6 @@
+int foo(void)
+{
+       return 0;
+rtattr_failure: __attribute__ ((unused))
+       return -1;
+}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: [PATCH] handle label attributes
Date: Sun, 25 Mar 2007 18:52:23 +0000
Message-ID: <20070325115223.f040a571.rdunlap () xenotime ! net>
--------------------
On Fri, 23 Mar 2007 16:10:08 -0700 Christopher Li wrote:

> On Fri, Mar 23, 2007 at 03:04:59PM -0700, Randy Dunlap wrote:
> > 1.  net/sched/cls_api.c, lines 593-611:
> > 
> > 	return 0;
> > rtattr_failure: __attribute__ ((unused))
> > 	return -1;
> > }
> 
> 
> Singed-Off-By: Christopher Li<sparse@chrisli.org>

Hi,
Yes, that does handle the label attributes cleanly.

Thanks.

> Index: sparse/parse.c
> ===================================================================
> --- sparse.orig/parse.c	2007-03-23 16:09:39.000000000 -0700
> +++ sparse/parse.c	2007-03-23 16:10:00.000000000 -0700
> @@ -1701,7 +1701,8 @@ static struct token *statement(struct to
>  		if (match_op(token->next, ':')) {
>  			stmt->type = STMT_LABEL;
>  			stmt->label_identifier = label_symbol(token);
> -			return statement(token->next->next, &stmt->label_statement);
> +			token = handle_attributes(token->next->next, &stmt->label_identifier->ctype);
> +			return statement(token, &stmt->label_statement);
>  		}
>  	}
>  
> Index: sparse/validation/label-attr.c
> ===================================================================
> --- sparse.orig/validation/label-attr.c	2007-03-23 16:10:00.000000000 -0700
> +++ sparse/validation/label-attr.c	2007-03-23 16:10:00.000000000 -0700
> @@ -0,0 +1,6 @@
> +int foo(void)
> +{
> +       return 0;
> +rtattr_failure: __attribute__ ((unused))
> +       return -1;
> +}
> 


---
~Randy
*** Remember to use Documentation/SubmitChecklist when testing your code ***
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] handle label attributes
Date: Fri, 20 Apr 2007 10:17:07 +0000
Message-ID: <46289323.9000804 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig4BA246429C418ED25AB50655
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> On Fri, Mar 23, 2007 at 03:04:59PM -0700, Randy Dunlap wrote:
>> 1.  net/sched/cls_api.c, lines 593-611:
>>
>> 	return 0;
>> rtattr_failure: __attribute__ ((unused))
>> 	return -1;
>> }

Applied, with the minor change of making the function in the new test cas=
e
static to avoid an unrelated warning with -Wdecl.

> Singed-Off-By: Christopher Li<sparse@chrisli.org>

And just what sound *does* a patch make when you sing it off? :)

- Josh Triplett


--------------enig4BA246429C418ED25AB50655
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGKJMjGJuZRtD+evsRAhSMAJ9Be2EwYzdXeq57UdrA/ZCzJVub9QCePm8X
ZIE7twXiR9V9qAvKPJ4HTdI=
=5zMb
-----END PGP SIGNATURE-----

--------------enig4BA246429C418ED25AB50655--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] libxml compile fix on Cygwin ===

From: Kovarththanan Rajaratnam <krj () rajaratnam ! dk>
To: linux-sparse
Subject: [PATCH] libxml compile fix on Cygwin
Date: Wed, 08 Aug 2007 20:34:39 +0000
Message-ID: <f9d9d1$m7o$1 () sea ! gmane ! org>
--------------------
This is a multi-part message in MIME format.
--------------010405000209000009060906
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

Hello,

I needed to re-arrange the libxml-2.0 library order to make sparse 
compile on Cygwin. Patch attached.

Signed-off-by: Kovarththanan Rajaratnam <krj@rajaratnam.dk>


--------------010405000209000009060906
Content-Type: text/x-patch;
 name="libxml_cygwin_fix.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="libxml_cygwin_fix.patch"

diff --git a/Makefile b/Makefile
index 1e06794..f07290e 100644
--- a/Makefile
+++ b/Makefile
@@ -124,7 +124,7 @@ ctags: ctags.o $(LIBS)
 	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
 c2xml: c2xml.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) `pkg-config --libs libxml-2.0` -o $@ $< $(LIBS)
+	$(QUIET_LINK)$(CC) $(LDFLAGS)  -o $@ $< $(LIBS) `pkg-config --libs libxml-2.0`
 
 $(LIB_FILE): $(LIB_OBJS)
 	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)

--------------010405000209000009060906--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] libxml compile fix on Cygwin
Date: Fri, 10 Aug 2007 05:53:12 +0000
Message-ID: <46BBFD48.3030805 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig3A97802D4B0C25CDB7D346E2
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Kovarththanan Rajaratnam wrote:
> I needed to re-arrange the libxml-2.0 library order to make sparse=20
> compile on Cygwin. Patch attached.
>=20
> Signed-off-by: Kovarththanan Rajaratnam <krj@rajaratnam.dk>

Applied; thanks!

- Josh Triplett


--------------enig3A97802D4B0C25CDB7D346E2
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGu/1IGJuZRtD+evsRAgfXAKCOd2XCA4RrehGEnv9am2iwl5RAYQCcDybO
BEGejT6zHqdVQvcHaEQWFfU=
=gdqK
-----END PGP SIGNATURE-----

--------------enig3A97802D4B0C25CDB7D346E2--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] parse.c: Adding va_end(). ===

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] parse.c: Adding va_end().
Date: Fri, 27 Jul 2007 17:22:01 +0000
Message-ID: <1185556921.2642.9.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-27 at 01:28 +0200, ricknu-0@student.ltu.se wrote:
> Adding va_end().
> 
> Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
> ---
> According to the manual, it needs a va_end() in the same function.
> Now it seems to be as many of va_end() as va_start().

Applied; thanks.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] saner reporting of overlaps in initializers ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] saner reporting of overlaps in initializers
Date: Fri, 25 May 2007 03:57:34 +0000
Message-ID: <E1HrQvm-00018O-Ig () ZenIV ! linux ! org ! uk>
--------------------

Fix the check for overlapping initializers; the current code tries to
skip ones with zero ->bit_size, but doesn't get it right.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 expand.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/expand.c b/expand.c
index aafbfe0..a46f1c2 100644
--- a/expand.c
+++ b/expand.c
@@ -874,7 +874,9 @@ static void verify_nonoverlapping(struct expression_list **list)
 	struct expression *b;
 
 	FOR_EACH_PTR(*list, b) {
-		if (a && a->ctype && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
+		if (!b->ctype || !b->ctype->bit_size)
+			continue;
+		if (a && bit_offset(a) == bit_offset(b)) {
 			sparse_error(a->pos, "Initializer entry defined twice");
 			info(b->pos, "  also defined here");
 			return;
-- 
1.5.0-rc2.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] tokenize.c: Replacing handmade rutin with existing function. ===

From: ricknu-0 () student ! ltu ! se
To: linux-sparse
Subject: [PATCH] tokenize.c: Replacing handmade rutin with existing function.
Date: Thu, 19 Jul 2007 00:04:36 +0000
Message-ID: <1184803476.469eaa94bd1a8 () portal ! student ! luth ! se>
--------------------
Replace handwritten with existing function.

Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
---
Equal, right?

diff --git a/tokenize.c b/tokenize.c
index fbe4c5a..e72c56e 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -792,16 +792,9 @@ static struct ident *create_hashed_ident(const char *name,
int len, unsigned lon
 	p = &hash_table[hash];
 	while ((ident = *p) != NULL) {
 		if (ident->len == (unsigned char) len) {
-			const char *n = name;
-			const char *m = ident->name;
-			int l = len;
-			do {
-				if (*n != *m)
-					goto next;
-				n++;
-				m++;
-			} while (--l);
-				
+			if (strncmp(name, ident->name, len) != 0)
+				goto next;
+
 			ident_hit++;
 			return ident;
 		}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] tokenize.c: Simplify drop_stream_eoln(). ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] tokenize.c: Simplify drop_stream_eoln().
Date: Sun, 29 Jul 2007 08:13:55 +0000
Message-ID: <46AC4C43.8090202 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigA9EC5D2A036F47DDDD25B960
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

ricknu-0@student.ltu.se wrote:
> Simplifying function drop_stream_eoln().
>=20
> Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
> ---
> Is there a reason to call nextchar() before drop_token()?

None that I know of, and your patch doesn't break the test suite.  Applie=
d;
thanks!

- Josh Triplett



--------------enigA9EC5D2A036F47DDDD25B960
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGrExDGJuZRtD+evsRAhEQAKCJ504HYm2eyxLoGutvNcmcj0JxVACguAh3
vrZWz0CxRiDJvnUGVAbolK4=
=Dg8c
-----END PGP SIGNATURE-----

--------------enigA9EC5D2A036F47DDDD25B960--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] vector parsing (take II) ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] vector parsing (take II)
Date: Fri, 23 Mar 2007 23:14:02 +0000
Message-ID: <20070323231402.GE27992 () chrisli ! org>
--------------------
Any one want to try this patch on PowerPC for vector
support? I surely don't have one.

Chris


Sparse will take "-maltivec" into account and turn on
vector parsing accordingly.

Signed-Off-By: Christopher Li <sparse@chrisli.org>

Index: sparse/symbol.c
===================================================================
--- sparse.orig/symbol.c	2007-03-23 12:45:11.000000000 -0700
+++ sparse/symbol.c	2007-03-23 13:48:02.000000000 -0700
@@ -425,6 +425,9 @@ struct symbol *examine_symbol_type(struc
 	case SYM_FOULED:
 		examine_base_type(sym);
 		return sym;
+	case SYM_VECTOR:
+		examine_base_type(sym);
+		return sym;
 	default:
 		sparse_error(sym->pos, "Examining unknown symbol type %d", sym->type);
 		break;
Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2007-03-23 12:45:11.000000000 -0700
+++ sparse/parse.c	2007-03-23 15:33:28.000000000 -0700
@@ -34,6 +34,9 @@ static struct symbol_list **function_sym
 struct symbol_list *function_computed_target_list;
 struct statement_list *function_computed_goto_list;
 
+static struct symbol *alloc_indirect_symbol(struct position pos, struct ctype *ctype, int type);
+static struct token *declaration_specifiers(struct token *next, struct ctype *ctype, int qual);
+
 static struct token *statement(struct token *token, struct statement **tree);
 static struct token *handle_attributes(struct token *token, struct ctype *ctype);
 
@@ -42,6 +45,7 @@ static struct token *union_specifier(str
 static struct token *enum_specifier(struct token *token, struct ctype *ctype);
 static struct token *attribute_specifier(struct token *token, struct ctype *ctype);
 static struct token *typeof_specifier(struct token *token, struct ctype *ctype);
+static struct token *vector_specifier(struct token *token, struct ctype *ctype);
 
 static struct token *parse_if_statement(struct token *token, struct statement *stmt);
 static struct token *parse_return_statement(struct token *token, struct statement *stmt);
@@ -103,6 +107,9 @@ static struct symbol_op enum_op = {
 	.declarator = enum_specifier,
 };
 
+static struct symbol_op vector_op = {
+	.declarator = vector_specifier,
+};
 
 
 static struct symbol_op if_op = {
@@ -225,6 +232,8 @@ static struct init_keyword {
 	{ "union", 	NS_TYPEDEF, .op = &union_op },
 	{ "enum", 	NS_TYPEDEF, .op = &enum_op },
 
+	{ "vector", 	NS_TYPEDEF, .op = &vector_op },
+
 	{ "inline",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
 	{ "__inline",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
 	{ "__inline__",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
@@ -382,6 +391,7 @@ static int apply_modifiers(struct positi
 		case SYM_ARRAY:
 		case SYM_BITFIELD:
 		case SYM_PTR:
+		case SYM_VECTOR:
 			ctype = &base->ctype;
 			continue;
 		}
@@ -720,6 +730,21 @@ static struct token *enum_specifier(stru
 	return ret;
 }
 
+static struct token *vector_specifier(struct token *token, struct ctype *ctype)
+{
+	struct token *next;
+	struct symbol *vector;
+
+	if (!maltivec)
+		return NULL;
+
+	next = declaration_specifiers(token, ctype, 0);
+	vector = alloc_indirect_symbol(token->pos, ctype, SYM_VECTOR);
+	vector->bit_size = bits_in_vector;
+	vector->ctype.alignment = vector_alignment;
+	return next;
+}
+
 static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
 {
 	struct symbol *sym;
@@ -1046,6 +1071,8 @@ static struct token *declaration_specifi
 		}
 		if (s->type == SYM_KEYWORD && s->op->declarator) {
 			next = s->op->declarator(next, &thistype);
+			if (!next)
+				break;
 			mod = thistype.modifiers;
 		}
 		type = thistype.base_type;
Index: sparse/symbol.h
===================================================================
--- sparse.orig/symbol.h	2007-03-23 12:45:11.000000000 -0700
+++ sparse/symbol.h	2007-03-23 13:48:02.000000000 -0700
@@ -54,6 +54,7 @@ enum type {
 	SYM_LABEL,
 	SYM_RESTRICT,
 	SYM_FOULED,
+	SYM_VECTOR,
 	SYM_KEYWORD,
 	SYM_BAD,
 };
@@ -178,7 +179,8 @@ struct symbol {
 #define MOD_LONG	0x0400
 #define MOD_LONGLONG	0x0800
 
-#define MOD_TYPEDEF	0x1000
+#define MOD_VECTOR	0x1000
+#define MOD_TYPEDEF	0x2000
 
 #define MOD_INLINE	0x40000
 #define MOD_ADDRESSABLE	0x80000
Index: sparse/lib.c
===================================================================
--- sparse.orig/lib.c	2007-03-22 14:11:40.000000000 -0700
+++ sparse/lib.c	2007-03-23 15:29:44.000000000 -0700
@@ -208,6 +208,8 @@ int Wuninitialized = 1;
 int dbg_entry = 0;
 int dbg_dead = 0;
 
+int maltivec = 0;
+
 int preprocess_only;
 char *include;
 
@@ -321,6 +323,9 @@ static char **handle_switch_m(char *arg,
 		max_int_alignment = 8;
 		bits_in_pointer = 64;
 		pointer_alignment = 8;
+	} else if (!strcmp(arg, "maltivec")) {
+		maltivec = 1;
+		add_pre_buffer("#define __VEC__\n");
 	}
 	return next;
 }
Index: sparse/target.h
===================================================================
--- sparse.orig/target.h	2006-12-05 16:17:39.000000000 -0800
+++ sparse/target.h	2007-03-23 14:53:26.000000000 -0700
@@ -42,4 +42,10 @@ extern int pointer_alignment;
 extern int bits_in_enum;
 extern int enum_alignment;
 
+/*
+ * Vector data types.
+ */
+extern int bits_in_vector;
+extern int vector_alignment;
+
 #endif
Index: sparse/expression.h
===================================================================
Index: sparse/evaluate.c
===================================================================
--- sparse.orig/evaluate.c	2007-03-23 12:45:11.000000000 -0700
+++ sparse/evaluate.c	2007-03-23 13:48:02.000000000 -0700
@@ -349,6 +349,7 @@ enum {
 	TYPE_PTR = 16,
 	TYPE_COMPOUND = 32,
 	TYPE_FOULED = 64,
+	TYPE_VECTOR = 128,
 };
 
 static inline int classify_type(struct symbol *type, struct symbol **base)
@@ -362,6 +363,7 @@ static inline int classify_type(struct s
 		[SYM_BITFIELD] = TYPE_NUM | TYPE_BITFIELD,
 		[SYM_RESTRICT] = TYPE_NUM | TYPE_RESTRICT,
 		[SYM_FOULED] = TYPE_NUM | TYPE_RESTRICT | TYPE_FOULED,
+		[SYM_VECTOR] = TYPE_VECTOR | TYPE_NUM, 
 	};
 	if (type->type == SYM_NODE)
 		type = type->ctype.base_type;
@@ -556,6 +558,9 @@ static struct symbol *evaluate_arith(str
 	if (!(lclass & rclass & TYPE_NUM))
 		goto Bad;
 
+	if ((lclass ^ rclass) & TYPE_VECTOR)
+		goto Bad;
+
 	if (!float_ok && (lclass | rclass) & TYPE_FLOAT)
 		goto Bad;
 
@@ -2086,6 +2091,7 @@ static void evaluate_initializer(struct 
 		switch (ctype->type) {
 		case SYM_ARRAY:
 		case SYM_PTR:
+		case SYM_VECTOR:
 			evaluate_array_initializer(get_base_type(ctype), expr);
 			return;
 		case SYM_UNION:
Index: sparse/target.c
===================================================================
--- sparse.orig/target.c	2006-12-05 16:17:39.000000000 -0800
+++ sparse/target.c	2007-03-23 14:51:51.000000000 -0700
@@ -43,3 +43,10 @@ int pointer_alignment = 4;
  */
 int bits_in_enum = 32;
 int enum_alignment = 4;
+
+/*
+ * Vector data types.
+ */
+int bits_in_vector = 128;
+int vector_alignment = 16;
+
Index: sparse/lib.h
===================================================================
--- sparse.orig/lib.h	2007-03-22 14:11:40.000000000 -0700
+++ sparse/lib.h	2007-03-23 14:50:04.000000000 -0700
@@ -99,6 +99,8 @@ extern int Wcast_truncate;
 extern int Wdo_while;
 extern int Wuninitialized;
 
+extern int maltivec;
+
 extern int dbg_entry;
 extern int dbg_dead;
 
Index: sparse/validation/vector2.c
===================================================================
--- sparse.orig/validation/vector2.c	2007-03-23 13:48:01.000000000 -0700
+++ sparse/validation/vector2.c	2007-03-23 15:19:11.000000000 -0700
@@ -0,0 +1,10 @@
+
+typedef vector signed char unative_t;
+
+int vector;
+
+#define NBYTES(x) ((vector signed char) {x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x})
+#define NSIZE	sizeof(unative_t)
+
+unative_t zv = NBYTES(0);
+
Index: sparse/validation/vector3.c
===================================================================
--- sparse.orig/validation/vector3.c	2007-03-23 15:19:34.000000000 -0700
+++ sparse/validation/vector3.c	2007-03-23 15:19:47.000000000 -0700
@@ -0,0 +1,2 @@
+int vector;
+
Index: sparse/validation/vector.c
===================================================================
--- sparse.orig/validation/vector.c	2007-03-23 13:48:01.000000000 -0700
+++ sparse/validation/vector.c	2007-03-23 15:41:32.000000000 -0700
@@ -0,0 +1,33 @@
+#ifndef __VEC__
+#error Use "-maltivec" flag to enable PowerPC AltiVec support.
+#endif
+
+typedef vector signed char unative_t;
+
+#define NBYTES(x) ((vector signed char) {x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x})
+#define NSIZE	sizeof(unative_t)
+
+#define __attribute_const__		__attribute__((__const__))
+
+extern unative_t vec_add(unative_t a, unative_t b);
+extern unative_t vec_cmpgt(unative_t a, unative_t b);
+
+static inline __attribute_const__ unative_t SHLBYTE(unative_t v)
+{
+	return vec_add(v,v);
+}
+
+static inline __attribute_const__ unative_t MASK(unative_t v)
+{
+	unative_t zv = NBYTES(0);
+
+	/* vec_cmpgt returns a vector bool char; thus the need for the cast */
+	return (unative_t)vec_cmpgt(zv, v);
+}
+
+unative_t foo(void)
+{
+	unative_t i = NBYTES(1);
+	return SHLBYTE(i) + MASK(i);
+}
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH](take II) Sparse fooled by double semicolon ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH](take II) Sparse fooled by double semicolon
Date: Wed, 31 Jan 2007 07:46:38 +0000
Message-ID: <1170229598.11455.104.camel () dv>
--------------------
On Tue, 2007-01-30 at 23:17 -0800, Christopher Li wrote:
> Actually, this version is better because it handle semicolon
> as the first member as well.

That's working too.

-- 
Regards,
Pavel Roskin


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH](take II) Sparse fooled by double semicolon
Date: Fri, 23 Feb 2007 03:43:29 +0000
Message-ID: <45DE62E1.9040606 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig3A7C6254D1E2B6ECAB54A132
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> Actually, this version is better because it handle semicolon
> as the first member as well.
>=20
> Fix double semicolon in struct declare
>=20
> Pavel discover this test case:
> #include <string.h>
> void test(void)
> {
>        struct { int foo;; } val;
>        memset(&val, 0, sizeof(val));
> }
>=20
> Sparse ends up create a node with empty ctype in the member list.
> Skip that seems fix it.
>=20
> Signed-Off-By: Christopher Li<spase@chrisli.org>

Applied, along with the test case.

- Josh Triplett



--------------enig3A7C6254D1E2B6ECAB54A132
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3mLhGJuZRtD+evsRAkLqAJ9w4tRIQuSbsv3X4clEuVYy9s2VQACeKb+M
d75LaSIJ2DNJGcdL9fdW5gI=
=MVqk
-----END PGP SIGNATURE-----

--------------enig3A7C6254D1E2B6ECAB54A132--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH](take II) Sparse fooled by double semicolon
Date: Fri, 23 Feb 2007 03:43:29 +0000
Message-ID: <45DE62E1.9040606 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig3A7C6254D1E2B6ECAB54A132
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
> Actually, this version is better because it handle semicolon
> as the first member as well.
>=20
> Fix double semicolon in struct declare
>=20
> Pavel discover this test case:
> #include <string.h>
> void test(void)
> {
>        struct { int foo;; } val;
>        memset(&val, 0, sizeof(val));
> }
>=20
> Sparse ends up create a node with empty ctype in the member list.
> Skip that seems fix it.
>=20
> Signed-Off-By: Christopher Li<spase@chrisli.org>

Applied, along with the test case.

- Josh Triplett



--------------enig3A7C6254D1E2B6ECAB54A132
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF3mLhGJuZRtD+evsRAkLqAJ9w4tRIQuSbsv3X4clEuVYy9s2VQACeKb+M
d75LaSIJ2DNJGcdL9fdW5gI=
=MVqk
-----END PGP SIGNATURE-----

--------------enig3A7C6254D1E2B6ECAB54A132--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH] Make sparse return 1 if errors occurred ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: [RFC PATCH] Make sparse return 1 if errors occurred
Date: Sat, 14 Jul 2007 20:51:24 +0000
Message-ID: <4699374C.1030303 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig453E37CBA0683056BF9284C7
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Sparse always returned 0.  Change it to return 1 if errors occurred, and
remove check-known-to-fail from tests that expected that behavior.

Also rename the misleadingly named global die_if_error to had_errors.

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 lib.c                                         |    4 ++--
 lib.h                                         |    2 +-
 sparse.c                                      |    2 +-
 validation/bad-array-designated-initializer.c |    2 --
 validation/bad-assignment.c                   |    2 --
 validation/preprocessor/preprocessor18.c      |    2 --
 validation/preprocessor/preprocessor21.c      |    2 --
 7 files changed, 4 insertions(+), 12 deletions(-)

diff --git a/lib.c b/lib.c
index a1442a2..be1aca4 100644
--- a/lib.c
+++ b/lib.c
@@ -29,7 +29,7 @@
 #include "target.h"
=20
 int verbose, optimize, optimize_size, preprocessing;
-int die_if_error =3D 0;
+int had_errors =3D 0;
=20
 #ifndef __GNUC__
 # define __GNUC__ 2
@@ -129,7 +129,7 @@ void warning(struct position pos, const char * fmt, .=
=2E.)
 static void do_error(struct position pos, const char * fmt, va_list args=
)
 {
 	static int errors =3D 0;
-        die_if_error =3D 1;
+	had_errors =3D 1;
 	show_info =3D 1;
 	/* Shut up warnings after an error */
 	max_warnings =3D 0;
diff --git a/lib.h b/lib.h
index aacafea..a5e9f8e 100644
--- a/lib.h
+++ b/lib.h
@@ -18,7 +18,7 @@
 #include "ptrlist.h"
=20
 extern int verbose, optimize, optimize_size, preprocessing;
-extern int die_if_error;
+extern int had_errors;
 extern int repeat_phase, merge_phi_sources;
 extern int gcc_major, gcc_minor, gcc_patchlevel;
=20
diff --git a/sparse.c b/sparse.c
index 4026ba7..2f74194 100644
--- a/sparse.c
+++ b/sparse.c
@@ -283,5 +283,5 @@ int main(int argc, char **argv)
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		check_symbols(sparse(file));
 	} END_FOR_EACH_PTR_NOTAG(file);
-	return 0;
+	return had_errors;
 }
diff --git a/validation/bad-array-designated-initializer.c b/validation/b=
ad-array-designated-initializer.c
index ecc5bd3..75e8a10 100644
--- a/validation/bad-array-designated-initializer.c
+++ b/validation/bad-array-designated-initializer.c
@@ -12,6 +12,4 @@ bad-array-designated-initializer.c:3:3: error: Expected=
 constant expression
 bad-array-designated-initializer.c:3:3: error: Expected } at end of init=
ializer
 bad-array-designated-initializer.c:3:3: error: got \
  * check-output-end
- *
- * check-known-to-fail
  */
diff --git a/validation/bad-assignment.c b/validation/bad-assignment.c
index 66f6fe8..f876076 100644
--- a/validation/bad-assignment.c
+++ b/validation/bad-assignment.c
@@ -13,6 +13,4 @@ static int foo(int a)
 bad-assignment.c:3:6: error: Expected ; at end of statement
 bad-assignment.c:3:6: error: got \
  * check-output-end
- *
- * check-known-to-fail
  */
diff --git a/validation/preprocessor/preprocessor18.c b/validation/prepro=
cessor/preprocessor18.c
index b4de1e6..b864010 100644
--- a/validation/preprocessor/preprocessor18.c
+++ b/validation/preprocessor/preprocessor18.c
@@ -12,6 +12,4 @@ preprocessor/preprocessor18.c:2:2: error: expected iden=
tifier to 'define'
 preprocessor/preprocessor18.c:3:2: error: expected identifier to 'undef'=

=20
  * check-output-end
- *
- * check-known-to-fail
  */
diff --git a/validation/preprocessor/preprocessor21.c b/validation/prepro=
cessor/preprocessor21.c
index 1719fc0..ce62dbb 100644
--- a/validation/preprocessor/preprocessor21.c
+++ b/validation/preprocessor/preprocessor21.c
@@ -11,6 +11,4 @@ preprocessor/preprocessor21.c:2:2: error: unterminated =
preprocessor conditional
=20
=20
  * check-output-end
- *
- * check-known-to-fail
  */
--=20
1.5.2.3



--------------enig453E37CBA0683056BF9284C7
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGmTdMGJuZRtD+evsRAqgbAJ0RqNfRreKGNLXiHsd+9Clbf/ovbgCgsdLL
bizdbHa8aYkkxVUKBXnXDi8=
=2Tct
-----END PGP SIGNATURE-----

--------------enig453E37CBA0683056BF9284C7--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] bloody mess with __attribute__() syntax ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 17:26:40 +0000
Message-ID: <alpine.LFD.0.98.0707051014380.9434 () woody ! linux-foundation ! org>
--------------------


On Thu, 5 Jul 2007, Al Viro wrote:
> > 
> > So what I'd suggest is to just have *both* cases trigger on __attribute__, 
> > but in the qualifier case we'd use NS_QUALIFIER to look up the attribute 
> > function, and in the non-qualifier case we'd use NS_ATTRIBUTE (right now 
> > we always use NS_KEYWORD, and that's probably bogus: we should put the 
> > attribute names in another namespace _anyway_).
> 
> But that's the problem - we have places where *both* qualifiers and
> attributes are allowed and they apply to different parts of declaration.

So?

If they are allowed int he same place, they have to be parsed in the same 
place.

And if that place allows both attributes and qualifiers, then that place 
*has* to have the parsing for both "__attibute__" and "__qualifier__".

And I'm just saying that:
 (a) having two different magic keywords is silly and stupid, since:
 (b) We already have *one* magic keyword that can (and has to) look at its 
     subwords, and those sub-words have the capability to tell which of 
     the two cases we have (by just using name-space lookups)

> So I'm afraid that we need to change __attribute__ parsing anyway...

YES. That's what I said in my original email. I said:

  "... what you suggest would involve having a new place for parsing
   __attributes__, and making the *current* qualifier-like attribute 
   parsing trigger on "__qualifier__" instead.

   So what I'd suggest is to just have *both* cases trigger on 
   __attribute__, but in the qualifier case we'd use NS_QUALIFIER to look 
   up the attribute function, and in the non-qualifier case we'd use 
   NS_ATTRIBUTE (right now we always use NS_KEYWORD, and that's probably 
   bogus: we should put the attribute names in another namespace 
   _anyway_)"

IOW, nobody disputes that to get the new semantics, we have to have new 
code.  That's obvious.

But what I dispute is that you need to make a whole new keyword. We 
already *have* the keywords. They are the sub-keywords inside the 
"__attribute__()" list.

In other words, the way we really should parse __attribute__ stuff (and 
this is largely how we *do* parse them) is that we end up doing

	__attribute__((x(n),y(m)))

and we turn that into

	__attribute_x__(n) __attribute_y__(m)

where that "__attrubute_x__" really comes from the lookup of "x" in the 
"attribute" namespace (well, right now it's actually NS_KEYWORD, but 
that's a small detail). 

That's literally how we do it now.

And yes, we can do a new top-level name, and have

	__qualifier__((x(n))

turn into

	__qualifier_x__(n)

instead, but I just don't see any advantage. You can already do lookups 
from multiple address spaces at the same time, so I would instead suggest 
that we just *continue* to use

	__attribute__((x(n)))

and in a place where we could accept both qualifiers and gcc attributes, 
we'd look it up with

	struct symbol *sym = lookup_symbol(x, NS_ATTR | NS_QUAL);

and in places where we can just parse one or the other, we'd use just one 
or the other.

See? THAT is what I'm saying. There's no reason to change existing syntax, 
and in fact it is just _bad_ to change existing syntax, because it doesn't 
actually buy us anything, because we already have the capability to parse 
things in different contexts, and in fact allowing things to be parsed at 
the same _time_ in the different contexts.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 18:07:42 +0000
Message-ID: <20070705180742.GP21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 10:26:40AM -0700, Linus Torvalds wrote:
> And I'm just saying that:
>  (a) having two different magic keywords is silly and stupid, since:
>  (b) We already have *one* magic keyword that can (and has to) look at its 
>      subwords, and those sub-words have the capability to tell which of 
>      the two cases we have (by just using name-space lookups)

I.e. you get per-attribute rules (fsckloads of them) and no way to tell
what do the attributes apply to unless you know the rules for given attribute.

> See? THAT is what I'm saying. There's no reason to change existing syntax, 
> and in fact it is just _bad_ to change existing syntax, because it doesn't 
> actually buy us anything, because we already have the capability to parse 
> things in different contexts, and in fact allowing things to be parsed at 
> the same _time_ in the different contexts.

Oh, I understand what you are proposing (hell, I've mentioned that variant
in the first posting).  The trouble is not with being able to implement it.
I just don't like having no relationship between the syntax and operations
on types, that's all.  gcc variant, nasty as it is for our needs, at least
has that consistent.  IOW, you can get from declaration to type structure
without knowing what each attribute does.  Seeing that gcc rules are
weird enough to be confusing, at least having that weirdness clearly
indicated by __attribute__() instead of recalling which attribute is gcc-like
and which is not...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 18:50:56 +0000
Message-ID: <1183661456.2604.43.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-05 at 17:43 +0100, Al Viro wrote:
> On Thu, Jul 05, 2007 at 08:36:35AM -0700, Josh Triplett wrote:
> > Wow.  Insane.  So these all declare the same type:
> > __attribute__((foo)) T *v;
> > T __attribute__((foo)) *v;
> > T *__attribute__((foo)) v;
> > ?  Specifically, they point to a foo-T, for convenient shooting?
> 
> They all give you foo-pointer-to-T.  
> 	T (__attribute__((foo)) *v);
> would give pointer-to-foo-T.

Doesn't that do exactly what we want, then?  If we say
T __attribute__((noderef)) *v;
, we want a noderef-pointer-to-T, not a pointer-to-noderef-T.  noderef
should modify a pointer.

> > context also represents a qualifier; the position of the qualifier should
> > determine things like whether you want to enforce the context when you access
> > a pointer or dereference a pointer.
> 
> Since __context__ is (sparse-only) keyword, we are not constrained by
> anything anyway.

No, I mean __attribute__((context(...))), which means something
different.  __context__() works as a statement statement changing the
context.  __attribute__((context(...))) works as an attribute modifying
a type to say that it requires a given context, and that
accessing/calling it changes the context.  Somewhat of an odd
distinction, but sparse currently works that way.

> > > Frankly, I would rather add a new primitive (__qualifier__) mirroring the
> > > __attribute__, but acting like real qualifiers do.  And switched the
> > > noderef et.al. to it.
> > 
> > Something like that sounds vaguely reasonable.  It should allow the same set
> > of attributes, and just change what they apply to.  To use your example,
> > T __qualifier__((foo)) *v;
> > and
> > T (__attribute__((foo)) *v);
> > would mean the same thing.
> 
> Yup, except that it would not accept storage-class-like attributes (e.g.
> always_inline).

So, to clarify what you mean by storage-class-like: __qualifier__ would
accept all attributes that modify a *type* rather than a *declaration*.

> And yes, __qualifier__((context(...))) probably might
> be a replacement for __context__, to reduce the number of primitives.

No, see above.  __context__ works as a statement, not as a way to modify
a type.

That said, "calling this function requires this context or changes the
context" and "accessing this variable requires this context or changes
the context" may represent different types of attributes.  I don't know.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 18:50:56 +0000
Message-ID: <1183661456.2604.43.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-05 at 17:43 +0100, Al Viro wrote:
> On Thu, Jul 05, 2007 at 08:36:35AM -0700, Josh Triplett wrote:
> > Wow.  Insane.  So these all declare the same type:
> > __attribute__((foo)) T *v;
> > T __attribute__((foo)) *v;
> > T *__attribute__((foo)) v;
> > ?  Specifically, they point to a foo-T, for convenient shooting?
> 
> They all give you foo-pointer-to-T.  
> 	T (__attribute__((foo)) *v);
> would give pointer-to-foo-T.

Doesn't that do exactly what we want, then?  If we say
T __attribute__((noderef)) *v;
, we want a noderef-pointer-to-T, not a pointer-to-noderef-T.  noderef
should modify a pointer.

> > context also represents a qualifier; the position of the qualifier should
> > determine things like whether you want to enforce the context when you access
> > a pointer or dereference a pointer.
> 
> Since __context__ is (sparse-only) keyword, we are not constrained by
> anything anyway.

No, I mean __attribute__((context(...))), which means something
different.  __context__() works as a statement statement changing the
context.  __attribute__((context(...))) works as an attribute modifying
a type to say that it requires a given context, and that
accessing/calling it changes the context.  Somewhat of an odd
distinction, but sparse currently works that way.

> > > Frankly, I would rather add a new primitive (__qualifier__) mirroring the
> > > __attribute__, but acting like real qualifiers do.  And switched the
> > > noderef et.al. to it.
> > 
> > Something like that sounds vaguely reasonable.  It should allow the same set
> > of attributes, and just change what they apply to.  To use your example,
> > T __qualifier__((foo)) *v;
> > and
> > T (__attribute__((foo)) *v);
> > would mean the same thing.
> 
> Yup, except that it would not accept storage-class-like attributes (e.g.
> always_inline).

So, to clarify what you mean by storage-class-like: __qualifier__ would
accept all attributes that modify a *type* rather than a *declaration*.

> And yes, __qualifier__((context(...))) probably might
> be a replacement for __context__, to reduce the number of primitives.

No, see above.  __context__ works as a statement, not as a way to modify
a type.

That said, "calling this function requires this context or changes the
context" and "accessing this variable requires this context or changes
the context" may represent different types of attributes.  I don't know.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 18:56:15 +0000
Message-ID: <alpine.LFD.0.98.0707051144560.9434 () woody ! linux-foundation ! org>
--------------------


On Thu, 5 Jul 2007, Al Viro wrote:
> 
> I.e. you get per-attribute rules (fsckloads of them) and no way to tell
> what do the attributes apply to unless you know the rules for given attribute.

It basically boils down to "__attribute__((x))" is basically a _single_ 
keyword.

There is no "__attribute__" on its own, or "x" on its own. The two do not 
make sense separately. 

And that's the _accurate_ way of seeing attribute. Seeing it as a "type 
attribute" is actively wrong, and that kind of thinking just leads you 
down the wrong path (not just with qualifiers, but with __attribute__ as 
done by gcc itself, where it's used for more than type attributes).

> I just don't like having no relationship between the syntax and operations
> on types, that's all.

You seem to think that "__attribute__" has some meaning of its own.

Not true. 

Gcc already has things like

	__attribute__((extended))

which acts not on types or variables, but on expressions and statements.

And it does not *make*sense* to think of that as just another "attribute". 
It is *not* about the same kind of attributes as the type attributes at 
all! If you think it is, you're thinking about it wrong. It's a totally 
different kind of thing.

So instead of thinking about "__attribute__" as having some stand-alone 
semantic meaning (it does *not*), think of it the way I do: the 
"__attribute__" part is just an escape sequence into an extended parsing 
thing, and "__attribute__((extended))" is really just another way to give 
a way to say the _extended_ thing, without having to make it a keyword, 
with all that implies.

In other words, I think your "__qualifier__" idea is fundamentally wrong, 
because it misses the real _point_ of "attribute()". 

The real point of "__attribute__" is that it's mis-named. But that does 
not mean that it should be named "__qualifier__", because that just 
re-inforces the initial mistake. Instead, it probably _should_ have been 
named "__extension__", or something like that (or maybe "__escape__" or 
"__magic_keyword__").

That ends up explaining all the gcc semantics. Because "__attribute__" as 
gcc uses it really isn't about attributes per se, it's about extensions to 
C semantics, in a way that doesn't violate the C rules that much, and in a 
way that doesn't introduce infinite numbers of special identifiers in the 
same global name-space.

So yes, I'd be ok with renaming it, and I don't think "__attribute__" is a 
wonderful name, but we named it for gcc compatibility, so we're kind of 
stuck with the name. But that doesn't mean that we have to be stuck with 
thinking about it as a "symbol node attribute", because it really isn't, 
and has never been that, even in gcc.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 19:13:59 +0000
Message-ID: <20070705191358.GQ21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 11:50:56AM -0700, Josh Triplett wrote:
> On Thu, 2007-07-05 at 17:43 +0100, Al Viro wrote:
> > On Thu, Jul 05, 2007 at 08:36:35AM -0700, Josh Triplett wrote:
> > > Wow.  Insane.  So these all declare the same type:
> > > __attribute__((foo)) T *v;
> > > T __attribute__((foo)) *v;
> > > T *__attribute__((foo)) v;
> > > ?  Specifically, they point to a foo-T, for convenient shooting?
> > 
> > They all give you foo-pointer-to-T.  
> > 	T (__attribute__((foo)) *v);
> > would give pointer-to-foo-T.
> 
> Doesn't that do exactly what we want, then?  If we say
> T __attribute__((noderef)) *v;
> , we want a noderef-pointer-to-T, not a pointer-to-noderef-T.  noderef
> should modify a pointer.

No.  int __user *v is pointer to noderef,address_space(1) int.  Same
as int const *v is pointer to const int.  Noderef is a property of
object being pointed to, _not_ the pointer itself.

And yes, I know that we store it ->modifiers of SYM_PTR - that saves us
a SYM_NODE we'd have to insert otherwise.  Same as with the rest of
qualifiers.

The same goes for address_space.  The same goes for const and volatile.

If you have struct foo {int x;}; struct foo __user *p; then &p->x will
be &((*p).x), i.e. &(<__user struct foo>.x), i.e. &(<__user int>), i.e.
int __user *.  __user is not a property of pointer; it couldn't work if
it would be.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 19:13:59 +0000
Message-ID: <20070705191358.GQ21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 11:50:56AM -0700, Josh Triplett wrote:
> On Thu, 2007-07-05 at 17:43 +0100, Al Viro wrote:
> > On Thu, Jul 05, 2007 at 08:36:35AM -0700, Josh Triplett wrote:
> > > Wow.  Insane.  So these all declare the same type:
> > > __attribute__((foo)) T *v;
> > > T __attribute__((foo)) *v;
> > > T *__attribute__((foo)) v;
> > > ?  Specifically, they point to a foo-T, for convenient shooting?
> > 
> > They all give you foo-pointer-to-T.  
> > 	T (__attribute__((foo)) *v);
> > would give pointer-to-foo-T.
> 
> Doesn't that do exactly what we want, then?  If we say
> T __attribute__((noderef)) *v;
> , we want a noderef-pointer-to-T, not a pointer-to-noderef-T.  noderef
> should modify a pointer.

No.  int __user *v is pointer to noderef,address_space(1) int.  Same
as int const *v is pointer to const int.  Noderef is a property of
object being pointed to, _not_ the pointer itself.

And yes, I know that we store it ->modifiers of SYM_PTR - that saves us
a SYM_NODE we'd have to insert otherwise.  Same as with the rest of
qualifiers.

The same goes for address_space.  The same goes for const and volatile.

If you have struct foo {int x;}; struct foo __user *p; then &p->x will
be &((*p).x), i.e. &(<__user struct foo>.x), i.e. &(<__user int>), i.e.
int __user *.  __user is not a property of pointer; it couldn't work if
it would be.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 19:35:53 +0000
Message-ID: <1183664153.2604.63.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-05 at 20:13 +0100, Al Viro wrote:
> On Thu, Jul 05, 2007 at 11:50:56AM -0700, Josh Triplett wrote:
> > On Thu, 2007-07-05 at 17:43 +0100, Al Viro wrote:
> > > On Thu, Jul 05, 2007 at 08:36:35AM -0700, Josh Triplett wrote:
> > > > Wow.  Insane.  So these all declare the same type:
> > > > __attribute__((foo)) T *v;
> > > > T __attribute__((foo)) *v;
> > > > T *__attribute__((foo)) v;
> > > > ?  Specifically, they point to a foo-T, for convenient shooting?
> > > 
> > > They all give you foo-pointer-to-T.  
> > > 	T (__attribute__((foo)) *v);
> > > would give pointer-to-foo-T.
> > 
> > Doesn't that do exactly what we want, then?  If we say
> > T __attribute__((noderef)) *v;
> > , we want a noderef-pointer-to-T, not a pointer-to-noderef-T.  noderef
> > should modify a pointer.
> 
> No.  int __user *v is pointer to noderef,address_space(1) int.  Same
> as int const *v is pointer to const int.  Noderef is a property of
> object being pointed to, _not_ the pointer itself.

OK, that seems inconsistent with what you said before.  You said that 
T __attribute__((foo)) *v;
gives you a foo-pointer-to-T.  So shouldn't
int __attribute__((noderef)) *v;
give you a noderef-pointer-to-int?

> And yes, I know that we store it ->modifiers of SYM_PTR - that saves us
> a SYM_NODE we'd have to insert otherwise.  Same as with the rest of
> qualifiers.
> 
> The same goes for address_space.  The same goes for const and volatile.
> 
> If you have struct foo {int x;}; struct foo __user *p; then &p->x will
> be &((*p).x), i.e. &(<__user struct foo>.x), i.e. &(<__user int>), i.e.
> int __user *.  __user is not a property of pointer; it couldn't work if
> it would be.

OK, that makes sense; address_space describes the actual storage of the
thing pointed to, not the pointer.  It *could* describe the pointer, if
you had a pointer that resided in user address space, but that occurs
less often, and would use a different syntax.

However, noderef seems like a property of a pointer, hence why I
proposed the example I did.  A warning should occur when you do
*(<noderef T *>v) to get a T, not when you do *(<* noderef T>v) to get a
noderef T.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 20:08:39 +0000
Message-ID: <20070705200839.GR21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 12:35:53PM -0700, Josh Triplett wrote:
> OK, that seems inconsistent with what you said before.  You said that 
> T __attribute__((foo)) *v;

... in gcc.

> gives you a foo-pointer-to-T.  So shouldn't
> int __attribute__((noderef)) *v;
> give you a noderef-pointer-to-int?

... if we followed gcc rules. 

> However, noderef seems like a property of a pointer, hence why I
> proposed the example I did.  A warning should occur when you do
> *(<noderef T *>v) to get a T, not when you do *(<* noderef T>v) to get a
> noderef T.

Nope.  __noderef is a property of object being pointed to.  Again,
consider &p->x.  It should not be int *.  And it should not be
an error.  We want it to be int __noderef *.

Semantics of noderef is simple: you should not access or modify the value
of noderef object.  That's all.  int __noderef * is an absolutely normal
pointer to such object.  Think of __noderef as of a stronger variant of const.

It's just another qualifier, with usual qualifier syntax.  It can occur
in the same places where const can, giving the same kind of effect on type.
See 6.7.5.1 and 6.7.3 for general stuff on qualifiers...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 20:08:39 +0000
Message-ID: <20070705200839.GR21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 12:35:53PM -0700, Josh Triplett wrote:
> OK, that seems inconsistent with what you said before.  You said that 
> T __attribute__((foo)) *v;

... in gcc.

> gives you a foo-pointer-to-T.  So shouldn't
> int __attribute__((noderef)) *v;
> give you a noderef-pointer-to-int?

... if we followed gcc rules. 

> However, noderef seems like a property of a pointer, hence why I
> proposed the example I did.  A warning should occur when you do
> *(<noderef T *>v) to get a T, not when you do *(<* noderef T>v) to get a
> noderef T.

Nope.  __noderef is a property of object being pointed to.  Again,
consider &p->x.  It should not be int *.  And it should not be
an error.  We want it to be int __noderef *.

Semantics of noderef is simple: you should not access or modify the value
of noderef object.  That's all.  int __noderef * is an absolutely normal
pointer to such object.  Think of __noderef as of a stronger variant of const.

It's just another qualifier, with usual qualifier syntax.  It can occur
in the same places where const can, giving the same kind of effect on type.
See 6.7.5.1 and 6.7.3 for general stuff on qualifiers...
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 20:56:35 +0000
Message-ID: <alpine.LFD.0.98.0707051341290.9434 () woody ! linux-foundation ! org>
--------------------


On Thu, 5 Jul 2007, Al Viro wrote:
> 
> Nope.  __noderef is a property of object being pointed to.  Again,
> consider &p->x.  It should not be int *.  And it should not be
> an error.  We want it to be int __noderef *.

A more interesting example to some degree is what happens to

	&*p

when p is a pointer to noderef.

The end result should be a pointer to noderef again, and it should be 
legal to do (ie we didn't actually _really_ derefence it).

It's interesting for a couple of reasons, specifically it shows how sparse 
ends up carrying around the "node" information in two _different_ places: 
either in the SYM_NODE (or SYM_ARRAY) that actually "is" the object, _or_ 
in the SYM_PTR thing that describes a pointer to the object.

So this behaviour can be directly seen in the sparse type logic when we 
convert to/from a pointer:

 - it shows how the "pointerness" is secondary, even if we actually 
   do end up putting some object flags in the SYM_PTR node.

   So the "*" needs to move the noderef from the SYM_PTR node into the 
   resulting SYM_NODE node. This is what "MOD_PTRINHERIT" is all about 
   (see its use in "create_pointer": it peels off the SYM_NODE'ness, but 
   inserts the node modifiers into the SYM_PTR).

 - the address-of operator does the reverse, and we merge the information 
   from the pointer into the resulting node (everything but the storage 
   modifiers, to be exact, see "merge_type()").

So I think Josh may be confused by the fact that the SYM_PTR node actually 
contains information about the thing the pointer _points_ to, and then the 
SYM_NODE for the pointer object actually contains information about the 
pointer itself!

So some of the flags about the object are really in the SYM_PTR node, but 
despite that, they are really about the *object*, not about the pointer, 
and that shows most clearly exactly when converting an object to a pointer 
("&" - evaluate_addressof() and crreate_pointer()) and when dereferencing 
a pointer to an object ("*" - evaluate_dereference() and merge_type())

Is it slightly complex? Yes. It's a bit strange that the SYM_PTR doesn't 
contain the information about the *pointer*, and the real information 
about an object is actually "one removed" from the type infromation, but 
it's a rather direct result of how sparse parses and maintains the type 
information.

Maybe it could have been done differently. I dunno. But it does end up 
being how the C types parse most naturally, I think.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 20:56:35 +0000
Message-ID: <alpine.LFD.0.98.0707051341290.9434 () woody ! linux-foundation ! org>
--------------------


On Thu, 5 Jul 2007, Al Viro wrote:
> 
> Nope.  __noderef is a property of object being pointed to.  Again,
> consider &p->x.  It should not be int *.  And it should not be
> an error.  We want it to be int __noderef *.

A more interesting example to some degree is what happens to

	&*p

when p is a pointer to noderef.

The end result should be a pointer to noderef again, and it should be 
legal to do (ie we didn't actually _really_ derefence it).

It's interesting for a couple of reasons, specifically it shows how sparse 
ends up carrying around the "node" information in two _different_ places: 
either in the SYM_NODE (or SYM_ARRAY) that actually "is" the object, _or_ 
in the SYM_PTR thing that describes a pointer to the object.

So this behaviour can be directly seen in the sparse type logic when we 
convert to/from a pointer:

 - it shows how the "pointerness" is secondary, even if we actually 
   do end up putting some object flags in the SYM_PTR node.

   So the "*" needs to move the noderef from the SYM_PTR node into the 
   resulting SYM_NODE node. This is what "MOD_PTRINHERIT" is all about 
   (see its use in "create_pointer": it peels off the SYM_NODE'ness, but 
   inserts the node modifiers into the SYM_PTR).

 - the address-of operator does the reverse, and we merge the information 
   from the pointer into the resulting node (everything but the storage 
   modifiers, to be exact, see "merge_type()").

So I think Josh may be confused by the fact that the SYM_PTR node actually 
contains information about the thing the pointer _points_ to, and then the 
SYM_NODE for the pointer object actually contains information about the 
pointer itself!

So some of the flags about the object are really in the SYM_PTR node, but 
despite that, they are really about the *object*, not about the pointer, 
and that shows most clearly exactly when converting an object to a pointer 
("&" - evaluate_addressof() and crreate_pointer()) and when dereferencing 
a pointer to an object ("*" - evaluate_dereference() and merge_type())

Is it slightly complex? Yes. It's a bit strange that the SYM_PTR doesn't 
contain the information about the *pointer*, and the real information 
about an object is actually "one removed" from the type infromation, but 
it's a rather direct result of how sparse parses and maintains the type 
information.

Maybe it could have been done differently. I dunno. But it does end up 
being how the C types parse most naturally, I think.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 21:09:16 +0000
Message-ID: <1183669756.2604.117.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-05 at 21:08 +0100, Al Viro wrote:
> On Thu, Jul 05, 2007 at 12:35:53PM -0700, Josh Triplett wrote:
> > OK, that seems inconsistent with what you said before.  You said that 
> > T __attribute__((foo)) *v;
> 
> ... in gcc.
> 
> > gives you a foo-pointer-to-T.  So shouldn't
> > int __attribute__((noderef)) *v;
> > give you a noderef-pointer-to-int?
> 
> ... if we followed gcc rules. 

Ah, OK.

> > However, noderef seems like a property of a pointer, hence why I
> > proposed the example I did.  A warning should occur when you do
> > *(<noderef T *>v) to get a T, not when you do *(<* noderef T>v) to get a
> > noderef T.
> 
> Nope.  __noderef is a property of object being pointed to.  Again,
> consider &p->x.  It should not be int *.  And it should not be
> an error.  We want it to be int __noderef *.
> 
> Semantics of noderef is simple: you should not access or modify the value
> of noderef object.  That's all.  int __noderef * is an absolutely normal
> pointer to such object.  Think of __noderef as of a stronger variant of const.

OK.  It hadn't occurred to me that "noderef int x" could have any useful
meaning on its own, but you've given a clear explanation of why it does,
which makes it meaningful to apply noderef to the pointer target rather
than the pointer.  Thanks.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Thu, 05 Jul 2007 21:09:16 +0000
Message-ID: <1183669756.2604.117.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-05 at 21:08 +0100, Al Viro wrote:
> On Thu, Jul 05, 2007 at 12:35:53PM -0700, Josh Triplett wrote:
> > OK, that seems inconsistent with what you said before.  You said that 
> > T __attribute__((foo)) *v;
> 
> ... in gcc.
> 
> > gives you a foo-pointer-to-T.  So shouldn't
> > int __attribute__((noderef)) *v;
> > give you a noderef-pointer-to-int?
> 
> ... if we followed gcc rules. 

Ah, OK.

> > However, noderef seems like a property of a pointer, hence why I
> > proposed the example I did.  A warning should occur when you do
> > *(<noderef T *>v) to get a T, not when you do *(<* noderef T>v) to get a
> > noderef T.
> 
> Nope.  __noderef is a property of object being pointed to.  Again,
> consider &p->x.  It should not be int *.  And it should not be
> an error.  We want it to be int __noderef *.
> 
> Semantics of noderef is simple: you should not access or modify the value
> of noderef object.  That's all.  int __noderef * is an absolutely normal
> pointer to such object.  Think of __noderef as of a stronger variant of const.

OK.  It hadn't occurred to me that "noderef int x" could have any useful
meaning on its own, but you've given a clear explanation of why it does,
which makes it meaningful to apply noderef to the pointer target rather
than the pointer.  Thanks.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-kernel
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Fri, 06 Jul 2007 03:26:04 +0000
Message-ID: <20070706032604.GU21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 01:56:35PM -0700, Linus Torvalds wrote:

> Is it slightly complex? Yes. It's a bit strange that the SYM_PTR doesn't 
> contain the information about the *pointer*, and the real information 
> about an object is actually "one removed" from the type infromation, but 
> it's a rather direct result of how sparse parses and maintains the type 
> information.

Not only that, but it's a fairly natural if you look at that as
lazy expression in type space...  Fortunately, we do have referential
transparency there, unlike e.g. in expression graphs handling.

BTW, one really ugly thing about __attribute__((mode(...))) is that
int *A;
int B;
typeof (A) __attribute__((mode(__pointer__))) p;
typeof (B) __attribute__((mode(__pointer__))) q;

gives int *p and intptr_t q resp.  IOW, we can't eliminate the damn thing
in parser unless we are willing to deal with typeof() in there, and I'd
rather not.

It really looks like we have to delay at least some of those suckers
until examine_... time.  IOW, new kind of SYM_... nodes.

FWIW, I'm going to kill off direct messing with symbol->type et.al.
in evaluate.c and trim that stuff down to few primitives provided
by symbol.c; classify_type() is one such thing, but it really ought
to be lazy - i.e. do not assume that type is already examined,
do just enough type expression evaluation to get the derivation
type and be done with that; we probably want to get more degrees
of ->examined.  Plus "find all qualifiers", "find all qualifiers of
pointed-to", type-related part of degenerate(), type_difference()
(after lifting !Wtypesign stuff into compatible_assignment_types())
and "calculate compatible type".  All lazy...  We probably want
to go for more grades of ->examined, while we are at it.

After that we'll have much more straightforward logics in evaluate.c
and free hands for fixing the handling of attributes, etc.

Eventually I'd like to kill off MOD_CHAR/MOD_SHORT/MOD_LONG/MOD_LONGLONG
as ->modifiers bits and separate the use of struct ctype for declaration
parser state from that in struct symbol; we *are* tight on bits
there, we have a bunch of MOD_... that make sense only in parser
state (MOD_BITWISE is the same kind of thing, BTW) and parser context
might need to grow, which is obviously not nice for struct symbol.
Very few places really care about MOD_SPECIFIER outside of parser and
they could be dealt with in saner way...

BTW, what the hell is struct symbol ->value and what's SYM_MEMBER is
supposed to be used for?  AFAICS, nothing ever sets them these days
and SYM_MEMBER appears to have never been used in the entire history
of sparse...

I'm documenting the existing type system (i.e. uses of struct symbol,
etc.); I think I've got most of the picture by now, will post when
it's done.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Fri, 06 Jul 2007 03:26:04 +0000
Message-ID: <20070706032604.GU21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 01:56:35PM -0700, Linus Torvalds wrote:

> Is it slightly complex? Yes. It's a bit strange that the SYM_PTR doesn't 
> contain the information about the *pointer*, and the real information 
> about an object is actually "one removed" from the type infromation, but 
> it's a rather direct result of how sparse parses and maintains the type 
> information.

Not only that, but it's a fairly natural if you look at that as
lazy expression in type space...  Fortunately, we do have referential
transparency there, unlike e.g. in expression graphs handling.

BTW, one really ugly thing about __attribute__((mode(...))) is that
int *A;
int B;
typeof (A) __attribute__((mode(__pointer__))) p;
typeof (B) __attribute__((mode(__pointer__))) q;

gives int *p and intptr_t q resp.  IOW, we can't eliminate the damn thing
in parser unless we are willing to deal with typeof() in there, and I'd
rather not.

It really looks like we have to delay at least some of those suckers
until examine_... time.  IOW, new kind of SYM_... nodes.

FWIW, I'm going to kill off direct messing with symbol->type et.al.
in evaluate.c and trim that stuff down to few primitives provided
by symbol.c; classify_type() is one such thing, but it really ought
to be lazy - i.e. do not assume that type is already examined,
do just enough type expression evaluation to get the derivation
type and be done with that; we probably want to get more degrees
of ->examined.  Plus "find all qualifiers", "find all qualifiers of
pointed-to", type-related part of degenerate(), type_difference()
(after lifting !Wtypesign stuff into compatible_assignment_types())
and "calculate compatible type".  All lazy...  We probably want
to go for more grades of ->examined, while we are at it.

After that we'll have much more straightforward logics in evaluate.c
and free hands for fixing the handling of attributes, etc.

Eventually I'd like to kill off MOD_CHAR/MOD_SHORT/MOD_LONG/MOD_LONGLONG
as ->modifiers bits and separate the use of struct ctype for declaration
parser state from that in struct symbol; we *are* tight on bits
there, we have a bunch of MOD_... that make sense only in parser
state (MOD_BITWISE is the same kind of thing, BTW) and parser context
might need to grow, which is obviously not nice for struct symbol.
Very few places really care about MOD_SPECIFIER outside of parser and
they could be dealt with in saner way...

BTW, what the hell is struct symbol ->value and what's SYM_MEMBER is
supposed to be used for?  AFAICS, nothing ever sets them these days
and SYM_MEMBER appears to have never been used in the entire history
of sparse...

I'm documenting the existing type system (i.e. uses of struct symbol,
etc.); I think I've got most of the picture by now, will post when
it's done.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Fri, 06 Jul 2007 07:48:03 +0000
Message-ID: <20070706074803.GV21478 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 05, 2007 at 11:50:56AM -0700, Josh Triplett wrote:
 
> No, I mean __attribute__((context(...))), which means something
> different.  __context__() works as a statement statement changing the
> context.  __attribute__((context(...))) works as an attribute modifying
> a type to say that it requires a given context, and that
> accessing/calling it changes the context.  Somewhat of an odd
> distinction, but sparse currently works that way.
 
That's actually not a qualifier from the syntax point of view...
It makes sense *only* on function types - we simply ignore it
on anything else.  And C syntax doesn't allow qualifiers on functions -
not without creative use of typedef (which gets you in nasal demon
country - undefined behaviour).

What syntax do we want?  Note that the *only* possible way to get
it kinda-sorta like qualifiers is by
typedef int F(void);
F __attribute__((context(x,0,1))) f;
with no way to actually define the sucker, since for function
definition you can't use such tricks.  IOW, no matter what we do,
it won't look like standard C.

If anything, it ought to be an analog of noreturn/pure/fastcall/etc. - same
kind of property should use the same syntax; no need to add confusion.
Unfortunately, gcc does _not_ give a sane way to declare pointers to
such beasts.  To quote gcc info:

|                        ...  At present, such attribute specifiers apply
|to the declared object or function, but in future they may attach to the
|outermost adjacent declarator.  In simple cases there is no difference,
|but, for example, in
|
|     void (****f)(void) __attribute__((noreturn));
|
|at present the `noreturn' attribute applies to `f', which causes a
|warning since `f' is not a function, but in future it may apply to the
|function `****f'.  The precise semantics of what attributes in such
|cases will apply to are not yet specified.

	Frankly, my preference would be to have that kind of attributes
follow ( parameter-type-list ), ( identifier-list ) or ( ) in productions
for direct-declarator.  That would allow uses like

int foo(void) ATTR;             // function with attribute
int foo(void) ATTR {....}       // function with attribute
int (*foo)(void) ATTR;          // pointer to function with attribute
int (*bar(int) ATTR)(void) {...}// function with attribute returning pointer to
                                // normal function
int (*bar(int))(void) ATTR {...}// normal function returning a pointer to
                                // function with attribute
AFAICS, that doesn't lead to any problems with parser - no deep lookahead,
etc.  Allowing them in declaration-specifiers, OTOH...

	Do we want to allow
__attribute__((context(x,0,1))) int foo(void) {....}
int (__attribute__((context(x,0,1))) *foo)(void);
and similar uses?  I'd rather prohibit that...

	Another fun question: how do we compare these suckers?  Suppose
you have foo() and bar() having some kind of contexts.  What contexts
do we put into n ? foo : bar and when do we allow that?  Similar question
for p = foo; where p is a pointer to function, etc.  I realize that the
first argument of __attribute__((context(...,...,...))) is currently ignored
and pretty much hopeless as defined, but...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Fri, 06 Jul 2007 08:33:30 +0000
Message-ID: <468DFE5A.8080602 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigA50EFB377E16BFEA303768DB
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> On Thu, Jul 05, 2007 at 11:50:56AM -0700, Josh Triplett wrote:
> =20
>> No, I mean __attribute__((context(...))), which means something
>> different.  __context__() works as a statement statement changing the
>> context.  __attribute__((context(...))) works as an attribute modifyin=
g
>> a type to say that it requires a given context, and that
>> accessing/calling it changes the context.  Somewhat of an odd
>> distinction, but sparse currently works that way.
> =20
> That's actually not a qualifier from the syntax point of view...
> It makes sense *only* on function types - we simply ignore it
> on anything else.

For now, yes.  I intend to make use of the context attribute on arbitrary=

pointers or data.  For example, I want to specify that you must hold a gi=
ven
lock in order to access a structure field, and enforce that context when =
you
access the field.

> And C syntax doesn't allow qualifiers on functions -
> not without creative use of typedef (which gets you in nasal demon
> country - undefined behaviour).

For functions, yes.  In the case of pointers or data, I do want the conte=
xt
attribute to work like a qualifier: you might want to apply it to a point=
er,
or to the pointer target, or to a structure field, or an entire structure=
=2E..

[snip several function-specific issues]

> 	Another fun question: how do we compare these suckers?  Suppose
> you have foo() and bar() having some kind of contexts.  What contexts
> do we put into n ? foo : bar and when do we allow that?

If foo requires context x, and bar requires context y, then (n ? foo : ba=
r)();
*might* require context x and *might* require context y.  Similar problem=
s
arise for issues like conditional locking.  So far, the solution involves=

saying "if it doesn't look obvious to the compiler, it doesn't look obvio=
us to
the coder, so rewrite it such that it does"; that works fairly well for L=
inux,
though long-term I'd like to handle increasingly complex cases.  In some
cases, specifying more attributes helps; for instance, you can remove
ambiguity by specifying context attributes on function pointers.

> Similar question for p =3D foo; where p is a pointer to function, etc.

See above.  Eventually we might have advanced dataflow analysis deriving
attributes for us; for now, function pointers will need explicit contexts=
=2E

> I realize that the first argument of __attribute__((context(...,...,...=
)))
> is currently ignored and pretty much hopeless as defined, but...

Currently ignored, yes.  I certainly hope that providing a context expres=
sion
proves sufficient to specify a context.  Yes, problems arise if you need =
to do
complex unification of context expressions, but I *think* that we can han=
dle
the simpler cases first and the complicated cases as needed.  If you have=
 any
suggestions that might improve context checking, I'd love to discuss them=
 with
you.

- Josh Triplett


--------------enigA50EFB377E16BFEA303768DB
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGjf5aGJuZRtD+evsRAsrNAJ9m/4XYglhBYNNV0htlKltUy9JIlQCgs76N
6RtOBYMYLiLZ+42OitSW5To=
=PADc
-----END PGP SIGNATURE-----

--------------enigA50EFB377E16BFEA303768DB--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Fri, 06 Jul 2007 15:52:45 +0000
Message-ID: <20070706155245.GX21478 () ftp ! linux ! org ! uk>
--------------------
On Fri, Jul 06, 2007 at 01:33:30AM -0700, Josh Triplett wrote:
> Al Viro wrote:
> > On Thu, Jul 05, 2007 at 11:50:56AM -0700, Josh Triplett wrote:
> >  
> >> No, I mean __attribute__((context(...))), which means something
> >> different.  __context__() works as a statement statement changing the
> >> context.  __attribute__((context(...))) works as an attribute modifying
> >> a type to say that it requires a given context, and that
> >> accessing/calling it changes the context.  Somewhat of an odd
> >> distinction, but sparse currently works that way.
> >  
> > That's actually not a qualifier from the syntax point of view...
> > It makes sense *only* on function types - we simply ignore it
> > on anything else.
> 
> For now, yes.  I intend to make use of the context attribute on arbitrary
> pointers or data.  For example, I want to specify that you must hold a given
> lock in order to access a structure field, and enforce that context when you
> access the field.

What kind of annotations on functions do you expect to need for that
enforcing?
 
> For functions, yes.  In the case of pointers or data, I do want the context
> attribute to work like a qualifier: you might want to apply it to a pointer,
> or to the pointer target, or to a structure field, or an entire structure...

I'm not sure I like the idea of having the same qualifier mean very
different things on functions and data objects ["gets locks" vs. "needs
locks"]...
 
> If foo requires context x, and bar requires context y, then (n ? foo : bar)();
> *might* require context x and *might* require context y.

... the hell?  On functions it's not about "requires", it's about "changes".

> See above.  Eventually we might have advanced dataflow analysis deriving
> attributes for us; for now, function pointers will need explicit contexts.

How do you compare two contexts for equality?

> Currently ignored, yes.  I certainly hope that providing a context expression
> proves sufficient to specify a context.  Yes, problems arise if you need to do
> complex unification of context expressions, but I *think* that we can handle
> the simpler cases first and the complicated cases as needed.  If you have any
> suggestions that might improve context checking, I'd love to discuss them with
> you.

What do you call simpler cases?  A constant being a context expression?
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Fri, 06 Jul 2007 19:29:27 +0000
Message-ID: <1183750167.2613.36.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2007-07-06 at 16:52 +0100, Al Viro wrote:
> On Fri, Jul 06, 2007 at 01:33:30AM -0700, Josh Triplett wrote:
> > Al Viro wrote:
> > > On Thu, Jul 05, 2007 at 11:50:56AM -0700, Josh Triplett wrote:
> > >> No, I mean __attribute__((context(...))), which means something
> > >> different.  __context__() works as a statement statement changing the
> > >> context.  __attribute__((context(...))) works as an attribute modifying
> > >> a type to say that it requires a given context, and that
> > >> accessing/calling it changes the context.  Somewhat of an odd
> > >> distinction, but sparse currently works that way.
> > >  
> > > That's actually not a qualifier from the syntax point of view...
> > > It makes sense *only* on function types - we simply ignore it
> > > on anything else.
> > 
> > For now, yes.  I intend to make use of the context attribute on arbitrary
> > pointers or data.  For example, I want to specify that you must hold a given
> > lock in order to access a structure field, and enforce that context when you
> > access the field.
> 
> What kind of annotations on functions do you expect to need for that
> enforcing?

The existing context annotations should suffice for many cases.
compiler.h will need new wrappers for cases like requiring a lock.  For
a very simple example:

compiler.h:
#define require_context(x) __attribute__((context(x,1,1))

magic_device.c:
DEFINE_SPINLOCK(device_lock);
struct the_device the_device require_context(device_lock);

void f(void)
{
	spin_lock(device_lock);
	frobulate(the_device.guts);
	spin_unlock(device_lock);
}

When Sparse sees an access to the_device.guts, it will check for a
device_lock context >= 1.

The same thing will work for functions which require the context:

void g(void) require_context(device_lock)
{
	glork(the_device.fnord);
}

In this case, Sparse will enforce the context on calls to g(), and then
assume the context inside g().

For special cases like preemption and RCU, which lack a lock expression
but still represent a distinct lock, how about:

compiler.h:
#ifdef __CHECKER__
#define fake_context(x) extern const int x
#else
#define fake_context(x)
#endif

preempt.h:
fake_context(preemption);
#define preempt_disable() ... __acquire(preemption)
#define preempt_enable() ... __release(preemption)
#define might_sleep_attr() ... /* something */

In this case, the "at least this value" semantic for the precondition
makes it hard to write the assertion we want.  I *almost* wonder if we
should just change this into something more like real code:

__compile_time_assert__(__context(preemption) == 0)
__something_else__(__context(preemption)++)
__something_else__(__context(preemption)--)

That would make the hard cases much easier, and the easy cases equally
hard. :)

Issues will also arise for other cases, such as referring to another
lock in the same structure, or a lock elsewhere in the parameter list of
a function.  I think this could work fairly easily by introducing some
additional scopes for looking up symbols in a context expression.

> > For functions, yes.  In the case of pointers or data, I do want the context
> > attribute to work like a qualifier: you might want to apply it to a pointer,
> > or to the pointer target, or to a structure field, or an entire structure...
> 
> I'm not sure I like the idea of having the same qualifier mean very
> different things on functions and data objects ["gets locks" vs. "needs
> locks"]...
> 
> > If foo requires context x, and bar requires context y, then (n ? foo : bar)();
> > *might* require context x and *might* require context y.
> 
> ... the hell?  On functions it's not about "requires", it's about "changes".

Both:
__attribute__((context(x,0,1))) means "you need not hold x before, but
you will hold one more of x after".
__attribute__((context(x,1,0))) means "you must already hold x, and you
will no longer hold x after".
__attribute__((context(x,1,1))) means "you must already hold x, and you
will continue to hold x".

Sparse does not yet enforce all of these conditions.  Also, the "at
least this value" semantic for the precondition makes it hard to use
contexts for things like "this blocks" and "may not block in this
context".  As I said, it needs work.  However, I intend for it to mean
*exactly* the same thing on functions or variables, except that in the
former case it means "when called", and in the latter case it means
"when accessed".  In both cases, you can require a context and change
the context.

> > See above.  Eventually we might have advanced dataflow analysis deriving
> > attributes for us; for now, function pointers will need explicit contexts.
> 
> How do you compare two contexts for equality?

A fine question.  In the simple cases, "same symbol" will work fairly
well; certainly better than the current "always equal" comparison. :)
Ideally, however, you want "refers to the same value".  Alias analysis
could do a fairly good job of that, I think.

> > Currently ignored, yes.  I certainly hope that providing a context expression
> > proves sufficient to specify a context.  Yes, problems arise if you need to do
> > complex unification of context expressions, but I *think* that we can handle
> > the simpler cases first and the complicated cases as needed.  If you have any
> > suggestions that might improve context checking, I'd love to discuss them with
> > you.
> 
> What do you call simpler cases?  A constant being a context expression?

That definitely qualifies, but I imagined "simple" as up to and
including bare symbols with no operators.

See above regarding more complicated cases.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Sat, 07 Jul 2007 02:11:52 +0000
Message-ID: <20070707021152.GA21668 () ftp ! linux ! org ! uk>
--------------------
On Fri, Jul 06, 2007 at 12:29:27PM -0700, Josh Triplett wrote:
> The existing context annotations should suffice for many cases.
> compiler.h will need new wrappers for cases like requiring a lock.  For
> a very simple example:
> 
> compiler.h:
> #define require_context(x) __attribute__((context(x,1,1))
> 
> magic_device.c:
> DEFINE_SPINLOCK(device_lock);
> struct the_device the_device require_context(device_lock);

*ugh*

More ugly syntax...

> compiler.h:
> #ifdef __CHECKER__
> #define fake_context(x) extern const int x
> #else
> #define fake_context(x)
> #endif
> 
> preempt.h:
> fake_context(preemption);
> #define preempt_disable() ... __acquire(preemption)
> #define preempt_enable() ... __release(preemption)
> #define might_sleep_attr() ... /* something */
 
Still not expressive enough...  Consider e.g.

struct foo *lookup_foo(char *s); // lookup by name, return NULL if failed
				 // or pointer to struct foo with ->mutex
				 // held.  Caller should unlock.

It's legitimate, not particulary rare and AFAICS can't be expressed.

> Sparse does not yet enforce all of these conditions.  Also, the "at
> least this value" semantic for the precondition makes it hard to use
> contexts for things like "this blocks" and "may not block in this
> context".  As I said, it needs work.  However, I intend for it to mean
> *exactly* the same thing on functions or variables, except that in the
> former case it means "when called", and in the latter case it means
> "when accessed".  In both cases, you can require a context and change
> the context.

_What_ change in case of objects?

> A fine question.  In the simple cases, "same symbol" will work fairly
> well; certainly better than the current "always equal" comparison. :)
> Ideally, however, you want "refers to the same value".  Alias analysis
> could do a fairly good job of that, I think.

Not particulary useful, since for
	int foo(struct bar *p) __acquires(&p->lock);
	int bar(struct bar *p) __acquires(&p->lock);
you will get false negative in (n ? foo : bar) *and* it will persist even if
you go for
	int foo(struct bar *p) __acquires(p);
	int bar(struct bar *p) __acquires(p);
since you will have different symbols (same name, different scopes) here.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Sat, 07 Jul 2007 02:28:03 +0000
Message-ID: <1183775283.2613.168.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Sat, 2007-07-07 at 03:11 +0100, Al Viro wrote:
> On Fri, Jul 06, 2007 at 12:29:27PM -0700, Josh Triplett wrote:
> > The existing context annotations should suffice for many cases.
> > compiler.h will need new wrappers for cases like requiring a lock.  For
> > a very simple example:
> > 
> > compiler.h:
> > #define require_context(x) __attribute__((context(x,1,1))
> > 
> > magic_device.c:
> > DEFINE_SPINLOCK(device_lock);
> > struct the_device the_device require_context(device_lock);
> 
> *ugh*
> 
> More ugly syntax...

Open to suggestions; just basing it on the existing syntax defined by
compiler.h.

> > compiler.h:
> > #ifdef __CHECKER__
> > #define fake_context(x) extern const int x
> > #else
> > #define fake_context(x)
> > #endif
> > 
> > preempt.h:
> > fake_context(preemption);
> > #define preempt_disable() ... __acquire(preemption)
> > #define preempt_enable() ... __release(preemption)
> > #define might_sleep_attr() ... /* something */
> 
> Still not expressive enough...  Consider e.g.
> 
> struct foo *lookup_foo(char *s); // lookup by name, return NULL if failed
> 				 // or pointer to struct foo with ->mutex
> 				 // held.  Caller should unlock.
> 
> It's legitimate, not particulary rare and AFAICS can't be expressed.

Very true; conditional locking doesn't work so well with Sparse.
Currently, you *can* express it with a bit of a hack; see the cond_lock
macro, used for spin_trylock.  Sparse will then correctly handle this:
if(spin_trylock(...)) {
	...
	spin_unlock(...);
}

That got me thinking about the idea I suggested of just using
compile-time asserts and increments/decrements.  I dunno whether that
has any hope of working or not, but it would certainly give you
expressiveness.  You might need some magic syntax to say "the return
value".

> > Sparse does not yet enforce all of these conditions.  Also, the "at
> > least this value" semantic for the precondition makes it hard to use
> > contexts for things like "this blocks" and "may not block in this
> > context".  As I said, it needs work.  However, I intend for it to mean
> > *exactly* the same thing on functions or variables, except that in the
> > former case it means "when called", and in the latter case it means
> > "when accessed".  In both cases, you can require a context and change
> > the context.
> 
> _What_ change in case of objects?

I don't immediately see the use case for changing the context when you
access an object.  I can vaguely imagine some case like "if you change
this field, you must later call this function", or vice versa.

> > A fine question.  In the simple cases, "same symbol" will work fairly
> > well; certainly better than the current "always equal" comparison. :)
> > Ideally, however, you want "refers to the same value".  Alias analysis
> > could do a fairly good job of that, I think.
> 
> Not particulary useful, since for
> 	int foo(struct bar *p) __acquires(&p->lock);
> 	int bar(struct bar *p) __acquires(&p->lock);
> you will get false negative in (n ? foo : bar) *and* it will persist even if
> you go for
> 	int foo(struct bar *p) __acquires(p);
> 	int bar(struct bar *p) __acquires(p);
> since you will have different symbols (same name, different scopes) here.

Not necessarily.  You need to substitute the actual arguments for the
formal arguments when you look at the context expression.  Given
sufficiently good analysis, you could figure this case out; in
(n ? foo : bar)(p), both cases want to acquire &p->lock, or p in the
latter case.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Sat, 07 Jul 2007 02:30:57 +0000
Message-ID: <20070707023057.GB21668 () ftp ! linux ! org ! uk>
--------------------
On Sat, Jul 07, 2007 at 03:11:52AM +0100, Al Viro wrote:
> Still not expressive enough...  Consider e.g.
> 
> struct foo *lookup_foo(char *s); // lookup by name, return NULL if failed
> 				 // or pointer to struct foo with ->mutex
> 				 // held.  Caller should unlock.
> 
> It's legitimate, not particulary rare and AFAICS can't be expressed.

Another fun problem: consider a structure with pair of methods - ->start()
and ->stop().  The only locking requirement is that calls are inverse wrt
locking (i.e. foo->start();foo->stop(); leaves the locking state unchanged).
Different instances may deal with different locks, different _kinds_ of
locks or no locks at all.  How do you annotate ->start() and ->stop()?

We have just such a beast in the kernel - seq_operations (see fs/seq_file.c
for code that calls these methods and grep for seq_operations to see users).
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Sat, 07 Jul 2007 02:55:03 +0000
Message-ID: <1183776903.2613.197.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Sat, 2007-07-07 at 03:30 +0100, Al Viro wrote:
> On Sat, Jul 07, 2007 at 03:11:52AM +0100, Al Viro wrote:
> > Still not expressive enough...  Consider e.g.
> > 
> > struct foo *lookup_foo(char *s); // lookup by name, return NULL if failed
> > 				 // or pointer to struct foo with ->mutex
> > 				 // held.  Caller should unlock.
> > 
> > It's legitimate, not particulary rare and AFAICS can't be expressed.
> 
> Another fun problem: consider a structure with pair of methods - ->start()
> and ->stop().  The only locking requirement is that calls are inverse wrt
> locking (i.e. foo->start();foo->stop(); leaves the locking state unchanged).
> Different instances may deal with different locks, different _kinds_ of
> locks or no locks at all.  How do you annotate ->start() and ->stop()?
>
> We have just such a beast in the kernel - seq_operations (see fs/seq_file.c
> for code that calls these methods and grep for seq_operations to see users).

Yeah, I've used seq_file.  I'd suggest treating this as two separate
problems:
     1. How do you express the semantic of function pointers that
        represent a paired context in a seq_file?  For this case, I
        suggest just saying that start and stop acquire and release the
        seq_operations structure itself, or some similar dummy context
        specific to the instance of the structure.  Any caller that
        calls the function pointers in a seq_operations struct would
        then need to properly pair them.  If you wrote a function that
        took a seq_operations and didn't properly manage the context
        with paired calls, Sparse would warn about it, just as if the
        contexts applied to local function pointers or pointers from any
        other struct.
     2. Does Sparse need to enforce any requirement that the functions
        you assign to the function pointers actually acquire and release
        some context?  If so, you'd have to do some kind of unification.
        However, I don't think Sparse needs to enforce that requirement.
        Either your particular seq_operations need pairing for some
        context reason, in which case you can specify a particular
        context on them, or they don't need pairing for some reason, in
        which case you don't need to specify a context on them.
        Meanwhile, any actual callers of those functions using the
        function pointers will get warnings as appropriate based on the
        solution to problem 1.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Sun, 08 Jul 2007 21:50:15 +0000
Message-ID: <20070708215015.GN21668 () ftp ! linux ! org ! uk>
--------------------
On Fri, Jul 06, 2007 at 07:28:03PM -0700, Josh Triplett wrote:
> > 	int foo(struct bar *p) __acquires(p);
> > 	int bar(struct bar *p) __acquires(p);
> > since you will have different symbols (same name, different scopes) here.
> 
> Not necessarily.  You need to substitute the actual arguments for the
> formal arguments when you look at the context expression.  Given
> sufficiently good analysis, you could figure this case out; in
> (n ? foo : bar)(p), both cases want to acquire &p->lock, or p in the
> latter case.

baz = n ? foo : bar;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Sun, 08 Jul 2007 21:52:17 +0000
Message-ID: <20070708215217.GO21668 () ftp ! linux ! org ! uk>
--------------------
On Fri, Jul 06, 2007 at 07:55:03PM -0700, Josh Triplett wrote:
>      2. Does Sparse need to enforce any requirement that the functions
>         you assign to the function pointers actually acquire and release
>         some context?  If so, you'd have to do some kind of unification.
>         However, I don't think Sparse needs to enforce that requirement.
>         Either your particular seq_operations need pairing for some
>         context reason, in which case you can specify a particular
>         context on them, or they don't need pairing for some reason, in
>         which case you don't need to specify a context on them.
>         Meanwhile, any actual callers of those functions using the
>         function pointers will get warnings as appropriate based on the
>         solution to problem 1.

That won't work.  You'll have ->show() calling the stuff that assumes
that locks are already grabbed by ->start() => warnings galore.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] bloody mess with __attribute__() syntax
Date: Fri, 13 Jul 2007 09:04:22 +0000
Message-ID: <20070713090422.GA23203 () ftp ! linux ! org ! uk>
--------------------
[l-k removed from Cc]

	FWIW, I have several problems with that TR.  All of them have the
same root cause: arrays vs. qualifiers.

1) unless 6.7.3[8] is explicitly changed, qualifiers apply to element type
of array; when you manage to apply qualifier to an array (possible via
creative use of typedef), it still applies to the element (i.e. trickles
down until it hits non-array).

2) consequently, changes to 6.2.5 are broken.  They require _any_ array
type T to be in generic address space; of course, this is a nonsense.

3) in changes to 6.7.2.1 (saying that struct or union member types should
not carry an address space qualifier) we have a variant of the same problem -
arrays escape that requirement, but they clearly should not.

4) in places where some attempt to dance around that problem is made,
results are clumsy and actually still wrong.  A typical example:

"The pointer into enclosed address space is first converted to a pointer
to the same reference type except with any address-space qualifier
removed and any address-space qualifer of the other pointer's reference
type added".

We clearly should not replace such qualifiers deep in type derivation.


Now, AFAICS a clean solution would be to leave 6.7.3[8] alone, but
* define 'type T belongs to address space A' by
	if T1 is a type and _A is an address-space qualifier, then 
the type '_A-qualified T1' belongs to corresponding address space.
	if a type T is an array of T1, T belongs to address space A
if and only if T1 belongs to address space A.
* in 6.7.2.1 change the requirement to 'the type of a member shall
not belong to non-generic address space' or equivalent.
* in places dealing with conversion of pointers between address spaces
for comparisons, etc., speak of address-space qualifiers on the outermost
non-array in derivation of reference type.  Might be worth a definition
('counterpart of type T in enclosing address space').

Note that this is very easy to get wrong; similar questions about
const and volatile lead to a subtle difference between C and C++ type
systems and in that particular case C++ one is actually saner.

In C you can assign a pointer to array of const int to object of type
pointer to void, exactly because the constraints refer to qualifiers
on reference type and do not take into account the case when qualifier
sits on array element.  C++ prohibits that - you can assign to const void *,
but not to void *.  I.e. the 'constness' is inherited by arrays there
as far as this kind of implicit conversions is concerned.

For address spaces we definitely want the same kind of semantics;
array elements obviously belong to the same address space as the
array itself.  I have not checked the C++98 (or drafts of C++0x), but
if the construction they are using to describe that part of C++
semantics of const and volatile is not too atrocious it might make
sense to borrow it...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] infinite loop in free_preprocessor_line() ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: [RFC] infinite loop in free_preprocessor_line()
Date: Sat, 26 May 2007 00:24:38 +0000
Message-ID: <20070526002437.GB5786 () martell ! zuzino ! mipt ! ru>
--------------------
While running if-2.c from gcc testsuite sparse goes into infinite loop in
free_preprocessor_line().

Trimmed down test-case is

	#if 1
	#if

(two lines)

--- a/pre-process.c
+++ b/pre-process.c
@@ -763,11 +763,11 @@ out:
 
 static int free_preprocessor_line(struct token *token)
 {
-	do {
+	while (token_type(token) != TOKEN_EOF) {
 		struct token *free = token;
 		token = token->next;
 		__free_token(free);
-	} while (token_type(token) != TOKEN_EOF);
+	};
 	return 1;
 }
 

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] infinite loop in free_preprocessor_line()
Date: Sat, 02 Jun 2007 21:55:26 +0000
Message-ID: <20070602215526.GA5710 () martell ! zuzino ! mipt ! ru>
--------------------
On Sat, May 26, 2007 at 05:35:26PM -0700, Josh Triplett wrote:
> Alexey Dobriyan wrote:
> > While running if-2.c from gcc testsuite sparse goes into infinite loop in
> > free_preprocessor_line().
> > 
> > Trimmed down test-case is
> > 
> > 	#if 1
> > 	#if
> > 
> > (two lines)
> 
> Thanks for this fix.
> 
> Can I get a Signed-off-by for this patch, please?

Sorry, lost email in noise

Patch is Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [RFC] infinite loop in free_preprocessor_line()
Date: Sun, 03 Jun 2007 22:27:35 +0000
Message-ID: <46634057.1000709 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig5506ECADCEDC12B95F62FAD1
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Alexey Dobriyan wrote:
> On Sat, May 26, 2007 at 05:35:26PM -0700, Josh Triplett wrote:
>> Alexey Dobriyan wrote:
>>> While running if-2.c from gcc testsuite sparse goes into infinite loo=
p in
>>> free_preprocessor_line().
>>>
>>> Trimmed down test-case is
>>>
>>> 	#if 1
>>> 	#if
>>>
>>> (two lines)
>> Thanks for this fix.
>>
>> Can I get a Signed-off-by for this patch, please?
>=20
> Sorry, lost email in noise
>=20
> Patch is Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

Thanks.  Applied, along with the test case.

- Josh Triplett



--------------enig5506ECADCEDC12B95F62FAD1
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGY0BXGJuZRtD+evsRAvdeAJwPiPSFhUF56iQRS3ZmAjKxsFNYCgCfSU6Q
9Bc5emBn74cmW6ZP0g85rWM=
=1MKF
-----END PGP SIGNATURE-----

--------------enig5506ECADCEDC12B95F62FAD1--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] show_type() format problems ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [RFC] show_type() format problems
Date: Thu, 12 Jul 2007 09:14:53 +0000
Message-ID: <20070712091453.GY21668 () ftp ! linux ! org ! uk>
--------------------
int __attribute__((address_space(1))) **p;
int *__attribute__((address_space(1))) *q;

void foo(void)
{
        p = q;
}

quite predictably gives a warning.  The contents of that warning,
however, is somewhat unfortunate:

test.c:6:4: warning: incorrect type in assignment (different address spaces)
test.c:6:4:    expected int **[addressable] [toplevel] p<asn:1>
test.c:6:4:    got int **[addressable] [toplevel] q<asn:1>

The reason is simple: we put <asn:...> *after* the identifier.  *, of
course, goes before it.  So when we have a pointer to pointer, there's
no way to tell which of them had brought address_space.

Do we want to keep the current behaviour?  It's obviously not nice -
especially when we get warnings like one above.

We also can't tell pointer to array from array of pointers.  Does anybody
object against making it look more like C declarations?  I.e. put <asn:...>
together with modifiers and at least add parens when needed?

Believe me, I do realize that it will change build logs.  I probably have
more of those than just about anybody else (several years worth of sparse
runs on the kernel for couple dozens of targets).  And yes, it'll hurt.
I don't see a better alternative, though; we might be able to tweak the
output to deal with ambiguities and still keep the same results for (very)
simple cases, but if we are tweaking it at all we really ought to go for
something recognizable for normal C programmers...

Comments?
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [RFC] show_type() format problems
Date: Thu, 12 Jul 2007 16:22:10 +0000
Message-ID: <1184257330.3000.7.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-07-12 at 10:14 +0100, Al Viro wrote:
> int __attribute__((address_space(1))) **p;
> int *__attribute__((address_space(1))) *q;
> 
> void foo(void)
> {
>         p = q;
> }
> 
> quite predictably gives a warning.  The contents of that warning,
> however, is somewhat unfortunate:
> 
> test.c:6:4: warning: incorrect type in assignment (different address spaces)
> test.c:6:4:    expected int **[addressable] [toplevel] p<asn:1>
> test.c:6:4:    got int **[addressable] [toplevel] q<asn:1>
> 
> The reason is simple: we put <asn:...> *after* the identifier.  *, of
> course, goes before it.  So when we have a pointer to pointer, there's
> no way to tell which of them had brought address_space.
> 
> Do we want to keep the current behaviour?  It's obviously not nice -
> especially when we get warnings like one above.
>
> We also can't tell pointer to array from array of pointers.  Does anybody
> object against making it look more like C declarations?  I.e. put <asn:...>
> together with modifiers and at least add parens when needed?

Please do go ahead and change the output.  I'd love for show_type to
output something as close to a parsable C type as possible.

> Believe me, I do realize that it will change build logs.  I probably have
> more of those than just about anybody else (several years worth of sparse
> runs on the kernel for couple dozens of targets).  And yes, it'll hurt.
> I don't see a better alternative, though; we might be able to tweak the
> output to deal with ambiguities and still keep the same results for (very)
> simple cases, but if we are tweaking it at all we really ought to go for
> something recognizable for normal C programmers...

I do understand the concern, but I think that consistency of build logs
matters far less than sanity for the users of *current* Sparse.  Let's
no go making purely gratuitous output changes, but here we have a good
reason to change the output.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [RFC] show_type() format problems
Date: Thu, 12 Jul 2007 18:25:08 +0000
Message-ID: <20070712182508.GZ21668 () ftp ! linux ! org ! uk>
--------------------
On Thu, Jul 12, 2007 at 09:22:10AM -0700, Josh Triplett wrote:
> Please do go ahead and change the output.  I'd love for show_type to
> output something as close to a parsable C type as possible.

How does below sound?  At least it makes output unambiguous and much
closer to normal C syntax.  We could do better (e.g. lift the things
like "extern", etc. in front of everything else), but that's a separate
problem...

diff --git a/show-parse.c b/show-parse.c
index aae8b74..9a1f796 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -226,11 +226,28 @@ const char *builtin_ctypename(struct ctype *ctype)
 	return NULL;
 }
 
-static void do_show_type(struct symbol *sym, struct type_name *name)
+static void do_show_type(struct symbol *sym, struct type_name *name,
+			 unsigned long mod, int as, int was_ptr)
 {
-	int modlen;
-	const char *mod;
 	const char *typename;
+	int is_ptr = was_ptr;
+
+	if (!sym || (sym->type != SYM_NODE && sym->type != SYM_ARRAY &&
+		     sym->type != SYM_BITFIELD)) {
+		const char *s;
+		size_t len;
+
+		if (as)
+			prepend(name, "<asn:%d>", as);
+
+		s = modifier_string(mod);
+		len = strlen(s);
+		name->start -= len;    
+		memcpy(name->start, s, len);  
+		mod = 0;
+		as = 0;
+	}
+
 	if (!sym)
 		return;
 
@@ -246,9 +263,14 @@ static void do_show_type(struct symbol *sym, struct type_name *name)
 	switch (sym->type) {
 	case SYM_PTR:
 		prepend(name, "*");
+		mod = sym->ctype.modifiers;
+		as = sym->ctype.as;
+		is_ptr = 1;
 		break;
 	case SYM_FN:
-		prepend(name, "( ");
+		if (was_ptr)
+			prepend(name, "( ");
+		is_ptr = 0;
 		break;
 	case SYM_STRUCT:
 		prepend(name, "struct %s ", show_ident(sym->ident));
@@ -264,9 +286,13 @@ static void do_show_type(struct symbol *sym, struct type_name *name)
 
 	case SYM_NODE:
 		append(name, "%s", show_ident(sym->ident));
+		mod |= sym->ctype.modifiers;
+		as |= sym->ctype.as;
 		break;
 
 	case SYM_BITFIELD:
+		mod |= sym->ctype.modifiers;
+		as |= sym->ctype.as;
 		append(name, ":%d", sym->bit_size);
 		break;
 
@@ -275,6 +301,11 @@ static void do_show_type(struct symbol *sym, struct type_name *name)
 		break;
 
 	case SYM_ARRAY:
+		mod |= sym->ctype.modifiers;
+		as |= sym->ctype.as;
+		if (was_ptr)
+			prepend(name, "( ");
+		is_ptr = 0;
 		break;
 
 	case SYM_RESTRICT:
@@ -288,26 +319,21 @@ static void do_show_type(struct symbol *sym, struct type_name *name)
 		return;
 	}
 
-	mod = modifier_string(sym->ctype.modifiers);
-	modlen = strlen(mod);
-	name->start -= modlen;    
-	memcpy(name->start, mod, modlen);  
-
-	do_show_type(sym->ctype.base_type, name);
-
-	/* Postpend */
-	if (sym->ctype.as)
-		append(name, "<asn:%d>", sym->ctype.as);
+	do_show_type(sym->ctype.base_type, name, mod, as, is_ptr);
 
 	switch (sym->type) {
 	case SYM_PTR:
-		return; 
+		return;
 
 	case SYM_FN:
-		append(name, " )( ... )");
+		if (was_ptr)
+			append(name, " )");
+		append(name, "( ... )");
 		return;
 
 	case SYM_ARRAY:
+		if (was_ptr)
+			append(name, " )");
 		append(name, "[%lld]", get_expression_value(sym->array_size));
 		return;
 
@@ -330,7 +356,7 @@ void show_type(struct symbol *sym)
 	struct type_name name;
 
 	name.start = name.end = array+100;
-	do_show_type(sym, &name);
+	do_show_type(sym, &name, 0, 0, 0);
 	*name.end = 0;
 	printf("%s", name.start);
 }
@@ -341,7 +367,7 @@ const char *show_typename(struct symbol *sym)
 	struct type_name name;
 
 	name.start = name.end = array+100;
-	do_show_type(sym, &name);
+	do_show_type(sym, &name, 0, 0, 0);
 	*name.end = 0;
 	return name.start;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [Security] Signed divides vs shifts (Re: /dev/urandom uses uninit ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [Security] Signed divides vs shifts (Re: /dev/urandom uses uninit
Date: Mon, 17 Dec 2007 18:28:38 +0000
Message-ID: <alpine.LFD.0.9999.0712171009570.21557 () woody ! linux-foundation ! org>
--------------------


On Mon, 17 Dec 2007, Eric Dumazet wrote:
> 
> while 
> 
> long *mid(long *a, long *b)
> {
> 	return ((a - b) / 2u + a);
> }

This is exactly what I'm talking about. That "2u" is TOTALLY POINTLESS. 
It's an "unsigned int", but since (a-b) will be of type ptrdiff_t, and is 
*wider* on a 64-bit architecture (it's the same as "long" on x86-64), then 
the 2u will just be converted to "long", and be signed again! 

So you thought that you did an unsigned divide, but you did no such thing. 

If you change the "2u" to a "2ul", it works again, and you get

	mid:
	        movq    %rdi, %rax
	        subq    %rsi, %rax
	        sarq    %rax
	        andq    $-8, %rax
	        addq    %rdi, %rax
	        ret

which is the code you wanted. But quite frankly, you could just have 
written it with a shift to start with, and avoided the subtle type issue, 
although gcc then generates

        movq    %rdi, %rax
        subq    %rsi, %rax
        sarq    $4, %rax
        leaq    (%rdi,%rax,8), %rax
        ret

instead. Of course, this all *does* still have subtle sign issues, because 
the "a-b" part implies a signed divide in itself, which is why you see 
that "sarq" in he first place (rather than a "shrq"). 

Signed divides are hard. The "a-b" pointer subtraction is actually cheaper 
than a general signed divide by sizeof, since the compiler can then assume 
that the two pointers are mutually aligned, which is why gcc can generate 
just a single "sarq" instead of having to do an extra "add negative bit" 
thing to get the rounding right.

[ So Al, when you said that

	(a-b)

  is equivalent to

	((char *)a-(char *)b)/4

  for a "int *" a and b, you're right in the sense that the *result* is 
  the same, but the code generation likely isn't. The "a-b" thing can (and 
  does) allow the compiler to avoid the whole "align up for signed 
  numbers" thing, and the difference in code generation is clear:

	subq    %rsi, %rdi
	sarq    $2, %rdi

  vs

	subq    %rsi, %rdi
	leaq    3(%rdi), %rax
	testq   %rdi, %rdi
	cmovs   %rax, %rdi
	sarq    $2, %rdi

  exactly because the first case *knows* that the low two bits have to be 
  zero, and thus there is no rounding issue. ]

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [Security] Signed divides vs shifts (Re: /dev/urandom uses uninit bytes, leaks user data) ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [Security] Signed divides vs shifts (Re: /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 19:08:10 +0000
Message-ID: <20071217190810.GE8181 () ftp ! linux ! org ! uk>
--------------------
On Mon, Dec 17, 2007 at 10:28:38AM -0800, Linus Torvalds wrote:
> [ So Al, when you said that
> 
> 	(a-b)
> 
>   is equivalent to
> 
> 	((char *)a-(char *)b)/4
> 
>   for a "int *" a and b, you're right in the sense that the *result* is 
>   the same, but the code generation likely isn't. The "a-b" thing can (and 

Sure.  And yes, I very much do prefer code that uses C as it ought to be
used and doesn't play games with casts from hell, etc.  For a lot of reasons,
both correctness- and efficiency-related.

We _do_ have such turds.  In spades.  And such places are potential timebombs,
since well-intentioned idiotic patch ("I've read in lecture notes that sizeof
is better than explicit constant, so replacement surely can only improve the
things and the best part is, I don't need to understand what I'm doing")
turns an ugly FPOS into equally ugly FPOS that silently doesn't work ;-/

[sorry about the rant, I'm about 3/4 through the drivers/net colonoscopy,
with >300Kb of patches and a pile of assorted bugs so far - and then there's
drivers/scsi to deal with.  Endianness stuff, mostly...]
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-kernel
Subject: Re: [Security] Signed divides vs shifts (Re: /dev/urandom uses uninit bytes, leaks user data)
Date: Mon, 17 Dec 2007 19:08:10 +0000
Message-ID: <20071217190810.GE8181 () ftp ! linux ! org ! uk>
--------------------
On Mon, Dec 17, 2007 at 10:28:38AM -0800, Linus Torvalds wrote:
> [ So Al, when you said that
> 
> 	(a-b)
> 
>   is equivalent to
> 
> 	((char *)a-(char *)b)/4
> 
>   for a "int *" a and b, you're right in the sense that the *result* is 
>   the same, but the code generation likely isn't. The "a-b" thing can (and 

Sure.  And yes, I very much do prefer code that uses C as it ought to be
used and doesn't play games with casts from hell, etc.  For a lot of reasons,
both correctness- and efficiency-related.

We _do_ have such turds.  In spades.  And such places are potential timebombs,
since well-intentioned idiotic patch ("I've read in lecture notes that sizeof
is better than explicit constant, so replacement surely can only improve the
things and the best part is, I don't need to understand what I'm doing")
turns an ugly FPOS into equally ugly FPOS that silently doesn't work ;-/

[sorry about the rant, I'm about 3/4 through the drivers/net colonoscopy,
with >300Kb of patches and a pile of assorted bugs so far - and then there's
drivers/scsi to deal with.  Endianness stuff, mostly...]
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [git pull] misc fixes ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [git pull] misc fixes
Date: Sat, 28 Jul 2007 23:57:41 +0000
Message-ID: <20070728235741.GB21089 () ftp ! linux ! org ! uk>
--------------------
Please pull from git://git.kernel.org/pub/scm/linux/kernel/git/viro/sparse.git
local15.

A bunch of bug fixes + more typechecking sanitized.

Contents:
      add __builtin_strlen()
      no such thing as array of functions
      new helper: unfoul()
      handling of typeof in evaluate_member_dereference()
      file and global scopes are the same for purposes of struct redefining
      ...,array should degenerate
      sanitize evaluate_ptr_add(), start checking for pointers to functions
      fix evaluate_compare()
      sanitize evaluate_postop()
      saner -Wtypesign
      braino in conditional_expression()
Diffstat:
 evaluate.c                    |  170 +++++++++++++++++++++++-----------------
 expression.c                  |    2 +-
 lib.c                         |    1 +
 parse.c                       |    2 +-
 scope.c                       |   10 +++
 scope.h                       |    1 +
 validation/comma.c            |   10 +++
 validation/member_of_typeof.c |   14 ++++
 validation/outer-scope.c      |   19 +++++
 9 files changed, 155 insertions(+), 74 deletions(-)
 create mode 100644 validation/comma.c
 create mode 100644 validation/member_of_typeof.c
 create mode 100644 validation/outer-scope.c

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [git pull] misc fixes
Date: Sun, 29 Jul 2007 08:11:26 +0000
Message-ID: <46AC4BAE.3070300 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig83808B4E9EDA274659E1CF4D
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> Please pull from git://git.kernel.org/pub/scm/linux/kernel/git/viro/spa=
rse.git
> local15.
>=20
> A bunch of bug fixes + more typechecking sanitized.
>=20
> Contents:
>       add __builtin_strlen()
>       no such thing as array of functions
>       new helper: unfoul()
>       handling of typeof in evaluate_member_dereference()
>       file and global scopes are the same for purposes of struct redefi=
ning
>       ...,array should degenerate
>       sanitize evaluate_ptr_add(), start checking for pointers to funct=
ions
>       fix evaluate_compare()
>       sanitize evaluate_postop()
>       saner -Wtypesign
>       braino in conditional_expression()

Merged; thanks!

- Josh Triplett



--------------enig83808B4E9EDA274659E1CF4D
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGrEuvGJuZRtD+evsRApbZAJ4/qqB8Qq2tW3MIRY+nkV3CN/dqVgCfTr4B
KpvmIstTJj+PsKiVwUYOm3w=
=YkOD
-----END PGP SIGNATURE-----

--------------enig83808B4E9EDA274659E1CF4D--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [patch] Mac OS X specs for cgcc ===

From: "Marko Kreen" <markokr () gmail ! com>
To: linux-sparse
Subject: [patch] Mac OS X specs for cgcc
Date: Thu, 20 Dec 2007 13:50:00 +0000
Message-ID: <e51f66da0712200550l620838f5h727b711a3abb85a () mail ! gmail ! com>
--------------------
------=_Part_19169_27260244.1198158600525
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

This patch adds MacOS X (darwin) specific defines to cgcc.

Only suspicios aspect about it is that OSX system include
files expect either __LITTLE_ENDIAN__ or __BIG_ENDIAN__ to be
defined to show endianess.  I added a arch switch to darwin
section to pick this up to avoid polluting general i86 and x86_64
sections.  (note: i dont speak perl and i dont have any ppc32/64
to test it on).

Somwhat simpler would be to put __LITTLE_ENDIAN__ unconditionally
to darwin section on the grounds that ppc is unsupported anyway,
but if the support appears it may be better to have the switch
available already.

-- 
marko

------=_Part_19169_27260244.1198158600525
Content-Type: application/octet-stream; name=cgcc.macos.specs.diff
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fafcnrc3
Content-Disposition: attachment; filename=cgcc.macos.specs.diff

ZGlmZiAtLWdpdCBhL2NnY2MgYi9jZ2NjCmluZGV4IDlhY2Y0OTguLmQ0YzUwZjggMTAwNzU1Ci0t
LSBhL2NnY2MKKysrIGIvY2djYwpAQCAtMjE0LDYgKzIxNCwxNCBAQCBzdWIgYWRkX3NwZWNzIHsK
ICAgICB9IGVsc2lmICgkc3BlYyBlcSAnbGludXgnKSB7CiAJcmV0dXJuICZhZGRfc3BlY3MgKCd1
bml4JykgLgogCSAgICAnIC1EX19saW51eF9fPTEgLURfX2xpbnV4PTEgLURsaW51eD1saW51eCc7
CisgICAgfSBlbHNpZiAoJHNwZWMgZXEgJ2RhcndpbicpIHsKKwlteSAkb3N4ID0gJyAtRF9fTUFD
SF9fPTEgLURfX0FQUExFX189MSAtRF9fQVBQTEVfQ0NfXz0xIC1EX19EWU5BTUlDX189MSc7CisJ
bXkgJGFyY2ggPSBgdW5hbWUgLW1gOworCWlmICgkYXJjaCA9fiAvcHBjL2kpIHsKKwkgIHJldHVy
biAoJG9zeCAuICIgLURfX0JJR19FTkRJQU5fXyIpOworCX0gZWxzZSB7CisJICByZXR1cm4gKCRv
c3ggLiAiIC1EX19MSVRUTEVfRU5ESUFOX18iKTsKKwl9CiAgICAgfSBlbHNpZiAoJHNwZWMgZXEg
J3VuaXgnKSB7CiAJcmV0dXJuICcgLUR1bml4PTEgLURfX3VuaXg9MSAtRF9fdW5peF9fPTEnOwog
ICAgIH0gZWxzaWYgKCAkc3BlYyA9fiAvXmN5Z3dpbi8pIHsK
------=_Part_19169_27260244.1198158600525--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [patch] improve flag handling ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [patch] improve flag handling
Date: Sat, 04 Aug 2007 20:50:45 +0000
Message-ID: <46B4E6A5.4080706 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig34404BCDFF09EB127344C3F5
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Mike Frysinger wrote:
> the attached patch tweaks the makefile so that it respects CFLAGS set
> in the environment and it makes sure to link the shared libsparse with
> $(LDFLAGS)
> -mike

Applied, thanks!

- Josh Triplett


--------------enig34404BCDFF09EB127344C3F5
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGtOalGJuZRtD+evsRAp/ZAKCrX6YZswmZSgsKwxEZvers2in0OwCfcvFU
CBHYpj1b/cpP9zfE5E7E1U0=
=bDkg
-----END PGP SIGNATURE-----

--------------enig34404BCDFF09EB127344C3F5--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [patches] misc fixes ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [patches] misc fixes
Date: Sun, 27 May 2007 00:44:27 +0000
Message-ID: <4658D46B.7050406 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig80F14A3D315782430958AED9
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> Just starting to reduce the queue; there'll be more later.  In this
> pile:
> 	handle __alignof as equivalent of __alignof__
> 	saner reporting of overlaps in initializers
> 	check for whitespace before object-like macro body
> 	fix alignment for _Bool
> 	fix interaction of typeof with bitwise types
> 	better recovery from bad operations on bitwise

All six patches applied.  Thanks!

- Josh Triplett



--------------enig80F14A3D315782430958AED9
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGWNRrGJuZRtD+evsRAlfCAKCtNvteHYdNQqUD/E9Va94KxICoqQCfXua4
qju64+TYO3O0SwHz+k46g2I=
=ZYer
-----END PGP SIGNATURE-----

--------------enig80F14A3D315782430958AED9--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [patches] more type cleanups and fixes ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [patches] more type cleanups and fixes
Date: Fri, 13 Jul 2007 17:44:17 +0000
Message-ID: <E1I9PBh-0000DU-3s () ZenIV ! linux ! org ! uk>
--------------------
	Getting the handling of qualifiers/address spaces right on the
pointer operations, type_difference sanitized and taken closer to sanity
(in particular, kernel ARRAY_SIZE() works now), SYM_BASENAME and SYM_TYPEOF
handling sanitized.

	That takes us about halfway to getting rid of very brittle
dependencies between evaluate.c and type-handling details in symbol.c.

	The series can be pulled from branch type_difference2 in
git://git.kernel.org/pub/scm/linux/kernel/git/viro/sparse.git/
individual patches follow in next postings...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [patches] more type cleanups and fixes
Date: Sat, 14 Jul 2007 20:33:54 +0000
Message-ID: <46993332.8070103 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig07B3D2CDF8FA9288040AA83D
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> 	Getting the handling of qualifiers/address spaces right on the
> pointer operations, type_difference sanitized and taken closer to sanit=
y
> (in particular, kernel ARRAY_SIZE() works now), SYM_BASENAME and SYM_TY=
PEOF
> handling sanitized.
>=20
> 	That takes us about halfway to getting rid of very brittle
> dependencies between evaluate.c and type-handling details in symbol.c.
>=20
> 	The series can be pulled from branch type_difference2 in
> git://git.kernel.org/pub/scm/linux/kernel/git/viro/sparse.git/
> individual patches follow in next postings...

Patch series applied and pushed, together with the fixes noted in the thr=
ead:

* Fix test suite breakage caused by patch 1.
* Expand commit message in patch 3.
* Fix type_difference prototype in patch 7.

Thanks!

- Josh Triplett



--------------enig07B3D2CDF8FA9288040AA83D
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGmTMyGJuZRtD+evsRApQxAJ46iW5zi6+1HoMLnTOi2INWbBScSwCfdSO/
vHfTc5TA4X2mrD1kRXbutQo=
=0ub0
-----END PGP SIGNATURE-----

--------------enig07B3D2CDF8FA9288040AA83D--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: __attribute__ annotations and struct types ===

From: Daniel Drake <ddrake () brontes3d ! com>
To: linux-sparse
Subject: __attribute__ annotations and struct types
Date: Wed, 14 Feb 2007 20:01:54 +0000
Message-ID: <1171483314.14504.9.camel () systems03 ! mmm ! com>
--------------------
gcc-4.1.1 accepts this as valid code:

struct __attribute__((__aligned__(16))) foo {
    int a;
};

sparse doesn't like it:

	test.c:7:8: error: Trying to use reserved word '__attribute__' 
	as identifier

I'm not sure if this is a bug that people are interested in solving, as
the more common form works in both gcc and sparse:

struct foo {
    int a;
} __attribute__((__aligned__(16)));

Thanks,
-- 
Daniel Drake
Brontes Technologies, A 3M Company

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: annotating semaphores. ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: annotating semaphores.
Date: Thu, 13 Dec 2007 22:00:09 +0000
Message-ID: <70318cbf0712131400j607b8f55mbb64e9b8cb7f8682 () mail ! gmail ! com>
--------------------
On Dec 12, 2007 12:00 PM, Dave Jones <davej@redhat.com> wrote:
> Today I came across a bug in the kernel cpufreq code where
> we were missing a bunch of up_write() calls in error paths
> of a function.
>
> I've been trying to get sparse's context checking to pick up
> on the errors and failing.  The kernel patch below is what I have
> so far, but it seems to report no output whatsoever.
> What am I missing ?

Can you share the example buggy cpufreq code that miss the up_write() calls?

> --- a/lib/rwsem-spinlock.c
> +++ b/lib/rwsem-spinlock.c
> @@ -162,6 +162,7 @@ void fastcall __sched __down_read(struct rw_semaphore *sem)
>
>         tsk->state = TASK_RUNNING;
>   out:
> +       __acquire(sem);
>         ;
>  }

That is not needed. Because the __down_read is not an inline function. The
extern void FASTCALL(__down_read(struct rw_semaphore *sem)) __acquires(sem);
declare should be good enough.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: annotating semaphores.
Date: Thu, 13 Dec 2007 22:05:42 +0000
Message-ID: <20071213220542.GA32252 () redhat ! com>
--------------------
On Thu, Dec 13, 2007 at 02:00:09PM -0800, Christopher Li wrote:
 > On Dec 12, 2007 12:00 PM, Dave Jones <davej@redhat.com> wrote:
 > > Today I came across a bug in the kernel cpufreq code where
 > > we were missing a bunch of up_write() calls in error paths
 > > of a function.
 > >
 > > I've been trying to get sparse's context checking to pick up
 > > on the errors and failing.  The kernel patch below is what I have
 > > so far, but it seems to report no output whatsoever.
 > > What am I missing ?
 > 
 > Can you share the example buggy cpufreq code that miss the up_write() calls?

Sure. In drivers/cpufreq/cpufreq.c cpufreq_add_dev() is missing several
calls to unlock_policy_rwsem_write() in the error paths.

The patch below should make it more obvious..

	Dave

diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 5e626b1..79581fa 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -841,19 +841,25 @@ static int cpufreq_add_dev (struct sys_device * sys_dev)
 	drv_attr = cpufreq_driver->attr;
 	while ((drv_attr) && (*drv_attr)) {
 		ret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));
-		if (ret)
+		if (ret) {
+			unlock_policy_rwsem_write(cpu);
 			goto err_out_driver_exit;
+		}
 		drv_attr++;
 	}
 	if (cpufreq_driver->get){
 		ret = sysfs_create_file(&policy->kobj, &cpuinfo_cur_freq.attr);
-		if (ret)
+		if (ret) {
+			unlock_policy_rwsem_write(cpu);
 			goto err_out_driver_exit;
+		}
 	}
 	if (cpufreq_driver->target){
 		ret = sysfs_create_file(&policy->kobj, &scaling_cur_freq.attr);
-		if (ret)
+		if (ret) {
+			unlock_policy_rwsem_write(cpu);
 			goto err_out_driver_exit;
+		}
 	}
 
 	spin_lock_irqsave(&cpufreq_driver_lock, flags);
-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: assertion when running sparse on current linux.git ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: assertion when running sparse on current linux.git
Date: Wed, 07 Nov 2007 21:14:22 +0000
Message-ID: <20071107211422.GA17454 () redhat ! com>
--------------------
On Wed, Nov 07, 2007 at 12:25:01PM -0800, Christopher Li wrote:
 > Looks like the local label problem which is already fixed in tip of sparse git.
 > 
 > Have you try the sparse git tree?

Yep, works. Thanks.  I'll poke ssomeone to update the Fedora sparse package.

	Dave

-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: attributes are not stored at right location for array variables ===

From: "Chris Li" <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: attributes are not stored at right location for array variables
Date: Wed, 31 Jan 2007 19:53:51 +0000
Message-ID: <70318cbf0701311153k126d4aeam5f68f1c519d3a7af () mail ! gmail ! com>
--------------------
Your patch assumes every attribute apply to node instead of type.
Is there any attribute need to apply to type instead?

For your change, apply_modifiers() need to change where it take the
__mode__ attribute as well.

Chris


On 1/31/07, Mitesh Shah <mshah@teja.com> wrote:
>
> It seems that the attributes are not stored with the variable ctype when the variable is an array. For declaration such as,
>
> char c[100] __attribute__((aligned(64)));
>
> The attribute is stored with the array ctype instead of the variable C ctype.
>
> In function direct_declarator in parse.c at line 920 the ctype gets replaced with the array ctype and in the next iteration it is
> passed to handle_attributes. handle_attributes should be passed the original ctype so here is the patch.
>
> Thanks,
>
> -Mitesh
>
> -------------------------------------------------------
>
> index 5077ee6..306b144 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -881,7 +881,7 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
>         }
>
>         for (;;) {
> -               token = handle_attributes(token, ctype);
> +               token = handle_attributes(token, &decl->ctype);
>
>                 if (token_type(token) != TOKEN_SPECIAL)
>                         return token;
>
>
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: comparison of safe pointers ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: comparison of safe pointers
Date: Fri, 25 May 2007 13:07:49 +0000
Message-ID: <20070525130749.GI4095 () ftp ! linux ! org ! uk>
--------------------
	Why do we generate a warning when we compare two pointers
declared as safe?  I understand why we do that when such beast gets
used as condition (i.e. implicitly compare with NULL), but what's
wrong with

int foo(void __safe *p, void __safe *q)
{
	return p == q;
}

What did you want that check in evaluate_compare() to catch?  Is that
about warning on explicit comparison with NULL?

Al, crawling through evaluate.c and fixing odd cases in typechecking...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: comparison of safe pointers
Date: Fri, 25 May 2007 15:29:11 +0000
Message-ID: <alpine.LFD.0.98.0705250827460.26602 () woody ! linux-foundation ! org>
--------------------


On Fri, 25 May 2007, Al Viro wrote:
> 
> What did you want that check in evaluate_compare() to catch?  Is that
> about warning on explicit comparison with NULL?

Yes. It was explicitly meant to be a "anybody who tests this pointer 
missed the 'safe' part of it".

But I never used it, so it was really meant as a concept thing, and I 
don't think it's wrong to test against non-null.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: constness bug in include/linux/compiler.h ===

From: "Russ Cox" <rsc () swtch ! com>
To: linux-sparse
Subject: constness bug in include/linux/compiler.h
Date: Tue, 13 Mar 2007 22:23:45 +0000
Message-ID: <ee9e417a0703131523x2cc701f7l7938624175bf1fe0 () mail ! gmail ! com>
--------------------
Probably sparse just doesn't pay attention to const,
but shouldn't the definitions of __chk_user_ptr
and __chk_io_ptr be

    extern void __chk_user_ptr(const void __user *);
    extern void __chk_io_ptr(const void __iomem *);

instead of

    extern void __chk_user_ptr(void __user *);
    extern void __chk_io_ptr(void __iomem *);

?

Russ
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: constness bug in include/linux/compiler.h
Date: Wed, 14 Mar 2007 16:18:54 +0000
Message-ID: <45F8206E.8030706 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig4332FB3A0471FB42255BB79B
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Russ Cox wrote:
> Probably sparse just doesn't pay attention to const,

Actually, it does:

$ cat /tmp/const.c
void f(int *p)
{
}

void g(void)
{
    int i =3D 0;
    const int *p =3D &i;
    f(p);
}
$ ./sparse /tmp/const.c
/tmp/const.c:9:7: warning: incorrect type in argument 1 (different modifi=
ers)
/tmp/const.c:9:7:    expected int *p
/tmp/const.c:9:7:    got int const *p

> but shouldn't the definitions of __chk_user_ptr
> and __chk_io_ptr be
>=20
>     extern void __chk_user_ptr(const void __user *);
>     extern void __chk_io_ptr(const void __iomem *);
>=20
> instead of
>=20
>     extern void __chk_user_ptr(void __user *);
>     extern void __chk_io_ptr(void __iomem *);
>=20
> ?

Yes, that makes sense.  These functions just check for the annotation on =
their
pointer argument, and having the const annotation would allow them to che=
ck
const pointers without provoking a warning due to the lack of const.

- Josh Triplett


--------------enig4332FB3A0471FB42255BB79B
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF+CBuGJuZRtD+evsRAoHlAJ9IQjjftQE9dxWhIgJf9pt5c4JZmQCfSxzL
bUiwEJfoXr2JAZfC6w0D4Ac=
=BgNL
-----END PGP SIGNATURE-----

--------------enig4332FB3A0471FB42255BB79B--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Russ Cox" <rsc () swtch ! com>
To: linux-sparse
Subject: Re: constness bug in include/linux/compiler.h
Date: Wed, 14 Mar 2007 19:10:35 +0000
Message-ID: <ee9e417a0703141210n7d8e8834j56c17b69ce68ff2c () mail ! gmail ! com>
--------------------
> Yes, that makes sense.  These functions just check for the annotation on their
> pointer argument, and having the const annotation would allow them to check
> const pointers without provoking a warning due to the lack of const.

They don't provoke a warning now.  Sparse is silent on this program:

	#define __user __attribute__((noderef, address_space(1)))

	extern void __chk_user_ptr(void __user *);

	void
	f(const void __user *p)
	{
		__chk_user_ptr(p);
	}

but arguably they should (and then be changed to const void __user*).

For an actual example, __copy_from_user_inatomic has a
const void __user* argument which it passes (via __get_user_size)
to __chk_user_ptr.

Russ
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: constness bug in include/linux/compiler.h
Date: Fri, 16 Mar 2007 18:26:50 +0000
Message-ID: <45FAE16A.3080601 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig91FF6F694D65C2B42BDD0508
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Russ Cox wrote:
>> Yes, that makes sense.  These functions just check for the annotation =
on their
>> pointer argument, and having the const annotation would allow them to =
check
>> const pointers without provoking a warning due to the lack of const.
>=20
> They don't provoke a warning now.  Sparse is silent on this program:
>=20
> 	#define __user __attribute__((noderef, address_space(1)))
>=20
> 	extern void __chk_user_ptr(void __user *);
>=20
> 	void
> 	f(const void __user *p)
> 	{
> 		__chk_user_ptr(p);
> 	}

Hmmm, odd.  After a few iterations, I managed to discover that Sparse wil=
l
warn if you attempt to convert a const int * to an int *, but not if you
attempt to convert a const void * to a void *.  This seems like a bug to =
me.

> but arguably they should (and then be changed to const void __user*).

Yes.  Please do go ahead and propose the obvious const-adding patch to
include/linux/compiler.h, Cc linux-sparse, and feel free to add a
Signed-off-by from me.

- Josh Triplett


--------------enig91FF6F694D65C2B42BDD0508
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF+uF3GJuZRtD+evsRAkEGAKCb1GSNWKLpWownOu7a3vkScBDANgCfZalP
M11T7OopEht1qIX6THyHWag=
=cYTC
-----END PGP SIGNATURE-----

--------------enig91FF6F694D65C2B42BDD0508--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: constness bug in include/linux/compiler.h
Date: Fri, 16 Mar 2007 18:40:18 +0000
Message-ID: <45FAE492.2040504 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE27BBB342AD49D99E994411D
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Josh Triplett wrote:
> Russ Cox wrote:
>>> Yes, that makes sense.  These functions just check for the annotation=
 on their
>>> pointer argument, and having the const annotation would allow them to=
 check
>>> const pointers without provoking a warning due to the lack of const.
>> They don't provoke a warning now.  Sparse is silent on this program:
>>
>> 	#define __user __attribute__((noderef, address_space(1)))
>>
>> 	extern void __chk_user_ptr(void __user *);
>>
>> 	void
>> 	f(const void __user *p)
>> 	{
>> 		__chk_user_ptr(p);
>> 	}
>=20
> Hmmm, odd.  After a few iterations, I managed to discover that Sparse w=
ill
> warn if you attempt to convert a const int * to an int *, but not if yo=
u
> attempt to convert a const void * to a void *.  This seems like a bug t=
o me.

This bug appears to come from the following code in compatible_assignment=
_types:

                /* "void *" matches anything as long as the address space=
 is OK */
                target_as =3D t->ctype.as | target->ctype.as;
                source_as =3D s->ctype.as | source->ctype.as;
                if (source_as =3D=3D target_as && (s->type =3D=3D SYM_PTR=
 || s->type =3D=3D SYM_ARRAY)) {
                        s =3D get_base_type(s);
                        t =3D get_base_type(t);
                        if (s =3D=3D &void_ctype || t =3D=3D &void_ctype)=

                                goto Cast;
                }

This should almost certainly check more than just address spaces.

- Josh Triplett


--------------enigE27BBB342AD49D99E994411D
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF+uSSGJuZRtD+evsRAnqzAJwNSuBOBy4vAQLVk7zoQfYeAtY29gCgtbu4
CyQaRO765HXr6NCV/NrFSAg=
=1Brl
-----END PGP SIGNATURE-----

--------------enigE27BBB342AD49D99E994411D--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: constness bug in include/linux/compiler.h
Date: Sat, 17 Mar 2007 02:30:58 +0000
Message-ID: <Pine.LNX.4.64.0703161930260.3910 () woody ! linux-foundation ! org>
--------------------


On Fri, 16 Mar 2007, Josh Triplett wrote:
> 
> Hmmm, odd.  After a few iterations, I managed to discover that Sparse will
> warn if you attempt to convert a const int * to an int *, but not if you
> attempt to convert a const void * to a void *.  This seems like a bug to me.

Yeah, I think we allow *any* conversion to "void *". We probably should 
still check const/volatile.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: exposing __attribute__ portability macros in lib.h; any objections? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: exposing __attribute__ portability macros in lib.h; any objections?
Date: Mon, 26 Feb 2007 10:43:48 +0000
Message-ID: <20070226104348.GA27482 () chrisli ! org>
--------------------
On Sun, Feb 25, 2007 at 02:45:29PM -0800, Josh Triplett wrote:
> Applied.

Thanks!

> 
> I'd also like to apply a patch to use __attribute__((__sentinel__)) on
> match_idents, which would have caught this problem.  In order to do so
> portably, I plan to add a portability macro SENTINEL_ATTR, like the
> FORMAT_ATTR macro currently in lib.h.  However, lib.h currently defines
> FORMAT_ATTR, uses it for a few prototypes, and then undefines it.  Any
> objections to defining SENTINEL_ATTR and leaving it defined (and probably
> doing the same for FORMAT_ATTR)?  I don't think those would pollute the
> namespace any more than lib.h already does with position, verbose, info, and
> similar.

No objection for __sentinel__ per se. In the long run, I would like to
get ride of match_idents completely. I want to define more parser
operation function for pre-defined keywords. So it is driven by the
symbol table rather than comparing the keyword one by one. It is a
big change though.

Chris


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: fun with ?: ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: fun with ?:
Date: Sat, 19 May 2007 02:52:49 +0000
Message-ID: <20070519025249.GZ4095 () ftp ! linux ! org ! uk>
--------------------
	There's an unpleasant case in conditional operator we are getting
wrong.
	int *p;
	const void *v;
	int n;

	n ? p : (const void *)0

According to C standard, the type of that expression is const void *.  Note
that
	n ? p : (void *)0
is an entirely different story - it's int *.

What's going on here is pretty simple: there are two degenerate cases of
conditional operator: pointer vs. null pointer constant and pointer vs.
possibly qualified pointer to void.  Look at these cases:
	n ? p : NULL => should be the same type as p
	n ? p : v => clearly const void * - pointer to void with union of
qualifiers; in this case we obviously lose any information about the type
of object being pointed to.

The tricky part comes from definition of what null pointer constant _is_.
C allows two variants - integer constant expression with value 0 (we accept
it, but warn about bad taste) and the same cast to void * (we also accept
that, of course).

Note that this is specific type - pointer to void.  Without any qualifiers.
We are guaranteed that we can convert it to any pointer type and get
a pointer distinct from address of any object.  So (const void *)0 is the same
thing as (const void *)(void *)0 and it is the null pointer to const void.
*HOWEVER*, it is not a null pointer constant.  The standard is clear here and
frankly, it's reasonable.  If you cast to anything other than void *, then
you presumably mean it and want the conversion rules as for any pointer
of that type.  Think of something like
#ifdef FOO
const void *f(int n);
#else
#define f(n) ((const void *)NULL)
#endif
You don't want to have types suddenly change under you depending on FOO.

sparse is more liberal than standard C in what it accepts as null pointer
constant.  It almost never matters; however, in case of conditional operator
we end up with a different type for an expression both sparse and any
C compiler will accept as valid.

I'm fixing other fun stuff in that area (e.g. we ought to take a union of
qualifiers, ought _not_ to mix different structs or unions, etc.), so
unless there are serious objections I'd rather go with standard behaviour
in that case.  What will change:

int n;
int *p;

n ? p : (const void *)NULL	int *	=>	const void *
n ? p : (const void *)0		ditto
n ? p : (char *)0		int *	=>	a warning on mixing int * with							char *
n ? p : (char *)NULL		ditto
n ? p : (void *)NULL		int *	=>	void *
n ? p : (void *)0		unchanged
n ? p : NULL			unchanged

Objections?
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: fun with ?:
Date: Tue, 22 May 2007 21:40:11 +0000
Message-ID: <4653633B.3000000 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig9883604EB15A73613B69775B
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> 	There's an unpleasant case in conditional operator we are getting
> wrong.
> 	int *p;
> 	const void *v;
> 	int n;
>=20
> 	n ? p : (const void *)0
>=20
> According to C standard, the type of that expression is const void *.  =
Note
> that
> 	n ? p : (void *)0
> is an entirely different story - it's int *.

That much actually makes sense to me.  You can convert from (int *) to (c=
onst
void *), but not from (const void *) to (int *), so I'd expect the behavi=
or of
the first case.  You *can* convert bidirectionally between (void *) and (=
int
*), so I expect the behavior of the second case as well.

> What's going on here is pretty simple: there are two degenerate cases o=
f
> conditional operator: pointer vs. null pointer constant and pointer vs.=

> possibly qualified pointer to void.  Look at these cases:
> 	n ? p : NULL =3D> should be the same type as p
> 	n ? p : v =3D> clearly const void * - pointer to void with union of
> qualifiers; in this case we obviously lose any information about the ty=
pe
> of object being pointed to.

I didn't actually know about the special case for a null pointer constant=
=2E

> The tricky part comes from definition of what null pointer constant _is=
_.
> C allows two variants - integer constant expression with value 0 (we ac=
cept
> it, but warn about bad taste) and the same cast to void * (we also acce=
pt
> that, of course).

Right.

> Note that this is specific type - pointer to void.  Without any qualifi=
ers.
> We are guaranteed that we can convert it to any pointer type and get
> a pointer distinct from address of any object.  So (const void *)0 is t=
he same
> thing as (const void *)(void *)0 and it is the null pointer to const vo=
id.
> *HOWEVER*, it is not a null pointer constant.  The standard is clear he=
re and
> frankly, it's reasonable.  If you cast to anything other than void *, t=
hen
> you presumably mean it and want the conversion rules as for any pointer=

> of that type.  Think of something like
> #ifdef FOO
> const void *f(int n);
> #else
> #define f(n) ((const void *)NULL)
> #endif
> You don't want to have types suddenly change under you depending on FOO=
=2E

Definitely not.  I don't want qualifiers to disappear just because I appl=
ied
them to NULL.

> sparse is more liberal than standard C in what it accepts as null point=
er
> constant.  It almost never matters; however, in case of conditional ope=
rator
> we end up with a different type for an expression both sparse and any
> C compiler will accept as valid.
>
> I'm fixing other fun stuff in that area (e.g. we ought to take a union =
of
> qualifiers, ought _not_ to mix different structs or unions, etc.), so
> unless there are serious objections I'd rather go with standard behavio=
ur
> in that case.  What will change:
>=20
> int n;
> int *p;
>=20
> n ? p : (const void *)NULL	int *	=3D>	const void *
> n ? p : (const void *)0		ditto
> n ? p : (char *)0		int *	=3D>	a warning on mixing int * with							char=
 *
> n ? p : (char *)NULL		ditto
> n ? p : (void *)NULL		int *	=3D>	void *
> n ? p : (void *)0		unchanged
> n ? p : NULL			unchanged
>=20
> Objections?

Thanks for the clear explanation.  I think following the standard seems l=
ike a
good idea here, though I find some of the cases somewhat unintuitive and
potentially error-prone.

In particular:
> n ? p : (void *)NULL		int *	=3D>	void *
Shouldn't this have type int * just like n ? p : NULL ?

- Josh Triplett


--------------enig9883604EB15A73613B69775B
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU2M7GJuZRtD+evsRArjNAKCFcJRa5/9gcD5ne0Zy7jBJQCS7dwCfclFC
Uvt/nVoWINGggJy2BvaVzbM=
=Hgkv
-----END PGP SIGNATURE-----

--------------enig9883604EB15A73613B69775B--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: fun with ?:
Date: Tue, 22 May 2007 23:24:49 +0000
Message-ID: <46537BC1.9000808 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig9FE4DAA7A1AB8C638AEC0D0F
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> On Tue, May 22, 2007 at 02:40:11PM -0700, Josh Triplett wrote:
>>> What's going on here is pretty simple: there are two degenerate cases=
 of
>>> conditional operator: pointer vs. null pointer constant and pointer v=
s.
>>> possibly qualified pointer to void.  Look at these cases:
>>> 	n ? p : NULL =3D> should be the same type as p
>>> 	n ? p : v =3D> clearly const void * - pointer to void with union of
>>> qualifiers; in this case we obviously lose any information about the =
type
>>> of object being pointed to.
>> I didn't actually know about the special case for a null pointer const=
ant.
>=20
> Rationale is pretty simple: normally if you have void * in the mix, you=

> _can't_ expect more type information from the result; i.e. you are not
> promised that result of ?: will point to int.  However, null pointer co=
nstant
> is a chameleon - it accepts whatever pointer type you might need in giv=
en
> context.  So in that case you do _not_ lose the type information.

Makes sense, except that in C you can assign a void pointer to an arbitra=
ry *
without a warning, so why can't conditional expressions do the equivalent=
?

>> In particular:
>>> n ? p : (void *)NULL		int *	=3D>	void *
>> Shouldn't this have type int * just like n ? p : NULL ?
>=20
> No.  It's "void * and I _mean_ it".  Well... actually (void *)(void *)0=
 if
> you want to be 100% portable and protect yourself against cretinous sys=
tems
> that define NULL to 0.
>=20
> Again, null pointer constant is not the same thing as null pointer to v=
oid.

I see.  I find it very strange that (void *)0 and (void *)(void *)0 have
different behavior.  I also find it strange that conditional expressions =
can't
convert void * to an arbitrary pointer as assignment can.

> BTW, there's another painful area: what do we do to somebody who uses
> (void *)(69 + 1 - 70) as null pointer constant?  Currenly sparse doesn'=
t
> recognize it as such; C standard does.  IMO the right thing to do is
> to add a flag that would switch to full-blown standard rules in that ar=
ea
> ("integer constant expression returning 0" instead of basically "0 in s=
ome
> layers of ()") and flame to the crisp any wanker caught at actually doi=
ng
> that.  Any suggestions re sufficiently violent warning messages?

I didn't know that the C standard actually *required* constant folding.
Interesting.  Would it add excessively to compilation time to apply the u=
sual
Sparse constant folding here?  If so, and if you really think this case
matters, let's have an option to turn on this constant folding, and warn
whenever we see it.  I'll let you come up with the wording; flame away. :=
)
Anyone expecting that behavior has some serious dain-bramage.  If constan=
t
folding *wouldn't* add excessively to the compilation time, go ahead and
handle the insanity the standard way by default, but still warn for the i=
nsane
case.

- Josh Triplett


--------------enig9FE4DAA7A1AB8C638AEC0D0F
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU3vBGJuZRtD+evsRAtlzAJ4xcNJK+K3/DKXgdzkP6maz6xe/kACgg62x
owWcSQlYOrN8TMnKt82OpTo=
=enTl
-----END PGP SIGNATURE-----

--------------enig9FE4DAA7A1AB8C638AEC0D0F--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 00:02:34 +0000
Message-ID: <20070523000234.GJ4095 () ftp ! linux ! org ! uk>
--------------------
On Tue, May 22, 2007 at 04:24:49PM -0700, Josh Triplett wrote:
> Makes sense, except that in C you can assign a void pointer to an arbitrary *
> without a warning, so why can't conditional expressions do the equivalent?

{in sparse it's obviously not true due to address_space, but that hadn't
affected C standard decisions; the rest applies to standard C}

For one thing, no, you can't (pointers to functions have every right to
be unrelated to void *).  For another, you are not guaranteed that
conversion from void * to int * will not yield undefined behaviour.
It is OK if the value of void * is properly aligned; then you know
that conversion back to void * will give the original pointer.  Otherwise
you are in nasal demon country.  The other way round (int * to void *
to int *) you are always safe.

Rationale: systems that have pointers to words and char smaller than word.
There you can very well have pointers to void and pointers to less-than-word
objects bigger than pointers to anything word-sized or bigger (e.g. they
can be represented as word address + bit offset).  Conversion to the latter
will lose offset and compiler is allowed to throw up on that at runtime.

Moral: void * -> int * may lose parts of value and trigger undefined behaviour;
int * -> void * loses information about type, is always revertible and always
safe.  In assignment operator it's your responsibility to make sure that
void * you are converting to int * is properly aligned (anything that started
its life as int * will be).  In ?: C could
	* lose type information, allowing any values (result is void *); if
you are sure that it's well-aligned, you can cast void * argument to int *
or cast the result.
	* require the void * argument to be well-aligned, keep the type.

The former makes more sense...
 
> > Again, null pointer constant is not the same thing as null pointer to void.
> 
> I see.  I find it very strange that (void *)0 and (void *)(void *)0 have
> different behavior.  I also find it strange that conditional expressions can't
> convert void * to an arbitrary pointer as assignment can.

It would be nicer if C had __null__ as the *only* null pointer constant
(with flexible type) and could refuse to accept anything else.  Too late
for that, unfortunately.  As for conversions - see above.
 
> > BTW, there's another painful area: what do we do to somebody who uses
> > (void *)(69 + 1 - 70) as null pointer constant?  Currenly sparse doesn't
> > recognize it as such; C standard does.  IMO the right thing to do is
> > to add a flag that would switch to full-blown standard rules in that area
> > ("integer constant expression returning 0" instead of basically "0 in some
> > layers of ()") and flame to the crisp any wanker caught at actually doing
> > that.  Any suggestions re sufficiently violent warning messages?
> 
> I didn't know that the C standard actually *required* constant folding.
> Interesting.  Would it add excessively to compilation time to apply the usual
> Sparse constant folding here?  If so, and if you really think this case
> matters, let's have an option to turn on this constant folding, and warn
> whenever we see it.

Usual sparse constant folding is _almost_ OK, provided that we play a bit
with evaluate_expression() and let it decide if subexpression is an integer
constant expression.  No prototype changes, we just get a global flag
and save/restore it around sizeof argument handling and several other
places.  It's actually pretty easy.  And if we get "it is an integer
constant expression", well, then caller can call expand stuff.

"Almost" bit above refers to another bit of insanity, fortunately easily
handled; we need division by zero to raise no error and just yield "the
entire thing is not an integer constant expression with value 0".  That's
exactly what longjmp() is for...

Speaking of C standard, if you need access to the current one - yell.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 01:03:31 +0000
Message-ID: <465392E3.3000300 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigB70B423F60D2A8D1D0C3E576
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> On Tue, May 22, 2007 at 04:24:49PM -0700, Josh Triplett wrote:
>> Makes sense, except that in C you can assign a void pointer to an arbi=
trary *
>> without a warning, so why can't conditional expressions do the equival=
ent?
>=20
> {in sparse it's obviously not true due to address_space, but that hadn'=
t
> affected C standard decisions; the rest applies to standard C}
>=20
> For one thing, no, you can't (pointers to functions have every right to=

> be unrelated to void *).  For another, you are not guaranteed that
> conversion from void * to int * will not yield undefined behaviour.
> It is OK if the value of void * is properly aligned; then you know
> that conversion back to void * will give the original pointer.  Otherwi=
se
> you are in nasal demon country.  The other way round (int * to void *
> to int *) you are always safe.
>=20
> Rationale: systems that have pointers to words and char smaller than wo=
rd.
> There you can very well have pointers to void and pointers to less-than=
-word
> objects bigger than pointers to anything word-sized or bigger (e.g. the=
y
> can be represented as word address + bit offset).  Conversion to the la=
tter
> will lose offset and compiler is allowed to throw up on that at runtime=
=2E

Go Cray go.

> Moral: void * -> int * may lose parts of value and trigger undefined be=
haviour;
> int * -> void * loses information about type, is always revertible and =
always
> safe.  In assignment operator it's your responsibility to make sure tha=
t
> void * you are converting to int * is properly aligned (anything that s=
tarted
> its life as int * will be).  In ?: C could
> 	* lose type information, allowing any values (result is void *); if
> you are sure that it's well-aligned, you can cast void * argument to in=
t *
> or cast the result.
> 	* require the void * argument to be well-aligned, keep the type.
>=20
> The former makes more sense...

Fair enough.

>>> Again, null pointer constant is not the same thing as null pointer to=
 void.
>> I see.  I find it very strange that (void *)0 and (void *)(void *)0 ha=
ve
>> different behavior.  I also find it strange that conditional expressio=
ns can't
>> convert void * to an arbitrary pointer as assignment can.
>=20
> It would be nicer if C had __null__ as the *only* null pointer constant=

> (with flexible type) and could refuse to accept anything else.  Too lat=
e
> for that, unfortunately.  As for conversions - see above.

Agreed; that seems far saner.  (Or, as long as we wishfully redefine the
original C spec, just NULL or null, sans underscores.)

>>> BTW, there's another painful area: what do we do to somebody who uses=

>>> (void *)(69 + 1 - 70) as null pointer constant?  Currenly sparse does=
n't
>>> recognize it as such; C standard does.  IMO the right thing to do is
>>> to add a flag that would switch to full-blown standard rules in that =
area
>>> ("integer constant expression returning 0" instead of basically "0 in=
 some
>>> layers of ()") and flame to the crisp any wanker caught at actually d=
oing
>>> that.  Any suggestions re sufficiently violent warning messages?
>> I didn't know that the C standard actually *required* constant folding=
=2E
>> Interesting.  Would it add excessively to compilation time to apply th=
e usual
>> Sparse constant folding here?  If so, and if you really think this cas=
e
>> matters, let's have an option to turn on this constant folding, and wa=
rn
>> whenever we see it.
>=20
> Usual sparse constant folding is _almost_ OK, provided that we play a b=
it
> with evaluate_expression() and let it decide if subexpression is an int=
eger
> constant expression.  No prototype changes, we just get a global flag
> and save/restore it around sizeof argument handling and several other
> places.  It's actually pretty easy.  And if we get "it is an integer
> constant expression", well, then caller can call expand stuff.

Sounds reasonable to me.  Possibly better written as some kind of generic=

parse-tree-walking operation, but this approach should work fine.

> "Almost" bit above refers to another bit of insanity, fortunately easil=
y
> handled; we need division by zero to raise no error and just yield "the=

> entire thing is not an integer constant expression with value 0".  That=
's
> exactly what longjmp() is for...

$ egrep -r 'setjmp|longjmp' ~/src/sparse/*
$

Let's keep it that way, please. :) Evaluation almost certainly should war=
n for
a compile-time divide-by-zero regardless, though we don't want to warn tw=
ice
for the same expression.  With the global "check for integer constant
expression" flag set, if evaluation encounters a compile-time divide-by-z=
ero,
evaluation could just set a divided_by_zero flag.  Or something like that=
=2E

> Speaking of C standard, if you need access to the current one - yell.

I use http://c0x.coding-guidelines.com/ , which has the C99 spec and some=

subsequent updates.

- Josh Triplett



--------------enigB70B423F60D2A8D1D0C3E576
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU5LjGJuZRtD+evsRAjgrAJ9TgfVhTnrbcDtWYvFYMkJF7HQsKACfaQRQ
FemkdvZKlq64kg3m269Kdbs=
=zxWT
-----END PGP SIGNATURE-----

--------------enigB70B423F60D2A8D1D0C3E576--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 01:05:39 +0000
Message-ID: <46539363.3010202 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigCCBAE6645D19D5A6EEF27C26
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Al Viro wrote:
> On Wed, May 23, 2007 at 01:02:34AM +0100, Al Viro wrote:
>> It would be nicer if C had __null__ as the *only* null pointer constan=
t
>> (with flexible type) and could refuse to accept anything else.  Too la=
te
>> for that, unfortunately.  As for conversions - see above.
>=20
> To clarify: all mess with null pointer constants comes from lack of
> explicit token and need to avoid massive breakage of old programs.  Tha=
t's
> what it's all about - compiler recognizing some subexpressions as
> representations of that missing token and trying to do that in a way th=
at
> would break as little as possible of existing C code.  It's an old stor=
y -
> decisions had to be made in 80s and now we are stuck with them.
>=20
> IOW, (void *)0 in contexts that allow null pointer constant is *not* a
> 0 cast to pointer to void; it's a compiler-recognized kludge for __null=
__.
> And it's not a pointer to void.  It can become a pointer to any type,
> including void.  If converted to a pointer type it gives the same value=

> you get if you convert 0 to that type ("null pointer to type").  But
> unlike null pointer to type it retains full flexibility.
>=20
> NULL is required to expand to null pointer constant and that's one of
> the reasons why sane code should be using it instead of explicitly spel=
led
> variants.  The next best thing to actually having __null__ in the langu=
age...

That makes perfect sense now.  Thanks for the explanation.

- Josh Triplett



--------------enigCCBAE6645D19D5A6EEF27C26
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFGU5NjGJuZRtD+evsRArLmAJwOVIKyEuiOc+h2G99U4GaZ/UzHkgCdEja1
f/Rx8xY+yfDrYyKSWMHo+YE=
=SvPN
-----END PGP SIGNATURE-----

--------------enigCCBAE6645D19D5A6EEF27C26--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 04:53:19 +0000
Message-ID: <20070523045319.GL4095 () ftp ! linux ! org ! uk>
--------------------
On Wed, May 23, 2007 at 01:25:06AM +0100, Al Viro wrote:
> To clarify: all mess with null pointer constants comes from lack of
> explicit token and need to avoid massive breakage of old programs.  That's
> what it's all about - compiler recognizing some subexpressions as
> representations of that missing token and trying to do that in a way that
> would break as little as possible of existing C code.  It's an old story -
> decisions had to be made in 80s and now we are stuck with them.
> 
> IOW, (void *)0 in contexts that allow null pointer constant is *not* a
> 0 cast to pointer to void; it's a compiler-recognized kludge for __null__.
> And it's not a pointer to void.  It can become a pointer to any type,
> including void.  If converted to a pointer type it gives the same value
> you get if you convert 0 to that type ("null pointer to type").  But
> unlike null pointer to type it retains full flexibility.

PPS: original idiom for that sucker was, of course, simply 0.  My
understanding (and I'm seriously risking playing wrongbot here, so
take it with big grain of salt) is that raise of "cast 0 to pointer"
idiom was mostly due to targets where sizeof(pointer) > sizeof(int); there
the lack of prototypes meant that passing 0 in pointer argument would
do the wrong thing.  I _think_ it predates the introduction of void *, but
not by much; 32V source is available, so that would be a useful data point.
When use of void * stopped being serious portability issue it became the
best variant in that family (the most type-neutral of available options).
Then (void *)0 went into Feb 86 ANSI draft as acceptable alternative for null
pointer constant (i.e. recognized by compiler and converted to type
appropriate by context).

BTW, note that null pointer constant is *not* recognized in variable part
of argument list when you are calling a vararg function, so there you
get what you get - integer-type 0 or null pointer to void.  Which may
make life bloody interesting wrt portability.  Fortunately, these days
userland headers tend to have NULL defined to (void *)0 or integer 0
of the right size, so you are probably OK as long as you use
va_arg(..., void *) to get it, but $DEITY help you if you pass NULL
in vararg in place of pointer to function - on minimally weird targets
it will be ugly.  I don't think that sparse can catch that kind of
braindamage, though...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 12:26:28 +0000
Message-ID: <118833cc0705230526o46eb1633i69a12219f24c1343 () mail ! gmail ! com>
--------------------
>[...] but $DEITY help you if you pass NULL
> in vararg in place of pointer to function - on minimally weird targets
> it will be ugly.  I don't think that sparse can catch that kind of
> braindamage, though...

If the rules for the types in any given function's varargs can be taught to
sparse, I don't see why not.  I did some vararg checking -- "must end with
-1" kind of thing -- early for sparse.  It should be in the archives.  (An
early prototype with sub-standard monkey-see-monkey-do coding, but
still.)

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 14:32:02 +0000
Message-ID: <20070523143202.GY4095 () ftp ! linux ! org ! uk>
--------------------
On Wed, May 23, 2007 at 11:25:44PM +0900, Neil Booth wrote:
> I respect you too much Al to doubt you, but I do warn you that
> getting the rules for integer constant expressions right in C is
> harder than it looks.  GCC is not very close.  The immediate
> cast of float bit painful in recursive descent parsers.  I've managed
> to find cases where Comeau's online compiler doesn't get it right,
> and they're pretty good.
> 
> I have a test suite that tests these things to an unhealthy level of
> pedantry for my own implementation (the only one I know passes the lot,
> of course 8-); happy to run sparse when you've finished if you like.

gcc integer constant expressions handling is a bad joke.

extern int n;
struct {
	int x : 1 + n - n;
} y;

passes with -pedantic -std=c99.  Replacing that with 1 + n - n + n - n
is still OK with gcc; 1 + n + n - n - n is not.

So that's hardly an example of, well, anything.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 15:32:55 +0000
Message-ID: <20070523153255.GA4095 () ftp ! linux ! org ! uk>
--------------------
On Wed, May 23, 2007 at 11:47:16PM +0900, Neil Booth wrote:
> > gcc integer constant expressions handling is a bad joke.
> > 
> > extern int n;
> > struct {
> > 	int x : 1 + n - n;
> > } y;
> > 
> > passes with -pedantic -std=c99.  Replacing that with 1 + n - n + n - n
> > is still OK with gcc; 1 + n + n - n - n is not.
> > 
> > So that's hardly an example of, well, anything.
> 
> Consistency?  :-)  I wasn't aware of the quirk of the second example.
> 
> Apparently these expressions are only folded if their net result
> is obvious as parsed by the grammar.  Fixing this in GCC is a
> horrendous amount of work; so much internal logic relies on this
> early simplification, which is why it's not been done I guess.

With sparse that's easier - we have parsing and typechecking separated
enough.  And yes, blind evaluate + expand will suffer similar problems.
However, it's not hard to have evaluate_expression() to set a flag
when it steps into a construct prohibited in integer constant expressions.
BTW, immediate cast from float is not hard - you need all casts other than
under sizeof go to integer type *and* you need any operations involving
floating point types to set "not an integer constant expression".  Since
comma and function calls are also banned, float will either go all
way up or it will be eaten by cast.

BTW, the fun question is whether (int)(1.1) is allowed; the same goes
for "is ((void *)0) a null pointer constant".  6.5.1 is sloppy ;-)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 21:16:02 +0000
Message-ID: <4654AF12.9040101 () knosof ! co ! uk>
--------------------
Al,

>> cast of float bit painful in recursive descent parsers.  I've managed
>> to find cases where Comeau's online compiler doesn't get it right,
>> and they're pretty good.

I would be interested to know what these cases were.

> extern int n;
> struct {
> 	int x : 1 + n - n;
> } y;
> 
> passes with -pedantic -std=c99.  Replacing that with 1 + n - n + n - n
> is still OK with gcc; 1 + n + n - n - n is not.
> 
> So that's hardly an example of, well, anything.

It is an example of order of evaluation mattering when overflow
occurs.

What with game programming growing and growing in importance
I think it won't be long before saturated interger arithmetic
overflow will be encountered just as often as the 'conventional'
wrapping behavior.

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Wed, 23 May 2007 23:01:43 +0000
Message-ID: <20070523230143.GG2547 () daikokuya ! co ! uk>
--------------------
Al Viro wrote:-

> BTW, the fun question is whether (int)(1.1) is allowed; the same goes
> for "is ((void *)0) a null pointer constant".  6.5.1 is sloppy ;-)

I believe that the intent is that parentheses are not viewed as
operators, just a grouping tool, so yes to both.  All implementations
I'm aware of take that view.

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Thu, 24 May 2007 00:02:40 +0000
Message-ID: <20070524000240.GC4095 () ftp ! linux ! org ! uk>
--------------------
On Thu, May 24, 2007 at 12:29:43AM +0100, Derek M Jones wrote:

> It was intended as a probabilit statement (ok, I did not make that
> clear).  An expression containing n+n is more likely to overflow
> than one containing n-n.

Gimme a break.
	a) s/int/unsigned and run that through gcc; no change in behaviour
	b) no fscking way in hell *either* is acceptable for bitfield
width - definitely not with -std=c99 -pedantic.  Violates 6.6p6 and 6.7.2.1p3.
	c) what's happening is pretty obvious - the difference is not in
overflows, it's in expression tree structure (remember, + and - are
left-to-right).  gcc throws several cheap optimizations at the expression
and checks if it has come up with a constant.  Simple common factors are taken
out (n*m - n*m is seen as 0), common subexpressions are not recognized
((n+m)-(n+m) is not seen as constant).
	d) (c) is an exercise in software proctology - gcc has an obvious
bug in that area (mishandling recognition of integer constant expressions),
period.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Thu, 24 May 2007 00:10:08 +0000
Message-ID: <4654D7E0.6090505 () knosof ! co ! uk>
--------------------
Neil,

>> BTW, the fun question is whether (int)(1.1) is allowed; the same goes
>> for "is ((void *)0) a null pointer constant".  6.5.1 is sloppy ;-)
> 
> I believe that the intent is that parentheses are not viewed as
> operators,

I suspect that many implementations simply throw them away (or rather
don't bother hanging onto them) in this case, and so work by
'accident'.

>             just a grouping tool, so yes to both.  All implementations
> I'm aware of take that view.

The word 'immediate' in sentence 1318
http://c0x.coding-guidelines.com/6.6.html
"... floating constants that are the immediate operands of casts"
could be interpreted to mean that no other tokens occur between
the cast and its operand.

I suspect that the behavior of existing implementations would be
enough to push any implementation that did not treat (int)(1.1) as
an integer constant into accepting it as such.

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Thu, 24 May 2007 00:14:31 +0000
Message-ID: <20070524001431.GD4095 () ftp ! linux ! org ! uk>
--------------------
On Thu, May 24, 2007 at 08:01:43AM +0900, Neil Booth wrote:
> Al Viro wrote:-
> 
> > BTW, the fun question is whether (int)(1.1) is allowed; the same goes
> > for "is ((void *)0) a null pointer constant".  6.5.1 is sloppy ;-)
> 
> I believe that the intent is that parentheses are not viewed as
> operators, just a grouping tool, so yes to both.  All implementations
> I'm aware of take that view.

Sure - especially for the second example ;-)  And no, I don't think
anybody can be arsed to file a DR about that.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: fun with ?:
Date: Thu, 24 May 2007 00:29:38 +0000
Message-ID: <alpine.LFD.0.98.0705231723260.3890 () woody ! linux-foundation ! org>
--------------------
  This message is in MIME format.  The first part should be readable text,
  while the remaining parts are likely unreadable without MIME-aware tools.

---1463790079-140575689-1179966579=:3890
Content-Type: TEXT/PLAIN; charset=iso-2022-jp



On Thu, 24 May 2007, Derek M Jones wrote:
> 
> Saturated arithmetic kills off so many optimizations because reordering
> an expression might produce different results.

Yes. However, the FP people do have solutions to that, for all the same 
reasons.

(ie, you can add rules like:
 - parentheses have meaning outside of just precedence, and disable 
   associativity-based ordering optimizations.
 - the normal C side effect boundaries also act as ordering boundaries for 
   arithmetic.

> This is the point of the discussion that has got me confused.
> What compiler misfeature?  Perhaps I am using the 'wrong' version
> of gcc (version 4.0.2), but I get the expected wrapping behavior (ie,
> the compiler tries to behave at translate time the same way as st
> runtime).

The problem that Al was pointing to that sometimes gcc will do *constant 
folding* at parse time, and treat "1+n-n" as a compile-time constant in 
situations where that simply isn't valid C.

Try this:

	[torvalds@woody ~]$ cat t.c
	extern int n;
	int a[1 + n - n];
	[torvalds@woody ~]$ gcc -c -Wall t.c

and notice the lack of any error what-so-ever. With sparse, you get

	[torvalds@woody ~]$ sparse -Wall t.c
	t.c:2:13: error: bad constant expression

now, change the "1+n-n" into "1+n+n-n-n", and notice what gcc says:

	[torvalds@woody ~]$ gcc -c -Wall t.c
	t.c:2: error: variably modified $B!F(Ja$B!G(J at file scope

iow, gcc actually thinks that "1+n-n" is somehow different from 
"1+n+n-n-n".

Which was Al's point.

		Linus
---1463790079-140575689-1179966579=:3890--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Brett Nash <nash () fst ! net>
To: linux-sparse
Subject: Re: fun with ?:
Date: Thu, 24 May 2007 01:36:22 +0000
Message-ID: <1179970582.2498.9.camel () baboon ! fluffyspider ! com ! au>
--------------------
On Wed, 2007-05-23 at 22:16 +0100, Derek M Jones wrote:
> > extern int n;
> > struct {
> > 	int x : 1 + n - n;
> > } y;
> > 
> > passes with -pedantic -std=c99.  Replacing that with 1 + n - n + n - n
> > is still OK with gcc; 1 + n + n - n - n is not.
> > 
> > So that's hardly an example of, well, anything.
> 
> It is an example of order of evaluation mattering when overflow
> occurs.

I shudder to think of the architecture where integer overflow and
bit-field declarations are mentioned in the same sentence.

	nash
	[Going back to lurking, on his new amd2147483648]
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with ?:
Date: Sun, 03 Jun 2007 01:05:34 +0000
Message-ID: <20070603010534.GV4095 () ftp ! linux ! org ! uk>
--------------------
On Tue, May 22, 2007 at 06:03:31PM -0700, Josh Triplett wrote:
> > Usual sparse constant folding is _almost_ OK, provided that we play a bit
> > with evaluate_expression() and let it decide if subexpression is an integer
> > constant expression.  No prototype changes, we just get a global flag
> > and save/restore it around sizeof argument handling and several other
> > places.  It's actually pretty easy.  And if we get "it is an integer
> > constant expression", well, then caller can call expand stuff.
> 
> Sounds reasonable to me.  Possibly better written as some kind of generic
> parse-tree-walking operation, but this approach should work fine.

Hrm...  Actually, "global flag" approach doesn't work at all, since we
mishandle already-evaluated subtrees (happens with inlined functions).

AFAICS, here's what we can do with relatively little PITA:

	Split some of the EXPR_... cases in two; additional variant
would differ by | EXPR_INT_CONST, which would be 1U<<31 (let's call it
i-bit).  EXPR_CAST gets split in three - normal, EXPR_CAST with i-bit
and EXPR_CAST with f-bit (1U<<30).

At parse time, do the following:
	* EXPR_VALUE, EXPR_TYPE, EXPR_SIZEOF, EXPR_PTRSIZEOF and EXPR_ALIGNOF
get i-bit.
	* EXPR_COMPARE, EXPR_BINOP, EXPR_LOGICAL, EXPR_CONDITIONAL,
EXPR_PREOP with !, + , -, ~ or ( and EXPR_CAST get i-bit if all their
arguments have it.
	* EXPR_CAST also gets both i- and f-bit if its argument is EXPR_FVALUE,
possibly wrapped into some EXPR_PREOP[(].

That won't really complicate the parser.  Now, at that point i-bit
is weaker than "subexpression is an integer constant expression", but not
by much - the only things we are missing are "it typechecks OK" and "all
casts are to integer types" (note that sizeof(VLA) would have to be caught
when we start handling those; as it is, it fails typechecking, plain and
simple).

So what we do at evaluate_expression() is simple - we remove some i-bits.
Rules:
	* EXPR_COMPARE, EXPR_BINOP, EXPR_LOGICAL, EXPR_CONDITIONAL, EXPR_PREOP:
lose i-bit if some argument doesn't have it after evaluation.
	* EXPR_IMPLIED_CAST to an integer type inherits i-bit from argument.
	* EXPR_CAST loses i-bit if the type we are casting to is not an
integer one; it also loses i-bit if evaluated argument doesn't have i-bit
*and* EXPR_CAST itself doesn't have f-bit.
	* in cannibalizing EXPR_PREOP in &*p and *&p simplifications,
keep the (lack of) i-bit and f-bit on the overwritten node.

In expand_expression() we keep i-bit through the replacement.

That's it.  Now, "has i-bit after evaluate_expression()" == "expression
is an integer constant one".

Now, we do the following:
	* static struct symbol null_ctype, initialized to SYM_PTR over
void.
	* evaluation of EXPR_CAST with target type being a pointer to void
and argument bearing an i-bit should check if argument is in fact 0; if
it is, replace the node with EXPR_VALUE[0] and &null_ctype as type.
	* int is_null_pointer_constant(expr) - return 1 if type is &null_ctype,
2 if argument bears i-bit and is in fact 0, return 0 otherwise.
	* have degenerate() turn &null_ctype into a normal pointer to void
	* callers of degenerate() in contexts where we care about null
pointer constants (?:, assignment, argument of function call, pointer
comparison, cast) should do is_null_pointer_constant() first.  Act accordingly,
warn if it had returned 2.  Note that we can't blindly generate a warning
in is_null_pointer_constant() - sometimes 0 is simply 0 and we don't want it
to become a pointer at all, let alone generate any warnings.

AFAICS, that will do the right thing with little pain.  I'm not all that
happy about splitting EXPR_... (in effect, stealing bit from expr->type);
perhaps reducing the size of expr->type and adding expr->flags would be
better.  Hell knows...

Comments?
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: idio{,ma}tic typos (was Re: + ===

From: Pierre Ossman <drzeus () drzeus ! cx>
To: linux-sparse
Subject: Re: idio{,ma}tic typos (was Re: +
Date: Wed, 10 Oct 2007 18:22:23 +0000
Message-ID: <20071010202223.292176a1 () poseidon ! drzeus ! cx>
--------------------
This is a MIME-formatted message.  If you see this text it means that your
E-mail software does not support MIME-formatted messages.

--=_hera.drzeus.cx-2283-1192040518-0001-2
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: quoted-printable

On Wed, 10 Oct 2007 14:45:40 +0400
Alexey Dobriyan <adobriyan@sw.ru> wrote:

> ["if (!x & y)" patch from yanzheng@]
> ["if (!x & y)" patch from adobriyan@]
> ["if (!x & y)" patches from viro@]
>=20
> While we're at it, below is somewhat ugly sparse patch for detecting
> "&& 0x" typos.
>=20

The maintainer for tifm is Alex Dubov, so cc:ing him.

> drivers/mmc/host/tifm_sd.c:183:9: warning: dubious && 0x
>=20
> 	if ((r_data->flags & MMC_DATA_WRITE)
>             && DATA_CARRY)
> 		writel(host->bounce_buf_data[0],
> 		host->dev->addr
> 		+ SOCK_MMCSD_DATA);
>=20
> 	given that DATA_CARRY is always used together with
> ->cmd_flags, this place is asking for obvious fixlet:
>=20
>=20
> [PATCH] tifm_sd.c: fix DATA_CARRY check
>=20
> Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
> ---
>=20
>  drivers/mmc/host/tifm_sd.c |    2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
>=20
> --- a/drivers/mmc/host/tifm_sd.c
> +++ b/drivers/mmc/host/tifm_sd.c
> @@ -180,7 +180,7 @@ static void tifm_sd_transfer_data(struct tifm_sd
> *host) host->sg_pos++;
>  			if (host->sg_pos =3D=3D host->sg_len) {
>  				if ((r_data->flags & MMC_DATA_WRITE)
> -				    && DATA_CARRY)
> +				    && (host->cmd_flags &
> DATA_CARRY)) writel(host->bounce_buf_data[0],
>  					       host->dev->addr
>  					       + SOCK_MMCSD_DATA);
>=20
>=20
>=20

Rgds
Pierre

--=_hera.drzeus.cx-2283-1192040518-0001-2
Content-Type: application/pgp-signature; name="signature.asc"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=signature.asc

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.7 (GNU/Linux)

iD8DBQFHDRhh7b8eESbyJLgRAglQAJ9tJ7VSsyuI7LIV4fi6WDHR/S1SugCgyjSI
O17f7Z+JemtEcXFjPl33wFI=
=KhSs
-----END PGP SIGNATURE-----

--=_hera.drzeus.cx-2283-1192040518-0001-2--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: idio{,ma}tic typos (was Re: +
Date: Wed, 10 Oct 2007 19:02:27 +0000
Message-ID: <1192042947.29176.2.camel () dv>
--------------------
On Wed, 2007-10-10 at 11:08 -0700, Josh Triplett wrote:

> Sparse has a notion of "integer constant expression" already, which it
> uses to validate expressions used for things like bitfield widths or
> array sizes.  I could easily have Sparse warn on any use of an integer
> constant expression as an operand of || or &&.  However, I can imagine
> that that might lead to some false positives when intentionally using
> an integer constant expression in a condition and expecting the
> compiler to optimize it out at compile time.

I can imagine 0 or 1 being used, maybe -1, but hardly anything else.
Maybe you could add the code printing the value and then get some
statics on the actual Linux kernel to see which values are common and
which are not?

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: +
Date: Wed, 10 Oct 2007 19:02:27 +0000
Message-ID: <1192042947.29176.2.camel () dv>
--------------------
On Wed, 2007-10-10 at 11:08 -0700, Josh Triplett wrote:

> Sparse has a notion of "integer constant expression" already, which it
> uses to validate expressions used for things like bitfield widths or
> array sizes.  I could easily have Sparse warn on any use of an integer
> constant expression as an operand of || or &&.  However, I can imagine
> that that might lead to some false positives when intentionally using
> an integer constant expression in a condition and expecting the
> compiler to optimize it out at compile time.

I can imagine 0 or 1 being used, maybe -1, but hardly anything else.
Maybe you could add the code printing the value and then get some
statics on the actual Linux kernel to see which values are common and
which are not?

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch
Date: Wed, 10 Oct 2007 11:45:46 +0000
Message-ID: <470CBB6A.7020305 () freedesktop ! org>
--------------------
Alexey Dobriyan wrote:
> ["if (!x & y)" patch from yanzheng@]
> ["if (!x & y)" patch from adobriyan@]
> ["if (!x & y)" patches from viro@]
> 
> While we're at it, below is somewhat ugly sparse patch for detecting
> "&& 0x" typos.

Excellent idea!  I think it applies to || as well.  I'll most likely
add a -Wboolean-logic-on-bit-constant to turn this warning on.

Any reason why this wouldn't apply to octal constants or to GCC's new
binary constants?  I can trivially modify this patch to handle those
as well, just by dropping the check for an 'x' or 'X', and renaming the
flag.

As far as patch beauty goes, I think this patch looks just fine.

- Josh Triplett

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch
Date: Wed, 10 Oct 2007 11:45:46 +0000
Message-ID: <470CBB6A.7020305 () freedesktop ! org>
--------------------
Alexey Dobriyan wrote:
> ["if (!x & y)" patch from yanzheng@]
> ["if (!x & y)" patch from adobriyan@]
> ["if (!x & y)" patches from viro@]
> 
> While we're at it, below is somewhat ugly sparse patch for detecting
> "&& 0x" typos.

Excellent idea!  I think it applies to || as well.  I'll most likely
add a -Wboolean-logic-on-bit-constant to turn this warning on.

Any reason why this wouldn't apply to octal constants or to GCC's new
binary constants?  I can trivially modify this patch to handle those
as well, just by dropping the check for an 'x' or 'X', and renaming the
flag.

As far as patch beauty goes, I think this patch looks just fine.

- Josh Triplett

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch
Date: Wed, 10 Oct 2007 18:08:53 +0000
Message-ID: <470D1535.6030708 () freedesktop ! org>
--------------------
Morten Welinder wrote:
>> While we're at it, below is somewhat ugly sparse patch for detecting
>> "&& 0x" typos.
> 
> Excellent idea, and there is something to be said about a low-footprint patch
> like that.  However, if you really want to capture this kind of bugs, you would
> need to have some kind "not a boolean" or "bitfield" attribute that
> can propagate.
> For example, you would want
> 
>     if (foo && (BAR | BAZ)) ...;
> 
> with BAR and BAZ being hex constants to produce the same warning.
> 
> Incidentally, it is probably not just hex constants that deserve this treatment:
> octal constants and variations of (1 << cst) are of the same nature.  As well
> as enums defined in such manners.

Sparse has a notion of "integer constant expression" already, which it
uses to validate expressions used for things like bitfield widths or
array sizes.  I could easily have Sparse warn on any use of an integer
constant expression as an operand of || or &&.  However, I can imagine
that that might lead to some false positives when intentionally using
an integer constant expression in a condition and expecting the
compiler to optimize it out at compile time.

- Josh Triplett
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to ===

From: Andreas Schwab <schwab () suse ! de>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to
Date: Wed, 10 Oct 2007 11:23:19 +0000
Message-ID: <je7ilvtdqw.fsf () sykes ! suse ! de>
--------------------
Alexey Dobriyan <adobriyan@sw.ru> writes:

> --- a/drivers/net/wireless/arlan.h
> +++ b/drivers/net/wireless/arlan.h
> @@ -485,7 +485,7 @@ struct arlan_private {
>  #define clearClearInterrupt(dev){\
>     writeControlRegister(dev,readControlRegister(dev) & ~ARLAN_CLEAR_INTERRUPT);}
>  #define setPowerOff(dev){\
> -   writeControlRegister(dev,readControlRegister(dev) | (ARLAN_POWER && ARLAN_ACCESS));\
> +   writeControlRegister(dev,readControlRegister(dev) | (ARLAN_POWER & ARLAN_ACCESS));\

Methinks that this actually wants (ARLAN_POWER | ARLAN_ACCESS), since
(ARLAN_POWER & ARLAN_ACCESS) == 0.

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab@suse.de
SuSE Linux Products GmbH, Maxfeldstra√üe 5, 90409 N√ºrnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to
Date: Wed, 10 Oct 2007 13:35:49 +0000
Message-ID: <118833cc0710100635x205503a2peb73d24384538afa () mail ! gmail ! com>
--------------------
> While we're at it, below is somewhat ugly sparse patch for detecting
> "&& 0x" typos.

Excellent idea, and there is something to be said about a low-footprint patch
like that.  However, if you really want to capture this kind of bugs, you would
need to have some kind "not a boolean" or "bitfield" attribute that
can propagate.
For example, you would want

    if (foo && (BAR | BAZ)) ...;

with BAR and BAZ being hex constants to produce the same warning.

Incidentally, it is probably not just hex constants that deserve this treatment:
octal constants and variations of (1 << cst) are of the same nature.  As well
as enums defined in such manners.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Alexey Dobriyan <adobriyan () sw ! ru>
To: linux-sparse
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to
Date: Thu, 11 Oct 2007 07:35:37 +0000
Message-ID: <20071011073537.GA6697 () localhost ! sw ! ru>
--------------------
On Wed, Oct 10, 2007 at 04:45:46AM -0700, Josh Triplett wrote:
> Alexey Dobriyan wrote:
> > ["if (!x & y)" patch from yanzheng@]
> > ["if (!x & y)" patch from adobriyan@]
> > ["if (!x & y)" patches from viro@]
> > 
> > While we're at it, below is somewhat ugly sparse patch for detecting
> > "&& 0x" typos.
> 
> Excellent idea!  I think it applies to || as well.

Sadly, yes.

[PATCH] smctr: fix "|| 0x" typo

IBM_PASS_SOURCE_ADDR is 1, so logically ORing it with status bits is
pretty useless. Do bitwise OR, instead.

Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
---

 drivers/net/tokenring/smctr.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/drivers/net/tokenring/smctr.c
+++ b/drivers/net/tokenring/smctr.c
@@ -3413,7 +3413,7 @@ static int smctr_make_tx_status_code(struct net_device *dev,
         tsv->svi = TRANSMIT_STATUS_CODE;
         tsv->svl = S_TRANSMIT_STATUS_CODE;
 
-        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) || IBM_PASS_SOURCE_ADDR);
+        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) | IBM_PASS_SOURCE_ADDR);
 
         /* Stripped frame status of Transmitted Frame */
         tsv->svv[1] = tx_fstatus & 0xff;

> I'll most likely
> add a -Wboolean-logic-on-bit-constant to turn this warning on.

Ewww, more options. :-(

> Any reason why this wouldn't apply to octal constants or to GCC's new
> binary constants?  I can trivially modify this patch to handle those
> as well, just by dropping the check for an 'x' or 'X', and renaming the
> flag.

OK, let me try too.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Dobriyan <adobriyan () sw ! ru>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to
Date: Thu, 11 Oct 2007 07:35:37 +0000
Message-ID: <20071011073537.GA6697 () localhost ! sw ! ru>
--------------------
On Wed, Oct 10, 2007 at 04:45:46AM -0700, Josh Triplett wrote:
> Alexey Dobriyan wrote:
> > ["if (!x & y)" patch from yanzheng@]
> > ["if (!x & y)" patch from adobriyan@]
> > ["if (!x & y)" patches from viro@]
> > 
> > While we're at it, below is somewhat ugly sparse patch for detecting
> > "&& 0x" typos.
> 
> Excellent idea!  I think it applies to || as well.

Sadly, yes.

[PATCH] smctr: fix "|| 0x" typo

IBM_PASS_SOURCE_ADDR is 1, so logically ORing it with status bits is
pretty useless. Do bitwise OR, instead.

Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
---

 drivers/net/tokenring/smctr.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/drivers/net/tokenring/smctr.c
+++ b/drivers/net/tokenring/smctr.c
@@ -3413,7 +3413,7 @@ static int smctr_make_tx_status_code(struct net_device *dev,
         tsv->svi = TRANSMIT_STATUS_CODE;
         tsv->svl = S_TRANSMIT_STATUS_CODE;
 
-        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) || IBM_PASS_SOURCE_ADDR);
+        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) | IBM_PASS_SOURCE_ADDR);
 
         /* Stripped frame status of Transmitted Frame */
         tsv->svv[1] = tx_fstatus & 0xff;

> I'll most likely
> add a -Wboolean-logic-on-bit-constant to turn this warning on.

Ewww, more options. :-(

> Any reason why this wouldn't apply to octal constants or to GCC's new
> binary constants?  I can trivially modify this patch to handle those
> as well, just by dropping the check for an 'x' or 'X', and renaming the
> flag.

OK, let me try too.

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Kyle Moffett <mrmacman_g4 () mac ! com>
To: linux-sparse
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to
Date: Thu, 11 Oct 2007 09:00:55 +0000
Message-ID: <19B9D181-BE66-41E5-AA24-6EBB39660A1F () mac ! com>
--------------------
On Oct 11, 2007, at 03:35:37, Alexey Dobriyan wrote:
> Sadly, yes.
>
> [PATCH] smctr: fix "|| 0x" typo
>
> IBM_PASS_SOURCE_ADDR is 1, so logically ORing it with status bits is
> pretty useless. Do bitwise OR, instead.
>
> Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
> ---
>
>  drivers/net/tokenring/smctr.c |    2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
>
> --- a/drivers/net/tokenring/smctr.c
> +++ b/drivers/net/tokenring/smctr.c
> @@ -3413,7 +3413,7 @@ static int smctr_make_tx_status_code(struct  
> net_device *dev,
>          tsv->svi = TRANSMIT_STATUS_CODE;
>          tsv->svl = S_TRANSMIT_STATUS_CODE;
>
> -        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) ||  
> IBM_PASS_SOURCE_ADDR);
> +        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) |  
> IBM_PASS_SOURCE_ADDR);
>
>          /* Stripped frame status of Transmitted Frame */
>          tsv->svv[1] = tx_fstatus & 0xff;

Hmm, here's a question for you:  The old code was equivalent to "tsv- 
 >svv[0] = 1;", what's your proof that we don't rely on this "bug"  
elsewhere in the code?  In other words, this is a significant  
behavior change (albeit fixing an apparent bug) from what we've done  
for a while.  You might want to do a git-blame on this bit of code to  
see who the last person to modify it was and ask them to test or  
confirm the patch first.  The same general questions apply to the  
other logical-op bugs.

Cheers,
Kyle Moffett

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kyle Moffett <mrmacman_g4 () mac ! com>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to
Date: Thu, 11 Oct 2007 09:00:55 +0000
Message-ID: <19B9D181-BE66-41E5-AA24-6EBB39660A1F () mac ! com>
--------------------
On Oct 11, 2007, at 03:35:37, Alexey Dobriyan wrote:
> Sadly, yes.
>
> [PATCH] smctr: fix "|| 0x" typo
>
> IBM_PASS_SOURCE_ADDR is 1, so logically ORing it with status bits is
> pretty useless. Do bitwise OR, instead.
>
> Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
> ---
>
>  drivers/net/tokenring/smctr.c |    2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
>
> --- a/drivers/net/tokenring/smctr.c
> +++ b/drivers/net/tokenring/smctr.c
> @@ -3413,7 +3413,7 @@ static int smctr_make_tx_status_code(struct  
> net_device *dev,
>          tsv->svi = TRANSMIT_STATUS_CODE;
>          tsv->svl = S_TRANSMIT_STATUS_CODE;
>
> -        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) ||  
> IBM_PASS_SOURCE_ADDR);
> +        tsv->svv[0] = ((tx_fstatus & 0x0100 >> 6) |  
> IBM_PASS_SOURCE_ADDR);
>
>          /* Stripped frame status of Transmitted Frame */
>          tsv->svv[1] = tx_fstatus & 0xff;

Hmm, here's a question for you:  The old code was equivalent to "tsv- 
 >svv[0] = 1;", what's your proof that we don't rely on this "bug"  
elsewhere in the code?  In other words, this is a significant  
behavior change (albeit fixing an apparent bug) from what we've done  
for a while.  You might want to do a git-blame on this bit of code to  
see who the last person to modify it was and ask them to test or  
confirm the patch first.  The same general questions apply to the  
other logical-op bugs.

Cheers,
Kyle Moffett

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Alex Dubov <oakad () yahoo ! com>
To: linux-kernel
Subject: Re: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to
Date: Thu, 11 Oct 2007 13:57:42 +0000
Message-ID: <712072.37707.qm () web36702 ! mail ! mud ! yahoo ! com>
--------------------

--- Pierre Ossman <drzeus@drzeus.cx> wrote:

> On Wed, 10 Oct 2007 14:45:40 +0400
> Alexey Dobriyan <adobriyan@sw.ru> wrote:
> 
> > ["if (!x & y)" patch from yanzheng@]
> > ["if (!x & y)" patch from adobriyan@]
> > ["if (!x & y)" patches from viro@]
> > 
> > While we're at it, below is somewhat ugly sparse patch for detecting
> > "&& 0x" typos.
> > 
> 
> The maintainer for tifm is Alex Dubov, so cc:ing him.
> 
> > drivers/mmc/host/tifm_sd.c:183:9: warning: dubious && 0x
> > 
> > 	if ((r_data->flags & MMC_DATA_WRITE)
> >             && DATA_CARRY)
> > 		writel(host->bounce_buf_data[0],
> > 		host->dev->addr
> > 		+ SOCK_MMCSD_DATA);
> > 
> > 	given that DATA_CARRY is always used together with
> > ->cmd_flags, this place is asking for obvious fixlet:
> > 
> > 
> > [PATCH] tifm_sd.c: fix DATA_CARRY check
> > 
> > Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
> > ---
> > 
> >  drivers/mmc/host/tifm_sd.c |    2 +-
> >  1 file changed, 1 insertion(+), 1 deletion(-)
> > 
> > --- a/drivers/mmc/host/tifm_sd.c
> > +++ b/drivers/mmc/host/tifm_sd.c
> > @@ -180,7 +180,7 @@ static void tifm_sd_transfer_data(struct tifm_sd
> > *host) host->sg_pos++;
> >  			if (host->sg_pos == host->sg_len) {
> >  				if ((r_data->flags & MMC_DATA_WRITE)
> > -				    && DATA_CARRY)
> > +				    && (host->cmd_flags &
> > DATA_CARRY)) writel(host->bounce_buf_data[0],
> >  					       host->dev->addr
> >  					       + SOCK_MMCSD_DATA);
> > 
> > 
> > 
> 
> Rgds
> Pierre
> 

Oops. I wonder why this was never triggered (some users are having problems with dma, so they use
PIO rather extensively). The patch is probably correct, but I can't do any testing because I'm
currently on vacation.



      ____________________________________________________________________________________
Shape Yahoo! in your own image.  Join our Network Research Panel today!   http://surveylink.yahoo.com/gmrs/yahoo_panel_invite.asp?a=7 


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to -mm ===

From: Alexey Dobriyan <adobriyan () sw ! ru>
To: linux-kernel
Subject: idio{,ma}tic typos (was Re: + fix-vm_can_nonlinear-check-in-sys_remap_file_pages.patch added to -mm
Date: Wed, 10 Oct 2007 10:45:40 +0000
Message-ID: <20071010104540.GA6366 () localhost ! sw ! ru>
--------------------
["if (!x & y)" patch from yanzheng@]
["if (!x & y)" patch from adobriyan@]
["if (!x & y)" patches from viro@]

While we're at it, below is somewhat ugly sparse patch for detecting
"&& 0x" typos.

diff --git a/evaluate.c b/evaluate.c
index c0e9d17..186756b 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -877,6 +877,13 @@ static struct symbol *evaluate_logical(struct expression *expr)
 	if (!evaluate_conditional(expr->right, 0))
 		return NULL;
 
+	if (expr->op == SPECIAL_LOGICAL_AND) {
+		if (expr->left->type == EXPR_VALUE && expr->left->orig_in_hex)
+			warning(expr->pos, "dubious && 0x");
+		if (expr->right->type == EXPR_VALUE && expr->right->orig_in_hex)
+			warning(expr->pos, "dubious && 0x");
+	}
+
 	expr->ctype = &bool_ctype;
 	if (expr->flags) {
 		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
diff --git a/expression.c b/expression.c
index 289927a..9bcf586 100644
--- a/expression.c
+++ b/expression.c
@@ -361,6 +361,7 @@ got_it:
 	expr->flags = Int_const_expr;
         expr->ctype = ctype_integer(modifiers);
         expr->value = value;
+	expr->orig_in_hex = (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'));
 	return;
 Eoverflow:
 	error_die(expr->pos, "constant %s is too big even for unsigned long long",
@@ -70,6 +70,7 @@ struct expression {
 		struct {
 			unsigned long long value;
 			unsigned taint;
+			unsigned int orig_in_hex:1;
 		};
 
 		// EXPR_FVALUE


Here are wonders that it found:

drivers/media/video/se401.c:1283:13: warning: dubious && 0x

	if (!cp[2] && SE401_FORMAT_BAYER) {
		err("Bayer format not supported!");
		return 1;
	}

	known issue, I sent a patch about it.


drivers/mmc/host/tifm_sd.c:183:9: warning: dubious && 0x

	if ((r_data->flags & MMC_DATA_WRITE)
            && DATA_CARRY)
		writel(host->bounce_buf_data[0],
		host->dev->addr
		+ SOCK_MMCSD_DATA);

	given that DATA_CARRY is always used together with ->cmd_flags,
	this place is asking for obvious fixlet:


[PATCH] tifm_sd.c: fix DATA_CARRY check

Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
---

 drivers/mmc/host/tifm_sd.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/drivers/mmc/host/tifm_sd.c
+++ b/drivers/mmc/host/tifm_sd.c
@@ -180,7 +180,7 @@ static void tifm_sd_transfer_data(struct tifm_sd *host)
 			host->sg_pos++;
 			if (host->sg_pos == host->sg_len) {
 				if ((r_data->flags & MMC_DATA_WRITE)
-				    && DATA_CARRY)
+				    && (host->cmd_flags & DATA_CARRY))
 					writel(host->bounce_buf_data[0],
 					       host->dev->addr
 					       + SOCK_MMCSD_DATA);



drivers/net/wireless/arlan-main.c:439:3: warning: dubious && 0x
drivers/net/wireless/arlan-main.c:439:3: warning: dubious && 0x
drivers/net/wireless/arlan-main.c:439:3: warning: dubious && 0x
drivers/net/wireless/arlan-main.c:439:3: warning: dubious && 0x

	#define setPowerOff(dev){\ 
	   writeControlRegister(dev,readControlRegister(dev) |
	   (ARLAN_POWER && ARLAN_ACCESS));
	   		^^^


[PATCH] arlan: fix "x && y" typo

Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
---

 drivers/net/wireless/arlan.h |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/drivers/net/wireless/arlan.h
+++ b/drivers/net/wireless/arlan.h
@@ -485,7 +485,7 @@ struct arlan_private {
 #define clearClearInterrupt(dev){\
    writeControlRegister(dev,readControlRegister(dev) & ~ARLAN_CLEAR_INTERRUPT);}
 #define setPowerOff(dev){\
-   writeControlRegister(dev,readControlRegister(dev) | (ARLAN_POWER && ARLAN_ACCESS));\
+   writeControlRegister(dev,readControlRegister(dev) | (ARLAN_POWER & ARLAN_ACCESS));\
    writeControlRegister(dev,readControlRegister(dev) & ~ARLAN_ACCESS);}
 #define setPowerOn(dev){\
    writeControlRegister(dev,readControlRegister(dev) & ~(ARLAN_POWER));   }

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: looking for any examples of using sparse ===

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: looking for any examples of using sparse
Date: Sat, 28 Jul 2007 17:44:14 +0000
Message-ID: <20070728104414.ff81537a.rdunlap () xenotime ! net>
--------------------
On Wed, 9 May 2007 16:32:30 +0200 Mish Mash wrote:

> dear all,
> 
> I'm trying to use sparse for writing various source code analysis
> tools (I was using ctool previously). I'm currently going through the
> source trying to figure out what I need. Given the excessive amounts
> of comments I'm having to wade through, this probably isn't the
> fastest way of figuring the beast out ;)
> 
> Does anyone have any notes they've taken or can point me at code that
> uses sparse to help get a rough idea of how to use the beast? (Ideally
> slightly more detailed than Randy Dunlap's howto) I noticed smatch now
> uses sparse and i've applied their patch which I'm going over. Is
> there anything better? (I've already found the no longer very useful
> presentation at http://developer.osdl.org/dmo/sparse/)

[belated]

Hi,

My sparse howto was never meant to be a guide to sparse internals,
but agreed, something like that would be very helpful.

My sparse howto is really intended to be a basic/intro user guide since
I didn't find one anywhere else.  And I have just updated it --
comments/corrections welcome.

http://www.xenotime.net/linux/sparse/sparse_howto.txt

---
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: pointer arithmetics and casts ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: pointer arithmetics and casts
Date: Sat, 26 May 2007 15:45:51 +0000
Message-ID: <20070526154551.GS4095 () ftp ! linux ! org ! uk>
--------------------
On Fri, May 25, 2007 at 11:00:51PM +0100, Al Viro wrote:
> > But that means a fsckload of extra nodes allocated on pretty much any
> > program - use of arrays is not rare and indices tend to be int, so we
> > hit an extra allocated node on each such place.
> 
> Argh...  Question: how much do we care if we see BINOP[+] with 64bit
> type as result and 32bit type in one of the arguments?  That's what
> we get when we have
> 	char *p;
> 	int i;
> 
> 	p + i
> 
> with -m64.  IOW, how much does it violate the assumptions outside of
> frontend?  We do not allocate any new nodes if sizeof(*p) is 1...

Actually, turns out that at least on the kernel builds a straightforward
variant (IMPLIED_CAST when width of i is smaller than bits_in_pointer,
whatever sizeof(*p) might be) isn't visibly smaller...  It would need
more profiling, but there's a chance that nothing trickier would be
needed.

BTW, _Bool is seriously mishandled - for one thing, some places treat it 
as one-bit unsigned integer (i.e. (_Bool)2 becomes 0 with a warning, while
it should yield 1).  For another, sizeof(_Bool) becomes 0, with all obvious
breakage.  And finally, assignment of pointer to _Bool generates a warning
and cast.1 in linearizer.  Correct behaviour is (a) no warning whatsoever
and (b) replacement with b = (p != NULL).  The same thing applies in
passing arguments and in return statement, of course...

Oh, and type of comparison result is int, not _Bool...  It rarely matters,
but sometimes it does - e.g. sizeof(0 == 0) should evaluate to sizeof(int),
not sizeof(_Bool) (which basically casts the damn thing in stone - changing
the type of == result on valid C90 arguments would break existing programs).

I agree that use of bool_ctype in evaluate_compare() is very natural, but
we should at least take care interaction with sizeof ;-/
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: random line shuffling test ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: random line shuffling test
Date: Sun, 29 Jul 2007 11:33:20 +0000
Message-ID: <20070729113320.GA5784 () martell ! zuzino ! mipt ! ru>
--------------------
I'm currently running random line shuffling test taking, ha-ha, advansys.i
as input.

Here is first trimmed testcase on which valgrind says stack overflow and
sparse segfaults.


int a, struct b c);
typedef void (elevator_activate_req_fn)(foo *);
typedef void (elevator_activate_req_fn)(struct foo *);
struct sigaction {
static struct lock_class_key __key;



So far the joy is spoiled by many infinite loops sparse gets into and
automatic testing is still semi-automatic, but stay tuned.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: random line shuffling test
Date: Wed, 01 Aug 2007 17:09:08 +0000
Message-ID: <1185988148.3123.36.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Tue, 2007-07-31 at 00:42 +0400, Alexey Dobriyan wrote:
> On Sun, Jul 29, 2007 at 03:33:20PM +0400, Alexey Dobriyan wrote:
> > I'm currently running random line shuffling test taking, ha-ha, advansys.i
> > as input.
> > 
> > Here is first trimmed testcase on which valgrind says stack overflow and
> > sparse segfaults.
> > 
> > 
> > int a, struct b c);
> > typedef void (elevator_activate_req_fn)(foo *);
> > typedef void (elevator_activate_req_fn)(struct foo *);
> > struct sigaction {
> > static struct lock_class_key __key;
> > 
> > 
> > 
> > So far the joy is spoiled by many infinite loops sparse gets into and
> > automatic testing is still semi-automatic, but stay tuned.
> 
> Here is another:
> 
> 	__asm__("l" : "i" (1)
> 
> #0  0x080543e4 in mark_assigned (expr=0x1) at evaluate.c:1388
> #1  0x080544ba in evaluate_assign_to (left=0xb749c2cc, type=0x80da040) at evaluate.c:1421
> #2  0x08058556 in evaluate_asm_statement (stmt=0xb7582888) at evaluate.c:3160
> #3  0x08058c63 in evaluate_statement (stmt=0xb7582888) at evaluate.c:3342
> #4  0x08058093 in evaluate_symbol (sym=0xb747d20c) at evaluate.c:3041
> #5  0x080580e9 in evaluate_symbol_list (list=0xb7dac30c) at evaluate.c:3054
> #6  0x080510cf in sparse (filename=0xbf9ff164 "a.c") at lib.c:786
> #7  0x0804bdac in main

Fuzz testing on Sparse seems like an *excellent* idea; thank you for
doing this.  Nice finds.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: random line shuffling test
Date: Wed, 01 Aug 2007 17:09:08 +0000
Message-ID: <1185988148.3123.36.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Tue, 2007-07-31 at 00:42 +0400, Alexey Dobriyan wrote:
> On Sun, Jul 29, 2007 at 03:33:20PM +0400, Alexey Dobriyan wrote:
> > I'm currently running random line shuffling test taking, ha-ha, advansys.i
> > as input.
> > 
> > Here is first trimmed testcase on which valgrind says stack overflow and
> > sparse segfaults.
> > 
> > 
> > int a, struct b c);
> > typedef void (elevator_activate_req_fn)(foo *);
> > typedef void (elevator_activate_req_fn)(struct foo *);
> > struct sigaction {
> > static struct lock_class_key __key;
> > 
> > 
> > 
> > So far the joy is spoiled by many infinite loops sparse gets into and
> > automatic testing is still semi-automatic, but stay tuned.
> 
> Here is another:
> 
> 	__asm__("l" : "i" (1)
> 
> #0  0x080543e4 in mark_assigned (expr=0x1) at evaluate.c:1388
> #1  0x080544ba in evaluate_assign_to (left=0xb749c2cc, type=0x80da040) at evaluate.c:1421
> #2  0x08058556 in evaluate_asm_statement (stmt=0xb7582888) at evaluate.c:3160
> #3  0x08058c63 in evaluate_statement (stmt=0xb7582888) at evaluate.c:3342
> #4  0x08058093 in evaluate_symbol (sym=0xb747d20c) at evaluate.c:3041
> #5  0x080580e9 in evaluate_symbol_list (list=0xb7dac30c) at evaluate.c:3054
> #6  0x080510cf in sparse (filename=0xbf9ff164 "a.c") at lib.c:786
> #7  0x0804bdac in main

Fuzz testing on Sparse seems like an *excellent* idea; thank you for
doing this.  Nice finds.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: segfaults in pathological cases from gcc testsuite ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: Re: segfaults in pathological cases from gcc testsuite
Date: Sat, 27 Oct 2007 22:01:29 +0000
Message-ID: <20071027220129.GG9816 () martell ! zuzino ! mipt ! ru>
--------------------
On Mon, Oct 22, 2007 at 09:38:51AM -0700, Christopher Li wrote:
> On 10/22/07, Alexey Dobriyan <adobriyan@sw.ru> wrote:
> > FWIW, I fed full gcc tree to sparse not only testsuite. Suprisingly it
> > crashed only in two places:
> >
> >
> > --------------------------------------------------------
> > gcc/testsuite/gcc.c-torture/compile/limits-exprparen.c
> 
> I can't  reproduce it for me. What command line
> are you using?

ulimit -s 8192 actually. With 16384 it passes.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse 0.2 - incomprehensible context warnings ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse 0.2 - incomprehensible context warnings
Date: Wed, 31 Jan 2007 23:06:23 +0000
Message-ID: <20070131230623.GA28548 () chrisli ! org>
--------------------
It has been a while. I find out why during this happen during
I debugging my other interrupt checker.

_spin_unlock_irq() is a macro which will expand to __raw_spin_unlock(),
which inline into a function. But _spin_lock_irq is an external function
which does not inline.

So sparse only sees the unlock, it can't see the locking.

Chris

On Tue, Dec 05, 2006 at 11:07:10PM +0100, Ulrich Kunitz wrote:
> Hi,
> 
> I have tried sparse 0.2 for the zd1211rw WLAN driver, which I
> happen to contribute too.
> 
> I get numerous context imbalance warnings, that I don't
> understand. This is on an SMP (x86-64) build of a vanilla 2.6.19.
> I get the same warning on an SMP build of PPC32.
> 
> A simple example is:
> 
> /home/kunitz/zd1211/rw/zd_usb.c:1167:13: warning: context imbalance in 'disable_read_regs_int' - wrong count at exit
> 
> zd_usb.c
> 1167 static void disable_read_regs_int(struct zd_usb *usb)
> 1168 {
> 1169         struct zd_usb_interrupt *intr = &usb->intr;
> 1170
> 1171         spin_lock_irq(&intr->lock);
> 1172         intr->read_regs_enabled = 0;
> 1173         spin_unlock_irq(&intr->lock);
> 1174 }
> 
> Please set me on CC of the answer I'm not a regular reader of this
> list.
> 
> You will find the driver source in the kernel itself. I tested it
> however against my latest git tree, which is available from
> 
> git-clone http://deine-taler.de/zd1211/zd1211.git
> 
> -- 
> Uli Kunitz
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse as a compiler front-end ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: sparse as a compiler front-end
Date: Wed, 28 Feb 2007 01:36:14 +0000
Message-ID: <45E4DC8E.9000702 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig5025F87992AD378E87B74933
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Jeff Garzik wrote:
> Josh Triplett wrote:
>> From the spec file, I notice that you install the pkg-config file to
>> /usr/lib/pkgconfig (or equivalent), rather than /usr/share/pkgconfig (=
or
>> equivalent) as the Makefile does; any particular reason for that?
>=20
> The pkgconfig file describes an architecture-specific library, so it=20
> goes into /usr/lib/pkgconfig/$pkg.pc if its 32-bit (or the rare 64-bit =

> arch that uses /usr/lib), and it goes into /usr/lib64/pkgconfig/$pkg.pc=
=20
> if the library is 64-bit.
>=20
> /usr/share is not appropriate for architecture-specific data.

Latest sparse from Git now installs sparse.pc to $(LIBDIR)/pkgconfig (def=
ault
/usr/lib/pkgconfig).

Thanks,
Josh Triplett


--------------enig5025F87992AD378E87B74933
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFF5NyOGJuZRtD+evsRAhu2AKCAxMawUbXX9m5+ZHQx36Wd/QGErwCeIbdl
GeQGubZBYam9iOY8xD/rucQ=
=jTT+
-----END PGP SIGNATURE-----

--------------enig5025F87992AD378E87B74933--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse breakage (x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu) ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: sparse breakage (x86_64: Add vDSO for x86-64 with gettimeofday/clock_gettime/getcpu)
Date: Sun, 22 Jul 2007 17:28:56 +0000
Message-ID: <20070722172856.GC21668 () ftp ! linux ! org ! uk>
--------------------
On Sun, Jul 22, 2007 at 06:06:57PM +0100, Al Viro wrote:
> On Sun, Jul 22, 2007 at 08:08:09PM +0400, Alexey Dobriyan wrote:
> > Andi, with new vDSO code sparse fails to check with usual invocation here:
> 
> Fucks with CF and not in a good way...
> 
> CF := $(PROFILING) -mcmodel=small -fPIC -g0 -O2 -fasynchronous-unwind-tables -m64
> 
> $(obj)/vclock_gettime.o: CFLAGS = $(CF)
> $(obj)/vgetcpu.o: CFLAGS = $(CF)
> 
> s/CF/CCF/ in there (arch/x86_64/vdso/Makefile) fixes gcc problems; sparse
> ones remain and I'll look into that when I get some sleep (26 hours uptime
> right now).  I think I have a good idea of what's going on there, but
> I'd rather not touch that code until tonight.
> 
> For now just rename the variable in makefile (obviously the right thing
> to do) and that will give you sparse runs not aborted at that point.

Actually,

ed evaluate.c <<EOF
/evaluate_member_dereference
/examine_symbol_type/m/ctype =
w
q
EOF

ought to take care of sparse, AFAICS.  IOW, in evaluate_member_dereference()
we need to do examine_symbol_type(ctype) before checking ctype->type, etc.
As it is, we end up with SYM_TYPEOF node there and it's not expanded until
we'd checked if we have SYM_STRUCT.  We would, after expansion, but we don't
do it until too late.

I haven't checked if that's causes any regressions, but it looks
straightforward enough to be a plausible fix.  I won't test it until
tonight, though (see above).  Minimal testcase is
struct foo {int x;} v;
typeof(v) *p;
void bar(void)
{
        p->x = 0;
}
and any serious regression testing should get both the sparse tests and
comparing kernel builds with and without that fix...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse breakage triggered by rcu_read_lock() lockdep annotations ===

From: Alexey Dobriyan <adobriyan () sw ! ru>
To: linux-sparse
Subject: sparse breakage triggered by rcu_read_lock() lockdep annotations
Date: Tue, 16 Oct 2007 10:55:21 +0000
Message-ID: <20071016105521.GB6352 () localhost ! sw ! ru>
--------------------
FWIW, commit 851a67b825540a8e00c0be3ee25e4627ba8b133b
aka "lockdep: annotate rcu_read_{,un}lock{,_bh}"
causes sparse to trigger internal assertion in quite a few places over
allyesconfig run.

	sparse: flow.c:805: rewrite_parent_branch: Assertion `changed' failed.

Trimmed down testcase:

	void f(unsigned long ip);
	static void g(void)
	{
	        if (1) {
	              f(({ __label__ x; x: (unsigned long)&&x; }));
	        }
	        f(({ __label__ x; x: (unsigned long)&&x; }));
	}

#0  0x4001c410 in __kernel_vsyscall ()
(gdb) bt
#0  0x4001c410 in __kernel_vsyscall ()
#1  0x40050701 in raise () from /lib/libc.so.6
#2  0x40051e38 in abort () from /lib/libc.so.6
#3  0x40049fcc in __assert_fail () from /lib/libc.so.6
#4  0x08064947 in pack_basic_blocks (ep=0x411a1c6c) at flow.c:812
#5  0x0805ffbf in linearize_symbol (sym=0x4103ec8c) at linearize.c:2154
#6  0x080492a3 in main (argc=Cannot access memory at address 0x274d) at sparse.c:266

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Dobriyan <adobriyan () sw ! ru>
To: linux-kernel
Subject: sparse breakage triggered by rcu_read_lock() lockdep annotations
Date: Tue, 16 Oct 2007 10:55:21 +0000
Message-ID: <20071016105521.GB6352 () localhost ! sw ! ru>
--------------------
FWIW, commit 851a67b825540a8e00c0be3ee25e4627ba8b133b
aka "lockdep: annotate rcu_read_{,un}lock{,_bh}"
causes sparse to trigger internal assertion in quite a few places over
allyesconfig run.

	sparse: flow.c:805: rewrite_parent_branch: Assertion `changed' failed.

Trimmed down testcase:

	void f(unsigned long ip);
	static void g(void)
	{
	        if (1) {
	              f(({ __label__ x; x: (unsigned long)&&x; }));
	        }
	        f(({ __label__ x; x: (unsigned long)&&x; }));
	}

#0  0x4001c410 in __kernel_vsyscall ()
(gdb) bt
#0  0x4001c410 in __kernel_vsyscall ()
#1  0x40050701 in raise () from /lib/libc.so.6
#2  0x40051e38 in abort () from /lib/libc.so.6
#3  0x40049fcc in __assert_fail () from /lib/libc.so.6
#4  0x08064947 in pack_basic_blocks (ep=0x411a1c6c) at flow.c:812
#5  0x0805ffbf in linearize_symbol (sym=0x4103ec8c) at linearize.c:2154
#6  0x080492a3 in main (argc=Cannot access memory at address 0x274d) at sparse.c:266

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-kernel
Subject: Re: sparse breakage triggered by rcu_read_lock() lockdep annotations
Date: Thu, 18 Oct 2007 17:41:15 +0000
Message-ID: <47179ABB.9060104 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig591FEE2E43CC1C54566C6E09
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Alexey Dobriyan wrote:
> FWIW, commit 851a67b825540a8e00c0be3ee25e4627ba8b133b
> aka "lockdep: annotate rcu_read_{,un}lock{,_bh}"
> causes sparse to trigger internal assertion in quite a few places over
> allyesconfig run.
>=20
> 	sparse: flow.c:805: rewrite_parent_branch: Assertion `changed' failed.=

>=20
> Trimmed down testcase:
>=20
> 	void f(unsigned long ip);
> 	static void g(void)
> 	{
> 	        if (1) {
> 	              f(({ __label__ x; x: (unsigned long)&&x; }));
> 	        }
> 	        f(({ __label__ x; x: (unsigned long)&&x; }));
> 	}
>=20
> #0  0x4001c410 in __kernel_vsyscall ()
> (gdb) bt
> #0  0x4001c410 in __kernel_vsyscall ()
> #1  0x40050701 in raise () from /lib/libc.so.6
> #2  0x40051e38 in abort () from /lib/libc.so.6
> #3  0x40049fcc in __assert_fail () from /lib/libc.so.6
> #4  0x08064947 in pack_basic_blocks (ep=3D0x411a1c6c) at flow.c:812
> #5  0x0805ffbf in linearize_symbol (sym=3D0x4103ec8c) at linearize.c:21=
54
> #6  0x080492a3 in main (argc=3DCannot access memory at address 0x274d) =
at sparse.c:266

Thanks for the detailed report.  Looking into it now.

- Josh Triplett



--------------enig591FEE2E43CC1C54566C6E09
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHF5q7GJuZRtD+evsRAi+yAJwOuuybjXRRSIVtdhymlpK2YzTCaACfTeAv
o3T4QqwbeCF614dLCYgJIig=
=OlIi
-----END PGP SIGNATURE-----

--------------enig591FEE2E43CC1C54566C6E09--
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: sparse breakage triggered by rcu_read_lock() lockdep annotations
Date: Thu, 18 Oct 2007 17:41:15 +0000
Message-ID: <47179ABB.9060104 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig591FEE2E43CC1C54566C6E09
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Alexey Dobriyan wrote:
> FWIW, commit 851a67b825540a8e00c0be3ee25e4627ba8b133b
> aka "lockdep: annotate rcu_read_{,un}lock{,_bh}"
> causes sparse to trigger internal assertion in quite a few places over
> allyesconfig run.
>=20
> 	sparse: flow.c:805: rewrite_parent_branch: Assertion `changed' failed.=

>=20
> Trimmed down testcase:
>=20
> 	void f(unsigned long ip);
> 	static void g(void)
> 	{
> 	        if (1) {
> 	              f(({ __label__ x; x: (unsigned long)&&x; }));
> 	        }
> 	        f(({ __label__ x; x: (unsigned long)&&x; }));
> 	}
>=20
> #0  0x4001c410 in __kernel_vsyscall ()
> (gdb) bt
> #0  0x4001c410 in __kernel_vsyscall ()
> #1  0x40050701 in raise () from /lib/libc.so.6
> #2  0x40051e38 in abort () from /lib/libc.so.6
> #3  0x40049fcc in __assert_fail () from /lib/libc.so.6
> #4  0x08064947 in pack_basic_blocks (ep=3D0x411a1c6c) at flow.c:812
> #5  0x0805ffbf in linearize_symbol (sym=3D0x4103ec8c) at linearize.c:21=
54
> #6  0x080492a3 in main (argc=3DCannot access memory at address 0x274d) =
at sparse.c:266

Thanks for the detailed report.  Looking into it now.

- Josh Triplett



--------------enig591FEE2E43CC1C54566C6E09
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFHF5q7GJuZRtD+evsRAi+yAJwOuuybjXRRSIVtdhymlpK2YzTCaACfTeAv
o3T4QqwbeCF614dLCYgJIig=
=OlIi
-----END PGP SIGNATURE-----

--------------enig591FEE2E43CC1C54566C6E09--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Chris Li" <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: sparse breakage triggered by rcu_read_lock() lockdep annotations
Date: Fri, 19 Oct 2007 19:44:09 +0000
Message-ID: <70318cbf0710191244v59bed9fekbef0ae1fcda22a6a () mail ! gmail ! com>
--------------------
Err,

Sparse does not support the local label syntax yet. It just treats the
second label "x:" as the same as the first one. Then the linearize
code gets serious confused when it saw one label get define in two
places.

The fix seems not trivial from the first look.

Chris

On 10/16/07, Alexey Dobriyan <adobriyan@sw.ru> wrote:
> FWIW, commit 851a67b825540a8e00c0be3ee25e4627ba8b133b
> aka "lockdep: annotate rcu_read_{,un}lock{,_bh}"
> causes sparse to trigger internal assertion in quite a few places over
> allyesconfig run.
>
>         sparse: flow.c:805: rewrite_parent_branch: Assertion `changed' failed.
>
> Trimmed down testcase:
>
>         void f(unsigned long ip);
>         static void g(void)
>         {
>                 if (1) {
>                       f(({ __label__ x; x: (unsigned long)&&x; }));
>                 }
>                 f(({ __label__ x; x: (unsigned long)&&x; }));
>         }
>
> #0  0x4001c410 in __kernel_vsyscall ()
> (gdb) bt
> #0  0x4001c410 in __kernel_vsyscall ()
> #1  0x40050701 in raise () from /lib/libc.so.6
> #2  0x40051e38 in abort () from /lib/libc.so.6
> #3  0x40049fcc in __assert_fail () from /lib/libc.so.6
> #4  0x08064947 in pack_basic_blocks (ep=0x411a1c6c) at flow.c:812
> #5  0x0805ffbf in linearize_symbol (sym=0x4103ec8c) at linearize.c:2154
> #6  0x080492a3 in main (argc=Cannot access memory at address 0x274d) at sparse.c:266
>
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse context tags ===

From: "Russ Cox" <rsc () swtch ! com>
To: linux-sparse
Subject: sparse context tags
Date: Mon, 12 Mar 2007 22:37:34 +0000
Message-ID: <ee9e417a0703121537p49657eai662b3dce82c7af5d () mail ! gmail ! com>
--------------------
Is the optional leading context argument
(the x in __attribute__((context(x, 0, 1)))
documented anywhere?  Apologies if this is
a FAQ, but I've looked.

Failing that, can someone enlighten me about
why sparse doesn't find any problems with
the function bad() below?  I am using sparse-0.2.

Thanks.
Russ

---

#define __acquires(x) __attribute__((context(x, 0, 1)))
#define __releases(x) __attribute__((context(x, 1, 0)))

typedef struct redlock redlock_t;
typedef struct bluelock bluelock_t;

void redlock(redlock_t *r) __acquires(r);
void redunlock(redlock_t *r) __releases(r);

void bluelock(bluelock_t *b) __acquires(b);
void blueunlock(bluelock_t *b) __releases(b);

void
bad(redlock_t *r, bluelock_t *b)
{
	redlock(r);
	blueunlock(b);
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse context tags
Date: Tue, 13 Mar 2007 00:32:34 +0000
Message-ID: <20070313003234.GA4640 () chrisli ! org>
--------------------
On Mon, Mar 12, 2007 at 06:37:34PM -0400, Russ Cox wrote:
> Is the optional leading context argument
> (the x in __attribute__((context(x, 0, 1)))
> documented anywhere?  Apologies if this is
> a FAQ, but I've looked.

I don't know about the document. The x is mostly
for human reading currently. Sparse does not use
it yet.

> 
> Failing that, can someone enlighten me about
> why sparse doesn't find any problems with
> the function bad() below?  I am using sparse-0.2.

That is because sparse can't distinguish which lock is
acquired. It is actually hard to get that information.
Even though the expression is the same, the actual lock
might be different.

e.g.

redlock(foo->redlock);
foo = bar;
redunlock (foo->redlock);


Depend on the value of foo, even the same expression can
mean different locks.

So sparse currently just stack all the lock level into one place,
it will complain about any lock level that is has mismatch.


> void
> bad(redlock_t *r, bluelock_t *b)
> {
> 	redlock(r);
> 	blueunlock(b);
> }

Sparse sees:

Some lock acquired and some lock release exactly once in the function.
Nothing to complain.

How ever, if you do:

#define __acquires_red(x) __attribute__((context(x, 0, 1)))
#define __releases_red(x) __attribute__((context(x, 1, 0)))

#define __acquires_blue(x) __attribute__((context(x, 0, 1024)))
#define __releases_blue(x) __attribute__((context(x, 1024, 0)))

Assume your redlock level did not go up to 1024, then:

void redlock(redlock_t *r) __acquires_red(r);

void bluelock(redlock_t *r) __acquires_blue(r);
void blueunlock(redlock_t *r) __releases_blue(r);


You will get the complain about lock level not match at exit.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: sparse context tags
Date: Tue, 13 Mar 2007 01:31:06 +0000
Message-ID: <1173749466.13436.32.camel () dv>
--------------------
On Mon, 2007-03-12 at 17:32 -0700, Christopher Li wrote:

> That is because sparse can't distinguish which lock is
> acquired. It is actually hard to get that information.
> Even though the expression is the same, the actual lock
> might be different.
> 
> e.g.
> 
> redlock(foo->redlock);
> foo = bar;
> redunlock (foo->redlock);

Just an idea.  The Linux "runtime locking correctness validator" (see
Documentation/lockdep-design.txt in the Linux sources) distinguishes
between lock classes.

Sparse could use a similar approach.  I think it would not catch your
example, but it would catch a more realistic case when one lock is
acquired and another is released even by the same function with the same
attributes:

lock(foo->redlock);
lock(foo->bluelock);
unlock(foo->redlock);
unlock(foo->bluelock);

Lock class could be just a unique reference to a place where the lock
was declared.  That would put some limitations on what a lock could be
(an address of a variable or a field), but I think it's OK.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse ctags ===

From: "Aneesh Kumar" <aneesh.kumar () gmail ! com>
To: linux-sparse
Subject: sparse ctags
Date: Tue, 26 Jun 2007 08:57:54 +0000
Message-ID: <cc723f590706260145q708c4390kf5b6ccbaf84000ef () mail ! gmail ! com>
--------------------
Hi,

Is there a document how to use this ? Does this work on multiple files
? Looking at the source i see it opening tags in truncate mode

-aneesh
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: sparse ctags
Date: Mon, 06 Aug 2007 19:03:07 +0000
Message-ID: <1186426987.3089.27.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Tue, 2007-06-26 at 14:15 +0530, Aneesh Kumar wrote:
> Is there a document how to use this ? Does this work on multiple files
> ? Looking at the source i see it opening tags in truncate mode

No documentation, unfortunately.  The Sparse ctags doesn't take any
options.  It should work on multiple files by simply giving all the
files on one ctags command line, with something like:
ctags $(find -name '*.c')

However, it seems to have some problems at the moment running on even
*one* file:

$ ./ctags ctags.c
unknown symbol const namespace:2 type:17

$ ./ctags validation/context.c
unknown symbol const namespace:2 type:17

type 17 refers to SYM_KEYWORD, which seems consistent with "unknown
symbol const", though I don't know why ctags would look at const as a
symbol.

I've CCed Christopher Li, the author of the Sparse ctags implementation.
Chris, can you look into this problem and suggest a possible solution?

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse ctags
Date: Wed, 08 Aug 2007 09:30:30 +0000
Message-ID: <70318cbf0708080230j5278e787j8684aa7ae0aa400b () mail ! gmail ! com>
--------------------
On 8/6/07, Josh Triplett <josh@freedesktop.org> wrote:
>
> Looks like some enums grew new values and ctags didn't stay up to date.  I
> think this patch fixes that particular problem:
>
> diff --git a/ctags.c b/ctags.c
> index f5b8fc7..63f59a5 100644
> --- a/ctags.c
> +++ b/ctags.c
> @@ -111,6 +111,8 @@ static void examine_symbol(struct symbol *sym)
>                 return;
>         if (sym->ident && sym->ident->reserved)
>                 return;
> +       if (sym->type == SYM_KEYWORD)
> +               return;
>
>         add_tag(sym);
>         base = sym->ctype.base_type;
> @@ -158,6 +160,8 @@ static void examine_namespace(struct symbol *sym)
>                 return;
>
>         switch(sym->namespace) {
> +       case NS_KEYWORD:
> +               return;
>         case NS_LABEL:
>                 sym->kind = 'l';
>                 break;
>

That looks good to me.

> After some further investigation, I think ctags really shouldn't look at
> SYM_PREPROCESSOR or NS_PREPROCESSOR either.  I came up with the attached
> patch, which I will apply soon unless someone shouts.  Chris?

I think SYM_PREPROCESSOR is also used by macros with NS_MACRO.
You just need to strip out the NS_PREPROCESSOR. I guess you try to
skip the symbol with NS_SYMBOL: and SYM_PREPROCESSOR at the same
time.

I am not sure about the test for "sym->type == SYM_KEYWORD",
do you see some case trigger that?

Sorry, I just find out that I get drop out from the sparse mail list
for a while and miss
a lot of interesting discussions. Blame my mail server.

>
> This still doesn't fix running ctags on multiple files; ctags seems to get
> confused in much the same way sparse does when run on multiple files: it spews
> a pile of redefinition errors.

Should make sparse able to clean up itself. I will see what I can do.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse failure. ===

From: "Aneesh Kumar K.V" <aneesh.kumar () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: sparse failure.
Date: Thu, 18 Oct 2007 08:39:01 +0000
Message-ID: <471718D5.2080204 () linux ! vnet ! ibm ! com>
--------------------
sparse: flow.c:805: rewrite_parent_branch: Assertion `changed' failed.
/bin/sh: line 1: 24220 Aborted                 sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__CHECK_ENDIAN__ -D__i386__ -nostdinc -isystem /usr/lib/gcc/i386-redhat-linux/4.1.2/include -Wp,-MD,fs/ext4/.mballoc.o.d -nostdinc -isystem /usr/lib/gcc/i386-redhat-linux/4.1.2/include -D__KERNEL__ -Iinclude -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Os -pipe -msoft-float -mregparm=3 -freg-struct-return -mpreferred-stack-boundary=2 -march=i686 -mtune=pentium3 -mtune=generic -ffreestanding -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -Iinclude/asm-x86/mach-generic -Iinclude/asm-x86/mach-default -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -fno-stack-protector -Wdeclaration-after-statement -Wno-pointer-sign -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mballoc)" -D"KBUILD_MODNAME=KBUILD_STR(ext4dev)" fs/ext4/m
balloc.c
make[1]: *** [fs/ext4/mballoc.o] Error 134
make: *** [fs/ext4/] Error 2
[kvaneesh@llm59 linux-2.6.23-rc8]$ 



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse segfault in kernel -mm tree ===

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 01:53:22 +0000
Message-ID: <20070305175322.cbe0bb66.rdunlap () xenotime ! net>
--------------------
Hi,

sparse (latest git tarball from DaveJones) segfaults when
checking the 2.6.21-rc2-mm1 tree:


  CHECK   drivers/net/vioc/vioc_provision.c
/bin/sh: line 1:  4021 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__x86_64__ -m64 -nostdinc -isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -Wp,-MD,drivers/net/vioc/.vioc_provision.o.d -nostdinc -isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -D__KERNEL__ -Iinclude -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Os -mtune=generic -m64 -mno-red-zone -mcmodel=kernel -pipe -fno-reorder-blocks -Wno-sign-compare -fno-asynchronous-unwind-tables -funit-at-a-time -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -fno-stack-protector -Wdeclaration-after-statement -Wno-pointer-sign -DMODULE -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(vioc_provision)" -D"KBUILD_MODNAME=KBUILD_STR(vioc)" drivers/net/vioc/vioc_provision.c
make[3]: *** [drivers/net/vioc/vioc_provision.o] Error 139
make[2]: *** [drivers/net/vioc] Error 2
make[1]: *** [drivers/net] Error 2
make: *** [drivers] Error 2

sparse[4021]: segfault at 0000000000000050 rip 000000000040fd63 rsp 00007fff6e1cccb0 error 4

---
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 02:33:51 +0000
Message-ID: <20070306023351.GB31138 () chrisli ! org>
--------------------
Hmm, It does not happen on tip of git tree even on 64bit boxes.

I can't reproduce it with a script that copy your command line
for mm1 tree either. I need to modify the gcc include path.
But after that it pass fine.

Can you send me your .config file?

If you have other ways to narrow down the bug that will be great.

Sorry I am out of luck to reproduce it.

Chris


On Mon, Mar 05, 2007 at 05:53:22PM -0800, Randy Dunlap wrote:
> Hi,
> 
> sparse (latest git tarball from DaveJones) segfaults when
> checking the 2.6.21-rc2-mm1 tree:
> 
> 
>   CHECK   drivers/net/vioc/vioc_provision.c
> /bin/sh: line 1:  4021 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__x86_64__ -m64 -nostdinc -isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -Wp,-MD,drivers/net/vioc/.vioc_provision.o.d -nostdinc -isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -D__KERNEL__ -Iinclude -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Os -mtune=generic -m64 -mno-red-zone -mcmodel=kernel -pipe -fno-reorder-blocks -Wno-sign-compare -fno-asynchronous-unwind-tables -funit-at-a-time -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -fno-stack-protector -Wdeclaration-after-statement -Wno-pointer-sign -DMODULE -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(vioc_provision)" -D"KBUILD_MODNAME=KBUILD_STR(vioc)" drivers/net/vioc/vioc_provision.c
> make[3]: *** [drivers/net/vioc/vioc_provision.o] Error 139
> make[2]: *** [drivers/net/vioc] Error 2
> make[1]: *** [drivers/net] Error 2
> make: *** [drivers] Error 2
> 
> sparse[4021]: segfault at 0000000000000050 rip 000000000040fd63 rsp 00007fff6e1cccb0 error 4
> 
> ---
> ~Randy
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 05:04:16 +0000
Message-ID: <20070305210416.7b5c0a2a.rdunlap () xenotime ! net>
--------------------
On Mon, 5 Mar 2007 18:33:51 -0800 Christopher Li wrote:

> Hmm, It does not happen on tip of git tree even on 64bit boxes.

I'm on x86_64.

> I can't reproduce it with a script that copy your command line
> for mm1 tree either. I need to modify the gcc include path.
> But after that it pass fine.
> 
> Can you send me your .config file?

make allmodconfig

> If you have other ways to narrow down the bug that will be great.
> 
> Sorry I am out of luck to reproduce it.
> 
> Chris
> 
> 
> On Mon, Mar 05, 2007 at 05:53:22PM -0800, Randy Dunlap wrote:
> > Hi,
> > 
> > sparse (latest git tarball from DaveJones) segfaults when
> > checking the 2.6.21-rc2-mm1 tree:
> > 
> > 
> >   CHECK   drivers/net/vioc/vioc_provision.c
> > /bin/sh: line 1:  4021 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__x86_64__ -m64 -nostdinc -isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -Wp,-MD,drivers/net/vioc/.vioc_provision.o.d -nostdinc -isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -D__KERNEL__ -Iinclude -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Os -mtune=generic -m64 -mno-red-zone -mcmodel=kernel -pipe -fno-reorder-blocks -Wno-sign-compare -fno-asynchronous-unwind-tables -funit-at-a-time -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -fno-stack-protector -Wdeclaration-after-statement -Wno-pointer-sign -DMODULE -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(vioc_provision)" -D"KBUILD_MODNAME=KBUILD_STR(vioc)" drivers/net/vioc/vioc_provision.c
> > make[3]: *** [drivers/net/vioc/vioc_provision.o] Error 139
> > make[2]: *** [drivers/net/vioc] Error 2
> > make[1]: *** [drivers/net] Error 2
> > make: *** [drivers] Error 2
> > 
> > sparse[4021]: segfault at 0000000000000050 rip 000000000040fd63 rsp 00007fff6e1cccb0 error 4
> > 
> > ---

---
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 05:42:43 +0000
Message-ID: <20070306004243.lvpk4ss8w8okw4ss () webmail ! spamcop ! net>
--------------------
Quoting Randy Dunlap <rdunlap@xenotime.net>:
> > I can't reproduce it with a script that copy your command line
> > for mm1 tree either. I need to modify the gcc include path.
> > But after that it pass fine.
> >
> > Can you send me your .config file?
>
> make allmodconfig

There is a relatively easy way to get the problematic file.  Remove the
corresponding object file and run this in the Linux build tree:

make CC="gcc -save-temps -D__CHECKER__"

This will likely fail, but there will be a file with *.i extension that would
probably cause the same problem with sparse.  That file can be renamed back to
*.c, indented and, time permitting, reduced to a few lines.

--
Regards,
Pavel Roskin
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 18:19:37 +0000
Message-ID: <1173205177.32333.34.camel () dv>
--------------------
On Mon, 2007-03-05 at 22:40 -0800, Randy Dunlap wrote:
> On Tue,  6 Mar 2007 00:42:43 -0500 Pavel Roskin wrote:
> > There is a relatively easy way to get the problematic file.  Remove the
> > corresponding object file and run this in the Linux build tree:
> > 
> > make CC="gcc -save-temps -D__CHECKER__"
> > 
> > This will likely fail, but there will be a file with *.i extension that would
> > probably cause the same problem with sparse.  That file can be renamed back to
> > *.c, indented and, time permitting, reduced to a few lines.
> 
> Sorry, that's not giving me anything from drivers/net/vioc/.
> It dies on init/main.c:
> 
> init/main.c: At top level:
> init/main.c:431: warning: 'context' attribute directive ignored
> init/main.c:431: error: expected ',' or ';' before '{' token

My bad, sorry.  I tested in on a standalone driver.  Here's a version
tested on the actual kernel tree:

make CC="gcc -save-temps -D__CHECKER__" KBUILD_NOCMDDEP=1

KBUILD_NOCMDDEP=1 prevents rebuilding other files when CC changes.  If
you still get stuck on another file, please also add "-k" to the command
line.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 20:58:46 +0000
Message-ID: <20070306125846.0e3a684a.rdunlap () xenotime ! net>
--------------------
On Tue, 06 Mar 2007 13:19:37 -0500 Pavel Roskin wrote:

> On Mon, 2007-03-05 at 22:40 -0800, Randy Dunlap wrote:
> > On Tue,  6 Mar 2007 00:42:43 -0500 Pavel Roskin wrote:
> > > There is a relatively easy way to get the problematic file.  Remove the
> > > corresponding object file and run this in the Linux build tree:
> > > 
> > > make CC="gcc -save-temps -D__CHECKER__"
> > > 
> > > This will likely fail, but there will be a file with *.i extension that would
> > > probably cause the same problem with sparse.  That file can be renamed back to
> > > *.c, indented and, time permitting, reduced to a few lines.
> > 
> > Sorry, that's not giving me anything from drivers/net/vioc/.
> > It dies on init/main.c:
> > 
> > init/main.c: At top level:
> > init/main.c:431: warning: 'context' attribute directive ignored
> > init/main.c:431: error: expected ',' or ';' before '{' token
> 
> My bad, sorry.  I tested in on a standalone driver.  Here's a version
> tested on the actual kernel tree:
> 
> make CC="gcc -save-temps -D__CHECKER__" KBUILD_NOCMDDEP=1
> 
> KBUILD_NOCMDDEP=1 prevents rebuilding other files when CC changes.  If
> you still get stuck on another file, please also add "-k" to the command
> line.

OK, that produced a large .i file and running:
  sparse vioc_provision.i
does reproduce the segfault, so now I am cutting down the size of
the .i file, then I'll send it in.

Thanks.
---
~Randy
*** Remember to use Documentation/SubmitChecklist when testing your code ***
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 22:28:24 +0000
Message-ID: <70318cbf0703061428u138a64b2x117eebdb915be50 () mail ! gmail ! com>
--------------------
------=_Part_185733_17820055.1173220104576
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Here is my version base on your email.

I need to change the gcc include path though. But it does not crash on me.

I did not get crash on allmodconfig either.

Chris

On 3/6/07, Randy Dunlap <rdunlap@xenotime.net> wrote:
> On Tue, 06 Mar 2007 13:19:37 -0500 Pavel Roskin wrote:
> OK, that produced a large .i file and running:
>   sparse vioc_provision.i
> does reproduce the segfault, so now I am cutting down the size of
> the .i file, then I'll send it in.
>
> Thanks.

------=_Part_185733_17820055.1173220104576
Content-Type: application/x-sh; name=bad.sh
Content-Transfer-Encoding: base64
X-Attachment-Id: f_eyyvv43y
Content-Disposition: attachment; filename="bad.sh"

c3BhcnNlIC1EX19saW51eF9fIC1EbGludXggLURfX1NURENfXyAtRHVuaXggLURfX3VuaXhfXyAt
V2JpdHdpc2UgLURfX3g4Nl82NF9fIC1tNjQgLW5vc3RkaW5jIC1pc3lzdGVtIC91c3IvbGliL2dj
Yy94ODZfNjQtcmVkaGF0LWxpbnV4LzQuMS4xL2luY2x1ZGUgLVdwLC1NRCxkcml2ZXJzL25ldC92
aW9jLy52aW9jX3Byb3Zpc2lvbi5vLmQgLW5vc3RkaW5jIC1pc3lzdGVtIC91c3IvbGliL2djYy94
ODZfNjQtcmVkaGF0LWxpbnV4LzQuMS4xL2luY2x1ZGUgLURfX0tFUk5FTF9fIC1JaW5jbHVkZSAt
aW5jbHVkZSBpbmNsdWRlL2xpbnV4L2F1dG9jb25mLmggLVdhbGwgLVd1bmRlZiAtV3N0cmljdC1w
cm90b3R5cGVzIC1Xbm8tdHJpZ3JhcGhzIC1mbm8tc3RyaWN0LWFsaWFzaW5nIC1mbm8tY29tbW9u
IC1PcyAtbXR1bmU9Z2VuZXJpYyAtbTY0IC1tbm8tcmVkLXpvbmUgLW1jbW9kZWw9a2VybmVsIC1w
aXBlIC1mbm8tcmVvcmRlci1ibG9ja3MgLVduby1zaWduLWNvbXBhcmUgLWZuby1hc3luY2hyb25v
dXMtdW53aW5kLXRhYmxlcyAtZnVuaXQtYXQtYS10aW1lIC1tbm8tc3NlIC1tbm8tbW14IC1tbm8t
c3NlMiAtbW5vLTNkbm93IC1tYWNjdW11bGF0ZS1vdXRnb2luZy1hcmdzIC1EQ09ORklHX0FTX0NG
ST0xIC1EQ09ORklHX0FTX0NGSV9TSUdOQUxfRlJBTUU9MSAtZm5vLW9taXQtZnJhbWUtcG9pbnRl
ciAtZm5vLW9wdGltaXplLXNpYmxpbmctY2FsbHMgLWcgLWZuby1zdGFjay1wcm90ZWN0b3IgLVdk
ZWNsYXJhdGlvbi1hZnRlci1zdGF0ZW1lbnQgLVduby1wb2ludGVyLXNpZ24gLURNT0RVTEUgLUQi
S0JVSUxEX1NUUihzKT0jcyIgLUQiS0JVSUxEX0JBU0VOQU1FPUtCVUlMRF9TVFIodmlvY19wcm92
aXNpb24pIiAtRCJLQlVJTERfTU9ETkFNRT1LQlVJTERfU1RSKHZpb2MpIiBkcml2ZXJzL25ldC92
aW9jL3Zpb2NfcHJvdmlzaW9uLmMK
------=_Part_185733_17820055.1173220104576--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Tue, 06 Mar 2007 23:12:52 +0000
Message-ID: <20070306151252.239c58f8.rdunlap () xenotime ! net>
--------------------
On Tue, 6 Mar 2007 14:28:24 -0800 Christopher Li wrote:

> Here is my version base on your email.
> 
> I need to change the gcc include path though. But it does not crash on me.
> 
> I did not get crash on allmodconfig either.
> 
> Chris

Hi,
OK, uh, what did we expect from this?
I changed /redhat/ to /suse/ and lib to lib64.  Here's what I got:
(split into multiple lines for my email client)


/home/rddunlap/scripts/cli_bad.sh: line 1: 17720 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__x86_64__ -m64 -nostdinc -isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -Wp,-MD,drivers/net/vioc/.vioc_provision.o.d -nostdinc 
-isystem /usr/lib64/gcc/x86_64-suse-linux/4.1.0/include -D__KERNEL__ -Iinclude -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Os -mtune=generic -m64 -mno-red-zone -mcmodel=kernel -pipe -fno-reorder-blocks -Wno-sign-compare -fno-asynchronous-unwind-tables -funit-at-a-time -mno-sse -mno-mmx -mno-sse2 
-mno-3dnow -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -fno-stack-protector -Wdeclaration-after-statement -Wno-pointer-sign -DMODULE -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(vioc_provision)" -D"KBUILD_MODNAME=KBUILD_STR(vioc)" drivers/net/vioc/vioc_provision.c


It looks like the problem (as I experience it) is in
drivers/net/vioc/vioc_provision.c, in this struct:
(it just takes a boatload of header files to get to this)

	static struct vnic_prov_def vnic_set_0 = {
	.rxd_ring[0].buf_size = RXDQ_SMALL_ALLOC_BUFSIZE,
	.rxd_ring[0].entries = RXDQ_SMALL_ENTRIES,
	.rxd_ring[0].id = 0,
	.rxd_ring[0].state = 1,
	.rxd_ring[1].buf_size = RXDQ_STD_ALLOC_BUFSIZE,
	.rxd_ring[1].entries = RXDQ_STD_ENTRIES,
	.rxd_ring[1].id = 1,
	.rxd_ring[1].state = 1,
	.rxd_ring[2].buf_size = RXDQ_JUMBO_ALLOC_BUFSIZE,
	.rxd_ring[2].entries = RXDQ_JUMBO_ENTRIES,
	.rxd_ring[2].id = 2,
	.rxd_ring[2].state = 1,
	.tx_entries = TXQ_ENTRIES,.rxc_entries = RXC_ENTRIES,.rxc_id =
	    0,.rxc_intr_id = 0
};


but I'll keep reducing the size of the .i file to try to be
sure about this.



> On 3/6/07, Randy Dunlap <rdunlap@xenotime.net> wrote:
> > On Tue, 06 Mar 2007 13:19:37 -0500 Pavel Roskin wrote:
> > OK, that produced a large .i file and running:
> >   sparse vioc_provision.i
> > does reproduce the segfault, so now I am cutting down the size of
> > the .i file, then I'll send it in.


---
~Randy
*** Remember to use Documentation/SubmitChecklist when testing your code ***
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Wed, 07 Mar 2007 02:43:51 +0000
Message-ID: <118833cc0703061843s22d35a9ei17fd48f97fc7626a () mail ! gmail ! com>
--------------------
Try running sparse under valgrind to see if there is some memory
corruption at an
earlier stage.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Wed, 07 Mar 2007 03:02:04 +0000
Message-ID: <1173236524.5140.31.camel () dv>
--------------------
On Tue, 2007-03-06 at 21:43 -0500, Morten Welinder wrote:
> Try running sparse under valgrind to see if there is some memory
> corruption at an
> earlier stage.

Randy,

maybe you'll just post the .i file as is (perhaps compressed with
bzip2)?  It looks like your post has generated lots of interest, but
nobody can reproduce the problem.  It's a much bigger waste of bandwidth
to have others download the -mm kernel.

If the file is too large for the list, please send it to me, and I'll
put it online.  Or put that file on pastebin.com or turboupload.com.

If I can reproduce the bug, with or without valgrind, I'll reduce the
file to the minimal required for the bug to be see.  I did it before.

If sparse crashes for you only, then you'll need to debug it on your
system, and it doesn't matter how big the file is.  What matters is the
backtrace and other info from gdb.

-- 
Regards,
Pavel Roskin

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Wed, 07 Mar 2007 03:12:53 +0000
Message-ID: <70318cbf0703061912k73f19092p2f74ab7d4ae80afb () mail ! gmail ! com>
--------------------
It seems that you are missing this change:

user:        Christopher Li <sparse@chrisli.org>
date:        Thu Feb 22 18:28:23 2007 -0800
summary:     Fix the segfault when initializer has unknown symbol

diff -r 9c425042a094 -r d22e36f6c600 expand.c
--- a/expand.c  Wed Feb 21 14:05:52 2007 -0800
+++ b/expand.c  Thu Feb 22 18:28:23 2007 -0800
@@ -872,7 +872,7 @@ static void verify_nonoverlapping(struct
        struct expression *b;

        FOR_EACH_PTR(*list, b) {
-               if (a && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
+               if (a && a->ctype && a->ctype->bit_size &&
bit_offset(a) == bit_offset(b)) {
                        sparse_error(a->pos, "Initializer entry defined twice");
                        info(b->pos, "  also defined here");
                        return;

Many be the snapshot script need a restart again?

Chris

On 3/6/07, Randy Dunlap <rdunlap@xenotime.net> wrote:
> On Tue, 6 Mar 2007 14:28:24 -0800 Christopher Li wrote:
> 875                     if (a && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
> (gdb) bt
> #0  0x000000000040fd63 in expand_expression (expr=<value optimized out>)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Wed, 07 Mar 2007 03:51:56 +0000
Message-ID: <20070307035156.GC20706 () redhat ! com>
--------------------
On Tue, Mar 06, 2007 at 07:12:53PM -0800, Christopher Li wrote:
 > It seems that you are missing this change:
 > 
 > user:        Christopher Li <sparse@chrisli.org>
 > date:        Thu Feb 22 18:28:23 2007 -0800
 > summary:     Fix the segfault when initializer has unknown symbol
 > 
 > diff -r 9c425042a094 -r d22e36f6c600 expand.c
 > --- a/expand.c  Wed Feb 21 14:05:52 2007 -0800
 > +++ b/expand.c  Thu Feb 22 18:28:23 2007 -0800
 > @@ -872,7 +872,7 @@ static void verify_nonoverlapping(struct
 >         struct expression *b;
 > 
 >         FOR_EACH_PTR(*list, b) {
 > -               if (a && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
 > +               if (a && a->ctype && a->ctype->bit_size &&
 > bit_offset(a) == bit_offset(b)) {
 >                         sparse_error(a->pos, "Initializer entry defined twice");
 >                         info(b->pos, "  also defined here");
 >                         return;
 > 
 > Many be the snapshot script need a restart again?

Kicked. Should work again now.
(For something so trivial, that thing is really high maintainence :)

	Dave

-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Wed, 07 Mar 2007 04:13:17 +0000
Message-ID: <20070306201317.5acb11b6.rdunlap () xenotime ! net>
--------------------
On Tue, 6 Mar 2007 19:12:53 -0800 Christopher Li wrote:

> It seems that you are missing this change:
> 
> user:        Christopher Li <sparse@chrisli.org>
> date:        Thu Feb 22 18:28:23 2007 -0800
> summary:     Fix the segfault when initializer has unknown symbol
> 
> diff -r 9c425042a094 -r d22e36f6c600 expand.c
> --- a/expand.c  Wed Feb 21 14:05:52 2007 -0800
> +++ b/expand.c  Thu Feb 22 18:28:23 2007 -0800
> @@ -872,7 +872,7 @@ static void verify_nonoverlapping(struct
>         struct expression *b;
> 
>         FOR_EACH_PTR(*list, b) {
> -               if (a && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
> +               if (a && a->ctype && a->ctype->bit_size &&
> bit_offset(a) == bit_offset(b)) {
>                         sparse_error(a->pos, "Initializer entry defined twice");
>                         info(b->pos, "  also defined here");
>                         return;
> 
> Many be the snapshot script need a restart again?

Hi,
OK, I hope that's it.  I'll check it out soon.
If that doesn't fix it, I'll post the .i file.

Thanks.

> Chris
> 
> On 3/6/07, Randy Dunlap <rdunlap@xenotime.net> wrote:
> > On Tue, 6 Mar 2007 14:28:24 -0800 Christopher Li wrote:
> > 875                     if (a && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
> > (gdb) bt
> > #0  0x000000000040fd63 in expand_expression (expr=<value optimized out>)



---
~Randy
*** Remember to use Documentation/SubmitChecklist when testing your code ***
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: sparse segfault in kernel -mm tree
Date: Wed, 07 Mar 2007 04:27:42 +0000
Message-ID: <20070306202742.d1b8d658.rdunlap () xenotime ! net>
--------------------
On Tue, 6 Mar 2007 20:13:17 -0800 Randy Dunlap wrote:

> On Tue, 6 Mar 2007 19:12:53 -0800 Christopher Li wrote:
> 
> > It seems that you are missing this change:
> > 
> > user:        Christopher Li <sparse@chrisli.org>
> > date:        Thu Feb 22 18:28:23 2007 -0800
> > summary:     Fix the segfault when initializer has unknown symbol
> > 
> > diff -r 9c425042a094 -r d22e36f6c600 expand.c
> > --- a/expand.c  Wed Feb 21 14:05:52 2007 -0800
> > +++ b/expand.c  Thu Feb 22 18:28:23 2007 -0800
> > @@ -872,7 +872,7 @@ static void verify_nonoverlapping(struct
> >         struct expression *b;
> > 
> >         FOR_EACH_PTR(*list, b) {
> > -               if (a && a->ctype->bit_size && bit_offset(a) == bit_offset(b)) {
> > +               if (a && a->ctype && a->ctype->bit_size &&
> > bit_offset(a) == bit_offset(b)) {
> >                         sparse_error(a->pos, "Initializer entry defined twice");
> >                         info(b->pos, "  also defined here");
> >                         return;
> > 
> > Many be the snapshot script need a restart again?
> 
> Hi,
> OK, I hope that's it.  I'll check it out soon.
> If that doesn't fix it, I'll post the .i file.


Hi all,
Working now, thanks to Chris for his patch and noticing that I
didn't have it.  /me /kicks snapshots.  :)

Sorry about the troubles.
---
~Randy
*** Remember to use Documentation/SubmitChecklist when testing your code ***
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse segfault on ppc64. ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 06:36:00 +0000
Message-ID: <20070322063600.GD15364 () redhat ! com>
--------------------
I thought I'd see what happens if I hooked up sparse
to our daily builds of Linus' tree.
The answer: a segfault on ppc64.

/usr/lib/gcc/ppc64-redhat-linux/4.1.2/include/altivec.h:37:2: error: Use the "-maltivec" flag to enable PowerPC AltiVec support
drivers/md/raid6altivec1.c:41:16: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:41:16: error: got signed
drivers/md/raid6altivec1.c:50:45: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:50:45: error: got SHLBYTE
drivers/md/raid6altivec1.c:53:1: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:53:1: error: got }
drivers/md/raid6altivec1.c:64:2: error: Trying to use reserved word 'return' as identifier
drivers/md/raid6altivec1.c:64:20: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:64:20: error: got __builtin_vec_cmpgt
drivers/md/raid6altivec1.c:65:1: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:65:1: error: got }
drivers/md/raid6altivec1.c:77:12: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:77:12: error: got wd0
drivers/md/raid6altivec1.c:78:12: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:78:12: error: got x1d
drivers/md/raid6altivec1.c:84:10: error: Expected ) in function declarator
drivers/md/raid6altivec1.c:84:10: error: got =
drivers/md/raid6altivec1.c:84:2: error: Trying to use reserved word 'for' as identifier
drivers/md/raid6altivec1.c:84:18: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:84:18: error: got <
drivers/md/raid6altivec1.c:84:30: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:84:30: error: got +=
drivers/md/raid6altivec1.c:86:11: error: Expected ) in function declarator
drivers/md/raid6altivec1.c:86:11: error: got =
drivers/md/raid6altivec1.c:86:3: error: Trying to use reserved word 'for' as identifier
drivers/md/raid6altivec1.c:86:22: error: Expected ; at end of declaration
vers/md/raid6altivec1.c:86:22: error: got >=
drivers/md/raid6altivec1.c:86:30: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:86:30: error: got --
drivers/md/raid6altivec1.c:94:3: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:94:3: error: got }
drivers/md/raid6altivec1.c:96:15: error: Expected ) in nested declarator
drivers/md/raid6altivec1.c:96:15: error: got *
drivers/md/raid6altivec1.c:97:2: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:97:2: error: got }
drivers/md/raid6altivec1.c:107:2: error: Trying to use reserved word 'do' as identifier
drivers/md/raid6altivec1.c:107:2: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:107:2: error: got {
drivers/md/raid6altivec1.c:108:1: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:108:1: error: got }
drivers/md/raid6altivec1.c:80:7: error: undefined identifier 'disks'
drivers/md/raid6altivec1.c:80:2: error: symbol 'z0' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:7
5) - different signedness
drivers/md/raid6altivec1.c:81:6: error: undefined identifier 'dptr'
drivers/md/raid6altivec1.c:81:2: error: symbol 'p' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:74
) - different base types
drivers/md/raid6altivec1.c:82:6: error: undefined identifier 'dptr'
drivers/md/raid6altivec1.c:82:2: error: symbol 'q' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:74
) - different base types
drivers/md/raid6altivec1.c:84:16: error: symbol 'd' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:7
5) - different signedness
drivers/md/raid6altivec1.c:84:28: error: symbol 'd' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:7
5) - different signedness
drivers/md/raid6altivec1.c:86:20: error: symbol 'z' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:7
5) - different signedness
drivers/md/raid6altivec1.c:86:29: error: symbol 'z' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:7
5) - different signedness
drivers/md/raid6altivec1.c:88:10: error: undefined identifier '__builtin_vec_xor'
drivers/md/raid6altivec1.c:89:10: error: undefined identifier 'MASK'
drivers/md/raid6altivec1.c:90:10: error: undefined identifier 'SHLBYTE'
drivers/md/raid6altivec1.c:91:10: error: undefined identifier '__builtin_vec_and'
drivers/md/raid6altivec1.c:92:10: error: undefined identifier '__builtin_vec_xor'
drivers/md/raid6altivec1.c:93:10: error: undefined identifier '__builtin_vec_xor'
drivers/md/raid6altivec1.c:96:3: error: symbol 'unative_t' redeclared with different type (originally declared at drivers/md/raid6altiv
ec1.c:78) - different base types
drivers/md/raid6altivec1.c:124:2: error: undefined identifier 'raid6_altivec1_gen_syndrome'
/bin/sh: line 1: 22303 Segmentation fault      sparse-0.2/sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -m32 -D__po
werpc__ -D__powerpc32__ -nostdinc -isystem /usr/lib/gcc/ppc64-redhat-linux/4.1.2/include -Wp,-MD,drivers/md/.raid6altivec1.o.d -nostdin
c -isystem /usr/lib/gcc/ppc64-redhat-linux/4.1.2/include -D__KERNEL__ -Iinclude -include include/linux/autoconf.h -Iarch/powerpc -Iarch
/powerpc/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaratio
n -Wextra -Wno-unused-parameter -Wno-missing-field-initializers -Os -msoft-float -pipe -Iarch/powerpc -ffixed-r2 -mmultiple -mno-altive
c -funit-at-a-time -mstring -mcpu=powerpc -Wa,-maltivec -fomit-frame-pointer -g -fno-stack-protector -Wdeclaration-after-statement -Wno
-pointer-sign -maltivec -mabi=altivec -DMODULE -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(raid6altivec1)" -D"KBUILD_MODNAME=KBU
ILD_STR(raid456)" drivers/md/raid6altivec1.c
make[2]: *** [drivers/md/raid6altivec1.o] Error 139


Is this something new, or am I the first person dumb enough to try and
run sparse on non-x86 ?

	Dave

-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 07:03:54 +0000
Message-ID: <20070322070354.GA22151 () chrisli ! org>
--------------------
On Thu, Mar 22, 2007 at 07:33:44AM +0000, Al Viro wrote:
> Segfault is new (which version?); the fscking mess in altivec is not, but
> it (a) doesn't depend on host sparse is ran on; (b) shouldn't lead to
> segfaults.  Altivec extensions are undocumented and fortunately used only
> in one place in the tree.  You should get sparse errors, but it shouldn't
> die on those.

I think the segfault is likely to cause by my recent change in the parser.

Dave, can you get a backtrace of the segfault? Even better if you can
give me a small test case which I can reproduce it on x86.

My guess it is cause by the bad_ctype related changes.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 07:33:44 +0000
Message-ID: <20070322073344.GU4095 () ftp ! linux ! org ! uk>
--------------------
On Thu, Mar 22, 2007 at 02:36:00AM -0400, Dave Jones wrote:

> Is this something new, or am I the first person dumb enough to try and
> run sparse on non-x86 ?

Segfault is new (which version?); the fscking mess in altivec is not, but
it (a) doesn't depend on host sparse is ran on; (b) shouldn't lead to
segfaults.  Altivec extensions are undocumented and fortunately used only
in one place in the tree.  You should get sparse errors, but it shouldn't
die on those.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 15:56:51 +0000
Message-ID: <20070322155651.GG15364 () redhat ! com>
--------------------
On Thu, Mar 22, 2007 at 07:33:44AM +0000, Al Viro wrote:
 > On Thu, Mar 22, 2007 at 02:36:00AM -0400, Dave Jones wrote:
 > 
 > > Is this something new, or am I the first person dumb enough to try and
 > > run sparse on non-x86 ?
 > 
 > Segfault is new (which version?);

0.2

	Dave

-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 16:02:39 +0000
Message-ID: <20070322160238.GY4095 () ftp ! linux ! org ! uk>
--------------------
On Thu, Mar 22, 2007 at 11:56:51AM -0400, Dave Jones wrote:
> On Thu, Mar 22, 2007 at 07:33:44AM +0000, Al Viro wrote:
>  > On Thu, Mar 22, 2007 at 02:36:00AM -0400, Dave Jones wrote:
>  > 
>  > > Is this something new, or am I the first person dumb enough to try and
>  > > run sparse on non-x86 ?
>  > 
>  > Segfault is new (which version?);
> 
> 0.2

Could you run

make C=2 V=1 drivers/md/raid6altivec1.o

pick sparse invocation out of that and mail it *and* its output with -E
added to command line?  IOW, flags and preprocessed-by-sparse input...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 16:04:21 +0000
Message-ID: <20070322160421.GH15364 () redhat ! com>
--------------------
On Thu, Mar 22, 2007 at 12:03:54AM -0700, Christopher Li wrote:
 > On Thu, Mar 22, 2007 at 07:33:44AM +0000, Al Viro wrote:
 > > Segfault is new (which version?); the fscking mess in altivec is not, but
 > > it (a) doesn't depend on host sparse is ran on; (b) shouldn't lead to
 > > segfaults.  Altivec extensions are undocumented and fortunately used only
 > > in one place in the tree.  You should get sparse errors, but it shouldn't
 > > die on those.
 > 
 > I think the segfault is likely to cause by my recent change in the parser.
 > 
 > Dave, can you get a backtrace of the segfault? Even better if you can
 > give me a small test case which I can reproduce it on x86.

I did battle with our ppc64 buildhost last night to try and coax it
into giving me a coredump, no luck. And as I don't have gcc in that
chroot, I couldn't build it natively.  Given this is altivec stuff,
I didn't try building it on x86. At which point I admitted defeat
and turned in for the night ;)

I'll see if I can force it into something buildable on x86 later,
but first I'll see if I can get a useful shell on that buildhost
that I can run gcc & gdb in.

	Dave
-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 17:11:18 +0000
Message-ID: <20070322171118.GL15364 () redhat ! com>
--------------------
On Thu, Mar 22, 2007 at 12:03:54AM -0700, Christopher Li wrote:
 > On Thu, Mar 22, 2007 at 07:33:44AM +0000, Al Viro wrote:
 > > Segfault is new (which version?); the fscking mess in altivec is not, but
 > > it (a) doesn't depend on host sparse is ran on; (b) shouldn't lead to
 > > segfaults.  Altivec extensions are undocumented and fortunately used only
 > > in one place in the tree.  You should get sparse errors, but it shouldn't
 > > die on those.
 > 
 > I think the segfault is likely to cause by my recent change in the parser.
 > 
 > Dave, can you get a backtrace of the segfault? Even better if you can
 > give me a small test case which I can reproduce it on x86.
 > 
 > My guess it is cause by the bad_ctype related changes.

So the good news is that this only seems to affect 0.2
Current git doesn't segfault, but still emits lots of spew.

	Dave

make -f scripts/Makefile.build obj=drivers/md drivers/md/raid6altivec1.o
  sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise  -m64 -D__powerpc__ -D__powerpc64__  -nostdinc -isystem /usr/lib/gcc/powerpc64-linux/4.0.1/include -Wp,-MD,drivers/md/.raid6altivec1.o.d  -nostdinc -isystem /usr/lib/gcc/powerpc64-linux/4.0.1/include -D__KERNEL__ -Iinclude  -include include/linux/autoconf.h  -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wextra -Wno-unused-parameter -Wno-missing-field-initializers -Os -msoft-float -pipe -mminimal-toc -mtraceback=none  -mcall-aixdesc -mtune=power4 -mno-altivec -funit-at-a-time -mstring -Wa,-maltivec -fomit-frame-pointer -g  -Wdeclaration-after-statement -Wno-pointer-sign  -maltivec -mabi=altivec -DMODULE -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(raid6altivec1)"  -D"KBUILD_MODNAME=KBUILD_STR(raid456)" drivers/md/raid6altivec1.c ;
/usr/lib/gcc/powerpc64-linux/4.0.1/include/altivec.h:36:2: error: Use the "-maltivec" flag to enable PowerPC AltiVec support
drivers/md/raid6altivec1.c:41:16: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:41:16: error: got signed
drivers/md/raid6altivec1.c:50:45: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:50:45: error: got SHLBYTE
drivers/md/raid6altivec1.c:53:1: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:53:1: error: got }
drivers/md/raid6altivec1.c:64:2: error: Trying to use reserved word 'return' as identifier
drivers/md/raid6altivec1.c:64:20: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:64:20: error: got __builtin_choose_expr
drivers/md/raid6altivec1.c:65:1: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:65:1: error: got }
drivers/md/raid6altivec1.c:77:12: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:77:12: error: got wd0
drivers/md/raid6altivec1.c:78:12: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:78:12: error: got x1d
drivers/md/raid6altivec1.c:84:10: error: Expected ) in function declarator
drivers/md/raid6altivec1.c:84:10: error: got =
drivers/md/raid6altivec1.c:84:2: error: Trying to use reserved word 'for' as identifier
drivers/md/raid6altivec1.c:84:18: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:84:18: error: got <
drivers/md/raid6altivec1.c:84:30: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:84:30: error: got +=
drivers/md/raid6altivec1.c:86:11: error: Expected ) in function declarator
drivers/md/raid6altivec1.c:86:11: error: got =
drivers/md/raid6altivec1.c:86:3: error: Trying to use reserved word 'for' as identifier
drivers/md/raid6altivec1.c:86:22: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:86:22: error: got >=
drivers/md/raid6altivec1.c:86:30: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:86:30: error: got --
drivers/md/raid6altivec1.c:88:10: error: Expected , in __builtin_types_compatible_p
drivers/md/raid6altivec1.c:88:10: error: got float
drivers/md/raid6altivec1.c:91:10: error: Expected , in __builtin_types_compatible_p
drivers/md/raid6altivec1.c:91:10: error: got float
drivers/md/raid6altivec1.c:92:10: error: Expected , in __builtin_types_compatible_p
drivers/md/raid6altivec1.c:92:10: error: got float
drivers/md/raid6altivec1.c:93:10: error: Expected , in __builtin_types_compatible_p
drivers/md/raid6altivec1.c:93:10: error: got float
drivers/md/raid6altivec1.c:94:3: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:94:3: error: got }
drivers/md/raid6altivec1.c:96:15: error: Expected ) in nested declarator
drivers/md/raid6altivec1.c:96:15: error: got *
drivers/md/raid6altivec1.c:97:2: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:97:2: error: got }
drivers/md/raid6altivec1.c:107:2: error: Trying to use reserved word 'do' as identifier
drivers/md/raid6altivec1.c:107:2: error: Expected ; at end of declaration
drivers/md/raid6altivec1.c:107:2: error: got {
drivers/md/raid6altivec1.c:108:1: error: Expected ; end of type declaration
drivers/md/raid6altivec1.c:108:1: error: got }
drivers/md/raid6altivec1.c:80:7: error: undefined identifier 'disks'
drivers/md/raid6altivec1.c:80:2: error: symbol 'z0' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:75) - different signedness
drivers/md/raid6altivec1.c:81:6: error: undefined identifier 'dptr'
drivers/md/raid6altivec1.c:81:2: error: symbol 'p' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:74) - different base types
drivers/md/raid6altivec1.c:82:6: error: undefined identifier 'dptr'
drivers/md/raid6altivec1.c:82:2: error: symbol 'q' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:74) - different base types
drivers/md/raid6altivec1.c:84:16: error: symbol 'd' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:75) - different signedness
drivers/md/raid6altivec1.c:84:28: error: symbol 'd' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:75) - different signedness
drivers/md/raid6altivec1.c:86:20: error: symbol 'z' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:75) - different signedness
drivers/md/raid6altivec1.c:86:29: error: symbol 'z' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:75) - different signedness
drivers/md/raid6altivec1.c:89:10: error: undefined identifier 'MASK'
drivers/md/raid6altivec1.c:90:10: error: undefined identifier 'SHLBYTE'
drivers/md/raid6altivec1.c:96:3: error: symbol 'unative_t' redeclared with different type (originally declared at drivers/md/raid6altivec1.c:78) - different base types
drivers/md/raid6altivec1.c:124:2: error: undefined identifier 'raid6_altivec1_gen_syndrome'

-- 
http://www.codemonkey.org.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 22:10:51 +0000
Message-ID: <20070322221050.GC22151 () chrisli ! org>
--------------------
On Thu, Mar 22, 2007 at 01:11:18PM -0400, Dave Jones wrote:
> So the good news is that this only seems to affect 0.2
> Current git doesn't segfault, but still emits lots of spew.
> 
> 	Dave
> 
> /usr/lib/gcc/powerpc64-linux/4.0.1/include/altivec.h:36:2: error: Use the "-maltivec" flag to enable PowerPC AltiVec support
> drivers/md/raid6altivec1.c:41:16: error: Expected ; at end of declaration
> drivers/md/raid6altivec1.c:41:16: error: got signed

The spew is cause by the vector extension which sparse know nothing about.
It is kind of expected.

I found a few place the kernel use "vector" as declarator. This introduce
ambiguity in expression:

(vector char) { x, x }

We look at 'vector', we can't decide it is a type or node yet. Because 'vector'
can be use as symbol. We have to look at the next token to decide if this is
cast expression or not.

Do we want to support vector in sparse?

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse segfault on ppc64.
Date: Thu, 22 Mar 2007 22:16:12 +0000
Message-ID: <20070322221612.GD22151 () chrisli ! org>
--------------------
On Thu, Mar 22, 2007 at 12:59:11PM +0000, Al Viro wrote:
> On Thu, Mar 22, 2007 at 12:03:54AM -0700, Christopher Li wrote:
> Humm...  I don't see ppc segfaults with the current tree.  However, after
> merging the mainline sparse changes and looking for regressions on kernel
> allmodconfig builds, I'm seeing a lot of noise due to expression_error() use.
> What used to generate a single error now brings a cascade.  More often than

Can you show me some example of the duplicate error? I can't seem to hit it
in on x86. I do notice though there is a few context imbalance report on the
inline function instead of the caller site.

> not it's utterly pointless; actually, I can't find a single instance where
> additional errors would add any useful information...

The expression_error is not intend to report more error. It is try to avoid
test expr->ctype against zero all the time. We often have error path there is
some expression has NULL in ctype then sparse segfaulted.

We can work on clean up the duplicate warnings.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse using insane amounts of memory ===

From: "Darren Jenkins" <darrenrjenkins () gmail ! com>
To: linux-sparse
Subject: Re: sparse using insane amounts of memory
Date: Sat, 10 Mar 2007 05:05:08 +0000
Message-ID: <82faac5b0703092105x75149bcdx5813e18f96db8004 () mail ! gmail ! com>
--------------------
On 3/9/07, Linus Torvalds <torvalds@linux-foundation.org> wrote:
>
>
> On Thu, 8 Mar 2007, Linus Torvalds wrote:
> >
> > To check a value for being a nice range of consecutive bits, you can
> > simply do:
> >
> >       #define is_power_of_two(x) (!((x) & ((x)-1)))

There is already an inline for this in log2.h

/*
 *  Determine whether some value is a power of two, where zero is
 * *not* considered a power of two.
 */

static inline __attribute__((const))
bool is_power_of_2(unsigned long n)
{
	return (n != 0 && ((n & (n - 1)) == 0));
}

>  - 0 is special, and is generally considered to be a power of two (and
>    this is more fundamental than you'd think: it's not just fall-out from
>    the particular expression chosen, it is fundamentally *required* to
>    handle overflow, and you can think of 0 as 2**x, x > wordsize if that
>    makes you more comfortable with the notion that zero is a power-of-two
>    in any finite representation of 2's complement)
>
> The "zero is special" thing means that if you don't want to accept zero as
> a valid mask (it technically *is* a contiguous set of bits set - it's just
> the empty set) you'd need to check for it specially.

I guess the person who wrote it wasn't thinking discrete maths at the time.

Darren J.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: specifying custom attributes ===

From: "Mike Frysinger" <vapier.adi () gmail ! com>
To: linux-sparse
Subject: specifying custom attributes
Date: Thu, 02 Aug 2007 22:53:41 +0000
Message-ID: <8bd0f97a0708021553m6edaefccof086012f64b199a3 () mail ! gmail ! com>
--------------------
the Blackfin port has a few custom gcc attributes that annoys sparse:
include/asm/uaccess.h:63:77: error: attribute 'l1_text': unknown attribute

is there a way from the cmdline to specify a custom list of OK
attributes ?  i feel like adding these processor-specific attributes
to the source code may not be the way you guys wish to go ...
-mike
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: specifying custom attributes
Date: Fri, 03 Aug 2007 00:53:04 +0000
Message-ID: <1186102384.3081.39.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Thu, 2007-08-02 at 18:53 -0400, Mike Frysinger wrote:
> the Blackfin port has a few custom gcc attributes that annoys sparse:
> include/asm/uaccess.h:63:77: error: attribute 'l1_text': unknown attribute
> 
> is there a way from the cmdline to specify a custom list of OK
> attributes ?  i feel like adding these processor-specific attributes
> to the source code may not be the way you guys wish to go ...

Currently no.  It might make sense to add a way to turn off the "unknown
attribute" warning, like GCC's -Wno-attributes.

- Josh Triplett


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: what's with "symbol blah was not declared" ===

From: "Randy.Dunlap" <rdunlap () xenotime ! net>
To: linux-sparse
Subject: what's with "symbol blah was not declared"
Date: Fri, 31 Aug 2007 04:05:34 +0000
Message-ID: <Pine.LNX.4.64.0708302100090.26586 () shark ! he ! net>
--------------------

e.g., linux kernel source code: init/do_mounts.c, line 23 is:

int __initdata rd_doload;


and sparse (snapshot of 2007-08-31) says:

init/do_mounts.c:23:16: warning: symbol 'rd_doload' was not declared. Should it be static?



thanks,
-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: what's with "symbol blah was not declared"
Date: Fri, 31 Aug 2007 04:16:27 +0000
Message-ID: <20070831041627.GA22695 () uranus ! ravnborg ! org>
--------------------
On Thu, Aug 30, 2007 at 09:05:34PM -0700, Randy.Dunlap wrote:
> 
> e.g., linux kernel source code: init/do_mounts.c, line 23 is:
> 
> int __initdata rd_doload;
> 
> 
> and sparse (snapshot of 2007-08-31) says:
> 
> init/do_mounts.c:23:16: warning: symbol 'rd_doload' was not declared. 
> Should it be static?

IIRC this is because sparse did not see a "extern int rd_doload; in a .h file so
the symbol is most probarly not used outside do_mounts.c.
So it give a hint that this symbol could be made static.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

