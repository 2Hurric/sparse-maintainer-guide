--- Emails for Year 2008 ---

=== Thread: [No Subject] ===

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
using the same expression on accessing the locks. Let's put
aside that it is right assumption or not. From the back end side,
you should able to get to all the expression and verify they are
the same without doing much front end changes.

All the code for "expression is equal test" should be move to
back end using linearized byte code. As matter of fact, sparse
have a simple common expression eliminate already.

> Well, yeah, it's very simple, and that doesn't help. And it's not about
> cross-function checking either:
>
> extern spinlock_t a;
>
> spin_lock(&a);
> rcu_read_unlock()

As I said, it is simple and does not take into account of which symbol
take the lock. But using same expression is not solid either.
How about:
extern spinlock_t a;

spinlock_t *p = &a;

spin_lock(&a);
spin_unlock(p);

> will not result in an error which is a pain.
>
>> The new context checking seems able to do more features.
>> But it has too many sore spots. I vote for back it out.
>
> I don't care, I don't have any more cycles to burn on this. For all I'm
> concerned it works pretty well and is a HUGE improvement over the
> current sparse which
>  * doesn't tell you what line the error really is in, it only warns
>   about the last line of the function
>  * isn't able to check different contexts despite documenting it
>   (see above)

You should able to do the same thing in the linearized back byte code.
You just linearized the context expression using pseudo. Then on
the checker side you can use the byte code to evaluate the expression
is same or not, by comparing expression instructions.
You can even get around the p=&a problem I mention above because
in the linearized byte code level, you can do some real data flow
analyze.

I think it is unnecessary to change the front end code to track
expression. In the back end you can do that much better.
That is the main reason I object to this patch.

>> I am not saying that annotation is not useful. I agree source
>> code annotation helps on the source code reading. But it
>
> Actually, I kinda disagree. Annotating *each and every function* with
> the locks it requires is _very_ useful, not just for sparse but also for
> human readers of the code. Hence, I don't just want sparse to check
> across functions, I want to be able to tell people what to do for
> calling a given function as well. The fact that sparse can check my
> annotations is great, but having them would be useful without that as
> well.

I don't think we have disagreement here. I do agree having source
code annotation is good for human reading. Please read my email.
But that shouldn't stop you having the checker to understand your code.

Even better, how do you know your annotation is in sync with your
code? You can have the checker to warn you that your annotation
is not in sync with code.

>
>
> It used to be like that. But I'm arguing (and others backed me up on
> this) that inlines are really just functions and as such should be
> annotated, not magically inlined into the code and then checked as
> sparse behaves right now.

First of all, I am just give it as example of idea how this problem can
be solved.

About annotate inline function or not, I don't have strong preference
against it. But I can see it is imposing a burden to maintain the additional
annotation. Now you update the code and you have to update the annotation
as well. You require developers who write new function to understand
the spase context checking and maintain the annotation as well.
You are creating addition work for kernel developers.

> Please don't focus on cross-function checking so much. Having different
> contexts is way more desirable, and cross-function checking probably is
> _not_ desirable in that you _want_ the annotations.

That is not what I said, you can keep your precious annotations for
human reading. But that does not mean sparse checker should limited
itself to only using annotations if it can be smarter about it.

Having cross-function checking is not exclusive to the annotations.
But having cross-function checking can enable some very useful
feature which we can't do right now.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re:
Date: Thu, 13 Mar 2008 19:09:10 +0000
Message-ID: <47D97BD6.8050408 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig0780C83A8CC2B1E49319918A
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

rajika@cse.mrt.ac.lk wrote:
> Is there is any guide which describe how to use sparse to parse a C sou=
rce file.
> I went through README, FAQ and searched the archived but unable to find=
 any
> guide which describe how to use this. I found some information in the R=
EADME
> file, is that the only information available?

You might also look at the manpages for sparse and cgcc.  If you just
want to run the sparse static analysis tool on your source code, those
manpages should tell you everything you need to know.  If you want to
use Sparse to parse C source code for some other purpose, then either
try c2xml or write some code linking to libsparse; documentation on
both of those alternatives still needs writing, but you can find
examples in the Sparse source code.

- Josh Triplett


--------------enig0780C83A8CC2B1E49319918A
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFH2XvXGJuZRtD+evsRAgSjAJ4+XihjfmXWe2HFYmIoCWvrtHqK2QCggjK4
WYdQlE9VxwdotlbRAftGFIU=
=GAKb
-----END PGP SIGNATURE-----

--------------enig0780C83A8CC2B1E49319918A--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: ./graph | dot > bad.png ===

From: Reza Roboubi <reza () earthdetails ! com>
To: linux-sparse
Subject: ./graph | dot > bad.png
Date: Thu, 31 Jan 2008 20:13:05 +0000
Message-ID: <47A22BD1.9020101 () earthdetails ! com>
--------------------
I'm not quite sure how to read this png file, it doesn't
look right. (The call arrows should go out of lines 10 and 11, no?)
http://reza.parvan.net/public/graph.png
And here's the command line:
./graph mytest.c |./gvpr/return-paths |./gvpr/subg-fwd -a main|\
dot -Tpng > graph.png
http://reza.parvan.net/public/mytest.c

Thanks.

Reza.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Reza Roboubi <reza () earthdetails ! com>
To: linux-sparse
Subject: Re: ./graph | dot > bad.png
Date: Thu, 31 Jan 2008 20:17:31 +0000
Message-ID: <47A22CDB.8030307 () earthdetails ! com>
--------------------
Reza Roboubi wrote:
> I'm not quite sure how to read this png file, it doesn't
> look right. (The call arrows should go out of lines 10 and 11, no?)
> http://reza.parvan.net/public/graph.png
> And here's the command line:
> ./graph mytest.c |./gvpr/return-paths |./gvpr/subg-fwd -a main|\

Oh I see, it's the subgraph that's being forwarded.  Great. Thanks.

Reza.

> dot -Tpng > graph.png
> http://reza.parvan.net/public/mytest.c
> 
> Thanks.
> 
> Reza.
> 

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: =?UTF-8?Q?=EF=BB=BFwarning=3A?= cast adds address space to ===

From: Jaswinder Singh <jaswinder () infradead ! org>
To: linux-sparse
Subject: =?UTF-8?Q?=EF=BB=BFwarning=3A?= cast adds address space to
Date: Sat, 12 Jul 2008 08:57:43 +0000
Message-ID: <1215853026.19076.32.camel () jaswinder ! satnam>
--------------------
Hello all,

I am trying to solve sparse warnings in kernel.

ï»¿Please let me know how can I solve following sparse warning :-

ï»¿warning: cast adds address space to expression

Is this a warning or a Info.

If any sparse documentation is available, please let me know.

Thank you,

Jaswinder Singh.

ï»¿

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: =?utf-8?b?77u/d2FybmluZzo=?= cast adds address space to ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: =?utf-8?b?77u/d2FybmluZzo=?= cast adds address space to
Date: Sat, 12 Jul 2008 15:17:03 +0000
Message-ID: <20080712111703.gjlzw6ns0k88844w-cebfxv () webmail ! spamcop ! net>
--------------------
Quoting Jaswinder Singh <jaswinder@infradead.org>:

> Hello all,
>
> I am trying to solve sparse warnings in kernel.
>
> ï»¿Please let me know how can I solve following sparse warning :-
>
> ï»¿warning: cast adds address space to expression
>
> Is this a warning or a Info.

It's a warning.  The code must be doing something like this:

void *addr1;
void __iomem *addr2;

addr2 = (void __iomem *) addr1;

> If any sparse documentation is available, please let me know.

I don't think you need sparse documentation to resolve it.  Sparse  
only detected a bad cast, but fixing it requires deeper understanding  
of the code, not of the warning.

You should look at the expression and see if the value before cast  
needs the attribute, or the value after the cast doesn't need the  
attribute.

The meanings of attributes in Linux are:

__user - pointer to data that came from the userspace
__iomem - pointer to a device I/O area (ports or I/O memory)

There are functions that deal with such pointers.  The code you are  
dealing with may be trying to circumvent those functions.

Further questions are better asked in Linux specific lists with more  
details of the code.  Please note that you should understand the code  
to fix it.  Just fixing the warning without understanding the problem  
is defeating the whole purpose of sparse.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: A few notes on how I see the whole process working. ===

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: A few notes on how I see the whole process working.
Date: Thu, 24 Apr 2008 20:15:24 +0000
Message-ID: <f19298770804241315wca6a214x23a863c6fceb6009 () mail ! gmail ! com>
--------------------
Hello.

This discussion began in private, but we agreed that it would be better
to move it to the mailing list.

On Mon, Apr 21, 2008 at 4:28 PM, Josh Triplett <josh@kernel.org> wrote:
> Alexey Zaytsev wrote:
>  > Design.
>  >
>  >         When sparse is run as compiler by the build system,
>  > it creates a "sparse object" file, which name is derived from
>  > the output object file name, say file.o.sparse. When the
>  > sparse linker is run, the data from a number of input "sparse
>  > object" files is combined into the output "sparse object"
>  > file, associated with the resulting output object file,
>  > library or executable.
>
>  Sounds reasonable.  For the compile stage, cgcc could have sparse
>  generate file.o.sparse, and allow the real compiler to generate file.o
>  as it currently does.

Yes, this is what I was thinking about. Initially I did not aim at
preserving the real binary creation, but after realizing how easy
it is to implement it, I see no reason not doing it.

>
>
>  >         What data I see essential to be present in the "sparse
>  > object" files:
>  >
>  >         - A list of source files from which the sparse object
>  >           file was built, including for each file the following
>  >           data:
>  >                 - Path to the source file
>  >                 - Path to the build directory
>  >                 - Options passed to the compiler
>
>  How would these get used?
>

We need this data in order to be able to parse the source file,
should the symbol table user wish to.The first component is
obviously needed, the second and the third are needed to
resolve #includes and to pass the proper -D's.

>
>  >         - A list of required shared libraries.
>
>  How would this get used?
>

Well, to resolve the external symbols? The user would load the
symbol table file, see there are undefined symbols, and if he
wishes to look at them, he would locate the .sparse file associated
with the required library and load it too. Or do you propose to
add this data to the output file at the "link" time? Might work.
We will have to rebuild the whole thing after each shared library
change, though.

>
>  >         - A list of symbols, including for each symbol:
>  >                 - Name
>  >                 - Current section of residence, if defined.
>  >                 - Type
>  >                 - Scope
>  >                 - Address, if any assigned.
>
>  Sounds reasonable.
>
>
>  >                 - Pointer into the source file table, if the
>  >                   symbol originates from a source file or
>  >                   pointer into the shared library table.
>  >                   (or just null)
>
>  How would this get used?

This lets the user decide which symbols he wants to look at, and
parse the corresponding files.

>
>
>  >                 - (maybe something else I've missed?)
>
>  Most of the things in a sparse "struct symbol" would probably prove
>  useful, I suspect.
>
May be. I'm still not really familiar with the sparse internals.

>  Eventually we will probably want something like the linearized
>  bytecode.
>

While I generally agree the we need to do something like

sparse -> intermediate data -> checker

the intermediate format is a bit unclear to me. It has to be verbose
enough to loose no essential information, and still be practical.
If by linearized bytecode you mean something like what we get
running sparse -ventry, this is clearly not going to work. As an
example, suppose you wish to check that local_irqsave() and
local_irqrestore() are balanced. This means, the checker actually
wants to look at the original source code, not even at the
pre-processed C code.

So, suggestions on the intermediate format are welcome.

>
>  >         This should work for object files, executables and shared
>  > libraries. And it should be trivial to extend the idea to work for
>  > static libraries.
>
>  You mean that you want to build libfoo.so.sparse, libfoo.a.sparse,
>  foo.sparse, and so on?  That sounds good.
>

Yes, for any output binary, we should provide a .sparse file.

>
>  >         An other option was to include the data into the binaries,
>  > probably into some new section.
>
>  Right, the approach which has come up on the list a few times, and
>  which we talked about in the comments on your SoC proposal.
>
>
>  > This approach lets you automatically
>  > get the sparse symbol tables, associated with the built libraries,
>  > installed into your system. Without even touching the build
>  > environment. But I'm not sure it is worth the added complexity. The
>  > symbol table should be appended to any object file built, and then
>  > extracted every time the object files are built into libraries or
>  > executables, and recreated anew. Also this would embarrass the
>  > linker debugging, as it gets harder to look at the generated symbol
>  > tables, and even non-trivial to tell if a binary has an associated
>  > symbol table. And in the end, we still need to keep the source tree
>  > around, as the symbol tables alone are not enough to perform any
>  > useful checks.
>  >         Maybe when we agree on some intermediate format to store
>  > the parsed file data, it would be worth appending this data to the the
>  > symbol table and include the result into the binary to be able to throw
>  > away the source tree. This needs further evaluation, so I'll take the
>  > easy path until things get certain.
>
>  I agree that this approach does not necessarily seem worthwhile.  Your
>  proposal to build *.sparse files seems simpler and yet equally
>  functional.
>
>  However, you mentioned that "we still need to keep the source tree
>  around, as the symbol tables alone are not enough to perform any
>  useful checks."; why not just write out the necessary information,
>  rather than re-parsing the source tree?
>
>  Note that we don't need to have some agreed-upon intermediate format;
>  for now, anything the Sparse compiler can write and the Sparse linker
>  can read will do, and I see no need to standardize it right now.
>
Yes, see above. This is what I hope will eventually happen. The question
is, when?

>
>  > Implementation.
>  >
>  >         Just some wild idea. We can let sparse, when run as the
>  > compiler, generate C code, with structures containing the "sparse
>  > object" data, like.
>  >
>  > struct sparse_file {
>  >         char *file_path;
>  >         char *build_path;
>  >         char *build_options;
>  > };
>  >
>  > struct sparse_symbol {
>  >         char *name;
>  >         char *section;
>  >         struct sparse_file *file;
>  >         ...
>  > };
>  >
>  > struct sparse_file *file_list = {
>  >         {
>  >                 ...
>  >         },
>  > };
>  >
>  > struct sparse_symbol *symbol_list = {
>  >         {
>  >                 ...
>  >         },
>  >         {
>  >                 ...
>  >         },
>  > };
>  >
>  >         The cgcc then could call the host compiler to build a shared
>  > library from the generated code. A consumer could use dlopen() to
>  > access the data in an efficient way. The "sparse linker", when run
>  > on the "sparse object" files, would collect the data from the input
>  > files, and build the output tables, just like a binary linker does.
>  > With this approach, the consumer will get the data in the most
>  > efficient and simple way. No need to parse the symbol tables. With
>  > some object naming tricks, we could even make ld.so resolve all the
>  > dependencies, but I'd like to keep the flexibility and resolve them
>  > manually.
>
>  Not a bad idea.  I'd suggest proposing it to the Sparse list to see
>  what others think.
>
>  On the other hand, it doesn't seem that difficult to just write out
>  all the structures to a file and read them back in.  This wouldn't
>  require parsing, just input and output of binary structures.
>

This would limit us only to structures containing no pointers. If we are going
to follow the pointers, this is not much different from generating C code.
And the C code has the benefit of being human-readable, so you could
use a text editor to look at the generated symbol tables, which I'm sure will
turn very handy for debugging the linker.

>
>  > On the time line.
>  >
>  > As I said, I expect this work to take no more than a month. But I'll
>  > be paragliding in Ukraine from around April 28 - May 11, and then
>  > there will be time to prepare for the exams. So I'd expect some
>  > working code towards the end of May, and a fully functional version
>  > somewhere in July (assuming I won't screw my neck while on the
>  > vacation ;). Ok?

s/July/June/ of course.

>
>  That sounds reasonable, since the official "start of coding" date
>  occurs on May 26th.  However, I'd like to see a rough prototype
>  earlier rather than later.  Please note that starting no later than
>  May 26th, I'd like to hear from you at least once a week about how
>  your project goes.

One think that could take some time might be the linker script parsing.
Probably will have to learn yacc. Any suggestions?

>
>  Good luck with your project and with your paragliding.
>
>  - Josh Triplett
>
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Chris Li" <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: A few notes on how I see the whole process working.
Date: Mon, 28 Apr 2008 20:29:11 +0000
Message-ID: <70318cbf0804281329j416eb99bxf1c74e38bfa97296 () mail ! gmail ! com>
--------------------
On Mon, Apr 28, 2008 at 12:12 AM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:
>
>  I still don't buy the bytecode idea, but it seems that the macros are
>  not actually lost after being pre-processed, which was my main concern
>  against even thinking about dumping the sparse internal representation
>  into the generated sparse object files. Still wandering in the dark. Will
>  look closed when return.
>
I think the whole point of dumping the sparse output is dumping the
linearized byte code and it can be load from a later time.  If some information
is missing from the current byte code, you can add annotate byte code
instruction.
e.g. the inlined call instruction is add for the reason to identify
which code are inserted
by he inline function call. You can certainly do that for macro if you
really want. The sparse
checker is not really using the macro right now.

The sparse checker currently is running on the linearized byte code. What other
internal representation do you need?


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Adding type information to instructions ===

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Adding type information to instructions
Date: Fri, 04 Jul 2008 23:43:24 +0000
Message-ID: <486EB59C.100 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigFD63256230295195B38DE98A
Content-Type: multipart/mixed;
 boundary="------------070509020402010206020203"

This is a multi-part message in MIME format.
--------------070509020402010206020203
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I've been having trouble finding the types of pseudos; the approach I've
been using, which is to follow the chain of pseudo's definers until I
find an instruction with enough type information to use, turns out to
fail utterly on OP_LOAD instructions; I can't find any way of getting
enough information from the opcode's arguments to determine the type of
the target.

As a result, I've had to make a minor patch to the lineariser code.
Given that the lineariser knows the information I need at the point
where it generates the instruction, it would seem to make sense to tag
the instruction with the type. This is made quite easy by the way that
the lineariser has a allocate-typed-instruction function.

Patch enclosed; it's very simple.

Does this seem like a reasonable approach? Is it something that would be
useful to have in the base builds? Are there any ramifications I should
be aware of?

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82 "I have always wished for my computer to be as easy to use as m=
y
=E2=94=82 telephone; my wish has come true because I can no longer figure=
 out
=E2=94=82 how to use my telephone." --- Bjarne Stroustrup

--------------070509020402010206020203
Content-Type: text/x-diff;
 name="type.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline;
 filename="type.patch"

diff -rwu sparse.orig/linearize.c sparse/linearize.c
--- sparse.orig/linearize.c	2008-06-28 22:44:21.714555764 +0100
+++ sparse/linearize.c	2008-06-30 23:20:30.777932755 +0100
@@ -55,7 +55,9 @@
=20
 static struct instruction *alloc_typed_instruction(int opcode, struct sy=
mbol *type)
 {
-	return alloc_instruction(opcode, type_size(type));
+	struct instruction *insn =3D alloc_instruction(opcode, type_size(type))=
;
+	insn->type =3D type;
+	return insn;
 }
=20
 static struct entrypoint *alloc_entrypoint(void)
diff -rwu sparse.orig/linearize.h sparse/linearize.h
--- sparse.orig/linearize.h	2008-06-28 22:44:21.714555764 +0100
+++ sparse/linearize.h	2008-06-30 23:20:04.425933822 +0100
@@ -71,6 +71,7 @@
 		 size:24;
 	struct basic_block *bb;
 	struct position pos;
+	struct symbol *type;
 	union {
 		pseudo_t target;
 		pseudo_t cond;		/* for branch and switch */

--------------070509020402010206020203--

--------------enigFD63256230295195B38DE98A
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIbrWff9E0noFvlzgRAoIzAKDLDKc+fed+4dxRnmQvUFy5enyqRgCgrEKr
QYkD00fHl09iSKiiLouv/io=
=3Bx9
-----END PGP SIGNATURE-----

--------------enigFD63256230295195B38DE98A--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Chris Li" <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: Adding type information to instructions
Date: Mon, 07 Jul 2008 20:08:08 +0000
Message-ID: <70318cbf0807071308i5ce33e92rf7b033d5709da2a2 () mail ! gmail ! com>
--------------------
On Mon, Jul 7, 2008 at 10:42 AM, Josh Triplett <josht@linux.vnet.ibm.com> wrote:
> I can't think of any fundamental reason not to do this, other than the
> standard reason of data structure size.

There is other ways to avoid the size blow up. At the linearized byte
code level,
the back end only need to know it is one of the stander C type . So we have an
array of stander ctype C type similar to ctype_declaration[].

We just need to replace the size member  with the array index in the instruction
struct..

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bogus error for constant array sizes ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Bogus error for constant array sizes
Date: Thu, 29 May 2008 20:01:22 +0000
Message-ID: <1212091282.4265.10.camel () dv>
--------------------
Hello!

I'm running sparse (the current git version) on this file:

static const int len = 64;
void foo(void);
void foo(void)
{
        int buf[len];
}

sparse test.c 
test.c:5:10: error: bad constant expression

But if I remove "const", the error message goes away.

The message comes from file expand.c, function __get_expression_value().
expr->type is checked to be equal EXPR_VALUE (1), but it's EXPR_PREOP
(9).

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Bogus error for constant array sizes
Date: Thu, 29 May 2008 22:10:09 +0000
Message-ID: <1212099009.4265.41.camel () dv>
--------------------
On Thu, 2008-05-29 at 16:01 -0400, Pavel Roskin wrote:
> Hello!
> 
> I'm running sparse (the current git version) on this file:
> 
> static const int len = 64;
> void foo(void);
> void foo(void)
> {
>         int buf[len];
> }
> 
> sparse test.c 
> test.c:5:10: error: bad constant expression
> 
> But if I remove "const", the error message goes away.

It turns out the initializer with "const" is an "implied cast"!

value->type after constant_symbol_value() call in expand_dereference()
is EXPR_VALUE if const is not used and EXPR_IMPLIED_CAST is const is
used.  It is EXPR_CAST for this input:

static int len = (int)64;
void foo(void);
void foo(void)
{
        int buf[len];
} 

That file would trigger the warning too.  I believe "value" should be
expanded, at least in some cases.  What matters is whether the value
evaluates to a constant at the compile time.

Even if we expand the value, problematic casts are still reported:

static int len = 0x100000000LL;
void foo(void);
void foo(void)
{
        int buf[len];
}

warning: cast truncates bits from constant value (100000000 becomes 0)

This patch fixes the bogus errors.  ï»¿The testsuite passes.  I ran sparse
on MadWifi where it was detecting those errors, and now it's showing
usable warnings instead.

Please review the patch.  Sparse is still almost voodoo science to me.
Once I understand more, I'll write the patch description :-)

diff --git a/expand.c b/expand.c
index 032f0c5..5aa0a1d 100644
--- a/expand.c
+++ b/expand.c
@@ -565,6 +565,7 @@ static struct expression *constant_symbol_value(struct symbol *sym, int offset)
 	value = sym->initializer;
 	if (!value)
 		return NULL;
+	expand_expression(value);
 	if (value->type == EXPR_INITIALIZER) {
 		struct expression *entry;
 		FOR_EACH_PTR(value->expr_list, entry) {


Another question is why assigning a numeric constant to a constant
variable is an "implied cast".  It should be possible to use numeric
constants (or anything that can be calculated at the compile time) to
initialize both constant and non-constant variables without any implied
casts as long as the value fits the destination type.  Or perhaps the
assignments to non-constant variables should be implied casts.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Casting away noderef and address spaces? ===

From: Rusty Russell <rusty () rustcorp ! com ! au>
To: linux-sparse
Subject: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 05:48:13 +0000
Message-ID: <200812221606.13910.rusty () rustcorp ! com ! au>
--------------------
Hi all,

  I need to use typeof(), but I want to change address spaces.  I can't see
how to do that: AFAICT it's not possible.  This doesn't work:

#define __percpu __attribute__((noderef, address_space(3)))

/* Turn v back into a normal var. */
#define convert(v) \
	(*(__attribute__((address_space(0), force)) typeof(&v))(v))

int main(int argc, char *argv)
{
	unsigned int __percpu x;

	convert(x) = 0;
	return 0;
}

Thanks,
Rusty.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 20:06:03 +0000
Message-ID: <70318cbf0812221206o1b5e2aech2a36f723afc63ffa () mail ! gmail ! com>
--------------------
On Sun, Dec 21, 2008 at 9:36 PM, Rusty Russell <rusty@rustcorp.com.au> wrote:
> #define convert(v) \
>        (*(__attribute__((address_space(0), force)) typeof(&v))(v))
>
Am I reading it right? You are trying to dereferenc a type instead of a pointer?

I don't think you can do that with sparse.

Are you trying to declare the per_cpu as the third address space
and force every usage of the per_cpu variable going through the conversion?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 20:57:50 +0000
Message-ID: <20081222205750.GK28946 () ZenIV ! linux ! org ! uk>
--------------------
On Mon, Dec 22, 2008 at 12:06:03PM -0800, Christopher Li wrote:
> On Sun, Dec 21, 2008 at 9:36 PM, Rusty Russell <rusty@rustcorp.com.au> wrote:
> > #define convert(v) \
> >        (*(__attribute__((address_space(0), force)) typeof(&v))(v))
> >
> Am I reading it right? You are trying to dereferenc a type instead of a pointer?
> 
> I don't think you can do that with sparse.

The right solution is
	(*(typeof(v) __attribute__((address_space(0), force)) *)(&v))

Cast there will take a pointer to type of V and force-cast it to pointer to
unqualified type of V.  *(cast)&v will do the obvious thing.  Will trim
both the AS and noderef.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 21:23:47 +0000
Message-ID: <70318cbf0812221323s53119420qcdb2ee0542185667 () mail ! gmail ! com>
--------------------
On Mon, Dec 22, 2008 at 12:57 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> The right solution is
>        (*(typeof(v) __attribute__((address_space(0), force)) *)(&v))
>
> Cast there will take a pointer to type of V and force-cast it to pointer to
> unqualified type of V.  *(cast)&v will do the obvious thing.  Will trim
> both the AS and noderef.

Thanks, that is much better. However sparse don't know how to handle it yet.

/tmp/typeof.c:11:64: warning: incorrect type in assignment (invalid types)
/tmp/typeof.c:11:64:    expected unknown type 11 <noident>
/tmp/typeof.c:11:64:    got int

classify_type does not know how to handle SYM_TYPEOF yet.
Let me see if I can make it to work.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 22:33:10 +0000
Message-ID: <70318cbf0812221433y62197ec7y851f00fa5775f150 () mail ! gmail ! com>
--------------------
On Mon, Dec 22, 2008 at 1:39 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> Works here (built from 8f208e215a531d2b32aec0428fd5eaa24ae3100b)...
>
> But yes, SYM_TYPEOF is a brittle mess, so whether that works or not
> is, er, version-dependent ;-/

Very strange. That is exactly what I have in my clean sparse git tree.
I just clone it a few minutes ago. It give me errors on your example.

On my clean tree, I need the attached patch to get it to work.

>
> I really ought to resurrect lazy-type-expressions branch...
>

Are you sure you don't have some of those bits left over on your
git tree? If you submit your lazy-type-expressions patch, I can help to
review it.

BTW, I am normally lazy enough that I am happy about just submitting
patches. On the other hand, I am tried of these sparse patches floating
around the mailing list. I can start a branch to merge the proper patches.
Maybe some thing like a development branch for sparse.
Is that some thing other people want?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 22:42:28 +0000
Message-ID: <1229985748.22856.23.camel () brick>
--------------------
On Mon, 2008-12-22 at 14:33 -0800, Christopher Li wrote:
> BTW, I am normally lazy enough that I am happy about just submitting
> patches. On the other hand, I am tried of these sparse patches floating
> around the mailing list. I can start a branch to merge the proper patches.
> Maybe some thing like a development branch for sparse.
> Is that some thing other people want?
> 

I'd use/test such a branch rather than scraping the mailing list for
useful bits.

Harvey

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 22:57:08 +0000
Message-ID: <20081222225708.GA4074 () uranus ! ravnborg ! org>
--------------------
> 
> BTW, I am normally lazy enough that I am happy about just submitting
> patches. On the other hand, I am tried of these sparse patches floating
> around the mailing list. I can start a branch to merge the proper patches.
> Maybe some thing like a development branch for sparse.
> Is that some thing other people want?

Please do so. We need some progress on sparse and current maintainer
seems to be occupied by other things at the moment.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 23:53:17 +0000
Message-ID: <f19298770812221553n5281505ex611e8e6f6fa1f0c2 () mail ! gmail ! com>
--------------------
On Tue, Dec 23, 2008 at 01:57, Sam Ravnborg <sam@ravnborg.org> wrote:
>>
>> BTW, I am normally lazy enough that I am happy about just submitting
>> patches. On the other hand, I am tried of these sparse patches floating
>> around the mailing list. I can start a branch to merge the proper patches.
>> Maybe some thing like a development branch for sparse.
>> Is that some thing other people want?
>
> Please do so. We need some progress on sparse and current maintainer
> seems to be occupied by other things at the moment.
>
>        Sam

Hello.

How about?
http://git.zaytsev.su/git?p=sparse.git;a=shortlog;h=discuss

This branch holds the two patch collections* I recently sent to the
mailing list. I
think it includes every useful patch that does not break the kernel check, and
even some that do. ;)
The last time we spoke (yesterday) Josh was going to merge the patches really
soon. The idea was to merge everything except the context patches, make a
release, add the context patches, and wait for someone to fix them.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Mon, 22 Dec 2008 23:55:25 +0000
Message-ID: <1229990125.11628.0.camel () johannes>
--------------------

--=-lvcnkKOnOn4bFgttTzj7
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Tue, 2008-12-23 at 02:53 +0300, Alexey Zaytsev wrote:

> The last time we spoke (yesterday) Josh was going to merge the patches re=
ally
> soon. The idea was to merge everything except the context patches, make a
> release, add the context patches, and wait for someone to fix them.

Make sure to revert those that are in the tree now though, before the
release.

johannes

--=-lvcnkKOnOn4bFgttTzj7
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJJUCjqAAoJEKVg1VMiehFYvt0P/158pMN68O2oUWFCdKBNeWFL
OKsXc579+HeYVfzG6s58PwuDSPhCgudGsy86QcjXQQUnm169BRuGsWYpXDbWASOI
3jPJCO0rHYCw3Zo4aH+bXJghFduaqZ5xjRiFUVdmC51JfY7zoUlo5ebv54OmU+zc
1UXvXD3F0LTN4a0XBiKHr2KFT7Dq14HXAEHCNab0NyDNi3KeM03i89fN43CcbQC1
33sBUO+ma06EbAyboxZeGAFOB30COtMZOBvW/91y0EizSNJ4LbPHYUSIWJZF4PfM
jinNjY9BJ4G1ZAUvIFc1M9PHwS2p4QnKAhVE9ZDFPFOx1szgLidThL8KK9uSBb92
NO+FQ1YZt1keG2vcXDtCldSQhiFt+c7K5bTyrtyH3fHAoJFyP+/8/tchlXxx6Xyd
J8BwPXDG516Yi4jOf1HdTyKCJMxIeJtcSpdl/UxhcZO9QvFjwUGU/w/Pk66as0Tu
qb0+Pcnk34305WelikTvzOmuhpOJ1XTWP2V+/NoMMMnRo2jSKsI4mylEpw7bY9km
/boKEqw5P8F60YFFRnuudKAaN4HXtaXnpYXDElV2R2vRT31Kdh3hQFRfX0MNyxno
RG+6xI6l8wJBFCGkuSlAp/0G4sY7vOuO73fqFoGUCcvY6xEzadt70sG7nDQNiWGl
uhPTXg6QzuQS55kJGSV5
=cQHN
-----END PGP SIGNATURE-----

--=-lvcnkKOnOn4bFgttTzj7--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Tue, 23 Dec 2008 00:20:29 +0000
Message-ID: <f19298770812221620s7ef34b9co55f1650220750b38 () mail ! gmail ! com>
--------------------
On Tue, Dec 23, 2008 at 02:55, Johannes Berg <johannes@sipsolutions.net> wrote:
> On Tue, 2008-12-23 at 02:53 +0300, Alexey Zaytsev wrote:
>
>> The last time we spoke (yesterday) Josh was going to merge the patches really
>> soon. The idea was to merge everything except the context patches, make a
>> release, add the context patches, and wait for someone to fix them.
>
> Make sure to revert those that are in the tree now though, before the
> release.
>

By the way, are you sure the latest series you have sent is correct? To me it
seems that it does not make any warnings go away, and adds quite some more:
http://zaytsev.su/tmp/build.diff.txt
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Tue, 23 Dec 2008 00:37:50 +0000
Message-ID: <1229992670.11628.4.camel () johannes>
--------------------

--=-zmHeH2HI7OKeS8+Z5hm8
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Tue, 2008-12-23 at 03:20 +0300, Alexey Zaytsev wrote:

> By the way, are you sure the latest series you have sent is correct? To m=
e it
> seems that it does not make any warnings go away, and adds quite some mor=
e:
> http://zaytsev.su/tmp/build.diff.txt

include/net/sch_generic.h:225:2: warning: label 'continue' already bound

This, of course, shouldn't happen. I thought I'd fixed it, but who
knows. I think it should all just be reverted :)

johannes

--=-zmHeH2HI7OKeS8+Z5hm8
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJJUDLZAAoJEKVg1VMiehFYV5UQAIJhenCW4SqhUwJabrw6cQzO
axRdB5TWlzFmV8Pgd3PDAafECMRCmxz0RLun5d+k1mfUjozmXDOqOICGICxl6K0q
54Sy7uBMf1q/BCTQ/SjHPu28QhhD86VOZHOriPqXp9ORTnHRZUsFSsWDSyJCJhaB
VpL67ZavlItcOuDNRatWEY5uw/F8DoAJNVmVOh/XOx6Ae/PtBW2JnOlVj4GWNGos
Lebpx9nGJUVjoNr+QNO1t/PjIRembcXWgAHE43ibTZQCccwF/G3+OqZxIrrqST3v
H6vw2qFeR4jr4B0Q9in2ChV6XDjrCWCKljxrn42SHbfSC/T2vjDYTAO/3+W6YkgH
3vreSe/U26I3SU/WmZE/h77HT1b0+xiOaHQH9zXDVuniTcR4YhalDhL8sYeOCPeR
ZMRT54KeOTLgCt6M3v0Lj3Ewex+ai270T47Qkv+x/UO9NDwjjd055Q3OsMRfB1oO
VL31X/UxlsAvKj1yUQnsETUCk/ncQ6qcSuDaaZow64m8+cXCak0s7Ti8m8Ye5VDM
Q/5JznHzRXmdddUM4wYgMunds2aHesd0SFbhl0/E4ZYYIysUAen8kOEXFGBLWMQH
uHM6bCIoKqm5p8+JV7KWkE+ihDfAC1HBDYaMq8/+ql0KM+fOyHRd+UkbA+NQZwyz
m/wvww29RQXQDVvHak/M
=JToB
-----END PGP SIGNATURE-----

--=-zmHeH2HI7OKeS8+Z5hm8--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rusty Russell <rusty () rustcorp ! com ! au>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Tue, 23 Dec 2008 02:26:22 +0000
Message-ID: <200812231244.22614.rusty () rustcorp ! com ! au>
--------------------
On Tuesday 23 December 2008 07:27:50 Al Viro wrote:
> The right solution is
> 	(*(typeof(v) __attribute__((address_space(0), force)) *)(&v))
> 
> Cast there will take a pointer to type of V and force-cast it to pointer to
> unqualified type of V.  *(cast)&v will do the obvious thing.  Will trim
> both the AS and noderef.

Thanks Al, that worked, but seems to tickle another bug (sparse 0.4.1, Ubuntu).

rusty@vivaldi:/tmp$ sparse foo.c
foo.c:11:20: warning: incorrect type in assignment (invalid types)
foo.c:11:20:    expected unknown type 11<noident>
foo.c:11:20:    got int

Here's my sample program now:

#define __percpu __attribute__((noderef, address_space(3)))

/* Turn v back into a normal var. */
#define convert(v) \
        (*(typeof(v) __attribute__((address_space(0), force)) *)(&v))

int main(int argc, char *argv)
{
        unsigned int __percpu x;

        convert(x) = 0;
        return 0;
}

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Tue, 23 Dec 2008 03:02:58 +0000
Message-ID: <70318cbf0812221902q23f00644h3af3eed6fa0138de () mail ! gmail ! com>
--------------------
------=_Part_68671_2695806.1230001378150
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Mon, Dec 22, 2008 at 6:14 PM, Rusty Russell <rusty@rustcorp.com.au> wrote:
> rusty@vivaldi:/tmp$ sparse foo.c
> foo.c:11:20: warning: incorrect type in assignment (invalid types)
> foo.c:11:20:    expected unknown type 11<noident>
> foo.c:11:20:    got int
>

I think you need this patch for sparse. The version of sparse you
have does not handle typeof based type compare yet.

Chris

------=_Part_68671_2695806.1230001378150
Content-Type: application/octet-stream; name=evaluate-typeof
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fp1yvsr30
Content-Disposition: attachment; filename=evaluate-typeof

VGVhY2ggY2xhc3NpZnlfdHlwZSB0byBoYW5kbGUgdHlwZW9mCgpTaWduZWQtT2ZmLUJ5OiBDaHJp
c3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgoKSW5kZXg6IHNwYXJzZS9ldmFsdWF0ZS5j
Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL2V2YWx1YXRlLmMKKysrIHNwYXJzZS9ldmFsdWF0
ZS5jCkBAIC0zNjIsNiArMzYyLDExIEBAIHN0YXRpYyBpbmxpbmUgaW50IGNsYXNzaWZ5X3R5cGUo
c3RydWN0IHMKIAl9OwogCWlmICh0eXBlLT50eXBlID09IFNZTV9OT0RFKQogCQl0eXBlID0gdHlw
ZS0+Y3R5cGUuYmFzZV90eXBlOworCWlmICh0eXBlLT50eXBlID09IFNZTV9UWVBFT0YpIHsKKwkJ
dHlwZSA9IGV2YWx1YXRlX2V4cHJlc3Npb24odHlwZS0+aW5pdGlhbGl6ZXIpOworCQlpZiAodHlw
ZS0+dHlwZSA9PSBTWU1fTk9ERSkKKwkJCXR5cGUgPSB0eXBlLT5jdHlwZS5iYXNlX3R5cGU7CisJ
fQogCWlmICh0eXBlLT50eXBlID09IFNZTV9FTlVNKQogCQl0eXBlID0gdHlwZS0+Y3R5cGUuYmFz
ZV90eXBlOwogCSpiYXNlID0gdHlwZTsK
------=_Part_68671_2695806.1230001378150--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Casting away noderef and address spaces?
Date: Tue, 23 Dec 2008 09:59:22 +0000
Message-ID: <1230026362.3046.4.camel () johannes>
--------------------
On Mon, 2008-12-22 at 17:25 -0800, Christopher Li wrote:

> Do you want to resend your change which revert the context changes?
> Make it base on Josh's git's tree and I will merge your changes in my
> branch.

Below. Or I can give it to you in git if you prefer. I still think we
should redo this in some form so that annotations with different
contexts can work properly, but I don't have time to take care of it
right now.

> It will take me a while to get up to speed with the git goodness.
> I will start with merging Alexey's resend patches.

Mind you, he sent a few of my patches, so ignore those.

johannes

>From ca95b62edf1600a2b55ed9ca0515d049807a84fc Mon Sep 17 00:00:00 2001
From: Johannes Berg <johannes@sipsolutions.net>
Date: Tue, 23 Dec 2008 10:53:19 +0100
Subject: [PATCH] Revert context tracking code

---
 inline.c                       |   12 +-
 linearize.c                    |   31 ++-
 linearize.h                    |    7 +-
 parse.c                        |  134 +---------
 parse.h                        |    3 +-
 sparse.1                       |   41 +---
 sparse.c                       |  424 ++++---------------------------
 symbol.h                       |    3 +-
 validation/context-dynamic.c   |  171 -------------
 validation/context-named.c     |  553 ----------------------------------------
 validation/context-statement.c |   69 -----
 validation/context.c           |  114 +-------
 12 files changed, 107 insertions(+), 1455 deletions(-)
 delete mode 100644 validation/context-dynamic.c
 delete mode 100644 validation/context-named.c
 delete mode 100644 validation/context-statement.c

diff --git a/inline.c b/inline.c
index 09d176a..860c0ee 100644
--- a/inline.c
+++ b/inline.c
@@ -331,18 +331,10 @@ static struct statement *copy_one_statement(struct statement *stmt)
 	case STMT_CONTEXT:
 	case STMT_EXPRESSION: {
 		struct expression *expr = copy_expression(stmt->expression);
-		struct statement *newstmt;
 		if (expr == stmt->expression)
 			break;
-		newstmt = dup_statement(stmt);
-		newstmt->expression = expr;
-		if (stmt->required) {
-			expr = copy_expression(stmt->required);
-			if (expr == stmt->required)
-				break;
-			newstmt->required = expr;
-		}
-		stmt = newstmt;
+		stmt = dup_statement(stmt);
+		stmt->expression = expr;
 		break;
 	}
 	case STMT_RANGE: {
diff --git a/linearize.c b/linearize.c
index 526a710..1a19214 100644
--- a/linearize.c
+++ b/linearize.c
@@ -68,6 +68,7 @@ static struct entrypoint *alloc_entrypoint(void)
 static struct basic_block *alloc_basic_block(struct entrypoint *ep, struct position pos)
 {
 	struct basic_block *bb = __alloc_basic_block(0);
+	bb->context = -1;
 	bb->pos = pos;
 	bb->ep = ep;
 	return bb;
@@ -440,7 +441,7 @@ const char *show_instruction(struct instruction *insn)
 		break;
 
 	case OP_CONTEXT:
-		buf += sprintf(buf, "%s%d,%d", "", insn->increment, insn->inc_false);
+		buf += sprintf(buf, "%s%d", insn->check ? "check: " : "", insn->increment);
 		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
@@ -1234,12 +1235,22 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 		FOR_EACH_PTR(ctype->contexts, context) {
 			int in = context->in;
 			int out = context->out;
-
-			if (out - in || context->out_false - in) {
+			int check = 0;
+			int context_diff;
+			if (in < 0) {
+				check = 1;
+				in = 0;
+			}
+			if (out < 0) {
+				check = 0;
+				out = 0;
+			}
+			context_diff = out - in;
+			if (check || context_diff) {
 				insn = alloc_instruction(OP_CONTEXT, 0);
-				insn->increment = out - in;
+				insn->increment = context_diff;
+				insn->check = check;
 				insn->context_expr = context->context;
-				insn->inc_false = context->out_false - in;
 				add_one_insn(ep, insn);
 			}
 		} END_FOR_EACH_PTR(context);
@@ -1674,16 +1685,6 @@ static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 		value = expr->value;
 
 	insn->increment = value;
-	insn->inc_false = value;
-
-	expr = stmt->required;
-	value = 0;
-
-	if (expr && expr->type == EXPR_VALUE)
-		value = expr->value;
-
-	insn->required = value;
-
 	insn->context_expr = stmt->context;
 	add_one_insn(ep, insn);
 	return VOID;
diff --git a/linearize.h b/linearize.h
index 0c5e4ef..2205082 100644
--- a/linearize.h
+++ b/linearize.h
@@ -117,7 +117,8 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false;
+			int increment;
+			int check;
 			struct expression *context_expr;
 		};
 		struct /* asm */ {
@@ -220,13 +221,11 @@ enum opcode {
 
 struct basic_block_list;
 struct instruction_list;
-struct context_list_list;
 
 struct basic_block {
 	struct position pos;
 	unsigned long generation;
-	int context_check_recursion;
-	struct context_list_list *checked_contexts;
+	int context;
 	struct entrypoint *ep;
 	struct basic_block_list *parents; /* sources */
 	struct basic_block_list *children; /* destinations */
diff --git a/parse.c b/parse.c
index eb31871..a78012a 100644
--- a/parse.c
+++ b/parse.c
@@ -64,8 +64,6 @@ static struct token *attribute_address_space(struct token *token, struct symbol
 static struct token *attribute_aligned(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_mode(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_exact_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
 
@@ -184,14 +182,6 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
-static struct symbol_op conditional_context_op = {
-	.attribute = attribute_conditional_context,
-};
-
-static struct symbol_op exact_context_op = {
-	.attribute = attribute_exact_context,
-};
-
 static struct symbol_op transparent_union_op = {
 	.attribute = attribute_transparent_union,
 };
@@ -273,8 +263,6 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
-	{ "conditional_context",	NS_KEYWORD,	.op = &conditional_context_op },
-	{ "exact_context",	NS_KEYWORD,	.op = &exact_context_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
@@ -875,7 +863,7 @@ static struct token *attribute_mode(struct token *token, struct symbol *attr, st
 	return token;
 }
 
-static struct token *_attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype, int exact)
+static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	struct context *context = alloc_context();
 	struct expression *args[3];
@@ -889,8 +877,6 @@ static struct token *_attribute_context(struct token *token, struct symbol *attr
 			break;
 		if (argc < 3)
 			args[argc++] = expr;
-		else
-			argc++;
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -912,14 +898,8 @@ static struct token *_attribute_context(struct token *token, struct symbol *attr
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 		break;
-	default:
-		sparse_error(token->pos, "too many arguments to context attribute");
-		break;
 	}
 
-	context->exact = exact;
-	context->out_false = context->out;
-
 	if (argc)
 		add_ptr_list(&ctype->contexts, context);
 
@@ -927,61 +907,6 @@ static struct token *_attribute_context(struct token *token, struct symbol *attr
 	return token;
 }
 
-static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype)
-{
-	return _attribute_context(token, attr, ctype, 0);
-}
-
-static struct token *attribute_exact_context(struct token *token, struct symbol *attr, struct ctype *ctype)
-{
-	return _attribute_context(token, attr, ctype, 1);
-}
-
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype)
-{
-	struct context *context = alloc_context();
-	struct expression *args[4];
-	int argc = 0;
-
-	token = expect(token, '(', "after conditional_context attribute");
-	while (!match_op(token, ')')) {
-		struct expression *expr = NULL;
-		token = conditional_expression(token, &expr);
-		if (!expr)
-			break;
-		if (argc < 4)
-			args[argc++] = expr;
-		else
-			argc++;
-		if (!match_op(token, ','))
-			break;
-		token = token->next;
-	}
-
-	switch(argc) {
-	case 3:
-		context->in = get_expression_value(args[0]);
-		context->out = get_expression_value(args[1]);
-		context->out_false = get_expression_value(args[2]);
-		break;
-	case 4:
-		context->context = args[0];
-		context->in = get_expression_value(args[1]);
-		context->out = get_expression_value(args[2]);
-		context->out_false = get_expression_value(args[3]);
-		break;
-	default:
-		sparse_error(token->pos, "invalid number of arguments to conditional_context attribute");
-		break;
-	}
-
-	if (argc)
-		add_ptr_list(&ctype->contexts, context);
-
-	token = expect(token, ')', "after conditional_context attribute");
-	return token;
-}
-
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	if (Wtransparent_union)
@@ -1813,56 +1738,17 @@ static struct token *parse_goto_statement(struct token *token, struct statement
 
 static struct token *parse_context_statement(struct token *token, struct statement *stmt)
 {
-	struct expression *args[3];
-	int argc = 0;
-
 	stmt->type = STMT_CONTEXT;
-	token = token->next;
-	token = expect(token, '(', "after __context__ statement");
-	while (!match_op(token, ')')) {
-		struct expression *expr = NULL;
-		token = conditional_expression(token, &expr);
-		if (!expr)
-			break;
-		if (argc < 3)
-			args[argc++] = expr;
-		else
-			argc++;
-		if (!match_op(token, ','))
-			break;
-		token = token->next;
-	}
-
-	stmt->expression = args[0];
-	stmt->context = NULL;
-
-	switch (argc) {
-	case 0:
-		sparse_error(token->pos, "__context__ statement needs argument(s)");
-		return token;
-	case 1:
-		/* already done */
-		break;
-	case 2:
-		if (args[0]->type != STMT_EXPRESSION) {
-			stmt->context = args[0];
-			stmt->expression = args[1];
-		} else {
-			stmt->expression = args[0];
-			stmt->required = args[1];
-		}
-		break;
-	case 3:
-		stmt->context = args[0];
-		stmt->expression = args[1];
-		stmt->required = args[2];
-		break;
-	default:
-		sparse_error(token->pos, "too many arguments for __context__ statement");
-		return token->next;
+	token = parse_expression(token->next, &stmt->expression);
+	if(stmt->expression->type == EXPR_PREOP
+	   && stmt->expression->op == '('
+	   && stmt->expression->unop->type == EXPR_COMMA) {
+		struct expression *expr;
+		expr = stmt->expression->unop;
+		stmt->context = expr->left;
+		stmt->expression = expr->right;
 	}
-
-	return expect(token, ')', "at end of __context__");
+	return expect(token, ';', "at end of statement");
 }
 
 static struct token *parse_range_statement(struct token *token, struct statement *stmt)
diff --git a/parse.h b/parse.h
index a2b9aa3..609910f 100644
--- a/parse.h
+++ b/parse.h
@@ -39,10 +39,9 @@ struct statement {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
-		struct { /* __context__ */
+		struct {
 			struct expression *expression;
 			struct expression *context;
-			struct expression *required;
 		};
 		struct /* return_statement */ {
 			struct expression *ret_value;
diff --git a/sparse.1 b/sparse.1
index 92a1cae..c44e3a5 100644
--- a/sparse.1
+++ b/sparse.1
@@ -73,43 +73,20 @@ Warn about potential errors in synchronization or other delimited contexts.
 Sparse supports several means of designating functions or statements that
 delimit contexts, such as synchronization.  Functions with the extended
 attribute
-.BI __attribute__((context( [expression ,] in_context , out_context ))
-require the context \fIexpression\fR (for instance, a lock) to have at least the value
+.BI __attribute__((context( expression , in_context , out_context ))
+require the context \fIexpression\fR (for instance, a lock) to have the value
 \fIin_context\fR (a constant nonnegative integer) when called, and return with
-the value adjusted by \fIout_context - in_context\fR (where
-\fIout_context\fR is a constant nonnegative integer).  To change the value
-of a context (for example in macros), use the statement
-.BI __context__( [expression , ]adjust_value[ , required] )
-where \fIadjust_value\fR is a constant integer and \fIrequired\fR is a
-constant nonnegative integer. Not giving \fIrequired\fR is equivalent to
-giving zero and means that the statement does not need the context as a
-precondition, when given it means that the context must at least have the
-value of \fIrequired\fR.
-
-To indicate that a function requires
-.BI exactly
-a certain lock context (not "at least" as above), use the form
-.BI __attribute__((exact_context( [expression ,] in_context , out_context ))
-There currently is no corresponding
-.BI __exact_context__( [expression , ]adjust_value[ , required] )
-statement.
-
-To indicate that a certain function acquires a context depending on its
-return value, use
-.BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
-where \fIout_success\fR and \fIout_failure\fR indicate the context change
-done depending on success (non-zero) or failure (zero) return of the
-function. Note that currently, using this attribute on a function means that
-the function itself won't be checked for context handling at all. See the
-testsuite for examples.
-
-Sparse will warn when it sees a function change a
-context without indicating this with a \fBcontext\fR or \fBexact_context\fR attribute, either by
+the value \fIout_context\fR (a constant nonnegative integer).  For APIs
+defined via macros, use the statement form
+.BI __context__( expression , in_value , out_value )
+in the body of the macro.
+
+With \fB-Wcontext\fR Sparse will warn when it sees a function change the
+context without indicating this with a \fBcontext\fR attribute, either by
 decreasing a context below zero (such as by releasing a lock without acquiring
 it), or returning with a changed context (such as by acquiring a lock without
 releasing it).  Sparse will also warn about blocks of code which may
-potentially execute with different contexts and about functions that are
-executed without a lock they require.
+potentially execute with different contexts.
 
 Sparse issues these warnings by default.  To turn them off, use
 \fB\-Wno\-context\fR.
diff --git a/sparse.c b/sparse.c
index 785a6f6..4026ba7 100644
--- a/sparse.c
+++ b/sparse.c
@@ -24,389 +24,77 @@
 #include "expression.h"
 #include "linearize.h"
 
-struct context_check {
-	int val, val_false;
-	char name[32];
-};
-
-DECLARE_ALLOCATOR(context_check);
-DECLARE_PTR_LIST(context_check_list, struct context_check);
-DECLARE_PTR_LIST(context_list_list, struct context_check_list);
-ALLOCATOR(context_check, "context check list");
-
-static const char *unnamed_context = "<unnamed>";
-
-static const char *context_name(struct context *context)
-{
-	if (context->context && context->context->symbol_name)
-		return show_ident(context->context->symbol_name);
-	return unnamed_context;
-}
-
-static void context_add(struct context_check_list **ccl, const char *name,
-			int offs, int offs_false)
-{
-	struct context_check *check, *found = NULL;
-
-	FOR_EACH_PTR(*ccl, check) {
-		if (strcmp(name, check->name))
-			continue;
-		found = check;
-		break;
-	} END_FOR_EACH_PTR(check);
-
-	if (!found) {
-		found = __alloc_context_check(0);
-		strncpy(found->name, name, sizeof(found->name));
-		found->name[sizeof(found->name) - 1] = '\0';
-		add_ptr_list(ccl, found);
-	}
-	found->val += offs;
-	found->val_false += offs_false;
-}
-
-static int context_list_has(struct context_check_list *ccl,
-			    struct context_check *c)
+static int context_increase(struct basic_block *bb, int entry)
 {
-	struct context_check *check;
+	int sum = 0;
+	struct instruction *insn;
 
-	FOR_EACH_PTR(ccl, check) {
-		if (strcmp(c->name, check->name))
+	FOR_EACH_PTR(bb->insns, insn) {
+		int val;
+		if (insn->opcode != OP_CONTEXT)
 			continue;
-		return check->val == c->val &&
-		       check->val_false == c->val_false;
-	} END_FOR_EACH_PTR(check);
-
-	/* not found is equal to 0 */
-	return c->val == 0 && c->val_false == 0;
-}
-
-static int context_lists_equal(struct context_check_list *ccl1,
-			       struct context_check_list *ccl2)
-{
-	struct context_check *check;
-
-	/* can be optimised... */
-
-	FOR_EACH_PTR(ccl1, check) {
-		if (!context_list_has(ccl2, check))
-			return 0;
-	} END_FOR_EACH_PTR(check);
-
-	FOR_EACH_PTR(ccl2, check) {
-		if (!context_list_has(ccl1, check))
-			return 0;
-	} END_FOR_EACH_PTR(check);
-
-	return 1;
-}
-
-static struct context_check_list *checked_copy(struct context_check_list *ccl)
-{
-	struct context_check_list *result = NULL;
-	struct context_check *c;
-
-	FOR_EACH_PTR(ccl, c) {
-		context_add(&result, c->name, c->val_false, c->val_false);
-	} END_FOR_EACH_PTR(c);
-
-	return result;
-}
-
-#define IMBALANCE_IN "context imbalance in '%s': "
-#define DEFAULT_CONTEXT_DESCR "   default context: "
-
-static void get_context_string(char **buf, const char **name)
-{
-	if (strcmp(*name, unnamed_context)) {
-		*buf = malloc(strlen(*name) + 16);
-		sprintf(*buf, "   context '%s': ", *name);
-		*name = *buf;
-	} else {
-		*name = DEFAULT_CONTEXT_DESCR;
-		*buf = NULL;
-	}
-}
-
-static int context_list_check(struct entrypoint *ep, struct position pos,
-			      struct context_check_list *ccl_cur,
-			      struct context_check_list *ccl_target)
-{
-	struct context_check *c1, *c2;
-	int cur, tgt;
-	const char *name;
-	char *buf;
-
-	/* make sure the loop below checks all */
-	FOR_EACH_PTR(ccl_target, c1) {
-		context_add(&ccl_cur, c1->name, 0, 0);
-	} END_FOR_EACH_PTR(c1);
-
-	FOR_EACH_PTR(ccl_cur, c1) {
-		cur = c1->val;
-		tgt = 0;
-
-		FOR_EACH_PTR(ccl_target, c2) {
-			if (strcmp(c2->name, c1->name))
+		val = insn->increment;
+		if (insn->check) {
+			int current = sum + entry;
+			if (!val) {
+				if (!current)
+					continue;
+			} else if (current >= val)
 				continue;
-			tgt = c2->val;
-			break;
-		} END_FOR_EACH_PTR(c2);
-
-		if (cur == tgt || !Wcontext)
+			warning(insn->pos, "context check failure");
 			continue;
-
-		if (cur > tgt)
-			warning(pos, IMBALANCE_IN "wrong count at exit",
-				show_ident(ep->name->ident));
-		else if (cur < tgt)
-			warning(pos, IMBALANCE_IN "unexpected unlock",
-				show_ident(ep->name->ident));
-
-		name = c1->name;
-		get_context_string(&buf, &name);
-
-		info(pos, "%swanted %d, got %d",
-		     name, tgt, cur);
-
-		free(buf);
-
-		return -1;
-	} END_FOR_EACH_PTR(c1);
-
-	return 0;
-}
-
-static int handle_call(struct entrypoint *ep, struct basic_block *bb,
-		       struct instruction *insn,
-		       struct context_check_list *combined)
-{
-	struct context *ctx;
-	struct context_check *c;
-	const char *name, *call, *cmp;
-	char *buf;
-	int val, ok;
-
-	if (!insn->func || !insn->func->sym ||
-	    insn->func->type != PSEUDO_SYM)
-		return 0;
-
-	/*
-	 * Check all contexts the function wants.
-	 */
-	FOR_EACH_PTR(insn->func->sym->ctype.contexts, ctx) {
-		name = context_name(ctx);
-		val = 0;
-
-		FOR_EACH_PTR(combined, c) {
-			if (strcmp(c->name, name) == 0) {
-				val = c->val;
-				break;
-			}
-		} END_FOR_EACH_PTR(c);
-
-		if (ctx->exact) {
-			ok = ctx->in == val;
-			cmp = "";
-		} else {
-			ok = ctx->in <= val;
-			cmp = ">= ";
-		}
-
-		if (!ok && Wcontext) {
-			get_context_string(&buf, &name);
-			call = strdup(show_ident(insn->func->ident));
-
-			warning(insn->pos, "context problem in '%s': "
-				"'%s' expected different context",
-				show_ident(ep->name->ident), call);
-
-			info(insn->pos, "%swanted %s%d, got %d",
-			     name, cmp, ctx->in, val);
-
-			free((void *)call);
-			free(buf);
-
-			return -1;
 		}
-	} END_FOR_EACH_PTR (ctx);
-
-	return 0;
+		sum += val;
+	} END_FOR_EACH_PTR(insn);
+	return sum;
 }
 
-static int handle_context(struct entrypoint *ep, struct basic_block *bb,
-			  struct instruction *insn,
-			  struct context_check_list **combined)
+static int imbalance(struct entrypoint *ep, struct basic_block *bb, int entry, int exit, const char *why)
 {
-	struct context_check *c;
-	const char *name;
-	char *buf;
-	int val, ok;
-
-	val = 0;
-
-	name = unnamed_context;
-	if (insn->context_expr)
-		name = show_ident(insn->context_expr->symbol_name);
-
-	FOR_EACH_PTR(*combined, c) {
-		if (strcmp(c->name, name) == 0) {
-			val = c->val;
-			break;
-		}
-	} END_FOR_EACH_PTR(c);
-
-	ok = insn->required <= val;
-
-	if (!ok && Wcontext) {
-		get_context_string(&buf, &name);
-
-		warning(insn->pos,
-			IMBALANCE_IN
-			"__context__ statement expected different context",
-			show_ident(ep->name->ident));
-
-		info(insn->pos, "%swanted >= %d, got %d",
-		     name, insn->required, val);
-
-		free(buf);
-		return -1;
+	if (Wcontext) {
+		struct symbol *sym = ep->name;
+		warning(bb->pos, "context imbalance in '%s' - %s", show_ident(sym->ident), why);
 	}
-
-	context_add(combined, name, insn->increment, insn->inc_false);
-
-	return 0;
+	return -1;
 }
 
-static int check_bb_context(struct entrypoint *ep, struct basic_block *bb,
-			    struct context_check_list *ccl_in,
-			    struct context_check_list *ccl_target,
-			    int in_false)
+static int check_bb_context(struct entrypoint *ep, struct basic_block *bb, int entry, int exit);
+
+static int check_children(struct entrypoint *ep, struct basic_block *bb, int entry, int exit)
 {
-	struct context_check_list *combined = NULL, *done;
-	struct context_check *c;
 	struct instruction *insn;
-	struct multijmp *mj;
-	int err = -1;
-
-	/*
-	 * Recurse in once to catch bad loops.
-	 */
-	if (bb->context_check_recursion > 1)
-		return 0;
-	bb->context_check_recursion++;
-
-	/*
-	 * Abort if we have already checked this block out of the same context.
-	 */
-	FOR_EACH_PTR(bb->checked_contexts, done) {
-		if (context_lists_equal(done, ccl_in))
-			return 0;
-	} END_FOR_EACH_PTR(done);
-
-	/*
-	 * We're starting with a completely new local list of contexts, so
-	 * initialise it according to what we got from the parent block.
-	 * That may use either the 'false' or the 'true' part of the context
-	 * for the conditional_context() attribute.
-	 */
-	FOR_EACH_PTR(ccl_in, c) {
-		if (in_false)
-			context_add(&combined, c->name, c->val_false, c->val_false);
-		else
-			context_add(&combined, c->name, c->val, c->val);
-	} END_FOR_EACH_PTR(c);
-
-	/* Add the new context to the list of already-checked contexts */
-	done = checked_copy(combined);
-	add_ptr_list(&bb->checked_contexts, done);
-
-	/*
-	 * Now walk the instructions for this block, recursing into any
-	 * instructions that have children. We need to have the right
-	 * order so we cannot iterate bb->children instead.
-	 */
-	FOR_EACH_PTR(bb->insns, insn) {
-		switch (insn->opcode) {
-		case OP_INLINED_CALL:
-		case OP_CALL:
-			if (handle_call(ep, bb, insn, combined))
-				goto out;
-			break;
-		case OP_CONTEXT:
-			if (handle_context(ep, bb, insn, &combined))
-				goto out;
-			break;
-		case OP_BR:
-			if (insn->bb_true)
-				if (check_bb_context(ep, insn->bb_true,
-						     combined, ccl_target, 0))
-					goto out;
-			if (insn->bb_false)
-				if (check_bb_context(ep, insn->bb_false,
-						     combined, ccl_target, 1))
-					goto out;
-			break;
-		case OP_SWITCH:
-		case OP_COMPUTEDGOTO:
-			FOR_EACH_PTR(insn->multijmp_list, mj) {
-				if (check_bb_context(ep, mj->target,
-					             combined, ccl_target, 0))
-					goto out;
-			} END_FOR_EACH_PTR(mj);
-			break;
-		}
-	} END_FOR_EACH_PTR(insn);
+	struct basic_block *child;
 
 	insn = last_instruction(bb->insns);
 	if (!insn)
-		goto out_good;
-
-	if (insn->opcode == OP_RET) {
-		err = context_list_check(ep, insn->pos, combined, ccl_target);
-		goto out;
-	}
+		return 0;
+	if (insn->opcode == OP_RET)
+		return entry != exit ? imbalance(ep, bb, entry, exit, "wrong count at exit") : 0;
 
- out_good:
-	err = 0;
- out:
-	/* contents will be freed once we return out of recursion */
-	free_ptr_list(&combined);
-	bb->context_check_recursion--;
-	return err;
+	FOR_EACH_PTR(bb->children, child) {
+		if (check_bb_context(ep, child, entry, exit))
+			return -1;
+	} END_FOR_EACH_PTR(child);
+	return 0;
 }
 
-static void free_bb_context_lists(struct basic_block *bb)
+static int check_bb_context(struct entrypoint *ep, struct basic_block *bb, int entry, int exit)
 {
-	struct context_check_list *done;
-	struct instruction *insn;
-	struct multijmp *mj;
-
-	if (!bb->checked_contexts)
-		return;
+	if (!bb)
+		return 0;
+	if (bb->context == entry)
+		return 0;
 
-	FOR_EACH_PTR(bb->checked_contexts, done) {
-		free_ptr_list(&done);
-	} END_FOR_EACH_PTR(done);
+	/* Now that's not good.. */
+	if (bb->context >= 0)
+		return imbalance(ep, bb, entry, bb->context, "different lock contexts for basic block");
 
-	free_ptr_list(&bb->checked_contexts);
+	bb->context = entry;
+	entry += context_increase(bb, entry);
+	if (entry < 0)
+		return imbalance(ep, bb, entry, exit, "unexpected unlock");
 
-	FOR_EACH_PTR(bb->insns, insn) {
-		switch (insn->opcode) {
-		case OP_BR:
-			if (insn->bb_true)
-				free_bb_context_lists(insn->bb_true);
-			if (insn->bb_false)
-				free_bb_context_lists(insn->bb_false);
-			break;
-		case OP_SWITCH:
-		case OP_COMPUTEDGOTO:
-			FOR_EACH_PTR(insn->multijmp_list, mj) {
-				free_bb_context_lists(mj->target);
-			} END_FOR_EACH_PTR(mj);
-			break;
-		}
-	} END_FOR_EACH_PTR(insn);
+	return check_children(ep, bb, entry, exit);
 }
 
 static void check_cast_instruction(struct instruction *insn)
@@ -547,7 +235,7 @@ static void check_context(struct entrypoint *ep)
 {
 	struct symbol *sym = ep->name;
 	struct context *context;
-	struct context_check_list *ccl_in = NULL, *ccl_target = NULL;
+	unsigned int in_context = 0, out_context = 0;
 
 	if (Wuninitialized && verbose && ep->entry->bb->needs) {
 		pseudo_t pseudo;
@@ -561,20 +249,10 @@ static void check_context(struct entrypoint *ep)
 	check_instructions(ep);
 
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
-		const char *name = context_name(context);
-
-		context_add(&ccl_in, name, context->in, context->in);
-		context_add(&ccl_target, name, context->out, context->out_false);
-		/* we don't currently check the body of trylock functions */
-		if (context->out != context->out_false)
-			return;
+		in_context += context->in;
+		out_context += context->out;
 	} END_FOR_EACH_PTR(context);
-
-	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target, 0);
-	free_ptr_list(&ccl_in);
-	free_ptr_list(&ccl_target);
-	free_bb_context_lists(ep->entry->bb);
-	clear_context_check_alloc();
+	check_bb_context(ep, ep->entry->bb, in_context, out_context);
 }
 
 static void check_symbols(struct symbol_list *list)
diff --git a/symbol.h b/symbol.h
index c4d7f28..4155b46 100644
--- a/symbol.h
+++ b/symbol.h
@@ -71,8 +71,7 @@ enum keyword {
 
 struct context {
 	struct expression *context;
-	unsigned int in, out, out_false;
-	int exact;
+	unsigned int in, out;
 };
 
 extern struct context *alloc_context(void);
diff --git a/validation/context-dynamic.c b/validation/context-dynamic.c
deleted file mode 100644
index 5e172f0..0000000
--- a/validation/context-dynamic.c
+++ /dev/null
@@ -1,171 +0,0 @@
-static void a(void) __attribute__ ((context(A, 0, 1)))
-{
-    __context__(A, 1);
-}
-
-static void r(void) __attribute__ ((context(A, 1, 0)))
-{
-    __context__(A, -1);
-}
-
-extern int condition, condition2;
-
-static int tl(void) __attribute__ ((conditional_context(A, 0, 1, 0)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int tl2(void) __attribute__ ((conditional_context(A, 0, 0, 1)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int dummy(void)
-{
-    return condition + condition2;
-}
-
-static int good_trylock1(void)
-{
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock2(void)
-{
-    if (tl()) {
-        r();
-    }
-
-    if (tl()) {
-        r();
-    }
-}
-static int good_trylock3(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    r();
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock4(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    if (tl()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock1(void)
-{
-    a();
-    if (dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_trylock5(void)
-{
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock6(void)
-{
-    if (!tl2()) {
-        r();
-    }
-
-    if (!tl2()) {
-        r();
-    }
-}
-static int good_trylock7(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    r();
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock8(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    if (!tl2()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock2(void)
-{
-    a();
-    if (!dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_switch(void)
-{
-    switch (condition) {
-    case 1:
-        a();
-        break;
-    case 2:
-        a();
-        break;
-    case 3:
-        a();
-        break;
-    default:
-        a();
-    }
-    r();
-}
-
-static void bad_lock1(void)
-{
-    r();
-    a();
-}
-
-/*
- * check-name: Check -Wcontext with lock trylocks
- *
- * check-error-start
-context-dynamic.c:83:6: warning: context problem in 'bad_trylock1': 'r' expected different context
-context-dynamic.c:83:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:133:6: warning: context problem in 'bad_trylock2': 'r' expected different context
-context-dynamic.c:133:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:156:6: warning: context problem in 'bad_lock1': 'r' expected different context
-context-dynamic.c:156:6:    context 'A': wanted >= 1, got 0
- * check-error-end
- */
diff --git a/validation/context-named.c b/validation/context-named.c
deleted file mode 100644
index 58310e9..0000000
--- a/validation/context-named.c
+++ /dev/null
@@ -1,553 +0,0 @@
-static void a(void) __attribute__((context(TEST,0,1)))
-{
-	__context__(TEST,1);
-}
-
-static void r(void) __attribute__((context(TEST,1,0)))
-{
-	__context__(TEST,-1,1);
-}
-
-static void a2(void) __attribute__((context(TEST2,0,1)))
-{
-	__context__(TEST2,1);
-}
-
-static void r2(void) __attribute__((context(TEST2,1,0)))
-{
-	__context__(TEST2,-1,1);
-}
-
-#define check_test2() __context__(TEST2,0,1)
-
-static void good_paired1(void)
-{
-	a();
-	a2();
-	r();
-	r2();
-}
-
-static void good_paired2(void)
-{
-	a();
-	r();
-	a();
-	r();
-	a2();
-	r2();
-}
-
-static void good_paired3(void)
-{
-	a();
-	a();
-	r();
-	r();
-	a2();
-	a2();
-	r2();
-	r2();
-}
-
-static void good_lock1(void) __attribute__((context(TEST,0,1)))
-{
-	a();
-}
-
-static void good_lock2(void) __attribute__((context(TEST,0,1)))
-{
-	a();
-	r();
-	a();
-}
-
-static void good_lock3(void) __attribute__((context(TEST,0,1)))
-{
-	a();
-	a();
-	r();
-}
-
-static void good_unlock1(void) __attribute__((context(TEST,1,0)))
-{
-	r();
-}
-
-static void good_unlock2(void) __attribute__((context(TEST,1,0)))
-{
-	a();
-	r();
-	r();
-}
-
-static void warn_lock1(void)
-{
-	a();
-}
-
-static void warn_lock2(void)
-{
-	a();
-	r();
-	a();
-}
-
-static void warn_lock3(void)
-{
-	a();
-	a();
-	r();
-}
-
-static void warn_unlock1(void)
-{
-	r();
-}
-
-static void warn_unlock2(void)
-{
-	a();
-	r();
-	r();
-}
-
-extern int condition, condition2;
-
-static int good_if1(void)
-{
-	a();
-	if(condition) {
-		r();
-		return -1;
-	}
-	r();
-	return 0;
-}
-
-static void good_if2(void)
-{
-	if(condition) {
-		a();
-		r();
-	}
-}
-
-static void good_if3(void)
-{
-	a();
-	if(condition) {
-		a();
-		r();
-	}
-	r();
-}
-
-static int warn_if1(void)
-{
-	a();
-	if(condition)
-		return -1;
-	r();
-	return 0;
-}
-
-static int warn_if2(void)
-{
-	a();
-	if(condition) {
-		r();
-		return -1;
-	}
-	return 0;
-}
-
-static void good_while1(void)
-{
-	a();
-	while(condition)
-		;
-	r();
-}
-
-static void good_while2(void)
-{
-	while(condition) {
-		a();
-		r();
-	}
-}
-
-static void good_while3(void)
-{
-	while(condition) {
-		a();
-		r();
-		if(condition2)
-			break;
-		a();
-		r();
-	}
-}
-
-static void good_while4(void)
-{
-	a();
-	while(1) {
-		if(condition2) {
-			r();
-			break;
-		}
-	}
-}
-
-static void good_while5(void)
-{
-	a();
-	while(1) {
-		r();
-		if(condition2)
-			break;
-		a();
-	}
-}
-
-static void warn_while1(void)
-{
-	while(condition) {
-		a();
-	}
-}
-
-static void warn_while2(void)
-{
-	while(condition) {
-		r();
-	}
-}
-
-static void warn_while3(void)
-{
-	while(condition) {
-		a();
-		if(condition2)
-			break;
-		r();
-	}
-}
-
-static void good_goto1(void)
-{
-    a();
-    goto label;
-label:
-    r();
-}
-
-static void good_goto2(void)
-{
-    a();
-    goto label;
-    a();
-    r();
-label:
-    r();
-}
-
-static void good_goto3(void)
-{
-    a();
-    if(condition)
-        goto label;
-    a();
-    r();
-label:
-    r();
-}
-
-static void good_goto4(void)
-{
-    if(condition)
-        goto label;
-    a();
-    r();
-label:
-    ;
-}
-
-static void good_goto5(void)
-{
-    a();
-    if(condition)
-        goto label;
-    r();
-    return;
-label:
-    r();
-}
-
-static void warn_goto1(void)
-{
-    a();
-    goto label;
-    r();
-label:
-    ;
-}
-
-static void warn_goto2(void)
-{
-    a();
-    goto label;
-    r();
-label:
-    a();
-    r();
-}
-
-static void warn_goto3(void)
-{
-    a();
-    if(condition)
-        goto label;
-    r();
-label:
-    r();
-}
-
-static void warn_multiple1(void)
-{
-    a();
-    a2();
-}
-
-static void warn_multiple2(void)
-{
-    a2();
-    a();
-}
-
-static void warn_mixed1(void)
-{
-    a2();
-    r();
-}
-
-static void warn_mixed2(void)
-{
-    a2();
-    if (condition) {
-        a();
-        r2();
-    }
-    r();
-}
-
-static void warn_mixed3(void)
-{
-    a2();
-    if (condition) {
-        r2();
-        return;
-    }
-    r();
-}
-
-static void warn_mixed4(void)
-{
-    a2();
-    if (condition) {
-        a();
-        r();
-        return;
-    }
-    r();
-}
-
-static void good_mixed1(void)
-{
-    if (condition) {
-        a();
-        r();
-    } else {
-        a2();
-        r2();
-    }
-}
-
-static void good_mixed2(void)
-{
-    if (condition) {
-        a();
-        r();
-    }
-    a2();
-    r2();
-}
-
-static int need_lock(void) __attribute__((context(TEST,1,1)))
-{
-}
-
-static void need_lock_exact(void) __attribute__((exact_context(TEST,1,1)))
-{
-}
-
-static void need_lock2(void) __attribute__((context(TEST,1,1)))
-{
-    need_lock();
-}
-
-static void good_fn(void)
-{
-    a();
-    need_lock();
-    r();
-}
-
-static void good_fn2(void)
-{
-    a();
-    a();
-    need_lock();
-    r();
-    r();
-}
-
-static void good_fn2(void)
-{
-    a();
-    if (condition)
-        need_lock();
-    r();
-}
-
-static void good_fn3(void) __attribute__((context(TEST,1,1)))
-{
-    if (condition)
-        need_lock2();
-}
-
-static void warn_fn(void)
-{
-    a2();
-    need_lock();
-    r2();
-}
-
-static void warn_fn2(void)
-{
-    a2();
-    need_lock2();
-    r2();
-}
-
-static void good_exact_fn(void)
-{
-    a();
-    need_lock_exact();
-    r();
-}
-
-static void warn_exact_fn1(void)
-{
-    a();
-    a();
-    need_lock_exact();
-    r();
-    r();
-}
-
-static void warn_exact_fn2(void)
-{
-    a2();
-    need_lock_exact();
-    r2();
-}
-
-static inline void need_lock3(void) __attribute__((context(TEST,1,1)))
-{
-}
-
-static void warn_fn3(void)
-{
-    a2();
-    need_lock3();
-    r2();
-}
-
-#define __acquire(x)	__context__(x,1)
-#define __release(x)	__context__(x,-1)
-
-#define rl() \
-  do { __acquire(RCU); } while (0)
-
-#define ru() \
-  do { __release(RCU); } while (0)
-
-static void good_mixed_with_if(void)
-{
-    rl();
-
-    if (condition) {
-        a();
-        r();
-    }
-
-    ru();
-}
-
-/*
- * check-name: Check -Wcontext with lock names
- *
- * check-error-start
-context-named.c:86:3: warning: context imbalance in 'warn_lock1': wrong count at exit
-context-named.c:86:3:    context 'TEST': wanted 0, got 1
-context-named.c:93:3: warning: context imbalance in 'warn_lock2': wrong count at exit
-context-named.c:93:3:    context 'TEST': wanted 0, got 1
-context-named.c:100:3: warning: context imbalance in 'warn_lock3': wrong count at exit
-context-named.c:100:3:    context 'TEST': wanted 0, got 1
-context-named.c:105:3: warning: context problem in 'warn_unlock1': 'r' expected different context
-context-named.c:105:3:    context 'TEST': wanted >= 1, got 0
-context-named.c:112:3: warning: context problem in 'warn_unlock2': 'r' expected different context
-context-named.c:112:3:    context 'TEST': wanted >= 1, got 0
-context-named.c:152:9: warning: context imbalance in 'warn_if1': wrong count at exit
-context-named.c:152:9:    context 'TEST': wanted 0, got 1
-context-named.c:162:9: warning: context imbalance in 'warn_if2': wrong count at exit
-context-named.c:162:9:    context 'TEST': wanted 0, got 1
-context-named.c:218:4: warning: context imbalance in 'warn_while1': wrong count at exit
-context-named.c:218:4:    context 'TEST': wanted 0, got 1
-context-named.c:225:4: warning: context problem in 'warn_while2': 'r' expected different context
-context-named.c:225:4:    context 'TEST': wanted >= 1, got 0
-context-named.c:235:4: warning: context imbalance in 'warn_while3': wrong count at exit
-context-named.c:235:4:    context 'TEST': wanted 0, got 1
-context-named.c:295:5: warning: context imbalance in 'warn_goto1': wrong count at exit
-context-named.c:295:5:    context 'TEST': wanted 0, got 1
-context-named.c:305:6: warning: context imbalance in 'warn_goto2': wrong count at exit
-context-named.c:305:6:    context 'TEST': wanted 0, got 1
-context-named.c:315:6: warning: context problem in 'warn_goto3': 'r' expected different context
-context-named.c:315:6:    context 'TEST': wanted >= 1, got 0
-context-named.c:321:7: warning: context imbalance in 'warn_multiple1': wrong count at exit
-context-named.c:321:7:    context 'TEST': wanted 0, got 1
-context-named.c:327:6: warning: context imbalance in 'warn_multiple2': wrong count at exit
-context-named.c:327:6:    context 'TEST2': wanted 0, got 1
-context-named.c:333:6: warning: context problem in 'warn_mixed1': 'r' expected different context
-context-named.c:333:6:    context 'TEST': wanted >= 1, got 0
-context-named.c:343:6: warning: context problem in 'warn_mixed2': 'r' expected different context
-context-named.c:343:6:    context 'TEST': wanted >= 1, got 0
-context-named.c:353:6: warning: context problem in 'warn_mixed3': 'r' expected different context
-context-named.c:353:6:    context 'TEST': wanted >= 1, got 0
-context-named.c:364:6: warning: context imbalance in 'warn_mixed4': wrong count at exit
-context-named.c:364:6:    context 'TEST2': wanted 0, got 1
-context-named.c:434:14: warning: context problem in 'warn_fn': 'need_lock' expected different context
-context-named.c:434:14:    context 'TEST': wanted >= 1, got 0
-context-named.c:441:15: warning: context problem in 'warn_fn2': 'need_lock2' expected different context
-context-named.c:441:15:    context 'TEST': wanted >= 1, got 0
-context-named.c:456:20: warning: context problem in 'warn_exact_fn1': 'need_lock_exact' expected different context
-context-named.c:456:20:    context 'TEST': wanted 1, got 2
-context-named.c:464:20: warning: context problem in 'warn_exact_fn2': 'need_lock_exact' expected different context
-context-named.c:464:20:    context 'TEST': wanted 1, got 0
-context-named.c:475:15: warning: context problem in 'warn_fn3': 'need_lock3' expected different context
-context-named.c:475:15:    context 'TEST': wanted >= 1, got 0
- * check-error-end
- */
diff --git a/validation/context-statement.c b/validation/context-statement.c
deleted file mode 100644
index fd79a6a..0000000
--- a/validation/context-statement.c
+++ /dev/null
@@ -1,69 +0,0 @@
-#define a() __context__(LOCK, 1)
-#define r() __context__(LOCK, -1)
-#define m() __context__(LOCK, 0, 1)
-#define m2() __context__(LOCK, 0, 2)
-
-static void good_ar(void)
-{
-    a();
-    r();
-}
-
-static void bad_arr(void)
-{
-    a();
-    r();
-    r();
-}
-
-static void good_macro1(void)
-{
-    a();
-    m();
-    r();
-}
-
-static void good_macro2(void)
-{
-    a();
-    a();
-    m();
-    m2();
-    r();
-    r();
-}
-
-static void bad_macro1(void)
-{
-    m();
-    a();
-    r();
-}
-
-static void bad_macro2(void)
-{
-    a();
-    r();
-    m();
-}
-
-static void bad_macro3(void)
-{
-    r();
-    a();
-}
-
-/*
- * check-name: Check __context__ statement with required context
- *
- * check-error-start
-context-statement.c:16:8: warning: context imbalance in 'bad_arr': unexpected unlock
-context-statement.c:16:8:    context 'LOCK': wanted 0, got -1
-context-statement.c:38:5: warning: context imbalance in 'bad_macro1': __context__ statement expected different context
-context-statement.c:38:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:47:5: warning: context imbalance in 'bad_macro2': __context__ statement expected different context
-context-statement.c:47:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:53:5: warning: context imbalance in 'bad_macro3': __context__ statement expected different context
-context-statement.c:53:5:    context 'LOCK': wanted >= 0, got -1
- * check-error-end
- */
diff --git a/validation/context.c b/validation/context.c
index 0b45ba3..4b15e75 100644
--- a/validation/context.c
+++ b/validation/context.c
@@ -314,109 +314,23 @@ static void warn_cond_lock1(void)
         condition2 = 1; /* do stuff */
     r();
 }
-
-static void warn_odd_looping(void)
-{
-    int i;
-
-    for (i = 0; i < 2; i++)
-        a();
-    for (i = 0; i < 2; i++)
-        r();
-}
-
-static void warn_huge_switch(void)
-{
-    a();
-
-    switch(condition) {
-    case 1:
-        r();
-        break;
-    case 2:
-        r();
-        break;
-    case 3:
-        r();
-        break;
-    case 4:
-        r();
-        break;
-    case 5:
-        r();
-        break;
-    case 11:
-        r();
-        break;
-    case 12:
-        r();
-        break;
-    case 13:
-        r();
-        break;
-    case 14:
-        r();
-    case 15:
-        r();
-        break;
-    case 16:
-        r();
-        break;
-    case 17:
-        r();
-        break;
-    }
-}
-
-static int warn_conditional(void)
-{
-    if (condition)
-        return 0;
-
-    a();
-    if (condition == 0)
-        return 1;
-    r();
-    return 0;
-}
-
 /*
  * check-name: Check -Wcontext
  *
  * check-error-start
-context.c:71:3: warning: context imbalance in 'warn_lock1': wrong count at exit
-context.c:71:3:    default context: wanted 0, got 1
-context.c:78:3: warning: context imbalance in 'warn_lock2': wrong count at exit
-context.c:78:3:    default context: wanted 0, got 1
-context.c:85:3: warning: context imbalance in 'warn_lock3': wrong count at exit
-context.c:85:3:    default context: wanted 0, got 1
-context.c:90:3: warning: context problem in 'warn_unlock1': 'r' expected different context
-context.c:90:3:    default context: wanted >= 1, got 0
-context.c:97:3: warning: context problem in 'warn_unlock2': 'r' expected different context
-context.c:97:3:    default context: wanted >= 1, got 0
-context.c:137:9: warning: context imbalance in 'warn_if1': wrong count at exit
-context.c:137:9:    default context: wanted 0, got 1
-context.c:147:9: warning: context imbalance in 'warn_if2': wrong count at exit
-context.c:147:9:    default context: wanted 0, got 1
-context.c:203:4: warning: context imbalance in 'warn_while1': wrong count at exit
-context.c:203:4:    default context: wanted 0, got 1
-context.c:210:4: warning: context problem in 'warn_while2': 'r' expected different context
-context.c:210:4:    default context: wanted >= 1, got 0
-context.c:220:4: warning: context imbalance in 'warn_while3': wrong count at exit
-context.c:220:4:    default context: wanted 0, got 1
-context.c:280:5: warning: context imbalance in 'warn_goto1': wrong count at exit
-context.c:280:5:    default context: wanted 0, got 1
-context.c:290:6: warning: context imbalance in 'warn_goto2': wrong count at exit
-context.c:290:6:    default context: wanted 0, got 1
-context.c:300:6: warning: context problem in 'warn_goto3': 'r' expected different context
-context.c:300:6:    default context: wanted >= 1, got 0
-context.c:315:6: warning: context problem in 'warn_cond_lock1': 'r' expected different context
-context.c:315:6:    default context: wanted >= 1, got 0
-context.c:325:10: warning: context problem in 'warn_odd_looping': 'r' expected different context
-context.c:325:10:    default context: wanted >= 1, got 0
-context.c:360:10: warning: context problem in 'warn_huge_switch': 'r' expected different context
-context.c:360:10:    default context: wanted >= 1, got 0
-context.c:380:12: warning: context imbalance in 'warn_conditional': wrong count at exit
-context.c:380:12:    default context: wanted 0, got 1
+context.c:69:13: warning: context imbalance in 'warn_lock1' - wrong count at exit
+context.c:74:13: warning: context imbalance in 'warn_lock2' - wrong count at exit
+context.c:81:13: warning: context imbalance in 'warn_lock3' - wrong count at exit
+context.c:88:13: warning: context imbalance in 'warn_unlock1' - unexpected unlock
+context.c:93:13: warning: context imbalance in 'warn_unlock2' - unexpected unlock
+context.c:131:12: warning: context imbalance in 'warn_if1' - wrong count at exit
+context.c:140:12: warning: context imbalance in 'warn_if2' - different lock contexts for basic block
+context.c:202:2: warning: context imbalance in 'warn_while1' - different lock contexts for basic block
+context.c:210:3: warning: context imbalance in 'warn_while2' - unexpected unlock
+context.c:216:2: warning: context imbalance in 'warn_while3' - wrong count at exit
+context.c:274:13: warning: context imbalance in 'warn_goto1' - wrong count at exit
+context.c:283:13: warning: context imbalance in 'warn_goto2' - wrong count at exit
+context.c:300:5: warning: context imbalance in 'warn_goto3' - different lock contexts for basic block
+context.c:315:5: warning: context imbalance in 'warn_cond_lock1' - different lock contexts for basic block
  * check-error-end
  */
-- 
1.6.0.6



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Context imbalance false positive ===

From: "Luis R. Rodriguez" <mcgrof () gmail ! com>
To: linux-sparse
Subject: Context imbalance false positive
Date: Thu, 17 Jul 2008 23:52:31 +0000
Message-ID: <43e72e890807171652r133c973dh160ea28d361a4601 () mail ! gmail ! com>
--------------------
I'm not sure how to resolve a situation like this:

#include <linux/module.h>
#include <linux/spinlock.h>

MODULE_AUTHOR("Luis R. Rodriguez");
MODULE_LICENSE("GPL");

static spinlock_t some_lock;

static void lock(int bh_flag)
{
        if (bh_flag)
                spin_lock_bh(&some_lock);
        else
                spin_lock(&some_lock);
}

static void unlock(int bh_flag)
{
        if (bh_flag)
                spin_unlock_bh(&some_lock);
        else
                spin_unlock(&some_lock);
}

static int hello_init(void)
{
        spin_lock_init(&some_lock);
        lock(1);
        printk("I am a module, cheers!\n");
        unlock(1);
        return 0;
}

static void goodbye_exit(void)
{
        printk("Goodbye cruel world!\n");
}

module_init(hello_init);
module_exit(goodbye_exit);

----

Sparse complains with:
/home/mcgrof/devel/spin_lock_sparse/sparse_spinlock.c:14:3: warning:
context imbalance in 'lock': wrong count at exit
/home/mcgrof/devel/spin_lock_sparse/sparse_spinlock.c:14:3:    context
'lock': wanted 0, got 1
/home/mcgrof/devel/spin_lock_sparse/sparse_spinlock.c:20:3: warning:
context problem in 'unlock': '_spin_unlock_bh' expected different
context
/home/mcgrof/devel/spin_lock_sparse/sparse_spinlock.c:20:3:    context
'lock': wanted >= 1, got 0

You can test compile from files here:

http://ruslug.rutgers.edu/~mcgrof/spin_lock_sparse/

  Luis
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Context imbalance false positive
Date: Fri, 18 Jul 2008 08:25:25 +0000
Message-ID: <1216369525.27738.4.camel () johannes ! berg>
--------------------

--=-Q8XlgAsHnCxpeCYAB+//
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Thu, 2008-07-17 at 16:52 -0700, Luis R. Rodriguez wrote:
> I'm not sure how to resolve a situation like this:

> static void lock(int bh_flag)
> {
>         if (bh_flag)
>                 spin_lock_bh(&some_lock);
>         else
>                 spin_lock(&some_lock);

The only generally accepted way is to not program locking dependent on
flags.

You can sneak in sparse annotations to do it anyway, but I won't tell
you how :)

johannes

--=-Q8XlgAsHnCxpeCYAB+//
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJIgFNvAAoJEKVg1VMiehFY+kAP/A/FgkyRFLBkrx0URLTSNLBa
/IEU+UawFdEsZDSSIdSZzZ0uD7kYONkTRDgIcvUHT8M7UN5UipxZ3jNH/1Urijzh
2JYY60S22AjGIBvl7vWe8w/CCAjguBifgWs6gJfI3ou0clunbMlodnJYga8NwuaN
I1vCDkONU+iXqS28cbVySG72SKyczEbG2CbzSYaD9v3Nvr0z41a85fES6S/dNQt5
XZ8/dDrtG8KzbZbBzMRDrJoBZMvZScPxQFYbZYuE47fA4/vNpbvjEquhYnV+EUGK
/kJMEB5xXj8mipqOSffqnPG1I9K68X6XR3BgOGioUNdX2Fj+BJdD70nNV64dRpMh
qI3lhZDwcHzib9LmfqHzqbPeafDK2rKll8dtdxprfue3d2Y/45OXm73UycYOK3lI
L2+v2URXAKp3TqSBPuQwy7Aib0w5dnlOOL4cldeU0U2lYa4XaF0xYJrQhquqlmrf
TNNBNiBStUoInUxtrwQkXp0lZ3dAn3BnuZVKWAU/Id3HKVNlxgsXw0Ir3SnGkUQ3
vBokt6h2M2Ewn7TBPeffuaMVI5sASW9sz89n1vpLajzsHxrH+Q0LA44nbOFKmQ4s
BXtKIk50McZmToSnD9z4pUA3jKxTrbwwwT2XXo8q3u2NOAd1Jg3CkqQ5Pl+BCfJC
Ia9mfZg2rxTau1+1R4wV
=kDYj
-----END PGP SIGNATURE-----

--=-Q8XlgAsHnCxpeCYAB+//--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Luis R. Rodriguez" <mcgrof () gmail ! com>
To: linux-sparse
Subject: Re: Context imbalance false positive
Date: Fri, 18 Jul 2008 14:25:18 +0000
Message-ID: <43e72e890807180725q4e1f0c8fu1da7185ade275aa1 () mail ! gmail ! com>
--------------------
On Fri, Jul 18, 2008 at 1:25 AM, Johannes Berg
<johannes@sipsolutions.net> wrote:
> On Thu, 2008-07-17 at 16:52 -0700, Luis R. Rodriguez wrote:
>> I'm not sure how to resolve a situation like this:
>
>> static void lock(int bh_flag)
>> {
>>         if (bh_flag)
>>                 spin_lock_bh(&some_lock);
>>         else
>>                 spin_lock(&some_lock);
>
> The only generally accepted way is to not program locking dependent on
> flags.

Agreed, and that's what I'm trying to do actually. I think the above
is pure absolute garbage.

> You can sneak in sparse annotations to do it anyway, but I won't tell
> you how :)

If you mean by __acquires() and __releases() then that didn't help.

  Luis
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Crash, apparent memory corruption ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Crash, apparent memory corruption
Date: Wed, 13 Feb 2008 23:18:01 +0000
Message-ID: <1202944681.8941.29.camel () dv>
--------------------
OK, I think I know what's wrong.

The "phi_list" field in "struct instruction" should only be accessed if
"opcode" in the same structure is OP_PHI.  "phi_list" is a part of a
transparent union, and thus could overlap with other data, including
data of the "pseudo_t" type.

linearize_compound_statement() uses "phi_list" unconditionally, but
"opcode" can be OP_INLINED_CALL in some cases.

It's a pure coincidence that pseudo_list_size() avoids crashing in most
cases and returns some number.  That number has to be 1 to enable some
additional logic, which is quite unlikely for invalid data.

I don't know the code enough to fix it properly.  I don't know if it's
OK for "opcode" not to be OP_PHI in linearize_compound_statement().

One approach would be to use assert() to ensure it.  The problem is,
it's triggered on several files in the testsuite.  Here's the patch
anyway:

diff --git a/linearize.c b/linearize.c
index 8a68f05..a907c50 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1636,6 +1636,7 @@ static pseudo_t linearize_compound_statement(struct entrypoint *ep, struct state
 		if (!phi_node)
 			return pseudo;
 
+		assert(phi_node->opcode != OP_PHI);
 		if (pseudo_list_size(phi_node->phi_list)==1) {
 			pseudo = first_pseudo(phi_node->phi_list);
 			assert(pseudo->type == PSEUDO_PHI);

Another approach would be to act like pseudo_list_size() returns a
number other than 1 if opcode is not OP_PHI:

diff --git a/linearize.c b/linearize.c
index 8a68f05..11f3a8b 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1636,7 +1636,8 @@ static pseudo_t linearize_compound_statement(struct entrypoint *ep, struct state
 		if (!phi_node)
 			return pseudo;
 
-		if (pseudo_list_size(phi_node->phi_list)==1) {
+		if (phi_node->opcode == OP_PHI
+		    && pseudo_list_size(phi_node->phi_list) == 1) {
 			pseudo = first_pseudo(phi_node->phi_list);
 			assert(pseudo->type == PSEUDO_PHI);
 			return pseudo->def->src1;

Not only the testsuite passes, but I can also check the kernel and
ndiswrapper without sparse crashes.

But I don't know whether the patch is hiding the problem instead of
fixing it.  And we may want to have an additional tag in memory to make
sure that the lists are of the correct type.

-- 
Regards,
Pavel Roskin
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Documentation? Anywhere? ===

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Documentation? Anywhere?
Date: Thu, 24 Jul 2008 22:23:30 +0000
Message-ID: <1216938210.5455.16.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Tue, 2008-07-22 at 17:31 +0000, Ben Greenberg wrote:
> So, I'm new to Linux and to static analysis and so I'm sure I'm not the target
> audience for Sparse, but where is all the documentation? The website is
> well...sparse, the readme contains nothing helpful and neither does the FAQ. I
> compiled Sparse but I have no idea how to use it. There are all these binaries
> and none of them accept --help (except for test-suite). Am I missing something?

sparse and cgcc have manpages.  Other than that, you haven't missed
anything.

> Basically I'm trying to use Sparse to generate a call graph for a specific
> program. I tried using the graph binary which seems to generate XML-like code
> but my browser can't read it. Through browsing this message list I found that
> people were piping the results of graph through the binaries in the gvpr folder
> First of all, how am I supposed to have deduced that the output of graph needs
> to be further processed and that the binaries in gvpr are there for that
> purpose? Second, when I tried to do that I got an error saying that
> /usr/bin/gvpr doesn't exist. Do I need to move the gvpr folder to /usr/bin/ or
> is gvpr a separate program? My command is: ./graph flow.c | ./gvpr/return-paths

graph does not generate XML.  It generates graphviz output.  You need
graphviz to work with it; graphviz also includes gvpr.  You do not need
to process the output further; you simply have the option of doing so.
You can directly feed the output of graph to "dot" or one of the other
graphviz tools to get an image.

However, I agree that no obvious connection exists between the "graph"
program and the post-processing scripts in gvpr.

- Josh Triplett


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Feature request - a macro defined for GCC ===

From: "Joseph S. Myers" <joseph () codesourcery ! com>
To: gcc
Subject: RE: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 00:12:33 +0000
Message-ID: <Pine.LNX.4.64.0807020007500.5121 () digraph ! polyomino ! org ! uk>
--------------------
On Tue, 1 Jul 2008, x z wrote:

> On the other hand, the 1997 sentence "if you invoke the preprocessor 
> directly, `__GNUC__' is undefined" is now replaced by "These macros are 
> also defined if you invoke the preprocessor directly."  I have not had 
> the time to find out what "invoke the preprocessor directly" means ('gcc 
> -E' ?) but now the implication is that a non-'GNU C'-compliant compiler 
> that uses GNU CPP as its preprocessor would have __GNUC__ defined, 
> unless it takes the extra effort to somehow undefine it.

In the 2.8.1 manual, it meant invoking the file 
lib/gcc-lib/$target/2.8.1/cpp, an internal binary not installed in any 
user binary directory that was called internally by the compiler binary 
"gcc" (along with other binaries such as "cc1").

This internal binary no longer exists.  Instead, there is a "cpp" binary 
installed in the user binary directory, which calls the "cc1" binary to do 
the same preprocessing as it does when compiling; that is, it has the same 
effect as "gcc -E".  The better consistency in predefined macros is 
deliberate.

-- 
Joseph S. Myers
joseph@codesourcery.com
================================================================================

From: x z <hzmonte () hotmail ! com>
To: gcc
Subject: RE: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 01:53:11 +0000
Message-ID: <BLU125-W495B0DAC339F02DDE29479A0990 () phx ! gbl>
--------------------

This is somewhat off-topic.  Perhaps the GCC development team should
consider making this __GNUC__ stuff more clarified in the GCC Manual.
Now, this __GNUC__ stuff appears to appear only in the CPP Manual
(section 3.7.2).  And the definition of similar macros such as __GFORTRAN__
and __GNUG__ may need to be further explained in this vein.  Currently, 
__GFORTRAN__ means "The GNU Fortran compiler defines this."  Should it 
rather mean "This is a GNU Fortran-complaint compiler", to be consistent
with the meaning of __GNUC__?  And, for example, should there be 
__GNUG_MINOR__ and __GNUG_PATCHLEVEL__ too?
Interestingly, there is a __VERSION__ macro ("which describes the version 
of the compiler in use").  There is some discussion in this thread on whether  
these macros are defined in the preprocessor or the compiler proper.  If 
these macros are processed by the preprocessor, and the C, C++, Fortran,
etc compilers all share CPP, then how would the preprocessor report the
correct version of the compiler in use?  It somehow checks with the
compiler to see whether it is C or Fortran, and then report the appropriate
version of the compiler?  

_________________________________________________________________
Its a talkathon  but its not just talk.
http://www.imtalkathon.com/?source=EML_WLH_Talkathon_JustTalk

================================================================================

From: Jim Wilson <wilson () tuliptree ! org>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 02:31:45 +0000
Message-ID: <486AE891.4020805 () tuliptree ! org>
--------------------
x z wrote:
> This is somewhat off-topic.  Perhaps the GCC development team should
> consider making this __GNUC__ stuff more clarified in the GCC Manual.

I don't think this is off-topic.  We need to get people to understand 
that __GNUC__ is ambiguous before we can solve the problem.  It means 
two things:
1) This code is written in the GNU C language.
2) This code is meant to be compiled by GCC.
Other compilers that implement the GNU C language are forced to define 
__GNUC__ because of the first issue, even though it then confuses the 
second issue.  If we want to fix this, gcc must change.  And this may 
also require GNU libc changes and linux kernel changes, etc.

The talk about whether __GNUC__ is defined by the preprocessor or the 
compiler proper is irrelevant.  Either way, it is still ambiguous.

You are right that we may also have trouble with other related macros. 
I am not sure if there is a GNU Fortran language, if there is, then we 
may have the same problem with __GFORTRAN__.

We don't need things like __GNUG_MINOR__ as G++ is always distributed in 
lock step with the C compiler, so we only need one set of macros for gcc 
version numbers.

We do however have the problem that the GNU C language changes 
frequently, and people have gotten in the habit of testing 
__GNUC_MINOR__ and other related macros to determine which features are 
present in the version of the GNU C language implemented by this 
compiler.  Hence, this means that other compilers that implement the GNU 
C language may also be forced to define macros like __GNUC_MINOR__ 
through no fault of their own, to correctly describe which version of 
the GNU C language that they implement.

This is a very complicated issue, and until people realize how 
complicated it has gotten, and accept that we need a solution, it is 
unlikely that we will make progress on this issue.

Jim
================================================================================

From: x z <hzmonte () hotmail ! com>
To: gcc
Subject: RE: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 04:34:16 +0000
Message-ID: <BLU125-W23C2C0C257AF9E56E1B886A0990 () phx ! gbl>
--------------------

> If we want to fix this, gcc must change. And this may
> also require GNU libc changes and linux kernel changes, etc.
Maybe you can enlighten us a bit on why GNU libc and linux kernel need 
changes so that we can realize better how complicated the issue is.

> The talk about whether __GNUC__ is defined by the preprocessor or the
> compiler proper is irrelevant. Either way, it is still ambiguous.
IMHO, it is irrelevant as far as whether __GNUC__ is ambiguous.  However,
I think it is relevant as far as how it can be fixed, if at all.  So, if you
have some insight as to whether __GNUC__ is defined by the preprocessor 
or the compiler proper, please let us know.  It does not hurt anyway.

> You are right that we may also have trouble with other related macros.
> I am not sure if there is a GNU Fortran language, if there is, then we
> may have the same problem with __GFORTRAN__.
There is a GNU Fortran compiler for sure.  So, just as people consider
the syntax and semantics of a language accepted by the GNU C compiler
as sort of a C language specification (i.e. whatever accepted by GNU C
compiler 4.3.1 becomes GNU C Standard 4.3.1), there is a GNU Fortran
language.  Whatever accepted by the GNU Fortran compiler becomes
the GNU Fortran language spec. 

> We don't need things like __GNUG_MINOR__ as G++ is always distributed in
> lock step with the C compiler, so we only need one set of macros for gcc
> version numbers.
Then maybe __GNUFORTRAN_MINOR__ .

Anyway, assumed GNU Fortran and GNU C are not distributed in lock step, then
the __VERSION__ macro should be clarified as to whether it refers to the
C or Fortran version (or the version of CPP itself - well, I guess CPP is also
distributed with C in lock step so they share the same version).
_________________________________________________________________
Need to know now? Get instant answers with Windows Live Messenger.
http://www.windowslive.com/messenger/connect_your_way.html?ocid=TXT_TAGLM_WL_messenger_072008

================================================================================

From: Vincent Lefevre <vincent+gcc () vinc17 ! org>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 13:40:16 +0000
Message-ID: <20080702134016.GA14963 () prunille ! vinc17 ! org>
--------------------
On 2008-07-01 11:11:42 -0700, Ian Lance Taylor wrote:
> __GNUC__ is indeed defined by the compiler proper, not by the
> preprocessor.

What do you mean here?

Even when calling the preprocessor directly, __GNUC__ is defined:

vin% gcc -dM -E -xc /dev/null | grep __GNUC__
#define __GNUC__ 4
vin% cpp -dM /dev/null | grep __GNUC__
#define __GNUC__ 4

> But that in turn does not matter, as if any non-gcc compiler *did* use
> the gcc preprocessor, it would do so via gcc -E.  In gcc, the
> preprocessor is not a separate program.

But in any case, there's a separate preprocessor: cpp. And perhaps cpp
shouldn't define __GNUC__.

(BTW, this isn't a compiler, but xrdb uses cpp by default.)

-- 
Vincent Lefèvre <vincent@vinc17.org> - Web: <http://www.vinc17.org/>
100% accessible validated (X)HTML - Blog: <http://www.vinc17.org/blog/>
Work: CR INRIA - computer arithmetic / Arenaire project (LIP, ENS-Lyon)
================================================================================

From: Vincent Lefevre <vincent+gcc () vinc17 ! org>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 13:47:49 +0000
Message-ID: <20080702134749.GB14963 () prunille ! vinc17 ! org>
--------------------
On 2008-07-02 00:12:33 +0000, Joseph S. Myers wrote:
> This internal binary no longer exists. Instead, there is a "cpp"
> binary installed in the user binary directory, which calls the "cc1"
> binary to do the same preprocessing as it does when compiling; that
> is, it has the same effect as "gcc -E".

Not exactly:

vin% cpp -dM /dev/null | wc -l
128
vin% gcc -E -dM /dev/null | wc -l
gcc.real: /dev/null: linker input file unused because linking not done
0

Is it a bug of "gcc -E"?

-- 
Vincent Lefèvre <vincent@vinc17.org> - Web: <http://www.vinc17.org/>
100% accessible validated (X)HTML - Blog: <http://www.vinc17.org/blog/>
Work: CR INRIA - computer arithmetic / Arenaire project (LIP, ENS-Lyon)
================================================================================

From: Jack Lloyd <lloyd () randombit ! net>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 14:10:32 +0000
Message-ID: <20080702141032.GB32658 () randombit ! net>
--------------------
On Wed, Jul 02, 2008 at 03:47:49PM +0200, Vincent Lefevre wrote:
> On 2008-07-02 00:12:33 +0000, Joseph S. Myers wrote:
> > This internal binary no longer exists. Instead, there is a "cpp"
> > binary installed in the user binary directory, which calls the "cc1"
> > binary to do the same preprocessing as it does when compiling; that
> > is, it has the same effect as "gcc -E".
> 
> Not exactly:
> 
> vin% cpp -dM /dev/null | wc -l
> 128
> vin% gcc -E -dM /dev/null | wc -l
> gcc.real: /dev/null: linker input file unused because linking not done
> 0
> 
> Is it a bug of "gcc -E"?

Not really, it just doesn't understand it needs to treat an empty file as
C... instead you have to tell it so with -x c

(wks9 ~)$ cpp -dM /dev/null | wc -l
86
(wks9 ~)$ gcc -E -dM /dev/null | wc -l
gcc: /dev/null: linker input file unused because linking not done
0
(wks9 ~)$ gcc -E -x c -dM /dev/null | wc -l
86
(wks9 ~)$ gcc -E -x c++ -dM /dev/null | wc -l
92
================================================================================

From: Andreas Schwab <schwab () suse ! de>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 14:12:21 +0000
Message-ID: <jeprpwxtmi.fsf () sykes ! suse ! de>
--------------------
Vincent Lefevre <vincent+gcc@vinc17.org> writes:

> On 2008-07-02 00:12:33 +0000, Joseph S. Myers wrote:
>> This internal binary no longer exists. Instead, there is a "cpp"
>> binary installed in the user binary directory, which calls the "cc1"
>> binary to do the same preprocessing as it does when compiling; that
>> is, it has the same effect as "gcc -E".
>
> Not exactly:
>
> vin% cpp -dM /dev/null | wc -l
> 128
> vin% gcc -E -dM /dev/null | wc -l
> gcc.real: /dev/null: linker input file unused because linking not done
> 0
>
> Is it a bug of "gcc -E"?

You need to tell gcc that /dev/null is a C file, since it does not have
a recognized extension.

$ gcc -E -dM -xc /dev/null | wc -l
120

Andreas.

-- 
Andreas Schwab, SuSE Labs, schwab@suse.de
SuSE Linux Products GmbH, Maxfeldstraße 5, 90409 Nürnberg, Germany
PGP key fingerprint = 58CA 54C7 6D53 942B 1756  01D3 44D5 214B 8276 4ED5
"And now for something completely different."
================================================================================

From: Ian Lance Taylor <iant () google ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 14:51:20 +0000
Message-ID: <m34p78ibkn.fsf () google ! com>
--------------------
Vincent Lefevre <vincent+gcc@vinc17.org> writes:

>> But that in turn does not matter, as if any non-gcc compiler *did* use
>> the gcc preprocessor, it would do so via gcc -E.  In gcc, the
>> preprocessor is not a separate program.
>
> But in any case, there's a separate preprocessor: cpp. And perhaps cpp
> shouldn't define __GNUC__.

You're right, there is a program which appears to be a separate
preprocessor.  In actual fact, that program is just gcc under a
different name.

I think it would be reasonable to argue that that program should not
define __GNUC__ by default.  I don't actually know which choice people
would find more surprising.  And unfortunately I also don't know how
to find out.

Ian
================================================================================

From: "Richard Guenther" <richard.guenther () gmail ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 15:23:40 +0000
Message-ID: <84fc9c000807020823o844fb0am299f9c879d276c25 () mail ! gmail ! com>
--------------------
On Wed, Jul 2, 2008 at 5:16 PM, Vincent Lefevre <vincent+gcc@vinc17.org> wrote:
> On 2008-07-02 10:10:32 -0400, Jack Lloyd wrote:
>> Not really, it just doesn't understand it needs to treat an empty
>> file as C... instead you have to tell it so with -x c
>
> But is there any reason why cpp assumes C as a fallback, but not gcc
> (at least with the -E option)? IMHO, this is a bit inconsistent, in
> particular if cpp is seen as a synonym for "gcc -E".

Because it's Cpp, the C preprocessor.

Richard.
================================================================================

From: rkiesling <rkiesling () earthlink ! net>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Wed, 02 Jul 2008 15:26:41 +0000
Message-ID: <E1KE4ED-0001H6-OC () opti1 ! gateway ! 2wire ! net>
--------------------
Vincent Lefevre:
[ Charset ISO-8859-1 converted... ]
> On 2008-07-01 11:11:42 -0700, Ian Lance Taylor wrote:
> > __GNUC__ is indeed defined by the compiler proper, not by the
> > preprocessor.
> 
> What do you mean here?
> 
> Even when calling the preprocessor directly, __GNUC__ is defined:
> 
> vin% gcc -dM -E -xc /dev/null | grep __GNUC__
> #define __GNUC__ 4
> vin% cpp -dM /dev/null | grep __GNUC__
> #define __GNUC__ 4
> 
> > But that in turn does not matter, as if any non-gcc compiler *did* use
> > the gcc preprocessor, it would do so via gcc -E.  In gcc, the
> > preprocessor is not a separate program.
> 
> But in any case, there's a separate preprocessor: cpp. And perhaps cpp
> shouldn't define __GNUC__.
> 
> (BTW, this isn't a compiler, but xrdb uses cpp by default.)

Try:

$ echo ' ' | cpp -undef -dM -

and determine if there's any output (varies by platform).

The ctpp preprocessor undefines all builtins when -undef is present.  See the 
URL below (plug, I know).

-- 
Ctalk Home Page: http://www.ctalklang.org
================================================================================

From: Jim Wilson <wilson () tuliptree ! org>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 16:01:13 +0000
Message-ID: <486CF7C9.60001 () tuliptree ! org>
--------------------
x z wrote:
>> If we want to fix this, gcc must change. And this may
>> also require GNU libc changes and linux kernel changes, etc.
> Maybe you can enlighten us a bit on why GNU libc and linux kernel need 
> changes so that we can realize better how complicated the issue is.

Because there are header files in /usr/include that test __GNUC__.  In 
order for these header files to do the right thing, the Intel compiler 
(and other compilers) need to define __GNUC__.

Now suppose we add a new macro __GCC_COMPILER__ that is intended to be 
unambiguous, and mean only that this is the GCC compiler.  What happens 
next?  Within a few months, someone will post a patch to glibc and/or 
the linux kernel that uses __GCC_COMPILER__, based on the misconception 
that because it is new, that they are supposed to use it.  A few months 
later, there is a glibc release and/or linux kernel release that 
contains this code.  A few months later it gets into a linux release. 
Then Intel discovers that their compiler no longer works as intended on 
linux, and in order to fix it, they have to define __GCC_COMPILER__. 
And now we are back where we started, except now we have two useless 
ambiguous macros instead of one, and hence we are worse off than before.

If we want to make progress on this issue, we need to get people to 
understand what the underlying problem is first, and adopt changes that 
will lead to a solution, otherwise adding new macros is futile.

One thing I haven't seen you answer yet is why you think you need a 
macro that uniquely identifies GCC.  If the Intel compiler correctly 
implements the GNU C language, then it should not matter whether the 
code is being compiled by GCC or ICC.  I think it would help the 
discussion if you could give a specific testcase where this matters.

Jim
================================================================================

From: Chris Lattner <clattner () apple ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 16:37:16 +0000
Message-ID: <49C57313-8636-400D-8121-1EE7B78CAB26 () apple ! com>
--------------------

On Jul 3, 2008, at 9:01 AM, Jim Wilson wrote:

> x z wrote:
>>> If we want to fix this, gcc must change. And this may
>>> also require GNU libc changes and linux kernel changes, etc.
>> Maybe you can enlighten us a bit on why GNU libc and linux kernel  
>> need changes so that we can realize better how complicated the  
>> issue is.
>
> Because there are header files in /usr/include that test __GNUC__.   
> In order for these header files to do the right thing, the Intel  
> compiler (and other compilers) need to define __GNUC__.
>
> Now suppose we add a new macro __GCC_COMPILER__ that is intended to  
> be unambiguous, and mean only that this is the GCC compiler.  What  
> happens next?  Within a few months, someone will post a patch to  
> glibc and/or the linux kernel that uses __GCC_COMPILER__, based on  
> the misconception that because it is new, that they are supposed to  
> use it.  A few months later, there is a glibc release and/or linux  
> kernel release that contains this code.  A few months later it gets  
> into a linux release. Then Intel discovers that their compiler no  
> longer works as intended on linux, and in order to fix it, they have  
> to define __GCC_COMPILER__. And now we are back where we started,  
> except now we have two useless ambiguous macros instead of one, and  
> hence we are worse off than before.

IMO, the whole notion of a compiler-specific macro has pretty limited  
usefulness.  Why not add macros for specific *features* offered by the  
compiler.  For example:

#ifdef __SUPPORTS_NESTED_FUNCTIONS__

is much better than some mismash of version checking, which isn't  
guaranteed to be right in the future.  One disadvantage of this is  
that it will put even more burden on the already overloaded  
preprocessor.  It would be much nicer to have a feature query system  
that doesn't rely on one macro per system.  Perhaps something like:

#if __feature_supported(nested_functions) &&  
__feature_supported(transparent_union) &&  
__feature_supported(attribute_aligned)
...

Taking an approach reduces startup time of the preprocessor, because  
it doesn't have to populate the identifier table with tons of  
predefines.

-Chris

================================================================================

From: Chris Lattner <clattner () apple ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 17:34:22 +0000
Message-ID: <5A1F01AD-4AD3-4D6D-9867-E8D43C3FB412 () apple ! com>
--------------------

On Jul 3, 2008, at 10:01 AM, Andrew Haley wrote:

> Chris Lattner wrote:
>
>> IMO, the whole notion of a compiler-specific macro has pretty limited
>> usefulness.  Why not add macros for specific *features* offered by  
>> the
>> compiler.  For example:
>>
>> #ifdef __SUPPORTS_NESTED_FUNCTIONS__
>>
>> is much better than some mismash of version checking, which isn't
>> guaranteed to be right in the future.
>
> Yeah, but in the absence of an external specification of the syntax  
> it'd
> have to be __SUPPORTS_GNU_NESTED_FUNCTIONS__.

The feature names should be independent of the set of compilers that  
happen to implement them, that's the whole point.  Consider:

#ifdef __SUPPORTS_GNU_CXX_MIN_MAX_OPERATORS__

Mainline GCC doesn't support "GNU" min max operators!   GCC adds and  
removes extensions, and other compilers have good support for subsets  
of the GCC extensions.  Obviously if Intel is defining __GNUC__ with  
moderate success, then they implement whatever extensions the macro is  
guarding.

> Hmm, looks like this could
> get very messy, very quickly; I don't think you could do this in any
> effective way without some compiler-independent organization to define
> these macros.

Huh?  Why not?

-Chris
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 17:50:00 +0000
Message-ID: <20080703175000.GA3852 () ins ! uni-bonn ! de>
--------------------
Hello,

>> Chris Lattner wrote:
>>
>>> IMO, the whole notion of a compiler-specific macro has pretty limited
>>> usefulness.  Why not add macros for specific *features* offered by  
>>> the compiler.  For example:
>>>
>>> #ifdef __SUPPORTS_NESTED_FUNCTIONS__
[...]
>> Hmm, looks like this could
>> get very messy, very quickly; I don't think you could do this in any
>> effective way without some compiler-independent organization to define
>> these macros.

I feel like I'm stating the obvious, but maybe you're just trying to
rediscover feature-based tests: do a test compile that exposes the
compiler bug or feature you're looking for.

Autoconf provides a framework that supports this kind of testing, among
others.

Cheers,
Ralf
================================================================================

From: Paul Koning <Paul_Koning () dell ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 18:00:37 +0000
Message-ID: <18541.5061.618400.378509 () gargle ! gargle ! HOWL>
--------------------
>>>>> "Ralf" == Ralf Wildenhues <Ralf.Wildenhues@gmx.de> writes:

 Ralf> I feel like I'm stating the obvious, but maybe you're just
 Ralf> trying to rediscover feature-based tests: do a test compile
 Ralf> that exposes the compiler bug or feature you're looking for.

 Ralf> Autoconf provides a framework that supports this kind of
 Ralf> testing, among others.

Autoconf is a massively cryptic and complicated way to make up for the
lack of "I have feature X" CPP flags in the compiler.

Chris is right, that's the correct way to do things.

      paul

================================================================================

From: Chris Lattner <clattner () apple ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 18:03:57 +0000
Message-ID: <B5C5B4CA-0688-46CC-BD5D-50B0F95E1A7A () apple ! com>
--------------------

On Jul 3, 2008, at 10:50 AM, Ralf Wildenhues wrote:

> Hello,
>
>>> Chris Lattner wrote:
>>>
>>>> IMO, the whole notion of a compiler-specific macro has pretty  
>>>> limited
>>>> usefulness.  Why not add macros for specific *features* offered by
>>>> the compiler.  For example:
>>>>
>>>> #ifdef __SUPPORTS_NESTED_FUNCTIONS__
> [...]
>>> Hmm, looks like this could
>>> get very messy, very quickly; I don't think you could do this in any
>>> effective way without some compiler-independent organization to  
>>> define
>>> these macros.
>
> I feel like I'm stating the obvious, but maybe you're just trying to
> rediscover feature-based tests: do a test compile that exposes the
> compiler bug or feature you're looking for.
>
> Autoconf provides a framework that supports this kind of testing,  
> among
> others.

That doesn't work for system headers.

-Chris
================================================================================

From: "Joseph S. Myers" <joseph () codesourcery ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 18:51:17 +0000
Message-ID: <Pine.LNX.4.64.0807031849120.8654 () digraph ! polyomino ! org ! uk>
--------------------
On Thu, 3 Jul 2008, Basile STARYNKEVITCH wrote:

> The __GNUC__ macro serves two different purposes:
> 
> 1. permitting the extremely useful GCC languages extensions which, for sad and
> various reasons, did not enter any official C standard (in particular,
> computed gotos, statement exprs, typeof....). We might add the extended asm
> instruction here also. I guess it is the most common use of __GNUC__.

Note that the view was expressed at the London WG14 meeting (going through 
a list of extensions considering what might be worth putting in C1x) that 
statement expressions and typeof might be worth standardising.  This does 
not of course mean that anyone will produce a concrete proposal to add 
appropriate words to the standard, or that such a proposal will be 
accepted for C1x.

-- 
Joseph S. Myers
joseph@codesourcery.com
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 21:12:26 +0000
Message-ID: <1215119546.11853.10.camel () josh-work ! beaverton ! ibm ! com>
--------------------
[Adding the Sparse mailing list to CC.]

On Thu, 2008-07-03 at 09:37 -0700, Chris Lattner wrote:
> IMO, the whole notion of a compiler-specific macro has pretty limited  
> usefulness.  Why not add macros for specific *features* offered by the  
> compiler.  For example:
> 
> #ifdef __SUPPORTS_NESTED_FUNCTIONS__
> 
> is much better than some mismash of version checking, which isn't  
> guaranteed to be right in the future.  One disadvantage of this is  
> that it will put even more burden on the already overloaded  
> preprocessor.  It would be much nicer to have a feature query system  
> that doesn't rely on one macro per system.  Perhaps something like:
> 
> #if __feature_supported(nested_functions) &&  
> __feature_supported(transparent_union) &&  
> __feature_supported(attribute_aligned)
> ...
> 
> Taking an approach reduces startup time of the preprocessor, because  
> it doesn't have to populate the identifier table with tons of  
> predefines.

ï»¿Speaking as the maintainer of Sparse, I would love to see GCC adopt
such an approach.  I don't like that Sparse currently has to define GNUC
and other such macros, and impersonate a GCC version that implies
support for the GCC extensions it has.  While that support probably
needs to stick around for backward compatibility, I'd much rather have
Sparse support some new feature-testing construct.

I'd suggest defining exactly one new preprocessor symbol, to advertise
the support for the feature-testing mechanism.  For instance,
__HAVE_EXTENSION_SUPPORTED__, or __FEATURE_SUPPORTED_SUPPORTED__. :)
The rest could use syntax like you suggest above.  For instance:

#ifdef __HAVE_EXTENSION_SUPPORTED__
#if __have_extension__(noreturn)
#define ATTR_NORETURN __extension__((noreturn))
#endif
ï»¿#if __have_extension__(sentinel)
#define ATTR_SENTINEL __extension__((sentinel))
#endif
#endif
#ifndef ATTR_NORETURN
#define ATTR_NORETURN
#endif
ï»¿#ifndef ATTR_SENTINEL
#define ATTR_SENTINEL
#endif

The same thing would work for Sparse extensions:

ï»¿#ifdef __HAVE_EXTENSION_SUPPORTED__
#if __have_extension__(address_space) && __have_extension__(noderef)
#define __user __extension__((address_space(1),noderef))
#endif
#endif
#ifndef __user
ï»¿#define __user
#endif

The only problem then becomes maintaining the canonical list of
extension names.  We could use the ugly approach of names like
"org.gnu.gcc.extension.sentinel" and "org.kernel.sparse.address_space",
but that seems entirely too ugly.  The other alternative seems like a
central registry of extension names; I'd happily help maintain such a
registry.

Thoughts?

- Josh Triplett



================================================================================

From: Chris Lattner <clattner () apple ! com>
To: linux-sparse
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 21:24:28 +0000
Message-ID: <23A4CFBC-4157-4B08-BA99-FBBCA6DDFEA4 () apple ! com>
--------------------
On Jul 3, 2008, at 2:12 PM, Josh Triplett wrote:
> I'd suggest defining exactly one new preprocessor symbol, to advertise
> the support for the feature-testing mechanism.  For instance,
> __HAVE_EXTENSION_SUPPORTED__, or __FEATURE_SUPPORTED_SUPPORTED__. :)
> The rest could use syntax like you suggest above.  For instance:


Sure.  The idea was that you'd do something like:

#ifndef __FEATURE_SUPPORTED_SUPPORTED__  /* or whatever :) */
#define has_extension(x) 0
#else
#define has_extension(x) __has_extension__(x)
#endif

which allows you to use "#if has_extension(typeof)" in your code  
portably.

In fact, it would be easy to make __has_extension__ actually be a  
macro itself, allowing one to say:

#ifdef __has_extension__
...

which is even more clear.

> The only problem then becomes maintaining the canonical list of
> extension names.  We could use the ugly approach of names like
> "org.gnu.gcc.extension.sentinel" and  
> "org.kernel.sparse.address_space",
> but that seems entirely too ugly.  The other alternative seems like a
> central registry of extension names; I'd happily help maintain such a
> registry.

I have no opinion on an approach, but I agree that it would be good to  
have a centralized list.  I would definitely add support for this to  
Clang.

-Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <clattner () apple ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 21:24:28 +0000
Message-ID: <23A4CFBC-4157-4B08-BA99-FBBCA6DDFEA4 () apple ! com>
--------------------
On Jul 3, 2008, at 2:12 PM, Josh Triplett wrote:
> I'd suggest defining exactly one new preprocessor symbol, to advertise
> the support for the feature-testing mechanism.  For instance,
> __HAVE_EXTENSION_SUPPORTED__, or __FEATURE_SUPPORTED_SUPPORTED__. :)
> The rest could use syntax like you suggest above.  For instance:


Sure.  The idea was that you'd do something like:

#ifndef __FEATURE_SUPPORTED_SUPPORTED__  /* or whatever :) */
#define has_extension(x) 0
#else
#define has_extension(x) __has_extension__(x)
#endif

which allows you to use "#if has_extension(typeof)" in your code  
portably.

In fact, it would be easy to make __has_extension__ actually be a  
macro itself, allowing one to say:

#ifdef __has_extension__
...

which is even more clear.

> The only problem then becomes maintaining the canonical list of
> extension names.  We could use the ugly approach of names like
> "org.gnu.gcc.extension.sentinel" and  
> "org.kernel.sparse.address_space",
> but that seems entirely too ugly.  The other alternative seems like a
> central registry of extension names; I'd happily help maintain such a
> registry.

I have no opinion on an approach, but I agree that it would be good to  
have a centralized list.  I would definitely add support for this to  
Clang.

-Chris
================================================================================

From: "Joseph S. Myers" <joseph () codesourcery ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 22:01:05 +0000
Message-ID: <Pine.LNX.4.64.0807032158080.10725 () digraph ! polyomino ! org ! uk>
--------------------
On Thu, 3 Jul 2008, Chris Lattner wrote:

> is much better than some mismash of version checking, which isn't guaranteed
> to be right in the future.  One disadvantage of this is that it will put even
> more burden on the already overloaded preprocessor.  It would be much nicer to
> have a feature query system that doesn't rely on one macro per system.
> Perhaps something like:
> 
> #if __feature_supported(nested_functions) &&
> __feature_supported(transparent_union) &&
> __feature_supported(attribute_aligned)
> ...

This looks rather like a reinvention of the #assert system (which is 
deprecated, or at least recommended against in the manual).

> Taking an approach reduces startup time of the preprocessor, because it
> doesn't have to populate the identifier table with tons of predefines.

I'd hope this is not a significant cost (certainly not compared to the 
thousands of built-in functions on some target), though I haven't seen 
recent figures for startup costs.

We have some existing practice for feature macros (__GNUC_GNU_INLINE__, 
__GNUC_STDC_INLINE__, __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1, ...).

-- 
Joseph S. Myers
joseph@codesourcery.com
================================================================================

From: Chris Lattner <clattner () apple ! com>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 22:10:38 +0000
Message-ID: <CB862774-4159-4B68-B7FB-576A3B0AC96E () apple ! com>
--------------------
On Jul 3, 2008, at 3:01 PM, Joseph S. Myers wrote:
>> Taking an approach reduces startup time of the preprocessor,  
>> because it
>> doesn't have to populate the identifier table with tons of  
>> predefines.
>
> I'd hope this is not a significant cost (certainly not compared to the
> thousands of built-in functions on some target), though I haven't seen
> recent figures for startup costs.

I was referring to clang startup times, not GCC.  clang registers  
builtins completely lazily, so they don't take significant time at  
startup.  Much of clang startup time is populating the predefined  
identifier table for macros.

> We have some existing practice for feature macros  
> (__GNUC_GNU_INLINE__,
> __GNUC_STDC_INLINE__, __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1, ...).

Understood.  Likewise many system headers have these.  I don't think  
we can eliminate existing macros, but adding a plethora of new macros  
would be bad.

-Chris
================================================================================

From: rkiesling <rkiesling () earthlink ! net>
To: gcc
Subject: Re: Feature request - a macro defined for GCC
Date: Thu, 03 Jul 2008 23:35:35 +0000
Message-ID: <E1KEYKt-0002x8-VR () opti1 ! gateway ! 2wire ! net>
--------------------
Paul Koning:
> >>>>> "Ralf" == Ralf Wildenhues <Ralf.Wildenhues@gmx.de> writes:
> 
>  Ralf> I feel like I'm stating the obvious, but maybe you're just
>  Ralf> trying to rediscover feature-based tests: do a test compile
>  Ralf> that exposes the compiler bug or feature you're looking for.
> 
>  Ralf> Autoconf provides a framework that supports this kind of
>  Ralf> testing, among others.
> 
> Autoconf is a massively cryptic and complicated way to make up for the
> lack of "I have feature X" CPP flags in the compiler.
> 
> Chris is right, that's the correct way to do things.
> 
>       paul

Cpp does not, however, define macros based on command line options,
for example __C99_STD_CMD_LINE_OPTION__.  You could do the same thing
yourself with a -D__MY_C99_STUFF__, for example, on the command line.

I also feel like I keep stating the obvious, but there are a lot of
GNU C platforms that don't use glibc and wouldn't have any need for
such feature-based macros, (or they would need their own unique
features) but they still comply with standard C.

-- 
Ctalk Home Page: http://www.ctalklang.org
================================================================================


################################################################################

=== Thread: Fwd: [PATCH 0/10] Sparse linker ===

From: Tommy Thorn <tommy () thorn ! ws>
To: linux-sparse
Subject: Re: Fwd: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 01:54:38 +0000
Message-ID: <48BF3FDE.10300 () thorn ! ws>
--------------------
Christopher Li wrote:
> I would rather not have that 4 byte prepended to every
> structure. Serialize is just one short stage of the life cycle
> of those c structures. Having the permanent extra space
> for just that is unnecessary. That 4 bytes meta data also
> limits what C structure you can work on. All you need
> is being able to map a point into some serialize object
> to keep track which object is tracked and which one is not.
>
> After you serialized the data. The meta data can be drop
> completely. So the price to pay is for every unknown object
> pointer, you need to do a dictionary look up. Only during
> the dumping stage. But that price is actually very small,
> when you dumping objects. You are mostly limit by the disk
> any way. The plus side is: you can work with any objects.
> You don't need to waste extra memory for serialization
> when you are not doing serialization. You can leave the
> object allocation code unchanged.
>   

I concur and just wanted to point out that this technique has been used 
in the garbage collector for functional languages for the same reason: 
the type information is very small and almost completely static; no need 
to replicate it all over the data. It does make marshaling (this is the 
common terminology for what Alex calls "serialization") slightly more 
complicated.

Tommy



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Handling of -specs in cgcc ===

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Handling of -specs in cgcc
Date: Sun, 20 Jul 2008 18:28:35 +0000
Message-ID: <f19298770807201128s3688702fm3f8b2f42edb198fc () mail ! gmail ! com>
--------------------
Hi.

Looking at cgcc, it seems that this code does not actually work,

26     if (/^-specs=(.*)$/) {
27         $check .= &add_specs ($1);
28         $has_specs = 1;
29         next;
30     }

because add_specs() never expects to see a file name, and
the option is removed from the argument list and never passed
to gcc. As it seems that this feature never worked, probably
we could simply remove it? Morten?

---

    Pass -specs to gcc without trying (and failing) to decompose it.

    Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>

diff --git a/cgcc b/cgcc
index 4fab530..a1d4f66 100755
--- a/cgcc
+++ b/cgcc
@@ -23,12 +23,6 @@ foreach (@ARGV) {
     $m32 = 1 if /^-m32$/;
     $m64 = 1 if /^-m64$/;

-    if (/^-specs=(.*)$/) {
-       $check .= &add_specs ($1);
-       $has_specs = 1;
-       next;
-    }
-
     if ($_ eq '-no-compile') {
        $do_compile = 0;
        next;
@@ -83,6 +77,8 @@ sub cc_only_option {
     # ones.  Don't include it just because a project wants to pass -Wall to cc.
     # If you really want cgcc to run sparse with -Wall, use
     # CHECK="sparse -Wall".
+
+    return 1 if $arg =~ /^-specs=.*/;
     return 1 if $arg =~ /^-Wall$/;
     return 0;
 }
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-sparse
Subject: Re: Handling of -specs in cgcc
Date: Tue, 22 Jul 2008 17:20:45 +0000
Message-ID: <118833cc0807221020m44938f77l70324a548baa4551 () mail ! gmail ! com>
--------------------
On Tue, Jul 22, 2008 at 1:00 PM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:
> [Added the new address to the CC]

("troll.com" is a bitkeeper bug.  Use a machine named "troll" and
bitkeeper would
happily add ".com".)

With respect to the substance, I am not sure why you want to remove -specs.
It was never meant to take a filename -- it takes a token like "i86" and adds
options for that.  That is not generally very useful, but has its uses
for cross-
compilation.

Morten
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: Handling of -specs in cgcc
Date: Tue, 22 Jul 2008 17:28:26 +0000
Message-ID: <f19298770807221028x4f2dca08l36a31a9c381bf4f3 () mail ! gmail ! com>
--------------------
On Tue, Jul 22, 2008 at 9:20 PM, Morten Welinder <mwelinder@gmail.com> wrote:
> On Tue, Jul 22, 2008 at 1:00 PM, Alexey Zaytsev
> <alexey.zaytsev@gmail.com> wrote:
>> [Added the new address to the CC]
>
> ("troll.com" is a bitkeeper bug.  Use a machine named "troll" and
> bitkeeper would
> happily add ".com".)
>
> With respect to the substance, I am not sure why you want to remove -specs.
> It was never meant to take a filename -- it takes a token like "i86" and adds
> options for that.  That is not generally very useful, but has its uses
> for cross-
> compilation.

But won't gcc fail in such case? Maybe we should not remove, but replace it
with a unique option to specify for which architecture sparse should check?

>
> Morten
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-sparse
Subject: Re: Handling of -specs in cgcc
Date: Tue, 22 Jul 2008 17:43:27 +0000
Message-ID: <118833cc0807221043n215f5378pa3f97bdf75452d0a () mail ! gmail ! com>
--------------------
> But won't gcc fail in such case?

It will not fail, as gcc does not see any of it.  But since the defines might
not match what gcc runs with, you might get interesting effects.

> Maybe we should not remove, but replace it
> with a unique option to specify for which architecture sparse should check?

That's certainly possible, but I would wait for an actual problem showing
up before fixing anything.  Right now, we can use -specs to get an idea
what sparse would find for a different arch without actually having a gcc
around that can cross compile.

Morten
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Handling of -specs in cgcc
Date: Tue, 22 Jul 2008 18:03:52 +0000
Message-ID: <1216749832.4485.30.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Tue, 2008-07-22 at 13:43 -0400, Morten Welinder wrote:
> > But won't gcc fail in such case?
> 
> It will not fail, as gcc does not see any of it.  But since the defines might
> not match what gcc runs with, you might get interesting effects.
> 
> > Maybe we should not remove, but replace it
> > with a unique option to specify for which architecture sparse should check?
> 
> That's certainly possible, but I would wait for an actual problem showing
> up before fixing anything.  Right now, we can use -specs to get an idea
> what sparse would find for a different arch without actually having a gcc
> around that can cross compile.

In general, it seems questionable to have cgcc handle an option named
identically to one in GCC but have it behave differently than GCC.

That said, I do think Sparse should handle different architectures
without requiring compilation of a "cross-Sparse"; it really just needs
a specs-equivalent for each architecture.

- Josh Triplett


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: Handling of -specs in cgcc
Date: Tue, 22 Jul 2008 18:11:22 +0000
Message-ID: <f19298770807221111t7277a49ek3931f0b1e5061957 () mail ! gmail ! com>
--------------------
On Tue, Jul 22, 2008 at 10:03 PM, Josh Triplett
<josht@linux.vnet.ibm.com> wrote:
> On Tue, 2008-07-22 at 13:43 -0400, Morten Welinder wrote:
>> > But won't gcc fail in such case?
>>
>> It will not fail, as gcc does not see any of it.  But since the defines might
>> not match what gcc runs with, you might get interesting effects.
>>
>> > Maybe we should not remove, but replace it
>> > with a unique option to specify for which architecture sparse should check?
>>
>> That's certainly possible, but I would wait for an actual problem showing
>> up before fixing anything.  Right now, we can use -specs to get an idea
>> what sparse would find for a different arch without actually having a gcc
>> around that can cross compile.
>
> In general, it seems questionable to have cgcc handle an option named
> identically to one in GCC but have it behave differently than GCC.
>
> That said, I do think Sparse should handle different architectures
> without requiring compilation of a "cross-Sparse"; it really just needs
> a specs-equivalent for each architecture.
>
> - Josh Triplett

How about just s/specs/arch/ ?

diff --git a/cgcc b/cgcc
index 4fab530..f4417dc 100755
--- a/cgcc
+++ b/cgcc
@@ -23,7 +23,7 @@ foreach (@ARGV) {
     $m32 = 1 if /^-m32$/;
     $m64 = 1 if /^-m64$/;

-    if (/^-specs=(.*)$/) {
+    if (/^-arch=(.*)$/) {
        $check .= &add_specs ($1);
        $has_specs = 1;
        next;
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Hard-coded gcc header path ===

From: =?utf-8?B?SsO2cm4=?= Engel <joern () logfs ! org>
To: linux-sparse
Subject: Hard-coded gcc header path
Date: Tue, 11 Nov 2008 13:58:17 +0000
Message-ID: <20081111135816.GA25986 () logfs ! org>
--------------------
Sparse doesn't work for me when compiling userspace code.  Others have
experienced the same, so I refer to someone else's description of the
symptom:
http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=505177

On my system, sparse tries several headers in order, neither of which
exists:
open("/usr/include/stddef.h", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/local/include/stddef.h", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h", O_RDONLY) = -1 ENOENT (No such file or directory)

Not a big surprise when looking at the headers that do exist:
Galway:/usr/lib/gcc/i486-linux-gnu# ll
total 20
drwxr-xr-x 4 root root 4096 2008-07-01 08:42 3.4.6
drwxr-xr-x 4 root root 4096 2007-09-23 17:59 4.0.4
drwxr-xr-x 3 root root 4096 2008-06-26 00:20 4.1
lrwxrwxrwx 1 root root    3 2007-09-23 20:57 4.1.3 -> 4.1
drwxr-xr-x 3 root root 4096 2008-07-13 11:06 4.2
lrwxrwxrwx 1 root root    3 2008-07-01 08:42 4.2.4 -> 4.2
drwxr-xr-x 4 root root 4096 2008-09-30 16:27 4.3
lrwxrwxrwx 1 root root    3 2008-07-01 08:42 4.3.1 -> 4.3
lrwxrwxrwx 1 root root    3 2008-08-08 18:18 4.3.2 -> 4.3

So why does sparse try 4.1.2 and not 4.1.3 or 4.3.2 or any other
variant?
joern@Galway:/usr/src/kernel/sparse$ cat pre-process.h
#define GCC_INTERNAL_INCLUDE "/usr/lib/gcc/i486-linux-gnu/4.1.2/include"

Ah, it is hard-coding the path.

So what is the right solution to this problem?  Call "gcc --version" and
parse the (deliberately hard) output?  Or make a copy of the gcc headers
and ship them as /usr/lib/sparse/0.4.1/...?

JÃ¶rn

-- 
But this is not to say that the main benefit of Linux and other GPL
software is lower-cost. Control is the main benefit--cost is secondary.
-- Bruce Perens
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Hard-coded gcc header path
Date: Tue, 11 Nov 2008 14:01:46 +0000
Message-ID: <1226412106.4478.5.camel () johannes ! berg>
--------------------

--=-8LccJ1ysjvJ75Z+/3YKx
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

On Tue, 2008-11-11 at 14:58 +0100, J=C3=B6rn Engel wrote:

> So why does sparse try 4.1.2 and not 4.1.3 or 4.3.2 or any other
> variant?
> joern@Galway:/usr/src/kernel/sparse$ cat pre-process.h
> #define GCC_INTERNAL_INCLUDE "/usr/lib/gcc/i486-linux-gnu/4.1.2/include"
>=20
> Ah, it is hard-coding the path.

Well, sort of. The patch is actually determined at sparse build time, so
right now sparse requires you to build it against the same compiler that
you are currently using. If you rebuild sparse with your shiny new
compiler you'll notice that it'll end up with a different path in
pre-process.h.

johannes

--=-8LccJ1ysjvJ75Z+/3YKx
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJJGZBHAAoJEKVg1VMiehFYRKkQAJOTfLTKNR766ePFE50/CpiC
L1K7hvhzvRJYmvhZ0nKOoAB5d4Xw1yrl1O1/3Nrh4LLui3pMFyMQx9A42QSVrhuI
iXDfe9l6UIMlDQAmTlfhdRAnsTsWND0MW/4XcVkEHUGJ23iu0quvq0OsNr/jbDRA
R6AW5RlH2dEmdOk0blTueg9yt6hPH34fl5Dn8zo2Qx3SUDCl1cbxIruGGj1aQYP8
ZsXlAnyum9S305S5yNa8rE3NrnI8DJITtN/igtS/Hgc8pmVZWfYAlRvgyV6oL6OY
zMYu4ixZHD7mAUUGlWNHQMFRU0+FXd+3gXUEqfWfdrQRia9Qo3oeHaTvIZiSVsvn
otaFrAbWtgm52blaD/8jGm4rSCSnKpe8ZrWEy2cj2z6NQT4ir+yo/kvbEU5Owvlc
BK5Bjf0u05SaLdTzbZreWmKBvB+pRzjl5Iie16rcouxYSyWJ6Dx36MCKWrfPWwWI
6Y6d/WQ2zGVEiOvP0fxdBh3tjIYXcnJKIQkTyedR1/p2TywfYVGMEhQE2HKRC5JY
TG4iTnFh6OMWTxLOemQOfIAXWqgGylYI0ZZDXqjay0UI9ZWcqYbmWFhAkyjmPxLn
fBtcLRNHdR6Jb3AKU8JxRo37gDbRGQ59tQ2qDwvNb6JBwsctPFz157cUeEvIwMqj
d6QqBtXHxJ5kqJTeYIPl
=wAef
-----END PGP SIGNATURE-----

--=-8LccJ1ysjvJ75Z+/3YKx--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () firmix ! at>
To: linux-sparse
Subject: Re: Hard-coded gcc header path
Date: Tue, 11 Nov 2008 14:41:39 +0000
Message-ID: <1226414499.29562.35.camel () spike ! firmix ! at>
--------------------
On Tue, 2008-11-11 at 14:58 +0100, JÃ¶rn Engel wrote:
[...]
> So what is the right solution to this problem?  Call "gcc --version" and
> parse the (deliberately hard) output?  Or make a copy of the gcc headers

There is `gcc -dumpversion`. But it doesn't help if your compiler is
from e.g. /opt/gcc-4.1.2 (where mine usually are).
And `which`, `type -all`, and similar also doesn't really help as the
reported pathname can be actually the ccache binary ....

So you want to use the output of
----  snip  ----
gcc -v -E - </dev/null 2>&1 >/dev/null | sed -n -e '/^#include <\.\.\.> search starts here:/,/^End of search list\./s/^ \(.*\)/\1/p'
----  snip  ----
which also seems to work with non-standard paths (like /opt) and ccache
in between.

	Bernd

PS: The core of the above line is from
    http://sourceware.org/ml/crossgcc/2006-12/msg00038.html. The quite
    trivial `sed` filter is by me.
-- 
Firmix Software GmbH                   http://www.firmix.at/
mobil: +43 664 4416156                 fax: +43 1 7890849-55
          Embedded Linux Development and Services


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pierre Habouzit <madcoder () debian ! org>
To: linux-sparse
Subject: Re: Hard-coded gcc header path
Date: Tue, 11 Nov 2008 20:13:28 +0000
Message-ID: <20081111201328.GA10073 () artemis ! corp>
--------------------

--wac7ysb48OaltWcw
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Tue, Nov 11, 2008 at 02:15:29PM +0000, J=C3=B6rn Engel wrote:
> On Tue, 11 November 2008 15:01:46 +0100, Johannes Berg wrote:
> >=20
> > Well, sort of. The patch is actually determined at sparse build time, so
> > right now sparse requires you to build it against the same compiler that
> > you are currently using. If you rebuild sparse with your shiny new
> > compiler you'll notice that it'll end up with a different path in
> > pre-process.h.
>=20
> Then the short-term solution for debian is clear.  Simply rebuild the
> package and add a dependency on a specific gcc version.

Which sucks badly because the default gcc is not always the same on
every arch, and more importantly, people may want to use different GCCs.
It would look like a better idea to ask gcc for its include path
properly.
--=20
=C2=B7O=C2=B7  Pierre Habouzit
=C2=B7=C2=B7O                                                madcoder@debia=
n.org
OOO                                                http://www.madism.org

--wac7ysb48OaltWcw
Content-Type: application/pgp-signature
Content-Disposition: inline

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)

iEYEABECAAYFAkkZ52cACgkQvGr7W6HudhyzzQCfamDR5WrI5db3QVcphs1aIQ8B
4wkAoJG43+pK7G2zMzRNUHq3OeyUzE4x
=RDv/
-----END PGP SIGNATURE-----

--wac7ysb48OaltWcw--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?utf-8?B?SsO2cm4=?= Engel <joern () logfs ! org>
To: linux-sparse
Subject: Re: Hard-coded gcc header path
Date: Tue, 11 Nov 2008 20:28:49 +0000
Message-ID: <20081111202849.GD25986 () logfs ! org>
--------------------
On Tue, 11 November 2008 21:13:28 +0100, Pierre Habouzit wrote:
> On Tue, Nov 11, 2008 at 02:15:29PM +0000, JÃ¶rn Engel wrote:
> > 
> > Then the short-term solution for debian is clear.  Simply rebuild the
> > package and add a dependency on a specific gcc version.
> 
> Which sucks badly because the default gcc is not always the same on
> every arch, and more importantly, people may want to use different GCCs.
> It would look like a better idea to ask gcc for its include path
> properly.

Maybe not even that.  It is conceivable to want sparse on systems that
don't even have gcc installed.  The BSDs seem to favor pcc lately.  So
the preferred long-term solution would be for sparse to ship its own
headers.

JÃ¶rn

-- 
To recognize individual spam features you have to try to get into the
mind of the spammer, and frankly I want to spend as little time inside
the minds of spammers as possible.
-- Paul Graham
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-sparse
Subject: Re: Hard-coded gcc header path
Date: Tue, 11 Nov 2008 21:00:21 +0000
Message-ID: <118833cc0811111300q4e7571f5o2a56a652f9a941e9 () mail ! gmail ! com>
--------------------
The problem is not the header files, but that we need to ensure that the
proper include path is set up.

This is needed because sparse currently tries to mimic some
indeterminate gcc version in terms of predefines.  A similar solution
would be needed to mimic any other compiler.  We obviously need
a default path for system headers somehow.

In this case, we could probably get away with accepting a definition
of GCC_INTERNAL_INCLUDE on the command line and use that in
preference over whatever is in pre-process.h

Morten
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () firmix ! at>
To: linux-sparse
Subject: Re: Hard-coded gcc header path
Date: Tue, 11 Nov 2008 23:10:17 +0000
Message-ID: <1226445017.3331.19.camel () gimli ! at ! home>
--------------------
On Die, 2008-11-11 at 23:32 +0100, JÃ¶rn Engel wrote:
[...]
> Either sparse gets smart enough to find the headers [1] or it ships its
> own set.  Anything else will continue to fail on one machine or another.

I don't think that shipping a copy of .h files from one gcc version will
seriously help people using `pcc` (or any other compiler).
But I'm probably missing something here.

> [1] Bernd Petrovitsch sent me this neat one-liner in a private mail:
> gcc -v -E - </dev/null 2>&1 >/dev/null | sed -n -e '/^#include <\.\.\.> search starts here:/,/^End of search list\./s/^ \(.*\)/\1/p
> 
> We could add that to cgcc to set additional include paths.

And there probably are similar ones for `pcc` or others.

	Bernd
-- 
Firmix Software GmbH                   http://www.firmix.at/
mobil: +43 664 4416156                 fax: +43 1 7890849-55
          Embedded Linux Development and Services

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: How to work on Sparse for Summer of Code 2008 ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: How to work on Sparse for Summer of Code 2008
Date: Tue, 18 Mar 2008 04:14:37 +0000
Message-ID: <47DF41AD.4060701 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig30C952DD71625AD84960AEE4
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Sparse did not get accepted as a mentoring organization for Google
Summer of Code 2008.  However, Portland State University has
graciously agreed to accept applications for Sparse projects under the
PSU banner.  Thus, any student wishing to work on Sparse for Summer of
Code 2008 should apply to Portland State University.  (You do not need
to attend PSU or have any affiliation with PSU.)

Some application guidelines you should follow to improve your chances
of getting accepted (some reiterated from my previous mail):

* Clearly state that you want to work on Sparse; don't make the
  mentors figure it out from context.  PSU will have many different
  applications for different projects.

* Explain your project as concretely as you can.  Don't just give an
  abstract idea like "Improve Sparse's support for $FOO."; give a
  concrete proposal for what Sparse or a technology built on Sparse
  will do at the end of the summer that it can't do at the beginning
  of the summer.

* If your project relates to making Sparse handle a new C construct,
  or detect a new type of problem, give code examples for the
  construct or the problem.

* Set realistic goals.  You don't have talk big to get accepted; you
  have to convince us you have a project you can complete.  Feel free
  to set ambitious goals, just convince us you can accomplish them.

* Point to any examples of projects you have worked on in the past.
  Bonus if you point to particular instances of contributions you made
  and the interactions you had with the project's community to get
  those contributions merged.  Note that this in no way means you have
  to have this type of experience in order to get accepted; on the
  contrary, Google Summer of Code exists in part to help people new to
  the Free and Open Source Software process.  This just means that
  *if* you have such experience, you should call attention to it, and
  that will help us evaluate your ability to succeed with your
  proposal.

* Release early, release often.  Please get comfortable with the idea
  of releasing your work to the Sparse mailing list, regardless of the
  current state of that work.

* Explain how you plan to keep your mentor informed of your status.

* Explain how you would stay in contact with your mentor if something
  happened to make you unable to get connectivity for a while.

- Josh Triplett


--------------enig30C952DD71625AD84960AEE4
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFH30GtGJuZRtD+evsRAnbAAJ9SwXJb9pWAmFIxxswZncA3AqjnoACcCLyi
nXKJ+Fnm+GQCU/uPilDaPG4=
=g6t9
-----END PGP SIGNATURE-----

--------------enig30C952DD71625AD84960AEE4--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: rajika () cse ! mrt ! ac ! lk
To: linux-sparse
Subject: Re: How to work on Sparse for Summer of Code 2008
Date: Wed, 19 Mar 2008 02:16:13 +0000
Message-ID: <1205892253.47e0749d8a4f4 () webmail ! mrt ! ac ! lk>
--------------------
hi,
I was searching through the project list at PSU[1], but unable to locate the
open project list for sparse. Is that same as 2007[2]?, Can you please guide me
to the open project list of sparse at PSU?.
Thanks in advance.
Regards,
Rajika
[1]- http://summer.cs.pdx.edu/ideas 
[2]- http://kernel.org/pub/software/devel/sparse/soc.html

Quoting Josh Triplett <josh@freedesktop.org>:

> Sparse did not get accepted as a mentoring organization for Google
> Summer of Code 2008.  However, Portland State University has
> graciously agreed to accept applications for Sparse projects under the
> PSU banner.  Thus, any student wishing to work on Sparse for Summer of
> Code 2008 should apply to Portland State University.  (You do not need
> to attend PSU or have any affiliation with PSU.)
> 
> Some application guidelines you should follow to improve your chances
> of getting accepted (some reiterated from my previous mail):
> 
> * Clearly state that you want to work on Sparse; don't make the
>   mentors figure it out from context.  PSU will have many different
>   applications for different projects.
> 
> * Explain your project as concretely as you can.  Don't just give an
>   abstract idea like "Improve Sparse's support for $FOO."; give a
>   concrete proposal for what Sparse or a technology built on Sparse
>   will do at the end of the summer that it can't do at the beginning
>   of the summer.
> 
> * If your project relates to making Sparse handle a new C construct,
>   or detect a new type of problem, give code examples for the
>   construct or the problem.
> 
> * Set realistic goals.  You don't have talk big to get accepted; you
>   have to convince us you have a project you can complete.  Feel free
>   to set ambitious goals, just convince us you can accomplish them.
> 
> * Point to any examples of projects you have worked on in the past.
>   Bonus if you point to particular instances of contributions you made
>   and the interactions you had with the project's community to get
>   those contributions merged.  Note that this in no way means you have
>   to have this type of experience in order to get accepted; on the
>   contrary, Google Summer of Code exists in part to help people new to
>   the Free and Open Source Software process.  This just means that
>   *if* you have such experience, you should call attention to it, and
>   that will help us evaluate your ability to succeed with your
>   proposal.
> 
> * Release early, release often.  Please get comfortable with the idea
>   of releasing your work to the Sparse mailing list, regardless of the
>   current state of that work.
> 
> * Explain how you plan to keep your mentor informed of your status.
> 
> * Explain how you would stay in contact with your mentor if something
>   happened to make you unable to get connectivity for a while.
> 
> - Josh Triplett
> 
> 




----------------------------------------------------------------
This message was sent using IMP, the Internet Messaging Program.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: How to work on Sparse for Summer of Code 2008
Date: Mon, 31 Mar 2008 06:17:14 +0000
Message-ID: <47F081EA.4010200 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigE8E20C3490178F6E39F6D28D
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

rajika@cse.mrt.ac.lk wrote:
> hi,
> I was searching through the project list at PSU[1], but unable to locat=
e the
> open project list for sparse. Is that same as 2007[2]?, Can you please =
guide me
> to the open project list of sparse at PSU?.
> Thanks in advance.
> Regards,
> Rajika
> [1]- http://summer.cs.pdx.edu/ideas=20
> [2]- http://kernel.org/pub/software/devel/sparse/soc.html

Yes, at the moment I just have the same project list up from 2007.
That page needs updating.

However, I would also encourage you to propose any other Sparse-related i=
dea
you would like to work on, not just those on the fairly small ideas list.=


- Josh Triplett


--------------enigE8E20C3490178F6E39F6D28D
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFH8IHqGJuZRtD+evsRAs89AJ0dxnlNQuiEtq0eh5ytPTPNHp/JMACeL7Tr
Sl64i8jMnkEDKLaHlkD6goE=
=X2co
-----END PGP SIGNATURE-----

--------------enigE8E20C3490178F6E39F6D28D--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Interrupt context ===

From: "Codrin Alexandru Grajdeanu" <grcodal () gmail ! com>
To: linux-sparse
Subject: Interrupt context
Date: Sun, 23 Mar 2008 21:44:56 +0000
Message-ID: <3581ed890803231444i58cff10i408dc4d9bef7b184 () mail ! gmail ! com>
--------------------
Hi all,

 I am a student from Politehnica University of Bucharest studying
 Computer Science. I would like to add some new kernel source checks
 based on sparse. The first idea would be to test if from interrupt
 context sleepy functions are called.
 To test this, sparse would be required to run twice. First to get all
 interrupt context functions, by verifying what arguments are passed to
 irq_handler_t() and what values are passed to the function pointers in
 struct timer_list, softirq_action and tasklet_struct. The second run
 would generate the call graph for this function and would verify if
 schedule() is called inside their call graph.
 What do you think about this?

 Thank you,
 Codrin Grajdenau
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Interrupt context
Date: Mon, 24 Mar 2008 21:00:32 +0000
Message-ID: <70318cbf0803241400m46d30098g85a402e6e0f86130 () mail ! gmail ! com>
--------------------
On Sun, Mar 23, 2008 at 2:44 PM, Codrin Alexandru Grajdeanu
<grcodal@gmail.com> wrote:
>   To test this, sparse would be required to run twice. First to get all
>   interrupt context functions, by verifying what arguments are passed to
>   irq_handler_t() and what values are passed to the function pointers in

You can identify the interrupt handler by return type is "irqreturn_t".

>   struct timer_list, softirq_action and tasklet_struct. The second run

That is harder.

>   would generate the call graph for this function and would verify if
>   schedule() is called inside their call graph.

I don't think two pass is enough. You need to build the call graph
for pretty much every function. Because the irq handler function might
call other function which calls other function which calls schedule().

I don't think you can go very far without doing any control flow
and data flow analyze. e.g. kmalloc() can go to sleep or not depend
on the allocation flag (GFP_ATOMIC).

Which points back to the proposal of:
a) allow sparse to access  function from different files.
b) building the call graph for every function in the kernel.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Octavian Purdila <tavi () cs ! pub ! ro>
To: linux-sparse
Subject: Re: Interrupt context
Date: Tue, 25 Mar 2008 01:34:30 +0000
Message-ID: <200803250334.30713.tavi () cs ! pub ! ro>
--------------------
On Monday 24 March 2008, Christopher Li wrote:
>
> I don't think two pass is enough. You need to build the call graph
> for pretty much every function. Because the irq handler function might
> call other function which calls other function which calls schedule().
>
> I don't think you can go very far without doing any control flow
> and data flow analyze. e.g. kmalloc() can go to sleep or not depend
> on the allocation flag (GFP_ATOMIC).
>
> Which points back to the proposal of:
> a) allow sparse to access  function from different files.
> b) building the call graph for every function in the kernel.
>


Hi Chris,

Yes, you are right, we need to have the complete call graph of the whole 
kernel and kernel modules we want to check. We developed a prototype 
some time ago, but we never manage to move from the prototype to something 
that could be used out in the real world.

The idea which we explored for the prototype was to serialize the sparse state 
and save it into the object files in a private section. The linker would than 
take care of aggregating the sparse state into the kernel image or kernel 
modules. The second stage loads the saved state, create the call graph, 
propagate the interrupt/softirq context around and finally check if schedule 
was called from interrupt context -- the check itself was really broad as we 
did not do any data flow analysis.

The nice thing about this approach is that at least in theory would allow all 
sorts of global analysis, not only this particular (sleeping in interrupt) 
check. And we actually started with the idea of using sparse itself to 
generate the serializer, but we ended up patching the generate code 
manually - we abandoned the idea of adding sparse annotations to sparse code 
to get things right as we realized that we are moving away from our goal.

But, what we obtain after the first stage was a vmlinux over 2GB in size, 
which could not be processed by ELF utilities (we assumed that we hit some 
limitations in the ELF32 format). So in the end its not so practical.

For this second try, we were thinking about replacing the serializer with a 
thiner layer which would just save the call graph information together with 
the associated interrupt context function / sleeping function attributes in 
the object files. 

Any comments / suggestions are greatly appreciated.

Thanks,
tavi







-- 
This message has been scanned for viruses and
dangerous content by MailScanner, and is
believed to be clean.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Interrupt context
Date: Tue, 25 Mar 2008 02:57:07 +0000
Message-ID: <70318cbf0803241957l6b211d34t3cad51d587192501 () mail ! gmail ! com>
--------------------
On Mon, Mar 24, 2008 at 6:34 PM, Octavian Purdila <tavi@cs.pub.ro> wrote:
> On Monday 24 March 2008, Christopher Li wrote:
>  Yes, you are right, we need to have the complete call graph of the whole
>  kernel and kernel modules we want to check. We developed a prototype
>  some time ago, but we never manage to move from the prototype to something
>  that could be used out in the real world.

Interesting. I did some hack on the serialize of the sparse output as well.

>  The idea which we explored for the prototype was to serialize the sparse state
>  and save it into the object files in a private section. The linker would than
>  take care of aggregating the sparse state into the kernel image or kernel
>  modules. The second stage loads the saved state, create the call graph,
>  propagate the interrupt/softirq context around and finally check if schedule
>  was called from interrupt context -- the check itself was really broad as we
>  did not do any data flow analysis.
>
>  The nice thing about this approach is that at least in theory would allow all
>  sorts of global analysis, not only this particular (sleeping in interrupt)
>  check. And we actually started with the idea of using sparse itself to
>  generate the serializer, but we ended up patching the generate code
>  manually - we abandoned the idea of adding sparse annotations to sparse code
>  to get things right as we realized that we are moving away from our goal.

I want to have sparse generate the the serializer code as well. One problem
I run into is that, a lot of the sparse C structure member are within the
union. The serialize code needs to understand the object type in order to access
the member specific to this type inside the union. It need some fairly
complicate
data flow analyze code to trace the sparse code itself how it access the union
member. I end up do it by hand as well :-)

>
>  But, what we obtain after the first stage was a vmlinux over 2GB in size,
>  which could not be processed by ELF utilities (we assumed that we hit some
>  limitations in the ELF32 format). So in the end its not so practical.

My plan is to write a symbol mapping  to perform the symbol look up.
For each extern symbol, you can look up to a object file name and an offset
within that object file to locate the symbol.

Then with the help from the serializer, you can load the that object file
into memory.

BTW, besides linking what else do the ELF format buys you?

Whatever file format, I want it to store the linearized byte code rather
than the machine code.

>  For this second try, we were thinking about replacing the serializer with a
>  thiner layer which would just save the call graph information together with
>  the associated interrupt context function / sleeping function attributes in
>  the object files.

I would like to see some thing more general. For each file, it saves
the information:

1) What symbol does it provide as extern.
2) What symbol does it accessed.
3) The linearized byte code for each function emits. (serialized of
the entrypoint
    for each function).

And then, you would be able to perform a lot of checking on this.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Interrupt context
Date: Wed, 26 Mar 2008 21:53:08 +0000
Message-ID: <70318cbf0803261453s8ec20c8m18bcf99a11e88ca () mail ! gmail ! com>
--------------------
On Wed, Mar 26, 2008 at 5:43 AM, Octavian Purdila <tavi@cs.pub.ro> wrote:
>  You don't need to change the build system, you got all the information you
>  need in the final deliverable of the build (vmlinux or the kernel module).

How do you write to the ELF object? Can you write to ELF64 then you shouldn't
have the size limit. I am not a big fan of loading everything into one big ELF
file. I image it would be useful to only load the module as you needed.

>
>  OK, so you think that the serializer approach is still the way to go then?
>

Depend on what you actually serialized. In the ideal world, you can save and
load the compiled linearized byte code with symbol informations. That way
you don't lose any information during the serialization.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: My sparse repository ===

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: My sparse repository
Date: Thu, 25 Dec 2008 20:26:46 +0000
Message-ID: <f19298770812251226i5a7dc027sc70ec25a9ea53a6f () mail ! gmail ! com>
--------------------
On Wed, Dec 24, 2008 at 15:17, Christopher Li <sparse@chrisli.org> wrote:
> HI,
>
> I create a sparse repository at:
>
> git://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git
>
> It is mostly for patch which I consider candidates for the official
> tree. Currently it only contain Johannes' context revert and a small
> fix for Rusty's recent encounter of typeof. I will collect other patches
> on the sparse mailing list if I see fit.

Is there a way to look at it in the gitweb? And also, could you please
create an experimental branch, for stuff that is not broken and ugly, but
needs more discussion? Otherwise I could do this, just didn't want to
duplicate the effort.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: My sparse repository
Date: Sun, 28 Dec 2008 18:36:49 +0000
Message-ID: <f19298770812281036u59ac3ecdi2ffbdbe403cdf58d () mail ! gmail ! com>
--------------------
On Fri, Dec 26, 2008 at 04:16, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Dec 25, 2008 at 12:26 PM, Alexey Zaytsev
> <alexey.zaytsev@gmail.com> wrote:
>> Is there a way to look at it in the gitweb? And also, could you please
>
> Good idea. I will ask the kernel.org administrators to add my tree.
>
>> create an experimental branch, for stuff that is not broken and ugly, but
>> needs more discussion? Otherwise I could do this, just didn't want to
>> duplicate the effort.
>
> Sure, what patch do you have in mind?

Like, your makefile cleanups, or the instruction type patch, or
just any random patch you or anyone else happens to write.
It's not hard to pick up patches from the ml, but setting
up a git remote and cheri-picking stuff is easier anyway.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Odd behaviour with OP_SCAST ===

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Odd behaviour with OP_SCAST
Date: Sat, 06 Sep 2008 21:14:36 +0000
Message-ID: <48C2F2BC.9030606 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig900734DB3222BEEE77FC3117
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

test-unssa.c compiles this:

extern void func(int i, ...);
void foo(int i) { func(0, (float) i, (double) i, i); }

=2E..into this:

	fpcast.64   %r3 <- (32) %arg1
	scast.64    %r5 <- (32) %arg1
	call        func, $0, %r3, %r5, %arg1
	ret

That's with the default settings. Unfortunately, with Clue,
sizeof(double) =3D=3D sizeof(int), so that second instruction comes out a=
s:

	scast.32    %r5 <- (32) %arg1

This then causes the simplification code in simplify_cast() to discard it=
:

	if (size =3D=3D orig_size) {
		int op =3D (orig_type->ctype.modifiers & MOD_SIGNED) ? OP_SCAST : OP_CA=
ST;
		if (insn->opcode =3D=3D op)
			goto simplify;
	}

The end result is that my call statement turns into:

	call        func, $0, %r3, %arg1, %arg1

=2E..which is wrong.

I assume that Clue's odd configuration is violating some assumption
somewhere, but I'm not well-enough versed with the sparse internals to
know where. It does seem odd to me that it's generating an OP_SCAST to
convert the int to a double, rather than an OP_FPCAST like in the float.
In the mean time, I've commented out the quoted stanza from
simplify_cast() on my setup, which makes things work, but that's not
really very pleasant.

Can anyone shed light on what might be happening here? Could this be a
symptom of some more serious underlying bug?

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82
=E2=94=82 "All power corrupts, but we need electricity." --- Diana Wynne =
Jones,
=E2=94=82 _Archer's Goon_


--------------enig900734DB3222BEEE77FC3117
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIwvLCf9E0noFvlzgRApaKAKCo8I7vPAkPOjdYcRyv0td0IgASewCeIXub
wStZAOr+6LN4ST5OWn1EjMM=
=4V0F
-----END PGP SIGNATURE-----

--------------enig900734DB3222BEEE77FC3117--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Chris Li" <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: Odd behaviour with OP_SCAST
Date: Mon, 08 Sep 2008 21:02:18 +0000
Message-ID: <70318cbf0809081402i7c7e80c4g9b45988b8cf2e0fc () mail ! gmail ! com>
--------------------
On Sat, Sep 6, 2008 at 2:14 PM, David Given <dg@cowlark.com> wrote:
> The end result is that my call statement turns into:
>
>        call        func, $0, %r3, %arg1, %arg1
>
> ...which is wrong.
>
> I assume that Clue's odd configuration is violating some assumption
> somewhere, but I'm not well-enough versed with the sparse internals to
> know where. It does seem odd to me that it's generating an OP_SCAST to
> convert the int to a double, rather than an OP_FPCAST like in the float.

Sparse assume that float and double have different size than int.
On the linearized instruction level, it does not have the full type
information any more. All it got is the size of the type. So it is
tricky to distinguish int vs float.

It generate cast to double because your third argument is a
double type.

Because the kernel does not have any floating pointer
code. Sparse did not take floating point very seriously.

The change require the instruction to have more type
information than size. I am tempting to just put a full
ctype pointer there.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Odd sparse behaviour ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Odd sparse behaviour
Date: Mon, 07 Jul 2008 19:42:17 +0000
Message-ID: <70318cbf0807071242k445297d0s79d3481eaa5a8899 () mail ! gmail ! com>
--------------------
On Mon, Jul 7, 2008 at 11:09 AM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:

>
>        /* Parse declaration-specifiers, if any */
>        token = declaration_specifiers(token, &ctype, 0);
>        decl = alloc_symbol(token->pos, SYM_NODE);
>        decl->ctype = ctype;
>        token = declarator(token, decl, &ident);
>        apply_modifiers(token->pos, &decl->ctype);
>
> I think that after calling declaration_specifiers(), we should
> check if token_type(token) == TOKEN_IDENT and lookup
> the symbol in the relevant namespaces. If it is found, we shoud
> check if the types and produce soe warnings. And reuse the
> symbol, if the types match.

This is a old bug of sparse and unfortunately very nasty to fix.

I have considered some thing similar to your approach before.
Yours is too simple, it can't handle node is a pointer for example.
But even if we change direct_declarator, there is other problem
with this approach. The type  evaluate happens _after_ the
parsing stage. So at the parsing state it is very hard to answer
the question "if the types match". No to mention "reuse the symbol"
does break a lot of the assumption of the parsing code which
assume symbol node is new. It just blindly assign ctype members
rather than merging it.

On the other hand, breaking that assumption might be a good thing
for other reasons. One of the thing I really want to do is make the
ctype have some optional attribute fields. e.g. no return functions.
We are running out of bits in the ctype attribute. Keep on adding
member to ctype does not scale because it is used every where.

Another approach to this problem is let parsing code create a new node.
Let check_duplicates merge the symbol if the type matches.
Then evaluate_symbol needs to return the merged result symbol
as well. The caller need to either place the current one with
the new symbol or delete the original one from the list.
Replacing the original symbol part seems ugly. On the bright side
there is not too many place needs it. It will have a smaller patch
than the first approach.

I like to heard if any one else have better suggestion as well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: PATCH] pre-process.c: [trivial] Use a larger buffer [4k] for ===

From: Brett Nash <nash () nash ! id ! au>
To: linux-sparse
Subject: PATCH] pre-process.c: [trivial] Use a larger buffer [4k] for
Date: Tue, 02 Sep 2008 23:31:57 +0000
Message-ID: <20080903093157.0e2586cd () shanbei ! fluffyspider ! com>
--------------------
--MP_/QN10/+9fsHIhtgG_qTZ90Tq
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Content-Disposition: inline


--MP_/QN10/+9fsHIhtgG_qTZ90Tq
Content-Type: text/x-patch;
 name=0001-pre-process.c-trivial-Use-a-larger-buffer-4k-fo.patch
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename=0001-pre-process.c-trivial-Use-a-larger-buffer-4k-fo.patch


================================================================================


################################################################################

=== Thread: Pointer arithmetic error ===

From: "Chris Li" <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Thu, 26 Jun 2008 23:51:25 +0000
Message-ID: <70318cbf0806261651u7a163d54m4d100012bce5db49 () mail ! gmail ! com>
--------------------
On Thu, Jun 26, 2008 at 4:40 PM, David Given <dg@cowlark.com> wrote:
>        /* Get the size of whatever the pointer points to */
>        multiply = base->bit_size >> 3;
>
> This divides the bit size by 8 to get the size in bytes. However, this
> doesn't take into account that bits_in_char might not be 8. I think this
> should actually be:
>
>        /* Get the size of whatever the pointer points to */
>        multiply = base->bit_size / bits_in_char;

I don't think so. The offset part of the ptr_add op is mean to be the
absolute offset, not how many element of the pointer index. In other
words, it is how many address number it need to add.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Fri, 27 Jun 2008 09:00:29 +0000
Message-ID: <70318cbf0806270200l27aef92ctbc3fbd4f3cbf9f45 () mail ! gmail ! com>
--------------------
On Thu, Jun 26, 2008 at 5:17 PM, David Given <dg@cowlark.com> wrote:

> Hmm. True. But even so, it's still not right on my system, which doesn't
> use 8-bit bytes. (It's word addressable where each word can contain any
> value, so sizeof(int) == sizeof(double) == sizeof(char) == 1.)

Ah, I see.  I was thinking some thing else.
What platform exactly is that?

> Should there, then, be another symbol to define the number of bits in a
> byte, distinct from the number of bits in a char?

Byte need to big enough to hold the char. Using bits_in_byte is better.
There might be other place in sparse assume byte is 8 bits.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () firmix ! at>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Fri, 27 Jun 2008 09:49:56 +0000
Message-ID: <1214560196.20755.73.camel () tara ! firmix ! at>
--------------------
On Fre, 2008-06-27 at 01:17 +0100, David Given wrote:
> Chris Li wrote:
> [...]
> > I don't think so. The offset part of the ptr_add op is mean to be the
> > absolute offset, not how many element of the pointer index. In other
> > words, it is how many address number it need to add.
> 
> Hmm. True. But even so, it's still not right on my system, which doesn't
> use 8-bit bytes. (It's word addressable where each word can contain any
> value, so sizeof(int) == sizeof(double) == sizeof(char) == 1.)

/usr/include/limits.h should have a correct #define CHAR_BIT.

> Should there, then, be another symbol to define the number of bits in a
> byte, distinct from the number of bits in a char?

In C, there is no type "byte" (unless you typedef oder #define it).
"byte" is usually (but not necessarily) meant as "unsigned char".

	Bernd
-- 
Firmix Software GmbH                   http://www.firmix.at/
mobil: +43 664 4416156                 fax: +43 1 7890849-55
          Embedded Linux Development and Services


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Fri, 27 Jun 2008 10:55:12 +0000
Message-ID: <4864C710.8000208 () cowlark ! com>
--------------------
Bernd Petrovitsch wrote:
[...]
> In C, there is no type "byte" (unless you typedef oder #define it).
> "byte" is usually (but not necessarily) meant as "unsigned char".

The issue here is that sparse is helpful and converts pointer offsets 
into byte offsets when generating code for pointer arithmetic. So:

const int* p = (const char*) 1234;
p += 10;

-->

set.32 %p0 <- 1234
add.32 %p1 <- %p0, 40
(In fact, in this example it'd collapse these together and use 1274 
instead.)

This appears to be done using hard-coded knowledge that a byte (one unit 
of addressingness) is 8 bits wide.

Chris Li wrote:
> Byte need to big enough to hold the char. Using bits_in_byte is better.
> There might be other place in sparse assume byte is 8 bits.

IIRC C specifies that sizeof() returns values measured in chars, but I 
don't believe it specifies any mapping between the size of chars and the 
underlying addressing units --- it should be possible to use 16-bit 
chars, for example, on an 8-bit byte system. Using 32-bit ints, 
sizeof(int) would then return 2; but you wouldn't be able to access 
individual bytes from C.

That's assuming I've remembered the spec correctly, of course --- this 
stuff is annoying subtle.

If you like I'll go and have a look to see if this can be easily fixed 
--- I need to do it anyway. In fact, I have vague recollections that 
load and store were actually using offsets like 0, 1, 2, etc (the 
'right' values), which means they must have been using bits_per_char to 
do their calculations; I need to check up on this.

-- 
David Given
dg@cowlark.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () firmix ! at>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Fri, 27 Jun 2008 11:20:44 +0000
Message-ID: <1214565644.20755.80.camel () tara ! firmix ! at>
--------------------
On Fre, 2008-06-27 at 11:55 +0100, David Given wrote:
> Bernd Petrovitsch wrote:
> [...]
> > In C, there is no type "byte" (unless you typedef oder #define it).
> > "byte" is usually (but not necessarily) meant as "unsigned char".
> 
> The issue here is that sparse is helpful and converts pointer offsets 
> into byte offsets when generating code for pointer arithmetic. So:
> 
> const int* p = (const char*) 1234;
> p += 10;
> 
> -->
> 
> set.32 %p0 <- 1234
> add.32 %p1 <- %p0, 40
> (In fact, in this example it'd collapse these together and use 1274 
> instead.)
> 
> This appears to be done using hard-coded knowledge that a byte (one unit 
> of addressingness) is 8 bits wide.

It is done IMHO with the false knowledge that "sizeof(int) == 4 *
sizeof(char)".
IIUC your hardware (a DSP or what is it exactly) has "sizeof(int) ==
sizeof(char)" so the size of a char (or int) as such is irrelevant.

> Chris Li wrote:
> > Byte need to big enough to hold the char. Using bits_in_byte is better.
> > There might be other place in sparse assume byte is 8 bits.
> 
> IIRC C specifies that sizeof() returns values measured in chars, but I 

ACK. Therefore "sizeof(char) == 1" must always hold.

> don't believe it specifies any mapping between the size of chars and the 
> underlying addressing units --- it should be possible to use 16-bit 

Yes, that's what CHAR_BIT is for.

> chars, for example, on an 8-bit byte system. Using 32-bit ints, 
> sizeof(int) would then return 2; but you wouldn't be able to access 
> individual bytes from C.

ACK (apart from "shift and mask it" ans similar).

	Bernd
-- 
Firmix Software GmbH                   http://www.firmix.at/
mobil: +43 664 4416156                 fax: +43 1 7890849-55
          Embedded Linux Development and Services


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () firmix ! at>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Fri, 27 Jun 2008 14:45:26 +0000
Message-ID: <1214577926.20755.98.camel () tara ! firmix ! at>
--------------------
On Fre, 2008-06-27 at 15:03 +0100, David Given wrote:
> Bernd Petrovitsch wrote:
> > It is done IMHO with the false knowledge that "sizeof(int) == 4 *
> > sizeof(char)".
> 
> No, it's correctly been told that ints are 32 bits wide, but then it's 
> converting this to *bytes* (not chars) by dividing by the hard-coded 

That's the bug. there is no difference between "byte" and "char". Tell
it that a char has 32 bits too *if* it's the case.

> constant 8.

Why do you (or sparse) want to divide a the size of a type where
"sizeof(type) == 1"?
Use (a correct) CHAR_BIT for that.

> (By 'byte' I'm referring to the quantum of addressingness of the 
> underlying machine architecture. In other words, the numbers that are 
> used as parameters as offsets into load and store. This isn't something 
> that's exposed to C except on architectures where sizeof(byte) == 
> sizeof(char), i.e., all sensible ones.)

Such hardware-specific issues must be implemented by the compiler. So
you probably have to extend "sparse" for that feature.

> [...]
> > ACK. Therefore "sizeof(char) == 1" must always hold.
> 
> Yes; but that is only true from C's perspective.

Is there another remotely relevant perspective (let alone more
important) in a C parser?

> We're dealing with things from the machine code perspective, where 
> sizeof(byte) == 1, and sizeof(char) is not necessarily the same as 
> sizeof(byte).

And that's AFAIU the problem: "sizeof(char) == 1" in C (K&R, c8x, c99)
per definitionem. There is no way around it. For all architectures in
the world, past, present and future.

If your hardware has 32bit char, short and int types, there is no way in
C to define a "byte" in a somewhat sane way. Yes, there are bitfields
but that tend to get somewhat clumsy.

Perhaps the are some compiler-specific extensions for such strange
hardware. But then you leave the defined ground and need to implement
them into "sparse" too.

> I find it really helps with this stuff if you are capable of holding two 
> completely contradictory beliefs at the same time. A certain level of 

I'm just pointing out the view of "C" (or what I understand it is).
Since "sparse" is a C code parser, this should matter most (if not all
and only) IMNSHO.
I don't think the (above newly beyond "C" introduced) concept of "byte"
for your specific, unknown and secret CPU/architecture is helpful in any
way.

> insanity can help too...

	Bernd
-- 
Firmix Software GmbH                   http://www.firmix.at/
mobil: +43 664 4416156                 fax: +43 1 7890849-55
          Embedded Linux Development and Services


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Fri, 27 Jun 2008 18:01:08 +0000
Message-ID: <70318cbf0806271101n2f9a65buc72764ee97f9ced9 () mail ! gmail ! com>
--------------------
> In C, there is no type "byte" (unless you typedef oder #define it).
> "byte" is usually (but not necessarily) meant as "unsigned char".

In C spec, there is a concept of "byte". The union return by sizeof()
is byte. Char must fit in a byte. But char does not necessary have the
same bits as byte. Char can have more.

C99: 3.6, 3.7.1

Because char can always fit in byte, sizeof(char) == 1.

> IIRC C specifies that sizeof() returns values measured in chars, but I don't believe it specifies any mapping between the size of chars and the underlying addressing units --- it should be
> possible to use 16-bit chars, for example, on an 8-bit byte system. Using 32-bit ints, sizeof(int) would then return 2; but you wouldn't be able to access individual bytes from C.

sizeof() return value measure in _byte_.
C99: 6.5.3.4

On Fri, Jun 27, 2008 at 8:45 AM, David Given <dg@cowlark.com> wrote:
> Bernd Petrovitsch wrote:
> [...]
>>
>> That's the bug. there is no difference between "byte" and "char". Tell
>> it that a char has 32 bits too *if* it's the case.

No, there is a different between "byte" and "char". See above.


>
> Having checked the standard it turns out that we've been talking at cross
> purposes as I've been using the wrong terminology --- it actually defines
> (unhelpfully) that byte and char are the same size. Sorry for the confusion.
>
> What I was referring to when I previously said (erroneously) 'byte' was 'an
> address delta of 1', as understood by the assembler. Let's just call this a
> 'unit' for clarity. This is not necessarily the same size as a char.

In C's term, that is call a "byte" :-)

> I'm proposing adding a bits_in_unit (or something) setting and then going
> through and tracking down these places and changing them to use it. That way
> it should still work fine on exotic architectures like mine.

You are right that point out a bug (assumption) of sparse which byte is 8 bits.
Using bits_in_byte is instead of 8 is better there.
Using bits_in_char assumes char has same bits as byte. That is my read
of the C spec.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Fri, 27 Jun 2008 23:32:57 +0000
Message-ID: <486578A9.7000900 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig87D352A3E9EA1421B5CCE263
Content-Type: multipart/mixed;
 boundary="------------070305050603040608050108"

This is a multi-part message in MIME format.
--------------070305050603040608050108
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Christopher Li wrote:
[...]
> You are right that point out a bug (assumption) of sparse which byte is=
 8 bits.
> Using bits_in_byte is instead of 8 is better there.
> Using bits_in_char assumes char has same bits as byte. That is my read
> of the C spec.

Yes, indeed, I'd managed to get my terminology muddled to the confusion
of everyone.

Okay, I've gone and looked at the implementation of this stuff; it would
appear that modifying the code to supply the back end with units scaled
in something other than C chars is actually quite complicated, so I
haven't tried to do that. However, I'm enclosing a patch that should,
hopefully, fix the cases where it's assuming 8 bit bytes. Hopefully I've
 managed to catch all the cases, without breaking the octal parse code...=


(I haven't used git before; is this the right format?)

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82 "I have always wished for my computer to be as easy to use as m=
y
=E2=94=82 telephone; my wish has come true because I can no longer figure=
 out
=E2=94=82 how to use my telephone." --- Bjarne Stroustrup

--------------070305050603040608050108
Content-Type: text/plain;
 name="diff"
Content-Transfer-Encoding: base64
Content-Disposition: inline;
 filename="diff"

Y29tbWl0IDA3NTJlMDJkMmM3YzNmNjdiN2MxODM1Yzg2YmY3N2YxMWM4Mzg0ZGQKQXV0aG9y
OiBkZyA8ZGdAY293bGFyay5jb20+CkRhdGU6ICAgU2F0IEp1biAyOCAwMDoyNDozNiAyMDA4
ICswMTAwCgogICAgQ2hhbmdlZCB1c2Ugb2YgaGFyZGNvZGVkIDhzIHdoZW4gY29udmVydGlu
ZyBiaXRzIHRvIGJ5dGVzIHRvIHVzZSBiaXRzX2luX2NoYXIgaW5zdGVhZC4KCmRpZmYgLS1n
aXQgYS9jb21waWxlLWkzODYuYyBiL2NvbXBpbGUtaTM4Ni5jCmluZGV4IDg1MjY0MDguLjNi
YmM5YzcgMTAwNjQ0Ci0tLSBhL2NvbXBpbGUtaTM4Ni5jCisrKyBiL2NvbXBpbGUtaTM4Ni5j
CkBAIC0xNTg0LDcgKzE1ODQsNyBAQCBzdGF0aWMgc3RydWN0IHN0b3JhZ2UgKmVtaXRfc2Vs
ZWN0X2V4cHIoc3RydWN0IGV4cHJlc3Npb24gKmV4cHIpCiAJLyoKIAkgKiBEbyB0aGUgYWN0
dWFsIHNlbGVjdDogY2hlY2sgdGhlIGNvbmRpdGlvbmFsIGZvciB6ZXJvLAogCSAqIG1vdmUg
ZmFsc2Ugb3ZlciB0cnVlIGlmIHplcm8KLQkgKi8gCisJICovCiAJaW5zbigidGVzdCIsIHJl
Z19jb25kLCByZWdfY29uZCwgTlVMTCk7CiAJaW5zbigiY21vdnoiLCByZWdfZmFsc2UsIHJl
Z190cnVlLCBOVUxMKTsKIApAQCAtMjA4MSw3ICsyMDgxLDcgQEAgc3RhdGljIHN0cnVjdCBz
dG9yYWdlICp4ODZfY2FsbF9leHByZXNzaW9uKHN0cnVjdCBleHByZXNzaW9uICpleHByKQog
CQlpbnNuKCJwdXNobCIsIG5ldywgTlVMTCwKIAkJICAgICAhZnJhbWVzaXplID8gImJlZ2lu
IGZ1bmN0aW9uIGNhbGwiIDogTlVMTCk7CiAKLQkJZnJhbWVzaXplICs9IHNpemUgPj4gMzsK
KwkJZnJhbWVzaXplICs9IHNpemUgLyBiaXRzX2luX2NoYXI7CiAJfSBFTkRfRk9SX0VBQ0hf
UFRSX1JFVkVSU0UoYXJnKTsKIAogCWZuID0gZXhwci0+Zm47CmRpZmYgLS1naXQgYS9ldmFs
dWF0ZS5jIGIvZXZhbHVhdGUuYwppbmRleCAyYTEyNmRkLi42MDE4ZTBjIDEwMDY0NAotLS0g
YS9ldmFsdWF0ZS5jCisrKyBiL2V2YWx1YXRlLmMKQEAgLTg3LDEzICs4NywxMyBAQCBzdGF0
aWMgc3RydWN0IHN5bWJvbCAqZXZhbHVhdGVfc3RyaW5nKHN0cnVjdCBleHByZXNzaW9uICpl
eHByKQogCWFycmF5LT5jdHlwZS5hbGlnbm1lbnQgPSAxOwogCWFycmF5LT5jdHlwZS5tb2Rp
ZmllcnMgPSBNT0RfU1RBVElDOwogCWFycmF5LT5jdHlwZS5iYXNlX3R5cGUgPSAmY2hhcl9j
dHlwZTsKLQkKKwogCWFkZHItPnN5bWJvbCA9IHN5bTsKIAlhZGRyLT5jdHlwZSA9ICZsYXp5
X3B0cl9jdHlwZTsKIAogCWV4cHItPnR5cGUgPSBFWFBSX1BSRU9QOwogCWV4cHItPm9wID0g
JyonOwotCWV4cHItPnVub3AgPSBhZGRyOyAgCisJZXhwci0+dW5vcCA9IGFkZHI7CiAJZXhw
ci0+Y3R5cGUgPSBzeW07CiAJcmV0dXJuIHN5bTsKIH0KQEAgLTU3OSw3ICs1NzksNyBAQCBz
dGF0aWMgc3RydWN0IHN5bWJvbCAqZXZhbHVhdGVfcHRyX2FkZChzdHJ1Y3QgZXhwcmVzc2lv
biAqZXhwciwgc3RydWN0IHN5bWJvbCAqaQogCX0KIAogCS8qIEdldCB0aGUgc2l6ZSBvZiB3
aGF0ZXZlciB0aGUgcG9pbnRlciBwb2ludHMgdG8gKi8KLQltdWx0aXBseSA9IGJhc2UtPmJp
dF9zaXplID4+IDM7CisJbXVsdGlwbHkgPSBiYXNlLT5iaXRfc2l6ZSAvIGJpdHNfaW5fY2hh
cjsKIAogCWlmIChjdHlwZSA9PSAmbnVsbF9jdHlwZSkKIAkJY3R5cGUgPSAmcHRyX2N0eXBl
OwpAQCAtODMxLDcgKzgzMSw3IEBAIHN0YXRpYyBzdHJ1Y3Qgc3ltYm9sICpldmFsdWF0ZV9w
dHJfc3ViKHN0cnVjdCBleHByZXNzaW9uICpleHByKQogCQlzdHJ1Y3QgZXhwcmVzc2lvbiAq
c3ViID0gYWxsb2NfZXhwcmVzc2lvbihleHByLT5wb3MsIEVYUFJfQklOT1ApOwogCQlzdHJ1
Y3QgZXhwcmVzc2lvbiAqZGl2ID0gZXhwcjsKIAkJc3RydWN0IGV4cHJlc3Npb24gKnZhbCA9
IGFsbG9jX2V4cHJlc3Npb24oZXhwci0+cG9zLCBFWFBSX1ZBTFVFKTsKLQkJdW5zaWduZWQg
bG9uZyB2YWx1ZSA9IGxiYXNlLT5iaXRfc2l6ZSA+PiAzOworCQl1bnNpZ25lZCBsb25nIHZh
bHVlID0gbGJhc2UtPmJpdF9zaXplIC8gYml0c19pbl9jaGFyOwogCiAJCXZhbC0+Y3R5cGUg
PSBzaXplX3RfY3R5cGU7CiAJCXZhbC0+dmFsdWUgPSB2YWx1ZTsKQEAgLTg1MCw3ICs4NTAs
NyBAQCBzdGF0aWMgc3RydWN0IHN5bWJvbCAqZXZhbHVhdGVfcHRyX3N1YihzdHJ1Y3QgZXhw
cmVzc2lvbiAqZXhwcikKIAkJZGl2LT5sZWZ0ID0gc3ViOwogCQlkaXYtPnJpZ2h0ID0gdmFs
OwogCX0KLQkJCisKIAlyZXR1cm4gc3NpemVfdF9jdHlwZTsKIH0KIApAQCAtMTU5MSw3ICsx
NTkxLDcgQEAgc3RhdGljIHN0cnVjdCBzeW1ib2wgKmRlZ2VuZXJhdGUoc3RydWN0IGV4cHJl
c3Npb24gKmV4cHIpCiAJCQkJZTMtPm9wID0gJysnOwogCQkJCWUzLT5sZWZ0ID0gZTA7CiAJ
CQkJZTMtPnJpZ2h0ID0gYWxsb2NfY29uc3RfZXhwcmVzc2lvbihleHByLT5wb3MsCi0JCQkJ
CQkJZXhwci0+cl9iaXRwb3MgPj4gMyk7CisJCQkJCQkJZXhwci0+cl9iaXRwb3MgLyBiaXRz
X2luX2NoYXIpOwogCQkJCWUzLT5jdHlwZSA9ICZsYXp5X3B0cl9jdHlwZTsKIAkJCX0gZWxz
ZSB7CiAJCQkJZTMgPSBlMDsKQEAgLTE3MjcsNyArMTcyNyw3IEBAIHN0YXRpYyBzdHJ1Y3Qg
c3ltYm9sICpldmFsdWF0ZV9wb3N0b3Aoc3RydWN0IGV4cHJlc3Npb24gKmV4cHIpCiAJfSBl
bHNlIGlmIChjbGFzcyA9PSBUWVBFX1BUUikgewogCQlzdHJ1Y3Qgc3ltYm9sICp0YXJnZXQg
PSBleGFtaW5lX3BvaW50ZXJfdGFyZ2V0KGN0eXBlKTsKIAkJaWYgKCFpc19mdW5jdGlvbih0
YXJnZXQpKQotCQkJbXVsdGlwbHkgPSB0YXJnZXQtPmJpdF9zaXplID4+IDM7CisJCQltdWx0
aXBseSA9IHRhcmdldC0+Yml0X3NpemUgLyBiaXRzX2luX2NoYXI7CiAJfQogCiAJaWYgKG11
bHRpcGx5KSB7CkBAIC0xODUwLDcgKzE4NTAsNyBAQCBzdGF0aWMgc3RydWN0IHN5bWJvbCAq
ZmluZF9pZGVudGlmaWVyKHN0cnVjdCBpZGVudCAqaWRlbnQsIHN0cnVjdCBzeW1ib2xfbGlz
dCAqXwogCQkJCQljb250aW51ZTsKIAkJCQkqb2Zmc2V0ICs9IHN5bS0+b2Zmc2V0OwogCQkJ
CXJldHVybiBzdWI7Ci0JCQl9CQorCQkJfQogCQl9CiAJfSB3aGlsZSAoKGxpc3QgPSBsaXN0
LT5uZXh0KSAhPSBoZWFkKTsKIAlyZXR1cm4gTlVMTDsKQEAgLTE5NDksNyArMTk0OSw3IEBA
IHN0YXRpYyBzdHJ1Y3Qgc3ltYm9sICpldmFsdWF0ZV9tZW1iZXJfZGVyZWZlcmVuY2Uoc3Ry
dWN0IGV4cHJlc3Npb24gKmV4cHIpCiAJCQlleHByLT5iYXNlID0gZGVyZWYtPmJhc2U7CiAJ
CQlleHByLT5yX2JpdHBvcyA9IGRlcmVmLT5yX2JpdHBvczsKIAkJfQotCQlleHByLT5yX2Jp
dHBvcyArPSBvZmZzZXQgPDwgMzsKKwkJZXhwci0+cl9iaXRwb3MgKz0gb2Zmc2V0ICogYml0
c19pbl9jaGFyOwogCQlleHByLT50eXBlID0gRVhQUl9TTElDRTsKIAkJZXhwci0+cl9ucmJp
dHMgPSBtZW1iZXItPmJpdF9zaXplOwogCQlleHByLT5yX2JpdHBvcyArPSBtZW1iZXItPmJp
dF9vZmZzZXQ7CkBAIC0yMDQwLDcgKzIwNDAsNyBAQCBzdGF0aWMgc3RydWN0IHN5bWJvbCAq
ZXZhbHVhdGVfc2l6ZW9mKHN0cnVjdCBleHByZXNzaW9uICpleHByKQogCWlmICgoc2l6ZSA8
IDApIHx8IChzaXplICYgNykpCiAJCWV4cHJlc3Npb25fZXJyb3IoZXhwciwgImNhbm5vdCBz
aXplIGV4cHJlc3Npb24iKTsKIAlleHByLT50eXBlID0gRVhQUl9WQUxVRTsKLQlleHByLT52
YWx1ZSA9IHNpemUgPj4gMzsKKwlleHByLT52YWx1ZSA9IHNpemUgLyBiaXRzX2luX2NoYXI7
CiAJZXhwci0+dGFpbnQgPSAwOwogCWV4cHItPmN0eXBlID0gc2l6ZV90X2N0eXBlOwogCXJl
dHVybiBzaXplX3RfY3R5cGU7CkBAIC0yMDc0LDcgKzIwNzQsNyBAQCBzdGF0aWMgc3RydWN0
IHN5bWJvbCAqZXZhbHVhdGVfcHRyc2l6ZW9mKHN0cnVjdCBleHByZXNzaW9uICpleHByKQog
CWlmIChzaXplICYgNykKIAkJc2l6ZSA9IDA7CiAJZXhwci0+dHlwZSA9IEVYUFJfVkFMVUU7
Ci0JZXhwci0+dmFsdWUgPSBzaXplID4+IDM7CisJZXhwci0+dmFsdWUgPSBzaXplIC8gYml0
c19pbl9jaGFyOwogCWV4cHItPnRhaW50ID0gMDsKIAlleHByLT5jdHlwZSA9IHNpemVfdF9j
dHlwZTsKIAlyZXR1cm4gc2l6ZV90X2N0eXBlOwpAQCAtMjg2NSw3ICsyODY1LDcgQEAgc3Rh
dGljIHN0cnVjdCBzeW1ib2wgKmV2YWx1YXRlX29mZnNldG9mKHN0cnVjdCBleHByZXNzaW9u
ICpleHByKQogCQkJdW5yZXN0cmljdChpZHgsIGlfY2xhc3MsICZpX3R5cGUpOwogCQkJaWR4
ID0gY2FzdF90byhpZHgsIHNpemVfdF9jdHlwZSk7CiAJCQltID0gYWxsb2NfY29uc3RfZXhw
cmVzc2lvbihleHByLT5wb3MsCi0JCQkJCQkgICBjdHlwZS0+Yml0X3NpemUgPj4gMyk7CisJ
CQkJCQkgICBjdHlwZS0+Yml0X3NpemUgLyBiaXRzX2luX2NoYXIpOwogCQkJbS0+Y3R5cGUg
PSBzaXplX3RfY3R5cGU7CiAJCQltLT5mbGFncyA9IEludF9jb25zdF9leHByOwogCQkJZXhw
ci0+dHlwZSA9IEVYUFJfQklOT1A7CmRpZmYgLS1naXQgYS9leGFtcGxlLmMgYi9leGFtcGxl
LmMKaW5kZXggYWU4OTdkYy4uYjg0NGQ0ZiAxMDA2NDQKLS0tIGEvZXhhbXBsZS5jCisrKyBi
L2V4YW1wbGUuYwpAQCAtMjcsNyArMjcsNyBAQCBzdGF0aWMgY29uc3QgY2hhciAqb3Bjb2Rl
c1tdID0gewogCVtPUF9JTlZPS0VdID0gImludm9rZSIsCiAJW09QX0NPTVBVVEVER09UT10g
PSAiam1wICoiLAogCVtPUF9VTldJTkRdID0gInVud2luZCIsCi0JCisKIAkvKiBCaW5hcnkg
Ki8KIAlbT1BfQUREXSA9ICJhZGQiLAogCVtPUF9TVUJdID0gInN1YiIsCkBAIC00MCw3ICs0
MCw3IEBAIHN0YXRpYyBjb25zdCBjaGFyICpvcGNvZGVzW10gPSB7CiAJW09QX1NITF0gPSAi
c2hsIiwKIAlbT1BfTFNSXSA9ICJsc3IiLAogCVtPUF9BU1JdID0gImFzciIsCi0JCisKIAkv
KiBMb2dpY2FsICovCiAJW09QX0FORF0gPSAiYW5kIiwKIAlbT1BfT1JdID0gIm9yIiwKQEAg
LTY2LDcgKzY2LDcgQEAgc3RhdGljIGNvbnN0IGNoYXIgKm9wY29kZXNbXSA9IHsKIAogCS8q
IFNwZWNpYWwgdGhyZWUtaW5wdXQgKi8KIAlbT1BfU0VMXSA9ICJzZWxlY3QiLAotCQorCiAJ
LyogTWVtb3J5ICovCiAJW09QX01BTExPQ10gPSAibWFsbG9jIiwKIAlbT1BfRlJFRV0gPSAi
ZnJlZSIsCkBAIC04MTgsNyArODE4LDcgQEAgc3RhdGljIGNvbnN0IGNoYXIgKmdlbmVyaWMo
c3RydWN0IGJiX3N0YXRlICpzdGF0ZSwgcHNldWRvX3QgcHNldWRvKQogCQlwdXRfb3BlcmFu
ZChzdGF0ZSwgb3ApOwogCQlyZWcgPSB0YXJnZXRfcmVnKHN0YXRlLCBwc2V1ZG8sIE5VTEwp
OwogCQlvdXRwdXRfaW5zbihzdGF0ZSwgImxlYSAlcywlcyIsIHNob3dfb3Aoc3RhdGUsIG9w
KSwgcmVnLT5uYW1lKTsKLQkJcmV0dXJuIHJlZy0+bmFtZTsJCQorCQlyZXR1cm4gcmVnLT5u
YW1lOwogCiAJZGVmYXVsdDoKIAkJc3RyID0gc2hvd19vcChzdGF0ZSwgb3ApOwpAQCAtODcw
LDcgKzg3MCw3IEBAIHN0YXRpYyB2b2lkIGtpbGxfZGVhZF9yZWcoc3RydWN0IGhhcmRyZWcg
KnJlZykKIHsKIAlpZiAocmVnLT5kZWFkKSB7CiAJCXBzZXVkb190IHA7Ci0JCQorCiAJCUZP
Ul9FQUNIX1BUUihyZWctPmNvbnRhaW5zLCBwKSB7CiAJCQlpZiAoQ1VSUkVOVF9UQUcocCkg
JiBUQUdfREVBRCkgewogCQkJCURFTEVURV9DVVJSRU5UX1BUUihwKTsKQEAgLTEwMTEsNyAr
MTAxMSw3IEBAIHN0YXRpYyB2b2lkIGtpbGxfcHNldWRvKHN0cnVjdCBiYl9zdGF0ZSAqc3Rh
dGUsIHBzZXVkb190IHBzZXVkbykKIAkJCQljb250aW51ZTsKIAkJCWlmIChDVVJSRU5UX1RB
RyhwKSAmIFRBR19ERUFEKQogCQkJCXJlZy0+ZGVhZC0tOwotCQkJb3V0cHV0X2NvbW1lbnQo
c3RhdGUsICJyZW1vdmluZyBwc2V1ZG8gJXMgZnJvbSByZWcgJXMiLCAKKwkJCW91dHB1dF9j
b21tZW50KHN0YXRlLCAicmVtb3ZpbmcgcHNldWRvICVzIGZyb20gcmVnICVzIiwKIAkJCQlz
aG93X3BzZXVkbyhwc2V1ZG8pLCByZWctPm5hbWUpOwogCQkJREVMRVRFX0NVUlJFTlRfUFRS
KHApOwogCQl9IEVORF9GT1JfRUFDSF9QVFIocCk7CkBAIC0xMDY5LDcgKzEwNjksNyBAQCBz
dGF0aWMgY29uc3QgY2hhciAqY29uZGl0aW9uYWxbXSA9IHsKIAlbT1BfU0VUX0JFXSA9ICJi
ZSIsCiAJW09QX1NFVF9BRV0gPSAiYWUiCiB9OwotCQorCiAKIHN0YXRpYyB2b2lkIGdlbmVy
YXRlX2JyYW5jaChzdHJ1Y3QgYmJfc3RhdGUgKnN0YXRlLCBzdHJ1Y3QgaW5zdHJ1Y3Rpb24g
KmJyKQogewpAQCAtMTE4Nyw3ICsxMTg3LDcgQEAgc3RhdGljIHZvaWQgcmVwbGFjZV9hc21f
cGVyY2VudChjb25zdCBjaGFyICoqc3JjX3AsIGNoYXIgKipkc3RfcCwgc3RydWN0IGFzbV9h
cmcKIAkJaWYgKGluZGV4IDwgbnIpCiAJCQlyZXBsYWNlX2FzbV9hcmcoZHN0X3AsIGFyZ3Mr
aW5kZXgpOwogCQlicmVhazsKLQl9CQorCX0KIAkqc3JjX3AgPSBzcmM7CiAJcmV0dXJuOwog
fQpAQCAtMTU4Myw3ICsxNTgzLDcgQEAgc3RhdGljIGludCBmaW5hbF9wc2V1ZG9fZmx1c2go
c3RydWN0IGJiX3N0YXRlICpzdGF0ZSwgcHNldWRvX3QgcHNldWRvLCBzdHJ1Y3QgaGEKIAlz
dHJ1Y3QgaGFyZHJlZyAqZHN0OwogCiAJLyoKLQkgKiBTaW5jZSB0aGlzIHBzZXVkbyBpcyBs
aXZlIGF0IGV4aXQsIHdlJ2QgYmV0dGVyIGhhdmUgb3V0cHV0IAorCSAqIFNpbmNlIHRoaXMg
cHNldWRvIGlzIGxpdmUgYXQgZXhpdCwgd2UnZCBiZXR0ZXIgaGF2ZSBvdXRwdXQKIAkgKiBz
dG9yYWdlIGZvciBpdC4uCiAJICovCiAJaGFzaCA9IGZpbmRfc3RvcmFnZV9oYXNoKHBzZXVk
bywgc3RhdGUtPm91dHB1dHMpOwpAQCAtMTgyOSw4ICsxODI5LDggQEAgc3RhdGljIHZvaWQg
c2V0X3VwX2FyY2hfZW50cnkoc3RydWN0IGVudHJ5cG9pbnQgKmVwLCBzdHJ1Y3QgaW5zdHJ1
Y3Rpb24gKmVudHJ5KQogCiAJCQlpbi0+dHlwZSA9IFJFR19GUkFNRTsKIAkJCWluLT5vZmZz
ZXQgPSBvZmZzZXQ7Ci0JCQkKLQkJCW9mZnNldCArPSBiaXRzID4+IDM7CisKKwkJCW9mZnNl
dCArPSBiaXRzIC8gYml0c19pbl9jaGFyOwogCQl9CiAJCWkrKzsKIAkJTkVYVF9QVFJfTElT
VChhcmd0eXBlKTsKQEAgLTE5MzYsNyArMTkzNiw3IEBAIHN0YXRpYyBpbnQgY29tcGlsZShz
dHJ1Y3Qgc3ltYm9sX2xpc3QgKmxpc3QpCiAJCWlmIChlcCkKIAkJCW91dHB1dChlcCk7CiAJ
fSBFTkRfRk9SX0VBQ0hfUFRSKHN5bSk7Ci0JCisKIAlyZXR1cm4gMDsKIH0KIApkaWZmIC0t
Z2l0IGEvZXhwYW5kLmMgYi9leHBhbmQuYwppbmRleCAwMzJmMGM1Li5kMWFhMDE5IDEwMDY0
NAotLS0gYS9leHBhbmQuYworKysgYi9leHBhbmQuYwpAQCAtMTAwLDcgKzEwMCw3IEBAIElu
dDoKIAkvLyBTdG9wIGhlcmUgdW5sZXNzIGNoZWNraW5nIGZvciB0cnVuY2F0aW9uCiAJaWYg
KCFXY2FzdF90cnVuY2F0ZSB8fCBjb25zZXJ2YXRpdmUpCiAJCXJldHVybjsKLQkKKwogCS8v
IENoZWNrIGlmIHdlIGRyb3BwZWQgYW55IGJpdHMuLgogCW9sZHNpZ25tYXNrID0gMVVMTCA8
PCAob2xkX3NpemUtMSk7CiAJb2xkbWFzayA9IG9sZHNpZ25tYXNrIHwgKG9sZHNpZ25tYXNr
LTEpOwpAQCAtMTc5LDcgKzE3OSw3IEBAIHN0YXRpYyBpbnQgc2ltcGxpZnlfaW50X2Jpbm9w
KHN0cnVjdCBleHByZXNzaW9uICpleHByLCBzdHJ1Y3Qgc3ltYm9sICpjdHlwZSkKIAkJc2wg
fD0gfihtYXNrLTEpOwogCWlmIChpc19zaWduZWQgJiYgKHNyICYgbWFzaykpCiAJCXNyIHw9
IH4obWFzay0xKTsKLQkKKwogCXN3aXRjaCAoQ09OVkVSVChleHByLT5vcCxpc19zaWduZWQp
KSB7CiAJY2FzZSBTSUdORUQoJysnKToKIAljYXNlIFVOU0lHTkVEKCcrJyk6CkBAIC0yMjQs
NyArMjI0LDcgQEAgc3RhdGljIGludCBzaW1wbGlmeV9pbnRfYmlub3Aoc3RydWN0IGV4cHJl
c3Npb24gKmV4cHIsIHN0cnVjdCBzeW1ib2wgKmN0eXBlKQogCiAJY2FzZSBVTlNJR05FRCgn
LycpOgogCQlpZiAoIXIpIGdvdG8gRGl2OwotCQl2ID0gbCAvIHI7IAorCQl2ID0gbCAvIHI7
CiAJCWJyZWFrOwogCiAJY2FzZSBTSUdORUQoJyUnKToKQEAgLTI0MSw3ICsyNDEsNyBAQCBz
dGF0aWMgaW50IHNpbXBsaWZ5X2ludF9iaW5vcChzdHJ1Y3QgZXhwcmVzc2lvbiAqZXhwciwg
c3RydWN0IHN5bWJvbCAqY3R5cGUpCiAJY2FzZSBTSUdORUQoU1BFQ0lBTF9MRUZUU0hJRlQp
OgogCWNhc2UgVU5TSUdORUQoU1BFQ0lBTF9MRUZUU0hJRlQpOgogCQl2ID0gbCA8PCByOwot
CQlicmVhazsgCisJCWJyZWFrOwogCiAJY2FzZSBTSUdORUQoU1BFQ0lBTF9SSUdIVFNISUZU
KToKIAkJdiA9IHNsID4+IHI7CkBAIC01MzYsNyArNTM2LDcgQEAgc3RhdGljIGludCBleHBh
bmRfY29uZGl0aW9uYWwoc3RydWN0IGV4cHJlc3Npb24gKmV4cHIpCiAKIAlyZXR1cm4gY29z
dCArIGNvbmRfY29zdCArIEJSQU5DSF9DT1NUOwogfQotCQkKKwogc3RhdGljIGludCBleHBh
bmRfYXNzaWdubWVudChzdHJ1Y3QgZXhwcmVzc2lvbiAqZXhwcikKIHsKIAlleHBhbmRfZXhw
cmVzc2lvbihleHByLT5sZWZ0KTsKQEAgLTgyMiw3ICs4MjIsNyBAQCBzdGF0aWMgaW50IGV4
cGFuZF9leHByZXNzaW9uX2xpc3Qoc3RydWN0IGV4cHJlc3Npb25fbGlzdCAqbGlzdCkKIAly
ZXR1cm4gY29zdDsKIH0KIAotLyogCisvKgogICogV2UgY2FuIHNpbXBsaWZ5IG5lc3RlZCBw
b3NpdGlvbiBleHByZXNzaW9ucyBpZgogICogdGhpcyBpcyBhIHNpbXBsZSAoc2luZ2xlKSBw
b3NpdGlvbmFsIGV4cHJlc3Npb24uCiAgKi8KQEAgLTg4MCw3ICs4ODAsNyBAQCBzdGF0aWMg
dW5zaWduZWQgbG9uZyBiaXRfb2Zmc2V0KGNvbnN0IHN0cnVjdCBleHByZXNzaW9uICpleHBy
KQogewogCXVuc2lnbmVkIGxvbmcgb2Zmc2V0ID0gMDsKIAl3aGlsZSAoZXhwci0+dHlwZSA9
PSBFWFBSX1BPUykgewotCQlvZmZzZXQgKz0gZXhwci0+aW5pdF9vZmZzZXQgPDwgMzsKKwkJ
b2Zmc2V0ICs9IGV4cHItPmluaXRfb2Zmc2V0ICogYml0c19pbl9jaGFyOwogCQlleHByID0g
ZXhwci0+aW5pdF9leHByOwogCX0KIAlpZiAoZXhwciAmJiBleHByLT5jdHlwZSkKZGlmZiAt
LWdpdCBhL2Zsb3cuYyBiL2Zsb3cuYwppbmRleCA4MmZiMjNhLi5iZGIyYzI1IDEwMDY0NAot
LS0gYS9mbG93LmMKKysrIGIvZmxvdy5jCkBAIC0xNiw2ICsxNiw3IEBACiAjaW5jbHVkZSAi
ZXhwcmVzc2lvbi5oIgogI2luY2x1ZGUgImxpbmVhcml6ZS5oIgogI2luY2x1ZGUgImZsb3cu
aCIKKyNpbmNsdWRlICJ0YXJnZXQuaCIKIAogdW5zaWduZWQgbG9uZyBiYl9nZW5lcmF0aW9u
OwogCkBAIC0yNjUsOCArMjY2LDggQEAgdm9pZCBjb252ZXJ0X2xvYWRfaW5zdHJ1Y3Rpb24o
c3RydWN0IGluc3RydWN0aW9uICppbnNuLCBwc2V1ZG9fdCBzcmMpCiAKIHN0YXRpYyBpbnQg
b3ZlcmxhcHBpbmdfbWVtb3Aoc3RydWN0IGluc3RydWN0aW9uICphLCBzdHJ1Y3QgaW5zdHJ1
Y3Rpb24gKmIpCiB7Ci0JdW5zaWduZWQgaW50IGFfc3RhcnQgPSBhLT5vZmZzZXQgPDwgMzsK
LQl1bnNpZ25lZCBpbnQgYl9zdGFydCA9IGItPm9mZnNldCA8PCAzOworCXVuc2lnbmVkIGlu
dCBhX3N0YXJ0ID0gYS0+b2Zmc2V0ICogYml0c19pbl9jaGFyOworCXVuc2lnbmVkIGludCBi
X3N0YXJ0ID0gYi0+b2Zmc2V0ICogYml0c19pbl9jaGFyOwogCXVuc2lnbmVkIGludCBhX3Np
emUgPSBhLT5zaXplOwogCXVuc2lnbmVkIGludCBiX3NpemUgPSBiLT5zaXplOwogCkBAIC0z
NjQsMTEgKzM2NSwxMSBAQCBmb3VuZF9kb21pbmF0b3I6CiAJCXVzZV9wc2V1ZG8oaW5zbiwg
cGhpLCBhZGRfcHNldWRvKGRvbWluYXRvcnMsIHBoaSkpOwogCX0gRU5EX0ZPUl9FQUNIX1BU
UihwYXJlbnQpOwogCXJldHVybiAxOwotfQkJCit9CiAKIC8qCiAgKiBXZSBzaG91bGQgcHJv
YmFibHkgc29ydCB0aGUgcGhpIGxpc3QganVzdCB0byBtYWtlIGl0IGVhc2llciB0byBjb21w
YXJlCi0gKiBsYXRlciBmb3IgZXF1YWxpdHkuIAorICogbGF0ZXIgZm9yIGVxdWFsaXR5Lgog
ICovCiB2b2lkIHJld3JpdGVfbG9hZF9pbnN0cnVjdGlvbihzdHJ1Y3QgaW5zdHJ1Y3Rpb24g
Kmluc24sIHN0cnVjdCBwc2V1ZG9fbGlzdCAqZG9taW5hdG9ycykKIHsKQEAgLTUyOSw3ICs1
MzAsNyBAQCBzdGF0aWMgdm9pZCBraWxsX2RlYWRfc3RvcmVzKHBzZXVkb190IHBzZXVkbywg
dW5zaWduZWQgbG9uZyBnZW5lcmF0aW9uLCBzdHJ1Y3QgYgogICogVGhpcyBzaG91bGQgc2Vl
IGlmIHRoZSAiaW5zbiIgdHJpdmlhbGx5IGRvbWluYXRlcyBzb21lIHByZXZpb3VzIHN0b3Jl
LCBhbmQga2lsbCB0aGUKICAqIHN0b3JlIGlmIHVubmVjZXNzYXJ5LgogICovCi1zdGF0aWMg
dm9pZCBraWxsX2RvbWluYXRlZF9zdG9yZXMocHNldWRvX3QgcHNldWRvLCBzdHJ1Y3QgaW5z
dHJ1Y3Rpb24gKmluc24sIAorc3RhdGljIHZvaWQga2lsbF9kb21pbmF0ZWRfc3RvcmVzKHBz
ZXVkb190IHBzZXVkbywgc3RydWN0IGluc3RydWN0aW9uICppbnNuLAogCXVuc2lnbmVkIGxv
bmcgZ2VuZXJhdGlvbiwgc3RydWN0IGJhc2ljX2Jsb2NrICpiYiwgaW50IGxvY2FsLCBpbnQg
Zm91bmQpCiB7CiAJc3RydWN0IGluc3RydWN0aW9uICpvbmU7CkBAIC01ODEsMTMgKzU4Miwx
NCBAQCB2b2lkIGNoZWNrX2FjY2VzcyhzdHJ1Y3QgaW5zdHJ1Y3Rpb24gKmluc24pCiAJcHNl
dWRvX3QgcHNldWRvID0gaW5zbi0+c3JjOwogCiAJaWYgKGluc24tPmJiICYmIHBzZXVkby0+
dHlwZSA9PSBQU0VVRE9fU1lNKSB7Ci0JCWludCBvZmZzZXQgPSBpbnNuLT5vZmZzZXQsIGJp
dCA9IChvZmZzZXQgPDwgMykgKyBpbnNuLT5zaXplOworCQlpbnQgb2Zmc2V0ID0gaW5zbi0+
b2Zmc2V0LCBiaXQgPSAob2Zmc2V0ICogYml0c19pbl9jaGFyKSArIGluc24tPnNpemU7CiAJ
CXN0cnVjdCBzeW1ib2wgKnN5bSA9IHBzZXVkby0+c3ltOwogCiAJCWlmIChzeW0tPmJpdF9z
aXplID4gMCAmJiAob2Zmc2V0IDwgMCB8fCBiaXQgPiBzeW0tPmJpdF9zaXplKSkKIAkJCXdh
cm5pbmcoaW5zbi0+cG9zLCAiaW52YWxpZCBhY2Nlc3MgJXMgJyVzJyAoJWQgJWQpIiwKIAkJ
CQlvZmZzZXQgPCAwID8gImJlbG93IiA6ICJwYXN0IHRoZSBlbmQgb2YiLAotCQkJCXNob3df
aWRlbnQoc3ltLT5pZGVudCksIG9mZnNldCwgc3ltLT5iaXRfc2l6ZSA+PiAzKTsKKwkJCQlz
aG93X2lkZW50KHN5bS0+aWRlbnQpLCBvZmZzZXQsCisJCQkJc3ltLT5iaXRfc2l6ZSAvIGJp
dHNfaW5fY2hhcik7CiAJfQogfQogCkBAIC03MDUsNyArNzA3LDcgQEAgZXh0ZXJuYWxfdmlz
aWJpbGl0eToKIAkJCX0gRU5EX0ZPUl9FQUNIX1BUUihiYik7CiAJCX0KIAl9Ci0JCQkKKwog
CXJldHVybjsKIH0KIApAQCAtODg3LDcgKzg4OSw3IEBAIHN0YXRpYyB2b2lkIHZyZnlfY2hp
bGRyZW4oc3RydWN0IGJhc2ljX2Jsb2NrICpiYikKIAlkZWZhdWx0OgogCQlicmVhazsKIAl9
Ci0JCQorCiAJRk9SX0VBQ0hfUFRSKGJiLT5jaGlsZHJlbiwgdG1wKSB7CiAJCXZyZnlfYmJf
aW5fbGlzdChiYiwgdG1wLT5wYXJlbnRzKTsKIAl9IEVORF9GT1JfRUFDSF9QVFIodG1wKTsK
ZGlmZiAtLWdpdCBhL3Nob3ctcGFyc2UuYyBiL3Nob3ctcGFyc2UuYwppbmRleCAwNjRhZjMy
Li42M2Q5MTQ0IDEwMDY0NAotLS0gYS9zaG93LXBhcnNlLmMKKysrIGIvc2hvdy1wYXJzZS5j
CkBAIC0yNDYsOCArMjQ2LDggQEAgZGVlcGVyOgogCiAJCXMgPSBtb2RpZmllcl9zdHJpbmco
bW9kKTsKIAkJbGVuID0gc3RybGVuKHMpOwotCQluYW1lLT5zdGFydCAtPSBsZW47ICAgIAot
CQltZW1jcHkobmFtZS0+c3RhcnQsIHMsIGxlbik7ICAKKwkJbmFtZS0+c3RhcnQgLT0gbGVu
OworCQltZW1jcHkobmFtZS0+c3RhcnQsIHMsIGxlbik7CiAJCW1vZCA9IDA7CiAJCWFzID0g
MDsKIAl9CkBAIC00MTIsNyArNDEyLDcgQEAgdm9pZCBzaG93X3N5bWJvbChzdHJ1Y3Qgc3lt
Ym9sICpzeW0pCiAJCXN0cnVjdCBzdGF0ZW1lbnQgKnN0bXQgPSB0eXBlLT5zdG10OwogCQlp
ZiAoc3RtdCkgewogCQkJaW50IHZhbDsKLQkJCXByaW50ZigiXG4iKTsJCQorCQkJcHJpbnRm
KCJcbiIpOwogCQkJdmFsID0gc2hvd19zdGF0ZW1lbnQoc3RtdCk7CiAJCQlpZiAodmFsKQog
CQkJCXByaW50ZigiXHRtb3YuJWRcdFx0cmV0dmFsLCVkXG4iLCBzdG10LT5yZXQtPmJpdF9z
aXplLCB2YWwpOwpAQCAtNTg5LDcgKzU4OSw3IEBAIGludCBzaG93X3N0YXRlbWVudChzdHJ1
Y3Qgc3RhdGVtZW50ICpzdG10KQogCQlpZiAocHJlX2NvbmRpdGlvbikgewogCQkJaWYgKHBy
ZV9jb25kaXRpb24tPnR5cGUgPT0gRVhQUl9WQUxVRSkgewogCQkJCWlmICghcHJlX2NvbmRp
dGlvbi0+dmFsdWUpIHsKLQkJCQkJbG9vcF9ib3R0b20gPSBuZXdfbGFiZWwoKTsgICAKKwkJ
CQkJbG9vcF9ib3R0b20gPSBuZXdfbGFiZWwoKTsKIAkJCQkJcHJpbnRmKCJcdGptcFx0XHQu
TCVkXG4iLCBsb29wX2JvdHRvbSk7CiAJCQkJfQogCQkJfSBlbHNlIHsKQEAgLTYyMyw3ICs2
MjMsNyBAQCBpbnQgc2hvd19zdGF0ZW1lbnQoc3RydWN0IHN0YXRlbWVudCAqc3RtdCkKIAl9
CiAJY2FzZSBTVE1UX05PTkU6CiAJCWJyZWFrOwotCQorCiAJY2FzZSBTVE1UX0xBQkVMOgog
CQlwcmludGYoIi5MJXA6XG4iLCBzdG10LT5sYWJlbF9pZGVudGlmaWVyKTsKIAkJc2hvd19z
dGF0ZW1lbnQoc3RtdC0+bGFiZWxfc3RhdGVtZW50KTsKQEAgLTY0OSw5ICs2NDksOSBAQCBp
bnQgc2hvd19zdGF0ZW1lbnQoc3RydWN0IHN0YXRlbWVudCAqc3RtdCkKIAkJaW50IHZhbCA9
IHNob3dfZXhwcmVzc2lvbihzdG10LT5yYW5nZV9leHByZXNzaW9uKTsKIAkJaW50IGxvdyA9
IHNob3dfZXhwcmVzc2lvbihzdG10LT5yYW5nZV9sb3cpOwogCQlpbnQgaGlnaCA9IHNob3df
ZXhwcmVzc2lvbihzdG10LT5yYW5nZV9oaWdoKTsKLQkJcHJpbnRmKCJcdHJhbmdlKCAlZCAl
ZC0lZClcbiIsIHZhbCwgbG93LCBoaWdoKTsgCisJCXByaW50ZigiXHRyYW5nZSggJWQgJWQt
JWQpXG4iLCB2YWwsIGxvdywgaGlnaCk7CiAJCWJyZWFrOwotCX0JCisJfQogCX0KIAlyZXR1
cm4gMDsKIH0KQEAgLTY3Myw3ICs2NzMsNyBAQCBzdGF0aWMgaW50IHNob3dfY2FsbF9leHBy
ZXNzaW9uKHN0cnVjdCBleHByZXNzaW9uICpleHByKQogCQlpbnQgbmV3ID0gc2hvd19leHBy
ZXNzaW9uKGFyZyk7CiAJCWludCBzaXplID0gYXJnLT5jdHlwZS0+Yml0X3NpemU7CiAJCXBy
aW50ZigiXHRwdXNoLiVkXHRcdHYlZFxuIiwgc2l6ZSwgbmV3KTsKLQkJZnJhbWVzaXplICs9
IHNpemUgPj4gMzsKKwkJZnJhbWVzaXplICs9IHNpemUgLyBiaXRzX2luX2NoYXI7CiAJfSBF
TkRfRk9SX0VBQ0hfUFRSX1JFVkVSU0UoYXJnKTsKIAogCWZuID0gZXhwci0+Zm47CkBAIC04
NDUsNyArODQ1LDcgQEAgc3RhdGljIGludCBzaG93X2luY19kZWMoc3RydWN0IGV4cHJlc3Np
b24gKmV4cHIsIGludCBwb3N0b3ApCiAJcHJpbnRmKCJcdCVzLiVkXHRcdHYlZCx2JWQsJDFc
biIsIG9wbmFtZSwgYml0cywgbmV3LCByZXR2YWwpOwogCXNob3dfc3RvcmVfZ2VuKGJpdHMs
IG5ldywgZXhwci0+dW5vcCwgYWRkcik7CiAJcmV0dXJuIHJldHZhbDsKLX0JCit9CiAKIHN0
YXRpYyBpbnQgc2hvd19wcmVvcChzdHJ1Y3QgZXhwcmVzc2lvbiAqZXhwcikKIHsKQEAgLTg2
NCw3ICs4NjQsNyBAQCBzdGF0aWMgaW50IHNob3dfcHJlb3Aoc3RydWN0IGV4cHJlc3Npb24g
KmV4cHIpCiBzdGF0aWMgaW50IHNob3dfcG9zdG9wKHN0cnVjdCBleHByZXNzaW9uICpleHBy
KQogewogCXJldHVybiBzaG93X2luY19kZWMoZXhwciwgMSk7Ci19CQorfQogCiBzdGF0aWMg
aW50IHNob3dfc3ltYm9sX2V4cHIoc3RydWN0IHN5bWJvbCAqc3ltKQogewpAQCAtOTE4LDcg
KzkxOCw3IEBAIHN0YXRpYyBpbnQgc2hvd19jYXN0X2V4cHIoc3RydWN0IGV4cHJlc3Npb24g
KmV4cHIpCiAKIAlvbGRfdHlwZSA9IGV4cHItPmNhc3RfZXhwcmVzc2lvbi0+Y3R5cGU7CiAJ
bmV3X3R5cGUgPSBleHByLT5jYXN0X3R5cGU7Ci0JCisKIAlvbGRiaXRzID0gb2xkX3R5cGUt
PmJpdF9zaXplOwogCW5ld2JpdHMgPSBuZXdfdHlwZS0+Yml0X3NpemU7CiAJaWYgKG9sZGJp
dHMgPj0gbmV3Yml0cykKQEAgLTEwMTcsNyArMTAxNyw3IEBAIGFnYWluOgogCQkJZW50cnkg
PSBlbnRyeS0+aWRlbnRfZXhwcmVzc2lvbjsKIAkJCWdvdG8gYWdhaW47CiAJCX0KLQkJCQor
CiAJCWlmIChlbnRyeS0+dHlwZSA9PSBFWFBSX0lOREVYKSB7CiAJCQlwcmludGYoIiBBVCAn
JWQuLiVkOlxuIiwgZW50cnktPmlkeF9mcm9tLCBlbnRyeS0+aWR4X3RvKTsKIAkJCWVudHJ5
ID0gZW50cnktPmlkeF9leHByZXNzaW9uOwpAQCAtMTA1NywxMSArMTA1NywxMSBAQCBpbnQg
c2hvd19leHByZXNzaW9uKHN0cnVjdCBleHByZXNzaW9uICpleHByKQogCQkJcG9zLT5saW5l
LCBwb3MtPnBvcyk7CiAJCXJldHVybiAwOwogCX0KLQkJCisKIAlzd2l0Y2ggKGV4cHItPnR5
cGUpIHsKIAljYXNlIEVYUFJfQ0FMTDoKIAkJcmV0dXJuIHNob3dfY2FsbF9leHByZXNzaW9u
KGV4cHIpOwotCQkKKwogCWNhc2UgRVhQUl9BU1NJR05NRU5UOgogCQlyZXR1cm4gc2hvd19h
c3NpZ25tZW50KGV4cHIpOwogCmRpZmYgLS1naXQgYS9zeW1ib2wuYyBiL3N5bWJvbC5jCmlu
ZGV4IDMyOTI5MDcuLmEyMjczMWYgMTAwNjQ0Ci0tLSBhL3N5bWJvbC5jCisrKyBiL3N5bWJv
bC5jCkBAIC0yMiw3ICsyMiw3IEBACiAKIC8qCiAgKiBTZWNvbmRhcnkgc3ltYm9sIGxpc3Qg
Zm9yIHN0dWZmIHRoYXQgbmVlZHMgdG8gYmUgb3V0cHV0IGJlY2F1c2UgaXQKLSAqIHdhcyB1
c2VkLiAKKyAqIHdhcyB1c2VkLgogICovCiBzdHJ1Y3Qgc3ltYm9sX2xpc3QgKnRyYW5zbGF0
aW9uX3VuaXRfdXNlZF9saXN0ID0gTlVMTDsKIApAQCAtMTE3LDcgKzExNyw3IEBAIHN0YXRp
YyB2b2lkIGxheV9vdXRfc3RydWN0KHN0cnVjdCBzeW1ib2wgKnN5bSwgc3RydWN0IHN0cnVj
dF91bmlvbl9pbmZvICppbmZvKQogCX0KIAogCWJpdF9zaXplID0gaW5mby0+Yml0X3NpemU7
Ci0JYmFzZV9zaXplID0gc3ltLT5iaXRfc2l6ZTsgCisJYmFzZV9zaXplID0gc3ltLT5iaXRf
c2l6ZTsKIAogCS8qCiAJICogVW5zaXplZCBhcnJheXMgY2F1c2UgdXMgdG8gbm90IGFsaWdu
IHRoZSByZXN1bHRpbmcKQEAgLTEyOCw3ICsxMjgsNyBAQCBzdGF0aWMgdm9pZCBsYXlfb3V0
X3N0cnVjdChzdHJ1Y3Qgc3ltYm9sICpzeW0sIHN0cnVjdCBzdHJ1Y3RfdW5pb25faW5mbyAq
aW5mbykKIAkJYmFzZV9zaXplID0gMDsKIAl9CiAKLQlhbGlnbl9iaXRfbWFzayA9IChzeW0t
PmN0eXBlLmFsaWdubWVudCA8PCAzKSAtIDE7CisJYWxpZ25fYml0X21hc2sgPSAoc3ltLT5j
dHlwZS5hbGlnbm1lbnQgKiBiaXRzX2luX2NoYXIpIC0gMTsKIAogCS8qCiAJICogQml0Zmll
bGRzIGhhdmUgc29tZSB2ZXJ5IHNwZWNpYWwgcnVsZXMuLgpAQCAtMTQzLDcgKzE0Myw3IEBA
IHN0YXRpYyB2b2lkIGxheV9vdXRfc3RydWN0KHN0cnVjdCBzeW1ib2wgKnN5bSwgc3RydWN0
IHN0cnVjdF91bmlvbl9pbmZvICppbmZvKQogCQkJYml0X3NpemUgPSAoYml0X3NpemUgKyBh
bGlnbl9iaXRfbWFzaykgJiB+YWxpZ25fYml0X21hc2s7CiAJCQliaXRfb2Zmc2V0ID0gMDsK
IAkJfQotCQlzeW0tPm9mZnNldCA9IChiaXRfc2l6ZSAtIGJpdF9vZmZzZXQpID4+IDM7CisJ
CXN5bS0+b2Zmc2V0ID0gKGJpdF9zaXplIC0gYml0X29mZnNldCkgLyBiaXRzX2luX2NoYXI7
CiAJCXN5bS0+Yml0X29mZnNldCA9IGJpdF9vZmZzZXQ7CiAJCXN5bS0+Y3R5cGUuYmFzZV90
eXBlLT5iaXRfb2Zmc2V0ID0gYml0X29mZnNldDsKIAkJaW5mby0+Yml0X3NpemUgPSBiaXRf
c2l6ZSArIHdpZHRoOwpAQCAtMTU2LDcgKzE1Niw3IEBAIHN0YXRpYyB2b2lkIGxheV9vdXRf
c3RydWN0KHN0cnVjdCBzeW1ib2wgKnN5bSwgc3RydWN0IHN0cnVjdF91bmlvbl9pbmZvICpp
bmZvKQogCSAqIE90aGVyd2lzZSwganVzdCBhbGlnbiBpdCByaWdodCBhbmQgYWRkIGl0IHVw
Li4KIAkgKi8KIAliaXRfc2l6ZSA9IChiaXRfc2l6ZSArIGFsaWduX2JpdF9tYXNrKSAmIH5h
bGlnbl9iaXRfbWFzazsKLQlzeW0tPm9mZnNldCA9IGJpdF9zaXplID4+IDM7CisJc3ltLT5v
ZmZzZXQgPSBiaXRfc2l6ZSAvIGJpdHNfaW5fY2hhcjsKIAogCWluZm8tPmJpdF9zaXplID0g
Yml0X3NpemUgKyBiYXNlX3NpemU7CiAJLy8gd2FybmluZyAoc3ltLT5wb3MsICJyZWd1bGFy
OiBvZmZzZXQ9JWQiLCBzeW0tPm9mZnNldCk7CkBAIC0xODIsNyArMTgyLDcgQEAgc3RhdGlj
IHN0cnVjdCBzeW1ib2wgKiBleGFtaW5lX3N0cnVjdF91bmlvbl90eXBlKHN0cnVjdCBzeW1i
b2wgKnN5bSwgaW50IGFkdmFuY2UKIAkJc3ltLT5jdHlwZS5hbGlnbm1lbnQgPSBpbmZvLm1h
eF9hbGlnbjsKIAliaXRfc2l6ZSA9IGluZm8uYml0X3NpemU7CiAJaWYgKGluZm8uYWxpZ25f
c2l6ZSkgewotCQliaXRfYWxpZ24gPSAoc3ltLT5jdHlwZS5hbGlnbm1lbnQgPDwgMyktMTsK
KwkJYml0X2FsaWduID0gKHN5bS0+Y3R5cGUuYWxpZ25tZW50ICogYml0c19pbl9jaGFyKS0x
OwogCQliaXRfc2l6ZSA9IChiaXRfc2l6ZSArIGJpdF9hbGlnbikgJiB+Yml0X2FsaWduOwog
CX0KIAlzeW0tPmJpdF9zaXplID0gYml0X3NpemU7CkBAIC0zNDAsNyArMzQwLDcgQEAgc3Rh
dGljIHN0cnVjdCBzeW1ib2wgKiBleGFtaW5lX25vZGVfdHlwZShzdHJ1Y3Qgc3ltYm9sICpz
eW0pCiAJCWlmIChub2RlX3R5cGUgJiYgbm9kZV90eXBlLT5iaXRfc2l6ZSA+PSAwKQogCQkJ
Yml0X3NpemUgPSBub2RlX3R5cGUtPmJpdF9zaXplICogY291bnQ7CiAJfQotCQorCiAJc3lt
LT5iaXRfc2l6ZSA9IGJpdF9zaXplOwogCXJldHVybiBzeW07CiB9CkBAIC02NTQsNyArNjU0
LDcgQEAgc3RhdGljIGludCBleHBhbmRfd2FybmluZyhzdHJ1Y3QgZXhwcmVzc2lvbiAqZXhw
ciwgaW50IGNvc3QpCiAJRk9SX0VBQ0hfUFRSIChhcmdsaXN0LCBhcmcpIHsKIAkJLyoKIAkJ
ICogQ29uc3RhbnQgc3RyaW5ncyBnZXQgcHJpbnRlZCBvdXQgYXMgYSB3YXJuaW5nLiBCeSB0
aGUKLQkJICogdGltZSB3ZSBnZXQgaGVyZSwgdGhlIEVYUFJfU1RSSU5HIGhhcyBiZWVuIGZ1
bGx5IAorCQkgKiB0aW1lIHdlIGdldCBoZXJlLCB0aGUgRVhQUl9TVFJJTkcgaGFzIGJlZW4g
ZnVsbHkKIAkJICogZXZhbHVhdGVkLCBzbyBieSBub3cgaXQncyBhbiBhbm9ueW1vdXMgc3lt
Ym9sIHdpdGggYQogCQkgKiBzdHJpbmcgaW5pdGlhbGl6ZXIuCiAJCSAqCkBAIC04NzcsNyAr
ODc3LDcgQEAgdm9pZCBpbml0X2N0eXBlKHZvaWQpCiAJCXN0cnVjdCBzeW1ib2wgKnN5bSA9
IGN0eXBlLT5wdHI7CiAJCXVuc2lnbmVkIGxvbmcgYml0X3NpemUgPSBjdHlwZS0+Yml0X3Np
emUgPyAqY3R5cGUtPmJpdF9zaXplIDogLTE7CiAJCXVuc2lnbmVkIGxvbmcgbWF4YWxpZ24g
PSBjdHlwZS0+bWF4YWxpZ24gPyAqY3R5cGUtPm1heGFsaWduIDogMDsKLQkJdW5zaWduZWQg
bG9uZyBhbGlnbm1lbnQgPSAoYml0X3NpemUgKyA3KSA+PiAzOworCQl1bnNpZ25lZCBsb25n
IGFsaWdubWVudCA9IChiaXRfc2l6ZSArIGJpdHNfaW5fY2hhciAtIDEpIC8gYml0c19pbl9j
aGFyOwogCiAJCWlmIChhbGlnbm1lbnQgPiBtYXhhbGlnbikKIAkJCWFsaWdubWVudCA9IG1h
eGFsaWduOwpkaWZmIC0tZ2l0IGEvdGFyZ2V0LmMgYi90YXJnZXQuYwppbmRleCBiZjFiYjhm
Li5hMGVlMDEwIDEwMDY0NAotLS0gYS90YXJnZXQuYworKysgYi90YXJnZXQuYwpAQCAtMTEs
NiArMTEsOCBAQCBzdHJ1Y3Qgc3ltYm9sICpzc2l6ZV90X2N0eXBlID0gJmludF9jdHlwZTsK
ICAqLwogaW50IG1heF9hbGlnbm1lbnQgPSAxNjsKIAoraW50IGJpdHNfaW5fdW5pdCA9IDg7
CisKIC8qCiAgKiBJbnRlZ2VyIGRhdGEgdHlwZXMKICAqLwpkaWZmIC0tZ2l0IGEvdG9rZW5p
emUuYyBiL3Rva2VuaXplLmMKaW5kZXggZTcyYzU2ZS4uNjdkYWE5NyAxMDA2NDQKLS0tIGEv
dG9rZW5pemUuYworKysgYi90b2tlbml6ZS5jCkBAIC05Niw3ICs5Niw3IEBAIHN0YXRpYyBj
aGFyICpjaGFyc3RyKGNoYXIgKnB0ciwgdW5zaWduZWQgY2hhciBjLCB1bnNpZ25lZCBjaGFy
IGVzY2FwZSwgdW5zaWduZWQKIAl9CiAJaWYgKCFpc2RpZ2l0KG5leHQpKQogCQlyZXR1cm4g
cHRyICsgc3ByaW50ZihwdHIsICIlbyIsIGMpOwotCQkKKwogCXJldHVybiBwdHIgKyBzcHJp
bnRmKHB0ciwgIiUwM28iLCBjKTsKIH0KIApAQCAtMTYxLDcgKzE2MSw3IEBAIGNvbnN0IGNo
YXIgKnNob3dfdG9rZW4oY29uc3Qgc3RydWN0IHRva2VuICp0b2tlbikKIAljYXNlIFRPS0VO
X1NUUkVBTUVORDoKIAkJc3ByaW50ZihidWZmZXIsICI8ZW5kIG9mICclcyc+Iiwgc3RyZWFt
X25hbWUodG9rZW4tPnBvcy5zdHJlYW0pKTsKIAkJcmV0dXJuIGJ1ZmZlcjsKLQkKKwogCWRl
ZmF1bHQ6CiAJCXJldHVybiAiV1RGPz8/IjsKIAl9CkBAIC00ODMsNyArNDgzLDcgQEAgc3Rh
dGljIGludCBlc2NhcGVjaGFyKGludCBmaXJzdCwgaW50IHR5cGUsIHN0cmVhbV90ICpzdHJl
YW0sIGludCAqdmFscCkKIAkJCQlpbnQgbnIgPSAyOwogCQkJCXZhbHVlIC09ICcwJzsKIAkJ
CQl3aGlsZSAobmV4dCA+PSAnMCcgJiYgbmV4dCA8PSAnOScpIHsKLQkJCQkJdmFsdWUgPSAo
dmFsdWUgPDwgMykgKyAobmV4dC0nMCcpOworCQkJCQl2YWx1ZSA9ICh2YWx1ZSo4KSArIChu
ZXh0LScwJyk7CiAJCQkJCW5leHQgPSBuZXh0Y2hhcihzdHJlYW0pOwogCQkJCQlpZiAoIS0t
bnIpCiAJCQkJCQlicmVhazsKQEAgLTU3Miw3ICs1NzIsNyBAQCBzdGF0aWMgaW50IGdldF9z
dHJpbmdfdG9rZW4oaW50IG5leHQsIHN0cmVhbV90ICpzdHJlYW0pCiAJdG9rZW5fdHlwZSh0
b2tlbikgPSBUT0tFTl9TVFJJTkc7CiAJdG9rZW4tPnN0cmluZyA9IHN0cmluZzsKIAlhZGRf
dG9rZW4oc3RyZWFtKTsKLQkKKwogCXJldHVybiBuZXh0OwogfQogCkBAIC04NzUsNyArODc1
LDcgQEAgc3RhdGljIGludCBnZXRfb25lX2lkZW50aWZpZXIoaW50IGMsIHN0cmVhbV90ICpz
dHJlYW0pCiAJdG9rZW4tPmlkZW50ID0gaWRlbnQ7CiAJYWRkX3Rva2VuKHN0cmVhbSk7CiAJ
cmV0dXJuIG5leHQ7Ci19CQkKK30KIAogc3RhdGljIGludCBnZXRfb25lX3Rva2VuKGludCBj
LCBzdHJlYW1fdCAqc3RyZWFtKQogewo=
--------------070305050603040608050108--

--------------enig87D352A3E9EA1421B5CCE263
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIZXisf9E0noFvlzgRAjvIAJwPZAhv7nP5dtc5zLnMwqPblrs8AQCgxMu7
EZzbDf2JwXyEtXgE8G8p18Y=
=qzTk
-----END PGP SIGNATURE-----

--------------enig87D352A3E9EA1421B5CCE263--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Sat, 28 Jun 2008 00:17:43 +0000
Message-ID: <70318cbf0806271717v42f4b1e0ocbdf9498b1417878 () mail ! gmail ! com>
--------------------
Your patch is white space damaged.

While you are there, you might want to consider macro

bits_to_byte(x)
byte_to_bits(x)

To isolate out the conversion. It should generate the same code.
Marginally more readable.

Chris

On Fri, Jun 27, 2008 at 4:32 PM, David Given <dg@cowlark.com> wrote:
> Christopher Li wrote:
> [...]
>> You are right that point out a bug (assumption) of sparse which byte is 8 bits.
>> Using bits_in_byte is instead of 8 is better there.
>> Using bits_in_char assumes char has same bits as byte. That is my read
>> of the C spec.
>
> Yes, indeed, I'd managed to get my terminology muddled to the confusion
> of everyone.
>
> Okay, I've gone and looked at the implementation of this stuff; it would
> appear that modifying the code to supply the back end with units scaled
> in something other than C chars is actually quite complicated, so I
> haven't tried to do that. However, I'm enclosing a patch that should,
> hopefully, fix the cases where it's assuming 8 bit bytes. Hopefully I've
>  managed to catch all the cases, without breaking the octal parse code...
>
> (I haven't used git before; is this the right format?)
>
> --
> $B(#(!(!(!(B $B#d#g!w#c#o#w#l#a#r#k!%#c#o#m(B $B(!(!(!(!(!(B http://www.cowlark.com $B(!(!(!(!(!(B
> $B("(B "I have always wished for my computer to be as easy to use as my
> $B("(B telephone; my wish has come true because I can no longer figure out
> $B("(B how to use my telephone." --- Bjarne Stroustrup
>
> commit 0752e02d2c7c3f67b7c1835c86bf77f11c8384dd
> Author: dg <dg@cowlark.com>
> Date:   Sat Jun 28 00:24:36 2008 +0100
>
>    Changed use of hardcoded 8s when converting bits to bytes to use bits_in_char instead.
>
> diff --git a/compile-i386.c b/compile-i386.c
> index 8526408..3bbc9c7 100644
> --- a/compile-i386.c
> +++ b/compile-i386.c
> @@ -1584,7 +1584,7 @@ static struct storage *emit_select_expr(struct expression *expr)
>        /*
>         * Do the actual select: check the conditional for zero,
>         * move false over true if zero
> -        */
> +        */
>        insn("test", reg_cond, reg_cond, NULL);
>        insn("cmovz", reg_false, reg_true, NULL);
>
> @@ -2081,7 +2081,7 @@ static struct storage *x86_call_expression(struct expression *expr)
>                insn("pushl", new, NULL,
>                     !framesize ? "begin function call" : NULL);
>
> -               framesize += size >> 3;
> +               framesize += size / bits_in_char;
>        } END_FOR_EACH_PTR_REVERSE(arg);
>
>        fn = expr->fn;
> diff --git a/evaluate.c b/evaluate.c
> index 2a126dd..6018e0c 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -87,13 +87,13 @@ static struct symbol *evaluate_string(struct expression *expr)
>        array->ctype.alignment = 1;
>        array->ctype.modifiers = MOD_STATIC;
>        array->ctype.base_type = &char_ctype;
> -
> +
>        addr->symbol = sym;
>        addr->ctype = &lazy_ptr_ctype;
>
>        expr->type = EXPR_PREOP;
>        expr->op = '*';
> -       expr->unop = addr;
> +       expr->unop = addr;
>        expr->ctype = sym;
>        return sym;
>  }
> @@ -579,7 +579,7 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
>        }
>
>        /* Get the size of whatever the pointer points to */
> -       multiply = base->bit_size >> 3;
> +       multiply = base->bit_size / bits_in_char;
>
>        if (ctype == &null_ctype)
>                ctype = &ptr_ctype;
> @@ -831,7 +831,7 @@ static struct symbol *evaluate_ptr_sub(struct expression *expr)
>                struct expression *sub = alloc_expression(expr->pos, EXPR_BINOP);
>                struct expression *div = expr;
>                struct expression *val = alloc_expression(expr->pos, EXPR_VALUE);
> -               unsigned long value = lbase->bit_size >> 3;
> +               unsigned long value = lbase->bit_size / bits_in_char;
>
>                val->ctype = size_t_ctype;
>                val->value = value;
> @@ -850,7 +850,7 @@ static struct symbol *evaluate_ptr_sub(struct expression *expr)
>                div->left = sub;
>                div->right = val;
>        }
> -
> +
>        return ssize_t_ctype;
>  }
>
> @@ -1591,7 +1591,7 @@ static struct symbol *degenerate(struct expression *expr)
>                                e3->op = '+';
>                                e3->left = e0;
>                                e3->right = alloc_const_expression(expr->pos,
> -                                                       expr->r_bitpos >> 3);
> +                                                       expr->r_bitpos / bits_in_char);
>                                e3->ctype = &lazy_ptr_ctype;
>                        } else {
>                                e3 = e0;
> @@ -1727,7 +1727,7 @@ static struct symbol *evaluate_postop(struct expression *expr)
>        } else if (class == TYPE_PTR) {
>                struct symbol *target = examine_pointer_target(ctype);
>                if (!is_function(target))
> -                       multiply = target->bit_size >> 3;
> +                       multiply = target->bit_size / bits_in_char;
>        }
>
>        if (multiply) {
> @@ -1850,7 +1850,7 @@ static struct symbol *find_identifier(struct ident *ident, struct symbol_list *_
>                                        continue;
>                                *offset += sym->offset;
>                                return sub;
> -                       }
> +                       }
>                }
>        } while ((list = list->next) != head);
>        return NULL;
> @@ -1949,7 +1949,7 @@ static struct symbol *evaluate_member_dereference(struct expression *expr)
>                        expr->base = deref->base;
>                        expr->r_bitpos = deref->r_bitpos;
>                }
> -               expr->r_bitpos += offset << 3;
> +               expr->r_bitpos += offset * bits_in_char;
>                expr->type = EXPR_SLICE;
>                expr->r_nrbits = member->bit_size;
>                expr->r_bitpos += member->bit_offset;
> @@ -2040,7 +2040,7 @@ static struct symbol *evaluate_sizeof(struct expression *expr)
>        if ((size < 0) || (size & 7))
>                expression_error(expr, "cannot size expression");
>        expr->type = EXPR_VALUE;
> -       expr->value = size >> 3;
> +       expr->value = size / bits_in_char;
>        expr->taint = 0;
>        expr->ctype = size_t_ctype;
>        return size_t_ctype;
> @@ -2074,7 +2074,7 @@ static struct symbol *evaluate_ptrsizeof(struct expression *expr)
>        if (size & 7)
>                size = 0;
>        expr->type = EXPR_VALUE;
> -       expr->value = size >> 3;
> +       expr->value = size / bits_in_char;
>        expr->taint = 0;
>        expr->ctype = size_t_ctype;
>        return size_t_ctype;
> @@ -2865,7 +2865,7 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
>                        unrestrict(idx, i_class, &i_type);
>                        idx = cast_to(idx, size_t_ctype);
>                        m = alloc_const_expression(expr->pos,
> -                                                  ctype->bit_size >> 3);
> +                                                  ctype->bit_size / bits_in_char);
>                        m->ctype = size_t_ctype;
>                        m->flags = Int_const_expr;
>                        expr->type = EXPR_BINOP;
> diff --git a/example.c b/example.c
> index ae897dc..b844d4f 100644
> --- a/example.c
> +++ b/example.c
> @@ -27,7 +27,7 @@ static const char *opcodes[] = {
>        [OP_INVOKE] = "invoke",
>        [OP_COMPUTEDGOTO] = "jmp *",
>        [OP_UNWIND] = "unwind",
> -
> +
>        /* Binary */
>        [OP_ADD] = "add",
>        [OP_SUB] = "sub",
> @@ -40,7 +40,7 @@ static const char *opcodes[] = {
>        [OP_SHL] = "shl",
>        [OP_LSR] = "lsr",
>        [OP_ASR] = "asr",
> -
> +
>        /* Logical */
>        [OP_AND] = "and",
>        [OP_OR] = "or",
> @@ -66,7 +66,7 @@ static const char *opcodes[] = {
>
>        /* Special three-input */
>        [OP_SEL] = "select",
> -
> +
>        /* Memory */
>        [OP_MALLOC] = "malloc",
>        [OP_FREE] = "free",
> @@ -818,7 +818,7 @@ static const char *generic(struct bb_state *state, pseudo_t pseudo)
>                put_operand(state, op);
>                reg = target_reg(state, pseudo, NULL);
>                output_insn(state, "lea %s,%s", show_op(state, op), reg->name);
> -               return reg->name;
> +               return reg->name;
>
>        default:
>                str = show_op(state, op);
> @@ -870,7 +870,7 @@ static void kill_dead_reg(struct hardreg *reg)
>  {
>        if (reg->dead) {
>                pseudo_t p;
> -
> +
>                FOR_EACH_PTR(reg->contains, p) {
>                        if (CURRENT_TAG(p) & TAG_DEAD) {
>                                DELETE_CURRENT_PTR(p);
> @@ -1011,7 +1011,7 @@ static void kill_pseudo(struct bb_state *state, pseudo_t pseudo)
>                                continue;
>                        if (CURRENT_TAG(p) & TAG_DEAD)
>                                reg->dead--;
> -                       output_comment(state, "removing pseudo %s from reg %s",
> +                       output_comment(state, "removing pseudo %s from reg %s",
>                                show_pseudo(pseudo), reg->name);
>                        DELETE_CURRENT_PTR(p);
>                } END_FOR_EACH_PTR(p);
> @@ -1069,7 +1069,7 @@ static const char *conditional[] = {
>        [OP_SET_BE] = "be",
>        [OP_SET_AE] = "ae"
>  };
> -
> +
>
>  static void generate_branch(struct bb_state *state, struct instruction *br)
>  {
> @@ -1187,7 +1187,7 @@ static void replace_asm_percent(const char **src_p, char **dst_p, struct asm_arg
>                if (index < nr)
>                        replace_asm_arg(dst_p, args+index);
>                break;
> -       }
> +       }
>        *src_p = src;
>        return;
>  }
> @@ -1583,7 +1583,7 @@ static int final_pseudo_flush(struct bb_state *state, pseudo_t pseudo, struct ha
>        struct hardreg *dst;
>
>        /*
> -        * Since this pseudo is live at exit, we'd better have output
> +        * Since this pseudo is live at exit, we'd better have output
>         * storage for it..
>         */
>        hash = find_storage_hash(pseudo, state->outputs);
> @@ -1829,8 +1829,8 @@ static void set_up_arch_entry(struct entrypoint *ep, struct instruction *entry)
>
>                        in->type = REG_FRAME;
>                        in->offset = offset;
> -
> -                       offset += bits >> 3;
> +
> +                       offset += bits / bits_in_char;
>                }
>                i++;
>                NEXT_PTR_LIST(argtype);
> @@ -1936,7 +1936,7 @@ static int compile(struct symbol_list *list)
>                if (ep)
>                        output(ep);
>        } END_FOR_EACH_PTR(sym);
> -
> +
>        return 0;
>  }
>
> diff --git a/expand.c b/expand.c
> index 032f0c5..d1aa019 100644
> --- a/expand.c
> +++ b/expand.c
> @@ -100,7 +100,7 @@ Int:
>        // Stop here unless checking for truncation
>        if (!Wcast_truncate || conservative)
>                return;
> -
> +
>        // Check if we dropped any bits..
>        oldsignmask = 1ULL << (old_size-1);
>        oldmask = oldsignmask | (oldsignmask-1);
> @@ -179,7 +179,7 @@ static int simplify_int_binop(struct expression *expr, struct symbol *ctype)
>                sl |= ~(mask-1);
>        if (is_signed && (sr & mask))
>                sr |= ~(mask-1);
> -
> +
>        switch (CONVERT(expr->op,is_signed)) {
>        case SIGNED('+'):
>        case UNSIGNED('+'):
> @@ -224,7 +224,7 @@ static int simplify_int_binop(struct expression *expr, struct symbol *ctype)
>
>        case UNSIGNED('/'):
>                if (!r) goto Div;
> -               v = l / r;
> +               v = l / r;
>                break;
>
>        case SIGNED('%'):
> @@ -241,7 +241,7 @@ static int simplify_int_binop(struct expression *expr, struct symbol *ctype)
>        case SIGNED(SPECIAL_LEFTSHIFT):
>        case UNSIGNED(SPECIAL_LEFTSHIFT):
>                v = l << r;
> -               break;
> +               break;
>
>        case SIGNED(SPECIAL_RIGHTSHIFT):
>                v = sl >> r;
> @@ -536,7 +536,7 @@ static int expand_conditional(struct expression *expr)
>
>        return cost + cond_cost + BRANCH_COST;
>  }
> -
> +
>  static int expand_assignment(struct expression *expr)
>  {
>        expand_expression(expr->left);
> @@ -822,7 +822,7 @@ static int expand_expression_list(struct expression_list *list)
>        return cost;
>  }
>
> -/*
> +/*
>  * We can simplify nested position expressions if
>  * this is a simple (single) positional expression.
>  */
> @@ -880,7 +880,7 @@ static unsigned long bit_offset(const struct expression *expr)
>  {
>        unsigned long offset = 0;
>        while (expr->type == EXPR_POS) {
> -               offset += expr->init_offset << 3;
> +               offset += expr->init_offset * bits_in_char;
>                expr = expr->init_expr;
>        }
>        if (expr && expr->ctype)
> diff --git a/flow.c b/flow.c
> index 82fb23a..bdb2c25 100644
> --- a/flow.c
> +++ b/flow.c
> @@ -16,6 +16,7 @@
>  #include "expression.h"
>  #include "linearize.h"
>  #include "flow.h"
> +#include "target.h"
>
>  unsigned long bb_generation;
>
> @@ -265,8 +266,8 @@ void convert_load_instruction(struct instruction *insn, pseudo_t src)
>
>  static int overlapping_memop(struct instruction *a, struct instruction *b)
>  {
> -       unsigned int a_start = a->offset << 3;
> -       unsigned int b_start = b->offset << 3;
> +       unsigned int a_start = a->offset * bits_in_char;
> +       unsigned int b_start = b->offset * bits_in_char;
>        unsigned int a_size = a->size;
>        unsigned int b_size = b->size;
>
> @@ -364,11 +365,11 @@ found_dominator:
>                use_pseudo(insn, phi, add_pseudo(dominators, phi));
>        } END_FOR_EACH_PTR(parent);
>        return 1;
> -}
> +}
>
>  /*
>  * We should probably sort the phi list just to make it easier to compare
> - * later for equality.
> + * later for equality.
>  */
>  void rewrite_load_instruction(struct instruction *insn, struct pseudo_list *dominators)
>  {
> @@ -529,7 +530,7 @@ static void kill_dead_stores(pseudo_t pseudo, unsigned long generation, struct b
>  * This should see if the "insn" trivially dominates some previous store, and kill the
>  * store if unnecessary.
>  */
> -static void kill_dominated_stores(pseudo_t pseudo, struct instruction *insn,
> +static void kill_dominated_stores(pseudo_t pseudo, struct instruction *insn,
>        unsigned long generation, struct basic_block *bb, int local, int found)
>  {
>        struct instruction *one;
> @@ -581,13 +582,14 @@ void check_access(struct instruction *insn)
>        pseudo_t pseudo = insn->src;
>
>        if (insn->bb && pseudo->type == PSEUDO_SYM) {
> -               int offset = insn->offset, bit = (offset << 3) + insn->size;
> +               int offset = insn->offset, bit = (offset * bits_in_char) + insn->size;
>                struct symbol *sym = pseudo->sym;
>
>                if (sym->bit_size > 0 && (offset < 0 || bit > sym->bit_size))
>                        warning(insn->pos, "invalid access %s '%s' (%d %d)",
>                                offset < 0 ? "below" : "past the end of",
> -                               show_ident(sym->ident), offset, sym->bit_size >> 3);
> +                               show_ident(sym->ident), offset,
> +                               sym->bit_size / bits_in_char);
>        }
>  }
>
> @@ -705,7 +707,7 @@ external_visibility:
>                        } END_FOR_EACH_PTR(bb);
>                }
>        }
> -
> +
>        return;
>  }
>
> @@ -887,7 +889,7 @@ static void vrfy_children(struct basic_block *bb)
>        default:
>                break;
>        }
> -
> +
>        FOR_EACH_PTR(bb->children, tmp) {
>                vrfy_bb_in_list(bb, tmp->parents);
>        } END_FOR_EACH_PTR(tmp);
> diff --git a/show-parse.c b/show-parse.c
> index 064af32..63d9144 100644
> --- a/show-parse.c
> +++ b/show-parse.c
> @@ -246,8 +246,8 @@ deeper:
>
>                s = modifier_string(mod);
>                len = strlen(s);
> -               name->start -= len;
> -               memcpy(name->start, s, len);
> +               name->start -= len;
> +               memcpy(name->start, s, len);
>                mod = 0;
>                as = 0;
>        }
> @@ -412,7 +412,7 @@ void show_symbol(struct symbol *sym)
>                struct statement *stmt = type->stmt;
>                if (stmt) {
>                        int val;
> -                       printf("\n");
> +                       printf("\n");
>                        val = show_statement(stmt);
>                        if (val)
>                                printf("\tmov.%d\t\tretval,%d\n", stmt->ret->bit_size, val);
> @@ -589,7 +589,7 @@ int show_statement(struct statement *stmt)
>                if (pre_condition) {
>                        if (pre_condition->type == EXPR_VALUE) {
>                                if (!pre_condition->value) {
> -                                       loop_bottom = new_label();
> +                                       loop_bottom = new_label();
>                                        printf("\tjmp\t\t.L%d\n", loop_bottom);
>                                }
>                        } else {
> @@ -623,7 +623,7 @@ int show_statement(struct statement *stmt)
>        }
>        case STMT_NONE:
>                break;
> -
> +
>        case STMT_LABEL:
>                printf(".L%p:\n", stmt->label_identifier);
>                show_statement(stmt->label_statement);
> @@ -649,9 +649,9 @@ int show_statement(struct statement *stmt)
>                int val = show_expression(stmt->range_expression);
>                int low = show_expression(stmt->range_low);
>                int high = show_expression(stmt->range_high);
> -               printf("\trange( %d %d-%d)\n", val, low, high);
> +               printf("\trange( %d %d-%d)\n", val, low, high);
>                break;
> -       }
> +       }
>        }
>        return 0;
>  }
> @@ -673,7 +673,7 @@ static int show_call_expression(struct expression *expr)
>                int new = show_expression(arg);
>                int size = arg->ctype->bit_size;
>                printf("\tpush.%d\t\tv%d\n", size, new);
> -               framesize += size >> 3;
> +               framesize += size / bits_in_char;
>        } END_FOR_EACH_PTR_REVERSE(arg);
>
>        fn = expr->fn;
> @@ -845,7 +845,7 @@ static int show_inc_dec(struct expression *expr, int postop)
>        printf("\t%s.%d\t\tv%d,v%d,$1\n", opname, bits, new, retval);
>        show_store_gen(bits, new, expr->unop, addr);
>        return retval;
> -}
> +}
>
>  static int show_preop(struct expression *expr)
>  {
> @@ -864,7 +864,7 @@ static int show_preop(struct expression *expr)
>  static int show_postop(struct expression *expr)
>  {
>        return show_inc_dec(expr, 1);
> -}
> +}
>
>  static int show_symbol_expr(struct symbol *sym)
>  {
> @@ -918,7 +918,7 @@ static int show_cast_expr(struct expression *expr)
>
>        old_type = expr->cast_expression->ctype;
>        new_type = expr->cast_type;
> -
> +
>        oldbits = old_type->bit_size;
>        newbits = new_type->bit_size;
>        if (oldbits >= newbits)
> @@ -1017,7 +1017,7 @@ again:
>                        entry = entry->ident_expression;
>                        goto again;
>                }
> -
> +
>                if (entry->type == EXPR_INDEX) {
>                        printf(" AT '%d..%d:\n", entry->idx_from, entry->idx_to);
>                        entry = entry->idx_expression;
> @@ -1057,11 +1057,11 @@ int show_expression(struct expression *expr)
>                        pos->line, pos->pos);
>                return 0;
>        }
> -
> +
>        switch (expr->type) {
>        case EXPR_CALL:
>                return show_call_expression(expr);
> -
> +
>        case EXPR_ASSIGNMENT:
>                return show_assignment(expr);
>
> diff --git a/symbol.c b/symbol.c
> index 3292907..a22731f 100644
> --- a/symbol.c
> +++ b/symbol.c
> @@ -22,7 +22,7 @@
>
>  /*
>  * Secondary symbol list for stuff that needs to be output because it
> - * was used.
> + * was used.
>  */
>  struct symbol_list *translation_unit_used_list = NULL;
>
> @@ -117,7 +117,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
>        }
>
>        bit_size = info->bit_size;
> -       base_size = sym->bit_size;
> +       base_size = sym->bit_size;
>
>        /*
>         * Unsized arrays cause us to not align the resulting
> @@ -128,7 +128,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
>                base_size = 0;
>        }
>
> -       align_bit_mask = (sym->ctype.alignment << 3) - 1;
> +       align_bit_mask = (sym->ctype.alignment * bits_in_char) - 1;
>
>        /*
>         * Bitfields have some very special rules..
> @@ -143,7 +143,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
>                        bit_size = (bit_size + align_bit_mask) & ~align_bit_mask;
>                        bit_offset = 0;
>                }
> -               sym->offset = (bit_size - bit_offset) >> 3;
> +               sym->offset = (bit_size - bit_offset) / bits_in_char;
>                sym->bit_offset = bit_offset;
>                sym->ctype.base_type->bit_offset = bit_offset;
>                info->bit_size = bit_size + width;
> @@ -156,7 +156,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
>         * Otherwise, just align it right and add it up..
>         */
>        bit_size = (bit_size + align_bit_mask) & ~align_bit_mask;
> -       sym->offset = bit_size >> 3;
> +       sym->offset = bit_size / bits_in_char;
>
>        info->bit_size = bit_size + base_size;
>        // warning (sym->pos, "regular: offset=%d", sym->offset);
> @@ -182,7 +182,7 @@ static struct symbol * examine_struct_union_type(struct symbol *sym, int advance
>                sym->ctype.alignment = info.max_align;
>        bit_size = info.bit_size;
>        if (info.align_size) {
> -               bit_align = (sym->ctype.alignment << 3)-1;
> +               bit_align = (sym->ctype.alignment * bits_in_char)-1;
>                bit_size = (bit_size + bit_align) & ~bit_align;
>        }
>        sym->bit_size = bit_size;
> @@ -340,7 +340,7 @@ static struct symbol * examine_node_type(struct symbol *sym)
>                if (node_type && node_type->bit_size >= 0)
>                        bit_size = node_type->bit_size * count;
>        }
> -
> +
>        sym->bit_size = bit_size;
>        return sym;
>  }
> @@ -654,7 +654,7 @@ static int expand_warning(struct expression *expr, int cost)
>        FOR_EACH_PTR (arglist, arg) {
>                /*
>                 * Constant strings get printed out as a warning. By the
> -                * time we get here, the EXPR_STRING has been fully
> +                * time we get here, the EXPR_STRING has been fully
>                 * evaluated, so by now it's an anonymous symbol with a
>                 * string initializer.
>                 *
> @@ -877,7 +877,7 @@ void init_ctype(void)
>                struct symbol *sym = ctype->ptr;
>                unsigned long bit_size = ctype->bit_size ? *ctype->bit_size : -1;
>                unsigned long maxalign = ctype->maxalign ? *ctype->maxalign : 0;
> -               unsigned long alignment = (bit_size + 7) >> 3;
> +               unsigned long alignment = (bit_size + bits_in_char - 1) / bits_in_char;
>
>                if (alignment > maxalign)
>                        alignment = maxalign;
> diff --git a/target.c b/target.c
> index bf1bb8f..a0ee010 100644
> --- a/target.c
> +++ b/target.c
> @@ -11,6 +11,8 @@ struct symbol *ssize_t_ctype = &int_ctype;
>  */
>  int max_alignment = 16;
>
> +int bits_in_unit = 8;
> +
>  /*
>  * Integer data types
>  */
> diff --git a/tokenize.c b/tokenize.c
> index e72c56e..67daa97 100644
> --- a/tokenize.c
> +++ b/tokenize.c
> @@ -96,7 +96,7 @@ static char *charstr(char *ptr, unsigned char c, unsigned char escape, unsigned
>        }
>        if (!isdigit(next))
>                return ptr + sprintf(ptr, "%o", c);
> -
> +
>        return ptr + sprintf(ptr, "%03o", c);
>  }
>
> @@ -161,7 +161,7 @@ const char *show_token(const struct token *token)
>        case TOKEN_STREAMEND:
>                sprintf(buffer, "<end of '%s'>", stream_name(token->pos.stream));
>                return buffer;
> -
> +
>        default:
>                return "WTF???";
>        }
> @@ -483,7 +483,7 @@ static int escapechar(int first, int type, stream_t *stream, int *valp)
>                                int nr = 2;
>                                value -= '0';
>                                while (next >= '0' && next <= '9') {
> -                                       value = (value << 3) + (next-'0');
> +                                       value = (value*8) + (next-'0');
>                                        next = nextchar(stream);
>                                        if (!--nr)
>                                                break;
> @@ -572,7 +572,7 @@ static int get_string_token(int next, stream_t *stream)
>        token_type(token) = TOKEN_STRING;
>        token->string = string;
>        add_token(stream);
> -
> +
>        return next;
>  }
>
> @@ -875,7 +875,7 @@ static int get_one_identifier(int c, stream_t *stream)
>        token->ident = ident;
>        add_token(stream);
>        return next;
> -}
> +}
>
>  static int get_one_token(int c, stream_t *stream)
>  {
>
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Sat, 28 Jun 2008 00:29:37 +0000
Message-ID: <1214612977.25532.14.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Sat, 2008-06-28 at 00:32 +0100, David Given wrote:
> diff --git a/compile-i386.c b/compile-i386.c
> index 8526408..3bbc9c7 100644
> --- a/compile-i386.c
> +++ b/compile-i386.c
> @@ -1584,7 +1584,7 @@ static struct storage *emit_select_expr(struct
> expression *expr)
>  	/*
>  	 * Do the actual select: check the conditional for zero,
>  	 * move false over true if zero
> -	 */ 
> +	 */

Don't include whitespace changes in unrelated patches.  You have many
whitespace changes in this patch; I haven't commented on all of them.

> @@ -2040,7 +2040,7 @@ static struct symbol *evaluate_sizeof(struct
> expression *expr)
>  	if ((size < 0) || (size & 7))
>  		expression_error(expr, "cannot size expression");

This "size & 7" represents an assumption about bits_in_char as well; it
checks if the size represents an integral number of chars.  You'll need
to look for other instances of 7 as well, to catch cases like this.

> @@ -2074,7 +2074,7 @@ static struct symbol *evaluate_ptrsizeof(struct
> expression *expr)
>  	if (size & 7)
>  		size = 0;

Same problem here.

>  	 * storage for it..
>  	 */
>  	hash = find_storage_hash(pseudo, state->outputs);
> @@ -1829,8 +1829,8 @@ static void set_up_arch_entry(struct entrypoint
> *ep, struct instruction *entry)
>  
>  			in->type = REG_FRAME;
>  			in->offset = offset;
> -			
> -			offset += bits >> 3;
> +
> +			offset += bits / bits_in_char;

ï»¿ï»¿ï»¿The first line represents a whitespace-only change.

> --- a/target.c
> +++ b/target.c
> @@ -11,6 +11,8 @@ struct symbol *ssize_t_ctype = &int_ctype;
>   */
>  int max_alignment = 16;
>  
> +int bits_in_unit = 8;
> +

Unused.

> @@ -483,7 +483,7 @@ static int escapechar(int first, int type,
> stream_t *stream, int *valp)
>  				int nr = 2;
>  				value -= '0';
>  				while (next >= '0' && next <= '9') {
> -					value = (value << 3) + (next-'0');
> +					value = (value*8) + (next-'0');

This does not relate to bits_per_char, and should not change.

- Josh Triplett


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Sun, 29 Jun 2008 00:13:19 +0000
Message-ID: <4866D39F.3050909 () numba-tu ! com>
--------------------
[Resent for the 3rd time. I seems I can't write to the list]

David Given wrote:
 > Christopher Li wrote:
 > [...]
 >   
 >> You are right that point out a bug (assumption) of sparse which byte 
is 8 bits.
 >> Using bits_in_byte is instead of 8 is better there.
 >> Using bits_in_char assumes char has same bits as byte. That is my read
 >> of the C spec.
 >>     
 >
 > Yes, indeed, I'd managed to get my terminology muddled to the confusion
 > of everyone.
 >
 > Okay, I've gone and looked at the implementation of this stuff; it would
 > appear that modifying the code to supply the back end with units scaled
 > in something other than C chars is actually quite complicated, so I
 > haven't tried to do that. However, I'm enclosing a patch that should,
 > hopefully, fix the cases where it's assuming 8 bit bytes. Hopefully I've
 >  managed to catch all the cases, without breaking the octal parse code...
 >
 > (I haven't used git before; is this the right format?)
 >   

Yes, but it would have been better to have kept all the white space
changes for a separate change so we could just see that relevant changes.

This introduces divides all over the place for all users, replacing a
very cheap constant shift with an expensive divide. All sparse users
would be paying the cost for a feature that is useful for 1 user, I
think we should perhaps think carefully about this.

One obvious solution would be to introduce a BITS_IN_CHAR macro in
target.h defaulting to 8 and let "exotic" architectures redefine it to
bits_in_char. This is very similar to the approach GCC is using.



On a completely unrelated node, I'm excited to see your work on using
sparse for compilation. Hopefully your experience will lead to it being
easier for the next guy. I would like to see sparse target for a simple
abstract machine, but I so far haven't had time to work on it.

Tommy


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Sun, 29 Jun 2008 00:30:18 +0000
Message-ID: <4866D79A.4000402 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigC919F0488A2E2F36A40F3475
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Tommy Thorn wrote:
[...]
> Yes, but it would have been better to have kept all the white space
> changes for a separate change so we could just see that relevant change=
s.

Corrected; turned out it had been so long since I've used a diff that
didn't use my alias I'd forgotten you have to explicitly tell it to
ignore white space.

> This introduces divides all over the place for all users, replacing a
> very cheap constant shift with an expensive divide. All sparse users
> would be paying the cost for a feature that is useful for 1 user, I
> think we should perhaps think carefully about this.

I really don't think this is an issue. Certainly, a division by a
variable is more expensive than a shift by a constant... but you'd have
to do billions of them before anyone actually started to notice. If it
really did turn out to be an issue, it would be simple enough to change
later to "value >> bits_in_char_power_of_2".

> One obvious solution would be to introduce a BITS_IN_CHAR macro in
> target.h defaulting to 8 and let "exotic" architectures redefine it to
> bits_in_char. This is very similar to the approach GCC is using.

The problem with this approach is that it involves recompiling all of
sparse for each target, which is a bit user unfriendly. Currently all
configuration can be done at run time, which allows such nice features
as having all potential back-ends share the same code via shared librarie=
s.

> On a completely unrelated node, I'm excited to see your work on using
> sparse for compilation. Hopefully your experience will lead to it being=

> easier for the next guy. I would like to see sparse target for a simple=

> abstract machine, but I so far haven't had time to work on it.

sparse is working rather well, and seems to be one of the better
compiler front ends that I've found. The linearising support is
particularly helpful. I have, however, been finding that the learning
curve is rather steep --- the API shows a lot of signs of having grown
organically over time --- and I've had to build big chunks of code that
I'm sure are unnecessary. For example, in order to generate the right
kind of code, I need to figure out whether a pseudo contains an integer,
float or pointer. The only way I've found out to do this is to
recursively follow the chain of pseudo->def pointers until I find an
instruction with enough type information attached to it to figure it
out. I'm sure there must be an easier way of doing this...

(BTW, given a function symbol, how do I find its return type? I can find
the list of arguments, but there's nothing in struct symbol that seems
to refer to the return value...)

I am intending to release my project once done, of course, and I hope
people will find it useful, but I'm not sure how much general use it
will be; I've basically ripped out and replaced the register allocator /
storage mechanism from my back end as I didn't understand it and didn't
need the complexity. That should probably all get rewritten properly at
some stage, but right now I'm focusing on getting things working...

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82 "I have always wished for my computer to be as easy to use as m=
y
=E2=94=82 telephone; my wish has come true because I can no longer figure=
 out
=E2=94=82 how to use my telephone." --- Bjarne Stroustrup


--------------enigC919F0488A2E2F36A40F3475
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIZteaf9E0noFvlzgRAuIyAJ4gy7bY+x7Ltk1ppAlXTvNTaNYUOQCgtzlu
IxuSBRaCao39GdUKHwDvFb0=
=RKo7
-----END PGP SIGNATURE-----

--------------enigC919F0488A2E2F36A40F3475--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Sun, 29 Jun 2008 00:38:36 +0000
Message-ID: <4866D98C.3070604 () numba-tu ! com>
--------------------
David Given wrote:
> sparse is working rather well, and seems to be one of the better
> compiler front ends that I've found. The linearising support is
> particularly helpful. I have, however, been finding that the learning
> curve is rather steep --- the API shows a lot of signs of having grown
> organically over time --- and I've had to build big chunks of code that
> I'm sure are unnecessary. For example, in order to generate the right
> kind of code, I need to figure out whether a pseudo contains an integer,
> float or pointer. The only way I've found out to do this is to
> recursively follow the chain of pseudo->def pointers until I find an
> instruction with enough type information attached to it to figure it
> out. I'm sure there must be an easier way of doing this...
>
> (BTW, given a function symbol, how do I find its return type? I can find
> the list of arguments, but there's nothing in struct symbol that seems
> to refer to the return value...)
>
> I am intending to release my project once done, of course, and I hope
> people will find it useful, but I'm not sure how much general use it
> will be; I've basically ripped out and replaced the register allocator /
> storage mechanism from my back end as I didn't understand it and didn't
> need the complexity. That should probably all get rewritten properly at
> some stage, but right now I'm focusing on getting things working...
>   

What I had in mind would not even perform register allocation or any 
attempt at optimization. Such only obscures how to use sparse as a compiler.

Cheers,
Tommy

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () firmix ! at>
To: linux-sparse
Subject: Re: Pointer arithmetic error
Date: Sun, 29 Jun 2008 12:19:47 +0000
Message-ID: <1214741987.4216.15.camel () gimli ! at ! home>
--------------------
On Fre, 2008-06-27 at 11:01 -0700, Christopher Li wrote: 
> > In C, there is no type "byte" (unless you typedef oder #define it).
> > "byte" is usually (but not necessarily) meant as "unsigned char".
> 
> In C spec, there is a concept of "byte". The union return by sizeof()

I stand corrected. Hmm, I need the time to read C99 thoroughly.

> is byte. Char must fit in a byte. But char does not necessary have the
> same bits as byte. Char can have more.
> 
> C99: 3.6, 3.7.1
>
> Because char can always fit in byte, sizeof(char) == 1.

But how can a char have more bits than a byte?

> > IIRC C specifies that sizeof() returns values measured in chars, but
> > I don't believe it specifies any mapping between the size of chars
> > and the underlying addressing units --- it should be possible to use
> > 16-bit chars, for example, on an 8-bit byte system. > Using 32-bit
> > ints, sizeof(int) would then return 2; but you wouldn't be able to
> > access individual bytes from C.
> 
> sizeof() return value measure in _byte_.
> C99: 6.5.3.4

Yes. But "sizeof(char)" is always 1 (as stated in the same chapter). 
So I see no real difference between "byte" and "char" (at least with the
size of them).

	Bernd
-- 
Firmix Software GmbH                   http://www.firmix.at/
mobil: +43 664 4416156                 fax: +43 1 7890849-55
          Embedded Linux Development and Services

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse annotation for "context imbalance" false positives? ===

From: Roland Dreier <rdreier () cisco ! com>
To: linux-sparse
Subject: Sparse annotation for "context imbalance" false positives?
Date: Thu, 15 May 2008 03:16:39 +0000
Message-ID: <adaod78fe94.fsf () cisco ! com>
--------------------
Now that I've gotten the sparse noise in drivers/infiniband down to a
fairly low level, I'm starting to look at some of the more recalcitrant
false positive warnings.  One example is:

    drivers/infiniband/hw/mlx4/qp.c:605:2: warning: context imbalance in 'mlx4_ib_lock_cqs' - wrong count at exit

where the function being warned about is:

	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)
	{
		if (send_cq == recv_cq)
			spin_lock_irq(&send_cq->lock);
		else if (send_cq->mcq.cqn < recv_cq->mcq.cqn) {
			spin_lock_irq(&send_cq->lock);
			spin_lock_nested(&recv_cq->lock, SINGLE_DEPTH_NESTING);
		} else {
			spin_lock_irq(&recv_cq->lock);
			spin_lock_nested(&send_cq->lock, SINGLE_DEPTH_NESTING);
		}
	}

this function wraps up the locking rules for aquiring the completion
queue (CQ) locks associated with a queue pair (QP) -- the rule is that
if both the send and receive CQs are the same object, we (obviously)
only lock it once, otherwise we take the lock belonging to the CQ with a
numerically lower ID first (to avoid AB-BA deadlocks).

So obviously is it correct and intended that this function return
holding one or two locks, but I don't know how to tell sparse that.
I've tried messing around with __acquires() etc but it doesn't seem to
be exactly what I want.

Is there any way to tell sparse what's going on here, or do I just live
with the warnings?

Thanks,
  Roland
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Re: Sparse annotation for "context imbalance" false positives?
Date: Thu, 15 May 2008 08:54:23 +0000
Message-ID: <1210841663.4282.9.camel () johannes ! berg>
--------------------

--=-XHPX6qtXCJCj2Aog5uOA
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

You could, for example, insert this:

> 	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_=
cq *recv_cq)
> 	{
> 		if (send_cq =3D=3D recv_cq)
		{
> 			spin_lock_irq(&send_cq->lock);
			 /* pretend to have acquired both for sparse */=09
			__acquire(&recv_cq->lock);
		}
> 		else if (send_cq->mcq.cqn < recv_cq->mcq.cqn) {
> 			spin_lock_irq(&send_cq->lock);
> 			spin_lock_nested(&recv_cq->lock, SINGLE_DEPTH_NESTING);
> 		} else {
> 			spin_lock_irq(&recv_cq->lock);
> 			spin_lock_nested(&send_cq->lock, SINGLE_DEPTH_NESTING);
> 		}
> 	}

and then declare that you take "both" locks. Not sure if that will bite
you in the callers again though.

The exact syntax is still a bit under discussion though, whether to use
&recv_cq->lock or leave out the "&" there, I'm favouring the approach
with & but the kernel uses no & in some places.

johannes

--=-XHPX6qtXCJCj2Aog5uOA
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASCv6PqVg1VMiehFYAQIc0RAAmxfNytGFfQn0Uua2XpahBdoppI71mNUY
7b25Cyq7aYpNGF3YSIWUhMHXFiz58XUvTZEzbb1a7CMP3e0nurmaY3SwATaDgUhD
tl84WNryZeKdLIqoDlIZVXD7rLD04rQ+aDmKoBVFAMBCV8e/FNJ9n+h14LNBr0O2
SKX9t+VmK5dc7TbfHHfeNZuyholdb1IVcAOCl7XdfmOPZ55Gz6ULilKPRRynvqUm
AZct0AK+eOJytTKezDZKm7jbL82EeO6Uq/y+JVbZpWYSgK4tDc6CluvpGWssWDBZ
DNNFDTl7YVVcazazRQ1cElrNJN0QmOvPk+t67MYAAvuq83jxvlhhS3MTrGfkvC3i
gIpatqQsv7JETn/M+wdu9NW1Tsiavy7/MJl+WEqjJTCeuynPxuNxM2RjGLwnmO8D
KTiK88VxuvQbK+knMtsGUzjq/ezpeZCgU0m0WCsHoKQ8krm3lv8tJRdz+vFuzMBw
wcBSoLmH+nmBc7EZHl7MZLuFPM0LaRINAIYwKIItZhl3qfOHLUZH9roXX9VRY1UF
eWYTATOwwTBeIKf+5v7wdSetQF+o5uCWW2pC3QFBfdlb1NVsq4cZ4a8NEkpN9PSN
ZaGif9YmGx8H2q2MljaLvmKnV1SQg8WtYYHzp6PbsMNkK4jC8fqpVsRznTWCPXOB
6sFtXUh5xtg=
=bgZU
-----END PGP SIGNATURE-----

--=-XHPX6qtXCJCj2Aog5uOA--

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Sparse annotation for "context imbalance" false positives?
Date: Thu, 15 May 2008 08:54:23 +0000
Message-ID: <1210841663.4282.9.camel () johannes ! berg>
--------------------

--=-XHPX6qtXCJCj2Aog5uOA
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

You could, for example, insert this:

> 	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_=
cq *recv_cq)
> 	{
> 		if (send_cq =3D=3D recv_cq)
		{
> 			spin_lock_irq(&send_cq->lock);
			 /* pretend to have acquired both for sparse */=09
			__acquire(&recv_cq->lock);
		}
> 		else if (send_cq->mcq.cqn < recv_cq->mcq.cqn) {
> 			spin_lock_irq(&send_cq->lock);
> 			spin_lock_nested(&recv_cq->lock, SINGLE_DEPTH_NESTING);
> 		} else {
> 			spin_lock_irq(&recv_cq->lock);
> 			spin_lock_nested(&send_cq->lock, SINGLE_DEPTH_NESTING);
> 		}
> 	}

and then declare that you take "both" locks. Not sure if that will bite
you in the callers again though.

The exact syntax is still a bit under discussion though, whether to use
&recv_cq->lock or leave out the "&" there, I'm favouring the approach
with & but the kernel uses no & in some places.

johannes

--=-XHPX6qtXCJCj2Aog5uOA
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASCv6PqVg1VMiehFYAQIc0RAAmxfNytGFfQn0Uua2XpahBdoppI71mNUY
7b25Cyq7aYpNGF3YSIWUhMHXFiz58XUvTZEzbb1a7CMP3e0nurmaY3SwATaDgUhD
tl84WNryZeKdLIqoDlIZVXD7rLD04rQ+aDmKoBVFAMBCV8e/FNJ9n+h14LNBr0O2
SKX9t+VmK5dc7TbfHHfeNZuyholdb1IVcAOCl7XdfmOPZ55Gz6ULilKPRRynvqUm
AZct0AK+eOJytTKezDZKm7jbL82EeO6Uq/y+JVbZpWYSgK4tDc6CluvpGWssWDBZ
DNNFDTl7YVVcazazRQ1cElrNJN0QmOvPk+t67MYAAvuq83jxvlhhS3MTrGfkvC3i
gIpatqQsv7JETn/M+wdu9NW1Tsiavy7/MJl+WEqjJTCeuynPxuNxM2RjGLwnmO8D
KTiK88VxuvQbK+knMtsGUzjq/ezpeZCgU0m0WCsHoKQ8krm3lv8tJRdz+vFuzMBw
wcBSoLmH+nmBc7EZHl7MZLuFPM0LaRINAIYwKIItZhl3qfOHLUZH9roXX9VRY1UF
eWYTATOwwTBeIKf+5v7wdSetQF+o5uCWW2pC3QFBfdlb1NVsq4cZ4a8NEkpN9PSN
ZaGif9YmGx8H2q2MljaLvmKnV1SQg8WtYYHzp6PbsMNkK4jC8fqpVsRznTWCPXOB
6sFtXUh5xtg=
=bgZU
-----END PGP SIGNATURE-----

--=-XHPX6qtXCJCj2Aog5uOA--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Roland Dreier <rdreier () cisco ! com>
To: linux-kernel
Subject: Re: Sparse annotation for "context imbalance" false positives?
Date: Thu, 15 May 2008 15:05:23 +0000
Message-ID: <ada7idvfw0c.fsf () cisco ! com>
--------------------
 > You could, for example, insert this:
 > 
 > > 	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)
 > > 	{
 > > 		if (send_cq == recv_cq)
 > 		{
 > > 			spin_lock_irq(&send_cq->lock);
 > 			 /* pretend to have acquired both for sparse */	
 > 			__acquire(&recv_cq->lock);
 > 		}

but the problem sparse sees is not that some paths take only one lock
and some take two -- sparse is complaining that this function is
returning without unlocking the locks that it takes.  Even if I change
the function to something as simple as:

	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)
	{
		spin_lock_irq(&recv_cq->lock);
	}

I still get

    drivers/infiniband/hw/mlx4/qp.c:603:13: warning: context imbalance in 'mlx4_ib_lock_cqs' - wrong count at exitn

thanks,
  Roland
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Roland Dreier <rdreier () cisco ! com>
To: linux-sparse
Subject: Re: Sparse annotation for "context imbalance" false positives?
Date: Thu, 15 May 2008 15:05:23 +0000
Message-ID: <ada7idvfw0c.fsf () cisco ! com>
--------------------
 > You could, for example, insert this:
 > 
 > > 	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)
 > > 	{
 > > 		if (send_cq == recv_cq)
 > 		{
 > > 			spin_lock_irq(&send_cq->lock);
 > 			 /* pretend to have acquired both for sparse */	
 > 			__acquire(&recv_cq->lock);
 > 		}

but the problem sparse sees is not that some paths take only one lock
and some take two -- sparse is complaining that this function is
returning without unlocking the locks that it takes.  Even if I change
the function to something as simple as:

	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)
	{
		spin_lock_irq(&recv_cq->lock);
	}

I still get

    drivers/infiniband/hw/mlx4/qp.c:603:13: warning: context imbalance in 'mlx4_ib_lock_cqs' - wrong count at exitn

thanks,
  Roland
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Sparse annotation for "context imbalance" false positives?
Date: Thu, 15 May 2008 15:20:02 +0000
Message-ID: <1210864802.3900.8.camel () johannes ! berg>
--------------------

--=-PVlW/DD8BTDL2ypw2Hru
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable


> but the problem sparse sees is not that some paths take only one lock
> and some take two -- sparse is complaining that this function is
> returning without unlocking the locks that it takes.  Even if I change
> the function to something as simple as:
>=20
> 	static void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_=
cq *recv_cq)
> 	{
> 		spin_lock_irq(&recv_cq->lock);
> 	}
>=20
> I still get
>=20
>     drivers/infiniband/hw/mlx4/qp.c:603:13: warning: context imbalance in=
 'mlx4_ib_lock_cqs' - wrong count at exitn

Oh. Well yes, you also have to annotate the function:

static void =EF=BB=BFmlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct ml=
x4_ib_cq *recv_cq)
	__acquires(&recv_cq->lock) __acquires(&send_cq->lock)
{
	...
}

but we're still discussing whether the & should be in there or not. I'd
think right now is a bad time for you to be working on this unless you
want to help with how sparse should behave too.

johannes

--=-PVlW/DD8BTDL2ypw2Hru
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASCxUoaVg1VMiehFYAQLXwg/+LiE4kk01kIQX9Hn05sT6ZEIjm2ADpZVM
ngeN50RkeIwRvj87T79MuCJvdTJkRlQp8Be+FujKO4+7DGPjtaRUx8/bgmWSD36t
Jp/H0S7v3xLgQRj6WH6ke9Xpw5J+ow3a/soT+bV8TdUqqInHlw0TzZiDlITLR4do
X+MC2+3xN4YM652aH/a79tatxc2UIesKkf303DINKLXv6xATo4pQkGsHcQhLTulC
tI8dFTjMpOA+T9Hn1ZH59Zi/M0aJml/73XHi2HEkmPJqU2SzNXgmYZABRgpyJvWv
F5VLvNRG1t+ydUl6LY0mBjgn6EX2W1X/AE22u6FLf6emL1Gkz8Blpu7z7CWp6zXr
CwX59v59oz5YRJMqmfywmqp0rH9ahdiz/gIDDBeFmBMwOnBvIVJtITKHDmQZWZQt
7ubjsDrcKSTQ8nqh4LuJ6+9zmUpaoznuxWJHysQiU6Viz0lCWEZ9NJ0iIfBWwm9f
sVQR/EGm3EZVUdqr38A0iZyQQgwFuVvCpHrb0xteIwWtaOtZF1KlrDrJ+1Q/g5T/
Nqi+j8WbAk6K40f/g//Vh6vZ0w5DgCDsA1dLZkB2UVX1NpZ76UBSx/aZqgse3iCA
Vwit35yvdeCvLuUf1/kdsnuZUoTrunpbQesUN+WmukuNnSOKFfeaM139bMmnBRG1
oElfChxZedQ=
=FdzP
-----END PGP SIGNATURE-----

--=-PVlW/DD8BTDL2ypw2Hru--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse tool ===

From: "Krishna Gopal" <linuxkrishna () gmail ! com>
To: linux-arm-kernel
Subject: Sparse tool
Date: Fri, 11 Jul 2008 19:59:46 +0000
Message-ID: <68f510a70807111259l5d15f385pec54c099d3960423 () mail ! gmail ! com>
--------------------
Hi,

    I am running the sparse tool on my code and I see following error

error: too many arguments for function <noident>

Do any one know the reason behind this error ?

Thank you,
Best regards,
Krishna

-------------------------------------------------------------------
List admin: http://lists.arm.linux.org.uk/mailman/listinfo/linux-arm-kernel
FAQ:        http://www.arm.linux.org.uk/mailinglists/faq.php
Etiquette:  http://www.arm.linux.org.uk/mailinglists/etiquette.php
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-arm-kernel
Subject: Re: Sparse tool
Date: Fri, 11 Jul 2008 20:08:29 +0000
Message-ID: <20080711200829.GA26676 () uranus ! ravnborg ! org>
--------------------
On Fri, Jul 11, 2008 at 02:59:46PM -0500, Krishna Gopal wrote:
> Hi,
> 
>     I am running the sparse tool on my code and I see following error
> 
> error: too many arguments for function <noident>
> 
> Do any one know the reason behind this error ?

sparce mailing list added.

> 
> Thank you,
> Best regards,
> Krishna

	Sam

-------------------------------------------------------------------
List admin: http://lists.arm.linux.org.uk/mailman/listinfo/linux-arm-kernel
FAQ:        http://www.arm.linux.org.uk/mailinglists/faq.php
Etiquette:  http://www.arm.linux.org.uk/mailinglists/etiquette.php
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Sparse tool
Date: Fri, 11 Jul 2008 20:11:40 +0000
Message-ID: <20080711201140.GA26723 () uranus ! ravnborg ! org>
--------------------
On Fri, Jul 11, 2008 at 10:08:29PM +0200, Sam Ravnborg wrote:
> On Fri, Jul 11, 2008 at 02:59:46PM -0500, Krishna Gopal wrote:
> > Hi,
> > 
> >     I am running the sparse tool on my code and I see following error
> > 
> > error: too many arguments for function <noident>
> > 
> > Do any one know the reason behind this error ?
> 
> sparce mailing list added.
This time with the correct address.

> 
> > 
> > Thank you,
> > Best regards,
> > Krishna
> 
	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Sparse tool
Date: Thu, 17 Jul 2008 21:58:48 +0000
Message-ID: <1216331928.4870.7.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2008-07-11 at 22:11 +0200, Sam Ravnborg wrote:
> On Fri, Jul 11, 2008 at 10:08:29PM +0200, Sam Ravnborg wrote:
> > On Fri, Jul 11, 2008 at 02:59:46PM -0500, Krishna Gopal wrote:
> > > Hi,
> > > 
> > >     I am running the sparse tool on my code and I see following error
> > > 
> > > error: too many arguments for function <noident>
> > > 
> > > Do any one know the reason behind this error ?
> > 
> > sparce mailing list added.
> This time with the correct address.

Can you please provide the code you used to trigger this error?  Or even
better, can you provide a test case which reproduces the error?

- Josh Triplett


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Erik Mouw <mouw () nl ! linux ! org>
To: linux-arm-kernel
Subject: Re: Sparse tool
Date: Sun, 20 Jul 2008 14:27:28 +0000
Message-ID: <20080720142727.GA4468 () arthur ! home>
--------------------

--===============0949291657==
Content-Type: multipart/signed; micalg=pgp-sha1;
	protocol="application/pgp-signature"; boundary="Q68bSM7Ycu6FN28Q"
Content-Disposition: inline


--Q68bSM7Ycu6FN28Q
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Fri, Jul 11, 2008 at 10:11:40PM +0200, Sam Ravnborg wrote:
> On Fri, Jul 11, 2008 at 10:08:29PM +0200, Sam Ravnborg wrote:
> > On Fri, Jul 11, 2008 at 02:59:46PM -0500, Krishna Gopal wrote:
> > > Hi,
> > >=20
> > >     I am running the sparse tool on my code and I see following error
> > >=20
> > > error: too many arguments for function <noident>
> > >=20
> > > Do any one know the reason behind this error ?
> >=20
> > sparce mailing list added.
> This time with the correct address.

Please don't do that, linux-arm-kernel is a subscriber-only mailing
list. Mailman will reject messages from people not subscribed to the
linux-arm-kernel mailing list (i.e.: most subscribers to linux-sparse)
anyway. It's better to point the OP to the linux-sparse mailing list.


Erik
[linux-arm-kernel-owner #2]

--=20
Erik Mouw -- mouw@nl.linux.org

--Q68bSM7Ycu6FN28Q
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: Digital signature
Content-Disposition: inline

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFIg0tP/PlVHJtIto0RAhm7AJ9LlHSpdK4nSs1t1IkcjNjptiLtAACfVj6U
xOrWUc9NQay7SZGHQpbmJWA=
=LZGK
-----END PGP SIGNATURE-----

--Q68bSM7Ycu6FN28Q--


--===============0949291657==
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

-------------------------------------------------------------------
List admin: http://lists.arm.linux.org.uk/mailman/listinfo/linux-arm-kernel
FAQ:        http://www.arm.linux.org.uk/mailinglists/faq.php
Etiquette:  http://www.arm.linux.org.uk/mailinglists/etiquette.php
--===============0949291657==--

================================================================================

From: Erik Mouw <mouw () nl ! linux ! org>
To: linux-sparse
Subject: Re: Sparse tool
Date: Sun, 20 Jul 2008 14:27:28 +0000
Message-ID: <20080720142727.GA4468 () arthur ! home>
--------------------

--Q68bSM7Ycu6FN28Q
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Fri, Jul 11, 2008 at 10:11:40PM +0200, Sam Ravnborg wrote:
> On Fri, Jul 11, 2008 at 10:08:29PM +0200, Sam Ravnborg wrote:
> > On Fri, Jul 11, 2008 at 02:59:46PM -0500, Krishna Gopal wrote:
> > > Hi,
> > >=20
> > >     I am running the sparse tool on my code and I see following error
> > >=20
> > > error: too many arguments for function <noident>
> > >=20
> > > Do any one know the reason behind this error ?
> >=20
> > sparce mailing list added.
> This time with the correct address.

Please don't do that, linux-arm-kernel is a subscriber-only mailing
list. Mailman will reject messages from people not subscribed to the
linux-arm-kernel mailing list (i.e.: most subscribers to linux-sparse)
anyway. It's better to point the OP to the linux-sparse mailing list.


Erik
[linux-arm-kernel-owner #2]

--=20
Erik Mouw -- mouw@nl.linux.org

--Q68bSM7Ycu6FN28Q
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: Digital signature
Content-Disposition: inline

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFIg0tP/PlVHJtIto0RAhm7AJ9LlHSpdK4nSs1t1IkcjNjptiLtAACfVj6U
xOrWUc9NQay7SZGHQpbmJWA=
=LZGK
-----END PGP SIGNATURE-----

--Q68bSM7Ycu6FN28Q--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: The __cold__ attribute again ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: The __cold__ attribute again
Date: Fri, 27 Jun 2008 16:00:59 +0000
Message-ID: <1214582459.6045.4.camel () dv>
--------------------
Hello!

It would be nice to have a new release with the __cold__ attribute
support in time for Linux 2.6.26 release, which uses __cold__ in some
important headers, including linux/kernel.h.  Otherwise, sparse will be
useless with the new kernel.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: The __cold__ attribute again
Date: Fri, 27 Jun 2008 17:40:53 +0000
Message-ID: <1214588453.5189.0.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Fri, 2008-06-27 at 12:00 -0400, Pavel Roskin wrote:
> It would be nice to have a new release with the __cold__ attribute
> support in time for Linux 2.6.26 release, which uses __cold__ in some
> important headers, including linux/kernel.h.  Otherwise, sparse will be
> useless with the new kernel.

Will do.  Thanks for the heads-up.

- Josh Triplett


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Undetected error cases ===

From: "Vegard Nossum" <vegard.nossum () gmail ! com>
To: linux-sparse
Subject: Undetected error cases
Date: Sun, 01 Jun 2008 18:42:54 +0000
Message-ID: <19f34abd0806011142x7e56fd8gf51358bf606ede91 () mail ! gmail ! com>
--------------------
Hi,

I was playing with sparse to see what it would accept, and I was
actually surprised at how many "obviously wrong" constructs it
accepted. Because sparse is supposed to warn about this, isn't it? Or
is there a policy not to warn about things that gcc already rejects?
If that were the case, I believe it would reduce the overall
usefulness of sparse.

(I say "obviously wrong" because I don't see how they can be valid,
but I might of course be mistaken :-))

Anyway, here are my test cases:

==> const-void.c <==
/* "const void" has no meaning. */
const void f(void);

==> extern-parameter.c <==
/* "extern" in parameter declaration has no meaning. */
void f(extern int x);

==> inline-parameter.c <==
/* "inline" in parameter declaration has no meaning. */
void f(inline int x);

==> inline-typedef.c <==
/* "inline" is in front of "typedef". Is this equivalent to
 * "typedef inline int t"? Even so, it doesn't make sense to make variables
 * inline. */
inline typedef t;

==> inline-variable.c <==
/* "inline" for variables has no meaning. */
static inline int x = 0;

==> typedef-collision.c <==
/* Two types with the same name. The second one is used, but should it
 * be allowed? */
typedef char t;
typedef int t;

static t my_t = 0;

==> typedef-parameter.c <==
/* "typedef" in parameter declaration has no meaning. */
void f(typedef x);


None of these produce errors or even warnings when they are run
through sparse. I probably won't get around to fixing these myself
since I'm not that familiar with sparse internals. This is just a
heads up :-)


Vegard

-- 
"The animistic metaphor of the bug that maliciously sneaked in while
the programmer was not looking is intellectually dishonest as it
disguises that the error is the programmer's own creation."
	-- E. W. Dijkstra, EWD1036
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Undetected error cases
Date: Sun, 01 Jun 2008 18:58:25 +0000
Message-ID: <1212346705.2727.6.camel () dv>
--------------------
On Sun, 2008-06-01 at 20:42 +0200, Vegard Nossum wrote:

> None of these produce errors or even warnings when they are run
> through sparse. I probably won't get around to fixing these myself
> since I'm not that familiar with sparse internals. This is just a
> heads up :-)

Still, you may be able to create test cases for the testsuite.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Vegard Nossum" <vegard.nossum () gmail ! com>
To: linux-sparse
Subject: Re: Undetected error cases
Date: Sun, 01 Jun 2008 19:46:28 +0000
Message-ID: <19f34abd0806011246nd615793o7e09ceae8dee73e6 () mail ! gmail ! com>
--------------------
On Sun, Jun 1, 2008 at 8:58 PM, Pavel Roskin <proski@gnu.org> wrote:
> On Sun, 2008-06-01 at 20:42 +0200, Vegard Nossum wrote:
>
>> None of these produce errors or even warnings when they are run
>> through sparse. I probably won't get around to fixing these myself
>> since I'm not that familiar with sparse internals. This is just a
>> heads up :-)
>
> Still, you may be able to create test cases for the testsuite.

Ah, that's be true. I have now submitted the .c files that should
produce the errors/warnings, but I can't seem to find an actual
testsuite in which to hook them. The existing test-* files seem to
test the API, not the files to be parsed.

Vegard

-- 
"The animistic metaphor of the bug that maliciously sneaked in while
the programmer was not looking is intellectually dishonest as it
disguises that the error is the programmer's own creation."
	-- E. W. Dijkstra, EWD1036
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Undetected error cases
Date: Sun, 01 Jun 2008 20:10:56 +0000
Message-ID: <1212351056.2727.7.camel () dv>
--------------------
On Sun, 2008-06-01 at 21:46 +0200, Vegard Nossum wrote:

> Ah, that's be true. I have now submitted the .c files that should
> produce the errors/warnings, but I can't seem to find an actual
> testsuite in which to hook them. The existing test-* files seem to
> test the API, not the files to be parsed.

It's under "validation".

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Unused arg_count field ===

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Unused arg_count field
Date: Sat, 06 Sep 2008 16:01:50 +0000
Message-ID: <48C2A96E.5020802 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig8DB91045EDD561471FBE6293
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I notice that struct symbol::arg_count doesn't appear to be used,
anywhere. Is this obsolete?

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82
=E2=94=82 "All power corrupts, but we need electricity." --- Diana Wynne =
Jones,
=E2=94=82 _Archer's Goon_


--------------enig8DB91045EDD561471FBE6293
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIwqluf9E0noFvlzgRAlXdAJ9KNbh0W8B1Bk6qrgLz08qivQnQmgCgiQp3
GNjmVE4YFvDT08DADo5/O8s=
=tUoI
-----END PGP SIGNATURE-----

--------------enig8DB91045EDD561471FBE6293--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Updated byte size patch ===

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Updated byte size patch
Date: Sun, 06 Jul 2008 01:03:27 +0000
Message-ID: <487019DF.10907 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig6DD22DB3B7FE553CA7FF5CA1
Content-Type: multipart/mixed;
 boundary="------------010609080402000901090104"

This is a multi-part message in MIME format.
--------------010609080402000901090104
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Turns out that I'd missed one place where there was a hardcoded 8 in the
last patch, so here's an updated version.

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82 "I have always wished for my computer to be as easy to use as m=
y
=E2=94=82 telephone; my wish has come true because I can no longer figure=
 out
=E2=94=82 how to use my telephone." --- Bjarne Stroustrup

--------------010609080402000901090104
Content-Type: text/plain;
 name="byte.diff"
Content-Transfer-Encoding: base64
Content-Disposition: inline;
 filename="byte.diff"

ZGlmZiAtdXJ3IC4uL3NwYXJzZS5vcmlnL2NvbXBpbGUtaTM4Ni5jIC4vY29tcGlsZS1pMzg2
LmMKLS0tIC4uL3NwYXJzZS5vcmlnL2NvbXBpbGUtaTM4Ni5jCTIwMDgtMDYtMjggMjI6NDQ6
MjEuNzA2NTU0OTk4ICswMTAwCisrKyAuL2NvbXBpbGUtaTM4Ni5jCTIwMDgtMDYtMjggMjM6
NDU6MjEuMjQ2NTU0NjI3ICswMTAwCkBAIC0yMDgxLDcgKzIwODEsNyBAQAogCQlpbnNuKCJw
dXNobCIsIG5ldywgTlVMTCwKIAkJICAgICAhZnJhbWVzaXplID8gImJlZ2luIGZ1bmN0aW9u
IGNhbGwiIDogTlVMTCk7CiAKLQkJZnJhbWVzaXplICs9IHNpemUgPj4gMzsKKwkJZnJhbWVz
aXplICs9IGJpdHNfdG9fYnl0ZXMoc2l6ZSk7CiAJfSBFTkRfRk9SX0VBQ0hfUFRSX1JFVkVS
U0UoYXJnKTsKIAogCWZuID0gZXhwci0+Zm47CmRpZmYgLXVydyAuLi9zcGFyc2Uub3JpZy9l
dmFsdWF0ZS5jIC4vZXZhbHVhdGUuYwotLS0gLi4vc3BhcnNlLm9yaWcvZXZhbHVhdGUuYwky
MDA4LTA2LTI4IDIyOjQ0OjIxLjcwNjU1NDk5OCArMDEwMAorKysgLi9ldmFsdWF0ZS5jCTIw
MDgtMDctMDUgMTU6Mzg6NTMuNzg2OTMxNDkxICswMTAwCkBAIC03Miw3ICs3Miw3IEBACiAJ
dW5zaWduZWQgaW50IGxlbmd0aCA9IGV4cHItPnN0cmluZy0+bGVuZ3RoOwogCiAJc3ltLT5h
cnJheV9zaXplID0gYWxsb2NfY29uc3RfZXhwcmVzc2lvbihleHByLT5wb3MsIGxlbmd0aCk7
Ci0Jc3ltLT5iaXRfc2l6ZSA9IGJpdHNfaW5fY2hhciAqIGxlbmd0aDsKKwlzeW0tPmJpdF9z
aXplID0gYnl0ZXNfdG9fYml0cyhsZW5ndGgpOwogCXN5bS0+Y3R5cGUuYWxpZ25tZW50ID0g
MTsKIAlzeW0tPnN0cmluZyA9IDE7CiAJc3ltLT5jdHlwZS5tb2RpZmllcnMgPSBNT0RfU1RB
VElDOwpAQCAtODMsNyArODMsNyBAQAogCWluaXRzdHItPnN0cmluZyA9IGV4cHItPnN0cmlu
ZzsKIAogCWFycmF5LT5hcnJheV9zaXplID0gc3ltLT5hcnJheV9zaXplOwotCWFycmF5LT5i
aXRfc2l6ZSA9IGJpdHNfaW5fY2hhciAqIGxlbmd0aDsKKwlhcnJheS0+Yml0X3NpemUgPSBi
eXRlc190b19iaXRzKGxlbmd0aCk7CiAJYXJyYXktPmN0eXBlLmFsaWdubWVudCA9IDE7CiAJ
YXJyYXktPmN0eXBlLm1vZGlmaWVycyA9IE1PRF9TVEFUSUM7CiAJYXJyYXktPmN0eXBlLmJh
c2VfdHlwZSA9ICZjaGFyX2N0eXBlOwpAQCAtNTc5LDcgKzU3OSw3IEBACiAJfQogCiAJLyog
R2V0IHRoZSBzaXplIG9mIHdoYXRldmVyIHRoZSBwb2ludGVyIHBvaW50cyB0byAqLwotCW11
bHRpcGx5ID0gYmFzZS0+Yml0X3NpemUgPj4gMzsKKwltdWx0aXBseSA9IGJpdHNfdG9fYnl0
ZXMoYmFzZS0+Yml0X3NpemUpOwogCiAJaWYgKGN0eXBlID09ICZudWxsX2N0eXBlKQogCQlj
dHlwZSA9ICZwdHJfY3R5cGU7CkBAIC04MzEsNyArODMxLDcgQEAKIAkJc3RydWN0IGV4cHJl
c3Npb24gKnN1YiA9IGFsbG9jX2V4cHJlc3Npb24oZXhwci0+cG9zLCBFWFBSX0JJTk9QKTsK
IAkJc3RydWN0IGV4cHJlc3Npb24gKmRpdiA9IGV4cHI7CiAJCXN0cnVjdCBleHByZXNzaW9u
ICp2YWwgPSBhbGxvY19leHByZXNzaW9uKGV4cHItPnBvcywgRVhQUl9WQUxVRSk7Ci0JCXVu
c2lnbmVkIGxvbmcgdmFsdWUgPSBsYmFzZS0+Yml0X3NpemUgPj4gMzsKKwkJdW5zaWduZWQg
bG9uZyB2YWx1ZSA9IGJpdHNfdG9fYnl0ZXMobGJhc2UtPmJpdF9zaXplKTsKIAogCQl2YWwt
PmN0eXBlID0gc2l6ZV90X2N0eXBlOwogCQl2YWwtPnZhbHVlID0gdmFsdWU7CkBAIC0xNTkx
LDcgKzE1OTEsNyBAQAogCQkJCWUzLT5vcCA9ICcrJzsKIAkJCQllMy0+bGVmdCA9IGUwOwog
CQkJCWUzLT5yaWdodCA9IGFsbG9jX2NvbnN0X2V4cHJlc3Npb24oZXhwci0+cG9zLAotCQkJ
CQkJCWV4cHItPnJfYml0cG9zID4+IDMpOworCQkJCQkJCWJpdHNfdG9fYnl0ZXMoZXhwci0+
cl9iaXRwb3MpKTsKIAkJCQllMy0+Y3R5cGUgPSAmbGF6eV9wdHJfY3R5cGU7CiAJCQl9IGVs
c2UgewogCQkJCWUzID0gZTA7CkBAIC0xNzI3LDcgKzE3MjcsNyBAQAogCX0gZWxzZSBpZiAo
Y2xhc3MgPT0gVFlQRV9QVFIpIHsKIAkJc3RydWN0IHN5bWJvbCAqdGFyZ2V0ID0gZXhhbWlu
ZV9wb2ludGVyX3RhcmdldChjdHlwZSk7CiAJCWlmICghaXNfZnVuY3Rpb24odGFyZ2V0KSkK
LQkJCW11bHRpcGx5ID0gdGFyZ2V0LT5iaXRfc2l6ZSA+PiAzOworCQkJbXVsdGlwbHkgPSBi
aXRzX3RvX2J5dGVzKHRhcmdldC0+Yml0X3NpemUpOwogCX0KIAogCWlmIChtdWx0aXBseSkg
ewpAQCAtMTk0OSw3ICsxOTQ5LDcgQEAKIAkJCWV4cHItPmJhc2UgPSBkZXJlZi0+YmFzZTsK
IAkJCWV4cHItPnJfYml0cG9zID0gZGVyZWYtPnJfYml0cG9zOwogCQl9Ci0JCWV4cHItPnJf
Yml0cG9zICs9IG9mZnNldCA8PCAzOworCQlleHByLT5yX2JpdHBvcyArPSBieXRlc190b19i
aXRzKG9mZnNldCk7CiAJCWV4cHItPnR5cGUgPSBFWFBSX1NMSUNFOwogCQlleHByLT5yX25y
Yml0cyA9IG1lbWJlci0+Yml0X3NpemU7CiAJCWV4cHItPnJfYml0cG9zICs9IG1lbWJlci0+
Yml0X29mZnNldDsKQEAgLTIwMzcsMTAgKzIwMzcsMTAgQEAKIAkJcmV0dXJuIE5VTEw7CiAK
IAlzaXplID0gdHlwZS0+Yml0X3NpemU7Ci0JaWYgKChzaXplIDwgMCkgfHwgKHNpemUgJiA3
KSkKKwlpZiAoKHNpemUgPCAwKSB8fCAoc2l6ZSAmIChiaXRzX2luX2NoYXIgLSAxKSkpCiAJ
CWV4cHJlc3Npb25fZXJyb3IoZXhwciwgImNhbm5vdCBzaXplIGV4cHJlc3Npb24iKTsKIAll
eHByLT50eXBlID0gRVhQUl9WQUxVRTsKLQlleHByLT52YWx1ZSA9IHNpemUgPj4gMzsKKwll
eHByLT52YWx1ZSA9IGJpdHNfdG9fYnl0ZXMoc2l6ZSk7CiAJZXhwci0+dGFpbnQgPSAwOwog
CWV4cHItPmN0eXBlID0gc2l6ZV90X2N0eXBlOwogCXJldHVybiBzaXplX3RfY3R5cGU7CkBA
IC0yMDcxLDEwICsyMDcxLDEwIEBACiAJCXJldHVybiBOVUxMOwogCX0KIAlzaXplID0gdHlw
ZS0+Yml0X3NpemU7Ci0JaWYgKHNpemUgJiA3KQorCWlmIChzaXplICYgKGJpdHNfaW5fY2hh
ci0xKSkKIAkJc2l6ZSA9IDA7CiAJZXhwci0+dHlwZSA9IEVYUFJfVkFMVUU7Ci0JZXhwci0+
dmFsdWUgPSBzaXplID4+IDM7CisJZXhwci0+dmFsdWUgPSBiaXRzX3RvX2J5dGVzKHNpemUp
OwogCWV4cHItPnRhaW50ID0gMDsKIAlleHByLT5jdHlwZSA9IHNpemVfdF9jdHlwZTsKIAly
ZXR1cm4gc2l6ZV90X2N0eXBlOwpAQCAtMjE1OCw3ICsyMTU4LDcgQEAKIAl1bnNpZ25lZCBm
cm9tID0gZS0+aWR4X2Zyb207CiAJdW5zaWduZWQgdG8gPSBlLT5pZHhfdG8gKyAxOwogCWUt
PnR5cGUgPSBFWFBSX1BPUzsKLQllLT5pbml0X29mZnNldCA9IGZyb20gKiAoZS0+Y3R5cGUt
PmJpdF9zaXplPj4zKTsKKwllLT5pbml0X29mZnNldCA9IGZyb20gKiBiaXRzX3RvX2J5dGVz
KGUtPmN0eXBlLT5iaXRfc2l6ZSk7CiAJZS0+aW5pdF9uciA9IHRvIC0gZnJvbTsKIAllLT5p
bml0X2V4cHIgPSBjaGlsZDsKIH0KQEAgLTI4NjUsNyArMjg2NSw3IEBACiAJCQl1bnJlc3Ry
aWN0KGlkeCwgaV9jbGFzcywgJmlfdHlwZSk7CiAJCQlpZHggPSBjYXN0X3RvKGlkeCwgc2l6
ZV90X2N0eXBlKTsKIAkJCW0gPSBhbGxvY19jb25zdF9leHByZXNzaW9uKGV4cHItPnBvcywK
LQkJCQkJCSAgIGN0eXBlLT5iaXRfc2l6ZSA+PiAzKTsKKwkJCQkJCSAgIGJpdHNfdG9fYnl0
ZXMoY3R5cGUtPmJpdF9zaXplKSk7CiAJCQltLT5jdHlwZSA9IHNpemVfdF9jdHlwZTsKIAkJ
CW0tPmZsYWdzID0gSW50X2NvbnN0X2V4cHI7CiAJCQlleHByLT50eXBlID0gRVhQUl9CSU5P
UDsKZGlmZiAtdXJ3IC4uL3NwYXJzZS5vcmlnL2V4YW1wbGUuYyAuL2V4YW1wbGUuYwotLS0g
Li4vc3BhcnNlLm9yaWcvZXhhbXBsZS5jCTIwMDgtMDYtMjggMjI6NDQ6MjEuNzA2NTU0OTk4
ICswMTAwCisrKyAuL2V4YW1wbGUuYwkyMDA4LTA2LTI4IDIzOjQ3OjM4Ljc1MDU1ODM0NiAr
MDEwMApAQCAtMTgzMCw3ICsxODMwLDcgQEAKIAkJCWluLT50eXBlID0gUkVHX0ZSQU1FOwog
CQkJaW4tPm9mZnNldCA9IG9mZnNldDsKIAkJCQotCQkJb2Zmc2V0ICs9IGJpdHMgPj4gMzsK
KwkJCW9mZnNldCArPSBiaXRzX3RvX2J5dGVzKGJpdHMpOwogCQl9CiAJCWkrKzsKIAkJTkVY
VF9QVFJfTElTVChhcmd0eXBlKTsKZGlmZiAtdXJ3IC4uL3NwYXJzZS5vcmlnL2V4cGFuZC5j
IC4vZXhwYW5kLmMKLS0tIC4uL3NwYXJzZS5vcmlnL2V4cGFuZC5jCTIwMDgtMDYtMjggMjI6
NDQ6MjEuNzEwNTU1NDE1ICswMTAwCisrKyAuL2V4cGFuZC5jCTIwMDgtMDYtMjggMjM6NDk6
NDYuNTIzMzA5NTU5ICswMTAwCkBAIC04ODAsNyArODgwLDcgQEAKIHsKIAl1bnNpZ25lZCBs
b25nIG9mZnNldCA9IDA7CiAJd2hpbGUgKGV4cHItPnR5cGUgPT0gRVhQUl9QT1MpIHsKLQkJ
b2Zmc2V0ICs9IGV4cHItPmluaXRfb2Zmc2V0IDw8IDM7CisJCW9mZnNldCArPSBieXRlc190
b19iaXRzKGV4cHItPmluaXRfb2Zmc2V0KTsKIAkJZXhwciA9IGV4cHItPmluaXRfZXhwcjsK
IAl9CiAJaWYgKGV4cHIgJiYgZXhwci0+Y3R5cGUpCmRpZmYgLXVydyAuLi9zcGFyc2Uub3Jp
Zy9mbG93LmMgLi9mbG93LmMKLS0tIC4uL3NwYXJzZS5vcmlnL2Zsb3cuYwkyMDA4LTA2LTI4
IDIyOjQ0OjIxLjcxMDU1NTQxNSArMDEwMAorKysgLi9mbG93LmMJMjAwOC0wNi0yOCAyMzo0
OTo0NS4wMTQ1NTQ1MTggKzAxMDAKQEAgLTE2LDYgKzE2LDcgQEAKICNpbmNsdWRlICJleHBy
ZXNzaW9uLmgiCiAjaW5jbHVkZSAibGluZWFyaXplLmgiCiAjaW5jbHVkZSAiZmxvdy5oIgor
I2luY2x1ZGUgInRhcmdldC5oIgogCiB1bnNpZ25lZCBsb25nIGJiX2dlbmVyYXRpb247CiAK
QEAgLTI2NSw4ICsyNjYsOCBAQAogCiBzdGF0aWMgaW50IG92ZXJsYXBwaW5nX21lbW9wKHN0
cnVjdCBpbnN0cnVjdGlvbiAqYSwgc3RydWN0IGluc3RydWN0aW9uICpiKQogewotCXVuc2ln
bmVkIGludCBhX3N0YXJ0ID0gYS0+b2Zmc2V0IDw8IDM7Ci0JdW5zaWduZWQgaW50IGJfc3Rh
cnQgPSBiLT5vZmZzZXQgPDwgMzsKKwl1bnNpZ25lZCBpbnQgYV9zdGFydCA9IGJ5dGVzX3Rv
X2JpdHMoYS0+b2Zmc2V0KTsKKwl1bnNpZ25lZCBpbnQgYl9zdGFydCA9IGJ5dGVzX3RvX2Jp
dHMoYi0+b2Zmc2V0KTsKIAl1bnNpZ25lZCBpbnQgYV9zaXplID0gYS0+c2l6ZTsKIAl1bnNp
Z25lZCBpbnQgYl9zaXplID0gYi0+c2l6ZTsKIApAQCAtNTgxLDEzICs1ODIsMTQgQEAKIAlw
c2V1ZG9fdCBwc2V1ZG8gPSBpbnNuLT5zcmM7CiAKIAlpZiAoaW5zbi0+YmIgJiYgcHNldWRv
LT50eXBlID09IFBTRVVET19TWU0pIHsKLQkJaW50IG9mZnNldCA9IGluc24tPm9mZnNldCwg
Yml0ID0gKG9mZnNldCA8PCAzKSArIGluc24tPnNpemU7CisJCWludCBvZmZzZXQgPSBpbnNu
LT5vZmZzZXQsIGJpdCA9IGJ5dGVzX3RvX2JpdHMob2Zmc2V0KSArIGluc24tPnNpemU7CiAJ
CXN0cnVjdCBzeW1ib2wgKnN5bSA9IHBzZXVkby0+c3ltOwogCiAJCWlmIChzeW0tPmJpdF9z
aXplID4gMCAmJiAob2Zmc2V0IDwgMCB8fCBiaXQgPiBzeW0tPmJpdF9zaXplKSkKIAkJCXdh
cm5pbmcoaW5zbi0+cG9zLCAiaW52YWxpZCBhY2Nlc3MgJXMgJyVzJyAoJWQgJWQpIiwKIAkJ
CQlvZmZzZXQgPCAwID8gImJlbG93IiA6ICJwYXN0IHRoZSBlbmQgb2YiLAotCQkJCXNob3df
aWRlbnQoc3ltLT5pZGVudCksIG9mZnNldCwgc3ltLT5iaXRfc2l6ZSA+PiAzKTsKKwkJCQlz
aG93X2lkZW50KHN5bS0+aWRlbnQpLCBvZmZzZXQsCisJCQkJYml0c190b19ieXRlcyhzeW0t
PmJpdF9zaXplKSk7CiAJfQogfQogCmRpZmYgLXVydyAuLi9zcGFyc2Uub3JpZy9zaG93LXBh
cnNlLmMgLi9zaG93LXBhcnNlLmMKLS0tIC4uL3NwYXJzZS5vcmlnL3Nob3ctcGFyc2UuYwky
MDA4LTA2LTI4IDIyOjQ0OjIxLjcxODU1NTkyNiArMDEwMAorKysgLi9zaG93LXBhcnNlLmMJ
MjAwOC0wNi0yOCAyMzo0Nzo0MC4wMTA1NTM2MTcgKzAxMDAKQEAgLTY3Myw3ICs2NzMsNyBA
QAogCQlpbnQgbmV3ID0gc2hvd19leHByZXNzaW9uKGFyZyk7CiAJCWludCBzaXplID0gYXJn
LT5jdHlwZS0+Yml0X3NpemU7CiAJCXByaW50ZigiXHRwdXNoLiVkXHRcdHYlZFxuIiwgc2l6
ZSwgbmV3KTsKLQkJZnJhbWVzaXplICs9IHNpemUgPj4gMzsKKwkJZnJhbWVzaXplICs9IGJp
dHNfdG9fYnl0ZXMoc2l6ZSk7CiAJfSBFTkRfRk9SX0VBQ0hfUFRSX1JFVkVSU0UoYXJnKTsK
IAogCWZuID0gZXhwci0+Zm47CmRpZmYgLXVydyAuLi9zcGFyc2Uub3JpZy9zeW1ib2wuYyAu
L3N5bWJvbC5jCi0tLSAuLi9zcGFyc2Uub3JpZy9zeW1ib2wuYwkyMDA4LTA2LTI4IDIyOjQ0
OjIxLjcyMjU1NTE3OCArMDEwMAorKysgLi9zeW1ib2wuYwkyMDA4LTA2LTI4IDIzOjQ5OjQ1
Ljc1ODU1NTM4NSArMDEwMApAQCAtMTI4LDcgKzEyOCw3IEBACiAJCWJhc2Vfc2l6ZSA9IDA7
CiAJfQogCi0JYWxpZ25fYml0X21hc2sgPSAoc3ltLT5jdHlwZS5hbGlnbm1lbnQgPDwgMykg
LSAxOworCWFsaWduX2JpdF9tYXNrID0gYnl0ZXNfdG9fYml0cyhzeW0tPmN0eXBlLmFsaWdu
bWVudCkgLSAxOwogCiAJLyoKIAkgKiBCaXRmaWVsZHMgaGF2ZSBzb21lIHZlcnkgc3BlY2lh
bCBydWxlcy4uCkBAIC0xNDMsNyArMTQzLDcgQEAKIAkJCWJpdF9zaXplID0gKGJpdF9zaXpl
ICsgYWxpZ25fYml0X21hc2spICYgfmFsaWduX2JpdF9tYXNrOwogCQkJYml0X29mZnNldCA9
IDA7CiAJCX0KLQkJc3ltLT5vZmZzZXQgPSAoYml0X3NpemUgLSBiaXRfb2Zmc2V0KSA+PiAz
OworCQlzeW0tPm9mZnNldCA9IGJpdHNfdG9fYnl0ZXMoYml0X3NpemUgLSBiaXRfb2Zmc2V0
KTsKIAkJc3ltLT5iaXRfb2Zmc2V0ID0gYml0X29mZnNldDsKIAkJc3ltLT5jdHlwZS5iYXNl
X3R5cGUtPmJpdF9vZmZzZXQgPSBiaXRfb2Zmc2V0OwogCQlpbmZvLT5iaXRfc2l6ZSA9IGJp
dF9zaXplICsgd2lkdGg7CkBAIC0xNTYsNyArMTU2LDcgQEAKIAkgKiBPdGhlcndpc2UsIGp1
c3QgYWxpZ24gaXQgcmlnaHQgYW5kIGFkZCBpdCB1cC4uCiAJICovCiAJYml0X3NpemUgPSAo
Yml0X3NpemUgKyBhbGlnbl9iaXRfbWFzaykgJiB+YWxpZ25fYml0X21hc2s7Ci0Jc3ltLT5v
ZmZzZXQgPSBiaXRfc2l6ZSA+PiAzOworCXN5bS0+b2Zmc2V0ID0gYml0c190b19ieXRlcyhi
aXRfc2l6ZSk7CiAKIAlpbmZvLT5iaXRfc2l6ZSA9IGJpdF9zaXplICsgYmFzZV9zaXplOwog
CS8vIHdhcm5pbmcgKHN5bS0+cG9zLCAicmVndWxhcjogb2Zmc2V0PSVkIiwgc3ltLT5vZmZz
ZXQpOwpAQCAtMTgyLDcgKzE4Miw3IEBACiAJCXN5bS0+Y3R5cGUuYWxpZ25tZW50ID0gaW5m
by5tYXhfYWxpZ247CiAJYml0X3NpemUgPSBpbmZvLmJpdF9zaXplOwogCWlmIChpbmZvLmFs
aWduX3NpemUpIHsKLQkJYml0X2FsaWduID0gKHN5bS0+Y3R5cGUuYWxpZ25tZW50IDw8IDMp
LTE7CisJCWJpdF9hbGlnbiA9IGJ5dGVzX3RvX2JpdHMoc3ltLT5jdHlwZS5hbGlnbm1lbnQp
LTE7CiAJCWJpdF9zaXplID0gKGJpdF9zaXplICsgYml0X2FsaWduKSAmIH5iaXRfYWxpZ247
CiAJfQogCXN5bS0+Yml0X3NpemUgPSBiaXRfc2l6ZTsKQEAgLTg3Nyw3ICs4NzcsNyBAQAog
CQlzdHJ1Y3Qgc3ltYm9sICpzeW0gPSBjdHlwZS0+cHRyOwogCQl1bnNpZ25lZCBsb25nIGJp
dF9zaXplID0gY3R5cGUtPmJpdF9zaXplID8gKmN0eXBlLT5iaXRfc2l6ZSA6IC0xOwogCQl1
bnNpZ25lZCBsb25nIG1heGFsaWduID0gY3R5cGUtPm1heGFsaWduID8gKmN0eXBlLT5tYXhh
bGlnbiA6IDA7Ci0JCXVuc2lnbmVkIGxvbmcgYWxpZ25tZW50ID0gKGJpdF9zaXplICsgNykg
Pj4gMzsKKwkJdW5zaWduZWQgbG9uZyBhbGlnbm1lbnQgPSBiaXRzX3RvX2J5dGVzKGJpdF9z
aXplICsgYml0c19pbl9jaGFyIC0gMSk7CiAKIAkJaWYgKGFsaWdubWVudCA+IG1heGFsaWdu
KQogCQkJYWxpZ25tZW50ID0gbWF4YWxpZ247CmRpZmYgLXVydyAuLi9zcGFyc2Uub3JpZy90
YXJnZXQuaCAuL3RhcmdldC5oCi0tLSAuLi9zcGFyc2Uub3JpZy90YXJnZXQuaAkyMDA4LTA2
LTI4IDIyOjQ0OjIxLjcyMjU1NTE3OCArMDEwMAorKysgLi90YXJnZXQuaAkyMDA4LTA2LTI5
IDAwOjA0OjI1Ljk1MDU1Mzk2NSArMDEwMApAQCAtNDIsNCArNDIsMTQgQEAKIGV4dGVybiBp
bnQgYml0c19pbl9lbnVtOwogZXh0ZXJuIGludCBlbnVtX2FsaWdubWVudDsKIAorLyoKKyAq
IEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbnZlcnRpbmcgYml0cyB0byBieXRlcyBhbmQgdmlj
ZSB2ZXJzYS4KKyAqLworCitzdGF0aWMgaW5saW5lIGludCBiaXRzX3RvX2J5dGVzKGludCBi
aXRzKQoreyByZXR1cm4gYml0cyAvIGJpdHNfaW5fY2hhcjsgfQorCitzdGF0aWMgaW5saW5l
IGludCBieXRlc190b19iaXRzKGludCBieXRlcykKK3sgcmV0dXJuIGJ5dGVzICogYml0c19p
bl9jaGFyOyB9CisKICNlbmRpZgo=
--------------010609080402000901090104--

--------------enig6DD22DB3B7FE553CA7FF5CA1
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIcBnjf9E0noFvlzgRAvHoAJ0QnLG1N1fB0c2G3qnnsdw6MbofmACfa+I1
enDpVKtecQvSPQg+kBm6XHA=
=To1c
-----END PGP SIGNATURE-----

--------------enig6DD22DB3B7FE553CA7FF5CA1--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Updated byte size patch
Date: Mon, 07 Jul 2008 18:02:50 +0000
Message-ID: <1215453770.3003.32.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Sun, 2008-07-06 at 02:03 +0100, David Given wrote:
> Turns out that I'd missed one place where there was a hardcoded 8 in the
> last patch, so here's an updated version.

I do still have some concerns about the potential performance loss, but
it seems unlikely to cause a serious problem.  I have *serious* doubts
that Sparse will ever successfully handle a system without 8-bit bytes.
However, I will merge this patch.  I do need a signoff, though.

- Josh Triplett


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Using sparse to catch invalid RCU dereferences? ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Using sparse to catch invalid RCU dereferences?
Date: Mon, 07 Apr 2008 22:04:16 +0000
Message-ID: <1207605856.12481.35.camel () johannes ! berg>
--------------------

--=-SjFz9EIODu9sYalA0+mv
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

Hi,

Just a thought, I haven't tried this yet because I'm not entirely sure
it's actually correct. I was just thinking it should be possible to
introduce something like

	#define __rcu	__attribute__((address_space(3)))

(for sparse only, of course) and then be able to say

	struct myfoo *foo __rcu;

and sparse would warn on

	struct myfoo *bar =3D foo;

but not on

	struct myfoo *bar =3D rcu_dereference(foo);

by way of using __force inside rcu_dereference(), rcu_assign_pointer()
etc.

Would this be feasible? Or should one actually use __bitwise/__force to
also get the warning when assigning between two variables both marked
__rcu?

johannes

--=-SjFz9EIODu9sYalA0+mv
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/qaX6Vg1VMiehFYAQL5Fg//caZ8XrG77rz5KrVMCHYB78RjnwktYNZv
8FlTqSmxZymQMZ8IrEUsihj/d6ZyXSWqvQbAQTakGsIy4uk9s35svmJJWkE+WqJR
yVjgOPATQc8dudxeZvyt8AeKfeCkKIfPq8jhEM+/wZ6SfuF0ji9C38vdGGclljMd
2VyL1oj4QF8ttoBYRGMJmP+3HDuJn3QcczZ1tivxIw5B2kchyq3X1FEuGMlwo3QR
AWaX1DF+VDcNgvWneJLBeEzcg1FK4vLSJr/jWaOO+ymMQ+T2eksQvlifZueO8imJ
xKGic/sP3T6G5+6wh1IaBA9SZP31QVsSH9Dlu6GCkG1/mXscrseDw9c+kZgN8wNJ
8JFUGUJTrIcqTMgZNZ4mjximeOAAVkLFKT49hhvOJYaw5forUoOs2sQ8IMEhzhMQ
qNJd3Bf6nmULlEnr4er4XdgTFlZ48Vr83UYDvDbTJftWZfnE2GTHNr6v7m+Gj8r3
uRodyK1MYkK+8LnPfM88H+GRhme6uJvT3Vbw7quJf/C1eOSZPs/kNjWnGeA6EYR/
heTJnFcfHO5KTP/wiMhHbbMumCZq5pi5ARZRY7OQeX5D/mmbVaj5cgD544FPNhFT
QGE1FTfCuyiCjhSqZmcOiHCZuk/DRRhB3npO5EzW5yZ36z0vYoVU1sQX8vu9eLug
m4h3RBPHK3U=
=ut7R
-----END PGP SIGNATURE-----

--=-SjFz9EIODu9sYalA0+mv--

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "Paul E. McKenney" <paulmck () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Tue, 08 Apr 2008 15:52:59 +0000
Message-ID: <20080408155259.GA8381 () linux ! vnet ! ibm ! com>
--------------------
On Tue, Apr 08, 2008 at 12:04:16AM +0200, Johannes Berg wrote:
> Hi,
> 
> Just a thought, I haven't tried this yet because I'm not entirely sure
> it's actually correct. I was just thinking it should be possible to
> introduce something like
> 
> 	#define __rcu	__attribute__((address_space(3)))
> 
> (for sparse only, of course) and then be able to say
> 
> 	struct myfoo *foo __rcu;
> 
> and sparse would warn on
> 
> 	struct myfoo *bar = foo;
> 
> but not on
> 
> 	struct myfoo *bar = rcu_dereference(foo);

Ah, "address_space" is a sparse-ism, no wonder I couldn't find it in
the gcc docs...

So the address_space attribute says what the pointer points to rather
than where the pointer resides, correct?

> by way of using __force inside rcu_dereference(), rcu_assign_pointer()
> etc.
> 
> Would this be feasible? Or should one actually use __bitwise/__force to
> also get the warning when assigning between two variables both marked
> __rcu?

It might be.  There are a number of places where it is legal to access
RCU-protected pointers directly, and all of these would need to be
changed.  For example, in the example above, one could do:

	foo = NULL;

I recently tried to modify rcu_assign_pointer() to issue the memory
memory barrier only when the pointer was non-NULL, but this ended badly.
Probably because I am not the greatest gcc expert around...  We ended
up having to define an rcu_assign_index() to handle the possibility of
assigning a zero-value array index, but my attempts to do type-checking
backfired, and I eventually gave it up.  Again, someone a bit more clued
in to gcc than I am could probably pull it off.

In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer()
when holding the update-side lock.

So I very much like this approach in general, but it will require some
care to implement.  I would be very happy to review and comment!!!

							Thanx, Paul
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Tue, 08 Apr 2008 16:09:15 +0000
Message-ID: <1207670955.5550.15.camel () johannes ! berg>
--------------------

--=-68mHHPRgfvVX9k6pfAa6
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> So the address_space attribute says what the pointer points to rather
> than where the pointer resides, correct?

Yeah. It's currently used for __user and __iomem. Using it for rcu
wouldn't be quite the way it was intended, I think, but hey :)

> It might be.  There are a number of places where it is legal to access
> RCU-protected pointers directly, and all of these would need to be
> changed.  For example, in the example above, one could do:
>=20
> 	foo =3D NULL;

Yeah, all of those would lead to sparse warnings. Are we willing to
change all that code?

> I recently tried to modify rcu_assign_pointer() to issue the memory
> memory barrier only when the pointer was non-NULL, but this ended badly.
> Probably because I am not the greatest gcc expert around...  We ended
> up having to define an rcu_assign_index() to handle the possibility of
> assigning a zero-value array index, but my attempts to do type-checking
> backfired, and I eventually gave it up.  Again, someone a bit more clued
> in to gcc than I am could probably pull it off.

I don't think I would be that person :)

> In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer=
()
> when holding the update-side lock.

Right. Those too would lead to problems, unless we change that code to
use those (or other) macros.

> So I very much like this approach in general, but it will require some
> care to implement.  I would be very happy to review and comment!!!

I'll play with it a bit if I get around, was just reviewing some RCU
usage and had the feeling that it should be possible to automate.

johannes

--=-68mHHPRgfvVX9k6pfAa6
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/uYqqVg1VMiehFYAQKJIQ/+K4yei2vr3DtJpwjO+zSLA+QyDPzFGq8J
FbYwZh9O7Bnq00Zst6RhZZSeP8Tj4HDnQEFIgxDJ1jM7oKveGaRRqW9siq69NDuW
2EVnJfJvwcJH/D957CqwskATjMgkFhPnDzHiTEsbua3Jwsehm0pyFZhOhxMpqODb
ZwAKGbNJRPU6ez/3UOwDj2XkidWQcJgie2FWhIN7w8J6ZpO48dfy6GiBP3q13vkQ
hukw+jGIoOqkxkAYXvSmRoTVhwioZB+khUdck1ZbjOqjy2eeVAfmtXJTreBRp0aW
IVdUXFP6gH2QipubNdeXYGd42NbJqdIC6hMhnmwbmdTXQRLxoKg9Uf2KFttZnUrw
tgd2psj4WTYgOlI8XtQlDnGmfDNfapqNqMOeIZwT/adIV/PbqggSy+tn9UL3BJf4
MF/0pAKsifte3XuFbuSymd4GsIumsbY+neIHNwvcjYUfJupZbwXqFrnIE3ikr8P+
EYcOFje1Ec7cEIdK78xZRVUb4QvdXQoAhgID203NLlfmLC9q305ZEZJZSm4rUaSK
XuBzSv9h8u0QGq4eVp2+WPAMgedGW8tM5VTkgf0NIlTjq2eQm6aJ3hR8UizwthuX
cdoezNYE3jDvSBzeKibHkPcN7k3o9ahRD5e3yCedtKXbrY5HHpf/7AsYCLbKLThO
GPz3j7USBqY=
=BhbU
-----END PGP SIGNATURE-----

--=-68mHHPRgfvVX9k6pfAa6--

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Tue, 08 Apr 2008 16:09:15 +0000
Message-ID: <1207670955.5550.15.camel () johannes ! berg>
--------------------

--=-68mHHPRgfvVX9k6pfAa6
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> So the address_space attribute says what the pointer points to rather
> than where the pointer resides, correct?

Yeah. It's currently used for __user and __iomem. Using it for rcu
wouldn't be quite the way it was intended, I think, but hey :)

> It might be.  There are a number of places where it is legal to access
> RCU-protected pointers directly, and all of these would need to be
> changed.  For example, in the example above, one could do:
>=20
> 	foo =3D NULL;

Yeah, all of those would lead to sparse warnings. Are we willing to
change all that code?

> I recently tried to modify rcu_assign_pointer() to issue the memory
> memory barrier only when the pointer was non-NULL, but this ended badly.
> Probably because I am not the greatest gcc expert around...  We ended
> up having to define an rcu_assign_index() to handle the possibility of
> assigning a zero-value array index, but my attempts to do type-checking
> backfired, and I eventually gave it up.  Again, someone a bit more clued
> in to gcc than I am could probably pull it off.

I don't think I would be that person :)

> In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer=
()
> when holding the update-side lock.

Right. Those too would lead to problems, unless we change that code to
use those (or other) macros.

> So I very much like this approach in general, but it will require some
> care to implement.  I would be very happy to review and comment!!!

I'll play with it a bit if I get around, was just reviewing some RCU
usage and had the feeling that it should be possible to automate.

johannes

--=-68mHHPRgfvVX9k6pfAa6
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/uYqqVg1VMiehFYAQKJIQ/+K4yei2vr3DtJpwjO+zSLA+QyDPzFGq8J
FbYwZh9O7Bnq00Zst6RhZZSeP8Tj4HDnQEFIgxDJ1jM7oKveGaRRqW9siq69NDuW
2EVnJfJvwcJH/D957CqwskATjMgkFhPnDzHiTEsbua3Jwsehm0pyFZhOhxMpqODb
ZwAKGbNJRPU6ez/3UOwDj2XkidWQcJgie2FWhIN7w8J6ZpO48dfy6GiBP3q13vkQ
hukw+jGIoOqkxkAYXvSmRoTVhwioZB+khUdck1ZbjOqjy2eeVAfmtXJTreBRp0aW
IVdUXFP6gH2QipubNdeXYGd42NbJqdIC6hMhnmwbmdTXQRLxoKg9Uf2KFttZnUrw
tgd2psj4WTYgOlI8XtQlDnGmfDNfapqNqMOeIZwT/adIV/PbqggSy+tn9UL3BJf4
MF/0pAKsifte3XuFbuSymd4GsIumsbY+neIHNwvcjYUfJupZbwXqFrnIE3ikr8P+
EYcOFje1Ec7cEIdK78xZRVUb4QvdXQoAhgID203NLlfmLC9q305ZEZJZSm4rUaSK
XuBzSv9h8u0QGq4eVp2+WPAMgedGW8tM5VTkgf0NIlTjq2eQm6aJ3hR8UizwthuX
cdoezNYE3jDvSBzeKibHkPcN7k3o9ahRD5e3yCedtKXbrY5HHpf/7AsYCLbKLThO
GPz3j7USBqY=
=BhbU
-----END PGP SIGNATURE-----

--=-68mHHPRgfvVX9k6pfAa6--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Paul E. McKenney" <paulmck () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Tue, 08 Apr 2008 17:24:36 +0000
Message-ID: <20080408172436.GE8381 () linux ! vnet ! ibm ! com>
--------------------
On Tue, Apr 08, 2008 at 06:09:15PM +0200, Johannes Berg wrote:
> 
> > So the address_space attribute says what the pointer points to rather
> > than where the pointer resides, correct?
> 
> Yeah. It's currently used for __user and __iomem. Using it for rcu
> wouldn't be quite the way it was intended, I think, but hey :)

;-)

> > It might be.  There are a number of places where it is legal to access
> > RCU-protected pointers directly, and all of these would need to be
> > changed.  For example, in the example above, one could do:
> > 
> > 	foo = NULL;
> 
> Yeah, all of those would lead to sparse warnings. Are we willing to
> change all that code?

If it found some bugs, I would certainly be in favor!

> > I recently tried to modify rcu_assign_pointer() to issue the memory
> > memory barrier only when the pointer was non-NULL, but this ended badly.
> > Probably because I am not the greatest gcc expert around...  We ended
> > up having to define an rcu_assign_index() to handle the possibility of
> > assigning a zero-value array index, but my attempts to do type-checking
> > backfired, and I eventually gave it up.  Again, someone a bit more clued
> > in to gcc than I am could probably pull it off.
> 
> I don't think I would be that person :)

When it comes to gcc extensions and type-casting trickery, I am not all
that clued in, to be honest...

> > In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer()
> > when holding the update-side lock.
> 
> Right. Those too would lead to problems, unless we change that code to
> use those (or other) macros.

Yep.

> > So I very much like this approach in general, but it will require some
> > care to implement.  I would be very happy to review and comment!!!
> 
> I'll play with it a bit if I get around, was just reviewing some RCU
> usage and had the feeling that it should be possible to automate.

If it finds a few bugs, it would be worth it!

							Thanx, Paul
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Wed, 09 Apr 2008 20:09:46 +0000
Message-ID: <1207771787.7442.45.camel () johannes ! berg>
--------------------

--=-zGX7g5zuk9rIfinKQi5/
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable


> It might be.  There are a number of places where it is legal to access
> RCU-protected pointers directly, and all of these would need to be
> changed.  For example, in the example above, one could do:
>=20
> 	foo =3D NULL;

Ok, that I understand, but sparse always treats NULL specially anyway.

> I recently tried to modify rcu_assign_pointer() to issue the memory
> memory barrier only when the pointer was non-NULL, but this ended badly.

Hm? I thought that's in the current tree.

> Probably because I am not the greatest gcc expert around...  We ended
> up having to define an rcu_assign_index() to handle the possibility of
> assigning a zero-value array index, but my attempts to do type-checking
> backfired, and I eventually gave it up.  Again, someone a bit more clued
> in to gcc than I am could probably pull it off.

Ah, ok.

> In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer=
()
> when holding the update-side lock.

That I don't understand. Well, I do understand that omitting
rcu_dereference() is ok, but it seems to me that the memory and compiler
barrier in rcu_assign_pointer() is actually needed.

I've been playing a bit, see below for my play rcupdate.h and test.c
test program.

Unfortunately, sparse doesn't have the ability to declare
"=EF=BB=BF__attribute__((force_bitwise)) typeof(p)" or even
"=EF=BB=BF__attribute__((force)) typeof(p)" which makes this force more tha=
n
necessary and causes it to not catch when incompatible pointers are
used. gcc notices that because I only do a cast at all for sparse, but
that doesn't help, since e.g. list_for_each_entry_rcu() requires that
the correct type is returned. So without sparse supporting the latter
notation, we don't stand a chance.

Also, I wouldn't know how to declare that an array or so needs
rcu-access to the members.

johannes


rcupdate.h:

#define USE_BITWISE

#ifdef __CHECKER__
#ifdef USE_BITWISE
#define __rcu __attribute__((bitwise))
#define __force_rcu_cast(p) (*((__attribute__((force)) void **)&(p)))
// would like instead:
//#define __force_rcu_cast(p) ((__attribute__((force_bitwise)) typeof(p)) (=
p))
#else /* not bitwise */
#define __rcu __attribute__((address_space(3)))
#define __force_rcu_cast(p) (*((__attribute__((force)) void **)&(p)))
// would like instead:
//#define __force_rcu_cast(p) ((__attribute__((force_address_space)) typeof=
(p)) (p))
#endif

#else /* not checker */
#define __rcu
#define __force_rcu_cast(p) (p)
#endif

#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))

#define rcu_dereference(p)     ({ \
				typeof(p) _________p1 =3D ACCESS_ONCE(p); \
				smp_read_barrier_depends(); \
				__force_rcu_cast(_________p1); \
				})

/**
 * rcu_fetch - fetch an RCU-protected pointer in the update-locked
 * critical section.
 *
 * This macro exists for documentation and code checking purposes.
 */
#define rcu_fetch(p)     __force_rcu_cast(p);

#define rcu_assign_pointer(p, v) \
	({ \
		if (!__builtin_constant_p(v) || \
		    ((v) !=3D NULL)) \
			smp_wmb(); \
		__force_rcu_cast(p) =3D (v); \
	})


test.c:

#include <stdlib.h>
#include "rcupdate.h"

/* my rcu protected variables */
static unsigned int __rcu *prot;
static unsigned int __rcu *prot_same;
static unsigned char __rcu *prot2;

// dummies
static smp_read_barrier_depends(void) {}
static smp_wmb(void) {}

int main(void)
{
	unsigned int *tmp;

	// no warnings from sparse due to forced cast
	rcu_assign_pointer(prot, tmp);
	// but gcc warns
	rcu_assign_pointer(prot2, tmp);

	// no warnings
	rcu_assign_pointer(prot, NULL);
	rcu_assign_pointer(prot2, NULL);

	// no warnings
	prot =3D NULL;
	prot2 =3D NULL;

	// no warnings from sparse due to forced cast
	tmp =3D rcu_dereference(prot);
	// but gcc warns
	tmp =3D rcu_dereference(prot2);

	/* now within locked section rcu_dereference isn't required */

	// no warnings from sparse due to forced cast
	tmp =3D rcu_fetch(prot);
	// but gcc warns
	tmp =3D rcu_fetch(prot2);

	/* not caught with address_space, but is caught with bitwise */
	prot =3D prot_same;
}


--=-zGX7g5zuk9rIfinKQi5/
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/0iiaVg1VMiehFYAQKBQw/+ObJPHF3OQNai7a/yaYleFi22KC+fZ0Am
qcm9jPC1kl9N/nQFxmbY0nUQyo/8282U7KjESFoT3IWF3Y8iPa6kwb8Os5YQn1jG
uhnnwgQwmUJ7EEckE5TAGJn7mGF25lcOowXI6xM31WA5XAXgBsOuXHDk7DOQQQkr
pjoawJg/R64bKjVDk97cXNUqHWysajAgRg0jZZr9EGO0OY1dbwqfdUfY5TUJEHvv
2zJvmgbiSrLeHRA1FwzDDrftTtwjgvEPU59nYhpd5sb0eetf5GK6yARaiI8MpJkA
Ikl7Cpc9A1EzuBKMDnh1j7XLAwgwkru/iLSe3Lh58VpqfblM5ITTtx3buQFDW3FN
zljDgKrOxGuRygEmkZX8vzEBeKtzxGCIFp/OHbJlaZSfus8TPHTEgCh7hYH2JeF+
Ccmdxo/8IGdfw2yP8FONFsSirLc1IAshnuLZszH3wvVd4ZfQ1f+QNK2uMWZTQrAV
DDuYCPrKWGc4FA/IK8vbTo36ndZeKRCIPBXywJAWxO6gLQ+sSV1mG1yNt2CUApRN
ghZu+AIhhA7wsTnlyKxtP4tZk+dj8oY/5LSKGIGJRW+a8YgzCp+89pLEFNXmuk+E
jxjQbWmGBjgOINHbAjevt0lbtjyI1hkJIU9a+17LaHFJdgBhNdJMji/MHw0qZycA
BRDmI9CMPCQ=
=7XsJ
-----END PGP SIGNATURE-----

--=-zGX7g5zuk9rIfinKQi5/--

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Wed, 09 Apr 2008 20:09:46 +0000
Message-ID: <1207771787.7442.45.camel () johannes ! berg>
--------------------

--=-zGX7g5zuk9rIfinKQi5/
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable


> It might be.  There are a number of places where it is legal to access
> RCU-protected pointers directly, and all of these would need to be
> changed.  For example, in the example above, one could do:
>=20
> 	foo =3D NULL;

Ok, that I understand, but sparse always treats NULL specially anyway.

> I recently tried to modify rcu_assign_pointer() to issue the memory
> memory barrier only when the pointer was non-NULL, but this ended badly.

Hm? I thought that's in the current tree.

> Probably because I am not the greatest gcc expert around...  We ended
> up having to define an rcu_assign_index() to handle the possibility of
> assigning a zero-value array index, but my attempts to do type-checking
> backfired, and I eventually gave it up.  Again, someone a bit more clued
> in to gcc than I am could probably pull it off.

Ah, ok.

> In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer=
()
> when holding the update-side lock.

That I don't understand. Well, I do understand that omitting
rcu_dereference() is ok, but it seems to me that the memory and compiler
barrier in rcu_assign_pointer() is actually needed.

I've been playing a bit, see below for my play rcupdate.h and test.c
test program.

Unfortunately, sparse doesn't have the ability to declare
"=EF=BB=BF__attribute__((force_bitwise)) typeof(p)" or even
"=EF=BB=BF__attribute__((force)) typeof(p)" which makes this force more tha=
n
necessary and causes it to not catch when incompatible pointers are
used. gcc notices that because I only do a cast at all for sparse, but
that doesn't help, since e.g. list_for_each_entry_rcu() requires that
the correct type is returned. So without sparse supporting the latter
notation, we don't stand a chance.

Also, I wouldn't know how to declare that an array or so needs
rcu-access to the members.

johannes


rcupdate.h:

#define USE_BITWISE

#ifdef __CHECKER__
#ifdef USE_BITWISE
#define __rcu __attribute__((bitwise))
#define __force_rcu_cast(p) (*((__attribute__((force)) void **)&(p)))
// would like instead:
//#define __force_rcu_cast(p) ((__attribute__((force_bitwise)) typeof(p)) (=
p))
#else /* not bitwise */
#define __rcu __attribute__((address_space(3)))
#define __force_rcu_cast(p) (*((__attribute__((force)) void **)&(p)))
// would like instead:
//#define __force_rcu_cast(p) ((__attribute__((force_address_space)) typeof=
(p)) (p))
#endif

#else /* not checker */
#define __rcu
#define __force_rcu_cast(p) (p)
#endif

#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))

#define rcu_dereference(p)     ({ \
				typeof(p) _________p1 =3D ACCESS_ONCE(p); \
				smp_read_barrier_depends(); \
				__force_rcu_cast(_________p1); \
				})

/**
 * rcu_fetch - fetch an RCU-protected pointer in the update-locked
 * critical section.
 *
 * This macro exists for documentation and code checking purposes.
 */
#define rcu_fetch(p)     __force_rcu_cast(p);

#define rcu_assign_pointer(p, v) \
	({ \
		if (!__builtin_constant_p(v) || \
		    ((v) !=3D NULL)) \
			smp_wmb(); \
		__force_rcu_cast(p) =3D (v); \
	})


test.c:

#include <stdlib.h>
#include "rcupdate.h"

/* my rcu protected variables */
static unsigned int __rcu *prot;
static unsigned int __rcu *prot_same;
static unsigned char __rcu *prot2;

// dummies
static smp_read_barrier_depends(void) {}
static smp_wmb(void) {}

int main(void)
{
	unsigned int *tmp;

	// no warnings from sparse due to forced cast
	rcu_assign_pointer(prot, tmp);
	// but gcc warns
	rcu_assign_pointer(prot2, tmp);

	// no warnings
	rcu_assign_pointer(prot, NULL);
	rcu_assign_pointer(prot2, NULL);

	// no warnings
	prot =3D NULL;
	prot2 =3D NULL;

	// no warnings from sparse due to forced cast
	tmp =3D rcu_dereference(prot);
	// but gcc warns
	tmp =3D rcu_dereference(prot2);

	/* now within locked section rcu_dereference isn't required */

	// no warnings from sparse due to forced cast
	tmp =3D rcu_fetch(prot);
	// but gcc warns
	tmp =3D rcu_fetch(prot2);

	/* not caught with address_space, but is caught with bitwise */
	prot =3D prot_same;
}


--=-zGX7g5zuk9rIfinKQi5/
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/0iiaVg1VMiehFYAQKBQw/+ObJPHF3OQNai7a/yaYleFi22KC+fZ0Am
qcm9jPC1kl9N/nQFxmbY0nUQyo/8282U7KjESFoT3IWF3Y8iPa6kwb8Os5YQn1jG
uhnnwgQwmUJ7EEckE5TAGJn7mGF25lcOowXI6xM31WA5XAXgBsOuXHDk7DOQQQkr
pjoawJg/R64bKjVDk97cXNUqHWysajAgRg0jZZr9EGO0OY1dbwqfdUfY5TUJEHvv
2zJvmgbiSrLeHRA1FwzDDrftTtwjgvEPU59nYhpd5sb0eetf5GK6yARaiI8MpJkA
Ikl7Cpc9A1EzuBKMDnh1j7XLAwgwkru/iLSe3Lh58VpqfblM5ITTtx3buQFDW3FN
zljDgKrOxGuRygEmkZX8vzEBeKtzxGCIFp/OHbJlaZSfus8TPHTEgCh7hYH2JeF+
Ccmdxo/8IGdfw2yP8FONFsSirLc1IAshnuLZszH3wvVd4ZfQ1f+QNK2uMWZTQrAV
DDuYCPrKWGc4FA/IK8vbTo36ndZeKRCIPBXywJAWxO6gLQ+sSV1mG1yNt2CUApRN
ghZu+AIhhA7wsTnlyKxtP4tZk+dj8oY/5LSKGIGJRW+a8YgzCp+89pLEFNXmuk+E
jxjQbWmGBjgOINHbAjevt0lbtjyI1hkJIU9a+17LaHFJdgBhNdJMji/MHw0qZycA
BRDmI9CMPCQ=
=7XsJ
-----END PGP SIGNATURE-----

--=-zGX7g5zuk9rIfinKQi5/--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Paul E. McKenney" <paulmck () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Thu, 10 Apr 2008 22:32:06 +0000
Message-ID: <20080410223206.GI8419 () linux ! vnet ! ibm ! com>
--------------------
On Wed, Apr 09, 2008 at 10:09:46PM +0200, Johannes Berg wrote:
> 
> > It might be.  There are a number of places where it is legal to access
> > RCU-protected pointers directly, and all of these would need to be
> > changed.  For example, in the example above, one could do:
> > 
> > 	foo = NULL;
> 
> Ok, that I understand, but sparse always treats NULL specially anyway.

But "int foo = 0;" would need the memory barrier -- index 0 of some
RCU-protected array.

> > I recently tried to modify rcu_assign_pointer() to issue the memory
> > memory barrier only when the pointer was non-NULL, but this ended badly.
> 
> Hm? I thought that's in the current tree.

It was for a bit.  Build failures in odd (but very real) circumstances.

> > Probably because I am not the greatest gcc expert around...  We ended
> > up having to define an rcu_assign_index() to handle the possibility of
> > assigning a zero-value array index, but my attempts to do type-checking
> > backfired, and I eventually gave it up.  Again, someone a bit more clued
> > in to gcc than I am could probably pull it off.
> 
> Ah, ok.
> 
> > In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer()
> > when holding the update-side lock.
> 
> That I don't understand. Well, I do understand that omitting
> rcu_dereference() is ok, but it seems to me that the memory and compiler
> barrier in rcu_assign_pointer() is actually needed.

You are right -- I was confused.  The case where you can omit the
rcu_assign_pointer() would be when building a multiple-element data
structure that is then published as a unit.  For example:

	p = kmalloc(sizeof(*p), GFP_KERNEL);
	q = kmalloc(sizeof(*p), GFP_KERNEL);
	p->next = q; /* don't need rcu_assign_pointer() here. */
	q->next = NULL;  /* or here. */
	/* initialize other fields of p and q. */
	rcu_assign_pointer(global_pointer, p);

The assignment to p->next doesn't have to be rcu_assign_pointer() because
other CPUs are unable to access the data structure -- only the final
assignment that publishes the whole group need be rcu_assign_pointer().
On the other hand, the cost of the extra memory barrier would be
insignificant in most cases.

> I've been playing a bit, see below for my play rcupdate.h and test.c
> test program.
> 
> Unfortunately, sparse doesn't have the ability to declare
> "ï»¿__attribute__((force_bitwise)) typeof(p)" or even
> "ï»¿__attribute__((force)) typeof(p)" which makes this force more than
> necessary and causes it to not catch when incompatible pointers are
> used. gcc notices that because I only do a cast at all for sparse, but
> that doesn't help, since e.g. list_for_each_entry_rcu() requires that
> the correct type is returned. So without sparse supporting the latter
> notation, we don't stand a chance.

"<feff>"???

> Also, I wouldn't know how to declare that an array or so needs
> rcu-access to the members.

Hmmm...  Can you apply the address-space attribute to the array itself?
I suppose one could convert the array to a pointer, but yecch!

						Thanx, Paul

> johannes
> 
> 
> rcupdate.h:
> 
> #define USE_BITWISE
> 
> #ifdef __CHECKER__
> #ifdef USE_BITWISE
> #define __rcu __attribute__((bitwise))
> #define __force_rcu_cast(p) (*((__attribute__((force)) void **)&(p)))
> // would like instead:
> //#define __force_rcu_cast(p) ((__attribute__((force_bitwise)) typeof(p)) (p))
> #else /* not bitwise */
> #define __rcu __attribute__((address_space(3)))
> #define __force_rcu_cast(p) (*((__attribute__((force)) void **)&(p)))
> // would like instead:
> //#define __force_rcu_cast(p) ((__attribute__((force_address_space)) typeof(p)) (p))
> #endif
> 
> #else /* not checker */
> #define __rcu
> #define __force_rcu_cast(p) (p)
> #endif
> 
> #define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
> 
> #define rcu_dereference(p)     ({ \
> 				typeof(p) _________p1 = ACCESS_ONCE(p); \
> 				smp_read_barrier_depends(); \
> 				__force_rcu_cast(_________p1); \
> 				})
> 
> /**
>  * rcu_fetch - fetch an RCU-protected pointer in the update-locked
>  * critical section.
>  *
>  * This macro exists for documentation and code checking purposes.
>  */
> #define rcu_fetch(p)     __force_rcu_cast(p);
> 
> #define rcu_assign_pointer(p, v) \
> 	({ \
> 		if (!__builtin_constant_p(v) || \
> 		    ((v) != NULL)) \
> 			smp_wmb(); \
> 		__force_rcu_cast(p) = (v); \
> 	})
> 
> 
> test.c:
> 
> #include <stdlib.h>
> #include "rcupdate.h"
> 
> /* my rcu protected variables */
> static unsigned int __rcu *prot;
> static unsigned int __rcu *prot_same;
> static unsigned char __rcu *prot2;
> 
> // dummies
> static smp_read_barrier_depends(void) {}
> static smp_wmb(void) {}
> 
> int main(void)
> {
> 	unsigned int *tmp;
> 
> 	// no warnings from sparse due to forced cast
> 	rcu_assign_pointer(prot, tmp);
> 	// but gcc warns
> 	rcu_assign_pointer(prot2, tmp);
> 
> 	// no warnings
> 	rcu_assign_pointer(prot, NULL);
> 	rcu_assign_pointer(prot2, NULL);
> 
> 	// no warnings
> 	prot = NULL;
> 	prot2 = NULL;
> 
> 	// no warnings from sparse due to forced cast
> 	tmp = rcu_dereference(prot);
> 	// but gcc warns
> 	tmp = rcu_dereference(prot2);
> 
> 	/* now within locked section rcu_dereference isn't required */
> 
> 	// no warnings from sparse due to forced cast
> 	tmp = rcu_fetch(prot);
> 	// but gcc warns
> 	tmp = rcu_fetch(prot2);
> 
> 	/* not caught with address_space, but is caught with bitwise */
> 	prot = prot_same;
> }
> 


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-kernel
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Fri, 11 Apr 2008 18:18:42 +0000
Message-ID: <1207937922.7524.17.camel () twins>
--------------------
On Tue, 2008-04-08 at 08:52 -0700, Paul E. McKenney wrote:
> On Tue, Apr 08, 2008 at 12:04:16AM +0200, Johannes Berg wrote:
> > Hi,
> > 
> > Just a thought, I haven't tried this yet because I'm not entirely sure
> > it's actually correct. I was just thinking it should be possible to
> > introduce something like
> > 
> > 	#define __rcu	__attribute__((address_space(3)))
> > 
> > (for sparse only, of course) and then be able to say
> > 
> > 	struct myfoo *foo __rcu;
> > 
> > and sparse would warn on
> > 
> > 	struct myfoo *bar = foo;
> > 
> > but not on
> > 
> > 	struct myfoo *bar = rcu_dereference(foo);
> 
> Ah, "address_space" is a sparse-ism, no wonder I couldn't find it in
> the gcc docs...
> 
> So the address_space attribute says what the pointer points to rather
> than where the pointer resides, correct?
> 
> > by way of using __force inside rcu_dereference(), rcu_assign_pointer()
> > etc.
> > 
> > Would this be feasible? Or should one actually use __bitwise/__force to
> > also get the warning when assigning between two variables both marked
> > __rcu?
> 
> It might be.  There are a number of places where it is legal to access
> RCU-protected pointers directly, and all of these would need to be
> changed.  For example, in the example above, one could do:
> 
> 	foo = NULL;
> 
> I recently tried to modify rcu_assign_pointer() to issue the memory
> memory barrier only when the pointer was non-NULL, but this ended badly.
> Probably because I am not the greatest gcc expert around...  We ended
> up having to define an rcu_assign_index() to handle the possibility of
> assigning a zero-value array index, but my attempts to do type-checking
> backfired, and I eventually gave it up.  Again, someone a bit more clued
> in to gcc than I am could probably pull it off.
> 
> In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer()
> when holding the update-side lock.

We could start by annotating those as well, for example:

 __rcu spinlock_t tree_lock;

Then we would know that when tree lock is held the data structure is
stable and we can ommit the rcu_*() functions.

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-sparse
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Fri, 11 Apr 2008 18:18:42 +0000
Message-ID: <1207937922.7524.17.camel () twins>
--------------------
On Tue, 2008-04-08 at 08:52 -0700, Paul E. McKenney wrote:
> On Tue, Apr 08, 2008 at 12:04:16AM +0200, Johannes Berg wrote:
> > Hi,
> > 
> > Just a thought, I haven't tried this yet because I'm not entirely sure
> > it's actually correct. I was just thinking it should be possible to
> > introduce something like
> > 
> > 	#define __rcu	__attribute__((address_space(3)))
> > 
> > (for sparse only, of course) and then be able to say
> > 
> > 	struct myfoo *foo __rcu;
> > 
> > and sparse would warn on
> > 
> > 	struct myfoo *bar = foo;
> > 
> > but not on
> > 
> > 	struct myfoo *bar = rcu_dereference(foo);
> 
> Ah, "address_space" is a sparse-ism, no wonder I couldn't find it in
> the gcc docs...
> 
> So the address_space attribute says what the pointer points to rather
> than where the pointer resides, correct?
> 
> > by way of using __force inside rcu_dereference(), rcu_assign_pointer()
> > etc.
> > 
> > Would this be feasible? Or should one actually use __bitwise/__force to
> > also get the warning when assigning between two variables both marked
> > __rcu?
> 
> It might be.  There are a number of places where it is legal to access
> RCU-protected pointers directly, and all of these would need to be
> changed.  For example, in the example above, one could do:
> 
> 	foo = NULL;
> 
> I recently tried to modify rcu_assign_pointer() to issue the memory
> memory barrier only when the pointer was non-NULL, but this ended badly.
> Probably because I am not the greatest gcc expert around...  We ended
> up having to define an rcu_assign_index() to handle the possibility of
> assigning a zero-value array index, but my attempts to do type-checking
> backfired, and I eventually gave it up.  Again, someone a bit more clued
> in to gcc than I am could probably pull it off.
> 
> In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer()
> when holding the update-side lock.

We could start by annotating those as well, for example:

 __rcu spinlock_t tree_lock;

Then we would know that when tree lock is held the data structure is
stable and we can ommit the rcu_*() functions.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Paul E. McKenney" <paulmck () linux ! vnet ! ibm ! com>
To: linux-kernel
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Fri, 11 Apr 2008 18:43:27 +0000
Message-ID: <20080411184327.GD29878 () linux ! vnet ! ibm ! com>
--------------------
On Fri, Apr 11, 2008 at 08:18:42PM +0200, Peter Zijlstra wrote:
> On Tue, 2008-04-08 at 08:52 -0700, Paul E. McKenney wrote:
> > On Tue, Apr 08, 2008 at 12:04:16AM +0200, Johannes Berg wrote:
> > > Hi,
> > > 
> > > Just a thought, I haven't tried this yet because I'm not entirely sure
> > > it's actually correct. I was just thinking it should be possible to
> > > introduce something like
> > > 
> > > 	#define __rcu	__attribute__((address_space(3)))
> > > 
> > > (for sparse only, of course) and then be able to say
> > > 
> > > 	struct myfoo *foo __rcu;
> > > 
> > > and sparse would warn on
> > > 
> > > 	struct myfoo *bar = foo;
> > > 
> > > but not on
> > > 
> > > 	struct myfoo *bar = rcu_dereference(foo);
> > 
> > Ah, "address_space" is a sparse-ism, no wonder I couldn't find it in
> > the gcc docs...
> > 
> > So the address_space attribute says what the pointer points to rather
> > than where the pointer resides, correct?
> > 
> > > by way of using __force inside rcu_dereference(), rcu_assign_pointer()
> > > etc.
> > > 
> > > Would this be feasible? Or should one actually use __bitwise/__force to
> > > also get the warning when assigning between two variables both marked
> > > __rcu?
> > 
> > It might be.  There are a number of places where it is legal to access
> > RCU-protected pointers directly, and all of these would need to be
> > changed.  For example, in the example above, one could do:
> > 
> > 	foo = NULL;
> > 
> > I recently tried to modify rcu_assign_pointer() to issue the memory
> > memory barrier only when the pointer was non-NULL, but this ended badly.
> > Probably because I am not the greatest gcc expert around...  We ended
> > up having to define an rcu_assign_index() to handle the possibility of
> > assigning a zero-value array index, but my attempts to do type-checking
> > backfired, and I eventually gave it up.  Again, someone a bit more clued
> > in to gcc than I am could probably pull it off.
> > 
> > In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer()
> > when holding the update-side lock.
> 
> We could start by annotating those as well, for example:
> 
>  __rcu spinlock_t tree_lock;
> 
> Then we would know that when tree lock is held the data structure is
> stable and we can ommit the rcu_*() functions.

Good point!  Though IIRC there are are cases where we are updating
one RCU-protected data structure while in an RCU read-side critical
section with respect to another RCU-protected data structure.

But it would probably best to start as you say rather than trying
to classify different RCU uses.  :-)

						Thanx, Paul
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "Paul E. McKenney" <paulmck () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Fri, 11 Apr 2008 18:43:27 +0000
Message-ID: <20080411184327.GD29878 () linux ! vnet ! ibm ! com>
--------------------
On Fri, Apr 11, 2008 at 08:18:42PM +0200, Peter Zijlstra wrote:
> On Tue, 2008-04-08 at 08:52 -0700, Paul E. McKenney wrote:
> > On Tue, Apr 08, 2008 at 12:04:16AM +0200, Johannes Berg wrote:
> > > Hi,
> > > 
> > > Just a thought, I haven't tried this yet because I'm not entirely sure
> > > it's actually correct. I was just thinking it should be possible to
> > > introduce something like
> > > 
> > > 	#define __rcu	__attribute__((address_space(3)))
> > > 
> > > (for sparse only, of course) and then be able to say
> > > 
> > > 	struct myfoo *foo __rcu;
> > > 
> > > and sparse would warn on
> > > 
> > > 	struct myfoo *bar = foo;
> > > 
> > > but not on
> > > 
> > > 	struct myfoo *bar = rcu_dereference(foo);
> > 
> > Ah, "address_space" is a sparse-ism, no wonder I couldn't find it in
> > the gcc docs...
> > 
> > So the address_space attribute says what the pointer points to rather
> > than where the pointer resides, correct?
> > 
> > > by way of using __force inside rcu_dereference(), rcu_assign_pointer()
> > > etc.
> > > 
> > > Would this be feasible? Or should one actually use __bitwise/__force to
> > > also get the warning when assigning between two variables both marked
> > > __rcu?
> > 
> > It might be.  There are a number of places where it is legal to access
> > RCU-protected pointers directly, and all of these would need to be
> > changed.  For example, in the example above, one could do:
> > 
> > 	foo = NULL;
> > 
> > I recently tried to modify rcu_assign_pointer() to issue the memory
> > memory barrier only when the pointer was non-NULL, but this ended badly.
> > Probably because I am not the greatest gcc expert around...  We ended
> > up having to define an rcu_assign_index() to handle the possibility of
> > assigning a zero-value array index, but my attempts to do type-checking
> > backfired, and I eventually gave it up.  Again, someone a bit more clued
> > in to gcc than I am could probably pull it off.
> > 
> > In addition, it is legal to omit rcu_dereference() and rcu_assign_pointer()
> > when holding the update-side lock.
> 
> We could start by annotating those as well, for example:
> 
>  __rcu spinlock_t tree_lock;
> 
> Then we would know that when tree lock is held the data structure is
> stable and we can ommit the rcu_*() functions.

Good point!  Though IIRC there are are cases where we are updating
one RCU-protected data structure while in an RCU read-side critical
section with respect to another RCU-protected data structure.

But it would probably best to start as you say rather than trying
to classify different RCU uses.  :-)

						Thanx, Paul
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Using sparse to catch invalid RCU dereferences?
Date: Fri, 11 Apr 2008 20:54:03 +0000
Message-ID: <1207947243.13354.88.camel () johannes ! berg>
--------------------

--=-oHNW+EEBViP18jY3fdR7
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable

On Thu, 2008-04-10 at 15:32 -0700, Paul E. McKenney wrote:
> On Wed, Apr 09, 2008 at 10:09:46PM +0200, Johannes Berg wrote:
> >=20
> > > It might be.  There are a number of places where it is legal to acces=
s
> > > RCU-protected pointers directly, and all of these would need to be
> > > changed.  For example, in the example above, one could do:
> > >=20
> > > 	foo =3D NULL;
> >=20
> > Ok, that I understand, but sparse always treats NULL specially anyway.
>=20
> But "int foo =3D 0;" would need the memory barrier -- index 0 of some
> RCU-protected array.

Oh. Hmm, I guess that wouldn't really be possible to find at least not
with sparse right now. Though maybe we can add some sort of annotation
that that special type can't even take zero directly.

> You are right -- I was confused.  The case where you can omit the
> rcu_assign_pointer() would be when building a multiple-element data
> structure that is then published as a unit.  For example:
>=20
> 	p =3D kmalloc(sizeof(*p), GFP_KERNEL);
> 	q =3D kmalloc(sizeof(*p), GFP_KERNEL);
> 	p->next =3D q; /* don't need rcu_assign_pointer() here. */
> 	q->next =3D NULL;  /* or here. */
> 	/* initialize other fields of p and q. */
> 	rcu_assign_pointer(global_pointer, p);
>=20
> The assignment to p->next doesn't have to be rcu_assign_pointer() because
> other CPUs are unable to access the data structure -- only the final
> assignment that publishes the whole group need be rcu_assign_pointer().
> On the other hand, the cost of the extra memory barrier would be
> insignificant in most cases.

Ah. Yeah, but we probably need a "raw" accessor anyway if we're going to
go this route, e.g. for any deref within the update-locked section.

> > I've been playing a bit, see below for my play rcupdate.h and test.c
> > test program.
> >=20
> > Unfortunately, sparse doesn't have the ability to declare
> > "=EF=BB=BF__attribute__((force_bitwise)) typeof(p)" or even
> > "=EF=BB=BF__attribute__((force)) typeof(p)" which makes this force more=
 than
> > necessary and causes it to not catch when incompatible pointers are
> > used. gcc notices that because I only do a cast at all for sparse, but
> > that doesn't help, since e.g. list_for_each_entry_rcu() requires that
> > the correct type is returned. So without sparse supporting the latter
> > notation, we don't stand a chance.
>=20
> "<feff>"???

Hmm?

> > Also, I wouldn't know how to declare that an array or so needs
> > rcu-access to the members.
>=20
> Hmmm...  Can you apply the address-space attribute to the array itself?
> I suppose one could convert the array to a pointer, but yecch!

Not sure if applying that to an array would work, and I wouldn't want to
convert it to pointers either. But I suppose you could declare the array
like this:

static struct foo * __attribute__((bitwise or address_space)) array[7];

which should, as far as I understand, apply the attribute to the array
members instead of the array.

johannes

--=-oHNW+EEBViP18jY3fdR7
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR//P6qVg1VMiehFYAQKomg/+LN9vLLI/V7DInn7pjY0liLFMEyvRuezR
dK16VBvG8r0iGVWWl7+UM92EcXWJ5HCOJVXzEUTCj0S1+wMCV8l5b7qMss5FguMX
qPXhVl/PvkD8WHZpRn+OSBsSmuIZ85bFnXr8cPeM8bwMJCp/94Ysk45Rg5dpuL7a
iWM4nh4kUdRBb2LUEorSw/ZuuCPUdvTw/XQHNikymQcN6Kw1fK9UxcTQRnwLV58b
LzmeRfcP+jLJ7kbuJcC7j99IFoT3WVKd6sYTJk5usOafLKK+Iylm8fqlIF17XyYK
OeKjAGgrFj5hr6fWTszcSFfPwX09pWY8GZr76ML0z6QUsF4Ne1nMimfd2GXaayR6
0muoyENiikxnHZ6MWuKEI9kyDPoI6/TGe65vtP3GzIPxeJsitFz1KUl4Xza498VU
0qxCbG5Z+d2YuO8u1LUe2HNCzzcMwFTbNOyh3aacKxJhRkdirLStbPmkPMtXd0Tp
gCF4r+ekHSKnUCWxQL/A12nPOO6mnUHiK4kNaCPmJTh857JabcqdMncsad9cclY1
eStrXSVUiAmKwOQ4TCITBb4ZnCMYJN8Y5RgDKt9Wo2vHkDFeT6oMWA7UZuvrzPaY
PyIM6H32otF3HEncC1EoFDiDcv5fEyI16p9hazydnrwUPaCpsAzR+j5+pfr8Sk6i
x1j+sGnX5Y4=
=RMWK
-----END PGP SIGNATURE-----

--=-oHNW+EEBViP18jY3fdR7--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Writing compilers, and example.c vs compile-i386.c ===

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Writing compilers, and example.c vs compile-i386.c
Date: Mon, 16 Jun 2008 23:04:54 +0000
Message-ID: <4856F196.8020403 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigA1132B1390733F5A572B3A60
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I'm wanting to write a compiler-like tool that's capable of generating
machine-code-like-stuff (don't ask, long story), and as such, have been
looking around for C compiler front ends that will make my life easier.
sparse looks extremely promising.

As such, I've been examining the two sample compilers, example.c and
compile-i386.c. These appear to generate i386-ish machine code, but do
so in entirely different ways. If I've understood them correctly,
example.c enumerates the instructions inside each function's basic
blocks, and uses sparse's pseudo_t support for doing register
allocation; while compile-i386.c enumerates the statements inside each
function, and does it's own register allocation.

Some basic testing with show_statement() and show_insn() reveals that
both approaches seem to yield similar but *different* pseudocode... with
different SSA phi functions. What's the difference between the two, and
do you have any suggestions as to which approach I should look at?

In addition, I'm afraid I'm going to have to use the D word... has
anyone written down anything about how all this stuff works? I'm afraid
it's rather a large mass of code to try and absorb in one go, and any
overview information would help me considerably. For example: if I put
together a noddy program that enumerates basic blocks (the example.c
approach) I see phi functions. Calling unssa() doesn't seem to help.
However, inserting instrumentation into example.c indicates that it
*doesn't* see phi functions (as far as I can tell). There's something
I'm simply not getting here --- does the removal of phis actually happen
inside the register allocator (which seems like the intuitive place for
it), and if so, what does unssa() actually do?

This is all with sparse 0.4.1. Is that current?

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82 "I have always wished for my computer to be as easy to use as m=
y
=E2=94=82 telephone; my wish has come true because I can no longer figure=
 out
=E2=94=82 how to use my telephone." --- Bjarne Stroustrup


--------------enigA1132B1390733F5A572B3A60
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIVvGWf9E0noFvlzgRAguyAJ4iGy1QtcPfoIyK0m4BeQZ/wSoeyQCfY+KY
XVyoQsSYh2mSBi7513YR8ss=
=h42t
-----END PGP SIGNATURE-----

--------------enigA1132B1390733F5A572B3A60--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mike Frysinger" <vapier.adi () gmail ! com>
To: linux-sparse
Subject: Re: Writing compilers, and example.c vs compile-i386.c
Date: Mon, 16 Jun 2008 23:50:54 +0000
Message-ID: <8bd0f97a0806161650w1d88f0d5k33601d66f3d3084 () mail ! gmail ! com>
--------------------
On Mon, Jun 16, 2008 at 7:04 PM, David Given wrote:
> I'm wanting to write a compiler-like tool that's capable of generating
> machine-code-like-stuff (don't ask, long story), and as such, have been
> looking around for C compiler front ends that will make my life easier.
> sparse looks extremely promising.

this may be worth investigating as well:
http://pcc.ludd.ltu.se/
-mike
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Writing compilers, and example.c vs compile-i386.c
Date: Tue, 17 Jun 2008 00:49:24 +0000
Message-ID: <70318cbf0806161749u543fa338sf43a2ab787297eaa () mail ! gmail ! com>
--------------------
On Mon, Jun 16, 2008 at 4:04 PM, David Given <dg@cowlark.com> wrote:
> Some basic testing with show_statement() and show_insn() reveals that
> both approaches seem to yield similar but *different* pseudocode... with
> different SSA phi functions. What's the difference between the two, and
> do you have any suggestions as to which approach I should look at?

I would strongly recommend using the example.c rather than compile-i386.c.
If you want to do any thing interesting with the back end at all, using
the linearize byte code is the way to go.

> In addition, I'm afraid I'm going to have to use the D word... has
> anyone written down anything about how all this stuff works? I'm afraid
> it's rather a large mass of code to try and absorb in one go, and any
> overview information would help me considerably. For example: if I put
> together a noddy program that enumerates basic blocks (the example.c
> approach) I see phi functions. Calling unssa() doesn't seem to help.
> However, inserting instrumentation into example.c indicates that it
> *doesn't* see phi functions (as far as I can tell). There's something
> I'm simply not getting here --- does the removal of phis actually happen
> inside the register allocator (which seems like the intuitive place for
> it), and if so, what does unssa() actually do?

I haven't use the unssa() myself. It seems unssa() just replace the
phisrc instruction to a copy instruction. Let the source copy to a
temp register. Then on phi instruction it just copy that temp register
back to the phi node register.

The phi node is replaces with copy instruction inside unssa().
In the real machine code, the copy instruction can emit as "mov"
instruction.

As for linearize instructions. They are the internal representation
of the compiled program. In this representation, there is unlimited
pseudo register. Each pseudo is define in only one instruction. except
"OP_COPY" in the unssa().

Each function entry point has a list of basic blocks and each basic block
has a list of instructions. Most instruction is pretty straight for what
it does.

BTW, if you don't mind coding in C++, you can take a look at LLVM.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Re: Writing compilers, and example.c vs compile-i386.c
Date: Tue, 17 Jun 2008 23:35:15 +0000
Message-ID: <48584A33.7080602 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig5D0C2A86F796072433AC381B
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Mike Frysinger wrote:
> this may be worth investigating as well:
> http://pcc.ludd.ltu.se/

That was actually where I started; it works pretty well, though after a
couple of hours of examining the code I realised that there was a good
reason why it looked like code that had been written 25 years ago and
then randomly hacked ever since. It's a little opaque, which is why I
ended up here.

Christopher Li wrote:
[...]
> I would strongly recommend using the example.c rather than compile-i386=
=2Ec.
> If you want to do any thing interesting with the back end at all, using=

> the linearize byte code is the way to go.

Yes, that's what I suspected --- being the more complicated file! Oh,
well, I've been examining it, and it's slow beginning to make sense.

However: I notice that the code seems to make use of OP_DEATHNOTE
instructions to mark hardregs as being dead. However, these are only
generated if track_pseudo_death(ep) is called --- and example.c never
calls this. It *is*, however, called if -vdead is specified on the
command line. Is this a bug in example.c or am I just misunderstanding
things?

(Also, the OP_DEATHNOTE instructions appear to occur *before* the
instruction that uses them last --- is this so that the instruction can
reuse the register is the code generator sees fit to do so?)

(In addition, I notice that once liveness tracking has been done phisrc
nodes get annotated with the desired shared register that the phi should
occupy; suddenly, the phi stuff all makes sense.)



(PS. Please don't cc me if you're also mailing the list --- I only need
one copy!)

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82 "I have always wished for my computer to be as easy to use as m=
y
=E2=94=82 telephone; my wish has come true because I can no longer figure=
 out
=E2=94=82 how to use my telephone." --- Bjarne Stroustrup


--------------enig5D0C2A86F796072433AC381B
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIWEo1f9E0noFvlzgRAi5ZAKCr1QyY71KAZiEf7TaR82tKyVt+YwCgt7Cu
s2/QORrMkFdwOry3vX3AGEc=
=kufV
-----END PGP SIGNATURE-----

--------------enig5D0C2A86F796072433AC381B--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Writing compilers, and example.c vs compile-i386.c
Date: Wed, 18 Jun 2008 00:41:40 +0000
Message-ID: <70318cbf0806171741g4d099e92vf0c0e9d7588fd7d6 () mail ! gmail ! com>
--------------------
On Tue, Jun 17, 2008 at 4:35 PM, David Given <dg@cowlark.com> wrote:

> Christopher Li wrote:
> However: I notice that the code seems to make use of OP_DEATHNOTE
> instructions to mark hardregs as being dead. However, these are only
> generated if track_pseudo_death(ep) is called --- and example.c never
> calls this. It *is*, however, called if -vdead is specified on the
> command line. Is this a bug in example.c or am I just misunderstanding
> things?

You understands it correctly. The example.c should call track_pseudo_death(ep).
It is a bug that I disable the dead node by default and forget to enable it for
example.c. For normal checking, death node is not needed, and if it is needed,
you can always generates it.

We should add the death node back for example.c. Patches are welcome
as well.

BTW, you shouldn't take example.c too seriously per Linus' suggestion.

> (Also, the OP_DEATHNOTE instructions appear to occur *before* the
> instruction that uses them last --- is this so that the instruction can
> reuse the register is the code generator sees fit to do so?)

I think so, it just let the code generator know that they don't need to preserve
that register any more for the next instruction they emit. It is a very naive
register allocations any way. Feel free to roll your own if you see fits.

> (In addition, I notice that once liveness tracking has been done phisrc
> nodes get annotated with the desired shared register that the phi should
> occupy; suddenly, the phi stuff all makes sense.)

Glad to hear that.


> (PS. Please don't cc me if you're also mailing the list --- I only need
> one copy!)

You mean your email client is not smart enough to realize that is the
same email :-)  I prefer to get CC directly to get a sense of being part of
the discussion. My email will filter differently if I am directly addressed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Writing compilers, and example.c vs compile-i386.c
Date: Sat, 21 Jun 2008 01:40:14 +0000
Message-ID: <70318cbf0806201840k18a51f94rcaa413b36fcfbbea () mail ! gmail ! com>
--------------------
On Fri, Jun 20, 2008 at 4:46 PM, David Given <dg@cowlark.com> wrote:
> - how do you determine the scalar type of a pseudo?

Depend on the pseudo type. If pseudo from a symbol,
pseudo->sym->ctype has the full type information.

If pseudo is from constant expression, pseduo->def->val
is the constant expression. using expr->ctype to get to the ctype.

If pseudo is from normal instruction result, the target type is
the same as any source type. The special case the OP_CAST
instruction, the type is in insn->cast_type.

I agree we should probability make the ctype into instruction so
make the back end easier.

> - if I wish to rewrite a basic block's instruction list --- for example,
> to decompose instructions that use a non-register pseudo into two
> instructions --- do I need to do anything other than iterate through the
> bb's list and insert instruction nodes? Is there any additional
> housekeeping to do? Naturally, I'd do this *before* calling
> track_pseudo_death()...

If you modify instructions in a existing instruction list. Make sure you
keep the pseudo in SSA form, including proper user list.

If you add basic block, you need to update the parent and child list.

> - what does expand_symbol() do?

Well, it expand symbols. That does help does it?

Sparse parsing have a few stage.

The tokenizer parse the source code and convert it into token list.

Pre-process stage expand the macro and handle include files etc.

Parsing stage consume the token list and parse into AST tree.

Evaluate stage does the type propagation, pointer degenerate etc.

Expand stage is mostly for some fix up. E.g. remove obvious dead code
like "#if 0".
The inline function get expanded in this stage.

Hope that helps.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [1/2] find ptr in a list ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: [1/2] find ptr in a list
Date: Thu, 04 Sep 2008 05:34:29 +0000
Message-ID: <70318cbf0809032234y3dbc6968kde3dbfef0af8108f () mail ! gmail ! com>
--------------------
------=_Part_66860_29874675.1220506469168
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Signed-Off-By: Christopher Li <sparse@chrisli.org>

------=_Part_66860_29874675.1220506469168
Content-Type: application/octet-stream; name=find-ptr-in-list
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fkohh0s40
Content-Disposition: attachment; filename=find-ptr-in-list

QWRkaW5nIHNvbWUgaGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgYSBwb2ludGVyIGluIHRoZSBwdHJs
aXN0LgoKSW5kZXg6IHNwYXJzZS9wdHJsaXN0LmgKPT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3BhcnNlLm9yaWcv
cHRybGlzdC5oCisrKyBzcGFyc2UvcHRybGlzdC5oCkBAIC00NSw2ICs0NSw4IEBAIGV4dGVybiB2
b2lkIGNvbmNhdF9wdHJfbGlzdChzdHJ1Y3QgcHRyX2wKIGV4dGVybiB2b2lkIF9fZnJlZV9wdHJf
bGlzdChzdHJ1Y3QgcHRyX2xpc3QgKiopOwogZXh0ZXJuIGludCBwdHJfbGlzdF9zaXplKHN0cnVj
dCBwdHJfbGlzdCAqKTsKIGV4dGVybiBpbnQgbGluZWFyaXplX3B0cl9saXN0KHN0cnVjdCBwdHJf
bGlzdCAqLCB2b2lkICoqLCBpbnQpOworZXh0ZXJuIGludCBmaW5kX3B0cl9pbl9saXN0KHN0cnVj
dCBwdHJfbGlzdCogbGlzdCwgdm9pZCAqcHRyKTsKK2V4dGVybiBpbnQgZmluZF9wdHJfaW5kZXgo
c3RydWN0IHB0cl9saXN0KiBsaXN0LCB2b2lkICpwdHIpOwogCiAvKgogICogSGV5LCB3aG8gc2Fp
ZCB0aGF0IHlvdSBjYW4ndCBkbyBvdmVybG9hZGluZyBpbiBDPwpJbmRleDogc3BhcnNlL3B0cmxp
c3QuYwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09Ci0tLSBzcGFyc2Uub3JpZy9wdHJsaXN0LmMKKysrIHNwYXJzZS9wdHJs
aXN0LmMKQEAgLTI0NiwzICsyNDYsMjkgQEAgdm9pZCBfX2ZyZWVfcHRyX2xpc3Qoc3RydWN0IHB0
cl9saXN0ICoqbAogCiAJKmxpc3RwID0gTlVMTDsKIH0KKworaW50IGZpbmRfcHRyX2luX2xpc3Qo
c3RydWN0IHB0cl9saXN0KiBsaXN0LCB2b2lkICpwdHIpCit7CisJdm9pZCAqcDsKKwlGT1JfRUFD
SF9QVFIobGlzdCwgcCkgeworCQlpZiAocCA9PSBwdHIpCisJCQlyZXR1cm4gMTsKKwl9IEVORF9G
T1JfRUFDSF9QVFIocCk7CisJcmV0dXJuIDA7Cit9CisKK2ludCBmaW5kX3B0cl9pbmRleChzdHJ1
Y3QgcHRyX2xpc3QqIGxpc3QsIHZvaWQgKnB0cikKK3sKKwl2b2lkICpwOworCWludCBpID0gMDsK
KwlGT1JfRUFDSF9QVFIobGlzdCwgcCkgeworCQlpZiAocCA9PSBwdHIpCisJCQlyZXR1cm4gaTsK
KwkJaSsrOworCX0gRU5EX0ZPUl9FQUNIX1BUUihwKTsKKwlyZXR1cm4gLTE7Cit9CisKKworCisK

------=_Part_66860_29874675.1220506469168--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [2/2] The sparse byte code writer. ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: [2/2] The sparse byte code writer.
Date: Thu, 04 Sep 2008 05:34:39 +0000
Message-ID: <70318cbf0809032234v4bb0f526r155a390344db77d9 () mail ! gmail ! com>
--------------------
------=_Part_66870_7724490.1220506479546
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

To test the writer:

$ ./test-write linearize.c
export syms 29 internal 72 import 47
struct instruction * size 349524
struct entrypoint * size 2280
struct basic_block * size 39248
pseudo_t size 118632
struct pseudo_user * size 0
struct asm_constraint * size 0
struct symbol * size 358608
struct asm_rules * size 0
struct multijmp * size 1344
struct expression * size 4064
struct ident * size 12596
struct string * size 0
char * size 0
char * (stream) size 191
struct ptr_list * size 114948
toalsize 995359

It generate linearize.b file.

Some internal detail:

traverse.c is responsible for traverse the pointer in an object.
It don't actually convert the pointer. It delegates the actual convertion
to the caller. The reader and writer can share the same traverse
code to convert the pointer to index, index back to pointer.

The writer use a two pass stage to write the object file.
The first pass is finding out which object need to write out to
the file. It register them into the hash table for later look up.
It add a shadow copy of the object with all the pointer inside the
object converted into index.

This is a recursive process until all the object under dependency
has been registered.

The second stage is the actual dumping of the registered file.

Compare to the one step convert and dump approach (been there
done that). The two step write back generate very nice sequential
disk IO. It is also much easier to work with. We can optionally
apply some compression method before we write it to the disk.
It can save the object file size. Currently it is the raw C structure.

Known limits:
- static string is not saved yet. The linearizer skip the initialization
  part of the storage type symbol. We should consider generate
  some initialization node for lay out the static C structure initializer.

- I think the linearized instruction does not have the full C type information
  yet.

- A few more I can't remember right now.
- Reader is half baked. Not included in this patch series. Too ugly to show
  on the list. Drop me a line and I can send you what I got. I will be very
  glad if some one want to adopt this...

Comments are welcome.

Chris

Signed-Off-By: Christopher Li <sparse@chrisli.org>

------=_Part_66870_7724490.1220506479546
Content-Type: application/octet-stream; name=writer-5
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fkohn83u0
Content-Disposition: attachment; filename=writer-5

CgpJbmRleDogc3BhcnNlL3RyYXZlcnNlLmMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3BhcnNlLm9yaWcvdHJh
dmVyc2UuYworKysgc3BhcnNlL3RyYXZlcnNlLmMKQEAgLTAsMCArMSwzMDcgQEAKKy8qCisgKiB0
cmF2ZXJzZS5jCisgKgorICogS2VlcCB0cmFjayBvZiBwb2ludGVycyBpbnNpZGUgdGhlIG9iamVj
dHMuIEl0IGNhbiBiZQorICogc2hhcmVkIGJ5IHJlYWRlciBhbmQgd3JpdGVyLgorICoKKyAqIENv
cHlyaWdodCAoQykgMjAwOCBDaHJpc3RvcGhlciBMaS4KKyAqCisgKiBMaWNlbnNlZCB1bmRlciB0
aGUgT3BlbiBTb2Z0d2FyZSBMaWNlbnNlIHZlcnNpb24gMS4xCisgKi8KKworCisjaW5jbHVkZSA8
c3RkaW8uaD4KKyNpbmNsdWRlIDxzdGRsaWIuaD4KKworI2luY2x1ZGUgImFsbG9jYXRlLmgiCisj
aW5jbHVkZSAic3ltYm9sLmgiCisjaW5jbHVkZSAiZXhwcmVzc2lvbi5oIgorI2luY2x1ZGUgImxp
bmVhcml6ZS5oIgorI2luY2x1ZGUgInRyYXZlcnNlLmgiCisKK2ludCB0cmF2ZXJzZV9sZXZlbCA9
IDA7CisKK3ZvaWQgaW5saW5lIHRyYXZlcnNlX2VudGVyKHZvaWQpCit7CisJdHJhdmVyc2VfbGV2
ZWwgKys7Cit9CisKK3ZvaWQgaW5saW5lIHRyYXZlcnNlX2V4aXQodm9pZCkKK3sKKwl0cmF2ZXJz
ZV9sZXZlbCAtLTsKK30KKworY29uc3QgY2hhciogb2JqZWN0X3R5cGVuYW1lKGludCB0eXBlKQor
eworCXN0YXRpYyBjb25zdCBjaGFyICpvYmplY3RfbmFtZV90YWJsZVtQVFJfTEFTVF0gPSB7CisJ
CVtQVFJfSU5TTl0gPSAic3RydWN0IGluc3RydWN0aW9uICoiLAorCQlbUFRSX0VOVFJZUE9JTlRd
ID0gInN0cnVjdCBlbnRyeXBvaW50ICoiLAorCQlbUFRSX0JBU0lDQkxPQ0tdID0gInN0cnVjdCBi
YXNpY19ibG9jayAqIiwKKwkJW1BUUl9QU0VVRE9dID0gInBzZXVkb190IiwKKwkJW1BUUl9QU0VV
RE9fVVNFUl0gPSAic3RydWN0IHBzZXVkb191c2VyICoiLAorCQlbUFRSX0FTTV9DT05TVFJBSU5U
XSA9ICJzdHJ1Y3QgYXNtX2NvbnN0cmFpbnQgKiIsCisJCVtQVFJfU1lNQk9MXSA9ICJzdHJ1Y3Qg
c3ltYm9sICoiLAorCQlbUFRSX0FTTV9SVUxFU10gPSAic3RydWN0IGFzbV9ydWxlcyAqIiwKKwkJ
W1BUUl9FWFBSXSA9ICJzdHJ1Y3QgZXhwcmVzc2lvbiAqIiwKKwkJW1BUUl9NVUxUSUpNUF0gPSAi
c3RydWN0IG11bHRpam1wICoiLAorCisJCVtQVFJfSURFTlRdID0gInN0cnVjdCBpZGVudCAqIiwK
KwkJW1BUUl9TVFJJTkddID0gInN0cnVjdCBzdHJpbmcgKiIsCisJCVtQVFJfQ0hBUlNUUklOR10g
PSAiY2hhciAqIiwKKwkJW1BUUl9TVFJFQU1fTkFNRV0gPSAiY2hhciAqIChzdHJlYW0pIiwKKwkJ
W1BUUl9MSVNUXSA9ICJzdHJ1Y3QgcHRyX2xpc3QgKiIsCisJfTsKKwlyZXR1cm4gb2JqZWN0X25h
bWVfdGFibGVbdHlwZV07Cit9CisKKwordm9pZCB0cmF2ZXJzZV9lbnRyeXBvaW50KHN0cnVjdCBj
b252ZXJ0X29wICpvcCwgdm9pZCAqcHRyLCB2b2lkICpkYXRhKQoreworCXN0cnVjdCBlbnRyeXBv
aW50ICplcCA9IChzdHJ1Y3QgZW50cnlwb2ludCopIHB0cjsKKwl0cmF2ZXJzZV9lbnRlcigpOwor
CWNvbnZlcnRfc3ltYm9sKG9wLCAmZXAtPm5hbWUsIGRhdGEpOworCWNvbnZlcnRfc3ltYm9sX2xp
c3Qob3AsICZlcC0+c3ltcywgZGF0YSk7CisJY29udmVydF9wc2V1ZG9fbGlzdChvcCwgJmVwLT5h
Y2Nlc3NlcywgZGF0YSk7CisJY29udmVydF9iYXNpY19ibG9ja19saXN0KG9wLCAmZXAtPmJicywg
ZGF0YSk7CisJY29udmVydF9pbnN0cnVjdGlvbihvcCwgJmVwLT5lbnRyeSwgZGF0YSk7CisJdHJh
dmVyc2VfZXhpdCgpOworfQorCit2b2lkIHRyYXZlcnNlX2Jhc2ljX2Jsb2NrKHN0cnVjdCBjb252
ZXJ0X29wICpvcCwgdm9pZCAqcHRyLCB2b2lkICpkYXRhKQoreworCXN0cnVjdCBiYXNpY19ibG9j
ayAqYmIgPSAoc3RydWN0IGJhc2ljX2Jsb2NrKikgcHRyOworCXRyYXZlcnNlX2VudGVyKCk7CisJ
b3AtPmNvbnZlcnRfcG9zaXRpb24oJmJiLT5wb3MsIGRhdGEpOworCWNvbnZlcnRfZW50cnlwb2lu
dChvcCwgJmJiLT5lcCwgZGF0YSk7CisJY29udmVydF9iYXNpY19ibG9ja19saXN0KG9wLCAmYmIt
PnBhcmVudHMsIGRhdGEpOworCWNvbnZlcnRfYmFzaWNfYmxvY2tfbGlzdChvcCwgJmJiLT5jaGls
ZHJlbiwgZGF0YSk7CisJY29udmVydF9pbnN0cnVjdGlvbl9saXN0KG9wLCAmYmItPmluc25zLCBk
YXRhKTsKKwljb252ZXJ0X3BzZXVkb19saXN0KG9wLCAmYmItPm5lZWRzLCBkYXRhKTsKKwljb252
ZXJ0X3BzZXVkb19saXN0KG9wLCAmYmItPmRlZmluZXMsIGRhdGEpOworCXRyYXZlcnNlX2V4aXQo
KTsKK30KKwordm9pZCB0cmF2ZXJzZV9wc2V1ZG8oc3RydWN0IGNvbnZlcnRfb3AgKm9wLCB2b2lk
ICpwdHIsIHZvaWQgKmRhdGEpCit7CisJcHNldWRvX3QgcHNldWRvID0gKHBzZXVkb190KSBwdHI7
CisJdHJhdmVyc2VfZW50ZXIoKTsKKwlzd2l0Y2gocHNldWRvLT50eXBlKSB7CisJY2FzZSBQU0VV
RE9fU1lNOgorCQljb252ZXJ0X3N5bWJvbChvcCwgJnBzZXVkby0+c3ltLCBkYXRhKTsKKwkJYnJl
YWs7CisJY2FzZSBQU0VVRE9fUkVHOgorCWNhc2UgUFNFVURPX1BISToKKwkJb3AtPmNvbnZlcnRf
aWRlbnQoJnBzZXVkby0+aWRlbnQsIGRhdGEpOworCQlicmVhazsKKwlkZWZhdWx0OgorCQlicmVh
azsKKwl9CisJdHJhdmVyc2VfZXhpdCgpOworfQorCit2b2lkIHRyYXZlcnNlX3N5bWJvbChzdHJ1
Y3QgY29udmVydF9vcCAqb3AsIHZvaWQgKnB0ciwgdm9pZCAqZGF0YSkKK3sKKwlzdHJ1Y3Qgc3lt
Ym9sICpzeW0gPSAoc3RydWN0IHN5bWJvbCopIHB0cjsKKwl0cmF2ZXJzZV9lbnRlcigpOworCW9w
LT5jb252ZXJ0X3Bvc2l0aW9uKCZzeW0tPnBvcywgZGF0YSk7CisJb3AtPmNvbnZlcnRfaWRlbnQo
JnN5bS0+aWRlbnQsIGRhdGEpOworCXN3aXRjaChzeW0tPnR5cGUpIHsKKwljYXNlIFNZTV9GTjoK
KwkJY29udmVydF9zeW1ib2xfbGlzdChvcCwgJnN5bS0+YXJndW1lbnRzLCBkYXRhKTsKKwkJYnJl
YWs7CisJY2FzZSBTWU1fU1RSVUNUOgorCWNhc2UgU1lNX1VOSU9OOgorCQljb252ZXJ0X3N5bWJv
bF9saXN0KG9wLCAmc3ltLT5zeW1ib2xfbGlzdCwgZGF0YSk7CisJCWJyZWFrOworCWNhc2UgU1lN
X0FSUkFZOgorCQljb252ZXJ0X2V4cHJlc3Npb24ob3AsICZzeW0tPmFycmF5X3NpemUsIGRhdGEp
OworCQlicmVhazsKKwljYXNlIFNZTV9CQVNFVFlQRToKKwkJZ290byBkb25lOworCWNhc2UgU1lN
X05PREU6CisJY2FzZSBTWU1fUFRSOgorCWNhc2UgU1lNX0JJVEZJRUxEOgorCWNhc2UgU1lNX0VO
VU06CisJCWJyZWFrOworCWRlZmF1bHQ6CisJCWRpZSgidW5pbXBsZW1lbnQgc3ltYm9sICVkXG4i
LCBzeW0tPnR5cGUpOworCQlicmVhazsKKwl9CisJY29udmVydF9zeW1ib2wob3AsICZzeW0tPmN0
eXBlLmJhc2VfdHlwZSwgZGF0YSk7CisKKwkvKiBzeW0tPmluaXRpYWxpemVyIGhhcyBhbHJlYWR5
IGJlZW4gdGFrZW4gY2FyZSBieSB0aGUgbGluZWFyaXplIGNvZGUuICovCisKKwkvLyBjb252ZXJ0
X2V4cHJlc3Npb24ob3AsICZzeW0tPmluaXRpYWxpemVyLCBkYXRhKTsKK2RvbmU6CisJdHJhdmVy
c2VfZXhpdCgpOworfQorCit2b2lkIHRyYXZlcnNlX2V4cHJlc3Npb24oc3RydWN0IGNvbnZlcnRf
b3AgKm9wLCB2b2lkICpwdHIsIHZvaWQgKmRhdGEpCit7CisJc3RydWN0IGV4cHJlc3Npb24gKmV4
cHIgPSAoc3RydWN0IGV4cHJlc3Npb24qKSBwdHI7CisJdHJhdmVyc2VfZW50ZXIoKTsKKwlzd2l0
Y2goZXhwci0+dHlwZSkgeworCWNhc2UgRVhQUl9TWU1CT0w6CisJCWNvbnZlcnRfc3ltYm9sKG9w
LCAmZXhwci0+c3ltYm9sLCBkYXRhKTsKKwkJb3AtPmNvbnZlcnRfaWRlbnQoJmV4cHItPnN5bWJv
bF9uYW1lLCBkYXRhKTsKKwkJYnJlYWs7CisJY2FzZSBFWFBSX1NUUklORzoKKwkJb3AtPmNvbnZl
cnRfc3RyaW5nKCZleHByLT5zdHJpbmcsIGRhdGEpOworCQlicmVhazsKKwljYXNlIEVYUFJfVkFM
VUU6CisJCWJyZWFrOworCWRlZmF1bHQ6CisJCWRpZSgidW5pbXBsZW1lbnQgZXhwcmVzc2lvbiAl
ZFxuIiwgZXhwci0+dHlwZSk7CisJCWJyZWFrOworCX0KKwl0cmF2ZXJzZV9leGl0KCk7Cit9CisK
Kwordm9pZCB0cmF2ZXJzZV9tdWx0aWptcChzdHJ1Y3QgY29udmVydF9vcCAqb3AsIHZvaWQgKnB0
ciwgdm9pZCAqZGF0YSkKK3sKKwlzdHJ1Y3QgbXVsdGlqbXAgKm1qID0gKHN0cnVjdCBtdWx0aWpt
cCopIHB0cjsKKwl0cmF2ZXJzZV9lbnRlcigpOworCWNvbnZlcnRfYmFzaWNfYmxvY2sob3AsICZt
ai0+dGFyZ2V0LCBkYXRhKTsKKwl0cmF2ZXJzZV9leGl0KCk7Cit9CisKK3ZvaWQgdHJhdmVyc2Vf
YXNtX2NvbnN0cmFpbnQoc3RydWN0IGNvbnZlcnRfb3AgKm9wLCB2b2lkICpwdHIsIHZvaWQgKmRh
dGEpCit7CisJc3RydWN0IGFzbV9jb25zdHJhaW50ICpjdCA9IChzdHJ1Y3QgYXNtX2NvbnN0cmFp
bnQqKSBwdHI7CisJdHJhdmVyc2VfZW50ZXIoKTsKKwljb252ZXJ0X3BzZXVkbyhvcCwgJmN0LT5w
c2V1ZG8sIGRhdGEpOworCW9wLT5jb252ZXJ0X2NoYXJzdHJpbmcoKGNoYXIqKikmY3QtPmNvbnN0
cmFpbnQsIGRhdGEpOworCW9wLT5jb252ZXJ0X2lkZW50KChzdHJ1Y3QgaWRlbnQqKikmY3QtPmlk
ZW50LCBkYXRhKTsKKwl0cmF2ZXJzZV9leGl0KCk7Cit9CisKK3ZvaWQgdHJhdmVyc2VfYXNtX3J1
bGVzKHN0cnVjdCBjb252ZXJ0X29wICpvcCwgdm9pZCAqcHRyLCB2b2lkICpkYXRhKQoreworCXN0
cnVjdCBhc21fcnVsZXMgKnJ1bGVzID0gKHN0cnVjdCBhc21fcnVsZXMqKSBwdHI7CisJdHJhdmVy
c2VfZW50ZXIoKTsKKwljb252ZXJ0X2FzbV9jb25zdHJhaW50X2xpc3Qob3AsICZydWxlcy0+aW5w
dXRzLCBkYXRhKTsKKwljb252ZXJ0X2FzbV9jb25zdHJhaW50X2xpc3Qob3AsICZydWxlcy0+b3V0
cHV0cywgZGF0YSk7CisJY29udmVydF9hc21fY29uc3RyYWludF9saXN0KG9wLCAmcnVsZXMtPmNs
b2JiZXJzLCBkYXRhKTsKKwl0cmF2ZXJzZV9leGl0KCk7Cit9CisKK3ZvaWQgdHJhdmVyc2VfaW5z
dHJ1Y3Rpb24oc3RydWN0IGNvbnZlcnRfb3AgKm9wLCB2b2lkICpwdHIsIHZvaWQgKmRhdGEpCit7
CisJc3RydWN0IGluc3RydWN0aW9uICppbnNuID0gKHN0cnVjdCBpbnN0cnVjdGlvbiopIHB0cjsK
Kwl0cmF2ZXJzZV9lbnRlcigpOworCW9wLT5jb252ZXJ0X3Bvc2l0aW9uKCZpbnNuLT5wb3MsIGRh
dGEpOworCWlmICghaW5zbi0+YmIpCisJCWdvdG8gZXhpdDsKKwljb252ZXJ0X2Jhc2ljX2Jsb2Nr
KG9wLCAmaW5zbi0+YmIsIGRhdGEpOworCXN3aXRjaCAoaW5zbi0+b3Bjb2RlKSB7CisJY2FzZSBP
UF9FTlRSWToKKwkJY29udmVydF9wc2V1ZG9fbGlzdChvcCwgJmluc24tPmFyZ19saXN0LCBkYXRh
KTsKKwkJYnJlYWs7CisJY2FzZSBPUF9SRVQ6CisJCWNvbnZlcnRfcHNldWRvKG9wLCAmaW5zbi0+
c3JjLCBkYXRhKTsKKwkJYnJlYWs7CisJY2FzZSBPUF9CUjoKKwkJY29udmVydF9wc2V1ZG8ob3As
ICZpbnNuLT5jb25kLCBkYXRhKTsKKwkJY29udmVydF9iYXNpY19ibG9jayhvcCwgJmluc24tPmJi
X3RydWUsIGRhdGEpOworCQljb252ZXJ0X2Jhc2ljX2Jsb2NrKG9wLCAmaW5zbi0+YmJfZmFsc2Us
IGRhdGEpOworCQlicmVhazsKKworCWNhc2UgT1BfU1dJVENIOgorCWNhc2UgT1BfQ09NUFVURURH
T1RPOgorCQljb252ZXJ0X3BzZXVkbyhvcCwgJmluc24tPmNvbmQsIGRhdGEpOworCQljb252ZXJ0
X211bHRpam1wX2xpc3Qob3AsICZpbnNuLT5tdWx0aWptcF9saXN0LCBkYXRhKTsKKwkJYnJlYWs7
CisKKwljYXNlIE9QX1BISVNPVVJDRToKKwkJY29udmVydF9wc2V1ZG8ob3AsICZpbnNuLT50YXJn
ZXQsIGRhdGEpOworCQljb252ZXJ0X3BzZXVkbyhvcCwgJmluc24tPnBoaV9zcmMsIGRhdGEpOwor
CQljb252ZXJ0X2luc3RydWN0aW9uX2xpc3Qob3AsICZpbnNuLT5waGlfdXNlcnMsIGRhdGEpOwor
CQlicmVhazsKKworCWNhc2UgT1BfUEhJOgorCQljb252ZXJ0X3BzZXVkbyhvcCwgJmluc24tPnRh
cmdldCwgZGF0YSk7CisJCWNvbnZlcnRfcHNldWRvX2xpc3Qob3AsICZpbnNuLT5waGlfbGlzdCwg
ZGF0YSk7CisJCWJyZWFrOworCisJY2FzZSBPUF9MTk9QOgorCWNhc2UgT1BfU05PUDoKKwkJY29u
dmVydF9wc2V1ZG8ob3AsICZpbnNuLT50YXJnZXQsIGRhdGEpOworCQlicmVhazsKKwljYXNlIE9Q
X0xPQUQ6CisJY2FzZSBPUF9TVE9SRToKKwkJY29udmVydF9wc2V1ZG8ob3AsICZpbnNuLT50YXJn
ZXQsIGRhdGEpOworCQljb252ZXJ0X3BzZXVkbyhvcCwgJmluc24tPnNyYywgZGF0YSk7CisJCWJy
ZWFrOworCWNhc2UgT1BfQ0FMTDoKKwljYXNlIE9QX0lOTElORURfQ0FMTDoKKwkJY29udmVydF9w
c2V1ZG8ob3AsICZpbnNuLT50YXJnZXQsIGRhdGEpOworCQljb252ZXJ0X3BzZXVkbyhvcCwgJmlu
c24tPmZ1bmMsIGRhdGEpOworCQljb252ZXJ0X3BzZXVkb19saXN0KG9wLCAmaW5zbi0+YXJndW1l
bnRzLCBkYXRhKTsKKwkJYnJlYWs7CisJY2FzZSBPUF9DQVNUOgorCWNhc2UgT1BfU0NBU1Q6CisJ
Y2FzZSBPUF9GUENBU1Q6CisJY2FzZSBPUF9QVFJDQVNUOgorCQljb252ZXJ0X3BzZXVkbyhvcCwg
Jmluc24tPnRhcmdldCwgZGF0YSk7CisJCWNvbnZlcnRfc3ltYm9sKG9wLCAmaW5zbi0+b3JpZ190
eXBlLCBkYXRhKTsKKwkJY29udmVydF9wc2V1ZG8ob3AsICZpbnNuLT5zcmMsIGRhdGEpOworCQli
cmVhazsKKworCWNhc2UgT1BfQklOQVJZIC4uLiBPUF9CSU5BUllfRU5EOgorCWNhc2UgT1BfQklO
Q01QIC4uLiBPUF9CSU5DTVBfRU5EOgorCQljb252ZXJ0X3BzZXVkbyhvcCwgJmluc24tPnRhcmdl
dCwgZGF0YSk7CisJCWNvbnZlcnRfcHNldWRvKG9wLCAmaW5zbi0+c3JjMSwgZGF0YSk7CisJCWNv
bnZlcnRfcHNldWRvKG9wLCAmaW5zbi0+c3JjMiwgZGF0YSk7CisJCWJyZWFrOworCisJY2FzZSBP
UF9TRUw6CisJCWNvbnZlcnRfcHNldWRvKG9wLCAmaW5zbi0+dGFyZ2V0LCBkYXRhKTsKKwkJY29u
dmVydF9wc2V1ZG8ob3AsICZpbnNuLT5zcmMxLCBkYXRhKTsKKwkJY29udmVydF9wc2V1ZG8ob3As
ICZpbnNuLT5zcmMyLCBkYXRhKTsKKwkJY29udmVydF9wc2V1ZG8ob3AsICZpbnNuLT5zcmMzLCBk
YXRhKTsKKwkJYnJlYWs7CisKKwljYXNlIE9QX1NMSUNFOgorCQljb252ZXJ0X3BzZXVkbyhvcCwg
Jmluc24tPnRhcmdldCwgZGF0YSk7CisJCWNvbnZlcnRfcHNldWRvKG9wLCAmaW5zbi0+YmFzZSwg
ZGF0YSk7CisJCWJyZWFrOworCisJY2FzZSBPUF9OT1A6CisJCWNvbnZlcnRfcHNldWRvKG9wLCAm
aW5zbi0+dGFyZ2V0LCBkYXRhKTsKKwkJYnJlYWs7CisJY2FzZSBPUF9OT1Q6IGNhc2UgT1BfTkVH
OgorCQljb252ZXJ0X3BzZXVkbyhvcCwgJmluc24tPnRhcmdldCwgZGF0YSk7CisJCWNvbnZlcnRf
cHNldWRvKG9wLCAmaW5zbi0+c3JjMSwgZGF0YSk7CisJCWJyZWFrOworCWNhc2UgT1BfQ09OVEVY
VDoKKwkJY29udmVydF9leHByZXNzaW9uKG9wLCAmaW5zbi0+Y29udGV4dF9leHByLCBkYXRhKTsK
KwkJYnJlYWs7CisJY2FzZSBPUF9SQU5HRToKKwkJY29udmVydF9wc2V1ZG8ob3AsICZpbnNuLT5z
cmMxLCBkYXRhKTsKKwkJY29udmVydF9wc2V1ZG8ob3AsICZpbnNuLT5zcmMyLCBkYXRhKTsKKwkJ
Y29udmVydF9wc2V1ZG8ob3AsICZpbnNuLT5zcmMzLCBkYXRhKTsKKwkJYnJlYWs7CisJY2FzZSBP
UF9ERUFUSE5PVEU6CisJCWNvbnZlcnRfcHNldWRvKG9wLCAmaW5zbi0+dGFyZ2V0LCBkYXRhKTsK
KwkJYnJlYWs7CisJY2FzZSBPUF9BU006CisJCW9wLT5jb252ZXJ0X2NoYXJzdHJpbmcoKGNoYXIg
KiopJmluc24tPnN0cmluZywgZGF0YSk7CisJCWNvbnZlcnRfYXNtX3J1bGVzKG9wLCAmaW5zbi0+
YXNtX3J1bGVzLCBkYXRhKTsKKwkJYnJlYWs7CisJY2FzZSBPUF9DT1BZOgorCQljb252ZXJ0X3Bz
ZXVkbyhvcCwgJmluc24tPnRhcmdldCwgZGF0YSk7CisJCWNvbnZlcnRfcHNldWRvKG9wLCAmaW5z
bi0+c3JjLCBkYXRhKTsKKwkJYnJlYWs7CisJY2FzZSBPUF9TWU1BRERSOgorCQljb252ZXJ0X3Bz
ZXVkbyhvcCwgJmluc24tPnRhcmdldCwgZGF0YSk7CisJCWNvbnZlcnRfcHNldWRvKG9wLCAmaW5z
bi0+c3ltYm9sLCBkYXRhKTsKKwkJYnJlYWs7CisJZGVmYXVsdDoKKwkJZGllKCJ1bmltcGxlbWVu
dCAlc1xuIiwgc2hvd19pbnN0cnVjdGlvbihpbnNuKSk7CisJfQorZXhpdDoKKwl0cmF2ZXJzZV9l
eGl0KCk7Cit9CisKKwpJbmRleDogc3BhcnNlL3Rva2VuaXplLmMKPT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3Bh
cnNlLm9yaWcvdG9rZW5pemUuYworKysgc3BhcnNlL3Rva2VuaXplLmMKQEAgLTIzLDYgKzIzLDcg
QEAKICNkZWZpbmUgRU9GICgtMSkKIAogaW50IGlucHV0X3N0cmVhbV9uciA9IDA7CitpbnQgZnJl
ZV9zdHJlYW1faGVhZCA9IDA7CS8qIGlucHV0X3N0cmVhbSBjYW4gcmVsb2NhdGUsIHVzaW5nIGlu
ZGV4ICovCiBzdHJ1Y3Qgc3RyZWFtICppbnB1dF9zdHJlYW1zOwogc3RhdGljIGludCBpbnB1dF9z
dHJlYW1zX2FsbG9jYXRlZDsKIApAQCAtMTY3LDExICsxNjgsMjMgQEAgY29uc3QgY2hhciAqc2hv
d190b2tlbihjb25zdCBzdHJ1Y3QgdG9rZQogCX0KIH0KIAotaW50IGluaXRfc3RyZWFtKGNvbnN0
IGNoYXIgKm5hbWUsIGludCBmZCwgY29uc3QgY2hhciAqKm5leHRfcGF0aCkKK3ZvaWQgZnJlZV9z
dHJlYW0oaW50IHN0cmVhbSkKIHsKLQlpbnQgc3RyZWFtID0gaW5wdXRfc3RyZWFtX25yOwotCXN0
cnVjdCBzdHJlYW0gKmN1cnJlbnQ7CisJaWYgKHN0cmVhbSkgeworCQlpbnB1dF9zdHJlYW1zW3N0
cmVhbV0uZmQgPSBmcmVlX3N0cmVhbV9oZWFkOworCQlmcmVlX3N0cmVhbV9oZWFkID0gc3RyZWFt
OworCX0KK30KIAoraW50IGFsbG9jYXRlX3N0cmVhbSh2b2lkKQoreworCWludCBzdHJlYW07CisJ
aWYgKGZyZWVfc3RyZWFtX2hlYWQpIHsKKwkJc3RyZWFtID0gZnJlZV9zdHJlYW1faGVhZDsKKwkJ
ZnJlZV9zdHJlYW1faGVhZCA9IGlucHV0X3N0cmVhbXNbc3RyZWFtXS5mZDsKKwkJcmV0dXJuIHN0
cmVhbTsKKwl9CisJc3RyZWFtID0gaW5wdXRfc3RyZWFtX25yOwogCWlmIChzdHJlYW0gPj0gaW5w
dXRfc3RyZWFtc19hbGxvY2F0ZWQpIHsKIAkJaW50IG5ld2FsbG9jID0gc3RyZWFtICogNCAvIDMg
KyAxMDsKIAkJaW5wdXRfc3RyZWFtcyA9IHJlYWxsb2MoaW5wdXRfc3RyZWFtcywgbmV3YWxsb2Mg
KiBzaXplb2Yoc3RydWN0IHN0cmVhbSkpOwpAQCAtMTc5LDYgKzE5MiwxNSBAQCBpbnQgaW5pdF9z
dHJlYW0oY29uc3QgY2hhciAqbmFtZSwgaW50IGZkCiAJCQlkaWUoIlVuYWJsZSB0byBhbGxvY2F0
ZSBtb3JlIHN0cmVhbXMgc3BhY2UiKTsKIAkJaW5wdXRfc3RyZWFtc19hbGxvY2F0ZWQgPSBuZXdh
bGxvYzsKIAl9CisJaW5wdXRfc3RyZWFtX25yID0gc3RyZWFtKzE7CisJcmV0dXJuIHN0cmVhbTsK
K30KKworaW50IGluaXRfc3RyZWFtKGNvbnN0IGNoYXIgKm5hbWUsIGludCBmZCwgY29uc3QgY2hh
ciAqKm5leHRfcGF0aCkKK3sKKwlpbnQgc3RyZWFtID0gYWxsb2NhdGVfc3RyZWFtKCk7CisJc3Ry
dWN0IHN0cmVhbSAqY3VycmVudDsKKwkKIAljdXJyZW50ID0gaW5wdXRfc3RyZWFtcyArIHN0cmVh
bTsKIAltZW1zZXQoY3VycmVudCwgMCwgc2l6ZW9mKCpjdXJyZW50KSk7CiAJY3VycmVudC0+bmFt
ZSA9IG5hbWU7CkBAIC0xODYsNyArMjA4LDYgQEAgaW50IGluaXRfc3RyZWFtKGNvbnN0IGNoYXIg
Km5hbWUsIGludCBmZAogCWN1cnJlbnQtPm5leHRfcGF0aCA9IG5leHRfcGF0aDsKIAljdXJyZW50
LT5wYXRoID0gTlVMTDsKIAljdXJyZW50LT5jb25zdGFudCA9IENPTlNUQU5UX0ZJTEVfTUFZQkU7
Ci0JaW5wdXRfc3RyZWFtX25yID0gc3RyZWFtKzE7CiAJcmV0dXJuIHN0cmVhbTsKIH0KIApJbmRl
eDogc3BhcnNlL3N5bWJvbC5oCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL3N5bWJvbC5oCisr
KyBzcGFyc2Uvc3ltYm9sLmgKQEAgLTEwNyw2ICsxMDcsOCBAQCBleHRlcm4gaW50IGV4cGFuZF9j
b25zdGFudF9wKHN0cnVjdCBleHByCiAjZGVmaW5lIFNZTV9BVFRSX05PUk1BTAkJMQogI2RlZmlu
ZSBTWU1fQVRUUl9TVFJPTkcJCTIKIAorc3RydWN0IGVudHJ5cG9pbnQ7CisKIHN0cnVjdCBzeW1i
b2wgewogCWVudW0gdHlwZSB0eXBlOjg7CiAJZW51bSBuYW1lc3BhY2UgbmFtZXNwYWNlOjk7CkBA
IC0xNTksNiArMTYxLDcgQEAgc3RydWN0IHN5bWJvbCB7CiAJfTsKIAl1bmlvbiAvKiBiYWNrZW5k
ICovIHsKIAkJc3RydWN0IGJhc2ljX2Jsb2NrICpiYl90YXJnZXQ7CS8qIGxhYmVsICovCisJCXN0
cnVjdCBlbnRyeXBvaW50ICplcDsJCS8qIGZ1bmN0aW9uICovCiAJCXZvaWQgKmF1eDsJCQkvKiBB
dXhpbGlhcnkgaW5mbywgZS5nLiBiYWNrZW5kIGluZm9ybWF0aW9uICovCiAJCXN0cnVjdCB7CQkJ
Lyogc3BhcnNlIGN0YWdzICovCiAJCQljaGFyIGtpbmQ7CkluZGV4OiBzcGFyc2UvdGVzdC1saW5l
YXJpemUuYwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09CkluZGV4OiBzcGFyc2UvTWFrZWZpbGUKPT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0g
c3BhcnNlLm9yaWcvTWFrZWZpbGUKKysrIHNwYXJzZS9NYWtlZmlsZQpAQCAtMjUsNyArMjUsNyBA
QCBJTkNMVURFRElSPSQoUFJFRklYKS9pbmNsdWRlCiBQS0dDT05GSUdESVI9JChMSUJESVIpL3Br
Z2NvbmZpZwogCiBQUk9HUkFNUz10ZXN0LWxleGluZyB0ZXN0LXBhcnNpbmcgb2JmdXNjYXRlIGNv
bXBpbGUgZ3JhcGggc3BhcnNlIHRlc3QtbGluZWFyaXplIGV4YW1wbGUgXAotCSB0ZXN0LXVuc3Nh
IHRlc3QtZGlzc2VjdCBjdGFncworCSB0ZXN0LXVuc3NhIHRlc3QtZGlzc2VjdCBjdGFncyB0ZXN0
LXdyaXRlIAogCiAKIElOU1RfUFJPR1JBTVM9c3BhcnNlIGNnY2MKQEAgLTM4LDEyICszOCwxMyBA
QCBlbmRpZgogCiBMSUJfSD0gICAgdG9rZW4uaCBwYXJzZS5oIGxpYi5oIHN5bWJvbC5oIHNjb3Bl
LmggZXhwcmVzc2lvbi5oIHRhcmdldC5oIFwKIAkgIGxpbmVhcml6ZS5oIGJpdG1hcC5oIGlkZW50
LWxpc3QuaCBjb21wYXQuaCBmbG93LmggYWxsb2NhdGUuaCBcCi0JICBzdG9yYWdlLmggcHRybGlz
dC5oIGRpc3NlY3QuaAorCSAgc3RvcmFnZS5oIHB0cmxpc3QuaCBkaXNzZWN0LmggdHJhdmVyc2Uu
aCBieXRlY29kZS5oCiAKIExJQl9PQkpTPSB0YXJnZXQubyBwYXJzZS5vIHRva2VuaXplLm8gcHJl
LXByb2Nlc3MubyBzeW1ib2wubyBsaWIubyBzY29wZS5vIFwKIAkgIGV4cHJlc3Npb24ubyBzaG93
LXBhcnNlLm8gZXZhbHVhdGUubyBleHBhbmQubyBpbmxpbmUubyBsaW5lYXJpemUubyBcCiAJICBz
b3J0Lm8gYWxsb2NhdGUubyBjb21wYXQtJChPUykubyBwdHJsaXN0Lm8gXAotCSAgZmxvdy5vIGNz
ZS5vIHNpbXBsaWZ5Lm8gbWVtb3BzLm8gbGl2ZW5lc3MubyBzdG9yYWdlLm8gdW5zc2EubyBkaXNz
ZWN0Lm8KKwkgIGZsb3cubyBjc2UubyBzaW1wbGlmeS5vIG1lbW9wcy5vIGxpdmVuZXNzLm8gc3Rv
cmFnZS5vIHVuc3NhLm8gZGlzc2VjdC5vIFwKKwkgIHdyaXRlci5vIHRyYXZlcnNlLm8KIAogTElC
X0ZJTEU9IGxpYnNwYXJzZS5hCiBTTElCX0ZJTEU9IGxpYnNwYXJzZS5zbwpAQCAtMTMzLDYgKzEz
NCw5IEBAIGN0YWdzOiBjdGFncy5vICQoTElCUykKIGMyeG1sOiBjMnhtbC5vICQoTElCUykKIAkk
KFFVSUVUX0xJTkspJChDQykgJChMREZMQUdTKSAgLW8gJEAgJDwgJChMSUJTKSBgcGtnLWNvbmZp
ZyAtLWxpYnMgbGlieG1sLTIuMGAKIAordGVzdC13cml0ZTogdGVzdC13cml0ZS5vICQoTElCUykK
KwkkKENDKSAkKExERkxBR1MpIC1vICRAICQ8ICQoTElCUykKKwogJChMSUJfRklMRSk6ICQoTElC
X09CSlMpCiAJJChRVUlFVF9BUikkKEFSKSByY3MgJEAgJChMSUJfT0JKUykKIApAQCAtMTc3LDYg
KzE4MSwxMCBAQCBncmFwaC5vOiAkKExJQl9IKQogCiBjMnhtbC5vOiBjMnhtbC5jICQoTElCX0gp
CiAJJChRVUlFVF9DQykkKENDKSBgcGtnLWNvbmZpZyAtLWNmbGFncyBsaWJ4bWwtMi4wYCAtbyAk
QCAtYyAkKENGTEFHUykgJDwKK3RyYXZlcnNlLm86ICQoTElCX0gpCit3cml0ZXIubzogJChMSUJf
SCkKK3RyYXZlcnNlLm86ICQoTElCX0gpCit0ZXN0LXdyaXRlLm86ICQoTElCX0gpCiAKIGNvbXBh
dC1saW51eC5vOiBjb21wYXQvc3RydG9sZC5jIGNvbXBhdC9tbWFwLWJsb2IuYyBcCiAJJChMSUJf
SCkKSW5kZXg6IHNwYXJzZS90b2tlbi5oCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL3Rva2Vu
LmgKKysrIHNwYXJzZS90b2tlbi5oCkBAIC00MCw3ICs0MCw4IEBAIHN0cnVjdCBzdHJlYW0gewog
CiAJLyogVXNlIHRoZXNlIHRvIGNoZWNrIGZvciAiYWxyZWFkeSBwYXJzZWQiICovCiAJZW51bSBj
b25zdGFudGZpbGUgY29uc3RhbnQ7Ci0JaW50IGRpcnR5OworCXVuc2lnbmVkIGRpcnR5OjE7CisJ
dW5zaWduZWQgdXNlZDoxOwogCXN0cnVjdCBpZGVudCAqcHJvdGVjdDsKIAlzdHJ1Y3QgdG9rZW4g
KmlmbmRlZjsKIAlzdHJ1Y3QgdG9rZW4gKnRvcF9pZjsKQEAgLTIxMCw0ICsyMTEsNyBAQCBzdGF0
aWMgaW5saW5lIGludCBtYXRjaF9pZGVudChzdHJ1Y3QgdG9rCiAJcmV0dXJuIHRva2VuLT5wb3Mu
dHlwZSA9PSBUT0tFTl9JREVOVCAmJiB0b2tlbi0+aWRlbnQgPT0gaWQ7CiB9CiAKK2V4dGVybiB2
b2lkIGZyZWVfc3RyZWFtKGludCBzdHJlYW0pOworZXh0ZXJuIGludCBhbGxvY2F0ZV9zdHJlYW0o
dm9pZCk7CisKICNlbmRpZgpJbmRleDogc3BhcnNlL2xpYi5oCj09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KSW5kZXg6IHNw
YXJzZS9ieXRlY29kZS5oCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5vcmlnL2J5dGVjb2RlLmgKKysr
IHNwYXJzZS9ieXRlY29kZS5oCkBAIC0wLDAgKzEsNDQgQEAKKy8qCisgKiBieXRlY29kZS5oCisg
KgorICogQ29weXJpZ2h0IChDKSAyMDA4IENocmlzdG9waGVyIExpLgorICoKKyAqIExpY2Vuc2Vk
IHVuZGVyIHRoZSBPcGVuIFNvZnR3YXJlIExpY2Vuc2UgdmVyc2lvbiAxLjEKKyAqLworCisjaW5j
bHVkZSAibGludXgvdHlwZXMuaCIKKyNpbmNsdWRlICJwdHJsaXN0LmgiCisKK0RFQ0xBUkVfUFRS
X0xJU1Qoc3RyZWFtX2xpc3QsIHN0cnVjdCBzdHJlYW0pOworREVDTEFSRV9QVFJfTElTVChpZGVu
dF9saXN0LCBzdHJ1Y3QgaWRlbnQpOworCitzdHJ1Y3Qgb2JqZWN0X2hlYWRlciB7CisJX191MzIg
dHlwZTsKKwlfX3UzMiBvZmZzZXQ7CisJX191MzIgY291bnQ7CisJX191MzIgc2l6ZTsKK307CisK
K3N0cnVjdCBieXRlY29kZV9oZHIgeworCV9fdTMyIG1hZ2ljOworCV9fdTE2IG1ham9yX3ZlcnNp
b247CisJX191MTYgbWlub3JfdmVyc2lvbjsKKwlfX3UzMiBleHBvcnRfc3ltYm9sczsJCS8vIGZp
cnN0IGdyb3VwICMgc3ltYm9scyBpbiBpZGVudCBvYmplY3RzCisJX191MzIgaW50ZXJuYWxfc3lt
Ym9sczsJCS8vIHNlY29uZCBncm91cCAjIHN5bWJvbCBpbiBpZGVudCBvYmplY3RzCisJX191MzIg
aW1wb3J0X3N5bWJvbHM7CQkvLyBmb2xsb3cgdXAgIyBzeW1ib2xzIGluIGlkZW50IG9iamVjdHMK
KwlfX3UzMiBzeW1ib2xfbGlzdDsKKwlfX3UzMiBmdW5jdGlvbl9saXN0OworCV9fdTE2IG9iamVj
dF9oZWFkZXJzOworCXN0cnVjdCBvYmplY3RfaGVhZGVyIGhlYWRlcnNbXTsKK307CisKK3ZvaWQg
d3JpdGVfYnl0ZWNvZGUoY2hhciAqc3JjLCBzdHJ1Y3Qgc3ltYm9sX2xpc3QgKnN5bXMpOworc3Ry
dWN0IGJ5dGVjb2RlX2hkciAqcmVhZF9ieXRlY29kZShjaGFyICpzcmMpOworCitzdGF0aWMgaW5s
aW5lIHZvaWQgKiphZGRfaWRlbnQoc3RydWN0IGlkZW50X2xpc3QgKipsaXN0LCBzdHJ1Y3QgaWRl
bnQgKmlkZW50KQoreworCXZvaWQgKnAgPSAodm9pZCopIGlkZW50OworCWlmICghcCkKKwkJcmV0
dXJuIE5VTEw7CisJcmV0dXJuIGFkZF9wdHJfbGlzdCgoc3RydWN0IHB0cl9saXN0KiopIGxpc3Qs
IHApOworfQpJbmRleDogc3BhcnNlL2xpbmVhcml6ZS5oCj09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5v
cmlnL2xpbmVhcml6ZS5oCisrKyBzcGFyc2UvbGluZWFyaXplLmgKQEAgLTgsNyArOCwxMCBAQAog
I2luY2x1ZGUgInN5bWJvbC5oIgogCiBzdHJ1Y3QgaW5zdHJ1Y3Rpb247CitzdHJ1Y3QgZW50cnlw
b2ludDsKKwogREVDTEFSRV9QVFJfTElTVChwc2V1ZG9fcHRyX2xpc3QsIHBzZXVkb190KTsKK0RF
Q0xBUkVfUFRSX0xJU1QoZW50cnlwb2ludF9saXN0LCBzdHJ1Y3QgZW50cnlwb2ludCk7CiAKIHN0
cnVjdCBwc2V1ZG9fdXNlciB7CiAJc3RydWN0IGluc3RydWN0aW9uICppbnNuOwpAQCAtNzEsMTgg
Kzc0LDE3IEBAIHN0cnVjdCBpbnN0cnVjdGlvbiB7CiAJCSBzaXplOjI0OwogCXN0cnVjdCBiYXNp
Y19ibG9jayAqYmI7CiAJc3RydWN0IHBvc2l0aW9uIHBvczsKLQl1bmlvbiB7Ci0JCXBzZXVkb190
IHRhcmdldDsKLQkJcHNldWRvX3QgY29uZDsJCS8qIGZvciBicmFuY2ggYW5kIHN3aXRjaCAqLwot
CX07CisJcHNldWRvX3QgdGFyZ2V0OwogCXVuaW9uIHsKIAkJc3RydWN0IC8qIGVudHJ5cG9pbnQg
Ki8gewogCQkJc3RydWN0IHBzZXVkb19saXN0ICphcmdfbGlzdDsKIAkJfTsKIAkJc3RydWN0IC8q
IGJyYW5jaCAqLyB7CisJCQlwc2V1ZG9fdCBjb25kOwogCQkJc3RydWN0IGJhc2ljX2Jsb2NrICpi
Yl90cnVlLCAqYmJfZmFsc2U7CiAJCX07CiAJCXN0cnVjdCAvKiBzd2l0Y2ggKi8geworCQkJcHNl
dWRvX3QgY29uZDsKIAkJCXN0cnVjdCBtdWx0aWptcF9saXN0ICptdWx0aWptcF9saXN0OwogCQl9
OwogCQlzdHJ1Y3QgLyogcGhpX25vZGUgKi8gewpJbmRleDogc3BhcnNlL3dyaXRlci5jCj09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT0KLS0tIHNwYXJzZS5vcmlnL3dyaXRlci5jCisrKyBzcGFyc2Uvd3JpdGVyLmMKQEAgLTAs
MCArMSw0NTYgQEAKKy8qCisgKiB3cml0ZXIuYworICoKKyAqIFdhbGsgdGhlIHNwYXJzZSBzeW1i
b2wgdHJlZSBhbmQgbGluZWFyaXplZCBpbnN0cnVjdGlvbi4gU2F2ZQorICogdGhlbSBpbnRvIGZp
bGUuCisgKgorICogQ29weXJpZ2h0IChDKSAyMDA4IENocmlzdG9waGVyIExpLgorICoKKyAqIExp
Y2Vuc2VkIHVuZGVyIHRoZSBPcGVuIFNvZnR3YXJlIExpY2Vuc2UgdmVyc2lvbiAxLjEKKyAqLwor
CisjaW5jbHVkZSA8dW5pc3RkLmg+CisKKyNpbmNsdWRlIDxzdGRpby5oPgorI2luY2x1ZGUgPHN0
ZGxpYi5oPgorI2luY2x1ZGUgPGZjbnRsLmg+CisjaW5jbHVkZSA8c3RyaW5nLmg+CisjaW5jbHVk
ZSA8c3lzL21tYW4uaD4KKworI2luY2x1ZGUgImFsbG9jYXRlLmgiCisjaW5jbHVkZSAibGluZWFy
aXplLmgiCisjaW5jbHVkZSAidHJhdmVyc2UuaCIKKyNpbmNsdWRlICJ0b2tlbi5oIgorI2luY2x1
ZGUgImxpYi5oIgorI2luY2x1ZGUgImV4cHJlc3Npb24uaCIKKyNpbmNsdWRlICJieXRlY29kZS5o
IgorCitzdHJ1Y3Qgc2hhZG93X3B0ciB7CisJc3RydWN0IHNoYWRvd19wdHIgKm5leHQ7CisJdm9p
ZCAqb3JpZzsKKwlpbnQgbnI7CisJaW50IHNpemU7Cit9OworCitzdHJ1Y3Qgb2JqZWN0IHt9Owor
CitBTExPQ0FUT1Ioc2hhZG93X3B0ciwgInNoYWRvdyBwdHIiKTsKK0FMTE9DQVRPUihvYmplY3Qs
ICJjb252ZXJ0ZWQgb2JqZWN0Iik7CisKK3N0cnVjdCBvYmplY3RfdGFibGUgeworCWludCBjb3Vu
dDsKKwlpbnQgc2l6ZTsKKwlpbnQgdG90YWxzaXplOworCXN0cnVjdCBwdHJfbGlzdCAqb2JqZWN0
X2xpc3Q7Cit9IG9iamVjdF90YWJsZVtQVFJfTEFTVF0gPSB7CisJW1BUUl9JTlNOXS5zaXplIAk9
IHNpemVvZihzdHJ1Y3QgaW5zdHJ1Y3Rpb24pLAorCVtQVFJfRU5UUllQT0lOVF0uc2l6ZSAJPSBz
aXplb2Yoc3RydWN0IGVudHJ5cG9pbnQpLAorCVtQVFJfQkFTSUNCTE9DS10uc2l6ZQk9IHNpemVv
ZihzdHJ1Y3QgYmFzaWNfYmxvY2spLAorCVtQVFJfUFNFVURPXS5zaXplCT0gc2l6ZW9mKHN0cnVj
dCBwc2V1ZG8pLAorCVtQVFJfUFNFVURPX1VTRVJdLnNpemUgCT0gc2l6ZW9mKHN0cnVjdCBwc2V1
ZG9fdXNlciksCisJW1BUUl9BU01fQ09OU1RSQUlOVF0uc2l6ZSA9IHNpemVvZihzdHJ1Y3QgYXNt
X2NvbnN0cmFpbnQpLAorCVtQVFJfU1lNQk9MXS5zaXplCT0gc2l6ZW9mIChzdHJ1Y3Qgc3ltYm9s
KSwKKwlbUFRSX0FTTV9SVUxFU10uc2l6ZQk9IHNpemVvZiAoc3RydWN0IGFzbV9ydWxlcyksCisJ
W1BUUl9NVUxUSUpNUF0uc2l6ZQk9IHNpemVvZiAoc3RydWN0IG11bHRpam1wKSwKKwlbUFRSX0VY
UFJdLnNpemUJCT0gc2l6ZW9mIChzdHJ1Y3QgZXhwcmVzc2lvbiksCit9OworCitzdHJ1Y3QgcHJv
Z3JhbSB7CisJc3RydWN0IHN5bWJvbF9saXN0ICpleHBvcnRfc3ltczsKKwlzdHJ1Y3Qgc3ltYm9s
X2xpc3QgKmltcG9ydF9zeW1zOworCXN0cnVjdCBzeW1ib2xfbGlzdCAqc3ltYm9sczsKKwlzdHJ1
Y3QgZW50cnlwb2ludF9saXN0ICpmdW5jdGlvbl9saXN0OworfTsKKworI2RlZmluZSBQVFJfSEFT
SF9TSVpFICgzODMzMykKKwordm9pZCAqZmlsZV9idWZmZXIgPSBOVUxMOworCitzdGF0aWMgc3Ry
dWN0IHNoYWRvd19wdHIgKnB0cl9oYXNoX3RhYmxlW1BUUl9IQVNIX1NJWkVdOworc3RhdGljIHN0
cnVjdCBwdHJfbGlzdCAqcHRyX29mZnNldF9saXN0ID0gTlVMTDsKK3N0YXRpYyBzdHJ1Y3QgcHRy
X2xpc3QgKnVzZWRfc3RyZWFtX25hbWUgPSBOVUxMOworCit1bnNpZ25lZCBpbnQgdG90YWxfcHRy
ID0gMDsKKworLy8gI2RlZmluZSBERUJVR19XUklURQorI2lmZGVmIERFQlVHX1dSSVRFCitzdGF0
aWMgY29uc3QgY2hhciAqaW5kZW50X3N0cmluZyA9ICIgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgIjsKKyNkZWZpbmUgZGJnKGZtdCwgLi4uKSBwcmlu
dGYoIiUuKnMiIGZtdCwgdHJhdmVyc2VfbGV2ZWwqMiwgaW5kZW50X3N0cmluZywgIyMgX19WQV9B
UkdTX18pCisjZWxzZQorI2RlZmluZSBkYmcoZm10LCAuLi4pCisjZW5kaWYKKworc3RhdGljIHN0
cnVjdCBjb252ZXJ0X29wIHdyaXRlcl9vcDsKKworc3RhdGljIHVuc2lnbmVkIGxvbmcgaW5saW5l
IHB0cl9oYXNoKHZvaWQgKnB0cikKK3sKKwlyZXR1cm4gKCh1bnNpZ25lZCBsb25nKSBwdHIgPj4g
MikgJSBQVFJfSEFTSF9TSVpFOworfQorCisKK3N0YXRpYyBpbmxpbmUgdm9pZCByZWdpc3Rlcl9v
YmplY3QoaW50IHR5cGUsIHZvaWQgKm9iamVjdCwgaW50IHNpemUsIHN0cnVjdCBzaGFkb3dfcHRy
ICpzcCwgdm9pZCAqKnBwdHIpCit7CisJc3RydWN0IG9iamVjdF90YWJsZSAqZW50cnkgPSBvYmpl
Y3RfdGFibGUgKyB0eXBlOworCWlmIChzcCAmJiBwcHRyKQorCQkqKHVuc2lnbmVkIGludCopIHBw
dHIgPSBzcC0+bnIgPSBlbnRyeS0+Y291bnQ7CisJZW50cnktPmNvdW50ICsrOworCWVudHJ5LT50
b3RhbHNpemUgKz0gc2l6ZTsKKwlhZGRfcHRyX2xpc3Rfbm90YWcoJmVudHJ5LT5vYmplY3RfbGlz
dCwgb2JqZWN0KTsKK30KKworc3RhdGljIHZvaWQgd3JpdGVyX2luaXRfb2JqZWN0X3RhYmxlKHZv
aWQpCit7CisJaW50IGk7CisJZm9yIChpID0gMDsgaSA8IFBUUl9MQVNUOyBpKyspIHsKKwkJc3Ry
dWN0IG9iamVjdF90YWJsZSAqZW50cnkgPSBvYmplY3RfdGFibGUgKyBpOworCQllbnRyeS0+Y291
bnQgPSAxOworCQllbnRyeS0+dG90YWxzaXplID0gMDsKKwkJZW50cnktPm9iamVjdF9saXN0ID0g
TlVMTDsKKwl9Cit9CisKK3N0YXRpYyB2b2lkIHdyaXRlcl9pbml0KHZvaWQpCit7CisJdG90YWxf
cHRyID0gMDsKKwl1c2VkX3N0cmVhbV9uYW1lID0gTlVMTDsKKwlwdHJfb2Zmc2V0X2xpc3QgPSBO
VUxMOworCXdyaXRlcl9pbml0X29iamVjdF90YWJsZSgpOworfQorCitzdGF0aWMgaW5saW5lIHN0
cnVjdCBzaGFkb3dfcHRyICpjcmVhdGVfc2hhZG93X3BvaW50ZXIodm9pZCAqcHB0cikKK3sKKwl2
b2lkICpwdHIgPSAqKHZvaWQqKilwcHRyOworCXVuc2lnbmVkIGludCBoYXNoID0gIHB0cl9oYXNo
KHB0cik7CisJc3RydWN0IHNoYWRvd19wdHIgKnNwOworCisJaWYgKCFwdHIpIHsKKwkJKih1bnNp
Z25lZCBpbnQqKSBwcHRyID0gMDsKKwkJcmV0dXJuIE5VTEw7CisJfQorCXNwID0gcHRyX2hhc2hf
dGFibGVbaGFzaF07CisJd2hpbGUgKHNwKSB7CisJCWlmIChzcC0+b3JpZyA9PSBwdHIpIHsKKwkJ
CSoodW5zaWduZWQgaW50KikgcHB0ciA9IHNwLT5ucjsKKwkJCXJldHVybiBOVUxMOworCQl9CisJ
CXNwID0gc3AtPm5leHQ7CisJfQorCisJc3AgPSBfX2FsbG9jX3NoYWRvd19wdHIoMCk7CisJc3At
Pm5leHQgPSBwdHJfaGFzaF90YWJsZVtoYXNoXTsKKwlwdHJfaGFzaF90YWJsZVtoYXNoXSA9IHNw
OworCXNwLT5vcmlnID0gcHRyOworCXJldHVybiBzcDsKKworfQorCitzdGF0aWMgdm9pZCB3cml0
ZXJfY29udmVydF9vYmplY3QoaW50IHR5cGUsIHZvaWQgKnBwdHIsIGludCBzaXplLCB0cmF2ZXJz
ZV90IHRyYXZlcnNlLCB2b2lkICpkYXRhKQoreworCXZvaWQgKnB0ciA9ICoodm9pZCoqKXBwdHI7
CisJc3RydWN0IHNoYWRvd19wdHIgKnNwID0gY3JlYXRlX3NoYWRvd19wb2ludGVyKHBwdHIpOwor
CWlmIChzcCkgeworCQl2b2lkICpvYmplY3QgPSBfX2FsbG9jX29iamVjdChzaXplKTsKKwkJbWVt
Y3B5KG9iamVjdCwgcHRyLCBzaXplKTsKKwkJcmVnaXN0ZXJfb2JqZWN0KHR5cGUsIG9iamVjdCwg
c2l6ZSwgc3AsICh2b2lkKiopIHBwdHIpOworCQl0cmF2ZXJzZSgmd3JpdGVyX29wLCBvYmplY3Qs
IGRhdGEpOworCX0KK30KKworc3RhdGljIHZvaWQgd3JpdGVyX2NvbnZlcnRfcHRyX2xpc3QoaW50
IHR5cGUsIHZvaWQgKnBwdHIsIGludCBzaXplLCB0cmF2ZXJzZV90IHRyYXZlcnNlLCB2b2lkICpk
YXRhKQoreworCXN0cnVjdCBwdHJfbGlzdCAqbGlzdCA9ICooc3RydWN0IHB0cl9saXN0KiopcHB0
cjsKKwlzdHJ1Y3Qgc2hhZG93X3B0ciAqc3AgPSBjcmVhdGVfc2hhZG93X3BvaW50ZXIocHB0cik7
CisJaWYgKHNwKSB7CisJCWludCBuID0gcHRyX2xpc3Rfc2l6ZShsaXN0KTsKKwkJaW50IGxpc3Rz
aXplID0gKG4gKyAxKSAqIHNpemVvZiAodW5zaWduZWQgaW50KTsKKwkJdW5zaWduZWQgaW50ICpj
dXIsICpsaXN0X29iamVjdCA9ICh1bnNpZ25lZCBpbnQqKSBfX2FsbG9jX29iamVjdChsaXN0c2l6
ZSk7CisJCSpsaXN0X29iamVjdCA9IG47CisJCWN1ciA9IGxpc3Rfb2JqZWN0ICsgMTsKKwkJcmVn
aXN0ZXJfb2JqZWN0KFBUUl9MSVNULCBsaXN0X29iamVjdCwgbGlzdHNpemUsIHNwLCAodm9pZCAq
KikgcHB0cik7CisJCXZvaWQgKnA7CisKKwkJRk9SX0VBQ0hfUFRSKGxpc3QsIHApIHsKKwkJCWlm
IChzaXplKQorCQkJCXdyaXRlcl9jb252ZXJ0X29iamVjdCh0eXBlLCAmcCwgc2l6ZSwgdHJhdmVy
c2UsIGRhdGEpOworCQkJKmN1cisrID0gKHVuc2lnbmVkIGludClwOworCQl9IEVORF9GT1JfRUFD
SF9QVFIocCk7CisJfQorfQorCitzdGF0aWMgdm9pZCB3cml0ZXJfY29udmVydF9zdHJpbmcoc3Ry
dWN0IHN0cmluZyAqKnBwdHIsIHZvaWQgKmRhdGEpCit7CisJc3RydWN0IHN0cmluZyAqc3RyaW5n
ID0gKnBwdHI7CisJc3RydWN0IHNoYWRvd19wdHIgKnNwID0gY3JlYXRlX3NoYWRvd19wb2ludGVy
KHBwdHIpOworCWlmIChzcCkgeworCQlpbnQgc2l6ZSA9IHNpemVvZiAqc3RyaW5nICsgc3RyaW5n
LT5sZW5ndGg7CisJCXJlZ2lzdGVyX29iamVjdChQVFJfU1RSSU5HLCBzdHJpbmcsIHNpemUsIHNw
LCAodm9pZCoqKSBwcHRyKTsKKwl9Cit9CisKK3N0YXRpYyB2b2lkIHdyaXRlcl9jb252ZXJ0X2No
YXJzdHJpbmcoY2hhciAqKnBwdHIsIHZvaWQgKmRhdGEpCit7CisJY2hhciAqc3RyaW5nID0gKnBw
dHI7CisJc3RydWN0IHNoYWRvd19wdHIgKnNwID0gY3JlYXRlX3NoYWRvd19wb2ludGVyKHBwdHIp
OworCWlmIChzcCkgeworCQlpbnQgc2l6ZSA9IHN0cmxlbihzdHJpbmcpICsgMTsKKwkJcmVnaXN0
ZXJfb2JqZWN0KFBUUl9DSEFSU1RSSU5HLCBzdHJpbmcsIHNpemUsIHNwLCAodm9pZCoqKSBwcHRy
KTsKKwl9Cit9CisKK3N0YXRpYyB2b2lkIHdyaXRlcl9jb252ZXJ0X3Bvc2lzdGlvbihzdHJ1Y3Qg
cG9zaXRpb24gKnBvcywgdm9pZCAqZGF0YSkKK3sKKwlzdHJ1Y3Qgc3RyZWFtICpzdHJlYW0gPSBp
bnB1dF9zdHJlYW1zICsgcG9zLT5zdHJlYW07CisJY2hhciAqbmFtZSA9IChjaGFyKikgc3RyZWFt
LT5uYW1lOworCXN0cnVjdCBzaGFkb3dfcHRyICpzcCA9IGNyZWF0ZV9zaGFkb3dfcG9pbnRlcigm
c3RyZWFtKTsKKwlpZiAoc3ApIHsKKwkJcmVnaXN0ZXJfb2JqZWN0KFBUUl9TVFJFQU1fTkFNRSwg
bmFtZSwgc3RybGVuKG5hbWUpICsgMSwgc3AsICh2b2lkKiopICZzdHJlYW0pOworCX0KKwlwb3Mt
PnN0cmVhbSA9ICh1bnNpZ25lZCBpbnQpIHN0cmVhbTsKK30KKworc3RhdGljIHZvaWQgd3JpdGVy
X2NvbnZlcnRfaWRlbnQoc3RydWN0IGlkZW50ICoqcGlkZW50LCB2b2lkICpkYXRhKQoreworCXN0
cnVjdCBpZGVudCAqaWRlbnQgPSAqcGlkZW50OworCXN0cnVjdCBzaGFkb3dfcHRyICpzcCA9IGNy
ZWF0ZV9zaGFkb3dfcG9pbnRlcihwaWRlbnQpOworCWlmIChzcCkgeworCQlpbnQgc2l6ZSA9IGlk
ZW50LT5sZW4gKyBzaXplb2YgKmlkZW50OworCQlyZWdpc3Rlcl9vYmplY3QoUFRSX0lERU5ULCBp
ZGVudCwgc2l6ZSwgc3AsICh2b2lkKiopIHBpZGVudCk7CisJfQorfQorCitzdGF0aWMgc3RydWN0
IGNvbnZlcnRfb3Agd3JpdGVyX29wID0geworCS5jb252ZXJ0X3B0ciA9IHdyaXRlcl9jb252ZXJ0
X29iamVjdCwKKwkuY29udmVydF9saXN0ID0gd3JpdGVyX2NvbnZlcnRfcHRyX2xpc3QsCisJLmNv
bnZlcnRfcG9zaXRpb24gPSB3cml0ZXJfY29udmVydF9wb3Npc3Rpb24sCisJLmNvbnZlcnRfc3Ry
aW5nID0gd3JpdGVyX2NvbnZlcnRfc3RyaW5nLAorCS5jb252ZXJ0X2NoYXJzdHJpbmcgPSB3cml0
ZXJfY29udmVydF9jaGFyc3RyaW5nLAorCS5jb252ZXJ0X2lkZW50ID0gd3JpdGVyX2NvbnZlcnRf
aWRlbnQsCit9OworCitzdGF0aWMgc2l6ZV90IGNhY2x1YXRlX3NpemUodm9pZCkKK3sKKwlpbnQg
aTsKKwlzaXplX3QgdG90YWwgPSAwOworCWZvciAoaSA9IDA7IGkgPCBQVFJfTEFTVDsgaSsrKSB7
CisJCXRvdGFsICs9IG9iamVjdF90YWJsZVtpXS50b3RhbHNpemU7CisJCXByaW50ZigiJXMgc2l6
ZSAlZFxuIiwgb2JqZWN0X3R5cGVuYW1lKGkpLCBvYmplY3RfdGFibGVbaV0udG90YWxzaXplKTsK
Kwl9CisJcmV0dXJuIHRvdGFsOworfQorCitzdGF0aWMgaW50IHJlZ2lzdGVyX3N5bWJvbF9pZGVu
dHMoc3RydWN0IHN5bWJvbF9saXN0ICpzeW1zKQoreworCXN0cnVjdCBzeW1ib2wgKnN5bTsKKwlp
bnQgb3JpZyA9IG9iamVjdF90YWJsZVtQVFJfSURFTlRdLmNvdW50OworCisJRk9SX0VBQ0hfUFRS
KHN5bXMsIHN5bSkgeworCQlzdHJ1Y3QgaWRlbnQgKmlkZW50ID0gc3ltLT5pZGVudDsKKwkJd3Jp
dGVyX2NvbnZlcnRfaWRlbnQoJmlkZW50LCBOVUxMKTsKKwl9IEVORF9GT1JfRUFDSF9QVFIoc3lt
KTsKKworCXJldHVybiBvYmplY3RfdGFibGVbUFRSX0lERU5UXS5jb3VudCAtIG9yaWc7Cit9CisK
K3N0YXRpYyBzaXplX3Qgd3JpdGVfZml4c2l6ZV9vYmplY3Qoc3RydWN0IGJ5dGVjb2RlX2hkciAq
aGRyLCBpbnQgdHlwZSwgc2l6ZV90IG9mZnNldCkKK3sKKwlzdHJ1Y3Qgb2JqZWN0X3RhYmxlICpl
bnRyeSA9IG9iamVjdF90YWJsZSArIHR5cGU7CisJc3RydWN0IG9iamVjdF9oZWFkZXIgKmhlYWRl
ciA9IGhkci0+aGVhZGVycyArIHR5cGU7CisJaW50IHNpemUgPSBlbnRyeS0+c2l6ZTsKKwl2b2lk
ICpwdHI7CisJY2hhciAqYnVmZmVyID0gKChjaGFyKikgaGRyKSArICBvZmZzZXQ7CisJCisJaGVh
ZGVyLT50eXBlID0gdHlwZTsKKwloZWFkZXItPm9mZnNldCA9IG9mZnNldDsKKwloZWFkZXItPmNv
dW50ID0gZW50cnktPmNvdW50OworCWhlYWRlci0+c2l6ZSA9IGVudHJ5LT50b3RhbHNpemU7CisK
KwlvZmZzZXQgPSAwOworCUZPUl9FQUNIX1BUUihlbnRyeS0+b2JqZWN0X2xpc3QsIHB0cikgewor
CQltZW1jcHkoYnVmZmVyICsgb2Zmc2V0LCBwdHIsIHNpemUpOworCQlvZmZzZXQgKz0gc2l6ZTsK
Kwl9IEVORF9GT1JfRUFDSF9QVFIocHRyKTsKKwlyZXR1cm4gb2Zmc2V0OworfQorCitzdGF0aWMg
c2l6ZV90IHdyaXRlX2lkZW50KHN0cnVjdCBieXRlY29kZV9oZHIgKmhkciwgc2l6ZV90IG9mZnNl
dCkKK3sKKwlzdHJ1Y3Qgb2JqZWN0X3RhYmxlICplbnRyeSA9IG9iamVjdF90YWJsZSArIFBUUl9J
REVOVDsKKwlzdHJ1Y3Qgb2JqZWN0X2hlYWRlciAqaGVhZGVyID0gaGRyLT5oZWFkZXJzICsgUFRS
X0lERU5UOworCXN0cnVjdCBpZGVudCAqaWRlbnQ7CisJc3RydWN0IGlkZW50X2xpc3QgKmxpc3Qg
PSAoc3RydWN0IGlkZW50X2xpc3QqKSBlbnRyeS0+b2JqZWN0X2xpc3Q7CisJY2hhciAqYnVmZmVy
ID0gKChjaGFyKikgaGRyKSArICBvZmZzZXQ7CisKKwloZWFkZXItPnR5cGUgPSBQVFJfSURFTlQ7
CisJaGVhZGVyLT5vZmZzZXQgPSBvZmZzZXQ7CisJaGVhZGVyLT5jb3VudCA9IGVudHJ5LT5jb3Vu
dDsKKwloZWFkZXItPnNpemUgPSBlbnRyeS0+dG90YWxzaXplOworCisJb2Zmc2V0ID0gMDsKKwlG
T1JfRUFDSF9QVFIobGlzdCwgaWRlbnQpIHsKKwkJbWVtY3B5KGJ1ZmZlciArIG9mZnNldCwgaWRl
bnQtPm5hbWUsIGlkZW50LT5sZW4pOworCQlidWZmZXJbb2Zmc2V0ICsgaWRlbnQtPmxlbl0gPSAn
XDAnOworCQlvZmZzZXQgKz0gaWRlbnQtPmxlbiArIDE7CisJfSBFTkRfRk9SX0VBQ0hfUFRSKGlk
ZW50KTsKKworCWhlYWRlci0+c2l6ZSA9IG9mZnNldDsKKwlyZXR1cm4gb2Zmc2V0OworfQorCitz
dGF0aWMgc2l6ZV90IHdyaXRlX3N0cmluZyhzdHJ1Y3QgYnl0ZWNvZGVfaGRyICpoZHIsIHNpemVf
dCBvZmZzZXQpCit7CisJc3RydWN0IG9iamVjdF90YWJsZSAqZW50cnkgPSBvYmplY3RfdGFibGUg
KyBQVFJfU1RSSU5HOworCXN0cnVjdCBvYmplY3RfaGVhZGVyICpoZWFkZXIgPSBoZHItPmhlYWRl
cnMgKyBQVFJfU1RSSU5HOworCXZvaWQgKnB0cjsKKwljaGFyICpidWZmZXIgPSAoKGNoYXIqKSBo
ZHIpICsgIG9mZnNldDsKKworCWhlYWRlci0+dHlwZSA9IFBUUl9TVFJJTkc7CisJaGVhZGVyLT5v
ZmZzZXQgPSBvZmZzZXQ7CisJaGVhZGVyLT5jb3VudCA9IGVudHJ5LT5jb3VudDsKKwloZWFkZXIt
PnNpemUgPSBlbnRyeS0+dG90YWxzaXplOworCisJb2Zmc2V0ID0gMDsKKwlGT1JfRUFDSF9QVFIo
ZW50cnktPm9iamVjdF9saXN0LCBwdHIpIHsKKwkJc3RydWN0IHN0cmluZyAqc3RyaW5nID0gKHN0
cnVjdCBzdHJpbmcgKikgcHRyOworCQlpbnQgc2l6ZSA9IHNpemVvZiAqc3RyaW5nICsgc3RyaW5n
LT5sZW5ndGg7CisJCW1lbWNweShidWZmZXIgKyBvZmZzZXQsIHB0ciwgc2l6ZSk7CisJCW9mZnNl
dCArPSBzaXplOworCX0gRU5EX0ZPUl9FQUNIX1BUUihwdHIpOworCXJldHVybiBvZmZzZXQ7Cit9
CisKK3N0YXRpYyBzaXplX3Qgd3JpdGVfY2hhcnN0cmluZyhzdHJ1Y3QgYnl0ZWNvZGVfaGRyICpo
ZHIsIGludCB0eXBlLCBzaXplX3Qgb2Zmc2V0KQoreworCXN0cnVjdCBvYmplY3RfdGFibGUgKmVu
dHJ5ID0gb2JqZWN0X3RhYmxlICsgdHlwZTsKKwlzdHJ1Y3Qgb2JqZWN0X2hlYWRlciAqaGVhZGVy
ID0gaGRyLT5oZWFkZXJzICsgdHlwZTsKKwl2b2lkICpwdHI7CisJY2hhciAqYnVmZmVyID0gKChj
aGFyKikgaGRyKSArICBvZmZzZXQ7CisKKwloZWFkZXItPnR5cGUgPSB0eXBlOworCWhlYWRlci0+
b2Zmc2V0ID0gb2Zmc2V0OworCWhlYWRlci0+Y291bnQgPSBlbnRyeS0+Y291bnQ7CisJaGVhZGVy
LT5zaXplID0gZW50cnktPnRvdGFsc2l6ZTsKKworCW9mZnNldCA9IDA7CisJRk9SX0VBQ0hfUFRS
KGVudHJ5LT5vYmplY3RfbGlzdCwgcHRyKSB7CisJCWludCBzaXplID0gc3RybGVuKHB0cik7CisJ
CXN0cm5jcHkoYnVmZmVyICsgb2Zmc2V0LCBwdHIsIHNpemUpOworCQlidWZmZXJbb2Zmc2V0ICsg
c2l6ZV0gPSAnXDAnOworCQlvZmZzZXQgKz0gc2l6ZSArIDE7CisJfSBFTkRfRk9SX0VBQ0hfUFRS
KHB0cik7CisJcmV0dXJuIG9mZnNldDsKK30KKworc3RhdGljIHNpemVfdCB3cml0ZV9saXN0KHN0
cnVjdCBieXRlY29kZV9oZHIgKmhkciwgc2l6ZV90IG9mZnNldCkKK3sKKwlzdHJ1Y3Qgb2JqZWN0
X3RhYmxlICplbnRyeSA9IG9iamVjdF90YWJsZSArIFBUUl9MSVNUOworCXN0cnVjdCBvYmplY3Rf
aGVhZGVyICpoZWFkZXIgPSBoZHItPmhlYWRlcnMgKyBQVFJfTElTVDsKKwl2b2lkICpwdHI7CisJ
Y2hhciAqYnVmZmVyID0gKChjaGFyKikgaGRyKSArICBvZmZzZXQ7CisKKwloZWFkZXItPnR5cGUg
PSBQVFJfTElTVDsKKwloZWFkZXItPm9mZnNldCA9IG9mZnNldDsKKwloZWFkZXItPmNvdW50ID0g
ZW50cnktPmNvdW50OworCWhlYWRlci0+c2l6ZSA9IGVudHJ5LT50b3RhbHNpemU7CisKKwlvZmZz
ZXQgPSAwOworCUZPUl9FQUNIX1BUUihlbnRyeS0+b2JqZWN0X2xpc3QsIHB0cikgeworCQlpbnQg
c2l6ZSA9ICgoKih1bnNpZ25lZCBpbnQqKXB0cikgKyAxKSAqIHNpemVvZiAodW5zaWduZWQgaW50
KTsKKwkJbWVtY3B5KGJ1ZmZlciArIG9mZnNldCwgcHRyLCBzaXplKTsKKwkJb2Zmc2V0ICs9IHNp
emU7CisJfSBFTkRfRk9SX0VBQ0hfUFRSKHB0cik7CisJcmV0dXJuIG9mZnNldDsKK30KKworc3Rh
dGljIHZvaWQgd3JpdGVfZmlsZShjaGFyICpmaWxlbmFtZSwgc3RydWN0IHByb2dyYW0gKnByb2cp
Cit7CisJc3RydWN0IGJ5dGVjb2RlX2hkciBoZHIgPSB7fSwgKmJoZHI7CisJc3RydWN0IHByb2dy
YW0gY3Byb2cgPSAqcHJvZzsKKwlpbnQgZmQgPSBvcGVuKGZpbGVuYW1lLCBPX1JEV1IgfCBPX0NS
RUFUIHwgT19UUlVOQywgMDY0NCk7CisJc2l6ZV90IG9mZnNldCA9IDAsIHRvdGFsOworCWludCBo
ZHJzaXplID0gc2l6ZW9mIGhkciArIFBUUl9MQVNUICogc2l6ZW9mIChzdHJ1Y3Qgb2JqZWN0X2hl
YWRlcik7CisJdm9pZCAqYnVmZmVyOworCWludCBpOworCisJaWYgKGZkIDwgMCkKKwkJZGllKCJl
cnJvciBvcGVuaW5nIGZpbGUgJXNcbiIsIGZpbGVuYW1lKTsKKworCXdyaXRlcl9pbml0KCk7CisK
KwloZHIuZXhwb3J0X3N5bWJvbHMgPSByZWdpc3Rlcl9zeW1ib2xfaWRlbnRzKHByb2ctPmV4cG9y
dF9zeW1zKTsKKwloZHIuaW50ZXJuYWxfc3ltYm9scyA9IHJlZ2lzdGVyX3N5bWJvbF9pZGVudHMo
cHJvZy0+c3ltYm9scyk7CisJaGRyLmltcG9ydF9zeW1ib2xzID0gcmVnaXN0ZXJfc3ltYm9sX2lk
ZW50cyhwcm9nLT5pbXBvcnRfc3ltcyk7CisKKwlwcmludGYgKCJleHBvcnQgc3ltcyAlZCBpbnRl
cm5hbCAlZCBpbXBvcnQgJWRcbiIsIGhkci5leHBvcnRfc3ltYm9scywgaGRyLmludGVybmFsX3N5
bWJvbHMsIGhkci5pbXBvcnRfc3ltYm9scyk7CisKKwl3cml0ZXJfY29udmVydF9wdHJfbGlzdChQ
VFJfU1lNQk9MLCAmY3Byb2cuc3ltYm9scywgc2l6ZW9mKHN0cnVjdCBzeW1ib2wpLAorCQkJCXRy
YXZlcnNlX3N5bWJvbCwgTlVMTCk7CisJd3JpdGVyX2NvbnZlcnRfcHRyX2xpc3QoUFRSX0VOVFJZ
UE9JTlQsICZjcHJvZy5mdW5jdGlvbl9saXN0LCBzaXplb2Yoc3RydWN0IGVudHJ5cG9pbnQpLAor
CQkJCXRyYXZlcnNlX2VudHJ5cG9pbnQsIE5VTEwpOworCWhkci5zeW1ib2xfbGlzdCA9ICh1bnNp
Z25lZCBpbnQpIGNwcm9nLnN5bWJvbHM7CisJaGRyLmZ1bmN0aW9uX2xpc3QgPSAodW5zaWduZWQg
aW50KSBjcHJvZy5mdW5jdGlvbl9saXN0OworCisJdG90YWwgPSBjYWNsdWF0ZV9zaXplKCkgKyBo
ZHJzaXplOworCisJZnRydW5jYXRlKGZkLCB0b3RhbCk7CisJYnVmZmVyID0gbW1hcChOVUxMLCB0
b3RhbCAsIFBST1RfUkVBRCB8IFBST1RfV1JJVEUsCisJCSAgICAgIE1BUF9TSEFSRUQsIGZkLCAw
KTsKKworCWlmIChidWZmZXIgPT0gTUFQX0ZBSUxFRCkKKwkJZGllKCJlcnJvciBtbWFwaW5nIGZp
bGUgJXMgd2l0aCBzaXplICVseFxuIiwgZmlsZW5hbWUsICh1bnNpZ25lZCBsb25nKXRvdGFsKTsK
KworCW1lbWNweShidWZmZXIsICZoZHIsIHNpemVvZiBoZHIpOworCWJoZHIgPSAoc3RydWN0IGJ5
dGVjb2RlX2hkciopIGJ1ZmZlcjsKKwlvZmZzZXQgKz0gaGRyc2l6ZTsKKworCW9mZnNldCArPSB3
cml0ZV9pZGVudChiaGRyLCBvZmZzZXQpOworCW9mZnNldCArPSB3cml0ZV9zdHJpbmcoYmhkciwg
b2Zmc2V0KTsKKwlvZmZzZXQgKz0gd3JpdGVfY2hhcnN0cmluZyhiaGRyLCBQVFJfU1RSRUFNX05B
TUUsb2Zmc2V0KTsKKwlvZmZzZXQgKz0gd3JpdGVfY2hhcnN0cmluZyhiaGRyLCBQVFJfQ0hBUlNU
UklORywgb2Zmc2V0KTsKKwlvZmZzZXQgKz0gd3JpdGVfbGlzdChiaGRyLCBvZmZzZXQpOworCisJ
Zm9yIChpID0gMDsgaSA8IFBUUl9WQVJTSVpFOyBpKyspCisJCW9mZnNldCArPSB3cml0ZV9maXhz
aXplX29iamVjdChiaGRyLCBpLCBvZmZzZXQpOworCW11bm1hcChidWZmZXIsIHRvdGFsKTsKKwlm
dHJ1bmNhdGUoZmQsIG9mZnNldCk7CisJcHJpbnRmKCJ0b2Fsc2l6ZSAlZFxuIiwgb2Zmc2V0KTsK
KwljbG9zZShmZCk7Cit9CisKK3ZvaWQgd3JpdGVfYnl0ZWNvZGUoY2hhciAqZmlsZW5hbWUsIHN0
cnVjdCBzeW1ib2xfbGlzdCAqc3ltcykKK3sKKwlzdHJ1Y3Qgc3ltYm9sICpzeW07CisJc3RydWN0
IHByb2dyYW0gcHJvZyA9IHt9OworCXN0cnVjdCBlbnRyeXBvaW50ICplcDsKKworCisJcHJvZy5z
eW1ib2xzID0gc3ltczsKKwlwcm9nLmltcG9ydF9zeW1zID0gTlVMTDsKKworCUZPUl9FQUNIX1BU
UihzeW1zLCBzeW0pIHsKKwkJZXhwYW5kX3N5bWJvbChzeW0pOworCQllcCA9IGxpbmVhcml6ZV9z
eW1ib2woc3ltKTsKKworCQlpZiAoIShzeW0tPmN0eXBlLm1vZGlmaWVycyAmIE1PRF9TVEFUSUMp
KQorCQkJYWRkX3N5bWJvbCgmcHJvZy5leHBvcnRfc3ltcywgc3ltKTsKKworCQlpZiAoZXApIHsK
KwkJCXN0cnVjdCBwc2V1ZG8gKnA7CisJCQlzdHJ1Y3Qgc3ltYm9sICpzOworCQkJYWRkX3B0cl9s
aXN0KCZwcm9nLmZ1bmN0aW9uX2xpc3QsIGVwKTsKKwkJCUZPUl9FQUNIX1BUUihlcC0+YWNjZXNz
ZXMsIHApIHsKKwkJCQlzdHJ1Y3QgaWRlbnQgKmlkZW50OworCQkJCXMgPSBwLT5zeW07CisJCQkJ
aWYgKCEocy0+Y3R5cGUubW9kaWZpZXJzICYgTU9EX0VYVEVSTikpCisJCQkJCWNvbnRpbnVlOwor
CQkJCWlmICghKGlkZW50ID0gcy0+aWRlbnQpKQorCQkJCQljb250aW51ZTsKKwkJCQlpZiAoZmlu
ZF9wdHJfaW5fbGlzdCgoc3RydWN0IHB0cl9saXN0ICopcHJvZy5pbXBvcnRfc3ltcywgcykpCisJ
CQkJCWNvbnRpbnVlOworCQkJCWFkZF9zeW1ib2woJnByb2cuaW1wb3J0X3N5bXMsIHMpOworCQkJ
fSBFTkRfRk9SX0VBQ0hfUFRSKHApOworCQl9CisJfSBFTkRfRk9SX0VBQ0hfUFRSKHN5bSk7CisK
Kwl3cml0ZV9maWxlKGZpbGVuYW1lLCAmcHJvZyk7Cit9CisKSW5kZXg6IHNwYXJzZS90ZXN0LXdy
aXRlLmMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PQotLS0gc3BhcnNlLm9yaWcvdGVzdC13cml0ZS5jCisrKyBzcGFyc2Uv
dGVzdC13cml0ZS5jCkBAIC0wLDAgKzEsNTQgQEAKKy8qCisgKiBUZXN0IHByb2dyYW0gZm9yIGR1
bXBpbmcgdGhlIHNwYXJzZSBwYXJzaW5nIHJlc3VsdCBpbnRvCisgKiBieXRlY29kZSBmaWxlcy4K
KyAqCisgKiAgQ29weXJpZ2h0IChDKSAyMDA4IENocmlzdG9waGVyIExpLgorICoKKyAqIExpY2Vu
c2VkIHVuZGVyIHRoZSBPcGVuIFNvZnR3YXJlIExpY2Vuc2UgdmVyc2lvbiAxLjEKKyAqLworCisK
KyNpbmNsdWRlIDxzdGRpby5oPgorI2luY2x1ZGUgPHN0ZGxpYi5oPgorI2luY2x1ZGUgPHN0cmlu
Zy5oPgorI2luY2x1ZGUgPHVuaXN0ZC5oPgorI2luY2x1ZGUgPGZjbnRsLmg+CisKKyNpbmNsdWRl
ICJsaWIuaCIKKyNpbmNsdWRlICJhbGxvY2F0ZS5oIgorI2luY2x1ZGUgInN5bWJvbC5oIgorI2lu
Y2x1ZGUgImV4cHJlc3Npb24uaCIKKyNpbmNsdWRlICJsaW5lYXJpemUuaCIKKyNpbmNsdWRlICJi
eXRlY29kZS5oIgorCitzdHJ1Y3Qgc3RyZWFtX2xpc3QgKnVzZWRfc3RyZWFtID0gTlVMTDsKKwor
c3RhdGljIHZvaWQgd3JpdGVfb25lX2ZpbGUoY2hhciAqc3JjZmlsZSkKK3sKKwljaGFyICpvdXRm
aWxlOworCWludCBlbmQ7CisJc3RydWN0IHN5bWJvbF9saXN0ICpzeW1zOworCisJb3V0ZmlsZSA9
IHN0cmR1cChzcmNmaWxlKTsKKwlpZiAoIW91dGZpbGUpCisJCWRpZSgib3V0IG9mIG1lbW9yeSAl
c1xuIiwgc3JjZmlsZSk7CisJZW5kID0gc3RybGVuKG91dGZpbGUpOworCWlmIChlbmQgPD0gMiB8
fCBvdXRmaWxlIFtlbmQgLSAxXSAhPSAnYycpCisJCWRpZSgibm90IGEgYyBmaWxlIik7CisJb3V0
ZmlsZVtlbmQgLSAxXSA9ICdiJzsKKwlzeW1zID0gc3BhcnNlKHNyY2ZpbGUpOworCXdyaXRlX2J5
dGVjb2RlKG91dGZpbGUsIHN5bXMpOworCWZyZWUob3V0ZmlsZSk7Cit9CisKK2ludCBtYWluKGlu
dCBhcmdjLCBjaGFyICoqYXJndikKK3sKKwlzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmZpbGVsaXN0ID0g
TlVMTDsKKwljaGFyICpmaWxlOworCisJc3BhcnNlX2luaXRpYWxpemUoYXJnYywgYXJndiwgJmZp
bGVsaXN0KTsKKwlGT1JfRUFDSF9QVFJfTk9UQUcoZmlsZWxpc3QsIGZpbGUpIHsKKwkJd3JpdGVf
b25lX2ZpbGUoZmlsZSk7CisJfSBFTkRfRk9SX0VBQ0hfUFRSX05PVEFHKGZpbGUpOworCXJldHVy
biAwOworfQpJbmRleDogc3BhcnNlL3RyYXZlcnNlLmgKPT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3BhcnNlLm9y
aWcvdHJhdmVyc2UuaAorKysgc3BhcnNlL3RyYXZlcnNlLmgKQEAgLTAsMCArMSw4NyBAQAorLyoK
KyAqIHRyYXZlcnNlLmgKKyAqCisgKiBDb3B5cmlnaHQgKEMpIDIwMDggQ2hyaXN0b3BoZXIgTGku
CisgKgorICogTGljZW5zZWQgdW5kZXIgdGhlIE9wZW4gU29mdHdhcmUgTGljZW5zZSB2ZXJzaW9u
IDEuMQorICovCisKKyNpbmNsdWRlICJzeW1ib2wuaCIKKyNpbmNsdWRlICJleHByZXNzaW9uLmgi
CisKK3N0cnVjdCBjb252ZXJ0X29wOworCitlbnVtIHB0cl90eXBlIHsKKwkvKiBmaXggc2l6ZSBv
YmplY3RzICovCisJUFRSX0lOU04sCisJUFRSX0VOVFJZUE9JTlQsCisJUFRSX0JBU0lDQkxPQ0ss
CisJUFRSX1BTRVVETywKKwlQVFJfUFNFVURPX1VTRVIsCisJUFRSX0FTTV9DT05TVFJBSU5ULAor
CVBUUl9TWU1CT0wsCisJUFRSX0FTTV9SVUxFUywKKwlQVFJfTVVMVElKTVAsCisJUFRSX0VYUFIs
CisKKwkvKiB2YXJpYWJsZSBzaXplIG9iamVjdHMgKi8KKwlQVFJfVkFSU0laRSwKKwlQVFJfSURF
TlQgPSBQVFJfVkFSU0laRSwKKwlQVFJfU1RSSU5HLAorCVBUUl9DSEFSU1RSSU5HLAorCVBUUl9T
VFJFQU1fTkFNRSwKKwlQVFJfTElTVCwKKwlQVFJfTEFTVCwKK307CisKKwordHlwZWRlZiB2b2lk
ICgqdHJhdmVyc2VfdCkoc3RydWN0IGNvbnZlcnRfb3AqLCB2b2lkICosIHZvaWQgKik7CisKK3N0
cnVjdCBjb252ZXJ0X29wIHsKKwl2b2lkICgqY29udmVydF9wdHIpKGludCB0eXBlLCB2b2lkICpw
dHIsIGludCBzaXplLCB0cmF2ZXJzZV90IGZ1bmMsIHZvaWQgKmRhdGEpOworCXZvaWQgKCpjb252
ZXJ0X2xpc3QpKGludCB0eXBlLCB2b2lkICpwdHIsIGludCBzaXplLCB0cmF2ZXJzZV90IGZ1bmMs
IHZvaWQgKmRhdGEpOworCXZvaWQgKCpjb252ZXJ0X3Bvc2l0aW9uKShzdHJ1Y3QgcG9zaXRpb24q
LCB2b2lkICpkYXRhKTsKKwl2b2lkICgqY29udmVydF9zdHJpbmcpKHN0cnVjdCBzdHJpbmcqKiwg
dm9pZCAqZGF0YSk7CisJdm9pZCAoKmNvbnZlcnRfY2hhcnN0cmluZykoY2hhciAqKiwgdm9pZCAq
ZGF0YSk7CisJdm9pZCAoKmNvbnZlcnRfaWRlbnQpKHN0cnVjdCBpZGVudCoqLCB2b2lkICpkYXRh
KTsKK307CisKK3ZvaWQgdHJhdmVyc2VfZW50cnlwb2ludChzdHJ1Y3QgY29udmVydF9vcCosIHZv
aWQgKnB0ciwgdm9pZCAqZGF0YSk7Cit2b2lkIHRyYXZlcnNlX2Jhc2ljX2Jsb2NrKHN0cnVjdCBj
b252ZXJ0X29wKiwgdm9pZCAqcHRyLCB2b2lkICpkYXRhKTsKK3ZvaWQgdHJhdmVyc2VfbXVsdGlq
bXAoc3RydWN0IGNvbnZlcnRfb3AqLCB2b2lkICpwdHIsIHZvaWQgKmRhdGEpOwordm9pZCB0cmF2
ZXJzZV9pbnN0cnVjdGlvbihzdHJ1Y3QgY29udmVydF9vcCosIHZvaWQgKnB0ciwgdm9pZCAqZGF0
YSk7Cit2b2lkIHRyYXZlcnNlX3N5bWJvbChzdHJ1Y3QgY29udmVydF9vcCosIHZvaWQgKnB0ciwg
dm9pZCAqZGF0YSk7Cit2b2lkIHRyYXZlcnNlX3BzZXVkbyhzdHJ1Y3QgY29udmVydF9vcCAqb3As
IHZvaWQgKnB0ciwgdm9pZCAqZGF0YSk7Cit2b2lkIHRyYXZlcnNlX2FzbV9jb25zdHJhaW50KHN0
cnVjdCBjb252ZXJ0X29wKiwgdm9pZCAqcHRyLCB2b2lkICpkYXRhKTsKK3ZvaWQgdHJhdmVyc2Vf
YXNtX3J1bGVzKHN0cnVjdCBjb252ZXJ0X29wKiwgdm9pZCAqcHRyLCB2b2lkICpkYXRhKTsKK3Zv
aWQgdHJhdmVyc2VfZXhwcmVzc2lvbihzdHJ1Y3QgY29udmVydF9vcCosIHZvaWQgKnB0ciwgdm9p
ZCAqZGF0YSk7CisKK2V4dGVybiBjb25zdCBjaGFyKiBvYmplY3RfdHlwZW5hbWUoaW50IHR5cGUp
OworZXh0ZXJuIGludCB0cmF2ZXJzZV9sZXZlbDsKKworI2RlZmluZSBERUNMQVJFX1BUUl9DT05W
RVJUT1IoZSwgbikJCQkJCQkJXAorCXN0YXRpYyBpbmxpbmUgdm9pZCBjb252ZXJ0XyMjbihzdHJ1
Y3QgY29udmVydF9vcCAqb3AsIHN0cnVjdCBuICoqbiwgdm9pZCAqZGF0YSkJXAorCXsJCQkJCQkJ
CQkJXAorCQlvcC0+Y29udmVydF9wdHIoZSwgbiwgc2l6ZW9mICoqbiwgdHJhdmVyc2VfIyNuLCBk
YXRhKTsJCQlcCisJfSAJCQkJCQkJCQkJXAorCisKKyNkZWZpbmUgREVDTEFSRV9MSVNUX0NPTlZF
UlRPUihlLCBuKQkJCQkJCQlcCisJc3RhdGljIGlubGluZSB2b2lkIGNvbnZlcnRfIyNuIyNfbGlz
dChzdHJ1Y3QgY29udmVydF9vcCAqb3AsIHN0cnVjdCBuIyNfbGlzdCAqKm4sIHZvaWQgKmRhdGEp
XAorCXsJCQkJCQkJCQkJXAorCQlvcC0+Y29udmVydF9saXN0KGUsIG4sIHNpemVvZiAqKCpuKS0+
bGlzdFswXSwgdHJhdmVyc2VfIyNuLCBkYXRhKTsJXAorCX0gCQkJCQkJCQkJCVwKKworI2RlZmlu
ZSBERUNMQVJFX0NPTlZFUlRPUihlLG4pCURFQ0xBUkVfUFRSX0NPTlZFUlRPUihlLCBuKSBERUNM
QVJFX0xJU1RfQ09OVkVSVE9SKGUsIG4pIAorCitERUNMQVJFX0NPTlZFUlRPUihQVFJfU1lNQk9M
LCBzeW1ib2wpOworREVDTEFSRV9DT05WRVJUT1IoUFRSX0VYUFIsIGV4cHJlc3Npb24pOworREVD
TEFSRV9DT05WRVJUT1IoUFRSX0VOVFJZUE9JTlQsIGVudHJ5cG9pbnQpOworREVDTEFSRV9DT05W
RVJUT1IoUFRSX1BTRVVETywgcHNldWRvKTsKK0RFQ0xBUkVfQ09OVkVSVE9SKFBUUl9CQVNJQ0JM
T0NLLCBiYXNpY19ibG9jayk7CitERUNMQVJFX0NPTlZFUlRPUihQVFJfSU5TTiwgaW5zdHJ1Y3Rp
b24pOworREVDTEFSRV9DT05WRVJUT1IoUFRSX01VTFRJSk1QLCBtdWx0aWptcCk7CitERUNMQVJF
X0NPTlZFUlRPUihQVFJfQVNNX0NPTlNUUkFJTlQsIGFzbV9jb25zdHJhaW50KTsKK0RFQ0xBUkVf
UFRSX0NPTlZFUlRPUihQVFJfQVNNX1JVTEVTLCBhc21fcnVsZXMpOworCisKSW5kZXg6IHNwYXJz
ZS90ZXN0LXJlYWQuYwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09CkluZGV4OiBzcGFyc2UvbGluZWFyaXplLmMKPT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PQo=
------=_Part_66870_7724490.1220506479546--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/10] Sparse linker ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 0/10] Sparse linker
Date: Wed, 03 Sep 2008 21:55:44 +0000
Message-ID: <1220478954-22678-1-git-send-email-alexey.zaytsev () gmail ! com>
--------------------
Hello.

I've been working on a "sparse linker" this summer as my Google
Summer of Code project. Wasn't neraly as productive as I hoped,
but I've got some results that I would like to share. Moreover,
I plan continuing this work, and would like to hear comments on
what was done so far.

The design didn't change much from what was proposed. We run
sparse to generate a "sparse object" file containing a list of
symbols, then run the "linker" to unite those object files into
bigger ones. This way, in the end we get a file containing all
the global symbols appearing in the program. After learning
more on the subject, I now agree that we should include the
intermediate code representation into the object files.

The implementation is built around a generic serialization
mechanism [PATCH 01]. It handles many sorts of complex data
structures, with pointers, cycles, unions, etc. E.g. it is able
to serialize beasts like the sparse pointer lists. The price
for this is a four byte overhead prepended to every
serializable structure by the allocation wrapper. Also, you
have to use a macro when declaring a serializable structure
(or an array of such) statically. One limitation I was unable
to overcome is the inability to work with structures used both
stand-alone and embedded into bigger ones. Luckily, we have no
such cases in the sparse codebase. The serializer produces C
code, containing the data structures beind serialized. For the
structure definitions, the generated code includes the original
headers, defining the structures. After serializing a bunch of
possibly interconnecded structures, and running cc over the
generated code, one might get a static or dynamic library
containing the copies of the serialized data structures, with
all the pointer interconnections included. This way loading
the data is trivial, and very memory efficient, and the whole
dump-restore process should be totally transparent, e.g. it
should be possible serialize the sparse() output, and run
check_symbols() after loading the data from an other program.
One thing that bothers me, is, if gcc would be able to process
the huge data files, containing all the "code" of bigger
projects like the Linux kernel. Will see.

Being able to serialize any data, generating the symbol lists
becomes as trivial as defining the data structures
corresponding to source files and symbols [PATCH 06], deriving
a symbol list from the sparse output, joining it into a ptr
list and serializing it [PATCH 07]. The linker needs to dlopen
the input "sparse objects", merge the symbol lists, and
serialize the result [PATCH 08]. The generated code compilation
is handled by the cgcc, cld and car wrappers [PATCH 09]. To
look up symbols in sparse object files, a simple program is
included [PATCH 10].

The plan is now to proceed with dumping the linearized code.

Please take a look at the code, ask if anything needs
clarification, and don't hesitate for criticism. If you've got
ideas on how the linker might be extended and used, or
have a different approach to the problem, please drop a message.

You can also look at the code at
http://svcs.cs.pdx.edu/gitweb?p=sparse-soc2008.git;a=shortlog;h=gsoc2008-linker

or grab it from
git://svcs.cs.pdx.edu/git/sparse-soc2008 branch gsoc2008-linker

For those brave that would actually like to see how it works,
that's how I'd run the thing over the sparse codebase:

make CC="cgcc -v -emit-code" LD=cld AR=car
and then
./where sparse.sparse.so linearize_statement

And no, the patches are not ment for mainline inclusion right
now.

P.S:
If you don't like being on the CC list, I'd miss your opinion,
but would drop you from any further notifications on the
project, just drop me a message.


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Fwd: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 01:16:24 +0000
Message-ID: <70318cbf0809031816m69565c5aj9417d9a2e136770d () mail ! gmail ! com>
--------------------
Oops, forget to CC the list.

Chris

---------- Forwarded message ----------
From: Chris Li <sparse@chrisli.org>
Date: Wed, Sep 3, 2008 at 6:08 PM
Subject: Re: [PATCH 0/10] Sparse linker
To: alexey.zaytsev@gmail.com


On Wed, Sep 3, 2008 at 2:55 PM,  <alexey.zaytsev@gmail.com> wrote:

> more on the subject, I now agree that we should include the
> intermediate code representation into the object files.

Good.

> for this is a four byte overhead prepended to every
> serializable structure by the allocation wrapper. Also, you

I would rather not have that 4 byte prepended to every
structure. Serialize is just one short stage of the life cycle
of those c structures. Having the permanent extra space
for just that is unnecessary. That 4 bytes meta data also
limits what C structure you can work on. All you need
is being able to map a point into some serialize object
to keep track which object is tracked and which one is not.

After you serialized the data. The meta data can be drop
completely. So the price to pay is for every unknown object
pointer, you need to do a dictionary look up. Only during
the dumping stage. But that price is actually very small,
when you dumping objects. You are mostly limit by the disk
any way. The plus side is: you can work with any objects.
You don't need to waste extra memory for serialization
when you are not doing serialization. You can leave the
object allocation code unchanged.

> have to use a macro when declaring a serializable structure
> (or an array of such) statically. One limitation I was unable
> to overcome is the inability to work with structures used both
> stand-alone and embedded into bigger ones. Luckily, we have no

Like the ctype member inside the "struct symbol"?

> list and serializing it [PATCH 07]. The linker needs to dlopen

Do you use the stander share library for dlopen and dynamic linking
the sparse objects?


> the input "sparse objects", merge the symbol lists, and
> serialize the result [PATCH 08]. The generated code compilation
> is handled by the cgcc, cld and car wrappers [PATCH 09]. To
> look up symbols in sparse object files, a simple program is
> included [PATCH 10].

Do you dump your sparse object in ELF format?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 07:27:40 +0000
Message-ID: <70318cbf0809040027i79476a4ds3d1086f5ca434d9d () mail ! gmail ! com>
--------------------
On Wed, Sep 3, 2008 at 9:03 PM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
> If I understand the question right, no. Every "sparse object" .so has a
> "struct ptr_list *symbols" entry (in fact, the only non-static entry) that
> points to the serialized ptr list of the "struct sold_symbol". The linker
> dlopen()'s the .so and hooks to the entry, for every input object file.
> After that, it simply calls ptr_list_concat() on the opened symbol lists,
> and serializes the resulting combined list. There is of course nothing
> wrong if we modify the data obtained from the .so, as it is cow-mmaped.
...
> Well, I serialize the data into C, and then compile it into .so, if
> that was the question. You might want to apply the first patch
> and look at the serialization-test output.

OK. I just realized that you are building a completely different kind
of "linker" than I have in mind.

Generate C source file and let gcc to compile and link it is an
interesting idea. But I think it is a step back wards.

For starts, how do you handle the case that the symbol from your
input file have conflict on the function define in the loader itself?

If I understand your plan correctly, I don't see how it can handle
the following case:

file a.c:

void foo(void) {
    printf("%p\n", &bar);
}

file b.c

bar() {
    printf("%p\n", &foo);
}

So do you put the extern symbol in your .so as symbol as well?
If you don't, how do you link the extern symbol to where it is defined?

If you do, then you can't load a.so alone because "bar" symbol is not
resolved. And you can't load b.so because "foo" symbol can't resolve.

If you link a.o and b.o together into ab.so. Then you pretty much need to
link the whole linux kernel (except the modules) into one flat file. It defeat
the purpose of having the linker and loader to load single sparse object
file one at a time. Ideally the checker should be able to dynamic load the
sparse object file only when it is needed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 10:35:04 +0000
Message-ID: <70318cbf0809040335k5ea24032sffc11a8793b43b40 () mail ! gmail ! com>
--------------------
On Thu, Sep 4, 2008 at 2:41 AM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
> No, that's not how it works. ;)
> Please compile and run the code. And look at what is actually generated.
> Or wait a bit, I'll try to describe the serialization process in more detail.
>

I did. It generate C *source* code like this:

=============cut =============
#include "test.sparse_declarations.c"

#define NULL ((void *)0)
static struct a_wrapper __a_0 = {
        .payload = {
                .d = 1,
                .b_ptr = &__b_0.payload,
        },
};
static struct b_wrapper __b_0 = {
        .payload = {
                .k = 11,
                .a_ptr = &__a_1.payload,
        },
};
============ paste ===========

I assume you intend to use a real compiler(gcc) to compile
and link that code, no?

I haven't fully understand how you use that piece of C code. But my
gut feeling is that we shouldn't need to do that C source code
generation at all.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 13:29:22 +0000
Message-ID: <f19298770809040629t1eb86f2co66a87e564bcd8684 () mail ! gmail ! com>
--------------------
On Thu, Sep 4, 2008 at 2:35 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Sep 4, 2008 at 2:41 AM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
>> No, that's not how it works. ;)
>> Please compile and run the code. And look at what is actually generated.
>> Or wait a bit, I'll try to describe the serialization process in more detail.
>>
>
> I did. It generate C *source* code like this:
>
> =============cut =============
> #include "test.sparse_declarations.c"
>
> #define NULL ((void *)0)
> static struct a_wrapper __a_0 = {
>        .payload = {
>                .d = 1,
>                .b_ptr = &__b_0.payload,
>        },
> };
> static struct b_wrapper __b_0 = {
>        .payload = {
>                .k = 11,
>                .a_ptr = &__a_1.payload,
>        },
> };
> ============ paste ===========
>
> I assume you intend to use a real compiler(gcc) to compile
> and link that code, no?
>
> I haven't fully understand how you use that piece of C code. But my
> gut feeling is that we shouldn't need to do that C source code
> generation at all.
Ok, let me try to explain how the stuff works. Please note that in
fact two files are generated, output.sparse.c and
output.sparse_declarations.c. This is required to have only one pass
over the serialized data. When we are in the process of serializing
"struct a1", and it points to a "struct b2", we can add  b2 to the
"serialization queue" and dump it after we finish with a1, but we
need to have the declaration somewhere before a1, so we add it to
the _declarations.c file, and #include it from near the output.sparse.c's
start.

Now let's look at an example (a simplified version of serialization-test):

===== test.h =====

struct a {
        int d;
        struct a *a_ptr;
};

DECLARE_WRAPPER(a);
 ^-- Declares struct a_wrapper {struct serialization_mdata meta;
struct a payload;};
and allocation wrapper prototypes.

====== test.c =====

[... helper functions ...]

.- That's the actual user-defined serialization function.
v       All that is needed to serialize any "struct a";
int dump_a(struct serialization_stream *s, struct a *w)
{
        emit_int(s, w, d); <-- dump the int a.d field.
        emit_ptr(s, w, a, a_ptr); <-- dump the struct a * a.a_ptr field.
        /* We could choose to not dump some fields, or choose to dump
         * them conditionally, etc */
        return 0;
}

WRAP(a, "test.h", dump_a);
^-- Defines the allocation wrappers, so that when you call __alloc_a(0),
a "struct a_wrapper" is allocated, and a pointer to its payload field (of
type "struct a") is returned. Also defines the serialization functions for
this type. The second argument is the header that contains the
"struct a" and "struct a_swapper" definitions. It's #included into the
generated file.

Now we allocate a few "struct a" instances, cross-reference them, and
call the serialization function on one of them:

int main(int argc, char **argv)
{
        struct serialization_stream *s;

        struct a *aa = __alloc_a(0);
        struct a *ab = __alloc_a(0);
        struct a *ac = __alloc_a(0);

        aa->d = 1;
        ab->d = 2;
        ac->d = 3;

        aa->a_ptr = ab;
        ab->a_ptr = ac;
        ac->a_ptr = aa

        s = new_serialization_stream("test");

        serialize_a(s, aa, "aa");
        ^- This function was defined through WRAP(a, ...);
        Look at the DO_WRAP monster from serialization.h:

        serialize_a() does the following:

        1 It calls schedule_a_serialization, that:

 88         int schedule_##type_name##_serialization(struct
serialization_stream *s,\
 89                 type *t)
             \
 90         {
             \
 91                 struct type_name##_wrapper *w;
             \
 92                 if (!t)
             \
 93                         return 0; /* Tried to serialize a NULL
pointer */       \
 94                 w = container(t, struct type_name##_wrapper,
payload);          \
 95 (1.1)           if (w->meta.declared)
             \
 96                         return 0;       /* Either already
serialized or waiting \
 97                                          * in the queue */
             \
 98 (1.2)           if (!type_name##_index)
             \
 99                         fprintf(s->declaration_f,
             \
100                                 "\n#include %s\n", #type_header);
             \
101
             \
102                 w->meta.index = type_name##_index++;
             \
103 (1.3)           fprintf(s->declaration_f,
             \
104                         "static struct " #type_name "_wrapper "
             \
105                         "__" #type_name "_%d;\n",
             \
106                         w->meta.index);
             \
107                 w->meta.declared = 1;
             \
108 (1.4)           return serialization_stream_enqueue(s, w,
             \
109                         do_serialize_##type_name);
             \
110         }
                1.1 checks the metadata associated with this instance to
                    see if it was already serialized

                1.2 If not, checks if any structure of type "struct a"
was serialized,
                    and adds #include "test.h" into the
output.sparse_declarations.c.
                    a_index beind a global counter associated with
"struct a", that
                    is incrementd every time a "struct a" is being serialized
                    Its values are assigned to the serialized instances.

                    This resulting in:
test.sparse_declarations.c:2    #include "serialization-test.h"

                1.3 Defines an struct a_wrapper instance in the
declarations file and
                    marks the aa instance as being serialized:
                    This resulting in:
test.sparse_declarations.c:3    static struct a_wrapper __a_0;

                1.4 Calls the serialization_stream_enqueue() function,
which allocates
                    a struct serialization_sched_work that binds the
aa instance and
                    the dump_a() user-supplied dunmper function
(through do_serialize_a())
                    to the "serialization stream" s. Returns to serialize_a().

        2 Calls process_serialization_queue(), that for every enqueued
data instance,
          calls the do_serialize_##type_name, that was bound to it at
step 1.3. The idea
          is, that if your structure references numerous other
structures, they all will
          be added to the queue by your user-supplied serializer
(transparently, through
          the emit_ptr function) and serialized before the loop exits:
40 int process_serialization_queue(struct serialization_stream *s)
 41 {
 42       int ret = 0;
 43       struct serialization_sched_work *w;
 45       while (s->queue) {
 46               w = s->queue;
 47               s->queue = s->queue->next;
 48               ret = w->serializer(s, w->unit); <- Here new
structures might get added
 49               free(w);      ^                       to the queue
as dependencies.
 50       }                     \ calls do_serialize_a(...)

          ret =  w->serializer(s, w->unit) points at do_serialize_a() that does:

 73       static int do_serialize_##type_name(struct
serialization_stream *s,     \
 74               void *unit)
           \
 75       {
           \
 76               struct type_name##_wrapper *w = unit;
           \
 77               int ret;
           \
 78 (2.1)         fprintf(s->definition_f, "static struct " #type_name
"_wrapper "\
 79                       "__" #type_name "_%d = {\n\t.payload = {\n",
           \
 80                       w->meta.index);
           \
 81 (2.2)         ret = serializer(s, &w->payload); <-- dump_a()
           \
 82 (2.3)         fprintf(s->definition_f, "\t},\n};\n");
           \
 83               if (ret)
           \
 84                       fprintf(stderr, "Warning: Failed to
serialize a " #type \
 85                       ": %d\n", ret);
           \
 86               return ret;
           \
 87       }
           \

                2.1 In the output.sparse.c file it adds an a_wrapper
instance, numbered
                    acording to the index assocoated to the structure
(step 1.2):
                    This resulting in:

test.sparse.c:4     static struct a_wrapper __a_0 = {
test.sparse.c:5            .payload = {

                    Note that __a_0 is derived not from the serialized
instance's
                    name (aa), but from the type name and the instance's index.

                2.2 Finally runs the user-supplied function (dump_a):

                    That does the following:
                        2.3.1 calls emit_int to dump the a.d field:
                              emit_int(s, w, d);
                              emit_int being: *
146 #define emit_int(s, parent, field)
             \
147         do {
             \
148                 int __i = parent->field;
             \
149                 fprintf(s->definition_f, "\t\t." #field " =
%d,\n", __i);       \
150         } while (0)
                              and resulting into:
test.sparse.c:6 .d = 1,
                        2.3.2 calls emit_ptr(s, w, a, a_ptr) that does:

                                         .------.- Here type being the name of
                                         v      v        the pointed-to type.
172 #define do_emit_ptr(stream, parent, type, type_name, field) **
             \
173         do {
             \
174                 struct type_name##_wrapper *__w;
             \
175                 void *__ptr = parent->field;
             \
176 (2.3.2.1)       if (!__ptr) {
             \
177                         fprintf(stream->definition_f,
             \
178                                 "\t\t." #field " = NULL,\n");
             \
179                         break;
             \
180                 }
             \
181 (2.3.2.2)       schedule_##type_name##_serialization(stream,
__ptr);            \
182                 __w = container(__ptr, struct type_name##_wrapper,
payload);    \
183 (2.3.2.3)       fprintf(stream->definition_f, "\t\t." #field " =
&"             \
184                         "__" #type_name "_%d.payload,\n",
__w->meta.index);     \
185         } while (0)
                                2.3.2.1 check the pointer for NULL.
                                2.3.2.2 Schedules the pointed-to structure for
                                        serializetion. The pointed-to
structure's
                                        is passed as the third
argument to emit_ptr().
                                        See point 1 on how
schedule_##type_name##_serialization
                                        works, resulting into the
pointed-to being added to
                                        the declatarion file and to
the serialization qeueue:

test.sparse_declarations.c:4  static struct a_wrapper __a_1;

                                2.3.2.3 Dumps the requisted field
(a_ptr), resulting in:
test.sparse.c:7 .a_ptr = &__a_1.payload,
                                __a_1 being the pointed-to structure's wrapper,
                                 declared, but not dumped yet.

                2.3 After the user-supplied function returns, closes the now
                    serialized structure:
test.sparse.c:8          },
test.sparse.c:9 };

                2.4 Now the process_serialization_queue's loop
iterates again, as a new
                    instance (ab) was added at the step 2.3.2.2, and
again, as this instance
                    references a third struct (ac). ac references the
first struct, aa, but
                    schedule_a_serialization() would see at step 1.1
that it was already
                    serialized, and would return right away, leadin to
the loop termination.

                    After this, we should have the following data:

test.sparse_declarations.c:2 #include "serialization-test.h"
test.sparse_declarations.c:3 static struct a_wrapper __a_0;
test.sparse_declarations.c:4 static struct a_wrapper __a_1;
test.sparse_declarations.c:5 static struct a_wrapper __a_2;

test.sparse.c:1 #include "test.sparse_declarations.c"
test.sparse.c:2
test.sparse.c:3 #define NULL ((void *)0)
test.sparse.c:4 static struct a_wrapper __a_0 = {
test.sparse.c:5         .payload = {
test.sparse.c:6                 .d = 1,
test.sparse.c:7                 .a_ptr = &__a_1.payload,
test.sparse.c:8         },
test.sparse.c:9 };
test.sparse.c:0 static struct a_wrapper __a_1 = {
test.sparse.c:1         .payload = {
test.sparse.c:2                 .d = 2,
test.sparse.c:3                 .a_ptr = &__a_2.payload,
test.sparse.c:4         },
test.sparse.c:5 };
test.sparse.c:6 static struct a_wrapper __a_2 = {
test.sparse.c:7         .payload = {
test.sparse.c:8                 .d = 3,
test.sparse.c:9                 .a_ptr = &__a_0.payload,
test.sparse.c:0         },
test.sparse.c:1 };

        3 At this point, we've got all the data, except it's
          all static. One final touch is to add a global reference
          to the structure that we serialized (aa):

117                 if (!ret && name)
             \
118                         ret = label_##type_name##_entry(s, t,
name);            \
119                 return ret;
             \
120         }
             \

121         int label_##type_name##_entry(struct serialization_stream
*s, type *t,  \
122                 const char *name)
             \
123         {
             \
124                 struct type_name##_wrapper *w;
             \
125                 if (!t) {
             \
126                         fprintf(s->definition_f, #type " *%s =
NULL;", name);   \
127                         return 0;
             \
128                 }
             \
129                 w = container(t, struct type_name##_wrapper,
payload);          \
130                 if (!w->meta.declared) {
             \
131                         fprintf(stderr, "Warning: Trying to label
an undefined" \
132                                 " '" #type "'\n");
             \
133                         return -1;
             \
134                 }
             \
135                 fprintf(s->definition_f, #type " *%s = &"
             \
136                         "__" #type_name "_%d.payload;\n", name,
w->meta.index); \
137                 return 0;
             \
138         }
          label_a_entry() doing the job:

test.sparse.c:22 struct a *aa = &__a_0.payload;

          If we decide to call serialize_a() on the other two structures,
          only the global pointers would be added, as the structure's
          metadata contains both the definition flag and the instance's index.


* emit_int was fixed, it worked only occasionally. ;)
** seems like we don't need to pass the "type" any more.

Uff. Seems like that's how it works. Now (or after a bit more looking
at the code),
it should be clear, that if in the program we have a "struct a", wrapped into a
"struct a_wrapper" and being serialized, you would see exactly the same struct
appearing in the output file, with the fields you have chosen to serialize.

Q: You tried to look smart or what?
A: Yes, the work was inspired by the ptr lists,
        and I hope I managed to beat Linus here,
        as ptr lists are perfectly serializable. ;)
>
> Chris
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 13:35:45 +0000
Message-ID: <f19298770809040635s611ef3c3sa05111743ea60631 () mail ! gmail ! com>
--------------------
On Thu, Sep 4, 2008 at 5:29 PM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
> On Thu, Sep 4, 2008 at 2:35 PM, Christopher Li <sparse@chrisli.org> wrote:
>> On Thu, Sep 4, 2008 at 2:41 AM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
>>> No, that's not how it works. ;)
>>> Please compile and run the code. And look at what is actually generated.
>>> Or wait a bit, I'll try to describe the serialization process in more detail.
>>>
>>
>> I did. It generate C *source* code like this:
>>
>> =============cut =============
>> #include "test.sparse_declarations.c"
>>
>> #define NULL ((void *)0)
>> static struct a_wrapper __a_0 = {
>>        .payload = {
>>                .d = 1,
>>                .b_ptr = &__b_0.payload,
>>        },
>> };
>> static struct b_wrapper __b_0 = {
>>        .payload = {
>>                .k = 11,
>>                .a_ptr = &__a_1.payload,
>>        },
>> };
>> ============ paste ===========
>>
>> I assume you intend to use a real compiler(gcc) to compile
>> and link that code, no?
>>
>> I haven't fully understand how you use that piece of C code. But my
>> gut feeling is that we shouldn't need to do that C source code
>> generation at all.
> Ok, let me try to explain how the stuff works. Please note that in

Ugh, my pretty code listings got corrupted by the bloody gmail.
Here is a better version: http://zaytsev.su/explanation.txt
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 19:04:28 +0000
Message-ID: <70318cbf0809041204y75fa8f58vd6d1cfc7317b4fff () mail ! gmail ! com>
--------------------
On Thu, Sep 4, 2008 at 6:35 AM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:

>> Ok, let me try to explain how the stuff works. Please note that in
>
> Ugh, my pretty code listings got corrupted by the bloody gmail.
> Here is a better version: http://zaytsev.su/explanation.txt

Thanks for your detail explain. It just confirm my reading of your
code. I stand by my original feedback:

- Using C source code as the output format is bad and unnecessary.
  It depend on gcc to process the intermediate C source file.

- Using dlopen to load the module does not have the fine grain control
  of the which symbol need to resolve and which is doesn't. The linked
  sparse object code for the whole linux kernel will be huge. Dynamic
  loading of 300M bytes of .so file is not fun.

- I can see you link all the define symbol together that way. In order to do
  inter-function check effectively, we need the have the reverse mapping
  as well. It need to perform task like this:
  "Get me a list of the function who has reference to spin_lock()".

  If I am writing a spin_lock checker.  I can look at who used spin_lock
  and only load those functions as needed.
  It is much better than scanning every single one of the kernel function to
  search for the spin_lock function call.

- The extra 4 bytes per structure storage on disk can be eliminated.
  I agree you need some meta data to track the object before you dump
  them to the file. But they don't need to be on the disk object at all.

  If you group same type of object together as an array. The index of the
  object is implicit as the array index. If the C struct is fixed size. It is
  trivial to locate the object.

  If the C struct is variable size, currently on sparse each object knows
  what size it is. You do need any index array to look it up. But this
  array can be build on object loading time. They don't have to be on
  the disk either.

  Then you can get ride of the wrapper structure on the disk file format
  all together.

  The writer patch I send out use those tricks already. You are welcome to
  poke around it.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/10] Sparse linker
Date: Thu, 04 Sep 2008 21:24:57 +0000
Message-ID: <70318cbf0809041424n1a773e0t3a68414a44ce79f3 () mail ! gmail ! com>
--------------------
On Thu, Sep 4, 2008 at 1:21 PM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
> Mostly ack here, but I still think the C code has two advantages over
> binaries: It's easy to read, and it's an easy way to get the shared
> library filled with the data, see below.

It does not stop you to have some parsing tool to generate readable
format from the object dump. But using the C source as primary way to
dump object is letting the tail whack the dog. The on disk format should
be optimized towards easy for checker rather than human to read it.

> The huge disadvantage is the time and the memory it takes to compile
> the C code.

And the run time dependency of gcc.

> Here I have to disagree. Loading the data from an .so might actually the
> most evfficient method. See, the bulk of data of the .so is simply mmap'ed
> read-only, with only the GOT being read-write, and when mapping with
> RTLD_LAZY, the pointers are resolved only when you follow them, completely
> transparently to us. You don't need the fine-grained control, the OS just does
> the right thing for you. And if the checker needs to look at the bulk
> of the data,

Are you sure?

Quote the man page:
===================
RTLD_LAZY
    Perform lazy binding. Only resolve symbols as the code that
references them is executed. If the symbol is never referenced, then
it is never resolved. (Lazy binding is only performed for function
references; references to variables are always immediately bound when
the library is loaded.)
===================

Your symbol is store as DATA  nodes. Not functions. You never EXECUTE
your sparse object code. The RTLD_LAZY has ZERO effect on them. All the symbol
has to be immediately bounded. How can you tell which data pointer is lazy bound
given that all the data value is possible in the pointer?

> it cat dlopen with RTLD_NOW. When multiple different checkers are being run
> over the .so, the bulk of memory is shared between the processes, which I
> think matters a lot. The memory is cheap, but now the number of cores
> is growing.
> E.g. if you've got 4 cores and 4 gigs of RAM, it's only one gig per
> core, and wasting
> 300 megabytes per process just to load the data doasn't look like a good idea.

Even they are mmaped. Every symbol have to be touch up. So they need
to swap in and COW. The COW memory can't be shared between process
at all.  This is against the tradition of sparse being a small and neat tools.

I have to NACK this approach especially I know there is alternative better
way to do it. My laptop does not have 4 gigs of ram and it only have one core,
but I still want to run the checker as fast as possible on it.


> That should be completely possible with both approaches. I don't see any
> difference here.

I don't think so. See above comment about RTLD_LAZY.

>
> This way, you don't have the transparency. You either need to load all the
> data into memory, one structure after the other, and link them together,
> basically going the same stuff dlopen() does for you,  or you'll need to
> use special functions/macros to access the data from your checker.

Yes, it need one bit of information of this symbol has been resolve
or not.

That does not need to test inside the checker though.
The loader can make sure the symbol that the specific checker want
are all resolved before it hand it over to the checker. On the typical checking
path, there is only very small percent of the data checker care about.
Spending CPU and memory on those structure that the checker  don't
care is a big waste.

We don't really need to link them into one big piece of object as long as
we can efficiently look up which object contain the symbol I want.
I see linking into one big piece of object and have to load them together
as serious disadvantage.

After the checker is done with object, ideally the checker can release it.
I don't want the checker load every objects into memory before it
can work on it. This obviously does not scale.

> I'm looking into it now. Thank you for sharing.
>
> One crazy idea is... why can't we actually produce shared object binaries
> directly... Maybe it won't be all that hard to generate valid ELF...
> Just crazy probably.

I don't mind to use ELF format as long as it is simple and easy to
use. Keep in mind that the object file format used by sparse has
slightly different design goals. I did try ELF a little bit but I did not go
very far.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/10] Sparse linker
Date: Fri, 05 Sep 2008 09:49:29 +0000
Message-ID: <f19298770809050249q48eac7d6oc02e8293ee6a163b () mail ! gmail ! com>
--------------------
On Fri, Sep 5, 2008 at 1:24 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Sep 4, 2008 at 1:21 PM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
>> Mostly ack here, but I still think the C code has two advantages over
>> binaries: It's easy to read, and it's an easy way to get the shared
>> library filled with the data, see below.
>
> It does not stop you to have some parsing tool to generate readable
> format from the object dump. But using the C source as primary way to
> dump object is letting the tail whack the dog. The on disk format should
> be optimized towards easy for checker rather than human to read it.
>
>> The huge disadvantage is the time and the memory it takes to compile
>> the C code.
>
> And the run time dependency of gcc.
>
>> Here I have to disagree. Loading the data from an .so might actually the
>> most evfficient method. See, the bulk of data of the .so is simply mmap'ed
>> read-only, with only the GOT being read-write, and when mapping with
>> RTLD_LAZY, the pointers are resolved only when you follow them, completely
>> transparently to us. You don't need the fine-grained control, the OS just does
>> the right thing for you. And if the checker needs to look at the bulk
>> of the data,
>
> Are you sure?
>
> Quote the man page:
> ===================
> RTLD_LAZY
>    Perform lazy binding. Only resolve symbols as the code that
> references them is executed. If the symbol is never referenced, then
> it is never resolved. (Lazy binding is only performed for function
> references; references to variables are always immediately bound when
> the library is loaded.)
> ===================
>
> Your symbol is store as DATA  nodes. Not functions. You never EXECUTE
> your sparse object code. The RTLD_LAZY has ZERO effect on them. All the symbol
> has to be immediately bounded. How can you tell which data pointer is lazy bound
> given that all the data value is possible in the pointer?
>

Confirmed, I was wrong.

>> it cat dlopen with RTLD_NOW. When multiple different checkers are being run
>> over the .so, the bulk of memory is shared between the processes, which I
>> think matters a lot. The memory is cheap, but now the number of cores
>> is growing.
>> E.g. if you've got 4 cores and 4 gigs of RAM, it's only one gig per
>> core, and wasting
>> 300 megabytes per process just to load the data doasn't look like a good idea.
>
> Even they are mmaped. Every symbol have to be touch up. So they need
> to swap in and COW. The COW memory can't be shared between process
> at all.  This is against the tradition of sparse being a small and neat tools.

And also here.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] improve context handling ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 0/3] improve context handling
Date: Thu, 10 Apr 2008 13:25:19 +0000
Message-ID: <20080410132519.049821000 () sipsolutions ! net>
--------------------
Hi,

Here are three patches to improve context tracking in sparse. For example,
with the patches, one could define

spin_lock_irqsave() __acquires(local_irq) __acquires(spinlock)
spin_unlock_irqrestore() __releases(local_irq) __releases(spinlock)

local_irq_save() __acquires(local_irq)
local_irq_restore() __releases(local_irq)

spin_lock() __acquires(spinlock)
spin_unlock() __releases(spinlock)

spin_trylock() __attribute__((conditional_context(spinlock,0,1,0)))

and sparse should be able to check constructs like the one in sungem
completely:

        local_irq_save(flags);
        if (!spin_trylock(&gp->tx_lock)) {
                /* Tell upper layer to requeue */
                local_irq_restore(flags);
                return ...;
        }
        if (..) {
                spin_unlock_irqrestore(&gp->tx_lock, flags);
                return ...;
        }
        [...]
        spin_unlock_irqrestore(&gp->tx_lock, flags);

I haven't tried this particular case, but I have tried simpler versions
of all the primivites used, those are in the test suite.


Also, one can now define, as the sparse man page already suggests without
patches:

/* needs irqs disabled */
void myfunc(void) __attribute__((context(local_irq,1,1)))
{...}

and sparse will warn when the function is called from a context that doesn't
have local_irq. Of course, if the context comes from outside the calling
function then the calling function needs to use that attribute as well to
indicate that it too needs irqs disabled.

Comments welcome!

johannes

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 0/3] improve context handling
Date: Mon, 21 Apr 2008 18:37:30 +0000
Message-ID: <480CDEEA.2020603 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig57DD2E4F7FAE7AB9EB0B5705
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Johannes Berg wrote:
> Here are three patches to improve context tracking in sparse.

All five patches applied and pushed.  Thanks for your great work!

- Josh Triplett


--------------enig57DD2E4F7FAE7AB9EB0B5705
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIDN7qGJuZRtD+evsRAtt8AKCFLLHxD2CQFwC84olOJYw+d5F9EQCeJymr
8cABH0svJMeOzstN8WY4Qc8=
=JkR9
-----END PGP SIGNATURE-----

--------------enig57DD2E4F7FAE7AB9EB0B5705--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/9] context tracking updates ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 08:54:02 +0000
Message-ID: <20080529085402.814224000 () sipsolutions ! net>
--------------------
This updates the context tracking, I just explained most of it in the mail
"Re: sparse context warning problem ..."
(message ID <1212050823.16917.37.camel@johannes.berg>)

johannes
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 22:12:15 +0000
Message-ID: <1212099135.28403.146.camel () brick>
--------------------
On Thu, 2008-05-29 at 10:54 +0200, Johannes Berg wrote:
> This updates the context tracking, I just explained most of it in the mail
> "Re: sparse context warning problem ..."
> (message ID <1212050823.16917.37.camel@johannes.berg>)
> 
> johannes

>From initial impressions, this works pretty well, at least in the kernel.

Looking a little deeper at the results now, but seems like a nice improvement.

Harvey

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 22:35:16 +0000
Message-ID: <1212100516.28403.152.camel () brick>
--------------------
On Thu, 2008-05-29 at 10:54 +0200, Johannes Berg wrote:
> This updates the context tracking, I just explained most of it in the mail
> "Re: sparse context warning problem ..."
> (message ID <1212050823.16917.37.camel@johannes.berg>)
> 

With these applied I get a new error when checking
fs/minix/itree_common.c

I'll try and track it down.

Harvey

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 22:45:02 +0000
Message-ID: <1212101102.10109.5.camel () johannes ! berg>
--------------------

--=-t5Vn4cXbwXb/g9QWhi7X
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Thu, 2008-05-29 at 15:35 -0700, Harvey Harrison wrote:
> On Thu, 2008-05-29 at 10:54 +0200, Johannes Berg wrote:
> > This updates the context tracking, I just explained most of it in the m=
ail
> > "Re: sparse context warning problem ..."
> > (message ID <1212050823.16917.37.camel@johannes.berg>)
> >=20
>=20
> With these applied I get a new error when checking
> fs/minix/itree_common.c

What sort? Right now, it seems to go into a dead loop on
fs/minix/itree_v1.c for me?!

johannes

--=-t5Vn4cXbwXb/g9QWhi7X
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASD8x7aVg1VMiehFYAQJ3XhAAmVsgV1DEAW0lwTqPvQQCa36z2M6dqFf/
bOJi1CHePHwZuP/ChF0qw8OFLvsMp3Gwczt1+eXI4gRQNXO/OCy0w0FoY+WVoS2V
S53BlMuEIOoV+rO3EI307ma8Vd6wzWVITwfonB7WfKhRrdJCX+KwJMakdiLV8VZg
uf1aQxML/YR0VkEFOlbhI8swbvLeboVwftzG4RyKz93DVlIVZ2LVYvuA9YuYRtkq
R+CFpsI78ZaKMMScSxXLtzNUGWC053eRfMButoshjV7kSkLEcNcpQh0wKGeiSuMZ
B3D9RsMsdgyoM+XaVPts/XnQU3Oj0Rg5xmMBqHsT7JZwisaLb2Y3HDsgF5FgKQW1
gb5F4BFD+MFSm0oMVuOLnEvBkf91yEbGi0kT5Uy3EOtO6thDzcjJDk30NaHwT2iy
oYRdIru8Fo3Mavv2dQ9EpoLA3d63SY//yGmvX+Ev2i64JSCOIZb6VFRUbAcDUZht
d77M2xepj94UbqsPIqa/GBC67S8EAvN6LOBr9nfBMJImVE5kQHja/BrlPMV47IIE
/sCtLEZLiNmNuS9SsdPDuXTPyRF6PVe5FkLDW5gzN2PuyVQ05u5AmbKHVuOg5prp
p0/dkpOguL47jcW+CBXjO54r8NUse2fupHL2XN9J0NYky9m0wgijneuZC6oUO0yQ
Dw+wEm/cfuI=
=mgzv
-----END PGP SIGNATURE-----

--=-t5Vn4cXbwXb/g9QWhi7X--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 22:51:05 +0000
Message-ID: <1212101465.28403.156.camel () brick>
--------------------
On Fri, 2008-05-30 at 00:45 +0200, Johannes Berg wrote:
> On Thu, 2008-05-29 at 15:35 -0700, Harvey Harrison wrote:
> > On Thu, 2008-05-29 at 10:54 +0200, Johannes Berg wrote:
> > > This updates the context tracking, I just explained most of it in the mail
> > > "Re: sparse context warning problem ..."
> > > (message ID <1212050823.16917.37.camel@johannes.berg>)
> > > 
> > 
> > With these applied I get a new error when checking
> > fs/minix/itree_common.c
> 
> What sort? Right now, it seems to go into a dead loop on
> fs/minix/itree_v1.c for me?!
> 

It's a problem introduced with 9/9 explicitly checking inlines.

Harvey


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 22:54:05 +0000
Message-ID: <1212101645.10109.7.camel () johannes ! berg>
--------------------

--=-a0QGFiH5ZzVcMMy+7kek
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

> > What sort? Right now, it seems to go into a dead loop on
> > fs/minix/itree_v1.c for me?!
> >=20
>=20
> It's a problem introduced with 9/9 explicitly checking inlines.

Cool, thanks, I'm just looking at it.

johannes

--=-a0QGFiH5ZzVcMMy+7kek
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASD80C6Vg1VMiehFYAQLTbxAAn6tH+icJsewjX4DRXt914DFQsEaJatM9
lhENJHFC9by1as7SgeScFQs6qNaAXFecqOCh0JCtp3epSsklhmxlTPci9pyuwvsw
nCX7J0lrbu/TsxroMdU/+L3nc7n/jpjXOnRhHxcl6KSU+A3aKywyfu/pGfLyklTp
7ZUPOhV3JTgWmK/yRwWzu3NUdXWdk4RNPGhZ8Zz04638B2Y2a5wtJ0op/txknIrk
eU8j3CcTCZx9sq5e6j755lOkDiPedIbnTBIpyG1bj5o3gfLJk3xka5yvcTjTnmOT
nZmf42DoPscv3+568WI7XYSZXUG1qp6FnWiqlqO4gBqrLZ4J66dO5Zk/A6Lo/8zT
DKqAsXaQ6ZpgruViAwPqJB4pzKWIjUs2syZHXKj+y7m9q4+tZuOFbMPa19U4DG1S
E2T3jJbCFfXfbh/7tjidUcCuL2N6PFdVZe08YnDZtih2eMK0ry5ejH20PhHLQtGe
bVpp1FQbCc1XxOCdQcTFa5HLCGqvcIh9sqnL210jvRJvvFkzVI5n35UDe1sDpfDW
wXoNpQg9qXhmyxFnQNpw54TM1rO3oBoFSanji0LGleGswfDOJTrtxzkPkfJEAfh4
B8ghyhFEgdzGa/31/7+wu2FukI6ocDjTalvfU+EhTaWv0vxQswYdJmtpxFq/5fMM
KkklYqqHkR0=
=NMVE
-----END PGP SIGNATURE-----

--=-a0QGFiH5ZzVcMMy+7kek--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 23:03:19 +0000
Message-ID: <1212102199.4265.46.camel () dv>
--------------------
On Fri, 2008-05-30 at 00:54 +0200, Johannes Berg wrote:
> > > What sort? Right now, it seems to go into a dead loop on
> > > fs/minix/itree_v1.c for me?!
> > > 
> > 
> > It's a problem introduced with 9/9 explicitly checking inlines.
> 
> Cool, thanks, I'm just looking at it.

You may want to look at this:
http://marc.info/?t=120287346100007&r=1&w=2
http://marc.info/?l=linux-sparse&m=120370800715845&w=2

It was happening in ndiswrapper because a typedef was forcing an inline
function to be linearized twice.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Thu, 29 May 2008 23:06:54 +0000
Message-ID: <1212102414.10109.11.camel () johannes ! berg>
--------------------

--=-DXZemLaSNYkdO7mIGZUf
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Thu, 2008-05-29 at 19:03 -0400, Pavel Roskin wrote:
> On Fri, 2008-05-30 at 00:54 +0200, Johannes Berg wrote:
> > > > What sort? Right now, it seems to go into a dead loop on
> > > > fs/minix/itree_v1.c for me?!
> > > >=20
> > >=20
> > > It's a problem introduced with 9/9 explicitly checking inlines.
> >=20
> > Cool, thanks, I'm just looking at it.
>=20
> You may want to look at this:
> http://marc.info/?t=3D120287346100007&r=3D1&w=3D2
> http://marc.info/?l=3Dlinux-sparse&m=3D120370800715845&w=3D2
>=20
> It was happening in ndiswrapper because a typedef was forcing an inline
> function to be linearized twice.

Ah, thanks for the pointers, that might be the case. Wonder why it's
being linearized twice, and I see it even without the linearization I
force...? will take a look tomorrow.

johannes

--=-DXZemLaSNYkdO7mIGZUf
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASD83DaVg1VMiehFYAQKAUA//bjyQSlx/qE/5uOUiescgesIiiVr0zp4A
MNY5tjfRjjnJHTA7rJTbjautgtQ6gWnTr6c8hoex3+Er6QqfO1BK4/wioxpiuImx
jA221lEGI4p/6buz8pstjnZjmucWu7sXUfiFTb7Kj92egJ8qghTZwWV77/fEYIJe
j77GrelvmAZKiSqmFLUOxJcQA6QUix+OOIQgCJBul5pKst3qebS7lP0BxGgwEb0p
u2Kmzz3yjdG8q9f/aWIpYwVUmJE0LqeIzwATE+CLWKQKd9h+cINGgdeC+4YqSzNG
txw02Mdk8Ic/bQoF0zKAJ+o4zfPJNfmatySKhyc8cr9TJqwbzZMp+oEO6ODDPly8
44fL51qo6nEslf/atSS6KShUZE3kKooHfKcbbH+nUpBfbPx3MwCLERk6gmUf+/0E
eS3Ox7WrR1su6IF/W5b4VSfcpySQ6AlFUwhJx7jN2epn1G6xw0ixy5pDW3BSkLY+
LE9l/DqOfJz7A0aJjNZIKnfZIF2loF+qykjk3NY7T6NELTjhRGQ5Xv8139pgcj1x
RRR5G6SOoa6JkiguXS+IRQx69LLpujXkrP9SBj77Sjlbca8VdLBoQjL33ZrijlX9
QJxnWdYCEMeWq21grq53V8MGVKVdlscRmEYzd2e+NmCONrfmjW4L+oGhDnpQGk2c
q5WnjH3w4G4=
=mFJ0
-----END PGP SIGNATURE-----

--=-DXZemLaSNYkdO7mIGZUf--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 0/9] context tracking updates
Date: Sun, 20 Jul 2008 12:30:12 +0000
Message-ID: <1216557012.3681.2.camel () johannes ! berg>
--------------------

--=-e2aARsB4KjI14dXlVbhs
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Thu, 2008-05-29 at 10:54 +0200, Johannes Berg wrote:
> This updates the context tracking, I just explained most of it in the mai=
l
> "Re: sparse context warning problem ..."
> (message ID <1212050823.16917.37.camel@johannes.berg>)

Ping? Josh, do you intend to merge this? I keep getting asked about the
corresponding kernel patches. If you don't want it, please revert my
previous patches and I'll stop bothering you either way.

johannes

--=-e2aARsB4KjI14dXlVbhs
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJIgy/QAAoJEKVg1VMiehFYYP8QALYqdRI9zmmUwpzKPIzF/DAj
GVMmqIKtR0wCkKP8OqY+ui8FGU1ftmEpG8qzYSGUqEn0j6tP6+wRs57cma7kGgEx
dy+sK9nQ3E0hz3MTvmjewdUJ9dAw+d34bLHP0iDIT0VltkonmTHK5cTH3bDXFcwm
GqpkkwYqF+Htam7nPA2aDwbYV2XwCzKFVrmVV2ck4cbT2KDRcugdDyt7m7hR7tFI
2z6ifMK6cRjkSXXrkMTF7rd8+mhnCrZ0EOv5Wt3JzYeKwiganEaFtqaJuDREzcS+
LvjPZEAwj5Rbotvulw7mDS+fM7Ht3ICC7wLhypPRFU8OjTDvoA42emp8zcgSGG3P
fREllJx66SLf4+/Utn3yaBHWIDSTHmGhKieG6Y/lxgZZVBq3Eyom7dUDjZG+/X9/
t2R90CgQXaThN3uQl0rxUnOKq1mwPN5jFZ5VmAD2gdXXMijz0ray579sldkV4hm3
y1G1LeG3CXMFeI5sIBsBOEqSoLf9UGR07Sw+aNGiX3/kZ1bTKgaQmLa/rvr5L7Xn
U6A/z0WOciDvMRf1LsmZvD0A3NbqVi2v/vu3ZJFTe29RXD7H1BqAIAWcUKcx+km9
eudUJN8hPpyst6MHKEyn99silz+pmcLmcTebNacpnBU40Dgy16FKNkyetXgSmM/i
0ZcFmME8BzoSt++KyXMJ
=IKD8
-----END PGP SIGNATURE-----

--=-e2aARsB4KjI14dXlVbhs--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 00/16] More patches. ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 00/16] More patches.
Date: Thu, 18 Dec 2008 21:51:13 +0000
Message-ID: <20081218181935.28136.60256.stgit () zaytsev ! su>
--------------------
Hello.

Here come patches, that I felt may need some
more discussion before being merged.

Christopher Li (1):
      Add enum member list to the parenta

This one is from Christopher and it does not break
anything => should probably apply. ;)

Josh Triplett (1):
      Expand "dubious !x & y" handling to other combinations of !, &, and |.

This one generates 17 new warnings on a allyesconfig x86_64 kenrnel,
of which 5 point to unintended bitwise or/and usage, but none are bugs:
http://git.zaytsev.su/git?p=linux-2.6.git;a=shortlog;h=dubious-bitwise

And I'm not sure about this one, might actually be a bug:
drivers/net/wireless/ath9k/regd.c:321:7: warning: dubious: x & !y

Anyway, the other 12 warning are bogus, so I'm not sure what should be done.
I'm thinking about some way to anotate such places. And if the warning
filtering would be performed by an external program, we could also annotate
bogus gcc warnings this way. Ideas?

Alexey Zaytsev (5):
      Set gcc include path at runtime.
      Let cgcc pass -gcc-base-dir to sparse.
      Document -gcc-base-dir in sparse.1
      Rename dirafter to idirafter.
      Let void have sizeof 1

The first 4 patches were already sent to the list. They let you
specify the gcc base dir, which is useful for distributions
like Debian, where multiple gcc versions are allowed, and the
one used to build the sparse package may be not installed.

The last patch changes sizeof(void) to 1, same as in gcc.

All theese patches were somehow tested, and cause no
regressions on x86_64 allyesconfig.

Johannes Berg (9):
      Check inlines explicitly
      Show required context in instruction output
      Test conditional result locking
      Ceck context expressions as expressions
      Revert the conditional_context patch
      Evaluate/expand context expressions
      Allow context() attribute on variables
      Add __exact_context__
      Add test for acquire/release

Now this series is a bit more problematic. First, I'm getting
some warnings like this:
Missing code in expression_str for 19

And also:
< fs/afs/proc.c:698:46: warning: context imbalance in 'afs_proc_cell_servers_start': unexpected unlock
< fs/afs/proc.c:698:46:    context 'servers_lock': wanted 1, got 0
< fs/afs/proc.c:721:2: warning: context problem in 'afs_proc_cell_servers_stop': '_read_unlock' expected different context
< fs/afs/proc.c:721:2:    context 'lock': wanted >= 1, got 0
---
> fs/afs/proc.c:690:2: error: expected structure or union
> fs/afs/proc.c:717:2: error: expected structure or union

And:
< drivers/usb/gadget/m66592-udc.c:887:20: warning: context problem in 'irq_packet_read': 'transfer_complete' expected different context
< drivers/usb/gadget/m66592-udc.c:887:20:    context 'lock': wanted >= 1, got 0
< drivers/usb/gadget/m66592-udc.c:951:24: warning: context problem in 'irq_pipe_empty': 'transfer_complete' expected different context
< drivers/usb/gadget/m66592-udc.c:951:24:    context 'lock': wanted >= 1, got 0
< drivers/usb/gadget/m66592-udc.c:1076:14: warning: context problem in 'setup_packet': 'get_status' expected different context
< drivers/usb/gadget/m66592-udc.c:1076:14:    context 'lock': wanted >= 1, got 0
---
> drivers/usb/gadget/m66592-udc.c:703:1: error: undefined identifier 'm66592'
> drivers/usb/gadget/m66592-udc.c:704:1: error: undefined identifier 'm66592'
> drivers/usb/gadget/m66592-udc.c:703:1: error: undefined identifier 'm66592'
> drivers/usb/gadget/m66592-udc.c:704:1: error: undefined identifier 'm66592'
> drivers/usb/gadget/m66592-udc.c:703:1: error: undefined identifier 'm66592'
> drivers/usb/gadget/m66592-udc.c:704:1: error: undefined identifier 'm66592'

And finally, it crashes on
CHECK   net/sched/sch_cbq.c
include/net/sch_generic.h:223:2: warning: unreplaced symbol 'root'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'break'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'continue'
include/net/sch_generic.h:189:10: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:189:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:236:2: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:236:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:223:2: warning: unreplaced symbol 'root'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'break'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'continue'
include/net/sch_generic.h:189:10: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:189:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:241:2: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:241:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:223:2: warning: unreplaced symbol 'root'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'break'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'continue'
include/net/sch_generic.h:189:10: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:189:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:236:2: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:236:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:223:2: warning: unreplaced symbol 'root'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'break'
include/net/sch_generic.h:225:2: warning: unreplaced symbol 'continue'
include/net/sch_generic.h:189:10: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:189:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:226:19: warning: unreplaced symbol 'return'
include/net/sch_generic.h:226:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:241:2: warning: unreplaced symbol 'qdisc'
include/net/sch_generic.h:241:2: warning: unreplaced symbol 'return'
include/net/sch_generic.h:225:2: warning: label 'continue' already bound
include/net/sch_generic.h:225:2: warning: label 'break' already bound
include/net/sch_generic.h:225:2: warning: label 'continue' already bound
include/net/sch_generic.h:225:2: warning: label 'break' already bound
sparse: simplify.c:82: if_convert_phi: Assertion `br->cond' failed.
/bin/sh: line 1:  1404 Aborted                 sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__x86_64__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-linux-gnu/4.3.2/include -Wp,-MD,net/sched/.sch_cbq.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-linux-gnu/4.3.2/include -D__KERNEL__ -Iinclude -I/home/xl0/work/linux/linux-2.6/arch/x86/include -include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Os -m64 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Iarch/x86/include/asm/mach-default -fno-stack-protector -fno-omit-frame-pointer -fno-optimize-sibling-calls -g -pg -Wdeclaration-after-statement -Wno-pointer-sign -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sch_cbq)" -D"KBUILD_MODNAME=KBUILD_STR(sch_cbq)" -D"DEBUG_HASH=53" -D"DEBUG_HASH2=43" net/sched/sch_cbq.c
make[2]: *** [net/sched/sch_cbq.o] Error 134
make[1]: *** [net/sched] Error 2

So, I'm not sure what should be done about theese.
Johannes, is there any chance you could fix it?

---
 Makefile                              |    7 -
 cgcc                                  |   14 ++
 evaluate.c                            |   40 ++++-
 expand.c                              |    8 +
 expression.c                          |  274 +++++++++++++++++++++++++++++++++
 expression.h                          |    7 +
 ident-list.h                          |    2 
 inline.c                              |   23 ++-
 lib.c                                 |   30 +++-
 linearize.c                           |  165 ++++++++++++++++----
 linearize.h                           |    4 
 parse.c                               |  138 +++++++++--------
 parse.h                               |    8 +
 pre-process.c                         |   98 +++++++++---
 sparse.1                              |   21 +--
 sparse.c                              |  221 +++++++++++----------------
 symbol.c                              |    2 
 symbol.h                              |   13 +-
 validation/context-dynamic.c          |  171 ---------------------
 validation/context-exact.c            |   67 ++++++++
 validation/context-on-vars.c          |  219 ++++++++++++++++++++++++++
 validation/context-statement.c        |    6 -
 validation/context-vars.c             |  192 +++++++++++++++++++++++
 validation/context.c                  |   43 +++++
 validation/dubious-bitwise-with-not.c |   19 ++
 25 files changed, 1322 insertions(+), 470 deletions(-)
 delete mode 100644 validation/context-dynamic.c
 create mode 100644 validation/context-exact.c
 create mode 100644 validation/context-on-vars.c
 create mode 100644 validation/context-vars.c

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 01/10] Serialization engine ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 01/10] Serialization engine
Date: Wed, 03 Sep 2008 21:55:45 +0000
Message-ID: <20df58606337d58576ba3c10cf8f8c1522f81f91.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 Makefile             |   11 ++-
 serialization-test.c |  120 +++++++++++++++++++++++++
 serialization-test.h |   32 +++++++
 serialization.c      |   99 +++++++++++++++++++++
 serialization.h      |  240 ++++++++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 499 insertions(+), 3 deletions(-)
 create mode 100644 serialization-test.c
 create mode 100644 serialization-test.h
 create mode 100644 serialization.c
 create mode 100644 serialization.h

diff --git a/Makefile b/Makefile
index 077003c..721979e 100644
--- a/Makefile
+++ b/Makefile
@@ -27,7 +27,7 @@ INCLUDEDIR=$(PREFIX)/include
 PKGCONFIGDIR=$(LIBDIR)/pkgconfig
 
 PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize example \
-	 test-unssa test-dissect ctags
+	 test-unssa test-dissect ctags serialization-test
 
 
 INST_PROGRAMS=sparse cgcc
@@ -40,12 +40,13 @@ endif
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
-	  storage.h ptrlist.h dissect.h
+	  storage.h ptrlist.h dissect.h serialization.h
 
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
-	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o
+	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o \
+	  serialization.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -135,6 +136,9 @@ ctags: ctags.o $(LIBS)
 c2xml: c2xml.o $(LIBS)
 	$(QUIET_LINK)$(CC) $(LDFLAGS)  -o $@ $< $(LIBS) `pkg-config --libs libxml-2.0`
 
+serialization-test: serialization-test.o $(LIBS)
+	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+
 $(LIB_FILE): $(LIB_OBJS)
 	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)
 
@@ -185,6 +189,7 @@ compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 compat-solaris.o: compat/mmap-blob.c $(LIB_H)
 compat-mingw.o: $(LIB_H)
 compat-cygwin.o: $(LIB_H)
+serialization-test.o: $(LIB_H)
 
 pre-process.h:
 	$(QUIET_GEN)echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=`\"" > pre-process.h
diff --git a/serialization-test.c b/serialization-test.c
new file mode 100644
index 0000000..f9bb3d4
--- /dev/null
+++ b/serialization-test.c
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2008 Alexey Zaytsev
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Alternatively, this program may be distributed under the
+ * Open Software License version 1.1.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+
+
+#include "serialization-test.h"
+
+static struct a *__alloc_a_core(int n)
+{
+	return malloc(sizeof(struct a) + n);
+}
+
+static struct b *__alloc_b_core(int n)
+{
+	return malloc(sizeof(struct b) + n);
+}
+
+
+void __free_a_core(struct a *t)
+{
+
+}
+
+void __free_b_core(struct b *t)
+{
+
+}
+
+int dump_a(struct serialization_stream *s, struct a *w)
+{
+	emit_int(s, w, d);
+	emit_ptr(s, w, b, b_ptr);
+
+	return 0;
+}
+
+int dump_b(struct serialization_stream *s, struct b *w)
+{
+	emit_int(s, w, k);
+	emit_ptr(s, w, a, a_ptr);
+
+	return 0;
+}
+
+WRAP(a, "serialization-test.h", dump_a);
+WRAP(b, "serialization-test.h", dump_b);
+
+int main(int argc, char **argv)
+{
+	struct serialization_stream *s;
+
+	struct a *a1 = __alloc_a(0);
+	struct a *a2 = __alloc_a(0);
+	struct a *a3 = __alloc_a(0);
+	struct a *a4 = __alloc_a(0);
+
+	struct b *b1 = __alloc_b(0);
+	struct b *b2 = __alloc_b(0);
+	struct b *b3 = __alloc_b(0);
+	struct b *b4 = __alloc_b(0);
+	struct b *b5 = __alloc_b(0);
+
+	a1->d = 1;
+	a2->d = 2;
+	a3->d = 3;
+	a4->d = 4;
+
+	a1->b_ptr = b1;
+	a2->b_ptr = b2;
+	a3->b_ptr = b3;
+	a4->b_ptr = b4;
+
+
+	b1->k = 11;
+	b2->k = 12;
+	b3->k = 13;
+	b4->k = 14;
+	b5->k = 15;
+
+	b1->a_ptr = a2;
+	b2->a_ptr = a3;
+	b3->a_ptr = a1;
+	b4->a_ptr = a2;
+	b5->a_ptr = a1;
+
+	s = new_serialization_stream("test");
+	if (!s) {
+		perror("Failed to open serialization stream");
+		exit(1);
+	}
+
+	printf("Dumping:\n");
+
+	printf("a1 = %p\n", a1);
+	serialize_a(s, a1, "a1_entry");
+	/* Note that we serializaed only one object, a1.
+	 * All the other objects appering in the generated file
+	 * were serializaed as it's dependencies. If you try to
+	 * serialize any of them again, only the global pointer
+	 * will be added. */
+
+	fini_serialization_stream(s);
+
+	return 0;
+
+}
+
diff --git a/serialization-test.h b/serialization-test.h
new file mode 100644
index 0000000..a1980e7
--- /dev/null
+++ b/serialization-test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2008 Alexey Zaytsev
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Alternatively, this program may be distributed under the
+ * Open Software License version 1.1.
+ */
+
+#ifndef SERIALIZATION_TEST_H
+#define SERIALIZATION_TEST_H
+
+#include "serialization.h"
+
+struct a {
+	int d;
+	struct b *b_ptr;
+};
+
+struct b {
+	int k;
+	char c;
+	struct a *a_ptr;
+};
+
+DECLARE_WRAPPER(a);
+DECLARE_WRAPPER(b);
+
+#endif
diff --git a/serialization.c b/serialization.c
new file mode 100644
index 0000000..79d4fda
--- /dev/null
+++ b/serialization.c
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2008 Alexey Zaytsev
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Alternatively, this program may be distributed under the
+ * Open Software License version 1.1.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <limits.h>
+#include <libgen.h>
+#include "serialization.h"
+
+
+int serialization_stream_enqueue(struct serialization_stream *s, void *unit,
+	int (*serializer) (struct serialization_stream *s, void *unit))
+{
+	struct serialization_sched_work *w;
+
+	w = malloc(sizeof(w[0]));
+	if (!w)
+		return -ENOMEM;
+
+	w->stream = s;
+	w->unit = unit;
+	w->serializer = serializer;
+	w->next = s->queue;
+	s->queue = w;
+
+	return 0;
+}
+
+int process_serialization_queue(struct serialization_stream *s)
+{
+	int ret = 0;
+	struct serialization_sched_work *w;
+
+	while (s->queue) {
+		w = s->queue;
+		s->queue = s->queue->next;
+		ret = w->serializer(s, w->unit);
+		free(w);
+	}
+	return ret;
+}
+
+struct serialization_stream *new_serialization_stream(const char *file)
+{
+	struct serialization_stream *s;
+	char tmp[PATH_MAX+1];
+
+	s = malloc(sizeof(s[0]));
+	s->queue = NULL;
+
+	strncpy(tmp, file, PATH_MAX);
+	s->definition_f = fopen(strncat(tmp, ".sparse.c", PATH_MAX), "w+");
+	if (!s->definition_f)
+		goto out_definitions;
+
+	strncpy(tmp, file, PATH_MAX);
+	s->declaration_f = fopen(strncat(tmp, ".sparse_declarations.c", PATH_MAX), "w+");
+	if (!s->declaration_f)
+		goto out_declarations;
+
+	fprintf(s->definition_f, "#include \"%s\"\n\n", basename(tmp));
+	fprintf(s->definition_f, "#define NULL ((void *)0)\n");
+
+	return s;
+
+out_declarations:
+	fclose(s->definition_f);
+out_definitions:
+	free(s);
+
+	return NULL;
+}
+
+void fini_serialization_stream(struct serialization_stream *s)
+{
+
+	/* Just in case something was left over */
+	process_serialization_queue(s);
+
+	fprintf(s->declaration_f, "\n");
+	fprintf(s->definition_f, "\n");
+
+	fclose(s->definition_f);
+	fclose(s->declaration_f);
+
+	free(s);
+}
+
diff --git a/serialization.h b/serialization.h
new file mode 100644
index 0000000..7805f50
--- /dev/null
+++ b/serialization.h
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2008 Alexey Zaytsev
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Alternatively, this program may be distributed under the
+ * Open Software License version 1.1.
+ */
+
+#ifndef SERIALIZATION_H
+#define SERIALIZATION_H
+
+#include <stdio.h>
+#include <stddef.h>
+#include <ctype.h>
+
+#define wrapper_overhead(w) (sizeof(w[0]) - sizeof(w->payload))
+#define container(ptr, type, member) \
+	(type *)((void *)(ptr) - offsetof(type, member))
+
+/*
+ * This structure is prepended to every object of serializable
+ * type. Do not bloat.
+ */
+struct serialization_mdata {
+	unsigned int index:30;
+	unsigned int declared:1;
+	unsigned int defined:1;
+};
+
+struct serialization_stream {
+	FILE *declaration_f;
+	FILE *definition_f;
+	struct serialization_sched_work *queue;
+};
+struct serialization_sched_work {
+	struct serialization_stream *stream;
+	void *unit;
+	int (*serializer) (struct serialization_stream *s,
+		void *unit);
+	struct serialization_sched_work *next;
+};
+
+
+int serialization_stream_enqueue(struct serialization_stream *s, void *unit,
+	int (serializaer) (struct serialization_stream *s, void *unit));
+int process_serialization_queue(struct serialization_stream *s);
+struct serialization_stream *new_serialization_stream(const char *file);
+void fini_serialization_stream(struct serialization_stream *s);
+
+
+#define DO_WRAP(type, type_name, type_header, allocator, allocator_name,	\
+		deallocator, deallocator_name, serializer)			\
+	static int type_name##_index = 0;					\
+	type *allocator_name(int n)						\
+	{									\
+		struct type_name##_wrapper *w;					\
+		w = (struct type_name##_wrapper *)				\
+			allocator(n + wrapper_overhead(w)); 			\
+		if (!w)								\
+			return NULL;						\
+		return &w->payload;						\
+	}									\
+	void deallocator_name(type *t)						\
+	{									\
+		struct type_name##_wrapper *w;					\
+		w = container(t, struct type_name##_wrapper, payload);		\
+		deallocator((type *)w);						\
+	}									\
+	static int do_serialize_##type_name(struct serialization_stream *s,	\
+		void *unit)							\
+	{									\
+		struct type_name##_wrapper *w = unit;				\
+		int ret;							\
+		fprintf(s->definition_f, "static struct " #type_name "_wrapper "\
+			"__" #type_name "_%d = {\n\t.payload = {\n",		\
+			w->meta.index);						\
+		ret = serializer(s, &w->payload);				\
+		fprintf(s->definition_f, "\t},\n};\n");				\
+		if (ret)							\
+			fprintf(stderr, "Warning: Failed to serialize a " #type	\
+			": %d\n", ret);						\
+		return ret;							\
+	}									\
+	int schedule_##type_name##_serialization(struct serialization_stream *s,\
+		type *t)							\
+	{									\
+		struct type_name##_wrapper *w;					\
+		if (!t)								\
+			return 0; /* Tried to serialize a NULL pointer */	\
+		w = container(t, struct type_name##_wrapper, payload);		\
+		if (w->meta.declared)						\
+			return 0;	/* Either already serialized or waiting	\
+					 * in the queue */			\
+		if (!type_name##_index)						\
+			fprintf(s->declaration_f,				\
+				"\n#include %s\n", #type_header);		\
+										\
+		w->meta.index = type_name##_index++;				\
+		fprintf(s->declaration_f,					\
+			"static struct " #type_name "_wrapper "			\
+			"__" #type_name "_%d;\n",				\
+			w->meta.index);						\
+		w->meta.declared = 1;						\
+		return serialization_stream_enqueue(s, w,			\
+			do_serialize_##type_name);				\
+	}									\
+	int serialize_##type_name(struct serialization_stream *s,		\
+		type *t, const char *name)					\
+	{									\
+		int ret;							\
+		schedule_##type_name##_serialization(s, t);			\
+		ret = process_serialization_queue(s);				\
+		if (!ret && name)						\
+			ret = label_##type_name##_entry(s, t, name);		\
+		return ret; 							\
+	}									\
+	int label_##type_name##_entry(struct serialization_stream *s, type *t,	\
+		const char *name)						\
+	{									\
+		struct type_name##_wrapper *w;					\
+		if (!t) { 							\
+			fprintf(s->definition_f, #type " *%s = NULL;", name);	\
+			return 0;						\
+		}								\
+		w = container(t, struct type_name##_wrapper, payload);		\
+		if (!w->meta.declared) {					\
+			fprintf(stderr, "Warning: Trying to label an undefined"	\
+				" '" #type "'\n");				\
+			return -1;						\
+		}								\
+		fprintf(s->definition_f, #type " *%s = &"			\
+			"__" #type_name "_%d.payload;\n", name, w->meta.index);	\
+		return 0;							\
+	}
+
+
+#define WRAP(type_name, type_header, serializer)				\
+	DO_WRAP(struct type_name, type_name, type_header,			\
+		__alloc_##type_name##_core, __alloc_##type_name,		\
+		__free_##type_name##_core, __free_##type_name, serializer)
+
+#define emit_int(struam, parent, field)						\
+	do {									\
+		int __i = parent->field;					\
+		fprintf(s->definition_f, "\t\t." #field " = %d,\n", __i);	\
+	} while (0)
+
+#define emit_cstring(stream, parent, field)					\
+	do {									\
+		char *__tmp = parent->field;					\
+		if (!__tmp) {							\
+			fprintf(stream->definition_f,				\
+				"\t\t." #field " = NULL,\n");			\
+			break;							\
+		}								\
+		fprintf(stream->definition_f, "\t\t." #field " = \"");		\
+		while (*__tmp) {						\
+			if (isprint(*__tmp))	 				\
+				fputc(*__tmp, stream->definition_f);		\
+			else							\
+				fprintf(stream->definition_f, "\\x%2x",		\
+					*__tmp);				\
+			__tmp++;						\
+		}								\
+		fprintf(stream->definition_f, "\",\n");				\
+	} while (0);
+
+#define do_emit_ptr(stream, parent, type, type_name, field) 			\
+	do {									\
+		struct type_name##_wrapper *__w;				\
+		void *__ptr = parent->field;					\
+		if (!__ptr) {							\
+			fprintf(stream->definition_f,				\
+				"\t\t." #field " = NULL,\n");			\
+			break;							\
+		}								\
+		schedule_##type_name##_serialization(stream, __ptr);		\
+		__w = container(__ptr, struct type_name##_wrapper, payload);	\
+		fprintf(stream->definition_f, "\t\t." #field " = &"		\
+			"__" #type_name	"_%d.payload,\n", __w->meta.index);	\
+	} while (0)
+
+#define emit_ptr(stream, parent, type_name, field)				\
+	do_emit_ptr(stream, parent, struct type_name, type_name,		\
+		field)
+
+#define emit_ptr_array(stream, parent, type, type_name, field, nr)		\
+	do {									\
+		struct type_name##_wrapper *__w;				\
+		void *__ptr = parent->field;					\
+		int __i ;							\
+		fprintf(stream->definition_f, "\t\t." #field " = {\n");		\
+		for (__i = 0; __i < nr; __i++) {				\
+			__ptr = parent->field[__i];				\
+			if (__ptr) {						\
+				__w = container(__ptr,				\
+					struct type_name##_wrapper, payload);	\
+				schedule_##type_name##_serialization(s, __ptr);	\
+				fprintf(stream->definition_f,			\
+					"\t\t\t&" "__" #type_name		\
+					"_%d.payload,\n", __w->meta.index);	\
+			}							\
+		}								\
+		fprintf(stream->definition_f, "\t\t},\n");			\
+	} while (0)
+
+#define DO_DECLARE_WRAPPER(type, type_name, allocator_name, deallocator_name)	\
+	struct type_name##_wrapper {						\
+		struct serialization_mdata meta;				\
+		type payload;							\
+	};									\
+	type *allocator_name(int x);						\
+	void deallocator_name(type *t);						\
+	int schedule_##type_name##_serialization(struct serialization_stream *s,\
+		type *ptr);							\
+	int serialize_##type_name(struct serialization_stream *s,		\
+		type *t, const char *name);					\
+	int emit_##type_name##_ptr(struct serialization_stream *s,		\
+	 	type *t);							\
+	int label_##type_name##_entry(struct serialization_stream *s,		\
+		type *t, const char *name);
+
+#define DECLARE_WRAPPER(type_name)						\
+		DO_DECLARE_WRAPPER(struct type_name, type_name,			\
+			__alloc_##type_name, __free_##type_name)
+
+/* If you need to serialize statically-allocated data, use these. */
+#define DO_DECLARE_SERIALIZABLE(type, type_name, name)				\
+	struct type_name##_wrapper __##name_wrapped;				\
+	type *name = &__##wrapped.payload;
+
+#define DECLARE_SERIALIZABLE(type, name)					\
+	DO_DECLARE_SERIALIZABLE(struct type, type, name)
+
+#endif
+
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 02/16] Expand "dubious !x & y" handling to other combinations ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 02/16] Expand "dubious !x & y" handling to other combinations
Date: Thu, 18 Dec 2008 21:51:30 +0000
Message-ID: <20081218215130.28136.92813.stgit () zaytsev ! su>
--------------------
From: Josh Triplett <josh@freedesktop.org>

Signed-off-by: Josh Triplett <josh@freedesktop.org>
---
 evaluate.c                            |   13 ++++++++++---
 validation/dubious-bitwise-with-not.c |   19 +++++++++++++++++--
 2 files changed, 27 insertions(+), 5 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index c501323..f976645 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -921,9 +921,16 @@ static struct symbol *evaluate_binop(struct expression *expr)
 			rtype = integer_promotion(rtype);
 		} else {
 			// The rest do usual conversions
-			if (op == '&' && expr->left->type == EXPR_PREOP &&
-			    expr->left->op == '!')
-				warning(expr->pos, "dubious: !x & y");
+			const unsigned left_not  = expr->left->type == EXPR_PREOP
+			                           && expr->left->op == '!';
+			const unsigned right_not = expr->right->type == EXPR_PREOP
+			                           && expr->right->op == '!';
+			if ((op == '&' || op == '|') && (left_not || right_not))
+				warning(expr->pos, "dubious: %sx %c %sy",
+				        left_not ? "!" : "",
+					op,
+					right_not ? "!" : "");
+
 			ltype = usual_conversions(op, expr->left, expr->right,
 						  lclass, rclass, ltype, rtype);
 			ctype = rtype = ltype;
diff --git a/validation/dubious-bitwise-with-not.c b/validation/dubious-bitwise-with-not.c
index e076899..c48bcae 100644
--- a/validation/dubious-bitwise-with-not.c
+++ b/validation/dubious-bitwise-with-not.c
@@ -1,9 +1,24 @@
-static unsigned int ok1 = !1 && 2;
-static unsigned int bad1 = !1 & 2;
+static unsigned int ok1  = !1 &&  2;
+static unsigned int bad1 = !1 &   2;
+static unsigned int ok2  = !1 ||  2;
+static unsigned int bad2 = !1 |   2;
+static unsigned int ok3  =  1 && !2;
+static unsigned int bad3 =  1 &  !2;
+static unsigned int ok4  =  1 || !2;
+static unsigned int bad4 =  1 |  !2;
+static unsigned int ok5  = !1 && !2;
+static unsigned int bad5 = !1 &  !2;
+static unsigned int ok6  = !1 || !2;
+static unsigned int bad6 = !1 |  !2;
 /*
  * check-name: Dubious bitwise operation on !x
  *
  * check-error-start
 dubious-bitwise-with-not.c:2:31: warning: dubious: !x & y
+dubious-bitwise-with-not.c:4:31: warning: dubious: !x | y
+dubious-bitwise-with-not.c:6:31: warning: dubious: x & !y
+dubious-bitwise-with-not.c:8:31: warning: dubious: x | !y
+dubious-bitwise-with-not.c:10:31: warning: dubious: !x & !y
+dubious-bitwise-with-not.c:12:31: warning: dubious: !x | !y
  * check-error-end
  */

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 03/10] Check stdin if no input files given, like cc1. ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 03/10] Check stdin if no input files given, like cc1.
Date: Wed, 03 Sep 2008 21:55:47 +0000
Message-ID: <2faea660ccc7cae55a2d2cd28f64059b80356a8f.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 lib.c    |   42 +++++++++++++++++++++---------------------
 lib.h    |    6 +++---
 sparse.c |    3 +++
 3 files changed, 27 insertions(+), 24 deletions(-)

diff --git a/lib.c b/lib.c
index edb8ac9..0e30424 100644
--- a/lib.c
+++ b/lib.c
@@ -215,7 +215,7 @@ int dbg_dead = 0;
 
 int preprocess_only;
 int emit_code = 0;
-const char *output_file = "a.out";
+const char *output_file = NULL;
 
 static enum { STANDARD_C89,
               STANDARD_C94,
@@ -856,38 +856,38 @@ struct symbol_list *sparse_initialize(int argc, char **argv, struct string_list
 		if (!arg)
 			break;
 
-		if (arg[0] == '-' && arg[1]) {
-			args = handle_switch(arg+1, args);
+		if (arg[0] == '-') {
+			if (arg[1])
+				args = handle_switch(arg+1, args);
 			continue;
 		}
 		add_ptr_list_notag(filelist, arg);
 
 	}
+
 	handle_switch_W_finalize();
 	handle_switch_v_finalize();
 
-	list = NULL;
-	if (!ptr_list_empty(filelist)) {
-		// Initialize type system
-		init_ctype();
+	// Initialize type system
+	init_ctype();
 
-		create_builtin_stream();
-		add_pre_buffer("#define __CHECKER__ 1\n");
-		if (!preprocess_only)
-			declare_builtin_functions();
+	create_builtin_stream();
+	add_pre_buffer("#define __CHECKER__ 1\n");
+	if (!preprocess_only)
+		declare_builtin_functions();
 
-		list = sparse_initial();
+	list = sparse_initial();
+
+	/*
+	 * Protect the initial token allocations, since
+	 * they need to survive all the others
+	 */
+	protect_token_alloc();
 
-		/*
-		 * Protect the initial token allocations, since
-		 * they need to survive all the others
-		 */
-		protect_token_alloc();
-	}
 	return list;
 }
 
-struct symbol_list * sparse_keep_tokens(char *filename)
+struct symbol_list * sparse_keep_tokens(const char *filename)
 {
 	struct symbol_list *res;
 
@@ -902,7 +902,7 @@ struct symbol_list * sparse_keep_tokens(char *filename)
 }
 
 
-struct symbol_list * __sparse(char *filename)
+struct symbol_list * __sparse(const char *filename)
 {
 	struct symbol_list *res;
 
@@ -915,7 +915,7 @@ struct symbol_list * __sparse(char *filename)
 	return res;
 }
 
-struct symbol_list * sparse(char *filename)
+struct symbol_list * sparse(const char *filename)
 {
 	struct symbol_list *res = __sparse(filename);
 
diff --git a/lib.h b/lib.h
index b74be7c..19a724f 100644
--- a/lib.h
+++ b/lib.h
@@ -118,9 +118,9 @@ extern const char *output_file;
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
 extern struct symbol_list *sparse_initialize(int argc, char **argv, struct string_list **files);
-extern struct symbol_list *__sparse(char *filename);
-extern struct symbol_list *sparse_keep_tokens(char *filename);
-extern struct symbol_list *sparse(char *filename);
+extern struct symbol_list *__sparse(const char *filename);
+extern struct symbol_list *sparse_keep_tokens(const char *filename);
+extern struct symbol_list *sparse(const char *filename);
 
 static inline int symbol_list_size(struct symbol_list *list)
 {
diff --git a/sparse.c b/sparse.c
index 785a6f6..b7a1f8b 100644
--- a/sparse.c
+++ b/sparse.c
@@ -602,6 +602,9 @@ int main(int argc, char **argv)
 
 	// Expand, linearize and show it.
 	check_symbols(sparse_initialize(argc, argv, &filelist));
+	if (ptr_list_empty(filelist))
+		check_symbols(sparse("-"));
+
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		check_symbols(sparse(file));
 	} END_FOR_EACH_PTR_NOTAG(file);
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 03/15] Add type information to struct instruction. ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 03/15] Add type information to struct instruction.
Date: Wed, 24 Dec 2008 23:27:47 +0000
Message-ID: <70318cbf0812241527h6abf21f1hbaa2d9c4b40d566b () mail ! gmail ! com>
--------------------
On Wed, Dec 24, 2008 at 3:01 PM, David Given <dg@cowlark.com> wrote:
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
>
> Christopher Li wrote:
> [...]
>> OK, if it is just for OP_LOAD. Will this attached patch solve your problem?
>>
>> Instead of adding type to every instruction. It just add that for the OP_LOAD
>> instruction in insn->orig_type. If that works for you. I am very glad to reclaim
>> the space back on instruction structure.
>
> Sorry, I'm not at home right now and can't test this (and probably won't
> until New Year, though I'll have a go).

No problem. Have a nice Christmas.

>
> Also, I don't know if it *is* just of OP_LOAD. That's just the one I
> remember from looking back at old email. I think the issue is that
> OP_LOAD breaks the chain of pseudo->definer->pseudo->definer that I was
> using to determine the intrinsic type of the pseudo, but there may be
> other instructions that do this as well.

I hope that is the only one. Let me know if you find out there is
more instructions.

>
> I'd imagine that nobody else has come across this yet because most
> people are happy using the size to distinguish between different types;
> but (assuming that I've remembered this correctly) this'll bite anyone
> who needs to distinguish floats from int32s of doubles from int64s.

Right, other than the size, we need to distinguish between:
(sign/unsign) integer, floating point, pointers.
That is why we even have three type of cast instruction.
CAST, CASTFP and CASTPTR. They can generate fairly different
code.


> If space is really an issue, would it make sense therefore to replace
> the insn->size (and symbol->size etc) field with a ->type field pointing
> at the defining symbol for the type? Anyone who needs the type can get
> it from the defining symbol, plus all the other information that people
> like me need would be available, and may also simplify other code. (I
> could throw away a complete source file!)

Right, that is what I am purposing in previous email as well.
It looks have more code up front. But it can simplify the back end
who actually going to use it. It is actually much easier to do it
from front end while initializing those symbols.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 04/10] Add char *first_string(struct string_list *) ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 04/10] Add char *first_string(struct string_list *)
Date: Wed, 03 Sep 2008 21:55:48 +0000
Message-ID: <c97fb6bb13fb17d09a2d1525cb5b813ecebb804d.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 lib.h     |    5 +++++
 ptrlist.h |   17 ++++++++++++++++-
 2 files changed, 21 insertions(+), 1 deletions(-)

diff --git a/lib.h b/lib.h
index 19a724f..532e7a4 100644
--- a/lib.h
+++ b/lib.h
@@ -186,6 +186,11 @@ static inline pseudo_t first_pseudo(struct pseudo_list *head)
 	return first_ptr_list((struct ptr_list *)head);
 }
 
+static inline char *first_string(struct string_list *head)
+{
+	return first_ptr_list_notag((struct ptr_list *)head);
+}
+
 static inline void concat_symbol_list(struct symbol_list *from, struct symbol_list **to)
 {
 	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
diff --git a/ptrlist.h b/ptrlist.h
index dae0906..fe43de1 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -73,15 +73,30 @@ static inline void *first_ptr_list(struct ptr_list *list)
 	return PTR_ENTRY(list, 0);
 }
 
-static inline void *last_ptr_list(struct ptr_list *list)
+static inline void *first_ptr_list_notag(struct ptr_list *list)
 {
+	if (!list)
+		return NULL;
+	return PTR_ENTRY_NOTAG(list, 0);
+}
 
+static inline void *last_ptr_list(struct ptr_list *list)
+{
 	if (!list)
 		return NULL;
 	list = list->prev;
 	return PTR_ENTRY(list, list->nr-1);
 }
 
+static inline void *last_ptr_list_notag(struct ptr_list *list)
+{
+	if (!list)
+		return NULL;
+	list = list->prev;
+	return PTR_ENTRY_NOTAG(list, list->nr-1);
+}
+
+
 #define DO_PREPARE(head, ptr, __head, __list, __nr, PTR_ENTRY)				\
 	do {										\
 		struct ptr_list *__head = (struct ptr_list *) (head);			\
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 04/16] Let cgcc pass -gcc-base-dir to sparse. ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 04/16] Let cgcc pass -gcc-base-dir to sparse.
Date: Thu, 18 Dec 2008 21:52:15 +0000
Message-ID: <20081218215215.28136.22788.stgit () zaytsev ! su>
--------------------
Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 cgcc |   14 +++++++++++++-
 1 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/cgcc b/cgcc
index cda8dab..fdda6d1 100755
--- a/cgcc
+++ b/cgcc
@@ -10,9 +10,11 @@ my $has_specs = 0;
 my $gendeps = 0;
 my $do_check = 0;
 my $do_compile = 1;
+my $gcc_base_dir;
 my $verbose = 0;
 
-foreach (@ARGV) {
+while (@ARGV) {
+    $_ = shift(@ARGV);
     # Look for a .c file.  We don't want to run the checker on .o or .so files
     # in the link run.  (This simplistic check knows nothing about options
     # with arguments, but it seems to do the job.)
@@ -36,6 +38,12 @@ foreach (@ARGV) {
 	next;
     }
 
+    if (/^-gcc-base-dir$/) {
+        $gcc_base_dir = shift @ARGV;
+        die ("$0: missing argument for -gcc-base-dir option") if !$gcc_base_dir;
+        next;
+    }
+
     # If someone adds "-E", don't pre-process twice.
     $do_compile = 0 if $_ eq '-E';
 
@@ -56,6 +64,10 @@ if ($do_check) {
 	$check .= &add_specs ('host_arch_specs');
 	$check .= &add_specs ('host_os_specs');
     }
+
+    $gcc_base_dir = qx($cc -print-file-name=) if !$gcc_base_dir;
+    $check .= " -gcc-base-dir " . $gcc_base_dir if $gcc_base_dir;
+
     print "$check\n" if $verbose;
     if ($do_compile) {
 	system ($check);

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 05/10] Serializable ptr lists. ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 05/10] Serializable ptr lists.
Date: Wed, 03 Sep 2008 21:55:49 +0000
Message-ID: <b0118cf8f9301f77a141af47739aa599ae1e624b.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 ptrlist.c |   30 +++++++++++++++++++++++++++---
 ptrlist.h |    7 +++++++
 2 files changed, 34 insertions(+), 3 deletions(-)

diff --git a/ptrlist.c b/ptrlist.c
index 2620412..fb6b6db 100644
--- a/ptrlist.c
+++ b/ptrlist.c
@@ -12,9 +12,33 @@
 #include "ptrlist.h"
 #include "allocate.h"
 #include "compat.h"
+#include "lib.h"
+#include "serialization.h"
+
+static int ptr_list_serializer(struct serialization_stream *s, struct ptr_list *w)
+{
+	die("Don't serialize abstract ptr lists, serialize your custom ones.");
+	return 0;
+}
+
+__DECLARE_ALLOCATOR(struct ptr_list, ptr_list_core);
+__ALLOCATOR(struct ptr_list, "ptr list", ptr_list_core);
+DO_WRAP(struct ptr_list, ptr_list, "ptrlist.h", __alloc_ptr_list_core,
+	__alloc_ptrlist, __free_ptr_list_core, __free_ptrlist,
+	ptr_list_serializer);
+
+
+struct ptr_list *fail_ptrlist_allocation(int i)
+{
+        die("Don't try to allocate ptr_list instances directly, use __add_ptr_list instead.");
+        return NULL;
+}
+
+void fail_ptrlist_free(void *p)
+{
+        die("Don't free ptr list instances directly, use free_ptr_list instead.");
+}
 
-__DECLARE_ALLOCATOR(struct ptr_list, ptrlist);
-__ALLOCATOR(struct ptr_list, "ptr list", ptrlist);
 
 int ptr_list_size(struct ptr_list *head)
 {
@@ -95,7 +119,7 @@ restart:
 			entry = next;
 		} while (entry != head);
 	}
-}		
+}
 
 void split_ptr_list_head(struct ptr_list *head)
 {
diff --git a/ptrlist.h b/ptrlist.h
index fe43de1..1a16819 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -7,6 +7,8 @@
  * (C) Copyright Linus Torvalds 2003-2005
  */
 
+#include "serialization.h"
+
 #define container(ptr, type, member) \
 	(type *)((void *)(ptr) - offsetof(type, member))
 
@@ -32,6 +34,8 @@ struct ptr_list {
 	void *list[LIST_NODE_NR];
 };
 
+DO_DECLARE_WRAPPER(struct ptr_list, ptr_list, __alloc_ptrlist, __free_ptrlist);
+
 #define ptr_list_empty(x) ((x) == NULL)
 
 void * undo_ptr_list_last(struct ptr_list **head);
@@ -46,6 +50,9 @@ extern void __free_ptr_list(struct ptr_list **);
 extern int ptr_list_size(struct ptr_list *);
 extern int linearize_ptr_list(struct ptr_list *, void **, int);
 
+/* To be used by custom ptr list serializers. */
+struct ptr_list *fail_ptrlist_allocation(int);
+void fail_ptrlist_free(void *);
 /*
  * Hey, who said that you can't do overloading in C?
  *
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 05/16] Document -gcc-base-dir in sparse.1 ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 05/16] Document -gcc-base-dir in sparse.1
Date: Thu, 18 Dec 2008 21:52:29 +0000
Message-ID: <20081218215229.28136.17429.stgit () zaytsev ! su>
--------------------
Signed-off-by: Alexey zaytsev <alexey.zaytsev@gmail.com>
---
 sparse.1 |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/sparse.1 b/sparse.1
index d242dc7..92a1cae 100644
--- a/sparse.1
+++ b/sparse.1
@@ -287,6 +287,11 @@ However, this behavior can lead to subtle errors.
 
 Sparse does not issue these warnings by default.
 .
+.SH MISC OPTIONS
+.TP
+.B \-gcc-base-dir \fIdir\fR
+Look for compiler-provided system headers in \fIdir\fR/include/ and \fIdir\fR/include-fixed/.
+.
 .SH SEE ALSO
 .BR cgcc (1)
 .

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 06/10] Linker core, serialization and helper functions. ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 06/10] Linker core, serialization and helper functions.
Date: Wed, 03 Sep 2008 21:55:50 +0000
Message-ID: <ad58a8f48bbd496a896ef370772e8a12101560f5.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 Makefile |    6 +++-
 link.c   |   57 ++++++++++++++++++++++++++++++++++++++++
 link.h   |   87 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 148 insertions(+), 2 deletions(-)
 create mode 100644 link.c
 create mode 100644 link.h

diff --git a/Makefile b/Makefile
index 721979e..dd1fe8a 100644
--- a/Makefile
+++ b/Makefile
@@ -40,13 +40,13 @@ endif
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
-	  storage.h ptrlist.h dissect.h serialization.h
+	  storage.h ptrlist.h dissect.h serialization.h link.h
 
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
 	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o \
-	  serialization.o
+	  serialization.o link.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -189,7 +189,9 @@ compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 compat-solaris.o: compat/mmap-blob.c $(LIB_H)
 compat-mingw.o: $(LIB_H)
 compat-cygwin.o: $(LIB_H)
+serialization.o: $(LIB_H)
 serialization-test.o: $(LIB_H)
+link.o: $(LIB_H)
 
 pre-process.h:
 	$(QUIET_GEN)echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=`\"" > pre-process.h
diff --git a/link.c b/link.c
new file mode 100644
index 0000000..8d2eadf
--- /dev/null
+++ b/link.c
@@ -0,0 +1,57 @@
+
+#define _GNU_SOURCE
+#include <string.h>
+
+#include "lib.h"
+#include "link.h"
+
+__ALLOCATOR(struct sold_srcfile, "sold_srcfile", sold_srcfile_core);
+__ALLOCATOR(struct sold_symbol, "sold_smbol", sold_symbol_core);
+
+int sold_srcfile_serialize(struct serialization_stream *s,
+	struct sold_srcfile *w);
+
+int sold_symbol_serialize(struct serialization_stream *s,
+	struct sold_symbol *w);
+
+int sold_symbol_list_serialize(struct serialization_stream *s,
+	struct ptr_list *w);
+
+WRAP(sold_srcfile, <sparse/link.h>, sold_srcfile_serialize);
+WRAP(sold_symbol, <sparse/link.h>, sold_symbol_serialize);
+DO_WRAP(struct ptr_list, sold_symbol_list, <sparse/link.h>,
+	fail_ptrlist_allocation, __alloc_sold_symbol_list,
+	fail_ptrlist_free, __free_sold_symbol_list,
+	sold_symbol_list_serialize);
+
+int sold_srcfile_serialize(struct serialization_stream *s,
+	struct sold_srcfile *w)
+{
+	emit_cstring(s, w, source);
+	emit_cstring(s, w, buildroot);
+	emit_cstring(s, w, cflags);
+
+	return 0;
+}
+
+int sold_symbol_serialize(struct serialization_stream *s,
+	struct sold_symbol *w)
+{
+	emit_cstring(s, w, name);
+	emit_ptr(s, w, sold_srcfile, source);
+	emit_int(s, w, type);
+
+	return 0;
+}
+
+int sold_symbol_list_serialize(struct serialization_stream *s,
+	struct ptr_list *w)
+{
+	emit_int(s, w, nr);
+	emit_ptr(s, w, sold_symbol_list, prev);
+	emit_ptr(s, w, sold_symbol_list, next);
+	emit_ptr_array(s, w, struct sold_symbol, sold_symbol, list, w->nr);
+	return 0;
+}
+
+
diff --git a/link.h b/link.h
new file mode 100644
index 0000000..eed83ff
--- /dev/null
+++ b/link.h
@@ -0,0 +1,87 @@
+
+#ifndef LINK_H
+#define LINK_H
+
+#include <string.h>
+#include <errno.h>
+
+
+#include "ptrlist.h"
+#include "allocate.h"
+#include "symbol.h"
+#include "serialization.h"
+
+
+struct sold_srcfile {
+	char *source;
+	char *buildroot;
+	char *cflags;
+};
+
+enum sold_sym_type {
+	SOLD_SYM_FUNCTION,
+	SOLD_SYM_DATA,
+	SOLD_SYM_OTHER,
+};
+
+struct sold_symbol {
+	struct sold_srcfile *source;
+	enum sold_sym_type type;
+	char *name;
+};
+
+
+__DECLARE_ALLOCATOR(struct sold_srcfile, sold_srcfile_core);
+__DECLARE_ALLOCATOR(struct sold_symbol, sold_symbol_core);
+
+DECLARE_PTR_LIST(sold_symbol_list, struct sold_symbol);
+
+DO_DECLARE_WRAPPER(struct sold_srcfile, sold_srcfile,
+	__alloc_sold_srcfile, __free_sold_srcfile);
+DO_DECLARE_WRAPPER(struct sold_symbol, sold_symbol,
+	__alloc_sold_symbol, __free_sold_symbol);
+DO_DECLARE_WRAPPER(struct ptr_list, sold_symbol_list,
+	__alloc_sold_symbol_list, __free_sold_symbol_list);
+
+static inline void do_add_sold_sym_list(struct sold_symbol_list **list,
+	struct sold_symbol *sym)
+{
+	add_ptr_list(list, sym);
+}
+
+static inline int add_sold_sym_list(struct sold_symbol_list **list,
+	struct symbol *sym, struct sold_srcfile *file)
+{
+	struct sold_symbol *sold_sym;
+
+	if (!sym->ident)
+		error_die(sym->pos, "Trying to serialize non-bound symbol");
+
+	sold_sym = __alloc_sold_symbol(0);
+	if (!sold_sym)
+		return -ENOMEM;
+
+	sold_sym->name = sym->ident->name;
+	sold_sym->source = file;
+	sold_sym->type = SOLD_SYM_OTHER;
+	if (sym->type == SYM_NODE) {
+		if (sym->ctype.base_type->type == SYM_FN)
+			sold_sym->type = SOLD_SYM_FUNCTION;
+		else
+			sold_sym->type = SOLD_SYM_DATA;
+	}
+
+	do_add_sold_sym_list(list, sold_sym);
+
+	return 0;
+}
+
+static inline void concat_sold_sym_list(struct sold_symbol_list *from,
+	struct sold_symbol_list **to)
+{
+	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
+}
+
+#endif
+
+
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 06/16] Rename dirafter to idirafter. ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 06/16] Rename dirafter to idirafter.
Date: Thu, 18 Dec 2008 21:52:38 +0000
Message-ID: <20081218215238.28136.79472.stgit () zaytsev ! su>
--------------------
Dirafter was probably just a mistake.
Gcc uses -idirafter.

Acked-by: Sam Ravnborg <sam@ravnborg.org>
Signed-off-by: Alexey zaytsev <alexey.zaytsev@gmail.com>
---
 lib.c         |   15 +++++----------
 pre-process.c |    4 ++--
 2 files changed, 7 insertions(+), 12 deletions(-)

diff --git a/lib.c b/lib.c
index 45a4f39..dc2da14 100644
--- a/lib.c
+++ b/lib.c
@@ -321,6 +321,11 @@ static char **handle_switch_i(char *arg, char **next)
 		if (!path)
 			die("missing argument for -isystem option");
 		add_pre_buffer("#add_isystem \"%s/\"\n", path);
+	} else if (*next && !strcmp(arg, "idirafter")) {
+		char *path = *++next;
+		if (!path)
+			die("missing argument for -idirafter option");
+		add_pre_buffer("#add_dirafter \"%s/\"\n", path);
 	}
 	return next;
 }
@@ -584,15 +589,6 @@ static char **handle_nostdinc(char *arg, char **next)
 	return next;
 }
 
-static char **handle_dirafter(char *arg, char **next)
-{
-	char *path = *++next;
-	if (!path)
-		die("missing argument for -dirafter option");
-	add_pre_buffer("#add_dirafter \"%s/\"\n", path);
-	return next;
-}
-
 static char **handle_base_dir(char *arg, char **next)
 {
 	gcc_base_dir = *++next;
@@ -610,7 +606,6 @@ static char **handle_switch(char *arg, char **next)
 {
 	static struct switches cmd[] = {
 		{ "nostdinc", handle_nostdinc },
-		{ "dirafter", handle_dirafter },
 		{ "gcc-base-dir", handle_base_dir},
 		{ NULL, NULL }
 	};
diff --git a/pre-process.c b/pre-process.c
index 9c6ef5b..cf53893 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -682,10 +682,10 @@ static int already_tokenized(const char *path)
  *   angle_includepath is set equal to isys_includepath.
  * -nostdinc removes all sys dirs by storing NULL in entry pointed
  *   to by * sys_includepath. Note that this will reset all dirs built-in
- *   and added before -nostdinc by -isystem and -dirafter.
+ *   and added before -nostdinc by -isystem and -idirafter.
  * -isystem dir adds dir where isys_includepath points adding this dir as
  *   first systemdir
- * -dirafter dir adds dir to the end of the list
+ * -idirafter dir adds dir to the end of the list
  */
 
 static void set_stream_include_path(struct stream *stream)

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 08/10] Sparse Object Link eDitor ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 08/10] Sparse Object Link eDitor
Date: Wed, 03 Sep 2008 21:55:52 +0000
Message-ID: <22963cd6ccaf20f03b680bde72da86355da740b3.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 Makefile |    9 +++-
 sold.c   |  127 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 133 insertions(+), 3 deletions(-)
 create mode 100644 sold.c

diff --git a/Makefile b/Makefile
index dd1fe8a..4fa2f82 100644
--- a/Makefile
+++ b/Makefile
@@ -2,7 +2,6 @@ VERSION=0.4.1
 
 OS = linux
 
-
 CC = gcc
 CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
 CFLAGS += -Wall -Wwrite-strings
@@ -27,10 +26,10 @@ INCLUDEDIR=$(PREFIX)/include
 PKGCONFIGDIR=$(LIBDIR)/pkgconfig
 
 PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize example \
-	 test-unssa test-dissect ctags serialization-test
+	 test-unssa test-dissect ctags serialization-test sold
 
 
-INST_PROGRAMS=sparse cgcc
+INST_PROGRAMS=sparse cgcc sold
 INST_MAN1=sparse.1 cgcc.1
 
 ifeq ($(HAVE_LIBXML),yes)
@@ -139,6 +138,9 @@ c2xml: c2xml.o $(LIBS)
 serialization-test: serialization-test.o $(LIBS)
 	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+sold: sold.o $(LIBS)
+	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS) -ldl
+
 $(LIB_FILE): $(LIB_OBJS)
 	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)
 
@@ -192,6 +194,7 @@ compat-cygwin.o: $(LIB_H)
 serialization.o: $(LIB_H)
 serialization-test.o: $(LIB_H)
 link.o: $(LIB_H)
+sold.o: $(LIB_H)
 
 pre-process.h:
 	$(QUIET_GEN)echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=`\"" > pre-process.h
diff --git a/sold.c b/sold.c
new file mode 100644
index 0000000..3da0cad
--- /dev/null
+++ b/sold.c
@@ -0,0 +1,127 @@
+
+#include <stdio.h>
+#include <limits.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+
+#include "lib.h"
+#include "link.h"
+#include "ptrlist.h"
+
+static const char *output = NULL;
+
+static char **handle_switch(char *arg, char **next)
+{
+	switch(*arg) {
+	case 'o':
+		if (!strcmp (arg, "o")) { 	// "-o foo"
+			next++;
+			if (!*next)
+				die("argument to '-o' is missing");
+			output = *next;
+		} else { 			// "-ofoo"
+			output = ++arg;
+		}
+		break;
+	case 'm':
+		if (!strcmp (arg, "m")) { 	// "-m foo"
+			next++;
+			if (!*next)
+				die("argument to '-m' is missing");
+		}
+		break;
+	case 'T':
+		if (!strcmp (arg, "m")) { 	// "-T foo"
+			next++;
+			if (!*next)
+				die("argument to '-T' is missing");
+		}
+		break;
+	}
+
+	return next;
+}
+
+char *input_name(const char *file)
+{
+	static char buf[PATH_MAX+1];
+	snprintf(buf, PATH_MAX, "./%s.sparse.so", file);
+	return buf;
+}
+
+int main(int argc, char **argv)
+{
+	char **args;
+	const char sym_type_tbl[] = {'F', 'D', 'O'}; /* Func, Data, Other */
+	struct string_list *file_list = NULL;
+	struct sold_symbol_list *out_symbols = NULL;
+	struct sold_symbol *sym;
+	struct serialization_stream *s;
+	char *file;
+	char *input_file;
+
+
+	args = argv;
+	for (;;) {
+		char *arg = *++args;
+		if (!arg)
+			break;
+
+		if (arg[0] == '-') {
+			if (arg[1])
+				args = handle_switch(arg+1, args);
+			continue;
+		}
+		add_ptr_list_notag(&file_list, arg);
+	}
+
+	output = output ? output : "a.out";
+
+	printf("output_file = %s\n", output);
+
+	FOR_EACH_PTR_NOTAG(file_list, file) {
+		void *handle;
+		struct sold_symbol_list **symbols;
+
+		printf("Input file: %s\n", file);
+		input_file = input_name(file);
+		printf("Sparse object: %s\n", input_file);
+
+		handle = dlopen(input_file, RTLD_NOW);
+		if (!handle) {
+			fprintf(stderr, "%s: Can't open input file %s. Ignoring it.\n",
+				argv[0], input_file);
+			continue;
+		}
+		symbols = dlsym(handle, "symbols");
+		if (!symbols) {
+			fprintf(stderr, "%s: %s: this input file does not "
+				"look like a sparse object file. Ignoring it.\n",
+				argv[0], input_file);
+			continue;
+		}
+
+		FOR_EACH_PTR(*symbols, sym) {
+			printf ("%c %s from %s\n", sym_type_tbl[sym->type],
+				sym->name, sym->source->source);
+		} END_FOR_EACH_PTR (sym);
+
+		concat_sold_sym_list(*symbols, &out_symbols);
+	} END_FOR_EACH_PTR_NOTAG(file);
+
+	printf("Resulting object file (%s):\n", output);
+	FOR_EACH_PTR (out_symbols, sym) {
+		printf ("%c %s from %s\n", sym_type_tbl[sym->type],
+			sym->name, sym->source->source);
+	} END_FOR_EACH_PTR (sym);
+
+	s = new_serialization_stream(output);
+	if (!s) {
+		perror("Failed to open the serialization stream");
+		exit(1);
+	}
+	serialize_sold_symbol_list(s, (struct ptr_list *) out_symbols, "symbols");
+	fini_serialization_stream(s);
+
+	return 0;
+}
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 08/16] Add test for acquire/release ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 08/16] Add test for acquire/release
Date: Thu, 18 Dec 2008 22:33:11 +0000
Message-ID: <20081218223237.23692.62518.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

	Test that giving
	__attribute__((context(TEST,1,0)))
	__attribute__((context(TEST,0,1)))
instead of
	__attribute__((context(TEST,1,1)))
works.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 validation/context.c |   15 +++++++++++++++
 1 files changed, 15 insertions(+), 0 deletions(-)

diff --git a/validation/context.c b/validation/context.c
index 0b45ba3..e8bb125 100644
--- a/validation/context.c
+++ b/validation/context.c
@@ -380,6 +380,21 @@ static int warn_conditional(void)
     return 0;
 }
 
+static void good_require(void)
+__attribute__((context(TEST,1,0)))
+__attribute__((context(TEST,0,1)))
+{
+    __context__(TEST,-1);
+    __context__(TEST,1);
+}
+
+static void good_require_caller(void)
+{
+    __context__(TEST,1,0);
+    good_require();
+    __context__(TEST,-1,1);
+}
+
 /*
  * check-name: Check -Wcontext
  *

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 09/10] Rewrite cgcc, add cld and car to wrap ld and ar ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 09/10] Rewrite cgcc, add cld and car to wrap ld and ar
Date: Wed, 03 Sep 2008 21:55:53 +0000
Message-ID: <5a555e4fe88da659e97a22698d58e6e54ec57f54.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

cgcc now compiles the serialized data produced by sparse
and also now it is able to handle multiple source files
well.

cld and car are there to integrate the sparse linker
into your build environment, wrapping ld and ar, and
compiling the data serialized by the sparse linker.

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 Makefile |    2 +-
 car      |   72 ++++++++++++++++++
 cgcc     |  252 ++++++++++++++++++++++++++++++++++++++++++++++++++++----------
 cld      |   84 +++++++++++++++++++++
 4 files changed, 369 insertions(+), 41 deletions(-)
 create mode 100755 car
 create mode 100755 cld

diff --git a/Makefile b/Makefile
index 4fa2f82..877634c 100644
--- a/Makefile
+++ b/Makefile
@@ -29,7 +29,7 @@ PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize
 	 test-unssa test-dissect ctags serialization-test sold
 
 
-INST_PROGRAMS=sparse cgcc sold
+INST_PROGRAMS=sparse sold cgcc cld car
 INST_MAN1=sparse.1 cgcc.1
 
 ifeq ($(HAVE_LIBXML),yes)
diff --git a/car b/car
new file mode 100755
index 0000000..5da892d
--- /dev/null
+++ b/car
@@ -0,0 +1,72 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+my $ar = $ENV{'REAL_AR'} || 'ar';
+my $linker = $ENV{'CLD'} || 'cld';
+
+my $verbose = 1;
+my $do_real_ar = 1;
+my $do_ar = 1;
+
+my $options = "";
+
+# We assume the first argument be the option string,
+# the second - the output name and all other - input names.
+
+die "Not enough arguments" if @ARGV < 2;
+
+foreach(@ARGV) {
+    if ($_ eq '-no-archive') {
+        $do_ar = 0;
+        next;
+    }
+
+    if ($_ eq '-no-real-archive') {
+        $do_real_ar = 0;
+        next;
+    }
+
+    if ($_ eq '-check-verbose') {
+        $verbose = 1;
+        next;
+    }
+
+    $options .= ' ' . &quote_arg ($_);
+}
+
+if ($do_real_ar) {
+    print STDERR "$ar $options\n" if $verbose;
+    my $res = system("$ar $options");
+    $res >>= 8;
+
+    exit $res if $res;
+}
+
+# We use our existing linker wrapper, as it basically does
+# the same thing.
+if ($do_ar) {
+    shift @ARGV; # remove the option string.
+    my $out = shift @ARGV;
+    my $inputs = join(" ", @ARGV); # everything else is an input file
+
+    if ($inputs) {
+        print STDERR "$linker -no-real-link -o $out $inputs";
+        system ("$linker -no-real-link -o $out $inputs");
+    }
+}
+
+exit 0;
+
+# -----------------------------------------------------------------------------
+# Simple arg-quoting function.  Just adds backslashes when needed.
+
+sub quote_arg {
+    my ($arg) = @_;
+    return "''" if $arg eq '';
+    return join ('',
+		 map {
+		     m|^[-a-zA-Z0-9._/,=]+$| ? $_ : "\\" . $_;
+		 } (split (//, $arg)));
+}
+
diff --git a/cgcc b/cgcc
index 89adbed..4484d0c 100755
--- a/cgcc
+++ b/cgcc
@@ -1,75 +1,242 @@
 #!/usr/bin/perl -w
 # -----------------------------------------------------------------------------
 
+use strict;
+
 my $cc = $ENV{'REAL_CC'} || 'cc';
+my $host_cc = $ENV{'HOST_CC'} || 'cc';
 my $check = $ENV{'CHECK'} || 'sparse';
+my $linker = $ENV{'SOLD'} || 'sold';
+
+my $cc_args = "";
+my $link_args = "";
+
+my @check_args_array;
 
 my $m32 = 0;
 my $m64 = 0;
 my $has_specs = 0;
-my $gendeps = 0;
-my $do_check = 0;
+my $do_check = 1;
+my $follow_check_status = 1;
 my $do_compile = 1;
+my $do_emit_code = 0;
+my $do_link = 1;
 my $verbose = 0;
 
-foreach (@ARGV) {
-    # Look for a .c file.  We don't want to run the checker on .o or .so files
-    # in the link run.  (This simplistic check knows nothing about options
-    # with arguments, but it seems to do the job.)
-    $do_check = 1 if /^[^-].*\.c$/;
+my @inputs;
+my $output;
 
-    # Ditto for stdin.
-    $do_check = 1 if $_ eq '-';
+my $compile_res = 0;
+my $check_res = 0;
 
-    $m32 = 1 if /^-m32$/;
-    $m64 = 1 if /^-m64$/;
-    $gendeps = 1 if /^-M$/;
+# split the gcc and sparse options.
+while (@ARGV) {
+    my $quote_arg;
+    $_ = shift @ARGV;
 
-    if (/^-specs=(.*)$/) {
-	$check .= &add_specs ($1);
-	$has_specs = 1;
-	next;
+    if ($_ eq '-no-compile') {
+        $do_compile = 0;
+        next;
     }
 
-    if ($_ eq '-no-compile') {
-	$do_compile = 0;
-	next;
+    if ($_ eq '-no-check') {
+        $do_check = 0;
+        next;
+    }
+
+    # Don't abort the build if the checker fails.
+    if ($_ eq '-no-follow-check-status') {
+        $follow_check_status = 0;
+        next;
+    }
+
+    if (/^-v+$/) {
+        $verbose = 1;
+        next;   # You probably didn't mean passing -v to gcc, right?
+                # Run with REAL_CC='cc -v' in such case.
     }
 
     # If someone adds "-E", don't pre-process twice.
-    $do_compile = 0 if $_ eq '-E';
+    # We can't disable compilation, because the caller may be asking
+    # gcc for its version (e.g. the Linux kernel does this).
+    $do_check = 0 if ($_ eq '-E' && $do_compile);
 
-    $verbose = 1 if $_ eq '-v';
+    # Don't check if called to generate dependencies.
+    $do_check = 0 if /^-M[MFGPQT]?$/;
 
     my $this_arg = ' ' . &quote_arg ($_);
-    $cc .= $this_arg unless &check_only_option ($_);
-    $check .= $this_arg unless &cc_only_option ($_);
+    $cc_args .= $this_arg unless &check_only_option ($_);
+    push @check_args_array, $_ unless &cc_only_option ($_);
 }
 
-if ($gendeps) {
-    $do_compile = 1;
-    $do_check = 0;
+if ($do_compile) {
+    print STDERR "cgcc: $cc $cc_args\n" if $verbose;
+    $compile_res = system ("$cc $cc_args") >> 8;
 }
 
 if ($do_check) {
-    if (!$has_specs) {
-	$check .= &add_specs ('host_arch_specs');
-	$check .= &add_specs ('host_os_specs');
+    my $check_args = "";
+
+    my @src_inputs;
+    my @link_inputs;
+    my $src_out;
+    my $link_out;
+
+    while(@check_args_array) {
+        $_ = shift @check_args_array;
+
+        # There are some options that cause gcc to only print some
+        # information, an not actually compile anything.
+
+        if (/^--(targer-)?help$/ ||
+            /^-dump(specs|version|machine)$/ ||
+            /^-print-*/) {
+
+            exit $compile_res;
+        }
+
+	if (/-arch=(\.*)$/) {
+		$check_args .= &add_specs ($1);
+		$has_specs = 1;
+		next;
+	}
+
+        # Everything that does not start with a dash, or is a dash itself is an input
+        if (!/^-+\w+/) {
+            push @inputs, $_;
+            next;   # We do not pass input files to sparse, instead
+                    # we run sparse for each input.
+        }
+
+        $m32 = 1 if /^-m32$/;
+        $m64 = 1 if /^-m64$/;
+
+        if ($_ eq '-emit-code') {
+            $do_emit_code = 1;
+        }
+
+        $do_link = 0 if $_ eq '-c' or $_ eq '-S';
+
+        # Output file.
+        if (/^-o(.*)/) {
+            if ($1) { # -ofoo
+                $output = $1;
+            } else { # -o foo
+            $output = shift @check_args_array;
+            if (!$output) { # terminal -o
+                die("$0: argument to '-o' is missing");
+                }
+            }
+            next;
+        }
+
+        if (/^-Wl,/) {
+            my @args = split /,/;
+            shift @args;
+            if ($do_link) {
+                $link_args .= join(" ", @args) . " ";
+            } else {
+                push @inputs, @args;    # Yes! Gcc interprets the -Wl options
+                                        # as inputs files, when runnign with -c.
+            }
+            next;
+        }
+
+        # Now there are some options that take arguments possibly separated
+        # with spaces. We have to recognise them to destinguish between
+        # option arguments and input files. Not really tested...
+        if (/^-D(.*)$/ ||
+		    /^-I(.*)$/ ||
+            /^-B(.*)$/ ||
+            /^-MF(.*)$/ ||
+            /^-MT(.*)$/ ||
+            /^-MQ(.*)$/ ||
+            /^-include$/ ||
+            /^-imacros$/ ||
+            /^-isystem$/) {
+            $check_args .= ' ' . &quote_arg ($_);
+            if (!$1) { 
+                $check_args .= ' ' . &quote_arg (shift @check_args_array);
+                # sparse should warn is the argument is actually missing.
+            }
+            next;
+	    }
+
+        # Ok, just a usual gcc option.
+        $check_args .= ' ' . &quote_arg ($_);
     }
-    print "$check\n" if $verbose;
-    if ($do_compile) {
-	system ($check);
-    } else {
-	exec ($check);
+
+    # gcc can have two types of inputs, sources and objects files.
+    # The sources we compile, the objects we link if needed
+    foreach(@inputs) {
+        if (/(\.[ch]|^-)$/) {
+            push @src_inputs, $_;
+        } else {
+            if ($do_link) {
+                push @link_inputs, $_;
+            } else {
+                warn "$0: $_: input file ignored because linking not performed";
+            }
+        }
     }
-}
 
-if ($do_compile) {
-    print "$cc\n" if $verbose;
-    exec ($cc);
+    if ($output) {
+        if ($do_link) {
+            $link_out = $output;
+        } else {
+            $src_out = $output;
+            die "$0: cannot specify -o with -c or -S with multiple files"  if @src_inputs > 1;
+        }
+    }
+
+    foreach (@src_inputs) {
+        my $in = $_;
+        my $out = $_;
+
+        # Won't feed stdin to both gcc and sparse.
+        if ($in =~ s/^-$//) {
+            next if $do_compile;
+        }
+
+        $out =~ s/\.[ch]$/\.o/;
+        $out =~ s/^-$/sparsedump/;
+
+        # In case output was explicitly specified with -o and no linking
+        # is performed, there can't be more than one source.
+
+        $out = $src_out ? $src_out : $out;
+
+        $check .= &add_specs ('host_arch_specs');
+        $check .= &add_specs ('host_os_specs');
+
+        print STDERR "cgcc: $check $check_args $in -o $out\n" if $verbose;
+
+        $check_res = system ("$check $check_args $in -o $out") >> 8;
+        if ($do_emit_code && !$check_res) {
+            # compile the code generated by sparse.
+            print "$host_cc -shared -fPIC $out.sparse.c -o $out.sparse.so\n" if $verbose;
+            system ("$host_cc -shared -fPIC $out.sparse.c -o $out.sparse.so");
+        }
+
+        # Add the checked file to the link list.
+        push @link_inputs, "$out";
+    }
+
+    if ($do_emit_code && !$check_res && $do_link && @link_inputs > 0) {
+    	my $out = $link_out ? $link_out : "a.out";
+        my $link_cmd = "$linker $link_args -o $out " . join(" ", @link_inputs);
+        print STDERR "cgcc: $link_cmd\n" if $verbose;
+        my $res = system($link_cmd);
+        if ($do_emit_code && !($res >> 8)) {
+            # compile the code generated by the linker.
+            print "$host_cc -shared -fPIC $out.sparse.c -o $out.sparse.so\n" if $verbose;
+            system ("$host_cc -shared -fPIC $out.sparse.c -o $out.sparse.so");
+        }
+    }
 }
 
-exit 0;
+my $res = $follow_check_status ? ($check_res | $compile_res ) : $compile_res;
+exit $res;
 
 # -----------------------------------------------------------------------------
 # Check if an option is for "check" only.
@@ -78,6 +245,9 @@ sub check_only_option {
     my ($arg) = @_;
     return 1 if $arg =~ /^-W(no-?)?(default-bitfield-sign|one-bit-signed-bitfield|cast-truncate|bitwise|typesign|context|undef|ptr-subtraction-blows|cast-to-as|decl|transparent-union|address-space|enum-mismatch|do-while|old-initializer|non-pointer-null|paren-string|return-void)$/;
     return 1 if $arg =~ /^-v(no-?)?(entry|dead)$/;
+    return 1 if $arg =~ /^-emit-code$/;
+    return 1 if $arg =~ /^-arch=.*$/;
+    return 1 if $arg =~ /^-v+$/; # You almost certainly don't want to pass -v to gcc.
     return 0;
 }
 
@@ -90,6 +260,8 @@ sub cc_only_option {
     # ones.  Don't include it just because a project wants to pass -Wall to cc.
     # If you really want cgcc to run sparse with -Wall, use
     # CHECK="sparse -Wall".
+
+    return 1 if $arg =~ /^-specs=.*$/;
     return 1 if $arg =~ /^-Wall$/;
     return 0;
 }
@@ -166,7 +338,7 @@ sub float_types {
 	     'EPSILON' => '1.92592994438723585305597794258492732e-34',
 	     'DENORM_MIN' => '6.47517511943802511092443895822764655e-4966',
 	 },
-	 );	     
+	 );
 
     my @types = (['FLT','F'], ['DBL',''], ['LDBL','L']);
     while (@types) {
diff --git a/cld b/cld
new file mode 100755
index 0000000..95196f4
--- /dev/null
+++ b/cld
@@ -0,0 +1,84 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+my $host_cc = $ENV{'HOST_CC'} || 'cc';
+my $real_linker = $ENV{'REAL_LD'} || 'ld';
+my $linker = $ENV{'SOLD'} || 'sold';
+
+my $verbose = 1;
+my $linker_options = "";
+
+my $do_link = 1;
+my $do_real_link = 1;
+
+my $out;
+
+while(@ARGV) {
+    $_ = shift @ARGV;
+
+    if ($_ eq '-no-link') {
+        $do_link = 0;
+        next;
+    }
+
+    if ($_ eq '-no-real-link') {
+        $do_real_link = 0;
+        next;
+    }
+
+    if ($_ eq '-check-verbose') {
+        $verbose = 1;
+        next;
+    }
+
+    # We need to know the output file name to compile the
+    # generated code.
+    if (/^-o(.*)/) {
+        if ($1) { # -ofoo
+            $out = $1;
+        } else { # -o foo
+        $out = shift @ARGV;
+        if (!$out) { # terminal -o
+            die("$0: argument to '-o' is missing");
+            }
+        }
+        next;
+    }
+
+    $linker_options .= ' ' . &quote_arg ($_);
+}
+
+$out = 'a.out' if !$out;
+
+if ($do_real_link) {
+    print STDERR "$real_linker $linker_options -o $out\n" if $verbose;
+    my $res = system ("$real_linker $linker_options -o $out");
+    $res >>= 8;
+    exit $res if $res;
+}
+
+if ($do_link) {
+
+    print STDERR "$linker $linker_options -o $out\n" if $verbose;
+    my $res = system ("$linker $linker_options -o $out");
+    exit 0 if $res >> 8; # Don't fail the whole build.
+
+    # compile the code generated by sold.
+    print STDERR "$host_cc -shared -fPIC $out.sparse.c -o $out.sparse.so\n" if $verbose;
+    system ("$host_cc -shared -fPIC $out.sparse.c -o $out.sparse.so");
+}
+
+exit 0;
+
+# -----------------------------------------------------------------------------
+# Simple arg-quoting function.  Just adds backslashes when needed.
+
+sub quote_arg {
+    my ($arg) = @_;
+    return "''" if $arg eq '';
+    return join ('',
+		 map {
+		     m|^[-a-zA-Z0-9._/,=]+$| ? $_ : "\\" . $_;
+		 } (split (//, $arg)));
+}
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 09/16] Add __exact_context__ ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 09/16] Add __exact_context__
Date: Thu, 18 Dec 2008 22:33:28 +0000
Message-ID: <20081218223320.23692.2908.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

We also need a statement to indicate that an exact context is
required, most notably the next patch will require it so that
it can translate attributes on variables into statements.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 ident-list.h               |    1 +
 linearize.c                |    1 +
 linearize.h                |    2 +
 parse.c                    |   20 ++++++++++++-
 parse.h                    |    1 +
 sparse.1                   |    2 +
 sparse.c                   |   14 +++++++--
 validation/context-exact.c |   67 ++++++++++++++++++++++++++++++++++++++++++++
 8 files changed, 101 insertions(+), 7 deletions(-)
 create mode 100644 validation/context-exact.c

diff --git a/ident-list.h b/ident-list.h
index 6104826..13b76d8 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -98,6 +98,7 @@ __IDENT(__PRETTY_FUNCTION___ident, "__PRETTY_FUNCTION__", 0);
 
 /* Sparse commands */
 IDENT_RESERVED(__context__);
+IDENT_RESERVED(__exact_context__);
 IDENT_RESERVED(__range__);
 
 /* Magic function names we recognize */
diff --git a/linearize.c b/linearize.c
index 526a710..111e7af 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1683,6 +1683,7 @@ static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 		value = expr->value;
 
 	insn->required = value;
+	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
 	add_one_insn(ep, insn);
diff --git a/linearize.h b/linearize.h
index 0c5e4ef..69341c2 100644
--- a/linearize.h
+++ b/linearize.h
@@ -117,7 +117,7 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false;
+			int increment, required, inc_false, exact;
 			struct expression *context_expr;
 		};
 		struct /* asm */ {
diff --git a/parse.c b/parse.c
index eb31871..5ad8c68 100644
--- a/parse.c
+++ b/parse.c
@@ -52,6 +52,7 @@ static struct token *parse_while_statement(struct token *token, struct statement
 static struct token *parse_do_statement(struct token *token, struct statement *stmt);
 static struct token *parse_goto_statement(struct token *token, struct statement *stmt);
 static struct token *parse_context_statement(struct token *token, struct statement *stmt);
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt);
 static struct token *parse_range_statement(struct token *token, struct statement *stmt);
 static struct token *parse_asm_statement(struct token *token, struct statement *stmt);
 static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
@@ -149,6 +150,10 @@ static struct symbol_op __context___op = {
 	.statement = parse_context_statement,
 };
 
+static struct symbol_op __exact_context___op = {
+	.statement = parse_exact_context_statement,
+};
+
 static struct symbol_op range_op = {
 	.statement = parse_range_statement,
 };
@@ -254,6 +259,7 @@ static struct init_keyword {
 	{ "do",		NS_KEYWORD, .op = &do_op },
 	{ "goto",	NS_KEYWORD, .op = &goto_op },
 	{ "__context__",NS_KEYWORD, .op = &__context___op },
+	{ "__exact_context__",NS_KEYWORD, .op = &__exact_context___op },
 	{ "__range__",	NS_KEYWORD, .op = &range_op },
 	{ "asm",	NS_KEYWORD, .op = &asm_op },
 	{ "__asm",	NS_KEYWORD, .op = &asm_op },
@@ -1811,7 +1817,7 @@ static struct token *parse_goto_statement(struct token *token, struct statement
 	return expect(token, ';', "at end of statement");
 }
 
-static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+static struct token *_parse_context_statement(struct token *token, struct statement *stmt, int exact)
 {
 	struct expression *args[3];
 	int argc = 0;
@@ -1836,6 +1842,8 @@ static struct token *parse_context_statement(struct token *token, struct stateme
 	stmt->expression = args[0];
 	stmt->context = NULL;
 
+	stmt->exact = exact;
+
 	switch (argc) {
 	case 0:
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
@@ -1865,6 +1873,16 @@ static struct token *parse_context_statement(struct token *token, struct stateme
 	return expect(token, ')', "at end of __context__");
 }
 
+static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 0);
+}
+
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 1);
+}
+
 static struct token *parse_range_statement(struct token *token, struct statement *stmt)
 {
 	stmt->type = STMT_RANGE;
diff --git a/parse.h b/parse.h
index a2b9aa3..ae50720 100644
--- a/parse.h
+++ b/parse.h
@@ -43,6 +43,7 @@ struct statement {
 			struct expression *expression;
 			struct expression *context;
 			struct expression *required;
+			int exact;
 		};
 		struct /* return_statement */ {
 			struct expression *ret_value;
diff --git a/sparse.1 b/sparse.1
index 92a1cae..45eea6f 100644
--- a/sparse.1
+++ b/sparse.1
@@ -90,7 +90,7 @@ To indicate that a function requires
 .BI exactly
 a certain lock context (not "at least" as above), use the form
 .BI __attribute__((exact_context( [expression ,] in_context , out_context ))
-There currently is no corresponding
+There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
diff --git a/sparse.c b/sparse.c
index 785a6f6..a26c8f2 100644
--- a/sparse.c
+++ b/sparse.c
@@ -239,7 +239,7 @@ static int handle_context(struct entrypoint *ep, struct basic_block *bb,
 			  struct context_check_list **combined)
 {
 	struct context_check *c;
-	const char *name;
+	const char *name, *cmp;
 	char *buf;
 	int val, ok;
 
@@ -256,7 +256,13 @@ static int handle_context(struct entrypoint *ep, struct basic_block *bb,
 		}
 	} END_FOR_EACH_PTR(c);
 
-	ok = insn->required <= val;
+	if (insn->exact) {
+		ok = insn->required == val;
+		cmp = "";
+	} else {
+		ok = insn->required <= val;
+		cmp = ">= ";
+	}
 
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
@@ -266,8 +272,8 @@ static int handle_context(struct entrypoint *ep, struct basic_block *bb,
 			"__context__ statement expected different context",
 			show_ident(ep->name->ident));
 
-		info(insn->pos, "%swanted >= %d, got %d",
-		     name, insn->required, val);
+		info(insn->pos, "%swanted %s%d, got %d",
+		     name, cmp, insn->required, val);
 
 		free(buf);
 		return -1;
diff --git a/validation/context-exact.c b/validation/context-exact.c
new file mode 100644
index 0000000..bacd9a1
--- /dev/null
+++ b/validation/context-exact.c
@@ -0,0 +1,67 @@
+static void a(void) __attribute__((context(TEST,0,1)))
+{
+	__context__(TEST,1);
+}
+
+static void r(void) __attribute__((context(TEST,1,0)))
+{
+	__context__(TEST,-1,1);
+}
+
+static void good_1(void)
+{
+	a();
+	r();
+}
+
+static void good_2(void)
+{
+	a();
+	r();
+	a();
+	r();
+}
+
+static void good_3(void)
+{
+	a();
+	a();
+	r();
+	r();
+}
+
+static void good_4(void)
+{
+	a();
+	a();
+	__context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void warn_1(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void good_5(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,2);
+	r();
+	r();
+}
+
+/*
+ * check-name: Check __exact_context__ statement with required context
+ *
+ * check-error-start
+context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2:    context 'TEST': wanted 1, got 2
+ * check-error-end
+ */

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] Fix cast instruction generation ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: [PATCH 1/2] Fix cast instruction generation
Date: Thu, 24 Apr 2008 21:52:12 +0000
Message-ID: <alpine.LFD.1.10.0804241443460.2779 () woody ! linux-foundation ! org>
--------------------


From: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date: Thu, 24 Apr 2008 14:45:43 -0700

Whether it's a sign-extending cast or not depends on the source
of the cast, not destination. The final size of the cast depends
on the destination, of course.

Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
---
In thread "[PATCH] RxRPC: Fix a regression in the RXKAD security module"

On Thu, 24 Apr 2008, Linus Torvalds wrote:
> 
> Ok, that looks stupid, and should even have had a warning (shifting a u16 
> right by 16 should warn about it being pointless, but doesn't, because the 
> compiler quietly expands it to "int" in the meantime).
> 
> Hmm. I could do something to sparse that warns about that too. 

Something along the lines of this?

Almost totally untested. This first patch is just preparatory to get the 
next patch working.

 linearize.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/linearize.c b/linearize.c
index 45bb168..ec48dac 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1097,10 +1097,10 @@ static pseudo_t linearize_postop(struct entrypoint *ep, struct expression *expr)
  * case, since you can't access through it anyway without another
  * cast.
  */
-static struct instruction *alloc_cast_instruction(struct symbol *ctype)
+static struct instruction *alloc_cast_instruction(struct symbol *src, struct symbol *ctype)
 {
 	int opcode = OP_CAST;
-	struct symbol *base = ctype;
+	struct symbol *base = src;
 
 	if (base->ctype.modifiers & MOD_SIGNED)
 		opcode = OP_SCAST;
@@ -1127,7 +1127,7 @@ static pseudo_t cast_pseudo(struct entrypoint *ep, pseudo_t src, struct symbol *
 		return VOID;
 	if (from->bit_size < 0 || to->bit_size < 0)
 		return VOID;
-	insn = alloc_cast_instruction(to);
+	insn = alloc_cast_instruction(from, to);
 	result = alloc_pseudo(insn);
 	insn->target = result;
 	insn->orig_type = from;
-- 
1.5.5.1.92.ga5bdc

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] Fix cast instruction generation
Date: Fri, 25 Apr 2008 02:24:42 +0000
Message-ID: <481140EA.9040803 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigAD64FE61CFD6B968AB8ED8E0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Linus Torvalds wrote:
> From: Linus Torvalds <torvalds@woody.linux-foundation.org>
> Date: Thu, 24 Apr 2008 14:45:43 -0700
>=20
> Whether it's a sign-extending cast or not depends on the source
> of the cast, not destination. The final size of the cast depends
> on the destination, of course.
>=20
> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
> ---
> In thread "[PATCH] RxRPC: Fix a regression in the RXKAD security module=
"
>=20
> On Thu, 24 Apr 2008, Linus Torvalds wrote:
>> Ok, that looks stupid, and should even have had a warning (shifting a =
u16=20
>> right by 16 should warn about it being pointless, but doesn't, because=
 the=20
>> compiler quietly expands it to "int" in the meantime).
>>
>> Hmm. I could do something to sparse that warns about that too.=20
>=20
> Something along the lines of this?

Applied and pushed.

- Josh Triplett



--------------enigAD64FE61CFD6B968AB8ED8E0
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIEUDqGJuZRtD+evsRAteZAJwMj+WzOvF2ubyeUoCqnrjnIj5HdwCgvXCq
6JWxCibyBj3sOdq0XwTxJME=
=w/tO
-----END PGP SIGNATURE-----

--------------enigAD64FE61CFD6B968AB8ED8E0--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] make sparse keep its promise about context tracking ===

From: Philipp Reisner <philipp.reisner () linbit ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Thu, 10 Apr 2008 15:24:26 +0000
Message-ID: <200804101724.27382.philipp.reisner () linbit ! com>
--------------------
Am Donnerstag, 10. April 2008 15:25:20 schrieb Johannes Berg:
> The sparse man page promises that it will check this:
>
>    Functions with the extended attribute
> 	__attribute__((context(expression,in_context,out_context))
>    require the context expression (for instance, a lock) to have the
>    value in_context (a constant nonnegative integer) when called,
>    and return with the value out_context (a constant nonnegative
>    integer).
>
> It doesn't keep that promise though, nor can it, especially with
> contexts that can be acquired recursively (like RCU in the kernel.)
>

Hi Josh,
Hi Johannes,

I just have implemented nearly the same here. Hopefully Josh will
decide for one of these patches soon.

diff --git a/expression.c b/expression.c
index 289927a..00cfb00 100644
--- a/expression.c
+++ b/expression.c
@@ -929,4 +929,76 @@ struct token *parse_expression(struct token *token, 
struct expression **tree)
 	return comma_expression(token,tree);
 }
 
+int ident_equal(struct ident *ident1, struct ident *ident2)
+{
+	return ident1->len == ident2->len &&
+		!strncmp(ident1->name, ident2->name, ident1->len);
+}
+
+int expressions_equal(struct expression *expr1, struct expression *expr2)
+{
+	if (expr1 == expr2)
+		return 1;
+
+	if (expr1 == NULL || expr2 == NULL)
+		return 0;
+
+	if (expr1->type != expr2->type)
+		return 0;
+
+	switch (expr1->type) {
+	case EXPR_SYMBOL:
+		return ident_equal(expr1->symbol_name, expr2->symbol_name);
+
+	case EXPR_VALUE:
+		return expr1->value == expr2->value;
+
+	case EXPR_FVALUE:
+		return expr1->fvalue == expr2->fvalue;
+
+	case EXPR_STRING:
+		return expr1->string->length == expr2->string->length &&
+			!strncmp(expr1->string->data, expr2->string->data, expr1->string->length);
+
+	case EXPR_BINOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_COMMA:
+	case EXPR_ASSIGNMENT:
+		return expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_DEREF:
+		return expressions_equal(expr1->deref, expr2->deref) &&
+			ident_equal(expr1->member, expr2->member);
+
+	case EXPR_PREOP:
+	case EXPR_POSTOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->unop, expr2->unop);
+
+	/* Not needed right now, but for sake of completness ...
+	case EXPR_LABEL:
+	case EXPR_STATEMENT:
+	case EXPR_CALL:
+	case EXPR_LOGICAL:
+	case EXPR_COMPARE:
+	case EXPR_SELECT:
+	case EXPR_CONDITIONAL:
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+	case EXPR_SLICE:
+	case EXPR_INITIALIZER:
+	case EXPR_POS:
+	*/
+
+	default:
+		printf("Missing code in expressions_equal for %d\n", expr1->type);
+	}
+
+	return 0;
+}
 
diff --git a/expression.h b/expression.h
index 5136b9b..e89ddb7 100644
--- a/expression.h
+++ b/expression.h
@@ -216,4 +216,5 @@ struct token *compound_statement(struct token *, struct 
statement *);
 void cast_value(struct expression *expr, struct symbol *newtype,
 	struct expression *old, struct symbol *oldtype);
 
+extern int expressions_equal(struct expression *expr1, struct expression 
*expr2);
 #endif
diff --git a/linearize.c b/linearize.c
index 8a68f05..5aae3d6 100644
--- a/linearize.c
+++ b/linearize.c
@@ -67,6 +67,7 @@ static struct basic_block *alloc_basic_block(struct 
entrypoint *ep, struct posit
 {
 	struct basic_block *bb = __alloc_basic_block(0);
 	bb->context = -1;
+	bb->context_expr = NULL;
 	bb->pos = pos;
 	bb->ep = ep;
 	return bb;
diff --git a/linearize.h b/linearize.h
index 7b2961b..a71f9aa 100644
--- a/linearize.h
+++ b/linearize.h
@@ -225,6 +225,7 @@ struct basic_block {
 	struct position pos;
 	unsigned long generation;
 	int context;
+	struct expression *context_expr;
 	struct entrypoint *ep;
 	struct basic_block_list *parents; /* sources */
 	struct basic_block_list *children; /* destinations */
diff --git a/sparse.c b/sparse.c
index 4026ba7..50c5e51 100644
--- a/sparse.c
+++ b/sparse.c
@@ -24,7 +24,110 @@
 #include "expression.h"
 #include "linearize.h"
 
-static int context_increase(struct basic_block *bb, int entry)
+
+int ident_str(struct ident *ident, char *buffer, int length)
+{
+	return snprintf(buffer, length, "%.*s", ident->len, ident->name);
+}
+
+
+int expression_str(struct expression *expr, char *buffer, int length)
+{
+	int n;
+
+	if (!expr) {
+		buffer[0] = 0;
+		return 0;
+	}
+
+	/* TODO, think about necessary braces () */
+
+	switch (expr->type) {
+	case EXPR_SYMBOL:
+		return ident_str(expr->symbol_name, buffer, length);
+
+	case EXPR_VALUE:
+		return snprintf(buffer, length, "%llu", expr->value);
+
+	case EXPR_FVALUE:
+		return snprintf(buffer, length, "%Lf", expr->fvalue);
+
+	case EXPR_STRING:
+		return snprintf(buffer, length, "%.*s", expr->string->length, 
expr->string->data);
+
+	case EXPR_BINOP:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_COMMA:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, ",");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_ASSIGNMENT:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "=");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_DEREF:
+		if (expr->left->type == EXPR_PREOP &&
+		    expr->left->op == '*') {
+			n  = expression_str(expr->left->unop, buffer, length);
+			n += snprintf(buffer+n, length-n, "->");
+			n += ident_str(expr->member, buffer+n, length-n);
+		} else {
+			n  = expression_str(expr->left, buffer, length);
+			n += snprintf(buffer+n, length-n, ".");
+			n += ident_str(expr->member, buffer+n, length-n);
+		}
+		return n;
+
+	case EXPR_PREOP:
+		n  = snprintf(buffer, length, "%c", expr->op);
+		n += expression_str(expr->unop, buffer+n, length-n);
+		return n;
+
+	case EXPR_POSTOP:
+		n  = expression_str(expr->unop, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		return n;
+
+	/* Not needed right now, but for sake of completness ...
+	case EXPR_LABEL:
+	case EXPR_STATEMENT:
+	case EXPR_CALL:
+	case EXPR_LOGICAL:
+	case EXPR_COMPARE:
+	case EXPR_SELECT:
+	case EXPR_CONDITIONAL:
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+	case EXPR_SLICE:
+	case EXPR_INITIALIZER:
+	case EXPR_POS:
+	*/
+
+	default:
+		printf("Missing code in expression_str for %d\n", expr->type);
+	}
+
+	return 0;
+}
+
+char *expression_sstr(struct expression *expr)
+{
+	static char expr_string[37] = " for ";
+	static char empty[] = "";
+
+	return expression_str(expr, expr_string+5, 32) ? expr_string : empty;
+}
+
+static int context_increase(struct basic_block *bb, struct expression *expr, 
int entry)
 {
 	int sum = 0;
 	struct instruction *insn;
@@ -33,6 +136,8 @@ static int context_increase(struct basic_block *bb, int 
entry)
 		int val;
 		if (insn->opcode != OP_CONTEXT)
 			continue;
+		if (!expressions_equal(expr, insn->context_expr))
+			continue;
 		val = insn->increment;
 		if (insn->check) {
 			int current = sum + entry;
@@ -49,18 +154,19 @@ static int context_increase(struct basic_block *bb, int 
entry)
 	return sum;
 }
 
-static int imbalance(struct entrypoint *ep, struct basic_block *bb, int 
entry, int exit, const char *why)
+static int imbalance(struct basic_block *bb, struct expression *expr, int 
entry, int exit, const char *why)
 {
 	if (Wcontext) {
-		struct symbol *sym = ep->name;
-		warning(bb->pos, "context imbalance in '%s' - %s", show_ident(sym->ident), 
why);
+		struct symbol *sym = bb->ep->name;
+		warning(bb->pos, "context imbalance in '%s' - %s%s", 
show_ident(sym->ident), why,
+			expression_sstr(expr));
 	}
 	return -1;
 }
 
-static int check_bb_context(struct entrypoint *ep, struct basic_block *bb, 
int entry, int exit);
+static int check_bb_context(struct basic_block *bb, struct expression *expr, 
int entry, int exit);
 
-static int check_children(struct entrypoint *ep, struct basic_block *bb, int 
entry, int exit)
+static int check_children(struct basic_block *bb, struct expression *expr, 
int entry, int exit)
 {
 	struct instruction *insn;
 	struct basic_block *child;
@@ -69,32 +175,36 @@ static int check_children(struct entrypoint *ep, struct 
basic_block *bb, int ent
 	if (!insn)
 		return 0;
 	if (insn->opcode == OP_RET)
-		return entry != exit ? imbalance(ep, bb, entry, exit, "wrong count at 
exit") : 0;
+		return entry != exit ? imbalance(bb, expr, entry, exit, "wrong count at 
exit") : 0;
 
 	FOR_EACH_PTR(bb->children, child) {
-		if (check_bb_context(ep, child, entry, exit))
+		if (check_bb_context(child, expr, entry, exit))
 			return -1;
 	} END_FOR_EACH_PTR(child);
 	return 0;
 }
 
-static int check_bb_context(struct entrypoint *ep, struct basic_block *bb, 
int entry, int exit)
+static int check_bb_context(struct basic_block *bb, struct expression *expr, 
int entry, int exit)
 {
+	int eq;
+
 	if (!bb)
 		return 0;
-	if (bb->context == entry)
+	eq = expressions_equal(expr, bb->context_expr);
+	if (eq && bb->context == entry)
 		return 0;
 
 	/* Now that's not good.. */
-	if (bb->context >= 0)
-		return imbalance(ep, bb, entry, bb->context, "different lock contexts for 
basic block");
+	if (eq && bb->context >= 0)
+		return imbalance(bb, expr, entry, bb->context, "different lock contexts for 
basic block");
 
 	bb->context = entry;
-	entry += context_increase(bb, entry);
+	bb->context_expr = expr;
+	entry += context_increase(bb, expr, entry);
 	if (entry < 0)
-		return imbalance(ep, bb, entry, exit, "unexpected unlock");
+		return imbalance(bb, expr, entry, exit, "unexpected unlock");
 
-	return check_children(ep, bb, entry, exit);
+	return check_children(bb, expr, entry, exit);
 }
 
 static void check_cast_instruction(struct instruction *insn)
@@ -195,7 +305,31 @@ static void check_call_instruction(struct instruction 
*insn)
 	}
 }
 
-static void check_one_instruction(struct instruction *insn)
+static void add_expression_once(struct expression_list **expr_list, struct 
expression* expr)
+{
+	struct expression *e;
+
+	FOR_EACH_PTR(*expr_list, e) {
+		if (expressions_equal(e, expr))
+			return;
+	} END_FOR_EACH_PTR(e);
+
+	add_expression(expr_list, expr);
+}
+
+static void remove_expression(struct expression_list **expr_list, struct 
expression* expr)
+{
+	struct expression *e;
+
+	FOR_EACH_PTR(*expr_list, e) {
+		if (expressions_equal(e, expr)) {
+			DELETE_CURRENT_PTR(e);
+			return;
+		}
+	} END_FOR_EACH_PTR(e);
+}
+
+static void check_one_instruction(struct instruction *insn, struct 
expression_list **expr_list)
 {
 	switch (insn->opcode) {
 	case OP_CAST: case OP_SCAST:
@@ -208,26 +342,29 @@ static void check_one_instruction(struct instruction 
*insn)
 	case OP_CALL:
 		check_call_instruction(insn);
 		break;
+	case OP_CONTEXT:
+		add_expression_once(expr_list, insn->context_expr);
+		break;
 	default:
 		break;
 	}
 }
 
-static void check_bb_instructions(struct basic_block *bb)
+static void check_bb_instructions(struct basic_block *bb, struct 
expression_list **expr_list)
 {
 	struct instruction *insn;
 	FOR_EACH_PTR(bb->insns, insn) {
 		if (!insn->bb)
 			continue;
-		check_one_instruction(insn);
+		check_one_instruction(insn, expr_list);
 	} END_FOR_EACH_PTR(insn);
 }
 
-static void check_instructions(struct entrypoint *ep)
+static void check_instructions(struct entrypoint *ep, struct expression_list 
**expr_list)
 {
 	struct basic_block *bb;
 	FOR_EACH_PTR(ep->bbs, bb) {
-		check_bb_instructions(bb);
+		check_bb_instructions(bb, expr_list);
 	} END_FOR_EACH_PTR(bb);
 }
 
@@ -235,7 +372,8 @@ static void check_context(struct entrypoint *ep)
 {
 	struct symbol *sym = ep->name;
 	struct context *context;
-	unsigned int in_context = 0, out_context = 0;
+	struct expression_list *expr_list = NULL;
+	struct expression *expr;
 
 	if (Wuninitialized && verbose && ep->entry->bb->needs) {
 		pseudo_t pseudo;
@@ -246,13 +384,16 @@ static void check_context(struct entrypoint *ep)
 		} END_FOR_EACH_PTR(pseudo);
 	}
 
-	check_instructions(ep);
+	check_instructions(ep, &expr_list);
 
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
-		in_context += context->in;
-		out_context += context->out;
+		remove_expression(&expr_list, context->context);
+		check_bb_context(ep->entry->bb, context->context, context->in, 
context->out);
 	} END_FOR_EACH_PTR(context);
-	check_bb_context(ep, ep->entry->bb, in_context, out_context);
+
+	FOR_EACH_PTR(expr_list, expr) {
+		check_bb_context(ep->entry->bb, expr, 0, 0);
+	} END_FOR_EACH_PTR(expr);
 }
 
 static void check_symbols(struct symbol_list *list)
diff --git a/validation/named_context.c b/validation/named_context.c
new file mode 100644
index 0000000..9b6d77f
--- /dev/null
+++ b/validation/named_context.c
@@ -0,0 +1,32 @@
+#ifdef __CHECKER__
+# define __acquires(x)	__attribute__((context(x,0,1)))
+# define __releases(x)	__attribute__((context(x,1,0)))
+# define __acquire(x)	__context__(x,1)
+# define __release(x)	__context__(x,-1)
+#else
+# define __acquires(x)
+# define __releases(x)
+# define __acquire(x) (void)0
+# define __release(x) (void)0
+#endif
+
+static void invalid1(void)
+{
+	__acquire(lock1);
+	__release(lock2);
+}
+
+static void global_lock(void) __acquires(lock1) __acquires(lock2)
+{
+	__acquire(lock1);
+	__acquire(lock2);
+}
+
+/*
+ * check-name: Check -Wcontext
+ *
+ * check-error-start
+named_context.c:13:13: warning: context imbalance in 'invalid1' - wrong count 
at exit for lock1
+named_context.c:13:13: warning: context imbalance in 'invalid1' - unexpected 
unlock for lock2
+ * check-error-end
+ */


-- 
: Dipl-Ing Philipp Reisner                      Tel +43-1-8178292-50 :
: LINBIT Information Technologies GmbH          Fax +43-1-8178292-82 :
: Vivenotgasse 48, 1120 Vienna, Austria        http://www.linbit.com :
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Thu, 10 Apr 2008 15:30:54 +0000
Message-ID: <1207841454.13354.7.camel () johannes ! berg>
--------------------

--=-3hoGFoNupxSlZvjvncG4
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable

=EF=BB=BFHi Philip,

> I just have implemented nearly the same here. Hopefully Josh will
> decide for one of these patches soon.


> +int ident_equal(struct ident *ident1, struct ident *ident2)

> +int expressions_equal(struct expression *expr1, struct expression *expr2=
)

That code looks pretty nice, I guess I should look at getting that into
my version instead of just printing the identifier to a string.

As far as I can see your version doesn't actually implement
__attribute__((context(x,1,1))) as the man-page envisioned it for
checking that a function is run under the lock context it wants, which
was one of the more important goals to me. Doing separate locks sort of
fell out.

johannes

--=-3hoGFoNupxSlZvjvncG4
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/4yraVg1VMiehFYAQI+4Q/+IRMy7JCpFtyQODMKRwIQAObO4qaQ9UMA
yBSHASNcK4htlN6+qzV4M6tP2HEigdaIeK99U82M3CLb3n84yWfwxG9Y44mEj8YM
eOZirO+bPoo/+YrWw/3kttKiiTWQJ6KuOjpnQ0uzX149f/btKAc6c92F+S5Qvx1P
TIWpxPTQei/j0uKAG3e2/UOw5YB2o+tGH83lgZl86Z5EwD0l4PD9upmadLBKI/Fl
MBq0st+UO6VsJu/uEvb91sfZuc+Fdyh8kpdfUQkiCRlZT29AzL7G/hQqlbXq6WaR
v5woFwT72xkQvvbCnX3qsmSs5XVAMrxu6A79e/KWbnNbJC+zkdT08BmMR5r0Knad
TSrb4rdb/Ys3wEeHTpk9z7U7K6rjnt04q4Ruq9P+z/qpwdaRjzGJvQr9SxvnWpos
PlcPToUYhC4LAB2Q8I/goJP2NYK+Hjnt1NwHQ8T3QtCz083ZuLVsTusreSYih8+1
1k4pBJCCsFTLhV/tDgRILif4XJ0rufGc14Lp763xOdD8ovrwbAIW3Cy/WL0WJvGm
w5EKVwHmZ+7NIaDgoftZt/KpDqeC8OAwJXXuKMTdX+rUgHCgp+N+VltFKAA7hfEr
PaszuGlTi0+Qq02R4UfJNdT8h6e0QKMuGHlls7hfIegyDHle+foU8vgPvnN1d/2P
GBsjBOFjh+w=
=JQRb
-----END PGP SIGNATURE-----

--=-3hoGFoNupxSlZvjvncG4--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Philipp Reisner <philipp.reisner () linbit ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Thu, 10 Apr 2008 15:46:13 +0000
Message-ID: <200804101746.14457.philipp.reisner () linbit ! com>
--------------------
Am Donnerstag, 10. April 2008 17:30:54 schrieb Johannes Berg:
> Hi Philip,
>
> > I just have implemented nearly the same here. Hopefully Josh will
> > decide for one of these patches soon.
> >
> >
> > +int ident_equal(struct ident *ident1, struct ident *ident2)
> >
> > +int expressions_equal(struct expression *expr1, struct expression
> > *expr2)
>
> That code looks pretty nice, I guess I should look at getting that into
> my version instead of just printing the identifier to a string.
>
> As far as I can see your version doesn't actually implement
> __attribute__((context(x,1,1))) as the man-page envisioned it for
> checking that a function is run under the lock context it wants, which
> was one of the more important goals to me. Doing separate locks sort of
> fell out.
>

Hi Johannes,

I also worked on that part, although I have to admitt that I did not
got that part of the manpage. Instead I invented the require_context
attribute.

Here is the second patch. It applies on top of the first one...

I hope that we get the good ideas of our two works combined and
accepted into sparse...

-Phil

diff --git a/allocate.c b/allocate.c
index 5cc52a9..198297b 100644
--- a/allocate.c
+++ b/allocate.c
@@ -114,6 +114,7 @@ void show_allocations(struct allocator_struct *x)
 ALLOCATOR(ident, "identifiers");
 ALLOCATOR(token, "tokens");
 ALLOCATOR(context, "contexts");
+ALLOCATOR(context_requirement, "context requirements");
 ALLOCATOR(symbol, "symbols");
 ALLOCATOR(expression, "expressions");
 ALLOCATOR(statement, "statements");
diff --git a/allocate.h b/allocate.h
index 9f1dc8c..8fa3efd 100644
--- a/allocate.h
+++ b/allocate.h
@@ -65,6 +65,7 @@ extern void show_allocations(struct allocator_struct *);
 DECLARE_ALLOCATOR(ident);
 DECLARE_ALLOCATOR(token);
 DECLARE_ALLOCATOR(context);
+DECLARE_ALLOCATOR(context_requirement);
 DECLARE_ALLOCATOR(symbol);
 DECLARE_ALLOCATOR(expression);
 DECLARE_ALLOCATOR(statement);
diff --git a/linearize.c b/linearize.c
index 5aae3d6..e47f862 100644
--- a/linearize.c
+++ b/linearize.c
@@ -240,6 +240,7 @@ static const char *opcodes[] = {
 
 	/* Sparse tagging (line numbers, context, whatever) */
 	[OP_CONTEXT] = "context",
+	[OP_CONTEXT_REQ] = "context req",
 	[OP_RANGE] = "range-check",
 
 	[OP_COPY] = "copy",
@@ -442,6 +443,9 @@ const char *show_instruction(struct instruction *insn)
 	case OP_CONTEXT:
 		buf += sprintf(buf, "%s%d", insn->check ? "check: " : "", insn->increment);
 		break;
+	case OP_CONTEXT_REQ:
+		buf += sprintf(buf, "%d to %d, type %d", insn->ctx_req->min, insn->ctx_req->max, insn->access_type);
+		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
 		break;
@@ -839,6 +843,7 @@ struct access_data {
 	unsigned int offset, alignment;	// byte offset
 	unsigned int bit_size, bit_offset; // which bits
 	struct position pos;
+	struct ctx_req_list *ctx_reqs;    // required contexts
 };
 
 static void finish_address_gen(struct entrypoint *ep, struct access_data *ad)
@@ -887,6 +892,8 @@ static int linearize_address_gen(struct entrypoint *ep,
 
 	if (!ctype)
 		return 0;
+
+	ad->ctx_reqs = ctype->ctype.ctx_reqs;
 	ad->pos = expr->pos;
 	ad->result_type = ctype;
 	ad->source_type = base_type(ctype);
@@ -938,6 +945,7 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 		struct access_data *ad)
 {
 	pseudo_t store = value;
+	struct context_requirement *ctx_req;
 
 	if (type_size(ad->source_type) != type_size(ad->result_type)) {
 		pseudo_t orig = add_load(ep, ad);
@@ -951,6 +959,19 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 		orig = add_binary_op(ep, ad->source_type, OP_AND, orig, value_pseudo(~mask));
 		store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
 	}
+	if (ad->ctx_reqs) {
+		struct instruction *insn;
+		FOR_EACH_PTR(ad->ctx_reqs, ctx_req) {
+			if (ctx_req->access_type == WRITE ||
+			    ctx_req->access_type == RDWR) {
+				insn = alloc_instruction(OP_CONTEXT_REQ, 0);
+				insn->ctx_req = ctx_req;
+				insn->access_type = WRITE;
+				add_one_insn(ep, insn);
+			}
+		} END_FOR_EACH_PTR(ctx_req);
+
+	}
 	add_store(ep, ad, store);
 	return value;
 }
@@ -989,14 +1010,30 @@ static pseudo_t add_symbol_address(struct entrypoint *ep, struct symbol *sym)
 
 static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad)
 {
-	pseudo_t new = add_load(ep, ad);
+	pseudo_t new;
+	struct context_requirement *ctx_req;
+
+	if (ad->ctx_reqs) {
+		struct instruction *insn;
+		FOR_EACH_PTR(ad->ctx_reqs, ctx_req) {
+			if (ctx_req->access_type == READ ||
+			    ctx_req->access_type == RDWR) {
+				insn = alloc_instruction(OP_CONTEXT_REQ, 0);
+				insn->ctx_req = ctx_req;
+				insn->access_type = READ;
+				add_one_insn(ep, insn);
+			}
+		} END_FOR_EACH_PTR(ctx_req);
+
+	}
+	new = add_load(ep, ad);
 
 	if (ad->bit_offset) {
 		pseudo_t shift = value_pseudo(ad->bit_offset);
 		pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
 		new = newval;
 	}
-		
+
 	return new;
 }
 
@@ -1195,6 +1232,7 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 	pseudo_t retval, call;
 	struct ctype *ctype = NULL;
 	struct context *context;
+	struct context_requirement *ctx_req;
 
 	if (!expr->ctype) {
 		warning(expr->pos, "call with no type!");
@@ -1211,6 +1249,17 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 	if (fn->ctype)
 		ctype = &fn->ctype->ctype;
 
+	if (ctype) {
+		FOR_EACH_PTR(ctype->ctx_reqs, ctx_req) {
+			struct instruction *cinsn;
+
+			cinsn = alloc_instruction(OP_CONTEXT_REQ, 0);
+			cinsn->ctx_req = ctx_req;
+			cinsn->access_type = CALL;
+			add_one_insn(ep, cinsn);
+		} END_FOR_EACH_PTR(ctx_req);
+	}
+
 	if (fn->type == EXPR_PREOP) {
 		if (fn->unop->type == EXPR_SYMBOL) {
 			struct symbol *sym = fn->unop->symbol;
@@ -1236,6 +1285,7 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 			int out = context->out;
 			int check = 0;
 			int context_diff;
+
 			if (in < 0) {
 				check = 1;
 				in = 0;
diff --git a/linearize.h b/linearize.h
index a71f9aa..8901a82 100644
--- a/linearize.h
+++ b/linearize.h
@@ -124,6 +124,11 @@ struct instruction {
 			const char *string;
 			struct asm_rules *asm_rules;
 		};
+		struct /* context_req */ {
+			int access_type;
+			struct context_requirement* ctx_req;
+		};
+
 	};
 };
 
@@ -212,6 +217,7 @@ enum opcode {
 
 	/* Sparse tagging (line numbers, context, whatever) */
 	OP_CONTEXT,
+	OP_CONTEXT_REQ,
 	OP_RANGE,
 
 	/* Needed to translate SSA back to normal form */
diff --git a/parse.c b/parse.c
index 6255737..6a8e1ac 100644
--- a/parse.c
+++ b/parse.c
@@ -66,6 +66,7 @@ static struct token *attribute_address_space(struct token *token, struct symbol
 static struct token *attribute_aligned(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_mode(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype);
+static struct token *attribute_require_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
 
@@ -184,6 +185,10 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
+static struct symbol_op require_context_op = {
+	.attribute = attribute_require_context,
+};
+
 static struct symbol_op transparent_union_op = {
 	.attribute = attribute_transparent_union,
 };
@@ -265,6 +270,7 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
+	{ "require_context",	NS_KEYWORD,	.op = &require_context_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
@@ -907,6 +913,72 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 	return token;
 }
 
+static int token_to_accesstype(struct token *token)
+{
+	static const char *at_text[] = {
+		[READ]  = "\"read\"",
+		[WRITE] = "\"write\"",
+		[RDWR]  = "\"rdwr\"",
+		[CALL]  = "\"call\""
+	};
+	const char *ats;
+	int i;
+
+	if (token_type(token) != TOKEN_STRING)
+		goto err;
+
+	ats = show_token(token);
+	for (i = 0; i < sizeof at_text/sizeof at_text[0]; i++) {
+		if (!strcmp(ats,at_text[i]))
+			return i;
+	}
+
+err:
+	sparse_error(token->pos, "Expected \"read\", \"write\", \"rdwr\" or \"call\""
+		     " as 4th argument of require_context");
+
+	return RDWR;
+}
+
+static struct token *attribute_require_context(struct token *token, struct symbol *attr, struct ctype *ctype)
+{
+	struct context_requirement *ctx_req = alloc_context_requirement();
+	struct expression *args[3];
+	int argc = 0;
+
+	token = expect(token, '(', "after require_context attribute");
+	while (!match_op(token, ')')) {
+		struct expression *expr = NULL;
+		if (argc < 3) {
+			token = conditional_expression(token, &expr);
+			if (!expr)
+				break;
+		} else {
+			ctx_req->access_type = token_to_accesstype(token);
+			token = token->next;
+			argc++;
+		}
+
+		if (argc < 3)
+			args[argc++] = expr;
+		if (!match_op(token, ','))
+			break;
+		token = token->next;
+	}
+
+	if (argc == 4) {
+		ctx_req->context = args[0];
+		ctx_req->min = get_expression_value(args[1]);
+		ctx_req->max = get_expression_value(args[2]);
+		add_ptr_list(&ctype->ctx_reqs, ctx_req);
+	} else
+		sparse_error(token->pos, "expected context name, min, max and type values");
+
+	token = expect(token, ')', "after context attribute");
+	return token;
+}
+
+
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	if (Wtransparent_union)
@@ -1039,6 +1111,8 @@ static void apply_ctype(struct position pos, struct ctype *thistype, struct ctyp
 	/* Context */
 	concat_ptr_list((struct ptr_list *)thistype->contexts,
 	                (struct ptr_list **)&ctype->contexts);
+	concat_ptr_list((struct ptr_list *)thistype->ctx_reqs,
+	                (struct ptr_list **)&ctype->ctx_reqs);
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
@@ -1246,6 +1320,8 @@ static struct token *pointer(struct token *token, struct ctype *ctype)
 		ptr->ctype.as = ctype->as;
 		concat_ptr_list((struct ptr_list *)ctype->contexts,
 				(struct ptr_list **)&ptr->ctype.contexts);
+		concat_ptr_list((struct ptr_list *)ctype->ctx_reqs,
+				(struct ptr_list **)&ptr->ctype.ctx_reqs);
 		ptr->ctype.base_type = base_type;
 
 		base_type = ptr;
@@ -1253,6 +1329,7 @@ static struct token *pointer(struct token *token, struct ctype *ctype)
 		ctype->base_type = base_type;
 		ctype->as = 0;
 		free_ptr_list(&ctype->contexts);
+		free_ptr_list(&ctype->ctx_reqs);
 
 		token = declaration_specifiers(token->next, ctype, 1);
 		modifiers = ctype->modifiers;
diff --git a/sparse.c b/sparse.c
index 50c5e51..45a1394 100644
--- a/sparse.c
+++ b/sparse.c
@@ -24,13 +24,11 @@
 #include "expression.h"
 #include "linearize.h"
 
-
 int ident_str(struct ident *ident, char *buffer, int length)
 {
 	return snprintf(buffer, length, "%.*s", ident->len, ident->name);
 }
 
-
 int expression_str(struct expression *expr, char *buffer, int length)
 {
 	int n;
@@ -127,6 +125,22 @@ char *expression_sstr(struct expression *expr)
 	return expression_str(expr, expr_string+5, 32) ? expr_string : empty;
 }
 
+static void out_of_context_access(struct basic_block *bb, struct expression *expr,
+				  struct instruction *insn, const char *why)
+{
+	static const char *at_text[] = {
+		[READ] =  "read access",
+		[WRITE] = "write access",
+		[CALL]  = "call"
+	};
+
+	if (Wcontext) {
+		warning(insn->pos, "out of context %s in '%s' - context too %s%s",
+			at_text[insn->access_type], show_ident(bb->ep->name->ident), why,
+			expression_sstr(expr));
+	}
+}
+
 static int context_increase(struct basic_block *bb, struct expression *expr, int entry)
 {
 	int sum = 0;
@@ -134,22 +148,33 @@ static int context_increase(struct basic_block *bb, struct expression *expr, int
 
 	FOR_EACH_PTR(bb->insns, insn) {
 		int val;
-		if (insn->opcode != OP_CONTEXT)
-			continue;
-		if (!expressions_equal(expr, insn->context_expr))
-			continue;
-		val = insn->increment;
-		if (insn->check) {
-			int current = sum + entry;
-			if (!val) {
-				if (!current)
+
+		switch (insn->opcode) {
+		case OP_CONTEXT:
+			if (!expressions_equal(expr, insn->context_expr))
+				continue;
+			val = insn->increment;
+			if (insn->check) {
+				int current = sum + entry;
+				if (!val) {
+					if (!current)
+						continue;
+				} else if (current >= val)
 					continue;
-			} else if (current >= val)
+				warning(insn->pos, "context check failure");
 				continue;
-			warning(insn->pos, "context check failure");
-			continue;
+			}
+			sum += val;
+			break;
+		case OP_CONTEXT_REQ:
+			if (!expressions_equal(expr, insn->ctx_req->context))
+				continue;
+			if (sum+entry < insn->ctx_req->min)
+				out_of_context_access(bb, expr, insn, "small");
+			if (sum+entry > insn->ctx_req->max)
+				out_of_context_access(bb, expr, insn, "high");
+			break;
 		}
-		sum += val;
 	} END_FOR_EACH_PTR(insn);
 	return sum;
 }
@@ -345,6 +370,8 @@ static void check_one_instruction(struct instruction *insn, struct expression_li
 	case OP_CONTEXT:
 		add_expression_once(expr_list, insn->context_expr);
 		break;
+	case OP_CONTEXT_REQ:
+		add_expression_once(expr_list, insn->ctx_req->context);
 	default:
 		break;
 	}
diff --git a/symbol.c b/symbol.c
index 7539817..4564843 100644
--- a/symbol.c
+++ b/symbol.c
@@ -57,6 +57,11 @@ struct context *alloc_context(void)
 	return __alloc_context(0);
 }
 
+struct context_requirement *alloc_context_requirement(void)
+{
+	return __alloc_context_requirement(0);
+}
+
 struct symbol *alloc_symbol(struct position pos, int type)
 {
 	struct symbol *sym = __alloc_symbol(0);
@@ -201,6 +206,8 @@ static struct symbol *examine_base_type(struct symbol *sym)
 	sym->ctype.modifiers |= base_type->ctype.modifiers & MOD_PTRINHERIT;
 	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
 			(struct ptr_list **)&sym->ctype.contexts);
+	concat_ptr_list((struct ptr_list *)base_type->ctype.ctx_reqs,
+			(struct ptr_list **)&sym->ctype.ctx_reqs);
 	if (base_type->type == SYM_NODE) {
 		base_type = base_type->ctype.base_type;
 		sym->ctype.base_type = base_type;
@@ -257,6 +264,8 @@ void merge_type(struct symbol *sym, struct symbol *base_type)
 	sym->ctype.modifiers |= (base_type->ctype.modifiers & ~MOD_STORAGE);
 	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
 	                (struct ptr_list **)&sym->ctype.contexts);
+	concat_ptr_list((struct ptr_list *)base_type->ctype.ctx_reqs,
+			(struct ptr_list **)&sym->ctype.ctx_reqs);
 	sym->ctype.base_type = base_type->ctype.base_type;
 	if (sym->ctype.base_type->type == SYM_NODE)
 		merge_type(sym, sym->ctype.base_type);
diff --git a/symbol.h b/symbol.h
index 4362f9a..cdb2452 100644
--- a/symbol.h
+++ b/symbol.h
@@ -74,14 +74,23 @@ struct context {
 	unsigned int in, out;
 };
 
+struct context_requirement {
+	struct expression *context;
+	unsigned int min, max;
+	enum { READ, WRITE, RDWR, CALL } access_type;
+};
+
 extern struct context *alloc_context(void);
+extern struct context_requirement *alloc_context_requirement(void);
 
 DECLARE_PTR_LIST(context_list, struct context);
+DECLARE_PTR_LIST(ctx_req_list, struct context_requirement);
 
 struct ctype {
 	unsigned long modifiers;
 	unsigned long alignment;
 	struct context_list *contexts;
+	struct ctx_req_list *ctx_reqs;
 	unsigned int as;
 	struct symbol *base_type;
 };
diff --git a/validation/context_requirement.c b/validation/context_requirement.c
new file mode 100644
index 0000000..24fe598
--- /dev/null
+++ b/validation/context_requirement.c
@@ -0,0 +1,185 @@
+#ifdef __CHECKER__
+# define __acquires(x)	__attribute__((context(x,0,1)))
+# define __releases(x)	__attribute__((context(x,1,0)))
+# define __acquire(x)	__context__(x,1)
+# define __release(x)	__context__(x,-1)
+# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
+# define __protected_by(x)       __attribute__((require_context(x,1,1,"rdwr")))
+# define __protected_read_by(x)  __attribute__((require_context(x,1,1,"read")))
+# define __protected_write_by(x) __attribute__((require_context(x,1,1,"write")))
+# define __must_hold(x)       __attribute__((context(x,1,1), require_context(x,1,1,"call")))
+#else
+# define __acquires(x)
+# define __releases(x)
+# define __acquire(x) (void)0
+# define __release(x) (void)0
+# define __cond_lock(x,c) (c)
+# define __protected_by(x)
+# define __protected_read_by(x)
+# define __protected_write_by(x)
+# define __must_hold(x)
+#endif
+
+
+#include <stdio.h>
+#include <stdlib.h>
+
+static int to_protect __protected_by(local);
+
+static int local_cnt=0;
+
+static void inc_local(void) __acquires(local)
+{
+	__acquire(local);
+	local_cnt++;
+}
+
+
+#define try_inc_local() __cond_lock(local, _try_inc_local())
+static int _try_inc_local(void)
+{
+	if (random() > RAND_MAX/2) {
+		local_cnt++;
+		return 1;
+	}
+	return 0;
+}
+
+#define dec_local(void) do { __release(local); _dec_local(); } while(0)
+static void _dec_local(void)
+{
+	local_cnt--;
+}
+
+static int valid1(void)
+{
+	inc_local();
+	to_protect = 1;
+	dec_local();
+}
+
+static int valid2(void)
+{
+	inc_local();
+	inc_local();
+	dec_local();
+	dec_local();
+}
+
+static int valid3(void)
+{
+	if (try_inc_local()) {
+		dec_local();
+	}
+}
+
+static int valid4(void)
+{
+	if ((random() > RAND_MAX/2) && try_inc_local()) {
+		dec_local();
+	}
+}
+
+static int helper(void) __must_hold(local)
+{
+	to_protect = 1;
+}
+
+static int valid5(void)
+{
+	inc_local();
+	helper();
+	dec_local();
+}
+
+static int invalid0(void) __releases(local)
+{
+	if (random() > RAND_MAX/2)
+		dec_local();
+}
+
+static int invalid1(void)
+{
+	inc_local();
+}
+
+static int invalid2(void)
+{
+	dec_local();
+}
+
+static int invalid3(void)
+{
+	if (try_inc_local()) {
+	}
+	dec_local();
+}
+
+static int invalid4(void)
+{
+	while (random() > RAND_MAX/2)
+		inc_local();
+
+	dec_local();
+}
+
+static int invalid5(void)
+{
+	try_inc_local();
+	dec_local();
+}
+
+static int invalid6(void)
+{
+	to_protect = 1;
+	inc_local();
+	dec_local();
+}
+
+static int invalid7(void)
+{
+	inc_local();
+	dec_local();
+	to_protect = 1;
+}
+
+static int invalid8(void)
+{
+	inc_local();
+	inc_local();
+	to_protect = 2;
+	dec_local();
+	dec_local();
+}
+
+static int invalid9(void)
+{
+	int lv;
+
+	lv = to_protect;
+	inc_local();
+	dec_local();
+}
+
+static int invalid10(void)
+{
+	helper();
+}
+
+/*
+ * check-name: Check -Wcontext
+ *
+ * check-error-start
+context_requirement.c:97:2: warning: context imbalance in 'invalid0' - different lock contexts for basic block
+context_requirement.c:101:12: warning: context imbalance in 'invalid1' - wrong count at exit
+context_requirement.c:106:12: warning: context imbalance in 'invalid2' - unexpected unlock
+context_requirement.c:113:6: warning: context imbalance in 'invalid3' - different lock contexts for basic block
+context_requirement.c:120:2: warning: context imbalance in 'invalid4' - different lock contexts for basic block
+context_requirement.c:129:2: warning: context imbalance in 'invalid5' - different lock contexts for basic block
+context_requirement.c:134:15: warning: out of context write access in 'invalid6' - context too small
+context_requirement.c:143:15: warning: out of context write access in 'invalid7' - context too small
+context_requirement.c:150:15: warning: out of context write access in 'invalid8' - context too high
+context_requirement.c:159:7: warning: out of context read access in 'invalid9' - context too small
+context_requirement.c:166:8: warning: out of context call in 'invalid10' - context too small
+ * check-error-end
+ */


-- 
: Dipl-Ing Philipp Reisner                      Tel +43-1-8178292-50 :
: LINBIT Information Technologies GmbH          Fax +43-1-8178292-82 :
: Vivenotgasse 48, 1120 Vienna, Austria        http://www.linbit.com :
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Thu, 10 Apr 2008 15:54:49 +0000
Message-ID: <1207842889.13354.15.camel () johannes ! berg>
--------------------

--=-QVF+I0oFPP7oba8YTSJi
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

> +# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)

> +#define try_inc_local() __cond_lock(local, _try_inc_local())
> +static int _try_inc_local(void)
> +{
> +	if (random() > RAND_MAX/2) {
> +		local_cnt++;
> +		return 1;
> +	}
> +	return 0;
> +}

That actually works? I guess it shows that I haven't slept enough while
working on this.

johannes

--=-QVF+I0oFPP7oba8YTSJi
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/44SKVg1VMiehFYAQKhSg/7BErNaEn3qkhkalPE7bAZiFHm9Zn2AyNO
kd5WwUeBqv7OD/D5Tbxye47na3im74D6TzhAnI5sjc0MHUxK9rxmpuuFw8Kg+rCx
JQYbfBpJCLRePuqSRFtJiQ3LLFSDdqlEnPnOjXWy1zLm3XZ0gJ/b54z7BjcYgkjv
SQE0ZkftWGxHmGV8zZXlyKJ2BjCMTDKtji5NvFRq3fas1rnB33n2f3raInY4qPBL
SD7tKU6XPBAJP/rMGM0j0gFqDrHiy+O2IIroEzncg9BnK19RWetUl9VTtcVyv7hS
cytEnNJj5YGYn4jAVmdW+OOOIY+Hh5yXauOliC/4Yj2WwW+baLCIjAKUDjbtJhj5
w4yuYBsISD8vGV7ZE3WLSoH9+n39zYn/Bxar36CeVTTHM3LXer33ce6aC83v0NWH
lobGXsmINGjMp4o1XfNyCIT/aPY3NuhK2qvfIdAgVqUCN1w1BP93OjhgDGe7XVpI
XKsBRpMMzmf0j7JP49bW0AhBexXZRxMHsLVVqeGOIb4CM6nPlUVItEwavUQI0D68
JBr4+CdQm8aCq+5/xAPYKdTHD4XsmQaQBy7XIrl5CCKgCOQAmO5YrrRUhdd5xEuz
lQJUQHxpNQFBE7SrGfLiTFVwmflTkWW8VMFWsUdV3AZMAGhxPcjTqMZHlmuwPyAg
q0dW9kBWdl8=
=1pne
-----END PGP SIGNATURE-----

--=-QVF+I0oFPP7oba8YTSJi--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Philipp Reisner <philipp.reisner () linbit ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Thu, 10 Apr 2008 16:05:31 +0000
Message-ID: <200804101805.31854.philipp.reisner () linbit ! com>
--------------------
Am Donnerstag, 10. April 2008 17:51:27 schrieb Johannes Berg:
> > I also worked on that part, although I have to admitt that I did not
> > got that part of the manpage. Instead I invented the require_context
> > attribute.
>
> Heh.
>
> > Here is the second patch. It applies on top of the first one...
>
> I don't really have time to look through it right now, sorry.
>
> > I hope that we get the good ideas of our two works combined and
> > accepted into sparse...
>
> That would be good :)
>

>
> What's this "rdwr" etc. for? And "call"? Also, how are you planning to
> handle nested contexts, where 1,1 doesn't cut it any >0,>0 is really
> more like what we need?
>

I also use it to check a recusive lock mechanism. 

The sematics of what I implemented is:
You simply use the __attribute__((context(ctx,in,out))) to
annotate the context changes of functions.

to annotate a variable, struct/union member or a function that
a certain locking primitive is required for accessing it, you
do it by 

__attribute__((require_context(ctx,min,max,"type")))

ctx ... the expression that describes the locking primitive
min ... the minimum of locks required of that locking primitive
max ... the maximum allowed of locks of that locking primitive.
type .. read, write, rdwr or call for the access type.

So you can express you need to hold this and that locking 
primitive to write to something. But an other locking
primitive might be sufficient for reading that something.

The annotation for a variable foo protected by a recursive lock
bar would be:

int foo __attribute__((require_context(bar,1,99999,"rdwr")))

PS: I just realized that there my e-mail client introduced linebreakes
    in the first patch I posted. I will repost on request of course.

-Phil
-- 
: Dipl-Ing Philipp Reisner                      Tel +43-1-8178292-50 :
: LINBIT Information Technologies GmbH          Fax +43-1-8178292-82 :
: Vivenotgasse 48, 1120 Vienna, Austria        http://www.linbit.com :
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Philipp Reisner <philipp.reisner () linbit ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Thu, 10 Apr 2008 21:21:31 +0000
Message-ID: <200804102321.31681.philipp.reisner () linbit ! com>
--------------------
> >
> > int foo __attribute__((require_context(bar,1,99999,"rdwr")))
>
> Ah. Makes sense as well, though now you can't do something like "require
> context count two and decrement by one", can you? Or do you just do that
> by combining the various attributes?

Right, by combining a context and a require_context attribute.

>
> Anyhow, I don't really care which patch gets chosen.
>

Nor do I really care. I just hope that there is some reaction from Josh
that indicates how he wishes to continue with that toppic...
I am also ready to do further work in this area.

> Though, how can you actually track multiple contexts within a single
> function if you have just a "struct expression *context_expr" for each
> basic block? I guess I should just try your code :)
>

In the check_context() I build a expression_list of all the context 
expressions that are of interest for that entrypoint. Then check_bb_context()
is called for each of these expressions that describe a locking primitive.

-Phil
-- 
: Dipl-Ing Philipp Reisner                      Tel +43-1-8178292-50 :
: LINBIT Information Technologies GmbH          Fax +43-1-8178292-82 :
: Vivenotgasse 48, 1120 Vienna, Austria        http://www.linbit.com :
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Fri, 11 Apr 2008 11:06:54 +0000
Message-ID: <1207912014.13354.52.camel () johannes ! berg>
--------------------

--=-IkkyQkeWa5U+vrXxGk2r
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable

Hi,

Managed to take a closer look now.

> > What's this "rdwr" etc. for? And "call"? Also, how are you planning to
> > handle nested contexts, where 1,1 doesn't cut it any >0,>0 is really
> > more like what we need?
> >
>=20
> I also use it to check a recusive lock mechanism.=20
>=20
> The sematics of what I implemented is:
> You simply use the __attribute__((context(ctx,in,out))) to
> annotate the context changes of functions.
>=20
> to annotate a variable, struct/union member or a function that
> a certain locking primitive is required for accessing it, you
> do it by=20
>=20
> __attribute__((require_context(ctx,min,max,"type")))
>=20
> ctx ... the expression that describes the locking primitive
> min ... the minimum of locks required of that locking primitive
> max ... the maximum allowed of locks of that locking primitive.
> type .. read, write, rdwr or call for the access type.
>=20
> So you can express you need to hold this and that locking=20
> primitive to write to something. But an other locking
> primitive might be sufficient for reading that something.
>=20
> The annotation for a variable foo protected by a recursive lock
> bar would be:
>=20
> int foo __attribute__((require_context(bar,1,99999,"rdwr")))

To be honest, that confuses me. I haven't been able to come up with a
way to make this test case I have result in a warning:

static void bad_macro1(void)
{
    m();
    a();
    r();
}

where a() is acquire(), r() is release() and m() should require the
lock, and all should be implemented as macros. I even tried playing with
dummy inline functions that are called from the macros.

As for read/write, what's wrong with encoding that in the context?

Something like
void read_lock(something) __attribute__((context(read_something,0,1)));
void write_lock(something) __attribute__((context(write_something,0,1)));

or similar. And if it has to be a parameter, why a string?

Another thing I actually like a lot about the fact that my patch changes
the warnings is that it tells you
 - which function caused the error
 - where that function is

I recently had the pleasure of digging through a huge switch statement
that looked like this:

function {

[lots of code]

lock();

[lots more code]

switch(something) {
=EF=BB=BFcase A:
	[lots of code]
	unlock();
	[lots of code]
	break;
[repeat a dozen times]
case M:
=EF=BB=BF	[lots of code]
	unlock();
=EF=BB=BF	[lots of code]
	// *** NOTE MISSING break;
case N:
	[lots of code]
	unlock();		// <----- this is where my code tells you the error is
	[lots of code]
	break;
[repeat another dozen times]
}

[lots more code in the function]

}		// <--- this is where current sparse tells you the error is


Also, my code tells you the function name, and not just "oh, some lock
context was wrong" :) I have just created another patch on top of mine
that will make the error look like this:

context.c:360:10: warning: context problem in 'warn_huge_switch': 'r' expec=
ted different context
context.c:360:10:    default context: wanted >=3D 1, got 0



I like the cond_lock() trick, but I was actually planning on expanding
the checking to switch() statements as well and I don't think we can
make it work there with such a trick.

Maybe something like
__attribute__((conditional_context(ctx,req,default,val=3Dctxchange,...)))

where you could have e.g.
=EF=BB=BF
__attribute__((conditional_context(L,1,0,1=3D1,-1=3D-1)))

Not sure yet though whether that is useful or not.


Finally, I think you have a bit of an inconsistency: You introduced the
require_context attribute, yet your context() macro still partially
fulfils that role, i.e. if you say that a function decreases a context
then you require that it gets one when called. Hence, extending that to
arbitrary context changes defined via the context attribute seems more
natural to me than to require using the require_context attribute for
positive assertions and the context attribute for negative assertions.

> PS: I just realized that there my e-mail client introduced linebreakes
>     in the first patch I posted. I will repost on request of course.

No worries, was easy enough to fix up.

johannes


--=-IkkyQkeWa5U+vrXxGk2r
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/9GTaVg1VMiehFYAQJ60w/+Lx9416nBFmGixTYImaIsg42Ur1ppKI1G
/RLdTRJxw4XpwH0AVCYOn35r9Ct+PJpXzGBFHa8raTi5vqPpQUTxN1LyX1wAdmR+
gwmZAcsSdEyK8iKnYz7ZRMKYSWZuzV2r51SVcemVi8EFWWBg7ijyatvRw5E95yVt
90CE047w7olg11tZ8ChIRhWe+Uab8MVeHwgXm2y89Ly3CXktAr2UYo6UBnxUHsL0
pvz6tAw2pCE9ptghMurZCoi+FgbZU8JodSrRK/j8NDwBpZPJbdeYQQse97TO7+78
EMhuA33T1Y5lB4Fr0oAuj6K/b7C5z7RaAMHU0aZsUoMEQI4qGBbTzs9F6SefxyT1
xn/GRSirHwtppL3EqH/YzwZNaTLRZvgXfblu6QwD5VeImyNX4MpouTrqD43X1YgG
TTMA00rgU3vBW/mnWT1lWgCjIWet+3+YpkddnwH/PT/pcvRTm82MGmSe/xcLbkc+
mPTH4FZQblyWDa5EnZR/3U1BzHejCm1AhXWCC58Pt4CFx3kIAIVFKfs+1EYtBH25
08eF/GbU7xtbPx/DEr9/V5PraUrSXCufuygLcyUzMrnecRN7ZD4SIlXER9m4CGZt
qPfa6MFNdzdPDArqCuWUK0WWqz5da0PD27m20upo6XqRjDlleg2Dub/mcTatUG+0
KFD6/UpU7aU=
=lDEp
-----END PGP SIGNATURE-----

--=-IkkyQkeWa5U+vrXxGk2r--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Fri, 11 Apr 2008 19:53:07 +0000
Message-ID: <47FFC1A3.9090803 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig7BBA488E938C32F89655F8FE
Content-Type: text/plain; charset=ISO-8859-15
Content-Transfer-Encoding: quoted-printable

Philipp Reisner wrote:
>> Anyhow, I don't really care which patch gets chosen.
>=20
> Nor do I really care. I just hope that there is some reaction from Josh=

> that indicates how he wishes to continue with that toppic...
> I am also ready to do further work in this area.

Definitely interested in the patches, just spoiled for choice.
However, having now reviewed the various proposals, I think I will
accept Johannes Berg's patches to support his corresponding proposed
changes in Linux's include/linux/compiler.h.

- Josh Triplett


--------------enig7BBA488E938C32F89655F8FE
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFH/8GjGJuZRtD+evsRAjYPAJwIst3JmjPHdzR/jO/zu1tRR5Y/vQCgitq8
O/OGBWS4HUiSYagfDaTLMhA=
=5xbH
-----END PGP SIGNATURE-----

--------------enig7BBA488E938C32F89655F8FE--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Fri, 18 Apr 2008 12:35:10 +0000
Message-ID: <1208522110.4848.19.camel () johannes ! berg>
--------------------

--=-DBMktwqnn75NBF85Zsyh
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Fri, 2008-04-11 at 12:53 -0700, Josh Triplett wrote:
> Philipp Reisner wrote:
> >> Anyhow, I don't really care which patch gets chosen.
> >=20
> > Nor do I really care. I just hope that there is some reaction from Josh
> > that indicates how he wishes to continue with that toppic...
> > I am also ready to do further work in this area.
>=20
> Definitely interested in the patches, just spoiled for choice.
> However, having now reviewed the various proposals, I think I will
> accept Johannes Berg's patches to support his corresponding proposed
> changes in Linux's include/linux/compiler.h.

Do you want me to fold the later cleanup patches into the first
two/three?

johannes

--=-DBMktwqnn75NBF85Zsyh
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAiVfaVg1VMiehFYAQKhEA/9ETC47CQKioAZtoTc1QeuW6VjyCM20hDe
oLgCOst1wYmb/dqZPo6LxGxdlDFdHicckTFZB9m41MHnT1HK2ZBWNLJpHNWBVm/F
xac2ykpJafXOGRuHYLJEHt3eEs/aZI5527WNYKqfzruLJjGO32Nuol4Y/nV3tOh7
MZCTeChpK4tSeLsD1ROMo/f3X4IJU3He4eMlu7Yq5P/KXsQMWF83wXyE55XOaCFJ
R5p27B1Pk5tIV6rJ+3j+UD6S46QXjGjbX8PKotonE1RndZrlg6q8+9dkTBPj8Yjw
khE7OXytAoXM60FQhKoFNfrlIwa4JaiFYHm2JTMlqD7gmR4Q5SMZJodh6Op3gMRx
quvIH6LXQ25pnmo9xa50Ee4vvvYxyv/YIbmo+UZUeK8aN8NtNYt+OM07whGd/gfu
LDNXF5sL+k9KF2ejgYwn4CozUTXYFQe6dtsEz53OU4WB2bBNoaYtHmfha7DW+w18
SpL+cUUcMSraOvd8GyQ5wGkS5BycW2IM76CjGjJBek0Hoj2DII0K+FUauEyZQbSi
D72MZ00hnRN2xBs7X4T6pLQm/nAKWRHpXZrBk55jEfmbLTeYeK3k8w1wcX6l/AO2
0uWgwAjIv+SSdlkNnS4+BWdAPk6a/sw+PzlqCFmxfpkH7UbYe0eu8M+0mR2YOfR0
nper2URk1Ck=
=UH2S
-----END PGP SIGNATURE-----

--=-DBMktwqnn75NBF85Zsyh--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Mon, 21 Apr 2008 18:04:38 +0000
Message-ID: <480CD736.601 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigC5153A41476CB17862798830
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

One comment on your patch description, by the way:

Johannes Berg wrote:
> However, the kernel use of __attribute__((context(...)) is actually
> wrong, the kernel often does things like:
>=20
>     static void *dev_mc_seq_start(struct seq_file *seq, loff_t * pos)
>             __acquires(dev_base_lock)
>     {
>             [...]
>             read_lock(&dev_base_lock);
>             [...]
>     }
>=20
> rather than
>=20
>     static void *dev_mc_seq_start(struct seq_file *seq, loff_t * pos)
>             __acquires(dev_base_lock)
>     {
>             [...]
>             __acquire__(dev_base_lock);
>             read_lock(&dev_base_lock);
>             [...]
>     }

I don't understand why you count this as wrong.  read_lock should
handle acquiring the context itself, either via an __acquires
annotation if written as a function, or via an __acquire__ statement
if written as a macro.  Callers of read_lock shouldn't need to
explicitly call __acquire__.

- Josh Triplett


--------------enigC5153A41476CB17862798830
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIDNc3GJuZRtD+evsRAq6FAJ0UeK//uhA9EEygEj33qPHSDmWVbACfYVQq
WpZ3Cdz9BQd3Tmp2/IZWTDs=
=2fEz
-----END PGP SIGNATURE-----

--------------enigC5153A41476CB17862798830--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Mon, 21 Apr 2008 18:11:25 +0000
Message-ID: <1208801485.26186.131.camel () johannes ! berg>
--------------------

--=-9sSsGwdy1A5kVRtdk0/T
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> >     static void *dev_mc_seq_start(struct seq_file *seq, loff_t * pos)
> >             __acquires(dev_base_lock)
> >     {
> >             [...]
> >             __acquire__(dev_base_lock);
> >             read_lock(&dev_base_lock);
> >             [...]
> >     }
>=20
> I don't understand why you count this as wrong.  read_lock should
> handle acquiring the context itself, either via an __acquires
> annotation if written as a function, or via an __acquire__ statement
> if written as a macro.  Callers of read_lock shouldn't need to
> explicitly call __acquire__.

Well, the question is how you want to name things. What I did is that
the context identifier is just a name and bears no other relation to the
code. Hence, read_lock() can't say that it acquires 'dev_base_lock'
because it doesn't know what the name should be.

With a slightly different sparse patch than mine you could declare
read_lock() something like this:

#define read_lock(x) do { \
	__acquire__(x); \
	__read_lock((x)); \
} while (0)

but then you'd have different names everywhere, say somebody passed
'&dev_base_lock' and somebody else used

readlock_t *dbl =3D &dev_base_lock;
read_lock(dbl)

and you'd end up with one context named "dbl" and another one named
"&dev_base_lock".

If you have suggestions on how to solve this I'm all ears, so far I
decided it wasn't worth it and opted for explicitly naming all the
contexts.

(with my patch the above would just create a context called "x")

johannes

--=-9sSsGwdy1A5kVRtdk0/T
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAzYzKVg1VMiehFYAQJCjA/+JrujuELoJCNPxj4CLIptdHKYNXIPb2/R
SHFvDE/fVcMAXuHjNFjJ9k/y/KriILvoFy75WPNrToZcGT19QRR+5xL7cg0bWwLU
erVsrVFYcPtsPScILpd2aQU1/PZ86MOPWkQQiJ9wG9dU1n79omuHC0oPdcSrZtV5
mPt49QfiKLWiOZU5KDkyIAvd13G/413lo5QViKeHn++J8G33AqopT1DRep7QeOuG
oKhDOR95+wwuVyI0TiiyFrrut6PHj0HBtmCSepihwS9bWa4z0ckwhQro3VKaNY3h
2MPkLfZQTqRHQn7ij6BwXzHZKj/unvzNVRhQTLJaAIZDvKpGiN6a+jbEwAC8dQSD
Z2eiuaXbkMcQltMKEJUUKQ2o/pctbWnkdioTxic3lG3ZfITFbqdPz/GkEYSC5zpP
KLmGLNxfkhkF/Dyv1EMg2WeAbbdWXVefsZDuIWoR4W96kabzzvPW1NE/hjeXHx2p
RZOD8OBiuT+ij4nN9d7JhYZGOKhJOty5Hdlqy/zXA6cyrM+3yIaAvTin80QY3tOg
uJo/rWD1IdyggxjvHkfBdS/n5vAmIrVvy7einUTL6a9L/c/xbPn+yAN1XCRPsKYt
EUoIw5lRmsZHJ3RYr5UKs9cVF0H6PCXuoSDwxb/Bx+mM5yPDkOzVB18tVQwbB3Py
vbME/e5bf+o=
=O+oa
-----END PGP SIGNATURE-----

--=-9sSsGwdy1A5kVRtdk0/T--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Mon, 21 Apr 2008 18:26:04 +0000
Message-ID: <480CDC3C.4040808 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig5624E8559F878735E98B2D46
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Johannes Berg wrote:
>>>     static void *dev_mc_seq_start(struct seq_file *seq, loff_t * pos)=

>>>             __acquires(dev_base_lock)
>>>     {
>>>             [...]
>>>             __acquire__(dev_base_lock);
>>>             read_lock(&dev_base_lock);
>>>             [...]
>>>     }
>> I don't understand why you count this as wrong.  read_lock should
>> handle acquiring the context itself, either via an __acquires
>> annotation if written as a function, or via an __acquire__ statement
>> if written as a macro.  Callers of read_lock shouldn't need to
>> explicitly call __acquire__.
>=20
> Well, the question is how you want to name things. What I did is that
> the context identifier is just a name and bears no other relation to th=
e
> code. Hence, read_lock() can't say that it acquires 'dev_base_lock'
> because it doesn't know what the name should be.
>=20
> With a slightly different sparse patch than mine you could declare
> read_lock() something like this:
>=20
> #define read_lock(x) do { \
> 	__acquire__(x); \
> 	__read_lock((x)); \
> } while (0)
>=20
> but then you'd have different names everywhere, say somebody passed
> '&dev_base_lock' and somebody else used
>=20
> readlock_t *dbl =3D &dev_base_lock;
> read_lock(dbl)
>=20
> and you'd end up with one context named "dbl" and another one named
> "&dev_base_lock".

That might still work, depending on how consistently kernel code uses
the same argument.  If you suggest explicitly changing calls to
read_lock to call __acquire__ with the appropriate context, it might
prove equally easy to make the argument of read_lock that context.

> If you have suggestions on how to solve this I'm all ears, so far I
> decided it wasn't worth it and opted for explicitly naming all the
> contexts.
>=20
> (with my patch the above would just create a context called "x")

That doesn't make sense to me; after preprocessing, x no longer
exists, so I don't see how you could pick up the identifier "x".  I
can understand that you might pick up two different expressions in
place of x which you can't easily compare, though.

And as for how to solve it: I think alias analysis might work.

- Josh Triplett


--------------enig5624E8559F878735E98B2D46
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIDNw8GJuZRtD+evsRApsIAKCUJ2JS0I4qG0G0BNPdGVMNrzs16QCghyKH
7kX75tTGpoAcOBiwfo2WGHs=
=9Fy9
-----END PGP SIGNATURE-----

--------------enig5624E8559F878735E98B2D46--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Mon, 21 Apr 2008 18:30:34 +0000
Message-ID: <1208802634.26186.135.camel () johannes ! berg>
--------------------

--=-28u/U74aIIqCj1KUAjcE
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> > and you'd end up with one context named "dbl" and another one named
> > "&dev_base_lock".
>=20
> That might still work, depending on how consistently kernel code uses
> the same argument.  If you suggest explicitly changing calls to
> read_lock to call __acquire__ with the appropriate context, it might
> prove equally easy to make the argument of read_lock that context.

True.

> That doesn't make sense to me; after preprocessing, x no longer
> exists, so I don't see how you could pick up the identifier "x".  I
> can understand that you might pick up two different expressions in
> place of x which you can't easily compare, though.

Oops, yes, preprocessing will remove it, of course. But yeah, you can
end up with two different expressions.

> And as for how to solve it: I think alias analysis might work.

How would I do that?

johannes

--=-28u/U74aIIqCj1KUAjcE
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAzdSKVg1VMiehFYAQIa9RAAxBmmWQkdOLfR8YkqtwM05PKPWFUYC3Tu
c/gwxNxS5ZKTVX7LOr2XvfL9ripZaVILbvCnRWK1UquuO4CpzujucpylFWBkcMFV
5X+jNLNL48PYDTcHuaphDtVneMPnbHgBBXDIdlnEbJlGoNiKssKPVN2wUM8bZDNm
yIlEQJL6kseJLCWZUg0uOJZClN7n2IUR0CH+6hOGEjjqN8nWboAugWbxDqktuANn
n3UwXJAZMLR/mAKBefeWOJHl/gekyPVJppwDK38MyS3w0ejJHiB0oFzpyTBk64hW
FfzeUvg8LorYdlq7vkpyc2qJOmlhUIwlgoYAU1CnLHzFduWLTVcCNUt5BtzMqyn0
XGeOdpJfLb/yUxWLZul736GwBBO/tgQuWbf1sRbJX14jV1pzGa6bKyWtwAHtOzqm
DkVgA+wZFoDnAZqpvQzeT/T9LvWuGGUUfnZFCXZPkeDvx03Q42EA8wN1d2xC/iYc
tTkyB1AjKfb/zqsweiLIh4lwJ7Or7moQciY4h/bFWUYoCf18yyt5diqZh1dinT8H
jp/mcx0hDaB+HZIAMHNVvoNq75sR3WnPlclSkV3yIl8PK9kOGwG/h8Y5ws7+QAJD
kYXIQy6S6HvhqQfX6L/mNv1Vo45DqNal2HGqvpvjVSP37X3IT1J3zPwsJpoatL32
demSJ2dJw+Y=
=LrQ+
-----END PGP SIGNATURE-----

--=-28u/U74aIIqCj1KUAjcE--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Mon, 21 Apr 2008 19:22:31 +0000
Message-ID: <480CE977.5050006 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigC8084B182612E062E0C54B3C
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Johannes Berg wrote:
>> I just have implemented nearly the same here. Hopefully Josh will
>> decide for one of these patches soon.
>=20
>> +int ident_equal(struct ident *ident1, struct ident *ident2)
>=20
>> +int expressions_equal(struct expression *expr1, struct expression *ex=
pr2)
>=20
> That code looks pretty nice, I guess I should look at getting that into=

> my version instead of just printing the identifier to a string.

I would love to see this work applied on top of the merged patches as wel=
l.

- Josh Triplett


--------------enigC8084B182612E062E0C54B3C
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIDOl3GJuZRtD+evsRApzyAJ47m2G3bN8Ogp/N7hXYwqwIK9JsnwCbB/7m
kvnks1hdzkSedKfzl2YGsR4=
=IgdX
-----END PGP SIGNATURE-----

--------------enigC8084B182612E062E0C54B3C--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Mon, 21 Apr 2008 19:34:41 +0000
Message-ID: <480CEC51.1000907 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig3297E7362F5691A1B15E8F70
Content-Type: text/plain; charset=ISO-8859-15
Content-Transfer-Encoding: quoted-printable

Philipp Reisner wrote:
> The sematics of what I implemented is:
> You simply use the __attribute__((context(ctx,in,out))) to
> annotate the context changes of functions.
>=20
> to annotate a variable, struct/union member or a function that
> a certain locking primitive is required for accessing it, you
> do it by=20
>=20
> __attribute__((require_context(ctx,min,max,"type")))
>=20
> ctx ... the expression that describes the locking primitive
> min ... the minimum of locks required of that locking primitive
> max ... the maximum allowed of locks of that locking primitive.
> type .. read, write, rdwr or call for the access type.
>=20
> So you can express you need to hold this and that locking=20
> primitive to write to something. But an other locking
> primitive might be sufficient for reading that something.
>=20
> The annotation for a variable foo protected by a recursive lock
> bar would be:
>=20
> int foo __attribute__((require_context(bar,1,99999,"rdwr")))

I would *love* to see this work applied on top of the patches I
applied from Johannes.  I really want the ability to mark a variable
or struct field as requiring a context to access.

I would probably call this new attribute something like
"data_context".  Also, I'd prefer an explicit way of saying "no
maximum context", rather than the hack of using a large number.

I hestiate to introduce a third semantic for a pair of numbers
describing a context.  The context attribute uses in and out contexts,
__context__ uses a delta and a required minimum, and this proposed
attribute uses a minimum and a maximum.

Similar to GCC's format attribute using the identifier printf rather
than the string "printf", I think I'd prefer the last argument as an
identifier.  Also, a minor nit: could you please use "readwrite"
rather than "rdwr"?

- Josh Triplett


--------------enig3297E7362F5691A1B15E8F70
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIDOxRGJuZRtD+evsRAiODAJ9zbhKuRZzrMZxMWLn2CL/3ckjgXACgtgTu
/xESlJaRWV7QPt1T3s5vklg=
=GKfH
-----END PGP SIGNATURE-----

--------------enig3297E7362F5691A1B15E8F70--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 1/3] make sparse keep its promise about context tracking
Date: Mon, 21 Apr 2008 19:37:50 +0000
Message-ID: <1208806670.26186.138.camel () johannes ! berg>
--------------------

--=-pnNKTUH7tmhOFbF2TQEK
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> I would *love* to see this work applied on top of the patches I
> applied from Johannes.  I really want the ability to mark a variable
> or struct field as requiring a context to access.
>=20
> I would probably call this new attribute something like
> "data_context".  Also, I'd prefer an explicit way of saying "no
> maximum context", rather than the hack of using a large number.
>=20
> I hestiate to introduce a third semantic for a pair of numbers
> describing a context.  The context attribute uses in and out contexts,
> __context__ uses a delta and a required minimum, and this proposed
> attribute uses a minimum and a maximum.

I have a fairly simple patch on top of my work for this
http://johannes.sipsolutions.net/patches/sparse/all/LATEST/001-context-on-v=
ars.patch

however, it doesn't really work with struct variables...

johannes

--=-pnNKTUH7tmhOFbF2TQEK
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAztDaVg1VMiehFYAQKMOBAAmSYPr/sxxDK77MbYaVR3M1nadRVhMih+
0EU2GOlmEtORtovek2lnQ6YwABH9zSV+LIh1ahV+O7wCcYCrd3fpT0QbHpXtXob5
+evzmOtCdJoTw1urKE0YwEFsoc8mehULLUPi7ZvLlLBW1AXsXy1rAXZ0Hc0Bb4GE
jCoxO8FqGzWmVM1ddiOAgi4P77L/6pD+72v9J5nIy0ZMxH6EhAA5Fg0mx1qa5tPD
3pPpQ+1a2c3Z3rdkw9PUf5/i2q2YPHVfmjNeOu4NGqiPYVuz5m8JFZ0vzhFT20XT
abseRG96MYC2vhQ4Pms86Mt6hQN+zxGA6nTJUb0TlfacM651LadvZ623jev/DMrF
Y17kXEPXVa1zbpDMfMbnM3whK/wuziibMRqdFCOahFVp1aPrKVtjRjGqCm9E2qa1
joSVenlvBs3nnxHjTQistUNEgKPUE7cZxXhd4Xg54Kp2CFbkBJVrjIuEunZsLx7M
rWVw+YM/gR7gtYVLwO03si3+4tk58puxvCP04pqTBJp4LYYx9ARD1p6+MFo9c3QA
TlokKeBggmbdITL+7ci7JgM1O/IuQ9dCLwXeW0pt3QzIi7FA2HHgworM2HfRV/UJ
9md9AHH/liRuseW24QqKkPJ4XKO+fZRTMg6+hWevjN0J4qWpXGwlcunPUXGBngre
GXTA+h+zsh4=
=GU4J
-----END PGP SIGNATURE-----

--=-pnNKTUH7tmhOFbF2TQEK--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/5] add __exact_context__ ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 1/5] add __exact_context__
Date: Sun, 27 Apr 2008 11:31:29 +0000
Message-ID: <20080427113348.793620000 () sipsolutions ! net>
--------------------
We also need a statement to indicate that an exact context is
required, most notably the next patch will require it so that
it can translate attributes on variables into statements.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 ident-list.h               |    1 
 linearize.c                |    1 
 linearize.h                |    2 -
 parse.c                    |   20 ++++++++++++-
 parse.h                    |    1 
 sparse.1                   |    2 -
 sparse.c                   |   14 ++++++---
 validation/context-exact.c |   67 +++++++++++++++++++++++++++++++++++++++++++++
 8 files changed, 101 insertions(+), 7 deletions(-)

--- sparse.orig/ident-list.h	2008-04-26 23:09:00.000000000 +0200
+++ sparse/ident-list.h	2008-04-26 23:09:05.000000000 +0200
@@ -96,6 +96,7 @@ __IDENT(__PRETTY_FUNCTION___ident, "__PR
 
 /* Sparse commands */
 IDENT_RESERVED(__context__);
+IDENT_RESERVED(__exact_context__);
 IDENT_RESERVED(__range__);
 
 /* Magic function names we recognize */
--- sparse.orig/linearize.c	2008-04-26 23:09:00.000000000 +0200
+++ sparse/linearize.c	2008-04-26 23:09:05.000000000 +0200
@@ -1681,6 +1681,7 @@ static pseudo_t linearize_context(struct
 		value = expr->value;
 
 	insn->required = value;
+	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
 	add_one_insn(ep, insn);
--- sparse.orig/parse.c	2008-04-26 23:09:04.000000000 +0200
+++ sparse/parse.c	2008-04-26 23:09:05.000000000 +0200
@@ -52,6 +52,7 @@ static struct token *parse_while_stateme
 static struct token *parse_do_statement(struct token *token, struct statement *stmt);
 static struct token *parse_goto_statement(struct token *token, struct statement *stmt);
 static struct token *parse_context_statement(struct token *token, struct statement *stmt);
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt);
 static struct token *parse_range_statement(struct token *token, struct statement *stmt);
 static struct token *parse_asm_statement(struct token *token, struct statement *stmt);
 static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
@@ -149,6 +150,10 @@ static struct symbol_op __context___op =
 	.statement = parse_context_statement,
 };
 
+static struct symbol_op __exact_context___op = {
+	.statement = parse_exact_context_statement,
+};
+
 static struct symbol_op range_op = {
 	.statement = parse_range_statement,
 };
@@ -254,6 +259,7 @@ static struct init_keyword {
 	{ "do",		NS_KEYWORD, .op = &do_op },
 	{ "goto",	NS_KEYWORD, .op = &goto_op },
 	{ "__context__",NS_KEYWORD, .op = &__context___op },
+	{ "__exact_context__",NS_KEYWORD, .op = &__exact_context___op },
 	{ "__range__",	NS_KEYWORD, .op = &range_op },
 	{ "asm",	NS_KEYWORD, .op = &asm_op },
 	{ "__asm",	NS_KEYWORD, .op = &asm_op },
@@ -1810,7 +1816,7 @@ static struct token *parse_goto_statemen
 	return expect(token, ';', "at end of statement");
 }
 
-static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+static struct token *_parse_context_statement(struct token *token, struct statement *stmt, int exact)
 {
 	struct expression *args[3];
 	int argc = 0;
@@ -1835,6 +1841,8 @@ static struct token *parse_context_state
 	stmt->expression = args[0];
 	stmt->context = NULL;
 
+	stmt->exact = exact;
+
 	switch (argc) {
 	case 0:
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
@@ -1864,6 +1872,16 @@ static struct token *parse_context_state
 	return expect(token, ')', "at end of __context__");
 }
 
+static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 0);
+}
+
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 1);
+}
+
 static struct token *parse_range_statement(struct token *token, struct statement *stmt)
 {
 	stmt->type = STMT_RANGE;
--- sparse.orig/sparse.1	2008-04-26 23:09:00.000000000 +0200
+++ sparse/sparse.1	2008-04-26 23:09:05.000000000 +0200
@@ -90,7 +90,7 @@ To indicate that a function requires
 .BI exactly
 a certain lock context (not "at least" as above), use the form
 .BI __attribute__((exact_context( [expression ,] in_context , out_context ))
-There currently is no corresponding
+There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
--- sparse.orig/sparse.c	2008-04-26 23:09:00.000000000 +0200
+++ sparse/sparse.c	2008-04-26 23:09:05.000000000 +0200
@@ -239,7 +239,7 @@ static int handle_context(struct entrypo
 			  struct context_check_list **combined)
 {
 	struct context_check *c;
-	const char *name;
+	const char *name, *cmp;
 	char *buf;
 	int val, ok;
 
@@ -256,7 +256,13 @@ static int handle_context(struct entrypo
 		}
 	} END_FOR_EACH_PTR(c);
 
-	ok = insn->required <= val;
+	if (insn->exact) {
+		ok = insn->required == val;
+		cmp = "";
+	} else {
+		ok = insn->required <= val;
+		cmp = ">= ";
+	}
 
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
@@ -266,8 +272,8 @@ static int handle_context(struct entrypo
 			"__context__ statement expected different context",
 			show_ident(ep->name->ident));
 
-		info(insn->pos, "%swanted >= %d, got %d",
-		     name, insn->required, val);
+		info(insn->pos, "%swanted %s%d, got %d",
+		     name, cmp, insn->required, val);
 
 		free(buf);
 		return -1;
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-exact.c	2008-04-26 23:09:05.000000000 +0200
@@ -0,0 +1,67 @@
+static void a(void) __attribute__((context(TEST,0,1)))
+{
+	__context__(TEST,1);
+}
+
+static void r(void) __attribute__((context(TEST,1,0)))
+{
+	__context__(TEST,-1,1);
+}
+
+static void good_1(void)
+{
+	a();
+	r();
+}
+
+static void good_2(void)
+{
+	a();
+	r();
+	a();
+	r();
+}
+
+static void good_3(void)
+{
+	a();
+	a();
+	r();
+	r();
+}
+
+static void good_4(void)
+{
+	a();
+	a();
+	__context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void warn_1(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void good_5(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,2);
+	r();
+	r();
+}
+
+/*
+ * check-name: Check __exact_context__ statement with required context
+ *
+ * check-error-start
+context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2:    context 'TEST': wanted 1, got 2
+ * check-error-end
+ */
--- sparse.orig/linearize.h	2008-04-26 23:09:00.000000000 +0200
+++ sparse/linearize.h	2008-04-26 23:09:05.000000000 +0200
@@ -116,7 +116,7 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false;
+			int increment, required, inc_false, exact;
 			struct expression *context_expr;
 		};
 		struct /* asm */ {
--- sparse.orig/parse.h	2008-04-26 23:09:00.000000000 +0200
+++ sparse/parse.h	2008-04-26 23:09:05.000000000 +0200
@@ -43,6 +43,7 @@ struct statement {
 			struct expression *expression;
 			struct expression *context;
 			struct expression *required;
+			int exact;
 		};
 		struct /* return_statement */ {
 			struct expression *ret_value;

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/9] add test for acquire/release ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 1/9] add test for acquire/release
Date: Thu, 29 May 2008 08:54:03 +0000
Message-ID: <20080529085512.974905000 () sipsolutions ! net>
--------------------
Test that giving
	__attribute__((context(TEST,1,0)))
	__attribute__((context(TEST,0,1)))
instead of
	__attribute__((context(TEST,1,1)))
works.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 validation/context.c |   15 +++++++++++++++
 1 file changed, 15 insertions(+)

--- sparse.orig/validation/context.c	2008-05-13 23:40:36.000000000 +0200
+++ sparse/validation/context.c	2008-05-14 00:58:33.000000000 +0200
@@ -380,6 +380,21 @@ static int warn_conditional(void)
     return 0;
 }
 
+static void good_require(void)
+__attribute__((context(TEST,1,0)))
+__attribute__((context(TEST,0,1)))
+{
+    __context__(TEST,-1);
+    __context__(TEST,1);
+}
+
+static void good_require_caller(void)
+{
+    __context__(TEST,1,0);
+    good_require();
+    __context__(TEST,-1,1);
+}
+
 /*
  * check-name: Check -Wcontext
  *

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 10/10] A simple demonstrational program that looks up symbols in sparse object files. ===

From: alexey.zaytsev () gmail ! com
To: linux-sparse
Subject: [PATCH 10/10] A simple demonstrational program that looks up symbols in sparse object files.
Date: Wed, 03 Sep 2008 21:55:54 +0000
Message-ID: <ee1fe6be61d60da3a892f127253582e1620131e5.1220475018.git.xl0 () xl0 ! local>
--------------------
From: Alexey Zaytsev <alexey.zaytsev@gmail.com>

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 Makefile |    6 +++++-
 where.c  |   61 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 66 insertions(+), 1 deletions(-)
 create mode 100644 where.c

diff --git a/Makefile b/Makefile
index 877634c..446e053 100644
--- a/Makefile
+++ b/Makefile
@@ -26,7 +26,7 @@ INCLUDEDIR=$(PREFIX)/include
 PKGCONFIGDIR=$(LIBDIR)/pkgconfig
 
 PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse test-linearize example \
-	 test-unssa test-dissect ctags serialization-test sold
+	 test-unssa test-dissect ctags serialization-test sold where
 
 
 INST_PROGRAMS=sparse sold cgcc cld car
@@ -141,6 +141,9 @@ serialization-test: serialization-test.o $(LIBS)
 sold: sold.o $(LIBS)
 	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS) -ldl
 
+where: where.o $(LIBS)
+	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS) -ldl
+
 $(LIB_FILE): $(LIB_OBJS)
 	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)
 
@@ -195,6 +198,7 @@ serialization.o: $(LIB_H)
 serialization-test.o: $(LIB_H)
 link.o: $(LIB_H)
 sold.o: $(LIB_H)
+where: $(LIB_H)
 
 pre-process.h:
 	$(QUIET_GEN)echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=`\"" > pre-process.h
diff --git a/where.c b/where.c
new file mode 100644
index 0000000..03241f9
--- /dev/null
+++ b/where.c
@@ -0,0 +1,61 @@
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <limits.h>
+
+#include "lib.h"
+#include "link.h"
+
+int main(int argc, char **argv)
+{
+	void *handle;
+	char *err;
+	struct sold_symbol *sym;
+	struct sold_symbol_list **symbols;
+	const char sym_type_tbl[] = {'F', 'D', 'O'};
+	char input[PATH_MAX];
+
+
+	if (argc < 2) {
+		fprintf(stderr, "usage: %s <sparse_object_file> [symbol_name]\n", argv[0]);
+		exit(1);
+	}
+
+	snprintf(input, PATH_MAX, "./%s", argv[1]);
+
+	dlerror();
+	handle = dlopen(input, RTLD_NOW);
+	if (!handle) {
+		fprintf(stderr, "%s: Can't open input file %s: %s\n",
+			argv[0], input, dlerror());
+		exit(1);
+	}
+
+	symbols = dlsym(handle, "symbols");
+	err = dlerror();
+	if (!symbols) {
+		if (err) {
+			fprintf(stderr, "%s: Can't process the input file %s: %s\n",
+				argv[0], input, err);
+			exit(1);
+		}
+		/* empty symbol list. */
+		exit(0);
+	}
+
+	if (argc > 2) {/* Look up the symbol */
+		FOR_EACH_PTR(*symbols, sym) {
+			if (!strcmp(argv[2], sym->name))
+				printf("%c %s %s\n", sym_type_tbl[sym->type],
+					sym->name, sym->source->source);
+		} END_FOR_EACH_PTR(sym);
+	} else {/* Just list all symbols */
+		FOR_EACH_PTR(*symbols, sym) {
+			printf("%c %s %s\n", sym_type_tbl[sym->type],
+				sym->name, sym->source->source);
+		} END_FOR_EACH_PTR(sym);
+	}
+
+	return 0;
+}
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 10/16] Allow context() attribute on variables ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 10/16] Allow context() attribute on variables
Date: Thu, 18 Dec 2008 22:33:46 +0000
Message-ID: <20081218223336.23692.15867.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

This patch makes it possible to add the context attribute on
variables, to warn for example in this case:

    struct something {
        int x __attribute__((context(L,1,1)));
    };

    extern struct something *s;

    static void warn_access13(void)
    {
        s->x = 7;
    }

This is achieved by translating the context attribute on
variables that are loaded from/stored to into a context
expression internally. A number of tests are included,
including tests for a struct member (as above) and array
accesses.

To distinguish between reads and writes (the default is to
check both) use the fourth parameter to the context attribute:
	__attribute__((context(L,1,1,read)))
or
	__attribute__((context(L,1,1,write)))

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 linearize.c                    |   92 ++++++++++++++++-
 linearize.h                    |    1 
 parse.c                        |   25 ++++-
 sparse.1                       |    7 +
 sparse.c                       |   18 +++
 symbol.h                       |    7 +
 validation/context-exact.c     |    2 
 validation/context-on-vars.c   |  219 ++++++++++++++++++++++++++++++++++++++++
 validation/context-statement.c |    6 +
 9 files changed, 365 insertions(+), 12 deletions(-)
 create mode 100644 validation/context-on-vars.c

diff --git a/linearize.c b/linearize.c
index 111e7af..9f5628a 100644
--- a/linearize.c
+++ b/linearize.c
@@ -30,7 +30,6 @@ static pseudo_t add_setval(struct entrypoint *ep, struct symbol *ctype, struct e
 static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym);
 
 struct access_data;
-static pseudo_t add_load(struct entrypoint *ep, struct access_data *);
 static pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *);
 
 struct pseudo void_pseudo = {};
@@ -937,6 +936,8 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 		pseudo_t value,
 		struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t store = value;
 
 	if (type_size(ad->source_type) != type_size(ad->result_type)) {
@@ -952,6 +953,49 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 		store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
 	}
 	add_store(ep, ad, store);
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_WRITE)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_WRITE)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			if (context->rws != CTX_RWS_BOTH &&
+			    context->rws != CTX_RWS_WRITE)
+				continue;
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return value;
 }
 
@@ -989,6 +1033,8 @@ static pseudo_t add_symbol_address(struct entrypoint *ep, struct symbol *sym)
 
 static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t new = add_load(ep, ad);
 
 	if (ad->bit_offset) {
@@ -996,7 +1042,49 @@ static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad
 		pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
 		new = newval;
 	}
-		
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_READ)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_READ)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			if (context->rws != CTX_RWS_BOTH &&
+			    context->rws != CTX_RWS_READ)
+				continue;
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return new;
 }
 
diff --git a/linearize.h b/linearize.h
index 69341c2..4e9100d 100644
--- a/linearize.h
+++ b/linearize.h
@@ -119,6 +119,7 @@ struct instruction {
 		struct /* context */ {
 			int increment, required, inc_false, exact;
 			struct expression *context_expr;
+			struct symbol *access_var;
 		};
 		struct /* asm */ {
 			const char *string;
diff --git a/parse.c b/parse.c
index 5ad8c68..2ac3d0e 100644
--- a/parse.c
+++ b/parse.c
@@ -884,16 +884,18 @@ static struct token *attribute_mode(struct token *token, struct symbol *attr, st
 static struct token *_attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype, int exact)
 {
 	struct context *context = alloc_context();
-	struct expression *args[3];
+	struct expression *args[4];
 	int argc = 0;
+	struct token *last = NULL;
 
 	token = expect(token, '(', "after context attribute");
 	while (!match_op(token, ')')) {
 		struct expression *expr = NULL;
+		last = token;
 		token = conditional_expression(token, &expr);
 		if (!expr)
 			break;
-		if (argc < 3)
+		if (argc < 4)
 			args[argc++] = expr;
 		else
 			argc++;
@@ -918,6 +920,25 @@ static struct token *_attribute_context(struct token *token, struct symbol *attr
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 		break;
+	case 4: {
+		const char *rw;
+		context->context = args[0];
+		context->in = get_expression_value(args[1]);
+		context->out = get_expression_value(args[2]);
+
+		if (last && token_type(last) == TOKEN_IDENT)
+			rw = show_token(last);
+		else
+			rw = NULL;
+
+		if (rw && strcmp(rw, "read") == 0)
+			context->rws = CTX_RWS_READ;
+		else if (rw && strcmp(rw, "write") == 0)
+			context->rws = CTX_RWS_WRITE;
+		else
+			sparse_error(last->pos, "invalid read/write specifier");
+		break;
+	}
 	default:
 		sparse_error(token->pos, "too many arguments to context attribute");
 		break;
diff --git a/sparse.1 b/sparse.1
index 45eea6f..61c40b8 100644
--- a/sparse.1
+++ b/sparse.1
@@ -94,6 +94,13 @@ There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
+Both these can also be added to variable accesses but it is not recommended
+to make variable accesses modify the context. For variables, it is possible
+to distinguish between reads and writes (the regular context attribute will
+be required on both reads and writes) by using either the token "read" or
+the token "write" for an optional fourth argument:
+.BI __attribute__((context( expression , in_context , out_context , read|write )).
+
 To indicate that a certain function acquires a context depending on its
 return value, use
 .BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
diff --git a/sparse.c b/sparse.c
index a26c8f2..1149244 100644
--- a/sparse.c
+++ b/sparse.c
@@ -114,6 +114,7 @@ static struct context_check_list *checked_copy(struct context_check_list *ccl)
 }
 
 #define IMBALANCE_IN "context imbalance in '%s': "
+#define CONTEXT_PROB "context problem in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
 static void get_context_string(char **buf, const char **name)
@@ -267,10 +268,19 @@ static int handle_context(struct entrypoint *ep, struct basic_block *bb,
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
 
-		warning(insn->pos,
-			IMBALANCE_IN
-			"__context__ statement expected different context",
-			show_ident(ep->name->ident));
+		if (insn->access_var) {
+			char *symname = strdup(show_ident(insn->access_var->ident));
+			warning(insn->pos,
+				CONTEXT_PROB
+				"access to '%s' requires different context",
+				show_ident(ep->name->ident), symname);
+			free(symname);
+		} else {
+			warning(insn->pos,
+				CONTEXT_PROB
+				"__context__ statement expected different context",
+				show_ident(ep->name->ident));
+		}
 
 		info(insn->pos, "%swanted %s%d, got %d",
 		     name, cmp, insn->required, val);
diff --git a/symbol.h b/symbol.h
index c4d7f28..f79674f 100644
--- a/symbol.h
+++ b/symbol.h
@@ -69,10 +69,17 @@ enum keyword {
 	KW_MODE		= 1 << 7,
 };
 
+enum context_read_write_specifier {
+	CTX_RWS_BOTH = 0,
+	CTX_RWS_READ,
+	CTX_RWS_WRITE,
+};
+
 struct context {
 	struct expression *context;
 	unsigned int in, out, out_false;
 	int exact;
+	enum context_read_write_specifier rws;
 };
 
 extern struct context *alloc_context(void);
diff --git a/validation/context-exact.c b/validation/context-exact.c
index bacd9a1..9b699f8 100644
--- a/validation/context-exact.c
+++ b/validation/context-exact.c
@@ -61,7 +61,7 @@ static void good_5(void)
  * check-name: Check __exact_context__ statement with required context
  *
  * check-error-start
-context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2: warning: context problem in 'warn_1': __context__ statement expected different context
 context-exact.c:46:2:    context 'TEST': wanted 1, got 2
  * check-error-end
  */
diff --git a/validation/context-on-vars.c b/validation/context-on-vars.c
new file mode 100644
index 0000000..c0fb623
--- /dev/null
+++ b/validation/context-on-vars.c
@@ -0,0 +1,219 @@
+static void a(void) __attribute__((context(L,0,1)))
+{
+	__context__(L,1);
+}
+
+static void r(void) __attribute__((context(L,1,0)))
+{
+	__context__(L,-1);
+}
+
+static int nl_int __attribute__((context(L,1,1)));
+static int nl_array[100] __attribute__((context(L,1,1)));
+extern int condition;
+
+static void warn_access1(void)
+{
+    nl_int = 7;
+}
+
+static void warn_access2(void)
+{
+    nl_int++;
+}
+
+static void warn_access3(void)
+{
+    if (condition)
+        nl_int++;
+}
+
+static void warn_access4(void)
+{
+    condition -= nl_int;
+}
+
+static void warn_access5(void)
+{
+    int x = condition ? nl_int : 0;
+}
+
+static void warn_access6(void)
+{
+    if (!nl_int) {
+        condition = 1;
+    }
+}
+
+static void warn_access7(void)
+{
+    if (nl_int) {
+        condition = 1;
+    }
+}
+
+static int *warn_access8(void)
+{
+    return &nl_int;
+}
+
+static void warn_access9(void)
+{
+    (void*)nl_int;
+}
+
+static void warn_access10(void)
+{
+    nl_array[7]++;
+}
+
+static void good_access1(void)
+{
+    a();
+    nl_int = 7;
+    r();
+}
+
+static void good_access1(void)
+{
+    if (condition) {
+        a();
+        nl_int = 7;
+        r();
+    }
+}
+
+static void good_access3(void)
+{
+    /* tests more our ability to optimise things out ... */
+    int x = 0 ? nl_int : 0;
+}
+
+static int *good_access4(void)
+{
+    return &nl_int;
+}
+
+struct something {
+    int a;
+    int b;
+};
+
+extern struct something *s __attribute__((context(L,1,1)));
+
+static void warn_access11(void)
+{
+    s->b = 7;
+}
+
+struct something2 {
+    int a;
+    int b __attribute__((context(L,1,1)));
+};
+
+extern struct something2 *s2;
+extern int lx __attribute__((context(L,1,1)));
+
+static void warn_access12(void)
+{
+    s2->b = lx;
+}
+
+static void warn_access13(void)
+{
+    s2->b = 7;
+}
+
+static void good_1(void)
+{
+    a();
+    s2->b = 7;
+    r();
+}
+
+static void good_2(void)
+{
+    a();
+    a();
+    s2->b = 8;
+    r();
+    r();
+}
+
+struct something3 {
+    int a;
+    int b __attribute__((exact_context(L,1,1)));
+};
+
+extern struct something3 *s3;
+
+static void warn_exact1(void)
+{
+    a();
+    a();
+    s3->b = 8;
+    r();
+    r();
+}
+
+extern int x __attribute__((context(L,1,1,read)));
+extern int y __attribute__((context(L,1,1,write)));
+
+static void good_3(void)
+{
+  a();
+  y = x;
+  r();
+}
+
+static void good_4(void)
+{
+  x = y;
+}
+
+static void warn_access14(void)
+{
+  x;
+}
+
+static void warn_access15(void)
+{
+  y = 7;
+}
+
+/*
+ * check-name: Check -Wcontext for variables
+ *
+ * check-error-start
+context-on-vars.c:17:14: warning: context problem in 'warn_access1': access to 'nl_int' requires different context
+context-on-vars.c:17:14:    context 'L': wanted >= 1, got 0
+context-on-vars.c:22:11: warning: context problem in 'warn_access2': access to 'nl_int' requires different context
+context-on-vars.c:22:11:    context 'L': wanted >= 1, got 0
+context-on-vars.c:28:15: warning: context problem in 'warn_access3': access to 'nl_int' requires different context
+context-on-vars.c:28:15:    context 'L': wanted >= 1, got 0
+context-on-vars.c:33:18: warning: context problem in 'warn_access4': access to 'nl_int' requires different context
+context-on-vars.c:33:18:    context 'L': wanted >= 1, got 0
+context-on-vars.c:38:25: warning: context problem in 'warn_access5': access to 'nl_int' requires different context
+context-on-vars.c:38:25:    context 'L': wanted >= 1, got 0
+context-on-vars.c:43:10: warning: context problem in 'warn_access6': access to 'nl_int' requires different context
+context-on-vars.c:43:10:    context 'L': wanted >= 1, got 0
+context-on-vars.c:50:9: warning: context problem in 'warn_access7': access to 'nl_int' requires different context
+context-on-vars.c:50:9:    context 'L': wanted >= 1, got 0
+context-on-vars.c:62:12: warning: context problem in 'warn_access9': access to 'nl_int' requires different context
+context-on-vars.c:62:12:    context 'L': wanted >= 1, got 0
+context-on-vars.c:67:16: warning: context problem in 'warn_access10': access to 'nl_array' requires different context
+context-on-vars.c:67:16:    context 'L': wanted >= 1, got 0
+context-on-vars.c:106:5: warning: context problem in 'warn_access11': access to 's' requires different context
+context-on-vars.c:106:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:119:13: warning: context problem in 'warn_access12': access to 'lx' requires different context
+context-on-vars.c:119:13:    context 'L': wanted >= 1, got 0
+context-on-vars.c:124:5: warning: context problem in 'warn_access13': access to 'b' requires different context
+context-on-vars.c:124:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:154:5: warning: context problem in 'warn_exact1': access to 'b' requires different context
+context-on-vars.c:154:5:    context 'L': wanted 1, got 2
+context-on-vars.c:176:3: warning: context problem in 'warn_access14': access to 'x' requires different context
+context-on-vars.c:176:3:    context 'L': wanted >= 1, got 0
+context-on-vars.c:181:7: warning: context problem in 'warn_access15': access to 'y' requires different context
+context-on-vars.c:181:7:    context 'L': wanted >= 1, got 0
+ * check-error-end
+ */
diff --git a/validation/context-statement.c b/validation/context-statement.c
index fd79a6a..71d4cae 100644
--- a/validation/context-statement.c
+++ b/validation/context-statement.c
@@ -59,11 +59,11 @@ static void bad_macro3(void)
  * check-error-start
 context-statement.c:16:8: warning: context imbalance in 'bad_arr': unexpected unlock
 context-statement.c:16:8:    context 'LOCK': wanted 0, got -1
-context-statement.c:38:5: warning: context imbalance in 'bad_macro1': __context__ statement expected different context
+context-statement.c:38:5: warning: context problem in 'bad_macro1': __context__ statement expected different context
 context-statement.c:38:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:47:5: warning: context imbalance in 'bad_macro2': __context__ statement expected different context
+context-statement.c:47:5: warning: context problem in 'bad_macro2': __context__ statement expected different context
 context-statement.c:47:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:53:5: warning: context imbalance in 'bad_macro3': __context__ statement expected different context
+context-statement.c:53:5: warning: context problem in 'bad_macro3': __context__ statement expected different context
 context-statement.c:53:5:    context 'LOCK': wanted >= 0, got -1
  * check-error-end
  */

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 11/16] Evaluate/expand context expressions ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 11/16] Evaluate/expand context expressions
Date: Thu, 18 Dec 2008 22:34:05 +0000
Message-ID: <20081218223355.23692.35.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

But still allow having a standalone symbol as the context
expression, also evaluate the context change/requirement
directly in the parser and pass them up as integers. Also
fixes a number of bugs e.g. in the expression copier and
a segfault when the default context is used as such:
   __context__(1,1);

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 evaluate.c           |    9 ++++++++-
 expand.c             |    2 +-
 inline.c             |   19 ++++++++++++-------
 linearize.c          |   17 +++--------------
 parse.c              |   22 +++++++++++++---------
 parse.h              |    6 ++++--
 validation/context.c |   28 ++++++++++++++++++++++++++++
 7 files changed, 69 insertions(+), 34 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index f976645..0c86295 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3364,7 +3364,14 @@ struct symbol *evaluate_statement(struct statement *stmt)
 		evaluate_asm_statement(stmt);
 		return NULL;
 	case STMT_CONTEXT:
-		evaluate_expression(stmt->expression);
+		/*
+		 * If this is an unknown symbol accept it as-is
+		 * as a context name.
+		 */
+		if (stmt->context &&
+		    (stmt->context->type != EXPR_SYMBOL ||
+		     stmt->context->symbol))
+			evaluate_expression(stmt->context);
 		return NULL;
 	case STMT_RANGE:
 		evaluate_expression(stmt->range_expression);
diff --git a/expand.c b/expand.c
index 3e962d1..dece314 100644
--- a/expand.c
+++ b/expand.c
@@ -1169,7 +1169,7 @@ static int expand_statement(struct statement *stmt)
 		/* FIXME! Do the asm parameter evaluation! */
 		break;
 	case STMT_CONTEXT:
-		expand_expression(stmt->expression);
+		expand_expression(stmt->context);
 		break;
 	case STMT_RANGE:
 		expand_expression(stmt->range_expression);
diff --git a/inline.c b/inline.c
index 09d176a..3e984c3 100644
--- a/inline.c
+++ b/inline.c
@@ -328,7 +328,18 @@ static struct statement *copy_one_statement(struct statement *stmt)
 		stmt = newstmt;
 		break;
 	}
-	case STMT_CONTEXT:
+	case STMT_CONTEXT: {
+		struct expression *expr = copy_expression(stmt->context);
+		struct statement *newstmt;
+		if (expr == stmt->context)
+			break;
+		newstmt = dup_statement(stmt);
+		newstmt->context = expr;
+		newstmt->change = stmt->change;
+		newstmt->required = stmt->required;
+		stmt = newstmt;
+		break;
+	}
 	case STMT_EXPRESSION: {
 		struct expression *expr = copy_expression(stmt->expression);
 		struct statement *newstmt;
@@ -336,12 +347,6 @@ static struct statement *copy_one_statement(struct statement *stmt)
 			break;
 		newstmt = dup_statement(stmt);
 		newstmt->expression = expr;
-		if (stmt->required) {
-			expr = copy_expression(stmt->required);
-			if (expr == stmt->required)
-				break;
-			newstmt->required = expr;
-		}
 		stmt = newstmt;
 		break;
 	}
diff --git a/linearize.c b/linearize.c
index 9f5628a..8e9775d 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1755,22 +1755,11 @@ static pseudo_t linearize_inlined_call(struct entrypoint *ep, struct statement *
 static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 {
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
-	struct expression *expr = stmt->expression;
-	int value = 0;
 
-	if (expr->type == EXPR_VALUE)
-		value = expr->value;
+	insn->increment = stmt->change;
+	insn->inc_false = stmt->change;
 
-	insn->increment = value;
-	insn->inc_false = value;
-
-	expr = stmt->required;
-	value = 0;
-
-	if (expr && expr->type == EXPR_VALUE)
-		value = expr->value;
-
-	insn->required = value;
+	insn->required = stmt->required;
 	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
diff --git a/parse.c b/parse.c
index 2ac3d0e..fdb7efb 100644
--- a/parse.c
+++ b/parse.c
@@ -1860,9 +1860,7 @@ static struct token *_parse_context_statement(struct token *token, struct statem
 		token = token->next;
 	}
 
-	stmt->expression = args[0];
 	stmt->context = NULL;
-
 	stmt->exact = exact;
 
 	switch (argc) {
@@ -1870,21 +1868,27 @@ static struct token *_parse_context_statement(struct token *token, struct statem
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
 		return token;
 	case 1:
-		/* already done */
+		stmt->change = get_expression_value(args[0]);
 		break;
 	case 2:
-		if (args[0]->type != STMT_EXPRESSION) {
+		/*
+		 * We should actually check whether we can evalulate
+		 * it as a constant expression and if so use as the
+		 * 'change' value. I hope nobody gives a calculation
+		 * for the number.
+		 */
+		if (args[0]->type != EXPR_VALUE) {
 			stmt->context = args[0];
-			stmt->expression = args[1];
+			stmt->change = get_expression_value(args[1]);
 		} else {
-			stmt->expression = args[0];
-			stmt->required = args[1];
+			stmt->change = get_expression_value(args[0]);
+			stmt->required = get_expression_value(args[1]);
 		}
 		break;
 	case 3:
 		stmt->context = args[0];
-		stmt->expression = args[1];
-		stmt->required = args[2];
+		stmt->change = get_expression_value(args[1]);
+		stmt->required = get_expression_value(args[2]);
 		break;
 	default:
 		sparse_error(token->pos, "too many arguments for __context__ statement");
diff --git a/parse.h b/parse.h
index ae50720..fe714b6 100644
--- a/parse.h
+++ b/parse.h
@@ -39,10 +39,12 @@ struct statement {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
-		struct { /* __context__ */
+		struct { /* expression */
 			struct expression *expression;
+		};
+		struct { /* __context__ */
 			struct expression *context;
-			struct expression *required;
+			int change, required;
 			int exact;
 		};
 		struct /* return_statement */ {
diff --git a/validation/context.c b/validation/context.c
index e8bb125..2c32ef3 100644
--- a/validation/context.c
+++ b/validation/context.c
@@ -395,6 +395,32 @@ static void good_require_caller(void)
     __context__(TEST,-1,1);
 }
 
+static void areq(void) __attribute__((context(1,2)))
+{
+	__context__(1,1);
+}
+
+static void good_reqlock(void)
+{
+	a();
+	areq();
+	r();
+	r();
+}
+
+static void warn_reqlock(void)
+{
+	areq();
+	r();
+}
+
+
+static void dummy1(void) __attribute__((context(p,0,1)))
+{
+        void *p;
+	__context__(p,1);
+}
+
 /*
  * check-name: Check -Wcontext
  *
@@ -433,5 +459,7 @@ context.c:360:10: warning: context problem in 'warn_huge_switch': 'r' expected d
 context.c:360:10:    default context: wanted >= 1, got 0
 context.c:380:12: warning: context imbalance in 'warn_conditional': wrong count at exit
 context.c:380:12:    default context: wanted 0, got 1
+context.c:413:6: warning: context problem in 'warn_reqlock': 'areq' expected different context
+context.c:413:6:    default context: wanted >= 1, got 0
  * check-error-end
  */

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 12/16] Revert the conditional_context patch ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 12/16] Revert the conditional_context patch
Date: Thu, 18 Dec 2008 22:34:26 +0000
Message-ID: <20081218223414.23692.94766.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

This patch removes the conditional_context attribute again, it turned
out that my attempt to do this was rather misguided and contrary to
what I thought we do not gain anything at all over using macros for
it as the kernel and the tests have been doing for a while.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 linearize.c                  |   32 +++++---
 linearize.h                  |    2 
 parse.c                      |   52 -------------
 sparse.1                     |    9 --
 sparse.c                     |   39 ++++------
 symbol.h                     |    2 
 validation/context-dynamic.c |  171 ------------------------------------------
 7 files changed, 37 insertions(+), 270 deletions(-)
 delete mode 100644 validation/context-dynamic.c

diff --git a/linearize.c b/linearize.c
index 8e9775d..34922e9 100644
--- a/linearize.c
+++ b/linearize.c
@@ -439,7 +439,7 @@ const char *show_instruction(struct instruction *insn)
 		break;
 
 	case OP_CONTEXT:
-		buf += sprintf(buf, "%s%d,%d", "", insn->increment, insn->inc_false);
+		buf += sprintf(buf, "%d", insn->increment);
 		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
@@ -960,7 +960,7 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->source_type;
 		insn->exact = context->exact;
@@ -973,7 +973,7 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->result_type;
 		insn->exact = context->exact;
@@ -988,7 +988,7 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 				continue;
 			insn = alloc_instruction(OP_CONTEXT, 0);
 			insn->required = context->in;
-			insn->increment = insn->inc_false = context->out - context->in;
+			insn->increment = context->out - context->in;
 			insn->context_expr = context->context;
 			insn->access_var = ad->address->sym;
 			insn->exact = context->exact;
@@ -1049,7 +1049,7 @@ static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->source_type;
 		insn->exact = context->exact;
@@ -1062,7 +1062,7 @@ static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->result_type;
 		insn->exact = context->exact;
@@ -1077,7 +1077,7 @@ static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad
 				continue;
 			insn = alloc_instruction(OP_CONTEXT, 0);
 			insn->required = context->in;
-			insn->increment = insn->inc_false = context->out - context->in;
+			insn->increment = context->out - context->in;
 			insn->context_expr = context->context;
 			insn->access_var = ad->address->sym;
 			insn->exact = context->exact;
@@ -1322,12 +1322,21 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 		FOR_EACH_PTR(ctype->contexts, context) {
 			int in = context->in;
 			int out = context->out;
-
-			if (out - in || context->out_false - in) {
+			int check = 0;
+			int context_diff;
+			if (in < 0) {
+				check = 1;
+				in = 0;
+			}
+			if (out < 0) {
+				check = 0;
+				out = 0;
+			}
+			context_diff = out - in;
+			if (check || context_diff) {
 				insn = alloc_instruction(OP_CONTEXT, 0);
-				insn->increment = out - in;
+				insn->increment = context_diff;
 				insn->context_expr = context->context;
-				insn->inc_false = context->out_false - in;
 				add_one_insn(ep, insn);
 			}
 		} END_FOR_EACH_PTR(context);
@@ -1757,7 +1766,6 @@ static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
 
 	insn->increment = stmt->change;
-	insn->inc_false = stmt->change;
 
 	insn->required = stmt->required;
 	insn->exact = stmt->exact;
diff --git a/linearize.h b/linearize.h
index 4e9100d..3bd5098 100644
--- a/linearize.h
+++ b/linearize.h
@@ -117,7 +117,7 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false, exact;
+			int increment, required, exact;
 			struct expression *context_expr;
 			struct symbol *access_var;
 		};
diff --git a/parse.c b/parse.c
index fdb7efb..5e3354c 100644
--- a/parse.c
+++ b/parse.c
@@ -65,7 +65,6 @@ static struct token *attribute_address_space(struct token *token, struct symbol
 static struct token *attribute_aligned(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_mode(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_exact_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
@@ -189,10 +188,6 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
-static struct symbol_op conditional_context_op = {
-	.attribute = attribute_conditional_context,
-};
-
 static struct symbol_op exact_context_op = {
 	.attribute = attribute_exact_context,
 };
@@ -279,7 +274,6 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
-	{ "conditional_context",	NS_KEYWORD,	.op = &conditional_context_op },
 	{ "exact_context",	NS_KEYWORD,	.op = &exact_context_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
@@ -945,7 +939,6 @@ static struct token *_attribute_context(struct token *token, struct symbol *attr
 	}
 
 	context->exact = exact;
-	context->out_false = context->out;
 
 	if (argc)
 		add_ptr_list(&ctype->contexts, context);
@@ -964,51 +957,6 @@ static struct token *attribute_exact_context(struct token *token, struct symbol
 	return _attribute_context(token, attr, ctype, 1);
 }
 
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype)
-{
-	struct context *context = alloc_context();
-	struct expression *args[4];
-	int argc = 0;
-
-	token = expect(token, '(', "after conditional_context attribute");
-	while (!match_op(token, ')')) {
-		struct expression *expr = NULL;
-		token = conditional_expression(token, &expr);
-		if (!expr)
-			break;
-		if (argc < 4)
-			args[argc++] = expr;
-		else
-			argc++;
-		if (!match_op(token, ','))
-			break;
-		token = token->next;
-	}
-
-	switch(argc) {
-	case 3:
-		context->in = get_expression_value(args[0]);
-		context->out = get_expression_value(args[1]);
-		context->out_false = get_expression_value(args[2]);
-		break;
-	case 4:
-		context->context = args[0];
-		context->in = get_expression_value(args[1]);
-		context->out = get_expression_value(args[2]);
-		context->out_false = get_expression_value(args[3]);
-		break;
-	default:
-		sparse_error(token->pos, "invalid number of arguments to conditional_context attribute");
-		break;
-	}
-
-	if (argc)
-		add_ptr_list(&ctype->contexts, context);
-
-	token = expect(token, ')', "after conditional_context attribute");
-	return token;
-}
-
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	if (Wtransparent_union)
diff --git a/sparse.1 b/sparse.1
index 61c40b8..ebe62f0 100644
--- a/sparse.1
+++ b/sparse.1
@@ -101,15 +101,6 @@ be required on both reads and writes) by using either the token "read" or
 the token "write" for an optional fourth argument:
 .BI __attribute__((context( expression , in_context , out_context , read|write )).
 
-To indicate that a certain function acquires a context depending on its
-return value, use
-.BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
-where \fIout_success\fR and \fIout_failure\fR indicate the context change
-done depending on success (non-zero) or failure (zero) return of the
-function. Note that currently, using this attribute on a function means that
-the function itself won't be checked for context handling at all. See the
-testsuite for examples.
-
 Sparse will warn when it sees a function change a
 context without indicating this with a \fBcontext\fR or \fBexact_context\fR attribute, either by
 decreasing a context below zero (such as by releasing a lock without acquiring
diff --git a/sparse.c b/sparse.c
index 1149244..76b1db2 100644
--- a/sparse.c
+++ b/sparse.c
@@ -25,7 +25,7 @@
 #include "linearize.h"
 
 struct context_check {
-	int val, val_false;
+	int val;
 	char name[32];
 };
 
@@ -44,7 +44,7 @@ static const char *context_name(struct context *context)
 }
 
 static void context_add(struct context_check_list **ccl, const char *name,
-			int offs, int offs_false)
+			int offs)
 {
 	struct context_check *check, *found = NULL;
 
@@ -62,7 +62,6 @@ static void context_add(struct context_check_list **ccl, const char *name,
 		add_ptr_list(ccl, found);
 	}
 	found->val += offs;
-	found->val_false += offs_false;
 }
 
 static int context_list_has(struct context_check_list *ccl,
@@ -73,12 +72,11 @@ static int context_list_has(struct context_check_list *ccl,
 	FOR_EACH_PTR(ccl, check) {
 		if (strcmp(c->name, check->name))
 			continue;
-		return check->val == c->val &&
-		       check->val_false == c->val_false;
+		return check->val == c->val;
 	} END_FOR_EACH_PTR(check);
 
 	/* not found is equal to 0 */
-	return c->val == 0 && c->val_false == 0;
+	return c->val == 0;
 }
 
 static int context_lists_equal(struct context_check_list *ccl1,
@@ -107,7 +105,7 @@ static struct context_check_list *checked_copy(struct context_check_list *ccl)
 	struct context_check *c;
 
 	FOR_EACH_PTR(ccl, c) {
-		context_add(&result, c->name, c->val_false, c->val_false);
+		context_add(&result, c->name, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	return result;
@@ -140,7 +138,7 @@ static int context_list_check(struct entrypoint *ep, struct position pos,
 
 	/* make sure the loop below checks all */
 	FOR_EACH_PTR(ccl_target, c1) {
-		context_add(&ccl_cur, c1->name, 0, 0);
+		context_add(&ccl_cur, c1->name, 0);
 	} END_FOR_EACH_PTR(c1);
 
 	FOR_EACH_PTR(ccl_cur, c1) {
@@ -289,15 +287,14 @@ static int handle_context(struct entrypoint *ep, struct basic_block *bb,
 		return -1;
 	}
 
-	context_add(combined, name, insn->increment, insn->inc_false);
+	context_add(combined, name, insn->increment);
 
 	return 0;
 }
 
 static int check_bb_context(struct entrypoint *ep, struct basic_block *bb,
 			    struct context_check_list *ccl_in,
-			    struct context_check_list *ccl_target,
-			    int in_false)
+			    struct context_check_list *ccl_target)
 {
 	struct context_check_list *combined = NULL, *done;
 	struct context_check *c;
@@ -327,10 +324,7 @@ static int check_bb_context(struct entrypoint *ep, struct basic_block *bb,
 	 * for the conditional_context() attribute.
 	 */
 	FOR_EACH_PTR(ccl_in, c) {
-		if (in_false)
-			context_add(&combined, c->name, c->val_false, c->val_false);
-		else
-			context_add(&combined, c->name, c->val, c->val);
+		context_add(&combined, c->name, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	/* Add the new context to the list of already-checked contexts */
@@ -356,18 +350,18 @@ static int check_bb_context(struct entrypoint *ep, struct basic_block *bb,
 		case OP_BR:
 			if (insn->bb_true)
 				if (check_bb_context(ep, insn->bb_true,
-						     combined, ccl_target, 0))
+						     combined, ccl_target))
 					goto out;
 			if (insn->bb_false)
 				if (check_bb_context(ep, insn->bb_false,
-						     combined, ccl_target, 1))
+						     combined, ccl_target))
 					goto out;
 			break;
 		case OP_SWITCH:
 		case OP_COMPUTEDGOTO:
 			FOR_EACH_PTR(insn->multijmp_list, mj) {
 				if (check_bb_context(ep, mj->target,
-					             combined, ccl_target, 0))
+					             combined, ccl_target))
 					goto out;
 			} END_FOR_EACH_PTR(mj);
 			break;
@@ -579,14 +573,11 @@ static void check_context(struct entrypoint *ep)
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
 		const char *name = context_name(context);
 
-		context_add(&ccl_in, name, context->in, context->in);
-		context_add(&ccl_target, name, context->out, context->out_false);
-		/* we don't currently check the body of trylock functions */
-		if (context->out != context->out_false)
-			return;
+		context_add(&ccl_in, name, context->in);
+		context_add(&ccl_target, name, context->out);
 	} END_FOR_EACH_PTR(context);
 
-	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target, 0);
+	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target);
 	free_ptr_list(&ccl_in);
 	free_ptr_list(&ccl_target);
 	free_bb_context_lists(ep->entry->bb);
diff --git a/symbol.h b/symbol.h
index f79674f..4e605c2 100644
--- a/symbol.h
+++ b/symbol.h
@@ -77,7 +77,7 @@ enum context_read_write_specifier {
 
 struct context {
 	struct expression *context;
-	unsigned int in, out, out_false;
+	unsigned int in, out;
 	int exact;
 	enum context_read_write_specifier rws;
 };
diff --git a/validation/context-dynamic.c b/validation/context-dynamic.c
deleted file mode 100644
index 5e172f0..0000000
--- a/validation/context-dynamic.c
+++ /dev/null
@@ -1,171 +0,0 @@
-static void a(void) __attribute__ ((context(A, 0, 1)))
-{
-    __context__(A, 1);
-}
-
-static void r(void) __attribute__ ((context(A, 1, 0)))
-{
-    __context__(A, -1);
-}
-
-extern int condition, condition2;
-
-static int tl(void) __attribute__ ((conditional_context(A, 0, 1, 0)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int tl2(void) __attribute__ ((conditional_context(A, 0, 0, 1)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int dummy(void)
-{
-    return condition + condition2;
-}
-
-static int good_trylock1(void)
-{
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock2(void)
-{
-    if (tl()) {
-        r();
-    }
-
-    if (tl()) {
-        r();
-    }
-}
-static int good_trylock3(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    r();
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock4(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    if (tl()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock1(void)
-{
-    a();
-    if (dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_trylock5(void)
-{
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock6(void)
-{
-    if (!tl2()) {
-        r();
-    }
-
-    if (!tl2()) {
-        r();
-    }
-}
-static int good_trylock7(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    r();
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock8(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    if (!tl2()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock2(void)
-{
-    a();
-    if (!dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_switch(void)
-{
-    switch (condition) {
-    case 1:
-        a();
-        break;
-    case 2:
-        a();
-        break;
-    case 3:
-        a();
-        break;
-    default:
-        a();
-    }
-    r();
-}
-
-static void bad_lock1(void)
-{
-    r();
-    a();
-}
-
-/*
- * check-name: Check -Wcontext with lock trylocks
- *
- * check-error-start
-context-dynamic.c:83:6: warning: context problem in 'bad_trylock1': 'r' expected different context
-context-dynamic.c:83:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:133:6: warning: context problem in 'bad_trylock2': 'r' expected different context
-context-dynamic.c:133:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:156:6: warning: context problem in 'bad_lock1': 'r' expected different context
-context-dynamic.c:156:6:    context 'A': wanted >= 1, got 0
- * check-error-end
- */

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 14/16] Test conditional result locking ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 14/16] Test conditional result locking
Date: Thu, 18 Dec 2008 22:35:05 +0000
Message-ID: <20081218223455.23692.82825.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

To test a function that can return a locked struct or NULL,
a macro has to be invented. Add a test case for that.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 validation/context-vars.c |   29 +++++++++++++++++++++++++----
 1 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/validation/context-vars.c b/validation/context-vars.c
index a44bfd8..a0c966f 100644
--- a/validation/context-vars.c
+++ b/validation/context-vars.c
@@ -1,3 +1,5 @@
+#include <stddef.h>
+
 static void a(void *p) __attribute__((context(p,0,1)))
 {
     __context__(p,1);
@@ -159,13 +161,32 @@ static void good_locked_val(void)
     ;
 }
 
+
+extern struct test *_search(int key);
+
+#define search(res, key) do {	\
+  (res) = _search((key));	\
+  if (res)			\
+      __context__(&(res)->lock,1);\
+  } while (0)
+
+static void test(void)
+{
+    struct test **x;
+
+    search(*x, 32);
+    if (*x)
+      unlock(*x);
+}
+
+
 /*
  * check-name: Check -Wcontext with lock variables
  *
  * check-error-start
-context-vars.c:53:7: warning: context imbalance in 'warn_lock1': wrong count at exit
-context-vars.c:53:7:    context '**v+4': wanted 0, got 1
-context-vars.c:137:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
-context-vars.c:137:11:    context '*t+0': wanted >= 1, got 0
+context-vars.c:55:7: warning: context imbalance in 'warn_lock1': wrong count at exit
+context-vars.c:55:7:    context '**v+4': wanted 0, got 1
+context-vars.c:139:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
+context-vars.c:139:11:    context '*t+0': wanted >= 1, got 0
  * check-error-end
  */

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 15/15] Warning should be enough for an unhandled transparent ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 15/15] Warning should be enough for an unhandled transparent
Date: Mon, 15 Dec 2008 00:27:55 +0000
Message-ID: <20081215002755.16107.5254.stgit () zaytsev ! su>
--------------------
An error would be issued if such union is actually used.

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 parse.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/parse.c b/parse.c
index 877414c..915ae20 100644
--- a/parse.c
+++ b/parse.c
@@ -987,7 +987,7 @@ static struct token *attribute_conditional_context(struct token *token, struct s
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	if (Wtransparent_union)
-		sparse_error(token->pos, "ignoring attribute __transparent_union__");
+		warning(token->pos, "ignoring attribute __transparent_union__");
 	return token;
 }
 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 15/16] Show required context in instruction output ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 15/16] Show required context in instruction output
Date: Thu, 18 Dec 2008 22:35:29 +0000
Message-ID: <20081218223514.23692.77595.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

Just eases debugging sparse/the context tracking itself.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 expression.c |    2 ++
 linearize.c  |    2 +-
 2 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/expression.c b/expression.c
index 198816b..8c4451d 100644
--- a/expression.c
+++ b/expression.c
@@ -648,6 +648,8 @@ static struct token *postfix_expression(struct token *token, struct expression *
 					copy->in = c->in;
 					copy->out = c->out;
 					copy->exact = c->exact;
+					copy->token = c->token;
+					copy->in_fn = c->context;
 					add_ptr_list(&call->contexts, copy);
 
 					if (!c->token)
diff --git a/linearize.c b/linearize.c
index 808b1bc..c9fe922 100644
--- a/linearize.c
+++ b/linearize.c
@@ -445,7 +445,7 @@ const char *show_instruction(struct instruction *insn)
 			expression_str(insn->context_expr, ctxbuf, sizeof(ctxbuf));
 			buf += sprintf(buf, "%s, ", ctxbuf);
 		}
-		buf += sprintf(buf, "%d", insn->increment);
+		buf += sprintf(buf, "%d %d", insn->increment, insn->required);
 		break;
 	}
 	case OP_RANGE:

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 16/16] Check inlines explicitly ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 16/16] Check inlines explicitly
Date: Thu, 18 Dec 2008 22:35:45 +0000
Message-ID: <20081218223538.23692.93413.stgit () zaytsev ! su>
--------------------
From: Johannes Berg <johannes@sipsolutions.net>

An earlier patch disabled checking through inline functions because
inlining them clashes with the context tracking code, so this now
makes sparse check the inline functions as though they were really
functions.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 sparse.c |   24 ++++++++++++++++++++++--
 1 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/sparse.c b/sparse.c
index 9f4ec03..0bf85fc 100644
--- a/sparse.c
+++ b/sparse.c
@@ -29,11 +29,12 @@ struct context_check {
 	const struct expression *expr;
 };
 
-DECLARE_ALLOCATOR(context_check);
 DECLARE_PTR_LIST(context_check_list, struct context_check);
 DECLARE_PTR_LIST(context_list_list, struct context_check_list);
 ALLOCATOR(context_check, "context check list");
 
+static struct symbol_list *inline_list = NULL;
+
 
 static void context_add(struct context_check_list **ccl,
 			const struct expression *expr,
@@ -277,6 +278,15 @@ static int check_bb_context(struct entrypoint *ep, struct basic_block *bb,
 	 */
 	FOR_EACH_PTR(bb->insns, insn) {
 		switch (insn->opcode) {
+		case OP_INLINED_CALL: {
+			if (!insn->func->sym)
+				break;
+			if (insn->func->sym->visited)
+				break;
+			insn->func->sym->visited = 1;
+			add_ptr_list(&inline_list, insn->func->sym);
+			break;
+		}
 		case OP_CONTEXT:
 			if (handle_context(ep, bb, insn, &combined))
 				goto out;
@@ -526,7 +536,14 @@ static void check_symbols(struct symbol_list *list)
 		struct entrypoint *ep;
 
 		expand_symbol(sym);
-		ep = linearize_symbol(sym);
+		/*
+		 * If we're passing back an inline via the special code
+		 * that tests those, it might already be linearized, if
+		 * so just check it and don't linearize again.
+		 */
+		ep = sym->ep;
+		if (!ep)
+			ep = linearize_symbol(sym);
 		if (ep) {
 			if (dbg_entry)
 				show_entry(ep);
@@ -545,6 +562,9 @@ int main(int argc, char **argv)
 	check_symbols(sparse_initialize(argc, argv, &filelist));
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		check_symbols(sparse(file));
+		evaluate_symbol_list(inline_list);
+		check_symbols(inline_list);
+		free_ptr_list(&inline_list);
 	} END_FOR_EACH_PTR_NOTAG(file);
 	return 0;
 }

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/15 v2] Unhardcode byte size being 8 bits. ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/15 v2] Unhardcode byte size being 8 bits.
Date: Wed, 17 Dec 2008 19:57:00 +0000
Message-ID: <20081217190534.24084.94887.stgit () zaytsev ! su>
--------------------
From: David Given <dg@cowlark.com>

---

Hello.

It turns out, there was a bug in this irivial patch, which
lead to discovery of an other bug in sparse.

First, i >> 3 != i / 8 when i < 0, and sym->bit_size
may actually quite often be -1:

symbol.c:878         unsigned long bit_size = ctype->bit_size ? *ctype->bit_size : -1;
		[...]
symbol.c:885         sym->bit_size = bit_size;

This problem may be addressed by changing bits_to_bytes to
static inline int bits_to_bytes(int bits)
{
       return bits >= 0 ? bits / bits_in_char : -1;
}

Which I think is ok if it helps Davind with his work,
and I doubt anybody could measure any slowdown here.

But it seems there is also a bug in sparse, as in
ctype_declaration[] the bit_size of void_ctype is
set to NULL, while gcc assumes sizeof(void) being 1.
Currently sparse would generate wrong code for:

void *test(void *p) {
        p++;
        return p;
}

unsigned long test1(void *p)
{
        return sizeof(*p);
}

.L0x2b48867c1010:
        <entry-point>
        add.32      %r2 <- %arg1, $-1
        ret.32      %r2

test1:
.L0x2b48867c10b0:
        <entry-point>
        ret.32      $-1

And with bit_size set to &bits_in_char, the code looks
as expected. But I don't really understand this
ctype-symbol stuff, so the fix needs more review.

Anyway, here is the updated byte size patch.
David, we still need your sign-off here.

 compile-i386.c |    2 +-
 evaluate.c     |   26 +++++++++++++-------------
 example.c      |    2 +-
 expand.c       |    2 +-
 flow.c         |   10 ++++++----
 show-parse.c   |    2 +-
 symbol.c       |   10 +++++-----
 target.h       |   14 ++++++++++++++
 8 files changed, 42 insertions(+), 26 deletions(-)

diff --git a/compile-i386.c b/compile-i386.c
index 8526408..37ea52e 100644
--- a/compile-i386.c
+++ b/compile-i386.c
@@ -2081,7 +2081,7 @@ static struct storage *x86_call_expression(struct expression *expr)
 		insn("pushl", new, NULL,
 		     !framesize ? "begin function call" : NULL);
 
-		framesize += size >> 3;
+		framesize += bits_to_bytes(size);
 	} END_FOR_EACH_PTR_REVERSE(arg);
 
 	fn = expr->fn;
diff --git a/evaluate.c b/evaluate.c
index e17da53..c501323 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -72,7 +72,7 @@ static struct symbol *evaluate_string(struct expression *expr)
 	unsigned int length = expr->string->length;
 
 	sym->array_size = alloc_const_expression(expr->pos, length);
-	sym->bit_size = bits_in_char * length;
+	sym->bit_size = bytes_to_bits(length);
 	sym->ctype.alignment = 1;
 	sym->string = 1;
 	sym->ctype.modifiers = MOD_STATIC;
@@ -83,7 +83,7 @@ static struct symbol *evaluate_string(struct expression *expr)
 	initstr->string = expr->string;
 
 	array->array_size = sym->array_size;
-	array->bit_size = bits_in_char * length;
+	array->bit_size = bytes_to_bits(length);
 	array->ctype.alignment = 1;
 	array->ctype.modifiers = MOD_STATIC;
 	array->ctype.base_type = &char_ctype;
@@ -579,7 +579,7 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
 	}
 
 	/* Get the size of whatever the pointer points to */
-	multiply = base->bit_size >> 3;
+	multiply = bits_to_bytes(base->bit_size);
 
 	if (ctype == &null_ctype)
 		ctype = &ptr_ctype;
@@ -831,7 +831,7 @@ static struct symbol *evaluate_ptr_sub(struct expression *expr)
 		struct expression *sub = alloc_expression(expr->pos, EXPR_BINOP);
 		struct expression *div = expr;
 		struct expression *val = alloc_expression(expr->pos, EXPR_VALUE);
-		unsigned long value = lbase->bit_size >> 3;
+		unsigned long value = bits_to_bytes(lbase->bit_size);
 
 		val->ctype = size_t_ctype;
 		val->value = value;
@@ -1591,7 +1591,7 @@ static struct symbol *degenerate(struct expression *expr)
 				e3->op = '+';
 				e3->left = e0;
 				e3->right = alloc_const_expression(expr->pos,
-							expr->r_bitpos >> 3);
+							bits_to_bytes(expr->r_bitpos));
 				e3->ctype = &lazy_ptr_ctype;
 			} else {
 				e3 = e0;
@@ -1727,7 +1727,7 @@ static struct symbol *evaluate_postop(struct expression *expr)
 	} else if (class == TYPE_PTR) {
 		struct symbol *target = examine_pointer_target(ctype);
 		if (!is_function(target))
-			multiply = target->bit_size >> 3;
+			multiply = bits_to_bytes(target->bit_size);
 	}
 
 	if (multiply) {
@@ -1949,7 +1949,7 @@ static struct symbol *evaluate_member_dereference(struct expression *expr)
 			expr->base = deref->base;
 			expr->r_bitpos = deref->r_bitpos;
 		}
-		expr->r_bitpos += offset << 3;
+		expr->r_bitpos += bytes_to_bits(offset);
 		expr->type = EXPR_SLICE;
 		expr->r_nrbits = member->bit_size;
 		expr->r_bitpos += member->bit_offset;
@@ -2037,10 +2037,10 @@ static struct symbol *evaluate_sizeof(struct expression *expr)
 		return NULL;
 
 	size = type->bit_size;
-	if ((size < 0) || (size & 7))
+	if ((size < 0) || (size & (bits_in_char - 1)))
 		expression_error(expr, "cannot size expression");
 	expr->type = EXPR_VALUE;
-	expr->value = size >> 3;
+	expr->value = bits_to_bytes(size);
 	expr->taint = 0;
 	expr->ctype = size_t_ctype;
 	return size_t_ctype;
@@ -2071,10 +2071,10 @@ static struct symbol *evaluate_ptrsizeof(struct expression *expr)
 		return NULL;
 	}
 	size = type->bit_size;
-	if (size & 7)
+	if (size & (bits_in_char-1))
 		size = 0;
 	expr->type = EXPR_VALUE;
-	expr->value = size >> 3;
+	expr->value = bits_to_bytes(size);
 	expr->taint = 0;
 	expr->ctype = size_t_ctype;
 	return size_t_ctype;
@@ -2158,7 +2158,7 @@ static void convert_index(struct expression *e)
 	unsigned from = e->idx_from;
 	unsigned to = e->idx_to + 1;
 	e->type = EXPR_POS;
-	e->init_offset = from * (e->ctype->bit_size>>3);
+	e->init_offset = from * bits_to_bytes(e->ctype->bit_size);
 	e->init_nr = to - from;
 	e->init_expr = child;
 }
@@ -2865,7 +2865,7 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 			unrestrict(idx, i_class, &i_type);
 			idx = cast_to(idx, size_t_ctype);
 			m = alloc_const_expression(expr->pos,
-						   ctype->bit_size >> 3);
+						   bits_to_bytes(ctype->bit_size));
 			m->ctype = size_t_ctype;
 			m->flags = Int_const_expr;
 			expr->type = EXPR_BINOP;
diff --git a/example.c b/example.c
index ae897dc..24444c6 100644
--- a/example.c
+++ b/example.c
@@ -1830,7 +1830,7 @@ static void set_up_arch_entry(struct entrypoint *ep, struct instruction *entry)
 			in->type = REG_FRAME;
 			in->offset = offset;
 			
-			offset += bits >> 3;
+			offset += bits_to_bytes(bits);
 		}
 		i++;
 		NEXT_PTR_LIST(argtype);
diff --git a/expand.c b/expand.c
index 032f0c5..3e962d1 100644
--- a/expand.c
+++ b/expand.c
@@ -880,7 +880,7 @@ static unsigned long bit_offset(const struct expression *expr)
 {
 	unsigned long offset = 0;
 	while (expr->type == EXPR_POS) {
-		offset += expr->init_offset << 3;
+		offset += bytes_to_bits(expr->init_offset);
 		expr = expr->init_expr;
 	}
 	if (expr && expr->ctype)
diff --git a/flow.c b/flow.c
index 82fb23a..5bd9a1d 100644
--- a/flow.c
+++ b/flow.c
@@ -16,6 +16,7 @@
 #include "expression.h"
 #include "linearize.h"
 #include "flow.h"
+#include "target.h"
 
 unsigned long bb_generation;
 
@@ -265,8 +266,8 @@ void convert_load_instruction(struct instruction *insn, pseudo_t src)
 
 static int overlapping_memop(struct instruction *a, struct instruction *b)
 {
-	unsigned int a_start = a->offset << 3;
-	unsigned int b_start = b->offset << 3;
+	unsigned int a_start = bytes_to_bits(a->offset);
+	unsigned int b_start = bytes_to_bits(b->offset);
 	unsigned int a_size = a->size;
 	unsigned int b_size = b->size;
 
@@ -581,13 +582,14 @@ void check_access(struct instruction *insn)
 	pseudo_t pseudo = insn->src;
 
 	if (insn->bb && pseudo->type == PSEUDO_SYM) {
-		int offset = insn->offset, bit = (offset << 3) + insn->size;
+		int offset = insn->offset, bit = bytes_to_bits(offset) + insn->size;
 		struct symbol *sym = pseudo->sym;
 
 		if (sym->bit_size > 0 && (offset < 0 || bit > sym->bit_size))
 			warning(insn->pos, "invalid access %s '%s' (%d %d)",
 				offset < 0 ? "below" : "past the end of",
-				show_ident(sym->ident), offset, sym->bit_size >> 3);
+				show_ident(sym->ident), offset,
+				bits_to_bytes(sym->bit_size));
 	}
 }
 
diff --git a/show-parse.c b/show-parse.c
index 064af32..c79a288 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -673,7 +673,7 @@ static int show_call_expression(struct expression *expr)
 		int new = show_expression(arg);
 		int size = arg->ctype->bit_size;
 		printf("\tpush.%d\t\tv%d\n", size, new);
-		framesize += size >> 3;
+		framesize += bits_to_bytes(size);
 	} END_FOR_EACH_PTR_REVERSE(arg);
 
 	fn = expr->fn;
diff --git a/symbol.c b/symbol.c
index 3292907..49560ee 100644
--- a/symbol.c
+++ b/symbol.c
@@ -128,7 +128,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
 		base_size = 0;
 	}
 
-	align_bit_mask = (sym->ctype.alignment << 3) - 1;
+	align_bit_mask = bytes_to_bits(sym->ctype.alignment) - 1;
 
 	/*
 	 * Bitfields have some very special rules..
@@ -143,7 +143,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
 			bit_size = (bit_size + align_bit_mask) & ~align_bit_mask;
 			bit_offset = 0;
 		}
-		sym->offset = (bit_size - bit_offset) >> 3;
+		sym->offset = bits_to_bytes(bit_size - bit_offset);
 		sym->bit_offset = bit_offset;
 		sym->ctype.base_type->bit_offset = bit_offset;
 		info->bit_size = bit_size + width;
@@ -156,7 +156,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
 	 * Otherwise, just align it right and add it up..
 	 */
 	bit_size = (bit_size + align_bit_mask) & ~align_bit_mask;
-	sym->offset = bit_size >> 3;
+	sym->offset = bits_to_bytes(bit_size);
 
 	info->bit_size = bit_size + base_size;
 	// warning (sym->pos, "regular: offset=%d", sym->offset);
@@ -182,7 +182,7 @@ static struct symbol * examine_struct_union_type(struct symbol *sym, int advance
 		sym->ctype.alignment = info.max_align;
 	bit_size = info.bit_size;
 	if (info.align_size) {
-		bit_align = (sym->ctype.alignment << 3)-1;
+		bit_align = bytes_to_bits(sym->ctype.alignment)-1;
 		bit_size = (bit_size + bit_align) & ~bit_align;
 	}
 	sym->bit_size = bit_size;
@@ -877,7 +877,7 @@ void init_ctype(void)
 		struct symbol *sym = ctype->ptr;
 		unsigned long bit_size = ctype->bit_size ? *ctype->bit_size : -1;
 		unsigned long maxalign = ctype->maxalign ? *ctype->maxalign : 0;
-		unsigned long alignment = (bit_size + 7) >> 3;
+		unsigned long alignment = bits_to_bytes(bit_size + bits_in_char - 1);
 
 		if (alignment > maxalign)
 			alignment = maxalign;
diff --git a/target.h b/target.h
index 25f7948..7f0fd27 100644
--- a/target.h
+++ b/target.h
@@ -42,4 +42,18 @@ extern int pointer_alignment;
 extern int bits_in_enum;
 extern int enum_alignment;
 
+/*
+ * Helper functions for converting bits to bytes and vice versa.
+ */
+
+static inline int bits_to_bytes(int bits)
+{
+	return bits >= 0 ? bits / bits_in_char : -1;
+}
+
+static inline int bytes_to_bits(int bytes)
+{
+	return bytes * bits_in_char;
+}
+
 #endif

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/15 v2] Unhardcode byte size being 8 bits.
Date: Thu, 18 Dec 2008 00:33:45 +0000
Message-ID: <f19298770812171633w43707eb0h8c0a0be262549ddf () mail ! gmail ! com>
--------------------
On Thu, Dec 18, 2008 at 02:33, David Given <dg@cowlark.com> wrote:
> Alexey Zaytsev wrote:
> [...]
>> This problem may be addressed by changing bits_to_bytes to
>> static inline int bits_to_bytes(int bits)
>> {
>>        return bits >= 0 ? bits / bits_in_char : -1;
>> }
>
> That's fine by me (although I've been using my version for ages now with
> no apparent problems --- just out of interest, Clue is now using Sparse
> to compile C into Lua, Javascript, Perl 5, Common Lisp, C and Java
> moderately successfully).
Just try to run sparse over the Linux kernel. It fireas at least at
void * pointer manipulation and (some?) offsetof()'s. Maybe
somewhere else.

>
>> But it seems there is also a bug in sparse, as in
>> ctype_declaration[] the bit_size of void_ctype is
>> set to NULL, while gcc assumes sizeof(void) being 1.
>> Currently sparse would generate wrong code for:
> [...]
>> unsigned long test1(void *p)
>> {
>>         return sizeof(*p);
>> }
>
> TBH, I don't think that's legal --- I know of several compilers that
> will refuse to compile it, and gcc -pedantic produces a warning, which
> means it probably falls into the 'undefined behaviour' bucket of the
> standard. I can't find anything that specifically talks about sizeof
> void, but 6.3.2.2.1 prohibits doing *anything* with the result of an
> expression of type void, which sort of applies here.
>
> Of course, I'm thinking about this from the sparse-as-a-compiler point
> of view, where you're probably more interested in replicating gcc's
> behaviour.

This seems to be legal, and quite popular in the Linux kernel. GNU C defines
sizeof(void) being 1.And as it has the -Wpointer-arith flag, this kind of stuff
may be caught without sparse if deemed undesirable.

P.S:
Please, sign off this patch and the one adding type information to
struct instruction.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 2/15 v2] Unhardcode byte size being 8 bits.
Date: Thu, 18 Dec 2008 01:10:30 +0000
Message-ID: <4949A306.2060200 () knosof ! co ! uk>
--------------------


Alexey ,

>>> unsigned long test1(void *p)
>>> {
>>>         return sizeof(*p);
>>> }
>> TBH, I don't think that's legal --- I know of several compilers that
>> will refuse to compile it, and gcc -pedantic produces a warning, which
>> means it probably falls into the 'undefined behaviour' bucket of the
>> standard. I can't find anything that specifically talks about sizeof
>> void, but 6.3.2.2.1 prohibits doing *anything* with the result of an
>> expression of type void, which sort of applies here.
>>
>> Of course, I'm thinking about this from the sparse-as-a-compiler point
>> of view, where you're probably more interested in replicating gcc's
>> behaviour.
> 
> This seems to be legal, and quite popular in the Linux kernel. GNU C defines
> sizeof(void) being 1.And as it has the -Wpointer-arith flag, this kind of stuff
> may be caught without sparse if deemed undesirable.

It is a constraint violation.

"The sizeof operator shall not be applied to an expression that has 
function type or an incomplete type"

sentence 1118: c0x.coding-guidelines.com/6.5.3.4.html

void is an incomplete type that cannot be completed
sentence 524: c0x.coding-guidelines.com/6.2.5.html

In pre-C90 days, prior to the availability of void, char * was
often used in a context where void * is now used.  Treating void
as being equivalent to char in some kind of compatibility mode
makes sense.  It looks like the gcc maintainers have over stepped
the mark.

I have reported the bug in gcc.  Track Bug: 38563
at: gcc.gnu.org/bugzilla

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 2/15 v2] Unhardcode byte size being 8 bits.
Date: Thu, 18 Dec 2008 01:52:31 +0000
Message-ID: <4949ACDF.50209 () knosof ! co ! uk>
--------------------
All,

> I have reported the bug in gcc.  Track Bug: 38563
> at: gcc.gnu.org/bugzilla

A very prompt response from a gcc maintainer, bug 38563
is a duplicate of bug 22086.

"This is a GCC extension. sizeof(void) is invalid C and should error out
and does with -pedantic-errors"

Yuk, who ever thought to use -pedantic-errors!

-ansi or -std=c89 or -std=c99 don't elicit any diagnostics.

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/15 v2] Unhardcode byte size being 8 bits.
Date: Thu, 18 Dec 2008 03:11:13 +0000
Message-ID: <f19298770812171911u1e7e3cc0i11d33544cd519fea () mail ! gmail ! com>
--------------------
On Thu, Dec 18, 2008 at 04:52, Derek M Jones <derek@knosof.co.uk> wrote:
> All,
>
>> I have reported the bug in gcc.  Track Bug: 38563
>> at: gcc.gnu.org/bugzilla
>
> A very prompt response from a gcc maintainer, bug 38563
> is a duplicate of bug 22086.
>
> "This is a GCC extension. sizeof(void) is invalid C and should error out
> and does with -pedantic-errors"
>
> Yuk, who ever thought to use -pedantic-errors!
>
> -ansi or -std=c89 or -std=c99 don't elicit any diagnostics.

I don't really see why you take this as a tragedy. People seem
to like this extension:
linux/linux-2.6$ make -j 8 CC='gcc -Wpointer-arith' 2>&1 | grep
'warning: pointer of type \'void \*\' used in arithmetic' | uniq | wc
-l
45095

And anyway, that's how gcc works, so sparse can only follow.

P.S:
Dear sir, can you imagine, in Russia, they put pieces of lemon
in their tea! And you worry about gcc being wrong.
/humor
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 2/15 v2] Unhardcode byte size being 8 bits.
Date: Thu, 18 Dec 2008 13:05:45 +0000
Message-ID: <494A4AA9.1060707 () knosof ! co ! uk>
--------------------
Alexey,

>> "This is a GCC extension. sizeof(void) is invalid C and should error out
>> and does with -pedantic-errors"
>>
>> Yuk, who ever thought to use -pedantic-errors!
>>
>> -ansi or -std=c89 or -std=c99 don't elicit any diagnostics.
> 
> I don't really see why you take this as a tragedy. People seem
> to like this extension:

I appreciate the reason for wanting to make this extension to
be friendly to people wanting to migrate pre-C standard code
and start using void.

There is plenty of opportunity for all sorts of subtle bugs here
and I would have hoped that gcc was more proactive in warning
users.  If people writing new code want a pointer to behave like
a char * then why not declare the fact.

Of course sparse has to support this usage, but I would expect it
to flag any usage as an error.

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Re: [PATCH 2/15 v2] Unhardcode byte size being 8 bits.
Date: Thu, 18 Dec 2008 17:12:34 +0000
Message-ID: <494A8482.7030801 () cowlark ! com>
--------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Alexey Zaytsev wrote:
> From: David Given <dg@cowlark.com>
[...]
> Anyway, here is the updated byte size patch.
> David, we still need your sign-off here.
[...]
> diff --git a/compile-i386.c b/compile-i386.c
[...snipped for brevity, you already have the patch...]

Okay:

Signed-off-by: David Given <dg@cowlark.com>

FWIW, I also hereby declare my work in this patch to be in the public
domain, which means you can do what you like with it, including
relicensing it at a future date. Just in case anyone decides to try and
persue a sparse license change.

- --
David Given
dg@cowlark.com
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (Cygwin)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iEYEARECAAYFAklKhIEACgkQf9E0noFvlzjSxwCgzwIVOjhr7Nu+eccIwR1susN8
+TMAoJujE7dAZgAoPSmtlcfYMeq7QE9T
=iKFi
-----END PGP SIGNATURE-----
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] Simplify (and warn about) right shifts that result ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] Simplify (and warn about) right shifts that result
Date: Fri, 25 Apr 2008 02:32:46 +0000
Message-ID: <481142CE.5030801 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig099962893ABBA746D413FDC9
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

Linus Torvalds wrote:
> On Thu, 24 Apr 2008, Pavel Roskin wrote:
>> So I would suggest a similar warning is this case.  Maybe "right shift=

>> too big (%u) for source type %s" (if the source type is readily
>> available) or "right shift count (%d) >=3D width of type (%d)"
>=20
> That's fine, except we shouldn't talk about "type", since we're really =

> doing some really stupid value analysis (the *type* will generally have=
=20
> been cast to a bigger one by the implicit C type evaluation rules).

Pavel, it sounds like you agree with the semantic of the warning, and
just want an different wording.  Thus, I've applied and pushed the patch;=

feel free to propose a change to the wording in a subsequent patch.

>> By the way, your patch has caught something interesting in
>> net/mac80211/tkip.c:
>>
>>         iv32 =3D data[hdr_len + 4] +
>>                 (data[hdr_len + 5] >> 8) +
>>                 (data[hdr_len + 6] >> 16) +
>>                 (data[hdr_len + 7] >> 24);
>>
>> Wow!
>=20
> Heh. That does look like somebody is shifting the wrong way, and=20
> apparently the new warning was worth something ;)

Nice.

- Josh Triplett



--------------enig099962893ABBA746D413FDC9
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIEULOGJuZRtD+evsRAi03AJ0diViUPSPMeudKYcEnKJE/k8GAPQCeJK2o
xFrKnBFAll3vw6NFBxWS9kc=
=wZqZ
-----END PGP SIGNATURE-----

--------------enig099962893ABBA746D413FDC9--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] fix show_typename() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 2/3] fix show_typename()
Date: Fri, 22 Feb 2008 23:05:25 +0000
Message-ID: <E1JSgxJ-0003m5-1z () ZenIV ! linux ! org ! uk>
--------------------

* postfix stuff had been applied in wrong order (e.g. int a[2][3] generated
int [addressable][toplevel] a[3][2])
* after fixing that, we've no need for recursion anymore, a bunch of arguments
go away and turn into local variables and we get an easy way to get rid of
bogus space in the show_typename() result.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c   |    4 +-
 show-parse.c |  100 +++++++++++++++++++++++++++++----------------------------
 2 files changed, 53 insertions(+), 51 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 777f603..2901c1b 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -502,7 +502,7 @@ static inline void unrestrict(struct expression *expr,
 	if (class & TYPE_RESTRICT) {
 		if (class & TYPE_FOULED)
 			*ctype = unfoul(*ctype);
-		warning(expr->pos, "%sdegrades to integer",
+		warning(expr->pos, "%s degrades to integer",
 			show_typename(*ctype));
 		*ctype = (*ctype)->ctype.base_type; /* get to arithmetic type */
 	}
@@ -1802,7 +1802,7 @@ static struct symbol *evaluate_preop(struct expression *expr)
 			expr->right->ctype = ctype;
 			expr->right->fvalue = 0;
 		} else if (is_fouled_type(ctype)) {
-			warning(expr->pos, "%sdegrades to integer",
+			warning(expr->pos, "%s degrades to integer",
 				show_typename(ctype->ctype.base_type));
 		}
 		ctype = &bool_ctype;
diff --git a/show-parse.c b/show-parse.c
index b9a2828..064af32 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -226,12 +226,16 @@ const char *builtin_ctypename(struct ctype *ctype)
 	return NULL;
 }
 
-static void do_show_type(struct symbol *sym, struct type_name *name,
-			 unsigned long mod, int as, int was_ptr)
+static void do_show_type(struct symbol *sym, struct type_name *name)
 {
 	const char *typename;
-	int is_ptr = was_ptr;
+	unsigned long mod = 0;
+	int as = 0;
+	int was_ptr = 0;
+	int restr = 0;
+	int fouled = 0;
 
+deeper:
 	if (!sym || (sym->type != SYM_NODE && sym->type != SYM_ARRAY &&
 		     sym->type != SYM_BITFIELD)) {
 		const char *s;
@@ -249,14 +253,15 @@ static void do_show_type(struct symbol *sym, struct type_name *name,
 	}
 
 	if (!sym)
-		return;
+		goto out;
 
 	if ((typename = builtin_typename(sym))) {
 		int len = strlen(typename);
-		*--name->start = ' ';
+		if (name->start != name->end)
+			*--name->start = ' ';
 		name->start -= len;
 		memcpy(name->start, typename, len);
-		return;
+		goto out;
 	}
 
 	/* Prepend */
@@ -265,20 +270,29 @@ static void do_show_type(struct symbol *sym, struct type_name *name,
 		prepend(name, "*");
 		mod = sym->ctype.modifiers;
 		as = sym->ctype.as;
-		is_ptr = 1;
+		was_ptr = 1;
 		break;
+
 	case SYM_FN:
-		if (was_ptr)
+		if (was_ptr) {
 			prepend(name, "( ");
-		is_ptr = 0;
+			append(name, " )");
+			was_ptr = 0;
+		}
+		append(name, "( ... )");
 		break;
+
 	case SYM_STRUCT:
-		prepend(name, "struct %s ", show_ident(sym->ident));
-		return;
+		if (name->start != name->end)
+			*--name->start = ' ';
+		prepend(name, "struct %s", show_ident(sym->ident));
+		goto out;
 
 	case SYM_UNION:
-		prepend(name, "union %s ", show_ident(sym->ident));
-		return;
+		if (name->start != name->end)
+			*--name->start = ' ';
+		prepend(name, "union %s", show_ident(sym->ident));
+		goto out;
 
 	case SYM_ENUM:
 		prepend(name, "enum %s ", show_ident(sym->ident));
@@ -298,60 +312,48 @@ static void do_show_type(struct symbol *sym, struct type_name *name,
 
 	case SYM_LABEL:
 		append(name, "label(%s:%p)", show_ident(sym->ident), sym);
-		break;
+		return;
 
 	case SYM_ARRAY:
 		mod |= sym->ctype.modifiers;
 		as |= sym->ctype.as;
-		if (was_ptr)
+		if (was_ptr) {
 			prepend(name, "( ");
-		is_ptr = 0;
+			append(name, " )");
+			was_ptr = 0;
+		}
+		append(name, "[%lld]", get_expression_value(sym->array_size));
 		break;
 
 	case SYM_RESTRICT:
-		if (sym->ident) {
-			prepend(name, "restricted %s ", show_ident(sym->ident));
-			return;
+		if (!sym->ident) {
+			restr = 1;
+			break;
 		}
-		break;
+		if (name->start != name->end)
+			*--name->start = ' ';
+		prepend(name, "restricted %s", show_ident(sym->ident));
+		goto out;
 
 	case SYM_FOULED:
+		fouled = 1;
 		break;
 
 	default:
+		if (name->start != name->end)
+			*--name->start = ' ';
 		prepend(name, "unknown type %d", sym->type);
-		return;
+		goto out;
 	}
 
-	do_show_type(sym->ctype.base_type, name, mod, as, is_ptr);
-
-	switch (sym->type) {
-	case SYM_PTR:
-		return;
-
-	case SYM_FN:
-		if (was_ptr)
-			append(name, " )");
-		append(name, "( ... )");
-		return;
-
-	case SYM_ARRAY:
-		if (was_ptr)
-			append(name, " )");
-		append(name, "[%lld]", get_expression_value(sym->array_size));
-		return;
+	sym = sym->ctype.base_type;
+	goto deeper;
 
-	case SYM_RESTRICT:
+out:
+	if (restr)
 		prepend(name, "restricted ");
-		return;
-
-	case SYM_FOULED:
+	if (fouled)
 		prepend(name, "fouled ");
-		return;
-
-	default:
-		break;
-	}
 }
 
 void show_type(struct symbol *sym)
@@ -360,7 +362,7 @@ void show_type(struct symbol *sym)
 	struct type_name name;
 
 	name.start = name.end = array+100;
-	do_show_type(sym, &name, 0, 0, 0);
+	do_show_type(sym, &name);
 	*name.end = 0;
 	printf("%s", name.start);
 }
@@ -371,7 +373,7 @@ const char *show_typename(struct symbol *sym)
 	struct type_name name;
 
 	name.start = name.end = array+100;
-	do_show_type(sym, &name, 0, 0, 0);
+	do_show_type(sym, &name);
 	*name.end = 0;
 	return name.start;
 }
-- 
1.5.3.GIT


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/5] allow context() attribute on variables ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 2/5] allow context() attribute on variables
Date: Sun, 27 Apr 2008 11:31:30 +0000
Message-ID: <20080427113349.512685000 () sipsolutions ! net>
--------------------
This patch makes it possible to add the context attribute on
variables, to warn for example in this case:

    struct something {
        int x __attribute__((context(L,1,1)));
    };

    extern struct something *s;

    static void warn_access13(void)
    {
        s->x = 7;
    }

This is achieved by translating the context attribute on
variables that are loaded from/stored to into a context
expression internally. A number of tests are included,
including tests for a struct member (as above) and array
accesses.

To distinguish between reads and writes (the default is to
check both) use the fourth parameter to the context attribute:
	__attribute__((context(L,1,1,read)))
or
	__attribute__((context(L,1,1,write)))

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
The exact_context() attribute is also allowed so we have the
same max/no-max semantics as functions.

 linearize.c                    |   92 ++++++++++++++++-
 linearize.h                    |    1 
 parse.c                        |   25 ++++
 sparse.1                       |    7 +
 sparse.c                       |   18 ++-
 symbol.h                       |    7 +
 validation/context-exact.c     |    2 
 validation/context-on-vars.c   |  219 +++++++++++++++++++++++++++++++++++++++++
 validation/context-statement.c |    6 -
 9 files changed, 365 insertions(+), 12 deletions(-)

--- sparse.orig/sparse.c	2008-04-26 23:09:05.000000000 +0200
+++ sparse/sparse.c	2008-04-26 23:09:27.000000000 +0200
@@ -114,6 +114,7 @@ static struct context_check_list *checke
 }
 
 #define IMBALANCE_IN "context imbalance in '%s': "
+#define CONTEXT_PROB "context problem in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
 static void get_context_string(char **buf, const char **name)
@@ -267,10 +268,19 @@ static int handle_context(struct entrypo
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
 
-		warning(insn->pos,
-			IMBALANCE_IN
-			"__context__ statement expected different context",
-			show_ident(ep->name->ident));
+		if (insn->access_var) {
+			char *symname = strdup(show_ident(insn->access_var->ident));
+			warning(insn->pos,
+				CONTEXT_PROB
+				"access to '%s' requires different context",
+				show_ident(ep->name->ident), symname);
+			free(symname);
+		} else {
+			warning(insn->pos,
+				CONTEXT_PROB
+				"__context__ statement expected different context",
+				show_ident(ep->name->ident));
+		}
 
 		info(insn->pos, "%swanted %s%d, got %d",
 		     name, cmp, insn->required, val);
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-on-vars.c	2008-04-26 23:37:36.000000000 +0200
@@ -0,0 +1,219 @@
+static void a(void) __attribute__((context(L,0,1)))
+{
+	__context__(L,1);
+}
+
+static void r(void) __attribute__((context(L,1,0)))
+{
+	__context__(L,-1);
+}
+
+static int nl_int __attribute__((context(L,1,1)));
+static int nl_array[100] __attribute__((context(L,1,1)));
+extern int condition;
+
+static void warn_access1(void)
+{
+    nl_int = 7;
+}
+
+static void warn_access2(void)
+{
+    nl_int++;
+}
+
+static void warn_access3(void)
+{
+    if (condition)
+        nl_int++;
+}
+
+static void warn_access4(void)
+{
+    condition -= nl_int;
+}
+
+static void warn_access5(void)
+{
+    int x = condition ? nl_int : 0;
+}
+
+static void warn_access6(void)
+{
+    if (!nl_int) {
+        condition = 1;
+    }
+}
+
+static void warn_access7(void)
+{
+    if (nl_int) {
+        condition = 1;
+    }
+}
+
+static int *warn_access8(void)
+{
+    return &nl_int;
+}
+
+static void warn_access9(void)
+{
+    (void*)nl_int;
+}
+
+static void warn_access10(void)
+{
+    nl_array[7]++;
+}
+
+static void good_access1(void)
+{
+    a();
+    nl_int = 7;
+    r();
+}
+
+static void good_access1(void)
+{
+    if (condition) {
+        a();
+        nl_int = 7;
+        r();
+    }
+}
+
+static void good_access3(void)
+{
+    /* tests more our ability to optimise things out ... */
+    int x = 0 ? nl_int : 0;
+}
+
+static int *good_access4(void)
+{
+    return &nl_int;
+}
+
+struct something {
+    int a;
+    int b;
+};
+
+extern struct something *s __attribute__((context(L,1,1)));
+
+static void warn_access11(void)
+{
+    s->b = 7;
+}
+
+struct something2 {
+    int a;
+    int b __attribute__((context(L,1,1)));
+};
+
+extern struct something2 *s2;
+extern int lx __attribute__((context(L,1,1)));
+
+static void warn_access12(void)
+{
+    s2->b = lx;
+}
+
+static void warn_access13(void)
+{
+    s2->b = 7;
+}
+
+static void good_1(void)
+{
+    a();
+    s2->b = 7;
+    r();
+}
+
+static void good_2(void)
+{
+    a();
+    a();
+    s2->b = 8;
+    r();
+    r();
+}
+
+struct something3 {
+    int a;
+    int b __attribute__((exact_context(L,1,1)));
+};
+
+extern struct something3 *s3;
+
+static void warn_exact1(void)
+{
+    a();
+    a();
+    s3->b = 8;
+    r();
+    r();
+}
+
+extern int x __attribute__((context(L,1,1,read)));
+extern int y __attribute__((context(L,1,1,write)));
+
+static void good_3(void)
+{
+  a();
+  y = x;
+  r();
+}
+
+static void good_4(void)
+{
+  x = y;
+}
+
+static void warn_access14(void)
+{
+  x;
+}
+
+static void warn_access15(void)
+{
+  y = 7;
+}
+
+/*
+ * check-name: Check -Wcontext for variables
+ *
+ * check-error-start
+context-on-vars.c:17:14: warning: context problem in 'warn_access1': access to 'nl_int' requires different context
+context-on-vars.c:17:14:    context 'L': wanted >= 1, got 0
+context-on-vars.c:22:11: warning: context problem in 'warn_access2': access to 'nl_int' requires different context
+context-on-vars.c:22:11:    context 'L': wanted >= 1, got 0
+context-on-vars.c:28:15: warning: context problem in 'warn_access3': access to 'nl_int' requires different context
+context-on-vars.c:28:15:    context 'L': wanted >= 1, got 0
+context-on-vars.c:33:18: warning: context problem in 'warn_access4': access to 'nl_int' requires different context
+context-on-vars.c:33:18:    context 'L': wanted >= 1, got 0
+context-on-vars.c:38:25: warning: context problem in 'warn_access5': access to 'nl_int' requires different context
+context-on-vars.c:38:25:    context 'L': wanted >= 1, got 0
+context-on-vars.c:43:10: warning: context problem in 'warn_access6': access to 'nl_int' requires different context
+context-on-vars.c:43:10:    context 'L': wanted >= 1, got 0
+context-on-vars.c:50:9: warning: context problem in 'warn_access7': access to 'nl_int' requires different context
+context-on-vars.c:50:9:    context 'L': wanted >= 1, got 0
+context-on-vars.c:62:12: warning: context problem in 'warn_access9': access to 'nl_int' requires different context
+context-on-vars.c:62:12:    context 'L': wanted >= 1, got 0
+context-on-vars.c:67:16: warning: context problem in 'warn_access10': access to 'nl_array' requires different context
+context-on-vars.c:67:16:    context 'L': wanted >= 1, got 0
+context-on-vars.c:106:5: warning: context problem in 'warn_access11': access to 's' requires different context
+context-on-vars.c:106:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:119:13: warning: context problem in 'warn_access12': access to 'lx' requires different context
+context-on-vars.c:119:13:    context 'L': wanted >= 1, got 0
+context-on-vars.c:124:5: warning: context problem in 'warn_access13': access to 'b' requires different context
+context-on-vars.c:124:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:154:5: warning: context problem in 'warn_exact1': access to 'b' requires different context
+context-on-vars.c:154:5:    context 'L': wanted 1, got 2
+context-on-vars.c:176:3: warning: context problem in 'warn_access14': access to 'x' requires different context
+context-on-vars.c:176:3:    context 'L': wanted >= 1, got 0
+context-on-vars.c:181:7: warning: context problem in 'warn_access15': access to 'y' requires different context
+context-on-vars.c:181:7:    context 'L': wanted >= 1, got 0
+ * check-error-end
+ */
--- sparse.orig/linearize.c	2008-04-26 23:09:05.000000000 +0200
+++ sparse/linearize.c	2008-04-26 23:37:56.000000000 +0200
@@ -30,7 +30,6 @@ static pseudo_t add_setval(struct entryp
 static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym);
 
 struct access_data;
-static pseudo_t add_load(struct entrypoint *ep, struct access_data *);
 static pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *);
 
 struct pseudo void_pseudo = {};
@@ -935,6 +934,8 @@ static pseudo_t linearize_store_gen(stru
 		pseudo_t value,
 		struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t store = value;
 
 	if (type_size(ad->source_type) != type_size(ad->result_type)) {
@@ -950,6 +951,49 @@ static pseudo_t linearize_store_gen(stru
 		store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
 	}
 	add_store(ep, ad, store);
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_WRITE)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_WRITE)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			if (context->rws != CTX_RWS_BOTH &&
+			    context->rws != CTX_RWS_WRITE)
+				continue;
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return value;
 }
 
@@ -987,6 +1031,8 @@ static pseudo_t add_symbol_address(struc
 
 static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t new = add_load(ep, ad);
 
 	if (ad->bit_offset) {
@@ -994,7 +1040,49 @@ static pseudo_t linearize_load_gen(struc
 		pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
 		new = newval;
 	}
-		
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_READ)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_READ)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			if (context->rws != CTX_RWS_BOTH &&
+			    context->rws != CTX_RWS_READ)
+				continue;
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return new;
 }
 
--- sparse.orig/linearize.h	2008-04-26 23:09:05.000000000 +0200
+++ sparse/linearize.h	2008-04-26 23:09:27.000000000 +0200
@@ -118,6 +118,7 @@ struct instruction {
 		struct /* context */ {
 			int increment, required, inc_false, exact;
 			struct expression *context_expr;
+			struct symbol *access_var;
 		};
 		struct /* asm */ {
 			const char *string;
--- sparse.orig/validation/context-statement.c	2008-04-26 23:08:59.000000000 +0200
+++ sparse/validation/context-statement.c	2008-04-26 23:09:06.000000000 +0200
@@ -59,11 +59,11 @@ static void bad_macro3(void)
  * check-error-start
 context-statement.c:16:8: warning: context imbalance in 'bad_arr': unexpected unlock
 context-statement.c:16:8:    context 'LOCK': wanted 0, got -1
-context-statement.c:38:5: warning: context imbalance in 'bad_macro1': __context__ statement expected different context
+context-statement.c:38:5: warning: context problem in 'bad_macro1': __context__ statement expected different context
 context-statement.c:38:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:47:5: warning: context imbalance in 'bad_macro2': __context__ statement expected different context
+context-statement.c:47:5: warning: context problem in 'bad_macro2': __context__ statement expected different context
 context-statement.c:47:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:53:5: warning: context imbalance in 'bad_macro3': __context__ statement expected different context
+context-statement.c:53:5: warning: context problem in 'bad_macro3': __context__ statement expected different context
 context-statement.c:53:5:    context 'LOCK': wanted >= 0, got -1
  * check-error-end
  */
--- sparse.orig/sparse.1	2008-04-26 23:09:05.000000000 +0200
+++ sparse/sparse.1	2008-04-26 23:42:50.000000000 +0200
@@ -94,6 +94,13 @@ There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
+Both these can also be added to variable accesses but it is not recommended
+to make variable accesses modify the context. For variables, it is possible
+to distinguish between reads and writes (the regular context attribute will
+be required on both reads and writes) by using either the token "read" or
+the token "write" for an optional fourth argument:
+.BI __attribute__((context( expression , in_context , out_context , read|write )).
+
 To indicate that a certain function acquires a context depending on its
 return value, use
 .BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
--- sparse.orig/validation/context-exact.c	2008-04-26 23:09:05.000000000 +0200
+++ sparse/validation/context-exact.c	2008-04-26 23:09:06.000000000 +0200
@@ -61,7 +61,7 @@ static void good_5(void)
  * check-name: Check __exact_context__ statement with required context
  *
  * check-error-start
-context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2: warning: context problem in 'warn_1': __context__ statement expected different context
 context-exact.c:46:2:    context 'TEST': wanted 1, got 2
  * check-error-end
  */
--- sparse.orig/parse.c	2008-04-26 23:37:51.000000000 +0200
+++ sparse/parse.c	2008-04-26 23:39:10.000000000 +0200
@@ -883,16 +883,18 @@ static struct token *attribute_mode(stru
 static struct token *_attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype, int exact)
 {
 	struct context *context = alloc_context();
-	struct expression *args[3];
+	struct expression *args[4];
 	int argc = 0;
+	struct token *last = NULL;
 
 	token = expect(token, '(', "after context attribute");
 	while (!match_op(token, ')')) {
 		struct expression *expr = NULL;
+		last = token;
 		token = conditional_expression(token, &expr);
 		if (!expr)
 			break;
-		if (argc < 3)
+		if (argc < 4)
 			args[argc++] = expr;
 		else
 			argc++;
@@ -917,6 +919,25 @@ static struct token *_attribute_context(
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 		break;
+	case 4: {
+		const char *rw;
+		context->context = args[0];
+		context->in = get_expression_value(args[1]);
+		context->out = get_expression_value(args[2]);
+
+		if (last && token_type(last) == TOKEN_IDENT)
+			rw = show_token(last);
+		else
+			rw = NULL;
+
+		if (rw && strcmp(rw, "read") == 0)
+			context->rws = CTX_RWS_READ;
+		else if (rw && strcmp(rw, "write") == 0)
+			context->rws = CTX_RWS_WRITE;
+		else
+			sparse_error(last->pos, "invalid read/write specifier");
+		break;
+	}
 	default:
 		sparse_error(token->pos, "too many arguments to context attribute");
 		break;
--- sparse.orig/symbol.h	2008-04-26 23:37:51.000000000 +0200
+++ sparse/symbol.h	2008-04-26 23:37:56.000000000 +0200
@@ -69,10 +69,17 @@ enum keyword {
 	KW_MODE		= 1 << 7,
 };
 
+enum context_read_write_specifier {
+	CTX_RWS_BOTH = 0,
+	CTX_RWS_READ,
+	CTX_RWS_WRITE,
+};
+
 struct context {
 	struct expression *context;
 	unsigned int in, out, out_false;
 	int exact;
+	enum context_read_write_specifier rws;
 };
 
 extern struct context *alloc_context(void);

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/9] add __exact_context__ ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 2/9] add __exact_context__
Date: Thu, 29 May 2008 08:54:04 +0000
Message-ID: <20080529085514.035665000 () sipsolutions ! net>
--------------------
We also need a statement to indicate that an exact context is
required, most notably the next patch will require it so that
it can translate attributes on variables into statements.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 ident-list.h               |    1 
 linearize.c                |    1 
 linearize.h                |    2 -
 parse.c                    |   20 ++++++++++++-
 parse.h                    |    1 
 sparse.1                   |    2 -
 sparse.c                   |   14 ++++++---
 validation/context-exact.c |   67 +++++++++++++++++++++++++++++++++++++++++++++
 8 files changed, 101 insertions(+), 7 deletions(-)

--- sparse.orig/ident-list.h	2008-04-26 23:09:00.000000000 +0200
+++ sparse/ident-list.h	2008-04-26 23:09:05.000000000 +0200
@@ -96,6 +96,7 @@ __IDENT(__PRETTY_FUNCTION___ident, "__PR
 
 /* Sparse commands */
 IDENT_RESERVED(__context__);
+IDENT_RESERVED(__exact_context__);
 IDENT_RESERVED(__range__);
 
 /* Magic function names we recognize */
--- sparse.orig/linearize.c	2008-04-26 23:09:00.000000000 +0200
+++ sparse/linearize.c	2008-04-26 23:09:05.000000000 +0200
@@ -1681,6 +1681,7 @@ static pseudo_t linearize_context(struct
 		value = expr->value;
 
 	insn->required = value;
+	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
 	add_one_insn(ep, insn);
--- sparse.orig/parse.c	2008-04-26 23:09:04.000000000 +0200
+++ sparse/parse.c	2008-04-26 23:09:05.000000000 +0200
@@ -52,6 +52,7 @@ static struct token *parse_while_stateme
 static struct token *parse_do_statement(struct token *token, struct statement *stmt);
 static struct token *parse_goto_statement(struct token *token, struct statement *stmt);
 static struct token *parse_context_statement(struct token *token, struct statement *stmt);
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt);
 static struct token *parse_range_statement(struct token *token, struct statement *stmt);
 static struct token *parse_asm_statement(struct token *token, struct statement *stmt);
 static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
@@ -149,6 +150,10 @@ static struct symbol_op __context___op =
 	.statement = parse_context_statement,
 };
 
+static struct symbol_op __exact_context___op = {
+	.statement = parse_exact_context_statement,
+};
+
 static struct symbol_op range_op = {
 	.statement = parse_range_statement,
 };
@@ -254,6 +259,7 @@ static struct init_keyword {
 	{ "do",		NS_KEYWORD, .op = &do_op },
 	{ "goto",	NS_KEYWORD, .op = &goto_op },
 	{ "__context__",NS_KEYWORD, .op = &__context___op },
+	{ "__exact_context__",NS_KEYWORD, .op = &__exact_context___op },
 	{ "__range__",	NS_KEYWORD, .op = &range_op },
 	{ "asm",	NS_KEYWORD, .op = &asm_op },
 	{ "__asm",	NS_KEYWORD, .op = &asm_op },
@@ -1810,7 +1816,7 @@ static struct token *parse_goto_statemen
 	return expect(token, ';', "at end of statement");
 }
 
-static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+static struct token *_parse_context_statement(struct token *token, struct statement *stmt, int exact)
 {
 	struct expression *args[3];
 	int argc = 0;
@@ -1835,6 +1841,8 @@ static struct token *parse_context_state
 	stmt->expression = args[0];
 	stmt->context = NULL;
 
+	stmt->exact = exact;
+
 	switch (argc) {
 	case 0:
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
@@ -1864,6 +1872,16 @@ static struct token *parse_context_state
 	return expect(token, ')', "at end of __context__");
 }
 
+static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 0);
+}
+
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 1);
+}
+
 static struct token *parse_range_statement(struct token *token, struct statement *stmt)
 {
 	stmt->type = STMT_RANGE;
--- sparse.orig/sparse.1	2008-04-26 23:09:00.000000000 +0200
+++ sparse/sparse.1	2008-04-26 23:09:05.000000000 +0200
@@ -90,7 +90,7 @@ To indicate that a function requires
 .BI exactly
 a certain lock context (not "at least" as above), use the form
 .BI __attribute__((exact_context( [expression ,] in_context , out_context ))
-There currently is no corresponding
+There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
--- sparse.orig/sparse.c	2008-04-26 23:09:00.000000000 +0200
+++ sparse/sparse.c	2008-04-26 23:09:05.000000000 +0200
@@ -239,7 +239,7 @@ static int handle_context(struct entrypo
 			  struct context_check_list **combined)
 {
 	struct context_check *c;
-	const char *name;
+	const char *name, *cmp;
 	char *buf;
 	int val, ok;
 
@@ -256,7 +256,13 @@ static int handle_context(struct entrypo
 		}
 	} END_FOR_EACH_PTR(c);
 
-	ok = insn->required <= val;
+	if (insn->exact) {
+		ok = insn->required == val;
+		cmp = "";
+	} else {
+		ok = insn->required <= val;
+		cmp = ">= ";
+	}
 
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
@@ -266,8 +272,8 @@ static int handle_context(struct entrypo
 			"__context__ statement expected different context",
 			show_ident(ep->name->ident));
 
-		info(insn->pos, "%swanted >= %d, got %d",
-		     name, insn->required, val);
+		info(insn->pos, "%swanted %s%d, got %d",
+		     name, cmp, insn->required, val);
 
 		free(buf);
 		return -1;
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-exact.c	2008-04-26 23:09:05.000000000 +0200
@@ -0,0 +1,67 @@
+static void a(void) __attribute__((context(TEST,0,1)))
+{
+	__context__(TEST,1);
+}
+
+static void r(void) __attribute__((context(TEST,1,0)))
+{
+	__context__(TEST,-1,1);
+}
+
+static void good_1(void)
+{
+	a();
+	r();
+}
+
+static void good_2(void)
+{
+	a();
+	r();
+	a();
+	r();
+}
+
+static void good_3(void)
+{
+	a();
+	a();
+	r();
+	r();
+}
+
+static void good_4(void)
+{
+	a();
+	a();
+	__context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void warn_1(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void good_5(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,2);
+	r();
+	r();
+}
+
+/*
+ * check-name: Check __exact_context__ statement with required context
+ *
+ * check-error-start
+context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2:    context 'TEST': wanted 1, got 2
+ * check-error-end
+ */
--- sparse.orig/linearize.h	2008-04-26 23:09:00.000000000 +0200
+++ sparse/linearize.h	2008-04-26 23:09:05.000000000 +0200
@@ -116,7 +116,7 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false;
+			int increment, required, inc_false, exact;
 			struct expression *context_expr;
 		};
 		struct /* asm */ {
--- sparse.orig/parse.h	2008-04-26 23:09:00.000000000 +0200
+++ sparse/parse.h	2008-04-26 23:09:05.000000000 +0200
@@ -43,6 +43,7 @@ struct statement {
 			struct expression *expression;
 			struct expression *context;
 			struct expression *required;
+			int exact;
 		};
 		struct /* return_statement */ {
 			struct expression *ret_value;

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/5] evaluate/expand context expressions ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 3/5] evaluate/expand context expressions
Date: Sun, 27 Apr 2008 11:31:31 +0000
Message-ID: <20080427113349.952558000 () sipsolutions ! net>
--------------------
But still allow having a standalone symbol as the context
expression, also evaluate the context change/requirement
directly in the parser and pass them up as integers. Also
fixes a number of bugs e.g. in the expression copier and
a segfault when the default context is used as such:
   __context__(1,1);

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 evaluate.c           |    9 ++++++++-
 expand.c             |    2 +-
 inline.c             |   19 ++++++++++++-------
 linearize.c          |   17 +++--------------
 parse.c              |   22 +++++++++++++---------
 parse.h              |    6 ++++--
 validation/context.c |   28 ++++++++++++++++++++++++++++
 7 files changed, 69 insertions(+), 34 deletions(-)

--- sparse.orig/evaluate.c	2008-04-26 23:09:27.000000000 +0200
+++ sparse/evaluate.c	2008-04-26 23:44:32.000000000 +0200
@@ -3356,7 +3356,14 @@ struct symbol *evaluate_statement(struct
 		evaluate_asm_statement(stmt);
 		return NULL;
 	case STMT_CONTEXT:
-		evaluate_expression(stmt->expression);
+		/*
+		 * If this is an unknown symbol accept it as-is
+		 * as a context name.
+		 */
+		if (stmt->context &&
+		    (stmt->context->type != EXPR_SYMBOL ||
+		     stmt->context->symbol))
+			evaluate_expression(stmt->context);
 		return NULL;
 	case STMT_RANGE:
 		evaluate_expression(stmt->range_expression);
--- sparse.orig/expand.c	2008-04-26 23:09:27.000000000 +0200
+++ sparse/expand.c	2008-04-26 23:44:32.000000000 +0200
@@ -1169,7 +1169,7 @@ static int expand_statement(struct state
 		/* FIXME! Do the asm parameter evaluation! */
 		break;
 	case STMT_CONTEXT:
-		expand_expression(stmt->expression);
+		expand_expression(stmt->context);
 		break;
 	case STMT_RANGE:
 		expand_expression(stmt->range_expression);
--- sparse.orig/inline.c	2008-04-26 23:09:27.000000000 +0200
+++ sparse/inline.c	2008-04-26 23:44:32.000000000 +0200
@@ -328,7 +328,18 @@ static struct statement *copy_one_statem
 		stmt = newstmt;
 		break;
 	}
-	case STMT_CONTEXT:
+	case STMT_CONTEXT: {
+		struct expression *expr = copy_expression(stmt->context);
+		struct statement *newstmt;
+		if (expr == stmt->context)
+			break;
+		newstmt = dup_statement(stmt);
+		newstmt->context = expr;
+		newstmt->change = stmt->change;
+		newstmt->required = stmt->required;
+		stmt = newstmt;
+		break;
+	}
 	case STMT_EXPRESSION: {
 		struct expression *expr = copy_expression(stmt->expression);
 		struct statement *newstmt;
@@ -336,12 +347,6 @@ static struct statement *copy_one_statem
 			break;
 		newstmt = dup_statement(stmt);
 		newstmt->expression = expr;
-		if (stmt->required) {
-			expr = copy_expression(stmt->required);
-			if (expr == stmt->required)
-				break;
-			newstmt->required = expr;
-		}
 		stmt = newstmt;
 		break;
 	}
--- sparse.orig/linearize.c	2008-04-26 23:37:56.000000000 +0200
+++ sparse/linearize.c	2008-04-26 23:44:32.000000000 +0200
@@ -1753,22 +1753,11 @@ static pseudo_t linearize_inlined_call(s
 static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 {
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
-	struct expression *expr = stmt->expression;
-	int value = 0;
 
-	if (expr->type == EXPR_VALUE)
-		value = expr->value;
+	insn->increment = stmt->change;
+	insn->inc_false = stmt->change;
 
-	insn->increment = value;
-	insn->inc_false = value;
-
-	expr = stmt->required;
-	value = 0;
-
-	if (expr && expr->type == EXPR_VALUE)
-		value = expr->value;
-
-	insn->required = value;
+	insn->required = stmt->required;
 	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
--- sparse.orig/parse.c	2008-04-26 23:39:10.000000000 +0200
+++ sparse/parse.c	2008-04-26 23:44:32.000000000 +0200
@@ -1859,9 +1859,7 @@ static struct token *_parse_context_stat
 		token = token->next;
 	}
 
-	stmt->expression = args[0];
 	stmt->context = NULL;
-
 	stmt->exact = exact;
 
 	switch (argc) {
@@ -1869,21 +1867,27 @@ static struct token *_parse_context_stat
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
 		return token;
 	case 1:
-		/* already done */
+		stmt->change = get_expression_value(args[0]);
 		break;
 	case 2:
-		if (args[0]->type != STMT_EXPRESSION) {
+		/*
+		 * We should actually check whether we can evalulate
+		 * it as a constant expression and if so use as the
+		 * 'change' value. I hope nobody gives a calculation
+		 * for the number.
+		 */
+		if (args[0]->type != EXPR_VALUE) {
 			stmt->context = args[0];
-			stmt->expression = args[1];
+			stmt->change = get_expression_value(args[1]);
 		} else {
-			stmt->expression = args[0];
-			stmt->required = args[1];
+			stmt->change = get_expression_value(args[0]);
+			stmt->required = get_expression_value(args[1]);
 		}
 		break;
 	case 3:
 		stmt->context = args[0];
-		stmt->expression = args[1];
-		stmt->required = args[2];
+		stmt->change = get_expression_value(args[1]);
+		stmt->required = get_expression_value(args[2]);
 		break;
 	default:
 		sparse_error(token->pos, "too many arguments for __context__ statement");
--- sparse.orig/parse.h	2008-04-26 23:09:27.000000000 +0200
+++ sparse/parse.h	2008-04-26 23:44:32.000000000 +0200
@@ -39,10 +39,12 @@ struct statement {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
-		struct { /* __context__ */
+		struct { /* expression */
 			struct expression *expression;
+		};
+		struct { /* __context__ */
 			struct expression *context;
-			struct expression *required;
+			int change, required;
 			int exact;
 		};
 		struct /* return_statement */ {
--- sparse.orig/validation/context.c	2008-04-26 23:09:27.000000000 +0200
+++ sparse/validation/context.c	2008-04-26 23:44:32.000000000 +0200
@@ -380,6 +380,32 @@ static int warn_conditional(void)
     return 0;
 }
 
+static void areq(void) __attribute__((context(1,2)))
+{
+	__context__(1,1);
+}
+
+static void good_reqlock(void)
+{
+	a();
+	areq();
+	r();
+	r();
+}
+
+static void warn_reqlock(void)
+{
+	areq();
+	r();
+}
+
+
+static void dummy1(void) __attribute__((context(p,0,1)))
+{
+        void *p;
+	__context__(p,1);
+}
+
 /*
  * check-name: Check -Wcontext
  *
@@ -418,5 +444,7 @@ context.c:360:10: warning: context probl
 context.c:360:10:    default context: wanted >= 1, got 0
 context.c:380:12: warning: context imbalance in 'warn_conditional': wrong count at exit
 context.c:380:12:    default context: wanted 0, got 1
+context.c:398:6: warning: context problem in 'warn_reqlock': 'areq' expected different context
+context.c:398:6:    default context: wanted >= 1, got 0
  * check-error-end
  */

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/9] allow context() attribute on variables ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 3/9] allow context() attribute on variables
Date: Thu, 29 May 2008 08:54:05 +0000
Message-ID: <20080529085514.658862000 () sipsolutions ! net>
--------------------
This patch makes it possible to add the context attribute on
variables, to warn for example in this case:

    struct something {
        int x __attribute__((context(L,1,1)));
    };

    extern struct something *s;

    static void warn_access13(void)
    {
        s->x = 7;
    }

This is achieved by translating the context attribute on
variables that are loaded from/stored to into a context
expression internally. A number of tests are included,
including tests for a struct member (as above) and array
accesses.

To distinguish between reads and writes (the default is to
check both) use the fourth parameter to the context attribute:
	__attribute__((context(L,1,1,read)))
or
	__attribute__((context(L,1,1,write)))

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
The exact_context() attribute is also allowed so we have the
same max/no-max semantics as functions.

 linearize.c                    |   92 ++++++++++++++++-
 linearize.h                    |    1 
 parse.c                        |   25 ++++
 sparse.1                       |    7 +
 sparse.c                       |   18 ++-
 symbol.h                       |    7 +
 validation/context-exact.c     |    2 
 validation/context-on-vars.c   |  219 +++++++++++++++++++++++++++++++++++++++++
 validation/context-statement.c |    6 -
 9 files changed, 365 insertions(+), 12 deletions(-)

--- sparse.orig/sparse.c	2008-04-26 23:09:05.000000000 +0200
+++ sparse/sparse.c	2008-04-26 23:09:27.000000000 +0200
@@ -114,6 +114,7 @@ static struct context_check_list *checke
 }
 
 #define IMBALANCE_IN "context imbalance in '%s': "
+#define CONTEXT_PROB "context problem in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
 static void get_context_string(char **buf, const char **name)
@@ -267,10 +268,19 @@ static int handle_context(struct entrypo
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
 
-		warning(insn->pos,
-			IMBALANCE_IN
-			"__context__ statement expected different context",
-			show_ident(ep->name->ident));
+		if (insn->access_var) {
+			char *symname = strdup(show_ident(insn->access_var->ident));
+			warning(insn->pos,
+				CONTEXT_PROB
+				"access to '%s' requires different context",
+				show_ident(ep->name->ident), symname);
+			free(symname);
+		} else {
+			warning(insn->pos,
+				CONTEXT_PROB
+				"__context__ statement expected different context",
+				show_ident(ep->name->ident));
+		}
 
 		info(insn->pos, "%swanted %s%d, got %d",
 		     name, cmp, insn->required, val);
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-on-vars.c	2008-04-26 23:37:36.000000000 +0200
@@ -0,0 +1,219 @@
+static void a(void) __attribute__((context(L,0,1)))
+{
+	__context__(L,1);
+}
+
+static void r(void) __attribute__((context(L,1,0)))
+{
+	__context__(L,-1);
+}
+
+static int nl_int __attribute__((context(L,1,1)));
+static int nl_array[100] __attribute__((context(L,1,1)));
+extern int condition;
+
+static void warn_access1(void)
+{
+    nl_int = 7;
+}
+
+static void warn_access2(void)
+{
+    nl_int++;
+}
+
+static void warn_access3(void)
+{
+    if (condition)
+        nl_int++;
+}
+
+static void warn_access4(void)
+{
+    condition -= nl_int;
+}
+
+static void warn_access5(void)
+{
+    int x = condition ? nl_int : 0;
+}
+
+static void warn_access6(void)
+{
+    if (!nl_int) {
+        condition = 1;
+    }
+}
+
+static void warn_access7(void)
+{
+    if (nl_int) {
+        condition = 1;
+    }
+}
+
+static int *warn_access8(void)
+{
+    return &nl_int;
+}
+
+static void warn_access9(void)
+{
+    (void*)nl_int;
+}
+
+static void warn_access10(void)
+{
+    nl_array[7]++;
+}
+
+static void good_access1(void)
+{
+    a();
+    nl_int = 7;
+    r();
+}
+
+static void good_access1(void)
+{
+    if (condition) {
+        a();
+        nl_int = 7;
+        r();
+    }
+}
+
+static void good_access3(void)
+{
+    /* tests more our ability to optimise things out ... */
+    int x = 0 ? nl_int : 0;
+}
+
+static int *good_access4(void)
+{
+    return &nl_int;
+}
+
+struct something {
+    int a;
+    int b;
+};
+
+extern struct something *s __attribute__((context(L,1,1)));
+
+static void warn_access11(void)
+{
+    s->b = 7;
+}
+
+struct something2 {
+    int a;
+    int b __attribute__((context(L,1,1)));
+};
+
+extern struct something2 *s2;
+extern int lx __attribute__((context(L,1,1)));
+
+static void warn_access12(void)
+{
+    s2->b = lx;
+}
+
+static void warn_access13(void)
+{
+    s2->b = 7;
+}
+
+static void good_1(void)
+{
+    a();
+    s2->b = 7;
+    r();
+}
+
+static void good_2(void)
+{
+    a();
+    a();
+    s2->b = 8;
+    r();
+    r();
+}
+
+struct something3 {
+    int a;
+    int b __attribute__((exact_context(L,1,1)));
+};
+
+extern struct something3 *s3;
+
+static void warn_exact1(void)
+{
+    a();
+    a();
+    s3->b = 8;
+    r();
+    r();
+}
+
+extern int x __attribute__((context(L,1,1,read)));
+extern int y __attribute__((context(L,1,1,write)));
+
+static void good_3(void)
+{
+  a();
+  y = x;
+  r();
+}
+
+static void good_4(void)
+{
+  x = y;
+}
+
+static void warn_access14(void)
+{
+  x;
+}
+
+static void warn_access15(void)
+{
+  y = 7;
+}
+
+/*
+ * check-name: Check -Wcontext for variables
+ *
+ * check-error-start
+context-on-vars.c:17:14: warning: context problem in 'warn_access1': access to 'nl_int' requires different context
+context-on-vars.c:17:14:    context 'L': wanted >= 1, got 0
+context-on-vars.c:22:11: warning: context problem in 'warn_access2': access to 'nl_int' requires different context
+context-on-vars.c:22:11:    context 'L': wanted >= 1, got 0
+context-on-vars.c:28:15: warning: context problem in 'warn_access3': access to 'nl_int' requires different context
+context-on-vars.c:28:15:    context 'L': wanted >= 1, got 0
+context-on-vars.c:33:18: warning: context problem in 'warn_access4': access to 'nl_int' requires different context
+context-on-vars.c:33:18:    context 'L': wanted >= 1, got 0
+context-on-vars.c:38:25: warning: context problem in 'warn_access5': access to 'nl_int' requires different context
+context-on-vars.c:38:25:    context 'L': wanted >= 1, got 0
+context-on-vars.c:43:10: warning: context problem in 'warn_access6': access to 'nl_int' requires different context
+context-on-vars.c:43:10:    context 'L': wanted >= 1, got 0
+context-on-vars.c:50:9: warning: context problem in 'warn_access7': access to 'nl_int' requires different context
+context-on-vars.c:50:9:    context 'L': wanted >= 1, got 0
+context-on-vars.c:62:12: warning: context problem in 'warn_access9': access to 'nl_int' requires different context
+context-on-vars.c:62:12:    context 'L': wanted >= 1, got 0
+context-on-vars.c:67:16: warning: context problem in 'warn_access10': access to 'nl_array' requires different context
+context-on-vars.c:67:16:    context 'L': wanted >= 1, got 0
+context-on-vars.c:106:5: warning: context problem in 'warn_access11': access to 's' requires different context
+context-on-vars.c:106:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:119:13: warning: context problem in 'warn_access12': access to 'lx' requires different context
+context-on-vars.c:119:13:    context 'L': wanted >= 1, got 0
+context-on-vars.c:124:5: warning: context problem in 'warn_access13': access to 'b' requires different context
+context-on-vars.c:124:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:154:5: warning: context problem in 'warn_exact1': access to 'b' requires different context
+context-on-vars.c:154:5:    context 'L': wanted 1, got 2
+context-on-vars.c:176:3: warning: context problem in 'warn_access14': access to 'x' requires different context
+context-on-vars.c:176:3:    context 'L': wanted >= 1, got 0
+context-on-vars.c:181:7: warning: context problem in 'warn_access15': access to 'y' requires different context
+context-on-vars.c:181:7:    context 'L': wanted >= 1, got 0
+ * check-error-end
+ */
--- sparse.orig/linearize.c	2008-04-26 23:09:05.000000000 +0200
+++ sparse/linearize.c	2008-04-26 23:37:56.000000000 +0200
@@ -30,7 +30,6 @@ static pseudo_t add_setval(struct entryp
 static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym);
 
 struct access_data;
-static pseudo_t add_load(struct entrypoint *ep, struct access_data *);
 static pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *);
 
 struct pseudo void_pseudo = {};
@@ -935,6 +934,8 @@ static pseudo_t linearize_store_gen(stru
 		pseudo_t value,
 		struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t store = value;
 
 	if (type_size(ad->source_type) != type_size(ad->result_type)) {
@@ -950,6 +951,49 @@ static pseudo_t linearize_store_gen(stru
 		store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
 	}
 	add_store(ep, ad, store);
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_WRITE)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_WRITE)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			if (context->rws != CTX_RWS_BOTH &&
+			    context->rws != CTX_RWS_WRITE)
+				continue;
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return value;
 }
 
@@ -987,6 +1031,8 @@ static pseudo_t add_symbol_address(struc
 
 static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t new = add_load(ep, ad);
 
 	if (ad->bit_offset) {
@@ -994,7 +1040,49 @@ static pseudo_t linearize_load_gen(struc
 		pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
 		new = newval;
 	}
-		
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_READ)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		if (context->rws != CTX_RWS_BOTH &&
+		    context->rws != CTX_RWS_READ)
+			continue;
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			if (context->rws != CTX_RWS_BOTH &&
+			    context->rws != CTX_RWS_READ)
+				continue;
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return new;
 }
 
--- sparse.orig/linearize.h	2008-04-26 23:09:05.000000000 +0200
+++ sparse/linearize.h	2008-04-26 23:09:27.000000000 +0200
@@ -118,6 +118,7 @@ struct instruction {
 		struct /* context */ {
 			int increment, required, inc_false, exact;
 			struct expression *context_expr;
+			struct symbol *access_var;
 		};
 		struct /* asm */ {
 			const char *string;
--- sparse.orig/validation/context-statement.c	2008-04-26 23:08:59.000000000 +0200
+++ sparse/validation/context-statement.c	2008-04-26 23:09:06.000000000 +0200
@@ -59,11 +59,11 @@ static void bad_macro3(void)
  * check-error-start
 context-statement.c:16:8: warning: context imbalance in 'bad_arr': unexpected unlock
 context-statement.c:16:8:    context 'LOCK': wanted 0, got -1
-context-statement.c:38:5: warning: context imbalance in 'bad_macro1': __context__ statement expected different context
+context-statement.c:38:5: warning: context problem in 'bad_macro1': __context__ statement expected different context
 context-statement.c:38:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:47:5: warning: context imbalance in 'bad_macro2': __context__ statement expected different context
+context-statement.c:47:5: warning: context problem in 'bad_macro2': __context__ statement expected different context
 context-statement.c:47:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:53:5: warning: context imbalance in 'bad_macro3': __context__ statement expected different context
+context-statement.c:53:5: warning: context problem in 'bad_macro3': __context__ statement expected different context
 context-statement.c:53:5:    context 'LOCK': wanted >= 0, got -1
  * check-error-end
  */
--- sparse.orig/sparse.1	2008-04-26 23:09:05.000000000 +0200
+++ sparse/sparse.1	2008-04-26 23:42:50.000000000 +0200
@@ -94,6 +94,13 @@ There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
+Both these can also be added to variable accesses but it is not recommended
+to make variable accesses modify the context. For variables, it is possible
+to distinguish between reads and writes (the regular context attribute will
+be required on both reads and writes) by using either the token "read" or
+the token "write" for an optional fourth argument:
+.BI __attribute__((context( expression , in_context , out_context , read|write )).
+
 To indicate that a certain function acquires a context depending on its
 return value, use
 .BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
--- sparse.orig/validation/context-exact.c	2008-04-26 23:09:05.000000000 +0200
+++ sparse/validation/context-exact.c	2008-04-26 23:09:06.000000000 +0200
@@ -61,7 +61,7 @@ static void good_5(void)
  * check-name: Check __exact_context__ statement with required context
  *
  * check-error-start
-context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2: warning: context problem in 'warn_1': __context__ statement expected different context
 context-exact.c:46:2:    context 'TEST': wanted 1, got 2
  * check-error-end
  */
--- sparse.orig/parse.c	2008-04-26 23:37:51.000000000 +0200
+++ sparse/parse.c	2008-04-26 23:39:10.000000000 +0200
@@ -883,16 +883,18 @@ static struct token *attribute_mode(stru
 static struct token *_attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype, int exact)
 {
 	struct context *context = alloc_context();
-	struct expression *args[3];
+	struct expression *args[4];
 	int argc = 0;
+	struct token *last = NULL;
 
 	token = expect(token, '(', "after context attribute");
 	while (!match_op(token, ')')) {
 		struct expression *expr = NULL;
+		last = token;
 		token = conditional_expression(token, &expr);
 		if (!expr)
 			break;
-		if (argc < 3)
+		if (argc < 4)
 			args[argc++] = expr;
 		else
 			argc++;
@@ -917,6 +919,25 @@ static struct token *_attribute_context(
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 		break;
+	case 4: {
+		const char *rw;
+		context->context = args[0];
+		context->in = get_expression_value(args[1]);
+		context->out = get_expression_value(args[2]);
+
+		if (last && token_type(last) == TOKEN_IDENT)
+			rw = show_token(last);
+		else
+			rw = NULL;
+
+		if (rw && strcmp(rw, "read") == 0)
+			context->rws = CTX_RWS_READ;
+		else if (rw && strcmp(rw, "write") == 0)
+			context->rws = CTX_RWS_WRITE;
+		else
+			sparse_error(last->pos, "invalid read/write specifier");
+		break;
+	}
 	default:
 		sparse_error(token->pos, "too many arguments to context attribute");
 		break;
--- sparse.orig/symbol.h	2008-04-26 23:37:51.000000000 +0200
+++ sparse/symbol.h	2008-04-26 23:37:56.000000000 +0200
@@ -69,10 +69,17 @@ enum keyword {
 	KW_MODE		= 1 << 7,
 };
 
+enum context_read_write_specifier {
+	CTX_RWS_BOTH = 0,
+	CTX_RWS_READ,
+	CTX_RWS_WRITE,
+};
+
 struct context {
 	struct expression *context;
 	unsigned int in, out, out_false;
 	int exact;
+	enum context_read_write_specifier rws;
 };
 
 extern struct context *alloc_context(void);

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/4] Rename dirafter to idirafter. ===

From: Alexey zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/4] Rename dirafter to idirafter.
Date: Mon, 08 Dec 2008 09:21:02 +0000
Message-ID: <20081208092102.15890.51534.stgit () xl0 ! local>
--------------------
Dirafter was probably just a mistake.
Gcc uses -idirafter.

Signed-off-by: Alexey zaytsev <alexey.zaytsev@gmail.com>
---
 lib.c         |   15 +++++----------
 pre-process.c |    4 ++--
 2 files changed, 7 insertions(+), 12 deletions(-)

diff --git a/lib.c b/lib.c
index b579834..7adff2d 100644
--- a/lib.c
+++ b/lib.c
@@ -313,6 +313,11 @@ static char **handle_switch_i(char *arg, char **next)
 		if (!path)
 			die("missing argument for -isystem option");
 		add_pre_buffer("#add_isystem \"%s/\"\n", path);
+	} else if (*next && !strcmp(arg, "idirafter")) {
+		char *path = *++next;
+		if (!path)
+			die("missing argument for -idirafter option");
+		add_pre_buffer("#add_dirafter \"%s/\"\n", path);
 	}
 	return next;
 }
@@ -573,15 +578,6 @@ static char **handle_nostdinc(char *arg, char **next)
 	return next;
 }
 
-static char **handle_dirafter(char *arg, char **next)
-{
-	char *path = *++next;
-	if (!path)
-		die("missing argument for -dirafter option");
-	add_pre_buffer("#add_dirafter \"%s/\"\n", path);
-	return next;
-}
-
 static char **handle_base_dir(char *arg, char **next)
 {
 	gcc_base_dir = *++next;
@@ -599,7 +595,6 @@ char **handle_switch(char *arg, char **next)
 {
 	static struct switches cmd[] = {
 		{ "nostdinc", handle_nostdinc },
-		{ "dirafter", handle_dirafter },
 		{ "gcc-base-dir", handle_base_dir},
 		{ NULL, NULL }
 	};
diff --git a/pre-process.c b/pre-process.c
index 9c6ef5b..cf53893 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -682,10 +682,10 @@ static int already_tokenized(const char *path)
  *   angle_includepath is set equal to isys_includepath.
  * -nostdinc removes all sys dirs by storing NULL in entry pointed
  *   to by * sys_includepath. Note that this will reset all dirs built-in
- *   and added before -nostdinc by -isystem and -dirafter.
+ *   and added before -nostdinc by -isystem and -idirafter.
  * -isystem dir adds dir where isys_includepath points adding this dir as
  *   first systemdir
- * -dirafter dir adds dir to the end of the list
+ * -idirafter dir adds dir to the end of the list
  */
 
 static void set_stream_include_path(struct stream *stream)

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [PATCH 4/4] Rename dirafter to idirafter.
Date: Mon, 15 Dec 2008 21:07:54 +0000
Message-ID: <20081215210754.GA14567 () uranus ! ravnborg ! org>
--------------------
On Mon, Dec 08, 2008 at 12:21:02PM +0300, Alexey zaytsev wrote:
> Dirafter was probably just a mistake.
> Gcc uses -idirafter.

My mistake - thanks.

> 
> Signed-off-by: Alexey zaytsev <alexey.zaytsev@gmail.com>
Acked-by: Sam Ravnborg <sam@ravnborg.org>

	Sam

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] revert the conditional_context patch ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 4/5] revert the conditional_context patch
Date: Sun, 27 Apr 2008 11:31:32 +0000
Message-ID: <20080427113350.453623000 () sipsolutions ! net>
--------------------
This patch removes the conditional_context attribute again, it turned
out that my attempt to do this was rather misguided and contrary to
what I thought we do not gain anything at all over using macros for
it as the kernel and the tests have been doing for a while.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 linearize.c                  |   32 +++++---
 linearize.h                  |    2 
 parse.c                      |   52 -------------
 sparse.1                     |    9 --
 sparse.c                     |   39 +++------
 symbol.h                     |    2 
 validation/context-dynamic.c |  171 -------------------------------------------
 7 files changed, 37 insertions(+), 270 deletions(-)

--- sparse.orig/linearize.c	2008-04-27 03:10:44.000000000 +0200
+++ sparse/linearize.c	2008-04-27 03:16:56.000000000 +0200
@@ -437,7 +437,7 @@ const char *show_instruction(struct inst
 		break;
 
 	case OP_CONTEXT:
-		buf += sprintf(buf, "%s%d,%d", "", insn->increment, insn->inc_false);
+		buf += sprintf(buf, "%d", insn->increment);
 		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
@@ -958,7 +958,7 @@ static pseudo_t linearize_store_gen(stru
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->source_type;
 		insn->exact = context->exact;
@@ -971,7 +971,7 @@ static pseudo_t linearize_store_gen(stru
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->result_type;
 		insn->exact = context->exact;
@@ -986,7 +986,7 @@ static pseudo_t linearize_store_gen(stru
 				continue;
 			insn = alloc_instruction(OP_CONTEXT, 0);
 			insn->required = context->in;
-			insn->increment = insn->inc_false = context->out - context->in;
+			insn->increment = context->out - context->in;
 			insn->context_expr = context->context;
 			insn->access_var = ad->address->sym;
 			insn->exact = context->exact;
@@ -1047,7 +1047,7 @@ static pseudo_t linearize_load_gen(struc
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->source_type;
 		insn->exact = context->exact;
@@ -1060,7 +1060,7 @@ static pseudo_t linearize_load_gen(struc
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->result_type;
 		insn->exact = context->exact;
@@ -1075,7 +1075,7 @@ static pseudo_t linearize_load_gen(struc
 				continue;
 			insn = alloc_instruction(OP_CONTEXT, 0);
 			insn->required = context->in;
-			insn->increment = insn->inc_false = context->out - context->in;
+			insn->increment = context->out - context->in;
 			insn->context_expr = context->context;
 			insn->access_var = ad->address->sym;
 			insn->exact = context->exact;
@@ -1320,12 +1320,21 @@ static pseudo_t linearize_call_expressio
 		FOR_EACH_PTR(ctype->contexts, context) {
 			int in = context->in;
 			int out = context->out;
-
-			if (out - in || context->out_false - in) {
+			int check = 0;
+			int context_diff;
+			if (in < 0) {
+				check = 1;
+				in = 0;
+			}
+			if (out < 0) {
+				check = 0;
+				out = 0;
+			}
+			context_diff = out - in;
+			if (check || context_diff) {
 				insn = alloc_instruction(OP_CONTEXT, 0);
-				insn->increment = out - in;
+				insn->increment = context_diff;
 				insn->context_expr = context->context;
-				insn->inc_false = context->out_false - in;
 				add_one_insn(ep, insn);
 			}
 		} END_FOR_EACH_PTR(context);
@@ -1755,7 +1764,6 @@ static pseudo_t linearize_context(struct
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
 
 	insn->increment = stmt->change;
-	insn->inc_false = stmt->change;
 
 	insn->required = stmt->required;
 	insn->exact = stmt->exact;
--- sparse.orig/parse.c	2008-04-27 03:10:44.000000000 +0200
+++ sparse/parse.c	2008-04-27 03:10:52.000000000 +0200
@@ -65,7 +65,6 @@ static struct token *attribute_address_s
 static struct token *attribute_aligned(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_mode(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_exact_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
@@ -189,10 +188,6 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
-static struct symbol_op conditional_context_op = {
-	.attribute = attribute_conditional_context,
-};
-
 static struct symbol_op exact_context_op = {
 	.attribute = attribute_exact_context,
 };
@@ -279,7 +274,6 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
-	{ "conditional_context",	NS_KEYWORD,	.op = &conditional_context_op },
 	{ "exact_context",	NS_KEYWORD,	.op = &exact_context_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
@@ -944,7 +938,6 @@ static struct token *_attribute_context(
 	}
 
 	context->exact = exact;
-	context->out_false = context->out;
 
 	if (argc)
 		add_ptr_list(&ctype->contexts, context);
@@ -963,51 +956,6 @@ static struct token *attribute_exact_con
 	return _attribute_context(token, attr, ctype, 1);
 }
 
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype)
-{
-	struct context *context = alloc_context();
-	struct expression *args[4];
-	int argc = 0;
-
-	token = expect(token, '(', "after conditional_context attribute");
-	while (!match_op(token, ')')) {
-		struct expression *expr = NULL;
-		token = conditional_expression(token, &expr);
-		if (!expr)
-			break;
-		if (argc < 4)
-			args[argc++] = expr;
-		else
-			argc++;
-		if (!match_op(token, ','))
-			break;
-		token = token->next;
-	}
-
-	switch(argc) {
-	case 3:
-		context->in = get_expression_value(args[0]);
-		context->out = get_expression_value(args[1]);
-		context->out_false = get_expression_value(args[2]);
-		break;
-	case 4:
-		context->context = args[0];
-		context->in = get_expression_value(args[1]);
-		context->out = get_expression_value(args[2]);
-		context->out_false = get_expression_value(args[3]);
-		break;
-	default:
-		sparse_error(token->pos, "invalid number of arguments to conditional_context attribute");
-		break;
-	}
-
-	if (argc)
-		add_ptr_list(&ctype->contexts, context);
-
-	token = expect(token, ')', "after conditional_context attribute");
-	return token;
-}
-
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	if (Wtransparent_union)
--- sparse.orig/sparse.1	2008-04-27 03:10:44.000000000 +0200
+++ sparse/sparse.1	2008-04-27 03:10:52.000000000 +0200
@@ -101,15 +101,6 @@ be required on both reads and writes) by
 the token "write" for an optional fourth argument:
 .BI __attribute__((context( expression , in_context , out_context , read|write )).
 
-To indicate that a certain function acquires a context depending on its
-return value, use
-.BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
-where \fIout_success\fR and \fIout_failure\fR indicate the context change
-done depending on success (non-zero) or failure (zero) return of the
-function. Note that currently, using this attribute on a function means that
-the function itself won't be checked for context handling at all. See the
-testsuite for examples.
-
 Sparse will warn when it sees a function change a
 context without indicating this with a \fBcontext\fR or \fBexact_context\fR attribute, either by
 decreasing a context below zero (such as by releasing a lock without acquiring
--- sparse.orig/sparse.c	2008-04-27 03:10:44.000000000 +0200
+++ sparse/sparse.c	2008-04-27 03:14:26.000000000 +0200
@@ -25,7 +25,7 @@
 #include "linearize.h"
 
 struct context_check {
-	int val, val_false;
+	int val;
 	char name[32];
 };
 
@@ -44,7 +44,7 @@ static const char *context_name(struct c
 }
 
 static void context_add(struct context_check_list **ccl, const char *name,
-			int offs, int offs_false)
+			int offs)
 {
 	struct context_check *check, *found = NULL;
 
@@ -62,7 +62,6 @@ static void context_add(struct context_c
 		add_ptr_list(ccl, found);
 	}
 	found->val += offs;
-	found->val_false += offs_false;
 }
 
 static int context_list_has(struct context_check_list *ccl,
@@ -73,12 +72,11 @@ static int context_list_has(struct conte
 	FOR_EACH_PTR(ccl, check) {
 		if (strcmp(c->name, check->name))
 			continue;
-		return check->val == c->val &&
-		       check->val_false == c->val_false;
+		return check->val == c->val;
 	} END_FOR_EACH_PTR(check);
 
 	/* not found is equal to 0 */
-	return c->val == 0 && c->val_false == 0;
+	return c->val == 0;
 }
 
 static int context_lists_equal(struct context_check_list *ccl1,
@@ -107,7 +105,7 @@ static struct context_check_list *checke
 	struct context_check *c;
 
 	FOR_EACH_PTR(ccl, c) {
-		context_add(&result, c->name, c->val_false, c->val_false);
+		context_add(&result, c->name, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	return result;
@@ -140,7 +138,7 @@ static int context_list_check(struct ent
 
 	/* make sure the loop below checks all */
 	FOR_EACH_PTR(ccl_target, c1) {
-		context_add(&ccl_cur, c1->name, 0, 0);
+		context_add(&ccl_cur, c1->name, 0);
 	} END_FOR_EACH_PTR(c1);
 
 	FOR_EACH_PTR(ccl_cur, c1) {
@@ -289,15 +287,14 @@ static int handle_context(struct entrypo
 		return -1;
 	}
 
-	context_add(combined, name, insn->increment, insn->inc_false);
+	context_add(combined, name, insn->increment);
 
 	return 0;
 }
 
 static int check_bb_context(struct entrypoint *ep, struct basic_block *bb,
 			    struct context_check_list *ccl_in,
-			    struct context_check_list *ccl_target,
-			    int in_false)
+			    struct context_check_list *ccl_target)
 {
 	struct context_check_list *combined = NULL, *done;
 	struct context_check *c;
@@ -327,10 +324,7 @@ static int check_bb_context(struct entry
 	 * for the conditional_context() attribute.
 	 */
 	FOR_EACH_PTR(ccl_in, c) {
-		if (in_false)
-			context_add(&combined, c->name, c->val_false, c->val_false);
-		else
-			context_add(&combined, c->name, c->val, c->val);
+		context_add(&combined, c->name, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	/* Add the new context to the list of already-checked contexts */
@@ -356,18 +350,18 @@ static int check_bb_context(struct entry
 		case OP_BR:
 			if (insn->bb_true)
 				if (check_bb_context(ep, insn->bb_true,
-						     combined, ccl_target, 0))
+						     combined, ccl_target))
 					goto out;
 			if (insn->bb_false)
 				if (check_bb_context(ep, insn->bb_false,
-						     combined, ccl_target, 1))
+						     combined, ccl_target))
 					goto out;
 			break;
 		case OP_SWITCH:
 		case OP_COMPUTEDGOTO:
 			FOR_EACH_PTR(insn->multijmp_list, mj) {
 				if (check_bb_context(ep, mj->target,
-					             combined, ccl_target, 0))
+					             combined, ccl_target))
 					goto out;
 			} END_FOR_EACH_PTR(mj);
 			break;
@@ -579,14 +573,11 @@ static void check_context(struct entrypo
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
 		const char *name = context_name(context);
 
-		context_add(&ccl_in, name, context->in, context->in);
-		context_add(&ccl_target, name, context->out, context->out_false);
-		/* we don't currently check the body of trylock functions */
-		if (context->out != context->out_false)
-			return;
+		context_add(&ccl_in, name, context->in);
+		context_add(&ccl_target, name, context->out);
 	} END_FOR_EACH_PTR(context);
 
-	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target, 0);
+	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target);
 	free_ptr_list(&ccl_in);
 	free_ptr_list(&ccl_target);
 	free_bb_context_lists(ep->entry->bb);
--- sparse.orig/symbol.h	2008-04-27 03:10:44.000000000 +0200
+++ sparse/symbol.h	2008-04-27 03:10:52.000000000 +0200
@@ -77,7 +77,7 @@ enum context_read_write_specifier {
 
 struct context {
 	struct expression *context;
-	unsigned int in, out, out_false;
+	unsigned int in, out;
 	int exact;
 	enum context_read_write_specifier rws;
 };
--- sparse.orig/validation/context-dynamic.c	2008-04-27 03:10:44.000000000 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,171 +0,0 @@
-static void a(void) __attribute__ ((context(A, 0, 1)))
-{
-    __context__(A, 1);
-}
-
-static void r(void) __attribute__ ((context(A, 1, 0)))
-{
-    __context__(A, -1);
-}
-
-extern int condition, condition2;
-
-static int tl(void) __attribute__ ((conditional_context(A, 0, 1, 0)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int tl2(void) __attribute__ ((conditional_context(A, 0, 0, 1)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int dummy(void)
-{
-    return condition + condition2;
-}
-
-static int good_trylock1(void)
-{
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock2(void)
-{
-    if (tl()) {
-        r();
-    }
-
-    if (tl()) {
-        r();
-    }
-}
-static int good_trylock3(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    r();
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock4(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    if (tl()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock1(void)
-{
-    a();
-    if (dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_trylock5(void)
-{
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock6(void)
-{
-    if (!tl2()) {
-        r();
-    }
-
-    if (!tl2()) {
-        r();
-    }
-}
-static int good_trylock7(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    r();
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock8(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    if (!tl2()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock2(void)
-{
-    a();
-    if (!dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_switch(void)
-{
-    switch (condition) {
-    case 1:
-        a();
-        break;
-    case 2:
-        a();
-        break;
-    case 3:
-        a();
-        break;
-    default:
-        a();
-    }
-    r();
-}
-
-static void bad_lock1(void)
-{
-    r();
-    a();
-}
-
-/*
- * check-name: Check -Wcontext with lock trylocks
- *
- * check-error-start
-context-dynamic.c:83:6: warning: context problem in 'bad_trylock1': 'r' expected different context
-context-dynamic.c:83:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:133:6: warning: context problem in 'bad_trylock2': 'r' expected different context
-context-dynamic.c:133:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:156:6: warning: context problem in 'bad_lock1': 'r' expected different context
-context-dynamic.c:156:6:    context 'A': wanted >= 1, got 0
- * check-error-end
- */
--- sparse.orig/linearize.h	2008-04-27 03:10:44.000000000 +0200
+++ sparse/linearize.h	2008-04-27 03:11:58.000000000 +0200
@@ -116,7 +116,7 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false, exact;
+			int increment, required, exact;
 			struct expression *context_expr;
 			struct symbol *access_var;
 		};

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/9] evaluate/expand context expressions ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 4/9] evaluate/expand context expressions
Date: Thu, 29 May 2008 08:54:06 +0000
Message-ID: <20080529085515.274212000 () sipsolutions ! net>
--------------------
But still allow having a standalone symbol as the context
expression, also evaluate the context change/requirement
directly in the parser and pass them up as integers. Also
fixes a number of bugs e.g. in the expression copier and
a segfault when the default context is used as such:
   __context__(1,1);

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 evaluate.c           |    9 ++++++++-
 expand.c             |    2 +-
 inline.c             |   19 ++++++++++++-------
 linearize.c          |   17 +++--------------
 parse.c              |   22 +++++++++++++---------
 parse.h              |    6 ++++--
 validation/context.c |   28 ++++++++++++++++++++++++++++
 7 files changed, 69 insertions(+), 34 deletions(-)

--- sparse.orig/evaluate.c	2008-05-11 02:41:01.000000000 +0200
+++ sparse/evaluate.c	2008-05-29 10:21:27.000000000 +0200
@@ -3356,7 +3356,14 @@ struct symbol *evaluate_statement(struct
 		evaluate_asm_statement(stmt);
 		return NULL;
 	case STMT_CONTEXT:
-		evaluate_expression(stmt->expression);
+		/*
+		 * If this is an unknown symbol accept it as-is
+		 * as a context name.
+		 */
+		if (stmt->context &&
+		    (stmt->context->type != EXPR_SYMBOL ||
+		     stmt->context->symbol))
+			evaluate_expression(stmt->context);
 		return NULL;
 	case STMT_RANGE:
 		evaluate_expression(stmt->range_expression);
--- sparse.orig/expand.c	2008-05-11 02:41:01.000000000 +0200
+++ sparse/expand.c	2008-05-29 10:21:27.000000000 +0200
@@ -1169,7 +1169,7 @@ static int expand_statement(struct state
 		/* FIXME! Do the asm parameter evaluation! */
 		break;
 	case STMT_CONTEXT:
-		expand_expression(stmt->expression);
+		expand_expression(stmt->context);
 		break;
 	case STMT_RANGE:
 		expand_expression(stmt->range_expression);
--- sparse.orig/inline.c	2008-05-11 02:41:00.000000000 +0200
+++ sparse/inline.c	2008-05-29 10:21:27.000000000 +0200
@@ -328,7 +328,18 @@ static struct statement *copy_one_statem
 		stmt = newstmt;
 		break;
 	}
-	case STMT_CONTEXT:
+	case STMT_CONTEXT: {
+		struct expression *expr = copy_expression(stmt->context);
+		struct statement *newstmt;
+		if (expr == stmt->context)
+			break;
+		newstmt = dup_statement(stmt);
+		newstmt->context = expr;
+		newstmt->change = stmt->change;
+		newstmt->required = stmt->required;
+		stmt = newstmt;
+		break;
+	}
 	case STMT_EXPRESSION: {
 		struct expression *expr = copy_expression(stmt->expression);
 		struct statement *newstmt;
@@ -336,12 +347,6 @@ static struct statement *copy_one_statem
 			break;
 		newstmt = dup_statement(stmt);
 		newstmt->expression = expr;
-		if (stmt->required) {
-			expr = copy_expression(stmt->required);
-			if (expr == stmt->required)
-				break;
-			newstmt->required = expr;
-		}
 		stmt = newstmt;
 		break;
 	}
--- sparse.orig/linearize.c	2008-05-29 10:15:40.000000000 +0200
+++ sparse/linearize.c	2008-05-29 10:21:28.000000000 +0200
@@ -1753,22 +1753,11 @@ static pseudo_t linearize_inlined_call(s
 static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 {
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
-	struct expression *expr = stmt->expression;
-	int value = 0;
 
-	if (expr->type == EXPR_VALUE)
-		value = expr->value;
+	insn->increment = stmt->change;
+	insn->inc_false = stmt->change;
 
-	insn->increment = value;
-	insn->inc_false = value;
-
-	expr = stmt->required;
-	value = 0;
-
-	if (expr && expr->type == EXPR_VALUE)
-		value = expr->value;
-
-	insn->required = value;
+	insn->required = stmt->required;
 	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
--- sparse.orig/parse.c	2008-05-29 10:15:40.000000000 +0200
+++ sparse/parse.c	2008-05-29 10:21:28.000000000 +0200
@@ -1859,9 +1859,7 @@ static struct token *_parse_context_stat
 		token = token->next;
 	}
 
-	stmt->expression = args[0];
 	stmt->context = NULL;
-
 	stmt->exact = exact;
 
 	switch (argc) {
@@ -1869,21 +1867,27 @@ static struct token *_parse_context_stat
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
 		return token;
 	case 1:
-		/* already done */
+		stmt->change = get_expression_value(args[0]);
 		break;
 	case 2:
-		if (args[0]->type != STMT_EXPRESSION) {
+		/*
+		 * We should actually check whether we can evalulate
+		 * it as a constant expression and if so use as the
+		 * 'change' value. I hope nobody gives a calculation
+		 * for the number.
+		 */
+		if (args[0]->type != EXPR_VALUE) {
 			stmt->context = args[0];
-			stmt->expression = args[1];
+			stmt->change = get_expression_value(args[1]);
 		} else {
-			stmt->expression = args[0];
-			stmt->required = args[1];
+			stmt->change = get_expression_value(args[0]);
+			stmt->required = get_expression_value(args[1]);
 		}
 		break;
 	case 3:
 		stmt->context = args[0];
-		stmt->expression = args[1];
-		stmt->required = args[2];
+		stmt->change = get_expression_value(args[1]);
+		stmt->required = get_expression_value(args[2]);
 		break;
 	default:
 		sparse_error(token->pos, "too many arguments for __context__ statement");
--- sparse.orig/parse.h	2008-05-29 10:15:40.000000000 +0200
+++ sparse/parse.h	2008-05-29 10:21:27.000000000 +0200
@@ -39,10 +39,12 @@ struct statement {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
-		struct { /* __context__ */
+		struct { /* expression */
 			struct expression *expression;
+		};
+		struct { /* __context__ */
 			struct expression *context;
-			struct expression *required;
+			int change, required;
 			int exact;
 		};
 		struct /* return_statement */ {
--- sparse.orig/validation/context.c	2008-05-29 10:14:30.000000000 +0200
+++ sparse/validation/context.c	2008-05-29 10:18:23.000000000 +0200
@@ -395,6 +395,32 @@ static void good_require_caller(void)
     __context__(TEST,-1,1);
 }
 
+static void areq(void) __attribute__((context(1,2)))
+{
+	__context__(1,1);
+}
+
+static void good_reqlock(void)
+{
+	a();
+	areq();
+	r();
+	r();
+}
+
+static void warn_reqlock(void)
+{
+	areq();
+	r();
+}
+
+
+static void dummy1(void) __attribute__((context(p,0,1)))
+{
+        void *p;
+	__context__(p,1);
+}
+
 /*
  * check-name: Check -Wcontext
  *
@@ -433,5 +459,7 @@ context.c:360:10: warning: context probl
 context.c:360:10:    default context: wanted >= 1, got 0
 context.c:380:12: warning: context imbalance in 'warn_conditional': wrong count at exit
 context.c:380:12:    default context: wanted 0, got 1
+context.c:413:6: warning: context problem in 'warn_reqlock': 'areq' expected different context
+context.c:413:6:    default context: wanted >= 1, got 0
  * check-error-end
  */

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/9] revert the conditional_context patch ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 5/9] revert the conditional_context patch
Date: Thu, 29 May 2008 08:54:07 +0000
Message-ID: <20080529085516.064702000 () sipsolutions ! net>
--------------------
This patch removes the conditional_context attribute again, it turned
out that my attempt to do this was rather misguided and contrary to
what I thought we do not gain anything at all over using macros for
it as the kernel and the tests have been doing for a while.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 linearize.c                  |   32 +++++---
 linearize.h                  |    2 
 parse.c                      |   52 -------------
 sparse.1                     |    9 --
 sparse.c                     |   39 +++------
 symbol.h                     |    2 
 validation/context-dynamic.c |  171 -------------------------------------------
 7 files changed, 37 insertions(+), 270 deletions(-)

--- sparse.orig/linearize.c	2008-04-27 03:10:44.000000000 +0200
+++ sparse/linearize.c	2008-04-27 03:16:56.000000000 +0200
@@ -437,7 +437,7 @@ const char *show_instruction(struct inst
 		break;
 
 	case OP_CONTEXT:
-		buf += sprintf(buf, "%s%d,%d", "", insn->increment, insn->inc_false);
+		buf += sprintf(buf, "%d", insn->increment);
 		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
@@ -958,7 +958,7 @@ static pseudo_t linearize_store_gen(stru
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->source_type;
 		insn->exact = context->exact;
@@ -971,7 +971,7 @@ static pseudo_t linearize_store_gen(stru
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->result_type;
 		insn->exact = context->exact;
@@ -986,7 +986,7 @@ static pseudo_t linearize_store_gen(stru
 				continue;
 			insn = alloc_instruction(OP_CONTEXT, 0);
 			insn->required = context->in;
-			insn->increment = insn->inc_false = context->out - context->in;
+			insn->increment = context->out - context->in;
 			insn->context_expr = context->context;
 			insn->access_var = ad->address->sym;
 			insn->exact = context->exact;
@@ -1047,7 +1047,7 @@ static pseudo_t linearize_load_gen(struc
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->source_type;
 		insn->exact = context->exact;
@@ -1060,7 +1060,7 @@ static pseudo_t linearize_load_gen(struc
 			continue;
 		insn = alloc_instruction(OP_CONTEXT, 0);
 		insn->required = context->in;
-		insn->increment = insn->inc_false = context->out - context->in;
+		insn->increment = context->out - context->in;
 		insn->context_expr = context->context;
 		insn->access_var = ad->result_type;
 		insn->exact = context->exact;
@@ -1075,7 +1075,7 @@ static pseudo_t linearize_load_gen(struc
 				continue;
 			insn = alloc_instruction(OP_CONTEXT, 0);
 			insn->required = context->in;
-			insn->increment = insn->inc_false = context->out - context->in;
+			insn->increment = context->out - context->in;
 			insn->context_expr = context->context;
 			insn->access_var = ad->address->sym;
 			insn->exact = context->exact;
@@ -1320,12 +1320,21 @@ static pseudo_t linearize_call_expressio
 		FOR_EACH_PTR(ctype->contexts, context) {
 			int in = context->in;
 			int out = context->out;
-
-			if (out - in || context->out_false - in) {
+			int check = 0;
+			int context_diff;
+			if (in < 0) {
+				check = 1;
+				in = 0;
+			}
+			if (out < 0) {
+				check = 0;
+				out = 0;
+			}
+			context_diff = out - in;
+			if (check || context_diff) {
 				insn = alloc_instruction(OP_CONTEXT, 0);
-				insn->increment = out - in;
+				insn->increment = context_diff;
 				insn->context_expr = context->context;
-				insn->inc_false = context->out_false - in;
 				add_one_insn(ep, insn);
 			}
 		} END_FOR_EACH_PTR(context);
@@ -1755,7 +1764,6 @@ static pseudo_t linearize_context(struct
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
 
 	insn->increment = stmt->change;
-	insn->inc_false = stmt->change;
 
 	insn->required = stmt->required;
 	insn->exact = stmt->exact;
--- sparse.orig/parse.c	2008-04-27 03:10:44.000000000 +0200
+++ sparse/parse.c	2008-04-27 03:10:52.000000000 +0200
@@ -65,7 +65,6 @@ static struct token *attribute_address_s
 static struct token *attribute_aligned(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_mode(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_exact_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
@@ -189,10 +188,6 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
-static struct symbol_op conditional_context_op = {
-	.attribute = attribute_conditional_context,
-};
-
 static struct symbol_op exact_context_op = {
 	.attribute = attribute_exact_context,
 };
@@ -279,7 +274,6 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
-	{ "conditional_context",	NS_KEYWORD,	.op = &conditional_context_op },
 	{ "exact_context",	NS_KEYWORD,	.op = &exact_context_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
@@ -944,7 +938,6 @@ static struct token *_attribute_context(
 	}
 
 	context->exact = exact;
-	context->out_false = context->out;
 
 	if (argc)
 		add_ptr_list(&ctype->contexts, context);
@@ -963,51 +956,6 @@ static struct token *attribute_exact_con
 	return _attribute_context(token, attr, ctype, 1);
 }
 
-static struct token *attribute_conditional_context(struct token *token, struct symbol *attr, struct ctype *ctype)
-{
-	struct context *context = alloc_context();
-	struct expression *args[4];
-	int argc = 0;
-
-	token = expect(token, '(', "after conditional_context attribute");
-	while (!match_op(token, ')')) {
-		struct expression *expr = NULL;
-		token = conditional_expression(token, &expr);
-		if (!expr)
-			break;
-		if (argc < 4)
-			args[argc++] = expr;
-		else
-			argc++;
-		if (!match_op(token, ','))
-			break;
-		token = token->next;
-	}
-
-	switch(argc) {
-	case 3:
-		context->in = get_expression_value(args[0]);
-		context->out = get_expression_value(args[1]);
-		context->out_false = get_expression_value(args[2]);
-		break;
-	case 4:
-		context->context = args[0];
-		context->in = get_expression_value(args[1]);
-		context->out = get_expression_value(args[2]);
-		context->out_false = get_expression_value(args[3]);
-		break;
-	default:
-		sparse_error(token->pos, "invalid number of arguments to conditional_context attribute");
-		break;
-	}
-
-	if (argc)
-		add_ptr_list(&ctype->contexts, context);
-
-	token = expect(token, ')', "after conditional_context attribute");
-	return token;
-}
-
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	if (Wtransparent_union)
--- sparse.orig/sparse.1	2008-04-27 03:10:44.000000000 +0200
+++ sparse/sparse.1	2008-04-27 03:10:52.000000000 +0200
@@ -101,15 +101,6 @@ be required on both reads and writes) by
 the token "write" for an optional fourth argument:
 .BI __attribute__((context( expression , in_context , out_context , read|write )).
 
-To indicate that a certain function acquires a context depending on its
-return value, use
-.BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
-where \fIout_success\fR and \fIout_failure\fR indicate the context change
-done depending on success (non-zero) or failure (zero) return of the
-function. Note that currently, using this attribute on a function means that
-the function itself won't be checked for context handling at all. See the
-testsuite for examples.
-
 Sparse will warn when it sees a function change a
 context without indicating this with a \fBcontext\fR or \fBexact_context\fR attribute, either by
 decreasing a context below zero (such as by releasing a lock without acquiring
--- sparse.orig/sparse.c	2008-04-27 03:10:44.000000000 +0200
+++ sparse/sparse.c	2008-04-27 03:14:26.000000000 +0200
@@ -25,7 +25,7 @@
 #include "linearize.h"
 
 struct context_check {
-	int val, val_false;
+	int val;
 	char name[32];
 };
 
@@ -44,7 +44,7 @@ static const char *context_name(struct c
 }
 
 static void context_add(struct context_check_list **ccl, const char *name,
-			int offs, int offs_false)
+			int offs)
 {
 	struct context_check *check, *found = NULL;
 
@@ -62,7 +62,6 @@ static void context_add(struct context_c
 		add_ptr_list(ccl, found);
 	}
 	found->val += offs;
-	found->val_false += offs_false;
 }
 
 static int context_list_has(struct context_check_list *ccl,
@@ -73,12 +72,11 @@ static int context_list_has(struct conte
 	FOR_EACH_PTR(ccl, check) {
 		if (strcmp(c->name, check->name))
 			continue;
-		return check->val == c->val &&
-		       check->val_false == c->val_false;
+		return check->val == c->val;
 	} END_FOR_EACH_PTR(check);
 
 	/* not found is equal to 0 */
-	return c->val == 0 && c->val_false == 0;
+	return c->val == 0;
 }
 
 static int context_lists_equal(struct context_check_list *ccl1,
@@ -107,7 +105,7 @@ static struct context_check_list *checke
 	struct context_check *c;
 
 	FOR_EACH_PTR(ccl, c) {
-		context_add(&result, c->name, c->val_false, c->val_false);
+		context_add(&result, c->name, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	return result;
@@ -140,7 +138,7 @@ static int context_list_check(struct ent
 
 	/* make sure the loop below checks all */
 	FOR_EACH_PTR(ccl_target, c1) {
-		context_add(&ccl_cur, c1->name, 0, 0);
+		context_add(&ccl_cur, c1->name, 0);
 	} END_FOR_EACH_PTR(c1);
 
 	FOR_EACH_PTR(ccl_cur, c1) {
@@ -289,15 +287,14 @@ static int handle_context(struct entrypo
 		return -1;
 	}
 
-	context_add(combined, name, insn->increment, insn->inc_false);
+	context_add(combined, name, insn->increment);
 
 	return 0;
 }
 
 static int check_bb_context(struct entrypoint *ep, struct basic_block *bb,
 			    struct context_check_list *ccl_in,
-			    struct context_check_list *ccl_target,
-			    int in_false)
+			    struct context_check_list *ccl_target)
 {
 	struct context_check_list *combined = NULL, *done;
 	struct context_check *c;
@@ -327,10 +324,7 @@ static int check_bb_context(struct entry
 	 * for the conditional_context() attribute.
 	 */
 	FOR_EACH_PTR(ccl_in, c) {
-		if (in_false)
-			context_add(&combined, c->name, c->val_false, c->val_false);
-		else
-			context_add(&combined, c->name, c->val, c->val);
+		context_add(&combined, c->name, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	/* Add the new context to the list of already-checked contexts */
@@ -356,18 +350,18 @@ static int check_bb_context(struct entry
 		case OP_BR:
 			if (insn->bb_true)
 				if (check_bb_context(ep, insn->bb_true,
-						     combined, ccl_target, 0))
+						     combined, ccl_target))
 					goto out;
 			if (insn->bb_false)
 				if (check_bb_context(ep, insn->bb_false,
-						     combined, ccl_target, 1))
+						     combined, ccl_target))
 					goto out;
 			break;
 		case OP_SWITCH:
 		case OP_COMPUTEDGOTO:
 			FOR_EACH_PTR(insn->multijmp_list, mj) {
 				if (check_bb_context(ep, mj->target,
-					             combined, ccl_target, 0))
+					             combined, ccl_target))
 					goto out;
 			} END_FOR_EACH_PTR(mj);
 			break;
@@ -579,14 +573,11 @@ static void check_context(struct entrypo
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
 		const char *name = context_name(context);
 
-		context_add(&ccl_in, name, context->in, context->in);
-		context_add(&ccl_target, name, context->out, context->out_false);
-		/* we don't currently check the body of trylock functions */
-		if (context->out != context->out_false)
-			return;
+		context_add(&ccl_in, name, context->in);
+		context_add(&ccl_target, name, context->out);
 	} END_FOR_EACH_PTR(context);
 
-	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target, 0);
+	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target);
 	free_ptr_list(&ccl_in);
 	free_ptr_list(&ccl_target);
 	free_bb_context_lists(ep->entry->bb);
--- sparse.orig/symbol.h	2008-04-27 03:10:44.000000000 +0200
+++ sparse/symbol.h	2008-04-27 03:10:52.000000000 +0200
@@ -77,7 +77,7 @@ enum context_read_write_specifier {
 
 struct context {
 	struct expression *context;
-	unsigned int in, out, out_false;
+	unsigned int in, out;
 	int exact;
 	enum context_read_write_specifier rws;
 };
--- sparse.orig/validation/context-dynamic.c	2008-04-27 03:10:44.000000000 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,171 +0,0 @@
-static void a(void) __attribute__ ((context(A, 0, 1)))
-{
-    __context__(A, 1);
-}
-
-static void r(void) __attribute__ ((context(A, 1, 0)))
-{
-    __context__(A, -1);
-}
-
-extern int condition, condition2;
-
-static int tl(void) __attribute__ ((conditional_context(A, 0, 1, 0)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int tl2(void) __attribute__ ((conditional_context(A, 0, 0, 1)))
-{
-    if (condition) {
-        a();
-        return 1;
-    }
-    return 0;
-}
-
-static int dummy(void)
-{
-    return condition + condition2;
-}
-
-static int good_trylock1(void)
-{
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock2(void)
-{
-    if (tl()) {
-        r();
-    }
-
-    if (tl()) {
-        r();
-    }
-}
-static int good_trylock3(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    r();
-    if (tl()) {
-        r();
-    }
-}
-
-static int good_trylock4(void)
-{
-    a();
-    if (tl()) {
-        r();
-    }
-    if (tl()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock1(void)
-{
-    a();
-    if (dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_trylock5(void)
-{
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock6(void)
-{
-    if (!tl2()) {
-        r();
-    }
-
-    if (!tl2()) {
-        r();
-    }
-}
-static int good_trylock7(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    r();
-    if (!tl2()) {
-        r();
-    }
-}
-
-static int good_trylock8(void)
-{
-    a();
-    if (!tl2()) {
-        r();
-    }
-    if (!tl2()) {
-        r();
-    }
-    r();
-}
-
-static void bad_trylock2(void)
-{
-    a();
-    if (!dummy()) {
-        r();
-    }
-    r();
-}
-
-static int good_switch(void)
-{
-    switch (condition) {
-    case 1:
-        a();
-        break;
-    case 2:
-        a();
-        break;
-    case 3:
-        a();
-        break;
-    default:
-        a();
-    }
-    r();
-}
-
-static void bad_lock1(void)
-{
-    r();
-    a();
-}
-
-/*
- * check-name: Check -Wcontext with lock trylocks
- *
- * check-error-start
-context-dynamic.c:83:6: warning: context problem in 'bad_trylock1': 'r' expected different context
-context-dynamic.c:83:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:133:6: warning: context problem in 'bad_trylock2': 'r' expected different context
-context-dynamic.c:133:6:    context 'A': wanted >= 1, got 0
-context-dynamic.c:156:6: warning: context problem in 'bad_lock1': 'r' expected different context
-context-dynamic.c:156:6:    context 'A': wanted >= 1, got 0
- * check-error-end
- */
--- sparse.orig/linearize.h	2008-04-27 03:10:44.000000000 +0200
+++ sparse/linearize.h	2008-04-27 03:11:58.000000000 +0200
@@ -116,7 +116,7 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false, exact;
+			int increment, required, exact;
 			struct expression *context_expr;
 			struct symbol *access_var;
 		};

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/5] test conditional result locking ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 6/5] test conditional result locking
Date: Sun, 27 Apr 2008 12:23:52 +0000
Message-ID: <1209299032.10943.71.camel () johannes ! berg>
--------------------
To test a function that can return a locked struct or NULL,
a macro has to be invented. Add a test case for that.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
This is a bit awkward but I don't see any good way to do it differently
since otherwise we'd have to track the assignment.

 validation/context-vars.c |   28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

--- sparse.orig/validation/context-vars.c	2008-04-27 14:10:37.000000000 +0200
+++ sparse/validation/context-vars.c	2008-04-27 14:14:25.000000000 +0200
@@ -1,3 +1,5 @@
+#include <stddef.h>
+
 static void a(void *p) __attribute__((context(p,0,1)))
 {
     __context__(p,1);
@@ -159,13 +161,31 @@ static void good_locked_val(void)
     ;
 }
 
+
+extern struct test *_search(int key);
+
+#define search(res, key) do {\
+  res = _search((key)); \
+  (res ? ({ __context__(&res->lock,1); res; }) : NULL); \
+  } while (0)
+
+static void test(void)
+{
+    struct test *x;
+
+    search(x, 32);
+    if (x)
+      unlock(x);
+}
+
+
 /*
  * check-name: Check -Wcontext with lock variables
  *
  * check-error-start
-context-vars.c:53:7: warning: context imbalance in 'warn_lock1': wrong count at exit
-context-vars.c:53:7:    context '**v+4': wanted 0, got 1
-context-vars.c:137:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
-context-vars.c:137:11:    context '*t+0': wanted >= 1, got 0
+context-vars.c:55:7: warning: context imbalance in 'warn_lock1': wrong count at exit
+context-vars.c:55:7:    context '**v+4': wanted 0, got 1
+context-vars.c:139:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
+context-vars.c:139:11:    context '*t+0': wanted >= 1, got 0
  * check-error-end
  */


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/9 v2] check context expressions as expressions ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 6/9 v2] check context expressions as expressions
Date: Wed, 10 Sep 2008 07:33:23 +0000
Message-ID: <1221032003.12266.4.camel () johannes ! berg>
--------------------
This patch makes sparse evaluate context expressions allowing this:

    struct test {
        lock_t lock;
        int i;
    };

    extern void r(struct test *t) __attribute__((context(&t->lock,0,1)));
    extern struct test *find(int i) __attribute__((context(&RESULT->lock,1,0)));

    void test(void)
    {
       struct test *x = find(42);
       r(x);
       r(x);
    }

to work the way you think it would.

This works by rewriting the given attribute expression into __context__
statements and evaluating those in the caller scope.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
Somewhat inspired by Philipp's patch. When it warns, the expression is
given as evaluated, e.g. in above case would result in a warning about
"**x+0". We can fix that later by keeping the original expression and
not expanding/evaluating it, but we need to do both for it to work.

Note that there's a problem: You cannot give RESULT on a static function
that is declared there without getting an error in the function itself...

v2: Harvey found a bug in this by running it on the Linux kernel and
    I also cleaned up some functions and made them static.

 evaluate.c                |   18 ++-
 expand.c                  |    6 +
 expression.c              |  271 +++++++++++++++++++++++++++++++++++++++++++++-
 expression.h              |    5 
 ident-list.h              |    1 
 inline.c                  |    4 
 linearize.c               |   63 ++++++----
 linearize.h               |    1 
 parse.c                   |   17 ++
 parse.h                   |    1 
 sparse.c                  |  144 ++++++------------------
 symbol.h                  |    4 
 validation/context-vars.c |  171 +++++++++++++++++++++++++++++
 13 files changed, 572 insertions(+), 134 deletions(-)

--- sparse.orig/expression.c	2008-09-10 08:56:01.000000000 +0200
+++ sparse/expression.c	2008-09-10 09:27:43.000000000 +0200
@@ -27,6 +27,8 @@
 #include "expression.h"
 #include "target.h"
 
+struct expression *current_assignment_expression = NULL;
+
 static int match_oplist(int op, ...)
 {
 	va_list args;
@@ -509,6 +511,63 @@ static struct token *expression_list(str
 	return token;
 }
 
+static int ident_equal(struct ident *ident1, struct ident *ident2)
+{
+	if (ident1 == ident2)
+		return 1;
+	if (!ident1 || !ident2)
+		return 0;
+
+	return ident1->len == ident2->len &&
+		!strncmp(ident1->name, ident2->name, ident1->len);
+}
+
+/* TODO: this is probably not complete */
+static void replace_ident(struct expression **_in, struct ident *s, struct expression *r)
+{
+	struct expression *in = *_in;
+
+	switch (in->type) {
+	case EXPR_SYMBOL:
+		if (ident_equal(in->symbol_name, s))
+			*_in = r;
+		break;
+	case EXPR_IDENTIFIER:
+		if (ident_equal(in->expr_ident, s))
+			*_in = r;
+		break;
+	case EXPR_BINOP:
+	case EXPR_COMMA:
+	case EXPR_ASSIGNMENT:
+	case EXPR_COMPARE:
+	case EXPR_LOGICAL:
+		replace_ident(&in->left, s, r);
+		replace_ident(&in->right, s, r);
+		break;
+	case EXPR_DEREF:
+		replace_ident(&in->deref, s, r);
+		break;
+	case EXPR_PREOP:
+	case EXPR_POSTOP:
+		replace_ident(&in->unop, s, r);
+		break;
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+	case EXPR_SIZEOF:
+		replace_ident(&in->cast_expression, s, r);
+		break;
+	case EXPR_SLICE:
+		replace_ident(&in->base, s, r);
+		break;
+	case EXPR_CONDITIONAL:
+		replace_ident(&in->conditional, s, r);
+		replace_ident(&in->cond_true, s, r);
+		replace_ident(&in->cond_false, s, r);
+		break;
+	}
+}
+
 /*
  * extend to deal with the ambiguous C grammar for parsing
  * a cast expressions followed by an initializer.
@@ -570,10 +629,49 @@ static struct token *postfix_expression(
 
 		case '(': {			/* Function call */
 			struct expression *call = alloc_expression(token->pos, EXPR_CALL);
+			struct symbol *fn = NULL;
+			struct context *c;
+
+			if (expr->symbol_name)
+				fn = lookup_symbol(expr->symbol_name, NS_SYMBOL);
 			call->op = '(';
 			call->fn = expr;
 			token = expression_list(token->next, &call->args);
 			token = expect(token, ')', "in function call");
+			if (fn && fn->ctype.base_type) {
+				FOR_EACH_PTR(fn->ctype.contexts, c) {
+					struct context *copy = alloc_context();
+					struct symbol *fn_arg;
+					struct expression *passed_arg;
+
+					copy->in = c->in;
+					copy->out = c->out;
+					copy->exact = c->exact;
+					add_ptr_list(&call->contexts, copy);
+
+					if (!c->token)
+						continue;
+
+					/* re-parse the token at this place */
+					conditional_expression(c->token, &copy->context);
+
+					copy->context->pos = expr->pos;
+
+					if (current_assignment_expression)
+						replace_ident(&copy->context, &RESULT_ident,
+							      current_assignment_expression);
+
+					/* and replace the arg */
+					PREPARE_PTR_LIST(fn->ctype.base_type->arguments, fn_arg);
+					FOR_EACH_PTR(call->args, passed_arg);
+					if (fn_arg && passed_arg->type != EXPR_CALL)
+						replace_ident(&copy->context, fn_arg->ident, passed_arg);
+					NEXT_PTR_LIST(fn_arg);
+					END_FOR_EACH_PTR(passed_arg);
+					FINISH_PTR_LIST(fn_arg);
+				} END_FOR_EACH_PTR(c);
+			}
+
 			expr = call;
 			continue;
 		}
@@ -894,6 +992,7 @@ struct token *conditional_expression(str
 
 struct token *assignment_expression(struct token *token, struct expression **tree)
 {
+	struct expression *old_cae = current_assignment_expression;
 	token = conditional_expression(token, tree);
 	if (*tree && token_type(token) == TOKEN_SPECIAL) {
 		static const int assignments[] = {
@@ -904,15 +1003,19 @@ struct token *assignment_expression(stru
 			SPECIAL_SHR_ASSIGN, SPECIAL_AND_ASSIGN,
 			SPECIAL_OR_ASSIGN,  SPECIAL_XOR_ASSIGN };
 		int i, op = token->special;
+		if (op == '=')
+			current_assignment_expression = *tree;
 		for (i = 0; i < sizeof(assignments)/sizeof(int); i++)
 			if (assignments[i] == op) {
 				struct expression * expr = alloc_expression(token->pos, EXPR_ASSIGNMENT);
 				expr->left = *tree;
 				expr->op = op;
 				*tree = expr;
-				return assignment_expression(token->next, &expr->right);
+				token = assignment_expression(token->next, &expr->right);
+				break;
 			}
 	}
+	current_assignment_expression = old_cae;
 	return token;
 }
 
@@ -929,4 +1032,170 @@ struct token *parse_expression(struct to
 	return comma_expression(token,tree);
 }
 
+int expressions_equal(const struct expression *expr1,
+		      const struct expression *expr2)
+{
+	if (expr1 == expr2)
+		return 1;
+
+	if (expr1 == NULL || expr2 == NULL)
+		return 0;
 
+	/* Is this the right way to handle casts? */
+	if (expr1->type == EXPR_CAST ||
+	    expr1->type == EXPR_FORCE_CAST ||
+	    expr1->type == EXPR_IMPLIED_CAST)
+		return expressions_equal(expr1->cast_expression, expr2);
+
+	if (expr2->type == EXPR_CAST ||
+	    expr2->type == EXPR_FORCE_CAST ||
+	    expr2->type == EXPR_IMPLIED_CAST)
+		return expressions_equal(expr2->cast_expression, expr1);
+
+	if (expr1->type != expr2->type)
+		return 0;
+
+	switch (expr1->type) {
+	case EXPR_SYMBOL:
+		return ident_equal(expr1->symbol_name, expr2->symbol_name);
+
+	case EXPR_VALUE:
+		return expr1->value == expr2->value;
+
+	case EXPR_FVALUE:
+		return expr1->fvalue == expr2->fvalue;
+
+	case EXPR_STRING:
+		return expr1->string->length == expr2->string->length &&
+			!strncmp(expr1->string->data, expr2->string->data, expr1->string->length);
+
+	case EXPR_BINOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_COMMA:
+	case EXPR_ASSIGNMENT:
+		return expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_DEREF:
+		return expressions_equal(expr1->deref, expr2->deref) &&
+			ident_equal(expr1->member, expr2->member);
+
+	case EXPR_PREOP:
+	case EXPR_POSTOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->unop, expr2->unop);
+
+	/* Not needed right now, but for sake of completness ...
+	case EXPR_LABEL:
+	case EXPR_STATEMENT:
+	case EXPR_CALL:
+	case EXPR_LOGICAL:
+	case EXPR_COMPARE:
+	case EXPR_SELECT:
+	case EXPR_CONDITIONAL:
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+	case EXPR_SLICE:
+	case EXPR_INITIALIZER:
+	case EXPR_POS:
+	*/
+
+	default:
+		/* nothing, we should already have had a warning */
+		;
+	}
+
+	return 0;
+}
+
+static int ident_str(struct ident *ident, char *buffer, int length)
+{
+	if (!ident)
+		return 0;
+	return snprintf(buffer, length, "%.*s", ident->len, ident->name);
+}
+
+int expression_str(const struct expression *expr,
+		   char *buffer, int length)
+{
+	int n;
+
+	memset(buffer, 0, length);
+
+	if (!expr)
+		return 0;
+
+	/* TODO, think about necessary parentheses () */
+
+	switch (expr->type) {
+	case EXPR_SYMBOL:
+		return ident_str(expr->symbol_name, buffer, length);
+
+	case EXPR_VALUE:
+		return snprintf(buffer, length, "%llu", expr->value);
+
+	case EXPR_FVALUE:
+		return snprintf(buffer, length, "%Lf", expr->fvalue);
+
+	case EXPR_STRING:
+		return snprintf(buffer, length, "\"%.*s\"", expr->string->length, expr->string->data);
+
+	case EXPR_BINOP:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_COMMA:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, ",");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_ASSIGNMENT:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "=");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_DEREF:
+		if (expr->left->type == EXPR_PREOP &&
+		    expr->left->op == '*') {
+			n  = expression_str(expr->left->unop, buffer, length);
+			n += snprintf(buffer+n, length-n, "->");
+			n += ident_str(expr->member, buffer+n, length-n);
+		} else {
+			n  = expression_str(expr->left, buffer, length);
+			n += snprintf(buffer+n, length-n, ".");
+			n += ident_str(expr->member, buffer+n, length-n);
+		}
+		return n;
+
+	case EXPR_PREOP:
+		n  = snprintf(buffer, length, "%c", expr->op);
+		n += expression_str(expr->unop, buffer+n, length-n);
+		return n;
+
+	case EXPR_POSTOP:
+		n  = expression_str(expr->unop, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		return n;
+
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+		/* todo: print out the cast type's ctype */
+		*buffer++ = '('; length--;
+		*buffer++ = ')'; length--;
+		return expression_str(expr->cast_expression, buffer, length) + 2;
+
+	default:
+		printf("Missing code in expression_str for %d\n", expr->type);
+	}
+
+	return 0;
+}
--- sparse.orig/expression.h	2008-09-10 08:56:01.000000000 +0200
+++ sparse/expression.h	2008-09-10 09:06:18.000000000 +0200
@@ -121,6 +121,7 @@ struct expression {
 		struct /* call_expr */ {
 			struct expression *fn;
 			struct expression_list *args;
+			struct context_list *contexts;
 		};
 		// EXPR_LABEL
 		struct /* label_expr */ {
@@ -216,4 +217,8 @@ struct token *compound_statement(struct 
 void cast_value(struct expression *expr, struct symbol *newtype,
 	struct expression *old, struct symbol *oldtype);
 
+int expressions_equal(const struct expression *expr1,
+		      const struct expression *expr2);
+int expression_str(const struct expression *, char *buf, int buflen);
+extern struct expression *current_assignment_expression;
 #endif
--- sparse.orig/sparse.c	2008-09-10 08:56:02.000000000 +0200
+++ sparse/sparse.c	2008-09-10 09:13:55.000000000 +0200
@@ -26,7 +26,7 @@
 
 struct context_check {
 	int val;
-	char name[32];
+	const struct expression *expr;
 };
 
 DECLARE_ALLOCATOR(context_check);
@@ -34,22 +34,15 @@ DECLARE_PTR_LIST(context_check_list, str
 DECLARE_PTR_LIST(context_list_list, struct context_check_list);
 ALLOCATOR(context_check, "context check list");
 
-static const char *unnamed_context = "<unnamed>";
 
-static const char *context_name(struct context *context)
-{
-	if (context->context && context->context->symbol_name)
-		return show_ident(context->context->symbol_name);
-	return unnamed_context;
-}
-
-static void context_add(struct context_check_list **ccl, const char *name,
+static void context_add(struct context_check_list **ccl,
+			const struct expression *expr,
 			int offs)
 {
 	struct context_check *check, *found = NULL;
 
 	FOR_EACH_PTR(*ccl, check) {
-		if (strcmp(name, check->name))
+		if (!expressions_equal(expr, check->expr))
 			continue;
 		found = check;
 		break;
@@ -57,8 +50,7 @@ static void context_add(struct context_c
 
 	if (!found) {
 		found = __alloc_context_check(0);
-		strncpy(found->name, name, sizeof(found->name));
-		found->name[sizeof(found->name) - 1] = '\0';
+		found->expr = expr;
 		add_ptr_list(ccl, found);
 	}
 	found->val += offs;
@@ -70,7 +62,7 @@ static int context_list_has(struct conte
 	struct context_check *check;
 
 	FOR_EACH_PTR(ccl, check) {
-		if (strcmp(c->name, check->name))
+		if (!expressions_equal(c->expr, check->expr))
 			continue;
 		return check->val == c->val;
 	} END_FOR_EACH_PTR(check);
@@ -105,7 +97,7 @@ static struct context_check_list *checke
 	struct context_check *c;
 
 	FOR_EACH_PTR(ccl, c) {
-		context_add(&result, c->name, c->val);
+		context_add(&result, c->expr, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	return result;
@@ -115,15 +107,15 @@ static struct context_check_list *checke
 #define CONTEXT_PROB "context problem in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
-static void get_context_string(char **buf, const char **name)
+static const char *get_context_string(char **buf, const char *name)
 {
-	if (strcmp(*name, unnamed_context)) {
-		*buf = malloc(strlen(*name) + 16);
-		sprintf(*buf, "   context '%s': ", *name);
-		*name = *buf;
+	if (strlen(name)) {
+		*buf = malloc(strlen(name) + 16);
+		sprintf(*buf, "   context '%s': ", name);
+		return *buf;
 	} else {
-		*name = DEFAULT_CONTEXT_DESCR;
 		*buf = NULL;
+		return DEFAULT_CONTEXT_DESCR;
 	}
 }
 
@@ -133,12 +125,13 @@ static int context_list_check(struct ent
 {
 	struct context_check *c1, *c2;
 	int cur, tgt;
-	const char *name;
+	char name[1000];
 	char *buf;
+	const char *pname;
 
 	/* make sure the loop below checks all */
 	FOR_EACH_PTR(ccl_target, c1) {
-		context_add(&ccl_cur, c1->name, 0);
+		context_add(&ccl_cur, c1->expr, 0);
 	} END_FOR_EACH_PTR(c1);
 
 	FOR_EACH_PTR(ccl_cur, c1) {
@@ -146,7 +139,7 @@ static int context_list_check(struct ent
 		tgt = 0;
 
 		FOR_EACH_PTR(ccl_target, c2) {
-			if (strcmp(c2->name, c1->name))
+			if (!expressions_equal(c1->expr, c2->expr))
 				continue;
 			tgt = c2->val;
 			break;
@@ -162,11 +155,11 @@ static int context_list_check(struct ent
 			warning(pos, IMBALANCE_IN "unexpected unlock",
 				show_ident(ep->name->ident));
 
-		name = c1->name;
-		get_context_string(&buf, &name);
+		expression_str(c1->expr, name, sizeof(name));
+		pname = get_context_string(&buf, name);
 
 		info(pos, "%swanted %d, got %d",
-		     name, tgt, cur);
+		     pname, tgt, cur);
 
 		free(buf);
 
@@ -176,83 +169,21 @@ static int context_list_check(struct ent
 	return 0;
 }
 
-static int handle_call(struct entrypoint *ep, struct basic_block *bb,
-		       struct instruction *insn,
-		       struct context_check_list *combined)
-{
-	struct context *ctx;
-	struct context_check *c;
-	const char *name, *call, *cmp;
-	char *buf;
-	int val, ok;
-
-	if (!insn->func || !insn->func->sym ||
-	    insn->func->type != PSEUDO_SYM)
-		return 0;
-
-	/*
-	 * Check all contexts the function wants.
-	 */
-	FOR_EACH_PTR(insn->func->sym->ctype.contexts, ctx) {
-		name = context_name(ctx);
-		val = 0;
-
-		FOR_EACH_PTR(combined, c) {
-			if (strcmp(c->name, name) == 0) {
-				val = c->val;
-				break;
-			}
-		} END_FOR_EACH_PTR(c);
-
-		if (ctx->exact) {
-			ok = ctx->in == val;
-			cmp = "";
-		} else {
-			ok = ctx->in <= val;
-			cmp = ">= ";
-		}
-
-		if (!ok && Wcontext) {
-			get_context_string(&buf, &name);
-			call = strdup(show_ident(insn->func->ident));
-
-			warning(insn->pos, "context problem in '%s': "
-				"'%s' expected different context",
-				show_ident(ep->name->ident), call);
-
-			info(insn->pos, "%swanted %s%d, got %d",
-			     name, cmp, ctx->in, val);
-
-			free((void *)call);
-			free(buf);
-
-			return -1;
-		}
-	} END_FOR_EACH_PTR (ctx);
-
-	return 0;
-}
-
 static int handle_context(struct entrypoint *ep, struct basic_block *bb,
 			  struct instruction *insn,
 			  struct context_check_list **combined)
 {
 	struct context_check *c;
-	const char *name, *cmp;
+	const char *cmp, *pname;
 	char *buf;
+	char name[1000];
 	int val, ok;
 
 	val = 0;
 
-	name = unnamed_context;
-	if (insn->context_expr)
-		name = show_ident(insn->context_expr->symbol_name);
-
 	FOR_EACH_PTR(*combined, c) {
-		if (strcmp(c->name, name) == 0) {
+		if (expressions_equal(c->expr, insn->context_expr))
 			val = c->val;
-			break;
-		}
 	} END_FOR_EACH_PTR(c);
 
 	if (insn->exact) {
@@ -264,7 +195,8 @@ static int handle_context(struct entrypo
 	}
 
 	if (!ok && Wcontext) {
-		get_context_string(&buf, &name);
+		expression_str(insn->context_expr, name, sizeof(name));
+		pname = get_context_string(&buf, name);
 
 		if (insn->access_var) {
 			char *symname = strdup(show_ident(insn->access_var->ident));
@@ -273,6 +205,13 @@ static int handle_context(struct entrypo
 				"access to '%s' requires different context",
 				show_ident(ep->name->ident), symname);
 			free(symname);
+		} else if (insn->called_fn) {
+			char *symname = strdup(show_ident(insn->called_fn->ident));
+			warning(insn->pos,
+				CONTEXT_PROB
+				"'%s' expected different context",
+				show_ident(ep->name->ident), symname);
+			free(symname);
 		} else {
 			warning(insn->pos,
 				CONTEXT_PROB
@@ -281,13 +220,13 @@ static int handle_context(struct entrypo
 		}
 
 		info(insn->pos, "%swanted %s%d, got %d",
-		     name, cmp, insn->required, val);
+		     pname, cmp, insn->required, val);
 
 		free(buf);
 		return -1;
 	}
 
-	context_add(combined, name, insn->increment);
+	context_add(combined, insn->context_expr, insn->increment);
 
 	return 0;
 }
@@ -324,7 +263,7 @@ static int check_bb_context(struct entry
 	 * for the conditional_context() attribute.
 	 */
 	FOR_EACH_PTR(ccl_in, c) {
-		context_add(&combined, c->name, c->val);
+		context_add(&combined, c->expr, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	/* Add the new context to the list of already-checked contexts */
@@ -338,11 +277,6 @@ static int check_bb_context(struct entry
 	 */
 	FOR_EACH_PTR(bb->insns, insn) {
 		switch (insn->opcode) {
-		case OP_INLINED_CALL:
-		case OP_CALL:
-			if (handle_call(ep, bb, insn, combined))
-				goto out;
-			break;
 		case OP_CONTEXT:
 			if (handle_context(ep, bb, insn, &combined))
 				goto out;
@@ -571,10 +505,10 @@ static void check_context(struct entrypo
 	check_instructions(ep);
 
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
-		const char *name = context_name(context);
-
-		context_add(&ccl_in, name, context->in);
-		context_add(&ccl_target, name, context->out);
+		context_add(&ccl_in, context->in_fn,
+			    context->in);
+		context_add(&ccl_target, context->in_fn,
+			    context->out);
 	} END_FOR_EACH_PTR(context);
 
 	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target);
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-vars.c	2008-09-10 09:13:56.000000000 +0200
@@ -0,0 +1,171 @@
+static void a(void *p) __attribute__((context(p,0,1)))
+{
+    __context__(p,1);
+}
+
+static void r(void *p) __attribute__((context(p,1,0)))
+{
+    __context__(p,-1,1);
+}
+
+extern void *l1, *l2;
+
+static void good_paired1(void)
+{
+    a(l1);
+    r(l1);
+}
+
+static void good_paired2(void)
+{
+    a(l1);
+    r(l1);
+    a(l1);
+    r(l1);
+    a(l2);
+    r(l2);
+}
+
+static void good_paired3(void)
+{
+    a(l1);
+    a(l2);
+    r(l2);
+    r(l1);
+}
+
+static void good_lock1(void *lp) __attribute__((context(lp,0,1)))
+{
+    a(lp);
+}
+
+static void good_lock2(void *lp) __attribute__((context(lp,0,1)))
+{
+    a(lp);
+    r(lp);
+    a(lp);
+}
+
+extern void **v;
+
+static void warn_lock1(void)
+{
+    a(v[1]);
+}
+
+extern int condition;
+
+static void good_lock3(void)
+{
+    a(v[1]);
+    if (condition) {
+        a(v[2]);
+        r(v[2]);
+    }
+    r(v[1]);
+}
+
+#define cond_lock(x, c)\
+  ((c) ? ({ __context__(x,1); 1; }) : 0)
+
+#define trylock(x) \
+    cond_lock(x, _try_lock(x))
+
+extern void _try_lock(int *x);
+
+static int good_condlock1(void)
+{
+    if (trylock(v[0]))
+        r(v[0]);
+}
+
+static int good_condlock2(void)
+{
+    if (trylock(&condition))
+        r((void*)&condition);
+}
+
+extern void ai(int *p) __attribute__((context(p,0,1)));
+extern void ri(int *p) __attribute__((context(p,1,0)));
+
+struct test {
+    int lock;
+};
+
+static inline void unlock(struct test *y)
+    __attribute__((context(&y->lock,1,0)))
+{
+    ri(&y->lock);
+}
+
+static void good_lock4(struct test *t)
+    __attribute__((context(&t->lock,0,1)))
+{
+    ai(&t->lock);
+}
+
+extern int *find_locked(void) __attribute__((context(RESULT,0,1)));
+
+static void good_find_release1(void)
+{
+    int *p;
+
+    p = find_locked();
+    ri(p);
+}
+
+extern struct test *find_locked_struct(void) __attribute__((context(&RESULT->lock,0,1)));
+
+static void good_find_release2(void)
+{
+    struct test *t;
+
+    t = find_locked_struct();
+    unlock(t);
+}
+
+static void good_find_release3(void)
+{
+    struct test *t = find_locked_struct();
+    unlock(t);
+}
+
+static void warn_unlock(void)
+{
+    struct test *t;
+    /* check that the warning is here, not at the unlock definition */
+    unlock(t);
+}
+
+extern int _locked_struct_test(struct test *ls, int *flags);
+#define locked_struct_test(ls, flags) (( _locked_struct_test((ls), (flags)) ) ? ({ __context__(&ls->lock,1); 1;}) : 0)
+
+static inline void unlock2(struct test *y)
+    __attribute__((context(&y->lock,1,0)))
+{
+    unlock(y);
+}
+
+static void good_locked_val(void)
+{
+    struct test *t;
+    int flags;
+
+    if (!t || !locked_struct_test(t, &flags))
+        goto out;
+
+    unlock2(t);
+ out:
+    ;
+}
+
+/*
+ * check-name: Check -Wcontext with lock variables
+ *
+ * check-error-start
+context-vars.c:53:7: warning: context imbalance in 'warn_lock1': wrong count at exit
+context-vars.c:53:7:    context '**v+4': wanted 0, got 1
+context-vars.c:137:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
+context-vars.c:137:11:    context '*t+0': wanted >= 1, got 0
+ * check-error-end
+ */
--- sparse.orig/evaluate.c	2008-09-10 08:56:02.000000000 +0200
+++ sparse/evaluate.c	2008-09-10 08:56:34.000000000 +0200
@@ -2954,8 +2954,16 @@ struct symbol *evaluate_expression(struc
 		return evaluate_alignof(expr);
 	case EXPR_DEREF:
 		return evaluate_member_dereference(expr);
-	case EXPR_CALL:
+	case EXPR_CALL: {
+		struct context *c;
+		FOR_EACH_PTR(expr->contexts, c) {
+			if (c->context &&
+			    (c->context->type != EXPR_SYMBOL ||
+			     c->context->symbol))
+				evaluate_expression(c->context);
+		} END_FOR_EACH_PTR(c);
 		return evaluate_call(expr);
+	}
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL:
 		return evaluate_conditional_expression(expr);
@@ -3025,6 +3033,7 @@ static void check_duplicates(struct symb
 static struct symbol *evaluate_symbol(struct symbol *sym)
 {
 	struct symbol *base_type;
+	struct context *c;
 
 	if (!sym)
 		return sym;
@@ -3054,6 +3063,13 @@ static struct symbol *evaluate_symbol(st
 			evaluate_statement(base_type->stmt);
 
 		current_fn = curr;
+
+		FOR_EACH_PTR(sym->ctype.contexts, c) {
+		if (c->in_fn &&
+		    (c->in_fn->type != EXPR_SYMBOL ||
+		     c->in_fn->symbol))
+			evaluate_expression(c->in_fn);
+		} END_FOR_EACH_PTR(c);
 	}
 
 	return base_type;
--- sparse.orig/expand.c	2008-09-10 08:56:02.000000000 +0200
+++ sparse/expand.c	2008-09-10 08:56:34.000000000 +0200
@@ -1034,8 +1034,14 @@ int expand_symbol(struct symbol *sym)
 	retval = expand_expression(sym->initializer);
 	/* expand the body of the symbol */
 	if (base_type->type == SYM_FN) {
+		struct context *c;
+
 		if (base_type->stmt)
 			expand_statement(base_type->stmt);
+
+		FOR_EACH_PTR(sym->ctype.contexts, c) {
+			expand_expression(c->in_fn);
+		} END_FOR_EACH_PTR(c);
 	}
 	return retval;
 }
--- sparse.orig/parse.c	2008-09-10 08:56:01.000000000 +0200
+++ sparse/parse.c	2008-09-10 08:56:34.000000000 +0200
@@ -879,12 +879,13 @@ static struct token *_attribute_context(
 	struct context *context = alloc_context();
 	struct expression *args[4];
 	int argc = 0;
-	struct token *last = NULL;
+	struct token *first = NULL, *last = NULL;
 
 	token = expect(token, '(', "after context attribute");
 	while (!match_op(token, ')')) {
 		struct expression *expr = NULL;
 		last = token;
+		first = first ? : token;
 		token = conditional_expression(token, &expr);
 		if (!expr)
 			break;
@@ -910,12 +911,14 @@ static struct token *_attribute_context(
 		break;
 	case 3:
 		context->context = args[0];
+		context->token = first;
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 		break;
 	case 4: {
 		const char *rw;
 		context->context = args[0];
+		context->token = first;
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 
@@ -2096,6 +2099,7 @@ static struct token *parse_function_body
 	struct symbol *base_type = decl->ctype.base_type;
 	struct statement *stmt, **p;
 	struct symbol *arg;
+	struct context *c;
 
 	old_symbol_list = function_symbol_list;
 	if (decl->ctype.modifiers & MOD_INLINE) {
@@ -2124,6 +2128,11 @@ static struct token *parse_function_body
 
 	token = compound_statement(token->next, stmt);
 
+	FOR_EACH_PTR(decl->ctype.contexts, c) {
+		if (c->token)
+			conditional_expression(c->token, &c->in_fn);
+	} END_FOR_EACH_PTR(c);
+
 	end_function(decl);
 	if (!(decl->ctype.modifiers & MOD_INLINE))
 		add_symbol(list, decl);
@@ -2286,11 +2295,17 @@ struct token *external_declaration(struc
 
 	for (;;) {
 		if (!is_typedef && match_op(token, '=')) {
+			struct expression *old_cae = current_assignment_expression;
 			if (decl->ctype.modifiers & MOD_EXTERN) {
 				warning(decl->pos, "symbol with external linkage has initializer");
 				decl->ctype.modifiers &= ~MOD_EXTERN;
 			}
+			current_assignment_expression = alloc_expression(token->pos, EXPR_SYMBOL);
+			current_assignment_expression->symbol_name = decl->ident;
+			current_assignment_expression->symbol =
+				lookup_symbol(decl->ident, NS_SYMBOL | NS_TYPEDEF);
 			token = initializer(&decl->initializer, token->next);
+			current_assignment_expression = old_cae;
 		}
 		if (!is_typedef) {
 			if (!(decl->ctype.modifiers & (MOD_EXTERN | MOD_INLINE))) {
--- sparse.orig/symbol.h	2008-09-10 08:56:01.000000000 +0200
+++ sparse/symbol.h	2008-09-10 08:56:34.000000000 +0200
@@ -77,6 +77,10 @@ enum context_read_write_specifier {
 
 struct context {
 	struct expression *context;
+	/* store the token pointer */
+	struct token *token;
+	/* to re-evaluate this context within the function it is for */
+	struct expression *in_fn;
 	unsigned int in, out;
 	int exact;
 	enum context_read_write_specifier rws;
--- sparse.orig/inline.c	2008-09-10 08:56:01.000000000 +0200
+++ sparse/inline.c	2008-09-10 09:00:00.000000000 +0200
@@ -56,7 +56,7 @@ static struct symbol_list *copy_symbol_l
 	return dst;
 }
 
-static struct expression * copy_expression(struct expression *expr)
+static struct expression *copy_expression(struct expression *expr)
 {
 	if (!expr)
 		return NULL;
@@ -474,6 +474,7 @@ void copy_statement(struct statement *sr
 	dst->args = copy_one_statement(src->args);
 	dst->ret = copy_symbol(src->pos, src->ret);
 	dst->inline_fn = src->inline_fn;
+	dst->inlined_fn_expr = src->inlined_fn_expr;
 }
 
 static struct symbol *create_copy_symbol(struct symbol *orig)
@@ -555,6 +556,7 @@ int inline_function(struct expression *e
 		stmt->args = decl;
 	}
 	stmt->inline_fn = sym;
+	stmt->inlined_fn_expr = expr;
 
 	unset_replace_list(fn_symbol_list);
 
--- sparse.orig/linearize.c	2008-09-10 08:56:02.000000000 +0200
+++ sparse/linearize.c	2008-09-10 09:13:56.000000000 +0200
@@ -35,6 +35,7 @@ static pseudo_t linearize_initializer(st
 struct pseudo void_pseudo = {};
 
 static struct position current_pos;
+static int in_inline_skip_context = 0;
 
 ALLOCATOR(pseudo_user, "pseudo_user");
 
@@ -436,9 +437,15 @@ const char *show_instruction(struct inst
 		buf += sprintf(buf, "%s <- %s", show_pseudo(insn->target), show_pseudo(insn->src1));
 		break;
 
-	case OP_CONTEXT:
+	case OP_CONTEXT: {
+		char ctxbuf[100];
+		if (insn->context_expr) {
+			expression_str(insn->context_expr, ctxbuf, sizeof(ctxbuf));
+			buf += sprintf(buf, "%s, ", ctxbuf);
+		}
 		buf += sprintf(buf, "%d", insn->increment);
 		break;
+	}
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
 		break;
@@ -1280,7 +1287,7 @@ static pseudo_t linearize_call_expressio
 	struct instruction *insn = alloc_typed_instruction(OP_CALL, expr->ctype);
 	pseudo_t retval, call;
 	struct ctype *ctype = NULL;
-	struct context *context;
+	struct context *c;
 
 	if (!expr->ctype) {
 		warning(expr->pos, "call with no type!");
@@ -1316,29 +1323,17 @@ static pseudo_t linearize_call_expressio
 	insn->target = retval;
 	add_one_insn(ep, insn);
 
-	if (ctype) {
-		FOR_EACH_PTR(ctype->contexts, context) {
-			int in = context->in;
-			int out = context->out;
-			int check = 0;
-			int context_diff;
-			if (in < 0) {
-				check = 1;
-				in = 0;
-			}
-			if (out < 0) {
-				check = 0;
-				out = 0;
-			}
-			context_diff = out - in;
-			if (check || context_diff) {
-				insn = alloc_instruction(OP_CONTEXT, 0);
-				insn->increment = context_diff;
-				insn->context_expr = context->context;
-				add_one_insn(ep, insn);
-			}
-		} END_FOR_EACH_PTR(context);
-	}
+	if (!in_inline_skip_context)
+		FOR_EACH_PTR(expr->contexts, c) {
+			struct instruction *tmp = alloc_instruction(OP_CONTEXT, 0);
+			tmp->increment = c->out - c->in;
+			tmp->exact = c->exact;
+			tmp->context_expr = c->context;
+			tmp->required = c->in;
+			tmp->called_fn = call->sym;
+			tmp->pos = insn->pos;
+			add_one_insn(ep, tmp);
+		} END_FOR_EACH_PTR(c);
 
 	return retval;
 }
@@ -1712,6 +1707,8 @@ static pseudo_t linearize_compound_state
 
 	pseudo = VOID;
 	FOR_EACH_PTR(stmt->stmts, s) {
+		if (in_inline_skip_context && s->type == STMT_CONTEXT)
+			continue;
 		pseudo = linearize_statement(ep, s);
 	} END_FOR_EACH_PTR(s);
 
@@ -1739,6 +1736,7 @@ static pseudo_t linearize_inlined_call(s
 	struct statement *args = stmt->args;
 	struct basic_block *bb;
 	pseudo_t pseudo;
+	struct context *c;
 
 	if (args) {
 		struct symbol *sym;
@@ -1750,12 +1748,27 @@ static pseudo_t linearize_inlined_call(s
 		} END_FOR_EACH_PTR(sym);
 	}
 
+	in_inline_skip_context++;
 	insn->target = pseudo = linearize_compound_statement(ep, stmt);
+	in_inline_skip_context--;
 	use_pseudo(insn, symbol_pseudo(ep, stmt->inline_fn), &insn->func);
 	bb = ep->active;
 	if (bb && !bb->insns)
 		bb->pos = stmt->pos;
 	add_one_insn(ep, insn);
+
+	if (!in_inline_skip_context)
+		FOR_EACH_PTR(stmt->inlined_fn_expr->contexts, c) {
+			struct instruction *tmp = alloc_instruction(OP_CONTEXT, 0);
+			tmp->increment = c->out - c->in;
+			tmp->exact = c->exact;
+			tmp->context_expr = c->context;
+			tmp->required = c->in;
+			tmp->called_fn = stmt->inline_fn;
+			tmp->pos = insn->pos;
+			add_one_insn(ep, tmp);
+		} END_FOR_EACH_PTR(c);
+
 	return pseudo;
 }
 
--- sparse.orig/parse.h	2008-09-10 08:56:02.000000000 +0200
+++ sparse/parse.h	2008-09-10 08:56:34.000000000 +0200
@@ -61,6 +61,7 @@ struct statement {
 			struct symbol *ret;
 			struct symbol *inline_fn;
 			struct statement *args;
+			struct expression *inlined_fn_expr;
 		};
 		struct /* labeled_struct */ {
 			struct symbol *label_identifier;
--- sparse.orig/linearize.h	2008-09-10 08:56:02.000000000 +0200
+++ sparse/linearize.h	2008-09-10 08:56:34.000000000 +0200
@@ -119,6 +119,7 @@ struct instruction {
 			int increment, required, exact;
 			struct expression *context_expr;
 			struct symbol *access_var;
+			struct symbol *called_fn;
 		};
 		struct /* asm */ {
 			const char *string;
--- sparse.orig/ident-list.h	2008-09-10 08:56:02.000000000 +0200
+++ sparse/ident-list.h	2008-09-10 08:56:34.000000000 +0200
@@ -98,6 +98,7 @@ __IDENT(__PRETTY_FUNCTION___ident, "__PR
 IDENT_RESERVED(__context__);
 IDENT_RESERVED(__exact_context__);
 IDENT_RESERVED(__range__);
+IDENT_RESERVED(RESULT);
 
 /* Magic function names we recognize */
 IDENT(memset); IDENT(memcpy);


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH 6/9 v2] check context expressions as expressions
Date: Wed, 10 Sep 2008 21:34:00 +0000
Message-ID: <1221082440.3804.40.camel () johannes ! berg>
--------------------

--=-mokhWGNv5oH3lKGyS9ZJ
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Wed, 2008-09-10 at 12:21 -0700, Christopher Li wrote:

> Nah, you pretty should never need to do that.
> Ident equal should just need to compare ident1 =3D=3D ident2.
>=20
> All ident has been hashed. Same ident, should show up
> as same pointer. Doing strncmp again is unnecessary.
>=20
> I feel that this patch  is adding too much hack to the
> sparse front end. At the very least, can you
> just change __context__ parsing to accept symbol expression
> and the let the checking back end to do the code motions
> stuff?

Can you explain?

> I haven't study the new context checking very carefully.
> I actually prefer the Linus's  old simple context checking.
> Yes, that does not distinguish which symbols taking the lock.
> But other than that it is working and counting the number
> correctly. And, it is very simple.

Well, yeah, it's very simple, and that doesn't help. And it's not about
cross-function checking either:

extern spinlock_t a;

spin_lock(&a);
rcu_read_unlock()

will not result in an error which is a pain.

> The new context checking seems able to do more features.
> But it has too many sore spots. I vote for back it out.

I don't care, I don't have any more cycles to burn on this. For all I'm
concerned it works pretty well and is a HUGE improvement over the
current sparse which
 * doesn't tell you what line the error really is in, it only warns
   about the last line of the function
 * isn't able to check different contexts despite documenting it
   (see above)

> Instead of keep adding more hacks to fix up the problem. I
> think we should step back and ask ourselves what do we really
> want to achieve.

See above.

> The fundamental problem I saw here is that, sparse does not
> support cross function checking. There is no good way to save
> some analyzed result for some function and used it later by other
> function. That is why we actually have to put __context__
> around so many functions. The __context__ describe what
> these functions in forms of source code annotation. There is
> only so much we can do with source code annotations.
> I am not saying that annotation is not useful. I agree source
> code annotation helps on the source code reading. But it
> shouldn't limit checker only use the annotations. The checker
> should be able to draw intelligent conclusions, by looking the
> the function source code itself.

Actually, I kinda disagree. Annotating *each and every function* with
the locks it requires is _very_ useful, not just for sparse but also for
human readers of the code. Hence, I don't just want sparse to check
across functions, I want to be able to tell people what to do for
calling a given function as well. The fact that sparse can check my
annotations is great, but having them would be useful without that as
well.

> e.g. Why do we have to annotate foo_lock(&bar->lock) will take a lock
> on &bar->lock? The checker should be able to find out foo_lock() just
> callers some lower level locking functions. For example,  let say if we
> can force foo to be inlined into the caller even foo is not declared as
> inline. Then there is no need to annotate foo itself. The caller see
> exactly what foo does.

It used to be like that. But I'm arguing (and others backed me up on
this) that inlines are really just functions and as such should be
annotated, not magically inlined into the code and then checked as
sparse behaves right now.

> So, I think we should implement cross functions checking capability
> systematically rather than putting more hacks on source code
> annotation. The writer patch I send out earlier is one step towards it.
> I will write up more detail proposal.

Please don't focus on cross-function checking so much. Having different
contexts is way more desirable, and cross-function checking probably is
_not_ desirable in that you _want_ the annotations.

johannes

--=-mokhWGNv5oH3lKGyS9ZJ
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJIyD1FAAoJEKVg1VMiehFYWHwP/jgsKCOrCncTS128dcRhi6Cn
dFjgqt+ReCLVOSMxr+Y7Rw002h8jIISoU2NEwGQbhw9PyHWhGtu7cUWNg9TO989p
nf+QaVmF6SyGtR8hVZKwrz9+o+RkH44QpI1BcxC4Cp8d0uU2NkBJH/4U5YYh7fun
XTc2M/l80WlXnZBrqQ+FhkasylcNtgNfkiDenSYsAWUTN39OB+svTyJL4prtpwBA
XLlXMprkD6RnrBBtIYSQPzrfRAItOYQeBfliJ9M/94Fo/JbqFzF278fmzUPUeFQD
nDtqosAhFieTnl3JVxBboPOlMjrQkzf0M/qn+9SEkGMO1aBkKbbffmn66F20ba9R
osfGMfbWIxIXbZrkZODbhO8IeqB9bA8MZpkJWHz3vqCrp8UjYCmsGdDiMrmhHJAR
u/bmxEK/2msNjZQrC6yjOrNqD4t5HIynI4HzBvPX1ODJ118m7cxzuUXFXG+MKywL
a86OFVxLkuS3bWHwaMn7Mp7PW9gvXrUPHvW8VrcrN7/VD/2gZnIWTWvoe/SoBLOv
lyG3Z6eDPi43eQEyrqzD2SY505YQrd9eZtT/53ZtemFSPeAu8Qzn+Ci5i/Ghumw0
NdVw8LA6SuCbvzEAUa0MidLxODF9SBD02IJtQczfXxOXW3GoF7DEfBXv+fNh5zJp
BpyOTAjK8UUhdEXNWpUy
=7MAh
-----END PGP SIGNATURE-----

--=-mokhWGNv5oH3lKGyS9ZJ--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 6/9 v2] check context expressions as expressions
Date: Thu, 11 Sep 2008 00:15:00 +0000
Message-ID: <70318cbf0809101715v4baa40b1pf90d2b59f3078f72 () mail ! gmail ! com>
--------------------
On Wed, Sep 10, 2008 at 2:34 PM, Johannes Berg
<johannes@sipsolutions.net> wrote:
>> I feel that this patch  is adding too much hack to the
>> sparse front end. At the very least, can you
>> just change __context__ parsing to accept symbol expression
>> and the let the checking back end to do the code motions
>> stuff?
>
> Can you explain?

Maybe you can help to explain why do you need to make so
many front end(parser) changes. I especially don't like the part
that does the replace ident.


================================================================================


################################################################################

=== Thread: [PATCH 6/9] check context expressions as expressions ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 6/9] check context expressions as expressions
Date: Thu, 29 May 2008 08:54:08 +0000
Message-ID: <20080529085516.930777000 () sipsolutions ! net>
--------------------
This patch makes sparse evaluate context expressions allowing this:

    struct test {
        lock_t lock;
        int i;
    };

    extern void r(struct test *t) __attribute__((context(&t->lock,0,1)));
    extern struct test *find(int i) __attribute__((context(&RESULT->lock,1,0)));

    void test(void)
    {
       struct test *x = find(42);
       r(x);
       r(x);
    }

to work the way you think it would.

This works by rewriting the given attribute expression into __context__
statements and evaluating those in the caller scope.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
Somewhat inspired by Philipp's patch. When it warns, the expression is
given as evaluated, e.g. in above case would result in a warning about
"**x+0". We can fix that later by keeping the original expression and
not expanding/evaluating it, but we need to do both for it to work.

Note that there's a problem: You cannot give RESULT on a static function
that is declared there without getting an error in the function itself...

 evaluate.c                |   18 ++-
 expand.c                  |    6 +
 expression.c              |  272 +++++++++++++++++++++++++++++++++++++++++++++-
 expression.h              |    7 +
 ident-list.h              |    1 
 inline.c                  |    4 
 linearize.c               |   63 ++++++----
 linearize.h               |    1 
 parse.c                   |   17 ++
 parse.h                   |    1 
 sparse.c                  |  144 ++++++------------------
 symbol.h                  |    4 
 validation/context-vars.c |  171 ++++++++++++++++++++++++++++
 13 files changed, 575 insertions(+), 134 deletions(-)

--- sparse.orig/expression.c	2008-04-27 10:45:03.000000000 +0200
+++ sparse/expression.c	2008-04-27 11:05:30.000000000 +0200
@@ -27,6 +27,8 @@
 #include "expression.h"
 #include "target.h"
 
+struct expression *current_assignment_expression = NULL;
+
 static int match_oplist(int op, ...)
 {
 	va_list args;
@@ -509,6 +511,63 @@ static struct token *expression_list(str
 	return token;
 }
 
+static int ident_equal(struct ident *ident1, struct ident *ident2)
+{
+	if (ident1 == ident2)
+		return 1;
+	if (!ident1 || !ident2)
+		return 0;
+
+	return ident1->len == ident2->len &&
+		!strncmp(ident1->name, ident2->name, ident1->len);
+}
+
+/* TODO: this is probably not complete */
+void replace_ident(struct expression **_in, struct ident *s, struct expression *r)
+{
+	struct expression *in = *_in;
+
+	switch (in->type) {
+	case EXPR_SYMBOL:
+		if (ident_equal(in->symbol_name, s))
+			*_in = r;
+		break;
+	case EXPR_IDENTIFIER:
+		if (ident_equal(in->expr_ident, s))
+			*_in = r;
+		break;
+	case EXPR_BINOP:
+	case EXPR_COMMA:
+	case EXPR_ASSIGNMENT:
+	case EXPR_COMPARE:
+	case EXPR_LOGICAL:
+		replace_ident(&in->left, s, r);
+		replace_ident(&in->right, s, r);
+		break;
+	case EXPR_DEREF:
+		replace_ident(&in->deref, s, r);
+		break;
+	case EXPR_PREOP:
+	case EXPR_POSTOP:
+		replace_ident(&in->unop, s, r);
+		break;
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+	case EXPR_SIZEOF:
+		replace_ident(&in->cast_expression, s, r);
+		break;
+	case EXPR_SLICE:
+		replace_ident(&in->base, s, r);
+		break;
+	case EXPR_CONDITIONAL:
+		replace_ident(&in->conditional, s, r);
+		replace_ident(&in->cond_true, s, r);
+		replace_ident(&in->cond_false, s, r);
+		break;
+	}
+}
+
 /*
  * extend to deal with the ambiguous C grammar for parsing
  * a cast expressions followed by an initializer.
@@ -570,10 +629,50 @@ static struct token *postfix_expression(
 
 		case '(': {			/* Function call */
 			struct expression *call = alloc_expression(token->pos, EXPR_CALL);
+			struct symbol *fn = NULL;
+			struct context *c;
+
+			if (expr->symbol_name)
+				fn = lookup_symbol(expr->symbol_name, NS_SYMBOL);
 			call->op = '(';
 			call->fn = expr;
 			token = expression_list(token->next, &call->args);
 			token = expect(token, ')', "in function call");
+
+			if (fn && fn->ctype.base_type) {
+				FOR_EACH_PTR(fn->ctype.contexts, c) {
+					struct context *copy = alloc_context();
+					struct symbol *fn_arg;
+					struct expression *passed_arg;
+
+					copy->in = c->in;
+					copy->out = c->out;
+					copy->exact = c->exact;
+					add_ptr_list(&call->contexts, copy);
+
+					if (!c->token)
+						continue;
+
+					/* re-parse the token at this place */
+					conditional_expression(c->token, &copy->context);
+
+					copy->context->pos = expr->pos;
+
+					if (current_assignment_expression)
+						replace_ident(&copy->context, &RESULT_ident,
+							      current_assignment_expression);
+
+					/* and replace the arg */
+					PREPARE_PTR_LIST(fn->ctype.base_type->arguments, fn_arg);
+					FOR_EACH_PTR(call->args, passed_arg);
+					if (fn_arg)
+						replace_ident(&copy->context, fn_arg->ident, passed_arg);
+					NEXT_PTR_LIST(fn_arg);
+					END_FOR_EACH_PTR(passed_arg);
+					FINISH_PTR_LIST(fn_arg);
+				} END_FOR_EACH_PTR(c);
+			}
+
 			expr = call;
 			continue;
 		}
@@ -894,6 +993,7 @@ struct token *conditional_expression(str
 
 struct token *assignment_expression(struct token *token, struct expression **tree)
 {
+	struct expression *old_cae = current_assignment_expression;
 	token = conditional_expression(token, tree);
 	if (*tree && token_type(token) == TOKEN_SPECIAL) {
 		static const int assignments[] = {
@@ -904,15 +1004,19 @@ struct token *assignment_expression(stru
 			SPECIAL_SHR_ASSIGN, SPECIAL_AND_ASSIGN,
 			SPECIAL_OR_ASSIGN,  SPECIAL_XOR_ASSIGN };
 		int i, op = token->special;
+		if (op == '=')
+			current_assignment_expression = *tree;
 		for (i = 0; i < sizeof(assignments)/sizeof(int); i++)
 			if (assignments[i] == op) {
 				struct expression * expr = alloc_expression(token->pos, EXPR_ASSIGNMENT);
 				expr->left = *tree;
 				expr->op = op;
 				*tree = expr;
-				return assignment_expression(token->next, &expr->right);
+				token = assignment_expression(token->next, &expr->right);
+				break;
 			}
 	}
+	current_assignment_expression = old_cae;
 	return token;
 }
 
@@ -929,4 +1033,170 @@ struct token *parse_expression(struct to
 	return comma_expression(token,tree);
 }
 
+int expressions_equal(const struct expression *expr1,
+		      const struct expression *expr2)
+{
+	if (expr1 == expr2)
+		return 1;
+
+	if (expr1 == NULL || expr2 == NULL)
+		return 0;
+
+	/* Is this the right way to handle casts? */
+	if (expr1->type == EXPR_CAST ||
+	    expr1->type == EXPR_FORCE_CAST ||
+	    expr1->type == EXPR_IMPLIED_CAST)
+		return expressions_equal(expr1->cast_expression, expr2);
+
+	if (expr2->type == EXPR_CAST ||
+	    expr2->type == EXPR_FORCE_CAST ||
+	    expr2->type == EXPR_IMPLIED_CAST)
+		return expressions_equal(expr2->cast_expression, expr1);
+
+	if (expr1->type != expr2->type)
+		return 0;
+
+	switch (expr1->type) {
+	case EXPR_SYMBOL:
+		return ident_equal(expr1->symbol_name, expr2->symbol_name);
+
+	case EXPR_VALUE:
+		return expr1->value == expr2->value;
+
+	case EXPR_FVALUE:
+		return expr1->fvalue == expr2->fvalue;
+
+	case EXPR_STRING:
+		return expr1->string->length == expr2->string->length &&
+			!strncmp(expr1->string->data, expr2->string->data, expr1->string->length);
+
+	case EXPR_BINOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_COMMA:
+	case EXPR_ASSIGNMENT:
+		return expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_DEREF:
+		return expressions_equal(expr1->deref, expr2->deref) &&
+			ident_equal(expr1->member, expr2->member);
+
+	case EXPR_PREOP:
+	case EXPR_POSTOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->unop, expr2->unop);
+
+	/* Not needed right now, but for sake of completness ...
+	case EXPR_LABEL:
+	case EXPR_STATEMENT:
+	case EXPR_CALL:
+	case EXPR_LOGICAL:
+	case EXPR_COMPARE:
+	case EXPR_SELECT:
+	case EXPR_CONDITIONAL:
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+	case EXPR_SLICE:
+	case EXPR_INITIALIZER:
+	case EXPR_POS:
+	*/
+
+	default:
+		/* nothing, we should already have had a warning */
+		;
+	}
+
+	return 0;
+}
+
+static int ident_str(struct ident *ident, char *buffer, int length)
+{
+	if (!ident)
+		return 0;
+	return snprintf(buffer, length, "%.*s", ident->len, ident->name);
+}
+
+int expression_str(const struct expression *expr,
+		   char *buffer, int length)
+{
+	int n;
+
+	memset(buffer, 0, length);
+
+	if (!expr)
+		return 0;
+
+	/* TODO, think about necessary parentheses () */
 
+	switch (expr->type) {
+	case EXPR_SYMBOL:
+		return ident_str(expr->symbol_name, buffer, length);
+
+	case EXPR_VALUE:
+		return snprintf(buffer, length, "%llu", expr->value);
+
+	case EXPR_FVALUE:
+		return snprintf(buffer, length, "%Lf", expr->fvalue);
+
+	case EXPR_STRING:
+		return snprintf(buffer, length, "\"%.*s\"", expr->string->length, expr->string->data);
+
+	case EXPR_BINOP:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_COMMA:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, ",");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_ASSIGNMENT:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "=");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_DEREF:
+		if (expr->left->type == EXPR_PREOP &&
+		    expr->left->op == '*') {
+			n  = expression_str(expr->left->unop, buffer, length);
+			n += snprintf(buffer+n, length-n, "->");
+			n += ident_str(expr->member, buffer+n, length-n);
+		} else {
+			n  = expression_str(expr->left, buffer, length);
+			n += snprintf(buffer+n, length-n, ".");
+			n += ident_str(expr->member, buffer+n, length-n);
+		}
+		return n;
+
+	case EXPR_PREOP:
+		n  = snprintf(buffer, length, "%c", expr->op);
+		n += expression_str(expr->unop, buffer+n, length-n);
+		return n;
+
+	case EXPR_POSTOP:
+		n  = expression_str(expr->unop, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		return n;
+
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+		/* todo: print out the cast type's ctype */
+		*buffer++ = '('; length--;
+		*buffer++ = ')'; length--;
+		return expression_str(expr->cast_expression, buffer, length) + 2;
+
+	default:
+		printf("Missing code in expression_str for %d\n", expr->type);
+	}
+
+	return 0;
+}
--- sparse.orig/expression.h	2008-04-27 10:45:03.000000000 +0200
+++ sparse/expression.h	2008-04-27 10:45:27.000000000 +0200
@@ -121,6 +121,7 @@ struct expression {
 		struct /* call_expr */ {
 			struct expression *fn;
 			struct expression_list *args;
+			struct context_list *contexts;
 		};
 		// EXPR_LABEL
 		struct /* label_expr */ {
@@ -216,4 +217,10 @@ struct token *compound_statement(struct 
 void cast_value(struct expression *expr, struct symbol *newtype,
 	struct expression *old, struct symbol *oldtype);
 
+int expressions_equal(const struct expression *expr1,
+		      const struct expression *expr2);
+int expression_str(const struct expression *, char *buf, int buflen);
+struct expression *copy_expression(struct expression *expr);
+void replace_ident(struct expression **in, struct ident *s, struct expression *r);
+extern struct expression *current_assignment_expression;
 #endif
--- sparse.orig/sparse.c	2008-04-27 10:45:27.000000000 +0200
+++ sparse/sparse.c	2008-04-27 11:04:41.000000000 +0200
@@ -26,7 +26,7 @@
 
 struct context_check {
 	int val;
-	char name[32];
+	const struct expression *expr;
 };
 
 DECLARE_ALLOCATOR(context_check);
@@ -34,22 +34,15 @@ DECLARE_PTR_LIST(context_check_list, str
 DECLARE_PTR_LIST(context_list_list, struct context_check_list);
 ALLOCATOR(context_check, "context check list");
 
-static const char *unnamed_context = "<unnamed>";
 
-static const char *context_name(struct context *context)
-{
-	if (context->context && context->context->symbol_name)
-		return show_ident(context->context->symbol_name);
-	return unnamed_context;
-}
-
-static void context_add(struct context_check_list **ccl, const char *name,
+static void context_add(struct context_check_list **ccl,
+			const struct expression *expr,
 			int offs)
 {
 	struct context_check *check, *found = NULL;
 
 	FOR_EACH_PTR(*ccl, check) {
-		if (strcmp(name, check->name))
+		if (!expressions_equal(expr, check->expr))
 			continue;
 		found = check;
 		break;
@@ -57,8 +50,7 @@ static void context_add(struct context_c
 
 	if (!found) {
 		found = __alloc_context_check(0);
-		strncpy(found->name, name, sizeof(found->name));
-		found->name[sizeof(found->name) - 1] = '\0';
+		found->expr = expr;
 		add_ptr_list(ccl, found);
 	}
 	found->val += offs;
@@ -70,7 +62,7 @@ static int context_list_has(struct conte
 	struct context_check *check;
 
 	FOR_EACH_PTR(ccl, check) {
-		if (strcmp(c->name, check->name))
+		if (!expressions_equal(c->expr, check->expr))
 			continue;
 		return check->val == c->val;
 	} END_FOR_EACH_PTR(check);
@@ -105,7 +97,7 @@ static struct context_check_list *checke
 	struct context_check *c;
 
 	FOR_EACH_PTR(ccl, c) {
-		context_add(&result, c->name, c->val);
+		context_add(&result, c->expr, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	return result;
@@ -115,15 +107,15 @@ static struct context_check_list *checke
 #define CONTEXT_PROB "context problem in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
-static void get_context_string(char **buf, const char **name)
+static const char *get_context_string(char **buf, const char *name)
 {
-	if (strcmp(*name, unnamed_context)) {
-		*buf = malloc(strlen(*name) + 16);
-		sprintf(*buf, "   context '%s': ", *name);
-		*name = *buf;
+	if (strlen(name)) {
+		*buf = malloc(strlen(name) + 16);
+		sprintf(*buf, "   context '%s': ", name);
+		return *buf;
 	} else {
-		*name = DEFAULT_CONTEXT_DESCR;
 		*buf = NULL;
+		return DEFAULT_CONTEXT_DESCR;
 	}
 }
 
@@ -133,12 +125,13 @@ static int context_list_check(struct ent
 {
 	struct context_check *c1, *c2;
 	int cur, tgt;
-	const char *name;
+	char name[1000];
 	char *buf;
+	const char *pname;
 
 	/* make sure the loop below checks all */
 	FOR_EACH_PTR(ccl_target, c1) {
-		context_add(&ccl_cur, c1->name, 0);
+		context_add(&ccl_cur, c1->expr, 0);
 	} END_FOR_EACH_PTR(c1);
 
 	FOR_EACH_PTR(ccl_cur, c1) {
@@ -146,7 +139,7 @@ static int context_list_check(struct ent
 		tgt = 0;
 
 		FOR_EACH_PTR(ccl_target, c2) {
-			if (strcmp(c2->name, c1->name))
+			if (!expressions_equal(c1->expr, c2->expr))
 				continue;
 			tgt = c2->val;
 			break;
@@ -162,11 +155,11 @@ static int context_list_check(struct ent
 			warning(pos, IMBALANCE_IN "unexpected unlock",
 				show_ident(ep->name->ident));
 
-		name = c1->name;
-		get_context_string(&buf, &name);
+		expression_str(c1->expr, name, sizeof(name));
+		pname = get_context_string(&buf, name);
 
 		info(pos, "%swanted %d, got %d",
-		     name, tgt, cur);
+		     pname, tgt, cur);
 
 		free(buf);
 
@@ -176,83 +169,21 @@ static int context_list_check(struct ent
 	return 0;
 }
 
-static int handle_call(struct entrypoint *ep, struct basic_block *bb,
-		       struct instruction *insn,
-		       struct context_check_list *combined)
-{
-	struct context *ctx;
-	struct context_check *c;
-	const char *name, *call, *cmp;
-	char *buf;
-	int val, ok;
-
-	if (!insn->func || !insn->func->sym ||
-	    insn->func->type != PSEUDO_SYM)
-		return 0;
-
-	/*
-	 * Check all contexts the function wants.
-	 */
-	FOR_EACH_PTR(insn->func->sym->ctype.contexts, ctx) {
-		name = context_name(ctx);
-		val = 0;
-
-		FOR_EACH_PTR(combined, c) {
-			if (strcmp(c->name, name) == 0) {
-				val = c->val;
-				break;
-			}
-		} END_FOR_EACH_PTR(c);
-
-		if (ctx->exact) {
-			ok = ctx->in == val;
-			cmp = "";
-		} else {
-			ok = ctx->in <= val;
-			cmp = ">= ";
-		}
-
-		if (!ok && Wcontext) {
-			get_context_string(&buf, &name);
-			call = strdup(show_ident(insn->func->ident));
-
-			warning(insn->pos, "context problem in '%s': "
-				"'%s' expected different context",
-				show_ident(ep->name->ident), call);
-
-			info(insn->pos, "%swanted %s%d, got %d",
-			     name, cmp, ctx->in, val);
-
-			free((void *)call);
-			free(buf);
-
-			return -1;
-		}
-	} END_FOR_EACH_PTR (ctx);
-
-	return 0;
-}
-
 static int handle_context(struct entrypoint *ep, struct basic_block *bb,
 			  struct instruction *insn,
 			  struct context_check_list **combined)
 {
 	struct context_check *c;
-	const char *name, *cmp;
+	const char *cmp, *pname;
 	char *buf;
+	char name[1000];
 	int val, ok;
 
 	val = 0;
 
-	name = unnamed_context;
-	if (insn->context_expr)
-		name = show_ident(insn->context_expr->symbol_name);
-
 	FOR_EACH_PTR(*combined, c) {
-		if (strcmp(c->name, name) == 0) {
+		if (expressions_equal(c->expr, insn->context_expr))
 			val = c->val;
-			break;
-		}
 	} END_FOR_EACH_PTR(c);
 
 	if (insn->exact) {
@@ -264,7 +195,8 @@ static int handle_context(struct entrypo
 	}
 
 	if (!ok && Wcontext) {
-		get_context_string(&buf, &name);
+		expression_str(insn->context_expr, name, sizeof(name));
+		pname = get_context_string(&buf, name);
 
 		if (insn->access_var) {
 			char *symname = strdup(show_ident(insn->access_var->ident));
@@ -273,6 +205,13 @@ static int handle_context(struct entrypo
 				"access to '%s' requires different context",
 				show_ident(ep->name->ident), symname);
 			free(symname);
+		} else if (insn->called_fn) {
+			char *symname = strdup(show_ident(insn->called_fn->ident));
+			warning(insn->pos,
+				CONTEXT_PROB
+				"'%s' expected different context",
+				show_ident(ep->name->ident), symname);
+			free(symname);
 		} else {
 			warning(insn->pos,
 				CONTEXT_PROB
@@ -281,13 +220,13 @@ static int handle_context(struct entrypo
 		}
 
 		info(insn->pos, "%swanted %s%d, got %d",
-		     name, cmp, insn->required, val);
+		     pname, cmp, insn->required, val);
 
 		free(buf);
 		return -1;
 	}
 
-	context_add(combined, name, insn->increment);
+	context_add(combined, insn->context_expr, insn->increment);
 
 	return 0;
 }
@@ -324,7 +263,7 @@ static int check_bb_context(struct entry
 	 * for the conditional_context() attribute.
 	 */
 	FOR_EACH_PTR(ccl_in, c) {
-		context_add(&combined, c->name, c->val);
+		context_add(&combined, c->expr, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	/* Add the new context to the list of already-checked contexts */
@@ -338,11 +277,6 @@ static int check_bb_context(struct entry
 	 */
 	FOR_EACH_PTR(bb->insns, insn) {
 		switch (insn->opcode) {
-		case OP_INLINED_CALL:
-		case OP_CALL:
-			if (handle_call(ep, bb, insn, combined))
-				goto out;
-			break;
 		case OP_CONTEXT:
 			if (handle_context(ep, bb, insn, &combined))
 				goto out;
@@ -571,10 +505,10 @@ static void check_context(struct entrypo
 	check_instructions(ep);
 
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
-		const char *name = context_name(context);
-
-		context_add(&ccl_in, name, context->in);
-		context_add(&ccl_target, name, context->out);
+		context_add(&ccl_in, context->in_fn,
+			    context->in);
+		context_add(&ccl_target, context->in_fn,
+			    context->out);
 	} END_FOR_EACH_PTR(context);
 
 	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target);
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-vars.c	2008-04-27 12:01:17.000000000 +0200
@@ -0,0 +1,171 @@
+static void a(void *p) __attribute__((context(p,0,1)))
+{
+    __context__(p,1);
+}
+
+static void r(void *p) __attribute__((context(p,1,0)))
+{
+    __context__(p,-1,1);
+}
+
+extern void *l1, *l2;
+
+static void good_paired1(void)
+{
+    a(l1);
+    r(l1);
+}
+
+static void good_paired2(void)
+{
+    a(l1);
+    r(l1);
+    a(l1);
+    r(l1);
+    a(l2);
+    r(l2);
+}
+
+static void good_paired3(void)
+{
+    a(l1);
+    a(l2);
+    r(l2);
+    r(l1);
+}
+
+static void good_lock1(void *lp) __attribute__((context(lp,0,1)))
+{
+    a(lp);
+}
+
+static void good_lock2(void *lp) __attribute__((context(lp,0,1)))
+{
+    a(lp);
+    r(lp);
+    a(lp);
+}
+
+extern void **v;
+
+static void warn_lock1(void)
+{
+    a(v[1]);
+}
+
+extern int condition;
+
+static void good_lock3(void)
+{
+    a(v[1]);
+    if (condition) {
+        a(v[2]);
+        r(v[2]);
+    }
+    r(v[1]);
+}
+
+#define cond_lock(x, c)\
+  ((c) ? ({ __context__(x,1); 1; }) : 0)
+
+#define trylock(x) \
+    cond_lock(x, _try_lock(x))
+
+extern void _try_lock(int *x);
+
+static int good_condlock1(void)
+{
+    if (trylock(v[0]))
+        r(v[0]);
+}
+
+static int good_condlock2(void)
+{
+    if (trylock(&condition))
+        r((void*)&condition);
+}
+
+extern void ai(int *p) __attribute__((context(p,0,1)));
+extern void ri(int *p) __attribute__((context(p,1,0)));
+
+struct test {
+    int lock;
+};
+
+static inline void unlock(struct test *y)
+    __attribute__((context(&y->lock,1,0)))
+{
+    ri(&y->lock);
+}
+
+static void good_lock4(struct test *t)
+    __attribute__((context(&t->lock,0,1)))
+{
+    ai(&t->lock);
+}
+
+extern int *find_locked(void) __attribute__((context(RESULT,0,1)));
+
+static void good_find_release1(void)
+{
+    int *p;
+
+    p = find_locked();
+    ri(p);
+}
+
+extern struct test *find_locked_struct(void) __attribute__((context(&RESULT->lock,0,1)));
+
+static void good_find_release2(void)
+{
+    struct test *t;
+
+    t = find_locked_struct();
+    unlock(t);
+}
+
+static void good_find_release3(void)
+{
+    struct test *t = find_locked_struct();
+    unlock(t);
+}
+
+static void warn_unlock(void)
+{
+    struct test *t;
+    /* check that the warning is here, not at the unlock definition */
+    unlock(t);
+}
+
+extern int _locked_struct_test(struct test *ls, int *flags);
+#define locked_struct_test(ls, flags) (( _locked_struct_test((ls), (flags)) ) ? ({ __context__(&ls->lock,1); 1;}) : 0)
+
+static inline void unlock2(struct test *y)
+    __attribute__((context(&y->lock,1,0)))
+{
+    unlock(y);
+}
+
+static void good_locked_val(void)
+{
+    struct test *t;
+    int flags;
+
+    if (!t || !locked_struct_test(t, &flags))
+        goto out;
+
+    unlock2(t);
+ out:
+    ;
+}
+
+/*
+ * check-name: Check -Wcontext with lock variables
+ *
+ * check-error-start
+context-vars.c:53:7: warning: context imbalance in 'warn_lock1': wrong count at exit
+context-vars.c:53:7:    context '**v+4': wanted 0, got 1
+context-vars.c:137:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
+context-vars.c:137:11:    context '*t+0': wanted >= 1, got 0
+ * check-error-end
+ */
--- sparse.orig/evaluate.c	2008-04-27 10:45:27.000000000 +0200
+++ sparse/evaluate.c	2008-04-27 10:45:27.000000000 +0200
@@ -2954,8 +2954,16 @@ struct symbol *evaluate_expression(struc
 		return evaluate_alignof(expr);
 	case EXPR_DEREF:
 		return evaluate_member_dereference(expr);
-	case EXPR_CALL:
+	case EXPR_CALL: {
+		struct context *c;
+		FOR_EACH_PTR(expr->contexts, c) {
+			if (c->context &&
+			    (c->context->type != EXPR_SYMBOL ||
+			     c->context->symbol))
+				evaluate_expression(c->context);
+		} END_FOR_EACH_PTR(c);
 		return evaluate_call(expr);
+	}
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL:
 		return evaluate_conditional_expression(expr);
@@ -3025,6 +3033,7 @@ static void check_duplicates(struct symb
 static struct symbol *evaluate_symbol(struct symbol *sym)
 {
 	struct symbol *base_type;
+	struct context *c;
 
 	if (!sym)
 		return sym;
@@ -3054,6 +3063,13 @@ static struct symbol *evaluate_symbol(st
 			evaluate_statement(base_type->stmt);
 
 		current_fn = curr;
+
+		FOR_EACH_PTR(sym->ctype.contexts, c) {
+		if (c->in_fn &&
+		    (c->in_fn->type != EXPR_SYMBOL ||
+		     c->in_fn->symbol))
+			evaluate_expression(c->in_fn);
+		} END_FOR_EACH_PTR(c);
 	}
 
 	return base_type;
--- sparse.orig/expand.c	2008-04-27 10:45:27.000000000 +0200
+++ sparse/expand.c	2008-04-27 10:45:27.000000000 +0200
@@ -1034,8 +1034,14 @@ int expand_symbol(struct symbol *sym)
 	retval = expand_expression(sym->initializer);
 	/* expand the body of the symbol */
 	if (base_type->type == SYM_FN) {
+		struct context *c;
+
 		if (base_type->stmt)
 			expand_statement(base_type->stmt);
+
+		FOR_EACH_PTR(sym->ctype.contexts, c) {
+			expand_expression(c->in_fn);
+		} END_FOR_EACH_PTR(c);
 	}
 	return retval;
 }
--- sparse.orig/parse.c	2008-04-27 10:45:27.000000000 +0200
+++ sparse/parse.c	2008-04-27 10:45:28.000000000 +0200
@@ -879,12 +879,13 @@ static struct token *_attribute_context(
 	struct context *context = alloc_context();
 	struct expression *args[4];
 	int argc = 0;
-	struct token *last = NULL;
+	struct token *first = NULL, *last = NULL;
 
 	token = expect(token, '(', "after context attribute");
 	while (!match_op(token, ')')) {
 		struct expression *expr = NULL;
 		last = token;
+		first = first ? : token;
 		token = conditional_expression(token, &expr);
 		if (!expr)
 			break;
@@ -910,12 +911,14 @@ static struct token *_attribute_context(
 		break;
 	case 3:
 		context->context = args[0];
+		context->token = first;
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 		break;
 	case 4: {
 		const char *rw;
 		context->context = args[0];
+		context->token = first;
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 
@@ -2096,6 +2099,7 @@ static struct token *parse_function_body
 	struct symbol *base_type = decl->ctype.base_type;
 	struct statement *stmt, **p;
 	struct symbol *arg;
+	struct context *c;
 
 	old_symbol_list = function_symbol_list;
 	if (decl->ctype.modifiers & MOD_INLINE) {
@@ -2124,6 +2128,11 @@ static struct token *parse_function_body
 
 	token = compound_statement(token->next, stmt);
 
+	FOR_EACH_PTR(decl->ctype.contexts, c) {
+		if (c->token)
+			conditional_expression(c->token, &c->in_fn);
+	} END_FOR_EACH_PTR(c);
+
 	end_function(decl);
 	if (!(decl->ctype.modifiers & MOD_INLINE))
 		add_symbol(list, decl);
@@ -2286,11 +2295,17 @@ struct token *external_declaration(struc
 
 	for (;;) {
 		if (!is_typedef && match_op(token, '=')) {
+			struct expression *old_cae = current_assignment_expression;
 			if (decl->ctype.modifiers & MOD_EXTERN) {
 				warning(decl->pos, "symbol with external linkage has initializer");
 				decl->ctype.modifiers &= ~MOD_EXTERN;
 			}
+			current_assignment_expression = alloc_expression(token->pos, EXPR_SYMBOL);
+			current_assignment_expression->symbol_name = decl->ident;
+			current_assignment_expression->symbol =
+				lookup_symbol(decl->ident, NS_SYMBOL | NS_TYPEDEF);
 			token = initializer(&decl->initializer, token->next);
+			current_assignment_expression = old_cae;
 		}
 		if (!is_typedef) {
 			if (!(decl->ctype.modifiers & (MOD_EXTERN | MOD_INLINE))) {
--- sparse.orig/symbol.h	2008-04-27 10:45:27.000000000 +0200
+++ sparse/symbol.h	2008-04-27 10:45:28.000000000 +0200
@@ -77,6 +77,10 @@ enum context_read_write_specifier {
 
 struct context {
 	struct expression *context;
+	/* store the token pointer */
+	struct token *token;
+	/* to re-evaluate this context within the function it is for */
+	struct expression *in_fn;
 	unsigned int in, out;
 	int exact;
 	enum context_read_write_specifier rws;
--- sparse.orig/inline.c	2008-04-27 10:45:27.000000000 +0200
+++ sparse/inline.c	2008-04-27 10:45:28.000000000 +0200
@@ -56,7 +56,7 @@ static struct symbol_list *copy_symbol_l
 	return dst;
 }
 
-static struct expression * copy_expression(struct expression *expr)
+struct expression *copy_expression(struct expression *expr)
 {
 	if (!expr)
 		return NULL;
@@ -474,6 +474,7 @@ void copy_statement(struct statement *sr
 	dst->args = copy_one_statement(src->args);
 	dst->ret = copy_symbol(src->pos, src->ret);
 	dst->inline_fn = src->inline_fn;
+	dst->inlined_fn_expr = src->inlined_fn_expr;
 }
 
 static struct symbol *create_copy_symbol(struct symbol *orig)
@@ -555,6 +556,7 @@ int inline_function(struct expression *e
 		stmt->args = decl;
 	}
 	stmt->inline_fn = sym;
+	stmt->inlined_fn_expr = expr;
 
 	unset_replace_list(fn_symbol_list);
 
--- sparse.orig/linearize.c	2008-04-27 10:45:27.000000000 +0200
+++ sparse/linearize.c	2008-04-27 11:06:10.000000000 +0200
@@ -35,6 +35,7 @@ static pseudo_t linearize_initializer(st
 struct pseudo void_pseudo = {};
 
 static struct position current_pos;
+static int in_inline_skip_context = 0;
 
 ALLOCATOR(pseudo_user, "pseudo_user");
 
@@ -436,9 +437,15 @@ const char *show_instruction(struct inst
 		buf += sprintf(buf, "%s <- %s", show_pseudo(insn->target), show_pseudo(insn->src1));
 		break;
 
-	case OP_CONTEXT:
+	case OP_CONTEXT: {
+		char ctxbuf[100];
+		if (insn->context_expr) {
+			expression_str(insn->context_expr, ctxbuf, sizeof(ctxbuf));
+			buf += sprintf(buf, "%s, ", ctxbuf);
+		}
 		buf += sprintf(buf, "%d", insn->increment);
 		break;
+	}
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
 		break;
@@ -1280,7 +1287,7 @@ static pseudo_t linearize_call_expressio
 	struct instruction *insn = alloc_typed_instruction(OP_CALL, expr->ctype);
 	pseudo_t retval, call;
 	struct ctype *ctype = NULL;
-	struct context *context;
+	struct context *c;
 
 	if (!expr->ctype) {
 		warning(expr->pos, "call with no type!");
@@ -1316,29 +1323,17 @@ static pseudo_t linearize_call_expressio
 	insn->target = retval;
 	add_one_insn(ep, insn);
 
-	if (ctype) {
-		FOR_EACH_PTR(ctype->contexts, context) {
-			int in = context->in;
-			int out = context->out;
-			int check = 0;
-			int context_diff;
-			if (in < 0) {
-				check = 1;
-				in = 0;
-			}
-			if (out < 0) {
-				check = 0;
-				out = 0;
-			}
-			context_diff = out - in;
-			if (check || context_diff) {
-				insn = alloc_instruction(OP_CONTEXT, 0);
-				insn->increment = context_diff;
-				insn->context_expr = context->context;
-				add_one_insn(ep, insn);
-			}
-		} END_FOR_EACH_PTR(context);
-	}
+	if (!in_inline_skip_context)
+		FOR_EACH_PTR(expr->contexts, c) {
+			struct instruction *tmp = alloc_instruction(OP_CONTEXT, 0);
+			tmp->increment = c->out - c->in;
+			tmp->exact = c->exact;
+			tmp->context_expr = c->context;
+			tmp->required = c->in;
+			tmp->called_fn = call->sym;
+			tmp->pos = insn->pos;
+			add_one_insn(ep, tmp);
+		} END_FOR_EACH_PTR(c);
 
 	return retval;
 }
@@ -1712,6 +1707,8 @@ static pseudo_t linearize_compound_state
 
 	pseudo = VOID;
 	FOR_EACH_PTR(stmt->stmts, s) {
+		if (in_inline_skip_context && s->type == STMT_CONTEXT)
+			continue;
 		pseudo = linearize_statement(ep, s);
 	} END_FOR_EACH_PTR(s);
 
@@ -1739,6 +1736,7 @@ static pseudo_t linearize_inlined_call(s
 	struct statement *args = stmt->args;
 	struct basic_block *bb;
 	pseudo_t pseudo;
+	struct context *c;
 
 	if (args) {
 		struct symbol *sym;
@@ -1750,12 +1748,27 @@ static pseudo_t linearize_inlined_call(s
 		} END_FOR_EACH_PTR(sym);
 	}
 
+	in_inline_skip_context++;
 	insn->target = pseudo = linearize_compound_statement(ep, stmt);
+	in_inline_skip_context--;
 	use_pseudo(insn, symbol_pseudo(ep, stmt->inline_fn), &insn->func);
 	bb = ep->active;
 	if (bb && !bb->insns)
 		bb->pos = stmt->pos;
 	add_one_insn(ep, insn);
+
+	if (!in_inline_skip_context)
+		FOR_EACH_PTR(stmt->inlined_fn_expr->contexts, c) {
+			struct instruction *tmp = alloc_instruction(OP_CONTEXT, 0);
+			tmp->increment = c->out - c->in;
+			tmp->exact = c->exact;
+			tmp->context_expr = c->context;
+			tmp->required = c->in;
+			tmp->called_fn = stmt->inline_fn;
+			tmp->pos = insn->pos;
+			add_one_insn(ep, tmp);
+		} END_FOR_EACH_PTR(c);
+
 	return pseudo;
 }
 
--- sparse.orig/parse.h	2008-04-27 10:45:27.000000000 +0200
+++ sparse/parse.h	2008-04-27 10:45:28.000000000 +0200
@@ -61,6 +61,7 @@ struct statement {
 			struct symbol *ret;
 			struct symbol *inline_fn;
 			struct statement *args;
+			struct expression *inlined_fn_expr;
 		};
 		struct /* labeled_struct */ {
 			struct symbol *label_identifier;
--- sparse.orig/linearize.h	2008-04-27 10:45:27.000000000 +0200
+++ sparse/linearize.h	2008-04-27 10:45:28.000000000 +0200
@@ -119,6 +119,7 @@ struct instruction {
 			int increment, required, exact;
 			struct expression *context_expr;
 			struct symbol *access_var;
+			struct symbol *called_fn;
 		};
 		struct /* asm */ {
 			const char *string;
--- sparse.orig/ident-list.h	2008-04-27 10:45:27.000000000 +0200
+++ sparse/ident-list.h	2008-04-27 10:45:28.000000000 +0200
@@ -98,6 +98,7 @@ __IDENT(__PRETTY_FUNCTION___ident, "__PR
 IDENT_RESERVED(__context__);
 IDENT_RESERVED(__exact_context__);
 IDENT_RESERVED(__range__);
+IDENT_RESERVED(RESULT);
 
 /* Magic function names we recognize */
 IDENT(memset); IDENT(memcpy);

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct ===

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 07:09:55 +0000
Message-ID: <1204700995.17484.7.camel () brick>
--------------------
On Wed, 2008-03-05 at 08:02 +0100, Ingo Molnar wrote:
> * Christopher Li <sparse@chrisli.org> wrote:
> 
> > I think Al Viro has sent a patch to linux-sparse with subject "[PATCH 
> > 3/3] catch !x & y brainos" does exactly that.
> 
> ah - nice :-)
> 
> /me checks the linux-sparse archive
> 
> Al's patch is:
> 
> +                       if (op == '&' && expr->left->type == EXPR_PREOP &&
> +                           expr->left->op == '!')
> +                               warning(expr->pos, "dubious: !x & y");
> 
> i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
> 

Well, (!x & y) and (!x | y) are probably the two that might have been
intended otherwise.  (x & !y), (x | !y) are probably ok.

Harvey

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: kernel-janitors
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 08:19:05 +0000
Message-ID: <20080305081904.GA17789 () elte ! hu>
--------------------

* Harvey Harrison <harvey.harrison@gmail.com> wrote:

> > Al's patch is:
> > 
> > +                       if (op == '&' && expr->left->type == EXPR_PREOP &&
> > +                           expr->left->op == '!')
> > +                               warning(expr->pos, "dubious: !x & y");
> > 
> > i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
> > 
> 
> Well, (!x & y) and (!x | y) are probably the two that might have been 
> intended otherwise.  (x & !y), (x | !y) are probably ok.

i think the proper intention in the latter cases is (x & ~y) and
(x | ~y).

My strong bet is that in 99% of the cases they are real bugs and && or 
|| was intended.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-wireless
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 08:19:05 +0000
Message-ID: <20080305081904.GA17789 () elte ! hu>
--------------------

* Harvey Harrison <harvey.harrison@gmail.com> wrote:

> > Al's patch is:
> > 
> > +                       if (op == '&' && expr->left->type == EXPR_PREOP &&
> > +                           expr->left->op == '!')
> > +                               warning(expr->pos, "dubious: !x & y");
> > 
> > i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
> > 
> 
> Well, (!x & y) and (!x | y) are probably the two that might have been 
> intended otherwise.  (x & !y), (x | !y) are probably ok.

i think the proper intention in the latter cases is (x & ~y) and
(x | ~y).

My strong bet is that in 99% of the cases they are real bugs and && or 
|| was intended.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-kernel
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 08:19:05 +0000
Message-ID: <20080305081904.GA17789 () elte ! hu>
--------------------

* Harvey Harrison <harvey.harrison@gmail.com> wrote:

> > Al's patch is:
> > 
> > +                       if (op == '&' && expr->left->type == EXPR_PREOP &&
> > +                           expr->left->op == '!')
> > +                               warning(expr->pos, "dubious: !x & y");
> > 
> > i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
> > 
> 
> Well, (!x & y) and (!x | y) are probably the two that might have been 
> intended otherwise.  (x & !y), (x | !y) are probably ok.

i think the proper intention in the latter cases is (x & ~y) and
(x | ~y).

My strong bet is that in 99% of the cases they are real bugs and && or 
|| was intended.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-sparse
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 08:19:05 +0000
Message-ID: <20080305081904.GA17789 () elte ! hu>
--------------------

* Harvey Harrison <harvey.harrison@gmail.com> wrote:

> > Al's patch is:
> > 
> > +                       if (op == '&' && expr->left->type == EXPR_PREOP &&
> > +                           expr->left->op == '!')
> > +                               warning(expr->pos, "dubious: !x & y");
> > 
> > i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
> > 
> 
> Well, (!x & y) and (!x | y) are probably the two that might have been 
> intended otherwise.  (x & !y), (x | !y) are probably ok.

i think the proper intention in the latter cases is (x & ~y) and
(x | ~y).

My strong bet is that in 99% of the cases they are real bugs and && or 
|| was intended.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Julia Lawall <julia () diku ! dk>
To: linux-wireless
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 08:55:49 +0000
Message-ID: <Pine.LNX.4.64.0803050951550.28021 () ask ! diku ! dk>
--------------------
There are some legitimate uses of !x & y which are actually of the form !x 
& !y, where x and y are function calls.  That is a not particularly 
elegant way of getting both x and y to be evaluated and then combining the 
results using "and".  If such code is considered acceptable, then perhaps 
the sparse patch should be more complicated.

julia

> Al's patch is:
> 
> +                       if (op == '&' && expr->left->type == EXPR_PREOP &&
> +                           expr->left->op == '!')
> +                               warning(expr->pos, "dubious: !x & y");
> 
> i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
> 
> 	Ingo
> 
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Julia Lawall <julia () diku ! dk>
To: linux-sparse
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 08:55:49 +0000
Message-ID: <Pine.LNX.4.64.0803050951550.28021 () ask ! diku ! dk>
--------------------
There are some legitimate uses of !x & y which are actually of the form !x 
& !y, where x and y are function calls.  That is a not particularly 
elegant way of getting both x and y to be evaluated and then combining the 
results using "and".  If such code is considered acceptable, then perhaps 
the sparse patch should be more complicated.

julia

> Al's patch is:
> 
> +                       if (op == '&' && expr->left->type == EXPR_PREOP &&
> +                           expr->left->op == '!')
> +                               warning(expr->pos, "dubious: !x & y");
> 
> i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
> 
> 	Ingo
> 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: kernel-janitors
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:13:28 +0000
Message-ID: <47CE8E68.5060701 () knosof ! co ! uk>
--------------------
All,

>>> i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
>>>
>> Well, (!x & y) and (!x | y) are probably the two that might have been 
>> intended otherwise.  (x & !y), (x | !y) are probably ok.
> 
> i think the proper intention in the latter cases is (x & ~y) and
> (x | ~y).
> 
> My strong bet is that in 99% of the cases they are real bugs and && or 
> || was intended.

Developer knowledge of operator precedence and the issue of what
they intended to write are interesting topics.  Some experimental
work is described in (binary operators only I'm afraid):

www.knosof.co.uk/cbook/accu06a.pdf
www.knosof.co.uk/cbook/accu07a.pdf

The ACCU 2006 experiment provides evidence that developer knowledge
is proportional to the number of occurrences of a construct in
source code, it also shows a stunningly high percentage of incorrect
answers.

The ACCU 2007 experiment provides evidence that the names of the
operands has a significant impact on operator precedence choice.

I wonder what kind of names are used as the operand of unary
operators?

I would expect the ~ operator to have a bitwise name, but the
! operator might have an arithmetic or bitwise name.

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-wireless
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:13:28 +0000
Message-ID: <47CE8E68.5060701 () knosof ! co ! uk>
--------------------
All,

>>> i think there might be similar patterns: "x & !y", "!x | y", "x | !y" ?
>>>
>> Well, (!x & y) and (!x | y) are probably the two that might have been 
>> intended otherwise.  (x & !y), (x | !y) are probably ok.
> 
> i think the proper intention in the latter cases is (x & ~y) and
> (x | ~y).
> 
> My strong bet is that in 99% of the cases they are real bugs and && or 
> || was intended.

Developer knowledge of operator precedence and the issue of what
they intended to write are interesting topics.  Some experimental
work is described in (binary operators only I'm afraid):

www.knosof.co.uk/cbook/accu06a.pdf
www.knosof.co.uk/cbook/accu07a.pdf

The ACCU 2006 experiment provides evidence that developer knowledge
is proportional to the number of occurrences of a construct in
source code, it also shows a stunningly high percentage of incorrect
answers.

The ACCU 2007 experiment provides evidence that the names of the
operands has a significant impact on operator precedence choice.

I wonder what kind of names are used as the operand of unary
operators?

I would expect the ~ operator to have a bitwise name, but the
! operator might have an arithmetic or bitwise name.

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: kernel-janitors
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:20:10 +0000
Message-ID: <20080305122010.GA999 () elte ! hu>
--------------------

* Julia Lawall <julia@diku.dk> wrote:

> There are some legitimate uses of !x & y which are actually of the 
> form !x & !y, where x and y are function calls.  That is a not 
> particularly elegant way of getting both x and y to be evaluated and 
> then combining the results using "and".  If such code is considered 
> acceptable, then perhaps the sparse patch should be more complicated.

i tend to be of the opinion that the details in C source code should be 
visually obvious and should be heavily simplified down from what is 
'possible' language-wise - with most deviations and complications that 
depart from convention considered an error. I'd consider "!fn1() & 
!fn2()" a borderline coding style violation in any case - and it costs 
nothing to change it to "!fn1() && !fn2()".

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-wireless
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:20:10 +0000
Message-ID: <20080305122010.GA999 () elte ! hu>
--------------------

* Julia Lawall <julia@diku.dk> wrote:

> There are some legitimate uses of !x & y which are actually of the 
> form !x & !y, where x and y are function calls.  That is a not 
> particularly elegant way of getting both x and y to be evaluated and 
> then combining the results using "and".  If such code is considered 
> acceptable, then perhaps the sparse patch should be more complicated.

i tend to be of the opinion that the details in C source code should be 
visually obvious and should be heavily simplified down from what is 
'possible' language-wise - with most deviations and complications that 
depart from convention considered an error. I'd consider "!fn1() & 
!fn2()" a borderline coding style violation in any case - and it costs 
nothing to change it to "!fn1() && !fn2()".

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-sparse
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:20:10 +0000
Message-ID: <20080305122010.GA999 () elte ! hu>
--------------------

* Julia Lawall <julia@diku.dk> wrote:

> There are some legitimate uses of !x & y which are actually of the 
> form !x & !y, where x and y are function calls.  That is a not 
> particularly elegant way of getting both x and y to be evaluated and 
> then combining the results using "and".  If such code is considered 
> acceptable, then perhaps the sparse patch should be more complicated.

i tend to be of the opinion that the details in C source code should be 
visually obvious and should be heavily simplified down from what is 
'possible' language-wise - with most deviations and complications that 
depart from convention considered an error. I'd consider "!fn1() & 
!fn2()" a borderline coding style violation in any case - and it costs 
nothing to change it to "!fn1() && !fn2()".

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-kernel
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:20:10 +0000
Message-ID: <20080305122010.GA999 () elte ! hu>
--------------------

* Julia Lawall <julia@diku.dk> wrote:

> There are some legitimate uses of !x & y which are actually of the 
> form !x & !y, where x and y are function calls.  That is a not 
> particularly elegant way of getting both x and y to be evaluated and 
> then combining the results using "and".  If such code is considered 
> acceptable, then perhaps the sparse patch should be more complicated.

i tend to be of the opinion that the details in C source code should be 
visually obvious and should be heavily simplified down from what is 
'possible' language-wise - with most deviations and complications that 
depart from convention considered an error. I'd consider "!fn1() & 
!fn2()" a borderline coding style violation in any case - and it costs 
nothing to change it to "!fn1() && !fn2()".

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Julia Lawall <julia () diku ! dk>
To: linux-kernel
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:35:29 +0000
Message-ID: <Pine.LNX.4.58.0803051331550.1188 () pc-041 ! diku ! dk>
--------------------
On Wed, 5 Mar 2008, Ingo Molnar wrote:

>
> * Julia Lawall <julia@diku.dk> wrote:
>
> > There are some legitimate uses of !x & y which are actually of the
> > form !x & !y, where x and y are function calls.  That is a not
> > particularly elegant way of getting both x and y to be evaluated and
> > then combining the results using "and".  If such code is considered
> > acceptable, then perhaps the sparse patch should be more complicated.
>
> i tend to be of the opinion that the details in C source code should be
> visually obvious and should be heavily simplified down from what is
> 'possible' language-wise - with most deviations and complications that
> depart from convention considered an error. I'd consider "!fn1() &
> !fn2()" a borderline coding style violation in any case - and it costs
> nothing to change it to "!fn1() && !fn2()".

!fn1() && !fn2() does not have the same semantics as !fn1() & !fn2().  In
!fn1() & !fn2() both function calls are evaluated.  In !fn1() && !fn2(),
if !fn1() returns false then !fn2() is not evaluated.  I haven't studied
the particular instances of fn2(), though, to know whether it makes a
difference.

One could instead do something like:

x = fn1();
y = fn2();
if (!x && !y) ...

It would certainly be clearer, but more verbose.

julia

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Julia Lawall <julia () diku ! dk>
To: kernel-janitors
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:35:29 +0000
Message-ID: <Pine.LNX.4.58.0803051331550.1188 () pc-041 ! diku ! dk>
--------------------
On Wed, 5 Mar 2008, Ingo Molnar wrote:

>
> * Julia Lawall <julia@diku.dk> wrote:
>
> > There are some legitimate uses of !x & y which are actually of the
> > form !x & !y, where x and y are function calls.  That is a not
> > particularly elegant way of getting both x and y to be evaluated and
> > then combining the results using "and".  If such code is considered
> > acceptable, then perhaps the sparse patch should be more complicated.
>
> i tend to be of the opinion that the details in C source code should be
> visually obvious and should be heavily simplified down from what is
> 'possible' language-wise - with most deviations and complications that
> depart from convention considered an error. I'd consider "!fn1() &
> !fn2()" a borderline coding style violation in any case - and it costs
> nothing to change it to "!fn1() && !fn2()".

!fn1() && !fn2() does not have the same semantics as !fn1() & !fn2().  In
!fn1() & !fn2() both function calls are evaluated.  In !fn1() && !fn2(),
if !fn1() returns false then !fn2() is not evaluated.  I haven't studied
the particular instances of fn2(), though, to know whether it makes a
difference.

One could instead do something like:

x = fn1();
y = fn2();
if (!x && !y) ...

It would certainly be clearer, but more verbose.

julia

--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Julia Lawall <julia () diku ! dk>
To: linux-wireless
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:35:29 +0000
Message-ID: <Pine.LNX.4.58.0803051331550.1188 () pc-041 ! diku ! dk>
--------------------
On Wed, 5 Mar 2008, Ingo Molnar wrote:

>
> * Julia Lawall <julia@diku.dk> wrote:
>
> > There are some legitimate uses of !x & y which are actually of the
> > form !x & !y, where x and y are function calls.  That is a not
> > particularly elegant way of getting both x and y to be evaluated and
> > then combining the results using "and".  If such code is considered
> > acceptable, then perhaps the sparse patch should be more complicated.
>
> i tend to be of the opinion that the details in C source code should be
> visually obvious and should be heavily simplified down from what is
> 'possible' language-wise - with most deviations and complications that
> depart from convention considered an error. I'd consider "!fn1() &
> !fn2()" a borderline coding style violation in any case - and it costs
> nothing to change it to "!fn1() && !fn2()".

!fn1() && !fn2() does not have the same semantics as !fn1() & !fn2().  In
!fn1() & !fn2() both function calls are evaluated.  In !fn1() && !fn2(),
if !fn1() returns false then !fn2() is not evaluated.  I haven't studied
the particular instances of fn2(), though, to know whether it makes a
difference.

One could instead do something like:

x = fn1();
y = fn2();
if (!x && !y) ...

It would certainly be clearer, but more verbose.

julia

--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: kernel-janitors
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:36:42 +0000
Message-ID: <20080305123641.GA2365 () elte ! hu>
--------------------

* Bart Van Assche <bart.vanassche@gmail.com> wrote:

> If someone writes (!x & !y) instead of (!x && !y) because both x and y 
> have to be evaluated, this means that both x and y have side effects.
> Please keep in mind that the C language does not specify whether x or 
> y has to be evaluated first, so if x and y have to be evaluated in 
> that order, an expression like (!x & !y) can be the cause of very 
> subtle bugs. I prefer readability above brevity.

such expressions _must_ be written as:

  ret1 = x();
  ret2 = y();

  if (ret1 && ret2)
	...

any side-effects are totally un-obvious when they are in expressions and 
someone doing cleanups later on could easily change the '&' to '&&' and 
introduce a bug.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-kernel
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:36:42 +0000
Message-ID: <20080305123641.GA2365 () elte ! hu>
--------------------

* Bart Van Assche <bart.vanassche@gmail.com> wrote:

> If someone writes (!x & !y) instead of (!x && !y) because both x and y 
> have to be evaluated, this means that both x and y have side effects.
> Please keep in mind that the C language does not specify whether x or 
> y has to be evaluated first, so if x and y have to be evaluated in 
> that order, an expression like (!x & !y) can be the cause of very 
> subtle bugs. I prefer readability above brevity.

such expressions _must_ be written as:

  ret1 = x();
  ret2 = y();

  if (ret1 && ret2)
	...

any side-effects are totally un-obvious when they are in expressions and 
someone doing cleanups later on could easily change the '&' to '&&' and 
introduce a bug.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-wireless
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:36:42 +0000
Message-ID: <20080305123641.GA2365 () elte ! hu>
--------------------

* Bart Van Assche <bart.vanassche@gmail.com> wrote:

> If someone writes (!x & !y) instead of (!x && !y) because both x and y 
> have to be evaluated, this means that both x and y have side effects.
> Please keep in mind that the C language does not specify whether x or 
> y has to be evaluated first, so if x and y have to be evaluated in 
> that order, an expression like (!x & !y) can be the cause of very 
> subtle bugs. I prefer readability above brevity.

such expressions _must_ be written as:

  ret1 = x();
  ret2 = y();

  if (ret1 && ret2)
	...

any side-effects are totally un-obvious when they are in expressions and 
someone doing cleanups later on could easily change the '&' to '&&' and 
introduce a bug.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-sparse
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct
Date: Wed, 05 Mar 2008 12:36:42 +0000
Message-ID: <20080305123641.GA2365 () elte ! hu>
--------------------

* Bart Van Assche <bart.vanassche@gmail.com> wrote:

> If someone writes (!x & !y) instead of (!x && !y) because both x and y 
> have to be evaluated, this means that both x and y have side effects.
> Please keep in mind that the C language does not specify whether x or 
> y has to be evaluated first, so if x and y have to be evaluated in 
> that order, an expression like (!x & !y) can be the cause of very 
> subtle bugs. I prefer readability above brevity.

such expressions _must_ be written as:

  ret1 = x();
  ret2 = y();

  if (ret1 && ret2)
	...

any side-effects are totally un-obvious when they are in expressions and 
someone doing cleanups later on could easily change the '&' to '&&' and 
introduce a bug.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct use of ! and & ===

From: "Bart Van Assche" <bart.vanassche () gmail ! com>
To: linux-wireless
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct use of ! and &
Date: Wed, 05 Mar 2008 12:30:54 +0000
Message-ID: <e2e108260803050430o317d3e0dyed50e86cc4569746 () mail ! gmail ! com>
--------------------
On Wed, Mar 5, 2008 at 1:20 PM, Ingo Molnar <mingo@elte.hu> wrote:
>
>  * Julia Lawall <julia@diku.dk> wrote:
>
>  > There are some legitimate uses of !x & y which are actually of the
>  > form !x & !y, where x and y are function calls.  That is a not
>  > particularly elegant way of getting both x and y to be evaluated and
>  > then combining the results using "and".  If such code is considered
>  > acceptable, then perhaps the sparse patch should be more complicated.
>
>  i tend to be of the opinion that the details in C source code should be
>  visually obvious and should be heavily simplified down from what is
>  'possible' language-wise - with most deviations and complications that
>  depart from convention considered an error. I'd consider "!fn1() &
>  !fn2()" a borderline coding style violation in any case - and it costs
>  nothing to change it to "!fn1() && !fn2()".

If someone writes (!x & !y) instead of (!x && !y) because both x and y
have to be evaluated, this means that both x and y have side effects.
Please keep in mind that the C language does not specify whether x or
y has to be evaluated first, so if x and y have to be evaluated in
that order, an expression like (!x & !y) can be the cause of very
subtle bugs. I prefer readability above brevity.

Bart Van Assche.
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Bart Van Assche" <bart.vanassche () gmail ! com>
To: kernel-janitors
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct use of ! and &
Date: Wed, 05 Mar 2008 12:30:54 +0000
Message-ID: <e2e108260803050430o317d3e0dyed50e86cc4569746 () mail ! gmail ! com>
--------------------
On Wed, Mar 5, 2008 at 1:20 PM, Ingo Molnar <mingo@elte.hu> wrote:
>
>  * Julia Lawall <julia@diku.dk> wrote:
>
>  > There are some legitimate uses of !x & y which are actually of the
>  > form !x & !y, where x and y are function calls.  That is a not
>  > particularly elegant way of getting both x and y to be evaluated and
>  > then combining the results using "and".  If such code is considered
>  > acceptable, then perhaps the sparse patch should be more complicated.
>
>  i tend to be of the opinion that the details in C source code should be
>  visually obvious and should be heavily simplified down from what is
>  'possible' language-wise - with most deviations and complications that
>  depart from convention considered an error. I'd consider "!fn1() &
>  !fn2()" a borderline coding style violation in any case - and it costs
>  nothing to change it to "!fn1() && !fn2()".

If someone writes (!x & !y) instead of (!x && !y) because both x and y
have to be evaluated, this means that both x and y have side effects.
Please keep in mind that the C language does not specify whether x or
y has to be evaluated first, so if x and y have to be evaluated in
that order, an expression like (!x & !y) can be the cause of very
subtle bugs. I prefer readability above brevity.

Bart Van Assche.
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Bart Van Assche" <bart.vanassche () gmail ! com>
To: linux-kernel
Subject: Re: [PATCH 6/9] drivers/net/wireless/iwlwifi/iwl-4965.c: Correct use of ! and &
Date: Wed, 05 Mar 2008 12:30:54 +0000
Message-ID: <e2e108260803050430o317d3e0dyed50e86cc4569746 () mail ! gmail ! com>
--------------------
On Wed, Mar 5, 2008 at 1:20 PM, Ingo Molnar <mingo@elte.hu> wrote:
>
>  * Julia Lawall <julia@diku.dk> wrote:
>
>  > There are some legitimate uses of !x & y which are actually of the
>  > form !x & !y, where x and y are function calls.  That is a not
>  > particularly elegant way of getting both x and y to be evaluated and
>  > then combining the results using "and".  If such code is considered
>  > acceptable, then perhaps the sparse patch should be more complicated.
>
>  i tend to be of the opinion that the details in C source code should be
>  visually obvious and should be heavily simplified down from what is
>  'possible' language-wise - with most deviations and complications that
>  depart from convention considered an error. I'd consider "!fn1() &
>  !fn2()" a borderline coding style violation in any case - and it costs
>  nothing to change it to "!fn1() && !fn2()".

If someone writes (!x & !y) instead of (!x && !y) because both x and y
have to be evaluated, this means that both x and y have side effects.
Please keep in mind that the C language does not specify whether x or
y has to be evaluated first, so if x and y have to be evaluated in
that order, an expression like (!x & !y) can be the cause of very
subtle bugs. I prefer readability above brevity.

Bart Van Assche.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH 7/16] Let void have sizeof 1 ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH 7/16] Let void have sizeof 1
Date: Thu, 18 Dec 2008 22:32:28 +0000
Message-ID: <20081218223216.23692.711.stgit () zaytsev ! su>
--------------------
Gcc assumes sizeof(void) being 1.
Currently sparse would generate wrong code for:

void *test(void *p) {
       p++;
       return p;
}

unsigned long test1(void *p)
{
       return sizeof(*p);
}

.L0x2b48867c1010:
       <entry-point>
       add.32      %r2 <- %arg1, $-1
       ret.32      %r2

test1:
.L0x2b48867c10b0:
       <entry-point>
       ret.32      $-1

And with bit_size set to &bits_in_char, the code looks
as expected.

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---
 symbol.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/symbol.c b/symbol.c
index 4da253b..02844cf 100644
--- a/symbol.c
+++ b/symbol.c
@@ -834,7 +834,7 @@ static const struct ctype_declare {
 	struct symbol *base_type;
 } ctype_declaration[] = {
 	{ &bool_ctype,	    SYM_BASETYPE, MOD_UNSIGNED,		    &bits_in_bool,	     &max_int_alignment, &int_type },
-	{ &void_ctype,	    SYM_BASETYPE, 0,			    NULL,		     NULL,		 NULL },
+	{ &void_ctype,	    SYM_BASETYPE, 0,			    &bits_in_char,	     NULL,		 NULL },
 	{ &type_ctype,	    SYM_BASETYPE, MOD_TYPE,		    NULL,		     NULL,		 NULL },
 	{ &incomplete_ctype,SYM_BASETYPE, 0,			    NULL,		     NULL,		 NULL },
 	{ &bad_ctype,	    SYM_BASETYPE, 0,			    NULL,		     NULL,		 NULL },

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Tue, 23 Dec 2008 04:37:34 +0000
Message-ID: <f19298770812222037l6dbe5b35t4803138e20bab04d () mail ! gmail ! com>
--------------------
On Tue, Dec 23, 2008 at 06:51, Christopher Li <sparse@chrisli.org> wrote:
> Void type is an incomplete type. It should not have storage size.
But how about void *? If void *p = x, what p+1 should be? Gcc defines
sizeof(void) being 1, and people seem to know and use this.
http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Warning-Options.html#index-Wno_002dpointer_002darith-347

In the Linux kernel, we've got lots of void * address arithmetics:
linux/linux-2.6$ make -j 8 CC='gcc -Wpointer-arith' 2>&1 | grep
'warning: pointer of type \'void \*\' used in arithmetic' | uniq | wc
-l
45095

So even if we can't agree if such use is legid or not, we definetely
have to support this in sparse. And there is no need to warn about
it, as gcc already can do this.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Tue, 23 Dec 2008 05:51:58 +0000
Message-ID: <70318cbf0812222151x11be46a4yde0327a0e62bb0ba () mail ! gmail ! com>
--------------------
> But how about void *? If void *p = x, what p+1 should be? Gcc defines
> sizeof(void) being 1, and people seem to know and use this.
> http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Warning-Options.html#index-Wno_002dpointer_002darith-347

Using pointer arithmetic on void* is not as crazy as using
sizeof(void) directly. Most people using void* arithmetic is
thinking it as char *. You should able to add a one line change
in evaluate_ptr_add() to allow void* pointer arithmetic.

Still better than hard code sizeof(void) as 1.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Tue, 23 Dec 2008 06:09:36 +0000
Message-ID: <f19298770812222209w7ce56ba5q48ecc92554443879 () mail ! gmail ! com>
--------------------
On Tue, Dec 23, 2008 at 08:51, Christopher Li <sparse@chrisli.org> wrote:
>> But how about void *? If void *p = x, what p+1 should be? Gcc defines
>> sizeof(void) being 1, and people seem to know and use this.
>> http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Warning-Options.html#index-Wno_002dpointer_002darith-347
>
> Using pointer arithmetic on void* is not as crazy as using
> sizeof(void) directly. Most people using void* arithmetic is
> thinking it as char *. You should able to add a one line change
> in evaluate_ptr_add() to allow void* pointer arithmetic.
>
> Still better than hard code sizeof(void) as 1.

I don't really see the problem. It's not like you can pass
void i; or void *p; *p = 5; or store something into void anyway.
And in gcc void *p; sizeof(*p) == 1, so void realy looks like
being sizeof 1.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Tue, 23 Dec 2008 09:00:18 +0000
Message-ID: <4950A8A2.5090702 () knosof ! co ! uk>
--------------------
Alexey,

>> In the Linux kernel, we've got lots of void * address arithmetics:
>> linux/linux-2.6$ make -j 8 CC='gcc -Wpointer-arith' 2>&1 | grep
>> 'warning: pointer of type \'void \*\' used in arithmetic' | uniq | wc
>> -l
>> 45095
> I screwed up, it should be | sort -u | uniq | wc -l
> But it's still 14488.

This is a sufficiently large number that we ought to consider adding
checks for the usage, for instance:

    1) Are the arguments really chars of one sort or another and
therefore the parameter ought to be declared as such?

    2) The arguments have various structure and/or array types and
the storage is being walked over in the called function.  Can the
minimum size ever passed be worked out and this information used in
the size_void (my proposed name for a pointer that has either sizeof,
++ or -- performed on it) function to check for overruns.

    3) Are there any restrictions on passing a void pointer to a
size_void function or vice versa?  I cannot think of any obvious
ones, but then I don't know the various kinds of circumstances
in which this happens.

    4) Other possible fault issues, people?

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Wed, 24 Dec 2008 00:26:40 +0000
Message-ID: <495181C0.7070803 () knosof ! co ! uk>
--------------------
Alexey,

I have been looking through the source to look at the contexts
in which arithmetic is performed on void pointers.

>>   1) Are the arguments really chars of one sort or another and
>> therefore the parameter ought to be declared as such?
> You mean, if address arithmetics is performed on a void * cast result,
> check that the casted type too has sizeof 1?

I was thinking more along the lines of pointer to a character type being
converted to void * for no obvious reason, or a value being converted to
void * having an arithmetic operation performed and then converted to
a pointer to character type.
For an example see line 156 of arch/x86/kernel/module_64.c

I would expect the void * to come from/go to a type that had a
size greater than 1.

>>   4) Other possible fault issues, people?

I have found an instance (arch/x86/kernel/kprobes.c:834) that
effectively does:

(void *)long_val + an_int_calculation

when it should have done:

(void *)(long_val + an_int_calculation)

hardly an earth shattering misuse.

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Wed, 24 Dec 2008 02:39:40 +0000
Message-ID: <f19298770812231839n1aaaf84fla96dda04b11e0944 () mail ! gmail ! com>
--------------------
On Wed, Dec 24, 2008 at 03:26, Derek M Jones <derek@knosof.co.uk> wrote:
> Alexey,
>
> I have been looking through the source to look at the contexts
> in which arithmetic is performed on void pointers.
>
>>>  1) Are the arguments really chars of one sort or another and
>>> therefore the parameter ought to be declared as such?
>>
>> You mean, if address arithmetics is performed on a void * cast result,
>> check that the casted type too has sizeof 1?
>
> I was thinking more along the lines of pointer to a character type being
> converted to void * for no obvious reason, or a value being converted to
> void * having an arithmetic operation performed and then converted to
> a pointer to character type.
> For an example see line 156 of arch/x86/kernel/module_64.
>
> I would expect the void * to come from/go to a type that had a
> size greater than 1.
>
>>>  4) Other possible fault issues, people?
>
> I have found an instance (arch/x86/kernel/kprobes.c:834) that
> effectively does:
>
> (void *)long_val + an_int_calculation
>
> when it should have done:
>
> (void *)(long_val + an_int_calculation)
>
> hardly an earth shattering misuse.
There is nothing wrong here. Just depends on the way you think
about it. In the first case you convert a long to a pointer, and add
an int, the the second, you convert the sum. The result is of course
the same. And this has nothing to do with void*, it would be the
same with char*.

So far the only concern with void* is that not everyone knows
the it is sizeof 1. So if you propose repulsing void* with char*
when we don't really need a void*, that's probably fine. But don't
you think there are more useful ways to spend your time?
With open issues like the Global Warming, World Hunger and
standing 2.6.28 regressions, I don't see anyone bothered with
replacing unnecessary void* casts.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Wed, 24 Dec 2008 21:59:09 +0000
Message-ID: <4952B0AD.7040007 () cowlark ! com>
--------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Alexey Zaytsev wrote:
[...]
> So far the only concern with void* is that not everyone knows
> the it is sizeof 1. So if you propose repulsing void* with char*
> when we don't really need a void*, that's probably fine. But don't
> you think there are more useful ways to spend your time?
> With open issues like the Global Warming, World Hunger and
> standing 2.6.28 regressions, I don't see anyone bothered with
> repacing unnecessary void* casts.

The thing is, sizeof(void) is *not* 1. sizeof(void) is *illegal*. It
just happens that gcc, as a platform-specific extension, treats
sizeof(void) as 1 by default.

As a linter, sparse really ought not to be encouraging non-portable
behaviour. Admittedly, there's so much stuff in the kernel source that's
gcc-specific that it's probably not going to be possible to make it
build on anything else, but it should still warn people about it unless
specifically told otherwise --- it's bad practice, and may be indicative
of further problems elsewhere, and as such is worth a diagnostic.

- --
David Given
dg@cowlark.com
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFJUrCmf9E0noFvlzgRAkRCAJwPffkuAuAMxfJJSkh+H7AlIPHQkQCgtGRQ
0t71dcB7ZaIKud6Qi5XXrx8=
=83ss
-----END PGP SIGNATURE-----
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Wed, 24 Dec 2008 23:10:31 +0000
Message-ID: <70318cbf0812241510o2318f701w938840b9123fb9e4 () mail ! gmail ! com>
--------------------
On Wed, Dec 24, 2008 at 1:59 PM, David Given <dg@cowlark.com> wrote:
> The thing is, sizeof(void) is *not* 1. sizeof(void) is *illegal*. It
> just happens that gcc, as a platform-specific extension, treats
> sizeof(void) as 1 by default.

Exactly. I am unhappy about that patch as well.
Sparse internally use symbol->bit_size == 0 to determine uncompleted type.
Thanks this change. Now is_byte_type() will return true for void type as well.

> As a linter, sparse really ought not to be encouraging non-portable
> behaviour. Admittedly, there's so much stuff in the kernel source that's
> gcc-specific that it's probably not going to be possible to make it
> build on anything else, but it should still warn people about it unless
> specifically told otherwise --- it's bad practice, and may be indicative
> of further problems elsewhere, and as such is worth a diagnostic.

I don't see the kernel directly use sizeof(void). Most of the place is
using (void*) pointer + offset. It is not portable. But it is probably not
worthy while to fix. Convert the void* to char*, add offset, convert it back
to void* is pretty annoying as well. If we really want to make it clean, maybe
we can use a macro or inline functions. Again, probably not worth the effort.

But legitimize sizeof(void) == 1 is a different story. That I feel is just
plain wrong.

Even gcc is self contradicting regarding the size of void.
Compiling "void i;" will give you:
/tmp/void.c:1: error: storage size of 'i' isn't known

I saw Josh just merge the sizeof(void) patch. Oh well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 7/16] Let void have sizeof 1
Date: Thu, 25 Dec 2008 00:15:20 +0000
Message-ID: <70318cbf0812241615m22b9597coc68a5b3ceb9e09a5 () mail ! gmail ! com>
--------------------
On Wed, Dec 24, 2008 at 3:35 PM, Tommy Thorn <tommy@numba-tu.com> wrote:
>
> You can't have one without the other as you will break identities like
>
>  (uintptr_t) (x + k) === (uintptr_t) x + sizeof (typeof (x)) * k
>
> which could appear in a macro.

Right. That is exactly the place I actuall want to know. We should
consider fix that in the source to have proper type. I expect there is
not much place in the kernel use that.

I can write some code to find out how many place in the kernel
actually need to evaluate sizeof(void).

What do you think?

>
> I really think you should let it go. The C standard for Linux is for all
> practical purposes GCC C, not C99 C.
>
> Trying to impose a stricter standard will just make sparse a less useful
> tool.

I understand that kernel is C stander gcc. But the whole point of sparse is
stricter than gcc. Otherwise we will just use gcc instead.

I agree that we should probably let the place use void* + offset go.

It all boils down to do we care about place directly use sizeof(void) or not.

Another aspect is that, inside sparse, it become very hard to distinguish
void vs char, other than compare it is &void_ctype or not. If we decide go
with sizeof(void) == 1. Those place that assume only uncompleted ctype
will have bit_size == 0 need to be fixed as well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/9] test conditional result locking ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 7/9] test conditional result locking
Date: Thu, 29 May 2008 08:54:09 +0000
Message-ID: <20080529085517.605471000 () sipsolutions ! net>
--------------------
To test a function that can return a locked struct or NULL,
a macro has to be invented. Add a test case for that.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 validation/context-vars.c |   29 +++++++++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)

--- sparse.orig/validation/context-vars.c	2008-04-27 14:10:37.000000000 +0200
+++ sparse/validation/context-vars.c	2008-04-27 14:41:41.000000000 +0200
@@ -1,3 +1,5 @@
+#include <stddef.h>
+
 static void a(void *p) __attribute__((context(p,0,1)))
 {
     __context__(p,1);
@@ -159,13 +161,32 @@ static void good_locked_val(void)
     ;
 }
 
+
+extern struct test *_search(int key);
+
+#define search(res, key) do {	\
+  (res) = _search((key));	\
+  if (res)			\
+      __context__(&(res)->lock,1);\
+  } while (0)
+
+static void test(void)
+{
+    struct test **x;
+
+    search(*x, 32);
+    if (*x)
+      unlock(*x);
+}
+
+
 /*
  * check-name: Check -Wcontext with lock variables
  *
  * check-error-start
-context-vars.c:53:7: warning: context imbalance in 'warn_lock1': wrong count at exit
-context-vars.c:53:7:    context '**v+4': wanted 0, got 1
-context-vars.c:137:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
-context-vars.c:137:11:    context '*t+0': wanted >= 1, got 0
+context-vars.c:55:7: warning: context imbalance in 'warn_lock1': wrong count at exit
+context-vars.c:55:7:    context '**v+4': wanted 0, got 1
+context-vars.c:139:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
+context-vars.c:139:11:    context '*t+0': wanted >= 1, got 0
  * check-error-end
  */

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 8/9] show required context in instruction output ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 8/9] show required context in instruction output
Date: Thu, 29 May 2008 08:54:10 +0000
Message-ID: <20080529085518.170577000 () sipsolutions ! net>
--------------------
Just eases debugging sparse/the context tracking itself.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 expression.c |    2 ++
 linearize.c  |    2 +-
 2 files changed, 3 insertions(+), 1 deletion(-)

--- sparse.orig/expression.c	2008-04-28 16:18:40.000000000 +0200
+++ sparse/expression.c	2008-04-28 16:18:40.000000000 +0200
@@ -648,6 +648,8 @@ static struct token *postfix_expression(
 					copy->in = c->in;
 					copy->out = c->out;
 					copy->exact = c->exact;
+					copy->token = c->token;
+					copy->in_fn = c->context;
 					add_ptr_list(&call->contexts, copy);
 
 					if (!c->token)
--- sparse.orig/linearize.c	2008-04-28 16:18:40.000000000 +0200
+++ sparse/linearize.c	2008-04-28 16:18:40.000000000 +0200
@@ -443,7 +443,7 @@ const char *show_instruction(struct inst
 			expression_str(insn->context_expr, ctxbuf, sizeof(ctxbuf));
 			buf += sprintf(buf, "%s, ", ctxbuf);
 		}
-		buf += sprintf(buf, "%d", insn->increment);
+		buf += sprintf(buf, "%d %d", insn->increment, insn->required);
 		break;
 	}
 	case OP_RANGE:

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 9/9 v2] check inlines explicitly ===

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 9/9 v2] check inlines explicitly
Date: Thu, 29 May 2008 23:20:42 +0000
Message-ID: <1212103242.28403.158.camel () brick>
--------------------
On Fri, 2008-05-30 at 01:14 +0200, Johannes Berg wrote:
> An earlier patch disabled checking through inline functions because
> inlining them clashes with the context tracking code, so this now
> makes sparse check the inline functions as though they were really
> functions.
> 
> Signed-off-by: Johannes Berg <johannes@sipsolutions.net>

Works for me.

Harvey

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 9/9] check inlines explicitly ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH 9/9] check inlines explicitly
Date: Thu, 29 May 2008 08:54:11 +0000
Message-ID: <20080529085519.078206000 () sipsolutions ! net>
--------------------
An earlier patch disabled checking through inline functions because
inlining them clashes with the context tracking code, so this now
makes sparse check the inline functions as though they were really
functions.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 sparse.c |   15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

--- sparse.orig/sparse.c	2008-05-29 10:19:13.000000000 +0200
+++ sparse/sparse.c	2008-05-29 10:19:14.000000000 +0200
@@ -29,11 +29,12 @@ struct context_check {
 	const struct expression *expr;
 };
 
-DECLARE_ALLOCATOR(context_check);
 DECLARE_PTR_LIST(context_check_list, struct context_check);
 DECLARE_PTR_LIST(context_list_list, struct context_check_list);
 ALLOCATOR(context_check, "context check list");
 
+static struct symbol_list *inline_list = NULL;
+
 
 static void context_add(struct context_check_list **ccl,
 			const struct expression *expr,
@@ -277,6 +278,15 @@ static int check_bb_context(struct entry
 	 */
 	FOR_EACH_PTR(bb->insns, insn) {
 		switch (insn->opcode) {
+		case OP_INLINED_CALL: {
+			if (!insn->func->sym)
+				break;
+			if (insn->func->sym->visited)
+				break;
+			insn->func->sym->visited = 1;
+			add_ptr_list(&inline_list, insn->func->sym);
+			break;
+		}
 		case OP_CONTEXT:
 			if (handle_context(ep, bb, insn, &combined))
 				goto out;
@@ -545,6 +555,9 @@ int main(int argc, char **argv)
 	check_symbols(sparse_initialize(argc, argv, &filelist));
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		check_symbols(sparse(file));
+		evaluate_symbol_list(inline_list);
+		check_symbols(inline_list);
+		free_ptr_list(&inline_list);
 	} END_FOR_EACH_PTR_NOTAG(file);
 	return 0;
 }

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 6/5] test conditional result locking ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH v2 6/5] test conditional result locking
Date: Sun, 27 Apr 2008 12:45:53 +0000
Message-ID: <1209300353.29025.1.camel () johannes ! berg>
--------------------
To test a function that can return a locked struct or NULL,
a macro has to be invented. Add a test case for that.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
The macro was a mess, this one's much better. The key is to pass in the
result variable and use it in __context__.

 validation/context-vars.c |   29 +++++++++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)

--- sparse.orig/validation/context-vars.c	2008-04-27 14:10:37.000000000 +0200
+++ sparse/validation/context-vars.c	2008-04-27 14:41:41.000000000 +0200
@@ -1,3 +1,5 @@
+#include <stddef.h>
+
 static void a(void *p) __attribute__((context(p,0,1)))
 {
     __context__(p,1);
@@ -159,13 +161,32 @@ static void good_locked_val(void)
     ;
 }
 
+
+extern struct test *_search(int key);
+
+#define search(res, key) do {	\
+  (res) = _search((key));	\
+  if (res)			\
+      __context__(&(res)->lock,1);\
+  } while (0)
+
+static void test(void)
+{
+    struct test **x;
+
+    search(*x, 32);
+    if (*x)
+      unlock(*x);
+}
+
+
 /*
  * check-name: Check -Wcontext with lock variables
  *
  * check-error-start
-context-vars.c:53:7: warning: context imbalance in 'warn_lock1': wrong count at exit
-context-vars.c:53:7:    context '**v+4': wanted 0, got 1
-context-vars.c:137:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
-context-vars.c:137:11:    context '*t+0': wanted >= 1, got 0
+context-vars.c:55:7: warning: context imbalance in 'warn_lock1': wrong count at exit
+context-vars.c:55:7:    context '**v+4': wanted 0, got 1
+context-vars.c:139:11: warning: context problem in 'warn_unlock': 'unlock' expected different context
+context-vars.c:139:11:    context '*t+0': wanted >= 1, got 0
  * check-error-end
  */


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add -ftabstop=WIDTH ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Add -ftabstop=WIDTH
Date: Wed, 31 Dec 2008 20:26:58 +0000
Message-ID: <70318cbf0812311226gc18b63dld37072c3b7f41719 () mail ! gmail ! com>
--------------------
------=_Part_165783_3866624.1230755218703
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Wed, Dec 31, 2008 at 4:41 AM, Hannes Eder <hannes@hanneseder.net> wrote:
> Make tokenizer aware of tabstops and add the commandline option:
>
> -ftabstop=WIDTH
>    Set the distance between tab stops.  This helps sparse report correct
>    column numbers in warnings or errors.  If the value is less than 1 or
>    greater than 100, the option is ignored.  The default is 8.
>

I took the liberty to simplify the patch a little bit. See the attachment.

If there is no objections, I am going to apply the combined patch to
my repository:

git://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git

Thanks,

Chris

------=_Part_165783_3866624.1230755218703
Content-Type: application/octet-stream;
 name=0001-Simplify-fstabstop-patch.patch
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fpefjxj80
Content-Disposition: attachment;
 filename=0001-Simplify-fstabstop-patch.patch

RnJvbSAyNDdmZTFhYTlmZWM4ZTkxM2I1MzNmZmYyOGIxNDEyZmM2Y2JiOTQxIE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBXZWQsIDMxIERlYyAyMDA4IDEyOjEzOjExIC0wODAwClN1YmplY3Q6IFtQQVRDSF0gU2lt
cGxpZnkgLWZzdGFic3RvcCBwYXRjaAoKU2lnbmVkLW9mZi1ieTogQ2hyaXN0b3BoZXIgTGkgPHNw
YXJzZUBjaHJpc2xpLm9yZz4KLS0tCiBsaWIuYyAgICAgIHwgICAyOSArKysrKysrLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQogdG9rZW4uaCAgICB8ICAgIDIgKy0KIHRva2VuaXplLmMgfCAgIDEwICsr
KysrLS0tLS0KIDMgZmlsZXMgY2hhbmdlZCwgMTMgaW5zZXJ0aW9ucygrKSwgMjggZGVsZXRpb25z
KC0pCgpkaWZmIC0tZ2l0IGEvbGliLmMgYi9saWIuYwppbmRleCA3YmFkNDUxLi5kZTBiMDlhIDEw
MDY0NAotLS0gYS9saWIuYworKysgYi9saWIuYwpAQCAtNTMyLDMzICs1MzIsMTggQEAgc3RhdGlj
IGNoYXIgKipoYW5kbGVfc3dpdGNoX2YoY2hhciAqYXJnLCBjaGFyICoqbmV4dCkKIAogCWlmICgh
c3RybmNtcCAoYXJnLCAidGFic3RvcD0iLCA4KSkgewogCQljaGFyICplbmQ7Ci0JCWxvbmcgdmFs
OworCQl1bnNpZ25lZCBsb25nIHZhbDsKIAkJYXJnICs9IDg7CiAKIAkJZXJybm8gPSAwOwotCQl2
YWwgPSBzdHJ0b2woYXJnLCAmZW5kLCAxMCk7CisJCXZhbCA9IHN0cnRvdWwoYXJnLCAmZW5kLCAx
MCk7CiAKLQkJaWYgKChlcnJubyA9PSBFUkFOR0UgJiYgKHZhbCA9PSBMT05HX01BWCB8fCB2YWwg
PT0gTE9OR19NSU4pKQotCQkgICAgfHwgKGVycm5vICE9IDAgJiYgdmFsID09IDApKSB7Ci0JCQlk
aWUoImludmFsaWQgYXJndW1lbnQgZm9yIHRoZSAtZnRhYnN0b3A9IG9wdGlvbjogJXMiLCBzdHJl
cnJvcihlcnJubykpOwotCQl9Ci0KLQkJaWYgKGVuZCA9PSBhcmcpIHsKLQkJCWRpZSgibWlzc2lu
ZyBhcmd1bWVudCBmb3IgdGhlIC1mdGFic3RvcD0gb3B0aW9uIik7Ci0JCX0KLQotCQlpZiAoKmVu
ZCAhPSAnXDAnKSB7Ci0JCQkvKiBmdXJ0aGVyIGNoYXJhY3RlcnMgYWZ0ZXIgbnVtYmVyICovCi0J
CQkvKiB3ZSBqdXN0IGlnbm9yZSB0aGVtICovCi0JCX0KLQotCQlpZiAoMSA8PSB2YWwgJiYgdmFs
IDw9IDEwMCkKLQkJCXRhYnN0b3Bfd2lkdGggPSB2YWw7Ci0KLQkJcmV0dXJuIG5leHQ7Ci0JfQor
CQlpZiAoIXZhbCB8fCB2YWwgPiAxMDApCisJCQlkaWUoImludmFsaWQgYXJndW1lbnQgZm9yIHRo
ZSAtZnRhYnN0b3A9IG9wdGlvbjogJWxkIiwgdmFsKTsKKwkJcHJpbnRmKCJ0YWJzdG9wPSAlbGRc
biIsIHZhbCk7CisJCXRhYnN0b3Bfd2lkdGggPSB2YWw7CiAKLQlpZiAoIXN0cm5jbXAoYXJnLCAi
bm8tIiwgMykpIHsKKwl9IGVsc2UgaWYgKCFzdHJuY21wKGFyZywgIm5vLSIsIDMpKSB7CiAJCWZs
YWcgPSAwOwogCQlhcmcgKz0gMzsKIAl9CmRpZmYgLS1naXQgYS90b2tlbi5oIGIvdG9rZW4uaApp
bmRleCBkZjdhODBjLi40Yzk5ODg3IDEwMDY0NAotLS0gYS90b2tlbi5oCisrKyBiL3Rva2VuLmgK
QEAgLTQ4LDcgKzQ4LDcgQEAgc3RydWN0IHN0cmVhbSB7CiAKIGV4dGVybiBpbnQgaW5wdXRfc3Ry
ZWFtX25yOwogZXh0ZXJuIHN0cnVjdCBzdHJlYW0gKmlucHV0X3N0cmVhbXM7Ci1leHRlcm4gaW50
IHRhYnN0b3Bfd2lkdGg7CitleHRlcm4gdW5zaWduZWQgaW50IHRhYnN0b3Bfd2lkdGg7CiAKIHN0
cnVjdCBpZGVudCB7CiAJc3RydWN0IGlkZW50ICpuZXh0OwkvKiBIYXNoIGNoYWluIG9mIGlkZW50
aWZpZXJzICovCmRpZmYgLS1naXQgYS90b2tlbml6ZS5jIGIvdG9rZW5pemUuYwppbmRleCA4YjNl
YzJmLi5lNmY5ZDEzIDEwMDY0NAotLS0gYS90b2tlbml6ZS5jCisrKyBiL3Rva2VuaXplLmMKQEAg
LTI1LDcgKzI1LDcgQEAKIGludCBpbnB1dF9zdHJlYW1fbnIgPSAwOwogc3RydWN0IHN0cmVhbSAq
aW5wdXRfc3RyZWFtczsKIHN0YXRpYyBpbnQgaW5wdXRfc3RyZWFtc19hbGxvY2F0ZWQ7Ci1pbnQg
dGFic3RvcF93aWR0aCA9IDg7Cit1bnNpZ25lZCBpbnQgdGFic3RvcF93aWR0aCA9IDg7CiAKICNk
ZWZpbmUgQlVGU0laRSAoODE5MikKIApAQCAtMjA3LDcgKzIwNyw3IEBAIHN0YXRpYyBpbnQgbmV4
dGNoYXJfc2xvdyhzdHJlYW1fdCAqc3RyZWFtKQogCWludCBvZmZzZXQgPSBzdHJlYW0tPm9mZnNl
dDsKIAlpbnQgc2l6ZSA9IHN0cmVhbS0+c2l6ZTsKIAlpbnQgYzsKLQlpbnQgc3BsaWNlZCA9IDAs
IGhhZF9jciwgaGFkX2JhY2tzbGFzaCwgY29tcGxhaW47CisJaW50IHNwbGljZWQgPSAwLCBoYWRf
Y3IsIGhhZF9iYWNrc2xhc2gsIGNvbXBsYWluLCBkZWx0YTsKIAogcmVzdGFydDoKIAloYWRfY3Ig
PSBoYWRfYmFja3NsYXNoID0gY29tcGxhaW4gPSAwOwpAQCAtMjMzLDEwICsyMzMsMTAgQEAgcmVw
ZWF0OgogCQlnb3RvIHJlcGVhdDsKIAl9CiAKKwlkZWx0YSA9IDE7CiAJaWYgKGMgPT0gJ1x0JykK
LQkJc3RyZWFtLT5wb3MgPSAoKHN0cmVhbS0+cG9zIC0gMSkgLyB0YWJzdG9wX3dpZHRoICsgMSkg
KiB0YWJzdG9wX3dpZHRoOwotCWVsc2UKLQkJc3RyZWFtLT5wb3MrKzsKKwkJZGVsdGEgPSB0YWJz
dG9wX3dpZHRoIC0gc3RyZWFtLT5wb3MgJSB0YWJzdG9wX3dpZHRoOworCXN0cmVhbS0+cG9zICs9
IGRlbHRhOwogCiAJaWYgKGMgPT0gJ1xuJykgewogCQlzdHJlYW0tPmxpbmUrKzsKLS0gCjEuNi4w
LjYKCg==
------=_Part_165783_3866624.1230755218703--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Also warn about sizeof(function) ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH] Also warn about sizeof(function)
Date: Thu, 25 Dec 2008 20:10:58 +0000
Message-ID: <20081225200613.15414.96407.stgit () zaytsev ! su>
--------------------
Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---

> Hi Alexey,
> 
> On Thu, Dec 25, 2008 at 10:36 AM, Alexey Zaytsev
> <alexey.zaytsev@gmail.com> wrote:
>> I added (hopefully the right way) handling of (sizeof(function)) to the
>> patch. function++ was already prohibited.
> 
> Can you send me an incremental patch for the sizeof(function) change?
Sure. Btw, your patches come demaged lately. Could you please use
git-send-email to send them in the future?

> BTW, is it one of the gcc special treatment as well?

It was just mentioned in the same option's description:
http://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/gcc/pointer-arith.html

 evaluate.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index e23c4eb..1424ce1 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2049,6 +2049,12 @@ static struct symbol *evaluate_sizeof(struct expression *expr)
 		warning(expr->pos, "expression using sizeof(void)");
 		size = bits_in_char;
 	}
+
+	if (is_function(type->ctype.base_type)) {
+		warning(expr->pos, "expression using sizeof on a function");
+		size = bits_in_char;
+	}
+
 	if ((size < 0) || (size & (bits_in_char - 1)))
 		expression_error(expr, "cannot size expression");
 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Also warn about sizeof(function)
Date: Fri, 26 Dec 2008 00:48:19 +0000
Message-ID: <70318cbf0812251648j115548e9u6409423382dec657 () mail ! gmail ! com>
--------------------
Thanks, apply and pushed.

On Thu, Dec 25, 2008 at 12:10 PM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:
> Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
> ---
>
>> Hi Alexey,
>>
> Sure. Btw, your patches come demaged lately. Could you please use
> git-send-email to send them in the future?

Sorry about that. I will use attachment to send them next time. I am
still learning my way to use git properly.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Expand initializers when testing them for being constant ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: [PATCH] Expand initializers when testing them for being constant
Date: Sun, 01 Jun 2008 23:26:18 +0000
Message-ID: <20080601232618.32306.5330.stgit () dv ! roinet ! com>
--------------------
Signed-off-by: Pavel Roskin <proski@gnu.org>
---

 expand.c                        |    2 ++
 validation/array-size-known.c   |    9 +++++++++
 validation/array-size-unknown.c |   14 ++++++++++++++
 3 files changed, 25 insertions(+), 0 deletions(-)
 create mode 100644 validation/array-size-known.c
 create mode 100644 validation/array-size-unknown.c

diff --git a/expand.c b/expand.c
index 032f0c5..bbe8d6c 100644
--- a/expand.c
+++ b/expand.c
@@ -620,6 +620,8 @@ static int expand_dereference(struct expression *expr)
 
 		/* Const symbol with a constant initializer? */
 		if (value) {
+			expand_expression(value);
+
 			/* FIXME! We should check that the size is right! */
 			if (value->type == EXPR_VALUE) {
 				expr->type = EXPR_VALUE;
diff --git a/validation/array-size-known.c b/validation/array-size-known.c
new file mode 100644
index 0000000..8f4603a
--- /dev/null
+++ b/validation/array-size-known.c
@@ -0,0 +1,9 @@
+void foo(void);
+void foo(void) {
+	const int len = 32 + 32;
+	int buf[len];
+	buf[0] = 0;
+}
+/*
+ * check-name: Array size known at the compile time
+ */
diff --git a/validation/array-size-unknown.c b/validation/array-size-unknown.c
new file mode 100644
index 0000000..825accb
--- /dev/null
+++ b/validation/array-size-unknown.c
@@ -0,0 +1,14 @@
+extern int extra;
+void foo(void);
+void foo(void) {
+	const int len = 32 + extra;
+	int buf[len];
+	buf[0] = 0;
+}
+/*
+ * check-name: Array size unknown at the compile time
+ *
+ * check-error-start
+array-size-unknown.c:5:10: error: bad constant expression
+ * check-error-end
+ */
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix use of invalid file descriptor ===

From: Vegard Nossum <vegard.nossum () gmail ! com>
To: linux-sparse
Subject: [PATCH] Fix use of invalid file descriptor
Date: Sun, 25 May 2008 07:51:57 +0000
Message-ID: <20080525075157.GA3681 () damson ! getinternet ! no>
--------------------
From: Vegard Nossum <vegardno@ifi.uio.no>
Date: Sun, 25 May 2008 09:41:29 +0200
Subject: [PATCH] Fix use of invalid file descriptor

tokenize_buffer() calls setup_stream() with a file descriptor argument of -1.
This number makes it all the way into nextchar_slow(), where -1 is used as an
actual file descriptor when calling read().

Check for the -1 before calling read() if the buffer is empty.

(By the way, that read() there is probably missing some additional error
 handling. An EINTR at the right moment...)

Signed-off-by: Vegard Nossum <vegardno@ifi.uio.no>
---
 tokenize.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/tokenize.c b/tokenize.c
index e72c56e..d154882 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -213,6 +213,8 @@ restart:
 
 repeat:
 	if (offset >= size) {
+		if (stream->fd < 0)
+			goto got_eof;
 		size = read(stream->fd, stream->buffer, BUFSIZE);
 		if (size <= 0)
 			goto got_eof;
-- 
1.5.4.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Ignore "cold" and "hot" attributes, which appeared in gcc 4.3 ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: [PATCH] Ignore "cold" and "hot" attributes, which appeared in gcc 4.3
Date: Fri, 25 Apr 2008 08:25:35 +0000
Message-ID: <20080425082534.7034.76060.stgit () dv ! roinet ! com>
--------------------
They describe how likely the function is to be executed, which can
affect optimization.  Also ignore attributes with underscores.

Signed-off-by: Pavel Roskin <proski@gnu.org>
---

 ident-list.h |    2 ++
 parse.c      |    4 ++++
 2 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/ident-list.h b/ident-list.h
index 8fcd7de..6104826 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -74,6 +74,8 @@ IDENT(__malloc__);
 IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
 IDENT(constructor); IDENT(__constructor__);
 IDENT(destructor); IDENT(__destructor__);
+IDENT(cold); IDENT(__cold__);
+IDENT(hot); IDENT(__hot__);
 IDENT(cdecl); IDENT(__cdecl__);
 IDENT(stdcall); IDENT(__stdcall__);
 IDENT(fastcall); IDENT(__fastcall__);
diff --git a/parse.c b/parse.c
index 137ba77..877414c 100644
--- a/parse.c
+++ b/parse.c
@@ -353,6 +353,10 @@ static struct init_keyword {
 	{ "__constructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "destructor",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "__destructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "cold",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__cold__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "hot",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__hot__",	NS_KEYWORD,	.op = &ignore_attr_op },
 };
 
 void init_parser(int stream)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Null ctype should have ptr_ctype as its base type. ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: [PATCH] Null ctype should have ptr_ctype as its base type.
Date: Sun, 28 Dec 2008 15:14:03 +0000
Message-ID: <20081228151134.6062.83633.stgit () zaytsev ! su>
--------------------
Amirite?

Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
---

On Thu, Dec 25, 2008 at 21:36, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:
> Tommy Thorn wrote:
>> Christopher Li wrote:
>>> So here is what I got. A patch address both of our need. It gives warning
>>> of using sizeof(void) explicitly. void* + offset will continue to work without
>>> warnings. It will also make is_byte_type() continue to work as it was
>>> before.
>>>
>>> Here is my test script:
>>>
>>> void *p;
>>>
>>> int i = sizeof(void);
>>> int j = sizeof(*p);
>>>
>
>> I can't test it right now, but does it give a warning for both sizeof's
>> above? If just first results in a warning, then I think that quite
>> reasonable.
>
> Both trigger the warning. I'm not sure this is a problem, as there are
> no such usage cases in the kernel.
>
> I added (hopefully the right way) handling of (sizeof(function)) to the
> patch. function++ was already prohibited.
>
> Running the test on the kernel right now.
>

And it found something.

2158a2159
> fs/compat_ioctl.c:787:10: warning: expression using sizeof on a function
9524a9526,9543
> drivers/media/video/gspca/sonixb.c:494:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:494:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:494:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:495:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:495:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:495:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:496:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:498:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:498:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:498:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:500:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:500:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:502:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:502:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:502:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:504:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:504:1: warning: expression using sizeof(void)
> drivers/media/video/gspca/sonixb.c:504:1: warning: expression using sizeof(void)
15293a15313,15325
> net/netfilter/nf_conntrack_sip.c:282:21: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:282:21: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:287:23: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:287:23: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:288:29: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:586:23: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:586:23: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:587:25: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:588:29: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:589:25: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:590:29: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:591:22: warning: expression using sizeof(void)
> net/netfilter/nf_conntrack_sip.c:591:22: warning: expression using sizeof(void)

The first one is

        if (copy_in_user(&sgio->status, sgio32->status,
                         (4 * sizeof(unsigned char)) +
                         (2 * sizeof(unsigned (short))) +       <------- oops
                         (3 * sizeof(int))))
                return -EFAULT;

a bug. So, if anyone ever missed his sgio.info, now we know why.
Patch sent.

drivers/media/video/gspca/sonixb.c looks like

SENS(initHv7131, NULL, hv7131_sensor_init, NULL, NULL, 0, NO_EXPO|NO_FREQ, 0),

#define SENS(bridge_1, bridge_3, sensor, sensor_1, \
        sensor_3, _flags, _ctrl_dis, _sensor_addr) \
{ \
        .bridge_init = { bridge_1, bridge_3 }, \
        .bridge_init_size = { sizeof(bridge_1), sizeof(bridge_3) }, \

So, we are getting a sizeof(NULL), or a sizeof((void *)0). It triggers here
because we are getting a null_ctype, and it's base_type points to
void_ctype. I'm not sure if this patch is correct, but it seems to do
the trick, all void warnings are gone. Christopher?

 symbol.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/symbol.c b/symbol.c
index 4da253b..df760d4 100644
--- a/symbol.c
+++ b/symbol.c
@@ -861,7 +861,7 @@ static const struct ctype_declare {
 
 	{ &string_ctype,    SYM_PTR,	  0,			    &bits_in_pointer,        &pointer_alignment, &char_ctype },
 	{ &ptr_ctype,	    SYM_PTR,	  0,			    &bits_in_pointer,        &pointer_alignment, &void_ctype },
-	{ &null_ctype,	    SYM_PTR,	  0,			    &bits_in_pointer,        &pointer_alignment, &void_ctype },
+	{ &null_ctype,	    SYM_PTR,	  0,			    &bits_in_pointer,        &pointer_alignment, &ptr_ctype  },
 	{ &label_ctype,	    SYM_PTR,	  0,			    &bits_in_pointer,        &pointer_alignment, &void_ctype },
 	{ &lazy_ptr_ctype,  SYM_PTR,	  0,			    &bits_in_pointer,        &pointer_alignment, &void_ctype },
 	{ NULL, }

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Null ctype should have ptr_ctype as its base type.
Date: Sun, 28 Dec 2008 20:52:59 +0000
Message-ID: <70318cbf0812281252m70c70493h507295316e6621df () mail ! gmail ! com>
--------------------
------=_Part_120082_23531105.1230497579625
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Sun, Dec 28, 2008 at 7:14 AM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:

> So, we are getting a sizeof(NULL), or a sizeof((void *)0). It triggers here

That is my fault. My test for void type should have been more careful.

> because we are getting a null_ctype, and it's base_type points to
> void_ctype. I'm not sure if this patch is correct, but it seems to do
> the trick, all void warnings are gone. Christopher?

No, that is not the right way to fix it. Now you declare NULL as pointer
to a pointer type "(void**) 0".

Thanks for finding it out. Does my patch work for you?

Chris

------=_Part_120082_23531105.1230497579625
Content-Type: application/octet-stream;
 name=0001-Correct-testing-for-void-type.patch
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fpa6b71c0
Content-Disposition: attachment;
 filename=0001-Correct-testing-for-void-type.patch

RnJvbSBhN2I1ZGU5MGVhM2VhODQ4NTg4MmJhMzQ4YjA0NTI3OTcwOWJkNmQ5IE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBTdW4sIDI4IERlYyAyMDA4IDEyOjMxOjUwIC0wODAwClN1YmplY3Q6IFtQQVRDSF0gQ29y
cmVjdCB0ZXN0aW5nIGZvciB2b2lkIHR5cGUuCgpUaGUgbGFzdCBzaXplb2Yodm9pZCkgd2Fybmlu
ZyBjb21taXQgdG9vIGVhZ2VyIHRvCmRlY2xhcmUgdHlwZSBpcyB2b2lkLiBJdCBlbmQgdXAgc2l6
ZW9mKE5VTEwpID09IDEKYXMgd2VsbC4KClNpZ25lZC1vZmYtYnk6IENocmlzdG9waGVyIExpIDxz
cGFyc2VAY2hyaXNsaS5vcmc+Ci0tLQogZXZhbHVhdGUuYyB8ICAgMTEgKysrKysrKysrLS0KIDEg
ZmlsZXMgY2hhbmdlZCwgOSBpbnNlcnRpb25zKCspLCAyIGRlbGV0aW9ucygtKQoKZGlmZiAtLWdp
dCBhL2V2YWx1YXRlLmMgYi9ldmFsdWF0ZS5jCmluZGV4IGQ5OWQzNGYuLjJmZmY0NmUgMTAwNjQ0
Ci0tLSBhL2V2YWx1YXRlLmMKKysrIGIvZXZhbHVhdGUuYwpAQCAtMzM3LDYgKzMzNywxMyBAQCBz
dGF0aWMgaW5saW5lIGludCBpc19ieXRlX3R5cGUoc3RydWN0IHN5bWJvbCAqdHlwZSkKIAlyZXR1
cm4gdHlwZS0+Yml0X3NpemUgPT0gYml0c19pbl9jaGFyICYmIHR5cGUtPnR5cGUgIT0gU1lNX0JJ
VEZJRUxEOwogfQogCitzdGF0aWMgaW5saW5lIGludCBpc192b2lkX3R5cGUoc3RydWN0IHN5bWJv
bCAqdHlwZSkKK3sKKwlpZiAodHlwZS0+dHlwZSA9PSBTWU1fTk9ERSkKKwkJdHlwZSA9IHR5cGUt
PmN0eXBlLmJhc2VfdHlwZTsKKwlyZXR1cm4gdHlwZSA9PSAmdm9pZF9jdHlwZTsKK30KKwogZW51
bSB7CiAJVFlQRV9OVU0gPSAxLAogCVRZUEVfQklURklFTEQgPSAyLApAQCAtNTg0LDcgKzU5MSw3
IEBAIHN0YXRpYyBzdHJ1Y3Qgc3ltYm9sICpldmFsdWF0ZV9wdHJfYWRkKHN0cnVjdCBleHByZXNz
aW9uICpleHByLCBzdHJ1Y3Qgc3ltYm9sICppCiAJfQogCiAJLyogR2V0IHRoZSBzaXplIG9mIHdo
YXRldmVyIHRoZSBwb2ludGVyIHBvaW50cyB0byAqLwotCW11bHRpcGx5ID0gKGJhc2UgPT0gJnZv
aWRfY3R5cGUpID8gMSA6IGJpdHNfdG9fYnl0ZXMoYmFzZS0+Yml0X3NpemUpOworCW11bHRpcGx5
ID0gaXNfdm9pZF90eXBlKGJhc2UpID8gMSA6IGJpdHNfdG9fYnl0ZXMoYmFzZS0+Yml0X3NpemUp
OwogCiAJaWYgKGN0eXBlID09ICZudWxsX2N0eXBlKQogCQljdHlwZSA9ICZwdHJfY3R5cGU7CkBA
IC0yMDUwLDcgKzIwNTcsNyBAQCBzdGF0aWMgc3RydWN0IHN5bWJvbCAqZXZhbHVhdGVfc2l6ZW9m
KHN0cnVjdCBleHByZXNzaW9uICpleHByKQogCiAJc2l6ZSA9IHR5cGUtPmJpdF9zaXplOwogCi0J
aWYgKHR5cGUtPmN0eXBlLmJhc2VfdHlwZSA9PSAmdm9pZF9jdHlwZSkgeworCWlmIChzaXplIDwg
MCAmJiBpc192b2lkX3R5cGUodHlwZSkpIHsKIAkJd2FybmluZyhleHByLT5wb3MsICJleHByZXNz
aW9uIHVzaW5nIHNpemVvZih2b2lkKSIpOwogCQlzaXplID0gYml0c19pbl9jaGFyOwogCX0KLS0g
CjEuNi4wLjYKCg==
------=_Part_120082_23531105.1230497579625--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Null ctype should have ptr_ctype as its base type.
Date: Sun, 28 Dec 2008 21:38:10 +0000
Message-ID: <f19298770812281338t698d10e6xf60b5d787896f04f () mail ! gmail ! com>
--------------------
On Sun, Dec 28, 2008 at 23:52, Christopher Li <sparse@chrisli.org> wrote:
> On Sun, Dec 28, 2008 at 7:14 AM, Alexey Zaytsev
> <alexey.zaytsev@gmail.com> wrote:
>
>> So, we are getting a sizeof(NULL), or a sizeof((void *)0). It triggers here
>
> That is my fault. My test for void type should have been more careful.
>
>> because we are getting a null_ctype, and it's base_type points to
>> void_ctype. I'm not sure if this patch is correct, but it seems to do
>> the trick, all void warnings are gone. Christopher?
>
> No, that is not the right way to fix it. Now you declare NULL as pointer
> to a pointer type "(void**) 0".
>
> Thanks for finding it out. Does my patch work for you?

Yes, it works, thank you.
There is one problem left:

11091a11093,11130
> drivers/net/wireless/wavelan_cs.c:362:16: error: subtraction of different types can't work (different base types)
> drivers/net/wireless/wavelan_cs.c:379:17: error: subtraction of different types can't work (different base types)
> drivers/net/wireless/wavelan_cs.c:385:21: error: subtraction of different types can't work (different base types)
[...]

It looks like:

... mmroff(0, mmr_fee_status) ..

#define mmroff(p,f)     (unsigned short)((void *)(&((mmr_t *)((void
*)0 + (p)))->f) - (void *)0)

mmr_fee_status being an element in struct mmr.
Here we end up substracting null from non-null void * pointer.
Looks quite pointless, but I think sparse should be able to
cope with this?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Null ctype should have ptr_ctype as its base type.
Date: Mon, 29 Dec 2008 07:32:24 +0000
Message-ID: <70318cbf0812282332m1188f0bbm1097ced77583dc42 () mail ! gmail ! com>
--------------------
On Sun, Dec 28, 2008 at 1:38 PM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:
> 11091a11093,11130
>> drivers/net/wireless/wavelan_cs.c:362:16: error: subtraction of different types can't work (different base types)
>> drivers/net/wireless/wavelan_cs.c:379:17: error: subtraction of different types can't work (different base types)
>> drivers/net/wireless/wavelan_cs.c:385:21: error: subtraction of different types can't work (different base types)
> [...]
>
> It looks like:
>
> ... mmroff(0, mmr_fee_status) ..
>
> #define mmroff(p,f)     (unsigned short)((void *)(&((mmr_t *)((void
> *)0 + (p)))->f) - (void *)0)

That is one piece of ugly code.

>
> mmr_fee_status being an element in struct mmr.
> Here we end up substracting null from non-null void * pointer.
> Looks quite pointless, but I think sparse should be able to
> cope with this?

Do you have minimal code to duplicate this bug?

I try with the following testing code without much luck.

Chris

typedef struct mmr_t	mmr_t;

struct mmr_t {
	int a;
	int mmr_fee_status;
};

#define mmroff(p,f)     (unsigned short)((void *)(&((mmr_t *)((void
*)0 + (p)))->f) - (void *)0)
int b;

int foo(void)
{
	return mmroff(0,mmr_fee_status);
}
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] OpenBSD support ===

From: "Blue Swirl" <blauwirbel () gmail ! com>
To: linux-sparse
Subject: [PATCH] OpenBSD support
Date: Sun, 02 Nov 2008 08:33:23 +0000
Message-ID: <f43fc5580811020133t66a2a4e6pf63659e8ce03e744 () mail ! gmail ! com>
--------------------
------=_Part_60639_31321404.1225614803911
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi,

This patch adds OpenBSD support to sparse. I'm not subscribed, please CC.

Signed-off-by: Blue Swirl <blauwirbel@gmail.com>

------=_Part_60639_31321404.1225614803911
Content-Type: plain/text; name=sparse-openbsd.diff
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fn1fd1dd
Content-Disposition: attachment; filename=sparse-openbsd.diff

ZGlmZiAtLWdpdCBhL2NnY2MgYi9jZ2NjCmluZGV4IDg5YWRiZWQuLjJmMDllMGQgMTAwNzU1Ci0t
LSBhL2NnY2MKKysrIGIvY2djYwpAQCAtMjIxLDYgKzIyMSw5IEBAIHN1YiBhZGRfc3BlY3Mgewog
ICAgIH0gZWxzaWYgKCRzcGVjIGVxICdsaW51eCcpIHsKIAlyZXR1cm4gJmFkZF9zcGVjcyAoJ3Vu
aXgnKSAuCiAJICAgICcgLURfX2xpbnV4X189MSAtRF9fbGludXg9MSAtRGxpbnV4PWxpbnV4JzsK
KyAgICB9IGVsc2lmICgkc3BlYyBlcSAnb3BlbmJzZCcpIHsKKwlyZXR1cm4gJmFkZF9zcGVjcyAo
J3VuaXgnKSAuCisJICAgICcgLURfX09wZW5CU0RfXz0xJzsKICAgICB9IGVsc2lmICgkc3BlYyBl
cSAndW5peCcpIHsKIAlyZXR1cm4gJyAtRHVuaXg9MSAtRF9fdW5peD0xIC1EX191bml4X189MSc7
CiAgICAgfSBlbHNpZiAoICRzcGVjID1+IC9eY3lnd2luLykgewpkaWZmIC0tZ2l0IGEvY29tcGF0
LWJzZC5jIGIvY29tcGF0LWJzZC5jCm5ldyBmaWxlIG1vZGUgMTAwNjQ0CmluZGV4IDAwMDAwMDAu
LmU5YTAyZGEKLS0tIC9kZXYvbnVsbAorKysgYi9jb21wYXQtYnNkLmMKQEAgLTAsMCArMSwyMCBA
QAorLyoJCisgKiBCU0QgQ29tcGF0aWJpbGl0eSBmdW5jdGlvbnMJCisgKgkKKyAqCQorICogIExp
Y2Vuc2VkIHVuZGVyIHRoZSBPcGVuIFNvZnR3YXJlIExpY2Vuc2UgdmVyc2lvbiAxLjEJCisgKi8J
CisKKyNpbmNsdWRlIDxzeXMvdHlwZXMuaD4KKyNpbmNsdWRlIDxzdHJpbmcuaD4JCisKKyNpbmNs
dWRlICJsaWIuaCIKKyNpbmNsdWRlICJhbGxvY2F0ZS5oIgorI2luY2x1ZGUgInRva2VuLmgiCisK
KyNpbmNsdWRlICJjb21wYXQvbW1hcC1ibG9iLmMiCisKK2xvbmcgZG91YmxlIHN0cmluZ190b19s
ZChjb25zdCBjaGFyICpucHRyLCBjaGFyICoqZW5kcHRyKSAJCit7CQorCXJldHVybiBzdHJ0b2Qo
bnB0ciwgZW5kcHRyKTsJCit9Cg==
------=_Part_60639_31321404.1225614803911--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] OpenBSD support
Date: Tue, 04 Nov 2008 20:08:12 +0000
Message-ID: <70318cbf0811041208h2350d500pe8e464271d7fa76b () mail ! gmail ! com>
--------------------
Acked-by: Christopher Li <sparse@chrisli.org>

On Sun, Nov 2, 2008 at 12:33 AM, Blue Swirl <blauwirbel@gmail.com> wrote:
> Hi,
>
> This patch adds OpenBSD support to sparse. I'm not subscribed, please CC.
>
> Signed-off-by: Blue Swirl <blauwirbel@gmail.com>
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Set *tree to NULL on error ===

From: Vegard Nossum <vegard.nossum () gmail ! com>
To: linux-sparse
Subject: [PATCH] Set *tree to NULL on error
Date: Sun, 25 May 2008 08:35:00 +0000
Message-ID: <20080525083500.GA4158 () damson ! getinternet ! no>
--------------------
From: Vegard Nossum <vegardno@ifi.uio.no>
Date: Sun, 25 May 2008 10:29:19 +0200
Subject: [PATCH] Set *tree to NULL on error

On "Syntax error in unary expression", the output parameter "tree" would be left
uninitialized and subsequently used in unary_expression(), leading to segfault.

Caught by valgrind and fixed by me ;-)

Signed-off-by: Vegard Nossum <vegardno@ifi.uio.no>
---
 expression.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/expression.c b/expression.c
index 289927a..f634b07 100644
--- a/expression.c
+++ b/expression.c
@@ -654,6 +654,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 			next = cast_expression(token->next, &unop);
 			if (!unop) {
 				sparse_error(token->pos, "Syntax error in unary expression");
+				*tree = NULL;
 				return next;
 			}
 			unary = alloc_expression(token->pos, EXPR_PREOP);
@@ -671,6 +672,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 			next = cast_expression(token->next, &unop);
 			if (!unop) {
 				sparse_error(token->pos, "Syntax error in unary expression");
+				*tree = NULL;
 				return next;
 			}
 			unary = alloc_expression(token->pos, EXPR_PREOP);
-- 
1.5.4.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Sparc64 (Sparc V9, LP64) support ===

From: "Blue Swirl" <blauwirbel () gmail ! com>
To: linux-sparse
Subject: [PATCH] Sparc64 (Sparc V9, LP64) support
Date: Sun, 02 Nov 2008 08:37:12 +0000
Message-ID: <f43fc5580811020137n6d0be9f4i98a69c48f917b40d () mail ! gmail ! com>
--------------------
------=_Part_60652_2012365.1225615032457
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi,

This patch adds support for Sparc64 (Sparc V9, LP64). I'm not
subscribed, please CC.

Signed-off-by: Blue Swirl <blauwirbel@gmail.com>

------=_Part_60652_2012365.1225615032457
Content-Type: plain/text; name=sparse-sparc64.diff
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fn1fi7i9
Content-Disposition: attachment; filename=sparse-sparc64.diff

ZGlmZiAtLWdpdCBhL2NnY2MgYi9jZ2NjCmluZGV4IDJmMDllMGQuLjVkMTI5YjkgMTAwNzU1Ci0t
LSBhL2NnY2MKKysrIGIvY2djYwpAQCAtMjQ2LDYgKzI0NiwxMSBAQCBzdWIgYWRkX3NwZWNzIHsK
IAkJJmludGVnZXJfdHlwZXMgKDgsIDE2LCAzMiwgJG02NCA/IDY0IDogMzIsIDY0KSAuCiAJCSZm
bG9hdF90eXBlcyAoMSwgMSwgMzMsIFsyNCw4XSwgWzUzLDExXSwgWzExMywxNV0pIC4KIAkJJmRl
ZmluZV9zaXplX3QgKCRtNjQgPyAibG9uZyB1bnNpZ25lZCBpbnQiIDogInVuc2lnbmVkIGludCIp
KTsKKyAgICB9IGVsc2lmICgkc3BlYyBlcSAnc3BhcmM2NCcpIHsKKwlyZXR1cm4gKCcgLURzcGFy
Yz0xIC1EX19zcGFyYz0xIC1EX19zcGFyY19fPTEgLURfX3NwYXJjdjlfXz0xIC1EX19zcGFyYzY0
X189MSAtRF9fYXJjaDY0X189MSAtRF9fTFA2NF9fPTEnIC4KKwkJJmludGVnZXJfdHlwZXMgKDgs
IDE2LCAzMiwgNjQsIDY0KSAuCisJCSZmbG9hdF90eXBlcyAoMSwgMSwgMzMsIFsyNCw4XSwgWzUz
LDExXSwgWzExMywxNV0pIC4KKwkJJmRlZmluZV9zaXplX3QgKCJsb25nIHVuc2lnbmVkIGludCIp
KTsKICAgICB9IGVsc2lmICgkc3BlYyBlcSAneDg2XzY0JykgewogCXJldHVybiAoJyAtRHg4Nl82
ND0xIC1EX194ODZfNjQ9MSAtRF9feDg2XzY0X189MScgLgogCQkmaW50ZWdlcl90eXBlcyAoOCwg
MTYsIDMyLCAkbTMyID8gMzIgOiA2NCwgNjQpIC4KQEAgLTI3MSw2ICsyNzYsOCBAQCBzdWIgYWRk
X3NwZWNzIHsKIAkgICAgcmV0dXJuICZhZGRfc3BlY3MgKCd4ODZfNjQnKTsKIAl9IGVsc2lmICgk
YXJjaCA9fiAvXihwcGMpJC9pKSB7CiAJICAgIHJldHVybiAmYWRkX3NwZWNzICgncHBjJyk7CisJ
fSBlbHNpZiAoJGFyY2ggPX4gL14oc3BhcmM2NCkkL2kpIHsKKwkgICAgcmV0dXJuICZhZGRfc3Bl
Y3MgKCdzcGFyYzY0Jyk7CiAJfQogICAgIH0gZWxzZSB7CiAJZGllICIkMDogaW52YWxpZCBzcGVj
czogJHNwZWNcbiI7Cg==
------=_Part_60652_2012365.1225615032457--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] The require_context attribute ===

From: Philipp Reisner <philipp.reisner () linbit ! com>
To: linux-sparse
Subject: [PATCH] The require_context attribute
Date: Mon, 31 Mar 2008 12:00:32 +0000
Message-ID: <200803311400.32860.philipp.reisner () linbit ! com>
--------------------
Hi,

To make sparse more usefull for me, I extended sparse with a require_context 
attribute. With that sparse can warn you if one accesses a variable outside of 
the corresponding locking context.

A small example to illustrate the idea:

static int to_protect __protected_by(the_lock);

static int helper(void) __must_hold(the_lock)
{
	to_protect = 1;
}

static int valid1(void)
{
	lock(the_lock);
	helper();
	unlock(the_lock);
}

static int invalid1(void)
{
	helper();
}

static int invalid2(void)
{
	to_protect = 1;
}

Sparse will warn you about the out of context access in invalid2().

I realize that automatic propagation of the lock context from caller to
callee seems to be desirable. On the other hand as it is now the
programmer is forced to annotate each function that requires a lock
with the appropriate __must_hold() macro. -- Which is high value
documentations, and helps reviewers to understand the code quicker.

So far the burden to maintain these __must_hold() annotations was feasible 
on the kernel code we develop and maintain here.

A complete example is included in the patch: validation/context_requirement.c

-Phil

commit 17978b26f051dcdbd4de498cd464a3acbc272c3c
Author: Philipp Reisner <philipp.reisner@linbit.com>
Date:   Mon Mar 31 13:21:02 2008 +0200

    Implemented the require_context attribute
    
    The require_context attribute allowes you to annotate variables,
    struct members or union members and functions with context requirements.
    
    This patch does not change the single pass nature of sparse, i.e.
    sparse does not find out on its own that a function that accesses
    an annotated variable is only called with the appropriate lock
    held. One has to annotate the functions that get called with
    a locks held as well.
    
    Signed-off-by: Philipp Reisner <philipp.reisner@linbit.com>

diff --git a/allocate.c b/allocate.c
index 5cc52a9..198297b 100644
--- a/allocate.c
+++ b/allocate.c
@@ -114,6 +114,7 @@ void show_allocations(struct allocator_struct *x)
 ALLOCATOR(ident, "identifiers");
 ALLOCATOR(token, "tokens");
 ALLOCATOR(context, "contexts");
+ALLOCATOR(context_requirement, "context requirements");
 ALLOCATOR(symbol, "symbols");
 ALLOCATOR(expression, "expressions");
 ALLOCATOR(statement, "statements");
diff --git a/allocate.h b/allocate.h
index 9f1dc8c..8fa3efd 100644
--- a/allocate.h
+++ b/allocate.h
@@ -65,6 +65,7 @@ extern void show_allocations(struct allocator_struct *);
 DECLARE_ALLOCATOR(ident);
 DECLARE_ALLOCATOR(token);
 DECLARE_ALLOCATOR(context);
+DECLARE_ALLOCATOR(context_requirement);
 DECLARE_ALLOCATOR(symbol);
 DECLARE_ALLOCATOR(expression);
 DECLARE_ALLOCATOR(statement);
diff --git a/linearize.c b/linearize.c
index 8a68f05..6d401df 100644
--- a/linearize.c
+++ b/linearize.c
@@ -239,6 +239,7 @@ static const char *opcodes[] = {
 
 	/* Sparse tagging (line numbers, context, whatever) */
 	[OP_CONTEXT] = "context",
+	[OP_CONTEXT_REQ] = "context req",
 	[OP_RANGE] = "range-check",
 
 	[OP_COPY] = "copy",
@@ -441,6 +442,9 @@ const char *show_instruction(struct instruction *insn)
 	case OP_CONTEXT:
 		buf += sprintf(buf, "%s%d", insn->check ? "check: " : "", insn->increment);
 		break;
+	case OP_CONTEXT_REQ:
+		buf += sprintf(buf, "%d to %d, type %d", insn->ctx_req->min, insn->ctx_req->max, insn->access_type);
+		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
 		break;
@@ -838,6 +842,7 @@ struct access_data {
 	unsigned int offset, alignment;	// byte offset
 	unsigned int bit_size, bit_offset; // which bits
 	struct position pos;
+	struct ctx_req_list *ctx_reqs;    // required contexts
 };
 
 static void finish_address_gen(struct entrypoint *ep, struct access_data *ad)
@@ -883,9 +888,14 @@ static int linearize_address_gen(struct entrypoint *ep,
 	struct access_data *ad)
 {
 	struct symbol *ctype = expr->ctype;
+	struct ctype *ctc = NULL;
 
 	if (!ctype)
 		return 0;
+
+	ctc = &ctype->ctype;
+	if (ctc)
+		ad->ctx_reqs = ctc->ctx_reqs;
 	ad->pos = expr->pos;
 	ad->result_type = ctype;
 	ad->source_type = base_type(ctype);
@@ -937,6 +947,7 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 		struct access_data *ad)
 {
 	pseudo_t store = value;
+	struct context_requirement *ctx_req;
 
 	if (type_size(ad->source_type) != type_size(ad->result_type)) {
 		pseudo_t orig = add_load(ep, ad);
@@ -950,6 +961,19 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 		orig = add_binary_op(ep, ad->source_type, OP_AND, orig, value_pseudo(~mask));
 		store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
 	}
+	if (ad->ctx_reqs) {
+		struct instruction *insn;
+		FOR_EACH_PTR(ad->ctx_reqs, ctx_req) {
+			if (ctx_req->access_type == WRITE ||
+			    ctx_req->access_type == RDWR) {
+				insn = alloc_instruction(OP_CONTEXT_REQ, 0);
+				insn->ctx_req = ctx_req;
+				insn->access_type = WRITE;
+				add_one_insn(ep, insn);
+			}
+		} END_FOR_EACH_PTR(ctx_req);
+
+	}
 	add_store(ep, ad, store);
 	return value;
 }
@@ -988,14 +1012,30 @@ static pseudo_t add_symbol_address(struct entrypoint *ep, struct symbol *sym)
 
 static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad)
 {
-	pseudo_t new = add_load(ep, ad);
+	pseudo_t new;
+	struct context_requirement *ctx_req;
+
+	if (ad->ctx_reqs) {
+		struct instruction *insn;
+		FOR_EACH_PTR(ad->ctx_reqs, ctx_req) {
+			if (ctx_req->access_type == READ ||
+			    ctx_req->access_type == RDWR) {
+				insn = alloc_instruction(OP_CONTEXT_REQ, 0);
+				insn->ctx_req = ctx_req;
+				insn->access_type = READ;
+				add_one_insn(ep, insn);
+			}
+		} END_FOR_EACH_PTR(ctx_req);
+
+	}
+	new = add_load(ep, ad);
 
 	if (ad->bit_offset) {
 		pseudo_t shift = value_pseudo(ad->bit_offset);
 		pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
 		new = newval;
 	}
-		
+
 	return new;
 }
 
@@ -1194,6 +1234,7 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 	pseudo_t retval, call;
 	struct ctype *ctype = NULL;
 	struct context *context;
+	struct context_requirement *ctx_req;
 
 	if (!expr->ctype) {
 		warning(expr->pos, "call with no type!");
@@ -1210,6 +1251,17 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 	if (fn->ctype)
 		ctype = &fn->ctype->ctype;
 
+	if (ctype) {
+		FOR_EACH_PTR(ctype->ctx_reqs, ctx_req) {
+			struct instruction *cinsn;
+
+			cinsn = alloc_instruction(OP_CONTEXT_REQ, 0);
+			cinsn->ctx_req = ctx_req;
+			cinsn->access_type = CALL;
+			add_one_insn(ep, cinsn);
+		} END_FOR_EACH_PTR(ctx_req);
+	}
+
 	if (fn->type == EXPR_PREOP) {
 		if (fn->unop->type == EXPR_SYMBOL) {
 			struct symbol *sym = fn->unop->symbol;
@@ -1235,6 +1287,7 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 			int out = context->out;
 			int check = 0;
 			int context_diff;
+
 			if (in < 0) {
 				check = 1;
 				in = 0;
diff --git a/linearize.h b/linearize.h
index 7b2961b..3a36338 100644
--- a/linearize.h
+++ b/linearize.h
@@ -124,6 +124,11 @@ struct instruction {
 			const char *string;
 			struct asm_rules *asm_rules;
 		};
+		struct /* context_req */ {
+			int access_type;
+			struct context_requirement* ctx_req;
+		};
+
 	};
 };
 
@@ -212,6 +217,7 @@ enum opcode {
 
 	/* Sparse tagging (line numbers, context, whatever) */
 	OP_CONTEXT,
+	OP_CONTEXT_REQ,
 	OP_RANGE,
 
 	/* Needed to translate SSA back to normal form */
diff --git a/parse.c b/parse.c
index a41939d..467dc49 100644
--- a/parse.c
+++ b/parse.c
@@ -66,6 +66,7 @@ static struct token *attribute_address_space(struct token *token, struct symbol
 static struct token *attribute_aligned(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_mode(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype);
+static struct token *attribute_require_context(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
 
@@ -184,6 +185,10 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
+static struct symbol_op require_context_op = {
+	.attribute = attribute_require_context,
+};
+
 static struct symbol_op transparent_union_op = {
 	.attribute = attribute_transparent_union,
 };
@@ -265,6 +270,7 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
+	{ "require_context",	NS_KEYWORD,	.op = &require_context_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
@@ -907,6 +913,72 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 	return token;
 }
 
+static int token_to_accesstype(struct token *token)
+{
+	static const char *at_text[] = {
+		[READ]  = "\"read\"",
+		[WRITE] = "\"write\"",
+		[RDWR]  = "\"rdwr\"",
+		[CALL]  = "\"call\""
+	};
+	const char *ats;
+	int i;
+
+	if (token_type(token) != TOKEN_STRING)
+		goto err;
+
+	ats = show_token(token);
+	for (i = 0; i < sizeof at_text/sizeof at_text[0]; i++) {
+		if (!strcmp(ats,at_text[i]))
+			return i;
+	}
+
+err:
+	sparse_error(token->pos, "Expected \"read\", \"write\", \"rdwr\" or \"call\""
+		     " as 4th argument of require_context");
+
+	return RDWR;
+}
+
+static struct token *attribute_require_context(struct token *token, struct symbol *attr, struct ctype *ctype)
+{
+	struct context_requirement *ctx_req = alloc_context_requirement();
+	struct expression *args[3];
+	int argc = 0;
+
+	token = expect(token, '(', "after require_context attribute");
+	while (!match_op(token, ')')) {
+		struct expression *expr = NULL;
+		if (argc < 3) {
+			token = conditional_expression(token, &expr);
+			if (!expr)
+				break;
+		} else {
+			ctx_req->access_type = token_to_accesstype(token);
+			token = token->next;
+			argc++;
+		}
+
+		if (argc < 3)
+			args[argc++] = expr;
+		if (!match_op(token, ','))
+			break;
+		token = token->next;
+	}
+
+	if (argc == 4) {
+		ctx_req->context = args[0];
+		ctx_req->min = get_expression_value(args[1]);
+		ctx_req->max = get_expression_value(args[2]);
+		add_ptr_list(&ctype->ctx_reqs, ctx_req);
+	} else
+		sparse_error(token->pos, "expected context name, min, max and type values");
+
+	token = expect(token, ')', "after context attribute");
+	return token;
+}
+
+
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	if (Wtransparent_union)
@@ -1039,6 +1111,8 @@ static void apply_ctype(struct position pos, struct ctype *thistype, struct ctyp
 	/* Context */
 	concat_ptr_list((struct ptr_list *)thistype->contexts,
 	                (struct ptr_list **)&ctype->contexts);
+	concat_ptr_list((struct ptr_list *)thistype->ctx_reqs,
+	                (struct ptr_list **)&ctype->ctx_reqs);
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
@@ -1246,6 +1320,8 @@ static struct token *pointer(struct token *token, struct ctype *ctype)
 		ptr->ctype.as = ctype->as;
 		concat_ptr_list((struct ptr_list *)ctype->contexts,
 				(struct ptr_list **)&ptr->ctype.contexts);
+		concat_ptr_list((struct ptr_list *)ctype->ctx_reqs,
+				(struct ptr_list **)&ptr->ctype.ctx_reqs);
 		ptr->ctype.base_type = base_type;
 
 		base_type = ptr;
@@ -1253,6 +1329,7 @@ static struct token *pointer(struct token *token, struct ctype *ctype)
 		ctype->base_type = base_type;
 		ctype->as = 0;
 		free_ptr_list(&ctype->contexts);
+		free_ptr_list(&ctype->ctx_reqs);
 
 		token = declaration_specifiers(token->next, ctype, 1);
 		modifiers = ctype->modifiers;
diff --git a/sparse.c b/sparse.c
index 4026ba7..5cb4f11 100644
--- a/sparse.c
+++ b/sparse.c
@@ -24,6 +24,20 @@
 #include "expression.h"
 #include "linearize.h"
 
+static void out_of_context_access(struct basic_block *bb, struct instruction *insn, const char *why)
+{
+	static const char *at_text[] = {
+		[READ] =  "read access",
+		[WRITE] = "write access",
+		[CALL]  = "call"
+	};
+
+	if (Wcontext) {
+		warning(insn->pos, "out of context %s in '%s' - context too %s",
+			at_text[insn->access_type], show_ident(bb->ep->name->ident), why);
+	}
+}
+
 static int context_increase(struct basic_block *bb, int entry)
 {
 	int sum = 0;
@@ -31,20 +45,28 @@ static int context_increase(struct basic_block *bb, int entry)
 
 	FOR_EACH_PTR(bb->insns, insn) {
 		int val;
-		if (insn->opcode != OP_CONTEXT)
-			continue;
-		val = insn->increment;
-		if (insn->check) {
-			int current = sum + entry;
-			if (!val) {
-				if (!current)
+		switch (insn->opcode) {
+		case OP_CONTEXT:
+			val = insn->increment;
+			if (insn->check) {
+				int current = sum + entry;
+				if (!val) {
+					if (!current)
+						continue;
+				} else if (current >= val)
 					continue;
-			} else if (current >= val)
+				warning(insn->pos, "context check failure");
 				continue;
-			warning(insn->pos, "context check failure");
-			continue;
+			}
+			sum += val;
+			break;
+		case OP_CONTEXT_REQ:
+			if (sum+entry < insn->ctx_req->min)
+				out_of_context_access(bb, insn, "small");
+			if (sum+entry > insn->ctx_req->max)
+				out_of_context_access(bb, insn, "high");
+			break;
 		}
-		sum += val;
 	} END_FOR_EACH_PTR(insn);
 	return sum;
 }
diff --git a/symbol.c b/symbol.c
index 7539817..4564843 100644
--- a/symbol.c
+++ b/symbol.c
@@ -57,6 +57,11 @@ struct context *alloc_context(void)
 	return __alloc_context(0);
 }
 
+struct context_requirement *alloc_context_requirement(void)
+{
+	return __alloc_context_requirement(0);
+}
+
 struct symbol *alloc_symbol(struct position pos, int type)
 {
 	struct symbol *sym = __alloc_symbol(0);
@@ -201,6 +206,8 @@ static struct symbol *examine_base_type(struct symbol *sym)
 	sym->ctype.modifiers |= base_type->ctype.modifiers & MOD_PTRINHERIT;
 	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
 			(struct ptr_list **)&sym->ctype.contexts);
+	concat_ptr_list((struct ptr_list *)base_type->ctype.ctx_reqs,
+			(struct ptr_list **)&sym->ctype.ctx_reqs);
 	if (base_type->type == SYM_NODE) {
 		base_type = base_type->ctype.base_type;
 		sym->ctype.base_type = base_type;
@@ -257,6 +264,8 @@ void merge_type(struct symbol *sym, struct symbol *base_type)
 	sym->ctype.modifiers |= (base_type->ctype.modifiers & ~MOD_STORAGE);
 	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
 	                (struct ptr_list **)&sym->ctype.contexts);
+	concat_ptr_list((struct ptr_list *)base_type->ctype.ctx_reqs,
+			(struct ptr_list **)&sym->ctype.ctx_reqs);
 	sym->ctype.base_type = base_type->ctype.base_type;
 	if (sym->ctype.base_type->type == SYM_NODE)
 		merge_type(sym, sym->ctype.base_type);
diff --git a/symbol.h b/symbol.h
index 4362f9a..cdb2452 100644
--- a/symbol.h
+++ b/symbol.h
@@ -74,14 +74,23 @@ struct context {
 	unsigned int in, out;
 };
 
+struct context_requirement {
+	struct expression *context;
+	unsigned int min, max;
+	enum { READ, WRITE, RDWR, CALL } access_type;
+};
+
 extern struct context *alloc_context(void);
+extern struct context_requirement *alloc_context_requirement(void);
 
 DECLARE_PTR_LIST(context_list, struct context);
+DECLARE_PTR_LIST(ctx_req_list, struct context_requirement);
 
 struct ctype {
 	unsigned long modifiers;
 	unsigned long alignment;
 	struct context_list *contexts;
+	struct ctx_req_list *ctx_reqs;
 	unsigned int as;
 	struct symbol *base_type;
 };
diff --git a/validation/context_requirement.c b/validation/context_requirement.c
new file mode 100644
index 0000000..24fe598
--- /dev/null
+++ b/validation/context_requirement.c
@@ -0,0 +1,185 @@
+#ifdef __CHECKER__
+# define __acquires(x)	__attribute__((context(x,0,1)))
+# define __releases(x)	__attribute__((context(x,1,0)))
+# define __acquire(x)	__context__(x,1)
+# define __release(x)	__context__(x,-1)
+# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
+# define __protected_by(x)       __attribute__((require_context(x,1,1,"rdwr")))
+# define __protected_read_by(x)  __attribute__((require_context(x,1,1,"read")))
+# define __protected_write_by(x) __attribute__((require_context(x,1,1,"write")))
+# define __must_hold(x)       __attribute__((context(x,1,1), require_context(x,1,1,"call")))
+#else
+# define __acquires(x)
+# define __releases(x)
+# define __acquire(x) (void)0
+# define __release(x) (void)0
+# define __cond_lock(x,c) (c)
+# define __protected_by(x)
+# define __protected_read_by(x)
+# define __protected_write_by(x)
+# define __must_hold(x)
+#endif
+
+
+#include <stdio.h>
+#include <stdlib.h>
+
+static int to_protect __protected_by(local);
+
+static int local_cnt=0;
+
+static void inc_local(void) __acquires(local)
+{
+	__acquire(local);
+	local_cnt++;
+}
+
+
+#define try_inc_local() __cond_lock(local, _try_inc_local())
+static int _try_inc_local(void)
+{
+	if (random() > RAND_MAX/2) {
+		local_cnt++;
+		return 1;
+	}
+	return 0;
+}
+
+#define dec_local(void) do { __release(local); _dec_local(); } while(0)
+static void _dec_local(void)
+{
+	local_cnt--;
+}
+
+static int valid1(void)
+{
+	inc_local();
+	to_protect = 1;
+	dec_local();
+}
+
+static int valid2(void)
+{
+	inc_local();
+	inc_local();
+	dec_local();
+	dec_local();
+}
+
+static int valid3(void)
+{
+	if (try_inc_local()) {
+		dec_local();
+	}
+}
+
+static int valid4(void)
+{
+	if ((random() > RAND_MAX/2) && try_inc_local()) {
+		dec_local();
+	}
+}
+
+static int helper(void) __must_hold(local)
+{
+	to_protect = 1;
+}
+
+static int valid5(void)
+{
+	inc_local();
+	helper();
+	dec_local();
+}
+
+static int invalid0(void) __releases(local)
+{
+	if (random() > RAND_MAX/2)
+		dec_local();
+}
+
+static int invalid1(void)
+{
+	inc_local();
+}
+
+static int invalid2(void)
+{
+	dec_local();
+}
+
+static int invalid3(void)
+{
+	if (try_inc_local()) {
+	}
+	dec_local();
+}
+
+static int invalid4(void)
+{
+	while (random() > RAND_MAX/2)
+		inc_local();
+
+	dec_local();
+}
+
+static int invalid5(void)
+{
+	try_inc_local();
+	dec_local();
+}
+
+static int invalid6(void)
+{
+	to_protect = 1;
+	inc_local();
+	dec_local();
+}
+
+static int invalid7(void)
+{
+	inc_local();
+	dec_local();
+	to_protect = 1;
+}
+
+static int invalid8(void)
+{
+	inc_local();
+	inc_local();
+	to_protect = 2;
+	dec_local();
+	dec_local();
+}
+
+static int invalid9(void)
+{
+	int lv;
+
+	lv = to_protect;
+	inc_local();
+	dec_local();
+}
+
+static int invalid10(void)
+{
+	helper();
+}
+
+/*
+ * check-name: Check -Wcontext
+ *
+ * check-error-start
+context_requirement.c:97:2: warning: context imbalance in 'invalid0' - different lock contexts for basic block
+context_requirement.c:101:12: warning: context imbalance in 'invalid1' - wrong count at exit
+context_requirement.c:106:12: warning: context imbalance in 'invalid2' - unexpected unlock
+context_requirement.c:113:6: warning: context imbalance in 'invalid3' - different lock contexts for basic block
+context_requirement.c:120:2: warning: context imbalance in 'invalid4' - different lock contexts for basic block
+context_requirement.c:129:2: warning: context imbalance in 'invalid5' - different lock contexts for basic block
+context_requirement.c:134:15: warning: out of context write access in 'invalid6' - context too small
+context_requirement.c:143:15: warning: out of context write access in 'invalid7' - context too small
+context_requirement.c:150:15: warning: out of context write access in 'invalid8' - context too high
+context_requirement.c:159:7: warning: out of context read access in 'invalid9' - context too small
+context_requirement.c:166:8: warning: out of context call in 'invalid10' - context too small
+ * check-error-end
+ */

-- 
: Dipl-Ing Philipp Reisner                      Tel +43-1-8178292-50 :
: LINBIT Information Technologies GmbH          Fax +43-1-8178292-82 :
: Vivenotgasse 48, 1120 Vienna, Austria        http://www.linbit.com :
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Warn about explicit usage of sizeof(void) and sizeof(function) ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Warn about explicit usage of sizeof(void) and sizeof(function)
Date: Thu, 25 Dec 2008 19:45:49 +0000
Message-ID: <70318cbf0812251145k1fa1e3bbh58b33a1aadf277cc () mail ! gmail ! com>
--------------------
Hi Alexey,

On Thu, Dec 25, 2008 at 10:36 AM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:
> I added (hopefully the right way) handling of (sizeof(function)) to the
> patch. function++ was already prohibited.

Can you send me an incremental patch for the sizeof(function) change?
BTW, is it one of the gcc special treatment as well?

Thanks

Chris

On Thu, Dec 25, 2008 at 10:36 AM, Alexey Zaytsev
<alexey.zaytsev@gmail.com> wrote:
> Tommy Thorn wrote:
>> Christopher Li wrote:
>>> So here is what I got. A patch address both of our need. It gives warning
>>> of using sizeof(void) explicitly. void* + offset will continue to work without
>>> warnings. It will also make is_byte_type() continue to work as it was
>>> before.
>>>
>>> Here is my test script:
>>>
> I added (hopefully the right way) handling of (sizeof(function)) to the
> patch. function++ was already prohibited.


>>> void *p;
>>>
>>> int i = sizeof(void);
>>> int j = sizeof(*p);
>>>
>
>> I can't test it right now, but does it give a warning for both sizeof's
>> above? If just first results in a warning, then I think that quite
>> reasonable.
>
> Both trigger the warning. I'm not sure this is a problem, as there are
> no such usage cases in the kernel.
>

>
> Running the test on the kernel right now.
>
> --
>
>
> From: Christopher Li <sparse@chrisli.org>
>
> sizeof(void) and sizeof(function) still evaluate as 1
> after the warning. void_ctype.bit_size remain zero so
> is_byte_type() will continue to work.
>
> Signed-Off-By: Christopher Li <sparse@chrisli.org>
> [sizeof(function) added by Alexey Zaytsev]
> Signed-off-by: Alexey Zaytsev <alexey.zaytsev@gmail.com>
> ---
>  evaluate.c |   13 ++++++++++++-
>  symbol.c   |    2 +-
>  2 files changed, 13 insertions(+), 2 deletions(-)
>
> diff --git a/evaluate.c b/evaluate.c
> index f976645..e82be53 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -579,7 +579,7 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
>        }
>
>        /* Get the size of whatever the pointer points to */
> -       multiply = bits_to_bytes(base->bit_size);
> +       multiply = (base == &void_ctype) ? 1 : bits_to_bytes(base->bit_size);
>
>        if (ctype == &null_ctype)
>                ctype = &ptr_ctype;
> @@ -2044,8 +2044,19 @@ static struct symbol *evaluate_sizeof(struct expression *expr)
>                return NULL;
>
>        size = type->bit_size;
> +
> +       if (type->ctype.base_type == &void_ctype) {
> +               warning(expr->pos, "expression using sizeof(void)");
> +               size = bits_in_char;
> +       }
> +
> +       if (is_function(type->ctype.base_type)) {
> +               warning(expr->pos, "expression using sizeof on a function");
> +               size = bits_in_char;
> +       }
>        if ((size < 0) || (size & (bits_in_char - 1)))
>                expression_error(expr, "cannot size expression");
> +
>        expr->type = EXPR_VALUE;
>        expr->value = bits_to_bytes(size);
>        expr->taint = 0;
> diff --git a/symbol.c b/symbol.c
> index 02844cf..4da253b 100644
> --- a/symbol.c
> +++ b/symbol.c
> @@ -834,7 +834,7 @@ static const struct ctype_declare {
>        struct symbol *base_type;
>  } ctype_declaration[] = {
>        { &bool_ctype,      SYM_BASETYPE, MOD_UNSIGNED,             &bits_in_bool,           &max_int_alignment, &int_type },
> -       { &void_ctype,      SYM_BASETYPE, 0,                        &bits_in_char,           NULL,               NULL },
> +       { &void_ctype,      SYM_BASETYPE, 0,                        NULL,                    NULL,               NULL },
>        { &type_ctype,      SYM_BASETYPE, MOD_TYPE,                 NULL,                    NULL,               NULL },
>        { &incomplete_ctype,SYM_BASETYPE, 0,                        NULL,                    NULL,               NULL },
>        { &bad_ctype,       SYM_BASETYPE, 0,                        NULL,                    NULL,               NULL },
>
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] activate context checking when context input and output ===

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] activate context checking when context input and output
Date: Mon, 21 Apr 2008 19:17:33 +0000
Message-ID: <480CE84D.3020102 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enigCE5FCDDFCFF1A5BA4C842BE0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

sylvain nahas wrote:
> the following patch activates context checking when context input and
> output values are the same and different of zero in
> __attribute__((context())), by making the parser generate a OP_CONTEXT
> pseudo instruction.
>=20
> Use case: specify that a function needs to be called in locked context.=


I have applied a patch from Johannes Berg which should also address this
problem.  Could you confirm that current Sparse from Git has the behavior=

you want?

- Josh Triplett


--------------enigCE5FCDDFCFF1A5BA4C842BE0
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIDOhNGJuZRtD+evsRAiz2AJsGBheTvA8AOuoOHDVFgJbuELEqFQCglAOA
JheHiWqLhykcFm58wzFLzAw=
=c2k2
-----END PGP SIGNATURE-----

--------------enigCE5FCDDFCFF1A5BA4C842BE0--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] activate context checking when context input and output values in __attribute__() are the sa ===

From: "sylvain nahas" <sylvain.nahas () googlemail ! com>
To: linux-sparse
Subject: [PATCH] activate context checking when context input and output values in __attribute__() are the sa
Date: Mon, 04 Feb 2008 20:42:19 +0000
Message-ID: <b98a45740802041242h35874d1fr563b92a122d30139 () mail ! gmail ! com>
--------------------
Hi,
the following patch activates context checking when context input and
output values are the same and different of zero in
__attribute__((context())), by making the parser generate a OP_CONTEXT
pseudo instruction.

Use case: specify that a function needs to be called in locked context.

Below is a sample case.
---
#define __needlock      __attribute__((context(lock,1,1)))
#define __acquire(x)	__context__(1)
#define __release(x)    __context__(-1)

static int __needlock test1(void)
{
	return 0;
}

static int __needlock test2(void)
{
	return test1(); /* OK */
}

static int test3(void)
{
        return test1(); /* should generate a warning */
}

int main(void)
{
	test1(); /* should generate a warning */
	test2(); /* should generate a warning */
	test3(); /* OK */
	__acquire();
	test1(); /* OK */
	__release();
	return -1;
}
---

I have used it on a relative big bunch of code and I believe it works well.
Thanks,

signed-off-by: Sylvain Nahas <sylvain.nahas@googlemailcom>
---
--- a/linearize.c
+++ b/linearize.c
@@ -1244,6 +1244,12 @@ static pseudo_t
linearize_call_expression(struct entrypoint *ep, struct expressi
                                out = 0;
                        }
                        context_diff = out - in;
+
+                       if( !context_diff && (in>0) ){
+                               check = 1;
+                               context_diff = in;
+                       }
+
                        if (check || context_diff) {
                                insn = alloc_instruction(OP_CONTEXT, 0);
                                insn->increment = context_diff;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] add __exact_context__ ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH] add __exact_context__
Date: Wed, 23 Apr 2008 12:50:38 +0000
Message-ID: <1208955038.31429.77.camel () johannes ! berg>
--------------------
We also need a statement to indicate that an exact context is
required, most notably the next patch will require it so that
it can translate attributes on variables into statements.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 ident-list.h               |    1 
 linearize.c                |    1 
 linearize.h                |    2 -
 parse.c                    |   20 ++++++++++++-
 parse.h                    |    1 
 sparse.1                   |    2 -
 sparse.c                   |   14 ++++++---
 validation/context-exact.c |   67 +++++++++++++++++++++++++++++++++++++++++++++
 8 files changed, 101 insertions(+), 7 deletions(-)

--- sparse.orig/ident-list.h	2008-04-23 14:36:41.000000000 +0200
+++ sparse/ident-list.h	2008-04-23 14:37:06.000000000 +0200
@@ -96,6 +96,7 @@ __IDENT(__PRETTY_FUNCTION___ident, "__PR
 
 /* Sparse commands */
 IDENT_RESERVED(__context__);
+IDENT_RESERVED(__exact_context__);
 IDENT_RESERVED(__range__);
 
 /* Magic function names we recognize */
--- sparse.orig/linearize.c	2008-04-23 14:37:06.000000000 +0200
+++ sparse/linearize.c	2008-04-23 14:44:00.000000000 +0200
@@ -1681,6 +1681,7 @@ static pseudo_t linearize_context(struct
 		value = expr->value;
 
 	insn->required = value;
+	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
 	add_one_insn(ep, insn);
--- sparse.orig/parse.c	2008-04-23 14:37:06.000000000 +0200
+++ sparse/parse.c	2008-04-23 14:37:06.000000000 +0200
@@ -52,6 +52,7 @@ static struct token *parse_while_stateme
 static struct token *parse_do_statement(struct token *token, struct statement *stmt);
 static struct token *parse_goto_statement(struct token *token, struct statement *stmt);
 static struct token *parse_context_statement(struct token *token, struct statement *stmt);
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt);
 static struct token *parse_range_statement(struct token *token, struct statement *stmt);
 static struct token *parse_asm_statement(struct token *token, struct statement *stmt);
 static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
@@ -149,6 +150,10 @@ static struct symbol_op __context___op =
 	.statement = parse_context_statement,
 };
 
+static struct symbol_op __exact_context___op = {
+	.statement = parse_exact_context_statement,
+};
+
 static struct symbol_op range_op = {
 	.statement = parse_range_statement,
 };
@@ -254,6 +259,7 @@ static struct init_keyword {
 	{ "do",		NS_KEYWORD, .op = &do_op },
 	{ "goto",	NS_KEYWORD, .op = &goto_op },
 	{ "__context__",NS_KEYWORD, .op = &__context___op },
+	{ "__exact_context__",NS_KEYWORD, .op = &__exact_context___op },
 	{ "__range__",	NS_KEYWORD, .op = &range_op },
 	{ "asm",	NS_KEYWORD, .op = &asm_op },
 	{ "__asm",	NS_KEYWORD, .op = &asm_op },
@@ -1810,7 +1816,7 @@ static struct token *parse_goto_statemen
 	return expect(token, ';', "at end of statement");
 }
 
-static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+static struct token *_parse_context_statement(struct token *token, struct statement *stmt, int exact)
 {
 	struct expression *args[3];
 	int argc = 0;
@@ -1835,6 +1841,8 @@ static struct token *parse_context_state
 	stmt->expression = args[0];
 	stmt->context = NULL;
 
+	stmt->exact = exact;
+
 	switch (argc) {
 	case 0:
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
@@ -1864,6 +1872,16 @@ static struct token *parse_context_state
 	return expect(token, ')', "at end of __context__");
 }
 
+static struct token *parse_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 0);
+}
+
+static struct token *parse_exact_context_statement(struct token *token, struct statement *stmt)
+{
+	return _parse_context_statement(token, stmt, 1);
+}
+
 static struct token *parse_range_statement(struct token *token, struct statement *stmt)
 {
 	stmt->type = STMT_RANGE;
--- sparse.orig/parse.h	2008-04-23 14:36:40.000000000 +0200
+++ sparse/parse.h	2008-04-23 14:37:06.000000000 +0200
@@ -43,6 +43,7 @@ struct statement {
 			struct expression *expression;
 			struct expression *context;
 			struct expression *required;
+			int exact;
 		};
 		struct /* return_statement */ {
 			struct expression *ret_value;
--- sparse.orig/sparse.1	2008-04-23 14:36:40.000000000 +0200
+++ sparse/sparse.1	2008-04-23 14:44:54.000000000 +0200
@@ -90,7 +90,7 @@ To indicate that a function requires
 .BI exactly
 a certain lock context (not "at least" as above), use the form
 .BI __attribute__((exact_context( [expression ,] in_context , out_context ))
-There currently is no corresponding
+There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
--- sparse.orig/sparse.c	2008-04-23 14:37:06.000000000 +0200
+++ sparse/sparse.c	2008-04-23 14:44:00.000000000 +0200
@@ -239,7 +239,7 @@ static int handle_context(struct entrypo
 			  struct context_check_list **combined)
 {
 	struct context_check *c;
-	const char *name;
+	const char *name, *cmp;
 	char *buf;
 	int val, ok;
 
@@ -256,7 +256,13 @@ static int handle_context(struct entrypo
 		}
 	} END_FOR_EACH_PTR(c);
 
-	ok = insn->required <= val;
+	if (insn->exact) {
+		ok = insn->required == val;
+		cmp = "";
+	} else {
+		ok = insn->required <= val;
+		cmp = ">= ";
+	}
 
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
@@ -266,8 +272,8 @@ static int handle_context(struct entrypo
 			"__context__ statement expected different context",
 			show_ident(ep->name->ident));
 
-		info(insn->pos, "%swanted >= %d, got %d",
-		     name, insn->required, val);
+		info(insn->pos, "%swanted %s%d, got %d",
+		     name, cmp, insn->required, val);
 
 		free(buf);
 		return -1;
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-exact.c	2008-04-23 14:44:00.000000000 +0200
@@ -0,0 +1,67 @@
+static void a(void) __attribute__((context(TEST,0,1)))
+{
+	__context__(TEST,1);
+}
+
+static void r(void) __attribute__((context(TEST,1,0)))
+{
+	__context__(TEST,-1,1);
+}
+
+static void good_1(void)
+{
+	a();
+	r();
+}
+
+static void good_2(void)
+{
+	a();
+	r();
+	a();
+	r();
+}
+
+static void good_3(void)
+{
+	a();
+	a();
+	r();
+	r();
+}
+
+static void good_4(void)
+{
+	a();
+	a();
+	__context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void warn_1(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,1);
+	r();
+	r();
+}
+
+static void good_5(void)
+{
+	a();
+	a();
+	__exact_context__(TEST,0,2);
+	r();
+	r();
+}
+
+/*
+ * check-name: Check __exact_context__ statement with required context
+ *
+ * check-error-start
+context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2:    context 'TEST': wanted 1, got 2
+ * check-error-end
+ */
--- sparse.orig/linearize.h	2008-04-23 14:37:12.000000000 +0200
+++ sparse/linearize.h	2008-04-23 14:44:00.000000000 +0200
@@ -116,7 +116,7 @@ struct instruction {
 			struct pseudo_list *arguments;
 		};
 		struct /* context */ {
-			int increment, required, inc_false;
+			int increment, required, inc_false, exact;
 			struct expression *context_expr;
 		};
 		struct /* asm */ {


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] allow context attribute on variables ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH] allow context attribute on variables
Date: Wed, 23 Apr 2008 12:55:51 +0000
Message-ID: <1208955351.31429.81.camel () johannes ! berg>
--------------------
This patch makes it possible to add the context attribute on
variables, to warn for example in this case:

    struct something {
        int x __attribute__((context(L,1,1)));
    };

    extern struct something *s;

    static void warn_access13(void)
    {
        s->x = 7;
    }

This is achieved by translating the context attribute on
variables that are loaded from/stored to into a context
expression internally. A number of tests are included,
including tests for a struct member (as above) and array
accesses.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
I didn't see any need for distinguishing between rd/wr nor
for a new attribute, so I just used the one we already have.

The exact_context() attribute is also allowed so we have the
same max/no-max semantics as functions.

If read/write is necessary to distinguish (I don't see a use
case) then we can do that fairly easily later.

 linearize.c                    |   74 +++++++++++++++
 linearize.h                    |    1 
 sparse.1                       |    3 
 sparse.c                       |   18 +++
 validation/context-exact.c     |    2 
 validation/context-on-vars.c   |  190 +++++++++++++++++++++++++++++++++++++++++
 validation/context-statement.c |    6 -
 7 files changed, 284 insertions(+), 10 deletions(-)

--- sparse.orig/sparse.c	2008-04-23 14:37:08.000000000 +0200
+++ sparse/sparse.c	2008-04-23 14:37:41.000000000 +0200
@@ -114,6 +114,7 @@ static struct context_check_list *checke
 }
 
 #define IMBALANCE_IN "context imbalance in '%s': "
+#define CONTEXT_PROB "context problem in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
 static void get_context_string(char **buf, const char **name)
@@ -267,10 +268,19 @@ static int handle_context(struct entrypo
 	if (!ok && Wcontext) {
 		get_context_string(&buf, &name);
 
-		warning(insn->pos,
-			IMBALANCE_IN
-			"__context__ statement expected different context",
-			show_ident(ep->name->ident));
+		if (insn->access_var) {
+			char *symname = strdup(show_ident(insn->access_var->ident));
+			warning(insn->pos,
+				CONTEXT_PROB
+				"access to '%s' requires different context",
+				show_ident(ep->name->ident), symname);
+			free(symname);
+		} else {
+			warning(insn->pos,
+				CONTEXT_PROB
+				"__context__ statement expected different context",
+				show_ident(ep->name->ident));
+		}
 
 		info(insn->pos, "%swanted %s%d, got %d",
 		     name, cmp, insn->required, val);
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-on-vars.c	2008-04-23 14:42:37.000000000 +0200
@@ -0,0 +1,190 @@
+static void a(void) __attribute__((context(L,0,1)))
+{
+	__context__(L,1);
+}
+
+static void r(void) __attribute__((context(L,1,0)))
+{
+	__context__(L,-1);
+}
+
+static int nl_int __attribute__((context(L,1,1)));
+static int nl_array[100] __attribute__((context(L,1,1)));
+extern int condition;
+
+static void warn_access1(void)
+{
+    nl_int = 7;
+}
+
+static void warn_access2(void)
+{
+    nl_int++;
+}
+
+static void warn_access3(void)
+{
+    if (condition)
+        nl_int++;
+}
+
+static void warn_access4(void)
+{
+    condition -= nl_int;
+}
+
+static void warn_access5(void)
+{
+    int x = condition ? nl_int : 0;
+}
+
+static void warn_access6(void)
+{
+    if (!nl_int) {
+        condition = 1;
+    }
+}
+
+static void warn_access7(void)
+{
+    if (nl_int) {
+        condition = 1;
+    }
+}
+
+static int *warn_access8(void)
+{
+    return &nl_int;
+}
+
+static void warn_access9(void)
+{
+    (void*)nl_int;
+}
+
+static void warn_access10(void)
+{
+    nl_array[7]++;
+}
+
+static void good_access1(void)
+{
+    a();
+    nl_int = 7;
+    r();
+}
+
+static void good_access1(void)
+{
+    if (condition) {
+        a();
+        nl_int = 7;
+        r();
+    }
+}
+
+static void good_access3(void)
+{
+    /* tests more our ability to optimise things out ... */
+    int x = 0 ? nl_int : 0;
+}
+
+static int *good_access4(void)
+{
+    return &nl_int;
+}
+
+struct something {
+    int a;
+    int b;
+};
+
+extern struct something *s __attribute__((context(L,1,1)));
+
+static void warn_access11(void)
+{
+    s->b = 7;
+}
+
+struct something2 {
+    int a;
+    int b __attribute__((context(L,1,1)));
+};
+
+extern struct something2 *s2;
+extern int lx __attribute__((context(L,1,1)));
+
+static void warn_access12(void)
+{
+    s2->b = lx;
+}
+
+static void warn_access13(void)
+{
+    s2->b = 7;
+}
+
+static void good_1(void)
+{
+    a();
+    s2->b = 7;
+    r();
+}
+
+static void good_2(void)
+{
+    a();
+    a();
+    s2->b = 8;
+    r();
+    r();
+}
+
+struct something3 {
+    int a;
+    int b __attribute__((exact_context(L,1,1)));
+};
+
+extern struct something3 *s3;
+
+static void warn_exact1(void)
+{
+    a();
+    a();
+    s3->b = 8;
+    r();
+    r();
+}
+
+/*
+ * check-name: Check -Wcontext for variables
+ *
+ * check-error-start
+context-on-vars.c:17:14: warning: context problem in 'warn_access1': access to 'nl_int' requires different context
+context-on-vars.c:17:14:    context 'L': wanted >= 1, got 0
+context-on-vars.c:22:11: warning: context problem in 'warn_access2': access to 'nl_int' requires different context
+context-on-vars.c:22:11:    context 'L': wanted >= 1, got 0
+context-on-vars.c:28:15: warning: context problem in 'warn_access3': access to 'nl_int' requires different context
+context-on-vars.c:28:15:    context 'L': wanted >= 1, got 0
+context-on-vars.c:33:18: warning: context problem in 'warn_access4': access to 'nl_int' requires different context
+context-on-vars.c:33:18:    context 'L': wanted >= 1, got 0
+context-on-vars.c:38:25: warning: context problem in 'warn_access5': access to 'nl_int' requires different context
+context-on-vars.c:38:25:    context 'L': wanted >= 1, got 0
+context-on-vars.c:43:10: warning: context problem in 'warn_access6': access to 'nl_int' requires different context
+context-on-vars.c:43:10:    context 'L': wanted >= 1, got 0
+context-on-vars.c:50:9: warning: context problem in 'warn_access7': access to 'nl_int' requires different context
+context-on-vars.c:50:9:    context 'L': wanted >= 1, got 0
+context-on-vars.c:62:12: warning: context problem in 'warn_access9': access to 'nl_int' requires different context
+context-on-vars.c:62:12:    context 'L': wanted >= 1, got 0
+context-on-vars.c:67:16: warning: context problem in 'warn_access10': access to 'nl_array' requires different context
+context-on-vars.c:67:16:    context 'L': wanted >= 1, got 0
+context-on-vars.c:106:5: warning: context problem in 'warn_access11': access to 's' requires different context
+context-on-vars.c:106:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:119:13: warning: context problem in 'warn_access12': access to 'lx' requires different context
+context-on-vars.c:119:13:    context 'L': wanted >= 1, got 0
+context-on-vars.c:124:5: warning: context problem in 'warn_access13': access to 'b' requires different context
+context-on-vars.c:124:5:    context 'L': wanted >= 1, got 0
+context-on-vars.c:154:5: warning: context problem in 'warn_exact1': access to 'b' requires different context
+context-on-vars.c:154:5:    context 'L': wanted 1, got 2
+ * check-error-end
+ */
--- sparse.orig/linearize.c	2008-04-23 14:37:08.000000000 +0200
+++ sparse/linearize.c	2008-04-23 14:40:54.000000000 +0200
@@ -30,7 +30,6 @@ static pseudo_t add_setval(struct entryp
 static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym);
 
 struct access_data;
-static pseudo_t add_load(struct entrypoint *ep, struct access_data *);
 static pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *);
 
 struct pseudo void_pseudo = {};
@@ -935,6 +934,8 @@ static pseudo_t linearize_store_gen(stru
 		pseudo_t value,
 		struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t store = value;
 
 	if (type_size(ad->source_type) != type_size(ad->result_type)) {
@@ -950,6 +951,40 @@ static pseudo_t linearize_store_gen(stru
 		store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
 	}
 	add_store(ep, ad, store);
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return value;
 }
 
@@ -987,6 +1022,8 @@ static pseudo_t add_symbol_address(struc
 
 static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad)
 {
+	struct context *context;
+	struct instruction *insn;
 	pseudo_t new = add_load(ep, ad);
 
 	if (ad->bit_offset) {
@@ -994,7 +1031,40 @@ static pseudo_t linearize_load_gen(struc
 		pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
 		new = newval;
 	}
-		
+
+	FOR_EACH_PTR(ad->source_type->ctype.contexts, context) {
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->source_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	FOR_EACH_PTR(ad->result_type->ctype.contexts, context) {
+		insn = alloc_instruction(OP_CONTEXT, 0);
+		insn->required = context->in;
+		insn->increment = insn->inc_false = context->out - context->in;
+		insn->context_expr = context->context;
+		insn->access_var = ad->result_type;
+		insn->exact = context->exact;
+		add_one_insn(ep, insn);
+	} END_FOR_EACH_PTR(context);
+
+	if (ad->address->type == PSEUDO_SYM &&
+	    ad->address->sym->namespace & NS_SYMBOL) {
+		FOR_EACH_PTR(ad->address->sym->ctype.contexts, context) {
+			insn = alloc_instruction(OP_CONTEXT, 0);
+			insn->required = context->in;
+			insn->increment = insn->inc_false = context->out - context->in;
+			insn->context_expr = context->context;
+			insn->access_var = ad->address->sym;
+			insn->exact = context->exact;
+			add_one_insn(ep, insn);
+		} END_FOR_EACH_PTR(context);
+	}
+
 	return new;
 }
 
--- sparse.orig/linearize.h	2008-04-23 14:37:16.000000000 +0200
+++ sparse/linearize.h	2008-04-23 14:37:41.000000000 +0200
@@ -118,6 +118,7 @@ struct instruction {
 		struct /* context */ {
 			int increment, required, inc_false, exact;
 			struct expression *context_expr;
+			struct symbol *access_var;
 		};
 		struct /* asm */ {
 			const char *string;
--- sparse.orig/validation/context-statement.c	2008-04-23 14:37:08.000000000 +0200
+++ sparse/validation/context-statement.c	2008-04-23 14:37:41.000000000 +0200
@@ -59,11 +59,11 @@ static void bad_macro3(void)
  * check-error-start
 context-statement.c:16:8: warning: context imbalance in 'bad_arr': unexpected unlock
 context-statement.c:16:8:    context 'LOCK': wanted 0, got -1
-context-statement.c:38:5: warning: context imbalance in 'bad_macro1': __context__ statement expected different context
+context-statement.c:38:5: warning: context problem in 'bad_macro1': __context__ statement expected different context
 context-statement.c:38:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:47:5: warning: context imbalance in 'bad_macro2': __context__ statement expected different context
+context-statement.c:47:5: warning: context problem in 'bad_macro2': __context__ statement expected different context
 context-statement.c:47:5:    context 'LOCK': wanted >= 1, got 0
-context-statement.c:53:5: warning: context imbalance in 'bad_macro3': __context__ statement expected different context
+context-statement.c:53:5: warning: context problem in 'bad_macro3': __context__ statement expected different context
 context-statement.c:53:5:    context 'LOCK': wanted >= 0, got -1
  * check-error-end
  */
--- sparse.orig/sparse.1	2008-04-23 14:37:08.000000000 +0200
+++ sparse/sparse.1	2008-04-23 14:42:59.000000000 +0200
@@ -94,6 +94,9 @@ There is also the corresponding
 .BI __exact_context__( [expression , ]adjust_value[ , required] )
 statement.
 
+Both these can also be added to variable accesses but it is not recommended
+to make variable accesses modify the context.
+
 To indicate that a certain function acquires a context depending on its
 return value, use
 .BI __attribute__((conditional_context( [expression ,] in_context , out_success , out_failure ))
--- sparse.orig/validation/context-exact.c	2008-04-23 14:43:12.000000000 +0200
+++ sparse/validation/context-exact.c	2008-04-23 14:43:19.000000000 +0200
@@ -61,7 +61,7 @@ static void good_5(void)
  * check-name: Check __exact_context__ statement with required context
  *
  * check-error-start
-context-exact.c:46:2: warning: context imbalance in 'warn_1': __context__ statement expected different context
+context-exact.c:46:2: warning: context problem in 'warn_1': __context__ statement expected different context
 context-exact.c:46:2:    context 'TEST': wanted 1, got 2
  * check-error-end
  */


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH] allow context attribute on variables
Date: Sat, 26 Apr 2008 15:50:05 +0000
Message-ID: <1209225005.10943.15.camel () johannes ! berg>
--------------------

--=-2wi6MN1SGTdHqosWoNoF
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> I like the idea of matching the existing attributes as closely as
> possible.  However, RCU provides a use case for distinguishing readers
> and writers: you might have a variable that you can read if you hold
> the RCU reader "lock", but you can only write if you hold a spinlock.

Oh good point. What way would you prefer? I can add another parameter to
the attribute, as in __attribute__((context(ctx,in,out,[read|write])))
(readwrite is implied), but that adds another parsing ambiguity. I have
just sent you another patch (was offline for a few days) that probably
won't apply without this, I'll fix this one and then do the other ones
on top.

johannes

--=-2wi6MN1SGTdHqosWoNoF
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASBNPK6Vg1VMiehFYAQJV5A//Z7jJ3Cr3arS35V6eVDMt3/iXiydIUzex
V9NhNjjkM2CbR4jVjaii3zvxbdFPj3LLQO+axecgL3H6sXQgUGf372Ot3TXwXWYx
R4kfkSJiDsmh4cmoDEA6imlF5Q/KoqoEjXeYWhwwxI2IJzDqnlDrBA3meB4FCNzj
d77pYjxHb3Dm8Yx8MasEaaLez190PIjpj8HEcrk40Yv8H7ZTOpHfGjwa3sAikRK8
p+XyqIt5Dyb6M2wVgZbkL8n3Mh7qCl8RSx9kXkFX1a1Sk7SLKYTNeTCo9nRqqyLB
01n4Tv+2Ve+ElAIs5G1PerwMqvQO1Wcvs2KChkwsNeo2wZrar1xzuFJyPlVHYh1h
mV4a9ImLjGNnsQDnTrerrfLou73BIglqMSeuzuHWCqCXzQERwF45M4ocAG9YGRrU
e9Fs0HcdzNpaOJ5pRAY1qJ8ZMqhZ3rQ81k3QxYCYC7fGFHBZb/GLGIzKbK2UqSrk
J4ia6RbnfNaOSZsbnodzeihpnNpOklXySVL71ToOdvc+Qb+goQ8xkZKREfEHlrIE
82YSfPYUfNbNxeYqGqQ5SB33NDI7hlsX/wCi2VXnu9zhPQYOde/tu7xwLrJ8UFgn
+ErdrXf3a2SlVJf1MaHBtGOilxPJPyXe/dqeC0ZqLEkL8TaSGd83DOvI88Quq+BV
JT/H+uUmySo=
=CGwK
-----END PGP SIGNATURE-----

--=-2wi6MN1SGTdHqosWoNoF--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] bitops: simplify generic bit finding functions ===

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] bitops: simplify generic bit finding functions
Date: Sun, 27 Apr 2008 20:38:27 +0000
Message-ID: <1209328707.14173.80.camel () brick>
--------------------
On Sun, 2008-04-27 at 21:36 +0100, Al Viro wrote:
> On Sun, Apr 27, 2008 at 01:29:21PM -0700, Harvey Harrison wrote:
> 
> > Oh, I didn't realize, I only did this because sparse started spewing out
> > lots of:
> > include/linux/bitops.h:166:32: warning: shift too big (65536) for type unsigned long
> > 
> > due to shift by size there, and again on line 202...I just wanted something
> > that sparse wouldn't warn about and was a little easier to understand to boot.
> 
> That's a sparse problem, really.  I wonder if we simply should introduce a
> new node type: EXPR_WARN.  So that expand would generate those from things
> like division by zero/overflow/bad shift *and* emitting an insn for those
> would generate a stored warning.

Well, even though it is a sparse problem, I think my revised version was
cleaner code anyway.

> 
> Objections?

None here

Harvey

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] don't call sparse when called to generate dependencies ===

From: Josh Triplett <josht () linux ! vnet ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] don't call sparse when called to generate dependencies
Date: Wed, 27 Aug 2008 00:43:04 +0000
Message-ID: <1219797784.6911.9.camel () josh-work ! beaverton ! ibm ! com>
--------------------
On Tue, 2008-08-26 at 00:33 +0300, Alexander Shishkin wrote:
> I have a situation here when $(CC) is called with -M options with
> slighly different set of -I/-D/etc arguments, which causes all sorts of
> funny reports from sparse. Also, this increases the overall build time
> because every compilation unit if sparsed twice.

Makes sense, given that -M implies -E.  Applied, thanks.

- Josh Triplett


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] evaluate/expand context expressions ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH] evaluate/expand context expressions
Date: Fri, 25 Apr 2008 11:24:22 +0000
Message-ID: <1209122662.10943.8.camel () johannes ! berg>
--------------------
But still allow having a standalone symbol as the context
expression, also evaluate the context change/requirement
directly in the parser and pass them up as integers. Also
fixes a number of bugs e.g. in the expression copier and
a segfault when the default context is used as such:
   __context__(1,1);

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 evaluate.c           |    9 ++++++++-
 expand.c             |    2 +-
 inline.c             |   19 ++++++++++++-------
 linearize.c          |   17 +++--------------
 parse.c              |   22 +++++++++++++---------
 parse.h              |    7 +++++--
 validation/context.c |   28 ++++++++++++++++++++++++++++
 7 files changed, 70 insertions(+), 34 deletions(-)

--- sparse.orig/evaluate.c	2008-04-25 02:15:15.000000000 +0200
+++ sparse/evaluate.c	2008-04-25 12:50:43.000000000 +0200
@@ -3356,7 +3356,14 @@ struct symbol *evaluate_statement(struct
 		evaluate_asm_statement(stmt);
 		return NULL;
 	case STMT_CONTEXT:
-		evaluate_expression(stmt->expression);
+		/*
+		 * If this is an unknown symbol accept it as-is
+		 * as a context name.
+		 */
+		if (stmt->context &&
+		    (stmt->context->type != EXPR_SYMBOL ||
+		     stmt->context->symbol))
+			evaluate_expression(stmt->context);
 		return NULL;
 	case STMT_RANGE:
 		evaluate_expression(stmt->range_expression);
--- sparse.orig/expand.c	2008-04-25 02:15:34.000000000 +0200
+++ sparse/expand.c	2008-04-25 12:50:43.000000000 +0200
@@ -1169,7 +1169,7 @@ static int expand_statement(struct state
 		/* FIXME! Do the asm parameter evaluation! */
 		break;
 	case STMT_CONTEXT:
-		expand_expression(stmt->expression);
+		expand_expression(stmt->context);
 		break;
 	case STMT_RANGE:
 		expand_expression(stmt->range_expression);
--- sparse.orig/inline.c	2008-04-25 12:50:08.000000000 +0200
+++ sparse/inline.c	2008-04-25 12:51:35.000000000 +0200
@@ -328,7 +328,18 @@ static struct statement *copy_one_statem
 		stmt = newstmt;
 		break;
 	}
-	case STMT_CONTEXT:
+	case STMT_CONTEXT: {
+		struct expression *expr = copy_expression(stmt->context);
+		struct statement *newstmt;
+		if (expr == stmt->context)
+			break;
+		newstmt = dup_statement(stmt);
+		newstmt->context = expr;
+		newstmt->change = stmt->change;
+		newstmt->required = stmt->required;
+		stmt = newstmt;
+		break;
+	}
 	case STMT_EXPRESSION: {
 		struct expression *expr = copy_expression(stmt->expression);
 		struct statement *newstmt;
@@ -336,12 +347,6 @@ static struct statement *copy_one_statem
 			break;
 		newstmt = dup_statement(stmt);
 		newstmt->expression = expr;
-		if (stmt->required) {
-			expr = copy_expression(stmt->required);
-			if (expr == stmt->required)
-				break;
-			newstmt->required = expr;
-		}
 		stmt = newstmt;
 		break;
 	}
--- sparse.orig/linearize.c	2008-04-25 12:50:09.000000000 +0200
+++ sparse/linearize.c	2008-04-25 12:56:35.000000000 +0200
@@ -1735,22 +1735,11 @@ static pseudo_t linearize_inlined_call(s
 static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 {
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
-	struct expression *expr = stmt->expression;
-	int value = 0;
 
-	if (expr->type == EXPR_VALUE)
-		value = expr->value;
+	insn->increment = stmt->change;
+	insn->inc_false = stmt->change;
 
-	insn->increment = value;
-	insn->inc_false = value;
-
-	expr = stmt->required;
-	value = 0;
-
-	if (expr && expr->type == EXPR_VALUE)
-		value = expr->value;
-
-	insn->required = value;
+	insn->required = stmt->required;
 	insn->exact = stmt->exact;
 
 	insn->context_expr = stmt->context;
--- sparse.orig/parse.c	2008-04-25 12:50:12.000000000 +0200
+++ sparse/parse.c	2008-04-25 13:09:27.000000000 +0200
@@ -1838,9 +1838,7 @@ static struct token *_parse_context_stat
 		token = token->next;
 	}
 
-	stmt->expression = args[0];
 	stmt->context = NULL;
-
 	stmt->exact = exact;
 
 	switch (argc) {
@@ -1848,21 +1846,27 @@ static struct token *_parse_context_stat
 		sparse_error(token->pos, "__context__ statement needs argument(s)");
 		return token;
 	case 1:
-		/* already done */
+		stmt->change = get_expression_value(args[0]);
 		break;
 	case 2:
-		if (args[0]->type != STMT_EXPRESSION) {
+		/*
+		 * We should actually check whether we can evalulate
+		 * it as a constant expression and if so use as the
+		 * 'change' value. I hope nobody gives a calculation
+		 * for the number.
+		 */
+		if (args[0]->type != EXPR_VALUE) {
 			stmt->context = args[0];
-			stmt->expression = args[1];
+			stmt->change = get_expression_value(args[1]);
 		} else {
-			stmt->expression = args[0];
-			stmt->required = args[1];
+			stmt->change = get_expression_value(args[0]);
+			stmt->required = get_expression_value(args[1]);
 		}
 		break;
 	case 3:
 		stmt->context = args[0];
-		stmt->expression = args[1];
-		stmt->required = args[2];
+		stmt->change = get_expression_value(args[1]);
+		stmt->required = get_expression_value(args[2]);
 		break;
 	default:
 		sparse_error(token->pos, "too many arguments for __context__ statement");
--- sparse.orig/parse.h	2008-04-25 12:50:09.000000000 +0200
+++ sparse/parse.h	2008-04-25 12:50:43.000000000 +0200
@@ -39,10 +39,13 @@ struct statement {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
-		struct { /* __context__ */
+		struct { /* expression */
 			struct expression *expression;
+		};
+		struct { /* __context__ */
 			struct expression *context;
-			struct expression *required;
+			int change, required;
+			int exact;
 		};
 		struct /* return_statement */ {
 			struct expression *ret_value;
--- sparse.orig/validation/context.c	2008-04-25 12:50:12.000000000 +0200
+++ sparse/validation/context.c	2008-04-25 13:10:09.000000000 +0200
@@ -380,6 +380,32 @@ static int warn_conditional(void)
     return 0;
 }
 
+static void areq(void) __attribute__((context(1,2)))
+{
+	__context__(1,1);
+}
+
+static void good_reqlock(void)
+{
+	a();
+	areq();
+	r();
+	r();
+}
+
+static void warn_reqlock(void)
+{
+	areq();
+	r();
+}
+
+
+static void dummy1(void) __attribute__((context(p,0,1)))
+{
+        void *p;
+	__context__(p,1);
+}
+
 /*
  * check-name: Check -Wcontext
  *
@@ -418,5 +444,7 @@ context.c:360:10: warning: context probl
 context.c:360:10:    default context: wanted >= 1, got 0
 context.c:380:12: warning: context imbalance in 'warn_conditional': wrong count at exit
 context.c:380:12:    default context: wanted 0, got 1
+context.c:398:6: warning: context problem in 'warn_reqlock': 'areq' expected different context
+context.c:398:6:    default context: wanted >= 1, got 0
  * check-error-end
  */


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix bug in context tracking code ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH] fix bug in context tracking code
Date: Wed, 23 Apr 2008 10:24:49 +0000
Message-ID: <1208946289.31429.66.camel () johannes ! berg>
--------------------
My optimisation to avoid recursion into BBs when checking contexts
lead to a failure in a case like this:

    static int warn_conditional(void)
    {
        if (condition)
            return 0;

        a();
        if (condition == 0)
            return 1;
        r();
        return 0;
    }

because some blocks are called with different contexts and thus
need to be checked multiple times.

The obvious fix would be to decrease the recursion depth at the
end of the BB check function, but that, while correct, leads to
extremely long sparse runtimes on somewhat complex functions.
Thus, this patch also makes sparse cache which contexts it has
checked a block in and avoid the re-checking in that case.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 linearize.c          |    1 
 linearize.h          |    4 +
 sparse.c             |  128 +++++++++++++++++++++++++++++++++++++++++++++------
 validation/context.c |   14 +++++
 4 files changed, 131 insertions(+), 16 deletions(-)

--- sparse.orig/linearize.c	2008-04-23 12:17:18.000000000 +0200
+++ sparse/linearize.c	2008-04-23 12:17:20.000000000 +0200
@@ -66,7 +66,6 @@ static struct entrypoint *alloc_entrypoi
 static struct basic_block *alloc_basic_block(struct entrypoint *ep, struct position pos)
 {
 	struct basic_block *bb = __alloc_basic_block(0);
-	bb->context = -1;
 	bb->pos = pos;
 	bb->ep = ep;
 	return bb;
--- sparse.orig/linearize.h	2008-04-23 12:17:18.000000000 +0200
+++ sparse/linearize.h	2008-04-23 12:17:20.000000000 +0200
@@ -219,11 +219,13 @@ enum opcode {
 
 struct basic_block_list;
 struct instruction_list;
+struct context_list_list;
 
 struct basic_block {
 	struct position pos;
 	unsigned long generation;
-	int context;
+	int context_check_recursion;
+	struct context_list_list *checked_contexts;
 	struct entrypoint *ep;
 	struct basic_block_list *parents; /* sources */
 	struct basic_block_list *children; /* destinations */
--- sparse.orig/sparse.c	2008-04-23 12:17:18.000000000 +0200
+++ sparse/sparse.c	2008-04-23 12:17:20.000000000 +0200
@@ -31,6 +31,7 @@ struct context_check {
 
 DECLARE_ALLOCATOR(context_check);
 DECLARE_PTR_LIST(context_check_list, struct context_check);
+DECLARE_PTR_LIST(context_list_list, struct context_check_list);
 ALLOCATOR(context_check, "context check list");
 
 static const char *unnamed_context = "<unnamed>";
@@ -64,6 +65,54 @@ static void context_add(struct context_c
 	found->val_false += offs_false;
 }
 
+static int context_list_has(struct context_check_list *ccl,
+			    struct context_check *c)
+{
+	struct context_check *check;
+
+	FOR_EACH_PTR(ccl, check) {
+		if (strcmp(c->name, check->name))
+			continue;
+		return check->val == c->val &&
+		       check->val_false == c->val_false;
+	} END_FOR_EACH_PTR(check);
+
+	/* not found is equal to 0 */
+	return c->val == 0 && c->val_false == 0;
+}
+
+static int context_lists_equal(struct context_check_list *ccl1,
+			       struct context_check_list *ccl2)
+{
+	struct context_check *check;
+
+	/* can be optimised... */
+
+	FOR_EACH_PTR(ccl1, check) {
+		if (!context_list_has(ccl2, check))
+			return 0;
+	} END_FOR_EACH_PTR(check);
+
+	FOR_EACH_PTR(ccl2, check) {
+		if (!context_list_has(ccl1, check))
+			return 0;
+	} END_FOR_EACH_PTR(check);
+
+	return 1;
+}
+
+static struct context_check_list *checked_copy(struct context_check_list *ccl)
+{
+	struct context_check_list *result = NULL;
+	struct context_check *c;
+
+	FOR_EACH_PTR(ccl, c) {
+		context_add(&result, c->name, c->val_false, c->val_false);
+	} END_FOR_EACH_PTR(c);
+
+	return result;
+}
+
 #define IMBALANCE_IN "context imbalance in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
@@ -234,18 +283,26 @@ static int check_bb_context(struct entry
 			    struct context_check_list *ccl_target,
 			    int in_false)
 {
-	struct context_check_list *combined = NULL;
+	struct context_check_list *combined = NULL, *done;
 	struct context_check *c;
 	struct instruction *insn;
 	struct multijmp *mj;
+	int err = -1;
 
 	/*
-	 * recurse in once to catch bad loops,
-	 * bb->context is initialised to -1.
+	 * Recurse in once to catch bad loops.
 	 */
-	if (bb->context > 0)
+	if (bb->context_check_recursion > 1)
 		return 0;
-	bb->context++;
+	bb->context_check_recursion++;
+
+	/*
+	 * Abort if we have already checked this block out of the same context.
+	 */
+	FOR_EACH_PTR(bb->checked_contexts, done) {
+		if (context_lists_equal(done, ccl_in))
+			return 0;
+	} END_FOR_EACH_PTR(done);
 
 	/*
 	 * We're starting with a completely new local list of contexts, so
@@ -260,6 +317,10 @@ static int check_bb_context(struct entry
 			context_add(&combined, c->name, c->val, c->val);
 	} END_FOR_EACH_PTR(c);
 
+	/* Add the new context to the list of already-checked contexts */
+	done = checked_copy(combined);
+	add_ptr_list(&bb->checked_contexts, done);
+
 	/*
 	 * Now walk the instructions for this block, recursing into any
 	 * instructions that have children. We need to have the right
@@ -270,28 +331,28 @@ static int check_bb_context(struct entry
 		case OP_INLINED_CALL:
 		case OP_CALL:
 			if (handle_call(ep, bb, insn, combined))
-				return -1;
+				goto out;
 			break;
 		case OP_CONTEXT:
 			if (handle_context(ep, bb, insn, &combined))
-				return -1;
+				goto out;
 			break;
 		case OP_BR:
 			if (insn->bb_true)
 				if (check_bb_context(ep, insn->bb_true,
 						     combined, ccl_target, 0))
-					return -1;
+					goto out;
 			if (insn->bb_false)
 				if (check_bb_context(ep, insn->bb_false,
 						     combined, ccl_target, 1))
-					return -1;
+					goto out;
 			break;
 		case OP_SWITCH:
 		case OP_COMPUTEDGOTO:
 			FOR_EACH_PTR(insn->multijmp_list, mj) {
 				if (check_bb_context(ep, mj->target,
 					             combined, ccl_target, 0))
-					return -1;
+					goto out;
 			} END_FOR_EACH_PTR(mj);
 			break;
 		}
@@ -299,15 +360,53 @@ static int check_bb_context(struct entry
 
 	insn = last_instruction(bb->insns);
 	if (!insn)
-		return 0;
+		goto out_good;
 
-	if (insn->opcode == OP_RET)
-		return context_list_check(ep, insn->pos, combined, ccl_target);
+	if (insn->opcode == OP_RET) {
+		err = context_list_check(ep, insn->pos, combined, ccl_target);
+		goto out;
+	}
 
+ out_good:
+	err = 0;
+ out:
 	/* contents will be freed once we return out of recursion */
 	free_ptr_list(&combined);
+	bb->context_check_recursion--;
+	return err;
+}
 
-	return 0;
+static void free_bb_context_lists(struct basic_block *bb)
+{
+	struct context_check_list *done;
+	struct instruction *insn;
+	struct multijmp *mj;
+
+	if (!bb->checked_contexts)
+		return;
+
+	FOR_EACH_PTR(bb->checked_contexts, done) {
+		free_ptr_list(&done);
+	} END_FOR_EACH_PTR(done);
+
+	free_ptr_list(&bb->checked_contexts);
+
+	FOR_EACH_PTR(bb->insns, insn) {
+		switch (insn->opcode) {
+		case OP_BR:
+			if (insn->bb_true)
+				free_bb_context_lists(insn->bb_true);
+			if (insn->bb_false)
+				free_bb_context_lists(insn->bb_false);
+			break;
+		case OP_SWITCH:
+		case OP_COMPUTEDGOTO:
+			FOR_EACH_PTR(insn->multijmp_list, mj) {
+				free_bb_context_lists(mj->target);
+			} END_FOR_EACH_PTR(mj);
+			break;
+		}
+	} END_FOR_EACH_PTR(insn);
 }
 
 static void check_cast_instruction(struct instruction *insn)
@@ -474,6 +573,7 @@ static void check_context(struct entrypo
 	check_bb_context(ep, ep->entry->bb, ccl_in, ccl_target, 0);
 	free_ptr_list(&ccl_in);
 	free_ptr_list(&ccl_target);
+	free_bb_context_lists(ep->entry->bb);
 	clear_context_check_alloc();
 }
 
--- sparse.orig/validation/context.c	2008-04-23 12:17:18.000000000 +0200
+++ sparse/validation/context.c	2008-04-23 12:17:20.000000000 +0200
@@ -368,6 +368,18 @@ static void warn_huge_switch(void)
     }
 }
 
+static int warn_conditional(void)
+{
+    if (condition)
+        return 0;
+
+    a();
+    if (condition == 0)
+        return 1;
+    r();
+    return 0;
+}
+
 /*
  * check-name: Check -Wcontext
  *
@@ -404,5 +416,7 @@ context.c:325:10: warning: context probl
 context.c:325:10:    default context: wanted >= 1, got 0
 context.c:360:10: warning: context problem in 'warn_huge_switch': 'r' expected different context
 context.c:360:10:    default context: wanted >= 1, got 0
+context.c:380:12: warning: context imbalance in 'warn_conditional': wrong count at exit
+context.c:380:12:    default context: wanted 0, got 1
  * check-error-end
  */


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] fix bug in context tracking code
Date: Fri, 25 Apr 2008 02:34:39 +0000
Message-ID: <4811433F.6010306 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig92B770EF6F397098036D0F54
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Johannes Berg wrote:
> My optimisation to avoid recursion into BBs when checking contexts
> lead to a failure in a case like this:
>=20
>     static int warn_conditional(void)
>     {
>         if (condition)
>             return 0;
>=20
>         a();
>         if (condition =3D=3D 0)
>             return 1;
>         r();
>         return 0;
>     }
>=20
> because some blocks are called with different contexts and thus
> need to be checked multiple times.
>=20
> The obvious fix would be to decrease the recursion depth at the
> end of the BB check function, but that, while correct, leads to
> extremely long sparse runtimes on somewhat complex functions.
> Thus, this patch also makes sparse cache which contexts it has
> checked a block in and avoid the re-checking in that case.
>=20
> Signed-off-by: Johannes Berg <johannes@sipsolutions.net>

Applied and pushed; thanks!

- Josh Triplett


--------------enig92B770EF6F397098036D0F54
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIEUM/GJuZRtD+evsRAk7KAJ4soCYu9Udp1i7hnQJF4j3suCDJcgCgntzB
JAlnlGYz4m4/aw7huV8Opuw=
=thbr
-----END PGP SIGNATURE-----

--------------enig92B770EF6F397098036D0F54--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] ignore __cold__ attribute ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [PATCH] ignore __cold__ attribute
Date: Tue, 22 Apr 2008 10:41:23 +0000
Message-ID: <1208860883.31429.8.camel () johannes ! berg>
--------------------
This is a new attribute in gcc 4.3, which when used and sparse is
compiled with gcc 4.3 leads to unknown attribute errors. Ignore it.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
diff --git a/parse.c b/parse.c
index 83e2d67..cdcd742 100644
--- a/parse.c
+++ b/parse.c
@@ -355,6 +355,7 @@ static struct init_keyword {
 	{ "__constructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "destructor",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "__destructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__cold__",	NS_KEYWORD,	.op = &ignore_attr_op },
 };
 
 void init_parser(int stream)


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH] ignore __cold__ attribute
Date: Tue, 22 Apr 2008 13:25:06 +0000
Message-ID: <1208870706.31429.23.camel () johannes ! berg>
--------------------

--=-BSKhGHYnZVVfgwfOxaaU
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Tue, 2008-04-22 at 09:07 -0400, Pavel Roskin wrote:
> Quoting Johannes Berg <johannes@sipsolutions.net>:
>=20
> > This is a new attribute in gcc 4.3, which when used and sparse is
> > compiled with gcc 4.3 leads to unknown attribute errors. Ignore it.
>=20
> According to =20
> http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html, the new =20
> attributes are "cold" and "hot".  I think we need them ignored both =20
> with and without underscores.
>=20
> The attributes indicate whether the function is likely to be executed, =20
> and thus affect optimization.  There is nothing useful for sparse in =20
> that information.

*Shrug*. I just wanted the kernel to work again and failed (in about 20
minutes of searching) to find a changelog for gcc mentioning this so
gave up and just added the one that the kernel uses. Want to amend the
patch?

johannes

--=-BSKhGHYnZVVfgwfOxaaU
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASA3nMaVg1VMiehFYAQKIpQ//eAfFup/N1KwrYea5bKqXWTLTIFevDhWF
vCBVsrWEzhKaTrIfBGMA79WQzBQsz8NG3pJAJw0/nsfjYHIyT+WrL7dhmSWwxP1m
ZiO13Elw51aA4HBxS7H/zy5blyTmHf+TBF6z7saPBAYVht6To07SKRX3bhBk9eeb
3WUYTNwujyFpaP8pgI67oqHsRWdKTCV5j/u7uQ9rcMwgV2jIqj7uS9A+m6bwtEHf
JfY8Sbp1kVd6n9ctRgym5zDgBFjCk9wNGGMeY9N/jy5KzzOg5suWKxF42HJp4g+2
RIU9KqmRfTFpWBX2dQC1REmA4VU212/OPOX8fZ+Yqr8dtrU+FdHyHy/9/vuWjVA1
99fAlt14eisuUpW/VwUZMApDRyF9SbuVVgyeo9hrqrBtiyZflmSX5+ygj6o2kkyP
e36ksCBq0284v5/kAeSRN94DCo7U5RaldHab2C/rsCZ5tbFcy/94OWDt/SQNb37o
VmXVwH3ZZwXyFc8sd9ozz7EPyRV4/FHfF6Up85oJAqWozR9g0HmugULoZQv6yJiy
YxPpRGDx3bcLBW1hbAW9EW382voS+gvJGoTr5XzgndrIG6MRUhmHy6/EJHZsCytd
QLqOFNI8ewnNct1AX6Ds/tLzz4sNmb6UVfA2vKM1+IiN2DMpsX5F3D6sJ3VoW5LX
mNtFakewgOE=
=wTM1
-----END PGP SIGNATURE-----

--=-BSKhGHYnZVVfgwfOxaaU--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: [PATCH] ignore __cold__ attribute
Date: Fri, 25 Apr 2008 02:26:06 +0000
Message-ID: <4811413E.1080103 () freedesktop ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig78D65CCA001E81C8CA803BEC
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Pavel Roskin wrote:
> On Tue, 2008-04-22 at 15:25 +0200, Johannes Berg wrote:
>> *Shrug*. I just wanted the kernel to work again and failed (in about 2=
0
>> minutes of searching) to find a changelog for gcc mentioning this so
>> gave up and just added the one that the kernel uses. Want to amend the=

>> patch?
>=20
> I think this would be better.  Now sparse would ignore both "cold" and
> "hot", both with and without underscores.  They are also added to
> ident-list.h.
>=20
> diff --git a/ident-list.h b/ident-list.h
> index 8fcd7de..6104826 100644
> --- a/ident-list.h
> +++ b/ident-list.h
> @@ -74,6 +74,8 @@ IDENT(__malloc__);
>  IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
>  IDENT(constructor); IDENT(__constructor__);
>  IDENT(destructor); IDENT(__destructor__);
> +IDENT(cold); IDENT(__cold__);
> +IDENT(hot); IDENT(__hot__);
>  IDENT(cdecl); IDENT(__cdecl__);
>  IDENT(stdcall); IDENT(__stdcall__);
>  IDENT(fastcall); IDENT(__fastcall__);
> diff --git a/parse.c b/parse.c
> index 137ba77..877414c 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -353,6 +353,10 @@ static struct init_keyword {
>  	{ "__constructor__",	NS_KEYWORD,	.op =3D &ignore_attr_op },
>  	{ "destructor",	NS_KEYWORD,	.op =3D &ignore_attr_op },
>  	{ "__destructor__",	NS_KEYWORD,	.op =3D &ignore_attr_op },
> +	{ "cold",	NS_KEYWORD,	.op =3D &ignore_attr_op },
> +	{ "__cold__",	NS_KEYWORD,	.op =3D &ignore_attr_op },
> +	{ "hot",	NS_KEYWORD,	.op =3D &ignore_attr_op },
> +	{ "__hot__",	NS_KEYWORD,	.op =3D &ignore_attr_op },
>  };

Looks good to me.  Could I get a signoff and commit message please?

- Josh Triplett


--------------enig78D65CCA001E81C8CA803BEC
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIEUE+GJuZRtD+evsRAjRZAJ9zt0jsvCbkcZ+QrkLXCSWgIt7rGACfbI+v
nlVR8IbLw7m0BHXI/3uB+YU=
=wmkq
-----END PGP SIGNATURE-----

--------------enig78D65CCA001E81C8CA803BEC--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH] ignore __cold__ attribute
Date: Fri, 02 May 2008 19:42:33 +0000
Message-ID: <1209757353.25568.2.camel () dv>
--------------------
On Thu, 2008-04-24 at 19:26 -0700, Josh Triplett wrote:

> Looks good to me.  Could I get a signoff and commit message please?

I posted it already, but I think it was lost, so here it is again.


Ignore "cold" and "hot" attributes, which appeared in gcc 4.3

They describe how likely the function is to be executed, which can
affect optimization.  Also ignore the attributes with underscores.

Signed-off-by: Pavel Roskin <proski@gnu.org>
---

 ident-list.h |    2 ++
 parse.c      |    4 ++++
 2 files changed, 6 insertions(+), 0 deletions(-)


diff --git a/ident-list.h b/ident-list.h
index 8fcd7de..6104826 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -74,6 +74,8 @@ IDENT(__malloc__);
 IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
 IDENT(constructor); IDENT(__constructor__);
 IDENT(destructor); IDENT(__destructor__);
+IDENT(cold); IDENT(__cold__);
+IDENT(hot); IDENT(__hot__);
 IDENT(cdecl); IDENT(__cdecl__);
 IDENT(stdcall); IDENT(__stdcall__);
 IDENT(fastcall); IDENT(__fastcall__);
diff --git a/parse.c b/parse.c
index 137ba77..877414c 100644
--- a/parse.c
+++ b/parse.c
@@ -353,6 +353,10 @@ static struct init_keyword {
 	{ "__constructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "destructor",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "__destructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "cold",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__cold__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "hot",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__hot__",	NS_KEYWORD,	.op = &ignore_attr_op },
 };
 
 void init_parser(int stream)

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH] ignore __cold__ attribute
Date: Fri, 02 May 2008 19:42:33 +0000
Message-ID: <1209757353.25568.2.camel () dv>
--------------------
On Thu, 2008-04-24 at 19:26 -0700, Josh Triplett wrote:

> Looks good to me.  Could I get a signoff and commit message please?

I posted it already, but I think it was lost, so here it is again.


Ignore "cold" and "hot" attributes, which appeared in gcc 4.3

They describe how likely the function is to be executed, which can
affect optimization.  Also ignore the attributes with underscores.

Signed-off-by: Pavel Roskin <proski@gnu.org>
---

 ident-list.h |    2 ++
 parse.c      |    4 ++++
 2 files changed, 6 insertions(+), 0 deletions(-)


diff --git a/ident-list.h b/ident-list.h
index 8fcd7de..6104826 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -74,6 +74,8 @@ IDENT(__malloc__);
 IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
 IDENT(constructor); IDENT(__constructor__);
 IDENT(destructor); IDENT(__destructor__);
+IDENT(cold); IDENT(__cold__);
+IDENT(hot); IDENT(__hot__);
 IDENT(cdecl); IDENT(__cdecl__);
 IDENT(stdcall); IDENT(__stdcall__);
 IDENT(fastcall); IDENT(__fastcall__);
diff --git a/parse.c b/parse.c
index 137ba77..877414c 100644
--- a/parse.c
+++ b/parse.c
@@ -353,6 +353,10 @@ static struct init_keyword {
 	{ "__constructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "destructor",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "__destructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "cold",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__cold__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "hot",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__hot__",	NS_KEYWORD,	.op = &ignore_attr_op },
 };
 
 void init_parser(int stream)

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH] ignore __cold__ attribute
Date: Thu, 19 Jun 2008 05:04:55 +0000
Message-ID: <1213851895.2405.2.camel () dv>
--------------------
On Thu, 2008-04-24 at 19:26 -0700, Josh Triplett wrote:
> Pavel Roskin wrote:
> > On Tue, 2008-04-22 at 15:25 +0200, Johannes Berg wrote:
> >> *Shrug*. I just wanted the kernel to work again and failed (in about 20
> >> minutes of searching) to find a changelog for gcc mentioning this so
> >> gave up and just added the one that the kernel uses. Want to amend the
> >> patch?
> > 
> > I think this would be better.  Now sparse would ignore both "cold" and
> > "hot", both with and without underscores.  They are also added to
> > ident-list.h.
> > 
> > diff --git a/ident-list.h b/ident-list.h
> > index 8fcd7de..6104826 100644
> > --- a/ident-list.h
> > +++ b/ident-list.h
> > @@ -74,6 +74,8 @@ IDENT(__malloc__);
> >  IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
> >  IDENT(constructor); IDENT(__constructor__);
> >  IDENT(destructor); IDENT(__destructor__);
> > +IDENT(cold); IDENT(__cold__);
> > +IDENT(hot); IDENT(__hot__);
> >  IDENT(cdecl); IDENT(__cdecl__);
> >  IDENT(stdcall); IDENT(__stdcall__);
> >  IDENT(fastcall); IDENT(__fastcall__);
> > diff --git a/parse.c b/parse.c
> > index 137ba77..877414c 100644
> > --- a/parse.c
> > +++ b/parse.c
> > @@ -353,6 +353,10 @@ static struct init_keyword {
> >  	{ "__constructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
> >  	{ "destructor",	NS_KEYWORD,	.op = &ignore_attr_op },
> >  	{ "__destructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "cold",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "__cold__",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "hot",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "__hot__",	NS_KEYWORD,	.op = &ignore_attr_op },
> >  };
> 
> Looks good to me.  Could I get a signoff and commit message please?

Signed-off-by: Pavel Roskin <proski@gnu.org>

Sorry for delay.  I thought I answered it already.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: [PATCH] ignore __cold__ attribute
Date: Thu, 19 Jun 2008 05:04:55 +0000
Message-ID: <1213851895.2405.2.camel () dv>
--------------------
On Thu, 2008-04-24 at 19:26 -0700, Josh Triplett wrote:
> Pavel Roskin wrote:
> > On Tue, 2008-04-22 at 15:25 +0200, Johannes Berg wrote:
> >> *Shrug*. I just wanted the kernel to work again and failed (in about 20
> >> minutes of searching) to find a changelog for gcc mentioning this so
> >> gave up and just added the one that the kernel uses. Want to amend the
> >> patch?
> > 
> > I think this would be better.  Now sparse would ignore both "cold" and
> > "hot", both with and without underscores.  They are also added to
> > ident-list.h.
> > 
> > diff --git a/ident-list.h b/ident-list.h
> > index 8fcd7de..6104826 100644
> > --- a/ident-list.h
> > +++ b/ident-list.h
> > @@ -74,6 +74,8 @@ IDENT(__malloc__);
> >  IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
> >  IDENT(constructor); IDENT(__constructor__);
> >  IDENT(destructor); IDENT(__destructor__);
> > +IDENT(cold); IDENT(__cold__);
> > +IDENT(hot); IDENT(__hot__);
> >  IDENT(cdecl); IDENT(__cdecl__);
> >  IDENT(stdcall); IDENT(__stdcall__);
> >  IDENT(fastcall); IDENT(__fastcall__);
> > diff --git a/parse.c b/parse.c
> > index 137ba77..877414c 100644
> > --- a/parse.c
> > +++ b/parse.c
> > @@ -353,6 +353,10 @@ static struct init_keyword {
> >  	{ "__constructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
> >  	{ "destructor",	NS_KEYWORD,	.op = &ignore_attr_op },
> >  	{ "__destructor__",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "cold",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "__cold__",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "hot",	NS_KEYWORD,	.op = &ignore_attr_op },
> > +	{ "__hot__",	NS_KEYWORD,	.op = &ignore_attr_op },
> >  };
> 
> Looks good to me.  Could I get a signoff and commit message please?

Signed-off-by: Pavel Roskin <proski@gnu.org>

Sorry for delay.  I thought I answered it already.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] pre-process.c: [trivial] Use a larger buffer [4k] for expanding tokens
 Fixes error on assert(strcmp(somefn(x),str) == 0) ===

From: Brett Nash <nash@nash.id.au>
To: Unknown
Subject: [PATCH] pre-process.c: [trivial] Use a larger buffer [4k] for expanding tokens
 Fixes error on assert(strcmp(somefn(x),str) == 0)
Date: Wed, 3 Sep 2008 08:29:26 +1000
Message-ID: 
--------------------

Signed-off-by: Brett Nash <nash@nash.id.au>
---
 pre-process.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/pre-process.c b/pre-process.c
index ca1d8ef..5269613 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -1401,7 +1401,7 @@ static int handle_endif(struct stream *stream, struct token **line, struct token
 
 static const char *show_token_sequence(struct token *token)
 {
-	static char buffer[1024];
+	static char buffer[4096];
 	char *ptr = buffer;
 	int whitespace = 0;
 
-- 
1.5.6.5


--MP_/QN10/+9fsHIhtgG_qTZ90Tq--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] saner warnings for restricted types ===

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH] saner warnings for restricted types
Date: Tue, 15 Jan 2008 16:52:36 +0000
Message-ID: <20080115165236.GS27894 () ZenIV ! linux ! org ! uk>
--------------------
* don't crap the type->ident for unsigned int just because somebody did
	typedef unsigned int x;
  only structs, unions, enums and restricted types need this logics.
* generate saner warnings for restricted, include type name(s) into them.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c   |   33 ++++++++++++++++++++-------------
 parse.c      |   11 +++++++++--
 show-parse.c |    4 ++++
 3 files changed, 33 insertions(+), 15 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 54fcd3f..777f603 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -500,9 +500,10 @@ static inline void unrestrict(struct expression *expr,
 			      int class, struct symbol **ctype)
 {
 	if (class & TYPE_RESTRICT) {
-		warning(expr->pos, "restricted degrades to integer");
 		if (class & TYPE_FOULED)
 			*ctype = unfoul(*ctype);
+		warning(expr->pos, "%sdegrades to integer",
+			show_typename(*ctype));
 		*ctype = (*ctype)->ctype.base_type; /* get to arithmetic type */
 	}
 }
@@ -1235,7 +1236,9 @@ static int evaluate_assign_op(struct expression *expr)
 		}
 		if (tclass & TYPE_RESTRICT) {
 			if (!restricted_binop(op, t)) {
-				expression_error(expr, "bad restricted assignment");
+				warning(expr->pos, "bad assignment (%s) to %s",
+					show_special(op), show_typename(t));
+				expr->right = cast_to(expr->right, target);
 				return 0;
 			}
 			/* allowed assignments unfoul */
@@ -1248,7 +1251,9 @@ static int evaluate_assign_op(struct expression *expr)
 		/* source and target would better be identical restricted */
 		if (t == s)
 			return 1;
-		warning(expr->pos, "invalid restricted assignment");
+		warning(expr->pos, "invalid assignment: %s", show_special(op));
+		info(expr->pos, "   left side has type %s", show_typename(t));
+		info(expr->pos, "   right side has type %s", show_typename(s));
 		expr->right = cast_to(expr->right, target);
 		return 0;
 	}
@@ -1707,10 +1712,8 @@ static struct symbol *evaluate_postop(struct expression *expr)
 		return NULL;
 	}
 
-	if ((class & TYPE_RESTRICT) && restricted_unop(expr->op, &ctype)) {
-		expression_error(expr, "bad operation on restricted");
-		return NULL;
-	}
+	if ((class & TYPE_RESTRICT) && restricted_unop(expr->op, &ctype))
+		return bad_expr_type(expr);
 
 	if (class & TYPE_NUM) {
 		multiply = 1;
@@ -1799,7 +1802,8 @@ static struct symbol *evaluate_preop(struct expression *expr)
 			expr->right->ctype = ctype;
 			expr->right->fvalue = 0;
 		} else if (is_fouled_type(ctype)) {
-			warning(expr->pos, "restricted degrades to integer");
+			warning(expr->pos, "%sdegrades to integer",
+				show_typename(ctype->ctype.base_type));
 		}
 		ctype = &bool_ctype;
 		break;
@@ -2664,9 +2668,11 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 	if (t1 != t2) {
 		if (class1 & TYPE_RESTRICT)
-			warning(expr->pos, "cast to restricted type");
+			warning(expr->pos, "cast to %s",
+				show_typename(t1));
 		if (class2 & TYPE_RESTRICT)
-			warning(expr->pos, "cast from restricted type");
+			warning(expr->pos, "cast from %s",
+				show_typename(t2));
 	}
 
 	if (t1 == &ulong_ctype)
@@ -3246,9 +3252,10 @@ static void check_case_type(struct expression *switch_expr,
 		return;
 
 	if (!restricted_binop_type(SPECIAL_EQUAL, case_expr, switch_expr,
-				   cclass, sclass, case_type, switch_type))
-		warning(case_expr->pos, "restricted degrades to integer");
-
+				   cclass, sclass, case_type, switch_type)) {
+		unrestrict(case_expr, cclass, &case_type);
+		unrestrict(switch_expr, sclass, &switch_type);
+	}
 	return;
 
 Bad:
diff --git a/parse.c b/parse.c
index a41939d..6255737 100644
--- a/parse.c
+++ b/parse.c
@@ -2158,8 +2158,15 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	base_type = decl->ctype.base_type;
 
 	if (is_typedef) {
-		if (base_type && !base_type->ident)
-			base_type->ident = ident;
+		if (base_type && !base_type->ident) {
+			switch (base_type->type) {
+			case SYM_STRUCT:
+			case SYM_UNION:
+			case SYM_ENUM:
+			case SYM_RESTRICT:
+				base_type->ident = ident;
+			}
+		}
 	} else if (base_type && base_type->type == SYM_FN) {
 		/* K&R argument declaration? */
 		if (lookup_type(token))
diff --git a/show-parse.c b/show-parse.c
index 9a1f796..b9a2828 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -309,6 +309,10 @@ static void do_show_type(struct symbol *sym, struct type_name *name,
 		break;
 
 	case SYM_RESTRICT:
+		if (sym->ident) {
+			prepend(name, "restricted %s ", show_ident(sym->ident));
+			return;
+		}
 		break;
 
 	case SYM_FOULED:
-- 
1.5.3.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] saner warnings for restricted types
Date: Tue, 15 Jan 2008 18:58:56 +0000
Message-ID: <20080115185856.GT27894 () ZenIV ! linux ! org ! uk>
--------------------
On Tue, Jan 15, 2008 at 12:36:12PM -0500, Pavel Roskin wrote:
> On Tue, 2008-01-15 at 16:52 +0000, Al Viro wrote:
> >  	if (class & TYPE_RESTRICT) {
> > -		warning(expr->pos, "restricted degrades to integer");
> >  		if (class & TYPE_FOULED)
> >  			*ctype = unfoul(*ctype);
> > +		warning(expr->pos, "%sdegrades to integer",
> > +			show_typename(*ctype));
> 
> Missing space after "%s"?

No.  Try it and you'll see...  The way show_typename() (actually, the
stuff behind it) works you get a space after the damn thing.  What you'll
get is something like

kernel/power/main.c:242:2: warning: restricted suspend_state_t degrades to integer

Actually, if you look at the things like

fs/afs/fsclient.c:465:21: warning: incorrect type in assignment (different base types)
fs/afs/fsclient.c:465:21:    expected restricted __be32 [usertype] operation_ID
fs/afs/fsclient.c:465:21:    got int

you'll see that the last line is "fs/afs/fsclient.c:465:21:    got int \n" -
with whitespace in the end.  We could get rid of that, but it'll take more
massage and it's definitely a separate patch series.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] saner warnings for restricted types
Date: Tue, 15 Jan 2008 23:14:28 +0000
Message-ID: <20080115231428.GV27894 () ZenIV ! linux ! org ! uk>
--------------------
On Tue, Jan 15, 2008 at 06:58:56PM +0000, Al Viro wrote:
> with whitespace in the end.  We could get rid of that, but it'll take more
> massage and it's definitely a separate patch series.

Whee...

; cat >foo.c <<'EOF'
int a[2][3];
EOF
; test-parsing foo.c
foo.c:1:5: warning: symbol 'a' was not declared. Should it be static?
.align 4
int [addressable] [toplevel] a[3][2]
;

See that [3][2]?  IOW, show_typename() really needs fixing.  Oh, well...

The problem is that append() part should go *before* recursive call, not
after it.  We want appended stuff from the outer levels closer to the
center (i.e. to the name if it's present).  Anyway, the fix follows:

[PATCH] fix show_typename()

* postfix stuff had been added in the wrong order (e.g. int a[2][3] generated
int [addressable][toplevel] a[3][2])
* after fixing that, we've no need for recursion anymore, a bunch of arguments
go away and turn into local variables and we get an easy way to get rid of
bogus space in the show_typename() result.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c   |    4 +-
 show-parse.c |  100 +++++++++++++++++++++++++++++----------------------------
 2 files changed, 53 insertions(+), 51 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 777f603..2901c1b 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -502,7 +502,7 @@ static inline void unrestrict(struct expression *expr,
 	if (class & TYPE_RESTRICT) {
 		if (class & TYPE_FOULED)
 			*ctype = unfoul(*ctype);
-		warning(expr->pos, "%sdegrades to integer",
+		warning(expr->pos, "%s degrades to integer",
 			show_typename(*ctype));
 		*ctype = (*ctype)->ctype.base_type; /* get to arithmetic type */
 	}
@@ -1802,7 +1802,7 @@ static struct symbol *evaluate_preop(struct expression *expr)
 			expr->right->ctype = ctype;
 			expr->right->fvalue = 0;
 		} else if (is_fouled_type(ctype)) {
-			warning(expr->pos, "%sdegrades to integer",
+			warning(expr->pos, "%s degrades to integer",
 				show_typename(ctype->ctype.base_type));
 		}
 		ctype = &bool_ctype;
diff --git a/show-parse.c b/show-parse.c
index b9a2828..064af32 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -226,12 +226,16 @@ const char *builtin_ctypename(struct ctype *ctype)
 	return NULL;
 }
 
-static void do_show_type(struct symbol *sym, struct type_name *name,
-			 unsigned long mod, int as, int was_ptr)
+static void do_show_type(struct symbol *sym, struct type_name *name)
 {
 	const char *typename;
-	int is_ptr = was_ptr;
+	unsigned long mod = 0;
+	int as = 0;
+	int was_ptr = 0;
+	int restr = 0;
+	int fouled = 0;
 
+deeper:
 	if (!sym || (sym->type != SYM_NODE && sym->type != SYM_ARRAY &&
 		     sym->type != SYM_BITFIELD)) {
 		const char *s;
@@ -249,14 +253,15 @@ static void do_show_type(struct symbol *sym, struct type_name *name,
 	}
 
 	if (!sym)
-		return;
+		goto out;
 
 	if ((typename = builtin_typename(sym))) {
 		int len = strlen(typename);
-		*--name->start = ' ';
+		if (name->start != name->end)
+			*--name->start = ' ';
 		name->start -= len;
 		memcpy(name->start, typename, len);
-		return;
+		goto out;
 	}
 
 	/* Prepend */
@@ -265,20 +270,29 @@ static void do_show_type(struct symbol *sym, struct type_name *name,
 		prepend(name, "*");
 		mod = sym->ctype.modifiers;
 		as = sym->ctype.as;
-		is_ptr = 1;
+		was_ptr = 1;
 		break;
+
 	case SYM_FN:
-		if (was_ptr)
+		if (was_ptr) {
 			prepend(name, "( ");
-		is_ptr = 0;
+			append(name, " )");
+			was_ptr = 0;
+		}
+		append(name, "( ... )");
 		break;
+
 	case SYM_STRUCT:
-		prepend(name, "struct %s ", show_ident(sym->ident));
-		return;
+		if (name->start != name->end)
+			*--name->start = ' ';
+		prepend(name, "struct %s", show_ident(sym->ident));
+		goto out;
 
 	case SYM_UNION:
-		prepend(name, "union %s ", show_ident(sym->ident));
-		return;
+		if (name->start != name->end)
+			*--name->start = ' ';
+		prepend(name, "union %s", show_ident(sym->ident));
+		goto out;
 
 	case SYM_ENUM:
 		prepend(name, "enum %s ", show_ident(sym->ident));
@@ -298,60 +312,48 @@ static void do_show_type(struct symbol *sym, struct type_name *name,
 
 	case SYM_LABEL:
 		append(name, "label(%s:%p)", show_ident(sym->ident), sym);
-		break;
+		return;
 
 	case SYM_ARRAY:
 		mod |= sym->ctype.modifiers;
 		as |= sym->ctype.as;
-		if (was_ptr)
+		if (was_ptr) {
 			prepend(name, "( ");
-		is_ptr = 0;
+			append(name, " )");
+			was_ptr = 0;
+		}
+		append(name, "[%lld]", get_expression_value(sym->array_size));
 		break;
 
 	case SYM_RESTRICT:
-		if (sym->ident) {
-			prepend(name, "restricted %s ", show_ident(sym->ident));
-			return;
+		if (!sym->ident) {
+			restr = 1;
+			break;
 		}
-		break;
+		if (name->start != name->end)
+			*--name->start = ' ';
+		prepend(name, "restricted %s", show_ident(sym->ident));
+		goto out;
 
 	case SYM_FOULED:
+		fouled = 1;
 		break;
 
 	default:
+		if (name->start != name->end)
+			*--name->start = ' ';
 		prepend(name, "unknown type %d", sym->type);
-		return;
+		goto out;
 	}
 
-	do_show_type(sym->ctype.base_type, name, mod, as, is_ptr);
-
-	switch (sym->type) {
-	case SYM_PTR:
-		return;
-
-	case SYM_FN:
-		if (was_ptr)
-			append(name, " )");
-		append(name, "( ... )");
-		return;
-
-	case SYM_ARRAY:
-		if (was_ptr)
-			append(name, " )");
-		append(name, "[%lld]", get_expression_value(sym->array_size));
-		return;
+	sym = sym->ctype.base_type;
+	goto deeper;
 
-	case SYM_RESTRICT:
+out:
+	if (restr)
 		prepend(name, "restricted ");
-		return;
-
-	case SYM_FOULED:
+	if (fouled)
 		prepend(name, "fouled ");
-		return;
-
-	default:
-		break;
-	}
 }
 
 void show_type(struct symbol *sym)
@@ -360,7 +362,7 @@ void show_type(struct symbol *sym)
 	struct type_name name;
 
 	name.start = name.end = array+100;
-	do_show_type(sym, &name, 0, 0, 0);
+	do_show_type(sym, &name);
 	*name.end = 0;
 	printf("%s", name.start);
 }
@@ -371,7 +373,7 @@ const char *show_typename(struct symbol *sym)
 	struct type_name name;
 
 	name.start = name.end = array+100;
-	do_show_type(sym, &name, 0, 0, 0);
+	do_show_type(sym, &name);
 	*name.end = 0;
 	return name.start;
 }
-- 
1.5.3.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: Increase pre_buffer[] and check overflow ===

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-mips
Subject: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Tue, 08 Jul 2008 15:28:05 +0000
Message-ID: <20080709.002805.128619748.anemo () mba ! ocn ! ne ! jp>
--------------------
I got this error when running sparse on mips kernel with gcc 4.3:

builtin:272:1: warning: Newline in string or character constant

The linus-mips kernel uses '$(CC) -dM -E' to generates arguments for
sparse.  With gcc 4.3, it generates lot of '-D' options and causes
pre_buffer overflow.

This patch increase pre_buffer[] size and add extra checking for
overflow instead of silently truncating.

Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
---
diff --git a/lib.c b/lib.c
index 0abcc9a..b8b2d57 100644
--- a/lib.c
+++ b/lib.c
@@ -186,7 +186,7 @@ void die(const char *fmt, ...)
 }
 
 static unsigned int pre_buffer_size;
-static char pre_buffer[8192];
+static char pre_buffer[16384];
 
 int Waddress_space = 1;
 int Wbitwise = 0;
@@ -238,6 +238,8 @@ void add_pre_buffer(const char *fmt, ...)
 		fmt, args);
 	pre_buffer_size = size;
 	va_end(args);
+	if (pre_buffer_size >= sizeof(pre_buffer) - 1)
+		die("pre_buffer overflow");
 }
 
 static char **handle_switch_D(char *arg, char **next)

================================================================================

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-sparse
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Tue, 08 Jul 2008 15:59:53 +0000
Message-ID: <20080709.005953.26097194.anemo () mba ! ocn ! ne ! jp>
--------------------
On Wed, 09 Jul 2008 00:28:05 +0900 (JST), Atsushi Nemoto <anemo@mba.ocn.ne.jp> wrote:
> The linus-mips kernel uses '$(CC) -dM -E' to generates arguments for
> sparse.  With gcc 4.3, it generates lot of '-D' options and causes
> pre_buffer overflow.

Here is an example of sparse commandline:

sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise
-D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__SFRACT_IBIT__='0'
-D__FLT_MIN__='1.17549435e-38F' -D__UFRACT_MAX__='0XFFFFP-16UR'
-D__DEC64_DEN__='0.000000000000001E-383DD' -D__DQ_FBIT__='63'
-D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK'
-D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__ACCUM_FBIT__='15'
-DR3000='1' -D__USFRACT_FBIT__='8'
-D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR'
-D__WCHAR_MAX__='2147483647' -D__LACCUM_IBIT__='32'
-D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1'
-D__DBL_DENORM_MIN__='4.9406564584124654e-324'
-D__FLT_EVAL_METHOD__='0' -D__unix__='1'
-D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__FRACT_FBIT__='15'
-D_MIPS_ISA='_MIPS_ISA_MIPS32' -D__UACCUM_FBIT__='16'
-D__LANGUAGE_C='1' -D__DBL_MIN_10_EXP__='(-307)'
-D__FINITE_MATH_ONLY__='0' -D_MIPS_TUNE='"mips32r2"'
-D__LFRACT_IBIT__='0' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR'
-D__DEC64_MAX_EXP__='384' -D_ABIO32='1' -D__SA_FBIT__='15'
-D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L'
-D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16'
-D__UFRACT_MIN__='0.0UR' -D__LANGUAGE_C__='1' -D__UINTMAX_TYPE__='long
long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1'
-D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1'
-D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64'
-D__LDBL_MAX_EXP__='1024' -D__MIPSEL__='1' -D__linux__='1'
-D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15'
-D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SQ_FBIT__='31'
-D__SIZEOF_POINTER__='4' -D__USACCUM_IBIT__='8'
-D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='0'
-D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)'
-D__mips_fpr='32' -D__HA_IBIT__='8' -D__TQ_IBIT__='0'
-D__FLT_EPSILON__='1.19209290e-7F' -D__mips__='1'
-D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L'
-D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF'
-D__DA_IBIT__='32' -DMIPSEL='1' -D__UQQ_FBIT__='8'
-D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK'
-D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR'
-D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1'
-D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32'
-D__UACCUM_EPSILON__='0x1P-16UK'
-D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__HQ_IBIT__='0'
-D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D_R3000='1'
-D__DQ_IBIT__='0' -D__DBL_MAX__='1.7976931348623157e+308'
-D__ULFRACT_IBIT__='0' -D__DBL_HAS_INFINITY__='1'
-D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-95)'
-D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__LDBL_HAS_DENORM__='1'
-D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL'
-D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K'
-D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK'
-D__R3000__='1' -D__DEC128_EPSILON__='1E-33DL'
-D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0'
-D__UACCUM_MIN__='0.0UK' -Dmips='1' -D__UACCUM_IBIT__='16'
-D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4'
-D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4'
-D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK'
-D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64'
-D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR'
-D__UFRACT_IBIT__='0' -D_MIPSEL='1'
-D__DBL_MIN__='2.2250738585072014e-308' -D_MIPS_ARCH='"mips32r2"'
-D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32'
-D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL'
-D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1'
-D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0'
-D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__R3000='1'
-D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.3.1"'
-D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R'
-D__ULACCUM_MIN__='0.0ULK' -D__UDA_FBIT__='32'
-D__LLACCUM_EPSILON__='0x1P-31LLK' -D_MIPS_TUNE_MIPS32R2='1'
-D__USFRACT_MIN__='0.0UHR' -D__UQQ_IBIT__='0'
-D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6143)'
-D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -Dunix='1'
-D__SIZE_TYPE__='unsigned int' -D__UDQ_FBIT__='64'
-D__DEC32_DEN__='0.000001E-95DF' -D__ELF__='1' -D__mips_isa_rev='2'
-D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63'
-D__FLT_RADIX__='2' -D__LDBL_EPSILON__='2.2204460492503131e-16L'
-D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIZEOF_PTRDIFF_T__='4'
-D__LACCUM_EPSILON__='0x1P-31LK' -D_MIPS_SZPTR='32'
-D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR'
-D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38'
-D__LONG_MAX__='2147483647L' -D__FLT_HAS_INFINITY__='1'
-D__USA_FBIT__='16' -D__DEC64_MAX__='9.999999999999999E384DD'
-D__DEC64_MANT_DIG__='16' -D__SACCUM_FBIT__='7' -D_mips='1'
-D__SIZEOF_INT__='4' -D__DEC32_MAX_EXP__='96' -D__QQ_FBIT__='7'
-Dlinux='1'
-D__DEC128_DEN__='0.000000000000000000000000000000001E-6143DL'
-D__UTA_IBIT__='64' -D_MIPS_SZINT='32' -D__LDBL_MANT_DIG__='53'
-D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)'
-D__DBL_HAS_QUIET_NAN__='1' -D__MIPSEL='1' -D__WCHAR_TYPE__='int'
-D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32'
-D__DEC64_MIN_EXP__='(-383)' -D__ULLACCUM_IBIT__='32'
-D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31'
-D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__FLT_MAX_EXP__='128'
-D__UTQ_IBIT__='0' -D_MIPS_SIM='_ABIO32' -D__DBL_MANT_DIG__='53'
-D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int'
-D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0'
-D__LDBL_MIN_EXP__='(-1021)' -D_MIPS_FPSET='16' -D__UDA_IBIT__='32'
-D__LFRACT_FBIT__='31' -D__LDBL_MAX_10_EXP__='308'
-D__DBL_EPSILON__='2.2204460492503131e-16' -D__SIZEOF_WCHAR_T__='4'
-D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127'
-D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0'
-D__LLACCUM_IBIT__='32' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63'
-D_MIPS_ARCH_MIPS32R2='1' -D__mips_soft_float='1' -D__UDQ_IBIT__='0'
-D__ACCUM_EPSILON__='0x1P-15K'
-D__INTMAX_MAX__='9223372036854775807LL'
-D__FLT_DENORM_MIN__='1.40129846e-45F' -D__LLFRACT_IBIT__='0'
-DVMLINUX_LOAD_ADDRESS='0xffffffff80100000'
-D__FLT_MAX__='3.40282347e+38F' -DLANGUAGE_C='1'
-D__USACCUM_FBIT__='8' -D__SIZEOF_DOUBLE__='8'
-D__FLT_MIN_10_EXP__='(-37)' -D__UFRACT_EPSILON__='0x1P-16UR'
-D__INTMAX_TYPE__='long long int' -D_LANGUAGE_C='1'
-D__DEC128_MAX_EXP__='6144' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7'
-D__DBL_MAX_10_EXP__='308'
-D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__STDC__='1'
-D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)'
-D__mips='32' -D__DA_FBIT__='31' -D_MIPS_SZLONG='32'
-D__USA_IBIT__='16' -D__DEC128_MANT_DIG__='34'
-D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8'
-D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8'
-D__LDBL_DIG__='15' -D__GNUC_GNU_INLINE__='1'
-D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32'
-D__QQ_IBIT__='0' -nostdinc -isystem
/usr/lib/gcc/mipsel-linux/4.3.1/include -Wp,-MD,init/.main.o.d
-nostdinc -isystem /usr/lib/gcc/mipsel-linux/4.3.1/include
-D__KERNEL__ -Iinclude -Iinclude2 -I/home/git/linux-mips/include
-include include/linux/autoconf.h -I/home/git/linux-mips/init -Iinit
-Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing
-fno-common -Werror-implicit-function-declaration -O2
-fno-stack-protector -mabi=32 -G 0 -mno-abicalls -fno-pic -pipe
-msoft-float -ffreestanding -march=mips32r2 -Wa,-mips32r2 -Wa,--trap
-I/home/git/linux-mips/include/asm-mips/mach-mips
-Iinclude/asm-mips/mach-mips
-I/home/git/linux-mips/include/asm-mips/mach-generic
-Iinclude/asm-mips/mach-generic
-D"VMLINUX_LOAD_ADDRESS=0xffffffff80100000" -fomit-frame-pointer
-Wdeclaration-after-statement -Wno-pointer-sign -D"KBUILD_STR(s)=#s"
-D"KBUILD_BASENAME=KBUILD_STR(main)"
-D"KBUILD_MODNAME=KBUILD_STR(main)" /home/git/linux-mips/init/main.c ;


Many of them are not required for kernel build.  So another workaround
might be filtering some patterns out on kernel side.  Something like
this:

diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index ad36c94..4ffa809 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -641,6 +641,9 @@ LDFLAGS			+= -m $(ld-emul)
 ifdef CONFIG_MIPS
 CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -xc /dev/null | \
 	egrep -vw '__GNUC_(|MINOR_|PATCHLEVEL_)_' | \
+	egrep -vw '__(FLT|DBL|LDBL)_[A-Z_0-9]+__' | \
+	egrep -vw '__[A-Z]*(ACCUM|FRACT)_[A-Z_0-9]+__' | \
+	egrep -vw '__DEC[0-9]+_[A-Z_0-9]+__' | \
 	sed -e 's/^\#define /-D/' -e "s/ /='/" -e "s/$$/'/")
 ifdef CONFIG_64BIT
 CHECKFLAGS		+= -m64
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-mips
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Tue, 08 Jul 2008 15:59:53 +0000
Message-ID: <20080709.005953.26097194.anemo () mba ! ocn ! ne ! jp>
--------------------
On Wed, 09 Jul 2008 00:28:05 +0900 (JST), Atsushi Nemoto <anemo@mba.ocn.ne.jp> wrote:
> The linus-mips kernel uses '$(CC) -dM -E' to generates arguments for
> sparse.  With gcc 4.3, it generates lot of '-D' options and causes
> pre_buffer overflow.

Here is an example of sparse commandline:

sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise
-D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__SFRACT_IBIT__='0'
-D__FLT_MIN__='1.17549435e-38F' -D__UFRACT_MAX__='0XFFFFP-16UR'
-D__DEC64_DEN__='0.000000000000001E-383DD' -D__DQ_FBIT__='63'
-D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK'
-D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__ACCUM_FBIT__='15'
-DR3000='1' -D__USFRACT_FBIT__='8'
-D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR'
-D__WCHAR_MAX__='2147483647' -D__LACCUM_IBIT__='32'
-D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1'
-D__DBL_DENORM_MIN__='4.9406564584124654e-324'
-D__FLT_EVAL_METHOD__='0' -D__unix__='1'
-D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__FRACT_FBIT__='15'
-D_MIPS_ISA='_MIPS_ISA_MIPS32' -D__UACCUM_FBIT__='16'
-D__LANGUAGE_C='1' -D__DBL_MIN_10_EXP__='(-307)'
-D__FINITE_MATH_ONLY__='0' -D_MIPS_TUNE='"mips32r2"'
-D__LFRACT_IBIT__='0' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR'
-D__DEC64_MAX_EXP__='384' -D_ABIO32='1' -D__SA_FBIT__='15'
-D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L'
-D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16'
-D__UFRACT_MIN__='0.0UR' -D__LANGUAGE_C__='1' -D__UINTMAX_TYPE__='long
long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1'
-D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1'
-D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64'
-D__LDBL_MAX_EXP__='1024' -D__MIPSEL__='1' -D__linux__='1'
-D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15'
-D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SQ_FBIT__='31'
-D__SIZEOF_POINTER__='4' -D__USACCUM_IBIT__='8'
-D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='0'
-D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)'
-D__mips_fpr='32' -D__HA_IBIT__='8' -D__TQ_IBIT__='0'
-D__FLT_EPSILON__='1.19209290e-7F' -D__mips__='1'
-D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L'
-D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF'
-D__DA_IBIT__='32' -DMIPSEL='1' -D__UQQ_FBIT__='8'
-D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK'
-D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR'
-D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1'
-D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32'
-D__UACCUM_EPSILON__='0x1P-16UK'
-D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__HQ_IBIT__='0'
-D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D_R3000='1'
-D__DQ_IBIT__='0' -D__DBL_MAX__='1.7976931348623157e+308'
-D__ULFRACT_IBIT__='0' -D__DBL_HAS_INFINITY__='1'
-D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-95)'
-D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__LDBL_HAS_DENORM__='1'
-D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL'
-D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K'
-D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK'
-D__R3000__='1' -D__DEC128_EPSILON__='1E-33DL'
-D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0'
-D__UACCUM_MIN__='0.0UK' -Dmips='1' -D__UACCUM_IBIT__='16'
-D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4'
-D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4'
-D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK'
-D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64'
-D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR'
-D__UFRACT_IBIT__='0' -D_MIPSEL='1'
-D__DBL_MIN__='2.2250738585072014e-308' -D_MIPS_ARCH='"mips32r2"'
-D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32'
-D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL'
-D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1'
-D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0'
-D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__R3000='1'
-D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.3.1"'
-D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R'
-D__ULACCUM_MIN__='0.0ULK' -D__UDA_FBIT__='32'
-D__LLACCUM_EPSILON__='0x1P-31LLK' -D_MIPS_TUNE_MIPS32R2='1'
-D__USFRACT_MIN__='0.0UHR' -D__UQQ_IBIT__='0'
-D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6143)'
-D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -Dunix='1'
-D__SIZE_TYPE__='unsigned int' -D__UDQ_FBIT__='64'
-D__DEC32_DEN__='0.000001E-95DF' -D__ELF__='1' -D__mips_isa_rev='2'
-D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63'
-D__FLT_RADIX__='2' -D__LDBL_EPSILON__='2.2204460492503131e-16L'
-D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIZEOF_PTRDIFF_T__='4'
-D__LACCUM_EPSILON__='0x1P-31LK' -D_MIPS_SZPTR='32'
-D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR'
-D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38'
-D__LONG_MAX__='2147483647L' -D__FLT_HAS_INFINITY__='1'
-D__USA_FBIT__='16' -D__DEC64_MAX__='9.999999999999999E384DD'
-D__DEC64_MANT_DIG__='16' -D__SACCUM_FBIT__='7' -D_mips='1'
-D__SIZEOF_INT__='4' -D__DEC32_MAX_EXP__='96' -D__QQ_FBIT__='7'
-Dlinux='1'
-D__DEC128_DEN__='0.000000000000000000000000000000001E-6143DL'
-D__UTA_IBIT__='64' -D_MIPS_SZINT='32' -D__LDBL_MANT_DIG__='53'
-D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)'
-D__DBL_HAS_QUIET_NAN__='1' -D__MIPSEL='1' -D__WCHAR_TYPE__='int'
-D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32'
-D__DEC64_MIN_EXP__='(-383)' -D__ULLACCUM_IBIT__='32'
-D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31'
-D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__FLT_MAX_EXP__='128'
-D__UTQ_IBIT__='0' -D_MIPS_SIM='_ABIO32' -D__DBL_MANT_DIG__='53'
-D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int'
-D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0'
-D__LDBL_MIN_EXP__='(-1021)' -D_MIPS_FPSET='16' -D__UDA_IBIT__='32'
-D__LFRACT_FBIT__='31' -D__LDBL_MAX_10_EXP__='308'
-D__DBL_EPSILON__='2.2204460492503131e-16' -D__SIZEOF_WCHAR_T__='4'
-D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127'
-D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0'
-D__LLACCUM_IBIT__='32' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63'
-D_MIPS_ARCH_MIPS32R2='1' -D__mips_soft_float='1' -D__UDQ_IBIT__='0'
-D__ACCUM_EPSILON__='0x1P-15K'
-D__INTMAX_MAX__='9223372036854775807LL'
-D__FLT_DENORM_MIN__='1.40129846e-45F' -D__LLFRACT_IBIT__='0'
-DVMLINUX_LOAD_ADDRESS='0xffffffff80100000'
-D__FLT_MAX__='3.40282347e+38F' -DLANGUAGE_C='1'
-D__USACCUM_FBIT__='8' -D__SIZEOF_DOUBLE__='8'
-D__FLT_MIN_10_EXP__='(-37)' -D__UFRACT_EPSILON__='0x1P-16UR'
-D__INTMAX_TYPE__='long long int' -D_LANGUAGE_C='1'
-D__DEC128_MAX_EXP__='6144' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7'
-D__DBL_MAX_10_EXP__='308'
-D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__STDC__='1'
-D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)'
-D__mips='32' -D__DA_FBIT__='31' -D_MIPS_SZLONG='32'
-D__USA_IBIT__='16' -D__DEC128_MANT_DIG__='34'
-D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8'
-D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8'
-D__LDBL_DIG__='15' -D__GNUC_GNU_INLINE__='1'
-D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32'
-D__QQ_IBIT__='0' -nostdinc -isystem
/usr/lib/gcc/mipsel-linux/4.3.1/include -Wp,-MD,init/.main.o.d
-nostdinc -isystem /usr/lib/gcc/mipsel-linux/4.3.1/include
-D__KERNEL__ -Iinclude -Iinclude2 -I/home/git/linux-mips/include
-include include/linux/autoconf.h -I/home/git/linux-mips/init -Iinit
-Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing
-fno-common -Werror-implicit-function-declaration -O2
-fno-stack-protector -mabi=32 -G 0 -mno-abicalls -fno-pic -pipe
-msoft-float -ffreestanding -march=mips32r2 -Wa,-mips32r2 -Wa,--trap
-I/home/git/linux-mips/include/asm-mips/mach-mips
-Iinclude/asm-mips/mach-mips
-I/home/git/linux-mips/include/asm-mips/mach-generic
-Iinclude/asm-mips/mach-generic
-D"VMLINUX_LOAD_ADDRESS=0xffffffff80100000" -fomit-frame-pointer
-Wdeclaration-after-statement -Wno-pointer-sign -D"KBUILD_STR(s)=#s"
-D"KBUILD_BASENAME=KBUILD_STR(main)"
-D"KBUILD_MODNAME=KBUILD_STR(main)" /home/git/linux-mips/init/main.c ;


Many of them are not required for kernel build.  So another workaround
might be filtering some patterns out on kernel side.  Something like
this:

diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index ad36c94..4ffa809 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -641,6 +641,9 @@ LDFLAGS			+= -m $(ld-emul)
 ifdef CONFIG_MIPS
 CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -xc /dev/null | \
 	egrep -vw '__GNUC_(|MINOR_|PATCHLEVEL_)_' | \
+	egrep -vw '__(FLT|DBL|LDBL)_[A-Z_0-9]+__' | \
+	egrep -vw '__[A-Z]*(ACCUM|FRACT)_[A-Z_0-9]+__' | \
+	egrep -vw '__DEC[0-9]+_[A-Z_0-9]+__' | \
 	sed -e 's/^\#define /-D/' -e "s/ /='/" -e "s/$$/'/")
 ifdef CONFIG_64BIT
 CHECKFLAGS		+= -m64

================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Tue, 08 Jul 2008 20:45:47 +0000
Message-ID: <20080708204547.GA16742 () uranus ! ravnborg ! org>
--------------------
On Wed, Jul 09, 2008 at 12:28:05AM +0900, Atsushi Nemoto wrote:
> I got this error when running sparse on mips kernel with gcc 4.3:
> 
> builtin:272:1: warning: Newline in string or character constant
> 
> The linus-mips kernel uses '$(CC) -dM -E' to generates arguments for
> sparse.  With gcc 4.3, it generates lot of '-D' options and causes
> pre_buffer overflow.

Why does mips have this need when all other archs does not?
We should fix sparse so it is dynamically allocated - but
that is not an excuse for mips to use odd stuff like this.

So please someone from mips land explain why this is needed.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-sparse
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Wed, 09 Jul 2008 16:18:18 +0000
Message-ID: <20080710.011818.26096759.anemo () mba ! ocn ! ne ! jp>
--------------------
On Tue, 8 Jul 2008 22:45:47 +0200, Sam Ravnborg <sam@ravnborg.org> wrote:
> > The linus-mips kernel uses '$(CC) -dM -E' to generates arguments for
> > sparse.  With gcc 4.3, it generates lot of '-D' options and causes
> > pre_buffer overflow.
> 
> Why does mips have this need when all other archs does not?
> We should fix sparse so it is dynamically allocated - but
> that is not an excuse for mips to use odd stuff like this.
> 
> So please someone from mips land explain why this is needed.

This was introduced by commit 59b3e8e9aac69d2d02853acac7e2affdfbabca50.
("[MIPS] Makefile crapectomy.")

Before the commit, CHECKFLAGS was adjusted like this:

CHECKFLAGS-y				+= -D__linux__ -D__mips__ \
					   -D_MIPS_SZINT=32 \
					   -D_ABIO32=1 \
					   -D_ABIN32=2 \
					   -D_ABI64=3
CHECKFLAGS-$(CONFIG_32BIT)		+= -D_MIPS_SIM=_ABIO32 \
					   -D_MIPS_SZLONG=32 \
					   -D_MIPS_SZPTR=32 \
					   -D__PTRDIFF_TYPE__=int
CHECKFLAGS-$(CONFIG_64BIT)		+= -m64 -D_MIPS_SIM=_ABI64 \
					   -D_MIPS_SZLONG=64 \
					   -D_MIPS_SZPTR=64 \
					   -D__PTRDIFF_TYPE__="long int"
CHECKFLAGS-$(CONFIG_CPU_BIG_ENDIAN)	+= -D__MIPSEB__
CHECKFLAGS-$(CONFIG_CPU_LITTLE_ENDIAN)	+= -D__MIPSEL__
CHECKFLAGS				= $(CHECKFLAGS-y)
CHECKFLAGS-$(CONFIG_CPU_R3000)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS1
CHECKFLAGS-$(CONFIG_CPU_TX39XX)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS1
CHECKFLAGS-$(CONFIG_CPU_R6000)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS2
CHECKFLAGS-$(CONFIG_CPU_R4300)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS3
CHECKFLAGS-$(CONFIG_CPU_VR41XX)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS3
CHECKFLAGS-$(CONFIG_CPU_R4X00)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS3
CHECKFLAGS-$(CONFIG_CPU_TX49XX)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS3
CHECKFLAGS-$(CONFIG_CPU_MIPS32_R1)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS32
CHECKFLAGS-$(CONFIG_CPU_MIPS32_R2)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS32
CHECKFLAGS-$(CONFIG_CPU_MIPS64_R1)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS64
CHECKFLAGS-$(CONFIG_CPU_MIPS64_R2)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS64
CHECKFLAGS-$(CONFIG_CPU_R5000)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS4
CHECKFLAGS-$(CONFIG_CPU_R5432)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS4
CHECKFLAGS-$(CONFIG_CPU_NEVADA)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS4
CHECKFLAGS-$(CONFIG_CPU_RM7000)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS4
CHECKFLAGS-$(CONFIG_CPU_RM9000)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS4
CHECKFLAGS-$(CONFIG_CPU_SB1)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS64
CHECKFLAGS-$(CONFIG_CPU_R8000)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS4
CHECKFLAGS-$(CONFIG_CPU_R10000)	+= -D_MIPS_ISA=_MIPS_ISA_MIPS4

And now:

CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -xc /dev/null | \
	egrep -vw '__GNUC_(|MINOR_|PATCHLEVEL_)_' | \
	sed -e 's/^\#define /-D/' -e "s/ /='/" -e "s/$$/'/")
ifdef CONFIG_64BIT
CHECKFLAGS		+= -m64
endif

It looks fairly simple, unless you run make C=1 V=1 ...

---
Atsushi Nemoto
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Wed, 09 Jul 2008 16:32:12 +0000
Message-ID: <20080709163212.GA1227 () uranus ! ravnborg ! org>
--------------------
On Thu, Jul 10, 2008 at 01:18:18AM +0900, Atsushi Nemoto wrote:
> On Tue, 8 Jul 2008 22:45:47 +0200, Sam Ravnborg <sam@ravnborg.org> wrote:
> > > The linus-mips kernel uses '$(CC) -dM -E' to generates arguments for
> > > sparse.  With gcc 4.3, it generates lot of '-D' options and causes
> > > pre_buffer overflow.
> > 
> > Why does mips have this need when all other archs does not?
> > We should fix sparse so it is dynamically allocated - but
> > that is not an excuse for mips to use odd stuff like this.
> > 
> > So please someone from mips land explain why this is needed.
> 
> This was introduced by commit 59b3e8e9aac69d2d02853acac7e2affdfbabca50.
> ("[MIPS] Makefile crapectomy.")
> 
> Before the commit, CHECKFLAGS was adjusted like this:
> 
> CHECKFLAGS-y				+= -D__linux__ -D__mips__ \
> 					   -D_MIPS_SZINT=32 \
> 					   -D_ABIO32=1 \
...

So the expalnation seems that gcc for mips define much more
than the usual gcc does.
My gcc define 76 symbols for i386.

And we use this stuff in the kernel.

OK - thanks for the details.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-mips
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Thu, 10 Jul 2008 17:39:45 +0000
Message-ID: <20080710173945.GE28946 () ZenIV ! linux ! org ! uk>
--------------------
On Wed, Jul 09, 2008 at 06:32:12PM +0200, Sam Ravnborg wrote:
> So the expalnation seems that gcc for mips define much more
> than the usual gcc does.
> My gcc define 76 symbols for i386.
> 
> And we use this stuff in the kernel.

How much of it do we really use?  Let's see - on i386 gcc-4.1.2 I see
79 symbols.  64 simply never occur in the tree.  At all.  Out of remaining
15, we have

__GNUC__, __GNUC_MAJOR__, __GNUC_PATCHLEVEL__ - provided by sparse.
__STDC__: few users, provided by sparse.
__SIZE_TYPE__: one odd user, defined by sparse anyway
__PTRDIFF_TYPE__: one odd user, defined by sparse anyway

__linux__ - few users, explicitly added in top-level Makefile
linux - 3 users.  Defined in top-level Makefile.
unix - no real users (some instances, of course, but none outside of comments,
#include pathnames and string constants).  Defined in top-level Makefile,
anyway.

__USER_LABEL_PREFIX__, __REGISTER_PREFIX__ - arch/m68knommu/lib/*.S; not
a sparse fodder anyway *and* defaults are given in files themselves.

__ELF__: arch/alpha/boot/tools/objstrip.c (userland helper, actually, *and*
misplaced there; it's used as a proxy for type of kernel image)

__i386__: a bunch
__i386: one user, redundant (__i386__ *and* i386 in the same #if)
i386: 3 users besides the aforementioned one.

So...  Only 3 symbols out of the entire bunch are arch-dependent *and* not
provided by sparse itself.  Absolute majority of the rest is never ever
used in the tree.

I very much doubt that mips situation is seriously different...

================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Thu, 10 Jul 2008 17:39:45 +0000
Message-ID: <20080710173945.GE28946 () ZenIV ! linux ! org ! uk>
--------------------
On Wed, Jul 09, 2008 at 06:32:12PM +0200, Sam Ravnborg wrote:
> So the expalnation seems that gcc for mips define much more
> than the usual gcc does.
> My gcc define 76 symbols for i386.
> 
> And we use this stuff in the kernel.

How much of it do we really use?  Let's see - on i386 gcc-4.1.2 I see
79 symbols.  64 simply never occur in the tree.  At all.  Out of remaining
15, we have

__GNUC__, __GNUC_MAJOR__, __GNUC_PATCHLEVEL__ - provided by sparse.
__STDC__: few users, provided by sparse.
__SIZE_TYPE__: one odd user, defined by sparse anyway
__PTRDIFF_TYPE__: one odd user, defined by sparse anyway

__linux__ - few users, explicitly added in top-level Makefile
linux - 3 users.  Defined in top-level Makefile.
unix - no real users (some instances, of course, but none outside of comments,
#include pathnames and string constants).  Defined in top-level Makefile,
anyway.

__USER_LABEL_PREFIX__, __REGISTER_PREFIX__ - arch/m68knommu/lib/*.S; not
a sparse fodder anyway *and* defaults are given in files themselves.

__ELF__: arch/alpha/boot/tools/objstrip.c (userland helper, actually, *and*
misplaced there; it's used as a proxy for type of kernel image)

__i386__: a bunch
__i386: one user, redundant (__i386__ *and* i386 in the same #if)
i386: 3 users besides the aforementioned one.

So...  Only 3 symbols out of the entire bunch are arch-dependent *and* not
provided by sparse itself.  Absolute majority of the rest is never ever
used in the tree.

I very much doubt that mips situation is seriously different...
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-mips
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Thu, 10 Jul 2008 17:51:00 +0000
Message-ID: <20080710175100.GF28946 () ZenIV ! linux ! org ! uk>
--------------------
On Wed, Jul 09, 2008 at 12:59:53AM +0900, Atsushi Nemoto wrote:
explicit (and __STDC__ is redundant): -D__linux__ -Dlinux -D__STDC__
-Dunix -D__unix__ -Wbitwise

Not used anywhere in the tree:
-D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__SFRACT_IBIT__='0'
-D__FLT_MIN__='1.17549435e-38F' -D__UFRACT_MAX__='0XFFFFP-16UR'
-D__DEC64_DEN__='0.000000000000001E-383DD' -D__DQ_FBIT__='63'
-D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK'
-D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__ACCUM_FBIT__='15'

Maybe, let me check...  Nope, not used.
> -DR3000='1'

Not used anywhere:
> -D__USFRACT_FBIT__='8'
> -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR'
> -D__WCHAR_MAX__='2147483647' -D__LACCUM_IBIT__='32'
> -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1'
> -D__DBL_DENORM_MIN__='4.9406564584124654e-324'
> -D__FLT_EVAL_METHOD__='0'

Explicitly passed: -D__unix__='1'

Not used:
> -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__FRACT_FBIT__='15'

Used:
-D_MIPS_ISA='_MIPS_ISA_MIPS32'

Not used:
> -D__UACCUM_FBIT__='16'
> -D__LANGUAGE_C='1' -D__DBL_MIN_10_EXP__='(-307)'
> -D__FINITE_MATH_ONLY__='0' -D_MIPS_TUNE='"mips32r2"'
> -D__LFRACT_IBIT__='0' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR'
> -D__DEC64_MAX_EXP__='384' -D_ABIO32='1' -D__SA_FBIT__='15'
> -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L'
> -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16'
> -D__UFRACT_MIN__='0.0UR' -D__LANGUAGE_C__='1'

Not used, might be worth defining in sparse:
-D__UINTMAX_TYPE__='long
> long unsigned int'

Not used:
 -D__LLFRACT_EPSILON__='0x1P-63LLR'

Explicitly passed:
 -D__linux='1'

Not used:
> -D__DEC32_EPSILON__='1E-6DF'

Passed by sparse:
-D__OPTIMIZE__='1'

Explicitly passed: -D__unix='1'

Not used:
> -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64'
> -D__LDBL_MAX_EXP__='1024'

Used: -D__MIPSEL__='1'

Explicitly passed: -D__linux__='1'

[...]

And AFAICS, the ratio gets even worse further into the list...

================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-mips
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Thu, 10 Jul 2008 18:09:37 +0000
Message-ID: <118833cc0807101109m6abcda96w492548d847b1a8c4 () mail ! gmail ! com>
--------------------
> Not used anywhere in the tree:
> -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__SFRACT_IBIT__='0'
> -D__FLT_MIN__='1.17549435e-38F' -D__UFRACT_MAX__='0XFFFFP-16UR'
> -D__DEC64_DEN__='0.000000000000001E-383DD' -D__DQ_FBIT__='63'
> -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK'
> -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__ACCUM_FBIT__='15'

Wrong tree, :-)  Check your equivalent of
/usr/lib64/gcc/x86_64-suse-linux/4.1.0/include/float.h

The kernel probably doesn't care much, but sparse as a general tool
ought to care.

Morten

================================================================================

From: "Morten Welinder" <mwelinder () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Thu, 10 Jul 2008 18:09:37 +0000
Message-ID: <118833cc0807101109m6abcda96w492548d847b1a8c4 () mail ! gmail ! com>
--------------------
> Not used anywhere in the tree:
> -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__SFRACT_IBIT__='0'
> -D__FLT_MIN__='1.17549435e-38F' -D__UFRACT_MAX__='0XFFFFP-16UR'
> -D__DEC64_DEN__='0.000000000000001E-383DD' -D__DQ_FBIT__='63'
> -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK'
> -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__ACCUM_FBIT__='15'

Wrong tree, :-)  Check your equivalent of
/usr/lib64/gcc/x86_64-suse-linux/4.1.0/include/float.h

The kernel probably doesn't care much, but sparse as a general tool
ought to care.

Morten
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-sparse
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Fri, 11 Jul 2008 16:07:21 +0000
Message-ID: <20080712.010721.18574863.anemo () mba ! ocn ! ne ! jp>
--------------------
On Thu, 10 Jul 2008 18:39:45 +0100, Al Viro <viro@ZenIV.linux.org.uk> wrote:
> So...  Only 3 symbols out of the entire bunch are arch-dependent *and* not
> provided by sparse itself.  Absolute majority of the rest is never ever
> used in the tree.
> 
> I very much doubt that mips situation is seriously different...

Then, how about this?  Ralf, is this filter reasonable?


Subject: [PATCH] mips: reduce symbols passed to CHECKFLAGS

Without this patch, gcc 4.3 will produces so many symbols and causes
pre_buffer[] overflow in sparse.

Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
---
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index d319cd6..6c4eb9f 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -619,7 +619,7 @@ LDFLAGS			+= -m $(ld-emul)
 
 ifdef CONFIG_MIPS
 CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -xc /dev/null | \
-	egrep -vw '__GNUC_(|MINOR_|PATCHLEVEL_)_' | \
+	egrep '(MIPS|mips|_ABI|_TYPE__)' | \
 	sed -e 's/^\#define /-D/' -e "s/ /='/" -e "s/$$/'/")
 ifdef CONFIG_64BIT
 CHECKFLAGS		+= -m64
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-mips
Subject: Re: [PATCH] sparse: Increase pre_buffer[] and check overflow
Date: Fri, 11 Jul 2008 16:07:21 +0000
Message-ID: <20080712.010721.18574863.anemo () mba ! ocn ! ne ! jp>
--------------------
On Thu, 10 Jul 2008 18:39:45 +0100, Al Viro <viro@ZenIV.linux.org.uk> wrote:
> So...  Only 3 symbols out of the entire bunch are arch-dependent *and* not
> provided by sparse itself.  Absolute majority of the rest is never ever
> used in the tree.
> 
> I very much doubt that mips situation is seriously different...

Then, how about this?  Ralf, is this filter reasonable?


Subject: [PATCH] mips: reduce symbols passed to CHECKFLAGS

Without this patch, gcc 4.3 will produces so many symbols and causes
pre_buffer[] overflow in sparse.

Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
---
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index d319cd6..6c4eb9f 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -619,7 +619,7 @@ LDFLAGS			+= -m $(ld-emul)
 
 ifdef CONFIG_MIPS
 CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -xc /dev/null | \
-	egrep -vw '__GNUC_(|MINOR_|PATCHLEVEL_)_' | \
+	egrep '(MIPS|mips|_ABI|_TYPE__)' | \
 	sed -e 's/^\#define /-D/' -e "s/ /='/" -e "s/$$/'/")
 ifdef CONFIG_64BIT
 CHECKFLAGS		+= -m64

================================================================================


################################################################################

=== Thread: [PATCH] sparse: Make pre_buffer dynamically increasable ===

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-sparse
Subject: [PATCH] sparse: Make pre_buffer dynamically increasable
Date: Sat, 19 Jul 2008 15:22:24 +0000
Message-ID: <20080720.002224.108306935.anemo () mba ! ocn ! ne ! jp>
--------------------
I got this error when running sparse on mips kernel with gcc 4.3:

builtin:272:1: warning: Newline in string or character constant

The linux-mips kernel uses '$(CC) -dM -E' to generates arguments for
sparse.  With gcc 4.3, it generates lot of '-D' options and causes
pre_buffer overflow.  The linux-mips kernel can filter unused symbols
out to avoid overflow, but sparse should be fixed anyway.

This patch make pre_buffer dynamically increasable and add extra
checking for overflow instead of silently truncating.

Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
---
diff --git a/lib.c b/lib.c
index 0abcc9a..6e8d09b 100644
--- a/lib.c
+++ b/lib.c
@@ -186,7 +186,8 @@ void die(const char *fmt, ...)
 }
 
 static unsigned int pre_buffer_size;
-static char pre_buffer[8192];
+static unsigned int pre_buffer_alloc_size;
+static char *pre_buffer;
 
 int Waddress_space = 1;
 int Wbitwise = 0;
@@ -232,12 +233,20 @@ void add_pre_buffer(const char *fmt, ...)
 	unsigned int size;
 
 	va_start(args, fmt);
+	if (pre_buffer_alloc_size < pre_buffer_size + getpagesize()) {
+		pre_buffer_alloc_size += getpagesize();
+		pre_buffer = realloc(pre_buffer, pre_buffer_alloc_size);
+		if (!pre_buffer)
+			die("Unable to allocate more pre_buffer space");
+	}
 	size = pre_buffer_size;
 	size += vsnprintf(pre_buffer + size,
-		sizeof(pre_buffer) - size,
+		pre_buffer_alloc_size - size,
 		fmt, args);
 	pre_buffer_size = size;
 	va_end(args);
+	if (pre_buffer_size >= pre_buffer_alloc_size - 1)
+		die("pre_buffer overflow");
 }
 
 static char **handle_switch_D(char *arg, char **next)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-sparse
Subject: Re: [PATCH] sparse: Make pre_buffer dynamically increasable
Date: Sun, 14 Sep 2008 12:41:59 +0000
Message-ID: <20080914.214159.128616923.anemo () mba ! ocn ! ne ! jp>
--------------------
On Sat, 13 Sep 2008 10:59:45 -0700, "Christopher Li" <sparse@chrisli.org> wrote:
> The better way is just remove the pre_buffer completely. Just tokenize
> the buffer
> and append the result token on the fly.
> 
> Can you try out the patch I attached? It does just that.

Thanks, it works for me.

---
Atsushi Nemoto
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]: Makefile automatic header dependency ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH]: Makefile automatic header dependency
Date: Thu, 25 Dec 2008 04:04:31 +0000
Message-ID: <70318cbf0812242004v30a91d73x844eca15c2733b20 () mail ! gmail ! com>
--------------------
Hi,

Can some one help me test the c2xml build? I don't
have libxml-2.0 to verify it.

Chris

Makefile automatic header dependency

It use the gcc generated dependency file to track
header file changes.

Use pattern rules to build programs.
Makefile is much shorter now. Easier to add
new objs or new programs.

Singed-Off-By: Christopher Li<sparse@chrisli.org>

Index: sparse.chrisl/Makefile
===================================================================
--- sparse.chrisl.orig/Makefile
+++ sparse.chrisl/Makefile
@@ -8,6 +8,7 @@ CFLAGS = -O2 -finline-functions -fno-str
 CFLAGS += -Wall -Wwrite-strings
 LDFLAGS += -g
 AR = ar
+PROG_LINK_CMD = $(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $^  $($@_EXTRA_OBJS)

 #
 # For debugging, uncomment the next one
@@ -18,6 +19,7 @@ HAVE_LIBXML=$(shell pkg-config --exists


 CFLAGS += -DGCC_BASE=\"$(shell $(CC) --print-file-name=)\"
+CFLAGS += -Wp,-MD,$(@D)/.$(@F).d

 DESTDIR=
 PREFIX=$(HOME)
@@ -28,16 +30,15 @@ MAN1DIR=$(MANDIR)/man1
 INCLUDEDIR=$(PREFIX)/include
 PKGCONFIGDIR=$(LIBDIR)/pkgconfig

-PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse
test-linearize example \
-	 test-unssa test-dissect ctags
-
-
+PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse \
+	 test-linearize example test-unssa test-dissect ctags
 INST_PROGRAMS=sparse cgcc
 INST_MAN1=sparse.1 cgcc.1

 ifeq ($(HAVE_LIBXML),yes)
 PROGRAMS+=c2xml
 INST_PROGRAMS+=c2xml
+c2xml_EXTRA_OBJS = `pkg-config --libs libxml-2.0`
 endif

 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
@@ -98,44 +99,12 @@ install: $(INST_PROGRAMS) $(LIBS) $(LIB_
 sparse.pc: sparse.pc.in
 	$(QUIET_GEN)sed
's|@version@|$(VERSION)|g;s|@prefix@|$(PREFIX)|g;s|@libdir@|$(LIBDIR)|g;s|@includedir@|$(INCLUDEDIR)|g'
sparse.pc.in > sparse.pc

-test-lexing: test-lexing.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-test-parsing: test-parsing.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-test-linearize: test-linearize.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-test-sort: test-sort.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
+	
 compile: compile.o compile-i386.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
-
-obfuscate: obfuscate.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-sparse: sparse.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-graph: graph.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-example: example.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-test-unssa: test-unssa.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-test-dissect: test-dissect.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
-
-ctags: ctags.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(PROG_LINK_CMD)

-c2xml: c2xml.o $(LIBS)
-	$(QUIET_LINK)$(CC) $(LDFLAGS)  -o $@ $< $(LIBS) `pkg-config --libs libxml-2.0`
+%: %.o $(LIBS)
+	$(PROG_LINK_CMD)

 $(LIB_FILE): $(LIB_OBJS)
 	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)
@@ -143,48 +112,13 @@ $(LIB_FILE): $(LIB_OBJS)
 $(SLIB_FILE): $(LIB_OBJS)
 	$(QUIET_LINK)$(CC) $(LDFLAGS) -Wl,-soname,$@ -shared -o $@ $(LIB_OBJS)

-evaluate.o: $(LIB_H)
-expression.o: $(LIB_H)
-lib.o: $(LIB_H)
-allocate.o: $(LIB_H)
-ptrlist.o: $(LIB_H)
-parse.o: $(LIB_H)
-pre-process.o: $(LIB_H)
-scope.o: $(LIB_H)
-show-parse.o: $(LIB_H)
-symbol.o: $(LIB_H)
-expand.o: $(LIB_H)
-linearize.o: $(LIB_H)
-flow.o: $(LIB_H)
-cse.o: $(LIB_H)
-simplify.o: $(LIB_H)
-memops.o: $(LIB_H)
-liveness.o: $(LIB_H)
-sort.o: $(LIB_H)
-inline.o: $(LIB_H)
-target.o: $(LIB_H)
-test-lexing.o: $(LIB_H)
-test-parsing.o: $(LIB_H)
-test-linearize.o: $(LIB_H)
-test-dissect.o: $(LIB_H)
-test-unssa.o: $(LIB_H)
-ctags.o: $(LIB_H)
-compile.o: $(LIB_H) compile.h
-compile-i386.o: $(LIB_H) compile.h
-tokenize.o: $(LIB_H)
-sparse.o: $(LIB_H)
-obfuscate.o: $(LIB_H)
-example.o: $(LIB_H)
-storage.o: $(LIB_H)
-dissect.o: $(LIB_H)
-graph.o: $(LIB_H)
+include $(wildcard .*.o.d)

 c2xml.o: c2xml.c $(LIB_H)
 	$(QUIET_CC)$(CC) `pkg-config --cflags libxml-2.0` -o $@ -c $(CFLAGS) $<

-compat-linux.o: compat/strtold.c compat/mmap-blob.c \
-	$(LIB_H)
-compat-solaris.o: compat/mmap-blob.c $(LIB_H)
+compat-linux.o: compat/strtold.c compat/mmap-blob.c
+compat-solaris.o: compat/mmap-blob.c
 compat-mingw.o: $(LIB_H)
 compat-cygwin.o: $(LIB_H)

@@ -192,7 +126,7 @@ compat-cygwin.o: $(LIB_H)
 	$(QUIET_CC)$(CC) -o $@ -c $(CFLAGS) $<

 clean: clean-check
-	rm -f *.[oa] *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc
+	rm -f *.[oad] *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc

 dist:
 	@if test "`git describe`" != "$(VERSION)" ; then \
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [PATCH]: Makefile automatic header dependency
Date: Thu, 25 Dec 2008 09:30:00 +0000
Message-ID: <20081225093000.GA27896 () uranus ! ravnborg ! org>
--------------------
Hi Chris.

I tried to apply your patch here.
It was word wrapped but that was easy to fix.

A few comments below.

> Singed-Off-By: Christopher Li<sparse@chrisli.org>

s/Singed/Signed/

> Index: sparse.chrisl/Makefile
> ===================================================================
> --- sparse.chrisl.orig/Makefile
> +++ sparse.chrisl/Makefile
> @@ -8,6 +8,7 @@ CFLAGS = -O2 -finline-functions -fno-str
>  CFLAGS += -Wall -Wwrite-strings
>  LDFLAGS += -g
>  AR = ar
> +PROG_LINK_CMD = $(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $^  $($@_EXTRA_OBJS)
> 
>  #
>  # For debugging, uncomment the next one
> @@ -18,6 +19,7 @@ HAVE_LIBXML=$(shell pkg-config --exists
> 
> 
>  CFLAGS += -DGCC_BASE=\"$(shell $(CC) --print-file-name=)\"
> +CFLAGS += -Wp,-MD,$(@D)/.$(@F).d

This works well with gcc - but if we want to build sparse with a wider
set of tool chains then this may fail.

> 
>  DESTDIR=
>  PREFIX=$(HOME)
> @@ -28,16 +30,15 @@ MAN1DIR=$(MANDIR)/man1
>  INCLUDEDIR=$(PREFIX)/include
>  PKGCONFIGDIR=$(LIBDIR)/pkgconfig
> 
> -PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse
> test-linearize example \
> -	 test-unssa test-dissect ctags
> -
> -
> +PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse \
> +	 test-linearize example test-unssa test-dissect ctags
>  INST_PROGRAMS=sparse cgcc
>  INST_MAN1=sparse.1 cgcc.1
> 
>  ifeq ($(HAVE_LIBXML),yes)
>  PROGRAMS+=c2xml
>  INST_PROGRAMS+=c2xml
> +c2xml_EXTRA_OBJS = `pkg-config --libs libxml-2.0`
>  endif
> 
>  LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
> @@ -98,44 +99,12 @@ install: $(INST_PROGRAMS) $(LIBS) $(LIB_
>  sparse.pc: sparse.pc.in
>  	$(QUIET_GEN)sed
> 's|@version@|$(VERSION)|g;s|@prefix@|$(PREFIX)|g;s|@libdir@|$(LIBDIR)|g;s|@includedir@|$(INCLUDEDIR)|g'
> sparse.pc.in > sparse.pc

When you are patching the Makefile then I suggest breaking this line up somehow.
Should be a follow-up patch.

> 
> -test-lexing: test-lexing.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -test-parsing: test-parsing.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -test-linearize: test-linearize.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -test-sort: test-sort.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> +	
>  compile: compile.o compile-i386.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
> -
> -obfuscate: obfuscate.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -sparse: sparse.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -graph: graph.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -example: example.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -test-unssa: test-unssa.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -test-dissect: test-dissect.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> -
> -ctags: ctags.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
> +	$(PROG_LINK_CMD)
> 
> -c2xml: c2xml.o $(LIBS)
> -	$(QUIET_LINK)$(CC) $(LDFLAGS)  -o $@ $< $(LIBS) `pkg-config --libs libxml-2.0`
> +%: %.o $(LIBS)
> +	$(PROG_LINK_CMD)

Such a catch-all rule may likely give problems 
in the future. But for now it looks good.

I tried with:
$(PROGRAMS): %.o: $(LIBS)

but that failed due to the special treatment of compile
in the rule above.

> 
>  $(LIB_FILE): $(LIB_OBJS)
>  	$(QUIET_AR)$(AR) rcs $@ $(LIB_OBJS)
> @@ -143,48 +112,13 @@ $(LIB_FILE): $(LIB_OBJS)
>  $(SLIB_FILE): $(LIB_OBJS)
>  	$(QUIET_LINK)$(CC) $(LDFLAGS) -Wl,-soname,$@ -shared -o $@ $(LIB_OBJS)
> 
> -evaluate.o: $(LIB_H)
> -expression.o: $(LIB_H)
> -lib.o: $(LIB_H)
> -allocate.o: $(LIB_H)
> -ptrlist.o: $(LIB_H)
> -parse.o: $(LIB_H)
> -pre-process.o: $(LIB_H)
> -scope.o: $(LIB_H)
> -show-parse.o: $(LIB_H)
> -symbol.o: $(LIB_H)
> -expand.o: $(LIB_H)
> -linearize.o: $(LIB_H)
> -flow.o: $(LIB_H)
> -cse.o: $(LIB_H)
> -simplify.o: $(LIB_H)
> -memops.o: $(LIB_H)
> -liveness.o: $(LIB_H)
> -sort.o: $(LIB_H)
> -inline.o: $(LIB_H)
> -target.o: $(LIB_H)
> -test-lexing.o: $(LIB_H)
> -test-parsing.o: $(LIB_H)
> -test-linearize.o: $(LIB_H)
> -test-dissect.o: $(LIB_H)
> -test-unssa.o: $(LIB_H)
> -ctags.o: $(LIB_H)
> -compile.o: $(LIB_H) compile.h
> -compile-i386.o: $(LIB_H) compile.h
> -tokenize.o: $(LIB_H)
> -sparse.o: $(LIB_H)
> -obfuscate.o: $(LIB_H)
> -example.o: $(LIB_H)
> -storage.o: $(LIB_H)
> -dissect.o: $(LIB_H)
> -graph.o: $(LIB_H)
> +include $(wildcard .*.o.d)

This gives a warning when there is no .*.o.d files.
You need to do something like:
$(if $(wildcard .*.o.d), include $(wildcard .*.o.d))


> 
>  c2xml.o: c2xml.c $(LIB_H)
>  	$(QUIET_CC)$(CC) `pkg-config --cflags libxml-2.0` -o $@ -c $(CFLAGS) $<
> 
> -compat-linux.o: compat/strtold.c compat/mmap-blob.c \
> -	$(LIB_H)
> -compat-solaris.o: compat/mmap-blob.c $(LIB_H)
> +compat-linux.o: compat/strtold.c compat/mmap-blob.c
> +compat-solaris.o: compat/mmap-blob.c
>  compat-mingw.o: $(LIB_H)
>  compat-cygwin.o: $(LIB_H)
> 
> @@ -192,7 +126,7 @@ compat-cygwin.o: $(LIB_H)
>  	$(QUIET_CC)$(CC) -o $@ -c $(CFLAGS) $<
> 
>  clean: clean-check
> -	rm -f *.[oa] *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc
> +	rm -f *.[oad] *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc
> 
>  dist:
>  	@if test "`git describe`" != "$(VERSION)" ; then \


	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]: clean up Makefile long lines ===

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH]: clean up Makefile long lines
Date: Fri, 26 Dec 2008 02:27:13 +0000
Message-ID: <70318cbf0812251827p2a294b9ar3a64f1d1b418be80 () mail ! gmail ! com>
--------------------
------=_Part_96885_5264249.1230258433619
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Thu, Dec 25, 2008 at 1:30 AM, Sam Ravnborg <sam@ravnborg.org> wrote:
>
> When you are patching the Makefile then I suggest breaking this line up somehow.
> Should be a follow-up patch.

Here is the follow-up patch.

Chris

------=_Part_96885_5264249.1230258433619
Content-Type: text/plain; name=makefile-cleanup.patch.txt
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fp67zchk0
Content-Disposition: attachment; filename=makefile-cleanup.patch.txt

Q2xlYW4gdXAgTWFrZWZpbGUgbG9uZyBsaW5lcwoKU2lnbmVkLU9mZi1CeTogQ2hyaXN0b3BoZXIg
TGk8c3BhcnNlQGNocmlzbGkub3JnPgoKSW5kZXg6IHNwYXJzZS5jaHJpc2wvTWFrZWZpbGUKPT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PQotLS0gc3BhcnNlLmNocmlzbC5vcmlnL01ha2VmaWxlCisrKyBzcGFyc2UuY2hyaXNs
L01ha2VmaWxlCkBAIC03OCw2ICs3OCwxNyBAQCBRVUlFVF9MSU5LICAgID0gJChROkA9QGVjaG8g
ICAgJyAgICAgTElOCiBRVUlFVF9JTlNUX1NIID0gJChROkA9ZWNobyAtbiAgJyAgICAgSU5TVEFM
TCAgJzspCiBRVUlFVF9JTlNUICAgID0gJChROkA9QGVjaG8gLW4gJyAgICAgSU5TVEFMTCAgJzsp
CiAKK2RlZmluZSBJTlNUQUxMX0NNRAorCSQoUSkkKFFVSUVUX0lOU1RfU0gpaW5zdGFsbCAtdiAk
MSAkKERFU1RESVIpJDIvJDEgfHwgZXhpdCAxOworCitlbmRlZgorCitTRURfUENfQ01EID0gJ3N8
QHZlcnNpb25AfCQoVkVSU0lPTil8ZzsJCVwKKwkgICAgICBzfEBwcmVmaXhAfCQoUFJFRklYKXxn
OwkJXAorCSAgICAgIHN8QGxpYmRpckB8JChMSUJESVIpfGc7CQlcCisJICAgICAgc3xAaW5jbHVk
ZWRpckB8JChJTkNMVURFRElSKXxnJworCisKIGFsbDogJChQUk9HUkFNUykgc3BhcnNlLnBjCiAK
IGluc3RhbGw6ICQoSU5TVF9QUk9HUkFNUykgJChMSUJTKSAkKExJQl9IKSBzcGFyc2UucGMKQEAg
LTg2LDIyICs5NywxNCBAQCBpbnN0YWxsOiAkKElOU1RfUFJPR1JBTVMpICQoTElCUykgJChMSUJf
CiAJJChRKWluc3RhbGwgLWQgJChERVNURElSKSQoTUFOMURJUikKIAkkKFEpaW5zdGFsbCAtZCAk
KERFU1RESVIpJChJTkNMVURFRElSKS9zcGFyc2UKIAkkKFEpaW5zdGFsbCAtZCAkKERFU1RESVIp
JChQS0dDT05GSUdESVIpCi0JJChRKWZvciBmIGluICQoSU5TVF9QUk9HUkFNUyk7IGRvIFwKLQkJ
JChRVUlFVF9JTlNUX1NIKWluc3RhbGwgLXYgJCRmICQoREVTVERJUikkKEJJTkRJUikvJCRmIHx8
IGV4aXQgMTsgXAotCWRvbmUKLQkkKFEpZm9yIGYgaW4gJChJTlNUX01BTjEpOyBkbyBcCi0JCSQo
UVVJRVRfSU5TVF9TSClpbnN0YWxsIC1tIDY0NCAtdiAkJGYgJChERVNURElSKSQoTUFOMURJUikv
JCRmIHx8IGV4aXQgMTsgXAotCWRvbmUKLQkkKFEpZm9yIGYgaW4gJChMSUJTKTsgZG8gXAotCQkk
KFFVSUVUX0lOU1RfU0gpaW5zdGFsbCAtbSA2NDQgLXYgJCRmICQoREVTVERJUikkKExJQkRJUikv
JCRmIHx8IGV4aXQgMTsgXAotCWRvbmUKLQkkKFEpZm9yIGYgaW4gJChMSUJfSCk7IGRvIFwKLQkJ
JChRVUlFVF9JTlNUX1NIKWluc3RhbGwgLW0gNjQ0IC12ICQkZiAkKERFU1RESVIpJChJTkNMVURF
RElSKS9zcGFyc2UvJCRmIHx8IGV4aXQgMTsgXAotCWRvbmUKLQkkKFFVSUVUX0lOU1QpaW5zdGFs
bCAtbSA2NDQgLXYgc3BhcnNlLnBjICQoREVTVERJUikkKFBLR0NPTkZJR0RJUikvc3BhcnNlLnBj
CisJJChmb3JlYWNoIGYsJChJTlNUX1BST0dSQU1TKSwkKGNhbGwgSU5TVEFMTF9DTUQsJGYsJChC
SU5ESVIpKSkKKwkkKGZvcmVhY2ggZiwkKElOU1RfTUFOMSksJChjYWxsIElOU1RBTExfQ01ELCRm
LCQoTUFOMURJUikpKQorCSQoZm9yZWFjaCBmLCQoTElCUyksJChjYWxsIElOU1RBTExfQ01ELCRm
LCQoTElCRElSKSkpCisJJChmb3JlYWNoIGYsJChMSUJfSCksJChjYWxsIElOU1RBTExfQ01ELCRm
LCQoSU5DTFVERURJUikvc3BhcnNlKSkKKwkkKGNhbGwgSU5TVEFMTF9DTUQsc3BhcnNlLnBjLCQo
UEtHQ09ORklHRElSKSkKIAogc3BhcnNlLnBjOiBzcGFyc2UucGMuaW4KLQkkKFFVSUVUX0dFTilz
ZWQgJ3N8QHZlcnNpb25AfCQoVkVSU0lPTil8ZztzfEBwcmVmaXhAfCQoUFJFRklYKXxnO3N8QGxp
YmRpckB8JChMSUJESVIpfGc7c3xAaW5jbHVkZWRpckB8JChJTkNMVURFRElSKXxnJyBzcGFyc2Uu
cGMuaW4gPiBzcGFyc2UucGMKKwkkKFFVSUVUX0dFTilzZWQgJChTRURfUENfQ01EKSBzcGFyc2Uu
cGMuaW4gPiBzcGFyc2UucGMKIAogCiBjb21waWxlX0VYVFJBX0RFUFMgPSBjb21waWxlLWkzODYu
bwo=
------=_Part_96885_5264249.1230258433619--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 0/3] Examples for the new sparse context tracking ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [RFC 0/3] Examples for the new sparse context tracking
Date: Mon, 21 Apr 2008 15:05:33 +0000
Message-ID: <1208790333.26186.112.camel () johannes ! berg>
--------------------

--=-CV94L+f4brYivCkDyoUt
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable


> > my_specific_rcu_get() __acquires(RCU) __acquires(specificRCU);
> >=20
> > and then annotate whatever needs the specific RCU type with
> > __requires(specificRCU)
>=20
> Cute!!!  I didn't realize you could mark a single interface with
> multiple __acquires() markings.
>=20
> So if there is at least one match, sparse is happy?

No, sparse requires all the given contexts to match. For example, say
you have

#define __requires_rcu __requires(RCU)

#define __requires_special_rcu \
	__requires(specificRCU)

#define __acquires_special_rcu \
	__acquires(RCU) __acquires(specificRCU)

=EF=BB=BF#define __acquires_regular_rcu __acquires(RCU)

Then a function marked "__acquires_special_rcu" with acquire *both*
contexts, and a function marked __requires_special_rcu will require just
the special one. And a function marked __requires_rcu just requires the
regular one. So say you have

rcu_special_lock __acquires_special_rcu
=EF=BB=BFrcu_special_unlock __releases_special_rcu
=EF=BB=BF
rcu_regular_lock __acquires_rcu
=EF=BB=BFrcu_regular_unlock __releases_rcu

rcu_do_special __requires_special_rcu
rcu_do_something __requires_rcu


Then both this will be fine:


rcu_special_lock()
rcu_do_special()
rcu_do_something()
rcu_special_unlock()


but this will result in a warning:


rcu_regular_lock()
rcu_do_special()
rcu_regular_unlock()

because the "specialRCU" context is missing.

You could mark do_special with *both* __requires(RCU) and
__requires(specialRCU) but as long as the acquires/releases parts have a
strict dependency (=EF=BB=BFspecialRCU implies RCU) that isn't necessary.

johannes

--=-CV94L+f4brYivCkDyoUt
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAytPKVg1VMiehFYAQIwTQ//QS8R7E3PBq027f4tO3NkphsHGilYCofv
/4u4hq8B7DiyItML+ebNgPrl8xyozaxYOilnYMLsz36rQSJs5RYhVi6F1pAbwU8q
Cv4RHJ6L3DNlxmR1B0G1HJcEcX6D8Y5ElXPN/HyU23tTATa1omTPJYBHfnzemzX3
vz2xM+bwDEezCmsO8r7O1yOTo/GlERiOskdU2jKTgwAJkxHC/1Dbj0tTJ6pmWF9X
aJtArFtCDEkoRZ5ySYIZq+cLpYNC+Yx9D1VwWT8+XEf4ybDTiuwbCVqiSKc/lXmW
Lt35IiiPsvX1MNNl3m+BQAv2q0gLKlp2R8HR43llHSwsGfu33cHvqfjOQT+YD+KT
AkQlVwm1cUtAu4DlI5qMqGPHXzBMhakxlY8sK1W5o12ffO09CiKL2MpJo3Ww++6X
uwoUuc6i8OrDbcxkxYGCJeTf19BbWAWxA8j9YG0QRhYkqb4fqjbkiY5bMhPTRwdv
ttvugB5GEj7Agml5Ch+d9WbN58eWsh81qTicjj9FSNFX66LfmPYuU6eONmLc4lto
f804E/OtPdMLpRI4Ok5P8hk1wTXPzj1+goiF7DXAnNEiJW4kcCPPPOZR3Foi/TUV
cs4vUjXW5KEflHze6RhWMgikhQHsTprQL0hJvCV6K547yYHdNcxf3D+HEP2rza0X
0H5g9AjOsBM=
=08Yo
-----END PGP SIGNATURE-----

--=-CV94L+f4brYivCkDyoUt--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 1/2] evaluate context expressions ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [RFC 1/2] evaluate context expressions
Date: Sat, 26 Apr 2008 15:20:26 +0000
Message-ID: <1209223226.10943.11.camel () johannes ! berg>
--------------------
This patch makes sparse evaluate context expressions allowing this:

    struct test {
        lock_t lock;
    };

    static void a(struct test *t) __attribute__((context(&t->lock,1,0)))
    {  
        __context__(&t->lock, 1);
    }

to work the way you think it would.

Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
Heavily inspired by Philipp's patch :) When it warns, the expression is
given as evaluated, e.g. in above case would result in a warning about
"**t+0". We can fix that later by keeping the original expression and
not expanding/evaluating it, but we need to do both for it to work.

 evaluate.c                |    8 ++
 example.c                 |    4 -
 expand.c                  |    6 +
 expression.c              |  177 ++++++++++++++++++++++++++++++++++++++++++++++
 expression.h              |    3 
 linearize.c               |   76 +++++++++++++++++--
 linearize.h               |   11 ++
 liveness.c                |    8 +-
 parse.c                   |    9 ++
 sparse.c                  |  147 ++++++++++++++++++++++++--------------
 symbol.h                  |    4 +
 validation/context-vars.c |  141 ++++++++++++++++++++++++++++++++++++
 12 files changed, 526 insertions(+), 68 deletions(-)

--- sparse.orig/expression.c	2008-04-25 22:24:19.000000000 +0200
+++ sparse/expression.c	2008-04-25 22:24:24.000000000 +0200
@@ -929,4 +929,181 @@ struct token *parse_expression(struct to
 	return comma_expression(token,tree);
 }
 
+static int ident_equal(struct ident *ident1, struct ident *ident2)
+{
+	if (ident1 == ident2)
+		return 1;
+	if (!ident1 || !ident2)
+		return 0;
 
+	return ident1->len == ident2->len &&
+		!strncmp(ident1->name, ident2->name, ident1->len);
+}
+
+int expressions_equal(const struct expression *expr1,
+		      const struct expression *expr2)
+{
+	if (expr1 == expr2)
+		return 1;
+
+	if (expr1 == NULL || expr2 == NULL)
+		return 0;
+
+	/* Is this the right way to handle casts? */
+	if (expr1->type == EXPR_CAST ||
+	    expr1->type == EXPR_FORCE_CAST ||
+	    expr1->type == EXPR_IMPLIED_CAST)
+		return expressions_equal(expr1->cast_expression, expr2);
+
+	if (expr2->type == EXPR_CAST ||
+	    expr2->type == EXPR_FORCE_CAST ||
+	    expr2->type == EXPR_IMPLIED_CAST)
+		return expressions_equal(expr2->cast_expression, expr1);
+
+	if (expr1->type != expr2->type)
+		return 0;
+
+	switch (expr1->type) {
+	case EXPR_SYMBOL:
+		return ident_equal(expr1->symbol_name, expr2->symbol_name);
+
+	case EXPR_VALUE:
+		return expr1->value == expr2->value;
+
+	case EXPR_FVALUE:
+		return expr1->fvalue == expr2->fvalue;
+
+	case EXPR_STRING:
+		return expr1->string->length == expr2->string->length &&
+			!strncmp(expr1->string->data, expr2->string->data, expr1->string->length);
+
+	case EXPR_BINOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_COMMA:
+	case EXPR_ASSIGNMENT:
+		return expressions_equal(expr1->left, expr2->left) &&
+			expressions_equal(expr1->right, expr2->right);
+
+	case EXPR_DEREF:
+		return expressions_equal(expr1->deref, expr2->deref) &&
+			ident_equal(expr1->member, expr2->member);
+
+	case EXPR_PREOP:
+	case EXPR_POSTOP:
+		return expr1->op == expr2->op &&
+			expressions_equal(expr1->unop, expr2->unop);
+
+	/* Not needed right now, but for sake of completness ...
+	case EXPR_LABEL:
+	case EXPR_STATEMENT:
+	case EXPR_CALL:
+	case EXPR_LOGICAL:
+	case EXPR_COMPARE:
+	case EXPR_SELECT:
+	case EXPR_CONDITIONAL:
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+	case EXPR_SLICE:
+	case EXPR_INITIALIZER:
+	case EXPR_POS:
+	*/
+
+	default:
+		/* nothing, we should already have had a warning */
+		;
+	}
+
+	return 0;
+}
+
+static int ident_str(struct ident *ident, char *buffer, int length)
+{
+	if (!ident)
+		return 0;
+	return snprintf(buffer, length, "%.*s", ident->len, ident->name);
+}
+
+int expression_str(const struct expression *expr,
+		   char *buffer, int length)
+{
+	int n;
+
+	memset(buffer, 0, length);
+
+	if (!expr)
+		return 0;
+
+	/* TODO, think about necessary parentheses () */
+
+	switch (expr->type) {
+	case EXPR_SYMBOL:
+		return ident_str(expr->symbol_name, buffer, length);
+
+	case EXPR_VALUE:
+		return snprintf(buffer, length, "%llu", expr->value);
+
+	case EXPR_FVALUE:
+		return snprintf(buffer, length, "%Lf", expr->fvalue);
+
+	case EXPR_STRING:
+		return snprintf(buffer, length, "\"%.*s\"", expr->string->length, expr->string->data);
+
+	case EXPR_BINOP:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_COMMA:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, ",");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_ASSIGNMENT:
+		n  = expression_str(expr->left, buffer, length);
+		n += snprintf(buffer+n, length-n, "=");
+		n += expression_str(expr->right, buffer+n, length-n);
+		return n;
+
+	case EXPR_DEREF:
+		if (expr->left->type == EXPR_PREOP &&
+		    expr->left->op == '*') {
+			n  = expression_str(expr->left->unop, buffer, length);
+			n += snprintf(buffer+n, length-n, "->");
+			n += ident_str(expr->member, buffer+n, length-n);
+		} else {
+			n  = expression_str(expr->left, buffer, length);
+			n += snprintf(buffer+n, length-n, ".");
+			n += ident_str(expr->member, buffer+n, length-n);
+		}
+		return n;
+
+	case EXPR_PREOP:
+		n  = snprintf(buffer, length, "%c", expr->op);
+		n += expression_str(expr->unop, buffer+n, length-n);
+		return n;
+
+	case EXPR_POSTOP:
+		n  = expression_str(expr->unop, buffer, length);
+		n += snprintf(buffer+n, length-n, "%c", expr->op);
+		return n;
+
+	case EXPR_CAST:
+	case EXPR_FORCE_CAST:
+	case EXPR_IMPLIED_CAST:
+		/* todo: print out the cast type's ctype */
+		*buffer++ = '('; length--;
+		*buffer++ = ')'; length--;
+		return expression_str(expr->cast_expression, buffer, length) + 2;
+
+	default:
+		printf("Missing code in expression_str for %d\n", expr->type);
+	}
+
+	return 0;
+}
--- sparse.orig/expression.h	2008-04-25 22:24:19.000000000 +0200
+++ sparse/expression.h	2008-04-26 17:07:58.000000000 +0200
@@ -216,4 +216,7 @@ struct token *compound_statement(struct 
 void cast_value(struct expression *expr, struct symbol *newtype,
 	struct expression *old, struct symbol *oldtype);
 
+int expressions_equal(const struct expression *expr1,
+		      const struct expression *expr2);
+int expression_str(const struct expression *, char *buf, int buflen);
 #endif
--- sparse.orig/sparse.c	2008-04-25 22:24:24.000000000 +0200
+++ sparse/sparse.c	2008-04-26 17:12:18.000000000 +0200
@@ -26,7 +26,7 @@
 
 struct context_check {
 	int val, val_false;
-	char name[32];
+	const struct expression *expr;
 };
 
 DECLARE_ALLOCATOR(context_check);
@@ -34,22 +34,15 @@ DECLARE_PTR_LIST(context_check_list, str
 DECLARE_PTR_LIST(context_list_list, struct context_check_list);
 ALLOCATOR(context_check, "context check list");
 
-static const char *unnamed_context = "<unnamed>";
 
-static const char *context_name(struct context *context)
-{
-	if (context->context && context->context->symbol_name)
-		return show_ident(context->context->symbol_name);
-	return unnamed_context;
-}
-
-static void context_add(struct context_check_list **ccl, const char *name,
+static void context_add(struct context_check_list **ccl,
+			const struct expression *expr,
 			int offs, int offs_false)
 {
 	struct context_check *check, *found = NULL;
 
 	FOR_EACH_PTR(*ccl, check) {
-		if (strcmp(name, check->name))
+		if (!expressions_equal(expr, check->expr))
 			continue;
 		found = check;
 		break;
@@ -57,8 +50,7 @@ static void context_add(struct context_c
 
 	if (!found) {
 		found = __alloc_context_check(0);
-		strncpy(found->name, name, sizeof(found->name));
-		found->name[sizeof(found->name) - 1] = '\0';
+		found->expr = expr;
 		add_ptr_list(ccl, found);
 	}
 	found->val += offs;
@@ -71,7 +63,7 @@ static int context_list_has(struct conte
 	struct context_check *check;
 
 	FOR_EACH_PTR(ccl, check) {
-		if (strcmp(c->name, check->name))
+		if (!expressions_equal(c->expr, check->expr))
 			continue;
 		return check->val == c->val &&
 		       check->val_false == c->val_false;
@@ -107,7 +99,7 @@ static struct context_check_list *checke
 	struct context_check *c;
 
 	FOR_EACH_PTR(ccl, c) {
-		context_add(&result, c->name, c->val_false, c->val_false);
+		context_add(&result, c->expr, c->val_false, c->val_false);
 	} END_FOR_EACH_PTR(c);
 
 	return result;
@@ -117,15 +109,15 @@ static struct context_check_list *checke
 #define CONTEXT_PROB "context problem in '%s': "
 #define DEFAULT_CONTEXT_DESCR "   default context: "
 
-static void get_context_string(char **buf, const char **name)
+static const char *get_context_string(char **buf, const char *name)
 {
-	if (strcmp(*name, unnamed_context)) {
-		*buf = malloc(strlen(*name) + 16);
-		sprintf(*buf, "   context '%s': ", *name);
-		*name = *buf;
+	if (strlen(name)) {
+		*buf = malloc(strlen(name) + 16);
+		sprintf(*buf, "   context '%s': ", name);
+		return *buf;
 	} else {
-		*name = DEFAULT_CONTEXT_DESCR;
 		*buf = NULL;
+		return DEFAULT_CONTEXT_DESCR;
 	}
 }
 
@@ -135,12 +127,13 @@ static int context_list_check(struct ent
 {
 	struct context_check *c1, *c2;
 	int cur, tgt;
-	const char *name;
+	char name[1000];
 	char *buf;
+	const char *pname;
 
 	/* make sure the loop below checks all */
 	FOR_EACH_PTR(ccl_target, c1) {
-		context_add(&ccl_cur, c1->name, 0, 0);
+		context_add(&ccl_cur, c1->expr, 0, 0);
 	} END_FOR_EACH_PTR(c1);
 
 	FOR_EACH_PTR(ccl_cur, c1) {
@@ -148,7 +141,7 @@ static int context_list_check(struct ent
 		tgt = 0;
 
 		FOR_EACH_PTR(ccl_target, c2) {
-			if (strcmp(c2->name, c1->name))
+			if (!expressions_equal(c1->expr, c2->expr))
 				continue;
 			tgt = c2->val;
 			break;
@@ -164,11 +157,11 @@ static int context_list_check(struct ent
 			warning(pos, IMBALANCE_IN "unexpected unlock",
 				show_ident(ep->name->ident));
 
-		name = c1->name;
-		get_context_string(&buf, &name);
+		expression_str(c1->expr, name, sizeof(name));
+		pname = get_context_string(&buf, name);
 
 		info(pos, "%swanted %d, got %d",
-		     name, tgt, cur);
+		     pname, tgt, cur);
 
 		free(buf);
 
@@ -180,13 +173,15 @@ static int context_list_check(struct ent
 
 static int handle_call(struct entrypoint *ep, struct basic_block *bb,
 		       struct instruction *insn,
-		       struct context_check_list *combined)
+		       struct context_check_list **combined)
 {
 	struct context *ctx;
 	struct context_check *c;
-	const char *name, *call, *cmp;
+	const char *call, *cmp, *pname;
 	char *buf;
+	char name[1000];
 	int val, ok;
+	struct argument *arg;
 
 	if (!insn->func || !insn->func->sym ||
 	    insn->func->type != PSEUDO_SYM)
@@ -196,11 +191,19 @@ static int handle_call(struct entrypoint
 	 * Check all contexts the function wants.
 	 */
 	FOR_EACH_PTR(insn->func->sym->ctype.contexts, ctx) {
-		name = context_name(ctx);
+		int skip = 0;
 		val = 0;
 
-		FOR_EACH_PTR(combined, c) {
-			if (strcmp(c->name, name) == 0) {
+		FOR_EACH_PTR(insn->arguments, arg) {
+			if (arg->c == ctx)
+				skip = 1;
+		} END_FOR_EACH_PTR(arg);
+
+		if (skip)
+			continue;
+
+		FOR_EACH_PTR(*combined, c) {
+			if (expressions_equal(c->expr, ctx->in_fn)) {
 				val = c->val;
 				break;
 			}
@@ -215,7 +218,8 @@ static int handle_call(struct entrypoint
 		}
 
 		if (!ok && Wcontext) {
-			get_context_string(&buf, &name);
+			expression_str(ctx->context, name, sizeof(name));
+			pname = get_context_string(&buf, name);
 			call = strdup(show_ident(insn->func->ident));
 
 			warning(insn->pos, "context problem in '%s': "
@@ -223,7 +227,7 @@ static int handle_call(struct entrypoint
 				show_ident(ep->name->ident), call);
 
 			info(insn->pos, "%swanted %s%d, got %d",
-			     name, cmp, ctx->in, val);
+			     pname, cmp, ctx->in, val);
 
 			free((void *)call);
 			free(buf);
@@ -232,6 +236,49 @@ static int handle_call(struct entrypoint
 		}
 	} END_FOR_EACH_PTR (ctx);
 
+	FOR_EACH_PTR(insn->arguments, arg) {
+		val = 0;
+		ctx = arg->c;
+
+		if (!arg->c)
+			continue;
+
+		FOR_EACH_PTR(*combined, c) {
+			if (expressions_equal(arg->e, c->expr))
+				val = c->val;
+		} END_FOR_EACH_PTR(c);
+
+		if (ctx->exact) {
+			ok = ctx->in == val;
+			cmp = "";
+		} else {
+			ok = ctx->in <= val;
+			cmp = ">= ";
+		}
+
+		if (!ok && Wcontext) {
+			expression_str(arg->e, name, sizeof(name));
+			pname = get_context_string(&buf, name);
+			call = strdup(show_ident(insn->func->ident));
+
+			warning(insn->pos, "context problem in '%s': "
+				"'%s' expected different context",
+				show_ident(ep->name->ident), call);
+
+			info(insn->pos, "%swanted %s%d, got %d",
+			     pname, cmp, ctx->in, val);
+
+			free((void *)call);
+			free(buf);
+
+			return -1;
+		}
+
+		context_add(combined, arg->e,
+			    ctx->out - ctx->in,
+			    ctx->out_false - ctx->in);
+	} END_FOR_EACH_PTR(arg);
+
 	return 0;
 }
 
@@ -240,21 +287,16 @@ static int handle_context(struct entrypo
 			  struct context_check_list **combined)
 {
 	struct context_check *c;
-	const char *name, *cmp;
+	const char *cmp, *pname;
 	char *buf;
+	char name[1000];
 	int val, ok;
 
 	val = 0;
 
-	name = unnamed_context;
-	if (insn->context_expr)
-		name = show_ident(insn->context_expr->symbol_name);
-
 	FOR_EACH_PTR(*combined, c) {
-		if (strcmp(c->name, name) == 0) {
+		if (expressions_equal(c->expr, insn->context_expr))
 			val = c->val;
-			break;
-		}
 	} END_FOR_EACH_PTR(c);
 
 	if (insn->exact) {
@@ -266,7 +308,8 @@ static int handle_context(struct entrypo
 	}
 
 	if (!ok && Wcontext) {
-		get_context_string(&buf, &name);
+		expression_str(insn->context_expr, name, sizeof(name));
+		pname = get_context_string(&buf, name);
 
 		if (insn->access_var) {
 			char *symname = strdup(show_ident(insn->access_var->ident));
@@ -283,13 +326,13 @@ static int handle_context(struct entrypo
 		}
 
 		info(insn->pos, "%swanted %s%d, got %d",
-		     name, cmp, insn->required, val);
+		     pname, cmp, insn->required, val);
 
 		free(buf);
 		return -1;
 	}
 
-	context_add(combined, name, insn->increment, insn->inc_false);
+	context_add(combined, insn->context_expr, insn->increment, insn->inc_false);
 
 	return 0;
 }
@@ -328,9 +371,9 @@ static int check_bb_context(struct entry
 	 */
 	FOR_EACH_PTR(ccl_in, c) {
 		if (in_false)
-			context_add(&combined, c->name, c->val_false, c->val_false);
+			context_add(&combined, c->expr, c->val_false, c->val_false);
 		else
-			context_add(&combined, c->name, c->val, c->val);
+			context_add(&combined, c->expr, c->val, c->val);
 	} END_FOR_EACH_PTR(c);
 
 	/* Add the new context to the list of already-checked contexts */
@@ -346,7 +389,7 @@ static int check_bb_context(struct entry
 		switch (insn->opcode) {
 		case OP_INLINED_CALL:
 		case OP_CALL:
-			if (handle_call(ep, bb, insn, combined))
+			if (handle_call(ep, bb, insn, &combined))
 				goto out;
 			break;
 		case OP_CONTEXT:
@@ -577,10 +620,10 @@ static void check_context(struct entrypo
 	check_instructions(ep);
 
 	FOR_EACH_PTR(sym->ctype.contexts, context) {
-		const char *name = context_name(context);
-
-		context_add(&ccl_in, name, context->in, context->in);
-		context_add(&ccl_target, name, context->out, context->out_false);
+		context_add(&ccl_in, context->in_fn,
+			    context->in, context->in);
+		context_add(&ccl_target, context->in_fn,
+			    context->out, context->out_false);
 		/* we don't currently check the body of trylock functions */
 		if (context->out != context->out_false)
 			return;
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sparse/validation/context-vars.c	2008-04-26 17:15:23.000000000 +0200
@@ -0,0 +1,141 @@
+static void a(void *p) __attribute__((context(p,0,1)))
+{
+    __context__(p,1);
+}
+
+static void r(void *p) __attribute__((context(p,1,0)))
+{
+    __context__(p,-1,1);
+}
+
+extern void *l1, *l2;
+
+static void good_paired1(void)
+{
+    a(l1);
+    r(l1);
+}
+
+static void good_paired2(void)
+{
+    a(l1);
+    r(l1);
+    a(l1);
+    r(l1);
+    a(l2);
+    r(l2);
+}
+
+static void good_paired3(void)
+{
+    a(l1);
+    a(l2);
+    r(l2);
+    r(l1);
+}
+
+static void good_lock1(void *lp) __attribute__((context(lp,0,1)))
+{
+    a(lp);
+}
+
+static void good_lock2(void *lp) __attribute__((context(lp,0,1)))
+{
+    a(lp);
+    r(lp);
+    a(lp);
+}
+
+extern void **v;
+
+static void warn_lock1(void)
+{
+    a(v[1]);
+}
+
+extern int condition;
+
+static void good_lock3(void)
+{
+    a(v[1]);
+    if (condition) {
+        a(v[2]);
+        r(v[2]);
+    }
+    r(v[1]);
+}
+
+#define cond_lock(x, c)\
+  ((c) ? ({ __context__(x,1); 1; }) : 0)
+
+#define trylock(x) \
+    cond_lock(x, _try_lock(x))
+
+extern void _try_lock(int *x);
+
+static int good_condlock1(void)
+{
+    if (trylock(v[0]))
+        r(v[0]);
+}
+
+static int good_condlock2(void)
+{
+    if (trylock(&condition))
+        r((void*)&condition);
+}
+
+extern void ai(int *p) __attribute__((context(p,0,1)));
+extern void ri(int *p) __attribute__((context(p,1,0)));
+
+struct test {
+    int lock;
+
+    /*
+     * &lock points to the lock within this struct
+     */
+    int val __attribute__((context(&lock,1,1)));
+};
+
+static inline void unlock(struct test *t)
+    __attribute__((context(&t->lock,1,0)))
+{
+    ri(&t->lock);
+}
+
+static void good_lock4(struct test *t)
+    __attribute__((context(&t->lock,0,1)))
+{
+    ai(&t->lock);
+}
+
+/*
+ * This test would currently fail with:
+ *
+context-vars.c:118:5: warning: context problem in 'good_use': access to 'val' requires different context
+context-vars.c:118:5:    context '&lock': wanted >= 1, got 0
+ *
+ * and
+ *
+context-vars.c:103:7: warning: context problem in 'good_use': 'ri' expected different context
+context-vars.c:103:7:    context '*t+0': wanted >= 1, got 0
+ *
+ * because arguments aren't bound properly nor does the &lock declaration
+ * within structs work the way you might thing it does.
+ *
+static void good_use(struct test *x)
+{
+    good_lock4(x);
+    x->val = 7;
+    unlock(x);
+}
+ */
+
+/*
+ * check-name: Check -Wcontext with lock variables
+ *
+ * check-error-start
+context-vars.c:53:7: warning: context imbalance in 'warn_lock1': wrong count at exit
+context-vars.c:53:7:    context '**v+4': wanted 0, got 1
+ * check-error-end
+ */
--- sparse.orig/example.c	2008-04-25 22:24:19.000000000 +0200
+++ sparse/example.c	2008-04-25 22:24:24.000000000 +0200
@@ -1121,10 +1121,10 @@ static void generate_ret(struct bb_state
 static void generate_call(struct bb_state *state, struct instruction *insn)
 {
 	int offset = 0;
-	pseudo_t arg;
+	struct argument *arg;
 
 	FOR_EACH_PTR(insn->arguments, arg) {
-		output_insn(state, "pushl %s", generic(state, arg));
+		output_insn(state, "pushl %s", generic(state, arg->p));
 		offset += 4;
 	} END_FOR_EACH_PTR(arg);
 	flush_reg(state, hardregs+0);
--- sparse.orig/linearize.c	2008-04-25 22:24:24.000000000 +0200
+++ sparse/linearize.c	2008-04-26 17:07:58.000000000 +0200
@@ -36,6 +36,13 @@ struct pseudo void_pseudo = {};
 
 static struct position current_pos;
 
+ALLOCATOR(argument, "arguments");
+
+static struct argument *alloc_argument(void)
+{
+	return __alloc_argument(0);
+}
+
 ALLOCATOR(pseudo_user, "pseudo_user");
 
 static struct instruction *alloc_instruction(int opcode, int size)
@@ -400,12 +407,12 @@ const char *show_instruction(struct inst
 		break;
 	case OP_INLINED_CALL:
 	case OP_CALL: {
-		struct pseudo *arg;
+		struct argument *arg;
 		if (insn->target && insn->target != VOID)
 			buf += sprintf(buf, "%s <- ", show_pseudo(insn->target));
 		buf += sprintf(buf, "%s", show_pseudo(insn->func));
 		FOR_EACH_PTR(insn->arguments, arg) {
-			buf += sprintf(buf, ", %s", show_pseudo(arg));
+			buf += sprintf(buf, ", %s", show_pseudo(arg->p));
 		} END_FOR_EACH_PTR(arg);
 		break;
 	}
@@ -437,7 +444,11 @@ const char *show_instruction(struct inst
 		break;
 
 	case OP_CONTEXT:
-		buf += sprintf(buf, "%s%d,%d", "", insn->increment, insn->inc_false);
+		if (insn->context_expr) {
+			buf += expression_str(insn->context_expr, buf, 1000);
+			buf += sprintf(buf, ", ");
+		}
+		buf += sprintf(buf, "%d, %d", insn->increment, insn->inc_false);
 		break;
 	case OP_RANGE:
 		buf += sprintf(buf, "%s between %s..%s", show_pseudo(insn->src1), show_pseudo(insn->src2), show_pseudo(insn->src3));
@@ -1263,22 +1274,58 @@ static pseudo_t linearize_call_expressio
 	pseudo_t retval, call;
 	struct ctype *ctype = NULL;
 	struct context *context;
+	struct symbol *sym, *found = NULL;
+	struct argument *narg;
+	int argnum = 0, i;
 
 	if (!expr->ctype) {
 		warning(expr->pos, "call with no type!");
 		return VOID;
 	}
 
-	FOR_EACH_PTR(expr->args, arg) {
-		pseudo_t new = linearize_expression(ep, arg);
-		use_pseudo(insn, new, add_pseudo(&insn->arguments, new));
-	} END_FOR_EACH_PTR(arg);
-
 	fn = expr->fn;
 
 	if (fn->ctype)
 		ctype = &fn->ctype->ctype;
 
+	FOR_EACH_PTR(expr->args, arg) {
+		char *ident;
+		pseudo_t new = linearize_expression(ep, arg);
+
+		narg = alloc_argument();
+		narg->e = arg;
+
+		add_ptr_list(&insn->arguments, narg);
+		use_pseudo(insn, new, &narg->p);
+		argnum++;
+
+		if (!ctype)
+			continue;
+
+		i = 0;
+
+		FOR_EACH_PTR(ctype->base_type->arguments, sym) {
+			if (i == argnum - 1)
+				found = sym;
+			i++;
+		} END_FOR_EACH_PTR(sym);
+
+		if (!found)
+			continue;
+
+		ident = strdup(show_ident(found->ident));
+
+		/* now get the context and link it to the arg */
+		FOR_EACH_PTR(ctype->contexts, context) {
+			if (context->context->type != EXPR_SYMBOL)
+				continue;
+			if (strcmp(show_ident(context->context->symbol_name),
+			           ident) == 0)
+				narg->c = context;
+		} END_FOR_EACH_PTR(context);
+		free(ident);
+	} END_FOR_EACH_PTR(arg);
+
 	if (fn->type == EXPR_PREOP) {
 		if (fn->unop->type == EXPR_SYMBOL) {
 			struct symbol *sym = fn->unop->symbol;
@@ -1302,6 +1349,15 @@ static pseudo_t linearize_call_expressio
 		FOR_EACH_PTR(ctype->contexts, context) {
 			int in = context->in;
 			int out = context->out;
+			int skip = 0;
+
+			FOR_EACH_PTR(insn->arguments, narg) {
+				if (context == narg->c)
+					skip = 1;
+			} END_FOR_EACH_PTR(narg);
+
+			if (skip)
+				continue;
 
 			if (out - in || context->out_false - in) {
 				insn = alloc_instruction(OP_CONTEXT, 0);
@@ -1719,7 +1775,9 @@ static pseudo_t linearize_inlined_call(s
 		concat_symbol_list(args->declaration, &ep->syms);
 		FOR_EACH_PTR(args->declaration, sym) {
 			pseudo_t value = linearize_one_symbol(ep, sym);
-			use_pseudo(insn, value, add_pseudo(&insn->arguments, value));
+			struct argument *narg = alloc_argument();
+			add_ptr_list(&insn->arguments, narg);
+			use_pseudo(insn, value, &narg->p);
 		} END_FOR_EACH_PTR(sym);
 	}
 
--- sparse.orig/linearize.h	2008-04-25 22:24:24.000000000 +0200
+++ sparse/linearize.h	2008-04-26 17:07:58.000000000 +0200
@@ -40,6 +40,15 @@ struct pseudo {
 	};
 };
 
+struct argument {
+	struct pseudo *p;
+	struct context *c;
+	struct expression *e;
+};
+
+DECLARE_PTR_LIST(argument_list, struct argument);
+DECLARE_ALLOCATOR(argument);
+
 extern struct pseudo void_pseudo;
 
 #define VOID (&void_pseudo)
@@ -113,7 +122,7 @@ struct instruction {
 		};
 		struct /* call */ {
 			pseudo_t func;
-			struct pseudo_list *arguments;
+			struct argument_list *arguments;
 		};
 		struct /* context */ {
 			int increment, required, inc_false, exact;
--- sparse.orig/liveness.c	2008-04-25 22:24:19.000000000 +0200
+++ sparse/liveness.c	2008-04-25 22:24:24.000000000 +0200
@@ -50,7 +50,7 @@ static void track_instruction_usage(stru
 	void (*def)(struct basic_block *, struct instruction *, pseudo_t),
 	void (*use)(struct basic_block *, struct instruction *, pseudo_t))
 {
-	pseudo_t pseudo;
+	struct argument *arg;
 
 	#define USES(x)		use(bb, insn, insn->x)
 	#define DEFINES(x)	def(bb, insn, insn->x)
@@ -125,9 +125,9 @@ static void track_instruction_usage(stru
 		USES(func);
 		if (insn->target != VOID)
 			DEFINES(target);
-		FOR_EACH_PTR(insn->arguments, pseudo) {
-			use(bb, insn, pseudo);
-		} END_FOR_EACH_PTR(pseudo);
+		FOR_EACH_PTR(insn->arguments, arg) {
+			use(bb, insn, arg->p);
+		} END_FOR_EACH_PTR(arg);
 		break;
 
 	case OP_SLICE:
--- sparse.orig/evaluate.c	2008-04-26 17:12:11.000000000 +0200
+++ sparse/evaluate.c	2008-04-26 17:12:18.000000000 +0200
@@ -3025,6 +3025,7 @@ static void check_duplicates(struct symb
 static struct symbol *evaluate_symbol(struct symbol *sym)
 {
 	struct symbol *base_type;
+	struct context *c;
 
 	if (!sym)
 		return sym;
@@ -3054,6 +3055,13 @@ static struct symbol *evaluate_symbol(st
 			evaluate_statement(base_type->stmt);
 
 		current_fn = curr;
+
+		FOR_EACH_PTR(sym->ctype.contexts, c) {
+		if (c->in_fn &&
+		    (c->in_fn->type != EXPR_SYMBOL ||
+		     c->in_fn->symbol))
+			evaluate_expression(c->in_fn);
+		} END_FOR_EACH_PTR(c);
 	}
 
 	return base_type;
--- sparse.orig/expand.c	2008-04-26 17:12:10.000000000 +0200
+++ sparse/expand.c	2008-04-26 17:12:18.000000000 +0200
@@ -1034,8 +1034,14 @@ int expand_symbol(struct symbol *sym)
 	retval = expand_expression(sym->initializer);
 	/* expand the body of the symbol */
 	if (base_type->type == SYM_FN) {
+		struct context *c;
+
 		if (base_type->stmt)
 			expand_statement(base_type->stmt);
+
+		FOR_EACH_PTR(sym->ctype.contexts, c) {
+			expand_expression(c->in_fn);
+		} END_FOR_EACH_PTR(c);
 	}
 	return retval;
 }
--- sparse.orig/parse.c	2008-04-26 17:12:10.000000000 +0200
+++ sparse/parse.c	2008-04-26 17:12:18.000000000 +0200
@@ -884,11 +884,13 @@ static struct token *_attribute_context(
 {
 	struct context *context = alloc_context();
 	struct expression *args[3];
+	struct token *tok = NULL;
 	int argc = 0;
 
 	token = expect(token, '(', "after context attribute");
 	while (!match_op(token, ')')) {
 		struct expression *expr = NULL;
+		tok = tok ? : token;
 		token = conditional_expression(token, &expr);
 		if (!expr)
 			break;
@@ -914,6 +916,7 @@ static struct token *_attribute_context(
 		break;
 	case 3:
 		context->context = args[0];
+		context->token = tok;
 		context->in = get_expression_value(args[1]);
 		context->out = get_expression_value(args[2]);
 		break;
@@ -2127,6 +2130,7 @@ static struct token *parse_function_body
 	struct symbol *base_type = decl->ctype.base_type;
 	struct statement *stmt, **p;
 	struct symbol *arg;
+	struct context *c;
 
 	old_symbol_list = function_symbol_list;
 	if (decl->ctype.modifiers & MOD_INLINE) {
@@ -2155,6 +2159,11 @@ static struct token *parse_function_body
 
 	token = compound_statement(token->next, stmt);
 
+	FOR_EACH_PTR(decl->ctype.contexts, c) {
+		if (c->token)
+			conditional_expression(c->token, &c->in_fn);
+	} END_FOR_EACH_PTR(c);
+
 	end_function(decl);
 	if (!(decl->ctype.modifiers & MOD_INLINE))
 		add_symbol(list, decl);
--- sparse.orig/symbol.h	2008-04-26 17:12:10.000000000 +0200
+++ sparse/symbol.h	2008-04-26 17:12:18.000000000 +0200
@@ -71,6 +71,10 @@ enum keyword {
 
 struct context {
 	struct expression *context;
+	/* store the token pointer */
+	struct token *token;
+	/* to re-evaluate this context within the function it is for */
+	struct expression *in_fn;
 	unsigned int in, out, out_false;
 	int exact;
 };


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 1/3] add macros for new sparse features ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [RFC 1/3] add macros for new sparse features
Date: Thu, 10 Apr 2008 13:48:11 +0000
Message-ID: <20080410134827.771251000 () sipsolutions ! net>
--------------------
This patch adds kernel macros for a few new sparse features, namely
 * checking try_lock functions and
 * making a function or macro require a certain lock.

Still waiting to see what the sparse folks say to my patches.

Not-yet-signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 include/linux/compiler.h |    6 ++++++
 1 file changed, 6 insertions(+)

--- everything.orig/include/linux/compiler.h	2008-04-10 15:36:18.000000000 +0200
+++ everything/include/linux/compiler.h	2008-04-10 15:36:40.000000000 +0200
@@ -11,9 +11,12 @@
 # define __nocast	__attribute__((nocast))
 # define __iomem	__attribute__((noderef, address_space(2)))
 # define __acquires(x)	__attribute__((context(x,0,1)))
+# define __try_acquires(x,t,f)	__attribute__((conditional_context(x,0,t,f)))
 # define __releases(x)	__attribute__((context(x,1,0)))
 # define __acquire(x)	__context__(x,1)
 # define __release(x)	__context__(x,-1)
+# define __requires(x)	__attribute__((context(x,1,1)))
+# define __macro_requires(x)	__context__(x,0,1)
 # define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
 extern void __chk_user_ptr(const volatile void __user *);
 extern void __chk_io_ptr(const volatile void __iomem *);
@@ -28,9 +31,12 @@ extern void __chk_io_ptr(const volatile 
 # define __chk_io_ptr(x) (void)0
 # define __builtin_warning(x, y...) (1)
 # define __acquires(x)
+# define __try_acquires(x,t,f)
 # define __releases(x)
 # define __acquire(x) (void)0
 # define __release(x) (void)0
+# define __requires(x)
+# define __macro_requires(x)
 # define __cond_lock(x,c) (c)
 #endif
 

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-wireless
Subject: [RFC 1/3] add macros for new sparse features
Date: Thu, 10 Apr 2008 13:48:11 +0000
Message-ID: <20080410134827.771251000 () sipsolutions ! net>
--------------------
This patch adds kernel macros for a few new sparse features, namely
 * checking try_lock functions and
 * making a function or macro require a certain lock.

Still waiting to see what the sparse folks say to my patches.

Not-yet-signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 include/linux/compiler.h |    6 ++++++
 1 file changed, 6 insertions(+)

--- everything.orig/include/linux/compiler.h	2008-04-10 15:36:18.000000000 +0200
+++ everything/include/linux/compiler.h	2008-04-10 15:36:40.000000000 +0200
@@ -11,9 +11,12 @@
 # define __nocast	__attribute__((nocast))
 # define __iomem	__attribute__((noderef, address_space(2)))
 # define __acquires(x)	__attribute__((context(x,0,1)))
+# define __try_acquires(x,t,f)	__attribute__((conditional_context(x,0,t,f)))
 # define __releases(x)	__attribute__((context(x,1,0)))
 # define __acquire(x)	__context__(x,1)
 # define __release(x)	__context__(x,-1)
+# define __requires(x)	__attribute__((context(x,1,1)))
+# define __macro_requires(x)	__context__(x,0,1)
 # define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
 extern void __chk_user_ptr(const volatile void __user *);
 extern void __chk_io_ptr(const volatile void __iomem *);
@@ -28,9 +31,12 @@ extern void __chk_io_ptr(const volatile 
 # define __chk_io_ptr(x) (void)0
 # define __builtin_warning(x, y...) (1)
 # define __acquires(x)
+# define __try_acquires(x,t,f)
 # define __releases(x)
 # define __acquire(x) (void)0
 # define __release(x) (void)0
+# define __requires(x)
+# define __macro_requires(x)
 # define __cond_lock(x,c) (c)
 #endif
 

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Stefan Richter <stefanr () s5r6 ! in-berlin ! de>
To: linux-kernel
Subject: Re: [RFC 1/3] add macros for new sparse features
Date: Thu, 10 Apr 2008 16:37:48 +0000
Message-ID: <47FE425C.7060405 () s5r6 ! in-berlin ! de>
--------------------
Johannes Berg wrote:
> This patch adds kernel macros for a few new sparse features, namely
>  * checking try_lock functions and
>  * making a function or macro require a certain lock.
> 
> Still waiting to see what the sparse folks say to my patches.
> 
> Not-yet-signed-off-by: Johannes Berg <johannes@sipsolutions.net>
> ---
>  include/linux/compiler.h |    6 ++++++
>  1 file changed, 6 insertions(+)
> 
> --- everything.orig/include/linux/compiler.h	2008-04-10 15:36:18.000000000 +0200
> +++ everything/include/linux/compiler.h	2008-04-10 15:36:40.000000000 +0200
> @@ -11,9 +11,12 @@
>  # define __nocast	__attribute__((nocast))
>  # define __iomem	__attribute__((noderef, address_space(2)))
>  # define __acquires(x)	__attribute__((context(x,0,1)))
> +# define __try_acquires(x,t,f)	__attribute__((conditional_context(x,0,t,f)))
>  # define __releases(x)	__attribute__((context(x,1,0)))
>  # define __acquire(x)	__context__(x,1)
>  # define __release(x)	__context__(x,-1)
> +# define __requires(x)	__attribute__((context(x,1,1)))
> +# define __macro_requires(x)	__context__(x,0,1)


So, instead of

  /* always call with host_lock held */
  int foo(struct bar *b)
  {

we could write

  int foo(struct bar *b) __requires(host_lock)
  {

and let sparse check the call chains... or how is it used?

And what about dynamically allocated locks?
E.g. b->lock
Or struct host h* = container_of(b, struct host, m); with the necessity
to hold h->lock...
-- 
Stefan Richter
-=====-==--- -=-- -=-=-
http://arcgraph.de/sr/
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Stefan Richter <stefanr () s5r6 ! in-berlin ! de>
To: linux-sparse
Subject: Re: [RFC 1/3] add macros for new sparse features
Date: Thu, 10 Apr 2008 16:37:48 +0000
Message-ID: <47FE425C.7060405 () s5r6 ! in-berlin ! de>
--------------------
Johannes Berg wrote:
> This patch adds kernel macros for a few new sparse features, namely
>  * checking try_lock functions and
>  * making a function or macro require a certain lock.
> 
> Still waiting to see what the sparse folks say to my patches.
> 
> Not-yet-signed-off-by: Johannes Berg <johannes@sipsolutions.net>
> ---
>  include/linux/compiler.h |    6 ++++++
>  1 file changed, 6 insertions(+)
> 
> --- everything.orig/include/linux/compiler.h	2008-04-10 15:36:18.000000000 +0200
> +++ everything/include/linux/compiler.h	2008-04-10 15:36:40.000000000 +0200
> @@ -11,9 +11,12 @@
>  # define __nocast	__attribute__((nocast))
>  # define __iomem	__attribute__((noderef, address_space(2)))
>  # define __acquires(x)	__attribute__((context(x,0,1)))
> +# define __try_acquires(x,t,f)	__attribute__((conditional_context(x,0,t,f)))
>  # define __releases(x)	__attribute__((context(x,1,0)))
>  # define __acquire(x)	__context__(x,1)
>  # define __release(x)	__context__(x,-1)
> +# define __requires(x)	__attribute__((context(x,1,1)))
> +# define __macro_requires(x)	__context__(x,0,1)


So, instead of

  /* always call with host_lock held */
  int foo(struct bar *b)
  {

we could write

  int foo(struct bar *b) __requires(host_lock)
  {

and let sparse check the call chains... or how is it used?

And what about dynamically allocated locks?
E.g. b->lock
Or struct host h* = container_of(b, struct host, m); with the necessity
to hold h->lock...
-- 
Stefan Richter
-=====-==--- -=-- -=-=-
http://arcgraph.de/sr/
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [RFC 1/3] add macros for new sparse features
Date: Fri, 11 Apr 2008 12:20:39 +0000
Message-ID: <1207916439.13354.68.camel () johannes ! berg>
--------------------

--=-8pjRjQXmdm/TnsTbuq52
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> So, instead of
>=20
>   /* always call with host_lock held */
>   int foo(struct bar *b)
>   {
>=20
> we could write
>=20
>   int foo(struct bar *b) __requires(host_lock)
>   {
>=20
> and let sparse check the call chains... or how is it used?

Yes.

> And what about dynamically allocated locks?
> E.g. b->lock
> Or struct host h* =3D container_of(b, struct host, m); with the necessity
> to hold h->lock...

I was looking at making sparse check that certain variable references
are under rcu, but it's not as easy. Also, the lock context is just an
arbitrary name, there's no way to actually link it to a certain variable
or so to differentiate between them. I think that's not really solvable
in sparse, look at the things lockdep has to do.

johannes

--=-8pjRjQXmdm/TnsTbuq52
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/9XlqVg1VMiehFYAQKk0w//fRspT04ACbb1HUS5P21pbENuirTgrIFv
jYz/UomtBkbuJrqZwL1OFO70jrBK3jt1UwzZENub162DHI6pzFgiKFlU5c5uYs7c
d9zzpqF6SnPG2Ox2f9BUgGdqBdulXBXAlrT9W8MBW8fwuKngS0iQE3zkGjYB+nY5
x7br69bWMK01h+tqMcfHaI76E+BGqlLhaomCAJe4VDhIXZJkKS95oevnHm9fHh2a
NrxV+f+DvFyR4MezX3mVRpOBd0obtdcbquws/etOCcLofAWJWNFMccY4UKpU5CWO
QoemmQIsAYYNfu96y8nwZaBaYwN8RP0pChneK+hpqHs2eQuynT8bIBpQPhASCKvC
mKvqx9ANT+UYsfHj3gj8XZms/m7XGuf5n8KR2HwiLsqCmle3Jwoy/2y3P7JA2Xwi
Asa7UBJmHcOpkGFAZb4ilA3cgp5CmFwijeWIHIEKLjM67VYnpyoSMg77tY89A7dU
z8v1+vDQJfaEjBMXQL0x0W6rsazR41orXhFilgOXEhvL7hBHbZC4S618eRur4mxY
Y1oRoH2ABKRPCMgmH5ZRjaADzRDdLQ0oSy49yvDKu1yWp6oxvH5MquaJ1owOaKNg
d89eWSG0BrdX/b/hbvfqTUxEiC1eXVHP4RjGUgm7143/4Cjn5ewspAzZVHBHJjmN
DAUgK98qcAc=
=4MWs
-----END PGP SIGNATURE-----

--=-8pjRjQXmdm/TnsTbuq52--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Re: [RFC 1/3] add macros for new sparse features
Date: Fri, 11 Apr 2008 12:20:39 +0000
Message-ID: <1207916439.13354.68.camel () johannes ! berg>
--------------------

--=-8pjRjQXmdm/TnsTbuq52
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> So, instead of
>=20
>   /* always call with host_lock held */
>   int foo(struct bar *b)
>   {
>=20
> we could write
>=20
>   int foo(struct bar *b) __requires(host_lock)
>   {
>=20
> and let sparse check the call chains... or how is it used?

Yes.

> And what about dynamically allocated locks?
> E.g. b->lock
> Or struct host h* =3D container_of(b, struct host, m); with the necessity
> to hold h->lock...

I was looking at making sparse check that certain variable references
are under rcu, but it's not as easy. Also, the lock context is just an
arbitrary name, there's no way to actually link it to a certain variable
or so to differentiate between them. I think that's not really solvable
in sparse, look at the things lockdep has to do.

johannes

--=-8pjRjQXmdm/TnsTbuq52
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/9XlqVg1VMiehFYAQKk0w//fRspT04ACbb1HUS5P21pbENuirTgrIFv
jYz/UomtBkbuJrqZwL1OFO70jrBK3jt1UwzZENub162DHI6pzFgiKFlU5c5uYs7c
d9zzpqF6SnPG2Ox2f9BUgGdqBdulXBXAlrT9W8MBW8fwuKngS0iQE3zkGjYB+nY5
x7br69bWMK01h+tqMcfHaI76E+BGqlLhaomCAJe4VDhIXZJkKS95oevnHm9fHh2a
NrxV+f+DvFyR4MezX3mVRpOBd0obtdcbquws/etOCcLofAWJWNFMccY4UKpU5CWO
QoemmQIsAYYNfu96y8nwZaBaYwN8RP0pChneK+hpqHs2eQuynT8bIBpQPhASCKvC
mKvqx9ANT+UYsfHj3gj8XZms/m7XGuf5n8KR2HwiLsqCmle3Jwoy/2y3P7JA2Xwi
Asa7UBJmHcOpkGFAZb4ilA3cgp5CmFwijeWIHIEKLjM67VYnpyoSMg77tY89A7dU
z8v1+vDQJfaEjBMXQL0x0W6rsazR41orXhFilgOXEhvL7hBHbZC4S618eRur4mxY
Y1oRoH2ABKRPCMgmH5ZRjaADzRDdLQ0oSy49yvDKu1yWp6oxvH5MquaJ1owOaKNg
d89eWSG0BrdX/b/hbvfqTUxEiC1eXVHP4RjGUgm7143/4Cjn5ewspAzZVHBHJjmN
DAUgK98qcAc=
=4MWs
-----END PGP SIGNATURE-----

--=-8pjRjQXmdm/TnsTbuq52--

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-wireless
Subject: Re: [RFC 1/3] add macros for new sparse features
Date: Fri, 11 Apr 2008 12:20:39 +0000
Message-ID: <1207916439.13354.68.camel () johannes ! berg>
--------------------

--=-8pjRjQXmdm/TnsTbuq52
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> So, instead of
>=20
>   /* always call with host_lock held */
>   int foo(struct bar *b)
>   {
>=20
> we could write
>=20
>   int foo(struct bar *b) __requires(host_lock)
>   {
>=20
> and let sparse check the call chains... or how is it used?

Yes.

> And what about dynamically allocated locks?
> E.g. b->lock
> Or struct host h* =3D container_of(b, struct host, m); with the necessity
> to hold h->lock...

I was looking at making sparse check that certain variable references
are under rcu, but it's not as easy. Also, the lock context is just an
arbitrary name, there's no way to actually link it to a certain variable
or so to differentiate between them. I think that's not really solvable
in sparse, look at the things lockdep has to do.

johannes

--=-8pjRjQXmdm/TnsTbuq52
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUAR/9XlqVg1VMiehFYAQKk0w//fRspT04ACbb1HUS5P21pbENuirTgrIFv
jYz/UomtBkbuJrqZwL1OFO70jrBK3jt1UwzZENub162DHI6pzFgiKFlU5c5uYs7c
d9zzpqF6SnPG2Ox2f9BUgGdqBdulXBXAlrT9W8MBW8fwuKngS0iQE3zkGjYB+nY5
x7br69bWMK01h+tqMcfHaI76E+BGqlLhaomCAJe4VDhIXZJkKS95oevnHm9fHh2a
NrxV+f+DvFyR4MezX3mVRpOBd0obtdcbquws/etOCcLofAWJWNFMccY4UKpU5CWO
QoemmQIsAYYNfu96y8nwZaBaYwN8RP0pChneK+hpqHs2eQuynT8bIBpQPhASCKvC
mKvqx9ANT+UYsfHj3gj8XZms/m7XGuf5n8KR2HwiLsqCmle3Jwoy/2y3P7JA2Xwi
Asa7UBJmHcOpkGFAZb4ilA3cgp5CmFwijeWIHIEKLjM67VYnpyoSMg77tY89A7dU
z8v1+vDQJfaEjBMXQL0x0W6rsazR41orXhFilgOXEhvL7hBHbZC4S618eRur4mxY
Y1oRoH2ABKRPCMgmH5ZRjaADzRDdLQ0oSy49yvDKu1yWp6oxvH5MquaJ1owOaKNg
d89eWSG0BrdX/b/hbvfqTUxEiC1eXVHP4RjGUgm7143/4Cjn5ewspAzZVHBHJjmN
DAUgK98qcAc=
=4MWs
-----END PGP SIGNATURE-----

--=-8pjRjQXmdm/TnsTbuq52--

--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 3/3] mac80211: annotate with __requires_rcu ===

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Thu, 10 Apr 2008 13:48:13 +0000
Message-ID: <20080410134829.412424000 () sipsolutions ! net>
--------------------
As an example, this annotates mac80211 with the new __requires_rcu.

Not-yet-signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 net/mac80211/key.c      |    2 +-
 net/mac80211/key.h      |    2 +-
 net/mac80211/rx.c       |   12 ++++++------
 net/mac80211/sta_info.h |    3 ++-
 net/mac80211/tx.c       |    3 ++-
 5 files changed, 12 insertions(+), 10 deletions(-)

--- everything.orig/net/mac80211/sta_info.h	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/sta_info.h	2008-04-10 15:36:45.000000000 +0200
@@ -321,7 +321,8 @@ static inline enum plink_state sta_plink
 /*
  * Get a STA info, must have be under RCU read lock.
  */
-struct sta_info *sta_info_get(struct ieee80211_local *local, u8 *addr);
+struct sta_info *sta_info_get(struct ieee80211_local *local, u8 *addr) __requires_rcu;
+
 /*
  * Get STA info by index, BROKEN!
  */
--- everything.orig/net/mac80211/key.c	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/key.c	2008-04-10 15:36:45.000000000 +0200
@@ -299,7 +299,7 @@ struct ieee80211_key *ieee80211_key_allo
 
 void ieee80211_key_link(struct ieee80211_key *key,
 			struct ieee80211_sub_if_data *sdata,
-			struct sta_info *sta)
+			struct sta_info *sta) __requires_rcu
 {
 	struct ieee80211_key *old_key;
 	unsigned long flags;
--- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
@@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
  */
 void ieee80211_key_link(struct ieee80211_key *key,
 			struct ieee80211_sub_if_data *sdata,
-			struct sta_info *sta);
+			struct sta_info *sta) __requires(RCU);
 void ieee80211_key_free(struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx);
 void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
--- everything.orig/net/mac80211/rx.c	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/rx.c	2008-04-10 15:36:45.000000000 +0200
@@ -1261,7 +1261,7 @@ static bool ieee80211_frame_allowed(stru
  * requires that rx->skb is a frame with ethernet header
  */
 static void
-ieee80211_deliver_skb(struct ieee80211_rx_data *rx)
+ieee80211_deliver_skb(struct ieee80211_rx_data *rx) __requires_rcu
 {
 	struct net_device *dev = rx->dev;
 	struct ieee80211_local *local = rx->local;
@@ -1349,7 +1349,7 @@ ieee80211_deliver_skb(struct ieee80211_r
 }
 
 static ieee80211_rx_result
-ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)
+ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx) __requires_rcu
 {
 	struct net_device *dev = rx->dev;
 	struct ieee80211_local *local = rx->local;
@@ -1466,7 +1466,7 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
 }
 
 static ieee80211_rx_result
-ieee80211_rx_h_data(struct ieee80211_rx_data *rx)
+ieee80211_rx_h_data(struct ieee80211_rx_data *rx) __requires_rcu
 {
 	struct net_device *dev = rx->dev;
 	u16 fc;
@@ -1876,7 +1876,7 @@ static void __ieee80211_rx_handle_packet
 					 struct sk_buff *skb,
 					 struct ieee80211_rx_status *status,
 					 u32 load,
-					 struct ieee80211_rate *rate)
+					 struct ieee80211_rate *rate) __requires_rcu
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	struct ieee80211_sub_if_data *sdata;
@@ -1997,7 +1997,7 @@ static inline u16 seq_sub(u16 sq1, u16 s
 u8 ieee80211_sta_manage_reorder_buf(struct ieee80211_hw *hw,
 				struct tid_ampdu_rx *tid_agg_rx,
 				struct sk_buff *skb, u16 mpdu_seq_num,
-				int bar_req)
+				int bar_req) __requires_rcu
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	struct ieee80211_rx_status status;
@@ -2100,7 +2100,7 @@ u8 ieee80211_sta_manage_reorder_buf(stru
 }
 
 static u8 ieee80211_rx_reorder_ampdu(struct ieee80211_local *local,
-				     struct sk_buff *skb)
+				     struct sk_buff *skb) __requires_rcu
 {
 	struct ieee80211_hw *hw = &local->hw;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
--- everything.orig/net/mac80211/tx.c	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/tx.c	2008-04-10 15:36:45.000000000 +0200
@@ -968,7 +968,7 @@ static ieee80211_tx_result
 __ieee80211_tx_prepare(struct ieee80211_tx_data *tx,
 		       struct sk_buff *skb,
 		       struct net_device *dev,
-		       struct ieee80211_tx_control *control)
+		       struct ieee80211_tx_control *control) __requires_rcu
 {
 	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
 	struct ieee80211_hdr *hdr;
@@ -1047,6 +1047,7 @@ static int ieee80211_tx_prepare(struct i
 				struct sk_buff *skb,
 				struct net_device *mdev,
 				struct ieee80211_tx_control *control)
+	__requires_rcu
 {
 	struct ieee80211_tx_packet_data *pkt_data;
 	struct net_device *dev;

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-wireless
Subject: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Thu, 10 Apr 2008 13:48:13 +0000
Message-ID: <20080410134829.412424000 () sipsolutions ! net>
--------------------
As an example, this annotates mac80211 with the new __requires_rcu.

Not-yet-signed-off-by: Johannes Berg <johannes@sipsolutions.net>
---
 net/mac80211/key.c      |    2 +-
 net/mac80211/key.h      |    2 +-
 net/mac80211/rx.c       |   12 ++++++------
 net/mac80211/sta_info.h |    3 ++-
 net/mac80211/tx.c       |    3 ++-
 5 files changed, 12 insertions(+), 10 deletions(-)

--- everything.orig/net/mac80211/sta_info.h	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/sta_info.h	2008-04-10 15:36:45.000000000 +0200
@@ -321,7 +321,8 @@ static inline enum plink_state sta_plink
 /*
  * Get a STA info, must have be under RCU read lock.
  */
-struct sta_info *sta_info_get(struct ieee80211_local *local, u8 *addr);
+struct sta_info *sta_info_get(struct ieee80211_local *local, u8 *addr) __requires_rcu;
+
 /*
  * Get STA info by index, BROKEN!
  */
--- everything.orig/net/mac80211/key.c	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/key.c	2008-04-10 15:36:45.000000000 +0200
@@ -299,7 +299,7 @@ struct ieee80211_key *ieee80211_key_allo
 
 void ieee80211_key_link(struct ieee80211_key *key,
 			struct ieee80211_sub_if_data *sdata,
-			struct sta_info *sta)
+			struct sta_info *sta) __requires_rcu
 {
 	struct ieee80211_key *old_key;
 	unsigned long flags;
--- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
@@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
  */
 void ieee80211_key_link(struct ieee80211_key *key,
 			struct ieee80211_sub_if_data *sdata,
-			struct sta_info *sta);
+			struct sta_info *sta) __requires(RCU);
 void ieee80211_key_free(struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx);
 void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
--- everything.orig/net/mac80211/rx.c	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/rx.c	2008-04-10 15:36:45.000000000 +0200
@@ -1261,7 +1261,7 @@ static bool ieee80211_frame_allowed(stru
  * requires that rx->skb is a frame with ethernet header
  */
 static void
-ieee80211_deliver_skb(struct ieee80211_rx_data *rx)
+ieee80211_deliver_skb(struct ieee80211_rx_data *rx) __requires_rcu
 {
 	struct net_device *dev = rx->dev;
 	struct ieee80211_local *local = rx->local;
@@ -1349,7 +1349,7 @@ ieee80211_deliver_skb(struct ieee80211_r
 }
 
 static ieee80211_rx_result
-ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)
+ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx) __requires_rcu
 {
 	struct net_device *dev = rx->dev;
 	struct ieee80211_local *local = rx->local;
@@ -1466,7 +1466,7 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
 }
 
 static ieee80211_rx_result
-ieee80211_rx_h_data(struct ieee80211_rx_data *rx)
+ieee80211_rx_h_data(struct ieee80211_rx_data *rx) __requires_rcu
 {
 	struct net_device *dev = rx->dev;
 	u16 fc;
@@ -1876,7 +1876,7 @@ static void __ieee80211_rx_handle_packet
 					 struct sk_buff *skb,
 					 struct ieee80211_rx_status *status,
 					 u32 load,
-					 struct ieee80211_rate *rate)
+					 struct ieee80211_rate *rate) __requires_rcu
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	struct ieee80211_sub_if_data *sdata;
@@ -1997,7 +1997,7 @@ static inline u16 seq_sub(u16 sq1, u16 s
 u8 ieee80211_sta_manage_reorder_buf(struct ieee80211_hw *hw,
 				struct tid_ampdu_rx *tid_agg_rx,
 				struct sk_buff *skb, u16 mpdu_seq_num,
-				int bar_req)
+				int bar_req) __requires_rcu
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	struct ieee80211_rx_status status;
@@ -2100,7 +2100,7 @@ u8 ieee80211_sta_manage_reorder_buf(stru
 }
 
 static u8 ieee80211_rx_reorder_ampdu(struct ieee80211_local *local,
-				     struct sk_buff *skb)
+				     struct sk_buff *skb) __requires_rcu
 {
 	struct ieee80211_hw *hw = &local->hw;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
--- everything.orig/net/mac80211/tx.c	2008-04-10 15:36:20.000000000 +0200
+++ everything/net/mac80211/tx.c	2008-04-10 15:36:45.000000000 +0200
@@ -968,7 +968,7 @@ static ieee80211_tx_result
 __ieee80211_tx_prepare(struct ieee80211_tx_data *tx,
 		       struct sk_buff *skb,
 		       struct net_device *dev,
-		       struct ieee80211_tx_control *control)
+		       struct ieee80211_tx_control *control) __requires_rcu
 {
 	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
 	struct ieee80211_hdr *hdr;
@@ -1047,6 +1047,7 @@ static int ieee80211_tx_prepare(struct i
 				struct sk_buff *skb,
 				struct net_device *mdev,
 				struct ieee80211_tx_control *control)
+	__requires_rcu
 {
 	struct ieee80211_tx_packet_data *pkt_data;
 	struct net_device *dev;

-- 

--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Geert Uytterhoeven <Geert.Uytterhoeven () sonycom ! com>
To: linux-sparse
Subject: Re: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Sat, 12 Apr 2008 08:50:51 +0000
Message-ID: <Pine.LNX.4.64.0804121050160.28120 () vixen ! sonytel ! be>
--------------------
  This message is in MIME format.  The first part should be readable text,
  while the remaining parts are likely unreadable without MIME-aware tools.

---584349381-1964633417-1207990251=:28120
Content-Type: TEXT/PLAIN; charset=UTF-8
Content-Transfer-Encoding: 8BIT

On Thu, 10 Apr 2008, Johannes Berg wrote:
> --- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0200
> +++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
> @@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
>   */
>  void ieee80211_key_link(struct ieee80211_key *key,
>  			struct ieee80211_sub_if_data *sdata,
> -			struct sta_info *sta);
> +			struct sta_info *sta) __requires(RCU);
                                              ^^^^^^^^^^^^^^^
					      __requires_rcu? (for consistency)

With kind regards,

Geert Uytterhoeven
Software Architect

Sony Network and Software Technology Center Europe
The Corporate Village Â· Da Vincilaan 7-D1 Â· B-1935 Zaventem Â· Belgium

Phone:    +32 (0)2 700 8453
Fax:      +32 (0)2 700 8622
E-mail:   Geert.Uytterhoeven@sonycom.com
Internet: http://www.sony-europe.com/

Sony Network and Software Technology Center Europe
A division of Sony Service Centre (Europe) N.V.
Registered office: Technologielaan 7 Â· B-1840 Londerzeel Â· Belgium
VAT BE 0413.825.160 Â· RPR Brussels
Fortis Bank Zaventem Â· Swift GEBABEBB08A Â· IBAN BE39001382358619
---584349381-1964633417-1207990251=:28120--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Geert Uytterhoeven <Geert.Uytterhoeven () sonycom ! com>
To: linux-kernel
Subject: Re: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Sat, 12 Apr 2008 08:50:51 +0000
Message-ID: <Pine.LNX.4.64.0804121050160.28120 () vixen ! sonytel ! be>
--------------------
  This message is in MIME format.  The first part should be readable text,
  while the remaining parts are likely unreadable without MIME-aware tools.

---584349381-1964633417-1207990251=:28120
Content-Type: TEXT/PLAIN; charset=UTF-8
Content-Transfer-Encoding: 8BIT

On Thu, 10 Apr 2008, Johannes Berg wrote:
> --- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0200
> +++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
> @@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
>   */
>  void ieee80211_key_link(struct ieee80211_key *key,
>  			struct ieee80211_sub_if_data *sdata,
> -			struct sta_info *sta);
> +			struct sta_info *sta) __requires(RCU);
                                              ^^^^^^^^^^^^^^^
					      __requires_rcu? (for consistency)

With kind regards,

Geert Uytterhoeven
Software Architect

Sony Network and Software Technology Center Europe
The Corporate Village Â· Da Vincilaan 7-D1 Â· B-1935 Zaventem Â· Belgium

Phone:    +32 (0)2 700 8453
Fax:      +32 (0)2 700 8622
E-mail:   Geert.Uytterhoeven@sonycom.com
Internet: http://www.sony-europe.com/

Sony Network and Software Technology Center Europe
A division of Sony Service Centre (Europe) N.V.
Registered office: Technologielaan 7 Â· B-1840 Londerzeel Â· Belgium
VAT BE 0413.825.160 Â· RPR Brussels
Fortis Bank Zaventem Â· Swift GEBABEBB08A Â· IBAN BE39001382358619
---584349381-1964633417-1207990251=:28120--
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Geert Uytterhoeven <Geert.Uytterhoeven () sonycom ! com>
To: linux-wireless
Subject: Re: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Sat, 12 Apr 2008 08:50:51 +0000
Message-ID: <Pine.LNX.4.64.0804121050160.28120 () vixen ! sonytel ! be>
--------------------
  This message is in MIME format.  The first part should be readable text,
  while the remaining parts are likely unreadable without MIME-aware tools.

---584349381-1964633417-1207990251=:28120
Content-Type: TEXT/PLAIN; charset=UTF-8
Content-Transfer-Encoding: 8BIT

On Thu, 10 Apr 2008, Johannes Berg wrote:
> --- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0200
> +++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
> @@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
>   */
>  void ieee80211_key_link(struct ieee80211_key *key,
>  			struct ieee80211_sub_if_data *sdata,
> -			struct sta_info *sta);
> +			struct sta_info *sta) __requires(RCU);
                                              ^^^^^^^^^^^^^^^
					      __requires_rcu? (for consistency)

With kind regards,

Geert Uytterhoeven
Software Architect

Sony Network and Software Technology Center Europe
The Corporate Village Â· Da Vincilaan 7-D1 Â· B-1935 Zaventem Â· Belgium

Phone:    +32 (0)2 700 8453
Fax:      +32 (0)2 700 8622
E-mail:   Geert.Uytterhoeven@sonycom.com
Internet: http://www.sony-europe.com/

Sony Network and Software Technology Center Europe
A division of Sony Service Centre (Europe) N.V.
Registered office: Technologielaan 7 Â· B-1840 Londerzeel Â· Belgium
VAT BE 0413.825.160 Â· RPR Brussels
Fortis Bank Zaventem Â· Swift GEBABEBB08A Â· IBAN BE39001382358619
---584349381-1964633417-1207990251=:28120--
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Sat, 12 Apr 2008 08:56:29 +0000
Message-ID: <1207990589.13354.123.camel () johannes ! berg>
--------------------

--=-eLdB7X2w7Ui/c5zhNN5e
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Sat, 2008-04-12 at 10:50 +0200, Geert Uytterhoeven wrote:
> On Thu, 10 Apr 2008, Johannes Berg wrote:
> > --- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0=
200
> > +++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
> > @@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
> >   */
> >  void ieee80211_key_link(struct ieee80211_key *key,
> >  			struct ieee80211_sub_if_data *sdata,
> > -			struct sta_info *sta);
> > +			struct sta_info *sta) __requires(RCU);
>                                               ^^^^^^^^^^^^^^^
> 					      __requires_rcu? (for consistency)

Yeah, forgot to fix up this one, I had been playing with it locally
without __requires_rcu first.

Thanks,
johannes

--=-eLdB7X2w7Ui/c5zhNN5e
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAB5PKVg1VMiehFYAQLMAw/+N7qQr2NIQ7Pq2n58zFhvPKFvyswwGy13
PPh2Apm/0qg9eIDfoCUsghs/OkNyclzRitfEcBol/QJzm/8tBpnhhY9F1lF4DZr1
SOeH8tdiM0Ncj+CE27CSVz/8yDbXUZRYPvpQB4z16IfEGW1gyQpQlmCpBy139VUl
Sg48L8DBdX91g7V44UngZKlQmOI/zv99+47X+vXc7vEkQe74I5T+pLt8BHiQhjRg
vmANxijyVFZO6C6WmeQgbZe8CkTyzldzsC+RBKnt51ldWqRMHZvzf9fFPicGUDI7
6/Ugd0fEqW82Sheyvp74uloS+KsV+NoITcaPiS7MoYrdznfM7ggLEBhuxbz6aEeH
a3brZWpTkIetV6OCMpsj/lZ6iXd/g4nWh/60YRwSv5CGZdkMhNR26TTghLK4OkEa
c8OFGxRtvPajDXBnyCbUP9HN2+mZ0aMSTFDfUC/xkH9svZ96vSI64gxwxDXlZbq5
3zyfsCml5YTzq1OYugVE4lSz1BgOr96Vizc6vTYoyvcWoIZPMBcc3xHc/lTyJij3
SM+8KT3YeBsa0yWzAV29NjqOXfyLFNcrmB3BE3L7F4muDskdVu3SPGXOYfoqWaYG
hK7EswuKckAKTDZBQ6tT3h+3kTmXED4zPVMhqvSsdYAVU+cnjbSF0HASsRTmcHZ0
PayuD7eGgxQ=
=wtII
-----END PGP SIGNATURE-----

--=-eLdB7X2w7Ui/c5zhNN5e--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-wireless
Subject: Re: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Sat, 12 Apr 2008 08:56:29 +0000
Message-ID: <1207990589.13354.123.camel () johannes ! berg>
--------------------

--=-eLdB7X2w7Ui/c5zhNN5e
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Sat, 2008-04-12 at 10:50 +0200, Geert Uytterhoeven wrote:
> On Thu, 10 Apr 2008, Johannes Berg wrote:
> > --- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0=
200
> > +++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
> > @@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
> >   */
> >  void ieee80211_key_link(struct ieee80211_key *key,
> >  			struct ieee80211_sub_if_data *sdata,
> > -			struct sta_info *sta);
> > +			struct sta_info *sta) __requires(RCU);
>                                               ^^^^^^^^^^^^^^^
> 					      __requires_rcu? (for consistency)

Yeah, forgot to fix up this one, I had been playing with it locally
without __requires_rcu first.

Thanks,
johannes

--=-eLdB7X2w7Ui/c5zhNN5e
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAB5PKVg1VMiehFYAQLMAw/+N7qQr2NIQ7Pq2n58zFhvPKFvyswwGy13
PPh2Apm/0qg9eIDfoCUsghs/OkNyclzRitfEcBol/QJzm/8tBpnhhY9F1lF4DZr1
SOeH8tdiM0Ncj+CE27CSVz/8yDbXUZRYPvpQB4z16IfEGW1gyQpQlmCpBy139VUl
Sg48L8DBdX91g7V44UngZKlQmOI/zv99+47X+vXc7vEkQe74I5T+pLt8BHiQhjRg
vmANxijyVFZO6C6WmeQgbZe8CkTyzldzsC+RBKnt51ldWqRMHZvzf9fFPicGUDI7
6/Ugd0fEqW82Sheyvp74uloS+KsV+NoITcaPiS7MoYrdznfM7ggLEBhuxbz6aEeH
a3brZWpTkIetV6OCMpsj/lZ6iXd/g4nWh/60YRwSv5CGZdkMhNR26TTghLK4OkEa
c8OFGxRtvPajDXBnyCbUP9HN2+mZ0aMSTFDfUC/xkH9svZ96vSI64gxwxDXlZbq5
3zyfsCml5YTzq1OYugVE4lSz1BgOr96Vizc6vTYoyvcWoIZPMBcc3xHc/lTyJij3
SM+8KT3YeBsa0yWzAV29NjqOXfyLFNcrmB3BE3L7F4muDskdVu3SPGXOYfoqWaYG
hK7EswuKckAKTDZBQ6tT3h+3kTmXED4zPVMhqvSsdYAVU+cnjbSF0HASsRTmcHZ0
PayuD7eGgxQ=
=wtII
-----END PGP SIGNATURE-----

--=-eLdB7X2w7Ui/c5zhNN5e--

--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Re: [RFC 3/3] mac80211: annotate with __requires_rcu
Date: Sat, 12 Apr 2008 08:56:29 +0000
Message-ID: <1207990589.13354.123.camel () johannes ! berg>
--------------------

--=-eLdB7X2w7Ui/c5zhNN5e
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Sat, 2008-04-12 at 10:50 +0200, Geert Uytterhoeven wrote:
> On Thu, 10 Apr 2008, Johannes Berg wrote:
> > --- everything.orig/net/mac80211/key.h	2008-04-10 15:36:20.000000000 +0=
200
> > +++ everything/net/mac80211/key.h	2008-04-10 15:36:45.000000000 +0200
> > @@ -146,7 +146,7 @@ struct ieee80211_key *ieee80211_key_allo
> >   */
> >  void ieee80211_key_link(struct ieee80211_key *key,
> >  			struct ieee80211_sub_if_data *sdata,
> > -			struct sta_info *sta);
> > +			struct sta_info *sta) __requires(RCU);
>                                               ^^^^^^^^^^^^^^^
> 					      __requires_rcu? (for consistency)

Yeah, forgot to fix up this one, I had been playing with it locally
without __requires_rcu first.

Thanks,
johannes

--=-eLdB7X2w7Ui/c5zhNN5e
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASAB5PKVg1VMiehFYAQLMAw/+N7qQr2NIQ7Pq2n58zFhvPKFvyswwGy13
PPh2Apm/0qg9eIDfoCUsghs/OkNyclzRitfEcBol/QJzm/8tBpnhhY9F1lF4DZr1
SOeH8tdiM0Ncj+CE27CSVz/8yDbXUZRYPvpQB4z16IfEGW1gyQpQlmCpBy139VUl
Sg48L8DBdX91g7V44UngZKlQmOI/zv99+47X+vXc7vEkQe74I5T+pLt8BHiQhjRg
vmANxijyVFZO6C6WmeQgbZe8CkTyzldzsC+RBKnt51ldWqRMHZvzf9fFPicGUDI7
6/Ugd0fEqW82Sheyvp74uloS+KsV+NoITcaPiS7MoYrdznfM7ggLEBhuxbz6aEeH
a3brZWpTkIetV6OCMpsj/lZ6iXd/g4nWh/60YRwSv5CGZdkMhNR26TTghLK4OkEa
c8OFGxRtvPajDXBnyCbUP9HN2+mZ0aMSTFDfUC/xkH9svZ96vSI64gxwxDXlZbq5
3zyfsCml5YTzq1OYugVE4lSz1BgOr96Vizc6vTYoyvcWoIZPMBcc3xHc/lTyJij3
SM+8KT3YeBsa0yWzAV29NjqOXfyLFNcrmB3BE3L7F4muDskdVu3SPGXOYfoqWaYG
hK7EswuKckAKTDZBQ6tT3h+3kTmXED4zPVMhqvSsdYAVU+cnjbSF0HASsRTmcHZ0
PayuD7eGgxQ=
=wtII
-----END PGP SIGNATURE-----

--=-eLdB7X2w7Ui/c5zhNN5e--

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [RFC PATCH] Make "bad constant expression" a warning, not an error ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: [RFC PATCH] Make "bad constant expression" a warning, not an error
Date: Fri, 20 Jun 2008 15:08:28 +0000
Message-ID: <1213974508.18379.2.camel () dv>
--------------------
Do the same to "bad integer constant expression".  It's still possible
to continue parsing the code if those are not constant.  To be on the
safe side, assume the actual value to be the largest value for the
type.
---

 expand.c |   12 +++++++-----
 1 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/expand.c b/expand.c
index 032f0c5..12a8989 100644
--- a/expand.c
+++ b/expand.c
@@ -1201,18 +1201,20 @@ static long long __get_expression_value(struct expression *expr, int strict)
 		expression_error(expr, "bad constant expression type");
 		return 0;
 	}
+
+	mask = 1ULL << (ctype->bit_size-1);
+
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		expression_error(expr, "bad constant expression");
-		return 0;
+		warning(expr->pos, "bad constant expression");
+		return mask;
 	}
 	if (strict && bad_integer_constant_expression(expr)) {
-		expression_error(expr, "bad integer constant expression");
-		return 0;
+		warning(expr->pos, "bad integer constant expression");
+		return mask;
 	}
 
 	value = expr->value;
-	mask = 1ULL << (ctype->bit_size-1);
 
 	if (value & mask) {
 		while (ctype->type != SYM_BASETYPE)

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC PATCH] Make "bad constant expression" a warning, not an error
Date: Fri, 20 Jun 2008 22:52:58 +0000
Message-ID: <70318cbf0806201552wb27c4f8v7dad63b1d9438f18 () mail ! gmail ! com>
--------------------
I object.

You should fix it in the parser side. When the parser call get expression
value, it really expect to get back a constant value. Make it return the
largest value on error is just wrong.

Chris

On Fri, Jun 20, 2008 at 8:08 AM, Pavel Roskin <proski@gnu.org> wrote:
> Do the same to "bad integer constant expression".  It's still possible
> to continue parsing the code if those are not constant.  To be on the
> safe side, assume the actual value to be the largest value for the
> type.
> ---
>
>  expand.c |   12 +++++++-----
>  1 files changed, 7 insertions(+), 5 deletions(-)
>
> diff --git a/expand.c b/expand.c
> index 032f0c5..12a8989 100644
> --- a/expand.c
> +++ b/expand.c
> @@ -1201,18 +1201,20 @@ static long long __get_expression_value(struct expression *expr, int strict)
>                expression_error(expr, "bad constant expression type");
>                return 0;
>        }
> +
> +       mask = 1ULL << (ctype->bit_size-1);
> +
>        expand_expression(expr);
>        if (expr->type != EXPR_VALUE) {
> -               expression_error(expr, "bad constant expression");
> -               return 0;
> +               warning(expr->pos, "bad constant expression");
> +               return mask;
>        }
>        if (strict && bad_integer_constant_expression(expr)) {
> -               expression_error(expr, "bad integer constant expression");
> -               return 0;
> +               warning(expr->pos, "bad integer constant expression");
> +               return mask;
>        }
>
>        value = expr->value;
> -       mask = 1ULL << (ctype->bit_size-1);
>
>        if (value & mask) {
>                while (ctype->type != SYM_BASETYPE)
>
> --
> Regards,
> Pavel Roskin
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: assertion failure in flow.c:804 (changed) building kernel/sched.c ===

From: Roel Kluin <12o3l () tiscali ! nl>
To: linux-sparse
Subject: assertion failure in flow.c:804 (changed) building kernel/sched.c
Date: Mon, 03 Mar 2008 13:06:00 +0000
Message-ID: <47CBF7B8.5060303 () tiscali ! nl>
--------------------
Building the linux kernel (git, linus' tree) with sparse enabled I get the
following assertion failure:

...
/home/roel/dnld/src/kernel/git/linux-2.6/kernel/sched.c:6228:25: error: cannot size expression
/home/roel/dnld/src/kernel/git/linux-2.6/kernel/sched.c:8255:43: error: cannot size expression
sparse: flow.c:804: rewrite_parent_branch: Assertion `changed' failed.
/bin/sh: line 1: 13021 Aborted                 sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__i386__ -nostdinc -isystem /usr/lib/gcc/i486-slackware-linux/4.1.2/include -Wp,-MD,kernel/.sched.o.d -nostdinc -isystem /usr/lib/gcc/i486-slackware-linux/4.1.2/include -D__KERNEL__ -Iinclude -Iinclude2 -I/home/roel/dnld/src/kernel/git/linux-2.6/include -include include/linux/autoconf.h -I/home/roel/dnld/src/kernel/git/linux-2.6/kernel -Ikernel -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Os -fno-stack-protector -m32 -msoft-float -mregparm=3 -freg-struct-return -mpreferred-stack-boundary=2 -march=i686 -mtune=i686 -ffreestanding -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -I/home/roel/dnld/src/kernel/git/linux-2.6/include/asm-x86/mach-default -Iinclude/asm-x86/mach-default -fno-omit-frame-po
inter -fno-optimize-sibling-calls -g -Wdeclaration-after-statement -Wno-pointer-sign -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sched)" -D"KBUILD_MODNAME=KBUILD_STR(sched)" /home/roel/dnld/src/kernel/git/linux-2.6/kernel/sched.c
make[2]: *** [kernel/sched.o] Error 134
make[1]: *** [kernel] Error 2
make: *** [sub-make] Error 2
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: confusing shift warning ===

From: "Marko Kreen" <markokr () gmail ! com>
To: linux-sparse
Subject: Re: confusing shift warning
Date: Fri, 25 Apr 2008 08:03:09 +0000
Message-ID: <e51f66da0804250103y4c5abbaby2c8a43db7ba5d04f () mail ! gmail ! com>
--------------------
On 4/25/08, Marko Kreen <markokr@gmail.com> wrote:
> Platform: x64_64 linux, uint64_t -> unsigned long
>  Sparse: today's git (6dcc36a)

Oh, and another warning:

#include <sys/socket.h> gives:

 /usr/include/bits/socket.h:159:5: warning: constant
9223372036854775807L is so big it is long long

I used to ignore it as it was not in my code, but its probably same thing.

Ubuntu 8.04
gcc 4:4.2.3-1ubuntu3
glibc 2.7-10ubuntu3
linux-headers - 2.6.24-16.30

-- 
marko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Marko Kreen" <markokr () gmail ! com>
To: linux-sparse
Subject: Re: confusing shift warning
Date: Fri, 25 Apr 2008 08:34:58 +0000
Message-ID: <e51f66da0804250134g7f05cc8fp9011d508f49295e3 () mail ! gmail ! com>
--------------------
On 4/25/08, Pavel Roskin <proski@gnu.org> wrote:
> Quoting Marko Kreen <markokr@gmail.com>:
>
>
> > Platform: x64_64 linux, uint64_t -> unsigned long
> > Sparse: today's git (6dcc36a)
> >
>  ...
>
> > Guess - somewhere is hardwired that "long" == "32-bit"?
> >
>
>  Of course not.  But -m64 should be specified to enable 64-bit type sizes.
>
>
> > For reference:
> > $ cgcc -v -c test.c
> > sparse -v -c test.c -Dx86_64=1 -D__x86_64=1 -D__x86_64__=1
> >
>  ...
>
>  cgcc fails to add -m64.  It must be a bug in cgcc.  This would not produce
> the warning:
>
>  cgcc -m64 -no-compile Test.c

Ok, that somewhat explains it.  But:

    } elsif ($spec eq 'x86_64') {
        return (' -Dx86_64=1 -D__x86_64=1 -D__x86_64__=1' .
                &integer_types (8, 16, 32, $m32 ? 32 : 64, 64) .
                &float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
                &define_size_t ($m32 ? "unsigned int" : "long unsigned int"));

It seems that cgcc defaults to 64-bit on x86_64, but sparse to 32-bit.
Isn't it sparse bug then?  Shouldnt it follow platform defaults?

-- 
marko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Marko Kreen" <markokr () gmail ! com>
To: linux-sparse
Subject: Re: confusing shift warning
Date: Fri, 25 Apr 2008 13:37:29 +0000
Message-ID: <e51f66da0804250637i4dff4c64p9d22a1162df14eb4 () mail ! gmail ! com>
--------------------
On 4/25/08, Pavel Roskin <proski@gnu.org> wrote:
> Quoting Marko Kreen <markokr@gmail.com>:
> > Patch attached.
>
>  NACK.  $m64 is only set if "-m64" was explicitly passed to cgcc.
>
>  It looks like cgcc code expect sparse to handle it, and sparse expects it
> from cgcc.

Do you mean the variables are not set?  But they are:

  my $m32 = 0;
  my $m64 = 0;

Or do you mean I cannot assume one of them as set, unless
overrided on command line?  But other sections (spact, i86, ppc)
do exactly that?

Or do you mean I cannot give extra -mXX arguement unless given by user?
But as you said, sparse (by policy) wont follow platform default,
but I want cgcc to follow it.  How do I achieve that then?

-- 
marko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Marko Kreen" <markokr () gmail ! com>
To: linux-sparse
Subject: Re: confusing shift warning
Date: Fri, 25 Apr 2008 14:37:01 +0000
Message-ID: <e51f66da0804250737r38582879s7dd41ee792756753 () mail ! gmail ! com>
--------------------
On 4/25/08, Pavel Roskin <proski@gnu.org> wrote:
> Quoting Marko Kreen <markokr@gmail.com>:
> > On 4/25/08, Pavel Roskin <proski@gnu.org> wrote:
> > > Quoting Marko Kreen <markokr@gmail.com>:
> > > > Patch attached.
> > >
> > >  NACK.  $m64 is only set if "-m64" was explicitly passed to cgcc.
> > >
> > >  It looks like cgcc code expect sparse to handle it, and sparse expects
> it
> > > from cgcc.
> >
> > Do you mean the variables are not set?  But they are:
> >
> >  my $m32 = 0;
> >  my $m64 = 0;
>
>  I mean, they are both 0 unless -m32 or -m64 is specified.

No, see other sections - they assume one of them is set unless overrided.

> > Or do you mean I cannot assume one of them as set, unless
> > overrided on command line?  But other sections (spact, i86, ppc)
> > do exactly that?
>
>  You cannot assume either of them to be 1 until cgcc is fixed.

But how should the fix look like if you don't like mine?

> > Or do you mean I cannot give extra -mXX arguement unless given by user?
>
>  No, I don't mean it.  It should be fine to add the -mXX argument.

-- 
marko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: confusing shift warning
Date: Fri, 25 Apr 2008 16:04:45 +0000
Message-ID: <1209139485.11744.25.camel () dv>
--------------------
On Fri, 2008-04-25 at 17:37 +0300, Marko Kreen wrote:

> >  I mean, they are both 0 unless -m32 or -m64 is specified.
> 
> No, see other sections - they assume one of them is set unless overrided.

If you are fixing a bug, you cannot rely on the code being correct.  Try
printing those variables:

printf("m32=%d, m64=%d\n", $m32, $m64);

It will be two zeroes.

> > > Or do you mean I cannot assume one of them as set, unless
> > > overrided on command line?  But other sections (spact, i86, ppc)
> > > do exactly that?
> >
> >  You cannot assume either of them to be 1 until cgcc is fixed.
> 
> But how should the fix look like if you don't like mine?

Well, it looks like cgcc is seriously broken.  In particular, it would
define x86_64 even if -m32 is specified, but it should define i386
instead.

Also, cgcc looks at uname output to determine the target CPU.  That
would default to 64 bit if a 32-bit system runs on a 64-bit kernel.  I
think cgcc should be running gcc instead to dump the machine settings.
I realize that it might be slower, but correctness is important here.
On the other hand, I'm not sure if we can rely on having gcc installed.

I would probably introduce a variable that would hold the memory model.
It could be ILP32 or LP64, but we could eventually support LLP64 (win64)
and even LP32 (win16).  It could be determined based on -m32/-m64
switches and uname output, but be could switch to "gcc -dumpmachine"
later.

The architecture would be adjusted based on the selected memory model.
And then it would be passed to add_specs().

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Marko Kreen" <markokr () gmail ! com>
To: linux-sparse
Subject: Re: confusing shift warning
Date: Fri, 25 Apr 2008 17:26:07 +0000
Message-ID: <e51f66da0804251026y4c6fbc25scedf04ab6c7dd6a0 () mail ! gmail ! com>
--------------------
On 4/25/08, Pavel Roskin <proski@gnu.org> wrote:
> On Fri, 2008-04-25 at 17:37 +0300, Marko Kreen wrote:
>  > >  I mean, they are both 0 unless -m32 or -m64 is specified.
>  >
>  > No, see other sections - they assume one of them is set unless overrided.
>
> If you are fixing a bug, you cannot rely on the code being correct.  Try
>  printing those variables:
>
>  printf("m32=%d, m64=%d\n", $m32, $m64);
>
>  It will be two zeroes.

I think you have misunderstood the point of the variables - they
only signify whether either argument was given on command line,
nothing more.  Each arch defaults implicitly to either of them,
so it needs to check if the other one was given, overriding the default.

>  > > > Or do you mean I cannot assume one of them as set, unless
>  > > > overrided on command line?  But other sections (spact, i86, ppc)
>  > > > do exactly that?
>  > >
>  > >  You cannot assume either of them to be 1 until cgcc is fixed.
>  >
>  > But how should the fix look like if you don't like mine?
>
> Well, it looks like cgcc is seriously broken.  In particular, it would
>  define x86_64 even if -m32 is specified, but it should define i386
>  instead.

You may be right here.  Seems like the x86_64 arch was tested only
with kernel compiles with -m64 always given.

>  Also, cgcc looks at uname output to determine the target CPU.  That
>  would default to 64 bit if a 32-bit system runs on a 64-bit kernel.  I
>  think cgcc should be running gcc instead to dump the machine settings.
>  I realize that it might be slower, but correctness is important here.
>  On the other hand, I'm not sure if we can rely on having gcc installed.
>
>  I would probably introduce a variable that would hold the memory model.
>  It could be ILP32 or LP64, but we could eventually support LLP64 (win64)
>  and even LP32 (win16).  It could be determined based on -m32/-m64
>  switches and uname output, but be could switch to "gcc -dumpmachine"
>  later.
>
>  The architecture would be adjusted based on the selected memory model.
>  And then it would be passed to add_specs().

Ok, this is somewhat of out my league.  But I think that having good
default and forcing user to use -mX for non-default case is good enough.

-- 
marko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: context imbalance false positive sparse warnings ===

From: "Steve French" <smfrench () gmail ! com>
To: linux-kernel
Subject: context imbalance false positive sparse warnings
Date: Tue, 19 Aug 2008 21:19:58 +0000
Message-ID: <524f69650808191419j3e3a261dj9757ae4ea7a682bf () mail ! gmail ! com>
--------------------
Just building one directory of the kernel (./fs/*.c), ie "make bzImage
C=1" generates more than 200 sparse warnings similar to
        warning: context imbalance in 'set_task_ioprio': wrong count at exit

Even the simplest use cases throw this error e.g. fs/super.c line 162-164:

static void put_super(struct super_block *sb)
{
        spin_lock(&sb_lock);
        __put_super(sb);
        spin_unlock(&sb_lock);
}


It doesn't look like sparse has been fixed in a few months, unless the
sparse tool repository has moved from the
     /pub/scm / devel/sparse/sparse.git
directory on git.kernel.org

Is there a way to turn just this warning off (the thousands of context
imbalance messages generated by the kernel build make it harder to see
real errors which sparse could catch)?



-- 
Thanks,

Steve
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "Steve French" <smfrench () gmail ! com>
To: linux-sparse
Subject: context imbalance false positive sparse warnings
Date: Tue, 19 Aug 2008 21:47:29 +0000
Message-ID: <524f69650808191447o62a421c3n65f3938c9fc28dd7 () mail ! gmail ! com>
--------------------
Just building one directory of the kernel (./fs/*.c), ie "make bzImage
C=1" generates more than 200 sparse warnings similar to
       warning: context imbalance in 'set_task_ioprio': wrong count at exit

Even the simplest use cases throw this error e.g. fs/super.c line 162-164:

static void put_super(struct super_block *sb)
{
       spin_lock(&sb_lock);
       __put_super(sb);
       spin_unlock(&sb_lock);
}


It doesn't look like sparse has been fixed in a few months, unless the
sparse tool repository has moved from the
    /pub/scm / devel/sparse/sparse.git
directory on git.kernel.org

Is there a way to turn just this warning off (the thousands of context
imbalance messages generated by the kernel build make it harder to see
real errors which sparse could catch)?


-- 
Thanks,

Steve
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Stalin Kenny" <stalinlinux () gmail ! com>
To: linux-sparse
Subject: Re: context imbalance false positive sparse warnings
Date: Tue, 19 Aug 2008 22:00:14 +0000
Message-ID: <8cef9d540808191500n10fa910eo674c8b8f2dd5b612 () mail ! gmail ! com>
--------------------
> Even the simplest use cases throw this error e.g. fs/super.c line 162-164:
>
> static void put_super(struct super_block *sb)
> {
>       spin_lock(&sb_lock);
>       __put_super(sb);
>       spin_unlock(&sb_lock);
> }

What is the sparse error when you call this function ?


On 8/19/08, Steve French <smfrench@gmail.com> wrote:
> Just building one directory of the kernel (./fs/*.c), ie "make bzImage
> C=1" generates more than 200 sparse warnings similar to
>       warning: context imbalance in 'set_task_ioprio': wrong count at exit
>
> Even the simplest use cases throw this error e.g. fs/super.c line 162-164:
>
> static void put_super(struct super_block *sb)
> {
>       spin_lock(&sb_lock);
>       __put_super(sb);
>       spin_unlock(&sb_lock);
> }
>
>
> It doesn't look like sparse has been fixed in a few months, unless the
> sparse tool repository has moved from the
>    /pub/scm / devel/sparse/sparse.git
> directory on git.kernel.org
>
> Is there a way to turn just this warning off (the thousands of context
> imbalance messages generated by the kernel build make it harder to see
> real errors which sparse could catch)?
>
>
> --
> Thanks,
>
> Steve
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: context imbalance false positive sparse warnings
Date: Tue, 19 Aug 2008 22:26:09 +0000
Message-ID: <1219184769.17033.95.camel () brick>
--------------------
On Tue, 2008-08-19 at 17:22 -0500, Steve French wrote:
> On Tue, Aug 19, 2008 at 5:00 PM, Stalin Kenny <stalinlinux@gmail.com> wrote:
> >> Even the simplest use cases throw this error e.g. fs/super.c line 162-164:
> >>
> >> static void put_super(struct super_block *sb)
> >> {
> >>       spin_lock(&sb_lock);
> >>       __put_super(sb);
> >>       spin_unlock(&sb_lock);
> >> }
> >
> > What is the sparse error when you call this function ?
> CHECK   fs/super.c
> fs/super.c:164:2: warning: context imbalance in 'put_super': wrong count at exit
> fs/super.c:164:2:    context 'lock': wanted 0, got 1
> 
> 

Johannes Berg had a 9-patch series that improved this somewhat, but they had
some bugs in them (crashes).  But I've been running with them anyway as they
do improve cases like this significantly.

Harvey

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: context imbalance false positive sparse warnings
Date: Wed, 10 Sep 2008 07:47:11 +0000
Message-ID: <1221032831.12266.8.camel () johannes ! berg>
--------------------

--=-HeyPaPgrJcGGC+Eka914
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Tue, 2008-08-19 at 15:26 -0700, Harvey Harrison wrote:
> On Tue, 2008-08-19 at 17:22 -0500, Steve French wrote:
> > On Tue, Aug 19, 2008 at 5:00 PM, Stalin Kenny <stalinlinux@gmail.com> w=
rote:
> > >> Even the simplest use cases throw this error e.g. fs/super.c line 16=
2-164:
> > >>
> > >> static void put_super(struct super_block *sb)
> > >> {
> > >>       spin_lock(&sb_lock);
> > >>       __put_super(sb);
> > >>       spin_unlock(&sb_lock);
> > >> }
> > >
> > > What is the sparse error when you call this function ?
> > CHECK   fs/super.c
> > fs/super.c:164:2: warning: context imbalance in 'put_super': wrong coun=
t at exit
> > fs/super.c:164:2:    context 'lock': wanted 0, got 1
> >=20
> >=20
>=20
> Johannes Berg had a 9-patch series that improved this somewhat, but they =
had
> some bugs in them (crashes).  But I've been running with them anyway as t=
hey
> do improve cases like this significantly.

I've just sent out a fixed version and with it I get no errors on
fs/super.c when I apply this small fixup:

diff --git a/fs/super.c b/fs/super.c
index e931ae9..6810845 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -201,7 +201,7 @@ EXPORT_SYMBOL(deactivate_super);
  *	success, 0 if we had failed (superblock contents was already dead or
  *	dying when grab_super() had been called).
  */
-static int grab_super(struct super_block *s) __releases(sb_lock)
+static int grab_super(struct super_block *s) __releases(&sb_lock)
 {
 	s->s_count++;
 	spin_unlock(&sb_lock);

johannes

--=-HeyPaPgrJcGGC+Eka914
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJIx3t7AAoJEKVg1VMiehFYSKMP/0I+EvSTYrmnC9beBQ4MFEn1
F1LQttZ5AKuMPvjygJLlGeWj6XbVfWTMXeqcTpLutvgoZanmI7LP4Mnr4bdZ81sU
ekApB4wqf8DTTb4tIHoRkoxPOzuesLAM6KNl9YI9lC85LvIEa/Sa4ShSfsB4Qnr8
pnFU/lcegFXBHwfT60nJ4jkJpMdSXibYMIXhul5eJsP8LHYu7CscuUT9PFNsHTT0
X/SG6FR0W5NEudwO3/6Atu9WI2yIGfhWqH/o9ThqQmHeb28e8YQHNNwTPQp+HFfx
i4NiZW4ztNWGiLPxRgmS65FaW6VzL8ZoQEUSYJ2N8wAzz3/dvn+oLHV1ObqAXYNj
uVoNn32x0cXOjf94GQnf9dyVTgazFgER5U2zNa0Gp9XJigN+j70k9a2oDWI+4QL5
i5B9N+eeWi3qi5+XBg8s8XydTJeqck5mCWoKGHNTBu+c0QPZBxsmxgTWG5idOqXO
stGXO/PUpQGo3pczKS5MCDwnu3NqIvM4M5ivMcWRrmewcQRr1aTn2xNoRk4tCPa4
7JoYgwNNJ87vwe1qMpDAy9dKke1AuD72lOuIX+EuJkjJtcl9+VvXw4kZSWf7H7Vj
taicUL+NuKydpkHZ3OAug2mxNFaU02ySZJmDtsmOa7o7eUZaH/KWByBfkZSaSEh5
tsy4JuFBW5xxjOtBw+/P
=6rRF
-----END PGP SIGNATURE-----

--=-HeyPaPgrJcGGC+Eka914--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: context imbalance false positive sparse warnings
Date: Wed, 10 Sep 2008 07:47:11 +0000
Message-ID: <1221032831.12266.8.camel () johannes ! berg>
--------------------

--=-HeyPaPgrJcGGC+Eka914
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Tue, 2008-08-19 at 15:26 -0700, Harvey Harrison wrote:
> On Tue, 2008-08-19 at 17:22 -0500, Steve French wrote:
> > On Tue, Aug 19, 2008 at 5:00 PM, Stalin Kenny <stalinlinux@gmail.com> w=
rote:
> > >> Even the simplest use cases throw this error e.g. fs/super.c line 16=
2-164:
> > >>
> > >> static void put_super(struct super_block *sb)
> > >> {
> > >>       spin_lock(&sb_lock);
> > >>       __put_super(sb);
> > >>       spin_unlock(&sb_lock);
> > >> }
> > >
> > > What is the sparse error when you call this function ?
> > CHECK   fs/super.c
> > fs/super.c:164:2: warning: context imbalance in 'put_super': wrong coun=
t at exit
> > fs/super.c:164:2:    context 'lock': wanted 0, got 1
> >=20
> >=20
>=20
> Johannes Berg had a 9-patch series that improved this somewhat, but they =
had
> some bugs in them (crashes).  But I've been running with them anyway as t=
hey
> do improve cases like this significantly.

I've just sent out a fixed version and with it I get no errors on
fs/super.c when I apply this small fixup:

diff --git a/fs/super.c b/fs/super.c
index e931ae9..6810845 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -201,7 +201,7 @@ EXPORT_SYMBOL(deactivate_super);
  *	success, 0 if we had failed (superblock contents was already dead or
  *	dying when grab_super() had been called).
  */
-static int grab_super(struct super_block *s) __releases(sb_lock)
+static int grab_super(struct super_block *s) __releases(&sb_lock)
 {
 	s->s_count++;
 	spin_unlock(&sb_lock);

johannes

--=-HeyPaPgrJcGGC+Eka914
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJIx3t7AAoJEKVg1VMiehFYSKMP/0I+EvSTYrmnC9beBQ4MFEn1
F1LQttZ5AKuMPvjygJLlGeWj6XbVfWTMXeqcTpLutvgoZanmI7LP4Mnr4bdZ81sU
ekApB4wqf8DTTb4tIHoRkoxPOzuesLAM6KNl9YI9lC85LvIEa/Sa4ShSfsB4Qnr8
pnFU/lcegFXBHwfT60nJ4jkJpMdSXibYMIXhul5eJsP8LHYu7CscuUT9PFNsHTT0
X/SG6FR0W5NEudwO3/6Atu9WI2yIGfhWqH/o9ThqQmHeb28e8YQHNNwTPQp+HFfx
i4NiZW4ztNWGiLPxRgmS65FaW6VzL8ZoQEUSYJ2N8wAzz3/dvn+oLHV1ObqAXYNj
uVoNn32x0cXOjf94GQnf9dyVTgazFgER5U2zNa0Gp9XJigN+j70k9a2oDWI+4QL5
i5B9N+eeWi3qi5+XBg8s8XydTJeqck5mCWoKGHNTBu+c0QPZBxsmxgTWG5idOqXO
stGXO/PUpQGo3pczKS5MCDwnu3NqIvM4M5ivMcWRrmewcQRr1aTn2xNoRk4tCPa4
7JoYgwNNJ87vwe1qMpDAy9dKke1AuD72lOuIX+EuJkjJtcl9+VvXw4kZSWf7H7Vj
taicUL+NuKydpkHZ3OAug2mxNFaU02ySZJmDtsmOa7o7eUZaH/KWByBfkZSaSEh5
tsy4JuFBW5xxjOtBw+/P
=6rRF
-----END PGP SIGNATURE-----

--=-HeyPaPgrJcGGC+Eka914--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: contextual attributes ===

From: Yoann Padioleau <padator () wanadoo ! fr>
To: linux-sparse
Subject: contextual attributes
Date: Mon, 17 Nov 2008 21:47:28 +0000
Message-ID: <8763mmuirz.fsf () aryx ! cs ! uiuc ! edu>
--------------------


Hi, 

Is it possible by using the __attribute((context(x,y)) sparse
attribute to enforce statically that all the callers of 
certain functions do certain actions such as disabling interrupts ?

I would like an attribute like __assume_disabled_interrupt and 
have such programs:


int __assume_disabled_interrupt    
startpoint() 
{
	return 1;
}


int f1ok()
{
	spin_lock_irq();
	startpoint();
	spin_unlock_irq();
}


int f1bad()
{
	startpoint();
}

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: contextual attributes
Date: Mon, 17 Nov 2008 22:10:28 +0000
Message-ID: <1226959828.4014.4.camel () johannes ! berg>
--------------------
On Mon, 2008-11-17 at 15:47 -0600, Yoann Padioleau wrote:

> Is it possible by using the __attribute((context(x,y)) sparse
> attribute to enforce statically that all the callers of 
> certain functions do certain actions such as disabling interrupts ?

In theory yes, but only half my patches got merged so no. If you search
the list you'll find a set of patches from myself that allow you to do
this, see below.

I have asked that those patches that got merged are reverted for the
time being until we can work on a decent implementation, but that hasn't
happen either so the current sparse git tree is fairly broken wrt.
context attributes...

> int __assume_disabled_interrupt    
> startpoint() 
> {
> 	return 1;
> }
> 
> 
> int f1ok()
> {
> 	spin_lock_irq();
> 	startpoint();
> 	spin_unlock_irq();
> }
> 
> 
> int f1bad()
> {
> 	startpoint();
> }

You'd have to annotate startpoint() with
__attribute__((context(irqsoff,1,1)))

and spin_lock_irq() with __attribute__((context(irqsoff,0,1))) and 1,0
for unlock, in addition to the regular locks.

[or something like that, the syntax isn't firm in my mind right now]

johannes

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: feature-request ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: feature-request
Date: Mon, 25 Feb 2008 02:48:45 +0000
Message-ID: <1203907725.25518.17.camel () dv>
--------------------

On Sat, 2008-02-23 at 14:39 +0100, Pierre Habouzit wrote:
> While I'm at it, there is this feature I'd like to see in sparse: I'd
> love to be able to ask it to ignore errors that are located in some
> specific paths (like /usr/include e.g.). For now I'm doing that through
> a custom script, but it'd be simpler for me if it does it natively.  The
> reason is that I don't want to patch third party libraries headers.

We probably don't want to ignore _errors_, as they can indicate that the
parser doesn't understand the code correctly.  Ignoring warnings would
be a good idea.

Perhaps a simpler approach would be to turn off warnings in any files
included using angle brackets.

gcc doesn't report warnings in system files by default, but it can be
enabled with -Wsystem-headers.  Since sparse is primarily for the
kernel, I think the default should be to check the headers (as they are
part of the kernel), but sparse could support -Wno-system-headers.

Alternatively, sparse could have a userspace mode that would disable
warnings in system headers by default (unless -Wsystem-headers is used).
The kernel mode could be made stricter for the kernel without affecting
the userspace.

-- 
Regards,
Pavel Roskin
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: feature-request
Date: Mon, 25 Feb 2008 14:22:49 +0000
Message-ID: <1203949369.802.22.camel () dv>
--------------------
On Mon, 2008-02-25 at 09:54 +0100, Pierre Habouzit wrote:

> > Perhaps a simpler approach would be to turn off warnings in any files
> > included using angle brackets.
> 
>   Nope, that's not good, because I use angle brackets to #include files
> from my projects when I use internally in-tree headers that will in the
> end be public.
> 
>   I'd rather like to ask to ignore warnings for example, for file under
> /usr/include and /usr/lib/gcc/

You are right.  I think sparse should try to follow gcc in this regard.
There are three hardcoded directories in pre-process.c
(/usr/include, /usr/local/include and the gcc include directory).  Maybe
they should be considered system include directories.

-- 
Regards,
Pavel Roskin
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: for (int i = expr; ....) ===

From: Pierre Habouzit <pierre.habouzit () m4x ! org>
To: linux-sparse
Subject: Re: for (int i = expr; ....)
Date: Sat, 23 Feb 2008 13:33:30 +0000
Message-ID: <20080223133330.GA10967 () artemis ! madism ! org>
--------------------

--+QahgC5+KEYLbs62
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Fri, Feb 22, 2008 at 08:26:30PM +0000, Chris Li wrote:
> On Thu, Feb 21, 2008 at 7:05 AM, Pierre Habouzit
> <pierre.habouzit@m4x.org> wrote:
> > Sparse doesn't support the C99 construct `for (int i =3D expr; ....)` p=
roperly.
> >  for example, the following C code:
> >
> >     #include <stdlib.h>
> >
> >     int main(void)
> >     {
> >         for (int i =3D atoi("12"); i < 10; i++);
> >         return 0;
> >     }
> >
> >  make sparse spit:
> >
> >     $ sparse -Wall test.c
> >     test.c:5:22: warning: call with no type!
> >
> >  In fact sparse doesn't support 'expr' to be a complex enough expression
> >  (expressions that can be folded work, but not any other afaict).
>=20
> Nah, sparse supports expression in initializer all right.
> It just need to evaluate them to give it the correct ctype.
>=20
> Please try the this one line patch I attached.

  Works for me, thanks.


--=20
=C2=B7O=C2=B7  Pierre Habouzit
=C2=B7=C2=B7O                                                madcoder@debia=
n.org
OOO                                                http://www.madism.org

--+QahgC5+KEYLbs62
Content-Type: application/pgp-signature
Content-Disposition: inline

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQBHwCCqvGr7W6HudhwRAkr4AKCUly4QqE9lv6EIWzFvgg8NBlhAEwCeNip5
Qw+gzhnPw2qHWc+gptUNn6A=
=XhHj
-----END PGP SIGNATURE-----

--+QahgC5+KEYLbs62--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: four sparse patches ===

From: Josh Triplett <josh () kernel ! org>
To: linux-sparse
Subject: Re: four sparse patches
Date: Sat, 05 Apr 2008 10:13:30 +0000
Message-ID: <47F750CA.1090307 () kernel ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig9AA6AB33AF9873DD839D65D4
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Geoff Johnstone wrote:
>>> I've attached four patches that I've written for sparse to
>>> use it for a userland project.

Regarding Wmix-decl-code.diff, I agree that that warning definitely
needs an option controlling it. but GCC already has that option and
calls it "-Wdeclaration-after-statement", so matching GCC's name seems
potentially useful.  (However, I can imagine corner cases where it
might prove problematic, such as wanting to pass that option to GCC
and not Sparse or vice versa.)  Also, I agree that the default should
depend on the C standard in use, and I see no compatibility reason why
the warning should remain for code that explicitly asks for C99.
Thus, I haven't applied this version of the patch.  I'd love to apply
an updated version with those two changes.

Regarding incomplete structs, your patch seems reasonable as far as I
know, and it doesn't break the test suite, so I've applied and pushed
it.  Per your concerns, if this patch doesn't represent the correct
fix, the code can change later when we have a test case that breaks
with this patch.  Please do consider writing a patch for a new test
case based on your example.

Your argument parsing for -ansi and -std=3D looks great to me.  Applied
and pushed.

The new builtins for fortify handling seem fine.  Applied and pushed.

Thanks for your patches.

- Josh Triplett


--------------enig9AA6AB33AF9873DD839D65D4
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFH91DKGJuZRtD+evsRApxQAKCjI7iB7S5iCfr4daxAXTShpo6R9gCfa+hi
1Ztyf/EUGxyqUgnwYu3CL5s=
=xAnQ
-----END PGP SIGNATURE-----

--------------enig9AA6AB33AF9873DD839D65D4--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Geoff Johnstone" <geoffsheep.johnstonefrog () googlemail ! com>
To: linux-sparse
Subject: Re: four sparse patches
Date: Sat, 12 Apr 2008 10:57:23 +0000
Message-ID: <32e600e90804120357k5923dd47xfcb253bf1c390225 () mail ! gmail ! com>
--------------------
------=_Part_5454_6374912.1207997843121
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

>  Regarding Wmix-decl-code.diff, I agree that that warning definitely
>  needs an option controlling it. but GCC already has that option and
>  calls it "-Wdeclaration-after-statement", so matching GCC's name
>  seems potentially useful. (However, I can imagine corner cases
>  where it might prove problematic, such as wanting to pass that
>  option to GCC and not Sparse or vice versa.) Also, I agree that the
>  default should depend on the C standard in use, and I see no
>  compatibility reason why the warning should remain for code that
>  explicitly asks for C99.  Thus, I haven't applied this version of
>  the patch.

I've attached a revised version of the patch that:
 - Renames the option to -Wdeclaration-after-statement, as per GCC
   (wasn't hitherto aware of that gcc option).
 - Defaults based on chosen C dialect.
 - Adds a few tests. (I'll do a separate patch for tests for the
   incomplete struct patch.)
 - Was made wrt the git trunk at about 11:30 UTC on 12th April.

Geoff.

------=_Part_5454_6374912.1207997843121
Content-Type: application/octet-stream;
 name=Wdeclaration-after-statement.diff
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fey2grfx1
Content-Disposition: attachment; filename=Wdeclaration-after-statement.diff

VGhpcyBhZGRzIC1XW25vLV1kZWNsYXJhdGlvbi1hZnRlci1zdGF0ZW1lbnQsIHdoaWNoIG1ha2Vz
IHdhcm5pbmdzIGFib3V0CmRlY2xhcmF0aW9ucyBhZnRlciBzdGF0ZW1lbnRzIGEgY29tbWFuZC1s
aW5lIG9wdGlvbi4gKFRoZSBjb2RlIHRvIGltcGxlbWVudAp0aGUgd2FybmluZyB3YXMgYWxyZWFk
eSBpbiB0aGVyZSB2aWEgYSAjZGVmaW5lOyB0aGUgcGF0Y2gganVzdCBleHBvc2VzIGl0CmF0IHJ1
bnRpbWUuKSBSYXRpb25hbGU6IEM5OSBhbGxvd3MgdGhlbSwgQzg5IGRvZXNuJ3QuCgpTaWduZWQt
b2ZmLWJ5OiBHZW9mZiBKb2huc3RvbmUgPGdlb2ZmU0hFRVAuam9obnN0b25lRlJPR0Bnb29nbGVt
YWlsLmNvbT4KCmRpZmYgLS1naXQgYS9saWIuYyBiL2xpYi5jCmluZGV4IDc1YWZkYjcuLjBhYmNj
OWEgMTAwNjQ0Ci0tLSBhL2xpYi5jCisrKyBiL2xpYi5jCkBAIC0yMDgsNiArMjA4LDcgQEAgaW50
IFd0cmFuc3BhcmVudF91bmlvbiA9IDE7CiBpbnQgV3R5cGVzaWduID0gMDsKIGludCBXdW5kZWYg
PSAwOwogaW50IFd1bmluaXRpYWxpemVkID0gMTsKK2ludCBXZGVjbGFyYXRpb25hZnRlcnN0YXRl
bWVudCA9IC0xOwogCiBpbnQgZGJnX2VudHJ5ID0gMDsKIGludCBkYmdfZGVhZCA9IDA7CkBAIC0z
NzIsNiArMzczLDcgQEAgc3RhdGljIGNvbnN0IHN0cnVjdCB3YXJuaW5nIHsKIAl7ICJ0eXBlc2ln
biIsICZXdHlwZXNpZ24gfSwKIAl7ICJ1bmRlZiIsICZXdW5kZWYgfSwKIAl7ICJ1bmluaXRpYWxp
emVkIiwgJld1bmluaXRpYWxpemVkIH0sCisJeyAiZGVjbGFyYXRpb24tYWZ0ZXItc3RhdGVtZW50
IiwgJldkZWNsYXJhdGlvbmFmdGVyc3RhdGVtZW50IH0sCiB9OwogCiBlbnVtIHsKQEAgLTQ1Niw2
ICs0NTgsMjggQEAgc3RhdGljIHZvaWQgaGFuZGxlX29ub2ZmX3N3aXRjaF9maW5hbGl6ZShjb25z
dCBzdHJ1Y3Qgd2FybmluZyB3YXJuaW5nc1tdLCBpbnQgbikKIHN0YXRpYyB2b2lkIGhhbmRsZV9z
d2l0Y2hfV19maW5hbGl6ZSh2b2lkKQogewogCWhhbmRsZV9vbm9mZl9zd2l0Y2hfZmluYWxpemUo
d2FybmluZ3MsIHNpemVvZih3YXJuaW5ncykgLyBzaXplb2Yod2FybmluZ3NbMF0pKTsKKworCS8q
IGRlZmF1bHQgV2RlY2xhcmF0aW9uYWZ0ZXJzdGF0ZW1lbnQgYmFzZWQgb24gdGhlIEMgZGlhbGVj
dCAqLworCWlmICgtMSA9PSBXZGVjbGFyYXRpb25hZnRlcnN0YXRlbWVudCkKKwl7CisJCXN3aXRj
aCAoc3RhbmRhcmQpCisJCXsKKwkJCWNhc2UgU1RBTkRBUkRfQzg5OgorCQkJY2FzZSBTVEFOREFS
RF9DOTQ6CisJCQkJV2RlY2xhcmF0aW9uYWZ0ZXJzdGF0ZW1lbnQgPSAxOworCQkJCWJyZWFrOwor
CisJCQljYXNlIFNUQU5EQVJEX0M5OToKKwkJCWNhc2UgU1RBTkRBUkRfR05VODk6CisJCQljYXNl
IFNUQU5EQVJEX0dOVTk5OgorCQkJCVdkZWNsYXJhdGlvbmFmdGVyc3RhdGVtZW50ID0gMDsKKwkJ
CQlicmVhazsKKworCQkJZGVmYXVsdDoKKwkJCQlhc3NlcnQgKDApOworCQl9CisKKwl9CiB9CiAK
IHN0YXRpYyB2b2lkIGhhbmRsZV9zd2l0Y2hfdl9maW5hbGl6ZSh2b2lkKQpkaWZmIC0tZ2l0IGEv
bGliLmggYi9saWIuaAppbmRleCBjZWY0YWI4Li40MmEzMzk2IDEwMDY0NAotLS0gYS9saWIuaAor
KysgYi9saWIuaApAQCAtMTA4LDYgKzEwOCw3IEBAIGV4dGVybiBpbnQgV3RyYW5zcGFyZW50X3Vu
aW9uOwogZXh0ZXJuIGludCBXdHlwZXNpZ247CiBleHRlcm4gaW50IFd1bmRlZjsKIGV4dGVybiBp
bnQgV3VuaW5pdGlhbGl6ZWQ7CitleHRlcm4gaW50IFdkZWNsYXJhdGlvbmFmdGVyc3RhdGVtZW50
OwogCiBleHRlcm4gaW50IGRiZ19lbnRyeTsKIGV4dGVybiBpbnQgZGJnX2RlYWQ7CmRpZmYgLS1n
aXQgYS9wYXJzZS5jIGIvcGFyc2UuYwppbmRleCA2MjU1NzM3Li44MzQ2ZmUyIDEwMDY0NAotLS0g
YS9wYXJzZS5jCisrKyBiL3BhcnNlLmMKQEAgLTI4LDggKzI4LDYgQEAKICNpbmNsdWRlICJleHBy
ZXNzaW9uLmgiCiAjaW5jbHVkZSAidGFyZ2V0LmgiCiAKLSNkZWZpbmUgd2Fybl9vbl9taXhlZCAo
MSkKLQogc3RhdGljIHN0cnVjdCBzeW1ib2xfbGlzdCAqKmZ1bmN0aW9uX3N5bWJvbF9saXN0Owog
c3RydWN0IHN5bWJvbF9saXN0ICpmdW5jdGlvbl9jb21wdXRlZF90YXJnZXRfbGlzdDsKIHN0cnVj
dCBzdGF0ZW1lbnRfbGlzdCAqZnVuY3Rpb25fY29tcHV0ZWRfZ290b19saXN0OwpAQCAtMTgxMCw3
ICsxODA4LDcgQEAgc3RhdGljIHN0cnVjdCB0b2tlbiAqIHN0YXRlbWVudF9saXN0KHN0cnVjdCB0
b2tlbiAqdG9rZW4sIHN0cnVjdCBzdGF0ZW1lbnRfbGlzdAogCQkJc3RtdCA9IGFsbG9jX3N0YXRl
bWVudCh0b2tlbi0+cG9zLCBTVE1UX0RFQ0xBUkFUSU9OKTsKIAkJCXRva2VuID0gZXh0ZXJuYWxf
ZGVjbGFyYXRpb24odG9rZW4sICZzdG10LT5kZWNsYXJhdGlvbik7CiAJCX0gZWxzZSB7Ci0JCQlz
ZWVuX3N0YXRlbWVudCA9IHdhcm5fb25fbWl4ZWQ7CisJCQlzZWVuX3N0YXRlbWVudCA9IFdkZWNs
YXJhdGlvbmFmdGVyc3RhdGVtZW50OwogCQkJdG9rZW4gPSBzdGF0ZW1lbnQodG9rZW4sICZzdG10
KTsKIAkJfQogCQlhZGRfc3RhdGVtZW50KGxpc3QsIHN0bXQpOwpkaWZmIC0tZ2l0IGEvc3BhcnNl
LjEgYi9zcGFyc2UuMQppbmRleCA3YTM5ZDg1Li4wZjkxMzFkIDEwMDY0NAotLS0gYS9zcGFyc2Uu
MQorKysgYi9zcGFyc2UuMQpAQCAtMTEyLDYgKzExMiwxNiBAQCBTcGFyc2UgaXNzdWVzIHRoZXNl
IHdhcm5pbmdzIGJ5IGRlZmF1bHQuICBUbyB0dXJuIHRoZW0gb2ZmLCB1c2UKIFxmQlwtV25vXC1k
ZWNsXGZSLgogLgogLlRQCisuQiBcLVdkZWNsYXJhdGlvbi1hZnRlci1zdGF0ZW1lbnQKK1dhcm4g
YWJvdXQgZGVjbGFyYXRpb25zIHRoYXQgYXJlIG5vdCBhdCB0aGUgc3RhcnQgb2YgYSBibG9jay4K
KworVGhlc2UgZGVjbGFyYXRpb25zIGFyZSBwZXJtaXR0ZWQgaW4gQzk5IGJ1dCBub3QgaW4gQzg5
LgorCitTcGFyc2UgaXNzdWVzIHRoZXNlIHdhcm5pbmdzIGJ5IGRlZmF1bHQgb25seSB3aGVuIHRo
ZSBDIGRpYWxlY3QgaXMKK0M4OSAoaS5lLiAtYW5zaSBvciAtc3RkPWM4OSkuICBUbyB0dXJuIHRo
ZW0gb2ZmLCB1c2UKK1xmQlwtV25vXC1kZWNsYXJhdGlvblwtYWZ0ZXJcLXN0YXRlbWVudFxmUi4K
Ky4KKy5UUAogLkIgXC1XZGVmYXVsdFwtYml0ZmllbGRcLXNpZ24KIFdhcm4gYWJvdXQgYW55IGJp
dGZpZWxkIHdpdGggbm8gZXhwbGljaXQgc2lnbmVkbmVzcy4KIApkaWZmIC0tZ2l0IGEvdmFsaWRh
dGlvbi9kZWNsYXJhdGlvbi1hZnRlci1zdGF0ZW1lbnQtYW5zaS5jIGIvdmFsaWRhdGlvbi9kZWNs
YXJhdGlvbi1hZnRlci1zdGF0ZW1lbnQtYW5zaS5jCm5ldyBmaWxlIG1vZGUgMTAwNjQ0CmluZGV4
IDAwMDAwMDAuLjMzMzQxMGIKLS0tIC9kZXYvbnVsbAorKysgYi92YWxpZGF0aW9uL2RlY2xhcmF0
aW9uLWFmdGVyLXN0YXRlbWVudC1hbnNpLmMKQEAgLTAsMCArMSwxMiBAQAorc3RhdGljIHZvaWQg
ZnVuYyAoaW50IGkpCit7CisJaTsKKwlpbnQgaiA9IGk7Cit9CisvKgorICogY2hlY2stbmFtZTog
ZGVjbGFyYXRpb24gYWZ0ZXIgc3RhdGVtZW50IChBTlNJKQorICogY2hlY2stY29tbWFuZDogc3Bh
cnNlIC1hbnNpICRmaWxlCisgKiBjaGVjay1lcnJvci1zdGFydAorZGVjbGFyYXRpb24tYWZ0ZXIt
c3RhdGVtZW50LWFuc2kuYzo0OjI6IHdhcm5pbmc6IG1peGluZyBkZWNsYXJhdGlvbnMgYW5kIGNv
ZGUKKyAqIGNoZWNrLWVycm9yLWVuZAorICovCmRpZmYgLS1naXQgYS92YWxpZGF0aW9uL2RlY2xh
cmF0aW9uLWFmdGVyLXN0YXRlbWVudC1jODkuYyBiL3ZhbGlkYXRpb24vZGVjbGFyYXRpb24tYWZ0
ZXItc3RhdGVtZW50LWM4OS5jCm5ldyBmaWxlIG1vZGUgMTAwNjQ0CmluZGV4IDAwMDAwMDAuLjc4
NjMyY2QKLS0tIC9kZXYvbnVsbAorKysgYi92YWxpZGF0aW9uL2RlY2xhcmF0aW9uLWFmdGVyLXN0
YXRlbWVudC1jODkuYwpAQCAtMCwwICsxLDEyIEBACitzdGF0aWMgdm9pZCBmdW5jIChpbnQgaSkK
K3sKKwlpOworCWludCBqID0gaTsKK30KKy8qCisgKiBjaGVjay1uYW1lOiBkZWNsYXJhdGlvbiBh
ZnRlciBzdGF0ZW1lbnQgKEM4OSkKKyAqIGNoZWNrLWNvbW1hbmQ6IHNwYXJzZSAtc3RkPWM4OSAk
ZmlsZQorICogY2hlY2stZXJyb3Itc3RhcnQKK2RlY2xhcmF0aW9uLWFmdGVyLXN0YXRlbWVudC1j
ODkuYzo0OjI6IHdhcm5pbmc6IG1peGluZyBkZWNsYXJhdGlvbnMgYW5kIGNvZGUKKyAqIGNoZWNr
LWVycm9yLWVuZAorICovCmRpZmYgLS1naXQgYS92YWxpZGF0aW9uL2RlY2xhcmF0aW9uLWFmdGVy
LXN0YXRlbWVudC1jOTkuYyBiL3ZhbGlkYXRpb24vZGVjbGFyYXRpb24tYWZ0ZXItc3RhdGVtZW50
LWM5OS5jCm5ldyBmaWxlIG1vZGUgMTAwNjQ0CmluZGV4IDAwMDAwMDAuLmRkMzZlNmUKLS0tIC9k
ZXYvbnVsbAorKysgYi92YWxpZGF0aW9uL2RlY2xhcmF0aW9uLWFmdGVyLXN0YXRlbWVudC1jOTku
YwpAQCAtMCwwICsxLDkgQEAKK3N0YXRpYyB2b2lkIGZ1bmMgKGludCBpKQoreworCWk7CisJaW50
IGogPSBpOworfQorLyoKKyAqIGNoZWNrLW5hbWU6IGRlY2xhcmF0aW9uIGFmdGVyIHN0YXRlbWVu
dCAoQzk5KQorICogY2hlY2stY29tbWFuZDogc3BhcnNlIC1zdGQ9Yzk5ICRmaWxlCisgKi8KZGlm
ZiAtLWdpdCBhL3ZhbGlkYXRpb24vZGVjbGFyYXRpb24tYWZ0ZXItc3RhdGVtZW50LWRlZmF1bHQu
YyBiL3ZhbGlkYXRpb24vZGVjbGFyYXRpb24tYWZ0ZXItc3RhdGVtZW50LWRlZmF1bHQuYwpuZXcg
ZmlsZSBtb2RlIDEwMDY0NAppbmRleCAwMDAwMDAwLi5jM2ZlMmNkCi0tLSAvZGV2L251bGwKKysr
IGIvdmFsaWRhdGlvbi9kZWNsYXJhdGlvbi1hZnRlci1zdGF0ZW1lbnQtZGVmYXVsdC5jCkBAIC0w
LDAgKzEsOSBAQAorc3RhdGljIHZvaWQgZnVuYyAoaW50IGkpCit7CisJaTsKKwlpbnQgaiA9IGk7
Cit9CisvKgorICogY2hlY2stbmFtZTogZGVjbGFyYXRpb24gYWZ0ZXIgc3RhdGVtZW50IChkZWZh
dWx0KQorICogY2hlY2stY29tbWFuZDogc3BhcnNlICRmaWxlCisgKi8K
------=_Part_5454_6374912.1207997843121--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () kernel ! org>
To: linux-sparse
Subject: Re: four sparse patches
Date: Mon, 21 Apr 2008 19:12:30 +0000
Message-ID: <480CE71E.5050608 () kernel ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig13257A6340ABC52EB09DAB01
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Geoff Johnstone wrote:
>>  Regarding Wmix-decl-code.diff, I agree that that warning definitely
>>  needs an option controlling it. but GCC already has that option and
>>  calls it "-Wdeclaration-after-statement", so matching GCC's name
>>  seems potentially useful. (However, I can imagine corner cases
>>  where it might prove problematic, such as wanting to pass that
>>  option to GCC and not Sparse or vice versa.) Also, I agree that the
>>  default should depend on the C standard in use, and I see no
>>  compatibility reason why the warning should remain for code that
>>  explicitly asks for C99.  Thus, I haven't applied this version of
>>  the patch.
>=20
> I've attached a revised version of the patch that:
>  - Renames the option to -Wdeclaration-after-statement, as per GCC
>    (wasn't hitherto aware of that gcc option).
>  - Defaults based on chosen C dialect.
>  - Adds a few tests. (I'll do a separate patch for tests for the
>    incomplete struct patch.)
>  - Was made wrt the git trunk at about 11:30 UTC on 12th April.

Looks good; applied and pushed.  Thanks!

- Josh Triplett



--------------enig13257A6340ABC52EB09DAB01
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFIDOcfGJuZRtD+evsRAspDAJ9KAmTt/507p+ylqNFRrd0YfC8zAQCfbA4X
Kh8dyA/ZMvLidVX/HG+rWFY=
=IkIF
-----END PGP SIGNATURE-----

--------------enig13257A6340ABC52EB09DAB01--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: inline declaration and assignment ===

From: Matt <matt () use ! net>
To: linux-sparse
Subject: inline declaration and assignment
Date: Tue, 11 Nov 2008 06:24:00 +0000
Message-ID: <Pine.NEB.4.64.0811102205210.20411 () cesium ! clock ! org>
--------------------
Hi,

I'm playing with smatch and noticed that an inline assignment doesn't seem 
to get parsed as such. There's a couple of examples, but this one in 
sparse's own parse.c (line 1480) is probably the best:
   struct ident *ident = NULL;


sparse doesn't seem to identify this as an assignment, only a declaration. 
as a result, smatch gives this false positive:
parse.c +1487 undefined param add_expression 1


Sorry if I'm incorrectly diagnosing the problem; I'm just diving into the 
code for the first time this evening :)

Thanks in advance for any help!

--
tangled strands of DNA explain the way that I behave.
http://www.clock.org/~matt
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: label 'continue' already bound, unreplaced symbol 'return' ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: label 'continue' already bound, unreplaced symbol 'return'
Date: Thu, 14 Feb 2008 00:16:55 +0000
Message-ID: <1202948215.8941.37.camel () dv>
--------------------
Hello!

Here are some interesting testcases from the same hal.c from ndiswrapper
that was triggering the crash.

static inline int foo(void)
{
    do {
    } while (0);
    return 0;
}
int bar(void);
int bar(void)
{
    return foo();
}
typeof(bar) quux;


hal.c:12:13: warning: symbol 'quux' was not declared. Should it be
static?
hal.c:3:5: warning: label 'continue' already bound
hal.c:3:5: warning: label 'break' already bound


static inline int foo(void)
{
    return 0;
}
typeof(foo) quux;

hal.c:3:5: warning: unreplaced symbol 'return'
hal.c:1:19: warning: unreplaced symbol 'return'
hal.c:5:13: warning: symbol 'quux' was not declared. Should it be
static?


static inline void foo(void)
{
    do {} while (0);
}
typeof(foo) quux;

hal.c:3:5: warning: unreplaced symbol 'break'
hal.c:3:5: warning: unreplaced symbol 'continue'
hal.c:1:20: warning: unreplaced symbol 'return'
hal.c:5:13: warning: symbol 'quux' was not declared. Should it be
static?

"extern" before "typeof" fixes all warnings.

-- 
Regards,
Pavel Roskin
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Christopher Li" <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: label 'continue' already bound, unreplaced symbol 'return'
Date: Fri, 22 Feb 2008 19:16:39 +0000
Message-ID: <70318cbf0802221116i229152d1wafc15442cd0ab2d3 () mail ! gmail ! com>
--------------------
>  static inline int foo(void)
>  {
>     do {
>     } while (0);
>     return 0;
>  }
>  int bar(void);
>  int bar(void)
>  {
>     return foo();
>  }
>  typeof(bar) quux;
>
>
>  hal.c:12:13: warning: symbol 'quux' was not declared. Should it be
>  static?
>  hal.c:3:5: warning: label 'continue' already bound
>  hal.c:3:5: warning: label 'break' already bound

This happen because you try to make quux has type of *function*,
not a function pointer. Sparse literary assign the base type of bar
as base  type of quux. This result in body of bar get linearized twice.

I don't thing typeof(bar) quux is doing any thing useful.
I am not sure what is the gcc rules here. I try gcc -S with the test
case, it does not even generate any thing for quux.

The rest of the test case is more or less the same thing.

>  "extern" before "typeof" fixes all warnings.

That is because, once you declear it as "extern", it does not emit
any code.

I guess I can skip typeof(function) to fix it, like gcc does. Is there
better suggestions?

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: majordomo@vger.kernel.org ===

From: "sylvain nahas" <sylvain.nahas () googlemail ! com>
To: linux-sparse
Subject: majordomo@vger.kernel.org
Date: Mon, 04 Feb 2008 17:27:08 +0000
Message-ID: <b98a45740802040927p5d09cc75q183f6b14cab9c2da () mail ! gmail ! com>
--------------------
subscribe linux-sparse
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: multiple source files [was four sparse patches] ===

From: "Geoff Johnstone" <geoffsheep.johnstonefrog () googlemail ! com>
To: linux-sparse
Subject: Re: multiple source files [was four sparse patches]
Date: Fri, 02 May 2008 18:58:06 +0000
Message-ID: <32e600e90805021158vb6be3c9jbb75c3a61345448 () mail ! gmail ! com>
--------------------
> > I've attached four patches that I've written for sparse to use it
> > for a userland project.
>
>  Regarding incomplete structs, your patch seems reasonable as far as
>  I know, and it doesn't break the test suite, so I've applied and
>  pushed it.  Per your concerns, if this patch doesn't represent the
>  correct fix, the code can change later when we have a test case
>  that breaks with this patch.  Please do consider writing a patch
>  for a new test case based on your example.

OK - I sat down to write a test case and had trouble reproducing
because it turns out that the problem has a different cause.
Take three files:

/* test.h */
typedef struct foo *Foo;

void a (Foo foo);
void b (Foo foo);


/* test1.c */
#include "test.h"
void a (Foo foo) { }


/* test2.c */
#include "test.h"
void b (Foo foo) { }


With sparse 0.4.1:

$ sparse test1.c
$ sparse test2.c
$ sparse test[12].c
test2.c:3:6: error: symbol 'b' redeclared with different type
(originally declared at test.h:4) - incompatible argument 1 (different
base types)

...i.e. the problem only occurs with multiple source files on the
sparse command line. (The userland project mentioned above has a build
system that invokes the compiler once, passing all necessary source
files, because it also builds on Windows, where process creation is
remarkably slow so invoking cl.exe once per source file is prohibitive).

I think that the problem may be rooted in main():
  // Expand, linearize and show it.
  check_symbols(sparse_initialize(argc, argv, &filelist));
  FOR_EACH_PTR_NOTAG(filelist, file) {
    check_symbols(sparse(file));
  } END_FOR_EACH_PTR_NOTAG(file);

i.e. sparse doesn't reinitialize for each source file.

My patch a few weeks ago silences the error, but in the light of this
I think that it's working around rather than fixing the problem. The
"correct" fix would seem to be to re-initialise sparse for each source
file. However, sparse's data structures weren't written with this in
mind, so a patch would be rather invasive. It might be simpler to say
that sparse must only be invoked on one source file and to modify cgcc
instead?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: multiple source files [was four sparse patches]
Date: Fri, 27 Jun 2008 19:40:15 +0000
Message-ID: <20080627194015.GA19046 () uranus ! ravnborg ! org>
--------------------
> I'd like Sparse to handle multiple files on the same command line.  I
> don't mind invasive patches, though as always I'd like to see them
> broken up into incremental patches when possible.

I once made a test patch for kbuild that allowed me to run
sparse on all files for a module.
It started out nicely but when I hit the xfs source my machine went
in swap death.
So there is a memory consumption issue to take care of too.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: preprocess(), external_declaration(),  writing a "smart" editor ===

From: Reza Roboubi <reza () earthdetails ! com>
To: linux-sparse
Subject: preprocess(), external_declaration(),  writing a "smart" editor
Date: Mon, 04 Feb 2008 15:07:58 +0000
Message-ID: <47A72A4E.8070108 () earthdetails ! com>
--------------------
Consider an editor that can do search & replace for all instances of
'size', but only when 'size' is a member of 'struct list'.  (Even
if 'size' is being referenced from inside a macro.)

I'm very interested in writing an open source editor for this.
If this is stupid, please tell me!

I've glanced at the source code.  Can you help me find out if sparse is
right for this?

Thanks a lot.

Reza.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: some newbie questions about __attribute__((context,...)) ===

From: "Robert P. J. Day" <rpjday () crashcourse ! ca>
To: linux-sparse
Subject: some newbie questions about __attribute__((context,...))
Date: Sat, 19 Jul 2008 11:49:53 +0000
Message-ID: <alpine.LFD.1.10.0807190737340.24056 () localhost ! localdomain>
--------------------

  (if there's a good writeup on this, or a previous mailing post
explaining this, a pointer to that will do just fine.)

  i'm trying to understand how this context checking is actually done
by sparse.  from the sparse man page:

"Functions with the extended attribute
__attribute__((context(expression,in_context,out_context)) require the
context expression (for instance, a lock) to have the value in_context
(a constant nonnegative integer) when called, and return with the
value out_context (a constant nonnegative integer)."

  fair enough, but what are the possibilities for that "expression"
and what exactly is being compared to the values of 0 or 1?  sure, a
lock is an obvious candidate, but you can't really simply be comparing
the value of a lock to 0 or 1 -- a lock is a *structure* which doesn't
have a simple value of 0 or 1.

  so, to try to keep things simple, what is happening in the
background with code like this:

=====
static void *aarp_seq_start(struct seq_file *seq, loff_t *pos)
        __acquires(aarp_lock)
{
        struct aarp_iter_state *iter = seq->private;

        read_lock_bh(&aarp_lock);
        iter->table     = resolved;
        iter->bucket    = 0;

        return *pos ? iter_next(iter, pos) : SEQ_START_TOKEN;
}
=====

  and how is that call to read_lock_bh() changing the "context" value
of the object aarp_lock?  thanks for any enlightenment.

rday
--


========================================================================
Robert P. J. Day
Linux Consulting, Training and Annoying Kernel Pedantry:
    Have classroom, will lecture.

http://crashcourse.ca                          Waterloo, Ontario, CANADA
========================================================================
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: some newbie questions about __attribute__((context,...))
Date: Sat, 19 Jul 2008 12:42:20 +0000
Message-ID: <1216471340.29432.3.camel () johannes ! berg>
--------------------

--=-IevsOXMNs1ddq+XTc9MB
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> "Functions with the extended attribute
> __attribute__((context(expression,in_context,out_context)) require the
> context expression (for instance, a lock) to have the value in_context
> (a constant nonnegative integer) when called, and return with the
> value out_context (a constant nonnegative integer)."
>=20
>   fair enough, but what are the possibilities for that "expression"

None. It's currently mostly ignored. I posted patches to fix this, which
had problems, and the fixes to those patches haven't been merged yet.

With my patches, the possibilities are either an expression that sparse
can resolve, e.g.

void do_lock(void *lock) __attribute__((context(lock,0,1))) {...}

or for compatibility anything else that is then treated as a constant:

void do_lock(void) __attribute__((context(GLOBAL_LOCK,0,1))) {...}

> and what exactly is being compared to the values of 0 or 1?  sure, a
> lock is an obvious candidate, but you can't really simply be comparing
> the value of a lock to 0 or 1 -- a lock is a *structure* which doesn't
> have a simple value of 0 or 1.

Sparse internally tracks the "value" of such a context. My examples
above would increase the context in the function, and every time that
function is called the context is increased, and if such a context is
"leaked" then sparse will complain it isn't 0.

> static void *aarp_seq_start(struct seq_file *seq, loff_t *pos)
>         __acquires(aarp_lock)
> {
>         struct aarp_iter_state *iter =3D seq->private;
>=20
>         read_lock_bh(&aarp_lock);
>         iter->table     =3D resolved;
>         iter->bucket    =3D 0;
>=20
>         return *pos ? iter_next(iter, pos) : SEQ_START_TOKEN;
> }
> =3D=3D=3D=3D=3D
>=20
>   and how is that call to read_lock_bh() changing the "context" value
> of the object aarp_lock?  thanks for any enlightenment.

Well, read_lock_bh() acquires the context named "aarp_lock", and
aarp_seq_start is annotated to also do that. If you write

void foo()
{
	read_lock_bh(&aarp_lock);
}

then sparse will complain that the context is leaked in foo.

If you really want to do any serious work with sparse's context tracking
I can only suggest to apply my patches.

johannes

--=-IevsOXMNs1ddq+XTc9MB
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJIgeEpAAoJEKVg1VMiehFYpy0QAKARhoF6CTc0v/CvpqLiYBN4
dg74cs8ZOdd0IYNeKzEz3YmqgRNRPG7zgxlX7VIqAXNn0Nx7Hz2vG1/0V59t1d9n
tduU/cHLCExZrXF3TB/jwuANIYjnwoXlzjw8RdwBYlkHwXJ1vnMGLArEsiYXSQq3
4rfinP68sYHWmud+jaKCWpsruf9HYLcpGSoQUdLzwx2sZvHRs3zvQRDx4r/cEbJo
IfLptwUfb3TTuJosgoNV7PdIuWU/RUrR+/0OiZwQ7EmkmNYfC4+hl5lQZHShVRGt
6I95jSmZG7rjyaU06RZGk/6XCVZKz0jMKxJfytE3MhHyMQVPN5UmvkakbyUp16sM
MwVIx29Sa2FjC0rYsQvkVI4GSiuUqYx+DIIUIz3xO/IkuikAysMGBpUv4v1iQEmK
+KP3G3yb+KYIIZRvAPMUn9wy6q1uuorKTZ9Ut91+w+rONRmAChMOGlZt9pVmkpdS
458M5qzPLkT1QPOaAxRDhf6nLot0eyFHBGBFVptmnfiyMNKj+xHW3f3baIIbd8ta
BV8Aw6Z0gvaRwitQUo/7Js/VJEqgRhNHbJ4WLeii6/ij53cTNNZL9/Z95azPAQFt
wUBOXQoDq9uB5lVwUxwvmPGzxjMzh17FmV8w1tdEMIGlM3JC4ZHaYbXHA428MN2u
LNsWEeWIEsRPVpc/OD83
=c1fS
-----END PGP SIGNATURE-----

--=-IevsOXMNs1ddq+XTc9MB--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse (cgcc) vs lintool ===

From: Christoph Hellwig <hch () lst ! de>
To: linux-sparse
Subject: sparse (cgcc) vs lintool
Date: Fri, 06 Jun 2008 12:34:34 +0000
Message-ID: <20080606123434.GA23323 () lst ! de>
--------------------
When trying to compile xfsprogs (from oss.sgi.com/projects/xfs)

hch@bigmac:~/work/xfs-cmds/xfsprogs$ CC=~/bin/cgcc ./configure
hch@bigmac:~/work/xfs-cmds/xfsprogs$ make

I get this error:

=== libxfs ===
/usr/bin/libtool --mode=compile /home/hch/bin/cgcc -I. -g -O2 -DNDEBUG
-DVERSION=\"2.9.8\" -DLOCALEDIR=\"/usr/local/share/locale\"
-DPACKAGE=\"xfsprogs\" -I../include -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64
-funsigned-char -fno-strict-aliasing -Wall   -c bit.c
libtool: compile: unable to infer tagged configuration
libtool: compile: specify a tag with `--tag'
make[1]: *** [bit.lo] Error 1
make: *** [default] Error 2

Any idea what's up with sparse and libtool?

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Re: sparse (cgcc) vs lintool
Date: Fri, 06 Jun 2008 12:49:55 +0000
Message-ID: <20080606124955.GE600 () ins ! uni-bonn ! de>
--------------------
Hello Christoph,

* Christoph Hellwig wrote on Fri, Jun 06, 2008 at 02:34:34PM CEST:
> 
> /usr/bin/libtool --mode=compile /home/hch/bin/cgcc -I. -g -O2 -DNDEBUG
> -DVERSION=\"2.9.8\" -DLOCALEDIR=\"/usr/local/share/locale\"
> -DPACKAGE=\"xfsprogs\" -I../include -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64
> -funsigned-char -fno-strict-aliasing -Wall   -c bit.c
> libtool: compile: unable to infer tagged configuration
> libtool: compile: specify a tag with `--tag'
> make[1]: *** [bit.lo] Error 1
> make: *** [default] Error 2
> 
> Any idea what's up with sparse and libtool?

If --tag=CC is not passed to libtool before /home/hch/bin/cgcc, then it
tries to infer the set of compiler settings to use (CC, CXX, F77, ...)
from the compiler name passed.

I don't know the sources in question, but typically you can append
--tag=CC to some $(LIBTOOL) variable or set $(LIBTOOLFLAGS) or so.

Hope that helps.

Cheers,
Ralf
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Balbir Singh" <bsingharora () gmail ! com>
To: linux-sparse
Subject: Re: sparse (cgcc) vs lintool
Date: Fri, 06 Jun 2008 12:59:16 +0000
Message-ID: <661de9470806060547j720f063fn7c1e4c88b3089738 () mail ! gmail ! com>
--------------------
On Fri, Jun 6, 2008 at 6:04 PM, Christoph Hellwig <hch@lst.de> wrote:
> When trying to compile xfsprogs (from oss.sgi.com/projects/xfs)
>
> hch@bigmac:~/work/xfs-cmds/xfsprogs$ CC=~/bin/cgcc ./configure
> hch@bigmac:~/work/xfs-cmds/xfsprogs$ make
>
> I get this error:
>
> === libxfs ===
> /usr/bin/libtool --mode=compile /home/hch/bin/cgcc -I. -g -O2 -DNDEBUG
> -DVERSION=\"2.9.8\" -DLOCALEDIR=\"/usr/local/share/locale\"
> -DPACKAGE=\"xfsprogs\" -I../include -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64
> -funsigned-char -fno-strict-aliasing -Wall   -c bit.c
> libtool: compile: unable to infer tagged configuration
> libtool: compile: specify a tag with `--tag'
> make[1]: *** [bit.lo] Error 1
> make: *** [default] Error 2
>
> Any idea what's up with sparse and libtool?

Looking at the FAQ from

http://www.astro.gla.ac.uk/~norman/star/ssn78/ssn78.htx/N-a5b1.html

I've just been told that libtool is ``unable to infer tagged
configuration''. What on earth is that supposed to mean?
    I'm not sure what this is supposed to mean exactly, but what it
seems to mean in practice is that libtool has become terribly confused
about your compiler. Very probably, you forced ./configure to use a
particular compiler by specifying one of the F77, FC or CC environment
variables at configure time. You may have forgotten that you have that
variable set.

    Alternatively, you may be unaware that that variable is set: a
known manifestation of this problem is that the IRAF startup script
sets F77 to be an IRAF-specific script, which works OK from the
command-line (given that you want to use IRAF), but which leaves
libtool in a confused heap.

    This problem has also been spotted in the form libtool: compile:
specify a tag with `--tag', with apparently the same cause.

    See Section 2.1.5 for more discussion of these variables.


Did gcc or any other development tools package change on your system?

Balbir
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christoph Hellwig <hch () lst ! de>
To: linux-sparse
Subject: Re: sparse (cgcc) vs lintool
Date: Fri, 06 Jun 2008 13:07:56 +0000
Message-ID: <20080606130756.GA24879 () lst ! de>
--------------------
On Fri, Jun 06, 2008 at 02:49:55PM +0200, Ralf Wildenhues wrote:
> > Any idea what's up with sparse and libtool?
> 
> If --tag=CC is not passed to libtool before /home/hch/bin/cgcc, then it
> tries to infer the set of compiler settings to use (CC, CXX, F77, ...)
> from the compiler name passed.
> 
> I don't know the sources in question, but typically you can append
> --tag=CC to some $(LIBTOOL) variable or set $(LIBTOOLFLAGS) or so.

Thanks, a

LIBTOOL="libtool --tag=CC" CC=~/bin/cgcc ./configure

does it for me.  So I guess the problem is with libtool and it needs
to be taught about cgcc.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christoph Hellwig <hch () lst ! de>
To: linux-sparse
Subject: Re: sparse (cgcc) vs lintool
Date: Fri, 06 Jun 2008 13:25:57 +0000
Message-ID: <20080606132557.GA27189 () lst ! de>
--------------------
On Fri, Jun 06, 2008 at 03:21:23PM +0200, Ralf Wildenhues wrote:
> Well, thing is, the typical way things work is that a libtool script is
> generated as part of the configure process, and it sets things for the
> $CC, $CXX, etc. used for that configure.  With this package, however,
> /usr/bin/libtool is used, and that typically has been configured only
> for /usr/bin/gcc etc.
> 
> I suppose a distro could add a section for cgcc, yes, or make it assume
> --tag=CC for 'cgcc'.  But really passing --tag=CC is the sane thing to
> do: the package knows that your code is C code, whereas libtool
> inferring it from the command line is error-prone (which is why the tag
> check was made stricter in the first place).

Thanks, that explanation makes a lot of sense.  I'll see if I can
fix up the xfsprogs buildsystems, it's a little odd anyway.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: sparse (cgcc) vs lintool
Date: Fri, 06 Jun 2008 19:39:16 +0000
Message-ID: <1212781156.18886.7.camel () dv>
--------------------
On Fri, 2008-06-06 at 14:34 +0200, Christoph Hellwig wrote:
> When trying to compile xfsprogs (from oss.sgi.com/projects/xfs)
> 
> hch@bigmac:~/work/xfs-cmds/xfsprogs$ CC=~/bin/cgcc ./configure
> hch@bigmac:~/work/xfs-cmds/xfsprogs$ make
> 
> I get this error:
> 
> === libxfs ===
> /usr/bin/libtool --mode=compile /home/hch/bin/cgcc -I. -g -O2 -DNDEBUG
> -DVERSION=\"2.9.8\" -DLOCALEDIR=\"/usr/local/share/locale\"
> -DPACKAGE=\"xfsprogs\" -I../include -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64
> -funsigned-char -fno-strict-aliasing -Wall   -c bit.c
> libtool: compile: unable to infer tagged configuration
> libtool: compile: specify a tag with `--tag'
> make[1]: *** [bit.lo] Error 1
> make: *** [default] Error 2
> 
> Any idea what's up with sparse and libtool?

It can be reproduced without sparse:

[proski@dv xfsprogs-2.9.8]$ ./configure CC=/usr/bin/gcc
checking for gcc... /usr/bin/gcc
checking for C compiler default output file name... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... no
...
checking size of char *... 8
configure: creating ./config.status
config.status: creating include/builddefs
config.status: creating include/platform_defs.h
config.status: include/platform_defs.h is unchanged
[proski@dv xfsprogs-2.9.8]$ make
=== include ===
rm -f xfs disk
ln -s . xfs
ln -s . disk
=== libxfs ===
/usr/bin/libtool --mode=compile /usr/bin/gcc -I. -g -O2 -DNDEBUG
-DVERSION=\"2.9.8\" -DLOCALEDIR=\"/usr/local/share/locale\" -DPACKAGE=
\"xfsprogs\" -I../include -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64
-funsigned-char -fno-strict-aliasing -Wall   -c bit.c
libtool: compile: unable to infer tagged configuration
libtool: compile: specify a tag with `--tag'
gmake[1]: *** [bit.lo] Error 1
make: *** [default] Error 2
[proski@dv xfsprogs-2.9.8]$

Besides, replying on user installed libtool is asking for trouble.  The
proper way to use libtool is to include it into the package.

It's recommended to use automake with libtool, but even if they are too
automake-averse, there are still some rules how to use libtool properly.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse 0.4.1 and __cold__ ===

From: Ben Dooks <ben-linux () fluff ! org>
To: linux-sparse
Subject: sparse 0.4.1 and __cold__
Date: Sun, 14 Sep 2008 14:31:52 +0000
Message-ID: <20080914143152.GI322 () trinity ! fluff ! org>
--------------------
I've just been trying sparse 0.4.1 with linux-next and have noticed
that the discussions and patches wrt to the __cold__ attribute have
not yet made it into a release version.

Would it be possible to put a release of sparse up which handled
this attribute please?

-- 
Ben

Q:      What's a light-year?
A:      One-third less calories than a regular year.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse context warning problem ... ===

From: David Brownell <david-b () pacbell ! net>
To: linux-sparse
Subject: sparse context warning problem ...
Date: Sun, 11 May 2008 00:24:03 +0000
Message-ID: <200805101724.04014.david-b () pacbell ! net>
--------------------
I just noticed this with some obviously correct code... and verified
that it's a regression in current GIT version of "sparse" since it
now rejects code which previously passed just fine.

The issue is a not-uncommon idiom, where a function must be called
with a lock held, and briefly drops it.  The way this has previously
been addressed, originally suggested by Linus and used in various
places in the kernel (but, I observe, not in the "sparse" internal
validation test cases) is:

  static void
  finish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)
  __releases(ohci->lock)
  __acquires(ohci->lock)
  {
	...
  }

But current versions of "sparse" complain (wrongly):

  drivers/usb/host/ohci-q.c:66:2: warning: context imbalance in 'finish_urb': __context__ statement expected different context
  drivers/usb/host/ohci-q.c:66:2:    context '<noident>': wanted >= 0, got -1

Presumably this is this a known bug ... is a fix on the way?
(Meanwhile, I can just ignore this bogus output.)

- Dave

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Brownell <david-b () pacbell ! net>
To: linux-sparse
Subject: Re: sparse context warning problem ...
Date: Sun, 11 May 2008 03:18:13 +0000
Message-ID: <200805102018.13358.david-b () pacbell ! net>
--------------------
On Saturday 10 May 2008, Johannes Berg wrote:
> This is probably my mistake.
> 
> However, I took __releases and __acquires to mean that this function
> *changed* the context, doing both doesn't really make much sense. I
> think the function should actually be declared
> 
> static void
> finish_urb(...)
> __requires(ohci->lock)
> {...}
> 
> where __requires is (for sparse) defined as
> 
> #define __requires(x) __attribute__((context(x,1,1)))

ISTR suggesting special syntax for this to Linus (this was way
back when "sparse" was just starting) and he wanted to just do
it by having those two attributes.

So at this point, I'd want to see the regression fixed (and the
tests updated to avoid this in the future) before exploring any
alternative syntax for kernel annotations.


On the plus side, having syntax *IS* more general.  It can serve
as an annotation that the function requires particular locking
context, whether or not that context is explicitly accessed.

- Dave



> It's probably possible to merge the __acquires and __releases into one
> though.


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: sparse context warning problem ...
Date: Sun, 11 May 2008 09:46:26 +0000
Message-ID: <1210499186.3646.16.camel () johannes ! berg>
--------------------

--=-E9zVpKqWXIyWVSk2l2p+
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Sat, 2008-05-10 at 20:18 -0700, David Brownell wrote:
> On Saturday 10 May 2008, Johannes Berg wrote:
> > This is probably my mistake.
> >=20
> > However, I took __releases and __acquires to mean that this function
> > *changed* the context, doing both doesn't really make much sense. I
> > think the function should actually be declared
> >=20
> > static void
> > finish_urb(...)
> > __requires(ohci->lock)
> > {...}
> >=20
> > where __requires is (for sparse) defined as
> >=20
> > #define __requires(x) __attribute__((context(x,1,1)))
>=20
> ISTR suggesting special syntax for this to Linus (this was way
> back when "sparse" was just starting) and he wanted to just do
> it by having those two attributes.
>=20
> So at this point, I'd want to see the regression fixed (and the
> tests updated to avoid this in the future) before exploring any
> alternative syntax for kernel annotations.

Yeah, true, on the other hand, if/when Josh merges my other patches then
most kernel annotations will have to be changed anyway because up to
before the patch that is already in sparse wouldn't flag this:

spin_lock(&lock);
rcu_read_unlock();

because it didn't care *at all* about the expression inside __acquire()
and thus a lot of usage crept in that isn't really usable.

With my future patches, I'm even binding the symbols, so that

void spin_lock(spinlock_t l) __acquire(l);

will flag errors with

spin_lock(&a);
spin_unlock(&b);

while right now it would just treat them both as the context "l".

So I expect that it will not be possible to not "regress" in that sense
because the current annotations are simply messed up since sparse didn't
care about the name inside __acquire()/__release() at all!


However, it's probably fairly easy right now to treat both of them as
being merged together which seems the only sensible things to do anyway
if such a situation is encountered. I'll look into it.

johannes

--=-E9zVpKqWXIyWVSk2l2p+
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASCbAcaVg1VMiehFYAQLlVhAAo2Ph7MNobSx+RBhe3NN2oTexwXK9jhpF
AxM9re6pNu6Y1WW69KW909r1HpXKZIze/O1naj6+yr8ms+AZWHF8EmHMwp0fK/Wt
8nAkESBk8uCP+uzdSWUIctY4hv3lVi6tHPMXDOe9xwb3balkQVC/6s7xs0WQHz7c
s8l5MKP394Hybwm792BgrdJeJrK4WbWyiSr2fZMw3scH3lxUM9DjyZNsM4JlmPjd
ZmM1VPGCBCkfoweiw9ipHwjuCu4esSCsMjGcwloWM1eVg27zTPDryQzOGmHgGPUO
Fz6ZdnNprGIq8w+wEIoAGaOBkmkBvEehty9r8lUkjLd59HGMz8QgKEdfNnz1R1Bg
Ug4xvYh+hGhezPRit3eh5fAjhl76GEjUnZTwdtmzctTPKw0+VblbRQ7DKl2YL0LO
r9YXTIdzqs7vfLZuTDBiXuOPtZ51tS43aI78855iR866iNcpMjmf7AaO7ia/cjFi
xjRwujxTHjD07wHrGn+kFmQhEScSXvUkhwTCIxwclVhQkmPl47Yuiv5zgq7c6tKx
xkmw7vbTY8238RKdHgVYI69cJM40rlMqT6xru0pdkTVbDWM2eBlARVXV1dYR1ac5
pmWr4FGGvCALkt0eVJzAIEM6SWoJNSDWqA+tRqCn6iI6NIKeYYtv/5/CyDFB+d5K
b2JMtkNJ9ks=
=L2O2
-----END PGP SIGNATURE-----

--=-E9zVpKqWXIyWVSk2l2p+--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: sparse context warning problem ...
Date: Tue, 13 May 2008 21:52:48 +0000
Message-ID: <1210715568.4279.35.camel () johannes ! berg>
--------------------

--=-gOdyOnYGXNi+XdZ6PbPT
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable


> >   static void
> >   finish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)
> >   __releases(ohci->lock)
> >   __acquires(ohci->lock)

> > But current versions of "sparse" complain (wrongly):
> >=20
> >   drivers/usb/host/ohci-q.c:66:2: warning: context imbalance in 'finish=
_urb': __context__ statement expected different context
> >   drivers/usb/host/ohci-q.c:66:2:    context '<noident>': wanted >=3D 0=
, got -1


> However, I took __releases and __acquires to mean that this function
> *changed* the context, doing both doesn't really make much sense. I
> think the function should actually be declared
>=20
> static void
> finish_urb(...)
> __requires(ohci->lock)
> {...}
>=20
> where __requires is (for sparse) defined as
>=20
> #define __requires(x) __attribute__((context(x,1,1)))

Actually, it turns out my analysis was completely wrong.

This is exactly the issue I pointed out in my other mail. You have:

=EF=BB=BF__acquires(ohci->lock)
           ^^^^^^^^^^
but, on the other hand:

spin_unlock (&ohci->lock);
             ^

I think you can fix this particular case by adding the & in the
__acquires(), but that will only work for UP, for actual spinlocks my
other patches will be needed, because w/o my patches sparse will, on
SMP, not be able to see that

void __lockfunc _spin_lock(spinlock_t *lock)            __acquires(lock);

means to lock "&ohci->lock" when doing "spin_lock(&ohci->lock);" but
will treat it as locking the abstractly-named "lock" context, while on
UP/no-preempt the "spin_lock" macro is expanded by the preprocessor and
you will get "&ohci->lock" as the expression.

Ultimately, this whole problem comes from the fact that sparse accepted
adding an expression, documented it, but never complained if they
slightly mismatched as above.

johannes

--=-gOdyOnYGXNi+XdZ6PbPT
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASCoNr6Vg1VMiehFYAQL9JQ//Yn8q3EsN49uvFWo8ByvPUHgwTX8TJk55
IMCAfJhFpgZen0HAI5kC77SsuTlbSVHNWIuAjkViIS3yNBhnEXNGNQGa68k7be6X
7iGVRaiKbRAGF/gpooi62dJOragyCZATdTeMj52jUc35ZiEyI0tKVeaaq37x4ZKP
m7wwe7NKXZ7Ism7hnVMry5v1FTKoJ4do9DOKLUsz2h9x8e9fvtgwtytcwfIiOZG1
Whnu0W78QtRfaGh9FvZ7Zic0TxStAjxr7C1AWpaXA88mmIjU/Xk7UC7imdTVhWbB
wrN4GTc86WfYTOhJSch4Ok71yYEWtKiK8+EoUlZ+7Ld9iYHkSNsGEPc3C7fHWPHc
zvxLEpqEfHEvo1KBeW6OS8oZkb4NVAXCK/0VdO0oX5ozifFQTpx2kuBoY7C//yH0
qcf2Qo/U2Rdz2CkBYklDKo3KdWfYBqXEDwcwG9viSkXzzYoKnDZPqXuP58mzoAfY
My3qqHteWF1h9VoXTI04vvulG8DN7xHjGgw7DbX01sBD0wpk/nXO/r7chD9iS80Z
qos4Bf2MuPfW8Zblx2Il2+RL1Sauy5983bGWC9apa2dX0694B0lcP2Lko0/kMK3b
wcxPgaUxGASJHaJjgMzql4QWCNAfuoAXuhn9tAx3SfsfG7FROx+3+VtusJOzQu7V
2aAw9DL3VgU=
=NTpO
-----END PGP SIGNATURE-----

--=-gOdyOnYGXNi+XdZ6PbPT--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Brownell <david-b () pacbell ! net>
To: linux-sparse
Subject: Re: sparse context warning problem ...
Date: Wed, 14 May 2008 13:58:03 +0000
Message-ID: <200805140658.04018.david-b () pacbell ! net>
--------------------
On Tuesday 13 May 2008, Johannes Berg wrote:

> Actually, it turns out my analysis was completely wrong.
> 
> This is exactly the issue I pointed out in my other mail. You have:
> 
> ï»¿__acquires(ohci->lock)
>            ^^^^^^^^^^
> but, on the other hand:
> 
> spin_unlock (&ohci->lock);
>              ^
> 
> I think you can fix this particular case by adding the & in the
> __acquires(), but that will only work for UP,

I used the OHCI example because it was a clear and readily
available/reproducible example of how this is a regression;
but I came across the problem with a different driver.  In
that driver, I just made sure that the strings were now
identical ... and the failures still came up with "sparse".

That's on a UP build.  (Albeit with PREEMPT and all the
debug options available ... since I'm debugging!)


> for actual spinlocks my 
> other patches will be needed, because w/o my patches sparse will, on
> SMP, not be able to see that
> 
> void __lockfunc _spin_lock(spinlock_t *lock)            __acquires(lock);
> 
> means to lock "&ohci->lock" when doing "spin_lock(&ohci->lock);" but
> will treat it as locking the abstractly-named "lock" context, while on
> UP/no-preempt the "spin_lock" macro is expanded by the preprocessor and
> you will get "&ohci->lock" as the expression.

Yeah, well the lock being acquired or released *IS* "ohci->lock",
but the spinlock calls don't take the lock, they take pointers
to it!

If you were to argue that understanding pointers like that is a
lot to demand of "sparse", I might agree.  But that won't change
the fact that locks themselves are not pointers to locks.  ;)


> Ultimately, this whole problem comes from the fact that sparse accepted
> adding an expression, documented it, but never complained if they
> slightly mismatched as above.

This still doesn't quite add up, though...

- Dave

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: sparse context warning problem ...
Date: Thu, 29 May 2008 08:47:03 +0000
Message-ID: <1212050823.16917.37.camel () johannes ! berg>
--------------------

--=-HL3YJ6PGCkWxEn0cZKEz
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> > means to lock "&ohci->lock" when doing "spin_lock(&ohci->lock);" but
> > will treat it as locking the abstractly-named "lock" context, while on
> > UP/no-preempt the "spin_lock" macro is expanded by the preprocessor and
> > you will get "&ohci->lock" as the expression.
>=20
> Yeah, well the lock being acquired or released *IS* "ohci->lock",
> but the spinlock calls don't take the lock, they take pointers
> to it!
>=20
> If you were to argue that understanding pointers like that is a
> lot to demand of "sparse", I might agree.  But that won't change
> the fact that locks themselves are not pointers to locks.  ;)

Yeah, I agree the locks aren't pointers, but really, it is a lot easier
for you to do that annotation than for sparse to figure it out.

I blame these problems on whoever implemented sparse context tracking in
the first place, documented the optional first expression parameter and
then didn't write any code for looking at the expression at all.

The patch series I have posted a while ago (I'll repost) would fix the
existing problems with the context tracking patch Josh put in
(especially the problem that

spin_lock_irqsave(&a);
spin_unlock_irqrestore(&a);

currently gives a warning on some kernel builds because one is a macro
and the other is not), but has its own problems again with the RESULT
"macro" (you can only use it on a declaration, not an implementation),
but that is completely new so not really a problem I think.


A problem my patch series introduces, though, is the static inline one:
Currently, static inlines are inlined right into the function when
testing for locks but that is a bit complicated with expression tracking
because the expressions inside of the static inline look completely
different due to variable passing. Hence, I change that to not go in
there but evaluate the static inlines themselves. However, this means
that this

static inline void netif_tx_lock_bh(struct net_device *dev)
{
        spin_lock_bh(&dev->_xmit_lock);
        dev->xmit_lock_owner =3D smp_processor_id();
}


will now trigger a warning and you have to annotate inlines as well
(also to get the user checked properly):

static inline void netif_tx_lock_bh(struct net_device *dev)
	__acquires(&dev->_xmit_lock)
{
        spin_lock_bh(&dev->_xmit_lock);
        dev->xmit_lock_owner =3D smp_processor_id();
}

Conceptually, I think this is cleaner because inlines are treated more
like real functions then, but you may disagree.


The status quo, however, has turned out to be unacceptable to users
because of the spinlock problem I mentioned above. Can we, based on an
evaluation of the problems I just outlined, either apply the patches I'm
about to send, or revert them to go back to the completely unchecked
contexts?

johannes

--=-HL3YJ6PGCkWxEn0cZKEz
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASD5thqVg1VMiehFYAQKoQhAArWyAH9UUn0QA/2mgRgr6+rMKCiy/u1yc
wUdMwRWLGkN+IrGn4a3L0tLY4KRJ/X8+Mi1xMNWzeglaCqJaYgIZIhKMetngmEFl
eTC2TdrYEDVp01XpKuUKmUnJXsXAAsUaP42TyHX1vsDeB9Wn4pKh+Yu76p+zN1VU
tCiSDRIJI7oI1hmJV+sgCtddVyDPAzO6rEAf80GsXSv7Hk5eQVw6P65DIej+a+7N
Y/2Ilooauvl1ya+7+8504qRG1HcARiAgZedsObJJrNuzVgLWklKxrxOR6Q+Ey6Zz
VYgqCZpnxWJu+8TxFPHo779LDyricKP6Jx5mmo6x6vvj5ipx8B3Tcv9DwWf/d+Kn
vXOfQ1y2zByUSdfNxwSvp0raObiCCkWYRtHeAUPzZupNseYLIzhxQO0jCAkF08do
LzqL6XTFKcxwnMS+CGfiJvUhd7jZuC9BaUFcPgnLHDmEE7YR6SP2WVsQN3SDsDIO
bePmHk9dbTjxXUMAlnfUAbv4IBH7v/9M5mwFHlNqa9KQteeVl7VScMn3alTK2pQt
Hg4M+ChgPsp2tBcmhtl+Wrz3ub4lbUg9zfUfw02jke2NQ5aD78hIWcdijp0d5o9K
CARGZaEc8UBRs3ko1jgJp9Cbf2/OqiCs9jL6p2HLa/rE37UJl6lvC4vLorZu6kbp
Atu9IhSTuIQ=
=1TML
-----END PGP SIGNATURE-----

--=-HL3YJ6PGCkWxEn0cZKEz--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Brownell <david-b () pacbell ! net>
To: linux-sparse
Subject: Re: sparse context warning problem ...
Date: Thu, 29 May 2008 09:39:13 +0000
Message-ID: <200805290239.13436.david-b () pacbell ! net>
--------------------
On Thursday 29 May 2008, Johannes Berg wrote:
> 
> > > means to lock "&ohci->lock" when doing "spin_lock(&ohci->lock);" but
> > > will treat it as locking the abstractly-named "lock" context, while on
> > > UP/no-preempt the "spin_lock" macro is expanded by the preprocessor and
> > > you will get "&ohci->lock" as the expression.
> > 
> > Yeah, well the lock being acquired or released *IS* "ohci->lock",
> > but the spinlock calls don't take the lock, they take pointers
> > to it!
> > 
> > If you were to argue that understanding pointers like that is a
> > lot to demand of "sparse", I might agree.  But that won't change
> > the fact that locks themselves are not pointers to locks.  ;)
> 
> Yeah, I agree the locks aren't pointers, but really, it is a lot easier
> for you to do that annotation than for sparse to figure it out.

I was fairly sure you'd argue that!


> I blame these problems on whoever implemented sparse context tracking in
> the first place, documented the optional first expression parameter and
> then didn't write any code for looking at the expression at all.

Yeah, that Torvalds clown is always leaving stuff unfinished.  ;)


> static inline void netif_tx_lock_bh(struct net_device *dev)
> 	__acquires(&dev->_xmit_lock)
> {
>         spin_lock_bh(&dev->_xmit_lock);
>         dev->xmit_lock_owner = smp_processor_id();
> }
> 
> Conceptually, I think this is cleaner because inlines are treated more
> like real functions then, but you may disagree.

I disagree.  They *are* real functions, so treating them
as such is the only reasonable option!

(Note by the way a convenience there:  the lock is easily
described using just the function parameters.  I suspect
that will be common, but not always true ...)


Will it be possible to put annotations on methods declared
in ops vectors?  Just today I was cleaning up some locking
issues and had to start using a lock.  But I couldn't find
any clear statement about the call contexts for some of the
new lock/unlock calls ... I had to go look at other drivers
to see an answer (and hope they weren't buggy).  It would
have been nicer to just have "sparse" tell me the answers.

(If right now that seems more like a research problem, I'd
not be too surprised.  But I'd like to think that someday
it should be practical to have kernel lockdep tools tell
us about such things, and have such constraints verified
during builds.)

 
> The status quo, however, has turned out to be unacceptable to users
> because of the spinlock problem I mentioned above. Can we, based on an
> evaluation of the problems I just outlined, either apply the patches I'm
> about to send, or revert them to go back to the completely unchecked
> contexts?

Haven't seen the patches, but in principle I have no objection
to finishing the lock context code.  Fixing all the kernel code
to get better lock annotations will take time, but that's OK.

What's probably more important right now is to make sure the
annotations are simple and correct, so they can be built on
over time.

- Dave


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: sparse context warning problem ...
Date: Thu, 29 May 2008 09:54:33 +0000
Message-ID: <1212054873.16917.51.camel () johannes ! berg>
--------------------

--=-d9dxoJqoVSpNni5kIg6L
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


> > Yeah, I agree the locks aren't pointers, but really, it is a lot easier
> > for you to do that annotation than for sparse to figure it out.
>=20
> I was fairly sure you'd argue that!

Heh.

> > I blame these problems on whoever implemented sparse context tracking i=
n
> > the first place, documented the optional first expression parameter and
> > then didn't write any code for looking at the expression at all.
>=20
> Yeah, that Torvalds clown is always leaving stuff unfinished.  ;)

:P

> > static inline void netif_tx_lock_bh(struct net_device *dev)
> > 	__acquires(&dev->_xmit_lock)
> > {
> >         spin_lock_bh(&dev->_xmit_lock);
> >         dev->xmit_lock_owner =3D smp_processor_id();
> > }
> >=20
> > Conceptually, I think this is cleaner because inlines are treated more
> > like real functions then, but you may disagree.
>=20
> I disagree.  They *are* real functions, so treating them
> as such is the only reasonable option!

Well they used to be inlined in the context tracker too, and thus
typically do not have any annotations at all. So with these patches,
many new missing annotations show up.

> (Note by the way a convenience there:  the lock is easily
> described using just the function parameters.  I suspect
> that will be common, but not always true ...)

Yeah you can do this too though:

static inline lock_device(struct net_device *dev)
	__acquires(&dev->somelock)
{
	spin_lock(&dev->somelock);
}

and then "lock_device(a);" will increase the context "&a->somelock".

> Will it be possible to put annotations on methods declared
> in ops vectors?  Just today I was cleaning up some locking
> issues and had to start using a lock.  But I couldn't find
> any clear statement about the call contexts for some of the
> new lock/unlock calls ... I had to go look at other drivers
> to see an answer (and hope they weren't buggy).  It would
> have been nicer to just have "sparse" tell me the answers.
>=20
> (If right now that seems more like a research problem, I'd
> not be too surprised.  But I'd like to think that someday
> it should be practical to have kernel lockdep tools tell
> us about such things, and have such constraints verified
> during builds.)

I'll have to try. Let's see... Nope, doesn't work, even with the
variable context tracking. I agree that tt should, in theory, be
possible to do this, but I haven't figured out the magic yet. However,
it seems it could be an extension of the third patch I just posted
("allow context() attribute on variables")
=20
> > The status quo, however, has turned out to be unacceptable to users
> > because of the spinlock problem I mentioned above. Can we, based on an
> > evaluation of the problems I just outlined, either apply the patches I'=
m
> > about to send, or revert them to go back to the completely unchecked
> > contexts?
>=20
> Haven't seen the patches, but in principle I have no objection
> to finishing the lock context code.  Fixing all the kernel code
> to get better lock annotations will take time, but that's OK.
>=20
> What's probably more important right now is to make sure the
> annotations are simple and correct, so they can be built on
> over time.

Well, the foremost important thing is probably to figure out how we want
to name contexts, I'm using expressions such as "&dev->lock" for that,
and this doesn't actually track things like this properly:

dev =3D a;
spin_lock(&dev->lock);
dev =3D b;
spin_unlock(&dev->lock);

and will not complain in this case because the expression is different.
I didn't really think of that as much of a problem, but maybe it is? In
any case, if we want to allow that we'd have to use the pseudos for
context tracking and I fear that would be a lot more complex especially
wrt. function pointer passing, almost to the point where we'd have to
pretty much run the code.

johannes

--=-d9dxoJqoVSpNni5kIg6L
Content-Type: application/pgp-signature; name=signature.asc
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIVAwUASD59V6Vg1VMiehFYAQK1Bg//R+Nc5GCz7PDpe/9NtmO3pXYBrKSzunZP
FTQ0hu/cSpUhi4eO/BnrEhA3v3FISeuUTXldH0dVWsIRE00dwWTyfZdv29fVEglU
eIcwZafnoVmIfMlmKFheQMeUv54GqfanMu1xiscRfKD/+hFf0st/+jGNGsNcWcoO
d88RQE3YlLoeuivL4UNsFBlfT4akAf9iKCBLPR4yYRO+u8M09ab2QViXPCldy/HE
YpoRsJZnyTYuXvJhBCO5pDpPrKVlUwI9570YPaLEGoAGc/yrruMGuckxliqiC7gh
5S5oeYzjljNiTCuAkoVt8b1hHqgCVXBOOyANMLMPXEJ2e32AP1tlzmO1OFIPgeiu
R8Q1VZPHmgzGbR3GwYeb/aPRXbLpK9VOGIgC9QxTO5Q2U6j2zgJ5/e13tKRYW2d8
FrYU15fFci0UQXDkr5WEywRg2s0IwJt3Lh1Us4LiWq5juSAuJ6/yOmon4fIsrLAM
ZflK84TPq9kqtat9lboiQqup9/qWwCBBjip3SyrNaqpR21pRxKAOIEOT7EqEHDyL
PH40xTteaZTrx3S/rf8xd5n3BlPsEKQibiUPfaVqUktxbtYEr5TbDwP+/Efr5JVn
qIQzp9Nwp9KlvM6Ld4vqkKQDv4SC90wKZ7modAUhjZn356c5nFJnvQnTbBdEPqc+
yWi0lJvMaJM=
=ppax
-----END PGP SIGNATURE-----

--=-d9dxoJqoVSpNni5kIg6L--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse licensing query ===

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: sparse licensing query
Date: Fri, 11 Jul 2008 23:02:19 +0000
Message-ID: <4877E67B.9040106 () cowlark ! com>
--------------------
This is an OpenPGP/MIME signed message (RFC 2440 and 3156)
--------------enig50B9B0039AEF0919B6D81DB2
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I'm just putting together some documentation in preparation for a proper
release of Clue, and have been doing some license paperwork (I want to
properly attribute sparse). I notice that the LICENSE documentation
refers to the OSL v1.1 (and provides a dead link to www.opensource.com).

Given that the OSL is now at v3.0, does sparse use OSL v1.1 on purpose
or simply that nobody got round to updating it?

(I also note, purely for informational value, that no version of the OSL
is DSFG compatible.)

--=20
=E2=94=8C=E2=94=80=E2=94=80=E2=94=80 =EF=BD=84=EF=BD=87=EF=BC=A0=EF=BD=83=
=EF=BD=8F=EF=BD=97=EF=BD=8C=EF=BD=81=EF=BD=92=EF=BD=8B=EF=BC=8E=EF=BD=83=EF=
=BD=8F=EF=BD=8D =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80 http://www.=
cowlark.com =E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80
=E2=94=82 "I have always wished for my computer to be as easy to use as m=
y
=E2=94=82 telephone; my wish has come true because I can no longer figure=
 out
=E2=94=82 how to use my telephone." --- Bjarne Stroustrup


--------------enig50B9B0039AEF0919B6D81DB2
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFId+Z+f9E0noFvlzgRAkqGAJ9hhXlqVbKVs+vVDqDSqQ+DaZZpbgCg1klL
Ar2csra9xr4lZa0hKg/IkrQ=
=dj9p
-----END PGP SIGNATURE-----

--------------enig50B9B0039AEF0919B6D81DB2--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: spyparse - sparse reimplemented in Python ===

From: "Anderson Lizardo" <anderson.lizardo () gmail ! com>
To: linux-sparse
Subject: spyparse - sparse reimplemented in Python
Date: Sat, 31 May 2008 00:39:36 +0000
Message-ID: <5b5833aa0805301739o6ceb14a6ha84271b938ee70ed () mail ! gmail ! com>
--------------------
------=_Part_11840_19779440.1212194376536
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi,

Yesterday I had the (crazy?) idea or reimplementing sparse in Python.
Some personal reasons for doing so:

1) Learn/experiment how to implement some "advanced" data structures in Python
2) Learn more about sparse internals along the way
3) some others I might not remember

Attached is a tarball containing the very very initial code. It
doesn't do anything useful, but should run without errors. A lot of
functions are not implemented yet (I started by sparse_initialize()
and going down until the lower level functions).

Some notes:

- I decided to take a more pragmatic approach and start implementing
only those functions necessary for writing a test-*.c like backend
- For now I'm just doing a plain manual translation of the sparse C
code to Python, thus forcing me to read the entire sparse code (which
IMHO is a good thing for achieving reason (2))
- Along the way I'm rewriting some code to become more OO-friendly
(with classes, methods etc.), therefore while the code is not finished
you will see a lot of mixed procedural and OO code
- I'm newbie in Python coding, so be prepared to see some examples of
bad coding style :)

I cannot guarantee spyparse will have all features from spase (even
because I do it in my free time, which is shared with other projects),
but right now I'm having a lot of fun working on it!

Comments/suggestions are welcome. Regards,
-- 
Anderson Lizardo

------=_Part_11840_19779440.1212194376536
Content-Type: application/x-gzip; name=spyparse-0.tar.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fgvh7dmv0
Content-Disposition: attachment; filename=spyparse-0.tar.gz

H4sIAIyYQEgAA+19/3PbOLLn/Lr4K3BObcV6pWgsx3Fmks28k2060Vtb8kjyZH1zKT9KgmxuKFJH
kHZ0V/e/X38DCUpyvs1LprZOrN2JJeJLo9Ho/nSjAdnFchFm1vz4w7d79uB5/uwZ/tt+/mzP/9c9
P7Tbe/t77fbB/t7BD3vt/WfPn/+gn31DmsqnsHmYaf1DHP3vMJumD5b71Pt/0ce6+Y+jcWux/CZ9
4AQfHhw8NP9Pn7fL+X96+KwN8//0+f6zH/TeN6Fm5fn/fP4faScB+oke8h+ZieaL2MxNkpupjhJ9
scxv00Q90sfpYplFN7e53j1u6P29vZ+07iRTk9k00WfMIf23UL5pCc/++808jOLWJJ3/oh5BK6Pb
yOpFlt5k4VzDn7PMGG3TWX4fZualXqaFnoQJkDGNbJ5F4yI3Oso1NPtjmkH9eTqNZkv8qsCedH5r
dG6yudXpjD687l3q1yYxWRjri2IcRxMgbmISa6B2CH3jd/YWBjdeUoVTpGAoFOjTFNoN8yhNXmoT
wftM38GA4LPehwakE2mxqdNM74Y5kp3pdIHVGkDrUsdhXtVsbRx5NUDiMzZ7my5gNLfQIIzvPopj
PTa6sGZWxE1oAcrqt93Rm/7lSHd6V/ptZzDo9EZXL6EsTBK8NXeGW8JJjKBhGFMWJvkSCIcGzoPB
8Ruo0TnqnnVHV0j9aXfUC4ZDfdof6I6+6AxG3ePLs85AX1wOLvrDoKX10CBRyL6Heatn0NY8BQZO
TQ4TbnnMVzCdFiiLp/o2vEPpmpjoDugK9QTE6fPmLE6TGxohlK1Y+FJHM52keVPfZxEISZ6uzybU
ruazqbvJpNXUz9pQKEzex8D0YQ7FoYnTaAbNn8ZpmjX1UWpzKI786ui9fdBOT9pP99pNfTnstJSa
Zelc2+V8nMbI5jSD2Uqi/HqSLxcgEfQ3v7ZcdpFnIHG5KxxOp9fw1TV+dw0DCG+UmpoZMCiZxuba
wkgnt7thdtPUifmQN14oDc8itHZDueu317MoCWGxmd1PlLz7SMlJZkBgr8dFFOdRcg2CacL5ejEi
PcNys5nJdmHO5yFw79+AWLtWeGomcZhVjc6KZILzYNfbtaR7rpF1URh/6j2OAHq8k2KPYF7d925e
eAB6FmUW6LMpL6p7Q7oFRgHEATOM1SaftKgVf9p2G4q+w2HpV/jPHX2eRbGhmXylf3/H34DUw2tc
v1iYCaLmZvjF73vv9KtX+vGTx6jAdGwSJLyhf9HtqqjX05oI/N5+8a5Jbxu18pM0AZYWpvxyXah2
HbVUX0b0sOxseO0LDFevDx7GiCNy/eCw9jwOlGvC1SbCNwtafRyVhO084onS19fHb4LjvweD62vd
/p/JTsPnNIwXtIIBxTAx1l6nSbyss/cjoliRJoNblcWqwCN9kaW5meSsYbkA6J33oHPDOE4npGYs
yFuUTEhlLmEFg7ID1WSL7A4UH5bz2sN2UrQxtlV+u+A+rqnda2rXEZGZvMgSvcuzWvJdfa39L/Hf
cf/iqtt7/V+JLdzzcfx38LS99/SHNpRoA/Bv7x8i/js8eLrFf9/j+ctfUKrI+Aa9YNA5A6N/dNY9
1vD/oDcMFBeA5zcHgZr6PwpYju2ff26DTNYhYfvnn35u0qsHMZXYYPXZRrhugtECKx0ArFqmQAWC
AYB+UZ7zIiNIgYrWw45Qdgxdz/FlZKxiyAE1YwEu03RSINptEryagAq8iQBvAACDQqhZcAnemylY
/r8wPy5QZ41jg4tyBCtYWrKCgUCLODyrQwJENrpJmMI8fA9f3odLQowKwe8UEAIqiFsqD8QTCQh6
AXodLUnVZyEu+M1ISTkEBuRGANoBFVNXN0WIyA/mgcDpx7rCd8rR/OQJFJkjnaCzSItVw3F4ncwe
oNMotwhPQX1pgrfqAXAYLhCNWuyc+COwr47VKil5bD0OJjQaxNSkKUsEfX+bYssFAN/MApfmIAdQ
UhWWpw9I2h2mc1GwD0pkbXCTFMSFPAPlmH0GFgWqPzCwKLG5CaethiaoS+gCxkr+CdBCnBeCwS7k
adpCoXl7CxYDwIhdmPA9MqPmBDXxFRKUGTCBGY4GGCDz10SRVIsM+ocB9ouHKLNroudPKXssiiA5
DtQTDm/p8IpZow8cHhad7IYkQdFyAibdQddojtGHuwcXq9Esu3LAHxopsgk2PTXofSDDbgy6O8pV
BJmFj15VLCOCWhNGqA6yp4HGCVOJjSRgce+ZXsf3lyxDrrn3SXpftjslp8Fiy8BnS7MzSp0N5pVD
Cs7SrDhrTrzMDHKKcQQ3D8wYR1MFsoraCZlpElrp0gm3hISjRNv3/IrAQWZKb5ZLtdSI69R6gRVt
0bUkbWcy8LTQVbYLeBmNoxgQiaghbJk5qjbOqM9J8mKF/aV7Taw4hRfmQ4gBgaYrsbE5W0xuwacT
lgOvbg2uOgWf8ohGTCpDzww0RP2A6dU3kcgfSEcETSXAHFQrFReIr7iMyH1s8SqjuivijGCLFliz
FDVPvNB79SSvRYGLig7wUO+xzNwJA8UTyGsACEcCA39FmXJTg2vYbJIScVPvYU5zs7Av9G67QWaJ
rWSd6yCWane/AfyDdS5i4hmm+9sImIo8svQyNjewzMngWTLGYvGa/gxznMRNo98fUd2JLXAI58KE
OGOkPR9bNxRsFRcLDIgFnlajE3gROEUMN84IUxgGcFQyteVUsDZN0ir8gF3S6Gq2BiaiO1szMUR8
xAEaCxocezGxZVuATiG8Qmhwb5RoC+tLEJArU4YunxMOjj+ISSfcDVOC7g26hzwktDHACLDsczKl
WTotJkwGg3QOyWADoJpjnPo0qbWlxBw9hgKLImd/gFcSvo6XTerEV09IUn5LXhEqarD2yMscTAiN
XmzjAl/naGZB7lC3kga5S6Mp9T9F7ZjxiL3IGRpGWJwhM700nDiIKJlGd9G0QKJ0OiZFwp2UcAZD
GdqAbE5otZEduq2agX/BDBkA0MuWKE2MPuU0zSQ8xPF5OKUA3iQ2oVAILJAB8fIblxBqyqIpovVY
0AZqefga+V6WCwmXtRwEW+D8lyuX7FMKI2StiW3iQoERNCv1JbKuWNrYd4OiCPYI6n0CGsPbUTA4
H+pO70Qf93sn3VG33+M4mrhTTX3SHY4G3aNLfEUFz/sn3dPucQe/QNr3WhwW3ACURBqJ1zAARjH3
afZeFAPiQpg1q0LkDJreRRxOqrBmpXVu0xhtiw2XAmzngD+B6V4AUm0MpgJhm9FFi7m+c8H07QB2
NsC3piLIUpJPVsEbA1JPag9EcoeGMg55MVPPrjU1N2DmXPTVe4NtYLtAanQHEwbiRa0w8dWA4/D+
BS/piGiBkUO3XFbYJtJca1ljeA6lgLBEU1XhX/YgcASo3n2JsU7jlqYZg7k0fpoxFcPSLMIbZNnu
G1CMoAdmwOJmWQE7JOg+iQuE7i6UG0cAaOV1otzM6B2/9x0EngFqclkYpOHC6TQzpCVDq3fAdOyA
QHdAu98xPkiFr4irHloWtUESlkTcWeFjlg4Rh5esYQmUFbmNaMWDAYXWnaiEqCxnKiuSNdaLTnZA
x0ybAtioNVCjmqKoXhXlQXUM9iA0wQ5xbskEkBaNcjKIek3QlOt5F7SgWSDySsgnAYWFxI0NwHPS
WzDODRQ3Wuot4xtdCllWINrGtiz24sxOOchpatgQtFuMYcLl57irDqpJM4+tD2Nwen1sjagZA5Gw
QuZgBArAYbD4QMubCv4qZM0imhRpYWPuHXQOqXKQXfhGtkdwEAQRhEi/lKpWmmgeGcQkDqM5cAWI
dob/pX5vzAKXBEqAgDvF1awzWAh/KHzva0L2+3Dw4dgaDKihKYOxlU0rLEMYsvIOPRxQZ11tx6Hq
R9V2F8rSMFXlLLGjQ9hVYAyo2tulhcURi1zzYnbeGvfE+G4prdT3iATylejIg19ocz84v9xhZpKc
/UpyBN5RizyqbLPAOI0pmk2xZoMSBZnFOZP7oCpuiillOfVxJqn2uiIUBb9pX24og2urcAzrdoNc
gmgA3p4bw0LCo7DGM+MvJCbfqHyASVhYdiBKyIhBUdL5E+AtMRbGiMtbRI7asKhXaU07F5P4zTqH
W3AaaIrOlggel2oxHeM1Okg2kQFlsx6/gDmyssSzBZ2OzdyDcaa3hL+yvDTr9J1lU4fjWlGBMrGy
T5IJ6k5n6APVABXoiFB6CZELTp7RRNFqjLJp2QoK0ENIwJl+Hv6k4ZB7yXpn6BPcFUJYCaB2ypEZ
cg4wOJWFaIZAz8jgQdGCgvVcQmYlyii9xPgsmlSnhXFFoOjJlk3ZIGFE2UTlCFM2BUubobYgvxCo
i1DJZzgpAJRQoFmekiQtQLtgCFCMMC2KmsbTGzVeSA3IFw+7PrsIaWPcLBYEVsqHrAKmo6zQqOIV
FFujFV/bDycNJNym6aIWVheMmFETx85+YXOafN1U30XmfkUnUisVwtsNPkwMqasXaGBrJju3Jp65
iKObA6CNmkBbRya9lARmPgcJkhrLm6zEahrIjWYdIfyvIso4AsMtrjTWaqgyakJF5xxSoIicGJNS
XKnLanWQK6oihALwPgQnUFsjYRfiDzqTVIWx0IMrs0lmCSMPY6QjtGkCrVEcF5FRRgCxgh1Y2BpY
fChm2IEVuDcHFt+hF5bf0p5+tQR5YhHw0AptYhSLAtXVOFOwbCX5tJJW9BFFO0K70jVGnIu8rKBW
ZM6Gc48rmEuBmoc8TNYw7JlEtmZT1KpNIb3q402xWdyGcwmlllNCqs4Bjv5WwRD28hgDOCwMLsQH
jIfL1Cuc2ky6cRizIGPBwRD4glxPHlZmbsJsCraA5h8q6Xu00hwaG0HFprdHwBuCueBICYiyzUNb
hLjIi/4RTrW58gNHUIyduwy3MwAEELEcBoByLzXM0i35DVVX5N0o88Fk7Py6sBlHhjCAEW9ktuc/
pRmguRhjGc6bshuRAIy5SzvnEW/jzFHRhTc3yCXXrLg8PA7kyqaG1CrUIv1IX34EiDTwc6jv0rjA
iP4MnF6bpxn4VaLSq/Ex9K2U0Dhz6s+jjrUmyTQ6KRuN3NOPI/XVIaxSjx4k21KHfvYbaKLS8T8x
ouIi4DB7kyInfYOAbIP5VUO34tpEw74mEPUQhgJlgAEzWVMc0AAOVPCpMwGTvEC0QklGMhv4XWzI
1GUcUSY7OIeVAQDqCdpyJJLxU+WDNGXNu1XrJzU9DATZ1NSHQxMskzeB1tJ5mEUg/4ULC1UhQrQ5
DMZeAgubJSBbH1lYridC3E19F8YRNwc8i0E75xR943EtTZjRNk3lVRA+IoWwbAoeFwCVpJzvRH40
7eYRLpLtLecgoPEzmYPawjhfXptkhJn31MIqx2uJUvXJqc0D4T62v583Bw/zn0fyFXMweUi6ooRz
hXAZeC4rwVMxzDRBbPpXdqEeGDJCFAqehTHQkrA+ExQje7YcHZhR8DBBIIqaEry2tWiHiyKg0eNM
C6HPh1qfXrw03hKfhqXUoVcOfMk4uqOHxdhZhzFzX5BLbXtsVikVDogxLbQpyNMxLy0nFsKtOInT
1h0z4Cdth56Sz+ATzQG5culz74p65y7dbswaXfA9dFKgqxRVTgs4dnFhyTEJrU0nkYuHwRIIUfAx
mSfiSCu6WVKe9XAWLXg7GQ22cvYLiYskTEawB+PjcRz6wKEaEYzyDUz8HTIdsZ2yC0MzbhyWba6N
x18utMGHVkPCcbiXR1uDZaSnxLR+tV302jlaKC0Dj8bkgCicp0a1EubhPwkBzEGiCZ3u8giR4vcg
xiZmaGJRjTdkhApsVMY+q13aHKAbxZhQ8dbHj44ScLVICLcQzWVXSlB7KCuU4sx17oGRn62hBa91
hFjeCsC9GgmTkaADfQpap64lG4PQcSgb0SQNFKUWVOtqaYTroJqRypUG1qTPwW0Co9QYvCgI51u1
CVbWtKQkyKbFza2n2yPZL+cY53wBPpOXUeI1shIt8phBkOGgggwoRBwG4mANeH8UQi/ThjdDCcWC
isJrPiwwjEvuk1h6p809pIJbmRheAqFY5Iogzj2BwfTB7h/uHdUnbiqxCNJGUVigFcjFlqERiXAe
a5ueG8hS5TJ0/EUEXc8B5ogVMcPtsdPsooFwAM2LCJabby5tIcqq1JuSMFo5NEvo3aAqdgSAO4i7
XPC/WRGzYomjEFxHmrpnPHXOu/N9TZTIRb7ignGOn9uZJsmRXAvSteXwEROThOMG5g06+By0re/j
SkAPNPgDE4PRoNyu7nxw3g06vKFzyjLaobuNxlHOgfo4vC+37sVPXB8PtwO2JcWN6fGSd8UoWlHD
1yuh+10JLz4YYm9waAd3Gyel1HD/oYR0a3OcE37FPWqMN7oUoy/Z1WOKS/LVChNXPBzJczhs8S5K
Hs2N4JOPIf1PjDj3MxpWFpAIP3rIbjU6jabcLrK84TQRXsT1SKK3u+/ogtVNqijHvWzzwE6oy58Q
9YT56BK3nBUZ7VbVsk3EBatC6o916WuKbhUFQHINrLilDa6Wqq8kSU9hkASOLfx3gvNUrUDZUPK0
MY1jxSF73tLdGdt1iqbAEi33BdAGgNP+z2J6Q5E8xiiec8obzgqAKBoc4wrNZD7d7gGGa/QubzXP
I8krlM1qWK6FsY2m8qSQsDDxkQQBZWdXkl9wUEwVAD8CJOAtu44rTd1wZhrT/GCZ5AL0yy5W1kiT
N9t4LaO5wNAn9ltaxofrcr6FJD9hdT+inwoYt5iyA+Jlo3kRwzI1vFXE2xdgQ24EVlZaX/mbNl6m
noG5pOC7V00s/9okIvJ2gvnA2pM9//W0pNDNbpk6QydOKC2c8kN1li7BS1g+oXwCb3F7MMH1AsqP
UW9KOThpub0mGyxTMAsTzM+goH35CbxIAhUwDh4iaR7yKyTdE4UBqHLsHQOT5GRTXQcy8WNUhrif
nqHRKqNBNMkfIZ8hnLflsxaPgj9vTYxAmn1hTKNLeFEaAnlseqkJXIyTIg5B00bZpJhb0tqs4cZh
XKlw4zfvZaEqjkm63RRXyNuUWMlalezJhEVI+d3i/mm3FnFbFBlpsA0hN5iZQuwzfeJV76We2Cqp
AsP8IKpLCZ5RtM5l6UmojuMGEZ2jokYols0lX9Y7vw3FocHReRS6PT5Jo8FB32TSYi45mJV/XZti
xvzNMryq/CN6Y9mznZQGZUEBeWSY1uc0jyaF8lU+jrrBrA5Y1qx1pJvSE7/HDfyMdiAxtW+NJDNV
TtpJdYlLQqmIos/ThOPdlhQnZbVMPJctBLBElV5KDLVYlJu9lEH14zRNeAKmYH2mlFZKeVba3pLM
IBgk816LFZS0OvoqZSREcvJJmS0halAsISvi2zQiTDhaWTW+mFI+HBKKvWBwn7Kb7sVHHAMbzB0v
gLFZt1ZsVW2+pp7Ryv3Ucjtrq1GKHyXjdUVhRdbLncDNA5cYSm5RhjpLfFMUlUr4x8tqW8v30llF
V2hkLZEIlSI5XrZGx7oXQAodT1tR1AFlAGb7xmDxxS1tn9eG6GW8gFnjjTjFergcSnWYq1a1dhKA
gzkJYYA5eAKqYgRrjsJKB2aKFjHhnalJyMbVU8WA8VNYwLhBYkmfeyTCMgehdOFF2Xscp9O1FAOa
1Z9blAbzYBY6csqlXmTmLqKtW55yTGiWg6RWuQOTDxzCJAiAIBZXE/yLpzdxbH4btHZQLsHAR6jb
gXa7iDJKWXdBJovrVmrwyQikEGAn5i1ABT7lSRqes42oizJ7kjc5QBAp/ZGwtTtFC4zB6CpGG3EK
YY4LGDSqRVciKeZjk1W5oc41pljOjHz1lbJrfgRrSi+bTgztDuru2tncnWblxJHFdgkaVejcC5/W
8bTLEHP7g46oNHMpA7WuNh89VhvEYW3s1XYGM2G5iQUrW2TLMoEldTDfVUHX9BMHob3jGJy3tNdy
2NHln3qrg6DCWvIJJcKx+vUzUK3s3tVW8AqmZkmjDeLa8V42D0ry5xG9V460IMPSCJS7kb6a+wTn
P3aauHY2HI9vpHODi8wqMgdliNGW2c5yRANtGPHdHekGkZ9WtGC6+E0axrS6ae1ld07sGBWAyik4
lRfqVzEA+sod7qkdmeGW0nlauux46IcTG6agYMSMlFVuWJ/Ey+qUU69fni+n+W+39FFw3LkcBnr0
JtAXg/7rQedcd4cuJfZEnw6CQPdP9fGbzuB10MRygwBL+G1hgqzXAJTq0+fgH6OgN9IXweC8OxpB
a0dXunNxAY13js4CfdZ5C9wM/nEcXIz02zdBT/Wx+bddoGc46mCFbk+/HXRH3d5rahCzcAfd129G
+k3/7CQYUKruj9A7VeSj7sFQAR2/dU/qg9rpDIHsnfKwvSMeB4cH7//e7Z00ddClhoJ/XAyCIYxf
Qdvdc6A4gJfd3vHZ5QllAR9BC73+CPgEIwM6R31ijSvrWgdioH21ekYf04Y/45A+sRAaAYYPusO/
685QCWN/veyUDQF3oY3zTu+YJmplInG4+qp/iVYDxn12ggWUK4CMCvRJcBocj7q/wfRCSehmeHke
CL+HI2LQ2ZnuBcdAb2dwpYfB4LfuMfJBDYKLThfYjwnSgwG20u+xbtlv4eSBlAS/oQxc9s5wtIPg
10sYzwZJwDY6r0HakJnevKu3XegcZ2h18ptUBV5Uk38FYtTX550rzsq+EvEAMsu07bpUgFBU0tk5
6iMPjoCeLpEFhCBDcIpOOued18GwqUohoK4lk7yphxfBcRf/gPcgejDXZ8wVWEW/XuIswhfSiO7A
dOLQUA5lynANoqz1nIxA36vrcrfqe0X+UC7O+kMUNuhk1NFEMfx7FGDpQdADftFy6hwfXw5gaWEJ
rAHUDC9hsXV7NCkKx0uruTs4ceuJ+KxPO92zy8GajEHPfWAhNkmyVk6IE7Jho0kyoLun0NXxG5k9
XVu1V/oNTMVRAMU6J791UfNwPwrWwrArPOlLC8LHMqcfVgmX35C9D2WwxBtOkeqQL8rx1RGZf/jy
CvVtD7COGDmLAiyGcQp2NU4XYJsFDFU5lN7RNsnQE1t5Q0c/bK7AA+EgWWFL88OOnfjb6DBgKIEi
0rfoYDDm4Rx3MkFRruqmgE1geVZn7WYV7xBouVPsgofuMJwLyOZ5KPtNFTIqE3kdcOQgBHCEHCEb
znBoSHFZe+4KU24fbTDhG9lgwW3B8pgoHz7hfEHAB3dmKRtWgN2toLQq0Zjyd7ApasO/dcRt9ROE
3ynRwA7A+USCVnqRkgNEeTiUxUcDLXjLgQ42olkHJkkC5N+Qn1TfpQt4DHgMWA23p7jpMbgeMw0W
P+RMIr7ehTLCf6G26seo/4ZpCL9AD9QEGn3CPL9wv3/o/hyJHHP25FfcoLN6f06Zqff5d+hsuEGH
WvmcW3Q2MuBLr9GhXJE/dpEONvHHrtIpDxd97mU6VOMP36bD+5ece/s19+lsOskPz9cf5seDKZi0
hEECP0cE42ishCm1gA9ZIl42mKqWpQmMiU8DAvzXdMMUBT5r6Rq17NSm05DuUEmIrMzKhN44es/6
VFH2I5Qj/WT5REUtzxUWkZF0qtcJYOw7BvdOxA9/bq6saFzQur6a12pPwJmQ46Odo2H/DMDH2ZUP
nF+SVIhAaLxXRf8nHVy9f9yqFsaqRqisD5kDE2M/yNcVBUEtyDmqMnzkPLKXfneTxz4hLc5buV0u
0M+jXa4q49vRRzSUtUWC3aHb2smSmhv54Nmz/ow2VmQvpOqPNo4txjiXGN/AHTfaDwY3jQIM3sGn
jaTJOSaO05MGGBs1T6HJJxOg4D3FNeYmKYBhZm6fPEFdTr60LSLe1y2P+8sJEhksZebhSWQqYkCn
pEuotusOvZe5yFJ7brKG5mPcmbLowce805FwNjtuNeMhuio2Vx2/2alOqTgEEs1UgqfkLR/WfCNZ
6iEmUSxiMBuUQkV1UEz5rMVVukyny8S4e7PQKo6XZUecHFQRQCsEMYooYekcGvpPT84f4/YYJQzC
arR8mtdqSVPBLBjbKGNq0Nl/IDX6TTh5bzJSgn/jPBI89w1SMlrCSkuTX5q6DWgti2K6gwRhC79o
4l0dNnLnu34DCZK47gP6sQyzyL5RFeJA+fHnl4IbyjsEW943UG6yZb4qCnGLNktxhxqVzTiDKmWM
RrnkcDqdiYqfrRVtPjIloFsptcvv0Yur2zIpRUnjLobESuHe5Yi6E91TgHTu9Mz6PRdq8z0X66HN
P/sKm+3zB57y/ie+9+ybXAH6ifs/n+/tH5T3v+4d4P1PBweH2/s/v8uzvf/zy3yX7f2f2/s/5f5P
up0PL5z0bwDl2wyhHwQccvdnZq7lXsKqKG09LsL8VsrQwvMbom8ypc77J9edy1Hf3Q34Su99QAVK
LwbB6+5wFAy8F/v0AsPh3eNajQN6gSH2Qa/24if1qNVq0dtR/+Is+C04c29/IgWt1O/kGwyvzq8v
e91eF4OT3f8RnDTLry8GwcWgjwHf/qD69qgzDEZXF0H1Ta9/4n26GHmFT3vV3yjUV9XH4WhweTxq
+kT0vdJB7/K8+oQdngSn9S/63ufz4Pwo8Knsjk67wZk3mrPOUXBWfRwEGAv2CTjtX575w/97cPW2
PzjxR36i3gELKYVit/1zQ6neEEbfC5Cv+Pd553jQhw9t/CA0w8d9/MjjhU8H+hHd11OdvigSd+OE
BicEI3RQnuiF4j9R5avzoz5+ah/ix+4Ig62wsl/pp9S4P1Xw5eEBfnnZ4+7b+9SGjAfpeXaoFIB9
kN3jEXiAfKkmXsh6TfdjXl/vYkZ5o7psEz+2MC2SHMZXupcmpv5Szl9mlnhRe5UuXA3pdEiw5IFe
m3LJ6yus0SS/Rf7Evr1v7SKc8OdVQoVI/Kf+gj2GV7yQ8fZNYQITtMv/ND5BGPfO5HiUeERwO60v
ql0ndCJDoOmpCOWG+4sHKTR3YVyAiRI2mQ8LECr5gLfNrrKLr+IFG9Y/6b/QeIjDggtnFANHbpuP
CLzS/4dqPQLdygf0iCT6bgdzYXdeUIu/c2dOwzVp4t/xItrJzA2mDmVQ1ivnFF69LB3mn1CrXlnW
gfWSeBo0S1ZLslKUkur/8oXDjj/XeXpNmVomW7+VmLl27a5sul7Ui5SXzSbXMksiPiSfrPUaqqp9
TfLvpm6XWnJ0wIsNJPG4mAwssUqPamyaM2xo04ztXJf341ZNuNlaGQyzzlmMpq6NQvj9yGsQNwLK
xj6nQa6wuTGw7HgZQNXapxqTCptbA66ZSf4FpHGFzY1xrgW2mXGLn2QcV6DGRPbqN1G/kBsr6D7r
Vz7O2N2Rtnea+km76eMKuS/YwxK7XIfVBx2Iw3AkZv6srmBPRy6xR6f06mqptOe6smANvybr0BZn
MxgUz1Hm3VeNJUh5+dZijZbfsbN3v++921DPNyQPVWy/k7Oh9Ulo3YVZhLnWaPRerrFkZYF8BUPY
DDc+PtqVbj53rJurtevVSJVsLrn/zhMzuZ/bU1t/tk+6fb7fU8Z/5BcKvkUA6BPxn/Zh+7D8/Zfn
dP/3weHh4Tb+8z2ebfxnG//Zxn++NP5T/hDKx35uY9VXKAvjMd1l9ZsZf6rlLfW//HqF+QYG4FP6
/9nT/er3v9r7qP+fH+xt9f/3eLb6f6v/t/r/a/T/xh/p+Zfzoqr9X/rnm+3/fuT3P+Hvw2r/ty37
v9vf//kuz6P/9mNhsx/HUfLjwmn5rUXYWoStRfgyiyBbt3YpP/gYR2O3nbv2y4VK7drlfOUX3NZ+
dg5/cw+aa9HPHCq+7HRH6kHhv9qm/2OEf7U7+q96Q7t4yrplPkT57t6mX4kr9f8g6JycB99Ex3wK
/+958Z/2Hv3+28Gzbf7Pd3k8XW8/rutffe6jnGrcU6onVx9hviosQTpVsTQ5n4R2F4hhhqVcP0cX
bLoEzCn9hAQ1oFjftfAwSlYkL5RqVYhFqdPOr0ifUr++0G9vl2UWKywYGd/Ov6vOCzmS8k+8qHKH
q++wDtlZLHc4fTU2IaqiFw26aeIebMMET6piHjBdTA1d4w/6vE7Tm9hLFpXfZSzvigvHqHmjnH7d
Z0T3hN1FeN1CKudDoUdHAZ1K5g9P2AgDVXS5aow3QC7pJ+MSpY45D97NhFJDQ2eR53LHMV4ZV9zc
GOuucgBav8wW/9nSuH2+91Pqf5fN9CfEf/A330v8/xz1/zMwAVv9/z2eLdrfov0t2v+a+I+fhsH7
/7Mp/1z7NeVf+OF/TsmiVLLPTKDzkiZOwxiY8I3Wf7X/W2Wp/lebgE/q/6fPq/3f9h7q/2d7W/z/
XZ6t/t/q/63+/1L97zIq8czy6+Pj624PE0g7Z9d840aglJeJByqc8+d3diQLlUKuUqL2HW7BxuUb
9e7bO2SV/v9m4f/P2P/dq/Z/D59h/H//+cFW/3+PZ6v/t/p/q/+/Gv/XM6v/5XZ/Pf1/Hr43uGnw
Dfr4hP7f26vyf/YO9vdI/+9v8z+/yxPG8Qv0T02YvFB/yeb6yUz/G8CAyb+MBG+f7bN9ts/22T7b
Z/tsn+2zfT73+X/yTO9nAKAAAA==
------=_Part_11840_19779440.1212194376536--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Anderson Lizardo" <anderson.lizardo () gmail ! com>
To: linux-sparse
Subject: Re: spyparse - sparse reimplemented in Python
Date: Sun, 01 Jun 2008 23:24:24 +0000
Message-ID: <5b5833aa0806011624o6c08f241vd51020fd298dcbb2 () mail ! gmail ! com>
--------------------
On Sun, Jun 1, 2008 at 4:33 PM, Pavel Roskin <proski@gnu.org> wrote:
> On Fri, 2008-05-30 at 20:39 -0400, Anderson Lizardo wrote:
>
>> Some notes:
>>
>> - I decided to take a more pragmatic approach and start implementing
>> only those functions necessary for writing a test-*.c like backend
>> - For now I'm just doing a plain manual translation of the sparse C
>> code to Python, thus forcing me to read the entire sparse code (which
>> IMHO is a good thing for achieving reason (2))
>
> ï»¿I'm surprised that you decided to relicense your work under GPLv2.
> Even though you are rewriting the code, it's still possible to argue
> that the original authors have rights to the code.
>
> It may be safer to use the original license, or you should make sure
> that the copyright holders are fine with what you are doing.

IANAL, but I had the impression that a copyright is applied to the
specific implementation of the work (and derivative works, such as
extensions or modifications to the original code) itself and not to
the algorithm. I presume my code is not a "derived work" from the
sparse code, even though I claim I'm "manually translating" to python
some parts of it. Unfortanely the "The Open Software License" does not
even describe what consists a "derivative work".

That said, I'd like to hear from some copyright holders about this
issue. I have plans to use my code with future projects that I'm sure
I'll not use OSL, and reading from
http://www.fsf.org/licensing/licenses/ I can see the OSL license is
GPL-imcompatible.

>> - Along the way I'm rewriting some code to become more OO-friendly
>> (with classes, methods etc.), therefore while the code is not finished
>> you will see a lot of mixed procedural and OO code
>
> I think it's a good idea, because sparse should be flexible.  It should
> be possible to change it for different coding standards.  A python
> implementation would be good, but it would also help if you provide
> detailed comments in the code.

Will do. But as I said, I just started coding it three days ago, so
consider the code in very bad shape right now. If I had decided to
publish the code only later, for sure it would be better commented,
but then I'd lose early comments as yours (which, specially for the
license issue, is very important).

BTW some comments are being purposedly ommited from the python code
because it fits better as a description above the function definition
and not on the calls. E.g.:

	// Tokenize the input stream
	token = tokenize(filename, fd, NULL, includepath);

But I'd like to first get more familiar with the sparse code and then
start adding detailed comments to the function definitions.

Thanks for the comments. Regards,
-- 
Anderson Lizardo
ÿôèº{.nÇ+·®­+%Ëÿ±éÝ¶¥wÿº{.nÇ+·¥{±þÊZ®Çÿ{ayºÊÚë,j­¢f£¢·hïêÿêçz_è®(­éÝ¢j"ú¶m§ÿÿ¾«þG«éÿ¢¸?¨è­Ú&£ø§~á

================================================================================


################################################################################

=== Thread: unable to open limits.h ===

From: "Alexey Zaytsev" <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: unable to open limits.h
Date: Tue, 25 Nov 2008 12:18:58 +0000
Message-ID: <f19298770811250418p154bad86qf926c464d16aef02 () mail ! gmail ! com>
--------------------
On Tue, Nov 25, 2008 at 14:07, Christoph Hellwig <hch@infradead.org> wrote:
> On Ubuntu 8.10 (glibc 2.8.90) I get the following warnings when
> compiling any program using limits.h:
>
> /usr/include/limits.h:125:17: error: unable to open 'limits.h'

This is probably fixed by
http://git.zaytsev.su/git?p=sparse.git;a=commitdiff;h=6f089b22a222dd086d14c985c5a67f8b3afd2177

Josh, please pull the gsoc2008-up branch from git://zaytsev.su/git/sparse.git
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: unable to open limits.h
Date: Tue, 25 Nov 2008 12:27:32 +0000
Message-ID: <20081125122732.GA2035 () uranus ! ravnborg ! org>
--------------------
On Tue, Nov 25, 2008 at 03:18:58PM +0300, Alexey Zaytsev wrote:
> On Tue, Nov 25, 2008 at 14:07, Christoph Hellwig <hch@infradead.org> wrote:
> > On Ubuntu 8.10 (glibc 2.8.90) I get the following warnings when
> > compiling any program using limits.h:
> >
> > /usr/include/limits.h:125:17: error: unable to open 'limits.h'
> 
> This is probably fixed by
> http://git.zaytsev.su/git?p=sparse.git;a=commitdiff;h=6f089b22a222dd086d14c985c5a67f8b3afd2177

Is this the right fix?
We should not rely on that sparse is built with the same gcc as currently installed.

The fix should be that we automagically uses the right path which
is available on the system.

> 
> Josh, please pull the gsoc2008-up branch from git://zaytsev.su/git/sparse.git
For a pull request itis prefarable that you always include:
- diffstat
- shortlog
- short intor what is contained

I assume patches has been on sparse ml.


	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-sparse
Subject: Re: unable to open limits.h
Date: Tue, 25 Nov 2008 12:36:22 +0000
Message-ID: <20081125123622.GA20420 () infradead ! org>
--------------------
On Tue, Nov 25, 2008 at 03:18:58PM +0300, Alexey Zaytsev wrote:
> On Tue, Nov 25, 2008 at 14:07, Christoph Hellwig <hch@infradead.org> wrote:
> > On Ubuntu 8.10 (glibc 2.8.90) I get the following warnings when
> > compiling any program using limits.h:
> >
> > /usr/include/limits.h:125:17: error: unable to open 'limits.h'
> 
> This is probably fixed by
> http://git.zaytsev.su/git?p=sparse.git;a=commitdiff;h=6f089b22a222dd086d14c985c5a67f8b3afd2177
> 
> Josh, please pull the gsoc2008-up branch from git://zaytsev.su/git/sparse.git

I still see the error with a sparse built from your repository.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-sparse
Subject: Re: unable to open limits.h
Date: Tue, 25 Nov 2008 12:37:43 +0000
Message-ID: <20081125123743.GA21584 () infradead ! org>
--------------------
On Tue, Nov 25, 2008 at 07:36:22AM -0500, Christoph Hellwig wrote:
> On Tue, Nov 25, 2008 at 03:18:58PM +0300, Alexey Zaytsev wrote:
> > On Tue, Nov 25, 2008 at 14:07, Christoph Hellwig <hch@infradead.org> wrote:
> > > On Ubuntu 8.10 (glibc 2.8.90) I get the following warnings when
> > > compiling any program using limits.h:
> > >
> > > /usr/include/limits.h:125:17: error: unable to open 'limits.h'
> > 
> > This is probably fixed by
> > http://git.zaytsev.su/git?p=sparse.git;a=commitdiff;h=6f089b22a222dd086d14c985c5a67f8b3afd2177
> > 
> > Josh, please pull the gsoc2008-up branch from git://zaytsev.su/git/sparse.git
> 
> I still see the error with a sparse built from your repository.

Oh, looks like your have the change in some bloody branch.  Care to send
a patch or publish a proper repository?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

