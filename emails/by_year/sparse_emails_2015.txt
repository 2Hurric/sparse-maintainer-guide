--- Emails for Year 2015 ---

=== Thread: [No Subject] ===

From: <>
To: linux-sparse
Subject: 
Date: Sat, 05 Sep 2015 18:58:41 +0000
Message-ID: <KL1PR04MB1125ADB4D0F3BA203562F5E0B8560 () KL1PR04MB1125 ! apcprd04 ! prod ! outlook ! com>
--------------------
 We offer both personal and business loan to any interested 

individual or company who will be able to pay back the loan when 

due for repayment. should Fill and return the application 

details below to my e-mail at ( montageglobalpvtltd@gmail.com ).

APPLICATION DETAILS

1) FULL NAMES:
2) CONTACT ADDRESS:
3) COUNTRY:
4) PHONE NUMBER:
5) SEX:
6) AGE:
7) AMOUNT NEEDED AS LOAN:
8) LOAN DURATION:
9) OCCUPATION:
10)MONTHLY INCOME:
11)PURPOSE OF LOAN:


Warm regard.
William Allen.
Phone: +91-7838915074
(Chairman, Montage Global Pvt Ltd.)

© 2015 Montage Global Pvt Ltd.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bad interaction between macro expansion and literal concatenation ===

From: Rasmus Villemoes <linux () rasmusvillemoes ! dk>
To: linux-sparse
Subject: Bad interaction between macro expansion and literal concatenation
Date: Fri, 30 Jan 2015 22:16:40 +0000
Message-ID: <87y4ojhq2f.fsf () rasmusvillemoes ! dk>
--------------------
Hi,

I'm trying to write a type checker for the kernel's %p format extensions, but
I've run into a problem with sparse which I can't debug myself.

It seems that something goes wrong when sparse is concatenating literal
strings, one of which was hidden behind a macro. As a random example,
drivers/net/ethernet/realtek/atp.c:471 has this format string:

  KERN_DEBUG "%s: Reset: current Rx mode %d.\n"

KERN_DEBUG ultimately expands to "\001" "7". When I print the
corresponding ->string->data, I get

  ^A6%s7%s: Reset: current Rx mode %d.

(^A is just less' way of showing the \001 byte - that part is
fine). Note the extra "6%s". Needless to say, such random extra content
makes format string verification very hard...

If I replace KERN_DEBUG by its expansion "\001" "7", it works fine. If I
only replace it by its immediate replacement KERN_SOH "7", I see the
same bad behaviour.

Any ideas?

Rasmus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: False positives unlock warning ===

From: Bastien Nocera <hadess () hadess ! net>
To: linux-sparse
Subject: False positives unlock warning
Date: Wed, 14 Jan 2015 13:46:58 +0000
Message-ID: <1421243218.2542.45.camel () hadess ! net>
--------------------
Hey,

The following project (a device driver which should compile with kernel
3.17 and above) throws a few false positives with "make C=1":
core/rtw_recv.c:3406:26: warning: context imbalance in 'recv_indicatepkt_reorder' - unexpected unlock
core/rtw_xmit.c:4300:6: warning: context imbalance in 'xmit_delivery_enabled_frames' - wrong count at exit

The code however doesn't look like it's doing anything problematic.

Any ideas?

Cheers

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: Re: False positives unlock warning
Date: Wed, 14 Jan 2015 14:11:43 +0000
Message-ID: <20150114141143.GH5571 () mwanda>
--------------------
On Wed, Jan 14, 2015 at 02:46:58PM +0100, Bastien Nocera wrote:
> Hey,
> 
> The following project (a device driver which should compile with kernel
> 3.17 and above) throws a few false positives with "make C=1":
> core/rtw_recv.c:3406:26: warning: context imbalance in 'recv_indicatepkt_reorder' - unexpected unlock
> core/rtw_xmit.c:4300:6: warning: context imbalance in 'xmit_delivery_enabled_frames' - wrong count at exit

This could be either of:

	drivers/staging/rtl8723au/core/rtw_recv.c
	drivers/staging/rtl8188eu/core/rtw_recv.c

Neither one of these give me that warning.  I'm using the latest Sparse
from git and today's linux-next.  Can you give us some more hints what
you're talking about?

regards,
dan carpenter

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: Re: False positives unlock warning
Date: Wed, 14 Jan 2015 16:41:27 +0000
Message-ID: <20150114164127.GD5520 () mwanda>
--------------------
Sparse gets confused because of the unused "_success_exit:" label.  If
you delete that it should go away.  In "real" kernel code GCC will warn
about unused labels.

I created a more minimal test case while I was looking at this, if
anyone is interested.

static int foo;

int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
{
        struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
        struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
        _queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;

        spin_lock(&ppending_recvframe_queue->lock);
        if (foo)
                goto err;
        spin_unlock(&ppending_recvframe_queue->lock);

unused_label:
        return 0;
err:
        spin_unlock(&ppending_recvframe_queue->lock);
        return -1;
}

regards,
dan carpenter
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bastien Nocera <hadess () hadess ! net>
To: linux-sparse
Subject: Re: False positives unlock warning
Date: Wed, 14 Jan 2015 17:42:40 +0000
Message-ID: <1421257360.2075.1.camel () hadess ! net>
--------------------
On Wed, 2015-01-14 at 19:41 +0300, Dan Carpenter wrote:
> Sparse gets confused because of the unused "_success_exit:" label.  If
> you delete that it should go away.  In "real" kernel code GCC will warn
> about unused labels.

Unfortunately, the problem in core/rtw_xmit.c is the same warning, but
this time the label is used.

Cheers

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: Re: False positives unlock warning
Date: Wed, 14 Jan 2015 20:54:42 +0000
Message-ID: <20150114205442.GA6201 () mwanda>
--------------------
On Wed, Jan 14, 2015 at 06:42:40PM +0100, Bastien Nocera wrote:
> On Wed, 2015-01-14 at 19:41 +0300, Dan Carpenter wrote:
> > Sparse gets confused because of the unused "_success_exit:" label.  If
> > you delete that it should go away.  In "real" kernel code GCC will warn
> > about unused labels.
> 
> Unfortunately, the problem in core/rtw_xmit.c is the same warning, but
> this time the label is used.

The goto has been ifdeffed out.  Try deleting the "exit:" label.  It
still compiles fine for me and the warning is gone.

regards,
dan carpenter

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: From: Mitesh Shah ===

From: "Mitesh Shah" <mpshah () gmail ! com>
To: linux-sparse
Subject: From: Mitesh Shah
Date: Mon, 23 Mar 2015 11:44:14 +0000
Message-ID: <FCDC1DD2-1F47-48FE-E940-D4DE21A83806 () pchome ! com ! tw>
--------------------

Hi Linux



http://indsai.com/told.php?corn=d6kmhbc8mb48v


Mitesh Shah

Sent from my iPhone
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Good Day ===

From: "Ms Golan" <mcortes () municoquimbo ! cl>
To: linux-sparse
Subject: Good Day
Date: Wed, 30 Dec 2015 14:02:51 +0000
Message-ID: <20151231015808.71E964C4A0D7 () tritan ! municoquimbo ! cl>
--------------------
 I am Ms.Golan I am getting in touch with you regarding an extremely important and urgent matter.If you would oblige me the opportunity,shall provide you with details upon your response. 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: PLEASE GET BACK TO ME AS SOON AS YOU RECEIVE THIS EMAIL ===

From: Mkhize Mthembu <mkhizemthembu399 () gmail ! com>
To: linux-sparse
Subject: PLEASE GET BACK TO ME AS SOON AS YOU RECEIVE THIS EMAIL
Date: Fri, 13 Mar 2015 21:44:27 +0000
Message-ID: <1117750665.4285665.1426283067123.JavaMail.yahoo () mail ! yahoo ! com>
--------------------
------=_Part_4285664_637764618.1426283067123
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit



------=_Part_4285664_637764618.1426283067123
Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="Mkhize Mthembu.docx"
Content-ID: <2d45825d-7e6a-7169-93e5-49999e6e3b83@yahoo.com>

UEsDBBQABgAIAAAAIQDd/JU3ZgEAACAFAAATAAgCW0NvbnRlbnRfVHlwZXNdLnhtbCCiBAIooAAC
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC0
VMtuwjAQvFfqP0S+Vomhh6qqCBz6OLZIpR9g7A1Y9Uv28vr7bgJEVQtBKuUSKVnvzOzsxIPR2pps
CTFp70rWL3osAye90m5Wso/JS37PsoTCKWG8g5JtILHR8PpqMNkESBl1u1SyOWJ44DzJOViRCh/A
UaXy0Qqk1zjjQchPMQN+2+vdcekdgsMcaww2HDxBJRYGs+c1fd4qiWASyx63B2uukokQjJYCSSlf
OvWDJd8xFNTZnElzHdINyWD8IENdOU6w63sja6JWkI1FxFdhSQZf+ai48nJhaYaiG+aATl9VWkLb
X6OF6CWkRJ5bU7QVK7Tb6z+qI+HGQPp/FVvcLnrSOY4+JE57OZsf6s0rUDlZESCihnZ1x0cHRLLs
EsPvkLvGb1KAlHfgzbN/tgcNzEnKin6JiZgaOJvvV/Ja6JMiVjB9v5j738C7hLT5kz7+wYz9dVF3
H0gdb+634RcAAAD//wMAUEsDBBQABgAIAAAAIQAekRq38wAAAE4CAAALAAgCX3JlbHMvLnJlbHMg
ogQCKKAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAjJLbSgNBDIbvBd9hyH032woi0tneSKF3IusDhJnsAXcOzKTavr2jILpQ217m9OfLT9ab
g5vUO6c8Bq9hWdWg2JtgR99reG23iwdQWchbmoJnDUfOsGlub9YvPJGUoTyMMaui4rOGQSQ+ImYz
sKNchci+VLqQHEkJU4+RzBv1jKu6vsf0VwOamabaWQ1pZ+9AtcdYNl/WDl03Gn4KZu/Yy4kVyAdh
b9kuYipsScZyjWop9SwabDDPJZ2RYqwKNuBpotX1RP9fi46FLAmhCYnP83x1nANaXg902aJ5x687
HyFZLBZ9e/tDg7MvaD4BAAD//wMAUEsDBBQABgAIAAAAIQDWZLNR+gAAADEDAAAcAAgBd29yZC9f
cmVscy9kb2N1bWVudC54bWwucmVscyCiBAEooAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
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
cy54bWxQSwUGAAAAAAsACwDBAgAAzy8AAAAA

------=_Part_4285664_637764618.1426283067123--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Why sparse does not support context tracking? ===

From: Alexander Riesen <alexander.riesen () cetitec ! com>
To: linux-sparse
Subject: Why sparse does not support context tracking?
Date: Mon, 04 May 2015 11:05:22 +0000
Message-ID: <55475272.90705 () cetitec ! com>
--------------------
Hi,

I tried to instrument my code (a kernel driver) with __must_hold hints
and noticed that they don't really work: a definitely broken code caused
no errors from sparse.

A test in the "sparse" tree confirmed. Here is the test I used:

static int ctx;

static void must_hold(void) __attribute__((context(ctx,1,1)))
{
     if (ctx)
         ;
}
static void bad_must_hold(void)
{
     must_hold();
}

After a bit of looking I found a commit which removed context tracking
from the "sparse":

Author: Johannes Berg <johannes@sipsolutions.net> 2008-12-23 10:59:22

     Revert the context tracking code

     > Do you want to resend your change which revert the context changes?
     > Make it base on Josh's git's tree and I will merge your changes in my
     > branch.

     Below. Or I can give it to you in git if you prefer. I still think we
     should redo this in some form so that annotations with different
     contexts can work properly, but I don't have time to take care of it
     right now.

     johannes

     >From ca95b62edf1600a2b55ed9ca0515d049807a84fc Mon Sep 17 00:00:00 2001
     From: Johannes Berg <johannes@sipsolutions.net>
     Date: Tue, 23 Dec 2008 10:53:19 +0100
     Subject: [PATCH] Revert context tracking code

So it seems that the code has problems with different contexts. Still, it seems
a bit heavy-handed to remove it completely (assuming it worked, of course).
The kernel even has a bit of use for it (not much, admittedly: DRBD and aoe).

Is it be possible to reintroduce the code at least for the same context?
So that it catches at least some locks not taken?

Regards,
Alex Riesen


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Re: Why sparse does not support context tracking?
Date: Mon, 04 May 2015 13:38:57 +0000
Message-ID: <1430746737.2013.22.camel () sipsolutions ! net>
--------------------
On Mon, 2015-05-04 at 13:05 +0200, Alexander Riesen wrote:
> Hi,
> 
> I tried to instrument my code (a kernel driver) with __must_hold hints
> and noticed that they don't really work: a definitely broken code caused
> no errors from sparse.

>      Revert the context tracking code

> So it seems that the code has problems with different contexts. Still, it seems
> a bit heavy-handed to remove it completely (assuming it worked, of course).

It didn't really work. It had a lot of issues that were too big for my
little wireless-focused brain :)

johannes

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Why sparse does not support context tracking?
Date: Mon, 04 May 2015 13:38:57 +0000
Message-ID: <1430746737.2013.22.camel () sipsolutions ! net>
--------------------
On Mon, 2015-05-04 at 13:05 +0200, Alexander Riesen wrote:
> Hi,
> 
> I tried to instrument my code (a kernel driver) with __must_hold hints
> and noticed that they don't really work: a definitely broken code caused
> no errors from sparse.

>      Revert the context tracking code

> So it seems that the code has problems with different contexts. Still, it seems
> a bit heavy-handed to remove it completely (assuming it worked, of course).

It didn't really work. It had a lot of issues that were too big for my
little wireless-focused brain :)

johannes

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexander Riesen <alexander.riesen () cetitec ! com>
To: linux-sparse
Subject: Re: Why sparse does not support context tracking?
Date: Mon, 04 May 2015 14:05:59 +0000
Message-ID: <55477CC7.4020807 () cetitec ! com>
--------------------
On 05/04/2015 03:38 PM, Johannes Berg wrote:
> On Mon, 2015-05-04 at 13:05  +0200, Alexander Riesen wrote:
 >>
 >>      Revert the context tracking code
 >>
 >> So it seems that the code has problems with different contexts. Still, it seems
 >> a bit heavy-handed to remove it completely (assuming it worked, of course).
 >
 > It didn't really work. It had a lot of issues that were too big for my
 > little wireless-focused brain :)

Ah, pity. Wasn't there any hope for it?


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] sparse-llvm: avoid SIGSEGV for function prototypes ===

From: Azat Khuzhin <a3at.mail () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] sparse-llvm: avoid SIGSEGV for function prototypes
Date: Sat, 16 May 2015 22:32:23 +0000
Message-ID: <1431815545-21250-1-git-send-email-a3at.mail () gmail ! com>
--------------------
Description is in the first patch, and the second patch contains regression.

Thanks!

Azat Khuzhin (2):
  sparse, llvm: compile: skip function prototypes to avoid SIGSEGV
  validation/prototype: regression for skipping prototypes

 sparse-llvm.c          | 11 +++++++++++
 validation/prototype.c |  6 ++++++
 2 files changed, 17 insertions(+)
 create mode 100644 validation/prototype.c

-- 
2.1.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] Minor enhancements and fixes ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 0/3] Minor enhancements and fixes
Date: Mon, 03 Aug 2015 18:10:31 +0000
Message-ID: <55BFAE97.8010204 () redhat ! com>
--------------------
On 07/29/2015 08:26 PM, Tony Camuso wrote:
> [PATCH 1/3] .gitignore: add cscope and Qt project files
> Useful if you're using cscope and Qt as an IDE
>
> [PATCH 2/3] c2xml.c, parse.c: gcc 5+ stricter case statement parsing
> The gcc 5.1.1 compiler complains if any of the possible values for the
> switch variable are not covered by the case statement. Basically, it
> forces the employment of the default case.
>
> [PATCH 3/3] Add NOWARN and NOERR compile conditions
> Provides compile conditionals to buid sparse without reporting
> warnings and errors. This isn't quite reducing it to a tokenizer, but
> it has the same effect for our application. Reports from the semantic
> parser and the time they take are undesirable in our application.
>
>   .gitignore |  7 +++++++
>   c2xml.c    |  2 +-
>   lib.c      | 21 +++++++++++++++++++++
>   parse.c    | 13 +++++++++++++
>   4 files changed, 42 insertions(+), 1 deletion(-)
>

Want to update this prologue to detail the differences in the versions
of the patches in this set.

[PATCH 1/3 v2] .gitignore: add cscope and Qt project files
Inadvertently contained local cruft that I didn't really want in the
.gitignore. The sparse maintainers may want to ignore this patch, as
it's not really a big deal.

[PATCH 2/2 v2] Handle all enum members in case statements
Best practice would specify each of the switch variable's enum values
separately, rather than to lump the unhandled ones into a default.

[PATCH 3/3 v4] Add Wall_off switch to disable errors and warnings
The original version of this patch used compile-time constants.

V2 was a first attempt at using a run-time switch to do the same,
but it wasn't tested properly and did not work as expected.

V3 had the run-time Wall_off switch tested at too high a level, which
required it to be placed in more places than necessary.

V4 puts the Wall_off switch at the lowest level and works as expected.

  .gitignore |  4 ++++
  c2xml.c    | 16 ++++++++++++++++
  lib.c      | 27 +++++++++++++++++++++++----
  lib.h      |  1 +
  parse.c    | 15 +++++++++++++++
  5 files changed, 59 insertions(+), 4 deletions(-)

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 0/3] Minor enhancements and fixes
Date: Wed, 02 Dec 2015 18:52:30 +0000
Message-ID: <565F3DEE.7060506 () redhat ! com>
--------------------
On 07/29/2015 08:26 PM, Tony Camuso wrote:
> [PATCH 1/3] .gitignore: add cscope and Qt project files
> Useful if you're using cscope and Qt as an IDE
>
> [PATCH 2/3] c2xml.c, parse.c: gcc 5+ stricter case statement parsing
> The gcc 5.1.1 compiler complains if any of the possible values for the
> switch variable are not covered by the case statement. Basically, it
> forces the employment of the default case.
>
> [PATCH 3/3] Add NOWARN and NOERR compile conditions
> Provides compile conditionals to buid sparse without reporting
> warnings and errors. This isn't quite reducing it to a tokenizer, but
> it has the same effect for our application. Reports from the semantic
> parser and the time they take are undesirable in our application.
>
>   .gitignore |  7 +++++++
>   c2xml.c    |  2 +-
>   lib.c      | 21 +++++++++++++++++++++
>   parse.c    | 13 +++++++++++++
>   4 files changed, 42 insertions(+), 1 deletion(-)
>

Any chance of this patchset being committed to sparse?

Regards,
Tony


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/4] Teach sparse to display data/initial values ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/4] Teach sparse to display data/initial values
Date: Sun, 01 Feb 2015 02:19:42 +0000
Message-ID: <1422757186-8007-1-git-send-email-luc.vanoostenryck () gmail ! com>
--------------------
The patches in this serie implement the display of toplevel variable's initializer.
It should allow to easily investigate the bug reported here: http://article.gmane.org/gmane.comp.parsers.sparse/4080
but can be usefull for others things.

For convenience, this patch series can also be found at git://github.com/looxix/sparse.git show-data


Luc Van Oostenryck (4):
 Add support for '-vdata', the equivalent of '-ventry' but for data
 Add support for show_data()
 Teach sparse to display data/initial values
 Small test/exemple for using '-vdata'

 lib.c                  |  2 ++
 lib.h                  |  1 +
 linearize.c            | 86 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 linearize.h            |  1 +
 sparse.c               |  3 +++
 validation/show_data.c | 75 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 168 insertions(+)

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] compiler/gcc5: Remove comments related to GCC 4.x branch. ===

From: mliska <mliska@suse.cz>
To: Unknown
Subject: [PATCH 1/2] compiler/gcc5: Remove comments related to GCC 4.x branch.
Date: Wed, 15 Apr 2015 10:55:14 +0200
Message-ID: 
--------------------
Signed-off-by: Martin Liska  <mliska@suse.cz>
---
 include/linux/compiler-gcc5.h | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/include/linux/compiler-gcc5.h b/include/linux/compiler-gcc5.h
index efee493..abb03b8 100644
--- a/include/linux/compiler-gcc5.h
+++ b/include/linux/compiler-gcc5.h
@@ -12,10 +12,6 @@
    like BUG(), printk(), panic() etc. [but let's keep them for now for
    older compilers]
 
-   Early snapshots of gcc 4.3 don't support this and we can't detect this
-   in the preprocessor, but we can live with this because they're unreleased.
-   Maketime probing would be overkill here.
-
    gcc also has a __attribute__((__hot__)) to move hot functions into
    a special section, but I don't see any sense in this right now in
    the kernel context */
@@ -32,10 +28,6 @@
  * Mark a position in code as unreachable.  This can be used to
  * suppress control flow warnings after asm blocks that transfer
  * control elsewhere.
- *
- * Early snapshots of gcc 4.5 don't support this and we can't detect
- * this in the preprocessor, but we can live with this because they're
- * unreleased.  Really, we need to have autoconf for the kernel.
  */
 #define unreachable() __builtin_unreachable()
 
-- 
2.1.4


--------------000902010403090201080709--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] compiler/gcc5: Remove quirk for asm_volatile_goto() ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] compiler/gcc5: Remove quirk for asm_volatile_goto()
Date: Tue, 14 Apr 2015 17:58:52 +0000
Message-ID: <CA+55aFzcyHJfP95EDZxOL7iCXg3HL42XqnMFoHFOSMhyGaKtMg () mail ! gmail ! com>
--------------------
On Tue, Apr 14, 2015 at 2:25 AM, Martin LiÅ¡ka <mliska@suse.cz> wrote:
> Remove comments related to GCC 4.x branch and workaround for
> asm_volatile_goto which is fixed in GCC 5 release.

How sure are you that it is *really* fixed? Because it wasn't, last we saw.

It was originally claimed to be fixed in 4.8.2, but that turned out to
be wrong. See commit 5631b8fba640 ("compiler/gcc4+: Remove inaccurate
comment about 'asm goto' miscompiles"), and

    https://lkml.org/lkml/2014/2/12/817

which shows that the bugzilla you reference is at the very least
unreliable. Apparently the gcc test-case didn't catch all the
problems.

IOW, just leave the workaround. It has no actual cost, and the gcc bug
wasn't obviously fully fixed. There are apparently very few users of
"asm goto" (probably partly because of the limitations of it,
particularly the "no outputs").

                           Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?B?TWFydGluIExpxaFrYQ==?= <mliska () suse ! cz>
To: linux-sparse
Subject: Re: [PATCH 1/2] compiler/gcc5: Remove quirk for asm_volatile_goto()
Date: Wed, 15 Apr 2015 09:08:43 +0000
Message-ID: <552E2A9B.7030605 () suse ! cz>
--------------------
This is a multi-part message in MIME format.
--------------000902010403090201080709
Content-Type: text/plain; charset=utf-8; format=flowed
Content-Transfer-Encoding: 8bit

On 04/14/2015 07:58 PM, Linus Torvalds wrote:
> On Tue, Apr 14, 2015 at 2:25 AM, Martin LiÅ¡ka <mliska@suse.cz> wrote:
>> Remove comments related to GCC 4.x branch and workaround for
>> asm_volatile_goto which is fixed in GCC 5 release.
>
> How sure are you that it is *really* fixed? Because it wasn't, last we saw.
>
> It was originally claimed to be fixed in 4.8.2, but that turned out to
> be wrong. See commit 5631b8fba640 ("compiler/gcc4+: Remove inaccurate
> comment about 'asm goto' miscompiles"), and
>
>      https://lkml.org/lkml/2014/2/12/817
>
> which shows that the bugzilla you reference is at the very least
> unreliable. Apparently the gcc test-case didn't catch all the
> problems.
>
> IOW, just leave the workaround. It has no actual cost, and the gcc bug
> wasn't obviously fully fixed. There are apparently very few users of
> "asm goto" (probably partly because of the limitations of it,
> particularly the "no outputs").
>
>                             Linus
>

Hello Linus.

Agree with you that a bit more defensive approach is reasonable, mainly because
of the actual cost.

Thus, I send updated version of the patch which just removes unrelated GCC 4.x branch
comments.

Thanks,
Martin


--------------000902010403090201080709
Content-Type: text/x-patch;
 name="0001-compiler-gcc5-Remove-comments-related-to-GCC-4.x-bra.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename*0="0001-compiler-gcc5-Remove-comments-related-to-GCC-4.x-bra.pa";
 filename*1="tch"


================================================================================


################################################################################

=== Thread: [PATCH 1/3 v2] .gitignore: add cscope and Qt project files ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 1/3 v2] .gitignore: add cscope and Qt project files
Date: Mon, 03 Aug 2015 17:41:00 +0000
Message-ID: <1438623660-18026-1-git-send-email-tcamuso () redhat ! com>
--------------------
Signed-off-by: Tony Camuso <tcamuso@redhat.com>
---
 .gitignore | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/.gitignore b/.gitignore
index d32d063..1e35eac 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,6 +9,7 @@
 pre-process.h
 sparse.pc
 version.h
+cscope*
 
 # programs
 test-inspect
@@ -40,3 +41,6 @@ series
 # local makefile
 local.mk
 
+# files related to Qt
+*.pro*
+*.pri*
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3 v2] .gitignore: add cscope and Qt project files
Date: Sat, 08 Aug 2015 03:58:21 +0000
Message-ID: <CANeU7Q=_+QH3gxvbkptqMh2uQEoRRoECXeQyR+esAKvS4iAHGw () mail ! gmail ! com>
--------------------
On Mon, Aug 3, 2015 at 1:41 PM, Tony Camuso <tcamuso@redhat.com> wrote:
>
> Signed-off-by: Tony Camuso <tcamuso@redhat.com>
> ---
>  .gitignore | 4 ++++
>  1 file changed, 4 insertions(+)
>
> diff --git a/.gitignore b/.gitignore
> index d32d063..1e35eac 100644
> --- a/.gitignore
> +++ b/.gitignore
> @@ -9,6 +9,7 @@
>  pre-process.h
>  sparse.pc
>  version.h
> +cscope*


Can we be more specific on the cscope files?
e.g. Will cscope.* works for you?

Just in case we can have some C file which starts
with "cscope". We do have "ctags.c" for example.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3 v2] .gitignore: add cscope and Qt project files
Date: Mon, 10 Aug 2015 11:18:30 +0000
Message-ID: <55C88886.9020903 () redhat ! com>
--------------------
On 08/07/2015 11:58 PM, Christopher Li wrote:
> On Mon, Aug 3, 2015 at 1:41 PM, Tony Camuso <tcamuso@redhat.com> wrote:
>>
>> Signed-off-by: Tony Camuso <tcamuso@redhat.com>
>> ---
>>   .gitignore | 4 ++++
>>   1 file changed, 4 insertions(+)
>>
>> diff --git a/.gitignore b/.gitignore
>> index d32d063..1e35eac 100644
>> --- a/.gitignore
>> +++ b/.gitignore
>> @@ -9,6 +9,7 @@
>>   pre-process.h
>>   sparse.pc
>>   version.h
>> +cscope*
>
>
> Can we be more specific on the cscope files?
> e.g. Will cscope.* works for you?
>
> Just in case we can have some C file which starts
> with "cscope". We do have "ctags.c" for example.
>
> Chris
>

Yes, very good point. You also have scope.c and scope.h

cscope.out is the generated file, so I will correct this patch
for that.

Regards,
Tony

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] .gitignore: add cscope and Qt project files ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 1/3] .gitignore: add cscope and Qt project files
Date: Thu, 30 Jul 2015 00:26:39 +0000
Message-ID: <1438216001-8862-2-git-send-email-tcamuso () redhat ! com>
--------------------
Signed-off-by: Tony Camuso <tcamuso@redhat.com>
---
 .gitignore | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/.gitignore b/.gitignore
index d32d063..e1734a9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,6 +9,7 @@
 pre-process.h
 sparse.pc
 version.h
+cscope*
 
 # programs
 test-inspect
@@ -40,3 +41,9 @@ series
 # local makefile
 local.mk
 
+# files related to Qt
+*.pro*
+*.pri*
+*.qt
+*.sparse
+*.save
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] test-suite: add support for tests case involving several input files ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 1/3] test-suite: add support for tests case involving several input files
Date: Fri, 06 Feb 2015 15:02:08 +0000
Message-ID: <CANeU7QnHX_v=0S1jd1TbWq5UmTCsoKibwO=A64_JdEV54QZXRg () mail ! gmail ! com>
--------------------
On Tue, Feb 3, 2015 at 6:46 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> These input files, instead of being stored in real files and thus polluting/confusing
> the test framework are now placed in a serie of sections inside an unique test file.
> These sections are delimited by new tags: input-file-1-start / input-file-1-end, / input-file-2-start/ ...

Sorry for the late review. Can I summarize the polluting/confusing problem as:
If there is more than one C file was used in one test case, and test suit wll
invoke each of the C file as a separate test case, not  a good thing.

I think merging it into one test file then split them by the test suit
is too complicated.
It is actually easier to maintain them as separate files.

I think the simpler way would be just teach the test suit, some file
was mean to be
part of a separate test case. Just don't invoke it as stand alone test.
We can add some rules like, embed a tag or simply reflect that in the file name.

It will be a smaller change to the test suit as well.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/4] Add support for '-vdata', the equivalent of '-ventry' but for data ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/4] Add support for '-vdata', the equivalent of '-ventry' but for data
Date: Sun, 01 Feb 2015 02:19:43 +0000
Message-ID: <1422757186-8007-2-git-send-email-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c | 2 ++
 lib.h | 1 +
 2 files changed, 3 insertions(+)

diff --git a/lib.c b/lib.c
index 8dc5bcf9..73714109 100644
--- a/lib.c
+++ b/lib.c
@@ -243,6 +243,7 @@ int Wuninitialized = 1;
 int Wvla = 1;
 
 int dbg_entry = 0;
+int dbg_data = 0;
 int dbg_dead = 0;
 
 int preprocess_only;
@@ -517,6 +518,7 @@ static char **handle_switch_W(char *arg, char **next)
 
 static struct warning debugs[] = {
 	{ "entry", &dbg_entry},
+	{ "data", &dbg_data},
 	{ "dead", &dbg_dead},
 };
 
diff --git a/lib.h b/lib.h
index 15b69fa2..2e1170b4 100644
--- a/lib.h
+++ b/lib.h
@@ -129,6 +129,7 @@ extern int Wuninitialized;
 extern int Wvla;
 
 extern int dbg_entry;
+extern int dbg_data;
 extern int dbg_dead;
 
 extern int arch_m64;
-- 
2.2.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] compiler/gcc6: add support for GCC 6 ===

From: =?windows-1252?Q?Martin_Li=9Aka?= <mliska () suse ! cz>
To: linux-sparse
Subject: [PATCH 2/2] compiler/gcc6: add support for GCC 6
Date: Tue, 14 Apr 2015 09:25:09 +0000
Message-ID: <552CDCF5.9000206 () suse ! cz>
--------------------
Because GCC trunk version has switched to GCC 6.x, new header file
is needed.

Signed-off-by: Martin Liska  <mliska@suse.cz>
---
  include/linux/compiler-gcc6.h | 55 +++++++++++++++++++++++++++++++++++++++++++
  1 file changed, 55 insertions(+)
  create mode 100644 include/linux/compiler-gcc6.h

diff --git a/include/linux/compiler-gcc6.h b/include/linux/compiler-gcc6.h
new file mode 100644
index 0000000..208767a
--- /dev/null
+++ b/include/linux/compiler-gcc6.h
@@ -0,0 +1,55 @@
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc6.h> directly, include <linux/compiler.h> instead."
+#endif
+
+#define __used				__attribute__((__used__))
+#define __must_check			__attribute__((warn_unused_result))
+#define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+
+/* Mark functions as cold. gcc will assume any path leading to a call
+   to them will be unlikely.  This means a lot of manual unlikely()s
+   are unnecessary now for any paths leading to the usual suspects
+   like BUG(), printk(), panic() etc. [but let's keep them for now for
+   older compilers]
+
+   gcc also has a __attribute__((__hot__)) to move hot functions into
+   a special section, but I don't see any sense in this right now in
+   the kernel context */
+#define __cold			__attribute__((__cold__))
+
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+
+/*
+ * Mark a position in code as unreachable.  This can be used to
+ * suppress control flow warnings after asm blocks that transfer
+ * control elsewhere.
+ */
+#define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__))
+
+/*
+ * Tell the optimizer that something else uses this function or variable.
+ */
+#define __visible __attribute__((externally_visible))
+
+/*
+ * 'asm goto' miscompilation is fixed in GCC 5.x version:
+ *
+ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+ */
+#define asm_volatile_goto(x...)	do { asm goto(x); } while (0)
+
+#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+#define __HAVE_BUILTIN_BSWAP32__
+#define __HAVE_BUILTIN_BSWAP64__
+#define __HAVE_BUILTIN_BSWAP16__
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
+
+#define KASAN_ABI_VERSION 4
-- 
2.1.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] validation/prototype: regression for skipping prototypes ===

From: Azat Khuzhin <a3at.mail () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] validation/prototype: regression for skipping prototypes
Date: Sun, 17 May 2015 18:53:54 +0000
Message-ID: <20150517185354.GN11068 () azat>
--------------------
On Sun, May 17, 2015 at 08:40:05PM +0200, Jonathan Neuschäfer wrote:
> > Subject: [PATCH 2/2] validation/prototype: regression for skipping prototypes
> 
> This is not a regression, but a regression test.

Yep, it is a regression test, thanks!
By some reason, I though that "validation" prefix will be enough.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3 v2] Handle all enum members in case statements ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/3 v2] Handle all enum members in case statements
Date: Tue, 04 Aug 2015 23:31:04 +0000
Message-ID: <CANeU7Qk7Xvs6RQuzDxq-9BrqCg-6VXnDUxmgwkREpWVX4Y2ynQ () mail ! gmail ! com>
--------------------
On Tue, Aug 4, 2015 at 8:06 AM, Tony Camuso <tcamuso@redhat.com> wrote:
> Missing enum members in case statements in c2xml.c and parse.c were
> causing compile time complaints by gcc 5.1.1. Better to explicitly
> handle all enum members of the switch variable in case statements,
> even if they just break.
>                 break;
> +       case SYM_PREPROCESSOR:
> +       case SYM_BASETYPE:
> +       case SYM_NODE:
> +       case SYM_PTR:
> +       case SYM_ARRAY:
> +       case SYM_ENUM:
> +       case SYM_TYPEDEF:
> +       case SYM_TYPEOF:
> +       case SYM_MEMBER:
> +       case SYM_BITFIELD:
> +       case SYM_LABEL:
> +       case SYM_RESTRICT:
> +       case SYM_FOULED:
> +       case SYM_KEYWORD:
> +       case SYM_BAD:
> +               break;

I think adding a "default: break" should work. I like your previous patch
better, except maybe adding a line break after default.


>                         case SYM_ENUM:
>                         case SYM_RESTRICT:
>                                 base_type->ident = ident;
> +                       case SYM_PREPROCESSOR:
> +                       case SYM_BASETYPE:

I notice this has the follow through behavior. It is not a bug.
But if some one append some new case there, it is easy to
cause unintended follow through. It is better add a break there.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 2/3 v2] Handle all enum members in case statements
Date: Tue, 04 Aug 2015 23:52:14 +0000
Message-ID: <55C1502E.5050609 () redhat ! com>
--------------------

On 08/04/2015 07:31 PM, Christopher Li wrote:
> On Tue, Aug 4, 2015 at 8:06 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>> Missing enum members in case statements in c2xml.c and parse.c were
>> causing compile time complaints by gcc 5.1.1. Better to explicitly
>> handle all enum members of the switch variable in case statements,
>> even if they just break.
>>                  break;
>> +       case SYM_PREPROCESSOR:
>> +       case SYM_BASETYPE:
>> +       case SYM_NODE:
>> +       case SYM_PTR:
>> +       case SYM_ARRAY:
>> +       case SYM_ENUM:
>> +       case SYM_TYPEDEF:
>> +       case SYM_TYPEOF:
>> +       case SYM_MEMBER:
>> +       case SYM_BITFIELD:
>> +       case SYM_LABEL:
>> +       case SYM_RESTRICT:
>> +       case SYM_FOULED:
>> +       case SYM_KEYWORD:
>> +       case SYM_BAD:
>> +               break;
>
> I think adding a "default: break" should work. I like your previous patch
> better, except maybe adding a line break after default.
>

It was mentioned to me that the new prevailing wisdom is to "Prefer
compile time errors to runtime errors", such that each enum'd value
of a switch variable should be explicitly handled.

I seem to have violated the spirit of that paradigm by using fall through.

I could add a new line and "break" statement after each case.

Or, if you prefer, I can resubmit the original patch with a linefeed after
the "default:" for good form. Either way, I believe the compiler optimize
them the same.

>
>>                          case SYM_ENUM:
>>                          case SYM_RESTRICT:
>>                                  base_type->ident = ident;
>> +                       case SYM_PREPROCESSOR:
>> +                       case SYM_BASETYPE:
>
> I notice this has the follow through behavior. It is not a bug.
> But if some one append some new case there, it is easy to
> cause unintended follow through. It is better add a break there.

It may not be a bug today, but without an explicit break for each,
it's a potential bug.

The whole reason for explicitly listing the existing enum members is so
that new cases for which "break" may not be the correct solution can be
easily identified at compile time.

Tony


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3 v3] Add default case to switches on enum variables ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 2/3 v3] Add default case to switches on enum variables
Date: Mon, 10 Aug 2015 12:35:32 +0000
Message-ID: <1439210132-19384-1-git-send-email-tcamuso () redhat ! com>
--------------------
Missing enum members in case statements in c2xml.c and parse.c were
causing compile time complaints by gcc 5.1.1. Adding a default case
satisfies the compiler and notifies the reviewer that there are
cases not explicitly mentioned being handled by the default case.

Signed-off-by: Tony Camuso <tcamuso@redhat.com>

---
 c2xml.c | 3 ++-
 parse.c | 2 ++
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/c2xml.c b/c2xml.c
index 67486c7..c45d581 100644
--- a/c2xml.c
+++ b/c2xml.c
@@ -214,6 +214,8 @@ static void examine_symbol(struct symbol *sym, xmlNodePtr node)
 	case SYM_UNINITIALIZED:
 		newProp(child, "base-type-builtin", builtin_typename(sym));
 		break;
+	default:
+		break;
 	}
 	return;
 }
@@ -330,4 +332,3 @@ int main(int argc, char **argv)
 
 	return 0;
 }
-
diff --git a/parse.c b/parse.c
index b43d683..39308da 100644
--- a/parse.c
+++ b/parse.c
@@ -2769,6 +2769,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			case SYM_ENUM:
 			case SYM_RESTRICT:
 				base_type->ident = ident;
+			default:
+				break;
 			}
 		}
 	} else if (base_type && base_type->type == SYM_FN) {
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] c2xml.c, parse.c: gcc 5+ stricter case statement parsing ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 2/3] c2xml.c, parse.c: gcc 5+ stricter case statement parsing
Date: Thu, 30 Jul 2015 00:26:40 +0000
Message-ID: <1438216001-8862-3-git-send-email-tcamuso () redhat ! com>
--------------------
The gcc 5+ compiler complains if case statements do not use all the
possible values of the switch variable. Just forces the coder to use
"default" in their case statements.

Signed-off-by: Tony Camuso <tcamuso@redhat.com>
---
 c2xml.c | 2 +-
 parse.c | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/c2xml.c b/c2xml.c
index 67486c7..96657d5 100644
--- a/c2xml.c
+++ b/c2xml.c
@@ -214,6 +214,7 @@ static void examine_symbol(struct symbol *sym, xmlNodePtr node)
 	case SYM_UNINITIALIZED:
 		newProp(child, "base-type-builtin", builtin_typename(sym));
 		break;
+	default: break;
 	}
 	return;
 }
@@ -330,4 +331,3 @@ int main(int argc, char **argv)
 
 	return 0;
 }
-
diff --git a/parse.c b/parse.c
index b43d683..02275d8 100644
--- a/parse.c
+++ b/parse.c
@@ -2769,6 +2769,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			case SYM_ENUM:
 			case SYM_RESTRICT:
 				base_type->ident = ident;
+			default: break;
 			}
 		}
 	} else if (base_type && base_type->type == SYM_FN) {
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/4] Add support for show_data() ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/4] Add support for show_data()
Date: Mon, 02 Feb 2015 05:30:44 +0000
Message-ID: <CANeU7Qkp-6KbTFgxe1Rvrpud66dB+J+-2XpjVDCwqkNDg4H37Q () mail ! gmail ! com>
--------------------
On Sat, Jan 31, 2015 at 6:19 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The purpose of show_data() is to visualize data, more or less

I think show_data() is a bad name. Data is very generic term,
it has not specific meaning what exactly is that data.

What you really want to show is the initializer expression.
Make the function name reflect that.

> diff --git a/linearize.c b/linearize.c

Why is this function belongs to linearize.c?
It has nothing to do with linearization instruction. It has
every thing to do with the AST structure.

I suggest that move this code to show-parse.c.
There are many functions showing internal of the AST
there.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/4] Add support for show_data()
Date: Wed, 04 Feb 2015 00:50:25 +0000
Message-ID: <20150204005025.GB8867 () macbook ! lan>
--------------------
On Sun, Feb 01, 2015 at 09:30:44PM -0800, Christopher Li wrote:
> On Sat, Jan 31, 2015 at 6:19 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > The purpose of show_data() is to visualize data, more or less
> 
> I think show_data() is a bad name. Data is very generic term,
> it has not specific meaning what exactly is that data.
> 
> What you really want to show is the initializer expression.
> Make the function name reflect that.

Yes, the name is too generic. The purpose was to use 'data'
in opposition to 'code'.
 
> > diff --git a/linearize.c b/linearize.c
> 
> Why is this function belongs to linearize.c?
> It has nothing to do with linearization instruction. It has
> every thing to do with the AST structure.
> 
> I suggest that move this code to show-parse.c.
> There are many functions showing internal of the AST
> there.

Well, I put it in linearize because it's where show_entry() is defined
and since I wanted this new show function be its complement, it seemed
to me much better to put it there than in show-parse.c
Even more so because I'm not interested in showing anything close to the AST,
on the contrary, I want to show the values like you would find them in
an assembler code file generated by a compiler after constant folding,
string expansion, type coercion, ...

Anyway, my intention was not to have it included as is (mainly because it's
not complete) but only as a quick tool to investigate the bug that Rasmus have reported.
I'll try to complete it and resubmit it then, taking your remarks in account.


Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3 V2] lib.c: add Wall_off switch ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 3/3 V2] lib.c: add Wall_off switch
Date: Fri, 31 Jul 2015 17:12:14 +0000
Message-ID: <1438362734-14505-1-git-send-email-tcamuso () redhat ! com>
--------------------
Disables all warning and error reporting for using sparse as a
tokenizer only.

Signed-off-by: Tony Camuso <tcamuso@redhat.com>
---
 lib.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/lib.c b/lib.c
index 8dc5bcf..c274a68 100644
--- a/lib.c
+++ b/lib.c
@@ -241,6 +241,7 @@ int Wtypesign = 0;
 int Wundef = 0;
 int Wuninitialized = 1;
 int Wvla = 1;
+int Wall_off = 0;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
@@ -464,6 +465,7 @@ static const struct warning {
 	{ "undef", &Wundef },
 	{ "uninitialized", &Wuninitialized },
 	{ "vla", &Wvla },
+	{ "all_off", &Wall_off },
 };
 
 enum {
@@ -479,6 +481,12 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
 	char *p = arg + 1;
 	unsigned i;
 
+	if (!strcmp(p, "all_off")) {
+		for (i = 0; i < n; i++)
+			*warnings[i].flag = WARNING_FORCE_OFF;
+		return NULL;
+	}
+
 	if (!strcmp(p, "sparse-all")) {
 		for (i = 0; i < n; i++) {
 			if (*warnings[i].flag != WARNING_FORCE_OFF && warnings[i].flag != &Wsparse_error)
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3 V2] lib.c: add Wall_off switch
Date: Fri, 31 Jul 2015 18:01:43 +0000
Message-ID: <55BBB807.2040807 () redhat ! com>
--------------------
On 07/31/2015 01:12 PM, Tony Camuso wrote:
> Disables all warning and error reporting for using sparse as a
> tokenizer only.
>
> Signed-off-by: Tony Camuso <tcamuso@redhat.com>

Spoke too soon ..

NAK

I'll send an update when I have something that really works.

> ---
>   lib.c | 8 ++++++++
>   1 file changed, 8 insertions(+)
>
> diff --git a/lib.c b/lib.c
> index 8dc5bcf..c274a68 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -241,6 +241,7 @@ int Wtypesign = 0;
>   int Wundef = 0;
>   int Wuninitialized = 1;
>   int Wvla = 1;
> +int Wall_off = 0;
>
>   int dbg_entry = 0;
>   int dbg_dead = 0;
> @@ -464,6 +465,7 @@ static const struct warning {
>   	{ "undef", &Wundef },
>   	{ "uninitialized", &Wuninitialized },
>   	{ "vla", &Wvla },
> +	{ "all_off", &Wall_off },
>   };
>
>   enum {
> @@ -479,6 +481,12 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
>   	char *p = arg + 1;
>   	unsigned i;
>
> +	if (!strcmp(p, "all_off")) {
> +		for (i = 0; i < n; i++)
> +			*warnings[i].flag = WARNING_FORCE_OFF;
> +		return NULL;
> +	}
> +
>   	if (!strcmp(p, "sparse-all")) {
>   		for (i = 0; i < n; i++) {
>   			if (*warnings[i].flag != WARNING_FORCE_OFF && warnings[i].flag != &Wsparse_error)
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3 V3] Add Wall_off switch to disable errors and warnings ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 3/3 V3] Add Wall_off switch to disable errors and warnings
Date: Fri, 31 Jul 2015 19:27:59 +0000
Message-ID: <1438370879-21792-1-git-send-email-tcamuso () redhat ! com>
--------------------
For using sparse as a tokenizer only. While it still parses semantics,
it doesn't report any semantic errors, which is undesirable for some
tasks like locating the KABI associations in a kernel source file.

Signed-off-by: Tony Camuso <tcamuso@redhat.com>
---
 lib.c   | 20 +++++++++++++++++++-
 lib.h   |  1 +
 parse.c |  4 ++++
 3 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/lib.c b/lib.c
index 8dc5bcf..ef182ae 100644
--- a/lib.c
+++ b/lib.c
@@ -103,6 +103,9 @@ unsigned int hexval(unsigned int c)
 
 static void do_warn(const char *type, struct position pos, const char * fmt, va_list args)
 {
+	if (Wall_off)
+		return;
+
 	static char buffer[512];
 	const char *name;
 
@@ -120,7 +123,7 @@ void info(struct position pos, const char * fmt, ...)
 {
 	va_list args;
 
-	if (!show_info)
+	if (!show_info || Wall_off)
 		return;
 	va_start(args, fmt);
 	do_warn("", pos, fmt, args);
@@ -129,6 +132,9 @@ void info(struct position pos, const char * fmt, ...)
 
 static void do_error(struct position pos, const char * fmt, va_list args)
 {
+	if (Wall_off)
+		return;
+
 	static int errors = 0;
         die_if_error = 1;
 	show_info = 1;
@@ -151,6 +157,9 @@ void warning(struct position pos, const char * fmt, ...)
 {
 	va_list args;
 
+	if (Wall_off)
+		return;
+
 	if (Wsparse_error) {
 		va_start(args, fmt);
 		do_error(pos, fmt, args);
@@ -241,6 +250,7 @@ int Wtypesign = 0;
 int Wundef = 0;
 int Wuninitialized = 1;
 int Wvla = 1;
+int Wall_off = 0;
 
 int dbg_entry = 0;
 int dbg_dead = 0;
@@ -464,6 +474,7 @@ static const struct warning {
 	{ "undef", &Wundef },
 	{ "uninitialized", &Wuninitialized },
 	{ "vla", &Wvla },
+	{ "all_off", &Wall_off },
 };
 
 enum {
@@ -479,6 +490,13 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
 	char *p = arg + 1;
 	unsigned i;
 
+	if (!strcmp(p, "all_off")) {
+		for (i = 0; i < n; i++)
+			*warnings[i].flag = WARNING_FORCE_OFF;
+		Wall_off = 1;
+		return NULL;
+	}
+
 	if (!strcmp(p, "sparse-all")) {
 		for (i = 0; i < n; i++) {
 			if (*warnings[i].flag != WARNING_FORCE_OFF && warnings[i].flag != &Wsparse_error)
diff --git a/lib.h b/lib.h
index 15b69fa..65e4836 100644
--- a/lib.h
+++ b/lib.h
@@ -127,6 +127,7 @@ extern int Wtypesign;
 extern int Wundef;
 extern int Wuninitialized;
 extern int Wvla;
+extern int Wall_off;
 
 extern int dbg_entry;
 extern int dbg_dead;
diff --git a/parse.c b/parse.c
index 02275d8..d70dffb 100644
--- a/parse.c
+++ b/parse.c
@@ -2746,6 +2746,10 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 
 	/* Just a type declaration? */
 	if (!ident) {
+
+		if (Wall_off)
+			return token->next;
+
 		warning(token->pos, "missing identifier in declaration");
 		return expect(token, ';', "at the end of type declaration");
 	}
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3 V3] Add Wall_off switch to disable errors and warnings
Date: Sat, 01 Aug 2015 13:52:48 +0000
Message-ID: <55BCCF30.3040409 () redhat ! com>
--------------------
On 08/01/2015 08:59 AM, Sam Ravnborg wrote:
>> diff --git a/parse.c b/parse.c
>> index 02275d8..d70dffb 100644
>> --- a/parse.c
>> +++ b/parse.c
>> @@ -2746,6 +2746,10 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>>
>>   	/* Just a type declaration? */
>>   	if (!ident) {
>> +
>> +		if (Wall_off)
>> +			return token->next;
>> +
>>   		warning(token->pos, "missing identifier in declaration");
>>   		return expect(token, ';', "at the end of type declaration");
>
> This is on the wrong level.
> You need to silence sparse in the spare_error function.
>
> Not on the level where you do the expect() - otherwise you would
> have to sprinkle "if (Wall_off)" checks everywhere.
>
> This was also a problem in v1 of the patch.
>
> 	Sam
>

Thanks, Sam. Rework in progress ...

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] Add NOWARN and NOERR compile conditions ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Thu, 30 Jul 2015 00:26:41 +0000
Message-ID: <1438216001-8862-4-git-send-email-tcamuso () redhat ! com>
--------------------
Allows building sparse to avert reporting semantic problems, e.g.
using sparse as a tokenizer to create a graph of KABI symbols and
their dependencies.

Signed-off-by: Tony Camuso <tcamuso@redhat.com>
---
 lib.c   | 21 +++++++++++++++++++++
 parse.c | 12 ++++++++++++
 2 files changed, 33 insertions(+)

diff --git a/lib.c b/lib.c
index 8dc5bcf..cb10bce 100644
--- a/lib.c
+++ b/lib.c
@@ -48,6 +48,13 @@
 int verbose, optimize, optimize_size, preprocessing;
 int die_if_error = 0;
 
+#ifdef NOWARN
+#pragma message "Built with NOWARN"
+#endif
+#ifdef NOERR
+#pragma message "Built with NOERR"
+#endif
+
 #ifndef __GNUC__
 # define __GNUC__ 2
 # define __GNUC_MINOR__ 95
@@ -103,6 +110,9 @@ unsigned int hexval(unsigned int c)
 
 static void do_warn(const char *type, struct position pos, const char * fmt, va_list args)
 {
+#ifdef NOWARN
+	return;
+#else
 	static char buffer[512];
 	const char *name;
 
@@ -111,9 +121,12 @@ static void do_warn(const char *type, struct position pos, const char * fmt, va_
 		
 	fprintf(stderr, "%s:%d:%d: %s%s\n",
 		name, pos.line, pos.pos, type, buffer);
+#endif
 }
 
+#ifndef NOWARN
 static int max_warnings = 100;
+#endif
 static int show_info = 1;
 
 void info(struct position pos, const char * fmt, ...)
@@ -129,6 +142,9 @@ void info(struct position pos, const char * fmt, ...)
 
 static void do_error(struct position pos, const char * fmt, va_list args)
 {
+#ifdef NOERR
+	return;
+#else
 	static int errors = 0;
         die_if_error = 1;
 	show_info = 1;
@@ -145,10 +161,14 @@ static void do_error(struct position pos, const char * fmt, va_list args)
 
 	do_warn("error: ", pos, fmt, args);
 	errors++;
+#endif
 }	
 
 void warning(struct position pos, const char * fmt, ...)
 {
+#ifdef NOWARN
+	return;
+#else
 	va_list args;
 
 	if (Wsparse_error) {
@@ -171,6 +191,7 @@ void warning(struct position pos, const char * fmt, ...)
 	va_start(args, fmt);
 	do_warn("warning: ", pos, fmt, args);
 	va_end(args);
+#endif
 }
 
 void sparse_error(struct position pos, const char * fmt, ...)
diff --git a/parse.c b/parse.c
index 02275d8..f773fe8 100644
--- a/parse.c
+++ b/parse.c
@@ -44,6 +44,13 @@
 #include "expression.h"
 #include "target.h"
 
+#ifdef NOWARN
+#pragma message "Built with NOWARN"
+#endif
+#ifdef NOERR
+#pragma message "Built with NOERR"
+#endif
+
 static struct symbol_list **function_symbol_list;
 struct symbol_list *function_computed_target_list;
 struct statement_list *function_computed_goto_list;
@@ -2746,8 +2753,13 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 
 	/* Just a type declaration? */
 	if (!ident) {
+
+#if defined NOWARN || defined NOERR
+		return token->next;
+#else
 		warning(token->pos, "missing identifier in declaration");
 		return expect(token, ';', "at the end of type declaration");
+#endif
 	}
 
 	/* type define declaration? */
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Thu, 30 Jul 2015 02:55:02 +0000
Message-ID: <20150730025502.GA1692 () x>
--------------------
On Wed, Jul 29, 2015 at 08:26:41PM -0400, Tony Camuso wrote:
> Allows building sparse to avert reporting semantic problems, e.g.
> using sparse as a tokenizer to create a graph of KABI symbols and
> their dependencies.
> 
> Signed-off-by: Tony Camuso <tcamuso@redhat.com>

This doesn't seem like something that should be determined at compile
time.  Ideally, this should be determined at runtime.

>  lib.c   | 21 +++++++++++++++++++++
>  parse.c | 12 ++++++++++++
>  2 files changed, 33 insertions(+)
> 
> diff --git a/lib.c b/lib.c
> index 8dc5bcf..cb10bce 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -48,6 +48,13 @@
>  int verbose, optimize, optimize_size, preprocessing;
>  int die_if_error = 0;
>  
> +#ifdef NOWARN
> +#pragma message "Built with NOWARN"
> +#endif
> +#ifdef NOERR
> +#pragma message "Built with NOERR"
> +#endif
> +
>  #ifndef __GNUC__
>  # define __GNUC__ 2
>  # define __GNUC_MINOR__ 95
> @@ -103,6 +110,9 @@ unsigned int hexval(unsigned int c)
>  
>  static void do_warn(const char *type, struct position pos, const char * fmt, va_list args)
>  {
> +#ifdef NOWARN
> +	return;
> +#else
>  	static char buffer[512];
>  	const char *name;
>  
> @@ -111,9 +121,12 @@ static void do_warn(const char *type, struct position pos, const char * fmt, va_
>  		
>  	fprintf(stderr, "%s:%d:%d: %s%s\n",
>  		name, pos.line, pos.pos, type, buffer);
> +#endif
>  }
>  
> +#ifndef NOWARN
>  static int max_warnings = 100;
> +#endif
>  static int show_info = 1;
>  
>  void info(struct position pos, const char * fmt, ...)
> @@ -129,6 +142,9 @@ void info(struct position pos, const char * fmt, ...)
>  
>  static void do_error(struct position pos, const char * fmt, va_list args)
>  {
> +#ifdef NOERR
> +	return;
> +#else
>  	static int errors = 0;
>          die_if_error = 1;
>  	show_info = 1;
> @@ -145,10 +161,14 @@ static void do_error(struct position pos, const char * fmt, va_list args)
>  
>  	do_warn("error: ", pos, fmt, args);
>  	errors++;
> +#endif
>  }	
>  
>  void warning(struct position pos, const char * fmt, ...)
>  {
> +#ifdef NOWARN
> +	return;
> +#else
>  	va_list args;
>  
>  	if (Wsparse_error) {
> @@ -171,6 +191,7 @@ void warning(struct position pos, const char * fmt, ...)
>  	va_start(args, fmt);
>  	do_warn("warning: ", pos, fmt, args);
>  	va_end(args);
> +#endif
>  }
>  
>  void sparse_error(struct position pos, const char * fmt, ...)
> diff --git a/parse.c b/parse.c
> index 02275d8..f773fe8 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -44,6 +44,13 @@
>  #include "expression.h"
>  #include "target.h"
>  
> +#ifdef NOWARN
> +#pragma message "Built with NOWARN"
> +#endif
> +#ifdef NOERR
> +#pragma message "Built with NOERR"
> +#endif
> +
>  static struct symbol_list **function_symbol_list;
>  struct symbol_list *function_computed_target_list;
>  struct statement_list *function_computed_goto_list;
> @@ -2746,8 +2753,13 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>  
>  	/* Just a type declaration? */
>  	if (!ident) {
> +
> +#if defined NOWARN || defined NOERR
> +		return token->next;
> +#else
>  		warning(token->pos, "missing identifier in declaration");
>  		return expect(token, ';', "at the end of type declaration");
> +#endif
>  	}
>  
>  	/* type define declaration? */
> -- 
> 2.4.3
> 
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Fri, 31 Jul 2015 17:07:43 +0000
Message-ID: <55BBAB5F.3070005 () redhat ! com>
--------------------
On 07/29/2015 10:55 PM, Josh Triplett wrote:
> On Wed, Jul 29, 2015 at 08:26:41PM -0400, Tony Camuso wrote:
>> Allows building sparse to avert reporting semantic problems, e.g.
>> using sparse as a tokenizer to create a graph of KABI symbols and
>> their dependencies.
>>
>> Signed-off-by: Tony Camuso <tcamuso@redhat.com>
>
> This doesn't seem like something that should be determined at compile
> time.  Ideally, this should be determined at runtime.
>

I will be sending the new patch as a reply to the original, though the
subject line is different, because I'm using the input switches instead
of build-time constants.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Fri, 31 Jul 2015 23:46:25 +0000
Message-ID: <CANeU7Qm=nv85N6MWZ=Lo=OLWEmyEOOk84AHbBwFAgfUfhBonbg () mail ! gmail ! com>
--------------------
On Thu, Jul 30, 2015 at 4:45 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>
> I thought it would be less intrusive, since I don't know how useful
> this would be to others.
>
> If you prefer a switch, I will do that.

I agree that this should be run time behavior.

+
+#if defined NOWARN || defined NOERR
+               return token->next;
+#else

What is up with this change? It is not output warning or not.
It affect the parsing as well. If sparse can't bail out properly,
this should be a separate patch.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Fri, 31 Jul 2015 23:46:25 +0000
Message-ID: <CANeU7Qm=nv85N6MWZ=Lo=OLWEmyEOOk84AHbBwFAgfUfhBonbg () mail ! gmail ! com>
--------------------
On Thu, Jul 30, 2015 at 4:45 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>
> I thought it would be less intrusive, since I don't know how useful
> this would be to others.
>
> If you prefer a switch, I will do that.

I agree that this should be run time behavior.

+
+#if defined NOWARN || defined NOERR
+               return token->next;
+#else

What is up with this change? It is not output warning or not.
It affect the parsing as well. If sparse can't bail out properly,
this should be a separate patch.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Sat, 01 Aug 2015 11:09:06 +0000
Message-ID: <55BCA8D2.1040808 () redhat ! com>
--------------------
On 07/31/2015 07:46 PM, Christopher Li wrote:
> On Thu, Jul 30, 2015 at 4:45 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>>
>> I thought it would be less intrusive, since I don't know how useful
>> this would be to others.
>>
>> If you prefer a switch, I will do that.
>
> I agree that this should be run time behavior.
>
> +
> +#if defined NOWARN || defined NOERR
> +               return token->next;
> +#else
>
> What is up with this change? It is not output warning or not.
> It affect the parsing as well. If sparse can't bail out properly,
> this should be a separate patch.
>
> Chris
>

Hi, Chris.

I've since submitted a runtime patch (3/3 V3) with a switch as a
response to this patch, but it basically does the same thing here.

Consider the case where the source contains something like this...

	struct foo {
		union {
			int number;
			int *pointer;
		};
	};

There being no ident for the union within the struct, we get the warning,
"missing identifier in declaration" etc.

Code without the patch.

	/* Just a type declaration? */
	if (!ident) {
		warning(token->pos, "missing identifier in declaration");
		return expect(token, ';', "at the end of type declaration");
	}
  
Regards,
Tony

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Sat, 01 Aug 2015 17:52:17 +0000
Message-ID: <20150801175217.GA7250 () x>
--------------------
On Sat, Aug 01, 2015 at 07:09:06AM -0400, Tony Camuso wrote:
> On 07/31/2015 07:46 PM, Christopher Li wrote:
> >On Thu, Jul 30, 2015 at 4:45 AM, Tony Camuso <tcamuso@redhat.com> wrote:
> >>
> >>I thought it would be less intrusive, since I don't know how useful
> >>this would be to others.
> >>
> >>If you prefer a switch, I will do that.
> >
> >I agree that this should be run time behavior.
> >
> >+
> >+#if defined NOWARN || defined NOERR
> >+               return token->next;
> >+#else
> >
> >What is up with this change? It is not output warning or not.
> >It affect the parsing as well. If sparse can't bail out properly,
> >this should be a separate patch.
> >
> >Chris
> >
> 
> Hi, Chris.
> 
> I've since submitted a runtime patch (3/3 V3) with a switch as a
> response to this patch, but it basically does the same thing here.
> 
> Consider the case where the source contains something like this...
> 
> 	struct foo {
> 		union {
> 			int number;
> 			int *pointer;
> 		};
> 	};
> 
> There being no ident for the union within the struct, we get the warning,
> "missing identifier in declaration" etc.

If so, that's actually a bug in Sparse; anonymous unions should be
allowed without warning:

$ cat test.c
struct foo {
    union {
        int number;
        int *pointer;
    };
};
$ gcc -Wall -Wextra -c test.c -o /dev/null
$

They have a well-defined semantic meaning, and they're standardized in
C11, just not in C89 or C99.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Sat, 01 Aug 2015 18:45:38 +0000
Message-ID: <CANeU7QkK5N8Jskcq9J1ODCeZEQYSAJTW-6PdKg1uuZeNXPYKTA () mail ! gmail ! com>
--------------------
On Sat, Aug 1, 2015 at 4:09 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>
> I've since submitted a runtime patch (3/3 V3) with a switch as a
> response to this patch, but it basically does the same thing here.
>
> Consider the case where the source contains something like this...
>
>         struct foo {
>                 union {
>                         int number;
>                         int *pointer;
>                 };
>         };
>
> There being no ident for the union within the struct, we get the warning,
> "missing identifier in declaration" etc.
>

I can't reproduce the warning with the chrisl repo master branch.

That being said, if there is indeed a bug in sparse, it should be a
separate patch. It changes the parsing behavior.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Sun, 02 Aug 2015 23:16:54 +0000
Message-ID: <55BEA4E6.50702 () redhat ! com>
--------------------
On 08/01/2015 02:45 PM, Christopher Li wrote:
> On Sat, Aug 1, 2015 at 4:09 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>>
>> I've since submitted a runtime patch (3/3 V3) with a switch as a
>> response to this patch, but it basically does the same thing here.
>>
>> Consider the case where the source contains something like this...
>>
>>          struct foo {
>>                  union {
>>                          int number;
>>                          int *pointer;
>>                  };
>>          };
>>
>> There being no ident for the union within the struct, we get the warning,
>> "missing identifier in declaration" etc.
>>
>
> I can't reproduce the warning with the chrisl repo master branch.
>
> That being said, if there is indeed a bug in sparse, it should be a
> separate patch. It changes the parsing behavior.
>
> Thanks
>
> Chris
>

This doubt this is a sparse bug. It is an most likely caused by some RHEL
specific macros with encapsulated anonymous unions devised to protect the
Kernel Application Binary Interface while backporting upstream changes
from point release to point release. I can try to convince the KABI macro
maintainers to make their macros sparse-compliant, but I'm hoping you agree
that it might not be a bad idea to provide an option to disable the sparse
error reporting in the meantime.

If you're interested in pursuing this further, these are the errors I'm
seeing, followed by the source that generates them.

/work/linux/fs/bio.i:9137:130: error: Expected ) in function declarator
/work/linux/fs/bio.i:9137:130: error: got (
builtin:0:0: error: expected ; at end of declaration
builtin:0:0: error: expected ; at end of declaration
builtin:0:0: error: expected ; at end of declaration
/work/linux/fs/bio.i:9137:172: error: Expected ; at the end of type declaration
/work/linux/fs/bio.i:9137:172: error: got }
/work/linux/fs/bio.i:9137:209: error: Expected ; at the end of type declaration
/work/linux/fs/bio.i:9137:209: error: got }
/work/linux/fs/bio.i:9137:266: error: Expected ) in function declarator
/work/linux/fs/bio.i:9137:266: error: got (
/work/linux/fs/bio.i:9137:308: error: Expected ; at the end of type declaration
/work/linux/fs/bio.i:9137:308: error: got }
/work/linux/fs/bio.i:9137:350: error: Expected ; at the end of type declaration
/work/linux/fs/bio.i:9137:350: error: got }
/work/linux/fs/bio.i:9137:382: error: Expected ; at the end of type declaration
/work/linux/fs/bio.i:9137:382: error: got }
/work/linux/fs/bio.i:9137:385: error: Expected ; at the end of type declaration
/work/linux/fs/bio.i:9137:385: error: got }
/work/linux/fs/bio.i:9139:1: error: Expected ; at the end of type declaration
/work/linux/fs/bio.i:9139:1: error: got }

The anonymous unions giving us those error messages are encapsulated
in a RHEL-specific macro.

# define _RH_KABI_REPLACE(_orig, _new)                  \
         union {                                         \
                 _new;                                   \
                 struct {                                \
                         _orig;                          \
                 } __UNIQUE_ID(rh_kabi_hide);            \
                 __RH_KABI_CHECK_SIZE_ALIGN(_orig, _new);        \
         }

Here's an example of the macro invocation.

         RH_KABI_REPLACE(void                    *spin_mlock,  /* Spinner MCS lock */
                         struct optimistic_spin_queue  *osq)   /* Spinner MCS lock */


The preprocessor expands it as follows.

  union { struct optimistic_spin_queue *osq; struct { void *spin_mlock; } __UNIQUE_ID_rh_kabi_hide0; union { _Static_assert(sizeof(struct{struct optimistic_spin_queue *osq;}) <= sizeof(struct{void *   spin_mlock;}), "kabi sizeof test panic"); _Static_assert(__alignof__(struct{struct optimistic_spin_queue *osq;}) <= __alignof__(struct{void *spin_mlock;}), "kabi alignof test panic"); }; };


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Sun, 02 Aug 2015 23:22:18 +0000
Message-ID: <55BEA62A.6070604 () redhat ! com>
--------------------
On 08/01/2015 02:45 PM, Christopher Li wrote:
> On Sat, Aug 1, 2015 at 4:09 AM, Tony Camuso <tcamuso@redhat.com> wrote:
>>
>> I've since submitted a runtime patch (3/3 V3) with a switch as a
>> response to this patch, but it basically does the same thing here.
>>
>> Consider the case where the source contains something like this...
>>
>>          struct foo {
>>                  union {
>>                          int number;
>>                          int *pointer;
>>                  };
>>          };
>>
>> There being no ident for the union within the struct, we get the warning,
>> "missing identifier in declaration" etc.
>>
>
> I can't reproduce the warning with the chrisl repo master branch.
>
> That being said, if there is indeed a bug in sparse, it should be a
> separate patch. It changes the parsing behavior.
>
> Thanks
>
> Chris
>

Here's one that might be a sparse bug.

/work/linux/fs/bio.i:5368:26: error: Expected ) at end of cast operator
/work/linux/fs/bio.i:5368:26: error: got __int128

Here is the kernel source in include/linux/math64.h that causes the error.

static inline __attribute__((no_instrument_function)) u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
{
  return (u64)(((unsigned __int128)a * mul) >> shift);
}

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Mon, 03 Aug 2015 11:23:34 +0000
Message-ID: <87lhdsmx8p.fsf () gmail ! com>
--------------------
Hi Tony,

Tony Camuso <tcamuso@redhat.com> writes:
> Here's one that might be a sparse bug.
>
> /work/linux/fs/bio.i:5368:26: error: Expected ) at end of cast operator
> /work/linux/fs/bio.i:5368:26: error: got __int128
>
> Here is the kernel source in include/linux/math64.h that causes the error.
>
> static inline __attribute__((no_instrument_function)) u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
> {
>  return (u64)(((unsigned __int128)a * mul) >> shift);
> }

This one is probably triggered by running sparse on gcc -E output.

The mul_u64_u32_shr() implementation cited by you is protected by a
  #if ... && defined(__SIZEOF_INT128__)
in include/linux/math64.h

__SIZEOF_INT128__ is #define'd by gcc but not by sparse.


The reason for your parsing error messages is probably that
declaration_specifiers() does not eat up the __int128, leaving this one
to cast_expression().

Could you please confirm that you did indeed run sparse on gcc -E
output?

Thank you,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH 3/3] Add NOWARN and NOERR compile conditions
Date: Mon, 03 Aug 2015 11:47:29 +0000
Message-ID: <55BF54D1.7070907 () redhat ! com>
--------------------
On 08/03/2015 07:23 AM, Nicolai Stange wrote:
> Hi Tony,
>
> Tony Camuso <tcamuso@redhat.com> writes:
>> Here's one that might be a sparse bug.
>>
>> /work/linux/fs/bio.i:5368:26: error: Expected ) at end of cast operator
>> /work/linux/fs/bio.i:5368:26: error: got __int128
>>
>> Here is the kernel source in include/linux/math64.h that causes the error.
>>
>> static inline __attribute__((no_instrument_function)) u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
>> {
>>   return (u64)(((unsigned __int128)a * mul) >> shift);
>> }
>
> This one is probably triggered by running sparse on gcc -E output.
>
> The mul_u64_u32_shr() implementation cited by you is protected by a
>    #if ... && defined(__SIZEOF_INT128__)
> in include/linux/math64.h
>
> __SIZEOF_INT128__ is #define'd by gcc but not by sparse.
>
>
> The reason for your parsing error messages is probably that
> declaration_specifiers() does not eat up the __int128, leaving this one
> to cast_expression().
>
> Could you please confirm that you did indeed run sparse on gcc -E
> output?
>
> Thank you,
>
> Nicolai

Yes, we are using -E to generate preprocessor output.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] test-suite: consolidate tests that require include files into single test files ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] test-suite: consolidate tests that require include files into single test files
Date: Wed, 04 Feb 2015 02:51:04 +0000
Message-ID: <20150204025103.GD7731 () macpro ! local>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/pragma-once.c                 | 13 ++++++++++++-
 validation/preprocessor/counter2.c       | 16 +++++++++++-----
 validation/preprocessor/counter2.h       |  1 -
 validation/preprocessor/preprocessor20.c | 18 +++++++++++++++---
 validation/preprocessor/preprocessor20.h |  6 ------
 5 files changed, 38 insertions(+), 16 deletions(-)
 delete mode 100644 validation/preprocessor/counter2.h
 delete mode 100644 validation/preprocessor/preprocessor20.h

diff --git a/validation/pragma-once.c b/validation/pragma-once.c
index 5e8b8254..83c0f9f9 100644
--- a/validation/pragma-once.c
+++ b/validation/pragma-once.c
@@ -1,5 +1,16 @@
+/* input-file-1-start */
 #pragma once
-#include "pragma-once.c"
+
+struct s {
+	int i;
+};
+/* input-file-1-end */
+
+/* input-file-2-start */
+#include "$file1"
+#include "$file1"
+/* input-file-2-end */
 /*
  * check-name: #pragma once
+ * check-command: sparse $file2
  */
diff --git a/validation/preprocessor/counter2.c b/validation/preprocessor/counter2.c
index 9883b682..fa15d954 100644
--- a/validation/preprocessor/counter2.c
+++ b/validation/preprocessor/counter2.c
@@ -1,14 +1,20 @@
+/* input-file-1-start */
 __FILE__ __COUNTER__
-#include <counter2.h>
+/* input-file-1-end */
+
+/* input-file-2-start */
 __FILE__ __COUNTER__
+#include "$file1"
+__FILE__ __COUNTER__
+/* input-file-2-end */
 /*
  * check-name: __COUNTER__ #2
- * check-command: sparse -Ipreprocessor -E $file
+ * check-command: sparse -E $file2
  *
  * check-output-start
 
-"preprocessor/counter2.c" 0
-"preprocessor/counter2.h" 1
-"preprocessor/counter2.c" 2
+"$file2" 0
+"$file1" 1
+"$file2" 2
  * check-output-end
  */
diff --git a/validation/preprocessor/counter2.h b/validation/preprocessor/counter2.h
deleted file mode 100644
index 447b70ab..00000000
--- a/validation/preprocessor/counter2.h
+++ /dev/null
@@ -1 +0,0 @@
-__FILE__ __COUNTER__
diff --git a/validation/preprocessor/preprocessor20.c b/validation/preprocessor/preprocessor20.c
index 90e93f37..679a9737 100644
--- a/validation/preprocessor/preprocessor20.c
+++ b/validation/preprocessor/preprocessor20.c
@@ -1,10 +1,22 @@
-#include "preprocessor20.h"
+/* input-file-1-start */
+#ifdef X
+B
+#endif
+#ifndef Y
+A
+#endif
+/* input-file-1-end */
+
+/* input-file-2-start */
+#include "$file1"
 #define X
 #define Y
-#include "preprocessor20.h"
+#include "$file1"
+/* input-file-2-end */
+
 /*
  * check-name: Preprocessor #20
- * check-command: sparse -E $file
+ * check-command: sparse -E $file2
  *
  * check-output-start
 
diff --git a/validation/preprocessor/preprocessor20.h b/validation/preprocessor/preprocessor20.h
deleted file mode 100644
index 322c543a..00000000
--- a/validation/preprocessor/preprocessor20.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifdef X
-B
-#endif
-#ifndef Y
-A
-#endif
-- 
2.2.0


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/4] Teach sparse to display data/initial values ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/4] Teach sparse to display data/initial values
Date: Sun, 01 Feb 2015 02:19:45 +0000
Message-ID: <1422757186-8007-4-git-send-email-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 sparse.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/sparse.c b/sparse.c
index 6b3324cf..e87f8c4f 100644
--- a/sparse.c
+++ b/sparse.c
@@ -285,6 +285,9 @@ static void check_symbols(struct symbol_list *list)
 				show_entry(ep);
 
 			check_context(ep);
+		} else {
+			if (dbg_data)
+				show_data(sym);
 		}
 	} END_FOR_EACH_PTR(sym);
 
-- 
2.2.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/4] Small test/exemple for using '-vdata' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/4] Small test/exemple for using '-vdata'
Date: Sun, 01 Feb 2015 02:19:46 +0000
Message-ID: <1422757186-8007-5-git-send-email-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/show_data.c | 75 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 75 insertions(+)
 create mode 100644 validation/show_data.c

diff --git a/validation/show_data.c b/validation/show_data.c
new file mode 100644
index 00000000..b620b610
--- /dev/null
+++ b/validation/show_data.c
@@ -0,0 +1,75 @@
+#define P "\001"
+
+static const char a[] = P "a";
+static const char b[] = P "b";
+
+static const char *c = "abc";
+
+static int i = 42;
+
+static int  *ipi = &i;
+static void *vpi = &i;
+
+struct s {
+	int i;
+};
+static struct s s = {
+	.i = 42,
+};
+
+union u {
+	int i;
+	void *p;
+};
+static union u u = {
+	.i = 42,
+};
+
+enum e {
+	first,
+	next,
+	last
+};
+static enum e e = next;
+/*
+ * check-name: show_data.c
+ * check-command: sparse -m32 -vdata $file
+ * check-output-start:
+symbol a:
+	char static const [toplevel] a[0]
+	bit_size = 24
+	val = "\1a"
+symbol b:
+	char static const [toplevel] b[0]
+	bit_size = 32
+	val = "\1b"
+symbol c:
+	char const *static [toplevel] c
+	bit_size = 32
+	val = &"abc"
+symbol i:
+	int static [signed] [addressable] [toplevel] i
+	bit_size = 32
+	val = 42
+symbol ipi:
+	int *static [toplevel] ipi
+	bit_size = 32
+	val = &i
+symbol vpi:
+	void *static [toplevel] vpi
+	bit_size = 32
+	val = &i
+symbol s:
+	struct s static [toplevel] s
+	bit_size = 32
+	val = {	}
+symbol u:
+	union u static [toplevel] u
+	bit_size = 32
+	val = {	}
+symbol e:
+	int enum e static [signed] [toplevel] e
+	bit_size = 32
+	val = 1
+ * check-output-end
+ */
-- 
2.2.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 00/13] improve constexpr handling ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 00/13] improve constexpr handling
Date: Wed, 22 Jul 2015 22:54:25 +0000
Message-ID: <87y4i7kdlq.fsf () gmail ! com>
--------------------
--=-=-=
Content-Type: text/plain
Content-Disposition: attachment; filename=linux-constexpr-fixes.diff

diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h
index 59915ea..00eb776 100644
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@ -736,7 +736,7 @@ void init_cpu_online(const struct cpumask *src);
  */
 #define to_cpumask(bitmap)						\
 	((struct cpumask *)(1 ? (bitmap)				\
-			    : (void *)sizeof(__check_is_bitmap(bitmap))))
+			    : (void *)0 + sizeof(__check_is_bitmap(bitmap))))
 
 static inline int __check_is_bitmap(const unsigned long *bitmap)
 {
diff --git a/include/linux/log2.h b/include/linux/log2.h
index fd7ff3d..384d6e5 100644
--- a/include/linux/log2.h
+++ b/include/linux/log2.h
@@ -82,80 +82,80 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
  *
  * selects the appropriately-sized optimised version depending on sizeof(n)
  */
-#define ilog2(n)				\
-(						\
-	__builtin_constant_p(n) ? (		\
-		(n) < 1 ? ____ilog2_NaN() :	\
-		(n) & (1ULL << 63) ? 63 :	\
-		(n) & (1ULL << 62) ? 62 :	\
-		(n) & (1ULL << 61) ? 61 :	\
-		(n) & (1ULL << 60) ? 60 :	\
-		(n) & (1ULL << 59) ? 59 :	\
-		(n) & (1ULL << 58) ? 58 :	\
-		(n) & (1ULL << 57) ? 57 :	\
-		(n) & (1ULL << 56) ? 56 :	\
-		(n) & (1ULL << 55) ? 55 :	\
-		(n) & (1ULL << 54) ? 54 :	\
-		(n) & (1ULL << 53) ? 53 :	\
-		(n) & (1ULL << 52) ? 52 :	\
-		(n) & (1ULL << 51) ? 51 :	\
-		(n) & (1ULL << 50) ? 50 :	\
-		(n) & (1ULL << 49) ? 49 :	\
-		(n) & (1ULL << 48) ? 48 :	\
-		(n) & (1ULL << 47) ? 47 :	\
-		(n) & (1ULL << 46) ? 46 :	\
-		(n) & (1ULL << 45) ? 45 :	\
-		(n) & (1ULL << 44) ? 44 :	\
-		(n) & (1ULL << 43) ? 43 :	\
-		(n) & (1ULL << 42) ? 42 :	\
-		(n) & (1ULL << 41) ? 41 :	\
-		(n) & (1ULL << 40) ? 40 :	\
-		(n) & (1ULL << 39) ? 39 :	\
-		(n) & (1ULL << 38) ? 38 :	\
-		(n) & (1ULL << 37) ? 37 :	\
-		(n) & (1ULL << 36) ? 36 :	\
-		(n) & (1ULL << 35) ? 35 :	\
-		(n) & (1ULL << 34) ? 34 :	\
-		(n) & (1ULL << 33) ? 33 :	\
-		(n) & (1ULL << 32) ? 32 :	\
-		(n) & (1ULL << 31) ? 31 :	\
-		(n) & (1ULL << 30) ? 30 :	\
-		(n) & (1ULL << 29) ? 29 :	\
-		(n) & (1ULL << 28) ? 28 :	\
-		(n) & (1ULL << 27) ? 27 :	\
-		(n) & (1ULL << 26) ? 26 :	\
-		(n) & (1ULL << 25) ? 25 :	\
-		(n) & (1ULL << 24) ? 24 :	\
-		(n) & (1ULL << 23) ? 23 :	\
-		(n) & (1ULL << 22) ? 22 :	\
-		(n) & (1ULL << 21) ? 21 :	\
-		(n) & (1ULL << 20) ? 20 :	\
-		(n) & (1ULL << 19) ? 19 :	\
-		(n) & (1ULL << 18) ? 18 :	\
-		(n) & (1ULL << 17) ? 17 :	\
-		(n) & (1ULL << 16) ? 16 :	\
-		(n) & (1ULL << 15) ? 15 :	\
-		(n) & (1ULL << 14) ? 14 :	\
-		(n) & (1ULL << 13) ? 13 :	\
-		(n) & (1ULL << 12) ? 12 :	\
-		(n) & (1ULL << 11) ? 11 :	\
-		(n) & (1ULL << 10) ? 10 :	\
-		(n) & (1ULL <<  9) ?  9 :	\
-		(n) & (1ULL <<  8) ?  8 :	\
-		(n) & (1ULL <<  7) ?  7 :	\
-		(n) & (1ULL <<  6) ?  6 :	\
-		(n) & (1ULL <<  5) ?  5 :	\
-		(n) & (1ULL <<  4) ?  4 :	\
-		(n) & (1ULL <<  3) ?  3 :	\
-		(n) & (1ULL <<  2) ?  2 :	\
-		(n) & (1ULL <<  1) ?  1 :	\
-		(n) & (1ULL <<  0) ?  0 :	\
-		____ilog2_NaN()			\
-				   ) :		\
-	(sizeof(n) <= 4) ?			\
-	__ilog2_u32(n) :			\
-	__ilog2_u64(n)				\
- )
+#define ilog2(n)							\
+	__builtin_choose_expr(						\
+		__builtin_constant_p(n),				\
+		(							\
+			(n) & (1ULL << 63) ? 63 :			\
+			(n) & (1ULL << 62) ? 62 :			\
+			(n) & (1ULL << 61) ? 61 :			\
+			(n) & (1ULL << 60) ? 60 :			\
+			(n) & (1ULL << 59) ? 59 :			\
+			(n) & (1ULL << 58) ? 58 :			\
+			(n) & (1ULL << 57) ? 57 :			\
+			(n) & (1ULL << 56) ? 56 :			\
+			(n) & (1ULL << 55) ? 55 :			\
+			(n) & (1ULL << 54) ? 54 :			\
+			(n) & (1ULL << 53) ? 53 :			\
+			(n) & (1ULL << 52) ? 52 :			\
+			(n) & (1ULL << 51) ? 51 :			\
+			(n) & (1ULL << 50) ? 50 :			\
+			(n) & (1ULL << 49) ? 49 :			\
+			(n) & (1ULL << 48) ? 48 :			\
+			(n) & (1ULL << 47) ? 47 :			\
+			(n) & (1ULL << 46) ? 46 :			\
+			(n) & (1ULL << 45) ? 45 :			\
+			(n) & (1ULL << 44) ? 44 :			\
+			(n) & (1ULL << 43) ? 43 :			\
+			(n) & (1ULL << 42) ? 42 :			\
+			(n) & (1ULL << 41) ? 41 :			\
+			(n) & (1ULL << 40) ? 40 :			\
+			(n) & (1ULL << 39) ? 39 :			\
+			(n) & (1ULL << 38) ? 38 :			\
+			(n) & (1ULL << 37) ? 37 :			\
+			(n) & (1ULL << 36) ? 36 :			\
+			(n) & (1ULL << 35) ? 35 :			\
+			(n) & (1ULL << 34) ? 34 :			\
+			(n) & (1ULL << 33) ? 33 :			\
+			(n) & (1ULL << 32) ? 32 :			\
+			(n) & (1ULL << 31) ? 31 :			\
+			(n) & (1ULL << 30) ? 30 :			\
+			(n) & (1ULL << 29) ? 29 :			\
+			(n) & (1ULL << 28) ? 28 :			\
+			(n) & (1ULL << 27) ? 27 :			\
+			(n) & (1ULL << 26) ? 26 :			\
+			(n) & (1ULL << 25) ? 25 :			\
+			(n) & (1ULL << 24) ? 24 :			\
+			(n) & (1ULL << 23) ? 23 :			\
+			(n) & (1ULL << 22) ? 22 :			\
+			(n) & (1ULL << 21) ? 21 :			\
+			(n) & (1ULL << 20) ? 20 :			\
+			(n) & (1ULL << 19) ? 19 :			\
+			(n) & (1ULL << 18) ? 18 :			\
+			(n) & (1ULL << 17) ? 17 :			\
+			(n) & (1ULL << 16) ? 16 :			\
+			(n) & (1ULL << 15) ? 15 :			\
+			(n) & (1ULL << 14) ? 14 :			\
+			(n) & (1ULL << 13) ? 13 :			\
+			(n) & (1ULL << 12) ? 12 :			\
+			(n) & (1ULL << 11) ? 11 :			\
+			(n) & (1ULL << 10) ? 10 :			\
+			(n) & (1ULL <<  9) ?  9 :			\
+			(n) & (1ULL <<  8) ?  8 :			\
+			(n) & (1ULL <<  7) ?  7 :			\
+			(n) & (1ULL <<  6) ?  6 :			\
+			(n) & (1ULL <<  5) ?  5 :			\
+			(n) & (1ULL <<  4) ?  4 :			\
+			(n) & (1ULL <<  3) ?  3 :			\
+			(n) & (1ULL <<  2) ?  2 :			\
+			(n) & (1ULL <<  1) ?  1 :			\
+			(n) == 1 ? 0 :					\
+			__builtin_warning(1, "log2 gives NaN") ? 0 : 0	\
+			),						\
+		(sizeof(n) <= 4) ?					\
+		__ilog2_u32(n) :					\
+		__ilog2_u64(n)						\
+		)
 
 /**
  * roundup_pow_of_two - round the given value up to nearest power of two
@@ -165,14 +165,14 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
  * - the result is undefined when n == 0
  * - this can be used to initialise global variables from constant data
  */
-#define roundup_pow_of_two(n)			\
-(						\
-	__builtin_constant_p(n) ? (		\
-		(n == 1) ? 1 :			\
-		(1UL << (ilog2((n) - 1) + 1))	\
-				   ) :		\
-	__roundup_pow_of_two(n)			\
- )
+#define roundup_pow_of_two(n)				\
+	__builtin_choose_expr(				\
+		__builtin_constant_p(n),		\
+		(					\
+			(n == 1) ? 1 :			\
+			(1UL << (ilog2((n) - 1) + 1))	\
+			),				\
+		__roundup_pow_of_two(n))
 
 /**
  * rounddown_pow_of_two - round the given value down to nearest power of two
@@ -182,12 +182,8 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
  * - the result is undefined when n == 0
  * - this can be used to initialise global variables from constant data
  */
-#define rounddown_pow_of_two(n)			\
-(						\
-	__builtin_constant_p(n) ? (		\
-		(1UL << ilog2(n))) :		\
-	__rounddown_pow_of_two(n)		\
- )
+#define rounddown_pow_of_two(n)		\
+	(1UL << ilog2(n))
 
 /**
  * order_base_2 - calculate the (rounded up) base 2 order of the argument
diff --git a/include/uapi/linux/swab.h b/include/uapi/linux/swab.h
index 0e011eb..d44773e 100644
--- a/include/uapi/linux/swab.h
+++ b/include/uapi/linux/swab.h
@@ -102,28 +102,28 @@ static inline __attribute_const__ __u32 __fswahb32(__u32 val)
  * __swab16 - return a byteswapped 16-bit value
  * @x: value to byteswap
  */
-#define __swab16(x)				\
-	(__builtin_constant_p((__u16)(x)) ?	\
-	___constant_swab16(x) :			\
-	__fswab16(x))
+#define __swab16(x)							\
+	__builtin_choose_expr(__builtin_constant_p((__u16)(x)),	\
+			___constant_swab16(x),				\
+			__fswab16(x))
 
 /**
  * __swab32 - return a byteswapped 32-bit value
  * @x: value to byteswap
  */
-#define __swab32(x)				\
-	(__builtin_constant_p((__u32)(x)) ?	\
-	___constant_swab32(x) :			\
-	__fswab32(x))
+#define __swab32(x)							\
+	__builtin_choose_expr(__builtin_constant_p((__u32)(x)),	\
+			___constant_swab32(x),				\
+			__fswab32(x))
 
 /**
  * __swab64 - return a byteswapped 64-bit value
  * @x: value to byteswap
  */
-#define __swab64(x)				\
-	(__builtin_constant_p((__u64)(x)) ?	\
-	___constant_swab64(x) :			\
-	__fswab64(x))
+#define __swab64(x)							\
+	__builtin_choose_expr(__builtin_constant_p((__u64)(x)),	\
+			___constant_swab64(x),				\
+			__fswab64(x))
 
 /**
  * __swahw32 - return a word-swapped 32-bit value

--=-=-=
Content-Type: text/plain

This patch series is split into four parts:
- The first part deals with the refactorization of the current integer
  constant expression handling and introduces some support for
  recognizing arithmetic expressions. [1-5/13]
- The second part introduces support for recognizing address constants.
  [6/13]
- The third part introduces a check for the constness of static storage
  duration objects' initializers. [7/13]
- The last part stems from my tests with the kernel. It contains things
  I missed in the first [9-10/13] and second [8,12/13] parts and
  relaxes some of the constraints on constant expressions [11/13].
  For the last patch [13/13], please see below.

My initial intent was to rework the current integer constant expression
handling in order to allow for the recognition of constant subexpressions
built up by means of __builtin_choose_expr(). Hence the first part.

However, since I had to touch the whole constant expression handling
code anyways, I decided to experimentally extend it to support
arithmetic constant expressions and address constants as well. Hence
the second part.

Since the additional information on expressions obtained through the
first two parts is rather pointless without making any use of it, I
implemented part three, the checking of static storage duration
objects' initializers for constness.
This part is the reason why there is a 'RFC' tag in the subject.
It is up to you to decide whether letting sparse check for C99
conformity is a valuable thing to have or whether being stricter than
GCC is counter-productive/completely idiotic.

Although the patches of the fourth part, the fixup part, fit very well
into the first two categories, their associated testcases, if any,
depend on [7/13]. Thus, I dediced to keep the order as is.

If you decide that you do not want to have the third part, I will
resend a stripped version of the first one only, together with
[9-10/13].


Random notes:

- [1/13] is basically a renaming patch only. It introduces additional
  flags used in later patches. It should not alter any behaviour.

- I am not very confident about [13/13]. It could introduce some
  new issues as well as just fix symptoms, not the problem.
  Please double check when reviewing.

- This series introduces two new testsuite failers, namely
  validation/choose_expr.c and validation/builtin_bswap.c.
  These testcases really violate the constexpr constraints. However,
  for the moment, I left them as is.


Results from running sparse on the kernel:

For testing, I ran sparse without and with this series applied on an
allmodconfig kernel on x86_64.
Beforehand, I fixed commonly used macros, namely log2- and
swab-related ones and to_cpumask() to qualify as constexprs,
if possible. See the attached diff (and blame me for attaching diffs).
Especially log2() needs this fixing anyways since it is used all over
the place where only integer constant expressions are allowed (in array
designators).

sparse now finds 519 occurences of non-const initializers of static
storage duration objects, 474 of which are located in drivers/acpi
and stem from this subsystem's custom offsetof macro implemented by
means of taking pointer differences.

The remaining hits are distributed as follows
14 drivers/net/ethernet/sfc/
13 drivers/isdn/hardware/mISDN/
 8 drivers/usb/core/
 2 drivers/net/wireless/libertas_tf/
 1 drivers/infiniband/hw/qib/
 1 drivers/misc/genwqe/
 1 drivers/net/ethernet/qlogic/qlcnic/
 1 drivers/net/wireless/ath/ath6kl/
 1 drivers/scsi/snic/
 1 drivers/staging/comedi/drivers/
 1 drivers/tty/ipwireless/
 1 net/wireless/

OTOH, 40 errors due to non-integer constant expressions in array
designators formerly spit out by sparse have vanished. This is because
the attached diff on log2() relies on __builtin_warning() getting
recognized as an integer constant, i.e. on [10/13].



Nicolai Stange (13):
  expression: introduce additional expression constness tracking flags
  expression: examine constness of casts at evaluation only
  expression: examine constness of binops and alike at evaluation only
  expression: examine constness of preops at evaluation only
  expression: examine constness of conditionals at evaluation only
  expression, evaluate: add support for recognizing address constants
  evaluate: check static storage duration objects' intializers'
    constness
  expression: recognize references to labels as address constants
  expression: examine constness of __builtin_offsetof at evaluation only
  symbol: flag builtins constant_p, safe_p and warning as constexprs
  evaluate: relax some constant expression rules for pointer expressions
  expression, evaluate: support compound literals as address constants
  symbol: do not inherit storage modifiers from base types at
    examination

 evaluate.c                              | 191 +++++++++++++++++++++++++-------
 expand.c                                |   2 +-
 expression.c                            |  54 +++++----
 expression.h                            | 133 +++++++++++++++++++++-
 symbol.c                                |  12 +-
 validation/constexpr-binop.c            |  33 ++++++
 validation/constexpr-cast.c             |  25 +++++
 validation/constexpr-compound-literal.c |  18 +++
 validation/constexpr-conditional.c      |  34 ++++++
 validation/constexpr-init.c             | 109 ++++++++++++++++++
 validation/constexpr-offsetof.c         |  21 ++++
 validation/constexpr-preop.c            |  29 +++++
 12 files changed, 578 insertions(+), 83 deletions(-)
 create mode 100644 validation/constexpr-binop.c
 create mode 100644 validation/constexpr-cast.c
 create mode 100644 validation/constexpr-compound-literal.c
 create mode 100644 validation/constexpr-conditional.c
 create mode 100644 validation/constexpr-init.c
 create mode 100644 validation/constexpr-offsetof.c
 create mode 100644 validation/constexpr-preop.c

-- 
2.4.5

--=-=-=--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: josh () joshtriplett ! org
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Thu, 23 Jul 2015 00:37:57 +0000
Message-ID: <20150723003757.GA28528 () cloud>
--------------------
[Side note: for some reason, your mail had your message ordered *after*
your attached diff, so replies quote the diff before the message.]

On Thu, Jul 23, 2015 at 12:54:25AM +0200, Nicolai Stange wrote:
> My initial intent was to rework the current integer constant expression
> handling in order to allow for the recognition of constant subexpressions
> built up by means of __builtin_choose_expr(). Hence the first part.
> 
> However, since I had to touch the whole constant expression handling
> code anyways, I decided to experimentally extend it to support
> arithmetic constant expressions and address constants as well. Hence
> the second part.
> 
> Since the additional information on expressions obtained through the
> first two parts is rather pointless without making any use of it, I
> implemented part three, the checking of static storage duration
> objects' initializers for constness.
> This part is the reason why there is a 'RFC' tag in the subject.
> It is up to you to decide whether letting sparse check for C99
> conformity is a valuable thing to have or whether being stricter than
> GCC is counter-productive/completely idiotic.

I think it's absolutely a valuable thing to have.  It may or may not be
the right *default* behavior, but having an appropriate -W option to
enable it would be a good start.

I've seen kernel maintainers ask people to not rely on GCC's lax
enforcement of constant initializers.

> sparse now finds 519 occurences of non-const initializers of static
> storage duration objects, 474 of which are located in drivers/acpi
> and stem from this subsystem's custom offsetof macro implemented by
> means of taking pointer differences.

Ideally, I'd suggest that ACPICA should add a translation from
ACPI_OFFSET to offsetof as part of its Linux-izing scripts.

That said, I also can't think of an obvious reason why ACPI_OFFSET
*should* be considered non-constant.  Perhaps there's a detail in the
C99 spec that explains why what it does isn't OK, but it *seems* like it
should be a compile-time constant expression.  I've CCed Al Viro, who
knows the C99 constant expression rules very well; Al, could you provide
some clarity here?  The ACPI_OFFSET macro in question expands to this:

(acpi_size) (((u8 *) (void *) ((&(((struct some_struct *) 0)->fieldname)))) - ((u8 *) (void *) (((void *) (void *) 0))))

Does the -> make this non-constant?

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Thu, 23 Jul 2015 09:13:57 +0000
Message-ID: <871tfzi6cq.fsf () gmail ! com>
--------------------
josh@joshtriplett.org writes:
> [Side note: for some reason, your mail had your message ordered *after*
> your attached diff, so replies quote the diff before the message.]
Yes, I messed it up for some reason. Sorry for that.

>> Since the additional information on expressions obtained through the
>> first two parts is rather pointless without making any use of it, I
>> implemented part three, the checking of static storage duration
>> objects' initializers for constness.
>> This part is the reason why there is a 'RFC' tag in the subject.
>> It is up to you to decide whether letting sparse check for C99
>> conformity is a valuable thing to have or whether being stricter than
>> GCC is counter-productive/completely idiotic.
>
> I think it's absolutely a valuable thing to have.  It may or may not be
> the right *default* behavior, but having an appropriate -W option to
> enable it would be a good start.

My next resend will contain such a -Wcheck-static-initializers then.
However, I will delay that resend in order to be able to incorporate
other reviews arriving in the meantime.


> On Thu, Jul 23, 2015 at 12:54:25AM +0200, Nicolai Stange wrote:
>> sparse now finds 519 occurences of non-const initializers of static
>> storage duration objects, 474 of which are located in drivers/acpi
>> and stem from this subsystem's custom offsetof macro implemented by
>> means of taking pointer differences.
>
> Ideally, I'd suggest that ACPICA should add a translation from
> ACPI_OFFSET to offsetof as part of its Linux-izing scripts.
>
> That said, I also can't think of an obvious reason why ACPI_OFFSET
> *should* be considered non-constant.  Perhaps there's a detail in the
> C99 spec that explains why what it does isn't OK, but it *seems* like it
> should be a compile-time constant expression.  I've CCed Al Viro, who
> knows the C99 constant expression rules very well; Al, could you provide
> some clarity here?  The ACPI_OFFSET macro in question expands to this:
>
> (acpi_size) (((u8 *) (void *) ((&(((struct some_struct *) 0)->fieldname)))) - ((u8 *) (void *) (((void *) (void *) 0))))
>
> Does the -> make this non-constant?

No, it is the pointer difference. At least to my interpretion of C99
[6.6(9)] which might be arguable.
Upon your request, I could relax these constraints as I have did already for
some special cases of conditionals in [11/13].
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: josh () joshtriplett ! org
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Thu, 23 Jul 2015 18:47:23 +0000
Message-ID: <20150723184723.GA1605 () cloud>
--------------------
On Thu, Jul 23, 2015 at 11:13:57AM +0200, Nicolai Stange wrote:
> josh@joshtriplett.org writes:
> >> Since the additional information on expressions obtained through the
> >> first two parts is rather pointless without making any use of it, I
> >> implemented part three, the checking of static storage duration
> >> objects' initializers for constness.
> >> This part is the reason why there is a 'RFC' tag in the subject.
> >> It is up to you to decide whether letting sparse check for C99
> >> conformity is a valuable thing to have or whether being stricter than
> >> GCC is counter-productive/completely idiotic.
> >
> > I think it's absolutely a valuable thing to have.  It may or may not be
> > the right *default* behavior, but having an appropriate -W option to
> > enable it would be a good start.
> 
> My next resend will contain such a -Wcheck-static-initializers then.

<bikeshed>Shouldn't it be something like -Wnon-constant-initializer,
since that's what it checks for?</bikeshed>

> However, I will delay that resend in order to be able to incorporate
> other reviews arriving in the meantime.

Sounds reasonable.

> > On Thu, Jul 23, 2015 at 12:54:25AM +0200, Nicolai Stange wrote:
> >> sparse now finds 519 occurences of non-const initializers of static
> >> storage duration objects, 474 of which are located in drivers/acpi
> >> and stem from this subsystem's custom offsetof macro implemented by
> >> means of taking pointer differences.
> >
> > Ideally, I'd suggest that ACPICA should add a translation from
> > ACPI_OFFSET to offsetof as part of its Linux-izing scripts.
> >
> > That said, I also can't think of an obvious reason why ACPI_OFFSET
> > *should* be considered non-constant.  Perhaps there's a detail in the
> > C99 spec that explains why what it does isn't OK, but it *seems* like it
> > should be a compile-time constant expression.  I've CCed Al Viro, who
> > knows the C99 constant expression rules very well; Al, could you provide
> > some clarity here?  The ACPI_OFFSET macro in question expands to this:
> >
> > (acpi_size) (((u8 *) (void *) ((&(((struct some_struct *) 0)->fieldname)))) - ((u8 *) (void *) (((void *) (void *) 0))))
> >
> > Does the -> make this non-constant?
> 
> No, it is the pointer difference. At least to my interpretion of C99
> [6.6(9)] which might be arguable.
> Upon your request, I could relax these constraints as I have did already for
> some special cases of conditionals in [11/13].

Ah, I see.  I don't know whether relaxing that makes sense or not; Al?

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Mon, 10 Aug 2015 00:06:45 +0000
Message-ID: <CANeU7Qmx3ttWHzwSprPDZ3YdoVcun9VWLmk2wHfzCf2FyiA5wQ () mail ! gmail ! com>
--------------------
On Wed, Aug 5, 2015 at 3:24 AM, Nicolai Stange <nicstange@gmail.com> wrote:
> Just a friendly ping to get some more reviews to consider in my next
> resend, especially on [13/13] and whether to relax the constant
> expression rules to treat pointer differences of address constants as
> (arithmetic or integer) constant expressions.

Sorry for the late reply. I am working on it. It will take me a bit of time
to think about the change. I like the generate direction you are going.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Mon, 10 Aug 2015 00:06:45 +0000
Message-ID: <CANeU7Qmx3ttWHzwSprPDZ3YdoVcun9VWLmk2wHfzCf2FyiA5wQ () mail ! gmail ! com>
--------------------
On Wed, Aug 5, 2015 at 3:24 AM, Nicolai Stange <nicstange@gmail.com> wrote:
> Just a friendly ping to get some more reviews to consider in my next
> resend, especially on [13/13] and whether to relax the constant
> expression rules to treat pointer differences of address constants as
> (arithmetic or integer) constant expressions.

Sorry for the late reply. I am working on it. It will take me a bit of time
to think about the change. I like the generate direction you are going.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Tue, 29 Dec 2015 08:34:44 +0000
Message-ID: <874mf1r6u3.fsf () gmail ! com>
--------------------
Christopher Li <sparse@chrisli.org> writes:

> On Wed, Aug 5, 2015 at 3:24 AM, Nicolai Stange <nicstange@gmail.com> wrote:
>> Just a friendly ping to get some more reviews to consider in my next
>> resend, especially on [13/13] and whether to relax the constant
>> expression rules to treat pointer differences of address constants as
>> (arithmetic or integer) constant expressions.
>
> Sorry for the late reply. I am working on it. It will take me a bit of time
> to think about the change. I like the generate direction you are going.
>
> Chris

Hi Chris,

do you see any way to get this one going again?

Cheers,

Nicolai
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Sat, 09 Jan 2016 18:25:32 +0000
Message-ID: <20160109182531.GB2718 () macpro ! local>
--------------------
On Wed, Jul 22, 2015 at 05:37:57PM -0700, josh@joshtriplett.org wrote:
> [Side note: for some reason, your mail had your message ordered *after*
> your attached diff, so replies quote the diff before the message.]
> 
> On Thu, Jul 23, 2015 at 12:54:25AM +0200, Nicolai Stange wrote:
> > My initial intent was to rework the current integer constant expression
> > handling in order to allow for the recognition of constant subexpressions
> > built up by means of __builtin_choose_expr(). Hence the first part.
> > 
> > However, since I had to touch the whole constant expression handling
> > code anyways, I decided to experimentally extend it to support
> > arithmetic constant expressions and address constants as well. Hence
> > the second part.
> > 
> > Since the additional information on expressions obtained through the
> > first two parts is rather pointless without making any use of it, I
> > implemented part three, the checking of static storage duration
> > objects' initializers for constness.
> > This part is the reason why there is a 'RFC' tag in the subject.
> > It is up to you to decide whether letting sparse check for C99
> > conformity is a valuable thing to have or whether being stricter than
> > GCC is counter-productive/completely idiotic.
> 
> I think it's absolutely a valuable thing to have.  It may or may not be
> the right *default* behavior, but having an appropriate -W option to
> enable it would be a good start.
> 
> I've seen kernel maintainers ask people to not rely on GCC's lax
> enforcement of constant initializers.

I also think it's a very valuable thing to have.
After all, it's the raison d'etre of sparse to make stricter checks
than the standard or GCC.

But then I wonder what's must be done for things like GCC's builtins?
Shouldn't, for example, __builtin_bswap32(..) always propagte the constantness
of it's argument or it specifically this sort of things that are the target of
this patch serie?


Regards,
Luc,
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Sat, 09 Jan 2016 22:05:21 +0000
Message-ID: <87lh7ywgri.fsf () gmail ! com>
--------------------
Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:

> On Wed, Jul 22, 2015 at 05:37:57PM -0700, josh@joshtriplett.org wrote:
>> [Side note: for some reason, your mail had your message ordered *after*
>> your attached diff, so replies quote the diff before the message.]
>> 
>> On Thu, Jul 23, 2015 at 12:54:25AM +0200, Nicolai Stange wrote:
>> > My initial intent was to rework the current integer constant expression
>> > handling in order to allow for the recognition of constant subexpressions
>> > built up by means of __builtin_choose_expr(). Hence the first part.
>> > 
>> > However, since I had to touch the whole constant expression handling
>> > code anyways, I decided to experimentally extend it to support
>> > arithmetic constant expressions and address constants as well. Hence
>> > the second part.
>> > 
>> > Since the additional information on expressions obtained through the
>> > first two parts is rather pointless without making any use of it, I
>> > implemented part three, the checking of static storage duration
>> > objects' initializers for constness.
>> > This part is the reason why there is a 'RFC' tag in the subject.
>> > It is up to you to decide whether letting sparse check for C99
>> > conformity is a valuable thing to have or whether being stricter than
>> > GCC is counter-productive/completely idiotic.
>> 
>> I think it's absolutely a valuable thing to have.  It may or may not be
>> the right *default* behavior, but having an appropriate -W option to
>> enable it would be a good start.
>> 
>> I've seen kernel maintainers ask people to not rely on GCC's lax
>> enforcement of constant initializers.
>
> I also think it's a very valuable thing to have.
> After all, it's the raison d'etre of sparse to make stricter checks
> than the standard or GCC.

First of all, thank you very much for your review, Luc!

>
> But then I wonder what's must be done for things like GCC's builtins?
> Shouldn't, for example, __builtin_bswap32(..) always propagte the constantness
> of it's argument or it specifically this sort of things that are the target of
> this patch serie?

Hmm. I guess it depends on the particular __builtin_*() thingie at hand.
In general, unless explicitly documented, I personally would neither
assume consistent constness rules nor that those are stable across GCC
releases and architectures.

In the case of __builtin_bswap32(..), the kernel seems to follow that line
of reasoning: for example in include/uapi/linux/swab.h, we have

  #define __swab32(x)                             \
          (__builtin_constant_p((__u32)(x)) ?     \
          ___constant_swab32(x) :                 \
          __fswab32(x))

where __fswap32(..) is essentially just a wrapper around
__builtin_bswap32(..).


But of course, if one decides that some __builtin_foo(<constexpr>) is a
constexpr again, we would have to teach it sparse explicitly. AFAICS,
this is nothing new introduced by this patch series though.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC 00/13] improve constexpr handling
Date: Mon, 11 Jan 2016 17:46:35 +0000
Message-ID: <20160111174634.GB2972 () macpro ! local>
--------------------
On Sat, Jan 09, 2016 at 11:05:21PM +0100, Nicolai Stange wrote:
> Luc Van Oostenryck <luc.vanoostenryck@gmail.com> writes:
> 
> > On Wed, Jul 22, 2015 at 05:37:57PM -0700, josh@joshtriplett.org wrote:
> >> [Side note: for some reason, your mail had your message ordered *after*
> >> your attached diff, so replies quote the diff before the message.]
> >> 
> >> On Thu, Jul 23, 2015 at 12:54:25AM +0200, Nicolai Stange wrote:
> >> > My initial intent was to rework the current integer constant expression
> >> > handling in order to allow for the recognition of constant subexpressions
> >> > built up by means of __builtin_choose_expr(). Hence the first part.
> >> > 
> >> > However, since I had to touch the whole constant expression handling
> >> > code anyways, I decided to experimentally extend it to support
> >> > arithmetic constant expressions and address constants as well. Hence
> >> > the second part.
> >> > 
> >> > Since the additional information on expressions obtained through the
> >> > first two parts is rather pointless without making any use of it, I
> >> > implemented part three, the checking of static storage duration
> >> > objects' initializers for constness.
> >> > This part is the reason why there is a 'RFC' tag in the subject.
> >> > It is up to you to decide whether letting sparse check for C99
> >> > conformity is a valuable thing to have or whether being stricter than
> >> > GCC is counter-productive/completely idiotic.
> >> 
> >> I think it's absolutely a valuable thing to have.  It may or may not be
> >> the right *default* behavior, but having an appropriate -W option to
> >> enable it would be a good start.
> >> 
> >> I've seen kernel maintainers ask people to not rely on GCC's lax
> >> enforcement of constant initializers.
> >
> > I also think it's a very valuable thing to have.
> > After all, it's the raison d'etre of sparse to make stricter checks
> > than the standard or GCC.
> 
> First of all, thank you very much for your review, Luc!

I'm glad to help to make things move on.
 
> >
> > But then I wonder what's must be done for things like GCC's builtins?
> > Shouldn't, for example, __builtin_bswap32(..) always propagte the constantness
> > of it's argument or it specifically this sort of things that are the target of
> > this patch serie?
> 
> Hmm. I guess it depends on the particular __builtin_*() thingie at hand.
> In general, unless explicitly documented, I personally would neither
> assume consistent constness rules nor that those are stable across GCC
> releases and architectures.

Yes, indeed.
 
> In the case of __builtin_bswap32(..), the kernel seems to follow that line
> of reasoning: for example in include/uapi/linux/swab.h, we have
> 
>   #define __swab32(x)                             \
>           (__builtin_constant_p((__u32)(x)) ?     \
>           ___constant_swab32(x) :                 \
>           __fswab32(x))
> 
> where __fswap32(..) is essentially just a wrapper around
> __builtin_bswap32(..).
> 
> 
> But of course, if one decides that some __builtin_foo(<constexpr>) is a
> constexpr again, we would have to teach it sparse explicitly. AFAICS,
> this is nothing new introduced by this patch series though.

Yes, sure. I was wondering if it is wanted or not to do so.


Yours,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 01/13] expression: introduce additional expression constness tracking flags ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 01/13] expression: introduce additional expression constness tracking flags
Date: Wed, 22 Jul 2015 23:11:36 +0000
Message-ID: <87r3nzkct3.fsf () gmail ! com>
--------------------
Prepare for a more fine-grained tracking of expression constness in the
sense of C99 [6.4.4, 6.6].

User-visible behaviour remains unchanged.

The current implementation tags an expression with either combination
of the flags Int_const_expr and Float_literal, the latter being only
used to tell that
  (int).0
is indeed an integer constant expression.

Even if sparse attempted to verify that initializers for static storage
duration objects are constant expressions [6.7.8(4)] (which it
currently does not), it could not tell reliably.
Examples:
1.)
  static float a = { (float)0 }; /* allowed by C99 */
  '(float)0' is not an integer constant expression, but an arithmetic
  one.
2.)
  enum { b = 0 };
  static void *c = { (void*)b }; /* disallowed by C99 */
  References to enum members are not allowed in address constants
  [6.6(9)] and thus, the initializer is not a constant expression at
  all.

Introduce a broader set of constness tracking flags, resembling the
four types of constants [6.4.4] (integer, floating, enumeration,
character) and the three types of constant expressions [6.6] (integer,
arithmetic, address). Use helper functions to consistently set and
clear these flags as they are not completely independent.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c   |  69 ++++++++++++++++++-------------
 expand.c     |   2 +-
 expression.c |  66 ++++++++++++++++++-----------
 expression.h | 133 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 4 files changed, 212 insertions(+), 58 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 035e448..7324fb4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -400,7 +400,7 @@ static struct symbol *bad_expr_type(struct expression *expr)
 		break;
 	}
 
-	expr->flags = 0;
+	expr->flags = EXPR_FLAG_NONE;
 	return expr->ctype = &bad_ctype;
 }
 
@@ -880,8 +880,9 @@ static struct symbol *evaluate_logical(struct expression *expr)
 	/* the result is int [6.5.13(3), 6.5.14(3)] */
 	expr->ctype = &int_ctype;
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 	return &int_ctype;
 }
@@ -894,8 +895,9 @@ static struct symbol *evaluate_binop(struct expression *expr)
 	int op = expr->op;
 
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	/* number op number */
@@ -986,7 +988,7 @@ static inline int is_null_pointer_constant(struct expression *e)
 {
 	if (e->ctype == &null_ctype)
 		return 1;
-	if (!(e->flags & Int_const_expr))
+	if (!(e->flags & EXPR_FLAG_INT_CONST_EXPR))
 		return 0;
 	return is_zero_constant(e) ? 2 : 0;
 }
@@ -1001,8 +1003,9 @@ static struct symbol *evaluate_compare(struct expression *expr)
 	const char *typediff;
 
 	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags & Int_const_expr))
-			expr->flags = 0;
+		if (!(expr->left->flags & expr->right->flags &
+				EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	/* Type types? */
@@ -1120,10 +1123,11 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	}
 
 	if (expr->flags) {
-		int flags = expr->conditional->flags & Int_const_expr;
+		int flags = (expr->conditional->flags &
+			expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR));
 		flags &= (*true)->flags & expr->cond_false->flags;
 		if (!flags)
-			expr->flags = 0;
+			expr->flags = EXPR_FLAG_NONE;
 	}
 
 	lclass = classify_type(ltype, &ltype);
@@ -1681,7 +1685,7 @@ static struct symbol *evaluate_addressof(struct expression *expr)
 	}
 	ctype = op->ctype;
 	*expr = *op->unop;
-	expr->flags = 0;
+	expr->flags = EXPR_FLAG_NONE;
 
 	if (expr->type == EXPR_SYMBOL) {
 		struct symbol *sym = expr->symbol;
@@ -1709,7 +1713,7 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 	/* Simplify: *&(expr) => (expr) */
 	if (op->type == EXPR_PREOP && op->op == '&') {
 		*expr = *op->unop;
-		expr->flags = 0;
+		expr->flags = EXPR_FLAG_NONE;
 		return expr->ctype;
 	}
 
@@ -1799,8 +1803,8 @@ static struct symbol *evaluate_sign(struct expression *expr)
 {
 	struct symbol *ctype = expr->unop->ctype;
 	int class = classify_type(ctype, &ctype);
-	if (expr->flags && !(expr->unop->flags & Int_const_expr))
-		expr->flags = 0;
+	if (expr->flags && !(expr->unop->flags & EXPR_FLAG_INT_CONST_EXPR))
+		expr->flags = EXPR_FLAG_NONE;
 	/* should be an arithmetic type */
 	if (!(class & TYPE_NUM))
 		return bad_expr_type(expr);
@@ -1854,8 +1858,9 @@ static struct symbol *evaluate_preop(struct expression *expr)
 		return evaluate_postop(expr);
 
 	case '!':
-		if (expr->flags && !(expr->unop->flags & Int_const_expr))
-			expr->flags = 0;
+		if (expr->flags && !(expr->unop->flags &
+					EXPR_FLAG_INT_CONST_EXPR))
+			expr->flags = EXPR_FLAG_NONE;
 		if (is_safe_type(ctype))
 			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
@@ -2734,14 +2739,19 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 	class1 = classify_type(ctype, &t1);
 
-	/* cast to non-integer type -> not an integer constant expression */
-	if (!is_int(class1))
-		expr->flags = 0;
+	/* cast to non-numeric type -> not an arithmetic expression */
+	if (!(class1 & TYPE_NUM))
+		expr->flags &=
+			~expr_clear_flag_mask(EXPR_FLAG_ARITH_CONST_EXPR);
+	/* cast to float type -> not an integer constant expression */
+	else if (class1 & TYPE_FLOAT)
+		expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	/* if argument turns out to be not an integer constant expression *and*
 	   it was not a floating literal to start with -> too bad */
-	else if (expr->flags == Int_const_expr &&
-		!(target->flags & Int_const_expr))
-		expr->flags = 0;
+	else if (!(target->flags &
+			(EXPR_FLAG_INT_CONST_EXPR | EXPR_FLAG_FP_CONST)))
+		expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
+
 	/*
 	 * You can always throw a value away by casting to
 	 * "void" - that's an implicit "force". Note that
@@ -2803,7 +2813,7 @@ static struct symbol *evaluate_cast(struct expression *expr)
 			"cast adds address space to expression (<asn:%d>)", as1);
 
 	if (!(t1->ctype.modifiers & MOD_PTRINHERIT) && class1 == TYPE_PTR &&
-	    !as1 && (target->flags & Int_const_expr)) {
+	    !as1 && (target->flags & EXPR_FLAG_INT_CONST_EXPR)) {
 		if (t1->ctype.base_type == &void_ctype) {
 			if (is_zero_constant(target)) {
 				/* NULL */
@@ -2933,7 +2943,7 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		}
 		ctype = field;
 		expr->type = EXPR_VALUE;
-		expr->flags = Int_const_expr;
+		expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		expr->value = offset;
 		expr->taint = 0;
 		expr->ctype = size_t_ctype;
@@ -2951,7 +2961,8 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		ctype = ctype->ctype.base_type;
 		if (!expr->index) {
 			expr->type = EXPR_VALUE;
-			expr->flags = Int_const_expr;
+			expr->flags
+				= expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			expr->value = 0;
 			expr->taint = 0;
 			expr->ctype = size_t_ctype;
@@ -2968,13 +2979,14 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 			m = alloc_const_expression(expr->pos,
 						   bits_to_bytes(ctype->bit_size));
 			m->ctype = size_t_ctype;
-			m->flags = Int_const_expr;
+			m->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			expr->type = EXPR_BINOP;
 			expr->left = idx;
 			expr->right = m;
 			expr->op = '*';
 			expr->ctype = size_t_ctype;
-			expr->flags = m->flags & idx->flags & Int_const_expr;
+			expr->flags = m->flags & idx->flags &
+				expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		}
 	}
 	if (e) {
@@ -2985,7 +2997,8 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 		if (!evaluate_expression(e))
 			return NULL;
 		expr->type = EXPR_BINOP;
-		expr->flags = e->flags & copy->flags & Int_const_expr;
+		expr->flags = e->flags & copy->flags &
+			expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		expr->op = '+';
 		expr->ctype = size_t_ctype;
 		expr->left = copy;
diff --git a/expand.c b/expand.c
index 0f6720c..afca611 100644
--- a/expand.c
+++ b/expand.c
@@ -1212,7 +1212,7 @@ static int expand_statement(struct statement *stmt)
 
 static inline int bad_integer_constant_expression(struct expression *expr)
 {
-	if (!(expr->flags & Int_const_expr))
+	if (!(expr->flags & EXPR_FLAG_INT_CONST_EXPR))
 		return 1;
 	if (expr->taint & Taint_comma)
 		return 1;
diff --git a/expression.c b/expression.c
index 7293d47..8582dc9 100644
--- a/expression.c
+++ b/expression.c
@@ -131,7 +131,8 @@ static struct token *parse_type(struct token *token, struct expression **tree)
 {
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
-	(*tree)->flags = Int_const_expr; /* sic */
+	(*tree)->flags
+		= expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR); /* sic */
 	token = typename(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
@@ -146,7 +147,7 @@ static struct token *builtin_types_compatible_p_expr(struct token *token,
 {
 	struct expression *expr = alloc_expression(
 		token->pos, EXPR_COMPARE);
-	expr->flags = Int_const_expr;
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	expr->op = SPECIAL_EQUAL;
 	token = token->next;
 	if (!match_op(token, '('))
@@ -200,7 +201,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 			return expect(token, ')', "at end of __builtin_offset");
 		case SPECIAL_DEREFERENCE:
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			e->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			*p = e;
 			p = &e->down;
@@ -208,7 +209,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '.':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			e->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '.';
 			if (token_type(token) != TOKEN_IDENT) {
 				sparse_error(token->pos, "Expected member name");
@@ -220,7 +221,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		case '[':
 			token = token->next;
 			e = alloc_expression(token->pos, EXPR_OFFSETOF);
-			e->flags = Int_const_expr;
+			e->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			e->op = '[';
 			token = parse_expression(token, &e->index);
 			token = expect(token, ']',
@@ -336,7 +337,7 @@ got_it:
 			"likely to produce unsigned long (and a warning) here",
 			show_token(token));
         expr->type = EXPR_VALUE;
-	expr->flags = Int_const_expr;
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST);
         expr->ctype = ctype_integer(size, want_unsigned);
         expr->value = value;
 	return;
@@ -361,7 +362,7 @@ Float:
 	else
 		goto Enoint;
 
-	expr->flags = Float_literal;
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_FP_CONST);
 	expr->type = EXPR_FVALUE;
 	return;
 
@@ -376,7 +377,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 	switch (token_type(token)) {
 	case TOKEN_CHAR ... TOKEN_WIDE_CHAR_EMBEDDED_3:
 		expr = alloc_expression(token->pos, EXPR_VALUE);   
-		expr->flags = Int_const_expr;
+		expr->flags = expr_set_flag_mask(EXPR_FLAG_CHAR_CONST);
 		expr->ctype = token_type(token) < TOKEN_WIDE_CHAR ? &int_ctype : &long_ctype;
 		get_char_constant(token, &expr->value);
 		token = token->next;
@@ -390,7 +391,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 
 	case TOKEN_ZERO_IDENT: {
 		expr = alloc_expression(token->pos, EXPR_SYMBOL);
-		expr->flags = Int_const_expr;
+		expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 		expr->ctype = &int_ctype;
 		expr->symbol = &zero_int;
 		expr->symbol_name = token->ident;
@@ -417,7 +418,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 			*expr = *sym->initializer;
 			/* we want the right position reported, thus the copy */
 			expr->pos = token->pos;
-			expr->flags = Int_const_expr;
+			expr->flags = expr_set_flag_mask(EXPR_FLAG_ENUM_CONST);
 			token = next;
 			break;
 		}
@@ -457,7 +458,9 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		}
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
-			expr->flags = Int_const_expr; /* sic */
+			/* sic */
+			expr->flags
+				= expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 			token = typename(token->next, &expr->symbol, NULL);
 			token = expect(token, ']', "in type expression");
 			break;
@@ -573,7 +576,8 @@ static struct token *type_info_expression(struct token *token,
 	struct token *p;
 
 	*tree = expr;
-	expr->flags = Int_const_expr; /* XXX: VLA support will need that changed */
+	/* XXX: VLA support will need that changed */
+	expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	token = token->next;
 	if (!match_op(token, '(') || !lookup_type(token->next))
 		return unary_expression(token, &expr->cast_expression);
@@ -662,7 +666,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 			unary = alloc_expression(token->pos, EXPR_PREOP);
 			unary->op = token->special;
 			unary->unop = unop;
-			unary->flags = unop->flags & Int_const_expr;
+			unary->flags = expr_flags_decay_consts(unop->flags);
 			*tree = unary;
 			return next;
 		}
@@ -720,10 +724,24 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			if (!v)
 				return token;
 			cast->cast_expression = v;
-			if (v->flags & Int_const_expr)
-				cast->flags = Int_const_expr;
-			else if (v->flags & Float_literal) /* and _not_ int */
-				cast->flags = Int_const_expr | Float_literal;
+
+			cast->flags = expr_flags_decay_consts(v->flags);
+			/*
+			 * Up to now, we missed the (int).0 case here
+			 * which should really get a
+			 * EXPR_FLAG_INT_CONST_EXPR marker. Also,
+			 * conversion to non-numeric types is not
+			 * properly reflected up to this point.
+			 * However, we do not know until evaluation.
+			 * For the moment, in order to preserve
+			 * semantics, speculatively set
+			 * EXPR_FLAG_INT_CONST_EXPR if
+			 * EXPR_FLAG_FP_CONST is set. evaluate_cast()
+			 * will unset inappropriate flags again after
+			 * examining type information.
+			 */
+			if (v->flags & EXPR_FLAG_FP_CONST)
+				cast->flags |= EXPR_FLAG_INT_CONST_EXPR;
 			return token;
 		}
 	}
@@ -760,8 +778,9 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 				sparse_error(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
-			top->flags = left->flags & right->flags		\
-						& Int_const_expr;	\
+			top->flags					\
+				= expr_flags_decay_consts(left->flags	\
+							& right->flags); \
 			top->op = op;					\
 			top->left = left;				\
 			top->right = right;				\
@@ -865,12 +884,11 @@ struct token *conditional_expression(struct token *token, struct expression **tr
 		token = expect(token, ':', "in conditional expression");
 		token = conditional_expression(token, &expr->cond_false);
 		if (expr->left && expr->cond_false) {
-			int is_const = expr->left->flags &
-					expr->cond_false->flags &
-					Int_const_expr;
+			enum expression_flags flags = expr->left->flags &
+				expr->cond_false->flags;
 			if (expr->cond_true)
-				is_const &= expr->cond_true->flags;
-			expr->flags = is_const;
+				flags &= expr->cond_true->flags;
+			expr->flags = expr_flags_decay_consts(flags);
 		}
 	}
 	return token;
diff --git a/expression.h b/expression.h
index 80b3be5..1c8a563 100644
--- a/expression.h
+++ b/expression.h
@@ -66,10 +66,133 @@ enum expression_type {
 	EXPR_OFFSETOF,
 };
 
-enum {
-	Int_const_expr = 1,
-	Float_literal = 2,
-}; /* for expr->flags */
+
+/*
+ * Flags for tracking the promotion of various attributes from
+ * subexpressions to their parents.
+ *
+ * Currently, they only cope with an expression's constness as defined
+ * by C99.
+ *
+ * The flags are not independent as one might imply another. Use
+ * expr_set_flag_mask() and expr_clear_flag_mask() for setting and
+ * clearing a particular flag.
+ */
+enum expression_flags {
+	EXPR_FLAG_NONE = 0,
+	/*
+	 * A constant in the sense of [6.4.4]:
+	 * - Integer constant [6.4.4.1]
+	 * - Floating point constant [6.4.4.2]
+	 * - Enumeration constant [6.4.4.3]
+	 * - Character constant [6.4.4.4]
+	 */
+	EXPR_FLAG_INT_CONST = (1 << 0),
+	EXPR_FLAG_FP_CONST = (1 << 1),
+	EXPR_FLAG_ENUM_CONST = (1 << 2),
+	EXPR_FLAG_CHAR_CONST = (1 << 3),
+
+	/*
+	 * A constant expression in the sense of [6.6]:
+	 * - integer constant expression [6.6(6)]
+	 * - arithmetic constant expression [6.6(8)]
+	 * - address constanr [6.6(9)]
+	 */
+	EXPR_FLAG_INT_CONST_EXPR = (1 << 4),
+	EXPR_FLAG_ARITH_CONST_EXPR = (1 << 5),
+	EXPR_FLAG_ADDR_CONST_EXPR = (1 << 6),
+};
+
+/*
+ * Calculate a mask to be or'ed in in order to set a particular
+ * expression flag.
+ *
+ * Only one single flag from enum expression_flags is allowed at a
+ * time.
+ */
+static inline enum expression_flags expr_set_flag_mask
+	(const enum expression_flags flag)
+{
+	/* obey the implications */
+	enum expression_flags implied_flags = EXPR_FLAG_NONE;
+
+	switch (flag) {
+	case EXPR_FLAG_INT_CONST:
+	case EXPR_FLAG_ENUM_CONST:
+	case EXPR_FLAG_CHAR_CONST:
+		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
+	/* fallthrough */
+	case EXPR_FLAG_FP_CONST:
+	case EXPR_FLAG_INT_CONST_EXPR:
+		implied_flags |= EXPR_FLAG_ARITH_CONST_EXPR;
+	/* fallthrough */
+	case EXPR_FLAG_ARITH_CONST_EXPR:
+	case EXPR_FLAG_ADDR_CONST_EXPR:
+	case EXPR_FLAG_NONE:
+		break;
+	}
+
+	return (implied_flags | flag);
+}
+
+/*
+ * Calculate a mask to be negated and and'ed in in order to clear a
+ * particular expression flag.
+ *
+ * Only one single flag from enum expression_flags is allowed at a
+ * time.
+ */
+static inline enum expression_flags expr_clear_flag_mask
+	(const enum expression_flags flag)
+{
+	/* obey the implications */
+	enum expression_flags implied_flags = EXPR_FLAG_NONE;
+
+	switch (flag) {
+	case EXPR_FLAG_ARITH_CONST_EXPR:
+		implied_flags |= EXPR_FLAG_INT_CONST_EXPR;
+		implied_flags |= EXPR_FLAG_FP_CONST;
+	/* fallthrough */
+	case EXPR_FLAG_INT_CONST_EXPR:
+		implied_flags |= EXPR_FLAG_INT_CONST;
+		implied_flags |= EXPR_FLAG_ENUM_CONST;
+		implied_flags |= EXPR_FLAG_CHAR_CONST;
+	/* fallthrough */
+	case EXPR_FLAG_ADDR_CONST_EXPR:
+	case EXPR_FLAG_INT_CONST:
+	case EXPR_FLAG_FP_CONST:
+	case EXPR_FLAG_ENUM_CONST:
+	case EXPR_FLAG_CHAR_CONST:
+	case EXPR_FLAG_NONE:
+		break;
+	}
+
+	return (implied_flags | flag);
+}
+
+/*
+ *  Remove any "Constant" [6.4.4] flag, but retain the "constant
+ * expression" [6.6] flags.
+ * Used to merge the constantness flags of primary subexpressions
+ * into their parent expressions' ones.
+ */
+static inline enum expression_flags expr_flags_decay_consts
+	(enum expression_flags flags)
+{
+	return (flags & ~(expr_clear_flag_mask(EXPR_FLAG_INT_CONST)
+			  | expr_clear_flag_mask(EXPR_FLAG_FP_CONST)
+			  | expr_clear_flag_mask(EXPR_FLAG_ENUM_CONST)
+			  | expr_clear_flag_mask(EXPR_FLAG_CHAR_CONST)));
+}
+
+/* Purge any constantness related flag. */
+static inline enum expression_flags expr_flags_remove_consts
+	(enum expression_flags flags)
+{
+	return (flags &
+		~(expr_clear_flag_mask(EXPR_FLAG_ARITH_CONST_EXPR)
+		  | expr_clear_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR)));
+}
 
 enum {
 	Taint_comma = 1,
@@ -77,7 +200,7 @@ enum {
 
 struct expression {
 	enum expression_type type:8;
-	unsigned flags:8;
+	enum expression_flags flags:8;
 	int op;
 	struct position pos;
 	struct symbol *ctype;
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 02/13] expression: examine constness of casts at evaluation only ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 02/13] expression: examine constness of casts at evaluation only
Date: Wed, 22 Jul 2015 23:12:47 +0000
Message-ID: <87mvynkcr4.fsf () gmail ! com>
--------------------
Currently, the propagation of expressions' constness flags through
cast expressions is done in two steps:
- Several flags are speculatively set at cast expression parsing time
- and possibly cleared again at evaluation time.

Set aside this unfortunate split of code, the early propagation of
constness flags is not able to recognize constant expressions such as
  (int)__builtin_choose_expr(0, 0, 0)
since the final expression to be thrown into the cast is known only
after evaluation.

Move the whole calculation of cast expressions' constness flags to the
evaluation phase.

Introduce support for tracking arithmetic constness propagation through
cast expressions.

Introduce support for recognizing address constants created by casting
an integer constant to pointer type.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                  | 45 +++++++++++++++++++++++++++++++++------------
 expression.c                | 18 ------------------
 validation/constexpr-cast.c | 25 +++++++++++++++++++++++++
 3 files changed, 58 insertions(+), 30 deletions(-)
 create mode 100644 validation/constexpr-cast.c

diff --git a/evaluate.c b/evaluate.c
index 7324fb4..90d6da0 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -323,7 +323,6 @@ static struct expression * cast_to(struct expression *old, struct symbol *type)
 	}
 
 	expr = alloc_expression(old->pos, EXPR_IMPLIED_CAST);
-	expr->flags = old->flags;
 	expr->ctype = type;
 	expr->cast_type = type;
 	expr->cast_expression = old;
@@ -2739,18 +2738,40 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 	class1 = classify_type(ctype, &t1);
 
-	/* cast to non-numeric type -> not an arithmetic expression */
-	if (!(class1 & TYPE_NUM))
+	if (!(class1 & TYPE_NUM)) {
+		/*
+		 * Casts of integer literals to pointer type yield
+		 * address constants [6.6(9)].
+		 */
+		if (class1 & TYPE_PTR &&
+			(target->flags & EXPR_FLAG_INT_CONST)) {
+			expr->flags |=
+				expr_set_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
+
+		}
+	} else {
+		expr->flags |= expr_flags_decay_consts(target->flags);
+		/*
+		 * Casts to numeric types never result in address
+		 * constants [6.6(9)].
+		 */
 		expr->flags &=
-			~expr_clear_flag_mask(EXPR_FLAG_ARITH_CONST_EXPR);
-	/* cast to float type -> not an integer constant expression */
-	else if (class1 & TYPE_FLOAT)
-		expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
-	/* if argument turns out to be not an integer constant expression *and*
-	   it was not a floating literal to start with -> too bad */
-	else if (!(target->flags &
-			(EXPR_FLAG_INT_CONST_EXPR | EXPR_FLAG_FP_CONST)))
-		expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
+			~expr_set_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
+		/*
+		 * Cast to float type -> not an integer constant
+		 * expression [6.6(6)].
+		 */
+		if (class1 & TYPE_FLOAT)
+			expr->flags &=
+				~expr_clear_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
+		/*
+		 * Casts of float literals to integer type results in
+		 * a constant integer expression [6.6(6)].
+		 */
+		else if (target->flags & EXPR_FLAG_FP_CONST)
+			expr->flags |=
+				expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
+	}
 
 	/*
 	 * You can always throw a value away by casting to
diff --git a/expression.c b/expression.c
index 8582dc9..9a0cd8c 100644
--- a/expression.c
+++ b/expression.c
@@ -724,24 +724,6 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			if (!v)
 				return token;
 			cast->cast_expression = v;
-
-			cast->flags = expr_flags_decay_consts(v->flags);
-			/*
-			 * Up to now, we missed the (int).0 case here
-			 * which should really get a
-			 * EXPR_FLAG_INT_CONST_EXPR marker. Also,
-			 * conversion to non-numeric types is not
-			 * properly reflected up to this point.
-			 * However, we do not know until evaluation.
-			 * For the moment, in order to preserve
-			 * semantics, speculatively set
-			 * EXPR_FLAG_INT_CONST_EXPR if
-			 * EXPR_FLAG_FP_CONST is set. evaluate_cast()
-			 * will unset inappropriate flags again after
-			 * examining type information.
-			 */
-			if (v->flags & EXPR_FLAG_FP_CONST)
-				cast->flags |= EXPR_FLAG_INT_CONST_EXPR;
 			return token;
 		}
 	}
diff --git a/validation/constexpr-cast.c b/validation/constexpr-cast.c
new file mode 100644
index 0000000..2706961
--- /dev/null
+++ b/validation/constexpr-cast.c
@@ -0,0 +1,25 @@
+static int a[] = {
+	[(int)0] = 0,		// OK
+	[(int)(int)0] = 0,	// OK
+	[(int)0.] = 0,		// OK
+	[(int)(int)0.] = 0,	// OK
+	[(int)__builtin_choose_expr(0, 0, 0)] = 0,	// OK
+	[(int)__builtin_choose_expr(0, 0, 0.)] = 0,	// OK
+
+	[(int)(float)0] = 0,	// KO
+	[(int)(float)0.] = 0,	// KO
+
+	[(int)(void*)0] = 0,	// KO
+	[(int)(void*)0.] = 0,	// KO
+
+};
+/*
+ * check-name: Expression constness propagation in casts
+ *
+ * check-error-start
+constexpr-cast.c:9:11: error: bad integer constant expression
+constexpr-cast.c:10:11: error: bad integer constant expression
+constexpr-cast.c:12:11: error: bad integer constant expression
+constexpr-cast.c:13:11: error: bad integer constant expression
+ * check-error-end
+ */
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 03/13] expression: examine constness of binops and alike at evaluation only ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 03/13] expression: examine constness of binops and alike at evaluation only
Date: Wed, 22 Jul 2015 23:14:37 +0000
Message-ID: <87io9bkco2.fsf () gmail ! com>
--------------------
Currently, the propagation of expressions' constness flags through
binary operations, compare and logical expressions is done in two
steps:
- Several flags are speculatively set at expression parsing time
- and possibly cleared again at evaluation time.

Set aside this unfortunate split of code, the early propagation of
constness flags is not able to recognize constant expressions such as
  0 + __builtin_choose_expr(0, 0, 0)
  0 < __builtin_choose_expr(0, 0, 0)
  0 && __builtin_choose_expr(0, 0, 0)
since the final expression to be thrown into the binop-like expression
is known only after evaluation.

Move the whole calculation of binary operations', compare and logical
expressions' constness flags to the evaluation phase.

Introduce support for tracking arithmetic constness propagation through
binop-like expressions.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                   | 24 ++++++++----------------
 expression.c                 |  4 ----
 validation/constexpr-binop.c | 33 +++++++++++++++++++++++++++++++++
 3 files changed, 41 insertions(+), 20 deletions(-)
 create mode 100644 validation/constexpr-binop.c

diff --git a/evaluate.c b/evaluate.c
index 90d6da0..637824c 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -878,11 +878,9 @@ static struct symbol *evaluate_logical(struct expression *expr)
 
 	/* the result is int [6.5.13(3), 6.5.14(3)] */
 	expr->ctype = &int_ctype;
-	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags &
-				EXPR_FLAG_INT_CONST_EXPR))
-			expr->flags = EXPR_FLAG_NONE;
-	}
+	expr->flags |= expr_flags_decay_consts(expr->left->flags &
+					expr->right->flags);
+	expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
 	return &int_ctype;
 }
 
@@ -893,14 +891,11 @@ static struct symbol *evaluate_binop(struct expression *expr)
 	int rclass = classify_type(expr->right->ctype, &rtype);
 	int op = expr->op;
 
-	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags &
-				EXPR_FLAG_INT_CONST_EXPR))
-			expr->flags = EXPR_FLAG_NONE;
-	}
-
 	/* number op number */
 	if (lclass & rclass & TYPE_NUM) {
+		expr->flags |= expr_flags_decay_consts(expr->left->flags &
+						expr->right->flags);
+
 		if ((lclass | rclass) & TYPE_FLOAT) {
 			switch (op) {
 			case '+': case '-': case '*': case '/':
@@ -1001,11 +996,8 @@ static struct symbol *evaluate_compare(struct expression *expr)
 	struct symbol *ctype;
 	const char *typediff;
 
-	if (expr->flags) {
-		if (!(expr->left->flags & expr->right->flags &
-				EXPR_FLAG_INT_CONST_EXPR))
-			expr->flags = EXPR_FLAG_NONE;
-	}
+	expr->flags |= expr_flags_decay_consts(left->flags & right->flags);
+	expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
 
 	/* Type types? */
 	if (is_type_type(ltype) && is_type_type(rtype))
diff --git a/expression.c b/expression.c
index 9a0cd8c..b52ae15 100644
--- a/expression.c
+++ b/expression.c
@@ -147,7 +147,6 @@ static struct token *builtin_types_compatible_p_expr(struct token *token,
 {
 	struct expression *expr = alloc_expression(
 		token->pos, EXPR_COMPARE);
-	expr->flags = expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	expr->op = SPECIAL_EQUAL;
 	token = token->next;
 	if (!match_op(token, '('))
@@ -760,9 +759,6 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 				sparse_error(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
-			top->flags					\
-				= expr_flags_decay_consts(left->flags	\
-							& right->flags); \
 			top->op = op;					\
 			top->left = left;				\
 			top->right = right;				\
diff --git a/validation/constexpr-binop.c b/validation/constexpr-binop.c
new file mode 100644
index 0000000..85a88e3
--- /dev/null
+++ b/validation/constexpr-binop.c
@@ -0,0 +1,33 @@
+static int a[] = {
+	[0 + 0] = 0,						// OK
+	[0 + 0.] = 0,						// KO
+	[(void*)0 + 0] = 0,					// KO
+	[0 + __builtin_choose_expr(0, 0, 0)] = 0,		// OK
+	[0 + __builtin_choose_expr(0, 0., 0)] = 0,		// OK
+	[0 + __builtin_choose_expr(0, 0, 0.)] = 0,		// KO
+	[0 < 0] = 0,						// OK
+	[0 < 0.] = 0,						// KO
+	[0 < __builtin_choose_expr(0, 0, 0)] = 0,		// OK
+	[0 < __builtin_choose_expr(0, 0., 0)] = 0,		// OK
+	[0 < __builtin_choose_expr(0, 0, 0.)] = 0,		// KO
+	[0 && 0] = 0,						// OK
+	[0 && 0.] = 0,						// KO
+	[0 && __builtin_choose_expr(0, 0, 0)] = 0,		// OK
+	[0 && __builtin_choose_expr(0, 0., 0)] = 0,		// OK
+	[0 && __builtin_choose_expr(0, 0, 0.)] = 0,		// KO
+	[0 + __builtin_types_compatible_p(int, float)] = 0,	// OK
+};
+
+/*
+ * check-name: Expression constness propagation in binops and alike
+ *
+ * check-error-start
+constexpr-binop.c:3:12: error: bad constant expression
+constexpr-binop.c:4:19: error: bad integer constant expression
+constexpr-binop.c:7:12: error: bad constant expression
+constexpr-binop.c:9:12: error: bad integer constant expression
+constexpr-binop.c:12:12: error: bad integer constant expression
+constexpr-binop.c:14:12: error: bad integer constant expression
+constexpr-binop.c:17:12: error: bad integer constant expression
+ * check-error-end
+ */
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 04/13] expression: examine constness of preops at evaluation only ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 04/13] expression: examine constness of preops at evaluation only
Date: Wed, 22 Jul 2015 23:15:40 +0000
Message-ID: <87egjzkcmb.fsf () gmail ! com>
--------------------
Currently, the propagation of expressions' constness flags through
prefix expressions is done in two steps:
- Several flags are speculatively set at expression parsing time
- and possibly cleared again at evaluation time.

Set aside this unfortunate split of code, the early propagation of
constness flags is not able to recognize constant expressions such as
  -__builtin_choose_expr(0, 0, 0)
  ~__builtin_choose_expr(0, 0, 0)
  !__builtin_choose_expr(0, 0, 0)
since the final expression to be thrown into the prefix expression is
known only after evaluation.

Move the whole calculation of prefix expressions' constness flags to
the evaluation phase.

Introduce support for tracking arithmetic constness propagation through
prefix expressions.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                   | 15 ++++++++++-----
 expression.c                 |  3 ---
 validation/constexpr-preop.c | 29 +++++++++++++++++++++++++++++
 3 files changed, 39 insertions(+), 8 deletions(-)
 create mode 100644 validation/constexpr-preop.c

diff --git a/evaluate.c b/evaluate.c
index 637824c..e1d2f3d 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1794,8 +1794,9 @@ static struct symbol *evaluate_sign(struct expression *expr)
 {
 	struct symbol *ctype = expr->unop->ctype;
 	int class = classify_type(ctype, &ctype);
-	if (expr->flags && !(expr->unop->flags & EXPR_FLAG_INT_CONST_EXPR))
-		expr->flags = EXPR_FLAG_NONE;
+	enum expression_flags flags;
+
+	flags = expr->flags | expr_flags_decay_consts(expr->unop->flags);
 	/* should be an arithmetic type */
 	if (!(class & TYPE_NUM))
 		return bad_expr_type(expr);
@@ -1812,6 +1813,7 @@ Normal:
 	}
 	if (expr->op == '+')
 		*expr = *expr->unop;
+	expr->flags = flags;
 	expr->ctype = ctype;
 	return ctype;
 Restr:
@@ -1849,9 +1851,12 @@ static struct symbol *evaluate_preop(struct expression *expr)
 		return evaluate_postop(expr);
 
 	case '!':
-		if (expr->flags && !(expr->unop->flags &
-					EXPR_FLAG_INT_CONST_EXPR))
-			expr->flags = EXPR_FLAG_NONE;
+		expr->flags |= expr_flags_decay_consts(expr->unop->flags);
+		/*
+		 * A logical negation never yields an address constant
+		 * [6.6(9)].
+		 */
+		expr->flags &= ~expr_clear_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
 		if (is_safe_type(ctype))
 			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
diff --git a/expression.c b/expression.c
index b52ae15..7759bd0 100644
--- a/expression.c
+++ b/expression.c
@@ -451,8 +451,6 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 			expr = alloc_expression(token->pos, EXPR_PREOP);
 			expr->op = '(';
 			token = parens_expression(token, &expr->unop, "in expression");
-			if (expr->unop)
-				expr->flags = expr->unop->flags;
 			break;
 		}
 		if (token->special == '[' && lookup_type(token->next)) {
@@ -665,7 +663,6 @@ static struct token *unary_expression(struct token *token, struct expression **t
 			unary = alloc_expression(token->pos, EXPR_PREOP);
 			unary->op = token->special;
 			unary->unop = unop;
-			unary->flags = expr_flags_decay_consts(unop->flags);
 			*tree = unary;
 			return next;
 		}
diff --git a/validation/constexpr-preop.c b/validation/constexpr-preop.c
new file mode 100644
index 0000000..5d869da
--- /dev/null
+++ b/validation/constexpr-preop.c
@@ -0,0 +1,29 @@
+static int a[] = {
+  [+0] = 0,					// OK
+  [+__builtin_choose_expr(0, 0, 0)] = 0,	// OK
+  [+0.] = 0,					// KO
+  [+__builtin_choose_expr(0, 0, 0.)] = 0,	// KO
+  [-0] = 0,					// OK
+  [-__builtin_choose_expr(0, 0, 0)] = 0,	// OK
+  [-0.] = 0,					// KO
+  [-__builtin_choose_expr(0, 0, 0.)] = 0,	// KO
+  [~0] = 0,					// OK
+  [~__builtin_choose_expr(0, 0, 0)] = 0,	// OK
+  [!0] = 0,					// OK
+  [!__builtin_choose_expr(0, 0, 0)] = 0,	// OK
+  [!0.] = 0,					// KO
+  [!__builtin_choose_expr(0, 0, 0.)] = 0,	// KO
+};
+
+/*
+ * check-name: Expression constness propagation in preops
+ *
+ * check-error-start
+constexpr-preop.c:4:5: error: bad constant expression
+constexpr-preop.c:5:33: error: bad constant expression
+constexpr-preop.c:8:4: error: bad constant expression
+constexpr-preop.c:9:4: error: bad constant expression
+constexpr-preop.c:14:4: error: bad integer constant expression
+constexpr-preop.c:15:4: error: bad integer constant expression
+ * check-error-end
+ */
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 06/13] expression, evaluate: add support for recognizing address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 06/13] expression, evaluate: add support for recognizing address constants
Date: Wed, 22 Jul 2015 23:18:08 +0000
Message-ID: <87615bkci7.fsf () gmail ! com>
--------------------
Address constants [6.6(9)] constitute one of the types of constant
expressions allowed in initializers [6.6(7)] for static storage
duration objects [6.7.8(4)].

Introduce support for recognizing address constants created either
- explicitly by referencing a static storage duration object by means
  of the unary & operator
- or implicitly by the use of an expression of array or function type.

Treat string literals as address constants.

Initially tag an expression as being an address constant at the
primary expression level, i.e. upon encountering a symbol designating
an object of static storage duration in primary_expression().

Carry these flags over to the *-preop wrapped expression created by
evaluate_symbol_expression().

For the special case of string literals, tag them as address constants
in evaluate_string().

Take care in evaluate_ptr_add() and evaluate_offset()
to properly propagate the address constness flags from
subexpressions to their parent expressions, namely the array ([])
or structure member dereference (->, .) expressions.

Finally, do not strip away an *-preop wrapped expression's constness
flags in evaluate_addressof().

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c   | 19 ++++++++++++++++++-
 expression.c |  9 +++++++++
 2 files changed, 27 insertions(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index edd0fe1..c38b893 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -70,9 +70,11 @@ static struct symbol *evaluate_symbol_expression(struct expression *expr)
 	addr->symbol = sym;
 	addr->symbol_name = expr->symbol_name;
 	addr->ctype = &lazy_ptr_ctype;	/* Lazy evaluation: we need to do a proper job if somebody does &sym */
+	addr->flags = expr->flags;
 	expr->type = EXPR_PREOP;
 	expr->op = '*';
 	expr->unop = addr;
+	expr->flags = EXPR_FLAG_NONE;
 
 	/* The type of a symbol is the symbol itself! */
 	expr->ctype = sym;
@@ -106,6 +108,7 @@ static struct symbol *evaluate_string(struct expression *expr)
 	
 	addr->symbol = sym;
 	addr->ctype = &lazy_ptr_ctype;
+	addr->flags |= expr_set_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
 
 	expr->type = EXPR_PREOP;
 	expr->op = '*';
@@ -563,6 +566,15 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
 	classify_type(degenerate(expr->left), &ctype);
 	base = examine_pointer_target(ctype);
 
+	/*
+	 * An address constant +/- an integer constant expression
+	 * yields an address constant again [6.6(7)].
+	 */
+	if ((expr->left->flags & EXPR_FLAG_ADDR_CONST_EXPR) &&
+		(expr->right->flags & EXPR_FLAG_INT_CONST_EXPR))
+		expr->flags |=
+			expr_set_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
+
 	if (!base) {
 		expression_error(expr, "missing type information");
 		return NULL;
@@ -1677,7 +1689,6 @@ static struct symbol *evaluate_addressof(struct expression *expr)
 	}
 	ctype = op->ctype;
 	*expr = *op->unop;
-	expr->flags = EXPR_FLAG_NONE;
 
 	if (expr->type == EXPR_SYMBOL) {
 		struct symbol *sym = expr->symbol;
@@ -1942,6 +1953,12 @@ static struct expression *evaluate_offset(struct expression *expr, unsigned long
 	 * we ever take the address of this member dereference..
 	 */
 	add->ctype = &lazy_ptr_ctype;
+	/*
+	 * An address constant +/- an integer constant expression
+	 * yields an address constant again [6.6(7)].
+	 */
+	add->flags |= expr->flags;
+
 	return add;
 }
 
diff --git a/expression.c b/expression.c
index a18fcc6..4d5edc8 100644
--- a/expression.c
+++ b/expression.c
@@ -436,6 +436,15 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		}
 		expr->symbol_name = token->ident;
 		expr->symbol = sym;
+
+		/*
+		 * A pointer to an lvalue designating a static storage
+		 * duration object is an address constant [6.6(9)].
+		 */
+		if (sym && (sym->ctype.modifiers & (MOD_TOPLEVEL | MOD_STATIC)))
+			expr->flags |=
+				expr_set_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
+
 		token = next;
 		break;
 	}
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 07/13] evaluate: check static storage duration objects' intializers' constness
Date: Wed, 22 Jul 2015 23:19:09 +0000
Message-ID: <871tfzkcgi.fsf () gmail ! com>
--------------------
Initializers of static storage duration objects shall be constant
expressions [6.7.8(4)].

Warn if that requirement is not met.

Identify static storage duration objects by having either of
MOD_TOPLEVEL or MOD_STATIC set.

Check an initializer's constness at the lowest possible subobject
level, i.e. at the level of the "assignment-expression" production
in [6.7.8].

For compound objects, make handle_list_initializer() pass the
surrounding object's storage duration modifiers down to
handle_simple_initializer() at subobject initializer evaluation.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                  |  25 +++++++++-
 validation/constexpr-init.c | 109 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 133 insertions(+), 1 deletion(-)
 create mode 100644 validation/constexpr-init.c

diff --git a/evaluate.c b/evaluate.c
index c38b893..a65cc0c 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2466,6 +2466,7 @@ static void handle_list_initializer(struct expression *expr,
 {
 	struct expression *e, *last = NULL, *top = NULL, *next;
 	int jumped = 0;
+	unsigned long old_modifiers;
 
 	FOR_EACH_PTR(expr->expr_list, e) {
 		struct expression **v;
@@ -2520,8 +2521,21 @@ found:
 		else
 			v = &top->ident_expression;
 
-		if (handle_simple_initializer(v, 1, lclass, top->ctype))
+		/*
+		 * Temporarily copy storage modifiers down from
+		 * surrounding type such that
+		 * handle_simple_initializer() can check
+		 * initializations of subobjects with static storage
+		 * duration.
+		 */
+		old_modifiers = top->ctype->ctype.modifiers;
+		top->ctype->ctype.modifiers =
+			old_modifiers | (ctype->ctype.modifiers & MOD_STORAGE);
+		if (handle_simple_initializer(v, 1, lclass, top->ctype)) {
+			top->ctype->ctype.modifiers = old_modifiers;
 			continue;
+		}
+		top->ctype->ctype.modifiers = old_modifiers;
 
 		if (!(lclass & TYPE_COMPOUND)) {
 			warning(e->pos, "bogus scalar initializer");
@@ -2631,6 +2645,15 @@ static int handle_simple_initializer(struct expression **ep, int nested,
 		if (!evaluate_expression(e))
 			return 1;
 		compatible_assignment_types(e, ctype, ep, "initializer");
+		/*
+		 * Initializers for static storage duration objects
+		 * shall be constant expressions or a string literal [6.7.8(4)].
+		 */
+		if ((ctype->ctype.modifiers & (MOD_TOPLEVEL | MOD_STATIC)) &&
+			!(e->flags & (EXPR_FLAG_ARITH_CONST_EXPR
+					| EXPR_FLAG_ADDR_CONST_EXPR)))
+			warning(e->pos, "initializer for static storage duration object is not a constant expression");
+
 		return 1;
 	}
 
diff --git a/validation/constexpr-init.c b/validation/constexpr-init.c
new file mode 100644
index 0000000..6c412b8
--- /dev/null
+++ b/validation/constexpr-init.c
@@ -0,0 +1,109 @@
+static int a = 1;					// OK
+static int b[2] = {1, 1};				// OK
+static void c(void) {}
+
+static int *d = &a;					// OK
+static int *e = &b[1];					// OK
+static int *f = b;					// OK
+static void (*g)(void) = c;				// OK
+static void (*h)(void) = &c;				// OK
+static int *i = (int*)0;				// OK
+static int *j = d;					// KO
+static int *k = (int*)0 + 1;				// OK
+
+static int *l = &a + 1;				// OK
+static int *m = &b[1] + 1;				// OK
+static int *n = b + 1;					// OK
+static int *o = d + 1;					// KO
+
+static int *p = &*&a;					// OK
+static int *q = &*&b[1];				// OK
+static int *r = &*b;					// OK
+static int *s = &*d;					// KO
+
+static int *t = &*(&a + 1);				// OK
+static int *u = &*(&b[1] + 1);				// OK
+static int *v = &*(b + 1);				// OK
+static int *w = &*(d + 1);				// KO
+
+
+struct A {
+	int a;
+	int b[2];
+};
+
+struct B {
+	int c;
+	struct A d;
+};
+
+static struct B x= {1, {1, {1, 1}}};				// OK
+static struct B y= {a, {1, {1, 1}}};				// KO
+static struct B z= {1, {a, {1, 1}}};				// KO
+static struct B aa= {1, {1, {a, 1}}};				// KO
+static struct B ab= {1, {1, {1, a}}};				// KO
+static struct B ac= {.c = 1, .d = {.a = 1, .b = {1, 1}}};	// OK
+static struct B ad= {.c = a, .d = {.a = 1, .b = {1, 1}}};	// KO
+static struct B ae= {.c = 1, .d = {.a = a, .b = {1, 1}}};	// KO
+static struct B af= {.c = 1, .d = {.a = 1, .b = {a, 1}}};	// KO
+static struct B ag= {.c = 1, .d = {.a = 1, .b = {1, a}}};	// KO
+
+static int *ah = &x.d.a;		// OK
+static int *ai = &(&x.d)->a;		// OK
+static int *aj = x.d.b;		// OK
+static int *ak = (&x.d)->b;		// OK
+static int *al = &x.d.b[1];		// OK
+static int *am = &(&x.d)->b[1];	// OK
+
+static int an[] = {a, 1};				// KO
+static int ao[] = {1, a};				// KO
+static int ap[] = {[0] = a, [1] = 1};			// KO
+static int aq[] = {[0] = 1, [1] = a};			// KO
+
+static char *ar = "foobar";				// OK
+
+static void as(void) {
+	int a = 0;
+	int b = a;		// OK
+}
+
+static void at(void) {
+	int a = 1;
+	static int b = a;	// KO
+}
+
+static void au(void) {
+	int a = 1;
+	static int *b = &a;	// KO
+}
+
+static void av(void) {
+	static int a = 1;
+	static int *b = &a;	// OK
+}
+
+
+/*
+ * check-name: Static storage object initializer constness verification.
+ *
+ * check-error-start
+constexpr-init.c:11:17: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:17:19: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:22:19: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:27:22: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:41:21: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:42:25: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:43:30: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:44:33: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:46:27: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:47:41: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:48:50: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:49:53: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:58:20: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:59:23: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:60:26: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:61:35: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:72:24: warning: initializer for static storage duration object is not a constant expression
+constexpr-init.c:77:26: warning: initializer for static storage duration object is not a constant expression
+ * check-error-end
+ */
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 08/13] expression: recognize references to labels as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 08/13] expression: recognize references to labels as address constants
Date: Wed, 22 Jul 2015 23:20:04 +0000
Message-ID: <87wpxrixuj.fsf () gmail ! com>
--------------------
As an extension, GCC allows labels to be referenced a la
  label1:
  ...

  void *ptr = &&label1;

Tag these label references as being address constants allowing them
to be used as initializers for objects of static storage duration.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 expression.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/expression.c b/expression.c
index 4d5edc8..19786e8 100644
--- a/expression.c
+++ b/expression.c
@@ -684,6 +684,8 @@ static struct token *unary_expression(struct token *token, struct expression **t
 				sym->ctype.modifiers |= MOD_ADDRESSABLE;
 				add_symbol(&function_computed_target_list, sym);
 			}
+			label->flags |=
+				expr_set_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
 			label->label_symbol = sym;
 			*tree = label;
 			return token->next->next;
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 10/13] symbol: flag builtins constant_p, safe_p and warning as constexprs ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 10/13] symbol: flag builtins constant_p, safe_p and warning as constexprs
Date: Wed, 22 Jul 2015 23:22:09 +0000
Message-ID: <87oaj3ixr2.fsf () gmail ! com>
--------------------
Unconditionally flag the expressions
  __builtin_constant_p(),
  __builtin_safe_p(),
  __builtin_warning()
as being integer constant expressions.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 symbol.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/symbol.c b/symbol.c
index 0ceff62..cbc846b 100644
--- a/symbol.c
+++ b/symbol.c
@@ -642,9 +642,10 @@ struct symbol *create_symbol(int stream, const char *name, int type, int namespa
 	return sym;
 }
 
-static int evaluate_to_integer(struct expression *expr)
+static int evaluate_to_int_const_expr(struct expression *expr)
 {
 	expr->ctype = &int_ctype;
+	expr->flags |= expr_set_flag_mask(EXPR_FLAG_INT_CONST_EXPR);
 	return 1;
 }
 
@@ -749,17 +750,17 @@ out:
 }
 
 static struct symbol_op constant_p_op = {
-	.evaluate = evaluate_to_integer,
+	.evaluate = evaluate_to_int_const_expr,
 	.expand = expand_constant_p
 };
 
 static struct symbol_op safe_p_op = {
-	.evaluate = evaluate_to_integer,
+	.evaluate = evaluate_to_int_const_expr,
 	.expand = expand_safe_p
 };
 
 static struct symbol_op warning_op = {
-	.evaluate = evaluate_to_integer,
+	.evaluate = evaluate_to_int_const_expr,
 	.expand = expand_warning
 };
 
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 12/13] expression, evaluate: support compound literals as address constants ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 12/13] expression, evaluate: support compound literals as address constants
Date: Wed, 22 Jul 2015 23:23:53 +0000
Message-ID: <87fv4fixo6.fsf () gmail ! com>
--------------------
Toplevel compound literals have got static storage duration
[6.5.2.5(6)].

This implies that
1. their addresses are address constants [6.6(9)] and
2. their initializers must contain constant expressions only
   [6.5.2.5(3), 6.7.8(4)] .

Flag the anonymous symbol created at expression parsing time as having
static storage duration if the compound literal occurs at top level
scope.

Flag the whole expression as being an address constant at evaluation
time if its corresponding anonymous symbol had been previously marked
as having static storage duration.

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 evaluate.c                              |  3 +++
 expression.c                            |  2 ++
 validation/constexpr-compound-literal.c | 18 ++++++++++++++++++
 3 files changed, 23 insertions(+)
 create mode 100644 validation/constexpr-compound-literal.c

diff --git a/evaluate.c b/evaluate.c
index ee5f18f..be239ab 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2769,6 +2769,9 @@ static struct symbol *evaluate_cast(struct expression *expr)
 
 		addr->ctype = &lazy_ptr_ctype;	/* Lazy eval */
 		addr->symbol = sym;
+		if (sym->ctype.modifiers & MOD_TOPLEVEL)
+			addr->flags |=
+				expr_set_flag_mask(EXPR_FLAG_ADDR_CONST_EXPR);
 
 		expr->type = EXPR_PREOP;
 		expr->op = '*';
diff --git a/expression.c b/expression.c
index a4b6fa2..4c5cafa 100644
--- a/expression.c
+++ b/expression.c
@@ -715,6 +715,8 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			cast->cast_type = sym;
 			token = expect(token, ')', "at end of cast operator");
 			if (match_op(token, '{')) {
+				if (toplevel(block_scope))
+					sym->ctype.modifiers |= MOD_TOPLEVEL;
 				if (is_force)
 					warning(sym->pos,
 						"[force] in compound literal");
diff --git a/validation/constexpr-compound-literal.c b/validation/constexpr-compound-literal.c
new file mode 100644
index 0000000..6019a18
--- /dev/null
+++ b/validation/constexpr-compound-literal.c
@@ -0,0 +1,18 @@
+static int *a = &(int){ 1 };	// OK
+static int *b = &(int){ *a };	// KO
+
+static void foo(void)
+{
+	int *b = &(int){ 1 };		// OK
+	int *c = &(int){ *a };		// OK
+	static int *d = &(int){ 1 };	// KO
+}
+
+/*
+ * check-name: compound literal address constness verification
+ *
+ * check-error-start
+constexpr-compound-literal.c:2:25: warning: initializer for static storage duration object is not a constant expression
+constexpr-compound-literal.c:8:27: warning: initializer for static storage duration object is not a constant expression
+ * check-error-end
+ */
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC 13/13] symbol: do not inherit storage modifiers from base types at examination ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: [PATCH RFC 13/13] symbol: do not inherit storage modifiers from base types at examination
Date: Wed, 22 Jul 2015 23:24:41 +0000
Message-ID: <87bnf3ixmu.fsf () gmail ! com>
--------------------
Consider the following code snippet:
  static inline foo(int dummy, ...) {}
  static int a = 0;
  static void bar(void)
  {
  	foo(0, a);
  }

Sparse moans:
  test.c:5:9: warning: initializer for static storage duration object
              is not a constant expression

The cause can be tracked down as follows:
The anonymous node created by inline_function() for the variadic
argument will get assigned to its base_type whatever the passed
expression's ctype is. For the special case of a primary expression
referencing a symbol, this ctype is the referenced symbol itself.
Furthermore, inline_function() sets that symbol node's initializer
to this expression.

Now, when the anonymous symbol node is evaluated, its base_type is
handled in examine_base_type(). This applies the base_type's modifiers,
i.e. the referenced symbol's MOD_STATIC in this case, to the inheriting
ctype, that of the anonymous node, itself.
This in turn instructs the evaluation of the symbol's initializer to
allow constant expressions only.

Do not inherit a base_type's storage related modifiers in
examine_base_type().

Signed-off-by: Nicolai Stange <nicstange@gmail.com>
---
 symbol.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/symbol.c b/symbol.c
index cbc846b..605ec1c 100644
--- a/symbol.c
+++ b/symbol.c
@@ -214,7 +214,8 @@ static struct symbol *examine_base_type(struct symbol *sym)
 	if (!base_type || base_type->type == SYM_PTR)
 		return base_type;
 	sym->ctype.as |= base_type->ctype.as;
-	sym->ctype.modifiers |= base_type->ctype.modifiers & MOD_PTRINHERIT;
+	sym->ctype.modifiers |= base_type->ctype.modifiers & MOD_PTRINHERIT &
+		~MOD_STORAGE;
 	concat_ptr_list((struct ptr_list *)base_type->ctype.contexts,
 			(struct ptr_list **)&sym->ctype.contexts);
 	if (base_type->type == SYM_NODE) {
-- 
2.4.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] Avoid reusing string buffer when doing string expansion ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2] Avoid reusing string buffer when doing string expansion
Date: Wed, 04 Feb 2015 02:01:30 +0000
Message-ID: <20150204020059.GA7069 () macpro ! local>
--------------------

In get_string_constant(), the code tried to reuse the storage for the string
but only if the expansion of the string was not bigger than its unexpanded form.
But this string can be shared with other expressions and reusing the buffer will
result in later corruption

A minimal exemple would be something like:
const char a[] = BACKSLASH;
const char b[] = BACKSLASH;

The expansion for 'a' will correctly produce the two-char string consisting
of a backslash char followed by a null char.
But then the expansion of 'b' will expand this once more,
producing the expansion of "\0": the two-char string: { '\0', '\0' }.

The fix is to not reuse the storage for the string if any king of expansion
have been done.

Reported-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 char.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/char.c b/char.c
index 08ca2230..2e21bb77 100644
--- a/char.c
+++ b/char.c
@@ -123,11 +123,15 @@ struct token *get_string_constant(struct token *token, struct expression *expr)
 		len = MAX_STRING;
 	}
 
-	if (len >= string->length)	/* can't cannibalize */
+	/* The input string can be shared with other expression and so
+	 * its storage can't be reused if any kind of expansion have been done on it.
+	 */
+	if ((len != string->length) || memcmp(buffer, string->data, len)) {
 		string = __alloc_string(len+1);
-	string->length = len+1;
-	memcpy(string->data, buffer, len);
-	string->data[len] = '\0';
+		string->length = len+1;
+		memcpy(string->data, buffer, len);
+		string->data[len] = '\0';
+	}
 	expr->string = string;
 	expr->wide = is_wide;
 	return token;
-- 
2.2.0


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v2] Avoid reusing string buffer when doing string expansion
Date: Wed, 04 Feb 2015 05:30:15 +0000
Message-ID: <CANeU7QnYCGWK0LH8+f=bDSbdPHfDvjdRtmUQF5R8j6h9fDBp2g () mail ! gmail ! com>
--------------------
On Tue, Feb 3, 2015 at 6:01 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> In get_string_constant(), the code tried to reuse the storage for the string
> but only if the expansion of the string was not bigger than its unexpanded form.
> But this string can be shared with other expressions and reusing the buffer will
> result in later corruption
>
> A minimal exemple would be something like:
> const char a[] = BACKSLASH;
> const char b[] = BACKSLASH;
>
> The expansion for 'a' will correctly produce the two-char string consisting
> of a backslash char followed by a null char.
> But then the expansion of 'b' will expand this once more,
> producing the expansion of "\0": the two-char string: { '\0', '\0' }.

Are you sure about this behavior? You mean you see "b" has the string
size as 2. I haven't understand how this can happen.

> The fix is to not reuse the storage for the string if any king of expansion
> have been done.

That is a bit over kill. We only need to avoid reuse storage if the
destination part of the string is come from a preprocessor macro.
It is pretty common string contain escape sequence. We don't
want to allocate extra memory copy if it is not part of a macro
expansion.

>
> Reported-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  char.c | 12 ++++++++----
>  1 file changed, 8 insertions(+), 4 deletions(-)
>
> diff --git a/char.c b/char.c
> index 08ca2230..2e21bb77 100644
> --- a/char.c
> +++ b/char.c
> @@ -123,11 +123,15 @@ struct token *get_string_constant(struct token *token, struct expression *expr)
>                 len = MAX_STRING;
>         }
>
> -       if (len >= string->length)      /* can't cannibalize */
> +       /* The input string can be shared with other expression and so
> +        * its storage can't be reused if any kind of expansion have been done on it.
> +        */
> +       if ((len != string->length) || memcmp(buffer, string->data, len)) {

I don' think this check take into account the preprocessor macro has
been used or not. In other words, any general "hello world\n" which
contain the escape character will produce a different buffer, there for,
a new copy of the string. Which is not necessary. That is a pretty
common case.

I am working on patch to address it in the preprocessor macro.
The idea is that just mark the string as immutable if it is part of the
macro expansion. I will see how it goes.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2] Avoid reusing string buffer when doing string expansion
Date: Wed, 04 Feb 2015 06:22:50 +0000
Message-ID: <20150204062250.GA9989 () macbook ! lan>
--------------------
On Tue, Feb 03, 2015 at 09:30:15PM -0800, Christopher Li wrote:
> On Tue, Feb 3, 2015 at 6:01 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > In get_string_constant(), the code tried to reuse the storage for the string
> > but only if the expansion of the string was not bigger than its unexpanded form.
> > But this string can be shared with other expressions and reusing the buffer will
> > result in later corruption
> >
> > A minimal exemple would be something like:
> > const char a[] = BACKSLASH;
> > const char b[] = BACKSLASH;
> >
> > The expansion for 'a' will correctly produce the two-char string consisting
> > of a backslash char followed by a null char.
> > But then the expansion of 'b' will expand this once more,
> > producing the expansion of "\0": the two-char string: { '\0', '\0' }.
> 
> Are you sure about this behavior? You mean you see "b" has the string
> size as 2. I haven't understand how this can happen.

Using the show_data() / sparse -vdata on:
===
#define BACKSLASH "\\"
const char a[] = BACKSLASH;
===

gives, correctly:
===
symbol a:
	char const [addressable] [toplevel] b[0]
	bit_size = 16
	val = "\\"
=== 

But if the macro is used several times:
===
#define BACKSLASH "\\"
const char a[] = BACKSLASH;
const char b[] = BACKSLASH;
const char c[] = "<" BACKSLASH ">";
===

the, we get:
===
symbol a:
	char const [addressable] [toplevel] a[0]
	bit_size = 16
	val = "\0"
symbol b:
	char const [addressable] [toplevel] b[0]
	bit_size = 16
	val = "\0"
symbol c:
	char const [addressable] [toplevel] c[0]
	bit_size = 32
	val = "<\0>"
===

And even worse:
===
#define BACKSLASH "(\\)"
const char m[] = BACKSLASH;
const char n[] = BACKSLASH;
const char k[] = "<" BACKSLASH ">";
===

gives:
===
symbol m:
	char const [addressable] [toplevel] m[0]
	bit_size = 24
	val = "()"
symbol n:
	char const [addressable] [toplevel] n[0]
	bit_size = 24
	val = "()"
symbol k:
	char const [addressable] [toplevel] k[0]
	bit_size = 40
	val = "<()>"
===

> > The fix is to not reuse the storage for the string if any king of expansion
> > have been done.
> 
> That is a bit over kill. We only need to avoid reuse storage if the
> destination part of the string is come from a preprocessor macro.
> It is pretty common string contain escape sequence. We don't
> want to allocate extra memory copy if it is not part of a macro
> expansion.

Well yes ...
Is it only with macros that the string structure is so shared?
And have we a way to test if the string is coming from a macro?

 
> >
> > Reported-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
> > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> > ---
> >  char.c | 12 ++++++++----
> >  1 file changed, 8 insertions(+), 4 deletions(-)
> >
> > diff --git a/char.c b/char.c
> > index 08ca2230..2e21bb77 100644
> > --- a/char.c
> > +++ b/char.c
> > @@ -123,11 +123,15 @@ struct token *get_string_constant(struct token *token, struct expression *expr)
> >                 len = MAX_STRING;
> >         }
> >
> > -       if (len >= string->length)      /* can't cannibalize */
> > +       /* The input string can be shared with other expression and so
> > +        * its storage can't be reused if any kind of expansion have been done on it.
> > +        */
> > +       if ((len != string->length) || memcmp(buffer, string->data, len)) {
> 
> I don' think this check take into account the preprocessor macro has
> been used or not. In other words, any general "hello world\n" which
> contain the escape character will produce a different buffer, there for,
> a new copy of the string. Which is not necessary. That is a pretty
> common case.

No, indeed, it does not.
It just allocate a new buffer every time there is any modification/expansion
so that the original one is not touched (in case it is used elsewhere).

> 
> I am working on patch to address it in the preprocessor macro.
> The idea is that just mark the string as immutable if it is part of the
> macro expansion. I will see how it goes.
> 
> Chris
> --

A simpler and safer way would be to directly do the string expansion just after
a string token is recognized, or even better in the lexer itself.
So the string buffer, macro or not, will always directly contain the right values.
But maybe there was good reasons to not do it this way.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v2] Avoid reusing string buffer when doing string expansion
Date: Wed, 04 Feb 2015 08:01:39 +0000
Message-ID: <CANeU7Q=xw-Hq7Nd+UOGb-EUbQSovzwpx1Zm4pP9XGnS4eaGb2A () mail ! gmail ! com>
--------------------
On Tue, Feb 3, 2015 at 10:22 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> Are you sure about this behavior? You mean you see "b" has the string
>> size as 2. I haven't understand how this can happen.
>
>
> But if the macro is used several times:
> ===
> #define BACKSLASH "\\"
> const char a[] = BACKSLASH;
> const char b[] = BACKSLASH;
> const char c[] = "<" BACKSLASH ">";
> ===
>
> the, we get:
> ===
> symbol a:
>         char const [addressable] [toplevel] a[0]
>         bit_size = 16
>         val = "\0"
> symbol b:
>         char const [addressable] [toplevel] b[0]
>         bit_size = 16

The value buffer is corrupted. But the bit_size is still 16, which
is correct. I just think that in your example it shouldn't corrupt
the size. Your test case seems confirm that.

> Is it only with macros that the string structure is so shared?

That is right. I haven't see it can happen any other way.
The tokenizer always construct new token and string structure
from the C source file.

It is the preprocessor using macro expand which copy and duplicate
the token list. The token has a pointer point to the string which
is shared across different invocation of macro.

> And have we a way to test if the string is coming from a macro?

Not right now. But we can add it.

>
> A simpler and safer way would be to directly do the string expansion just after
> a string token is recognized, or even better in the lexer itself.
> So the string buffer, macro or not, will always directly contain the right values.
> But maybe there was good reasons to not do it this way.

I have an counter example that will not work. Let say

#define b(a, d) a##d
wchar_t s[] = b(L, "\xabcdabc");

When the lexer process the escape char, you did not know the string
is wide char or not. That can be changed after the macro expansion.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2] Avoid reusing string buffer when doing string expansion
Date: Wed, 04 Feb 2015 23:38:03 +0000
Message-ID: <20150204233802.GA2275 () macpro ! local>
--------------------
On Wed, Feb 04, 2015 at 12:01:39AM -0800, Christopher Li wrote:
> On Tue, Feb 3, 2015 at 10:22 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >> Are you sure about this behavior? You mean you see "b" has the string
> >> size as 2. I haven't understand how this can happen.
> >
> >
> > But if the macro is used several times:
> > ===
> > #define BACKSLASH "\\"
> > const char a[] = BACKSLASH;
> > const char b[] = BACKSLASH;
> > const char c[] = "<" BACKSLASH ">";
> > ===
> >
> > the, we get:
> > ===
> > symbol a:
> >         char const [addressable] [toplevel] a[0]
> >         bit_size = 16
> >         val = "\0"
> > symbol b:
> >         char const [addressable] [toplevel] b[0]
> >         bit_size = 16
> 
> The value buffer is corrupted. But the bit_size is still 16, which
> is correct. I just think that in your example it shouldn't corrupt
> the size. Your test case seems confirm that.
> 
> > Is it only with macros that the string structure is so shared?
> 
> That is right. I haven't see it can happen any other way.
> The tokenizer always construct new token and string structure
> from the C source file.
> 
> It is the preprocessor using macro expand which copy and duplicate
> the token list. The token has a pointer point to the string which
> is shared across different invocation of macro.

Fine.
I was affraid that there was other possibilities, like, for exemple,
if the identical string litterals are put in an hash table, like it is done
for identifiers.

> > And have we a way to test if the string is coming from a macro?
> 
> Not right now. But we can add it.
> 
> >
> > A simpler and safer way would be to directly do the string expansion just after
> > a string token is recognized, or even better in the lexer itself.
> > So the string buffer, macro or not, will always directly contain the right values.
> > But maybe there was good reasons to not do it this way.
> 
> I have an counter example that will not work. Let say
> 
> #define b(a, d) a##d
> wchar_t s[] = b(L, "\xabcdabc");
> 
> When the lexer process the escape char, you did not know the string
> is wide char or not. That can be changed after the macro expansion.
> 
> Chris

Yes, I see.

BTW, I've checked and there is a lot of problems with wide strings.
I'll send some test case later.


Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v2] Avoid reusing string buffer when doing string expansion
Date: Fri, 06 Feb 2015 13:58:15 +0000
Message-ID: <CANeU7Q=wp=fCnKaYF+-z+AhrNW5kc+1Uu1=6DgE=9fiapd+VNA () mail ! gmail ! com>
--------------------
On Wed, Feb 4, 2015 at 3:38 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Working perfectly here.
>

Any update of the string test case?

I commit a review version of the immutable string fix in review-immutable-string
branch. Compare to the last patch,  it take into account that string
can come from
macro arguments rather than macro body.

It also avoid the string copy if there is no change, that is pretty
common as well.

Care to give this version a try?

https://git.kernel.org/cgit/devel/sparse/chrisl/sparse.git/commit/?h=review-immutable-string&id=de1fa7e60d3d179a1b67c47a0429b2d0ac4e4842

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rasmus Villemoes <linux () rasmusvillemoes ! dk>
To: linux-sparse
Subject: Re: [PATCH v2] Avoid reusing string buffer when doing string expansion
Date: Fri, 06 Feb 2015 20:32:32 +0000
Message-ID: <878ugapyqn.fsf () rasmusvillemoes ! dk>
--------------------
On Fri, Feb 06 2015, Christopher Li <sparse@chrisli.org> wrote:

> On Wed, Feb 4, 2015 at 3:38 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> Working perfectly here.
>>
>
> Any update of the string test case?
>
> I commit a review version of the immutable string fix in review-immutable-string
> branch. Compare to the last patch,  it take into account that string
> can come from
> macro arguments rather than macro body.
>
> It also avoid the string copy if there is no change, that is pretty
> common as well.
>
> Care to give this version a try?
>
> https://git.kernel.org/cgit/devel/sparse/chrisl/sparse.git/commit/?h=review-immutable-string&id=de1fa7e60d3d179a1b67c47a0429b2d0ac4e4842

Sorry for taking so long to reply. This seems to work for the cases I
can think of, but I haven't put it to the real test yet (whether the
format strings are going to be messed up).

Rasmus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3] dmaengine: xgene-dma: Fix sparse wannings and coccinelle warnings ===

From: Fengguang Wu <fengguang.wu () intel ! com>
To: linux-sparse
Subject: Re: [PATCH v3] dmaengine: xgene-dma: Fix sparse wannings and coccinelle warnings
Date: Mon, 27 Apr 2015 05:20:45 +0000
Message-ID: <20150427052045.GA5199 () wfg-t540p ! sh ! intel ! com>
--------------------
On Mon, Apr 27, 2015 at 08:43:15AM +0530, Vinod Koul wrote:
> On Mon, Apr 20, 2015 at 08:38:18AM +0530, Rameshwar Sahu wrote:
> > Hi Vinod,
> >> >> @@ -2085,6 +2043,5 @@ module_platform_driver(xgene_dma_driver);
> > >>
> > >>  MODULE_DESCRIPTION("APM X-Gene SoC DMA driver");
> > >>  MODULE_AUTHOR("Rameshwar Prasad Sahu <rsahu@apm.com>");
> > >> -MODULE_AUTHOR("Loc Ho <lho@apm.com>");
> > > And why this?
> > 
> > I saw below warning reported by the kbuild robot test
> > 
> > drivers/dma/xgene-dma.c:2088:1: sparse: symbol
> > '__UNIQUE_ID_author__COUNTER__' has multiple initializers (originally
> > initialized at drivers/dma/xgene-dma.c:2087)
> > So, I kept only one author here.
> No that is not right, sparse shouldn't have cribbed here.
> 
> Fengguang can we get the bot to ignore this please

OK, sorry for the noises! CC sparse maintainer btw.

Thanks,
Fengguang
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add a define for __builtin_ms_va_copy() ===

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: [PATCH] Add a define for __builtin_ms_va_copy()
Date: Wed, 11 Mar 2015 23:22:14 +0000
Message-ID: <20150311232214.GB14617 () redhat ! com>
--------------------
Signed-off-by: Michael Stefaniuc <mstefani@redhat.com>
---
Gets rid of the remaining "error: undefined identifier '__builtin_...'"
in Wine.


 lib.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/lib.c b/lib.c
index 58a7f2e..d5b56b0 100644
--- a/lib.c
+++ b/lib.c
@@ -970,6 +970,7 @@ void create_builtin_stream(void)
 	add_pre_buffer("#define __builtin_va_alist (*(void *)0)\n");
 	add_pre_buffer("#define __builtin_va_arg_incr(x) ((x) + 1)\n");
 	add_pre_buffer("#define __builtin_va_copy(dest, src) ({ dest = src; (void)0; })\n");
+	add_pre_buffer("#define __builtin_ms_va_copy(dest, src) ({ dest = src; (void)0; })\n");
 	add_pre_buffer("#define __builtin_va_end(arg)\n");
 	add_pre_buffer("#define __builtin_ms_va_end(arg)\n");
 	add_pre_buffer("#define __builtin_va_arg_pack()\n");
-- 
2.1.0
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Add a define for __builtin_ms_va_copy()
Date: Fri, 13 Mar 2015 17:51:23 +0000
Message-ID: <CANeU7Q=PxbRsFa_WSuA_uLDUCr=VevvCmdREhVmj1fZxVpdxOw () mail ! gmail ! com>
--------------------
On Wed, Mar 11, 2015 at 4:22 PM, Michael Stefaniuc <mstefani@redhat.com> wrote:
> Signed-off-by: Michael Stefaniuc <mstefani@redhat.com>
> ---
> Gets rid of the remaining "error: undefined identifier '__builtin_...'"
> in Wine.


Both patch applied and pushed.

Can you submit some test case while you are there?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add tests for the builtin INF and nan() functions. ===

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: [PATCH] Add tests for the builtin INF and nan() functions.
Date: Wed, 08 Apr 2015 21:48:39 +0000
Message-ID: <20150408214839.GA24502 () redhat ! com>
--------------------
Test file cross checked with
gcc -c -Wall -Werror -Wno-unused-variable validation/builtin_inf.c

Signed-off-by: Michael Stefaniuc <mstefani@redhat.com>
---
Sorry for the delay.


 validation/builtin_inf.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)
 create mode 100644 validation/builtin_inf.c

diff --git a/validation/builtin_inf.c b/validation/builtin_inf.c
new file mode 100644
index 0000000..48546e4
--- /dev/null
+++ b/validation/builtin_inf.c
@@ -0,0 +1,13 @@
+static double d = __builtin_huge_val();
+static float f = __builtin_huge_valf();
+static long double l = __builtin_huge_vall();
+static double di = __builtin_inf();
+static float fi = __builtin_inff();
+static long double li = __builtin_infl();
+static double dn = __builtin_nan("");
+static float fn = __builtin_nanf("");
+static long double ln = __builtin_nanl("");
+
+/*
+ * check-name: __builtin INFINITY / nan()
+ */
-- 
2.1.0
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add the __builtin functions needed for INFINITY and nan(). ===

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: [PATCH] Add the __builtin functions needed for INFINITY and nan().
Date: Wed, 11 Mar 2015 23:19:19 +0000
Message-ID: <20150311231919.GA14617 () redhat ! com>
--------------------
Signed-off-by: Michael Stefaniuc <mstefani@redhat.com>
---
Needed for Wine. Not all of those but have added them for completeness.


 lib.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/lib.c b/lib.c
index 8dc5bcf..58a7f2e 100644
--- a/lib.c
+++ b/lib.c
@@ -876,6 +876,17 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern int __builtin_islessgreater(float, float);\n");
 	add_pre_buffer("extern int __builtin_isunordered(float, float);\n");
 
+	/* And some INFINITY / NAN stuff.. */
+	add_pre_buffer("extern double __builtin_huge_val(void);\n");
+	add_pre_buffer("extern float __builtin_huge_valf(void);\n");
+	add_pre_buffer("extern long double __builtin_huge_vall(void);\n");
+	add_pre_buffer("extern double __builtin_inf(void);\n");
+	add_pre_buffer("extern float __builtin_inff(void);\n");
+	add_pre_buffer("extern long double __builtin_infl(void);\n");
+	add_pre_buffer("extern double __builtin_nan(const char *);\n");
+	add_pre_buffer("extern float __builtin_nanf(const char *);\n");
+	add_pre_buffer("extern long double __builtin_nanl(const char *);\n");
+
 	/* And some __FORTIFY_SOURCE ones.. */
 	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(void *, int);\n");
 	add_pre_buffer ("extern void * __builtin___memcpy_chk(void *, const void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
-- 
2.1.0
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Sat, 31 Jan 2015 01:23:40 +0000
Message-ID: <20150131012339.GA3460 () macpro ! local>
--------------------
In get_string_constant(), the code tried to reuse the storage for the string
but only if the expansion of the string was not bigger than its unexpanded form.
But this fail when the string constant is a sequence of adjacent string litterals
(each being possibly shared, used elsewhere, isolated or in another order).
The minimal exemple would be something like this:

#define P "\001"
const char a[] = P "a";
const char b[] = P "b";

The expansion for 'a' will produce a string which is smaller than
the unexpanded "\001" (2 instead of 4).
By trying to reuse the storage, all further occurrence of "\001"
(probably only from the same 'origin', here the macro P) will then be replaced by "\001a".

The fix is thus to not try to reuse the storage for the string if it consit of
several adjacent litterals.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 char.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/char.c b/char.c
index 08ca2230..ce1a0700 100644
--- a/char.c
+++ b/char.c
@@ -93,6 +93,7 @@ struct token *get_string_constant(struct token *token, struct expression *expr)
 	static char buffer[MAX_STRING];
 	int len = 0;
 	int bits;
+	int parts = 0;
 
 	while (!done) {
 		switch (token_type(next)) {
@@ -117,13 +118,14 @@ struct token *get_string_constant(struct token *token, struct expression *expr)
 			len++;
 		}
 		token = token->next;
+		parts++;
 	}
 	if (len > MAX_STRING) {
 		warning(token->pos, "trying to concatenate %d-character string (%d bytes max)", len, MAX_STRING);
 		len = MAX_STRING;
 	}
 
-	if (len >= string->length)	/* can't cannibalize */
+	if (len >= string->length || parts > 1)	/* safe to reuse the string buffer */
 		string = __alloc_string(len+1);
 	string->length = len+1;
 	memcpy(string->data, buffer, len);
-- 
2.2.2


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Sat, 31 Jan 2015 01:23:40 +0000
Message-ID: <20150131012339.GA3460 () macpro ! local>
--------------------
In get_string_constant(), the code tried to reuse the storage for the string
but only if the expansion of the string was not bigger than its unexpanded form.
But this fail when the string constant is a sequence of adjacent string litterals
(each being possibly shared, used elsewhere, isolated or in another order).
The minimal exemple would be something like this:

#define P "\001"
const char a[] = P "a";
const char b[] = P "b";

The expansion for 'a' will produce a string which is smaller than
the unexpanded "\001" (2 instead of 4).
By trying to reuse the storage, all further occurrence of "\001"
(probably only from the same 'origin', here the macro P) will then be replaced by "\001a".

The fix is thus to not try to reuse the storage for the string if it consit of
several adjacent litterals.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 char.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/char.c b/char.c
index 08ca2230..ce1a0700 100644
--- a/char.c
+++ b/char.c
@@ -93,6 +93,7 @@ struct token *get_string_constant(struct token *token, struct expression *expr)
 	static char buffer[MAX_STRING];
 	int len = 0;
 	int bits;
+	int parts = 0;
 
 	while (!done) {
 		switch (token_type(next)) {
@@ -117,13 +118,14 @@ struct token *get_string_constant(struct token *token, struct expression *expr)
 			len++;
 		}
 		token = token->next;
+		parts++;
 	}
 	if (len > MAX_STRING) {
 		warning(token->pos, "trying to concatenate %d-character string (%d bytes max)", len, MAX_STRING);
 		len = MAX_STRING;
 	}
 
-	if (len >= string->length)	/* can't cannibalize */
+	if (len >= string->length || parts > 1)	/* safe to reuse the string buffer */
 		string = __alloc_string(len+1);
 	string->length = len+1;
 	memcpy(string->data, buffer, len);
-- 
2.2.2


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Wed, 04 Feb 2015 00:32:08 +0000
Message-ID: <20150204003208.GA8867 () macbook ! lan>
--------------------
On Tue, Feb 03, 2015 at 11:38:02PM +0100, Rasmus Villemoes wrote:
> On Sat, Jan 31 2015, Luc Van Oostenryck <luc.vanoostenryck@gmail.com> wrote:
> 
> > In get_string_constant(), the code tried to reuse the storage for the string
> > but only if the expansion of the string was not bigger than its unexpanded form.
> > But this fail when the string constant is a sequence of adjacent string litterals
> > (each being possibly shared, used elsewhere, isolated or in another order).
> > The minimal exemple would be something like this:
> >
> > #define P "\001"
> > const char a[] = P "a";
> > const char b[] = P "b";
> >
> > The expansion for 'a' will produce a string which is smaller than
> > the unexpanded "\001" (2 instead of 4).
> > By trying to reuse the storage, all further occurrence of "\001"
> > (probably only from the same 'origin', here the macro P) will then be replaced by "\001a".
> >
> > The fix is thus to not try to reuse the storage for the string if it consit of
> > several adjacent litterals.
> >
> 
> Thanks, but there's still something wrong. Using your show-data feature
> on this:
> 
> ===
> #define BACKSLASH "\\"
> #define LETTER_t "t"
> 
> static const char s1[] = BACKSLASH;
> /* static const char s2[] = BACKSLASH; */
> static const char s3[] = BACKSLASH LETTER_t;
> static const char s4[] = "a" BACKSLASH LETTER_t "b";
> ===
> 
> I get
> 
> symbol s1:
>         char static const [toplevel] s1[0]
>         bit_size = 16
>         val = "\\"
> symbol s3:
>         char static const [toplevel] s3[0]
>         bit_size = 24
>         val = "\0t"
> symbol s4:
>         char static const [toplevel] s4[0]
>         bit_size = 40
>         val = "a\0tb"
> 
> Now if I do the same with s2 not commented out, I get
> 
> 
> symbol s1:
>         char static const [toplevel] s1[0]
>         bit_size = 16
>         val = "\0"
> symbol s2:
>         char static const [toplevel] s2[0]
>         bit_size = 16
>         val = "\0"
> symbol s3:
>         char static const [toplevel] s3[0]
>         bit_size = 24
>         val = "\0t"
> symbol s4:
>         char static const [toplevel] s4[0]
>         bit_size = 40
>         val = "a\0tb"
> 
> So the expansion of BACKSLASH changes depending on how often it is
> expanded...
> 
> The LETTER_t thing above is because I thought I had somehow provoked a
> double expansion, making BACKSLASH LETTER_t (or some variant) expand to
> a single-character string containing just a tab. But I can't seem to
> reproduce that particular behaviour, so maybe I'm imagining
> stuff. Anyway, the above is certainly real.
> 
> Thanks,
> Rasmus
> --
Yes, I see.

Now thinking about it, it's obvious that the string buffer can't be reused at all
if there is any kind of expansion done on it, the adjacent strings concatenation
make just the thing worse but are not the cause of it.

I'll post an updated patch later.


Regards,
Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rasmus Villemoes <linux () rasmusvillemoes ! dk>
To: linux-sparse
Subject: Re: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Wed, 04 Feb 2015 08:39:08 +0000
Message-ID: <87r3u6ax5f.fsf () rasmusvillemoes ! dk>
--------------------
On Wed, Feb 04 2015, Luc Van Oostenryck <luc.vanoostenryck@gmail.com> wrote:

> On Tue, Feb 03, 2015 at 11:38:02PM +0100, Rasmus Villemoes wrote:
>> 
>> Thanks, but there's still something wrong. Using your show-data feature
>> on this:
>> 
>> ===
>> #define BACKSLASH "\\"
>> #define LETTER_t "t"
>> 
>> static const char s1[] = BACKSLASH;
>> /* static const char s2[] = BACKSLASH; */
>> static const char s3[] = BACKSLASH LETTER_t;
>> static const char s4[] = "a" BACKSLASH LETTER_t "b";
>> ===
>> 
>> I get
>> 
>> symbol s1:
>>         char static const [toplevel] s1[0]
>>         bit_size = 16
>>         val = "\\"
>> symbol s3:
>>         char static const [toplevel] s3[0]
>>         bit_size = 24
>>         val = "\0t"
>> symbol s4:
>>         char static const [toplevel] s4[0]
>>         bit_size = 40
>>         val = "a\0tb"
>> 
>> Now if I do the same with s2 not commented out, I get
>> 
>> 
>> symbol s1:
>>         char static const [toplevel] s1[0]
>>         bit_size = 16
>>         val = "\0"
>> symbol s2:
>>         char static const [toplevel] s2[0]
>>         bit_size = 16
>>         val = "\0"
>> symbol s3:
>>         char static const [toplevel] s3[0]
>>         bit_size = 24
>>         val = "\0t"
>> symbol s4:
>>         char static const [toplevel] s4[0]
>>         bit_size = 40
>>         val = "a\0tb"
>> 
>> So the expansion of BACKSLASH changes depending on how often it is
>> expanded...
>> 
>> The LETTER_t thing above is because I thought I had somehow provoked a
>> double expansion, making BACKSLASH LETTER_t (or some variant) expand to
>> a single-character string containing just a tab. But I can't seem to
>> reproduce that particular behaviour, so maybe I'm imagining
>> stuff. Anyway, the above is certainly real.
>> 
>> Thanks,
>> Rasmus
>> --
> Yes, I see.
>
> Now thinking about it, it's obvious that the string buffer can't be reused at all
> if there is any kind of expansion done on it, the adjacent strings concatenation
> make just the thing worse but are not the cause of it.
>

That was also my conclusion from looking at the code, but I was unable
to do anything about it. And I wasn't hallucinating, I was just
overcomplicating things:

#define NOT_TAB "\\t"

static const char s1[] = NOT_TAB;
static const char s2[] = NOT_TAB;

indeed fails.

Thanks,
Rasmus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Wed, 04 Feb 2015 16:20:58 +0000
Message-ID: <CANeU7QmHRFMhYeeyQm=8MYs=C1B=qo8vn8DN=4zUPo8j8rZUow () mail ! gmail ! com>
--------------------
On Wed, Feb 4, 2015 at 12:58 AM, Rasmus Villemoes
<linux@rasmusvillemoes.dk> wrote:
> On Wed, Feb 04 2015, Rasmus Villemoes <linux@rasmusvillemoes.dk> wrote:
>
>> And I wasn't hallucinating, I was just overcomplicating things:
>>
>> #define NOT_TAB "\\t"
>>
>> static const char s1[] = NOT_TAB;
>> static const char s2[] = NOT_TAB;
>>
>> indeed fails.
>
> While we're collecting examples, let me also mention that __FILE__
> doesn't work for files with backslash in their name. Sane people of
> course don't put backslashes in file names, but they are a rather normal
> occurence in path names on a certain operating system.

Can you submit a patch for adding the test case you found?
I will include those into the the test suit.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rasmus Villemoes <linux () rasmusvillemoes ! dk>
To: linux-sparse
Subject: Re: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Fri, 06 Feb 2015 21:52:43 +0000
Message-ID: <874mqypv10.fsf () rasmusvillemoes ! dk>
--------------------
On Wed, Feb 04 2015, Christopher Li <sparse@chrisli.org> wrote:

> On Wed, Feb 4, 2015 at 12:58 AM, Rasmus Villemoes
> <linux@rasmusvillemoes.dk> wrote:
>> On Wed, Feb 04 2015, Rasmus Villemoes <linux@rasmusvillemoes.dk> wrote:
>>
>>> And I wasn't hallucinating, I was just overcomplicating things:
>>>
>>> #define NOT_TAB "\\t"
>>>
>>> static const char s1[] = NOT_TAB;
>>> static const char s2[] = NOT_TAB;
>>>
>>> indeed fails.
>>
>> While we're collecting examples, let me also mention that __FILE__
>> doesn't work for files with backslash in their name. Sane people of
>> course don't put backslashes in file names, but they are a rather normal
>> occurence in path names on a certain operating system.
>
> Can you submit a patch for adding the test case you found?
> I will include those into the the test suit.

I'd like to, but I'm not sure how to write the test in terms of sparse's
test frame work. How do I check that the string is as expected? 

Rasmus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Sat, 07 Feb 2015 01:30:50 +0000
Message-ID: <CANeU7QniCPHPqvJe=xnA7yAUADm_3Z8oZLtNtoejgAfv-kcdBQ () mail ! gmail ! com>
--------------------
On Fri, Feb 6, 2015 at 1:52 PM, Rasmus Villemoes
<linux@rasmusvillemoes.dk> wrote:
>> Can you submit a patch for adding the test case you found?
>> I will include those into the the test suit.
>
> I'd like to, but I'm not sure how to write the test in terms of sparse's
> test frame work. How do I check that the string is as expected?

You can use ./test-parsing to evaluate the test file.
$ cat /tmp/v.c
#define BACKSLASH "\\"
static const char a[] = BACKSLASH "a";
static const char b[] = BACKSLASH "b";

# on current master branch it shows:
$ ./test-parsing /tmp/v.c
.align 1
char static const [toplevel] a[0]
 =
    movi.64        v2,&"\7b"
    ld.24        v3,[v2]
,
.align 1
char static const [toplevel] b[0]
 =
    movi.64        v5,&"\7b"
    ld.24        v6,[v5]


# on the review-immutable-string branch it shows:
$ ./test-parsing /tmp/v.c

.align 1
char static const [toplevel] a[0]
 =
    movi.64        v2,&"\\a"
    ld.24        v3,[v2]
,
.align 1
char static const [toplevel] b[0]
 =
    movi.64        v5,&"\\b"
    ld.24        v6,[v5]


Notice that "\\a" and "\\b" was not there before the
bug was fixed.

The test suit is just some C file in the "validations" directory.
Each file has a test name and optional how to invoke the C file
and what to expect from the running result.
You should able to find some example in the test suit.
Or, you can just submit a patch to include those C file
in the "validations" directory. Let some one help you complete
the test suit.

You run the test suit as:

make check


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Damien Lespiau <damien.lespiau () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Avoid reuse of string buffer when concatening adjacent string litterals
Date: Mon, 09 Feb 2015 21:48:52 +0000
Message-ID: <CAGrt=7hURQi_h823pZ-cXCbqdwDkFQSA1QDuduXCt=oaZaeDdA () mail ! gmail ! com>
--------------------
On 7 February 2015 at 01:30, Christopher Li <sparse@chrisli.org> wrote:
> On Fri, Feb 6, 2015 at 1:52 PM, Rasmus Villemoes
> <linux@rasmusvillemoes.dk> wrote:
>>> Can you submit a patch for adding the test case you found?
>>> I will include those into the the test suit.
>>
>> I'd like to, but I'm not sure how to write the test in terms of sparse's
>> test frame work. How do I check that the string is as expected?
>
> You can use ./test-parsing to evaluate the test file.

There's even a bit of documentation!

http://git.kernel.org/cgit/devel/sparse/sparse.git/tree/Documentation/test-suite

-- 
Damien
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix context checking detection of a reversed lock-pair within a basic block ===

From: David Holmer <odinguru () gmail ! com>
To: linux-sparse
Subject: [PATCH] Fix context checking detection of a reversed lock-pair within a basic block
Date: Tue, 17 Nov 2015 17:17:58 +0000
Message-ID: <1447780678-7431-1-git-send-email-odinguru () gmail ! com>
--------------------
This commit adds a new validation test case with a simple lock context
issue that was not previously caught by sparse. This test case is a simple
"reversed" lock pair (unlock/lock instead of lock/unlock):
+static void warn_reverse(void)
+{
+    r();
+    a();
+}

Previously, sparse would not flag this context imbalance because it happens
WITHIN a single basic block and imbalance checking was only done at the
boundaries of basic blocks. In this case, the lock following the unlock
results in a net context change of zero for this basic block, so checking
only at the boundaries of basic blocks is insufficient.

Primarily, this commit moves the checking for "unexpected unlock" inside
the context_increase function where it can correctly detect the new test
case as well as all other existing test cases.

In order to accommodate the primary change, some additional ancillary
changes are made:
* The entry point is added as an argument to context_increase() so that it
  can be passed to imbalance() if needed.
* The two arguments entry and exit are removed from imbalance() as they are
  currently unused in the function and it simplifies calling it in the new
  location (all call sites of imbalance() are changed).
* A prototype for imbalance() is added at top of the file as a call is now
  made before the function is defined.

Signed-off-by: David Holmer <odinguru@gmail.com>
---
 sparse.c             | 19 ++++++++++++-------
 validation/context.c |  8 ++++++++
 2 files changed, 20 insertions(+), 7 deletions(-)

diff --git a/sparse.c b/sparse.c
index 6b3324c..85b92e9 100644
--- a/sparse.c
+++ b/sparse.c
@@ -40,7 +40,9 @@
 #include "expression.h"
 #include "linearize.h"
 
-static int context_increase(struct basic_block *bb, int entry)
+static int imbalance(struct entrypoint *ep, struct basic_block *bb, const char *why);
+
+static int context_increase(struct entrypoint *ep, struct basic_block *bb, int entry)
 {
 	int sum = 0;
 	struct instruction *insn;
@@ -61,11 +63,15 @@ static int context_increase(struct basic_block *bb, int entry)
 			continue;
 		}
 		sum += val;
+		if (entry + sum < 0) {
+			imbalance(ep, bb, "unexpected unlock");
+			return sum;
+		}
 	} END_FOR_EACH_PTR(insn);
 	return sum;
 }
 
-static int imbalance(struct entrypoint *ep, struct basic_block *bb, int entry, int exit, const char *why)
+static int imbalance(struct entrypoint *ep, struct basic_block *bb, const char *why)
 {
 	if (Wcontext) {
 		struct symbol *sym = ep->name;
@@ -85,7 +91,7 @@ static int check_children(struct entrypoint *ep, struct basic_block *bb, int ent
 	if (!insn)
 		return 0;
 	if (insn->opcode == OP_RET)
-		return entry != exit ? imbalance(ep, bb, entry, exit, "wrong count at exit") : 0;
+		return entry != exit ? imbalance(ep, bb, "wrong count at exit") : 0;
 
 	FOR_EACH_PTR(bb->children, child) {
 		if (check_bb_context(ep, child, entry, exit))
@@ -103,12 +109,11 @@ static int check_bb_context(struct entrypoint *ep, struct basic_block *bb, int e
 
 	/* Now that's not good.. */
 	if (bb->context >= 0)
-		return imbalance(ep, bb, entry, bb->context, "different lock contexts for basic block");
+		return imbalance(ep, bb, "different lock contexts for basic block");
 
 	bb->context = entry;
-	entry += context_increase(bb, entry);
-	if (entry < 0)
-		return imbalance(ep, bb, entry, exit, "unexpected unlock");
+	entry += context_increase(ep, bb, entry);
+	if (entry < 0) return -1;
 
 	return check_children(ep, bb, entry, exit);
 }
diff --git a/validation/context.c b/validation/context.c
index 33b70b8..c0a5357 100644
--- a/validation/context.c
+++ b/validation/context.c
@@ -314,6 +314,13 @@ static void warn_cond_lock1(void)
         condition2 = 1; /* do stuff */
     r();
 }
+
+static void warn_reverse(void)
+{
+    r();
+    a();
+}
+
 /*
  * check-name: Check -Wcontext
  *
@@ -332,5 +339,6 @@ context.c:274:13: warning: context imbalance in 'warn_goto1' - wrong count at ex
 context.c:283:13: warning: context imbalance in 'warn_goto2' - wrong count at exit
 context.c:300:5: warning: context imbalance in 'warn_goto3' - different lock contexts for basic block
 context.c:315:5: warning: context imbalance in 'warn_cond_lock1' - different lock contexts for basic block
+context.c:318:13: warning: context imbalance in 'warn_reverse' - unexpected unlock
  * check-error-end
  */
-- 
1.9.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Support __COUNTER__ macro ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: [PATCH] Support __COUNTER__ macro
Date: Fri, 23 Jan 2015 22:26:44 +0000
Message-ID: <20150123222644.GA691 () ravnborg ! org>
--------------------
OUNTER__ macro is expanded to a sequential number starting from 0.
This is sometimes used to declare unique variable names.

Implement support for __COUNTER__ in sparse including a
small test program for the test suite.

Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
---

I had hit this before - and then I saw a mil about it today.
So took a quick look at it.
It seems to work as expected.

 ident-list.h                             |  1 +
 pre-process.c                            |  3 +++
 validation/preprocessor/preprocessor24.c | 20 ++++++++++++++++++++
 3 files changed, 24 insertions(+)
 create mode 100644 validation/preprocessor/preprocessor24.c

diff --git a/ident-list.h b/ident-list.h
index d5a145f..98e1764 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -108,6 +108,7 @@ __IDENT(__TIME___ident, "__TIME__", 0);
 __IDENT(__func___ident, "__func__", 0);
 __IDENT(__FUNCTION___ident, "__FUNCTION__", 0);
 __IDENT(__PRETTY_FUNCTION___ident, "__PRETTY_FUNCTION__", 0);
+__IDENT(__COUNTER__ident, "__COUNTER__", 0);
 
 /* Sparse commands */
 IDENT_RESERVED(__context__);
diff --git a/pre-process.c b/pre-process.c
index 1aa3d2c..67cc81f 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -181,6 +181,9 @@ static int expand_one_symbol(struct token **list)
 			time(&t);
 		strftime(buffer, 9, "%T", localtime(&t));
 		replace_with_string(token, buffer);
+	} else if (token->ident == &__COUNTER__ident) {
+		static int counter = 0;
+		replace_with_integer(token, counter++);
 	}
 	return 1;
 }
diff --git a/validation/preprocessor/preprocessor24.c b/validation/preprocessor/preprocessor24.c
new file mode 100644
index 0000000..381b823
--- /dev/null
+++ b/validation/preprocessor/preprocessor24.c
@@ -0,0 +1,20 @@
+#define DO_CONCAT(a, b) a##b
+#define CONCAT(a, b) DO_CONCAT(a, b)
+#define VARNAME(name) CONCAT(name, __COUNTER__)
+
+int VARNAME(x);
+int VARNAME(x);
+
+/*
+ * check-name: Preprocessor #24 __COUNTER__
+ * check-command: sparse -E $file
+ *
+ * check-output-start
+
+int x0;
+int x1;
+* check-output-end
+ *
+ * check-error-start
+ * check-error-end
+ */
-- 
1.9.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: josh () joshtriplett ! org
To: linux-sparse
Subject: Re: [PATCH] Support __COUNTER__ macro
Date: Fri, 23 Jan 2015 22:39:41 +0000
Message-ID: <20150123223941.GC1489 () cloud>
--------------------
On Fri, Jan 23, 2015 at 11:26:44PM +0100, Sam Ravnborg wrote:
> +	} else if (token->ident == &__COUNTER__ident) {
> +		static int counter = 0;
> +		replace_with_integer(token, counter++);

Same comment as with the other version of this patch: this shouldn't use
a static counter, because it needs to reset for each top-level source
file.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Teach sparse about the __COUNTER__ predefined macro ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Fri, 23 Jan 2015 22:23:32 +0000
Message-ID: <20150123222332.GB42179 () macpro ! local>
--------------------
On Fri, Jan 23, 2015 at 08:40:17AM -0800, Christopher Li wrote:
> On Thu, Jan 22, 2015 at 12:31 PM, Christian Borntraeger
> <borntraeger@de.ibm.com> wrote:
> > Linus, Christopher,
> >
> > Commit  0f25c6a78e08fdc15af5e599d836fa24349c042f ("Add warning about duplicate initializers") has a false positive on arch/s390/kvm/kvm-s390.c
> >
> >   CHECK   arch/s390/kvm/kvm-s390.c
> > arch/s390/kvm/kvm-s390.c:1823:1: error: symbol '__UNIQUE_ID_alias__COUNTER__' has multiple initializers (originally initialized at arch/s390/kvm/kvm-s390.c:1822)
> 
> Search the "__COUNTER__" macro shows that:
> https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
> 
> __COUNTER__This macro expands to sequential integral values starting
> from 0. In conjunction with the ## operator, this provides a
> convenient means to generate unique identifiers. Care must be taken to
> ensure that __COUNTER__ is not expanded prior to inclusion of
> precompiled headers which use it. Otherwise, the precompiled headers
> will not be used.
> 
> I think sparse haven't implement the __COUNTER__ macro. That is why it emit the
> error on duplicate entry.
> 
> Chris
> --


The following patch should fix that.


Luc


Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 ident-list.h                          |  1 +
 pre-process.c                         |  4 ++++
 validation/preprocessor/__COUNTER__.c | 12 ++++++++++++
 3 files changed, 17 insertions(+)
 create mode 100644 validation/preprocessor/__COUNTER__.c

diff --git a/ident-list.h b/ident-list.h
index d5a145f8..b65b667d 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -108,6 +108,7 @@ __IDENT(__TIME___ident, "__TIME__", 0);
 __IDENT(__func___ident, "__func__", 0);
 __IDENT(__FUNCTION___ident, "__FUNCTION__", 0);
 __IDENT(__PRETTY_FUNCTION___ident, "__PRETTY_FUNCTION__", 0);
+__IDENT(__COUNTER___ident, "__COUNTER__", 0);
 
 /* Sparse commands */
 IDENT_RESERVED(__context__);
diff --git a/pre-process.c b/pre-process.c
index 1aa3d2c4..316247ac 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -181,6 +181,10 @@ static int expand_one_symbol(struct token **list)
 			time(&t);
 		strftime(buffer, 9, "%T", localtime(&t));
 		replace_with_string(token, buffer);
+	} else if (token->ident == &__COUNTER___ident) {
+		static int counter;
+
+		replace_with_integer(token, counter++);
 	}
 	return 1;
 }
diff --git a/validation/preprocessor/__COUNTER__.c b/validation/preprocessor/__COUNTER__.c
new file mode 100644
index 00000000..98187ee6
--- /dev/null
+++ b/validation/preprocessor/__COUNTER__.c
@@ -0,0 +1,12 @@
+__COUNTER__
+__COUNTER__
+/*
+ * check-name: __COUNTER__ #1
+ * check-command: sparse -E $file
+ *
+ * check-output-start
+
+0
+1
+ * check-output-end
+ */
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Fri, 23 Jan 2015 22:28:16 +0000
Message-ID: <20150123222816.GB691 () ravnborg ! org>
--------------------
On Fri, Jan 23, 2015 at 11:23:32PM +0100, Luc Van Oostenryck wrote:
> On Fri, Jan 23, 2015 at 08:40:17AM -0800, Christopher Li wrote:
> > On Thu, Jan 22, 2015 at 12:31 PM, Christian Borntraeger
> > <borntraeger@de.ibm.com> wrote:
> > > Linus, Christopher,
> > >
> > > Commit  0f25c6a78e08fdc15af5e599d836fa24349c042f ("Add warning about duplicate initializers") has a false positive on arch/s390/kvm/kvm-s390.c
> > >
> > >   CHECK   arch/s390/kvm/kvm-s390.c
> > > arch/s390/kvm/kvm-s390.c:1823:1: error: symbol '__UNIQUE_ID_alias__COUNTER__' has multiple initializers (originally initialized at arch/s390/kvm/kvm-s390.c:1822)
> > 
> > Search the "__COUNTER__" macro shows that:
> > https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
> > 
> > __COUNTER__This macro expands to sequential integral values starting
> > from 0. In conjunction with the ## operator, this provides a
> > convenient means to generate unique identifiers. Care must be taken to
> > ensure that __COUNTER__ is not expanded prior to inclusion of
> > precompiled headers which use it. Otherwise, the precompiled headers
> > will not be used.
> > 
> > I think sparse haven't implement the __COUNTER__ macro. That is why it emit the
> > error on duplicate entry.
> > 
> > Chris
> > --
> 
> 
> The following patch should fix that.

Seems we were working on this in parallel :-)
> 
> 
> Luc
> 
> 
> Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Acked-by: Sam Ravnborg <sam@ravnborg.org>

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Fri, 23 Jan 2015 23:59:35 +0000
Message-ID: <20150123235934.GA42931 () macpro ! local>
--------------------
On Fri, Jan 23, 2015 at 02:38:56PM -0800, josh@joshtriplett.org wrote:
> On Fri, Jan 23, 2015 at 11:23:32PM +0100, Luc Van Oostenryck wrote:
> > On Fri, Jan 23, 2015 at 08:40:17AM -0800, Christopher Li wrote:
> > > I think sparse haven't implement the __COUNTER__ macro. That is why it emit the
> > > error on duplicate entry.
> > 
> > The following patch should fix that.
> [...]
> > Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.
> > 
> > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> 
> One issue below.
> 
> > --- a/pre-process.c
> > +++ b/pre-process.c
> > @@ -181,6 +181,10 @@ static int expand_one_symbol(struct token **list)
> >  			time(&t);
> >  		strftime(buffer, 9, "%T", localtime(&t));
> >  		replace_with_string(token, buffer);
> > +	} else if (token->ident == &__COUNTER___ident) {
> > +		static int counter;
> > +
> > +		replace_with_integer(token, counter++);
> 
> This should not use a static counter.  GCC and Sparse can run over more
> than one file in one invocation:
> 
> $ head test1.c test2.c
> ==> test1.c <==
> __COUNTER__
> __COUNTER__
> 
> ==> test2.c <==
> __COUNTER__
> __COUNTER__
> 
> $ gcc -E test1.c test2.c
> # 1 "test1.c"
> # 1 "<built-in>"
> # 1 "<command-line>"
> # 1 "/usr/include/stdc-predef.h" 1 3 4
> # 1 "<command-line>" 2
> # 1 "test1.c"
> 0
> 1
> # 1 "test2.c"
> # 1 "<built-in>"
> # 1 "<command-line>"
> # 1 "/usr/include/stdc-predef.h" 1 3 4
> # 1 "<command-line>" 2
> # 1 "test2.c"
> 0
> 1
> 
> Notice that the second file starts with __COUNTER__ at 0 again.
> 
> The counter *should* keep counting through include files, but needs to
> reset before starting a new top-level compile.
> 
> - Josh Triplett
> --

Yes, indeed.
Thanks for bringing to my attention.

Here is a new version of the patch taking care of that.


Luc

---
Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.

This macro expands to sequential integral values starting from 0,
and this for each top-level source file.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 ident-list.h                       |  1 +
 pre-process.c                      |  4 ++++
 validation/preprocessor/counter1.c | 12 ++++++++++++
 validation/preprocessor/counter2.c | 14 ++++++++++++++
 validation/preprocessor/counter2.h |  1 +
 validation/preprocessor/counter3.c | 13 +++++++++++++
 6 files changed, 45 insertions(+)
 create mode 100644 validation/preprocessor/counter1.c
 create mode 100644 validation/preprocessor/counter2.c
 create mode 100644 validation/preprocessor/counter2.h
 create mode 100644 validation/preprocessor/counter3.c

diff --git a/ident-list.h b/ident-list.h
index d5a145f8..b65b667d 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -108,6 +108,7 @@ __IDENT(__TIME___ident, "__TIME__", 0);
 __IDENT(__func___ident, "__func__", 0);
 __IDENT(__FUNCTION___ident, "__FUNCTION__", 0);
 __IDENT(__PRETTY_FUNCTION___ident, "__PRETTY_FUNCTION__", 0);
+__IDENT(__COUNTER___ident, "__COUNTER__", 0);
 
 /* Sparse commands */
 IDENT_RESERVED(__context__);
diff --git a/pre-process.c b/pre-process.c
index 1aa3d2c4..601e0f26 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -45,6 +45,7 @@
 #include "scope.h"
 
 static int false_nesting = 0;
+static int counter_macro;		// __COUNTER__ expansion
 
 #define INCLUDEPATHS 300
 const char *includepath[INCLUDEPATHS+1] = {
@@ -181,6 +182,8 @@ static int expand_one_symbol(struct token **list)
 			time(&t);
 		strftime(buffer, 9, "%T", localtime(&t));
 		replace_with_string(token, buffer);
+	} else if (token->ident == &__COUNTER___ident) {
+		replace_with_integer(token, counter_macro++);
 	}
 	return 1;
 }
@@ -1882,6 +1885,7 @@ static void init_preprocessor(void)
 		sym->normal = 0;
 	}
 
+	counter_macro = 0;
 }
 
 static void handle_preprocessor_line(struct stream *stream, struct token **line, struct token *start)
diff --git a/validation/preprocessor/counter1.c b/validation/preprocessor/counter1.c
new file mode 100644
index 00000000..98187ee6
--- /dev/null
+++ b/validation/preprocessor/counter1.c
@@ -0,0 +1,12 @@
+__COUNTER__
+__COUNTER__
+/*
+ * check-name: __COUNTER__ #1
+ * check-command: sparse -E $file
+ *
+ * check-output-start
+
+0
+1
+ * check-output-end
+ */
diff --git a/validation/preprocessor/counter2.c b/validation/preprocessor/counter2.c
new file mode 100644
index 00000000..9883b682
--- /dev/null
+++ b/validation/preprocessor/counter2.c
@@ -0,0 +1,14 @@
+__FILE__ __COUNTER__
+#include <counter2.h>
+__FILE__ __COUNTER__
+/*
+ * check-name: __COUNTER__ #2
+ * check-command: sparse -Ipreprocessor -E $file
+ *
+ * check-output-start
+
+"preprocessor/counter2.c" 0
+"preprocessor/counter2.h" 1
+"preprocessor/counter2.c" 2
+ * check-output-end
+ */
diff --git a/validation/preprocessor/counter2.h b/validation/preprocessor/counter2.h
new file mode 100644
index 00000000..447b70ab
--- /dev/null
+++ b/validation/preprocessor/counter2.h
@@ -0,0 +1 @@
+__FILE__ __COUNTER__
diff --git a/validation/preprocessor/counter3.c b/validation/preprocessor/counter3.c
new file mode 100644
index 00000000..1449b2d1
--- /dev/null
+++ b/validation/preprocessor/counter3.c
@@ -0,0 +1,13 @@
+/*
+ * check-name: __COUNTER__ #3
+ * check-command: sparse -Ipreprocessor -E preprocessor/counter1.c preprocessor/counter2.c
+ *
+ * check-output-start
+
+0
+1
+"preprocessor/counter2.c" 0
+"preprocessor/counter2.h" 1
+"preprocessor/counter2.c" 2
+ * check-output-end
+ */
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Sat, 24 Jan 2015 01:29:58 +0000
Message-ID: <20150124012958.GB28468 () thin>
--------------------
On Sat, Jan 24, 2015 at 12:59:35AM +0100, Luc Van Oostenryck wrote:
> Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.
> 
> This macro expands to sequential integral values starting from 0,
> and this for each top-level source file.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

counter3.c seems like a bit of an abuse of the test suite framework, but
I don't have a better suggestion.

Reviewed-by: Josh Triplett <josh@joshtriplett.org>

>  ident-list.h                       |  1 +
>  pre-process.c                      |  4 ++++
>  validation/preprocessor/counter1.c | 12 ++++++++++++
>  validation/preprocessor/counter2.c | 14 ++++++++++++++
>  validation/preprocessor/counter2.h |  1 +
>  validation/preprocessor/counter3.c | 13 +++++++++++++
>  6 files changed, 45 insertions(+)
>  create mode 100644 validation/preprocessor/counter1.c
>  create mode 100644 validation/preprocessor/counter2.c
>  create mode 100644 validation/preprocessor/counter2.h
>  create mode 100644 validation/preprocessor/counter3.c
> 
> diff --git a/ident-list.h b/ident-list.h
> index d5a145f8..b65b667d 100644
> --- a/ident-list.h
> +++ b/ident-list.h
> @@ -108,6 +108,7 @@ __IDENT(__TIME___ident, "__TIME__", 0);
>  __IDENT(__func___ident, "__func__", 0);
>  __IDENT(__FUNCTION___ident, "__FUNCTION__", 0);
>  __IDENT(__PRETTY_FUNCTION___ident, "__PRETTY_FUNCTION__", 0);
> +__IDENT(__COUNTER___ident, "__COUNTER__", 0);
>  
>  /* Sparse commands */
>  IDENT_RESERVED(__context__);
> diff --git a/pre-process.c b/pre-process.c
> index 1aa3d2c4..601e0f26 100644
> --- a/pre-process.c
> +++ b/pre-process.c
> @@ -45,6 +45,7 @@
>  #include "scope.h"
>  
>  static int false_nesting = 0;
> +static int counter_macro;		// __COUNTER__ expansion
>  
>  #define INCLUDEPATHS 300
>  const char *includepath[INCLUDEPATHS+1] = {
> @@ -181,6 +182,8 @@ static int expand_one_symbol(struct token **list)
>  			time(&t);
>  		strftime(buffer, 9, "%T", localtime(&t));
>  		replace_with_string(token, buffer);
> +	} else if (token->ident == &__COUNTER___ident) {
> +		replace_with_integer(token, counter_macro++);
>  	}
>  	return 1;
>  }
> @@ -1882,6 +1885,7 @@ static void init_preprocessor(void)
>  		sym->normal = 0;
>  	}
>  
> +	counter_macro = 0;
>  }
>  
>  static void handle_preprocessor_line(struct stream *stream, struct token **line, struct token *start)
> diff --git a/validation/preprocessor/counter1.c b/validation/preprocessor/counter1.c
> new file mode 100644
> index 00000000..98187ee6
> --- /dev/null
> +++ b/validation/preprocessor/counter1.c
> @@ -0,0 +1,12 @@
> +__COUNTER__
> +__COUNTER__
> +/*
> + * check-name: __COUNTER__ #1
> + * check-command: sparse -E $file
> + *
> + * check-output-start
> +
> +0
> +1
> + * check-output-end
> + */
> diff --git a/validation/preprocessor/counter2.c b/validation/preprocessor/counter2.c
> new file mode 100644
> index 00000000..9883b682
> --- /dev/null
> +++ b/validation/preprocessor/counter2.c
> @@ -0,0 +1,14 @@
> +__FILE__ __COUNTER__
> +#include <counter2.h>
> +__FILE__ __COUNTER__
> +/*
> + * check-name: __COUNTER__ #2
> + * check-command: sparse -Ipreprocessor -E $file
> + *
> + * check-output-start
> +
> +"preprocessor/counter2.c" 0
> +"preprocessor/counter2.h" 1
> +"preprocessor/counter2.c" 2
> + * check-output-end
> + */
> diff --git a/validation/preprocessor/counter2.h b/validation/preprocessor/counter2.h
> new file mode 100644
> index 00000000..447b70ab
> --- /dev/null
> +++ b/validation/preprocessor/counter2.h
> @@ -0,0 +1 @@
> +__FILE__ __COUNTER__
> diff --git a/validation/preprocessor/counter3.c b/validation/preprocessor/counter3.c
> new file mode 100644
> index 00000000..1449b2d1
> --- /dev/null
> +++ b/validation/preprocessor/counter3.c
> @@ -0,0 +1,13 @@
> +/*
> + * check-name: __COUNTER__ #3
> + * check-command: sparse -Ipreprocessor -E preprocessor/counter1.c preprocessor/counter2.c
> + *
> + * check-output-start
> +
> +0
> +1
> +"preprocessor/counter2.c" 0
> +"preprocessor/counter2.h" 1
> +"preprocessor/counter2.c" 2
> + * check-output-end
> + */
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Sat, 24 Jan 2015 11:27:06 +0000
Message-ID: <20150124112705.GA47109 () macpro ! local>
--------------------
On Fri, Jan 23, 2015 at 05:29:58PM -0800, Josh Triplett wrote:
> On Sat, Jan 24, 2015 at 12:59:35AM +0100, Luc Van Oostenryck wrote:
> > Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.
> > 
> > This macro expands to sequential integral values starting from 0,
> > and this for each top-level source file.
> > 
> > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> 
> counter3.c seems like a bit of an abuse of the test suite framework, but
> I don't have a better suggestion.
> 
> Reviewed-by: Josh Triplett <josh@joshtriplett.org>

Yes, I know ...

Would the following change to the test-suite (introducing tags to separate input sections)
and the corresponding test be more OK ?


Luc

diff --git a/validation/test-suite b/validation/test-suite
index df5a7c60..97d4dd40 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -102,6 +102,15 @@ do_test()
 	fi
 	test_name=$last_result
 
+	# grab the input sections
+	input_nr=1
+	while grep -q "input-file-$input_nr-start" "$file"; do
+		sed -n "/input-file-$input_nr-start/,/input-file-$input_nr-end/p" "$file" \
+			| grep -v input-file > "$file".input$input_nr
+		eval "file$input_nr=$file.input$input_nr"
+		input_nr=$(($input_nr + 1))
+	done
+
 	# does the test provide a specific command ?
 	cmd=`eval echo $default_path/$default_cmd`
 	get_value "check-command" $file
diff --git a/Documentation/test-suite b/Documentation/test-suite
index 6c4f24f6..34b38696 100644
--- a/Documentation/test-suite
+++ b/Documentation/test-suite
@@ -32,6 +32,10 @@ check-output-start / check-output-end (optional)
 check-known-to-fail (optional)
 	Mark the test as being known to fail.
 
+input-file-1-start / input-file-1-end, / input-file-2-start / ... (optional)
+	The input files of check-command lies between those tags.
+	It's only needed when the test needs several distincts input files.
+
 
 	Using test-suite
 	~~~~~~~~~~~~~~~~
@@ -58,6 +62,9 @@ name:
 cmd:
 	check-command value. If no cmd is provided, it defaults to
 	"sparse $file".
+	If the "input-file-1-start/..." tags are used those files are to be
+	referenced with "$file1", ... and the command need to be something like:
+	"sparse $file1 $file2"
 
 The output of the test-suite format command can be redirected into the
 test case to create a test-suite formated file.
diff --git a/validation/preprocessor/counter3.c b/validation/preprocessor/counter3.c
index e69de29b..76635e82 100644
--- a/validation/preprocessor/counter3.c
+++ b/validation/preprocessor/counter3.c
@@ -0,0 +1,20 @@
+/* input-file-1-start */
+__COUNTER__
+__COUNTER__
+/* input-file-1-end */
+
+/* input-file-2-start */
+__COUNTER__
+/* input-file-2-end */
+
+/*
+ * check-name: __COUNTER__ #3
+ * check-command: sparse -E $file1 $file2
+ *
+ * check-output-start
+
+0
+1
+0
+ * check-output-end
+ */
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Sat, 24 Jan 2015 20:39:23 +0000
Message-ID: <20150124203922.GA52862 () macpro ! local>
--------------------
On Sat, Jan 24, 2015 at 12:19:50PM -0800, Josh Triplett wrote:
> On Sat, Jan 24, 2015 at 12:27:06PM +0100, Luc Van Oostenryck wrote:
> > On Fri, Jan 23, 2015 at 05:29:58PM -0800, Josh Triplett wrote:
> > > On Sat, Jan 24, 2015 at 12:59:35AM +0100, Luc Van Oostenryck wrote:
> > > > Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.
> > > > 
> > > > This macro expands to sequential integral values starting from 0,
> > > > and this for each top-level source file.
> > > > 
> > > > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> > > 
> > > counter3.c seems like a bit of an abuse of the test suite framework, but
> > > I don't have a better suggestion.
> > > 
> > > Reviewed-by: Josh Triplett <josh@joshtriplett.org>
> > 
> > Yes, I know ...
> > 
> > Would the following change to the test-suite (introducing tags to separate input sections)
> > and the corresponding test be more OK ?
> 
> Interesting idea!  That would also allow consolidating tests that
> require include files into a single test file, if it's possible to
> #include "$file1"; for instance, pragma-once.c could avoid recursing if
> the test fails.
> 
> I'll leave it to others to decide if this seems like a direction the
> test suite should expand to cover, or if for this single case counter3.c
> should just include other tests as your previous patch did.
> 
> - Josh Triplett
> --

Yes, it's fairly easy to add. In fact ... yesterday I had a version that
did that but I removed it because I found it a bit hackish and it was
not needed.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christian Borntraeger <borntraeger () de ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Wed, 28 Jan 2015 10:08:41 +0000
Message-ID: <54C8B529.4000805 () de ! ibm ! com>
--------------------
Am 25.01.2015 um 21:12 schrieb Christian Borntraeger:
> Am 24.01.2015 um 00:59 schrieb Luc Van Oostenryck:
> [...] 
>> Yes, indeed.
>> Thanks for bringing to my attention.
>>
>> Here is a new version of the patch taking care of that.
>>
>>
>> Luc
>>
>> ---
>> Subject: [PATCH] Teach sparse about the __COUNTER__ predefined macro.
>>
>> This macro expands to sequential integral values starting from 0,
>> and this for each top-level source file.
>>
>> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> 
> Tested-by: Christian Borntraeger <borntraeger@de.ibm.com>

Christoper,
can you apply that fix as well?

Thans

> 
>> ---
>>  ident-list.h                       |  1 +
>>  pre-process.c                      |  4 ++++
>>  validation/preprocessor/counter1.c | 12 ++++++++++++
>>  validation/preprocessor/counter2.c | 14 ++++++++++++++
>>  validation/preprocessor/counter2.h |  1 +
>>  validation/preprocessor/counter3.c | 13 +++++++++++++
>>  6 files changed, 45 insertions(+)
>>  create mode 100644 validation/preprocessor/counter1.c
>>  create mode 100644 validation/preprocessor/counter2.c
>>  create mode 100644 validation/preprocessor/counter2.h
>>  create mode 100644 validation/preprocessor/counter3.c
>>
>> diff --git a/ident-list.h b/ident-list.h
>> index d5a145f8..b65b667d 100644
>> --- a/ident-list.h
>> +++ b/ident-list.h
>> @@ -108,6 +108,7 @@ __IDENT(__TIME___ident, "__TIME__", 0);
>>  __IDENT(__func___ident, "__func__", 0);
>>  __IDENT(__FUNCTION___ident, "__FUNCTION__", 0);
>>  __IDENT(__PRETTY_FUNCTION___ident, "__PRETTY_FUNCTION__", 0);
>> +__IDENT(__COUNTER___ident, "__COUNTER__", 0);
>>
>>  /* Sparse commands */
>>  IDENT_RESERVED(__context__);
>> diff --git a/pre-process.c b/pre-process.c
>> index 1aa3d2c4..601e0f26 100644
>> --- a/pre-process.c
>> +++ b/pre-process.c
>> @@ -45,6 +45,7 @@
>>  #include "scope.h"
>>
>>  static int false_nesting = 0;
>> +static int counter_macro;		// __COUNTER__ expansion
>>
>>  #define INCLUDEPATHS 300
>>  const char *includepath[INCLUDEPATHS+1] = {
>> @@ -181,6 +182,8 @@ static int expand_one_symbol(struct token **list)
>>  			time(&t);
>>  		strftime(buffer, 9, "%T", localtime(&t));
>>  		replace_with_string(token, buffer);
>> +	} else if (token->ident == &__COUNTER___ident) {
>> +		replace_with_integer(token, counter_macro++);
>>  	}
>>  	return 1;
>>  }
>> @@ -1882,6 +1885,7 @@ static void init_preprocessor(void)
>>  		sym->normal = 0;
>>  	}
>>
>> +	counter_macro = 0;
>>  }
>>
>>  static void handle_preprocessor_line(struct stream *stream, struct token **line, struct token *start)
>> diff --git a/validation/preprocessor/counter1.c b/validation/preprocessor/counter1.c
>> new file mode 100644
>> index 00000000..98187ee6
>> --- /dev/null
>> +++ b/validation/preprocessor/counter1.c
>> @@ -0,0 +1,12 @@
>> +__COUNTER__
>> +__COUNTER__
>> +/*
>> + * check-name: __COUNTER__ #1
>> + * check-command: sparse -E $file
>> + *
>> + * check-output-start
>> +
>> +0
>> +1
>> + * check-output-end
>> + */
>> diff --git a/validation/preprocessor/counter2.c b/validation/preprocessor/counter2.c
>> new file mode 100644
>> index 00000000..9883b682
>> --- /dev/null
>> +++ b/validation/preprocessor/counter2.c
>> @@ -0,0 +1,14 @@
>> +__FILE__ __COUNTER__
>> +#include <counter2.h>
>> +__FILE__ __COUNTER__
>> +/*
>> + * check-name: __COUNTER__ #2
>> + * check-command: sparse -Ipreprocessor -E $file
>> + *
>> + * check-output-start
>> +
>> +"preprocessor/counter2.c" 0
>> +"preprocessor/counter2.h" 1
>> +"preprocessor/counter2.c" 2
>> + * check-output-end
>> + */
>> diff --git a/validation/preprocessor/counter2.h b/validation/preprocessor/counter2.h
>> new file mode 100644
>> index 00000000..447b70ab
>> --- /dev/null
>> +++ b/validation/preprocessor/counter2.h
>> @@ -0,0 +1 @@
>> +__FILE__ __COUNTER__
>> diff --git a/validation/preprocessor/counter3.c b/validation/preprocessor/counter3.c
>> new file mode 100644
>> index 00000000..1449b2d1
>> --- /dev/null
>> +++ b/validation/preprocessor/counter3.c
>> @@ -0,0 +1,13 @@
>> +/*
>> + * check-name: __COUNTER__ #3
>> + * check-command: sparse -Ipreprocessor -E preprocessor/counter1.c preprocessor/counter2.c
>> + *
>> + * check-output-start
>> +
>> +0
>> +1
>> +"preprocessor/counter2.c" 0
>> +"preprocessor/counter2.h" 1
>> +"preprocessor/counter2.c" 2
>> + * check-output-end
>> + */
>>
> 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Mon, 02 Feb 2015 05:17:38 +0000
Message-ID: <CANeU7Qn9ORJ=uH6szkW2FpTT8hFhdNETjxndBYa8347Z1iON0Q () mail ! gmail ! com>
--------------------
On Fri, Jan 23, 2015 at 3:59 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Thanks for bringing to my attention.
>
> Here is a new version of the patch taking care of that.
>

I like Sam's commit message better. So I merge a version using his
commit message.

The branch for review is here:
https://git.kernel.org/cgit/devel/sparse/chrisl/sparse.git/log/?h=review-counter

If there is no objects, I will merge it to master.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Wed, 04 Feb 2015 02:38:18 +0000
Message-ID: <20150204023816.GA7731 () macpro ! local>
--------------------
On Sun, Feb 01, 2015 at 09:17:38PM -0800, Christopher Li wrote:
> On Fri, Jan 23, 2015 at 3:59 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > Thanks for bringing to my attention.
> >
> > Here is a new version of the patch taking care of that.
> >
> 
> I like Sam's commit message better. So I merge a version using his
> commit message.
> 
> The branch for review is here:
> https://git.kernel.org/cgit/devel/sparse/chrisl/sparse.git/log/?h=review-counter
> 
> If there is no objects, I will merge it to master.
> 
> Chris
> --

Fine for me but Josh had a remark about the third test file (validation/preprocessor/counter3.c)
abusing a bit the test framework and I shared his feeling.

Here is a patch serie fixing this abuse by extending the test framework.


1/3) test-suite: add support for tests case involving several input files
2/3) test-suite: allow filename expansion of the input sections
3/3) test-suite: consolidate tests that require include files into single test files

 Documentation/test-suite                 | 11 +++++++++++
 validation/.gitignore                    |  1 +
 validation/pragma-once.c                 | 13 ++++++++++++-
 validation/preprocessor/counter2.c       | 16 +++++++++++-----
 validation/preprocessor/counter2.h       |  1 -
 validation/preprocessor/counter3.c       | 15 +++++++++++----
 validation/preprocessor/preprocessor20.c | 18 +++++++++++++++---
 validation/preprocessor/preprocessor20.h |  6 ------
 validation/test-suite                    | 11 +++++++++++
 validation/test-suite-file-expansion.c   | 22 ++++++++++++++++++++++
 10 files changed, 94 insertions(+), 20 deletions(-)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Teach sparse about the __COUNTER__ predefined macro
Date: Thu, 12 Feb 2015 20:16:55 +0000
Message-ID: <CANeU7Q=DevAJH5UAXGi+jzMbdn2M6XFqCioTRxYjqZyGXAtDhA () mail ! gmail ! com>
--------------------
On Tue, Feb 3, 2015 at 6:38 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Fine for me but Josh had a remark about the third test file (validation/preprocessor/counter3.c)
> abusing a bit the test framework and I shared his feeling.
>
> Here is a patch serie fixing this abuse by extending the test framework.
>

I check in a version with very minor fix for the counter3.c hack.
Counter3.c does a few things unclean, top of which is, it does not invoke
counter3.c at all. It is invoking counter1.c and counter2.c.

I modify coutner3.c to include the couter2.c, that will solve the problem that
counter3.c not using its own source code.

Any way, the change is pushed.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build: drop -ON (optimization level) from llvm flags ===

From: Azat Khuzhin <a3at.mail () gmail ! com>
To: linux-sparse
Subject: [PATCH] build: drop -ON (optimization level) from llvm flags
Date: Sat, 16 May 2015 22:34:27 +0000
Message-ID: <1431815667-22623-1-git-send-email-a3at.mail () gmail ! com>
--------------------
This will make debugging easier (via overriding flags in local.mk)
---
 Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index c7031af..269b1eb 100644
--- a/Makefile
+++ b/Makefile
@@ -84,7 +84,7 @@ ifeq ($(shell expr "$(LLVM_VERSION)" : '[3-9]\.'),2)
 LLVM_PROGS := sparse-llvm
 $(LLVM_PROGS): LD := g++
 LLVM_LDFLAGS := $(shell $(LLVM_CONFIG) --ldflags)
-LLVM_CFLAGS := $(shell $(LLVM_CONFIG) --cflags | sed -e "s/-DNDEBUG//g")
+LLVM_CFLAGS := $(shell $(LLVM_CONFIG) --cflags | sed -e "s/-DNDEBUG//g" -e 's/-O[0-9]//g')
 LLVM_LIBS := $(shell $(LLVM_CONFIG) --libs)
 LLVM_LIBS += $(shell $(LLVM_CONFIG) --system-libs 2>/dev/null)
 PROGRAMS += $(LLVM_PROGS)
-- 
2.1.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] compiler.h: Fix sparse check errors ===

From: Mauro Carvalho Chehab <mchehab () osg ! samsung ! com>
To: linux-sparse
Subject: [PATCH] compiler.h: Fix sparse check errors
Date: Tue, 07 Jul 2015 13:43:05 +0000
Message-ID: <607087dd3321926ddf4f67762be67656501bfa25.1436276428.git.mchehab () osg ! samsung ! com>
--------------------
The #define __pmem was put at the wrong place, inside a
__rcu check. The way it is, if CONFIG_SPARSE_RCU_POINTER is
not defined, it will produce thousands of errors like:

./arch/x86/include/asm/io.h:251:27: error: void declaration
./arch/x86/include/asm/io.h:251:27: error: Expected ; at end of declaration
./arch/x86/include/asm/io.h:251:27: error: got *

making sparse pretty much useless, due to the excess of noise.

So, move the define out of the sparse RCU pointer check.

Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 7f8ad9593da7..4f85b58b7285 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -21,8 +21,8 @@
 # define __rcu		__attribute__((noderef, address_space(4)))
 #else
 # define __rcu
+#endif
 # define __pmem		__attribute__((noderef, address_space(5)))
-#endif
 extern void __chk_user_ptr(const volatile void __user *);
 extern void __chk_io_ptr(const volatile void __iomem *);
 #else
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Mauro Carvalho Chehab <mchehab () osg ! samsung ! com>
To: linux-kernel
Subject: [PATCH] compiler.h: Fix sparse check errors
Date: Tue, 07 Jul 2015 13:43:05 +0000
Message-ID: <607087dd3321926ddf4f67762be67656501bfa25.1436276428.git.mchehab () osg ! samsung ! com>
--------------------
The #define __pmem was put at the wrong place, inside a
__rcu check. The way it is, if CONFIG_SPARSE_RCU_POINTER is
not defined, it will produce thousands of errors like:

./arch/x86/include/asm/io.h:251:27: error: void declaration
./arch/x86/include/asm/io.h:251:27: error: Expected ; at end of declaration
./arch/x86/include/asm/io.h:251:27: error: got *

making sparse pretty much useless, due to the excess of noise.

So, move the define out of the sparse RCU pointer check.

Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 7f8ad9593da7..4f85b58b7285 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -21,8 +21,8 @@
 # define __rcu		__attribute__((noderef, address_space(4)))
 #else
 # define __rcu
+#endif
 # define __pmem		__attribute__((noderef, address_space(5)))
-#endif
 extern void __chk_user_ptr(const volatile void __user *);
 extern void __chk_io_ptr(const volatile void __iomem *);
 #else
-- 
2.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Ross Zwisler <ross.zwisler () linux ! intel ! com>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: Fix sparse check errors
Date: Tue, 07 Jul 2015 14:56:14 +0000
Message-ID: <1436280974.790.1.camel () theros ! lm ! intel ! com>
--------------------
On Tue, 2015-07-07 at 10:43 -0300, Mauro Carvalho Chehab wrote:
> The #define __pmem was put at the wrong place, inside a
> __rcu check. The way it is, if CONFIG_SPARSE_RCU_POINTER is
> not defined, it will produce thousands of errors like:
> 
> ./arch/x86/include/asm/io.h:251:27: error: void declaration
> ./arch/x86/include/asm/io.h:251:27: error: Expected ; at end of declaration
> ./arch/x86/include/asm/io.h:251:27: error: got *
> 
> making sparse pretty much useless, due to the excess of noise.
> 
> So, move the define out of the sparse RCU pointer check.
> 
> Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
> 
> diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> index 7f8ad9593da7..4f85b58b7285 100644
> --- a/include/linux/compiler.h
> +++ b/include/linux/compiler.h
> @@ -21,8 +21,8 @@
>  # define __rcu		__attribute__((noderef, address_space(4)))
>  #else
>  # define __rcu
> +#endif
>  # define __pmem		__attribute__((noderef, address_space(5)))
> -#endif
>  extern void __chk_user_ptr(const volatile void __user *);
>  extern void __chk_io_ptr(const volatile void __iomem *);
>  #else

Yep, thank you for the fix.  I think Dan already has a version of this queued
up in his tree for his next pull request:

https://git.kernel.org/cgit/linux/kernel/git/djbw/nvdimm.git/commit/?h=libnvdimm-pending&id=31f02455455d405320e2f749696bef4e02903b35


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ross Zwisler <ross.zwisler () linux ! intel ! com>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: Fix sparse check errors
Date: Tue, 07 Jul 2015 14:56:14 +0000
Message-ID: <1436280974.790.1.camel () theros ! lm ! intel ! com>
--------------------
On Tue, 2015-07-07 at 10:43 -0300, Mauro Carvalho Chehab wrote:
> The #define __pmem was put at the wrong place, inside a
> __rcu check. The way it is, if CONFIG_SPARSE_RCU_POINTER is
> not defined, it will produce thousands of errors like:
> 
> ./arch/x86/include/asm/io.h:251:27: error: void declaration
> ./arch/x86/include/asm/io.h:251:27: error: Expected ; at end of declaration
> ./arch/x86/include/asm/io.h:251:27: error: got *
> 
> making sparse pretty much useless, due to the excess of noise.
> 
> So, move the define out of the sparse RCU pointer check.
> 
> Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
> 
> diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> index 7f8ad9593da7..4f85b58b7285 100644
> --- a/include/linux/compiler.h
> +++ b/include/linux/compiler.h
> @@ -21,8 +21,8 @@
>  # define __rcu		__attribute__((noderef, address_space(4)))
>  #else
>  # define __rcu
> +#endif
>  # define __pmem		__attribute__((noderef, address_space(5)))
> -#endif
>  extern void __chk_user_ptr(const volatile void __user *);
>  extern void __chk_io_ptr(const volatile void __iomem *);
>  #else

Yep, thank you for the fix.  I think Dan already has a version of this queued
up in his tree for his next pull request:

https://git.kernel.org/cgit/linux/kernel/git/djbw/nvdimm.git/commit/?h=libnvdimm-pending&id=31f02455455d405320e2f749696bef4e02903b35


--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH] include/linux/compiler.h: unconditionally define __pmem sparse attribute ===

From: Nicolai Stange <nicstange () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] include/linux/compiler.h: unconditionally define __pmem sparse attribute
Date: Tue, 07 Jul 2015 15:47:20 +0000
Message-ID: <87bnfoc6lz.fsf () gmail ! com>
--------------------
Already fixed in linux-next. Sorry for the noise.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] ptrlist: reading deleted items in NEXT_PTR_LIST() ===

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: [PATCH] ptrlist: reading deleted items in NEXT_PTR_LIST()
Date: Thu, 23 Jul 2015 08:24:14 +0000
Message-ID: <20150723082414.GA30778 () mwanda>
--------------------
If you call DELETE_CURRENT_PTR(), then you can sometimes end up with a
__list->nr that is zero.  The FOR_EACH_PTR() macro can handle this but
the NEXT_PTR_LIST() macro returns ptr = 0xf0f0f0f0 which leads to a
segfault.

Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
---
 ptrlist.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/ptrlist.h b/ptrlist.h
index 58d3bda..61e159f 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -97,6 +97,8 @@ static inline void *last_ptr_list(struct ptr_list *list)
 			} else {							\
 				__list = __list->next;					\
 				ptr = NULL;						\
+				while (__list->nr == 0 && __list != __head)		\
+					__list = __list->next;				\
 				if (__list != __head) {					\
 					__nr = 0;					\
 					ptr = PTR_ENTRY(__list,0);			\
-- 
2.1.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] remove validation/tmp.o in clean target ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH] remove validation/tmp.o in clean target
Date: Sun, 19 Jul 2015 09:57:49 +0000
Message-ID: <1437299869-3669-1-git-send-email-uwe () kleine-koenig ! org>
--------------------
To prevent validation/tmp.o being still around after

	make check && make clean

remove it as part of the latter command.
---
 Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index c7031afda00b..bc837db7c3f6 100644
--- a/Makefile
+++ b/Makefile
@@ -199,7 +199,7 @@ compat-cygwin.o: $(LIB_H)
 	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $<
 
 clean: clean-check
-	rm -f *.[oa] .*.d *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc
+	rm -f *.[oa] .*.d *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc validation/*.[oa]
 
 dist:
 	@if test "$(SPARSE_VERSION)" != "v$(VERSION)" ; then \
-- 
2.1.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] remove validation/tmp.o in clean target
Date: Tue, 04 Aug 2015 06:44:34 +0000
Message-ID: <CANeU7Q=x4aF3CqrP-prJmtLj_jVz+yji5b8Sn-V7FOtnfHCM4g () mail ! gmail ! com>
--------------------
On Sun, Jul 19, 2015 at 5:57 AM, Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org> wrote:
> To prevent validation/tmp.o being still around after
>
>         make check && make clean
>
> remove it as part of the latter command.

Looks good. I would like to apply it.

Can you send me a "signed-off-by" line please?
While you are at it, you can combine the two patches into one.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] s390x: add the proper defines for data types ===

From: Christian Borntraeger <borntraeger () de ! ibm ! com>
To: linux-s390
Subject: [PATCH] s390x: add the proper defines for data types
Date: Thu, 22 Jan 2015 09:51:50 +0000
Message-ID: <1421920310-1499-1-git-send-email-borntraeger () de ! ibm ! com>
--------------------
This patch fixes several issues when compiling code under s390x
(64bit) with cgcc, e.g.
/usr/include/gnu/stubs.h:8:12: error: unable to open 'gnu/stubs-32.h'
by providing the proper defines.

Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
---
 cgcc |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/cgcc b/cgcc
index 8e38174..d7b1c99 100755
--- a/cgcc
+++ b/cgcc
@@ -279,6 +279,12 @@ sub add_specs {
 		&float_types (1, 1, 21, [24,8], [53,11], [113,15]) .
 		&define_size_t ($m64 ? "long unsigned int" : "unsigned int") .
 		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
+    } elsif ($spec eq 's390x') {
+	return (' -D__s390x__ -D__s390__ -D_BIG_ENDIAN' .
+		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
+		&float_types (1, 1, 36, [24,8], [53,11], [113,15]) .
+		&define_size_t ("long unsigned int") .
+		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
     } elsif ($spec eq 'host_os_specs') {
 	my $os = `uname -s`;
 	chomp $os;
@@ -294,6 +300,8 @@ sub add_specs {
 	    return &add_specs ('x86_64');
 	} elsif ($arch =~ /^(ppc)$/i) {
 	    return &add_specs ('ppc');
+	} elsif ($arch =~ /^(s390x)$/i) {
+	    return &add_specs ('s390x');
 	} elsif ($arch =~ /^(sparc64)$/i) {
 	    return &add_specs ('sparc64');
 	}
-- 
1.7.1

--
To unsubscribe from this list: send the line "unsubscribe linux-s390" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] s390x: add the proper defines for data types
Date: Thu, 22 Jan 2015 17:52:56 +0000
Message-ID: <CANeU7Qn9jD-ZX2CjSkVTyTu92b9qwM4XZqTOSUB5NDVpAdVMSQ () mail ! gmail ! com>
--------------------
On Thu, Jan 22, 2015 at 1:51 AM, Christian Borntraeger
<borntraeger@de.ibm.com> wrote:
> This patch fixes several issues when compiling code under s390x
> (64bit) with cgcc, e.g.
> /usr/include/gnu/stubs.h:8:12: error: unable to open 'gnu/stubs-32.h'
> by providing the proper defines.


The change looks good. Will apply.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-s390
Subject: Re: [PATCH] s390x: add the proper defines for data types
Date: Thu, 22 Jan 2015 17:52:56 +0000
Message-ID: <CANeU7Qn9jD-ZX2CjSkVTyTu92b9qwM4XZqTOSUB5NDVpAdVMSQ () mail ! gmail ! com>
--------------------
On Thu, Jan 22, 2015 at 1:51 AM, Christian Borntraeger
<borntraeger@de.ibm.com> wrote:
> This patch fixes several issues when compiling code under s390x
> (64bit) with cgcc, e.g.
> /usr/include/gnu/stubs.h:8:12: error: unable to open 'gnu/stubs-32.h'
> by providing the proper defines.


The change looks good. Will apply.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-s390" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] s390x: add the proper defines for data types (sparse) ===

From: Christian Borntraeger <borntraeger () de ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH] s390x: add the proper defines for data types (sparse)
Date: Thu, 22 Jan 2015 13:50:57 +0000
Message-ID: <54C10041.3080002 () de ! ibm ! com>
--------------------
I somehow managed to not mention the word "sparse" , which is the target for my patch. 
Also adding Christopher cc.

Am 22.01.2015 um 10:51 schrieb Christian Borntraeger:
> This patch fixes several issues when compiling code under s390x
> (64bit) with cgcc, e.g.
> /usr/include/gnu/stubs.h:8:12: error: unable to open 'gnu/stubs-32.h'
> by providing the proper defines.
> 
> Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
> ---
>  cgcc |    8 ++++++++
>  1 files changed, 8 insertions(+), 0 deletions(-)
> 
> diff --git a/cgcc b/cgcc
> index 8e38174..d7b1c99 100755
> --- a/cgcc
> +++ b/cgcc
> @@ -279,6 +279,12 @@ sub add_specs {
>  		&float_types (1, 1, 21, [24,8], [53,11], [113,15]) .
>  		&define_size_t ($m64 ? "long unsigned int" : "unsigned int") .
>  		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
> +    } elsif ($spec eq 's390x') {
> +	return (' -D__s390x__ -D__s390__ -D_BIG_ENDIAN' .
> +		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
> +		&float_types (1, 1, 36, [24,8], [53,11], [113,15]) .
> +		&define_size_t ("long unsigned int") .
> +		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
>      } elsif ($spec eq 'host_os_specs') {
>  	my $os = `uname -s`;
>  	chomp $os;
> @@ -294,6 +300,8 @@ sub add_specs {
>  	    return &add_specs ('x86_64');
>  	} elsif ($arch =~ /^(ppc)$/i) {
>  	    return &add_specs ('ppc');
> +	} elsif ($arch =~ /^(s390x)$/i) {
> +	    return &add_specs ('s390x');
>  	} elsif ($arch =~ /^(sparc64)$/i) {
>  	    return &add_specs ('sparc64');
>  	}
> 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christian Borntraeger <borntraeger () de ! ibm ! com>
To: linux-s390
Subject: Re: [PATCH] s390x: add the proper defines for data types (sparse)
Date: Thu, 22 Jan 2015 13:50:57 +0000
Message-ID: <54C10041.3080002 () de ! ibm ! com>
--------------------
I somehow managed to not mention the word "sparse" , which is the target for my patch. 
Also adding Christopher cc.

Am 22.01.2015 um 10:51 schrieb Christian Borntraeger:
> This patch fixes several issues when compiling code under s390x
> (64bit) with cgcc, e.g.
> /usr/include/gnu/stubs.h:8:12: error: unable to open 'gnu/stubs-32.h'
> by providing the proper defines.
> 
> Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
> ---
>  cgcc |    8 ++++++++
>  1 files changed, 8 insertions(+), 0 deletions(-)
> 
> diff --git a/cgcc b/cgcc
> index 8e38174..d7b1c99 100755
> --- a/cgcc
> +++ b/cgcc
> @@ -279,6 +279,12 @@ sub add_specs {
>  		&float_types (1, 1, 21, [24,8], [53,11], [113,15]) .
>  		&define_size_t ($m64 ? "long unsigned int" : "unsigned int") .
>  		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
> +    } elsif ($spec eq 's390x') {
> +	return (' -D__s390x__ -D__s390__ -D_BIG_ENDIAN' .
> +		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
> +		&float_types (1, 1, 36, [24,8], [53,11], [113,15]) .
> +		&define_size_t ("long unsigned int") .
> +		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
>      } elsif ($spec eq 'host_os_specs') {
>  	my $os = `uname -s`;
>  	chomp $os;
> @@ -294,6 +300,8 @@ sub add_specs {
>  	    return &add_specs ('x86_64');
>  	} elsif ($arch =~ /^(ppc)$/i) {
>  	    return &add_specs ('ppc');
> +	} elsif ($arch =~ /^(s390x)$/i) {
> +	    return &add_specs ('s390x');
>  	} elsif ($arch =~ /^(sparc64)$/i) {
>  	    return &add_specs ('sparc64');
>  	}
> 

--
To unsubscribe from this list: send the line "unsubscribe linux-s390" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse/parse.c: ignore hotpatch attribute ===

From: josh () joshtriplett ! org
To: linux-sparse
Subject: Re: [PATCH] sparse/parse.c: ignore hotpatch attribute
Date: Thu, 30 Apr 2015 19:41:34 +0000
Message-ID: <20150430194134.GC9971 () cloud>
--------------------
On Thu, Apr 30, 2015 at 10:51:42AM -0700, Linus Torvalds wrote:
> On Thu, Apr 30, 2015 at 10:38 AM,  <josh@joshtriplett.org> wrote:
> > I think part of the problem arises because sparse claims (via the
> > preprocessor symbols we provide) to be whatever version of GCC it was
> > compiled with.  I think that's a mistake.  We should pick a version of
> > GCC for which we support all the attributes we actually need to do
> > something with, and advertise ourselves specifically as that version.
> 
> Fair enough. Although there may then be headers that are unhappy.

If you mean the GCC internal headers, I don't think those have version
checks; after all, you'd only use them with the GCC they ship with,
right? ;)

For any other headers, I think we'll get worse results by claiming to be
a version of GCC that has features we don't actually support.

> > I suspect that 3.2 is probably the version sparse should claim to be,
> > for now.
> 
> That may be too old. You can't reliably compile the kernel with gcc
> that old (some config options will complain).
> 
> At least CONFIG_GCOV_KERNEL wants 3.4 minimum.

If we want to claim to be 3.4 instead, then there are some attributes
we'll need to check for and warn if we find.  From a quick read of
https://ohse.de/uwe/articles/gcc-attributes.html I think this is a
complete list of attributes in 3.4 that sparse has to care about but
doesn't currently support:

cleanup
gcc_struct
ms_struct

"cleanup" we'll need to handle because it affects control flow;
gcc_struct and ms_struct affect structure layout, which we have warnings
related to.

For the moment, we could just add an explicit warning if we see any of
those three attributes, set our GCC version to 3.4, and then drop the
"unknown attribute" warning.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 0/3] sparse: Introduce __private to privatize members of structs ===

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-sparse
Subject: [RFC 0/3] sparse: Introduce __private to privatize members of structs
Date: Sat, 12 Dec 2015 02:55:59 +0000
Message-ID: <1449888962-29348-1-git-send-email-boqun.feng () gmail ! com>
--------------------
Hi all,

As I proposed:

http://marc.info/?l=linux-arm-kernel&m=144944469805753

, we can define a __private modifier for sparse to detect misuses of private
members of structs. This could make maintenace a little easier and prevent some
potential bugs.

This patchset serves as a POC and consists of three patches:

1.	Introduce __private and related macro, also improve compiler.h a litte
	bit

2.	Privatize rcu_node::lock

3.	Privatize irq_common_data::state_use_accessors

This patchset is against

	-rcu/rcu/next	5f343fc7f0ce7edfe344e7cc5afdfe145a18f802

because this depends on commits:
	
	"rcu: Create transitive rnp->lock acquisition functions"

and

	"rcu: Add transitivity to remaining rcu_node ->lock acquisitions


I tried to use 0day to test this, but seems the email transfer from 0day to my
mail box is very slow recently, so I haven't received a recent result yet. But
as one can see, this patchset doesn't have any functional modification, the 0day
may not find anything interesting ;-)


Looking forward to any suggestion, question and comment ;-)

Regards,
Boqun
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 1/3] sparse: Add __private to privatize members of structs ===

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-sparse
Subject: [RFC 1/3] sparse: Add __private to privatize members of structs
Date: Sat, 12 Dec 2015 02:56:00 +0000
Message-ID: <1449888962-29348-2-git-send-email-boqun.feng () gmail ! com>
--------------------
In C programming language, we don't have a easy way to privatize a
member of a structure. However in kernel, sometimes there is a need to
privatize a member in case of potential bugs or misuses.

Fortunately, the noderef attribute of sparse is a way to privatize a
member, as by defining a member as noderef, the address-of operator on
the member will produce a noderef pointer to that member, and if anyone
wants to dereference that kind of pointers to read or modify the member,
sparse will yell.

Based on this, __private modifier and related operation ACCESS_PRIVATE()
are introduced, which could help detect undesigned public uses of
private members of structs. Here is an example of sparse's output if it
detect an undersigned public use:

| kernel/rcu/tree.c:4453:25: warning: incorrect type in argument 1 (different modifiers)
| kernel/rcu/tree.c:4453:25:    expected struct raw_spinlock [usertype] *lock
| kernel/rcu/tree.c:4453:25:    got struct raw_spinlock [noderef] *<noident>

Also, this patch improves compiler.h a little bit by adding comments for
"#else" and "#endif".

Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
---
 include/linux/compiler.h | 12 ++++++++----
 scripts/checkpatch.pl    |  3 ++-
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 4dac103..e4a4fb1 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -20,12 +20,14 @@
 # define __pmem		__attribute__((noderef, address_space(5)))
 #ifdef CONFIG_SPARSE_RCU_POINTER
 # define __rcu		__attribute__((noderef, address_space(4)))
-#else
+#else /* CONFIG_SPARSE_RCU_POINTER */
 # define __rcu
-#endif
+#endif /* CONFIG_SPARSE_RCU_POINTER */
+# define __private	__attribute__((noderef))
 extern void __chk_user_ptr(const volatile void __user *);
 extern void __chk_io_ptr(const volatile void __iomem *);
-#else
+# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))
+#else /* __CHECKER__ */
 # define __user
 # define __kernel
 # define __safe
@@ -44,7 +46,9 @@ extern void __chk_io_ptr(const volatile void __iomem *);
 # define __percpu
 # define __rcu
 # define __pmem
-#endif
+# define __private
+# define ACCESS_PRIVATE(p, member) ((p)->member)
+#endif /* __CHECKER__ */
 
 /* Indirect macros required for expanded argument pasting, eg. __LINE__. */
 #define ___PASTE(a,b) a##b
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index 2b3c228..fda1c61 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -269,7 +269,8 @@ our $Sparse	= qr{
 			__init_refok|
 			__kprobes|
 			__ref|
-			__rcu
+			__rcu|
+			__private
 		}x;
 our $InitAttributePrefix = qr{__(?:mem|cpu|dev|net_|)};
 our $InitAttributeData = qr{$InitAttributePrefix(?:initdata\b)};
-- 
2.6.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 2/3] RCU: Privatize rcu_node::lock ===

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-sparse
Subject: [RFC 2/3] RCU: Privatize rcu_node::lock
Date: Sat, 12 Dec 2015 02:56:01 +0000
Message-ID: <1449888962-29348-3-git-send-email-boqun.feng () gmail ! com>
--------------------
In patch:

"rcu: Add transitivity to remaining rcu_node ->lock acquisitions"

All locking operations on rcu_node::lock are replaced with the wrappers
because of the need of transitivity, which indicates we should never
write code using LOCK primitives alone(i.e. without a proper barrier
following) on rcu_node::lock outside those wrappers. We could detect
this kind of misuses on rcu_node::lock in the future by adding __private
modifier on rcu_node::lock.

To privatize rcu_node::lock, unlock wrappers are also needed. Replacing
spinlock unlocks with these wrappers not only privatizes rcu_node::lock
but also makes it easier to figure out critical sections of rcu_node.

This patch adds __private modifier to rcu_node::lock and makes every
access to it wrapped by ACCESS_PRIVATE(). Besides, unlock wrappers are
added and raw_spin_unlock(&rnp->lock) and its friends are replaced with
those wrappers.

Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
---
 kernel/rcu/tree.c        | 103 ++++++++++++++++++++++++-----------------------
 kernel/rcu/tree.h        |  42 ++++++++++++++-----
 kernel/rcu/tree_plugin.h |  26 ++++++------
 3 files changed, 96 insertions(+), 75 deletions(-)

diff --git a/kernel/rcu/tree.c b/kernel/rcu/tree.c
index e41dd41..1646efd 100644
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@ -1246,7 +1246,7 @@ static void rcu_dump_cpu_stacks(struct rcu_state *rsp)
 				if (rnp->qsmask & (1UL << cpu))
 					dump_cpu_task(rnp->grplo + cpu);
 		}
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	}
 }
 
@@ -1266,12 +1266,12 @@ static void print_other_cpu_stall(struct rcu_state *rsp, unsigned long gpnum)
 	raw_spin_lock_irqsave_rcu_node(rnp, flags);
 	delta = jiffies - READ_ONCE(rsp->jiffies_stall);
 	if (delta < RCU_STALL_RAT_DELAY || !rcu_gp_in_progress(rsp)) {
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		return;
 	}
 	WRITE_ONCE(rsp->jiffies_stall,
 		   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 
 	/*
 	 * OK, time to rat on our buddy...
@@ -1292,7 +1292,7 @@ static void print_other_cpu_stall(struct rcu_state *rsp, unsigned long gpnum)
 					ndetected++;
 				}
 		}
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	}
 
 	print_cpu_stall_info_end();
@@ -1357,7 +1357,7 @@ static void print_cpu_stall(struct rcu_state *rsp)
 	if (ULONG_CMP_GE(jiffies, READ_ONCE(rsp->jiffies_stall)))
 		WRITE_ONCE(rsp->jiffies_stall,
 			   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 
 	/*
 	 * Attempt to revive the RCU machinery by forcing a context switch.
@@ -1595,7 +1595,7 @@ rcu_start_future_gp(struct rcu_node *rnp, struct rcu_data *rdp,
 	}
 unlock_out:
 	if (rnp != rnp_root)
-		raw_spin_unlock(&rnp_root->lock);
+		raw_spin_unlock_rcu_node(rnp_root);
 out:
 	if (c_out != NULL)
 		*c_out = c;
@@ -1815,7 +1815,7 @@ static void note_gp_changes(struct rcu_state *rsp, struct rcu_data *rdp)
 		return;
 	}
 	needwake = __note_gp_changes(rsp, rnp, rdp);
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	if (needwake)
 		rcu_gp_kthread_wake(rsp);
 }
@@ -1840,7 +1840,7 @@ static bool rcu_gp_init(struct rcu_state *rsp)
 	raw_spin_lock_irq_rcu_node(rnp);
 	if (!READ_ONCE(rsp->gp_flags)) {
 		/* Spurious wakeup, tell caller to go back to sleep.  */
-		raw_spin_unlock_irq(&rnp->lock);
+		raw_spin_unlock_irq_rcu_node(rnp);
 		return false;
 	}
 	WRITE_ONCE(rsp->gp_flags, 0); /* Clear all flags: New grace period. */
@@ -1850,7 +1850,7 @@ static bool rcu_gp_init(struct rcu_state *rsp)
 		 * Grace period already in progress, don't start another.
 		 * Not supposed to be able to happen.
 		 */
-		raw_spin_unlock_irq(&rnp->lock);
+		raw_spin_unlock_irq_rcu_node(rnp);
 		return false;
 	}
 
@@ -1859,7 +1859,7 @@ static bool rcu_gp_init(struct rcu_state *rsp)
 	/* Record GP times before starting GP, hence smp_store_release(). */
 	smp_store_release(&rsp->gpnum, rsp->gpnum + 1);
 	trace_rcu_grace_period(rsp->name, rsp->gpnum, TPS("start"));
-	raw_spin_unlock_irq(&rnp->lock);
+	raw_spin_unlock_irq_rcu_node(rnp);
 
 	/*
 	 * Apply per-leaf buffered online and offline operations to the
@@ -1873,7 +1873,7 @@ static bool rcu_gp_init(struct rcu_state *rsp)
 		if (rnp->qsmaskinit == rnp->qsmaskinitnext &&
 		    !rnp->wait_blkd_tasks) {
 			/* Nothing to do on this leaf rcu_node structure. */
-			raw_spin_unlock_irq(&rnp->lock);
+			raw_spin_unlock_irq_rcu_node(rnp);
 			continue;
 		}
 
@@ -1907,7 +1907,7 @@ static bool rcu_gp_init(struct rcu_state *rsp)
 			rcu_cleanup_dead_rnp(rnp);
 		}
 
-		raw_spin_unlock_irq(&rnp->lock);
+		raw_spin_unlock_irq_rcu_node(rnp);
 	}
 
 	/*
@@ -1938,7 +1938,7 @@ static bool rcu_gp_init(struct rcu_state *rsp)
 		trace_rcu_grace_period_init(rsp->name, rnp->gpnum,
 					    rnp->level, rnp->grplo,
 					    rnp->grphi, rnp->qsmask);
-		raw_spin_unlock_irq(&rnp->lock);
+		raw_spin_unlock_irq_rcu_node(rnp);
 		cond_resched_rcu_qs();
 		WRITE_ONCE(rsp->gp_activity, jiffies);
 	}
@@ -1996,7 +1996,7 @@ static void rcu_gp_fqs(struct rcu_state *rsp, bool first_time)
 		raw_spin_lock_irq_rcu_node(rnp);
 		WRITE_ONCE(rsp->gp_flags,
 			   READ_ONCE(rsp->gp_flags) & ~RCU_GP_FLAG_FQS);
-		raw_spin_unlock_irq(&rnp->lock);
+		raw_spin_unlock_irq_rcu_node(rnp);
 	}
 }
 
@@ -2025,7 +2025,7 @@ static void rcu_gp_cleanup(struct rcu_state *rsp)
 	 * safe for us to drop the lock in order to mark the grace
 	 * period as completed in all of the rcu_node structures.
 	 */
-	raw_spin_unlock_irq(&rnp->lock);
+	raw_spin_unlock_irq_rcu_node(rnp);
 
 	/*
 	 * Propagate new ->completed value to rcu_node structures so
@@ -2046,7 +2046,7 @@ static void rcu_gp_cleanup(struct rcu_state *rsp)
 			needgp = __note_gp_changes(rsp, rnp, rdp) || needgp;
 		/* smp_mb() provided by prior unlock-lock pair. */
 		nocb += rcu_future_gp_cleanup(rsp, rnp);
-		raw_spin_unlock_irq(&rnp->lock);
+		raw_spin_unlock_irq_rcu_node(rnp);
 		cond_resched_rcu_qs();
 		WRITE_ONCE(rsp->gp_activity, jiffies);
 		rcu_gp_slow(rsp, gp_cleanup_delay);
@@ -2068,7 +2068,7 @@ static void rcu_gp_cleanup(struct rcu_state *rsp)
 				       READ_ONCE(rsp->gpnum),
 				       TPS("newreq"));
 	}
-	raw_spin_unlock_irq(&rnp->lock);
+	raw_spin_unlock_irq_rcu_node(rnp);
 }
 
 /*
@@ -2245,7 +2245,7 @@ static void rcu_report_qs_rsp(struct rcu_state *rsp, unsigned long flags)
 {
 	WARN_ON_ONCE(!rcu_gp_in_progress(rsp));
 	WRITE_ONCE(rsp->gp_flags, READ_ONCE(rsp->gp_flags) | RCU_GP_FLAG_FQS);
-	raw_spin_unlock_irqrestore(&rcu_get_root(rsp)->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rcu_get_root(rsp), flags);
 	rcu_gp_kthread_wake(rsp);
 }
 
@@ -2275,7 +2275,7 @@ rcu_report_qs_rnp(unsigned long mask, struct rcu_state *rsp,
 			 * Our bit has already been cleared, or the
 			 * relevant grace period is already over, so done.
 			 */
-			raw_spin_unlock_irqrestore(&rnp->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 			return;
 		}
 		WARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */
@@ -2287,7 +2287,7 @@ rcu_report_qs_rnp(unsigned long mask, struct rcu_state *rsp,
 		if (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {
 
 			/* Other bits still set at this level, so done. */
-			raw_spin_unlock_irqrestore(&rnp->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 			return;
 		}
 		mask = rnp->grpmask;
@@ -2297,7 +2297,7 @@ rcu_report_qs_rnp(unsigned long mask, struct rcu_state *rsp,
 
 			break;
 		}
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		rnp_c = rnp;
 		rnp = rnp->parent;
 		raw_spin_lock_irqsave_rcu_node(rnp, flags);
@@ -2329,7 +2329,7 @@ static void rcu_report_unblock_qs_rnp(struct rcu_state *rsp,
 
 	if (rcu_state_p == &rcu_sched_state || rsp != rcu_state_p ||
 	    rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		return;  /* Still need more quiescent states! */
 	}
 
@@ -2346,7 +2346,7 @@ static void rcu_report_unblock_qs_rnp(struct rcu_state *rsp,
 	/* Report up the rest of the hierarchy, tracking current ->gpnum. */
 	gps = rnp->gpnum;
 	mask = rnp->grpmask;
-	raw_spin_unlock(&rnp->lock);	/* irqs remain disabled. */
+	raw_spin_unlock_rcu_node(rnp);	/* irqs remain disabled. */
 	raw_spin_lock_rcu_node(rnp_p);	/* irqs already disabled. */
 	rcu_report_qs_rnp(mask, rsp, rnp_p, gps, flags);
 }
@@ -2383,12 +2383,12 @@ rcu_report_qs_rdp(int cpu, struct rcu_state *rsp, struct rcu_data *rdp)
 		 */
 		rdp->cpu_no_qs.b.norm = true;	/* need qs for new gp. */
 		rdp->rcu_qs_ctr_snap = __this_cpu_read(rcu_qs_ctr);
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		return;
 	}
 	mask = rdp->grpmask;
 	if ((rnp->qsmask & mask) == 0) {
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	} else {
 		rdp->core_needs_qs = 0;
 
@@ -2599,10 +2599,11 @@ static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)
 		rnp->qsmaskinit &= ~mask;
 		rnp->qsmask &= ~mask;
 		if (rnp->qsmaskinit) {
-			raw_spin_unlock(&rnp->lock); /* irqs remain disabled. */
+			raw_spin_unlock_rcu_node(rnp);
+			/* irqs remain disabled. */
 			return;
 		}
-		raw_spin_unlock(&rnp->lock); /* irqs remain disabled. */
+		raw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */
 	}
 }
 
@@ -2625,7 +2626,7 @@ static void rcu_cleanup_dying_idle_cpu(int cpu, struct rcu_state *rsp)
 	mask = rdp->grpmask;
 	raw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */
 	rnp->qsmaskinitnext &= ~mask;
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 }
 
 /*
@@ -2859,7 +2860,7 @@ static void force_qs_rnp(struct rcu_state *rsp,
 			rcu_report_qs_rnp(mask, rsp, rnp, rnp->gpnum, flags);
 		} else {
 			/* Nothing to do here, so just drop the lock. */
-			raw_spin_unlock_irqrestore(&rnp->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		}
 	}
 }
@@ -2895,11 +2896,11 @@ static void force_quiescent_state(struct rcu_state *rsp)
 	raw_spin_unlock(&rnp_old->fqslock);
 	if (READ_ONCE(rsp->gp_flags) & RCU_GP_FLAG_FQS) {
 		rsp->n_force_qs_lh++;
-		raw_spin_unlock_irqrestore(&rnp_old->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);
 		return;  /* Someone beat us to it. */
 	}
 	WRITE_ONCE(rsp->gp_flags, READ_ONCE(rsp->gp_flags) | RCU_GP_FLAG_FQS);
-	raw_spin_unlock_irqrestore(&rnp_old->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);
 	rcu_gp_kthread_wake(rsp);
 }
 
@@ -2925,7 +2926,7 @@ __rcu_process_callbacks(struct rcu_state *rsp)
 	if (cpu_needs_another_gp(rsp, rdp)) {
 		raw_spin_lock_rcu_node(rcu_get_root(rsp)); /* irqs disabled. */
 		needwake = rcu_start_gp(rsp);
-		raw_spin_unlock_irqrestore(&rcu_get_root(rsp)->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rcu_get_root(rsp), flags);
 		if (needwake)
 			rcu_gp_kthread_wake(rsp);
 	} else {
@@ -3016,7 +3017,7 @@ static void __call_rcu_core(struct rcu_state *rsp, struct rcu_data *rdp,
 
 			raw_spin_lock_rcu_node(rnp_root);
 			needwake = rcu_start_gp(rsp);
-			raw_spin_unlock(&rnp_root->lock);
+			raw_spin_unlock_rcu_node(rnp_root);
 			if (needwake)
 				rcu_gp_kthread_wake(rsp);
 		} else {
@@ -3436,14 +3437,14 @@ static void sync_exp_reset_tree_hotplug(struct rcu_state *rsp)
 	rcu_for_each_leaf_node(rsp, rnp) {
 		raw_spin_lock_irqsave_rcu_node(rnp, flags);
 		if (rnp->expmaskinit == rnp->expmaskinitnext) {
-			raw_spin_unlock_irqrestore(&rnp->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 			continue;  /* No new CPUs, nothing to do. */
 		}
 
 		/* Update this node's mask, track old value for propagation. */
 		oldmask = rnp->expmaskinit;
 		rnp->expmaskinit = rnp->expmaskinitnext;
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 
 		/* If was already nonzero, nothing to propagate. */
 		if (oldmask)
@@ -3458,7 +3459,7 @@ static void sync_exp_reset_tree_hotplug(struct rcu_state *rsp)
 			if (rnp_up->expmaskinit)
 				done = true;
 			rnp_up->expmaskinit |= mask;
-			raw_spin_unlock_irqrestore(&rnp_up->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp_up, flags);
 			if (done)
 				break;
 			mask = rnp_up->grpmask;
@@ -3481,7 +3482,7 @@ static void __maybe_unused sync_exp_reset_tree(struct rcu_state *rsp)
 		raw_spin_lock_irqsave_rcu_node(rnp, flags);
 		WARN_ON_ONCE(rnp->expmask);
 		rnp->expmask = rnp->expmaskinit;
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	}
 }
 
@@ -3522,11 +3523,11 @@ static void __rcu_report_exp_rnp(struct rcu_state *rsp, struct rcu_node *rnp,
 			if (!rnp->expmask)
 				rcu_initiate_boost(rnp, flags);
 			else
-				raw_spin_unlock_irqrestore(&rnp->lock, flags);
+				raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 			break;
 		}
 		if (rnp->parent == NULL) {
-			raw_spin_unlock_irqrestore(&rnp->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 			if (wake) {
 				smp_mb(); /* EGP done before wake_up(). */
 				wake_up(&rsp->expedited_wq);
@@ -3534,7 +3535,7 @@ static void __rcu_report_exp_rnp(struct rcu_state *rsp, struct rcu_node *rnp,
 			break;
 		}
 		mask = rnp->grpmask;
-		raw_spin_unlock(&rnp->lock); /* irqs remain disabled */
+		raw_spin_unlock_rcu_node(rnp); /* irqs remain disabled */
 		rnp = rnp->parent;
 		raw_spin_lock_rcu_node(rnp); /* irqs already disabled */
 		WARN_ON_ONCE(!(rnp->expmask & mask));
@@ -3569,7 +3570,7 @@ static void rcu_report_exp_cpu_mult(struct rcu_state *rsp, struct rcu_node *rnp,
 
 	raw_spin_lock_irqsave_rcu_node(rnp, flags);
 	if (!(rnp->expmask & mask)) {
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		return;
 	}
 	rnp->expmask &= ~mask;
@@ -3730,7 +3731,7 @@ static void sync_rcu_exp_select_cpus(struct rcu_state *rsp,
 		 */
 		if (rcu_preempt_has_tasks(rnp))
 			rnp->exp_tasks = rnp->blkd_tasks.next;
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 
 		/* IPI the remaining CPUs for expedited quiescent state. */
 		mask = 1;
@@ -3747,7 +3748,7 @@ retry_ipi:
 			raw_spin_lock_irqsave_rcu_node(rnp, flags);
 			if (cpu_online(cpu) &&
 			    (rnp->expmask & mask)) {
-				raw_spin_unlock_irqrestore(&rnp->lock, flags);
+				raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 				schedule_timeout_uninterruptible(1);
 				if (cpu_online(cpu) &&
 				    (rnp->expmask & mask))
@@ -3756,7 +3757,7 @@ retry_ipi:
 			}
 			if (!(rnp->expmask & mask))
 				mask_ofl_ipi &= ~mask;
-			raw_spin_unlock_irqrestore(&rnp->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		}
 		/* Report quiescent states for those that went offline. */
 		mask_ofl_test |= mask_ofl_ipi;
@@ -4163,7 +4164,7 @@ static void rcu_init_new_rnp(struct rcu_node *rnp_leaf)
 			return;
 		raw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */
 		rnp->qsmaskinit |= mask;
-		raw_spin_unlock(&rnp->lock); /* Interrupts remain disabled. */
+		raw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */
 	}
 }
 
@@ -4187,7 +4188,7 @@ rcu_boot_init_percpu_data(int cpu, struct rcu_state *rsp)
 	rdp->rsp = rsp;
 	mutex_init(&rdp->exp_funnel_mutex);
 	rcu_boot_init_nocb_percpu_data(rdp);
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 }
 
 /*
@@ -4215,7 +4216,7 @@ rcu_init_percpu_data(int cpu, struct rcu_state *rsp)
 	rcu_sysidle_init_percpu_data(rdp->dynticks);
 	atomic_set(&rdp->dynticks->dynticks,
 		   (atomic_read(&rdp->dynticks->dynticks) & ~0x1) + 1);
-	raw_spin_unlock(&rnp->lock);		/* irqs remain disabled. */
+	raw_spin_unlock_rcu_node(rnp);		/* irqs remain disabled. */
 
 	/*
 	 * Add CPU to leaf rcu_node pending-online bitmask.  Any needed
@@ -4236,7 +4237,7 @@ rcu_init_percpu_data(int cpu, struct rcu_state *rsp)
 	rdp->rcu_qs_ctr_snap = per_cpu(rcu_qs_ctr, cpu);
 	rdp->core_needs_qs = false;
 	trace_rcu_grace_period(rsp->name, rdp->gpnum, TPS("cpuonl"));
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 }
 
 static void rcu_prepare_cpu(int cpu)
@@ -4358,7 +4359,7 @@ static int __init rcu_spawn_gp_kthread(void)
 			sp.sched_priority = kthread_prio;
 			sched_setscheduler_nocheck(t, SCHED_FIFO, &sp);
 		}
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		wake_up_process(t);
 	}
 	rcu_spawn_nocb_kthreads();
@@ -4449,8 +4450,8 @@ static void __init rcu_init_one(struct rcu_state *rsp)
 		cpustride *= levelspread[i];
 		rnp = rsp->level[i];
 		for (j = 0; j < levelcnt[i]; j++, rnp++) {
-			raw_spin_lock_init(&rnp->lock);
-			lockdep_set_class_and_name(&rnp->lock,
+			raw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));
+			lockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),
 						   &rcu_node_class[i], buf[i]);
 			raw_spin_lock_init(&rnp->fqslock);
 			lockdep_set_class_and_name(&rnp->fqslock,
diff --git a/kernel/rcu/tree.h b/kernel/rcu/tree.h
index 83360b4..4886d6a 100644
--- a/kernel/rcu/tree.h
+++ b/kernel/rcu/tree.h
@@ -149,8 +149,9 @@ struct rcu_dynticks {
  * Definition for node within the RCU grace-period-detection hierarchy.
  */
 struct rcu_node {
-	raw_spinlock_t lock;	/* Root rcu_node's lock protects some */
-				/*  rcu_state fields as well as following. */
+	raw_spinlock_t __private lock;	/* Root rcu_node's lock protects */
+					/*  some rcu_state fields as well as */
+					/*  following. */
 	unsigned long gpnum;	/* Current grace period for this node. */
 				/*  This will either be equal to or one */
 				/*  behind the root rcu_node's gpnum. */
@@ -680,7 +681,7 @@ static inline void rcu_nocb_q_lengths(struct rcu_data *rdp, long *ql, long *qll)
 #endif /* #else #ifdef CONFIG_PPC */
 
 /*
- * Wrappers for the rcu_node::lock acquire.
+ * Wrappers for the rcu_node::lock acquire and release.
  *
  * Because the rcu_nodes form a tree, the tree traversal locking will observe
  * different lock values, this in turn means that an UNLOCK of one level
@@ -689,29 +690,48 @@ static inline void rcu_nocb_q_lengths(struct rcu_data *rdp, long *ql, long *qll)
  *
  * In order to restore full ordering between tree levels, augment the regular
  * lock acquire functions with smp_mb__after_unlock_lock().
+ *
+ * As ->lock of struct rcu_node is a __private field, therefore one should use
+ * these wrappers rather than directly call raw_spin_{lock,unlock}* on ->lock.
  */
 static inline void raw_spin_lock_rcu_node(struct rcu_node *rnp)
 {
-	raw_spin_lock(&rnp->lock);
+	raw_spin_lock(&ACCESS_PRIVATE(rnp, lock));
 	smp_mb__after_unlock_lock();
 }
 
+static inline void raw_spin_unlock_rcu_node(struct rcu_node *rnp)
+{
+	raw_spin_unlock(&ACCESS_PRIVATE(rnp, lock));
+}
+
 static inline void raw_spin_lock_irq_rcu_node(struct rcu_node *rnp)
 {
-	raw_spin_lock_irq(&rnp->lock);
+	raw_spin_lock_irq(&ACCESS_PRIVATE(rnp, lock));
 	smp_mb__after_unlock_lock();
 }
 
-#define raw_spin_lock_irqsave_rcu_node(rnp, flags)	\
-do {							\
-	typecheck(unsigned long, flags);		\
-	raw_spin_lock_irqsave(&(rnp)->lock, flags);	\
-	smp_mb__after_unlock_lock();			\
+static inline void raw_spin_unlock_irq_rcu_node(struct rcu_node *rnp)
+{
+	raw_spin_unlock_irq(&ACCESS_PRIVATE(rnp, lock));
+}
+
+#define raw_spin_lock_irqsave_rcu_node(rnp, flags)			\
+do {									\
+	typecheck(unsigned long, flags);				\
+	raw_spin_lock_irqsave(&ACCESS_PRIVATE(rnp, lock), flags);	\
+	smp_mb__after_unlock_lock();					\
+} while (0)
+
+#define raw_spin_unlock_irqrestore_rcu_node(rnp, flags)			\
+do {									\
+	typecheck(unsigned long, flags);				\
+	raw_spin_unlock_irqrestore(&ACCESS_PRIVATE(rnp, lock), flags);	\
 } while (0)
 
 static inline bool raw_spin_trylock_rcu_node(struct rcu_node *rnp)
 {
-	bool locked = raw_spin_trylock(&rnp->lock);
+	bool locked = raw_spin_trylock(&ACCESS_PRIVATE(rnp, lock));
 
 	if (locked)
 		smp_mb__after_unlock_lock();
diff --git a/kernel/rcu/tree_plugin.h b/kernel/rcu/tree_plugin.h
index 9467a8b..0d51a67 100644
--- a/kernel/rcu/tree_plugin.h
+++ b/kernel/rcu/tree_plugin.h
@@ -235,7 +235,7 @@ static void rcu_preempt_ctxt_queue(struct rcu_node *rnp, struct rcu_data *rdp)
 		rnp->gp_tasks = &t->rcu_node_entry;
 	if (!rnp->exp_tasks && (blkd_state & RCU_EXP_BLKD))
 		rnp->exp_tasks = &t->rcu_node_entry;
-	raw_spin_unlock(&rnp->lock); /* rrupts remain disabled. */
+	raw_spin_unlock_rcu_node(rnp); /* interrupts remain disabled. */
 
 	/*
 	 * Report the quiescent state for the expedited GP.  This expedited
@@ -489,7 +489,7 @@ void rcu_read_unlock_special(struct task_struct *t)
 							 !!rnp->gp_tasks);
 			rcu_report_unblock_qs_rnp(rcu_state_p, rnp, flags);
 		} else {
-			raw_spin_unlock_irqrestore(&rnp->lock, flags);
+			raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		}
 
 		/* Unboost if we were boosted. */
@@ -518,14 +518,14 @@ static void rcu_print_detail_task_stall_rnp(struct rcu_node *rnp)
 
 	raw_spin_lock_irqsave_rcu_node(rnp, flags);
 	if (!rcu_preempt_blocked_readers_cgp(rnp)) {
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		return;
 	}
 	t = list_entry(rnp->gp_tasks->prev,
 		       struct task_struct, rcu_node_entry);
 	list_for_each_entry_continue(t, &rnp->blkd_tasks, rcu_node_entry)
 		sched_show_task(t);
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 }
 
 /*
@@ -991,7 +991,7 @@ static int rcu_boost(struct rcu_node *rnp)
 	 * might exit their RCU read-side critical sections on their own.
 	 */
 	if (rnp->exp_tasks == NULL && rnp->boost_tasks == NULL) {
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		return 0;
 	}
 
@@ -1028,7 +1028,7 @@ static int rcu_boost(struct rcu_node *rnp)
 	 */
 	t = container_of(tb, struct task_struct, rcu_node_entry);
 	rt_mutex_init_proxy_locked(&rnp->boost_mtx, t);
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	/* Lock only for side effect: boosts task t's priority. */
 	rt_mutex_lock(&rnp->boost_mtx);
 	rt_mutex_unlock(&rnp->boost_mtx);  /* Then keep lockdep happy. */
@@ -1088,7 +1088,7 @@ static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)
 
 	if (!rcu_preempt_blocked_readers_cgp(rnp) && rnp->exp_tasks == NULL) {
 		rnp->n_balk_exp_gp_tasks++;
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		return;
 	}
 	if (rnp->exp_tasks != NULL ||
@@ -1098,13 +1098,13 @@ static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)
 	     ULONG_CMP_GE(jiffies, rnp->boost_time))) {
 		if (rnp->exp_tasks == NULL)
 			rnp->boost_tasks = rnp->gp_tasks;
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		t = rnp->boost_kthread_task;
 		if (t)
 			rcu_wake_cond(t, rnp->boost_kthread_status);
 	} else {
 		rcu_initiate_boost_trace(rnp);
-		raw_spin_unlock_irqrestore(&rnp->lock, flags);
+		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	}
 }
 
@@ -1172,7 +1172,7 @@ static int rcu_spawn_one_boost_kthread(struct rcu_state *rsp,
 		return PTR_ERR(t);
 	raw_spin_lock_irqsave_rcu_node(rnp, flags);
 	rnp->boost_kthread_task = t;
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	sp.sched_priority = kthread_prio;
 	sched_setscheduler_nocheck(t, SCHED_FIFO, &sp);
 	wake_up_process(t); /* get to TASK_INTERRUPTIBLE quickly. */
@@ -1308,7 +1308,7 @@ static void rcu_prepare_kthreads(int cpu)
 static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)
 	__releases(rnp->lock)
 {
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 }
 
 static void invoke_rcu_callbacks_kthread(void)
@@ -1559,7 +1559,7 @@ static void rcu_prepare_for_idle(void)
 		rnp = rdp->mynode;
 		raw_spin_lock_rcu_node(rnp); /* irqs already disabled. */
 		needwake = rcu_accelerate_cbs(rsp, rnp, rdp);
-		raw_spin_unlock(&rnp->lock); /* irqs remain disabled. */
+		raw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */
 		if (needwake)
 			rcu_gp_kthread_wake(rsp);
 	}
@@ -2059,7 +2059,7 @@ static void rcu_nocb_wait_gp(struct rcu_data *rdp)
 
 	raw_spin_lock_irqsave_rcu_node(rnp, flags);
 	needwake = rcu_start_future_gp(rnp, rdp, &c);
-	raw_spin_unlock_irqrestore(&rnp->lock, flags);
+	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 	if (needwake)
 		rcu_gp_kthread_wake(rdp->rsp);
 
-- 
2.6.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 3/3] irq: Privatize irq_common_data::state_use_accessors ===

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-sparse
Subject: Re: [RFC 3/3] irq: Privatize irq_common_data::state_use_accessors
Date: Tue, 15 Dec 2015 00:56:25 +0000
Message-ID: <20151215005625.GK1072 () fixme-laptop ! cn ! ibm ! com>
--------------------

--0hHDr/TIsw4o3iPK
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Mon, Dec 14, 2015 at 04:59:45PM +0100, Thomas Gleixner wrote:
> On Mon, 14 Dec 2015, Boqun Feng wrote:
> > Probably something like this(untested, only run "make kernel/irq/")?
> >=20
> > Subject: [RFC v2 3/3] irq: Privatize irq_common_data::state_use_accesso=
rs
> >=20
> > According to Peter Zijlstra, irq_common_data::state_use_accessors is not
> > designed for public use. Therefore make it private so that people who
> > write code accessing it directly will get blamed by sparse.
> >=20
> > Also macro __irqd_to_state() is for _designed_ accesses to irq_data's
> > state only, it's better to limit its scope, therefore put all its
> > callers together and #undef it after use.
>=20
> That exposes the set/clr functions to the global header file, while
> today those are restricted to the core internals header. There is a
> reason why I did not make them public ....
>=20

Oops, I wasn't aware of that... then I guess we should define and undef
__irqd_to_state twice, in include/linux/irq.h and in
kernel/irq/internals.h, right?

Regards,
Boqun

--0hHDr/TIsw4o3iPK
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQEcBAABCAAGBQJWb2UzAAoJEEl56MO1B/q40vEH/R/eD8QUp/rmVcz3UaaveFDJ
iG9zZOzTdH0zLshMqUBzA5H4bfwFAnBZMM40QNcHYiTvGpgjCHss7TmXbG3BFi/9
Y2uOWI+ashuItLjXMdldriubRklty5z2GJki/3eqgrwrUmyU50SfbjI17zEtxn0t
GMZj8sJHMY76x/YLxEY+SEyMH95zplYPPm9826kZeMFWNV0n70ZKnWAL9gbD4dcA
1Qjz5J2DIBA7XxuJ15qg3l4GkLeNmiQd/P69d9f4AONB1rqwVCE4EsUbuj8AHjMt
jFyxfekdRaIb70YlBBKM62DNKUMU4buv3DPGFsGou3mEDROO1xvlZAR/gmHjzrg=
=D/Ip
-----END PGP SIGNATURE-----

--0hHDr/TIsw4o3iPK--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC v2 0/3] sparse: Introduce __private to privatize members of structs ===

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-sparse
Subject: [RFC v2 0/3] sparse: Introduce __private to privatize members of structs
Date: Tue, 29 Dec 2015 04:18:45 +0000
Message-ID: <1451362728-18961-1-git-send-email-boqun.feng () gmail ! com>
--------------------
Hi all,

This is v2 of __private.

Link for v1: http://marc.info/?l=linux-sparse&m=144988906932520&w=2

Change since v1:

*	#undef __irqd_to_state after used (Peter Zijlstra)


This patchset introduces a __private modifier for sparse to detect misuses of
private members of structs. This could make maintenace a little easier and
prevent some potential bugs.


This patchset consists of three patches:

1.	Introduce __private and related macro, also improve compiler.h a litte
	bit

2.	Privatize rcu_node::lock

3.	Privatize irq_common_data::state_use_accessors

This patchset is against

	-rcu/rcu/next	c95a158356397844a5a6deb0bd58758084f891df

because it depends on commits:
	
	"rcu: Create transitive rnp->lock acquisition functions"
and
	"rcu: Add transitivity to remaining rcu_node ->lock acquisitions


Tested by 0day.

Looking forward to any suggestion, question and comment ;-)

Regards,
Boqun
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC v2 1/3] sparse: Add __private to privatize members of structs ===

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-sparse
Subject: [RFC v2 1/3] sparse: Add __private to privatize members of structs
Date: Tue, 29 Dec 2015 04:18:46 +0000
Message-ID: <1451362728-18961-2-git-send-email-boqun.feng () gmail ! com>
--------------------
In C programming language, we don't have a easy way to privatize a
member of a structure. However in kernel, sometimes there is a need to
privatize a member in case of potential bugs or misuses.

Fortunately, the noderef attribute of sparse is a way to privatize a
member, as by defining a member as noderef, the address-of operator on
the member will produce a noderef pointer to that member, and if anyone
wants to dereference that kind of pointers to read or modify the member,
sparse will yell.

Based on this, __private modifier and related operation ACCESS_PRIVATE()
are introduced, which could help detect undesigned public uses of
private members of structs. Here is an example of sparse's output if it
detect an undersigned public use:

| kernel/rcu/tree.c:4453:25: warning: incorrect type in argument 1 (different modifiers)
| kernel/rcu/tree.c:4453:25:    expected struct raw_spinlock [usertype] *lock
| kernel/rcu/tree.c:4453:25:    got struct raw_spinlock [noderef] *<noident>

Also, this patch improves compiler.h a little bit by adding comments for
"#else" and "#endif".

Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
---
 include/linux/compiler.h | 12 ++++++++----
 scripts/checkpatch.pl    |  3 ++-
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 4dac103..e4a4fb1 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -20,12 +20,14 @@
 # define __pmem		__attribute__((noderef, address_space(5)))
 #ifdef CONFIG_SPARSE_RCU_POINTER
 # define __rcu		__attribute__((noderef, address_space(4)))
-#else
+#else /* CONFIG_SPARSE_RCU_POINTER */
 # define __rcu
-#endif
+#endif /* CONFIG_SPARSE_RCU_POINTER */
+# define __private	__attribute__((noderef))
 extern void __chk_user_ptr(const volatile void __user *);
 extern void __chk_io_ptr(const volatile void __iomem *);
-#else
+# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))
+#else /* __CHECKER__ */
 # define __user
 # define __kernel
 # define __safe
@@ -44,7 +46,9 @@ extern void __chk_io_ptr(const volatile void __iomem *);
 # define __percpu
 # define __rcu
 # define __pmem
-#endif
+# define __private
+# define ACCESS_PRIVATE(p, member) ((p)->member)
+#endif /* __CHECKER__ */
 
 /* Indirect macros required for expanded argument pasting, eg. __LINE__. */
 #define ___PASTE(a,b) a##b
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index 2b3c228..fda1c61 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -269,7 +269,8 @@ our $Sparse	= qr{
 			__init_refok|
 			__kprobes|
 			__ref|
-			__rcu
+			__rcu|
+			__private
 		}x;
 our $InitAttributePrefix = qr{__(?:mem|cpu|dev|net_|)};
 our $InitAttributeData = qr{$InitAttributePrefix(?:initdata\b)};
-- 
2.6.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC v2 3/3] irq: Privatize irq_common_data::state_use_accessors ===

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-sparse
Subject: [RFC v2 3/3] irq: Privatize irq_common_data::state_use_accessors
Date: Tue, 29 Dec 2015 04:18:48 +0000
Message-ID: <1451362728-18961-4-git-send-email-boqun.feng () gmail ! com>
--------------------
irq_common_data::state_use_accessors is not designed for public use.
Therefore make it private so that people who write code accessing it
directly will get blamed by sparse. Also #undef the macro
__irqd_to_state after used in header files, so that the macro can't be
misused.

Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
---
 include/linux/irq.h    | 6 ++++--
 kernel/irq/internals.h | 4 ++++
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3c1c967..cd14cd4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -137,7 +137,7 @@ struct irq_domain;
  * @msi_desc:		MSI descriptor
  */
 struct irq_common_data {
-	unsigned int		state_use_accessors;
+	unsigned int		__private state_use_accessors;
 #ifdef CONFIG_NUMA
 	unsigned int		node;
 #endif
@@ -208,7 +208,7 @@ enum {
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
 };
 
-#define __irqd_to_state(d)		((d)->common->state_use_accessors)
+#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
 {
@@ -299,6 +299,8 @@ static inline void irqd_clr_forwarded_to_vcpu(struct irq_data *d)
 	__irqd_to_state(d) &= ~IRQD_FORWARDED_TO_VCPU;
 }
 
+#undef __irqd_to_state
+
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
 {
 	return d->hwirq;
diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index fcab63c..3d18293 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -160,6 +160,8 @@ irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)
 	__irq_put_desc_unlock(desc, flags, false);
 }
 
+#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
+
 /*
  * Manipulation functions for irq_data.state
  */
@@ -188,6 +190,8 @@ static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
 	return __irqd_to_state(d) & mask;
 }
 
+#undef __irqd_to_state
+
 static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)
 {
 	__this_cpu_inc(*desc->kstat_irqs);
-- 
2.6.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Boqun Feng <boqun.feng () gmail ! com>
To: linux-kernel
Subject: [RFC v2 3/3] irq: Privatize irq_common_data::state_use_accessors
Date: Tue, 29 Dec 2015 04:18:48 +0000
Message-ID: <1451362728-18961-4-git-send-email-boqun.feng () gmail ! com>
--------------------
irq_common_data::state_use_accessors is not designed for public use.
Therefore make it private so that people who write code accessing it
directly will get blamed by sparse. Also #undef the macro
__irqd_to_state after used in header files, so that the macro can't be
misused.

Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
---
 include/linux/irq.h    | 6 ++++--
 kernel/irq/internals.h | 4 ++++
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3c1c967..cd14cd4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -137,7 +137,7 @@ struct irq_domain;
  * @msi_desc:		MSI descriptor
  */
 struct irq_common_data {
-	unsigned int		state_use_accessors;
+	unsigned int		__private state_use_accessors;
 #ifdef CONFIG_NUMA
 	unsigned int		node;
 #endif
@@ -208,7 +208,7 @@ enum {
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
 };
 
-#define __irqd_to_state(d)		((d)->common->state_use_accessors)
+#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
 {
@@ -299,6 +299,8 @@ static inline void irqd_clr_forwarded_to_vcpu(struct irq_data *d)
 	__irqd_to_state(d) &= ~IRQD_FORWARDED_TO_VCPU;
 }
 
+#undef __irqd_to_state
+
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
 {
 	return d->hwirq;
diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index fcab63c..3d18293 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -160,6 +160,8 @@ irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)
 	__irq_put_desc_unlock(desc, flags, false);
 }
 
+#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
+
 /*
  * Manipulation functions for irq_data.state
  */
@@ -188,6 +190,8 @@ static inline bool irqd_has_set(struct irq_data *d, unsigned int mask)
 	return __irqd_to_state(d) & mask;
 }
 
+#undef __irqd_to_state
+
 static inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)
 {
 	__this_cpu_inc(*desc->kstat_irqs);
-- 
2.6.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Thomas Gleixner <tglx () linutronix ! de>
To: linux-kernel
Subject: Re: [RFC v2 3/3] irq: Privatize irq_common_data::state_use_accessors
Date: Tue, 29 Dec 2015 09:46:39 +0000
Message-ID: <alpine.DEB.2.11.1512291046250.28591 () nanos>
--------------------
On Tue, 29 Dec 2015, Boqun Feng wrote:

> irq_common_data::state_use_accessors is not designed for public use.
> Therefore make it private so that people who write code accessing it
> directly will get blamed by sparse. Also #undef the macro
> __irqd_to_state after used in header files, so that the macro can't be
> misused.
> 
> Signed-off-by: Boqun Feng <boqun.feng@gmail.com>

Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [kbuild-all] [kvm:queue 27/38] arch/x86/kvm/hyperv.c:186:41: sparse: incorrect type in argument ===

From: Fengguang Wu <fengguang.wu () intel ! com>
To: linux-sparse
Subject: Re: [kbuild-all] [kvm:queue 27/38] arch/x86/kvm/hyperv.c:186:41: sparse: incorrect type in argument 
Date: Fri, 18 Sep 2015 15:06:44 +0000
Message-ID: <20150918150644.GB20668 () wfg-t540p ! sh ! intel ! com>
--------------------
[CC sparse people]

On Fri, Sep 18, 2015 at 04:41:56PM +0200, Paolo Bonzini wrote:
> 
> 
> On 18/09/2015 16:40, Roman Kagan wrote:
> > typedef unsigned long __nocast cputime_t;
> > 
> > extern void task_cputime_adjusted(cputime_t *);
> > extern void current_task_runtime_100ns(void);
> > 
> > void current_task_runtime_100ns(void)
> > {
> >         cputime_t utime;
> > 
> >         task_cputime_adjusted(&utime);
> > }
> > %%% gcc -c x.c -Wall -Werror -O2; echo $?
> > 0
> > %%% sparse x.c
> > x.c:16:32: warning: incorrect type in argument 1 (different modifiers)
> > x.c:16:32:    expected unsigned long [nocast] [usertype] *<noident>
> > x.c:16:32:    got unsigned long *<noident>
> > x.c:16:32: warning: implicit cast to nocast type
> > 
> > Looks like a sparse bug to me.
> 
> Indeed...
> 
> Paolo
> _______________________________________________
> kbuild-all mailing list
> kbuild-all@lists.01.org
> https://lists.01.org/mailman/listinfo/kbuild-all
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: from: Mitesh Shah ===

From: "Mitesh Shah" <mpshah () gmail ! com>
To: linux-sparse
Subject: from: Mitesh Shah
Date: Fri, 03 Jul 2015 02:27:42 +0000
Message-ID: <D6935020-B66A-42E4-912B-9F4BF9E178C5 () procurementadvies ! nl>
--------------------

Sup Linux

http://greaterforyou.com/profile.php?higher=8gm4cxh9dcvwnb5ywppn





Mitesh Shah


Sent from my iPhone
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh Shah" <mpshah () gmail ! com>
To: linux-sparse
Subject: from: Mitesh Shah
Date: Wed, 02 Sep 2015 11:29:58 +0000
Message-ID: <2913269A-5948-473E-9927-7735D21A2792 () casapellas ! com ! ni>
--------------------
Hi Linux

http://northalbanycarshow.com/sure.php?evening=nhpvr9h7r0s7




Linux
mpshah@gmail.com

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: rhashtable sparse annotations? ===

From: Andreas Gruenbacher <agruenba () redhat ! com>
To: linux-sparse
Subject: Re: rhashtable sparse annotations?
Date: Wed, 09 Sep 2015 23:32:02 +0000
Message-ID: <CAHc6FU6GSLb1tY3i8+d1-3WLnesdT6M6PMqFNYKFG6LzHJvcwQ () mail ! gmail ! com>
--------------------
2015-09-09 23:13 GMT+02:00 Thomas Graf <tgraf@suug.ch>:
> On 09/09/15 at 04:14pm, Andreas Gruenbacher wrote:
>> I'm hitting the same kinds of errors in the gfs2 rhashtable code as
>> well, but it doesn't seem to happen in the network code. Does this
>> need fixing in rhashtable?
>
> What's the rhashtable related sparse error for gfs2?

Mmh, it seems I was mixing things up: I do get the same kind of error
as in dcache.c, but the code is not rhashtable related, it's also a
hlist_bl_for_each_entry_rcu() loop. Sorry for the rhashtable noise,
Thomas.

Does anybody know how to fix the dcache.c sparse errors?

Thanks,
Andreas
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse error: got __int128 ===

From: Tony Camuso <tcamuso () redhat ! com>
To: linux-sparse
Subject: sparse error: got __int128
Date: Sun, 18 Jan 2015 12:28:20 +0000
Message-ID: <54BBA6E4.7020506 () redhat ! com>
--------------------
Example:

drivers/acpi/processor_core.i:6109:26: error: Expected ) at end of cast operator
drivers/acpi/processor_core.i:6109:26: error: got __int128

Passing a large list of files causes the error count to exceed 100, whereupon
sparse exits.

The offending source is in include/linux/math64.h

#if defined(CONFIG_ARCH_SUPPORTS_INT128) && defined(__SIZEOF_INT128__)

#ifndef mul_u64_u32_shr
static inline u64 mul_u64_u32_shr(u64 a, u32 mul, unsigned int shift)
{
         return (u64)(((unsigned __int128)a * mul) >> shift);
}
#endif /* mul_u64_u32_shr */

Of course, disabling 64-bit kernel in .config removes the problem, but this is
an unacceptable solution.

I can't see clearly why sparse should flag this as an error.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: new feature " multiple initializers" has false positives on MODULE_ALIAS ===

From: Christian Borntraeger <borntraeger () de ! ibm ! com>
To: linux-sparse
Subject: sparse: new feature " multiple initializers" has false positives on MODULE_ALIAS
Date: Thu, 22 Jan 2015 20:31:10 +0000
Message-ID: <54C15E0E.4000008 () de ! ibm ! com>
--------------------
Linus, Christopher,

Commit  0f25c6a78e08fdc15af5e599d836fa24349c042f ("Add warning about duplicate initializers") has a false positive on arch/s390/kvm/kvm-s390.c

  CHECK   arch/s390/kvm/kvm-s390.c
arch/s390/kvm/kvm-s390.c:1823:1: error: symbol '__UNIQUE_ID_alias__COUNTER__' has multiple initializers (originally initialized at arch/s390/kvm/kvm-s390.c:1822)

1822: MODULE_ALIAS_MISCDEV(KVM_MINOR);
1823: MODULE_ALIAS("devname:kvm");


Preprocessing with gcc gives
static const char __UNIQUE_ID_alias0[] __attribute__((__used__)) __attribute__((section(".modinfo"), unused, aligned(1))) = "alias" "=" "char-major-" "10" "-" "232";
static const char __UNIQUE_ID_alias1[] __attribute__((__used__)) __attribute__((section(".modinfo"), unused, aligned(1))) = "alias" "=" "devname:kvm";

so alias0 and alias1 instead of __COUNTER__.
I never heard of __COUNTER__ before, so I guess its some gcc magic that sparse should mimic..

Christian

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

