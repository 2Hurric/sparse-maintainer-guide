--- Emails for Year 2009 ---

=== Thread: [No Subject] ===

From: Erik de Castro Lopo <mle+tools () mega-nerd ! com>
To: linux-sparse
Subject: 
Date: Fri, 20 Feb 2009 21:53:44 +0000
Message-ID: <20090221085344.53ccaa35.mle+tools () mega-nerd ! com>
--------------------
subscribe linux-sparse

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: 'make install' target issues ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: 'make install' target issues
Date: Wed, 28 Oct 2009 03:04:26 +0000
Message-ID: <70318cbf0910272004s2a5aba06r949a1f76445dfa8c () mail ! gmail ! com>
--------------------
On Tue, Oct 27, 2009 at 5:37 PM, Dan McGee <dan@archlinux.org> wrote:
> commit bb54f9a83eaa7c683e292a90fdfeebb54381c313
> Author: Christopher Li <sparse@chrisli.org>
> Date:   Fri Dec 26 01:37:01 2008 -0800
> Subject: Clean up Makefile long lines
>
> Is there something I am missing? By default, the install program
> installs all files with rwxr-xr-x. I'd be happy to submit a patch to
> fix this.

That is a bug. Thanks for catching it.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Antwort: Re: [PATCH] Fix implicit cast to float (Was:Re: Initializing float ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Antwort: Re: [PATCH] Fix implicit cast to float (Was:Re: Initializing float
Date: Mon, 09 Feb 2009 13:38:55 +0000
Message-ID: <OF56CB73D3.5EA2DB0D-ONC1257558.00499FF2-C1257558.004AEC1A () br-automation ! com>
--------------------
christ.li@gmail.com schrieb am 09.02.2009 08:37:50:

> On Fri, Feb 6, 2009 at 4:51 AM, Thomas Schmid
> <Thomas.Schmid@br-automation.com> wrote:
> > christ.li@gmail.com schrieb am 06.02.2009 05:15:37:
> > -       if (newtype->ctype.base_type != &fp_type) {
> > +       if (is_int_type(newtype)) {
> 
> I change your patch a little bit. The old logic of testing against float
> type is better. The type can be a pointer for example. Then using
> the long long value is more correct.
> 
> See the patch attached.
> 
> If there is not objections. I am going to apply this one.

Thank you for correcting, your changes work fine for me.

There's only a little problem with the patch,
patch breaks off in evaluate.c, cause there's no function "is_void_type" 
within...

Greetings
Thomas Schmid
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Braino in attribute_packed() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Braino in attribute_packed()
Date: Wed, 11 Mar 2009 15:45:47 +0000
Message-ID: <E1LhQct-0006sH-5W () ZenIV ! linux ! org ! uk>
--------------------

D'oh...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/parse.c b/parse.c
index f16d321..e2b47e3 100644
--- a/parse.c
+++ b/parse.c
@@ -943,7 +943,7 @@ static struct token *ignore_attribute(struct token *token, struct symbol *attr,
 
 static struct token *attribute_packed(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
-	if (!&ctx->ctype.alignment)
+	if (!ctx->ctype.alignment)
 		ctx->ctype.alignment = 1;
 	return token;
 }
-- 
1.5.6.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Braino in attribute_packed()
Date: Wed, 11 Mar 2009 19:39:32 +0000
Message-ID: <70318cbf0903111239x6c2cfed6ybc997c835500c3dc () mail ! gmail ! com>
--------------------
All applied.

Thanks!

Chris

On Wed, Mar 11, 2009 at 8:45 AM, Al Viro <viro@ftp.linux.org.uk> wrote:
>
> D'oh...
>
> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
> ---
>  parse.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)
>
> diff --git a/parse.c b/parse.c
> index f16d321..e2b47e3 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -943,7 +943,7 @@ static struct token *ignore_attribute(struct token *token, struct symbol *attr,
>
>  static struct token *attribute_packed(struct token *token, struct symbol *attr, struct decl_state *ctx)
>  {
> -       if (!&ctx->ctype.alignment)
> +       if (!ctx->ctype.alignment)
>                ctx->ctype.alignment = 1;
>        return token;
>  }
> --
> 1.5.6.5
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Declarations with typedef (Was: Re: Messing typedefs?) ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Declarations with typedef (Was: Re: Messing typedefs?)
Date: Fri, 20 Feb 2009 09:59:57 +0000
Message-ID: <OF43E68700.A0BC8190-ONC1257563.00349412-C1257563.0036E79A () br-automation ! com>
--------------------
The old thread "Messing typedefs" 
(http://marc.info/?l=linux-sparse&m=118156319806264) described strange 
behaviour:

>         typedef unsigned char  plcbit;
>         typedef unsigned char  USINT;
> 
>         USINT usVar1;
> 
> leads to a symbol "usVar1" with base_type->ident named "plcbit".

This has changed, but now I can't find any information inside symbol "
usVar1" that points to the used typedef .

How am I able to get the typedef a symbol is declared with - if it is 
declared with one?
Is there a way?

Greetings
Thomas Schmid


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Detect unused header files? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Tue, 28 Jul 2009 20:36:26 +0000
Message-ID: <70318cbf0907281336p47b68b5cg44a3e7206646cb80 () mail ! gmail ! com>
--------------------
On Tue, Jul 28, 2009 at 11:18 AM, Sam Ravnborg<sam@ravnborg.org> wrote:
> In the kernel we would like to avoid all
> unused include files.
> Especially in the headers we export to userspace.
>
> Are there any easy way we can use sparse to detect
> that a specific header file is not used?

I don't know a way to do that with current sparse.
We can implement some code for this.

We need to have a good definition of what is used.

> The header files I have in mind will be fully self-contained
> as they all include the header files they need to be used.

But a lot of case we have the header file is used in *another*
file.

>
> Sample:
>
> cat foo.h:
> #include <linux/types.h>
> #include <linux/swab.h>
>
> struct foo {
>        __u32 bar;
>        __u32 baz;
> };
>
> EOF
>
>
> Here <linux/swab.h> is obviously not used.
> And I would like sparse to flag this...

I don't think it is can be turn on by default.
What if some user space program want to include foo.h
and use the definitional inside "swab.h"? In that case it will
be OK. I don't think we can ban this kind of the usage case.

Looking at the header file itself is not good enough. It also depend
on how the user include it. What macro has been defined.
That will change the behavior of the header file as well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Tue, 28 Jul 2009 20:49:57 +0000
Message-ID: <70318cbf0907281349k72a71b8fyc10d80992e4b1db9 () mail ! gmail ! com>
--------------------
On Tue, Jul 28, 2009 at 1:36 PM, Robert P. J. Day<rpjday@crashcourse.ca> wrote:
> sure you can.  no one should be counting on the inclusion of header
> files by other header files (except possibly in unusual situations,
> which i can't even think of at the moment).  if your program needs the
> contents of a header file, it's your responsibility to include it.

The case I have in mind is that, some API level header file include some
internal header file for constant defines. For example:

drivers/ieee1394/host.h include drivers/ieee1394/csr.h.

The "csr.h" is just the register define. It is not used in this header file
itself. I did not check very closely, for augments sake pretend those
inline function are not there. It just have register defines.

Should the C program changed to include "csr.h" directly? I don't think so.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Tue, 28 Jul 2009 20:58:08 +0000
Message-ID: <20090728205808.GA20955 () merkur ! ravnborg ! org>
--------------------
On Tue, Jul 28, 2009 at 01:36:26PM -0700, Christopher Li wrote:
> On Tue, Jul 28, 2009 at 11:18 AM, Sam Ravnborg<sam@ravnborg.org> wrote:
> > In the kernel we would like to avoid all
> > unused include files.
> > Especially in the headers we export to userspace.
> >
> > Are there any easy way we can use sparse to detect
> > that a specific header file is not used?
> 
> I don't know a way to do that with current sparse.
> We can implement some code for this.

Would be great...
If you can give some general into I can maybe give
it a shot albeit I have only very limited sprase
hacking knowledge.

> 
> We need to have a good definition of what is used.

The short version...
The header file that include the file is dependent
on the included file.

So if we:
- use (check/test/reference) a macro from the file => used
- use a typedef/struct
- ...
then we need the included header file.

> 
> > The header files I have in mind will be fully self-contained
> > as they all include the header files they need to be used.
> 
> But a lot of case we have the header file is used in *another*
> file.
We do not care about this case...

The objective is to get the exported kernel headers as lean as possible.
This may occasionally break userland - but until now this has
been manageable.


If we apply this to kernel internal headers then we need to
do a bit of test builds to check things.
This is the same thing we do when we untange the include mess we have
today so we know what to do.
-next is btw a great help here.

If we do this inside spase or using a dedicated backend is not so important.
But adding this as a default=disabled option to sparse would be preferred.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Tue, 28 Jul 2009 21:04:04 +0000
Message-ID: <20090728210404.GA21187 () merkur ! ravnborg ! org>
--------------------
On Tue, Jul 28, 2009 at 01:49:57PM -0700, Christopher Li wrote:
> On Tue, Jul 28, 2009 at 1:36 PM, Robert P. J. Day<rpjday@crashcourse.ca> wrote:
> > sure you can.  no one should be counting on the inclusion of header
> > files by other header files (except possibly in unusual situations,
> > which i can't even think of at the moment).  if your program needs the
> > contents of a header file, it's your responsibility to include it.
> 
> The case I have in mind is that, some API level header file include some
> internal header file for constant defines. For example:
> 
> drivers/ieee1394/host.h include drivers/ieee1394/csr.h.
> 
> The "csr.h" is just the register define. It is not used in this header file
> itself. I did not check very closely, for augments sake pretend those
> inline function are not there. It just have register defines.
> 
> Should the C program changed to include "csr.h" directly? I don't think so.

Agreed on this one.

So we should add some intelligence when we 'fix' these warnings.
This is sometimes causing us troubles.

I need to see the results before I can judge if this will
be a big issue.

The first challenge will anyway to make all the header files self contained.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Tue, 28 Jul 2009 21:21:02 +0000
Message-ID: <70318cbf0907281421x431d896dla3dfd9862ad3dd8a () mail ! gmail ! com>
--------------------
On Tue, Jul 28, 2009 at 1:58 PM, Sam Ravnborg<sam@ravnborg.org> wrote:
> Would be great...
> If you can give some general into I can maybe give
> it a shot albeit I have only very limited sprase
> hacking knowledge.

I think the starting point is lookup_symbol().
Currently lookup_symbol does not care about where is
this symbol used. There is "sym->used" already. But it does
not help much in this case because sym->used did not distingish
the usage from the same file vs from other file.  We need to add
information some how. May be one more argument for the source
of the lookup.

>
> So if we:
> - use (check/test/reference) a macro from the file => used
> - use a typedef/struct

lookup_symbol() covers all of those. But there is annoying
part as well. For example. If the same header file get include
twice, the later one will consider using the first one because
it lookup the __HEAD_FILE_NAME__ macro to avoid duplicating
include.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 30 Jul 2009 10:55:46 +0000
Message-ID: <70318cbf0907300355h5cb34671ha452433c4e0b5324 () mail ! gmail ! com>
--------------------
Hi Sam,

I create a branch "unused-include-files" for some experiment patch.
Some thing quick and dirty to find out what works and what doesn't.
No where near submitting quality.

http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=shortlog;h=unused-include-files

Currently it just report all unused stream.

for your example foo.h:

#include <linux/types.h>
#include <linux/string.h>

struct foo {
       __u32 bar;
       __u32 baz;
};


$ ./sparse foo.h
unused stream preprocessor(1)
unused stream foo.h(2)
unused stream preprocessor(3)
unused stream /usr/include/linux/stddef.h(6)
unused stream /usr/include/asm/posix_types.h(7)
unused stream /usr/include/asm/types.h(9)
unused stream /usr/include/linux/string.h(11)
unused stream /usr/include/string.h(12)
unused stream /usr/include/features.h(13)
unused stream /usr/include/sys/cdefs.h(14)
unused stream /usr/include/bits/wordsize.h(15)
unused stream /usr/include/gnu/stubs.h(16)
unused stream /usr/include/bits/wordsize.h(17)
unused stream /usr/include/gnu/stubs-32.h(18)
unused stream /usr/lib/gcc/x86_64-redhat-linux/4.3.0//include/stddef.h(19)

Just as I expected. Lost of noise :-)

BTW, use "-vstream" to show the actual symbol usage detail.

Comments?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 30 Jul 2009 20:36:33 +0000
Message-ID: <20090730203633.GA28838 () merkur ! ravnborg ! org>
--------------------
On Thu, Jul 30, 2009 at 03:55:46AM -0700, Christopher Li wrote:
> Hi Sam,
> 
> I create a branch "unused-include-files" for some experiment patch.
> Some thing quick and dirty to find out what works and what doesn't.
> No where near submitting quality.
> 
> http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=shortlog;h=unused-include-files
> 
> Currently it just report all unused stream.
> 
> for your example foo.h:
> 
> #include <linux/types.h>
> #include <linux/string.h>
> 
> struct foo {
>        __u32 bar;
>        __u32 baz;
> };
> 
> 
> $ ./sparse foo.h
> unused stream preprocessor(1)
> unused stream foo.h(2)
> unused stream preprocessor(3)
> unused stream /usr/include/linux/stddef.h(6)
> unused stream /usr/include/asm/posix_types.h(7)
> unused stream /usr/include/asm/types.h(9)
> unused stream /usr/include/linux/string.h(11)
> unused stream /usr/include/string.h(12)
> unused stream /usr/include/features.h(13)
> unused stream /usr/include/sys/cdefs.h(14)
> unused stream /usr/include/bits/wordsize.h(15)
> unused stream /usr/include/gnu/stubs.h(16)
> unused stream /usr/include/bits/wordsize.h(17)
> unused stream /usr/include/gnu/stubs-32.h(18)
> unused stream /usr/lib/gcc/x86_64-redhat-linux/4.3.0//include/stddef.h(19)
> 
> Just as I expected. Lost of noise :-)
> 
> BTW, use "-vstream" to show the actual symbol usage detail.
> 
> Comments?
Thanks for hacking this up!

I will try it out during the weekend as work permits. Busy...

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 30 Jul 2009 20:36:33 +0000
Message-ID: <20090730203633.GA28838 () merkur ! ravnborg ! org>
--------------------
On Thu, Jul 30, 2009 at 03:55:46AM -0700, Christopher Li wrote:
> Hi Sam,
> 
> I create a branch "unused-include-files" for some experiment patch.
> Some thing quick and dirty to find out what works and what doesn't.
> No where near submitting quality.
> 
> http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=shortlog;h=unused-include-files
> 
> Currently it just report all unused stream.
> 
> for your example foo.h:
> 
> #include <linux/types.h>
> #include <linux/string.h>
> 
> struct foo {
>        __u32 bar;
>        __u32 baz;
> };
> 
> 
> $ ./sparse foo.h
> unused stream preprocessor(1)
> unused stream foo.h(2)
> unused stream preprocessor(3)
> unused stream /usr/include/linux/stddef.h(6)
> unused stream /usr/include/asm/posix_types.h(7)
> unused stream /usr/include/asm/types.h(9)
> unused stream /usr/include/linux/string.h(11)
> unused stream /usr/include/string.h(12)
> unused stream /usr/include/features.h(13)
> unused stream /usr/include/sys/cdefs.h(14)
> unused stream /usr/include/bits/wordsize.h(15)
> unused stream /usr/include/gnu/stubs.h(16)
> unused stream /usr/include/bits/wordsize.h(17)
> unused stream /usr/include/gnu/stubs-32.h(18)
> unused stream /usr/lib/gcc/x86_64-redhat-linux/4.3.0//include/stddef.h(19)
> 
> Just as I expected. Lost of noise :-)
> 
> BTW, use "-vstream" to show the actual symbol usage detail.
> 
> Comments?
Thanks for hacking this up!

I will try it out during the weekend as work permits. Busy...

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Tue, 04 Aug 2009 21:49:27 +0000
Message-ID: <70318cbf0908041449u4ce5ab30w6700a7081aa4909c () mail ! gmail ! com>
--------------------
On Thu, Jul 30, 2009 at 1:36 PM, Sam Ravnborg<sam@ravnborg.org> wrote:
> Thanks for hacking this up!
>
> I will try it out during the weekend as work permits. Busy...

Any updates?

It seems that top level header file including sub component
header file is very common practice, especially on big header
file. From the header file itself is not sufficient to determine
the included header file is a sub component or some thing
new.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Wed, 05 Aug 2009 06:12:23 +0000
Message-ID: <20090805061223.GA2861 () merkur ! ravnborg ! org>
--------------------
On Tue, Aug 04, 2009 at 02:49:27PM -0700, Christopher Li wrote:
> On Thu, Jul 30, 2009 at 1:36 PM, Sam Ravnborg<sam@ravnborg.org> wrote:
> > Thanks for hacking this up!
> >
> > I will try it out during the weekend as work permits. Busy...
> 
> Any updates?
Sorry - but caught up with day-time job.
 
> It seems that top level header file including sub component
> header file is very common practice, especially on big header
> file. From the header file itself is not sufficient to determine
> the included header file is a sub component or some thing
> new.
In the exported linux-kernel headers this is not common practice - so we will not
be caught by this.
But for general application programming it is useless.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Marko Kreen <markokr () gmail ! com>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 06 Aug 2009 11:14:04 +0000
Message-ID: <e51f66da0908060414n62a34b89n322f516878567141 () mail ! gmail ! com>
--------------------
On 8/5/09, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Jul 30, 2009 at 1:36 PM, Sam Ravnborg<sam@ravnborg.org> wrote:
>  > Thanks for hacking this up!
>  >
>  > I will try it out during the weekend as work permits. Busy...
>
>
> Any updates?
>
>  It seems that top level header file including sub component
>  header file is very common practice, especially on big header
>  file. From the header file itself is not sufficient to determine
>  the included header file is a sub component or some thing
>  new.

Could we have a flag to track top-level headers only?  So that
anything declared in sub-headers will be registered also under
top header file?  This seems more useful scanning mode for regular
user-space code.

-- 
marko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Robert P. J. Day" <rpjday () crashcourse ! ca>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 06 Aug 2009 11:17:02 +0000
Message-ID: <alpine.LFD.2.00.0908060716010.7946 () localhost>
--------------------
On Thu, 6 Aug 2009, Marko Kreen wrote:

> On 8/5/09, Christopher Li <sparse@chrisli.org> wrote:
> > On Thu, Jul 30, 2009 at 1:36 PM, Sam Ravnborg<sam@ravnborg.org> wrote:
> >  > Thanks for hacking this up!
> >  >
> >  > I will try it out during the weekend as work permits. Busy...
> >
> > Any updates?
> >
> >  It seems that top level header file including sub component
> >  header file is very common practice, especially on big header
> >  file. From the header file itself is not sufficient to determine
> >  the included header file is a sub component or some thing
> >  new.
>
> Could we have a flag to track top-level headers only?  So that
> anything declared in sub-headers will be registered also under top
> header file?  This seems more useful scanning mode for regular
> user-space code.

  has anyone tried cscout?

http://www.spinellis.gr/cscout/

rday
--
========================================================================
Robert P. J. Day                               Waterloo, Ontario, CANADA

        Linux Consulting, Training and Annoying Kernel Pedantry.

Web page:                                          http://crashcourse.ca
Twitter:                                       http://twitter.com/rpjday
"Kernel Newbie Corner" column @ linux.com:          http://cli.gs/WG6WYX
========================================================================
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Robert P. J. Day" <rpjday () crashcourse ! ca>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 06 Aug 2009 12:15:17 +0000
Message-ID: <alpine.LFD.2.00.0908060813460.8569 () localhost>
--------------------
On Thu, 6 Aug 2009, Kamil Dudka wrote:

> On Thu August 6 2009 13:17:02 Robert P. J. Day wrote:
> > On Thu, 6 Aug 2009, Marko Kreen wrote:
> > > On 8/5/09, Christopher Li <sparse@chrisli.org> wrote:
> > > > On Thu, Jul 30, 2009 at 1:36 PM, Sam Ravnborg<sam@ravnborg.org> wrote:
> > > >  > Thanks for hacking this up!
> > > >  >
> > > >  > I will try it out during the weekend as work permits. Busy...
> > > >
> > > > Any updates?
> > > >
> > > >  It seems that top level header file including sub component
> > > >  header file is very common practice, especially on big header
> > > >  file. From the header file itself is not sufficient to determine
> > > >  the included header file is a sub component or some thing
> > > >  new.
> > >
> > > Could we have a flag to track top-level headers only?  So that
> > > anything declared in sub-headers will be registered also under top
> > > header file?  This seems more useful scanning mode for regular
> > > user-space code.
> >
> >   has anyone tried cscout?
> >
> > http://www.spinellis.gr/cscout/
>
> The homepage looks interesting, but where can I download its sources?

http://www.spinellis.gr/cscout/download.html

i grabbed a copy of it a few days ago, i just haven't had time to set
it up.  i mention it since one of the things it claims to do is -- ta
da! -- identify unused header files.  but it appears to take some
careful configuration.  i'd like to see someone config it to scan the
current source tree, i just don't think i have the time at the moment.

rday
--

========================================================================
Robert P. J. Day                               Waterloo, Ontario, CANADA

        Linux Consulting, Training and Annoying Kernel Pedantry.

Web page:                                          http://crashcourse.ca
Twitter:                                       http://twitter.com/rpjday
"Kernel Newbie Corner" column @ linux.com:          http://cli.gs/WG6WYX
========================================================================
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 06 Aug 2009 12:16:45 +0000
Message-ID: <200908061416.46210.kdudka () redhat ! com>
--------------------
On Thu August 6 2009 13:17:02 Robert P. J. Day wrote:
> On Thu, 6 Aug 2009, Marko Kreen wrote:
> > On 8/5/09, Christopher Li <sparse@chrisli.org> wrote:
> > > On Thu, Jul 30, 2009 at 1:36 PM, Sam Ravnborg<sam@ravnborg.org> wrote:
> > >  > Thanks for hacking this up!
> > >  >
> > >  > I will try it out during the weekend as work permits. Busy...
> > >
> > > Any updates?
> > >
> > >  It seems that top level header file including sub component
> > >  header file is very common practice, especially on big header
> > >  file. From the header file itself is not sufficient to determine
> > >  the included header file is a sub component or some thing
> > >  new.
> >
> > Could we have a flag to track top-level headers only?  So that
> > anything declared in sub-headers will be registered also under top
> > header file?  This seems more useful scanning mode for regular
> > user-space code.
>
>   has anyone tried cscout?
>
> http://www.spinellis.gr/cscout/

The homepage looks interesting, but where can I download its sources?

Kamil

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 06 Aug 2009 13:26:25 +0000
Message-ID: <4A7ADA01.6020402 () redhat ! com>
--------------------
Kamil Dudka wrote:
> On Thu August 6 2009 14:16:45 Kamil Dudka wrote:
>>>   has anyone tried cscout?
>>>
>>> http://www.spinellis.gr/cscout/
>> The homepage looks interesting, but where can I download its sources?
> 
> FYI we figured out with rday off-list that there are no sources available.
> 
> Please leave a note here if you find them.
It is a proprietary application that is free as in beer to use for
checking open source code. But careful as the application phones home
(see the FAQ). I wanted to use it too on Wine but that stopped me.

bye
	michael
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Robert P. J. Day" <rpjday () crashcourse ! ca>
To: linux-sparse
Subject: Re: Detect unused header files?
Date: Thu, 06 Aug 2009 14:09:55 +0000
Message-ID: <alpine.LFD.2.00.0908061007240.10398 () localhost>
--------------------
On Thu, 6 Aug 2009, Michael Stefaniuc wrote:

> Kamil Dudka wrote:
> > On Thu August 6 2009 14:16:45 Kamil Dudka wrote:
> >>>   has anyone tried cscout?
> >>>
> >>> http://www.spinellis.gr/cscout/
> >> The homepage looks interesting, but where can I download its sources?
> >
> > FYI we figured out with rday off-list that there are no sources available.
> >
> > Please leave a note here if you find them.

> It is a proprietary application that is free as in beer to use for
> checking open source code. But careful as the application phones
> home (see the FAQ). I wanted to use it too on Wine but that stopped
> me.

  while i understand the dislike OSS folks have for that sort of
thing, is there anything fundamentally harmful with what cscout would
be "sending home" WRT the linux kernel source tree?  i'm not arguing
one way or the other -- i'm just wondering if the benefits of running
cscout on the kernel would outweigh the annoyance of how it behaves.

rday
--

========================================================================
Robert P. J. Day                               Waterloo, Ontario, CANADA

        Linux Consulting, Training and Annoying Kernel Pedantry.

Web page:                                          http://crashcourse.ca
Twitter:                                       http://twitter.com/rpjday
"Kernel Newbie Corner" column @ linux.com:          http://cli.gs/WG6WYX
========================================================================
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Don't mix storage class bits with ctype->modifiers while parsing type ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Don't mix storage class bits with ctype->modifiers while parsing type
Date: Wed, 11 Mar 2009 07:08:25 +0000
Message-ID: <E1LhIYD-00040j-D5 () ZenIV ! linux ! org ! uk>
--------------------

Keep storage class (and "is it inline") explicitly in decl_state;
translate to modifiers only when we are done with parsing.  That
avoids the need to separate MOD_STORAGE bits while constructing
the type (e.g. in alloc_indirect_symbol(), etc.).  It also allows
to get rid of MOD_FORCE for good - instead of passing it to typename()
we pass an int * and let typename() tell whether we'd got a force-cast.
Indication of force-cast never makes it into the modifier bits at all.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 expression.c |   12 +++----
 expression.h |    2 +-
 gdbhelpers   |    3 --
 parse.c      |  107 ++++++++++++++++++++++++++++++++++++++++++----------------
 symbol.h     |    5 +--
 5 files changed, 86 insertions(+), 43 deletions(-)

diff --git a/expression.c b/expression.c
index 7c88a28..c9277da 100644
--- a/expression.c
+++ b/expression.c
@@ -118,7 +118,7 @@ static struct token *parse_type(struct token *token, struct expression **tree)
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
 	(*tree)->flags = Int_const_expr; /* sic */
-	token = typename(token, &sym, 0);
+	token = typename(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -167,7 +167,7 @@ static struct token *builtin_offsetof_expr(struct token *token,
 		return expect(token, '(', "after __builtin_offset");
 
 	token = token->next;
-	token = typename(token, &sym, 0);
+	token = typename(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -482,7 +482,7 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
 			expr->flags = Int_const_expr; /* sic */
-			token = typename(token->next, &expr->symbol, 0);
+			token = typename(token->next, &expr->symbol, NULL);
 			token = expect(token, ']', "in type expression");
 			break;
 		}
@@ -602,7 +602,7 @@ static struct token *type_info_expression(struct token *token,
 	if (!match_op(token, '(') || !lookup_type(token->next))
 		return unary_expression(token, &expr->cast_expression);
 	p = token;
-	token = typename(token->next, &expr->cast_type, 0);
+	token = typename(token->next, &expr->cast_type, NULL);
 
 	if (!match_op(token, ')')) {
 		static const char * error[] = {
@@ -727,10 +727,8 @@ static struct token *cast_expression(struct token *token, struct expression **tr
 			struct symbol *sym;
 			int is_force;
 
-			token = typename(next, &sym, MOD_FORCE);
+			token = typename(next, &sym, &is_force);
 			cast->cast_type = sym;
-			is_force = sym->ctype.modifiers & MOD_FORCE;
-			sym->ctype.modifiers &= ~MOD_FORCE;
 			token = expect(token, ')', "at end of cast operator");
 			if (match_op(token, '{')) {
 				if (is_force)
diff --git a/expression.h b/expression.h
index 2e12b12..631224f 100644
--- a/expression.h
+++ b/expression.h
@@ -193,7 +193,7 @@ static inline struct expression *alloc_const_expression(struct position pos, int
 }
 
 /* Type name parsing */
-struct token *typename(struct token *, struct symbol **, int);
+struct token *typename(struct token *, struct symbol **, int *);
 
 static inline int lookup_type(struct token *token)
 {
diff --git a/gdbhelpers b/gdbhelpers
index e28417a..db78d6c 100644
--- a/gdbhelpers
+++ b/gdbhelpers
@@ -158,9 +158,6 @@ define gdb_show_ctype
 	if ($arg0->modifiers & MOD_USERTYPE)
 		printf "MOD_USERTYPE "
 	end
-	if ($arg0->modifiers & MOD_FORCE)
-		printf "MOD_FORCE "
-	end
 	if ($arg0->modifiers & MOD_EXPLICITLY_SIGNED)
 		printf "MOD_EXPLICITLY_SIGNED"
 	end
diff --git a/parse.c b/parse.c
index e99ca3d..28bc0c9 100644
--- a/parse.c
+++ b/parse.c
@@ -65,7 +65,7 @@ static attr_t
 	attribute_packed, attribute_aligned, attribute_modifier,
 	attribute_address_space, attribute_context,
 	attribute_transparent_union, ignore_attribute,
-	attribute_mode;
+	attribute_mode, attribute_force;
 
 typedef struct symbol *to_mode_t(struct symbol *);
 
@@ -91,6 +91,10 @@ enum {
 	CInt = 0, CSInt, CUInt, CReal, CChar, CSChar, CUChar
 };
 
+enum {
+	SNone = 0, STypedef, SAuto, SRegister, SExtern, SStatic, SForced
+};
+
 static struct symbol_op typedef_op = {
 	.type = KW_MODIFIER,
 	.declarator = typedef_specifier,
@@ -294,6 +298,10 @@ static struct symbol_op attr_mod_op = {
 	.attribute = attribute_modifier,
 };
 
+static struct symbol_op attr_force_op = {
+	.attribute = attribute_force,
+};
+
 static struct symbol_op address_space_op = {
 	.attribute = attribute_address_space,
 };
@@ -426,7 +434,7 @@ static struct init_keyword {
 	{ "nocast",	NS_KEYWORD,	MOD_NOCAST,	.op = &attr_mod_op },
 	{ "noderef",	NS_KEYWORD,	MOD_NODEREF,	.op = &attr_mod_op },
 	{ "safe",	NS_KEYWORD,	MOD_SAFE, 	.op = &attr_mod_op },
-	{ "force",	NS_KEYWORD,	MOD_FORCE,	.op = &attr_mod_op },
+	{ "force",	NS_KEYWORD,	.op = &attr_force_op },
 	{ "bitwise",	NS_KEYWORD,	MOD_BITWISE,	.op = &attr_mod_op },
 	{ "__bitwise__",NS_KEYWORD,	MOD_BITWISE,	.op = &attr_mod_op },
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
@@ -585,10 +593,10 @@ static struct symbol * alloc_indirect_symbol(struct position pos, struct ctype *
 	struct symbol *sym = alloc_symbol(pos, type);
 
 	sym->ctype.base_type = ctype->base_type;
-	sym->ctype.modifiers = ctype->modifiers & ~MOD_STORAGE;
+	sym->ctype.modifiers = ctype->modifiers;
 
 	ctype->base_type = sym;
-	ctype->modifiers &= MOD_STORAGE;
+	ctype->modifiers = 0;
 	return sym;
 }
 
@@ -912,7 +920,7 @@ static struct token *typeof_specifier(struct token *token, struct decl_state *ct
 		return token;
 	}
 	if (lookup_type(token->next)) {
-		token = typename(token->next, &sym, 0);
+		token = typename(token->next, &sym, NULL);
 		ctx->ctype.base_type = sym->ctype.base_type;
 		apply_ctype(token->pos, &sym->ctype, &ctx->ctype);
 	} else {
@@ -1138,51 +1146,79 @@ static struct token *attribute_specifier(struct token *token, struct decl_state
 	return token;
 }
 
-static void apply_modifier(struct position *pos, struct ctype *ctx, unsigned long modifier)
+static const char *storage_class[] = 
 {
-	if (!(ctx->modifiers & MOD_STORAGE & ~MOD_INLINE)) {
-		ctx->modifiers |= modifier;
+	[STypedef] = "typedef",
+	[SAuto] = "auto",
+	[SExtern] = "extern",
+	[SStatic] = "static",
+	[SRegister] = "register",
+	[SForced] = "[force]"
+};
+
+static unsigned long storage_modifiers(struct decl_state *ctx)
+{
+	static unsigned long mod[] = 
+	{
+		[SAuto] = MOD_AUTO,
+		[SExtern] = MOD_EXTERN,
+		[SStatic] = MOD_STATIC,
+		[SRegister] = MOD_REGISTER
+	};
+	return mod[ctx->storage_class] | (ctx->is_inline ? MOD_INLINE : 0);
+}
+
+static void set_storage_class(struct position *pos, struct decl_state *ctx, int class)
+{
+	if (!ctx->storage_class) {
+		ctx->storage_class = class;
 		return;
 	}
-	if (ctx->modifiers & modifier)
-		sparse_error(*pos, "duplicate %s", modifier_string(modifier));
+	if (ctx->storage_class == class)
+		sparse_error(*pos, "duplicate %s", storage_class[class]);
 	else
 		sparse_error(*pos, "multiple storage classes");
 }
 
 static struct token *typedef_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, &ctx->ctype, MOD_TYPEDEF);
+	set_storage_class(&next->pos, ctx, STypedef);
 	return next;
 }
 
 static struct token *auto_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, &ctx->ctype, MOD_AUTO);
+	set_storage_class(&next->pos, ctx, SAuto);
 	return next;
 }
 
 static struct token *register_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, &ctx->ctype, MOD_REGISTER);
+	set_storage_class(&next->pos, ctx, SRegister);
 	return next;
 }
 
 static struct token *static_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, &ctx->ctype, MOD_STATIC);
+	set_storage_class(&next->pos, ctx, SStatic);
 	return next;
 }
 
 static struct token *extern_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, &ctx->ctype, MOD_EXTERN);
+	set_storage_class(&next->pos, ctx, SExtern);
 	return next;
 }
 
+static struct token *attribute_force(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	set_storage_class(&token->pos, ctx, SForced);
+	return token;
+}
+
 static struct token *inline_specifier(struct token *next, struct decl_state *ctx)
 {
-	ctx->ctype.modifiers |= MOD_INLINE;
+	ctx->is_inline = 1;
 	return next;
 }
 
@@ -1559,20 +1595,19 @@ static struct token *pointer(struct token *token, struct decl_state *ctx)
 	unsigned long modifiers;
 	struct symbol *base_type;
 
-	modifiers = ctx->ctype.modifiers & ~MOD_TYPEDEF;
+	modifiers = ctx->ctype.modifiers;
 	base_type = ctx->ctype.base_type;
-	ctx->ctype.modifiers = modifiers;
 
 	while (match_op(token,'*')) {
 		struct symbol *ptr = alloc_symbol(token->pos, SYM_PTR);
-		ptr->ctype.modifiers = modifiers & ~MOD_STORAGE;
+		ptr->ctype.modifiers = modifiers;
 		ptr->ctype.as = ctx->ctype.as;
 		concat_ptr_list((struct ptr_list *)ctx->ctype.contexts,
 				(struct ptr_list **)&ptr->ctype.contexts);
 		ptr->ctype.base_type = base_type;
 
 		base_type = ptr;
-		ctx->ctype.modifiers = modifiers & MOD_STORAGE;
+		ctx->ctype.modifiers = 0;
 		ctx->ctype.base_type = base_type;
 		ctx->ctype.as = 0;
 		free_ptr_list(&ctx->ctype.contexts);
@@ -1642,8 +1677,10 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 {
 	struct decl_state ctx = {.prefer_abstract = 0};
 	struct ctype saved;
+	unsigned long mod;
 
 	token = declaration_specifiers(token, &ctx);
+	mod = storage_modifiers(&ctx);
 	saved = ctx.ctype;
 	for (;;) {
 		struct symbol *decl = alloc_symbol(token->pos, SYM_NODE);
@@ -1657,6 +1694,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 		apply_modifiers(token->pos, &ctx);
 
 		decl->ctype = ctx.ctype;
+		decl->ctype.modifiers |= mod;
 		decl->endpos = token->pos;
 		add_symbol(list, decl);
 		if (!match_op(token, ','))
@@ -1691,23 +1729,33 @@ static struct token *parameter_declaration(struct token *token, struct symbol *s
 	token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
 	apply_modifiers(token->pos, &ctx);
 	sym->ctype = ctx.ctype;
+	sym->ctype.modifiers |= storage_modifiers(&ctx);
 	sym->endpos = token->pos;
 	return token;
 }
 
-struct token *typename(struct token *token, struct symbol **p, int mod)
+struct token *typename(struct token *token, struct symbol **p, int *forced)
 {
 	struct decl_state ctx = {.prefer_abstract = 1};
+	int class;
 	struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
 	*p = sym;
 	token = declaration_specifiers(token, &ctx);
 	token = declarator(token, &ctx);
 	apply_modifiers(token->pos, &ctx);
-	if (ctx.ctype.modifiers & MOD_STORAGE & ~mod)
-		warning(sym->pos, "storage class in typename (%s)",
-			show_typename(sym));
 	sym->ctype = ctx.ctype;
 	sym->endpos = token->pos;
+	class = ctx.storage_class;
+	if (forced) {
+		*forced = 0;
+		if (class == SForced) {
+			*forced = 1;
+			class = 0;
+		}
+	}
+	if (class)
+		warning(sym->pos, "storage class in typename (%s %s)",
+			storage_class[class], show_typename(sym));
 	return token;
 }
 
@@ -2487,6 +2535,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	struct decl_state ctx = { .ident = &ident };
 	struct ctype saved;
 	struct symbol *base_type;
+	unsigned long mod;
 	int is_typedef;
 
 	/* Top-level inline asm? */
@@ -2498,6 +2547,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 
 	/* Parse declaration-specifiers, if any */
 	token = declaration_specifiers(token, &ctx);
+	mod = storage_modifiers(&ctx);
 	decl = alloc_symbol(token->pos, SYM_NODE);
 	/* Just a type declaration? */
 	if (match_op(token, ';')) {
@@ -2511,6 +2561,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	apply_modifiers(token->pos, &ctx);
 
 	decl->ctype = ctx.ctype;
+	decl->ctype.modifiers |= mod;
 	decl->endpos = token->pos;
 
 	/* Just a type declaration? */
@@ -2520,14 +2571,11 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	}
 
 	/* type define declaration? */
-	is_typedef = (saved.modifiers & MOD_TYPEDEF) != 0;
+	is_typedef = ctx.storage_class == STypedef;
 
 	/* Typedefs don't have meaningful storage */
-	if (is_typedef) {
-		saved.modifiers &= ~MOD_STORAGE;
-		decl->ctype.modifiers &= ~MOD_STORAGE;
+	if (is_typedef)
 		decl->ctype.modifiers |= MOD_USERTYPE;
-	}
 
 	bind_symbol(decl, ident, is_typedef ? NS_TYPEDEF: NS_SYMBOL);
 
@@ -2586,6 +2634,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 		token = handle_attributes(token, &ctx, KW_ATTRIBUTE | KW_ASM);
 		apply_modifiers(token->pos, &ctx);
 		decl->ctype = ctx.ctype;
+		decl->ctype.modifiers |= mod;
 		decl->endpos = token->pos;
 		if (!ident) {
 			sparse_error(token->pos, "expected identifier name in type definition");
diff --git a/symbol.h b/symbol.h
index f58c80a..da4d64a 100644
--- a/symbol.h
+++ b/symbol.h
@@ -92,8 +92,8 @@ struct ctype {
 struct decl_state {
 	struct ctype ctype;
 	struct ident **ident;
-	int prefer_abstract;
 	struct symbol_op *mode;
+	unsigned char prefer_abstract, is_inline, storage_class;
 };
 
 struct symbol_op {
@@ -212,12 +212,11 @@ struct symbol {
 #define MOD_SAFE	0x8000000	// non-null/non-trapping pointer
 
 #define MOD_USERTYPE	0x10000000
-#define MOD_FORCE	0x20000000
 #define MOD_EXPLICITLY_SIGNED	0x40000000
 #define MOD_BITWISE	0x80000000
 
 #define MOD_NONLOCAL	(MOD_EXTERN | MOD_TOPLEVEL)
-#define MOD_STORAGE	(MOD_AUTO | MOD_REGISTER | MOD_STATIC | MOD_EXTERN | MOD_INLINE | MOD_TOPLEVEL | MOD_FORCE)
+#define MOD_STORAGE	(MOD_AUTO | MOD_REGISTER | MOD_STATIC | MOD_EXTERN | MOD_INLINE | MOD_TOPLEVEL)
 #define MOD_SIGNEDNESS	(MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED)
 #define MOD_SPECIFIER	(MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG | MOD_SIGNEDNESS)
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG)
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Fix __label__ handling ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Fix __label__ handling
Date: Mon, 09 Mar 2009 23:32:36 +0000
Message-ID: <E1LgoxY-0005y2-C8 () ZenIV ! linux ! org ! uk>
--------------------

a) __label__ in gcc is not a type, it's a statement.  Accepted in the beginning
of compound-statement, has form __label__ ident-list;
b) instead of crapping into NS_SYMBOL namespace (and consequent shadowing
issues), reassign the namespace to NS_LABEL after we'd bound it.  We'll get
block scope and label namespace, i.e. what we get in gcc.
c) MOD_LABEL can be dropped now.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 gdbhelpers               |    3 --
 ident-list.h             |    1 +
 parse.c                  |   55 ++++++++++++++++++++++-----------------------
 symbol.h                 |    1 -
 validation/label-scope.c |   12 ++++++++++
 5 files changed, 40 insertions(+), 32 deletions(-)
 create mode 100644 validation/label-scope.c

diff --git a/gdbhelpers b/gdbhelpers
index 7223ffd..e28417a 100644
--- a/gdbhelpers
+++ b/gdbhelpers
@@ -146,9 +146,6 @@ define gdb_show_ctype
 	if ($arg0->modifiers & MOD_TOPLEVEL)
 		printf "MOD_TOPLEVEL "
 	end
-	if ($arg0->modifiers & MOD_LABEL)
-		printf "MOD_LABEL "
-	end
 	if ($arg0->modifiers & MOD_ASSIGNED)
 		printf "MOD_ASSIGNED "
 	end
diff --git a/ident-list.h b/ident-list.h
index e22084e..29ddeca 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -31,6 +31,7 @@ IDENT(alignof); IDENT_RESERVED(__alignof); IDENT_RESERVED(__alignof__);
 IDENT_RESERVED(__sizeof_ptr__);
 IDENT_RESERVED(__builtin_types_compatible_p);
 IDENT_RESERVED(__builtin_offsetof);
+IDENT_RESERVED(__label__);
 
 /* Attribute names */
 IDENT(packed); IDENT(__packed__);
diff --git a/parse.c b/parse.c
index 00469b2..fa0c511 100644
--- a/parse.c
+++ b/parse.c
@@ -372,8 +372,6 @@ static struct init_keyword {
 	{ "_Bool",	NS_TYPEDEF, .type = &bool_ctype, .op = &spec_op },
 
 	/* Predeclared types */
-	{ "__label__",	NS_TYPEDEF, MOD_LABEL,
-		.type =&label_ctype, .op = &spec_op },
 	{ "__builtin_va_list", NS_TYPEDEF, .type = &ptr_ctype, .op = &spec_op },
 
 	/* Extended types */
@@ -594,28 +592,6 @@ static struct symbol * alloc_indirect_symbol(struct position pos, struct ctype *
 	return sym;
 }
 
-static struct symbol *lookup_or_create_symbol(enum namespace ns, enum type type, struct token *token)
-{
-	struct symbol *sym = lookup_symbol(token->ident, ns);
-	if (!sym) {
-		sym = alloc_symbol(token->pos, type);
-		bind_symbol(sym, token->ident, ns);
-		if (type == SYM_LABEL)
-			fn_local_symbol(sym);
-	}
-	return sym;
-}
-
-static struct symbol * local_label(struct token *token)
-{
-	struct symbol *sym = lookup_symbol(token->ident, NS_SYMBOL);
-
-	if (sym && sym->ctype.modifiers & MOD_LABEL)
-		return sym;
-
-	return NULL;
-}
-
 /*
  * NOTE! NS_LABEL is not just a different namespace,
  * it also ends up using function scope instead of the
@@ -623,10 +599,13 @@ static struct symbol * local_label(struct token *token)
  */
 struct symbol *label_symbol(struct token *token)
 {
-	struct symbol *sym = local_label(token);
-	if (sym)
-		return sym;
-	return lookup_or_create_symbol(NS_LABEL, SYM_LABEL, token);
+	struct symbol *sym = lookup_symbol(token->ident, NS_LABEL);
+	if (!sym) {
+		sym = alloc_symbol(token->pos, SYM_LABEL);
+		bind_symbol(sym, token->ident, NS_LABEL);
+		fn_local_symbol(sym);
+	}
+	return sym;
 }
 
 static struct token *struct_union_enum_specifier(enum type type,
@@ -2149,9 +2128,29 @@ static struct token *statement(struct token *token, struct statement **tree)
 	return expression_statement(token, &stmt->expression);
 }
 
+/* gcc extension - __label__ ident-list; in the beginning of compound stmt */
+static struct token *label_statement(struct token *token)
+{
+	while (token_type(token) == TOKEN_IDENT) {
+		struct symbol *sym = alloc_symbol(token->pos, SYM_LABEL);
+		/* it's block-scope, but we want label namespace */
+		bind_symbol(sym, token->ident, NS_SYMBOL);
+		sym->namespace = NS_LABEL;
+		fn_local_symbol(sym);
+		token = token->next;
+		if (!match_op(token, ','))
+			break;
+		token = token->next;
+	}
+	return expect(token, ';', "at end of label declaration");
+}
+
 static struct token * statement_list(struct token *token, struct statement_list **list)
 {
 	int seen_statement = 0;
+	while (token_type(token) == TOKEN_IDENT &&
+	       token->ident == &__label___ident)
+		token = label_statement(token->next);
 	for (;;) {
 		struct statement * stmt;
 		if (eof_token(token))
diff --git a/symbol.h b/symbol.h
index f9944bf..f58c80a 100644
--- a/symbol.h
+++ b/symbol.h
@@ -207,7 +207,6 @@ struct symbol {
 #define MOD_ACCESSED	0x400000
 #define MOD_TOPLEVEL	0x800000	// scoping..
 
-#define MOD_LABEL	0x1000000
 #define MOD_ASSIGNED	0x2000000
 #define MOD_TYPE	0x4000000
 #define MOD_SAFE	0x8000000	// non-null/non-trapping pointer
diff --git a/validation/label-scope.c b/validation/label-scope.c
new file mode 100644
index 0000000..7af3d91
--- /dev/null
+++ b/validation/label-scope.c
@@ -0,0 +1,12 @@
+static int f(int n)
+{
+	__label__ n;
+n:	return n;
+}
+static int g(int n)
+{
+n:	return n;
+}
+/*
+ * check-name: __label__ scope
+ */
-- 
1.5.6.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Fix enumeration constants' scope beginning ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Fix enumeration constants' scope beginning
Date: Mon, 09 Mar 2009 23:32:16 +0000
Message-ID: <E1LgoxE-0005wC-Bf () ZenIV ! linux ! org ! uk>
--------------------

It starts after the end of enumerator; i.e. if we have
enum {
	...
	Foo = expression,
	...
};
the scope of Foo starts only after the end of expression.
Rationale: 6.2.1p7.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                 |    7 +++----
 validation/enum_scope.c |   11 +++++++++++
 2 files changed, 14 insertions(+), 4 deletions(-)
 create mode 100644 validation/enum_scope.c

diff --git a/parse.c b/parse.c
index bffb690..c19822c 100644
--- a/parse.c
+++ b/parse.c
@@ -804,10 +804,6 @@ static struct token *parse_enum_declaration(struct token *token, struct symbol *
 		struct token *next = token->next;
 		struct symbol *sym;
 
-		sym = alloc_symbol(token->pos, SYM_NODE);
-		bind_symbol(sym, token->ident, NS_SYMBOL);
-		sym->ctype.modifiers &= ~MOD_ADDRESSABLE;
-
 		if (match_op(next, '=')) {
 			next = constant_expression(next->next, &expr);
 			lastval = get_expression_value(expr);
@@ -828,6 +824,9 @@ static struct token *parse_enum_declaration(struct token *token, struct symbol *
 			expr->ctype = ctype;
 		}
 
+		sym = alloc_symbol(token->pos, SYM_NODE);
+		bind_symbol(sym, token->ident, NS_SYMBOL);
+		sym->ctype.modifiers &= ~MOD_ADDRESSABLE;
 		sym->initializer = expr;
 		sym->enum_member = 1;
 		sym->ctype.base_type = parent;
diff --git a/validation/enum_scope.c b/validation/enum_scope.c
new file mode 100644
index 0000000..92ffc8e
--- /dev/null
+++ b/validation/enum_scope.c
@@ -0,0 +1,11 @@
+enum {A = 12};
+
+static void f(void)
+{
+	enum {A = A + 1, B};
+	char s[1 - 2 * (B != 14)];
+}
+
+/*
+ * check-name: enumeration constants' scope [6.2.1p7]
+ */
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Fixing "cast truncates bits from constant value" ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Fixing "cast truncates bits from constant value"
Date: Mon, 17 Aug 2009 21:02:02 +0000
Message-ID: <1250542922.10511.38.camel () mj>
--------------------
Hello!

There was a discussion in the linux-wireless mailing list about
silencing a sparse warning in the b43 driver:

http://marc.info/?t=125020183400006&r=1&w=2

It turns out the fixes for the warnings would make the code worse, not
better.  It's not what sparse should try to do.

Here's the simplest case:

static unsigned short test(void)
{
        return (unsigned short)~0x8000;
}

test.c:3:32: warning: cast truncates bits from constant value (ffff7fff
becomes 7fff)

A side note - "0x" should be used with user visible output.

0x8000 could be a constant defined in a header, so just using 0x7fff is
not an option, if the code readability is to be preserved.

In my opinion, an explicit cast should be enough to suppress the
warning.  But it's not.  Moreover, it's a "superwarning" that cannot
even be suppressed by the "force" attribute!  This source still
generates a warning:

static unsigned short test(void)
{
        return (__attribute__((force)) unsigned short)~0x8000;
}

There is also an inconsistency.  This source produces a warning:

static unsigned short test(void)
{
        return 0x0ffff000U;
}

But this source doesn't:

static unsigned short test(void)
{
        return 0xfffff000U;
}

In both cases bits are dropped and the value (a large positive number)
is changed.

I'm not currently subscribed to this list, please copy me.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Fixing "cast truncates bits from constant value"
Date: Wed, 19 Aug 2009 23:28:07 +0000
Message-ID: <1250724487.23170.72.camel () mj>
--------------------
On Tue, 2009-08-18 at 22:36 -0700, Christopher Li wrote:
> On Mon, Aug 17, 2009 at 2:02 PM, Pavel Roskin<proski@gnu.org> wrote:
> > static unsigned short test(void)
> > {
> >        return (unsigned short)~0x8000;
> > }
> >
> > test.c:3:32: warning: cast truncates bits from constant value (ffff7fff
> > becomes 7fff)
> 
> That warning is legit because you ARE truncating constant value here.

I believe it's not, as it's an explicit cast.  Sure, it's debatable
whether users want to be warned about it.  But suppose we keep the
warning.  What would be the fix for the above code?  The only fix I can
think of would be to use AND with 0xffff:

static unsigned short test(void)
{
      return (unsigned short)(0xffff & ~0x8000);
}

I think it's ugly.  And that's what b43 developers think, so the sparce
warning remains unfixed.

> > In my opinion, an explicit cast should be enough to suppress the
> > warning.  But it's not.  Moreover, it's a "superwarning" that cannot
> > even be suppressed by the "force" attribute!  This source still
> > generates a warning:
> >
> > static unsigned short test(void)
> > {
> >        return (__attribute__((force)) unsigned short)~0x8000;
> 
> Sparse currently does not thing than just mark it as forced.

The whole point of having that attribute is to suppress warnings.

> > But this source doesn't:
> >
> > static unsigned short test(void)
> > {
> >        return 0xfffff000U;
> > }
> 
> I think sparse consider it as signed extend.
> Truncating all 0xffff is consider OK for the negative case.

That's wrong, as there are no signed integers involved in the above
example.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fixing "cast truncates bits from constant value"
Date: Thu, 20 Aug 2009 06:55:18 +0000
Message-ID: <70318cbf0908192355j32feec13r12b9ce62697b5bb9 () mail ! gmail ! com>
--------------------
On Wed, Aug 19, 2009 at 4:28 PM, Pavel Roskin<proski@gnu.org> wrote:
>
> static unsigned short test(void)
> {
>      return (unsigned short)(0xffff & ~0x8000);
> }
>
> I think it's ugly.  And that's what b43 developers think, so the sparce
> warning remains unfixed.


You can use a macro with nice name to do the convert plus AND 0xffff.
e.g.

return short_value(~0x8000);


>
>> > In my opinion, an explicit cast should be enough to suppress the
>> > warning.  But it's not.  Moreover, it's a "superwarning" that cannot
>> > even be suppressed by the "force" attribute!  This source still
>> > generates a warning:
>> >
>> > static unsigned short test(void)
>> > {
>> >        return (__attribute__((force)) unsigned short)~0x8000;
>>
>> Sparse currently does not thing than just mark it as forced.
>
> The whole point of having that attribute is to suppress warnings.

Yes, there is a lot of place sparse is complete yet. If any one want
to send patches. I am glad to review it.

>> > static unsigned short test(void)
>> > {
>> >        return 0xfffff000U;
>> > }
>>
>> I think sparse consider it as signed extend.
>> Truncating all 0xffff is consider OK for the negative case.
>
> That's wrong, as there are no signed integers involved in the above
> example.

True. But sparse is not a validations tool. It just point out the possible
warnings. If a warning has too much false positives. It is pretty much
useless. What you are suggesting will cause too much unnecessary
warnings. I haven't try it myself, but I suspect the kernel using negative
error code in pointers might trigger this.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Getting info from used typedef ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Getting info from used typedef
Date: Wed, 25 Nov 2009 14:15:50 +0000
Message-ID: <OF00751164.A668C764-ONC1257679.004B0F96-C1257679.004E5AEF () br-automation ! com>
--------------------
Hello,

I try to get information about a typedef, which was used in a declaration.

For example:

typedef signed short INT;
INT var1;

When i iterate over the symbol_list which is returend by sparse(), I can 
get the information,
that "var1" was declared using a typedef, this information is held in 
"symbol->ctype.modifiers".
Can you tell me how I can examine the name of the typedef - "INT", which 
was used in the declaration?
I'm only able to get the name of the basic datatype, which is "signed 
short" in this case.

This behaviour has changed in 0.4.2, in former versions the name of a used 
typedef was stored in the used datatypes ident
(altough the behaviour was erroneous there).

Thanks in advance,
regards,
Thomas

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Getting info from used typedef
Date: Mon, 30 Nov 2009 23:41:18 +0000
Message-ID: <70318cbf0911301541i478a4642k54423fd8ac5e83ec () mail ! gmail ! com>
--------------------
On Wed, Nov 25, 2009 at 6:15 AM, Thomas Schmid
<Thomas.Schmid@br-automation.com> wrote:
> typedef signed short INT;
> INT var1;
>
> When i iterate over the symbol_list which is returend by sparse(), I can
> get the information,
> that "var1" was declared using a typedef, this information is held in
> "symbol->ctype.modifiers".

So far so good.

> Can you tell me how I can examine the name of the typedef - "INT", which
> was used in the declaration?

I take a look at the current code base, there is no good way to get the
typedef from the symbol node. When sparse parse the "INT" token.
It will try to lookup it as type define. If it is, sparse directly
apply the underlying
ctype, which is "signed short", to var1.

The code does that is in declaration_specifiers() if you are curious.
Sparse only use the base type of the user type, as if the declaration
is "signed short var1". This make the later process much easier.
It is none trivial change to preserve the type define name.

May I ask more back ground information what do you want to do
with the type define name? I am trying to find out if there is other easier
way to achieve your goal.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Handle __builtin_ms_va_list. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Handle __builtin_ms_va_list.
Date: Thu, 01 Oct 2009 18:41:57 +0000
Message-ID: <70318cbf0910011141r78e02d78qbb7ab4f183253406 () mail ! gmail ! com>
--------------------
On Wed, Sep 30, 2009 at 2:34 PM, Michael Stefaniuc <mstefani@redhat.com> wrote:
> For Win64 compiles Wine does
>  #ifndef __ms_va_list
>  # if defined(__x86_64__) && defined (__GNUC__)
>  #  define __ms_va_list __builtin_ms_va_list
>  #  define __ms_va_start(list,arg) __builtin_ms_va_start(list,arg)
>  #  define __ms_va_end(list) __builtin_ms_va_end(list)
>  # else
>
> Wouldn't be as bad if sparse cannot handle those but it trips over
> WINBASEAPI DWORD WINAPI FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,__ms_va_list*);
> WINBASEAPI DWORD WINAPI FormatMessageW(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,DWORD,__ms_va_list*);
> producing this errors for basically every file:
> wine/include/winbase.h:1546:96: error: Expected ) in function declarator
> wine/include/winbase.h:1546:96: error: got *
> wine/include/winbase.h:1547:97: error: Expected ) in function declarator
> wine/include/winbase.h:1547:97: error: got *

Applied.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Ignore the ms_abi/sysv_abi attributes. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Ignore the ms_abi/sysv_abi attributes.
Date: Wed, 30 Sep 2009 20:49:59 +0000
Message-ID: <70318cbf0909301349n6a9a1beao9713fc6923ad9216 () mail ! gmail ! com>
--------------------
On Wed, Sep 30, 2009 at 1:21 PM, Michael Stefaniuc <mstefani@redhat.com> wrote:
> The nicest part about this is that the ignored attributes are now sorted
> alphabetically and one doesn't have to figure out where exactly to add them.

Thanks, I like that too :-)

I actually write a five lines python script to short them and make sure
I did not drop some of the attributes.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Initializing float variables without type suffix ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Initializing float variables without type suffix
Date: Fri, 06 Feb 2009 04:15:37 +0000
Message-ID: <70318cbf0902052015i387c5e18w475704b290904e61 () mail ! gmail ! com>
--------------------
On Wed, Feb 4, 2009 at 6:57 AM, Thomas Schmid
<Thomas.Schmid@br-automation.com> wrote:
> Hello,
>
> i think i found an error, when float variables are initialized.
> Parsing the line
>
> float var = 1.2345;
>
> gets casted with the function cast_to(). It seems that cast_to() doesn't
> make double to float casts.

cast_to() seems fine.

In expanding stage, cast_value() did not cast the constant
correctly.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Multiple translation unit regression ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Multiple translation unit regression
Date: Sun, 05 Jul 2009 23:06:28 +0000
Message-ID: <4A5131F4.7070007 () ramsay1 ! demon ! co ! uk>
--------------------
This is a multi-part message in MIME format.
--------------050806070605050507090105
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

Hi Chris,

The recent patches from Linus caught my eye, since I have my own
versions of two of them (the array restrict and transparent_union
patches) in my sparse repo. (I suspect for the same reason; try to
reduce the number of sparse warnings on git. I also have a quick
hack to sorta-kinda implement transparent_union on glibc/Linux;
new-lib/cygwin doesn't need it. I did manage to get to zero
warnings at one point).

So, I decided to fetch from your repo, in order to upgrade to the
latest sparse (I was still using Josh's repo, commit e3bff51f, as
the basis of my version). Having done so, I noticed a regression
when using sparse on libgit2.

<offtopic for="Chris, Junio">
I note that both sparse and git have only one "serious" sparse
error; but it is effectively the same one. If you run sparse
over itself you will find:

    pre-process.c:609:25: error: bad constant expression

and for git (on platforms for which THREADED_DELTA_SEARCH is
defined):

    builtin-pack-objects.c:1606:32: error: bad constant expression

These errors relate to using the "dynamic local arrays" gcc
extension (aka C99 VLAs); viz:

pre-process.c:609 in function expand():
	struct arg args[nargs];

builtin-pack-objects.c:1606 in function ll_find_deltas():
	struct thread_params p[delta_search_threads];

So, whether this is actually a problem, depends on the project
policy regarding this extension...
</offtopic>

In libgit2, the sparse Makefile target includes all source files
(via the SRC_C macro) in a single invocation of cgcc, thus:

sparse:
	cgcc -no-compile $(ALL_CFLAGS) $(SPARSE_FLAGS) $(SRC_C)

this results in the follwing warnings (on cygwin):

.../byteorder.h:39:1: warning: multiple definitions for function '__ntohl'
.../byteorder.h:39:1:  the previous one is here
.../byteorder.h:56:1: warning: multiple definitions for function '__ntohs'
.../byteorder.h:56:1:  the previous one is here

repeated 10 times. (Hint: it is significant that the number of source
files is 11 [-1 = 10]). It is much much worse on Linux, where the glibc
header files have many more extern inline function declarations.

Note that the previous definition of __ntohl is at, er... ;-)

However, if you run cgcc on each file separately, then no warnings
are issued!

To make things a little clearer, try this:

$ cat -n test.c
     1	
     2	extern __inline__ int f(int);
     3	
     4	extern __inline__ int
     5	f(int x)
     6	{
     7		return x;
     8	}
     9	
$ ./sparse test.c
$ ./sparse test.c test.c
test.c:5:1: warning: multiple definitions for function 'f'
test.c:5:1:  the previous one is here
$ cp test.c test-again.c
$ ./sparse test.c test-again.c
test-again.c:5:1: warning: multiple definitions for function 'f'
test.c:5:1:  the previous one is here
$ 

So, the previous definition was in the previous translation unit!

I then used "git bisect" to try and find the culprit, and it fingered:

    commit 0ed9c1290e9fd37e6a320d16c621beba202d422e
    Author: Al Viro <viro@ZenIV.linux.org.uk>
    Date:   Mon Feb 2 07:30:19 2009 +0000

        fun with declarations and definitions
    
        ...

The third hunk of the diff to parse.c actually triggers the problem,
but is not the real cause of the regression.

I think the problem is mainly caused by bind_symbol() binding the
global_scope to some symbols. Indeed, the global_scope/file_scope
seems to be a bit confused and confusing. Note that the global_scope
is not changed at all once intialised. In particular, each translation
unit keeps adding to the, one and only, global_scope; which is
effectively the same as the builtin_scope!

Hmm, the following diff shows a quick fix:

--->8---
diff --git a/scope.c b/scope.c
index 27e38bc..fb4c039 100644
--- a/scope.c
+++ b/scope.c
@@ -49,6 +49,7 @@ void start_file_scope(void)
 	/* top-level stuff defaults to file scope, "extern" etc will choose global scope */
 	function_scope = scope;
 	block_scope = scope;
+	start_scope(&global_scope);
 }
 
 void start_symbol_scope(void)
@@ -87,6 +88,7 @@ static void end_scope(struct scope **s)
 void end_file_scope(void)
 {
 	end_scope(&file_scope);
+	end_scope(&global_scope);
 }
 
 void new_file_scope(void)
--->8---

But this is not the correct fix. In fact it may have broken c2xml
and ctags. I haven't checked, but look at the main() code in c2xml.c
and ctags.c; again the semantics of global_scope vs. file_scope
seems confused and confusing. At least to me. ;-)

Note the comment in the first hunk above. I suspect that the
global_scope was intended to be used to check the semantics of
local extern declarations, which are effectively hoisted to global
scope, in order the check the type of the re-declarations (and
maybe re-definitions). (but it would be a separate symbol table,
used only for the semantic checks).

Hmm, you would also need to compose the two types, check the
resulting linkage... Take a look at this example:

$ cat extern-test.c

int f(void) { extern float g(int); return 0; }
int g(void) { return -1; } /* ERROR, conflicting type for g() */
int h(void) { extern double g(void); return 0; }  /* ditto */

int x;  /* the extern decl. below conflicts with this x, not param */
int k(int x)
{
	{ extern float x; x=1; }  /* ERROR, conflicting type for x */
	return x;  /* this is the parameter x */
}

static int y; /* y has internal linkage */
extern int y; /* OK, y still has internal linkage */
static int y; /* OK, y still has internal linkage */
int y;        /* ERROR, y has internal linkage */

extern int z; /* z has external linkage */
extern int z; /* OK, z still has external linkage */
int z;        /* OK, z still has external linkage */
static int z; /* ERROR, z has external linkage */

int w;        /* w has external linkage */
extern int w; /* OK, w still has external linkage */
int w;        /* OK, w still has external linkage */
static int w; /* ERROR, w has external linkage */

In order to get sparse to issue the correct errors, a lot more
code would be needed. I'm sure I could add the necessary code
eventually, but it would be better for someone who understands
the code better than me to implement this...

I prefer to provide solutions, but in this case I will have to
make do with just reporting the issue :(

Random question: I noticed the preprocessor symbols were defined
frequently; every call to preprocess() in fact: is this intended?

HTH

ATB
Ramsay Jones

P.S. I've attached extern-test.c so you can try it out yourself.
I've tried it with 5 different compilers and the results are
very uneven! Older versions of gcc (circa 3.4) don't get it
completely correct, for example.




--------------050806070605050507090105
Content-Type: text/plain;
 name="extern-test.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="extern-test.c"


int f(void) { extern float g(int); return 0; }
int g(void) { return -1; } /* ERROR, conflicting type for g() */
int h(void) { extern double g(void); return 0; }  /* ditto */

int x;  /* the extern decl. below conflicts with this x, not param */
int k(int x)
{
	{ extern float x; x=1; }  /* ERROR, conflicting type for x */
	return x;  /* this is the parameter x */
}

static int y; /* y has internal linkage */
extern int y; /* OK, y still has internal linkage */
static int y; /* OK, y still has internal linkage */
int y;        /* ERROR, y has internal linkage */

extern int z; /* z has external linkage */
extern int z; /* OK, z still has external linkage */
int z;        /* OK, z still has external linkage */
static int z; /* ERROR, z has external linkage */

int w;        /* w has external linkage */
extern int w; /* OK, w still has external linkage */
int w;        /* OK, w still has external linkage */
static int w; /* ERROR, w has external linkage */


--------------050806070605050507090105
Content-Type: text/plain;
 name="test.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="test.c"


extern __inline__ int f(int);

extern __inline__ int
f(int x)
{
	return x;
}


--------------050806070605050507090105--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Multiple translation unit regression
Date: Tue, 07 Jul 2009 06:27:22 +0000
Message-ID: <70318cbf0907062327u51a4253fub2c0f1b2f64c1a () mail ! gmail ! com>
--------------------
--0016e64ec0642465fa046e17b7aa
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

Can you try the following patch? I move the extern inline function
to file scope. Again, I still think it would be better let sparse
check one file at a time.

Chris

--0016e64ec0642465fa046e17b7aa
Content-Type: application/octet-stream; name=extern-inline
Content-Disposition: attachment; filename=extern-inline
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fwsyh0vg0

bW92ZSBleHRlcm4gaW5saW5lIGZ1bmN0aW9uIHRvIGZpbGUgc2NvcGUKCkluIGdjYyBleHRlcm4g
aW5saW5lIGZ1bmN0aW9uIGhhcyBzcGVjaWFsIG1lYW5pbmcuIFRoZSBpbmxpbmUKZnVuY3Rpb24g
d2lsbCBuZXZlciBlbWl0IHN0YW5kIGFsb25lIGNvcHkgb2YgdGhlIGZ1bmN0aW9uLiBJdCBhbHNv
CmFsbG93IG11bHRpcGxlIGltcGxlbWVudGF0aW9ucyBjcm9zcyBkaWZmZXJlbnQgZmlsZS4gVGhh
dCBlZmZlY3RpdmVseQptYWtlcyB0aGUgZXh0ZXJuIGlubGluZSBoYXMgZmlsZSBzY29wZS4KCklu
ZGV4OiBzcGFyc2UuY2hyaXNsL2V2YWx1YXRlLmMKPT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3BhcnNlLmNocmlz
bC5vcmlnL2V2YWx1YXRlLmMKKysrIHNwYXJzZS5jaHJpc2wvZXZhbHVhdGUuYwpAQCAtNTM2LDEx
ICs1MzYsNiBAQCBzdGF0aWMgaW5saW5lIGludCBsdmFsdWVfZXhwcmVzc2lvbihzdHJ1CiAJcmV0
dXJuIGV4cHItPnR5cGUgPT0gRVhQUl9QUkVPUCAmJiBleHByLT5vcCA9PSAnKic7CiB9CiAKLXN0
YXRpYyBpbmxpbmUgaW50IGlzX2Z1bmN0aW9uKHN0cnVjdCBzeW1ib2wgKnR5cGUpCi17Ci0JcmV0
dXJuIHR5cGUgJiYgdHlwZS0+dHlwZSA9PSBTWU1fRk47Ci19Ci0KIHN0YXRpYyBzdHJ1Y3Qgc3lt
Ym9sICpldmFsdWF0ZV9wdHJfYWRkKHN0cnVjdCBleHByZXNzaW9uICpleHByLCBzdHJ1Y3Qgc3lt
Ym9sICppdHlwZSkKIHsKIAlzdHJ1Y3QgZXhwcmVzc2lvbiAqaW5kZXggPSBleHByLT5yaWdodDsK
SW5kZXg6IHNwYXJzZS5jaHJpc2wvc3ltYm9sLmMKPT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3BhcnNlLmNocmlz
bC5vcmlnL3N5bWJvbC5jCisrKyBzcGFyc2UuY2hyaXNsL3N5bWJvbC5jCkBAIC01NTgsOCArNTU4
LDEwIEBAIHZvaWQgYmluZF9zeW1ib2woc3RydWN0IHN5bWJvbCAqc3ltLCBzdHIKIAlzY29wZSA9
IGJsb2NrX3Njb3BlOwogCWlmIChucyA9PSBOU19TWU1CT0wgJiYgdG9wbGV2ZWwoc2NvcGUpKSB7
CiAJCXVuc2lnbmVkIG1vZCA9IE1PRF9BRERSRVNTQUJMRSB8IE1PRF9UT1BMRVZFTDsKKwogCQlz
Y29wZSA9IGdsb2JhbF9zY29wZTsKLQkJaWYgKHN5bS0+Y3R5cGUubW9kaWZpZXJzICYgTU9EX1NU
QVRJQykgeworCQlpZiAoc3ltLT5jdHlwZS5tb2RpZmllcnMgJiBNT0RfU1RBVElDIHx8CisJCSAg
ICBpc19leHRlcm5faW5saW5lKHN5bSkpIHsKIAkJCXNjb3BlID0gZmlsZV9zY29wZTsKIAkJCW1v
ZCA9IE1PRF9UT1BMRVZFTDsKIAkJfQpJbmRleDogc3BhcnNlLmNocmlzbC9zeW1ib2wuaAo9PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09Ci0tLSBzcGFyc2UuY2hyaXNsLm9yaWcvc3ltYm9sLmgKKysrIHNwYXJzZS5jaHJpc2wv
c3ltYm9sLmgKQEAgLTM0MCw2ICszNDAsMTggQEAgc3RhdGljIGlubGluZSBpbnQgaXNfdm9pZF90
eXBlKHN0cnVjdCBzeQogCXJldHVybiB0eXBlID09ICZ2b2lkX2N0eXBlOwogfQogCitzdGF0aWMg
aW5saW5lIGludCBpc19mdW5jdGlvbihzdHJ1Y3Qgc3ltYm9sICp0eXBlKQoreworCXJldHVybiB0
eXBlICYmIHR5cGUtPnR5cGUgPT0gU1lNX0ZOOworfQorCitzdGF0aWMgaW5saW5lIGludCBpc19l
eHRlcm5faW5saW5lKHN0cnVjdCBzeW1ib2wgKnN5bSkKK3sKKwlyZXR1cm4gKHN5bS0+Y3R5cGUu
bW9kaWZpZXJzICYgTU9EX0VYVEVSTikgJiYKKwkJKHN5bS0+Y3R5cGUubW9kaWZpZXJzICYgTU9E
X0lOTElORSkgJiYKKwkJaXNfZnVuY3Rpb24oc3ltLT5jdHlwZS5iYXNlX3R5cGUpOworfQorCiBz
dGF0aWMgaW5saW5lIGludCBnZXRfc3ltX3R5cGUoc3RydWN0IHN5bWJvbCAqdHlwZSkKIHsKIAlp
ZiAodHlwZS0+dHlwZSA9PSBTWU1fTk9ERSkKSW5kZXg6IHNwYXJzZS5jaHJpc2wvdmFsaWRhdGlv
bi9leHRlcm4taW5saW5lLmMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3BhcnNlLmNocmlzbC5vcmlnL3ZhbGlk
YXRpb24vZXh0ZXJuLWlubGluZS5jCisrKyBzcGFyc2UuY2hyaXNsL3ZhbGlkYXRpb24vZXh0ZXJu
LWlubGluZS5jCkBAIC0wLDAgKzEsMTMgQEAKK2V4dGVybiBfX2lubGluZV9fIGludCBmKGludCk7
CisKK2V4dGVybiBfX2lubGluZV9fIGludAorZihpbnQgeCkKK3sKKyAgICAgICAgcmV0dXJuIHg7
Cit9CisKKy8qCisgKiBjaGVjay1uYW1lOiBleHRlcm4gaW5saW5lIGZ1bmN0aW9uCisgKiBjaGVj
ay1kZXNjcmlwdGlvbjogRXh0ZXJuIGlubGluZSBmdW5jdGlvbiBuZXZlciBlbWl0cyBzdGFuZCBh
bG9uZSBjb3B5CisgKiBvZiB0aGUgZnVuY3Rpb24uIEl0IGFsbG93cyBtdWx0aXBsZSBzdWNoIGRl
ZmluaXRpb25zIGluIGRpZmZlcmVudCBmaWxlLgorICovCg==
--0016e64ec0642465fa046e17b7aa--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: Multiple translation unit regression
Date: Wed, 08 Jul 2009 19:32:34 +0000
Message-ID: <4A54F452.8030601 () ramsay1 ! demon ! co ! uk>
--------------------
Christopher Li wrote:
> Can you try the following patch? I move the extern inline function
> to file scope. Again, I still think it would be better let sparse
> check one file at a time.
> 

This solves the problem on cygwin. I almost didn't test it on Linux,
since it looked like this should work just fine...

Unfortunately, the problem persists on Linux and I don't have time
tonight to try and debug it; I will look into it further, hopefully
tomorrow evening.

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: Multiple translation unit regression
Date: Fri, 10 Jul 2009 20:53:58 +0000
Message-ID: <4A57AA66.4080305 () ramsay1 ! demon ! co ! uk>
--------------------
This is a multi-part message in MIME format.
--------------020709020201060304050702
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

Christopher Li wrote:
> On Wed, Jul 8, 2009 at 12:32 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
>> Unfortunately, the problem persists on Linux and I don't have time
>> tonight to try and debug it; I will look into it further, hopefully
>> tomorrow evening.
> 
> If you can give me a small test case on Linux that will be great.
> I can pick it up from there.
> 

[sorry for the late reply; something came up!]

I forgot to mention that, on Linux, enabling optimization is required to
trip this, since the extern inline function definitions are #ifdef'ed out
otherwise. That does not affect the following test case, however.

I've added to the previous test.c file (Note that the declaration of
g() does not include __inline__):

$ cat -n test.c
     1	
     2	extern __inline__ int f(int);
     3	
     4	extern __inline__ int
     5	f(int x)
     6	{
     7		return x;
     8	}
     9	
    10	
    11	extern int g(int);
    12	
    13	extern __inline__ int
    14	g(int x)
    15	{
    16		return x;
    17	}
    18	
$ ./sparse test.c
$ ./sparse test.c test.c
test.c:14:1: warning: multiple definitions for function 'g'
test.c:14:1:  the previous one is here
$ cp test.c test-again.c
$ ./sparse test.c test-again.c
test-again.c:14:1: warning: multiple definitions for function 'g'
test.c:14:1:  the previous one is here
$ 

Actually, the following may be closer to the situation on Linux:

$ cat -n test.c
     1	
     2	extern __inline__ int f(int);
     3	
     4	extern __inline__ int
     5	f(int x)
     6	{
     7		return x;
     8	}
     9	
    10	
    11	extern int g(int);
    12	
    13	#ifdef __OPTIMIZE__
    14	extern __inline__ int
    15	g(int x)
    16	{
    17		return x;
    18	}
    19	#endif
    20	
$ ./sparse test.c test.c
$ ./sparse -O2 test.c test.c
test.c:15:1: warning: multiple definitions for function 'g'
test.c:15:1:  the previous one is here


HTH

ATB
Ramsay Jones


--------------020709020201060304050702
Content-Type: text/plain;
 name="test.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="test.c"


extern __inline__ int f(int);

extern __inline__ int
f(int x)
{
	return x;
}


extern int g(int);

extern __inline__ int
g(int x)
{
	return x;
}


--------------020709020201060304050702--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Multiple translation unit regression
Date: Fri, 10 Jul 2009 23:27:14 +0000
Message-ID: <70318cbf0907101627w1b9760a4oc7d13969751e3d00 () mail ! gmail ! com>
--------------------
--0016e647f026fb924a046e624f59
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

On Fri, Jul 10, 2009 at 1:53 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> w=
rote:
> =A0 =A011 =A0extern int g(int);
> =A0 =A012
> =A0 =A013 =A0extern __inline__ int
> =A0 =A014 =A0g(int x)
> =A0 =A015 =A0{
> =A0 =A016 =A0 =A0 =A0 =A0 =A0return x;
> =A0 =A017 =A0}
> =A0 =A018

Err, that is ugly. I just find out what happen there.
The none inline version picks up the function definition
from the inline version because they are both "extern".
Sparse only has one global extern scope.

Later even the inline version get remove from the
filescope, the second file still conflict with the non-inline
version of the function body, which steal from the inline
version.

I add two lines to distinguish the "extern inline" vs "extern".
They are not the same_symbol any more. Because effectly
the "extern inline" is not visiable in the global "extern" scope.
Any one see problem using this approach?

I attach the patch follows. Can you give it a try?

Chris

--0016e647f026fb924a046e624f59
Content-Type: application/octet-stream; name=extern-inline-1
Content-Disposition: attachment; filename=extern-inline-1
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fwz20m1k1

bW92ZSBleHRlcm4gaW5saW5lIGZ1bmN0aW9uIHRvIGZpbGUgc2NvcGUKCkluIGdjYyBleHRlcm4g
aW5saW5lIGZ1bmN0aW9uIGhhcyBzcGVjaWFsIG1lYW5pbmcuIFRoZSBpbmxpbmUKZnVuY3Rpb24g
d2lsbCBuZXZlciBlbWl0IHN0YW5kIGFsb25lIGNvcHkgb2YgdGhlIGZ1bmN0aW9uLiBJdCBhbHNv
CmFsbG93IG11bHRpcGxlIGltcGxlbWVudGF0aW9ucyBjcm9zcyBkaWZmZXJlbnQgZmlsZS4gVGhh
dCBlZmZlY3RpdmVseQptYWtlcyB0aGUgZXh0ZXJuIGlubGluZSBoYXMgZmlsZSBzY29wZS4KCklu
ZGV4OiBzcGFyc2UuY2hyaXNsL3N5bWJvbC5oCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5jaHJpc2wu
b3JpZy9zeW1ib2wuaAorKysgc3BhcnNlLmNocmlzbC9zeW1ib2wuaApAQCAtMzQwLDYgKzM0MCwx
OCBAQCBzdGF0aWMgaW5saW5lIGludCBpc192b2lkX3R5cGUoc3RydWN0IHN5CiAJcmV0dXJuIHR5
cGUgPT0gJnZvaWRfY3R5cGU7CiB9CiAKK3N0YXRpYyBpbmxpbmUgaW50IGlzX2Z1bmN0aW9uKHN0
cnVjdCBzeW1ib2wgKnR5cGUpCit7CisJcmV0dXJuIHR5cGUgJiYgdHlwZS0+dHlwZSA9PSBTWU1f
Rk47Cit9CisKK3N0YXRpYyBpbmxpbmUgaW50IGlzX2V4dGVybl9pbmxpbmUoc3RydWN0IHN5bWJv
bCAqc3ltKQoreworCXJldHVybiAoc3ltLT5jdHlwZS5tb2RpZmllcnMgJiBNT0RfRVhURVJOKSAm
JgorCQkoc3ltLT5jdHlwZS5tb2RpZmllcnMgJiBNT0RfSU5MSU5FKSAmJgorCQlpc19mdW5jdGlv
bihzeW0tPmN0eXBlLmJhc2VfdHlwZSk7Cit9CisKIHN0YXRpYyBpbmxpbmUgaW50IGdldF9zeW1f
dHlwZShzdHJ1Y3Qgc3ltYm9sICp0eXBlKQogewogCWlmICh0eXBlLT50eXBlID09IFNZTV9OT0RF
KQpJbmRleDogc3BhcnNlLmNocmlzbC9ldmFsdWF0ZS5jCj09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5j
aHJpc2wub3JpZy9ldmFsdWF0ZS5jCisrKyBzcGFyc2UuY2hyaXNsL2V2YWx1YXRlLmMKQEAgLTUz
NiwxMSArNTM2LDYgQEAgc3RhdGljIGlubGluZSBpbnQgbHZhbHVlX2V4cHJlc3Npb24oc3RydQog
CXJldHVybiBleHByLT50eXBlID09IEVYUFJfUFJFT1AgJiYgZXhwci0+b3AgPT0gJyonOwogfQog
Ci1zdGF0aWMgaW5saW5lIGludCBpc19mdW5jdGlvbihzdHJ1Y3Qgc3ltYm9sICp0eXBlKQotewot
CXJldHVybiB0eXBlICYmIHR5cGUtPnR5cGUgPT0gU1lNX0ZOOwotfQotCiBzdGF0aWMgc3RydWN0
IHN5bWJvbCAqZXZhbHVhdGVfcHRyX2FkZChzdHJ1Y3QgZXhwcmVzc2lvbiAqZXhwciwgc3RydWN0
IHN5bWJvbCAqaXR5cGUpCiB7CiAJc3RydWN0IGV4cHJlc3Npb24gKmluZGV4ID0gZXhwci0+cmln
aHQ7CkluZGV4OiBzcGFyc2UuY2hyaXNsL3N5bWJvbC5jCj09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5j
aHJpc2wub3JpZy9zeW1ib2wuYworKysgc3BhcnNlLmNocmlzbC9zeW1ib2wuYwpAQCAtNTIyLDYg
KzUyMiw4IEBAIHZvaWQgY2hlY2tfZGVjbGFyYXRpb24oc3RydWN0IHN5bWJvbCAqc3kKIAkJCXJl
dHVybjsKIAkJfQogCQlpZiAoc3ltLT5jdHlwZS5tb2RpZmllcnMgJiBuZXh0LT5jdHlwZS5tb2Rp
ZmllcnMgJiBNT0RfRVhURVJOKSB7CisJCQlpZiAoKHN5bS0+Y3R5cGUubW9kaWZpZXJzIF4gbmV4
dC0+Y3R5cGUubW9kaWZpZXJzKSAmIE1PRF9JTkxJTkUpCisJCQkJY29udGludWU7CiAJCQlzeW0t
PnNhbWVfc3ltYm9sID0gbmV4dDsKIAkJCXJldHVybjsKIAkJfQpAQCAtNTU4LDggKzU2MCwxMCBA
QCB2b2lkIGJpbmRfc3ltYm9sKHN0cnVjdCBzeW1ib2wgKnN5bSwgc3RyCiAJc2NvcGUgPSBibG9j
a19zY29wZTsKIAlpZiAobnMgPT0gTlNfU1lNQk9MICYmIHRvcGxldmVsKHNjb3BlKSkgewogCQl1
bnNpZ25lZCBtb2QgPSBNT0RfQUREUkVTU0FCTEUgfCBNT0RfVE9QTEVWRUw7CisKIAkJc2NvcGUg
PSBnbG9iYWxfc2NvcGU7Ci0JCWlmIChzeW0tPmN0eXBlLm1vZGlmaWVycyAmIE1PRF9TVEFUSUMp
IHsKKwkJaWYgKHN5bS0+Y3R5cGUubW9kaWZpZXJzICYgTU9EX1NUQVRJQyB8fAorCQkgICAgaXNf
ZXh0ZXJuX2lubGluZShzeW0pKSB7CiAJCQlzY29wZSA9IGZpbGVfc2NvcGU7CiAJCQltb2QgPSBN
T0RfVE9QTEVWRUw7CiAJCX0KSW5kZXg6IHNwYXJzZS5jaHJpc2wvc2NvcGUuYwo9PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
CkluZGV4OiBzcGFyc2UuY2hyaXNsL3ZhbGlkYXRpb24vZXh0ZXJuLWlubGluZS5jCj09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT0KLS0tIHNwYXJzZS5jaHJpc2wub3JpZy92YWxpZGF0aW9uL2V4dGVybi1pbmxpbmUuYworKysg
c3BhcnNlLmNocmlzbC92YWxpZGF0aW9uL2V4dGVybi1pbmxpbmUuYwpAQCAtMCwwICsxLDIyIEBA
CitleHRlcm4gX19pbmxpbmVfXyBpbnQgZihpbnQpOworCitleHRlcm4gX19pbmxpbmVfXyBpbnQK
K2YoaW50IHgpCit7CisgICAgICAgIHJldHVybiB4OworfQorCitleHRlcm4gaW50IGcoaW50KTsK
KworZXh0ZXJuIF9faW5saW5lX18gaW50CitnKGludCB4KQoreworICAgICAgICByZXR1cm4geDsK
K30KKworCisvKgorICogY2hlY2stbmFtZTogZXh0ZXJuIGlubGluZSBmdW5jdGlvbgorICogY2hl
Y2stZGVzY3JpcHRpb246IEV4dGVybiBpbmxpbmUgZnVuY3Rpb24gbmV2ZXIgZW1pdHMgc3RhbmQg
YWxvbmUgY29weQorICogb2YgdGhlIGZ1bmN0aW9uLiBJdCBhbGxvd3MgbXVsdGlwbGUgc3VjaCBk
ZWZpbml0aW9ucyBpbiBkaWZmZXJlbnQgZmlsZS4KKyAqLwo=
--0016e647f026fb924a046e624f59--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: Multiple translation unit regression
Date: Mon, 13 Jul 2009 17:43:51 +0000
Message-ID: <4A5B7257.9090409 () ramsay1 ! demon ! co ! uk>
--------------------
Christopher Li wrote:
> I attach the patch follows. Can you give it a try?
> 

Yep, this works.
Tested on cygwin and Linux.

Thanks!

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: Multiple translation unit regression
Date: Sat, 18 Jul 2009 20:26:23 +0000
Message-ID: <4A622FEF.2010704 () ramsay1 ! demon ! co ! uk>
--------------------
This is a multi-part message in MIME format.
--------------070204070908000208010502
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

Ramsay Jones wrote:
> Christopher Li wrote:
>> I attach the patch follows. Can you give it a try?
>>
> 
> Yep, this works.
> Tested on cygwin and Linux.
> 
> Thanks!
> 

BTW, I forgot to mention that I changed the test file so that
it would fail before applying the rest of this patch, and
pass afterward.

I've attached the new file. The diff is as follows:

-->8--
diff --git a/validation/extern-inline.c b/validation/extern-inline.c
index 13af438..4f12ac0 100644
--- a/validation/extern-inline.c
+++ b/validation/extern-inline.c
@@ -17,6 +17,7 @@ g(int x)
 
 /*
  * check-name: extern inline function
+ * check-command: sparse $file $file
  * check-description: Extern inline function never emits stand alone copy
  * of the function. It allows multiple such definitions in different file.
  */
-->8--

HTH.

ATB,
Ramsay Jones


--------------070204070908000208010502
Content-Type: text/plain;
 name="extern-inline.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="extern-inline.c"

extern __inline__ int f(int);

extern __inline__ int
f(int x)
{
        return x;
}

extern int g(int);

extern __inline__ int
g(int x)
{
        return x;
}


/*
 * check-name: extern inline function
 * check-command: sparse $file $file
 * check-description: Extern inline function never emits stand alone copy
 * of the function. It allows multiple such definitions in different file.
 */

--------------070204070908000208010502--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Multiple translation unit regression
Date: Sat, 18 Jul 2009 21:53:01 +0000
Message-ID: <70318cbf0907181453u1af5a96ie85fc4d47af8db14 () mail ! gmail ! com>
--------------------
On Sat, Jul 18, 2009 at 1:26 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
>
> BTW, I forgot to mention that I changed the test file so that
> it would fail before applying the rest of this patch, and
> pass afterward.
>
> I've attached the new file. The diff is as follows:

Thanks. Will apply that.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new ===

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-kernel
Subject: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Thu, 19 Mar 2009 19:07:31 +0000
Message-ID: <20090319190730.GC28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Mar 19, 2009 at 07:51:22PM +0100, Hannes Eder wrote:
> When currently running sparse agains the current linux-next tree, a
> lot of checks produce error messages like this:
> 
> include/linux/skbuff.h:381:9: error: expected preprocessor identifier

Cute.  If anything, this kmemcheck_define_bitfield stuff needs to be moved
inside the ifdefs.

Folks, this is not a valid C, period.  And no, there's no promise that
gcc won't change its behaviour on such constructs whenever they feel
like that.

Preprocessor directives do not belong in argument lists.  Not #ifdef,
not #define, not #include; this is undefined behaviour.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Thu, 19 Mar 2009 19:07:31 +0000
Message-ID: <20090319190730.GC28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Mar 19, 2009 at 07:51:22PM +0100, Hannes Eder wrote:
> When currently running sparse agains the current linux-next tree, a
> lot of checks produce error messages like this:
> 
> include/linux/skbuff.h:381:9: error: expected preprocessor identifier

Cute.  If anything, this kmemcheck_define_bitfield stuff needs to be moved
inside the ifdefs.

Folks, this is not a valid C, period.  And no, there's no promise that
gcc won't change its behaviour on such constructs whenever they feel
like that.

Preprocessor directives do not belong in argument lists.  Not #ifdef,
not #define, not #include; this is undefined behaviour.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Thu, 19 Mar 2009 19:27:58 +0000
Message-ID: <20090319192758.GB24318 () elte ! hu>
--------------------

* Al Viro <viro@ZenIV.linux.org.uk> wrote:

> On Thu, Mar 19, 2009 at 07:51:22PM +0100, Hannes Eder wrote:
> > When currently running sparse agains the current linux-next tree, a
> > lot of checks produce error messages like this:
> > 
> > include/linux/skbuff.h:381:9: error: expected preprocessor identifier
> 
> Cute.  If anything, this kmemcheck_define_bitfield stuff needs to be moved
> inside the ifdefs.
> 
> Folks, this is not a valid C, period.  And no, there's no promise 
> that gcc won't change its behaviour on such constructs whenever 
> they feel like that.
> 
> Preprocessor directives do not belong in argument lists.  Not 
> #ifdef, not #define, not #include; this is undefined behaviour.

Agreed.

Vegard, it's this bit:

        kmemcheck_define_bitfield(flags2, {
#ifdef CONFIG_IPV6_NDISC_NODETYPE
                __u8                    ndisc_nodetype:2;
#endif
#if defined(CONFIG_MAC80211) || defined(CONFIG_MAC80211_MODULE)
                __u8                    do_not_encrypt:1;
                __u8                    requeue:1;
#endif
        });

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Thu, 19 Mar 2009 19:39:10 +0000
Message-ID: <20090319193910.GE28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Mar 19, 2009 at 08:27:58PM +0100, Ingo Molnar wrote:
> Vegard, it's this bit:
> 
>         kmemcheck_define_bitfield(flags2, {
> #ifdef CONFIG_IPV6_NDISC_NODETYPE
>                 __u8                    ndisc_nodetype:2;
> #endif
> #if defined(CONFIG_MAC80211) || defined(CONFIG_MAC80211_MODULE)
>                 __u8                    do_not_encrypt:1;
>                 __u8                    requeue:1;
> #endif
>         });

BTW, there's a related turd: kernel/cred.c
        if (
#ifdef CONFIG_KEYS
                !p->cred->thread_keyring &&
#endif
                clone_flags & CLONE_THREAD
            ) {
is not only ucking fugly, it's not a valid C if you have PROFILE_ALL_BRANCHES
set.  Why?  Because then we get if() #defined ;-/

BTW^2, speaking of that ifdef...  What happens to
static void put_cred_rcu(struct rcu_head *rcu)
{
        struct cred *cred = container_of(rcu, struct cred, rcu);

        if (atomic_read(&cred->usage) != 0)
                panic("CRED: put_cred_rcu() sees %p with usage %d\n",
                      cred, atomic_read(&cred->usage));

        security_cred_free(cred);
        key_put(cred->thread_keyring);
        key_put(cred->request_key_auth);
        release_tgcred(cred);
        put_group_info(cred->group_info);
        free_uid(cred->user);
        kmem_cache_free(cred_jar, cred);
}
if CONFIG_KEYS is not set?
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Thu, 19 Mar 2009 19:39:10 +0000
Message-ID: <20090319193910.GE28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Mar 19, 2009 at 08:27:58PM +0100, Ingo Molnar wrote:
> Vegard, it's this bit:
> 
>         kmemcheck_define_bitfield(flags2, {
> #ifdef CONFIG_IPV6_NDISC_NODETYPE
>                 __u8                    ndisc_nodetype:2;
> #endif
> #if defined(CONFIG_MAC80211) || defined(CONFIG_MAC80211_MODULE)
>                 __u8                    do_not_encrypt:1;
>                 __u8                    requeue:1;
> #endif
>         });

BTW, there's a related turd: kernel/cred.c
        if (
#ifdef CONFIG_KEYS
                !p->cred->thread_keyring &&
#endif
                clone_flags & CLONE_THREAD
            ) {
is not only ucking fugly, it's not a valid C if you have PROFILE_ALL_BRANCHES
set.  Why?  Because then we get if() #defined ;-/

BTW^2, speaking of that ifdef...  What happens to
static void put_cred_rcu(struct rcu_head *rcu)
{
        struct cred *cred = container_of(rcu, struct cred, rcu);

        if (atomic_read(&cred->usage) != 0)
                panic("CRED: put_cred_rcu() sees %p with usage %d\n",
                      cred, atomic_read(&cred->usage));

        security_cred_free(cred);
        key_put(cred->thread_keyring);
        key_put(cred->request_key_auth);
        release_tgcred(cred);
        put_group_info(cred->group_info);
        free_uid(cred->user);
        kmem_cache_free(cred_jar, cred);
}
if CONFIG_KEYS is not set?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Vegard Nossum <vegard.nossum () gmail ! com>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Thu, 19 Mar 2009 20:20:51 +0000
Message-ID: <19f34abd0903191320qdd73530ud85081d23e17b266 () mail ! gmail ! com>
--------------------
2009/3/19 Ingo Molnar <mingo@elte.hu>:
>
> * Al Viro <viro@ZenIV.linux.org.uk> wrote:
>
>> On Thu, Mar 19, 2009 at 07:51:22PM +0100, Hannes Eder wrote:
>> > When currently running sparse agains the current linux-next tree, a
>> > lot of checks produce error messages like this:
>> >
>> > include/linux/skbuff.h:381:9: error: expected preprocessor identifier
>>
>> Cute. Â If anything, this kmemcheck_define_bitfield stuff needs to be moved
>> inside the ifdefs.
>>
>> Folks, this is not a valid C, period. Â And no, there's no promise
>> that gcc won't change its behaviour on such constructs whenever
>> they feel like that.
>>
>> Preprocessor directives do not belong in argument lists. Â Not
>> #ifdef, not #define, not #include; this is undefined behaviour.
>
> Agreed.
>
> Vegard, it's this bit:
>
> Â  Â  Â  Â kmemcheck_define_bitfield(flags2, {
> #ifdef CONFIG_IPV6_NDISC_NODETYPE
> Â  Â  Â  Â  Â  Â  Â  Â __u8 Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ndisc_nodetype:2;
> #endif
> #if defined(CONFIG_MAC80211) || defined(CONFIG_MAC80211_MODULE)
> Â  Â  Â  Â  Â  Â  Â  Â __u8 Â  Â  Â  Â  Â  Â  Â  Â  Â  Â do_not_encrypt:1;
> Â  Â  Â  Â  Â  Â  Â  Â __u8 Â  Â  Â  Â  Â  Â  Â  Â  Â  Â requeue:1;
> #endif
> Â  Â  Â  Â });
>
> Â  Â  Â  Â Ingo
>

Hm.

Is this really not valid C?

It worked with GCC, so I assumed it was. My mistake.

Okay, that puts us in a bit of a tight spot, with regards to kmemcheck, I mean.

Maybe I should just take up GCC development instead, and implement a
-fkmemcheck or something.

(To get rid of the bitfield false positives, I mean.)

I guess this means that kmemcheck branch should be withdrawn from
linux-next, at least temporarily, as I have no immediate
workarounds/alternatives. Stephen, can you drop it?


Vegard

-- 
"The animistic metaphor of the bug that maliciously sneaked in while
the programmer was not looking is intellectually dishonest as it
disguises that the error is the programmer's own creation."
	-- E. W. Dijkstra, EWD1036
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Stephen Rothwell <sfr () canb ! auug ! org ! au>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Thu, 19 Mar 2009 22:07:08 +0000
Message-ID: <20090320090708.b87580a4.sfr () canb ! auug ! org ! au>
--------------------
--Signature=_Fri__20_Mar_2009_09_07_08_+1100_.o=X60qHxJJ/lBOR
Content-Type: text/plain; charset=US-ASCII
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

Hi Vegard,

On Thu, 19 Mar 2009 21:20:51 +0100 Vegard Nossum <vegard.nossum@gmail.com> =
wrote:
>
> I guess this means that kmemcheck branch should be withdrawn from
> linux-next, at least temporarily, as I have no immediate
> workarounds/alternatives. Stephen, can you drop it?

OK, I will remove it starting today.  Let me know when you want it back
in.

--=20
Cheers,
Stephen Rothwell                    sfr@canb.auug.org.au
http://www.canb.auug.org.au/~sfr/

--Signature=_Fri__20_Mar_2009_09_07_08_+1100_.o=X60qHxJJ/lBOR
Content-Type: application/pgp-signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)

iEYEARECAAYFAknCwgwACgkQjjKRsyhoI8wsJACfYe7sORkN/86nZ6dI7KEMomzI
bpIAoIn8aE8P/apZ+FdkGn13cn5ODkO2
=HWIO
-----END PGP SIGNATURE-----

--Signature=_Fri__20_Mar_2009_09_07_08_+1100_.o=X60qHxJJ/lBOR--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 18:08:53 +0000
Message-ID: <20090320180853.GA24154 () elte ! hu>
--------------------

* Vegard Nossum <vegard.nossum@gmail.com> wrote:

> I guess this means that kmemcheck branch should be withdrawn from 
> linux-next, at least temporarily, as I have no immediate 
> workarounds/alternatives. Stephen, can you drop it?

Al Viro, well done :-(

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ingo Molnar <mingo () elte ! hu>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 18:08:53 +0000
Message-ID: <20090320180853.GA24154 () elte ! hu>
--------------------

* Vegard Nossum <vegard.nossum@gmail.com> wrote:

> I guess this means that kmemcheck branch should be withdrawn from 
> linux-next, at least temporarily, as I have no immediate 
> workarounds/alternatives. Stephen, can you drop it?

Al Viro, well done :-(

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 19:04:09 +0000
Message-ID: <20090320190409.GH28946 () ZenIV ! linux ! org ! uk>
--------------------
On Fri, Mar 20, 2009 at 07:08:53PM +0100, Ingo Molnar wrote:
> 
> * Vegard Nossum <vegard.nossum@gmail.com> wrote:
> 
> > I guess this means that kmemcheck branch should be withdrawn from 
> > linux-next, at least temporarily, as I have no immediate 
> > workarounds/alternatives. Stephen, can you drop it?
> 
> Al Viro, well done :-(
> 
> 	Ingo

What the fuck?

Al
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 19:04:09 +0000
Message-ID: <20090320190409.GH28946 () ZenIV ! linux ! org ! uk>
--------------------
On Fri, Mar 20, 2009 at 07:08:53PM +0100, Ingo Molnar wrote:
> 
> * Vegard Nossum <vegard.nossum@gmail.com> wrote:
> 
> > I guess this means that kmemcheck branch should be withdrawn from 
> > linux-next, at least temporarily, as I have no immediate 
> > workarounds/alternatives. Stephen, can you drop it?
> 
> Al Viro, well done :-(
> 
> 	Ingo

What the fuck?

Al
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 19:14:07 +0000
Message-ID: <20090320191407.GI28946 () ZenIV ! linux ! org ! uk>
--------------------
On Fri, Mar 20, 2009 at 07:04:09PM +0000, Al Viro wrote:
> On Fri, Mar 20, 2009 at 07:08:53PM +0100, Ingo Molnar wrote:
> > 
> > * Vegard Nossum <vegard.nossum@gmail.com> wrote:
> > 
> > > I guess this means that kmemcheck branch should be withdrawn from 
> > > linux-next, at least temporarily, as I have no immediate 
> > > workarounds/alternatives. Stephen, can you drop it?
> > 
> > Al Viro, well done :-(
> > 
> > 	Ingo
> 
> What the fuck?

While we are at it, there *is* an obvious workaround:
#ifdef ...
	#define L1 <list>
#else
	#define L1
#endif
#ifdef ...
	#define L2 <list>
#else
	#define L2
#endif
	your_macro(...
	L1
	L2
	...)
#undef L1
#undef L2

Ingo, care to explain what the hell had your reply above been about?
Especially since we both apparently agree that code in question did
need fixing, what with your immediate ACK upthread...
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Vegard Nossum <vegard.nossum () gmail ! com>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 23:16:17 +0000
Message-ID: <19f34abd0903201616v4175b5afn5630fcae02d7ff4f () mail ! gmail ! com>
--------------------
[removed duplicate Al Viro from Cc]

2009/3/20 Al Viro <viro@zeniv.linux.org.uk>:
> On Fri, Mar 20, 2009 at 07:04:09PM +0000, Al Viro wrote:
>> On Fri, Mar 20, 2009 at 07:08:53PM +0100, Ingo Molnar wrote:
>> >
>> > * Vegard Nossum <vegard.nossum@gmail.com> wrote:
>> >
>> > > I guess this means that kmemcheck branch should be withdrawn from
>> > > linux-next, at least temporarily, as I have no immediate
>> > > workarounds/alternatives. Stephen, can you drop it?
>> >
>> > Al Viro, well done :-(

[snip]

> Ingo, care to explain what the hell had your reply above been about?
> Especially since we both apparently agree that code in question did
> need fixing, what with your immediate ACK upthread...
>

Hi,

I think it is simply the frustration of discovering this rather
serious flaw just when the dust has settled, and with no capacity to
really fix it in a satisfactory way. But we should be thankful for the
heads up and try again to remember the value of linux-next and those
who test it!

(The solution you sketched is still quite an uglification of the
original code, something we tried to minimize using the construct you
saw.)

So, Ingo: There's no way this could have been merged in mainline with
such a defect, and it would be a lot worse if it wasn't discovered at
this point. We'll just have to be creative (again!) and I'm sure
Stephen can revive the tree when it's been fixed.


Vegard
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Vegard Nossum <vegard.nossum () gmail ! com>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 23:16:17 +0000
Message-ID: <19f34abd0903201616v4175b5afn5630fcae02d7ff4f () mail ! gmail ! com>
--------------------
[removed duplicate Al Viro from Cc]

2009/3/20 Al Viro <viro@zeniv.linux.org.uk>:
> On Fri, Mar 20, 2009 at 07:04:09PM +0000, Al Viro wrote:
>> On Fri, Mar 20, 2009 at 07:08:53PM +0100, Ingo Molnar wrote:
>> >
>> > * Vegard Nossum <vegard.nossum@gmail.com> wrote:
>> >
>> > > I guess this means that kmemcheck branch should be withdrawn from
>> > > linux-next, at least temporarily, as I have no immediate
>> > > workarounds/alternatives. Stephen, can you drop it?
>> >
>> > Al Viro, well done :-(

[snip]

> Ingo, care to explain what the hell had your reply above been about?
> Especially since we both apparently agree that code in question did
> need fixing, what with your immediate ACK upthread...
>

Hi,

I think it is simply the frustration of discovering this rather
serious flaw just when the dust has settled, and with no capacity to
really fix it in a satisfactory way. But we should be thankful for the
heads up and try again to remember the value of linux-next and those
who test it!

(The solution you sketched is still quite an uglification of the
original code, something we tried to minimize using the construct you
saw.)

So, Ingo: There's no way this could have been merged in mainline with
such a defect, and it would be a lot worse if it wasn't discovered at
this point. We'll just have to be creative (again!) and I'm sure
Stephen can revive the tree when it's been fixed.


Vegard
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 23:44:12 +0000
Message-ID: <20090320234412.GK28946 () ZenIV ! linux ! org ! uk>
--------------------
On Sat, Mar 21, 2009 at 12:16:17AM +0100, Vegard Nossum wrote:

> (The solution you sketched is still quite an uglification of the
> original code, something we tried to minimize using the construct you
> saw.)

Frankly, I'd suggest expanding that sucker and being done with that.
However, more interesting question is whether you really need the
named field to be a struct.  If not, something like
bitfields_start(name)
....
bitfields_end
would work just fine, without all that fun.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 20 Mar 2009 23:44:12 +0000
Message-ID: <20090320234412.GK28946 () ZenIV ! linux ! org ! uk>
--------------------
On Sat, Mar 21, 2009 at 12:16:17AM +0100, Vegard Nossum wrote:

> (The solution you sketched is still quite an uglification of the
> original code, something we tried to minimize using the construct you
> saw.)

Frankly, I'd suggest expanding that sucker and being done with that.
However, more interesting question is whether you really need the
named field to be a struct.  If not, something like
bitfields_start(name)
....
bitfields_end
would work just fine, without all that fun.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Sat, 21 Mar 2009 08:34:06 +0000
Message-ID: <1237624446.5100.171.camel () johannes ! local>
--------------------

--=-vCmA5GnLiL2qfwiRF9bn
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Fri, 2009-03-20 at 19:14 +0000, Al Viro wrote:

> Ingo, care to explain what the hell had your reply above been about?

Yes, please do. You're showing a little confusing behaviour here,
telling me in one thread to show more respect for other people, and ...

johannes

--=-vCmA5GnLiL2qfwiRF9bn
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----
Comment: Johannes Berg (powerbook)

iQIcBAABAgAGBQJJxKZ7AAoJEKVg1VMiehFYRVEP/2JWZfgOT7yLkweCyMizMgZ+
sGmCWxY/tbmjYow3vPp/2VytQN5cHuG0YRbzFTDFlRfebhqdQ/CyL1JyHzZzSu7U
HWeQDrR5E/EdrZs7Tg3QFKUzEsjIZ4GMfB139iPwr9K6C2HM18R42GioCiz1kOwD
bMc8IBH7ODSJIOGCeJpHiGiqZE/uZLeXmlOChw/qkFqiw/b1StZSmexvDe9+epET
Ub3xMH3H2jSAs71NH4wWyDq1b0OiLrG0X3A10igjGJoW+JktYXGhqgIa4Dq9N7L/
SjaYcuneHnb6uBqAdW43fXA1g9TPoGDM4L7kscDpMr7SHGV0Qieaawf+xFy00O5m
tO8rArvbnDMrXj0sjjM28+VXCNT6rTdVcRZ3XWA6Q6u86Rx9dyTEq7fou1Zgs1WI
LTP5b76x9Nr0YjXIAN43TYX/C+zyiODEp4oj5fFTUERJrmH9xZploiZQAGCiPxSm
btw4jNEnQyuSoV1vHzSr8VH0O/u65ZN3hggN+xgZXf89QQTFjLoClt0GX4moJE6Z
R/0DTUqFYF41eR31QBT5gaTutiWpjJkmAeuZFOR9NXaf7iL59GHBqFWZ25oHbXpf
z3VlaRs4eyZHjilhGXFVewJUR1eSTaKpsWbPeEYYFD/T8P0t05yRhNmH1G6oU56b
pL/xY2cHrwPBfN6ny9J6
=D6l6
-----END PGP SIGNATURE-----

--=-vCmA5GnLiL2qfwiRF9bn--

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "H. Peter Anvin" <hpa () zytor ! com>
To: linux-kernel
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 27 Mar 2009 03:13:05 +0000
Message-ID: <49CC4441.8060205 () zytor ! com>
--------------------
Johannes Berg wrote:
> On Fri, 2009-03-20 at 19:14 +0000, Al Viro wrote:
> 
>> Ingo, care to explain what the hell had your reply above been about?
> 
> Yes, please do. You're showing a little confusing behaviour here,
> telling me in one thread to show more respect for other people, and ...
> 
> johannes

I'm not Ingo, but I took his statement at exactly face value...

Well done for catching a serious problem, and :-( for the serious 
problem being discovered at this late stage.

	-hpa
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "H. Peter Anvin" <hpa () zytor ! com>
To: linux-sparse
Subject: Re: Nasal demons in preprocessor use (Re: [PATCH] test-suite: new
Date: Fri, 27 Mar 2009 03:13:05 +0000
Message-ID: <49CC4441.8060205 () zytor ! com>
--------------------
Johannes Berg wrote:
> On Fri, 2009-03-20 at 19:14 +0000, Al Viro wrote:
> 
>> Ingo, care to explain what the hell had your reply above been about?
> 
> Yes, please do. You're showing a little confusing behaviour here,
> telling me in one thread to show more respect for other people, and ...
> 
> johannes

I'm not Ingo, but I took his statement at exactly face value...

Well done for catching a serious problem, and :-( for the serious 
problem being discovered at this late stage.

	-hpa
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Question: attribute 'naked' ===

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?=
To: linux-sparse
Subject: Re: Question: attribute 'naked'
Date: Wed, 05 Aug 2009 07:50:47 +0000
Message-ID: <20090805075047.GC18938 () pengutronix ! de>
--------------------
Hello,

On Wed, Aug 05, 2009 at 08:19:36AM +0200, Sam Ravnborg wrote:
> cc: linux-sparse
> On Tue, Aug 04, 2009 at 11:15:11PM +0100, Russell King - ARM Linux wrote:
> > On Tue, Aug 04, 2009 at 06:03:22PM -0400, H Hartley Sweeten wrote:
> > > When compiling the kernel with sparse, in arch/arm/mm/copypage-v4wb.c
> > > I get the following error:
> > > 
> > > arch/arm/mm/copypage-v4wb.c:25:13: error: attribute 'naked': unknown attribute 
> > 
> > Sparse doesn't understand the naked attribute.  GCC does.
> > 
> > > /*
> > >  * it doesn't make sense on ARM (currently the only user of __naked) to trace
> > >  * naked functions because then mcount is called without stack and frame pointer
> > >  * being set up and there is no chance to restore the lr register to the value
> > >  * before mcount was called.
> > >  */
> > > #define __naked				__attribute__((naked)) notrace
> > > 
> > > Is this macro actually correct?  The compiler I am using is:
Quoting gcc documentation:

     Use [naked] on the ARM, AVR, IP2K and SPU ports to indicate
     that the specified function does not need prologue/epilogue
     sequences generated by the compiler.  It is up to the programmer
     to provide these sequences.

This is typically used for functions that only consist of a single asm
statement.

Best regards
Uwe

-- 
Pengutronix e.K.                              | Uwe Kleine-König            |
Industrial Linux Solutions                    | http://www.pengutronix.de/  |
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re: Getting info from used typedef ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Re: Getting info from used typedef
Date: Tue, 01 Dec 2009 18:49:18 +0000
Message-ID: <70318cbf0912011049w4cab5e4qa74a15371511c8a4 () mail ! gmail ! com>
--------------------
--0016e6d976262e4f490479af37a5
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

On Tue, Dec 1, 2009 at 4:30 AM, Thomas Schmid
<Thomas.Schmid@br-automation.com> wrote:
> Of course: I wrote a tool, which converts C-declarations into another
> format (IEC61131).
> These generated declarations are used as a interface to communicate to
> programs of different languages.
> This IEC-format uses datatypes, which are not known in ANSI C, such as th=
e
> following:
>
> typedef signed long =A0 =A0DINT;
> typedef unsigned long =A0UDINT;
> typedef signed long =A0 =A0TIME;
> typedef unsigned long =A0DATE_AND_TIME;
> typedef unsigned short UINT;
> typedef unsigned short WSTRING;
>

So you only use sparse as a C source code processing tool. You don't
care about the back end part of the sparse right?

In that case, you can try this one line patch. It should preserve the typed=
ef
symbol as the base type. I will not commit that to main line though.

Will that work for you?

Chris

--0016e6d976262e4f490479af37a5
Content-Type: application/octet-stream; 
	name="0001-hacking-preserve-typedef-name.patch"
Content-Disposition: attachment; 
	filename="0001-hacking-preserve-typedef-name.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_g2p0rvuw0

RnJvbSA2ZjFhNTc3YWY3ZDlmYTIzYzkwNzBmMjc4YmRhYjAyZGJmOGZiMDY4IE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBUdWUsIDEgRGVjIDIwMDkgMTA6Mzg6MDIgLTA4MDAKU3ViamVjdDogW1BBVENIXSBoYWNr
aW5nIHByZXNlcnZlIHR5cGVkZWYgbmFtZS4KCi0tLQogcGFyc2UuYyB8ICAgIDIgKy0KIDEgZmls
ZXMgY2hhbmdlZCwgMSBpbnNlcnRpb25zKCspLCAxIGRlbGV0aW9ucygtKQoKZGlmZiAtLWdpdCBh
L3BhcnNlLmMgYi9wYXJzZS5jCmluZGV4IDY2YjgxMTIuLjI0OTEzNWIgMTAwNjQ0Ci0tLSBhL3Bh
cnNlLmMKKysrIGIvcGFyc2UuYwpAQCAtMTQyOSw3ICsxNDI5LDcgQEAgc3RhdGljIHN0cnVjdCB0
b2tlbiAqZGVjbGFyYXRpb25fc3BlY2lmaWVycyhzdHJ1Y3QgdG9rZW4gKnRva2VuLCBzdHJ1Y3Qg
ZGVjbF9zdGEKIAkJCWlmIChzZWVuICYgU2V0X0FueSkKIAkJCQlicmVhazsKIAkJCXNlZW4gfD0g
U2V0X1MgfCBTZXRfVDsKLQkJCWN0eC0+Y3R5cGUuYmFzZV90eXBlID0gcy0+Y3R5cGUuYmFzZV90
eXBlOworCQkJY3R4LT5jdHlwZS5iYXNlX3R5cGUgPSBzOwogCQkJYXBwbHlfY3R5cGUodG9rZW4t
PnBvcywgJnMtPmN0eXBlLCAmY3R4LT5jdHlwZSk7CiAJCQl0b2tlbiA9IHRva2VuLT5uZXh0Owog
CQkJY29udGludWU7Ci0tIAoxLjYuMC42Cgo=
--0016e6d976262e4f490479af37a5--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re: Re: Getting info from used typedef ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Re: Re: Re: Getting info from used typedef
Date: Wed, 02 Dec 2009 14:05:52 +0000
Message-ID: <OF83C748CA.F60373EF-ONC1257680.004D070F-C1257680.004D7110 () br-automation ! com>
--------------------
christ.li@gmail.com schrieb am 01.12.2009 19:49:18:
> So you only use sparse as a C source code processing tool. You don't
> care about the back end part of the sparse right?

Yes, that's right.

> In that case, you can try this one line patch. It should preserve the 
typedef
> symbol as the base type. I will not commit that to main line though.
> 
> Will that work for you?

Thank you, but I'm sorry, that patch doesn't work for me. 
The output is the same as before, the base_type of the symbol doesn't have 
an ident.

I'm surprised that the base_type had an ident in former versions of sparse 

(which didn't also work correctly - I tried to figure out something in the 
past, see 
http://marc.info/?l=linux-sparse&m=118171213001092&w=2
), but now this has changed.

In former versions of sparse, this code gave output, even tough it was 
incorrect:
("sym" is a "struct symbol*" of the symlist returned by sparse() )

        struct symbol *type;
        type = sym->ctype.base_type;
 
        if (type->ident)
        {
                if (sym->ctype.modifiers & MOD_USERTYPE) 
                        fprintf(pFOut, "Typedef=\"%s\" ", 
type->ident->name);
        } 


I tried to compare the function "declaration_specifiers" from sparse 0.4.1 
and 0.4.2.
The function changed a lot, but I don't understand the changes.

Is it really not necessary for compilers (or frontends) to hold the 
information about declarations with typedefs?

Regards,
Thomas
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Re: Re: Getting info from used typedef
Date: Thu, 21 Jan 2010 00:38:09 +0000
Message-ID: <70318cbf1001201638g4b8708e0v94160b64ed2aa854 () mail ! gmail ! com>
--------------------
On Wed, Dec 2, 2009 at 6:05 AM, Thomas Schmid
<Thomas.Schmid@br-automation.com> wrote:
>
> Thank you, but I'm sorry, that patch doesn't work for me.

I took another look into it. I think if you are just working on the
source code transform,
you should be able to skip the evaluation step which short cut the typedef.

Can you try again with the same patch, but in your program, using
__sparse(filename)
instead of sparse(filename) to get the symbols? Using __sparse will skip the
evaluation step. It should keep the typedef node unchanged.


> Is it really not necessary for compilers (or frontends) to hold the
> information about declarations with typedefs?

The back end only care about the type, not the name of type.
In fact, C type system need to evaluation the type to get ride of the
alias so it will not complain type mismatch due to typedef.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re: Re: Re: Getting info from used typedef ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Re: Re: Re: Getting info from used typedef
Date: Fri, 29 Jan 2010 01:21:18 +0000
Message-ID: <70318cbf1001281721p1b0df85ey63e58062dd7d809 () mail ! gmail ! com>
--------------------
On Tue, Jan 26, 2010 at 7:28 AM, Thomas Schmid
<Thomas.Schmid@br-automation.com> wrote:
>
> Yes, that seems to help, thank you very much.
> I think because of the missing evaluation step, it is now a little bit
> more tricky
> to get out the elements of an struct or enum, but it will work.
> Do I lose anything else, skipping the evaluation step?

You don't have the type evaluation. I don't think your source code
transform program
cares.
>
> Is it possible to commit your change (
> 0001-hacking-preserve-typedef-name.patch) in source?
> - I didn't recognize any change in behaviour when using the function
> sparse().

How about make it an hidden options? It does not make sense for compiler
to care about the typedef name. I will send out a review later.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re: Re: Re: Re: Getting info from used typedef ===

From: Thomas Schmid <Thomas.Schmid () br-automation ! com>
To: linux-sparse
Subject: Re: Re: Re: Re: Re: Getting info from used typedef
Date: Tue, 02 Feb 2010 08:52:12 +0000
Message-ID: <OFA331B5BF.6AEF491A-ONC12576BE.003038A0-C12576BE.0030B9D2 () br-automation ! com>
--------------------
linux-sparse-owner@vger.kernel.org schrieb am 29.01.2010 02:21:18:

> Christopher Li <sparse@chrisli.org> 
> > Is it possible to commit your change (
> > 0001-hacking-preserve-typedef-name.patch) in source?
> > - I didn't recognize any change in behaviour when using the function
> > sparse().
> 
> How about make it an hidden options? It does not make sense for compiler
> to care about the typedef name. I will send out a review later.
Sounds good to me.

Regards 
Thomas

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Re: [PATCH] Fix implicit cast to float (Was:Re: Initializing ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Re: [PATCH] Fix implicit cast to float (Was:Re: Initializing
Date: Mon, 09 Feb 2009 19:15:58 +0000
Message-ID: <70318cbf0902091115l338eb247x2d4f42d154ba0a43 () mail ! gmail ! com>
--------------------
I guess you apply the patch on the official sparse's tree.

The patch is base on my development tree here:

http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=summary

is_type_void() is introduced at change 405cd6edfe2e88c808f0a45f0c2ef92a854dbe67,
warn about explicit usage of sizeof(void).

Chris

On Mon, Feb 9, 2009 at 5:38 AM, Thomas Schmid
<Thomas.Schmid@br-automation.com> wrote:
> christ.li@gmail.com schrieb am 09.02.2009 08:37:50:
>
>> On Fri, Feb 6, 2009 at 4:51 AM, Thomas Schmid
>> <Thomas.Schmid@br-automation.com> wrote:
>> > christ.li@gmail.com schrieb am 06.02.2009 05:15:37:
>> > -       if (newtype->ctype.base_type != &fp_type) {
>> > +       if (is_int_type(newtype)) {
>>
>> I change your patch a little bit. The old logic of testing against float
>> type is better. The type can be a pointer for example. Then using
>> the long long value is more correct.
>>
>> See the patch attached.
>>
>> If there is not objections. I am going to apply this one.
>
> Thank you for correcting, your changes work fine for me.
>
> There's only a little problem with the patch,
> patch breaks off in evaluate.c, cause there's no function "is_void_type"
> within...
>
> Greetings
> Thomas Schmid
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sanitize pointer() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Sanitize pointer()
Date: Wed, 11 Mar 2009 07:08:35 +0000
Message-ID: <E1LhIYN-00042T-DM () ZenIV ! linux ! org ! uk>
--------------------

There's no need to concat the context list into (empty) one of new node,
only to free the original one.  Moving the pointer to list instead works
fine...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c |   20 +++++---------------
 1 files changed, 5 insertions(+), 15 deletions(-)

diff --git a/parse.c b/parse.c
index 28bc0c9..f16d321 100644
--- a/parse.c
+++ b/parse.c
@@ -1592,28 +1592,18 @@ static struct token *direct_declarator(struct token *token, struct decl_state *c
 
 static struct token *pointer(struct token *token, struct decl_state *ctx)
 {
-	unsigned long modifiers;
-	struct symbol *base_type;
-
-	modifiers = ctx->ctype.modifiers;
-	base_type = ctx->ctype.base_type;
-
 	while (match_op(token,'*')) {
 		struct symbol *ptr = alloc_symbol(token->pos, SYM_PTR);
-		ptr->ctype.modifiers = modifiers;
+		ptr->ctype.modifiers = ctx->ctype.modifiers;
+		ptr->ctype.base_type = ctx->ctype.base_type;
 		ptr->ctype.as = ctx->ctype.as;
-		concat_ptr_list((struct ptr_list *)ctx->ctype.contexts,
-				(struct ptr_list **)&ptr->ctype.contexts);
-		ptr->ctype.base_type = base_type;
-
-		base_type = ptr;
+		ptr->ctype.contexts = ctx->ctype.contexts;
 		ctx->ctype.modifiers = 0;
-		ctx->ctype.base_type = base_type;
+		ctx->ctype.base_type = ptr;
 		ctx->ctype.as = 0;
-		free_ptr_list(&ctx->ctype.contexts);
+		ctx->ctype.contexts = NULL;
 
 		token = handle_qualifiers(token->next, ctx);
-		modifiers = ctx->ctype.modifiers;
 		ctx->ctype.base_type->endpos = token->pos;
 	}
 	return token;
-- 
1.5.6.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Simplify get_number_value() and ctype_integer() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Simplify get_number_value() and ctype_integer()
Date: Wed, 11 Mar 2009 07:08:15 +0000
Message-ID: <E1LhIY3-0003yb-Dv () ZenIV ! linux ! org ! uk>
--------------------

There's no point whatsoever in constructing modifiers for chosen
type when decoding integer constant only to have them picked
apart by ctype_integer().  Seeing that the former is the only
caller of the latter these days, we can bloody well just pass
the rank and signedness explicitly and save a lot of efforts.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 expression.c |   40 ++++++++++++++++++++--------------------
 parse.c      |   13 ++-----------
 parse.h      |    2 +-
 3 files changed, 23 insertions(+), 32 deletions(-)

diff --git a/expression.c b/expression.c
index 124a8ec..7c88a28 100644
--- a/expression.c
+++ b/expression.c
@@ -272,7 +272,7 @@ static void get_number_value(struct expression *expr, struct token *token)
 	const char *str = token->number;
 	unsigned long long value;
 	char *end;
-	unsigned long modifiers = 0;
+	int size = 0, want_unsigned = 0;
 	int overflow = 0, do_warn = 0;
 	int try_unsigned = 1;
 	int bits;
@@ -284,55 +284,55 @@ static void get_number_value(struct expression *expr, struct token *token)
 	if (value == ULLONG_MAX && errno == ERANGE)
 		overflow = 1;
 	while (1) {
-		unsigned long added;
 		char c = *end++;
 		if (!c) {
 			break;
 		} else if (c == 'u' || c == 'U') {
-			added = MOD_UNSIGNED;
+			if (want_unsigned)
+				goto Enoint;
+			want_unsigned = 1;
 		} else if (c == 'l' || c == 'L') {
-			added = MOD_LONG;
+			if (size)
+				goto Enoint;
+			size = 1;
 			if (*end == c) {
-				added |= MOD_LONGLONG;
+				size = 2;
 				end++;
 			}
 		} else
 			goto Float;
-		if (modifiers & added)
-			goto Enoint;
-		modifiers |= added;
 	}
 	if (overflow)
 		goto Eoverflow;
 	/* OK, it's a valid integer */
 	/* decimals can be unsigned only if directly specified as such */
-	if (str[0] != '0' && !(modifiers & MOD_UNSIGNED))
+	if (str[0] != '0' && !want_unsigned)
 		try_unsigned = 0;
-	if (!(modifiers & MOD_LONG)) {
+	if (!size) {
 		bits = bits_in_int - 1;
 		if (!(value & (~1ULL << bits))) {
 			if (!(value & (1ULL << bits))) {
 				goto got_it;
 			} else if (try_unsigned) {
-				modifiers |= MOD_UNSIGNED;
+				want_unsigned = 1;
 				goto got_it;
 			}
 		}
-		modifiers |= MOD_LONG;
+		size = 1;
 		do_warn = 1;
 	}
-	if (!(modifiers & MOD_LONGLONG)) {
+	if (size < 2) {
 		bits = bits_in_long - 1;
 		if (!(value & (~1ULL << bits))) {
 			if (!(value & (1ULL << bits))) {
 				goto got_it;
 			} else if (try_unsigned) {
-				modifiers |= MOD_UNSIGNED;
+				want_unsigned = 1;
 				goto got_it;
 			}
 			do_warn |= 2;
 		}
-		modifiers |= MOD_LONGLONG;
+		size = 2;
 		do_warn |= 1;
 	}
 	bits = bits_in_longlong - 1;
@@ -343,14 +343,14 @@ static void get_number_value(struct expression *expr, struct token *token)
 	if (!try_unsigned)
 		warning(expr->pos, "decimal constant %s is too big for long long",
 			show_token(token));
-	modifiers |= MOD_UNSIGNED;
+	want_unsigned = 1;
 got_it:
 	if (do_warn)
 		warning(expr->pos, "constant %s is so big it is%s%s%s",
 			show_token(token),
-			(modifiers & MOD_UNSIGNED) ? " unsigned":"",
-			(modifiers & MOD_LONG) ? " long":"",
-			(modifiers & MOD_LONGLONG) ? " long":"");
+			want_unsigned ? " unsigned":"",
+			size > 0 ? " long":"",
+			size > 1 ? " long":"");
 	if (do_warn & 2)
 		warning(expr->pos,
 			"decimal constant %s is between LONG_MAX and ULONG_MAX."
@@ -359,7 +359,7 @@ got_it:
 			show_token(token));
         expr->type = EXPR_VALUE;
 	expr->flags = Int_const_expr;
-        expr->ctype = ctype_integer(modifiers);
+        expr->ctype = ctype_integer(size, want_unsigned);
         expr->value = value;
 	return;
 Eoverflow:
diff --git a/parse.c b/parse.c
index fa0c511..e99ca3d 100644
--- a/parse.c
+++ b/parse.c
@@ -1262,18 +1262,9 @@ static struct symbol * const * const types[] = {
 	real_types + 1, char_types, char_types + 1, char_types + 2
 };
 
-struct symbol *ctype_integer(unsigned long spec)
+struct symbol *ctype_integer(int size, int want_unsigned)
 {
-	int size;
-
-	if (spec & MOD_LONGLONG)
-		size = 2;
-	else if (spec & MOD_LONG)
-		size = 1;
-	else
-		size = 0;
-
-	return types[spec & MOD_UNSIGNED ? CUInt : CInt][size];
+	return types[want_unsigned ? CUInt : CInt][size];
 }
 
 static struct token *handle_qualifiers(struct token *t, struct decl_state *ctx)
diff --git a/parse.h b/parse.h
index 26dc624..02b8585 100644
--- a/parse.h
+++ b/parse.h
@@ -127,7 +127,7 @@ extern int show_expression(struct expression *);
 
 extern struct token *external_declaration(struct token *token, struct symbol_list **list);
 
-extern struct symbol *ctype_integer(unsigned long spec);
+extern struct symbol *ctype_integer(int size, int want_unsigned);
 
 extern void copy_statement(struct statement *src, struct statement *dst);
 extern int inline_function(struct expression *expr, struct symbol *sym);
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse 0.4.2 released ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Sparse 0.4.2 released
Date: Fri, 16 Oct 2009 15:45:31 +0000
Message-ID: <70318cbf0910160845g51baf4dbtff57b81cfb1c7538 () mail ! gmail ! com>
--------------------
Hi,

I have tagged and released the sparse version 0.4.2 at
http://www.kernel.org/pub/software/devel/sparse/dist/sparse-0.4.2.tar.gz

As previous discussions on the sparse mailing list, I am the new maintainer of
the sparse project. This is my first release for sparse.
Thanks Josh Triplett for the previously maintaining the project.

I also created a new sparse wiki, it will replace the current sparse
home page. http://sparse.wiki.kernel.org/index.php/Main_Page

A lot of bug fixes and enhancements have gone into this release.
Special thanks to Al Viro for overhauling the parser. Now sparse
has  better ctype and attribute handling. The detailed changes follow.

Chris


 .gitignore                                       |    6 +
 Documentation/data-structures.txt                |   54 +
 Makefile                                         |  162 +--
 cgcc                                             |   47 +-
 compat-bsd.c                                     |   20 +
 compile-i386.c                                   |   10 +-
 compile.h                                        |    2 +
 evaluate.c                                       |  141 ++-
 example.c                                        |    2 +-
 expand.c                                         |   11 +-
 expression.c                                     |   66 +-
 expression.h                                     |    4 +-
 flow.c                                           |   10 +-
 flow.h                                           |    6 +
 gdbhelpers                                       |  307 +++++
 ident-list.h                                     |    5 +
 lib.c                                            |  242 ++++-
 lib.h                                            |    5 +-
 linearize.c                                      |   16 +-
 linearize.h                                      |    3 +-
 liveness.c                                       |    2 +-
 parse.c                                          | 1367 +++++++++++++++-------
 parse.h                                          |    3 +-
 pre-process.c                                    |  126 ++-
 ptrlist.h                                        |    2 +
 scope.c                                          |    2 +-
 scope.h                                          |    2 +
 show-parse.c                                     |  110 +-
 simplify.c                                       |   57 +-
 sparse.1                                         |   22 +
 storage.h                                        |    3 +
 symbol.c                                         |   84 +-
 symbol.h                                         |   86 ++-
 target.c                                         |    1 +
 target.h                                         |   15 +
 token.h                                          |    3 +-
 tokenize.c                                       |   41 +-
 unssa.c                                          |    2 +
 validation/address_space.c                       |    6 +-
 validation/attr-warning.c                        |    8 +
 validation/attr_in_parameter.c                   |   12 +
 validation/bad-array-designated-initializer.c    |    6 +-
 validation/bad-assignment.c                      |    4 +-
 validation/bad-cast.c                            |    6 +-
 validation/bad-ternary-cond.c                    |    4 +-
 validation/bad-typeof.c                          |   14 +
 validation/badtype4.c                            |    4 +-
 validation/check_byte_count-ice.c                |    4 +-
 validation/compare-null-to-int.c                 |    2 +-
 validation/cond_expr.c                           |    4 +-
 validation/cond_expr2.c                          |   12 +-
 validation/context.c                             |    6 +-
 validation/declaration-after-statement-ansi.c    |   12 +
 validation/declaration-after-statement-c89.c     |   12 +
 validation/declaration-after-statement-c99.c     |    9 +
 validation/declaration-after-statement-default.c |    9 +
 validation/definitions.c                         |   12 +
 validation/dubious-bitwise-with-not.c            |   24 +
 validation/enum_scope.c                          |   11 +
 validation/extern-inline.c                       |   23 +
 validation/identifier_list.c                     |   18 +
 validation/initializer-entry-defined-twice.c     |    8 +-
 validation/label-scope.c                         |   12 +
 validation/missing-ident.c                       |   18 +
 validation/multi_typedef.c                       |   15 +
 validation/nested-declarator.c                   |   29 +
 validation/nested-declarator2.c                  |   41 +
 validation/noderef.c                             |    6 +-
 validation/preprocessor/preprocessor11.c         |   21 +
 validation/preprocessor/preprocessor12.c         |   11 +
 validation/preprocessor/preprocessor13.c         |   16 +
 validation/preprocessor/preprocessor14.c         |   10 +
 validation/preprocessor/preprocessor15.c         |    9 +
 validation/preprocessor/preprocessor16.c         |    9 +
 validation/preprocessor/preprocessor22.c         |   35 +
 validation/preprocessor/preprocessor7.c          |    9 +
 validation/preprocessor/preprocessor8.c          |   22 +
 validation/reserved.c                            |   40 +
 validation/restrict-array.c                      |   12 +
 validation/sizeof-compound-postfix.c             |    8 +
 validation/specifiers1.c                         |  101 ++
 validation/specifiers2.c                         |  152 +++
 validation/test-suite                            |    6 +-
 validation/typedef_shadow.c                      |   12 +
 validation/typeof-attribute.c                    |   16 +
 validation/typesign.c                            |   36 +-
 86 files changed, 3011 insertions(+), 912 deletions(-)


Al Viro (39):
      saner warnings for restricted types
      fix show_typename()
      catch !x & y brainos
      fun with declarations and definitions
      Fix type_info_expression()
      fun with declarations and definitions
      Fix handling of ident-less declarations
      Separate parsing of identifier-list (in K&R-style declarations)
      More nested declarator fixes
      Fix attribute/asm handling
      more direct_declarator() sanitizing
      Warn about non-empty identifier list outside of definition
      Apply attributes after ( to the right place
      Leave applying attributes until we know whether it's a nested declarator
      Don't mess with passing symbol to declarator/direct_declarator
      Fix braino in which_kind()
      Sanitize direct_declarator logics
      Separating ctype and parser state, part 1
      Propagate decl_state to declaration_specifiers()
      Fix regression created by commit af30c6df74f01db10fa78ac0cbdb5c3c40b5c73f
      Take the rest of storage class keywords to parse.c
      Fix handling of typedefs with several declarators
      preparations to ->declarator() cleanup - separate typedef handling
      Take the rest of specifiers to parse.c
      Saner type for __builtin_va_list
      Rewrite and fix specifiers handling
      Have ->declarator() act directly on ctype being affected
      Clean up and split declaration_specifiers()
      Pass decl_state down to ->declarator() and handle_attributes()
      Pass decl_state down to ->attribute()
      Restore __attribute__((mode)) handling
      Fix enumeration constants' scope beginning
      Fix declaration_specifiers() handling of typedef name shadowed
by NS_SYMBOL
      Fix __label__ handling
      Simplify get_number_value() and ctype_integer()
      Don't mix storage class bits with ctype->modifiers while parsing type
      Sanitize pointer()
      Segfault at evaluate.c:341
      warn directive in argument list

Alberto Bertogli (1):
      Support the __thread storage class

Alexander Shishkin (1):
      don't call sparse when called to generate dependencies

Alexey Zaytsev (16):
      Remove symbol.id_list
      Replace the -specs cgcc option with -target
      Make show_symbol newline-consistent
      Handle a terminal -o option properly.
      Looks more evident this way.
      Mark handle_switch as static and don't export it from lib.h
      Handle missing argument to -D.
      Gdb macros to get a better look at some sparse data structures.
      A slightly edited irc discussion with Josh Triplett.
      Warning should be enough for an unhandled transparent union
      Set gcc include path at runtime.
      Let cgcc pass -gcc-base-dir to sparse.
      Document -gcc-base-dir in sparse.1
      Rename dirafter to idirafter.
      Let void have sizeof 1
      Also warn about sizeof(function)

Blue Swirl (6):
      Sparc64 (Sparc V9, LP64) support
      OpenBSD support
      Ignore attribute __bounded__, used by OpenBSD headers.
      Add c{l,t}z{,l,ll}, ffsl{,l}, popcountll and floating point
comparison builtins.
      Add support for TImode type (__int128_t)
      Define __LP64__ for x86_64 unless in 32 bit mode

Christopher Li (11):
      Evaluate iterator symbols
      Remove pre_buffer
      Add enum member list to the parent
      Teach classify_type to handle typeof
      Warn about explicit usage of sizeof(void)
      Makefile automatic header dependency
      Clean up Makefile long lines
      Update the validation check for ftabstop=
      Add validation for restrict and attribute warning
      move extern inline function to file scope
      Sparse 0.4.2

David Given (2):
      Unhardcode byte size being 8 bits.
      Add type information to struct instruction.

Geoff Johnstone (4):
      Add support for GCC's -std=... and -ansi command line options.
      Add builtin functions for use with __FORTIFY_SOURCE
      Fix type mismatches with incomplete types
      Add -Wno-declaration-after-statement

Hannes Eder (4):
      Add -ftabstop=WIDTH
      refactor handle_switch_f
      test-suite: be more verbose on 'unhandled' and 'known to fail' tests
      test-suite: integrate unhandled proprocessor tests

Johannes Berg (8):
      cgcc: handle ppc arch
      make sparse keep its promise about context tracking
      sparse test suite: add test mixing __context__ and
__attribute__((context(...)))
      sparse: simple conditional context tracking
      inlined call bugfix & test
      improve -Wcontext code and messages
      fix bug in context tracking code
      Revert the context tracking code

Josh Triplett (2):
      Add test case for new warning about !x & y
      Expand "dubious !x & y" handling to other combinations of !, &, and |.

Kamil Dudka (4):
      compile-i386: do not generate an infinite loop
      linearize.h: sanitize header
      unssa: track uses when replacing a phi node
      make sparse headers self-compilable...

Linus Torvalds (5):
      Fix cast instruction generation
      Simplify (and warn about) right shifts that result in zero
      Allow array declarators to have 'restrict' in them
      Turn off '-Wtransparent-union' by default
      Avoid "attribute 'warning': unknown attribute" warning

Martin Nagy (3):
      .gitignore: Ignore dependencies and Vim swap files
      Add missing checks for Waddress-space
      Print an error if typeof() lacks an argument

Pavel Roskin (1):
      Ignore "cold" and "hot" attributes, which appeared in gcc 4.3

Pekka Enberg (1):
      sparse: Add GCC pre-defined macros for user-space

Ramsay Jones (1):
      Makefile: suppress error message from pkg-config

Reinhard Tartler (1):
      show_token: handle TOKEN_UNTAINT and TOKEN_ARG_COUNT types

Samuel Bronson (1):
      Have Makefile import local.mk if it exists.

Thomas Schmid (1):
      Fix implicit cast to float

Vegard Nossum (2):
      Fix use of invalid file descriptor
      Set *tree to NULL on error
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse 0.4.2-rc1 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Sparse 0.4.2-rc1
Date: Mon, 28 Sep 2009 07:33:36 +0000
Message-ID: <70318cbf0909280033p32c64e2fpbb563ac2b498fa8d () mail ! gmail ! com>
--------------------
I just tagged the sparse git tree with v0.4.2-rc1.

It has been a long while since the last 0.4.1 release.
Al made a big overhaul of the parser to support better
type and attribute parsing. The rest of the changes are
mostly small improvements.

Please give it some test and report back any regression
you find.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse official tree merged ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Sparse official tree merged
Date: Sat, 18 Jul 2009 22:08:28 +0000
Message-ID: <70318cbf0907181508x3a11d789v79f556ac18fd89ff () mail ! gmail ! com>
--------------------
Hi,

I just clean up the history in chrisl/sparse.git a little bit and
push them to the official tree.

Moving forward, I am going to continue using chrisl/sparse.git
as a developing tree. Patches will first apply there and then
move to official tree later on.

Warning for developing branch, I am going to clean up history there
occasionally.You might not get a clean fast forward pull. If that becomes
a problem, I will consider using topic branch later. For now, there
is just not enough changes to make the topic branch worthwhile.

Please give the official tree some test and report any problem you
found.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: User question for =?utf-8?b?X19jb250ZXh0X18=?= or similiar ===

From: Holger Freyther <zecke () selfish ! org>
To: linux-sparse
Subject: User question for =?utf-8?b?X19jb250ZXh0X18=?= or similiar
Date: Wed, 28 Oct 2009 10:56:36 +0000
Message-ID: <loom.20091028T113843-308 () post ! gmane ! org>
--------------------
Hi,

I would like to use sparse on the OpenBSC[1] userspace application
and I'm searching for a hint on how to realize it or how to adopt the
sparse code to do the following.

In the code we have a struct called "struct gsm_subscriber" and it
is reference counted. We have various methods that query the 
database (VLR) to find a subscriber and then we have subscr_put
and subscr_get to operate on the reference count.

One rule we have established in the code is that the "reference" is
never borrowed. This means code that is doing a subscr_get or a query
will need to do subscr_put on all exits paths. The only exception is
e.g. if work needs to be scheduled and the pointer is put into a talloc
allocated structure.

My first thought was that this almost works like locking in the kernel
but I was wrong. I have used the CHECKER macros from linux/compiler.h

and changed code to

struct gsm_subscriber *subscr_get(struct gsm_subscriber *subscr)
                                          __acquires(subscr);
struct gsm_subscriber *subscr_put(struct gsm_subscriber *subscr)
                                         __releases(subscr);
struct gsm_subscriber *subscr_find_by_tmsi(int tmsi)
                                         __acquires(subscr);

and the code like

do_something()
{
    subscr = subscr_find_by_tmsi(tmsi);
    if (!subscr)
           return;

   if (some_condition) {
...
          subscr_put(subscr);
   }

...
   return;
}

My assumption would be that sparse is looking at the flows and figures
out that one path exits without subscr_put being called. Is my assumption
wrong, would it be worth adding a check that goes through the flow and
counts ref's/unref's? Am I doing it completely wrong?

help and pointers to the code are very much appreciated.

      z.

PS: I will update the wiki with some explanation when I get it to work.


[1] http://openbsc.gnumonks.org

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Warning from ring buffer code (Was: Re: linux-next: tip tree ===

From: Ingo Molnar <mingo () elte ! hu>
To: linux-kernel
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 13:53:25 +0000
Message-ID: <20090914135325.GA24454 () elte ! hu>
--------------------

* Steven Rostedt <srostedt@redhat.com> wrote:

> On Sat, 2009-09-12 at 09:39 +0200, Ingo Molnar wrote:
> > * Stephen Rothwell <sfr@canb.auug.org.au> wrote:
> 
> > > Now that this is in Linus' tree, can we have a fix for the waning, 
> > > please?
> > 
> > The first warning got fixed 1.5 months ago - the second one at line 
> > 797 is still there but harmless - you can ignore it for now, it will 
> > be fixed.
> 
> The first warning never got fixed. The typecast was placed in the 
> wrong spot (my fault). I sent another patch that fixes both warnings.

Pulled it, thanks Steve.

	Ingo
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Steven Rostedt <srostedt () redhat ! com>
To: linux-sparse
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 15:16:56 +0000
Message-ID: <1252941416.2964.143.camel () localhost ! localdomain>
--------------------
On Sat, 2009-09-12 at 16:42 +0530, Jaswinder Singh Rajput wrote:

> 
> Here are some more trace related warnings in current linus (as well as
> -tip) tree :
> 
>   CHECK   arch/x86/kernel/ptrace.c
> include/trace/events/syscalls.h:18:1: warning: symbol 'ftrace_raw_output_sys_enter' was not declared. Should it be static?
> include/trace/events/syscalls.h:42:1: warning: symbol 'ftrace_raw_output_sys_exit' was not declared. Should it be static?
> include/trace/events/syscalls.h:18:1: warning: symbol 'ftrace_define_fields_sys_enter' was not declared. Should it be static?
> include/trace/events/syscalls.h:42:1: warning: symbol 'ftrace_define_fields_sys_exit' was not declared. Should it be static?

I just wrote a patch to fix the above.

> include/trace/events/syscalls.h:18:1: error: bad constant expression
> include/trace/events/syscalls.h:42:1: error: bad constant expression

Not sure why sparse is failing on this. Looking at the sched.c code, I
ran "make kernel/sched.i" and then removed the CPP expressions and then
expanded the macros and here's where it is failing:

static void ftrace_profile_sched_kthread_stop(struct task_struct *t)
{
	struct ftrace_data_offsets_sched_kthread_stop __attribute__((unused)) __data_offsets;
	struct ftrace_event_call *event_call = &event_sched_kthread_stop;
	extern void perf_tpcounter_event(int, u64, u64, void *, int);
	struct ftrace_raw_sched_kthread_stop *entry;
	u64 __addr = 0, __count = 1;
	unsigned long irq_flags;
	
	int __entry_size;
	int __data_size;
	int pc;

	do { ({ unsigned long __dummy;
				typeof(irq_flags) __dummy2;
				(void)(&__dummy == &__dummy2);
				1;
			});
		do { (irq_flags) = __raw_local_save_flags();
		} while (0);
	} while (0);
	pc = (current_thread_info()->preempt_count);
	__data_size = ftrace_get_offsets_sched_kthread_stop(&__data_offsets, t);
	__entry_size = (((__data_size + sizeof(*entry) + sizeof(u32))+((typeof(__data_size + sizeof(*entry) + sizeof(u32)))(sizeof(u64))-1))&~((typeof(__data_size + sizeof(*entry) + sizeof(u32)))(sizeof(u64))-1));
	__entry_size -= sizeof(u32);
	do {
		char raw_data[__entry_size];   <<<<----------- FAILURE HERE
		struct trace_entry *ent;
		*(u64 *)(&raw_data[__entry_size - sizeof(u64)]) = 0ULL;
		entry = (struct ftrace_raw_sched_kthread_stop *)raw_data;
		ent = &entry->ent;
		tracing_generic_entry_update(ent, irq_flags, pc);
		ent->type = event_call->id;
		{ memcpy(entry->comm, t->comm, 16);
			entry->pid = t->pid;
			;
		} perf_tpcounter_event(event_call->id, __addr, __count, entry, __entry_size);
	} while (0);
};

Sure enough, sparse does not like the __entry_size. I replaced it with
"10" and sparse was happy with it. That is a perfectly legal entry, so
this looks more like a bug with sparse.

I just tested this too:

static void func(int size_me) {
	char array[size_me];

	memcpy(array, "hello", size);
};

and sparse failed on it as well. Note, you need to have something call
func, or sparse will ignore it.


-- Steve


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <srostedt () redhat ! com>
To: linux-next
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 15:16:56 +0000
Message-ID: <1252941416.2964.143.camel () localhost ! localdomain>
--------------------
On Sat, 2009-09-12 at 16:42 +0530, Jaswinder Singh Rajput wrote:

> 
> Here are some more trace related warnings in current linus (as well as
> -tip) tree :
> 
>   CHECK   arch/x86/kernel/ptrace.c
> include/trace/events/syscalls.h:18:1: warning: symbol 'ftrace_raw_output_sys_enter' was not declared. Should it be static?
> include/trace/events/syscalls.h:42:1: warning: symbol 'ftrace_raw_output_sys_exit' was not declared. Should it be static?
> include/trace/events/syscalls.h:18:1: warning: symbol 'ftrace_define_fields_sys_enter' was not declared. Should it be static?
> include/trace/events/syscalls.h:42:1: warning: symbol 'ftrace_define_fields_sys_exit' was not declared. Should it be static?

I just wrote a patch to fix the above.

> include/trace/events/syscalls.h:18:1: error: bad constant expression
> include/trace/events/syscalls.h:42:1: error: bad constant expression

Not sure why sparse is failing on this. Looking at the sched.c code, I
ran "make kernel/sched.i" and then removed the CPP expressions and then
expanded the macros and here's where it is failing:

static void ftrace_profile_sched_kthread_stop(struct task_struct *t)
{
	struct ftrace_data_offsets_sched_kthread_stop __attribute__((unused)) __data_offsets;
	struct ftrace_event_call *event_call = &event_sched_kthread_stop;
	extern void perf_tpcounter_event(int, u64, u64, void *, int);
	struct ftrace_raw_sched_kthread_stop *entry;
	u64 __addr = 0, __count = 1;
	unsigned long irq_flags;
	
	int __entry_size;
	int __data_size;
	int pc;

	do { ({ unsigned long __dummy;
				typeof(irq_flags) __dummy2;
				(void)(&__dummy == &__dummy2);
				1;
			});
		do { (irq_flags) = __raw_local_save_flags();
		} while (0);
	} while (0);
	pc = (current_thread_info()->preempt_count);
	__data_size = ftrace_get_offsets_sched_kthread_stop(&__data_offsets, t);
	__entry_size = (((__data_size + sizeof(*entry) + sizeof(u32))+((typeof(__data_size + sizeof(*entry) + sizeof(u32)))(sizeof(u64))-1))&~((typeof(__data_size + sizeof(*entry) + sizeof(u32)))(sizeof(u64))-1));
	__entry_size -= sizeof(u32);
	do {
		char raw_data[__entry_size];   <<<<----------- FAILURE HERE
		struct trace_entry *ent;
		*(u64 *)(&raw_data[__entry_size - sizeof(u64)]) = 0ULL;
		entry = (struct ftrace_raw_sched_kthread_stop *)raw_data;
		ent = &entry->ent;
		tracing_generic_entry_update(ent, irq_flags, pc);
		ent->type = event_call->id;
		{ memcpy(entry->comm, t->comm, 16);
			entry->pid = t->pid;
			;
		} perf_tpcounter_event(event_call->id, __addr, __count, entry, __entry_size);
	} while (0);
};

Sure enough, sparse does not like the __entry_size. I replaced it with
"10" and sparse was happy with it. That is a perfectly legal entry, so
this looks more like a bug with sparse.

I just tested this too:

static void func(int size_me) {
	char array[size_me];

	memcpy(array, "hello", size);
};

and sparse failed on it as well. Note, you need to have something call
func, or sparse will ignore it.


-- Steve


--
To unsubscribe from this list: send the line "unsubscribe linux-next" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 17:09:27 +0000
Message-ID: <70318cbf0909141009v46581785m4c70edf31fcb79fa () mail ! gmail ! com>
--------------------
On Mon, Sep 14, 2009 at 8:16 AM, Steven Rostedt <srostedt@redhat.com> wrote:
> static void func(int size_me) {
>        char array[size_me];
>
>        memcpy(array, "hello", size);
> };
>
> and sparse failed on it as well. Note, you need to have something call
> func, or sparse will ignore it.

Gcc allows variable size. Sparse expects the size of an array is constant.
For the kernel using variable array size is consider bad. Because the kernel
has very limited stack size. (8K if I remember correctly). Using dynamic array
is very easy to overflow the stack without realizing it.

It deserves a warning. I agree the warning message can use a better description
though.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 17:09:27 +0000
Message-ID: <70318cbf0909141009v46581785m4c70edf31fcb79fa () mail ! gmail ! com>
--------------------
On Mon, Sep 14, 2009 at 8:16 AM, Steven Rostedt <srostedt@redhat.com> wrote:
> static void func(int size_me) {
>        char array[size_me];
>
>        memcpy(array, "hello", size);
> };
>
> and sparse failed on it as well. Note, you need to have something call
> func, or sparse will ignore it.

Gcc allows variable size. Sparse expects the size of an array is constant.
For the kernel using variable array size is consider bad. Because the kernel
has very limited stack size. (8K if I remember correctly). Using dynamic array
is very easy to overflow the stack without realizing it.

It deserves a warning. I agree the warning message can use a better description
though.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <srostedt () redhat ! com>
To: linux-kernel
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:17:18 +0000
Message-ID: <1252952238.2964.154.camel () localhost ! localdomain>
--------------------
On Mon, 2009-09-14 at 10:09 -0700, Christopher Li wrote:
> On Mon, Sep 14, 2009 at 8:16 AM, Steven Rostedt <srostedt@redhat.com> wrote:
> > static void func(int size_me) {
> >        char array[size_me];
> >
> >        memcpy(array, "hello", size);
> > };
> >
> > and sparse failed on it as well. Note, you need to have something call
> > func, or sparse will ignore it.
> 
> Gcc allows variable size. Sparse expects the size of an array is constant.
> For the kernel using variable array size is consider bad. Because the kernel
> has very limited stack size. (8K if I remember correctly). Using dynamic array
> is very easy to overflow the stack without realizing it.
> 
> It deserves a warning. I agree the warning message can use a better description
> though.

Good point!

I've added Frederic to the Cc list, since he wrote the code.

Frederic, how big can one of those events get. The ring buffer (and
TRACE_EVENT) allow up to almost a page size, which is very hefty for the
stack. This code needs to either be rewritten or we need to set a limit
to the size of a profile entry.

We could add:

	if (__entry_size > 256)
		return;

Thoughts?

-- Steve



--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Steven Rostedt <srostedt () redhat ! com>
To: linux-sparse
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:17:18 +0000
Message-ID: <1252952238.2964.154.camel () localhost ! localdomain>
--------------------
On Mon, 2009-09-14 at 10:09 -0700, Christopher Li wrote:
> On Mon, Sep 14, 2009 at 8:16 AM, Steven Rostedt <srostedt@redhat.com> wrote:
> > static void func(int size_me) {
> >        char array[size_me];
> >
> >        memcpy(array, "hello", size);
> > };
> >
> > and sparse failed on it as well. Note, you need to have something call
> > func, or sparse will ignore it.
> 
> Gcc allows variable size. Sparse expects the size of an array is constant.
> For the kernel using variable array size is consider bad. Because the kernel
> has very limited stack size. (8K if I remember correctly). Using dynamic array
> is very easy to overflow the stack without realizing it.
> 
> It deserves a warning. I agree the warning message can use a better description
> though.

Good point!

I've added Frederic to the Cc list, since he wrote the code.

Frederic, how big can one of those events get. The ring buffer (and
TRACE_EVENT) allow up to almost a page size, which is very hefty for the
stack. This code needs to either be rewritten or we need to set a limit
to the size of a profile entry.

We could add:

	if (__entry_size > 256)
		return;

Thoughts?

-- Steve



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-next
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:23:41 +0000
Message-ID: <1252952621.31964.0.camel () twins>
--------------------
On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
> Frederic, how big can one of those events get. The ring buffer (and
> TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> stack. This code needs to either be rewritten or we need to set a limit
> to the size of a profile entry.

Yeah, that needs to get a re-write.. I've complained about this when it
went in.
--
To unsubscribe from this list: send the line "unsubscribe linux-next" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-sparse
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:23:41 +0000
Message-ID: <1252952621.31964.0.camel () twins>
--------------------
On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
> Frederic, how big can one of those events get. The ring buffer (and
> TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> stack. This code needs to either be rewritten or we need to set a limit
> to the size of a profile entry.

Yeah, that needs to get a re-write.. I've complained about this when it
went in.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven Rostedt <srostedt () redhat ! com>
To: linux-next
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:31:16 +0000
Message-ID: <1252953076.2964.156.camel () localhost ! localdomain>
--------------------
On Mon, 2009-09-14 at 20:23 +0200, Peter Zijlstra wrote:
> On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
> > Frederic, how big can one of those events get. The ring buffer (and
> > TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> > stack. This code needs to either be rewritten or we need to set a limit
> > to the size of a profile entry.
> 
> Yeah, that needs to get a re-write.. I've complained about this when it
> went in.

One answer is to create a per cpu buffer that is big enough to hold the
data needed. Then you can disable interrupts an use it without worry.

If you need to also handle NMIs, then create a per_cpu NMI buffer too,
and use that if "in_nmi()" is true.

-- Steve


--
To unsubscribe from this list: send the line "unsubscribe linux-next" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Frederic Weisbecker <fweisbec () gmail ! com>
To: linux-kernel
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:38:10 +0000
Message-ID: <20090914183808.GB6045 () nowhere>
--------------------
On Mon, Sep 14, 2009 at 02:17:18PM -0400, Steven Rostedt wrote:
> On Mon, 2009-09-14 at 10:09 -0700, Christopher Li wrote:
> > On Mon, Sep 14, 2009 at 8:16 AM, Steven Rostedt <srostedt@redhat.com> wrote:
> > > static void func(int size_me) {
> > >        char array[size_me];
> > >
> > >        memcpy(array, "hello", size);
> > > };
> > >
> > > and sparse failed on it as well. Note, you need to have something call
> > > func, or sparse will ignore it.
> > 
> > Gcc allows variable size. Sparse expects the size of an array is constant.
> > For the kernel using variable array size is consider bad. Because the kernel
> > has very limited stack size. (8K if I remember correctly). Using dynamic array
> > is very easy to overflow the stack without realizing it.
> > 
> > It deserves a warning. I agree the warning message can use a better description
> > though.
> 
> Good point!
> 
> I've added Frederic to the Cc list, since he wrote the code.
> 
> Frederic, how big can one of those events get. The ring buffer (and
> TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> stack. This code needs to either be rewritten or we need to set a limit
> to the size of a profile entry.
> 
> We could add:
> 
> 	if (__entry_size > 256)
> 		return;
> 
> Thoughts?
> 


Well it can be big, especially once we play with array fields or
__string().

I can manage the __string() that said, by only copying their
pointer and later delay the copy.

Well actually I would like to rewrite all that entirely to avoid
any stack allocation, especially for arrays and string.

Lemme think about a CPP magic way to directly interact with perf
buffer. I think it's possible.

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Frederic Weisbecker <fweisbec () gmail ! com>
To: linux-next
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:38:10 +0000
Message-ID: <20090914183808.GB6045 () nowhere>
--------------------
On Mon, Sep 14, 2009 at 02:17:18PM -0400, Steven Rostedt wrote:
> On Mon, 2009-09-14 at 10:09 -0700, Christopher Li wrote:
> > On Mon, Sep 14, 2009 at 8:16 AM, Steven Rostedt <srostedt@redhat.com> wrote:
> > > static void func(int size_me) {
> > >        char array[size_me];
> > >
> > >        memcpy(array, "hello", size);
> > > };
> > >
> > > and sparse failed on it as well. Note, you need to have something call
> > > func, or sparse will ignore it.
> > 
> > Gcc allows variable size. Sparse expects the size of an array is constant.
> > For the kernel using variable array size is consider bad. Because the kernel
> > has very limited stack size. (8K if I remember correctly). Using dynamic array
> > is very easy to overflow the stack without realizing it.
> > 
> > It deserves a warning. I agree the warning message can use a better description
> > though.
> 
> Good point!
> 
> I've added Frederic to the Cc list, since he wrote the code.
> 
> Frederic, how big can one of those events get. The ring buffer (and
> TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> stack. This code needs to either be rewritten or we need to set a limit
> to the size of a profile entry.
> 
> We could add:
> 
> 	if (__entry_size > 256)
> 		return;
> 
> Thoughts?
> 


Well it can be big, especially once we play with array fields or
__string().

I can manage the __string() that said, by only copying their
pointer and later delay the copy.

Well actually I would like to rewrite all that entirely to avoid
any stack allocation, especially for arrays and string.

Lemme think about a CPP magic way to directly interact with perf
buffer. I think it's possible.

--
To unsubscribe from this list: send the line "unsubscribe linux-next" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Frederic Weisbecker <fweisbec () gmail ! com>
To: linux-sparse
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:38:10 +0000
Message-ID: <20090914183808.GB6045 () nowhere>
--------------------
On Mon, Sep 14, 2009 at 02:17:18PM -0400, Steven Rostedt wrote:
> On Mon, 2009-09-14 at 10:09 -0700, Christopher Li wrote:
> > On Mon, Sep 14, 2009 at 8:16 AM, Steven Rostedt <srostedt@redhat.com> wrote:
> > > static void func(int size_me) {
> > >        char array[size_me];
> > >
> > >        memcpy(array, "hello", size);
> > > };
> > >
> > > and sparse failed on it as well. Note, you need to have something call
> > > func, or sparse will ignore it.
> > 
> > Gcc allows variable size. Sparse expects the size of an array is constant.
> > For the kernel using variable array size is consider bad. Because the kernel
> > has very limited stack size. (8K if I remember correctly). Using dynamic array
> > is very easy to overflow the stack without realizing it.
> > 
> > It deserves a warning. I agree the warning message can use a better description
> > though.
> 
> Good point!
> 
> I've added Frederic to the Cc list, since he wrote the code.
> 
> Frederic, how big can one of those events get. The ring buffer (and
> TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> stack. This code needs to either be rewritten or we need to set a limit
> to the size of a profile entry.
> 
> We could add:
> 
> 	if (__entry_size > 256)
> 		return;
> 
> Thoughts?
> 


Well it can be big, especially once we play with array fields or
__string().

I can manage the __string() that said, by only copying their
pointer and later delay the copy.

Well actually I would like to rewrite all that entirely to avoid
any stack allocation, especially for arrays and string.

Lemme think about a CPP magic way to directly interact with perf
buffer. I think it's possible.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Frederic Weisbecker <fweisbec () gmail ! com>
To: linux-kernel
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 18:41:24 +0000
Message-ID: <20090914184123.GC6045 () nowhere>
--------------------
On Mon, Sep 14, 2009 at 02:31:16PM -0400, Steven Rostedt wrote:
> On Mon, 2009-09-14 at 20:23 +0200, Peter Zijlstra wrote:
> > On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
> > > Frederic, how big can one of those events get. The ring buffer (and
> > > TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> > > stack. This code needs to either be rewritten or we need to set a limit
> > > to the size of a profile entry.
> > 
> > Yeah, that needs to get a re-write.. I've complained about this when it
> > went in.
> 
> One answer is to create a per cpu buffer that is big enough to hold the
> data needed. Then you can disable interrupts an use it without worry.
> 
> If you need to also handle NMIs, then create a per_cpu NMI buffer too,
> and use that if "in_nmi()" is true.
> 
> -- Steve


Looks like a nice idea.

Peter, does that sound acceptable to you to disable interrupts during a
profiled tracepoint event?

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Stephen Rothwell <sfr () canb ! auug ! org ! au>
To: linux-next
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 22:36:01 +0000
Message-ID: <20090915083601.41bf16e1.sfr () canb ! auug ! org ! au>
--------------------
--Signature=_Tue__15_Sep_2009_08_36_01_+1000_icbpFa729/f1lXND
Content-Type: text/plain; charset=US-ASCII
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

Hi Steve,

On Mon, 14 Sep 2009 09:50:01 -0400 Steven Rostedt <srostedt@redhat.com> wro=
te:
>
> On Sat, 2009-09-12 at 09:39 +0200, Ingo Molnar wrote:
> > * Stephen Rothwell <sfr@canb.auug.org.au> wrote:
>=20
> > > Now that this is in Linus' tree, can we have a fix for the waning,=20
> > > please?
> >=20
> > The first warning got fixed 1.5 months ago - the second one at line=20
> > 797 is still there but harmless - you can ignore it for now, it will=20
> > be fixed.
>=20
> The first warning never got fixed. The typecast was placed in the wrong
> spot (my fault). I sent another patch that fixes both warnings.

Thanks for that.

--=20
Cheers,
Stephen Rothwell                    sfr@canb.auug.org.au
http://www.canb.auug.org.au/~sfr/

--Signature=_Tue__15_Sep_2009_08_36_01_+1000_icbpFa729/f1lXND
Content-Type: application/pgp-signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.10 (GNU/Linux)

iEYEARECAAYFAkquxVEACgkQjjKRsyhoI8wHFwCaAqaPkFm9aq3oOUc1i0OH52Vy
29kAn2isI+Mtp/4iVipP4u0JYDu8rThJ
=gFS3
-----END PGP SIGNATURE-----

--Signature=_Tue__15_Sep_2009_08_36_01_+1000_icbpFa729/f1lXND--
--
To unsubscribe from this list: send the line "unsubscribe linux-next" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Stephen Rothwell <sfr () canb ! auug ! org ! au>
To: linux-kernel
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Mon, 14 Sep 2009 22:36:01 +0000
Message-ID: <20090915083601.41bf16e1.sfr () canb ! auug ! org ! au>
--------------------
--Signature=_Tue__15_Sep_2009_08_36_01_+1000_icbpFa729/f1lXND
Content-Type: text/plain; charset=US-ASCII
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

Hi Steve,

On Mon, 14 Sep 2009 09:50:01 -0400 Steven Rostedt <srostedt@redhat.com> wro=
te:
>
> On Sat, 2009-09-12 at 09:39 +0200, Ingo Molnar wrote:
> > * Stephen Rothwell <sfr@canb.auug.org.au> wrote:
>=20
> > > Now that this is in Linus' tree, can we have a fix for the waning,=20
> > > please?
> >=20
> > The first warning got fixed 1.5 months ago - the second one at line=20
> > 797 is still there but harmless - you can ignore it for now, it will=20
> > be fixed.
>=20
> The first warning never got fixed. The typecast was placed in the wrong
> spot (my fault). I sent another patch that fixes both warnings.

Thanks for that.

--=20
Cheers,
Stephen Rothwell                    sfr@canb.auug.org.au
http://www.canb.auug.org.au/~sfr/

--Signature=_Tue__15_Sep_2009_08_36_01_+1000_icbpFa729/f1lXND
Content-Type: application/pgp-signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.10 (GNU/Linux)

iEYEARECAAYFAkquxVEACgkQjjKRsyhoI8wHFwCaAqaPkFm9aq3oOUc1i0OH52Vy
29kAn2isI+Mtp/4iVipP4u0JYDu8rThJ
=gFS3
-----END PGP SIGNATURE-----

--Signature=_Tue__15_Sep_2009_08_36_01_+1000_icbpFa729/f1lXND--
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-sparse
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Tue, 15 Sep 2009 07:16:34 +0000
Message-ID: <1252998994.5506.0.camel () laptop>
--------------------
On Mon, 2009-09-14 at 20:41 +0200, Frederic Weisbecker wrote:
> On Mon, Sep 14, 2009 at 02:31:16PM -0400, Steven Rostedt wrote:
> > On Mon, 2009-09-14 at 20:23 +0200, Peter Zijlstra wrote:
> > > On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
> > > > Frederic, how big can one of those events get. The ring buffer (and
> > > > TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> > > > stack. This code needs to either be rewritten or we need to set a limit
> > > > to the size of a profile entry.
> > > 
> > > Yeah, that needs to get a re-write.. I've complained about this when it
> > > went in.
> > 
> > One answer is to create a per cpu buffer that is big enough to hold the
> > data needed. Then you can disable interrupts an use it without worry.
> > 
> > If you need to also handle NMIs, then create a per_cpu NMI buffer too,
> > and use that if "in_nmi()" is true.
> > 
> > -- Steve
> 
> 
> Looks like a nice idea.
> 
> Peter, does that sound acceptable to you to disable interrupts during a
> profiled tracepoint event?

It does anyway, a little further down the line, so sure.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-next
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Tue, 15 Sep 2009 07:16:34 +0000
Message-ID: <1252998994.5506.0.camel () laptop>
--------------------
On Mon, 2009-09-14 at 20:41 +0200, Frederic Weisbecker wrote:
> On Mon, Sep 14, 2009 at 02:31:16PM -0400, Steven Rostedt wrote:
> > On Mon, 2009-09-14 at 20:23 +0200, Peter Zijlstra wrote:
> > > On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
> > > > Frederic, how big can one of those events get. The ring buffer (and
> > > > TRACE_EVENT) allow up to almost a page size, which is very hefty for the
> > > > stack. This code needs to either be rewritten or we need to set a limit
> > > > to the size of a profile entry.
> > > 
> > > Yeah, that needs to get a re-write.. I've complained about this when it
> > > went in.
> > 
> > One answer is to create a per cpu buffer that is big enough to hold the
> > data needed. Then you can disable interrupts an use it without worry.
> > 
> > If you need to also handle NMIs, then create a per_cpu NMI buffer too,
> > and use that if "in_nmi()" is true.
> > 
> > -- Steve
> 
> 
> Looks like a nice idea.
> 
> Peter, does that sound acceptable to you to disable interrupts during a
> profiled tracepoint event?

It does anyway, a little further down the line, so sure.

--
To unsubscribe from this list: send the line "unsubscribe linux-next" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?ISO-8859-1?Q?Fr=E9d=E9ric_Weisbecker?= <fweisbec () gmail ! com>
To: linux-sparse
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Tue, 15 Sep 2009 09:01:15 +0000
Message-ID: <c62985530909150201p3d5ca037g232c9456e6436fc () mail ! gmail ! com>
--------------------
2009/9/15, Peter Zijlstra <peterz@infradead.org>:
> On Mon, 2009-09-14 at 20:41 +0200, Frederic Weisbecker wrote:
>> On Mon, Sep 14, 2009 at 02:31:16PM -0400, Steven Rostedt wrote:
>> > On Mon, 2009-09-14 at 20:23 +0200, Peter Zijlstra wrote:
>> > > On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
>> > > > Frederic, how big can one of those events get. The ring buffer (and
>> > > > TRACE_EVENT) allow up to almost a page size, which is very hefty for
>> > > > the
>> > > > stack. This code needs to either be rewritten or we need to set a
>> > > > limit
>> > > > to the size of a profile entry.
>> > >
>> > > Yeah, that needs to get a re-write.. I've complained about this when
>> > > it
>> > > went in.
>> >
>> > One answer is to create a per cpu buffer that is big enough to hold the
>> > data needed. Then you can disable interrupts an use it without worry.
>> >
>> > If you need to also handle NMIs, then create a per_cpu NMI buffer too,
>> > and use that if "in_nmi()" is true.
>> >
>> > -- Steve
>>
>>
>> Looks like a nice idea.
>>
>> Peter, does that sound acceptable to you to disable interrupts during a
>> profiled tracepoint event?
>
> It does anyway, a little further down the line, so sure.


Ok I'll fix it soon using Steve's idea then.

Thanks.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?ISO-8859-1?Q?Fr=E9d=E9ric_Weisbecker?= <fweisbec () gmail ! com>
To: linux-next
Subject: Re: Warning from ring buffer code (Was: Re: linux-next: tip tree
Date: Tue, 15 Sep 2009 09:01:15 +0000
Message-ID: <c62985530909150201p3d5ca037g232c9456e6436fc () mail ! gmail ! com>
--------------------
2009/9/15, Peter Zijlstra <peterz@infradead.org>:
> On Mon, 2009-09-14 at 20:41 +0200, Frederic Weisbecker wrote:
>> On Mon, Sep 14, 2009 at 02:31:16PM -0400, Steven Rostedt wrote:
>> > On Mon, 2009-09-14 at 20:23 +0200, Peter Zijlstra wrote:
>> > > On Mon, 2009-09-14 at 14:17 -0400, Steven Rostedt wrote:
>> > > > Frederic, how big can one of those events get. The ring buffer (and
>> > > > TRACE_EVENT) allow up to almost a page size, which is very hefty for
>> > > > the
>> > > > stack. This code needs to either be rewritten or we need to set a
>> > > > limit
>> > > > to the size of a profile entry.
>> > >
>> > > Yeah, that needs to get a re-write.. I've complained about this when
>> > > it
>> > > went in.
>> >
>> > One answer is to create a per cpu buffer that is big enough to hold the
>> > data needed. Then you can disable interrupts an use it without worry.
>> >
>> > If you need to also handle NMIs, then create a per_cpu NMI buffer too,
>> > and use that if "in_nmi()" is true.
>> >
>> > -- Steve
>>
>>
>> Looks like a nice idea.
>>
>> Peter, does that sound acceptable to you to disable interrupts during a
>> profiled tracepoint event?
>
> It does anyway, a little further down the line, so sure.


Ok I'll fix it soon using Steve's idea then.

Thanks.
--
To unsubscribe from this list: send the line "unsubscribe linux-next" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Winner ===

From: Tobacco <feetfirst () winch ! twcbc ! com>
To: linux-sparse
Subject: Winner
Date: Tue, 05 May 2009 11:34:48 +0000
Message-ID: <7h9gbp$d24uu2 () rrcs-agw-01b ! hrndva ! rr ! com>
--------------------
Your email ID was awarded £1,000,000,00 GBP in the tobacco draw. Get back to us via 

Name:...........................
Country:........................
Sex:............................
Age/Tell Number:................
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: You are awarded 1,000,000.00 Pounds by the British Tobacco Promotion, Provide your ===

From: Official Notice <0otraviso0 () sbcglobal ! net>
To: linux-sparse
Subject: You are awarded 1,000,000.00 Pounds by the British Tobacco Promotion, Provide your
Date: Fri, 04 Dec 2009 23:29:36 +0000
Message-ID: <2536.78115.qm () web83803 ! mail ! sp1 ! yahoo ! com>
--------------------

Name
Address
Occupation
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] Fix sparc64 and x86_64 issues ===

From: Blue Swirl <blauwirbel () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] Fix sparc64 and x86_64 issues
Date: Wed, 05 Aug 2009 18:51:25 +0000
Message-ID: <f43fc5580908051151o560e73bdw50c3d575f50f7096 () mail ! gmail ! com>
--------------------
Hi,

With these patches, I can run Sparse on OpenBIOS sources (which use
libgcc) also when compiling for 64 bit targets. 64 bit targets use 128
bit double cells, just like 64 bit double cells are used on 32 bit
targets.

I'm not sure if 'long long long' is actually used, libgcc uses
__attribute__ ((mode (TI))).

Blue Swirl (2):
  Add support for TImode type (__int128_t)
  Define __LP64__ for x86_64 unless in 32 bit mode

 cgcc         |    9 +++++----
 evaluate.c   |    8 +++++---
 expand.c     |    3 ++-
 gdbhelpers   |    3 +++
 parse.c      |   25 ++++++++++++++++++++++---
 show-parse.c |    3 +++
 symbol.c     |    6 ++++++
 symbol.h     |    8 +++++---
 target.c     |    1 +
 target.h     |    1 +
 10 files changed, 53 insertions(+), 14 deletions(-)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] Fix sparc64 and x86_64 issues
Date: Thu, 06 Aug 2009 21:16:59 +0000
Message-ID: <70318cbf0908061416o1956a2f6vce8f17d59e8b5f78 () mail ! gmail ! com>
--------------------
On Thu, Aug 6, 2009 at 1:23 PM, Blue Swirl<blauwirbel@gmail.com> wrote:
> On Wed, Aug 5, 2009 at 9:51 PM, Blue Swirl<blauwirbel@gmail.com> wrote:
>> Hi,
>>
>> With these patches, I can run Sparse on OpenBIOS sources (which use
>> libgcc) also when compiling for 64 bit targets. 64 bit targets use 128
>> bit double cells, just like 64 bit double cells are used on 32 bit
>> targets.
>>
>> I'm not sure if 'long long long' is actually used, libgcc uses
>> __attribute__ ((mode (TI))).

The change looks reasonable.

I feel that we can use:

#define MOD_ALL_LONG (MOD_LONG | MOD_LONGLONG | MOD_LONGLONGLONG)

Eventually the expression needs to handle 128 bit long constant as well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] Fix sparc64 and x86_64 issues
Date: Mon, 10 Aug 2009 17:49:52 +0000
Message-ID: <70318cbf0908101049v5958c121s320a5528d8fae032 () mail ! gmail ! com>
--------------------
On Thu, Aug 6, 2009 at 2:16 PM, Christopher Li<sparse@chrisli.org> wrote:
> On Thu, Aug 6, 2009 at 1:23 PM, Blue Swirl<blauwirbel@gmail.com> wrote:
>> On Wed, Aug 5, 2009 at 9:51 PM, Blue Swirl<blauwirbel@gmail.com> wrote:
>>> Hi,
>>>
>>> With these patches, I can run Sparse on OpenBIOS sources (which use
>>> libgcc) also when compiling for 64 bit targets. 64 bit targets use 128
>>> bit double cells, just like 64 bit double cells are used on 32 bit
>>> targets.
>>>
>>> I'm not sure if 'long long long' is actually used, libgcc uses
>>> __attribute__ ((mode (TI))).
>
> The change looks reasonable.
>
> I feel that we can use:
>
> #define MOD_ALL_LONG (MOD_LONG | MOD_LONGLONG | MOD_LONGLONGLONG)
>

I push the change does that. Please verify.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Blue Swirl <blauwirbel () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] Fix sparc64 and x86_64 issues
Date: Wed, 12 Aug 2009 18:42:00 +0000
Message-ID: <f43fc5580908121142i207fd9di17c7070de1e74856 () mail ! gmail ! com>
--------------------
On Mon, Aug 10, 2009 at 8:49 PM, Christopher Li<sparse@chrisli.org> wrote:
> On Thu, Aug 6, 2009 at 2:16 PM, Christopher Li<sparse@chrisli.org> wrote:
>> On Thu, Aug 6, 2009 at 1:23 PM, Blue Swirl<blauwirbel@gmail.com> wrote:
>>> On Wed, Aug 5, 2009 at 9:51 PM, Blue Swirl<blauwirbel@gmail.com> wrote:
>>>> Hi,
>>>>
>>>> With these patches, I can run Sparse on OpenBIOS sources (which use
>>>> libgcc) also when compiling for 64 bit targets. 64 bit targets use 128
>>>> bit double cells, just like 64 bit double cells are used on 32 bit
>>>> targets.
>>>>
>>>> I'm not sure if 'long long long' is actually used, libgcc uses
>>>> __attribute__ ((mode (TI))).
>>
>> The change looks reasonable.
>>
>> I feel that we can use:
>>
>> #define MOD_ALL_LONG (MOD_LONG | MOD_LONGLONG | MOD_LONGLONGLONG)
>>
>
> I push the change does that. Please verify.

Seems to work, thanks!
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2, RESEND] Ignore attribute __bounded__, used by OpenBSD ===

From: Blue Swirl <blauwirbel () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2, RESEND] Ignore attribute __bounded__, used by OpenBSD
Date: Sat, 01 Aug 2009 09:28:43 +0000
Message-ID: <f43fc5580908010228m75cc77eds2ecb23da51f031c1 () mail ! gmail ! com>
--------------------
See also an obsolete version at
http://marc.info/?l=linux-sparse&m=113344255600417&w=2

Signed-off-by: Blue Swirl <blauwirbel@gmail.com>
---
 parse.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/parse.c b/parse.c
index e5ad867..613f439 100644
--- a/parse.c
+++ b/parse.c
@@ -530,6 +530,8 @@ static struct init_keyword {
 	{ "__hot__",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "warning",	NS_KEYWORD,	.op = &ignore_attr_op },
 	{ "__warning__",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "bounded",	NS_KEYWORD,	.op = &ignore_attr_op },
+	{ "__bounded__",	NS_KEYWORD,	.op = &ignore_attr_op },
 };

 void init_parser(int stream)
-- 
1.6.2.4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for ===

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for
Date: Mon, 01 Jun 2009 06:21:35 +0000
Message-ID: <f19298770905312321q6eedf6e8ge7d5fe5ec46740da () mail ! gmail ! com>
--------------------
On Sun, May 31, 2009 at 19:44, Samuel Bronson <naesten@gmail.com> wrote:
> Changes-licensed-under: ISC license

I don't think it works that way.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================

From: Anderson Lizardo <anderson.lizardo () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for
Date: Mon, 01 Jun 2009 17:26:09 +0000
Message-ID: <5b5833aa0906011026p11eacb23y2f8326312a61fc22 () mail ! gmail ! com>
--------------------
On Mon, Jun 1, 2009 at 12:06 PM, Samuel Bronson <naesten@gmail.com> wrote:
> I just don't feel comfortable contributing under the OSL 1.1, for some
> reason -- possibly because it's considered non-DFSG, possibly because
> it's even more restrictive than the GPL ...

If you look at the recent mailing list archives, you will find that a
particular snapshot of the git tree was relicensed by the original
copyright holder (Transmeta?) under the MIT license. It seems the
current developers intend to check with the other copyright holders
(for code commited after the particular relicensed snapshot) for a
license change.

So I would you suggest at least using the MIT license to not "pollute"
the code with yet another license...

The developers might need to confirm this, I'm just on "monitoring
mode" here currently :)

Regards,
-- 
Anderson Lizardo
Instituto Nokia de Tecnologia (INdT)
Manaus - Brazil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for
Date: Mon, 01 Jun 2009 17:36:59 +0000
Message-ID: <db65a1cd0906011036t6b83a97v38664b7d7ba06f51 () mail ! gmail ! com>
--------------------
On Mon, Jun 1, 2009 at 1:26 PM, Anderson Lizardo
<anderson.lizardo@gmail.com> wrote:
> On Mon, Jun 1, 2009 at 12:06 PM, Samuel Bronson <naesten@gmail.com> wrote:
>> I just don't feel comfortable contributing under the OSL 1.1, for some
>> reason -- possibly because it's considered non-DFSG, possibly because
>> it's even more restrictive than the GPL ...
>
> If you look at the recent mailing list archives, you will find that a
> particular snapshot of the git tree was relicensed by the original
> copyright holder (Transmeta?) under the MIT license. It seems the
> current developers intend to check with the other copyright holders
> (for code commited after the particular relicensed snapshot) for a
> license change.
>
> So I would you suggest at least using the MIT license to not "pollute"
> the code with yet another license...

Oh, sure, that's fine with me! Hadn't heard about that. The MIT/X11
license is almost the same as the ISC license. Go ahead and s/ISC
license/MIT license/ in these patches, though I don't think either of
the patches that actually work (1/3 and 3/3) give me copyright on any
code anyway.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Zaytsev <alexey.zaytsev () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for
Date: Mon, 01 Jun 2009 17:44:58 +0000
Message-ID: <f19298770906011044o3affa20agc84787cfd9752618 () mail ! gmail ! com>
--------------------
On Mon, Jun 1, 2009 at 21:36, Samuel Bronson <naesten@gmail.com> wrote:
> On Mon, Jun 1, 2009 at 1:26 PM, Anderson Lizardo
> <anderson.lizardo@gmail.com> wrote:
>> On Mon, Jun 1, 2009 at 12:06 PM, Samuel Bronson <naesten@gmail.com> wrote:
>>> I just don't feel comfortable contributing under the OSL 1.1, for some
>>> reason -- possibly because it's considered non-DFSG, possibly because
>>> it's even more restrictive than the GPL ...
>>
>> If you look at the recent mailing list archives, you will find that a
>> particular snapshot of the git tree was relicensed by the original
>> copyright holder (Transmeta?) under the MIT license. It seems the
>> current developers intend to check with the other copyright holders
>> (for code commited after the particular relicensed snapshot) for a
>> license change.
>>
>> So I would you suggest at least using the MIT license to not "pollute"
>> the code with yet another license...
>
> Oh, sure, that's fine with me! Hadn't heard about that. The MIT/X11
> license is almost the same as the ISC license. Go ahead and s/ISC
> license/MIT license/ in these patches, though I don't think either of
> the patches that actually work (1/3 and 3/3) give me copyright on any
> code anyway.
>

Won't work that easily. Only an early sparse version, owned exclusively
by transmeta may be alternatively distribute under the MIT license. To
convert the current sparse version to MIT, we need to get all the
contributors to agree to this. Not impossible, but someone needs to
send lots of emails. ;)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for
Date: Mon, 01 Jun 2009 17:50:54 +0000
Message-ID: <db65a1cd0906011050k63f5dda5hf8d9b276a109cc0c () mail ! gmail ! com>
--------------------
On Mon, Jun 1, 2009 at 1:44 PM, Alexey Zaytsev <alexey.zaytsev@gmail.com> wrote:

> Won't work that easily. Only an early sparse version, owned exclusively
> by transmeta may be alternatively distribute under the MIT license. To
> convert the current sparse version to MIT, we need to get all the
> contributors to agree to this. Not impossible, but someone needs to
> send lots of emails. ;)

Yes, well, count me in -- now all I have to do is actually contribute
something copyrightable ;-)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for Emacs ===

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for Emacs
Date: Sun, 31 May 2009 15:44:10 +0000
Message-ID: <1243784652-31802-1-git-send-email-naesten () gmail ! com>
--------------------
Changes-licensed-under: ISC license
Signed-off-by: Samuel Bronson <naesten@gmail.com>
---
 gdbhelpers |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/gdbhelpers b/gdbhelpers
index 7223ffd..34407d6 100644
--- a/gdbhelpers
+++ b/gdbhelpers
@@ -1,3 +1,4 @@
+# For emacs: -*- gdb-script -*- 
 
 # Don't forget to rebuild sparse with uncommented debug options
 # in the Makefile. Also, gcc 3 is known to screw up with the
-- 
1.6.3.1.169.g33fd.dirty

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/3] Add -*- gdb-script -*- to the top of gdbhelpers, for Emacs
Date: Sun, 31 May 2009 15:44:10 +0000
Message-ID: <1243784652-31802-1-git-send-email-naesten () gmail ! com>
--------------------
Changes-licensed-under: ISC license
Signed-off-by: Samuel Bronson <naesten@gmail.com>
---
 gdbhelpers |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/gdbhelpers b/gdbhelpers
index 7223ffd..34407d6 100644
--- a/gdbhelpers
+++ b/gdbhelpers
@@ -1,3 +1,4 @@
+# For emacs: -*- gdb-script -*- 
 
 # Don't forget to rebuild sparse with uncommented debug options
 # in the Makefile. Also, gcc 3 is known to screw up with the
-- 
1.6.3.1.169.g33fd.dirty

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================


################################################################################

=== Thread: [PATCH 1/7] Fix handling of ident-less declarations ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 1/7] Fix handling of ident-less declarations
Date: Sat, 14 Feb 2009 18:45:41 +0000
Message-ID: <70318cbf0902141045q2552f1aetdd0ba0e462a21bad () mail ! gmail ! com>
--------------------
On Sat, Feb 14, 2009 at 4:25 AM, Al Viro <viro@ftp.linux.org.uk> wrote:
>
> The rule for ident-less declaration is

wow, great.

The series applies to the tree fine. First impression of the series
looks fine. I am still working on it.

Thanks for the patches. BTW, this is not the "lazy type evaluation"
you are talking about right?

Chris

>        declaration -> declaration-specifiers ;
> not
>        declaration -> declaration-specifiers abstract-declarator;
>
> IOW, struct foo; is OK and so's struct foo {int x; int y;} (and even
> simply int; is allowed by syntax - it's rejected by constraints, but
> that's a separate story), but not struct foo (void); and its ilk.
>
> See C99 6.7p1 for syntax; C90 is the same in that area and gcc also
> behaves the same way.  Unlike gcc I've made it a warning (gcc produces
> a hard error for those).
>
> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
> ---
>  parse.c                    |   10 +++++++++-
>  validation/missing-ident.c |   18 ++++++++++++++++++
>  2 files changed, 27 insertions(+), 1 deletions(-)
>  create mode 100644 validation/missing-ident.c
>
> diff --git a/parse.c b/parse.c
> index 73e7b65..6100fc2 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -2265,14 +2265,22 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>        token = declaration_specifiers(token, &ctype, 0);
>        decl = alloc_symbol(token->pos, SYM_NODE);
>        decl->ctype = ctype;
> +       /* Just a type declaration? */
> +       if (match_op(token, ';')) {
> +               apply_modifiers(token->pos, &decl->ctype);
> +               return token->next;
> +       }
> +
>        token = declarator(token, decl, &ident, 0);
>        apply_modifiers(token->pos, &decl->ctype);
>
>        decl->endpos = token->pos;
>
>        /* Just a type declaration? */
> -       if (!ident)
> +       if (!ident) {
> +               warning(token->pos, "missing identifier in declaration");
>                return expect(token, ';', "end of type declaration");
> +       }
>
>        /* type define declaration? */
>        is_typedef = (ctype.modifiers & MOD_TYPEDEF) != 0;
> diff --git a/validation/missing-ident.c b/validation/missing-ident.c
> new file mode 100644
> index 0000000..ce73983
> --- /dev/null
> +++ b/validation/missing-ident.c
> @@ -0,0 +1,18 @@
> +int [2];
> +int *;
> +int (*);
> +int ();
> +int;
> +struct foo;
> +union bar {int x; int y;};
> +struct baz {int x, :3, y:2;};
> +/*
> + * check-name: handling of identifier-less declarations
> + *
> + * check-error-start
> +missing-ident.c:1:8: warning: missing identifier in declaration
> +missing-ident.c:2:6: warning: missing identifier in declaration
> +missing-ident.c:3:8: warning: missing identifier in declaration
> +missing-ident.c:4:7: warning: missing identifier in declaration
> + * check-error-end
> + */
> --
> 1.5.6.6
>
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/7] Fix handling of ident-less declarations
Date: Sat, 14 Feb 2009 19:08:36 +0000
Message-ID: <20090214190836.GO28946 () ZenIV ! linux ! org ! uk>
--------------------
On Sat, Feb 14, 2009 at 10:45:41AM -0800, Christopher Li wrote:
> On Sat, Feb 14, 2009 at 4:25 AM, Al Viro <viro@ftp.linux.org.uk> wrote:
> >
> > The rule for ident-less declaration is
> 
> wow, great.
> 
> The series applies to the tree fine. First impression of the series
> looks fine. I am still working on it.
> 
> Thanks for the patches. BTW, this is not the "lazy type evaluation"
> you are talking about right?

No, just the first batch of declaration parser fixes...  The next group is
about separating ctype-as-part-of-symbol from ctype-as-parser-state uses.
After that - getting declaration_specifiers() to sane shape, which, BTW,
will relieve the situation with mode bits.  Then -  cleaning up the type
handling...
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/7] Fix handling of ident-less declarations
Date: Sat, 14 Feb 2009 20:31:54 +0000
Message-ID: <20090214203154.GP28946 () ZenIV ! linux ! org ! uk>
--------------------
On Sat, Feb 14, 2009 at 07:08:36PM +0000, Al Viro wrote:
> On Sat, Feb 14, 2009 at 10:45:41AM -0800, Christopher Li wrote:
> > On Sat, Feb 14, 2009 at 4:25 AM, Al Viro <viro@ftp.linux.org.uk> wrote:
> > >
> > > The rule for ident-less declaration is
> > 
> > wow, great.
> > 
> > The series applies to the tree fine. First impression of the series
> > looks fine. I am still working on it.
> > 
> > Thanks for the patches. BTW, this is not the "lazy type evaluation"
> > you are talking about right?
> 
> No, just the first batch of declaration parser fixes...  The next group is
> about separating ctype-as-part-of-symbol from ctype-as-parser-state uses.
> After that - getting declaration_specifiers() to sane shape, which, BTW,
> will relieve the situation with mode bits.  Then -  cleaning up the type
> handling...

BTW, I wonder whether if it would be better to just scan for the end
of attributes after ( when we are deciding whether it's a function or
nested declarator, leaving the actual handling of these guys to after
the decision.  The thing is, unlike gcc we have the token list anyway,
and it's easier to not bother with passing that crap to parameter_type_list(),
etc.

I'll try to do that and see what falls out; potentially that replaces
7/7 in this series.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/7] Fix handling of ident-less declarations
Date: Sat, 14 Feb 2009 21:30:32 +0000
Message-ID: <20090214213032.GQ28946 () ZenIV ! linux ! org ! uk>
--------------------
On Sat, Feb 14, 2009 at 08:31:54PM +0000, Al Viro wrote:
> On Sat, Feb 14, 2009 at 07:08:36PM +0000, Al Viro wrote:
> > On Sat, Feb 14, 2009 at 10:45:41AM -0800, Christopher Li wrote:
> > > On Sat, Feb 14, 2009 at 4:25 AM, Al Viro <viro@ftp.linux.org.uk> wrote:
> > > >
> > > > The rule for ident-less declaration is
> > > 
> > > wow, great.
> > > 
> > > The series applies to the tree fine. First impression of the series
> > > looks fine. I am still working on it.
> > > 
> > > Thanks for the patches. BTW, this is not the "lazy type evaluation"
> > > you are talking about right?
> > 
> > No, just the first batch of declaration parser fixes...  The next group is
> > about separating ctype-as-part-of-symbol from ctype-as-parser-state uses.
> > After that - getting declaration_specifiers() to sane shape, which, BTW,
> > will relieve the situation with mode bits.  Then -  cleaning up the type
> > handling...
> 
> BTW, I wonder whether if it would be better to just scan for the end
> of attributes after ( when we are deciding whether it's a function or
> nested declarator, leaving the actual handling of these guys to after
> the decision.  The thing is, unlike gcc we have the token list anyway,
> and it's easier to not bother with passing that crap to parameter_type_list(),
> etc.
> 
> I'll try to do that and see what falls out; potentially that replaces
> 7/7 in this series.

... no, it doesn't ;-/  Too much PITA with error recovery, so the original
version still stands.  Alas.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 10/18] preparations to ->declarator() cleanup - separate typedef handling ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 10/18] preparations to ->declarator() cleanup - separate typedef handling
Date: Mon, 09 Mar 2009 07:11:48 +0000
Message-ID: <E1LgZeO-0000vd-1Y () ZenIV ! linux ! org ! uk>
--------------------

Take typedef handling in declaration_specifiers() into separate
branch; kill useless check for qual in case the type we've got
has non-NULL base_type (we'd have already buggered off in that
situation before we get to the check in question).

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c |   20 +++++++++++---------
 1 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/parse.c b/parse.c
index 1435fde..ba1a52d 100644
--- a/parse.c
+++ b/parse.c
@@ -1105,29 +1105,31 @@ static struct token *declaration_specifiers(struct token *next, struct decl_stat
 		s = lookup_symbol(ident, NS_TYPEDEF);
 		if (!s)
 			break;
-		thistype = s->ctype;
-		mod = thistype.modifiers;
 		if (qual) {
 			if (s->type != SYM_KEYWORD)
 				break;
 			if (!(s->op->type & (KW_ATTRIBUTE | KW_QUALIFIER)))
 				break;
 		}
+		if (s->ctype.modifiers & MOD_USERTYPE) {
+			if (ctx->ctype.base_type)
+				break;
+			if (ctx->ctype.modifiers & MOD_SPECIFIER)
+				break;
+			ctx->ctype.base_type = s->ctype.base_type;
+			apply_ctype(token->pos, &s->ctype, &ctx->ctype);
+			continue;
+		}
+		thistype = s->ctype;
+		mod = thistype.modifiers;
 		if (s->type == SYM_KEYWORD && s->op->declarator) {
 			next = s->op->declarator(next, &thistype);
 			mod = thistype.modifiers;
 		}
 		type = thistype.base_type;
 		if (type) {
-			if (qual)
-				break;
 			if (ctx->ctype.base_type)
 				break;
-			/* User types only mix with qualifiers */
-			if (mod & MOD_USERTYPE) {
-				if (ctx->ctype.modifiers & MOD_SPECIFIER)
-					break;
-			}
 			ctx->ctype.base_type = type;
 		}
 
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 12/18] Saner type for __builtin_va_list ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 12/18] Saner type for __builtin_va_list
Date: Mon, 09 Mar 2009 07:12:08 +0000
Message-ID: <E1LgZei-0000xH-1z () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/parse.c b/parse.c
index a9156c9..04a4227 100644
--- a/parse.c
+++ b/parse.c
@@ -232,7 +232,7 @@ static struct init_keyword {
 		.op = &spec_op },
 
 	/* Predeclared types */
-	{ "__builtin_va_list", NS_TYPEDEF, .type = &int_type, .op = &spec_op },
+	{ "__builtin_va_list", NS_TYPEDEF, .type = &ptr_ctype, .op = &spec_op },
 
 	/* Extended types */
 	{ "typeof", 	NS_TYPEDEF, .op = &typeof_op },
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 13/18] Rewrite and fix specifiers handling ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 13/18] Rewrite and fix specifiers handling
Date: Mon, 09 Mar 2009 07:12:18 +0000
Message-ID: <E1LgZes-0000xr-2I () ZenIV ! linux ! org ! uk>
--------------------

Make sure that we accept the right set; kill ad-hackery around checks
for banned combinations.  Instead of that we keep a bitmap describing
what we'd already seen (with several extra bits for 'long long' and
for keeping track of can't-combine-with-anything stuff), check and
update it using the values in ..._op and keep track of size modifiers
more or less explicitly.

Testcases added.  A _lot_ of that used to be done wrong.

Note that __attribute__((mode(...))) got more broken by this one;
the next several changesets will take care of that.

One more thing: we are -><- close to getting rid of MOD_SPECIFIER bits
for good.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 ident-list.h             |    1 +
 parse.c                  |  365 ++++++++++++++++++++++++++--------------------
 parse.h                  |    1 -
 symbol.h                 |   12 +-
 validation/specifiers1.c |  101 +++++++++++++
 validation/specifiers2.c |  152 +++++++++++++++++++
 6 files changed, 467 insertions(+), 165 deletions(-)
 create mode 100644 validation/specifiers1.c
 create mode 100644 validation/specifiers2.c

diff --git a/ident-list.h b/ident-list.h
index 6104826..e22084e 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -23,6 +23,7 @@ IDENT(union);
 IDENT(enum);
 IDENT(__attribute); IDENT(__attribute__);
 IDENT(volatile); IDENT(__volatile); IDENT(__volatile__);
+IDENT(double);
 
 /* Extended gcc identifiers */
 IDENT(asm); IDENT_RESERVED(__asm); IDENT_RESERVED(__asm__);
diff --git a/parse.c b/parse.c
index 04a4227..73b4cac 100644
--- a/parse.c
+++ b/parse.c
@@ -67,6 +67,24 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
 
+enum {
+	Set_T = 1,
+	Set_S = 2,
+	Set_Char = 4,
+	Set_Int = 8,
+	Set_Double = 16,
+	Set_Float = 32,
+	Set_Signed = 64,
+	Set_Unsigned = 128,
+	Set_Short = 256,
+	Set_Long = 512,
+	Set_Vlong = 1024,
+	Set_Any = Set_T | Set_Short | Set_Long | Set_Signed | Set_Unsigned
+};
+
+enum {
+	CInt = 0, CSInt, CUInt, CReal, CChar, CSChar, CUChar
+};
 
 static struct symbol_op modifier_op = {
 	.type = KW_MODIFIER,
@@ -77,8 +95,10 @@ static struct symbol_op qualifier_op = {
 };
 
 static struct symbol_op typeof_op = {
-	.type = KW_TYPEOF,
+	.type = KW_SPECIFIER,
 	.declarator = typeof_specifier,
+	.test = Set_Any,
+	.set = Set_S|Set_T,
 };
 
 static struct symbol_op attribute_op = {
@@ -89,20 +109,81 @@ static struct symbol_op attribute_op = {
 static struct symbol_op struct_op = {
 	.type = KW_SPECIFIER,
 	.declarator = struct_specifier,
+	.test = Set_Any,
+	.set = Set_S|Set_T,
 };
 
 static struct symbol_op union_op = {
 	.type = KW_SPECIFIER,
 	.declarator = union_specifier,
+	.test = Set_Any,
+	.set = Set_S|Set_T,
 };
 
 static struct symbol_op enum_op = {
 	.type = KW_SPECIFIER,
 	.declarator = enum_specifier,
+	.test = Set_Any,
+	.set = Set_S|Set_T,
 };
 
 static struct symbol_op spec_op = {
-	.type = KW_SPEC,
+	.type = KW_SPECIFIER,
+	.test = Set_Any,
+	.set = Set_S|Set_T,
+};
+
+static struct symbol_op char_op = {
+	.type = KW_SPECIFIER,
+	.test = Set_T|Set_Long|Set_Short,
+	.set = Set_T|Set_Char,
+	.class = CChar,
+};
+
+static struct symbol_op int_op = {
+	.type = KW_SPECIFIER,
+	.test = Set_T,
+	.set = Set_T|Set_Int,
+};
+
+static struct symbol_op double_op = {
+	.type = KW_SPECIFIER,
+	.test = Set_T|Set_Signed|Set_Unsigned|Set_Short|Set_Vlong,
+	.set = Set_T|Set_Double,
+	.class = CReal,
+};
+
+static struct symbol_op float_op = {
+	.type = KW_SPECIFIER | KW_SHORT,
+	.test = Set_T|Set_Signed|Set_Unsigned|Set_Short|Set_Long,
+	.set = Set_T|Set_Float,
+	.class = CReal,
+};
+
+static struct symbol_op short_op = {
+	.type = KW_SPECIFIER | KW_SHORT,
+	.test = Set_S|Set_Char|Set_Float|Set_Double|Set_Long|Set_Short,
+	.set = Set_Short,
+};
+
+static struct symbol_op signed_op = {
+	.type = KW_SPECIFIER,
+	.test = Set_S|Set_Float|Set_Double|Set_Signed|Set_Unsigned,
+	.set = Set_Signed,
+	.class = CSInt,
+};
+
+static struct symbol_op unsigned_op = {
+	.type = KW_SPECIFIER,
+	.test = Set_S|Set_Float|Set_Double|Set_Signed|Set_Unsigned,
+	.set = Set_Unsigned,
+	.class = CUInt,
+};
+
+static struct symbol_op long_op = {
+	.type = KW_SPECIFIER | KW_LONG,
+	.test = Set_S|Set_Char|Set_Float|Set_Short|Set_Vlong,
+	.set = Set_Long,
 };
 
 static struct symbol_op if_op = {
@@ -216,22 +297,21 @@ static struct init_keyword {
 
 	/* Type specifiers */
 	{ "void",	NS_TYPEDEF, .type = &void_ctype, .op = &spec_op},
-	{ "char",	NS_TYPEDEF, MOD_CHAR, .op = &spec_op },
-	{ "short",	NS_TYPEDEF, MOD_SHORT, .op = &spec_op },
-	{ "int",	NS_TYPEDEF, .type = &int_type, .op = &spec_op },
-	{ "long",	NS_TYPEDEF, MOD_LONG, .op = &spec_op },
-	{ "float",	NS_TYPEDEF, .type = &fp_type, .op = &spec_op },
-	{ "double",	NS_TYPEDEF, MOD_LONG, .type = &fp_type, .op = &spec_op },
-	{ "signed",	NS_TYPEDEF, MOD_SIGNED | MOD_EXPLICITLY_SIGNED, .op = &spec_op },
-	{ "__signed",	NS_TYPEDEF, MOD_SIGNED | MOD_EXPLICITLY_SIGNED, .op = &spec_op },
-	{ "__signed__",	NS_TYPEDEF, MOD_SIGNED | MOD_EXPLICITLY_SIGNED, .op = &spec_op },
-	{ "unsigned",	NS_TYPEDEF, MOD_UNSIGNED, .op = &spec_op },
-	{ "__label__",	NS_TYPEDEF, MOD_LABEL | MOD_UNSIGNED,
-		.type =&label_ctype, .op = &spec_op },
-	{ "_Bool",	NS_TYPEDEF, MOD_UNSIGNED, .type = &bool_ctype,
-		.op = &spec_op },
+	{ "char",	NS_TYPEDEF, .op = &char_op },
+	{ "short",	NS_TYPEDEF, .op = &short_op },
+	{ "int",	NS_TYPEDEF, .op = &int_op },
+	{ "long",	NS_TYPEDEF, .op = &long_op },
+	{ "float",	NS_TYPEDEF, .op = &float_op },
+	{ "double",	NS_TYPEDEF, .op = &double_op },
+	{ "signed",	NS_TYPEDEF, .op = &signed_op },
+	{ "__signed",	NS_TYPEDEF, .op = &signed_op },
+	{ "__signed__",	NS_TYPEDEF, .op = &signed_op },
+	{ "unsigned",	NS_TYPEDEF, .op = &unsigned_op },
+	{ "_Bool",	NS_TYPEDEF, .type = &bool_ctype, .op = &spec_op },
 
 	/* Predeclared types */
+	{ "__label__",	NS_TYPEDEF, MOD_LABEL,
+		.type =&label_ctype, .op = &spec_op },
 	{ "__builtin_va_list", NS_TYPEDEF, .type = &ptr_ctype, .op = &spec_op },
 
 	/* Extended types */
@@ -428,45 +508,7 @@ static struct token *struct_declaration_list(struct token *token, struct symbol_
 
 static int apply_modifiers(struct position pos, struct ctype *ctype)
 {
-	struct symbol *base;
-
-	while ((base = ctype->base_type)) {
-		switch (base->type) {
-		case SYM_FN:
-		case SYM_ENUM:
-		case SYM_ARRAY:
-		case SYM_BITFIELD:
-		case SYM_PTR:
-			ctype = &base->ctype;
-			continue;
-		}
-		break;
-	}
-
-	/* Turn the "virtual types" into real types with real sizes etc */
-	if (ctype->base_type == &int_type) {
-		ctype->base_type = ctype_integer(ctype->modifiers);
-		ctype->modifiers &= ~MOD_SPECIFIER;
-	} else if (ctype->base_type == &fp_type) {
-		ctype->base_type = ctype_fp(ctype->modifiers);
-		ctype->modifiers &= ~MOD_SPECIFIER;
-	}
-
-	if (ctype->modifiers & MOD_BITWISE) {
-		struct symbol *type;
-		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
-		if (!is_int_type(ctype->base_type)) {
-			sparse_error(pos, "invalid modifier");
-			return 1;
-		}
-		type = alloc_symbol(pos, SYM_BASETYPE);
-		*type = *ctype->base_type;
-		type->ctype.base_type = ctype->base_type;
-		type->type = SYM_RESTRICT;
-		type->ctype.modifiers &= ~MOD_SPECIFIER;
-		ctype->base_type = type;
-		create_fouled(type);
-	}
+	/* not removing it; application of delayed attributes will be here */
 	return 0;
 }
 
@@ -990,82 +1032,26 @@ static struct token *attribute_specifier(struct token *token, struct ctype *ctyp
 	return token;
 }
 
-struct symbol * ctype_integer(unsigned long spec)
-{
-	static struct symbol *const integer_ctypes[][3] = {
-		{ &llong_ctype, &sllong_ctype, &ullong_ctype },
-		{ &long_ctype,  &slong_ctype,  &ulong_ctype  },
-		{ &short_ctype, &sshort_ctype, &ushort_ctype },
-		{ &char_ctype,  &schar_ctype,  &uchar_ctype  },
-		{ &int_ctype,   &sint_ctype,   &uint_ctype   },
-	};
-	struct symbol *const (*ctype)[3];
-	int sub;
-
-	ctype = integer_ctypes;
-	if (!(spec & MOD_LONGLONG)) {
-		ctype++;
-		if (!(spec & MOD_LONG)) {
-			ctype++;
-			if (!(spec & MOD_SHORT)) {
-				ctype++;
-				if (!(spec & MOD_CHAR))
-					ctype++;
-			}
-		}
-	}
-
-	sub = ((spec & MOD_UNSIGNED)
-	       ? 2
-	       : ((spec & MOD_EXPLICITLY_SIGNED)
-		  ? 1
-		  : 0));
-
-	return ctype[0][sub];
-}
-
-struct symbol * ctype_fp(unsigned long spec)
-{
-	if (spec & MOD_LONGLONG)
-		return &ldouble_ctype;
-	if (spec & MOD_LONG)
-		return &double_ctype;
-	return &float_ctype;
-}
-
 static void apply_ctype(struct position pos, struct ctype *thistype, struct ctype *ctype)
 {
 	unsigned long mod = thistype->modifiers;
 
 	if (mod) {
 		unsigned long old = ctype->modifiers;
-		unsigned long extra = 0, dup, conflict;
+		unsigned long dup, conflict;
 
-		if (mod & old & MOD_LONG) {
-			extra = MOD_LONGLONG | MOD_LONG;
-			mod &= ~MOD_LONG;
-			old &= ~MOD_LONG;
-		}
-		dup = (mod & old) | (extra & old) | (extra & mod);
+		dup = mod & old;
 		if (dup)
 			sparse_error(pos, "Just how %sdo you want this type to be?",
 				modifier_string(dup));
 
-		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
-		if (conflict)
-			sparse_error(pos, "You cannot have both long and short modifiers.");
-
-		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
-		if (conflict)
-			sparse_error(pos, "You cannot have both signed and unsigned modifiers.");
-
 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
 			sparse_error(pos, "multiple storage classes");
 
-		ctype->modifiers = old | mod | extra;
+		ctype->modifiers = old | mod;
 	}
 
 	/* Context */
@@ -1085,41 +1071,76 @@ static void apply_ctype(struct position pos, struct ctype *thistype, struct ctyp
 		ctype->as = thistype->as;
 }
 
-static void check_modifiers(struct position *pos, struct symbol *s, unsigned long mod)
-{
-	unsigned long banned, wrong;
-	const unsigned long BANNED_SIZE = MOD_LONG | MOD_LONGLONG | MOD_SHORT;
-	const unsigned long BANNED_SIGN = MOD_SIGNED | MOD_UNSIGNED;
-
-	if (!(s->op->type & KW_SPEC))
-		banned = s->op->type == KW_SPECIFIER ? (BANNED_SIZE | BANNED_SIGN) : 0;
-	else if (s->ctype.base_type == &fp_type)
-		banned = BANNED_SIGN;
-	else if (s->ctype.base_type == &int_type || !s->ctype.base_type || is_int_type (s))
-		banned = 0;
-	else {
-		// label_type
-		// void_type
-		// bad_type
-		// vector_type <-- whatever that is
-		banned = BANNED_SIZE | BANNED_SIGN;
-	}
+static void specifier_conflict(struct position pos, int what, struct ident *new)
+{
+	const char *old;
+	if (what & (Set_S | Set_T))
+		goto Catch_all;
+	if (what & Set_Char)
+		old = "char";
+	else if (what & Set_Double)
+		old = "double";
+	else if (what & Set_Float)
+		old = "float";
+	else if (what & Set_Signed)
+		old = "signed";
+	else if (what & Set_Unsigned)
+		old = "unsigned";
+	else if (what & Set_Short)
+		old = "short";
+	else if (what & Set_Long)
+		old = "long";
+	else
+		old = "long long";
+	sparse_error(pos, "impossible combination of type specifiers: %s %s",
+			old, show_ident(new));
+	return;
+
+Catch_all:
+	sparse_error(pos, "two or more data types in declaration specifiers");
+}
+
+static struct symbol * const int_types[] =
+	{&short_ctype, &int_ctype, &long_ctype, &llong_ctype};
+static struct symbol * const signed_types[] =
+	{&sshort_ctype, &sint_ctype, &slong_ctype, &sllong_ctype};
+static struct symbol * const unsigned_types[] =
+	{&ushort_ctype, &uint_ctype, &ulong_ctype, &ullong_ctype};
+static struct symbol * const real_types[] =
+	{&float_ctype, &double_ctype, &ldouble_ctype};
+static struct symbol * const char_types[] =
+	{&char_ctype, &schar_ctype, &uchar_ctype};
+static struct symbol * const * const types[] = {
+	int_types + 1, signed_types + 1, unsigned_types + 1,
+	real_types + 1, char_types, char_types + 1, char_types + 2
+};
+
+struct symbol *ctype_integer(unsigned long spec)
+{
+	int size;
+
+	if (spec & MOD_LONGLONG)
+		size = 2;
+	else if (spec & MOD_LONG)
+		size = 1;
+	else
+		size = 0;
 
-	wrong = mod & banned;
-	if (wrong)
-		sparse_error(*pos, "modifier %sis invalid in this context",
-		     modifier_string (wrong));
+	return types[spec & MOD_UNSIGNED ? CUInt : CInt][size];
 }
 
 static struct token *declaration_specifiers(struct token *next, struct decl_state *ctx, int qual)
 {
+
 	struct token *token;
+	int seen = 0;
+	int class = CInt;
+	int size = 0;
 
 	while ( (token = next) != NULL ) {
 		struct ctype thistype;
 		struct ident *ident;
 		struct symbol *s, *type;
-		unsigned long mod;
 
 		next = token->next;
 		if (token_type(token) != TOKEN_IDENT)
@@ -1136,43 +1157,69 @@ static struct token *declaration_specifiers(struct token *next, struct decl_stat
 				break;
 		}
 		if (s->ctype.modifiers & MOD_USERTYPE) {
-			if (ctx->ctype.base_type)
-				break;
-			if (ctx->ctype.modifiers & MOD_SPECIFIER)
+			if (seen & Set_Any)
 				break;
+			seen |= Set_S | Set_T;
 			ctx->ctype.base_type = s->ctype.base_type;
 			apply_ctype(token->pos, &s->ctype, &ctx->ctype);
 			continue;
 		}
+		if (s->type != SYM_KEYWORD)
+			break;
+		if (s->op->type & KW_SPECIFIER) {
+			if (seen & s->op->test) {
+				specifier_conflict(token->pos,
+						   seen & s->op->test,
+						   ident);
+				break;
+			}
+			seen |= s->op->set;
+			class += s->op->class;
+			if (s->op->type & KW_SHORT) {
+				size = -1;
+			} else if (s->op->type & KW_LONG && size++) {
+				if (class == CReal) {
+					specifier_conflict(token->pos,
+							   Set_Vlong,
+							   &double_ident);
+					break;
+				}
+				seen |= Set_Vlong;
+			}
+		}
 		thistype = s->ctype;
-		mod = thistype.modifiers;
-		if (s->type == SYM_KEYWORD && s->op->declarator) {
+		if (s->op->declarator)
 			next = s->op->declarator(next, &thistype);
-			mod = thistype.modifiers;
-		}
 		type = thistype.base_type;
-		if (type) {
-			if (ctx->ctype.base_type)
-				break;
+		if (type)
 			ctx->ctype.base_type = type;
-		}
-
-		check_modifiers(&token->pos, s, ctx->ctype.modifiers);
 		apply_ctype(token->pos, &thistype, &ctx->ctype);
 	}
+	if (qual)
+		return token;
 
-	if (!ctx->ctype.base_type) {
+	if (!(seen & Set_S)) {	/* not set explicitly? */
 		struct symbol *base = &incomplete_ctype;
-
-		/*
-		 * If we have modifiers, we'll default to an integer
-		 * type, and "ctype_integer()" will turn this into
-		 * a specific one.
-		 */
-		if (ctx->ctype.modifiers & MOD_SPECIFIER)
-			base = &int_type;
+		if (seen & Set_Any)
+			base = types[class][size];
 		ctx->ctype.base_type = base;
 	}
+
+	if (ctx->ctype.modifiers & MOD_BITWISE) {
+		struct symbol *type;
+		ctx->ctype.modifiers &= ~MOD_BITWISE;
+		if (!is_int_type(ctx->ctype.base_type)) {
+			sparse_error(token->pos, "invalid modifier");
+			return token;
+		}
+		type = alloc_symbol(token->pos, SYM_BASETYPE);
+		*type = *ctx->ctype.base_type;
+		type->ctype.modifiers &= ~MOD_SPECIFIER;
+		type->ctype.base_type = ctx->ctype.base_type;
+		type->type = SYM_RESTRICT;
+		ctx->ctype.base_type = type;
+		create_fouled(type);
+	}
 	return token;
 }
 
diff --git a/parse.h b/parse.h
index 609910f..26dc624 100644
--- a/parse.h
+++ b/parse.h
@@ -128,7 +128,6 @@ extern int show_expression(struct expression *);
 extern struct token *external_declaration(struct token *token, struct symbol_list **list);
 
 extern struct symbol *ctype_integer(unsigned long spec);
-extern struct symbol *ctype_fp(unsigned long spec);
 
 extern void copy_statement(struct statement *src, struct statement *dst);
 extern int inline_function(struct expression *expr, struct symbol *sym);
diff --git a/symbol.h b/symbol.h
index 229057c..f82f51d 100644
--- a/symbol.h
+++ b/symbol.h
@@ -64,11 +64,11 @@ enum keyword {
 	KW_MODIFIER	= 1 << 1,
 	KW_QUALIFIER	= 1 << 2,
 	KW_ATTRIBUTE	= 1 << 3,
-	KW_TYPEOF	= 1 << 4,
-	KW_STATEMENT	= 1 << 5,
-	KW_ASM		= 1 << 6,
-	KW_MODE		= 1 << 7,
-	KW_SPEC		= 1 << 8,
+	KW_STATEMENT	= 1 << 4,
+	KW_ASM		= 1 << 5,
+	KW_MODE		= 1 << 6,
+	KW_SHORT	= 1 << 7,
+	KW_LONG		= 1 << 8,
 };
 
 struct context {
@@ -105,6 +105,8 @@ struct symbol_op {
 	struct token *(*statement)(struct token *token, struct statement *stmt);
 	struct token *(*toplevel)(struct token *token, struct symbol_list **list);
 	struct token *(*attribute)(struct token *token, struct symbol *attr, struct ctype *ctype);
+
+	int test, set, class;
 };
 
 extern int expand_safe_p(struct expression *expr, int cost);
diff --git a/validation/specifiers1.c b/validation/specifiers1.c
new file mode 100644
index 0000000..86db45d
--- /dev/null
+++ b/validation/specifiers1.c
@@ -0,0 +1,101 @@
+static void OK(void)
+{
+#define TEST(x) { T a; x *b = &a; }
+#define TEST2(x, y) TEST(x y) TEST(y x)
+#define TEST3(x, y, z) TEST(x y z) TEST(x z y) TEST(y x z) \
+		       TEST(y z x) TEST(z x y) TEST(z y x)
+#define TEST4(x, y, z, w) TEST2(x y, z w) TEST2(x y, w z) \
+			  TEST2(y x, z w) TEST2(y x, w z) \
+			  TEST2(x z, y w) TEST2(x z, w y) \
+			  TEST2(z x, y w) TEST2(z x, w y) \
+			  TEST2(x w, y z) TEST2(x w, z y) \
+			  TEST2(w x, y z) TEST2(w x, z y)
+
+
+#define T char
+TEST(char)
+#undef T
+
+#define T signed char
+TEST2(char, signed)
+#undef T
+
+#define T unsigned char
+TEST2(char, unsigned)
+#undef T
+
+#define T short
+TEST(short)
+TEST2(int, short)
+#undef T
+
+#define T int
+TEST(int)
+#undef T
+
+#define T long
+TEST(long)
+TEST2(int, long)
+#undef T
+
+#define T long long
+TEST2(long, long)
+TEST3(int, long, long)
+#undef T
+
+#define T signed short
+TEST2(short, signed)
+TEST3(int, short, signed)
+#undef T
+
+#define T signed
+TEST(signed)
+TEST2(int, signed)
+#undef T
+
+#define T signed long
+TEST2(long, signed)
+TEST3(int, long, signed)
+#undef T
+
+#define T signed long long
+TEST3(long, long, signed)
+TEST4(int, long, long, signed)
+#undef T
+
+#define T unsigned short
+TEST2(short, unsigned)
+TEST3(int, short, unsigned)
+#undef T
+
+#define T unsigned
+TEST(unsigned)
+TEST2(int, unsigned)
+#undef T
+
+#define T unsigned long
+TEST2(long, unsigned)
+TEST3(int, long, unsigned)
+#undef T
+
+#define T unsigned long long
+TEST3(long, long, unsigned)
+TEST4(int, long, long, unsigned)
+#undef T
+
+#define T float
+TEST(float)
+#undef T
+
+#define T double
+TEST(double)
+#undef T
+
+#define T long double
+TEST2(double, long)
+#undef T
+}
+/*
+ * check-name: valid specifier combinations
+ * check-command: sparse -Wall $file
+ */
diff --git a/validation/specifiers2.c b/validation/specifiers2.c
new file mode 100644
index 0000000..d5be118
--- /dev/null
+++ b/validation/specifiers2.c
@@ -0,0 +1,152 @@
+typedef int T;
+void BAD(
+char char,
+char int,
+char double,
+char float,
+char long,
+char short,
+int char,
+int int,
+int double,
+int float,
+double char,
+double int,
+double double,
+double float,
+double short,
+double signed,
+double unsigned,
+float char,
+float int,
+float double,
+float float,
+float short,
+float long,
+float signed,
+float unsigned,
+short char,
+short double,
+short float,
+short short,
+short long,
+long char,
+long float,
+long short,
+signed double,
+signed float,
+signed signed,
+signed unsigned,
+unsigned double,
+unsigned float,
+unsigned signed,
+unsigned unsigned,
+unsigned signed,
+long long long,
+long double long,
+long long double,
+double long long,
+T char,
+T int,
+T double,
+T float,
+T short,
+T long,
+T signed,
+T unsigned,
+T void,
+void char,
+void int,
+void double,
+void float,
+void short,
+void long,
+void signed,
+void unsigned,
+char void,
+int void,
+double void,
+float void,
+short void,
+long void,
+signed void,
+unsigned void,
+void void
+);
+/*
+ * check-name: invalid specifier combinations
+ * check-error-start
+specifiers2.c:3:6: error: two or more data types in declaration specifiers
+specifiers2.c:4:6: error: two or more data types in declaration specifiers
+specifiers2.c:5:6: error: two or more data types in declaration specifiers
+specifiers2.c:6:6: error: two or more data types in declaration specifiers
+specifiers2.c:7:6: error: impossible combination of type specifiers: char long
+specifiers2.c:8:6: error: impossible combination of type specifiers: char short
+specifiers2.c:9:5: error: two or more data types in declaration specifiers
+specifiers2.c:10:5: error: two or more data types in declaration specifiers
+specifiers2.c:11:5: error: two or more data types in declaration specifiers
+specifiers2.c:12:5: error: two or more data types in declaration specifiers
+specifiers2.c:13:8: error: two or more data types in declaration specifiers
+specifiers2.c:14:8: error: two or more data types in declaration specifiers
+specifiers2.c:15:8: error: two or more data types in declaration specifiers
+specifiers2.c:16:8: error: two or more data types in declaration specifiers
+specifiers2.c:17:8: error: impossible combination of type specifiers: double short
+specifiers2.c:18:8: error: impossible combination of type specifiers: double signed
+specifiers2.c:19:8: error: impossible combination of type specifiers: double unsigned
+specifiers2.c:20:7: error: two or more data types in declaration specifiers
+specifiers2.c:21:7: error: two or more data types in declaration specifiers
+specifiers2.c:22:7: error: two or more data types in declaration specifiers
+specifiers2.c:23:7: error: two or more data types in declaration specifiers
+specifiers2.c:24:7: error: impossible combination of type specifiers: float short
+specifiers2.c:25:7: error: impossible combination of type specifiers: float long
+specifiers2.c:26:7: error: impossible combination of type specifiers: float signed
+specifiers2.c:27:7: error: impossible combination of type specifiers: float unsigned
+specifiers2.c:28:7: error: impossible combination of type specifiers: short char
+specifiers2.c:29:7: error: impossible combination of type specifiers: short double
+specifiers2.c:30:7: error: impossible combination of type specifiers: short float
+specifiers2.c:31:7: error: impossible combination of type specifiers: short short
+specifiers2.c:32:7: error: impossible combination of type specifiers: short long
+specifiers2.c:33:6: error: impossible combination of type specifiers: long char
+specifiers2.c:34:6: error: impossible combination of type specifiers: long float
+specifiers2.c:35:6: error: impossible combination of type specifiers: long short
+specifiers2.c:36:8: error: impossible combination of type specifiers: signed double
+specifiers2.c:37:8: error: impossible combination of type specifiers: signed float
+specifiers2.c:38:8: error: impossible combination of type specifiers: signed signed
+specifiers2.c:39:8: error: impossible combination of type specifiers: signed unsigned
+specifiers2.c:40:10: error: impossible combination of type specifiers: unsigned double
+specifiers2.c:41:10: error: impossible combination of type specifiers: unsigned float
+specifiers2.c:42:10: error: impossible combination of type specifiers: unsigned signed
+specifiers2.c:43:10: error: impossible combination of type specifiers: unsigned unsigned
+specifiers2.c:44:10: error: impossible combination of type specifiers: unsigned signed
+specifiers2.c:45:11: error: impossible combination of type specifiers: long long long
+specifiers2.c:46:13: error: impossible combination of type specifiers: long long double
+specifiers2.c:47:11: error: impossible combination of type specifiers: long long double
+specifiers2.c:48:13: error: impossible combination of type specifiers: long long double
+specifiers2.c:49:3: error: two or more data types in declaration specifiers
+specifiers2.c:50:3: error: two or more data types in declaration specifiers
+specifiers2.c:51:3: error: two or more data types in declaration specifiers
+specifiers2.c:52:3: error: two or more data types in declaration specifiers
+specifiers2.c:53:3: error: two or more data types in declaration specifiers
+specifiers2.c:54:3: error: two or more data types in declaration specifiers
+specifiers2.c:55:3: error: two or more data types in declaration specifiers
+specifiers2.c:56:3: error: two or more data types in declaration specifiers
+specifiers2.c:57:3: error: two or more data types in declaration specifiers
+specifiers2.c:58:6: error: two or more data types in declaration specifiers
+specifiers2.c:59:6: error: two or more data types in declaration specifiers
+specifiers2.c:60:6: error: two or more data types in declaration specifiers
+specifiers2.c:61:6: error: two or more data types in declaration specifiers
+specifiers2.c:62:6: error: two or more data types in declaration specifiers
+specifiers2.c:63:6: error: two or more data types in declaration specifiers
+specifiers2.c:64:6: error: two or more data types in declaration specifiers
+specifiers2.c:65:6: error: two or more data types in declaration specifiers
+specifiers2.c:66:6: error: two or more data types in declaration specifiers
+specifiers2.c:67:5: error: two or more data types in declaration specifiers
+specifiers2.c:68:8: error: two or more data types in declaration specifiers
+specifiers2.c:69:7: error: two or more data types in declaration specifiers
+specifiers2.c:70:7: error: impossible combination of type specifiers: short void
+specifiers2.c:71:6: error: impossible combination of type specifiers: long void
+specifiers2.c:72:8: error: impossible combination of type specifiers: signed void
+specifiers2.c:73:10: error: impossible combination of type specifiers: unsigned void
+specifiers2.c:74:6: error: two or more data types in declaration specifiers
+ * check-error-end
+ */
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 14/18] Have ->declarator() act directly on ctype being affected ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 14/18] Have ->declarator() act directly on ctype being affected
Date: Mon, 09 Mar 2009 07:12:28 +0000
Message-ID: <E1LgZf2-0000yB-2W () ZenIV ! linux ! org ! uk>
--------------------

... and don't do full-blown apply_ctype() every damn time.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c  |  234 ++++++++++++++++++++++++++++++++++++++++++-------------------
 symbol.h |    1 +
 2 files changed, 162 insertions(+), 73 deletions(-)

diff --git a/parse.c b/parse.c
index 73b4cac..076e149 100644
--- a/parse.c
+++ b/parse.c
@@ -35,11 +35,13 @@ struct statement_list *function_computed_goto_list;
 static struct token *statement(struct token *token, struct statement **tree);
 static struct token *handle_attributes(struct token *token, struct ctype *ctype, unsigned int keywords);
 
-static struct token *struct_specifier(struct token *token, struct ctype *ctype);
-static struct token *union_specifier(struct token *token, struct ctype *ctype);
-static struct token *enum_specifier(struct token *token, struct ctype *ctype);
-static struct token *attribute_specifier(struct token *token, struct ctype *ctype);
-static struct token *typeof_specifier(struct token *token, struct ctype *ctype);
+typedef struct token *declarator_t(struct token *, struct ctype *);
+static declarator_t
+	struct_specifier, union_specifier, enum_specifier,
+	attribute_specifier, typeof_specifier, parse_asm_declarator,
+	typedef_specifier, inline_specifier, auto_specifier,
+	register_specifier, static_specifier, extern_specifier,
+	const_qualifier, volatile_qualifier;
 
 static struct token *parse_if_statement(struct token *token, struct statement *stmt);
 static struct token *parse_return_statement(struct token *token, struct statement *stmt);
@@ -55,17 +57,14 @@ static struct token *parse_context_statement(struct token *token, struct stateme
 static struct token *parse_range_statement(struct token *token, struct statement *stmt);
 static struct token *parse_asm_statement(struct token *token, struct statement *stmt);
 static struct token *toplevel_asm_declaration(struct token *token, struct symbol_list **list);
-static struct token *parse_asm_declarator(struct token *token, struct ctype *ctype);
 
+typedef struct token *attr_t(struct token *, struct symbol *, struct ctype *);
 
-static struct token *attribute_packed(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_modifier(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_address_space(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_aligned(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_mode(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_context(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct ctype *ctype);
-static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct ctype *ctype);
+static attr_t
+	attribute_packed, attribute_aligned, attribute_modifier,
+	attribute_address_space, attribute_context,
+	attribute_transparent_union, ignore_attribute,
+	attribute_mode;
 
 enum {
 	Set_T = 1,
@@ -86,11 +85,47 @@ enum {
 	CInt = 0, CSInt, CUInt, CReal, CChar, CSChar, CUChar
 };
 
-static struct symbol_op modifier_op = {
+static struct symbol_op typedef_op = {
 	.type = KW_MODIFIER,
+	.declarator = typedef_specifier,
 };
 
-static struct symbol_op qualifier_op = {
+static struct symbol_op inline_op = {
+	.type = KW_MODIFIER,
+	.declarator = inline_specifier,
+};
+
+static struct symbol_op auto_op = {
+	.type = KW_MODIFIER,
+	.declarator = auto_specifier,
+};
+
+static struct symbol_op register_op = {
+	.type = KW_MODIFIER,
+	.declarator = register_specifier,
+};
+
+static struct symbol_op static_op = {
+	.type = KW_MODIFIER,
+	.declarator = static_specifier,
+};
+
+static struct symbol_op extern_op = {
+	.type = KW_MODIFIER,
+	.declarator = extern_specifier,
+};
+
+static struct symbol_op const_op = {
+	.type = KW_QUALIFIER,
+	.declarator = const_qualifier,
+};
+
+static struct symbol_op volatile_op = {
+	.type = KW_QUALIFIER,
+	.declarator = volatile_qualifier,
+};
+
+static struct symbol_op restrict_op = {
 	.type = KW_QUALIFIER,
 };
 
@@ -128,7 +163,7 @@ static struct symbol_op enum_op = {
 };
 
 static struct symbol_op spec_op = {
-	.type = KW_SPECIFIER,
+	.type = KW_SPECIFIER | KW_EXACT,
 	.test = Set_Any,
 	.set = Set_S|Set_T,
 };
@@ -285,15 +320,15 @@ static struct init_keyword {
 	struct symbol *type;
 } keyword_table[] = {
 	/* Type qualifiers */
-	{ "const",	NS_TYPEDEF, MOD_CONST, .op = &qualifier_op },
-	{ "__const",	NS_TYPEDEF, MOD_CONST, .op = &qualifier_op },
-	{ "__const__",	NS_TYPEDEF, MOD_CONST, .op = &qualifier_op },
-	{ "volatile",	NS_TYPEDEF, MOD_VOLATILE, .op = &qualifier_op },
-	{ "__volatile",		NS_TYPEDEF, MOD_VOLATILE, .op = &qualifier_op },
-	{ "__volatile__", 	NS_TYPEDEF, MOD_VOLATILE, .op = &qualifier_op },
+	{ "const",	NS_TYPEDEF, .op = &const_op },
+	{ "__const",	NS_TYPEDEF, .op = &const_op },
+	{ "__const__",	NS_TYPEDEF, .op = &const_op },
+	{ "volatile",	NS_TYPEDEF, .op = &volatile_op },
+	{ "__volatile",		NS_TYPEDEF, .op = &volatile_op },
+	{ "__volatile__", 	NS_TYPEDEF, .op = &volatile_op },
 
 	/* Typedef.. */
-	{ "typedef",	NS_TYPEDEF, MOD_TYPEDEF, .op = &modifier_op },
+	{ "typedef",	NS_TYPEDEF, .op = &typedef_op },
 
 	/* Type specifiers */
 	{ "void",	NS_TYPEDEF, .type = &void_ctype, .op = &spec_op},
@@ -326,19 +361,19 @@ static struct init_keyword {
 	{ "union", 	NS_TYPEDEF, .op = &union_op },
 	{ "enum", 	NS_TYPEDEF, .op = &enum_op },
 
-	{ "inline",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
-	{ "__inline",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
-	{ "__inline__",	NS_TYPEDEF, MOD_INLINE, .op = &modifier_op },
+	{ "inline",	NS_TYPEDEF, .op = &inline_op },
+	{ "__inline",	NS_TYPEDEF, .op = &inline_op },
+	{ "__inline__",	NS_TYPEDEF, .op = &inline_op },
 
 	/* Ignored for now.. */
-	{ "restrict",	NS_TYPEDEF, .op = &qualifier_op},
-	{ "__restrict",	NS_TYPEDEF, .op = &qualifier_op},
+	{ "restrict",	NS_TYPEDEF, .op = &restrict_op},
+	{ "__restrict",	NS_TYPEDEF, .op = &restrict_op},
 
 	/* Storage class */
-	{ "auto",	NS_TYPEDEF, MOD_AUTO, .op = &modifier_op },
-	{ "register",	NS_TYPEDEF, MOD_REGISTER, .op = &modifier_op },
-	{ "static",	NS_TYPEDEF, MOD_STATIC, .op = &modifier_op },
-	{ "extern",	NS_TYPEDEF, MOD_EXTERN, .op = &modifier_op },
+	{ "auto",	NS_TYPEDEF, .op = &auto_op },
+	{ "register",	NS_TYPEDEF, .op = &register_op },
+	{ "static",	NS_TYPEDEF, .op = &static_op },
+	{ "extern",	NS_TYPEDEF, .op = &extern_op },
 
 	/* Statement */
 	{ "if",		NS_KEYWORD, .op = &if_op },
@@ -566,7 +601,6 @@ static struct token *struct_union_enum_specifier(enum type type,
 	struct symbol *sym;
 	struct position *repos;
 
-	ctype->modifiers = 0;
 	token = handle_attributes(token, ctype, KW_ATTRIBUTE);
 	if (token_type(token) == TOKEN_IDENT) {
 		sym = lookup_symbol(token->ident, NS_STRUCT);
@@ -854,6 +888,8 @@ static struct token *enum_specifier(struct token *token, struct ctype *ctype)
 	return ret;
 }
 
+static void apply_ctype(struct position pos, struct ctype *thistype, struct ctype *ctype);
+
 static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
 {
 	struct symbol *sym;
@@ -864,12 +900,12 @@ static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
 	}
 	if (lookup_type(token->next)) {
 		token = typename(token->next, &sym, 0);
-		*ctype = sym->ctype;
+		ctype->base_type = sym->ctype.base_type;
+		apply_ctype(token->pos, &sym->ctype, ctype);
 	} else {
 		struct symbol *typeof_sym = alloc_symbol(token->pos, SYM_TYPEOF);
 		token = parse_expression(token->next, &typeof_sym->initializer);
 
-		ctype->modifiers = 0;
 		typeof_sym->endpos = token->pos;
 		ctype->base_type = typeof_sym;
 	}		
@@ -886,7 +922,8 @@ static struct token *ignore_attribute(struct token *token, struct symbol *attr,
 
 static struct token *attribute_packed(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
-	ctype->alignment = 1;
+	if (!ctype->alignment)
+		ctype->alignment = 1;
 	return token;
 }
 
@@ -900,23 +937,38 @@ static struct token *attribute_aligned(struct token *token, struct symbol *attr,
 		if (expr)
 			alignment = const_expression_value(expr);
 	}
-	ctype->alignment = alignment;
+	if (alignment & (alignment-1)) {
+		warning(token->pos, "I don't like non-power-of-2 alignments");
+		return token;
+	} else if (alignment > ctype->alignment)
+		ctype->alignment = alignment;
 	return token;
 }
 
+static void apply_qualifier(struct position *pos, struct ctype *ctx, unsigned long qual)
+{
+	if (ctx->modifiers & qual)
+		warning(*pos, "duplicate %s", modifier_string(qual));
+	ctx->modifiers |= qual;
+}
+
 static struct token *attribute_modifier(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
-	ctype->modifiers |= attr->ctype.modifiers;
+	apply_qualifier(&token->pos, ctype, attr->ctype.modifiers);
 	return token;
 }
 
 static struct token *attribute_address_space(struct token *token, struct symbol *attr, struct ctype *ctype)
 {
 	struct expression *expr = NULL;
+	int as;
 	token = expect(token, '(', "after address_space attribute");
 	token = conditional_expression(token, &expr);
-	if (expr)
-		ctype->as = const_expression_value(expr);
+	if (expr) {
+		as = const_expression_value(expr);
+		if (as)
+			ctype->as = as;
+	}
 	token = expect(token, ')', "after address_space attribute");
 	return token;
 }
@@ -1001,7 +1053,6 @@ static struct token *recover_unknown_attribute(struct token *token)
 
 static struct token *attribute_specifier(struct token *token, struct ctype *ctype)
 {
-	ctype->modifiers = 0;
 	token = expect(token, '(', "after attribute");
 	token = expect(token, '(', "after attribute");
 
@@ -1032,37 +1083,78 @@ static struct token *attribute_specifier(struct token *token, struct ctype *ctyp
 	return token;
 }
 
-static void apply_ctype(struct position pos, struct ctype *thistype, struct ctype *ctype)
+static void apply_modifier(struct position *pos, struct ctype *ctx, unsigned long modifier)
 {
-	unsigned long mod = thistype->modifiers;
+	if (!(ctx->modifiers & MOD_STORAGE & ~MOD_INLINE)) {
+		ctx->modifiers |= modifier;
+		return;
+	}
+	if (ctx->modifiers & modifier)
+		sparse_error(*pos, "duplicate %s", modifier_string(modifier));
+	else
+		sparse_error(*pos, "multiple storage classes");
+}
+
+static struct token *typedef_specifier(struct token *next, struct ctype *ctx)
+{
+	apply_modifier(&next->pos, ctx, MOD_TYPEDEF);
+	return next;
+}
 
-	if (mod) {
-		unsigned long old = ctype->modifiers;
-		unsigned long dup, conflict;
+static struct token *auto_specifier(struct token *next, struct ctype *ctx)
+{
+	apply_modifier(&next->pos, ctx, MOD_AUTO);
+	return next;
+}
 
-		dup = mod & old;
-		if (dup)
-			sparse_error(pos, "Just how %sdo you want this type to be?",
-				modifier_string(dup));
+static struct token *register_specifier(struct token *next, struct ctype *ctx)
+{
+	apply_modifier(&next->pos, ctx, MOD_REGISTER);
+	return next;
+}
 
-		// Only one storage modifier allowed, except that "inline" doesn't count.
-		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
-		conflict &= (conflict - 1);
-		if (conflict)
-			sparse_error(pos, "multiple storage classes");
+static struct token *static_specifier(struct token *next, struct ctype *ctx)
+{
+	apply_modifier(&next->pos, ctx, MOD_STATIC);
+	return next;
+}
 
-		ctype->modifiers = old | mod;
-	}
+static struct token *extern_specifier(struct token *next, struct ctype *ctx)
+{
+	apply_modifier(&next->pos, ctx, MOD_EXTERN);
+	return next;
+}
+
+static struct token *inline_specifier(struct token *next, struct ctype *ctx)
+{
+	ctx->modifiers |= MOD_INLINE;
+	return next;
+}
+
+static struct token *const_qualifier(struct token *next, struct ctype *ctx)
+{
+	apply_qualifier(&next->pos, ctx, MOD_CONST);
+	return next;
+}
+
+static struct token *volatile_qualifier(struct token *next, struct ctype *ctx)
+{
+	apply_qualifier(&next->pos, ctx, MOD_VOLATILE);
+	return next;
+}
+
+static void apply_ctype(struct position pos, struct ctype *thistype, struct ctype *ctype)
+{
+	unsigned long mod = thistype->modifiers;
+
+	if (mod)
+		apply_qualifier(&pos, ctype, mod);
 
 	/* Context */
 	concat_ptr_list((struct ptr_list *)thistype->contexts,
 	                (struct ptr_list **)&ctype->contexts);
 
 	/* Alignment */
-	if (thistype->alignment & (thistype->alignment-1)) {
-		warning(pos, "I don't like non-power-of-2 alignments");
-		thistype->alignment = 0;
-	}
 	if (thistype->alignment > ctype->alignment)
 		ctype->alignment = thistype->alignment;
 
@@ -1138,9 +1230,8 @@ static struct token *declaration_specifiers(struct token *next, struct decl_stat
 	int size = 0;
 
 	while ( (token = next) != NULL ) {
-		struct ctype thistype;
 		struct ident *ident;
-		struct symbol *s, *type;
+		struct symbol *s;
 
 		next = token->next;
 		if (token_type(token) != TOKEN_IDENT)
@@ -1187,13 +1278,12 @@ static struct token *declaration_specifiers(struct token *next, struct decl_stat
 				seen |= Set_Vlong;
 			}
 		}
-		thistype = s->ctype;
 		if (s->op->declarator)
-			next = s->op->declarator(next, &thistype);
-		type = thistype.base_type;
-		if (type)
-			ctx->ctype.base_type = type;
-		apply_ctype(token->pos, &thistype, &ctx->ctype);
+			next = s->op->declarator(next, &ctx->ctype);
+		if (s->op->type & KW_EXACT) {
+			ctx->ctype.base_type = s->ctype.base_type;
+			ctx->ctype.modifiers |= s->ctype.modifiers;
+		}
 	}
 	if (qual)
 		return token;
@@ -1290,7 +1380,6 @@ static struct token *handle_attributes(struct token *token, struct ctype *ctype,
 {
 	struct symbol *keyword;
 	for (;;) {
-		struct ctype thistype = { 0, };
 		if (token_type(token) != TOKEN_IDENT)
 			break;
 		keyword = lookup_keyword(token->ident, NS_KEYWORD | NS_TYPEDEF);
@@ -1298,8 +1387,7 @@ static struct token *handle_attributes(struct token *token, struct ctype *ctype,
 			break;
 		if (!(keyword->op->type & keywords))
 			break;
-		token = keyword->op->declarator(token->next, &thistype);
-		apply_ctype(token->pos, &thistype, ctype);
+		token = keyword->op->declarator(token->next, ctype);
 		keywords &= KW_ATTRIBUTE;
 	}
 	return token;
diff --git a/symbol.h b/symbol.h
index f82f51d..07da99c 100644
--- a/symbol.h
+++ b/symbol.h
@@ -69,6 +69,7 @@ enum keyword {
 	KW_MODE		= 1 << 6,
 	KW_SHORT	= 1 << 7,
 	KW_LONG		= 1 << 8,
+	KW_EXACT	= 1 << 9,
 };
 
 struct context {
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 16/18] Pass decl_state down to ->declarator() and handle_attributes() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 16/18] Pass decl_state down to ->declarator() and handle_attributes()
Date: Mon, 09 Mar 2009 07:12:48 +0000
Message-ID: <E1LgZfM-0000z3-2t () ZenIV ! linux ! org ! uk>
--------------------

Other than for attributes of labels (completely ignored, and we can
simply use skip_attributes() there), all callers of handle_attributes
actually get ctype == &ctx->ctype for some ctx.  Ditto for ->declarator().
Switch both to passing ctx instead (has to be done at the same time,
since we have handle_attributes() called from ->declarator() for struct).

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c  |   96 +++++++++++++++++++++++++++++++-------------------------------
 symbol.h |    2 +-
 2 files changed, 49 insertions(+), 49 deletions(-)

diff --git a/parse.c b/parse.c
index 9adba58..6976070 100644
--- a/parse.c
+++ b/parse.c
@@ -33,9 +33,9 @@ struct symbol_list *function_computed_target_list;
 struct statement_list *function_computed_goto_list;
 
 static struct token *statement(struct token *token, struct statement **tree);
-static struct token *handle_attributes(struct token *token, struct ctype *ctype, unsigned int keywords);
+static struct token *handle_attributes(struct token *token, struct decl_state *ctx, unsigned int keywords);
 
-typedef struct token *declarator_t(struct token *, struct ctype *);
+typedef struct token *declarator_t(struct token *, struct decl_state *);
 static declarator_t
 	struct_specifier, union_specifier, enum_specifier,
 	attribute_specifier, typeof_specifier, parse_asm_declarator,
@@ -595,13 +595,13 @@ struct symbol *label_symbol(struct token *token)
 }
 
 static struct token *struct_union_enum_specifier(enum type type,
-	struct token *token, struct ctype *ctype,
+	struct token *token, struct decl_state *ctx,
 	struct token *(*parse)(struct token *, struct symbol *))
 {
 	struct symbol *sym;
 	struct position *repos;
 
-	token = handle_attributes(token, ctype, KW_ATTRIBUTE);
+	token = handle_attributes(token, ctx, KW_ATTRIBUTE);
 	if (token_type(token) == TOKEN_IDENT) {
 		sym = lookup_symbol(token->ident, NS_STRUCT);
 		if (!sym ||
@@ -614,7 +614,7 @@ static struct token *struct_union_enum_specifier(enum type type,
 		}
 		if (sym->type != type)
 			error_die(token->pos, "invalid tag applied to %s", show_typename (sym));
-		ctype->base_type = sym;
+		ctx->ctype.base_type = sym;
 		repos = &token->pos;
 		token = token->next;
 		if (match_op(token, '{')) {
@@ -637,13 +637,13 @@ static struct token *struct_union_enum_specifier(enum type type,
 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
 		sparse_error(token->pos, "expected declaration");
-		ctype->base_type = &bad_ctype;
+		ctx->ctype.base_type = &bad_ctype;
 		return token;
 	}
 
 	sym = alloc_symbol(token->pos, type);
 	token = parse(token->next, sym);
-	ctype->base_type = sym;
+	ctx->ctype.base_type = sym;
 	token =  expect(token, '}', "at end of specifier");
 	sym->endpos = token->pos;
 
@@ -673,14 +673,14 @@ static struct token *parse_union_declaration(struct token *token, struct symbol
 	return struct_declaration_list(token, &sym->symbol_list);
 }
 
-static struct token *struct_specifier(struct token *token, struct ctype *ctype)
+static struct token *struct_specifier(struct token *token, struct decl_state *ctx)
 {
-	return struct_union_enum_specifier(SYM_STRUCT, token, ctype, parse_struct_declaration);
+	return struct_union_enum_specifier(SYM_STRUCT, token, ctx, parse_struct_declaration);
 }
 
-static struct token *union_specifier(struct token *token, struct ctype *ctype)
+static struct token *union_specifier(struct token *token, struct decl_state *ctx)
 {
-	return struct_union_enum_specifier(SYM_UNION, token, ctype, parse_union_declaration);
+	return struct_union_enum_specifier(SYM_UNION, token, ctx, parse_union_declaration);
 }
 
 
@@ -877,11 +877,11 @@ static struct token *parse_enum_declaration(struct token *token, struct symbol *
 	return token;
 }
 
-static struct token *enum_specifier(struct token *token, struct ctype *ctype)
+static struct token *enum_specifier(struct token *token, struct decl_state *ctx)
 {
-	struct token *ret = struct_union_enum_specifier(SYM_ENUM, token, ctype, parse_enum_declaration);
+	struct token *ret = struct_union_enum_specifier(SYM_ENUM, token, ctx, parse_enum_declaration);
+	struct ctype *ctype = &ctx->ctype.base_type->ctype;
 
-	ctype = &ctype->base_type->ctype;
 	if (!ctype->base_type)
 		ctype->base_type = &incomplete_ctype;
 
@@ -890,7 +890,7 @@ static struct token *enum_specifier(struct token *token, struct ctype *ctype)
 
 static void apply_ctype(struct position pos, struct ctype *thistype, struct ctype *ctype);
 
-static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
+static struct token *typeof_specifier(struct token *token, struct decl_state *ctx)
 {
 	struct symbol *sym;
 
@@ -900,14 +900,14 @@ static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
 	}
 	if (lookup_type(token->next)) {
 		token = typename(token->next, &sym, 0);
-		ctype->base_type = sym->ctype.base_type;
-		apply_ctype(token->pos, &sym->ctype, ctype);
+		ctx->ctype.base_type = sym->ctype.base_type;
+		apply_ctype(token->pos, &sym->ctype, &ctx->ctype);
 	} else {
 		struct symbol *typeof_sym = alloc_symbol(token->pos, SYM_TYPEOF);
 		token = parse_expression(token->next, &typeof_sym->initializer);
 
 		typeof_sym->endpos = token->pos;
-		ctype->base_type = typeof_sym;
+		ctx->ctype.base_type = typeof_sym;
 	}		
 	return expect(token, ')', "after typeof");
 }
@@ -1051,7 +1051,7 @@ static struct token *recover_unknown_attribute(struct token *token)
 	return token;
 }
 
-static struct token *attribute_specifier(struct token *token, struct ctype *ctype)
+static struct token *attribute_specifier(struct token *token, struct decl_state *ctx)
 {
 	token = expect(token, '(', "after attribute");
 	token = expect(token, '(', "after attribute");
@@ -1069,7 +1069,7 @@ static struct token *attribute_specifier(struct token *token, struct ctype *ctyp
 		attribute_name = token->ident;
 		attr = lookup_keyword(attribute_name, NS_KEYWORD);
 		if (attr && attr->op->attribute)
-			token = attr->op->attribute(token->next, attr, ctype);
+			token = attr->op->attribute(token->next, attr, &ctx->ctype);
 		else
 			token = recover_unknown_attribute(token);
 
@@ -1095,51 +1095,51 @@ static void apply_modifier(struct position *pos, struct ctype *ctx, unsigned lon
 		sparse_error(*pos, "multiple storage classes");
 }
 
-static struct token *typedef_specifier(struct token *next, struct ctype *ctx)
+static struct token *typedef_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, ctx, MOD_TYPEDEF);
+	apply_modifier(&next->pos, &ctx->ctype, MOD_TYPEDEF);
 	return next;
 }
 
-static struct token *auto_specifier(struct token *next, struct ctype *ctx)
+static struct token *auto_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, ctx, MOD_AUTO);
+	apply_modifier(&next->pos, &ctx->ctype, MOD_AUTO);
 	return next;
 }
 
-static struct token *register_specifier(struct token *next, struct ctype *ctx)
+static struct token *register_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, ctx, MOD_REGISTER);
+	apply_modifier(&next->pos, &ctx->ctype, MOD_REGISTER);
 	return next;
 }
 
-static struct token *static_specifier(struct token *next, struct ctype *ctx)
+static struct token *static_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, ctx, MOD_STATIC);
+	apply_modifier(&next->pos, &ctx->ctype, MOD_STATIC);
 	return next;
 }
 
-static struct token *extern_specifier(struct token *next, struct ctype *ctx)
+static struct token *extern_specifier(struct token *next, struct decl_state *ctx)
 {
-	apply_modifier(&next->pos, ctx, MOD_EXTERN);
+	apply_modifier(&next->pos, &ctx->ctype, MOD_EXTERN);
 	return next;
 }
 
-static struct token *inline_specifier(struct token *next, struct ctype *ctx)
+static struct token *inline_specifier(struct token *next, struct decl_state *ctx)
 {
-	ctx->modifiers |= MOD_INLINE;
+	ctx->ctype.modifiers |= MOD_INLINE;
 	return next;
 }
 
-static struct token *const_qualifier(struct token *next, struct ctype *ctx)
+static struct token *const_qualifier(struct token *next, struct decl_state *ctx)
 {
-	apply_qualifier(&next->pos, ctx, MOD_CONST);
+	apply_qualifier(&next->pos, &ctx->ctype, MOD_CONST);
 	return next;
 }
 
-static struct token *volatile_qualifier(struct token *next, struct ctype *ctx)
+static struct token *volatile_qualifier(struct token *next, struct decl_state *ctx)
 {
-	apply_qualifier(&next->pos, ctx, MOD_VOLATILE);
+	apply_qualifier(&next->pos, &ctx->ctype, MOD_VOLATILE);
 	return next;
 }
 
@@ -1233,7 +1233,7 @@ static struct token *handle_qualifiers(struct token *t, struct decl_state *ctx)
 			break;
 		t = t->next;
 		if (s->op->declarator)
-			t = s->op->declarator(t, &ctx->ctype);
+			t = s->op->declarator(t, ctx);
 	}
 	return t;
 }
@@ -1280,7 +1280,7 @@ static struct token *declaration_specifiers(struct token *token, struct decl_sta
 		}
 		token = token->next;
 		if (s->op->declarator)
-			token = s->op->declarator(token, &ctx->ctype);
+			token = s->op->declarator(token, ctx);
 		if (s->op->type & KW_EXACT) {
 			ctx->ctype.base_type = s->ctype.base_type;
 			ctx->ctype.modifiers |= s->ctype.modifiers;
@@ -1375,7 +1375,7 @@ static struct token *skip_attributes(struct token *token)
 	return token;
 }
 
-static struct token *handle_attributes(struct token *token, struct ctype *ctype, unsigned int keywords)
+static struct token *handle_attributes(struct token *token, struct decl_state *ctx, unsigned int keywords)
 {
 	struct symbol *keyword;
 	for (;;) {
@@ -1386,7 +1386,7 @@ static struct token *handle_attributes(struct token *token, struct ctype *ctype,
 			break;
 		if (!(keyword->op->type & keywords))
 			break;
-		token = keyword->op->declarator(token->next, ctype);
+		token = keyword->op->declarator(token->next, ctx);
 		keywords &= KW_ATTRIBUTE;
 	}
 	return token;
@@ -1473,7 +1473,7 @@ static struct token *direct_declarator(struct token *token, struct decl_state *c
 	    is_nested(token, &next, ctx->prefer_abstract)) {
 		struct symbol *base_type = ctype->base_type;
 		if (token->next != next)
-			next = handle_attributes(token->next, ctype,
+			next = handle_attributes(token->next, ctx,
 						  KW_ATTRIBUTE);
 		token = declarator(next, ctx);
 		token = expect(token, ')', "in nested declarator");
@@ -1606,7 +1606,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 		if (match_op(token, ':'))
 			token = handle_bitfield(token, &ctx);
 
-		token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE);
+		token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
 		apply_modifiers(token->pos, &ctx.ctype);
 
 		decl->ctype = ctx.ctype;
@@ -1641,7 +1641,7 @@ static struct token *parameter_declaration(struct token *token, struct symbol *s
 	token = declaration_specifiers(token, &ctx);
 	ctx.ident = &sym->ident;
 	token = declarator(token, &ctx);
-	token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE);
+	token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
 	apply_modifiers(token->pos, &ctx.ctype);
 	sym->ctype = ctx.ctype;
 	sym->endpos = token->pos;
@@ -1726,7 +1726,7 @@ static struct token *parse_asm_statement(struct token *token, struct statement *
 	return expect(token, ';', "at end of asm-statement");
 }
 
-static struct token *parse_asm_declarator(struct token *token, struct ctype *ctype)
+static struct token *parse_asm_declarator(struct token *token, struct decl_state *ctx)
 {
 	struct expression *expr;
 	token = expect(token, '(', "after asm");
@@ -2054,7 +2054,7 @@ static struct token *statement(struct token *token, struct statement **tree)
 		if (match_op(token->next, ':')) {
 			stmt->type = STMT_LABEL;
 			stmt->label_identifier = label_symbol(token);
-			token = handle_attributes(token->next->next, &stmt->label_identifier->ctype, KW_ATTRIBUTE);
+			token = skip_attributes(token->next->next);
 			return statement(token, &stmt->label_statement);
 		}
 	}
@@ -2440,7 +2440,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 
 	saved = ctx.ctype;
 	token = declarator(token, &ctx);
-	token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE | KW_ASM);
+	token = handle_attributes(token, &ctx, KW_ATTRIBUTE | KW_ASM);
 	apply_modifiers(token->pos, &ctx.ctype);
 
 	decl->ctype = ctx.ctype;
@@ -2514,9 +2514,9 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 		ident = NULL;
 		decl = alloc_symbol(token->pos, SYM_NODE);
 		ctx.ctype = saved;
-		token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE);
+		token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
 		token = declarator(token, &ctx);
-		token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE | KW_ASM);
+		token = handle_attributes(token, &ctx, KW_ATTRIBUTE | KW_ASM);
 		apply_modifiers(token->pos, &ctx.ctype);
 		decl->ctype = ctx.ctype;
 		decl->endpos = token->pos;
diff --git a/symbol.h b/symbol.h
index 07da99c..fd75631 100644
--- a/symbol.h
+++ b/symbol.h
@@ -102,7 +102,7 @@ struct symbol_op {
 	int (*args)(struct expression *);
 
 	/* keywords */
-	struct token *(*declarator)(struct token *token, struct ctype *ctype);
+	struct token *(*declarator)(struct token *token, struct decl_state *ctx);
 	struct token *(*statement)(struct token *token, struct statement *stmt);
 	struct token *(*toplevel)(struct token *token, struct symbol_list **list);
 	struct token *(*attribute)(struct token *token, struct symbol *attr, struct ctype *ctype);
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 18/18] Restore __attribute__((mode)) handling ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 18/18] Restore __attribute__((mode)) handling
Date: Mon, 09 Mar 2009 07:13:08 +0000
Message-ID: <E1LgZfg-000100-3K () ZenIV ! linux ! org ! uk>
--------------------

... at least to the extent we used to do it.  It still does _not_
cover the perversions gcc can do with that, but at least it deals
with regressions.  Full solution will have to wait for full-blown
imitation of what gcc people call __attribute__ semantics, the
bastards...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                         |  118 ++++++++++++++++++++++++++++++++-------
 symbol.h                        |    4 +-
 validation/nested-declarator2.c |    1 +
 3 files changed, 101 insertions(+), 22 deletions(-)

diff --git a/parse.c b/parse.c
index 8fa9ac1..bffb690 100644
--- a/parse.c
+++ b/parse.c
@@ -67,6 +67,11 @@ static attr_t
 	attribute_transparent_union, ignore_attribute,
 	attribute_mode;
 
+typedef struct symbol *to_mode_t(struct symbol *);
+
+static to_mode_t
+	to_QI_mode, to_HI_mode, to_SI_mode, to_DI_mode, to_word_mode;
+
 enum {
 	Set_T = 1,
 	Set_S = 2,
@@ -309,8 +314,29 @@ static struct symbol_op ignore_attr_op = {
 	.attribute = ignore_attribute,
 };
 
-static struct symbol_op mode_spec_op = {
+static struct symbol_op mode_QI_op = {
+	.type = KW_MODE,
+	.to_mode = to_QI_mode
+};
+
+static struct symbol_op mode_HI_op = {
 	.type = KW_MODE,
+	.to_mode = to_HI_mode
+};
+
+static struct symbol_op mode_SI_op = {
+	.type = KW_MODE,
+	.to_mode = to_SI_mode
+};
+
+static struct symbol_op mode_DI_op = {
+	.type = KW_MODE,
+	.to_mode = to_DI_mode
+};
+
+static struct symbol_op mode_word_op = {
+	.type = KW_MODE,
+	.to_mode = to_word_mode
 };
 
 static struct init_keyword {
@@ -411,16 +437,16 @@ static struct init_keyword {
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
-	{ "QI",		NS_KEYWORD,	MOD_CHAR,	.op = &mode_spec_op },
-	{ "__QI__",	NS_KEYWORD,	MOD_CHAR,	.op = &mode_spec_op },
-	{ "HI",		NS_KEYWORD,	MOD_SHORT,	.op = &mode_spec_op },
-	{ "__HI__",	NS_KEYWORD,	MOD_SHORT,	.op = &mode_spec_op },
-	{ "SI",		NS_KEYWORD,			.op = &mode_spec_op },
-	{ "__SI__",	NS_KEYWORD,			.op = &mode_spec_op },
-	{ "DI",		NS_KEYWORD,	MOD_LONGLONG,	.op = &mode_spec_op },
-	{ "__DI__",	NS_KEYWORD,	MOD_LONGLONG,	.op = &mode_spec_op },
-	{ "word",	NS_KEYWORD,	MOD_LONG,	.op = &mode_spec_op },
-	{ "__word__",	NS_KEYWORD,	MOD_LONG,	.op = &mode_spec_op },
+	{ "QI",		NS_KEYWORD,	MOD_CHAR,	.op = &mode_QI_op },
+	{ "__QI__",	NS_KEYWORD,	MOD_CHAR,	.op = &mode_QI_op },
+	{ "HI",		NS_KEYWORD,	MOD_SHORT,	.op = &mode_HI_op },
+	{ "__HI__",	NS_KEYWORD,	MOD_SHORT,	.op = &mode_HI_op },
+	{ "SI",		NS_KEYWORD,			.op = &mode_SI_op },
+	{ "__SI__",	NS_KEYWORD,			.op = &mode_SI_op },
+	{ "DI",		NS_KEYWORD,	MOD_LONGLONG,	.op = &mode_DI_op },
+	{ "__DI__",	NS_KEYWORD,	MOD_LONGLONG,	.op = &mode_DI_op },
+	{ "word",	NS_KEYWORD,	MOD_LONG,	.op = &mode_word_op },
+	{ "__word__",	NS_KEYWORD,	MOD_LONG,	.op = &mode_word_op },
 
 	/* Ignored attributes */
 	{ "nothrow",	NS_KEYWORD,	.op = &ignore_attr_op },
@@ -542,10 +568,18 @@ struct statement *alloc_statement(struct position pos, int type)
 
 static struct token *struct_declaration_list(struct token *token, struct symbol_list **list);
 
-static int apply_modifiers(struct position pos, struct ctype *ctype)
+static void apply_modifiers(struct position pos, struct decl_state *ctx)
 {
-	/* not removing it; application of delayed attributes will be here */
-	return 0;
+	struct symbol *ctype;
+	if (!ctx->mode)
+		return;
+	ctype = ctx->mode->to_mode(ctx->ctype.base_type);
+	if (!ctype)
+		sparse_error(pos, "don't know how to apply mode to %s",
+				show_typename(ctx->ctype.base_type));
+	else
+		ctx->ctype.base_type = ctype;
+	
 }
 
 static struct symbol * alloc_indirect_symbol(struct position pos, struct ctype *ctype, int type)
@@ -974,13 +1008,55 @@ static struct token *attribute_address_space(struct token *token, struct symbol
 	return token;
 }
 
+static struct symbol *to_QI_mode(struct symbol *ctype)
+{
+	if (ctype->ctype.base_type != &int_type)
+		return NULL;
+	if (ctype == &char_ctype)
+		return ctype;
+	return ctype->ctype.modifiers & MOD_UNSIGNED ? &uchar_ctype
+						     : &schar_ctype;
+}
+
+static struct symbol *to_HI_mode(struct symbol *ctype)
+{
+	if (ctype->ctype.base_type != &int_type)
+		return NULL;
+	return ctype->ctype.modifiers & MOD_UNSIGNED ? &ushort_ctype
+						     : &sshort_ctype;
+}
+
+static struct symbol *to_SI_mode(struct symbol *ctype)
+{
+	if (ctype->ctype.base_type != &int_type)
+		return NULL;
+	return ctype->ctype.modifiers & MOD_UNSIGNED ? &uint_ctype
+						     : &sint_ctype;
+}
+
+static struct symbol *to_DI_mode(struct symbol *ctype)
+{
+	if (ctype->ctype.base_type != &int_type)
+		return NULL;
+	return ctype->ctype.modifiers & MOD_UNSIGNED ? &ullong_ctype
+						     : &sllong_ctype;
+}
+
+static struct symbol *to_word_mode(struct symbol *ctype)
+{
+	if (ctype->ctype.base_type != &int_type)
+		return NULL;
+	return ctype->ctype.modifiers & MOD_UNSIGNED ? &ulong_ctype
+						     : &slong_ctype;
+}
+
 static struct token *attribute_mode(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	token = expect(token, '(', "after mode attribute");
 	if (token_type(token) == TOKEN_IDENT) {
 		struct symbol *mode = lookup_keyword(token->ident, NS_KEYWORD);
 		if (mode && mode->op->type == KW_MODE)
-			ctx->ctype.modifiers |= mode->ctype.modifiers;
+			ctx->mode = mode->op;
 		else
 			sparse_error(token->pos, "unknown mode attribute %s\n", show_ident(token->ident));
 		token = token->next;
@@ -1608,7 +1684,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 			token = handle_bitfield(token, &ctx);
 
 		token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
-		apply_modifiers(token->pos, &ctx.ctype);
+		apply_modifiers(token->pos, &ctx);
 
 		decl->ctype = ctx.ctype;
 		decl->endpos = token->pos;
@@ -1643,7 +1719,7 @@ static struct token *parameter_declaration(struct token *token, struct symbol *s
 	ctx.ident = &sym->ident;
 	token = declarator(token, &ctx);
 	token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
-	apply_modifiers(token->pos, &ctx.ctype);
+	apply_modifiers(token->pos, &ctx);
 	sym->ctype = ctx.ctype;
 	sym->endpos = token->pos;
 	return token;
@@ -1656,7 +1732,7 @@ struct token *typename(struct token *token, struct symbol **p, int mod)
 	*p = sym;
 	token = declaration_specifiers(token, &ctx);
 	token = declarator(token, &ctx);
-	apply_modifiers(token->pos, &ctx.ctype);
+	apply_modifiers(token->pos, &ctx);
 	if (ctx.ctype.modifiers & MOD_STORAGE & ~mod)
 		warning(sym->pos, "storage class in typename (%s)",
 			show_typename(sym));
@@ -2435,14 +2511,14 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	decl = alloc_symbol(token->pos, SYM_NODE);
 	/* Just a type declaration? */
 	if (match_op(token, ';')) {
-		apply_modifiers(token->pos, &ctx.ctype);
+		apply_modifiers(token->pos, &ctx);
 		return token->next;
 	}
 
 	saved = ctx.ctype;
 	token = declarator(token, &ctx);
 	token = handle_attributes(token, &ctx, KW_ATTRIBUTE | KW_ASM);
-	apply_modifiers(token->pos, &ctx.ctype);
+	apply_modifiers(token->pos, &ctx);
 
 	decl->ctype = ctx.ctype;
 	decl->endpos = token->pos;
@@ -2518,7 +2594,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 		token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
 		token = declarator(token, &ctx);
 		token = handle_attributes(token, &ctx, KW_ATTRIBUTE | KW_ASM);
-		apply_modifiers(token->pos, &ctx.ctype);
+		apply_modifiers(token->pos, &ctx);
 		decl->ctype = ctx.ctype;
 		decl->endpos = token->pos;
 		if (!ident) {
diff --git a/symbol.h b/symbol.h
index b74ab0c..f9944bf 100644
--- a/symbol.h
+++ b/symbol.h
@@ -91,8 +91,9 @@ struct ctype {
 
 struct decl_state {
 	struct ctype ctype;
-	int prefer_abstract;
 	struct ident **ident;
+	int prefer_abstract;
+	struct symbol_op *mode;
 };
 
 struct symbol_op {
@@ -106,6 +107,7 @@ struct symbol_op {
 	struct token *(*statement)(struct token *token, struct statement *stmt);
 	struct token *(*toplevel)(struct token *token, struct symbol_list **list);
 	struct token *(*attribute)(struct token *token, struct symbol *attr, struct decl_state *ctx);
+	struct symbol *(*to_mode)(struct symbol *);
 
 	int test, set, class;
 };
diff --git a/validation/nested-declarator2.c b/validation/nested-declarator2.c
index cd22853..345a04b 100644
--- a/validation/nested-declarator2.c
+++ b/validation/nested-declarator2.c
@@ -32,6 +32,7 @@ nested-declarator2.c:17:1: warning: non-ANSI definition of function 'w1'
 nested-declarator2.c:21:21: warning: non-ANSI function declaration of function '<noident>'
 nested-declarator2.c:22:16: warning: variadic functions must have one named argument
 nested-declarator2.c:24:21: warning: identifier list not in definition
+nested-declarator2.c:25:45: error: don't know how to apply mode to incomplete type
 nested-declarator2.c:26:13: error: Expected ) in nested declarator
 nested-declarator2.c:26:13: error: got -
 nested-declarator2.c:27:16: error: Expected ; at the end of type declaration
-- 
1.5.6.5

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] Define __LP64__ for x86_64 unless in 32 bit mode ===

From: Blue Swirl <blauwirbel () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] Define __LP64__ for x86_64 unless in 32 bit mode
Date: Wed, 05 Aug 2009 18:51:53 +0000
Message-ID: <f43fc5580908051151o2d3281acpfc1eabe81d93b6c2 () mail ! gmail ! com>
--------------------
Signed-off-by: Blue Swirl <blauwirbel@gmail.com>
---
 cgcc |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/cgcc b/cgcc
index 59de967..1ddbcb0 100755
--- a/cgcc
+++ b/cgcc
@@ -265,7 +265,7 @@ sub add_specs {
 		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
 		&define_size_t ("long unsigned int"));
     } elsif ($spec eq 'x86_64') {
-	return (' -Dx86_64=1 -D__x86_64=1 -D__x86_64__=1' .
+	return (' -Dx86_64=1 -D__x86_64=1 -D__x86_64__=1' . ($m32 ? '' : '
-D__LP64__=1') .
 		&integer_types (8, 16, 32, $m32 ? 32 : 64, 64, 128) .
 		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
 		&define_size_t ($m32 ? "unsigned int" : "long unsigned int"));
-- 
1.6.2.4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] Subject: Add a few GCC builtins ===

From: Blue Swirl <blauwirbel () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] Subject: Add a few GCC builtins
Date: Sat, 01 Aug 2009 09:28:50 +0000
Message-ID: <f43fc5580908010228k6760baa7j506fd674a0510307 () mail ! gmail ! com>
--------------------
Add c{l,t}z{,l,ll}, ffsl{,l}, popcountll and floating point comparison
builtins.

Signed-off-by: Blue Swirl <blauwirbel@gmail.com>
---
 lib.c |   25 ++++++++++++++++++++++---
 1 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index 42affcd..600939b 100644
--- a/lib.c
+++ b/lib.c
@@ -685,15 +685,26 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern char * __builtin_strpbrk(const char *, const
char *);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strlen(const char *);\n");

+	/* And bitwise operations.. */
+	add_pre_buffer("extern int __builtin_clz(int);\n");
+	add_pre_buffer("extern int __builtin_clzl(long);\n");
+	add_pre_buffer("extern int __builtin_clzll(long long);\n");
+	add_pre_buffer("extern int __builtin_ctz(int);\n");
+	add_pre_buffer("extern int __builtin_ctzl(long);\n");
+	add_pre_buffer("extern int __builtin_ctzll(long long);\n");
+	add_pre_buffer("extern int __builtin_ffs(int);\n");
+	add_pre_buffer("extern int __builtin_ffsl(long);\n");
+	add_pre_buffer("extern int __builtin_ffsll(long long);\n");
+	add_pre_buffer("extern int __builtin_popcount(unsigned int);\n");
+	add_pre_buffer("extern int __builtin_popcountl(unsigned long);\n");
+	add_pre_buffer("extern int __builtin_popcountll(unsigned long long);\n");
+
 	/* And some random ones.. */
 	add_pre_buffer("extern void *__builtin_return_address(unsigned int);\n");
 	add_pre_buffer("extern void *__builtin_extract_return_addr(void *);\n");
 	add_pre_buffer("extern void *__builtin_frame_address(unsigned int);\n");
 	add_pre_buffer("extern void __builtin_trap(void);\n");
-	add_pre_buffer("extern int __builtin_ffs(int);\n");
 	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
-	add_pre_buffer("extern int __builtin_popcount(unsigned int);\n");
-	add_pre_buffer("extern int __builtin_popcountl(unsigned long);\n");
 	add_pre_buffer("extern void __builtin_prefetch (const void *, ...);\n");
 	add_pre_buffer("extern long __builtin_alpha_extbl(long, long);\n");
 	add_pre_buffer("extern long __builtin_alpha_extwl(long, long);\n");
@@ -704,6 +715,14 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 	add_pre_buffer("extern long __builtin_labs(long);\n");

+	/* And some floating point stuff.. */
+	add_pre_buffer("extern int __builtin_isgreater(float, float);\n");
+	add_pre_buffer("extern int __builtin_isgreaterequal(float, float);\n");
+	add_pre_buffer("extern int __builtin_isless(float, float);\n");
+	add_pre_buffer("extern int __builtin_islessequal(float, float);\n");
+	add_pre_buffer("extern int __builtin_islessgreater(float, float);\n");
+	add_pre_buffer("extern int __builtin_isunordered(float, float);\n");
+
 	/* And some __FORTIFY_SOURCE ones.. */
 	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(void *, int);\n");
 	add_pre_buffer ("extern void * __builtin___memcpy_chk(void *, const
void *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
-- 
1.6.2.4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] Subject: Add a few GCC builtins
Date: Sat, 01 Aug 2009 16:53:09 +0000
Message-ID: <70318cbf0908010953n5ead2933g12b2213bf5901b83 () mail ! gmail ! com>
--------------------
On Sat, Aug 1, 2009 at 2:28 AM, Blue Swirl<blauwirbel@gmail.com> wrote:
> Add c{l,t}z{,l,ll}, ffsl{,l}, popcountll and floating point comparison
> builtins.

Your two patches looks good. But the patch itself is white space damaged.
Gmail does some strange thing to inlined patches.

Can you resend this patch using "attach a file"?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Blue Swirl <blauwirbel () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] Subject: Add a few GCC builtins
Date: Sat, 01 Aug 2009 17:23:12 +0000
Message-ID: <f43fc5580908011023m73ec63b5rbc09862aeb31f847 () mail ! gmail ! com>
--------------------
--000e0cd25b90c534b4047017cb8b
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit

On Sat, Aug 1, 2009 at 7:53 PM, Christopher Li<sparse@chrisli.org> wrote:
> On Sat, Aug 1, 2009 at 2:28 AM, Blue Swirl<blauwirbel@gmail.com> wrote:
>> Add c{l,t}z{,l,ll}, ffsl{,l}, popcountll and floating point comparison
>> builtins.
>
> Your two patches looks good. But the patch itself is white space damaged.
> Gmail does some strange thing to inlined patches.
>
> Can you resend this patch using "attach a file"?

Sure. I removed the extra "Subject:" from the description.

--000e0cd25b90c534b4047017cb8b
Content-Type: application/x-patch; name="0002-Add-a-few-GCC-builtins.patch"
Content-Disposition: attachment; 
	filename="0002-Add-a-few-GCC-builtins.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fxum2ut01

RnJvbSAxYjExYjRlOTNmY2VmNDQxMWMwMjhlNTA1YmJiM2M0MzgxNzk0ZDgxIE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBCbHVlIFN3aXJsIDxibGF1d2lyYmVsQGdtYWlsLmNvbT4KRGF0
ZTogU2F0LCAxIEF1ZyAyMDA5IDE3OjE5OjQ5ICswMDAwClN1YmplY3Q6IFtQQVRDSF0gQWRkIGEg
ZmV3IEdDQyBidWlsdGlucwoKQWRkIGN7bCx0fXp7LGwsbGx9LCBmZnNseyxsfSwgcG9wY291bnRs
bCBhbmQgZmxvYXRpbmcgcG9pbnQgY29tcGFyaXNvbgpidWlsdGlucy4KClNpZ25lZC1vZmYtYnk6
IEJsdWUgU3dpcmwgPGJsYXV3aXJiZWxAZ21haWwuY29tPgotLS0KIGxpYi5jIHwgICAyNSArKysr
KysrKysrKysrKysrKysrKysrLS0tCiAxIGZpbGVzIGNoYW5nZWQsIDIyIGluc2VydGlvbnMoKyks
IDMgZGVsZXRpb25zKC0pCgpkaWZmIC0tZ2l0IGEvbGliLmMgYi9saWIuYwppbmRleCA0MmFmZmNk
Li42MDA5MzliIDEwMDY0NAotLS0gYS9saWIuYworKysgYi9saWIuYwpAQCAtNjg1LDE1ICs2ODUs
MjYgQEAgdm9pZCBkZWNsYXJlX2J1aWx0aW5fZnVuY3Rpb25zKHZvaWQpCiAJYWRkX3ByZV9idWZm
ZXIoImV4dGVybiBjaGFyICogX19idWlsdGluX3N0cnBicmsoY29uc3QgY2hhciAqLCBjb25zdCBj
aGFyICopO1xuIik7CiAJYWRkX3ByZV9idWZmZXIoImV4dGVybiBfX1NJWkVfVFlQRV9fIF9fYnVp
bHRpbl9zdHJsZW4oY29uc3QgY2hhciAqKTtcbiIpOwogCisJLyogQW5kIGJpdHdpc2Ugb3BlcmF0
aW9ucy4uICovCisJYWRkX3ByZV9idWZmZXIoImV4dGVybiBpbnQgX19idWlsdGluX2NseihpbnQp
O1xuIik7CisJYWRkX3ByZV9idWZmZXIoImV4dGVybiBpbnQgX19idWlsdGluX2NsemwobG9uZyk7
XG4iKTsKKwlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIGludCBfX2J1aWx0aW5fY2x6bGwobG9uZyBs
b25nKTtcbiIpOworCWFkZF9wcmVfYnVmZmVyKCJleHRlcm4gaW50IF9fYnVpbHRpbl9jdHooaW50
KTtcbiIpOworCWFkZF9wcmVfYnVmZmVyKCJleHRlcm4gaW50IF9fYnVpbHRpbl9jdHpsKGxvbmcp
O1xuIik7CisJYWRkX3ByZV9idWZmZXIoImV4dGVybiBpbnQgX19idWlsdGluX2N0emxsKGxvbmcg
bG9uZyk7XG4iKTsKKwlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIGludCBfX2J1aWx0aW5fZmZzKGlu
dCk7XG4iKTsKKwlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIGludCBfX2J1aWx0aW5fZmZzbChsb25n
KTtcbiIpOworCWFkZF9wcmVfYnVmZmVyKCJleHRlcm4gaW50IF9fYnVpbHRpbl9mZnNsbChsb25n
IGxvbmcpO1xuIik7CisJYWRkX3ByZV9idWZmZXIoImV4dGVybiBpbnQgX19idWlsdGluX3BvcGNv
dW50KHVuc2lnbmVkIGludCk7XG4iKTsKKwlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIGludCBfX2J1
aWx0aW5fcG9wY291bnRsKHVuc2lnbmVkIGxvbmcpO1xuIik7CisJYWRkX3ByZV9idWZmZXIoImV4
dGVybiBpbnQgX19idWlsdGluX3BvcGNvdW50bGwodW5zaWduZWQgbG9uZyBsb25nKTtcbiIpOwor
CiAJLyogQW5kIHNvbWUgcmFuZG9tIG9uZXMuLiAqLwogCWFkZF9wcmVfYnVmZmVyKCJleHRlcm4g
dm9pZCAqX19idWlsdGluX3JldHVybl9hZGRyZXNzKHVuc2lnbmVkIGludCk7XG4iKTsKIAlhZGRf
cHJlX2J1ZmZlcigiZXh0ZXJuIHZvaWQgKl9fYnVpbHRpbl9leHRyYWN0X3JldHVybl9hZGRyKHZv
aWQgKik7XG4iKTsKIAlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIHZvaWQgKl9fYnVpbHRpbl9mcmFt
ZV9hZGRyZXNzKHVuc2lnbmVkIGludCk7XG4iKTsKIAlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIHZv
aWQgX19idWlsdGluX3RyYXAodm9pZCk7XG4iKTsKLQlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIGlu
dCBfX2J1aWx0aW5fZmZzKGludCk7XG4iKTsKIAlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIHZvaWQg
Kl9fYnVpbHRpbl9hbGxvY2EoX19TSVpFX1RZUEVfXyk7XG4iKTsKLQlhZGRfcHJlX2J1ZmZlcigi
ZXh0ZXJuIGludCBfX2J1aWx0aW5fcG9wY291bnQodW5zaWduZWQgaW50KTtcbiIpOwotCWFkZF9w
cmVfYnVmZmVyKCJleHRlcm4gaW50IF9fYnVpbHRpbl9wb3Bjb3VudGwodW5zaWduZWQgbG9uZyk7
XG4iKTsKIAlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIHZvaWQgX19idWlsdGluX3ByZWZldGNoIChj
b25zdCB2b2lkICosIC4uLik7XG4iKTsKIAlhZGRfcHJlX2J1ZmZlcigiZXh0ZXJuIGxvbmcgX19i
dWlsdGluX2FscGhhX2V4dGJsKGxvbmcsIGxvbmcpO1xuIik7CiAJYWRkX3ByZV9idWZmZXIoImV4
dGVybiBsb25nIF9fYnVpbHRpbl9hbHBoYV9leHR3bChsb25nLCBsb25nKTtcbiIpOwpAQCAtNzA0
LDYgKzcxNSwxNCBAQCB2b2lkIGRlY2xhcmVfYnVpbHRpbl9mdW5jdGlvbnModm9pZCkKIAlhZGRf
cHJlX2J1ZmZlcigiZXh0ZXJuIGxvbmcgX19idWlsdGluX2FscGhhX2NtcGJnZShsb25nLCBsb25n
KTtcbiIpOwogCWFkZF9wcmVfYnVmZmVyKCJleHRlcm4gbG9uZyBfX2J1aWx0aW5fbGFicyhsb25n
KTtcbiIpOwogCisJLyogQW5kIHNvbWUgZmxvYXRpbmcgcG9pbnQgc3R1ZmYuLiAqLworCWFkZF9w
cmVfYnVmZmVyKCJleHRlcm4gaW50IF9fYnVpbHRpbl9pc2dyZWF0ZXIoZmxvYXQsIGZsb2F0KTtc
biIpOworCWFkZF9wcmVfYnVmZmVyKCJleHRlcm4gaW50IF9fYnVpbHRpbl9pc2dyZWF0ZXJlcXVh
bChmbG9hdCwgZmxvYXQpO1xuIik7CisJYWRkX3ByZV9idWZmZXIoImV4dGVybiBpbnQgX19idWls
dGluX2lzbGVzcyhmbG9hdCwgZmxvYXQpO1xuIik7CisJYWRkX3ByZV9idWZmZXIoImV4dGVybiBp
bnQgX19idWlsdGluX2lzbGVzc2VxdWFsKGZsb2F0LCBmbG9hdCk7XG4iKTsKKwlhZGRfcHJlX2J1
ZmZlcigiZXh0ZXJuIGludCBfX2J1aWx0aW5faXNsZXNzZ3JlYXRlcihmbG9hdCwgZmxvYXQpO1xu
Iik7CisJYWRkX3ByZV9idWZmZXIoImV4dGVybiBpbnQgX19idWlsdGluX2lzdW5vcmRlcmVkKGZs
b2F0LCBmbG9hdCk7XG4iKTsKKwogCS8qIEFuZCBzb21lIF9fRk9SVElGWV9TT1VSQ0Ugb25lcy4u
ICovCiAJYWRkX3ByZV9idWZmZXIgKCJleHRlcm4gX19TSVpFX1RZUEVfXyBfX2J1aWx0aW5fb2Jq
ZWN0X3NpemUodm9pZCAqLCBpbnQpO1xuIik7CiAJYWRkX3ByZV9idWZmZXIgKCJleHRlcm4gdm9p
ZCAqIF9fYnVpbHRpbl9fX21lbWNweV9jaGsodm9pZCAqLCBjb25zdCB2b2lkICosIF9fU0laRV9U
WVBFX18sIF9fU0laRV9UWVBFX18pO1xuIik7Ci0tIAoxLjUuNi41Cgo=
--000e0cd25b90c534b4047017cb8b--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] Subject: Add a few GCC builtins
Date: Tue, 04 Aug 2009 21:35:06 +0000
Message-ID: <70318cbf0908041435j59c33f64uc6f79b018884c8b2 () mail ! gmail ! com>
--------------------
On Sat, Aug 1, 2009 at 10:23 AM, Blue Swirl<blauwirbel@gmail.com> wrote:
> Sure. I removed the extra "Subject:" from the description.

Thanks, all two patches applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] Replace SYM_ and MOD_ #defines with enums in ===

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/3] Replace SYM_ and MOD_ #defines with enums in
Date: Sun, 31 May 2009 16:03:04 +0000
Message-ID: <db65a1cd0905310903i4e33c29fv81ac4d214b7d1752 () mail ! gmail ! com>
--------------------
On Sun, May 31, 2009 at 11:44 AM, Samuel Bronson <naesten@gmail.com> wrote:
> Adjust the associated fields to match.

Dang it, I seem to have somehow forgotten to test after this step ... whoops!
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================


################################################################################

=== Thread: [PATCH 2/5] Fix some "enum value 'SYM_...' not handled in ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 2/5] Fix some "enum value 'SYM_...' not handled in
Date: Sun, 19 Jul 2009 14:01:26 +0000
Message-ID: <20090719140125.GA25417 () feather>
--------------------
On Sat, Jul 18, 2009 at 09:41:46PM +0100, Ramsay Jones wrote:
> These warnings were issued by gcc v3.4.4, but not by gcc v4.1.2.
> So I guess gcc probably found these warnings to be too noisy ...
[...]
> --- a/parse.c
> +++ b/parse.c
> @@ -2616,6 +2616,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>  			case SYM_ENUM:
>  			case SYM_RESTRICT:
>  				base_type->ident = ident;
> +			default:
> +				break;
>  			}

I don't think you want to add defaults like this just to avoid warnings.
Warnings like that can help when adding a new item to an enum, to find
the places where you need to extend the code to hand the new item.  And
since current GCC doesn't even issue the warning by default, it seems
even more unnecessary to add that default case.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 2/5] Fix some "enum value 'SYM_...' not handled in
Date: Thu, 23 Jul 2009 04:42:42 +0000
Message-ID: <20090723044241.GA6472 () feather>
--------------------
On Tue, Jul 21, 2009 at 10:15:49PM +0100, Ramsay Jones wrote:
> Josh Triplett wrote:
> > On Sat, Jul 18, 2009 at 09:41:46PM +0100, Ramsay Jones wrote:
> >> These warnings were issued by gcc v3.4.4, but not by gcc v4.1.2.
> >> So I guess gcc probably found these warnings to be too noisy ...
> > [...]
> >> --- a/parse.c
> >> +++ b/parse.c
> >> @@ -2616,6 +2616,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
> >>  			case SYM_ENUM:
> >>  			case SYM_RESTRICT:
> >>  				base_type->ident = ident;
> >> +			default:
> >> +				break;
> >>  			}
> > 
> > I don't think you want to add defaults like this just to avoid warnings.
> > Warnings like that can help when adding a new item to an enum, to find
> > the places where you need to extend the code to hand the new item.  And
> > since current GCC doesn't even issue the warning by default, it seems
> > even more unnecessary to add that default case.
> > 
> 
> OK...
> 
> So, if I understand your argument, in order to make the best use of these
> warnings, then the correct change would look like the diff given below,
> and (for more up-to-date gcc) add -Wswitch-enum to CFLAGS (at least
> occasionally).
[...]
> diff --git a/parse.c b/parse.c
> index e5ad867..afe39c3 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -2616,6 +2616,23 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>  			case SYM_ENUM:
>  			case SYM_RESTRICT:
>  				base_type->ident = ident;
> +				break;
> +			case SYM_UNINITIALIZED:
> +			case SYM_PREPROCESSOR:
> +			case SYM_BASETYPE:
> +			case SYM_NODE:
> +			case SYM_PTR:
> +			case SYM_FN:
> +			case SYM_ARRAY:
> +			case SYM_TYPEDEF:
> +			case SYM_TYPEOF:
> +			case SYM_MEMBER:
> +			case SYM_BITFIELD:
> +			case SYM_LABEL:
> +			case SYM_FOULED:
> +			case SYM_KEYWORD:
> +			case SYM_BAD:
> +				break;

This represents exactly why more recent GCC defaults this warning to
off. ;)

No, I don't think writing the code this way helps.  I think it makes
more sense to leave the warning off and not bother placating older
versions of GCC.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/5] Fix some "enum value 'SYM_...' not handled in switch" ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: [PATCH 2/5] Fix some "enum value 'SYM_...' not handled in switch"
Date: Sat, 18 Jul 2009 20:41:46 +0000
Message-ID: <4A62338A.1060600 () ramsay1 ! demon ! co ! uk>
--------------------

Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>
---

Hi Chris,

These warnings were issued by gcc v3.4.4, but not by gcc v4.1.2.
So I guess gcc probably found these warnings to be too noisy ...

ATB,
Ramsay Jones

 parse.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/parse.c b/parse.c
index e5ad867..42e8c74 100644
--- a/parse.c
+++ b/parse.c
@@ -2616,6 +2616,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			case SYM_ENUM:
 			case SYM_RESTRICT:
 				base_type->ident = ident;
+			default:
+				break;
 			}
 		}
 	} else if (base_type && base_type->type == SYM_FN) {
-- 
1.6.3.1


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 2/5] Fix some "enum value 'SYM_...' not handled in switch"
Date: Tue, 21 Jul 2009 21:15:49 +0000
Message-ID: <4A663005.5090009 () ramsay1 ! demon ! co ! uk>
--------------------
Josh Triplett wrote:
> On Sat, Jul 18, 2009 at 09:41:46PM +0100, Ramsay Jones wrote:
>> These warnings were issued by gcc v3.4.4, but not by gcc v4.1.2.
>> So I guess gcc probably found these warnings to be too noisy ...
> [...]
>> --- a/parse.c
>> +++ b/parse.c
>> @@ -2616,6 +2616,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>>  			case SYM_ENUM:
>>  			case SYM_RESTRICT:
>>  				base_type->ident = ident;
>> +			default:
>> +				break;
>>  			}
> 
> I don't think you want to add defaults like this just to avoid warnings.
> Warnings like that can help when adding a new item to an enum, to find
> the places where you need to extend the code to hand the new item.  And
> since current GCC doesn't even issue the warning by default, it seems
> even more unnecessary to add that default case.
> 

OK...

So, if I understand your argument, in order to make the best use of these
warnings, then the correct change would look like the diff given below,
and (for more up-to-date gcc) add -Wswitch-enum to CFLAGS (at least
occasionally).

Yes?

[if no, then I obviously don't understand ;-)]

Hmm, I have another idea; a new patch is brewing!

ATB,
Ramsay Jones

-->8--
diff --git a/parse.c b/parse.c
index e5ad867..afe39c3 100644
--- a/parse.c
+++ b/parse.c
@@ -2616,6 +2616,23 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			case SYM_ENUM:
 			case SYM_RESTRICT:
 				base_type->ident = ident;
+				break;
+			case SYM_UNINITIALIZED:
+			case SYM_PREPROCESSOR:
+			case SYM_BASETYPE:
+			case SYM_NODE:
+			case SYM_PTR:
+			case SYM_FN:
+			case SYM_ARRAY:
+			case SYM_TYPEDEF:
+			case SYM_TYPEOF:
+			case SYM_MEMBER:
+			case SYM_BITFIELD:
+			case SYM_LABEL:
+			case SYM_FOULED:
+			case SYM_KEYWORD:
+			case SYM_BAD:
+				break;
 			}
 		}
 	} else if (base_type && base_type->type == SYM_FN) {
-->8--



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/5] Fix some "enum value 'SYM_...' not handled in switch"
Date: Fri, 24 Jul 2009 20:13:04 +0000
Message-ID: <70318cbf0907241313hea92354me02cae1a8d460351 () mail ! gmail ! com>
--------------------
On Fri, Jul 24, 2009 at 11:25 AM, Ramsay
Jones<ramsay@ramsay1.demon.co.uk> wrote:
> Just FYI, I had planned to fix this by implementing a local makefile
> config file (like config.mak in git), so that I could fix this issue
> locally ("out of tree").
>
> However, I was (pleasantly) surprised to find that I'd been beaten to
> the punch by Samuel Bronson in commit 8d86d0e.
>
> So I tried this local.mk file:
>
>    OS=cygwin
>    CFLAGS+=-Wno-switch-enum
>
> This lead to the invocation of gcc I was hoping for; something like:
>
>    gcc ... -Wall ... -Wno-switch-enum parse.c

Yes, that works. I try the latest version of the cygwin. The gcc in
cygwin is still old enough to give the warning. I am going to leave it
as it is.

BTW, you can put some local build target in local.mk as well, not
just config changes.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/7] Separate parsing of identifier-list (in K&R-style declarations) ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 2/7] Separate parsing of identifier-list (in K&R-style declarations)
Date: Sat, 14 Feb 2009 12:25:15 +0000
Message-ID: <E1LYJa7-0001mV-KZ () ZenIV ! linux ! org ! uk>
--------------------

Don't mix it with parameter-type-list, add saner checks.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                      |   28 ++++++++++++++++++++++++++--
 validation/identifier_list.c |   18 ++++++++++++++++++
 2 files changed, 44 insertions(+), 2 deletions(-)
 create mode 100644 validation/identifier_list.c

diff --git a/parse.c b/parse.c
index 6100fc2..86e26aa 100644
--- a/parse.c
+++ b/parse.c
@@ -1948,12 +1948,36 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn,
 		return token;
 	}
 
+	if (match_op(token, SPECIAL_ELLIPSIS)) {
+		warning(token->pos, "variadic functions must have one named argument");
+		fn->variadic = 1;
+		return token->next;
+	}
+
+	if (token_type(token) != TOKEN_IDENT)
+		return token;
+
+	if (!lookup_type(token)) {
+		/* K&R */
+		for (;;) {
+			struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
+			sym->ident = token->ident;
+			token = token->next;
+			sym->endpos = token->pos;
+			add_symbol(list, sym);
+			if (!match_op(token, ',') ||
+			    token_type(token->next) != TOKEN_IDENT ||
+			    lookup_type(token->next))
+				break;
+			token = token->next;
+		}
+		return token;
+	}
+
 	for (;;) {
 		struct symbol *sym;
 
 		if (match_op(token, SPECIAL_ELLIPSIS)) {
-			if (!*list)
-				warning(token->pos, "variadic functions must have one named argument");
 			fn->variadic = 1;
 			token = token->next;
 			break;
diff --git a/validation/identifier_list.c b/validation/identifier_list.c
new file mode 100644
index 0000000..4691989
--- /dev/null
+++ b/validation/identifier_list.c
@@ -0,0 +1,18 @@
+typedef int T;
+void f(...);
+void g(*);
+void h(x,int);
+void i_OK(T);
+void j(x,T);
+/*
+ * check-name: identifier-list parsing
+ * check-error-start
+identifier_list.c:2:8: warning: variadic functions must have one named argument
+identifier_list.c:3:8: error: Expected ) in function declarator
+identifier_list.c:3:8: error: got *
+identifier_list.c:4:9: error: Expected ) in function declarator
+identifier_list.c:4:9: error: got ,
+identifier_list.c:6:9: error: Expected ) in function declarator
+identifier_list.c:6:9: error: got ,
+ * check-error-end
+ */
-- 
1.5.6.6


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] Whitespace tweaks in symbol.h ===

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] Whitespace tweaks in symbol.h
Date: Sun, 31 May 2009 15:44:12 +0000
Message-ID: <1243784652-31802-3-git-send-email-naesten () gmail ! com>
--------------------
Changes-licensed-under: ISC license
Signed-off-by: Samuel Bronson <naesten@gmail.com>
---
 symbol.h |   22 +++++++++++-----------
 1 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/symbol.h b/symbol.h
index 4a16f0d..3dd4531 100644
--- a/symbol.h
+++ b/symbol.h
@@ -24,16 +24,16 @@
  * declared.
  */
 enum namespace {
-	NS_NONE = 0,
-	NS_MACRO = 1,
-	NS_TYPEDEF = 2,
-	NS_STRUCT = 4,  // Also used for unions and enums.
-	NS_LABEL = 8,
-	NS_SYMBOL = 16,
-	NS_ITERATOR = 32,
-	NS_PREPROCESSOR = 64,
-	NS_UNDEF = 128,
-	NS_KEYWORD = 256,
+	NS_NONE		= 0,
+	NS_MACRO	= 1,
+	NS_TYPEDEF	= 2,
+	NS_STRUCT	= 4,  // Also used for unions and enums.
+	NS_LABEL	= 8,
+	NS_SYMBOL	= 16,
+	NS_ITERATOR	= 32,
+	NS_PREPROCESSOR	= 64,
+	NS_UNDEF	= 128,
+	NS_KEYWORD	= 256,
 };
 
 enum type {
@@ -59,7 +59,7 @@ enum type {
 };
 
 enum keyword {
-	KW_SPECIFIER 	= 1 << 0,
+	KW_SPECIFIER	= 1 << 0,
 	KW_MODIFIER	= 1 << 1,
 	KW_QUALIFIER	= 1 << 2,
 	KW_ATTRIBUTE	= 1 << 3,
-- 
1.6.3.1.169.g33fd.dirty

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================


################################################################################

=== Thread: [PATCH 3/5] Makefile: suppress error message from shell ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: [PATCH 3/5] Makefile: suppress error message from shell
Date: Sat, 18 Jul 2009 20:42:56 +0000
Message-ID: <4A6233D0.1060502 () ramsay1 ! demon ! co ! uk>
--------------------

In particular, on systems which do not have 'pkg-config' installed,
every invocation of make issues the following message:

    /bin/sh: pkg-config: command not found

Suppress the message by redirecting stderr to the bit-bucket.

Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>
---
 Makefile |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/Makefile b/Makefile
index 72f3686..70ccbc9 100644
--- a/Makefile
+++ b/Makefile
@@ -15,7 +15,7 @@ AR = ar
 #     CFLAGS += -O0 -DDEBUG -g3 -gdwarf-2
 #
 
-HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 && echo 'yes')
+HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 2>/dev/null && echo 'yes')
 HAVE_GCC_DEP=$(shell touch .gcc-test.c && 				\
 		$(CC) -c -Wp,-MD,.gcc-test.d .gcc-test.c 2>/dev/null && \
 		echo 'yes'; rm -f .gcc-test.d .gcc-test.o .gcc-test.c)
-- 
1.6.3.1


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 3/5] Makefile: suppress error message from shell
Date: Sun, 19 Jul 2009 14:03:17 +0000
Message-ID: <20090719140316.GB25417 () feather>
--------------------
On Sat, Jul 18, 2009 at 09:42:56PM +0100, Ramsay Jones wrote:
> In particular, on systems which do not have 'pkg-config' installed,
> every invocation of make issues the following message:
> 
>     /bin/sh: pkg-config: command not found
> 
> Suppress the message by redirecting stderr to the bit-bucket.
[...]
> --- a/Makefile
> +++ b/Makefile
> @@ -15,7 +15,7 @@ AR = ar
>  #     CFLAGS += -O0 -DDEBUG -g3 -gdwarf-2
>  #
>  
> -HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 && echo 'yes')
> +HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 2>/dev/null && echo 'yes')

Seems sensible; this way, systems without pkg-config will simply end up
without HAVE_LIBXML.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/5] Makefile: suppress error message from shell
Date: Mon, 20 Jul 2009 20:21:01 +0000
Message-ID: <70318cbf0907201321y26cba10h2d77d7ae02d86090 () mail ! gmail ! com>
--------------------
> On Sat, Jul 18, 2009 at 09:42:56PM +0100, Ramsay Jones wrote:
>> In particular, on systems which do not have 'pkg-config' installed,
>> every invocation of make issues the following message:
>>
>>     /bin/sh: pkg-config: command not found
>>
>> Suppress the message by redirecting stderr to the bit-bucket.

Applied.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/5] Makefile: suppress error message from shell
Date: Wed, 22 Jul 2009 00:35:46 +0000
Message-ID: <70318cbf0907211735t6e279f5ag5602abd54f94656f () mail ! gmail ! com>
--------------------
On Tue, Jul 21, 2009 at 2:50 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
> Hmm, I noticed that you edited the "subject line" when you applied
> the patch; namely s/shell/pkg-config/.
>
> I find this a little puzzling, since the error message *is* issued
> by the shell and is definitely *not* issued by pkg-config... which
> is kinda the point... ;-)
>
Oh, right. The error is issue from shell when it try to run pkg-config.
If I just read the title, it is hard for me to predict where the change
is going to be. I just want to be more specific.

There is a reason I haven't push those to official tree yet. We can
still change it if we want. Suggestion?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 3/5] Makefile: suppress error message from shell
Date: Fri, 24 Jul 2009 18:40:22 +0000
Message-ID: <4A6A0016.5030204 () ramsay1 ! demon ! co ! uk>
--------------------
Christopher Li wrote:
> On Tue, Jul 21, 2009 at 2:50 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
>> Hmm, I noticed that you edited the "subject line" when you applied
>> the patch; namely s/shell/pkg-config/.
>>
>> I find this a little puzzling, since the error message *is* issued
>> by the shell and is definitely *not* issued by pkg-config... which
>> is kinda the point... ;-)
>>
> Oh, right. The error is issue from shell when it try to run pkg-config.
> If I just read the title, it is hard for me to predict where the change
> is going to be. I just want to be more specific.
> 
> There is a reason I haven't push those to official tree yet. We can
> still change it if we want. Suggestion?

I liked the original myself. :)

The "Makefile:" prefix was intended to indicate where the change was
made and I thought that the one-line summary was compact and accurate.

It's a bit difficult to indicate that "the cause of the error, which
is issued by the shell, is a missing pkg-config command on some
systems" as part of the one-line summary. (So I didn't try ;P )

Having said that, I can't claim to be good at writing commit messages.
So, feel free to re-write it as you wish.

ATB,
Ramsay Jones


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/7] More nested declarator fixes ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 3/7] More nested declarator fixes
Date: Sat, 14 Feb 2009 12:25:25 +0000
Message-ID: <E1LYJaH-0001nA-Kl () ZenIV ! linux ! org ! uk>
--------------------

no nested declarators after [...] or (parameters)

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                        |    2 ++
 validation/nested-declarator.c |   16 ++++++++++++++++
 2 files changed, 18 insertions(+), 0 deletions(-)

diff --git a/parse.c b/parse.c
index 86e26aa..1678d80 100644
--- a/parse.c
+++ b/parse.c
@@ -1295,6 +1295,7 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
 			token = parameter_type_list(next, sym, p);
 			token = expect(token, ')', "in function declarator");
 			sym->endpos = token->pos;
+			dont_nest = 1;
 			continue;
 		}
 		if (token->special == '[') {
@@ -1303,6 +1304,7 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
 			token = expect(token, ']', "in abstract_array_declarator");
 			array->endpos = token->pos;
 			ctype = &array->ctype;
+			dont_nest = 1;
 			continue;
 		}
 		break;
diff --git a/validation/nested-declarator.c b/validation/nested-declarator.c
index 24ed833..1e69823 100644
--- a/validation/nested-declarator.c
+++ b/validation/nested-declarator.c
@@ -6,6 +6,22 @@ static void g(int x)
 	T = x;
 	f(T);
 }
+static void h(void)
+{
+	static int [2](T)[3];
+}
+static int [2](*p)[3];
+int i(void (void)(*f));
+int j(int [2](*));
 /*
  * check-name: nested declarator vs. parameters
+ * check-error-start:
+nested-declarator.c:11:22: warning: missing identifier in declaration
+nested-declarator.c:13:16: error: Expected ) in function declarator
+nested-declarator.c:13:16: error: got *
+nested-declarator.c:14:19: error: Expected ) in function declarator
+nested-declarator.c:14:19: error: got *
+nested-declarator.c:15:15: error: Expected ) in function declarator
+nested-declarator.c:15:15: error: got *
+ * check-error-end:
  */
-- 
1.5.6.6


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/18] Sanitize direct_declarator logics ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 4/18] Sanitize direct_declarator logics
Date: Mon, 09 Mar 2009 07:10:48 +0000
Message-ID: <E1LgZdQ-0000sV-0X () ZenIV ! linux ! org ! uk>
--------------------

a) handling of nested declarator does not belong in the loop, for fsck sake
b) functions and arrays don't mix (and functions don't mix with functions)

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                         |  140 ++++++++++++++++++---------------------
 validation/nested-declarator.c  |   16 +++--
 validation/nested-declarator2.c |    6 +-
 3 files changed, 76 insertions(+), 86 deletions(-)

diff --git a/parse.c b/parse.c
index 08de424..4c31bbe 100644
--- a/parse.c
+++ b/parse.c
@@ -1224,13 +1224,8 @@ static struct token *handle_attributes(struct token *token, struct ctype *ctype,
 	return token;
 }
 
-enum kind {
-	Nested, Empty, K_R, Proto, Bad_Func, Bad_Nested
-};
-
-static enum kind which_kind(struct token *token, struct token **p,
-			    struct ident **n,
-			    int dont_nest, int prefer_abstract)
+static int is_nested(struct token *token, struct token **p,
+		    int prefer_abstract)
 {
 	/*
 	 * This can be either a parameter list or a grouping.
@@ -1245,22 +1240,38 @@ static enum kind which_kind(struct token *token, struct token **p,
 
 	if (token_type(next) == TOKEN_IDENT) {
 		if (lookup_type(next))
-			return (dont_nest || prefer_abstract) ? Proto : Nested;
-		if (dont_nest) {
-			/* attributes in the K&R identifier list */
-			if (next != token->next)
-				return Bad_Func;
-			/* identifier list not in definition; complain */
-			if (prefer_abstract)
-				warning(token->pos,
-					"identifier list not in definition");
-			return K_R;
-		}
-		return Nested;
+			return !prefer_abstract;
+		return 1;
+	}
+
+	if (match_op(next, ')') || match_op(next, SPECIAL_ELLIPSIS))
+		return 0;
+
+	return 1;
+}
+
+enum kind {
+	Empty, K_R, Proto, Bad_Func,
+};
+
+static enum kind which_func(struct token *token,
+			    struct ident **n,
+			    int prefer_abstract)
+{
+	struct token *next = token->next;
+
+	if (token_type(next) == TOKEN_IDENT) {
+		if (lookup_type(next))
+			return Proto;
+		/* identifier list not in definition; complain */
+		if (prefer_abstract)
+			warning(token->pos,
+				"identifier list not in definition");
+		return K_R;
 	}
 
 	if (token_type(next) != TOKEN_SPECIAL)
-		return !dont_nest ? Bad_Nested : Bad_Func;
+		return Bad_Func;
 
 	if (next->special == ')') {
 		/* don't complain about those */
@@ -1278,72 +1289,51 @@ static enum kind which_kind(struct token *token, struct token **p,
 		return Proto;
 	}
 
-	return dont_nest ? Bad_Func : Nested;
+	return Bad_Func;
 }
 
 static struct token *direct_declarator(struct token *token, struct ctype *ctx, struct ident **p, int prefer_abstract)
 {
 	struct ctype *ctype = ctx;
-	int dont_nest = 0;
+	struct token *next;
 
 	if (p && token_type(token) == TOKEN_IDENT) {
 		*p = token->ident;
 		token = token->next;
-		dont_nest = 1;
+	} else if (match_op(token, '(') &&
+	    is_nested(token, &next, prefer_abstract)) {
+		struct symbol *base_type = ctype->base_type;
+		if (token->next != next)
+			next = handle_attributes(token->next, ctype,
+						  KW_ATTRIBUTE);
+		token = declarator(next, ctx, p, prefer_abstract);
+		token = expect(token, ')', "in nested declarator");
+		while (ctype->base_type != base_type)
+			ctype = &ctype->base_type->ctype;
+		p = NULL;
 	}
 
-	for (;;) {
-		if (token_type(token) != TOKEN_SPECIAL)
-			return token;
-
-		if (token->special == '(') {
-			struct symbol *sym;
-			struct token *next;
-			enum kind kind = which_kind(token, &next, p,
-						dont_nest, prefer_abstract);
-
-			dont_nest = 1;
-
-			if (kind == Nested) {
-				struct symbol *base_type = ctype->base_type;
-				if (token->next != next)
-					next = handle_attributes(token->next, ctype,
-								  KW_ATTRIBUTE);
-				token = declarator(next, ctx, p, prefer_abstract);
-				token = expect(token, ')', "in nested declarator");
-				while (ctype->base_type != base_type)
-					ctype = &ctype->base_type->ctype;
-				p = NULL;
-				continue;
-			}
-
-			if (kind == Bad_Nested) {
-				token = expect(token, ')', "in nested declarator");
-				p = NULL;
-				continue;
-			}
-
-			/* otherwise we have a function */
-			sym = alloc_indirect_symbol(token->pos, ctype, SYM_FN);
-			if (kind == K_R)
-				next = identifier_list(token->next, sym);
-			else if (kind == Proto)
-				next = parameter_type_list(token->next, sym);
-			token = expect(next, ')', "in function declarator");
-			sym->endpos = token->pos;
-			continue;
-		}
+	if (match_op(token, '(')) {
+		enum kind kind = which_func(token, p, prefer_abstract);
+		struct symbol *fn;
+		fn = alloc_indirect_symbol(token->pos, ctype, SYM_FN);
+		token = token->next;
+		if (kind == K_R)
+			token = identifier_list(token, fn);
+		else if (kind == Proto)
+			token = parameter_type_list(token, fn);
+		token = expect(token, ')', "in function declarator");
+		fn->endpos = token->pos;
+		return token;
+	}
 
-		if (token->special == '[') {
-			struct symbol *array = alloc_indirect_symbol(token->pos, ctype, SYM_ARRAY);
-			token = abstract_array_declarator(token->next, array);
-			token = expect(token, ']', "in abstract_array_declarator");
-			array->endpos = token->pos;
-			ctype = &array->ctype;
-			dont_nest = 1;
-			continue;
-		}
-		break;
+	while (match_op(token, '[')) {
+		struct symbol *array;
+		array = alloc_indirect_symbol(token->pos, ctype, SYM_ARRAY);
+		token = abstract_array_declarator(token->next, array);
+		token = expect(token, ']', "in abstract_array_declarator");
+		array->endpos = token->pos;
+		ctype = &array->ctype;
 	}
 	return token;
 }
@@ -2282,7 +2272,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	/* Just a type declaration? */
 	if (!ident) {
 		warning(token->pos, "missing identifier in declaration");
-		return expect(token, ';', "end of type declaration");
+		return expect(token, ';', "at the end of type declaration");
 	}
 
 	/* type define declaration? */
diff --git a/validation/nested-declarator.c b/validation/nested-declarator.c
index 62c4940..1efe20c 100644
--- a/validation/nested-declarator.c
+++ b/validation/nested-declarator.c
@@ -16,12 +16,14 @@ int j(int [2](*));
 /*
  * check-name: nested declarator vs. parameters
  * check-error-start:
-nested-declarator.c:11:29: warning: missing identifier in declaration
-nested-declarator.c:13:16: error: Expected ) in function declarator
-nested-declarator.c:13:16: error: got *
-nested-declarator.c:14:19: error: Expected ) in function declarator
-nested-declarator.c:14:19: error: got *
-nested-declarator.c:15:15: error: Expected ) in function declarator
-nested-declarator.c:15:15: error: got *
+nested-declarator.c:11:23: warning: missing identifier in declaration
+nested-declarator.c:11:23: error: Expected ; at the end of type declaration
+nested-declarator.c:11:23: error: got (
+nested-declarator.c:13:15: error: Expected ; at the end of type declaration
+nested-declarator.c:13:15: error: got (
+nested-declarator.c:14:18: error: Expected ) in function declarator
+nested-declarator.c:14:18: error: got (
+nested-declarator.c:15:14: error: Expected ) in function declarator
+nested-declarator.c:15:14: error: got (
  * check-error-end:
  */
diff --git a/validation/nested-declarator2.c b/validation/nested-declarator2.c
index 795d01f..cd22853 100644
--- a/validation/nested-declarator2.c
+++ b/validation/nested-declarator2.c
@@ -32,11 +32,9 @@ nested-declarator2.c:17:1: warning: non-ANSI definition of function 'w1'
 nested-declarator2.c:21:21: warning: non-ANSI function declaration of function '<noident>'
 nested-declarator2.c:22:16: warning: variadic functions must have one named argument
 nested-declarator2.c:24:21: warning: identifier list not in definition
-nested-declarator2.c:25:44: error: Expected ) in function declarator
-nested-declarator2.c:25:44: error: got x
 nested-declarator2.c:26:13: error: Expected ) in nested declarator
 nested-declarator2.c:26:13: error: got -
-nested-declarator2.c:27:17: error: Expected ) in function declarator
-nested-declarator2.c:27:17: error: got *
+nested-declarator2.c:27:16: error: Expected ; at the end of type declaration
+nested-declarator2.c:27:16: error: got (
  * check-error-end:
  */
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/4] Have Makefile import config.mak if it exists. ===

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/4] Have Makefile import config.mak if it exists.
Date: Mon, 01 Jun 2009 18:37:25 +0000
Message-ID: <1243881445-30069-4-git-send-email-naesten () gmail ! com>
--------------------
This will allow users to override build settings without dirtying their
trees, making life with `git stash' a bit easier.

Signed-off-by: Samuel Bronson <naesten@gmail.com>
---
 Makefile |   10 ++++++++--
 1 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/Makefile b/Makefile
index 18cec68..f45a74a 100644
--- a/Makefile
+++ b/Makefile
@@ -10,9 +10,10 @@ LDFLAGS += -g
 AR = ar
 
 #
-# For debugging, uncomment the next one
+# For debugging, put this in config.mak:
+#
+#     CFLAGS += -O0 -DDEBUG -g3 -gdwarf-2
 #
-#CFLAGS += -O0 -DDEBUG -g3 -gdwarf-2
 
 HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 && echo 'yes')
 
@@ -73,6 +74,11 @@ QUIET_LINK    = $(Q:@=@echo    '     LINK     '$@;)
 QUIET_INST_SH = $(Q:@=echo -n  '     INSTALL  ';)
 QUIET_INST    = $(Q:@=@echo -n '     INSTALL  ';)
 
+
+# Allow users to override build settings without dirtying their trees
+-include config.mak
+
+
 all: $(PROGRAMS) sparse.pc
 
 install: $(INST_PROGRAMS) $(LIBS) $(LIB_H) sparse.pc
-- 
1.6.3.1.169.g33fd.dirty

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 4/4] Have Makefile import config.mak if it exists.
Date: Tue, 02 Jun 2009 20:30:48 +0000
Message-ID: <70318cbf0906021330n7d0df47y5010dd158f731966 () mail ! gmail ! com>
--------------------
--000e0cd3287207b7e2046b636b03
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

On Mon, Jun 1, 2009 at 11:37 AM, Samuel Bronson <naesten@gmail.com> wrote:
> This will allow users to override build settings without dirtying their
> trees, making life with `git stash' a bit easier.
>
I modify the patch to use "local.mk" and add it in .gitignore.

If that works for you, I am going to apply it as yours.

Thanks

Chris

--000e0cd3287207b7e2046b636b03
Content-Type: application/octet-stream; 
	name="4-4-Have-Makefile-import-config.mak-if-it-exists..patch"
Content-Disposition: attachment; 
	filename="4-4-Have-Makefile-import-config.mak-if-it-exists..patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fvgl25le0

RnJvbSBwYXRjaHdvcmsgTW9uIEp1biAgMSAxODozNzoyNSAyMDA5CkNvbnRlbnQtVHlwZTogdGV4
dC9wbGFpbjsgY2hhcnNldD0idXRmLTgiCk1JTUUtVmVyc2lvbjogMS4wCkNvbnRlbnQtVHJhbnNm
ZXItRW5jb2Rpbmc6IDdiaXQKU3ViamVjdDogWzQvNF0gSGF2ZSBNYWtlZmlsZSBpbXBvcnQgY29u
ZmlnLm1hayBpZiBpdCBleGlzdHMuCkRhdGU6IE1vbiwgMDEgSnVuIDIwMDkgMTg6Mzc6MjUgLTAw
MDAKRnJvbTogU2FtdWVsIEJyb25zb24gPG5hZXN0ZW5AZ21haWwuY29tPgpYLVBhdGNod29yay1J
ZDogMjcyNjQKClRoaXMgd2lsbCBhbGxvdyB1c2VycyB0byBvdmVycmlkZSBidWlsZCBzZXR0aW5n
cyB3aXRob3V0IGRpcnR5aW5nIHRoZWlyCnRyZWVzLCBtYWtpbmcgbGlmZSB3aXRoIGBnaXQgc3Rh
c2gnIGEgYml0IGVhc2llci4KClNpZ25lZC1vZmYtYnk6IFNhbXVlbCBCcm9uc29uIDxuYWVzdGVu
QGdtYWlsLmNvbT4KCi0tLQpNYWtlZmlsZSB8ICAgMTAgKysrKysrKystLQogMSBmaWxlcyBjaGFu
Z2VkLCA4IGluc2VydGlvbnMoKyksIDIgZGVsZXRpb25zKC0pCgpJbmRleDogc3BhcnNlLmNocmlz
bC9NYWtlZmlsZQo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09Ci0tLSBzcGFyc2UuY2hyaXNsLm9yaWcvTWFrZWZpbGUKKysr
IHNwYXJzZS5jaHJpc2wvTWFrZWZpbGUKQEAgLTEwLDkgKzEwLDEwIEBAIExERkxBR1MgKz0gLWcK
IEFSID0gYXIKIAogIwotIyBGb3IgZGVidWdnaW5nLCB1bmNvbW1lbnQgdGhlIG5leHQgb25lCisj
IEZvciBkZWJ1Z2dpbmcsIHB1dCB0aGlzIGluIGxvY2FsLm1rOgorIworIyAgICAgQ0ZMQUdTICs9
IC1PMCAtRERFQlVHIC1nMyAtZ2R3YXJmLTIKICMKLSNDRkxBR1MgKz0gLU8wIC1EREVCVUcgLWcz
IC1nZHdhcmYtMgogCiBIQVZFX0xJQlhNTD0kKHNoZWxsIHBrZy1jb25maWcgLS1leGlzdHMgbGli
eG1sLTIuMCAmJiBlY2hvICd5ZXMnKQogSEFWRV9HQ0NfREVQPSQoc2hlbGwgdG91Y2ggLmdjYy10
ZXN0LmMgJiYgCQkJCVwKQEAgLTg5LDYgKzkwLDExIEBAIFNFRF9QQ19DTUQgPSAnc3xAdmVyc2lv
bkB8JChWRVJTSU9OKXxnOwkKIAkgICAgICBzfEBpbmNsdWRlZGlyQHwkKElOQ0xVREVESVIpfGcn
CiAKIAorCisjIEFsbG93IHVzZXJzIHRvIG92ZXJyaWRlIGJ1aWxkIHNldHRpbmdzIHdpdGhvdXQg
ZGlydHlpbmcgdGhlaXIgdHJlZXMKKy1pbmNsdWRlIGxvY2FsLm1rCisKKwogYWxsOiAkKFBST0dS
QU1TKSBzcGFyc2UucGMKIAogaW5zdGFsbDogJChJTlNUX1BST0dSQU1TKSAkKExJQlMpICQoTElC
X0gpIHNwYXJzZS5wYwpJbmRleDogc3BhcnNlLmNocmlzbC8uZ2l0aWdub3JlCj09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0K
LS0tIHNwYXJzZS5jaHJpc2wub3JpZy8uZ2l0aWdub3JlCisrKyBzcGFyc2UuY2hyaXNsLy5naXRp
Z25vcmUKQEAgLTMzLDMgKzMzLDcgQEAgcGF0Y2hlcy0qCiAjIHF1aWx0J3MgZmlsZXMKIHBhdGNo
ZXMKIHNlcmllcworCisjIGxvY2FsIG1ha2VmaWxlCitsb2NhbC5taworCg==
--000e0cd3287207b7e2046b636b03--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Samuel Bronson <naesten () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 4/4] Have Makefile import config.mak if it exists.
Date: Wed, 03 Jun 2009 00:37:04 +0000
Message-ID: <db65a1cd0906021737p66cd5abcs87600f73b7792809 () mail ! gmail ! com>
--------------------
On Tue, Jun 2, 2009 at 4:30 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Mon, Jun 1, 2009 at 11:37 AM, Samuel Bronson <naesten@gmail.com> wrote:
>> This will allow users to override build settings without dirtying their
>> trees, making life with `git stash' a bit easier.
>>
> I modify the patch to use "local.mk" and add it in .gitignore.
>
> If that works for you, I am going to apply it as yours.

Yeah, that's fine.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] Fix some "plain integer as NULL pointer" warnings ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 4/5] Fix some "plain integer as NULL pointer" warnings
Date: Tue, 21 Jul 2009 21:54:07 +0000
Message-ID: <4A6638FF.4000108 () ramsay1 ! demon ! co ! uk>
--------------------
Christopher Li wrote:
> On Sat, Jul 18, 2009 at 1:58 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
[snip]
>>
>> $ cat -n null-test.sh
>>     1  #!/bin/bash
>>     2
>>     3  # The C99 standard says that the following headers define NULL:
>>     4  #   locale.h (7.11), stddef.h (7.17), stdio.h (7.19.1),
>>     5  #   stdlib.h (7.20), string.h (7.21.1), time.h (7.23.1),
>>     6  #   wchar.h (7.24.1).
>>     7
>>     8  for i in locale.h stddef.h stdio.h stdlib.h string.h time.h wchar.h
>>     9  do
>>    10          printf "%10s:  " $i
>>    11          printf "#include<%s>\nchar *xyz_ptr = NULL;\n" $i >t.c
>>    12          cgcc -E t.c | grep xyz_ptr
>>    13  done
>>    14  rm t.c
>>    15
>> $ ./null-test.sh
> 
> That is what I get in FC11:
>   locale.h:  char *xyz_ptr = ((void *)0);
>   stddef.h:  char *xyz_ptr = ((void *)0);
>    stdio.h:  char *xyz_ptr = ((void *)0);
>   stdlib.h:  char *xyz_ptr = ((void *)0);
>   string.h:  char *xyz_ptr = ((void *)0);
>     time.h:  char *xyz_ptr = ((void *)0);
>    wchar.h:  char *xyz_ptr = ((void *)0);
> 
> Which system has this problem?
> 

This is on cygwin. (as mentioned in the subject;P)

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] Fix some "plain integer as NULL pointer" warnings on ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 4/5] Fix some "plain integer as NULL pointer" warnings on
Date: Mon, 20 Jul 2009 20:31:20 +0000
Message-ID: <70318cbf0907201331v1c830779i89c9bef9d6706115 () mail ! gmail ! com>
--------------------
On Sat, Jul 18, 2009 at 1:58 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
>
> These sparse warnings are caused by broken new-lib headers,
> which sometimes result in NULL being defined as 0, and at
> other times defined as ((void *)0).
>
> In essence, the only header which works correctly (by defining
> NULL as ((void *)0)) is stddef.h. The stdio.h and time.h headers
> also work, almost by accident, by indirectly including stddef.h.
> The other standard headers which are required to define the NULL
> macro, namely locale.h, stdlib.h, string.h and wchar.h, all
> define the macro as the 0 token. (This is a slightly simplified
> description of the problem).
>
> In order to suppress these warnings, include the stddef.h header
> at the start of ptrlist.c.
>
> Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>
> ---
>
> Hi Chris,
>
> $ cat -n null-test.sh
>     1  #!/bin/bash
>     2
>     3  # The C99 standard says that the following headers define NULL:
>     4  #   locale.h (7.11), stddef.h (7.17), stdio.h (7.19.1),
>     5  #   stdlib.h (7.20), string.h (7.21.1), time.h (7.23.1),
>     6  #   wchar.h (7.24.1).
>     7
>     8  for i in locale.h stddef.h stdio.h stdlib.h string.h time.h wchar.h
>     9  do
>    10          printf "%10s:  " $i
>    11          printf "#include<%s>\nchar *xyz_ptr = NULL;\n" $i >t.c
>    12          cgcc -E t.c | grep xyz_ptr
>    13  done
>    14  rm t.c
>    15
> $ ./null-test.sh

That is what I get in FC11:
  locale.h:  char *xyz_ptr = ((void *)0);
  stddef.h:  char *xyz_ptr = ((void *)0);
   stdio.h:  char *xyz_ptr = ((void *)0);
  stdlib.h:  char *xyz_ptr = ((void *)0);
  string.h:  char *xyz_ptr = ((void *)0);
    time.h:  char *xyz_ptr = ((void *)0);
   wchar.h:  char *xyz_ptr = ((void *)0);

Which system has this problem?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 4/5] Fix some "plain integer as NULL pointer" warnings on
Date: Wed, 22 Jul 2009 00:37:22 +0000
Message-ID: <70318cbf0907211737i42ae4b29u7fc4b4c9d32f6b6c () mail ! gmail ! com>
--------------------
On Tue, Jul 21, 2009 at 2:54 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
> This is on cygwin. (as mentioned in the subject;P)

Sorry I miss the most obvious spot :-). Let me take a look.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/5] Add a --version option to sparse ===

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: [PATCH 5/5] Add a --version option to sparse
Date: Sat, 18 Jul 2009 21:06:37 +0000
Message-ID: <4A62395D.9000207 () ramsay1 ! demon ! co ! uk>
--------------------

In addition to a minimal --version implementation, using
the output of 'git describe', we also output the version
string when -v(erbose) output has been requested.

Also, when cgcc internally sets the $gcc_base_dir, the
compiler invocation is changed to use an explicit gcc
command, rather than $cc. (when --version is part of
$cc, this breaks badly).

Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>
---

Hi Chris,

This patch actually adds a feature :-)

This is a minimal implementation and doesn't address the issue
of a sparse library version number; should the library define
some version macros like __SPARSE_MAJOR, __SPARSE_MINOR, etc.?
Dunno.

ATB,
Ramsay Jones

 Makefile |    9 +++++++++
 cgcc     |    5 ++++-
 lib.c    |   14 ++++++++++++++
 lib.h    |    1 +
 sparse.c |    8 +++++++-
 5 files changed, 35 insertions(+), 2 deletions(-)

diff --git a/Makefile b/Makefile
index 70ccbc9..2dcbc5a 100644
--- a/Makefile
+++ b/Makefile
@@ -19,6 +19,7 @@ HAVE_LIBXML=$(shell pkg-config --exists libxml-2.0 2>/dev/null && echo 'yes')
 HAVE_GCC_DEP=$(shell touch .gcc-test.c && 				\
 		$(CC) -c -Wp,-MD,.gcc-test.d .gcc-test.c 2>/dev/null && \
 		echo 'yes'; rm -f .gcc-test.d .gcc-test.o .gcc-test.c)
+IN_GIT_REPO=$(shell test -d .git && git describe >/dev/null 2>&1 && echo 'yes')
 
 CFLAGS += -DGCC_BASE=\"$(shell $(CC) --print-file-name=)\"
 
@@ -26,6 +27,14 @@ ifeq ($(HAVE_GCC_DEP),yes)
 CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
 endif
 
+BUILD_VERSION=$(VERSION)
+
+ifeq ($(IN_GIT_REPO),yes)
+BUILD_VERSION=$(shell git describe)
+endif
+
+CFLAGS += -DVERSION='"$(BUILD_VERSION)"'
+
 DESTDIR=
 PREFIX=$(HOME)
 BINDIR=$(PREFIX)/bin
diff --git a/cgcc b/cgcc
index fdda6d1..a12d4b1 100755
--- a/cgcc
+++ b/cgcc
@@ -23,6 +23,9 @@ while (@ARGV) {
     # Ditto for stdin.
     $do_check = 1 if $_ eq '-';
 
+    # Check for --version
+    $do_check = 1 if $_ eq '--version';
+
     $m32 = 1 if /^-m32$/;
     $m64 = 1 if /^-m64$/;
     $gendeps = 1 if /^-M$/;
@@ -65,7 +68,7 @@ if ($do_check) {
 	$check .= &add_specs ('host_os_specs');
     }
 
-    $gcc_base_dir = qx($cc -print-file-name=) if !$gcc_base_dir;
+    $gcc_base_dir = qx(gcc -print-file-name=) if !$gcc_base_dir;
     $check .= " -gcc-base-dir " . $gcc_base_dir if $gcc_base_dir;
 
     print "$check\n" if $verbose;
diff --git a/lib.c b/lib.c
index 42affcd..9390c7f 100644
--- a/lib.c
+++ b/lib.c
@@ -43,6 +43,13 @@ int gcc_patchlevel = __GNUC_PATCHLEVEL__;
 
 static const char *gcc_base_dir = GCC_BASE;
 
+static const char *sparse_version_string = VERSION;
+
+const char *sparse_version(void)
+{
+	return sparse_version_string;
+}
+
 struct token *skip_to(struct token *token, int op)
 {
 	while (!match_op(token, op) && !eof_token(token))
@@ -619,6 +626,12 @@ static char **handle_base_dir(char *arg, char **next)
 	return next;
 }
 
+static char **handle_version(char *arg, char **next)
+{
+	printf("sparse version %s\n", sparse_version());
+	exit(0);
+}
+
 struct switches {
 	const char *name;
 	char **(*fn)(char *, char **);
@@ -629,6 +642,7 @@ static char **handle_switch(char *arg, char **next)
 	static struct switches cmd[] = {
 		{ "nostdinc", handle_nostdinc },
 		{ "gcc-base-dir", handle_base_dir},
+		{ "-version", handle_version },
 		{ NULL, NULL }
 	};
 	struct switches *s;
diff --git a/lib.h b/lib.h
index 919b5b1..80f8ec8 100644
--- a/lib.h
+++ b/lib.h
@@ -80,6 +80,7 @@ struct token *expect(struct token *, int, const char *);
 #define NORETURN_ATTR
 #define SENTINEL_ATTR
 #endif
+extern const char *sparse_version(void);
 extern void die(const char *, ...) FORMAT_ATTR(1) NORETURN_ATTR;
 extern void info(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void warning(struct position, const char *, ...) FORMAT_ATTR(2);
diff --git a/sparse.c b/sparse.c
index 4026ba7..2c43e0f 100644
--- a/sparse.c
+++ b/sparse.c
@@ -276,10 +276,16 @@ static void check_symbols(struct symbol_list *list)
 int main(int argc, char **argv)
 {
 	struct string_list *filelist = NULL;
+	struct symbol_list *list;
 	char *file;
 
+	list = sparse_initialize(argc, argv, &filelist);
+
+	if (verbose)
+		fprintf(stderr, "sparse version %s\n", sparse_version());
+
 	// Expand, linearize and show it.
-	check_symbols(sparse_initialize(argc, argv, &filelist));
+	check_symbols(list);
 	FOR_EACH_PTR_NOTAG(filelist, file) {
 		check_symbols(sparse(file));
 	} END_FOR_EACH_PTR_NOTAG(file);
-- 
1.6.3.1


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 5/5] Add a --version option to sparse
Date: Wed, 22 Jul 2009 00:57:33 +0000
Message-ID: <70318cbf0907211757w1e0e3436hcc8b679c6de60804 () mail ! gmail ! com>
--------------------
On Sat, Jul 18, 2009 at 2:06 PM, Ramsay Jones<ramsay@ramsay1.demon.co.uk> wrote:
>
> In addition to a minimal --version implementation, using
> the output of 'git describe', we also output the version
> string when -v(erbose) output has been requested.
>
> Also, when cgcc internally sets the $gcc_base_dir, the
> compiler invocation is changed to use an explicit gcc
> command, rather than $cc. (when --version is part of
> $cc, this breaks badly).
>
> Signed-off-by: Ramsay Jones <ramsay@ramsay1.demon.co.uk>

Sorry I did not have a chance to reply it earlier. I was on a trip, very limited
Internet access.

> ---
>
> Hi Chris,
>
> This patch actually adds a feature :-)
>
> This is a minimal implementation and doesn't address the issue
> of a sparse library version number; should the library define
> some version macros like __SPARSE_MAJOR, __SPARSE_MINOR, etc.?
> Dunno.

I don't mind sparse has a version number. Some thing like 4.2.0 etc.
I would rather not mix that version number with the git commit hash.
The git commit hash has very limited usage. I think just print it as
part of the generic verbose printing is good enough. Add the printing in
handle_switch_v_finalize() so other executable can get it as well.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsay1 ! demon ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH 5/5] Add a --version option to sparse
Date: Fri, 24 Jul 2009 19:30:58 +0000
Message-ID: <4A6A0BF2.7080509 () ramsay1 ! demon ! co ! uk>
--------------------
Christopher Li wrote:
> I don't mind sparse has a version number. Some thing like 4.2.0 etc.
> I would rather not mix that version number with the git commit hash.

The commit hash is only part of the version number string when you
build in a git repo and your HEAD does not reference a release
commit (as indicated by a tag object on this commit).

Note that the "dist" make target already uses 'git describe' to check
that the release tag and VERSION makefile variable agree.

$ git checkout master
$ git describe
0.4.1-99-g37f041a
$ git checkout 0.4.1
Note: moving to '0.4.1' which isn't a local branch
If you want to create a new branch from this checkout, you may do so
(now or later) by using -b with the checkout command again. Example:
  git checkout -b <new_branch_name>
HEAD is now at a02aeb3... Makefile: VERSION=0.4.1
$ git describe
0.4.1
$ 

[Note that I don't check for locally modified files and add "-dirty"
to the version string like git does; that is partly what I meant by
"minimal implementation"]

> The git commit hash has very limited usage. I think just print it as
> part of the generic verbose printing is good enough. Add the printing in
> handle_switch_v_finalize() so other executable can get it as well.
> 

Hmm, Oops! Now I remember... ahem *blush*, I had intended to modify
this patch before publishing it. (As I said before, this is quite an
old patch; I had a TODO to fix it up).

However, the fixup I have in mind involves moving most of the handling
of the --version option out of the library and into the sparse executable.
(i.e. more or less the opposite of what you suggest above for -v ;-) ).

My intent with this patch was to provide sparse (the program) with a
version number; *not* the sparse library, which is a separate issue.
(If a library version number is implemented, then the sparse program
version number *could* be the same number, of course). I did not
consider the other example programs built with sparse, but I suppose
they could all share the same version number if necessary.

However, you would not want sparse (the library) to force *all*
applications built with the library to handle the --version option
by printing the sparse (the program) version string and exiting!

So, the library should just set a version_option seen flag and let
the application process this flag itself.

Hmm, I don't have time tonight to re-write the patch, but I will
send a new version soon.

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 5/5] Add a --version option to sparse
Date: Sat, 25 Jul 2009 19:34:59 +0000
Message-ID: <70318cbf0907251234o6028d0adh8a470f40f373578 () mail ! gmail ! com>
--------------------
On Fri, Jul 24, 2009 at 12:30 PM, Ramsay
Jones<ramsay@ramsay1.demon.co.uk> wrote:
> $ git checkout master
> $ git describe
> 0.4.1-99-g37f041a

If works well if you are following the official branch. If you are working
on your own, you might have some private tag. Then that will mess up
the "git describe". My tag might not even look like a version number.

So for version numbers, I still prefer the dot and numbers. We can
follow what Linux kernel do for version strings.

> My intent with this patch was to provide sparse (the program) with a
> version number; *not* the sparse library, which is a separate issue.
> (If a library version number is implemented, then the sparse program
> version number *could* be the same number, of course). I did not
> consider the other example programs built with sparse, but I suppose
> they could all share the same version number if necessary.

In my mind, they share the same version number. Individual version
the program inside sparse package is kind of messy. I don't see
a need for that in the near future yet.

> However, you would not want sparse (the library) to force *all*
> applications built with the library to handle the --version option
> by printing the sparse (the program) version string and exiting!

That is what YOUR current patch do, no?

>
> So, the library should just set a version_option seen flag and let
> the application process this flag itself.

That will force every program to process the version itself, doing more
or less the same thing.

Let's say I don't need separate version inside sparse package.
Does "-v" printing out sparse version string in side lib.c satisfy
your need already? In that case, I don't see the need for a separate
"--version".

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/7] more direct_declarator() sanitizing ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 5/7] more direct_declarator() sanitizing
Date: Sat, 14 Feb 2009 12:25:45 +0000
Message-ID: <E1LYJab-0001p6-L5 () ZenIV ! linux ! org ! uk>
--------------------

* new helper function - which_kind().  Finds how to parse what
follows ( in declarator.
* parameter-type-list and identifier-list handling separated
and cleaned up.
* saner recovery from errors
* int f(__attribute__((....)) x) is prohibited by gcc syntax;
attributes are not allowed in K&R identifier list, obviously,
and gcc refused to treat that as "int is implicit if missing"
kind of case.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                         |  138 ++++++++++++++++++++++++--------------
 validation/nested-declarator2.c |   40 +++++++++++
 2 files changed, 127 insertions(+), 51 deletions(-)
 create mode 100644 validation/nested-declarator2.c

diff --git a/parse.c b/parse.c
index 62a005c..70cf2fb 100644
--- a/parse.c
+++ b/parse.c
@@ -1226,7 +1226,8 @@ static struct token *abstract_array_declarator(struct token *token, struct symbo
 	return token;
 }
 
-static struct token *parameter_type_list(struct token *, struct symbol *, struct ident **p);
+static struct token *parameter_type_list(struct token *, struct symbol *);
+static struct token *identifier_list(struct token *, struct symbol *);
 static struct token *declarator(struct token *token, struct symbol *sym, struct ident **p, int);
 
 static struct token *handle_attributes(struct token *token, struct ctype *ctype, unsigned int keywords)
@@ -1248,6 +1249,55 @@ static struct token *handle_attributes(struct token *token, struct ctype *ctype,
 	return token;
 }
 
+enum kind {
+	Nested, Empty, K_R, Proto, Bad_Func, Bad_Nested
+};
+
+static enum kind which_kind(struct token *token, struct token **p,
+			    struct ident **n, struct ctype *ctype,
+			    int dont_nest, int prefer_abstract)
+{
+	/*
+	 * This can be either a parameter list or a grouping.
+	 * For the direct (non-abstract) case, we know if must be
+	 * a parameter list if we already saw the identifier.
+	 * For the abstract case, we know if must be a parameter
+	 * list if it is empty or starts with a type.
+	 */
+	struct token *next = token->next;
+
+	*p = next = handle_attributes(next, ctype, KW_ATTRIBUTE);
+
+	if (token_type(next) == TOKEN_IDENT) {
+		if (lookup_type(next))
+			return (dont_nest || prefer_abstract) ? Proto : Nested;
+		if (dont_nest)
+			return (next == token->next) ? K_R : Bad_Func;
+		return Nested;
+	}
+
+	if (token_type(next) != TOKEN_SPECIAL)
+		return dont_nest ? Bad_Nested : Bad_Func;
+
+	if (next->special == ')') {
+		/* don't complain about those */
+		if (!n || match_op(next->next, ';'))
+			return Empty;
+		warning(next->pos,
+			"non-ANSI function declaration of function '%s'",
+			show_ident(*n));
+		return Empty;
+	}
+
+	if (next->special == SPECIAL_ELLIPSIS) {
+		warning(next->pos,
+			"variadic functions must have one named argument");
+		return Proto;
+	}
+
+	return dont_nest ? Bad_Func : Nested;
+}
+
 static struct token *direct_declarator(struct token *token, struct symbol *decl, struct ident **p, int prefer_abstract)
 {
 	struct ctype *ctype = &decl->ctype;
@@ -1263,40 +1313,42 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
 		if (token_type(token) != TOKEN_SPECIAL)
 			return token;
 
-		/*
-		 * This can be either a parameter list or a grouping.
-		 * For the direct (non-abstract) case, we know if must be
-		 * a parameter list if we already saw the identifier.
-		 * For the abstract case, we know if must be a parameter
-		 * list if it is empty or starts with a type.
-		 */
 		if (token->special == '(') {
 			struct symbol *sym;
-			struct token *next = token->next;
-			int fn;
+			struct token *next;
+			enum kind kind = which_kind(token, &next, p, ctype,
+						dont_nest, prefer_abstract);
 
-			next = handle_attributes(next, ctype, KW_ATTRIBUTE);
-			fn = dont_nest || match_op(next, ')') ||
-				(prefer_abstract && lookup_type(next));
+			dont_nest = 1;
 
-			if (!fn) {
+			if (kind == Nested) {
 				struct symbol *base_type = ctype->base_type;
 				token = declarator(next, decl, p, prefer_abstract);
 				token = expect(token, ')', "in nested declarator");
 				while (ctype->base_type != base_type)
 					ctype = &ctype->base_type->ctype;
-				dont_nest = 1;
 				p = NULL;
 				continue;
 			}
 
+			if (kind == Bad_Nested) {
+				token = expect(token, ')', "in nested declarator");
+				p = NULL;
+				continue;
+			}
+
+			/* otherwise we have a function */
 			sym = alloc_indirect_symbol(token->pos, ctype, SYM_FN);
-			token = parameter_type_list(next, sym, p);
-			token = expect(token, ')', "in function declarator");
+			if (kind == K_R) {
+				next = identifier_list(next, sym);
+			} else if (kind == Proto) {
+				next = parameter_type_list(next, sym);
+			}
+			token = expect(next, ')', "in function declarator");
 			sym->endpos = token->pos;
-			dont_nest = 1;
 			continue;
 		}
+
 		if (token->special == '[') {
 			struct symbol *array = alloc_indirect_symbol(token->pos, ctype, SYM_ARRAY);
 			token = abstract_array_declarator(token->next, array);
@@ -1939,43 +1991,27 @@ static struct token * statement_list(struct token *token, struct statement_list
 	return token;
 }
 
-static struct token *parameter_type_list(struct token *token, struct symbol *fn, struct ident **p)
+static struct token *identifier_list(struct token *token, struct symbol *fn)
 {
 	struct symbol_list **list = &fn->arguments;
-
-	if (match_op(token, ')')) {
-		// No warning for "void oink ();"
-		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
-		if (p && !match_op(token->next, ';'))
-			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
-		return token;
-	}
-
-	if (match_op(token, SPECIAL_ELLIPSIS)) {
-		warning(token->pos, "variadic functions must have one named argument");
-		fn->variadic = 1;
-		return token->next;
+	for (;;) {
+		struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
+		sym->ident = token->ident;
+		token = token->next;
+		sym->endpos = token->pos;
+		add_symbol(list, sym);
+		if (!match_op(token, ',') ||
+		    token_type(token->next) != TOKEN_IDENT ||
+		    lookup_type(token->next))
+			break;
+		token = token->next;
 	}
+	return token;
+}
 
-	if (token_type(token) != TOKEN_IDENT)
-		return token;
-
-	if (!lookup_type(token)) {
-		/* K&R */
-		for (;;) {
-			struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
-			sym->ident = token->ident;
-			token = token->next;
-			sym->endpos = token->pos;
-			add_symbol(list, sym);
-			if (!match_op(token, ',') ||
-			    token_type(token->next) != TOKEN_IDENT ||
-			    lookup_type(token->next))
-				break;
-			token = token->next;
-		}
-		return token;
-	}
+static struct token *parameter_type_list(struct token *token, struct symbol *fn)
+{
+	struct symbol_list **list = &fn->arguments;
 
 	for (;;) {
 		struct symbol *sym;
diff --git a/validation/nested-declarator2.c b/validation/nested-declarator2.c
new file mode 100644
index 0000000..700c802
--- /dev/null
+++ b/validation/nested-declarator2.c
@@ -0,0 +1,40 @@
+typedef int T;
+extern void f1(int);
+extern void f2(T);
+static void (*f3)(int) = f2;
+static void (*f4)(T) = f1;
+extern void f5(void (int));
+extern void f6(void (T));
+static void z(int x)
+{
+	int (T) = x;
+	f5(f2);
+	f6(f3);
+}
+static void f8();
+static int (x) = 1;
+static void w1(y)
+int y;
+{
+	x = y;
+}
+static void w2(int ());
+static void w3(...);
+static void f9(__attribute__((mode(DI))) T);
+static void bad1(__attribute__((mode(DI))) x);
+static int (-bad2);
+static void [2](*bad3);
+/*
+ * check-name: more on handling of ( in direct-declarator
+ * check-error-start:
+nested-declarator2.c:17:1: warning: non-ANSI definition of function 'w1'
+nested-declarator2.c:21:21: warning: non-ANSI function declaration of function '<noident>'
+nested-declarator2.c:22:16: warning: variadic functions must have one named argument
+nested-declarator2.c:24:44: error: Expected ) in function declarator
+nested-declarator2.c:24:44: error: got x
+nested-declarator2.c:25:13: error: Expected ) in nested declarator
+nested-declarator2.c:25:13: error: got -
+nested-declarator2.c:26:17: error: Expected ) in function declarator
+nested-declarator2.c:26:17: error: got *
+ * check-error-end:
+ */
-- 
1.5.6.6


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/18] Propagate decl_state to declaration_specifiers() ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 6/18] Propagate decl_state to declaration_specifiers()
Date: Mon, 09 Mar 2009 07:11:08 +0000
Message-ID: <E1LgZdk-0000tX-0u () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c |   74 +++++++++++++++++++++++++++++++-------------------------------
 1 files changed, 37 insertions(+), 37 deletions(-)

diff --git a/parse.c b/parse.c
index 8c402f3..a2048a2 100644
--- a/parse.c
+++ b/parse.c
@@ -1079,7 +1079,7 @@ static void check_modifiers(struct position *pos, struct symbol *s, unsigned lon
 		     modifier_string (wrong));
 }
 
-static struct token *declaration_specifiers(struct token *next, struct ctype *ctype, int qual)
+static struct token *declaration_specifiers(struct token *next, struct decl_state *ctx, int qual)
 {
 	struct token *token;
 
@@ -1113,21 +1113,21 @@ static struct token *declaration_specifiers(struct token *next, struct ctype *ct
 		if (type) {
 			if (qual)
 				break;
-			if (ctype->base_type)
+			if (ctx->ctype.base_type)
 				break;
 			/* User types only mix with qualifiers */
 			if (mod & MOD_USERTYPE) {
-				if (ctype->modifiers & MOD_SPECIFIER)
+				if (ctx->ctype.modifiers & MOD_SPECIFIER)
 					break;
 			}
-			ctype->base_type = type;
+			ctx->ctype.base_type = type;
 		}
 
-		check_modifiers(&token->pos, s, ctype->modifiers);
-		apply_ctype(token->pos, &thistype, ctype);
+		check_modifiers(&token->pos, s, ctx->ctype.modifiers);
+		apply_ctype(token->pos, &thistype, &ctx->ctype);
 	}
 
-	if (!ctype->base_type) {
+	if (!ctx->ctype.base_type) {
 		struct symbol *base = &incomplete_ctype;
 
 		/*
@@ -1135,9 +1135,9 @@ static struct token *declaration_specifiers(struct token *next, struct ctype *ct
 		 * type, and "ctype_integer()" will turn this into
 		 * a specific one.
 		 */
-		if (ctype->modifiers & MOD_SPECIFIER)
+		if (ctx->ctype.modifiers & MOD_SPECIFIER)
 			base = &int_type;
-		ctype->base_type = base;
+		ctx->ctype.base_type = base;
 	}
 	return token;
 }
@@ -1339,39 +1339,39 @@ static struct token *direct_declarator(struct token *token, struct decl_state *c
 	return token;
 }
 
-static struct token *pointer(struct token *token, struct ctype *ctype)
+static struct token *pointer(struct token *token, struct decl_state *ctx)
 {
 	unsigned long modifiers;
 	struct symbol *base_type;
 
-	modifiers = ctype->modifiers & ~MOD_TYPEDEF;
-	base_type = ctype->base_type;
-	ctype->modifiers = modifiers;
+	modifiers = ctx->ctype.modifiers & ~MOD_TYPEDEF;
+	base_type = ctx->ctype.base_type;
+	ctx->ctype.modifiers = modifiers;
 
 	while (match_op(token,'*')) {
 		struct symbol *ptr = alloc_symbol(token->pos, SYM_PTR);
 		ptr->ctype.modifiers = modifiers & ~MOD_STORAGE;
-		ptr->ctype.as = ctype->as;
-		concat_ptr_list((struct ptr_list *)ctype->contexts,
+		ptr->ctype.as = ctx->ctype.as;
+		concat_ptr_list((struct ptr_list *)ctx->ctype.contexts,
 				(struct ptr_list **)&ptr->ctype.contexts);
 		ptr->ctype.base_type = base_type;
 
 		base_type = ptr;
-		ctype->modifiers = modifiers & MOD_STORAGE;
-		ctype->base_type = base_type;
-		ctype->as = 0;
-		free_ptr_list(&ctype->contexts);
+		ctx->ctype.modifiers = modifiers & MOD_STORAGE;
+		ctx->ctype.base_type = base_type;
+		ctx->ctype.as = 0;
+		free_ptr_list(&ctx->ctype.contexts);
 
-		token = declaration_specifiers(token->next, ctype, 1);
-		modifiers = ctype->modifiers;
-		ctype->base_type->endpos = token->pos;
+		token = declaration_specifiers(token->next, ctx, 1);
+		modifiers = ctx->ctype.modifiers;
+		ctx->ctype.base_type->endpos = token->pos;
 	}
 	return token;
 }
 
 static struct token *declarator(struct token *token, struct decl_state *ctx)
 {
-	token = pointer(token, &ctx->ctype);
+	token = pointer(token, ctx);
 	return direct_declarator(token, ctx);
 }
 
@@ -1425,14 +1425,13 @@ static struct token *handle_bitfield(struct token *token, struct decl_state *ctx
 
 static struct token *declaration_list(struct token *token, struct symbol_list **list)
 {
-	struct ctype ctype = {0, };
+	struct decl_state ctx = {.prefer_abstract = 0};
+	struct ctype saved;
 
-	token = declaration_specifiers(token, &ctype, 0);
+	token = declaration_specifiers(token, &ctx, 0);
+	saved = ctx.ctype;
 	for (;;) {
-		struct decl_state ctx;
 		struct symbol *decl = alloc_symbol(token->pos, SYM_NODE);
-		ctx.ctype = ctype;
-		ctx.prefer_abstract = 0;
 		ctx.ident = &decl->ident;
 
 		token = declarator(token, &ctx);
@@ -1448,6 +1447,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
+		ctx.ctype = saved;
 	}
 	return token;
 }
@@ -1470,7 +1470,7 @@ static struct token *parameter_declaration(struct token *token, struct symbol *s
 {
 	struct decl_state ctx = {.prefer_abstract = 1};
 
-	token = declaration_specifiers(token, &ctx.ctype, 0);
+	token = declaration_specifiers(token, &ctx, 0);
 	ctx.ident = &sym->ident;
 	token = declarator(token, &ctx);
 	token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE);
@@ -1485,7 +1485,7 @@ struct token *typename(struct token *token, struct symbol **p, int mod)
 	struct decl_state ctx = {.prefer_abstract = 1};
 	struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
 	*p = sym;
-	token = declaration_specifiers(token, &ctx.ctype, 0);
+	token = declaration_specifiers(token, &ctx, 0);
 	token = declarator(token, &ctx);
 	apply_modifiers(token->pos, &ctx.ctype);
 	if (ctx.ctype.modifiers & MOD_STORAGE & ~mod)
@@ -2249,8 +2249,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 {
 	struct ident *ident = NULL;
 	struct symbol *decl;
-	struct ctype ctype = { 0, };
 	struct decl_state ctx = { .ident = &ident };
+	struct ctype saved;
 	struct symbol *base_type;
 	int is_typedef;
 
@@ -2262,15 +2262,15 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	}
 
 	/* Parse declaration-specifiers, if any */
-	token = declaration_specifiers(token, &ctype, 0);
+	token = declaration_specifiers(token, &ctx, 0);
 	decl = alloc_symbol(token->pos, SYM_NODE);
 	/* Just a type declaration? */
 	if (match_op(token, ';')) {
-		apply_modifiers(token->pos, &ctype);
+		apply_modifiers(token->pos, &ctx.ctype);
 		return token->next;
 	}
 
-	ctx.ctype = ctype;
+	saved = ctx.ctype;
 	token = declarator(token, &ctx);
 	token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE | KW_ASM);
 	apply_modifiers(token->pos, &ctx.ctype);
@@ -2285,11 +2285,11 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	}
 
 	/* type define declaration? */
-	is_typedef = (ctype.modifiers & MOD_TYPEDEF) != 0;
+	is_typedef = (saved.modifiers & MOD_TYPEDEF) != 0;
 
 	/* Typedefs don't have meaningful storage */
 	if (is_typedef) {
-		ctype.modifiers &= ~MOD_STORAGE;
+		saved.modifiers &= ~MOD_STORAGE;
 		decl->ctype.modifiers &= ~MOD_STORAGE;
 		decl->ctype.modifiers |= MOD_USERTYPE;
 	}
@@ -2345,7 +2345,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 		token = token->next;
 		ident = NULL;
 		decl = alloc_symbol(token->pos, SYM_NODE);
-		ctx.ctype = ctype;
+		ctx.ctype = saved;
 		token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE);
 		token = declarator(token, &ctx);
 		token = handle_attributes(token, &ctx.ctype, KW_ATTRIBUTE | KW_ASM);
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/7] Warn about non-empty identifier list outside of definition ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 6/7] Warn about non-empty identifier list outside of definition
Date: Sat, 14 Feb 2009 12:25:55 +0000
Message-ID: <E1LYJal-0001pS-LD () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                         |   12 ++++++++++--
 validation/nested-declarator2.c |   14 ++++++++------
 2 files changed, 18 insertions(+), 8 deletions(-)

diff --git a/parse.c b/parse.c
index 70cf2fb..9fe87e6 100644
--- a/parse.c
+++ b/parse.c
@@ -1271,8 +1271,16 @@ static enum kind which_kind(struct token *token, struct token **p,
 	if (token_type(next) == TOKEN_IDENT) {
 		if (lookup_type(next))
 			return (dont_nest || prefer_abstract) ? Proto : Nested;
-		if (dont_nest)
-			return (next == token->next) ? K_R : Bad_Func;
+		if (dont_nest) {
+			/* attributes in the K&R identifier list */
+			if (next != token->next)
+				return Bad_Func;
+			/* identifier list not in definition; complain */
+			if (prefer_abstract)
+				warning(token->pos,
+					"identifier list not in definition");
+			return K_R;
+		}
 		return Nested;
 	}
 
diff --git a/validation/nested-declarator2.c b/validation/nested-declarator2.c
index 700c802..795d01f 100644
--- a/validation/nested-declarator2.c
+++ b/validation/nested-declarator2.c
@@ -21,6 +21,7 @@ int y;
 static void w2(int ());
 static void w3(...);
 static void f9(__attribute__((mode(DI))) T);
+static void w4(int f(x,y));
 static void bad1(__attribute__((mode(DI))) x);
 static int (-bad2);
 static void [2](*bad3);
@@ -30,11 +31,12 @@ static void [2](*bad3);
 nested-declarator2.c:17:1: warning: non-ANSI definition of function 'w1'
 nested-declarator2.c:21:21: warning: non-ANSI function declaration of function '<noident>'
 nested-declarator2.c:22:16: warning: variadic functions must have one named argument
-nested-declarator2.c:24:44: error: Expected ) in function declarator
-nested-declarator2.c:24:44: error: got x
-nested-declarator2.c:25:13: error: Expected ) in nested declarator
-nested-declarator2.c:25:13: error: got -
-nested-declarator2.c:26:17: error: Expected ) in function declarator
-nested-declarator2.c:26:17: error: got *
+nested-declarator2.c:24:21: warning: identifier list not in definition
+nested-declarator2.c:25:44: error: Expected ) in function declarator
+nested-declarator2.c:25:44: error: got x
+nested-declarator2.c:26:13: error: Expected ) in nested declarator
+nested-declarator2.c:26:13: error: got -
+nested-declarator2.c:27:17: error: Expected ) in function declarator
+nested-declarator2.c:27:17: error: got *
  * check-error-end:
  */
-- 
1.5.6.6


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/18] Fix regression created by commit af30c6df74f01db10fa78ac0cbdb5c3c40b5c73f ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 7/18] Fix regression created by commit af30c6df74f01db10fa78ac0cbdb5c3c40b5c73f
Date: Mon, 09 Mar 2009 07:11:18 +0000
Message-ID: <E1LgZdu-0000tv-13 () ZenIV ! linux ! org ! uk>
--------------------

const and friends are reserved words, TYVM...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c               |    2 ++
 validation/reserved.c |   40 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 42 insertions(+), 0 deletions(-)
 create mode 100644 validation/reserved.c

diff --git a/parse.c b/parse.c
index a2048a2..12d2bba 100644
--- a/parse.c
+++ b/parse.c
@@ -354,6 +354,8 @@ void init_parser(int stream)
 		struct init_keyword *ptr = keyword_table + i;
 		struct symbol *sym = create_symbol(stream, ptr->name, SYM_KEYWORD, ptr->ns);
 		sym->ident->keyword = 1;
+		if (ptr->ns == NS_TYPEDEF)
+			sym->ident->reserved = 1;
 		sym->ctype.modifiers = ptr->modifiers;
 		sym->op = ptr->op;
 	}
diff --git a/validation/reserved.c b/validation/reserved.c
new file mode 100644
index 0000000..caacd21
--- /dev/null
+++ b/validation/reserved.c
@@ -0,0 +1,40 @@
+static int (struct);
+static int (union);
+static int (enum);
+static int (volatile);
+static int (__volatile);
+static int (__volatile__);
+static int (const);
+static int (__const);
+static int (__const__);
+static int (restrict);
+static int (__restrict);
+static int (__restrict__);
+static int (typedef);
+static int (__typeof);
+static int (__typeof__);
+static int (inline);
+static int (__inline);
+static int (__inline__);
+/*
+ * check-name: const et.al. are reserved identifiers
+ * check-error-start:
+reserved.c:1:12: error: Trying to use reserved word 'struct' as identifier
+reserved.c:2:12: error: Trying to use reserved word 'union' as identifier
+reserved.c:3:12: error: Trying to use reserved word 'enum' as identifier
+reserved.c:4:12: error: Trying to use reserved word 'volatile' as identifier
+reserved.c:5:12: error: Trying to use reserved word '__volatile' as identifier
+reserved.c:6:12: error: Trying to use reserved word '__volatile__' as identifier
+reserved.c:7:12: error: Trying to use reserved word 'const' as identifier
+reserved.c:8:12: error: Trying to use reserved word '__const' as identifier
+reserved.c:9:12: error: Trying to use reserved word '__const__' as identifier
+reserved.c:10:12: error: Trying to use reserved word 'restrict' as identifier
+reserved.c:11:12: error: Trying to use reserved word '__restrict' as identifier
+reserved.c:13:12: error: Trying to use reserved word 'typedef' as identifier
+reserved.c:14:12: error: Trying to use reserved word '__typeof' as identifier
+reserved.c:15:12: error: Trying to use reserved word '__typeof__' as identifier
+reserved.c:16:12: error: Trying to use reserved word 'inline' as identifier
+reserved.c:17:12: error: Trying to use reserved word '__inline' as identifier
+reserved.c:18:12: error: Trying to use reserved word '__inline__' as identifier
+ * check-error-end:
+ */
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/7] Apply attributes after ( to the right place ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 7/7] Apply attributes after ( to the right place
Date: Sat, 14 Feb 2009 12:26:05 +0000
Message-ID: <E1LYJav-0001pq-LQ () ZenIV ! linux ! org ! uk>
--------------------

In int f(__user int *p) __user applies to p, not to f...

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                        |   23 +++++++++++++++--------
 validation/attr_in_parameter.c |   12 ++++++++++++
 2 files changed, 27 insertions(+), 8 deletions(-)
 create mode 100644 validation/attr_in_parameter.c

diff --git a/parse.c b/parse.c
index 9fe87e6..3922ce3 100644
--- a/parse.c
+++ b/parse.c
@@ -1226,7 +1226,7 @@ static struct token *abstract_array_declarator(struct token *token, struct symbo
 	return token;
 }
 
-static struct token *parameter_type_list(struct token *, struct symbol *);
+static struct token *parameter_type_list(struct token *, struct symbol *, struct ctype *);
 static struct token *identifier_list(struct token *, struct symbol *);
 static struct token *declarator(struct token *token, struct symbol *sym, struct ident **p, int);
 
@@ -1324,13 +1324,16 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
 		if (token->special == '(') {
 			struct symbol *sym;
 			struct token *next;
-			enum kind kind = which_kind(token, &next, p, ctype,
+			struct ctype thistype = {0, };
+			enum kind kind = which_kind(token, &next, p, &thistype,
 						dont_nest, prefer_abstract);
 
 			dont_nest = 1;
 
 			if (kind == Nested) {
 				struct symbol *base_type = ctype->base_type;
+				if (token->next != next)
+					apply_ctype(token->pos, &thistype, ctype);
 				token = declarator(next, decl, p, prefer_abstract);
 				token = expect(token, ')', "in nested declarator");
 				while (ctype->base_type != base_type)
@@ -1350,7 +1353,9 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
 			if (kind == K_R) {
 				next = identifier_list(next, sym);
 			} else if (kind == Proto) {
-				next = parameter_type_list(next, sym);
+				struct ctype *t;
+				t = (token->next == next ? NULL : &thistype);
+				next = parameter_type_list(next, sym, t);
 			}
 			token = expect(next, ')', "in function declarator");
 			sym->endpos = token->pos;
@@ -1495,12 +1500,14 @@ static struct token *struct_declaration_list(struct token *token, struct symbol_
 	return token;
 }
 
-static struct token *parameter_declaration(struct token *token, struct symbol **tree)
+static struct token *parameter_declaration(struct token *token, struct symbol **tree, struct ctype *pending)
 {
 	struct ident *ident = NULL;
 	struct symbol *sym;
-	struct ctype ctype = { 0, };
+	struct ctype ctype = {0, };
 
+	if (pending)
+		apply_ctype(token->pos, pending, &ctype);
 	token = declaration_specifiers(token, &ctype, 0);
 	sym = alloc_symbol(token->pos, SYM_NODE);
 	sym->ctype = ctype;
@@ -2017,7 +2024,7 @@ static struct token *identifier_list(struct token *token, struct symbol *fn)
 	return token;
 }
 
-static struct token *parameter_type_list(struct token *token, struct symbol *fn)
+static struct token *parameter_type_list(struct token *token, struct symbol *fn, struct ctype *pending)
 {
 	struct symbol_list **list = &fn->arguments;
 
@@ -2031,7 +2038,7 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn)
 		}
 
 		sym = alloc_symbol(token->pos, SYM_NODE);
-		token = parameter_declaration(token, &sym);
+		token = parameter_declaration(token, &sym, pending);
 		if (sym->ctype.base_type == &void_ctype) {
 			/* Special case: (void) */
 			if (!*list && !sym->ident)
@@ -2043,7 +2050,7 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn)
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
-
+		pending = NULL;
 	}
 	return token;
 }
diff --git a/validation/attr_in_parameter.c b/validation/attr_in_parameter.c
new file mode 100644
index 0000000..1b104ea
--- /dev/null
+++ b/validation/attr_in_parameter.c
@@ -0,0 +1,12 @@
+#define A __attribute__((address_space(1)))
+static int (A *p);
+static int A *q;
+static void (*f)(A int *x, A int *y) = (void *)0;
+static void g(int A *x)
+{
+	f(x, x);
+	p = q;
+}
+/*
+ * check-name: attribute after ( in direct-declarator
+ */
-- 
1.5.6.6

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 8/18] Take the rest of storage class keywords to parse.c ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [PATCH 8/18] Take the rest of storage class keywords to parse.c
Date: Mon, 09 Mar 2009 07:11:28 +0000
Message-ID: <E1LgZe4-0000uZ-1F () ZenIV ! linux ! org ! uk>
--------------------

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c  |    6 ++++++
 symbol.c |    6 ------
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/parse.c b/parse.c
index 12d2bba..7b1cfb6 100644
--- a/parse.c
+++ b/parse.c
@@ -231,6 +231,12 @@ static struct init_keyword {
 	{ "restrict",	NS_TYPEDEF, .op = &qualifier_op},
 	{ "__restrict",	NS_TYPEDEF, .op = &qualifier_op},
 
+	/* Storage class */
+	{ "auto",	NS_TYPEDEF, MOD_AUTO, .op = &modifier_op },
+	{ "register",	NS_TYPEDEF, MOD_REGISTER, .op = &modifier_op },
+	{ "static",	NS_TYPEDEF, MOD_STATIC, .op = &modifier_op },
+	{ "extern",	NS_TYPEDEF, MOD_EXTERN, .op = &modifier_op },
+
 	/* Statement */
 	{ "if",		NS_KEYWORD, .op = &if_op },
 	{ "return",	NS_KEYWORD, .op = &return_op },
diff --git a/symbol.c b/symbol.c
index c82e530..8a323b5 100644
--- a/symbol.c
+++ b/symbol.c
@@ -700,12 +700,6 @@ static struct sym_init {
 	unsigned int modifiers;
 	struct symbol_op *op;
 } symbol_init_table[] = {
-	/* Storage class */
-	{ "auto",	NULL,		MOD_AUTO },
-	{ "register",	NULL,		MOD_REGISTER },
-	{ "static",	NULL,		MOD_STATIC },
-	{ "extern",	NULL,		MOD_EXTERN },
-
 	/* Type specifiers */
 	{ "void",	&void_ctype,	0 },
 	{ "char",	NULL,		MOD_CHAR },
-- 
1.5.6.5


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH-v2 2/4] Replace SYM_ and MOD_ #defines with enums in ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH-v2 2/4] Replace SYM_ and MOD_ #defines with enums in
Date: Tue, 02 Jun 2009 20:44:20 +0000
Message-ID: <70318cbf0906021344w2adcf585g7d7adcd320d66fa9 () mail ! gmail ! com>
--------------------
On Mon, Jun 1, 2009 at 11:37 AM, Samuel Bronson <naesten@gmail.com> wrote:
> Adjust the associated fields to match. While we're here, change
> some nearby bitfields from "char" to "int" so GDB doesn't bother
> showing character literals for them.

> +enum modifier {
> +       MOD_AUTO        = 1 << 0,

The patch does not apply to my tree. The modifier is definitely not
an enum because we apply bit operation to it.

Changing bitfield from "char" to "int" has risk of making the symbol
struct bigger. We don't want that because symbol is a very common
structure for sparse.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH-v2 2/4] Replace SYM_ and MOD_ #defines with enums in
Date: Thu, 04 Jun 2009 19:24:09 +0000
Message-ID: <70318cbf0906041224v21bb1f27h57fc077f7a246f27 () mail ! gmail ! com>
--------------------
On Tue, Jun 2, 2009 at 8:43 PM, Samuel Bronson <naesten@gmail.com> wrote:

> Hmm, which tree is yours? I pulled from
> git://git.kernel.org/pub/scm/devel/sparse/sparse.git


I have a development tree for sparse at:

http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=summary

> As for the bit operations, those are perfectly legal for enum values,
> and there are two similar enum types defined in this very header:

But they are simple assign, they don't have the following

+       MOD_NONLOCAL    = (MOD_EXTERN | MOD_TOPLEVEL),
+       MOD_STORAGE     = (MOD_AUTO | MOD_REGISTER | MOD_STATIC |
MOD_EXTERN | MOD_INLINE | MOD_TOPLEVEL | MOD_FORCE),
+       MOD_SIGNEDNESS  = (MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED),
+       MOD_SPECIFIER   = (MOD_CHAR | MOD_SHORT | MOD_LONG |
MOD_LONGLONG | MOD_SIGNEDNESS),
+       MOD_SIZE        = (MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG),
+       MOD_IGNORE      = (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |
+                          MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED
| MOD_EXPLICITLY_SIGNED),
+       MOD_PTRINHERIT  = (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE)

Same can apply to pretty much all constant defines. It doesn't mean
that we should replace all constant defines into enum. There is no actual
benefit for people who runs sparse.

>> Changing bitfield from "char" to "int" has risk of making the symbol
>> struct bigger. We don't want that because symbol is a very common
>> structure for sparse.
>
> When could this actually happen? Here (on i386), pahole says this:

You answer yourself, it is implementation defined. Most of the people
just run sparse. They don't benefit from your change. Personally I think
how gdb print them is not a big deal. No worth to risk it.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix implicit cast to float (Was:Re: Initializing float ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix implicit cast to float (Was:Re: Initializing float
Date: Mon, 09 Feb 2009 07:37:50 +0000
Message-ID: <70318cbf0902082337r250543c8ic94c0f8f6517565a () mail ! gmail ! com>
--------------------
--000e0cd20a32a0f3bf04627772f9
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

On Fri, Feb 6, 2009 at 4:51 AM, Thomas Schmid
<Thomas.Schmid@br-automation.com> wrote:
> christ.li@gmail.com schrieb am 06.02.2009 05:15:37:
> -       if (newtype->ctype.base_type != &fp_type) {
> +       if (is_int_type(newtype)) {

I change your patch a little bit. The old logic of testing against float
type is better. The type can be a pointer for example. Then using
the long long value is more correct.

See the patch attached.

If there is not objections. I am going to apply this one.

Chris

--000e0cd20a32a0f3bf04627772f9
Content-Type: application/octet-stream; 
	name="Fix-implicit-cast-to-float-Was-Re-Initializing-float-variables-without-type-suffix.patch"
Content-Disposition: attachment; 
	filename="Fix-implicit-cast-to-float-Was-Re-Initializing-float-variables-without-type-suffix.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fqycrjpo0

RnJvbSBwYXRjaHdvcmsgRnJpIEZlYiAgNiAxMjo1MTozNCAyMDA5CkNvbnRlbnQtVHlwZTogdGV4
dC9wbGFpbjsgY2hhcnNldD0idXRmLTgiCk1JTUUtVmVyc2lvbjogMS4wCkNvbnRlbnQtVHJhbnNm
ZXItRW5jb2Rpbmc6IDdiaXQKU3ViamVjdDogRml4IGltcGxpY2l0IGNhc3QgdG8gZmxvYXQgKFdh
czpSZTogSW5pdGlhbGl6aW5nIGZsb2F0IHZhcmlhYmxlcwoJd2l0aG91dCB0eXBlIHN1ZmZpeCkK
RGF0ZTogRnJpLCAwNiBGZWIgMjAwOSAxMjo1MTozNCAtMDAwMApGcm9tOiBUaG9tYXMgU2NobWlk
IDxUaG9tYXMuU2NobWlkQGJyLWF1dG9tYXRpb24uY29tPgpYLVBhdGNod29yay1JZDogNTg3NAoK
Y2hyaXN0LmxpQGdtYWlsLmNvbSBzY2hyaWViIGFtIDA2LjAyLjIwMDkgMDU6MTU6Mzc6Cgo+IGNh
c3RfdG8oKSBzZWVtcyBmaW5lLgo+IAo+IEluIGV4cGFuZGluZyBzdGFnZSwgY2FzdF92YWx1ZSgp
IGRpZCBub3QgY2FzdCB0aGUgY29uc3RhbnQKPiBjb3JyZWN0bHkuCgpZb3UncmUgcmlnaHQsIEkg
YWxzbyBub3RpY2VkIHRoaXMgaW4gdGhlIG1lYW50aW1lLgoKVGhlIGRlY2lzaW9uLCB3aGV0aGVy
IG5ld3R5cGUgaXMgaW50X3R5cGUgb3IgZnBfdHlwZSBpcyBub3QgbWFkZSAKY29ycmVjdGx5LgoK
VGhlIGZvbGxvd2luZyBwYXRjaCBzZWVtcyB0byB3b3JrOgoKRml4IGltcGxpY2l0IGNhc3QgdG8g
ZmxvYXQKCk1vZGlmaWVkIGJ5IENocmlzLgoKU2lnbmVkLU9mZi1CeTogVGhvbWFzIFNjaG1pZCA8
VGhvbWFzLlNjaG1pZEBici1hdXRvbWF0aW9uLmNvbT4KU2lnbmVkLU9mZi1CeTogQ2hyaXN0b3Bo
ZXIgTGkgPHNwYXJzZUBjaHJpc2xpLm9yZz4KCi0tClRvIHVuc3Vic2NyaWJlIGZyb20gdGhpcyBs
aXN0OiBzZW5kIHRoZSBsaW5lICJ1bnN1YnNjcmliZSBsaW51eC1zcGFyc2UiIGluCnRoZSBib2R5
IG9mIGEgbWVzc2FnZSB0byBtYWpvcmRvbW9Admdlci5rZXJuZWwub3JnCk1vcmUgbWFqb3Jkb21v
IGluZm8gYXQgIGh0dHA6Ly92Z2VyLmtlcm5lbC5vcmcvbWFqb3Jkb21vLWluZm8uaHRtbAoKSW5k
ZXg6IHNwYXJzZS5jaHJpc2wvZXZhbHVhdGUuYwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ci0tLSBzcGFyc2UuY2hyaXNs
Lm9yaWcvZXZhbHVhdGUuYworKysgc3BhcnNlLmNocmlzbC9ldmFsdWF0ZS5jCkBAIC0zMTMsMzcg
KzMxMyw2IEBAIHN0YXRpYyBzdHJ1Y3QgZXhwcmVzc2lvbiAqIGNhc3RfdG8oc3RydWMKIAlyZXR1
cm4gZXhwcjsKIH0KIAotc3RhdGljIGludCBpc190eXBlX3R5cGUoc3RydWN0IHN5bWJvbCAqdHlw
ZSkKLXsKLQlyZXR1cm4gKHR5cGUtPmN0eXBlLm1vZGlmaWVycyAmIE1PRF9UWVBFKSAhPSAwOwot
fQotCi1pbnQgaXNfcHRyX3R5cGUoc3RydWN0IHN5bWJvbCAqdHlwZSkKLXsKLQlpZiAodHlwZS0+
dHlwZSA9PSBTWU1fTk9ERSkKLQkJdHlwZSA9IHR5cGUtPmN0eXBlLmJhc2VfdHlwZTsKLQlyZXR1
cm4gdHlwZS0+dHlwZSA9PSBTWU1fUFRSIHx8IHR5cGUtPnR5cGUgPT0gU1lNX0FSUkFZIHx8IHR5
cGUtPnR5cGUgPT0gU1lNX0ZOOwotfQotCi1zdGF0aWMgaW5saW5lIGludCBpc19mbG9hdF90eXBl
KHN0cnVjdCBzeW1ib2wgKnR5cGUpCi17Ci0JaWYgKHR5cGUtPnR5cGUgPT0gU1lNX05PREUpCi0J
CXR5cGUgPSB0eXBlLT5jdHlwZS5iYXNlX3R5cGU7Ci0JcmV0dXJuIHR5cGUtPmN0eXBlLmJhc2Vf
dHlwZSA9PSAmZnBfdHlwZTsKLX0KLQotc3RhdGljIGlubGluZSBpbnQgaXNfYnl0ZV90eXBlKHN0
cnVjdCBzeW1ib2wgKnR5cGUpCi17Ci0JcmV0dXJuIHR5cGUtPmJpdF9zaXplID09IGJpdHNfaW5f
Y2hhciAmJiB0eXBlLT50eXBlICE9IFNZTV9CSVRGSUVMRDsKLX0KLQotc3RhdGljIGlubGluZSBp
bnQgaXNfdm9pZF90eXBlKHN0cnVjdCBzeW1ib2wgKnR5cGUpCi17Ci0JaWYgKHR5cGUtPnR5cGUg
PT0gU1lNX05PREUpCi0JCXR5cGUgPSB0eXBlLT5jdHlwZS5iYXNlX3R5cGU7Ci0JcmV0dXJuIHR5
cGUgPT0gJnZvaWRfY3R5cGU7Ci19Ci0KIGVudW0gewogCVRZUEVfTlVNID0gMSwKIAlUWVBFX0JJ
VEZJRUxEID0gMiwKSW5kZXg6IHNwYXJzZS5jaHJpc2wvZXhwYW5kLmMKPT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0g
c3BhcnNlLmNocmlzbC5vcmlnL2V4cGFuZC5jCisrKyBzcGFyc2UuY2hyaXNsL2V4cGFuZC5jCkBA
IC0xMTYsMTcgKzExNiwxNyBAQCBJbnQ6CiAJcmV0dXJuOwogCiBGbG9hdDoKLQlpZiAobmV3dHlw
ZS0+Y3R5cGUuYmFzZV90eXBlICE9ICZmcF90eXBlKSB7CisJaWYgKCFpc19mbG9hdF90eXBlKG5l
d3R5cGUpKSB7CiAJCXZhbHVlID0gKGxvbmcgbG9uZylvbGQtPmZ2YWx1ZTsKIAkJZXhwci0+dHlw
ZSA9IEVYUFJfVkFMVUU7CiAJCWV4cHItPnRhaW50ID0gMDsKIAkJZ290byBJbnQ7CiAJfQogCi0J
aWYgKG9sZHR5cGUtPmN0eXBlLmJhc2VfdHlwZSAhPSAmZnBfdHlwZSkKKwlpZiAoIWlzX2Zsb2F0
X3R5cGUob2xkdHlwZSkpCiAJCWV4cHItPmZ2YWx1ZSA9IChsb25nIGRvdWJsZSlnZXRfbG9uZ2xv
bmcob2xkKTsKIAllbHNlCi0JCWV4cHItPmZ2YWx1ZSA9IG9sZC0+dmFsdWU7CisJCWV4cHItPmZ2
YWx1ZSA9IG9sZC0+ZnZhbHVlOwogCiAJaWYgKCEobmV3dHlwZS0+Y3R5cGUubW9kaWZpZXJzICYg
TU9EX0xPTkdMT05HKSkgewogCQlpZiAoKG5ld3R5cGUtPmN0eXBlLm1vZGlmaWVycyAmIE1PRF9M
T05HKSkKSW5kZXg6IHNwYXJzZS5jaHJpc2wvc3ltYm9sLmgKPT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQotLS0gc3BhcnNl
LmNocmlzbC5vcmlnL3N5bWJvbC5oCisrKyBzcGFyc2UuY2hyaXNsL3N5bWJvbC5oCkBAIC0xMCw2
ICsxMCw3IEBACiAgKi8KIAogI2luY2x1ZGUgInRva2VuLmgiCisjaW5jbHVkZSAidGFyZ2V0Lmgi
CiAKIC8qCiAgKiBBbiBpZGVudGlmaWVyIHdpdGggc2VtYW50aWMgbWVhbmluZyBpcyBhICJzeW1i
b2wiLgpAQCAtMjk3LDYgKzI5OCwzNyBAQCBzdGF0aWMgaW5saW5lIGludCBpc19lbnVtX3R5cGUo
Y29uc3Qgc3RyCiAJcmV0dXJuICh0eXBlLT50eXBlID09IFNZTV9FTlVNKTsKIH0KIAorc3RhdGlj
IGlubGluZSBpbnQgaXNfdHlwZV90eXBlKHN0cnVjdCBzeW1ib2wgKnR5cGUpCit7CisJcmV0dXJu
ICh0eXBlLT5jdHlwZS5tb2RpZmllcnMgJiBNT0RfVFlQRSkgIT0gMDsKK30KKworc3RhdGljIGlu
bGluZSBpbnQgaXNfcHRyX3R5cGUoc3RydWN0IHN5bWJvbCAqdHlwZSkKK3sKKwlpZiAodHlwZS0+
dHlwZSA9PSBTWU1fTk9ERSkKKwkJdHlwZSA9IHR5cGUtPmN0eXBlLmJhc2VfdHlwZTsKKwlyZXR1
cm4gdHlwZS0+dHlwZSA9PSBTWU1fUFRSIHx8IHR5cGUtPnR5cGUgPT0gU1lNX0FSUkFZIHx8IHR5
cGUtPnR5cGUgPT0gU1lNX0ZOOworfQorCitzdGF0aWMgaW5saW5lIGludCBpc19mbG9hdF90eXBl
KHN0cnVjdCBzeW1ib2wgKnR5cGUpCit7CisJaWYgKHR5cGUtPnR5cGUgPT0gU1lNX05PREUpCisJ
CXR5cGUgPSB0eXBlLT5jdHlwZS5iYXNlX3R5cGU7CisJcmV0dXJuIHR5cGUtPmN0eXBlLmJhc2Vf
dHlwZSA9PSAmZnBfdHlwZTsKK30KKworc3RhdGljIGlubGluZSBpbnQgaXNfYnl0ZV90eXBlKHN0
cnVjdCBzeW1ib2wgKnR5cGUpCit7CisJcmV0dXJuIHR5cGUtPmJpdF9zaXplID09IGJpdHNfaW5f
Y2hhciAmJiB0eXBlLT50eXBlICE9IFNZTV9CSVRGSUVMRDsKK30KKworc3RhdGljIGlubGluZSBp
bnQgaXNfdm9pZF90eXBlKHN0cnVjdCBzeW1ib2wgKnR5cGUpCit7CisJaWYgKHR5cGUtPnR5cGUg
PT0gU1lNX05PREUpCisJCXR5cGUgPSB0eXBlLT5jdHlwZS5iYXNlX3R5cGU7CisJcmV0dXJuIHR5
cGUgPT0gJnZvaWRfY3R5cGU7Cit9CisKIHN0YXRpYyBpbmxpbmUgaW50IGdldF9zeW1fdHlwZShz
dHJ1Y3Qgc3ltYm9sICp0eXBlKQogewogCWlmICh0eXBlLT50eXBlID09IFNZTV9OT0RFKQo=
--000e0cd20a32a0f3bf04627772f9--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix incorrect linearization of "x && y && z" ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix incorrect linearization of "x && y && z"
Date: Wed, 28 Oct 2009 22:48:43 +0000
Message-ID: <70318cbf0910281548j23167f7anf968b29b9ef34067 () mail ! gmail ! com>
--------------------
On Tue, Oct 27, 2009 at 4:02 PM, Daniel De Graaf
<danieldegraaf@gmail.com> wrote:
> This fixes an incorrect assumption that results in && using shortcut
> logic on the true branch instead of the false branch.

Good catch. Thanks!
I applied it without the "else" line.

Chris

PS. I almost miss this email because it is send to "unlisted-recipients".
My patch tool catches it though.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Ignore the alloc_size attribute. ===

From: Michael Stefaniuc <mstefaniuc () gmail ! com>
To: linux-sparse
Subject: [PATCH] Ignore the alloc_size attribute.
Date: Wed, 30 Sep 2009 20:19:30 +0000
Message-ID: <20090930201930.GB32461 () redhat ! com>
--------------------
Wine has annotated the Win32 alloc functions with the alloc_size
attribute. This cuts down the noise a lot when running sparse on the
Wine source code.

Signed-off-by: Michael Stefaniuc <mstefaniuc@gmail.com>
---
Resend for the chrisl tree.


 parse.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/parse.c b/parse.c
index fa3b45e..c3f9b6a 100644
--- a/parse.c
+++ b/parse.c
@@ -475,6 +475,8 @@ static struct init_keyword {
 const char *ignored_attributes[] = {
 	"alias",
 	"__alias__",
+	"alloc_size",
+	"__alloc_size__",
 	"always_inline",
 	"__always_inline__",
 	"bounded",
-- 
1.6.5.rc2
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Ignore the alloc_size attribute.
Date: Wed, 30 Sep 2009 21:02:50 +0000
Message-ID: <70318cbf0909301402r37b56fc3q790107f48456f4b5 () mail ! gmail ! com>
--------------------
On Wed, Sep 30, 2009 at 1:19 PM, Michael Stefaniuc <mstefaniuc@gmail.com> wrote:
> Wine has annotated the Win32 alloc functions with the alloc_size
> attribute. This cuts down the noise a lot when running sparse on the
> Wine source code.

Both patches were applied and pushed.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Ignore the ms_abi/sysv_abi attributes. ===

From: Michael Stefaniuc <mstefaniuc () gmail ! com>
To: linux-sparse
Subject: [PATCH] Ignore the ms_abi/sysv_abi attributes.
Date: Wed, 30 Sep 2009 20:18:50 +0000
Message-ID: <20090930201850.GA32461 () redhat ! com>
--------------------
This is needed for getting a meaningful sparse run on a Wine 64-bit
compile. Else the basic Win32 headers will produce tons of
error: attribute 'ms_abi': unknown attribute
which end in
error: too many errors.

The sysv_abi attribute was just added for symmetry.

Signed-off-by: Michael Stefaniuc <mstefaniuc@gmail.com>
---
Resend for the chrisl tree.


 parse.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/parse.c b/parse.c
index 34fa562..fa3b45e 100644
--- a/parse.c
+++ b/parse.c
@@ -508,6 +508,8 @@ const char *ignored_attributes[] = {
 	"__malloc__",
 	"model",
 	"__model__",
+	"ms_abi",
+	"__ms_abi__",
 	"no_instrument_function",
 	"__no_instrument_function__",
 	"noinline",
@@ -530,6 +532,8 @@ const char *ignored_attributes[] = {
 	"__stdcall__",
 	"syscall_linkage",
 	"__syscall_linkage__",
+	"sysv_abi",
+	"__sysv_abi__",
 	"unused",
 	"__unused__",
 	"used",
-- 
1.6.5.rc2
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Makefile: fix permissions mixup on install ===

From: Dan McGee <dan () archlinux ! org>
To: linux-sparse
Subject: [PATCH] Makefile: fix permissions mixup on install
Date: Wed, 28 Oct 2009 00:46:08 +0000
Message-ID: <1256690768-2577-1-git-send-email-dan () archlinux ! org>
--------------------
`install` by default uses 755 permissions; for everything but executables we
want to use 644 permissions.

Signed-off-by: Dan McGee <dan@archlinux.org>
---
 Makefile |   15 +++++++++------
 1 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/Makefile b/Makefile
index 571673e..f6b0d2c 100644
--- a/Makefile
+++ b/Makefile
@@ -79,9 +79,12 @@ QUIET_LINK    = $(Q:@=@echo    '     LINK     '$@;)
 QUIET_INST_SH = $(Q:@=echo -n  '     INSTALL  ';)
 QUIET_INST    = $(Q:@=@echo -n '     INSTALL  ';)
 
-define INSTALL_CMD
+define INSTALL_PROG
 	$(Q)$(QUIET_INST_SH)install -v $1 $(DESTDIR)$2/$1 || exit 1;
+endef
 
+define INSTALL_OTHER
+	$(Q)$(QUIET_INST_SH)install -v -m 644 $1 $(DESTDIR)$2/$1 || exit 1;
 endef
 
 SED_PC_CMD = 's|@version@|$(VERSION)|g;		\
@@ -103,11 +106,11 @@ install: $(INST_PROGRAMS) $(LIBS) $(LIB_H) sparse.pc
 	$(Q)install -d $(DESTDIR)$(MAN1DIR)
 	$(Q)install -d $(DESTDIR)$(INCLUDEDIR)/sparse
 	$(Q)install -d $(DESTDIR)$(PKGCONFIGDIR)
-	$(foreach f,$(INST_PROGRAMS),$(call INSTALL_CMD,$f,$(BINDIR)))
-	$(foreach f,$(INST_MAN1),$(call INSTALL_CMD,$f,$(MAN1DIR)))
-	$(foreach f,$(LIBS),$(call INSTALL_CMD,$f,$(LIBDIR)))
-	$(foreach f,$(LIB_H),$(call INSTALL_CMD,$f,$(INCLUDEDIR)/sparse))
-	$(call INSTALL_CMD,sparse.pc,$(PKGCONFIGDIR))
+	$(foreach f,$(INST_PROGRAMS),$(call INSTALL_PROG,$f,$(BINDIR)))
+	$(foreach f,$(INST_MAN1),$(call INSTALL_OTHER,$f,$(MAN1DIR)))
+	$(foreach f,$(LIBS),$(call INSTALL_OTHER,$f,$(LIBDIR)))
+	$(foreach f,$(LIB_H),$(call INSTALL_OTHER,$f,$(INCLUDEDIR)/sparse))
+	$(call INSTALL_OTHER,sparse.pc,$(PKGCONFIGDIR))
 
 sparse.pc: sparse.pc.in
 	$(QUIET_GEN)sed $(SED_PC_CMD) sparse.pc.in > sparse.pc
-- 
1.6.5.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] New attribute designated_init: mark a struct as ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] New attribute designated_init: mark a struct as
Date: Sat, 10 Oct 2009 16:03:05 +0000
Message-ID: <20091010160304.GA11876 () feather>
--------------------
On Sat, Oct 10, 2009 at 03:33:20AM -0700, Christopher Li wrote:
> On Sat, Oct 10, 2009 at 1:58 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> > Some structure types provide a set of fields of which most users will
> > only initialize the subset they care about.  Users of these types should
> > always use designated initializers, to avoid relying on the specific
> > structure layout.  Examples of this type of structure include the many
> 
> The patch is very well written with nice documentations and test case.
> It applies and runs fine.
> 
> I am curious weather this is some thing the kernel developers want to
> use. Please speak up if you want to annotate the kernel structure to
> issue such warning. If some one use it, I have no problem adding it to
> sparse.

After getting this patch reviewed, I intended to add many such
annotations myself.  I have patches sitting in my local Linux tree.
(However, I don't plan to try to get the patches accepted into Linux
until this attribute shows up in a Sparse release, since I don't want to
make Linux require the latest Sparse from the git tree.)

> I am not sure how useful this is yet.  If the structure is changed, most
> likely the positional initialization will fail due to type mismatching.
> Some real life example how this feature can expose some otherwise
> hard to detect bug would be nice.

You *hope* that positional initialization will fail. :)  Some of these
types of structures contain many fields with the same or similar types,
and initializers don't inherently contain a lot of distinguishing type
information that helps cause type errors rather than silent failures.

Even if the positional initialization does fail, this failure will occur
at the time of attempting to change the structure, and many such
failures may occur all over the tree, making such changes significantly
more difficult.  With the designated_init attribute, sparse will warn
when attempting to create the structure initializer.

With the designated_init attribute, someone making changes to a
structure can check that Sparse produces no warnings about positional
initializers and then know that certain types of changes can occur
without having to check every initializer.  For instance, removing a
field will only require checking any initializer that initializes that
field, and the compiler will find all of those.  Adding a field that can
safely remain NULL does not require checking any initializers.

> With this approach, we need to annotate the kernel to benefit from it.
> Another idea is that we can find out how different part of the kernel
> initialize the same structure. If most of them using designated init then
> the few non-conforming can get a warning. This approach is more
> complicate.  But it does not need to change the kernel.

I agree that we could infer certain types of warnings by saying "99% of
the kernel does $FOO, but this bit of code doesn't".  Other static
analysis tools do similar things.  However, such analyses can easily
lead to false positives, and they prove far more difficult to implement.
Having an explicit attribute works now, and also provides useful
documentation of the intended use of a structure.

> > +                               warning(e->pos, "%s%s%spositional init of field in %s %s, declared with attribute designated_init",
> > +                                       ctype->ident ? "in initializer for " : "",
> > +                                       ctype->ident ? ctype->ident->name : "",
> 
> ident->name has no guarantee of terminating by NUL.
> You want to use "%.*s" with ident->size, ident->name here.

Good catch; will fix and send new patch.

(As an aside, though: any fundamental reason why we use that error-prone
approach rather than allocating one extra byte and NUL-terminating
idents?  Then we could drop the (larger) len field, and remove the
annoying restriction on calling show_ident multiple times in the same
statement.)

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] New attribute designated_init: mark a struct as
Date: Mon, 12 Oct 2009 06:42:33 +0000
Message-ID: <20091012064233.GB6370 () feather>
--------------------
On Sun, Oct 11, 2009 at 10:18:24PM -0700, Christopher Li wrote:
> On Sat, Oct 10, 2009 at 9:03 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> > After getting this patch reviewed, I intended to add many such
> > annotations myself.  I have patches sitting in my local Linux tree.
> > (However, I don't plan to try to get the patches accepted into Linux
> > until this attribute shows up in a Sparse release, since I don't want to
> > make Linux require the latest Sparse from the git tree.)
> 
> I apply your patch so you can have a fair chance to pitch to the
> kernel. If nobody use it, I can remove it later. I don't think you need
> to wait for the patch to go into sparse release to collect feed back
> from lkml.

Oh, definitely.  I just don't think the patches should actually get
accepted into Linux before the next Sparse release.  I certainly plan to
*submit* them. :)

Thanks for accepting the patch.

> > You *hope* that positional initialization will fail. :)  Some of these
> > types of structures contain many fields with the same or similar types,
> > and initializers don't inherently contain a lot of distinguishing type
> > information that helps cause type errors rather than silent failures.
> 
> I am very interested to know some precedence from the kernel commit history.
> If we can find such a commit which changes the structure and breaks
> other initialization due to the position initialization, it will make your
> case stronger as well.

I don't know of any cases in the commit history off the top of my head.
However, I do recall seeing this come up during LKML review comments on
patch, where the patch used positional initializers and the comments
suggested designated initializers.

> > Even if the positional initialization does fail, this failure will occur
> > at the time of attempting to change the structure, and many such
> > failures may occur all over the tree, making such changes significantly
> > more difficult.  With the designated_init attribute, sparse will warn
> > when attempting to create the structure initializer.
> 
> Without sparse, you can temporary  insert some unused strange type
> into the beginning of the struct. That should cause any position initializer
> fail to compile. You can then find call the call site.

Interesting idea!

However, again, this doesn't trigger the warning as soon as someone adds
a positional initializer; the person who wants to change the structure
will have to do this kind of work.  Warnings help ensure that those
types of changes get made by the person submitting potentially
problematic code, rather than the person who will trip over that code
later.  Warnings also reduce the load on patch reviewers, by making
certain types of issues less likely to make it to patch submission time,
and by letting reviewers suggest tools like sparse rather than having to
point out each new issue.

> > With the designated_init attribute, someone making changes to a
> > structure can check that Sparse produces no warnings about positional
> > initializers and then know that certain types of changes can occur
> > without having to check every initializer.  For instance, removing a
> > field will only require checking any initializer that initializes that
> > field, and the compiler will find all of those.  Adding a field that can
> > safely remain NULL does not require checking any initializers.
> 
> I think the initializer is just a small part of the work if you even change
> the structure. You need to make sure the *code* use these C struct
> actually works as expected.

Very true.  However, the types of structs for which the designated_init
attribute will prove useful often already follow semantics that avoid
the need to check the code.  For instance, as long as you know that a
field can safely remain 0 except in code that wants to use it, you can
add a new field without checking every designated initializer.

> > (As an aside, though: any fundamental reason why we use that error-prone
> > approach rather than allocating one extra byte and NUL-terminating
> > idents?  Then we could drop the (larger) len field, and remove the
> > annoying restriction on calling show_ident multiple times in the same
> > statement.)
> 
> When sparse does the hash table look up, if there is collision on the
> hash table entry, sparse will compare the size first before the memcmp().
> That will reduce the number of the memcmp call it makes. I would like to
> keep the size of struct ident. If any thing, we can NUL terminate the string
> in ident to make printing easy.

Fair enough on the hash comparisons, though I do wonder how much value
we get from that compared to a highly optimized memcmp implementation;
if the strings differ in the first 4 or 8 bytes, I'd expect memcmp to
notice after one comparison.  But even if we keep the length, requiring
NUL termination seems highly useful.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-kernel
Subject: Re: [PATCH] New attribute designated_init: mark a struct as
Date: Mon, 12 Oct 2009 06:42:33 +0000
Message-ID: <20091012064233.GB6370 () feather>
--------------------
On Sun, Oct 11, 2009 at 10:18:24PM -0700, Christopher Li wrote:
> On Sat, Oct 10, 2009 at 9:03 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> > After getting this patch reviewed, I intended to add many such
> > annotations myself.  I have patches sitting in my local Linux tree.
> > (However, I don't plan to try to get the patches accepted into Linux
> > until this attribute shows up in a Sparse release, since I don't want to
> > make Linux require the latest Sparse from the git tree.)
> 
> I apply your patch so you can have a fair chance to pitch to the
> kernel. If nobody use it, I can remove it later. I don't think you need
> to wait for the patch to go into sparse release to collect feed back
> from lkml.

Oh, definitely.  I just don't think the patches should actually get
accepted into Linux before the next Sparse release.  I certainly plan to
*submit* them. :)

Thanks for accepting the patch.

> > You *hope* that positional initialization will fail. :)  Some of these
> > types of structures contain many fields with the same or similar types,
> > and initializers don't inherently contain a lot of distinguishing type
> > information that helps cause type errors rather than silent failures.
> 
> I am very interested to know some precedence from the kernel commit history.
> If we can find such a commit which changes the structure and breaks
> other initialization due to the position initialization, it will make your
> case stronger as well.

I don't know of any cases in the commit history off the top of my head.
However, I do recall seeing this come up during LKML review comments on
patch, where the patch used positional initializers and the comments
suggested designated initializers.

> > Even if the positional initialization does fail, this failure will occur
> > at the time of attempting to change the structure, and many such
> > failures may occur all over the tree, making such changes significantly
> > more difficult.  With the designated_init attribute, sparse will warn
> > when attempting to create the structure initializer.
> 
> Without sparse, you can temporary  insert some unused strange type
> into the beginning of the struct. That should cause any position initializer
> fail to compile. You can then find call the call site.

Interesting idea!

However, again, this doesn't trigger the warning as soon as someone adds
a positional initializer; the person who wants to change the structure
will have to do this kind of work.  Warnings help ensure that those
types of changes get made by the person submitting potentially
problematic code, rather than the person who will trip over that code
later.  Warnings also reduce the load on patch reviewers, by making
certain types of issues less likely to make it to patch submission time,
and by letting reviewers suggest tools like sparse rather than having to
point out each new issue.

> > With the designated_init attribute, someone making changes to a
> > structure can check that Sparse produces no warnings about positional
> > initializers and then know that certain types of changes can occur
> > without having to check every initializer.  For instance, removing a
> > field will only require checking any initializer that initializes that
> > field, and the compiler will find all of those.  Adding a field that can
> > safely remain NULL does not require checking any initializers.
> 
> I think the initializer is just a small part of the work if you even change
> the structure. You need to make sure the *code* use these C struct
> actually works as expected.

Very true.  However, the types of structs for which the designated_init
attribute will prove useful often already follow semantics that avoid
the need to check the code.  For instance, as long as you know that a
field can safely remain 0 except in code that wants to use it, you can
add a new field without checking every designated initializer.

> > (As an aside, though: any fundamental reason why we use that error-prone
> > approach rather than allocating one extra byte and NUL-terminating
> > idents?  Then we could drop the (larger) len field, and remove the
> > annoying restriction on calling show_ident multiple times in the same
> > statement.)
> 
> When sparse does the hash table look up, if there is collision on the
> hash table entry, sparse will compare the size first before the memcmp().
> That will reduce the number of the memcmp call it makes. I would like to
> keep the size of struct ident. If any thing, we can NUL terminate the string
> in ident to make printing easy.

Fair enough on the hash comparisons, though I do wonder how much value
we get from that compared to a highly optimized memcmp implementation;
if the strings differ in the first 4 or 8 bytes, I'd expect memcmp to
notice after one comparison.  But even if we keep the length, requiring
NUL termination seems highly useful.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH] New attribute designated_init: mark a struct as requiring ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-kernel
Subject: [PATCH] New attribute designated_init: mark a struct as requiring
Date: Sat, 10 Oct 2009 08:31:07 +0000
Message-ID: <20091010083102.GA10581 () feather>
--------------------
Some structure types provide a set of fields of which most users will
only initialize the subset they care about.  Users of these types should
always use designated initializers, to avoid relying on the specific
structure layout.  Examples of this type of structure include the many
*_operations structures in Linux, which contain a set of function
pointers; these structures occasionally gain a new field, lose an
obsolete field, or change the function signature for a field.

Add a new attribute designated_init; when used on a struct, it tells
Sparse to warn on any positional initialization of a field in that
struct.

The new flag -Wdesignated-init controls these warnings.  Since these
warnings only fire for structures explicitly tagged with the attribute,
enable the warning by default.

Includes documentation and test case.

Signed-off-by: Josh Triplett <josh@joshtriplett.org>
---
 evaluate.c                   |    9 ++
 lib.c                        |    2 +
 lib.h                        |    1 +
 parse.c                      |   15 +++
 sparse.1                     |   24 +++++
 symbol.h                     |    3 +-
 validation/designated-init.c |  195 ++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 248 insertions(+), 1 deletions(-)
 create mode 100644 validation/designated-init.c

diff --git a/evaluate.c b/evaluate.c
index 805ae90..8e840a6 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2366,6 +2366,7 @@ static void handle_list_initializer(struct expression *expr,
 		int lclass;
 
 		if (e->type != EXPR_INDEX && e->type != EXPR_IDENTIFIER) {
+			struct symbol *struct_sym;
 			if (!top) {
 				top = e;
 				last = first_subobject(ctype, class, &top);
@@ -2378,6 +2379,14 @@ static void handle_list_initializer(struct expression *expr,
 				DELETE_CURRENT_PTR(e);
 				continue;
 			}
+			struct_sym = ctype->type == SYM_NODE ? ctype->ctype.base_type : ctype;
+			if (Wdesignated_init && struct_sym->designated_init)
+				warning(e->pos, "%s%s%spositional init of field in %s %s, declared with attribute designated_init",
+					ctype->ident ? "in initializer for " : "",
+					ctype->ident ? ctype->ident->name : "",
+					ctype->ident ? ": " : "",
+					get_type_name(struct_sym->type),
+					show_ident(struct_sym->ident));
 			if (jumped) {
 				warning(e->pos, "advancing past deep designator");
 				jumped = 0;
diff --git a/lib.c b/lib.c
index 622b547..77a1c33 100644
--- a/lib.c
+++ b/lib.c
@@ -197,6 +197,7 @@ int Wcast_truncate = 1;
 int Wcontext = 1;
 int Wdecl = 1;
 int Wdefault_bitfield_sign = 0;
+int Wdesignated_init = 1;
 int Wdo_while = 0;
 int Wenum_mismatch = 1;
 int Wnon_pointer_null = 1;
@@ -378,6 +379,7 @@ static const struct warning {
 	{ "context", &Wcontext },
 	{ "decl", &Wdecl },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
+	{ "designated-init", &Wdesignated_init },
 	{ "do-while", &Wdo_while },
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "non-pointer-null", &Wnon_pointer_null },
diff --git a/lib.h b/lib.h
index 25abb80..3ced1bf 100644
--- a/lib.h
+++ b/lib.h
@@ -97,6 +97,7 @@ extern int Wcast_truncate;
 extern int Wcontext;
 extern int Wdecl;
 extern int Wdefault_bitfield_sign;
+extern int Wdesignated_init;
 extern int Wdo_while;
 extern int Wenum_mismatch;
 extern int Wnon_pointer_null;
diff --git a/parse.c b/parse.c
index 5e75242..03fa5d9 100644
--- a/parse.c
+++ b/parse.c
@@ -64,6 +64,7 @@ typedef struct token *attr_t(struct token *, struct symbol *,
 static attr_t
 	attribute_packed, attribute_aligned, attribute_modifier,
 	attribute_address_space, attribute_context,
+	attribute_designated_init,
 	attribute_transparent_union, ignore_attribute,
 	attribute_mode, attribute_force;
 
@@ -319,6 +320,10 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
+static struct symbol_op designated_init_op = {
+	.attribute = attribute_designated_init,
+};
+
 static struct symbol_op transparent_union_op = {
 	.attribute = attribute_transparent_union,
 };
@@ -453,6 +458,7 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
+	{ "designated_init",	NS_KEYWORD,	.op = &designated_init_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
@@ -1127,6 +1133,15 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 	return token;
 }
 
+static struct token *attribute_designated_init(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	if (ctx->ctype.base_type && ctx->ctype.base_type->type == SYM_STRUCT)
+		ctx->ctype.base_type->designated_init = 1;
+	else
+		warning(token->pos, "attribute designated_init applied to non-structure type");
+	return token;
+}
+
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	if (Wtransparent_union)
diff --git a/sparse.1 b/sparse.1
index d7fe444..1054712 100644
--- a/sparse.1
+++ b/sparse.1
@@ -134,6 +134,30 @@ explicitly.
 Sparse does not issue these warnings by default.
 .
 .TP
+.B \-Wdesignated\-init
+Warn about positional initialization of structs marked as requiring designated
+initializers.
+
+Sparse allows an attribute
+.BI __attribute__((designated_init))
+which marks a struct as requiring designated initializers.  Sparse will warn
+about positional initialization of a struct variable or struct literal of a
+type that has this attribute.
+
+Requiring designated initializers for a particular struct type will insulate
+code using that struct type from changes to the layout of the type, avoiding
+the need to change initializers for that type unless they initialize a removed
+or incompatibly changed field.
+
+Common examples of this type of struct include collections of function pointers
+for the implementations of a class of related operations, for which the default
+NULL for an unmentioned field in a designated initializer will correctly
+indicate the absence of that operation.
+
+Sparse issues these warnings by default.  To turn them off, use
+\fB\-Wno\-designated\-init\fR.
+.
+.TP
 .B \-Wdo\-while
 Warn about do-while loops that do not delimit the loop body with braces.
 
diff --git a/symbol.h b/symbol.h
index 60fdad0..83b3d4b 100644
--- a/symbol.h
+++ b/symbol.h
@@ -156,7 +156,8 @@ struct symbol {
 					examined:1,
 					expanding:1,
 					evaluated:1,
-					string:1;
+					string:1,
+					designated_init:1;
 			struct expression *array_size;
 			struct ctype ctype;
 			struct symbol_list *arguments;
diff --git a/validation/designated-init.c b/validation/designated-init.c
new file mode 100644
index 0000000..23423e9
--- /dev/null
+++ b/validation/designated-init.c
@@ -0,0 +1,195 @@
+struct s1 {
+	int x;
+	int y;
+};
+
+struct s2 {
+	int x;
+	int y;
+} __attribute__((designated_init));
+
+struct nest1 {
+	struct s1 s1;
+	struct s2 s2;
+};
+
+struct nest2 {
+	struct s1 s1;
+	struct s2 s2;
+} __attribute__((designated_init));
+
+static struct s1 s1_positional = { 5, 10 };
+static struct s1 s1_designated = { .x = 5, .y = 10 };
+static struct s2 s2_positional = { 5, 10 };
+static struct s2 s2_designated = { .x = 5, .y = 10 };
+static struct nest1 nest1_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest1 nest1_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest1 nest1_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest1 nest1_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+static struct nest2 nest2_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest2 nest2_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest2 nest2_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest2 nest2_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+
+static struct {
+	int x;
+	int y;
+} __attribute__((designated_init))
+	anon_positional = { 5, 10 },
+	anon_designated = { .x = 5, .y = 10};
+
+static struct s1 s1_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s2 s2_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s1 ret_s1_positional(void)
+{
+	return ((struct s1){ 5, 10 });
+}
+
+static struct s1 ret_s1_designated(void)
+{
+	return ((struct s1){ .x = 5, .y = 10 });
+}
+
+static struct s2 ret_s2_positional(void)
+{
+	return ((struct s2){ 5, 10 });
+}
+
+static struct s2 ret_s2_designated(void)
+{
+	return ((struct s2){ .x = 5, .y = 10 });
+}
+
+static struct nest1 ret_nest1_positional(void)
+{
+	return ((struct nest1){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_outer(void)
+{
+	return ((struct nest1){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_inner(void)
+{
+	return ((struct nest1){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_both(void)
+{
+	return ((struct nest1){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_positional(void)
+{
+	return ((struct nest2){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_outer(void)
+{
+	return ((struct nest2){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_inner(void)
+{
+	return ((struct nest2){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_both(void)
+{
+	return ((struct nest2){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+/*
+ * check-name: designated_init attribute
+ *
+ * check-error-start
+designated-init.c:23:36: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:23:39: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:42:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:43:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:50:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:51:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:62:29: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:62:32: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:71:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:71:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:30: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:33: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:130:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:131:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:146:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:147:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+ * check-error-end
+ */
-- 
1.6.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: [PATCH] New attribute designated_init: mark a struct as requiring
Date: Sat, 10 Oct 2009 08:58:32 +0000
Message-ID: <20091010085732.GA10923 () feather>
--------------------
Some structure types provide a set of fields of which most users will
only initialize the subset they care about.  Users of these types should
always use designated initializers, to avoid relying on the specific
structure layout.  Examples of this type of structure include the many
*_operations structures in Linux, which contain a set of function
pointers; these structures occasionally gain a new field, lose an
obsolete field, or change the function signature for a field.

Add a new attribute designated_init; when used on a struct, it tells
Sparse to warn on any positional initialization of a field in that
struct.

The new flag -Wdesignated-init controls these warnings.  Since these
warnings only fire for structures explicitly tagged with the attribute,
enable the warning by default.

Includes documentation and test case.

Signed-off-by: Josh Triplett <josh@joshtriplett.org>
---
Resent with the right list address this time...

 evaluate.c                   |    9 ++
 lib.c                        |    2 +
 lib.h                        |    1 +
 parse.c                      |   15 +++
 sparse.1                     |   24 +++++
 symbol.h                     |    3 +-
 validation/designated-init.c |  195 ++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 248 insertions(+), 1 deletions(-)
 create mode 100644 validation/designated-init.c

diff --git a/evaluate.c b/evaluate.c
index 805ae90..8e840a6 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2366,6 +2366,7 @@ static void handle_list_initializer(struct expression *expr,
 		int lclass;
 
 		if (e->type != EXPR_INDEX && e->type != EXPR_IDENTIFIER) {
+			struct symbol *struct_sym;
 			if (!top) {
 				top = e;
 				last = first_subobject(ctype, class, &top);
@@ -2378,6 +2379,14 @@ static void handle_list_initializer(struct expression *expr,
 				DELETE_CURRENT_PTR(e);
 				continue;
 			}
+			struct_sym = ctype->type == SYM_NODE ? ctype->ctype.base_type : ctype;
+			if (Wdesignated_init && struct_sym->designated_init)
+				warning(e->pos, "%s%s%spositional init of field in %s %s, declared with attribute designated_init",
+					ctype->ident ? "in initializer for " : "",
+					ctype->ident ? ctype->ident->name : "",
+					ctype->ident ? ": " : "",
+					get_type_name(struct_sym->type),
+					show_ident(struct_sym->ident));
 			if (jumped) {
 				warning(e->pos, "advancing past deep designator");
 				jumped = 0;
diff --git a/lib.c b/lib.c
index 622b547..77a1c33 100644
--- a/lib.c
+++ b/lib.c
@@ -197,6 +197,7 @@ int Wcast_truncate = 1;
 int Wcontext = 1;
 int Wdecl = 1;
 int Wdefault_bitfield_sign = 0;
+int Wdesignated_init = 1;
 int Wdo_while = 0;
 int Wenum_mismatch = 1;
 int Wnon_pointer_null = 1;
@@ -378,6 +379,7 @@ static const struct warning {
 	{ "context", &Wcontext },
 	{ "decl", &Wdecl },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
+	{ "designated-init", &Wdesignated_init },
 	{ "do-while", &Wdo_while },
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "non-pointer-null", &Wnon_pointer_null },
diff --git a/lib.h b/lib.h
index 25abb80..3ced1bf 100644
--- a/lib.h
+++ b/lib.h
@@ -97,6 +97,7 @@ extern int Wcast_truncate;
 extern int Wcontext;
 extern int Wdecl;
 extern int Wdefault_bitfield_sign;
+extern int Wdesignated_init;
 extern int Wdo_while;
 extern int Wenum_mismatch;
 extern int Wnon_pointer_null;
diff --git a/parse.c b/parse.c
index 5e75242..03fa5d9 100644
--- a/parse.c
+++ b/parse.c
@@ -64,6 +64,7 @@ typedef struct token *attr_t(struct token *, struct symbol *,
 static attr_t
 	attribute_packed, attribute_aligned, attribute_modifier,
 	attribute_address_space, attribute_context,
+	attribute_designated_init,
 	attribute_transparent_union, ignore_attribute,
 	attribute_mode, attribute_force;
 
@@ -319,6 +320,10 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
+static struct symbol_op designated_init_op = {
+	.attribute = attribute_designated_init,
+};
+
 static struct symbol_op transparent_union_op = {
 	.attribute = attribute_transparent_union,
 };
@@ -453,6 +458,7 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
+	{ "designated_init",	NS_KEYWORD,	.op = &designated_init_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
@@ -1127,6 +1133,15 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 	return token;
 }
 
+static struct token *attribute_designated_init(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	if (ctx->ctype.base_type && ctx->ctype.base_type->type == SYM_STRUCT)
+		ctx->ctype.base_type->designated_init = 1;
+	else
+		warning(token->pos, "attribute designated_init applied to non-structure type");
+	return token;
+}
+
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	if (Wtransparent_union)
diff --git a/sparse.1 b/sparse.1
index d7fe444..1054712 100644
--- a/sparse.1
+++ b/sparse.1
@@ -134,6 +134,30 @@ explicitly.
 Sparse does not issue these warnings by default.
 .
 .TP
+.B \-Wdesignated\-init
+Warn about positional initialization of structs marked as requiring designated
+initializers.
+
+Sparse allows an attribute
+.BI __attribute__((designated_init))
+which marks a struct as requiring designated initializers.  Sparse will warn
+about positional initialization of a struct variable or struct literal of a
+type that has this attribute.
+
+Requiring designated initializers for a particular struct type will insulate
+code using that struct type from changes to the layout of the type, avoiding
+the need to change initializers for that type unless they initialize a removed
+or incompatibly changed field.
+
+Common examples of this type of struct include collections of function pointers
+for the implementations of a class of related operations, for which the default
+NULL for an unmentioned field in a designated initializer will correctly
+indicate the absence of that operation.
+
+Sparse issues these warnings by default.  To turn them off, use
+\fB\-Wno\-designated\-init\fR.
+.
+.TP
 .B \-Wdo\-while
 Warn about do-while loops that do not delimit the loop body with braces.
 
diff --git a/symbol.h b/symbol.h
index 60fdad0..83b3d4b 100644
--- a/symbol.h
+++ b/symbol.h
@@ -156,7 +156,8 @@ struct symbol {
 					examined:1,
 					expanding:1,
 					evaluated:1,
-					string:1;
+					string:1,
+					designated_init:1;
 			struct expression *array_size;
 			struct ctype ctype;
 			struct symbol_list *arguments;
diff --git a/validation/designated-init.c b/validation/designated-init.c
new file mode 100644
index 0000000..23423e9
--- /dev/null
+++ b/validation/designated-init.c
@@ -0,0 +1,195 @@
+struct s1 {
+	int x;
+	int y;
+};
+
+struct s2 {
+	int x;
+	int y;
+} __attribute__((designated_init));
+
+struct nest1 {
+	struct s1 s1;
+	struct s2 s2;
+};
+
+struct nest2 {
+	struct s1 s1;
+	struct s2 s2;
+} __attribute__((designated_init));
+
+static struct s1 s1_positional = { 5, 10 };
+static struct s1 s1_designated = { .x = 5, .y = 10 };
+static struct s2 s2_positional = { 5, 10 };
+static struct s2 s2_designated = { .x = 5, .y = 10 };
+static struct nest1 nest1_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest1 nest1_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest1 nest1_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest1 nest1_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+static struct nest2 nest2_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest2 nest2_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest2 nest2_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest2 nest2_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+
+static struct {
+	int x;
+	int y;
+} __attribute__((designated_init))
+	anon_positional = { 5, 10 },
+	anon_designated = { .x = 5, .y = 10};
+
+static struct s1 s1_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s2 s2_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s1 ret_s1_positional(void)
+{
+	return ((struct s1){ 5, 10 });
+}
+
+static struct s1 ret_s1_designated(void)
+{
+	return ((struct s1){ .x = 5, .y = 10 });
+}
+
+static struct s2 ret_s2_positional(void)
+{
+	return ((struct s2){ 5, 10 });
+}
+
+static struct s2 ret_s2_designated(void)
+{
+	return ((struct s2){ .x = 5, .y = 10 });
+}
+
+static struct nest1 ret_nest1_positional(void)
+{
+	return ((struct nest1){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_outer(void)
+{
+	return ((struct nest1){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_inner(void)
+{
+	return ((struct nest1){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_both(void)
+{
+	return ((struct nest1){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_positional(void)
+{
+	return ((struct nest2){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_outer(void)
+{
+	return ((struct nest2){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_inner(void)
+{
+	return ((struct nest2){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_both(void)
+{
+	return ((struct nest2){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+/*
+ * check-name: designated_init attribute
+ *
+ * check-error-start
+designated-init.c:23:36: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:23:39: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:42:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:43:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:50:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:51:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:62:29: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:62:32: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:71:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:71:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:30: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:33: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:130:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:131:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:146:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:147:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+ * check-error-end
+ */
-- 
1.6.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-kernel
Subject: [PATCH] New attribute designated_init: mark a struct as requiring
Date: Sat, 10 Oct 2009 08:58:32 +0000
Message-ID: <20091010085732.GA10923 () feather>
--------------------
Some structure types provide a set of fields of which most users will
only initialize the subset they care about.  Users of these types should
always use designated initializers, to avoid relying on the specific
structure layout.  Examples of this type of structure include the many
*_operations structures in Linux, which contain a set of function
pointers; these structures occasionally gain a new field, lose an
obsolete field, or change the function signature for a field.

Add a new attribute designated_init; when used on a struct, it tells
Sparse to warn on any positional initialization of a field in that
struct.

The new flag -Wdesignated-init controls these warnings.  Since these
warnings only fire for structures explicitly tagged with the attribute,
enable the warning by default.

Includes documentation and test case.

Signed-off-by: Josh Triplett <josh@joshtriplett.org>
---
Resent with the right list address this time...

 evaluate.c                   |    9 ++
 lib.c                        |    2 +
 lib.h                        |    1 +
 parse.c                      |   15 +++
 sparse.1                     |   24 +++++
 symbol.h                     |    3 +-
 validation/designated-init.c |  195 ++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 248 insertions(+), 1 deletions(-)
 create mode 100644 validation/designated-init.c

diff --git a/evaluate.c b/evaluate.c
index 805ae90..8e840a6 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2366,6 +2366,7 @@ static void handle_list_initializer(struct expression *expr,
 		int lclass;
 
 		if (e->type != EXPR_INDEX && e->type != EXPR_IDENTIFIER) {
+			struct symbol *struct_sym;
 			if (!top) {
 				top = e;
 				last = first_subobject(ctype, class, &top);
@@ -2378,6 +2379,14 @@ static void handle_list_initializer(struct expression *expr,
 				DELETE_CURRENT_PTR(e);
 				continue;
 			}
+			struct_sym = ctype->type == SYM_NODE ? ctype->ctype.base_type : ctype;
+			if (Wdesignated_init && struct_sym->designated_init)
+				warning(e->pos, "%s%s%spositional init of field in %s %s, declared with attribute designated_init",
+					ctype->ident ? "in initializer for " : "",
+					ctype->ident ? ctype->ident->name : "",
+					ctype->ident ? ": " : "",
+					get_type_name(struct_sym->type),
+					show_ident(struct_sym->ident));
 			if (jumped) {
 				warning(e->pos, "advancing past deep designator");
 				jumped = 0;
diff --git a/lib.c b/lib.c
index 622b547..77a1c33 100644
--- a/lib.c
+++ b/lib.c
@@ -197,6 +197,7 @@ int Wcast_truncate = 1;
 int Wcontext = 1;
 int Wdecl = 1;
 int Wdefault_bitfield_sign = 0;
+int Wdesignated_init = 1;
 int Wdo_while = 0;
 int Wenum_mismatch = 1;
 int Wnon_pointer_null = 1;
@@ -378,6 +379,7 @@ static const struct warning {
 	{ "context", &Wcontext },
 	{ "decl", &Wdecl },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
+	{ "designated-init", &Wdesignated_init },
 	{ "do-while", &Wdo_while },
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "non-pointer-null", &Wnon_pointer_null },
diff --git a/lib.h b/lib.h
index 25abb80..3ced1bf 100644
--- a/lib.h
+++ b/lib.h
@@ -97,6 +97,7 @@ extern int Wcast_truncate;
 extern int Wcontext;
 extern int Wdecl;
 extern int Wdefault_bitfield_sign;
+extern int Wdesignated_init;
 extern int Wdo_while;
 extern int Wenum_mismatch;
 extern int Wnon_pointer_null;
diff --git a/parse.c b/parse.c
index 5e75242..03fa5d9 100644
--- a/parse.c
+++ b/parse.c
@@ -64,6 +64,7 @@ typedef struct token *attr_t(struct token *, struct symbol *,
 static attr_t
 	attribute_packed, attribute_aligned, attribute_modifier,
 	attribute_address_space, attribute_context,
+	attribute_designated_init,
 	attribute_transparent_union, ignore_attribute,
 	attribute_mode, attribute_force;
 
@@ -319,6 +320,10 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
+static struct symbol_op designated_init_op = {
+	.attribute = attribute_designated_init,
+};
+
 static struct symbol_op transparent_union_op = {
 	.attribute = attribute_transparent_union,
 };
@@ -453,6 +458,7 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
+	{ "designated_init",	NS_KEYWORD,	.op = &designated_init_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
@@ -1127,6 +1133,15 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 	return token;
 }
 
+static struct token *attribute_designated_init(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	if (ctx->ctype.base_type && ctx->ctype.base_type->type == SYM_STRUCT)
+		ctx->ctype.base_type->designated_init = 1;
+	else
+		warning(token->pos, "attribute designated_init applied to non-structure type");
+	return token;
+}
+
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	if (Wtransparent_union)
diff --git a/sparse.1 b/sparse.1
index d7fe444..1054712 100644
--- a/sparse.1
+++ b/sparse.1
@@ -134,6 +134,30 @@ explicitly.
 Sparse does not issue these warnings by default.
 .
 .TP
+.B \-Wdesignated\-init
+Warn about positional initialization of structs marked as requiring designated
+initializers.
+
+Sparse allows an attribute
+.BI __attribute__((designated_init))
+which marks a struct as requiring designated initializers.  Sparse will warn
+about positional initialization of a struct variable or struct literal of a
+type that has this attribute.
+
+Requiring designated initializers for a particular struct type will insulate
+code using that struct type from changes to the layout of the type, avoiding
+the need to change initializers for that type unless they initialize a removed
+or incompatibly changed field.
+
+Common examples of this type of struct include collections of function pointers
+for the implementations of a class of related operations, for which the default
+NULL for an unmentioned field in a designated initializer will correctly
+indicate the absence of that operation.
+
+Sparse issues these warnings by default.  To turn them off, use
+\fB\-Wno\-designated\-init\fR.
+.
+.TP
 .B \-Wdo\-while
 Warn about do-while loops that do not delimit the loop body with braces.
 
diff --git a/symbol.h b/symbol.h
index 60fdad0..83b3d4b 100644
--- a/symbol.h
+++ b/symbol.h
@@ -156,7 +156,8 @@ struct symbol {
 					examined:1,
 					expanding:1,
 					evaluated:1,
-					string:1;
+					string:1,
+					designated_init:1;
 			struct expression *array_size;
 			struct ctype ctype;
 			struct symbol_list *arguments;
diff --git a/validation/designated-init.c b/validation/designated-init.c
new file mode 100644
index 0000000..23423e9
--- /dev/null
+++ b/validation/designated-init.c
@@ -0,0 +1,195 @@
+struct s1 {
+	int x;
+	int y;
+};
+
+struct s2 {
+	int x;
+	int y;
+} __attribute__((designated_init));
+
+struct nest1 {
+	struct s1 s1;
+	struct s2 s2;
+};
+
+struct nest2 {
+	struct s1 s1;
+	struct s2 s2;
+} __attribute__((designated_init));
+
+static struct s1 s1_positional = { 5, 10 };
+static struct s1 s1_designated = { .x = 5, .y = 10 };
+static struct s2 s2_positional = { 5, 10 };
+static struct s2 s2_designated = { .x = 5, .y = 10 };
+static struct nest1 nest1_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest1 nest1_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest1 nest1_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest1 nest1_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+static struct nest2 nest2_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest2 nest2_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest2 nest2_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest2 nest2_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+
+static struct {
+	int x;
+	int y;
+} __attribute__((designated_init))
+	anon_positional = { 5, 10 },
+	anon_designated = { .x = 5, .y = 10};
+
+static struct s1 s1_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s2 s2_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s1 ret_s1_positional(void)
+{
+	return ((struct s1){ 5, 10 });
+}
+
+static struct s1 ret_s1_designated(void)
+{
+	return ((struct s1){ .x = 5, .y = 10 });
+}
+
+static struct s2 ret_s2_positional(void)
+{
+	return ((struct s2){ 5, 10 });
+}
+
+static struct s2 ret_s2_designated(void)
+{
+	return ((struct s2){ .x = 5, .y = 10 });
+}
+
+static struct nest1 ret_nest1_positional(void)
+{
+	return ((struct nest1){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_outer(void)
+{
+	return ((struct nest1){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_inner(void)
+{
+	return ((struct nest1){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_both(void)
+{
+	return ((struct nest1){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_positional(void)
+{
+	return ((struct nest2){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_outer(void)
+{
+	return ((struct nest2){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_inner(void)
+{
+	return ((struct nest2){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_both(void)
+{
+	return ((struct nest2){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+/*
+ * check-name: designated_init attribute
+ *
+ * check-error-start
+designated-init.c:23:36: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:23:39: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:42:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:43:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:50:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:51:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:62:29: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:62:32: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:71:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:71:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:30: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:33: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:130:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:131:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:146:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:147:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+ * check-error-end
+ */
-- 
1.6.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: [PATCH] New attribute designated_init: mark a struct as requiring
Date: Sat, 10 Oct 2009 10:33:20 +0000
Message-ID: <70318cbf0910100333m128e3500vb1659a55a9f49768 () mail ! gmail ! com>
--------------------
On Sat, Oct 10, 2009 at 1:58 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> Some structure types provide a set of fields of which most users will
> only initialize the subset they care about.  Users of these types should
> always use designated initializers, to avoid relying on the specific
> structure layout.  Examples of this type of structure include the many

The patch is very well written with nice documentations and test case.
It applies and runs fine.

I am curious weather this is some thing the kernel developers want to
use. Please speak up if you want to annotate the kernel structure to
issue such warning. If some one use it, I have no problem adding it to
sparse.

I am not sure how useful this is yet.  If the structure is changed, most
likely the positional initialization will fail due to type mismatching.
Some real life example how this feature can expose some otherwise
hard to detect bug would be nice.

With this approach, we need to annotate the kernel to benefit from it.
Another idea is that we can find out how different part of the kernel
initialize the same structure. If most of them using designated init then
the few non-conforming can get a warning. This approach is more
complicate.  But it does not need to change the kernel.


> +                               warning(e->pos, "%s%s%spositional init of field in %s %s, declared with attribute designated_init",
> +                                       ctype->ident ? "in initializer for " : "",
> +                                       ctype->ident ? ctype->ident->name : "",

ident->name has no guarantee of terminating by NUL.
You want to use "%.*s" with ident->size, ident->name here.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] New attribute designated_init: mark a struct as requiring
Date: Mon, 12 Oct 2009 05:18:24 +0000
Message-ID: <70318cbf0910112218j50a63148t2e044bc5451dc0cb () mail ! gmail ! com>
--------------------
On Sat, Oct 10, 2009 at 9:03 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> After getting this patch reviewed, I intended to add many such
> annotations myself.  I have patches sitting in my local Linux tree.
> (However, I don't plan to try to get the patches accepted into Linux
> until this attribute shows up in a Sparse release, since I don't want to
> make Linux require the latest Sparse from the git tree.)

I apply your patch so you can have a fair chance to pitch to the
kernel. If nobody use it, I can remove it later. I don't think you need
to wait for the patch to go into sparse release to collect feed back
from lkml.


> You *hope* that positional initialization will fail. :)  Some of these
> types of structures contain many fields with the same or similar types,
> and initializers don't inherently contain a lot of distinguishing type
> information that helps cause type errors rather than silent failures.

I am very interested to know some precedence from the kernel commit history.
If we can find such a commit which changes the structure and breaks
other initialization due to the position initialization, it will make your
case stronger as well.

> Even if the positional initialization does fail, this failure will occur
> at the time of attempting to change the structure, and many such
> failures may occur all over the tree, making such changes significantly
> more difficult.  With the designated_init attribute, sparse will warn
> when attempting to create the structure initializer.

Without sparse, you can temporary  insert some unused strange type
into the beginning of the struct. That should cause any position initializer
fail to compile. You can then find call the call site.

> With the designated_init attribute, someone making changes to a
> structure can check that Sparse produces no warnings about positional
> initializers and then know that certain types of changes can occur
> without having to check every initializer.  For instance, removing a
> field will only require checking any initializer that initializes that
> field, and the compiler will find all of those.  Adding a field that can
> safely remain NULL does not require checking any initializers.

I think the initializer is just a small part of the work if you even change
the structure. You need to make sure the *code* use these C struct
actually works as expected.

> (As an aside, though: any fundamental reason why we use that error-prone
> approach rather than allocating one extra byte and NUL-terminating
> idents?  Then we could drop the (larger) len field, and remove the
> annoying restriction on calling show_ident multiple times in the same
> statement.)

When sparse does the hash table look up, if there is collision on the
hash table entry, sparse will compare the size first before the memcmp().
That will reduce the number of the memcmp call it makes. I would like to
keep the size of struct ident. If any thing, we can NUL terminate the string
in ident to make printing easy.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Rename -Wall to Wsparse-all, so it doesn't get turned on ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: [PATCH] Rename -Wall to Wsparse-all, so it doesn't get turned on
Date: Sun, 11 Oct 2009 21:59:49 +0000
Message-ID: <20091011215943.GA2684 () feather>
--------------------
sparse's -Wall option turns on all sparse warnings, including those that
many projects will not want; for instance, warnings that enforce
particular stylistic choices, or behavior allowed by a standard but
considered questionable or error-prone.  Furthermore, using -Wall means
accepting all future warnings sparse may start issuing, not just those
intentionally turned on by default.

Other compilers like GCC also use -Wall, and interpret it to mean "turn
on a sensible set of warnings".  Since sparse exists to emit warnings,
it already defaults to emitting a sensible set of warnings.  Many
projects pass the same options to both sparse and the C compiler,
including warning options like -Wall; this results in turning on
excessive amounts of sparse warnings.

cgcc already filtered out -Wall, but many projects invoke sparse
directly rather than using cgcc.  Remove that filter, now that -Wall
does not change sparse's behavior.

Projects almost certainly don't want to use the new -Wsparse-all option;
they should choose the specific set of warnings they want, or just go
with sparse's defaults.

Signed-off-by: Josh Triplett <josh@joshtriplett.org>
---

This has come up for discussion numerous times before, and most people
seem to approve of renaming -Wall, but the change hasn't actually gone
into sparse yet.

 cgcc     |   15 +--------------
 lib.c    |    2 +-
 sparse.1 |    4 ++++
 3 files changed, 6 insertions(+), 15 deletions(-)

diff --git a/cgcc b/cgcc
index 995cc05..ff8c921 100755
--- a/cgcc
+++ b/cgcc
@@ -51,7 +51,7 @@ while (@ARGV) {
 
     my $this_arg = ' ' . &quote_arg ($_);
     $cc .= $this_arg unless &check_only_option ($_);
-    $check .= $this_arg unless &cc_only_option ($_);
+    $check .= $this_arg;
 }
 
 if ($gendeps) {
@@ -94,19 +94,6 @@ sub check_only_option {
 }
 
 # -----------------------------------------------------------------------------
-# Check if an option is for "cc" only.
-
-sub cc_only_option {
-    my ($arg) = @_;
-    # -Wall turns on all Sparse warnings, including experimental and noisy
-    # ones.  Don't include it just because a project wants to pass -Wall to cc.
-    # If you really want cgcc to run sparse with -Wall, use
-    # CHECK="sparse -Wall".
-    return 1 if $arg =~ /^-Wall$/;
-    return 0;
-}
-
-# -----------------------------------------------------------------------------
 # Simple arg-quoting function.  Just adds backslashes when needed.
 
 sub quote_arg {
diff --git a/lib.c b/lib.c
index 622b547..963be08 100644
--- a/lib.c
+++ b/lib.c
@@ -407,7 +407,7 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
 	char *p = arg + 1;
 	unsigned i;
 
-	if (!strcmp(p, "all")) {
+	if (!strcmp(p, "sparse-all")) {
 		for (i = 0; i < n; i++) {
 			if (*warnings[i].flag != WARNING_FORCE_OFF)
 				*warnings[i].flag = WARNING_ON;
diff --git a/sparse.1 b/sparse.1
index d7fe444..abc75a2 100644
--- a/sparse.1
+++ b/sparse.1
@@ -20,6 +20,10 @@ off those warnings, pass the negation of the associated warning option,
 .
 .SH WARNING OPTIONS
 .TP
+.B \-Wsparse\-all
+Turn on all sparse warnings, except for those explicitly disabled via
+\fB\-Wno\-something\fR.
+.TP
 .B \-Waddress\-space
 Warn about code which mixes pointers to different address spaces.
 
-- 
1.6.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Support the __thread storage class ===

From: Alberto Bertogli <albertito () blitiri ! com ! ar>
To: linux-sparse
Subject: [PATCH] Support the __thread storage class
Date: Mon, 27 Apr 2009 00:44:56 +0000
Message-ID: <1240793096-23090-1-git-send-email-albertito () blitiri ! com ! ar>
--------------------
GCC supports a __thread storage class, used to indicate thread-local
storage. It may be used alone, or with extern or static.

This patch makes sparse aware of it, but ignores it completely.

Signed-off-by: Alberto Bertogli <albertito@blitiri.com.ar>
---
 parse.c |   14 +++++++++++++-
 1 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/parse.c b/parse.c
index 14ae25d..e49cb39 100644
--- a/parse.c
+++ b/parse.c
@@ -41,7 +41,7 @@ static declarator_t
 	attribute_specifier, typeof_specifier, parse_asm_declarator,
 	typedef_specifier, inline_specifier, auto_specifier,
 	register_specifier, static_specifier, extern_specifier,
-	const_qualifier, volatile_qualifier;
+	thread_specifier, const_qualifier, volatile_qualifier;
 
 static struct token *parse_if_statement(struct token *token, struct statement *stmt);
 static struct token *parse_return_statement(struct token *token, struct statement *stmt);
@@ -125,6 +125,11 @@ static struct symbol_op extern_op = {
 	.declarator = extern_specifier,
 };
 
+static struct symbol_op thread_op = {
+	.type = KW_MODIFIER,
+	.declarator = thread_specifier,
+};
+
 static struct symbol_op const_op = {
 	.type = KW_QUALIFIER,
 	.declarator = const_qualifier,
@@ -407,6 +412,7 @@ static struct init_keyword {
 	{ "register",	NS_TYPEDEF, .op = &register_op },
 	{ "static",	NS_TYPEDEF, .op = &static_op },
 	{ "extern",	NS_TYPEDEF, .op = &extern_op },
+	{ "__thread",	NS_TYPEDEF, .op = &thread_op },
 
 	/* Statement */
 	{ "if",		NS_KEYWORD, .op = &if_op },
@@ -1210,6 +1216,12 @@ static struct token *extern_specifier(struct token *next, struct decl_state *ctx
 	return next;
 }
 
+static struct token *thread_specifier(struct token *next, struct decl_state *ctx)
+{
+	/* Ignore __thread */
+	return next;
+}
+
 static struct token *attribute_force(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	set_storage_class(&token->pos, ctx, SForced);
-- 
1.6.2.2.646.gb214

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alberto Bertogli <albertito () blitiri ! com ! ar>
To: linux-sparse
Subject: [PATCH] Support the __thread storage class
Date: Sat, 16 May 2009 15:36:58 +0000
Message-ID: <1242488218-19811-1-git-send-email-albertito () blitiri ! com ! ar>
--------------------
GCC supports a __thread storage class, used to indicate thread-local
storage. It may be used alone, or with extern or static.

This patch makes sparse aware of it, and check those restrictions.

Signed-off-by: Alberto Bertogli <albertito@blitiri.com.ar>
---
 parse.c  |   34 +++++++++++++++++++++++++++++++---
 symbol.h |    3 ++-
 2 files changed, 33 insertions(+), 4 deletions(-)

diff --git a/parse.c b/parse.c
index 14ae25d..ed79538 100644
--- a/parse.c
+++ b/parse.c
@@ -41,7 +41,7 @@ static declarator_t
 	attribute_specifier, typeof_specifier, parse_asm_declarator,
 	typedef_specifier, inline_specifier, auto_specifier,
 	register_specifier, static_specifier, extern_specifier,
-	const_qualifier, volatile_qualifier;
+	thread_specifier, const_qualifier, volatile_qualifier;
 
 static struct token *parse_if_statement(struct token *token, struct statement *stmt);
 static struct token *parse_return_statement(struct token *token, struct statement *stmt);
@@ -125,6 +125,11 @@ static struct symbol_op extern_op = {
 	.declarator = extern_specifier,
 };
 
+static struct symbol_op thread_op = {
+	.type = KW_MODIFIER,
+	.declarator = thread_specifier,
+};
+
 static struct symbol_op const_op = {
 	.type = KW_QUALIFIER,
 	.declarator = const_qualifier,
@@ -407,6 +412,7 @@ static struct init_keyword {
 	{ "register",	NS_TYPEDEF, .op = &register_op },
 	{ "static",	NS_TYPEDEF, .op = &static_op },
 	{ "extern",	NS_TYPEDEF, .op = &extern_op },
+	{ "__thread",	NS_TYPEDEF, .op = &thread_op },
 
 	/* Statement */
 	{ "if",		NS_KEYWORD, .op = &if_op },
@@ -1165,11 +1171,19 @@ static unsigned long storage_modifiers(struct decl_state *ctx)
 		[SStatic] = MOD_STATIC,
 		[SRegister] = MOD_REGISTER
 	};
-	return mod[ctx->storage_class] | (ctx->is_inline ? MOD_INLINE : 0);
+	return mod[ctx->storage_class] | (ctx->is_inline ? MOD_INLINE : 0)
+		| (ctx->is_tls ? MOD_TLS : 0);
 }
 
 static void set_storage_class(struct position *pos, struct decl_state *ctx, int class)
 {
+	/* __thread can be used alone, or with extern or static */
+	if (ctx->is_tls && (class != SStatic && class != SExtern)) {
+		sparse_error(*pos, "__thread can only be used alone, or with "
+				"extern or static");
+		return;
+	}
+
 	if (!ctx->storage_class) {
 		ctx->storage_class = class;
 		return;
@@ -1210,6 +1224,20 @@ static struct token *extern_specifier(struct token *next, struct decl_state *ctx
 	return next;
 }
 
+static struct token *thread_specifier(struct token *next, struct decl_state *ctx)
+{
+	/* This GCC extension can be used alone, or with extern or static */
+	if (!ctx->storage_class || ctx->storage_class == SStatic
+			|| ctx->storage_class == SExtern) {
+		ctx->is_tls = 1;
+	} else {
+		sparse_error(next->pos, "__thread can only be used alone, or "
+				"with extern or static");
+	}
+
+	return next;
+}
+
 static struct token *attribute_force(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	set_storage_class(&token->pos, ctx, SForced);
@@ -1871,7 +1899,7 @@ static struct statement *start_function(struct symbol *sym)
 	start_function_scope();
 	ret = alloc_symbol(sym->pos, SYM_NODE);
 	ret->ctype = sym->ctype.base_type->ctype;
-	ret->ctype.modifiers &= ~(MOD_STORAGE | MOD_CONST | MOD_VOLATILE | MOD_INLINE | MOD_ADDRESSABLE | MOD_NOCAST | MOD_NODEREF | MOD_ACCESSED | MOD_TOPLEVEL);
+	ret->ctype.modifiers &= ~(MOD_STORAGE | MOD_CONST | MOD_VOLATILE | MOD_TLS | MOD_INLINE | MOD_ADDRESSABLE | MOD_NOCAST | MOD_NODEREF | MOD_ACCESSED | MOD_TOPLEVEL);
 	ret->ctype.modifiers |= (MOD_AUTO | MOD_REGISTER);
 	bind_symbol(ret, &return_ident, NS_ITERATOR);
 	stmt->ret = ret;
diff --git a/symbol.h b/symbol.h
index da4d64a..751dec1 100644
--- a/symbol.h
+++ b/symbol.h
@@ -93,7 +93,7 @@ struct decl_state {
 	struct ctype ctype;
 	struct ident **ident;
 	struct symbol_op *mode;
-	unsigned char prefer_abstract, is_inline, storage_class;
+	unsigned char prefer_abstract, is_inline, storage_class, is_tls;
 };
 
 struct symbol_op {
@@ -199,6 +199,7 @@ struct symbol {
 
 #define MOD_TYPEDEF	0x1000
 
+#define MOD_TLS		0x20000
 #define MOD_INLINE	0x40000
 #define MOD_ADDRESSABLE	0x80000
 
-- 
1.6.2.2.646.gb214

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Support the __thread storage class
Date: Tue, 19 May 2009 10:00:40 +0000
Message-ID: <70318cbf0905190300o1b82f2aax433b08248ac08c3a () mail ! gmail ! com>
--------------------
On Sat, May 16, 2009 at 8:36 AM, Alberto Bertogli
<albertito@blitiri.com.ar> wrote:
> GCC supports a __thread storage class, used to indicate thread-local
> storage. It may be used alone, or with extern or static.
>

Thanks, I applied it to my tree already.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] add warnings enum-to-int and int-to-enum ===

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] add warnings enum-to-int and int-to-enum
Date: Sun, 13 Sep 2009 20:09:23 +0000
Message-ID: <200909132209.23393.kdudka () redhat ! com>
--------------------
On Sunday 13 of September 2009 21:55:32 Christopher Li wrote:
> On Sun, Sep 13, 2009 at 12:28 PM, Kamil Dudka <kdudka@redhat.com> wrote:
> > Any progress here? I wouldn't like this to become another downstream
> > patch.
>
> Guilty. Too busy this week. I am going to take a look at it again tonight.

Thanks for quick reply! It doesn't hurry actually. I am only trying to keep 
this thread alive :-)

> > I work on a generic layer [1] for processing C sources (for now)
> > supporting SPARSE and gcc 4.5 plug-in as sources. The gcc plug-in [2] now
> > works fairly well and I am going to make the SPARSE client fully
> > equivalent to the plug-in. This will probably need a few more tiny
> > patches for SPARSE to implement what's missing.
> >
> > Is the upstream interested to make SPARSE more useful as a library?
>
> Yes. I am interested in that. If it does not cause additional slow down
> or memory blow. Sure yes.
>
> If it does because it needs to preserve more information, e.g. space and
> comments it would be nice to put it under some options or even compile time
> config option. I care about people don't use those feature can still run
> sparse fast.

I think we'll need to add some extra items to the public SPARSE headers, not 
sure if it's good idea to #ifdef it even there. But I need to analyse what 
exactly is missing first. Now I am only asking whether the idea itself is 
welcome (before starting work on it).

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] compile-i386: do not generate an infinite loop ===

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: [PATCH] compile-i386: do not generate an infinite loop
Date: Sat, 18 Jul 2009 21:34:10 +0000
Message-ID: <200907182334.10900.kdudka () redhat ! com>
--------------------
--Boundary-00=_S/jYKycSIZ/aNhV
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hello,

I've probably encountered a bug within compile-i386.c. It generates
an infinite loop for 'while' statement. My testing example and proposed
patch are enclosed.

Kamil

--Boundary-00=_S/jYKycSIZ/aNhV
Content-Type: text/x-csrc;
  charset="us-ascii";
  name="list.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
	filename="list.c"

#include <stdlib.h>

typedef void *TItem;

void dispose_list(TItem *list) {
    while (list) {
        TItem *item = list;
        list = (TItem *) *list;
        free(item);
    }
}

--Boundary-00=_S/jYKycSIZ/aNhV
Content-Type: text/x-diff;
  charset="us-ascii";
  name="0001-compile-i386-do-not-generate-an-infinite-loop.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="0001-compile-i386-do-not-generate-an-infinite-loop.patch"

=46rom 60c47d120b577092f0d8fe9001ca6753706dcdbc Mon Sep 17 00:00:00 2001
=46rom: Kamil Dudka <kdudka@redhat.com>
Date: Sat, 18 Jul 2009 23:24:38 +0200
Subject: [PATCH] compile-i386: do not generate an infinite loop

=2D--
 compile-i386.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/compile-i386.c b/compile-i386.c
index 37ea52e..abe9313 100644
=2D-- a/compile-i386.c
+++ b/compile-i386.c
@@ -1913,6 +1913,10 @@ static void emit_loop(struct statement *stmt)
=20
 	x86_symbol_decl(stmt->iterator_syms);
 	x86_statement(pre_statement);
+	if (!post_condition || post_condition->type !=3D EXPR_VALUE || post_condi=
tion->value) {
+		loop_top =3D new_label();
+		emit_label(loop_top, "loop top");
+	}
 	if (pre_condition) {
 		if (pre_condition->type =3D=3D EXPR_VALUE) {
 			if (!pre_condition->value) {
@@ -1936,10 +1940,6 @@ static void emit_loop(struct statement *stmt)
 			insn("jz", lbv, NULL, NULL);
 		}
 	}
=2D	if (!post_condition || post_condition->type !=3D EXPR_VALUE || post_con=
dition->value) {
=2D		loop_top =3D new_label();
=2D		emit_label(loop_top, "loop top");
=2D	}
 	x86_statement(statement);
 	if (stmt->iterator_continue->used)
 		emit_label(loop_continue, "'continue' iterator");
=2D-=20
1.6.3.3


--Boundary-00=_S/jYKycSIZ/aNhV--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 08:38:43 +0000
Message-ID: <70318cbf0907220138g412388fam12f31f03c25ebf1f () mail ! gmail ! com>
--------------------
On Sat, Jul 18, 2009 at 2:34 PM, Kamil Dudka<kdudka@redhat.com> wrote:
> Hello,
>
> I've probably encountered a bug within compile-i386.c. It generates
> an infinite loop for 'while' statement. My testing example and proposed
> patch are enclosed.

Adding Jeff to the CC list. The compile-i386.c is Jeff's pet project.
The change looks good to me. I would like to give Jeff some time
to comment it before I apply the patch.

BTW, have you take a look at Linus's example.c? It is based on the
linearized byte code and It does more advance stuff like simple
register allocation. In my opinion example.c is a better place to start
hacking compiler back end  than compile.c

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 09:24:35 +0000
Message-ID: <200907221124.35339.kdudka () redhat ! com>
--------------------
On Wed July 22 2009 10:38:43 Christopher Li wrote:
> Adding Jeff to the CC list. The compile-i386.c is Jeff's pet project.
> The change looks good to me. I would like to give Jeff some time
> to comment it before I apply the patch.

Thanks!

> BTW, have you take a look at Linus's example.c? It is based on the
> linearized byte code and It does more advance stuff like simple
> register allocation. In my opinion example.c is a better place to start
> hacking compiler back end  than compile.c

Linus's example.c works fine with the same test-case. I decided to take 
compile.c as template just because it doesn't use the linearized code.
The tree structure better accomplishes my requirements for now. Maybe I'll 
turn to byte code in future. I've just started to play with it.

Anyway SPARSE seems to be quite helpful. It's easy to read and can save
a lot of development time while processing C sources.

Kamil

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 12:45:58 +0000
Message-ID: <4A670A06.1010605 () garzik ! org>
--------------------
Christopher Li wrote:
> On Sat, Jul 18, 2009 at 2:34 PM, Kamil Dudka<kdudka@redhat.com> wrote:
>> Hello,
>>
>> I've probably encountered a bug within compile-i386.c. It generates
>> an infinite loop for 'while' statement. My testing example and proposed
>> patch are enclosed.
> 
> Adding Jeff to the CC list. The compile-i386.c is Jeff's pet project.
> The change looks good to me. I would like to give Jeff some time
> to comment it before I apply the patch.

Acked-by: Jeff Garzik <jgarzik@redhat.com>


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 16:34:13 +0000
Message-ID: <70318cbf0907220934p607b8c61g31fcec75e868d0d () mail ! gmail ! com>
--------------------
On Wed, Jul 22, 2009 at 2:24 AM, Kamil Dudka<kdudka@redhat.com> wrote:
> Anyway SPARSE seems to be quite helpful. It's easy to read and can save
> a lot of development time while processing C sources.

Just curious, what are you trying to build with sparse? A Linus filter would be
pretty cool.

BTW, I want to start some hacking guide for sparse. I am particular interested
in what is the common pain when a new hacker try to work on sparse. Do you
find sparse pretty easy to learn on?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 16:39:42 +0000
Message-ID: <70318cbf0907220939s48bcfd3fi20ae9fda1edd290 () mail ! gmail ! com>
--------------------
Oh one last thing. I need a signed-off line from you.

Chris

On Sat, Jul 18, 2009 at 2:34 PM, Kamil Dudka<kdudka@redhat.com> wrote:
> Hello,
>
> I've probably encountered a bug within compile-i386.c. It generates
> an infinite loop for 'while' statement. My testing example and proposed
> patch are enclosed.
>
> Kamil
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 17:02:48 +0000
Message-ID: <200907221902.49184.kdudka () redhat ! com>
--------------------
--Boundary-00=_5Y0ZKv2VUdbX7Fr
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Wednesday 22 of July 2009 18:51:14 Jeff Garzik wrote:
> Christopher Li wrote:
> > Oh one last thing. I need a signed-off line from you.
>
> I think sparse needs some text document, describing what Signed-off-by
> means.  I did this in one of my own projects by copying the relevant
> "DCO" from kernel tree's Documentation/SubmittingPatches.

Thanks! I was just looking for some info about "Signed-off-by"...

The signed-off patch is attached.

Kamil

--Boundary-00=_5Y0ZKv2VUdbX7Fr
Content-Type: text/x-diff;
  charset="iso-8859-1";
  name="0001-compile-i386-do-not-generate-infinite-loop.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="0001-compile-i386-do-not-generate-infinite-loop.patch"

=46rom 984e2612d2174390a54a36a805051c3f66cf6250 Mon Sep 17 00:00:00 2001
=46rom: Kamil Dudka <kdudka@redhat.com>
Date: Sat, 18 Jul 2009 23:16:53 +0200
Subject: [PATCH] compile-i386: do not generate infinite loop

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
=2D--
 compile-i386.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/compile-i386.c b/compile-i386.c
index 37ea52e..abe9313 100644
=2D-- a/compile-i386.c
+++ b/compile-i386.c
@@ -1913,6 +1913,10 @@ static void emit_loop(struct statement *stmt)
=20
 	x86_symbol_decl(stmt->iterator_syms);
 	x86_statement(pre_statement);
+	if (!post_condition || post_condition->type !=3D EXPR_VALUE || post_condi=
tion->value) {
+		loop_top =3D new_label();
+		emit_label(loop_top, "loop top");
+	}
 	if (pre_condition) {
 		if (pre_condition->type =3D=3D EXPR_VALUE) {
 			if (!pre_condition->value) {
@@ -1936,10 +1940,6 @@ static void emit_loop(struct statement *stmt)
 			insn("jz", lbv, NULL, NULL);
 		}
 	}
=2D	if (!post_condition || post_condition->type !=3D EXPR_VALUE || post_con=
dition->value) {
=2D		loop_top =3D new_label();
=2D		emit_label(loop_top, "loop top");
=2D	}
 	x86_statement(statement);
 	if (stmt->iterator_continue->used)
 		emit_label(loop_continue, "'continue' iterator");
=2D-=20
1.6.3.3


--Boundary-00=_5Y0ZKv2VUdbX7Fr--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 19:18:37 +0000
Message-ID: <70318cbf0907221218s7a155392l5f1e548a9cbd709c () mail ! gmail ! com>
--------------------
On Wed, Jul 22, 2009 at 9:51 AM, Jeff Garzik<jeff@garzik.org> wrote:
> Christopher Li wrote:
>
> I think sparse needs some text document, describing what Signed-off-by
> means.  I did this in one of my own projects by copying the relevant "DCO"
> from kernel tree's Documentation/SubmittingPatches.

Good idea.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: do not generate an infinite loop
Date: Wed, 22 Jul 2009 19:30:42 +0000
Message-ID: <70318cbf0907221230o3f96ace7yc8e1d409e75891b2 () mail ! gmail ! com>
--------------------
On Wed, Jul 22, 2009 at 10:21 AM, Kamil Dudka<kdudka@redhat.com> wrote:
> Sorry for my ignorance, I've never heard about the Linus filter. Could you
> please point me to some relevant info? For now we only want to play with
> separation logic and use it for static analysis of code as part of our
> research at FIT BUT.

Of course you haven't heard of it. I just make it up myself.  A Linus filter
is a program that take bad C code as input and output good C code as if
it is written by Linus himself. We just need to hook it to LKML.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] do not ignore attribute 'noreturn'... ===

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: [PATCH] do not ignore attribute 'noreturn'...
Date: Fri, 28 Aug 2009 21:30:08 +0000
Message-ID: <200908282330.08332.kdudka () redhat ! com>
--------------------
--Boundary-00=_gxEmKKPvnGlLNOK
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hello,

enclosed is a simple patch adding support for attribute 'noreturn' to the 
parser. The enhancement makes it possible to optimize walk through CFG and 
thus help us to fight with the state explosion. The benefit is demonstrated 
on a simple real-world example.

Generated CFG before patch:
http://dudka.cz/devel/html/slsparse-before/slplug.c-handle_stmt_assign.svg

Generated CFG after patch:
http://dudka.cz/devel/html/slsparse-after/slplug.c-handle_stmt_assign.svg

It's one of the key features I am currently missing in SPARSE in contrast
to gcc used as parser. Thanks in advance for considering it!

Kamil

--Boundary-00=_gxEmKKPvnGlLNOK
Content-Type: text/x-diff;
  charset="us-ascii";
  name="0001-do-not-ignore-attribute-noreturn.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="0001-do-not-ignore-attribute-noreturn.patch"

=46rom 892f19915cbcbe26b3a7ad2c3baf1a1420f3c954 Mon Sep 17 00:00:00 2001
=46rom: Kamil Dudka <kdudka@redhat.com>
Date: Fri, 28 Aug 2009 21:49:16 +0200
Subject: [PATCH] do not ignore attribute 'noreturn'...

=2E.. and thus make it possible to optimize walk through CFG.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
=2D--
 parse.c  |    4 ++--
 symbol.h |    4 +++-
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/parse.c b/parse.c
index e5ad867..215c4da 100644
=2D-- a/parse.c
+++ b/parse.c
@@ -480,8 +480,8 @@ static struct init_keyword {
 	{ "const",	NS_KEYWORD,	.op =3D &ignore_attr_op },
 	{ "__const",	NS_KEYWORD,	.op =3D &ignore_attr_op },
 	{ "__const__",	NS_KEYWORD,	.op =3D &ignore_attr_op },
=2D	{ "noreturn",	NS_KEYWORD,	.op =3D &ignore_attr_op },
=2D	{ "__noreturn__",	NS_KEYWORD,	.op =3D &ignore_attr_op },
+	{ "noreturn",	NS_KEYWORD,	MOD_NORETURN,	.op =3D &attr_mod_op },
+	{ "__noreturn__",	NS_KEYWORD,	MOD_NORETURN,	.op =3D &attr_mod_op },
 	{ "no_instrument_function",	NS_KEYWORD,	.op =3D &ignore_attr_op },
 	{ "__no_instrument_function__",	NS_KEYWORD,	.op =3D &ignore_attr_op },
 	{ "sentinel",	NS_KEYWORD,	.op =3D &ignore_attr_op },
diff --git a/symbol.h b/symbol.h
index 42d69d6..d8d1793 100644
=2D-- a/symbol.h
+++ b/symbol.h
@@ -216,6 +216,8 @@ struct symbol {
 #define MOD_EXPLICITLY_SIGNED	0x40000000
 #define MOD_BITWISE	0x80000000
=20
+#define MOD_NORETURN	0x100000000
+
 #define MOD_NONLOCAL	(MOD_EXTERN | MOD_TOPLEVEL)
 #define MOD_STORAGE	(MOD_AUTO | MOD_REGISTER | MOD_STATIC | MOD_EXTERN | M=
OD_INLINE | MOD_TOPLEVEL)
 #define MOD_SIGNEDNESS	(MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED)
@@ -223,7 +225,7 @@ struct symbol {
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG)
 #define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
 	MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
=2D#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STO=
RAGE)
+#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORA=
GE | MOD_NORETURN)
=20
=20
 /* Current parsing/evaluation function */
=2D-=20
1.6.4.1


--Boundary-00=_gxEmKKPvnGlLNOK--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] do not ignore attribute 'noreturn'...
Date: Fri, 28 Aug 2009 21:44:05 +0000
Message-ID: <70318cbf0908281444q735b7b9fm73f0fcbdbaeefa7b () mail ! gmail ! com>
--------------------
On Fri, Aug 28, 2009 at 2:30 PM, Kamil Dudka<kdudka@redhat.com> wrote:
> enclosed is a simple patch adding support for attribute 'noreturn' to the
> parser. The enhancement makes it possible to optimize walk through CFG and
> thus help us to fight with the state explosion. The benefit is demonstrated
> on a simple real-world example.
>
> Generated CFG before patch:
> http://dudka.cz/devel/html/slsparse-before/slplug.c-handle_stmt_assign.svg
>
> Generated CFG after patch:
> http://dudka.cz/devel/html/slsparse-after/slplug.c-handle_stmt_assign.svg
>
> It's one of the key features I am currently missing in SPARSE in contrast
> to gcc used as parser. Thanks in advance for considering it!

Yes, no return is kind of useful. I think we need to do some thing about the
MOD_XXX eventually. It is very easy to run out of bits there.

Thanks for the patch. Applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] do not ignore attribute 'noreturn'...
Date: Mon, 14 Sep 2009 17:32:12 +0000
Message-ID: <200909141932.12684.kdudka () redhat ! com>
--------------------
On Monday 14 of September 2009 19:27:40 Christopher Li wrote:
> On Fri, Aug 28, 2009 at 2:44 PM, Christopher Li <sparse@chrisli.org> wrote:
> > Yes, no return is kind of useful. I think we need to do some thing about
> > the MOD_XXX eventually. It is very easy to run out of bits there.
>
> Ah, the MOD_NORETURN is bigger than size of long in 32 bit systems.
> I just get a few warning from GCC.
>
> I just relocate the MOD_NORETURN bits.

Thanks! It makes sense to me.

As for the long term solution, I don't think it's possible without breaking 
the current API/ABI. What about using a bitfield instead? I can see it solved 
this way in <gcc/tree.h>.

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] do not ignore attribute 'noreturn'...
Date: Mon, 14 Sep 2009 19:44:37 +0000
Message-ID: <200909142144.37273.kdudka () redhat ! com>
--------------------
On Monday 14 of September 2009 19:55:49 Christopher Li wrote:
> On Mon, Sep 14, 2009 at 10:32 AM, Kamil Dudka <kdudka@redhat.com> wrote:
> > As for the long term solution, I don't think it's possible without
> > breaking the current API/ABI. What about using a bitfield instead? I can
> > see it solved this way in <gcc/tree.h>.
>
> I am actually not afraid of breaking current API/ABI because there is not
> enough sparse user application to worry about. Just recompile the apps
> should be fine. Please warn me if any one disagree.
>
> As for long term, here is my plan, it will go will with Al's replace same
> type with same type pointer plan as well.
>
> We need to have a different structure to support the extended attributes
> for ctype. Current "contexts" and "as" should go into that extended
> attribute as well. Then ctype should have one pointer for extended
> attributes. For most common case, the extended attribute pointer is just
> NULL.
>
> Because the extended attribute pointer is possibles to be shared between
> different ctypes. It is not allow to modify the extended attribute struct
> from ctype directly. Instead it should replace with a new one.
> We can even hash the extended attribute struct so same attribute struct
> will have the same pointer, just like ident. That will make comparing
> attribute is the same much easier.
>
> I try it before, it is  hard to do because current code does implicit
> assign for the ctype.

It sounds like a tough challenge to me :-)

I am playing with the SPARSE API now. Any chance to pass in a unique ID
to each symbol? (as equivalent to DECL_UID from <gcc/tree.h>) I can of course 
manage an ptr/ID mapping at application level. I am only curious if this is 
possible to place directly into SPARSE, so that other apps could gain
from it. Please let me know if such functionality is already implemented
in SPARSE.

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] kmemcheck: fix sparse warning ===

From: Bernd Petrovitsch <bernd () firmix ! at>
To: linux-sparse
Subject: Re: [PATCH] kmemcheck: fix sparse warning
Date: Thu, 09 Jul 2009 09:48:10 +0000
Message-ID: <1247132890.25570.3.camel () spike ! firmix ! at>
--------------------
[ stripped people from To: and Cc: - far too trivial and well-known
answer ]

On Wed, 2009-07-08 at 23:29 -0700, Josh Triplett wrote:
> [Adding Linus and Chris Li to CC; Linus for further background on
> -Wdo-while, and Chris Li for Sparse.]
[....]
> Much discussion has occurred previously suggesting that Sparse's -Wall
> should match GCC's "all useful warnings" rather than "all possible
this is usually phrased as "all useful warnings in RMS opinion". I'm not
sure how far RMS influence is today on that.

> warnings", and some other option should exist for "all possible
> warnings" (for instance, -Weverything).  This seems very reasonable.
gcc's has "-Wextra" since ages which enables lots of other (IMHO) useful
warnings.
But it's just a name ....

	Bernd
-- 
Firmix Software GmbH                   http://www.firmix.at/
mobil: +43 664 4416156                 fax: +43 1 7890849-55
          Embedded Linux Development and Services


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] linearize.h: sanitize header ===

From: Kamil Dudka <kdudka@redhat.com>
To: Unknown
Subject: [PATCH] linearize.h: sanitize header
Date: Thu, 6 Aug 2009 10:54:56 +0200
Message-ID: 
--------------------
It's unfortunate to use 'true' and 'false' as identifiers in a system
header. It clashes with corresponding macros from <stdbool.h> when
included before <sparse/linearize.h>.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 linearize.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/linearize.h b/linearize.h
index 2205082..50b3601 100644
--- a/linearize.h
+++ b/linearize.h
@@ -328,7 +328,7 @@ struct entrypoint {
 	struct instruction *entry;
 };
 
-extern void insert_select(struct basic_block *bb, struct instruction *br, struct instruction *phi, pseudo_t true, pseudo_t false);
+extern void insert_select(struct basic_block *bb, struct instruction *br, struct instruction *phi, pseudo_t if_true, pseudo_t if_false);
 extern void insert_branch(struct basic_block *bb, struct instruction *br, struct basic_block *target);
 
 pseudo_t alloc_phi(struct basic_block *source, pseudo_t pseudo, int size);
-- 
1.6.2.5


--Boundary-00=_WwpeK+nnTQatjOH--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: [PATCH] linearize.h: sanitize header
Date: Thu, 06 Aug 2009 09:02:14 +0000
Message-ID: <200908061102.14935.kdudka () redhat ! com>
--------------------
--Boundary-00=_WwpeK+nnTQatjOH
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hello,

please consider applying the attached one-line patch. Feel free to choose 
better identifiers if these are not accurate enough. Thanks!

Kamil



--Boundary-00=_WwpeK+nnTQatjOH
Content-Type: text/x-patch;
  charset="us-ascii";
  name="0001-linearize.h-sanitize-header.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
	filename="0001-linearize.h-sanitize-header.patch"


================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] linearize.h: sanitize header
Date: Thu, 06 Aug 2009 09:30:08 +0000
Message-ID: <200908061130.08387.kdudka () redhat ! com>
--------------------
On Thu August 6 2009 11:23:26 Hannes Eder wrote:
> On Thu, Aug 6, 2009 at 11:02, Kamil Dudka<kdudka@redhat.com> wrote:
> > It's unfortunate to use 'true' and 'false' as identifiers in a system
> > header. It clashes with corresponding macros from <stdbool.h> when
> > included before <sparse/linearize.h>.
> >
> > Signed-off-by: Kamil Dudka <kdudka@redhat.com>
> > ---
> >  linearize.h |    2 +-
> >  1 files changed, 1 insertions(+), 1 deletions(-)
> >
> > diff --git a/linearize.h b/linearize.h
> > index 2205082..50b3601 100644
> > --- a/linearize.h
> > +++ b/linearize.h
> > @@ -328,7 +328,7 @@ struct entrypoint {
> >         struct instruction *entry;
> >  };
> >
> > -extern void insert_select(struct basic_block *bb, struct instruction
> > *br, struct instruction *phi, pseudo_t true, pseudo_t false); +extern
> > void insert_select(struct basic_block *bb, struct instruction *br, struct
> > instruction *phi, pseudo_t if_true, pseudo_t if_false);
>
> I guess it is wise to change this in linearize.c as well.  Mind sending a
> patch?

The question is if we need/want to :-) It's change of the working code for no 
real benefit. I am talking only about system-wide headers which can be 
included anywhere.

Kamil

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] linearize.h: sanitize header
Date: Thu, 06 Aug 2009 09:51:11 +0000
Message-ID: <200908061151.11277.kdudka () redhat ! com>
--------------------
On Thu August 6 2009 11:39:11 Hannes Eder wrote:
> >> I guess it is wise to change this in linearize.c as well.  Mind sending
> >> a patch?
> >
> > The question is if we need/want to :-) It's change of the working code
> > for no real benefit. I am talking only about system-wide headers which
> > can be included anywhere.
>
> Well I see at least one benefit, a small one though.  Syntax
> highlighting is somewhat confused with "true" and "false", at least
> emacs is.  They appear like the constants, where in fact they are
> variables.

I can confirm it's the same case with the vim's syntax highlighter.

> The likelyhood to break the code by renaming this two variables is
> kinda low, no?  And IHMO it was not so wise in the first place to pick
> these names. ;)

I would contend that only two variables are affected. They are if we consider 
only headers. However the situation is much worse when we concern about .c 
files. The patch would be non-trivial. Please try the following command:

$ grep --color '[^_]false[^_]' *.c

Kamil

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Hannes Eder <hannes () hanneseder ! net>
To: linux-sparse
Subject: Re: [PATCH] linearize.h: sanitize header
Date: Thu, 06 Aug 2009 11:09:03 +0000
Message-ID: <154e089b0908060409v4dff4785x456b5aad2460ed84 () mail ! gmail ! com>
--------------------
On Thu, Aug 6, 2009 at 11:51, Kamil Dudka<kdudka@redhat.com> wrote:
> On Thu August 6 2009 11:39:11 Hannes Eder wrote:
>> >> I guess it is wise to change this in linearize.c as well. Â Mind sending
>> >> a patch?
>> >
>> > The question is if we need/want to :-) It's change of the working code
>> > for no real benefit. I am talking only about system-wide headers which
>> > can be included anywhere.
>>
>> Well I see at least one benefit, a small one though. Â Syntax
>> highlighting is somewhat confused with "true" and "false", at least
>> emacs is. Â They appear like the constants, where in fact they are
>> variables.
>
> I can confirm it's the same case with the vim's syntax highlighter.
>
>> The likelyhood to break the code by renaming this two variables is
>> kinda low, no? Â And IHMO it was not so wise in the first place to pick
>> these names. ;)
>
> I would contend that only two variables are affected. They are if we consider
> only headers. However the situation is much worse when we concern about .c
> files. The patch would be non-trivial. Please try the following command:
>
> $ grep --color '[^_]false[^_]' *.c

$ grep --color '\bfalse\b\|\btrue\b' *.c | wc -l
91

some of them are just in comments, does not look to scary to me.  If
others agree that its a good idea to rename them, I can do it if you
don't want to.

-Hannes
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] linearize.h: sanitize header
Date: Thu, 06 Aug 2009 17:10:30 +0000
Message-ID: <70318cbf0908061010w737ac3d7j1feb1f9744217df7 () mail ! gmail ! com>
--------------------
On Thu, Aug 6, 2009 at 4:09 AM, Hannes Eder<hannes@hanneseder.net> wrote:
>> $ grep --color '[^_]false[^_]' *.c
>
> $ grep --color '\bfalse\b\|\btrue\b' *.c | wc -l
> 91
>
> some of them are just in comments, does not look to scary to me.  If
> others agree that its a good idea to rename them, I can do it if you
> don't want to.

I would just apply the change to the header file and related variables.
The linearize.h is consider an API header file for other sparse application
to use. So we'd better not assume too much on the sparse caller side.

I agree with Kamil that rename variable in linearize.c offer no real
benefits. I consider it more of a personal preference thing. And it is
internal to linearize.c. At this point renaming variable will mess up with
annotations. It is not good enough reason to do it just to make
the editor happy.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] linearize.h: sanitize header
Date: Thu, 06 Aug 2009 17:27:46 +0000
Message-ID: <200908061927.47201.kdudka () redhat ! com>
--------------------
--Boundary-00=_TKxeKQDGjWT5c1A
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Thursday 06 of August 2009 19:10:30 Christopher Li wrote:
> I would just apply the change to the header file and related variables.
> The linearize.h is consider an API header file for other sparse application
> to use. So we'd better not assume too much on the sparse caller side.
>
> I agree with Kamil that rename variable in linearize.c offer no real
> benefits. I consider it more of a personal preference thing. And it is
> internal to linearize.c. At this point renaming variable will mess up with
> annotations. It is not good enough reason to do it just to make
> the editor happy.

Well, let's make a tradeoff - we can only change the identifiers
in linearize.h and the corresponding identifiers in linearize.c. I admit it 
could be confusing when we have different identifiers in the prototype and 
different identifiers in the function body. New version of the patch is 
attached.

Kamil

--Boundary-00=_TKxeKQDGjWT5c1A
Content-Type: text/x-diff;
  charset="iso-8859-1";
  name="0001-linearize.h-sanitize-header.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="0001-linearize.h-sanitize-header.patch"

=46rom 4d4c71eb876351d53e0f8edf0f121950ec2a9a84 Mon Sep 17 00:00:00 2001
=46rom: Kamil Dudka <kdudka@redhat.com>
Date: Thu, 6 Aug 2009 19:20:51 +0200
Subject: [PATCH] linearize.h: sanitize header

It's unfortunate to use 'true' and 'false' as identifiers in a system
header. It clashes with corresponding macros from <stdbool.h> when
included before <sparse/linearize.h>.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
=2D--
 linearize.c |    6 +++---
 linearize.h |    2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/linearize.c b/linearize.c
index 1a19214..238ee5d 100644
=2D-- a/linearize.c
+++ b/linearize.c
@@ -666,7 +666,7 @@ void insert_branch(struct basic_block *bb, struct instr=
uction *jmp, struct basic
 }
 =09
=20
=2Dvoid insert_select(struct basic_block *bb, struct instruction *br, struc=
t instruction *phi_node, pseudo_t true, pseudo_t false)
+void insert_select(struct basic_block *bb, struct instruction *br, struct =
instruction *phi_node, pseudo_t if_true, pseudo_t if_false)
 {
 	pseudo_t target;
 	struct instruction *select;
@@ -685,8 +685,8 @@ void insert_select(struct basic_block *bb, struct instr=
uction *br, struct instru
 	select->target =3D target;
 	target->def =3D select;
=20
=2D	use_pseudo(select, true, &select->src2);
=2D	use_pseudo(select, false, &select->src3);
+	use_pseudo(select, if_true, &select->src2);
+	use_pseudo(select, if_false, &select->src3);
=20
 	add_instruction(&bb->insns, select);
 	add_instruction(&bb->insns, br);
diff --git a/linearize.h b/linearize.h
index 2205082..50b3601 100644
=2D-- a/linearize.h
+++ b/linearize.h
@@ -328,7 +328,7 @@ struct entrypoint {
 	struct instruction *entry;
 };
=20
=2Dextern void insert_select(struct basic_block *bb, struct instruction *br=
, struct instruction *phi, pseudo_t true, pseudo_t false);
+extern void insert_select(struct basic_block *bb, struct instruction *br, =
struct instruction *phi, pseudo_t if_true, pseudo_t if_false);
 extern void insert_branch(struct basic_block *bb, struct instruction *br, =
struct basic_block *target);
=20
 pseudo_t alloc_phi(struct basic_block *source, pseudo_t pseudo, int size);
=2D-=20
1.6.3.3


--Boundary-00=_TKxeKQDGjWT5c1A--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Hannes Eder <hannes () hanneseder ! net>
To: linux-sparse
Subject: Re: [PATCH] linearize.h: sanitize header
Date: Thu, 06 Aug 2009 17:49:23 +0000
Message-ID: <154e089b0908061049o714bd341v733e828166a8f604 () mail ! gmail ! com>
--------------------
On Thu, Aug 6, 2009 at 19:27, Kamil Dudka<kdudka@redhat.com> wrote:
> On Thursday 06 of August 2009 19:10:30 Christopher Li wrote:
>> I would just apply the change to the header file and related variables.
>> The linearize.h is consider an API header file for other sparse application
>> to use. So we'd better not assume too much on the sparse caller side.
>>
>> I agree with Kamil that rename variable in linearize.c offer no real
>> benefits. I consider it more of a personal preference thing. And it is
>> internal to linearize.c. At this point renaming variable will mess up with
>> annotations. It is not good enough reason to do it just to make
>> the editor happy.
>
> Well, let's make a tradeoff - we can only change the identifiers
> in linearize.h and the corresponding identifiers in linearize.c. I admit it
> could be confusing when we have different identifiers in the prototype and
> different identifiers in the function body. New version of the patch is
> attached.

LGTM

Acked-by: Hannes Eder <hannes@hanneseder.net>

Best,
-Hannes
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] make sparse headers self-compilable... ===

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: [PATCH] make sparse headers self-compilable...
Date: Fri, 07 Aug 2009 20:27:08 +0000
Message-ID: <200908072227.08652.kdudka () redhat ! com>
--------------------
--Boundary-00=_c4IfKEAQe3HiagY
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hello,

attached is another fix for SPARSE headers improving their sanity. I am
also attaching a simple test for the dependency tracking of headers. It's
not enough generic and portable and therefore not really useful. Maybe 
someone skilled in writing makefiles might want to include something like
that to the SPARSE Makefile as part of the 'check' target.

Kamil

--Boundary-00=_c4IfKEAQe3HiagY
Content-Type: text/x-diff;
  charset="us-ascii";
  name="0001-make-sparse-headers-self-compilable.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="0001-make-sparse-headers-self-compilable.patch"

=46rom 8ffbb46652f69e662ce39c135f1867599c0f5477 Mon Sep 17 00:00:00 2001
=46rom: Kamil Dudka <kdudka@redhat.com>
Date: Fri, 7 Aug 2009 21:48:44 +0200
Subject: [PATCH] make sparse headers self-compilable...

=2E.. and thus possible to include them in arbitrary order and without any
external dependencies.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
=2D--
 compile.h |    2 ++
 flow.h    |    2 ++
 ptrlist.h |    2 ++
 scope.h   |    2 ++
 storage.h |    2 ++
 5 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/compile.h b/compile.h
index 0db8fdb..6c5260d 100644
=2D-- a/compile.h
+++ b/compile.h
@@ -1,6 +1,8 @@
 #ifndef COMPILE_H
 #define COMPILE_H
=20
+#include "symbol.h"
+
 extern void emit_one_symbol(struct symbol *);
 extern void emit_unit_begin(const char *);
 extern void emit_unit_end(void);
diff --git a/flow.h b/flow.h
index 9f2e165..241f081 100644
=2D-- a/flow.h
+++ b/flow.h
@@ -1,6 +1,8 @@
 #ifndef FLOW_H
 #define FLOW_H
=20
+#include "symbol.h"
+
 extern unsigned long bb_generation;
=20
 #define REPEAT_CSE		1
diff --git a/ptrlist.h b/ptrlist.h
index dae0906..85b23fc 100644
=2D-- a/ptrlist.h
+++ b/ptrlist.h
@@ -7,6 +7,8 @@
  * (C) Copyright Linus Torvalds 2003-2005
  */
=20
+#include <stdlib.h>
+
 #define container(ptr, type, member) \
 	(type *)((void *)(ptr) - offsetof(type, member))
=20
diff --git a/scope.h b/scope.h
index 5f1f232..aff7b6b 100644
=2D-- a/scope.h
+++ b/scope.h
@@ -9,6 +9,8 @@
  *  Licensed under the Open Software License version 1.1
  */
=20
+#include "symbol.h"
+
 struct scope {
 	struct token *token;		/* Scope start information */
 	struct symbol_list *symbols;	/* List of symbols in this scope */
diff --git a/storage.h b/storage.h
index 610cbfd..0d3bbc5 100644
=2D-- a/storage.h
+++ b/storage.h
@@ -1,6 +1,8 @@
 #ifndef STORAGE_H
 #define STORAGE_H
=20
+#include "lib.h"
+
 /*
  * The "storage" that underlies an incoming/outgoing pseudo. It's
  * basically the backing store for a pseudo, and may be a real hardware
=2D-=20
1.6.3.3


--Boundary-00=_c4IfKEAQe3HiagY
Content-Type: text/x-makefile;
  charset="us-ascii";
  name="Makefile.chk"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
	filename="Makefile.chk"

# all SPARSE headers (except ident-list.h which is not an ordinary header)
HEADERS ?= \
	allocate.h \
	bitmap.h \
	compat.h \
	compile.h \
	dissect.h \
	expression.h \
	flow.h \
	lib.h \
	linearize.h \
	parse.h \
	ptrlist.h \
	scope.h \
	storage.h \
	symbol.h \
	target.h \
	token.h \

SINK ?= /dev/null

.PHONY: check $(HEADERS)

# check whether each header is self-compilable
check: $(HEADERS)
$(HEADERS):
	$(CC) -o $(SINK) -c $@

--Boundary-00=_c4IfKEAQe3HiagY--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] make sparse headers self-compilable...
Date: Tue, 11 Aug 2009 09:40:45 +0000
Message-ID: <70318cbf0908110240w5067933dv92e92829c0bb2e8f () mail ! gmail ! com>
--------------------
On Sat, Aug 8, 2009 at 4:10 AM, Kamil Dudka<kdudka@redhat.com> wrote:
> On Friday 07 of August 2009 22:27:08 Kamil Dudka wrote:
>> attached is another fix for SPARSE headers improving their sanity. I am
>> also attaching a simple test for the dependency tracking of headers. It's
>> not enough generic and portable and therefore not really useful. Maybe
>> someone skilled in writing makefiles might want to include something like
>> that to the SPARSE Makefile as part of the 'check' target.

What is the significant of making every header file self compilable?
Unlike the kernel header files exported to user space, which usually
have self contained meaning. Most of these header file have tight interaction
with each other. I don't think it make sense for other sparse application
to just use one of the header file.

Enforcing each header file to be self compilable will result in a lot
of unnecessary include. Gcc needs to include "symbol.h" many times
just to skip over it. Take a look at pre-process.c. It is not exactly
trivial. It needs to scan the token to find out the end of the if
scope. In this case, it might be better just let other header
file depend on "symbol.h".

I want to heard what other people think about it too. I am a little bit
reluctant on this one.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] make sparse headers self-compilable...
Date: Tue, 11 Aug 2009 09:55:19 +0000
Message-ID: <200908111155.19586.kdudka () redhat ! com>
--------------------
On Tuesday 11 of August 2009 11:40:45 Christopher Li wrote:
> What is the significant of making every header file self compilable?
> Unlike the kernel header files exported to user space, which usually
> have self contained meaning. Most of these header file have tight
> interaction with each other. I don't think it make sense for other sparse
> application to just use one of the header file.
>
> Enforcing each header file to be self compilable will result in a lot
> of unnecessary include. Gcc needs to include "symbol.h" many times
> just to skip over it. Take a look at pre-process.c. It is not exactly
> trivial. It needs to scan the token to find out the end of the if
> scope. In this case, it might be better just let other header
> file depend on "symbol.h".

Then an ordinary SPARSE user needs to try various permutation of the includes 
to pass his hello-world through compiler. It could be really annoying. I'd 
like to have all includes in alphabetical order because it's then easier to 
maintenance.

If you really want to have external dependencies of SPARSE headers (no matter 
what reason for), the dependencies should be exactly documented somewhere - 
maybe in the headers themselves?

What about replacing my '#include "allocate.h"' with comment '// ATTENTION: 
you have to include allocate.h before storage.h'?

> I want to heard what other people think about it too. I am a little bit
> reluctant on this one.

No problem with me as it has easy workaround.

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] make sparse headers self-compilable...
Date: Tue, 11 Aug 2009 10:40:06 +0000
Message-ID: <200908111240.06529.kdudka () redhat ! com>
--------------------
On Tuesday 11 of August 2009 11:55:19 Kamil Dudka wrote:
> On Tuesday 11 of August 2009 11:40:45 Christopher Li wrote:
> > What is the significant of making every header file self compilable?
> > Unlike the kernel header files exported to user space, which usually
> > have self contained meaning. Most of these header file have tight
> > interaction with each other. I don't think it make sense for other sparse
> > application to just use one of the header file.
> >
> > Enforcing each header file to be self compilable will result in a lot
> > of unnecessary include. Gcc needs to include "symbol.h" many times
> > just to skip over it. Take a look at pre-process.c. It is not exactly
> > trivial. It needs to scan the token to find out the end of the if
> > scope. In this case, it might be better just let other header
> > file depend on "symbol.h".

I agree processing of multiple-includes could be painful for the SPARSE 
preprocessor. But you don't solve it by avoiding multiple-includes in the 
SPARSE code itself. If you want to pass the SPARSE code through SPARSE, it's 
small enough to not bother us with performance.

But you have absolutely no control of the foreign code processed by SPARSE
and there the performance impact could be significant. I think this is the
way to go:

http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Hannes Eder <hannes () hanneseder ! net>
To: linux-sparse
Subject: Re: [PATCH] make sparse headers self-compilable...
Date: Tue, 11 Aug 2009 12:48:39 +0000
Message-ID: <154e089b0908110548t33b9114ej4bf3a019ee6ab80e () mail ! gmail ! com>
--------------------
On Tue, Aug 11, 2009 at 11:40, Christopher Li<sparse@chrisli.org> wrote:
> On Sat, Aug 8, 2009 at 4:10 AM, Kamil Dudka<kdudka@redhat.com> wrote:
>> On Friday 07 of August 2009 22:27:08 Kamil Dudka wrote:
>>> attached is another fix for SPARSE headers improving their sanity. I am
>>> also attaching a simple test for the dependency tracking of headers. It's
>>> not enough generic and portable and therefore not really useful. Maybe
>>> someone skilled in writing makefiles might want to include something like
>>> that to the SPARSE Makefile as part of the 'check' target.
>
> What is the significant of making every header file self compilable?
> Unlike the kernel header files exported to user space, which usually
> have self contained meaning. Most of these header file have tight interaction
> with each other. I don't think it make sense for other sparse application
> to just use one of the header file.
>
> Enforcing each header file to be self compilable will result in a lot
> of unnecessary include. Gcc needs to include "symbol.h" many times
> just to skip over it. Take a look at pre-process.c. It is not exactly
> trivial. It needs to scan the token to find out the end of the if
> scope. In this case, it might be better just let other header
> file depend on "symbol.h".
>
> I want to heard what other people think about it too. I am a little bit
> reluctant on this one.

What about just using some forward decls instead of including the header files?

e.g. for compile.h it is enough to have a "struct symbol;" there
instead of the "#include <symbol.h>" to make it self-compilable.

Cheers,
-Hannes
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] make sparse headers self-compilable...
Date: Tue, 11 Aug 2009 12:59:23 +0000
Message-ID: <200908111459.23341.kdudka () redhat ! com>
--------------------
--Boundary-00=_rsWgK/MkOv0fS24
Content-Type: text/plain;
  charset="utf-8"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Tuesday 11 of August 2009 14:48:39 Hannes Eder wrote:
> What about just using some forward decls instead of including the header
> files?
>
> e.g. for compile.h it is enough to have a "struct symbol;" there
> instead of the "#include <symbol.h>" to make it self-compilable.

Thanks for the hint! It's definitely better, though not sufficient in all 
cases. The amended patch is attached.

Kamil

--Boundary-00=_rsWgK/MkOv0fS24
Content-Type: text/x-diff;
  charset="utf-8";
  name="0001-make-sparse-headers-self-compilable.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="0001-make-sparse-headers-self-compilable.patch"

=46rom 93455c6fe7dc84e1519bec70a9fd8625a879d791 Mon Sep 17 00:00:00 2001
=46rom: Kamil Dudka <kdudka@redhat.com>
Date: Tue, 11 Aug 2009 14:56:53 +0200
Subject: [PATCH] make sparse headers self-compilable...

=2E.. and thus possible to include them in arbitrary order and without any
external dependencies.

Signed-off-by: Kamil Dudka <kdudka@redhat.com>
=2D--
 compile.h |    2 ++
 flow.h    |    5 +++++
 ptrlist.h |    2 ++
 scope.h   |    2 ++
 storage.h |    3 +++
 5 files changed, 14 insertions(+), 0 deletions(-)

diff --git a/compile.h b/compile.h
index 0db8fdb..177363a 100644
=2D-- a/compile.h
+++ b/compile.h
@@ -1,6 +1,8 @@
 #ifndef COMPILE_H
 #define COMPILE_H
=20
+struct symbol;
+
 extern void emit_one_symbol(struct symbol *);
 extern void emit_unit_begin(const char *);
 extern void emit_unit_end(void);
diff --git a/flow.h b/flow.h
index fbc9505..370aadd 100644
=2D-- a/flow.h
+++ b/flow.h
@@ -1,11 +1,16 @@
 #ifndef FLOW_H
 #define FLOW_H
=20
+#include "lib.h"
+
 extern unsigned long bb_generation;
=20
 #define REPEAT_CSE		1
 #define REPEAT_SYMBOL_CLEANUP	2
=20
+struct entrypoint;
+struct instruction;
+
 extern int simplify_flow(struct entrypoint *ep);
=20
 extern void simplify_symbol_usage(struct entrypoint *ep);
diff --git a/ptrlist.h b/ptrlist.h
index dae0906..fbfc080 100644
=2D-- a/ptrlist.h
+++ b/ptrlist.h
@@ -1,6 +1,8 @@
 #ifndef PTR_LIST_H
 #define PTR_LIST_H
=20
+#include <stdlib.h>
+
 /*
  * Generic pointer list manipulation code.=20
  *
diff --git a/scope.h b/scope.h
index 5f1f232..0fab286 100644
=2D-- a/scope.h
+++ b/scope.h
@@ -9,6 +9,8 @@
  *  Licensed under the Open Software License version 1.1
  */
=20
+struct symbol;
+
 struct scope {
 	struct token *token;		/* Scope start information */
 	struct symbol_list *symbols;	/* List of symbols in this scope */
diff --git a/storage.h b/storage.h
index 610cbfd..e049e23 100644
=2D-- a/storage.h
+++ b/storage.h
@@ -1,6 +1,9 @@
 #ifndef STORAGE_H
 #define STORAGE_H
=20
+#include "allocate.h"
+#include "lib.h"
+
 /*
  * The "storage" that underlies an incoming/outgoing pseudo. It's
  * basically the backing store for a pseudo, and may be a real hardware
=2D-=20
1.6.4


--Boundary-00=_rsWgK/MkOv0fS24--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] make sparse headers self-compilable...
Date: Tue, 11 Aug 2009 21:08:24 +0000
Message-ID: <70318cbf0908111408u238bd057vd3e4578baa0fe32c () mail ! gmail ! com>
--------------------
On Tue, Aug 11, 2009 at 3:40 AM, Kamil Dudka<kdudka@redhat.com> wrote:
> I agree processing of multiple-includes could be painful for the SPARSE
> preprocessor. But you don't solve it by avoiding multiple-includes in the
> SPARSE code itself. If you want to pass the SPARSE code through SPARSE, it's
> small enough to not bother us with performance.

I am worry about adding too much duplicated include slow down the
gcc compile of sparse itself. I know I am paranoid :-)

>
> But you have absolutely no control of the foreign code processed by SPARSE
> and there the performance impact could be significant. I think this is the
> way to go:
>
> http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html

BTW, sparse does similar things already. That is what the stream->protect
was for.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] make sparse headers self-compilable...
Date: Tue, 11 Aug 2009 21:08:59 +0000
Message-ID: <70318cbf0908111408y609dd2cex42c6b78d3e35d709 () mail ! gmail ! com>
--------------------
On Tue, Aug 11, 2009 at 5:59 AM, Kamil Dudka<kdudka@redhat.com> wrote:
> Thanks for the hint! It's definitely better, though not sufficient in all
> cases. The amended patch is attached.

Will apply.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] show_token: handle TOKEN_UNTAINT and TOKEN_ARG_COUNT ===

From: Chris Li <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] show_token: handle TOKEN_UNTAINT and TOKEN_ARG_COUNT
Date: Tue, 11 Aug 2009 20:39:06 +0000
Message-ID: <70318cbf0908111339u75597849o7e037d17aee9a46 () mail ! gmail ! com>
--------------------
On Thu, Apr 30, 2009 at 2:08 PM, Reinhard Tartler<siretart@tauware.de> wrote:
>
> These cases are probably never hit with "regular" codepaths, but are
> useful when called in a gdb session to print token sequences.
>
> Signed-off-by: Reinhard Tartler <siretart@tauware.de>

Thanks, applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: Add GCC pre-defined macros for user-space ===

From: Pekka Enberg <penberg () cs ! helsinki ! fi>
To: linux-sparse
Subject: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sat, 15 Aug 2009 14:57:15 +0000
Message-ID: <1250348235-19691-1-git-send-email-penberg () cs ! helsinki ! fi>
--------------------
Sparse prints a lot of warnings like this for user-space projects:

  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:33:22: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:5: warning: undefined preprocessor identifier '__SHRT_MAX__'
  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:21: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/include/bits/xopen_lim.h:95:6: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/include/bits/xopen_lim.h:98:7: warning: undefined preprocessor identifier '__INT_MAX__'

Fix that up by defining some GCC pre-processor builtins.

Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
---
 ident-list.h  |    7 +++++++
 pre-process.c |   20 ++++++++++++++++++++
 2 files changed, 27 insertions(+), 0 deletions(-)

diff --git a/ident-list.h b/ident-list.h
index 0ee81bc..c0a2735 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -99,6 +99,13 @@ __IDENT(__func___ident, "__func__", 0);
 __IDENT(__FUNCTION___ident, "__FUNCTION__", 0);
 __IDENT(__PRETTY_FUNCTION___ident, "__PRETTY_FUNCTION__", 0);
 
+__IDENT(__SCHAR_MAX__ident, "__SCHAR_MAX__", 0);
+__IDENT(__SHRT_MAX__ident, "__SHRT_MAX__", 0);
+__IDENT(__INT_MAX__ident, "__INT_MAX__", 0);
+__IDENT(__LONG_MAX__ident, "__LONG_MAX__", 0);
+__IDENT(__LONG_LONG_MAX__ident, "__LONG_LONG_MAX__", 0);
+__IDENT(__WCHAR_MAX__ident, "__WCHAR_MAX__", 0);
+
 /* Sparse commands */
 IDENT_RESERVED(__context__);
 IDENT_RESERVED(__range__);
diff --git a/pre-process.c b/pre-process.c
index 34b21ff..de3d3f1 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -106,6 +106,14 @@ static void replace_with_integer(struct token *token, unsigned int val)
 	token->number = buf;
 }
 
+static void replace_with_long_long(struct token *token, unsigned long long val)
+{
+	char *buf = __alloc_bytes(20);
+	sprintf(buf, "%llu", val);
+	token_type(token) = TOKEN_NUMBER;
+	token->number = buf;
+}
+
 static struct symbol *lookup_macro(struct ident *ident)
 {
 	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_UNDEF);
@@ -167,6 +175,18 @@ static int expand_one_symbol(struct token **list)
 			time(&t);
 		strftime(buffer, 9, "%T", localtime(&t));
 		replace_with_string(token, buffer);
+	} else if (token->ident == &__SHRT_MAX__ident) {
+		replace_with_integer(token, __SHRT_MAX__);
+	} else if (token->ident == &__SCHAR_MAX__ident) {
+		replace_with_integer(token, __SCHAR_MAX__);
+	} else if (token->ident == &__INT_MAX__ident) {
+		replace_with_integer(token, __INT_MAX__);
+	} else if (token->ident == &__LONG_MAX__ident) {
+		replace_with_integer(token, __LONG_MAX__);
+	} else if (token->ident == &__LONG_LONG_MAX__ident) {
+		replace_with_long_long(token, __LONG_LONG_MAX__);
+	} else if (token->ident == &__WCHAR_MAX__ident) {
+		replace_with_integer(token, __WCHAR_MAX__);
 	}
 	return 1;
 }
-- 
1.5.6.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sat, 15 Aug 2009 19:36:37 +0000
Message-ID: <70318cbf0908151236q2c691d73n5114ab21f3cbd819 () mail ! gmail ! com>
--------------------
On Sat, Aug 15, 2009 at 7:57 AM, Pekka Enberg<penberg@cs.helsinki.fi> wrote:
> +       } else if (token->ident == &__SHRT_MAX__ident) {
> +               replace_with_integer(token, __SHRT_MAX__);
> +       } else if (token->ident == &__SCHAR_MAX__ident) {
> +               replace_with_integer(token, __SCHAR_MAX__);
> +       } else if (token->ident == &__INT_MAX__ident) {
> +               replace_with_integer(token, __INT_MAX__);
> +       } else if (token->ident == &__LONG_MAX__ident) {
> +               replace_with_integer(token, __LONG_MAX__);
> +       } else if (token->ident == &__LONG_LONG_MAX__ident) {
> +               replace_with_long_long(token, __LONG_LONG_MAX__);
> +       } else if (token->ident == &__WCHAR_MAX__ident) {
> +               replace_with_integer(token, __WCHAR_MAX__);


I am pretty sure that is not the way to do it in sparse.  If you just want
add some sparse builtin defines, it is much better to add them in
create_builtin_streams(). It would be even better to group them in a new
function create_builtin_define():

Some thing like:

add_pre_buffer("#weak_define __INT_MAX__ %d\n", __INT_MAX__);

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () cs ! helsinki ! fi>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sat, 15 Aug 2009 20:26:31 +0000
Message-ID: <1250367991.14751.1.camel () penberg-laptop>
--------------------
Hi Chris,

On Sat, 2009-08-15 at 12:36 -0700, Christopher Li wrote:
> On Sat, Aug 15, 2009 at 7:57 AM, Pekka Enberg<penberg@cs.helsinki.fi> wrote:
> > +       } else if (token->ident == &__SHRT_MAX__ident) {
> > +               replace_with_integer(token, __SHRT_MAX__);
> > +       } else if (token->ident == &__SCHAR_MAX__ident) {
> > +               replace_with_integer(token, __SCHAR_MAX__);
> > +       } else if (token->ident == &__INT_MAX__ident) {
> > +               replace_with_integer(token, __INT_MAX__);
> > +       } else if (token->ident == &__LONG_MAX__ident) {
> > +               replace_with_integer(token, __LONG_MAX__);
> > +       } else if (token->ident == &__LONG_LONG_MAX__ident) {
> > +               replace_with_long_long(token, __LONG_LONG_MAX__);
> > +       } else if (token->ident == &__WCHAR_MAX__ident) {
> > +               replace_with_integer(token, __WCHAR_MAX__);
> 
> 
> I am pretty sure that is not the way to do it in sparse.  If you just want
> add some sparse builtin defines, it is much better to add them in
> create_builtin_streams(). It would be even better to group them in a new
> function create_builtin_define():
> 
> Some thing like:
> 
> add_pre_buffer("#weak_define __INT_MAX__ %d\n", __INT_MAX__);

Oh, right, makes sense. I am a total sparse newbie so does something
like this look better (works fine for me)?

			Pekka

>From 8e19ea98138dd43a5482519fec6f7488422aff30 Mon Sep 17 00:00:00 2001
From: Pekka Enberg <penberg@cs.helsinki.fi>
Date: Sat, 15 Aug 2009 23:22:24 +0300
Subject: [PATCH] Define GCC builtin defines for limits.h

Sparse produces a bunch of warnings like this when compiling against
glibc:

  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:33:22: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:5: warning: undefined preprocessor identifier '__SHRT_MAX__'
  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:21: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/include/bits/xopen_lim.h:95:6: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/include/bits/xopen_lim.h:98:7: warning: undefined preprocessor identifier '__INT_MAX__'

Fix that up by adding some add_pre_buffer() calls to
create_builtin_define(). For future reference, GCC defines the builtins
in the c_cpp_builtins() function in gcc/c-cppbuiltin.c.

Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
---
 lib.c |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index 42affcd..0510ae0 100644
--- a/lib.c
+++ b/lib.c
@@ -788,6 +788,14 @@ void create_builtin_stream(void)
 		add_pre_buffer("#define __OPTIMIZE__ 1\n");
 	if (optimize_size)
 		add_pre_buffer("#define __OPTIMIZE_SIZE__ 1\n");
+
+	/* GCC defines these for limits.h */
+	add_pre_buffer("#weak_define __SHRT_MAX__ %d\n", __SHRT_MAX__);
+	add_pre_buffer("#weak_define __SCHAR_MAX__ %d\n", __SCHAR_MAX__);
+	add_pre_buffer("#weak_define __INT_MAX__ %d\n", __INT_MAX__);
+	add_pre_buffer("#weak_define __LONG_MAX__ %ld\n", __LONG_MAX__);
+	add_pre_buffer("#weak_define __LONG_LONG_MAX__ %lld\n", __LONG_LONG_MAX__);
+	add_pre_buffer("#weak_define __WCHAR_MAX__ %d\n", __WCHAR_MAX__);
 }
 
 static struct symbol_list *sparse_tokenstream(struct token *token)
-- 
1.5.6.3



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sat, 15 Aug 2009 22:36:03 +0000
Message-ID: <20090815223602.GA4516 () feather>
--------------------
On Sat, Aug 15, 2009 at 11:26:31PM +0300, Pekka Enberg wrote:
> --- a/lib.c
> +++ b/lib.c
> @@ -788,6 +788,14 @@ void create_builtin_stream(void)
>  		add_pre_buffer("#define __OPTIMIZE__ 1\n");
>  	if (optimize_size)
>  		add_pre_buffer("#define __OPTIMIZE_SIZE__ 1\n");
> +
> +	/* GCC defines these for limits.h */
> +	add_pre_buffer("#weak_define __SHRT_MAX__ %d\n", __SHRT_MAX__);
> +	add_pre_buffer("#weak_define __SCHAR_MAX__ %d\n", __SCHAR_MAX__);
> +	add_pre_buffer("#weak_define __INT_MAX__ %d\n", __INT_MAX__);
> +	add_pre_buffer("#weak_define __LONG_MAX__ %ld\n", __LONG_MAX__);
> +	add_pre_buffer("#weak_define __LONG_LONG_MAX__ %lld\n", __LONG_LONG_MAX__);
> +	add_pre_buffer("#weak_define __WCHAR_MAX__ %d\n", __WCHAR_MAX__);

These defines need to have the right type suffixes.  GCC defines
__LONG_LONG_MAX__ with an LL suffix, and __LONG_MAX__ with an L suffix.
You could either add the appropriate suffixes, or better yet, stringize
the constants and print them as strings.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sun, 16 Aug 2009 10:51:14 +0000
Message-ID: <20090816105114.GA6489 () feather>
--------------------
On Sun, Aug 16, 2009 at 10:03:53AM +0300, Pekka Enberg wrote:
> On Sat, 2009-08-15 at 15:36 -0700, Josh Triplett wrote:
> > These defines need to have the right type suffixes.  GCC defines
> > __LONG_LONG_MAX__ with an LL suffix, and __LONG_MAX__ with an L suffix.
> > You could either add the appropriate suffixes, or better yet, stringize
> > the constants and print them as strings.
> 
> Right. Is there a macro in sparse to do the stringification? I didn't
> find one and the best I could come up is this.
[...]
> --- a/lib.c
> +++ b/lib.c
> @@ -788,6 +788,14 @@ void create_builtin_stream(void)
>  		add_pre_buffer("#define __OPTIMIZE__ 1\n");
>  	if (optimize_size)
>  		add_pre_buffer("#define __OPTIMIZE_SIZE__ 1\n");
> +
> +	/* GCC defines these for limits.h */
> +	add_pre_buffer("#weak_define __SHRT_MAX__ " STRINGIFY(__SHRT_MAX__) "\n");
> +	add_pre_buffer("#weak_define __SCHAR_MAX__ " STRINGIFY(__SCHAR_MAX__) "\n");
> +	add_pre_buffer("#weak_define __INT_MAX__ " STRINGIFY(__INT_MAX__) "\n");
> +	add_pre_buffer("#weak_define __LONG_MAX__ " STRINGIFY(__LONG_MAX__) "\n");
> +	add_pre_buffer("#weak_define __LONG_LONG_MAX__ " STRINGIFY(__LONG_LONG_MAX__) "\n");
> +	add_pre_buffer("#weak_define __WCHAR_MAX__ " STRINGIFY(__WCHAR_MAX__) "\n");
>  }
>  
>  static struct symbol_list *sparse_tokenstream(struct token *token)
> diff --git a/lib.h b/lib.h
> index b22fa93..62f7433 100644
> --- a/lib.h
> +++ b/lib.h
> @@ -17,6 +17,9 @@
>  #include "compat.h"
>  #include "ptrlist.h"
>  
> +#define __STRINGIFY(x) #x
> +#define STRINGIFY(x) __STRINGIFY(x)
> +

This looks fine, with one minor nit: s/__STRINGIFY/STRINGIFY2/g or
similar.  The C language reserves identifiers containing "__" (C99
"7.1.3 Reserved identifiers").

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () cs ! helsinki ! fi>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sun, 16 Aug 2009 11:05:33 +0000
Message-ID: <1250420733.9535.1.camel () penberg-laptop>
--------------------
Hi Josh,

On Sun, 2009-08-16 at 03:51 -0700, Josh Triplett wrote:
> On Sun, Aug 16, 2009 at 10:03:53AM +0300, Pekka Enberg wrote:
> > On Sat, 2009-08-15 at 15:36 -0700, Josh Triplett wrote:
> > > These defines need to have the right type suffixes.  GCC defines
> > > __LONG_LONG_MAX__ with an LL suffix, and __LONG_MAX__ with an L suffix.
> > > You could either add the appropriate suffixes, or better yet, stringize
> > > the constants and print them as strings.
> > 
> > Right. Is there a macro in sparse to do the stringification? I didn't
> > find one and the best I could come up is this.
> [...]
> > --- a/lib.c
> > +++ b/lib.c
> > @@ -788,6 +788,14 @@ void create_builtin_stream(void)
> >  		add_pre_buffer("#define __OPTIMIZE__ 1\n");
> >  	if (optimize_size)
> >  		add_pre_buffer("#define __OPTIMIZE_SIZE__ 1\n");
> > +
> > +	/* GCC defines these for limits.h */
> > +	add_pre_buffer("#weak_define __SHRT_MAX__ " STRINGIFY(__SHRT_MAX__) "\n");
> > +	add_pre_buffer("#weak_define __SCHAR_MAX__ " STRINGIFY(__SCHAR_MAX__) "\n");
> > +	add_pre_buffer("#weak_define __INT_MAX__ " STRINGIFY(__INT_MAX__) "\n");
> > +	add_pre_buffer("#weak_define __LONG_MAX__ " STRINGIFY(__LONG_MAX__) "\n");
> > +	add_pre_buffer("#weak_define __LONG_LONG_MAX__ " STRINGIFY(__LONG_LONG_MAX__) "\n");
> > +	add_pre_buffer("#weak_define __WCHAR_MAX__ " STRINGIFY(__WCHAR_MAX__) "\n");
> >  }
> >  
> >  static struct symbol_list *sparse_tokenstream(struct token *token)
> > diff --git a/lib.h b/lib.h
> > index b22fa93..62f7433 100644
> > --- a/lib.h
> > +++ b/lib.h
> > @@ -17,6 +17,9 @@
> >  #include "compat.h"
> >  #include "ptrlist.h"
> >  
> > +#define __STRINGIFY(x) #x
> > +#define STRINGIFY(x) __STRINGIFY(x)
> > +
> 
> This looks fine, with one minor nit: s/__STRINGIFY/STRINGIFY2/g or
> similar.  The C language reserves identifiers containing "__" (C99
> "7.1.3 Reserved identifiers").

Of course. Here's the final patch. *fingers crossed*

			Pekka

>From 8894fa768ddc69f4c7d2160c67e080731aefb88e Mon Sep 17 00:00:00 2001
From: Pekka Enberg <penberg@cs.helsinki.fi>
Date: Sat, 15 Aug 2009 23:22:24 +0300
Subject: [PATCH] Define GCC builtin defines for limits.h

Sparse produces a bunch of warnings like this when compiling against
glibc:

  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:33:22: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:5: warning: undefined preprocessor identifier '__SHRT_MAX__'
  /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:21: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/include/bits/xopen_lim.h:95:6: warning: undefined preprocessor identifier '__INT_MAX__'
  /usr/include/bits/xopen_lim.h:98:7: warning: undefined preprocessor identifier '__INT_MAX__'

Fix that up by adding some add_pre_buffer() calls to
create_builtin_define(). For future reference, GCC defines the builtins
in the c_cpp_builtins() function in gcc/c-cppbuiltin.c.

Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
---
 lib.c |    8 ++++++++
 lib.h |    3 +++
 2 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index 42affcd..fb7e9bc 100644
--- a/lib.c
+++ b/lib.c
@@ -788,6 +788,14 @@ void create_builtin_stream(void)
 		add_pre_buffer("#define __OPTIMIZE__ 1\n");
 	if (optimize_size)
 		add_pre_buffer("#define __OPTIMIZE_SIZE__ 1\n");
+
+	/* GCC defines these for limits.h */
+	add_pre_buffer("#weak_define __SHRT_MAX__ " STRINGIFY(__SHRT_MAX__) "\n");
+	add_pre_buffer("#weak_define __SCHAR_MAX__ " STRINGIFY(__SCHAR_MAX__) "\n");
+	add_pre_buffer("#weak_define __INT_MAX__ " STRINGIFY(__INT_MAX__) "\n");
+	add_pre_buffer("#weak_define __LONG_MAX__ " STRINGIFY(__LONG_MAX__) "\n");
+	add_pre_buffer("#weak_define __LONG_LONG_MAX__ " STRINGIFY(__LONG_LONG_MAX__) "\n");
+	add_pre_buffer("#weak_define __WCHAR_MAX__ " STRINGIFY(__WCHAR_MAX__) "\n");
 }
 
 static struct symbol_list *sparse_tokenstream(struct token *token)
diff --git a/lib.h b/lib.h
index b22fa93..25abb80 100644
--- a/lib.h
+++ b/lib.h
@@ -17,6 +17,9 @@
 #include "compat.h"
 #include "ptrlist.h"
 
+#define DO_STRINGIFY(x) #x
+#define STRINGIFY(x) DO_STRINGIFY(x)
+
 extern int verbose, optimize, optimize_size, preprocessing;
 extern int die_if_error;
 extern int repeat_phase, merge_phi_sources;
-- 
1.5.6.3



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sun, 16 Aug 2009 12:41:57 +0000
Message-ID: <20090816124157.GA6936 () feather>
--------------------
On Sun, Aug 16, 2009 at 02:05:33PM +0300, Pekka Enberg wrote:
> Of course. Here's the final patch. *fingers crossed*

Looks good to me.

Acked-by: Josh Triplett <josh@joshtriplett.org>

> From: Pekka Enberg <penberg@cs.helsinki.fi>
> Date: Sat, 15 Aug 2009 23:22:24 +0300
> Subject: [PATCH] Define GCC builtin defines for limits.h
> 
> Sparse produces a bunch of warnings like this when compiling against
> glibc:
> 
>   /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:33:22: warning: undefined preprocessor identifier '__INT_MAX__'
>   /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:5: warning: undefined preprocessor identifier '__SHRT_MAX__'
>   /usr/lib/gcc/i486-linux-gnu/4.3.2//include-fixed/limits.h:64:21: warning: undefined preprocessor identifier '__INT_MAX__'
>   /usr/include/bits/xopen_lim.h:95:6: warning: undefined preprocessor identifier '__INT_MAX__'
>   /usr/include/bits/xopen_lim.h:98:7: warning: undefined preprocessor identifier '__INT_MAX__'
> 
> Fix that up by adding some add_pre_buffer() calls to
> create_builtin_define(). For future reference, GCC defines the builtins
> in the c_cpp_builtins() function in gcc/c-cppbuiltin.c.
> 
> Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
> ---
>  lib.c |    8 ++++++++
>  lib.h |    3 +++
>  2 files changed, 11 insertions(+), 0 deletions(-)
> 
> diff --git a/lib.c b/lib.c
> index 42affcd..fb7e9bc 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -788,6 +788,14 @@ void create_builtin_stream(void)
>  		add_pre_buffer("#define __OPTIMIZE__ 1\n");
>  	if (optimize_size)
>  		add_pre_buffer("#define __OPTIMIZE_SIZE__ 1\n");
> +
> +	/* GCC defines these for limits.h */
> +	add_pre_buffer("#weak_define __SHRT_MAX__ " STRINGIFY(__SHRT_MAX__) "\n");
> +	add_pre_buffer("#weak_define __SCHAR_MAX__ " STRINGIFY(__SCHAR_MAX__) "\n");
> +	add_pre_buffer("#weak_define __INT_MAX__ " STRINGIFY(__INT_MAX__) "\n");
> +	add_pre_buffer("#weak_define __LONG_MAX__ " STRINGIFY(__LONG_MAX__) "\n");
> +	add_pre_buffer("#weak_define __LONG_LONG_MAX__ " STRINGIFY(__LONG_LONG_MAX__) "\n");
> +	add_pre_buffer("#weak_define __WCHAR_MAX__ " STRINGIFY(__WCHAR_MAX__) "\n");
>  }
>  
>  static struct symbol_list *sparse_tokenstream(struct token *token)
> diff --git a/lib.h b/lib.h
> index b22fa93..25abb80 100644
> --- a/lib.h
> +++ b/lib.h
> @@ -17,6 +17,9 @@
>  #include "compat.h"
>  #include "ptrlist.h"
>  
> +#define DO_STRINGIFY(x) #x
> +#define STRINGIFY(x) DO_STRINGIFY(x)
> +
>  extern int verbose, optimize, optimize_size, preprocessing;
>  extern int die_if_error;
>  extern int repeat_phase, merge_phi_sources;
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sun, 16 Aug 2009 17:50:46 +0000
Message-ID: <70318cbf0908161050w4b95c04cme5f30157cba684df () mail ! gmail ! com>
--------------------
On Sun, Aug 16, 2009 at 5:41 AM, Josh Triplett<josh@joshtriplett.org> wrote:
> On Sun, Aug 16, 2009 at 02:05:33PM +0300, Pekka Enberg wrote:
>> Of course. Here's the final patch. *fingers crossed*
>
> Looks good to me.
>
> Acked-by: Josh Triplett <josh@joshtriplett.org>
>

Looks good to me too. I will apply.

The linux kernel has a STRING macro. I will rename to match
that if nobody objects.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add GCC pre-defined macros for user-space
Date: Sun, 16 Aug 2009 19:34:31 +0000
Message-ID: <1250451271.11216.0.camel () johannes ! local>
--------------------

--=-6OthxtDxKp7yllpjhwud
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable

On Sun, 2009-08-16 at 11:56 -0700, Josh Triplett wrote:

> > The linux kernel has a STRING macro. I will rename to match
> > that if nobody objects.
>=20
> Matching Linux seems sensible, but I don't see that macro in any general
> code, just a bunch of local defines with various names.  A few quick
> greps on current git master turned up at least:

> So, I don't see any particular consistency here that we can follow, other=
 than
> that the macro should probably have "str" in it somewhere. :)  And if we =
have
> to choose, I think STRINGIFY seems more descriptive than just STRING.

There's include/linux/stringify.h that all those instances you found
could use.

johannes

--=-6OthxtDxKp7yllpjhwud
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: This is a digitally signed message part

-----BEGIN PGP SIGNATURE-----

iQIcBAABAgAGBQJKiF9EAAoJEODzc/N7+QmaVYwP/2SdBcHwTJDT9oPyMkYnZnOZ
CTHrWryCZFCJafSRMO3CYyVTUoFdFLzsGUSILieGUoqy6E5qiTM4ItEJt/UvprrT
ABS5S9DooPSIlNAW6sh+rTC6n3wt52uASZB0sqoBM7pqkePKNGA+NbUbqLW47uLa
3UrjDj+6jW/Yb6MZDFYNqXlQ2iFp8PRgOROvB/uqdFwsY5Bx/qoWOgLdWEO0DPX+
qTZ+BSQKL+jpXyWvK3Tax5U2wRJ9Wqpx2i3RHdndjprS0tUBQnEhHDw81zZD4clo
Cej+VEk+kxu9peI+BR7/kKKiZPHF361Z9xDkCDTSw9uUoUj+DOQpgYHM3TiD40Jm
JitncWqi27YUmXI9a8q7a0ayx2vsDXZJapPwm/8ertDkhhyCvyvzOte9w4cNsIpT
fq2JIl0jY+Dkrdg0uSZmf6WWOZxIELY+IFZoWy7gxoBB96ZybcBhkiviGX7xaSxT
q41TsX+iL+7CVeO9VW+zvH/pIHkrewYneg8aHLxJal305WnvTEYzWNj9u5snfD96
K/sePK9BEttzvIgM0f7vKImro4/aaDonoMcuIr+g2bTO6DSZeuHc8nqG/wUkphpP
vn6JCylVQu+e62may++kgEWYaPJOqiWyEptGSy946BLmK7JR36Eh8gqJtW/o8LKb
LGExIYnLpabNv3zLcU8A
=26ap
-----END PGP SIGNATURE-----

--=-6OthxtDxKp7yllpjhwud--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] test-suite: be more verbose on 'unhandled' and 'known to ===

From: Hannes Eder <hannes () hanneseder ! net>
To: linux-sparse
Subject: [PATCH] test-suite: be more verbose on 'unhandled' and 'known to
Date: Thu, 16 Jul 2009 21:51:49 +0000
Message-ID: <20090716215134.7792.46659.stgit () f10box ! hanneseder ! net>
--------------------
Impact:
  - On an 'unhandled' test issue a warning, and
  - in case of a 'known to fail' test a info message.

Signed-off-by: Hannes Eder <hannes@hanneseder.net>
---

grep-ed out from 'make check' output:

warning: test 'badtype1.c' unhandled
warning: test 'badtype2.c' unhandled
warning: test 'badtype3.c' unhandled
warning: test 'bitfields.c' unhandled
warning: test 'builtin_safe1.c' unhandled
warning: test 'choose_expr.c' unhandled
warning: test 'field-overlap.c' unhandled
warning: test 'foul-bitwise.c' unhandled
warning: test 'inline_compound_literals.c' unhandled
warning: test 'preprocessor/preprocessor11.c' unhandled
warning: test 'preprocessor/preprocessor12.c' unhandled
warning: test 'preprocessor/preprocessor13.c' unhandled
warning: test 'preprocessor/preprocessor14.c' unhandled
warning: test 'preprocessor/preprocessor15.c' unhandled
warning: test 'preprocessor/preprocessor16.c' unhandled
warning: test 'preprocessor/preprocessor7.c' unhandled
warning: test 'preprocessor/preprocessor8.c' unhandled
warning: test 'struct-ns2.c' unhandled
warning: test 'struct-size1.c' unhandled
warning: test 'test-be.c' unhandled
warning: test 'type1.c' unhandled

Out of 72 tests, 70 passed, 2 failed (2 of them are known to fail)
21 tests could not be handled by test-suite

I'd say we should integrate these tests into the test-suite, no?

Cheers,
Hannes

 validation/test-suite |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)

diff --git a/validation/test-suite b/validation/test-suite
index 1a35703..42f7bd7 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -89,6 +89,7 @@ do_test()
 	# (it has to have a check-name key in it)
 	get_value "check-name" $file
 	if [ "$?" -eq 1 ]; then
+		echo "warning: test '$file' unhandled"
 		unhandled_tests=`expr $unhandled_tests + 1`
 		return 2
 	fi
@@ -142,7 +143,10 @@ do_test()
 	if [ "$test_failed" -eq "1" ]; then
 		ko_tests=`expr $ko_tests + 1`
 		get_tag "check-known-to-fail" $file
-		[ "$?" -eq "0" ] && known_ko_tests=`expr $known_ko_tests + 1`
+		if [ "$?" -eq "0" ]; then
+			echo "info: test '$file' is known to fail"
+			known_ko_tests=`expr $known_ko_tests + 1`
+		fi
 		return 1
 	else
 		ok_tests=`expr $ok_tests + 1`

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] test-suite: be more verbose on 'unhandled' and 'known to
Date: Fri, 17 Jul 2009 09:01:02 +0000
Message-ID: <70318cbf0907170201u30cc9b7dk7db8e84c8b6b994d () mail ! gmail ! com>
--------------------
On Thu, Jul 16, 2009 at 2:51 PM, Hannes Eder<hannes@hanneseder.net> wrote:
> Impact:
>  - On an 'unhandled' test issue a warning, and
>  - in case of a 'known to fail' test a info message.

Looks good. I will apply.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] test-suite: integrate unhandled proprocessor tests ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] test-suite: integrate unhandled proprocessor tests
Date: Mon, 27 Jul 2009 21:04:00 +0000
Message-ID: <70318cbf0907271404i34dac921ge2b3f4d4dcc7c596 () mail ! gmail ! com>
--------------------
On Mon, Jul 27, 2009 at 11:13 AM, Hannes Eder<hannes@hanneseder.net> wrote:
> Instrument validate/preprocessor/preproprocessor*.c to be integrated
> into the test-suite where missing and add an additional test case.

Thanks, applied.

> Ok there is a difference in the number of empty lines, who cares, but
> spares outputs a "," and cpp does not.
>
> Could somebody with more insight comment on this?  Al? :)
>
> Meanwhile I marked this test as "check-known-to-fail".

Currently sparse did not handle ##__VA_ARGS__ the same ways
as gcc. Take a look at parse_expansion(). It marks TOKEN_GNU_KLUDGE
only if it saw "," right before "##__VA_ARGS__".  So ",##x##__VA_ARGS__"
will not get generate TOKEN_GNU_KLUDE.

The fix is that ##__VA_ARGS__ should kick in *after* the argument
list has been expanded. It literally delete the previous "," if __VA_ARGS__ is
empty.

Am I missing any thing, AI?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] test-suite: new preprocessor test case ===

From: Hannes Eder <hannes () hanneseder ! net>
To: linux-sparse
Subject: [PATCH] test-suite: new preprocessor test case
Date: Thu, 19 Mar 2009 17:56:11 +0000
Message-ID: <20090319175544.13691.42362.stgit () f10box ! hanneseder ! net>
--------------------
Sparse currently fails on this test.

Signed-off-by: Hannes Eder <hannes@hanneseder.net>
---

I discovered this while hunting down the sparse segfault when checking kernel/cred.c.

When preprocessing the file with gcc, gcc remains silent, but sparse
complains:

include/linux/skbuff.h:381:9: error: expected preprocessor identifier
include/linux/skbuff.h:381:9: error: expected preprocessor identifier
include/linux/skbuff.h:381:9: error: garbage at end: )
include/linux/skbuff.h:381:9: error: expected preprocessor identifier
include/linux/skbuff.h:381:9: error: expected preprocessor identifier
include/linux/skbuff.h:381:9: error: garbage at end: )

this is covered by the test case in a more abstract form.  Sparse
further complains about this, which is not yet covered in a test case:

kernel/cred.c:281:9: error: unmatched #endif in stream
kernel/cred.c:281:9: error: unmatched #endif in stream
kernel/cred.c:281:9: error: unmatched #endif in stream

 validation/preprocessor/preprocessor22.c |   21 +++++++++++++++++++++
 1 files changed, 21 insertions(+), 0 deletions(-)
 create mode 100644 validation/preprocessor/preprocessor22.c

diff --git a/validation/preprocessor/preprocessor22.c b/validation/preprocessor/preprocessor22.c
new file mode 100644
index 0000000..838479f
--- /dev/null
+++ b/validation/preprocessor/preprocessor22.c
@@ -0,0 +1,21 @@
+#define CONFIG_FOO 1
+
+#define define_struct(name, fields...) struct fields name;
+
+define_struct(a, {
+#ifdef CONFIG_FOO
+  int b;
+#endif
+});
+/*
+ * check-name: Preprocessor #22
+ * check-description: Sparse gets this wrong, should be fixed
+ * check-command: sparse -E $file
+ * check-known-to-fail
+ *
+ * check-output-start
+
+struct {
+int b; } a;;
+ * check-output-end
+ */

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] test-suite: new preprocessor test case
Date: Thu, 19 Mar 2009 18:26:28 +0000
Message-ID: <20090319182628.GB28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Mar 19, 2009 at 06:56:11PM +0100, Hannes Eder wrote:
> Sparse currently fails on this test.

It doesn't.  6.10.3p11: "If there are sequences of preprocessing tokens
within the list of arguments that would otherwise act as preprocessing
directives, the behavior is undefined."

You are asking for identical nasal demons from two implementations, when
it's not even promised that the same kind will fly on two invocations of
the same implementation...

Seriously, this is undefined behaviour *and* it's extermely hard to come
up with self-consistent semantics for it.  Standard doesn't even try and
implementations are doing whatever's more convenient at the moment.  Try
to think of it and you'll come up with really ugly corner cases very fast.

What we probably ought to do is a warning when such stuff happens.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: [PATCH] test-suite: new preprocessor test case
Date: Thu, 19 Mar 2009 19:24:06 +0000
Message-ID: <49C29BD6.7050005 () knosof ! co ! uk>
--------------------
Al,

> It doesn't.  6.10.3p11: "If there are sequences of preprocessing tokens
> within the list of arguments that would otherwise act as preprocessing
> directives, the behavior is undefined."
> 
> You are asking for identical nasal demons from two implementations, when
> it's not even promised that the same kind will fly on two invocations of
> the same implementation...

So what you are saying is that this is a bug in the header.
This is the approach I would favor.

> Seriously, this is undefined behaviour *and* it's extermely hard to come
> up with self-consistent semantics for it.  Standard doesn't even try and
> implementations are doing whatever's more convenient at the moment.  Try
> to think of it and you'll come up with really ugly corner cases very fast.

Unless gcc comes up with consistent behavior every time I would not
expect this usage to hang around very long in the header.

> What we probably ought to do is a warning when such stuff happens.

You mean a more easy to understand message.

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] unssa: track uses when replacing a phi node ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] unssa: track uses when replacing a phi node
Date: Tue, 11 Aug 2009 09:16:02 +0000
Message-ID: <70318cbf0908110216w363b7e2cnccc59075a21d1888 () mail ! gmail ! com>
--------------------
On Sun, Aug 9, 2009 at 1:30 AM, Kamil Dudka<kdudka@redhat.com> wrote:
> Hello,
>
> attached are patch, testing input for test-unssa and its outputs before patch
> and after patch. Thanks in advance for considering the patch!
>
> Kamil
>

Looks good to me. Thanks for the patch.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCHv2] New attribute designated_init: mark a struct as ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: [PATCHv2] New attribute designated_init: mark a struct as
Date: Sun, 11 Oct 2009 18:54:30 +0000
Message-ID: <20091011185425.GA8688 () feather>
--------------------
Some structure types provide a set of fields of which most users will
only initialize the subset they care about.  Users of these types should
always use designated initializers, to avoid relying on the specific
structure layout.  Examples of this type of structure include the many
*_operations structures in Linux, which contain a set of function
pointers; these structures occasionally gain a new field, lose an
obsolete field, or change the function signature for a field.

Add a new attribute designated_init; when used on a struct, it tells
Sparse to warn on any positional initialization of a field in that
struct.

The new flag -Wdesignated-init controls these warnings.  Since these
warnings only fire for structures explicitly tagged with the attribute,
enable the warning by default.

Includes documentation and test case.

Signed-off-by: Josh Triplett <josh@joshtriplett.org>
---

v2: Fixed printing of ->ident to not rely on terminating NUL, as noticed
by Chris Li.

 evaluate.c                   |   10 ++
 lib.c                        |    2 +
 lib.h                        |    1 +
 parse.c                      |   15 +++
 sparse.1                     |   24 +++++
 symbol.h                     |    3 +-
 validation/designated-init.c |  195 ++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 249 insertions(+), 1 deletions(-)
 create mode 100644 validation/designated-init.c

diff --git a/evaluate.c b/evaluate.c
index 805ae90..28bfd7c 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2366,6 +2366,7 @@ static void handle_list_initializer(struct expression *expr,
 		int lclass;
 
 		if (e->type != EXPR_INDEX && e->type != EXPR_IDENTIFIER) {
+			struct symbol *struct_sym;
 			if (!top) {
 				top = e;
 				last = first_subobject(ctype, class, &top);
@@ -2378,6 +2379,15 @@ static void handle_list_initializer(struct expression *expr,
 				DELETE_CURRENT_PTR(e);
 				continue;
 			}
+			struct_sym = ctype->type == SYM_NODE ? ctype->ctype.base_type : ctype;
+			if (Wdesignated_init && struct_sym->designated_init)
+				warning(e->pos, "%s%.*s%spositional init of field in %s %s, declared with attribute designated_init",
+					ctype->ident ? "in initializer for " : "",
+					ctype->ident ? ctype->ident->len : 0,
+					ctype->ident ? ctype->ident->name : "",
+					ctype->ident ? ": " : "",
+					get_type_name(struct_sym->type),
+					show_ident(struct_sym->ident));
 			if (jumped) {
 				warning(e->pos, "advancing past deep designator");
 				jumped = 0;
diff --git a/lib.c b/lib.c
index 622b547..77a1c33 100644
--- a/lib.c
+++ b/lib.c
@@ -197,6 +197,7 @@ int Wcast_truncate = 1;
 int Wcontext = 1;
 int Wdecl = 1;
 int Wdefault_bitfield_sign = 0;
+int Wdesignated_init = 1;
 int Wdo_while = 0;
 int Wenum_mismatch = 1;
 int Wnon_pointer_null = 1;
@@ -378,6 +379,7 @@ static const struct warning {
 	{ "context", &Wcontext },
 	{ "decl", &Wdecl },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
+	{ "designated-init", &Wdesignated_init },
 	{ "do-while", &Wdo_while },
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "non-pointer-null", &Wnon_pointer_null },
diff --git a/lib.h b/lib.h
index 25abb80..3ced1bf 100644
--- a/lib.h
+++ b/lib.h
@@ -97,6 +97,7 @@ extern int Wcast_truncate;
 extern int Wcontext;
 extern int Wdecl;
 extern int Wdefault_bitfield_sign;
+extern int Wdesignated_init;
 extern int Wdo_while;
 extern int Wenum_mismatch;
 extern int Wnon_pointer_null;
diff --git a/parse.c b/parse.c
index 5e75242..03fa5d9 100644
--- a/parse.c
+++ b/parse.c
@@ -64,6 +64,7 @@ typedef struct token *attr_t(struct token *, struct symbol *,
 static attr_t
 	attribute_packed, attribute_aligned, attribute_modifier,
 	attribute_address_space, attribute_context,
+	attribute_designated_init,
 	attribute_transparent_union, ignore_attribute,
 	attribute_mode, attribute_force;
 
@@ -319,6 +320,10 @@ static struct symbol_op context_op = {
 	.attribute = attribute_context,
 };
 
+static struct symbol_op designated_init_op = {
+	.attribute = attribute_designated_init,
+};
+
 static struct symbol_op transparent_union_op = {
 	.attribute = attribute_transparent_union,
 };
@@ -453,6 +458,7 @@ static struct init_keyword {
 	{ "address_space",NS_KEYWORD,	.op = &address_space_op },
 	{ "mode",	NS_KEYWORD,	.op = &mode_op },
 	{ "context",	NS_KEYWORD,	.op = &context_op },
+	{ "designated_init",	NS_KEYWORD,	.op = &designated_init_op },
 	{ "__transparent_union__",	NS_KEYWORD,	.op = &transparent_union_op },
 
 	{ "__mode__",	NS_KEYWORD,	.op = &mode_op },
@@ -1127,6 +1133,15 @@ static struct token *attribute_context(struct token *token, struct symbol *attr,
 	return token;
 }
 
+static struct token *attribute_designated_init(struct token *token, struct symbol *attr, struct decl_state *ctx)
+{
+	if (ctx->ctype.base_type && ctx->ctype.base_type->type == SYM_STRUCT)
+		ctx->ctype.base_type->designated_init = 1;
+	else
+		warning(token->pos, "attribute designated_init applied to non-structure type");
+	return token;
+}
+
 static struct token *attribute_transparent_union(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	if (Wtransparent_union)
diff --git a/sparse.1 b/sparse.1
index d7fe444..1054712 100644
--- a/sparse.1
+++ b/sparse.1
@@ -134,6 +134,30 @@ explicitly.
 Sparse does not issue these warnings by default.
 .
 .TP
+.B \-Wdesignated\-init
+Warn about positional initialization of structs marked as requiring designated
+initializers.
+
+Sparse allows an attribute
+.BI __attribute__((designated_init))
+which marks a struct as requiring designated initializers.  Sparse will warn
+about positional initialization of a struct variable or struct literal of a
+type that has this attribute.
+
+Requiring designated initializers for a particular struct type will insulate
+code using that struct type from changes to the layout of the type, avoiding
+the need to change initializers for that type unless they initialize a removed
+or incompatibly changed field.
+
+Common examples of this type of struct include collections of function pointers
+for the implementations of a class of related operations, for which the default
+NULL for an unmentioned field in a designated initializer will correctly
+indicate the absence of that operation.
+
+Sparse issues these warnings by default.  To turn them off, use
+\fB\-Wno\-designated\-init\fR.
+.
+.TP
 .B \-Wdo\-while
 Warn about do-while loops that do not delimit the loop body with braces.
 
diff --git a/symbol.h b/symbol.h
index 60fdad0..83b3d4b 100644
--- a/symbol.h
+++ b/symbol.h
@@ -156,7 +156,8 @@ struct symbol {
 					examined:1,
 					expanding:1,
 					evaluated:1,
-					string:1;
+					string:1,
+					designated_init:1;
 			struct expression *array_size;
 			struct ctype ctype;
 			struct symbol_list *arguments;
diff --git a/validation/designated-init.c b/validation/designated-init.c
new file mode 100644
index 0000000..23423e9
--- /dev/null
+++ b/validation/designated-init.c
@@ -0,0 +1,195 @@
+struct s1 {
+	int x;
+	int y;
+};
+
+struct s2 {
+	int x;
+	int y;
+} __attribute__((designated_init));
+
+struct nest1 {
+	struct s1 s1;
+	struct s2 s2;
+};
+
+struct nest2 {
+	struct s1 s1;
+	struct s2 s2;
+} __attribute__((designated_init));
+
+static struct s1 s1_positional = { 5, 10 };
+static struct s1 s1_designated = { .x = 5, .y = 10 };
+static struct s2 s2_positional = { 5, 10 };
+static struct s2 s2_designated = { .x = 5, .y = 10 };
+static struct nest1 nest1_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest1 nest1_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest1 nest1_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest1 nest1_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+static struct nest2 nest2_positional = {
+	{ 5, 10 },
+	{ 5, 10 },
+};
+static struct nest2 nest2_designated_outer = {
+	.s1 = { 5, 10 },
+	.s2 = { 5, 10 },
+};
+static struct nest2 nest2_designated_inner = {
+	{ .x = 5, .y = 10 },
+	{ .x = 5, .y = 10 },
+};
+static struct nest2 nest2_designated_both = {
+	.s1 = { .x = 5, .y = 10 },
+	.s2 = { .x = 5, .y = 10 },
+};
+
+static struct {
+	int x;
+	int y;
+} __attribute__((designated_init))
+	anon_positional = { 5, 10 },
+	anon_designated = { .x = 5, .y = 10};
+
+static struct s1 s1_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s2 s2_array[] = {
+	{ 5, 10 },
+	{ .x = 5, .y = 10 },
+};
+
+static struct s1 ret_s1_positional(void)
+{
+	return ((struct s1){ 5, 10 });
+}
+
+static struct s1 ret_s1_designated(void)
+{
+	return ((struct s1){ .x = 5, .y = 10 });
+}
+
+static struct s2 ret_s2_positional(void)
+{
+	return ((struct s2){ 5, 10 });
+}
+
+static struct s2 ret_s2_designated(void)
+{
+	return ((struct s2){ .x = 5, .y = 10 });
+}
+
+static struct nest1 ret_nest1_positional(void)
+{
+	return ((struct nest1){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_outer(void)
+{
+	return ((struct nest1){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_inner(void)
+{
+	return ((struct nest1){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest1 ret_nest1_designated_both(void)
+{
+	return ((struct nest1){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_positional(void)
+{
+	return ((struct nest2){
+			{ 5, 10 },
+			{ 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_outer(void)
+{
+	return ((struct nest2){
+			.s1 = { 5, 10 },
+			.s2 = { 5, 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_inner(void)
+{
+	return ((struct nest2){
+			{ .x = 5, .y = 10 },
+			{ .x = 5, .y = 10 },
+		});
+}
+
+static struct nest2 ret_nest2_designated_both(void)
+{
+	return ((struct nest2){
+			.s1 = { .x = 5, .y = 10 },
+			.s2 = { .x = 5, .y = 10 },
+		});
+}
+/*
+ * check-name: designated_init attribute
+ *
+ * check-error-start
+designated-init.c:23:36: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:23:39: warning: in initializer for s2_positional: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:27:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:31:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:42:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:9: warning: in initializer for nest2_positional: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:43:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:43:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:17: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:47:20: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:50:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:51:9: warning: in initializer for nest2_designated_inner: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:62:29: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:62:32: warning: in initializer for anon_positional: positional init of field in struct <noident>, declared with attribute designated_init
+designated-init.c:71:11: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:71:14: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:30: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:87:33: warning: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:99:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:107:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:130:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:131:27: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:131:30: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:33: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:139:36: warning: in initializer for s2: positional init of field in struct s2, declared with attribute designated_init
+designated-init.c:146:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+designated-init.c:147:25: warning: positional init of field in struct nest2, declared with attribute designated_init
+ * check-error-end
+ */
-- 
1.6.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCHv2] Rename -Wall to Wsparse-all, so it doesn't get ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCHv2] Rename -Wall to Wsparse-all, so it doesn't get
Date: Mon, 12 Oct 2009 06:25:00 +0000
Message-ID: <20091012062457.GA6370 () feather>
--------------------
On Sun, Oct 11, 2009 at 10:46:25PM -0700, Christopher Li wrote:
> On Sun, Oct 11, 2009 at 3:47 PM, Josh Triplett <josh@joshtriplett.org> wrote:
> > v2: Update cgcc and remove unnecessary (and now ignored) -Wall from a
> > test case.
> 
> Applied. BTW, what do you think about moving the logic from cgcc into
> sparse directly?

Definitely a good idea.

The logic in cgcc seems to fall in two main categories:
architecture-specific code and code to launch the C compiler.  The
former should definitely live in sparse itself, because otherwise sparse
doesn't have all the proper built-in definitions when launched directly;
I'd like to *avoid* the GCC approach of only supporting one architecture
(or architecture family) at a time, though, and instead let the caller
specify any architecture sparse supports.  As for launching the
compiler, it would prove fairly straightforward for sparse to strip any
sparse-specific warning options from its command line and then launch
$CC; in fact, if sparse did so right before exiting, it could just call
exec and avoid the need to fork.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCHv2] Rename -Wall to Wsparse-all, so it doesn't get turned ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCHv2] Rename -Wall to Wsparse-all, so it doesn't get turned
Date: Mon, 12 Oct 2009 05:46:25 +0000
Message-ID: <70318cbf0910112246w3cdb386fjc12f0be4ff135220 () mail ! gmail ! com>
--------------------
On Sun, Oct 11, 2009 at 3:47 PM, Josh Triplett <josh@joshtriplett.org> wrote:
> v2: Update cgcc and remove unnecessary (and now ignored) -Wall from a
> test case.

Applied. BTW, what do you think about moving the logic from cgcc into
sparse directly?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCHv2] Rename -Wall to Wsparse-all, so it doesn't get turned on ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: [PATCHv2] Rename -Wall to Wsparse-all, so it doesn't get turned on
Date: Sun, 11 Oct 2009 22:47:03 +0000
Message-ID: <20091011224618.GA3963 () feather>
--------------------
sparse's -Wall option turns on all sparse warnings, including those that
many projects will not want; for instance, warnings that enforce
particular stylistic choices, or behavior allowed by a standard but
considered questionable or error-prone.  Furthermore, using -Wall means
accepting all future warnings sparse may start issuing, not just those
intentionally turned on by default.

Other compilers like GCC also use -Wall, and interpret it to mean "turn
on a sensible set of warnings".  Since sparse exists to emit warnings,
it already defaults to emitting a sensible set of warnings.  Many
projects pass the same options to both sparse and the C compiler,
including warning options like -Wall; this results in turning on
excessive amounts of sparse warnings.

cgcc already filtered out -Wall, but many projects invoke sparse
directly rather than using cgcc.  Remove that filter, now that -Wall
does not change sparse's behavior.

Projects almost certainly don't want to use the new -Wsparse-all option;
they should choose the specific set of warnings they want, or just go
with sparse's defaults.

Also update cgcc to know about Wsparse-all and not pass it to GCC, and
update a test case that unnecessarily used -Wall.

Signed-off-by: Josh Triplett <josh@joshtriplett.org>
---

v2: Update cgcc and remove unnecessary (and now ignored) -Wall from a
test case.

My -Wdesignated-init patch also needs to include an update for cgcc, and
thus it will conflict with this one.  I'll rebase the Wdesignated-init
patch on this one, to avoid the conflict.  In the future, perhaps sparse
could have some kind of --print-warning-options option, and the Makefile
could generate cgcc from cgcc.in and that, avoiding the need to update
cgcc when adding a new Sparse option.

 cgcc                     |   17 ++---------------
 lib.c                    |    2 +-
 sparse.1                 |    4 ++++
 validation/specifiers1.c |    2 +-
 4 files changed, 8 insertions(+), 17 deletions(-)

diff --git a/cgcc b/cgcc
index 995cc05..8005c3c 100755
--- a/cgcc
+++ b/cgcc
@@ -51,7 +51,7 @@ while (@ARGV) {
 
     my $this_arg = ' ' . &quote_arg ($_);
     $cc .= $this_arg unless &check_only_option ($_);
-    $check .= $this_arg unless &cc_only_option ($_);
+    $check .= $this_arg;
 }
 
 if ($gendeps) {
@@ -88,25 +88,12 @@ exit 0;
 
 sub check_only_option {
     my ($arg) = @_;
-    return 1 if $arg =~ /^-W(no-?)?(default-bitfield-sign|one-bit-signed-bitfield|cast-truncate|bitwise|typesign|context|undef|ptr-subtraction-blows|cast-to-as|decl|transparent-union|address-space|enum-mismatch|do-while|old-initializer|non-pointer-null|paren-string|return-void)$/;
+    return 1 if $arg =~ /^-W(no-?)?(default-bitfield-sign|one-bit-signed-bitfield|cast-truncate|bitwise|typesign|context|undef|ptr-subtraction-blows|cast-to-as|decl|transparent-union|address-space|enum-mismatch|do-while|old-initializer|non-pointer-null|paren-string|return-void|sparse-all)$/;
     return 1 if $arg =~ /^-v(no-?)?(entry|dead)$/;
     return 0;
 }
 
 # -----------------------------------------------------------------------------
-# Check if an option is for "cc" only.
-
-sub cc_only_option {
-    my ($arg) = @_;
-    # -Wall turns on all Sparse warnings, including experimental and noisy
-    # ones.  Don't include it just because a project wants to pass -Wall to cc.
-    # If you really want cgcc to run sparse with -Wall, use
-    # CHECK="sparse -Wall".
-    return 1 if $arg =~ /^-Wall$/;
-    return 0;
-}
-
-# -----------------------------------------------------------------------------
 # Simple arg-quoting function.  Just adds backslashes when needed.
 
 sub quote_arg {
diff --git a/lib.c b/lib.c
index 622b547..963be08 100644
--- a/lib.c
+++ b/lib.c
@@ -407,7 +407,7 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
 	char *p = arg + 1;
 	unsigned i;
 
-	if (!strcmp(p, "all")) {
+	if (!strcmp(p, "sparse-all")) {
 		for (i = 0; i < n; i++) {
 			if (*warnings[i].flag != WARNING_FORCE_OFF)
 				*warnings[i].flag = WARNING_ON;
diff --git a/sparse.1 b/sparse.1
index d7fe444..abc75a2 100644
--- a/sparse.1
+++ b/sparse.1
@@ -20,6 +20,10 @@ off those warnings, pass the negation of the associated warning option,
 .
 .SH WARNING OPTIONS
 .TP
+.B \-Wsparse\-all
+Turn on all sparse warnings, except for those explicitly disabled via
+\fB\-Wno\-something\fR.
+.TP
 .B \-Waddress\-space
 Warn about code which mixes pointers to different address spaces.
 
diff --git a/validation/specifiers1.c b/validation/specifiers1.c
index 86db45d..1a4e1d5 100644
--- a/validation/specifiers1.c
+++ b/validation/specifiers1.c
@@ -97,5 +97,5 @@ TEST2(double, long)
 }
 /*
  * check-name: valid specifier combinations
- * check-command: sparse -Wall $file
+ * check-command: sparse $file
  */
-- 
1.6.4.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [Patch] warning for preprocessor directive in macro Was: Segfault at ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [Patch] warning for preprocessor directive in macro Was: Segfault at
Date: Fri, 20 Mar 2009 07:18:11 +0000
Message-ID: <70318cbf0903200018k65330948g86fe8445e4ad86f6 () mail ! gmail ! com>
--------------------
--000e0cd21454250a7b046587b8c9
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

On Thu, Mar 19, 2009 at 4:11 PM, Christopher Li <sparse@chrisli.org> wrote:
> Thanks Al,
>
> I will apply it later tonight.
>
> If no one beats to me, I will try to add the warning for using preprocessor
> directive inside macro expansion. It should be a better error message
> than the current one.

OK, attached patch generate warning like this:

macro-argument-ifdef.c:10:1: warning: invalid usage of "#ifdef" in
macro argument

The wording of the error message can be improved. Any suggestion?

Chris

--000e0cd21454250a7b046587b8c9
Content-Type: application/octet-stream; name=warn-macro-argument-ifdef
Content-Disposition: attachment; filename=warn-macro-argument-ifdef
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fsi49n5g0

V2FybiBhYm91dCB1c2luZyAjaWZkZWYgaW4gbWFjcm8gYXJndW1lbnRzCgo2LjEwLjNwMTE6ICJJ
ZiB0aGVyZSBhcmUgc2VxdWVuY2VzIG9mIHByZXByb2Nlc3NpbmcgdG9rZW5zCndpdGhpbiB0aGUg
bGlzdCBvZiBhcmd1bWVudHMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYWN0IGFzIHByZXByb2Nlc3Np
bmcKZGlyZWN0aXZlcywgdGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZC4iCgpTaWduZWQtT2ZmLUJ5
OiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgoKSW5kZXg6IHNwYXJzZS5jaHJp
c2wvcHJlLXByb2Nlc3MuYwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09Ci0tLSBzcGFyc2UuY2hyaXNsLm9yaWcvcHJlLXBy
b2Nlc3MuYworKysgc3BhcnNlLmNocmlzbC9wcmUtcHJvY2Vzcy5jCkBAIC0xOTMsNiArMTkzLDE3
IEBAIHN0YXRpYyB2b2lkIGV4cGFuZF9saXN0KHN0cnVjdCB0b2tlbiAqKmwKIAl9CiB9CiAKK3N0
YXRpYyBpbmxpbmUgdm9pZCB3YXJuX3ByZXByb2Nlc3Nvcl9kaXJlY3RpdmUoc3RydWN0IHRva2Vu
ICp0b2tlbikKK3sKKwlzdHJ1Y3QgdG9rZW4gKmNtZCA9IHRva2VuLT5uZXh0OworCWlmICh0b2tl
bl90eXBlKGNtZCkgIT0gVE9LRU5fSURFTlQpCisJCXJldHVybjsKKwlpZiAoIWxvb2t1cF9zeW1i
b2woY21kLT5pZGVudCwgTlNfUFJFUFJPQ0VTU09SKSkKKwkJcmV0dXJuOworCXdhcm5pbmcodG9r
ZW4tPnBvcywgImludmFsaWQgdXNhZ2Ugb2YgXCIjJXNcIiBpbiBtYWNybyBhcmd1bWVudCIsCisJ
CXNob3dfaWRlbnQoY21kLT5pZGVudCkpOworfQorCiBzdGF0aWMgc3RydWN0IHRva2VuICpjb2xs
ZWN0X2FyZyhzdHJ1Y3QgdG9rZW4gKnByZXYsIGludCB2YXJhcmcsIHN0cnVjdCBwb3NpdGlvbiAq
cG9zKQogewogCXN0cnVjdCB0b2tlbiAqKnAgPSAmcHJldi0+bmV4dDsKQEAgLTIwNyw2ICsyMTgs
OCBAQCBzdGF0aWMgc3RydWN0IHRva2VuICpjb2xsZWN0X2FyZyhzdHJ1Y3QgCiAJCQkJYnJlYWs7
CiAJCX0gZWxzZSBpZiAobWF0Y2hfb3AobmV4dCwgJywnKSAmJiAhbmVzdGluZyAmJiAhdmFyYXJn
KSB7CiAJCQlicmVhazsKKwkJfSBlbHNlIGlmIChtYXRjaF9vcChuZXh0LCAnIycpICYmIG5leHQt
PnBvcy5uZXdsaW5lKSB7CisJCQl3YXJuX3ByZXByb2Nlc3Nvcl9kaXJlY3RpdmUobmV4dCk7CiAJ
CX0KIAkJbmV4dC0+cG9zLnN0cmVhbSA9IHBvcy0+c3RyZWFtOwogCQluZXh0LT5wb3MubGluZSA9
IHBvcy0+bGluZTsKSW5kZXg6IHNwYXJzZS5jaHJpc2wvdmFsaWRhdGlvbi9tYWNyby1hcmd1bWVu
dC1pZmRlZi5jCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT0KLS0tIHNwYXJzZS5jaHJpc2wub3JpZy92YWxpZGF0aW9uL21h
Y3JvLWFyZ3VtZW50LWlmZGVmLmMKKysrIHNwYXJzZS5jaHJpc2wvdmFsaWRhdGlvbi9tYWNyby1h
cmd1bWVudC1pZmRlZi5jCkBAIC0wLDAgKzEsMjggQEAKKyNkZWZpbmUgZm9vKGEsYixjKSBiYXIo
YSxiLGMpCisKK3N0YXRpYyB2b2lkIGJhcihpbnQgYSwgaW50IGIsIGludCBjKQoreworfQorCitz
dGF0aWMgdm9pZCB0ZXN0KHZvaWQpCit7CisJZm9vKDEsCisjaWZkZWYgTk9UCisJMiwKKyNlbHNl
CisJMywKKyNlbmRpZgorCTQpOworfQorCisvKgorICogY2hlY2stbmFtZTogaW52YWxpZCB1c2Fn
ZSBvZiBpZmRlZiBpbnNpZGUgbWFjcm8gYXJndW1lbnRzCisgKiBjaGVjay1lcnJvci1zdGFydAor
bWFjcm8tYXJndW1lbnQtaWZkZWYuYzoxMDoxOiB3YXJuaW5nOiBpbnZhbGlkIHVzYWdlIG9mICIj
aWZkZWYiIGluIG1hY3JvIGFyZ3VtZW50CittYWNyby1hcmd1bWVudC1pZmRlZi5jOjEyOjE6IHdh
cm5pbmc6IGludmFsaWQgdXNhZ2Ugb2YgIiNlbHNlIiBpbiBtYWNybyBhcmd1bWVudAorbWFjcm8t
YXJndW1lbnQtaWZkZWYuYzoxNDoxOiB3YXJuaW5nOiBpbnZhbGlkIHVzYWdlIG9mICIjZW5kaWYi
IGluIG1hY3JvIGFyZ3VtZW50CittYWNyby1hcmd1bWVudC1pZmRlZi5jOjk6OTogZXJyb3I6IG1h
Y3JvICJmb28iIHBhc3NlZCA0IGFyZ3VtZW50cywgYnV0IHRha2VzIGp1c3QgMworbWFjcm8tYXJn
dW1lbnQtaWZkZWYuYzo5Ojk6IGVycm9yOiB1bmRlZmluZWQgaWRlbnRpZmllciAnZm9vJworICog
Y2hlY2stZXJyb3ItZW5kCisgKi8KKwo=
--000e0cd21454250a7b046587b8c9--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] potential DR in handling of signed int and unholy mess ===

From: David Given <dg () cowlark ! com>
To: linux-sparse
Subject: Re: [RFC] potential DR in handling of signed int and unholy mess
Date: Thu, 19 Mar 2009 02:33:00 +0000
Message-ID: <49C1AEDC.9030809 () cowlark ! com>
--------------------
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Al Viro wrote:
[...]
> I'll probably go for gcc-like behaviour in sparse for now, unless somebody
> sees a good reason not to.  At least that one is consistent and doesn't
> bring the shitloads of fun questions about behaviour of arithmetic conversions,
> etc.
> 
> Comments?

All I can really say to that is: ew.

I like bitfields and use them frequently, particularly for flags and
packing several small fields into a small space; luckily I've already
been pretty anally retentive about declaring them explicitly as 'signed'
or 'unsigned'.

- From the compiler perspective, Principle of Least Surprise would suggest
doing the consistent thing, which as you say is gcc-like. OTOH from the
linter perspective I'd be *strongly* in favour of a warning if sparse
sees a problematic declaration. Bitfields are an area where signedness
suddenly becomes really important. (int i : 1, anyone?)

Are you submitting a bug report to the standards people?

- --
ââââ ï½ï½ï¼ ï½ï½ï½ï½ï½ï½ï½ï¼ï½ï½ï½ âââââ http://www.cowlark.com âââââ
â
â "All power corrupts, but we need electricity." --- Diana Wynne Jones,
â _Archer's Goon_
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iD8DBQFJwa7Zf9E0noFvlzgRAl6ZAKCb1Y9FNTkZRDQqvYH2URVZ7uw4uQCfeN8P
0Tif41kFR7FmUshV5PI7ogA=
=QHru
-----END PGP SIGNATURE-----
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: [RFC] potential DR in handling of signed int and unholy mess
Date: Thu, 19 Mar 2009 12:10:47 +0000
Message-ID: <49C23647.5030209 () knosof ! co ! uk>
--------------------
Al,

> 	First of all, C99 has rather unpleasant inconsistency between
> 6.7.2p5 and footnote in 6.7.2.1p9.  According to the former,

It is not really an inconsistency, one set of wording does not say
something about a particular case.

> However, the footnote in 6.7.2.1p9 says
>   "As specified in 6.7.2 above, if the actual type specifier
>    used is int or a typedef-name defined as int, then it is
>    implementation-defined whether the bit-field is signed or unsigned."

Ok, so the wording in 7.6.2 does not mention the typedef case.
At most this is an editorial change to the Standard.

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] potential DR in handling of signed int and unholy mess in ===

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: [RFC] potential DR in handling of signed int and unholy mess in
Date: Thu, 19 Mar 2009 01:33:58 +0000
Message-ID: <20090319013358.GZ28946 () ZenIV ! linux ! org ! uk>
--------------------
	First of all, C99 has rather unpleasant inconsistency between
6.7.2p5 and footnote in 6.7.2.1p9.  According to the former,
	typedef int T;
	struct {
		T x : 2;
	} y;
is equivalent to
	typedef signed int T;
	struct {
		T x : 2;
	} y;
and in both y.x must be signed.  Indeed, since the first declaration does
not declare a bitfield, int and signed int designate the same type in
it, per 6.7.2p5.

However, the footnote in 6.7.2.1p9 says
  "As specified in 6.7.2 above, if the actual type specifier
   used is int or a typedef-name defined as int, then it is
   implementation-defined whether the bit-field is signed or unsigned."

According to that, y.x in the second case is signed, but in the first one
it's implementation-defined whether it's signed or unsigned.

But 6.7.2 specifies no such thing!  The only place in there that speaks of
bit-fields is 6.7.2p5, which says
  "Each of the comma-separated sets designates the same type, except
   that for bit-fields, it is implementation-defined whether the specifier
   int designates the same type as signed int or the same type as unsigned
   int."
and there's no mentioning whatsoever of typedef-name in such context.

Note that it's not like the situation with char; plain char *IS* a separate
type, distinct from signed char and unsigned char alike.  There's no such
type in case of int; C99 is very clear on that one.  IOW, "explicit signedness"
for int is a property of declaration-specifiers interpretation, not of a type.

The only question is whether this property applies to bitfield declarations
alone (as 6.7.2p5 says) or it applies to typedef-name as well (as the footnote
in 6.7.2.1p9 says, with reference to hell knows what in 6.7.2).

FWIW, gcc follows 6.7.2.1p9 footnote.  It looks if we had 'signed' specifier
or a typedef-name marked explicitly signed; if either happens in typedef
declaration, gcc marks the new typedef-name as explicitly signed; if we
have a bitfield declaration that would result in a signed type *and* if
there's no explicitly signed specifiers in the mix *and* if the target
has unsigned bitfields, the type is replaced with unsigned counterpart.

Note that gcc typeof is *NOT* treated as explicitly signed, no matter what
it resolves to.  IOW, even
	typeof(signed int) x:2;
is treated as
	int x:2;
and if -funsigned-bitfields is present, unsigned it becomes.  How much of
that behaviour is going to remain stable?  No idea.

sparse walks even deeper into that shitpile; we really treat signed int
and int as different types.  Results are not pretty - for stuff like
	signed int *p;
	typeof(*p) .....
we get signed int, for stuff like
	typeof(signed_int_var + 1) .....
et.al. we get either int or signed int, depending on phase of the moon.
Leads to no end of fun in compatible types recognition, etc.

IMO it's a very real DR fodder; either the footnote in 6.7.2.1p9 should be
modified, dropping mentioning of typedef-name (and then e.g. gcc becomes
non-compliant) or 6.7.2 ought to grow some mentioning of 'typedef-name
defined as int' (probably in 6.7.2p5).

I'll probably go for gcc-like behaviour in sparse for now, unless somebody
sees a good reason not to.  At least that one is consistent and doesn't
bring the shitloads of fun questions about behaviour of arithmetic conversions,
etc.

Comments?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [patches] more declarations fixes ===

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: [patches] more declarations fixes
Date: Mon, 09 Mar 2009 07:10:08 +0000
Message-ID: <E1LgZcm-0000qk-0S () ZenIV ! linux ! org ! uk>
--------------------

OK, that pile ought to take care of a lot of nastiness.  We still have
rather messy crap in attributes' handling, but it's actually getting
cleaner now.  In particular, direct_declarator and declaration_specifiers
are relatively sane, handling of type specifiers should be correct now (and
much cleaner than it used to be) and most of the tangled mess around
attributes is untangled.  Still a mess, but at least doing something
about it becomes feasible...

That series is on top of Chris' tree; equivalent on top of Josh's one
is not particulary different.  Have fun...

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [patches] more declarations fixes
Date: Mon, 09 Mar 2009 22:55:47 +0000
Message-ID: <70318cbf0903091555t2f456476u16e06d642f1fd02 () mail ! gmail ! com>
--------------------
Great change. Thanks.

I will try it out later tonight.

Chris

On Mon, Mar 9, 2009 at 12:10 AM, Al Viro <viro@ftp.linux.org.uk> wrote:
>
> OK, that pile ought to take care of a lot of nastiness.  We still have
> rather messy crap in attributes' handling, but it's actually getting
> cleaner now.  In particular, direct_declarator and declaration_specifiers
> are relatively sane, handling of type specifiers should be correct now (and
> much cleaner than it used to be) and most of the tangled mess around
> attributes is untangled.  Still a mess, but at least doing something
> about it becomes feasible...
>
> That series is on top of Chris' tree; equivalent on top of Josh's one
> is not particulary different.  Have fun...
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [patches] more declarations fixes
Date: Mon, 09 Mar 2009 23:32:11 +0000
Message-ID: <20090309233211.GT28946 () ZenIV ! linux ! org ! uk>
--------------------
On Mon, Mar 09, 2009 at 03:55:47PM -0700, Christopher Li wrote:
> Great change. Thanks.
> 
> I will try it out later tonight.

And while we are at it, here come 3 scope-related fixes...

BTW, what in the name of everything unholy have you got in
validation/static-forward-decl.c?  Misplaced error line?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [patches] more declarations fixes
Date: Mon, 09 Mar 2009 23:53:18 +0000
Message-ID: <70318cbf0903091653x2c67decfif0260aae1d176f80 () mail ! gmail ! com>
--------------------
On Mon, Mar 9, 2009 at 4:32 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> BTW, what in the name of everything unholy have you got in
> validation/static-forward-decl.c?  Misplaced error line?

Err, that is obvious a screw up from my side. It just happen on a file
supposed to fail so I did not notice it. I will clean it up.

Thanks for point it out.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [patches] more declarations fixes
Date: Tue, 10 Mar 2009 22:42:14 +0000
Message-ID: <20090310224214.GU28946 () ZenIV ! linux ! org ! uk>
--------------------
On Tue, Mar 10, 2009 at 02:27:26PM -0700, Christopher Li wrote:
> On Mon, Mar 9, 2009 at 12:10 AM, Al Viro <viro@ftp.linux.org.uk> wrote:
> >
> > OK, that pile ought to take care of a lot of nastiness. ?We still have
> > rather messy crap in attributes' handling, but it's actually getting
> > cleaner now. ?In particular, direct_declarator and declaration_specifiers
> > are relatively sane, handling of type specifiers should be correct now (and
> > much cleaner than it used to be) and most of the tangled mess around
> > attributes is untangled. ?Still a mess, but at least doing something
> > about it becomes feasible...
> >
> 
> I really like these series of patches. All applied.
> 
> It is much cleaner now.
> 
> BTW, what does Set_S and Set_T means? Symbol and type?

s/symbol/solitary/, actually (it's used for the things that don't mix with
other specifiers at all).  T is more or less "type" - it's for the large
group of specifiers that are mutually exclusive (int/char/double/float/all
solitary ones - the only things that are *not* part of that set are
signed/unsigned/long/short).  For the sake of completeness, Set_Vlong (used
to track having seen "long" twice) comes from the name Plan 9 C compiler
used (pre-C99) for long long; they call it vlong, presumably with "v" for
"very".

FWIW, float could be considered solitary too, if not for (yet to be supported)
_Complex.  Parser-side modifications to support that would be fairly simple,
especially if we support gcc extensions[1].  Of course, we'd need to deal
with that more than just in parser - expand.c and evaluate.c at the very
least, and we'd need new EXPR_... node types for constant values...


[1] C99 gives parser a bit of a wart since _Complex, _Complex long and
long _Complex are not accepted, so we get valid combinations that have
invalid prefices; not a big deal.  Requires slightly different definition
for complex_op and an extra check and warning in the end of process.
gcc, out of either laziness or sheer insanity allows complex for *any*
arithmetic types, even though e.g. complex char makes no sense whatsoever,
so it's even simpler for parser to deal with.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: bitfields treatment ===

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: bitfields treatment
Date: Fri, 20 Mar 2009 21:37:27 +0000
Message-ID: <20090320213727.GJ28946 () ZenIV ! linux ! org ! uk>
--------------------
	Aside of corner cases associated with signedness, there's another
fun pile we are handling strangely.  Namely, treatment of integer promotions
and conversions.

	What standard says:
* there's a well-defined behaviour for bitfields based on _Bool, signed int
and unsigned int (int-based is equivalent to one signed or unsigned).  We
get it right, AFAICS, and so does gcc.
* implementation can do bitfields based on other types.  Fair enough.  Both
sparse and gcc allow those for any integer types.
* standard wording is such that it does *NOT* have integer promotions applied
to such bitfields, even if the size is smaller than int.  Arguably, that's
a hole in standard; in any case, both gcc and sparse *do* integer promotions
on those, with the same behaviour as usual (value-preserving promotion).
* for all bitfields we are told that they act as (signed or unsigned)
integer types of specified width.  That has interesting implications:

unsigned long long f(unsigned long long n)
{
	struct {
		unsigned long long n:33;
	} x = {n};
	return x.n + x.n;
}

*must* be equivalent to (n + n) & 0x1ffffffff on all implementations that
allow such bitfields.  I.e. these suckers are not promoted to base type;
they act as if we really head 33bit unsigned type, usual conversions in
x.n + x.n left the result with that type and addition had been done within
that type.

gcc does it that way, we do not (x.n gets promoted to unsigned long long).

AFAICS, sparse is wrong here; nothing to do about that, C99 is really not
ambiguous in that area.  HOWEVER, that's not the end of story.  It's nice
to say "it's an integer type of this width"; however, it is really not enough.

	What happens when we mix two such suckers with the same width?
I.e. what about their ranks?  gcc seems to do the following: when the width
is equal to that of base type, treat the bitfield as equivalent to the
base type.  When the size is smaller, treat all bitfields with this width
and this signedness as belonging to the same type.  It leaves a corner case,
though - what if the width *is* equal to that of a smaller normal type?
It *is* possible even on amd64 - there's a 128bit integer type (can't get
to it for bitfield without typedef due to cretinous syntax, but
	typedef unsigned __attribute__((mode(TI))) T;
	....
	T x : 64;
will get it for you).  Apparently, that gets treated as equivalent of
the lowest-rank standard type with that size, i.e. unsigned long in case
of amd64.  Fsck knows how stable that assumption would be...  For now, it
seems that they are careful of having such types only with the widths that
do not overlap with those of standard types and having only one signed/unsigned
pair for given size.

	BTW, with typeof() we *can* get to some of those types.  We can't apply
typeof to bitfield, but we can say
	struct {unsigned long long x:33;} x;
	typedef typeof(+x.x) __u33;
and it will actually work as expected with gcc.  Can do pointers to them,
etc.  Can't get smaller-than-int ones, but that's not particulary interesting
due to integer promotions.  I really wonder how well would sparse cope with
that (allocation size > bit_size rounded to byte).
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: bitfields treatment
Date: Sat, 21 Mar 2009 21:57:41 +0000
Message-ID: <49C562D5.40103 () knosof ! co ! uk>
--------------------
Al,

> * standard wording is such that it does *NOT* have integer promotions applied
> to such bitfields, even if the size is smaller than int.  Arguably, that's
> a hole in standard; in any case, both gcc and sparse *do* integer promotions
> on those, with the same behaviour as usual (value-preserving promotion).

The usual arithmetic conversions (of which integer promotion is a
subset) are performed where the standard says they are performed,
bit-field involving an implementation defined type or not.

> * for all bitfields we are told that they act as (signed or unsigned)
> integer types of specified width.  That has interesting implications:

See:
http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_315.htm

> unsigned long long f(unsigned long long n)
> {
> 	struct {
> 		unsigned long long n:33;
> 	} x = {n};
> 	return x.n + x.n;
> }
> 
> *must* be equivalent to (n + n) & 0x1ffffffff on all implementations that
> allow such bitfields.  I.e. these suckers are not promoted to base type;

Sentence 1162 says otherwise:
http://c0x.coding-guidelines.com/6.5.6.html

> they act as if we really head 33bit unsigned type, usual conversions in
> x.n + x.n left the result with that type and addition had been done within
> that type.
> 
> gcc does it that way, we do not (x.n gets promoted to unsigned long long).

It has been argued at WG14 that gcc gets it wrong.

> 	What happens when we mix two such suckers with the same width?

At the very least sparse should generate a useful message.

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: bitfields treatment
Date: Sat, 21 Mar 2009 23:12:33 +0000
Message-ID: <20090321231233.GM28946 () ZenIV ! linux ! org ! uk>
--------------------
On Sat, Mar 21, 2009 at 09:57:41PM +0000, Derek M Jones wrote:
>> to such bitfields, even if the size is smaller than int.  Arguably, that's
>> a hole in standard; in any case, both gcc and sparse *do* integer promotions
>> on those, with the same behaviour as usual (value-preserving promotion).
>
> The usual arithmetic conversions (of which integer promotion is a
> subset) are performed where the standard says they are performed,
> bit-field involving an implementation defined type or not.

The issue is whether integer promotion *do* anything for a type or happen
to be a no-op.  6.3.1.1p2 lists only the bitfields based on _Bool, int,
signed int and unsigned int, leaving the based on "some other implemention-
defined type" case mentioned in 6.7.2.1p4 not covered.  Then it proceeds
to say that everything not included in the lists is not affected by
integer promotions.

I.e. 6.3.1.1p2 as written says that e.g.
	unsigned long x : 2;
on implementations allowing unsigned long-based bitfields is not affected
by integer promotions.  All I can say is that in this case such reading
of standard can get stuffed.  The sane behaviour is close to TC proposed
in DR315, except that we should convert *all* bitfields that could be
represented by int/unsigned int resp.  If we end up with that in standard -
great, if not... I'm quite willing to go for deliberate non-compliance in
this particular case.

>> * for all bitfields we are told that they act as (signed or unsigned)
>> integer types of specified width.  That has interesting implications:
>
> See:
> http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_315.htm

Seen it...  AFAICS, the most recent part boils down to "since it's
implementation-defined per 6.7.2.1p4, it's up to implementation to
make up the rules".  Not particulary inspiring and Q2 there is a
non-issue.  The interesting part is not sizeof, it's modulo by which
the arithmetics is done...

>> unsigned long long f(unsigned long long n)
>> {
>> 	struct {
>> 		unsigned long long n:33;
>> 	} x = {n};
>> 	return x.n + x.n;
>> }
>>
>> *must* be equivalent to (n + n) & 0x1ffffffff on all implementations that
>> allow such bitfields.  I.e. these suckers are not promoted to base type;
>
> Sentence 1162 says otherwise:
> http://c0x.coding-guidelines.com/6.5.6.html

And?  Of course usual arithmetic conversions are applied.  Integer promotions
leave both arguments unaffected[1], left and right arguments have the same
type, so we get the same type as the result.

If you want to argue that type of either argument is simply unsigned long long,
you'll need more relevant references than that.  In particular, I'd like to
see how you propose to explain away 1407: "A bit-field is interpreted as a
signed or unsigned integer type consisting of the specified number of bits."
Unless you are talking about a target where the width of unsigned long long
is 33 bits, I'd say that whatever it is, it's not unsigned long long.

[1] they'd better - neither int nor unsigned int has to be wide enough to
hold the possible value.

>> they act as if we really head 33bit unsigned type, usual conversions in
>> x.n + x.n left the result with that type and addition had been done within
>> that type.
>>
>> gcc does it that way, we do not (x.n gets promoted to unsigned long long).
>
> It has been argued at WG14 that gcc gets it wrong.

What was the outcome of that argument?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: cgcc and REAL_CC help ===

From: rubisher <rubisher () scarlet ! be>
To: linux-sparse
Subject: cgcc and REAL_CC help
Date: Thu, 17 Dec 2009 09:15:46 +0000
Message-ID: <4B29F6C2.7040800 () scarlet ! be>
--------------------
Hello all,

May be can I ask you some more help.

I trying to sparse a bit grub2 code but at some moment make call a sript wich failled with following error:
genkernsyms.sh: line 23: REAL_CC=gcc-4.4: command not found

this shell script is:
### The configure script will replace these variables.

: ${srcdir=/Sources/jso/Deb.grub2/exp-wrk1}
: ${CC=REAL_CC=gcc-4.4 /usr/bin/cgcc}

u=
grep "^#define HAVE_ASM_USCORE" config.h >/dev/null 2>&1 && u="_"

$CC -O0 -DGRUB_MACHINE_IEEE1275=1 -m32 -fno-stack-protector -Wbitwise -Wnon-pointer-null -DGRUB_SYMBOL_GENERATOR=1 -E -I. 
-Iinclude
-I"$srcdir/include" $* \
   | grep -v '^#' \
   | sed -n \
         -e '/EXPORT_FUNC *([a-zA-Z0-9_]*)/{s/.*EXPORT_FUNC *(\([a-zA-Z0-9_]*\)).*/'"$u"'\1 kernel/;p;}' \
         -e '/EXPORT_VAR *([a-zA-Z0-9_]*)/{s/.*EXPORT_VAR *(\([a-zA-Z0-9_]*\)).*/'"$u"'\1 kernel/;p;}' \
   | sort -u

Any idea how should I fix it?

Tia,
	J.

PS: I am runing a debian unstable with bash 4.0-7 dpkg as shell.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bert Wesarg <bert.wesarg () googlemail ! com>
To: linux-sparse
Subject: Re: cgcc and REAL_CC help
Date: Thu, 17 Dec 2009 09:42:12 +0000
Message-ID: <36ca99e90912170142p26b9b0aal1a08509d65c53047 () mail ! gmail ! com>
--------------------
On Thu, Dec 17, 2009 at 10:15, rubisher <rubisher@scarlet.be> wrote:
> Hello all,
>
> May be can I ask you some more help.
>
> I trying to sparse a bit grub2 code but at some moment make call a sript
> wich failled with following error:
> genkernsyms.sh: line 23: REAL_CC=gcc-4.4: command not found
>
> this shell script is:
> ### The configure script will replace these variables.
>
> : ${srcdir=/Sources/jso/Deb.grub2/exp-wrk1}
> : ${CC=REAL_CC=gcc-4.4 /usr/bin/cgcc}
Try:

    export REAL_CC=gcc-4.4
    : ${CC=/usr/bin/cgcc}

Or use eval or the $CC command below.

>
> u=
> grep "^#define HAVE_ASM_USCORE" config.h >/dev/null 2>&1 && u="_"
>
> $CC -O0 -DGRUB_MACHINE_IEEE1275=1 -m32 -fno-stack-protector -Wbitwise
> -Wnon-pointer-null -DGRUB_SYMBOL_GENERATOR=1 -E -I. -Iinclude
> -I"$srcdir/include" $* \
> Â | grep -v '^#' \
> Â | sed -n \
> Â  Â  Â  Â -e '/EXPORT_FUNC *([a-zA-Z0-9_]*)/{s/.*EXPORT_FUNC
> *(\([a-zA-Z0-9_]*\)).*/'"$u"'\1 kernel/;p;}' \
> Â  Â  Â  Â -e '/EXPORT_VAR *([a-zA-Z0-9_]*)/{s/.*EXPORT_VAR
> *(\([a-zA-Z0-9_]*\)).*/'"$u"'\1 kernel/;p;}' \
> Â | sort -u
>
> Any idea how should I fix it?
>
> Tia,
> Â  Â  Â  Â J.
>
> PS: I am runing a debian unstable with bash 4.0-7 dpkg as shell.
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at Â http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Li <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: cgcc and REAL_CC help
Date: Sun, 20 Dec 2009 22:45:01 +0000
Message-ID: <70318cbf0912201445m37b31c71r6209a26b40892461 () mail ! gmail ! com>
--------------------
On Fri, Dec 18, 2009 at 9:14 AM, rubisher <rubisher@scarlet.be> wrote:
> That said, my next issue is that "-E" which is disable by cgcc:
> [snip]
>    # If someone adds "-E", don't pre-process twice.
>    $do_compile = 0 if $_ eq '-E';
> [snip]
>
> If ever some of you knows why, I would be interested in?

My guess is that, both gcc and sparse pre-process print to stdout.
So allow them both pre-process will mess up the result.

The current cgcc chose to let sparse do the pre-process and don't
run the real cc. You can make the gcc does the real pro-process and
sparse just check though.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: rubisher <rubisher () scarlet ! be>
To: linux-sparse
Subject: Re: cgcc and REAL_CC help
Date: Mon, 21 Dec 2009 16:42:01 +0000
Message-ID: <4B2FA559.4040102 () scarlet ! be>
--------------------
Hello Chris,

Chris Li wrote:
> On Fri, Dec 18, 2009 at 9:14 AM, rubisher <rubisher@scarlet.be> wrote:
>> That said, my next issue is that "-E" which is disable by cgcc:
>> [snip]
>>    # If someone adds "-E", don't pre-process twice.
>>    $do_compile = 0 if $_ eq '-E';
>> [snip]
>>
>> If ever some of you knows why, I would be interested in?
> 
> My guess is that, both gcc and sparse pre-process print to stdout.
> So allow them both pre-process will mess up the result.
> 
That was also my guess but when I comment out this line and run the same script one time with 'REAL_CC=gcc-4.4 cgcc' and the
second time with 'gcc-4.4' the results are the same, thought?

> The current cgcc chose to let sparse do the pre-process and don't
> run the real cc. You can make the gcc does the real pro-process and
> sparse just check though.
> 
Yes I think that I would have to do more effort to sparse this code.

Tx,
	J.

> Chris
> 


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: fun with declarations and definitions ===

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: fun with declarations and definitions
Date: Mon, 02 Feb 2009 07:30:19 +0000
Message-ID: <20090202073018.GB28946 () ZenIV ! linux ! org ! uk>
--------------------
	There are several interesting problems caused by the fact that
we create a separate symbol for each declaration of given function.

1)

static inline int f(void);
static int g(void)
{
	return f();
}
static inline int f(void)
{
	return 0;
}
gives an error, since the instance of f in g is not associated with anything
useful.  Needless to say, this is a perfectly valid C.  Moreover,
static inline int f(void)
{
	return 0;
}
static inline int f(void);
static int g(void)
{
	return f();
}
will step on the same thing.  Currently we get the former case all over the
place in the kernel, thanks to the way DEFINE_SYSCALLx() is done.

I have a kinda-sorta fix for that (basically, add a reference to external
definition to struct symbol and update it correctly - it's not hard).
However, that doesn't cover *another* weirdness in the same area -
gccisms around extern inline.  There we can have inline and external
definitions in the same translation unit (and they can be different,
to make the things even more interesting).  Anyway, that's a separate
story - as it is, we don't even have a way to tell 'extern inline ...'
from 'inline ...'

2) More fun in the same area: checks for SYM_FN in external_declaration()
do not take into account the possibility of
	void f(int);
	typeof(f) g;
Ergo, we get linkage-less function declarations.  Fun, innit?  No patch.

3) Better yet, sparse does _NOT_ reject
	typeof(f) g
	{
		...
	}
which is obviously a Bloody Bad Idea(tm) (just think what that does to
argument list).  Similar crap is triggerable with typedef.  IMO, we really
ought to reject _that_ - not only 6.9.1(2) explicitly requires that, but
there's no even remotely sane way to deal with arguments.

4)
	static void f(void);
	...
	void f(void);
triggers "warning: symbol 'f' was not declared. Should it be static?"
which is at least very confusing - it *is* declared and it *is* static.
IOW, we do not collect the linkage information sanely.  (2) will make
fixing that one very interesting.

Anyway, proposed patch for (1) follows:

Subject: [PATCH] Handle mix of declarations and definitions

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 evaluate.c                 |    7 +++++++
 parse.c                    |   16 ++++++++++++++++
 symbol.h                   |    1 +
 validation/context-named.c |    2 ++
 validation/definitions.c   |   12 ++++++++++++
 5 files changed, 38 insertions(+), 0 deletions(-)
 create mode 100644 validation/definitions.c

diff --git a/evaluate.c b/evaluate.c
index f976645..5ed31a9 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2747,6 +2747,10 @@ static int evaluate_symbol_call(struct expression *expr)
 	if (ctype->ctype.modifiers & MOD_INLINE) {
 		int ret;
 		struct symbol *curr = current_fn;
+
+		if (ctype->definition)
+			ctype = ctype->definition;
+
 		current_fn = ctype->ctype.base_type;
 
 		ret = inline_function(expr, ctype);
@@ -3052,6 +3056,9 @@ static struct symbol *evaluate_symbol(struct symbol *sym)
 	if (base_type->type == SYM_FN) {
 		struct symbol *curr = current_fn;
 
+		if (sym->definition && sym->definition != sym)
+			return evaluate_symbol(sym->definition);
+
 		current_fn = base_type;
 
 		examine_fn_arguments(base_type);
diff --git a/parse.c b/parse.c
index eb31871..3cdcf63 100644
--- a/parse.c
+++ b/parse.c
@@ -2105,6 +2105,7 @@ static struct token *parse_function_body(struct token *token, struct symbol *dec
 	struct symbol_list **old_symbol_list;
 	struct symbol *base_type = decl->ctype.base_type;
 	struct statement *stmt, **p;
+	struct symbol *prev;
 	struct symbol *arg;
 
 	old_symbol_list = function_symbol_list;
@@ -2138,6 +2139,18 @@ static struct token *parse_function_body(struct token *token, struct symbol *dec
 	if (!(decl->ctype.modifiers & MOD_INLINE))
 		add_symbol(list, decl);
 	check_declaration(decl);
+	decl->definition = decl;
+	prev = decl->same_symbol;
+	if (prev && prev->definition) {
+		warning(decl->pos, "multiple definitions for function '%s'",
+			show_ident(decl->ident));
+		info(prev->definition->pos, " the previous one is here");
+	} else {
+		while (prev) {
+			prev->definition = decl;
+			prev = prev->same_symbol;
+		}
+	}
 	function_symbol_list = old_symbol_list;
 	if (function_computed_goto_list) {
 		if (!function_computed_target_list)
@@ -2282,6 +2295,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			}
 		}
 	} else if (base_type && base_type->type == SYM_FN) {
+		if (decl->next_id && decl->next_id->scope == decl->scope)
 		/* K&R argument declaration? */
 		if (lookup_type(token))
 			return parse_k_r_arguments(token, decl, list);
@@ -2309,6 +2323,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			}
 		}
 		check_declaration(decl);
+		if (decl->same_symbol)
+			decl->definition = decl->same_symbol->definition;
 
 		if (!match_op(token, ','))
 			break;
diff --git a/symbol.h b/symbol.h
index c4d7f28..e5369d2 100644
--- a/symbol.h
+++ b/symbol.h
@@ -155,6 +155,7 @@ struct symbol {
 			struct expression *initializer;
 			struct entrypoint *ep;
 			long long value;		/* Initial value */
+			struct symbol *definition;
 		};
 	};
 	union /* backend */ {
diff --git a/validation/context-named.c b/validation/context-named.c
index 58310e9..a896621 100644
--- a/validation/context-named.c
+++ b/validation/context-named.c
@@ -501,6 +501,8 @@ static void good_mixed_with_if(void)
  * check-name: Check -Wcontext with lock names
  *
  * check-error-start
+context-named.c:417:13: warning: multiple definitions for function 'good_fn2'
+context-named.c:408:13:  the previous one is here
 context-named.c:86:3: warning: context imbalance in 'warn_lock1': wrong count at exit
 context-named.c:86:3:    context 'TEST': wanted 0, got 1
 context-named.c:93:3: warning: context imbalance in 'warn_lock2': wrong count at exit
diff --git a/validation/definitions.c b/validation/definitions.c
new file mode 100644
index 0000000..fce7393
--- /dev/null
+++ b/validation/definitions.c
@@ -0,0 +1,12 @@
+static inline int f(void);
+static int g(void)
+{
+        return f();
+}
+static inline int f(void)
+{
+	return 0;
+}
+/*
+ * check-name: finding definitions
+ */
-- 
1.5.6.6

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Mon, 02 Feb 2009 20:17:06 +0000
Message-ID: <70318cbf0902021217r634f94a0y46fe572091a78634 () mail ! gmail ! com>
--------------------
On Sun, Feb 1, 2009 at 11:30 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
>        There are several interesting problems caused by the fact that
> we create a separate symbol for each declaration of given function.

Thanks for the patch. That is great. This is actually one of the two
hard problem in
sparse. I haven't able to solved them. (BTW, the other one was running
out of modifier bits.)

You patch seems base on Josh's tree. In my tree the context change has been
back out, so the  validation/context-named.c is gone. Other than that, the patch
seems apply fine. I will take a closer look at it and get back to you.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Mon, 02 Feb 2009 20:58:14 +0000
Message-ID: <20090202205814.GF28946 () ZenIV ! linux ! org ! uk>
--------------------
On Mon, Feb 02, 2009 at 12:17:06PM -0800, Christopher Li wrote:
> On Sun, Feb 1, 2009 at 11:30 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> >        There are several interesting problems caused by the fact that
> > we create a separate symbol for each declaration of given function.
> 
> Thanks for the patch. That is great. This is actually one of the two
> hard problem in
> sparse. I haven't able to solved them. (BTW, the other one was running
> out of modifier bits.)

Modifier bits are going to get easier - I have a patch series that
takes a bunch out (basically, to hell with everything in MOD_SPECIFIER -
the only hard part is on the parser side and I've got a saner way to
deal with that).
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Mon, 02 Feb 2009 22:25:00 +0000
Message-ID: <70318cbf0902021425n3550d961na1ab14bd0d684953 () mail ! gmail ! com>
--------------------
On Mon, Feb 2, 2009 at 12:58 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> Modifier bits are going to get easier - I have a patch series that
> takes a bunch out (basically, to hell with everything in MOD_SPECIFIER -
> the only hard part is on the parser side and I've got a saner way to
> deal with that).

That sounds like an interesting patch. Cared to shared it? Even it is not
quite ready, I would like to take a look and maybe I can learn some thing.

I want to store more than a few bits attribute information. So I was hacking a
patch to make an separate structure for extended attributes.
Only the symbol that use those extended attribute will have it.
The address space and context will move to the extend attributes
as well. Most of the symbol don't have special attribute, so it will save up
some space overall. Does it sound like some thing sane to do?

Any way, I haven't able to get it to work. The big messy part is when sparse
propagate those attributes, some times it need to keep a separate copy of
the extended attributes, because this extended attribute is option for symbols.
Maybe I should try it again.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Tue, 03 Feb 2009 03:07:24 +0000
Message-ID: <70318cbf0902021907w634ffc6dm693022b23a0eabfc () mail ! gmail ! com>
--------------------
On Sun, Feb 1, 2009 at 11:30 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> Anyway, proposed patch for (1) follows:

I read the patch, seems reasonable. It is only solve the inline case though.
The more generic problem still exist, symbol look up between partial
prototype declare and the real declare will get symbol with partial
information.

It would be great if we can apply the definition to the first symbol. But
I can haven't find a clean way to do it yet.

Most likely I will apply your patch until we find a better way to do it.

> @@ -2282,6 +2295,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>                        }
>                }
>        } else if (base_type && base_type->type == SYM_FN) {
> +               if (decl->next_id && decl->next_id->scope == decl->scope)

Not sure what this is trying to do. Shouldn't the next line to be indented
if I read it correctly?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Tue, 03 Feb 2009 04:13:17 +0000
Message-ID: <20090203041317.GH28946 () ZenIV ! linux ! org ! uk>
--------------------
On Mon, Feb 02, 2009 at 07:07:24PM -0800, Christopher Li wrote:
> On Sun, Feb 1, 2009 at 11:30 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> > Anyway, proposed patch for (1) follows:
> 
> I read the patch, seems reasonable. It is only solve the inline case though.
> The more generic problem still exist, symbol look up between partial
> prototype declare and the real declare will get symbol with partial
> information.

... and unfortunately, that's what we _have_ to do.  Reason: behaviour
of typeof().  Example:

extern int a[];
int a[__builtin_types_compatible_p(typeof(a),int [3]) + 3];	/* 4 */
int b[__builtin_types_compatible_p(typeof(a),int [3]) + 3];	/* 3 */

Similar for
extern int a[];		/* a is int [] */
typedef typeof(a) A;	/* A is int []  _AND_ _WILL_ _REMAIN_ _SO_ */
int a[10];		/* a is int [10] now */
A b;			/* int [] */
int b[1];		/* no problem */

Similar applies for functions getting pointers to functions, etc. - having
the type refined by subsequent declaration is not retroactive.

Mind you, we are not doing composite types in any useful way and _that_ is
where we ought to change things.  Subsequent declarations should pick
the additional type information; we do propagate the inline definition
back to the call sites, provided that we had the function declared inline
before those.  However, the type information should _not_ be spread back.

And it's not just due to typeof (I suspect that honest attempt to define
its semantics in presense of back-propagation like that will end up to
be Turing-complete, but even if it is decidable it's prohibitively hard).
Note that we do have similar effects in standard C - e.g.

extern int a[];
void f(void)
{
	extern int a[24];
	memset(a, 0, sizeof(a)); /* OK */
}
void g(void)
{
	memset(a, 0, sizeof(a)); /* error - sizeof(a) is hidden from us here */
}

doesn't involve any extensions and having it barf on the second memset call
there is certainly intended behaviour.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Tue, 03 Feb 2009 04:41:56 +0000
Message-ID: <20090203044156.GI28946 () ZenIV ! linux ! org ! uk>
--------------------
On Mon, Feb 02, 2009 at 07:07:24PM -0800, Christopher Li wrote:
> >        } else if (base_type && base_type->type == SYM_FN) {
> > +               if (decl->next_id && decl->next_id->scope == decl->scope)
> 
> Not sure what this is trying to do. Shouldn't the next line to be indented
> if I read it correctly?

Yuck.   That's a leftover that hadn't been caught since it affects only
K&R definitions.  Kill that line...

ObDeclarationParsing: I'm sorely (_very_ sorely) tempted to claim that
gcc folks are violating GPL.  Proof: gcc/c-parse.in, around productions
for declspecs_*.  Of course, they can say that this _is_ the preferred
form for making modifications, but having such admission made in public
would be worth it...  Trying to sort out the __attribute__ handling in
there just plain hurts ;-/
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Thu, 05 Feb 2009 18:40:40 +0000
Message-ID: <70318cbf0902051040m7506a365s784a591667358f1f () mail ! gmail ! com>
--------------------
On Mon, Feb 2, 2009 at 8:13 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
>> I read the patch, seems reasonable. It is only solve the inline case though.
>> The more generic problem still exist, symbol look up between partial
>> prototype declare and the real declare will get symbol with partial
>> information.
>
> ... and unfortunately, that's what we _have_ to do.  Reason: behaviour
> of typeof().  Example:
>
> extern int a[];
> int a[__builtin_types_compatible_p(typeof(a),int [3]) + 3];     /* 4 */
> int b[__builtin_types_compatible_p(typeof(a),int [3]) + 3];     /* 3 */
>
> Similar for
> extern int a[];         /* a is int [] */
> typedef typeof(a) A;    /* A is int []  _AND_ _WILL_ _REMAIN_ _SO_ */
> int a[10];              /* a is int [10] now */
> A b;                    /* int [] */
> int b[1];               /* no problem */
>
> Similar applies for functions getting pointers to functions, etc. - having
> the type refined by subsequent declaration is not retroactive.

I see. So the subsequent declaration for the same symbol should inherent
previous declaration attributes, but no the other way around.

> Mind you, we are not doing composite types in any useful way and _that_ is
> where we ought to change things.  Subsequent declarations should pick
> the additional type information; we do propagate the inline definition
> back to the call sites, provided that we had the function declared inline
> before those.  However, the type information should _not_ be spread back.

Right. I think currently sparse treat the subsequent declaration like a new
one. It check the type is compatible with previous declaration. But it does
not merge the previous declaration information.

> doesn't involve any extensions and having it barf on the second memset call
> there is certainly intended behaviour.

That is good to know. I will keep that in mind.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Thu, 05 Feb 2009 18:47:17 +0000
Message-ID: <498B3435.8010506 () knosof ! co ! uk>
--------------------
Christopher,

> Right. I think currently sparse treat the subsequent declaration like a new
> one. It check the type is compatible with previous declaration. But it does
> not merge the previous declaration information.

Sparse needs to generate composite types:
http://c0x.coding-guidelines.com/6.2.7.html

-- 
Derek M. Jones                         tel: +44 (0) 1252 520 667
Knowledge Software Ltd                 mailto:derek@knosof.co.uk
Source code analysis                   http://www.knosof.co.uk
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Thu, 05 Feb 2009 18:52:31 +0000
Message-ID: <70318cbf0902051052h7c1e0149s90dda738bcf55500 () mail ! gmail ! com>
--------------------
On Mon, Feb 2, 2009 at 8:41 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> Yuck.   That's a leftover that hadn't been caught since it affects only
> K&R definitions.  Kill that line...

Apply and pushed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Thu, 05 Feb 2009 20:28:11 +0000
Message-ID: <20090205202811.GO28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Feb 05, 2009 at 06:47:17PM +0000, Derek M Jones wrote:
> Christopher,
>
>> Right. I think currently sparse treat the subsequent declaration like a new
>> one. It check the type is compatible with previous declaration. But it does
>> not merge the previous declaration information.
>
> Sparse needs to generate composite types:
> http://c0x.coding-guidelines.com/6.2.7.html

Of course it does need that (and it's not C0X news, obviously).  We still
have the type handling messed up in a lot of areas, so the plan is to
sort out the declaration parsing, then get rid of the warts in type
representation and handling, then deal with composites.

IMO the right way to look at that crap is:
	* any declaration gives a new struct symbol, with type being the
composite of that given by declaration and that of previously seen one
(which, in turn, has gathered all earlier stuff)
	* type nodes should be treated as expressions, with on-demand
evaluation and referential transparency (i.e. any rewrite replaces with
equal).  We are not that far from such state.
	* composite type is built by unifying two trees, with evaluation
driven by comparisons.
	* we should _NOT_ do update-in-place from e.g. int[] to int[3] -
it's guaranteed to mess e.g. typedef handling, not to mention making the
VLA implementation hard as hell.  We are not referentially transparent
for e.g. struct expression and we'd paid a _lot_ for that.

Note that even check for type compatibility is fscked up for function
types - as it is, we treat void() and void(int) as incompatible types.
So yes, the composite type handling is certainly needed.  We also have
deeply fscked treatment of declarations, mostly thanks to fallout from
trying to be compatible with gcc in attribute handling ;-/

BTW, typedef treatment in declarators is also b0rken: witness sparse barfing on

typedef int T;
extern void f(int);
void g(int x)
{
        int (T);
        T = x;
        f(T);
}

which is a valid C (we have T redeclared in the function scope as int,
with declarator -> direct-declarator -> ( declarator ) -> ( identifier )
as derivation).  sparse mistakes int (T) for typename, does *NOT* notice
that typename has no business whatsoever being there and silently proceeds
to T = ..., without having redeclared T as object of type int.  It sees
typedef-name <something>, decides that it's a beginning of external-definition
and vomits on the following =.

IOW, the rule in direct_declarator() for distinguishing between function
and non-function is broken...
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Thu, 05 Feb 2009 22:41:00 +0000
Message-ID: <70318cbf0902051441m3b015affvc33003ac6a733f18 () mail ! gmail ! com>
--------------------
On Thu, Feb 5, 2009 at 12:28 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
>
> Of course it does need that (and it's not C0X news, obviously).  We still
> have the type handling messed up in a lot of areas, so the plan is to
> sort out the declaration parsing, then get rid of the warts in type
> representation and handling, then deal with composites.


>
> IMO the right way to look at that crap is:
>        * any declaration gives a new struct symbol, with type being the
> composite of that given by declaration and that of previously seen one
> (which, in turn, has gathered all earlier stuff)
>        * type nodes should be treated as expressions, with on-demand
> evaluation and referential transparency (i.e. any rewrite replaces with
> equal).  We are not that far from such state.

Can you elaborate the referential transparency? I currently have a vague
idea of what you are trying to do. Where should I start if I am going
to turn the idea into code. Should we delay the detail of type
information until evaluate stage?


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Thu, 05 Feb 2009 23:22:49 +0000
Message-ID: <20090205232249.GQ28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Feb 05, 2009 at 02:41:00PM -0800, Christopher Li wrote:

> Can you elaborate the referential transparency? I currently have a vague
> idea of what you are trying to do. Where should I start if I am going
> to turn the idea into code. Should we delay the detail of type
> information until evaluate stage?

Basically, "replace equal with equal".  I.e. whatever we do with struct
symbol that might be visible to somebody, we should not change the
interpretation of type for *any* struct symbol, including ones that
might refer to that one.

Take a look at uninlining for a nice example of the fallout you get
when that property doesn't hold.  We cannibalize struct expression
during evaluation a _lot_, so we have to be bloody careful about what
we share and what we must copy.

For struct expression we do that in a lot of places and it's probably
worth to keep doing due to memory footprint concerns.  For types
we can avoid that.

As for the laziness - yes, that's what classify_type() et.al. is about.
We want to do exactly as little as possible; basically, *all* type
node evaluation (aka examining) should be demand-driven.  It mostly
holds, but we definitely could be lazier, e.g. in qualifier-related
stuff.

I'll do a more complete braindump (ideally - along with the declaration-parsing
patchset, so that this work could really start) once I dig myself from
under the !@#!@#!@# patch and mail piles elsewhere a bit.

			Al, terminally annoyed by the size of backlog ;-/
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Fri, 06 Feb 2009 05:36:55 +0000
Message-ID: <20090206053655.GS28946 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Feb 05, 2009 at 09:19:21PM +0000, Al Viro wrote:
> IOW, direct_declarator() (which doubles for direct-abstract-declarator) should
> have more than one-bit indication of which case we've got.  Right now it's
> done by "have we passed a non-NULL ident ** to store the identifier being
> declared"; that's not enough.  What we need is explicit 'is that a part of
> parameter declaration' flag; then the rule turns into
> 	if (p && *p)
> 		fn = 1; /* we'd seen identifier already, can't be nested */
> 	else if match_op(next, ')')
> 		fn = 1; /* empty list can't be direct-declarator or
> 			 * direct-abstract-declarator */
> 	else
> 		fn = (in_parameter && lookup_type(next));

Umm...  It's a bit more subtle (p goes NULL after the nested one is
handled), so we need to keep track of "don't allow nested declarator from
that point on" explicitly.  Patch follows:

Subject: [PATCH] Handle nested declarators vs. parameter lists correctly

Seeing a typedef name after ( means that we have a parameter-type-list
only if we are parsing a parameter declaration or a typename; otherwise
it might very well be a redeclaration (e.g. int (T); when T had been a
typedef in outer scope).

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
 parse.c                        |   26 +++++++++++++++-----------
 validation/nested-declarator.c |   11 +++++++++++
 2 files changed, 26 insertions(+), 11 deletions(-)
 create mode 100644 validation/nested-declarator.c

diff --git a/parse.c b/parse.c
index 7e3191a..73e7b65 100644
--- a/parse.c
+++ b/parse.c
@@ -1227,7 +1227,7 @@ static struct token *abstract_array_declarator(struct token *token, struct symbo
 }
 
 static struct token *parameter_type_list(struct token *, struct symbol *, struct ident **p);
-static struct token *declarator(struct token *token, struct symbol *sym, struct ident **p);
+static struct token *declarator(struct token *token, struct symbol *sym, struct ident **p, int);
 
 static struct token *handle_attributes(struct token *token, struct ctype *ctype, unsigned int keywords)
 {
@@ -1247,13 +1247,15 @@ static struct token *handle_attributes(struct token *token, struct ctype *ctype,
 	return token;
 }
 
-static struct token *direct_declarator(struct token *token, struct symbol *decl, struct ident **p)
+static struct token *direct_declarator(struct token *token, struct symbol *decl, struct ident **p, int prefer_abstract)
 {
 	struct ctype *ctype = &decl->ctype;
+	int dont_nest = 0;
 
 	if (p && token_type(token) == TOKEN_IDENT) {
 		*p = token->ident;
 		token = token->next;
+		dont_nest = 1;
 	}
 
 	for (;;) {
@@ -1275,14 +1277,16 @@ static struct token *direct_declarator(struct token *token, struct symbol *decl,
 			int fn;
 
 			next = handle_attributes(next, ctype, KW_ATTRIBUTE);
-			fn = (p && *p) || match_op(next, ')') || lookup_type(next);
+			fn = dont_nest || match_op(next, ')') ||
+				(prefer_abstract && lookup_type(next));
 
 			if (!fn) {
 				struct symbol *base_type = ctype->base_type;
-				token = declarator(next, decl, p);
+				token = declarator(next, decl, p, prefer_abstract);
 				token = expect(token, ')', "in nested declarator");
 				while (ctype->base_type != base_type)
 					ctype = &ctype->base_type->ctype;
+				dont_nest = 1;
 				p = NULL;
 				continue;
 			}
@@ -1336,10 +1340,10 @@ static struct token *pointer(struct token *token, struct ctype *ctype)
 	return token;
 }
 
-static struct token *declarator(struct token *token, struct symbol *sym, struct ident **p)
+static struct token *declarator(struct token *token, struct symbol *sym, struct ident **p, int prefer_abstract)
 {
 	token = pointer(token, &sym->ctype);
-	return direct_declarator(token, sym, p);
+	return direct_declarator(token, sym, p, prefer_abstract);
 }
 
 static struct token *handle_bitfield(struct token *token, struct symbol *decl)
@@ -1399,7 +1403,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **
 		struct ident *ident = NULL;
 		struct symbol *decl = alloc_symbol(token->pos, SYM_NODE);
 		decl->ctype = ctype;
-		token = declarator(token, decl, &ident);
+		token = declarator(token, decl, &ident, 0);
 		decl->ident = ident;
 		if (match_op(token, ':')) {
 			token = handle_bitfield(token, decl);
@@ -1439,7 +1443,7 @@ static struct token *parameter_declaration(struct token *token, struct symbol **
 	sym = alloc_symbol(token->pos, SYM_NODE);
 	sym->ctype = ctype;
 	*tree = sym;
-	token = declarator(token, sym, &ident);
+	token = declarator(token, sym, &ident, 1);
 	sym->ident = ident;
 	apply_modifiers(token->pos, &sym->ctype);
 	sym->endpos = token->pos;
@@ -1451,7 +1455,7 @@ struct token *typename(struct token *token, struct symbol **p, int mod)
 	struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
 	*p = sym;
 	token = declaration_specifiers(token, &sym->ctype, 0);
-	token = declarator(token, sym, NULL);
+	token = declarator(token, sym, NULL, 1);
 	apply_modifiers(token->pos, &sym->ctype);
 	if (sym->ctype.modifiers & MOD_STORAGE & ~mod)
 		warning(sym->pos, "storage class in typename (%s)",
@@ -2261,7 +2265,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	token = declaration_specifiers(token, &ctype, 0);
 	decl = alloc_symbol(token->pos, SYM_NODE);
 	decl->ctype = ctype;
-	token = declarator(token, decl, &ident);
+	token = declarator(token, decl, &ident, 0);
 	apply_modifiers(token->pos, &decl->ctype);
 
 	decl->endpos = token->pos;
@@ -2333,7 +2337,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 		decl = alloc_symbol(token->pos, SYM_NODE);
 		decl->ctype = ctype;
 		token = declaration_specifiers(token, &decl->ctype, 1);
-		token = declarator(token, decl, &ident);
+		token = declarator(token, decl, &ident, 0);
 		apply_modifiers(token->pos, &decl->ctype);
 		decl->endpos = token->pos;
 		if (!ident) {
diff --git a/validation/nested-declarator.c b/validation/nested-declarator.c
new file mode 100644
index 0000000..24ed833
--- /dev/null
+++ b/validation/nested-declarator.c
@@ -0,0 +1,11 @@
+typedef int T;
+extern void f(int);
+static void g(int x)
+{
+	int (T);
+	T = x;
+	f(T);
+}
+/*
+ * check-name: nested declarator vs. parameters
+ */
-- 
1.5.6.6

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: fun with declarations and definitions
Date: Mon, 09 Feb 2009 07:52:23 +0000
Message-ID: <70318cbf0902082352n32450ca2g87c847bb035baf15 () mail ! gmail ! com>
--------------------
On Thu, Feb 5, 2009 at 9:36 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> On Thu, Feb 05, 2009 at 09:19:21PM +0000, Al Viro wrote:
>> IOW, direct_declarator() (which doubles for direct-abstract-declarator) should
>> have more than one-bit indication of which case we've got.  Right now it's
>> done by "have we passed a non-NULL ident ** to store the identifier being
>> declared"; that's not enough.  What we need is explicit 'is that a part of
>> parameter declaration' flag; then the rule turns into
>>       if (p && *p)
>>               fn = 1; /* we'd seen identifier already, can't be nested */
>>       else if match_op(next, ')')
>>               fn = 1; /* empty list can't be direct-declarator or
>>                        * direct-abstract-declarator */
>>       else
>>               fn = (in_parameter && lookup_type(next));
>
> Umm...  It's a bit more subtle (p goes NULL after the nested one is
> handled), so we need to keep track of "don't allow nested declarator from
> that point on" explicitly.  Patch follows:
>
> Subject: [PATCH] Handle nested declarators vs. parameter lists correctly
>
> Seeing a typedef name after ( means that we have a parameter-type-list
> only if we are parsing a parameter declaration or a typename; otherwise
> it might very well be a redeclaration (e.g. int (T); when T had been a
> typedef in outer scope).

The patch looks great. Applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: new sparse release? ===

From: Jeff Layton <jlayton () poochiereds ! net>
To: linux-sparse
Subject: new sparse release?
Date: Fri, 25 Sep 2009 12:31:09 +0000
Message-ID: <20090925083109.18353a08 () tlielax ! poochiereds ! net>
--------------------
The sparse package in Fedora is based on the latest release of sparse
(0.4.1). That seems to be really old (from 2007) and is lacking
important patches (like the one to ignore the __cold__ attribute).

Would it be possible to cut a newer release sometime in the near future
so that distros can pick up a new official version?

Thanks,
-- 
Jeff Layton <jlayton@poochiereds.net>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: new sparse release?
Date: Fri, 25 Sep 2009 17:12:32 +0000
Message-ID: <70318cbf0909251012q6e21a7b6g96c68351c19c772a () mail ! gmail ! com>
--------------------
On Fri, Sep 25, 2009 at 5:31 AM, Jeff Layton <jlayton@poochiereds.net> wrote:
> The sparse package in Fedora is based on the latest release of sparse
> (0.4.1). That seems to be really old (from 2007) and is lacking
> important patches (like the one to ignore the __cold__ attribute).
>
> Would it be possible to cut a newer release sometime in the near future
> so that distros can pick up a new official version?
>

Sure, I mean to do that. Currently the sparse wiki is up. I have been
syncing bits from chrisl branch from time to time.

I just need to:
- Get a PGP key.
- Sign the new release tag.
- Run magic git command to generate stat of changes.
- Add change log.
- make dist.
- Upload the tar package.
- Announce the release to mailing list.

I will cut 0.4.2.0-rc1 one over the week end.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Layton <jlayton () kernel ! org>
To: linux-sparse
Subject: new sparse release?
Date: Mon, 26 Jul 2021 11:20:28 +0000
Message-ID: <c7963e9e4c7d5b91fc8bee9c9ae9a9c893664e0b.camel () kernel ! org>
--------------------
It's been quite a while since we've had a new sparse release and there
are some fixes that I'd like to see in the fedora package. I could just
cut a release from a current git snapshot, but I don't want to do that
if there are any plans to do a release soon. 

Any idea when the next sparse release will be?

Thanks, 
-- 
Jeff Layton <jlayton@kernel.org>

================================================================================

From: Jeff Layton <jlayton () kernel ! org>
To: linux-sparse
Subject: Re: new sparse release?
Date: Tue, 27 Jul 2021 12:48:26 +0000
Message-ID: <330ba271fdc21d5453702d4403be6f35b5e9dd76.camel () kernel ! org>
--------------------
On Mon, 2021-07-26 at 17:50 +0200, Luc Van Oostenryck wrote:
> On Mon, Jul 26, 2021 at 07:20:28AM -0400, Jeff Layton wrote:
> > It's been quite a while since we've had a new sparse release and there
> > are some fixes that I'd like to see in the fedora package. I could just
> > cut a release from a current git snapshot, but I don't want to do that
> > if there are any plans to do a release soon. 
> > 
> > Any idea when the next sparse release will be?
> 
> I've been quite a bit side-tracked lately and as such I had nothing
> really planned. But yes, it's been a while with enough changes already.
> I've a few minor fixes I would like to add and a bigger series (but
> one 'm not really happy with). I'll see what I can do n the next days
> but the idea would be to do a -rc next WE and the full release a few
> days later (so around Aug 5) if nothing serious come up.
> 
> Would this be OK for you?
> 

Yeah, sounds fine. No huge rush for any of this, to be clear, but it
would be nice to have an updated release in the near future.

Thanks!
-- 
Jeff Layton <jlayton@kernel.org>

================================================================================

From: Jeff Layton <jlayton () kernel ! org>
To: linux-sparse
Subject: Re: new sparse release?
Date: Tue, 31 Aug 2021 12:51:43 +0000
Message-ID: <72eec6322944bc2fc91e053565fb27ee4aaa203f.camel () kernel ! org>
--------------------
On Tue, 2021-07-27 at 08:48 -0400, Jeff Layton wrote:
> On Mon, 2021-07-26 at 17:50 +0200, Luc Van Oostenryck wrote:
> > On Mon, Jul 26, 2021 at 07:20:28AM -0400, Jeff Layton wrote:
> > > It's been quite a while since we've had a new sparse release and there
> > > are some fixes that I'd like to see in the fedora package. I could just
> > > cut a release from a current git snapshot, but I don't want to do that
> > > if there are any plans to do a release soon. 
> > > 
> > > Any idea when the next sparse release will be?
> > 
> > I've been quite a bit side-tracked lately and as such I had nothing
> > really planned. But yes, it's been a while with enough changes already.
> > I've a few minor fixes I would like to add and a bigger series (but
> > one 'm not really happy with). I'll see what I can do n the next days
> > but the idea would be to do a -rc next WE and the full release a few
> > days later (so around Aug 5) if nothing serious come up.
> > 
> > Would this be OK for you?
> > 
> 
> Yeah, sounds fine. No huge rush for any of this, to be clear, but it
> would be nice to have an updated release in the near future.
> 
> Thanks!

Hi Luc,

Just checking back in. Were you still planning to do an -rc for 0.6.4?

Thanks,
-- 
Jeff Layton <jlayton@kernel.org>

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: new sparse release?
Date: Tue, 31 Aug 2021 12:58:48 +0000
Message-ID: <20210831125848.mqkudmaz4innkst4 () mail>
--------------------
> Hi Luc,
> 
> Just checking back in. Were you still planning to do an -rc for 0.6.4?
> 
> Thanks,

Hi,

Sorry, I've had a few unplanned things to handle here.
I'll do a -rc1 this evening, when I'm back home and,
if everything is fine, as I hope it will, the release somewhere
between Friday & Saturday.

-- Luc
================================================================================


################################################################################

=== Thread: pysparse: Python bindings for sparse ===

From: Anderson Lizardo <anderson.lizardo () gmail ! com>
To: linux-sparse
Subject: pysparse: Python bindings for sparse
Date: Wed, 27 May 2009 01:38:25 +0000
Message-ID: <5b5833aa0905261838r6ddfb0f4xa343f787c47e4f40 () mail ! gmail ! com>
--------------------
Hi,

I am proud to announce the availability of pysparse, that consists of
Python bindings for sparse. It can be obtained from:

http://gitorious.org/pysparse/pysparse

Please note it is the initial commit, and many things are missing (see
the TODO section on the README). But I've already added enough support
to port test-dissect, test-lexing and test-linearize to python, and
they work just fine :)

My plans are to add support for more functions incrementally as I
become more familiar with the current public sparse API.

Comments, suggestions and contributions are welcome. Note that I've
intentionally licensed pysparse under the MIT license so that it can
be added to a future sparse release licensed under it (if the sparse
maintainers want so). But for now pysparse can live outside sparse
tree just fine.

Thanks,
-- 
Anderson Lizardo
Instituto Nokia de Tecnologia (INdT)
Manaus - Brazil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: smatch_implied.c ===

From: Dan Carpenter <error27 () gmail ! com>
To: linux-sparse
Subject: smatch_implied.c
Date: Mon, 16 Feb 2009 10:43:17 +0000
Message-ID: <alpine.DEB.2.00.0902161341500.3451 () bikeee>
--------------------
I pushed some new code and it's pretty cool.

This is some kernel code from drivers/char/ppdev.c
    681          compat_negot = 0;
    682          if (!(pp->flags & PP_CLAIMED) && pp->pdev &&
    683              (pp->state.mode != IEEE1284_MODE_COMPAT)) {
    684                  struct ieee1284_info *info;
    685
    686                  /* parport released, but not in compatibility mode */
    687                  parport_claim_or_block (pp->pdev);
    688                  pp->flags |= PP_CLAIMED;
    689                  info = &pp->pdev->port->ieee1284;
    690                  pp->saved_state.mode = info->mode;
    691                  pp->saved_state.phase = info->phase;
    692                  info->mode = pp->state.mode;
    693                  info->phase = pp->state.phase;
    694                  compat_negot = 1;
    695          } else if ((pp->flags & PP_CLAIMED) && pp->pdev &&
    696              (pp->pdev->port->ieee1284.mode != IEEE1284_MODE_COMPAT)) {
    697                  compat_negot = 2;
    698          }
    699          if (compat_negot) {
    700                  parport_negotiate (pp->pdev->port, IEEE1284_MODE_COMPAT);
    701                  printk (KERN_DEBUG CHRDEV
    702                          "%x: negotiated back to compatibility mode because "
    703                          "user-space forgot\n", minor);
    704          }
    705
    706          if (pp->flags & PP_CLAIMED) {
    707                  struct ieee1284_info *info;
    708
    709                  info = &pp->pdev->port->ieee1284;

The new smatch code recognizes that pp->pdev might be null when we 
dereference it on line 709.  It used to do that before as well...  The 
cool part is that it recognizes that dereferencing pp->dev on line 700 is 
not a bug.

The trick is that when code paths get merged, all the states that are 
unique to one side get saved in an "implied pool".  The smatch_extra.c 
code tracks very simple assignments like "compat_negot = 2".

When there is an "if (compat_negot)" condition, we make a list of both the 
implied pools where compat_negot is not zero.  All the states which are 
two in both pools are true on line 700.  So if compat_negot isn't zero, 
pp->dev isn't null.

The sad part is that there are still way way too many false positives for 
smatch to be practical...  I need to rewrite smatch_extra to track many 
more things.  Also the checking scripts are pretty rubbish.

Nevertheless progress is being made...

regards,
dan carpenter
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse segv with simple test ===

From: Stephen Hemminger <shemminger () vyatta ! com>
To: linux-sparse
Subject: sparse segv with simple test
Date: Sun, 30 Aug 2009 22:32:02 +0000
Message-ID: <20090830153202.4dc5c58c () s6510>
--------------------
I was checking up on some enum issues and tried running the following:
	sparse -Wenum-mismatch enum.c
It dies here:
gdb) run -Wenum-mismatch e.c
Starting program: /home/shemminger/src/sparse/sparse -Wenum-mismatch enum.c

Program received signal SIGSEGV, Segmentation fault.
0x0805c81d in linearize_store_gen (ep=0xb7e7600c, value=0xb7e4e00c, 
    ad=0xbfd43134) at linearize.h:293
293		return (p && p->type != PSEUDO_VOID && p->type != PSEUDO_VAL);
(gdb) where
#0  0x0805c81d in linearize_store_gen (ep=0xb7e7600c, value=0xb7e4e00c, 
    ad=0xbfd43134) at linearize.h:293
#1  0x080609da in linearize_symbol (sym=0xb7e244cc) at linearize.c:1526
#2  0x080494bd in main (argc=-1209907772, argv=0xb7e245c4) at sparse.c:266
------
#include <stdio.h>

enum x { A, B, C };

static enum x foo(int n) {
	return (n > 0) ? A : B;
}

int main(int ac, char **av) {
	int x = foo(ac);
	enum x y = 99;

	printf("%d %d\n", x, y);
	return 0;
}
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: sparse segv with simple test
Date: Sun, 30 Aug 2009 22:53:58 +0000
Message-ID: <200908310053.59138.kdudka () redhat ! com>
--------------------
On Monday 31 of August 2009 00:32:02 Stephen Hemminger wrote:
> I was checking up on some enum issues and tried running the following:
> 	sparse -Wenum-mismatch enum.c
> It dies here:
> gdb) run -Wenum-mismatch e.c
> Starting program: /home/shemminger/src/sparse/sparse -Wenum-mismatch enum.c
>
> Program received signal SIGSEGV, Segmentation fault.
> 0x0805c81d in linearize_store_gen (ep=0xb7e7600c, value=0xb7e4e00c,
>     ad=0xbfd43134) at linearize.h:293
> 293		return (p && p->type != PSEUDO_VOID && p->type != PSEUDO_VAL);
> (gdb) where
> #0  0x0805c81d in linearize_store_gen (ep=0xb7e7600c, value=0xb7e4e00c,
>     ad=0xbfd43134) at linearize.h:293
> #1  0x080609da in linearize_symbol (sym=0xb7e244cc) at linearize.c:1526
> #2  0x080494bd in main (argc=-1209907772, argv=0xb7e245c4) at sparse.c:266
> ------
> #include <stdio.h>
>
> enum x { A, B, C };
>
> static enum x foo(int n) {
> 	return (n > 0) ? A : B;
> }
>
> int main(int ac, char **av) {
> 	int x = foo(ac);
> 	enum x y = 99;
>
> 	printf("%d %d\n", x, y);
> 	return 0;
> }

I am unable to reproduce the crash, tested with sparse 0.4.1 and current git 
HEAD. Even no suspicious place reported by valgrind. Maybe your <stdio.h> is 
the trigger. Could you please attach the preprocessed code?

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: sparse segv with simple test
Date: Mon, 31 Aug 2009 18:12:36 +0000
Message-ID: <200908312012.37019.kdudka () redhat ! com>
--------------------
On Monday 31 of August 2009 17:57:58 Stephen Hemminger wrote:
> Not sure why, but the crash went away after a 'make clean; make' so maybe
> something was stale on that machine?

Could be ... outdated depfiles, skewed mtimes, etc.

> It still doesn't give any warnings. about assigning an enum with a value
> out of range thou.

AFAICT it is not supposed to issue a warning in that case. Here is an example 
which is caught by the check:

static void f(void) {
    enum A { VAL_A } a = VAL_A;
    enum B { VAL_B } b = a;
}

$ sparse enum.c
enum.c:3:26: warning: mixing different enum types
enum.c:3:26:     int enum A  versus
enum.c:3:26:     int enum B

Note that you don't even need to write -Wenum-mismatch since it's default.

But it might be good idea to implement such out-of-range detection ;-)

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Stephen Hemminger <shemminger () vyatta ! com>
To: linux-sparse
Subject: Re: sparse segv with simple test
Date: Mon, 31 Aug 2009 18:49:00 +0000
Message-ID: <20090831114900.6887df23 () nehalam>
--------------------
On Mon, 31 Aug 2009 20:12:36 +0200
Kamil Dudka <kdudka@redhat.com> wrote:

> On Monday 31 of August 2009 17:57:58 Stephen Hemminger wrote:
> > Not sure why, but the crash went away after a 'make clean; make' so maybe
> > something was stale on that machine?
> 
> Could be ... outdated depfiles, skewed mtimes, etc.
> 
> > It still doesn't give any warnings. about assigning an enum with a value
> > out of range thou.
> 
> AFAICT it is not supposed to issue a warning in that case. Here is an example 
> which is caught by the check:
> 
> static void f(void) {
>     enum A { VAL_A } a = VAL_A;
>     enum B { VAL_B } b = a;
> }
> 
> $ sparse enum.c
> enum.c:3:26: warning: mixing different enum types
> enum.c:3:26:     int enum A  versus
> enum.c:3:26:     int enum B
> 
> Note that you don't even need to write -Wenum-mismatch since it's default.
> 
> But it might be good idea to implement such out-of-range detection ;-)

Yes, I was looking to use more enum's in places where int was used in the
kernel. There were places where the interface expected a limit range of
values like network device transmit, but the interface was being misused
and caller was returning errno values.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: sparse segv with simple test
Date: Mon, 31 Aug 2009 19:04:54 +0000
Message-ID: <200908312104.54990.kdudka () redhat ! com>
--------------------
On Monday 31 of August 2009 20:49:00 Stephen Hemminger wrote:
> > But it might be good idea to implement such out-of-range detection ;-)
>
> Yes, I was looking to use more enum's in places where int was used in the
> kernel. There were places where the interface expected a limit range of
> values like network device transmit, but the interface was being misused
> and caller was returning errno values.

Generally you can't simply check if the value is in a *range* since the enum 
values could be non-continuous. You need to check for all continuous 
sub-ranges or even for all values.

What about issuing a warning for any assignment of int value to enum? (as it 
is already checked by a C++ compiler) Such places are IMHO always suspicious. 
If you know what you are doing you can still cast it explicitly to avoid such 
warning.

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: sparse segv with simple test
Date: Mon, 31 Aug 2009 20:53:54 +0000
Message-ID: <20090831205353.GA6239 () josh-work ! beaverton ! ibm ! com>
--------------------
On Mon, Aug 31, 2009 at 09:04:54PM +0200, Kamil Dudka wrote:
> On Monday 31 of August 2009 20:49:00 Stephen Hemminger wrote:
> > > But it might be good idea to implement such out-of-range detection ;-)
> >
> > Yes, I was looking to use more enum's in places where int was used in the
> > kernel. There were places where the interface expected a limit range of
> > values like network device transmit, but the interface was being misused
> > and caller was returning errno values.
> 
> Generally you can't simply check if the value is in a *range* since the enum 
> values could be non-continuous. You need to check for all continuous 
> sub-ranges or even for all values.
> 
> What about issuing a warning for any assignment of int value to enum? (as it 
> is already checked by a C++ compiler) Such places are IMHO always suspicious. 
> If you know what you are doing you can still cast it explicitly to avoid such 
> warning.

That seems quite sensible, and it even seems like something sparse
should warn about by default.

The reverse, warning about the assignment of an enum value to int, seems
useful as well, but sparse shouldn't issue that warning by default
because a lot of code just uses enum to define constants.

Distinguishing between anonymous and named enums seems useful as well.
An anonymous enum just creates some named constants but doesn't create a
type to use them with, so assigning those constants to int shouldn't
generate a warning.  (Corner case: "enum { ... } foo;".)

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: flow.c:804: rewrite_parent_branch: Asparse: flow.c:804: ===

From: Belisko Marek <marek.belisko () gmail ! com>
To: linux-sparse
Subject: sparse: flow.c:804: rewrite_parent_branch: Asparse: flow.c:804:
Date: Thu, 03 Sep 2009 09:49:56 +0000
Message-ID: <e7c6a05e0909030249qb5dac77u35293c4d857bba0f () mail ! gmail ! com>
--------------------
Hi,

current linux-next tree compiled with make C=1 all >build.out 2>&1
produce following error.

sparse: flow.c:804: rewrite_parent_branch: Assertion `changed' failed.
/bin/sh: line 1: 19625 Aborted                 sparse -D__linux__
-Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void
-D__i386_
_ -nostdinc -isystem /usr/lib/gcc/i586-suse-linux/4.3/include
-Wp,-MD,kernel/trace/.ring_buffer_benchmark.o.d -nostdinc -isystem
/usr/lib/g
cc/i586-suse-linux/4.3/include -Iinclude
-I/home/marek.nandra/kernel/linux-next/arch/x86/include -include
include/linux/autoconf.h -D__KERN
EL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs
-fno-strict-aliasing -fno-common -Werror-implicit-function-declaration
-Wno-format-se
curity -fno-delete-null-pointer-checks -Os -m32 -msoft-float
-mregparm=3 -freg-struct-return -mpreferred-stack-boundary=2
-march=i486 -Wa,-
mtune=generic32 -ffreestanding -fstack-protector -fstack-protector-all
-DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-com
pare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2
-mno-3dnow -fno-omit-frame-pointer -fno-optimize-sibling-calls -g
-Wdeclar
ation-after-statement -Wno-pointer-sign -fno-strict-overflow
-fprofile-arcs -ftest-coverage -DMODULE -D"KBUILD_STR(s)=#s"
-D"KBUILD_BASENAM
E=KBUILD_STR(ring_buffer_benchmark)"
-D"KBUILD_MODNAME=KBUILD_STR(ring_buffer_benchmark)" -D"DEBUG_HASH=55"
-D"DEBUG_HASH2=35" kernel/trace
/ring_buffer_benchmark.c
make[2]: *** [kernel/trace/ring_buffer_benchmark.o] Error 134
make[1]: *** [kernel/trace] Error 2
make: *** [kernel] Error 2


-- 
as simple as primitive as possible
-------------------------------------------------
Marek Belisko - OPEN-NANDRA

Ruska Nova Ves 219 | Presov, 08005 Slovak Republic
Tel: +421 915 052 184
skype: marekwhite
icq: 290551086
web: http://open-nandra.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

