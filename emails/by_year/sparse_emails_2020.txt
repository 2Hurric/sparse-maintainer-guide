--- Emails for Year 2020 ---

=== Thread: [No Subject] ===

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
tend to call that style as zero-initialization, or universal zero
initialization.

[1]: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53119#c12



-- 
Danh
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
388 Greenwich St, New York, 10013, United States United.
PAYMENT CODE: FRB010
Swift: PTBLBXXX
==============================================

Attention: Beneficiary,

We write to inform you that Series of meetings have been held over the
past 2 weeks with the Secretary General of United Nations,U.S
Department of State and Dubai Union Organization this ended last
week.And parcel is under our custody right now, It will deliver to you
within 24 hours once you clear the charges which will cost you
according to the BANKERS COURIER SERVICES that wish to deliver your
ATM CARD card to
you immediately.

However, it is the pleasure of this office to inform you that your ATM
CARD number; is 29741733 and it has been approved and upgraded in your
favor .you call me for the pin code numbers. The ATM CARD value is us
$10.5 Million only.

Kindly contact the paying bank for the claim of your ATM visa card
payment fund $10,500,000.00 through the below contact information;

Contact Person:Mr Williams S Young
Director of Financial Controller
Bank Name: CITIBANK
Bank address; 388 Greenwich St,
New York City,10013, United States
Email:mrsmegwilliam6@gmail.com

Reconfirm the following information?

(1)Your Full Name=============
(2)Mobile Phone Number======
(3)Current Home Address==== ====
(4)Fax Number================
(5)Passport/Drivers license ======

Endeavor to keep me posted once you contacted the officer in charge
through the above mentioned information.

Your timely response is highly appreciated.To this end, you are
required to forward your payment information as follows to enable us
load your fund into the card with your information and deliver it to
your door step. as the BANKERS COURIER SERVICES are in charge of the
delivery services to your destination.

Yours truly;

Ms Mary Mcniff.
Chief Compliance Officer, Citigroup Inc
FEDERAL RESERVE SYSTEM.
Email: marymcniff7@gmail.com.
================================================================================

From: "Francois Pinault" <francioispinaul () gmail ! com>
To: linux-sparse
Subject: Re:
Date: Sun, 08 Mar 2020 17:33:22 +0000
Message-ID: <202003081733.028HWv59022119 () dn1 ! bdren ! net ! bd>
--------------------
A donation was made in your favour by Francois Pinault, reply for more details.
================================================================================


################################################################################

=== Thread: 19-02-2020 ===

From: "urs portmann" <mucios () imp ! edu ! mx>
To: linux-sparse
Subject: 19-02-2020
Date: Wed, 19 Feb 2020 10:51:42 +0000
Message-ID: <20200219105144.AC97D180635F4B () imp ! edu ! mx>
--------------------
Guten Morgen,
                                          19-02-2020
Wir haben versucht, Sie zu erreichen und haben noch nichts von Ihnen gehört. Haben Sie unsere letzte E-Mail über Ihre S.p.e.n.d.e erhalten? Wenn nicht, melden Sie sich bitte bei uns, um weitere Informationen zu erhalten.

Wir warten darauf, von Ihnen zu hören, sobald Sie diese Nachricht erhalten, die Sie bei der weiteren Vorgehensweise unterstützt.

Mfg
urs portmann
================================================================================


################################################################################

=== Thread: =?UTF-8?Q?=5BPossible_Spam=5D_Covid?= =?UTF-8?Q?_19_Wohlt=C3=A4tigkeitsfon?= =?UTF-8?Q?ds?= ===

From: charles jackson <lisa.petel () sd73 ! bc ! ca>
To: linux-sparse
Subject: =?UTF-8?Q?=5BPossible_Spam=5D_Covid?= =?UTF-8?Q?_19_Wohlt=C3=A4tigkeitsfon?= =?UTF-8?Q?ds?=
Date: Tue, 30 Jun 2020 08:18:39 +0000
Message-ID: <1075858694.67041388.1593505119760.JavaMail.zimbra () zimbra ! sd73 ! bc ! ca>
--------------------


-- 
Hallo
 
 Ich bin Charles W. Jackson aus North Carolina, Vereinigte Staaten von Amerika, und ich bin der Gewinner des Mega-Millionen-Jackpots von 344 Millionen US-Dollar. Ich spende die Summe von 2.000.000 Millionen Euro als Teil der Hilfsgelder f&uuml;r das Corona-Virus.
 
 Dies ist Ihr Spendencode: [CJ530342019]
 
 www.youtube.com/watch?v=BSr8myiLPMQ
 
 Bitte antworten Sie auf diese E-Mail mit dem SPENDERCODE:
 
 charlesjacksonjr001@gmail.com
 
 Ich hoffe, dass Sie und Ihre Familie dies durchkommen
 
 
 Herr Charles Jackson
================================================================================


################################################################################

=== Thread: =?utf-8?Q?=5BSpam=5D?= We are still waiting for your email... ===

From: piyin.crhe () live ! com ! mx
To: linux-sparse
Subject: =?utf-8?Q?=5BSpam=5D?= We are still waiting for your email...
Date: Wed, 09 Sep 2020 08:49:55 +0000
Message-ID: <20200909014955.ABB54E64DAD3975D () live ! com ! mx>
--------------------
Dear Beneficiary,

We wish to inform you that a power of attorney was forwarded to 
our office  by two gentlemen regarding your unclaimed fund of $56 
Million Dollar. One of them is an American citizen named Mr. 
Robert Porter and the other is Mr. Wilhelm Berg a Swedish 
citizen.We have be waiting for you to contact us since last year.

The document claims these gentlemen to be your authorized 
representatives, and the power of attorney states that you are 
already deceased.  It further states that your death was due to 
lung cancer, with your date of death being January 27th, 2020.

They have now submitted a new account to replace the receiving 
account that was in the original claim of funds. These funds have 
remained unclaimed for quite some time and the need for 
resolution is pressing. Below is the new account they have 
submitted.

Account Name's :  Robert Porter /Wilhelm Berg
Account: 5007-29 438 66
IBAN-nr: SE4150000000050072943866
Bic-kod: ESSESESS
Skandinaviska Enskilda Banken. (SEB :)
SWEDEN .

In the event that you are in fact still alive, we ask that you 
confirm your existence by responding to this email. You are to 
view this as a matter requiring immediate attention and response. 
We have 48 hr monitoring of all activities within Federal Reserve 
Bank.On this regard,you will be directed to any of our office 
center that you will go in person to sign the final papers,
because we have our payment center in Europe,Asia,America and 
Canada.You will go to any of the office that you will be directed 
to with the copy of the documents of your fund.

We have contacted the bank in the Sweden asking them to wait for 
further directives from Federal Reserve Bank, prior to 
authorizing any withdrawals in any form.  Our request is based 
entirely on our attempt to verify that you are in fact deceased, 
before money is wrongly disbursed.

Your in Service,

Robert Steven Kaplan
2200 N Pearl St, Dallas, TX 75201, United States
================================================================================


################################################################################

=== Thread: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?= ===

From: ''Tayeb Souami'' <aguayenergia () tlalpan ! gob ! mx>
To: linux-sparse
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Tue, 28 Jul 2020 09:08:40 +0000
Message-ID: <20200728090424.F046C4783FC () correo ! tlalpan ! gob ! mx>
--------------------
Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zufÃ¤llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Mail nach einem Spinball ausgewÃ¤hlt.Ich habe den grÃ¶Ãten Teil meines VermÃ¶gens auf eine Reihe von WohltÃ¤tigkeitsorganisationen und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die Summe von â¬ 2.000.000,00 an Sie als eine der ausgewÃ¤hlten 5 zu spenden, um meine Gewinne zu Ã¼berprÃ¼fen, sehen Sie bitte meine You Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=Z6ui8ZDQ6Ks


Das ist dein Spendencode: [TS530342018]


Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie glÃ¼cklich zu machen.

GrÃ¼Ãe
Herr Tayeb Souami
================================================================================

From: ''charles jackson'' <lu.marin () munisurquillo ! gob ! pe>
To: linux-sparse
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Fri, 14 Aug 2020 07:39:20 +0000
Message-ID: <20200814073930.18DF2403B4FE3 () mail ! munisurquillo ! gob ! pe>
--------------------
Hallo

Ich bin Charles W. Jackson aus North Carolina, Vereinigte Staaten von Amerika, und ich bin der Gewinner des Mega-Millionen-Jackpots von 344 Millionen US-Dollar. Ich spende die Summe von 2.000.000 Millionen Euro als Teil der Hilfsgelder für das Corona-Virus.

Dies ist Ihr Spendencode: [CJ530342019]

www.youtube.com/watch?v=BSr8myiLPMQ

Bitte antworten Sie auf diese E-Mail mit dem SPENDERCODE:

charlesjacksonjr001@gmail.com

Ich hoffe, dass Sie und Ihre Familie dies durchkommen


Herr Charles Jackson
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: kvm-ppc
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 05:19:48 +0000
Message-ID: <20210610051233.C94A71F22910 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-serial
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 05:28:31 +0000
Message-ID: <20210610052116.5F52A1F22C68 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-i2c
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 05:31:36 +0000
Message-ID: <20210610052420.6FDA71F225C2 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-tegra
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 05:40:37 +0000
Message-ID: <20210610053327.F0C961F22B7D () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-ide
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 05:43:20 +0000
Message-ID: <20210610053605.7BE4F1F231D3 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: ceph-devel
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 05:47:54 +0000
Message-ID: <20210610054040.4C4EF1F22F2E () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-kernel
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 05:59:48 +0000
Message-ID: <20210610055232.BDA661F230FE () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-pci
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 06:25:17 +0000
Message-ID: <20210610061808.3FCBE1F2373F () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-nilfs
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 06:29:36 +0000
Message-ID: <20210610062224.3AD801F237A8 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-nfs
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 06:36:24 +0000
Message-ID: <20210610062921.3D7541F23FC5 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: util-linux-ng
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 06:37:20 +0000
Message-ID: <20210610063013.E4EA11F239FA () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: devicetree
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 07:20:02 +0000
Message-ID: <20210610071248.580541F24BB4 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: reiserfs-devel
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:03:43 +0000
Message-ID: <20210610075632.99E2E1F25931 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-arch
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:03:57 +0000
Message-ID: <20210610075643.20B481F25946 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-s390
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:15:29 +0000
Message-ID: <20210610080816.5592B1F250A3 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-netdev
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:17:18 +0000
Message-ID: <20210610081004.C0E331F25C14 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-sparse
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:24:56 +0000
Message-ID: <20210610081741.11D8D1F2529C () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: kernel-janitors
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:26:01 +0000
Message-ID: <20210610081847.DD8521F2529B () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-pm
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:28:36 +0000
Message-ID: <20210610082121.A318B1F2538B () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-crypto-vger
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:49:08 +0000
Message-ID: <20210610084156.7F6F91F2635D () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-edac
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 08:49:59 +0000
Message-ID: <20210610084250.4155F1F26385 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================

From: ''Tayeb souami'' <mpaucar () chalver ! com ! ec>
To: linux-kbuild
Subject: =?utf-8?q?Covid_19_Wohlt=C3=A4tigkeitsfonds?=
Date: Thu, 10 Jun 2021 09:37:38 +0000
Message-ID: <20210610093028.1D8991F25E70 () mail ! chalver ! com ! ec>
--------------------

Lieber Freund,

Ich bin Herr Tayeb Souami, New Jersey, Vereinigte Staaten von Amerika, der =
Mega-Gewinner von $ 315million In Mega Millions Jackpot, spende ich an 5 zu=
f=C3=A4llige Personen, wenn Sie diese E-Mail erhalten, dann wurde Ihre E-Ma=
il nach einem Spinball ausgew=C3=A4hlt.Ich habe den gr=C3=B6=C3=9Ften Teil =
meines Verm=C3=B6gens auf eine Reihe von Wohlt=C3=A4tigkeitsorganisationen =
und Organisationen verteilt.Ich habe mich freiwillig dazu entschieden, die =
Summe von =E2=82=AC 2.000.000,00 an Sie als eine der ausgew=C3=A4hlten 5 zu=
 spenden, um meine Gewinne zu =C3=BCberpr=C3=BCfen, sehen Sie bitte meine Y=
ou Tube Seite unten.

UHR MICH HIER: https://www.youtube.com/watch?v=3DZ6ui8ZDQ6Ks



Das ist dein Spendencode: [TS530342018]



Antworten Sie mit dem SPENDE-CODE an diese

E-Mail:Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie gl=C3=BCcklich zu machen.

Gr=C3=BC=C3=9Fe
Herr Tayeb Souami
================================================================================


################################################################################

=== Thread: Attn: Dear Friend ===

From: Mrs Elizabeth Edawrds <alhajihassankareem () gmail ! com>
To: linux-sparse
Subject: Attn: Dear Friend
Date: Mon, 20 Apr 2020 20:31:35 +0000
Message-ID: <CAJC1dGogzANXtrKbxiG=WpX9qHv6rswo9b0Wrm0a5HoToAO=hA () mail ! gmail ! com>
--------------------
Dear Friend,

Please forgive me for stressing you with my predicaments as I know
that this letter may come to you as big surprise. Actually, as my
pastor advised me to reject earthly reward and thinks by handing the
project to someone I have never seen or met for a greater reward in
heaven awaits for whoever can give such a costly donation. I came
across your E-mail from my personal search, and I decided to email you
directly believing that you will be honest to fulfill my final wish
before or after my death.

 Meanwhile, I am Madam Elizabeth Edwards, 73 years, am from USA, still
childless. I am suffering from Adenocarcinoma Cancer of the lungs for
the past 8 years and from all indication my condition is really
deteriorating as my doctors have confirmed and courageously advised me
that I may not live beyond 2 weeks from now for the reason that my
tumor has reached a critical stage which has defiled all forms of
medical treatment.

Since my days are numbered, I=E2=80=99ve decided willingly to fulfill my
long-time vow to donate to the underprivileged the sum of Eighteen
million five hundred thousand dollars ($18.5m) I deposited in a
different account over 8 years now because I have tried to handle this
project by myself but I have seen that my health could not allow me to
do so anymore. My promise for the poor includes building of
well-equipped charity foundation hospital and a technical school for
their survival.

If you will be honest, kind and willing to assist me handle this
charity project as I=E2=80=99ve mentioned here, I will like you to provide =
me
your personal data like. Contact me through this email address
(elisabethe1981@mail.com) and also send me your private email address.

(1) Your full name:
(2) country:
(3) phone number:
(4) Age:

Best Regards!
Mrs. Elizabeth Edwards
================================================================================


################################################################################

=== Thread: Contact Diplomatic Agent, Mr. Mcclaine John to receive your ATM CARD valued the sum of $12.8Million ===

From: "Prof, William Roberts" <eco.bank1204 () gmail ! com>
To: linux-sparse
Subject: Contact Diplomatic Agent, Mr. Mcclaine John to receive your ATM CARD valued the sum of $12.8Million 
Date: Mon, 20 Jan 2020 19:32:40 +0000
Message-ID: <CAOE+jABpcHQWZWhtskhDFbtTqfBe7h065WE2kC1G+jQD+tQiTA () mail ! gmail ! com>
--------------------
Attn: Dear Beneficiary,

I wish to inform you that the diplomatic agent conveying your ATM CARD
valued the sum of $12.8Million United States Dollars has misplaced
your address and he is currently stranded at (George Bush
International Airport) Houston Texas USA now
We required you to reconfirm the following information's below to him
so that he can deliver your Payment CARD to you today or tomorrow
morning as information provided with open communications via email and
telephone for security reasons.
HERE IS THE DETAILS  HE NEED FROM YOU URGENT
YOUR FULL NAME:========
ADDRESS:========
MOBILE NO:========
NAME OF YOUR NEAREST AIRPORT:========
A COPY OF YOUR IDENTIFICATION :========

Note; do contact the diplomatic agent immediately through the
information's listed below
Contact Person: Diplomatic Agent, Mr. Mcclaine John
EMAIL: mcclainejohn.13@gmail.com
Tel:(223) 777-7518

Contact the diplomatic agent immediately
because he is waiting to hear from you today with the needed information's.

NOTE: The Diplomatic agent does not know that the content of the
consignment box is $12.800,000,00 Million United States Dollars and on
no circumstances should you let him know the content. The consignment
was moved from here as family treasures, so never allow him to open
the box. Please I have paid delivery fees for you but the only money
you must send to Mcclaine John is your ATM CARD delivery fee $25.00
only. text Him as you contact Him Immediately

Thanks,
with Regards.
Prof, William Roberts
Director DHL COURIER SERVICES-Benin
================================================================================


################################################################################

=== Thread: Contact Eco bank-Benin to receive your payment funds transfer amount of $12.800.000,00 Million USD,a ===

From: "Mrs. Angella Michelle" <info.zennitbankplcnigerian () gmail ! com>
To: linux-sparse
Subject: Contact Eco bank-Benin to receive your payment funds transfer amount of $12.800.000,00 Million USD,a
Date: Thu, 23 Apr 2020 18:27:12 +0000
Message-ID: <CABHzvrnzZLe4Z0E4acOdcsDJTPa3wvp-Oz12f_M4TQ03PAGZkw () mail ! gmail ! com>
--------------------
Attn Dear.
Contact Bank of Africa-Benin to receive your payment funds transfer amount =
of
$12.800.000,00 Million USD,approved this morning by IMF.
Happy to inform you, we have finally deposited your payment funds
$12.8 million us dollars with the Paying Bank of Africa-Benin
to transfer the payment amount of $12.800,000,00 Million Us Dollars to you
Contact the bank immediately you receive this email now.
Director Bank of Africa-Benin: Dr. Festus Obiara
Email id:  boa.benin107@yahoo.com
Tel/mobile, (229) 62819378
BOA-BENIN | GROUPE BANK OF AFRICA, boa-benin
Avenue Jean-Paul II - 08 BP 0879 - Cotonou - B=C3=A9nin
Phone:(229) 62819378.
2020 GROUPE BANK OF AFRICA
Be advised to re-confirm your bank details to this bank as listed.
Your account Holder's name----------------
Bank Name----------------------------------------------------------
Bank address----------------------------------------------
Account Numbers---------------------------------------
Rounting-----------------------------------------------------------------
Your direct Phone Numbers----------------------------------------------
Note,I have paid the deposit and insurance fees for you
But the only money you are to send to this bank is $150.00 us dollars
Been for the wire transfer fees of your funds
Contact Him now to receive your transfer deposited this morning
I wait for your reply upon confirmation
Mrs. Angella Michelle
Editor, Zenith Bank- Companies Benin
mrsa9389@gmail.com
================================================================================


################################################################################

=== Thread: FROM MR. MOORE ===

From: "MOORE GATES LTD" <TEXT () TEXT ! COM>
To: linux-sparse
Subject: FROM MR. MOORE
Date: Tue, 21 Jul 2020 03:17:24 +0000
Message-ID: <qoap--$$2--7c-9c () 95ql ! c ! sm7vtdb>
--------------------

--D9F2D5A2__
Content-Type: text/plain;
Content-Transfer-Encoding: quoted-printable

Dear Beloved,
Peace of the Lord be with you and family, I am Fitzpatrick Moore a
United Kingdom Citizen, I have ($ 25M) Twenty five Million united
states dollars with a finance House in United State. I will want you
to help me collect this deposit and dispatch it to charity
organizations. You will take out 30% of these funds for your
assistance to help ME disburse this fund to charities. I will like you
to acknowledge the receipt of this e-mail as soon as possible and
treats with absolute confidentiality and sincerity. Please reply to my
Email: (moorefitzpatrick@gmail.com)
Yours Sincerely,
Fitzpatrick Moore

--D9F2D5A2__--

================================================================================


################################################################################

=== Thread: Greetings From Mrs. Hilda Kickett Hancock. ===

From: Hilda Hancock <accueil () abbayedubec ! com>
To: linux-sparse
Subject: Greetings From Mrs. Hilda Kickett Hancock.
Date: Tue, 11 Feb 2020 22:59:27 +0000
Message-ID: <02b65f7bfcadb694689f378eeac96561 () abbayeup ! fr ! fto>
--------------------


-- 
Greetings From Mrs. Hilda Hancock.

May this day bring you peace, happiness, prosperity, good health and 
every blessings from above, may all of your wishes and dreams come true!

I was touched to send this message to you after I have carefully gone 
through your profile that speaks good of you in your country.

I am Dr. Mrs. Hilda Kickett Hancock a 69 years old woman from Australia, 
I am writing this message to let you know my heart desire to establish a 
charity foundation in your country through your noble assistance.

For more information, please respond to me immediately.

The future belongs to those who believe in the beauty of their dreams.

Yours respectfully,

Mrs. Hilda Hancock
Email: hildakicketthancock@gmail.com
================================================================================


################################################################################

=== Thread: Greetings From Mrs. Sarah Koffi ===

From: Sarah Koffi <paulwiliam782 () gmail ! com>
To: linux-sparse
Subject: Greetings From Mrs. Sarah Koffi
Date: Tue, 23 Jun 2020 11:15:57 +0000
Message-ID: <CAHqcnY1sQc2pQ+0Uyz5Y25va64Mmiq7PVAFb=gqiSCPOaqkzpA () mail ! gmail ! com>
--------------------
Greetings From Mrs. Sarah Koffi

I'm contacting you based on your good profiles I read and for a good
reasons, I am in search of a property to buy in your country as I
intended to come over to your
country for investment, Though I have not meet with you before but I
believe that one has to risk confiding in someone to succeed sometimes
in life.

My name is Mrs. Sarah Koffi. My late husband deals on Crude Oil with
Federal Government of Sudan and he has a personal Oil firm in Bentiu
Oil zone town and Upper
Nile city. What I have experience physically, I don't wish to
experience it again in my life due to the recent civil Ethnic war
cause by our President Mr. Salva Kiir
and the rebel leader Mr Riek Machar, I have been Under United Nation
refuge camp in chad to save my life and that of my little daughter.

Though, I do not know how you will feel to my proposal, but the truth
is that I sneaked into Chad our neighboring country where I am living
now as a refugee.
I escaped with my little daughter when the rebels bust into our house
and killed my husband as one of the big oil dealers in the country,
ever since then, I have being on the run.

I left my country and move to Chad our neighboring country with the
little ceasefire we had, due to the face to face peace meeting accord
coordinated by the US Secretary of State, Mr John Kerry and United
Nations in Ethiopia (Addis Ababa) between our President Mr Salva Kiir
and the rebel leader Mr Riek Machar to stop this war.

I want to solicit for your partnership with trust to invest the $8
million dollars deposited by my late husband in Bank because my life
is no longer safe in our country, since the rebels are looking for the
families of all the oil business men in the country to kill, saying
that they are they one that is milking the country dry.

I will offer you 20% of the total fund for your help while I will
partner with you for the investment in your country.
If I get your reply.

I will wait to hear from you so as to give you details.With love from

 i need you to contact me here sarahkoffi389@yahoo.co.jp

Mrs. Sarah Koffi
================================================================================


################################################################################

=== Thread: HAPPY SURVIVAL OF CORONAVIRUS ===

From: ECOWAS COMMITEE <ecowasmonitoringcommitteeabj () gmail ! com>
To: linux-sparse
Subject: HAPPY SURVIVAL OF CORONAVIRUS
Date: Fri, 20 Mar 2020 11:20:17 +0000
Message-ID: <CAHHubrZ1ezbdrwbRJEimmavkmE1YkgwPJE1q19_7Jvh2e8vX4A () mail ! gmail ! com>
--------------------
Dear Sir/Madam

HAPPY SURVIVAL OF CORONAVIRUS

We the West African Monitoring Committee of the West African Economic
Community(ECOWAS)are contacting you for a business transaction which
we feel will be of great interest to you.

Our duty is to see to the coming in and out of funds into this sub
region.There is a fund which we confiscated worth of $12.5 million
dollars.We will like you to receive this fund on your name in your
account and as well helping us in the investment.

You are advised to contact us as soon as you get this message for
details of the transaction if you find it interesting.

Best Regards,

Mr John Aka

Chairman
ECOWAS
West African Monitoring Committee
Tel 00225 6716 6756
Abidjan Cote D'Ivoire
================================================================================


################################################################################

=== Thread: HI ===

From: "Mr.Michea Sawadogo" <honbarrzongoibrahim () gmail ! com>
To: linux-sparse
Subject: HI
Date: Thu, 19 Mar 2020 11:33:54 +0000
Message-ID: <CAKZhgJTNvYZAbX2o7f3-zD_6S+HfwrfyNcVzCEa44_4YqemqBA () mail ! gmail ! com>
--------------------
-- 
Hello,

We are here to notify you that the sum of US$2,800,000.00 was
generated and awarded to you by the United Arab Emirates, and Qatar's
United Development (UD) under (CBI) Foundation of Burkina Faso, for a
charity project, The achieve and results of this is to help financial
problem in the nation.

This award was been selected through the internet, where your e-mail
address was indicated and notified. The Foundation collect all the
email addresses of the people that are active online, among the
Billions of customers who used all those means of Money Transfer, in
their business transactions. Four people are selected yearly to
benefit from this promotion and you are one of the Selected Winners.

For your prize contact the Agent: Mr Michea Sawadogo. With this code
(X220E) His E-mail (micheasawadogo072@gmail.com) he will direct you on what
to do for the releasing of your prize.

Yours Faithfully,
Awards Coordinator Mr. Samie Salam,
Chief executive Jassim Al-Othman.
================================================================================


################################################################################

=== Thread: Hello Dear ===

From: DR CHALLY NOAH <mayorabrahamedge404 () gmail ! com>
To: linux-sparse
Subject: Hello Dear
Date: Tue, 03 Mar 2020 18:07:56 +0000
Message-ID: <CALqVJWfs6c5u8GPtq5eVSK-ajudUdj5-F=fEyHY1UeBaPk8vjg () mail ! gmail ! com>
--------------------
Hello Dear,
What Have Kept You Waiting To Claim Your $600,000.00 USD Compensation Award?
This said fund was issued out by the UNITED NATIONS To compensate
you.Please If You Have Not Claim Your Fund (Award),Kindly contact me
at   DR.CHALLYNOAH@GMAIL.COM   for further details on how to proceed your
fund (award)release to you or better still reply back Immediately You
Receive This Information For An Urgent Confirmation And Release Of Your
Fund To You Without Delays, as your email was listed among those to be
compensated this year.Congratulations..
Best Regards,
Dr Chally Noah.
Minister Of Finance On Foreign Remittance:
================================================================================


################################################################################

=== Thread: Hello, Please ===

From: "Mr. Scott Donald" <confianzayrentabilidad () gmail ! com>
To: linux-sparse
Subject: Hello, Please
Date: Sun, 16 Aug 2020 14:28:30 +0000
Message-ID: <CANrrfX7wwL97G=jb--8nb9jH8oRO8T90L6NGSfg1HfnzMyyHcw () mail ! gmail ! com>
--------------------
--=20
Dear Friend,

I'm Mr. Scott Donald a Successful businessMan dealing with
Exportation, I got your mail contact through search to let you know my
intension and my Ugly Situation Am a dying Man here in Los Angeles
California Hospital Bed in (USA), I Lost my Wife and my only Daughter
for Covid-19 and I also have a problem in my Health and I can die
anytime I Know,

I have a project that I am about to hand over to you. and I already
instructed the Bankia S.A. Madrid, Spain(BSA) to transfer my fund sum
of =C2=A33,7M GBP. Equivalent to =E2=82=AC4,077,033.91 EUR, to you as to en=
able you
to give 50% of this fund to Charitable Home in your State and take 50%
don't think otherwise and why would anybody send someone you barely
know to help you deliver a message, help me do this for the happiness
of my soul and for God to mercy me and my Family and give Us a good
place.

please, do as I said there was someone from your State that I deeply
love so very very much and I miss her so badly I have no means to
reach any Charitable Home there. that is why I go for a personal
search of the Country and State and I got your mail contact through
search to let you know my Bitterness and please, help me is getting
Dark I ask my Doctor to help me keep you notice failure for me to
reach you in person Your urgent Response, here is my Doctor Whats-app
Number for urgent notice +13019692737

Hope To Hear From You. I'm sending this email to you for the second
time yet no response from you.

My Regards.

Mr. Scott Donald
CEO
================================================================================


################################################################################

=== Thread: Hello. ===

From: YAVUZ BEKTER <bakert.jg () gmail ! com>
To: linux-sparse
Subject: Hello.
Date: Tue, 23 Jun 2020 12:13:12 +0000
Message-ID: <CAAUSuTUvZ0_kfnu-NZoKKCVE0axON3iiyXTQq5VPW+zJkDn4kA () mail ! gmail ! com>
--------------------
I am the foreign operations director of Bank of Turkey.
My name is Mr, Yavuz. I have a sensitive investment project to discuss
with you, please reply now.
________________________
Ik ben de directeur buitenlandse activiteiten van de Bank of Turkey.
Mijn naam is meneer Yavuz. Ik moet een gevoelig investeringsproject bespreken
met u, antwoord dan nu.
================================================================================


################################################################################

=== Thread: Hello/Hallo ===

From: "Mr. John Galvan" <no-reply () msgroupspa ! com>
To: linux-sparse
Subject: Hello/Hallo
Date: Fri, 30 Oct 2020 08:08:03 +0000
Message-ID: <0d2cf4301ff4649fbf993b8f3f7e83c8 () msgroupspa ! com>
--------------------


-- 
Sir/Madam,

I have access to very vital information that can be used to move a huge 
amount of money. I have done my homework very well and I have the 
machineries in place to get it done since I am still in active service. 
If it was possible for me to do it alone I would not have bothered 
contacting you. Ultimately I need an honest foreigner to play an 
important role in the completion of this business transaction. Send 
responds to this email:Â galvan.johnny@outlook.com

Regards,
John Galvan

---------------------------------------------------------------

Sir / Madam,

Ich habe Zugang zu sehr wichtigen Informationen, mit denen ich eine 
groÃe Menge Geld bewegen kann. Ich habe meine Hausaufgaben sehr gut 
gemacht und ich habe die Maschinen, um sie zu erledigen, da ich immer 
noch im aktiven Dienst bin. Wenn es mir mÃ¶glich gewesen wÃ¤re, es alleine 
zu tun, hÃ¤tte ich mich nicht darum gekÃ¼mmert, Sie zu kontaktieren. 
Letztendlich brauche ich einen ehrlichen AuslÃ¤nder, der eine wichtige 
Rolle beim Abschluss dieses GeschÃ¤ftsvorgangs spielt. Senden Sie 
Antworten auf diese E-Mail: galvan.johnny@outlook.com

GrÃ¼Ãe,
John Galvan
================================================================================


################################################################################

=== Thread: I have already sent you first payment US$5000.00 this morning through MONEY Gram service.it is avail ===

From: Barrister Robert Richter UN-Attorney at Law Court-Benin  <info.zennitbankplcnige
To: linux-sparse
Subject: I have already sent you first payment US$5000.00 this morning through MONEY Gram service.it is avail
Date: Mon, 13 Apr 2020 11:41:28 +0000
Message-ID: <CABHzvrngm=rA5Ct9h+JGdbyDfHJmnfntceDPoyJToo8PZn+YZg () mail ! gmail ! com>
--------------------
ATTN DEAR BENEFICIARY.

GOOD NEWS.

I have already sent you first payment US$5000.00 this morning through
MONEY Gram service.it is available to pick up in address now.

So we advise you to Contact This Money Gram office to pick up your
transfer $US5000.00 today.


Note that your compensation payment funds is total amount $US2.800,000
Million Dollars.We have instructed the Money Gram Agent,Mr. James
Gadner to keep sending the transfer to you daily, but the maximum
amount you will be receiving everyday is US$5000.00. Contact Agent now
to pick up your first payment $US5000.00 immediately.

Contact Person, Mr. James Gadner, Dir. Money Gram Benin.
Email: mgbenin903@gmail.com
Telephone Numbers: +229 62819378/ +229 98477762

HERE IS YOUR PAYMENT DETAILS FOR THE FIRST =C2=A3US5000.00 SENT TODAY.

Track View Website link:
https://secure.moneygram.com/track
Sender=E2=80=99s First name: David
Sender=E2=80=99s Last Name: Joiner
Money Transfer Control Number (MTCN) (REFERENCE)# 26046856

Contact the Mmoney Gram Urgent and reconfirm your address to the
office before, they will allow you to pick up the transfer today.

HERE IS WHAT REQUIRED OF YOU.

YOUR FULL NAME---------
ADDRESS--------------
COUNTRY-----------------------------
TELEPHONE NUMBERS-----------------

Note, I paid the transfer fee for you, but only you are required to
send to the office is $75 only,Been Your Payment File activation fee,
Send once you contact the office,before you can able to pick up your
transfer today.

Let me know once you pick up first payment today.

Barrister Robert Richter UN-Attorney at Law Court-Benin
================================================================================


################################################################################

=== Thread: I promise you must be happy today, God has uplifted you and your family ok ===

From: "Rev.Dr Emmanuel Okoye CEO Ecobank-benin"  <westernunion.benin982 () gmail ! com>
To: linux-sparse
Subject: I promise you must be happy today, God has uplifted you and your family ok
Date: Fri, 03 Jan 2020 20:20:08 +0000
Message-ID: <CAP=nHBJWiJ9KpSSbF4jP9u5UiU5d_kGjSUyPYDmdB2x1uiJFMw () mail ! gmail ! com>
--------------------
Dear Friend

i hope all is well with you,if so, glory be to God almighty. I'm very
happy to inform you, about my success in getting payment funds under
the cooperation of a new partner from United States of
America.Presently I am in uk for investment projects with my own share
of the total sum. I didn't forget your past efforts. IMF finally
approved your compensation payment funds this morning by prepaid (ATM)
Debit card of US$12,500.000.00Million Dollars, Since you not received
this payment yet, I was not certified
but it is not your fault and not my fault, I hold nothing against
you.than bank official whom has been detaining the transfer in the
bank, trying to claim your funds by themselves.

Therefore, in appreciation of your effort I have raised an
International prepaid (ATM) Debit card of US$12,500.000.00 in your
favor as compensation to you.

Now, i want you to contact my Diplomatic Agent, His name is Mike Benz
on His  e-mail Address (mikebenz550@aol.com

ask Him to send the Prepaid (ATM) Debit card to you. Bear in mind that
the money is in Prepaid (ATM) Debit card, not cash, so you need to
send to him,
your full name
address  where the prepaid (ATM) Debit card will be delivered to you,
including your cell phone number. Finally, I left explicit
instructions with him, on how to send the (ATM CARD) to you.

The Prepaid (ATM) Debit card, will be send to you through my
Diplomatic Agent Mr. Mike Benz immediately you contact him. So contact
my Diplomatic Agent Mr. Mike Benz immediately you receive this letter.
Below is his contact information:

NAME : MIKE BENZ
EMAIL ADDRESS: mikebenz550@aol.com
Text Him, (256) 284-4886

Request for Delivery of the Prepaid (ATM) Debit card  to you today.
Note, please I have paid for the whole service fees for you, so the
only money you will send to my Diplomatic Agent Mr. Mike Benz is
$50.00 for your prepaid (ATM) Debit card DELIVERY FEE to your address
ok.
Let me know once you receive this Card at your address.
Best regards,
Rev.Dr, George Adadar
================================================================================


################################################################################

=== Thread: I wait for your swift response, ===

From: Rick Schaech <cathben72 () gmail ! com>
To: linux-sparse
Subject: I wait for your swift response,
Date: Mon, 13 Jan 2020 05:52:37 +0000
Message-ID: <CAEcBxO=DoZZeZuHjVOxQpB8CM4fADYg6sCQVLkjP+qQwsNEH9A () mail ! gmail ! com>
--------------------
Dear, I'm Mr Rick Schaech, I am the General Account Auditor, Though i
know we have not meet each other before but sometimes in life God have
a reason of bringing two people from two different countries together
as business partners or life partners.

My dear friend, I have the sum of 15.7 Million USD i wish to put in
your name due to the death of my late client who died several years
ago as his next of kin column still remain blank. Though the internet
medium is highly abuse these days but am assuring you that this
transaction is legitimate and I am contacting you that we may have a
deal, note for your cooperation and collaboration 40% of the sum will
be for you while the other 60% will be for me as well. I wait for your
swift response for more details. please forward your response to my
personal E-mail: rickschaech@gmail.com

Yours sincerely,
Rick Schaech.
================================================================================


################################################################################

=== Thread: KASAN: global-out-of-bounds Read in precalculate_color ===

From: syzbot <syzbot+02d9172bf4c43104cd70 () syzkaller ! appspotmail ! com>
To: linux-sparse
Subject: Re: KASAN: global-out-of-bounds Read in precalculate_color
Date: Wed, 12 Aug 2020 01:07:05 +0000
Message-ID: <0000000000005c72d405aca3ce17 () google ! com>
--------------------
syzbot suspects this issue was fixed by commit:

commit dfd402a4c4baae42398ce9180ff424d589b8bffc
Author: Marco Elver <elver@google.com>
Date:   Thu Nov 14 18:02:54 2019 +0000

    kcsan: Add Kernel Concurrency Sanitizer infrastructure

bisection log:  https://syzkaller.appspot.com/x/bisect.txt?x=13eb65d6900000
start commit:   46cf053e Linux 5.5-rc3
git tree:       upstream
kernel config:  https://syzkaller.appspot.com/x/.config?x=ed9d672709340e35
dashboard link: https://syzkaller.appspot.com/bug?extid=02d9172bf4c43104cd70
syz repro:      https://syzkaller.appspot.com/x/repro.syz?x=147e5ac1e00000
C reproducer:   https://syzkaller.appspot.com/x/repro.c?x=14b49e71e00000

If the result looks correct, please mark the issue as fixed by replying with:

#syz fix: kcsan: Add Kernel Concurrency Sanitizer infrastructure

For information about bisection process see: https://goo.gl/tpsmEJ#bisection
================================================================================


################################################################################

=== Thread: LETTER OF INQUIRY ===

From: "Mr. Theophilus Odadudu" <cristinamedina0010 () gmail ! com>
To: linux-sparse
Subject: LETTER OF INQUIRY
Date: Fri, 07 Feb 2020 20:44:08 +0000
Message-ID: <CAPNvSTj-8q7w5QPmnH26+_3xCKjEWyE+9xcb8QyQs9Xie+iYgg () mail ! gmail ! com>
--------------------
Good Day,

I work as a clerk in a Bank here in Nigeria, I have a very
confidential Business Proposition for you. There is a said amount of
money floating in the bank unclaimed, belonging to the bank Foreign
customer who die with his family in the Ethiopian Airline crash of
March 11, 2019.

I seek your good collaboration to move the fund for our benefit. we
have agreed that 40% be yours once you help claim.

Do get back to with 1) Your Full Name: (2) Residential Address: (3)
Phone, Mobile  (4) Scan Copy of Your ID. to apply for claims of the
funds.

Regards
Theophilus Odadudu
================================================================================


################################################################################

=== Thread: Loan Application Breakdown ===

From: Express Loan South Africa <e445nau88 () vera ! com ! uy>
To: linux-sparse
Subject: Loan Application Breakdown
Date: Fri, 20 Mar 2020 10:05:20 +0000
Message-ID: <361278098.96655.1584698720921.JavaMail.zimbra () vera ! com ! uy>
--------------------
------=_Part_96653_887185263.1584698720918
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 7bit

 
Good Day, 

 Kindly Find Attached Files And Send Your Documents Back To Us. Apply With Us On Our 5% Interest Rate, 

We Offer for all categories. Personal, Home, Debt Consolidation And Business Loans. Even thou you are blacklisted or under debt review. 

 We await your swift responds.

Regards, 

Mrs. Paula Rigt 

Office Line: +27 679 616 466 

Legal Registration No. : 2014/238085/07 
------=_Part_96653_887185263.1584698720918
Content-Type: application/pdf; name="EXPRESS LOAN OFFER.pdf"
Content-Disposition: attachment; filename="EXPRESS LOAN OFFER.pdf"
Content-Transfer-Encoding: base64

JVBERi0xLjMKJcfsj6IKNSAwIG9iago8PC9MZW5ndGggNiAwIFIvRmlsdGVyIC9GbGF0ZURlY29k
ZT4+CnN0cmVhbQp4nOV93ZMkt3FnmNrlLmc3lktS/NTXiJKpHlrTLHwDsuW788kvF/ciBSP8QPrJ
PttxsS0Hef9/xGUCCSCrOjHdPYtdLe/ECBGsBqryl5lI5C+Bqvnuetkrfb3gP7XxL4err/4Urv/9
/1x9d21iivmiilFdexOvtXK2dInXf/jPqz9e5bHX3//71XdXcW/wf/kCb//L4fofvoYR6Vqp/WKv
v/63K1Xuem2XvfPXwbq9j9dfH652f3Xz9f++UsHtrb2+jctew+V/vfoGrt/qvYreu3OaEW6nkz6n
q9Z+vwT7z1//jyxh2iePAmqNEiz48CLTV39Siskfi7pINr1f4uJeT+M27kNMi39dt0TN/OPXaOn9
kpYlhgS+otWSwBuWvfFmMeE8+4MCq3qr/Q3oOV6DJfYWzf/N7i20TbTBmN2Pbm7BKRcXwZC8/eDG
7KPSSu8e3twqtw8h7t6+UXsblmBA4GUfjAO5do9ubi04UPR29xjw6MUvKf+uoWvUu3fwpj5Gs/v2
z/lOgCXtntxYuJVaFBv0NHuMCtHtvv3+5tbsF22iWrVZl2dZockmt3sXZA2Ky/cc1A1uFBeldu/B
r/AA+P19vBGMTnb3Afy+9/BYw5D+GKS2DqAEdivWE5tm753VHOCHACDATXcfYU9llY6oMxBJp+Cb
cCC6snvlPTwGZQMtGwABsjmj3Ua3dOuPoafem+TM7pMbt4fZljxeBI+ADmXqVZjoYCHtdVD8Dq2Z
O+iY1N5osYMmL4ROYBCIC3BjFheMCSjq7lMwnAlgT2bYz9AFFhus3f0EdWC0gVn/06wOnZxmg36W
teCWoBmidzLMgIP6xZ/j8LgsKvA7yd6E0NJi4BlDaH+xJjOQbJXX97RXiQ1dR2sISL4H7DvHXyri
VGSv1yiXPKJJdv+4WEPKuxghjVn0OjDyyG1whhm/+8XNLSwasMjwQMTCIYucQqBSu+s8F2Nynq8H
v4SusJyktPs8LzjLov3uVzl8qeBDgL7oNipB9DCu+s2v8bYxar/SzDXe1hgX+OL119iEaGDT7oub
W7fXEDl6PGajWYQSY+rPc2SPNtoaBa3OnXIYtEdR8Deoj5QsPPjbHSjcGQcK/fYGHg3AU+RXv8Rn
u2Sd42KI0RNjGgwD7KlHSpO9AiImdOIyjJqX+OCttksCnPe7w8vPmbOGtSnRLPs38LPTyYKL/BZ8
zFhl2PraF/Q+RTRfx29R98GZRa1E6Z79UXYHBf6824OPLNrung8zAmrCs9BxTAotp/1m91WeNzn5
4Ot/m1cL3hR8Pe4UtGLAbPlttDbkhbC8a3g4zFXrzoWpdqYlViwHYWL03y3KnoyzXDbyfkKxzgHe
hNX0TVjqth2imp52bJ7m/HyYr2o9zRFdmzOzgP/ffOW1Ps0CGXnzAMk3e3Pc5i9qPTDZDxvaicz6
pdfYttB9VVzGwtBYvYalwYxkS5R1da2ST1iN+VLJkl6HOZqKOriNDK0za3qA4yCxcsPFGHJl5SDf
q6t6jZuw7iqEIyedM5pvQjBuzvDmRMof6NM2y65xkU2GN1nw5gLh5jbsI9BRXr3jU2yQq0ccB8PY
RG7kaZWN8WoZp1eJrqvFjrqvSSPr3RTEql18IKOYdV4Xy1w2r//SE/T/9dnzBi2M42apqxncuWnz
mtd8tbEJFpNX5E9TFTLKCT7HWaljdI4v4Cw/YMPumvc+8bt+cnPr9xrWbLOam23KrqLEz/C51uHu
TGKd2+XAtd7LRixCsGZf9Y8s+dWflLlOuDdzW4yKHHtBqk2mdXtIEZzfvYWls4T5+48wm7AI9AE+
wvuQAqQTfm/TEhNWCwzWvVRgYx7Bc13IFx9jZU87ZWiMCvzXPuQdvHmwSqusUAddbcB9GqywgbY0
6/sU+9olFIPVJrttkRmMiM9MAS9hTMf9wJB3biALs9aZlaRPc01NJd07Jwj6j9je2Pm7oNIumMJd
UBcwOSvbYCf9lZUaWdEGO1AJVaOTedAUr5uyHR+pbst32dhjWQI56AFJqAKXxg0PegQ8TNw3Ks5q
cCeql5DoAeBeXLLnv8uOm6w7S5g2Cf4W9y6Ns4nqUMYlnr+zfJflzuy2z1laL5X4/i5Pw2QVeBar
oLISa+vaS7+9xbCUKrSBdDybEwRdHK9Ss1ouE+SLEnlt3DvVStM0ygW2f8me9Hu4COj0ykV6Ye95
TgsWladyrd0x7YimlLXHOojbl2zUczas25pxG2YqLoFoEoUb9tpMsQjuC5xhkTbqC4pQXvO+rEPf
+WDouKuXtjbrvQ3RAqUI60JYTYsB93tafMUBKt98ZRMw7p5YvL3ZrDnDD5RKcT394RqsfarsZKSE
2QOuprplEN4riLVu9/eoEg3umQbMV1jMKt1I17CI7RPdlK3i3SX5LN9waI3bI5AhMwnESTWKCBAK
vcW1Yut/6BVnOaB1+lIHhIeGCE+ivmFd+e24V8Gt/b4qT0jewTqwWclnMI6D5UbZyBX32+ytYfEr
eblT8cjLHfoG0wNQmfLykYcOqccONjfkaVQGuSVslsAyS2ASS3vEbMeMrSO/yzpXaGgxZq7NQ5Zm
YPmMles5/bYbNRMupoz1XKD4nvczI0QzFwdRo++uPB+s1q35nN2hhzPRr8SwtdZcW9dbLH9pJcsh
VMwhVgHhNkLi4sEj2Ch5OpDjm7xKljUY/1so8XHbbkNe3NtVyOvOwZSFD8XNN7X7xU296erc0/G6
KE9sthziZFWYpnvhrtGvppF0Wqlkdt6ZlaAtcRAdSEwBNoErQKjoq5YNg9lQc1fm4Cwu8ojyXNQU
M88qB0KvVkE52cH4U4/Xu805Bh/y3j6zd2FV9UzhAq5WveVZ1raKOZIhc4RpamGdQXKhy2EFULxa
XXsXyYvSkDs/zxQ0LECe3sPUDu5jUW8OmSesAh9kdehktQXNKwzM0PoQOQHEYqdWHfodPsoeEv2C
lSKwAawzOhOhCB0XzYX+KBMQpRc8rAAt8PVNT5i4i/foAxadGYLMEwzpEUik5ZiB1GkUG5aIT7NB
dQJ3+Ey6+JOf3nhtUQekXMalQkL2RNrl8XBTirw1MYBLuFWKwDxJji6vLPsv/PWOpd4lfzrXfLLB
mwnWnfE/YoZzec5H06bHD57FSiyij3f4MGCkMMNZgnARzxxmuZtw7RKsTTKNEyMSCxODZfl3FPAt
KrR6Wc8m2L364igWiFchmSmXpI0p8G0YeU1aLy8Xa2ebPIjJbT/VxG7FsrkLach9ROhEXjx4Ik9U
lkfIemRPHWRjUmbJEFyQoVGR1PCdQHwSiIXnTF9aQwwsn4eblAMiYywpxxK7DC9vpuNVuPu+vAaz
CcVFqBpdVlPu+Z0enw+e3B8Hrj5hs7C/h6t5tEwMb8P9z2MfJ2P3FfckUbsro9ZrAs2mcN3c3tyz
kbgS8RQ7NCZgWWKYgGU1l0f5k0kwsorys57Dt/yj5wyfYabhMav7eUl0IIxgSRecc58Wf5Q9GIsV
2FVYH9etWOiTzwXIken5Gm8tmIp5czWNmGmfdAf5eOzpBeS0cwmJ/QqssMzKtpdf6GA7KxJd3GZ1
QpYj6FI2zHNMS82yWCUfMR4VuOquF58UPNo6E2tNq0ZbptaOZa3Vu9KqQUYivvLSS7rbI9bKEsmH
hHIZYOZsr3ogm9tyfMuZfLBIffrazGUu99daXsIY0I2nHDM0EbK40SEv5yyN6Joe8FapLDAigUgR
3eIHOdF/Kdm9UX51Ivv7+mLCcdhZlbHaYaFtVHEL2ueMUlovavdHyCn+f+2iMldoJ3zFA/hMrIHT
rmKFQAFMXo0jktlh9Uqo/vPXl+Cu+BrYCatKrx1wQY+jrhj75KXg5HJ31jbatu5QA45mhSb5ZbFT
wVt+Rey0UANuJDE82Ss22ahbEAorgLE19KQDsZPhp0K1ZGxW/meDuo7aIrsTZcoTwaRojrllXop6
9D23lrSqnzVXortDjiu4pLx/ecm+nFwUY5AEQZ/mX3UCPrhapO488V8GAR1QPErLfbnG2hrbX72R
Kwaj4LfJlUqkFCxxyjPE8iZT1B4jF9xbpZMG4umGFKSOFl4s1+q9h45p999wtQ7LktTJ56w2BVhc
LS9QlsSFV75Opk/33he8iO3QuKjCxbQgaJwriREDoNcGj9GcIAb4UqpJ7pgMwOOlfaDRxDoyXdcH
61d/ZPz/viXz482ke5bMwbkVEqOTFXMxdWN7kT0StGRBzAv7c+6+ueJbmj2sskFsJRgGn3PJzImu
mwWzlHQUW5CPj7+cJG6TdjGOI7rsFIMDGNIiftHStoV90iXHWj/eO5YBihuJAzrKEw+ICJudN+FV
eDG6ely7nMYXIEwtHKXd1C8jmKMzYeXLGHaxWLvLZ8IeZ32BZjDPbZsAuU4L8wCy3749xDZi2D7N
L3PhWZvkeQcMA3u9YPxifdlWEd8JAm+I2pZyKYwChpRPIEc8KA0SfI5uBl5t3PgJdYPpQwwKACGu
HnC86SVK8jw7qVMekxUXYDKGcK/DeK6ceaxaVwn8iGkd1Fu//VENBMHb7PNXCDrD/wd8IzpGcMTO
tc5d8taV7kH9k021o5rzpr7NbvtZPn7qEtA5Nq3KVmXSq2ByzoGets5tX1EBj9D1CU4rOXl+LrMi
mZLeuag+l0v4F+2V3JEtlpfT5O3ivpJtSBgxK754N+L+dts76rsABAEN+nK1YrBuj0qxJXrlYbKP
8m1LecEUtzjkqmJb7+UdLuHcEODs7yH1xGHzwZHsoGIRY6SNpm++79ZLhkxJd1zMwa3v5bLT1+xt
rJ6w9Ne2pBbbZri7o7m7I1PDk57Td4P2DzIMdrTErOdLckuI03ZzhsUmtV4AmbmOv+Yg0pgLAuF5
lrnj4n3G3H2RuYD4Pt7KA+pF2QVOuEodbOSO+efk+rzO1jo5r1mSxBLyOpPfLxujeBDohzl9hUnb
ezLbrb9qcfb0vbjjwHht+rZZke/o4xLElEE+S3FionU++LAdDF+2E3q7EorMc+7nqDZHL+xFIYH7
wNqeeKoIP+YysM3xXJwyAz2bgVm9eBnzwfUM/O840Hq7eaGALafdmPIHw7o62aeljs5i8Dd07wq/
yF0v0vWUUFym46xQ/LqiP3Mz9oGvS1yqxGoMNXkeqsDyvVMRQjiSe1yKUM5vCgf1K0mrd2lq1ZAX
GlttuQuyPTOW/ab7co8r/Asvpz73JBaq5PrFZfGoLlgTj2OM4tGx/gdTZJQlnLuSlEpSZG9Q3mdN
uat6Bc1trelsl7HR7E2KVB4lohyWeoS1UONXXP8wJmHRJtc/RoWKu8sI7cRpr460konPo8sLk6yk
8isMxxZLDriJ5HHDNtXiA8Tj1dlZVuYoux1Asc3u13m+JRUDfggM4gBkU4lJ8HkW0MM9YJbAMo/1
ayyn4mm1ZNS6ptHfzFTGN1+BJ3f1A40EhwaluyVE6A32thpyB9S+TuYaHf7aKXuttb3+/n9d/duV
wW+5OhgDIK6V0uXqd+W6T/b6cGUXVZovStNFA00aiM3/uPqn6z+DwfCf88wcRl+ANbScHu741Cv7
UmuG/Ud4YpPxcAWTu4qbm0VGJvkccfOHX7m4b6HZIXRY3B8Bv4ox+bzb47TKNApPTGsrAsjKRNus
rDBFo+DU7W3St1GNwcRyZhgcyy7RMGkfVxmbsO/k5MP6jdirb/jC1PT8C7ln+CIkvhVv7L4YQc7s
i6gO5ov5ejGuUmmp1i3tYlMaOs28aslfGOX2xXeOIcB5A3E3dVU9yefP8HBdt3XXWn75GHIBx9X8
8MbhBNZq5cId2gE/M+QazNwu2Djki3EKn11WFj+721EyA/6x6BSNtDLHHMVyr5TneckKfELS+yyX
FMGNYi7QW4UvmHd1P7kJ+KIdvr10Y5A9anPspHpvL3TSovgcMXXoXqp0XChkmsDdtPxABgwAvhow
t8mANHieozpQ0spP38vK0olOxhRlvV/dtWvtg/yuPsjjeTDoQ1gMMBbXm7W3NoAI1usO1reZyIHP
8FbIAfHKwF2LanNQ4XaZot/T7nrqC+Q/zq+LRK0M13EPHmKg+JAHipVKrG5HYM/352yakgEo5s85
GJcUQK38Of9AJo42NRPnNpmYBk/zZw28PtpxHiAt/l24w5VeUlv+S7sK2oWeI6hWuDd0vwzg3MRG
sYVSTfNp0vHLZgY9KqwjbWjM4FzP1DoYIR/QRkUxISg/kME9Jjlk8NwuRq6D5xk8RDwO8jpTgo4N
cIaehpc24WSYZwRZUBueaBgE2aLV2UkBqfaHkBQU1R8lBTpYLyYF5YdiQtBdi02lTSakwdNc1eis
yNefFXSEgBaPNFe0uU3EkSGf4rBRIcqRw2bdzs4KSMH3TQvWyYDK32lw908GgICFS0NuschRMmBy
JBaSgfIDWdaoxk5KmyxLg+f5cdL4JYaLkoEuHAjqVHdB19cDLvQkQcP+vrmAUA1gy+G8VZ+U+eas
+iaYJKz6JmBuIqz65QeqSSndKEdpk2Vp8Lw6j8sHKF7nqt+xIU4fOk7fcm2OeUYQtQmi/pBaFa3O
XvVJtRcFUUgAwl4F59Xp9b+a44713+Lx58u8tlihJADMa+F3XROAldeWH8iavrOo0iZr0uBpXuuW
/IezXn8C0BEi2uQ62tQiLkc+w3edC2smtvLdotuSAMzzXVLwD6UucE0HIXUlx7gHAOthVsUZ2waQ
cZchVKgthQGDt6BL7RGtaIC/0ROiJkewajnzsTTElCG18mbc8Lm9ZMoerLRrgM99ch1jyhi6UfBm
/Gj6cf1ouDGBhhhz5qNpjCljiFpQ5iU+Wre0jD0aZ/ml+q5jVgqvnFN+dCOk/NFBpUsVXsesFA75
aRo+uv64erSBSV4Vbs58dB1jypiagNhl/Gj6cf3o4OKlCq9jVgrH/cvho+uPq0dbCCik8CWd+eg6
xpQxZDmc5wYysjzPa5jMG1N4VdoetE7hflsmWNB8UZoGFETbg6U5cXtQRzyWvV3PPspb3Ab3tT++
8ftoXLL4cV2zX1xYArv4Me/pFrzsV+tXAwO4km64sFnAMIgz1q4QMo+ssFYrF57wwy/tXh83apwt
lmHLWt6zwavSFlrBlUKouHKzgCkDGa4LDs9LG0u0zdPtdd8/3ClxvAbhcAUPMhVOaRcQDNoUPPh1
MoYH+F031HdMCpTIpy4RtosYXLopIunC50TfKathns6alz3yHkn2GmnvigC46BqA3CYAZfA8AGVr
pbtIPvgPIcnl70a0mfqwTd+H/eLbN/id1/Il6frzY3FKdzgAzRvVoOU2QWMwp0BLeDxmYJq8DVMi
LWf3bEIL2zBFfq1UC0qlTfKXwdPkrzsEsm3e6mZ4pzeBFitMZdXq6jvNOu+I1umIEJ2LHZ1rCwhH
OgWdy2+/yuYpGdVRYC2FbyGyUkW8AABq0wDkNgEog+cBoHr5y0fXE8W0DuiAHw9eGrjcJnAM6BRw
Kf8R6G6dx6tQ28VAkZzvIrm2MnPxZohkFjWcziUNPoq0pe4sRFoqSGf5zeJaOCptkj9ss4yXlJ/K
1fJ0ftJn69M2W5/eHWrfEidzx4PYUujYUgtPHOcUbN7jSSzZOKXKfRRrDZvjQpWbALjQolFpE4Ay
eB6AtF7HX12s7YgAndctVJU2oWNIZ6Cz4HpmlKWUCvBRrC3lRiHWUh2yAIixmye3CUAZPA8AVSnv
G2vFPYomO+BIphsitwkHwzQFB8wTzqBg2vOw2sVAkeLSRepJHxdvikj4B2PjwDdKnbXEVeYEpZxX
4qpQZy0A4P9b7CntIjQNngagVgHlqfv4HimsHFc7HsTmTcfmWyjiOKdgs/jXfEfUtN66HCqGteXC
giLKzwqKZ1BdHDEqN6IA23IjXltXY+58hCaOcFRuHDy3/rh6cCkdFnWc++Q6Rh2XG0ePph/Xj86l
wwx6VW6889E0Rh2XGwePrj+uHl1Kh5fpu45Rx+XG0aPpx/Wjc+nwMoXXMeq43Dh4dP1x9ehSOiwK
N2c+uo5Rx+XG0aPpx/WjQ+FJlyi8jlHH5cbBo+uPq0eX0mFW+KrceNej6xjFy41nxAhwNqEYiVel
YiQuCVSMxCZV6jD/e1EHxsnFyIAvtxxVIz+dXI0kYEk3YNgsaBjGidXIhmsV87/rxUUqIhZxcrPI
kDtwceYUEZmep1cRCxyqzWU8pV1QMGwzq4hdwVIZsYrkUxcJ20UOLt7MMuLI6L1kiOUz55pMuU0y
5T4TZSqVQWb3ASUqRzHoL2R8+73EXh/zhEuZvVkz3odyzbABxdPtleC/oDaBZgqYUzOM+7vs0OqD
tQxYRCptEin3mSdSLQMODPFkeh2wwnOxw3MtdnOoM+uAI5X3ml8t7ZFMuU0y5T4TZaLS3oSYd1Zt
j9CVgllBl9uEjiGdWdvrGpeKe1Um57tMri10XL6Jxb2hE4S+CBulWygobRIpbNfhOfW6wbzDU9Bi
BHwkBcAHdwfAR3KpqCFF1D501L5FGK6BKaiDvTP96FW7WpwjmXKbZMp9JsqUNqvjq4uAHVKtzhG8
3CZ4DOrM6txQ5a0SVwtuJFNuk0y5z0SZqOB27wg4rrgRkFLGKkBym4AwUDMrbl25UsmtyhSXLlPP
prh8M0tuI4P38lqtohWZSrvIUfrMk6lW0QZz7CmPVX2rVyijPWk/P7ujjFbBedPB+RY0ONCZZTRZ
4ZnnKuUEnotXJZ6L/PdQOWCodFBBzvCiDvSTea7z+SvBG577mcRzGaX95Cbgpxncmub2jiLhrbAO
V6GCfVGaBRYDO4PwRpON0wBeev6mGGl7/gavSudvCjDilKHSy4KGBvpJblepMzPddOpc4FQ+Gho3
LSgYtpnUuZvqsUCdq0iFLodGnYscXLyZ1Fl2n1IhzpP7+AhOdhzpCA4hIG4ZGs8kBDR4GoJCtJmX
nEO0xV3ih0Ka+Q7fWR7zbMJM3Do0nk2YGf6JPHtgtHw4p0Tko8M5ZbYLh3MKgEpVQ6OtBIAGzwJQ
WfnAapwd8JxTtiXvcYqhu7b8aL3YBjW3CzwOew5Dj3imf2CsshtxFIMLJReCcOXqofF5QpDbhIAG
T0NAfH5CID6LzxM64sih8WVCx5DO5PPdPo8EPl9lKhw+ND5PMjH5JvL5gctQYHHSaR0hKFdmHxr7
LwBKmwDQ4GkAiP1fGJUfS3P9LSEqr4qjY/JfQfvQQfsWyLgCZpJ/2WzlHM9RWDYsAAjneAgB8efQ
uDQhoMHTEKRNNvB6wnKHh1DD0qGGNq047Cks0uTvoo+MlU/1HIXlUicQwnItIIRWZCAEuU0IaPA0
BFRkuHdYHhcZCAgR99BIPAFhoGYWGbopnglFhipT7O6ReibJ5ZtZZJDdw1IUcdLBnhKChYM9BYF1
sUWj0i5S18GzENSSxBlzeTVtn7XJup7ux0H40anUuEPFNylN41ilTbCZCqbAdssa9oYPn9yyXxZ6
tVApVsrAq6WUoValDDT2oVJ6V9k99n7RB84tZVjTPiMplzI+nVrKKAhDBUuljAKLgZ1YymgApb37
Ig4xc1dJepEhd+DizClAMIVPL0AUOJXVu8bwCwqGbWYBoitYKkBUkXzqImG7yMHFm1mAGBm91xoO
jUa7RqlJptxnokylpMDsziPno0t2rp4IcfPZqeS14zy0MoJrJQXCzPBPLCkMzdCqB4fGkF1jyyRS
7jNPpFokGNiBL09PphcJCCoVBlwrEhR4HPbMIsFI/b0ecGgE2DUyTDLlPhNlIto/IfydRfsJHVFp
12g1oWNIZ9L+rvEnAu2vMjnfZcI2ycTkm0j7h07QGP6hcVfXeCyJlPtMFImI/GAOjoj8A2mXS8oh
n53KITvQQyPvrhF5SrSYAmYS+ZEhOmc/NF7qGkclmXKfiTKlzTr5eoJhh3dodNw1ak5QGeyZ1Hyo
/sbCD42LusZLSabcZ6JMRLbvHQzHZJuAEIF1jcwSEAZqJtnuyn0okO0qU+wGTz3H4vLNJNsjg3de
fWh80TXuWOQofebJVOnzhYGPHeCUX3s7f2OpIz00xuwaeybUTAMz2bNsCZ3fEkj6eKs/X5W2+lG0
A+eJPr/akern96k5kx+bBdOWLT/+yava6i8IGSkOHRYDO5EfN4AXbvWTkTZb/fmqtNVfgDEKik1C
QwPNJLerTJuZbjrTLnA4fc1tQsGwzWTa3VSPBKZdReLs2qcqBxdvJtOW3Sdv9ZfJfbTVXxxH2uon
BJyLY7sioMHTEBRezryEh+Rng5D8VEqHpBOlD09F5I7zsObi2K6YGf6JvHxgNNzqp4i83eqn2S5s
9RcAnMLmdgVAg2cBqCx+YLXHr2ZLqaM7rIk7tgkdRz2TxMu2yjv9xyE4s3YpBnc6f1jTfGxXBDR4
GgKi/BPi8FmUn9Bxml9egizoGNKZlL/b55lA+atMnOZDu8rE5JtI+QcuQ3FFCzv9Ukzu5B8AgPIb
AGxXADR4GgAqEAym97pYqm3Cvxq19oQm6GFF5HO7Cs0ATBEa8tu0FlqsWHBWLW17PbijZFER8TKF
b5GVo5tZspAdKZ89OF4nDAtJwtkDQsCLGtiuCGjwNARpk568lnWioztsahqhzXOOemZ9Y2ArPHpw
vE7kgoa0TvRKx2FdAcF2RUCDpyGgasi914lxNYSA8AoItisQBmpmNaSb4oFQDaky8QpIz2y5fDOr
IbJ7WAoiWjh6QGuCcPSgIFjVS7BNUtfBsxDU2snpqbyatQ/PPZP79FQE7kAP63IJtitopoCZpZMR
Oz918ECFuAiFFbwqFFayqQ+1wKBrrQG/hvGiDlSTCyuQyIfjdyh++ooKK4QwVLBUWCmwGNiJhZUG
UDh4QOJQnUDXkkGRIXfg4swphzCFzy6HEJxaY9Ct3lBQMGwzyyFdwU+OyyFNJJ+6SNgucnDxZpZD
RkbvlY9DI/W6EXySKfeZKFMpcDC787j5cBA3+37Po7sLHCcPbHWch1bU0K3AQZgZ/okFjqEZWi3j
0Ai7buSdRMp95olUSxYDOzx6hSWLipTKFLqVLAo6jnpmyWKk/V6dODQ6rhs1J5lyn4kyURFiQvQ7
pwhR0RGx143kEzqGdGYRomv84XERosnkfJcJ2yQTk29iEWLoBK3ecGi8VTcOSyLlPhNForLCYAo+
Gcy2fniV9Tjx+RT5RdsO9NCIu24knvIspoCZJH5kiM7XD42U6kZQSabcZ6JMabNMvpZY2NEdGhXX
jZYTUoZ6Ji0far8x8EPjobpxUpIp95koExHte8fCIdGuQIi86kZkCQgDNZNod+U+PSbaTabYDZ56
hsXlm0m0RwbvnPrQ2KJuzLHIUfrMk6lS59PTbRD33uGB7U7q/O33Y+5cURNf1o07E2qmgZncWbZE
ZsceFs1jdoxXJXaMrPlQWeJSCaP3qbLj0pzJjhez18fH8n/2qthxQRgqWGLHBRYDO5EdN4CXHjso
RtoeO8CrwrEDAkYEtP4ZDEJDA9Mkt6s8m5luOs8ucCp5bX9Eg1AwbDN5djfVM4FnV5EKt14azy5y
cPFm8mzZfcqxgzy5j48dZMcRjh1UBMREl8ZKCQENnoagsHLmJYNvuwxCMovDJ95llVPRjvPQmPjS
WDlhZvgnsvKB0fKxgxKRj44dlNl+fOyAAFQGuzQ2SwBo8CwAlcMPrPbsVXJ4Qkq8fWkcvqDjqGdy
eNlW5djBUQgupF2IwZXNL43xE4LcJgQ0eBoCYvwT4vBZjJ/QEYtuf22jomNIZzL+bp8HAuOvMhWW
vzTGTzIx+SYy/oHLUFyJ0rEDISZX7r+0+kABUNoEgAZPA0D1gcH0Pl0qPfGO1urncX2ggvahg/Yt
jnEFzKwPyGYrm/xHUdmwAHC8yV8REJdeGq8mBDR4GoK0SQZeS1Tu6A6tgrC0agIhZahnVhMGtsqb
/EdRuZQPhKhc6woZQWTeFpm30eBpCKj2cFlUlgsOvq3/Jvmu/9wm6RmSOQUHu2Yt32zeZxcdpQkH
3HdZWigubRKUCT2nCuHGodhSNInSbn8Jxce7/RWA9o3+lnYRug6eBaCWLDqCH23KKL7LRIWDpRUR
qkx+rkxwxa6tPzoe/FjK06WS8clvznRwh1YtWVrlhIAy0DMrJyNyfvLUASYZx3UVvCrVVdDlDrW+
EGupwblQ6yqlObGuomLCPH5bV/n5q6qrFIShgqW6SoHFwM6rq3SA0qmDIg6VCern/EmG3IGLM6Ua
whU+vRpS4NQSQ/tbAISCYZtYDWEKfihUQ6pIPnWRsF3k4OJNrIYMjd4LH4fG72Pj+iRT7jNRplzf
4HYffihm/dGY+oVo8Wym+Fei2Otxg08fNMyI34aO3zbf4LqYQtAWuy+V/oFNWl3j0Mh7bESeZMp9
JspUyhcjozx4leULQkoli9jKFwUdRz2xfDHUfq9UHBo1b9/1rzLlPhNlKgWJGaHwrIIEoSOS3/5C
QEXHkE4sSDCNPxUKElUm57tM2CaZmHzzChJjJ2i1h0Nj1e37/VWk3GeiSKXEMJqCo7rvW+L3s6SE
8gGvC49rDBW1Dx21b8GGa2BijWFoiV5OODTOHBt/Jplyn4kypc2i+VqCYUd3aJWC2KoGhJShnlg1
GGu/FQgOjTHHxp5JptxnokylDnBhMBzXAUh6otGxUWqSniGZWAfg0m8ymnEhoEhayX9shQCSlEk9
rxAwNH3n/IfGImNjlEWM0meeSETtRxNvVGV9IFVZxXepVn+3ecypCTXx6Ng4NaFmGpjIqQeWyKzZ
WiuwZrwqsWZcN4FTel2aL0rTWldZc2nOZM3B749J82fn8+OXItIN6eGK0uL85wGwWZAy/DOIdMrF
nob50vMJxWzb8wl4VTqfUHARVa1/JYDA0EA3yRErI+/GnE7IC5rKcttfGCAQDNpMQt4M9UDg41Wi
wsF94+NFDC7dTD4u+k45nJDn+vHhhOw10uEEAkAk1TfCSgBo8DQAhbx3Fxlx97dE6s5qnuLeWKfu
/TMKcrLaAR8aW/eNuRN4poiZzF22HkUZK51SKHNeOKVQAOS/nkMASpsAsCA2k+afNt8wiRVy33P6
ivS/oT7QuYGqgdAmHdfGFA34gH9VSDZhfbCVDi8IAbrWATIAazuA3CYANHgaAKoVvJog3VEgF8dw
RIhcCU1ug25OfcBsELGy3cBzmmgoZlRdzNgmPBd5TsnA7kdzX1OgsdIRBiFy19qBb0y7yF/aJD8N
niY/1RdOz3357/KJm+XPpNDdI/voLINvkc9o1aZNaVOeyjQxBX1cMi8TzWcoyFjpKIMQuk0LVkjV
k20AcpsAsCA2syjxZoTujvpAhwtIA7lNGmDamEJYbd50HJiQHmylEw5C6K5VC98qGwQgdr+rg6cB
oMrGRaF7XNgg4aks4FuJgISPcydQLWysovSpgmKT7dBKGb6VNUhOJvPEsoboJJaCipWON5QwLRxv
IPmJ9bc/IkAy18Gz5K81EHmen64Cn3gn9+mpmd1xHlrVw7cKCGFm+GdWQGRGXW+t80M1/hEMfF+H
uHNeeDW+RtyvqVSu2bypUlmUTkc9lbb1nrxrcOG4awiO7pr6VZidx11hNXHHAmif3HHXkJe8jQCw
HpmjrkZbVQVI/WrAl5S2XUMuDGwEgLY+6mpV5odZANeunlELUtcJ99E2pSDncAdBYVE5+272Rh2j
t7v9jdsvuv8bw4feQ5LmzO7vc9EoeJ/QaeNeG7+E3Y9vwC0cDA6QZ0Dsd0ZjRFyA1Icl6jIx1OIi
pLNf3dxCFrl4FXfPWRdwdwWczcMz2FV8tAEhIK/hA5/muKtCdPRoWFM8H/cApIgKJvzuA7jv3i9+
wfvegkODH6rdHwCacca63fv5rirAhOyDHkJPtw8h7jx0dNoujo+mx3sTOfLf5Qmb7Ao5TOc9tILh
MmeZFPop1+c/3tz6vU5eJbgBznTIgxYbvYEIeKt1/qsl/5rrdqDhrAYmO4PZYTDhuhysJzbN3jur
5d8ZDsFqUYXd729uwz5ZlYygCQdO8ODG7g3AULtf3NyCH5rFOCZh1xnDwjTF7S8LJnuhw/uqqEHD
HdlzEaTYVbQlVyz6ArjzShQm9x71AnMHbHlyFgk3FSaROm8Sod9oA0a1MNOzu2xmE/j1EvSdkylr
EIcFmCKw/ChQSwyY5HRhmdbeRQsYs2j+qA+BYwSw5u7vUGoDLuLc7kscBEsfNL+9QXdQEQJo7/vF
za3DijRvsXv+EuQA/HDxLRQZFlGYlixu/QYxpWRt4pP1C+wQMKTyvk/AL21Qi+IPECfRb+EiqGLx
J00p36k71alYMTJEg9Jv9VtoGatMC5ueScwnzcqMCEQFhXbMfmI9fsyZ/GRlUQMGiXwwUx13qB30
BD1Ah6+yaylny7rhYBWPA+Uw3+M+DRm0VXutFMp2a4EGKljsMEJBKp5FZLdj92CRg8+F34OFoYMO
u78F/4KwA27xBKelCxXbFgW/68DsVa/dFOfHj+6/69lHBpQnHyheeZhePorrcpVntXaB9XQKnjuU
y7fRZuERh4mxeThJ/Dl2gGwOgiuPOM37hPU7uJN+/jMUy8LsXS3Z7aYrqVpIFNzzg+LFDpZy74Rw
1xfK1cxqt+RrexvUIw974lqRx+ZusouTnQ25e0XFyyxGPs1BRCcX1hOpxQMWZWRfqJ5yViqGtzUK
Zu0vbipYtnaydZbf4gy/q9gHftfMYaSQTGtDjLu/KT1VDKvoVx80Cn9NWY7WRjBL9RUmxy1iCs4s
ahOIMreBMSYkSJUBd6SG1xE8+Mz9WCPm4B4pLJ64yhn4uy1sQkDCGZIVcI0KTMYFDBAKcq0A9uxd
30d3NcGnVfM32FQuGbX7CG8FigEf+RATTIhoTu0+Bm0p4Kl5ITZ7C2Yz6Hr5PXv4/d0bjwqHpwBp
jbtfofHBNibBTRzqHsLRexhggZRY/rhPcFnXGlaBX2O0g3iTuAifgDkjWAbDq0VviR7vmCDZXgxT
95KWBRQNatZqSQb1DcFwMeHe+lYR2DrTd/nu+ooewZKucO+evIMteauI5gJcVgmlXT8JJPE2leHs
s+6vwHn0EpEOXOg9eflf1L29pxq+OI8F1gCzRuGnMmDp/Qwsa3KAuv0MfcCH4lwa6QHEf3anL3A9
hvCf0yRc5ZPVdvBU1txn94VYErsbZSeDCKmxI6w/0cNdf3UDKN3ev1qHMkHlMu/Go8rzzi+yCPQc
T9qVqlezbsDEJTrMAnpM5oHu9gZC994Vp+SFm4CN4pJ/JXm8ru4eYTqDVwBj+RQ5W/Aw77FyZTAG
8AQOowfm9NCGBYB3SXRdLZZHXt69nDSxwdp2ufRuEf8nuKgZWGncauDH2dVMcrhQsCwuJ4uQKu0z
S84vTmQ42fVg7iausc6r2MrxvCcpjBCLBGHVbPiKECu1R3V9a0Zav8VfUxFzvdxXkVhKy43MekhC
KQ66r4cddE0Cq8j4LtT11//z6usvv2F5j5jDiIv38zOS27sZDaXe3vhBMspSHFJKKm8LNKXIaZqU
fvljoyHyM6hqVeoMpgqjV0SVZ55IVDFFZ0uPuYGZBSpSRz6WNG7GtrQXpgesCiHnPBDYIBa+plae
gUWY2+JRJNAF49dxMC48YuWI+h3EVI+vpx2unFqo/aK0nTXl43eutVvjP67+6cvrP199dw1rUInK
HreYsCdQVYjC+Oh0/Yf/pKI6/A7j6kPyLXLTplAfUZr13+0BPpTArozP97eJbq9Vvf0fr/4vngG8
+mVuZHN0cmVhbQplbmRvYmoKNiAwIG9iagoxMTczMgplbmRvYmoKMjcgMCBvYmoKPDwvTGVuZ3Ro
IDI4IDAgUi9GaWx0ZXIgL0ZsYXRlRGVjb2RlPj4Kc3RyZWFtCnic7Vxbr9y2EYZ9bCeVDfcksR2g
DWA1KGKtkaV5v7RNH4q2KYL0wekB+uD0KU0cFHYKuw/9+52hLhytKK32rHbPujgOYtBaihwO5/LN
DMU3JWdClhz/axvfvS6efePKl/8p3pTKBx8fCu9FaZUvpTC67uLLP/67eF7Ed8u3L4s3hWcK/8QH
tP3d6/IPF/BGKIVgXJcXPxSiHrXUnBlbOm2Y9eXF66K6sbr4F3SV0Fe3fbVG2tbKMwmd/lm8gF4K
fpTKVTdXa8uM0CZUZ/BQ8aBtdQtagnNf3V5JxpXUsrqz4kw5oaWHfmvD4F1jyCvvrdaKOSmtrN5f
rSXzCga/vRJAnwu6+tlqzVngxgrsKpEiLf5x8VUBj6Uu679PjLRIEz81qmpWnQy/1pIzL6ytvv0p
DUtmuNuRd7YC6fXGmuoekGK4F5SoNNO3b1drAdJvtKOk0Mf3cChuTJ/Adqge/YY5oZTokddrk2E7
Xt1fOVih14GM/3NcdvNS1zG3EjL9Ob4juFZKk66JJR+svAf+G40bGwSTVBGuGbonQ6n+XjNzT2Zu
mp1rhu7J0OjOWxctZWxFYW1dOPH2a7Dp0YULy5SknYQqAws2unmJXS6+Li6evgCqwCwHLblcurkG
qgDDTHcVISDb14FZJwww04BjksDKByvBgnZSVx+i61HOBl89gkE18xbe/xhZHTTw9SG8o7SwvnqC
PYUJsK1p+mfAX2sCd2Twj+BXYIJzlrz9wQpcp/Bc03HI5By9puI2Or5uYzqcBbMgT4HfTwbsRl2A
n+7XP4nuJ886u3MPBUoI5031OSwdSFKgLoJpx52q1igwziguJEwATWWUVdWfV2vHoEUbGtcowsQj
I93mr9zJLWPsML42au8xZnTnQZrliIaNPTjRKDRKwOYL0277YvQfnvr+Iy18yPTjauQVz7jUoFA3
GtUhCrJWEoIY4MlaumiZwGrdbaxW0hWwvLLlWlKM+2AGpFEgCTcA+wIwEmIwfq2Atcm8PxiX6OAz
tNCCW7DFVOE+WWnr4R/DgWHuZlwxGFdjvNUM/NvoBAz4jXEqA/OziPwwEikQYH8OZgwcrfC2kmjG
UPUIb877VgMNohJg/a5arpSdGsEHc4rKAGQffML0KFoKqVgIMy3FUXW5m2FSqb1nxkSljkL9LCPU
0mfcn1mtwRF76agso9OT0PSSaulZjaOMD3JCs6RlrlFF0JOhXUl6ivjNwyoBoQEVgKEkBLqAGwC3
bdiEvZ3wVUs0l8o3v3HtovufSwW8GsSUvYUAtTVldwb8BoulZGbbzxPziQSQDojIVaR7anJpWCNU
8O7m3JbpTuLyk5CnxNAiXmSWo0aMCsGxtnzeoFZDVOF8xmUl9mcZZIc+FlE3JpVkowLSagdKv9xC
LwUaACAzIzvzAkHEcDHBZlw72cy9BC1OXzMS3pgyK7/BaXgA55xa54m/hKA5gnZZri9kWpZA91fg
45fC91Mj1PjeIVo4gtdexsn3lXB6lEl3b0zr7lsMPx/GCuZlMD6PYmOszoX3e4EAsIet7d8CRe5E
VG0cGAUG9MCS6aMHQIM23ltHlJkYD/I7sS776vU1Aj8AAo/qyv18dT05AD5XN61j1iUo/n7GVXo9
dPzUEaanLGJG0LOEjIk2Evmn6H2OWu4Z9nYqej6qbWNUqFDXZGm+lCBWQD85IEEsk8XUotTcvGtB
wkGISSEC5hw8F4Ka7rHmeDgRsGY9EU9IsjlCM2utIJKR4oq8PG/PkpyKC19qwklbAfjF+85U3MwA
247dXaKa+L88tydgtOhQ+hFg9OVzYNcw+nIw2ge3+6QtkLbqBIH0niNMg2gNRouC6GMU6O5i+c1b
YzUpkZHCVyqMfRrfsUIG0jNV4khZLb0zUp4DPfRSN3VWxSTCiE8RO4DRVoY2H0TPLrjoUwfioaWR
/QqdYU4LsAV1gQ5t2NfRrDw5heB8QSFdeJqNeOC0TdBIPLAV6e8SmF9tpLNXHN/9NijyzjFAEgJe
925E8SoDFlSmREhzzESFCRn5/O9EuCASIL2VoYL7DH/OiVF5EO0orFXNnJCz42Gkq0lJXHX3ZUbY
wSZdesKsMdsnrTcrLtBGRjjWBgbXZiFnFkynpsNyBLULUSWDCQBqHiP6CoorGjthIItYSeuRMtQE
FborgJ2MrdhfF/9/TMQgmDrslK21UNmTBDvbiJk4QhvLTEjWYu5xHiJoSRmSdN7J5uGJcqaXdq7n
aZNOCR2lcrwlHTYjM6a6XEx1O1fScEZ0JlmgHXbWGgo+Rs8KHUavF9W3racQVGBaN0I/O+VNxGpr
UWfx1NKlu49W+4VOQq0zLHD0JAZ0xu8zuqxeP5UHMyhjVPV7bEqQpDB2GuDoUjEZKU+GO04yZY+c
biEnn8/QOkiOCfJH8UC5kGAoHuJBY8etESS3cowDzaAlTwZKoogRIXufSqOLHNHyDOgMjaSeTSor
GTyvoh/FjJI1wLXTQSsLpmBGtd2Kroy9Fw9NVluE78xFHlnazkN2JoTMQ5zihDmddbboncqtHRVz
Tlo7qVw6LjUdGlxqA4kB+AJND7fS0a4T2Et1aHCX+msChn2YBaZQYY76NED/VUcZxyF5v8zHRnZD
agiOly/9XKoWlYl4ul/z555dG/qcfAp1azU9c6qDKHx7/COfPiEdyUgT0YxntsWq2+JFckJr3R5G
uRepAPY5wCk6QDuEIdDg3SQ9rHfW7mSaMSA0nIs5Rr8RkWLWoTOaKM4Hlb3kUNqXLpbbD+qcnD25
yhFIXmYXkzFv0joho2GrqIGbTKZ40Tu+teWoMxWlFqXnjz9vx+5YDxJhKNWauuT91SiGNlycrofb
Ab2f6OnJ7S57oVzjqO8+2GL3+xQRHDZ4RN1q10gxZaHdqD+9HXlh/49wp8/1Lr8JC3yCu7gQbhdQ
RwLhGWMt7wKO5Oi2VPod5nYOmfvKJazw4hllgqh+Db4HYjQjaXIq5a7SoZ/0LHu8iOTNPsYVe6Nc
9lt94pKkxSOOzQUIXwLJRjgbLIla/1JDafgTNttIggY/ObcLD0E6Lbb2D5OzTgwPK/Y7v6tgqdoh
f4nrp4WWFhncrm+tCMB0Wkeh1dMsjBh8P2kAVI1VVHMxQxtcZEe/hVstwcY3CQZAFLwfANE8Qe6c
6nZkTfIW3THmL+pzZSF9UfqCktXSfK/OQDqQxMerdka6kG7A9P36LdgRxbnuVYSzhYk8WMsTnGFo
Wm4+btvKRTJ8dqy7OdkaiwbHBcYPOBbLKxuhsdVej3zSNydK7laSYm+S5I4jGNhuQ074E0aT8+ap
vgZqEoVEKlLwT0tJSnYfhRhgesjJhmvhiRHxZgB8qlOCrP5XbcHyEWmah0SDubwCVWuiV6kD5Vh2
bwkBxFy0TdiU7dFtvZdB2o1xm5rU6LoyMksmo0vrV4HxTY/lrCTBZI4dDUkrt9sMSdbo9qxL63+G
S3OqX1g+72n2Gm8B5JJmi3p8jAKpeHd1UC9KzGgeXXRalUY1C8rooWpG+h+CrXMwZPW7eCdS0MKY
6inSaWC/QDNWaNmEV1Kmvp/Fm+VkoC1C+68QJ3ADD28izwE7gAq+h2NK4GksbeE1CVr33voMO4DX
tZL2nWWOGk3J2W3CijO8KcrHb+g37cUsczbqyeYIoJa6kUCpnNolSUQmpp4HIKPTDjbjcS0pRhP/
NuKDul0fLu+cJOiy+qUiSHVOhJGEB55hwgnqayhhDzM1ASO7+5YURHCAZFW8iwlpTqKU5k8Lzhf5
8wc4CLoZrffPjjwvC+QPEUK0V0Ds9pHW/s3jzlZ7Ytd9qv/ipKk9MGVjfdP1RHm/tss9ZLsWLK8s
mI6SIQyektrxm4CNuPpPF8Xz4k3BS7C1vnxdGIi26varum28NtCWxnTtrvFj8fen5U/FmxLCo3hT
rwy6FDA8dAjN/b9K1BcAPy/ApnrngyiHjbcvC6V8acD4lBBrxf/ffl/88LSATTTlfwtf/rUQ5VfN
NcLffAnd3aD732AhmovSOMlhKVq7uvmqblp45VXdoW4C+UD9DjcTC5e5mthjBsI6E23766L6BZr7
yFZkbEcE0ANAuKUHmw09ibRF6DEKa0SEnhuEHmSyAo5vMBmZufm4ZaYKsLc1M2OzphjQg2yY2TQX
ZCZ4t+g7gfhHA2a29AAHW3qw2dCTSFuQmYSeTWZK62SGmfA4K5kSmVwzMzZfNc16HbFDbC7ITExp
4w2OQPwvB8xs6QEOtvTEZrfPS9JTM5PQ02MmmBqhhpKZeYzMBLuN/4ySwEPdfFU3ddz+2EEvKJkK
D5gIx1tJ+KTPzJaIenNberCpG00Jy9ITMD4n9FBmPi/+ByTHE8RlbmRzdHJlYW0KZW5kb2JqCjI4
IDAgb2JqCjMyNTAKZW5kb2JqCjQgMCBvYmoKPDwvVHlwZS9QYWdlL01lZGlhQm94IFswIDAgNjEy
IDc5Ml0KL1JvdGF0ZSAwL1BhcmVudCAzIDAgUgovUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGIC9J
bWFnZUMgL0ltYWdlSSAvVGV4dF0KL0NvbG9yU3BhY2UgMjIgMCBSCi9FeHRHU3RhdGUgMjMgMCBS
Ci9YT2JqZWN0IDI0IDAgUgovRm9udCAyNSAwIFIKPj4KL0NvbnRlbnRzIDUgMCBSCj4+CmVuZG9i
agoyNiAwIG9iago8PC9UeXBlL1BhZ2UvTWVkaWFCb3ggWzAgMCA2MTIgNzkyXQovUm90YXRlIDAv
UGFyZW50IDMgMCBSCi9SZXNvdXJjZXM8PC9Qcm9jU2V0Wy9QREYgL0ltYWdlQyAvVGV4dF0KL0V4
dEdTdGF0ZSAzMiAwIFIKL1hPYmplY3QgMzMgMCBSCi9Gb250IDM0IDAgUgo+PgovQ29udGVudHMg
MjcgMCBSCj4+CmVuZG9iagozIDAgb2JqCjw8IC9UeXBlIC9QYWdlcyAvS2lkcyBbCjQgMCBSCjI2
IDAgUgpdIC9Db3VudCAyCj4+CmVuZG9iagoxIDAgb2JqCjw8L1R5cGUgL0NhdGFsb2cgL1BhZ2Vz
IDMgMCBSCj4+CmVuZG9iago3IDAgb2JqCjw8L1R5cGUvRXh0R1N0YXRlCi9PUE0gMT4+ZW5kb2Jq
CjIwIDAgb2JqClsvSW5kZXhlZAovRGV2aWNlUkdCCjI1NQooXDM3NlwzNzZcMzc3XDM3NlwzNzZc
Mzc2XDM3N1wzNzdcMzc3XDM3N1wzNzZcMzc3XDM3NVwzNzVcMzc2XDM3NlwzNzVcMzc2XDM3NVwz
NzVcMzc1XDM3NFwzNzRcMzc1XDM3M1wzNzNcMzc0XDM3MVwzNzFcMzcyXDM3MlwzNzJcMzczXDM3
MVwzNzFcMzcxXDM3MlwzNzFcMzcyXDM1NlwzNTVcMzYwXDI2MFwyNTZcMjY1XDIyM1wyMjFcMjMx
XDM2NlwzNjVcMzY2XDM3MFwzNzBcMzcxXDM3MVwzNzBcMzcxVlRbXDM1MFwzNTBcMzUxdXF5XDM2
M1wzNjJcMzY0bWt0XDIzNFwyMzJcMjQyXDI0N1wyNDVcMjU1XDM2NVwzNjVcMzY3Y2FpZ2VtXDM2
NFwzNjRcMzY1XDM2N1wzNjZcMzcwWldeT01TXDI1M1wyNTFcMjU3XDM2NFwzNjNcMzY1XDMwMFwy
NzZcMzA0XDM1MlwzNTFcMzU0YF5lXDIyNlwyMjRcMjM0XDMzNlwzMzVcMzM3XDMxN1wzMTZcMzIx
V1ZdXDM2NlwzNjVcMzY3XDM2NVwzNjVcMzY2XDMwNlwzMDRcMzEyXDIzNVwyMzRcMjQzXDM3M1wz
NzJcMzc0bWxwXDM2MFwzNTdcMzYxXDMyMlwzMjFcMzI1XDM3NFwzNzNcMzc1UVBXXDM2MlwzNjFc
MzYzdnR8XDM0NFwzNDRcMzUwXDI2NVwyNjRcMjcyXDI1MVwyNDdcMjU2XDM2N1wzNjdcMzcxXDM1
NVwzNTRcMzU1XDM3MFwzNjdcMzcxXDM1MVwzNTFcMzU0XVphXDIxM1wyMTBcMjIwaWZvXDMxNFwz
MTJcMzE3XDM2NVwzNjRcMzY1XDM2MFwzNTZcMzYxenZcMTc3XDI0NFwyNDJcMjUxWllfXDM0Nlwz
NDVcMzUwXDI3NVwyNzRcMzAyXDM0MlwzNDFcMzQ0XDMwMlwzMDBcMzA2XDMyN1wzMjZcMzMyXDM1
M1wzNTJcMzU1XDM3MlwzNzJcMzc0XDI2MlwyNjBcMjY2a2lxXDIxMVwyMDZcMjE3XDM2MVwzNjFc
MzYyfXtcMjA0XDIwM1wyMDFcMjEyXDI2N1wyNjVcMjczXDI0M1wyNDBcMjQ3XDM2MVwzNjFcMzYz
XDMxMVwzMDdcMzEzXDMyNFwzMjJcMzI3XDIyMFwyMTZcMjI2XDMzNFwzMzNcMzM3XDIzN1wyMzVc
MjQ1XDM0MVwzNDBcMzQ0QUBFXDI3NlwyNzVcMzAzZGNrXDE3N31cMjA2XDI3M1wyNzFcMjc3XDM1
NFwzNTNcMzU1aGdrXDMxN1wzMTRcMzIxcW52XDM0MFwzMzdcMzQyXDI1NlwyNTVcMjY0XDMwNFwz
MDNcMzExXDIwNFwyMDNcMjEzXDIxNVwyMTVcMjE3XDIwNVwyMDVcMjExXDIwN1wyMDRcMjE0XDI3
NFwyNzNcMjc3XDI3MVwyNzBcMjc1XDM3NFwzNzRcMzc0XDIzMlwyMjZcMjM2XDMwNlwzMDZcMzEy
XDM2MFwzNjBcMzYxXDM0M1wzNDJcMzQ1XDIxNlwyMTRcMjI0XDM2M1wzNjNcMzY1XDM0MFwzNDBc
MzQzXDMzM1wzMzFcMzM0dXV5RUNKXDM3NFwzNzNcMzc0YWBnZGNmXDMxMlwzMTFcMzE2eXV8SEZO
XDM0NFwzNDNcMzQ2XDI2NFwyNjJcMjcxXDIyMVwyMjBcMjMwXDMyNlwzMjVcMzMxXDMzMlwzMzBc
MzM0e3pcMjAzXDM3MlwzNzFcMzczXDM2MVwzNjBcMzYyXDMzN1wzMzZcMzQxXDM0MFwzNDBcMzQ0
XDIzM1wyMzJcMjM1XDI1NVwyNTNcMjYyXDI3MFwyNjdcMjc1enhcMjAxOzpBXDM1NVwzNTVcMzU3
XDMyNlwzMjZcMzI3XDMyMVwzMjBcMzI1XDM2M1wzNjNcMzY0XDMyNVwzMjRcMzMwXDIzN1wyMzRc
MjQzXDM1NVwzNTVcMzYwXDIyMVwyMjFcMjIzXDM2NlwzNjZcMzcwXDMwMFwzMDBcMzA1XDMyMVwz
MjFcMzI1XDMwNFwzMDJcMzA3XDM2MlwzNjJcMzY0XDM2MlwzNjJcMzYzXDM3MlwzNzJcMzcyXDM2
N1wzNjdcMzcwXDI2MFwyNjBcMjYzVFNaXDIyNFwyMjNcMjMzS0tNXDMzM1wzMzNcMzM3XDM0MFwz
NDBcMzQxXDIzMFwyMjZcMjM1XDM1NFwzNTRcMzU2XDM0N1wzNDZcMzUxXDI2NFwyNjRcMjY3XDMz
MVwzMzFcMzMyXDI0MFwyMzdcMjQ2XDI3MlwyNjdcMjc1XDMwN1wzMDZcMzEzXDM1MVwzNTBcMzUz
XDMxM1wzMTJcMzE3XDIwMlwxNzdcMjA3XDIxNlwyMTJcMjIycHB0XDMzNVwzMzRcMzQwXDMxNFwz
MTRcMzIwXDI3NVwyNzVcMjc3XDI3NlwyNzZcMzAwXDMzNFwzMzJcMzM2XDMzMVwzMjdcMzMzXDI0
NVwyNDRcMjUzXDM0MVwzNDBcMzQyXDI3MFwyNzBcMjcycXB4XDMwNVwzMDNcMzA2XDMyNlwzMjRc
MzI3VVRXXDM1MFwzNDZcMzUxXDM0M1wzNDNcMzQ0XDMwMVwzMDBcMzAzODY8XDM2MVwzNjBcMzYx
XDM2MlwzNjFcMzY0XDIzNlwyMzdcMjQyXDIwMFwyMDBcMjAzXDM3NlwzNzdcMzc3eXl8Pz1DXDI1
M1wyNTNcMjU2XFxbXlwzNDdcMzQ3XDM1MFwzMDBcMjc1XDMwM1wzMTRcMzEyXDMxNFwzNzVcMzc2
XDM3Nn17XDIwMFwyNTBcMjQ2XDI1MVwyMjZcMjI2XDIzMlwyNjdcMjY3XDI3MWFhZFwyNzZcMjc0
XDMwMlwyNTZcMjU2XDI2MFwzNDVcMzQ1XDM0N1wzMjFcMzE0XDMyMVwzMTRcMzE0XDMxN1wzNzVc
MzczXDM3NVwyMjBcMjE0XDIyNFwzNjZcMzY2XDM2N1wyNzJcMjcyXDI3NVwzMjVcMzIyXDMyNXx4
XDIwMVwyMjJcMjIyXDIyNlwzMDFcMjcyXDMwMVwzNjVcMzY1XDM2NVwzNjVcMzYzXDM2NVwzNzNc
MzczXDM3M1wzNDVcMzQzXDM0NlwzMzRcMzM0XDMzNlwyMzRcMjIzXDIzNFwzMzNcMzMzXDMzNVwz
MzZcMzM2XDMzN1wzMTVcMzA3XDMxNlwzNjJcMzYwXDM2MlwyMTRcMjEwXDIxNVwzMDJcMjc0XDMw
M1wzMjRcMzI0XDMyNVwzNjZcMzY0XDM2NlwzMDJcMzAyXDMwNFwzMTFcMzExXDMxM1wyNDVcMjQy
XDI0N1wwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBc
MDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFww
MDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAw
MCldZW5kb2JqCjIyIDAgb2JqCjw8L1IyMAoyMCAwIFI+PgplbmRvYmoKMjMgMCBvYmoKPDwvUjcK
NyAwIFI+PgplbmRvYmoKMjQgMCBvYmoKPDwvUjIxCjIxIDAgUi9SMTkKMTkgMCBSL1I4CjggMCBS
Pj4KZW5kb2JqCjIxIDAgb2JqCjw8L1N1YnR5cGUvSW1hZ2UKL0NvbG9yU3BhY2UgMjAgMCBSCi9X
aWR0aCAxNjUKL0hlaWdodCA0NQovQml0c1BlckNvbXBvbmVudCA4Ci9GaWx0ZXIvRmxhdGVEZWNv
ZGUvTGVuZ3RoIDM1MTQ+PnN0cmVhbQp4nK1ZhZ8btxJeabWSmX3MzMzMzDlmvjAzMzMnTcMpJm0D
hWCZmRkf83v/wZO09tmXXqDp6Rf7stq15tPANzNaKPABgADpEAT2sU0pd12JFACEomibkP/YnhCF
Ow26Fr0L7nj/QYYdmWQDIlKwFAGAkVti+yAQxF/DER1bucOa97j/ICAFBktkaAAA0K64yCk3S5wV
AumFCCUk3F1LcMIRUoEIMAMhjEmVUqNUKjcoMOB4vz3gdwaMAUk/INNikn6XQNE2fgtGZk+k9N6f
1ZLXVb11q0534XCbJSk9BoOHt9zchZy0JlKYoqKjfhW6q7KYdAjvjOHBQKriLnad3F6Y3JOjD3Er
8o8OadUXle4+rX13ivn6TCdVQgZS2eW5CkBwN4NT8ZI0oXEDwJyBHNdrk4fDLBuNCkVVlWKDOjKj
rbzx6amvLTv19rdoVBrVngigZqs1iP3vzn5Jb2ClhkwkSJy1pf/AY3MeVjgLhVSMR/z0Nzv7H804
hljgQ25sGlQ+7c94U0UCtj2RzkLAYTEGY1/MawXRY2RY9fscd+zo84+d/RAWnCIWAFkiOHYmtjP2
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
hqWBp1LO1b/s21OYHG5e6rk+OXHljsWJ3cn60gVx9hKArUrmb5o9a15t+4wjM9JqC7tP+PklnvCq
Se6Z/JTVy7XaokS/Zm9xjOz7OUTgD1FMWV5uRkz35TjYpe312hO5uy1DXdle89zbQ9zcu1rOB6gT
0GjWwIgfBGCSoMCMT/LjUiqWB85IfT56TU5rY+qhrAAyMa95bDsBBds9L2028Rm70kXBoyi8er7G
sj6wKd3DpCSsLxrN/cLoOxx7/4/4yyoaWQqV+uBBDbYfCk8MSHYsle++0mtbPnQ017y2zdq+Mjqv
yHWuCPlrNCiMbxynV1Ly2wb7OQ74/ef+Dn+g4a2NGjlHeAsqcalMjEgsbsHFie4GKDiedOjGdrri
ACjYvBrIsH/Lu5F7gpR7I8JzHpSPYeSylyaepkNnt+6njQbLyeKvy5SxmrXtTeYVKLfcvw3p/wFs
ylrcCmVuZHN0cmVhbQplbmRvYmoKMTkgMCBvYmoKPDwvU3VidHlwZS9JbWFnZQovQ29sb3JTcGFj
ZS9EZXZpY2VSR0IKL1dpZHRoIDI4NgovSGVpZ2h0IDEzOAovQml0c1BlckNvbXBvbmVudCA4Ci9G
aWx0ZXIvRENURGVjb2RlL0xlbmd0aCAxNDYxOT4+c3RyZWFtCv/Y/+4ADkFkb2JlAGQAAAAAAf/b
AEMAAgICAgICAgICAgMDAgMEBgQEAwMEBwUGBAYJCAkJCQgICAoLDgwKCg0KCAgMEAwNDg8PEA8J
DBESEQ8SDg8PD//bAEMBAwMDBAMEBwQEBw8KCAoPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P
Dw8PDw8PDw8PDw8PDw8PDw8PDw8PD//AABEIAIoBHgMBEQACEQEDEQH/xAAfAAABBQEBAQEBAQAA
AAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEU
MoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2Rl
ZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK
0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUG
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
AOhb1b/wCm/+JrWFele9/wAzllRqHL3mgeJP+hb1b/wWTf8AxNdUMRQ/n/Bnn1aM/wCX8Tlrnw/4
k/6FvXf/AAWXP/xNdkcXQX2/wZ51ehV6R/FGJN4Y8Sf9C3rv/gsuf/ia0jjaC+3+D/yPOlgqz+x+
K/zM1/Cvi3/oUtd/8Fk3/wARWrxtD+f8H/kTHBVv5fxQz/hF/F3/AEKmr/8Agsm/+Iqfr1B/b/B/
5D+qVv5PxRF/wjPiX/oU9e/8Fk3/AMRTWJw7+3+DD6pV/l/E/S3/AIJp/D/Uh4/8e+NtX0S+sX0v
T00+H7dA8HzzvuYoGUZ+WIfnXwnG2PVXD06dPz/9tZ9rwlhKtKtKU1/VpH7REYOSOK/OHOMVqfep
WuSUJjCmAUAFABQAUAFABQAUAFAFcqu3G0YOOMe1SgZMQMdBVCRQnZlgvtrEbV+XBxt47UDGy/6s
+7RfqRmkwLZUBcgDOF5/GhBIsUxIrH/VL/vL/wChCpkUxsBJjUnrk/zNOJDFXqv+7n+VNDQhVS8R
KjO4c4/3qBkI+a5kDcjHQ/QVTMnuX27UkNjayRoFWjNjV70I3HnoKZBTckO2Dj5R/Os+pSJj/rQO
xU8VstiJEg6Cs0N7i1aHIKYMKZKI6CWFBDGJ0rOeyDDdSw3Vao1j1HDoKziMWrAKACgAoAKACgAo
AKACgD//2QplbmRzdHJlYW0KZW5kb2JqCjggMCBvYmoKPDwvU3VidHlwZS9JbWFnZQovQ29sb3JT
cGFjZS9EZXZpY2VSR0IKL1dpZHRoIDI4NgovSGVpZ2h0IDEzOAovQml0c1BlckNvbXBvbmVudCA4
Ci9GaWx0ZXIvRENURGVjb2RlL0xlbmd0aCA3NDgxPj5zdHJlYW0K/9j/7gAOQWRvYmUAZAAAAAAB
/9sAQwACAgICAgICAgICAwMCAwQGBAQDAwQHBQYEBgkICQkJCAgICgsODAoKDQoICAwQDA0ODw8Q
DwkMERIRDxIODw8P/9sAQwEDAwMEAwQHBAQHDwoICg8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P
Dw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P/8AAEQgAigEeAwERAAIRAQMRAf/EAB8AAAEFAQEBAQEB
AAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQci
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
Ui9SOQo5IDAgUi9SMTEKMTEgMCBSPj4KZW5kb2JqCjMyIDAgb2JqCjw8L1I3CjcgMCBSPj4KZW5k
b2JqCjMzIDAgb2JqCjw8L1IzMQozMSAwIFIvUjgKOCAwIFI+PgplbmRvYmoKMzEgMCBvYmoKPDwv
U3VidHlwZS9JbWFnZQovQ29sb3JTcGFjZS9EZXZpY2VSR0IKL1dpZHRoIDE4NgovSGVpZ2h0IDEw
OAovQml0c1BlckNvbXBvbmVudCA4Ci9GaWx0ZXIvRENURGVjb2RlL0xlbmd0aCA4NjcxPj5zdHJl
YW0K/9j/7gAOQWRvYmUAZAAAAAAB/9sAQwACAgICAgICAgICAwMCAwQGBAQDAwQHBQYEBgkICQkJ
CAgICgsODAoKDQoICAwQDA0ODw8QDwkMERIRDxIODw8P/9sAQwEDAwMEAwQHBAQHDwoICg8PDw8P
Dw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P/8AAEQgAbAC6AwER
AAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQE
AAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2
Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Sl
pqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8B
AAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUh
MQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJ
SlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2
t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A/fyg
AoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAC
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
x9y6S3u9bifzbrnO979Nf+e3aT+dn79O+6/fe+swoK3Rv01v7fwjm36xmDPflva+T3M7pu21nZ5S
qk/rWk9tW/67NKSYcVk/h1qNpGGsqF4jKQ+sfY2kPLPmGkm5Zx1qJOWVtdRIygvrWCPJE+tDjaQh
sz7WSBoeWKcaSYMGX/DvrOqsS42kbKytRlJurGuNpMJnNuAZVIoMOBOwPLICZxKNJBg0JtHIhQwa
k6hwIYPGJCoEGjQmUeG6Bo1J5KrQmES95kJjEvUUGUQMqp4KOBOw12MAZwL2IgBnAroqcCbgSAK2
U0HlnR04D2BhBdD1Bgv32WF1eQtfisPq8haui9srqHwLDqvLO3Jdh9XDy7fvsLq8owbD6vJmPQas
Lu9IoMPq8hZurMPq8o4TK6weXl2F1eUtF1ZYXd5MAvZPwWDOxe4quMrdwA0UVN4K26ngy9FVWPv4
YovOw+eHz6PBM/Z5pLr54zjadtdB1EHjAbtu7d9Z3W87Z3XI6Q/uKPEFCmVuZHN0cmVhbQplbmRv
YmoKMTMgMCBvYmoKPDwvQmFzZUZvbnQvWFRTRUJOK0dlb3JnaWEsQm9sZC9Gb250RGVzY3JpcHRv
ciAxNCAwIFIvVG9Vbmljb2RlIDQxIDAgUi9UeXBlL0ZvbnQKL0ZpcnN0Q2hhciAxL0xhc3RDaGFy
IDUyL1dpZHRoc1sgMTEyNiA3MjEgNjg2IDcxNSA4MjAgMTAyMyAyNTQgNjg0IDgwOSA3MDEgNzk3
IDY0OSA3NTggODM5IDU3Mgo1NzcgMzU0IDUxMyAzOTcgNTIwIDU5NiA2MzYgNjkwIDMyOCA0OTAg
NzAxIDU1NCA2MjUgNTk5IDg3OSA1NjIKNjU4IDM5MyA2NjMgMTAxNiA1MzEgNjgwIDY3NyAzNDQg
NTg4IDk2NyA4NjMgNjQ2IDUyNSA2MjYgNjMyIDgzNAozNjcgNDQ2IDc1NyA3MzIgNjcxXQovU3Vi
dHlwZS9UcnVlVHlwZT4+CmVuZG9iagoxNSAwIG9iago8PC9CYXNlRm9udC9RRUdNSk8rSGVsdmV0
aWNhL0ZvbnREZXNjcmlwdG9yIDE2IDAgUi9UeXBlL0ZvbnQKL0ZpcnN0Q2hhciAzMi9MYXN0Q2hh
ciAzMi9XaWR0aHNbCjI3OF0KL0VuY29kaW5nL1dpbkFuc2lFbmNvZGluZy9TdWJ0eXBlL1R5cGUx
Pj4KZW5kb2JqCjQyIDAgb2JqCjw8L0ZpbHRlci9GbGF0ZURlY29kZS9MZW5ndGggMjUyPj5zdHJl
YW0KeJxdkcFuwyAMhu95Ct4gJjXtKlW+tJceNk3bXiABU+VQgmh62NsP42WHHT6kD2xkfvrz9XJN
82r697L4T15NnFMo/FiexbOZ+Danzg4mzH79tbb6+5i7/vw65q/vzKYWcFR/G+/cf6DuWO3xS+BH
Hj2XMd24OwHQKUbqOIV/R/agHVPcSi0pgANVHUgB50R3pIDbiSIpgEdRRwogi+5JAWy9B1JgANEX
UgCt6JEUQBQdSQHXiidSwLWpPCmAUTSQAuhFmRTANmQkBZzcbGsWQj3di9a3Wn1vaAFtSUhWEvqW
sfHPUjit7Wda8pL4nPjv8/KSpctUuh8JnYaqCmVuZHN0cmVhbQplbmRvYmoKMjkgMCBvYmoKPDwv
QmFzZUZvbnQvVFdQV0FWK0FuZGFsdXMvRm9udERlc2NyaXB0b3IgMzAgMCBSL1RvVW5pY29kZSA0
MiAwIFIvVHlwZS9Gb250Ci9GaXJzdENoYXIgMS9MYXN0Q2hhciAxNy9XaWR0aHNbIDU0MiA2Nzcg
NDQ4IDMwMiA2NzcgNDc5IDI0NCA2MDQgNzA4IDQ3OSA1NDIgNzI5IDQ2OSA2MTUgNTIxCjQyNyA4
ODVdCi9TdWJ0eXBlL1RydWVUeXBlPj4KZW5kb2JqCjQzIDAgb2JqCjw8L0ZpbHRlci9GbGF0ZURl
Y29kZS9MZW5ndGggMzM0Pj5zdHJlYW0KeJxdkk1ugzAQRvecghswg8EkUjSbdJNFq6rtBYgZIhYx
iJBFb9/5KV108ZA+Zmx49lTny8slT1tZva9z+uStHKc8rPyYn2vi8sq3KRdYl8OUtt9kz3Tvl6I6
v/bL1/fCpTTw6Pmtv3P10QR7g74mzQM/lj7x2ucbFycAOo0jFZyHf6X66Cuu496K5EANJLEmB5qk
MZADcdTYkAMRNbbkQGSNkRxorNqRA3HQeCAHulbjkRzoGo09OdBYvJIDXa0xkQPxqHEgB+qDRiYH
WquO5EDUD6GchSLNWkVxRfNtdWcUVzTfTvVRXNF8O2sWVzTf1qriiu6rP4niiuYbbCtxRfMN1iyu
aL61niSKK5pvsL8SVzTfoGeF4oomGIJGkUMTDFGjyKEJhoNd6n57er86KPtclOm5rpw3myabFp2S
KfPfwC3zoqtKofgB2Lms/QplbmRzdHJlYW0KZW5kb2JqCjE3IDAgb2JqCjw8L0Jhc2VGb250L1dR
SFdLRCtDYWxpYnJpLEJvbGQvRm9udERlc2NyaXB0b3IgMTggMCBSL1RvVW5pY29kZSA0MyAwIFIv
VHlwZS9Gb250Ci9GaXJzdENoYXIgMS9MYXN0Q2hhciAzMC9XaWR0aHNbIDIyNiA0MjMgNTM4IDQ5
NCA1MzcgNjA2IDgxMyA1MzcgMzQ3IDYzMCAzNTUgMjQ2IDMxMiA1MjAgNTAzCjMxMiA1NjMgNTM3
IDQ3NCA1MzIgNTM3IDUwNyA1MDcgMjU4IDUwNyA1MDcgNTA3IDUwNyA1MDcgNTA3XQovU3VidHlw
ZS9UcnVlVHlwZT4+CmVuZG9iago0NCAwIG9iago8PC9GaWx0ZXIvRmxhdGVEZWNvZGUvTGVuZ3Ro
IDIzNT4+c3RyZWFtCnicXZE9bsMwDEZ3nUI3MC3K+QECLumSoUHR9gKyTAceIguKM+T2NcW6Q4cn
4EkkCH5qzpe3S5oW23yUOX7xYscpDYUf87NEtj3fpmRaZ4cpLr9Wz3gP2TTn95C/X5ntWsCj+jXc
ufn0vt602hPngR85RC4h3dicAOg0jmQ4Df+eWq8d/biVtqSAA1rVkQLoRJEU6Kp6UgAPoh0pgHvR
HSngWHRPCqAXPZACiKJHUgDr3EAKuCjakwLYiUZSAI+iAymArSiTArirO2/LyfqS4xabjc9SOC01
7BqmhDgl/vuPPGfpsivmB/CNfMoKZW5kc3RyZWFtCmVuZG9iago5IDAgb2JqCjw8L0Jhc2VGb250
L1ZOWlFYTCtDYWxpYnJpL0ZvbnREZXNjcmlwdG9yIDEwIDAgUi9Ub1VuaWNvZGUgNDQgMCBSL1R5
cGUvRm9udAovRmlyc3RDaGFyIDEvTGFzdENoYXIgMTQvV2lkdGhzWyAyMjYgNTA3IDU0MyA1MDcg
NTA3IDI1MiA1MDcgNTA3IDUwNyAyNTAgNTA3IDUwNyA1MDcgNTA3XQovU3VidHlwZS9UcnVlVHlw
ZT4+CmVuZG9iago0NSAwIG9iago8PC9GaWx0ZXIvRmxhdGVEZWNvZGUvTGVuZ3RoIDU3Nz4+c3Ry
ZWFtCnicXZTBbttADETv/gr9gZfclZQAwV7SSw4tirY/IEurwIfIguIc+vedGTY99DBBxss1+cg1
z88vX1626707fz9u889279brthzt/fZxzK27tNfrdjLvlut8/+v0d36b9tP5+eu0//q9tw4BbQ3/
bXpr5x+l1ycWd+bb0t73aW7HtL2201NK9Wld66lty39HY4obl/Uz1GooeaqwXkOprLS5htIw0JYa
SsMjbV9Daci0Qw2loacdaygVo32ooVRG2scaSll5pxpKWaeXGko+0841lAZ91VJDadBpw7+rLO8a
4KmURqcFnAmwyALOBDiySAOcCXAkggHOArDRAs4EWBQMOBPg+EALOBNgZnMMcCbArFPAWQAqL+As
AIlggDMB5kILOBOgs+0GOBNgVlUApGBVBlhNvCPzYm4SimReB6sHL5vjYPUYqILB6uLt2SsHq4u3
50AdrC7enokcrC7enmU4WD0GyuY4WD0GqlOwunh78jpYXbw95+tg9RjoQgtWj4HKgtWDd6IFq4t3
1F2wesyXzcF7kZCXp2inhGASodkSglkG+ichL2tGsyUEMxHaKcFyChijhLsXWrBm8fY6BWsWr+sU
rDnmy9ahcAl3FQzWLN4iC9Ys3p4zymDN4i26C9YcvLJgLRqqMRi/HgnfzJrxiiWUIQu4IsDCTiKb
hK/iM8OzlRAsC7gSA2Un8UOUkIhPBc9H8oShc3d8LgmuEe6jz/XTzR/H0ba7lpaWEpfRdWv/9tp+
23mrg05/AD2UMeUKZW5kc3RyZWFtCmVuZG9iagoxMSAwIG9iago8PC9CYXNlRm9udC9ERURWSVAr
R2VvcmdpYS9Gb250RGVzY3JpcHRvciAxMiAwIFIvVG9Vbmljb2RlIDQ1IDAgUi9UeXBlL0ZvbnQK
L0ZpcnN0Q2hhciAxL0xhc3RDaGFyIDcyL1dpZHRoc1sgMjQxIDc0NCAzMjUgMjkzIDQ1NCA0ODMg
NjcxIDcyNSA2MTQgNTAyIDI3MCA1MDQgMjg2IDUwOSA1ODIKNDEwIDY1NCA1NzUgNDMyIDU5MSA2
NTMgNTA1IDU2NiA1OTYgNTU5IDQzMCA1NjUgNDY5IDU1MiA1MjggNDk3CjgxNSA2MDQgNTk5IDk3
NiA2MTUgNzU2IDU2MSA3NjcgNjQyIDcwMiA2MTAgMzc0IDg4MSAzMTMgNTcxIDUzOQo5MjkgNzM3
IDU2MCAyNzAgNDQ0IDM0NSA1MzYgNjE5IDY0MyA1NjYgNTc0IDc0OSA3MTAgMzkwIDQ5MiAyMjcK
MjI3IDI5MiA0NzIgOTI3IDU2MCAzMzEgNjQzIDQxMCA4MDddCi9TdWJ0eXBlL1RydWVUeXBlPj4K
ZW5kb2JqCjE0IDAgb2JqCjw8L1R5cGUvRm9udERlc2NyaXB0b3IvRm9udE5hbWUvWFRTRUJOK0dl
b3JnaWEsQm9sZC9Gb250QkJveFstMjkgLTIxNiAxMTQ1IDc1NV0vRmxhZ3MgNgovQXNjZW50IDc1
NQovQ2FwSGVpZ2h0IDcxMQovRGVzY2VudCAtMjE2Ci9JdGFsaWNBbmdsZSAwCi9TdGVtViAxOTIK
L01pc3NpbmdXaWR0aCAxMDAwCi9YSGVpZ2h0IDQ5OAovRm9udEZpbGUyIDM1IDAgUj4+CmVuZG9i
agolQmVnaW5SZXNvdXJjZTogZmlsZSAoUERGIEZvbnRGaWxlIG9ial8zNSkKMzUgMCBvYmoKPDwv
RmlsdGVyL0ZsYXRlRGVjb2RlCi9MZW5ndGgxIDIwMjI0L0xlbmd0aCAxMzU4Mz4+c3RyZWFtCnic
7Xx5fBzFnW9Vd889o+m57+me6TmkmdHcmtFlqa1b1mlLtiXLY+vwjcEy+DYgGyNsbIyNjbEMBIRl
TIDEyMQmtiFZJ0sI2YRjDSQQQhbCnUVZltzgGb3qnpEsTEj27Xt/vM/n7fRUd3V193TV9/et31FV
EoAAAAXYAXDQ3tYRigL+0/w62i0YuLZvMHvepAUAHh/YtIFu6W87hgp+hc4/WDG48tpttb9zAYA9
C4Dgn1au3boie788DEBpYtXyvmU//8WH2wBofR4VJlahAjIs+RAA8a3o3LXq2g1bsve3oPvhlrXr
Bvqy53WrACAeu7Zvy6DgCPY2uv+bqJC+ru/a5bn6nUM7++C6GzZkz1v564PXLx88teD2UXQ/eh++
Sijnrgn2AS/6tc8BDXIfoojL428DG3c2+Qa/f3tqn6nhn/oc5c6B/8OPOJf++x9443/rqYNwFxyA
9bAbbIHXwm44BwYgC1JwK3/WBq4Dt6C7MmAl6AM9UAIeAteCXtAM1eAVxIVFcCNch37mZfAz0Iq2
e8BmUAeqUEkz9s3cK86AenAYnAAfQwyWQR3UofN6cIEvr4ctcAHcCffBQ+BmdM9fAAsawUKwjH/i
CfBT8BasgxvgHuz7wAz+hMoAfAOaUT1uBlowiM/D/3nyLcyFvQE+x25ET6bBv4MXYAQ8BfpBGL8F
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
EKj5/wMCgBDIAahfvu76lav7AlXr1i7jrwJ4EAj+y/9+66r7PgWfTn6pAE7dBqcThp65OokkoOcf
JWwU7OOS4H6wEv93sFGAg+uISRDn009BMZ/Wge6phH0KvvO3kugZ8IBQNfkToRLUCs6DeuG3QLXg
Ryi/9ErC7wKVU0lwI6gVhwEj/C6wCQ+AevT+Wi4J+9AxAljBVqCYShJ88nXhFiARvDn57N9LxLOg
TeCbnCBY9HutoJ44DOpxNxAS3wBWwSDAsVeBg0uCPJT/AcKPBgHBMEp6dH81kHGJKAABwgyqceQn
CNYAJZeEH03+njgDcGJo8n0ijuSO/wP5cfIRAHB6/IkLS5XlfwSWrEC/ffuZX3DHH1R9VJDZlj4s
TYk+5tfMYdnH/he2NFSMCmVuZHN0cmVhbQplbmRvYmoKMTYgMCBvYmoKPDwvVHlwZS9Gb250RGVz
Y3JpcHRvci9Gb250TmFtZS9RRUdNSk8rSGVsdmV0aWNhL0ZvbnRCQm94WzAgMCAxMDAwIDEwMDBd
L0ZsYWdzIDY1NTY5Ci9Bc2NlbnQgMAovQ2FwSGVpZ2h0IDAKL0Rlc2NlbnQgMAovSXRhbGljQW5n
bGUgMAovU3RlbVYgMAovQXZnV2lkdGggMjc4Ci9NYXhXaWR0aCAyNzgKL01pc3NpbmdXaWR0aCAy
NzgKL0NoYXJTZXQoL3NwYWNlKS9Gb250RmlsZTMgMzYgMCBSPj4KZW5kb2JqCiVCZWdpblJlc291
cmNlOiBmaWxlIChQREYgRm9udEZpbGUgb2JqXzM2KQozNiAwIG9iago8PC9GaWx0ZXIvRmxhdGVE
ZWNvZGUKL1N1YnR5cGUvVHlwZTFDL0xlbmd0aCAxOTU+PnN0cmVhbQp4nGNkYGFiYGRk5PJIzSlL
LclMTgTx1H9IM/6QYfohyyzL4DPnGe8POR6Gbh7mbh6WRd9bhb5XCn4v4/9eLMDAwsho7hM5UyM0
KFxTW1vHOb+gsigzPaNEwdDS0lIhqVIBKqPgklqcmZ6noAZklKXm5BfkpuaV+GXmJpUWKwQn5hUr
+CgEpaaX5iQWoQgizCPPBgYGBkYFIGZgYmRkYf++ig+IShb9WDDre9D0kEVsN7kecN+cwMPzYAoP
LwMDAJe2U1EKZW5kc3RyZWFtCmVuZG9iagozMCAwIG9iago8PC9UeXBlL0ZvbnREZXNjcmlwdG9y
L0ZvbnROYW1lL1RXUFdBVitBbmRhbHVzL0ZvbnRCQm94WzAgMCA4NzggNzEzXS9GbGFncyA2NTU0
MAovQXNjZW50IDcxMwovQ2FwSGVpZ2h0IDcxMwovRGVzY2VudCAwCi9JdGFsaWNBbmdsZSAwCi9T
dGVtViAxMzEKL01pc3NpbmdXaWR0aCA1MDAKL0ZvbnRGaWxlMiAzNyAwIFI+PgplbmRvYmoKJUJl
Z2luUmVzb3VyY2U6IGZpbGUgKFBERiBGb250RmlsZSBvYmpfMzcpCjM3IDAgb2JqCjw8L0ZpbHRl
ci9GbGF0ZURlY29kZQovTGVuZ3RoMSA4MTM2L0xlbmd0aCA0ODk3Pj5zdHJlYW0KeJztOQtwW9WV
9973nvQkS9Z7+suyoic/y5/IRooVOz8lVmxJkT+xZTs2lhMndmIHB5PEISbkA9RJEwJOSgMNbCAF
wmcWWkrzXD4btnQnLSad7aYtUwqU3cJmtyyzXeolnQKdKfHznvtkmyS729md2Zndme297/7O/Z3f
PefIRhghZEZjiEGZ1o5wFdLSgsVQdW3Z3j+SGxe+ihDesGXPqBQ95XwSAL+E8snWkZu27/leYhLm
3kBIJ990y76tufWGiwjlXxoa7B/4xWPJryLkPwHAmiEACM/oNiCk/wTGxUPbR/fO3nccqg9u2bml
Pzd2fwshNn97/94R5kf6LQjxbgBKO/q3D86up2PPyM7do7mxn+Ipjdw6OFL8q9fvgvVLAaev6Qwz
P+HG0AIoxawDFaCDM7+aK+ovZi5xO1DZTMHMu8wGtICewv45QtOAmQq3k78lJwF0cOZ9wsNI1d3N
SOi/n86iV9AmKCn0DTSAVgHkTtQJ0E50CnIEPQWQe6BQvnei3eg4rDquzeTSk2gvegC9iB4CeArt
gFEGRgjmt6FD6Az6A8wgdD+UVwDyVygTr+3uXNfR3pZpbVnb3NTYkF6TSibq61bHa1etjK1Yvmzp
kprq8A2VFWUlwWK5yO+2i4LFnGc08HodxzIEo4qknOqTlJI+hS2R0+lKOpb7AdB/FaBPkQCUunaN
IvVpy6RrV8Zh5dbrVsZzK+PzK7EgxVCsskJKypLy44QsncM9bd3Q/0pCzkrKlNZfq/XZEm1ghkEg
ADukpHsoISm4T0oqqT1D48m+BJw3kWesl+sHjZUVaMKYB9086Cll8sgELluFtQ4pSy6fIIg302sV
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
r1ry6HBfVL1w+7qNVdXtW4dKt20I3Qjcc4JWBbnnQatujFefFPBpgu1ixmI9ayVWswdnEDyNM/RX
ViuXMLYiM+bN2OpkLWmPzZlTklmnBDHXe1qE8OH0h++DaxZopT0KGmN9oQ2yxMhi1BkNVFVH2eAa
Rn2zRgtXkupHhlSFuYC5uSjCLsL+K+g0q0meReo/4DsqtV/zYbBsXfAGgmgkXtnju9m338cMFx4o
JJ2eQc9tHuZeI84z4qM6zOowaiVJuQX5Bb/kZ/zU2xaC9/b7S022FldCaDUhOVNMbEJGJN5G3jCr
5zS+AAqoIQ9RUubNFhhrEJheF5BAQtfEPc6otKSmWigl1Gx3fZfkLR1Vf65O7l1BQ6Fs7QMdd2DU
UpJf+mX8CpcpnH7uF87jHd9+oesuciEXgdT3TNedX1/9YvZFXLIX15m0P4k7/ofyk7gM343fJc3k
aS3/Hc1MOfN79j7Ow+3j9uk43dO6z/Ujf8p/yn/K/xez9ndKMvuXSzvYYki4AIoOOsGlNRWLypji
0mh1VbhkSXkE/f9KLKrTapby57I4MwM1pjWMWaiDEDfVoAq0CJUB54pRKYrCL7wq8CQlaAkq1/7/
iOHXL4GM4DegHqHVOwb6b7ltN9JmED6BOIiC/mvpunWX0eWZawB4Dmk0NlfwJwD+Xy7sW8jAdqLl
7EeomXsOxZm3oAyjlXOFDKOGucKcR6v1DqTjhlER9xZqhrUraIH9S5kHUR8bQk6YC+f09I8kygvu
oyMTytm/3GSJfYrcOeY992eStvMC//H9qnrlCf6n/DswNGjygfRvtkR3DgplbmRzdHJlYW0KZW5k
b2JqCjE4IDAgb2JqCjw8L1R5cGUvRm9udERlc2NyaXB0b3IvRm9udE5hbWUvV1FIV0tEK0NhbGli
cmksQm9sZC9Gb250QkJveFswIC0xNzcgNzU0IDY5NV0vRmxhZ3MgNAovQXNjZW50IDY5NQovQ2Fw
SGVpZ2h0IDY5NQovRGVzY2VudCAtMTc3Ci9JdGFsaWNBbmdsZSAwCi9TdGVtViAxMTMKL01pc3Np
bmdXaWR0aCA1MDYKL0ZvbnRGaWxlMiAzOCAwIFI+PgplbmRvYmoKJUJlZ2luUmVzb3VyY2U6IGZp
bGUgKFBERiBGb250RmlsZSBvYmpfMzgpCjM4IDAgb2JqCjw8L0ZpbHRlci9GbGF0ZURlY29kZQov
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
G7E5KvZTcckJC2tphFPtyyrMKtSk3ssdEk5wgidwTk5hX4amp4snjvql4dw58ghdfHeCxRL78v74
WB/1HBmpxq9H8ZwdO8hNmGcJOX6aU0pjTRFW0e9ymxNXzeNTCbf/4zNHeB0e/+MB9nrBocdHTz7U
uP3AusrVc0v1cM4WyVUyRfb03ulTemoybIHljVN6clKT0tK5ZXKdUmxMjBY769wrf94/hd688pa1
lVqzWWtIciezP2Uxp5gtJa1l+c3FyarUTK4wy6lK9tgq/dG3RVxBzw4yNhZ/BuIk/G8Ii8fO2hB/
MvYfcN6IgbZ8zXD39xc4yTcO57HAF3/HcONkmBhEQ98siN2x8MF/M0hmfLMglUsvnRhk/FeEW1iQ
Z/yLcODbBEXp1wi3TYbJMBm+NLzyfQelS7nm/2JQTVNNU/u/Y3hBs1HboVuud+vf038CYWwyTIbJ
MBkmw2SYDJNhMkyGyTAZJsNkmAyTYTJMhskwGSbDZPhmQfgemYv9y8CJhBc4n0hIPWF/FWADTRXd
Sjm6kYjoIN1HryMWehHt5s8iW6iNP5vMpz+kj5N5NJl/l3+HD/Lv8yP8e/xR/gP+IyIiC6EWEfuX
hAk5ahuDux2l7BPiIvYPEH+HuolQiwHazhH2Dx2rCJnet3rl4nUrc2v6Vy8VUgm9lIiJ7Gv+L3xO
yneUHB07QRH715NFmuNCfwv8AzF/nyJWkh3/F4Vf/O8XUc0EOee/LFlENymT8lXCf0hm/DtF1Eya
TxApafr/KvQTsurfKZJzyVlg46+WFtLwjWRCWe6FbymPEfN/SqCdm78P4X9DTJMyKZMyKZMyKV9X
OB3sQ//X5SyyCqRvUr6ewPNxB4Sp3zGUkytJJwmSDNIbq4//X57j2XO6+MbIcGj3vT3ayo9JEj7Y
H3j7TOHv5h9N//G6z14c3SF/R/oo5JUL7w/g538AqHsIMwplbmRzdHJlYW0KZW5kb2JqCjEwIDAg
b2JqCjw8L1R5cGUvRm9udERlc2NyaXB0b3IvRm9udE5hbWUvVk5aUVhMK0NhbGlicmkvRm9udEJC
b3hbMCAtMTQxIDUwNSA2NDFdL0ZsYWdzIDQKL0FzY2VudCA2NDEKL0NhcEhlaWdodCA2NDEKL0Rl
c2NlbnQgLTE0MQovSXRhbGljQW5nbGUgMAovU3RlbVYgNzUKL01pc3NpbmdXaWR0aCA1MDYKL0Zv
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
eAf4LfAb4G3g18CvgLeAN4FfAr8A3gBeB14Dfg68CrwCvAy8BPwMeBH4KfAT4MfAC8DzwHPAs8CP
gB8CzwCHgKeBHwBPAU8CTwAHgQPACPA4sB94DHgU2AdEgGEgDOwFHgG+DzwM7AEeAh4EHgDuB3YD
9wH3At8D7gHuBu4C7gTuAL4L3A7cBtwK3ALcDNwE3AjcAFwPXAdcC1wDXA1cBXwHuBK4ArgcGAIu
Ay4FLgEuBi5i/TMGOfyfw/85/J/D/zn8n8P/Ofyfw/85/J/D/zn8n8P/Ofyfw/85/J/D/zn8n8P/
+QCAGMARAzhiAEcM4IgBHDGAIwZwxACOGMARAzhiAEcM4IgBHDGAIwZwxACOGMARAzhiAEcM4IgB
HDGAIwZwxACOGMARAzhiAEcM4IgBHDGAIwZwxAAO/+fwfw7/5/B9Dt/n8H0O3+fwfQ7f5/B9Dt/n
8H0O3/93x+H/8E/Xv/sC/sM/ScuWMh1jY5uV13RWpjADq2StbC5b/CSzYEsnsCr+2GPxDQ3GfMMP
sF01zIsNb2Sc1wdtWo3l8ZSUWt/jZforFUczXt4frTVciVBeO/rO6MuFo+8ccVYWHuGFv333nXft
H73sqCwsffeNd4uLuCPDocJl1RgMLr0vs0BTNslfXlpaMl1TNsXvy7RqVNuU8qnTldKSdI3ikpbp
GlHmymtfL1Lmjeo15/hqF5bq0lNsLotep0lNcubXZNvbF2fXFKQZFINe0RkNOVPrMlvWNWb+2uBI
i09IcxqNzrSE+DSHYfRtnfXYxzrrV/XadV9dr+irl9RmKTebjBqtXj+SnpQ8uTqjeaEtzq41x9kd
CUaD0xGb07Bk9OL4VDFGanw8jTXaiml5ePyY1owZLGcN7Jpgur3AMdVo5q1T7TZxirXwOVOT7JBJ
wjiiKX08N4hibq1jZPzoPiiVbVG2qPz5vliV39tnFqxxRFIL7CPcuH9TkAeDidNGuPmxjLbEkC7E
amtrxVx3H6nkhe+q61ryRoCEs7KyuCg7On+TlALF53PI2XRMKS/NKElITFfixVKkK4lxCQl8in+S
349WYjW0Zr0rKz0lw2XWnhmfP72jenNMXEZycobLmJvI44pnpLRsnjvJV7ek0jslP8e1xWocG22Y
n1xbes0DDX11nhRjrFGrjbHH8uIpp9X6Rn9ljDXodAYYH5nk0SmWioUb62esmlflsgZq5haP/SEr
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
7djFxmHDwpNeCtXXQWxfTFP0jbDk5D2s7mJt9M3w+C6eqteflDNq5Zsh5Yzlym5XUdvZD24KtM3I
c2GyzEZzzrQFpb2Xd+Zpyq7vWXdd16SS0+8daNu1JDjJsTezrqd2xpLq1OSKRXUtV2gOdjx85+Wr
q812p9OTkpBi1dmctpZzdi/xFFWvvKJ94W3bmnJb1w/d3TS4d11R4bz+surlDdn59Jfb7v7PO/ic
iWPimDgmjonj/6Njl3rc+T//0LRqWpXN/71D69f+VrdLf4ah3PA3wyfGa423xrRPHBPHxDFxTBwT
x8QxcUwcE8fEMXFMHBPHxDFxTBwTx8QxcUwcE8f/zqH+d2RN9F9NdTFF5SqmZ371dySsTFE+ZIuU
T5VPlE7lqPJ35QMlpHykfKYcUT5mWlaDVlrxr6gydtQ6Po4zF2eUteIfX/2Wvkxt5cR3a5j4R1wN
jNX3rluzfGAN1TB+NdMx4//i/7bjlHZH2dHxbxii/yqs1noC/JUJ/N+CtpM9PIEJTGACE5jABCYw
gQlM4H8e+DibLKHRsZsm8J8PvB+vxbHgv3nMYo+wAbaKFbEVGK1PtbHonzH86494V9fdMTIc3ntw
ma3mM5ZML/dP/G2n+JsG7LnMm3d8dWz08pgPDPtRjFH//ACf/wKiIiMYCmVuZHN0cmVhbQplbmRv
YmoKMTIgMCBvYmoKPDwvVHlwZS9Gb250RGVzY3JpcHRvci9Gb250TmFtZS9ERURWSVArR2Vvcmdp
YS9Gb250QkJveFstNzMgLTIxNiA5OTAgNzU1XS9GbGFncyA2Ci9Bc2NlbnQgNzU1Ci9DYXBIZWln
aHQgNzA5Ci9EZXNjZW50IC0yMTYKL0l0YWxpY0FuZ2xlIDAKL1N0ZW1WIDEzMwovTWlzc2luZ1dp
ZHRoIDEwMDAKL1hIZWlnaHQgNTA3Ci9Gb250RmlsZTIgNDAgMCBSPj4KZW5kb2JqCiVCZWdpblJl
c291cmNlOiBmaWxlIChQREYgRm9udEZpbGUgb2JqXzQwKQo0MCAwIG9iago8PC9GaWx0ZXIvRmxh
dGVEZWNvZGUKL0xlbmd0aDEgMzAyODgvTGVuZ3RoIDE5NzY2Pj5zdHJlYW0KeJykvAlgG8X5Nzyz
u7qv1X1rJa0k6/TKkm3JR6z1ncRJ7DiOYzs4dk5ykTjk4GpiQxoSEsKVAoFyBBII0BYcmoQEeqSF
3n/KEXq+XG3z0f4ppi0vbSlg+ZsZSY4DtP/3ez/ZWs3Ozl7P+XueeXYBBABowBigQVfnIiEFyOfK
F9Cid+UVy0cK6yOvAwB/unLHNm/uj024A6+/tmbk8itkH//xHgCocQAkE5dvvGZNYbx6GwBDz65d
vXzVLx5vDwGww4Y6q9eiDl2H/J8AyI+g9cDaK7ZdXRi/1YWO8duNm1cuL6xvTALAPHHF8qtHJMep
99F4fD3eTcuvWF28vsfQwj6yeeu2wvr2j/D2kStXj3xUlh1E4y8AQN8iVeNtkgPAj472MfCC4oep
wG36l8CF16beJMvfk+XbAORbyF4fo9YZ8P/zIy9+/+8/cMX/1W4fgF+Ac2A5eAV9XwI/At8C96Bv
G3gD/Aa8AGaBVWAzojgAW0A/6EbjrwJXgGEwDzwNdoOtoBsCqEW93wI/BR2gHdwHbgeNADO+nVpa
PMPzqGcxWAnWg53gaeiFXtCF/n6DztqG/r4D3kPHMMAY2ACuAzeAWjAH9BVHPwD+DP4BlZClXNQy
YEFX+iT4A3we3AVuQX8mMEJ30s9PvQFfpSuoNeBqdLRxqp6qAgepV6h6sa6nLpuprqpMpyqSQnki
HotGwmWhYID3+7ycx+1yOuw2q8VsMhr0rE6rUauUCrlMKmFoCoI4HLc1952wy2JOn8/XnyiuOy5d
H6eD7Ae+cWC4ZJDzMzu5PrPu/sy6Z3p9wTgwjbfxzS34wCdA2zvjwDgOTeMAnwUa56MzFXdqXbWe
b103bm9eNTyM9mjhWe9421+F4qWQY59QKZv55tXKRBycUKpQU4VaaOzICdjWAEmDamutPUEBuSYR
HzfExqlgK/6uHxcPDKMG34KOhLYYL245M3Xu5pmbANqt1DIWWnBc2jwuI+f1rhsXl4+DA94T8XP7
bz7DghXDMfUqftXyyxDllqNrPAHoYOvaHkzHVvwdXusdZ9DBycKJeryta737eUyO1rXDaMm3oL2+
sB91K5r79vrOOccN6Ld1XB8bb0cj2q+94KT3t9rWefHq/v17veNHFvbN3OrDy/7+fhu64P2tPDog
Oljr+iZ0KzYhES/cU5EAq4bX43OuX46vs3W9d/+B1eRabybXQIa2rkWMWf4/jdq/v3UV37pq+aqm
wtGbx8Ue8gN6BvrIDSLStfQXu4oD0BaGbBlu6fcViN3R3deML4xf3uIssH26Z7jYgzpaSxu9+Arm
oAOMe1d6x0F3H4+GZvFidRbsX5klwuPrh2ivrot7jUuCLO/d/3cwDof5ifcu7Vle7JEG2b8D3Gzj
24b372/jvW37h/cvPzM1toL3svz+Ex0d+0dah9FZu/rQXmemnj3gHG+7uX+cHV4LaxHtsQS0dffl
nD59f2m1q7QKkEghwVKR20FUQP9zij+IyqCnz+dFhFrc1+9EdOrD7R7ULvxiQUKCm0U8LpIN02h1
dpo8zcWmz4el88AZEaxAK+NjC/sK616wwvk0EIUY4scw3nKutMW8GG8ZK22Z3n2YR2c5CbDHNI/L
Q9P/OtZibF1bOw4t/2Hz6sL2cWNzH+2k+gstyknjljKGNL1+3BpD7XBsP2LCy/w4GxuX9J1z1vd7
WT2yAJh7i/iOhQN93tb901JQ6CneKZYDJOr88rX7i6qEhX6cau7pmzmwZEuQjWg6wcN9C0+IcN+i
gb6zLPKh+3r6nqYg1Tzc1H8igLb1nfUCIJJeCvfiTrzixSugAwvm05ScjHeeFQEYI1sZ0kHWV56B
gPTJS30QrDxDFfrYUh+F+phCn0j68CdBHCAAst58DgDFC/n78w8qFhMCz/ycxj1UD3gIyJB3kaBj
UUBEvglQ701NIVwDRXMP+Cnk3hbepsRXo4lqcIG94L1AI+kRUxfcwepbL0Dd69zrudc7X2e4V4RX
cq90vjL0yuZXpNzLwsu5lztfZv7rZyz34ksO7ufoi3fjXzLaqx+/r4y79z4H91X0e98dZdyt90D2
Ae8Dtz1Aex848gCFxzkfQOOO3yXn7j5cxh2+y87dib533e3lzv0R4u2mo/Hy6qN3yLmvoP0Poe/t
6Is3hO/gQ9XitxTa6uHnRp4be472Pvvys5T4rFJXzZ6Fw2dHzo6d/cvZv56V4MH2Mwp1tfhM1zO3
PUOD01B3mjtNgVPwtlPkHMpTKm316H/D0XfI6onfO7jqt5/865PUk49w3GuP2Lljj6Q49rbbbqPO
H7FzD6Hv2BEInhCe2PzEkScYsIJdQT34K8i9NfIW9fw3HRz4JtR9j/sede7bDu676Psd9D35bTf3
7V1O7sB+gbsJfffvErh9e+Tc3j2zuafuh/fvcXA37vFzX95dwylyuzt3U/W796S5X6DusT237aHe
2gP37HJxL/8R3jDGcyNjY2PU9bvmcqO7/NzOXXFCj4d2+YPVYBcc3jWy66+76HhCF41pwxFdqEwb
COr8vNbr03k4rdPl1tjsDo3ZYtUYjCaNTBrl7LYoZzFHOaMhyjF0hGN1UU7H6tVqjVatUKrUUplc
TTMSNYCUmvMIHoqTQkGak3ZKaZ1O0OV0nTomp+5SU500FEAOdCLoxDjr5JyuVs7RNXIOZOVcVxqO
GzpAR0/TuBGi30VN4+lYxxk56B5PxTrGFV1L+05AeEs/6h2n9iGV6Bln9iEt6EF+bWBp3xlox5v3
EDeHWmfg2J6DB50nmGKrvz/mHl/VsahvfMTdP57Cjdvc/SCGPlsLn9i/+Zx4g8Heb/n4G3zLiTff
IJ5w/E3kJP+AgIZ4YJxuHR7/A9qkwJe5qrsJbt2Gd9sW2xrbtj0WW7Z1GVrbfvF4aPPWbeR8WwvD
tuL1bXgZQ0tQGLWt+LN9+rrINW7Ho5DGUliFZUCKQDj6MT0jpRiAv8KLb7xIFhVJn96nD6IFRKM+
HpOAT/AvQA0MW1+aeg/+TjIO1MAG/KJByTCM5SXWAr4rk2nODRmhURicSAsTIDeZEnIVSWiiaF4J
qyqr0ymL0STl/aFCG/66yb7A0jg7m52tWJjNLsRfSSQ1+UL+71BF1adqFsz/hM12duJN2BL1Uv9N
Xyl5CuHckbPAjMRyrkKXyYlooQNO1kk5nclcxwJaag7Iy34DEmyCSiRaaxj1bE919exAskMqjaLD
6AAHBIS2GQCSURjVdQvdnd30oDCYFga3GKw1QlpIg1warU1Ya1KoOxbD94Avu8xisVoQuCXtUKhM
KpVJi7eTqa7OSC/emjWEBxTbaK9qPAC10b4y0qCvjPosx9cmFjicnqTT4FWxXFUypNU4zS7B5bYv
iqx43OGLRn2eu0fKem0uNxrDqbXl4UREq+KMLmHz0MYH0QCmI+iPqRsWudxxuzNsNrrHvnTVAavJ
FHLbol7HQI0y4Qv5g1FV1ZDdE0MjTCbb8YE19ziM5pA7sulqdSSA6HobKGfuRFGZCtSIPPVLqGTg
T+W/FGRQBsjKN6W/BDJWlpPRspymU0MhWl2YqKlhL4BSAxHIp+f1viqfPq33MXfmZ43mZ8HnR+Hz
8G+4sRM+n5+FzrQ8/wD8BvgURR0x0Sl9xfQipxW0lFameRp8Twb0rJ7SC7acDZ8hPTkhoONPTlQk
g4hoWigra4AZ9H9RfL7RGI0Nh8uT82yeqDTd3NFS19vLzx4rT841N3vqPXx3ZVtdtHMrOu9i+Ar1
OLUJybtfNMOfcZSA3CniPxRhF6ThqAQS/qPzTeBbqfJRj09+neqBr9yP5e4gkvcH0VWrQJno4BSC
glK8RANRyWZQuCVlpZRU0OQIWSZiQJgYJFd88TIfLMn21hmyXJHvo9dI/je6ok4xhJwkfJ6iTRRF
s8i1JymawjK6GW0dU2szAJiUmgzyaL8T1agBQCeCCJ3Fa46hU8ZQqyK5V1Ie27vzBQh5SK+ZnH8D
dULyvz9aLfsq0tjLp95mbmAWAivgwVrRFXUGfbXOKt9sRbu5T7HELHfeZ9b47lPYbTcRt6xwejKA
ZmkKrb0t+tRqqo6mg0FRpcl4burSQVYHdWrcq1OrVGiJLmJwy0RMj65mMIb0fiKHiQCJqhQ0pKAM
BR2gKyneT5lNhnTKwNBibkFL27kd1/8019SYaxZ/esNNL7iP3nzLsfsPHXqAfnT+S1v2/ap9ztze
jgWvXHPVjxcuGLgsH3gfSvMfv//7/AQ0IkruRmYsgu7NAa4VVcr7VCpW46Aeh9jbflOlziiJi0YN
gC8fsEoIWNMBJeySw1E5lKMbPGk0UnWo8a5ow/ckN2g0aCl3OQVXzkW5RAWbiQ3qDTXoLtFtptMT
qZSAPjFM+YlUDlk6ZC99VUTFq/R8VTpVnUlLpWa9iag+HZlc5hm1cb5/ZTZ+LbiIlnJuxw53O6WR
KRMJ6js9XeWNT7ZOPsVnNCoDCtrBJgAYK7qfJNgidklkIG6RsnFBvl53jWJL8CbdXcFHg6qIF4mF
LKnSZ6Q8dDj09/EaSrgHmqw3uQHQ3iS4qRDhTyiUElJQSOVSnSkkWpASBgcHMZsMNTXIRAsTNegW
anKoifiF7q50G4X/qsoQ75fKShZvmoEFruJ/H2P9dIlzuCk80t65mLe6blzXuM0tM+caUtX12czD
y178WyxZdcsdS+5K0nAfNz/hFENRUeAGe3duTye8fdFQXWtt9RXliewz98y5ujw9p7FscRhrh5g/
xFCIBj3gb+J8BS1tstMGuyHE2/kQPzs2v8JWMbtuQaOtcXbHgoW2rtBAeNHsyxastA2H1oeHZ29e
MNI40jTSdc0i97wO/1d5Pgdy1bC6OnpfTqPA0lCHGaxQmO/DYFjEK6CjlS+7qZVIc6sBU67VhPtb
k+mbamr4VlrqvAl0s91UNxYTFR7WTQiM1v8kOvDQ7u5eoRcKvbnezl5ap75JKqp0GakQm6gpUBxR
dwJ7lwkiRxOCoQbrLaJ8jJAfyxcypRXJQei/6DowpYnPwTJFGII28UTEisyRfgF/rCXFk5mLDouB
f1x2XzY7K1lVnzNLZUGnt02s3xyNV1g5bkP37iX7r92xsbLZbPfKZabcrKqK2pqaYxuue6g84Xd5
+a1LsqPpqpb8f+UPCeHw2kxFZ13Iu8Ks8Kh1hnC8/LpV1evLymJbD9+zc9Su1vrl3sFosG5eqnKj
INTOqUyPhFOrY8J8GysJl0WuX3nuL8geVSD+1jMdQAk04BHRpFGrD8qkJplMCiipWqaAmnsJsvZh
wkoktEwj0pAmnEKmkpHR6gOAVXiRHSbswPqrILxD6/mTmC+o8Y5oLvBZp8OsEHQQscSEWTIYKzAk
NphGLl7AfMhh9Ub019fUoHDtdKd0s3RUSg/27y2PSXayLyCLzhP/BtP6tE8PmfqfnZsco769+2f5
7ZMXBvI18Ef30ks+vYO6dXILlt+6/CH6AvKoAiwTuyM2DUvVRW06tMRtKWlL62JxFrdFvFTJzM6A
M8alnXVcs7OD62K6nEu5YWbYuZEbAVdCNhqJxiIHQ0FTKBSMnpl6TXRqtRTZGS/xLSejQ9GRKB0N
JgJYKHl82ICoYTOBgO+riYQ0cg+2Cbb7RCkiBKaMNIRpbFCzmVAoGRSDVDAcDio8+7EL+KZCnUG/
H4ohTFZaXXABFUIF5NAiV9FZMVQxWiE16G5SiMgKKWbK+QQyLgJxTUUJz01g4cbb0JZBNAJ7Kjkh
K0CrELOCOAsw7TQ/L/hY2MuMPrOPLjiRjqYl+d/+/qkPUpX1OYtUHrA7OlLilWWx2P1jXQcyzYup
/5rcU5k41DfnfviLymPX/Sr/p0c3peflgt5hq8ymUukr09lbNx08W9/moF59Ot/nzSWKfjIteRLY
QRicF5OiBno1YXPWUGMWaVEhakRto2GuWQz0G1ZQq+m1huHAddpRw3ab0RlS6jLhM1O//Sb6RfT/
LfLUuoz7qyarVcrepyPCTBymjiNBDaNjQvdJ7V4Tb2R5lmJZtWM/wKMqEeEBkWUgJZYJRIUoFKK5
aGeU5vezaqgmW9WEJWoyRl2wLjPoLwwiSmM/PEjWaiawdY8NDsKZ/pgFQatMShE8apCVzAnxy9VM
uiM358Tw5pM5sQ0+DlcbBn4zwfc+Nnh84jd37uy4vh4y9+y86g744trT4py27o55r98EV8N3KwbY
tvyvz3c0TIHfPvxCtkm9xP5u/p8vYY3oRxovQRqhAcfOAoDk06lCVw5teEkjt3dLAf6EQC+gVJgQ
aYR0VCr6HnS7lJOKUrWUSC2lpBQRXQrt4qLiVD01j7qMWk9dS8koSkUI6FFghFSMHGmdqNBmlDcL
KqiyYIKpsETGii6wQCWs/Vg4kektIqgYE8Mgylcwr0jtGclkZif1YP6qJSsiXIVmFv11+q8fH2X+
weg1GxbBfTiOWjv1JjOIYiKMsFLQKzpCY8johHFwYhWRKMREtS4jx4aonAATXYYE1itRw443KRiJ
XmHiynhj2ljjropVpea621L97t7Ues2wcbN72LvSP5zaCXdKRmTbNCP6EeuV3q3xmyQ36m/2H7bf
5fu6/RHft+U/NQUUUZ+ZoZ33XZQ0AoAw1XRM8j7abjtwm+GIgTKocZfBc2bq45O4hRunNRppneeA
Gik+6UONj8Uw7lQr1AYzIw0cwLwsCmalUJmrHK4cqWQSB1hkVBD8JYQt+Dkkh7EYXsFiWOhDFC7F
o9DE8P4A9ljY1QWmNZ4mYmg24YjJWFkMstAqFsnB/JvvvZH/x/33ju6C5u997y9fHnv00Ae3b9ly
27FXO5qi1emKp9YMD3zjtv0Pw6sf++DNp67/Rn37ExuOvv7y/atP1bZ/neq+9p5DV6y7Y1Hygcm1
uaGy0KJY5UOXHzp1BEe0PflbGC/TjeKSMPiJGOFhGjZD2kkLVIyuVtRZOqlOupOZZ1msGLAM+C9X
XGFZ59+qYD2YtFcg7towi1144f2qyqTVSh33mTSyGaaWV1ldspiMksn0VkJ4634AWHRmLVF19edU
3b1f0EM9UXU9iyVXT8boL1F1JMozpHiC2FlDSdkh0nZKJmVkZZlqQyk2BekUIPi7SNRMJbKt1Yx3
0+Wr82+cNAz86gO+++iao3+D1hffgorXsJLfuXPBDVmaopgn8y9uu/Ju2wDbAh2/aWvMf+8l6Mp/
P//pu1Dx4smHX6jJMTaLNozu6RkUL/2EfhPFS1aQEYMs7UWRxEsKHWcWzJT5JZ3acEnwBOyCvRA8
4fuYGCwEDzMiKP3MaOonOJLqqqnpKkVV9OJsVxduf/rOdHxFgcfyP5L+TDIAulCkPyGesIfRCe1+
NsxG2LkBS3COd24VrLXW+usbrlRe2aZRNMT8Qo2wMNlc1VK/sEUvGjr8c1KtHZ0Le/RdhgF/b8fQ
wnWylYbNkXXDo5HRxLUVozWjC0e7Xc7hhULyxlRFqoqrQlFdbQVVUVE1sCcIglWAVtSNm80rhBW5
FZ0r6PZfAQWLIMvgj7ikkHRxjK3nB7HsD7w2aIvZ6MYf5lBQhe2Drqtr/g9pgB0m0SXkTAcnBKJT
wkQSFrWsuC4g6Ij4v3fyHPpUwEHkTyVSrFplIaqq0pCpDpTwIPatZWWfC8as6UyaLqqYoYgv/Qxy
C8gPFN0vDE27BrIu+XhVfuLxu/Ovb992y9hVW+GiH38jv3DhwvyHLy7eIZMlr8tFFvt8Zc01NafW
ZZcopbE7v61QVUa++vLceXPevHVfPr/+8rFVS/s/OPjgRyvzz2sb6sUNwbJYRGjZKFy1ZMPylSth
2Y+/Bpt2XXf35qUD745+mH9q8XxqzhIn51u/YM6p7kXX5maNTL5jbzSmBci/v+Mn8+f1rb98Vf6X
3zqVnxgcGOjtpqML517ePvepuYuXLutFsjD1KwAkByUPgjIQBUdEQeYzQ6uvLFrNZb0Z32ruS44t
/hFeFYlEwwr59T6vLxJVam9wuTifDTkPFwZTftSQcAqvmbN7Q1zEK3VxXh9jjmPvAkBciEPzmam/
YisrrTMr79AhRaaiUTNHG8sgxViOmhE7rTUYZA5iFhYdkBWDob0s5h1ZyjEHSQiGGUH7pEWiW82l
sMwAjGlIcJEV0rTk4OSJBZczzI68zsVrNcpdnZPvOhbYw3HzBkit7oK/0YX81rn2yRd+db5d4rEo
HErY0LY2HqvWh+NMeztlZJ11lVBF3QuZT7JlSavWCOEkFZr8LfJnQygKfVtyAERABrRAs/glpYRy
W6LhcCCag7lIribZ0tyyCPbwA+Ge6KKWdeH15cMtI/x14ZHoNeVbWqxloYZDOuQhqMpKZfqQ7aid
bjqkOqos0yeIHUvsrPA2eimvHFPMa8FmzksctNeCN3u9+iwZl935IEL+BJCqMiQbQYIvmiWxwJmp
j0QDPgJNtyGcUpnbZT+iPKKfHqZX49AArf/pJMbJqPE+0jAdaimJSUU4mrg8/alW9h8Fx3ThwmSq
iKNiW4h5JYECbiEeIhNL0FUxUptOcExH/wWXVeX7TBBWNg1h9UiDjMVmwa11NXT3tjY/PjA5bLvM
xDmsfs9cO3XrvAO5unnVFeVXtc66+3TQPbbfu9w32r39ycfvF/ssa5be+QB1Z3Tf8pV3COXJdkqj
0ApB+lN/JYtijHZPiL+6t2N7NJzRKWTC12Nr2rbvoeHkW9H86l0P0zCvzolPIi++YOotiULyBCgH
D4lfkmh1Zorx210mfyiSdVf5kpFkYq671SdGxMSQa6Gvy7+OWqW8ltqu3BY1mUUVm9lsGEUoQsR0
Nhj0tP2QmhnBWD54OzDGHo6zD+vjeuPDhjPI2EFup5TwWMrgIEiqxdSXEhghfUYokH5ikP3HRBoZ
Npw4xhExgg0YTCBnNrhFgo1WwaARo5VJG/lQwVaVdKQUKmSsUoY6P/rfA/3r11629KOD656YH+lS
dLNiLPnlxcuPz6ptahXFpzYu3JdKzbN19OYv+FYtWwZ1TzwBzatWbqwUWvLSud+ob5nf27Pw43v3
/aF38XA6Gh9pCpw/hbzKMmRJTiCtcAEBPC9aVF46YXFEuXncEDfk3eCT84fMRy1npn53Uo2CM9wQ
XWqttM7CqbUZCx09JD8q4/AmvJTWydCA0ziR496JoOubJwkUQLEDEVaAoy8jJhQ4UyFWjFRQZbvM
R2RHtNPSrSXSrS1JtxZLtwZLt5ZIt/ZUsijUFy5g4mIaAxIfIDyGl1iCCUJA4pv6vPjikKBI4YKk
ohGSE/uu2JR//47Jk+5Bncdp9XOzHdTGsY8u23nL3+fNaf3JdZHL7es3jX6nrqGG+vap/D8WL+5p
V8k06QAD/NWsTku1dzb359/+/q1/7O1eRsNPvr20baCr5w2c20eUVSHKzoKUqOw3rzOvqB81M3VI
808jz90ZhHi2WUQgSFoXxBm5YEDE7QCZDkTrgWDiUEDnElydriEX43LpKaPReYg9qqfxpBFFQgM/
oSaoPEQfpUL8wwFRqc0ETA8b8a/RGFDMehgQS2PJABxhGwg/QE7MQVdiF/sQ9ZBimvYKQntFifaK
adorCO0VpxqmaV+yJ8STxyaE2GQKW5I0iTvQD878DKYnUwKGywV5h/TnDIq+KO+8vijm6Ys9RelP
FRN3EpXzkzWeVTqv3cI7lzqZuR2mPfVcb+atI/PbnRZO0tHB8Eaus/GIweEYWOTbGAwt1Jev1sKH
88twVlKXRKbEl2Y1Jqo9/8S8r8kZZvK/3H738tjkL5IbbGW2fK8412hUMYzZkHy+vMA75inEuzR4
U1RspkYpqtMADdP8MmB+GfSEX3rcW43W9QbHIX2nAiqIAVGICDPX4TZaKlI8APJDFUdTtC9wFAXI
D+v1UVjkjRXz5l3RVOBNla4K+h9SOHdVPMQ/FJ3mTpRwJ1riTnSaO1HCneipyhncuTDNHgFzZjI1
zRWSIZrBmEH4PzFh2lNfZBzzVId5zyxucfX7R+d2u00+ybx5NG/yLBWPOny6VY7JexCnPM4Cp/qZ
cOdJBaL3DzmvZbBq8nx8xB505q2+SlZmgshjKwq6VOQOKFrx7yIr3gjOiXOkgj1iFJKCKFwW7Snv
Ei5n11lWJ3ew11g0/h6kRpu5UY7iOA8dOmRnQO4oJ0JRTN2hMSaRT8/VjIIjUgYTTHpm6j2RRB1S
98Meqcf78K0cJPFqOYpnORsew3HNQvPmZiq+00hMu5GYdiMx7UZi2o3PNJVMezFaIeYdUR3RdLBg
5DG1c4Xs8yAs4B1szDGEDV0CYf+Dxa+qKtFa8l3bQrvHTlN78h+N7vt02dDIhhVDUHbX1U+3YB9g
bqioOLhiw2MNs5oaGxqe3dF3u0cOrQHfFi+1icrQGhSGBzdd3eOsF9csG4LsYw9D85pVm2sjLXm2
+8FcrmNJ76KP7tn7lyX9a6o9leuDC6KNOiRUcxAXVgAg5ZAGNIOXxWq5R560eWzJsCeclH6chAgP
IgGiYjFjurI6wPiO+ulmSOkZ01FjJTwSl++aVQ2OzEL4kTgA3BDLMIVnabHIzrJhWs463aprFVrF
1pFWhjccial2OfymI45piXcQiXeUJN4xjXQcJE/kKCEdx6mWEtL5MMVOpj5MFTxDaa2AU9GXoBwk
8lsuzmz4/q2MmwucQyM+21PYQ8pNftO2VO9xTa62+vVL7MU1h9c530XNdy00+a3UV2eukVHtlFyu
riiD/8ob+KRBYcAKQHoY4K3SYQVoh6xMnfXlZ8MnL+35FBb2wBrSiUKAnyPecDjTbNAdZWmOOgoN
ODMK8ILFdgX9kvIMD2oYzoPz9l3seXg+KR+T3yY/ImeSvk7fkI+WT9NbLi9OGl0g9JZjhSH0lhML
g9Y/JRkUOeamBlNeLvd5N/tGfVRpKongykFkgS5ciJG5JKQLk6mZU0lfTEzq55PXO9eYfR5LxLPU
TY1yvd6Qw82bh3yYPJpEmGF4gVWbMTE0SnW175NJX1onN8KCnDK/IKj+trMgPDUm2hCQMxqxm0Qh
uRrFMl7sHCMFY4tjdDw/hu8LN0S2YHVjhiOOXewR6sgX+MML/8YfRi9a3AvFNGXRC+IqAaT+X+Dz
LrnvosVF/8wvPJ98zbbUgPGHdZGTWuLqN/ntGpt1aXewK8DXaSNXmOGj+YF2SinXpMrojxAuVlsx
OQwyda3v0/amOSaDikFHZsufq0VUSQIg0yKq1EGpWLFEdblqTZgOR8JlkRuUKpNSqQqXhSNl12vU
Jo1GjSta0apMC88rdiUeAg9VYQphEqDGR2QqsQozH1MBNd4lsxGokRdJyFJ1epblvHYsdN563oMB
HiGehxDPg+cu8G4erMV4N9T4NZJInJw7Va8GlEqp0sQZa3nwaBltrkOBpe2otaCwkymcDmju6RMN
OhWnElR04Sen6lRJBgf703AG+Wc00V57C6n4vdpy23ROfsZsJkR//1bvIUQdnxFPmXbyoH+DiXPr
8q5UPq1Bnmy/efL5xEon7/C4uIE4vADvgkuNTghfci0x+W02v+EyZztUq4wVQUb+STvz6qcnrhtz
mUNI3xmLxbVtH/XLXJfd6aDaP/k1fW3FBsNMJVfqsVzbpj6QGhAH4+BF0Sfxl/GdCpr3+69XyE0K
hXyOAkaxpkejcn4MnJfi9CaJRjAH7Jj2UhdxeyTklJaLCnVGWk6gigbthsyaYszuM5y3T3PMTjhm
x6mBEOaUnexpP5XoVAwpNitGFQyvkEfjgPYiYy9njUcNWL2FgmGtGYQzbK4gxPTpGDEIFyZrENgY
RBxhiowoukTEhn/Pg+mW1ODaZg/Yl3x6jPNab7NOPuscY3lkVQPXheCdtMfrcSHr0yhpgR7WfssV
n/yNuWkycN2XXRZMaIrXurYeoJ4rv8zuExChf0gd/dIeizGAQAYFuqbelByTfAMgYQMHRbXCJ004
fOYE47vDTEQVQTfcEMtwaFNrnmseMNNmJnFHlaJVsVhBK2x4BF4iQ2B07qQxgIuRMF5ZCOMrBBTh
bK6gy3bqCIooFhcQFKF7phDGFEIYFBtiIJEbxB24xMBgxiGMlL80QKSn50ovRQvM68vWbxwe/MeB
r3wyMHD5xqFl/9p38OPabLomk3l0w9WPVaUqKrPVx67c8HXmDyvyf37s8fx7y4fXbl65HJof+AbU
rVyxdv0nTy9955Y7PuxdPLTpsr73brjtTwN9K1chGi1FlvUIedahAtwthkW6ke+IdPlX+ob9I35Z
+R1A5pWNyGiZjE0c8hzlaK3+KBvaScISJ8JUwFSITdK6NJemdA+Vy3ZxD7FHrNMG1kokzlpy8NZp
A2slBtZ6KvUFkLaIZku+vDj78+/1OWWBFyeZMcZljiyZP+/0mgetAcPS0OSDxOiagqEOJ7Xvh//M
v+y3OH38lYsPrtm4l0ls/lo2W5nv5qu0MjWWKGJ8GcBntRoV1f7d/Obk5ZGaHXGhcvJgM87QIl8k
+TGJGurB98TVOkrqU8c5ypHQ1/MUX5+O1VSl6pup5tjcqoGqlZErqq6krqsyMnBXebS8XBtl7qit
1WYPuY66aXUa0rqjWi+AlTsDRHQCgWg5bdY1cA0UAA2ah2oku9xHtEfM0+Q0E3KaS+Q0T5PTTMhp
PjVrJjkRNQfJnMbEYBEgkWihRl8DceKuYDJDVNl/ouzFfFAhf4dTeJVFMkt+nL9h9MWrb7cEDAPc
5GNFMtu7XNStAw+IDXNTFYld89YdWB1v5x0LHJMffGXvE7v3n/kR9N+bb/gMvSm+WqvQUe3BSPj6
pd27ymM5y4Hv7KuvMWi0kP5f1989+eAJZC+XTf2BSUi+BkTwD9HWJBIHrwU6wNIVOE5I4ZkMgovQ
r+7M1NfFQ6hXIZEFLbWuhhCIepOgwZsUe2p6GjY5RsAuZiQwErwyM1K3NWd0cbvq6nKj5bC8PEEb
G/iG6rrqhra6tobeOlldA+dipFV3hJlh9YiaUiOjf4fUGH84kRAeLm+oo7MMpn4x9Tfq4uz+cr/a
PkqfaRKaoPJhlUrzsFedVIvqLjWjLlQZ4rQRjqzRdzIW09eQmWacQhJIDgknWXGAUeITyevBwnQz
CTJkPJ3+XInFJRnymaFHwZKgf/oXiVj+3Z8Pfac11qVdaG/OVB64rPVyr5cbHmp8bNbVe5pm1T7Q
u+KrYqRLvtCSice+NDB0Y2/3nINN9ZupA6mrOr/1YV10Dnxn4PZcXVvA5+uvXXwo5Mi5qp86uPDm
TGVdfbglH1n4lfra1mv7LrumjE+7HU2IbzpkZf5A8NtRUbeMWcZvYjbxu5hdvBSUnZl6C4XFmkxZ
mcp1KEwbzEdNRlHHZkwk9YEaKIS+zXhevcsZerjsNtN5XDI55rzNyTgJrHNisIJ1wYkhqwrzwUkK
W5zYtOsxhHU6Y1GE12JDsdEYcxHGDl74cIKdRItpEIuMT/piuPzF8XGxeKU4wfqHVoXg9rT7uGXh
Whdv2OqdXOHaavFxtdxlUV+7x1OuaGNeY5SBlfHyVgnDfHK7L6OT2bDYqxWaighzNS1h2hOJ1T54
Pcb8c5HHmkR0qoEJsTIQDsSpquhczYBmveZajcSdyQLGcdRJRy06UphBcgIkzIoWyjNu12DDgDeS
Bt6CG6IBb9UYX8q+laWyokaPDoSIe0qrz4BsxZmpD57BVKoYA9JiBcWlSMNKMAaLlU1KrJTUS/DG
manfiy68p1Rap6sT6jbX0a4jgV3OI0mjaOwy0sbpmiOjBVstIz4qPhZqfCrq8fGMpGbJSNwp6n31
JD6ccTrKQEivlNNGn/RkDMEMBDQAyQPiLgxMSIKjBOVmlAn8Jzh+caNk0rXR73es6Op8qmvsxy3N
LVbevsBOdboWo3DOHiy7cfumO2MRv5fjr/FSLQiEIGG4be3k3TuezFYLzTU1h7rodl4wafUXY7i/
1uyszrS11VTvqKfaNh+02F0IjcCpT6fel72HeJuEO09Q+OEK0egPqmgNbxVoK600aowqVaoCSyfI
oQ/7Apl5dp6Q/p+PFR/tVHaqKdafU+bUuCn6RH+PX65UQKlfzlv8dfI6ZW1ornyOssnXFpgT6lMv
4XsDfeFlwlrl+th1yh3q7b6r+R2Ba4M2v9evVqluUCl5Pz+zzQeC1wcjKqUyGLlBqpAm/dDvvV6t
0+g0CpciqskpUppORYtmUDGg6tGsV6xXXSO9RnWN5iodq9Oo+IBCKrMS9JAhU1ApXUpIiamRFGPF
j9xJdd6IvFLTgsSd1gRaeZjkRX47T/P2cgHwEstRKw0wz4VBXPVsrYHC9IzUXvbc5DliLl/eK5+U
oCUrn9grP1f8QZhrcAtAIUV/QVZkUormIeQpqqDpBTkhZtJghGlYbSga1Sqf7D17k4uPse3fuuKy
/L35A30rXwsoeI+92Uk1z9sgpazbt8IVK+Dq2Wv9NvXgWopGUmLWW2rSf5y8O3+UafnkW3AZ9bcx
LmnSYylhLA6lT9mX35DfyLg/+a+P4NYvD7ba/OVykhfTFDP182GFeAMoV1dyUpPWlOAqL3P3tKxO
7kgq3W5vKlVeab9Bo1LJWlpma8ReDdTcYLdXet0q2a7ZLany2dnyJeVU+S6vVxa0B71xMTq7yp7x
1ou1s1vtrd554tzZS+w93svEgdmr7Ku9V4gbZm+zb/fuFK+bbasRtWympqZuODwSpsKkAAjF2uFw
aAhuhqOQhngOBUK7RjbbW14phuqUpvl4lFbNZubrOrlOoZOe30myqCF0JINhs2nURJlK4+WmSLa2
jgmhUFA/H4WCpqPG6dyNnjA0jQOLQcJUnGsWpheIt4N7z50rzTsOIq7Kz7GSyXP4F/N3egoSV19Q
l0xAInaGPs9pXK1R4LFZWrLqFkMR5UhOTK7tXl0eCG+q7nt71trJ9x0LHZU5r/jj+bUn18QqIrbF
dur22p0pP9/bsOVYRz+lty90VqZjXXuHun4wwHXZbQtd7ZTTpVtWK36jc1v+rNvH4dlLlcbVGO+D
so2LoeTOXKVRpUFCQdkdxqHq7L7+e/4R9HoYnAJR22szl5+64cr8m19OLNRpZShenHoNSYef5Ove
EmNirLOpKzbUNBzb3CTN1mYram+QKk1SqTJbka2tuJ7nTDz64gDSjLlRhhpSpRqA7QjEcrx7axRG
gem8OqveFTWfv80N3aSmw41NvhObaTcxy253a0srLnvgWjtbN7fSSpJ2KpYB2VCDr6iVckqpJd7Y
DJjI0ShtJPPGGMETlsZicDAGS3npC+mJGvZCmhR/kEUshkL4z4bycBBOM+RiiH4pPP0idmKOGi6m
Vf36uWyZK7zgyyuDNjdv3uibXOsasQScZc76O6p9aZ8NqfDgmh61ShNghRWd9z/id7lb3HACKbBd
bXNkNv3+SXHB3PzfAlWs3IqdtkqhqwzBfnZx5TaoHa6pxY4YddssUo/V0cz1n7hlEjpdVpdcLqGx
zf8k/44kOtUBaKA/DX9M0bSEEvS4Xr9Yri+JfvyKRMi/s5pEq3+k36f/ARpAB9SeBfNxjSN2m5zc
oo/Ko3OvNVzbLE3hEj0WmU5VCC1yhy0hxBkLZoURM89iEZSbQ6MhKoTnLnCd5EkV4iQpmHRiEBAK
uQ8LbMPdtGX2XUqLl98dwQMjGDpVYW5HIlUaaceebDZn2QOOVXlJgog46aoQLsysYrGHrnp2Pjdf
mJ+bT7diV062tH6Z0wgaSkNKfzQkCa8heFijxps1z80rRCZXTsSKqdsLGHBN1BQkY4KU/U2QirZY
qWydVAQNwliw4NT5mQ+tVAcyF0Nl0xeXEhfjZ1gqSMDOn35faE8sGNRIG+9ct/lWr9feHUhAY1Jl
MM1pLu9kjblsSmisTIzN6tmZTldJkf42+vNHF49lUrVLmts3Bg1685y22fP2baoZCHgErf4yx0rN
XF8ww+lNC3x8bXu8vMfnKrOGgqOrbn1jd1k5q6Dgy/ZkwD8oLlrQKuC6jr9O/YypkKrxbCxUi3YD
qbM1kmUFmVaqEIsAC0E3TLygUOOtEtZEGMNx46sYF5PUJgHIvE4nrTMBqYXm73KwMlniMG1pA71g
DaDdu4sFmSR6JLESAW4AV8dFMR/Btyp0FUJFZwUte1Qut4Qo3BnaY3xSZcOSp6Lw7qozU++R86kw
4FNhy6Ai4Y6KwDh8RJUcX4WKXCvq/YDAOFUJt2FOx1KFkKcwrULmUHDVVw1Cch/iEL9YTFuo9pGV
zUBoQaveWqr0LE3rluIepiL/p7ML72+d2yBhOJux3wnXa2UNh9pPf/iK1+/fNL9tXVTKezzzMtfe
Bd9/M/9qKrpVO/fl5fTL/hYdum7RqpvcQTU15d9+f+69NbWzM8Lk922i28W/hz3x7Kl36PuRPpah
KD8XIaXKCuhwmbmYK8DVU2lVzpXi5lHLKDxzqOECoo7SiZhsOhSR44pZ22EFGwj47gKWIKaUEhMz
GDQZfqEmMJvNqDFALiNVsXFSFauO6CJCJBfpjAxFJJ7dtBqTnSb1JST5ZCzUkGAW0ESr6OfC7Iex
GXNVSI9w/XKBvunS9F9M4qdmPgVR1JTP1EdZpVKK/eUHjQ11T6+7/XQyU9doowztkeSSSLD8kRuX
786KTb92QNdf1p6a277kwNWp+fXBxJCFM0cyqSd2PPvnZcuiO/YjOzZ76gIzhqS7DMyC6rMgh4TU
i8mSQ8EZMjCp2lRldraiT7FOsc189Sy5+7jnVa4k0sSpBLAwcYCxyITDRrbsOHgV1t0ls3hErTnj
8Vio8B7wmg8LJT6qDwszCTJ8hFo+EnRgCvm8mG6+QnZaihvFcND3bE7IdeaGc3TVbhIeRYjJUuLd
NSTA0RASF9szjRg6GJmO0jxXmiefzvAVBT2VShH6Cx9OXCLguMBEUlb1BYVsMwS94MSC+i+aMGTG
8o/p5JX3LOy5v7audW7jrBOXte5JuuyuoQw8pHM6jLM9+bvlAad7QWX96rJgzBvir+joWmewaC+j
aud2tLR+f/uGc7Obu3gnXBJtNRj1TINV9/HP+Qq9Wgo3Uo2Oervd11Cb/ca6npvqsi1thJPv0CeR
BnhBFOtAnORb4oSN8YKFMtREZks6paJ6QDIk7VKvl2yWDqu360cMOzit9XAUOTAUm0bpssM61otZ
m0QIuM7rdd9FW7yPAuD7ssWLj2khQayFKIHlW3FdXIh3xumo9cvkOQmuMFFDZmWIX1EQ9igIYxTP
xYrUnyxOCRbTKOQBFfJ0RIH6JScSutRJmH3TYSE9bWDokw0v773qm7W1NbPqah5ft/HeZHlicmsw
XLZrSf/19Xcbzdau3LoD0j/tuLln9uxzG4bPIoVoqcse7m9a/kB9bfOijXB+dixWXvvUfTjHDwAd
kmoQDd8VtUP0ZnqUpmkRB+m4PuykttB482SxMuw1Iq24R1RodLhETHE4XNIPgsfrsX6EAavx3R3Q
WR3H7RzgtAhTaHMgp5VqsZGXlqrwtcD2JIvQzR7/k/ZHpnzQh2Pwol58KOqJ3pDI3kcm0Ila4R1R
4wNRTbTlbEwX5+LUYNHQIAhXeHYyjc2LMFhAekTQJ4qh+nQZbLEM2pw2f0EepSpdVWnAOe9QsoIT
TCa/unlOPu9027rckx9ZKwwu5/PP//dT/QOSOxMNDoslq6dP/XD18GQ9H1cpVMhqU4xUkQhQPx/O
/Q5a23AtezTfQv8ZyWs96ACD4K+ijwJSjyJm9djiuySj0u1L5KG7eTCHnUPNOezgo7Q3QZ7lx2Yk
kcjoRE6kxMNeNiM63JlMRjfaDbuXHlY434q+NYuqqOjWWXDZpGXejcQWB4gVDtCBWXss9nK+TOKO
inZPJkqsddSCSReNEnOm1GaiQ9yQMJQbohffqCbCq7YUDH7bHjfey01q69mMWyhSEZtzMrmCoiBc
fkAKcGqQbd+Cbctgmkj3lVi88YArMZ4cDM54bhHLeNV0PrBq+pFen5k3F5674meC5lIB+7QzKNSw
8zPsD31nuLwh1/zsTW+/eeRLHtHq8HbMG17/ytFEfzns+1MwcP7ma6ypqMc9PxK/x1s++KehXqHZ
bNIvn987eK6yyvXk1o1LPUF+x+JDj68JDbe37ywXKnfvWrNDolU4DeaaaFW/V5c4OHjzSYN2WBpb
m7rhpDwaCJbJ5AyESkiFqdD2A2UB32DF5psPTArZ2RpGaV65gBedDh95ckkKAHMV8joNcJ6oEcnj
RaJYnN58+RmFLhM5Hn01VtIj3BDjWI9iIOFU31nJ2htQMOo67tRRHEVRx+R7Gh7JEreVJZzKTqtL
1oKPnVWSJfbrKpL09WOtzWJvsgyzPvusqNCJgkjVcOJm8UGRzolD4q3ilMgIIsSSJog51P0XUWo/
FjfuiRxzPaLY7Ic1gj/nH/K/5J/yS3R+1n+r/0E/M+If8//FT/tJ6t9PMnw60vhHId3pJxLlJ5N8
+Fr8xFeh9fcJDvNPp9O2XLlscFlhnqXQvujDcKatGIcbSj4LY7KZk/rFzOe/mytA/is9/bh4cRBz
Vd5lzSJVXtle2c/7A0qnyyK4UF9K73JxdsNSF7xCy/iq46HLxS/fYndbg56iXsNP1l3ps9lT+smf
+ONqpRIrvESCNjBf8rfoNSoC3rp8aZfNe/z+ySk+plYo8Bs8Yghgl0n+DOwgCL5/FpQhhmOylWHO
tGBqlRGp4B9wE6zmdut1x1lRgZoseaCNFTHNWBHLBvuqnrVTx6H3focDPGLcw74GH5GXUqNyHIkV
SieYYilFwbIWaipIEYUFH1GOT03CJvnZkK6MKxPKRsqYaXNK5rOxy8LP5E4SPIGRHA4QY5fS/1KU
QM94uIAqy/PEYroxDICXaZ1uS9SxqyOT7uhI18wpmcrlXhTK6alGi/bT1/lybEUlkZrFCysz3fNR
VLIu3wK/I3kPcIiGb5wFCZyjIyRy4Zt0kWXkAZ6Qjec9ruPuVz1slxpPiNBqAgfUasNhqTN0vxeL
IkeqokdxpZyGzSjcyGJk3BjCud3mPV4FKdRQ6XGhxgeEQ6BEWNR4uVS68WkBygFHoZ506u2TxQDm
9YJzAiAhJEYS1IwscSyVmiiUvg0KsSIQGMz9fSZRgzOsZPE9B6mZFL7kXQ9PiVU1t/b2DyTLuaSB
9enmNXJ29hoO3qzVlehbv+l7ueb29mSs0WE2VNnP/Ix6x1tnUFnoBosWfqVE4YKNGkQ2KgsPil9j
vPjOJGRZSzAVoyUuhSwpsoRkychJAECWFFlCsowUJwDInLNPEZFHzdCUDkAhmkqL6e7ydb5V5Wuq
tqa1jISBe6pT1V5iFr1uPsrX8R08w+9jGJhKVSclSWdyRLI9OVLN8N4kwpoSWTZyPH48xhIul6wm
eWxIhzXDA9RZSOuOa+PVuK9Wrc1wSVdKSG5MoUPycXQMmQQ/KOQFI/iFFbW6Wq5WqM3VMppjXske
95PaR8zK4kzmO+TY5pL6mKeLFcyW4hRnAZLgBgHf5rM1FwF3adZ4kDyVIBRsGLZfuYlJPeqCe1mc
HpwcZM7F8KRnIVMYu/gBWMlCVJnM/O/tWump8ouJwkKWkBnM/3LB08PdDrct7p62amYUh16hXXCq
QW5cEoZP91zvt/V1dr8oxNuat0Dq2vnvBgTVTIN2bbBRzyqxQftkYsE32xRuhdMhERvsHR7TwJzV
+XdydQEGSQ+FLJsFSY8dPI2GkmwBS5ZOYtGQGXtVX+IUqQEpx5zSA2zBiPV6Ej6ic3JOwZlzjjgl
OjkckY/J/yKn5cpiTdi0/fp90bCxRcP210KYL6fwEeWGolV795lCfZjTMaMyDHkZUhtGYGHBj/xn
O0ZZ8py1suAOht1wq9bhtsScJdrsCOQMahOmzcfP8AnsBxAlagCQ/o7+O1gOd4vrVhIovbLwOHyf
qYvtD3UF+mvm1iyq6m/rX9R/eb+q+XjLq61s+8Iq9Z1L2NCdC9i03elaDilZ9fEqHQQOnRNUsg7O
+bLjLaccPLJ0DzLzjkcWGvc4H/FXPtKW2NNyrOqR+jNTFwqPbNeTrApaf53Qur40rVVfKpuqLz2H
WI9LqzC16nEhFSmnq39CbimS+wORJ44kQGhNVF3uIhwgkY3cVKRzXjQRQj8BECIYQ0DAVQQC74pW
fAA/RfAAqW71kzIAP37A5FIs8G7hgRO/f+UKYeXmldRKUam5+HqIIrAvtUquqaBebHExjRAKgW0p
rP0/gwj/I3gwT4MH62dRhPR3SEQE5N6G2it6A+4ypQ0DhXzEGpvuCytdLnPcmfeV3GDWA+dqZfbZ
HL9u1vB+TyCTCF2e23kH2jPhKkGMybVbPE5LWj/5IyRaCD40zdjAOS0Z7eTP/OVF7FHwoKu9aYNa
hz3oQXuL2ea9fA5f5XF4jz2RVxUOgaRzFrLyNyHpbIDgdAGIYggqCiUMyn4x4GQItzHsNBHYifMW
mK9Zon4zkKe2hEeJiGUJDMR6OQ1B38EvdiAQtAQ0mWmQiSTh1yX4WFB3/7S99cuLOPK9z8jOn4jZ
9Z/NfcbsXoSPOMM3E0AW4eP/J/Ro/jx6vCnvtmYIeqzq8/vKFIjHFQ7UV+RxpQfO1kpss73BNeIt
N9ncNp67BD1aq9gZ6LGIgfw1BrUKc/CArRlx8MQhAh6VcmxeQdvU7xkFiiD1IASOidpaW1WAsh3W
sYHDUosBKdVpTDHDboJVihDlnQJzALGVQF0EKh+WgMqHorOQaQ134gk1D/Hcnt1qks5QY2jIFR6L
J1HhzIfjWUx99XNlJSpP581xc/pdNZe8qAY/JSv7wvoxRdOs1tNblj3R1Dgfan77EtS85PF413bM
v8LvdXB+/+Xzdt4B/7n2J21dC9pbmr939R9hKP/f73Ycr23omNc06745w0dFcc4HmEK+fAszB0l3
OWjByC7AYg8UJDffhp0OscZtxCO1EZscEiqF2iqRPNB6nUqG4mNdJnA8+GqI1YQV2bvibNNhhcVk
PW5xSmmY2k2XCnfpkoCixgsFGEgbijmSD8UAeXruW226NqGts224jTE9WVav2RN4zfoacEM3CZXc
uKoXH8pdOpS7hDFR45fEZrtL6AIPJmLuPjv9TF1sC5bzi4KOE9ek8H/a/sVIZqn4FogSJ/5tNRWS
cevny/yms9n0i3WNC8TmY5f1XxmQu9y2fvfkb7haq8fmsRlED+zSyivvnXfZPRvDIZLcnrs2pIjY
udmV2bX06razV23/Xkvr3LAz/+tAUqXQw+ZmSipTpvyM3ZPVqzVI4tWbqfquBZ/+q+HYapLubkxM
nnXWmu1cHc71Ib7ewLCIr42QOt1MUn3NmKFdJMvqxWz2Ty+ldfZsNJs11Gcr62cb+gzrDdu46xqV
PF99WOFnXWzuLtZSjnCHMwBfkwt++R7wWiAZFsNdYRqnsL6pNuCXThTtTlhbTG29X/CvYeIE8Tph
URhPX+gwa8LhZra5s5mq2W3BiuMmM15EkSwkL2ghYmghT2JaSqlay3NNpVBrYkaYsCVdyGIJRZYW
XixUeNIf8RRO8276ZWmfyRxacb68ZKmg/tJCK6xyN0z+mau3cTYpW+cNz80OPFhX19rVlDuxpHF1
gGvQLK5hNAg3zrXm75SHHK6FVdsf5EKBTT2z1+RbiqyDGymDoDNbO1pbfnTVlrOtjfPtek1EdoN8
7q8XfjrCpzVKHUUlqfn2WVab94PXevbVZZtnFTwQXUd/ABLghBimVEzEGAmoGC9+FY0KaxatuEtd
Zo6x/PHAq0HWaDlulu4GxTkJMllkKcRWgiAqNBmkWUixjpkfcZXUyDWdDHFZSGxIHIerpEouXEeO
PRJqvE144DpbfqnriM2o8/ywRPzCXMX07IT/f3IWWJHqUpXZOhkt7Io73fbOUuJw2jc0HM7lOuml
6c5a3hIwzGub/D4fV13iDrj6kjtY2NONaDdn6h06TP8T1ELvaRdTfKDxYyKItSWgV1NqZEuNTKlR
XWpUYRpdTvLUHkmtg7HwlmyUCfKhbLqqpWpR1YqqrWBUOaoa0e2IjERHE1uzpv/l/7P/X36ai43E
/hKjYyQdEYtFWeGwH90pIw2yQM2ieJvG5YfIIUUejUbjj8ZSNxIXThyIX0o8NRL+v54mWoBzle+L
bmItY341/a16rh4qH1WpNI+qCZxQP1eHWFMoSHxHjzQCORfMmkuqEXGOkTzUijkESj4fTr9ScGYt
4nQh4sX3CBYKEWdWIVLnI/EXj/bezpk6lK3yymDZFS3Da31e33CdsDUSz568u/aakHW2rtV8YFX3
Mo7zLG1u2g7/EFjWctOTDY5GuKRsbTRev2RhdJbVGjRoK3z8mtZrHvOYK/PPr9/TXZuoN5t4izlL
6mmm/kw9LlEABzgoOiVenSHD4Heb4Letye5W6hwO6500EmJSkuTG8g9cLiz1cg27RykfkY3JKJkW
WyVZKfEmI2kJrAcyA6agrOTtZRj/Y0rLikZmME2ewsOynhYKb5WcwDlcPKtdmI0gaXD86kGz72J5
GvV447aeL61++vRp6Mz/UaFnxWr7clPMGdx5JXXfMEznXxye/E3DIs7tUcjQHfJTf2TW0e+AFHSJ
cysJ4Kwk/ldqUmkzHpMK3S1OXIePR16Nsqbj5lctbApPqjnvUloiNixlkdco3x5wLB7GNxonFjWO
cSWxsHGS6Y4Toxxn8I3GyYR/HEtWM77f+LOVXOWtlQ9WPlXJ5CqHKkcrb6v8S+VUpVSohDq0Cb9v
pRNtltr2mI4JmlEN9V0NHNNADYvPp8FkI3Nv0xlNDSGsZjqK0eiKs2+FmWXNjIzmhQmcy5yZyETW
pTj/Rv7JS0WKs2/89IsvLwlDi4/ofC40Zdblv6uT2urLEj3zd9/kdBiqPXCObrg50+t2RlQuu6E9
Dtfo0G/KY7Bod9prrE7X147CXwcqiE2xaScXbdjot5oFEyX4UOAgwX2f/s2f1KtINc/E1D8ZC/1b
EAUvi+rS7Bq+30LN31ngQjGimRhQVzwGwhEjq4/oXEq9TgkEZDRz7Bs/QP+F2hpc/jewQwJdPpfD
t49WmJCZd9ldHvtejRLFj0qN3UcrJEpjOAoY9jg6RIiOaCiNUkHbfVJ98U0ucVwNQt4LgefgcvHO
ODP9/pbBwpQEzrMAoVjb8wWlO2CwH/tPUmFHqmQLhTozyuus07V1hQdNLYmF7rpdLaaEccHQkV5T
fwL+2DOglETuEgJX5JQGn9Ua18Jr6PvlFQ035t84Ur6r9s9w98/K07KmNmg10XZ2Tf6OkV4IHnAK
Nr1Ticy7CHDtzdS/pBJE3SRcV6y3NIFyi/G4ifOraBMiiKDz6kw6XEApCHp0W+zkD147d7Hi0o7H
abwmAQ1SahRKv1rD+blS3eWLL7Iv/gD9Iyc5o/7yUJ2qQ7VUdY2KkUiUKpnfJHGoLP6QJybklGl1
lTkndCqb1a3mTmFIuUi92DwkrFWu1W6VXqu8RnWt9mruGu9239V+j1Ij18mQJ3BxapVqn0rp5bwz
216ff68/hPyYP4QYTXM3uu5yUa69aoTFFRq7Jq64WsWwGpXXp6BlJmLZIgo9LrYUUptTVAo/JmTC
1ZY06+L8IaXG57WUC8ArQbTRFcor0wIuxYtdUlw5eO4/FVduGQSl2soC2yH8As4b03A6l4Y8QpVP
Kokut6T6M4agrjf/z/zfuztuzbADUXjGN18m8S4UPx2GMLbYK9N4rSZBBa+i72UaGg7l/3Ws8uoM
9cvJ6Jvw1MNCtQRJgsnKOHTr8pMvUT+cbLnxk02OmNngUsjlWBaAGiGiPJKFdrisyF1W5RYamQCs
0QV00FwLMKI8RfAij5wnafGqUmm0SjVnNlGyF9Dfiy8QnuuL5bkF0TJ/9nB8aZ8XXrh0B3GVIxVL
1bi2x5lhHWLHBtUqgXK7vYIQTzlu0KlUssbGFl2D7gaHI4ULOve2NAqxlther1dW5ahraHV0NHSZ
FzuWNmx3XNegqKmpCwb5UYg+Dp2sxRtLNfB1Sms7md9CTG9vnzM6B87B9t9stpaGyK0hXISJ8J/O
ZIUU037cgqDYjCLM9EXeI/+PVoXCowgzyi8vqb4EgxBDA/xK/RklmJ97DUyoyHWz/2L95ecyq4XZ
jXy+PpEzKe1LcpV9SZmupiZ/qGURz23uSx9KOppnwW94G9QKy2A1P1jGyFs5uHF+r8e3tHvplbXu
9oYmidKsCLFlu5c2Xteq9CgsbonYYKqJhm++es75tpDQ1CTXKiwa/y2dybFamVlptuPtmUDk6o1j
x5bE0wy2HxMoItIimcnCctGTIDm/crIUyDJJlrUz7LXo9qiNdJxgLcVd1c7o8bLjYfNxw3FjWGfU
4acjiTB5PLWFmjdkediJCRa/nOVF/IZBYsEFZbxiu7A1zah1ak8y4eE9Tn5fImlKJJIep4d37tWp
TTqdWpdAKxK1uSwSxUVhuqS6ix6mR2iaJqcW8LvtdeokHiU31mKrHi25WdR4tfAegmi0VqiFOpKY
76xlcL0+iY6NBWNfnH4uPfIupP+d0ccpdpxV7y8Ew/TMt0d/gfW/lOUUJSt5ZToT8ZYbdH5l6gA3
dG+PcSABv+/pUUhD98USy+tljqURuMmzwnbV2WRupVDeEV7Qn/9OKmcz6ir1zgu9E3DHj4tOQSd1
6VbmD4xs+H/uMzbbHAnEXUlddf69fO2Gm+9PRN1zsU1ABpFejPjrAg+fplkcr1A49mnELRqFpHsL
b/aTap1UjApo66hKbQfVol1K9Wg3UNdR27SarSqoUmnpw2odcLGuYdd2/AIPSoffwWHCR9Edhjqa
0iK4rVVRzkeJJVYSS+zhPPidtmROChfC4teq4vf0xGrIwz94WXqpH/KohUwa5Kff62eGM58rTtOL
P/09Vb5/yYqIq8Iwi/pg8ieB3lR4SUs4olJx6voqukeqV63tgULk0yMQqTuFDMuaJK6Y+MrUe5I/
gb+SN57xICm6dU6fmSm8KvrnNPiuVKr+rsFg+64HeFgPNUiCgsJc5SA2ZjNfFy35d+3/t71rjWnq
iuO/e++5t4D0RUtbKC0glL7AFrHl0SKlU2gLlIpQeRRQFofTyGDRabZsM5lGs8zEzGUPM5NlHxbM
4oQYNeETZFn2Yc6RPZJB5pIlbtFkEpZtZiaW7tzSTevQbX7yA+eX3znn/u/teeX87/333HPPuR52
ucJtbndbfK59gxhzhe/G9rpaW+npsMvdkhaCRTs3x97gb0FD/8dGfG5j6aiEkVyWzlZojNr5YnFG
cvG0YdIsjmObMZ8lCrKmBSpQRBTbFZzCkRzhdvRX3Yzbr9F2pj4aquI3+0VNY2SMuDR32nS4jUw1
v7KYOeCoMxYYBefG5obqaKjGYo0VMm9SmcGQJuOn9OYio39DvccWHIs17rHZvSovFRU2ponE3tfK
zTH7krWz+vJTNdMY76mHWAlW4ehfLnc8Odj3gNLt+2fpkiUxPJGeLYMYd5U5zN+muZb7coXZl2WM
7LLaKJ1MrWsnmVemPp6j9t61ePL1aXJl8QcsZH641mLZblhrbVHri4izoclX3RXiK/x7LdZGuUdX
pTU2uny11uBYcr+NwhT67gcjYbzMQeYtZob5g32KvcJFiI9M8K8JtcIZybEMR8bYXWQeyFKuYde8
mx2UmqU/ysblz8nviFAcVe7K0eacUflVfjXU3+WOagY0A9ox3aG87nswkjeS/6Terf+y4JKh1ygv
lBYpiz4qHlz7UglX2mFymmbKzppPWiqtedZXbcN2TXlBhXtd2brxxxi30uHYSfGe4+oqVrGKR0Hy
XsWmdgtS02ekuJlQPqVAI9z6YGtToNSmypdvag+1dJm6o1ssfXn6XLU2R6PrsTusdd4ad2WZq0oR
MWztKOndrOzfFq6WFTSbPeWxCxfbpM5O4j//4SNtzvcYOIKJpC/OR8BiIJGgPiP69JgazbS11iOI
VjQhgFLYoEI+5NiEdoTQgi6Y0I0otsBC7/t50COXtrAWOfR5pEMP7HDAijp4UQM3KlEGF6qgQAQG
bEUHtVB6sRlK9GMbwtR+k1HbrRlmeFCOGC7gItoghROdtCx+nMdyMzM0fXFmGCBAAjTvfObZ4ad3
LJ8BcwL8f95q8b7rFrGYSBMwf13G/E1mgXamD/DFv5H7FFHehBOsBTvYJXTR8Dg3jUpyA8PcKF4h
BzFCdsNHjlBZHTzkKIYJjx7yCXbReCd7CJdWomQE4/xA4lveg0G+BGF+CQN8HaLkM5rf5wgLRzDE
GamtlSL5GkOSPXAKJdDxvyFCfkCfSP40hsiLGCC/Qi5IERIpuZKI8+cgJT8nvlmJvClxRyTJoOm8
kPiFex8B8jYC3PcIsKegIyrYyDgEtht2NprYTYI0HgIryUYtmUI9iaCJvI5i8jz9TTPquf0Ish/T
/E6hhLudWOB/omlnIZtbTCxwx1G9yv9PYT/eeBi5AO0XlMws1epYUsMf7kQd4IHJiXNTg3Lv79Av
K83ZRvVXYjjjv25dOh0/mdkleYceZib1kro/ARsyLCEKZW5kc3RyZWFtCmVuZG9iagoyIDAgb2Jq
Cjw8L1Byb2R1Y2VyKEdQTCBHaG9zdHNjcmlwdCA5LjA2KQovQ3JlYXRpb25EYXRlKEQ6MjAyMDAz
MTcxMTUxMjErMDInMDAnKQovTW9kRGF0ZShEOjIwMjAwMzE3MTE1MTIxKzAyJzAwJykKL1RpdGxl
KE1pY3Jvc29mdCBXb3JkIC0gRVhQUkVTUyBMT0FOIE9GRkVSKQovQ3JlYXRvcihQU2NyaXB0NS5k
bGwgVmVyc2lvbiA1LjIuMikKL0F1dGhvcihVc2VyKT4+ZW5kb2JqCnhyZWYKMCA0NgowMDAwMDAw
MDAwIDY1NTM1IGYgCjAwMDAwMTU2NDQgMDAwMDAgbiAKMDAwMDExODIxMSAwMDAwMCBuIAowMDAw
MDE1NTc4IDAwMDAwIG4gCjAwMDAwMTUxODEgMDAwMDAgbiAKMDAwMDAwMDAxNSAwMDAwMCBuIAow
MDAwMDExODE3IDAwMDAwIG4gCjAwMDAwMTU2OTIgMDAwMDAgbiAKMDAwMDAzNzAxOCAwMDAwMCBu
IAowMDAwMDU2MjQwIDAwMDAwIG4gCjAwMDAwODgyODggMDAwMDAgbiAKMDAwMDA1NzA4NiAwMDAw
MCBuIAowMDAwMDk4MTAwIDAwMDAwIG4gCjAwMDAwNTQyMTAgMDAwMDAgbiAKMDAwMDA1NzUyMCAw
MDAwMCBuIAowMDAwMDU0NTcyIDAwMDAwIG4gCjAwMDAwNzE0NTQgMDAwMDAgbiAKMDAwMDA1NTY2
NiAwMDAwMCBuIAowMDAwMDc3MjM5IDAwMDAwIG4gCjAwMDAwMjIyNTEgMDAwMDAgbiAKMDAwMDAx
NTczMyAwMDAwMCBuIAowMDAwMDE4NTkyIDAwMDAwIG4gCjAwMDAwMTg0NzggMDAwMDAgbiAKMDAw
MDAxODUxMCAwMDAwMCBuIAowMDAwMDE4NTQwIDAwMDAwIG4gCjAwMDAwNDQ2NDUgMDAwMDAgbiAK
MDAwMDAxNTM5MiAwMDAwMCBuIAowMDAwMDExODM4IDAwMDAwIG4gCjAwMDAwMTUxNjAgMDAwMDAg
biAKMDAwMDA1NTA1MCAwMDAwMCBuIAowMDAwMDcyMDE3IDAwMDAwIG4gCjAwMDAwNDQ3OTAgMDAw
MDAgbiAKMDAwMDA0NDcxOSAwMDAwMCBuIAowMDAwMDQ0NzQ5IDAwMDAwIG4gCjAwMDAwNTM2MDgg
MDAwMDAgbiAKMDAwMDA1Nzc4NiAwMDAwMCBuIAowMDAwMDcxNzM4IDAwMDAwIG4gCjAwMDAwNzIy
NTkgMDAwMDAgbiAKMDAwMDA3NzQ4OCAwMDAwMCBuIAowMDAwMDg4NTMxIDAwMDAwIG4gCjAwMDAw
OTgzNjAgMDAwMDAgbiAKMDAwMDA1MzY4MiAwMDAwMCBuIAowMDAwMDU0NzMwIDAwMDAwIG4gCjAw
MDAwNTUyNjQgMDAwMDAgbiAKMDAwMDA1NTkzNyAwMDAwMCBuIAowMDAwMDU2NDQxIDAwMDAwIG4g
CnRyYWlsZXIKPDwgL1NpemUgNDYgL1Jvb3QgMSAwIFIgL0luZm8gMiAwIFIKL0lEIFs8Nzg5RjIw
OEMxNTY4MUE4OENBMjNEQ0M0NzBCMTlFODQ+PDc4OUYyMDhDMTU2ODFBODhDQTIzRENDNDcwQjE5
RTg0Pl0KPj4Kc3RhcnR4cmVmCjExODQyOQolJUVPRgo=
------=_Part_96653_887185263.1584698720918--

================================================================================


################################################################################

=== Thread: Loan Application Details ===

From: Express Loan South Africa <e445nau88 () vera ! com ! uy>
To: linux-sparse
Subject: Loan Application Details
Date: Thu, 19 Mar 2020 09:12:48 +0000
Message-ID: <250846317.4096961.1584609168619.JavaMail.zimbra () vera ! com ! uy>
--------------------
------=_Part_4096958_747990253.1584609168613
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 7bit

 
 
Attention, 

Kindly Find Attached Files And Send Your Documents Back To Us. Apply With Us On Our 5% Interest Rate, 

We Offer for all categories. Personal, Home, Debt Consolidation And Business Loans. Even thou you are blacklisted or under debt review. 

Legal Registration No. : 2014/238085/07 

Regards, 

Mrs. Paula Rigt 

Office Line: +27 679 616 466 

Emails: expressloan@webmail.co.za  And expressloan2020@outlook.com
------=_Part_4096958_747990253.1584609168613
Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document;
 name="EXPRESS LOAN OFFER.docx"
Content-Disposition: attachment; filename="EXPRESS LOAN OFFER.docx"
Content-Transfer-Encoding: base64

UEsDBBQABgAIAAAAIQBwfOPktgEAAA4IAAATAAgCW0NvbnRlbnRfVHlwZXNdLnhtbCCiBAIooAAC
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADE
VctOwzAQvCPxD5GvqHEpEkKoKQceR6hE+QBjb1JDYlv29vX3bJImQqVpUUvFJVJi7czseHYzvFsW
eTQHH7Q1CbuM+ywCI63SJkvY2+Spd8OigMIokVsDCVtBYHej87PhZOUgRFRtQsKmiO6W8yCnUIgQ
WweGTlLrC4H06jPuhPwUGfBBv3/NpTUIBntYYrDR8IUEeK0gGguPz6IgHr6wXvHUWjQWIcQEx6L7
uq6kTphwLtdSIAnnc6M2SHs2TbUEZeWsIKq4hHPeSgiBWivyuIW+KKH5aPgAqZjlGD0uSVttx4eD
bINVF2UX1cH2Gg952KjZo3RtTUyVVTdhql3YoWq3FetuOi1tHdkNc4CjLXIhtGn0d+oIuMpPca81
7l56MOpEwWqQd0kgq8beusApGkdHG8rAKlA9yrcDjxra9HS7D4g0ByeYq7BGbtrfMlaZTjcmpJ6q
8jsNVadopO0CvHpeHu1aBdOI7KScglDgB0ez/Vg/NfAv+a/+jT+ljTsR7zn8vYIWeq8JC3h/PVle
v4HvFVJf2vHZOyAN7caQ1h9wGc0/pqzesid49TcffQEAAP//AwBQSwMEFAAGAAgAAAAhAB6RGrfz
AAAATgIAAAsACAJfcmVscy8ucmVscyCiBAIooAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMkttKA0EMhu8F32HIfTfbCiLS2d5IoXci6wOE
mewBdw7MpNq+vaMgulDbXub058tP1puDm9Q7pzwGr2FZ1aDYm2BH32t4bbeLB1BZyFuagmcNR86w
aW5v1i88kZShPIwxq6Lis4ZBJD4iZjOwo1yFyL5UupAcSQlTj5HMG/WMq7q+x/RXA5qZptpZDWln
70C1x1g2X9YOXTcafgpm79jLiRXIB2Fv2S5iKmxJxnKNain1LBpsMM8lnZFirAo24Gmi1fVE/1+L
joUsCaEJic/zfHWcA1peD3TZonnHrzsfIVksFn17+0ODsy9oPgEAAP//AwBQSwMEFAAGAAgAAAAh
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
PIDktxzN0o2/AAAA//8DAFBLAwQKAAAAAAAAACEA4XmbYw4vAAAOLwAAFgAAAHdvcmQvbWVkaWEv
aW1hZ2U0LmpwZWf/2P/gABBKRklGAAEBAQBgAGAAAP/bAEMAAgEBAgEBAgICAgICAgIDBQMDAwMD
BgQEAwUHBgcHBwYHBwgJCwkICAoIBwcKDQoKCwwMDAwHCQ4PDQwOCwwMDP/bAEMBAgICAwMDBgMD
BgwIBwgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/A
ABEIAIoBHgMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAAC
AQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZ
GiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOU
lZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T1
9vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAAB
AncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3
ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Sl
pqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEA
AhEDEQA/AP38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigA
ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACi
iigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKK
KAI/P9qj+3wf89h+dVrzqK5/WO31oM6k+VXOl/tq3/5+IPz/APr1B/wk+m/9BKy/7/JXl+v/AHq4
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
n/keVW4ChWT/AHzX/bq/zP5Srz4ZeJMf8i34s/8ABNd//EVmzfCzxaD/AMil4s/8E0//AMRX9Y9F
dUfFyslb6sv/AAJ/5HmS8LaF7/WH/wCAr/M/k1/4Vd4u/wChU8R/+Caf/wCIqL/hWviX/oU/Fv8A
4Jp//iK/rLop/wDEXK3XCp/9vP8AyM5eGFFf8xD/APAV/mfjF/wbR/s/akPj54+8bavomq6U+gaT
HpVv9utntv3lzJvcoHQZ+SEfnX7S1XqxX5zxDndTNsbLG1I8raStvay+R+h5FlEMswkcJCXNa7v6
hRSJ90UteFF3Vz2AoooqgCiiigAooooAKKKKAP/ZUEsDBAoAAAAAAAAAIQBoojYrOx8AADsfAAAW
AAAAd29yZC9tZWRpYS9pbWFnZTMuanBlZ//Y/+AAEEpGSUYAAQEBANwA3AAA/9sAQwACAQEBAQEC
AQEBAgICAgIEAwICAgIFBAQDBAYFBgYGBQYGBgcJCAYHCQcGBggLCAkKCgoKCgYICwwLCgwJCgoK
/9sAQwECAgICAgIFAwMFCgcGBwoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoK/8AAEQgAbAC6AwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgME
BQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEV
UtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3
eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh
4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALUR
AAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDTh
JfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJ
ipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz
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
w5iVi4p1Fa/n/kfU37NPw5tPhJ8BvCHwyslCxaF4csrBAP8AplCqk/mDXespJx7VBZIsVoqRjAA4
xVkct+Ffilao6teUn1bZ+04amqWHhFdEhaKKKk6AooooAKKKKAP/2VBLAwQKAAAAAAAAACEAJgwR
L/sWAAD7FgAAFQAAAHdvcmQvbWVkaWEvaW1hZ2UyLmdpZkdJRjg5YaUALQD3AAD+/v/+/v7/////
/v/9/f7+/f79/f38/P37+/z5+fr6+vv5+fn6+fru7fCwrrWTkZn29fb4+Pn5+PlWVFvo6Ol1cXnz
8vRta3ScmqKnpa319fdjYWlnZW309PX39vhaV15PTVOrqa/08/XAvsTq6exgXmWWlJze3d/PztFX
Vl329ff19fbGxMqdnKP7+vxtbHDw7/HS0dX8+/1RUFfy8fN2dHzk5Oi1tLqpp6739/nt7O349/np
6exdWmGLiJBpZm/Mys/19PXw7vF6dn+koqlaWV/m5ei9vMLi4eTCwMbX1trr6u36+vyysLZraXGJ
ho/x8fJ9e4SDgYq3tbujoKfx8fPJx8vU0teQjpbc29+fnaXh4ORBQEW+vcNkY2t/fYa7ub/s6+1o
Z2vPzNFxbnbg3+KurbTEw8mEg4uNjY+FhYmHhIy8u7+5uL38/Pyalp7Gxsrw8PHj4uWOjJTz8/Xg
4OPb2dx1dXlFQ0r8+/xhYGdkY2bKyc55dXxIRk7k4+a0srmRkJjW1dna2Nx7eoP6+fvx8PLf3uHg
4OSbmp2tq7K4t716eIE7OkHt7e/W1tfR0NXz8/TV1NifnKPt7fCRkZP29vjAwMXR0dXEwsfy8vTy
8vP6+vr39/iwsLNUU1qUk5tLS03b29/g4OGYlp3s7O7n5um0tLfZ2dqgn6a6t73Hxsvp6OvLys+C
f4eOipJwcHTd3ODMzNC9vb++vsDc2t7Z19ulpKvh4OK4uLpxcHjFw8bW1NdVVFfo5unj4+TBwMM4
Njzx8PHy8fSen6KAgIP+//95eXw/PUOrq65cW17n5+jAvcPMysz9/v59e4CopqmWlpq3t7lhYWS+
vMKurrDl5efRzNHMzM/9+/2QjJT29ve6ur3V0tV8eIGSkpbBusH19fX18/X7+/vl4+bc3N6ck5zb
293e3t/Nx87y8PKMiI3CvMPU1NX29PbCwsTJyculoqcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0i
VzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6
bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8w
My8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3Lncz
Lm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJv
dXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBN
TT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9u
cy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0i
QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9Inht
cC5paWQ6RDI2MjY3MTg1OEI0MTFFNThDQ0ZBNEI1QkM2NTZCNTAiIHhtcE1NOkRvY3VtZW50SUQ9
InhtcC5kaWQ6RDI2MjY3MTk1OEI0MTFFNThDQ0ZBNEI1QkM2NTZCNTAiPiA8eG1wTU06RGVyaXZl
ZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpEMjYyNjcxNjU4QjQxMUU1OENDRkE0QjVC
QzY1NkI1MCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpEMjYyNjcxNzU4QjQxMUU1OENDRkE0
QjVCQzY1NkI1MCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4g
PD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb
2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOi
oaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2pp
aGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEw
Ly4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAAAAAAA
LAAAAAClAC0AAAj/AAUAGEgwQAAAAhIKRLiQYMEEj2itABAg4YABDgcezJgwI8aMIEOCNDgQ40aR
KFOqXMly5cKOAws43DhA4ceKKxK9CCPg4MWWBGs2BOpyKNGjSJNyJGgRwMWbBgV8nLkiTS8jFFMK
9CmgAAGNSkUqDEu2LNAABA6SJGDAwAEmCRgkmFsIgYEAPyluqwRiFEmUDXvuoCBBptnDKp8qnoq4
JcmLBBJ0oMTjCpAuTRQpcuCgFaYsFGjkcHG3U6Jej76eBIlR4AAEW6L8ITD28NSmZhc/bUyUpAIY
sbqAYjSkxhcfD0xgIBKihQksD4gcgSSqwbI0E3a5+RtSoOsEXTb8/6nIPXfMAqt5qz8bIM4YHxd0
oTGDgoKhCAgQMGGCoNCCFTpkkQQVr6hBzB6hJLNNWmK5VhEDilRAQkcmmbWRAXEdsN6GQBnAQyJi
VIJKHJ0gkB5IAmGoQQxsHMOFGKfowMlXAMjkGkIUSeWBFrB00NNfBtXkVE9gZdXRQS/5pMEZZihg
GIdQihRGCC/AsYkBBYlkEJJbBcDJKC9w8cIptCBhgQFSGUBjSV1BEMgLmxC5pY0A0EgAehml95FA
CMRwQRRBRCloSNwUAU8CAqRVEWCMXdRTOGk0Usko5TiQhBESYDkAjQIRQMAOWNzh40l4ZeVUjQQV
IFOFFN2JYwArzP/RyAUUDGorQd8oo0NC5NW50l9tRUAMF7O4JYQtYIxATgKm5iXBK2l08iNDPa2J
o0NCUeRTVmzxoEcRDwjy5K1RqvHCqBVheVRP43gSjCd3AXAADDGAAYQjaBoJgAcmRDstTD8hCYBb
bbVVAEwd3SkDEH5Q0cUI6pIbZRpF8BCvAPmKxBhTASAwCxfVYFmRAAcIAQQzSkCQr1cqhDpqQbS5
hjETGjiyRRl1IEGCJh4YgNGqeCWQQQpZ2OGADBILesoMv2B5F21O6WYSdwMY5AYtoeSC5lYJLZCF
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
WFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPE
xcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAA
AQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGh
scEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlq
c3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV
1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AP38ooooAKKKKACiiigAooooAKKK
KACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoooo
AKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigA
ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAI/P9qj+3wf89h+dVrzqK5/WO31oM6k+VXO
l/tq3/5+IPz/APr1B/wk+m/9BKy/7/JXl+v/AHq4DxZWftDzKuYuH2bn0Q/jTRQOdT0v8blP8aif
4leHQOdb0n/wKSvjnxJBXm/iqDNYVMQ07JHh4niipT2pr7z9BH+MfhTv4j0D8b+P/Gq8nx08Fn/m
a/Dv/gxh/wDiq/LvxJBXm/iuxtjShinezR8pmHiXWw6vGgnbzaP2H/4aG8D/APQ6eFf/AAYxf/F1
F/w0R4A/6Hbwn/4M4P8A4uvws8VWNt/z7VxV5Z2//PvXQqul0j8/xfj/AImhV9n9Tj/4G/8A5E/o
I/4aI8Af9Dt4T/8ABnB/8XSf8NF/D3/odvCf/g3t/wD4qv55pYLc9Leo5YLcni3rmqYxx2REfpBY
l74OP/gb/wAj+hr/AIaR+H//AEO/hL/wb2//AMXTv+Gjvh7/ANDt4T/8G9v/APF1/O79jtv+feme
Tbf8+1Yf2jLsjReP+I/6A4/+Bv8A+RP6J/8Ahov4e/8AQ7+E/wDwb2//AMXR/wANF/D3/od/Cf8A
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
BgAAAAAXABcA5AUAACX2AAAAAA==
------=_Part_4096958_747990253.1584609168613
Content-Type: application/pdf; name="EXPRESS LOAN OFFER.pdf"
Content-Disposition: attachment; filename="EXPRESS LOAN OFFER.pdf"
Content-Transfer-Encoding: base64

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
tZL2nWWOGk3J2W3CijO8KcrHb+g37cUsczbqyeYIoJa6kUCpnNolSUQmpp4HIKPTDjbjcS0pRhP/
NuKDul0fLu+cJOiy+qUiSHVOhJGEB55hwgnqayhhDzM1ASO7+5YURHCAZFW8iwlpTqKU5k8Lzhf5
8wc4CLoZrffPjjwvC+QPEUK0V0Ds9pHW/s3jzlZ7Ytd9qv/ipKk9MGVjfdP1RHm/tss9ZLsWLK8s
mI6SIQyektrxm4CNuPpPF8Xz4k3BS7C1vnxdGIi26varum28NtCWxnTtrvFj8fen5U/FmxLCo3hT
rwy6FDA8dAjN/b9K1BcAPy/ApnrngyiHjbcvC6V8acD4lBBrxf/ffl/88LSATTTlfwtf/rUQ5VfN
NcLffAnd3aD732AhmovSOMlhKVq7uvmqblp45VXdoW4C+UD9DjcTC5e5mthjBsI6E23766L6BZr7
yFZkbEcE0ANAuKUHmw09ibRF6DEKa0SEnhuEHmSyAo5vMBmZufm4ZaYKsLc1M2OzphjQg2yY2TQX
ZCZ4t+g7gfhHA2a29AAHW3qw2dCTSFuQmYSeTWZK62SGmfA4K5kSmVwzMzZfNc16HbFDbC7ITExp
4w2OQPwvB8xs6QEOtvTEZrfPS9JTM5PQ02MmmBqhhpKZeYzMBLuN/4ySwEPdfFU3ddz+2EEvKJkK
D5gIx1tJ+KTPzJaIenNberCpG00Jy9ITMD4n9FBmPi/+ByTHE8RlbmRzdHJlYW0KZW5kb2JqCjI4
IDAgb2JqCjMyNTAKZW5kb2JqCjQgMCBvYmoKPDwvVHlwZS9QYWdlL01lZGlhQm94IFswIDAgNjEy
IDc5Ml0KL1JvdGF0ZSAwL1BhcmVudCAzIDAgUgovUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGIC9J
bWFnZUMgL0ltYWdlSSAvVGV4dF0KL0NvbG9yU3BhY2UgMjIgMCBSCi9FeHRHU3RhdGUgMjMgMCBS
Ci9YT2JqZWN0IDI0IDAgUgovRm9udCAyNSAwIFIKPj4KL0NvbnRlbnRzIDUgMCBSCj4+CmVuZG9i
agoyNiAwIG9iago8PC9UeXBlL1BhZ2UvTWVkaWFCb3ggWzAgMCA2MTIgNzkyXQovUm90YXRlIDAv
UGFyZW50IDMgMCBSCi9SZXNvdXJjZXM8PC9Qcm9jU2V0Wy9QREYgL0ltYWdlQyAvVGV4dF0KL0V4
dEdTdGF0ZSAzMiAwIFIKL1hPYmplY3QgMzMgMCBSCi9Gb250IDM0IDAgUgo+PgovQ29udGVudHMg
MjcgMCBSCj4+CmVuZG9iagozIDAgb2JqCjw8IC9UeXBlIC9QYWdlcyAvS2lkcyBbCjQgMCBSCjI2
IDAgUgpdIC9Db3VudCAyCj4+CmVuZG9iagoxIDAgb2JqCjw8L1R5cGUgL0NhdGFsb2cgL1BhZ2Vz
IDMgMCBSCj4+CmVuZG9iago3IDAgb2JqCjw8L1R5cGUvRXh0R1N0YXRlCi9PUE0gMT4+ZW5kb2Jq
CjIwIDAgb2JqClsvSW5kZXhlZAovRGV2aWNlUkdCCjI1NQooXDM3NlwzNzZcMzc3XDM3NlwzNzZc
Mzc2XDM3N1wzNzdcMzc3XDM3N1wzNzZcMzc3XDM3NVwzNzVcMzc2XDM3NlwzNzVcMzc2XDM3NVwz
NzVcMzc1XDM3NFwzNzRcMzc1XDM3M1wzNzNcMzc0XDM3MVwzNzFcMzcyXDM3MlwzNzJcMzczXDM3
MVwzNzFcMzcxXDM3MlwzNzFcMzcyXDM1NlwzNTVcMzYwXDI2MFwyNTZcMjY1XDIyM1wyMjFcMjMx
XDM2NlwzNjVcMzY2XDM3MFwzNzBcMzcxXDM3MVwzNzBcMzcxVlRbXDM1MFwzNTBcMzUxdXF5XDM2
M1wzNjJcMzY0bWt0XDIzNFwyMzJcMjQyXDI0N1wyNDVcMjU1XDM2NVwzNjVcMzY3Y2FpZ2VtXDM2
NFwzNjRcMzY1XDM2N1wzNjZcMzcwWldeT01TXDI1M1wyNTFcMjU3XDM2NFwzNjNcMzY1XDMwMFwy
NzZcMzA0XDM1MlwzNTFcMzU0YF5lXDIyNlwyMjRcMjM0XDMzNlwzMzVcMzM3XDMxN1wzMTZcMzIx
V1ZdXDM2NlwzNjVcMzY3XDM2NVwzNjVcMzY2XDMwNlwzMDRcMzEyXDIzNVwyMzRcMjQzXDM3M1wz
NzJcMzc0bWxwXDM2MFwzNTdcMzYxXDMyMlwzMjFcMzI1XDM3NFwzNzNcMzc1UVBXXDM2MlwzNjFc
MzYzdnR8XDM0NFwzNDRcMzUwXDI2NVwyNjRcMjcyXDI1MVwyNDdcMjU2XDM2N1wzNjdcMzcxXDM1
NVwzNTRcMzU1XDM3MFwzNjdcMzcxXDM1MVwzNTFcMzU0XVphXDIxM1wyMTBcMjIwaWZvXDMxNFwz
MTJcMzE3XDM2NVwzNjRcMzY1XDM2MFwzNTZcMzYxenZcMTc3XDI0NFwyNDJcMjUxWllfXDM0Nlwz
NDVcMzUwXDI3NVwyNzRcMzAyXDM0MlwzNDFcMzQ0XDMwMlwzMDBcMzA2XDMyN1wzMjZcMzMyXDM1
M1wzNTJcMzU1XDM3MlwzNzJcMzc0XDI2MlwyNjBcMjY2a2lxXDIxMVwyMDZcMjE3XDM2MVwzNjFc
MzYyfXtcMjA0XDIwM1wyMDFcMjEyXDI2N1wyNjVcMjczXDI0M1wyNDBcMjQ3XDM2MVwzNjFcMzYz
XDMxMVwzMDdcMzEzXDMyNFwzMjJcMzI3XDIyMFwyMTZcMjI2XDMzNFwzMzNcMzM3XDIzN1wyMzVc
MjQ1XDM0MVwzNDBcMzQ0QUBFXDI3NlwyNzVcMzAzZGNrXDE3N31cMjA2XDI3M1wyNzFcMjc3XDM1
NFwzNTNcMzU1aGdrXDMxN1wzMTRcMzIxcW52XDM0MFwzMzdcMzQyXDI1NlwyNTVcMjY0XDMwNFwz
MDNcMzExXDIwNFwyMDNcMjEzXDIxNVwyMTVcMjE3XDIwNVwyMDVcMjExXDIwN1wyMDRcMjE0XDI3
NFwyNzNcMjc3XDI3MVwyNzBcMjc1XDM3NFwzNzRcMzc0XDIzMlwyMjZcMjM2XDMwNlwzMDZcMzEy
XDM2MFwzNjBcMzYxXDM0M1wzNDJcMzQ1XDIxNlwyMTRcMjI0XDM2M1wzNjNcMzY1XDM0MFwzNDBc
MzQzXDMzM1wzMzFcMzM0dXV5RUNKXDM3NFwzNzNcMzc0YWBnZGNmXDMxMlwzMTFcMzE2eXV8SEZO
XDM0NFwzNDNcMzQ2XDI2NFwyNjJcMjcxXDIyMVwyMjBcMjMwXDMyNlwzMjVcMzMxXDMzMlwzMzBc
MzM0e3pcMjAzXDM3MlwzNzFcMzczXDM2MVwzNjBcMzYyXDMzN1wzMzZcMzQxXDM0MFwzNDBcMzQ0
XDIzM1wyMzJcMjM1XDI1NVwyNTNcMjYyXDI3MFwyNjdcMjc1enhcMjAxOzpBXDM1NVwzNTVcMzU3
XDMyNlwzMjZcMzI3XDMyMVwzMjBcMzI1XDM2M1wzNjNcMzY0XDMyNVwzMjRcMzMwXDIzN1wyMzRc
MjQzXDM1NVwzNTVcMzYwXDIyMVwyMjFcMjIzXDM2NlwzNjZcMzcwXDMwMFwzMDBcMzA1XDMyMVwz
MjFcMzI1XDMwNFwzMDJcMzA3XDM2MlwzNjJcMzY0XDM2MlwzNjJcMzYzXDM3MlwzNzJcMzcyXDM2
N1wzNjdcMzcwXDI2MFwyNjBcMjYzVFNaXDIyNFwyMjNcMjMzS0tNXDMzM1wzMzNcMzM3XDM0MFwz
NDBcMzQxXDIzMFwyMjZcMjM1XDM1NFwzNTRcMzU2XDM0N1wzNDZcMzUxXDI2NFwyNjRcMjY3XDMz
MVwzMzFcMzMyXDI0MFwyMzdcMjQ2XDI3MlwyNjdcMjc1XDMwN1wzMDZcMzEzXDM1MVwzNTBcMzUz
XDMxM1wzMTJcMzE3XDIwMlwxNzdcMjA3XDIxNlwyMTJcMjIycHB0XDMzNVwzMzRcMzQwXDMxNFwz
MTRcMzIwXDI3NVwyNzVcMjc3XDI3NlwyNzZcMzAwXDMzNFwzMzJcMzM2XDMzMVwzMjdcMzMzXDI0
NVwyNDRcMjUzXDM0MVwzNDBcMzQyXDI3MFwyNzBcMjcycXB4XDMwNVwzMDNcMzA2XDMyNlwzMjRc
MzI3VVRXXDM1MFwzNDZcMzUxXDM0M1wzNDNcMzQ0XDMwMVwzMDBcMzAzODY8XDM2MVwzNjBcMzYx
XDM2MlwzNjFcMzY0XDIzNlwyMzdcMjQyXDIwMFwyMDBcMjAzXDM3NlwzNzdcMzc3eXl8Pz1DXDI1
M1wyNTNcMjU2XFxbXlwzNDdcMzQ3XDM1MFwzMDBcMjc1XDMwM1wzMTRcMzEyXDMxNFwzNzVcMzc2
XDM3Nn17XDIwMFwyNTBcMjQ2XDI1MVwyMjZcMjI2XDIzMlwyNjdcMjY3XDI3MWFhZFwyNzZcMjc0
XDMwMlwyNTZcMjU2XDI2MFwzNDVcMzQ1XDM0N1wzMjFcMzE0XDMyMVwzMTRcMzE0XDMxN1wzNzVc
MzczXDM3NVwyMjBcMjE0XDIyNFwzNjZcMzY2XDM2N1wyNzJcMjcyXDI3NVwzMjVcMzIyXDMyNXx4
XDIwMVwyMjJcMjIyXDIyNlwzMDFcMjcyXDMwMVwzNjVcMzY1XDM2NVwzNjVcMzYzXDM2NVwzNzNc
MzczXDM3M1wzNDVcMzQzXDM0NlwzMzRcMzM0XDMzNlwyMzRcMjIzXDIzNFwzMzNcMzMzXDMzNVwz
MzZcMzM2XDMzN1wzMTVcMzA3XDMxNlwzNjJcMzYwXDM2MlwyMTRcMjEwXDIxNVwzMDJcMjc0XDMw
M1wzMjRcMzI0XDMyNVwzNjZcMzY0XDM2NlwzMDJcMzAyXDMwNFwzMTFcMzExXDMxM1wyNDVcMjQy
XDI0N1wwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBc
MDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFww
MDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAwMFwwMDBcMDAwXDAw
MCldZW5kb2JqCjIyIDAgb2JqCjw8L1IyMAoyMCAwIFI+PgplbmRvYmoKMjMgMCBvYmoKPDwvUjcK
NyAwIFI+PgplbmRvYmoKMjQgMCBvYmoKPDwvUjIxCjIxIDAgUi9SMTkKMTkgMCBSL1I4CjggMCBS
Pj4KZW5kb2JqCjIxIDAgb2JqCjw8L1N1YnR5cGUvSW1hZ2UKL0NvbG9yU3BhY2UgMjAgMCBSCi9X
aWR0aCAxNjUKL0hlaWdodCA0NQovQml0c1BlckNvbXBvbmVudCA4Ci9GaWx0ZXIvRmxhdGVEZWNv
ZGUvTGVuZ3RoIDM1MTQ+PnN0cmVhbQp4nK1ZhZ8btxJeabWSmX3MzMzMzDlmvjAzMzMnTcMpJm0D
hWCZmRkf83v/wZO09tmXXqDp6Rf7stq15tPANzNaKPABgADpEAT2sU0pd12JFACEomibkP/YnhCF
Ow26Fr0L7nj/QYYdmWQDIlKwFAGAkVti+yAQxF/DER1bucOa97j/ICAFBktkaAAA0K64yCk3S5wV
AumFCCUk3F1LcMIRUoEIMAMhjEmVUqNUKjcoMOB4vz3gdwaMAUk/INNikn6XQNE2fgtGZk+k9N6f
1ZLXVb11q0534XCbJSk9BoOHt9zchZy0JlKYoqKjfhW6q7KYdAjvjOHBQKriLnad3F6Y3JOjD3Er
8o8OadUXle4+rX13ivn6TCdVQgZS2eW5CkBwN4NT8ZI0oXEDwJyBHNdrk4fDLBuNCkVVlWKDOjKj
rbzx6amvLTv19rdoVBrVngigZqs1iP3vzn5Jb2ClhkwkSJy1pf/AY3MeVjgLhVSMR/z0Nzv7H804
hljgQ25sGlQ+7c94U0UCtj2RzkLAYTEGY1/MawXRY2RY9fscd+zo84+d/RAWnCIWAFkiOHYmtjP2
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
hqWBp1LO1b/s21OYHG5e6rk+OXHljsWJ3cn60gVx9hKArUrmb5o9a15t+4wjM9JqC7tP+PklnvCq
Se6Z/JTVy7XaokS/Zm9xjOz7OUTgD1FMWV5uRkz35TjYpe312hO5uy1DXdle89zbQ9zcu1rOB6gT
0GjWwIgfBGCSoMCMT/LjUiqWB85IfT56TU5rY+qhrAAyMa95bDsBBds9L2028Rm70kXBoyi8er7G
sj6wKd3DpCSsLxrN/cLoOxx7/4/4yyoaWQqV+uBBDbYfCk8MSHYsle++0mtbPnQ017y2zdq+Mjqv
yHWuCPlrNCiMbxynV1Ly2wb7OQ74/ef+Dn+g4a2NGjlHeAsqcalMjEgsbsHFie4GKDiedOjGdrri
ACjYvBrIsH/Lu5F7gpR7I8JzHpSPYeSylyaepkNnt+6njQbLyeKvy5SxmrXtTeYVKLfcvw3p/wFs
ylrcCmVuZHN0cmVhbQplbmRvYmoKMTkgMCBvYmoKPDwvU3VidHlwZS9JbWFnZQovQ29sb3JTcGFj
ZS9EZXZpY2VSR0IKL1dpZHRoIDI4NgovSGVpZ2h0IDEzOAovQml0c1BlckNvbXBvbmVudCA4Ci9G
aWx0ZXIvRENURGVjb2RlL0xlbmd0aCAxNDYxOT4+c3RyZWFtCv/Y/+4ADkFkb2JlAGQAAAAAAf/b
AEMAAgICAgICAgICAgMDAgMEBgQEAwMEBwUGBAYJCAkJCQgICAoLDgwKCg0KCAgMEAwNDg8PEA8J
DBESEQ8SDg8PD//bAEMBAwMDBAMEBwQEBw8KCAoPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P
Dw8PDw8PDw8PDw8PDw8PDw8PDw8PD//AABEIAIoBHgMBEQACEQEDEQH/xAAfAAABBQEBAQEBAQAA
AAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEU
MoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2Rl
ZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK
0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUG
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
AOhb1b/wCm/+JrWFele9/wAzllRqHL3mgeJP+hb1b/wWTf8AxNdUMRQ/n/Bnn1aM/wCX8Tlrnw/4
k/6FvXf/AAWXP/xNdkcXQX2/wZ51ehV6R/FGJN4Y8Sf9C3rv/gsuf/ia0jjaC+3+D/yPOlgqz+x+
K/zM1/Cvi3/oUtd/8Fk3/wARWrxtD+f8H/kTHBVv5fxQz/hF/F3/AEKmr/8Agsm/+Iqfr1B/b/B/
5D+qVv5PxRF/wjPiX/oU9e/8Fk3/AMRTWJw7+3+DD6pV/l/E/S3/AIJp/D/Uh4/8e+NtX0S+sX0v
T00+H7dA8HzzvuYoGUZ+WIfnXwnG2PVXD06dPz/9tZ9rwlhKtKtKU1/VpH7REYOSOK/OHOMVqfep
WuSUJjCmAUAFABQAUAFABQAUAFAFcqu3G0YOOMe1SgZMQMdBVCRQnZlgvtrEbV+XBxt47UDGy/6s
+7RfqRmkwLZUBcgDOF5/GhBIsUxIrH/VL/vL/wChCpkUxsBJjUnrk/zNOJDFXqv+7n+VNDQhVS8R
KjO4c4/3qBkI+a5kDcjHQ/QVTMnuX27UkNjayRoFWjNjV70I3HnoKZBTckO2Dj5R/Os+pSJj/rQO
xU8VstiJEg6Cs0N7i1aHIKYMKZKI6CWFBDGJ0rOeyDDdSw3Vao1j1HDoKziMWrAKACgAoAKACgAo
AKACgD//2QplbmRzdHJlYW0KZW5kb2JqCjggMCBvYmoKPDwvU3VidHlwZS9JbWFnZQovQ29sb3JT
cGFjZS9EZXZpY2VSR0IKL1dpZHRoIDI4NgovSGVpZ2h0IDEzOAovQml0c1BlckNvbXBvbmVudCA4
Ci9GaWx0ZXIvRENURGVjb2RlL0xlbmd0aCA3NDgxPj5zdHJlYW0K/9j/7gAOQWRvYmUAZAAAAAAB
/9sAQwACAgICAgICAgICAwMCAwQGBAQDAwQHBQYEBgkICQkJCAgICgsODAoKDQoICAwQDA0ODw8Q
DwkMERIRDxIODw8P/9sAQwEDAwMEAwQHBAQHDwoICg8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P
Dw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P/8AAEQgAigEeAwERAAIRAQMRAf/EAB8AAAEFAQEBAQEB
AAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQci
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
Ui9SOQo5IDAgUi9SMTEKMTEgMCBSPj4KZW5kb2JqCjMyIDAgb2JqCjw8L1I3CjcgMCBSPj4KZW5k
b2JqCjMzIDAgb2JqCjw8L1IzMQozMSAwIFIvUjgKOCAwIFI+PgplbmRvYmoKMzEgMCBvYmoKPDwv
U3VidHlwZS9JbWFnZQovQ29sb3JTcGFjZS9EZXZpY2VSR0IKL1dpZHRoIDE4NgovSGVpZ2h0IDEw
OAovQml0c1BlckNvbXBvbmVudCA4Ci9GaWx0ZXIvRENURGVjb2RlL0xlbmd0aCA4NjcxPj5zdHJl
YW0K/9j/7gAOQWRvYmUAZAAAAAAB/9sAQwACAgICAgICAgICAwMCAwQGBAQDAwQHBQYEBgkICQkJ
CAgICgsODAoKDQoICAwQDA0ODw8QDwkMERIRDxIODw8P/9sAQwEDAwMEAwQHBAQHDwoICg8PDw8P
Dw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8P/8AAEQgAbAC6AwER
AAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQE
AAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2
Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Sl
pqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8B
AAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUh
MQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJ
SlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2
t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A/fyg
AoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAC
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
x9y6S3u9bifzbrnO979Nf+e3aT+dn79O+6/fe+swoK3Rv01v7fwjm36xmDPflva+T3M7pu21nZ5S
qk/rWk9tW/67NKSYcVk/h1qNpGGsqF4jKQ+sfY2kPLPmGkm5Zx1qJOWVtdRIygvrWCPJE+tDjaQh
sz7WSBoeWKcaSYMGX/DvrOqsS42kbKytRlJurGuNpMJnNuAZVIoMOBOwPLICZxKNJBg0JtHIhQwa
k6hwIYPGJCoEGjQmUeG6Bo1J5KrQmES95kJjEvUUGUQMqp4KOBOw12MAZwL2IgBnAroqcCbgSAK2
U0HlnR04D2BhBdD1Bgv32WF1eQtfisPq8haui9srqHwLDqvLO3Jdh9XDy7fvsLq8owbD6vJmPQas
Lu9IoMPq8hZurMPq8o4TK6weXl2F1eUtF1ZYXd5MAvZPwWDOxe4quMrdwA0UVN4K26ngy9FVWPv4
YovOw+eHz6PBM/Z5pLr54zjadtdB1EHjAbtu7d9Z3W87Z3XI6Q/uKPEFCmVuZHN0cmVhbQplbmRv
YmoKMTMgMCBvYmoKPDwvQmFzZUZvbnQvWFRTRUJOK0dlb3JnaWEsQm9sZC9Gb250RGVzY3JpcHRv
ciAxNCAwIFIvVG9Vbmljb2RlIDQxIDAgUi9UeXBlL0ZvbnQKL0ZpcnN0Q2hhciAxL0xhc3RDaGFy
IDUyL1dpZHRoc1sgMTEyNiA3MjEgNjg2IDcxNSA4MjAgMTAyMyAyNTQgNjg0IDgwOSA3MDEgNzk3
IDY0OSA3NTggODM5IDU3Mgo1NzcgMzU0IDUxMyAzOTcgNTIwIDU5NiA2MzYgNjkwIDMyOCA0OTAg
NzAxIDU1NCA2MjUgNTk5IDg3OSA1NjIKNjU4IDM5MyA2NjMgMTAxNiA1MzEgNjgwIDY3NyAzNDQg
NTg4IDk2NyA4NjMgNjQ2IDUyNSA2MjYgNjMyIDgzNAozNjcgNDQ2IDc1NyA3MzIgNjcxXQovU3Vi
dHlwZS9UcnVlVHlwZT4+CmVuZG9iagoxNSAwIG9iago8PC9CYXNlRm9udC9RRUdNSk8rSGVsdmV0
aWNhL0ZvbnREZXNjcmlwdG9yIDE2IDAgUi9UeXBlL0ZvbnQKL0ZpcnN0Q2hhciAzMi9MYXN0Q2hh
ciAzMi9XaWR0aHNbCjI3OF0KL0VuY29kaW5nL1dpbkFuc2lFbmNvZGluZy9TdWJ0eXBlL1R5cGUx
Pj4KZW5kb2JqCjQyIDAgb2JqCjw8L0ZpbHRlci9GbGF0ZURlY29kZS9MZW5ndGggMjUyPj5zdHJl
YW0KeJxdkcFuwyAMhu95Ct4gJjXtKlW+tJceNk3bXiABU+VQgmh62NsP42WHHT6kD2xkfvrz9XJN
82r697L4T15NnFMo/FiexbOZ+Danzg4mzH79tbb6+5i7/vw65q/vzKYWcFR/G+/cf6DuWO3xS+BH
Hj2XMd24OwHQKUbqOIV/R/agHVPcSi0pgANVHUgB50R3pIDbiSIpgEdRRwogi+5JAWy9B1JgANEX
UgCt6JEUQBQdSQHXiidSwLWpPCmAUTSQAuhFmRTANmQkBZzcbGsWQj3di9a3Wn1vaAFtSUhWEvqW
sfHPUjit7Wda8pL4nPjv8/KSpctUuh8JnYaqCmVuZHN0cmVhbQplbmRvYmoKMjkgMCBvYmoKPDwv
QmFzZUZvbnQvVFdQV0FWK0FuZGFsdXMvRm9udERlc2NyaXB0b3IgMzAgMCBSL1RvVW5pY29kZSA0
MiAwIFIvVHlwZS9Gb250Ci9GaXJzdENoYXIgMS9MYXN0Q2hhciAxNy9XaWR0aHNbIDU0MiA2Nzcg
NDQ4IDMwMiA2NzcgNDc5IDI0NCA2MDQgNzA4IDQ3OSA1NDIgNzI5IDQ2OSA2MTUgNTIxCjQyNyA4
ODVdCi9TdWJ0eXBlL1RydWVUeXBlPj4KZW5kb2JqCjQzIDAgb2JqCjw8L0ZpbHRlci9GbGF0ZURl
Y29kZS9MZW5ndGggMzM0Pj5zdHJlYW0KeJxdkk1ugzAQRvecghswg8EkUjSbdJNFq6rtBYgZIhYx
iJBFb9/5KV108ZA+Zmx49lTny8slT1tZva9z+uStHKc8rPyYn2vi8sq3KRdYl8OUtt9kz3Tvl6I6
v/bL1/fCpTTw6Pmtv3P10QR7g74mzQM/lj7x2ucbFycAOo0jFZyHf6X66Cuu496K5EANJLEmB5qk
MZADcdTYkAMRNbbkQGSNkRxorNqRA3HQeCAHulbjkRzoGo09OdBYvJIDXa0xkQPxqHEgB+qDRiYH
WquO5EDUD6GchSLNWkVxRfNtdWcUVzTfTvVRXNF8O2sWVzTf1qriiu6rP4niiuYbbCtxRfMN1iyu
aL61niSKK5pvsL8SVzTfoGeF4oomGIJGkUMTDFGjyKEJhoNd6n57er86KPtclOm5rpw3myabFp2S
KfPfwC3zoqtKofgB2Lms/QplbmRzdHJlYW0KZW5kb2JqCjE3IDAgb2JqCjw8L0Jhc2VGb250L1dR
SFdLRCtDYWxpYnJpLEJvbGQvRm9udERlc2NyaXB0b3IgMTggMCBSL1RvVW5pY29kZSA0MyAwIFIv
VHlwZS9Gb250Ci9GaXJzdENoYXIgMS9MYXN0Q2hhciAzMC9XaWR0aHNbIDIyNiA0MjMgNTM4IDQ5
NCA1MzcgNjA2IDgxMyA1MzcgMzQ3IDYzMCAzNTUgMjQ2IDMxMiA1MjAgNTAzCjMxMiA1NjMgNTM3
IDQ3NCA1MzIgNTM3IDUwNyA1MDcgMjU4IDUwNyA1MDcgNTA3IDUwNyA1MDcgNTA3XQovU3VidHlw
ZS9UcnVlVHlwZT4+CmVuZG9iago0NCAwIG9iago8PC9GaWx0ZXIvRmxhdGVEZWNvZGUvTGVuZ3Ro
IDIzNT4+c3RyZWFtCnicXZE9bsMwDEZ3nUI3MC3K+QECLumSoUHR9gKyTAceIguKM+T2NcW6Q4cn
4EkkCH5qzpe3S5oW23yUOX7xYscpDYUf87NEtj3fpmRaZ4cpLr9Wz3gP2TTn95C/X5ntWsCj+jXc
ufn0vt602hPngR85RC4h3dicAOg0jmQ4Df+eWq8d/biVtqSAA1rVkQLoRJEU6Kp6UgAPoh0pgHvR
HSngWHRPCqAXPZACiKJHUgDr3EAKuCjakwLYiUZSAI+iAymArSiTArirO2/LyfqS4xabjc9SOC01
7BqmhDgl/vuPPGfpsivmB/CNfMoKZW5kc3RyZWFtCmVuZG9iago5IDAgb2JqCjw8L0Jhc2VGb250
L1ZOWlFYTCtDYWxpYnJpL0ZvbnREZXNjcmlwdG9yIDEwIDAgUi9Ub1VuaWNvZGUgNDQgMCBSL1R5
cGUvRm9udAovRmlyc3RDaGFyIDEvTGFzdENoYXIgMTQvV2lkdGhzWyAyMjYgNTA3IDU0MyA1MDcg
NTA3IDI1MiA1MDcgNTA3IDUwNyAyNTAgNTA3IDUwNyA1MDcgNTA3XQovU3VidHlwZS9UcnVlVHlw
ZT4+CmVuZG9iago0NSAwIG9iago8PC9GaWx0ZXIvRmxhdGVEZWNvZGUvTGVuZ3RoIDU3Nz4+c3Ry
ZWFtCnicXZTBbttADETv/gr9gZfclZQAwV7SSw4tirY/IEurwIfIguIc+vedGTY99DBBxss1+cg1
z88vX1626707fz9u889279brthzt/fZxzK27tNfrdjLvlut8/+v0d36b9tP5+eu0//q9tw4BbQ3/
bXpr5x+l1ycWd+bb0t73aW7HtL2201NK9Wld66lty39HY4obl/Uz1GooeaqwXkOprLS5htIw0JYa
SsMjbV9Daci0Qw2loacdaygVo32ooVRG2scaSll5pxpKWaeXGko+0841lAZ91VJDadBpw7+rLO8a
4KmURqcFnAmwyALOBDiySAOcCXAkggHOArDRAs4EWBQMOBPg+EALOBNgZnMMcCbArFPAWQAqL+As
AIlggDMB5kILOBOgs+0GOBNgVlUApGBVBlhNvCPzYm4SimReB6sHL5vjYPUYqILB6uLt2SsHq4u3
50AdrC7enokcrC7enmU4WD0GyuY4WD0GqlOwunh78jpYXbw95+tg9RjoQgtWj4HKgtWDd6IFq4t3
1F2wesyXzcF7kZCXp2inhGASodkSglkG+ichL2tGsyUEMxHaKcFyChijhLsXWrBm8fY6BWsWr+sU
rDnmy9ahcAl3FQzWLN4iC9Ys3p4zymDN4i26C9YcvLJgLRqqMRi/HgnfzJrxiiWUIQu4IsDCTiKb
hK/iM8OzlRAsC7gSA2Un8UOUkIhPBc9H8oShc3d8LgmuEe6jz/XTzR/H0ba7lpaWEpfRdWv/9tp+
23mrg05/AD2UMeUKZW5kc3RyZWFtCmVuZG9iagoxMSAwIG9iago8PC9CYXNlRm9udC9ERURWSVAr
R2VvcmdpYS9Gb250RGVzY3JpcHRvciAxMiAwIFIvVG9Vbmljb2RlIDQ1IDAgUi9UeXBlL0ZvbnQK
L0ZpcnN0Q2hhciAxL0xhc3RDaGFyIDcyL1dpZHRoc1sgMjQxIDc0NCAzMjUgMjkzIDQ1NCA0ODMg
NjcxIDcyNSA2MTQgNTAyIDI3MCA1MDQgMjg2IDUwOSA1ODIKNDEwIDY1NCA1NzUgNDMyIDU5MSA2
NTMgNTA1IDU2NiA1OTYgNTU5IDQzMCA1NjUgNDY5IDU1MiA1MjggNDk3CjgxNSA2MDQgNTk5IDk3
NiA2MTUgNzU2IDU2MSA3NjcgNjQyIDcwMiA2MTAgMzc0IDg4MSAzMTMgNTcxIDUzOQo5MjkgNzM3
IDU2MCAyNzAgNDQ0IDM0NSA1MzYgNjE5IDY0MyA1NjYgNTc0IDc0OSA3MTAgMzkwIDQ5MiAyMjcK
MjI3IDI5MiA0NzIgOTI3IDU2MCAzMzEgNjQzIDQxMCA4MDddCi9TdWJ0eXBlL1RydWVUeXBlPj4K
ZW5kb2JqCjE0IDAgb2JqCjw8L1R5cGUvRm9udERlc2NyaXB0b3IvRm9udE5hbWUvWFRTRUJOK0dl
b3JnaWEsQm9sZC9Gb250QkJveFstMjkgLTIxNiAxMTQ1IDc1NV0vRmxhZ3MgNgovQXNjZW50IDc1
NQovQ2FwSGVpZ2h0IDcxMQovRGVzY2VudCAtMjE2Ci9JdGFsaWNBbmdsZSAwCi9TdGVtViAxOTIK
L01pc3NpbmdXaWR0aCAxMDAwCi9YSGVpZ2h0IDQ5OAovRm9udEZpbGUyIDM1IDAgUj4+CmVuZG9i
agolQmVnaW5SZXNvdXJjZTogZmlsZSAoUERGIEZvbnRGaWxlIG9ial8zNSkKMzUgMCBvYmoKPDwv
RmlsdGVyL0ZsYXRlRGVjb2RlCi9MZW5ndGgxIDIwMjI0L0xlbmd0aCAxMzU4Mz4+c3RyZWFtCnic
7Xx5fBzFnW9Vd889o+m57+me6TmkmdHcmtFlqa1b1mlLtiXLY+vwjcEy+DYgGyNsbIyNjbEMBIRl
TIDEyMQmtiFZJ0sI2YRjDSQQQhbCnUVZltzgGb3qnpEsTEj27Xt/vM/n7fRUd3V193TV9/et31FV
EoAAAAXYAXDQ3tYRigL+0/w62i0YuLZvMHvepAUAHh/YtIFu6W87hgp+hc4/WDG48tpttb9zAYA9
C4Dgn1au3boie788DEBpYtXyvmU//8WH2wBofR4VJlahAjIs+RAA8a3o3LXq2g1bsve3oPvhlrXr
Bvqy53WrACAeu7Zvy6DgCPY2uv+bqJC+ru/a5bn6nUM7++C6GzZkz1v564PXLx88teD2UXQ/eh++
Sijnrgn2AS/6tc8BDXIfoojL428DG3c2+Qa/f3tqn6nhn/oc5c6B/8OPOJf++x9443/rqYNwFxyA
9bAbbIHXwm44BwYgC1JwK3/WBq4Dt6C7MmAl6AM9UAIeAteCXtAM1eAVxIVFcCNch37mZfAz0Iq2
e8BmUAeqUEkz9s3cK86AenAYnAAfQwyWQR3UofN6cIEvr4ctcAHcCffBQ+BmdM9fAAsawUKwjH/i
CfBT8BasgxvgHuz7wAz+hMoAfAOaUT1uBlowiM/D/3nyLcyFvQE+x25ET6bBv4MXYAQ8BfpBGL8F
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
EKj5/wMCgBDIAahfvu76lav7AlXr1i7jrwJ4EAj+y/9+66r7PgWfTn6pAE7dBqcThp65OokkoOcf
JWwU7OOS4H6wEv93sFGAg+uISRDn009BMZ/Wge6phH0KvvO3kugZ8IBQNfkToRLUCs6DeuG3QLXg
Ryi/9ErC7wKVU0lwI6gVhwEj/C6wCQ+AevT+Wi4J+9AxAljBVqCYShJ88nXhFiARvDn57N9LxLOg
TeCbnCBY9HutoJ44DOpxNxAS3wBWwSDAsVeBg0uCPJT/AcKPBgHBMEp6dH81kHGJKAABwgyqceQn
CNYAJZeEH03+njgDcGJo8n0ijuSO/wP5cfIRAHB6/IkLS5XlfwSWrEC/ffuZX3DHH1R9VJDZlj4s
TYk+5tfMYdnH/he2NFSMCmVuZHN0cmVhbQplbmRvYmoKMTYgMCBvYmoKPDwvVHlwZS9Gb250RGVz
Y3JpcHRvci9Gb250TmFtZS9RRUdNSk8rSGVsdmV0aWNhL0ZvbnRCQm94WzAgMCAxMDAwIDEwMDBd
L0ZsYWdzIDY1NTY5Ci9Bc2NlbnQgMAovQ2FwSGVpZ2h0IDAKL0Rlc2NlbnQgMAovSXRhbGljQW5n
bGUgMAovU3RlbVYgMAovQXZnV2lkdGggMjc4Ci9NYXhXaWR0aCAyNzgKL01pc3NpbmdXaWR0aCAy
NzgKL0NoYXJTZXQoL3NwYWNlKS9Gb250RmlsZTMgMzYgMCBSPj4KZW5kb2JqCiVCZWdpblJlc291
cmNlOiBmaWxlIChQREYgRm9udEZpbGUgb2JqXzM2KQozNiAwIG9iago8PC9GaWx0ZXIvRmxhdGVE
ZWNvZGUKL1N1YnR5cGUvVHlwZTFDL0xlbmd0aCAxOTU+PnN0cmVhbQp4nGNkYGFiYGRk5PJIzSlL
LclMTgTx1H9IM/6QYfohyyzL4DPnGe8POR6Gbh7mbh6WRd9bhb5XCn4v4/9eLMDAwsho7hM5UyM0
KFxTW1vHOb+gsigzPaNEwdDS0lIhqVIBKqPgklqcmZ6noAZklKXm5BfkpuaV+GXmJpUWKwQn5hUr
+CgEpaaX5iQWoQgizCPPBgYGBkYFIGZgYmRkYf++ig+IShb9WDDre9D0kEVsN7kecN+cwMPzYAoP
LwMDAJe2U1EKZW5kc3RyZWFtCmVuZG9iagozMCAwIG9iago8PC9UeXBlL0ZvbnREZXNjcmlwdG9y
L0ZvbnROYW1lL1RXUFdBVitBbmRhbHVzL0ZvbnRCQm94WzAgMCA4NzggNzEzXS9GbGFncyA2NTU0
MAovQXNjZW50IDcxMwovQ2FwSGVpZ2h0IDcxMwovRGVzY2VudCAwCi9JdGFsaWNBbmdsZSAwCi9T
dGVtViAxMzEKL01pc3NpbmdXaWR0aCA1MDAKL0ZvbnRGaWxlMiAzNyAwIFI+PgplbmRvYmoKJUJl
Z2luUmVzb3VyY2U6IGZpbGUgKFBERiBGb250RmlsZSBvYmpfMzcpCjM3IDAgb2JqCjw8L0ZpbHRl
ci9GbGF0ZURlY29kZQovTGVuZ3RoMSA4MTM2L0xlbmd0aCA0ODk3Pj5zdHJlYW0KeJztOQtwW9WV
9973nvQkS9Z7+suyoic/y5/IRooVOz8lVmxJkT+xZTs2lhMndmIHB5PEISbkA9RJEwJOSgMNbCAF
wmcWWkrzXD4btnQnLSad7aYtUwqU3cJmtyyzXeolnQKdKfHznvtkmyS729md2Zndme297/7O/Z3f
PefIRhghZEZjiEGZ1o5wFdLSgsVQdW3Z3j+SGxe+ihDesGXPqBQ95XwSAL+E8snWkZu27/leYhLm
3kBIJ990y76tufWGiwjlXxoa7B/4xWPJryLkPwHAmiEACM/oNiCk/wTGxUPbR/fO3nccqg9u2bml
Pzd2fwshNn97/94R5kf6LQjxbgBKO/q3D86up2PPyM7do7mxn+Ipjdw6OFL8q9fvgvVLAaev6Qwz
P+HG0AIoxawDFaCDM7+aK+ovZi5xO1DZTMHMu8wGtICewv45QtOAmQq3k78lJwF0cOZ9wsNI1d3N
SOi/n86iV9AmKCn0DTSAVgHkTtQJ0E50CnIEPQWQe6BQvnei3eg4rDquzeTSk2gvegC9iB4CeArt
gFEGRgjmt6FD6Az6A8wgdD+UVwDyVygTr+3uXNfR3pZpbVnb3NTYkF6TSibq61bHa1etjK1Yvmzp
kprq8A2VFWUlwWK5yO+2i4LFnGc08HodxzIEo4qknOqTlJI+hS2R0+lKOpb7AdB/FaBPkQCUunaN
IvVpy6RrV8Zh5dbrVsZzK+PzK7EgxVCsskJKypLy44QsncM9bd3Q/0pCzkrKlNZfq/XZEm1ghkEg
ADukpHsoISm4T0oqqT1D48m+BJw3kWesl+sHjZUVaMKYB9086Cll8sgELluFtQ4pSy6fIIg302sV
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
r1ry6HBfVL1w+7qNVdXtW4dKt20I3Qjcc4JWBbnnQatujFefFPBpgu1ixmI9ayVWswdnEDyNM/RX
ViuXMLYiM+bN2OpkLWmPzZlTklmnBDHXe1qE8OH0h++DaxZopT0KGmN9oQ2yxMhi1BkNVFVH2eAa
Rn2zRgtXkupHhlSFuYC5uSjCLsL+K+g0q0meReo/4DsqtV/zYbBsXfAGgmgkXtnju9m338cMFx4o
JJ2eQc9tHuZeI84z4qM6zOowaiVJuQX5Bb/kZ/zU2xaC9/b7S022FldCaDUhOVNMbEJGJN5G3jCr
5zS+AAqoIQ9RUubNFhhrEJheF5BAQtfEPc6otKSmWigl1Gx3fZfkLR1Vf65O7l1BQ6Fs7QMdd2DU
UpJf+mX8CpcpnH7uF87jHd9+oesuciEXgdT3TNedX1/9YvZFXLIX15m0P4k7/ofyk7gM343fJc3k
aS3/Hc1MOfN79j7Ow+3j9uk43dO6z/Ujf8p/yn/K/xez9ndKMvuXSzvYYki4AIoOOsGlNRWLypji
0mh1VbhkSXkE/f9KLKrTapby57I4MwM1pjWMWaiDEDfVoAq0CJUB54pRKYrCL7wq8CQlaAkq1/7/
iOHXL4GM4DegHqHVOwb6b7ltN9JmED6BOIiC/mvpunWX0eWZawB4Dmk0NlfwJwD+Xy7sW8jAdqLl
7EeomXsOxZm3oAyjlXOFDKOGucKcR6v1DqTjhlER9xZqhrUraIH9S5kHUR8bQk6YC+f09I8kygvu
oyMTytm/3GSJfYrcOeY992eStvMC//H9qnrlCf6n/DswNGjygfRvtkR3DgplbmRzdHJlYW0KZW5k
b2JqCjE4IDAgb2JqCjw8L1R5cGUvRm9udERlc2NyaXB0b3IvRm9udE5hbWUvV1FIV0tEK0NhbGli
cmksQm9sZC9Gb250QkJveFswIC0xNzcgNzU0IDY5NV0vRmxhZ3MgNAovQXNjZW50IDY5NQovQ2Fw
SGVpZ2h0IDY5NQovRGVzY2VudCAtMTc3Ci9JdGFsaWNBbmdsZSAwCi9TdGVtViAxMTMKL01pc3Np
bmdXaWR0aCA1MDYKL0ZvbnRGaWxlMiAzOCAwIFI+PgplbmRvYmoKJUJlZ2luUmVzb3VyY2U6IGZp
bGUgKFBERiBGb250RmlsZSBvYmpfMzgpCjM4IDAgb2JqCjw8L0ZpbHRlci9GbGF0ZURlY29kZQov
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
G7E5KvZTcckJC2tphFPtyyrMKtSk3ssdEk5wgidwTk5hX4amp4snjvql4dw58ghdfHeCxRL78v74
WB/1HBmpxq9H8ZwdO8hNmGcJOX6aU0pjTRFW0e9ymxNXzeNTCbf/4zNHeB0e/+MB9nrBocdHTz7U
uP3AusrVc0v1cM4WyVUyRfb03ulTemoybIHljVN6clKT0tK5ZXKdUmxMjBY769wrf94/hd688pa1
lVqzWWtIciezP2Uxp5gtJa1l+c3FyarUTK4wy6lK9tgq/dG3RVxBzw4yNhZ/BuIk/G8Ii8fO2hB/
MvYfcN6IgbZ8zXD39xc4yTcO57HAF3/HcONkmBhEQ98siN2x8MF/M0hmfLMglUsvnRhk/FeEW1iQ
Z/yLcODbBEXp1wi3TYbJMBm+NLzyfQelS7nm/2JQTVNNU/u/Y3hBs1HboVuud+vf038CYWwyTIbJ
MBkmw2SYDJNhMkyGyTAZJsNkmAyTYTJMhskwGSbDZPhmQfgemYv9y8CJhBc4n0hIPWF/FWADTRXd
Sjm6kYjoIN1HryMWehHt5s8iW6iNP5vMpz+kj5N5NJl/l3+HD/Lv8yP8e/xR/gP+IyIiC6EWEfuX
hAk5ahuDux2l7BPiIvYPEH+HuolQiwHazhH2Dx2rCJnet3rl4nUrc2v6Vy8VUgm9lIiJ7Gv+L3xO
yneUHB07QRH715NFmuNCfwv8AzF/nyJWkh3/F4Vf/O8XUc0EOee/LFlENymT8lXCf0hm/DtF1Eya
TxApafr/KvQTsurfKZJzyVlg46+WFtLwjWRCWe6FbymPEfN/SqCdm78P4X9DTJMyKZMyKZMyKV9X
OB3sQ//X5SyyCqRvUr6ewPNxB4Sp3zGUkytJJwmSDNIbq4//X57j2XO6+MbIcGj3vT3ayo9JEj7Y
H3j7TOHv5h9N//G6z14c3SF/R/oo5JUL7w/g538AqHsIMwplbmRzdHJlYW0KZW5kb2JqCjEwIDAg
b2JqCjw8L1R5cGUvRm9udERlc2NyaXB0b3IvRm9udE5hbWUvVk5aUVhMK0NhbGlicmkvRm9udEJC
b3hbMCAtMTQxIDUwNSA2NDFdL0ZsYWdzIDQKL0FzY2VudCA2NDEKL0NhcEhlaWdodCA2NDEKL0Rl
c2NlbnQgLTE0MQovSXRhbGljQW5nbGUgMAovU3RlbVYgNzUKL01pc3NpbmdXaWR0aCA1MDYKL0Zv
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
eAf4LfAb4G3g18CvgLeAN4FfAr8A3gBeB14Dfg68CrwCvAy8BPwMeBH4KfAT4MfAC8DzwHPAs8CP
gB8CzwCHgKeBHwBPAU8CTwAHgQPACPA4sB94DHgU2AdEgGEgDOwFHgG+DzwM7AEeAh4EHgDuB3YD
9wH3At8D7gHuBu4C7gTuAL4L3A7cBtwK3ALcDNwE3AjcAFwPXAdcC1wDXA1cBXwHuBK4ArgcGAIu
Ay4FLgEuBi5i/TMGOfyfw/85/J/D/zn8n8P/Ofyfw/85/J/D/zn8n8P/Ofyfw/85/J/D/zn8n8P/
+QCAGMARAzhiAEcM4IgBHDGAIwZwxACOGMARAzhiAEcM4IgBHDGAIwZwxACOGMARAzhiAEcM4IgB
HDGAIwZwxACOGMARAzhiAEcM4IgBHDGAIwZwxAAO/+fwfw7/5/B9Dt/n8H0O3+fwfQ7f5/B9Dt/n
8H0O3/93x+H/8E/Xv/sC/sM/ScuWMh1jY5uV13RWpjADq2StbC5b/CSzYEsnsCr+2GPxDQ3GfMMP
sF01zIsNb2Sc1wdtWo3l8ZSUWt/jZforFUczXt4frTVciVBeO/rO6MuFo+8ccVYWHuGFv333nXft
H73sqCwsffeNd4uLuCPDocJl1RgMLr0vs0BTNslfXlpaMl1TNsXvy7RqVNuU8qnTldKSdI3ikpbp
GlHmymtfL1Lmjeo15/hqF5bq0lNsLotep0lNcubXZNvbF2fXFKQZFINe0RkNOVPrMlvWNWb+2uBI
i09IcxqNzrSE+DSHYfRtnfXYxzrrV/XadV9dr+irl9RmKTebjBqtXj+SnpQ8uTqjeaEtzq41x9kd
CUaD0xGb07Bk9OL4VDFGanw8jTXaiml5ePyY1owZLGcN7Jpgur3AMdVo5q1T7TZxirXwOVOT7JBJ
wjiiKX08N4hibq1jZPzoPiiVbVG2qPz5vliV39tnFqxxRFIL7CPcuH9TkAeDidNGuPmxjLbEkC7E
amtrxVx3H6nkhe+q61ryRoCEs7KyuCg7On+TlALF53PI2XRMKS/NKElITFfixVKkK4lxCQl8in+S
349WYjW0Zr0rKz0lw2XWnhmfP72jenNMXEZycobLmJvI44pnpLRsnjvJV7ek0jslP8e1xWocG22Y
n1xbes0DDX11nhRjrFGrjbHH8uIpp9X6Rn9ljDXodAYYH5nk0SmWioUb62esmlflsgZq5haP/SEr
TblozppEg35sTkb1fMbZ5LF3ENsPMzczRcyJqcz+xkt0MwaDVRG3MDXu+JbYrLcmOi7TWeKS4xyJ
Jq69yJyUlZKclWi+yjOlID/5ZYPJqCj4bh436Pba9Xq7V/w23U3jX+BJcZiZWeIw0+Olaz8mXR+j
zGG1L/HCwDPi67BB/diLpSUJfEPh9JoCgfUzCwsaAYa1Xzt+RHlK52VT2Cx2ywE2G295iTZNa89s
Hthay1fW8vpaPqWWZ9Xy2hFNfdAVm5oau6OMn17GW8p4VRkPlPEyVOzfxLgXlzQyfljsBPB7j2MY
VhTLY0fGjwVNKMRWjRcV6fx4KYzEdTWM8Phh3TJWe6Q26mmB7jcCge7ud7vFByY7qZLiou4Ap1XX
YsK0mDB9fHQXCG8zkJsZpkSLrnSNWH3lqSnrdp/RtnPJtGy7s2Dembs3ZM8J5lkNWg03mGPM/vLW
0u6LQ7lKyozWhcVrru7yP5JYvqgue3ZjbUpG7dLa4NLpafx7oTvPas6ZvW7o3qXtD91x+aqaGJvT
bLHFWZ0pdqPVYZ0z+OASW3qSrXLFZT1Vy+qyLIke53mPrMkvalvBEI8WYG4P6jLYJDaVzeTnH2Dl
40cftTn4nHI4yqPCr8pGopYyaZkiLVOkpVR4lYO3lka9rFkstFiiZl4k26jCZo+KqOWw8L2iEU1y
MNmVo7pxjl20iWovanNGNEnBlHSbLx13wVtd6indlW6qUNtUjIy/GoxP460VaseoUXSsOIjcn42/
sU8s8olFP7TPFWV7lC3Ej6IPq8PFBU1ijLoiDFonL7pOXnRd9KLrxFZzmIKQprJpuvzR5K7G0eOb
BXEiGh/eoOfA8WBRWKiSXTXQWeye46/5/KRQPLVAke4XDSCKuoOwt9I1ieXlcShNsiK4JJSWlCsH
a87Yvbb/jg1VOS0bGmuWBDOK+25Zufyq7ryMYHfNzI0tk95Kq2gvW7fRXXlazYp1kzMbVzXULpvm
uejCwQv4nI4LFhVMXrC9ddrKhS2Znsa2JeUNZ3aWFrZtqC1d2tHs9c0OLdMsm9xQlLw8NKm+ptIz
5ZzRewpaZkzL8Eyva87rPX0t/HQW9tIL2EtxLMDeDybnOHmug/st3B/L/UaebeCTFZ6r4fnij2my
xe7I5y4RtF0iiLsSsAwuE6KDSyyeK0moJzTid3K9CNFo5o1uLvD7Ys280RAOfk9ElSwvF79xGIwx
eVkRCzLFJNYyBj0KTfNMGiY2iiiZ7LQhDqkez0zMlJ/nFn9IbGvPBg3rFqqL6HByWq1Ad6Abjh44
sWC0ZN3RDz/l4Qkv1wovjycv1yovFK4Pn7fj/pWBonXhwbPBYas7UNNaFDp9WkL6jBWzKkLTcpJi
NEM3fD7ce9qDX9x1/RcqP9x767bQ1OT5Vzy57poXB6uy6pcOXITw9Qjc9k5dIitgfwpmZaXzrDSe
lcp9bp6VwrOSuT+J+xN5rjr3Tq9deBfu1CKmu4gzMbUsd4QmNDc6obnRZ2JudELBX4otnotnYtCa
niQ6JZnF2eyI+hFY9StH1I9Osh+KPlYx9ehxFzKROOcIr93nW5CLp6thWN+B6S2pHUX4pzkNvBR4
NlD6kSqfizoD7z7+UZ+tGXJ+MxwGvd7vV70jm6JqvENNYe7UmyyG0SWGWLNeH2MxcuuxuESrTtGb
Y/hkbawzyZnkderfN1pjdA1xKXaDwZ4S50xxxChv3WDSWtITHUn2WP3TilbLtQaz/qurYhwp4vk1
gNm+HXt6Ors+aMkt54F0npvG/ek8OCIfQ0GeIHZxghp5EsQ0JWAb7i/NxsEqo3NdeVBzLjPT5Jgx
WUGzTUxnRaXXW4nNV7C/NEFf0G6vHOE5coYQJY4gp6NgggDyktiO6gZU56ibnzo5U+OmI17QIya6
IfXHY4chQ0zS7boYW8xomTXeZlBMttivTltT6Uwtmz9lWm9zcazBjCePzphU3bW2eumV3QUJMy/e
+JKm1Ggz62Y7U+NiDPb0BFd6YqKFm5Zcu315INBalZmZk2l0psfbEuzW+CxfUtmSHY3Tz75q78Av
Y5xuMX+rEBOuxfx1ct0BtghTliqmbBEvNmJSioXjF6vzVizmrXhEUxY0zW33z52bFMdbMcXvBf1o
4vfiFITVH1SsbtHTLXq61Z5u0dMd3bJuzPxjTGSG4vH+qPBva3RrWqO73SoWLg7LYK0OolgdFIMU
VnN160a3MD0Bqh3VjoRypIFBU3N73ider665PQHFaIQQKUGlHUukRgnsZbFMIt5HY30i7MLicFae
iPPRYKFX8x3KAtQlOx5Ajlv+2SLG4wlw7fQtD62dcUZnlc2oV6yWmLL2jQ11/Q2ZgfazWs/GWhn0
ZmvMGXVrmielTGkrq+qdU2LCwioavTGuKrQxuOjSxfne6Yuq6zfOz+cDXVetnBqf5rFaXWnxWane
bG/m9FDJ1M5gJtwjPi7ZZsgMdk3NaS73+HJ8Ops7wZbosMZhnQs6ts6ctqat0qwxlM0Xsb9o/Jjy
us7FJiMufRWsyi7g/nw+KY9nTeJZfp6dyv1u7lMDVHYSz07k/gTuj+d+F/fbOZY4S8eztDzg5mq0
clK0yk9IgkgQQSwhuoiCH8faJaQWIFcf/zqYhhZ24X52sSPsdoQxu3iI2O3YA/YnNA5kNlqKVVo8
AIT7aYX7mVCt1RYVTnIXqAusDWTY7aaMBSaR7DuF15UeKSkRzwCxhKXRsF/iKH1J5RMeeMqHI5s9
6QXguGvyE7Eqgft4hvK6y3mt0eVNTvLGGUbfj7VbdBq9ycBf08Wl56VnFKfbr3XEj92tGVvM7+eb
MvxjR41m5Po4cbvenp4Ul56caFGceAHAK5gl5uvnfZq/jlYJj1sBj7sRb0rT2TNBy6SpfFK5ePr6
FTVi7aeANTUalaaKrMYsXp4OYqZyMPU5sOYIv8ixzivZWHJuiVKSJqY3TUxvmupwacLh0g5qSpFc
vRdNrg49JpKrYBzU4yJdiotLguPkBWPzqj71ZvLMTF1eW9I3XKf7iHCdwgC3/zLqMc92v0HOQ5Mr
ZveEt9Cj9YRzqO8M9H4lfEPvy3CUqx6l3Ng0OLyuZl1HuQ0vrIrRbDBNnrlmVv2mtoJJbTsXTuv0
pyZ50jTTjDaTzuUcS/M1F23cvbGS37X6no1VjuQka6wjxelwO4zJaSnehlWzpy+r9cSmZGtsGd4Y
BMGsnLEbdJqy3qHxcfleotErP1X/5lAffGAvZt7D3jzAHIhdJkcGn+Ow26Ovmd98/Xwv+pz8Ut2L
W5ApObh9RPayi172aC97tJdabTbH8jlb7cJx9MKOzhlyZTP4SYntW2pCGx99IsdHX3Tjo2OCDz+G
PvE6xwjP35fSZhY7/0iJGsTwSFZXATmOuu+jpEYvAxevhn5/+VSekemnh7KY972KLkY/VqCzJWal
ZPodGj1/f/S6uDidyRqj+dgab9Zrn3WmuZOtX70ca4tR9JY4i3Z2TlYcnit6ZypmM/omgtn8GRNv
faK8G0+OIlbHngrG5RbwyTqeq+W5Cp/s534TbxChwituuwGPE4t8kqTtKOaVxc3Fa4qVQDHHIyUv
GMOsVi/bxDT0GkCvA4+KHVstnhvoWi3yFafovrWal1c3Va+sVrKqefWIJhC0Fmbz7ODHXq+h/NPJ
7djFxmHDwpNeCtXXQWxfTFP0jbDk5D2s7mJt9M3w+C6eqteflDNq5Zsh5Yzlym5XUdvZD24KtM3I
c2GyzEZzzrQFpb2Xd+Zpyq7vWXdd16SS0+8daNu1JDjJsTezrqd2xpLq1OSKRXUtV2gOdjx85+Wr
q812p9OTkpBi1dmctpZzdi/xFFWvvKJ94W3bmnJb1w/d3TS4d11R4bz+surlDdn59Jfb7v7PO/ic
iWPimDgmjonj/6Njl3rc+T//0LRqWpXN/71D69f+VrdLf4ah3PA3wyfGa423xrRPHBPHxDFxTBwT
x8QxcUwcE8fEMXFMHBPHxDFxTBwTx8QxcUwcE8f/zqH+d2RN9F9NdTFF5SqmZ371dySsTFE+ZIuU
T5VPlE7lqPJ35QMlpHykfKYcUT5mWlaDVlrxr6gydtQ6Po4zF2eUteIfX/2Wvkxt5cR3a5j4R1wN
jNX3rluzfGAN1TB+NdMx4//i/7bjlHZH2dHxbxii/yqs1noC/JUJ/N+CtpM9PIEJTGACE5jABCYw
gQlM4H8e+DibLKHRsZsm8J8PvB+vxbHgv3nMYo+wAbaKFbEVGK1PtbHonzH86494V9fdMTIc3ntw
ma3mM5ZML/dP/G2n+JsG7LnMm3d8dWz08pgPDPtRjFH//ACf/wKiIiMYCmVuZHN0cmVhbQplbmRv
YmoKMTIgMCBvYmoKPDwvVHlwZS9Gb250RGVzY3JpcHRvci9Gb250TmFtZS9ERURWSVArR2Vvcmdp
YS9Gb250QkJveFstNzMgLTIxNiA5OTAgNzU1XS9GbGFncyA2Ci9Bc2NlbnQgNzU1Ci9DYXBIZWln
aHQgNzA5Ci9EZXNjZW50IC0yMTYKL0l0YWxpY0FuZ2xlIDAKL1N0ZW1WIDEzMwovTWlzc2luZ1dp
ZHRoIDEwMDAKL1hIZWlnaHQgNTA3Ci9Gb250RmlsZTIgNDAgMCBSPj4KZW5kb2JqCiVCZWdpblJl
c291cmNlOiBmaWxlIChQREYgRm9udEZpbGUgb2JqXzQwKQo0MCAwIG9iago8PC9GaWx0ZXIvRmxh
dGVEZWNvZGUKL0xlbmd0aDEgMzAyODgvTGVuZ3RoIDE5NzY2Pj5zdHJlYW0KeJykvAlgG8X5Nzyz
u7qv1X1rJa0k6/TKkm3JR6z1ncRJ7DiOYzs4dk5ykTjk4GpiQxoSEsKVAoFyBBII0BYcmoQEeqSF
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
XsWmdgtS02ekuJlQPqVAI9z6YGtToNSmypdvag+1dJm6o1ssfXn6XLU2R6PrsTusdd4ad2WZq0oR
MWztKOndrOzfFq6WFTSbPeWxCxfbpM5O4j//4SNtzvcYOIKJpC/OR8BiIJGgPiP69JgazbS11iOI
VjQhgFLYoEI+5NiEdoTQgi6Y0I0otsBC7/t50COXtrAWOfR5pEMP7HDAijp4UQM3KlEGF6qgQAQG
bEUHtVB6sRlK9GMbwtR+k1HbrRlmeFCOGC7gItoghROdtCx+nMdyMzM0fXFmGCBAAjTvfObZ4ad3
LJ8BcwL8f95q8b7rFrGYSBMwf13G/E1mgXamD/DFv5H7FFHehBOsBTvYJXTR8Dg3jUpyA8PcKF4h
BzFCdsNHjlBZHTzkKIYJjx7yCXbReCd7CJdWomQE4/xA4lveg0G+BGF+CQN8HaLkM5rf5wgLRzDE
GamtlSL5GkOSPXAKJdDxvyFCfkCfSP40hsiLGCC/Qi5IERIpuZKI8+cgJT8nvlmJvClxRyTJoOm8
kPiFex8B8jYC3PcIsKegIyrYyDgEtht2NprYTYI0HgIryUYtmUI9iaCJvI5i8jz9TTPquf0Ish/T
/E6hhLudWOB/omlnIZtbTCxwx1G9yv9PYT/eeBi5AO0XlMws1epYUsMf7kQd4IHJiXNTg3Lv79Av
K83ZRvVXYjjjv25dOh0/mdkleYceZib1kro/ARsyLCEKZW5kc3RyZWFtCmVuZG9iagoyIDAgb2Jq
Cjw8L1Byb2R1Y2VyKEdQTCBHaG9zdHNjcmlwdCA5LjA2KQovQ3JlYXRpb25EYXRlKEQ6MjAyMDAz
MTcxMTUxMjErMDInMDAnKQovTW9kRGF0ZShEOjIwMjAwMzE3MTE1MTIxKzAyJzAwJykKL1RpdGxl
KE1pY3Jvc29mdCBXb3JkIC0gRVhQUkVTUyBMT0FOIE9GRkVSKQovQ3JlYXRvcihQU2NyaXB0NS5k
bGwgVmVyc2lvbiA1LjIuMikKL0F1dGhvcihVc2VyKT4+ZW5kb2JqCnhyZWYKMCA0NgowMDAwMDAw
MDAwIDY1NTM1IGYgCjAwMDAwMTU2NDQgMDAwMDAgbiAKMDAwMDExODIxMSAwMDAwMCBuIAowMDAw
MDE1NTc4IDAwMDAwIG4gCjAwMDAwMTUxODEgMDAwMDAgbiAKMDAwMDAwMDAxNSAwMDAwMCBuIAow
MDAwMDExODE3IDAwMDAwIG4gCjAwMDAwMTU2OTIgMDAwMDAgbiAKMDAwMDAzNzAxOCAwMDAwMCBu
IAowMDAwMDU2MjQwIDAwMDAwIG4gCjAwMDAwODgyODggMDAwMDAgbiAKMDAwMDA1NzA4NiAwMDAw
MCBuIAowMDAwMDk4MTAwIDAwMDAwIG4gCjAwMDAwNTQyMTAgMDAwMDAgbiAKMDAwMDA1NzUyMCAw
MDAwMCBuIAowMDAwMDU0NTcyIDAwMDAwIG4gCjAwMDAwNzE0NTQgMDAwMDAgbiAKMDAwMDA1NTY2
NiAwMDAwMCBuIAowMDAwMDc3MjM5IDAwMDAwIG4gCjAwMDAwMjIyNTEgMDAwMDAgbiAKMDAwMDAx
NTczMyAwMDAwMCBuIAowMDAwMDE4NTkyIDAwMDAwIG4gCjAwMDAwMTg0NzggMDAwMDAgbiAKMDAw
MDAxODUxMCAwMDAwMCBuIAowMDAwMDE4NTQwIDAwMDAwIG4gCjAwMDAwNDQ2NDUgMDAwMDAgbiAK
MDAwMDAxNTM5MiAwMDAwMCBuIAowMDAwMDExODM4IDAwMDAwIG4gCjAwMDAwMTUxNjAgMDAwMDAg
biAKMDAwMDA1NTA1MCAwMDAwMCBuIAowMDAwMDcyMDE3IDAwMDAwIG4gCjAwMDAwNDQ3OTAgMDAw
MDAgbiAKMDAwMDA0NDcxOSAwMDAwMCBuIAowMDAwMDQ0NzQ5IDAwMDAwIG4gCjAwMDAwNTM2MDgg
MDAwMDAgbiAKMDAwMDA1Nzc4NiAwMDAwMCBuIAowMDAwMDcxNzM4IDAwMDAwIG4gCjAwMDAwNzIy
NTkgMDAwMDAgbiAKMDAwMDA3NzQ4OCAwMDAwMCBuIAowMDAwMDg4NTMxIDAwMDAwIG4gCjAwMDAw
OTgzNjAgMDAwMDAgbiAKMDAwMDA1MzY4MiAwMDAwMCBuIAowMDAwMDU0NzMwIDAwMDAwIG4gCjAw
MDAwNTUyNjQgMDAwMDAgbiAKMDAwMDA1NTkzNyAwMDAwMCBuIAowMDAwMDU2NDQxIDAwMDAwIG4g
CnRyYWlsZXIKPDwgL1NpemUgNDYgL1Jvb3QgMSAwIFIgL0luZm8gMiAwIFIKL0lEIFs8Nzg5RjIw
OEMxNTY4MUE4OENBMjNEQ0M0NzBCMTlFODQ+PDc4OUYyMDhDMTU2ODFBODhDQTIzRENDNDcwQjE5
RTg0Pl0KPj4Kc3RhcnR4cmVmCjExODQyOQolJUVPRgo=
------=_Part_4096958_747990253.1584609168613--

================================================================================


################################################################################

=== Thread: Making structs with variable-sized arrays unsized? ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Making structs with variable-sized arrays unsized?
Date: Fri, 18 Sep 2020 19:33:56 +0000
Message-ID: <CAHk-=wgJZ05ap8VQdzWDWJVWVtZiOYTc6cnNB8gNeQzEnfm-tw () mail ! gmail ! com>
--------------------
Luc,
 we've been making kernel structures use flexible arrays as a
cleanliness thing, but it turns out that it doesn't find bugs that it
_should_ find.

We have that nice "struct_size()" macro to determine the size of the
flexible structure given the number of elements, which uses "offsetof
+ n*members". But sadly standard C still allows the (nonsensical)
'sizeof()' to be used - and I merged another fix for that just today.

Ok, so that's a C standard problem, but it's something that sparse
*could* warn about.

Comments? Appended is a kind of test-case for odd situations that
sparse happily and silently generates nonsensical code for (just
tested with test-linearize).

              Linus

---

    struct bad {
        unsigned long long a;
        char b[];
    };

    // An option to warn about this?
    static struct bad array[5];

    int odd(struct bad *a);
    int not_nice(struct bad p[2]);
    int please_fix(struct bad *p);
    void weird(struct bad *dst, const struct bad *src);

    // The layout is odd
    // The code does "info->align_size = 0" for unsized arrays, but it
still works?
    int odd(struct bad *a)
    {
        return __alignof__(*a);
    }

    // Arrays of flexible-array structures are pretty nonsensical
    // Plus we don't even optimize the constant return. Sad.
    int not_nice(struct bad p[2])
    {
        return (void *)(p+1) - (void *)p;
    }

    // This should at least have an option to warn
    int please_fix(struct bad *p)
    {
        return sizeof(*p);
    }

    void weird(struct bad *dst, const struct bad *src)
    {
        *dst = *src;
    }
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Making structs with variable-sized arrays unsized?
Date: Fri, 18 Sep 2020 20:49:46 +0000
Message-ID: <CAHk-=wgnWnk6H376pux0V13Re6Gb6sFhqsS2oSW6E_v5CyfChQ () mail ! gmail ! com>
--------------------
On Fri, Sep 18, 2020 at 1:41 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> I also have 2 questions here under.
>
> >     struct bad {
> >         unsigned long long a;
> >         char b[];
> >     };
> ...
> >     // The layout is odd
> >     // The code does "info->align_size = 0" for unsized arrays, but it
> > still works?
> >     int odd(struct bad *a)
> >     {
> >         return __alignof__(*a);
> >     }
>
> This returns 8. What's odd here?

The fact that it works correctly.

> The 0 align_size is only for the member 'b' and shouldn't have any
> effect on the alignment of the whole struct. What am I missing?

I wrote that code by looking at the sparse source, and _expected_ it
to return the wrong value.

Because the sparse code does

        /*
         * Unsized arrays cause us to not align the resulting
         * structure size
         */
        if (base_size < 0) {
                info->align_size = 0;
                base_size = 0;
        }

so I expected that when base_size < 0, we'd drop the _previous_
alignment we saved.

But what I suspect goes on is that base_size is actually 0, not < 0.
But I didn't verify.

> >     // Arrays of flexible-array structures are pretty nonsensical
> >     // Plus we don't even optimize the constant return. Sad.
> >     int not_nice(struct bad p[2])
> >     {
> >         return (void *)(p+1) - (void *)p;
> >     }
>
> I don't understand what you mean by 'optimize the constant return'.
> test-linearize returns the only possible sensical answer (if the size
> of the structure is accepted to be 8):
>         not_nice:
>         .L2:
>                 <entry-point>
>                 ret.32      $8

That's not what I see. I see

  not_nice:
  .L2:
        <entry-point>
        add.64      %r3 <- %arg1, $8
        sub.64      %r5 <- %r3, %arg1
        trunc.32    %r6 <- (64) %r5
        ret.32      %r6

which is rather different and not exactly optimal.

That wasn't what I _intended_ to look for, obviously. I expected the
code you quote.

I wonder why it works for you but not me.

               Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Making structs with variable-sized arrays unsized?
Date: Fri, 18 Sep 2020 21:04:22 +0000
Message-ID: <20200918210422.uwq3pris3f3f5ku4 () ltop ! local>
--------------------
On Fri, Sep 18, 2020 at 01:49:46PM -0700, Linus Torvalds wrote:
> On Fri, Sep 18, 2020 at 1:41 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > I also have 2 questions here under.
> >
> > >     struct bad {
> > >         unsigned long long a;
> > >         char b[];
> > >     };
> > ...
> > >     // The layout is odd
> > >     // The code does "info->align_size = 0" for unsized arrays, but it
> > > still works?
> > >     int odd(struct bad *a)
> > >     {
> > >         return __alignof__(*a);
> > >     }
> >
> > This returns 8. What's odd here?
> 
> The fact that it works correctly.
> 
> > The 0 align_size is only for the member 'b' and shouldn't have any
> > effect on the alignment of the whole struct. What am I missing?
> 
> I wrote that code by looking at the sparse source, and _expected_ it
> to return the wrong value.
> 
> Because the sparse code does
> 
>         /*
>          * Unsized arrays cause us to not align the resulting
>          * structure size
>          */
>         if (base_size < 0) {
>                 info->align_size = 0;
>                 base_size = 0;
>         }
> 
> so I expected that when base_size < 0, we'd drop the _previous_
> alignment we saved.
> 
> But what I suspect goes on is that base_size is actually 0, not < 0.
> But I didn't verify.

OK, I see. I'll check this.
 
> > >     // Arrays of flexible-array structures are pretty nonsensical
> > >     // Plus we don't even optimize the constant return. Sad.
> > >     int not_nice(struct bad p[2])
> > >     {
> > >         return (void *)(p+1) - (void *)p;
> > >     }
> >
> > I don't understand what you mean by 'optimize the constant return'.
> > test-linearize returns the only possible sensical answer (if the size
> > of the structure is accepted to be 8):
> >         not_nice:
> >         .L2:
> >                 <entry-point>
> >                 ret.32      $8
> 
> That's not what I see. I see
> 
>   not_nice:
>   .L2:
>         <entry-point>
>         add.64      %r3 <- %arg1, $8
>         sub.64      %r5 <- %r3, %arg1
>         trunc.32    %r6 <- (64) %r5
>         ret.32      %r6
> 
> which is rather different and not exactly optimal.
> 
> That wasn't what I _intended_ to look for, obviously. I expected the
> code you quote.
> 
> I wonder why it works for you but not me.

My fault, sorry. By error, I didn't run these tests on the head but in
one of my branches that coincidentally had some patches doing some
reassociation which then triggers the optimization.

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Making structs with variable-sized arrays unsized?
Date: Wed, 30 Sep 2020 23:28:09 +0000
Message-ID: <20200930232809.soika2g32ddo6doh () ltop ! local>
--------------------
On Fri, Sep 18, 2020 at 01:49:46PM -0700, Linus Torvalds wrote:
> On Fri, Sep 18, 2020 at 1:41 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > I also have 2 questions here under.
> >
> > >     struct bad {
> > >         unsigned long long a;
> > >         char b[];
> > >     };
> > ...
> > >     // The layout is odd
> > >     // The code does "info->align_size = 0" for unsized arrays, but it
> > > still works?
> > >     int odd(struct bad *a)
> > >     {
> > >         return __alignof__(*a);
> > >     }
> >
> > This returns 8. What's odd here?
> 
> The fact that it works correctly.

For info, it was just a coincidence. The returned value correspond
to the value 'max_align' which was not reset. This is now fixed in
the series I just posted.

Best regards,
-- Luc
================================================================================


################################################################################

=== Thread: PATCH: domtree_build() creates extraneous bb->doms entries ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: PATCH: domtree_build() creates extraneous bb->doms entries
Date: Tue, 28 Jan 2020 23:06:09 +0000
Message-ID: <20200128230609.bgbhamef6tunqqpy () ltop ! local>
--------------------
On Tue, Jan 28, 2020 at 12:48:11PM +0800, Xan Phung wrote:
> Hi Luc, I have added a sign off to end of my patch below as requested.

Thanks!

-- Luc 
================================================================================


################################################################################

=== Thread: RECEIVE MONEY IN BANK ACCOUNT REPLY TO fta447447@gmail.com ===

From: "RECEIVE AND SECURE THIS MONEY FOR ME" <fta447447 () gmail ! com>
To: linux-sparse
Subject: RECEIVE MONEY IN BANK ACCOUNT REPLY TO fta447447@gmail.com
Date: Sat, 22 Feb 2020 17:49:35 +0000
Message-ID: <qo$48v09x4c2--5-$f9 () r5u1c0kgq>
--------------------

--A..C8.._3321CEA_--

================================================================================


################################################################################

=== Thread: REF ===

From: Stephen Li <stenn6 () gabg ! net>
To: linux-sparse
Subject: REF
Date: Tue, 17 Mar 2020 12:09:27 +0000
Message-ID: <1348826789.1834294.1584446967790 () mail ! yahoo ! com>
--------------------


Greetings,
I was searching through a local business directory when I found your
profile. I am Soliciting On-Behalf of my private client who is
interested in having a serious business investment in your country. If
you have a valid business, investment or project he can invest
back to me for more details. Your swift response is highly needed.
Sincerely
Stephen Li
Please response back to me with is my private email below for more details
stephli947701@gmail.com
================================================================================


################################################################################

=== Thread: Reply For More Details. ===

From: Maryalice Williams <maryalicewilliams730 () gmail ! com>
To: linux-sparse
Subject: Reply For More Details.
Date: Mon, 30 Mar 2020 10:52:43 +0000
Message-ID: <CAKwdjsr+YKgJk7z-UHX7Zo55cx5RUN3-bw03sWcArP4vbM2B5g () mail ! gmail ! com>
--------------------
-- 
My dear,

I am Mrs Maryalice Williams, I want to send you donation of two
million seven hundred thousand Dollars ($2.7M) for volunteer projects
in your country due to my ill health that could not permit me. Kindly
reply for more details, and also send me the following details, as per
below, your full Name ..........,  Address...........,
Age...............,  Occupation ...............

Remain blessed,
Mrs. Maryalice Williams.
================================================================================


################################################################################

=== Thread: Segmentation fault when running sparse with current linux master ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Segmentation fault when running sparse with current linux master
Date: Fri, 25 Sep 2020 08:46:46 +0000
Message-ID: <20200925084646.56wyiphyl65qidwd () ltop ! local>
--------------------
On Fri, Sep 25, 2020 at 07:37:57AM +0200, Jiri Slaby wrote:
> On 24. 09. 20, 21:38, Luc Van Oostenryck wrote:
> > 
> > In the official tree, there is a branch 'maint-v0.6.2' which just contain
> > 4 patches fixing some problems with the release v0.6.2, the second patch
> > 	77f35b796cc8 ("generic: fix missing inlining of generic expression")
> > being the one fixing this problem.
> 
> Being fixed in Tumbleweed:
> https://build.opensuse.org/request/show/837254

Awesome! Thank you.
 
> If you want the fix on older distros, we can do that, but you have to
> create a bug against the product firstâ¦ 20180324 is pretty old version
> and is both in 15.1 and even 15.2.

Mmmm, 20180324, that's sparse v0.5.2. It's very old indeed and
unusable for current kernel development anyway.

Best regards,
-- Luc
================================================================================


################################################################################

=== Thread: Sparse improvements & regressions for Linux v5.9-rc1 -> v5.10-rc1 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Sparse improvements & regressions for Linux v5.9-rc1 -> v5.10-rc1
Date: Tue, 27 Oct 2020 21:03:44 +0000
Message-ID: <20201027210344.e6rwboxcktgh5vyc () ltop ! local>
--------------------
Hi,

Here is a comparison of Sparse's unique warnings between v5.9-rc1 &
v5.10-rc1 on x86-64 (defconfig + allyesconfig).

This time, there is a VERY significant decrease in the number of
warnings, almost 20% less. On ppc64, the difference is 31%. This big
difference is mainly but not only caused by "cast to restricted type"
warnings or related, like "different base types".

Some of these differences come from changes in Sparse, but most come
from changes in the kernel itself.

The raw logs as well as the result of the processing giving the
'unique warnings' are available at:
        git://github.com/lucvoo/sparse-logs.git


- 18621 14983 Total
+   191   210 Initializer entry defined twice
-   105    92 Using plain integer as NULL pointer
-   394     0 advancing past deep designator
      4     4 arithmetics on pointers to functions
+     0    88 array of flexible structures
-    12    10 bad assignment to restricted type
      4     4 cast between address spaces (__percpu -> __rcu)
-   261   257 cast from restricted type
-   473   468 cast removes address space '__iomem' of expression
      1     1 cast removes address space '__percpu' of expression
     15    15 cast removes address space '__rcu' of expression
-    43    20 cast removes address space '__user' of expression
-    13     0 cast to non-scalar
-  4550  2862 cast to restricted type
-   609   548 cast truncates bits from constant value
+   332   359 context imbalance - different lock contexts for basic block
+   467   472 context imbalance - unexpected unlock
+   189   191 context imbalance - wrong count at exit
-   109   106 dereference of noderef expression
+     0     1 division by zero
+     0     1 dubious one-bit signed bitfield
     16    16 dubious: !x & y
      1     1 dubious: !x | !y
      6     6 dubious: !x | y
     56    56 dubious: x & !y
-    20    19 dubious: x | !y
-     1     0 duplicate [noderef]
-    21    18 function with external linkage has definition
      2     2 implicit cast from nocast type
-   490   458 incompatible types in comparison expression (different address spaces)
+     3     4 incompatible types in comparison expression (different base types)
-     1     0 incompatible types in comparison expression (different type sizes)
      7     7 incompatible types in conditional expression (different base types)
-  1087  1031 incorrect type in argument (different address spaces)
-   494   477 incorrect type in argument (different base types)
-     1     0 incorrect type in argument (incompatible argument (different address spaces))
-   382   336 incorrect type in assignment (different address spaces)
-  4762  3513 incorrect type in assignment (different base types)
      1     1 incorrect type in assignment (different modifiers)
+   120   130 incorrect type in initializer (different address spaces)
-   131   124 incorrect type in initializer (different base types)
-     7     4 incorrect type in initializer (incompatible argument (different address spaces))
-    25    24 incorrect type in return expression (different address spaces)
-    30    25 incorrect type in return expression (different base types)
-   285   282 invalid assignment
     37    37 invalid bitfield specifier for type restricted type.
      7     7 invalid initializer
+     1     2 marked inline, but without a definition
-     1     0 memcpy with byte count of ...
-     5     4 memset with byte count of ...
      7     7 mixed bitwiseness
      8     8 mixing different enum types:
-     2     1 multiple address spaces given
     12    12 multiple definitions for ...
+     0     2 no generic selection for ...
-   918   902 restricted type degrades to integer
+     0     1 statement expected after label
+    12    16 static assertion failed
      5     5 subtraction of different types can't work (different address spaces)
     23    23 subtraction of functions? Share your drugs
      1     1 switch with no cases
+     0     1 symbol redeclared with different type (different address spaces)
-     5     2 symbol redeclared with different type (incompatible argument (different address spaces))
-  1852  1705 symbol was not declared. Should it be static?
      1     1 too long token expansion
      3     3 trying to concatenate long character string (8191 bytes max)
================================================================================


################################################################################

=== Thread: Spende ===

From: "Mrs.Judith Rice" <hamurafujimi () tmail ! plala ! or ! jp>
To: linux-sparse
Subject: Spende
Date: Wed, 27 May 2020 13:08:28 +0000
Message-ID: <20200527220828.CT7ZD.794.root () mwebp13>
--------------------
Attn:

Es tut uns leid, dass wir Sie aufgrund eines Mismanagent of Beneficaries-Fonds von unseren ernannten Zonal Managern versp&#228;tet kontaktiert haben. Bitte beachten Sie, dass Sie qualifiziert sind, die Zahlung von 900.000,00 USD an der ATM-Karte mit neunhunderttausend Dollar zu erhalten.

Als Entsch&#228;digung von WORLD BANK / IWF (Internationaler W&#228;hrungsfonds) f&#252;r die automatisch &#252;ber einen E-Mail-Wahlautomaten gezogenen, die in der Vergangenheit noch nicht abgeschlossene Transaktionen hatten.

F&#252;r weitere Informationen kontaktieren Sie bitte Rev.EVANS JONES ( jonesevansje@gmail.com )

Bitte senden Sie ihm Ihre pers&#246;nlichen Daten wie:

Vollst&#228;ndiger Name:
Wohnanschrift:
Telefonnummer:
Herkunftsland:

Gr&#252;&#223;e,
Mrs. Judith Rice

================================================================================


################################################################################

=== Thread: Spende von 2.000.000,00 Euro ===

From: "manuel franco" <manuel () info ! com>
To: linux-sparse
Subject: Spende von 2.000.000,00 Euro
Date: Thu, 28 May 2020 16:29:55 +0000
Message-ID: <20200528163007.5582238E0A19 () correo ! bnv ! gob ! ve>
--------------------
Ich bin Manuel Franco, ich spende Ihnen 2.000.000,00 Euro. Nehmen Sie jetzt Kontakt mit mir auf, damit wir fortfahren können.
================================================================================


################################################################################

=== Thread: Wir finanzieren Projekte und Unternehmen ===

From: Blue Oak Mortgage and Loans <em () rusoil ! net>
To: linux-sparse
Subject: Wir finanzieren Projekte und Unternehmen
Date: Mon, 21 Sep 2020 23:08:09 +0000
Message-ID: <2020026523.907101.1600729689731.JavaMail.zimbra () rusoil ! net>
--------------------


Dies ist ein Newsletter von Blue Oak Mortgage and Loans. Bitte melden Sie s=
ich ab, wenn Sie keine E-Mail mehr von uns erhalten m=C3=B6chten.


Eine kurze Einf=C3=BChrung.

Wir sind ein f=C3=BChrendes Finanzierungsunternehmen in Europa. Wir finanzi=
eren Startups / etablierte Unternehmen, finanzieren Gro=C3=9Fprojekte (Bau,=
 Landwirtschaft, Immobilien und dergleichen) zu einem niedrigen Zinssatz vo=
n 2% pro Jahr.


Darlehensverfahren

1. Sie m=C3=BCssen das Online-Bewerbungsformular ausf=C3=BCllen und eine or=
dnungsgem=C3=A4=C3=9F unterschriebene Kopie an uns zur=C3=BCcksenden.

2. M=C3=B6glicherweise m=C3=BCssen Sie Finanzdokumente als unterst=C3=BCtze=
nden Nachweis f=C3=BCr die F=C3=A4higkeit zur R=C3=BCckzahlung von Krediten=
 vorlegen.

3. Wenn Ihr Darlehen genehmigt wurde, m=C3=BCssen Sie eine Versicherungsgar=
antie f=C3=BCr die Darlehenssicherheit vorlegen. Wir empfehlen eine Versich=
erungsgesellschaft. Sie sind allein verantwortlich f=C3=BCr die Zahlung und=
 den Erwerb der Anleihe, die als Sicherheit dienen. Die H=C3=B6he der Anlei=
he h=C3=A4ngt von Ihrem Darlehensbetrag ab. Die Versicherungsgesellschaft w=
ird Sie durch den Prozess f=C3=BChren. (F=C3=BCr Gro=C3=9Fprojekte)

4. Ihr =C3=9Cberweisungsprozess wird eingeleitet, sobald die Versicherungsa=
nleihe =C3=BCberpr=C3=BCft wurde. Ihr Darlehensr=C3=BCckzahlungsplan wird i=
m NC-Darlehensvertragsformular aufgef=C3=BChrt.

Wenn die Bedingungen Sie beruhigen, k=C3=B6nnen Sie uns =C3=BCber die Whats=
App-Nummer / E-Mail kontaktieren und auch unsere Website besuchen, um weite=
re Informationen zu erhalten. Wir freuen uns darauf, von Ihnen zu h=C3=B6re=
n.

WhatsApp: + 90-552-365-3483
E-Mail: info@bluelmtg.net
================================================================================


################################################################################

=== Thread: YOUR EARLY REPLY ===

From: "Mr. Fu Lan" <aitor () coacan ! es>
To: linux-sparse
Subject: YOUR EARLY REPLY
Date: Wed, 30 Sep 2020 14:30:48 +0000
Message-ID: <202009301430.08UEUh9R015477-08UEUh9T015477 () fortimail ! grupovidela ! com>
--------------------
YOUR EARLY REPLY 

It is understandable that you might be a little bit apprehensive because
you do not know me but I have a lucrative business proposal of mutual
interest to share with you.$222,695.415.00 million United States dollars
your earliest response will be appreciated.
Email: fulanlan28@gmail.com
Kind Regards,
Mr. Fu Lan
================================================================================


################################################################################

=== Thread: Your Respond ASAP ===

From: Ms Mary Mcniff <diplomaticstoragecourier () gmail ! com>
To: linux-sparse
Subject: Your Respond ASAP
Date: Mon, 14 Sep 2020 12:19:50 +0000
Message-ID: <CAD72A3P634cmdJwk2eeLsy2spHM=1QE+j0vb_dgHKWhtp-VgqQ () mail ! gmail ! com>
--------------------
-- 

================================================================================


################################################################################

=== Thread: [ANNOUNCE] Sparse v0.6.2 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [ANNOUNCE] Sparse v0.6.2
Date: Sun, 21 Jun 2020 13:34:24 +0000
Message-ID: <20200621133424.tj4pgwmzkibb2d4m () ltop ! local>
--------------------
Sparse v0.6.2 is out.

The source code can be found at the official repository:
   git://git.kernel.org/pub/scm/devel/sparse/sparse.git v0.6.2

The tarballs can be found at:
   https://www.kernel.org/pub/software/devel/sparse/dist/
with the following sha256sum:
   0395bada812d831b2f32948258690c1c5799761683d5d4f20c34e641037bd555  sparse-0.6.2.tar.gz
   519ca0de92c1c5dbb76494176c7e567ce4cc8f64a2ecd27b2fae32ce156421fc  sparse-0.6.2.tar.xz


Many thanks to people who have contributed to the 269 patches
of this release, reported a bug or made a suggestion:
   Ramsay Jones, Oleg Nesterov, John Levon, Alexey Gladkov,
   Xi Wang, Xan Phung, Toomas Soome, Quentin Monnet,
   Joe Perches, Davidson Francis, Garrit Franke, Ben Dooks,
   Randy Dunlap, Marco Elver Alex Kogan, Miguel Ojeda,
   Linus Torvalds, Paul Walmsley and kbuild test robot.

Special thanks to Ramsay Jones who has reviewed and tested
numerous patches and found a lot of my typos and to Marco Elver
who has reported an embarrassing bug late in the release cycle.

The most notable changes are:
* sindex: a new cscope-like tool by Alexey Gladkov
* sparse can now use the option --arch=<arch> for non-native usage
* support for __auto_type & _Generic()
* the documentation can now be found on https://sparse.docs.kernel.org

Release notes for v0.6.2
------------------------

* add a new tool: sindex - the semantic utility
    Sindex is a simple to use cscope-like tool but understanding
    how symbols are used and which can track struct members.

* add support for GCC's __auto_type

* add support for _Generic

* fully propagate declarations downward.
    For example, it means that code like:
        static int foo(void);
        int foo(void) { return 0; }
    now behaves as expected: foo() is effectively static.

* multi-arch:
   * allow a single sparse executable to be used for multiple architectures
   * add support for -mcmodel & -f{pic,PIC,pie,PIE}, mainly for RISC-V
   * add new option, --arch=$ARCH, to specify the target architecture
   * move all arch-specific code into separate files (target-$ARCH.c)
   * try to support the various floating-point ABIs on ARM
   * fix wchar_t & wint_t for openbsd
   * add missing predefines for PPC
   * add missing predefines: __amd64 & __amd64__
   * sparc32 on SunOS/Solaris uses 128-bit long double
   * fix wchar_t & wint_t on SunOS/Solaris
   * teach sparse about -fshort-wchar
   * keep cygwin specifics with i386/x86-64 specifics
   * keep BSD & Darwin specifics with i386/x86-64 specifics
   * fix the signedness of plain chars
   * add support for s390 (ILP32)
   * add predefine for __mips__
   * predefine "i386" if needed
   * pre-define __unix__ and friends
   * add necessary defined for sunos-derived systems
   * improved detection of the native OS

* warnings:
   * improve diagnostic message about wrong redeclaration
   * conditionally accept { 0 } without warnings
   * add -Wexternal-function-has-definition
   * display the bitfield name in error messages
   * oversized bitfields are now errors
   * add an option to suppress warning 'no newline at EOF'
   * warn when jumping into statement expressions
   * warn when using undefined labels
   * warn on defined but unused labels

* attributes:
   * allows '__<attribute-name>__' for all attributes.
   * improve handling of function attributes
   * separate modifiers into type/declaration
   * add support for attributes 'unused' & 'gnu_inline'
   * simplify parsing of inline/__tls/__visible
   * better handle function-only attributes
   * teach sparse about gnu_inline
   * parse enum attributes and, for now, ignore them

* cgcc:
   * use -fshort-char for Cygwin
   * add support for riscv32 & riscv64
   * don't define __CYGWIN32__ on 64-bit
   * filter-out sparse-specific -msize-long & -msize-llp64
   * use -mfloat-abi=hard for armhf
   * define _BIG_ENDIAN when needed
   * remove definition of _STRING_ARCH_unaligned (defined by glibc)
   * removed unneeded predefines for integers (now defined by sparse)
   * better multi-arch support by using --arch=$ARCH

* testsuite:
   * avoid standard includes in the tests
   * fix testcase with non-constant initializer
    
* IR
   * add support for the linearization of builtins
   * generate OP_UNREACH from  __builtin_unreachable()
   * add OP_UNREACH after calls to __noreturn functions

* doc:
   * do not use obsolete sphinx's AutodocReporter
   * Sphinx's minimal version is now 1.7
   * add basic doc about the type system
   * doc is now accessible as: https://sparse.docs.kernel.org
   * release notes (old and current ones) have been added to the doc
   * now using the sphinx_rtd_theme instead of the classic theme

* misc:
   * add support for '-std=c17/c18'
   * simplify testing of which version of the standard is used
   * ensure that typeofs are evaluated before using show_typename()
   * use a single way to expand typeofs
   * various improvements to the 'dissect' tool
   * simplify the parsing of type specifiers
   * improve diagnostic messages concerning bitfields
   * fix premature examination of dereferenced object
   * various fixes for the expansion of constant symbols
   * fix type compatibility of _Atomic types
   * add support for builtin macros with argument
   * add support for __has_feature() & __has_extension()

------------------------

Changes since previous release (v0.6.1) are:
   Alexey Gladkov (2):
      Add semantic index utility
      sindex: Add option to search by location

   Davidson Francis (1):
      show-parse: null pointer dereference in do_show_type()

   Garrit Franke (1):
      ir-validate: remove orphan comments

   Joe Perches (1):
      Add '__' prefix and suffix to all __attribute__ #defines

   John Levon (5):
      Add -Wexternal-function-has-definition
      define __PRAGMA_REDEFINE_EXTNAME
      add necessary defined for sunos-derived systems
      pre-define __unix__ and friends
      predefine "i386" if needed

   Luc Van Oostenryck (229):
      options: add support for -fpic, -fPIC, -fpie & -fPIE
      options: add support for -mcmodel
      arch: add predefine for __mips__
      arch: reorder MACH_XXX defines
      arch: add support for s390 (ILP32)
      arch: change the arch when changing -m32/64
      arch: add an option to specify the desired arch: --arch=<arch>
      cgcc: specify the arch via --arch
      cgcc: removed unneeded predefines for integers
      .gitignore: alphasort the patterns
      remove unused KW_STATEMENT
      remove unused SYM_MEMBER
      remove unused SYM_TYPEDEF
      remove unneeded MOD_TYPE
      show-type: add a test program to test do_show_type() & friends
      arch: fix setting the endianness
      cgcc: remove _STRING_ARCH_unaligned
      cgcc: let sparse define _BIG_ENDIAN
      typeof: fix up comment in examine_pointer_type()
      typeof: add a test for unexamined typeof
      typeof: examine it at show-time
      spec: process chars like other integer types
      spec: types[] is indexed by the specifier class
      spec: add '.class = CInt'
      spec: improve parsing of __int128
      spec: KW_SHORT is not needed
      spec: KW_LONG is not needed
      spec: s/size/rank/
      arch: fix the signedness of plain chars
      arch: simplify i386/x86-64 specifics
      arch: do not needlessly set bitness on 32-bit archs
      arch: remove impossible cases with 64-bit arch not being lp64
      arch: keep BSD & Darwin specifics with i386/x86-64 specifics
      function attributes apply to the function declaration
      option: move all option parsing helpers before their potential uses
      arch: keep cygwin specifics with i386/x86-64 specifics
      arch: teach sparse about -fshort-wchar
      cgcc: let cygwin use -fshort-wchar
      option: allow handle_switches() to set non-boolean values
      option: use handle_switches() for -m flags
      option: simpler handling of key-value for suboptions
      add tests for function attributes
      fix assignment: pointer to __pure/__noreturn function to void *
      fix assignment check with function attribute
      propagate function modifiers only to functions
      let function definition inherit prototype attributes
      allow 'static' forward declaration
      spec: make ctype_declare[] more readable
      spec: get rid of all specifier MOD_XXX
      fp-abi: add tests for ARM's -mfloat-abi=... & -msoft-float
      fp-abi: teach sparse about -mfloat-abi on ARM
      fp-abi: teach sparse about -m{hard,soft}-float
      cgcc: use -mfloat-abi=hard for armhf
      arch: char32_t should be the same as uint32_t, not uint
      arch: (almost) all platforms simply use int for int32
      arch: add predefines for INT128 only on supported archs
      arch: use a variable for the OS
      arch: fix wchar_t & wint_t on SunOS/Solaris
      arch: sparc32 on SunOS/Solaris uses 128-bit long doubles
      arch: add note for 128-bit long double on mips64
      spec: replace lllong_ctype by int128_ctype
      cgcc: filter-out -msize-long & -msize-llp64
      arch: add missing predfines: __amd64 & __amd64__
      arch: add missing predefines for PPC
      arch: fix wchar_t & wint_t for openbsd
      cgcc: add support for riscv64
      simplify initialization of Wdeclarationafterstatement
      allow to test the standard version outside of lib.c
      alt definition for STANDARD_GNU89 & friends
      testsuite: avoid standard includes in the tests
      remove redundant degenerate() in compatible_assignment_types()
      bitfield: add testcases for invalid bitfield width
      bitfield: don't warn twice on invalid width
      bitfield: oversized bitfields are errors
      bitfield: keep the bitfield ident
      bitfield: display the bitfield name in error messages
      reorganize the __STDC_VERSION__/__STRICT_ANSI__ switch statement
      simplify definition of __STRICT_ANSI__
      separate definition of __STDC_NO_ATOMICS__ and friends from C11
      teach sparse about C17
      fix premature examination of dereferenced object
      split testcases for type punning & constant initializer expansion
      add testcase for expansion of default initializers
      add testcase for addressability of degenerated symbol
      add testcase for addressability of 'complex' symbols
      add test for union cast
      add test for dereference cost of symbol with complex type
      add test for constant expansion of complex initializer
      extract mark_addressable() from evaluate_addressof().
      fix addressability marking in evaluate_addressof()
      degenerated arrays & functions are addressable too
      fix expansion of initializer (mismatching size)
      fix expansion of initializer (mismatching type)
      fix expansion of initializer (default)
      fix simplify_loads() when doing type punning
      fix cost of dereference of symbols with complex type
      mark strings as examined & evaluated
      testcase: remove trailing ';' in commands
      typeof: do not let classify_type() do its own SYM_TYPEOF expansion
      typeof: extract examine_typeof() from examine_symbol_type()
      typeof: avoid using is_bitfield_type()
      improve diagnostic message about wrong redeclaration
      cgcc: add support for riscv32
      cgcc: rename 'ppc64+{be,le}' to 'ppc64{be,le}'
      arch: move arch-specificities to their own files
      arch: move parsing of --arch=<ARCH> to target.c
      arch: move handle_arch_finalize() into target_init()
      arch: use an arch-specific default for -msize-long
      arch: move target-specific predefines to the target files.
      arch: move cmodel predefines to the target files.
      arch: use arch_target for INT128's predefine
      arch: arch_mach is not needed anymore
      fix testcase with non-constant initializer
      ptrlist: fix typos
      add predefine_nostd()
      fix typo when detecting SunOS
      detect native OS in alphabetical order
      detect native OS on OpenBSD & NetBSD
      detect OS_UNIX as native OS
      allow to easily test if the OS is UNIX-like
      fix type compatibility of _Atomic
      inline: add some tests
      do the tree inlining during expansion phase
      teach sparse about -pedantic/-Wpedantic
      cpp: silently allow conditional directives within a macro
      cpp: remove extra newlines during macro expansion
      cpp: fix redefinition of a macro during its own expansion
      add testcases for OP_UNREACH
      add instruction OP_UNREACH
      add an implicit __builtin_unreachable() for __noreturn
      add support for linearization of builtins
      teach sparse to linearize __builtin_unreachable()
      add support for GCC's __auto_type
      do not use expr->left for conditionals
      doc: do not use obsolete sphinx.ext.autodoc.AutodocReporter
      doc: fix the warnings when building the doc
      doc: remove done item from the TODO
      misc: fix typo: s/OS_UNIX/OS_NATIVE/
      attribute: sort the table of modifier names
      attribute: add helper apply_mod() and use it
      attribute: allow some attribute to be present multiple times
      attribute: add support for unused
      attribute: separate modifiers into type/declaration
      attribute: teach sparse about attribute((gnu_inline))
      univ-init: add helper match_token_zero()
      attribute: '__tls' is just another 'declaration' modifier
      attribute: 'inline' is just another 'declaration' modifier
      attribute: 'externally_visible' is just another 'declaration' modifier
      testsuite: add a few testcases for nested functions
      misc: fix testcase typeof-safe
      misc: s/fntype/rettype/
      misc: always use the node for current_fn
      bad-goto: add testcase for 'jump inside discarded expression statement'
      bad-goto: add testcases for linearization of invalid labels
      bad-goto: reorganize testcases and add some more
      bad-goto: do not linearize if the IR will be invalid
      bad-goto: reorg test in evaluate_goto_statement()
      bad-goto: simplify testing of undeclared labels
      bad-goto: do not linearize function with undeclared labels
      bad-goto: catch labels with reserved names
      scope: no memset() needed after __alloc_scope()
      scope: move scope opening/ending inside compound_statement()
      scope: extract bind_symbol_with_scope() from bind_symbol()
      scope: __func__ is special
      scope: __label__ is special
      scope: s/{start,end}_symbol_scope/{start,end}_block_scope/
      scope: let labels have their own scope
      scope: add is_in_scope()
      scope: give a scope for labels & gotos
      bad-goto: jumping inside a statement expression is an error
      bad-goto: label expression inside a statement expression is UB
      bad-goto: extract check_label_declaration()
      bad-goto: check declaration of label expressions
      bad-label: check for unused labels
      bad-label: mark labels as used when needed
      bad-label: respect attribute((unused))
      univ-init: conditionally accept { 0 } without warnings
      add an option to suppress warning 'no newline at EOF'
      testsuite: add testcase for duplicated local definitions
      add support for _Generic
      univ-init: scalar initializer needs some additional checks
      univ-init: set default to -Wno-universal-initializer
      pre-process: remove unneeded declaration of show_token_sequence()
      generic: fix crash when nothing match
      nios2: add declaration for __builtin_{rd,wr}ctl()
      builtin: can be initialized later
      builtin: use a table for the builtins
      builtin: unify the 2 tables of builtins
      builtin: add support for arch-specific builtins
      arch: add specificities for Nios2
      arch: add specificities for Blackfin
      arch: add specificities for Alpha
      testsuite: plain chars are never compatible with [un]signed chars
      ctype: keep modifiers & base_type close
      doc: add some doc for the type system
      doc: move meta-doc to its own section
      doc: add link to the doc on kernel.org in the man page
      doc: add release notes for incoming v0.6.2
      doc: show the ToC in the sidebar
      Sparse v0.6.2-rc1
      sindex: minimal version for sqlite3 is 3.24
      sindex: use -stdc=gnu99
      doc: reindent the sublists in the relnotes
      attribute: parse but ignore enum attributes
      doc: fix code-block formatting in v0.6.2 relnotes
      doc: minimal version for Sphinx is 1.7
      doc: add intro stolen from the wiki
      doc: copy the old relnotes here
      doc: update TODO
      doc: fix some typos
      doc: fix markup in types.rst (s/```/``/)
      doc: reformulate an item in the TODO
      build: let the C++ compiler be configurable
      testsuite: be less paranoid with timeout
      pre-process: add testcases for __has_feature() & __has_extension()
      pre-process: rename 'expander' into 'expand_simple'
      pre-process: add support for builtin macros
      pre-process: add support for __has_feature() & __has_extension()
      pre-process: make __has_{attribute,builtin}() true builtin macros
      Sparse v0.6.2-rc2
      gensel: add testcases from DR481
      gensel: use temporary variable in generic selection
      gensel: controlling expression must be lvalue converted
      gensel: controlling expression must be pointer-converted
      gensel: validate the type of the associations
      doc: switch to the sphinx_rtd theme
      doc: add some info to the main page
      doc: update release notes
      Sparse v0.6.2

   Oleg Nesterov (20):
      show_parse: avoid null pointer dereference in do_show_type()
      dissect: don't report anonymous members in initializers
      dissect: turn mk_name() into deanon()
      dissect: change deanon() to handle the !node case
      dissect: disallow NULL pointers in struct reporter
      dissect: introduce reporter->r_memdef()
      dissect: introduce dissect_ctx
      dissect: change do_symbol(SYM_FN) to check base_type->stmt != NULL
      dissect: kill return_type
      dissect: set sym->kind for reporter
      dissect: enforce sym->kind='f' when it looks like a function call
      dissect: introduce sym_is_local() for reporter
      dissect: move __sparse() callsite from test-dissect.c to dissect.c
      dissect: use show_ident() to print dctx->ident
      dissect: don't set ->ident = '?' in no_member()
      dissect: kill no_member()
      struct_union_enum_specifier: always initialize sym->scope
      dissect: fix sym_is_local(SYM_STRUCT/UNION/ENUM)
      dissect: enforce toplevel() if SYM_STRUCT was not defined
      make "directive in macro's argument list" a warning

   Quentin Monnet (1):
      build: fix LLVM version detection

   Ramsay Jones (6):
      lib.c: fix spelling of _BIG_ENDIAN
      cgcc: fix definition of 'linux' macro
      cgcc: only define __CYGWIN32__ for -m32 builds
      evaluate: mark evaluate_generic_selection() as static
      pre-process: fix a compiler array subscript type warning
      doc: correct some spelling

   Toomas Soome (1):
      correct sparcv9 defines

   Xan Phung (1):
      domtree: domtree_build() creates extraneous bb->doms entries

   Xi Wang (1):
      fix pointer casts in evaluate_compare()

------------------------
================================================================================


################################################################################

=== Thread: [ANNOUNCE] Sparse v0.6.2-rc2 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [ANNOUNCE] Sparse v0.6.2-rc2
Date: Thu, 18 Jun 2020 22:15:40 +0000
Message-ID: <20200618221540.gvibhjj5fxiu4g4h () ltop ! local>
--------------------
Sparse v0.6.2-rc2 is now out.

The source code can be found at its usual repository:
  git://git.kernel.org/pub/scm/devel/sparse/sparse.git v0.6.1-rc2

The tarballs can be found at:
    https://www.kernel.org/pub/software/devel/sparse/dist/
with the following sha256sum:
    37347a72ed5c5465008d3f3f473f7c2fee68ad608887018f889dd65f97174b20  sparse-0.6.2-rc2.tar.gz
    685dfe9d7342b499e8137585bcf50bf4e42d548448b46a0ab578f3be5d212f2a  sparse-0.6.2-rc2.tar.xz


The changes since the -rc1 pre-release are:
* a bunch of spelling corrections in the documentation
* enum attributes are now parsed (and ignored)
* some build fixes for old versions of gcc or sqlite
* 'make CXX=...' can now be used to specify the C++ compiler
* the testsuite don't use anymore the option '-k' of 'timeout'
* remove commented-out code in optimize.c

-- Luc
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [ANNOUNCE] Sparse v0.6.2-rc2
Date: Sat, 20 Jun 2020 00:11:13 +0000
Message-ID: <ce3f1a29-e7d1-a18b-dec9-a0e794c6d7ac () ramsayjones ! plus ! com>
--------------------


On 18/06/2020 23:15, Luc Van Oostenryck wrote:
> Sparse v0.6.2-rc2 is now out.

As expected, no issues found during testing. :-D

Thanks!

ATB,
Ramsay Jones

================================================================================


################################################################################

=== Thread: [Bug 207959] New: Don't warn about the universal zero initializer for a structure with the 'desi ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [Bug 207959] New: Don't warn about the universal zero initializer for a structure with the 'desi
Date: Thu, 28 May 2020 19:57:40 +0000
Message-ID: <90ad9ce9-fcbc-7018-3c1f-243602e49dd7 () ramsayjones ! plus ! com>
--------------------


On 28/05/2020 17:27, bugzilla-daemon@bugzilla.kernel.org wrote:
> https://bugzilla.kernel.org/show_bug.cgi?id=207959
> 
>             Bug ID: 207959
>            Summary: Don't warn about the universal zero initializer for a
>                     structure with the 'designated_init' attribute.
>            Product: Tools
>            Version: unspecified
>     Kernel Version: Sparse 0.6.1 (Debian: 0.6.1-2+b1)
>           Hardware: All
>                 OS: Linux
>               Tree: Mainline
>             Status: NEW
>           Severity: enhancement
>           Priority: P1
>          Component: Sparse
>           Assignee: tools_sparse@kernel-bugs.kernel.org
>           Reporter: AsDaGo@posteo.net
>         Regression: No
> 
> Created attachment 289383
>   --> https://bugzilla.kernel.org/attachment.cgi?id=289383&action=edit
> A test program illustrating the issue
> 
> I reported this bug to GCC here:
> https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95379
> 
> They don't want to diverge GCC's behavior from Sparse's, but I think this would
> be a useful feature, and I think it should be implemented in Sparse as well.
> Below is my bug report to GCC.
> 
>> When the 'designated_init' attribute is used on a structure type, GCC warns
>> when an instance of that structure is initialized with '{ 0 }'. I think GCC
>> should make an exception for this, since '{ 0 }' is often used to initialize
>> all fields of a structure to 0, and it does not depend on the internal
>> structure of the structure type.
>>
>> If '{ }' is used to initialize the structure, GCC does not warn. However,
>> although '{ }' seems to initialize the structure to zero in GCC, I'm not
>> sure if it's as portable as '{ 0 }' (and it's less readable, IMO). I think
>> '{ }' is part of the C++ standard; does anyone know if it's part of C too?

No this is not standard C:

  $ cat -n junk1.c
       1	#include <stdio.h>
       2	
       3	int main (int argc, char *argv[])
       4	{
       5		struct { char *f; int i; } fred = {};
       6		printf("fred.f %p, fred.i %d\n", fred.f, fred.i);
       7		return 0;	
       8	}
  $ gcc -pedantic -o junk1 junk1.c
  junk1.c: In function âmainâ:
  junk1.c:5:36: warning: ISO C forbids empty initializer braces [-Wpedantic]
    struct { char *f; int i; } fred = {};
                                      ^
  $ ./junk1
  fred.f (nil), fred.i 0
  $ 

... and you get similar results with clang:

  $ clang -pedantic -o junk1 junk1.c
  junk1.c:5:36: warning: use of GNU empty initializer extension
        [-Wgnu-empty-initializer]
          struct { char *f; int i; } fred = {};
                                            ^
  junk1.c:6:35: warning: format specifies type 'void *' but the argument has type
        'char *' [-Wformat-pedantic]
          printf("fred.f %p, fred.i %d\n", fred.f, fred.i);
                         ~~                ^~~~~~
                         %s
  2 warnings generated.
  $ 
  

ATB,
Ramsay Jones


  
================================================================================


################################################################################

=== Thread: [Bug 207959] New: Don't warn about the universal zero initializer for a structure with the 'designat ===

From: bugzilla-daemon () bugzilla ! kernel ! org
To: linux-sparse
Subject: [Bug 207959] New: Don't warn about the universal zero initializer for a structure with the 'designat
Date: Thu, 28 May 2020 16:27:17 +0000
Message-ID: <bug-207959-200559 () https ! bugzilla ! kernel ! org/>
--------------------
https://bugzilla.kernel.org/show_bug.cgi?id=207959

            Bug ID: 207959
           Summary: Don't warn about the universal zero initializer for a
                    structure with the 'designated_init' attribute.
           Product: Tools
           Version: unspecified
    Kernel Version: Sparse 0.6.1 (Debian: 0.6.1-2+b1)
          Hardware: All
                OS: Linux
              Tree: Mainline
            Status: NEW
          Severity: enhancement
          Priority: P1
         Component: Sparse
          Assignee: tools_sparse@kernel-bugs.kernel.org
          Reporter: AsDaGo@posteo.net
        Regression: No

Created attachment 289383
  --> https://bugzilla.kernel.org/attachment.cgi?id=289383&action=edit
A test program illustrating the issue

I reported this bug to GCC here:
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95379

They don't want to diverge GCC's behavior from Sparse's, but I think this would
be a useful feature, and I think it should be implemented in Sparse as well.
Below is my bug report to GCC.

> When the 'designated_init' attribute is used on a structure type, GCC warns
> when an instance of that structure is initialized with '{ 0 }'. I think GCC
> should make an exception for this, since '{ 0 }' is often used to initialize
> all fields of a structure to 0, and it does not depend on the internal
> structure of the structure type.
> 
> If '{ }' is used to initialize the structure, GCC does not warn. However,
> although '{ }' seems to initialize the structure to zero in GCC, I'm not
> sure if it's as portable as '{ 0 }' (and it's less readable, IMO). I think
> '{ }' is part of the C++ standard; does anyone know if it's part of C too?
> 
> See the attached test program (compile with 'gcc -o test test.c').

I have also included the same program I attached in the GCC bug report.

Also, since this isn't a bug report for the kernel, I've used Sparse's version
number for the "Kernel Version" field.

-- 
You are receiving this mail because:
You are watching the assignee of the bug.
================================================================================


################################################################################

=== Thread: [PATCH 0/2] testsuite: add new tags: check-output-{match,returns} ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] testsuite: add new tags: check-output-{match,returns}
Date: Sat, 31 Oct 2020 20:04:00 +0000
Message-ID: <20201031200402.31312-1-luc.vanoostenryck () gmail ! com>
--------------------
This two patches should help to write IR-related testcases by
allowing an easy way to check that every occurence of a given
instruction has a specific operand or that all functions
have the same specified return value.

Luc Van Oostenryck (2):
  testsuite: add a new tag: check-output-match
  testsuite: add a new tag: check-output-returns

 Documentation/test-suite.rst | 13 +++++++++
 validation/test-suite        | 56 ++++++++++++++++++++++++++++++++++++
 2 files changed, 69 insertions(+)


base-commit: 49c98aa3ed1b315ed2f4fbe44271ecd5bdd9cbc7
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH 0/3] teach sparse about union casts ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] teach sparse about union casts
Date: Sat, 15 Aug 2020 15:28:00 +0000
Message-ID: <20200815152803.2788-1-luc.vanoostenryck () gmail ! com>
--------------------
This series adds support for union casts which otherwise give
technically exact diagnostic messages:
	warning: cast to non-scalar
But these warnings are not interesting because GCC and clang
support these casts, they are used in the kernel (but not much:
~13 in the usual x86 configs) and they are not especially dangerous
(like losing bits or cheating with types).


Luc Van Oostenryck (3):
  union-cast: add some testcases
  union-cast: extract evaluate_compound_literal()
  union-cast: teach sparse about union casts

 Documentation/release-notes/v0.6.3.rst |  5 ++
 evaluate.c                             | 88 ++++++++++++++++++++------
 options.c                              |  2 +
 options.h                              |  1 +
 sparse.1                               |  6 ++
 validation/eval/union-cast-no.c        | 23 +++++++
 validation/eval/union-cast.c           | 24 +++++++
 7 files changed, 129 insertions(+), 20 deletions(-)
 create mode 100644 Documentation/release-notes/v0.6.3.rst
 create mode 100644 validation/eval/union-cast-no.c
 create mode 100644 validation/eval/union-cast.c


base-commit: 49f7e13a7ac9a582d11e9c1ad01e71740f486601
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 0/4] Fix shifts-assigns and avoid warns on deadcode ===

From: Stafford Horne <shorne () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/4] Fix shifts-assigns and avoid warns on deadcode
Date: Sat, 15 Aug 2020 09:59:49 +0000
Message-ID: <20200815095949.GV80756 () lianli ! shorne-pla ! net>
--------------------
On Thu, Aug 06, 2020 at 09:29:59PM +0200, Luc Van Oostenryck wrote:
> Sparse warns shifts by a negative or oversized amount but
> it does this even on code that will not be executed. It's
> annoying because such warnings are given for generic macros.
> 
> The strategy for these warnings is changed in patch 4:
> they are delayed until after the elimination of deadcode.
> This uncovered a bug in the type evaluation and the linearization
> of shift-assigns which is now solved in patch 2 & 3.
> 
> Thanks to Stafford Horne to bring this back to my attention.
> 
> This series is available for testing & review at:
>   git://git.kernel.org/pub/scm/devel/sparse/sparse.git bad-shift-equal

Thanks!

I see you merged this already, I tested it and see no regressions on my kernel
build, and confirm the xchg issues are fixed.

Sorry, I reviewed this early but didn't respond until now as I had time to test.

I just had one question on 4/4.

-Stafford

> Luc Van Oostenryck (4):
>   shift-assign: add more testcases for bogus linearization
>   shift-assign: fix linearization of shift-assign
>   shift-assign: restrict shift count to unsigned int
>   bad-shift: wait dead code elimination to warn about bad shifts
> 
>  evaluate.c                         |  11 +-
>  expand.c                           |  18 --
>  linearize.c                        |  44 ++++
>  simplify.c                         |  20 +-
>  validation/expand/bad-shift.c      |   8 +-
>  validation/linear/bug-assign-op0.c |   1 -
>  validation/linear/shift-assign1.c  | 319 +++++++++++++++++++++++++++++
>  validation/linear/shift-assign2.c  |  53 +++++
>  validation/optim/shift-big.c       |  12 +-
>  validation/shift-negative.c        |   4 +-
>  validation/shift-undef-long.c      |   7 +-
>  validation/shift-undef.c           |  52 ++---
>  12 files changed, 462 insertions(+), 87 deletions(-)
>  create mode 100644 validation/linear/shift-assign1.c
>  create mode 100644 validation/linear/shift-assign2.c
> 
> 
> base-commit: 4c6cbe557c48205f9b3d2aae4c166cd66446b240
> -- 
> 2.28.0
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/4] Fix shifts-assigns and avoid warns on deadcode
Date: Sat, 15 Aug 2020 11:03:24 +0000
Message-ID: <20200815110324.j4kvv2brr2lgcxnc () ltop ! local>
--------------------
On Sat, Aug 15, 2020 at 06:59:49PM +0900, Stafford Horne wrote:
> On Thu, Aug 06, 2020 at 09:29:59PM +0200, Luc Van Oostenryck wrote:
> > Sparse warns shifts by a negative or oversized amount but
> > it does this even on code that will not be executed. It's
> > annoying because such warnings are given for generic macros.
> > 
> > The strategy for these warnings is changed in patch 4:
> > they are delayed until after the elimination of deadcode.
> > This uncovered a bug in the type evaluation and the linearization
> > of shift-assigns which is now solved in patch 2 & 3.
> > 
> > Thanks to Stafford Horne to bring this back to my attention.
> > 
> > This series is available for testing & review at:
> >   git://git.kernel.org/pub/scm/devel/sparse/sparse.git bad-shift-equal
> 
> Thanks!
> 
> I see you merged this already, I tested it and see no regressions on my kernel
> build, and confirm the xchg issues are fixed.
> 
> Sorry, I reviewed this early but didn't respond until now as I had time to test.

I should have waited a little more before merging (but OTOH, I thought,
it would be easier for you to give it a try before sending your PR
to Linus if already merged).

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH 0/4] dissect: minor fixes/cleanups ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 0/4] dissect: minor fixes/cleanups
Date: Tue, 04 Feb 2020 16:51:19 +0000
Message-ID: <20200204165119.GA24330 () redhat ! com>
--------------------
Hello,

Preparations for the new functionality.

Oleg.
---
 dissect.c      | 42 +++++++++++++++++++-----------------------
 test-dissect.c |  7 +++----
 2 files changed, 22 insertions(+), 27 deletions(-)

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/4] dissect: minor fixes/cleanups
Date: Thu, 06 Feb 2020 03:08:11 +0000
Message-ID: <20200206030811.lkcvfmwgztrx44js () ltop ! local>
--------------------
On Tue, Feb 04, 2020 at 05:51:19PM +0100, Oleg Nesterov wrote:

Thanks for theses patches and the following one.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH 0/5] Fixes for generic selection ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/5] Fixes for generic selection
Date: Fri, 19 Jun 2020 15:02:55 +0000
Message-ID: <20200619150300.63695-1-luc.vanoostenryck () gmail ! com>
--------------------
This series contains:
* the controlling expression must be lvalue-converted,
  array-to-pointer & function-to-pointer converted.
  These are the rules following the resolution of DR481
  and are also used for C17 (and are followed by both
  GCC & clang).
* validate the type of the associations.

These patches are available for testing & review at:
  git://git.kernel.org/pub/scm/devel/sparse/sparse.git fix-gensel


Note: A small inconsistency remains: a plain char
      will match a signed char or a unsigned char.

Luc Van Oostenryck (5):
  gensel: add testcases from DR481
  gensel: use temporary variable in generic selection
  gensel: controlling expression must be lvalue converted
  gensel: controlling expression must be pointer-converted
  gensel: validate the type of the associations

 evaluate.c                 | 33 ++++++++++++++++++++++++++++++---
 validation/generic-dr481.c | 17 +++++++++++++++++
 2 files changed, 47 insertions(+), 3 deletions(-)
 create mode 100644 validation/generic-dr481.c

-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 0/5] add support for __builtin_unreachable() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/5] add support for __builtin_unreachable()
Date: Wed, 18 Mar 2020 17:31:15 +0000
Message-ID: <20200318173120.63939-1-luc.vanoostenryck () gmail ! com>
--------------------
__builtin_unreachable() has direct consequences on the CFG
and should thus not be ignored. This series add minimal
support for it, motivated by some improvements in the
processing of contexts.


Luc Van Oostenryck (5):
  add testcases for OP_UNREACH
  add instruction OP_UNREACH
  add an implicit __builtin_unreachable() for __noreturn
  add support for linearization of builtins
  teach sparse to linearize __builtin_unreachable()

 Documentation/IR.rst                          |  3 ++
 builtin.c                                     |  2 +
 linearize.c                                   | 52 +++++++++++++++++++
 opcode.def                                    |  1 +
 symbol.h                                      |  7 ++-
 validation/context-unreachable.c              | 15 ++++++
 validation/linear/builtin_unreachable0.c      | 29 +++++++++++
 ...n_unreachable.c => builtin_unreachable1.c} | 15 +++---
 validation/linear/noreturn-unreachable0.c     | 22 ++++++++
 9 files changed, 137 insertions(+), 9 deletions(-)
 create mode 100644 validation/context-unreachable.c
 create mode 100644 validation/linear/builtin_unreachable0.c
 rename validation/linear/{builtin_unreachable.c => builtin_unreachable1.c} (59%)
 create mode 100644 validation/linear/noreturn-unreachable0.c


base-commit: 0558317d0c7a2e20a6d82b7ef35357ec02e2ad38
-- 
2.25.1

================================================================================


################################################################################

=== Thread: [PATCH 0/6] fix parsing of C99's array declarators ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/6] fix parsing of C99's array declarators
Date: Thu, 23 Jul 2020 23:46:35 +0000
Message-ID: <20200723234641.78462-1-luc.vanoostenryck () gmail ! com>
--------------------
C99's array declarators were only partially parsed.
This series completes and simplify this parsing.

Luc Van Oostenryck (6):
  add testcase for comma in array declarator
  do not accept comma expressions in array declarator
  add testcases for C99 array declarators
  simplify & fix parsing of array declarators
  remove now unused match_idents()
  allow [*] in array declarators

 parse.c                                      | 53 ++++++--------------
 symbol.h                                     |  2 +-
 validation/abstract-array-declarator-quals.c | 21 ++++++++
 validation/abstract-array-declarator-star.c  |  8 +++
 validation/abstract-array-declarator.c       | 11 ++++
 5 files changed, 57 insertions(+), 38 deletions(-)
 create mode 100644 validation/abstract-array-declarator-quals.c
 create mode 100644 validation/abstract-array-declarator-star.c
 create mode 100644 validation/abstract-array-declarator.c

-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 0/7] doc: small tweaks to the online documentation ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/7] doc: small tweaks to the online documentation
Date: Mon, 10 Aug 2020 21:53:29 +0000
Message-ID: <20200810215336.76070-1-luc.vanoostenryck () gmail ! com>
--------------------
This series contains some adjustment to the spacing in the generated
HTML and some small changes in the content of the main page.

Luc Van Oostenryck (7):
  doc: use a smaller logo in the sidebar
  doc: make the sidebar more compact
  doc: decrease vertical spacing
  doc: move down info about tarballs, after git repositories
  doc: reorganize the table of content
  doc: use shorter titles
  doc: add links to some external doc

 Documentation/IR.rst                          |  4 +--
 Documentation/conf.py                         |  8 +++++-
 Documentation/dev-options.rst                 |  4 +--
 Documentation/doc-guide.rst                   |  4 +--
 Documentation/index.rst                       | 26 +++++++++++--------
 .../sphinx/static/theme_overrides.css         | 20 ++++++++++++++
 Documentation/types.rst                       |  6 ++---
 7 files changed, 51 insertions(+), 21 deletions(-)
 create mode 100644 Documentation/sphinx/static/theme_overrides.css


base-commit: 6fe6d05b56815966b452b0363c9ffd11e1787f85
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 01/13] flex-array: add testcases ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 01/13] flex-array: add testcases
Date: Wed, 30 Sep 2020 23:18:16 +0000
Message-ID: <20200930231828.66751-2-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/flex-array-align.c   | 19 +++++++++++++++++++
 validation/flex-array-array.c   | 16 ++++++++++++++++
 validation/flex-array-error.c   | 27 +++++++++++++++++++++++++++
 validation/flex-array-nested.c  | 30 ++++++++++++++++++++++++++++++
 validation/flex-array-padding.c | 22 ++++++++++++++++++++++
 validation/flex-array-sizeof.c  | 19 +++++++++++++++++++
 6 files changed, 133 insertions(+)
 create mode 100644 validation/flex-array-align.c
 create mode 100644 validation/flex-array-array.c
 create mode 100644 validation/flex-array-error.c
 create mode 100644 validation/flex-array-nested.c
 create mode 100644 validation/flex-array-padding.c
 create mode 100644 validation/flex-array-sizeof.c

diff --git a/validation/flex-array-align.c b/validation/flex-array-align.c
new file mode 100644
index 000000000000..0cc67ab36997
--- /dev/null
+++ b/validation/flex-array-align.c
@@ -0,0 +1,19 @@
+struct s {
+	__INT32_TYPE__ x;
+	__INT16_TYPE__ y;
+	unsigned char f[];
+};
+
+static int foo(struct s *s)
+{
+	return (sizeof(*s) << 16) | __builtin_offsetof(typeof(*s), f);
+}
+
+/*
+ * check-name: flex-array-align
+ * check-command: test-linearize -Wno-flexible-array-sizeof $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-contains: ret\\..*\\$0x80006
+ */
diff --git a/validation/flex-array-array.c b/validation/flex-array-array.c
new file mode 100644
index 000000000000..bda80d7a0a20
--- /dev/null
+++ b/validation/flex-array-array.c
@@ -0,0 +1,16 @@
+struct s {
+	int i;
+	long f[];
+};
+
+static struct s a[2];
+
+/*
+ * check-name: flex-array-array
+ * check-command: sparse -Wflexible-array-array $file
+ * check-known-to-fail
+ *
+ * check-error-start
+flex-array-array.c:6:18: warning: array of flexible structures
+ * check-error-end
+ */
diff --git a/validation/flex-array-error.c b/validation/flex-array-error.c
new file mode 100644
index 000000000000..89601e42daf6
--- /dev/null
+++ b/validation/flex-array-error.c
@@ -0,0 +1,27 @@
+struct s {
+	int i;
+	long f[];
+	int j;
+};
+
+union u {
+	int i;
+	long f[];
+};
+
+// trigger the examination of the offending types
+static int foo(struct s *s, union u *u)
+{
+	return    __builtin_offsetof(typeof(*s), i)
+		+ __builtin_offsetof(typeof(*u), i);
+}
+
+/*
+ * check-name: flex-array-error
+ * check-known-to-fail
+ *
+ * check-error-start
+flex-array-error.c:3:14: error: flexible array member 'f' is not last
+flex-array-error.c:9:14: error: flexible array member 'f' in a union
+ * check-error-end
+ */
diff --git a/validation/flex-array-nested.c b/validation/flex-array-nested.c
new file mode 100644
index 000000000000..3503c329d7c3
--- /dev/null
+++ b/validation/flex-array-nested.c
@@ -0,0 +1,30 @@
+struct f {
+	int i;
+	long f[];
+};
+
+struct s {
+	struct f f;
+};
+
+union u {
+	struct f f;
+};
+
+// trigger the examination of the offending types
+static int foo(struct s *s, union u *u)
+{
+	return    __builtin_offsetof(typeof(*s), f)
+		+ __builtin_offsetof(typeof(*u), f);
+}
+
+/*
+ * check-name: flex-array-nested
+ * check-command: sparse -Wflexible-array-nested $file
+ * check-known-to-fail
+ *
+ * check-error-start
+flex-array-nested.c:6:8: warning: nested flexible arrays
+flex-array-nested.c:10:7: warning: nested flexible arrays
+ * check-error-end
+ */
diff --git a/validation/flex-array-padding.c b/validation/flex-array-padding.c
new file mode 100644
index 000000000000..2ba77971266e
--- /dev/null
+++ b/validation/flex-array-padding.c
@@ -0,0 +1,22 @@
+struct s {
+	__INT32_TYPE__ x;
+	__INT16_TYPE__ y;
+	unsigned char f[];
+};
+
+static int foo(struct s *s)
+{
+	return __builtin_offsetof(typeof(*s), f);
+}
+
+/*
+ * check-name: flex-array-padding
+ * check-command: test-linearize -Wflexible-array-padding $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ *
+ * check-error-start
+flex-array-padding.c:4:23: warning: flexible array member has padding
+ * check-error-end
+ */
diff --git a/validation/flex-array-sizeof.c b/validation/flex-array-sizeof.c
new file mode 100644
index 000000000000..3359509d0084
--- /dev/null
+++ b/validation/flex-array-sizeof.c
@@ -0,0 +1,19 @@
+struct s {
+	int i;
+	long f[];
+};
+
+static int foo(struct s *s)
+{
+	return sizeof(*s);
+}
+
+/*
+ * check-name: flex-array-sizeof
+ * check-command: sparse -Wflexible-array-sizeof $file
+ * check-known-to-fail
+ *
+ * check-error-start
+flex-array-sizeof.c:8:16: warning: using sizeof on a flexible structure
+ * check-error-end
+ */
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 01/17] bad-goto: add testcase for 'jump inside discarded expression statement' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 01/17] bad-goto: add testcase for 'jump inside discarded expression statement'
Date: Mon, 13 Apr 2020 16:15:49 +0000
Message-ID: <20200413161605.95900-2-luc.vanoostenryck () gmail ! com>
--------------------
A goto done into an piece of code discarded at expand or
linearize time will produce an invalid IR.

Add a testcase for it.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/label-stmt-expr1.c           | 30 +++++++++++++++++++++++++
 validation/linear/goto-and-expr-stmt0.c | 28 +++++++++++++++++++++++
 2 files changed, 58 insertions(+)
 create mode 100644 validation/label-stmt-expr1.c
 create mode 100644 validation/linear/goto-and-expr-stmt0.c

diff --git a/validation/label-stmt-expr1.c b/validation/label-stmt-expr1.c
new file mode 100644
index 000000000000..47ba54ae7305
--- /dev/null
+++ b/validation/label-stmt-expr1.c
@@ -0,0 +1,30 @@
+static int foo(void)
+{
+	goto l;
+	return	({
+l:
+		0;
+	});
+}
+
+static void bar(void)
+{
+	int r;
+	r = ({
+l:
+		0;
+	});
+	goto l;
+}
+
+/*
+ * check-name: label-stmt-expr1
+ * check-known-to-fail
+ *
+ * check-error-start
+label-stmt-expr1.c:3:9: error: goto into statement expression
+label-stmt-expr1.c:5:1:    label 'l' is defined here
+label-stmt-expr1.c:17:9: error: goto into statement expression
+label-stmt-expr1.c:14:1:    label 'l' is defined here
+ * check-error-end
+ */
diff --git a/validation/linear/goto-and-expr-stmt0.c b/validation/linear/goto-and-expr-stmt0.c
new file mode 100644
index 000000000000..548813531779
--- /dev/null
+++ b/validation/linear/goto-and-expr-stmt0.c
@@ -0,0 +1,28 @@
+int t(void)
+{
+	goto inside;
+	return 1 ? 2 : ({
+inside:
+			return 3;
+			4;
+		    });
+}
+
+void f(int x, int y)
+{
+	1 ? x : ({
+a:
+		 y;
+	});
+	goto a;
+}
+
+/*
+ * check-name: goto-and-expr-stmt0
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-excludes: END
+ * check-error-ignore
+ */
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 02/13] flex-array: factor out common part of lay_out_{struct,union}() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 02/13] flex-array: factor out common part of lay_out_{struct,union}()
Date: Wed, 30 Sep 2020 23:18:17 +0000
Message-ID: <20200930231828.66751-3-luc.vanoostenryck () gmail ! com>
--------------------
This is a preparatory step for later patches.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c | 24 ++++++++----------------
 1 file changed, 8 insertions(+), 16 deletions(-)

diff --git a/symbol.c b/symbol.c
index 7f0c85580f06..365351a0a756 100644
--- a/symbol.c
+++ b/symbol.c
@@ -94,14 +94,6 @@ struct struct_union_info {
  */
 static void lay_out_union(struct symbol *sym, struct struct_union_info *info)
 {
-	examine_symbol_type(sym);
-
-	// Unnamed bitfields do not affect alignment.
-	if (sym->ident || !is_bitfield_type(sym)) {
-		if (sym->ctype.alignment > info->max_align)
-			info->max_align = sym->ctype.alignment;
-	}
-
 	if (sym->bit_size > info->bit_size)
 		info->bit_size = sym->bit_size;
 
@@ -125,14 +117,6 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
 	unsigned long bit_size, align_bit_mask;
 	int base_size;
 
-	examine_symbol_type(sym);
-
-	// Unnamed bitfields do not affect alignment.
-	if (sym->ident || !is_bitfield_type(sym)) {
-		if (sym->ctype.alignment > info->max_align)
-			info->max_align = sym->ctype.alignment;
-	}
-
 	bit_size = info->bit_size;
 	base_size = sym->bit_size; 
 
@@ -196,6 +180,14 @@ static struct symbol * examine_struct_union_type(struct symbol *sym, int advance
 			sparse_error(member->pos, "member '%s' has __auto_type", show_ident(member->ident));
 			member->ctype.base_type = &incomplete_ctype;
 		}
+		examine_symbol_type(member);
+
+		if (member->ctype.alignment > info.max_align) {
+			// Unnamed bitfields do not affect alignment.
+			if (member->ident || !is_bitfield_type(member))
+				info.max_align = member->ctype.alignment;
+		}
+
 		fn(member, &info);
 	} END_FOR_EACH_PTR(member);
 
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 02/17] bad-goto: add testcases for linearization of invalid labels ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 02/17] bad-goto: add testcases for linearization of invalid labels
Date: Mon, 13 Apr 2020 16:15:50 +0000
Message-ID: <20200413161605.95900-3-luc.vanoostenryck () gmail ! com>
--------------------
A goto to a reserved or a undeclared label will generate
an IR with a branch to a non-existing BB. Bad.

Add a testcase for these.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/linear/invalid-labels0.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)
 create mode 100644 validation/linear/invalid-labels0.c

diff --git a/validation/linear/invalid-labels0.c b/validation/linear/invalid-labels0.c
new file mode 100644
index 000000000000..ae3bf7283fb8
--- /dev/null
+++ b/validation/linear/invalid-labels0.c
@@ -0,0 +1,19 @@
+static void foo(void)
+{
+	goto return;
+}
+
+void bar(void)
+{
+	goto neverland;
+}
+
+/*
+ * check-name: invalid-labels0
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-excludes: END
+ * check-error-ignore
+ */
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 03/13] flex-array: do not lay out invalid struct members ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 03/13] flex-array: do not lay out invalid struct members
Date: Wed, 30 Sep 2020 23:18:18 +0000
Message-ID: <20200930231828.66751-4-luc.vanoostenryck () gmail ! com>
--------------------
Do not bother trying to lay out invalid struct members,
ignore them as it will avoid to special case them later.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/symbol.c b/symbol.c
index 365351a0a756..4c93a0fb4880 100644
--- a/symbol.c
+++ b/symbol.c
@@ -121,10 +121,12 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
 	base_size = sym->bit_size; 
 
 	/*
-	 * Unsized arrays cause us to not align the resulting
-	 * structure size
+	 * If the member is unsized, either it's a flexible array or
+	 * it's invalid and a warning has already been issued.
 	 */
 	if (base_size < 0) {
+		if (!is_array_type(sym))
+			return;
 		info->align_size = 0;
 		base_size = 0;
 	}
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 04/13] flex-array: flexible array members have zero size and alignment is OK ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 04/13] flex-array: flexible array members have zero size and alignment is OK
Date: Wed, 30 Sep 2020 23:18:19 +0000
Message-ID: <20200930231828.66751-5-luc.vanoostenryck () gmail ! com>
--------------------
When doing the layout of structures, flexible arrays used to
not align the resulting structure size.

However, the standard specify that while for most purposes
flexible arrays can be handled as if not present, they still
may add some trailing padding (cfr. C11's 6.7.2.1p18).

So, there is no reason to reset the alignment.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c                      | 1 -
 validation/flex-array-align.c | 1 -
 2 files changed, 2 deletions(-)

diff --git a/symbol.c b/symbol.c
index 4c93a0fb4880..9acffeea7fad 100644
--- a/symbol.c
+++ b/symbol.c
@@ -127,7 +127,6 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
 	if (base_size < 0) {
 		if (!is_array_type(sym))
 			return;
-		info->align_size = 0;
 		base_size = 0;
 	}
 
diff --git a/validation/flex-array-align.c b/validation/flex-array-align.c
index 0cc67ab36997..9f28942a1ee1 100644
--- a/validation/flex-array-align.c
+++ b/validation/flex-array-align.c
@@ -12,7 +12,6 @@ static int foo(struct s *s)
 /*
  * check-name: flex-array-align
  * check-command: test-linearize -Wno-flexible-array-sizeof $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-contains: ret\\..*\\$0x80006
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 04/17] bad-goto: do not linearize if the IR will be invalid ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 04/17] bad-goto: do not linearize if the IR will be invalid
Date: Mon, 13 Apr 2020 16:15:52 +0000
Message-ID: <20200413161605.95900-5-luc.vanoostenryck () gmail ! com>
--------------------
In some error cases, it's not possible to produce a valid &
correct IR for the concerned function. For exemple, if the
AST contains invalid gotos, the CFG will either be invalid
or won't correspond to the erroneous source code.

So, refuse to linearize such functions.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c | 2 +-
 symbol.h    | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index b040d345d469..222714564a3f 100644
--- a/linearize.c
+++ b/linearize.c
@@ -2480,7 +2480,7 @@ static struct entrypoint *linearize_fn(struct symbol *sym, struct symbol *base_t
 	pseudo_t result;
 	int i;
 
-	if (!stmt)
+	if (!stmt || base_type->bogus_linear)
 		return NULL;
 
 	ep = alloc_entrypoint();
diff --git a/symbol.h b/symbol.h
index c86dfb335e29..de13d60b8b75 100644
--- a/symbol.h
+++ b/symbol.h
@@ -171,6 +171,7 @@ struct symbol {
 			unsigned long	offset;
 			int		bit_size;
 			unsigned int	bit_offset:8,
+					bogus_linear:1,
 					variadic:1,
 					initialized:1,
 					examined:1,
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 05/13] flex-array: detect structures with a flexible array member ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 05/13] flex-array: detect structures with a flexible array member
Date: Wed, 30 Sep 2020 23:18:20 +0000
Message-ID: <20200930231828.66751-6-luc.vanoostenryck () gmail ! com>
--------------------
This is a preparatory step for doing the checks and warnings.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/symbol.c b/symbol.c
index 9acffeea7fad..6633e89de4a9 100644
--- a/symbol.c
+++ b/symbol.c
@@ -87,6 +87,7 @@ struct struct_union_info {
 	unsigned long max_align;
 	unsigned long bit_size;
 	int align_size;
+	struct symbol *flex_array;
 };
 
 /*
@@ -128,6 +129,7 @@ static void lay_out_struct(struct symbol *sym, struct struct_union_info *info)
 		if (!is_array_type(sym))
 			return;
 		base_size = 0;
+		info->flex_array = sym;
 	}
 
 	align_bit_mask = bytes_to_bits(sym->ctype.alignment) - 1;
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 05/17] bad-goto: reorg test in evaluate_goto_statement() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 05/17] bad-goto: reorg test in evaluate_goto_statement()
Date: Mon, 13 Apr 2020 16:15:53 +0000
Message-ID: <20200413161605.95900-6-luc.vanoostenryck () gmail ! com>
--------------------
No functional changes here, only changing the code structure
to prepare more incoming changes.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index b7bb1f52aa91..a432d243610e 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3741,10 +3741,14 @@ static void evaluate_goto_statement(struct statement *stmt)
 {
 	struct symbol *label = stmt->goto_label;
 
-	if (label && !label->stmt && label->ident && !lookup_keyword(label->ident, NS_KEYWORD))
+	if (!label) {
+		// no label associated, may be a computed goto
+		evaluate_expression(stmt->goto_expression);
+		return;
+	}
+	if (!label->stmt && label->ident && !lookup_keyword(label->ident, NS_KEYWORD)) {
 		sparse_error(stmt->pos, "label '%s' was not declared", show_ident(label->ident));
-
-	evaluate_expression(stmt->goto_expression);
+	}
 }
 
 struct symbol *evaluate_statement(struct statement *stmt)
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 06/13] flex-array: warn on flexible arrays in unions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 06/13] flex-array: warn on flexible arrays in unions
Date: Wed, 30 Sep 2020 23:18:21 +0000
Message-ID: <20200930231828.66751-7-luc.vanoostenryck () gmail ! com>
--------------------
Flexible array members are not allowed in unions.
So, warn if one is present.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/symbol.c b/symbol.c
index 6633e89de4a9..e578b1a840a3 100644
--- a/symbol.c
+++ b/symbol.c
@@ -95,6 +95,9 @@ struct struct_union_info {
  */
 static void lay_out_union(struct symbol *sym, struct struct_union_info *info)
 {
+	if (sym->bit_size < 0 && is_array_type(sym))
+		sparse_error(sym->pos, "flexible array member '%s' in a union", show_ident(sym->ident));
+
 	if (sym->bit_size > info->bit_size)
 		info->bit_size = sym->bit_size;
 
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 06/17] bad-goto: simplify testing of undeclared labels ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 06/17] bad-goto: simplify testing of undeclared labels
Date: Mon, 13 Apr 2020 16:15:54 +0000
Message-ID: <20200413161605.95900-7-luc.vanoostenryck () gmail ! com>
--------------------
There is no need to do a lookup: checking if the label's
symbol is in the NS_LABEL namespace and is lacking an
associated statement is enough and much simpler.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index a432d243610e..dc66b2e6ad9a 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3746,7 +3746,8 @@ static void evaluate_goto_statement(struct statement *stmt)
 		evaluate_expression(stmt->goto_expression);
 		return;
 	}
-	if (!label->stmt && label->ident && !lookup_keyword(label->ident, NS_KEYWORD)) {
+
+	if (label->namespace == NS_LABEL && !label->stmt) {
 		sparse_error(stmt->pos, "label '%s' was not declared", show_ident(label->ident));
 	}
 }
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 07/10] attribute: no need to lookup '__attribute__' in NS_KEYWORD ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 07/10] attribute: no need to lookup '__attribute__' in NS_KEYWORD
Date: Sun, 09 Aug 2020 20:53:26 +0000
Message-ID: <20200809205329.42811-8-luc.vanoostenryck () gmail ! com>
--------------------
Since '__attribute__' is in NS_TYPEDEF, it's not useful to
look it up also in NS_KEYWORD.

So, remove NS_KEYWORD from the mask while looking up '__attribute__'.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/parse.c b/parse.c
index 681d98e49641..f2fdbc9b5a7b 100644
--- a/parse.c
+++ b/parse.c
@@ -1769,7 +1769,7 @@ static bool match_attribute(struct token *token)
 
 	if (token_type(token) != TOKEN_IDENT)
 		return false;
-	sym = lookup_keyword(token->ident, NS_KEYWORD | NS_TYPEDEF);
+	sym = lookup_keyword(token->ident, NS_TYPEDEF);
 	if (!sym || sym->type != SYM_KEYWORD)
 		return false;
 	return sym->op->type & KW_ATTRIBUTE;
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 07/13] flex-array: warn if flexible array is not last ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 07/13] flex-array: warn if flexible array is not last
Date: Wed, 30 Sep 2020 23:18:22 +0000
Message-ID: <20200930231828.66751-8-luc.vanoostenryck () gmail ! com>
--------------------
Flexible array members must be the last in a structure.
Warn if it is not the case.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c                      | 2 ++
 validation/flex-array-error.c | 1 -
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/symbol.c b/symbol.c
index e578b1a840a3..b4c5e471372b 100644
--- a/symbol.c
+++ b/symbol.c
@@ -186,6 +186,8 @@ static struct symbol * examine_struct_union_type(struct symbol *sym, int advance
 			sparse_error(member->pos, "member '%s' has __auto_type", show_ident(member->ident));
 			member->ctype.base_type = &incomplete_ctype;
 		}
+		if (info.flex_array)
+			sparse_error(info.flex_array->pos, "flexible array member '%s' is not last", show_ident(info.flex_array->ident));
 		examine_symbol_type(member);
 
 		if (member->ctype.alignment > info.max_align) {
diff --git a/validation/flex-array-error.c b/validation/flex-array-error.c
index 89601e42daf6..2b7e6953050c 100644
--- a/validation/flex-array-error.c
+++ b/validation/flex-array-error.c
@@ -18,7 +18,6 @@ static int foo(struct s *s, union u *u)
 
 /*
  * check-name: flex-array-error
- * check-known-to-fail
  *
  * check-error-start
 flex-array-error.c:3:14: error: flexible array member 'f' is not last
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 08/10] testing for SYM_KEYWORD is unneeded for lookup_keyword() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 08/10] testing for SYM_KEYWORD is unneeded for lookup_keyword()
Date: Sun, 09 Aug 2020 20:53:27 +0000
Message-ID: <20200809205329.42811-9-luc.vanoostenryck () gmail ! com>
--------------------
All symbols returned by lookup_keyword() are of type SYM_KEYWORD,
because either:
   1) it's in NS_KEYWORD (and all symbol in NS_KEYWORD are SYM_KEYWORD)
   2) it's in NS_TYPEDEF and all *keywords* in NS_TYPEDEF are reserved
      and so can't be user defined and so must be SYM_KEYWORD.
It's thus unneeded to test it.

So, remove the unneeded test.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/parse.c b/parse.c
index f2fdbc9b5a7b..2b7ef2ae23c4 100644
--- a/parse.c
+++ b/parse.c
@@ -1620,8 +1620,6 @@ static struct token *handle_qualifiers(struct token *t, struct decl_state *ctx)
 		struct symbol *s = lookup_keyword(t->ident, NS_TYPEDEF);
 		if (!s)
 			break;
-		if (s->type != SYM_KEYWORD)
-			break;
 		if (!(s->op->type & (KW_ATTRIBUTE | KW_QUALIFIER)))
 			break;
 		t = t->next;
@@ -1749,7 +1747,7 @@ static struct token *handle_asm_name(struct token *token, struct decl_state *ctx
 	if (token_type(token) != TOKEN_IDENT)
 		return token;
 	keyword = lookup_keyword(token->ident, NS_KEYWORD);
-	if (!keyword || keyword->type != SYM_KEYWORD)
+	if (!keyword)
 		return token;
 	if (!(keyword->op->type & KW_ASM))
 		return token;
@@ -1770,7 +1768,7 @@ static bool match_attribute(struct token *token)
 	if (token_type(token) != TOKEN_IDENT)
 		return false;
 	sym = lookup_keyword(token->ident, NS_TYPEDEF);
-	if (!sym || sym->type != SYM_KEYWORD)
+	if (!sym)
 		return false;
 	return sym->op->type & KW_ATTRIBUTE;
 }
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 08/17] bad-goto: catch labels with reserved names ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 08/17] bad-goto: catch labels with reserved names
Date: Mon, 13 Apr 2020 16:15:56 +0000
Message-ID: <20200413161605.95900-9-luc.vanoostenryck () gmail ! com>
--------------------
If a reserved name is used as the destination of a goto,
its associated label won't be valid and at linearization
time no BB will can be created for it, resulting in an
invalid IR.

So, catch such gotos at evaluation time and mark the
function to not be linearized.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                          | 2 ++
 validation/linear/invalid-labels0.c | 1 -
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index 14953f195fcc..99a9ee72d11f 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3751,6 +3751,8 @@ static void evaluate_goto_statement(struct statement *stmt)
 		sparse_error(stmt->pos, "label '%s' was not declared", show_ident(label->ident));
 		current_fn->bogus_linear = 1;
 	}
+	if (label->namespace == NS_NONE)
+		current_fn->bogus_linear = 1;
 }
 
 struct symbol *evaluate_statement(struct statement *stmt)
diff --git a/validation/linear/invalid-labels0.c b/validation/linear/invalid-labels0.c
index ae3bf7283fb8..a15e9d434011 100644
--- a/validation/linear/invalid-labels0.c
+++ b/validation/linear/invalid-labels0.c
@@ -11,7 +11,6 @@ void bar(void)
 /*
  * check-name: invalid-labels0
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: END
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 09/10] testing for sym->op is unneeded for lookup_keyword() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 09/10] testing for sym->op is unneeded for lookup_keyword()
Date: Sun, 09 Aug 2020 20:53:28 +0000
Message-ID: <20200809205329.42811-10-luc.vanoostenryck () gmail ! com>
--------------------
All symbols returned by lookup_keyword() are of type SYM_KEYWORD,
because either:
   1) it's in NS_KEYWORD (and all symbol in NS_KEYWORD are SYM_KEYWORD)
   2) it's in NS_TYPEDEF and all *keywords* in NS_TYPEDEF are reserved
      and so can't be user defined and so must be SYM_KEYWORD.
Thus, they all have a symbol_op associated to them and it's
unneeded to test it.

So, remove the unneeded test.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/parse.c b/parse.c
index 2b7ef2ae23c4..d378f1255fee 100644
--- a/parse.c
+++ b/parse.c
@@ -2160,7 +2160,7 @@ static struct token *parse_asm_statement(struct token *token, struct statement *
 	stmt->type = STMT_ASM;
 	while (token_type(token) == TOKEN_IDENT) {
 		struct symbol *s = lookup_keyword(token->ident, NS_TYPEDEF);
-		if (s && s->op  && s->op->asm_modifier)
+		if (s && s->op->asm_modifier)
 			s->op->asm_modifier(token, &mods);
 		else if (token->ident == &goto_ident)
 			asm_modifier(token, &mods, MOD_ASM_GOTO);
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 09/13] flex-array: add helper has_flexible_array() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 09/13] flex-array: add helper has_flexible_array()
Date: Wed, 30 Sep 2020 23:18:24 +0000
Message-ID: <20200930231828.66751-10-luc.vanoostenryck () gmail ! com>
--------------------
This will make later checks easier & clearer.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/symbol.h b/symbol.h
index 287df0a3a0ee..c9e6c7fe4439 100644
--- a/symbol.h
+++ b/symbol.h
@@ -507,6 +507,13 @@ static inline int is_extern_inline(struct symbol *sym)
 		is_function(sym->ctype.base_type);
 }
 
+static inline int has_flexible_array(struct symbol *type)
+{
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	return type->has_flex_array;
+}
+
 static inline int get_sym_type(struct symbol *type)
 {
 	if (type->type == SYM_NODE)
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 09/17] scope: no memset() needed after __alloc_scope() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 09/17] scope: no memset() needed after __alloc_scope()
Date: Mon, 13 Apr 2020 16:15:57 +0000
Message-ID: <20200413161605.95900-10-luc.vanoostenryck () gmail ! com>
--------------------
When starting some scopes, the newly allocated struct is
memset'ed with zero but this is unneeded since the allocator
always returns zeroed memory.

Remove the unneeded call to memset().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 scope.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/scope.c b/scope.c
index 420c0f5a3f51..0e4fb3b42150 100644
--- a/scope.c
+++ b/scope.c
@@ -68,7 +68,6 @@ void rebind_scope(struct symbol *sym, struct scope *new)
 static void start_scope(struct scope **s)
 {
 	struct scope *scope = __alloc_scope(0);
-	memset(scope, 0, sizeof(*scope));
 	scope->next = *s;
 	*s = scope;
 }
@@ -77,7 +76,6 @@ void start_file_scope(void)
 {
 	struct scope *scope = __alloc_scope(0);
 
-	memset(scope, 0, sizeof(*scope));
 	scope->next = &builtin_scope;
 	file_scope = scope;
 
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 1/2] add helper first_symbol() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] add helper first_symbol()
Date: Sun, 25 Oct 2020 13:09:20 +0000
Message-ID: <20201025130921.20693-2-luc.vanoostenryck () gmail ! com>
--------------------
This is just a wrapper around first_ptr_list().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.h | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/lib.h b/lib.h
index 0b1d4492e6bd..b4c3db93ab31 100644
--- a/lib.h
+++ b/lib.h
@@ -204,6 +204,11 @@ static inline pseudo_t first_pseudo(struct pseudo_list *head)
 	return first_ptr_list((struct ptr_list *)head);
 }
 
+static inline struct symbol *first_symbol(struct symbol_list *head)
+{
+	return first_ptr_list((struct ptr_list *)head);
+}
+
 static inline void concat_symbol_list(struct symbol_list *from, struct symbol_list **to)
 {
 	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH 1/2] add helper has_definition() ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] add helper has_definition()
Date: Mon, 28 Dec 2020 17:20:29 +0000
Message-ID: <0b310b49-2357-cc38-7e40-b215c6fe0773 () ramsayjones ! plus ! com>
--------------------


On 27/12/2020 09:27, Luc Van Oostenryck wrote:
> Add he helper has_definition() to check if the pseudo belong to one

s/Add he/Add the/

ATB,
Ramsay Jones

> of the pseudo types having a definition: PSEUDO_REG & PSEUDO_PHI.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  linearize.h | 5 +++++
>  1 file changed, 5 insertions(+)
> 
> diff --git a/linearize.h b/linearize.h
> index 2c548d43526f..c5bdd04257a1 100644
> --- a/linearize.h
> +++ b/linearize.h
> @@ -249,6 +249,11 @@ static inline int has_use_list(pseudo_t p)
>  	return (p && p->type != PSEUDO_VOID && p->type != PSEUDO_UNDEF && p->type != PSEUDO_VAL);
>  }
>  
> +static inline bool has_definition(pseudo_t p)
> +{
> +	return p->type == PSEUDO_REG || p->type == PSEUDO_PHI;
> +}
> +
>  static inline int pseudo_user_list_size(struct pseudo_user_list *list)
>  {
>  	return ptr_list_size((struct ptr_list *)list);
> 
================================================================================


################################################################################

=== Thread: [PATCH 1/2] dissect: set sym->kind for reporter ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] dissect: set sym->kind for reporter
Date: Mon, 10 Feb 2020 23:32:12 +0000
Message-ID: <20200210233212.xfsktwxhewxgtvr3 () ltop ! local>
--------------------
On Mon, Feb 10, 2020 at 05:20:18PM +0100, Oleg Nesterov wrote:
> Change dissect to report ctags-like kind passed in sym->kind.
> Currently only v,f,s and m kinds are possible.
> 
> SYM_UNION doesn't differ from SYM_STRUCT and has ->kind = 's'.
> 
> Signed-off-by: Oleg Nesterov <oleg@redhat.com>

Thanks.
Both patches applied and pushed.

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH 1/2] eval_insn: add testcases for incorrect type in OP_SET_* ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] eval_insn: add testcases for incorrect type in OP_SET_*
Date: Thu, 29 Oct 2020 22:59:04 +0000
Message-ID: <20201029225905.85037-2-luc.vanoostenryck () gmail ! com>
--------------------
Because of the lack of type information, compare instruction are
not always handled correctly. So, add some testcases for this.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/optim/cmp-op-type.c | 18 ++++++++++++++++++
 validation/optim/cmp-type0.c   | 13 +++++++++++++
 validation/optim/cmp-type1.c   | 16 ++++++++++++++++
 3 files changed, 47 insertions(+)
 create mode 100644 validation/optim/cmp-op-type.c
 create mode 100644 validation/optim/cmp-type0.c
 create mode 100644 validation/optim/cmp-type1.c

diff --git a/validation/optim/cmp-op-type.c b/validation/optim/cmp-op-type.c
new file mode 100644
index 000000000000..037272f84465
--- /dev/null
+++ b/validation/optim/cmp-op-type.c
@@ -0,0 +1,18 @@
+extern int get(void);
+
+static int array[8192];
+
+static int foo(void)
+{
+	int n = -1;
+	if (n < 0)
+		n = get();
+	return array[n];
+}
+
+/*
+ * check-name: cmp-op-type
+ * check-command: test-linearize -Wno-decl $file
+ *
+ * check-output-ignore
+ */
diff --git a/validation/optim/cmp-type0.c b/validation/optim/cmp-type0.c
new file mode 100644
index 000000000000..695d082b6aed
--- /dev/null
+++ b/validation/optim/cmp-type0.c
@@ -0,0 +1,13 @@
+static int foo(long long a)
+{
+	return 0LL < (0x80000000LL + (a - a));
+}
+
+/*
+ * check-name: cmp-type0
+ * check-command: test-linearize $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-contains: ret.*\\$1
+ */
diff --git a/validation/optim/cmp-type1.c b/validation/optim/cmp-type1.c
new file mode 100644
index 000000000000..2fb78a0bb86a
--- /dev/null
+++ b/validation/optim/cmp-type1.c
@@ -0,0 +1,16 @@
+int foo(void)
+{
+	int r;
+	long n;
+	n = 0;
+	return n < 2147483648U;
+}
+
+/*
+ * check-name: cmp-type1
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-contains: ret\\..*\\$1
+ */
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH 1/2] simplify unsigned compares against 0 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] simplify unsigned compares against 0
Date: Fri, 23 Oct 2020 15:58:31 +0000
Message-ID: <20201023155832.57237-2-luc.vanoostenryck () gmail ! com>
--------------------
Some unsigned compares against 0 are always true or always false
(x < 0 or x >= 0). Simplify them.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                   | 10 ++++++++++
 validation/optim/set-uimm0.c | 10 ++++++++++
 2 files changed, 20 insertions(+)
 create mode 100644 validation/optim/set-uimm0.c

diff --git a/simplify.c b/simplify.c
index 6caf6cbcf918..4441b27c7546 100644
--- a/simplify.c
+++ b/simplify.c
@@ -1173,6 +1173,16 @@ static int simplify_constant_rightside(struct instruction *insn)
 	case OP_SET_NE:
 	case OP_SET_EQ:
 		return simplify_seteq_setne(insn, value);
+	case OP_SET_B:
+		if (!value) {			// (x < 0) --> 0
+			return replace_with_pseudo(insn, value_pseudo(0));
+		}
+		break;
+	case OP_SET_AE:
+		if (!value) {			// (x >= 0) --> 1
+			return replace_with_pseudo(insn, value_pseudo(1));
+		}
+		break;
 	}
 	return 0;
 }
diff --git a/validation/optim/set-uimm0.c b/validation/optim/set-uimm0.c
new file mode 100644
index 000000000000..1f62358ff0fb
--- /dev/null
+++ b/validation/optim/set-uimm0.c
@@ -0,0 +1,10 @@
+static _Bool setlt0(unsigned int a) { return (a <   0u) == 0; }
+static _Bool setge0(unsigned int a) { return (a >=  0u) == 1; }
+
+/*
+ * check-name: set-uimm0
+ * check-command: test-linearize $file
+ *
+ * check-output-ignore
+ * check-output-pattern(2): ret\\.1 *\\$1
+ */
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 1/2] testsuite: add a new tag: check-output-match ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] testsuite: add a new tag: check-output-match
Date: Sat, 31 Oct 2020 20:50:37 +0000
Message-ID: <6cc4c620-0821-d3dc-6d46-803344a379bf () ramsayjones ! plus ! com>
--------------------


On 31/10/2020 20:04, Luc Van Oostenryck wrote:
> The current tags check-output-contains/excludes/pattern are
> quite powerful, universal, but they often need 'complex' regular
> expressions with escaping which make them not so nice to read.
> 
> For testing IR results, a very common pattern is:
> 	this instruction must have this (kind of) operand.
> 
> So, make a new tag for this. It does nothing than can't be done
> with done with the previous ones, on  the contrary, but is much
> simpler to use:
> 	check-output-match(instruction): operand
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  Documentation/test-suite.rst |  8 ++++++++
>  validation/test-suite        | 29 +++++++++++++++++++++++++++++
>  2 files changed, 37 insertions(+)
> 
> diff --git a/Documentation/test-suite.rst b/Documentation/test-suite.rst
> index 333106ee138a..4ff2db2f8777 100644
> --- a/Documentation/test-suite.rst
> +++ b/Documentation/test-suite.rst
> @@ -88,6 +88,14 @@ Tag's syntax
>  	of the number of times the pattern should occur in the output.
>  	If *min* or *max* is ``-`` the corresponding check is ignored.
>  
> +``check-output-match(``\ *start*\ ``):`` *pattern*
> +
> +	Check that in the output (stdout) all lines starting with the
> +	first pattern also contains the second pattern. This should be
> +	reserved for matching IR instructions since the '.$size' suffix
> +	is ignored in the first pattern but is expected to be followed
> +	by a space character.
> +
>  Using test-suite
>  ================
>  
> diff --git a/validation/test-suite b/validation/test-suite
> index f7d992dc7c8c..1f229439d699 100755
> --- a/validation/test-suite
> +++ b/validation/test-suite
> @@ -77,6 +77,7 @@ get_tag_value()
>  	check_output_contains=0
>  	check_output_excludes=0
>  	check_output_pattern=0
> +	check_output_match=0
>  	check_arch_ignore=""
>  	check_arch_only=""
>  	check_assert=""
> @@ -100,6 +101,7 @@ get_tag_value()
>  		check-output-contains:)	check_output_contains=1 ;;
>  		check-output-excludes:)	check_output_excludes=1 ;;
>  		check-output-pattern)	check_output_pattern=1 ;;
> +		check-output-match)	check_output_match=1 ;;
>  		check-arch-ignore:)	arch=$(uname -m)
>  					check_arch_ignore="$val" ;;
>  		check-arch-only:)	arch=$(uname -m)
> @@ -204,6 +206,26 @@ minmax_patterns()
>  	return $?
>  }
>  
> +##
> +match_patterns()
> +{
> +	ifile="$1"
> +	patt="$2"
> +	ofile="$3"
> +	grep "$patt" "$ifile" | sed -e "s/^.*$patt(\(.*\)): *\(.*\)$/\1 \2/" | \
> +	while read ins pat; do
> +		echo "ins: $ins"
> +		echo "pat: $pat"

Left-over debug?

ATB,
Ramsay Jones

> +		grep -s "^	$ins\\.*[0-9]* " "$ofile" | grep -v -s -q "$pat"
> +		if [ "$?" -ne 1 ]; then
> +			error "	IR doesn't match '$pat'"
> +			return 1
> +		fi
> +	done
> +
> +	return $?
> +}
> +
>  ##
>  # arg_file(filename) - checks if filename exists
>  arg_file()
> @@ -395,6 +417,13 @@ do_test()
>  			test_failed=1
>  		fi
>  	fi
> +	if [ $check_output_match -eq 1 ]; then
> +		# verify the 'check-output-match($insn): $patt' tags
> +		match_patterns "$file" 'check-output-match' $file.output.got
> +		if [ "$?" -ne "0" ]; then
> +			test_failed=1
> +		fi
> +	fi
>  
>  	if [ "$must_fail" -eq "1" ]; then
>  		if [ "$test_failed" -eq "1" ]; then
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] testsuite: add a new tag: check-output-match
Date: Sat, 31 Oct 2020 22:08:11 +0000
Message-ID: <20201031220811.ygdwj6pqq6h6t5j3 () ltop ! local>
--------------------
On Sat, Oct 31, 2020 at 08:50:37PM +0000, Ramsay Jones wrote:
> On 31/10/2020 20:04, Luc Van Oostenryck wrote:
> > +	grep "$patt" "$ifile" | sed -e "s/^.*$patt(\(.*\)): *\(.*\)$/\1 \2/" | \
> > +	while read ins pat; do
> > +		echo "ins: $ins"
> > +		echo "pat: $pat"
> 
> Left-over debug?

Grnn, yes. Thank you for noticing this!

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH 1/3] struct_union_enum_specifier: set MOD_TOPLEVEL if toplevel(sym->scope) ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 1/3] struct_union_enum_specifier: set MOD_TOPLEVEL if toplevel(sym->scope)
Date: Fri, 14 Feb 2020 11:33:20 +0000
Message-ID: <20200214113320.GA31578 () redhat ! com>
--------------------
With this change dissect can know the scope of SYM_STRUCT/UNION/ENUM,
see the next patch.

Note that MOD_TOPLEVEL can be set even if struct/union/enum type is
private and bind_symbol() is not called.

IIUC nobody else looks at SYM_STRUCT->ctype.modifiers, "make check"
doesn't show any difference.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 parse.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/parse.c b/parse.c
index a08165a..4492586 100644
--- a/parse.c
+++ b/parse.c
@@ -741,6 +741,8 @@ static struct token *struct_union_enum_specifier(enum type type,
 			// symbol being redefined.
 			sym = alloc_symbol(token->pos, type);
 			bind_symbol(sym, token->ident, NS_STRUCT);
+			if (toplevel(sym->scope))
+				sym->ctype.modifiers |= MOD_TOPLEVEL;
 		}
 		if (sym->type != type)
 			error_die(token->pos, "invalid tag applied to %s", show_typename (sym));
@@ -772,6 +774,8 @@ static struct token *struct_union_enum_specifier(enum type type,
 	}
 
 	sym = alloc_symbol(token->pos, type);
+	if (toplevel(block_scope))
+		sym->ctype.modifiers |= MOD_TOPLEVEL;
 	token = parse(token->next, sym);
 	ctx->ctype.base_type = sym;
 	token =  expect(token, '}', "at end of specifier");
-- 
2.5.0


================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] struct_union_enum_specifier: set MOD_TOPLEVEL if toplevel(sym->scope)
Date: Mon, 17 Feb 2020 21:46:10 +0000
Message-ID: <20200217214610.uxbnfh5zooqve4yc () ltop ! local>
--------------------
On Fri, Feb 14, 2020 at 12:33:20PM +0100, Oleg Nesterov wrote:
> With this change dissect can know the scope of SYM_STRUCT/UNION/ENUM,
> see the next patch.
> 
> Note that MOD_TOPLEVEL can be set even if struct/union/enum type is
> private and bind_symbol() is not called.

I don't like that very much. For example: why this is needed for
struct/union/enum and not other types?
Should it be possible to use the function toplevel() or add and
helper for it in scope.c?

> IIUC nobody else looks at SYM_STRUCT->ctype.modifiers, "make check"
> doesn't show any difference.

Yes, it's true and it shouldn't make any difference but still I
would prefer to not mix symbols and types more than they already are.
 
-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/3] struct_union_enum_specifier: set MOD_TOPLEVEL if toplevel(sym->scope)
Date: Tue, 18 Feb 2020 15:59:30 +0000
Message-ID: <20200218155930.ouldse3f47lna43z () ltop ! local>
--------------------
On Tue, Feb 18, 2020 at 11:38:38AM +0100, Oleg Nesterov wrote:
> On 02/17, Luc Van Oostenryck wrote:
> >
> > On Fri, Feb 14, 2020 at 12:33:20PM +0100, Oleg Nesterov wrote:
> > > With this change dissect can know the scope of SYM_STRUCT/UNION/ENUM,
> > > see the next patch.
> > >
> > > Note that MOD_TOPLEVEL can be set even if struct/union/enum type is
> > > private and bind_symbol() is not called.
> >
> > I don't like that very much. For example: why this is needed for
> > struct/union/enum and not other types?
> 
> Do you mean builtin types like int_ctype? OK, I agree, this is slightly
> inconsistent.

I was thinking of the other constructed types: arrays & pointers.
 
> > Should it be possible to use the function toplevel() or add and
> > helper for it in scope.c?
> 
> Well, toplevel() won't work if SYM_STRUCT/etc is anonymous, in this
> case bind_symbol() is not called and thus sym->scope = NULL.
> 
> Consider
> 
> 	struct { int m; } x;
> 
> 	void func(void)
> 	{
> 		struct { int m; } x;
> 
> 	}
> 
> we want to report the 2nd struct definition as "local"
> 
>    1:8                    def   s :x
>    1:14                   def   m :x.m                             int
>    1:19                   def   v x                                struct :x
>    3:6                    def   f func                             void ( ... )
>    5:16  func             def . s :x
>    5:22  func             def . m :x.m                             int
>    5:27  func             def . v x                                struct :x
> 
> so that this spam can be filtered out, but base->scope is NULL in both
> cases.

OK, I see.
 
> > > IIUC nobody else looks at SYM_STRUCT->ctype.modifiers, "make check"
> > > doesn't show any difference.
> >
> > Yes, it's true and it shouldn't make any difference but still I
> > would prefer to not mix symbols and types more than they already are.
> 
> OK, will you agree with one-liner below? This should make toplevel() work.

This will still be inconsistent with the other types but I can live
with this. If you could just add a comment explaining why it is needed
and using an helper instead of directly using 'block_scope' (like
set_[current_]scope() or something).

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH 1/5] add testcases for OP_UNREACH ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/5] add testcases for OP_UNREACH
Date: Wed, 18 Mar 2020 17:31:16 +0000
Message-ID: <20200318173120.63939-2-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/context-unreachable.c              | 16 ++++++++++
 validation/linear/builtin_unreachable0.c      | 30 +++++++++++++++++++
 ...n_unreachable.c => builtin_unreachable1.c} | 14 ++++-----
 validation/linear/noreturn-unreachable0.c     | 23 ++++++++++++++
 4 files changed, 76 insertions(+), 7 deletions(-)
 create mode 100644 validation/context-unreachable.c
 create mode 100644 validation/linear/builtin_unreachable0.c
 rename validation/linear/{builtin_unreachable.c => builtin_unreachable1.c} (65%)
 create mode 100644 validation/linear/noreturn-unreachable0.c

diff --git a/validation/context-unreachable.c b/validation/context-unreachable.c
new file mode 100644
index 000000000000..3e330403ce01
--- /dev/null
+++ b/validation/context-unreachable.c
@@ -0,0 +1,16 @@
+int fun(void);
+
+static void foo(void)
+{
+	__context__(1);
+	if (!fun()) {
+		__builtin_unreachable();
+		return;
+	}
+	__context__(-1);
+}
+
+/*
+ * check-name: context-unreachable
+ * check-known-to-fail
+ */
diff --git a/validation/linear/builtin_unreachable0.c b/validation/linear/builtin_unreachable0.c
new file mode 100644
index 000000000000..5da9d074ae5f
--- /dev/null
+++ b/validation/linear/builtin_unreachable0.c
@@ -0,0 +1,30 @@
+extern void die(void) __attribute__((noreturn));
+
+int foo(int p)
+{
+	if (p == 3)
+		__builtin_unreachable();
+	return p;
+}
+
+/*
+ * check-name: builtin_unreachable0
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-start
+foo:
+.L0:
+	<entry-point>
+	seteq.32    %r2 <- %arg1, $3
+	cbr         %r2, .L1, .L3
+
+.L1:
+	unreach
+
+.L3:
+	ret.32      %arg1
+
+
+ * check-output-end
+ */
diff --git a/validation/linear/builtin_unreachable.c b/validation/linear/builtin_unreachable1.c
similarity index 65%
rename from validation/linear/builtin_unreachable.c
rename to validation/linear/builtin_unreachable1.c
index 4f13b892af54..280f853d8a07 100644
--- a/validation/linear/builtin_unreachable.c
+++ b/validation/linear/builtin_unreachable1.c
@@ -1,15 +1,15 @@
-void function_that_never_returns(void);
+extern void die(void);
 
 int foo(int c)
 {
 	if (c)
 		return 1;
-	function_that_never_returns();
+	die();
 	__builtin_unreachable();
 }
 
 /*
- * check-name: __builtin_unreachable()
+ * check-name: builtin_unreachable1
  * check-command: test-linearize -Wno-decl $file
  *
  * check-known-to-fail
@@ -19,13 +19,13 @@ foo:
 	<entry-point>
 	cbr         %arg1, .L3, .L2
 
-.L2:
-	call        function_that_never_returns
-	unreach
-
 .L3:
 	ret.32      $1
 
+.L2:
+	call        die
+	unreach
+
 
  * check-output-end
  */
diff --git a/validation/linear/noreturn-unreachable0.c b/validation/linear/noreturn-unreachable0.c
new file mode 100644
index 000000000000..b76319458e96
--- /dev/null
+++ b/validation/linear/noreturn-unreachable0.c
@@ -0,0 +1,23 @@
+extern void die(void) __attribute__((noreturn));
+
+int foo(void)
+{
+	die();
+	return 0;
+}
+
+/*
+ * check-name: noreturn-unreachable0
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-start
+foo:
+.L0:
+	<entry-point>
+	call        die
+	unreach
+
+
+ * check-output-end
+ */
-- 
2.25.1

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 1/5] add testcases for OP_UNREACH
Date: Thu, 19 Mar 2020 22:24:28 +0000
Message-ID: <48b264ee-c07f-9545-ba92-04934aca9752 () ramsayjones ! plus ! com>
--------------------


On 18/03/2020 17:31, Luc Van Oostenryck wrote:
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  validation/context-unreachable.c              | 16 ++++++++++
>  validation/linear/builtin_unreachable0.c      | 30 +++++++++++++++++++
>  ...n_unreachable.c => builtin_unreachable1.c} | 14 ++++-----
>  validation/linear/noreturn-unreachable0.c     | 23 ++++++++++++++
>  4 files changed, 76 insertions(+), 7 deletions(-)
>  create mode 100644 validation/context-unreachable.c
>  create mode 100644 validation/linear/builtin_unreachable0.c
>  rename validation/linear/{builtin_unreachable.c => builtin_unreachable1.c} (65%)
>  create mode 100644 validation/linear/noreturn-unreachable0.c
> 
> diff --git a/validation/context-unreachable.c b/validation/context-unreachable.c
> new file mode 100644
> index 000000000000..3e330403ce01
> --- /dev/null
> +++ b/validation/context-unreachable.c
> @@ -0,0 +1,16 @@
> +int fun(void);
> +
> +static void foo(void)
> +{
> +	__context__(1);
> +	if (!fun()) {
> +		__builtin_unreachable();
> +		return;
> +	}
> +	__context__(-1);
> +}
> +
> +/*
> + * check-name: context-unreachable
> + * check-known-to-fail
> + */
> diff --git a/validation/linear/builtin_unreachable0.c b/validation/linear/builtin_unreachable0.c
> new file mode 100644
> index 000000000000..5da9d074ae5f
> --- /dev/null
> +++ b/validation/linear/builtin_unreachable0.c
> @@ -0,0 +1,30 @@
> +extern void die(void) __attribute__((noreturn));

Hmm, is this declaration intended?

ATB,
Ramsay Jones

> +
> +int foo(int p)
> +{
> +	if (p == 3)
> +		__builtin_unreachable();
> +	return p;
> +}
> +
> +/*
> + * check-name: builtin_unreachable0
> + * check-command: test-linearize -Wno-decl $file
> + * check-known-to-fail
> + *
> + * check-output-start
> +foo:
> +.L0:
> +	<entry-point>
> +	seteq.32    %r2 <- %arg1, $3
> +	cbr         %r2, .L1, .L3
> +
> +.L1:
> +	unreach
> +
> +.L3:
> +	ret.32      %arg1
> +
> +
> + * check-output-end
> + */
> diff --git a/validation/linear/builtin_unreachable.c b/validation/linear/builtin_unreachable1.c
> similarity index 65%
> rename from validation/linear/builtin_unreachable.c
> rename to validation/linear/builtin_unreachable1.c
> index 4f13b892af54..280f853d8a07 100644
> --- a/validation/linear/builtin_unreachable.c
> +++ b/validation/linear/builtin_unreachable1.c
> @@ -1,15 +1,15 @@
> -void function_that_never_returns(void);
> +extern void die(void);
>  
>  int foo(int c)
>  {
>  	if (c)
>  		return 1;
> -	function_that_never_returns();
> +	die();
>  	__builtin_unreachable();
>  }
>  
>  /*
> - * check-name: __builtin_unreachable()
> + * check-name: builtin_unreachable1
>   * check-command: test-linearize -Wno-decl $file
>   *
>   * check-known-to-fail
> @@ -19,13 +19,13 @@ foo:
>  	<entry-point>
>  	cbr         %arg1, .L3, .L2
>  
> -.L2:
> -	call        function_that_never_returns
> -	unreach
> -
>  .L3:
>  	ret.32      $1
>  
> +.L2:
> +	call        die
> +	unreach
> +
>  
>   * check-output-end
>   */
> diff --git a/validation/linear/noreturn-unreachable0.c b/validation/linear/noreturn-unreachable0.c
> new file mode 100644
> index 000000000000..b76319458e96
> --- /dev/null
> +++ b/validation/linear/noreturn-unreachable0.c
> @@ -0,0 +1,23 @@
> +extern void die(void) __attribute__((noreturn));
> +
> +int foo(void)
> +{
> +	die();
> +	return 0;
> +}
> +
> +/*
> + * check-name: noreturn-unreachable0
> + * check-command: test-linearize -Wno-decl $file
> + * check-known-to-fail
> + *
> + * check-output-start
> +foo:
> +.L0:
> +	<entry-point>
> +	call        die
> +	unreach
> +
> +
> + * check-output-end
> + */
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/5] add testcases for OP_UNREACH
Date: Thu, 19 Mar 2020 23:54:48 +0000
Message-ID: <20200319235448.j4l72vgoo6sl64tn () ltop ! local>
--------------------
On Thu, Mar 19, 2020 at 10:24:28PM +0000, Ramsay Jones wrote:
> On 18/03/2020 17:31, Luc Van Oostenryck wrote:
> > diff --git a/validation/linear/builtin_unreachable0.c b/validation/linear/builtin_unreachable0.c
> > new file mode 100644
> > index 000000000000..5da9d074ae5f
> > --- /dev/null
> > +++ b/validation/linear/builtin_unreachable0.c
> > @@ -0,0 +1,30 @@
> > +extern void die(void) __attribute__((noreturn));
> 
> Hmm, is this declaration intended?

Only before it was cut-and-pasted ;)
Thanks for noticing.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH 1/5] gensel: add testcases from DR481 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/5] gensel: add testcases from DR481
Date: Fri, 19 Jun 2020 15:02:56 +0000
Message-ID: <20200619150300.63695-2-luc.vanoostenryck () gmail ! com>
--------------------
Following the resolution of DR481, the controlling expression
is subject to a few different rules.

Add the testcases from this defect report.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/generic-dr481.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)
 create mode 100644 validation/generic-dr481.c

diff --git a/validation/generic-dr481.c b/validation/generic-dr481.c
new file mode 100644
index 000000000000..2ed15c9bc6d3
--- /dev/null
+++ b/validation/generic-dr481.c
@@ -0,0 +1,17 @@
+static char const* a = _Generic("bla", char*: "blu");
+static char const* b = _Generic("bla", char[4]: "blu");
+static char const* c = _Generic((int const){ 0 }, int: "blu");
+static char const* d = _Generic((int const){ 0 }, int const: "blu");
+static char const* e = _Generic(+(int const){ 0 }, int: "blu");
+static char const* f = _Generic(+(int const){ 0 }, int const: "blu");
+
+/*
+ * check-name: generic-dr481
+ * check-known-to-fail
+ *
+ * check-error-start
+generic-dr481.c:2:32: error: no generic selection for 'char *'
+generic-dr481.c:4:32: error: no generic selection for 'int const [toplevel]'
+generic-dr481.c:6:32: error: no generic selection for 'int'
+ * check-error-end
+ */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 1/5] pre-process: add testcases for __has_feature() & __has_extension() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/5] pre-process: add testcases for __has_feature() & __has_extension()
Date: Thu, 18 Jun 2020 20:47:12 +0000
Message-ID: <20200618204716.3896-2-luc.vanoostenryck () gmail ! com>
--------------------
The support for these builtin macros is incoming.
So, add some testcases for them.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/preprocessor/has-feature.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)
 create mode 100644 validation/preprocessor/has-feature.c

diff --git a/validation/preprocessor/has-feature.c b/validation/preprocessor/has-feature.c
new file mode 100644
index 000000000000..3ab7c3e039fa
--- /dev/null
+++ b/validation/preprocessor/has-feature.c
@@ -0,0 +1,21 @@
+#ifndef __has_feature
+__has_feature()??? Quesako?
+#define __has_feature(x) 0
+#else
+"has __has_feature(), yeah!"
+#endif
+
+#if __has_feature(not_a_feature)
+#error "not a feature!"
+#endif
+
+/*
+ * check-name: has-feature
+ * check-command: sparse -E $file
+ * check-known-to-fail
+ *
+ * check-output-start
+
+"has __has_feature(), yeah!"
+ * check-output-end
+ */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 1/6] add testcase for comma in array declarator ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/6] add testcase for comma in array declarator
Date: Thu, 23 Jul 2020 23:46:36 +0000
Message-ID: <20200723234641.78462-2-luc.vanoostenryck () gmail ! com>
--------------------
Comma expressions are not allowed for the size in an array
declarator. Add a testcase for this.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/abstract-array-declarator.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)
 create mode 100644 validation/abstract-array-declarator.c

diff --git a/validation/abstract-array-declarator.c b/validation/abstract-array-declarator.c
new file mode 100644
index 000000000000..f230e5862ae9
--- /dev/null
+++ b/validation/abstract-array-declarator.c
@@ -0,0 +1,12 @@
+void f77(int a[1, 2]);
+void c99(int a[(1, 2)]);
+
+/*
+ * check-name: abstract-array-declarator
+ * check-known-to-fail
+ *
+ * check-error-start
+abstract-array-declarator.c:1:17: error: Expected ] in abstract_array_declarator
+abstract-array-declarator.c:1:17: error: got ,
+ * check-error-end
+ */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 10/10] keyword type is a bitmask and must be tested so ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 10/10] keyword type is a bitmask and must be tested so
Date: Sun, 09 Aug 2020 20:53:29 +0000
Message-ID: <20200809205329.42811-11-luc.vanoostenryck () gmail ! com>
--------------------
The keyword's type is a bitmask because depending on the context
the same keyword can be of different type (for example 'const'
as qualifier and the attribute 'const' , a variant of 'pure').

Thus, it's an error to test this type for equality, instead it's
a specific (set of) bit(s) that must be tested.

So, change a test ' x == KW_...' into 'x & KW_...'.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/parse.c b/parse.c
index d378f1255fee..e1a5cce4e46b 100644
--- a/parse.c
+++ b/parse.c
@@ -1287,7 +1287,7 @@ static struct token *attribute_mode(struct token *token, struct symbol *attr, st
 	token = expect(token, '(', "after mode attribute");
 	if (token_type(token) == TOKEN_IDENT) {
 		struct symbol *mode = lookup_keyword(token->ident, NS_KEYWORD);
-		if (mode && mode->op->type == KW_MODE)
+		if (mode && mode->op->type & KW_MODE)
 			ctx->mode = mode->op;
 		else
 			sparse_error(token->pos, "unknown mode attribute %s", show_ident(token->ident));
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 11/13] flex-array: warn an arrays containing a flexible array ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 11/13] flex-array: warn an arrays containing a flexible array
Date: Wed, 30 Sep 2020 23:18:26 +0000
Message-ID: <20200930231828.66751-12-luc.vanoostenryck () gmail ! com>
--------------------
An array of some aggregate type containing, possibly recursively,
a flexible array is pretty non-sensical. So, add an option
-Wflexible-array-array to warn on such usage.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 options.c                     | 2 ++
 options.h                     | 1 +
 sparse.1                      | 7 +++++++
 symbol.c                      | 2 ++
 validation/flex-array-array.c | 1 -
 5 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/options.c b/options.c
index ce88fbf6ed61..a8129ac1e952 100644
--- a/options.c
+++ b/options.c
@@ -100,6 +100,7 @@ int Wdesignated_init = 1;
 int Wdo_while = 0;
 int Wenum_mismatch = 1;
 int Wexternal_function_has_definition = 1;
+int Wflexible_array_array = 1;
 int Wflexible_array_sizeof = 0;
 int Wimplicit_int = 1;
 int Winit_cstring = 0;
@@ -841,6 +842,7 @@ static const struct flag warnings[] = {
 	{ "do-while", &Wdo_while },
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "external-function-has-definition", &Wexternal_function_has_definition },
+	{ "flexible-array-array", &Wflexible_array_array },
 	{ "flexible-array-sizeof", &Wflexible_array_sizeof },
 	{ "implicit-int", &Wimplicit_int },
 	{ "init-cstring", &Winit_cstring },
diff --git a/options.h b/options.h
index feb351a36c9e..7bcf925b6912 100644
--- a/options.h
+++ b/options.h
@@ -99,6 +99,7 @@ extern int Wdesignated_init;
 extern int Wdo_while;
 extern int Wenum_mismatch;
 extern int Wexternal_function_has_definition;
+extern int Wflexible_array_array;
 extern int Wflexible_array_sizeof;
 extern int Wimplicit_int;
 extern int Winit_cstring;
diff --git a/sparse.1 b/sparse.1
index 5f98df33a231..c1a74153c618 100644
--- a/sparse.1
+++ b/sparse.1
@@ -257,6 +257,13 @@ Sparse issues these warnings by default.  To turn them off, use
 \fB\-Wno\-external\-function\-has\-definition\fR.
 .
 .TP
+.B -Wflexible-array-array
+Warn about arrays of structures containing a flexible array.
+
+Sparse issues these warnings by default. To turn them off, use
+\fB-Wno-flexible-array-array\fR.
+.
+.TP
 .B -Wflexible-array-sizeof
 Warn about using the sizeof operator on a structure containing a flexible array,
 possibly recursively.
diff --git a/symbol.c b/symbol.c
index bffdc135ba69..02b9066e966a 100644
--- a/symbol.c
+++ b/symbol.c
@@ -267,6 +267,8 @@ static struct symbol * examine_array_type(struct symbol *sym)
 			bit_size = -1;
 		}
 	}
+	if (has_flexible_array(base_type) && Wflexible_array_array)
+		warning(sym->pos, "array of flexible structures");
 	alignment = base_type->ctype.alignment;
 	if (!sym->ctype.alignment)
 		sym->ctype.alignment = alignment;
diff --git a/validation/flex-array-array.c b/validation/flex-array-array.c
index bda80d7a0a20..921a0698bb28 100644
--- a/validation/flex-array-array.c
+++ b/validation/flex-array-array.c
@@ -8,7 +8,6 @@ static struct s a[2];
 /*
  * check-name: flex-array-array
  * check-command: sparse -Wflexible-array-array $file
- * check-known-to-fail
  *
  * check-error-start
 flex-array-array.c:6:18: warning: array of flexible structures
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 11/17] scope: make function scope the same as the body block scope ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 11/17] scope: make function scope the same as the body block scope
Date: Mon, 13 Apr 2020 16:15:59 +0000
Message-ID: <20200413161605.95900-12-luc.vanoostenryck () gmail ! com>
--------------------
Currently, the function scope (only used for labels) and
the block scope of the function's body are distinct scopes,
none being a child from the other.

This is fine as these scopes are currently unrelated but:
* it's unneeded and somehow unintuitive
* checking that gotos doesn't jump inside and expression
  statement is easier if these scopes are properly nested.

So, make the function scope and the body's block scope one
single scope.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 scope.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/scope.c b/scope.c
index 0e4fb3b42150..175d72c23762 100644
--- a/scope.c
+++ b/scope.c
@@ -91,8 +91,8 @@ void start_symbol_scope(void)
 
 void start_function_scope(void)
 {
-	start_scope(&function_scope);
 	start_scope(&block_scope);
+	function_scope = block_scope;
 }
 
 static void remove_symbol_scope(struct symbol *sym)
@@ -137,7 +137,7 @@ void end_symbol_scope(void)
 void end_function_scope(void)
 {
 	end_scope(&block_scope);
-	end_scope(&function_scope);
+	function_scope = block_scope;
 }
 
 int is_outer_scope(struct scope *scope)
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 12/17] scope: s/{start,end}_symbol_scope/{start,end}_block_scope/ ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 12/17] scope: s/{start,end}_symbol_scope/{start,end}_block_scope/
Date: Mon, 13 Apr 2020 16:16:00 +0000
Message-ID: <20200413161605.95900-13-luc.vanoostenryck () gmail ! com>
--------------------
The names {start,end}_symbol_scope() are misleading as these
function really start & end a block scope and not all symbols
are declared inside a block scope.

So, rename them to their more direct name: {start,end}_block_scope().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 12 ++++++------
 scope.c |  4 ++--
 scope.h |  4 ++--
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/parse.c b/parse.c
index 5da314cd05ee..1a2c7af22ff4 100644
--- a/parse.c
+++ b/parse.c
@@ -2222,7 +2222,7 @@ static void start_iterator(struct statement *stmt)
 {
 	struct symbol *cont, *brk;
 
-	start_symbol_scope();
+	start_block_scope();
 	cont = alloc_symbol(stmt->pos, SYM_NODE);
 	bind_symbol(cont, &continue_ident, NS_ITERATOR);
 	brk = alloc_symbol(stmt->pos, SYM_NODE);
@@ -2237,7 +2237,7 @@ static void start_iterator(struct statement *stmt)
 
 static void end_iterator(struct statement *stmt)
 {
-	end_symbol_scope();
+	end_block_scope();
 }
 
 static struct statement *start_function(struct symbol *sym)
@@ -2282,7 +2282,7 @@ static void start_switch(struct statement *stmt)
 {
 	struct symbol *brk, *switch_case;
 
-	start_symbol_scope();
+	start_block_scope();
 	brk = alloc_symbol(stmt->pos, SYM_NODE);
 	bind_symbol(brk, &break_ident, NS_ITERATOR);
 
@@ -2302,7 +2302,7 @@ static void end_switch(struct statement *stmt)
 {
 	if (!stmt->switch_case->symbol_list)
 		warning(stmt->pos, "switch with no cases");
-	end_symbol_scope();
+	end_block_scope();
 }
 
 static void add_case_statement(struct statement *stmt)
@@ -2655,9 +2655,9 @@ static struct token *parameter_type_list(struct token *token, struct symbol *fn)
 struct token *compound_statement(struct token *token, struct statement *stmt)
 {
 	stmt->type = STMT_COMPOUND;
-	start_symbol_scope();
+	start_block_scope();
 	token = statement_list(token, &stmt->stmts);
-	end_symbol_scope();
+	end_block_scope();
 	return token;
 }
 
diff --git a/scope.c b/scope.c
index 175d72c23762..be042a45357d 100644
--- a/scope.c
+++ b/scope.c
@@ -84,7 +84,7 @@ void start_file_scope(void)
 	block_scope = scope;
 }
 
-void start_symbol_scope(void)
+void start_block_scope(void)
 {
 	start_scope(&block_scope);
 }
@@ -129,7 +129,7 @@ void new_file_scope(void)
 	start_file_scope();
 }
 
-void end_symbol_scope(void)
+void end_block_scope(void)
 {
 	end_scope(&block_scope);
 }
diff --git a/scope.h b/scope.h
index 3cad514ac128..83741459eb6a 100644
--- a/scope.h
+++ b/scope.h
@@ -47,8 +47,8 @@ extern void start_file_scope(void);
 extern void end_file_scope(void);
 extern void new_file_scope(void);
 
-extern void start_symbol_scope(void);
-extern void end_symbol_scope(void);
+extern void start_block_scope(void);
+extern void end_block_scope(void);
 
 extern void start_function_scope(void);
 extern void end_function_scope(void);
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 13/13] flex-array: warn when a flexible array member has some padding ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 13/13] flex-array: warn when a flexible array member has some padding
Date: Wed, 30 Sep 2020 23:18:28 +0000
Message-ID: <20200930231828.66751-14-luc.vanoostenryck () gmail ! com>
--------------------
If some padding is added because of the presence of a flexible
array member, the size of the structure will be greater than
the offset of this flexible array which can cause some
problems if the assumption is made that these 2 size must be
identical (which is easy to do since such flexible arrays are
conceptually 'after' the structure itself).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 options.c                       | 2 ++
 options.h                       | 1 +
 sparse.1                        | 6 ++++++
 symbol.c                        | 2 ++
 validation/flex-array-padding.c | 1 -
 5 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/options.c b/options.c
index b46900b973a6..92d64e6ab64e 100644
--- a/options.c
+++ b/options.c
@@ -102,6 +102,7 @@ int Wenum_mismatch = 1;
 int Wexternal_function_has_definition = 1;
 int Wflexible_array_array = 1;
 int Wflexible_array_nested = 0;
+int Wflexible_array_padding = 0;
 int Wflexible_array_sizeof = 0;
 int Wimplicit_int = 1;
 int Winit_cstring = 0;
@@ -845,6 +846,7 @@ static const struct flag warnings[] = {
 	{ "external-function-has-definition", &Wexternal_function_has_definition },
 	{ "flexible-array-array", &Wflexible_array_array },
 	{ "flexible-array-nested", &Wflexible_array_nested },
+	{ "flexible-array-padding", &Wflexible_array_padding },
 	{ "flexible-array-sizeof", &Wflexible_array_sizeof },
 	{ "implicit-int", &Wimplicit_int },
 	{ "init-cstring", &Winit_cstring },
diff --git a/options.h b/options.h
index d23ed472eaac..31d9c5859977 100644
--- a/options.h
+++ b/options.h
@@ -101,6 +101,7 @@ extern int Wenum_mismatch;
 extern int Wexternal_function_has_definition;
 extern int Wflexible_array_array;
 extern int Wflexible_array_nested;
+extern int Wflexible_array_padding;
 extern int Wflexible_array_sizeof;
 extern int Wimplicit_int;
 extern int Winit_cstring;
diff --git a/sparse.1 b/sparse.1
index 9b1a59c6b9d4..8c61e869dc57 100644
--- a/sparse.1
+++ b/sparse.1
@@ -268,6 +268,12 @@ Sparse issues these warnings by default. To turn them off, use
 Warn about structures containing a flexible array being contained into
 another structure, union or array.
 
+Sparse does not issue these warnings by default.
+.
+.TP
+.B -Wflexible-array-padding
+Warn about padding alignments caused by the presence of a flexible array member.
+
 Sparse does not issue these warnings by default.
 .
 .TP
diff --git a/symbol.c b/symbol.c
index a9f646eb053f..eabb2226651f 100644
--- a/symbol.c
+++ b/symbol.c
@@ -213,6 +213,8 @@ static struct symbol * examine_struct_union_type(struct symbol *sym, int advance
 	}
 	if (info.flex_array) {
 		info.has_flex_array = 1;
+		if (sym->offset != bits_to_bytes(bit_size) && Wflexible_array_padding)
+			warning(info.flex_array->pos, "flexible array member has padding");
 	}
 	if (info.has_flex_array)
 		sym->has_flex_array = 1;
diff --git a/validation/flex-array-padding.c b/validation/flex-array-padding.c
index 2ba77971266e..95b349e1199a 100644
--- a/validation/flex-array-padding.c
+++ b/validation/flex-array-padding.c
@@ -12,7 +12,6 @@ static int foo(struct s *s)
 /*
  * check-name: flex-array-padding
  * check-command: test-linearize -Wflexible-array-padding $file
- * check-known-to-fail
  *
  * check-output-ignore
  *
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 13/17] scope: let labels have their own scope ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 13/17] scope: let labels have their own scope
Date: Mon, 13 Apr 2020 17:30:49 +0000
Message-ID: <CAHk-=wiLAGGb=RLUQvAggvqf5tbAp1nUPyKUrimwy2BRAso69A () mail ! gmail ! com>
--------------------
On Mon, Apr 13, 2020 at 9:16 AM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> One way of detecting gotos inside an statement expression
> is to use a new kind of scope for the gotos & labels.

Ack. This is a much better approach than trying to figure things out later.

Very nice.

               Linus
================================================================================


################################################################################

=== Thread: [PATCH 14/17] scope: add is_in_scope() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 14/17] scope: add is_in_scope()
Date: Mon, 13 Apr 2020 16:16:02 +0000
Message-ID: <20200413161605.95900-15-luc.vanoostenryck () gmail ! com>
--------------------
Add an helper to check if a scope is included into
another one.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 scope.c | 9 +++++++++
 scope.h | 2 ++
 2 files changed, 11 insertions(+)

diff --git a/scope.c b/scope.c
index 24c8a7a484f7..b5c9e454b55d 100644
--- a/scope.c
+++ b/scope.c
@@ -163,3 +163,12 @@ int is_outer_scope(struct scope *scope)
 	return 1;
 }
 
+int is_in_scope(struct scope *outer, struct scope *inner)
+{
+	while (inner != outer) {
+		if (inner == &builtin_scope)
+			return 0;
+		inner = inner->next;
+	}
+	return 1;
+}
diff --git a/scope.h b/scope.h
index ddcb90bd146b..36a56d6adf1d 100644
--- a/scope.h
+++ b/scope.h
@@ -62,4 +62,6 @@ extern void bind_scope(struct symbol *, struct scope *);
 extern void rebind_scope(struct symbol *, struct scope *);
 
 extern int is_outer_scope(struct scope *);
+extern int is_in_scope(struct scope *outer, struct scope *inner);
+
 #endif
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 15/17] scope: give a scope for labels & gotos ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Mon, 13 Apr 2020 16:16:03 +0000
Message-ID: <20200413161605.95900-16-luc.vanoostenryck () gmail ! com>
--------------------
One way of detecting gotos inside an statement expression
is to use a new kind of scope for the gotos & labels.
Since gotos don't need to have their label predeclared,
nothing can be checked at parsing time but later it can
be checked that a goto doesn't jump inside one of the
label scope created by statement expressions.

So, add additional scope information to gotos and labels
to allow such check to be done.

Note: the label's symbols are still created in the function
      scope since they belong to a single namespace.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c  | 2 ++
 parse.h  | 1 +
 symbol.h | 3 +++
 3 files changed, 6 insertions(+)

diff --git a/parse.c b/parse.c
index 1a2c7af22ff4..244991c1c4f5 100644
--- a/parse.c
+++ b/parse.c
@@ -2481,6 +2481,7 @@ static struct token *parse_goto_statement(struct token *token, struct statement
 		add_statement(&function_computed_goto_list, stmt);
 	} else if (token_type(token) == TOKEN_IDENT) {
 		stmt->goto_label = label_symbol(token);
+		stmt->goto_scope = label_scope;
 		token = token->next;
 	} else {
 		sparse_error(token->pos, "Expected identifier or goto expression");
@@ -2533,6 +2534,7 @@ static struct token *statement(struct token *token, struct statement **tree)
 
 		if (match_op(token->next, ':')) {
 			struct symbol *s = label_symbol(token);
+			s->label_scope = label_scope;
 			token = skip_attributes(token->next->next);
 			if (s->stmt) {
 				sparse_error(stmt->pos, "label '%s' redefined", show_ident(s->ident));
diff --git a/parse.h b/parse.h
index 0742a2a87e9d..5995eb56849f 100644
--- a/parse.h
+++ b/parse.h
@@ -99,6 +99,7 @@ struct statement {
 		};
 		struct /* goto_struct */ {
 			struct symbol *goto_label;
+			struct scope *goto_scope;
 
 			/* computed gotos have these: */
 			struct expression *goto_expression;
diff --git a/symbol.h b/symbol.h
index de13d60b8b75..f9d7bcaa997f 100644
--- a/symbol.h
+++ b/symbol.h
@@ -167,6 +167,9 @@ struct symbol {
 			int (*handler)(struct stream *, struct token **, struct token *);
 			int normal;
 		};
+		struct /* NS_LABEL */ {
+			struct scope *label_scope;
+		};
 		struct /* NS_SYMBOL */ {
 			unsigned long	offset;
 			int		bit_size;
-- 
2.26.0

================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Mon, 13 Apr 2020 17:52:19 +0000
Message-ID: <CAHk-=wiy-BFXMpmm9-GNT_WtDKVLeR0ki4OTj83xPk=npuNSHA () mail ! gmail ! com>
--------------------
On Mon, Apr 13, 2020 at 9:16 AM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Note: the label's symbols are still created in the function
>       scope since they belong to a single namespace.

Oh, I saw that 13/17 and was like "yeah, this is the right thing to
do", because I thought you were going in a different direction.

But then here in 15/17 I think you're doing it wrong.

Just give the symbol the proper scope, and make it simply not even
_parse_ right if somebody tries to use a label from the wrong scope,
instead of making the symbol visible, and then having to check whether
the scopes nested right later.

So I think you should just bite the bullet, and change the
bind_symbol() function so that a NS_LABEL is bound to label scope.

Then you can remove this 15/17 entirely (and all the "is this scope
nesting" code - nesting is automatically enforced by the symbol
scope).

I think that's a much cleaner approach. Yes, it gives a different
error from gcc, but I think it's a *better* error.

This:

   int fn1(int arg)
   {
      target:
         return 0;
   }

   int fn2(int arg)
   {
      goto target;
   }

is invalid code, and 'target' isn't even visible in fn2, because it is
a local label to fn1.

I think the exact same thing is the right thing to do for expression
statements, so

   int fn(int arg)
   {
      goto inside;
      return ({ inside: 0; });
   }

should fail with the exact same error message of having an undefined
label (which sparse currently gets wrong too, but you're fixing that
elsewhere).

Because "inside" simply shouldn't be defined at all in the outer
scope, and you can only branch _within_ a statement expression, the
same way you can only branch within a function.

So I think statement expressions should basically work kind of like
local "nested functions": they have access to the state outside, but
the outside doesn't have access to the state inside that statement
expression.

           Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Mon, 13 Apr 2020 18:54:52 +0000
Message-ID: <20200413185452.pgj75pj5g7a42kik () ltop ! local>
--------------------
On Mon, Apr 13, 2020 at 10:52:19AM -0700, Linus Torvalds wrote:
> On Mon, Apr 13, 2020 at 9:16 AM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > Note: the label's symbols are still created in the function
> >       scope since they belong to a single namespace.
> 
> Oh, I saw that 13/17 and was like "yeah, this is the right thing to
> do", because I thought you were going in a different direction.
> 
> But then here in 15/17 I think you're doing it wrong.
> 
> Just give the symbol the proper scope, and make it simply not even
> _parse_ right if somebody tries to use a label from the wrong scope,
> instead of making the symbol visible, and then having to check whether
> the scopes nested right later.
> 
> So I think you should just bite the bullet, and change the
> bind_symbol() function so that a NS_LABEL is bound to label scope.
> 
> Then you can remove this 15/17 entirely (and all the "is this scope
> nesting" code - nesting is automatically enforced by the symbol
> scope).
> 
> I think that's a much cleaner approach. Yes, it gives a different
> error from gcc, but I think it's a *better* error.
> 
> This:
> 
>    int fn1(int arg)
>    {
>       target:
>          return 0;
>    }
> 
>    int fn2(int arg)
>    {
>       goto target;
>    }
> 
> is invalid code, and 'target' isn't even visible in fn2, because it is
> a local label to fn1.
> 
> I think the exact same thing is the right thing to do for expression
> statements, so
> 
>    int fn(int arg)
>    {
>       goto inside;
>       return ({ inside: 0; });
>    }
> 
> should fail with the exact same error message of having an undefined
> label (which sparse currently gets wrong too, but you're fixing that
> elsewhere).
> 
> Because "inside" simply shouldn't be defined at all in the outer
> scope, and you can only branch _within_ a statement expression, the
> same way you can only branch within a function.
> 
> So I think statement expressions should basically work kind of like
> local "nested functions": they have access to the state outside, but
> the outside doesn't have access to the state inside that statement
> expression.

Yes, I agree and in fact (if I understand you correctly) it was what
I tried first, mainly because it was "conceptualy neat" and simpler.
But then it wasn't working correctly in all situations and I
convinced myself it couldn't. The problem was with code like:
	void foo(void)
	{
		... = ({ ...  goto out; ... });

	out:
		...;
	}

In this case, when 'goto out' is parsed, the corresponding label
symbol would be created in the inner scope and later when the label
is defined the symbol lookup will only look in the outer scope, see
nothing and declare another symbol for it, then the obvious scope
check will complain that the goto's label is undeclared.
But this code is legit and both occurences of the ident 'out' should
refer to the same label, right?

I didn't saw a proper solution for this, hence the current patch 15
where I'm keeping all labels in the usual function scope but where
the new label scope is associated to the STMT_GOTO & STMT_LABEL
and where evaluate_goto_statement() check in the scope of the
goto is contained in the one of the label definition via the
new helper is_in_scope(). This is less elegant than I would have
liked but again I don't see a better solution.

-- Luc
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Mon, 13 Apr 2020 19:32:41 +0000
Message-ID: <CAHk-=wjMSeVVQHZ23=HJ3V-yYPooeuHNHmZtexUVRKg_e5VMXA () mail ! gmail ! com>
--------------------
On Mon, Apr 13, 2020 at 11:54 AM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Yes, I agree and in fact (if I understand you correctly) it was what
> I tried first, mainly because it was "conceptualy neat" and simpler.
> But then it wasn't working correctly in all situations and I
> convinced myself it couldn't. The problem was with code like:
>         void foo(void)
>         {
>                 ... = ({ ...  goto out; ... });
>
>         out:
>                 ...;
>         }
>
> In this case, when 'goto out' is parsed, the corresponding label
> symbol would be created in the inner scope and later when the label
> is defined the symbol lookup will only look in the outer scope, see
> nothing and declare another symbol for it

Oh, yeah, I see.

And that's just because of how we basically do the same thing at
"goto" time as we do at "label definition" time.

Both basically create the symbol label.

Which was simple, and worked, and meant that you never had to look
anything up, because they automatically just did the right thing - and
the use and scope is symmetric.

And the reason it does that, is that labels - unlike every other
symbol - aren't declared before use. So it's a hacky solution, and it
works.

And by "it works", I mean "doesn't really work all that well", because
clearly all the _other_ patches in your series were about the fact
that it also meant that we were horrible at the whole "label was never
defined in the first place" case.

But with the scoping change, the use and scope isn't symmetric any
more, and the "create symbol both at use and at definition" doesn't
work.

I _feel_ like the fix to that should be that the only thing that
creates the actual symbol is the label definition, and that the goto
should only ever use the 'ident' and we'd tie the two together later.

But yeah, that "tie the two together later" may not work, simply
because scoping is so tightly tied to parsing in sparse.

So maybe your approach is the best one.

It feels hacky and wrong, but maybe that just fundamentally comes from
labels having that very special "use = implicit declaration" thing.

              Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Mon, 13 Apr 2020 20:00:43 +0000
Message-ID: <20200413200043.6mv4d67pioex52wb () ltop ! local>
--------------------
On Mon, Apr 13, 2020 at 12:32:41PM -0700, Linus Torvalds wrote:
> 
> I _feel_ like the fix to that should be that the only thing that
> creates the actual symbol is the label definition, and that the goto
> should only ever use the 'ident' and we'd tie the two together later.

Yes, I tried that too but it didn't worked because:
 
> But yeah, that "tie the two together later" may not work, simply
> because scoping is so tightly tied to parsing in sparse.
> 
> So maybe your approach is the best one.
> 
> It feels hacky and wrong, but maybe that just fundamentally comes from
> labels having that very special "use = implicit declaration" thing.

Yes, that and the way the symbol 'table' is done: very clever but
unusable for our problem here. But maybe there is something that can
be done there. Currently end_scope() sets scope->symbols to NULL but
as far as I can see, this is not really needed and, if left, the
"tie the two together later" could be done by doing a symbol lookup
via this list instead of the usual lookup via ident->symbols, much
like classical symbol tables are used. It should be quite easy.
I'll give it a try because I'm also not really satisfied with my
current solution giving a kind of secondary scope to the statements.

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Mon, 13 Apr 2020 23:39:00 +0000
Message-ID: <20200413233900.t7fczyyqrees5gwr () ltop ! local>
--------------------
On Mon, Apr 13, 2020 at 03:40:55PM -0700, Linus Torvalds wrote:
> On Mon, Apr 13, 2020 at 12:32 PM Linus Torvalds
> <torvalds@linux-foundation.org> wrote:
> >
> > I _feel_ like the fix to that should be that the only thing that
> > creates the actual symbol is the label definition, and that the goto
> > should only ever use the 'ident' and we'd tie the two together later.
> 
> Actually, how about something like this?
> 
> I've not signed off on these patches, and the commit logs are
> questionable, but part of that is that the two first ones are just
> quick-and-dirty versions of your rename cleanups.
> 
> The third patch is the serious one, which shows what I think might be
> the solution to the odd scoping rules for labels.
> 
> Basically, we always scope labels - but if a label is _used_ but not
> defined in an inner label, when we close the label scope, we move it
> out to the next level.
> 
> But a defined label is never moved out, and when we define it, we
> require that any previous use was in the same scope (where "same
> scope" might have been an inner scope that was moved out).
> 
> I think it gets the semantics right, and it's actually fairly simple.
> 
> But it has very little testing, so this is more of a "how about
> something like this" than a serious submission.
> 
> If you test it, and fix up the warnings and error cases (like the
> other patches in your series did), you are more than welcome to take
> credit and authorship for this.
> 
> I just felt that the best way to describe (and do _some_ testing) my
> idea was to have a quick implementation to show what I mean.
> 
> And by "_some_ testing" I literally mean "almost no testing at all". I
> didn't even run this on the kernel tree. I just used one stipid small
> test-case for this, and when it gave the warning I wanted, I said
> "good enough" and sent this email out ;)

I like the idea. I just gave it a very quick test with sparse's
"make check" (it covers a lot of simple but corner/dirty cases that
the kernel may/should not have). It seemed to pass all the tests but
the ones using __label__. For exemple, things like this complain:
	{
		__label__ l;

	l:
		goto l;
	}

I'll look more at it tommorow as it's a bit late here. I just fear
that __label__ will spoil things here or at least complicate them.

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Tue, 14 Apr 2020 07:49:34 +0000
Message-ID: <20200414074934.urvzzgpi2a36jdf2 () ltop ! local>
--------------------
On Tue, Apr 14, 2020 at 01:39:00AM +0200, Luc Van Oostenryck wrote:
> 
> I like the idea. I just gave it a very quick test with sparse's
> "make check" (it covers a lot of simple but corner/dirty cases that
> the kernel may/should not have). It seemed to pass all the tests but
> the ones using __label__. For exemple, things like this complain:
> 	{
> 		__label__ l;
> 
> 	l:
> 		goto l;
> 	}
> 
> I'll look more at it tommorow as it's a bit late here. I just fear
> that __label__ will spoil things here or at least complicate them.

The problem is that now normal labels use the new label_scope
but the ones declared with __label__ use block_scope and these
2 scopes are kinda in a different namespace of scope.
It's easy to make it work here but the problem would remain
when extra block levels are present, like in:
	{
		__label__ l;
		{
		l:
			goto l;
		}
		goto l;
	}

It's surely salvageable in some ways but I'm not sure it's worth
the troubles.

-- Luc
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Tue, 14 Apr 2020 18:19:32 +0000
Message-ID: <CAHk-=wiahqumRaQkkcQ_kFhknA9z==DCWNKK-j0GRJH7GUtPEw () mail ! gmail ! com>
--------------------
--000000000000b178a305a3443e48
Content-Type: text/plain; charset="UTF-8"

On Tue, Apr 14, 2020 at 12:49 AM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> The problem is that now normal labels use the new label_scope
> but the ones declared with __label__ use block_scope and these
> 2 scopes are kinda in a different namespace of scope.

Oh, I forgot about the special __label__ thing that actually declares labels.

That one has an interesting behavior, in that the _lifetime_ of the
symbol is the block scope, but the *use* of the symbol must remain in
label scope.

The most obvious fix is probably something like the appended: make the
'sym->scope' remain the lifetime scope, but then attach a "must be
used in this scope' thing to any NS_LABEL case.

That fairly clearly separates the two issues.

Again, not actually tested outside of the obvious trivial case.

              Linus

--000000000000b178a305a3443e48
Content-Type: text/x-patch; charset="US-ASCII"; name="patch.diff"
Content-Disposition: attachment; filename="patch.diff"
Content-Transfer-Encoding: base64
Content-ID: <f_k908b8bi0>
X-Attachment-Id: f_k908b8bi0

IHBhcnNlLmMgIHwgMTYgKysrKysrKysrKystLS0tLQogc2NvcGUuYyAgfCAgMSArCiBzeW1ib2wu
aCB8ICAzICsrKwogMyBmaWxlcyBjaGFuZ2VkLCAxNSBpbnNlcnRpb25zKCspLCA1IGRlbGV0aW9u
cygtKQoKZGlmZiAtLWdpdCBhL3BhcnNlLmMgYi9wYXJzZS5jCmluZGV4IDhlMjM4ZjU5Li5iNjEw
OTUxNiAxMDA2NDQKLS0tIGEvcGFyc2UuYworKysgYi9wYXJzZS5jCkBAIC03MjgsNiArNzI4LDcg
QEAgc3RydWN0IHN5bWJvbCAqbGFiZWxfc3ltYm9sKHN0cnVjdCB0b2tlbiAqdG9rZW4pCiAJaWYg
KCFzeW0pIHsKIAkJc3ltID0gYWxsb2Nfc3ltYm9sKHRva2VuLT5wb3MsIFNZTV9MQUJFTCk7CiAJ
CWJpbmRfc3ltYm9sKHN5bSwgdG9rZW4tPmlkZW50LCBOU19MQUJFTCk7CisJCXN5bS0+ZGVjbGFy
ZWRfc2NvcGUgPSBsYWJlbF9zY29wZTsKIAkJZm5fbG9jYWxfc3ltYm9sKHN5bSk7CiAJfQogCXJl
dHVybiBzeW07CkBAIC0yNTQxLDEzICsyNTQyLDE0IEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKnN0
YXRlbWVudChzdHJ1Y3QgdG9rZW4gKnRva2VuLCBzdHJ1Y3Qgc3RhdGVtZW50ICoqdHJlZSkKIAkJ
CX0KIAkJCS8qCiAJCQkgKiBJZiB0aGUgc2NvcGUgb2YgdGhlIGxhYmVsIHN5bWJvbCBpcyBkaWZm
ZXJlbnQKLQkJCSAqIGZyb20gdGhlIGN1cnJlbnQgbGFiZWwgc2NvcGUsIHRoYXQgbWVhbnMgdGhh
dAotCQkJICogaXQgbXVzdCBoYXZlIGJlZW4gdXNlZCBhdCBhbiBvdXRlciBzY29wZS4KKwkJCSAq
IGZyb20gdGhlIGRlY2xhcmVkIGxhYmVsIHNjb3BlLCB0aGF0IG1lYW5zIHRoYXQKKwkJCSAqIGl0
IG11c3QgaGF2ZSBiZWVuIHVzZWQgb3IgZGVjbGFyZWQgYXQgYW4gb3V0ZXIKKwkJCSAqIHNjb3Bl
LgogCQkJICoKIAkJCSAqIFRoYXQncyBub3Qgb2suCiAJCQkgKi8KLQkJCWlmIChzLT5zY29wZSAh
PSBsYWJlbF9zY29wZSkgewotCQkJCXNwYXJzZV9lcnJvcihzdG10LT5wb3MsICJsYWJlbCAnJXMn
IHVzZWQgb3V0c2lkZSBsYWJlbCBleHByZXNzaW9uIiwgc2hvd19pZGVudChzLT5pZGVudCkpOwor
CQkJaWYgKHMtPnNjb3BlICE9IHMtPmRlY2xhcmVkX3Njb3BlKSB7CisJCQkJc3BhcnNlX2Vycm9y
KHN0bXQtPnBvcywgImxhYmVsICclcycgdXNlZCBvdXRzaWRlIHN0YXRlbWVudCBleHByZXNzaW9u
Iiwgc2hvd19pZGVudChzLT5pZGVudCkpOwogCQkJCXNwYXJzZV9lcnJvcihzLT5wb3MsICJpbnZh
bGlkIHVzZSBoZXJlIik7CiAJCQl9CiAJCQlzdG10LT50eXBlID0gU1RNVF9MQUJFTDsKQEAgLTI1
NzUsOSArMjU3NywxMyBAQCBzdGF0aWMgc3RydWN0IHRva2VuICpsYWJlbF9zdGF0ZW1lbnQoc3Ry
dWN0IHRva2VuICp0b2tlbikKIHsKIAl3aGlsZSAodG9rZW5fdHlwZSh0b2tlbikgPT0gVE9LRU5f
SURFTlQpIHsKIAkJc3RydWN0IHN5bWJvbCAqc3ltID0gYWxsb2Nfc3ltYm9sKHRva2VuLT5wb3Ms
IFNZTV9MQUJFTCk7Ci0JCS8qIGl0J3MgYmxvY2stc2NvcGUsIGJ1dCB3ZSB3YW50IGxhYmVsIG5h
bWVzcGFjZSAqLworCisJCS8qIGl0J3MgbGlmZXRpbGUgaXMgYmxvY2stc2NvcGUsIGJ1dCB3ZSB3
YW50IGxhYmVsIG5hbWVzcGFjZSAqLwogCQliaW5kX3N5bWJvbChzeW0sIHRva2VuLT5pZGVudCwg
TlNfU1lNQk9MKTsKIAkJc3ltLT5uYW1lc3BhY2UgPSBOU19MQUJFTDsKKworCQkvKiBCdXQgd2Ug
bXVzdCBkZWZpbmUgaXQgaW4gdGhpcyBsYWJlbCBzY29wZSAqLworCQlzeW0tPmRlY2xhcmVkX3Nj
b3BlID0gbGFiZWxfc2NvcGU7CiAJCWZuX2xvY2FsX3N5bWJvbChzeW0pOwogCQl0b2tlbiA9IHRv
a2VuLT5uZXh0OwogCQlpZiAoIW1hdGNoX29wKHRva2VuLCAnLCcpKQpkaWZmIC0tZ2l0IGEvc2Nv
cGUuYyBiL3Njb3BlLmMKaW5kZXggNGIwZjc5NDcuLjExNzkyZWM0IDEwMDY0NAotLS0gYS9zY29w
ZS5jCisrKyBiL3Njb3BlLmMKQEAgLTE3MSw2ICsxNzEsNyBAQCB2b2lkIGVuZF9sYWJlbF9zY29w
ZSh2b2lkKQogCiAJCS8qIFJlLWJpbmQgdGhlIHN5bWJvbCB0byB0aGUgcGFyZW50IHNjb3BlLCB3
ZSdsbCB0cnkgYWdhaW4gKi8KIAkJYmluZF9zY29wZShzeW0sIGxhYmVsX3Njb3BlKTsKKwkJc3lt
LT5kZWNsYXJlZF9zY29wZSA9IGxhYmVsX3Njb3BlOwogCX0gRU5EX0ZPUl9FQUNIX1BUUihzeW0p
OwogCiAJZW5kX3Njb3BlKCZibG9ja19zY29wZSk7CmRpZmYgLS1naXQgYS9zeW1ib2wuaCBiL3N5
bWJvbC5oCmluZGV4IDE4NDc2NTgyLi4wOGUzNTQzOCAxMDA2NDQKLS0tIGEvc3ltYm9sLmgKKysr
IGIvc3ltYm9sLmgKQEAgLTE2Nyw2ICsxNjcsOSBAQCBzdHJ1Y3Qgc3ltYm9sIHsKIAkJCWludCAo
KmhhbmRsZXIpKHN0cnVjdCBzdHJlYW0gKiwgc3RydWN0IHRva2VuICoqLCBzdHJ1Y3QgdG9rZW4g
Kik7CiAJCQlpbnQgbm9ybWFsOwogCQl9OworCQlzdHJ1Y3QgLyogTlNfTEFCRUwgKi8geworCQkJ
c3RydWN0IHNjb3BlICpkZWNsYXJlZF9zY29wZTsKKwkJfTsKIAkJc3RydWN0IC8qIE5TX1NZTUJP
TCAqLyB7CiAJCQl1bnNpZ25lZCBsb25nCW9mZnNldDsKIAkJCWludAkJYml0X3NpemU7Cg==
--000000000000b178a305a3443e48--
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Wed, 15 Apr 2020 00:59:18 +0000
Message-ID: <CAHk-=whoCQ9hiNsNS_PKJGt+dxhXng8+YLJ-CzGG0eESfv0f0g () mail ! gmail ! com>
--------------------
On Tue, Apr 14, 2020 at 4:09 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> +                       if (s->scope != s->declared_scope) {
>
> This comparison can never succeed for labels declared with __label__
> because s->scope is a block scope and s->declared_scope a label one.

Hold on.. I'm sure I tested it.

Oh.

What I tested wasn't what I sent you, and I'd fixed things due to the
testing but not updated the patch file.

Oops.

The test is supposed to be

                        if (s->declared_scope != label_scope) {

which is the whole point of that 'declared_scope'.

So the concept of the patch is that the 'declared_scope' (and
'label_scope') are the same kind of scope (and comparable): it is the
applicability of the label itself (either the whole function or some
sub-expression statement).

And the the visibility of the -symbol- ends up being different, and is
the s->scope thing.

But while my testing wasn't quite as limited as my wrong-version patch
implied, it _was_ limited. So it might miss some other case.

              Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 15/17] scope: give a scope for labels & gotos
Date: Thu, 14 May 2020 22:22:39 +0000
Message-ID: <20200514222227.n3hvic3lndz5qcjv () ltop ! local>
--------------------
On Tue, Apr 14, 2020 at 05:59:18PM -0700, Linus Torvalds wrote:
> On Tue, Apr 14, 2020 at 4:09 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > +                       if (s->scope != s->declared_scope) {
> >
> > This comparison can never succeed for labels declared with __label__
> > because s->scope is a block scope and s->declared_scope a label one.
> 
> Hold on.. I'm sure I tested it.
> 
> Oh.
> 
> What I tested wasn't what I sent you, and I'd fixed things due to the
> testing but not updated the patch file.
> 
> Oops.
> 
> The test is supposed to be
> 
>                         if (s->declared_scope != label_scope) {
> 
> which is the whole point of that 'declared_scope'.
> 
> So the concept of the patch is that the 'declared_scope' (and
> 'label_scope') are the same kind of scope (and comparable): it is the
> applicability of the label itself (either the whole function or some
> sub-expression statement).
> 
> And the the visibility of the -symbol- ends up being different, and is
> the s->scope thing.
> 
> But while my testing wasn't quite as limited as my wrong-version patch
> implied, it _was_ limited. So it might miss some other case.

Sorry for the late reply.

Yes, it's working OK wth this change but there are several issues that
make me think that this approach is not ideal:

1) these 2 functions would give very different error message:
	void foo(void)
	{
		goto l;
		({ l: 0; });
	}

	void bar(void)
	{
		({ l: 0; });
		goto l;
	}

  The first one gives the 'warning: jumping inside statement expression'
  while the second one can only give 'warning: goto with undeclared label'
  because indeed the 'l' label inside the statement isn't visible anymore.
  This second warning is of coure less informative than the first one
  but what I really find abnormal is that the warning would be different
  depending on the fact that the goto comes before or after the label
  definition. This seems incorrect to me, confusing and is different
  from GCC (clang doesn't seems to mind).

2) in the following case, no warning can be given:
	void foo(void)
	{
	l:
		({
		l:
			goto l;
			0;
		});
		goto l;
	}
  
   In this case both label definition are in a different scope and each goto
   sees its own label. This is different than GCC which would complain
   about 'l' being redeclared.

   There was also another issue related to the fact that GCC put all
   labels in a single namespace bit I forgot the details.


These two problems are linked to the fact of using the local namespace
for labels while GCC use a single one for all of them.
But well, then again I can't say I'm fully happy with my solution
using the label scope not for the labels but for their definition
and uses (gotos & label expressions) and then comparing these with
the helper is_in_scope().

I dunno. I've fixed a number of details, I'll repost everything soon.

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH 17/17] bad-goto: cleanup evaluate_goto() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 17/17] bad-goto: cleanup evaluate_goto()
Date: Mon, 13 Apr 2020 16:16:05 +0000
Message-ID: <20200413161605.95900-18-luc.vanoostenryck () gmail ! com>
--------------------
Reorganize the code to not repeat the test of the
label's namespace.

Also, make all namespaces other than NS_LABEL & NS_ITERATOR
as bogus and add some comments.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 26 ++++++++++++++------------
 1 file changed, 14 insertions(+), 12 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 2b845a301d6b..663540ff6445 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3748,20 +3748,22 @@ static void evaluate_goto_statement(struct statement *stmt)
 		return;
 	}
 
-	if (label->namespace == NS_LABEL && !label->stmt) {
-		sparse_error(stmt->pos, "label '%s' was not declared", show_ident(label->ident));
-		current_fn->bogus_linear = 1;
-	}
-	if (label->namespace == NS_LABEL && label->stmt) {
-		if (is_in_scope(label->label_scope, stmt->goto_scope))
-			return;
-		sparse_error(stmt->pos, "goto into statement expression");
-		info(label->stmt->pos,"   label '%s' is defined here",
-					show_ident(label->ident));
+	switch (label->namespace) {
+	case NS_ITERATOR:	// break / continue
+		break;
+	case NS_LABEL:		// goto + ident
+		if (!label->stmt) {
+			sparse_error(stmt->pos, "label '%s' was not declared",
+						show_ident(label->ident));
+		} else if (!is_in_scope(label->label_scope, stmt->goto_scope)) {
+			sparse_error(stmt->pos, "goto into statement expression");
+			info(label->stmt->pos,"   label '%s' is defined here",
+						show_ident(label->ident));
+		} else
+			break;
+	default:
 		current_fn->bogus_linear = 1;
 	}
-	if (label->namespace == NS_NONE)
-		current_fn->bogus_linear = 1;
 }
 
 struct symbol *evaluate_statement(struct statement *stmt)
-- 
2.26.0

================================================================================


################################################################################

=== Thread: [PATCH 2/2] dissect: enforce sym->kind='f' when it looks like a function call ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 2/2] dissect: enforce sym->kind='f' when it looks like a function call
Date: Mon, 10 Feb 2020 16:20:38 +0000
Message-ID: <20200210162038.GA29643 () redhat ! com>
--------------------
A separate change for documentation purposes.

dissect() tries to work even if the parsed code is buggy or incomplete,
thus it makes sense to change expr_symbol() to set kind = 'f' when it
likely looks like a function name.

We can safely abuse EXPR_SYMBOL->op to pass the hint to expr_symbol(),
it must be 0.

Test-case:

	void call(void)
	{
		func();
	}

before this patch

	1:14                   def f call                             void ( ... )
	3:17  call             --r v func                             bad type

after:

	1:14                   def f call                             void ( ... )
	3:17  call             --r f func                             bad type

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c      | 4 +++-
 test-dissect.c | 2 +-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/dissect.c b/dissect.c
index 20456b2..d9ca142 100644
--- a/dissect.c
+++ b/dissect.c
@@ -166,7 +166,7 @@ static inline struct symbol *expr_symbol(struct expression *expr)
 			sym = alloc_symbol(expr->pos, SYM_BAD);
 			bind_symbol(sym, expr->symbol_name, NS_SYMBOL);
 			sym->ctype.modifiers = MOD_EXTERN;
-			sym->kind = 'v';
+			sym->kind = expr->op ?: 'v'; /* see EXPR_CALL */
 		}
 	}
 
@@ -374,6 +374,8 @@ again:
 		ret = do_expression(mode, expr->cond_false);
 
 	break; case EXPR_CALL:
+		if (expr->fn->type == EXPR_SYMBOL)
+			expr->fn->op = 'f'; /* for expr_symbol() */
 		ret = do_expression(U_R_PTR, expr->fn);
 		if (is_ptr(ret))
 			ret = ret->ctype.base_type;
diff --git a/test-dissect.c b/test-dissect.c
index 81cc89d..ece2253 100644
--- a/test-dissect.c
+++ b/test-dissect.c
@@ -55,7 +55,7 @@ static void r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
 		goto err;
 
 	case 'f':
-		if (sym->ctype.base_type->type != SYM_FN)
+		if (sym->type != SYM_BAD && sym->ctype.base_type->type != SYM_FN)
 			goto err;
 	case 'v':
 		if (sym->type == SYM_NODE || sym->type == SYM_BAD)
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH 2/2] dissect: kill no_member() ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 2/2] dissect: kill no_member()
Date: Wed, 12 Feb 2020 10:04:37 +0000
Message-ID: <20200212100437.GA23419 () redhat ! com>
--------------------
It is trivial and has a single caller, lookup_member().

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 29 ++++++++++++++---------------
 1 file changed, 14 insertions(+), 15 deletions(-)

diff --git a/dissect.c b/dissect.c
index 05bddc8..40baf64 100644
--- a/dissect.c
+++ b/dissect.c
@@ -119,19 +119,6 @@ static usage_t fix_mode(struct symbol *type, usage_t mode)
 	return mode;
 }
 
-static inline struct symbol *no_member(struct ident *name)
-{
-	static struct symbol sym = {
-		.type = SYM_BAD,
-		.ctype.base_type = &bad_ctype,
-		.kind = 'm',
-	};
-
-	sym.ident = name;
-
-	return &sym;
-}
-
 static struct symbol *report_member(usage_t mode, struct position *pos,
 					struct symbol *type, struct symbol *mem)
 {
@@ -308,8 +295,20 @@ found:
 
 static struct symbol *lookup_member(struct symbol *type, struct ident *name, int *addr)
 {
-	return __lookup_member(type, name, addr)
-		?: no_member(name);
+	struct symbol *mem = __lookup_member(type, name, addr);
+
+	if (!mem) {
+		static struct symbol bad_member = {
+			.type = SYM_BAD,
+			.ctype.base_type = &bad_ctype,
+			.kind = 'm',
+		};
+
+		mem = &bad_member;
+		mem->ident = name;
+	}
+
+	return mem;
 }
 
 static struct expression *peek_preop(struct expression *expr, int op)
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH 2/2] fix rem_usage() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] fix rem_usage()
Date: Sun, 27 Dec 2020 09:27:59 +0000
Message-ID: <20201227092759.30999-3-luc.vanoostenryck () gmail ! com>
--------------------
rem_usage() is used to remove an element from a def-use chain. Optionally,
if the chain become empty, the defining instruction can also be killed.

This optional part is currently be done on all pseudos but only those
having a definition should be concerned.

Fix this by adding a check so that only PSEUDO_REGs and PSEUDO_PHIs are killed.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index a877b693b610..12482d787189 100644
--- a/simplify.c
+++ b/simplify.c
@@ -271,7 +271,7 @@ static inline void rem_usage(pseudo_t p, pseudo_t *usep, int kill)
 {
 	if (has_use_list(p)) {
 		delete_pseudo_user_list_entry(&p->users, usep, 1);
-		if (kill && !p->users)
+		if (kill && !p->users && has_definition(p))
 			kill_instruction(p->def);
 	}
 }
-- 
2.29.2

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] fix rem_usage()
Date: Mon, 28 Dec 2020 17:22:36 +0000
Message-ID: <52a111f5-aea4-d705-f0c3-d71ecb2226dc () ramsayjones ! plus ! com>
--------------------


On 27/12/2020 09:27, Luc Van Oostenryck wrote:
> rem_usage() is used to remove an element from a def-use chain. Optionally,

Hmm, rename this to 'remove_usage()' at the same time?

ATB,
Ramsay Jones

> if the chain become empty, the defining instruction can also be killed.
> 
> This optional part is currently be done on all pseudos but only those
> having a definition should be concerned.
> 
> Fix this by adding a check so that only PSEUDO_REGs and PSEUDO_PHIs are killed.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  simplify.c | 2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
> 
> diff --git a/simplify.c b/simplify.c
> index a877b693b610..12482d787189 100644
> --- a/simplify.c
> +++ b/simplify.c
> @@ -271,7 +271,7 @@ static inline void rem_usage(pseudo_t p, pseudo_t *usep, int kill)
>  {
>  	if (has_use_list(p)) {
>  		delete_pseudo_user_list_entry(&p->users, usep, 1);
> -		if (kill && !p->users)
> +		if (kill && !p->users && has_definition(p))
>  			kill_instruction(p->def);
>  	}
>  }
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] fix rem_usage()
Date: Mon, 28 Dec 2020 21:39:43 +0000
Message-ID: <20201228213943.honhyxpk6apd23tg () ltop ! local>
--------------------
On Mon, Dec 28, 2020 at 05:22:36PM +0000, Ramsay Jones wrote:
> 
> 
> On 27/12/2020 09:27, Luc Van Oostenryck wrote:
> > rem_usage() is used to remove an element from a def-use chain. Optionally,
> 
> Hmm, rename this to 'remove_usage()' at the same time?

It can't, 'remove_usage()' is already taken and 'rem_usage()' is more
for internal uses than 'remove_usage()'.

-- Luc
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] fix rem_usage()
Date: Mon, 28 Dec 2020 22:09:35 +0000
Message-ID: <f8b3a7fe-e4b3-a83f-7d2a-71ec8e79b3de () ramsayjones ! plus ! com>
--------------------


On 28/12/2020 21:39, Luc Van Oostenryck wrote:
> On Mon, Dec 28, 2020 at 05:22:36PM +0000, Ramsay Jones wrote:
>>
>>
>> On 27/12/2020 09:27, Luc Van Oostenryck wrote:
>>> rem_usage() is used to remove an element from a def-use chain. Optionally,
>>
>> Hmm, rename this to 'remove_usage()' at the same time?
> 
> It can't, 'remove_usage()' is already taken and 'rem_usage()' is more
> for internal uses than 'remove_usage()'.

Ugh! I just took a quick look. Ugly. ;-)

Well, I think I would rename it 'remove_use()' or somesuch instead.

ATB,
Ramsay Jones

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] fix rem_usage()
Date: Mon, 28 Dec 2020 22:30:29 +0000
Message-ID: <25740e62-2357-0a87-5a8a-07d6278ca1de () ramsayjones ! plus ! com>
--------------------


On 28/12/2020 22:09, Ramsay Jones wrote:
> 
> 
> On 28/12/2020 21:39, Luc Van Oostenryck wrote:
>> On Mon, Dec 28, 2020 at 05:22:36PM +0000, Ramsay Jones wrote:
>>>
>>>
>>> On 27/12/2020 09:27, Luc Van Oostenryck wrote:
>>>> rem_usage() is used to remove an element from a def-use chain. Optionally,
>>>
>>> Hmm, rename this to 'remove_usage()' at the same time?
>>
>> It can't, 'remove_usage()' is already taken and 'rem_usage()' is more
>> for internal uses than 'remove_usage()'.
> 
> Ugh! I just took a quick look. Ugly. ;-)
> 
> Well, I think I would rename it 'remove_use()' or somesuch instead.

Ahem, except you can't, because it is already used ... (facepalm).

Ho Hum. ;-)

ATB,
Ramsay Jones

================================================================================


################################################################################

=== Thread: [PATCH 2/2] fix testing if a OP_CALL's function is pure ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] fix testing if a OP_CALL's function is pure
Date: Sun, 25 Oct 2020 13:09:21 +0000
Message-ID: <20201025130921.20693-3-luc.vanoostenryck () gmail ! com>
--------------------
kill_instruction() will kill an OP_CALL but only if it's a
forced kill or if the corresponding function is pure.

However, only functions called via a symbol pseudo are so killed.
Those called via a function pointer are not because only symbol
pseudos contain the function type needed to test the presence of
the MOD_PURE modifier.

Fix this by using the function type always available in the
instruction's ::fntypes member.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/simplify.c b/simplify.c
index 6caf6cbcf918..634a3ea66e91 100644
--- a/simplify.c
+++ b/simplify.c
@@ -351,9 +351,9 @@ int kill_insn(struct instruction *insn, int force)
 	case OP_CALL:
 		if (!force) {
 			/* a "pure" function can be killed too */
-			if (!(insn->func->type == PSEUDO_SYM))
-				return 0;
-			if (!(insn->func->sym->ctype.modifiers & MOD_PURE))
+			struct symbol *fntype = first_symbol(insn->fntypes);
+
+			if (!(fntype->ctype.modifiers & MOD_PURE))
 				return 0;
 		}
 		kill_use_list(insn->arguments);
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH 2/3] dissect: fix sym_is_local(SYM_STRUCT/UNION/ENUM) ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 2/3] dissect: fix sym_is_local(SYM_STRUCT/UNION/ENUM)
Date: Fri, 14 Feb 2020 11:33:43 +0000
Message-ID: <20200214113343.GA31587 () redhat ! com>
--------------------
Now that struct_union_enum_specifier() sets MOD_TOPLEVEL we can
simplify sym_is_local(sym) and rely on it even if "sym" is type.

Test-case:

	// copied from linux kernel
	# define __force	__attribute__((force))
	#define WRITE_ONCE(x, val) \
	({							\
		union { typeof(x) __val; char __c[1]; } __u =	\
			{ .__val = (__force typeof(x)) (val) }; \
		__write_once_size(&(x), __u.__c, sizeof(x));	\
		__u.__val;					\
	})

	void func(int *p)
	{
		WRITE_ONCE(*p, 0);
	}

before this patch the widely used WRITE_ONCE() generates a lot of spam which
can't be filtered out using sym_is_local(),

	11:6                    def   f func                             void ( ... )
	11:11  func             def . v p                                int *
	13:9                    def   s :__u
	13:9                    --- . v p                                int *
	13:9                    def   m :__u.__val                       int
	13:9                    def   m :__u.__c                         char [1]
	13:9   func             def . v __u                              union :__u
	13:9   func             -w- . v __u                              union :__u
	13:9   func             -w-   m :__u.__val                       int
	13:9   func             --- . v p                                int *
	13:9   func             --r   f __write_once_size                bad type
	13:9   func             -r- . v p                                int *
	13:9   func             -r- . v __u                              union :__u
	13:9   func             m--   m :__u.__c                         char [1]
	13:9   func             --- . v p                                int *
	13:9   func             --- . v __u                              union :__u
	13:9   func             ---   m :__u.__val                       int

plus it triggers warning("no context") in test-dissect.c. With this patch
the only "nonlocal" report is __write_once_size() call.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 3 ++-
 dissect.h | 2 +-
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/dissect.c b/dissect.c
index 40baf64..1465760 100644
--- a/dissect.c
+++ b/dissect.c
@@ -238,7 +238,8 @@ static void examine_sym_node(struct symbol *node, struct symbol *parent)
 				return;
 
 			dctx = dissect_ctx;
-			dissect_ctx = NULL;
+			if (base->ctype.modifiers & MOD_TOPLEVEL)
+				dissect_ctx = NULL;
 
 			if (base->ident || deanon(base, name, parent))
 				reporter->r_symdef(base);
diff --git a/dissect.h b/dissect.h
index 326d3dc..38ac877 100644
--- a/dissect.h
+++ b/dissect.h
@@ -29,7 +29,7 @@ extern struct symbol *dissect_ctx;
 
 static inline bool sym_is_local(struct symbol *sym)
 {
-	return sym->kind == 'v' && !(sym->ctype.modifiers & MOD_TOPLEVEL);
+	return !(sym->ctype.modifiers & MOD_TOPLEVEL);
 }
 
 extern void dissect(struct reporter *, struct string_list *);
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH 2/3] union-cast: extract evaluate_compound_literal() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] union-cast: extract evaluate_compound_literal()
Date: Sat, 15 Aug 2020 15:28:02 +0000
Message-ID: <20200815152803.2788-3-luc.vanoostenryck () gmail ! com>
--------------------
extract evaluate_compound_literal() from evaluate_cast,
in preparation for supporting union casts.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 41 ++++++++++++++++++++++-------------------
 1 file changed, 22 insertions(+), 19 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 63a9390b5ee7..0563be939f23 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2948,6 +2948,26 @@ static int cast_flags(struct expression *expr, struct expression *old)
 	return flags;
 }
 
+static struct symbol *evaluate_compound_literal(struct expression *expr, struct expression *source)
+{
+	struct expression *addr = alloc_expression(expr->pos, EXPR_SYMBOL);
+	struct symbol *sym = expr->cast_type;
+
+	sym->initializer = source;
+	evaluate_symbol(sym);
+
+	addr->ctype = &lazy_ptr_ctype;	/* Lazy eval */
+	addr->symbol = sym;
+	if (sym->ctype.modifiers & MOD_TOPLEVEL)
+		addr->flags |= CEF_ADDR;
+
+	expr->type = EXPR_PREOP;
+	expr->op = '*';
+	expr->deref = addr;
+	expr->ctype = sym;
+	return sym;
+}
+
 static struct symbol *evaluate_cast(struct expression *expr)
 {
 	struct expression *source = expr->cast_expression;
@@ -2970,25 +2990,8 @@ static struct symbol *evaluate_cast(struct expression *expr)
 	 * dereferenced as part of a post-fix expression.
 	 * We need to produce an expression that can be dereferenced.
 	 */
-	if (source->type == EXPR_INITIALIZER) {
-		struct symbol *sym = expr->cast_type;
-		struct expression *addr = alloc_expression(expr->pos, EXPR_SYMBOL);
-
-		sym->initializer = source;
-		evaluate_symbol(sym);
-
-		addr->ctype = &lazy_ptr_ctype;	/* Lazy eval */
-		addr->symbol = sym;
-		if (sym->ctype.modifiers & MOD_TOPLEVEL)
-			addr->flags |= CEF_ADDR;
-
-		expr->type = EXPR_PREOP;
-		expr->op = '*';
-		expr->unop = addr;
-		expr->ctype = sym;
-
-		return sym;
-	}
+	if (source->type == EXPR_INITIALIZER)
+		return evaluate_compound_literal(expr, source);
 
 	ctype = examine_symbol_type(expr->cast_type);
 	expr->ctype = ctype;
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 2/3] warn on empty assignments ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] warn on empty assignments
Date: Tue, 14 Jul 2020 00:00:29 +0000
Message-ID: <20200714000030.85886-3-luc.vanoostenryck () gmail ! com>
--------------------
Currently sparse accepts an empty assignment like:
	a = ;

Make this an error.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expression.c                | 6 +++++-
 validation/bad-assignment.c | 1 +
 validation/empty-assign.c   | 1 -
 3 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/expression.c b/expression.c
index 1160cd9cc593..ecbdd18eb402 100644
--- a/expression.c
+++ b/expression.c
@@ -937,10 +937,14 @@ struct token *assignment_expression(struct token *token, struct expression **tre
 		for (i = 0; i < ARRAY_SIZE(assignments); i++)
 			if (assignments[i] == op) {
 				struct expression * expr = alloc_expression(token->pos, EXPR_ASSIGNMENT);
+				struct token *next = token->next;
 				expr->left = *tree;
 				expr->op = op;
 				*tree = expr;
-				return assignment_expression(token->next, &expr->right);
+				token = assignment_expression(next, &expr->right);
+				if (token == next)
+					expression_error(expr, "expression expected before '%s'", show_token(token));
+				return token;
 			}
 	}
 	return token;
diff --git a/validation/bad-assignment.c b/validation/bad-assignment.c
index 71938db7c4f5..959712beda94 100644
--- a/validation/bad-assignment.c
+++ b/validation/bad-assignment.c
@@ -8,6 +8,7 @@ static int foo(int a)
  * check-name: bad assignment
  *
  * check-error-start
+bad-assignment.c:3:11: error: expression expected before '\'
 bad-assignment.c:3:13: error: Expected ; at end of statement
 bad-assignment.c:3:13: error: got \
  * check-error-end
diff --git a/validation/empty-assign.c b/validation/empty-assign.c
index 48ac626ddaed..d1c3884f71e8 100644
--- a/validation/empty-assign.c
+++ b/validation/empty-assign.c
@@ -6,7 +6,6 @@ static int foo(int a)
 
 /*
  * check-name: empty-assign
- * check-known-to-fail
  *
  * check-error-start
 empty-assign.c:3:11: error: expression expected before ';'
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 2/4] dissect: turn mk_name() into deanon() ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 2/4] dissect: turn mk_name() into deanon()
Date: Tue, 04 Feb 2020 16:51:40 +0000
Message-ID: <20200204165140.GA24343 () redhat ! com>
--------------------
Preparation. Change mk_name() to initialize base->ident itself, simplify it,
and rename to deanon().

Also change examine_sym_node() to accept "struct symbol *parent" rather than
"struct ident *root". Currently it is only used as ->ident holder, but this
will be changed.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/dissect.c b/dissect.c
index ff3a313..d34b38a 100644
--- a/dissect.c
+++ b/dissect.c
@@ -190,18 +190,22 @@ static struct symbol *report_symbol(usage_t mode, struct expression *expr)
 	return ret;
 }
 
-static inline struct ident *mk_name(struct ident *root, struct ident *node)
+static bool deanon(struct symbol *base, struct ident *node, struct symbol *parent)
 {
+	struct ident *pi = parent ? parent->ident : NULL;
 	char name[256];
 
+	if (!node)
+		return false;
+
 	snprintf(name, sizeof(name), "%.*s:%.*s",
-			root ? root->len : 0, root ? root->name : "",
-			node ? node->len : 0, node ? node->name : "");
+		pi ? pi->len : 0, pi ? pi->name : NULL, node->len, node->name);
 
-	return built_in_ident(name);
+	base->ident = built_in_ident(name);
+	return true;
 }
 
-static void examine_sym_node(struct symbol *node, struct ident *root)
+static void examine_sym_node(struct symbol *node, struct symbol *parent)
 {
 	struct symbol *base;
 	struct ident *name;
@@ -232,12 +236,12 @@ static void examine_sym_node(struct symbol *node, struct ident *root)
 				return;
 			base->evaluated = 1;
 
-			if (!base->ident && name)
-				base->ident = mk_name(root, name);
-			if (base->ident && reporter->r_symdef)
-				reporter->r_symdef(base);
+			if (base->ident || deanon(base, name, parent)) {
+				if (reporter->r_symdef)
+					reporter->r_symdef(base);
+			}
 			DO_LIST(base->symbol_list, mem,
-				examine_sym_node(mem, base->ident ?: root));
+				examine_sym_node(mem, base->ident ? base : parent));
 		default:
 			return;
 		}
-- 
2.5.0

================================================================================


################################################################################

=== Thread: [PATCH 2/5] add instruction OP_UNREACH ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/5] add instruction OP_UNREACH
Date: Wed, 18 Mar 2020 17:31:17 +0000
Message-ID: <20200318173120.63939-3-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/IR.rst | 3 +++
 linearize.c          | 3 +++
 opcode.def           | 1 +
 3 files changed, 7 insertions(+)

diff --git a/Documentation/IR.rst b/Documentation/IR.rst
index 9d6f2299eaf1..33a761662fad 100644
--- a/Documentation/IR.rst
+++ b/Documentation/IR.rst
@@ -47,6 +47,9 @@ Terminators
 	* .type: type of .cond, must be an integral type
 	* .multijmp_list: pairs of case-value - destination basic block
 
+.. op:: OP_UNREACH
+	Mark code as unreachable
+
 .. op:: OP_COMPUTEDGOTO
 	Computed goto / branch to register
 
diff --git a/linearize.c b/linearize.c
index 30ed2a302d95..f1e538e23ae1 100644
--- a/linearize.c
+++ b/linearize.c
@@ -183,6 +183,7 @@ static const char *opcodes[] = {
 	[OP_BR] = "br",
 	[OP_CBR] = "cbr",
 	[OP_SWITCH] = "switch",
+	[OP_UNREACH] = "unreach",
 	[OP_COMPUTEDGOTO] = "jmp *",
 	
 	/* Binary */
@@ -399,6 +400,8 @@ const char *show_instruction(struct instruction *insn)
 		} END_FOR_EACH_PTR(jmp);
 		break;
 	}
+	case OP_UNREACH:
+		break;
 
 	case OP_PHISOURCE: {
 		struct instruction *phi;
diff --git a/opcode.def b/opcode.def
index 57d827f449b5..2583e2f4a602 100644
--- a/opcode.def
+++ b/opcode.def
@@ -10,6 +10,7 @@ OPCODE(RET,             BADOP,    BADOP,    BADOP, 1, OPF_NONE)
 OPCODE(BR,              BADOP,    BADOP,    BADOP, 0, OPF_NONE)
 OPCODE(CBR,             BADOP,    BADOP,    BADOP, 1, OPF_NONE)
 OPCODE(SWITCH,          BADOP,    BADOP,    BADOP, 1, OPF_NONE)
+OPCODE(UNREACH,         BADOP,    BADOP,    BADOP, 0, OPF_NONE)
 OPCODE(COMPUTEDGOTO,    BADOP,    BADOP,    BADOP, 1, OPF_NONE)
 OPCODE_RANGE(TERMINATOR, RET, COMPUTEDGOTO)
 
-- 
2.25.1

================================================================================


################################################################################

=== Thread: [PATCH 2/5] gensel: use temporary variable in generic selection ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/5] gensel: use temporary variable in generic selection
Date: Fri, 19 Jun 2020 15:02:57 +0000
Message-ID: <20200619150300.63695-3-luc.vanoostenryck () gmail ! com>
--------------------
Use a temporary variable for 'map->type' to make the expressions
in the following patches more readable.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 95aef4dc0758..cf40eed418b4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3293,9 +3293,11 @@ static struct symbol *evaluate_generic_selection(struct expression *expr)
 		return NULL;
 
 	for (map = expr->map; map; map = map->next) {
-		if (!evaluate_symbol(map->type))
+		struct symbol *stype = map->type;
+
+		if (!evaluate_symbol(stype))
 			continue;
-		if (!type_selection(ctrl, map->type))
+		if (!type_selection(ctrl, stype))
 			continue;
 
 		res = map->expr;
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 2/5] pre-process: rename 'expander' into 'expand_simple' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/5] pre-process: rename 'expander' into 'expand_simple'
Date: Thu, 18 Jun 2020 20:47:13 +0000
Message-ID: <20200618204716.3896-3-luc.vanoostenryck () gmail ! com>
--------------------
Sparse support the expansion of one-symbol-builtin macros like
__FILE__ or the pre-processor operator 'defined'. It also supports the
expansion of builtin macros with arguments, like __has_attribute()
but only inside a pre-processor conditional expression.

In preparation of adding the general expansion of these macros,
rename the method 'expander' into 'expand_simple'.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 pre-process.c | 8 ++++----
 symbol.h      | 2 +-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/pre-process.c b/pre-process.c
index e6becf233eba..059a7c1d9b7b 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -229,8 +229,8 @@ static int expand_one_symbol(struct token **list)
 	sym = lookup_macro(token->ident);
 	if (!sym)
 		return 1;
-	if (sym->expander) {
-		sym->expander(token);
+	if (sym->expand_simple) {
+		sym->expand_simple(token);
 		return 1;
 	} else {
 		int rc;
@@ -2040,7 +2040,7 @@ static void init_preprocessor(void)
 	};
 	static struct {
 		const char *name;
-		void (*expander)(struct token *);
+		void (*expand_simple)(struct token *);
 	} dynamic[] = {
 		{ "__LINE__",		expand_line },
 		{ "__FILE__",		expand_file },
@@ -2066,7 +2066,7 @@ static void init_preprocessor(void)
 	for (i = 0; i < ARRAY_SIZE(dynamic); i++) {
 		struct symbol *sym;
 		sym = create_symbol(stream, dynamic[i].name, SYM_NODE, NS_MACRO);
-		sym->expander = dynamic[i].expander;
+		sym->expand_simple = dynamic[i].expand_simple;
 	}
 
 	counter_macro = 0;
diff --git a/symbol.h b/symbol.h
index a16a27c24afe..6b483101548a 100644
--- a/symbol.h
+++ b/symbol.h
@@ -160,7 +160,7 @@ struct symbol {
 			struct token *expansion;
 			struct token *arglist;
 			struct scope *used_in;
-			void (*expander)(struct token *);
+			void (*expand_simple)(struct token *);
 		};
 		struct /* NS_PREPROCESSOR */ {
 			int (*handler)(struct stream *, struct token **, struct token *);
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 2/7] doc: make the sidebar more compact ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/7] doc: make the sidebar more compact
Date: Mon, 10 Aug 2020 21:53:31 +0000
Message-ID: <20200810215336.76070-3-luc.vanoostenryck () gmail ! com>
--------------------
There is generous spacing in the sidebar, too generous.

So, reduce it to something more compact, which will also
allow more entries without scrolling.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/sphinx/static/theme_overrides.css | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/Documentation/sphinx/static/theme_overrides.css b/Documentation/sphinx/static/theme_overrides.css
index 8d6246e4202c..8791046c9013 100644
--- a/Documentation/sphinx/static/theme_overrides.css
+++ b/Documentation/sphinx/static/theme_overrides.css
@@ -1,3 +1,7 @@
+.wy-menu-vertical a, .wy-menu-vertical li.current > a, .wy-menu-vertical p.caption {
+	padding: 0.2em 1.2em;
+}
+
 .wy-side-nav-search > a img.logo {
 	width: 60%;
 }
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 3/3] warn on empty initializations ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] warn on empty initializations
Date: Tue, 14 Jul 2020 00:00:30 +0000
Message-ID: <20200714000030.85886-4-luc.vanoostenryck () gmail ! com>
--------------------
Currently sparse accepts an empty initialization like:
	int a = ;

Make this an error.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                        | 5 ++++-
 validation/empty-initializer.c | 1 -
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/parse.c b/parse.c
index a9222e7cbf08..d0a41b14b914 100644
--- a/parse.c
+++ b/parse.c
@@ -3117,7 +3117,10 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 
 	for (;;) {
 		if (!is_typedef && match_op(token, '=')) {
-			token = initializer(&decl->initializer, token->next);
+			struct token *next = token->next;
+			token = initializer(&decl->initializer, next);
+			if (token == next)
+				sparse_error(token->pos, "expression expected before '%s'", show_token(token));
 		}
 		if (!is_typedef) {
 			if (validate_decl)
diff --git a/validation/empty-initializer.c b/validation/empty-initializer.c
index 0ca763f699a0..950679991401 100644
--- a/validation/empty-initializer.c
+++ b/validation/empty-initializer.c
@@ -2,7 +2,6 @@ static int i = ;		// KO
 
 /*
  * check-name: empty-initializer
- * check-known-to-fail
  *
  * check-error-start
 empty-initializer.c:1:16: error: expression expected before ';'
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 3/4] dissect: change deanon() to handle the !node case ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 3/4] dissect: change deanon() to handle the !node case
Date: Tue, 04 Feb 2020 16:51:42 +0000
Message-ID: <20200204165142.GA24346 () redhat ! com>
--------------------
Change deanon() to always initialize base->ident when parent != NULL
but still return false to avoid the pointless ->r_symdef().

Test-case:

	struct {
		union {
			int x;
		};
	} var = {
		{ .x = 0 },
	};

before this patch:

	1:8   s def  :var
	5:3   g def  var                              struct :var
	5:3   g -w-  var                              struct :var
	6:12  s -w-  ?.x                              int

after:

	1:8   s def  :var
	5:3   g def  var                              struct :var
	5:3   g -w-  var                              struct :var
	6:12  s -w-  :var.x                           int

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dissect.c b/dissect.c
index d34b38a..57dcdb2 100644
--- a/dissect.c
+++ b/dissect.c
@@ -195,8 +195,10 @@ static bool deanon(struct symbol *base, struct ident *node, struct symbol *paren
 	struct ident *pi = parent ? parent->ident : NULL;
 	char name[256];
 
-	if (!node)
+	if (!node) {
+		base->ident = pi;
 		return false;
+	}
 
 	snprintf(name, sizeof(name), "%.*s:%.*s",
 		pi ? pi->len : 0, pi ? pi->name : NULL, node->len, node->name);
-- 
2.5.0

================================================================================


################################################################################

=== Thread: [PATCH 3/5] gensel: controlling expression must be lvalue converted ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/5] gensel: controlling expression must be lvalue converted
Date: Fri, 19 Jun 2020 15:02:58 +0000
Message-ID: <20200619150300.63695-4-luc.vanoostenryck () gmail ! com>
--------------------
Following the resolution of DR481, the controlling expression
of a generic selection must be lvalue converted. In other words,
the qualifiers must be ignored.

Reported-by: Marco Elver <elver@google.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index cf40eed418b4..d8615a894c0d 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3287,17 +3287,20 @@ static struct symbol *evaluate_generic_selection(struct expression *expr)
 {
 	struct type_expression *map;
 	struct expression *res;
+	struct symbol source;
 	struct symbol *ctrl;
 
 	if (!(ctrl = evaluate_expression(expr->control)))
 		return NULL;
 
+	source = *ctrl;
+	source.ctype.modifiers &= ~(MOD_QUALIFIER|MOD_ATOMIC);
 	for (map = expr->map; map; map = map->next) {
 		struct symbol *stype = map->type;
 
 		if (!evaluate_symbol(stype))
 			continue;
-		if (!type_selection(ctrl, stype))
+		if (!type_selection(&source, stype))
 			continue;
 
 		res = map->expr;
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 3/5] pre-process: add support for builtin macros ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/5] pre-process: add support for builtin macros
Date: Thu, 18 Jun 2020 20:47:14 +0000
Message-ID: <20200618204716.3896-4-luc.vanoostenryck () gmail ! com>
--------------------
Sparse support the expansion of one-symbol-builtin macros like __FILE__.
It also support builtin macros with an argument, like 'defined()'
or '__has_attribute()'.

However, these last one are only expanded inside a pre-processor
conditional expression. This is correct for 'defined()' but macros
like '__has_attribute()' should be expanded in all contexts,
like user defined macros.

So, add support for the general expansion of such macros.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 pre-process.c | 34 ++++++++++++++++++++++++++++++++++
 symbol.h      |  2 ++
 2 files changed, 36 insertions(+)

diff --git a/pre-process.c b/pre-process.c
index 059a7c1d9b7b..d2e13400711e 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -777,6 +777,9 @@ static int expand(struct token **list, struct symbol *sym)
 		expand_arguments(nargs, args);
 	}
 
+	if (sym->expand)
+		return sym->expand(token, args) ? 0 : 1;
+
 	expanding->tainted = 1;
 
 	last = token->next;
@@ -2000,6 +2003,34 @@ static int handle_nondirective(struct stream *stream, struct token **line, struc
 	return 1;
 }
 
+static void create_arglist(struct symbol *sym, int count)
+{
+	struct token *token;
+	struct token **next;
+
+	if (!count)
+		return;
+
+	token = __alloc_token(0);
+	token_type(token) = TOKEN_ARG_COUNT;
+	token->count.normal = count;
+	sym->arglist = token;
+	next = &token->next;
+
+	while (count--) {
+		struct token *id, *uses;
+		id = __alloc_token(0);
+		token_type(id) = TOKEN_IDENT;
+		uses = __alloc_token(0);
+		token_type(uses) = TOKEN_ARG_COUNT;
+		uses->count.normal = 1;
+
+		*next = id;
+		id->next = uses;
+		next = &uses->next;
+	}
+	*next = &eof_token_entry;
+}
 
 static void init_preprocessor(void)
 {
@@ -2041,6 +2072,7 @@ static void init_preprocessor(void)
 	static struct {
 		const char *name;
 		void (*expand_simple)(struct token *);
+		bool (*expand)(struct token *, struct arg *args);
 	} dynamic[] = {
 		{ "__LINE__",		expand_line },
 		{ "__FILE__",		expand_file },
@@ -2067,6 +2099,8 @@ static void init_preprocessor(void)
 		struct symbol *sym;
 		sym = create_symbol(stream, dynamic[i].name, SYM_NODE, NS_MACRO);
 		sym->expand_simple = dynamic[i].expand_simple;
+		if ((sym->expand = dynamic[i].expand) != NULL)
+			create_arglist(sym, 1);
 	}
 
 	counter_macro = 0;
diff --git a/symbol.h b/symbol.h
index 6b483101548a..e256322e83a2 100644
--- a/symbol.h
+++ b/symbol.h
@@ -114,6 +114,7 @@ struct decl_state {
 
 struct pseudo;
 struct entrypoint;
+struct arg;
 
 struct symbol_op {
 	enum keyword type;
@@ -161,6 +162,7 @@ struct symbol {
 			struct token *arglist;
 			struct scope *used_in;
 			void (*expand_simple)(struct token *);
+			bool (*expand)(struct token *, struct arg *args);
 		};
 		struct /* NS_PREPROCESSOR */ {
 			int (*handler)(struct stream *, struct token **, struct token *);
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 3/6] add testcases for C99 array declarators ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/6] add testcases for C99 array declarators
Date: Thu, 23 Jul 2020 23:46:38 +0000
Message-ID: <20200723234641.78462-4-luc.vanoostenryck () gmail ! com>
--------------------
C99 introduced some funky new array declarators, those with
'restrict' or 'static' inside the brackets.

Add some testcases for them.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/abstract-array-declarator-quals.c | 22 ++++++++++++++++++++
 validation/abstract-array-declarator-star.c  |  9 ++++++++
 2 files changed, 31 insertions(+)
 create mode 100644 validation/abstract-array-declarator-quals.c
 create mode 100644 validation/abstract-array-declarator-star.c

diff --git a/validation/abstract-array-declarator-quals.c b/validation/abstract-array-declarator-quals.c
new file mode 100644
index 000000000000..85a35a2aca7c
--- /dev/null
+++ b/validation/abstract-array-declarator-quals.c
@@ -0,0 +1,22 @@
+#define N 2
+
+void ok1(int []);
+void ok2(int [N]);
+void ok3(int [const volatile restrict]);
+void ok4(int [const volatile restrict N]);
+void ok5(int [static N]);
+void ok6(int [static const volatile restrict N]);
+void ok7(int [const volatile restrict static N]);
+
+void ok1(int a[]);
+void ok2(int a[N]);
+void ok3(int a[const volatile restrict]);
+void ok4(int a[const volatile restrict N]);
+void ok5(int a[static N]);
+void ok6(int a[static const volatile restrict N]);
+void ok7(int a[const volatile restrict static N]);
+
+/*
+ * check-name: abstract-array-declarator-quals
+ * check-known-to-fail
+ */
diff --git a/validation/abstract-array-declarator-star.c b/validation/abstract-array-declarator-star.c
new file mode 100644
index 000000000000..fdbdff19840d
--- /dev/null
+++ b/validation/abstract-array-declarator-star.c
@@ -0,0 +1,9 @@
+void ok8(int [*]);
+
+void ok8(int a[*]);
+void ok9(int a[const volatile restrict *]);
+
+/*
+ * check-name: abstract-array-declarator-star
+ * check-known-to-fail
+ */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 3/7] doc: decrease vertical spacing ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/7] doc: decrease vertical spacing
Date: Mon, 10 Aug 2020 21:53:32 +0000
Message-ID: <20200810215336.76070-4-luc.vanoostenryck () gmail ! com>
--------------------
The vertical spacing in the generated HTML is a bit excessive
to my taste. So decrease it somehow, especially the top of lists.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/sphinx/static/theme_overrides.css | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/Documentation/sphinx/static/theme_overrides.css b/Documentation/sphinx/static/theme_overrides.css
index 8791046c9013..3e4bc3b0223a 100644
--- a/Documentation/sphinx/static/theme_overrides.css
+++ b/Documentation/sphinx/static/theme_overrides.css
@@ -1,3 +1,16 @@
+p {
+	margin-bottom: 0.6em;
+}
+
+ul.simple {
+	margin-top: -0.5em;
+	margin-bottom: 0.5em;
+}
+
+.rst-content .toctree-wrapper ul {
+	margin-bottom: 0.5em;
+}
+
 .wy-menu-vertical a, .wy-menu-vertical li.current > a, .wy-menu-vertical p.caption {
 	padding: 0.2em 1.2em;
 }
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 4/4] bad-shift: wait dead code elimination to warn about bad shifts ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/4] bad-shift: wait dead code elimination to warn about bad shifts
Date: Thu, 06 Aug 2020 19:30:03 +0000
Message-ID: <20200806193003.10144-5-luc.vanoostenryck () gmail ! com>
--------------------
Sparse complains when a shift amount is too big for the size
of its operand or if it's negative.

However, it does this even for expressions that are never evaluated.
It's especially annoying in the kernel for type generic macros,
for example the ones in arch/*/include/asm/cmpxchg.h

So, remove all warnings done at expansion time and avoid any
simplifications of such expressions. Same, at linearization
and optimization time but in this case mark the instructions as
'tainted' to inhibit any further simplifications. Finally, at the
end of the optimization phase, warn for the tainted instructions.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expand.c                      | 18 -------------
 linearize.c                   | 44 ++++++++++++++++++++++++++++++++
 simplify.c                    | 20 ++++-----------
 validation/expand/bad-shift.c |  8 +++---
 validation/optim/shift-big.c  | 12 ++++++---
 validation/shift-negative.c   |  4 +--
 validation/shift-undef-long.c |  7 +++--
 validation/shift-undef.c      | 48 +++++++++--------------------------
 8 files changed, 78 insertions(+), 83 deletions(-)

diff --git a/expand.c b/expand.c
index b07893318382..623b180025ad 100644
--- a/expand.c
+++ b/expand.c
@@ -170,22 +170,6 @@ Float:
 	expr->type = EXPR_FVALUE;
 }
 
-static void warn_shift_count(struct expression *expr, struct symbol *ctype, long long count)
-{
-	if (count < 0) {
-		if (!Wshift_count_negative)
-			return;
-		warning(expr->pos, "shift count is negative (%lld)", count);
-		return;
-	}
-	if (ctype->type == SYM_NODE)
-		ctype = ctype->ctype.base_type;
-
-	if (!Wshift_count_overflow)
-		return;
-	warning(expr->pos, "shift too big (%llu) for type %s", count, show_typename(ctype));
-}
-
 /* Return true if constant shift size is valid */
 static bool check_shift_count(struct expression *expr, struct expression *right)
 {
@@ -194,8 +178,6 @@ static bool check_shift_count(struct expression *expr, struct expression *right)
 
 	if (count >= 0 && count < ctype->bit_size)
 		return true;
-	if (!conservative)
-		warn_shift_count(expr, ctype, count);
 	return false;
 }
 
diff --git a/linearize.c b/linearize.c
index 4927468183b0..5a8e74970d98 100644
--- a/linearize.c
+++ b/linearize.c
@@ -2468,6 +2468,49 @@ static pseudo_t linearize_statement(struct entrypoint *ep, struct statement *stm
 	return VOID;
 }
 
+static void check_tainted_insn(struct instruction *insn)
+{
+	unsigned long long uval;
+	long long sval;
+	pseudo_t src2;
+
+	switch (insn->opcode) {
+	case OP_DIVU: case OP_DIVS:
+	case OP_MODU: case OP_MODS:
+		if (insn->src2 == value_pseudo(0))
+			warning(insn->pos, "divide by zero");
+		break;
+	case OP_SHL: case OP_LSR: case OP_ASR:
+		src2 = insn->src2;
+		if (src2->type != PSEUDO_VAL)
+			break;
+		uval = src2->value;
+		if (uval < insn->size)
+			break;
+		sval = sign_extend(uval, insn->size);
+		if (Wshift_count_negative && sval < 0)
+			warning(insn->pos, "shift count is negative (%lld)", sval);
+		else if (Wshift_count_overflow)
+			warning(insn->pos, "shift too big (%llu) for type %s", uval, show_typename(insn->type));
+	}
+}
+
+///
+// issue warnings after all possible DCE
+static void late_warnings(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+	FOR_EACH_PTR(ep->bbs, bb) {
+		struct instruction *insn;
+		FOR_EACH_PTR(bb->insns, insn) {
+			if (!insn->bb)
+				continue;
+			if (insn->tainted)
+				check_tainted_insn(insn);
+		} END_FOR_EACH_PTR(insn);
+	} END_FOR_EACH_PTR(bb);
+}
+
 static struct entrypoint *linearize_fn(struct symbol *sym, struct symbol *base_type)
 {
 	struct statement *stmt = base_type->stmt;
@@ -2514,6 +2557,7 @@ static struct entrypoint *linearize_fn(struct symbol *sym, struct symbol *base_t
 	add_one_insn(ep, ret);
 
 	optimize(ep);
+	late_warnings(ep);
 	return ep;
 }
 
diff --git a/simplify.c b/simplify.c
index 7850bcdc6069..f6b79685f439 100644
--- a/simplify.c
+++ b/simplify.c
@@ -754,28 +754,18 @@ static long long check_shift_count(struct instruction *insn, unsigned long long
 	unsigned int size = insn->size;
 	long long sval = uval;
 
+	if (insn->tainted)
+		return -1;
+
 	if (uval < size)
 		return uval;
 
+	insn->tainted = 1;
 	sval = sign_extend_safe(sval, size);
 	sval = sign_extend_safe(sval, bits_in_int);
 	if (sval < 0)
 		insn->src2 = value_pseudo(sval);
-	if (insn->tainted)
-		return sval;
-
-	if (sval < 0 && Wshift_count_negative)
-		warning(insn->pos, "shift count is negative (%lld)", sval);
-	if (sval > 0 && Wshift_count_overflow) {
-		struct symbol *ctype = insn->type;
-		const char *tname;
-		if (ctype->type == SYM_NODE)
-			ctype = ctype->ctype.base_type;
-		tname = show_typename(ctype);
-		warning(insn->pos, "shift too big (%llu) for type %s", sval, tname);
-	}
-	insn->tainted = 1;
-	return sval;
+	return -1;
 }
 
 static int simplify_shift(struct instruction *insn, pseudo_t pseudo, long long value)
diff --git a/validation/expand/bad-shift.c b/validation/expand/bad-shift.c
index 22c4341f1680..b68866c2b048 100644
--- a/validation/expand/bad-shift.c
+++ b/validation/expand/bad-shift.c
@@ -56,9 +56,9 @@ rneg:
  * check-output-end
  *
  * check-error-start
-expand/bad-shift.c:5:18: warning: shift too big (32) for type int
-expand/bad-shift.c:10:18: warning: shift count is negative (-1)
-expand/bad-shift.c:15:18: warning: shift too big (32) for type int
-expand/bad-shift.c:20:18: warning: shift count is negative (-1)
+expand/bad-shift.c:5:21: warning: shift too big (32) for type int
+expand/bad-shift.c:10:21: warning: shift count is negative (-1)
+expand/bad-shift.c:15:21: warning: shift too big (32) for type int
+expand/bad-shift.c:20:21: warning: shift count is negative (-1)
  * check-error-end
  */
diff --git a/validation/optim/shift-big.c b/validation/optim/shift-big.c
index 84bcd2ce01a3..e7bf22fe36ff 100644
--- a/validation/optim/shift-big.c
+++ b/validation/optim/shift-big.c
@@ -50,13 +50,15 @@ lsr31:
 lsr32:
 .L8:
 	<entry-point>
-	ret.32      $0
+	lsr.32      %r14 <- %arg1, $32
+	ret.32      %r14
 
 
 lsr33:
 .L10:
 	<entry-point>
-	ret.32      $0
+	lsr.32      %r17 <- %arg1, $33
+	ret.32      %r17
 
 
 shl31:
@@ -69,13 +71,15 @@ shl31:
 shl32:
 .L14:
 	<entry-point>
-	ret.32      $0
+	shl.32      %r23 <- %arg1, $32
+	ret.32      %r23
 
 
 shl33:
 .L16:
 	<entry-point>
-	ret.32      $0
+	shl.32      %r26 <- %arg1, $33
+	ret.32      %r26
 
 
  * check-output-end
diff --git a/validation/shift-negative.c b/validation/shift-negative.c
index fff5cf123dd6..6df02b18468f 100644
--- a/validation/shift-negative.c
+++ b/validation/shift-negative.c
@@ -9,8 +9,8 @@ unsigned int fo2(unsigned int a) { return a >> ((a & 0) ^ ~0); }
  * check-command: sparse -Wno-decl $file
  *
  * check-error-start
-shift-negative.c:1:45: warning: shift count is negative (-1)
-shift-negative.c:2:45: warning: shift count is negative (-1)
+shift-negative.c:1:48: warning: shift count is negative (-1)
+shift-negative.c:2:48: warning: shift count is negative (-1)
 shift-negative.c:4:59: warning: shift count is negative (-1)
 shift-negative.c:5:59: warning: shift count is negative (-1)
  * check-error-end
diff --git a/validation/shift-undef-long.c b/validation/shift-undef-long.c
index 326267436ec7..985fe4c4c595 100644
--- a/validation/shift-undef-long.c
+++ b/validation/shift-undef-long.c
@@ -13,9 +13,8 @@ static unsigned very_big_shift(unsigned int a)
  * check-command: sparse -m64 $file
  *
  * check-error-start
-shift-undef-long.c:4:16: warning: shift too big (4294967295) for type unsigned int
-shift-undef-long.c:5:16: warning: shift too big (4294967296) for type unsigned int
-shift-undef-long.c:6:16: warning: shift too big (4294967296) for type unsigned int
-shift-undef-long.c:7:16: warning: shift count is negative (-4294967296)
+shift-undef-long.c:4:25: warning: shift count is negative (-1)
+shift-undef-long.c:5:47: warning: shift too big (4294967296) for type unsigned int
+shift-undef-long.c:7:20: warning: shift count is negative (-4294967296)
  * check-error-end
  */
diff --git a/validation/shift-undef.c b/validation/shift-undef.c
index 613c6b95b113..0c7541e9ffd9 100644
--- a/validation/shift-undef.c
+++ b/validation/shift-undef.c
@@ -112,48 +112,24 @@ void hw_write(u32 val)
  * check-command: sparse -Wno-decl $file
  *
  * check-error-start
-shift-undef.c:3:15: warning: shift too big (100) for type int
-shift-undef.c:4:15: warning: shift too big (101) for type unsigned int
-shift-undef.c:5:15: warning: shift too big (102) for type unsigned int
-shift-undef.c:6:15: warning: shift count is negative (-1)
-shift-undef.c:7:15: warning: shift count is negative (-2)
-shift-undef.c:8:15: warning: shift count is negative (-3)
-shift-undef.c:9:25: warning: shift too big (103) for type int
-shift-undef.c:10:25: warning: shift too big (104) for type unsigned int
-shift-undef.c:11:25: warning: shift too big (105) for type unsigned int
-shift-undef.c:12:25: warning: shift count is negative (-4)
-shift-undef.c:13:25: warning: shift count is negative (-5)
-shift-undef.c:14:25: warning: shift count is negative (-6)
-shift-undef.c:15:30: warning: shift too big (106) for type int
-shift-undef.c:16:30: warning: shift too big (107) for type unsigned int
-shift-undef.c:17:30: warning: shift too big (108) for type unsigned int
-shift-undef.c:18:30: warning: shift count is negative (-7)
-shift-undef.c:19:30: warning: shift count is negative (-8)
-shift-undef.c:20:30: warning: shift count is negative (-9)
+shift-undef.c:3:18: warning: shift too big (100) for type int
+shift-undef.c:4:18: warning: shift too big (101) for type unsigned int
+shift-undef.c:5:18: warning: shift too big (102) for type unsigned int
+shift-undef.c:6:19: warning: shift count is negative (-1)
+shift-undef.c:7:19: warning: shift count is negative (-2)
+shift-undef.c:8:19: warning: shift count is negative (-3)
 shift-undef.c:21:29: warning: shift too big (109) for type int
 shift-undef.c:22:29: warning: shift too big (110) for type unsigned int
 shift-undef.c:23:29: warning: shift too big (111) for type unsigned int
 shift-undef.c:24:29: warning: shift count is negative (-10)
 shift-undef.c:25:29: warning: shift count is negative (-11)
 shift-undef.c:26:29: warning: shift count is negative (-12)
-shift-undef.c:32:11: warning: shift too big (100) for type int
-shift-undef.c:33:11: warning: shift too big (101) for type unsigned int
-shift-undef.c:34:11: warning: shift too big (102) for type unsigned int
-shift-undef.c:35:11: warning: shift count is negative (-1)
-shift-undef.c:36:11: warning: shift too big (4294967294) for type unsigned int
-shift-undef.c:37:11: warning: shift too big (4294967293) for type unsigned int
-shift-undef.c:38:25: warning: shift too big (103) for type int
-shift-undef.c:39:25: warning: shift too big (104) for type unsigned int
-shift-undef.c:40:25: warning: shift too big (105) for type unsigned int
-shift-undef.c:41:25: warning: shift count is negative (-4)
-shift-undef.c:42:25: warning: shift too big (4294967291) for type unsigned int
-shift-undef.c:43:25: warning: shift too big (4294967290) for type unsigned int
-shift-undef.c:44:30: warning: shift too big (106) for type int
-shift-undef.c:45:30: warning: shift too big (107) for type unsigned int
-shift-undef.c:46:30: warning: shift too big (108) for type unsigned int
-shift-undef.c:47:30: warning: shift count is negative (-7)
-shift-undef.c:48:30: warning: shift too big (4294967288) for type unsigned int
-shift-undef.c:49:30: warning: shift too big (4294967287) for type unsigned int
+shift-undef.c:32:15: warning: shift too big (100) for type int
+shift-undef.c:33:15: warning: shift too big (101) for type unsigned int
+shift-undef.c:34:15: warning: shift too big (102) for type unsigned int
+shift-undef.c:35:16: warning: shift count is negative (-1)
+shift-undef.c:36:16: warning: shift count is negative (-2)
+shift-undef.c:37:16: warning: shift count is negative (-3)
 shift-undef.c:50:26: warning: shift too big (109) for type int
 shift-undef.c:51:26: warning: shift too big (110) for type unsigned int
 shift-undef.c:52:26: warning: shift too big (111) for type unsigned int
-- 
2.28.0

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 4/4] bad-shift: wait dead code elimination to warn about bad shifts
Date: Sat, 15 Aug 2020 11:15:40 +0000
Message-ID: <20200815111540.nxdsfzurv555qpap () ltop ! local>
--------------------
On Sat, Aug 15, 2020 at 06:57:03PM +0900, Stafford Horne wrote:
> On Thu, Aug 06, 2020 at 09:30:03PM +0200, Luc Van Oostenryck wrote:
> > --- a/linearize.c
> > +++ b/linearize.c
> > @@ -2468,6 +2468,49 @@ static pseudo_t linearize_statement(struct entrypoint *ep, struct statement *stm
> >  	return VOID;
> >  }
> >  
> > +static void check_tainted_insn(struct instruction *insn)
> > +{
> > +	unsigned long long uval;
> > +	long long sval;
> > +	pseudo_t src2;
> > +
> > +	switch (insn->opcode) {
> > +	case OP_DIVU: case OP_DIVS:
> > +	case OP_MODU: case OP_MODS:
> > +		if (insn->src2 == value_pseudo(0))
> > +			warning(insn->pos, "divide by zero");
> > +		break;
> 
> Is this divide by zero a new check?  I get the shift, but is this new?

Yes, and no. The warning is already given (using 'division by zero')
but, like for shifts before this series, issued early, before dead code
elimination is done. So, code like the following:
	...
	if (d != 0)
		r = a / d;
	...
issues the warning nevertheless. So, the check here above is now unused
but is a preparation for the part 2 doing the same for division by zero
by zero.

Best regards,
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH 4/4] dissect: disallow NULL pointers in struct reporter ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH 4/4] dissect: disallow NULL pointers in struct reporter
Date: Tue, 04 Feb 2020 16:51:44 +0000
Message-ID: <20200204165144.GA24349 () redhat ! com>
--------------------
This makes dissect.c a bit more readable.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 24 +++++++-----------------
 1 file changed, 7 insertions(+), 17 deletions(-)

diff --git a/dissect.c b/dissect.c
index 57dcdb2..88eaab1 100644
--- a/dissect.c
+++ b/dissect.c
@@ -135,7 +135,7 @@ static struct symbol *report_member(usage_t mode, struct position *pos,
 {
 	struct symbol *ret = mem->ctype.base_type;
 
-	if (mem->ident && reporter->r_member)
+	if (mem->ident)
 		reporter->r_member(fix_mode(ret, mode), pos, type, mem);
 
 	return ret;
@@ -146,9 +146,6 @@ static void report_implicit(usage_t mode, struct position *pos, struct symbol *t
 	if (type->type != SYM_STRUCT && type->type != SYM_UNION)
 		return;
 
-	if (!reporter->r_member)
-		return;
-
 	if (type->ident != NULL)
 		reporter->r_member(mode, pos, type, NULL);
 
@@ -184,8 +181,7 @@ static struct symbol *report_symbol(usage_t mode, struct expression *expr)
 	if (0 && ret->type == SYM_ENUM)
 		return report_member(mode, &expr->pos, ret, expr->symbol);
 
-	if (reporter->r_symbol)
-		reporter->r_symbol(fix_mode(ret, mode), &expr->pos, sym);
+	reporter->r_symbol(fix_mode(ret, mode), &expr->pos, sym);
 
 	return ret;
 }
@@ -238,10 +234,8 @@ static void examine_sym_node(struct symbol *node, struct symbol *parent)
 				return;
 			base->evaluated = 1;
 
-			if (base->ident || deanon(base, name, parent)) {
-				if (reporter->r_symdef)
-					reporter->r_symdef(base);
-			}
+			if (base->ident || deanon(base, name, parent))
+				reporter->r_symdef(base);
 			DO_LIST(base->symbol_list, mem,
 				examine_sym_node(mem, base->ident ? base : parent));
 		default:
@@ -577,19 +571,15 @@ static struct symbol *do_initializer(struct symbol *type, struct expression *exp
 
 static inline struct symbol *do_symbol(struct symbol *sym)
 {
-	struct symbol *type;
-
-	type = base_type(sym);
+	struct symbol *type = base_type(sym);
 
-	if (reporter->r_symdef)
-		reporter->r_symdef(sym);
+	reporter->r_symdef(sym);
 
 	switch (type->type) {
 	default:
 		if (!sym->initializer)
 			break;
-		if (reporter->r_symbol)
-			reporter->r_symbol(U_W_VAL, &sym->pos, sym);
+		reporter->r_symbol(U_W_VAL, &sym->pos, sym);
 		do_initializer(type, sym->initializer);
 
 	break; case SYM_FN:
-- 
2.5.0

================================================================================


################################################################################

=== Thread: [PATCH 4/5] add support for linearization of builtins ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/5] add support for linearization of builtins
Date: Wed, 18 Mar 2020 17:31:19 +0000
Message-ID: <20200318173120.63939-5-luc.vanoostenryck () gmail ! com>
--------------------
Sparse ignores most builtins. A few of them are directly
interpreted at parsing time (types_compatible_p, offsetof).
Some others are expanded if their argument(s) are constant
but that's all.

However, some of the builtins are significant at the IR
level and shouldn't thus be ignored.

This patch add the support needed for the linearization of
these builtins.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 builtin.c   |  2 ++
 linearize.c | 32 ++++++++++++++++++++++++++++++++
 symbol.h    |  7 ++++++-
 3 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/builtin.c b/builtin.c
index 52285a91cd1e..debc22c036ec 100644
--- a/builtin.c
+++ b/builtin.c
@@ -418,6 +418,8 @@ void init_builtins(int stream)
 		sym->op = ptr->op;
 		sym->builtin = 1;
 	}
+
+	init_linearized_builtins(stream);
 }
 
 static void declare_builtin(const char *name, struct symbol *rtype, int variadic, ...)
diff --git a/linearize.c b/linearize.c
index 19c284c4a456..25d6327bf6f1 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1509,6 +1509,11 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 
 	fn = expr->fn;
 	fntype = fn->ctype;
+
+	// handle builtins
+	if (fntype->op && fntype->op->linearize)
+		return fntype->op->linearize(ep, expr);
+
 	ctype = &fntype->ctype;
 	if (fntype->type == SYM_NODE)
 		fntype = fntype->ctype.base_type;
@@ -2526,3 +2531,30 @@ struct entrypoint *linearize_symbol(struct symbol *sym)
 		return linearize_fn(sym, base_type);
 	return NULL;
 }
+
+/*
+ * Builtin functions
+ */
+
+static struct sym_init {
+	const char *name;
+	pseudo_t (*linearize)(struct entrypoint *, struct expression*);
+	struct symbol_op op;
+} builtins_table[] = {
+	// must be declared in builtin.c:declare_builtins[]
+	{ }
+};
+
+void init_linearized_builtins(int stream)
+{
+	struct sym_init *ptr;
+
+	for (ptr = builtins_table; ptr->name; ptr++) {
+		struct symbol *sym;
+		sym = create_symbol(stream, ptr->name, SYM_NODE, NS_SYMBOL);
+		if (!sym->op)
+			sym->op = &ptr->op;
+		sym->op->type |= KW_BUILTIN;
+		ptr->op.linearize = ptr->linearize;
+	}
+}
diff --git a/symbol.h b/symbol.h
index 9ef5a886172f..270ae098cacf 100644
--- a/symbol.h
+++ b/symbol.h
@@ -78,7 +78,7 @@ enum keyword {
 	KW_MODIFIER	= 1 << 1,
 	KW_QUALIFIER	= 1 << 2,
 	KW_ATTRIBUTE	= 1 << 3,
-     // KW UNUSED	= 1 << 4,
+	KW_BUILTIN	= 1 << 4,
 	KW_ASM		= 1 << 5,
 	KW_MODE		= 1 << 6,
      // KW UNUSED	= 1 << 7,
@@ -112,11 +112,15 @@ struct decl_state {
 	unsigned char is_ext_visible;
 };
 
+struct pseudo;
+struct entrypoint;
+
 struct symbol_op {
 	enum keyword type;
 	int (*evaluate)(struct expression *);
 	int (*expand)(struct expression *, int);
 	int (*args)(struct expression *);
+	struct pseudo *(*linearize)(struct entrypoint *, struct expression *);
 
 	/* keywords */
 	struct token *(*declarator)(struct token *token, struct decl_state *ctx);
@@ -308,6 +312,7 @@ extern struct symbol *lookup_symbol(struct ident *, enum namespace);
 extern struct symbol *create_symbol(int stream, const char *name, int type, int namespace);
 extern void init_symbols(void);
 extern void init_builtins(int stream);
+extern void init_linearized_builtins(int stream);
 extern void declare_builtins(void);
 extern void init_ctype(void);
 extern struct symbol *alloc_symbol(struct position, int type);
-- 
2.25.1

================================================================================


################################################################################

=== Thread: [PATCH 4/5] pre-process: add support for __has_feature() & __has_extension() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/5] pre-process: add support for __has_feature() & __has_extension()
Date: Thu, 18 Jun 2020 20:47:15 +0000
Message-ID: <20200618204716.3896-5-luc.vanoostenryck () gmail ! com>
--------------------
Add the trivial methods for the expansion of these macros with:
c_alignas, c_alignof, c_generic_selections and c_static_assert.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 ident-list.h                          |  4 ++
 pre-process.c                         | 54 +++++++++++++++++++++++++++
 validation/preprocessor/has-feature.c |  1 -
 3 files changed, 58 insertions(+), 1 deletion(-)

diff --git a/ident-list.h b/ident-list.h
index 75740b9d9f77..a3a282587c67 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -61,6 +61,10 @@ IDENT(defined);
 IDENT(once);
 IDENT(__has_attribute);
 IDENT(__has_builtin);
+IDENT(c_alignas);
+IDENT(c_alignof);
+IDENT(c_generic_selections);
+IDENT(c_static_assert);
 __IDENT(pragma_ident, "__pragma__", 0);
 __IDENT(__VA_ARGS___ident, "__VA_ARGS__", 0);
 __IDENT(__func___ident, "__func__", 0);
diff --git a/pre-process.c b/pre-process.c
index d2e13400711e..7a39b1715f31 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -2003,6 +2003,58 @@ static int handle_nondirective(struct stream *stream, struct token **line, struc
 	return 1;
 }
 
+static bool expand_has_extension(struct token *token, struct arg *args)
+{
+	struct token *arg = args[0].expanded;
+	struct ident *ident;
+	bool val = false;
+
+	if (token_type(arg) != TOKEN_IDENT) {
+		sparse_error(arg->pos, "identifier expected");
+		return false;
+	}
+
+	ident = arg->ident;
+	if (ident == &c_alignas_ident)
+		val = true;
+	else if (ident == &c_alignof_ident)
+		val = true;
+	else if (ident == &c_generic_selections_ident)
+		val = true;
+	else if (ident == &c_static_assert_ident)
+		val = true;
+
+	replace_with_bool(token, val);
+	return 1;
+}
+
+static bool expand_has_feature(struct token *token, struct arg *args)
+{
+	struct token *arg = args[0].expanded;
+	struct ident *ident;
+	bool val = false;
+
+	if (token_type(arg) != TOKEN_IDENT) {
+		sparse_error(arg->pos, "identifier expected");
+		return false;
+	}
+
+	ident = arg->ident;
+	if (standard >= STANDARD_C11) {
+		if (ident == &c_alignas_ident)
+			val = true;
+		else if (ident == &c_alignof_ident)
+			val = true;
+		else if (ident == &c_generic_selections_ident)
+			val = true;
+		else if (ident == &c_static_assert_ident)
+			val = true;
+	}
+
+	replace_with_bool(token, val);
+	return 1;
+}
+
 static void create_arglist(struct symbol *sym, int count)
 {
 	struct token *token;
@@ -2081,6 +2133,8 @@ static void init_preprocessor(void)
 		{ "__TIME__",		expand_time },
 		{ "__COUNTER__",	expand_counter },
 		{ "__INCLUDE_LEVEL__",	expand_include_level },
+		{ "__has_extension",	NULL, expand_has_extension },
+		{ "__has_feature",	NULL, expand_has_feature },
 	};
 
 	for (i = 0; i < ARRAY_SIZE(normal); i++) {
diff --git a/validation/preprocessor/has-feature.c b/validation/preprocessor/has-feature.c
index 3ab7c3e039fa..e0f2e7f63cda 100644
--- a/validation/preprocessor/has-feature.c
+++ b/validation/preprocessor/has-feature.c
@@ -12,7 +12,6 @@ __has_feature()??? Quesako?
 /*
  * check-name: has-feature
  * check-command: sparse -E $file
- * check-known-to-fail
  *
  * check-output-start
 
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 4/6] simplify & fix parsing of array declarators ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/6] simplify & fix parsing of array declarators
Date: Thu, 23 Jul 2020 23:46:39 +0000
Message-ID: <20200723234641.78462-5-luc.vanoostenryck () gmail ! com>
--------------------
Any type qualifier is valid inside an abstract-array-declarator
but currently only 'restrict' is accepted. Also the parsing of
this is somehow more complex than needed and done by comparing
the identifiers instead of being driven by the keyword table.

So, simplify & fix the parsing of these declarators by:
1) using the keyword type KW_QUALIFIER to identify all type
   qualifier at once.
2) add a new keyword type just for 'static'
3) folding the helper abstract_array_static_declarator() into
   the main function: abstract_array_declarator().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                                      | 28 +++++++-------------
 symbol.h                                     |  2 +-
 validation/abstract-array-declarator-quals.c |  1 -
 3 files changed, 11 insertions(+), 20 deletions(-)

diff --git a/parse.c b/parse.c
index 182f4ad30b9c..ec69e0c6e9ca 100644
--- a/parse.c
+++ b/parse.c
@@ -171,7 +171,7 @@ static struct symbol_op register_op = {
 };
 
 static struct symbol_op static_op = {
-	.type = KW_MODIFIER,
+	.type = KW_MODIFIER|KW_STATIC,
 	.declarator = static_specifier,
 };
 
@@ -1721,28 +1721,20 @@ static struct token *declaration_specifiers(struct token *token, struct decl_sta
 	return token;
 }
 
-static struct token *abstract_array_static_declarator(struct token *token, int *has_static)
-{
-	while (token->ident == &static_ident) {
-		if (*has_static)
-			sparse_error(token->pos, "duplicate array static declarator");
-
-		*has_static = 1;
-		token = token->next;
-	}
-	return token;
-
-}
-
 static struct token *abstract_array_declarator(struct token *token, struct symbol *sym)
 {
 	struct expression *expr = NULL;
 	int has_static = 0;
 
-	token = abstract_array_static_declarator(token, &has_static);
-
-	if (match_idents(token, &restrict_ident, &__restrict_ident, &__restrict___ident, NULL))
-		token = abstract_array_static_declarator(token->next, &has_static);
+	while (token_type(token) == TOKEN_IDENT) {
+		struct symbol *sym = lookup_keyword(token->ident, NS_TYPEDEF);
+		if (!sym || !(sym->op->type & (KW_STATIC|KW_QUALIFIER)))
+			break;
+		if (has_static && (sym->op->type & KW_STATIC))
+			sparse_error(token->pos, "duplicate array static declarator");
+		has_static |= (sym->op->type & KW_STATIC);
+		token = token->next;
+	}
 	token = assignment_expression(token, &expr);
 	sym->array_size = expr;
 	return token;
diff --git a/symbol.h b/symbol.h
index c2b60ce91c27..147306481c20 100644
--- a/symbol.h
+++ b/symbol.h
@@ -81,7 +81,7 @@ enum keyword {
 	KW_BUILTIN	= 1 << 4,
 	KW_ASM		= 1 << 5,
 	KW_MODE		= 1 << 6,
-     // KW UNUSED	= 1 << 7,
+	KW_STATIC	= 1 << 7,
      // KW UNUSED	= 1 << 8,
 	KW_EXACT	= 1 << 9,
 };
diff --git a/validation/abstract-array-declarator-quals.c b/validation/abstract-array-declarator-quals.c
index 85a35a2aca7c..e69df902b895 100644
--- a/validation/abstract-array-declarator-quals.c
+++ b/validation/abstract-array-declarator-quals.c
@@ -18,5 +18,4 @@ void ok7(int a[const volatile restrict static N]);
 
 /*
  * check-name: abstract-array-declarator-quals
- * check-known-to-fail
  */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 4/7] doc: move down info about tarballs, after git repositories ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/7] doc: move down info about tarballs, after git repositories
Date: Mon, 10 Aug 2020 21:53:33 +0000
Message-ID: <20200810215336.76070-5-luc.vanoostenryck () gmail ! com>
--------------------
Better to have the information about the GIT repositories
first because I'm not sure if anyone still use the tarballs.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/index.rst | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/Documentation/index.rst b/Documentation/index.rst
index 4047343a5a75..321a947ec9c5 100644
--- a/Documentation/index.rst
+++ b/Documentation/index.rst
@@ -25,9 +25,6 @@ by Christopher Li in 2009 and by Luc Van Oostenryck in late 2018.
 Getting Sparse
 --------------
 
-You can find tarballs of released versions of Sparse at
-https://www.kernel.org/pub/software/devel/sparse/dist/.
-
 The most recent version can be obtained directly from the Git
 repository with the command::
 
@@ -35,6 +32,8 @@ repository with the command::
 
 You can also `browse the Git repository <https://git.kernel.org/pub/scm/devel/sparse/sparse.git>`_
 or use the mirror at https://github.com/lucvoo/sparse.
+The tarballs of released versions of Sparse and their signatures can be found at
+https://www.kernel.org/pub/software/devel/sparse/dist/.
 
 Once you have the sources, to build Sparse and install it in your ~/bin
 directory, just do::
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 4/9] unop: simplify -(x - y) --> y - x ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/9] unop: simplify -(x - y) --> y - x
Date: Fri, 23 Oct 2020 16:39:34 +0000
Message-ID: <20201023163939.58359-5-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                          | 4 ++++
 validation/optim/simplify-neg-sub.c | 1 -
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index 85c8d1d1df1c..fd486172e6e8 100644
--- a/simplify.c
+++ b/simplify.c
@@ -1478,6 +1478,10 @@ static int simplify_unop(struct instruction *insn)
 			return replace_pseudo(insn, &insn->src1, src);
 		case OP_NEG:		// -(-x) --> x
 			return replace_with_pseudo(insn, def->src);
+		case OP_SUB:		// -(x - y) --> y - x
+			insn->opcode = OP_SUB;
+			use_pseudo(insn, def->src1, &insn->src2);
+			return replace_pseudo(insn, &insn->src1, def->src2);
 		}
 		break;
 	default:
diff --git a/validation/optim/simplify-neg-sub.c b/validation/optim/simplify-neg-sub.c
index b73c9e5e66b4..9a824f09c1db 100644
--- a/validation/optim/simplify-neg-sub.c
+++ b/validation/optim/simplify-neg-sub.c
@@ -3,7 +3,6 @@ int foo(int x, int y) { return -(x - y) == (y - x); }
 /*
  * check-name: simplify-neg-sub
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-contains: ret\\..*\\$1
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 5/5] gensel: validate the type of the associations ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/5] gensel: validate the type of the associations
Date: Fri, 19 Jun 2020 15:03:00 +0000
Message-ID: <20200619150300.63695-6-luc.vanoostenryck () gmail ! com>
--------------------
The type in a generic association must correspond to a complete
type and not a variably modified type.

Add validation for this.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/evaluate.c b/evaluate.c
index 491dfa3c6b89..aa0f208006bb 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3299,9 +3299,29 @@ static struct symbol *evaluate_generic_selection(struct expression *expr)
 	source.ctype.modifiers &= ~(MOD_QUALIFIER|MOD_ATOMIC);
 	for (map = expr->map; map; map = map->next) {
 		struct symbol *stype = map->type;
+		struct symbol *base;
 
 		if (!evaluate_symbol(stype))
 			continue;
+
+		if (stype->type == SYM_NODE)
+			base = stype->ctype.base_type;
+
+		if (base->type == SYM_ARRAY && base->array_size) {
+			get_expression_value_silent(base->array_size);
+			if (base->array_size->type == EXPR_VALUE)
+				continue;
+			sparse_error(stype->pos, "variable length array type in generic selection");
+			continue;
+		}
+		if (is_func_type(stype)) {
+			sparse_error(stype->pos, "function type in generic selection");
+			continue;
+		}
+		if (stype->bit_size <= 0 || is_void_type(stype)) {
+			sparse_error(stype->pos, "incomplete type in generic selection");
+			continue;
+		}
 		if (!type_selection(&source, stype))
 			continue;
 
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 5/5] teach sparse to linearize __builtin_unreachable() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/5] teach sparse to linearize __builtin_unreachable()
Date: Wed, 18 Mar 2020 17:31:20 +0000
Message-ID: <20200318173120.63939-6-luc.vanoostenryck () gmail ! com>
--------------------
__builtin_unreachable() is one of the builtin that shouldn't
be ignored at IR level since it directly impact the CFG.

So, add the infrastructure put in place in the previous patch
to generate the OP_UNREACH instruction instead of generating
a call to a non-existing function "__builtin_unreachable()".

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c                              | 7 +++++++
 validation/context-unreachable.c         | 1 -
 validation/linear/builtin_unreachable0.c | 1 -
 validation/linear/builtin_unreachable1.c | 1 -
 4 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/linearize.c b/linearize.c
index 25d6327bf6f1..615636ed1f83 100644
--- a/linearize.c
+++ b/linearize.c
@@ -2536,12 +2536,19 @@ struct entrypoint *linearize_symbol(struct symbol *sym)
  * Builtin functions
  */
 
+static pseudo_t linearize_unreachable(struct entrypoint *ep, struct expression *exp)
+{
+	add_unreachable(ep);
+	return VOID;
+}
+
 static struct sym_init {
 	const char *name;
 	pseudo_t (*linearize)(struct entrypoint *, struct expression*);
 	struct symbol_op op;
 } builtins_table[] = {
 	// must be declared in builtin.c:declare_builtins[]
+	{ "__builtin_unreachable", linearize_unreachable },
 	{ }
 };
 
diff --git a/validation/context-unreachable.c b/validation/context-unreachable.c
index 3e330403ce01..8664962ea088 100644
--- a/validation/context-unreachable.c
+++ b/validation/context-unreachable.c
@@ -12,5 +12,4 @@ static void foo(void)
 
 /*
  * check-name: context-unreachable
- * check-known-to-fail
  */
diff --git a/validation/linear/builtin_unreachable0.c b/validation/linear/builtin_unreachable0.c
index 5da9d074ae5f..fb59a3408987 100644
--- a/validation/linear/builtin_unreachable0.c
+++ b/validation/linear/builtin_unreachable0.c
@@ -10,7 +10,6 @@ int foo(int p)
 /*
  * check-name: builtin_unreachable0
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-start
 foo:
diff --git a/validation/linear/builtin_unreachable1.c b/validation/linear/builtin_unreachable1.c
index 280f853d8a07..a83da079a3c9 100644
--- a/validation/linear/builtin_unreachable1.c
+++ b/validation/linear/builtin_unreachable1.c
@@ -12,7 +12,6 @@ int foo(int c)
  * check-name: builtin_unreachable1
  * check-command: test-linearize -Wno-decl $file
  *
- * check-known-to-fail
  * check-output-start
 foo:
 .L0:
-- 
2.25.1

================================================================================


################################################################################

=== Thread: [PATCH 5/6] remove now unused match_idents() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/6] remove now unused match_idents()
Date: Thu, 23 Jul 2020 23:46:40 +0000
Message-ID: <20200723234641.78462-6-luc.vanoostenryck () gmail ! com>
--------------------
match_idents() is now unused and identifier matching should
preferably be done via the keyword table.

So, remove this function.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 18 ------------------
 1 file changed, 18 deletions(-)

diff --git a/parse.c b/parse.c
index ec69e0c6e9ca..c7ca3dce7f6b 100644
--- a/parse.c
+++ b/parse.c
@@ -678,24 +678,6 @@ static void fn_local_symbol(struct symbol *sym)
 		add_symbol(function_symbol_list, sym);
 }
 
-static int SENTINEL_ATTR match_idents(struct token *token, ...)
-{
-	va_list args;
-	struct ident * next;
-
-	if (token_type(token) != TOKEN_IDENT)
-		return 0;
-
-	va_start(args, token);
-	do {
-		next = va_arg(args, struct ident *);
-	} while (next && token->ident != next);
-	va_end(args);
-
-	return next && token->ident == next;
-}
-
-
 struct statement *alloc_statement(struct position pos, int type)
 {
 	struct statement *stmt = __alloc_statement(0);
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 5/7] doc: reorganize the table of content ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/7] doc: reorganize the table of content
Date: Mon, 10 Aug 2020 21:53:34 +0000
Message-ID: <20200810215336.76070-6-luc.vanoostenryck () gmail ! com>
--------------------
Reorganize the table of of content with user documentation first
then all documentation useful for development on sparse itself.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/index.rst | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/Documentation/index.rst b/Documentation/index.rst
index 321a947ec9c5..4bca8c7e47f3 100644
--- a/Documentation/index.rst
+++ b/Documentation/index.rst
@@ -64,22 +64,22 @@ Bugs can also be reported and tracked via the `Linux kernel's bugzilla for spars
 
 
 .. toctree::
-   :caption: Documentation
+   :caption: User Documentation
    :maxdepth: 1
 
    annotations
-   dev-options
-   types
-   api
-   IR
-   test-suite
-   doc-guide
 
 .. toctree::
-   :caption: How to contribute
+   :caption: Development
    :maxdepth: 1
 
    submitting-patches
+   types
+   api
+   dev-options
+   IR
+   test-suite
+   doc-guide
    TODO
 
 .. toctree::
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 5/9] unop: simplify -(~x) --> x + 1 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/9] unop: simplify -(~x) --> x + 1
Date: Fri, 23 Oct 2020 16:39:35 +0000
Message-ID: <20201023163939.58359-6-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                          | 4 ++++
 validation/optim/simplify-neg-not.c | 1 -
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index fd486172e6e8..8f6b821dcf8c 100644
--- a/simplify.c
+++ b/simplify.c
@@ -1478,6 +1478,10 @@ static int simplify_unop(struct instruction *insn)
 			return replace_pseudo(insn, &insn->src1, src);
 		case OP_NEG:		// -(-x) --> x
 			return replace_with_pseudo(insn, def->src);
+		case OP_NOT:
+			insn->opcode = OP_ADD;	// -(~x) --> x + 1
+			insn->src2 = value_pseudo(1);
+			return replace_pseudo(insn, &insn->src1, def->src);
 		case OP_SUB:		// -(x - y) --> y - x
 			insn->opcode = OP_SUB;
 			use_pseudo(insn, def->src1, &insn->src2);
diff --git a/validation/optim/simplify-neg-not.c b/validation/optim/simplify-neg-not.c
index 4bd0abfb0628..e92352cfeeec 100644
--- a/validation/optim/simplify-neg-not.c
+++ b/validation/optim/simplify-neg-not.c
@@ -3,7 +3,6 @@ int foo(int x) { return -(~x) == x + 1; }
 /*
  * check-name: simplify-neg-not
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-contains: ret\\..*\\$1
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 6/6] allow [*] in array declarators ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 6/6] allow [*] in array declarators
Date: Thu, 23 Jul 2020 23:46:41 +0000
Message-ID: <20200723234641.78462-7-luc.vanoostenryck () gmail ! com>
--------------------
Since C99, a '*' is allowed in an abstract array declarator to
specify that the array is a VLA with a yet-to-be-determined size.

So, accept this construction (but still ignore it for now).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                                     | 7 ++++++-
 validation/abstract-array-declarator-star.c | 1 -
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/parse.c b/parse.c
index c7ca3dce7f6b..6db70f1a95e9 100644
--- a/parse.c
+++ b/parse.c
@@ -1717,7 +1717,12 @@ static struct token *abstract_array_declarator(struct token *token, struct symbo
 		has_static |= (sym->op->type & KW_STATIC);
 		token = token->next;
 	}
-	token = assignment_expression(token, &expr);
+	if (match_op(token, '*') && match_op(token->next, ']')) {
+		// FIXME: '[*]' is treated like '[]'
+		token = token->next;
+	} else {
+		token = assignment_expression(token, &expr);
+	}
 	sym->array_size = expr;
 	return token;
 }
diff --git a/validation/abstract-array-declarator-star.c b/validation/abstract-array-declarator-star.c
index fdbdff19840d..fc42da3ae6c9 100644
--- a/validation/abstract-array-declarator-star.c
+++ b/validation/abstract-array-declarator-star.c
@@ -5,5 +5,4 @@ void ok9(int a[const volatile restrict *]);
 
 /*
  * check-name: abstract-array-declarator-star
- * check-known-to-fail
  */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH 6/7] doc: use shorter titles ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 6/7] doc: use shorter titles
Date: Mon, 10 Aug 2020 21:53:35 +0000
Message-ID: <20200810215336.76070-7-luc.vanoostenryck () gmail ! com>
--------------------
Mainly it's removing 'sparse' from the title.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/IR.rst          | 4 ++--
 Documentation/dev-options.rst | 4 ++--
 Documentation/doc-guide.rst   | 4 ++--
 Documentation/types.rst       | 6 +++---
 4 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/Documentation/IR.rst b/Documentation/IR.rst
index 33a761662fad..97d4b2b27ee3 100644
--- a/Documentation/IR.rst
+++ b/Documentation/IR.rst
@@ -1,7 +1,7 @@
 .. default-domain:: ir
 
-Sparse's Intermediate Representation
-====================================
+Intermediate Representation
+===========================
 
 Instructions
 ~~~~~~~~~~~~
diff --git a/Documentation/dev-options.rst b/Documentation/dev-options.rst
index 23e8096c2cd0..57f9e8d6c4de 100644
--- a/Documentation/dev-options.rst
+++ b/Documentation/dev-options.rst
@@ -1,5 +1,5 @@
-sparse - extra options for developers
-=====================================
+Extra options for developers
+============================
 
 SYNOPSIS
 --------
diff --git a/Documentation/doc-guide.rst b/Documentation/doc-guide.rst
index 8133cb3a59df..29f39aab360a 100644
--- a/Documentation/doc-guide.rst
+++ b/Documentation/doc-guide.rst
@@ -1,5 +1,5 @@
-How to write sparse documentation
-=================================
+Documentation guide
+===================
 
 Introduction
 ------------
diff --git a/Documentation/types.rst b/Documentation/types.rst
index 272f32a0f4ed..974f9861afef 100644
--- a/Documentation/types.rst
+++ b/Documentation/types.rst
@@ -1,6 +1,6 @@
-********************
-Sparse's Type System
-********************
+***********
+Type System
+***********
 
 struct symbol is used to represent symbols & types but
 most parts pertaining to the types are in the field 'ctype'.
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 7/9] unop: simplify ~(C - x) --> x + ~C ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 7/9] unop: simplify ~(C - x) --> x + ~C
Date: Fri, 23 Oct 2020 16:39:37 +0000
Message-ID: <20201023163939.58359-8-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                              | 6 ++++++
 validation/optim/simplify-not-sub-cte.c | 1 -
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index 63431b3d00b1..8173777652af 100644
--- a/simplify.c
+++ b/simplify.c
@@ -1472,6 +1472,12 @@ static int simplify_unop(struct instruction *insn)
 			return replace_pseudo(insn, &insn->src1, src);
 		case OP_NOT:		// ~(~x) --> x
 			return replace_with_pseudo(insn, def->src);
+		case OP_SUB:
+			if (!constant(def->src1))
+				break;
+			insn->opcode = OP_ADD;	// ~(C - x) --> x + ~C
+			insn->src2 = eval_unop(OP_NOT, insn->size, def->src1);
+			return replace_pseudo(insn, &insn->src1, def->src2);
 		}
 		break;
 	case OP_NEG:
diff --git a/validation/optim/simplify-not-sub-cte.c b/validation/optim/simplify-not-sub-cte.c
index ec105beb31fe..1ea73ece2e27 100644
--- a/validation/optim/simplify-not-sub-cte.c
+++ b/validation/optim/simplify-not-sub-cte.c
@@ -5,7 +5,6 @@ int foo(int x) { return ~(C - x) == (x + ~C); }
 /*
  * check-name: simplify-not-sub-cte
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-contains: ret\\..*\\$1
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH 9/9] unop: simplify ~(-x) --> x - 1 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 9/9] unop: simplify ~(-x) --> x - 1
Date: Fri, 23 Oct 2020 16:39:39 +0000
Message-ID: <20201023163939.58359-10-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                          | 4 ++++
 validation/optim/simplify-not-neg.c | 1 -
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index 1b6e1cc2313b..6588f8af2820 100644
--- a/simplify.c
+++ b/simplify.c
@@ -1470,6 +1470,10 @@ static int simplify_unop(struct instruction *insn)
 			src = eval_unop(OP_NOT, insn->size, def->src2);
 			use_pseudo(insn, def->src1, &insn->src2);
 			return replace_pseudo(insn, &insn->src1, src);
+		case OP_NEG:
+			insn->opcode = OP_SUB;	// ~(-x) --> x - 1
+			insn->src2 = value_pseudo(1);
+			return replace_pseudo(insn, &insn->src1, def->src);
 		case OP_NOT:		// ~(~x) --> x
 			return replace_with_pseudo(insn, def->src);
 		case OP_SUB:
diff --git a/validation/optim/simplify-not-neg.c b/validation/optim/simplify-not-neg.c
index b9675ea62049..3fd8400d7bd4 100644
--- a/validation/optim/simplify-not-neg.c
+++ b/validation/optim/simplify-not-neg.c
@@ -3,7 +3,6 @@ int foo(int x) { return ~(-x) == (x - 1); }
 /*
  * check-name: simplify-not-neg
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-contains: ret\\..*\\$1
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH AUTOSEL 4.14 18/30] compiler.h: fix error in BUILD_BUG_ON() reporting ===

From: Sasha Levin <sashal () kernel ! org>
To: linux-sparse
Subject: [PATCH AUTOSEL 4.14 18/30] compiler.h: fix error in BUILD_BUG_ON() reporting
Date: Wed, 15 Apr 2020 11:46:59 +0000
Message-ID: <20200415114711.15381-18-sashal () kernel ! org>
--------------------
From: Vegard Nossum <vegard.nossum@oracle.com>

[ Upstream commit af9c5d2e3b355854ff0e4acfbfbfadcd5198a349 ]

compiletime_assert() uses __LINE__ to create a unique function name.  This
means that if you have more than one BUILD_BUG_ON() in the same source
line (which can happen if they appear e.g.  in a macro), then the error
message from the compiler might output the wrong condition.

For this source file:

	#include <linux/build_bug.h>

	#define macro() \
		BUILD_BUG_ON(1); \
		BUILD_BUG_ON(0);

	void foo()
	{
		macro();
	}

gcc would output:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_9' declared with attribute error: BUILD_BUG_ON failed: 0
  _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

However, it was not the BUILD_BUG_ON(0) that failed, so it should say 1
instead of 0. With this patch, we use __COUNTER__ instead of __LINE__, so
each BUILD_BUG_ON() gets a different function name and the correct
condition is printed:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_0' declared with attribute error: BUILD_BUG_ON failed: 1
  _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)

Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
Reviewed-by: Daniel Santos <daniel.santos@pobox.com>
Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Cc: Ian Abbott <abbotti@mev.co.uk>
Cc: Joe Perches <joe@perches.com>
Link: http://lkml.kernel.org/r/20200331112637.25047-1-vegard.nossum@oracle.com
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
---
 include/linux/compiler.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index f84d332085c31..3ffe3f3f79035 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -331,7 +331,7 @@ unsigned long read_word_at_a_time(const void *addr)
  * compiler has support to do so.
  */
 #define compiletime_assert(condition, msg) \
-	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
+	_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)
 
 #define compiletime_assert_atomic_type(t)				\
 	compiletime_assert(__native_word(t),				\
-- 
2.20.1

================================================================================


################################################################################

=== Thread: [PATCH AUTOSEL 4.19 23/40] compiler.h: fix error in BUILD_BUG_ON() reporting ===

From: Sasha Levin <sashal () kernel ! org>
To: linux-sparse
Subject: [PATCH AUTOSEL 4.19 23/40] compiler.h: fix error in BUILD_BUG_ON() reporting
Date: Wed, 15 Apr 2020 11:46:06 +0000
Message-ID: <20200415114623.14972-23-sashal () kernel ! org>
--------------------
From: Vegard Nossum <vegard.nossum@oracle.com>

[ Upstream commit af9c5d2e3b355854ff0e4acfbfbfadcd5198a349 ]

compiletime_assert() uses __LINE__ to create a unique function name.  This
means that if you have more than one BUILD_BUG_ON() in the same source
line (which can happen if they appear e.g.  in a macro), then the error
message from the compiler might output the wrong condition.

For this source file:

	#include <linux/build_bug.h>

	#define macro() \
		BUILD_BUG_ON(1); \
		BUILD_BUG_ON(0);

	void foo()
	{
		macro();
	}

gcc would output:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_9' declared with attribute error: BUILD_BUG_ON failed: 0
  _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

However, it was not the BUILD_BUG_ON(0) that failed, so it should say 1
instead of 0. With this patch, we use __COUNTER__ instead of __LINE__, so
each BUILD_BUG_ON() gets a different function name and the correct
condition is printed:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_0' declared with attribute error: BUILD_BUG_ON failed: 1
  _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)

Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
Reviewed-by: Daniel Santos <daniel.santos@pobox.com>
Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Cc: Ian Abbott <abbotti@mev.co.uk>
Cc: Joe Perches <joe@perches.com>
Link: http://lkml.kernel.org/r/20200331112637.25047-1-vegard.nossum@oracle.com
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
---
 include/linux/compiler.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index bb22908c79e83..75112aa8064e8 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -345,7 +345,7 @@ static inline void *offset_to_ptr(const int *off)
  * compiler has support to do so.
  */
 #define compiletime_assert(condition, msg) \
-	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
+	_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)
 
 #define compiletime_assert_atomic_type(t)				\
 	compiletime_assert(__native_word(t),				\
-- 
2.20.1

================================================================================


################################################################################

=== Thread: [PATCH AUTOSEL 4.9 13/21] compiler.h: fix error in BUILD_BUG_ON() reporting ===

From: Sasha Levin <sashal () kernel ! org>
To: linux-sparse
Subject: [PATCH AUTOSEL 4.9 13/21] compiler.h: fix error in BUILD_BUG_ON() reporting
Date: Wed, 15 Apr 2020 11:47:40 +0000
Message-ID: <20200415114748.15713-13-sashal () kernel ! org>
--------------------
From: Vegard Nossum <vegard.nossum@oracle.com>

[ Upstream commit af9c5d2e3b355854ff0e4acfbfbfadcd5198a349 ]

compiletime_assert() uses __LINE__ to create a unique function name.  This
means that if you have more than one BUILD_BUG_ON() in the same source
line (which can happen if they appear e.g.  in a macro), then the error
message from the compiler might output the wrong condition.

For this source file:

	#include <linux/build_bug.h>

	#define macro() \
		BUILD_BUG_ON(1); \
		BUILD_BUG_ON(0);

	void foo()
	{
		macro();
	}

gcc would output:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_9' declared with attribute error: BUILD_BUG_ON failed: 0
  _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

However, it was not the BUILD_BUG_ON(0) that failed, so it should say 1
instead of 0. With this patch, we use __COUNTER__ instead of __LINE__, so
each BUILD_BUG_ON() gets a different function name and the correct
condition is printed:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_0' declared with attribute error: BUILD_BUG_ON failed: 1
  _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)

Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
Reviewed-by: Daniel Santos <daniel.santos@pobox.com>
Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Cc: Ian Abbott <abbotti@mev.co.uk>
Cc: Joe Perches <joe@perches.com>
Link: http://lkml.kernel.org/r/20200331112637.25047-1-vegard.nossum@oracle.com
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
---
 include/linux/compiler.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 0020ee1cab37a..7837afabbd78e 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -546,7 +546,7 @@ unsigned long read_word_at_a_time(const void *addr)
  * compiler has support to do so.
  */
 #define compiletime_assert(condition, msg) \
-	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
+	_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)
 
 #define compiletime_assert_atomic_type(t)				\
 	compiletime_assert(__native_word(t),				\
-- 
2.20.1

================================================================================


################################################################################

=== Thread: [PATCH AUTOSEL 5.4 53/84] compiler.h: fix error in BUILD_BUG_ON() reporting ===

From: Sasha Levin <sashal () kernel ! org>
To: linux-sparse
Subject: [PATCH AUTOSEL 5.4 53/84] compiler.h: fix error in BUILD_BUG_ON() reporting
Date: Wed, 15 Apr 2020 11:44:10 +0000
Message-ID: <20200415114442.14166-53-sashal () kernel ! org>
--------------------
From: Vegard Nossum <vegard.nossum@oracle.com>

[ Upstream commit af9c5d2e3b355854ff0e4acfbfbfadcd5198a349 ]

compiletime_assert() uses __LINE__ to create a unique function name.  This
means that if you have more than one BUILD_BUG_ON() in the same source
line (which can happen if they appear e.g.  in a macro), then the error
message from the compiler might output the wrong condition.

For this source file:

	#include <linux/build_bug.h>

	#define macro() \
		BUILD_BUG_ON(1); \
		BUILD_BUG_ON(0);

	void foo()
	{
		macro();
	}

gcc would output:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_9' declared with attribute error: BUILD_BUG_ON failed: 0
  _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

However, it was not the BUILD_BUG_ON(0) that failed, so it should say 1
instead of 0. With this patch, we use __COUNTER__ instead of __LINE__, so
each BUILD_BUG_ON() gets a different function name and the correct
condition is printed:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_0' declared with attribute error: BUILD_BUG_ON failed: 1
  _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)

Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
Reviewed-by: Daniel Santos <daniel.santos@pobox.com>
Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Cc: Ian Abbott <abbotti@mev.co.uk>
Cc: Joe Perches <joe@perches.com>
Link: http://lkml.kernel.org/r/20200331112637.25047-1-vegard.nossum@oracle.com
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
---
 include/linux/compiler.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 5e88e7e33abec..034b0a644efcc 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -347,7 +347,7 @@ static inline void *offset_to_ptr(const int *off)
  * compiler has support to do so.
  */
 #define compiletime_assert(condition, msg) \
-	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
+	_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)
 
 #define compiletime_assert_atomic_type(t)				\
 	compiletime_assert(__native_word(t),				\
-- 
2.20.1

================================================================================


################################################################################

=== Thread: [PATCH AUTOSEL 5.5 070/106] compiler.h: fix error in BUILD_BUG_ON() reporting ===

From: Sasha Levin <sashal () kernel ! org>
To: linux-sparse
Subject: [PATCH AUTOSEL 5.5 070/106] compiler.h: fix error in BUILD_BUG_ON() reporting
Date: Wed, 15 Apr 2020 11:41:50 +0000
Message-ID: <20200415114226.13103-70-sashal () kernel ! org>
--------------------
From: Vegard Nossum <vegard.nossum@oracle.com>

[ Upstream commit af9c5d2e3b355854ff0e4acfbfbfadcd5198a349 ]

compiletime_assert() uses __LINE__ to create a unique function name.  This
means that if you have more than one BUILD_BUG_ON() in the same source
line (which can happen if they appear e.g.  in a macro), then the error
message from the compiler might output the wrong condition.

For this source file:

	#include <linux/build_bug.h>

	#define macro() \
		BUILD_BUG_ON(1); \
		BUILD_BUG_ON(0);

	void foo()
	{
		macro();
	}

gcc would output:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_9' declared with attribute error: BUILD_BUG_ON failed: 0
  _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

However, it was not the BUILD_BUG_ON(0) that failed, so it should say 1
instead of 0. With this patch, we use __COUNTER__ instead of __LINE__, so
each BUILD_BUG_ON() gets a different function name and the correct
condition is printed:

./include/linux/compiler.h:350:38: error: call to `__compiletime_assert_0' declared with attribute error: BUILD_BUG_ON failed: 1
  _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)

Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
Reviewed-by: Daniel Santos <daniel.santos@pobox.com>
Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Cc: Ian Abbott <abbotti@mev.co.uk>
Cc: Joe Perches <joe@perches.com>
Link: http://lkml.kernel.org/r/20200331112637.25047-1-vegard.nossum@oracle.com
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
---
 include/linux/compiler.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 5e88e7e33abec..034b0a644efcc 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -347,7 +347,7 @@ static inline void *offset_to_ptr(const int *off)
  * compiler has support to do so.
  */
 #define compiletime_assert(condition, msg) \
-	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
+	_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)
 
 #define compiletime_assert_atomic_type(t)				\
 	compiletime_assert(__native_word(t),				\
-- 
2.20.1

================================================================================


################################################################################

=== Thread: [PATCH bpf] bpf: Improve bucket_log calculation logic ===

From: Martin KaFai Lau <kafai () fb ! com>
To: linux-sparse
Subject: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 08:18:10 +0000
Message-ID: <20200207081810.3918919-1-kafai () fb ! com>
--------------------
It was reported that the max_t, ilog2, and roundup_pow_of_two macros have
exponential effects on the number of states in the sparse checker.

This patch breaks them up by calculating the "nbuckets" first so
that the "bucket_log" only needs to take ilog2().

Fixes: 6ac99e8f23d4 ("bpf: Introduce bpf sk local storage")
Reported-by: Randy Dunlap <rdunlap@infradead.org>
Reported-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Martin KaFai Lau <kafai@fb.com>
---
 net/core/bpf_sk_storage.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/net/core/bpf_sk_storage.c b/net/core/bpf_sk_storage.c
index 458be6b3eda9..3ab23f698221 100644
--- a/net/core/bpf_sk_storage.c
+++ b/net/core/bpf_sk_storage.c
@@ -643,9 +643,10 @@ static struct bpf_map *bpf_sk_storage_map_alloc(union bpf_attr *attr)
 		return ERR_PTR(-ENOMEM);
 	bpf_map_init_from_attr(&smap->map, attr);
 
+	nbuckets = roundup_pow_of_two(num_possible_cpus());
 	/* Use at least 2 buckets, select_bucket() is undefined behavior with 1 bucket */
-	smap->bucket_log = max_t(u32, 1, ilog2(roundup_pow_of_two(num_possible_cpus())));
-	nbuckets = 1U << smap->bucket_log;
+	nbuckets = max_t(u32, 2, nbuckets);
+	smap->bucket_log = ilog2(nbuckets);
 	cost = sizeof(*smap->buckets) * nbuckets + sizeof(*smap);
 
 	ret = bpf_map_charge_init(&smap->map.memory, cost);
-- 
2.17.1

================================================================================

From: Martin KaFai Lau <kafai () fb ! com>
To: linux-netdev
Subject: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 08:18:10 +0000
Message-ID: <20200207081810.3918919-1-kafai () fb ! com>
--------------------
It was reported that the max_t, ilog2, and roundup_pow_of_two macros have
exponential effects on the number of states in the sparse checker.

This patch breaks them up by calculating the "nbuckets" first so
that the "bucket_log" only needs to take ilog2().

Fixes: 6ac99e8f23d4 ("bpf: Introduce bpf sk local storage")
Reported-by: Randy Dunlap <rdunlap@infradead.org>
Reported-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Martin KaFai Lau <kafai@fb.com>
---
 net/core/bpf_sk_storage.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/net/core/bpf_sk_storage.c b/net/core/bpf_sk_storage.c
index 458be6b3eda9..3ab23f698221 100644
--- a/net/core/bpf_sk_storage.c
+++ b/net/core/bpf_sk_storage.c
@@ -643,9 +643,10 @@ static struct bpf_map *bpf_sk_storage_map_alloc(union bpf_attr *attr)
 		return ERR_PTR(-ENOMEM);
 	bpf_map_init_from_attr(&smap->map, attr);
 
+	nbuckets = roundup_pow_of_two(num_possible_cpus());
 	/* Use at least 2 buckets, select_bucket() is undefined behavior with 1 bucket */
-	smap->bucket_log = max_t(u32, 1, ilog2(roundup_pow_of_two(num_possible_cpus())));
-	nbuckets = 1U << smap->bucket_log;
+	nbuckets = max_t(u32, 2, nbuckets);
+	smap->bucket_log = ilog2(nbuckets);
 	cost = sizeof(*smap->buckets) * nbuckets + sizeof(*smap);
 
 	ret = bpf_map_charge_init(&smap->map.memory, cost);
-- 
2.17.1

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-netdev
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 13:07:21 +0000
Message-ID: <20200207130721.pitlvbxcx656c7ur () ltop ! local>
--------------------
On Fri, Feb 07, 2020 at 12:18:10AM -0800, Martin KaFai Lau wrote:
> 
> diff --git a/net/core/bpf_sk_storage.c b/net/core/bpf_sk_storage.c
> index 458be6b3eda9..3ab23f698221 100644
> --- a/net/core/bpf_sk_storage.c
> +++ b/net/core/bpf_sk_storage.c
> @@ -643,9 +643,10 @@ static struct bpf_map *bpf_sk_storage_map_alloc(union bpf_attr *attr)
>  		return ERR_PTR(-ENOMEM);
>  	bpf_map_init_from_attr(&smap->map, attr);
>  
> +	nbuckets = roundup_pow_of_two(num_possible_cpus());
>  	/* Use at least 2 buckets, select_bucket() is undefined behavior with 1 bucket */
> -	smap->bucket_log = max_t(u32, 1, ilog2(roundup_pow_of_two(num_possible_cpus())));
> -	nbuckets = 1U << smap->bucket_log;
> +	nbuckets = max_t(u32, 2, nbuckets);
> +	smap->bucket_log = ilog2(nbuckets);
>  	cost = sizeof(*smap->buckets) * nbuckets + sizeof(*smap);
>  
>  	ret = bpf_map_charge_init(&smap->map.memory, cost);
> -- 

Yes, that's much nicer to read. Feel free to add my

Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

-- Luc
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-netdev
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 18:07:32 +0000
Message-ID: <CAHk-=wieADOQcYkehVN7meevnd3jZrq06NkmyH9GGR==2rEpuQ () mail ! gmail ! com>
--------------------
On Fri, Feb 7, 2020 at 12:18 AM Martin KaFai Lau <kafai@fb.com> wrote:
>
> It was reported that the max_t, ilog2, and roundup_pow_of_two macros have
> exponential effects on the number of states in the sparse checker.

Patch looks good, but I'd like to point out that it's not just sparse.

You can see it with a simple

    make net/core/bpf_sk_storage.i
    grep 'smap->bucket_log = ' net/core/bpf_sk_storage.i | wc

and see the end result:

      1  365071 2686974

That's one line (the assignment line) that is 2,686,974 characters in length.

Now, sparse does happen to react particularly badly to that (I didn't
look to why, but I suspect it's just that evaluating all the types
that don't actually ever end up getting used ends up being much more
expensive than it should be), but I bet it's not good for gcc either.

I do think this is a good test-case for sparse. Luc, have you looked
at what it is that then makes sparse use *so* much memory for this one
line?

             Linus
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 18:07:32 +0000
Message-ID: <CAHk-=wieADOQcYkehVN7meevnd3jZrq06NkmyH9GGR==2rEpuQ () mail ! gmail ! com>
--------------------
On Fri, Feb 7, 2020 at 12:18 AM Martin KaFai Lau <kafai@fb.com> wrote:
>
> It was reported that the max_t, ilog2, and roundup_pow_of_two macros have
> exponential effects on the number of states in the sparse checker.

Patch looks good, but I'd like to point out that it's not just sparse.

You can see it with a simple

    make net/core/bpf_sk_storage.i
    grep 'smap->bucket_log = ' net/core/bpf_sk_storage.i | wc

and see the end result:

      1  365071 2686974

That's one line (the assignment line) that is 2,686,974 characters in length.

Now, sparse does happen to react particularly badly to that (I didn't
look to why, but I suspect it's just that evaluating all the types
that don't actually ever end up getting used ends up being much more
expensive than it should be), but I bet it's not good for gcc either.

I do think this is a good test-case for sparse. Luc, have you looked
at what it is that then makes sparse use *so* much memory for this one
line?

             Linus
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 19:39:24 +0000
Message-ID: <CAHk-=wjbhawNieeiEig4LnPVRTRPgY8xag7NuAKuM9NKXCTLeQ () mail ! gmail ! com>
--------------------
On Fri, Feb 7, 2020 at 10:07 AM Linus Torvalds
<torvalds@linux-foundation.org> wrote:
>
> I do think this is a good test-case for sparse. Luc, have you looked
> at what it is that then makes sparse use *so* much memory for this one
> line?

Looking at the profile, it's doing a lot of "copy_expression()".

Which comes from inlining.

I think the problem may be that with that macro expansion from hell we
end up with 28968 copies of cpumask_weight(), and sparse will inline
every one of them into the parse tree - even though basically none of
them are _used_.

In fact, it's worse than that: we end up having a few rounds of
inlining thanks to

static inline unsigned int cpumask_weight(const struct cpumask *srcp)
{
        return bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);
}

static __always_inline int bitmap_weight(const unsigned long *src,
unsigned int nbits)
{
        if (small_const_nbits(nbits))
                return hweight_long(*src & BITMAP_LAST_WORD_MASK(nbits));
        return __bitmap_weight(src, nbits);
}

static __always_inline unsigned long hweight_long(unsigned long w)
{
        return sizeof(w) == 4 ? hweight32(w) : hweight64(w);
}

where those hweight*() things aren't simple either, they end up doing

  #define hweight32(w) (__builtin_constant_p(w) ? __const_hweight32(w)
: __arch_hweight32(w))
  #define hweight64(w) (__builtin_constant_p(w) ? __const_hweight64(w)
: __arch_hweight64(w))

where the __const_hweight*() in turn are more expansions of a macro
with several levels in order to turn it all into a constant value.

So we may have "only" 28968 calls to cpumask_weight(), but it results
in millions of expressions being expanded.

If we did some basic simplification of constant ops before inlining,
that would likely help a lot.

But currently sparse does inline function expansion at type evaluation
time - so long before it does any simplification of the tree at all.

So that explains why sparse happens to react _so_ badly to this thing.
A real compiler would do inlining much later.

Inlining that early is partly because originally one of the design
ideas in sparse was to make inline functions act basically as
templates, so they'd react to the types of the context. But it really
bites us in the ass here.

Luc, any ideas? Yes, this is solvable in the kernel, but it does show
that sparse simply does a _lot_ of unnecessary work.

               Linus
================================================================================

From: Alexei Starovoitov <alexei.starovoitov () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 20:13:03 +0000
Message-ID: <20200207201301.wpq4abick4j3rucl () ast-mbp ! dhcp ! thefacebook ! com>
--------------------
On Fri, Feb 07, 2020 at 10:07:32AM -0800, Linus Torvalds wrote:
> On Fri, Feb 7, 2020 at 12:18 AM Martin KaFai Lau <kafai@fb.com> wrote:
> >
> > It was reported that the max_t, ilog2, and roundup_pow_of_two macros have
> > exponential effects on the number of states in the sparse checker.
> 
> Patch looks good, but I'd like to point out that it's not just sparse.
> 
> You can see it with a simple
> 
>     make net/core/bpf_sk_storage.i
>     grep 'smap->bucket_log = ' net/core/bpf_sk_storage.i | wc
> 
> and see the end result:
> 
>       1  365071 2686974
> 
> That's one line (the assignment line) that is 2,686,974 characters in length.

In addition to this patch I've tried:
diff --git a/include/linux/log2.h b/include/linux/log2.h
index 83a4a3ca3e8a..7363abf60854 100644
--- a/include/linux/log2.h
+++ b/include/linux/log2.h
@@ -74,74 +74,76 @@ unsigned long __rounddown_pow_of_two(unsigned long n)
  * Use this where sparse expects a true constant expression, e.g. for array
  * indices.
  */
-#define const_ilog2(n)                         \
-(                                              \
-       __builtin_constant_p(n) ? (             \
-               (n) < 2 ? 0 :                   \
-               (n) & (1ULL << 63) ? 63 :       \
-               (n) & (1ULL << 62) ? 62 :       \
...
+#define __const_ilog2(n, unique_n) ({                  \
+       typeof(n) unique_n = (n);                       \
+       __builtin_constant_p(unique_n) ? (              \
+               (unique_n) < 2 ? 0 :                    \
+               (unique_n) & (1ULL << 63) ? 63 :        \
+               (unique_n) & (1ULL << 62) ? 62 :        \
+               (unique_n) & (1ULL << 61) ? 61 :        \
+               (unique_n) & (1ULL << 60) ? 60 :        \
+               (unique_n) & (1ULL << 59) ? 59 :        \
...
+               (unique_n) & (1ULL <<  3) ?  3 :        \
+               (unique_n) & (1ULL <<  2) ?  2 :        \
                1) :                            \
-       -1)
+       -1; })
+
+#define const_ilog2(n) __const_ilog2(n, __UNIQUE_ID(__n))

and for this nested ilog2() case that caused this explosion
the line got shorter: from 2.6M characters to 144k.
Still a lot.
Unfortunately this approach doesn't work in all cases:
../include/linux/log2.h:77:36: error: braced-group within expression allowed only inside a function
   77 | #define __const_ilog2(n, unique_n) ({   \
      |                                    ^
../include/linux/log2.h:146:24: note: in expansion of macro â__const_ilog2â
  146 | #define const_ilog2(n) __const_ilog2(n, __UNIQUE_ID(__n))
      |                        ^~~~~~~~~~~~~
../include/linux/log2.h:161:2: note: in expansion of macro âconst_ilog2â
  161 |  const_ilog2(n) :  \
      |  ^~~~~~~~~~~
../include/linux/blockgroup_lock.h:14:27: note: in expansion of macro âilog2â
   14 | #define NR_BG_LOCKS (4 << ilog2(NR_CPUS < 32 ? NR_CPUS : 32))
      |                           ^~~~~
../include/linux/blockgroup_lock.h:24:24: note: in expansion of macro âNR_BG_LOCKSâ
   24 |  struct bgl_lock locks[NR_BG_LOCKS];

Just fyi for folks who're looking at ilog2 and wondering
why it was done this way without ({ })
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 20:41:44 +0000
Message-ID: <20200207204144.hh4n4o643oqpcwed () ltop ! local>
--------------------
On Fri, Feb 07, 2020 at 11:39:24AM -0800, Linus Torvalds wrote:
> On Fri, Feb 7, 2020 at 10:07 AM Linus Torvalds
> <torvalds@linux-foundation.org> wrote:
> >
> > I do think this is a good test-case for sparse. Luc, have you looked
> > at what it is that then makes sparse use *so* much memory for this one
> > line?
> 
> Looking at the profile, it's doing a lot of "copy_expression()".
> 
> Which comes from inlining.
> 
> I think the problem may be that with that macro expansion from hell we
> end up with 28968 copies of cpumask_weight(), and sparse will inline
> every one of them into the parse tree - even though basically none of
> them are _used_.

Yes, indeed. I was just what I saw too.

> In fact, it's worse than that: we end up having a few rounds of
> inlining thanks to

<snip> 

> So we may have "only" 28968 calls to cpumask_weight(), but it results
> in millions of expressions being expanded.

Yes, roughly 1500 expressions per call (:
 
> If we did some basic simplification of constant ops before inlining,
> that would likely help a lot.
> 
> But currently sparse does inline function expansion at type evaluation
> time - so long before it does any simplification of the tree at all.
> 
> So that explains why sparse happens to react _so_ badly to this thing.
> A real compiler would do inlining much later.
> 
> Inlining that early is partly because originally one of the design
> ideas in sparse was to make inline functions act basically as
> templates, so they'd react to the types of the context. But it really
> bites us in the ass here.
> 
> Luc, any ideas? Yes, this is solvable in the kernel, but it does show
> that sparse simply does a _lot_ of unnecessary work.

I never saw it so badly but it's not the first time I've bitten by
the very early inlining. Independently of this, it would be handy to
have an inliner at IR level, it shouldn't be very difficult but ...
OTOH, it should really be straightforward would be to separate the
current tree inliner from the type evaluation and instead run it just
after expansion. The downsides would be:
  * the tree would need to be walked once more;
  * this may make the expansion less useful but it could be run again
    after the inlining.

[ If we would like to keep inline-as-template it would just need to be
  able to detect such inlines at type evaluation and only inline those. ]

I'll look more closely at all of it during the WE.

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-netdev
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 20:41:44 +0000
Message-ID: <20200207204144.hh4n4o643oqpcwed () ltop ! local>
--------------------
On Fri, Feb 07, 2020 at 11:39:24AM -0800, Linus Torvalds wrote:
> On Fri, Feb 7, 2020 at 10:07 AM Linus Torvalds
> <torvalds@linux-foundation.org> wrote:
> >
> > I do think this is a good test-case for sparse. Luc, have you looked
> > at what it is that then makes sparse use *so* much memory for this one
> > line?
> 
> Looking at the profile, it's doing a lot of "copy_expression()".
> 
> Which comes from inlining.
> 
> I think the problem may be that with that macro expansion from hell we
> end up with 28968 copies of cpumask_weight(), and sparse will inline
> every one of them into the parse tree - even though basically none of
> them are _used_.

Yes, indeed. I was just what I saw too.

> In fact, it's worse than that: we end up having a few rounds of
> inlining thanks to

<snip> 

> So we may have "only" 28968 calls to cpumask_weight(), but it results
> in millions of expressions being expanded.

Yes, roughly 1500 expressions per call (:
 
> If we did some basic simplification of constant ops before inlining,
> that would likely help a lot.
> 
> But currently sparse does inline function expansion at type evaluation
> time - so long before it does any simplification of the tree at all.
> 
> So that explains why sparse happens to react _so_ badly to this thing.
> A real compiler would do inlining much later.
> 
> Inlining that early is partly because originally one of the design
> ideas in sparse was to make inline functions act basically as
> templates, so they'd react to the types of the context. But it really
> bites us in the ass here.
> 
> Luc, any ideas? Yes, this is solvable in the kernel, but it does show
> that sparse simply does a _lot_ of unnecessary work.

I never saw it so badly but it's not the first time I've bitten by
the very early inlining. Independently of this, it would be handy to
have an inliner at IR level, it shouldn't be very difficult but ...
OTOH, it should really be straightforward would be to separate the
current tree inliner from the type evaluation and instead run it just
after expansion. The downsides would be:
  * the tree would need to be walked once more;
  * this may make the expansion less useful but it could be run again
    after the inlining.

[ If we would like to keep inline-as-template it would just need to be
  able to detect such inlines at type evaluation and only inline those. ]

I'll look more closely at all of it during the WE.

-- Luc
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 21:09:32 +0000
Message-ID: <CAHk-=wgdCXgQyBSSx-ovfiZ7WFR6fStOZ_2R9mxkX3a+R5MkxQ () mail ! gmail ! com>
--------------------
On Fri, Feb 7, 2020 at 12:13 PM Alexei Starovoitov
<alexei.starovoitov@gmail.com> wrote:
>
> In addition to this patch I've tried:
> +#define __const_ilog2(n, unique_n) ({                  \
> +       typeof(n) unique_n = (n);                       \

Yeah, as you found out, this doesn't work for the case of having
global initializers or things like array sizes.

Which people do do - often nor directly, but through various size macros.

It's annoying, but one of the failures of C is having a nice form of
compile-time constant handling where you can do slightly smarter
arithmetic. The definition of a "const expression" is very very
limited, and hurts us exactly for the array declaration and constant
initializer case.

Oh well.

          Linus
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 21:22:49 +0000
Message-ID: <CAHk-=whvS9x5NKtOqcUgJeTY7dfdAHcEALJT53cy3P7Hzfgr1g () mail ! gmail ! com>
--------------------
--000000000000c479ce059e02fe60
Content-Type: text/plain; charset="UTF-8"

On Fri, Feb 7, 2020 at 12:41 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> I never saw it so badly but it's not the first time I've bitten by
> the very early inlining. Independently of this, it would be handy to
> have an inliner at IR level, it shouldn't be very difficult but ...
> OTOH, it should really be straightforward would be to separate the
> current tree inliner from the type evaluation and instead run it just
> after expansion. The downsides would be:
>   * the tree would need to be walked once more;

Actually, if we were to do the inlining _during_ expansion, we
wouldn't add a new phase.

>   * this may make the expansion less useful but it could be run again
>     after the inlining.

Same comment: how about doing it as part of the expansion phase?

This is where we handle the built-ins too, it would kind of make sense
to do inlining in expand_symbol_call(), I feel. An inline function is
a "builtin" that the user has defined, after all.

And if we do it in that phase, we'd automatically avoid it for
conditional expressions with a static conditional value, because
expansion does the obvious trivial simplification as it goes along,
and never expands the side that is trivially not seen.

Something like the attached completely broken patch. It builds but
doesn't work, because "inline_function()" is currently designed to
work during evaluation, not during expansion.

So the patch is complete garbage, but maybe could be the starting
point for something that works.

             Linus

--000000000000c479ce059e02fe60
Content-Type: text/x-patch; charset="US-ASCII"; name="broken.diff"
Content-Disposition: attachment; filename="broken.diff"
Content-Transfer-Encoding: base64
Content-ID: <f_k6co9evz0>
X-Attachment-Id: f_k6co9evz0

ZGlmZiAtLWdpdCBhL2V2YWx1YXRlLmMgYi9ldmFsdWF0ZS5jCmluZGV4IGYxYTI2NmJlLi5iN2Ji
MWY1MiAxMDA2NDQKLS0tIGEvZXZhbHVhdGUuYworKysgYi9ldmFsdWF0ZS5jCkBAIC0zMTA3LDIy
ICszMTA3LDYgQEAgc3RhdGljIGludCBldmFsdWF0ZV9zeW1ib2xfY2FsbChzdHJ1Y3QgZXhwcmVz
c2lvbiAqZXhwcikKIAlpZiAoY3R5cGUtPm9wICYmIGN0eXBlLT5vcC0+ZXZhbHVhdGUpCiAJCXJl
dHVybiBjdHlwZS0+b3AtPmV2YWx1YXRlKGV4cHIpOwogCi0JaWYgKGN0eXBlLT5jdHlwZS5tb2Rp
ZmllcnMgJiBNT0RfSU5MSU5FKSB7Ci0JCWludCByZXQ7Ci0JCXN0cnVjdCBzeW1ib2wgKmN1cnIg
PSBjdXJyZW50X2ZuOwotCi0JCWlmIChjdHlwZS0+ZGVmaW5pdGlvbikKLQkJCWN0eXBlID0gY3R5
cGUtPmRlZmluaXRpb247Ci0KLQkJY3VycmVudF9mbiA9IGN0eXBlLT5jdHlwZS5iYXNlX3R5cGU7
Ci0KLQkJcmV0ID0gaW5saW5lX2Z1bmN0aW9uKGV4cHIsIGN0eXBlKTsKLQotCQkvKiByZXN0b3Jl
IHRoZSBvbGQgZnVuY3Rpb24gKi8KLQkJY3VycmVudF9mbiA9IGN1cnI7Ci0JCXJldHVybiByZXQ7
Ci0JfQotCiAJcmV0dXJuIDA7CiB9CiAKZGlmZiAtLWdpdCBhL2V4cGFuZC5jIGIvZXhwYW5kLmMK
aW5kZXggMzY2MTJjODYuLmE0ZjI2NDYxIDEwMDY0NAotLS0gYS9leHBhbmQuYworKysgYi9leHBh
bmQuYwpAQCAtOTEwLDYgKzkxMCwxNSBAQCBzdGF0aWMgaW50IGV4cGFuZF9zeW1ib2xfY2FsbChz
dHJ1Y3QgZXhwcmVzc2lvbiAqZXhwciwgaW50IGNvc3QpCiAJaWYgKGZuLT50eXBlICE9IEVYUFJf
UFJFT1ApCiAJCXJldHVybiBTSURFX0VGRkVDVFM7CiAKKwlpZiAoY3R5cGUtPmN0eXBlLm1vZGlm
aWVycyAmIE1PRF9JTkxJTkUpIHsKKwkJc3RydWN0IHN5bWJvbCAqZGVmOworCisJCWRlZiA9IGN0
eXBlLT5kZWZpbml0aW9uID8gY3R5cGUtPmRlZmluaXRpb24gOiBjdHlwZTsKKwkJaWYgKGlubGlu
ZV9mdW5jdGlvbihleHByLCBkZWYpKQorCQkJcmV0dXJuIGV4cGFuZF9leHByZXNzaW9uKGV4cHIp
OworCX0KKworCiAJaWYgKGN0eXBlLT5vcCAmJiBjdHlwZS0+b3AtPmV4cGFuZCkKIAkJcmV0dXJu
IGN0eXBlLT5vcC0+ZXhwYW5kKGV4cHIsIGNvc3QpOwogCg==
--000000000000c479ce059e02fe60--
================================================================================

From: Daniel Borkmann <daniel () iogearbox ! net>
To: linux-netdev
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 22:04:50 +0000
Message-ID: <87b3934a-094f-28c1-c5ce-3792c1fa0356 () iogearbox ! net>
--------------------
On 2/7/20 9:18 AM, Martin KaFai Lau wrote:
> It was reported that the max_t, ilog2, and roundup_pow_of_two macros have
> exponential effects on the number of states in the sparse checker.
> 
> This patch breaks them up by calculating the "nbuckets" first so
> that the "bucket_log" only needs to take ilog2().
> 
> Fixes: 6ac99e8f23d4 ("bpf: Introduce bpf sk local storage")
> Reported-by: Randy Dunlap <rdunlap@infradead.org>
> Reported-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
> Signed-off-by: Martin KaFai Lau <kafai@fb.com>

Applied (& improved changelog to clarify it's not just sparse), thanks!
================================================================================

From: Daniel Borkmann <daniel () iogearbox ! net>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Fri, 07 Feb 2020 22:04:50 +0000
Message-ID: <87b3934a-094f-28c1-c5ce-3792c1fa0356 () iogearbox ! net>
--------------------
On 2/7/20 9:18 AM, Martin KaFai Lau wrote:
> It was reported that the max_t, ilog2, and roundup_pow_of_two macros have
> exponential effects on the number of states in the sparse checker.
> 
> This patch breaks them up by calculating the "nbuckets" first so
> that the "bucket_log" only needs to take ilog2().
> 
> Fixes: 6ac99e8f23d4 ("bpf: Introduce bpf sk local storage")
> Reported-by: Randy Dunlap <rdunlap@infradead.org>
> Reported-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
> Signed-off-by: Martin KaFai Lau <kafai@fb.com>

Applied (& improved changelog to clarify it's not just sparse), thanks!
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Sun, 09 Feb 2020 00:58:51 +0000
Message-ID: <CAHk-=whqDZUo6yARXMgwHSJRerXM4tWgMPV=MC9wR80YCEon1A () mail ! gmail ! com>
--------------------
On Sat, Feb 8, 2020 at 3:55 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> > Something like the attached completely broken patch. It builds but
> > doesn't work, because "inline_function()" is currently designed to
> > work during evaluation, not during expansion.
> >
> > So the patch is complete garbage, but maybe could be the starting
> > point for something that works.
>
> It was just missing the part with current_fn (needed for the evaluation)
> and some adjustment to avoid recursive expansions.

Oh, good. I looked at that current_fn thing and decided it shouldn't
possibly matter, so my hacked-up patch just dropped it. Blush. And
yeah, the recursion avoidance got broken because it only triggered
during evaluation and that wasn't where it was recursing any more.

Anyway, your fixed patch looks good, and the numbers look lovely. I
don't see why there would sometimes be extra memory use, but the patch
feels like the right thing to do regardless.

Thanks,
               Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH bpf] bpf: Improve bucket_log calculation logic
Date: Sun, 09 Feb 2020 12:19:50 +0000
Message-ID: <20200209121950.gxnfnyr2tpnuqz47 () ltop ! local>
--------------------
On Sat, Feb 08, 2020 at 04:58:51PM -0800, Linus Torvalds wrote:
> 
> Anyway, your fixed patch looks good, and the numbers look lovely. I
> don't see why there would sometimes be extra memory use, but the patch
> feels like the right thing to do regardless.

Yes, I'm quite happy with it so. Thank you for the suggestion.

For the cases with extra memory consumption, I've investigated the
most extreme one and it's quite interesting. The extra memory was
used for basic blocks, instructions and pseudos, so more linearized
code. I reduced it to:

	static inline int get_order(long size)
	{
		return __builtin_constant_p(size) ? 0 : 1;
	}
	
	int foo(void)
	{
		return get_order(0);
	}

Sparse used to not recognized the size as a constant (I don't
understand why but haven't investigated). Strangely, the builtin
without the conditional gave the expected result.

Now, with the patch doing the inlining during expansion, the size
is correctly recognized as a constant, with or without the conditional.
The extra linearized code comes from some complex expression that is
now selected instead of a function call (while reducing, I had the
vague impression that the expression should have expanded further
but I haven't check that yet).

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v1 01/28] misc: fix testcase typeof-safe ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 01/28] misc: fix testcase typeof-safe
Date: Tue, 19 May 2020 00:57:01 +0000
Message-ID: <20200519005728.84594-2-luc.vanoostenryck () gmail ! com>
--------------------
This testcase was marked as known-to-fail but it was
simply the expected error messages that were missing.

So, slightly reorganize the test a little bit, add the
expected messages and remove the 'known-to-fail' tag.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/typeof-safe.c | 26 ++++++++++++++++++++------
 1 file changed, 20 insertions(+), 6 deletions(-)

diff --git a/validation/typeof-safe.c b/validation/typeof-safe.c
index 614863fba381..508bd39204c5 100644
--- a/validation/typeof-safe.c
+++ b/validation/typeof-safe.c
@@ -2,16 +2,24 @@
 
 static void test_safe(void)
 {
-	int __safe obj, *ptr;
-	typeof(obj) var = obj;
-	typeof(ptr) ptr2 = ptr;
+	int obj;
+	int __safe *ptr;
+
+	int __safe *ptr2 = ptr;
+	typeof(ptr) ptr3 = ptr;
 	typeof(*ptr) var2 = obj;
-	typeof(*ptr) *ptr3 = ptr;
-	typeof(obj) *ptr4 = ptr;
+	int __safe  var3 = obj;
+	int *ptr4 = &obj;
+	int *ptr4 = ptr;		// KO
+
+	typeof(*ptr) sobj;
+	typeof(&sobj) ptr5 = &obj;
+	typeof(&sobj) ptr6 = ptr;	// KO
+
 	obj = obj;
 	ptr = ptr;
-	ptr = &obj;
 	obj = *ptr;
+	ptr = (int __safe *) &obj;
 }
 
 /*
@@ -19,5 +27,11 @@ static void test_safe(void)
  * check-known-to-fail
  *
  * check-error-start
+typeof-safe.c:13:21: warning: incorrect type in initializer (different modifiers)
+typeof-safe.c:13:21:    expected int *ptr4
+typeof-safe.c:13:21:    got int [safe] *ptr
+typeof-safe.c:17:30: warning: incorrect type in initializer (different modifiers)
+typeof-safe.c:17:30:    expected int *ptr6
+typeof-safe.c:17:30:    got int [safe] *ptr
  * check-error-end
  */
-- 
2.26.2

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v1 01/28] misc: fix testcase typeof-safe
Date: Wed, 20 May 2020 00:33:07 +0000
Message-ID: <422723ea-00aa-ee89-72aa-f4dddbd8da06 () ramsayjones ! plus ! com>
--------------------


On 19/05/2020 01:57, Luc Van Oostenryck wrote:
> This testcase was marked as known-to-fail but it was
> simply the expected error messages that were missing.
> 
> So, slightly reorganize the test a little bit, add the
> expected messages and remove the 'known-to-fail' tag.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  validation/typeof-safe.c | 26 ++++++++++++++++++++------
>  1 file changed, 20 insertions(+), 6 deletions(-)
> 
> diff --git a/validation/typeof-safe.c b/validation/typeof-safe.c
> index 614863fba381..508bd39204c5 100644
> --- a/validation/typeof-safe.c
> +++ b/validation/typeof-safe.c
> @@ -2,16 +2,24 @@
>  
>  static void test_safe(void)
>  {
> -	int __safe obj, *ptr;
> -	typeof(obj) var = obj;
> -	typeof(ptr) ptr2 = ptr;
> +	int obj;
> +	int __safe *ptr;
> +
> +	int __safe *ptr2 = ptr;
> +	typeof(ptr) ptr3 = ptr;
>  	typeof(*ptr) var2 = obj;
> -	typeof(*ptr) *ptr3 = ptr;
> -	typeof(obj) *ptr4 = ptr;
> +	int __safe  var3 = obj;
> +	int *ptr4 = &obj;
> +	int *ptr4 = ptr;		// KO

ptr4 declared twice - and sparse didn't complain?

ATB,
Ramsay Jones

> +
> +	typeof(*ptr) sobj;
> +	typeof(&sobj) ptr5 = &obj;
> +	typeof(&sobj) ptr6 = ptr;	// KO
> +
>  	obj = obj;
>  	ptr = ptr;
> -	ptr = &obj;
>  	obj = *ptr;
> +	ptr = (int __safe *) &obj;
>  }
>  
>  /*
> @@ -19,5 +27,11 @@ static void test_safe(void)
>   * check-known-to-fail
>   *
>   * check-error-start
> +typeof-safe.c:13:21: warning: incorrect type in initializer (different modifiers)
> +typeof-safe.c:13:21:    expected int *ptr4
> +typeof-safe.c:13:21:    got int [safe] *ptr
> +typeof-safe.c:17:30: warning: incorrect type in initializer (different modifiers)
> +typeof-safe.c:17:30:    expected int *ptr6
> +typeof-safe.c:17:30:    got int [safe] *ptr
>   * check-error-end
>   */
> 
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v1 01/28] misc: fix testcase typeof-safe
Date: Wed, 20 May 2020 15:34:53 +0000
Message-ID: <2de08a4e-ce53-8694-da00-c2c90334da65 () ramsayjones ! plus ! com>
--------------------


On 20/05/2020 01:33, Ramsay Jones wrote:
> On 19/05/2020 01:57, Luc Van Oostenryck wrote:
>> This testcase was marked as known-to-fail but it was
>> simply the expected error messages that were missing.
>>
>> So, slightly reorganize the test a little bit, add the
>> expected messages and remove the 'known-to-fail' tag.
>>
>> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>> ---
>>  validation/typeof-safe.c | 26 ++++++++++++++++++++------
>>  1 file changed, 20 insertions(+), 6 deletions(-)
>>
>> diff --git a/validation/typeof-safe.c b/validation/typeof-safe.c
>> index 614863fba381..508bd39204c5 100644
>> --- a/validation/typeof-safe.c
>> +++ b/validation/typeof-safe.c
>> @@ -2,16 +2,24 @@
>>  
>>  static void test_safe(void)
>>  {
>> -	int __safe obj, *ptr;
>> -	typeof(obj) var = obj;
>> -	typeof(ptr) ptr2 = ptr;
>> +	int obj;
>> +	int __safe *ptr;
>> +
>> +	int __safe *ptr2 = ptr;
>> +	typeof(ptr) ptr3 = ptr;
>>  	typeof(*ptr) var2 = obj;
>> -	typeof(*ptr) *ptr3 = ptr;
>> -	typeof(obj) *ptr4 = ptr;
>> +	int __safe  var3 = obj;
>> +	int *ptr4 = &obj;
>> +	int *ptr4 = ptr;		// KO
> 
> ptr4 declared twice - and sparse didn't complain?

Heh, I had a slightly different example in the test case
for my '{0}' initializer patch (but involving different
types as well).

I had a quick look at this and tried to use 'git-bisect' to
isolate the change which broke this. However, I couldn't find
a version of sparse that worked correctly! :D (I went all the
way back to v0.4.2 before giving up - several tagged releases
didn't even compile without some fix-ups, including v0.4.2).

Just FYI, this was my test-case:

  $ cat -n test-dup-decl.c
       1	#ifdef WORKS_OK
       2	static int sobj;
       3	static int *sptr4 = &sobj;
       4	static int *sptr4 = 0;
       5	#endif
       6	
       7	static void func(void)
       8	{
       9		int obj, *ptr;
      10		int *ptr4 = &obj;
      11		int *ptr4 = ptr;
      12		int a;
      13		float a;
      14	}
  $ 

  $ gcc -c test-dup-decl.c
  test-dup-decl.c: In function âfuncâ:
  test-dup-decl.c:11:7: error: redefinition of âptr4â
    int *ptr4 = ptr;
         ^~~~
  test-dup-decl.c:10:7: note: previous definition of âptr4â was here
    int *ptr4 = &obj;
         ^~~~
  test-dup-decl.c:13:8: error: conflicting types for âaâ
    float a;
          ^
  test-dup-decl.c:12:6: note: previous declaration of âaâ was here
    int a;
        ^
  $ 

  $ ./sparse test-dup-decl.c
  $ 

ATB,
Ramsay Jones


================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v1 01/28] misc: fix testcase typeof-safe
Date: Wed, 20 May 2020 16:12:59 +0000
Message-ID: <20200520161259.u4raoc4bujauzu5y () ltop ! local>
--------------------
On Wed, May 20, 2020 at 04:34:53PM +0100, Ramsay Jones wrote:
> On 20/05/2020 01:33, Ramsay Jones wrote:
> > On 19/05/2020 01:57, Luc Van Oostenryck wrote:
> >> +	int __safe  var3 = obj;
> >> +	int *ptr4 = &obj;
> >> +	int *ptr4 = ptr;		// KO
> > 
> > ptr4 declared twice - and sparse didn't complain?

Yes, I was surprised by this too.
 
> Heh, I had a slightly different example in the test case
> for my '{0}' initializer patch (but involving different
> types as well).
> 
> I had a quick look at this and tried to use 'git-bisect' to
> isolate the change which broke this. However, I couldn't find
> a version of sparse that worked correctly! :D (I went all the
> way back to v0.4.2 before giving up - several tagged releases
> didn't even compile without some fix-ups, including v0.4.2).

Yes, it's quite annoying when bisecting, but well ...
 
> Just FYI, this was my test-case:
> 
>   $ cat -n test-dup-decl.c
>        1	#ifdef WORKS_OK
>        2	static int sobj;
>        3	static int *sptr4 = &sobj;
>        4	static int *sptr4 = 0;
>        5	#endif
>        6	
>        7	static void func(void)
>        8	{
>        9		int obj, *ptr;
>       10		int *ptr4 = &obj;
>       11		int *ptr4 = ptr;
>       12		int a;
>       13		float a;
>       14	}
>   $ 
> 
>   $ gcc -c test-dup-decl.c
>   test-dup-decl.c: In function âfuncâ:
>   test-dup-decl.c:11:7: error: redefinition of âptr4â
>     int *ptr4 = ptr;
>          ^~~~
>   test-dup-decl.c:10:7: note: previous definition of âptr4â was here
>     int *ptr4 = &obj;
>          ^~~~
>   test-dup-decl.c:13:8: error: conflicting types for âaâ
>     float a;
>           ^
>   test-dup-decl.c:12:6: note: previous declaration of âaâ was here
>     int a;
>         ^
>   $ 
> 
>   $ ./sparse test-dup-decl.c
>   $ 

It seems that sparse detect the redefinition when the symbols are global
but not when they're local.

Thanks for noticing this.
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v1 02/28] misc: s/fntype/rettype/ ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v1 02/28] misc: s/fntype/rettype/
Date: Wed, 20 May 2020 16:39:30 +0000
Message-ID: <20200520163930.3jfjgqhahupj5ill () ltop ! local>
--------------------
On Wed, May 20, 2020 at 01:35:13AM +0100, Ramsay Jones wrote:
> On 19/05/2020 01:57, Luc Van Oostenryck wrote:
> > So, rename the variable holding the return type to 'rettype'
> > and only use 'fntype' for the one hoding the full function type.
> 
> s/hoding/holding/

Thanks for this and the ones in the other patches.
-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH v1 03/28] misc: always use the node for current_fn ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 03/28] misc: always use the node for current_fn
Date: Tue, 19 May 2020 00:57:03 +0000
Message-ID: <20200519005728.84594-4-luc.vanoostenryck () gmail ! com>
--------------------
At evaluation time and at expansion time, current_fn is set
to the function's base type (SYM_FN) but at parse time it's
set to its parent type (SYM_NODE).

Since current_fn is used to access the corresponding ident,
it should be set to the node type, not the base.

So, always set current_fn to the node type.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 4 ++--
 expand.c   | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 54cd5fa136e6..c18ae81df5ad 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3422,7 +3422,7 @@ static struct symbol *evaluate_symbol(struct symbol *sym)
 		if (sym->definition && sym->definition != sym)
 			return evaluate_symbol(sym->definition);
 
-		current_fn = base_type;
+		current_fn = sym;
 
 		examine_fn_arguments(base_type);
 		if (!base_type->stmt && base_type->inline_stmt)
@@ -3453,7 +3453,7 @@ static struct symbol *evaluate_return_expression(struct statement *stmt)
 	struct symbol *fntype, *rettype;
 
 	evaluate_expression(expr);
-	fntype = current_fn;
+	fntype = current_fn->ctype.base_type;
 	rettype = fntype->ctype.base_type;
 	if (!rettype || rettype == &void_ctype) {
 		if (expr && expr->ctype != &void_ctype)
diff --git a/expand.c b/expand.c
index e75598781b6c..ab296c730efd 100644
--- a/expand.c
+++ b/expand.c
@@ -918,7 +918,7 @@ static int expand_symbol_call(struct expression *expr, int cost)
 			struct symbol *fn = def->ctype.base_type;
 			struct symbol *curr = current_fn;
 
-			current_fn = fn;
+			current_fn = def;
 			evaluate_statement(expr->statement);
 			current_fn = curr;
 
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH v1 14/28] scope: extract bind_symbol_with_scope() from bind_symbol() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 14/28] scope: extract bind_symbol_with_scope() from bind_symbol()
Date: Tue, 19 May 2020 00:57:14 +0000
Message-ID: <20200519005728.84594-15-luc.vanoostenryck () gmail ! com>
--------------------
In most cases, the scope that must be used for a symbol is
given by its namespace.

However, in some situations a different scope must be used.
This is then set, for exemple by doing the lookup with
the wrong namespace (but corresponding to the desired scope)
and changing it just after to its correct value.

To avoid these contortions, extract from bind_symbol() a version
where the scope can be explicitly given: bind_symbol_with_scope().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.c | 13 +++++++++----
 symbol.h |  1 +
 2 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/symbol.c b/symbol.c
index c2e6f0b426b3..7044ab3f78ce 100644
--- a/symbol.c
+++ b/symbol.c
@@ -671,9 +671,8 @@ static void inherit_static(struct symbol *sym)
 	}
 }
 
-void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
+void bind_symbol_with_scope(struct symbol *sym, struct ident *ident, enum namespace ns, struct scope *scope)
 {
-	struct scope *scope;
 	if (sym->bound) {
 		sparse_error(sym->pos, "internal error: symbol type already bound");
 		return;
@@ -690,7 +689,6 @@ void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
 	sym->ident = ident;
 	sym->bound = 1;
 
-	scope = block_scope;
 	if (ns == NS_SYMBOL && toplevel(scope)) {
 		unsigned mod = MOD_ADDRESSABLE | MOD_TOPLEVEL;
 
@@ -704,11 +702,18 @@ void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
 		}
 		sym->ctype.modifiers |= mod;
 	}
+	bind_scope(sym, scope);
+}
+
+void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
+{
+	struct scope *scope = block_scope;;
+
 	if (ns == NS_MACRO)
 		scope = file_scope;
 	if (ns == NS_LABEL)
 		scope = function_scope;
-	bind_scope(sym, scope);
+	bind_symbol_with_scope(sym, ident, ns, scope);
 }
 
 struct symbol *create_symbol(int stream, const char *name, int type, int namespace)
diff --git a/symbol.h b/symbol.h
index 50dba78a654a..c297c778dfdf 100644
--- a/symbol.h
+++ b/symbol.h
@@ -332,6 +332,7 @@ extern void show_type_list(struct symbol *);
 extern void show_symbol_list(struct symbol_list *, const char *);
 extern void add_symbol(struct symbol_list **, struct symbol *);
 extern void bind_symbol(struct symbol *, struct ident *, enum namespace);
+extern void bind_symbol_with_scope(struct symbol *, struct ident *, enum namespace, struct scope *);
 
 extern struct symbol *examine_symbol_type(struct symbol *);
 extern struct symbol *examine_pointer_target(struct symbol *);
-- 
2.26.2

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v1 14/28] scope: extract bind_symbol_with_scope() from bind_symbol()
Date: Wed, 20 May 2020 00:44:12 +0000
Message-ID: <94c72b94-814a-ee32-b107-523f43ad9299 () ramsayjones ! plus ! com>
--------------------


On 19/05/2020 01:57, Luc Van Oostenryck wrote:
> In most cases, the scope that must be used for a symbol is
> given by its namespace.
> 
> However, in some situations a different scope must be used.
> This is then set, for exemple by doing the lookup with

s/exemple/example/

ATB,
Ramsay Jones

> the wrong namespace (but corresponding to the desired scope)
> and changing it just after to its correct value.
> 
> To avoid these contortions, extract from bind_symbol() a version
> where the scope can be explicitly given: bind_symbol_with_scope().
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  symbol.c | 13 +++++++++----
>  symbol.h |  1 +
>  2 files changed, 10 insertions(+), 4 deletions(-)
> 
> diff --git a/symbol.c b/symbol.c
> index c2e6f0b426b3..7044ab3f78ce 100644
> --- a/symbol.c
> +++ b/symbol.c
> @@ -671,9 +671,8 @@ static void inherit_static(struct symbol *sym)
>  	}
>  }
>  
> -void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
> +void bind_symbol_with_scope(struct symbol *sym, struct ident *ident, enum namespace ns, struct scope *scope)
>  {
> -	struct scope *scope;
>  	if (sym->bound) {
>  		sparse_error(sym->pos, "internal error: symbol type already bound");
>  		return;
> @@ -690,7 +689,6 @@ void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
>  	sym->ident = ident;
>  	sym->bound = 1;
>  
> -	scope = block_scope;
>  	if (ns == NS_SYMBOL && toplevel(scope)) {
>  		unsigned mod = MOD_ADDRESSABLE | MOD_TOPLEVEL;
>  
> @@ -704,11 +702,18 @@ void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
>  		}
>  		sym->ctype.modifiers |= mod;
>  	}
> +	bind_scope(sym, scope);
> +}
> +
> +void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
> +{
> +	struct scope *scope = block_scope;;
> +
>  	if (ns == NS_MACRO)
>  		scope = file_scope;
>  	if (ns == NS_LABEL)
>  		scope = function_scope;
> -	bind_scope(sym, scope);
> +	bind_symbol_with_scope(sym, ident, ns, scope);
>  }
>  
>  struct symbol *create_symbol(int stream, const char *name, int type, int namespace)
> diff --git a/symbol.h b/symbol.h
> index 50dba78a654a..c297c778dfdf 100644
> --- a/symbol.h
> +++ b/symbol.h
> @@ -332,6 +332,7 @@ extern void show_type_list(struct symbol *);
>  extern void show_symbol_list(struct symbol_list *, const char *);
>  extern void add_symbol(struct symbol_list **, struct symbol *);
>  extern void bind_symbol(struct symbol *, struct ident *, enum namespace);
> +extern void bind_symbol_with_scope(struct symbol *, struct ident *, enum namespace, struct scope *);
>  
>  extern struct symbol *examine_symbol_type(struct symbol *);
>  extern struct symbol *examine_pointer_target(struct symbol *);
> 
================================================================================


################################################################################

=== Thread: [PATCH v1 15/28] scope: __func__ is special ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 15/28] scope: __func__ is special
Date: Tue, 19 May 2020 00:57:15 +0000
Message-ID: <20200519005728.84594-16-luc.vanoostenryck () gmail ! com>
--------------------
__func__ needs to be in the namepsace for symbols: NS_SYMBOL
but doesn't follow the usual scope rules of them: it always
needs to be declared in the function scope.

So, use bind_symbol_scoped() instead of first using bind_symbol()
and then changing the namespace.
Also change the comment to better express that it's the scope
that is the unusual thing.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expression.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/expression.c b/expression.c
index 78e577cf10a1..ffb3c2dce4d5 100644
--- a/expression.c
+++ b/expression.c
@@ -122,9 +122,8 @@ static struct symbol *handle_func(struct token *token)
 	decl->ctype.modifiers = MOD_STATIC;
 	decl->endpos = token->pos;
 
-	/* function-scope, but in NS_SYMBOL */
-	bind_symbol(decl, ident, NS_LABEL);
-	decl->namespace = NS_SYMBOL;
+	/* NS_SYMBOL but in function-scope */
+	bind_symbol_with_scope(decl, ident, NS_SYMBOL, function_scope);
 
 	len = current_fn->ident->len;
 	string = __alloc_string(len + 1);
-- 
2.26.2

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v1 15/28] scope: __func__ is special
Date: Wed, 20 May 2020 00:45:50 +0000
Message-ID: <cbeaeb8a-698b-56e2-6e31-90547de54e89 () ramsayjones ! plus ! com>
--------------------


On 19/05/2020 01:57, Luc Van Oostenryck wrote:
> __func__ needs to be in the namepsace for symbols: NS_SYMBOL
> but doesn't follow the usual scope rules of them: it always
> needs to be declared in the function scope.
> 
> So, use bind_symbol_scoped() instead of first using bind_symbol()

s/bind_symbol_scoped/bind_symbol_with_scope/

ATB,
Ramsay Jones

> and then changing the namespace.
> Also change the comment to better express that it's the scope
> that is the unusual thing.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  expression.c | 5 ++---
>  1 file changed, 2 insertions(+), 3 deletions(-)
> 
> diff --git a/expression.c b/expression.c
> index 78e577cf10a1..ffb3c2dce4d5 100644
> --- a/expression.c
> +++ b/expression.c
> @@ -122,9 +122,8 @@ static struct symbol *handle_func(struct token *token)
>  	decl->ctype.modifiers = MOD_STATIC;
>  	decl->endpos = token->pos;
>  
> -	/* function-scope, but in NS_SYMBOL */
> -	bind_symbol(decl, ident, NS_LABEL);
> -	decl->namespace = NS_SYMBOL;
> +	/* NS_SYMBOL but in function-scope */
> +	bind_symbol_with_scope(decl, ident, NS_SYMBOL, function_scope);
>  
>  	len = current_fn->ident->len;
>  	string = __alloc_string(len + 1);
> 
================================================================================


################################################################################

=== Thread: [PATCH v1 16/28] scope: __label__ is special ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v1 16/28] scope: __label__ is special
Date: Wed, 20 May 2020 00:47:27 +0000
Message-ID: <92c02efb-7733-cca8-981d-b3d0c5b7909e () ramsayjones ! plus ! com>
--------------------


On 19/05/2020 01:57, Luc Van Oostenryck wrote:
> Labels declared wth __label__ are special because they must follow
> the block scope normally used for variables instad of using the

s/instad/instead/

> scope used for labels.
> 
> So, use bind_symbol_scoped() instead of first using bind_symbol()

s/bind_symbol_scoped/bind/symbol_with_scope/

ATB,
Ramsay Jones

> and then changing the namespace.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  parse.c | 3 +--
>  1 file changed, 1 insertion(+), 2 deletions(-)
> 
> diff --git a/parse.c b/parse.c
> index e23c5b64e8be..29e3f939166d 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -2569,8 +2569,7 @@ static struct token *label_statement(struct token *token)
>  	while (token_type(token) == TOKEN_IDENT) {
>  		struct symbol *sym = alloc_symbol(token->pos, SYM_LABEL);
>  		/* it's block-scope, but we want label namespace */
> -		bind_symbol(sym, token->ident, NS_SYMBOL);
> -		sym->namespace = NS_LABEL;
> +		bind_symbol_with_scope(sym, token->ident, NS_LABEL, block_scope);
>  		fn_local_symbol(sym);
>  		token = token->next;
>  		if (!match_op(token, ','))
> 
================================================================================


################################################################################

=== Thread: [PATCH v1 18/28] scope: make function_scope invalid outside functions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 18/28] scope: make function_scope invalid outside functions
Date: Tue, 19 May 2020 00:57:18 +0000
Message-ID: <20200519005728.84594-19-luc.vanoostenryck () gmail ! com>
--------------------
The scopes are mainly used for symbols corresponding to variables
and functions with this hiearchy:
* builtin
* global
* function
* block

But the function_scope is only used for labels and __func__ and
is meaningless outside a function.

So, mainly in preparation for some incoming changes, let
function_scope's parent be NULL instead of the builtin scope.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 scope.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/scope.c b/scope.c
index cc54f1e1760b..83cc34c44bf5 100644
--- a/scope.c
+++ b/scope.c
@@ -36,7 +36,7 @@
 static struct scope builtin_scope = { .next = &builtin_scope };
 
 struct scope	*block_scope = &builtin_scope,		// regular automatic variables etc
-		*function_scope = &builtin_scope,	// labels, arguments etc
+		*function_scope = NULL,			// __fun__, labels
 		*file_scope = &builtin_scope,		// static
 		*global_scope = &builtin_scope;		// externally visible
 
@@ -80,7 +80,6 @@ void start_file_scope(void)
 	file_scope = scope;
 
 	/* top-level stuff defaults to file scope, "extern" etc will choose global scope */
-	function_scope = scope;
 	block_scope = scope;
 }
 
@@ -138,6 +137,7 @@ void end_function_scope(void)
 {
 	end_scope(&block_scope);
 	end_scope(&function_scope);
+	function_scope = NULL;
 }
 
 int is_outer_scope(struct scope *scope)
-- 
2.26.2

================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH v1 18/28] scope: make function_scope invalid outside functions
Date: Tue, 19 May 2020 01:38:17 +0000
Message-ID: <CAHk-=wgSBgpXKfMD=yC1B6vH-YxP+6y_KUBuDODXB_i=K7sdNg () mail ! gmail ! com>
--------------------
On Mon, May 18, 2020 at 5:57 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> So, mainly in preparation for some incoming changes, let
> function_scope's parent be NULL instead of the builtin scope.

Hmm. Gcc nested functions?

Sparse doesn't _support_ them, but the symbol nesting part actually
does work, afaik. This looks like it might break it.

Yes, gcc function nesting is disgusting. But it's a thing.

Stupid test-case that almost works with sparse:

    int test(int a, int b)
    {
        inline int nested(int i)
        {
                return a*2 + i;
        }
        return nested(b);
    }

and by "almost works with sparse" I mean that it actually linearizes
correctly, even if it's mostly by mistake, and you get a warning about

    t.c:5:24: warning: unreplaced symbol 'a'

because sparse really doesn't support nested functions and it really
only works because of inlining.

            Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v1 18/28] scope: make function_scope invalid outside functions
Date: Tue, 19 May 2020 20:57:00 +0000
Message-ID: <20200519205700.n52dgvp4npgldrey () ltop ! local>
--------------------
On Mon, May 18, 2020 at 06:38:17PM -0700, Linus Torvalds wrote:
> On Mon, May 18, 2020 at 5:57 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > So, mainly in preparation for some incoming changes, let
> > function_scope's parent be NULL instead of the builtin scope.
> 
> Hmm. Gcc nested functions?
> 
> Sparse doesn't _support_ them, but the symbol nesting part actually
> does work, afaik. This looks like it might break it.

Hmm yes. I was barely aware that nested functions were at least parsed
but I had absolutely not internalized that and indeed this patch
assumes that leaving the function will return to the file scope.

But well this patch maybe made some sense at some stage but was
probably a bad idea, even more so with the nested functions.
So I'm dropping it and making the corresponding adjustments
in the next 2 patches.

Thank you for noticing this.

> Yes, gcc function nesting is disgusting. But it's a thing.
> 
> Stupid test-case that almost works with sparse:
> 
>     int test(int a, int b)
>     {
>         inline int nested(int i)
>         {
>                 return a*2 + i;
>         }
>         return nested(b);
>     }
> 
> and by "almost works with sparse" I mean that it actually linearizes
> correctly, even if it's mostly by mistake, and you get a warning about
> 
>     t.c:5:24: warning: unreplaced symbol 'a'
> 
> because sparse really doesn't support nested functions and it really
> only works because of inlining.

I see, interesting. I only saw this "unreplaced symbol" message a very
few tmes and never understood its cause (I don't think it was related
to a nested function but it makes more sense now).

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v1 19/28] scope: let labels have their own scope ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 19/28] scope: let labels have their own scope
Date: Tue, 19 May 2020 00:57:19 +0000
Message-ID: <20200519005728.84594-20-luc.vanoostenryck () gmail ! com>
--------------------
It's invalid to jump inside a statement expression.
So, concerning labels & gotos, a statement expression is
like a kind of scope.

So, in preparation for the detection of such jumps, create
these new scopes and open/close them when entering/leaving
statement expressions.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expression.c |  2 ++
 scope.c      | 19 ++++++++++++++++---
 scope.h      |  4 ++++
 3 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/expression.c b/expression.c
index ffb3c2dce4d5..f8a8f03e7402 100644
--- a/expression.c
+++ b/expression.c
@@ -71,7 +71,9 @@ struct token *parens_expression(struct token *token, struct expression **expr, c
 		struct statement *stmt = alloc_statement(token->pos, STMT_COMPOUND);
 		*expr = e;
 		e->statement = stmt;
+		start_label_scope();
 		token = compound_statement(token->next, stmt);
+		end_label_scope();
 		token = expect(token, '}', "at end of statement expression");
 	} else
 		token = parse_expression(token, expr);
diff --git a/scope.c b/scope.c
index 83cc34c44bf5..2e3a1c37ec15 100644
--- a/scope.c
+++ b/scope.c
@@ -36,7 +36,8 @@
 static struct scope builtin_scope = { .next = &builtin_scope };
 
 struct scope	*block_scope = &builtin_scope,		// regular automatic variables etc
-		*function_scope = NULL,			// __fun__, labels
+		*label_scope = NULL,			// expr-stmt labels
+		*function_scope = NULL,			// __fun__
 		*file_scope = &builtin_scope,		// static
 		*global_scope = &builtin_scope;		// externally visible
 
@@ -90,8 +91,9 @@ void start_block_scope(void)
 
 void start_function_scope(void)
 {
-	start_scope(&function_scope);
 	start_scope(&block_scope);
+	start_scope(&label_scope);
+	function_scope = label_scope;
 }
 
 static void remove_symbol_scope(struct symbol *sym)
@@ -136,8 +138,19 @@ void end_block_scope(void)
 void end_function_scope(void)
 {
 	end_scope(&block_scope);
-	end_scope(&function_scope);
+	end_label_scope();
 	function_scope = NULL;
+	label_scope = NULL;
+}
+
+void start_label_scope(void)
+{
+	start_scope(&label_scope);
+}
+
+void end_label_scope(void)
+{
+	end_scope(&label_scope);
 }
 
 int is_outer_scope(struct scope *scope)
diff --git a/scope.h b/scope.h
index 83741459eb6a..ddcb90bd146b 100644
--- a/scope.h
+++ b/scope.h
@@ -34,6 +34,7 @@ struct scope {
 
 extern struct scope
 		*block_scope,
+		*label_scope,
 		*function_scope,
 		*file_scope,
 		*global_scope;
@@ -53,6 +54,9 @@ extern void end_block_scope(void);
 extern void start_function_scope(void);
 extern void end_function_scope(void);
 
+extern void start_label_scope(void);
+extern void end_label_scope(void);
+
 extern void set_current_scope(struct symbol *);
 extern void bind_scope(struct symbol *, struct scope *);
 extern void rebind_scope(struct symbol *, struct scope *);
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH v1 20/28] scope: add is_in_scope() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 20/28] scope: add is_in_scope()
Date: Tue, 19 May 2020 00:57:20 +0000
Message-ID: <20200519005728.84594-21-luc.vanoostenryck () gmail ! com>
--------------------
Add an helper to check if a scope is included into another one.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 scope.c | 9 +++++++++
 scope.h | 2 ++
 2 files changed, 11 insertions(+)

diff --git a/scope.c b/scope.c
index 2e3a1c37ec15..017c0dcd8600 100644
--- a/scope.c
+++ b/scope.c
@@ -162,3 +162,12 @@ int is_outer_scope(struct scope *scope)
 	return 1;
 }
 
+int is_in_scope(struct scope *outer, struct scope *inner)
+{
+	while (inner != outer) {
+		if (!inner)
+			return 0;
+		inner = inner->next;
+	}
+	return 1;
+}
diff --git a/scope.h b/scope.h
index ddcb90bd146b..36a56d6adf1d 100644
--- a/scope.h
+++ b/scope.h
@@ -62,4 +62,6 @@ extern void bind_scope(struct symbol *, struct scope *);
 extern void rebind_scope(struct symbol *, struct scope *);
 
 extern int is_outer_scope(struct scope *);
+extern int is_in_scope(struct scope *outer, struct scope *inner);
+
 #endif
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH v1 22/28] bad-goto: jumping inside a statemet expression is an error ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 22/28] bad-goto: jumping inside a statemet expression is an error
Date: Tue, 19 May 2020 00:57:22 +0000
Message-ID: <20200519005728.84594-23-luc.vanoostenryck () gmail ! com>
--------------------
It's invalid to jump inside a statement expression.

So, detect such jumps, issue an error message and mark the
function as useless for linearization since the resulting IR
would be invalid.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                                       | 30 ++++++++++++++++---
 parse.h                                       |  1 +
 validation/label-scope2.c                     |  1 -
 validation/label-stmt-expr0.c                 |  1 -
 validation/label-stmt-expr1.c                 |  1 -
 validation/label-stmt-expr2.c                 |  1 -
 .../linear/goto-stmt-expr-conditional.c       |  1 -
 .../linear/goto-stmt-expr-short-circuit.c     |  1 -
 8 files changed, 27 insertions(+), 10 deletions(-)

diff --git a/parse.c b/parse.c
index bf45e3b0ea44..b9d4940e77fb 100644
--- a/parse.c
+++ b/parse.c
@@ -2480,6 +2480,27 @@ static struct token *parse_switch_statement(struct token *token, struct statemen
 	return token;
 }
 
+static void warn_label_usage(struct position def, struct position use, struct ident *ident)
+{
+	const char *id = show_ident(ident);
+	sparse_error(use, "label '%s' used outside statement expression", id);
+	info(def, "   label '%s' defined here", id);
+	current_fn->bogus_linear = 1;
+}
+
+void check_label_usage(struct symbol *label, struct position use_pos)
+{
+	struct statement *def = label->stmt;
+
+	if (def) {
+		if (!is_in_scope(def->label_scope, label_scope))
+			warn_label_usage(def->pos, use_pos, label->ident);
+	} else if (!label->label_scope) {
+		label->label_scope = label_scope;
+		label->label_pos = use_pos;
+	}
+}
+
 static struct token *parse_goto_statement(struct token *token, struct statement *stmt)
 {
 	stmt->type = STMT_GOTO;
@@ -2490,10 +2511,7 @@ static struct token *parse_goto_statement(struct token *token, struct statement
 	} else if (token_type(token) == TOKEN_IDENT) {
 		struct symbol *label = label_symbol(token);
 		stmt->goto_label = label;
-		if (!label->stmt && !label->label_scope) {
-			label->label_scope = label_scope;
-			label->label_pos = stmt->pos;
-		}
+		check_label_usage(label, stmt->pos);
 		token = token->next;
 	} else {
 		sparse_error(token->pos, "Expected identifier or goto expression");
@@ -2555,6 +2573,10 @@ static struct token *statement(struct token *token, struct statement **tree)
 			stmt->type = STMT_LABEL;
 			stmt->label_identifier = s;
 			stmt->label_scope = label_scope;
+			if (s->label_scope) {
+				if (!is_in_scope(label_scope, s->label_scope))
+					warn_label_usage(stmt->pos, s->label_pos, s->ident);
+			}
 			s->stmt = stmt;
 			return statement(token, &stmt->label_statement);
 		}
diff --git a/parse.h b/parse.h
index daef243938b2..2cfdd872e621 100644
--- a/parse.h
+++ b/parse.h
@@ -125,6 +125,7 @@ extern struct statement_list *function_computed_goto_list;
 
 extern struct token *parse_expression(struct token *, struct expression **);
 extern struct symbol *label_symbol(struct token *token);
+extern void check_label_usage(struct symbol *label, struct position use_pos);
 
 extern int show_statement(struct statement *);
 extern void show_statement_list(struct statement_list *, const char *);
diff --git a/validation/label-scope2.c b/validation/label-scope2.c
index 8c04ac6525e5..448647528dc6 100644
--- a/validation/label-scope2.c
+++ b/validation/label-scope2.c
@@ -23,7 +23,6 @@ a:
 
 /*
  * check-name: label-scope2
- * check-known-to-fail
  *
  * check-error-start
 label-scope2.c:20:17: error: label 'a' used outside statement expression
diff --git a/validation/label-stmt-expr0.c b/validation/label-stmt-expr0.c
index 66a6490241bd..5fc452ab0d15 100644
--- a/validation/label-stmt-expr0.c
+++ b/validation/label-stmt-expr0.c
@@ -26,7 +26,6 @@ l:		 1;
 /*
  * check-name: label-stmt-expr0
  * check-command: sparse -Wno-decl $file
- * check-known-to-fail
  *
  * check-error-start
 label-stmt-expr0.c:6:9: error: label 'l' used outside statement expression
diff --git a/validation/label-stmt-expr1.c b/validation/label-stmt-expr1.c
index 339217dcb999..32a89aad4e1f 100644
--- a/validation/label-stmt-expr1.c
+++ b/validation/label-stmt-expr1.c
@@ -18,7 +18,6 @@ l:
 
 /*
  * check-name: label-stmt-expr1
- * check-known-to-fail
  *
  * check-error-start
 label-stmt-expr1.c:3:9: error: label 'l' used outside statement expression
diff --git a/validation/label-stmt-expr2.c b/validation/label-stmt-expr2.c
index 7a38e3799c55..8c54477a4cc3 100644
--- a/validation/label-stmt-expr2.c
+++ b/validation/label-stmt-expr2.c
@@ -30,7 +30,6 @@ l:
 
 /*
  * check-name: label-stmt-expr2
- * check-known-to-fail
  *
  * check-error-start
 label-stmt-expr2.c:3:9: error: label 'l' used outside statement expression
diff --git a/validation/linear/goto-stmt-expr-conditional.c b/validation/linear/goto-stmt-expr-conditional.c
index 6576052b50ac..bbfcb3ebc039 100644
--- a/validation/linear/goto-stmt-expr-conditional.c
+++ b/validation/linear/goto-stmt-expr-conditional.c
@@ -20,7 +20,6 @@ a:
 /*
  * check-name: goto-stmt-expr-conditional
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-error-ignore
  * check-output-ignore
diff --git a/validation/linear/goto-stmt-expr-short-circuit.c b/validation/linear/goto-stmt-expr-short-circuit.c
index 426315e69fbd..a5953e73bc93 100644
--- a/validation/linear/goto-stmt-expr-short-circuit.c
+++ b/validation/linear/goto-stmt-expr-short-circuit.c
@@ -24,7 +24,6 @@ inside:
 /*
  * check-name: goto-stmt-expr-short-circuit
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-error-ignore
  * check-output-ignore
-- 
2.26.2

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v1 22/28] bad-goto: jumping inside a statemet expression is an error
Date: Wed, 20 May 2020 16:37:42 +0000
Message-ID: <20200520163742.qvqp6nqwge5ezmoi () ltop ! local>
--------------------
On Wed, May 20, 2020 at 01:53:51AM +0100, Ramsay Jones wrote:
> On 19/05/2020 01:57, Luc Van Oostenryck wrote:
> > It's invalid to jump inside a statement expression.
> > 
> > So, detect such jumps, issue an error message and mark the
> > function as useless for linearization since the resulting IR
> > would be invalid.

...

> > +static void warn_label_usage(struct position def, struct position use, struct ident *ident)
> 
> you are issuing an error report from this function, so should it be
> called, something like, 'label_usage_error'?

Yes, it's a bit confusing. I hesitated on the name when writting it.
The logic is that most functions in this file (and other files too)
are named following the verb+object pattern and I don't have a good
(short) verb for 'issue an diagnostic message'. 'label_usage_error'
sounds to me more like the name for a variable. In standardese
maybe 'diagnose' could be used but ... no, thanks. The way I see it
is that the verb/action 'warn' can be realized in 2 ways:
issue a warning message or issue an error message.

In fact, I really would prefer to fold this function with its check.
It was how it was written at some stage but the function needed 5
arguments and was quite hard to read.
 
Best regards,
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v1 23/28] bad-goto: label expression inside a statement expression is UB ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 23/28] bad-goto: label expression inside a statement expression is UB
Date: Tue, 19 May 2020 00:57:23 +0000
Message-ID: <20200519005728.84594-24-luc.vanoostenryck () gmail ! com>
--------------------
More exactly, what is undefined is to jump inside the statement
expression with a computed goto.

Of course, once the address of such a label is taken, it's generaly
impossible to track if it will be used or not to jump inside the
statement expression.

So, for now, handle taking the address of such a label from outside
the statement expression, exactly as if a computed goto is effectively
done from there and so issue an error message and also mark the function
as useless for linearization.

Note: this is only partially correct since:
      1) the address could be taken from outside the statement
         and never used for a computed goto.
      2) the address could be taken from outside the statement
         but the corresponding computed goto only done from
         inside, which is perfectly fine.
      3) the address could be taken from inside but a computed
         goto done from outside.

Note: the real problem, like for the regular goto, is that the
      statement expression can be eliminated before linearization,
      the correspondng gotos corresponding then to branches to
      unexistent BBs.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expression.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/expression.c b/expression.c
index f8a8f03e7402..bbbc24e6b561 100644
--- a/expression.c
+++ b/expression.c
@@ -691,6 +691,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 				sym->ctype.modifiers |= MOD_ADDRESSABLE;
 				add_symbol(&function_computed_target_list, sym);
 			}
+			check_label_usage(sym, token->pos);
 			label->flags = CEF_ADDR;
 			label->label_symbol = sym;
 			*tree = label;
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH v1 24/28] bad-goto: extract check_label_declaration() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 24/28] bad-goto: extract check_label_declaration()
Date: Tue, 19 May 2020 00:57:24 +0000
Message-ID: <20200519005728.84594-25-luc.vanoostenryck () gmail ! com>
--------------------
Extract this helper from evaluate_goto_statement().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 22 ++++++++++++++++------
 1 file changed, 16 insertions(+), 6 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 21d5d761627f..b272e3f642b2 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3257,6 +3257,21 @@ static struct symbol *evaluate_offsetof(struct expression *expr)
 	return size_t_ctype;
 }
 
+static void check_label_declaration(struct position pos, struct symbol *label)
+{
+	switch (label->namespace) {
+	case NS_LABEL:
+		if (label->stmt)
+			break;
+		sparse_error(pos, "label '%s' was not declared", show_ident(label->ident));
+		/* fallthrough */
+	case NS_NONE:
+		current_fn->bogus_linear = 1;
+	default:
+		break;
+	}
+}
+
 struct symbol *evaluate_expression(struct expression *expr)
 {
 	if (!expr)
@@ -3748,12 +3763,7 @@ static void evaluate_goto_statement(struct statement *stmt)
 		return;
 	}
 
-	if (label->namespace == NS_LABEL && !label->stmt) {
-		sparse_error(stmt->pos, "label '%s' was not declared", show_ident(label->ident));
-		current_fn->bogus_linear = 1;
-	}
-	if (label->namespace == NS_NONE)
-		current_fn->bogus_linear = 1;
+	check_label_declaration(stmt->pos, label);
 }
 
 struct symbol *evaluate_statement(struct statement *stmt)
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH v1 27/28] bad-label: mark labels as used when needed ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 27/28] bad-label: mark labels as used when needed
Date: Tue, 19 May 2020 00:57:27 +0000
Message-ID: <20200519005728.84594-28-luc.vanoostenryck () gmail ! com>
--------------------
In most cases symbols are automatically marked as being used via
a successfull call to lookup_symbols(), the idea being that the
symbol will be created at its declaration and then any (successfull)
lookup will correspond to an use.

For labels, things are slightly different because labels are
created on-demand via label_symbol() and their use can precede their
'declaration'. And of, course, label_symbol() has no ways to know
if it is used for a definition or an use.

So, fix this by adding an argument to label_symbol(), explictly
telling if the call correspond to an use or not.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expression.c |  2 +-
 parse.c      | 10 ++++++----
 parse.h      |  2 +-
 3 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/expression.c b/expression.c
index bbbc24e6b561..99a6d7568222 100644
--- a/expression.c
+++ b/expression.c
@@ -686,7 +686,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
 		if (match_op(token, SPECIAL_LOGICAL_AND) &&
 		    token_type(token->next) == TOKEN_IDENT) {
 			struct expression *label = alloc_expression(token->pos, EXPR_LABEL);
-			struct symbol *sym = label_symbol(token->next);
+			struct symbol *sym = label_symbol(token->next, 1);
 			if (!(sym->ctype.modifiers & MOD_ADDRESSABLE)) {
 				sym->ctype.modifiers |= MOD_ADDRESSABLE;
 				add_symbol(&function_computed_target_list, sym);
diff --git a/parse.c b/parse.c
index b9d4940e77fb..a8e4a02e90e4 100644
--- a/parse.c
+++ b/parse.c
@@ -726,12 +726,14 @@ static struct symbol * alloc_indirect_symbol(struct position pos, struct ctype *
  * it also ends up using function scope instead of the
  * regular symbol scope.
  */
-struct symbol *label_symbol(struct token *token)
+struct symbol *label_symbol(struct token *token, int used)
 {
 	struct symbol *sym = lookup_symbol(token->ident, NS_LABEL);
 	if (!sym) {
 		sym = alloc_symbol(token->pos, SYM_LABEL);
 		bind_symbol(sym, token->ident, NS_LABEL);
+		if (used)
+			sym->used = 1;
 		fn_local_symbol(sym);
 	}
 	return sym;
@@ -2139,7 +2141,7 @@ static struct token *parse_asm_labels(struct token *token, struct statement *stm
 		token = token->next; /* skip ':' and ',' */
 		if (token_type(token) != TOKEN_IDENT)
 			return token;
-		label = label_symbol(token);
+		label = label_symbol(token, 1);
 		add_symbol(labels, label);
 		token = token->next;
 	} while (match_op(token, ','));
@@ -2509,7 +2511,7 @@ static struct token *parse_goto_statement(struct token *token, struct statement
 		token = parse_expression(token->next, &stmt->goto_expression);
 		add_statement(&function_computed_goto_list, stmt);
 	} else if (token_type(token) == TOKEN_IDENT) {
-		struct symbol *label = label_symbol(token);
+		struct symbol *label = label_symbol(token, 1);
 		stmt->goto_label = label;
 		check_label_usage(label, stmt->pos);
 		token = token->next;
@@ -2563,7 +2565,7 @@ static struct token *statement(struct token *token, struct statement **tree)
 			return s->op->statement(token, stmt);
 
 		if (match_op(token->next, ':')) {
-			struct symbol *s = label_symbol(token);
+			struct symbol *s = label_symbol(token, 0);
 			token = skip_attributes(token->next->next);
 			if (s->stmt) {
 				sparse_error(stmt->pos, "label '%s' redefined", show_ident(s->ident));
diff --git a/parse.h b/parse.h
index 2cfdd872e621..5ac9a23ba363 100644
--- a/parse.h
+++ b/parse.h
@@ -124,7 +124,7 @@ extern struct symbol_list *function_computed_target_list;
 extern struct statement_list *function_computed_goto_list;
 
 extern struct token *parse_expression(struct token *, struct expression **);
-extern struct symbol *label_symbol(struct token *token);
+extern struct symbol *label_symbol(struct token *token, int used);
 extern void check_label_usage(struct symbol *label, struct position use_pos);
 
 extern int show_statement(struct statement *);
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH v1 28/28] bad-label: respect attribute((unused)) ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v1 28/28] bad-label: respect attribute((unused))
Date: Tue, 19 May 2020 00:57:28 +0000
Message-ID: <20200519005728.84594-29-luc.vanoostenryck () gmail ! com>
--------------------
Currently, attributes on labels were simply ignored. This was fine
since nothing was done wth them anyway.

But now that Sparse can give a warning for unused labels it would
be nice to also support the attribute 'unused' not to issues the
warning when not desired.

So, add a small helper around handle_attributes() and use this
instead of skipping the attributes.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                   | 11 ++++++++++-
 scope.c                   |  2 ++
 symbol.h                  |  1 +
 validation/label-unused.c |  6 ++++++
 4 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/parse.c b/parse.c
index a8e4a02e90e4..3cd84a3c7703 100644
--- a/parse.c
+++ b/parse.c
@@ -2554,6 +2554,15 @@ static struct token *parse_range_statement(struct token *token, struct statement
 	return expect(token, ';', "after range statement");
 }
 
+static struct token *handle_label_attributes(struct token *token, struct symbol *label)
+{
+	struct decl_state ctx = { };
+
+	token = handle_attributes(token, &ctx, KW_ATTRIBUTE);
+	label->label_modifiers = ctx.ctype.modifiers;
+	return token;
+}
+
 static struct token *statement(struct token *token, struct statement **tree)
 {
 	struct statement *stmt = alloc_statement(token->pos, STMT_NONE);
@@ -2566,7 +2575,7 @@ static struct token *statement(struct token *token, struct statement **tree)
 
 		if (match_op(token->next, ':')) {
 			struct symbol *s = label_symbol(token, 0);
-			token = skip_attributes(token->next->next);
+			token = handle_label_attributes(token->next->next, s);
 			if (s->stmt) {
 				sparse_error(stmt->pos, "label '%s' redefined", show_ident(s->ident));
 				// skip the label to avoid multiple definitions
diff --git a/scope.c b/scope.c
index 03593d823d6d..4c1badb2c135 100644
--- a/scope.c
+++ b/scope.c
@@ -155,6 +155,8 @@ void end_label_scope(void)
 	FOR_EACH_PTR(label_scope->symbols, sym) {
 		if (!sym->stmt || sym->used)
 			continue;
+		if (sym->label_modifiers & MOD_UNUSED)
+			continue;
 		warning(sym->pos, "unused label '%s'", show_ident(sym->ident));
 	} END_FOR_EACH_PTR(sym);
 
diff --git a/symbol.h b/symbol.h
index 2293d06dd4fb..6f90479505cc 100644
--- a/symbol.h
+++ b/symbol.h
@@ -170,6 +170,7 @@ struct symbol {
 		struct /* NS_LABEL */ {
 			struct scope *label_scope;
 			struct position label_pos;
+			unsigned long label_modifiers;
 		};
 		struct /* NS_SYMBOL */ {
 			unsigned long	offset;
diff --git a/validation/label-unused.c b/validation/label-unused.c
index a654ef7742be..e3f255e1b5de 100644
--- a/validation/label-unused.c
+++ b/validation/label-unused.c
@@ -13,6 +13,12 @@ l:
 	});
 }
 
+static void baz(void)
+{
+l: __attribute__((unused));
+	return;
+}
+
 /*
  * check-name: label-unused
  *
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH v1] sindex: allow indexing outside the project tree ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH v1] sindex: allow indexing outside the project tree
Date: Thu, 30 Jul 2020 15:22:00 +0000
Message-ID: <20200730152159.GC6956 () redhat ! com>
--------------------
On 07/30, Alexey Gladkov wrote:
>
> One possible way to compile the linux kernel is by using the O=<DIR>
> parameter to place all generated files outside the source tree.
>
> Prior to this patch, sindex filters processed sources to exclude system
> files. The base directory of the project was the current directory.
>
> When compiled outside of the source tree, this may not be the case.
> This patch adds a parameter and an environment variable to specify
> the source tree.
>
> You can use it like this:
>
> $ make O=$PWD-build C=2 CHECK="sindex -B $PWD add --"
>
> This parameter is also needed for searching if you want to display
> the source code line because sindex does not store lines in the database
> but reads them from source files.

Thanks, looks good to me.

Oleg.

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v1] sindex: allow indexing outside the project tree
Date: Thu, 30 Jul 2020 20:06:36 +0000
Message-ID: <20200730200636.axihcb36kkdhzsn6 () ltop ! local>
--------------------
On Thu, Jul 30, 2020 at 03:20:33PM +0200, Alexey Gladkov wrote:
> One possible way to compile the linux kernel is by using the O=<DIR>
> parameter to place all generated files outside the source tree.
> 
> Prior to this patch, sindex filters processed sources to exclude system
> files. The base directory of the project was the current directory.
> 
> When compiled outside of the source tree, this may not be the case.
> This patch adds a parameter and an environment variable to specify
> the source tree.
> 
> You can use it like this:
> 
> $ make O=$PWD-build C=2 CHECK="sindex -B $PWD add --"
> 
> This parameter is also needed for searching if you want to display
> the source code line because sindex does not store lines in the database
> but reads them from source files.

Thanks. Applied & pushed.

-- Luc 
================================================================================

From: ebiederm () xmission ! com (Eric W !  Biederman)
To: linux-sparse
Subject: Re: [PATCH v1] sindex: allow indexing outside the project tree
Date: Thu, 30 Jul 2020 21:02:12 +0000
Message-ID: <87d04c67jf.fsf () x220 ! int ! ebiederm ! org>
--------------------
Alexey Gladkov <gladkov.alexey@gmail.com> writes:

> One possible way to compile the linux kernel is by using the O=<DIR>
> parameter to place all generated files outside the source tree.
>
> Prior to this patch, sindex filters processed sources to exclude system
> files. The base directory of the project was the current directory.
>
> When compiled outside of the source tree, this may not be the case.
> This patch adds a parameter and an environment variable to specify
> the source tree.
>
> You can use it like this:
>
> $ make O=$PWD-build C=2 CHECK="sindex -B $PWD add --"
>
> This parameter is also needed for searching if you want to display
> the source code line because sindex does not store lines in the database
> but reads them from source files.

Tested-by: "Eric W. Biederman" <ebiederm@xmission.com>

This simple little example search now works for me:

sindex --database=$PWD-build/sindex.sqlite search -m w task_struct.pid 

> Signed-off-by: Alexey Gladkov <gladkov.alexey@gmail.com>
> ---
>  sindex.c | 21 +++++++++++++++++----
>  1 file changed, 17 insertions(+), 4 deletions(-)
>
> diff --git a/sindex.c b/sindex.c
> index 22836a95..bff6d8c4 100644
> --- a/sindex.c
> +++ b/sindex.c
> @@ -101,11 +101,13 @@ static void show_help(int ret)
>  	    "\n"
>  	    "Options:\n"
>  	    "  -D, --database=FILE    Specify database file (default: %2$s);\n"
> +	    "  -B, --basedir=DIR      Define project top directory (default is the current directory);\n"
>  	    "  -v, --verbose          Show information about what is being done;\n"
>  	    "  -h, --help             Show this text and exit.\n"
>  	    "\n"
>  	    "Environment:\n"
>  	    "  SINDEX_DATABASE        Database file location.\n"
> +	    "  SINDEX_BASEDIR         Project top directory.\n"
>  	    "\n"
>  	    "Report bugs to authors.\n"
>  	    "\n",
> @@ -125,9 +127,6 @@ static void show_help_add(int ret)
>  	    "  -v, --verbose          Show information about what is being done;\n"
>  	    "  -h, --help             Show this text and exit.\n"
>  	    "\n"
> -	    "Environment:\n"
> -	    "  SINDEX_BASEDIRE        Project top directory.\n"
> -	    "\n"
>  	    "Report bugs to authors.\n"
>  	    "\n",
>  	    progname);
> @@ -251,21 +250,26 @@ static void parse_cmdline(int argc, char **argv)
>  {
>  	static const struct option long_options[] = {
>  		{ "database", required_argument, NULL, 'D' },
> +		{ "basedir", required_argument, NULL, 'B' },
>  		{ "verbose", no_argument, NULL, 'v' },
>  		{ "help", no_argument, NULL, 'h' },
>  		{ NULL }
>  	};
>  	int c;
> +	char *basedir = getenv("SINDEX_BASEDIR");
>  	char *env;
>  
>  	if ((env = getenv("SINDEX_DATABASE")) != NULL)
>  		sindex_dbfile = env;
>  
> -	while ((c = getopt_long(argc, argv, "+D:vh", long_options, NULL)) != -1) {
> +	while ((c = getopt_long(argc, argv, "+B:D:vh", long_options, NULL)) != -1) {
>  		switch (c) {
>  			case 'D':
>  				sindex_dbfile = optarg;
>  				break;
> +			case 'B':
> +				basedir = optarg;
> +				break;
>  			case 'v':
>  				sindex_verbose++;
>  				break;
> @@ -278,6 +282,12 @@ static void parse_cmdline(int argc, char **argv)
>  		message("command required");
>  		show_usage();
>  	}
> +
> +	if (basedir) {
> +		if (!realpath(basedir, cwd))
> +			sindex_error(1, errno, "unable to get project base directory");
> +		n_cwd = strlen(cwd);
> +	}
>  }
>  
>  static void parse_cmdline_add(int argc, char **argv)
> @@ -1016,6 +1026,9 @@ static void command_search(int argc, char **argv)
>  	char *dberr = NULL;
>  	sqlite3_str *query = sqlite3_str_new(sindex_db);
>  
> +	if (chdir(cwd) < 0)
> +		sindex_error(1, errno, "unable to change directory: %s", cwd);
> +
>  	if (query_appendf(query,
>  	                  "SELECT"
>  	                  " file.name,"
================================================================================


################################################################################

=== Thread: [PATCH v2 04/16] add testcases for type attributes ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v2 04/16] add testcases for type attributes
Date: Mon, 28 Dec 2020 16:13:54 +0000
Message-ID: <f39438bd-3ab3-b827-a488-510b49351eb5 () ramsayjones ! plus ! com>
--------------------


On 26/12/2020 17:51, Luc Van Oostenryck wrote:
> Currently, type attributes are not handled correctly.
> 
> Add some testcases for them.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  validation/type-attribute-align.c | 20 ++++++++++++++++++
>  validation/type-attribute-as.c    | 34 +++++++++++++++++++++++++++++++
>  validation/type-attribute-mod.c   | 22 ++++++++++++++++++++
>  validation/type-attribute-qual.c  | 12 +++++++++++
>  4 files changed, 88 insertions(+)
>  create mode 100644 validation/type-attribute-align.c
>  create mode 100644 validation/type-attribute-as.c
>  create mode 100644 validation/type-attribute-mod.c
>  create mode 100644 validation/type-attribute-qual.c
> 
> diff --git a/validation/type-attribute-align.c b/validation/type-attribute-align.c
> new file mode 100644
> index 000000000000..d9358bff8327
> --- /dev/null
> +++ b/validation/type-attribute-align.c
> @@ -0,0 +1,20 @@
> +#define __aligned(N)	__attribute__((aligned(N)))
> +#define alignof(X)	__alignof__(X)
> +
> +struct s {
> +	short a, b, c;
> +} __aligned(2*sizeof(short));
> +
> +static int fs(void) { return  sizeof(struct s); }
> +static int fa(void) { return alignof(struct s); }
> +
> +void main(void)
> +{
> +	_Static_assert( sizeof(struct s) == 4 * sizeof(short), "size");
> +	_Static_assert(alignof(struct s) == 2 * sizeof(short), "alignment");
> +}
> +
> +/*
> + * check-name: type-attribute-align
> + * check-known-to-fail
> + */
> diff --git a/validation/type-attribute-as.c b/validation/type-attribute-as.c
> new file mode 100644
> index 000000000000..b40b4e7dddf5
> --- /dev/null
> +++ b/validation/type-attribute-as.c
> @@ -0,0 +1,34 @@
> +#define	__as		__attribute__((address_space(__as)))
> +
> +struct s {
> +	int i;
> +} __as;
> +
> +
> +extern void use0(void *);
> +extern void use1(void __as *);
> +
> +void main(void)
> +{
> +	struct s s;
> +	int i;
> +
> +	use0(&s);	// KO
> +	use0(&i);	// OK
> +	use1(&s);	// OK
> +	use1(&i);	// KO
> +}
> +
> +/*
> + * check-name: type-attribute-as
> + * check-known-to-fail
> + *
> + * check-error-start
> +type-attribute-as.c:16:15: warning: incorrect type in argument 1 (different address spaces)
> +type-attribute-as.c:16:15:    expected void *
> +type-attribute-as.c:16:15:    got struct s __as *
> +type-attribute-as.c:19:15: warning: incorrect type in argument 1 (different address spaces)
> +type-attribute-as.c:19:15:    expected void __as *
> +type-attribute-as.c:19:15:    got int *
> + * check-error-end
> + */
> diff --git a/validation/type-attribute-mod.c b/validation/type-attribute-mod.c
> new file mode 100644
> index 000000000000..0e7b166a4aec
> --- /dev/null
> +++ b/validation/type-attribute-mod.c
> @@ -0,0 +1,22 @@
> +#define	__noderef	__attribute__((noderef))
> +
> +struct s {
> +	int i;
> +} __noderef;
> +
> +
> +void main(void)
> +{
> +	struct s s;
> +
> +	s.i = 0;
> +}
> +
> +/*
> + * check-name: type-attribute-mod
> + * check-known-to-fail
> + *
> + * check-error-start
> +type-attribute-mod.c:12:9: warning: dereference of noderef expression
> + * check-error-end
> + */
> diff --git a/validation/type-attribute-qual.c b/validation/type-attribute-qual.c
> new file mode 100644
> index 000000000000..ab19a605bda1
> --- /dev/null
> +++ b/validation/type-attribute-qual.c
> @@ -0,0 +1,12 @@
> +static const struct s {
> +	int x;
> +} map[2];
> +
> +static void foo(struct s *p, int v)
> +{
> +	p->x += v;
> +}

Hmm, I don't understand what this is testing! :(

ATB,
Ramsay Jones

> +
> +/*
> + * check-name: type-attribute-qual
> + */
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 04/16] add testcases for type attributes
Date: Mon, 28 Dec 2020 19:59:48 +0000
Message-ID: <20201228195948.5kqsxvp3qat2mvxq () ltop ! local>
--------------------
On Mon, Dec 28, 2020 at 04:13:54PM +0000, Ramsay Jones wrote:
> On 26/12/2020 17:51, Luc Van Oostenryck wrote:
> > diff --git a/validation/type-attribute-qual.c b/validation/type-attribute-qual.c
> > new file mode 100644
> > index 000000000000..ab19a605bda1
> > --- /dev/null
> > +++ b/validation/type-attribute-qual.c
> > @@ -0,0 +1,12 @@
> > +static const struct s {
> > +	int x;
> > +} map[2];
> > +
> > +static void foo(struct s *p, int v)
> > +{
> > +	p->x += v;
> > +}
> 
> Hmm, I don't understand what this is testing! :(

The declaration of map also contains the definition of 'struct s'.
The test, by tryin to modify something of type 'struct s', allows to
verify that the 'const' applies only to 'map' and not to 'struct s'.

I'll add a comment.
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v2 05/16] add testcases for packed structures ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v2 05/16] add testcases for packed structures
Date: Mon, 28 Dec 2020 16:17:36 +0000
Message-ID: <860fe109-6819-ec55-e55f-90812b9f90f2 () ramsayjones ! plus ! com>
--------------------


On 26/12/2020 17:51, Luc Van Oostenryck wrote:
> Currently, packed structs are not handled correctly.
> 
> Add some testcases for them.
> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  validation/packed-deref0.c | 24 ++++++++++++++++++++++++
>  validation/packed-struct.c | 33 +++++++++++++++++++++++++++++++++
>  2 files changed, 57 insertions(+)
>  create mode 100644 validation/packed-deref0.c
>  create mode 100644 validation/packed-struct.c
> 
> diff --git a/validation/packed-deref0.c b/validation/packed-deref0.c
> new file mode 100644
> index 000000000000..865ad68a4f37
> --- /dev/null
> +++ b/validation/packed-deref0.c
> @@ -0,0 +1,24 @@
> +#define	__packed	__attribute__((packed))
> +
> +typedef struct {
> +	__INT8_TYPE__	a;
> +	__INT16_TYPE__	b;
> +	__INT32_TYPE__	c;
> +} __packed obj_t;
> +
> +_Static_assert(sizeof(obj_t) == 7, "sizeof packed struct");
> +
> +static void foo(obj_t *ptr, int val)
> +{
> +	ptr->c = val;
> +}
> +
> +static void bar(obj_t o)
> +{
> +	foo(&o, 0);
> +}
> +
> +/*
> + * check-name: packed-deref0
> + * check-known-to-fail
> + */
> diff --git a/validation/packed-struct.c b/validation/packed-struct.c
> new file mode 100644
> index 000000000000..5039be4d0b45
> --- /dev/null
> +++ b/validation/packed-struct.c
> @@ -0,0 +1,33 @@
> +#define __packed __attribute__((packed))
> +
> +typedef unsigned char   u8;
> +typedef __UINT16_TYPE__ u16;
> +typedef __UINT32_TYPE__ u32;
> +typedef __UINT64_TYPE__ u64;
> +
> +struct a {
> +	u8 a;
> +	u8 b;
> +	u16 c;
> +} __packed;
> +_Static_assert(__alignof(struct a) == 1, "align struct");
> +_Static_assert(   sizeof(struct a) == sizeof(u32), " size struct");

Hmm, I don't think '== sizeof(u32)' is any better than '== 4'.

ATB,
Ramsay Jones

> +
> +struct b {
> +	u32	a;
> +	u32	b;
> +} __packed;
> +_Static_assert(__alignof(struct b) == 1, "align struct");
> +_Static_assert(   sizeof(struct b) == 8, "size struct");
> +
> +struct c {
> +	u16	a;
> +	u32	b;
> +} __packed;
> +_Static_assert(__alignof(struct c) == 1, "align struct");
> +_Static_assert(   sizeof(struct c) == 6, "size struct");
> +
> +/*
> + * check-name: packed-struct
> + * check-known-to-fail
> + */
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 05/16] add testcases for packed structures
Date: Mon, 28 Dec 2020 20:01:50 +0000
Message-ID: <20201228200150.xvvrfno2e3mol7v4 () ltop ! local>
--------------------
On Mon, Dec 28, 2020 at 04:17:36PM +0000, Ramsay Jones wrote:
> 
> 
> On 26/12/2020 17:51, Luc Van Oostenryck wrote:
> > Currently, packed structs are not handled correctly.
> > 
> > Add some testcases for them.
> > 
> > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> > ---
> >  validation/packed-deref0.c | 24 ++++++++++++++++++++++++
> >  validation/packed-struct.c | 33 +++++++++++++++++++++++++++++++++
> >  2 files changed, 57 insertions(+)
> >  create mode 100644 validation/packed-deref0.c
> >  create mode 100644 validation/packed-struct.c
> > 
> > diff --git a/validation/packed-deref0.c b/validation/packed-deref0.c
> > new file mode 100644
> > index 000000000000..865ad68a4f37
> > --- /dev/null
> > +++ b/validation/packed-deref0.c
> > @@ -0,0 +1,24 @@
> > +#define	__packed	__attribute__((packed))
> > +
> > +typedef struct {
> > +	__INT8_TYPE__	a;
> > +	__INT16_TYPE__	b;
> > +	__INT32_TYPE__	c;
> > +} __packed obj_t;
> > +
> > +_Static_assert(sizeof(obj_t) == 7, "sizeof packed struct");
> > +
> > +static void foo(obj_t *ptr, int val)
> > +{
> > +	ptr->c = val;
> > +}
> > +
> > +static void bar(obj_t o)
> > +{
> > +	foo(&o, 0);
> > +}
> > +
> > +/*
> > + * check-name: packed-deref0
> > + * check-known-to-fail
> > + */
> > diff --git a/validation/packed-struct.c b/validation/packed-struct.c
> > new file mode 100644
> > index 000000000000..5039be4d0b45
> > --- /dev/null
> > +++ b/validation/packed-struct.c
> > @@ -0,0 +1,33 @@
> > +#define __packed __attribute__((packed))
> > +
> > +typedef unsigned char   u8;
> > +typedef __UINT16_TYPE__ u16;
> > +typedef __UINT32_TYPE__ u32;
> > +typedef __UINT64_TYPE__ u64;
> > +
> > +struct a {
> > +	u8 a;
> > +	u8 b;
> > +	u16 c;
> > +} __packed;
> > +_Static_assert(__alignof(struct a) == 1, "align struct");
> > +_Static_assert(   sizeof(struct a) == sizeof(u32), " size struct");
> 
> Hmm, I don't think '== sizeof(u32)' is any better than '== 4'.

Yes, I agree.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH v2 06/16] add testcases for packed bitfields ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 06/16] add testcases for packed bitfields
Date: Mon, 28 Dec 2020 20:05:46 +0000
Message-ID: <20201228200546.co4ibljkw6zvp3pe () ltop ! local>
--------------------
On Mon, Dec 28, 2020 at 04:28:24PM +0000, Ramsay Jones wrote:
> 
> 
> On 26/12/2020 17:51, Luc Van Oostenryck wrote:
> > Currently, packed bitfields are not handled correctly.
> > 
> > Add some testcases for them.
> > 
> > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> > ---
> >  validation/packed-bitfield0.c | 67 +++++++++++++++++++++++++++++++++++
> >  validation/packed-bitfield1.c | 28 +++++++++++++++
> >  validation/packed-bitfield2.c | 16 +++++++++
> >  validation/packed-bitfield3.c | 29 +++++++++++++++
> >  validation/packed-bitfield4.c | 19 ++++++++++
> >  validation/packed-bitfield5.c | 21 +++++++++++
> >  6 files changed, 180 insertions(+)
> >  create mode 100644 validation/packed-bitfield0.c
> >  create mode 100644 validation/packed-bitfield1.c
> >  create mode 100644 validation/packed-bitfield2.c
> >  create mode 100644 validation/packed-bitfield3.c
> >  create mode 100644 validation/packed-bitfield4.c
> >  create mode 100644 validation/packed-bitfield5.c
> > 
> > diff --git a/validation/packed-bitfield0.c b/validation/packed-bitfield0.c
> > new file mode 100644
> > index 000000000000..907500dedbf0
> > --- /dev/null
> > +++ b/validation/packed-bitfield0.c
> > @@ -0,0 +1,67 @@
> > +#define alignof(X)	__alignof__(X)
> > +#define __packed	__attribute__((packed))
> > +
> > +struct sa {
> > +	int a:7;
> > +	int c:10;
> > +	int b:2;
> > +} __packed;
> > +_Static_assert(alignof(struct sa) == 1, "alignof(struct sa)");
> > +_Static_assert( sizeof(struct sa) == 3,  "sizeof(struct sa)");
> > +
> > +struct __packed sb {
> > +	int a:7;
> > +	int c:10;
> > +	int b:2;
> > +};
> > +_Static_assert(alignof(struct sb) == 1, "alignof(struct sb)");
> > +_Static_assert( sizeof(struct sb) == 3,  "sizeof(struct sb)");
> 
> Why 'struct sb'? It is not used in the rest of the test (and is
> identical to 'struct sa').

Good question :)
I've probably reused some previous file as a kind of template.
 
> > diff --git a/validation/packed-bitfield3.c b/validation/packed-bitfield3.c
> > new file mode 100644
> > index 000000000000..6acff875299f
> > --- /dev/null
> > +++ b/validation/packed-bitfield3.c
> > @@ -0,0 +1,29 @@
> > +#define __packed __attribute__((packed))
> > +
> > +typedef unsigned char   u8;
> > +typedef __UINT16_TYPE__ u16;
> > +typedef __UINT32_TYPE__ u32;
> > +typedef __UINT64_TYPE__ u64;
> > +
> > +struct b {
> > +	u32	a:1;
> > +	u32	b:2;
> > +	u32	c:4;
> > +	u32	d:8;
> > +	u32	e:16;
> > +} __packed;
> > +_Static_assert(__alignof(struct b) == 1);
> > +_Static_assert(   sizeof(struct b) == sizeof(u32));
> 
> Again '== sizeof(u32)' does not seem useful. (what is it
> trying to say?)
> 
> > +
> > +struct c {
> > +	u8	a;
> > +	u8	b;
> > +	u64	c:48;
> > +} __packed;
> > +_Static_assert(__alignof(struct c) == 1);
> > +_Static_assert(   sizeof(struct c) == sizeof(u64));
> 
> ditto.

Yes, I agree.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH v2 08/16] apply_ctype: reverse the order of arguments ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v2 08/16] apply_ctype: reverse the order of arguments
Date: Mon, 28 Dec 2020 16:47:01 +0000
Message-ID: <3be177c7-b744-2d79-7f9b-935bc22b3db9 () ramsayjones ! plus ! com>
--------------------


On 26/12/2020 17:51, Luc Van Oostenryck wrote:
> apply_ctype()'s argument order is: src, dst (so the reading
> direction) but the assignment/memcpy() order is much more used:
> 	dst = src;
> 	memcpy(dst, src, n);
> than the order here is confusing.
> 
> So, change its argument order to comply with the memcpy()/
> assignement order and stop the confusion.

Hmm, how about:

"""
apply_ctype()'s argument order is 'src' then 'dst', which reads as
copying 'src' to 'dst'. However, assignment, and many library functions
(eg. memcpy()), use the opposite order for the source and destination
of a copy operation.

So, change the argument order of apply_ctype() to mimic the order of
memcpy()/assignment, to hopefully reduce any potential confusion.
"""

Heh, well that is probably not much better! ;-)

However, what about the (er...) position of the 'pos' argument?
Should it move to the end?

ATB,
Ramsay Jones

> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  parse.c | 8 ++++----
>  1 file changed, 4 insertions(+), 4 deletions(-)
> 
> diff --git a/parse.c b/parse.c
> index 402214212d77..f106444f75d8 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -1043,7 +1043,7 @@ static struct token *enum_specifier(struct token *token, struct symbol *sym, str
>  	return ret;
>  }
>  
> -static void apply_ctype(struct position pos, struct ctype *src, struct ctype *dst);
> +static void apply_ctype(struct position pos, struct ctype *dst, struct ctype *src);
>  
>  static struct token *typeof_specifier(struct token *token, struct symbol *sym, struct decl_state *ctx)
>  {
> @@ -1056,7 +1056,7 @@ static struct token *typeof_specifier(struct token *token, struct symbol *sym, s
>  		struct symbol *sym;
>  		token = typename(token->next, &sym, NULL);
>  		ctx->ctype.base_type = sym->ctype.base_type;
> -		apply_ctype(token->pos, &sym->ctype, &ctx->ctype);
> +		apply_ctype(token->pos, &ctx->ctype, &sym->ctype);
>  	} else {
>  		struct symbol *typeof_sym = alloc_symbol(token->pos, SYM_TYPEOF);
>  		token = parse_expression(token->next, &typeof_sym->initializer);
> @@ -1427,7 +1427,7 @@ static struct token *generic_qualifier(struct token *next, struct symbol *sym, s
>  	return next;
>  }
>  
> -static void apply_ctype(struct position pos, struct ctype *src, struct ctype *dst)
> +static void apply_ctype(struct position pos, struct ctype *dst, struct ctype *src)
>  {
>  	unsigned long mod = src->modifiers;
>  
> @@ -1529,7 +1529,7 @@ static struct token *declaration_specifiers(struct token *token, struct decl_sta
>  				break;
>  			seen |= Set_S | Set_T;
>  			ctx->ctype.base_type = s->ctype.base_type;
> -			apply_ctype(token->pos, &s->ctype, &ctx->ctype);
> +			apply_ctype(token->pos, &ctx->ctype, &s->ctype);
>  			token = token->next;
>  			continue;
>  		}
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 08/16] apply_ctype: reverse the order of arguments
Date: Mon, 28 Dec 2020 20:37:45 +0000
Message-ID: <20201228203745.bahrevokbb3ty5si () ltop ! local>
--------------------
On Mon, Dec 28, 2020 at 04:47:01PM +0000, Ramsay Jones wrote:
> 
> 
> On 26/12/2020 17:51, Luc Van Oostenryck wrote:
> > apply_ctype()'s argument order is: src, dst (so the reading
> > direction) but the assignment/memcpy() order is much more used:
> > 	dst = src;
> > 	memcpy(dst, src, n);
> > than the order here is confusing.
> > 
> > So, change its argument order to comply with the memcpy()/
> > assignement order and stop the confusion.
> 
> Hmm, how about:
> 
> """
> apply_ctype()'s argument order is 'src' then 'dst', which reads as
> copying 'src' to 'dst'. However, assignment, and many library functions
> (eg. memcpy()), use the opposite order for the source and destination
> of a copy operation.
> 
> So, change the argument order of apply_ctype() to mimic the order of
> memcpy()/assignment, to hopefully reduce any potential confusion.
> """
> 
> Heh, well that is probably not much better! ;-)

It's better but I'll try to reformulate it to better express that:
*) the 'reading direction' (left to right) vs. the 'assignment direction'
   (right to left) is a question of API choice
*) the left-to-right direction confuses *me* endlessly, but it's just me.

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v2 10/16] struct-attr: prepare to handle attributes at the end of struct definitions (1) ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 10/16] struct-attr: prepare to handle attributes at the end of struct definitions (1)
Date: Sat, 26 Dec 2020 17:51:23 +0000
Message-ID: <20201226175129.9621-11-luc.vanoostenryck () gmail ! com>
--------------------
Type attributes for struct can be placed either just after the
keyword 'struct' or after the '}' ending its definition but this
later case is currently ignored.

Prepare the handling of this by factoring the code common to both
cases in a single place.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                        | 11 +++++------
 validation/parsing/enum-attr.c |  4 ++--
 2 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/parse.c b/parse.c
index d6343f0e48bf..99d810910dab 100644
--- a/parse.c
+++ b/parse.c
@@ -745,12 +745,7 @@ static struct token *struct_union_enum_specifier(enum type type,
 			if (sym->symbol_list)
 				error_die(token->pos, "redefinition of %s", show_typename (sym));
 			sym->pos = *repos;
-			token = parse(token->next, sym);
-			token = expect(token, '}', "at end of struct-union-enum-specifier");
-
-			// Mark the structure as needing re-examination
-			sym->examined = 0;
-			sym->endpos = token->pos;
+			goto end;
 		}
 		return token;
 	}
@@ -763,10 +758,14 @@ static struct token *struct_union_enum_specifier(enum type type,
 	}
 
 	sym = alloc_symbol(token->pos, type);
+end:
 	set_current_scope(sym);		// used by dissect
 	token = parse(token->next, sym);
 	ctx->ctype.base_type = sym;
 	token =  expect(token, '}', "at end of specifier");
+
+	// Mark the structure as needing re-examination
+	sym->examined = 0;
 	sym->endpos = token->pos;
 
 	return token;
diff --git a/validation/parsing/enum-attr.c b/validation/parsing/enum-attr.c
index a962d8b417af..8d851a162135 100644
--- a/validation/parsing/enum-attr.c
+++ b/validation/parsing/enum-attr.c
@@ -21,9 +21,9 @@ enum bad {
 parsing/enum-attr.c:10:15: error: typename in expression
 parsing/enum-attr.c:10:15: error: undefined identifier '__attribute__'
 parsing/enum-attr.c:10:15: error: bad constant expression type
-parsing/enum-attr.c:10:22: error: Expected } at end of struct-union-enum-specifier
+parsing/enum-attr.c:10:22: error: Expected } at end of specifier
 parsing/enum-attr.c:10:22: error: got 33
-parsing/enum-attr.c:14:18: error: Expected } at end of struct-union-enum-specifier
+parsing/enum-attr.c:14:18: error: Expected } at end of specifier
 parsing/enum-attr.c:14:18: error: got __attribute__
  * check-error-end
  */
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v2 15/16] packed: no out-of-bound access of packed bitfields ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 15/16] packed: no out-of-bound access of packed bitfields
Date: Sat, 26 Dec 2020 17:51:28 +0000
Message-ID: <20201226175129.9621-16-luc.vanoostenryck () gmail ! com>
--------------------
There is (at least) 2 ways by which packed bitfields doesn't
follow normal layout/access rules and as consequence can't (always)
be accessed the usual way (load the whole underlying word, then shift
and mask to isolate the bitfield).

At least two different cases are a concern:
1) there is no padding at the end of a bitfield sequence. For example,
   the following struct is only 3 bytes width:
	struct s {
		int f:24;
	} __packed;
   So, trying to access the bitfield by first doing a 32-bit load
   will create an out-of-bound access.

2) a bitfield smaller than one word may need more than one word to be
   accessed. For example, with the following struct
	struct {
		int a:5;
		int f:30;
		int z:5;
	} __packed;
   the bitfield 'f', while smaller than one 32-bit word, can't be accessed
   with a single 32-bit access.

At machine level, these bitfields should be accessed with several, possibly
smaller, loads and their corresponding values reconstructed form these,
making things much more complicated than for non-packed bitfields.

But at IR level, things can be a little more flexible and things can stay
simple by using sub-word or super-word accesses (until these need to
be lowered to be usable at machine level). In other words, the example here
can be safely accessed with respectively a 24-bit and a 40-bit load.
This is what is done in this patch.
---
 linearize.c | 13 +++++++++++--
 symbol.h    |  1 +
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/linearize.c b/linearize.c
index 0250c6bb17ef..e80715ab2458 100644
--- a/linearize.c
+++ b/linearize.c
@@ -977,8 +977,17 @@ static struct symbol *bitfield_base_type(struct symbol *sym)
 	if (sym) {
 		if (sym->type == SYM_NODE)
 			base = base->ctype.base_type;
-		if (base->type == SYM_BITFIELD)
-			return base->ctype.base_type;
+		if (base->type == SYM_BITFIELD) {
+			base = base->ctype.base_type;
+			if (sym->packed) {
+				int size = bits_to_bytes(sym->bit_offset + sym->bit_size);
+				sym = __alloc_symbol(0);
+				*sym = *base;
+				sym->bit_size = bytes_to_bits(size);
+				return sym;
+			}
+			return base;
+		}
 	}
 	return sym;
 }
diff --git a/symbol.h b/symbol.h
index 5c5a7f12affa..866d57522f49 100644
--- a/symbol.h
+++ b/symbol.h
@@ -192,6 +192,7 @@ struct symbol {
 					accessed:1,
 					builtin:1,
 					torename:1,
+					packed:1,
 					transparent_union:1;
 			int		rank:3;	// arithmetic's rank
 			struct expression *array_size;
-- 
2.29.2

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 15/16] packed: no out-of-bound access of packed bitfields
Date: Mon, 28 Dec 2020 21:12:32 +0000
Message-ID: <20201228211232.weajlanyegb23hef () ltop ! local>
--------------------
> 
> Hmm, I didn't know the IR could represent this! ;-)

It was already used but I would prefer to avoid it.
For example, when copying a structure:
	struct s {
		char name[5];
	} s, d;

	...
	d = s;
will linearize into a single 40-bit load + store.
In this case, it's quite OK because it directly translate to
a memcpy().

> Is the 'lowering' code already present? Maybe next patch.

I had several versions, all more ugly than the others. It's why
I ended with this 'OK, keep things simple for now'.
Also, there is several ways of doing this and I'm not convinced
of which one  should be used. Worse, the case:
	struct {
		a:10;
		f:14;
	};
should probably not be handled like the case:
	struct {
		a:5;
		f:30;
		z:5;
	};
since the problems are different (the first one is just a question
of not doing an out-of-bound access, while for the second case we
have a field not wider than 4-bytes but which can't be accessed 
in less than 5 bytes).
 
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v2 2/2] dissect: fix sym_is_local(SYM_STRUCT/UNION/ENUM) ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH v2 2/2] dissect: fix sym_is_local(SYM_STRUCT/UNION/ENUM)
Date: Wed, 19 Feb 2020 16:29:34 +0000
Message-ID: <20200219162934.GA26799 () redhat ! com>
--------------------
Now that struct_union_enum_specifier() always sets sym->scope we can
simplify sym_is_local(sym) and rely on toplevel() even if sym is type.

Test-case:

	// copied from linux kernel
	# define __force	__attribute__((force))
	#define WRITE_ONCE(x, val) \
	({							\
		union { typeof(x) __val; char __c[1]; } __u =	\
			{ .__val = (__force typeof(x)) (val) }; \
		__write_once_size(&(x), __u.__c, sizeof(x));	\
		__u.__val;					\
	})

	void func(int *p)
	{
		WRITE_ONCE(*p, 0);
	}

before this patch the widely used WRITE_ONCE() generates a lot of spam which
can't be filtered out using sym_is_local(),

	11:6                    def   f func                             void ( ... )
	11:11  func             def . v p                                int *
	13:9                    def   s :__u
	13:9                    --- . v p                                int *
	13:9                    def   m :__u.__val                       int
	13:9                    def   m :__u.__c                         char [1]
	13:9   func             def . v __u                              union :__u
	13:9   func             -w- . v __u                              union :__u
	13:9   func             -w-   m :__u.__val                       int
	13:9   func             --- . v p                                int *
	13:9   func             --r   f __write_once_size                bad type
	13:9   func             -r- . v p                                int *
	13:9   func             -r- . v __u                              union :__u
	13:9   func             m--   m :__u.__c                         char [1]
	13:9   func             --- . v p                                int *
	13:9   func             --- . v __u                              union :__u
	13:9   func             ---   m :__u.__val                       int

plus it triggers warning("no context") in test-dissect.c. With this patch
the only "nonlocal" report is __write_once_size() call.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 4 ++--
 dissect.h | 3 ++-
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/dissect.c b/dissect.c
index 40baf64..c48214b 100644
--- a/dissect.c
+++ b/dissect.c
@@ -152,7 +152,6 @@ static inline struct symbol *expr_symbol(struct expression *expr)
 		if (!sym) {
 			sym = alloc_symbol(expr->pos, SYM_BAD);
 			bind_symbol(sym, expr->symbol_name, NS_SYMBOL);
-			sym->ctype.modifiers = MOD_EXTERN | MOD_TOPLEVEL;
 			sym->kind = expr->op ?: 'v'; /* see EXPR_CALL */
 		}
 	}
@@ -238,7 +237,8 @@ static void examine_sym_node(struct symbol *node, struct symbol *parent)
 				return;
 
 			dctx = dissect_ctx;
-			dissect_ctx = NULL;
+			if (toplevel(base->scope))
+				dissect_ctx = NULL;
 
 			if (base->ident || deanon(base, name, parent))
 				reporter->r_symdef(base);
diff --git a/dissect.h b/dissect.h
index 326d3dc..a77a932 100644
--- a/dissect.h
+++ b/dissect.h
@@ -4,6 +4,7 @@
 #include <stdio.h>
 #include "parse.h"
 #include "expression.h"
+#include "scope.h"
 
 #define	U_SHIFT		8
 
@@ -29,7 +30,7 @@ extern struct symbol *dissect_ctx;
 
 static inline bool sym_is_local(struct symbol *sym)
 {
-	return sym->kind == 'v' && !(sym->ctype.modifiers & MOD_TOPLEVEL);
+	return !toplevel(sym->scope);
 }
 
 extern void dissect(struct reporter *, struct string_list *);
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH v2 2/3] add more testcases for existing AND/OR simplifications ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2 2/3] add more testcases for existing AND/OR simplifications
Date: Mon, 07 Sep 2020 22:28:33 +0000
Message-ID: <20200907222833.tsbptcqsvk4lzikx () ltop ! local>
--------------------
On Sun, Sep 06, 2020 at 10:54:25PM +0100, Ramsay Jones wrote:
> > 
> > diff --git a/validation/optim/and-shl-or-and0.c b/validation/optim/and-shl-or-and0.c
> > new file mode 100644
> > index 000000000000..298dcb434fc7
> > --- /dev/null
> > +++ b/validation/optim/and-shl-or-and0.c
> > @@ -0,0 +1,15 @@
> > +// =>	(b << 12) & 0xfff00000
> > +unsigned and_shl_or_and0(unsigned a, unsigned b)
> > +{
> > +	return (((a & 0xfff00000) | b) << 12) & 0xfff00000;
> > +}
> > +
> > +/*
> > + * check-name: and-shl-or-and0
> > + * check-command: test-linearize -Wno-decl $file
> > + *
> > + * check-output-ignore
> > + * check-output-excludes: or\\.
> > + * check-output-excludes: lsr\\.
> 
> Hmm, this still doesn't sit right - have you discovered the
> reason for this?

Sorry, I don't understand what I can add.
Such expressions are simplified into something where the OR and
the LSR are absent. This is what is checked by the test.
 
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v2 3/3] add more testcases for AND/OR simplification ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v2 3/3] add more testcases for AND/OR simplification
Date: Mon, 07 Sep 2020 00:15:18 +0000
Message-ID: <7ead3fd3-34f4-f5d4-21fa-c7937fcab5fe () ramsayjones ! plus ! com>
--------------------


On 06/09/2020 22:16, Luc Van Oostenryck wrote:
> Add a few testcases showing the effectiveness of these
> simplifications and to catch possible future regressions.
> 

Sorry, I had to step away from the keyboard for a couple
of hours ...

> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  validation/optim/and-lsr-or-shl0.c | 13 +++++++++++++
>  validation/optim/and-lsr-or-shl1.c | 13 +++++++++++++
>  validation/optim/and-shl-or-lsr0.c | 13 +++++++++++++
>  validation/optim/lsr-or-lsr0.c     | 22 ++++++++++++++++++++++
>  validation/optim/trunc-or-shl0.c   | 22 ++++++++++++++++++++++
>  5 files changed, 83 insertions(+)
>  create mode 100644 validation/optim/and-lsr-or-shl0.c
>  create mode 100644 validation/optim/and-lsr-or-shl1.c
>  create mode 100644 validation/optim/and-shl-or-lsr0.c
>  create mode 100644 validation/optim/lsr-or-lsr0.c
>  create mode 100644 validation/optim/trunc-or-shl0.c
> 
> diff --git a/validation/optim/and-lsr-or-shl0.c b/validation/optim/and-lsr-or-shl0.c
> new file mode 100644
> index 000000000000..46ab1bde5249
> --- /dev/null
> +++ b/validation/optim/and-lsr-or-shl0.c
> @@ -0,0 +1,13 @@
> +// =>	0
> +unsigned int and_lsr_or_shl0(unsigned int a, unsigned int b)
> +{
> +	return ((a | b << 12) >> 12) & 0xfff00000;
> +}
> +
> +/*
> + * check-name: and-lsr-or-shl0
> + * check-command: test-linearize -Wno-decl $file
> + * check-known-to-fail
> + *
> + * check-output-excludes: shl\\.

Why not something like:
  * check-output-contains: ret.32 *\\$0
  * check-output-excludes: shl\\.
  * check-output-excludes: or\\.
  * check-output-excludes: lsr\\.
  * check-output-excludes: and\\.

> + */
> diff --git a/validation/optim/and-lsr-or-shl1.c b/validation/optim/and-lsr-or-shl1.c
> new file mode 100644
> index 000000000000..22fee362b16b
> --- /dev/null
> +++ b/validation/optim/and-lsr-or-shl1.c
> @@ -0,0 +1,13 @@
> +// =>	(((a | b << 12) >> 12)
> +unsigned int and_lsr_or_shl1(unsigned int a, unsigned int b)
> +{
> +	return ((a | b << 12) >> 12) & 0x000fffff;
> +}
> +
> +/*
> + * check-name: and-lsr-or-shl1
> + * check-command: test-linearize -Wno-decl $file
> + * check-known-to-fail
> + *
> + * check-output-excludes: shl\\.

Hmm, this should be ': and\\.' right?

> + */
> diff --git a/validation/optim/and-shl-or-lsr0.c b/validation/optim/and-shl-or-lsr0.c
> new file mode 100644
> index 000000000000..f2a7cc631258
> --- /dev/null
> +++ b/validation/optim/and-shl-or-lsr0.c
> @@ -0,0 +1,13 @@

Hmm, I can't see the optimization, just ...

> +unsigned and_shl_or_lsr0(unsigned a, unsigned b)
> +{
> +	return ((a | (b >> 12)) << 12) & 0xfff00000;

->((a << 12) | ((b >> 12) << 12)) & 0xfff00000
->((a << 12) | b) & 0xfff00000
so that ...

> +}
> +
> +/*
> + * check-name: and-shl-or-lsr0
> + * check-command: test-linearize -Wno-decl $file
> + * check-known-to-fail
> + *
> + * check-output-ignore
> + * check-output-excludes: or\\.

... this wouldn't be correct. puzzled! :(

> + */
> diff --git a/validation/optim/lsr-or-lsr0.c b/validation/optim/lsr-or-lsr0.c
> new file mode 100644
> index 000000000000..aad4aa7fda56
> --- /dev/null
> +++ b/validation/optim/lsr-or-lsr0.c
> @@ -0,0 +1,22 @@
> +#define	S	12
> +
> +//	((x >> S') | y) >> S;
> +// ->	((x >> S' >> S) | (y >> S)

s/((x/(x/

> +// ->	((x >> 32) | (y >> S)

s/((x/(x/

> +// =>	(y >> S)
> +
> +int lsr_or_lsr0(unsigned int x, unsigned int b)
> +{
> +	return ((x >> (32 - S)) | b) >> S;
> +}
> +
> +/*
> + * check-name: lsr-or-lsr0
> + * check-command: test-linearize -Wno-decl $file
> + * check-known-to-fail
> + *
> + * check-output-ignore
> + * check-output-pattern(1): lsr\\.
> + * check-output-excludes: and\\.

why would an 'and' be here anyway?

> + * check-output-excludes: or\\.
> + */
> diff --git a/validation/optim/trunc-or-shl0.c b/validation/optim/trunc-or-shl0.c
> new file mode 100644
> index 000000000000..ab92aca1b711
> --- /dev/null
> +++ b/validation/optim/trunc-or-shl0.c
> @@ -0,0 +1,22 @@
> +// => TRUNC(b, 8)
> +char trunc_or_shl0a(unsigned a, unsigned b)
> +{
> +	return (a << 8) | b;
> +}
> +
> +// => TRUNC(a, 8)
> +char trunc_or_shl0b(unsigned a, unsigned b)
> +{
> +	return a | (b << 8);
> +}
> +
> +/*
> + * check-name: trunc-or-shl0
> + * check-command: test-linearize -Wno-decl $file
> + * check-known-to-fail
> + *
> + * check-output-ignore
> + * check-output-excludes: or\\.
> + * check-output-excludes: shl\\.
> + * check-output-pattern(2): %arg

OK, good.

> + */
> 

ATB,
Ramsay Jones

================================================================================


################################################################################

=== Thread: [PATCH v2] Add semantic index utility ===

From: Alexey Gladkov <gladkov.alexey () gmail ! com>
To: linux-sparse
Subject: [PATCH v2] Add semantic index utility
Date: Wed, 11 Mar 2020 17:22:46 +0000
Message-ID: <20200311172246.59838-1-gladkov.alexey () gmail ! com>
--------------------
sindex is the simple to use cscope-like tool based on sparse/dissect.
Unlike cscope it runs after pre-processor and thus it can't index the
code filtered out by ifdef's, but otoh it understands how the symbol
is used and it can track the usage of struct members.

To create an index for your linux kernel configuration:

$ make C=2 CHECK="sindex add --"

Now, to find where a definition of the pid field from the task_struct
structure:

$ sindex search -m def task_struct.pid
(def) include/linux/sched.h 793 11   pid_t    pid;

default output format:

SOURCE-FILE \t LINE-NUMBER \t COLUMN \t IN FUNCTION NAME \t CODE LINE

To find where this field changes:

$ sindex search -m w task_struct.pid
(-w-) fs/exec.c 1154 6 de_thread   tsk->pid = leader->pid;
(-w-) kernel/fork.c 2155 3 copy_process  p->pid = pid_nr(pid);

To get only filenames and line number you can change output format:

$ sindex search -f '%f:%l' -m w task_struct.pid
fs/exec.c:1154
kernel/fork.c:2155

Current limitations:

* inline functions are ignored;
* enums are ignored;
* unknown #include leads to a fatal error.

Suggested-by: Oleg Nesterov <oleg@redhat.com>
Signed-off-by: Oleg Nesterov <oleg@redhat.com>
Signed-off-by: Alexey Gladkov <gladkov.alexey@gmail.com>
---
 .gitignore |    1 +
 Makefile   |   12 +-
 sindex.1   |  143 +++++++
 sindex.c   | 1094 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 1249 insertions(+), 1 deletion(-)
 create mode 100644 sindex.1
 create mode 100644 sindex.c

diff --git a/.gitignore b/.gitignore
index 91305a6a..58598364 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,6 +19,7 @@ graph
 obfuscate
 sparse
 sparse-llvm
+sindex
 test-dissect
 test-inspect
 test-lexing
diff --git a/Makefile b/Makefile
index e2d3a7de..85d15edc 100644
--- a/Makefile
+++ b/Makefile
@@ -140,6 +140,17 @@ else
 $(warning Your system does not have libxml, disabling c2xml)
 endif
 
+HAVE_SQLITE := $(shell $(PKG_CONFIG) --exists sqlite3 2>/dev/null && echo 'yes')
+ifeq ($(HAVE_SQLITE),yes)
+PROGRAMS += sindex
+INST_PROGRAMS += sindex
+INST_MAN1 += sindex.1
+sindex-ldlibs := $(shell $(PKG_CONFIG) --libs sqlite3)
+sindex-cflags := $(shell $(PKG_CONFIG) --cflags sqlite3)
+else
+$(warning Your system does not have sqlite3, disabling sindex)
+endif
+
 # Can we use gtk (needed for test-inspect)
 GTK_VERSION:=3.0
 HAVE_GTK:=$(shell $(PKG_CONFIG) --exists gtk+-$(GTK_VERSION) 2>/dev/null && echo 'yes')
@@ -228,7 +239,6 @@ cflags   += $($(*)-cflags) $(CPPFLAGS) $(CFLAGS)
 
 selfcheck: $(OBJS:.o=.sc)
 
-
 SPARSE_VERSION:=$(shell git describe --dirty 2>/dev/null || echo '$(VERSION)')
 lib.o: version.h
 version.h: FORCE
diff --git a/sindex.1 b/sindex.1
new file mode 100644
index 00000000..ef39f0f9
--- /dev/null
+++ b/sindex.1
@@ -0,0 +1,143 @@
+.\" Sindex manpage by Alexey Gladkov
+.TH sindex "1"
+.
+.SH NAME
+sindex \- Semantic Indexer for C
+.
+.SH SYNOPSIS
+.B sindex
+[\fIoptions\fR]
+.br
+.B sindex
+[\fIoptions\fR] \fIadd\fR [\fIcommand options\fR] [\fI--\fR] [\fIcompiler options\fR] [\fIfiles...\fR]
+.br
+.B sindex
+[\fIoptions\fR] \fIrm\fR [\fIcommand options\fR] \fIpattern\fR
+.br
+.B sindex
+[\fIoptions\fR] \fIsearch\fR [\fIcommand options\fR] [\fIpattern\fR]
+.br
+.SH DESCRIPTION
+.P
+sindex is the simple to use cscope-like tool based on sparse/dissect.  Unlike
+cscope it runs after pre-processor and thus it can't index the code filtered out
+by ifdef's, but otoh it understands how the symbol is used and it can track the
+usage of struct members.
+.
+.SH SUBCOMMANDS
+.TP
+\fBadd\fR
+generates or updates semantic index file.
+.TP
+\fBrm\fR
+removes files from the index by \fIpattern\fR. The \fIpattern\fR is a
+.BR glob (7)
+wildcard pattern.
+.TP
+\fBsearch\fR
+queries information about symbol by \fIpattern\fR. The \fIpattern\fR is a
+.BR glob (7)
+wildcard pattern.
+.
+.SH COMMON OPTIONS
+.TP
+\fB-D\fR, \fB--database=FILE\fR
+specify database file (default: ./sindex.sqlite).
+.TP
+\fB-v\fR, \fB--verbose\fR
+show information about what is being done.
+.TP
+\fB-h\fR, \fB--help\fR
+show this text and exit.
+.
+.SH ADD OPTIONS
+.TP
+\fB--include-local-syms\fR
+include into the index local symbols.
+.
+.SH SEARCH OPTIONS
+.TP
+\fB-f\fR, \fB--format=STRING\fR
+specify an output format. Default: '(%m) %f\\t%l\\t%c\\t%C\\t%s' (see
+.BR FORMAT
+below).
+.TP
+\fB-p\fR, \fB--path=PATTERN\fR
+search symbols only in specified directories.
+.TP
+\fB-m\fR, \fB--mode=MODE\fR
+search only the specified type of access (see
+.BR MODE
+below).
+.TP
+\fB-k\fR, \fB--kind=KIND\fR
+specify a kind of symbol (see
+.BR KIND
+below).
+.TP
+\fB-v\fR, \fB--verbose\fR
+show information about what is being done;
+.TP
+\fB-h\fR, \fB--help\fR
+show this text and exit.
+.
+.SH FORMAT
+.TP
+\fB%m\fR
+access mode in human readable form (see
+.BR MODE
+below).
+.TP
+\fB%f\fR
+file name.
+.TP
+\fB%l\fR
+line number.
+.TP
+\fB%c\fR
+column number.
+.TP
+\fB%C\fR
+the name of the function in which the symbol occurs.
+.TP
+\fB%n\fR
+symbol name.
+.TP
+\fB%s\fR
+source code line. Indexer does not save source code lines. They are read from
+the file during the search.
+.
+.SH KIND
+.TP
+\fBf\fR
+function
+.TP
+\fBs\fR
+strict
+.TP
+\fBm\fR
+struct member
+.
+.SH MODE
+The \fBMODE\fR is dumped as a 3-letter string. The first letter denotes address
+of part, 2-nd - access by value, 3-rd - access by pointer. A special value
+\'\fIdef\fR\' means a symbol definition.
+.TP
+\fBr\fR
+read
+.TP
+\fBw\fR
+write
+.TP
+\fBm\fR
+read and write
+.
+.SH SEE ALSO
+.BR sparse (1)
+.
+.SH HOMEPAGE
+http://www.kernel.org/pub/software/devel/sparse/
+.
+.SH MAILING LIST
+linux-sparse@vger.kernel.org
+.
diff --git a/sindex.c b/sindex.c
new file mode 100644
index 00000000..d1934a78
--- /dev/null
+++ b/sindex.c
@@ -0,0 +1,1094 @@
+/*
+ * sindex - semantic indexer for C.
+ *
+ * Copyright (C) 2020  Alexey Gladkov
+ */
+
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <unistd.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <errno.h>
+#include <sqlite3.h>
+
+#include "dissect.h"
+
+#define U_DEF (0x100 << U_SHIFT)
+#define SINDEX_DATABASE_VERSION 1
+
+#define message(fmt, ...) sindex_error(0, 0, (fmt), ##__VA_ARGS__)
+
+static const char *progname;
+static const char *sindex_command = NULL;
+
+// common options
+static const char *sindex_dbfile = "sindex.sqlite";
+static int sindex_verbose = 0;
+static char cwd[PATH_MAX];
+static size_t n_cwd;
+
+// 'add' command options
+static struct string_list *sindex_filelist = NULL;
+static int sindex_include_local_syms = 0;
+
+struct sindex_streams {
+	sqlite3_int64 id;
+};
+
+static struct sindex_streams *sindex_streams = NULL;
+static int sindex_streams_nr = 0;
+
+// 'search' command options
+static int sindex_search_modmask;
+static int sindex_search_modmask_defined = 0;
+static int sindex_search_kind = 0;
+static char *sindex_search_path = NULL;
+static char *sindex_search_symbol = NULL;
+static const char *sindex_search_format = "(%m) %f\t%l\t%c\t%C\t%s";
+
+static sqlite3 *sindex_db = NULL;
+static sqlite3_stmt *lock_stmt = NULL;
+static sqlite3_stmt *unlock_stmt = NULL;
+static sqlite3_stmt *insert_rec_stmt = NULL;
+static sqlite3_stmt *select_file_stmt = NULL;
+static sqlite3_stmt *insert_file_stmt = NULL;
+static sqlite3_stmt *delete_file_stmt = NULL;
+
+struct command {
+	const char *name;
+	int dbflags;
+	void (*parse_cmdline)(int argc, char **argv);
+	void (*handler)(int argc, char **argv);
+};
+
+static void show_usage(void)
+{
+	if (sindex_command)
+		printf("Try '%s %s --help' for more information.\n",
+		       progname, sindex_command);
+	else
+		printf("Try '%s --help' for more information.\n",
+		       progname);
+	exit(1);
+}
+
+static void show_help(int ret)
+{
+	printf(
+	    "Usage: %1$s [options]\n"
+	    "   or: %1$s [options] add    [command options] [--] [compiler options] [files...]\n"
+	    "   or: %1$s [options] rm     [command options] pattern\n"
+	    "   or: %1$s [options] search [command options] pattern\n"
+	    "\n"
+	    "These are common %1$s commands used in various situations:\n"
+	    "  add      Generate or updates semantic index file for c-source code;\n"
+	    "  rm       Remove files from the index by pattern;\n"
+	    "  search   Make index queries.\n"
+	    "\n"
+	    "Options:\n"
+	    "  -D, --database=FILE    Specify database file (default: %2$s);\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "Environment:\n"
+	    "  SINDEX_DATABASE        Database file location.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    progname, sindex_dbfile);
+	exit(ret);
+}
+
+static void show_help_add(int ret)
+{
+	printf(
+	    "Usage: %1$s add [options] [--] [compiler options] files...\n"
+	    "\n"
+	    "Utility creates or updates a symbol index.\n"
+	    "\n"
+	    "Options:\n"
+	    "  --include-local-syms   Include into the index local symbols;\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "Environment:\n"
+	    "  SINDEX_BASEDIRE        Project top directory.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    progname);
+	exit(ret);
+
+}
+
+static void show_help_rm(int ret)
+{
+	printf(
+	    "Usage: %1$s rm [options] pattern\n"
+	    "\n"
+	    "Utility removes source files from the index.\n"
+	    "The pattern is a glob(7) wildcard pattern.\n"
+	    "\n"
+	    "Options:\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    progname);
+	exit(ret);
+}
+
+static void show_help_search(int ret)
+{
+	printf(
+	    "Usage: %1$s search [options] [pattern]\n"
+	    "\n"
+	    "Utility searches information about symbol by pattern.\n"
+	    "The pattern is a glob(7) wildcard pattern.\n"
+	    "\n"
+	    "Options:\n"
+	    "  -f, --format=STRING    Specify an output format;\n"
+	    "  -p, --path=PATTERN     Search symbols only in specified directories;\n"
+	    "  -m, --mode=MODE        Search only the specified type of access;\n"
+	    "  -k, --kind=KIND        Specify a kind of symbol;\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "The KIND can be one of the following: `s', `f', `v', `m'.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    progname);
+	exit(ret);
+}
+
+static void sindex_print_progname(void)
+{
+	fprintf(stderr, "%s: ", progname);
+	if (sindex_command)
+		fprintf(stderr, "%s: ", sindex_command);
+}
+
+static void sindex_error(int status, int errnum, const char *fmt, ...)
+{
+	va_list ap;
+	sindex_print_progname();
+
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+
+	if (errnum > 0)
+		fprintf(stderr, ": %s", strerror(errnum));
+
+	fprintf(stderr, "\n");
+
+	if (status)
+		exit(status);
+}
+
+static void set_search_modmask(const char *v)
+{
+	size_t n = strlen(v);
+
+	if (n != 1 && n != 3)
+		sindex_error(1, 0, "the length of mode value must be 1 or 3: %s", v);
+
+	sindex_search_modmask_defined = 1;
+	sindex_search_modmask = 0;
+
+	if (n == 1) {
+		switch (v[0]) {
+			case 'r': v = "rrr"; break;
+			case 'w': v = "ww-"; break;
+			case 'm': v = "mmm"; break;
+			case '-': v = "---"; break;
+			default: sindex_error(1, 0, "unknown modificator: %s", v);
+		}
+	} else if (!strcmp(v, "def")) {
+		sindex_search_modmask = U_DEF;
+		return;
+	}
+
+	static const int modes[] = {
+		U_R_AOF, U_W_AOF, U_R_AOF | U_W_AOF,
+		U_R_VAL, U_W_VAL, U_R_VAL | U_W_VAL,
+		U_R_PTR, U_W_PTR, U_R_PTR | U_W_PTR,
+	};
+
+	for (int i = 0; i < 3; i++) {
+		switch (v[i]) {
+			case 'r': sindex_search_modmask |= modes[i * 3];     break;
+			case 'w': sindex_search_modmask |= modes[i * 3 + 1]; break;
+			case 'm': sindex_search_modmask |= modes[i * 3 + 2]; break;
+			case '-': break;
+			default:  sindex_error(1, 0,
+			                "unknown modificator in the mode value"
+			                " (`r', `w', `m' or `-' expected): %c", v[i]);
+		}
+	}
+}
+
+static void parse_cmdline(int argc, char **argv)
+{
+	static const struct option long_options[] = {
+		{ "database", required_argument, 0, 'D' },
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{0, 0, 0, 0 }
+	};
+	int c;
+	char *env;
+
+	if ((env = getenv("SINDEX_DATABASE")) != NULL)
+		sindex_dbfile = env;
+
+	while ((c = getopt_long(argc, argv, "+D:vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 'D':
+				sindex_dbfile = optarg;
+				break;
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help(0);
+		}
+	}
+
+	if (optind == argc) {
+		message("command required");
+		show_usage();
+	}
+}
+
+static void parse_cmdline_add(int argc, char **argv)
+{
+	static const struct option long_options[] = {
+		{ "include-local-syms", no_argument, 0, 1 },
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{0, 0, 0, 0 }
+	};
+	int c;
+
+	opterr = 0;
+
+	while ((c = getopt_long(argc, argv, "+vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 1:
+				sindex_include_local_syms = 1;
+				break;
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help_add(0);
+			case '?':
+				goto done;
+		}
+	}
+done:
+	if (optind == argc) {
+		message("more arguments required");
+		show_usage();
+	}
+
+	// enforce tabstop
+	tabstop = 1;
+
+	// step back since sparse_initialize will ignore argv[0].
+	optind--;
+
+	sparse_initialize(argc - optind, argv + optind, &sindex_filelist);
+}
+
+static void parse_cmdline_rm(int argc, char **argv)
+{
+	static const struct option long_options[] = {
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{0, 0, 0, 0 }
+	};
+	int c;
+
+	while ((c = getopt_long(argc, argv, "+vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help_rm(0);
+		}
+	}
+
+	if (optind == argc) {
+		message("more arguments required");
+		show_usage();
+	}
+}
+
+static void parse_cmdline_search(int argc, char **argv)
+{
+	static const struct option long_options[] = {
+		{ "format", required_argument, 0, 'f' },
+		{ "path", required_argument, 0, 'p' },
+		{ "mode", required_argument, 0, 'm' },
+		{ "kind", required_argument, 0, 'k' },
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{ 0, 0, 0, 0 }
+	};
+	int c;
+
+	while ((c = getopt_long(argc, argv, "+f:m:k:p:vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 'f':
+				sindex_search_format = optarg;
+				break;
+			case 'm':
+				set_search_modmask(optarg);
+				break;
+			case 'k':
+				sindex_search_kind = tolower(optarg[0]);
+				break;
+			case 'p':
+				sindex_search_path = optarg;
+				break;
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help_search(0);
+		}
+	}
+
+	if (optind < argc)
+		sindex_search_symbol = argv[optind++];
+}
+
+static int query_appendf(sqlite3_str *query, const char *fmt, ...)
+{
+	int status;
+	va_list args;
+
+	va_start(args, fmt);
+	sqlite3_str_vappendf(query, fmt, args);
+	va_end(args);
+
+	if ((status = sqlite3_str_errcode(query)) == SQLITE_OK)
+		return 0;
+
+	if (status == SQLITE_NOMEM)
+		message("not enough memory");
+
+	if (status == SQLITE_TOOBIG)
+		message("string too big");
+
+	return -1;
+}
+
+static inline void sqlite_bind_text(sqlite3_stmt *stmt, const char *field, const char *var, int len)
+{
+	if (sqlite3_bind_text(stmt, sqlite3_bind_parameter_index(stmt, field), var, len, SQLITE_STATIC) != SQLITE_OK)
+		sindex_error(1, 0, "unable to bind value for %s: %s", field, sqlite3_errmsg(sindex_db));
+}
+
+static inline void sqlite_bind_int64(sqlite3_stmt *stmt, const char *field, long long var)
+{
+	if (sqlite3_bind_int64(stmt, sqlite3_bind_parameter_index(stmt, field), var) != SQLITE_OK)
+		sindex_error(1, 0, "unable to bind value for %s: %s", field, sqlite3_errmsg(sindex_db));
+}
+
+static inline void sqlite_prepare(const char *sql, sqlite3_stmt **stmt)
+{
+	int ret;
+	do {
+		ret = sqlite3_prepare_v2(sindex_db, sql, -1, stmt, NULL);
+		if (ret != SQLITE_OK && ret != SQLITE_BUSY)
+			sindex_error(1, 0, "unable to prepare query: %s: %s", sqlite3_errmsg(sindex_db), sql);
+	} while (ret == SQLITE_BUSY);
+}
+
+static inline void sqlite_prepare_persistent(const char *sql, sqlite3_stmt **stmt)
+{
+	int ret;
+	do {
+		ret = sqlite3_prepare_v3(sindex_db, sql, -1, SQLITE_PREPARE_PERSISTENT, stmt, NULL);
+		if (ret != SQLITE_OK && ret != SQLITE_BUSY)
+			sindex_error(1, 0, "unable to prepare query: %s: %s", sqlite3_errmsg(sindex_db), sql);
+	} while (ret == SQLITE_BUSY);
+}
+
+static inline void sqlite_reset_stmt(sqlite3_stmt *stmt)
+{
+	// Contrary to the intuition of many, sqlite3_reset() does not reset the
+	// bindings on a prepared statement. Use this routine to reset all host
+	// parameters to NULL.
+	sqlite3_clear_bindings(stmt);
+	sqlite3_reset(stmt);
+}
+
+static int sqlite_run(sqlite3_stmt *stmt)
+{
+	int ret = sqlite3_step(stmt);
+	if (ret != SQLITE_DONE && ret != SQLITE_ROW)
+		sindex_error(1, 0, "unable to process query: %s: %s", sqlite3_errmsg(sindex_db), sqlite3_sql(stmt));
+	return ret;
+}
+
+static void sqlite_command(const char *sql)
+{
+	sqlite3_stmt *stmt;
+	sqlite_prepare(sql, &stmt);
+	sqlite_run(stmt);
+	sqlite3_finalize(stmt);
+}
+
+static sqlite3_int64 get_db_version(void)
+{
+	sqlite3_stmt *stmt;
+	sqlite3_int64 dbversion;
+
+	sqlite_prepare("PRAGMA user_version", &stmt);
+	sqlite_run(stmt);
+	dbversion = sqlite3_column_int64(stmt, 0);
+	sqlite3_finalize(stmt);
+
+	return dbversion;
+}
+
+static void set_db_version(void)
+{
+	char *sql;
+	sqlite3_str *query = sqlite3_str_new(sindex_db);
+
+	if (query_appendf(query, "PRAGMA user_version = %d", SINDEX_DATABASE_VERSION) < 0)
+		exit(1);
+
+	sql = sqlite3_str_finish(query);
+	sqlite_command(sql);
+	sqlite3_free(sql);
+}
+
+static void open_temp_database(void)
+{
+	static const char *database_schema[] = {
+		"ATTACH ':memory:' AS tempdb",
+		"CREATE TABLE tempdb.sindex ("
+			" file INTEGER NOT NULL,"
+			" line INTEGER NOT NULL,"
+			" column INTEGER NOT NULL,"
+			" symbol TEXT NOT NULL,"
+			" kind INTEGER NOT NULL,"
+			" context TEXT,"
+			" mode INTEGER NOT NULL"
+		")",
+		NULL,
+	};
+
+	for (int i = 0; database_schema[i]; i++)
+		sqlite_command(database_schema[i]);
+}
+
+static void open_database(const char *filename, int flags)
+{
+	static const char *database_schema[] = {
+		"CREATE TABLE file ("
+			" id INTEGER PRIMARY KEY AUTOINCREMENT,"
+			" name TEXT UNIQUE NOT NULL,"
+			" mtime INTEGER NOT NULL"
+		")",
+		"CREATE TABLE sindex ("
+			" file INTEGER NOT NULL REFERENCES file(id) ON DELETE CASCADE,"
+			" line INTEGER NOT NULL,"
+			" column INTEGER NOT NULL,"
+			" symbol TEXT NOT NULL,"
+			" kind INTEGER NOT NULL,"
+			" context TEXT,"
+			" mode INTEGER NOT NULL"
+		")",
+		"CREATE UNIQUE INDEX sindex_0 ON sindex (symbol, kind, mode, file, line, column)",
+		"CREATE INDEX sindex_1 ON sindex (file)",
+		NULL,
+	};
+
+	int exists = !access(filename, R_OK);
+
+	if (sqlite3_open_v2(filename, &sindex_db, flags, NULL) != SQLITE_OK)
+		sindex_error(1, 0, "unable to open database: %s: %s", filename, sqlite3_errmsg(sindex_db));
+
+	sqlite_command("PRAGMA journal_mode = WAL");
+	sqlite_command("PRAGMA synchronous = OFF");
+	sqlite_command("PRAGMA secure_delete = FAST");
+	sqlite_command("PRAGMA busy_timeout = 2147483647");
+	sqlite_command("PRAGMA foreign_keys = ON");
+
+	if (exists) {
+		if (get_db_version() < SINDEX_DATABASE_VERSION)
+			sindex_error(1, 0, "%s: Database too old. Please rebuild it.", filename);
+		return;
+	}
+
+	set_db_version();
+
+	for (int i = 0; database_schema[i]; i++)
+		sqlite_command(database_schema[i]);
+}
+
+struct index_record {
+	const char *context;
+	int ctx_len;
+
+	const char *symbol;
+	int sym_len;
+
+	int kind;
+	unsigned int mode;
+	long long mtime;
+	sqlite3_int64 file;
+	int line;
+	int col;
+};
+
+static void insert_record(struct index_record *rec)
+{
+	sqlite_bind_text(insert_rec_stmt,  "@context", rec->context, rec->ctx_len);
+	sqlite_bind_text(insert_rec_stmt,  "@symbol",  rec->symbol, rec->sym_len);
+	sqlite_bind_int64(insert_rec_stmt, "@kind",    rec->kind);
+	sqlite_bind_int64(insert_rec_stmt, "@mode",    rec->mode);
+	sqlite_bind_int64(insert_rec_stmt, "@file",    rec->file);
+	sqlite_bind_int64(insert_rec_stmt, "@line",    rec->line);
+	sqlite_bind_int64(insert_rec_stmt, "@column",  rec->col);
+	sqlite_run(insert_rec_stmt);
+	sqlite_reset_stmt(insert_rec_stmt);
+}
+
+static void update_stream(void)
+{
+	if (sindex_streams_nr >= input_stream_nr)
+		return;
+
+	sindex_streams = realloc(sindex_streams, input_stream_nr * sizeof(struct sindex_streams));
+	if (!sindex_streams)
+		sindex_error(1, errno, "realloc");
+
+	sqlite_run(lock_stmt);
+
+	for (int i = sindex_streams_nr; i < input_stream_nr; i++) {
+		struct stat st;
+		const char *filename;
+		char fullname[PATH_MAX];
+		sqlite3_int64 cur_mtime = 0;
+
+		if (input_streams[i].fd != -1) {
+			/*
+			 * FIXME: Files in the input_streams may be duplicated.
+			 */
+			if (stat(input_streams[i].name, &st) < 0)
+				sindex_error(1, errno, "stat: %s", input_streams[i].name);
+
+			cur_mtime = st.st_mtim.tv_sec;
+
+			if (!realpath(input_streams[i].name, fullname))
+				sindex_error(1, errno, "realpath: %s", input_streams[i].name);
+
+			if (!strncmp(fullname, cwd, n_cwd) && fullname[n_cwd] == '/') {
+				filename = fullname + n_cwd + 1;
+				sindex_streams[i].id = 0;
+			} else {
+				sindex_streams[i].id = -1;
+				continue;
+			}
+		} else {
+			sindex_streams[i].id = -1;
+			continue;
+		}
+
+		if (sindex_verbose > 1)
+			message("filename: %s", filename);
+
+		sqlite_bind_text(select_file_stmt, "@name", filename, -1);
+
+		if (sqlite_run(select_file_stmt) == SQLITE_ROW) {
+			sqlite3_int64 old_mtime;
+
+			sindex_streams[i].id = sqlite3_column_int64(select_file_stmt, 0);
+			old_mtime = sqlite3_column_int64(select_file_stmt, 1);
+
+			sqlite_reset_stmt(select_file_stmt);
+
+			if (cur_mtime == old_mtime)
+				continue;
+
+			sqlite_bind_text(delete_file_stmt, "@name", filename, -1);
+			sqlite_run(delete_file_stmt);
+			sqlite_reset_stmt(delete_file_stmt);
+		}
+
+		sqlite_reset_stmt(select_file_stmt);
+
+		sqlite_bind_text(insert_file_stmt,  "@name",  filename, -1);
+		sqlite_bind_int64(insert_file_stmt, "@mtime", cur_mtime);
+		sqlite_run(insert_file_stmt);
+		sqlite_reset_stmt(insert_file_stmt);
+
+		sindex_streams[i].id = sqlite3_last_insert_rowid(sindex_db);
+	}
+
+	sqlite_run(unlock_stmt);
+
+	sindex_streams_nr = input_stream_nr;
+}
+
+static void r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
+{
+	static struct ident null;
+	struct ident *ctx = &null;
+	struct index_record rec;
+
+	update_stream();
+
+	if (sindex_streams[pos->stream].id == -1)
+		return;
+
+	if (!sindex_include_local_syms && sym_is_local(sym))
+		return;
+
+	if (!sym->ident) {
+		warning(*pos, "empty ident");
+		return;
+	}
+
+	if (dissect_ctx)
+		ctx = dissect_ctx->ident;
+
+	rec.context = ctx->name;
+	rec.ctx_len = ctx->len;
+	rec.symbol  = sym->ident->name;
+	rec.sym_len = sym->ident->len;
+	rec.kind    = sym->kind;
+	rec.mode    = mode;
+	rec.file    = sindex_streams[pos->stream].id;
+	rec.line    = pos->line;
+	rec.col     = pos->pos;
+
+	insert_record(&rec);
+}
+
+static void r_member(unsigned mode, struct position *pos, struct symbol *sym, struct symbol *mem)
+{
+	static struct ident null;
+	static char memname[1024];
+	struct ident *ni, *si, *mi;
+	struct ident *ctx = &null;
+	struct index_record rec;
+
+	update_stream();
+
+	if (sindex_streams[pos->stream].id == -1)
+		return;
+
+	if (!sindex_include_local_syms && sym_is_local(sym))
+		return;
+
+	ni = built_in_ident("?");
+	si = sym->ident ?: ni;
+	/* mem == NULL means entire struct accessed */
+	mi = mem ? (mem->ident ?: ni) : built_in_ident("*");
+
+	if (dissect_ctx)
+		ctx = dissect_ctx->ident;
+
+	snprintf(memname, sizeof(memname), "%.*s.%.*s", si->len, si->name, mi->len, mi->name);
+
+	rec.context = ctx->name;
+	rec.ctx_len = ctx->len;
+	rec.symbol  = memname;
+	rec.sym_len = si->len + mi->len + 1;
+	rec.kind    = 'm';
+	rec.mode    = mode;
+	rec.file    = sindex_streams[pos->stream].id;
+	rec.line    = pos->line;
+	rec.col     = pos->pos;
+
+	insert_record(&rec);
+}
+
+static void r_symdef(struct symbol *sym)
+{
+	r_symbol(U_DEF, &sym->pos, sym);
+}
+
+static void r_memdef(struct symbol *sym, struct symbol *mem)
+{
+	r_member(U_DEF, &mem->pos, sym, mem);
+}
+
+static void command_add(int argc, char **argv)
+{
+	static struct reporter reporter = {
+		.r_symdef = r_symdef,
+		.r_symbol = r_symbol,
+		.r_memdef = r_memdef,
+		.r_member = r_member,
+	};
+
+	open_temp_database();
+
+	sqlite_prepare_persistent(
+		"BEGIN IMMEDIATE",
+		&lock_stmt);
+
+	sqlite_prepare_persistent(
+		"COMMIT",
+		&unlock_stmt);
+
+	sqlite_prepare_persistent(
+		"INSERT OR IGNORE INTO tempdb.sindex "
+		"(context, symbol, kind, mode, file, line, column) "
+		"VALUES (@context, @symbol, @kind, @mode, @file, @line, @column)",
+		&insert_rec_stmt);
+
+	sqlite_prepare_persistent(
+		"SELECT id, mtime FROM file WHERE name == @name",
+		&select_file_stmt);
+
+	sqlite_prepare_persistent(
+		"INSERT INTO file (name, mtime) VALUES (@name, @mtime)",
+		&insert_file_stmt);
+
+	sqlite_prepare_persistent(
+		"DELETE FROM file WHERE name == @name",
+		&delete_file_stmt);
+
+	dissect(&reporter, sindex_filelist);
+
+	sqlite_run(lock_stmt);
+	sqlite_command("INSERT OR IGNORE INTO sindex SELECT * FROM tempdb.sindex");
+	sqlite_run(unlock_stmt);
+
+	sqlite3_finalize(insert_rec_stmt);
+	sqlite3_finalize(select_file_stmt);
+	sqlite3_finalize(insert_file_stmt);
+	sqlite3_finalize(delete_file_stmt);
+	sqlite3_finalize(lock_stmt);
+	sqlite3_finalize(unlock_stmt);
+	free(sindex_streams);
+}
+
+static void command_rm(int argc, char **argv)
+{
+	sqlite3_stmt *stmt;
+
+	sqlite_command("BEGIN IMMEDIATE");
+	sqlite_prepare("DELETE FROM file WHERE name GLOB @file", &stmt);
+
+	if (sindex_verbose > 1)
+		message("SQL: %s", sqlite3_sql(stmt));
+
+	for (int i = 0; i < argc; i++) {
+		sqlite_bind_text(stmt, "@file",  argv[i], -1);
+		sqlite_run(stmt);
+		sqlite_reset_stmt(stmt);
+	}
+
+	sqlite3_finalize(stmt);
+	sqlite_command("COMMIT");
+}
+
+static inline void print_mode(char *value)
+{
+	char str[3];
+	int v = atoi(value);
+
+	if (v == U_DEF) {
+		printf("def");
+		return;
+	}
+
+#define U(m) "-rwm"[(v / m) & 3]
+	str[0] = U(U_R_AOF);
+	str[1] = U(U_R_VAL);
+	str[2] = U(U_R_PTR);
+
+	printf("%.3s", str);
+#undef U
+}
+
+static char *sindex_file_name;
+static FILE *sindex_file_fd;
+static int sindex_file_lnum;
+static char *sindex_line;
+static size_t sindex_line_buflen;
+static int sindex_line_len;
+
+static void print_file_line(const char *name, int lnum)
+{
+	/*
+	 * All files are sorted by name and line number. So, we can reopen
+	 * the file and read it line by line.
+	 */
+	if (!sindex_file_name || strcmp(sindex_file_name, name)) {
+		if (sindex_file_fd) {
+			fclose(sindex_file_fd);
+			free(sindex_file_name);
+		}
+
+		sindex_file_name = strdup(name);
+
+		if (!sindex_file_name)
+			sindex_error(1, errno, "strdup");
+
+		sindex_file_fd = fopen(name, "r");
+
+		if (!sindex_file_fd)
+			sindex_error(1, errno, "fopen: %s", name);
+
+		sindex_file_lnum = 0;
+	}
+
+	do {
+		if (sindex_file_lnum == lnum) {
+			if (sindex_line[sindex_line_len-1] == '\n')
+				sindex_line_len--;
+			printf("%.*s", sindex_line_len, sindex_line);
+			break;
+		}
+		sindex_file_lnum++;
+		errno = 0;
+	} while((sindex_line_len = getline(&sindex_line, &sindex_line_buflen, sindex_file_fd)) != -1);
+
+	if (errno && errno != EOF)
+		sindex_error(1, errno, "getline");
+}
+
+static int search_query_callback(void *data, int argc, char **argv, char **colname)
+{
+	char *fmt = (char *) sindex_search_format;
+	char buf[32];
+	int quote = 0;
+	int n = 0;
+
+	while (*fmt != '\0') {
+		char c = *fmt;
+
+		if (quote) {
+			quote = 0;
+			switch (c) {
+				case 't': c = '\t'; break;
+				case 'r': c = '\r'; break;
+				case 'n': c = '\n'; break;
+			}
+		} else if (c == '%') {
+			int colnum = 0;
+			char *pos = ++fmt;
+
+			c = *fmt;
+
+			if (c == '\0')
+				sindex_error(1, 0, "unexpected end of format string");
+
+			switch (c) {
+				case 'f': colnum = 0; goto print_string;
+				case 'l': colnum = 1; goto print_string;
+				case 'c': colnum = 2; goto print_string;
+				case 'C': colnum = 3; goto print_string;
+				case 'n': colnum = 4; goto print_string;
+				case 'm':
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					print_mode(argv[5]);
+					fmt++;
+					break;
+				case 'k':
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					printf("%c", atoi(argv[6]));
+					fmt++;
+					break;
+				case 's':
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					print_file_line(argv[0], atoi(argv[1]));
+					fmt++;
+					break;
+				case -1:
+print_string:
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					printf("%s", argv[colnum]);
+					fmt++;
+					break;
+			}
+
+			if (pos == fmt)
+				sindex_error(1, 0, "invalid format specification: %%%c", c);
+
+			continue;
+		} else if (c == '\\') {
+			quote = 1;
+			fmt++;
+			continue;
+		}
+
+		if (n == sizeof(buf)) {
+			printf("%.*s", n, buf);
+			n = 0;
+		}
+
+		buf[n++] = c;
+		fmt++;
+	}
+
+	if (n)
+		printf("%.*s", n, buf);
+	printf("\n");
+
+	return 0;
+}
+
+static void command_search(int argc, char **argv)
+{
+	char *sql;
+	char *dberr = NULL;
+	sqlite3_str *query = sqlite3_str_new(sindex_db);
+
+	if (query_appendf(query,
+	                  "SELECT"
+	                  " file.name,"
+	                  " sindex.line,"
+	                  " sindex.column,"
+	                  " sindex.context,"
+	                  " sindex.symbol,"
+	                  " sindex.mode,"
+	                  " sindex.kind "
+	                  "FROM sindex, file "
+	                  "WHERE sindex.file == file.id") < 0)
+		goto fail;
+
+	if (sindex_search_kind) {
+		if (query_appendf(query, " AND sindex.kind == %d", sindex_search_kind) < 0)
+			goto fail;
+	}
+
+	if (sindex_search_symbol) {
+		int ret;
+
+		if (query_appendf(query, " AND ") < 0)
+			goto fail;
+
+		if (strpbrk(sindex_search_symbol, "*?[]"))
+			ret = query_appendf(query, "sindex.symbol GLOB %Q", sindex_search_symbol);
+		else
+			ret = query_appendf(query, "sindex.symbol == %Q", sindex_search_symbol);
+
+		if (ret < 0)
+			goto fail;
+	}
+
+	if (sindex_search_modmask_defined) {
+		if (!sindex_search_modmask) {
+			if (query_appendf(query, " AND sindex.mode == %d", sindex_search_modmask) < 0)
+				goto fail;
+		} else if (query_appendf(query, " AND (sindex.mode & %d) != 0", sindex_search_modmask) < 0)
+			goto fail;
+	}
+
+	if (sindex_search_path) {
+		if (query_appendf(query, " AND file.name GLOB %Q", sindex_search_path) < 0)
+			goto fail;
+	}
+
+	if (query_appendf(query, " ORDER BY file.name, sindex.line, sindex.column ASC", sindex_search_path) < 0)
+		goto fail;
+
+	sql = sqlite3_str_value(query);
+
+	if (sindex_verbose > 1)
+		message("SQL: %s", sql);
+
+	sqlite3_exec(sindex_db, sql, search_query_callback, 0, &dberr);
+	if (dberr)
+		sindex_error(1, 0, "sql query failed: %s", dberr);
+fail:
+	sql = sqlite3_str_finish(query);
+	sqlite3_free(sql);
+
+	if (sindex_file_fd) {
+		fclose(sindex_file_fd);
+		free(sindex_file_name);
+	}
+	free(sindex_line);
+}
+
+
+int main(int argc, char **argv)
+{
+	static const struct command commands[] = {
+		{
+			.name          = "add",
+			.dbflags       = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,
+			.parse_cmdline = parse_cmdline_add,
+			.handler       = command_add
+		},
+		{
+			.name          = "rm",
+			.dbflags       = SQLITE_OPEN_READWRITE,
+			.parse_cmdline = parse_cmdline_rm,
+			.handler       = command_rm
+		},
+		{
+			.name          = "search",
+			.dbflags       = SQLITE_OPEN_READONLY,
+			.parse_cmdline = parse_cmdline_search,
+			.handler       = command_search
+		},
+		{ .name = NULL },
+	};
+	const struct command *cmd;
+
+	if (!(progname = rindex(argv[0], '/')))
+		progname = argv[0];
+	else
+		progname++;
+
+	if (!realpath(".", cwd))
+		sindex_error(1, errno, "unable to get current directory");
+	n_cwd = strlen(cwd);
+
+	parse_cmdline(argc, argv);
+
+	for (cmd = commands; cmd->name && strcmp(argv[optind], cmd->name); cmd++);
+	if (!cmd->name)
+		sindex_error(1, 0, "unknown command: %s", argv[optind]);
+	optind++;
+
+	sindex_command = cmd->name;
+
+	if (cmd->parse_cmdline)
+		cmd->parse_cmdline(argc, argv);
+
+	open_database(sindex_dbfile, cmd->dbflags);
+	cmd->handler(argc - optind, argv + optind);
+
+	sqlite3_close(sindex_db);
+
+	return 0;
+}
-- 
2.25.1

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2] Add semantic index utility
Date: Wed, 11 Mar 2020 21:56:23 +0000
Message-ID: <20200311215623.dafdzmub25dlb7za () ltop ! local>
--------------------
On Wed, Mar 11, 2020 at 06:22:46PM +0100, Alexey Gladkov wrote:
> sindex is the simple to use cscope-like tool based on sparse/dissect.
> Unlike cscope it runs after pre-processor and thus it can't index the
> code filtered out by ifdef's, but otoh it understands how the symbol
> is used and it can track the usage of struct members.

Great! Thank you.

I've pushed this with 2 small changes:
1) a bunch of s/0/NULL/ to quiet make selfcheck
2) s/st.st_mtim.tv_sec/st.st_mtime/ or comptability.

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH v3 00/16] support __packed struct ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 00/16] support __packed struct
Date: Thu, 31 Dec 2020 10:10:18 +0000
Message-ID: <20201231101034.59978-1-luc.vanoostenryck () gmail ! com>
--------------------
During parsing, Sparse recognizes the attribute 'packed' but this
attribute is otherwise ignored for several reasons:
1) the attribute in 'struct __attr { ... }' is wrongly handled as
   belonging to the whole declaration but it should belong to the type,
2) the attribute in 'struct <name> { ... } __attr;' is simply ignored,
3) the layout of packed bitfields need special care.

This series contains 2 parts:
1) handling of type attributes
2) correct layout of packed structs, including packed bitfields.


This series is also available for review and testing at:
  git://git.kernel.org/pub/scm/devel/sparse/sparse-dev.git packed-v3


Changes since v2 (all thanks to Ramsay Jones):
* correct several typos
* add an explanation for one of the test
* avoid sizeof() in tests where the size is constrained to some fixed value
* remove a redundency in a test (struct sb identical to struct sa)
* reformulate the commit message for apply_ctype()'s arguments reversal
* tweak the not-so-1-to-1 code movement
* fix the truncated commit message of the last patch

Changes since v1:
* fix layout of packed bitfields


Luc Van Oostenryck (16):
  add testcases for dubious enum values
  add testcases for exotic enum values
  add testcases for enum attributes
  add testcases for type attributes
  add testcases for packed structures
  add testcases for packed bitfields
  apply_ctype: use self-explanatory argument name
  apply_ctype: reverse the order of arguments
  apply_ctype: move up its declaration
  struct-attr: prepare to handle attributes at the end of struct
    definitions (1)
  struct-attr: prepare to handle attributes at the end of struct
    definitions (2)
  struct-attr: prepare to handle attributes at the end of struct
    definitions (3)
  struct-attr: fix type attribute like 'struct __attr { ... }'
  struct-attr: fix: do not ignore struct/union/enum type attributes
  packed: no out-of-bound access of packed bitfields
  packed: add support for __packed struct

 Documentation/TODO.md             |  3 --
 linearize.c                       | 13 +++++-
 parse.c                           | 78 ++++++++++++++++---------------
 symbol.c                          | 12 +++--
 symbol.h                          |  2 +
 validation/enum-type-dubious.c    | 18 +++++++
 validation/enum-type-exotic.c     | 28 +++++++++++
 validation/packed-bitfield0.c     | 58 +++++++++++++++++++++++
 validation/packed-bitfield1.c     | 27 +++++++++++
 validation/packed-bitfield2.c     | 15 ++++++
 validation/packed-bitfield3.c     | 28 +++++++++++
 validation/packed-bitfield4.c     | 18 +++++++
 validation/packed-bitfield5.c     | 20 ++++++++
 validation/packed-deref0.c        | 23 +++++++++
 validation/packed-struct.c        | 32 +++++++++++++
 validation/parsing/enum-attr.c    | 29 ++++++++++++
 validation/type-attribute-align.c | 19 ++++++++
 validation/type-attribute-as.c    | 33 +++++++++++++
 validation/type-attribute-mod.c   | 21 +++++++++
 validation/type-attribute-qual.c  | 15 ++++++
 20 files changed, 447 insertions(+), 45 deletions(-)
 create mode 100644 validation/enum-type-dubious.c
 create mode 100644 validation/enum-type-exotic.c
 create mode 100644 validation/packed-bitfield0.c
 create mode 100644 validation/packed-bitfield1.c
 create mode 100644 validation/packed-bitfield2.c
 create mode 100644 validation/packed-bitfield3.c
 create mode 100644 validation/packed-bitfield4.c
 create mode 100644 validation/packed-bitfield5.c
 create mode 100644 validation/packed-deref0.c
 create mode 100644 validation/packed-struct.c
 create mode 100644 validation/parsing/enum-attr.c
 create mode 100644 validation/type-attribute-align.c
 create mode 100644 validation/type-attribute-as.c
 create mode 100644 validation/type-attribute-mod.c
 create mode 100644 validation/type-attribute-qual.c

-- 
2.29.2

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH v3 00/16] support __packed struct
Date: Thu, 31 Dec 2020 15:30:24 +0000
Message-ID: <5c9945a4-f9bc-68a9-31f0-ae0958d06f84 () ramsayjones ! plus ! com>
--------------------


On 31/12/2020 10:10, Luc Van Oostenryck wrote:
> During parsing, Sparse recognizes the attribute 'packed' but this
> attribute is otherwise ignored for several reasons:
> 1) the attribute in 'struct __attr { ... }' is wrongly handled as
>    belonging to the whole declaration but it should belong to the type,
> 2) the attribute in 'struct <name> { ... } __attr;' is simply ignored,
> 3) the layout of packed bitfields need special care.
> 
> This series contains 2 parts:
> 1) handling of type attributes
> 2) correct layout of packed structs, including packed bitfields.
> 
> 
> This series is also available for review and testing at:
>   git://git.kernel.org/pub/scm/devel/sparse/sparse-dev.git packed-v3
> 
> 
> Changes since v2 (all thanks to Ramsay Jones):
> * correct several typos
> * add an explanation for one of the test
> * avoid sizeof() in tests where the size is constrained to some fixed value
> * remove a redundency in a test (struct sb identical to struct sa)
> * reformulate the commit message for apply_ctype()'s arguments reversal
> * tweak the not-so-1-to-1 code movement
> * fix the truncated commit message of the last patch

This all LGTM. Thanks!

ATB,
Ramsay Jones

> 
> Changes since v1:
> * fix layout of packed bitfields
> 
> 
> Luc Van Oostenryck (16):
>   add testcases for dubious enum values
>   add testcases for exotic enum values
>   add testcases for enum attributes
>   add testcases for type attributes
>   add testcases for packed structures
>   add testcases for packed bitfields
>   apply_ctype: use self-explanatory argument name
>   apply_ctype: reverse the order of arguments
>   apply_ctype: move up its declaration
>   struct-attr: prepare to handle attributes at the end of struct
>     definitions (1)
>   struct-attr: prepare to handle attributes at the end of struct
>     definitions (2)
>   struct-attr: prepare to handle attributes at the end of struct
>     definitions (3)
>   struct-attr: fix type attribute like 'struct __attr { ... }'
>   struct-attr: fix: do not ignore struct/union/enum type attributes
>   packed: no out-of-bound access of packed bitfields
>   packed: add support for __packed struct
> 
>  Documentation/TODO.md             |  3 --
>  linearize.c                       | 13 +++++-
>  parse.c                           | 78 ++++++++++++++++---------------
>  symbol.c                          | 12 +++--
>  symbol.h                          |  2 +
>  validation/enum-type-dubious.c    | 18 +++++++
>  validation/enum-type-exotic.c     | 28 +++++++++++
>  validation/packed-bitfield0.c     | 58 +++++++++++++++++++++++
>  validation/packed-bitfield1.c     | 27 +++++++++++
>  validation/packed-bitfield2.c     | 15 ++++++
>  validation/packed-bitfield3.c     | 28 +++++++++++
>  validation/packed-bitfield4.c     | 18 +++++++
>  validation/packed-bitfield5.c     | 20 ++++++++
>  validation/packed-deref0.c        | 23 +++++++++
>  validation/packed-struct.c        | 32 +++++++++++++
>  validation/parsing/enum-attr.c    | 29 ++++++++++++
>  validation/type-attribute-align.c | 19 ++++++++
>  validation/type-attribute-as.c    | 33 +++++++++++++
>  validation/type-attribute-mod.c   | 21 +++++++++
>  validation/type-attribute-qual.c  | 15 ++++++
>  20 files changed, 447 insertions(+), 45 deletions(-)
>  create mode 100644 validation/enum-type-dubious.c
>  create mode 100644 validation/enum-type-exotic.c
>  create mode 100644 validation/packed-bitfield0.c
>  create mode 100644 validation/packed-bitfield1.c
>  create mode 100644 validation/packed-bitfield2.c
>  create mode 100644 validation/packed-bitfield3.c
>  create mode 100644 validation/packed-bitfield4.c
>  create mode 100644 validation/packed-bitfield5.c
>  create mode 100644 validation/packed-deref0.c
>  create mode 100644 validation/packed-struct.c
>  create mode 100644 validation/parsing/enum-attr.c
>  create mode 100644 validation/type-attribute-align.c
>  create mode 100644 validation/type-attribute-as.c
>  create mode 100644 validation/type-attribute-mod.c
>  create mode 100644 validation/type-attribute-qual.c
> 
================================================================================


################################################################################

=== Thread: [PATCH v3 02/16] add testcases for exotic enum values ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 02/16] add testcases for exotic enum values
Date: Thu, 31 Dec 2020 10:10:20 +0000
Message-ID: <20201231101034.59978-3-luc.vanoostenryck () gmail ! com>
--------------------
There is more than one complexity in the evaluation of enums.

Add a test for enums with 'exotic' values not covered in other tests.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/enum-type-exotic.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)
 create mode 100644 validation/enum-type-exotic.c

diff --git a/validation/enum-type-exotic.c b/validation/enum-type-exotic.c
new file mode 100644
index 000000000000..a17ca0ad48ef
--- /dev/null
+++ b/validation/enum-type-exotic.c
@@ -0,0 +1,28 @@
+enum foobar {
+        C = (unsigned char)0,
+        L = 1L,
+};
+
+unsigned int foo(void);
+unsigned int foo(void)
+{
+#ifdef __CHECKER__
+	_Static_assert([typeof(C)] == [enum foobar], "enum type");
+	_Static_assert([typeof(C)] != [unsigned char], "char type");
+#endif
+
+	typeof(C) v = ~0;
+	return v;
+}
+
+/*
+ * check-name: enum-type-exotic
+ * check-description:
+ *	GCC type's for C is 'int' or maybe 'unsigned int'
+ *	but certainly not 'unsigned char' like here.
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-excludes: ret\\.32 *\\$255
+ */
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 03/16] add testcases for enum attributes ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 03/16] add testcases for enum attributes
Date: Thu, 31 Dec 2020 10:10:21 +0000
Message-ID: <20201231101034.59978-4-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/parsing/enum-attr.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 validation/parsing/enum-attr.c

diff --git a/validation/parsing/enum-attr.c b/validation/parsing/enum-attr.c
new file mode 100644
index 000000000000..a962d8b417af
--- /dev/null
+++ b/validation/parsing/enum-attr.c
@@ -0,0 +1,29 @@
+#define __attr __attribute__((deprecated))
+
+enum {
+	old __attr,
+	cur __attr = 42,
+	new,
+};
+
+enum odd {
+	odd = __attr 33,
+};
+
+enum bad {
+	bad = 43 __attr,
+};
+
+/*
+ * check-name: enum-attr
+ *
+ * check-error-start
+parsing/enum-attr.c:10:15: error: typename in expression
+parsing/enum-attr.c:10:15: error: undefined identifier '__attribute__'
+parsing/enum-attr.c:10:15: error: bad constant expression type
+parsing/enum-attr.c:10:22: error: Expected } at end of struct-union-enum-specifier
+parsing/enum-attr.c:10:22: error: got 33
+parsing/enum-attr.c:14:18: error: Expected } at end of struct-union-enum-specifier
+parsing/enum-attr.c:14:18: error: got __attribute__
+ * check-error-end
+ */
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 04/16] add testcases for type attributes ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 04/16] add testcases for type attributes
Date: Thu, 31 Dec 2020 10:10:22 +0000
Message-ID: <20201231101034.59978-5-luc.vanoostenryck () gmail ! com>
--------------------
Currently, type attributes are not handled correctly.

Add some testcases for them.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/type-attribute-align.c | 20 ++++++++++++++++++
 validation/type-attribute-as.c    | 34 +++++++++++++++++++++++++++++++
 validation/type-attribute-mod.c   | 22 ++++++++++++++++++++
 validation/type-attribute-qual.c  | 15 ++++++++++++++
 4 files changed, 91 insertions(+)
 create mode 100644 validation/type-attribute-align.c
 create mode 100644 validation/type-attribute-as.c
 create mode 100644 validation/type-attribute-mod.c
 create mode 100644 validation/type-attribute-qual.c

diff --git a/validation/type-attribute-align.c b/validation/type-attribute-align.c
new file mode 100644
index 000000000000..d9358bff8327
--- /dev/null
+++ b/validation/type-attribute-align.c
@@ -0,0 +1,20 @@
+#define __aligned(N)	__attribute__((aligned(N)))
+#define alignof(X)	__alignof__(X)
+
+struct s {
+	short a, b, c;
+} __aligned(2*sizeof(short));
+
+static int fs(void) { return  sizeof(struct s); }
+static int fa(void) { return alignof(struct s); }
+
+void main(void)
+{
+	_Static_assert( sizeof(struct s) == 4 * sizeof(short), "size");
+	_Static_assert(alignof(struct s) == 2 * sizeof(short), "alignment");
+}
+
+/*
+ * check-name: type-attribute-align
+ * check-known-to-fail
+ */
diff --git a/validation/type-attribute-as.c b/validation/type-attribute-as.c
new file mode 100644
index 000000000000..b40b4e7dddf5
--- /dev/null
+++ b/validation/type-attribute-as.c
@@ -0,0 +1,34 @@
+#define	__as		__attribute__((address_space(__as)))
+
+struct s {
+	int i;
+} __as;
+
+
+extern void use0(void *);
+extern void use1(void __as *);
+
+void main(void)
+{
+	struct s s;
+	int i;
+
+	use0(&s);	// KO
+	use0(&i);	// OK
+	use1(&s);	// OK
+	use1(&i);	// KO
+}
+
+/*
+ * check-name: type-attribute-as
+ * check-known-to-fail
+ *
+ * check-error-start
+type-attribute-as.c:16:15: warning: incorrect type in argument 1 (different address spaces)
+type-attribute-as.c:16:15:    expected void *
+type-attribute-as.c:16:15:    got struct s __as *
+type-attribute-as.c:19:15: warning: incorrect type in argument 1 (different address spaces)
+type-attribute-as.c:19:15:    expected void __as *
+type-attribute-as.c:19:15:    got int *
+ * check-error-end
+ */
diff --git a/validation/type-attribute-mod.c b/validation/type-attribute-mod.c
new file mode 100644
index 000000000000..0e7b166a4aec
--- /dev/null
+++ b/validation/type-attribute-mod.c
@@ -0,0 +1,22 @@
+#define	__noderef	__attribute__((noderef))
+
+struct s {
+	int i;
+} __noderef;
+
+
+void main(void)
+{
+	struct s s;
+
+	s.i = 0;
+}
+
+/*
+ * check-name: type-attribute-mod
+ * check-known-to-fail
+ *
+ * check-error-start
+type-attribute-mod.c:12:9: warning: dereference of noderef expression
+ * check-error-end
+ */
diff --git a/validation/type-attribute-qual.c b/validation/type-attribute-qual.c
new file mode 100644
index 000000000000..62d8b98ee3df
--- /dev/null
+++ b/validation/type-attribute-qual.c
@@ -0,0 +1,15 @@
+static const struct s {
+	int x;
+} map[2];
+
+static void foo(struct s *p, int v)
+{
+	p->x += v;
+}
+
+/*
+ * check-name: type-attribute-qual
+ * check-description: When declaring a type and a variable in the same
+ *	declaration, ensure that type qualifiers apply to the variable
+ *	and not to the type.
+ */
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 05/16] add testcases for packed structures ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 05/16] add testcases for packed structures
Date: Thu, 31 Dec 2020 10:10:23 +0000
Message-ID: <20201231101034.59978-6-luc.vanoostenryck () gmail ! com>
--------------------
Currently, packed structs are not handled correctly.

Add some testcases for them.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/packed-deref0.c | 24 ++++++++++++++++++++++++
 validation/packed-struct.c | 33 +++++++++++++++++++++++++++++++++
 2 files changed, 57 insertions(+)
 create mode 100644 validation/packed-deref0.c
 create mode 100644 validation/packed-struct.c

diff --git a/validation/packed-deref0.c b/validation/packed-deref0.c
new file mode 100644
index 000000000000..865ad68a4f37
--- /dev/null
+++ b/validation/packed-deref0.c
@@ -0,0 +1,24 @@
+#define	__packed	__attribute__((packed))
+
+typedef struct {
+	__INT8_TYPE__	a;
+	__INT16_TYPE__	b;
+	__INT32_TYPE__	c;
+} __packed obj_t;
+
+_Static_assert(sizeof(obj_t) == 7, "sizeof packed struct");
+
+static void foo(obj_t *ptr, int val)
+{
+	ptr->c = val;
+}
+
+static void bar(obj_t o)
+{
+	foo(&o, 0);
+}
+
+/*
+ * check-name: packed-deref0
+ * check-known-to-fail
+ */
diff --git a/validation/packed-struct.c b/validation/packed-struct.c
new file mode 100644
index 000000000000..e21d11538639
--- /dev/null
+++ b/validation/packed-struct.c
@@ -0,0 +1,33 @@
+#define __packed __attribute__((packed))
+
+typedef unsigned char   u8;
+typedef __UINT16_TYPE__ u16;
+typedef __UINT32_TYPE__ u32;
+typedef __UINT64_TYPE__ u64;
+
+struct a {
+	u8 a;
+	u8 b;
+	u16 c;
+} __packed;
+_Static_assert(__alignof(struct a) == 1, "align struct");
+_Static_assert(   sizeof(struct a) == 4, " size struct");
+
+struct b {
+	u32	a;
+	u32	b;
+} __packed;
+_Static_assert(__alignof(struct b) == 1, "align struct");
+_Static_assert(   sizeof(struct b) == 8, "size struct");
+
+struct c {
+	u16	a;
+	u32	b;
+} __packed;
+_Static_assert(__alignof(struct c) == 1, "align struct");
+_Static_assert(   sizeof(struct c) == 6, "size struct");
+
+/*
+ * check-name: packed-struct
+ * check-known-to-fail
+ */
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 07/16] apply_ctype: use self-explanatory argument name ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 07/16] apply_ctype: use self-explanatory argument name
Date: Thu, 31 Dec 2020 10:10:25 +0000
Message-ID: <20201231101034.59978-8-luc.vanoostenryck () gmail ! com>
--------------------
apply_ctype() is used to copy/apply things like modifiers
and address space from one type to another one.
But the names used for the two types are: 'ctype' & 'thistype'
which doesn't help at all to know which one is the 'source' type
and which one is the 'destination' type.

Change this by renaming these arguments to 'src' & 'dst'.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/parse.c b/parse.c
index 0b2685707b82..402214212d77 100644
--- a/parse.c
+++ b/parse.c
@@ -1043,7 +1043,7 @@ static struct token *enum_specifier(struct token *token, struct symbol *sym, str
 	return ret;
 }
 
-static void apply_ctype(struct position pos, struct ctype *thistype, struct ctype *ctype);
+static void apply_ctype(struct position pos, struct ctype *src, struct ctype *dst);
 
 static struct token *typeof_specifier(struct token *token, struct symbol *sym, struct decl_state *ctx)
 {
@@ -1427,24 +1427,24 @@ static struct token *generic_qualifier(struct token *next, struct symbol *sym, s
 	return next;
 }
 
-static void apply_ctype(struct position pos, struct ctype *thistype, struct ctype *ctype)
+static void apply_ctype(struct position pos, struct ctype *src, struct ctype *dst)
 {
-	unsigned long mod = thistype->modifiers;
+	unsigned long mod = src->modifiers;
 
 	if (mod)
-		apply_qualifier(&pos, ctype, mod);
+		apply_qualifier(&pos, dst, mod);
 
 	/* Context */
-	concat_ptr_list((struct ptr_list *)thistype->contexts,
-	                (struct ptr_list **)&ctype->contexts);
+	concat_ptr_list((struct ptr_list *)src->contexts,
+	                (struct ptr_list **)&dst->contexts);
 
 	/* Alignment */
-	if (thistype->alignment > ctype->alignment)
-		ctype->alignment = thistype->alignment;
+	if (src->alignment > dst->alignment)
+		dst->alignment = src->alignment;
 
 	/* Address space */
-	if (thistype->as)
-		ctype->as = thistype->as;
+	if (src->as)
+		dst->as = src->as;
 }
 
 static void specifier_conflict(struct position pos, int what, struct ident *new)
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 08/16] apply_ctype: reverse the order of arguments ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 08/16] apply_ctype: reverse the order of arguments
Date: Thu, 31 Dec 2020 10:10:26 +0000
Message-ID: <20201231101034.59978-9-luc.vanoostenryck () gmail ! com>
--------------------
apply_ctype()'s argument order confuse me endlessly as I'm much more
used to have the destination first and the source next (the so called
'assignment order' used for assignments but also in memcpy() and in
many sparse or library functions).

So, change the argument order of apply_ctype() to mimic the order
of memcpy()/assignment, to hopefully reduce my confusion.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/parse.c b/parse.c
index 402214212d77..f106444f75d8 100644
--- a/parse.c
+++ b/parse.c
@@ -1043,7 +1043,7 @@ static struct token *enum_specifier(struct token *token, struct symbol *sym, str
 	return ret;
 }
 
-static void apply_ctype(struct position pos, struct ctype *src, struct ctype *dst);
+static void apply_ctype(struct position pos, struct ctype *dst, struct ctype *src);
 
 static struct token *typeof_specifier(struct token *token, struct symbol *sym, struct decl_state *ctx)
 {
@@ -1056,7 +1056,7 @@ static struct token *typeof_specifier(struct token *token, struct symbol *sym, s
 		struct symbol *sym;
 		token = typename(token->next, &sym, NULL);
 		ctx->ctype.base_type = sym->ctype.base_type;
-		apply_ctype(token->pos, &sym->ctype, &ctx->ctype);
+		apply_ctype(token->pos, &ctx->ctype, &sym->ctype);
 	} else {
 		struct symbol *typeof_sym = alloc_symbol(token->pos, SYM_TYPEOF);
 		token = parse_expression(token->next, &typeof_sym->initializer);
@@ -1427,7 +1427,7 @@ static struct token *generic_qualifier(struct token *next, struct symbol *sym, s
 	return next;
 }
 
-static void apply_ctype(struct position pos, struct ctype *src, struct ctype *dst)
+static void apply_ctype(struct position pos, struct ctype *dst, struct ctype *src)
 {
 	unsigned long mod = src->modifiers;
 
@@ -1529,7 +1529,7 @@ static struct token *declaration_specifiers(struct token *token, struct decl_sta
 				break;
 			seen |= Set_S | Set_T;
 			ctx->ctype.base_type = s->ctype.base_type;
-			apply_ctype(token->pos, &s->ctype, &ctx->ctype);
+			apply_ctype(token->pos, &ctx->ctype, &s->ctype);
 			token = token->next;
 			continue;
 		}
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 10/16] struct-attr: prepare to handle attributes at the end of struct definitions (1) ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 10/16] struct-attr: prepare to handle attributes at the end of struct definitions (1)
Date: Thu, 31 Dec 2020 10:10:28 +0000
Message-ID: <20201231101034.59978-11-luc.vanoostenryck () gmail ! com>
--------------------
Type attributes for struct can be placed either just after the
keyword 'struct' or after the '}' ending its definition but this
later case is currently ignored.

Prepare the handling of this by factoring the code common to both
cases in a single place.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                        | 10 +++++-----
 validation/parsing/enum-attr.c |  4 ++--
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/parse.c b/parse.c
index d6343f0e48bf..41d3eb1ff4f8 100644
--- a/parse.c
+++ b/parse.c
@@ -745,12 +745,10 @@ static struct token *struct_union_enum_specifier(enum type type,
 			if (sym->symbol_list)
 				error_die(token->pos, "redefinition of %s", show_typename (sym));
 			sym->pos = *repos;
-			token = parse(token->next, sym);
-			token = expect(token, '}', "at end of struct-union-enum-specifier");
 
 			// Mark the structure as needing re-examination
 			sym->examined = 0;
-			sym->endpos = token->pos;
+			goto end;
 		}
 		return token;
 	}
@@ -764,9 +762,11 @@ static struct token *struct_union_enum_specifier(enum type type,
 
 	sym = alloc_symbol(token->pos, type);
 	set_current_scope(sym);		// used by dissect
-	token = parse(token->next, sym);
 	ctx->ctype.base_type = sym;
-	token =  expect(token, '}', "at end of specifier");
+end:
+	token = parse(token->next, sym);
+	token = expect(token, '}', "at end of specifier");
+
 	sym->endpos = token->pos;
 
 	return token;
diff --git a/validation/parsing/enum-attr.c b/validation/parsing/enum-attr.c
index a962d8b417af..8d851a162135 100644
--- a/validation/parsing/enum-attr.c
+++ b/validation/parsing/enum-attr.c
@@ -21,9 +21,9 @@ enum bad {
 parsing/enum-attr.c:10:15: error: typename in expression
 parsing/enum-attr.c:10:15: error: undefined identifier '__attribute__'
 parsing/enum-attr.c:10:15: error: bad constant expression type
-parsing/enum-attr.c:10:22: error: Expected } at end of struct-union-enum-specifier
+parsing/enum-attr.c:10:22: error: Expected } at end of specifier
 parsing/enum-attr.c:10:22: error: got 33
-parsing/enum-attr.c:14:18: error: Expected } at end of struct-union-enum-specifier
+parsing/enum-attr.c:14:18: error: Expected } at end of specifier
 parsing/enum-attr.c:14:18: error: got __attribute__
  * check-error-end
  */
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 11/16] struct-attr: prepare to handle attributes at the end of struct definitions (2) ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 11/16] struct-attr: prepare to handle attributes at the end of struct definitions (2)
Date: Thu, 31 Dec 2020 10:10:29 +0000
Message-ID: <20201231101034.59978-12-luc.vanoostenryck () gmail ! com>
--------------------
Type attributes for struct can be placed either just after the
keyword 'struct' or after the '}' ending its definition but this
later case is currently ignored.

Prepare the handling of this by restructuring the code handling
struct specifiers, namely inverting the condition so that the
function can return early to make next patch's job easier.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 26 +++++++++++++-------------
 1 file changed, 13 insertions(+), 13 deletions(-)

diff --git a/parse.c b/parse.c
index 41d3eb1ff4f8..663f2141dbf4 100644
--- a/parse.c
+++ b/parse.c
@@ -738,19 +738,19 @@ static struct token *struct_union_enum_specifier(enum type type,
 		ctx->ctype.base_type = sym;
 		repos = &token->pos;
 		token = token->next;
-		if (match_op(token, '{')) {
-			// The following test is actually wrong for empty
-			// structs, but (1) they are not C99, (2) gcc does
-			// the same thing, and (3) it's easier.
-			if (sym->symbol_list)
-				error_die(token->pos, "redefinition of %s", show_typename (sym));
-			sym->pos = *repos;
-
-			// Mark the structure as needing re-examination
-			sym->examined = 0;
-			goto end;
-		}
-		return token;
+		if (!match_op(token, '{'))
+			return token;
+
+		// The following test is actually wrong for empty
+		// structs, but (1) they are not C99, (2) gcc does
+		// the same thing, and (3) it's easier.
+		if (sym->symbol_list)
+			error_die(token->pos, "redefinition of %s", show_typename (sym));
+		sym->pos = *repos;
+
+		// Mark the structure as needing re-examination
+		sym->examined = 0;
+		goto end;
 	}
 
 	// private struct/union/enum type
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 12/16] struct-attr: prepare to handle attributes at the end of struct definitions (3) ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 12/16] struct-attr: prepare to handle attributes at the end of struct definitions (3)
Date: Thu, 31 Dec 2020 10:10:30 +0000
Message-ID: <20201231101034.59978-13-luc.vanoostenryck () gmail ! com>
--------------------
Type attributes for struct can be placed either just after the
keyword 'struct' or after the '}' ending its definition but this
later case is currently ignored.

Prepare the handling of this by having the 3 following cases in sequence:
1) a tag is present
2) no tag present but is followed by an opening brace
3) neither of these, so it's an error.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 15 ++++++---------
 1 file changed, 6 insertions(+), 9 deletions(-)

diff --git a/parse.c b/parse.c
index 663f2141dbf4..69bfc2e0fe57 100644
--- a/parse.c
+++ b/parse.c
@@ -750,20 +750,17 @@ static struct token *struct_union_enum_specifier(enum type type,
 
 		// Mark the structure as needing re-examination
 		sym->examined = 0;
-		goto end;
-	}
-
-	// private struct/union/enum type
-	if (!match_op(token, '{')) {
+	} else if (match_op(token, '{')) {
+		// private struct/union/enum type
+		sym = alloc_symbol(token->pos, type);
+		set_current_scope(sym);		// used by dissect
+		ctx->ctype.base_type = sym;
+	} else {
 		sparse_error(token->pos, "expected declaration");
 		ctx->ctype.base_type = &bad_ctype;
 		return token;
 	}
 
-	sym = alloc_symbol(token->pos, type);
-	set_current_scope(sym);		// used by dissect
-	ctx->ctype.base_type = sym;
-end:
 	token = parse(token->next, sym);
 	token = expect(token, '}', "at end of specifier");
 
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 14/16] struct-attr: fix: do not ignore struct/union/enum type attributes ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 14/16] struct-attr: fix: do not ignore struct/union/enum type attributes
Date: Thu, 31 Dec 2020 10:10:32 +0000
Message-ID: <20201231101034.59978-15-luc.vanoostenryck () gmail ! com>
--------------------
GCC's syntax for type attributes is specified as:
    An attribute specifier list may appear as part of a struct,
    union or enum specifier. It may go either immediately after
    the struct, union or enum keyword, or after the closing brace.
    The former syntax is preferred. Where attribute specifiers
    follow the closing brace, they are considered to relate to
    the structure, union or enumerated type defined, not to any
    enclosing declaration the type specifier appears in, and the type
    defined is not complete until after the attribute specifiers.
In the section about type attributes, it's also said:
    You may specify type attributes in an enum, struct or union type
    declaration or definition by placing them immediately after the
    struct, union or enum keyword. A less preferred syntax is to
    place them just past the closing curly brace of the definition.

So, while placing the attribute after the closing curly is not
preferred, it is cleary legal (and it seems to be much more popular
than placing them just after the struct, union or enum keyword).

However, currently sparse doesn't handle this correctly:
- these attributes are parsed in declaration_specifiers() and
  added to the current decl_state
- when the ';' ending the type declaration is reached, the plain
  struct/union/enum is used and the content of the decl_state is
  simply ignored.
- if the declaration is for a variable, then those attributes
  are assigned to the variable (but not to the type).

Fix this by calling handle_attribute() once we have reached the
closing '}' of a struct/union/enum definition and applying these
attributes, if any, directly to the current base type.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                           | 2 ++
 validation/packed-bitfield3.c     | 1 -
 validation/packed-bitfield4.c     | 1 -
 validation/type-attribute-align.c | 1 -
 validation/type-attribute-as.c    | 1 -
 validation/type-attribute-mod.c   | 1 -
 6 files changed, 2 insertions(+), 5 deletions(-)

diff --git a/parse.c b/parse.c
index b38615b8d61d..338e525f46b9 100644
--- a/parse.c
+++ b/parse.c
@@ -764,6 +764,8 @@ static struct token *struct_union_enum_specifier(enum type type,
 
 	token = parse(token->next, sym);
 	token = expect(token, '}', "at end of specifier");
+	attr.ctype.base_type = sym;
+	token = handle_attributes(token, &attr);
 	apply_ctype(token->pos, &sym->ctype, &attr.ctype);
 
 	sym->endpos = token->pos;
diff --git a/validation/packed-bitfield3.c b/validation/packed-bitfield3.c
index c06e7c41cbcd..13368c84469e 100644
--- a/validation/packed-bitfield3.c
+++ b/validation/packed-bitfield3.c
@@ -25,5 +25,4 @@ _Static_assert(   sizeof(struct c) == 8);
 
 /*
  * check-name: packed-bitfield3
- * check-known-to-fail
  */
diff --git a/validation/packed-bitfield4.c b/validation/packed-bitfield4.c
index 0342b2414b6e..1a956344f2d3 100644
--- a/validation/packed-bitfield4.c
+++ b/validation/packed-bitfield4.c
@@ -15,5 +15,4 @@ static int ld(struct s *s)
 /*
  * check-name: packed-bitfield4
  * check-description: Is check_access() OK with short packed bitfields?
- * check-known-to-fail
  */
diff --git a/validation/type-attribute-align.c b/validation/type-attribute-align.c
index d9358bff8327..5f3db14aceb1 100644
--- a/validation/type-attribute-align.c
+++ b/validation/type-attribute-align.c
@@ -16,5 +16,4 @@ void main(void)
 
 /*
  * check-name: type-attribute-align
- * check-known-to-fail
  */
diff --git a/validation/type-attribute-as.c b/validation/type-attribute-as.c
index b40b4e7dddf5..38f06b374e25 100644
--- a/validation/type-attribute-as.c
+++ b/validation/type-attribute-as.c
@@ -21,7 +21,6 @@ void main(void)
 
 /*
  * check-name: type-attribute-as
- * check-known-to-fail
  *
  * check-error-start
 type-attribute-as.c:16:15: warning: incorrect type in argument 1 (different address spaces)
diff --git a/validation/type-attribute-mod.c b/validation/type-attribute-mod.c
index 0e7b166a4aec..d55011dfa09a 100644
--- a/validation/type-attribute-mod.c
+++ b/validation/type-attribute-mod.c
@@ -14,7 +14,6 @@ void main(void)
 
 /*
  * check-name: type-attribute-mod
- * check-known-to-fail
  *
  * check-error-start
 type-attribute-mod.c:12:9: warning: dereference of noderef expression
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH v3 15/16] packed: no out-of-bound access of packed bitfields ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 15/16] packed: no out-of-bound access of packed bitfields
Date: Thu, 31 Dec 2020 10:10:33 +0000
Message-ID: <20201231101034.59978-16-luc.vanoostenryck () gmail ! com>
--------------------
There is (at least) 2 ways by which packed bitfields doesn't
follow normal layout/access rules and as consequence can't (always)
be accessed the usual way (load the whole underlying word, then shift
and mask to isolate the bitfield).

At least two different cases are a concern:
1) there is no padding at the end of a bitfield sequence. For example,
   the following struct is only 3 bytes width:
	struct s {
		int f:24;
	} __packed;
   So, trying to access the bitfield by first doing a 32-bit load
   will create an out-of-bound access.

2) a bitfield smaller than one word may need more than one word to be
   accessed. For example, with the following struct
	struct {
		int a:5;
		int f:30;
		int z:5;
	} __packed;
   the bitfield 'f', while smaller than one 32-bit word, can't be accessed
   with a single 32-bit access.

At machine level, these bitfields should be accessed with several, possibly
smaller, loads and their corresponding values reconstructed from these,
making things much more complicated than for non-packed bitfields.

But at IR level, things can be a little more flexible and things can stay
simple by using sub-word or super-word accesses (until these need to
be lowered to be usable at machine level). In other words, the example here
can be safely accessed with respectively a 24-bit and a 40-bit load.
This is what is done in this patch.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c | 13 +++++++++++--
 symbol.h    |  1 +
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/linearize.c b/linearize.c
index 0250c6bb17ef..e80715ab2458 100644
--- a/linearize.c
+++ b/linearize.c
@@ -977,8 +977,17 @@ static struct symbol *bitfield_base_type(struct symbol *sym)
 	if (sym) {
 		if (sym->type == SYM_NODE)
 			base = base->ctype.base_type;
-		if (base->type == SYM_BITFIELD)
-			return base->ctype.base_type;
+		if (base->type == SYM_BITFIELD) {
+			base = base->ctype.base_type;
+			if (sym->packed) {
+				int size = bits_to_bytes(sym->bit_offset + sym->bit_size);
+				sym = __alloc_symbol(0);
+				*sym = *base;
+				sym->bit_size = bytes_to_bits(size);
+				return sym;
+			}
+			return base;
+		}
 	}
 	return sym;
 }
diff --git a/symbol.h b/symbol.h
index 5c5a7f12affa..866d57522f49 100644
--- a/symbol.h
+++ b/symbol.h
@@ -192,6 +192,7 @@ struct symbol {
 					accessed:1,
 					builtin:1,
 					torename:1,
+					packed:1,
 					transparent_union:1;
 			int		rank:3;	// arithmetic's rank
 			struct expression *array_size;
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH] Add symantic index utility ===

From: Alexey Gladkov <gladkov.alexey () gmail ! com>
To: linux-sparse
Subject: [PATCH] Add symantic index utility
Date: Mon, 09 Mar 2020 15:25:09 +0000
Message-ID: <20200309152509.6707-1-gladkov.alexey () gmail ! com>
--------------------
sindex is the simple to use cscope-like tool based on sparse/dissect.
Unlike cscope it runs after pre-processor and thus it can't index the
code filtered out by ifdef's, but otoh it understands how the symbol
is used and it can track the usage of struct members.

To create an index for your linux kernel configuration:

$ make C=2 CHECK="sindex add --"

Now, to find where a definition of the pid field from the task_struct
structure:

$ sindex search -m def task_struct.pid
(def) include/linux/sched.h 793 11   pid_t    pid;

default output format:

SOURCE-FILE \t LINE-NUMBER \t COLUMN \t IN FUNCTION NAME \t CODE LINE

To find where this field changes:

$ sindex search -m w task_struct.pid
(-w-) fs/exec.c 1154 6 de_thread   tsk->pid = leader->pid;
(-w-) kernel/fork.c 2155 3 copy_process  p->pid = pid_nr(pid);

To get only filenames and line number you can change output format:

$ sindex search -f '%f:%l' -m w task_struct.pid
fs/exec.c:1154
kernel/fork.c:2155

Current limitations:

* inline functions are ignored;
* unknown #include leads to a fatal error.

Suggested-by: Oleg Nesterov <oleg@redhat.com>
Signed-off-by: Oleg Nesterov <oleg@redhat.com>
Signed-off-by: Alexey Gladkov <gladkov.alexey@gmail.com>
---
 .gitignore |    1 +
 Makefile   |   11 +-
 sindex.c   | 1109 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 1120 insertions(+), 1 deletion(-)
 create mode 100644 sindex.c

diff --git a/.gitignore b/.gitignore
index 91305a6a..58598364 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,6 +19,7 @@ graph
 obfuscate
 sparse
 sparse-llvm
+sindex
 test-dissect
 test-inspect
 test-lexing
diff --git a/Makefile b/Makefile
index e2d3a7de..7b269950 100644
--- a/Makefile
+++ b/Makefile
@@ -140,6 +140,16 @@ else
 $(warning Your system does not have libxml, disabling c2xml)
 endif
 
+HAVE_SQLITE := $(shell $(PKG_CONFIG) --exists sqlite3 2>/dev/null && echo 'yes')
+ifeq ($(HAVE_SQLITE),yes)
+PROGRAMS += sindex
+INST_PROGRAMS += sindex
+sindex-ldlibs := $(shell $(PKG_CONFIG) --libs sqlite3)
+sindex-cflags := $(shell $(PKG_CONFIG) --cflags sqlite3)
+else
+$(warning Your system does not have sqlite3, disabling sindex)
+endif
+
 # Can we use gtk (needed for test-inspect)
 GTK_VERSION:=3.0
 HAVE_GTK:=$(shell $(PKG_CONFIG) --exists gtk+-$(GTK_VERSION) 2>/dev/null && echo 'yes')
@@ -228,7 +238,6 @@ cflags   += $($(*)-cflags) $(CPPFLAGS) $(CFLAGS)
 
 selfcheck: $(OBJS:.o=.sc)
 
-
 SPARSE_VERSION:=$(shell git describe --dirty 2>/dev/null || echo '$(VERSION)')
 lib.o: version.h
 version.h: FORCE
diff --git a/sindex.c b/sindex.c
new file mode 100644
index 00000000..8478fe33
--- /dev/null
+++ b/sindex.c
@@ -0,0 +1,1109 @@
+/*
+ * sindex - semantic indexer for C.
+ *
+ * Copyright (C) 2020  Alexey Gladkov
+ */
+
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <unistd.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <errno.h>
+#include <error.h>
+#include <sqlite3.h>
+
+#include "dissect.h"
+
+#define U_DEF (0x100 << U_SHIFT)
+#define SINDEX_DATABASE_VERSION 1
+
+#define message(fmt, ...) error(0, 0, (fmt), ##__VA_ARGS__)
+
+static const char *sindex_command = NULL;
+
+// common options
+static const char *sindex_dbfile = "sindex.sqlite";
+static int sindex_verbose = 0;
+static char cwd[PATH_MAX];
+static size_t n_cwd;
+
+// 'add' command options
+static struct string_list *sindex_filelist = NULL;
+static int sindex_include_local_syms = 0;
+
+struct sindex_streams {
+	sqlite3_int64 id;
+};
+
+static struct sindex_streams *sindex_streams = NULL;
+static int sindex_streams_nr = 0;
+
+// 'search' command options
+static int sindex_search_modmask;
+static int sindex_search_modmask_defined = 0;
+static int sindex_search_kind = 0;
+static char *sindex_search_path = NULL;
+static char *sindex_search_symbol = NULL;
+static const char *sindex_search_format = "(%m) %f\t%l\t%c\t%C\t%s";
+
+static sqlite3 *sindex_db = NULL;
+static sqlite3_stmt *lock_stmt = NULL;
+static sqlite3_stmt *unlock_stmt = NULL;
+static sqlite3_stmt *insert_rec_stmt = NULL;
+static sqlite3_stmt *select_file_stmt = NULL;
+static sqlite3_stmt *insert_file_stmt = NULL;
+static sqlite3_stmt *delete_file_stmt = NULL;
+
+struct command {
+	const char *name;
+	int dbflags;
+	void (*parse_cmdline)(int argc, char **argv);
+	void (*handler)(int argc, char **argv);
+};
+
+static void
+show_usage(void)
+{
+	if (sindex_command)
+		printf("Try '%s %s --help' for more information.\n",
+		       program_invocation_short_name, sindex_command);
+	else
+		printf("Try '%s --help' for more information.\n",
+		       program_invocation_short_name);
+	exit(1);
+}
+
+static void
+show_help(int ret)
+{
+	printf(
+	    "Usage: %1$s [options]\n"
+	    "   or: %1$s [options] add    [command options] [--] [compiler options] [files...]\n"
+	    "   or: %1$s [options] rm     [command options] pattern\n"
+	    "   or: %1$s [options] search [command options] pattern\n"
+	    "\n"
+	    "These are common %1$s commands used in various situations:\n"
+	    "  add      Generate or updates symantic index file for c-source code;\n"
+	    "  rm       Remove files from the index by pattern;\n"
+	    "  search   Make index queries.\n"
+	    "\n"
+	    "Options:\n"
+	    "  -D, --database=FILE    Specify database file (default: %2$s);\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "Environment:\n"
+	    "  SINDEX_DATABASE        Database file location.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    program_invocation_short_name, sindex_dbfile);
+	exit(ret);
+}
+
+static void
+show_help_add(int ret)
+{
+	printf(
+	    "Usage: %1$s add [options] [--] [compiler options] files...\n"
+	    "\n"
+	    "Utility creates or updates a symbol index.\n"
+	    "\n"
+	    "Options:\n"
+	    "  --include-local-syms   Include into the index local symbols;\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "Environment:\n"
+	    "  SINDEX_BASEDIRE        Project top directory.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    program_invocation_short_name);
+	exit(ret);
+
+}
+
+static void
+show_help_rm(int ret)
+{
+	printf(
+	    "Usage: %1$s rm [options] pattern\n"
+	    "\n"
+	    "Utility removes source files from the index.\n"
+	    "The pattern is a glob(7) wildcard pattern.\n"
+	    "\n"
+	    "Options:\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    program_invocation_short_name);
+	exit(ret);
+}
+
+static void
+show_help_search(int ret)
+{
+	printf(
+	    "Usage: %1$s search [options] [pattern]\n"
+	    "\n"
+	    "Utility searches information about symbol by pattern.\n"
+	    "The pattern is a glob(7) wildcard pattern.\n"
+	    "\n"
+	    "Options:\n"
+	    "  -f, --format=STRING    Specify an output format;\n"
+	    "  -p, --path=PATTERN     Search symbols only in specified directories;\n"
+	    "  -m, --mode=MODE        Search only the specified type of access;\n"
+	    "  -k, --kind=KIND        Specify a kind of symbol;\n"
+	    "  -v, --verbose          Show information about what is being done;\n"
+	    "  -h, --help             Show this text and exit.\n"
+	    "\n"
+	    "The KIND can be one of the following: `s', `f', `v', `m'.\n"
+	    "\n"
+	    "Report bugs to authors.\n"
+	    "\n",
+	    program_invocation_short_name);
+	exit(ret);
+}
+
+static void
+sindex_error_print_progname(void)
+{
+	fprintf(stderr, "%s: ", program_invocation_short_name);
+	if (sindex_command)
+		fprintf(stderr, "%s: ", sindex_command);
+}
+
+static void
+set_search_modmask(const char *v)
+{
+	size_t n = strlen(v);
+
+	if (n != 1 && n != 3)
+		error(1, 0, "the length of mode value must be 1 or 3: %s", v);
+
+	sindex_search_modmask_defined = 1;
+	sindex_search_modmask = 0;
+
+	if (n == 1) {
+		switch (v[0]) {
+			case 'r': v = "rrr"; break;
+			case 'w': v = "ww-"; break;
+			case 'm': v = "mmm"; break;
+			case '-': v = "---"; break;
+			default: error(1, 0, "unknown modificator: %s", v);
+		}
+	} else if (!strcmp(v, "def")) {
+		sindex_search_modmask = U_DEF;
+		return;
+	}
+
+	int modes[] = {
+		U_R_AOF, U_W_AOF, U_R_AOF | U_W_AOF,
+		U_R_VAL, U_W_VAL, U_R_VAL | U_W_VAL,
+		U_R_PTR, U_W_PTR, U_R_PTR | U_W_PTR,
+	};
+
+	for (int i = 0; i < 3; i++) {
+		switch (v[i]) {
+			case 'r': sindex_search_modmask |= modes[i * 3];     break;
+			case 'w': sindex_search_modmask |= modes[i * 3 + 1]; break;
+			case 'm': sindex_search_modmask |= modes[i * 3 + 2]; break;
+			case '-': break;
+			default:  error(1, 0,
+			                "unknown modificator in the mode value"
+			                " (`r', `w', `m' or `-' expected): %c", v[i]);
+		}
+	}
+}
+
+static void
+parse_cmdline(int argc, char **argv)
+{
+	static struct option long_options[] = {
+		{ "database", required_argument, 0, 'D' },
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{0, 0, 0, 0 }
+	};
+	int c;
+	char *env;
+
+	if ((env = getenv("SINDEX_DATABASE")) != NULL)
+		sindex_dbfile = env;
+
+	while ((c = getopt_long(argc, argv, "+D:vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 'D':
+				sindex_dbfile = optarg;
+				break;
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help(0);
+		}
+	}
+
+	if (optind == argc) {
+		message("command required");
+		show_usage();
+	}
+}
+
+static void
+parse_cmdline_add(int argc, char **argv)
+{
+	static struct option long_options[] = {
+		{ "include-local-syms", no_argument, 0, 1 },
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{0, 0, 0, 0 }
+	};
+	int c;
+
+	opterr = 0;
+
+	while ((c = getopt_long(argc, argv, "+vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 1:
+				sindex_include_local_syms = 1;
+				break;
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help_add(0);
+			case '?':
+				goto done;
+		}
+	}
+done:
+	if (optind == argc) {
+		message("more arguments required");
+		show_usage();
+	}
+
+	// enforce tabstop
+	tabstop = 1;
+
+	// step back since sparse_initialize will ignore argv[0].
+	optind--;
+
+	sparse_initialize(argc - optind, argv + optind, &sindex_filelist);
+}
+
+static void
+parse_cmdline_rm(int argc, char **argv)
+{
+	static struct option long_options[] = {
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{0, 0, 0, 0 }
+	};
+	int c;
+
+	while ((c = getopt_long(argc, argv, "+vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help_rm(0);
+		}
+	}
+
+	if (optind == argc) {
+		message("more arguments required");
+		show_usage();
+	}
+}
+
+static void
+parse_cmdline_search(int argc, char **argv)
+{
+	struct option long_options[] = {
+		{ "format", required_argument, 0, 'f' },
+		{ "path", required_argument, 0, 'p' },
+		{ "mode", required_argument, 0, 'm' },
+		{ "kind", required_argument, 0, 'k' },
+		{ "verbose", no_argument, 0, 'v' },
+		{ "help", no_argument, 0, 'h' },
+		{ 0, 0, 0, 0 }
+	};
+	int c;
+
+	while ((c = getopt_long(argc, argv, "+f:m:k:p:vh", long_options, NULL)) != -1) {
+		switch (c) {
+			case 'f':
+				sindex_search_format = optarg;
+				break;
+			case 'm':
+				set_search_modmask(optarg);
+				break;
+			case 'k':
+				sindex_search_kind = tolower(optarg[0]);
+				break;
+			case 'p':
+				sindex_search_path = optarg;
+				break;
+			case 'v':
+				sindex_verbose++;
+				break;
+			case 'h':
+				show_help_search(0);
+		}
+	}
+
+	if (optind < argc)
+		sindex_search_symbol = argv[optind++];
+}
+
+static int
+query_appendf(sqlite3_str *query, const char *fmt, ...)
+{
+	int status;
+	va_list args;
+
+	va_start(args, fmt);
+	sqlite3_str_vappendf(query, fmt, args);
+	va_end(args);
+
+	if ((status = sqlite3_str_errcode(query)) == SQLITE_OK)
+		return 0;
+
+	if (status == SQLITE_NOMEM)
+		message("not enough memory");
+
+	if (status == SQLITE_TOOBIG)
+		message("string too big");
+
+	return -1;
+}
+
+static inline void
+sqlite_bind_text(sqlite3_stmt *stmt, const char *field, const char *var, int len)
+{
+	if (sqlite3_bind_text(stmt, sqlite3_bind_parameter_index(stmt, field), var, len, SQLITE_STATIC) != SQLITE_OK)
+		error(1, 0, "unable to bind value for %s: %s", field, sqlite3_errmsg(sindex_db));
+}
+
+static inline void
+sqlite_bind_int64(sqlite3_stmt *stmt, const char *field, long long var)
+{
+	if (sqlite3_bind_int64(stmt, sqlite3_bind_parameter_index(stmt, field), var) != SQLITE_OK)
+		error(1, 0, "unable to bind value for %s: %s", field, sqlite3_errmsg(sindex_db));
+}
+
+static inline void
+sqlite_prepare(const char *sql, sqlite3_stmt **stmt)
+{
+	int ret;
+	do {
+		ret = sqlite3_prepare_v2(sindex_db, sql, -1, stmt, NULL);
+		if (ret != SQLITE_OK && ret != SQLITE_BUSY)
+			error(1, 0, "unable to prepare query: %s: %s", sqlite3_errmsg(sindex_db), sql);
+	} while (ret == SQLITE_BUSY);
+}
+
+static inline void
+sqlite_prepare_persistent(const char *sql, sqlite3_stmt **stmt)
+{
+	int ret;
+	do {
+		ret = sqlite3_prepare_v3(sindex_db, sql, -1, SQLITE_PREPARE_PERSISTENT, stmt, NULL);
+		if (ret != SQLITE_OK && ret != SQLITE_BUSY)
+			error(1, 0, "unable to prepare query: %s: %s", sqlite3_errmsg(sindex_db), sql);
+	} while (ret == SQLITE_BUSY);
+}
+
+static inline void
+sqlite_reset_stmt(sqlite3_stmt *stmt)
+{
+	// Contrary to the intuition of many, sqlite3_reset() does not reset the
+	// bindings on a prepared statement. Use this routine to reset all host
+	// parameters to NULL.
+	sqlite3_clear_bindings(stmt);
+	sqlite3_reset(stmt);
+}
+
+static int
+sqlite_run(sqlite3_stmt *stmt)
+{
+	int ret = sqlite3_step(stmt);
+	if (ret != SQLITE_DONE && ret != SQLITE_ROW)
+		error(1, 0, "unable to process query: %s: %s", sqlite3_errmsg(sindex_db), sqlite3_sql(stmt));
+	return ret;
+}
+
+static void
+sqlite_command(const char *sql)
+{
+	sqlite3_stmt *stmt;
+	sqlite_prepare(sql, &stmt);
+	sqlite_run(stmt);
+	sqlite3_finalize(stmt);
+}
+
+static sqlite3_int64
+get_db_version(void)
+{
+	sqlite3_stmt *stmt;
+	sqlite3_int64 dbversion;
+
+	sqlite_prepare("PRAGMA user_version", &stmt);
+	sqlite_run(stmt);
+	dbversion = sqlite3_column_int64(stmt, 0);
+	sqlite3_finalize(stmt);
+
+	return dbversion;
+}
+
+static void
+set_db_version(void)
+{
+	sqlite3_str *query = sqlite3_str_new(sindex_db);
+
+	if (query_appendf(query, "PRAGMA user_version = %d", SINDEX_DATABASE_VERSION) < 0)
+		exit(1);
+
+	char *sql = sqlite3_str_finish(query);
+	sqlite_command(sql);
+	sqlite3_free(sql);
+}
+
+static void
+open_temp_database(void)
+{
+	const char *database_schema[] = {
+		"ATTACH ':memory:' AS tempdb",
+		"CREATE TABLE tempdb.sindex ("
+			" file INTEGER NOT NULL,"
+			" line INTEGER NOT NULL,"
+			" column INTEGER NOT NULL,"
+			" symbol TEXT NOT NULL,"
+			" kind INTEGER NOT NULL,"
+			" context TEXT,"
+			" mode INTEGER NOT NULL"
+		")",
+		NULL,
+	};
+
+	for (int i = 0; database_schema[i]; i++)
+		sqlite_command(database_schema[i]);
+}
+
+static void
+open_database(const char *filename, int flags)
+{
+	int exists = !access(filename, R_OK);
+
+	if (sqlite3_open_v2(filename, &sindex_db, flags, NULL) != SQLITE_OK)
+		error(1, 0, "unable to open database: %s: %s", filename, sqlite3_errmsg(sindex_db));
+
+	sqlite_command("PRAGMA journal_mode = WAL");
+	sqlite_command("PRAGMA synchronous = OFF");
+	sqlite_command("PRAGMA secure_delete = FAST");
+	sqlite_command("PRAGMA busy_timeout = 2147483647");
+	sqlite_command("PRAGMA foreign_keys = ON");
+
+	if (exists) {
+		if (get_db_version() < SINDEX_DATABASE_VERSION)
+			error(1, 0, "%s: Database too old. Please rebuild it.", filename);
+		return;
+	}
+
+	set_db_version();
+
+	const char *database_schema[] = {
+		"CREATE TABLE file ("
+			" id INTEGER PRIMARY KEY AUTOINCREMENT,"
+			" name TEXT UNIQUE NOT NULL,"
+			" mtime INTEGER NOT NULL"
+		")",
+		"CREATE TABLE sindex ("
+			" file INTEGER NOT NULL REFERENCES file(id) ON DELETE CASCADE,"
+			" line INTEGER NOT NULL,"
+			" column INTEGER NOT NULL,"
+			" symbol TEXT NOT NULL,"
+			" kind INTEGER NOT NULL,"
+			" context TEXT,"
+			" mode INTEGER NOT NULL"
+		")",
+		"CREATE UNIQUE INDEX sindex_0 ON sindex (symbol, kind, mode, file, line, column)",
+		"CREATE INDEX sindex_1 ON sindex (file)",
+		NULL,
+	};
+
+	for (int i = 0; database_schema[i]; i++)
+		sqlite_command(database_schema[i]);
+}
+
+struct index_record {
+	const char *context;
+	int ctx_len;
+
+	const char *symbol;
+	int sym_len;
+
+	int kind;
+	unsigned int mode;
+	long long mtime;
+	sqlite3_int64 file;
+	int line;
+	int col;
+};
+
+static void
+insert_record(struct index_record *rec)
+{
+	sqlite_bind_text(insert_rec_stmt,  "@context", rec->context, rec->ctx_len);
+	sqlite_bind_text(insert_rec_stmt,  "@symbol",  rec->symbol, rec->sym_len);
+	sqlite_bind_int64(insert_rec_stmt, "@kind",    rec->kind);
+	sqlite_bind_int64(insert_rec_stmt, "@mode",    rec->mode);
+	sqlite_bind_int64(insert_rec_stmt, "@file",    rec->file);
+	sqlite_bind_int64(insert_rec_stmt, "@line",    rec->line);
+	sqlite_bind_int64(insert_rec_stmt, "@column",  rec->col);
+	sqlite_run(insert_rec_stmt);
+	sqlite_reset_stmt(insert_rec_stmt);
+}
+
+static void
+update_stream(void)
+{
+	if (sindex_streams_nr >= input_stream_nr)
+		return;
+
+	sindex_streams = realloc(sindex_streams, input_stream_nr * sizeof(struct sindex_streams));
+	if (!sindex_streams)
+		error(1, errno, "realloc");
+
+	sqlite_run(lock_stmt);
+
+	for (int i = sindex_streams_nr; i < input_stream_nr; i++) {
+		struct stat st;
+		const char *filename;
+		char fullname[PATH_MAX];
+		sqlite3_int64 cur_mtime = 0;
+
+		if (input_streams[i].fd != -1) {
+			/*
+			 * FIXME: Files in the input_streams may be duplicated.
+			 */
+			if (stat(input_streams[i].name, &st) < 0)
+				error(1, errno, "stat: %s", input_streams[i].name);
+
+			cur_mtime = st.st_mtim.tv_sec;
+
+			if (!realpath(input_streams[i].name, fullname))
+				error(1, errno, "realpath: %s", input_streams[i].name);
+
+			if (!strncmp(fullname, cwd, n_cwd) && fullname[n_cwd] == '/') {
+				filename = fullname + n_cwd + 1;
+				sindex_streams[i].id = 0;
+			} else {
+				sindex_streams[i].id = -1;
+				continue;
+			}
+		} else {
+			sindex_streams[i].id = -1;
+			continue;
+		}
+
+		if (sindex_verbose > 1)
+			message("filename: %s", filename);
+
+		sqlite_bind_text(select_file_stmt, "@name", filename, -1);
+
+		if (sqlite_run(select_file_stmt) == SQLITE_ROW) {
+			sqlite3_int64 old_mtime;
+
+			sindex_streams[i].id = sqlite3_column_int64(select_file_stmt, 0);
+			old_mtime = sqlite3_column_int64(select_file_stmt, 1);
+
+			sqlite_reset_stmt(select_file_stmt);
+
+			if (cur_mtime == old_mtime)
+				continue;
+
+			sqlite_bind_text(delete_file_stmt, "@name", filename, -1);
+			sqlite_run(delete_file_stmt);
+			sqlite_reset_stmt(delete_file_stmt);
+		}
+
+		sqlite_reset_stmt(select_file_stmt);
+
+		sqlite_bind_text(insert_file_stmt,  "@name",  filename, -1);
+		sqlite_bind_int64(insert_file_stmt, "@mtime", cur_mtime);
+		sqlite_run(insert_file_stmt);
+		sqlite_reset_stmt(insert_file_stmt);
+
+		sindex_streams[i].id = sqlite3_last_insert_rowid(sindex_db);
+	}
+
+	sqlite_run(unlock_stmt);
+
+	sindex_streams_nr = input_stream_nr;
+}
+
+static void
+r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
+{
+	static struct ident null;
+	struct ident *ctx = &null;
+	struct index_record rec;
+
+	update_stream();
+
+	if (sindex_streams[pos->stream].id == -1)
+		return;
+
+	if (!sindex_include_local_syms && sym_is_local(sym))
+		return;
+
+	if (!sym->ident) {
+		warning(*pos, "empty ident");
+		return;
+	}
+
+	if (dissect_ctx)
+		ctx = dissect_ctx->ident;
+
+	rec.context = ctx->name;
+	rec.ctx_len = ctx->len;
+	rec.symbol  = sym->ident->name;
+	rec.sym_len = sym->ident->len;
+	rec.kind    = sym->kind;
+	rec.mode    = mode;
+	rec.file    = sindex_streams[pos->stream].id;
+	rec.line    = pos->line;
+	rec.col     = pos->pos;
+
+	insert_record(&rec);
+}
+
+static void
+r_member(unsigned mode, struct position *pos, struct symbol *sym, struct symbol *mem)
+{
+	struct ident *ni, *si, *mi;
+	static struct ident null;
+	struct ident *ctx = &null;
+	struct index_record rec;
+
+	update_stream();
+
+	if (sindex_streams[pos->stream].id == -1)
+		return;
+
+	if (!sindex_include_local_syms && sym_is_local(sym))
+		return;
+
+	ni = built_in_ident("?");
+	si = sym->ident ?: ni;
+	/* mem == NULL means entire struct accessed */
+	mi = mem ? (mem->ident ?: ni) : built_in_ident("*");
+
+	if (dissect_ctx)
+		ctx = dissect_ctx->ident;
+
+	static char memname[1024];
+	snprintf(memname, sizeof(memname), "%.*s.%.*s", si->len, si->name, mi->len, mi->name);
+
+	rec.context = ctx->name;
+	rec.ctx_len = ctx->len;
+	rec.symbol  = memname;
+	rec.sym_len = si->len + mi->len + 1;
+	rec.kind    = 'm';
+	rec.mode    = mode;
+	rec.file    = sindex_streams[pos->stream].id;
+	rec.line    = pos->line;
+	rec.col     = pos->pos;
+
+	insert_record(&rec);
+}
+
+static void
+r_symdef(struct symbol *sym)
+{
+	r_symbol(U_DEF, &sym->pos, sym);
+}
+
+static void
+r_memdef(struct symbol *sym, struct symbol *mem)
+{
+	r_member(U_DEF, &mem->pos, sym, mem);
+}
+
+static void
+command_add(int argc, char **argv)
+{
+	struct reporter reporter = {
+		.r_symdef = r_symdef,
+		.r_symbol = r_symbol,
+		.r_memdef = r_memdef,
+		.r_member = r_member,
+	};
+
+	open_temp_database();
+
+	sqlite_prepare_persistent(
+		"BEGIN IMMEDIATE",
+		&lock_stmt);
+
+	sqlite_prepare_persistent(
+		"COMMIT",
+		&unlock_stmt);
+
+	sqlite_prepare_persistent(
+		"INSERT OR IGNORE INTO tempdb.sindex "
+		"(context, symbol, kind, mode, file, line, column) "
+		"VALUES (@context, @symbol, @kind, @mode, @file, @line, @column)",
+		&insert_rec_stmt);
+
+	sqlite_prepare_persistent(
+		"SELECT id, mtime FROM file WHERE name == @name",
+		&select_file_stmt);
+
+	sqlite_prepare_persistent(
+		"INSERT INTO file (name, mtime) VALUES (@name, @mtime)",
+		&insert_file_stmt);
+
+	sqlite_prepare_persistent(
+		"DELETE FROM file WHERE name == @name",
+		&delete_file_stmt);
+
+	dissect(&reporter, sindex_filelist);
+
+	sqlite_run(lock_stmt);
+	sqlite_command("INSERT OR IGNORE INTO sindex SELECT * FROM tempdb.sindex");
+	sqlite_run(unlock_stmt);
+
+	sqlite3_finalize(insert_rec_stmt);
+	sqlite3_finalize(select_file_stmt);
+	sqlite3_finalize(insert_file_stmt);
+	sqlite3_finalize(delete_file_stmt);
+	sqlite3_finalize(lock_stmt);
+	sqlite3_finalize(unlock_stmt);
+	free(sindex_streams);
+}
+
+static void
+command_rm(int argc, char **argv)
+{
+	sqlite3_stmt *stmt;
+
+	sqlite_command("BEGIN IMMEDIATE");
+	sqlite_prepare("DELETE FROM file WHERE name GLOB @file", &stmt);
+
+	if (sindex_verbose > 1)
+		message("SQL: %s", sqlite3_sql(stmt));
+
+	for (int i = 0; i < argc; i++) {
+		sqlite_bind_text(stmt, "@file",  argv[i], -1);
+		sqlite_run(stmt);
+		sqlite_reset_stmt(stmt);
+	}
+
+	sqlite3_finalize(stmt);
+	sqlite_command("COMMIT");
+}
+
+static inline void
+print_mode(char *value)
+{
+	char str[3];
+	int v = atoi(value);
+
+	if (v == U_DEF) {
+		printf("def");
+		return;
+	}
+
+#define U(m) "-rwm"[(v / m) & 3]
+	str[0] = U(U_R_AOF);
+	str[1] = U(U_R_VAL);
+	str[2] = U(U_R_PTR);
+
+	printf("%.3s", str);
+#undef U
+}
+
+static char *sindex_file_name;
+static FILE *sindex_file_fd;
+static int sindex_file_lnum;
+static char *sindex_line;
+static size_t sindex_line_buflen;
+static int sindex_line_len;
+
+static void
+print_file_line(const char *name, int lnum)
+{
+	/*
+	 * All files are sorted by name and line number. So, we can reopen
+	 * the file and read it line by line.
+	 */
+	if (!sindex_file_name || strcmp(sindex_file_name, name)) {
+		if (sindex_file_fd) {
+			fclose(sindex_file_fd);
+			free(sindex_file_name);
+		}
+
+		sindex_file_name = strdup(name);
+
+		if (!sindex_file_name)
+			error(1, errno, "strdup");
+
+		sindex_file_fd = fopen(name, "r");
+
+		if (!sindex_file_fd)
+			error(1, errno, "fopen: %s", name);
+
+		sindex_file_lnum = 0;
+	}
+
+	do {
+		if (sindex_file_lnum == lnum) {
+			if (sindex_line[sindex_line_len-1] == '\n')
+				sindex_line_len--;
+			printf("%.*s", sindex_line_len, sindex_line);
+			break;
+		}
+		sindex_file_lnum++;
+		errno = 0;
+	} while((sindex_line_len = getline(&sindex_line, &sindex_line_buflen, sindex_file_fd)) != -1);
+
+	if (errno && errno != EOF)
+		error(1, errno, "getline");
+}
+
+static int
+search_query_callback(void *data, int argc, char **argv, char **colname)
+{
+	char *fmt = (char *) sindex_search_format;
+	char buf[32];
+	int quote = 0;
+	int n = 0;
+
+	while (*fmt != '\0') {
+		char c = *fmt;
+
+		if (quote) {
+			quote = 0;
+			switch (c) {
+				case 't': c = '\t'; break;
+				case 'r': c = '\r'; break;
+				case 'n': c = '\n'; break;
+			}
+		} else if (c == '%') {
+			char *pos = ++fmt;
+
+			c = *fmt;
+
+			if (c == '\0')
+				error(1, 0, "unexpected end of format string");
+
+			int colnum = 0;
+
+			switch (c) {
+				case 'f': colnum = 0; goto print_string;
+				case 'l': colnum = 1; goto print_string;
+				case 'c': colnum = 2; goto print_string;
+				case 'C': colnum = 3; goto print_string;
+				case 'n': colnum = 4; goto print_string;
+				case 'm':
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					print_mode(argv[5]);
+					fmt++;
+					break;
+				case 'k':
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					printf("%c", atoi(argv[6]));
+					fmt++;
+					break;
+				case 's':
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					print_file_line(argv[0], atoi(argv[1]));
+					fmt++;
+					break;
+				case -1:
+print_string:
+					if (n) {
+						printf("%.*s", n, buf);
+						n = 0;
+					}
+					printf("%s", argv[colnum]);
+					fmt++;
+					break;
+			}
+
+			if (pos == fmt)
+				error(1, 0, "invalid format specification: %%%c", c);
+
+			continue;
+		} else if (c == '\\') {
+			quote = 1;
+			fmt++;
+			continue;
+		}
+
+		if (n == sizeof(buf)) {
+			printf("%.*s", n, buf);
+			n = 0;
+		}
+
+		buf[n++] = c;
+		fmt++;
+	}
+
+	if (n)
+		printf("%.*s", n, buf);
+	printf("\n");
+
+	return 0;
+}
+
+static void
+command_search(int argc, char **argv)
+{
+	char *sql;
+	char *dberr = NULL;
+	sqlite3_str *query = sqlite3_str_new(sindex_db);
+
+	if (query_appendf(query,
+	                  "SELECT"
+	                  " file.name,"
+	                  " sindex.line,"
+	                  " sindex.column,"
+	                  " sindex.context,"
+	                  " sindex.symbol,"
+	                  " sindex.mode,"
+	                  " sindex.kind "
+	                  "FROM sindex, file "
+	                  "WHERE sindex.file == file.id") < 0)
+		goto fail;
+
+	if (sindex_search_kind) {
+		if (query_appendf(query, " AND sindex.kind == %d", sindex_search_kind) < 0)
+			goto fail;
+	}
+
+	if (sindex_search_symbol) {
+		if (query_appendf(query, " AND ") < 0)
+			goto fail;
+
+		int ret;
+
+		if (strpbrk(sindex_search_symbol, "*?[]"))
+			ret = query_appendf(query, "sindex.symbol GLOB %Q", sindex_search_symbol);
+		else
+			ret = query_appendf(query, "sindex.symbol == %Q", sindex_search_symbol);
+
+		if (ret < 0)
+			goto fail;
+	}
+
+	if (sindex_search_modmask_defined) {
+		if (!sindex_search_modmask) {
+			if (query_appendf(query, " AND sindex.mode == %d", sindex_search_modmask) < 0)
+				goto fail;
+		} else if (query_appendf(query, " AND (sindex.mode & %d) != 0", sindex_search_modmask) < 0)
+			goto fail;
+	}
+
+	if (sindex_search_path) {
+		if (query_appendf(query, " AND file.name GLOB %Q", sindex_search_path) < 0)
+			goto fail;
+	}
+
+	if (query_appendf(query, " ORDER BY file.name, sindex.line, sindex.column ASC", sindex_search_path) < 0)
+		goto fail;
+
+	sql = sqlite3_str_value(query);
+
+	if (sindex_verbose > 1)
+		message("SQL: %s", sql);
+
+	sqlite3_exec(sindex_db, sql, search_query_callback, 0, &dberr);
+	if (dberr)
+		error(1, 0, "sql query failed: %s", dberr);
+fail:
+	sql = sqlite3_str_finish(query);
+	sqlite3_free(sql);
+
+	if (sindex_file_fd) {
+		fclose(sindex_file_fd);
+		free(sindex_file_name);
+	}
+	free(sindex_line);
+}
+
+
+int
+main(int argc, char **argv)
+{
+	struct command commands[] = {
+		{
+			.name          = "add",
+			.dbflags       = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,
+			.parse_cmdline = parse_cmdline_add,
+			.handler       = command_add
+		},
+		{
+			.name          = "rm",
+			.dbflags       = SQLITE_OPEN_READWRITE,
+			.parse_cmdline = parse_cmdline_rm,
+			.handler       = command_rm
+		},
+		{
+			.name          = "search",
+			.dbflags       = SQLITE_OPEN_READONLY,
+			.parse_cmdline = parse_cmdline_search,
+			.handler       = command_search
+		},
+		{ .name = NULL },
+	};
+	struct command *cmd;
+
+	error_print_progname = sindex_error_print_progname;
+
+	if (!realpath(".", cwd))
+		error(1, errno, "unable to get current directory");
+	n_cwd = strlen(cwd);
+
+	parse_cmdline(argc, argv);
+
+	for (cmd = commands; cmd->name && strcmp(argv[optind], cmd->name); cmd++);
+	if (!cmd->name)
+		error(1, 0, "unknown command: %s", argv[optind]);
+	optind++;
+
+	sindex_command = cmd->name;
+
+	if (cmd->parse_cmdline)
+		cmd->parse_cmdline(argc, argv);
+
+	open_database(sindex_dbfile, cmd->dbflags);
+	cmd->handler(argc - optind, argv + optind);
+
+	sqlite3_close(sindex_db);
+
+	return 0;
+}
-- 
2.24.1

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Add symantic index utility
Date: Mon, 09 Mar 2020 22:37:01 +0000
Message-ID: <20200309223701.dbnej7esb4qp56bm () ltop ! local>
--------------------
On Mon, Mar 09, 2020 at 04:25:09PM +0100, Alexey Gladkov wrote:
> sindex is the simple to use cscope-like tool based on sparse/dissect.
> Unlike cscope it runs after pre-processor and thus it can't index the
> code filtered out by ifdef's, but otoh it understands how the symbol
> is used and it can track the usage of struct members.

Hi,

This looks pretty good.
I just have a few non-essential remarks I've added here below.

> To create an index for your linux kernel configuration:
> 
> $ make C=2 CHECK="sindex add --"
> 
> Now, to find where a definition of the pid field from the task_struct
> structure:
> 
> $ sindex search -m def task_struct.pid
> (def) include/linux/sched.h 793 11   pid_t    pid;
> 
> default output format:
> 
> SOURCE-FILE \t LINE-NUMBER \t COLUMN \t IN FUNCTION NAME \t CODE LINE
> 
> To find where this field changes:
> 
> $ sindex search -m w task_struct.pid
> (-w-) fs/exec.c 1154 6 de_thread   tsk->pid = leader->pid;
> (-w-) kernel/fork.c 2155 3 copy_process  p->pid = pid_nr(pid);
> 
> To get only filenames and line number you can change output format:
> 
> $ sindex search -f '%f:%l' -m w task_struct.pid
> fs/exec.c:1154
> kernel/fork.c:2155

It would be great to add this and the equivalent of the show_usage()
function into a manpage (I don't mind to do the formatting, just the
content is fine).

It would also be great if some doc could be added to explain the
meaning of the kinds (s, f, v, m) and the 'access fields' (def),
'(-r-)', ... but yes, that's really something for dissect itself.
 
> diff --git a/sindex.c b/sindex.c
> new file mode 100644
> index 00000000..8478fe33
> --- /dev/null
> +++ b/sindex.c
> @@ -0,0 +1,1109 @@
> +/*
> + * sindex - semantic indexer for C.
> + *
> + * Copyright (C) 2020  Alexey Gladkov
> + */
> +
> +#define _GNU_SOURCE
> +#include <sys/types.h>
> +#include <sys/stat.h>
> +
> +#include <unistd.h>
> +#include <limits.h>
> +#include <stdlib.h>
> +#include <string.h>
> +#include <fcntl.h>
> +#include <getopt.h>
> +#include <ctype.h>
> +#include <errno.h>
> +#include <error.h>

<error.h> is glibc specific. This makes the build fail on
non-glibc platforms. This dependencies should be removed
or some tests should be added to the Makefile to not build
this program if glibs is not present.

> +
> +static void
> +show_usage(void)

I would prefer: static void show_usage(...
but I don't mind much.

> +	    "These are common %1$s commands used in various situations:\n"
> +	    "  add      Generate or updates symantic index file for c-source code;\n"

I think you mean "semantic index" (same for the title of the patch).

> +static void
> +set_search_modmask(const char *v)
> +{
> +	size_t n = strlen(v);
> +
> +	if (n != 1 && n != 3)
> +		error(1, 0, "the length of mode value must be 1 or 3: %s", v);
> +
> +	sindex_search_modmask_defined = 1;
> +	sindex_search_modmask = 0;
> +
> +	if (n == 1) {
> +		switch (v[0]) {
> +			case 'r': v = "rrr"; break;
> +			case 'w': v = "ww-"; break;
> +			case 'm': v = "mmm"; break;
> +			case '-': v = "---"; break;
> +			default: error(1, 0, "unknown modificator: %s", v);
> +		}
> +	} else if (!strcmp(v, "def")) {
> +		sindex_search_modmask = U_DEF;
> +		return;
> +	}
> +
> +	int modes[] = {
> +		U_R_AOF, U_W_AOF, U_R_AOF | U_W_AOF,
> +		U_R_VAL, U_W_VAL, U_R_VAL | U_W_VAL,
> +		U_R_PTR, U_W_PTR, U_R_PTR | U_W_PTR,
> +	};

Please, move this table at the top of the function, wth static const.

> +static void
> +set_db_version(void)
> +{
> +	sqlite3_str *query = sqlite3_str_new(sindex_db);
> +
> +	if (query_appendf(query, "PRAGMA user_version = %d", SINDEX_DATABASE_VERSION) < 0)
> +		exit(1);
> +
> +	char *sql = sqlite3_str_finish(query);
> +	sqlite_command(sql);
> +	sqlite3_free(sql);
> +}
> +
> +static void
> +open_temp_database(void)
> +{
> +	const char *database_schema[] = {

+static
+const ?

> +static void
> +open_database(const char *filename, int flags)
> +{
> +	int exists = !access(filename, R_OK);
> +
> +	if (sqlite3_open_v2(filename, &sindex_db, flags, NULL) != SQLITE_OK)
> +		error(1, 0, "unable to open database: %s: %s", filename, sqlite3_errmsg(sindex_db));
> +
> +	sqlite_command("PRAGMA journal_mode = WAL");
> +	sqlite_command("PRAGMA synchronous = OFF");
> +	sqlite_command("PRAGMA secure_delete = FAST");
> +	sqlite_command("PRAGMA busy_timeout = 2147483647");
> +	sqlite_command("PRAGMA foreign_keys = ON");
> +
> +	if (exists) {
> +		if (get_db_version() < SINDEX_DATABASE_VERSION)
> +			error(1, 0, "%s: Database too old. Please rebuild it.", filename);
> +		return;
> +	}
> +
> +	set_db_version();
> +
> +	const char *database_schema[] = {

idem.

> +static void
> +r_member(unsigned mode, struct position *pos, struct symbol *sym, struct symbol *mem)
> +{
> +	struct ident *ni, *si, *mi;
> +	static struct ident null;
> +	struct ident *ctx = &null;
> +	struct index_record rec;
> +
> +	update_stream();
> +
> +	if (sindex_streams[pos->stream].id == -1)
> +		return;
> +
> +	if (!sindex_include_local_syms && sym_is_local(sym))
> +		return;
> +
> +	ni = built_in_ident("?");
> +	si = sym->ident ?: ni;
> +	/* mem == NULL means entire struct accessed */
> +	mi = mem ? (mem->ident ?: ni) : built_in_ident("*");
> +
> +	if (dissect_ctx)
> +		ctx = dissect_ctx->ident;
> +
> +	static char memname[1024];

please, move the declaration on top.

> +static void
> +command_search(int argc, char **argv)
> +{

...

> +	if (sindex_search_symbol) {
> +		if (query_appendf(query, " AND ") < 0)
> +			goto fail;
> +
> +		int ret;
> +

same here.

> +int
> +main(int argc, char **argv)
> +{
> +	struct command commands[] = {

static?


Best regards,
-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Add symantic index utility
Date: Tue, 10 Mar 2020 17:12:02 +0000
Message-ID: <20200310171202.y5rhsydmmbewoarm () ltop ! local>
--------------------
On Tue, Mar 10, 2020 at 04:07:14PM +0100, Oleg Nesterov wrote:
> 
> Annoyingly, this triggers a lot of sparse_error's in pre-process.c:collect_arg().
> And just in case, of course this is not specific to dissect/sindex, ./sparse or
> anything else will equally complain.
> 
> For example,
> 
>   1011  static inline bool page_expected_state(struct page *page,
>   1012                                          unsigned long check_flags)
>   1013  {
>   1014          if (unlikely(atomic_read(&page->_mapcount) != -1))
>   1015                  return false;
>   1016
>   1017          if (unlikely((unsigned long)page->mapping |
>   1018                          page_ref_count(page) |
>   1019  #ifdef CONFIG_MEMCG
>   1020                          (unsigned long)page->mem_cgroup |
>   1021  #endif
>   1022                          (page->flags & check_flags)))
>   1023                  return false;
>   1024
>   1025          return true;
>   1026  }
> 
> leads to
> 
> 	mm/page_alloc.c:1019:1: error: directive in macro's argument list
> 	mm/page_alloc.c:1021:1: error: directive in macro's argument list
> 
> and it is not immediately clear why. Yes, because "unlikely" is a macro.
> 
> Can't we simply remove this sparse_error() ? "#if" inside the macro's args
> is widely used in kernel, gcc doesn't complain, afaics pre-process.c handles
> this case correctly.

I'm quite reluctant to simply suppress it.
My (contradictory) point of view is that it is because it's not
immediately clear there is a problem that the warning is needed
but, OTOH, people and the Standard, want to use macros transparently
so a macro wrapping a function call should behave just like directly
calling the function. And yes both Sparse and GCC seem to be able
to handle this, so it's maybe only a restriction for more primtive
preprocessors. I dunno.

Some arguments/justifications for the arning can be found at:
	https://www.spinics.net/lists/kernel/msg1636994.html

Anyway, only a warning should be issued (I'll send a patch for this).
I also wouldn't mind to add a new warning flag to suppress it,
something like -Wno-directive-within-macro.

-- Luc
================================================================================

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: Re: [PATCH] Add symantic index utility
Date: Wed, 11 Mar 2020 09:07:45 +0000
Message-ID: <20200311090745.GD11561 () kadam>
--------------------
On Tue, Mar 10, 2020 at 04:07:14PM +0100, Oleg Nesterov wrote:
> Annoyingly, this triggers a lot of sparse_error's in pre-process.c:collect_arg().
> And just in case, of course this is not specific to dissect/sindex, ./sparse or
> anything else will equally complain.
> 
> For example,
> 
>   1011  static inline bool page_expected_state(struct page *page,
>   1012                                          unsigned long check_flags)
>   1013  {
>   1014          if (unlikely(atomic_read(&page->_mapcount) != -1))
>   1015                  return false;
>   1016
>   1017          if (unlikely((unsigned long)page->mapping |
>   1018                          page_ref_count(page) |
>   1019  #ifdef CONFIG_MEMCG
>   1020                          (unsigned long)page->mem_cgroup |
>   1021  #endif
>   1022                          (page->flags & check_flags)))
>   1023                  return false;
>   1024
>   1025          return true;
>   1026  }
> 
> leads to
> 
> 	mm/page_alloc.c:1019:1: error: directive in macro's argument list
> 	mm/page_alloc.c:1021:1: error: directive in macro's argument list

This does:

	/* Shut up warnings after an error */
	has_error |= ERROR_CURR_PHASE;

so we probably end up not seeing some warnings.

> 
> and it is not immediately clear why. Yes, because "unlikely" is a macro.
> 
> Can't we simply remove this sparse_error() ? "#if" inside the macro's args
> is widely used in kernel, gcc doesn't complain, afaics pre-process.c handles
> this case correctly.

s/correctly/the same as GCC/.  The behavior is undefined in c99.

regards,
dan carpenter

================================================================================

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] Add symantic index utility
Date: Wed, 11 Mar 2020 12:04:27 +0000
Message-ID: <20200311120427.GB19327 () redhat ! com>
--------------------
On 03/10, Luc Van Oostenryck wrote:
>
> Anyway, only a warning should be issued (I'll send a patch for this).
> I also wouldn't mind to add a new warning flag to suppress it,
> something like -Wno-directive-within-macro.

OK, agreed. something like below?

Oleg.

diff --git a/lib.c b/lib.c
index f15e4d99..264a890e 100644
--- a/lib.c
+++ b/lib.c
@@ -264,6 +264,7 @@ int Wdecl = 1;
 int Wdeclarationafterstatement = -1;
 int Wdefault_bitfield_sign = 0;
 int Wdesignated_init = 1;
+int Wdirective_within_macro = 1;
 int Wdo_while = 0;
 int Wimplicit_int = 1;
 int Winit_cstring = 0;
@@ -740,6 +741,7 @@ static const struct flag warnings[] = {
 	{ "declaration-after-statement", &Wdeclarationafterstatement },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
 	{ "designated-init", &Wdesignated_init },
+	{ "directive-within-macro", &Wdirective_within_macro },
 	{ "do-while", &Wdo_while },
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "external-function-has-definition", &Wexternal_function_has_definition },
diff --git a/lib.h b/lib.h
index 72651cef..49db0117 100644
--- a/lib.h
+++ b/lib.h
@@ -153,6 +153,7 @@ extern int Wdecl;
 extern int Wdeclarationafterstatement;
 extern int Wdefault_bitfield_sign;
 extern int Wdesignated_init;
+extern int Wdirective_within_macro;
 extern int Wdo_while;
 extern int Wenum_mismatch;
 extern int Wexternal_function_has_definition;
diff --git a/pre-process.c b/pre-process.c
index 433d1bf8..e79a447a 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -271,8 +271,9 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position
 	while (!eof_token(next = scan_next(p))) {
 		if (next->pos.newline && match_op(next, '#')) {
 			if (!next->pos.noexpand) {
-				sparse_error(next->pos,
-					     "directive in macro's argument list");
+				if (Wdirective_within_macro)
+					warning(next->pos,
+						"directive in macro's argument list");
 				preprocessor_line(stream, p);
 				__free_token(next);	/* Free the '#' token */
 				continue;

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Add symantic index utility
Date: Wed, 11 Mar 2020 17:06:25 +0000
Message-ID: <20200311170625.a53orumjtoffx75t () ltop ! local>
--------------------
On Wed, Mar 11, 2020 at 12:07:45PM +0300, Dan Carpenter wrote:
> On Tue, Mar 10, 2020 at 04:07:14PM +0100, Oleg Nesterov wrote:
> 
> This does:
> 
> 	/* Shut up warnings after an error */
> 	has_error |= ERROR_CURR_PHASE;
> 
> so we probably end up not seeing some warnings.

Yes, this is annoying, OTOH syntax errors used to cause a lot
of silly errors @ evaluation and type errors caused even more
errors or crashes at linearization or later.
Ideally we should have the equivalent of this flag but more
fine grained.

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Add symantic index utility
Date: Wed, 11 Mar 2020 17:11:57 +0000
Message-ID: <20200311171157.fhpuwphwfn3ek7wm () ltop ! local>
--------------------
On Wed, Mar 11, 2020 at 12:33:52PM +0100, Oleg Nesterov wrote:
> and just in case... there are other cases when GCC and sparse differ,
> 
> 	if, within a macro invocation, that macro is redefined, then the new
> 	definition takes effect in time for argument pre-expansion, but the
> 	original definition is still used for argument replacement. Here is a
> 	pathological example:
> 
> 		#define f(x) x x
> 		f (1
> 		#undef f
> 		#define f 2
> 		f)
> 
> 	which expands to
> 
> 		1 2 1 2
> 
> ./sparse -E outputs
> 
> 	/tmp/M.c:3:1: error: directive in macro's argument list
> 	/tmp/M.c:4:1: error: directive in macro's argument list
> 	2

Not much, indeed. But I see that sparse & gcc differ also in the
non-erroneous case:
	#define f(x) x x
	f(1
	2)

(Sparse adds newlines after the 1s) but it seems easy to solve.

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] OP_CALL should use the full function type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] OP_CALL should use the full function type
Date: Sun, 25 Oct 2020 12:31:47 +0000
Message-ID: <20201025123147.19301-1-luc.vanoostenryck () gmail ! com>
--------------------
OP_CALL keep a list with the type of the function itself
and of each of its arguments.

However, the function type added to the list is not the complete type
but its base type. So, we can't use the function's modifiers or contexts.

Fix this by storing the complete function type.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/linearize.c b/linearize.c
index 1081bda86425..2432801135f3 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1520,8 +1520,6 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 	}
 
 	ctype = &fntype->ctype;
-	if (fntype->type == SYM_NODE)
-		fntype = fntype->ctype.base_type;
 
 	add_symbol(&insn->fntypes, fntype);
 	FOR_EACH_PTR(expr->args, arg) {
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH] add an option to suppress warning no 'newline at EOF' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] add an option to suppress warning no 'newline at EOF'
Date: Sun, 24 May 2020 14:00:57 +0000
Message-ID: <20200524140057.5927-1-luc.vanoostenryck () gmail ! com>
--------------------
Some platforms have some of their systems header files which
are missing the ending newline. Sparse will then warn about
the missng newline, again and again, and more important warnings
can easily be lost in the noise.

So, add an option flag '-W[no-]newline-eof' to conditionalize
this warning.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c      | 2 ++
 lib.h      | 1 +
 sparse.1   | 7 +++++++
 tokenize.c | 2 +-
 4 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/lib.c b/lib.c
index 9ee8d3cf6b21..7aca9cd0ac40 100644
--- a/lib.c
+++ b/lib.c
@@ -272,6 +272,7 @@ int Wenum_mismatch = 1;
 int Wexternal_function_has_definition = 1;
 int Wsparse_error = 0;
 int Wmemcpy_max_count = 1;
+int Wnewline_eof = 1;
 int Wnon_pointer_null = 1;
 int Wold_initializer = 1;
 int Wold_style_definition = 1;
@@ -761,6 +762,7 @@ static const struct flag warnings[] = {
 	{ "int-to-pointer-cast", &Wint_to_pointer_cast },
 	{ "memcpy-max-count", &Wmemcpy_max_count },
 	{ "non-pointer-null", &Wnon_pointer_null },
+	{ "newline-eof", &Wnewline_eof },
 	{ "old-initializer", &Wold_initializer },
 	{ "old-style-definition", &Wold_style_definition },
 	{ "one-bit-signed-bitfield", &Wone_bit_signed_bitfield },
diff --git a/lib.h b/lib.h
index 5e6db111170a..e767840c1038 100644
--- a/lib.h
+++ b/lib.h
@@ -161,6 +161,7 @@ extern int Wimplicit_int;
 extern int Winit_cstring;
 extern int Wint_to_pointer_cast;
 extern int Wmemcpy_max_count;
+extern int Wnewline_eof;
 extern int Wnon_pointer_null;
 extern int Wold_initializer;
 extern int Wold_style_definition;
diff --git a/sparse.1 b/sparse.1
index 50e928392573..63b408e3aa5a 100644
--- a/sparse.1
+++ b/sparse.1
@@ -280,6 +280,13 @@ The limit can be changed with \fB\-fmemcpy\-max\-count=COUNT\fR,
 the default being \fB100000\fR.
 .
 .TP
+.B \-Wnewline\-eof
+Warn if the input file doesn't end with a newline.
+
+Sparse issues these warnings by default.  To turn them off, use
+\fB\-Wno\-newline\-eof\fR.
+.
+.TP
 .B \-Wnon\-pointer\-null
 Warn about the use of 0 as a NULL pointer.
 
diff --git a/tokenize.c b/tokenize.c
index d8bbef498a46..d3371e1e7cb1 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -411,7 +411,7 @@ got_eof:
 		c = '\\';
 		goto out;
 	}
-	if (stream->pos)
+	if (stream->pos & Wnewline_eof)
 		warning(stream_pos(stream), "no newline at end of file");
 	else if (spliced)
 		warning(stream_pos(stream), "backslash-newline at end of file");
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH] add support for GCC's __auto_type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] add support for GCC's __auto_type
Date: Tue, 24 Mar 2020 09:57:11 +0000
Message-ID: <20200324095711.84902-1-luc.vanoostenryck () gmail ! com>
--------------------
Despite the similarity with typeof, the approach taken here
is relatively different. A specific symbol type (SYM_TYPEOF)
is not used, instead a new flag is added to decl_state, another
one in the declared symbol and a new internal type is used:
'autotype_ctype'. It's this new internal type that will be
resolved to the definitive type at evalution time.

It seems to be working pretty well, maybe because it
hasn't been tested well enough.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c                  | 38 +++++++++++++++++++++++++++
 symbol.c                 | 19 ++++++++++++++
 symbol.h                 |  2 ++
 validation/autotype-ko.c | 45 ++++++++++++++++++++++++++++++++
 validation/autotype.c    | 55 ++++++++++++++++++++++++++++++++++++++++
 5 files changed, 159 insertions(+)
 create mode 100644 validation/autotype-ko.c
 create mode 100644 validation/autotype.c

diff --git a/parse.c b/parse.c
index 0e6f66a86037..a29c67c8cf41 100644
--- a/parse.c
+++ b/parse.c
@@ -60,6 +60,7 @@ static declarator_t
 	thread_specifier, const_qualifier, volatile_qualifier;
 static declarator_t restrict_qualifier;
 static declarator_t atomic_qualifier;
+static declarator_t autotype_specifier;
 
 static struct token *parse_if_statement(struct token *token, struct statement *stmt);
 static struct token *parse_return_statement(struct token *token, struct statement *stmt);
@@ -213,6 +214,13 @@ static struct symbol_op typeof_op = {
 	.set = Set_S|Set_T,
 };
 
+static struct symbol_op autotype_op = {
+	.type = KW_SPECIFIER,
+	.declarator = autotype_specifier,
+	.test = Set_Any,
+	.set = Set_S|Set_T,
+};
+
 static struct symbol_op attribute_op = {
 	.type = KW_ATTRIBUTE,
 	.declarator = attribute_specifier,
@@ -505,6 +513,7 @@ static struct init_keyword {
 	{ "typeof", 	NS_TYPEDEF, .op = &typeof_op },
 	{ "__typeof", 	NS_TYPEDEF, .op = &typeof_op },
 	{ "__typeof__",	NS_TYPEDEF, .op = &typeof_op },
+	{ "__auto_type",NS_TYPEDEF, .op = &autotype_op },
 
 	{ "__attribute",   NS_TYPEDEF, .op = &attribute_op },
 	{ "__attribute__", NS_TYPEDEF, .op = &attribute_op },
@@ -1078,6 +1087,13 @@ static struct token *typeof_specifier(struct token *token, struct decl_state *ct
 	return expect(token, ')', "after typeof");
 }
 
+static struct token *autotype_specifier(struct token *token, struct decl_state *ctx)
+{
+	ctx->ctype.base_type = &autotype_ctype;
+	ctx->autotype = 1;
+	return token;
+}
+
 static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct decl_state *ctx)
 {
 	struct expression *expr = NULL;
@@ -2985,6 +3001,11 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			}
 		}
 	} else if (base_type && base_type->type == SYM_FN) {
+		if (base_type->ctype.base_type == &autotype_ctype) {
+			sparse_error(decl->pos, "'%s()' has __auto_type return type",
+				show_ident(decl->ident));
+			base_type->ctype.base_type = &int_ctype;
+		}
 		if (base_type->ctype.base_type == &incomplete_ctype) {
 			warning(decl->pos, "'%s()' has implicit return type",
 				show_ident(decl->ident));
@@ -3037,6 +3058,23 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			}
 		}
 
+		if (ctx.autotype) {
+			const char *msg = NULL;
+			if (decl->ctype.base_type != &autotype_ctype)
+				msg = "on non-identifier";
+			else if (match_op(token, ','))
+				msg = "on declaration list";
+			else if (!decl->initializer)
+				msg = "without initializer";
+			else if (decl->initializer->type == EXPR_SYMBOL &&
+				 decl->initializer->symbol == decl)
+				msg = "on self-init var";
+			if (msg) {
+				sparse_error(decl->pos, "__auto_type %s", msg);
+				decl->ctype.base_type = &bad_ctype;
+			}
+		}
+
 		if (!match_op(token, ','))
 			break;
 
diff --git a/symbol.c b/symbol.c
index ab6e9841696f..c2e6f0b426b3 100644
--- a/symbol.c
+++ b/symbol.c
@@ -192,6 +192,10 @@ static struct symbol * examine_struct_union_type(struct symbol *sym, int advance
 
 	fn = advance ? lay_out_struct : lay_out_union;
 	FOR_EACH_PTR(sym->symbol_list, member) {
+		if (member->ctype.base_type == &autotype_ctype) {
+			sparse_error(member->pos, "member '%s' has __auto_type", show_ident(member->ident));
+			member->ctype.base_type = &incomplete_ctype;
+		}
 		fn(member, &info);
 	} END_FOR_EACH_PTR(member);
 
@@ -210,6 +214,19 @@ static struct symbol *examine_base_type(struct symbol *sym)
 {
 	struct symbol *base_type;
 
+	if (sym->ctype.base_type == &autotype_ctype) {
+		struct symbol *type = evaluate_expression(sym->initializer);
+		if (!type)
+			type = &bad_ctype;
+		if (is_bitfield_type(type)) {
+			warning(sym->pos, "__auto_type on bitfield");
+			if (type->type == SYM_NODE)
+				type = type->ctype.base_type;
+			type = type->ctype.base_type;
+		}
+		sym->ctype.base_type = type;
+	}
+
 	/* Check the base type */
 	base_type = examine_symbol_type(sym->ctype.base_type);
 	if (!base_type || base_type->type == SYM_PTR)
@@ -734,6 +751,7 @@ struct symbol	bool_ctype, void_ctype, type_ctype,
 		string_ctype, ptr_ctype, lazy_ptr_ctype,
 		incomplete_ctype, label_ctype, bad_ctype,
 		null_ctype;
+struct symbol	autotype_ctype;
 struct symbol	int_ptr_ctype, uint_ptr_ctype;
 struct symbol	long_ptr_ctype, ulong_ptr_ctype;
 struct symbol	llong_ptr_ctype, ullong_ptr_ctype;
@@ -792,6 +810,7 @@ static const struct ctype_declare {
 	{ &void_ctype,         T_BASETYPE },
 	{ &type_ctype,         T_BASETYPE },
 	{ &incomplete_ctype,   T_BASETYPE },
+	{ &autotype_ctype,     T_BASETYPE },
 	{ &bad_ctype,          T_BASETYPE },
 
 	{ &char_ctype,         T__INT(-2, char) },
diff --git a/symbol.h b/symbol.h
index 270ae098cacf..c86dfb335e29 100644
--- a/symbol.h
+++ b/symbol.h
@@ -110,6 +110,7 @@ struct decl_state {
 	unsigned long f_modifiers;		// function attributes
 	unsigned char prefer_abstract, is_inline, storage_class, is_tls;
 	unsigned char is_ext_visible;
+	unsigned char autotype;
 };
 
 struct pseudo;
@@ -281,6 +282,7 @@ extern struct symbol	bool_ctype, void_ctype, type_ctype,
 			string_ctype, ptr_ctype, lazy_ptr_ctype,
 			incomplete_ctype, label_ctype, bad_ctype,
 			null_ctype;
+extern struct symbol	autotype_ctype;
 extern struct symbol	int_ptr_ctype, uint_ptr_ctype;
 extern struct symbol	long_ptr_ctype, ulong_ptr_ctype;
 extern struct symbol	llong_ptr_ctype, ullong_ptr_ctype;
diff --git a/validation/autotype-ko.c b/validation/autotype-ko.c
new file mode 100644
index 000000000000..5b6cd708ade7
--- /dev/null
+++ b/validation/autotype-ko.c
@@ -0,0 +1,45 @@
+__auto_type u;				// KO: no initializer
+__auto_type r[2] = { 0, 1 };		// KO: not a plain identifier
+__auto_type foo(void) { }		// KO: not a plain identifier
+__auto_type v = 0, w = 1;		// KO: in list
+struct { __auto_type x; } s;		// KO: not valid for struct/union
+__auto_type self = self;		// KO: self-declared
+__auto_type undc = this;		// KO: undeclared
+
+int i = 1;
+double f = 1.0;
+__auto_type i = 2;			// KO: redecl, same type
+__auto_type f = 2.0f;			// KO: redecl, diff type
+
+
+static int foo(int a, const int *ptr)
+{
+	__auto_type i = a;
+	__auto_type c = *ptr;
+
+	c += 1;
+	return i;
+}
+
+/*
+ * check-name: autotype-ko
+ * check-command: sparse -Wno-decl $file
+ *
+ * check-error-start
+autotype-ko.c:1:13: error: __auto_type without initializer
+autotype-ko.c:2:13: error: __auto_type on non-identifier
+autotype-ko.c:3:13: error: 'foo()' has __auto_type return type
+autotype-ko.c:4:13: error: __auto_type on declaration list
+autotype-ko.c:6:13: error: __auto_type on self-init var
+autotype-ko.c:2:20: error: invalid initializer
+autotype-ko.c:5:22: error: member 'x' has __auto_type
+autotype-ko.c:7:20: error: undefined identifier 'this'
+autotype-ko.c:11:13: error: symbol 'i' has multiple initializers (originally initialized at autotype-ko.c:9)
+autotype-ko.c:12:13: error: symbol 'f' has multiple initializers (originally initialized at autotype-ko.c:10)
+autotype-ko.c:12:13: error: symbol 'f' redeclared with different type (different type sizes):
+autotype-ko.c:12:13:    float [addressable] [toplevel] f
+autotype-ko.c:10:8: note: previously declared as:
+autotype-ko.c:10:8:    double [addressable] [toplevel] f
+autotype-ko.c:20:9: error: assignment to const expression
+ * check-error-end
+ */
diff --git a/validation/autotype.c b/validation/autotype.c
new file mode 100644
index 000000000000..98683c93d2e8
--- /dev/null
+++ b/validation/autotype.c
@@ -0,0 +1,55 @@
+#ifdef __CHECKER__
+#define	is_type(X, T)	_Static_assert([typeof(X)] == [T], "")
+#else
+#define	is_type(X, T)	_Static_assert(1, "")
+#endif
+
+struct s {
+	int x;
+	int bf:3;
+};
+
+extern char ch;
+extern const int ci;
+
+__auto_type i = 0;		is_type(i, int);
+__auto_type m = 1UL;		is_type(m, unsigned long);
+__auto_type l = (int)0L;	is_type(l, int);
+__auto_type c = (char)'\n';	is_type(c, char);
+__auto_type p = &i;		is_type(p, int *);
+__auto_type f = 0.0;		is_type(f, double);
+__auto_type s = (struct s){0};	is_type(s, struct s);
+__auto_type pci = &ci;		is_type(pci, const int *);
+
+// ~~: not valid for bitfield
+__auto_type b = (struct s){0}.bf; is_type(b, int);
+
+static __auto_type si = 0;	is_type(si, int);
+const  __auto_type ci = 0;	is_type(ci, const int);
+__auto_type ch = (char) '\n';	is_type(ch, char);
+
+static int foo(int a)
+{
+	__auto_type i = a;	is_type(i, int);
+	__auto_type c = ch;	is_type(c, char);
+	__auto_type ct = ci;	is_type(&ct, const int *);
+
+	return ct += i + c;
+}
+
+
+
+#define __as __attribute__((address_space(42)))
+extern int __as aa;
+
+__auto_type pa = &aa;		is_type(pa, int __as *);
+
+/*
+ * check-name: autotype
+ * check-command: sparse -Wno-decl $file
+ *
+ * check-error-start
+autotype.c:25:13: warning: __auto_type on bitfield
+autotype.c:37:16: error: assignment to const expression
+ * check-error-end
+ */
-- 
2.25.1

================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH] add support for GCC's __auto_type
Date: Wed, 25 Mar 2020 00:37:22 +0000
Message-ID: <42f2b610-4a89-c4c5-2291-228610b01868 () ramsayjones ! plus ! com>
--------------------


On 24/03/2020 09:57, Luc Van Oostenryck wrote:
> Despite the similarity with typeof, the approach taken here
> is relatively different. A specific symbol type (SYM_TYPEOF)
> is not used, instead a new flag is added to decl_state, another
> one in the declared symbol and a new internal type is used:
> 'autotype_ctype'. It's this new internal type that will be
> resolved to the definitive type at evalution time.
> 
> It seems to be working pretty well, maybe because it
> hasn't been tested well enough.

I haven't tested this (yet) either, but it looks good from what I see
in my email client! ;-) (I deleted my Linux repo many years ago, because
I was always over 90+% used on my disk - and I was only using it as a
'large' repo to test git!).

BTW, I recently upgraded an 32-bit Linux Mint 18.3 to 19.2 using a
'nuke and pave' procedure, rather than the 'upgrade path' provided
by Linux Mint. As part of that, I backed up my $HOME directory from
18.3 and 'restored' it to the new 19.2 (so far, so good). When I built
sparse (before installing llvm), the test-suite failed all of the
'backend/' tests. Given that these tests should have been SKIPed, since
sparse-llvm was disabled, I was a little surprised.

I am sure that you will have guessed by now, that I had an sparse-llvm
executable from 18.3 laying around, ... :-D

I thought about sending a patch to the Makefile to always include the
sparse-llvm program in the clean target (it wouldn't hurt being in the
'rm' invocation twice), but decided that this is unlikely to happen very
often, so ...

BTW, I noticed that we don't install 'sparse-llvm-dis' or 'sparsei' as
part of the 'llvm programs' - should we?

ATB,
Ramsay Jones

> 
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  parse.c                  | 38 +++++++++++++++++++++++++++
>  symbol.c                 | 19 ++++++++++++++
>  symbol.h                 |  2 ++
>  validation/autotype-ko.c | 45 ++++++++++++++++++++++++++++++++
>  validation/autotype.c    | 55 ++++++++++++++++++++++++++++++++++++++++
>  5 files changed, 159 insertions(+)
>  create mode 100644 validation/autotype-ko.c
>  create mode 100644 validation/autotype.c
> 
> diff --git a/parse.c b/parse.c
> index 0e6f66a86037..a29c67c8cf41 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -60,6 +60,7 @@ static declarator_t
>  	thread_specifier, const_qualifier, volatile_qualifier;
>  static declarator_t restrict_qualifier;
>  static declarator_t atomic_qualifier;
> +static declarator_t autotype_specifier;
>  
>  static struct token *parse_if_statement(struct token *token, struct statement *stmt);
>  static struct token *parse_return_statement(struct token *token, struct statement *stmt);
> @@ -213,6 +214,13 @@ static struct symbol_op typeof_op = {
>  	.set = Set_S|Set_T,
>  };
>  
> +static struct symbol_op autotype_op = {
> +	.type = KW_SPECIFIER,
> +	.declarator = autotype_specifier,
> +	.test = Set_Any,
> +	.set = Set_S|Set_T,
> +};
> +
>  static struct symbol_op attribute_op = {
>  	.type = KW_ATTRIBUTE,
>  	.declarator = attribute_specifier,
> @@ -505,6 +513,7 @@ static struct init_keyword {
>  	{ "typeof", 	NS_TYPEDEF, .op = &typeof_op },
>  	{ "__typeof", 	NS_TYPEDEF, .op = &typeof_op },
>  	{ "__typeof__",	NS_TYPEDEF, .op = &typeof_op },
> +	{ "__auto_type",NS_TYPEDEF, .op = &autotype_op },
>  
>  	{ "__attribute",   NS_TYPEDEF, .op = &attribute_op },
>  	{ "__attribute__", NS_TYPEDEF, .op = &attribute_op },
> @@ -1078,6 +1087,13 @@ static struct token *typeof_specifier(struct token *token, struct decl_state *ct
>  	return expect(token, ')', "after typeof");
>  }
>  
> +static struct token *autotype_specifier(struct token *token, struct decl_state *ctx)
> +{
> +	ctx->ctype.base_type = &autotype_ctype;
> +	ctx->autotype = 1;
> +	return token;
> +}
> +
>  static struct token *ignore_attribute(struct token *token, struct symbol *attr, struct decl_state *ctx)
>  {
>  	struct expression *expr = NULL;
> @@ -2985,6 +3001,11 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>  			}
>  		}
>  	} else if (base_type && base_type->type == SYM_FN) {
> +		if (base_type->ctype.base_type == &autotype_ctype) {
> +			sparse_error(decl->pos, "'%s()' has __auto_type return type",
> +				show_ident(decl->ident));
> +			base_type->ctype.base_type = &int_ctype;
> +		}
>  		if (base_type->ctype.base_type == &incomplete_ctype) {
>  			warning(decl->pos, "'%s()' has implicit return type",
>  				show_ident(decl->ident));
> @@ -3037,6 +3058,23 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>  			}
>  		}
>  
> +		if (ctx.autotype) {
> +			const char *msg = NULL;
> +			if (decl->ctype.base_type != &autotype_ctype)
> +				msg = "on non-identifier";
> +			else if (match_op(token, ','))
> +				msg = "on declaration list";
> +			else if (!decl->initializer)
> +				msg = "without initializer";
> +			else if (decl->initializer->type == EXPR_SYMBOL &&
> +				 decl->initializer->symbol == decl)
> +				msg = "on self-init var";
> +			if (msg) {
> +				sparse_error(decl->pos, "__auto_type %s", msg);
> +				decl->ctype.base_type = &bad_ctype;
> +			}
> +		}
> +
>  		if (!match_op(token, ','))
>  			break;
>  
> diff --git a/symbol.c b/symbol.c
> index ab6e9841696f..c2e6f0b426b3 100644
> --- a/symbol.c
> +++ b/symbol.c
> @@ -192,6 +192,10 @@ static struct symbol * examine_struct_union_type(struct symbol *sym, int advance
>  
>  	fn = advance ? lay_out_struct : lay_out_union;
>  	FOR_EACH_PTR(sym->symbol_list, member) {
> +		if (member->ctype.base_type == &autotype_ctype) {
> +			sparse_error(member->pos, "member '%s' has __auto_type", show_ident(member->ident));
> +			member->ctype.base_type = &incomplete_ctype;
> +		}
>  		fn(member, &info);
>  	} END_FOR_EACH_PTR(member);
>  
> @@ -210,6 +214,19 @@ static struct symbol *examine_base_type(struct symbol *sym)
>  {
>  	struct symbol *base_type;
>  
> +	if (sym->ctype.base_type == &autotype_ctype) {
> +		struct symbol *type = evaluate_expression(sym->initializer);
> +		if (!type)
> +			type = &bad_ctype;
> +		if (is_bitfield_type(type)) {
> +			warning(sym->pos, "__auto_type on bitfield");
> +			if (type->type == SYM_NODE)
> +				type = type->ctype.base_type;
> +			type = type->ctype.base_type;
> +		}
> +		sym->ctype.base_type = type;
> +	}
> +
>  	/* Check the base type */
>  	base_type = examine_symbol_type(sym->ctype.base_type);
>  	if (!base_type || base_type->type == SYM_PTR)
> @@ -734,6 +751,7 @@ struct symbol	bool_ctype, void_ctype, type_ctype,
>  		string_ctype, ptr_ctype, lazy_ptr_ctype,
>  		incomplete_ctype, label_ctype, bad_ctype,
>  		null_ctype;
> +struct symbol	autotype_ctype;
>  struct symbol	int_ptr_ctype, uint_ptr_ctype;
>  struct symbol	long_ptr_ctype, ulong_ptr_ctype;
>  struct symbol	llong_ptr_ctype, ullong_ptr_ctype;
> @@ -792,6 +810,7 @@ static const struct ctype_declare {
>  	{ &void_ctype,         T_BASETYPE },
>  	{ &type_ctype,         T_BASETYPE },
>  	{ &incomplete_ctype,   T_BASETYPE },
> +	{ &autotype_ctype,     T_BASETYPE },
>  	{ &bad_ctype,          T_BASETYPE },
>  
>  	{ &char_ctype,         T__INT(-2, char) },
> diff --git a/symbol.h b/symbol.h
> index 270ae098cacf..c86dfb335e29 100644
> --- a/symbol.h
> +++ b/symbol.h
> @@ -110,6 +110,7 @@ struct decl_state {
>  	unsigned long f_modifiers;		// function attributes
>  	unsigned char prefer_abstract, is_inline, storage_class, is_tls;
>  	unsigned char is_ext_visible;
> +	unsigned char autotype;
>  };
>  
>  struct pseudo;
> @@ -281,6 +282,7 @@ extern struct symbol	bool_ctype, void_ctype, type_ctype,
>  			string_ctype, ptr_ctype, lazy_ptr_ctype,
>  			incomplete_ctype, label_ctype, bad_ctype,
>  			null_ctype;
> +extern struct symbol	autotype_ctype;
>  extern struct symbol	int_ptr_ctype, uint_ptr_ctype;
>  extern struct symbol	long_ptr_ctype, ulong_ptr_ctype;
>  extern struct symbol	llong_ptr_ctype, ullong_ptr_ctype;
> diff --git a/validation/autotype-ko.c b/validation/autotype-ko.c
> new file mode 100644
> index 000000000000..5b6cd708ade7
> --- /dev/null
> +++ b/validation/autotype-ko.c
> @@ -0,0 +1,45 @@
> +__auto_type u;				// KO: no initializer
> +__auto_type r[2] = { 0, 1 };		// KO: not a plain identifier
> +__auto_type foo(void) { }		// KO: not a plain identifier
> +__auto_type v = 0, w = 1;		// KO: in list
> +struct { __auto_type x; } s;		// KO: not valid for struct/union
> +__auto_type self = self;		// KO: self-declared
> +__auto_type undc = this;		// KO: undeclared
> +
> +int i = 1;
> +double f = 1.0;
> +__auto_type i = 2;			// KO: redecl, same type
> +__auto_type f = 2.0f;			// KO: redecl, diff type
> +
> +
> +static int foo(int a, const int *ptr)
> +{
> +	__auto_type i = a;
> +	__auto_type c = *ptr;
> +
> +	c += 1;
> +	return i;
> +}
> +
> +/*
> + * check-name: autotype-ko
> + * check-command: sparse -Wno-decl $file
> + *
> + * check-error-start
> +autotype-ko.c:1:13: error: __auto_type without initializer
> +autotype-ko.c:2:13: error: __auto_type on non-identifier
> +autotype-ko.c:3:13: error: 'foo()' has __auto_type return type
> +autotype-ko.c:4:13: error: __auto_type on declaration list
> +autotype-ko.c:6:13: error: __auto_type on self-init var
> +autotype-ko.c:2:20: error: invalid initializer
> +autotype-ko.c:5:22: error: member 'x' has __auto_type
> +autotype-ko.c:7:20: error: undefined identifier 'this'
> +autotype-ko.c:11:13: error: symbol 'i' has multiple initializers (originally initialized at autotype-ko.c:9)
> +autotype-ko.c:12:13: error: symbol 'f' has multiple initializers (originally initialized at autotype-ko.c:10)
> +autotype-ko.c:12:13: error: symbol 'f' redeclared with different type (different type sizes):
> +autotype-ko.c:12:13:    float [addressable] [toplevel] f
> +autotype-ko.c:10:8: note: previously declared as:
> +autotype-ko.c:10:8:    double [addressable] [toplevel] f
> +autotype-ko.c:20:9: error: assignment to const expression
> + * check-error-end
> + */
> diff --git a/validation/autotype.c b/validation/autotype.c
> new file mode 100644
> index 000000000000..98683c93d2e8
> --- /dev/null
> +++ b/validation/autotype.c
> @@ -0,0 +1,55 @@
> +#ifdef __CHECKER__
> +#define	is_type(X, T)	_Static_assert([typeof(X)] == [T], "")
> +#else
> +#define	is_type(X, T)	_Static_assert(1, "")
> +#endif
> +
> +struct s {
> +	int x;
> +	int bf:3;
> +};
> +
> +extern char ch;
> +extern const int ci;
> +
> +__auto_type i = 0;		is_type(i, int);
> +__auto_type m = 1UL;		is_type(m, unsigned long);
> +__auto_type l = (int)0L;	is_type(l, int);
> +__auto_type c = (char)'\n';	is_type(c, char);
> +__auto_type p = &i;		is_type(p, int *);
> +__auto_type f = 0.0;		is_type(f, double);
> +__auto_type s = (struct s){0};	is_type(s, struct s);
> +__auto_type pci = &ci;		is_type(pci, const int *);
> +
> +// ~~: not valid for bitfield
> +__auto_type b = (struct s){0}.bf; is_type(b, int);
> +
> +static __auto_type si = 0;	is_type(si, int);
> +const  __auto_type ci = 0;	is_type(ci, const int);
> +__auto_type ch = (char) '\n';	is_type(ch, char);
> +
> +static int foo(int a)
> +{
> +	__auto_type i = a;	is_type(i, int);
> +	__auto_type c = ch;	is_type(c, char);
> +	__auto_type ct = ci;	is_type(&ct, const int *);
> +
> +	return ct += i + c;
> +}
> +
> +
> +
> +#define __as __attribute__((address_space(42)))
> +extern int __as aa;
> +
> +__auto_type pa = &aa;		is_type(pa, int __as *);
> +
> +/*
> + * check-name: autotype
> + * check-command: sparse -Wno-decl $file
> + *
> + * check-error-start
> +autotype.c:25:13: warning: __auto_type on bitfield
> +autotype.c:37:16: error: assignment to const expression
> + * check-error-end
> + */
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] add support for GCC's __auto_type
Date: Wed, 25 Mar 2020 01:39:20 +0000
Message-ID: <20200325013920.ynrmmrnkcqyupdmm () ltop ! local>
--------------------
On Wed, Mar 25, 2020 at 12:37:22AM +0000, Ramsay Jones wrote:
> On 24/03/2020 09:57, Luc Van Oostenryck wrote:
> > Despite the similarity with typeof, the approach taken here
> > is relatively different. A specific symbol type (SYM_TYPEOF)
> > is not used, instead a new flag is added to decl_state, another
> > one in the declared symbol and a new internal type is used:
> > 'autotype_ctype'. It's this new internal type that will be
> > resolved to the definitive type at evalution time.
> > 
> > It seems to be working pretty well, maybe because it
> > hasn't been tested well enough.
> 
> I haven't tested this (yet) either, but it looks good from what I see
> in my email client! ;-) (I deleted my Linux repo many years ago, because
> I was always over 90+% used on my disk - and I was only using it as a
> 'large' repo to test git!).

Yes, its size become interesting ;) 
But it shouldn't contain (yet) an occurence of __auto_type so
it wouldn't help here.

> BTW, I recently upgraded an 32-bit Linux Mint 18.3 to 19.2 using a
> 'nuke and pave' procedure, rather than the 'upgrade path' provided
> by Linux Mint. As part of that, I backed up my $HOME directory from
> 18.3 and 'restored' it to the new 19.2 (so far, so good). When I built
> sparse (before installing llvm), the test-suite failed all of the
> 'backend/' tests. Given that these tests should have been SKIPed, since
> sparse-llvm was disabled, I was a little surprised.
> 
> I am sure that you will have guessed by now, that I had an sparse-llvm
> executable from 18.3 laying around, ... :-D

For a moment you worried because I understood it as if it was
one in your PATH or so and this shouldn't be called from the
testsuite. But yes, it could happen if it comes from an old build
in the current directory.

> I thought about sending a patch to the Makefile to always include the
> sparse-llvm program in the clean target (it wouldn't hurt being in the
> 'rm' invocation twice), but decided that this is unlikely to happen very
> often, so ...

Mmmm, yes, it wouldn't hurt.
We could also do something like:

	ifeq ($(HAVE_LLVM),yes)
	... stuff ...
	else
	CLEAN += sparse-llvm
	endif

which has the advantage to not have to keep elsewhere the list
of extra targets for cleaning and keeping these things together.

> BTW, I noticed that we don't install 'sparse-llvm-dis' or 'sparsei' as
> part of the 'llvm programs' - should we?

I don't think so.
I only added sparse-llvm-dis to debug sparse-llvm and when sparsei
was added it also wasn't installed, for the same reason I think,
they're just dev tools. Now, if sparse-llvm would be more complete
and would more commonly used then yes, maybe.

In my opinion, none of the tools that depends on an external library
should be installed by default. Each of them should be, for the
distros, a separate package (like some distros do/did for inspect).

Keep safe,
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] add support for _Generic ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] add support for _Generic
Date: Thu, 28 May 2020 15:19:32 +0000
Message-ID: <20200528151932.25282-1-luc.vanoostenryck () gmail ! com>
--------------------
It's slightly tested but is fine for the latest kernels
like https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git locking/kcsan

Note: a known difference with GCC is that it doesn't make the
      distinction between 'signed char' and a plain 'char'
      (on platforms where plain char are signed) since it's using
      the usual type compatbility like used for assignements.

Reference: lore.kernel.org/r/20200527235442.GC1805@zn.tnic
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---

Given there is some emergency, exceptionally, I've directly
upstreamed this patch but of course comments are most welcome.

-- Luc

 evaluate.c                     |  36 ++++++++
 expand.c                       |   1 +
 expression.c                   |  40 +++++++++
 expression.h                   |  16 ++++
 show-parse.c                   |   3 +
 validation/generic-functions.c |  44 +++++++++
 validation/generic-schar.c     |  39 ++++++++
 validation/generic-typename.c  | 157 +++++++++++++++++++++++++++++++++
 8 files changed, 336 insertions(+)
 create mode 100644 validation/generic-functions.c
 create mode 100644 validation/generic-schar.c
 create mode 100644 validation/generic-typename.c

diff --git a/evaluate.c b/evaluate.c
index 63d75d9031d1..5f2b7d6fc4f1 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3272,6 +3272,39 @@ static void check_label_declaration(struct position pos, struct symbol *label)
 	}
 }
 
+static int type_selection(struct symbol *ctrl, struct symbol *type)
+{
+	struct ctype c = { .base_type = ctrl };
+	struct ctype t = { .base_type = type };
+
+	return !type_difference(&c, &t, 0, 0);
+}
+
+struct symbol *evaluate_generic_selection(struct expression *expr)
+{
+	struct type_expression *map;
+	struct expression *res;
+	struct symbol *ctrl;
+
+	if (!(ctrl = evaluate_expression(expr->control)))
+		return NULL;
+
+	for (map = expr->map; map; map = map->next) {
+		if (!evaluate_symbol(map->type))
+			continue;
+		if (!type_selection(ctrl, map->type))
+			continue;
+
+		res = map->expr;
+		goto end;
+	}
+	res = expr->def;
+
+end:
+	*expr = *res;
+	return evaluate_expression(expr);
+}
+
 struct symbol *evaluate_expression(struct expression *expr)
 {
 	if (!expr)
@@ -3357,6 +3390,9 @@ struct symbol *evaluate_expression(struct expression *expr)
 	case EXPR_OFFSETOF:
 		return evaluate_offsetof(expr);
 
+	case EXPR_GENERIC:
+		return evaluate_generic_selection(expr);
+
 	/* These can not exist as stand-alone expressions */
 	case EXPR_INITIALIZER:
 	case EXPR_IDENTIFIER:
diff --git a/expand.c b/expand.c
index ab296c730efd..b07893318382 100644
--- a/expand.c
+++ b/expand.c
@@ -1180,6 +1180,7 @@ static int expand_expression(struct expression *expr)
 	case EXPR_POS:
 		return expand_pos_expression(expr);
 
+	case EXPR_GENERIC:
 	case EXPR_SIZEOF:
 	case EXPR_PTRSIZEOF:
 	case EXPR_ALIGNOF:
diff --git a/expression.c b/expression.c
index 99a6d7568222..1160cd9cc593 100644
--- a/expression.c
+++ b/expression.c
@@ -44,6 +44,8 @@
 #include "target.h"
 #include "char.h"
 
+ALLOCATOR(type_expression, "type-expr-maps");
+
 static int match_oplist(int op, ...)
 {
 	va_list args;
@@ -380,6 +382,40 @@ Enoint:
 	error_die(expr->pos, "constant %s is not a valid number", show_token(token));
 }
 
+static struct token *generic_selection(struct token *token, struct expression **tree)
+{
+	struct expression *expr = alloc_expression(token->pos, EXPR_GENERIC);
+	struct type_expression **last = &expr->map;
+
+	token = expect(token, '(', "after '_Generic'");
+	token = assignment_expression(token, &expr->control);
+	if (!match_op(token, ',')) {
+		goto end;
+	}
+	while (match_op(token, ',')) {
+		token = token->next;
+		if (lookup_type(token)) {
+			struct type_expression *map = __alloc_type_expression(0);
+			token = typename(token, &map->type, NULL);
+			token = expect(token, ':', "after typename");
+			token = assignment_expression(token, &map->expr);
+			*last = map;
+			last = &map->next;
+		} else if (match_ident(token, &default_ident)) {
+			if (expr->def) {
+				warning(token->pos, "multiple default in generic expression");
+				info(expr->def->pos, "note: previous was here");
+			}
+			token = token->next;
+			token = expect(token, ':', "after typename");
+			token = assignment_expression(token, &expr->def);
+		}
+	}
+end:
+	*tree = expr;
+	return expect(token, ')', "after expression");
+}
+
 struct token *primary_expression(struct token *token, struct expression **tree)
 {
 	struct expression *expr = NULL;
@@ -423,6 +459,10 @@ struct token *primary_expression(struct token *token, struct expression **tree)
 				token = builtin_offsetof_expr(token, &expr);
 				break;
 			}
+			if (token->ident == &_Generic_ident) {
+				token = generic_selection(token->next, &expr);
+				break;
+			}
 		} else if (sym->enum_member) {
 			expr = alloc_expression(token->pos, EXPR_VALUE);
 			*expr = *sym->initializer;
diff --git a/expression.h b/expression.h
index 3b79e0f1134e..64aa1fc23309 100644
--- a/expression.h
+++ b/expression.h
@@ -64,6 +64,7 @@ enum expression_type {
 	EXPR_FVALUE,
 	EXPR_SLICE,
 	EXPR_OFFSETOF,
+	EXPR_GENERIC,
 };
 
 
@@ -147,6 +148,14 @@ struct asm_operand {
 	unsigned int is_memory:1;
 };
 
+struct type_expression {
+	struct symbol *type;
+	struct expression *expr;
+	struct type_expression *next;
+};
+
+DECLARE_ALLOCATOR(type_expression);
+
 struct expression {
 	enum expression_type type:8;
 	unsigned flags:8;
@@ -246,6 +255,13 @@ struct expression {
 				struct expression *index;
 			};
 		};
+		// EXPR_GENERIC
+		struct {
+			struct expression *control;
+			struct expression *def;
+			struct type_expression *map;
+			struct expression *result;
+		};
 	};
 };
 
diff --git a/show-parse.c b/show-parse.c
index eb71b6504be4..51a151911e3b 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -1180,6 +1180,9 @@ int show_expression(struct expression *expr)
 	case EXPR_TYPE:
 		warning(expr->pos, "unable to show type expression");
 		return 0;
+	case EXPR_GENERIC:
+		warning(expr->pos, "unable to show generic expression");
+		return 0;
 	}
 	return 0;
 }
diff --git a/validation/generic-functions.c b/validation/generic-functions.c
new file mode 100644
index 000000000000..61bfd99e2808
--- /dev/null
+++ b/validation/generic-functions.c
@@ -0,0 +1,44 @@
+void funf(float);
+void fund(double);
+void funl(long double);
+
+#define fung(X) _Generic(X,		\
+	float:		funf,		\
+	default:	fund,		\
+	long double:	funl) (X)
+
+#define TEST(name, T)	\
+static void test ## name(T a) { return fung(a); }
+
+TEST(f, float)
+TEST(d, double)
+TEST(l, long double)
+
+/*
+ * check-name: generic-functions
+ * check-command: test-linearize $file
+ *
+ * check-output-start
+testf:
+.L0:
+	<entry-point>
+	call        funf, %arg1
+	ret
+
+
+testd:
+.L2:
+	<entry-point>
+	call        fund, %arg1
+	ret
+
+
+testl:
+.L4:
+	<entry-point>
+	call        funl, %arg1
+	ret
+
+
+ * check-output-end
+ */
diff --git a/validation/generic-schar.c b/validation/generic-schar.c
new file mode 100644
index 000000000000..0b082f4f5edd
--- /dev/null
+++ b/validation/generic-schar.c
@@ -0,0 +1,39 @@
+#define typename(x) _Generic((x) 0,			\
+char:			"char",				\
+signed char:		"signed char",			\
+unsigned char:		"unsigned char",		\
+default:		"???")
+
+#define TEST(name, x)	\
+static const char *test_ ## name(void) { return typename(x); }
+
+TEST(char, char)
+TEST(schar, signed char)
+TEST(uchar, unsigned char)
+
+/*
+ * check-name: generic-schar
+ * check-command: test-linearize --arch=i386 -fsigned-char $file
+ * check-known-to-fail
+ *
+ * check-output-start
+test_char:
+.L0:
+	<entry-point>
+	ret.32      "char"
+
+
+test_schar:
+.L2:
+	<entry-point>
+	ret.32      "signed char"
+
+
+test_uchar:
+.L4:
+	<entry-point>
+	ret.32      "unsigned char"
+
+
+ * check-output-end
+ */
diff --git a/validation/generic-typename.c b/validation/generic-typename.c
new file mode 100644
index 000000000000..1e914c5768b3
--- /dev/null
+++ b/validation/generic-typename.c
@@ -0,0 +1,157 @@
+#define typename(x) _Generic((x) 0,			\
+_Bool:			"_Bool",			\
+char:			"char",				\
+unsigned char:		"unsigned char",		\
+short:			"short",			\
+unsigned short:		"unsigned short",		\
+int:			"int",				\
+unsigned int:		"unsigned int",			\
+long:			"long",				\
+unsigned long:		"unsigned long",		\
+long long:		"long long",			\
+unsigned long long:	"unsigned long long",		\
+float:			"float",			\
+double:			"double",			\
+long double:		"long double",			\
+void *:			"void *",			\
+char *:			"char *",			\
+int *:			"int *",			\
+default:		"???")
+
+#define TEST(name, x)	\
+static const char *test_ ## name(void) { return typename(x); }
+
+TEST(bool, _Bool)
+TEST(char, char)
+TEST(uchar, unsigned char)
+TEST(short, short)
+TEST(ushort, unsigned short)
+TEST(int, int)
+TEST(uint, unsigned int)
+TEST(long, long)
+TEST(ulong, unsigned long)
+TEST(llong, long long)
+TEST(ullong, unsigned long long)
+TEST(float, float)
+TEST(double, double)
+TEST(ldouble, long double)
+TEST(vptr, void *)
+TEST(cptr, char *)
+TEST(iptr, int *)
+TEST(int128, __int128)
+
+/*
+ * check-name: generic-typename
+ * check-command: test-linearize --arch=i386 -fsigned-char $file
+ *
+ * check-output-start
+test_bool:
+.L0:
+	<entry-point>
+	ret.32      "_Bool"
+
+
+test_char:
+.L2:
+	<entry-point>
+	ret.32      "char"
+
+
+test_uchar:
+.L4:
+	<entry-point>
+	ret.32      "unsigned char"
+
+
+test_short:
+.L6:
+	<entry-point>
+	ret.32      "short"
+
+
+test_ushort:
+.L8:
+	<entry-point>
+	ret.32      "unsigned short"
+
+
+test_int:
+.L10:
+	<entry-point>
+	ret.32      "int"
+
+
+test_uint:
+.L12:
+	<entry-point>
+	ret.32      "unsigned int"
+
+
+test_long:
+.L14:
+	<entry-point>
+	ret.32      "long"
+
+
+test_ulong:
+.L16:
+	<entry-point>
+	ret.32      "unsigned long"
+
+
+test_llong:
+.L18:
+	<entry-point>
+	ret.32      "long long"
+
+
+test_ullong:
+.L20:
+	<entry-point>
+	ret.32      "unsigned long long"
+
+
+test_float:
+.L22:
+	<entry-point>
+	ret.32      "float"
+
+
+test_double:
+.L24:
+	<entry-point>
+	ret.32      "double"
+
+
+test_ldouble:
+.L26:
+	<entry-point>
+	ret.32      "long double"
+
+
+test_vptr:
+.L28:
+	<entry-point>
+	ret.32      "void *"
+
+
+test_cptr:
+.L30:
+	<entry-point>
+	ret.32      "char *"
+
+
+test_iptr:
+.L32:
+	<entry-point>
+	ret.32      "int *"
+
+
+test_int128:
+.L34:
+	<entry-point>
+	ret.32      "???"
+
+
+ * check-output-end
+ */
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH] add testcase for missing inline definition ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] add testcase for missing inline definition
Date: Sun, 25 Oct 2020 13:58:12 +0000
Message-ID: <20201025135812.32732-1-luc.vanoostenryck () gmail ! com>
--------------------
If the address of an inline function is taken, a definition
for this function must be emitted.

However, sparse only do this if this inline function is defined
before it is used.

So add a testcase for this.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/linear/inline-definition.c | 30 +++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)
 create mode 100644 validation/linear/inline-definition.c

diff --git a/validation/linear/inline-definition.c b/validation/linear/inline-definition.c
new file mode 100644
index 000000000000..2918bd5d7527
--- /dev/null
+++ b/validation/linear/inline-definition.c
@@ -0,0 +1,30 @@
+extern void use(void *);
+
+static inline int inl0(int a);
+static inline int inl1(int a);
+
+static inline int inl0(int a)
+{
+	return a;
+}
+
+void foo(void)
+{
+	use(inl0);
+	use(inl1);
+}
+
+static inline int inl1(int a)
+{
+	return a;
+}
+
+/*
+ * check-name: inline-definition
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-contains: inl0:
+ * check-output-contains: inl1:
+ */
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH] avoid multiple warnings when inlining undeclared calls ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] avoid multiple warnings when inlining undeclared calls
Date: Thu, 25 Jun 2020 19:03:49 +0000
Message-ID: <20200625190349.3665-1-luc.vanoostenryck () gmail ! com>
--------------------
When inlining multiple times a function which contains an undeclared
function call, multiple error messages are issued. More annoyingly,
only the first one is meaningful, the other ones doesn't even show
the incriminated identifier:
	error: undefined identifier '...'
	error: not a function <noident>

Part of the problem is that the first message is displayed with
expression_error() which also sets the expression to &bad_ctype.
This change the way how the expression is handled when re-evaluated.

Current fix is to avoid the evaluation of function call if already
set to bad_ctype: it's known that an error message have already been
issued for them and that nothing good can done with them.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                         |  4 ++++
 validation/eval/undecl-no-indent.c | 19 +++++++++++++++++++
 2 files changed, 23 insertions(+)
 create mode 100644 validation/eval/undecl-no-indent.c

diff --git a/evaluate.c b/evaluate.c
index 461c2547285f..3b9aec3c13c0 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3130,6 +3130,10 @@ static struct symbol *evaluate_call(struct expression *expr)
 
 	if (ctype->type != SYM_FN) {
 		struct expression *arg;
+
+		if (fn->ctype == &bad_ctype)
+			return NULL;
+
 		expression_error(expr, "not a function %s",
 			     show_ident(sym->ident));
 		/* do typechecking in arguments */
diff --git a/validation/eval/undecl-no-indent.c b/validation/eval/undecl-no-indent.c
new file mode 100644
index 000000000000..4aadf3d99235
--- /dev/null
+++ b/validation/eval/undecl-no-indent.c
@@ -0,0 +1,19 @@
+inline void fun(void)
+{
+	undecl();
+}
+
+void foo(void);
+void foo(void)
+{
+	fun();
+	fun();
+}
+
+/*
+ * check-name: undecl-no-indent
+ *
+ * check-error-start
+eval/undecl-no-indent.c:3:9: error: undefined identifier 'undecl'
+ * check-error-end
+ */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] bug-assign-op0.c: fix test on 32-bit builds ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] bug-assign-op0.c: fix test on 32-bit builds
Date: Tue, 11 Aug 2020 04:45:00 +0000
Message-ID: <20200811044500.5d2il2ygw4mwrrma () ltop ! local>
--------------------
On Tue, Aug 11, 2020 at 04:15:23AM +0100, Ramsay Jones wrote:
> 
Hi Ramsay,
> 
> Tonight my 32-bit build/test run on 32-bit Linux failed this test.

Yeah :( When writing I thought "I must make them 64bit ones" but ...

> The first version of this patch was a simple one-liner to add an
> '-m64' argument to the test-linearize 'check-command'. This seems
> to be the usual fix for this, but I thought I would try something
> different. ;-)
> 
> If you prefer the one-liner, then go with that (I tested it on 32-bit
> Linux, but not on 64-bit Linux - I can't imagine that it would fail!).

No no, it's fine so when 64-bit vars are needed. Usnig -m64 is only
OK when 'long' is needed and that these long need

Many thanks for reporting and fixing this.
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] build: fix LLVM version detection ===

From: Quentin Monnet <quentin () isovalent ! com>
To: linux-sparse
Subject: [PATCH] build: fix LLVM version detection
Date: Mon, 20 Apr 2020 15:53:52 +0000
Message-ID: <20200420155352.11364-1-quentin () isovalent ! com>
--------------------
The regex match used for detecting the LLVM version works for versions
with a single-digit major number. Now that LLVM v10 is out, detection
can fail, resulting in sparse-llvm not being built.

Fix detection by extracting the major version number to compare with the
minimum supported.

Signed-off-by: Quentin Monnet <quentin@isovalent.com>
---
 Makefile | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index 85d15edca948..e93cfd66d0c9 100644
--- a/Makefile
+++ b/Makefile
@@ -183,7 +183,8 @@ arch := x32
 endif
 ifneq ($(filter ${arch},i386 i486 i586 i686 x86_64 amd64),)
 LLVM_VERSION:=$(shell $(LLVM_CONFIG) --version)
-ifeq ($(shell expr "$(LLVM_VERSION)" : '[3-9]\.'),2)
+LLVM_VERSION_MAJOR:=$(firstword $(subst ., ,$(LLVM_VERSION)))
+ifeq ($(shell expr "$(LLVM_VERSION_MAJOR)" '>=' 3),1)
 LLVM_PROGS := sparse-llvm
 $(LLVM_PROGS): LD := g++
 LLVM_LDFLAGS := $(shell $(LLVM_CONFIG) --ldflags)
-- 
2.20.1

================================================================================


################################################################################

=== Thread: [PATCH] build: let the C++ compiler be configurable ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] build: let the C++ compiler be configurable
Date: Tue, 16 Jun 2020 21:10:58 +0000
Message-ID: <20200616211058.78202-1-luc.vanoostenryck () gmail ! com>
--------------------
By default, the C compiler is 'gcc' but it can be overridden
on the command line via 'make CC=...'.

However, the C++ compiler (only needed for sparse-llvm) is
hardcoded to 'g++'.

Fix this by allowing to specify the C++ compiler via 'CXX=...'
but keeping 'g++' as the default.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Makefile | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index f46654e79642..07de0bc3226e 100644
--- a/Makefile
+++ b/Makefile
@@ -6,6 +6,7 @@ OS = linux
 
 
 CC = gcc
+CXX = g++
 LD = $(CC)
 AR = ar
 
@@ -189,7 +190,7 @@ LLVM_VERSION:=$(shell $(LLVM_CONFIG) --version)
 LLVM_VERSION_MAJOR:=$(firstword $(subst ., ,$(LLVM_VERSION)))
 ifeq ($(shell expr "$(LLVM_VERSION_MAJOR)" '>=' 3),1)
 LLVM_PROGS := sparse-llvm
-$(LLVM_PROGS): LD := g++
+$(LLVM_PROGS): LD := $(CXX)
 LLVM_LDFLAGS := $(shell $(LLVM_CONFIG) --ldflags)
 LLVM_CFLAGS := $(shell $(LLVM_CONFIG) --cppflags)
 LLVM_LIBS := $(shell $(LLVM_CONFIG) --libs)
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] cleanup: remove unneeded predeclaration of evaluate_cast() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] cleanup: remove unneeded predeclaration of evaluate_cast()
Date: Sat, 15 Aug 2020 13:45:11 +0000
Message-ID: <20200815134511.98842-1-luc.vanoostenryck () gmail ! com>
--------------------
evaluate_cast() is predeclared in the middle of the file but
is not used before it's defined.

So, remove this unneeded predeclaration.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 63a9390b5ee7..447020aa7fe4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2198,8 +2198,6 @@ static int is_promoted(struct expression *expr)
 }
 
 
-static struct symbol *evaluate_cast(struct expression *);
-
 static struct symbol *evaluate_type_information(struct expression *expr)
 {
 	struct symbol *sym = expr->cast_type;
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH] compiler.h: avoid escaped section names ===

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-sparse
Subject: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 19:43:18 +0000
Message-ID: <20200929194318.548707-1-ndesaulniers () google ! com>
--------------------
The stringification operator, `#`, in the preprocessor escapes strings.
For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
they treat section names that contain \".

The portable solution is to not use a string literal with the
preprocessor stringification operator.

In this case, since __section unconditionally uses the stringification
operator, we actually want the more verbose
__attribute__((__section__())).

Link: https://bugs.llvm.org/show_bug.cgi?id=42950
Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
---
 include/linux/compiler.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 92ef163a7479..ac45f6d40d39 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 	extern typeof(sym) sym;					\
 	static const unsigned long __kentry_##sym		\
 	__used							\
-	__section("___kentry" "+" #sym )			\
+	__attribute__((__section__("___kentry+" #sym)))		\
 	= (unsigned long)&sym;
 #endif
 
-- 
2.28.0.709.gb0816b6eb0-goog

================================================================================

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-kernel
Subject: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 19:43:18 +0000
Message-ID: <20200929194318.548707-1-ndesaulniers () google ! com>
--------------------
The stringification operator, `#`, in the preprocessor escapes strings.
For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
they treat section names that contain \".

The portable solution is to not use a string literal with the
preprocessor stringification operator.

In this case, since __section unconditionally uses the stringification
operator, we actually want the more verbose
__attribute__((__section__())).

Link: https://bugs.llvm.org/show_bug.cgi?id=42950
Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
---
 include/linux/compiler.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 92ef163a7479..ac45f6d40d39 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 	extern typeof(sym) sym;					\
 	static const unsigned long __kentry_##sym		\
 	__used							\
-	__section("___kentry" "+" #sym )			\
+	__attribute__((__section__("___kentry+" #sym)))		\
 	= (unsigned long)&sym;
 #endif
 
-- 
2.28.0.709.gb0816b6eb0-goog

================================================================================

From: Arvind Sankar <nivedita () alum ! mit ! edu>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:08:01 +0000
Message-ID: <20200929200801.GA2668747 () rani ! riverdale ! lan>
--------------------
On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> The stringification operator, `#`, in the preprocessor escapes strings.
> For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> they treat section names that contain \".
> 
> The portable solution is to not use a string literal with the
> preprocessor stringification operator.
> 
> In this case, since __section unconditionally uses the stringification
> operator, we actually want the more verbose
> __attribute__((__section__())).
> 
> Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> ---
>  include/linux/compiler.h | 2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
> 
> diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> index 92ef163a7479..ac45f6d40d39 100644
> --- a/include/linux/compiler.h
> +++ b/include/linux/compiler.h
> @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
>  	extern typeof(sym) sym;					\
>  	static const unsigned long __kentry_##sym		\
>  	__used							\
> -	__section("___kentry" "+" #sym )			\
> +	__attribute__((__section__("___kentry+" #sym)))		\
>  	= (unsigned long)&sym;
>  #endif
>  
> -- 
> 2.28.0.709.gb0816b6eb0-goog
> 

There was this previous mini-thread:
https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
and this older one:
https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/

Just for my own curiosity: how does KENTRY actually get used? grep
doesn't show any hits, and the thread from 2019 was actually going to
drop it if I read it right, and also just remove stringification from
the __section macro.

There are still other instances that need to be fixed, right?

Thanks.
================================================================================

From: Arvind Sankar <nivedita () alum ! mit ! edu>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:13:24 +0000
Message-ID: <20200929201324.GB2668747 () rani ! riverdale ! lan>
--------------------
On Tue, Sep 29, 2020 at 04:08:01PM -0400, Arvind Sankar wrote:
> On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > The stringification operator, `#`, in the preprocessor escapes strings.
> > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > they treat section names that contain \".
> > 
> > The portable solution is to not use a string literal with the
> > preprocessor stringification operator.
> > 
> > In this case, since __section unconditionally uses the stringification
> > operator, we actually want the more verbose
> > __attribute__((__section__())).
> > 
> > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > ---
> >  include/linux/compiler.h | 2 +-
> >  1 file changed, 1 insertion(+), 1 deletion(-)
> > 
> > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > index 92ef163a7479..ac45f6d40d39 100644
> > --- a/include/linux/compiler.h
> > +++ b/include/linux/compiler.h
> > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> >  	extern typeof(sym) sym;					\
> >  	static const unsigned long __kentry_##sym		\
> >  	__used							\
> > -	__section("___kentry" "+" #sym )			\
> > +	__attribute__((__section__("___kentry+" #sym)))		\
> >  	= (unsigned long)&sym;
> >  #endif
> >  
> > -- 
> > 2.28.0.709.gb0816b6eb0-goog
> > 
> 
> There was this previous mini-thread:
> https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> and this older one:
> https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
> 
> Just for my own curiosity: how does KENTRY actually get used? grep
> doesn't show any hits, and the thread from 2019 was actually going to
> drop it if I read it right, and also just remove stringification from
> the __section macro.
> 
> There are still other instances that need to be fixed, right?
> 
> Thanks.

Ignore the last question, I see you have separate patches for the rest.
================================================================================

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:25:47 +0000
Message-ID: <CAKwvOdm=H3GDOPo-dbgsqH7UXzC1twz1h2Rdcidh8OXtFtCY4Q () mail ! gmail ! com>
--------------------
On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
>
> On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > The stringification operator, `#`, in the preprocessor escapes strings.
> > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > they treat section names that contain \".
> >
> > The portable solution is to not use a string literal with the
> > preprocessor stringification operator.
> >
> > In this case, since __section unconditionally uses the stringification
> > operator, we actually want the more verbose
> > __attribute__((__section__())).
> >
> > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > ---
> >  include/linux/compiler.h | 2 +-
> >  1 file changed, 1 insertion(+), 1 deletion(-)
> >
> > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > index 92ef163a7479..ac45f6d40d39 100644
> > --- a/include/linux/compiler.h
> > +++ b/include/linux/compiler.h
> > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> >       extern typeof(sym) sym;                                 \
> >       static const unsigned long __kentry_##sym               \
> >       __used                                                  \
> > -     __section("___kentry" "+" #sym )                        \
> > +     __attribute__((__section__("___kentry+" #sym)))         \
> >       = (unsigned long)&sym;
> >  #endif
> >
> > --
> > 2.28.0.709.gb0816b6eb0-goog
> >
>
> There was this previous mini-thread:
> https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> and this older one:
> https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
>
> Just for my own curiosity: how does KENTRY actually get used? grep
> doesn't show any hits, and the thread from 2019 was actually going to
> drop it if I read it right, and also just remove stringification from
> the __section macro.

Oh, sorry I didn't respond on that thread; I could have sworn I ran a
grep for KENTRY back then.

$ git log -S KENTRY

Doesn't seem to get any hits, so I'm not sure what I should use for a
proper Fixes tag in the event we just remove it.  Let me grab lunch,
then I'll send a v2 that just removes the KENTRY block.  Thanks for
the reminder!

And I don't remember what ever happened to Joe's script for treewide
conversion of __section.
-- 
Thanks,
~Nick Desaulniers
================================================================================

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:25:47 +0000
Message-ID: <CAKwvOdm=H3GDOPo-dbgsqH7UXzC1twz1h2Rdcidh8OXtFtCY4Q () mail ! gmail ! com>
--------------------
On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
>
> On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > The stringification operator, `#`, in the preprocessor escapes strings.
> > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > they treat section names that contain \".
> >
> > The portable solution is to not use a string literal with the
> > preprocessor stringification operator.
> >
> > In this case, since __section unconditionally uses the stringification
> > operator, we actually want the more verbose
> > __attribute__((__section__())).
> >
> > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > ---
> >  include/linux/compiler.h | 2 +-
> >  1 file changed, 1 insertion(+), 1 deletion(-)
> >
> > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > index 92ef163a7479..ac45f6d40d39 100644
> > --- a/include/linux/compiler.h
> > +++ b/include/linux/compiler.h
> > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> >       extern typeof(sym) sym;                                 \
> >       static const unsigned long __kentry_##sym               \
> >       __used                                                  \
> > -     __section("___kentry" "+" #sym )                        \
> > +     __attribute__((__section__("___kentry+" #sym)))         \
> >       = (unsigned long)&sym;
> >  #endif
> >
> > --
> > 2.28.0.709.gb0816b6eb0-goog
> >
>
> There was this previous mini-thread:
> https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> and this older one:
> https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
>
> Just for my own curiosity: how does KENTRY actually get used? grep
> doesn't show any hits, and the thread from 2019 was actually going to
> drop it if I read it right, and also just remove stringification from
> the __section macro.

Oh, sorry I didn't respond on that thread; I could have sworn I ran a
grep for KENTRY back then.

$ git log -S KENTRY

Doesn't seem to get any hits, so I'm not sure what I should use for a
proper Fixes tag in the event we just remove it.  Let me grab lunch,
then I'll send a v2 that just removes the KENTRY block.  Thanks for
the reminder!

And I don't remember what ever happened to Joe's script for treewide
conversion of __section.
-- 
Thanks,
~Nick Desaulniers
================================================================================

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:30:22 +0000
Message-ID: <CAKwvOdmA746irmMVAzs5pJz4XgcWMBA8jWM2Ha1Z5c6hajWzJw () mail ! gmail ! com>
--------------------
On Tue, Sep 29, 2020 at 1:25 PM Nick Desaulniers
<ndesaulniers@google.com> wrote:
>
> On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
> >
> > On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > > The stringification operator, `#`, in the preprocessor escapes strings.
> > > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > > they treat section names that contain \".
> > >
> > > The portable solution is to not use a string literal with the
> > > preprocessor stringification operator.
> > >
> > > In this case, since __section unconditionally uses the stringification
> > > operator, we actually want the more verbose
> > > __attribute__((__section__())).
> > >
> > > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > > ---
> > >  include/linux/compiler.h | 2 +-
> > >  1 file changed, 1 insertion(+), 1 deletion(-)
> > >
> > > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > > index 92ef163a7479..ac45f6d40d39 100644
> > > --- a/include/linux/compiler.h
> > > +++ b/include/linux/compiler.h
> > > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> > >       extern typeof(sym) sym;                                 \
> > >       static const unsigned long __kentry_##sym               \
> > >       __used                                                  \
> > > -     __section("___kentry" "+" #sym )                        \
> > > +     __attribute__((__section__("___kentry+" #sym)))         \
> > >       = (unsigned long)&sym;
> > >  #endif
> > >
> > > --
> > > 2.28.0.709.gb0816b6eb0-goog
> > >
> >
> > There was this previous mini-thread:
> > https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> > and this older one:
> > https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
> >
> > Just for my own curiosity: how does KENTRY actually get used? grep
> > doesn't show any hits, and the thread from 2019 was actually going to
> > drop it if I read it right, and also just remove stringification from
> > the __section macro.
>
> Oh, sorry I didn't respond on that thread; I could have sworn I ran a
> grep for KENTRY back then.
>
> $ git log -S KENTRY

Added by
b67067f1176df6ee727450546b58704e4b588563 ?

>
> Doesn't seem to get any hits, so I'm not sure what I should use for a
> proper Fixes tag in the event we just remove it.  Let me grab lunch,
> then I'll send a v2 that just removes the KENTRY block.  Thanks for
> the reminder!
>
> And I don't remember what ever happened to Joe's script for treewide
> conversion of __section.
> --
> Thanks,
> ~Nick Desaulniers



-- 
Thanks,
~Nick Desaulniers
================================================================================

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:30:22 +0000
Message-ID: <CAKwvOdmA746irmMVAzs5pJz4XgcWMBA8jWM2Ha1Z5c6hajWzJw () mail ! gmail ! com>
--------------------
On Tue, Sep 29, 2020 at 1:25 PM Nick Desaulniers
<ndesaulniers@google.com> wrote:
>
> On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
> >
> > On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > > The stringification operator, `#`, in the preprocessor escapes strings.
> > > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > > they treat section names that contain \".
> > >
> > > The portable solution is to not use a string literal with the
> > > preprocessor stringification operator.
> > >
> > > In this case, since __section unconditionally uses the stringification
> > > operator, we actually want the more verbose
> > > __attribute__((__section__())).
> > >
> > > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > > ---
> > >  include/linux/compiler.h | 2 +-
> > >  1 file changed, 1 insertion(+), 1 deletion(-)
> > >
> > > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > > index 92ef163a7479..ac45f6d40d39 100644
> > > --- a/include/linux/compiler.h
> > > +++ b/include/linux/compiler.h
> > > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> > >       extern typeof(sym) sym;                                 \
> > >       static const unsigned long __kentry_##sym               \
> > >       __used                                                  \
> > > -     __section("___kentry" "+" #sym )                        \
> > > +     __attribute__((__section__("___kentry+" #sym)))         \
> > >       = (unsigned long)&sym;
> > >  #endif
> > >
> > > --
> > > 2.28.0.709.gb0816b6eb0-goog
> > >
> >
> > There was this previous mini-thread:
> > https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> > and this older one:
> > https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
> >
> > Just for my own curiosity: how does KENTRY actually get used? grep
> > doesn't show any hits, and the thread from 2019 was actually going to
> > drop it if I read it right, and also just remove stringification from
> > the __section macro.
>
> Oh, sorry I didn't respond on that thread; I could have sworn I ran a
> grep for KENTRY back then.
>
> $ git log -S KENTRY

Added by
b67067f1176df6ee727450546b58704e4b588563 ?

>
> Doesn't seem to get any hits, so I'm not sure what I should use for a
> proper Fixes tag in the event we just remove it.  Let me grab lunch,
> then I'll send a v2 that just removes the KENTRY block.  Thanks for
> the reminder!
>
> And I don't remember what ever happened to Joe's script for treewide
> conversion of __section.
> --
> Thanks,
> ~Nick Desaulniers



-- 
Thanks,
~Nick Desaulniers
================================================================================

From: Arvind Sankar <nivedita () alum ! mit ! edu>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:47:48 +0000
Message-ID: <20200929204748.GA2683578 () rani ! riverdale ! lan>
--------------------
On Tue, Sep 29, 2020 at 01:30:22PM -0700, Nick Desaulniers wrote:
> On Tue, Sep 29, 2020 at 1:25 PM Nick Desaulniers
> <ndesaulniers@google.com> wrote:
> >
> > On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
> > >
> > > On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > > > The stringification operator, `#`, in the preprocessor escapes strings.
> > > > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > > > they treat section names that contain \".
> > > >
> > > > The portable solution is to not use a string literal with the
> > > > preprocessor stringification operator.
> > > >
> > > > In this case, since __section unconditionally uses the stringification
> > > > operator, we actually want the more verbose
> > > > __attribute__((__section__())).
> > > >
> > > > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > > > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > > > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > > > ---
> > > >  include/linux/compiler.h | 2 +-
> > > >  1 file changed, 1 insertion(+), 1 deletion(-)
> > > >
> > > > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > > > index 92ef163a7479..ac45f6d40d39 100644
> > > > --- a/include/linux/compiler.h
> > > > +++ b/include/linux/compiler.h
> > > > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> > > >       extern typeof(sym) sym;                                 \
> > > >       static const unsigned long __kentry_##sym               \
> > > >       __used                                                  \
> > > > -     __section("___kentry" "+" #sym )                        \
> > > > +     __attribute__((__section__("___kentry+" #sym)))         \
> > > >       = (unsigned long)&sym;
> > > >  #endif
> > > >
> > > > --
> > > > 2.28.0.709.gb0816b6eb0-goog
> > > >
> > >
> > > There was this previous mini-thread:
> > > https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> > > and this older one:
> > > https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
> > >
> > > Just for my own curiosity: how does KENTRY actually get used? grep
> > > doesn't show any hits, and the thread from 2019 was actually going to
> > > drop it if I read it right, and also just remove stringification from
> > > the __section macro.
> >
> > Oh, sorry I didn't respond on that thread; I could have sworn I ran a
> > grep for KENTRY back then.
> >
> > $ git log -S KENTRY
> 
> Added by
> b67067f1176df6ee727450546b58704e4b588563 ?
> 

Yeah but nothing seems to have used it. I assume for LTO we use some
other technique to mark functions as used?
================================================================================

From: Arvind Sankar <nivedita () alum ! mit ! edu>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:47:48 +0000
Message-ID: <20200929204748.GA2683578 () rani ! riverdale ! lan>
--------------------
On Tue, Sep 29, 2020 at 01:30:22PM -0700, Nick Desaulniers wrote:
> On Tue, Sep 29, 2020 at 1:25 PM Nick Desaulniers
> <ndesaulniers@google.com> wrote:
> >
> > On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
> > >
> > > On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > > > The stringification operator, `#`, in the preprocessor escapes strings.
> > > > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > > > they treat section names that contain \".
> > > >
> > > > The portable solution is to not use a string literal with the
> > > > preprocessor stringification operator.
> > > >
> > > > In this case, since __section unconditionally uses the stringification
> > > > operator, we actually want the more verbose
> > > > __attribute__((__section__())).
> > > >
> > > > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > > > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > > > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > > > ---
> > > >  include/linux/compiler.h | 2 +-
> > > >  1 file changed, 1 insertion(+), 1 deletion(-)
> > > >
> > > > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > > > index 92ef163a7479..ac45f6d40d39 100644
> > > > --- a/include/linux/compiler.h
> > > > +++ b/include/linux/compiler.h
> > > > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> > > >       extern typeof(sym) sym;                                 \
> > > >       static const unsigned long __kentry_##sym               \
> > > >       __used                                                  \
> > > > -     __section("___kentry" "+" #sym )                        \
> > > > +     __attribute__((__section__("___kentry+" #sym)))         \
> > > >       = (unsigned long)&sym;
> > > >  #endif
> > > >
> > > > --
> > > > 2.28.0.709.gb0816b6eb0-goog
> > > >
> > >
> > > There was this previous mini-thread:
> > > https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> > > and this older one:
> > > https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
> > >
> > > Just for my own curiosity: how does KENTRY actually get used? grep
> > > doesn't show any hits, and the thread from 2019 was actually going to
> > > drop it if I read it right, and also just remove stringification from
> > > the __section macro.
> >
> > Oh, sorry I didn't respond on that thread; I could have sworn I ran a
> > grep for KENTRY back then.
> >
> > $ git log -S KENTRY
> 
> Added by
> b67067f1176df6ee727450546b58704e4b588563 ?
> 

Yeah but nothing seems to have used it. I assume for LTO we use some
other technique to mark functions as used?
================================================================================

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:59:30 +0000
Message-ID: <CAKwvOd=Pj1FiFxKwbGu1g-LjabHqbct4_HF2BpEj4Su6+Fv-Gw () mail ! gmail ! com>
--------------------
On Tue, Sep 29, 2020 at 1:47 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
>
> On Tue, Sep 29, 2020 at 01:30:22PM -0700, Nick Desaulniers wrote:
> > On Tue, Sep 29, 2020 at 1:25 PM Nick Desaulniers
> > <ndesaulniers@google.com> wrote:
> > >
> > > On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
> > > >
> > > > On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > > > > The stringification operator, `#`, in the preprocessor escapes strings.
> > > > > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > > > > they treat section names that contain \".
> > > > >
> > > > > The portable solution is to not use a string literal with the
> > > > > preprocessor stringification operator.
> > > > >
> > > > > In this case, since __section unconditionally uses the stringification
> > > > > operator, we actually want the more verbose
> > > > > __attribute__((__section__())).
> > > > >
> > > > > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > > > > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > > > > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > > > > ---
> > > > >  include/linux/compiler.h | 2 +-
> > > > >  1 file changed, 1 insertion(+), 1 deletion(-)
> > > > >
> > > > > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > > > > index 92ef163a7479..ac45f6d40d39 100644
> > > > > --- a/include/linux/compiler.h
> > > > > +++ b/include/linux/compiler.h
> > > > > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> > > > >       extern typeof(sym) sym;                                 \
> > > > >       static const unsigned long __kentry_##sym               \
> > > > >       __used                                                  \
> > > > > -     __section("___kentry" "+" #sym )                        \
> > > > > +     __attribute__((__section__("___kentry+" #sym)))         \
> > > > >       = (unsigned long)&sym;
> > > > >  #endif
> > > > >
> > > > > --
> > > > > 2.28.0.709.gb0816b6eb0-goog
> > > > >
> > > >
> > > > There was this previous mini-thread:
> > > > https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> > > > and this older one:
> > > > https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
> > > >
> > > > Just for my own curiosity: how does KENTRY actually get used? grep
> > > > doesn't show any hits, and the thread from 2019 was actually going to
> > > > drop it if I read it right, and also just remove stringification from
> > > > the __section macro.
> > >
> > > Oh, sorry I didn't respond on that thread; I could have sworn I ran a
> > > grep for KENTRY back then.
> > >
> > > $ git log -S KENTRY
> >
> > Added by
> > b67067f1176df6ee727450546b58704e4b588563 ?
> >
>
> Yeah but nothing seems to have used it. I assume for LTO we use some
> other technique to mark functions as used?

Nicholas, do you recall why KENTRY was added in
b67067f1176df6ee727450546b58704e4b588563?  May I remove that and the
addition to INIT_DATA from that commit?

-- 
Thanks,
~Nick Desaulniers
================================================================================

From: Nick Desaulniers <ndesaulniers () google ! com>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 20:59:30 +0000
Message-ID: <CAKwvOd=Pj1FiFxKwbGu1g-LjabHqbct4_HF2BpEj4Su6+Fv-Gw () mail ! gmail ! com>
--------------------
On Tue, Sep 29, 2020 at 1:47 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
>
> On Tue, Sep 29, 2020 at 01:30:22PM -0700, Nick Desaulniers wrote:
> > On Tue, Sep 29, 2020 at 1:25 PM Nick Desaulniers
> > <ndesaulniers@google.com> wrote:
> > >
> > > On Tue, Sep 29, 2020 at 1:08 PM Arvind Sankar <nivedita@alum.mit.edu> wrote:
> > > >
> > > > On Tue, Sep 29, 2020 at 12:43:18PM -0700, Nick Desaulniers wrote:
> > > > > The stringification operator, `#`, in the preprocessor escapes strings.
> > > > > For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> > > > > they treat section names that contain \".
> > > > >
> > > > > The portable solution is to not use a string literal with the
> > > > > preprocessor stringification operator.
> > > > >
> > > > > In this case, since __section unconditionally uses the stringification
> > > > > operator, we actually want the more verbose
> > > > > __attribute__((__section__())).
> > > > >
> > > > > Link: https://bugs.llvm.org/show_bug.cgi?id=42950
> > > > > Fixes: commit e04462fb82f8 ("Compiler Attributes: remove uses of __attribute__ from compiler.h")
> > > > > Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
> > > > > ---
> > > > >  include/linux/compiler.h | 2 +-
> > > > >  1 file changed, 1 insertion(+), 1 deletion(-)
> > > > >
> > > > > diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> > > > > index 92ef163a7479..ac45f6d40d39 100644
> > > > > --- a/include/linux/compiler.h
> > > > > +++ b/include/linux/compiler.h
> > > > > @@ -155,7 +155,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
> > > > >       extern typeof(sym) sym;                                 \
> > > > >       static const unsigned long __kentry_##sym               \
> > > > >       __used                                                  \
> > > > > -     __section("___kentry" "+" #sym )                        \
> > > > > +     __attribute__((__section__("___kentry+" #sym)))         \
> > > > >       = (unsigned long)&sym;
> > > > >  #endif
> > > > >
> > > > > --
> > > > > 2.28.0.709.gb0816b6eb0-goog
> > > > >
> > > >
> > > > There was this previous mini-thread:
> > > > https://lore.kernel.org/lkml/20200629205448.GA1474367@rani.riverdale.lan/
> > > > and this older one:
> > > > https://lore.kernel.org/lkml/20190904181740.GA19688@gmail.com/
> > > >
> > > > Just for my own curiosity: how does KENTRY actually get used? grep
> > > > doesn't show any hits, and the thread from 2019 was actually going to
> > > > drop it if I read it right, and also just remove stringification from
> > > > the __section macro.
> > >
> > > Oh, sorry I didn't respond on that thread; I could have sworn I ran a
> > > grep for KENTRY back then.
> > >
> > > $ git log -S KENTRY
> >
> > Added by
> > b67067f1176df6ee727450546b58704e4b588563 ?
> >
>
> Yeah but nothing seems to have used it. I assume for LTO we use some
> other technique to mark functions as used?

Nicholas, do you recall why KENTRY was added in
b67067f1176df6ee727450546b58704e4b588563?  May I remove that and the
addition to INIT_DATA from that commit?

-- 
Thanks,
~Nick Desaulniers
================================================================================

From: Miguel Ojeda <miguel.ojeda.sandonis () gmail ! com>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 21:33:10 +0000
Message-ID: <CANiq72kHEhTm3-7WbZwmoKQV5Qn9fD_sk+yrVrdj_K0AqT6dNQ () mail ! gmail ! com>
--------------------
Hi Nick,

On Tue, Sep 29, 2020 at 9:43 PM Nick Desaulniers
<ndesaulniers@google.com> wrote:
>
> The stringification operator, `#`, in the preprocessor escapes strings.
> For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> they treat section names that contain \".
>
> The portable solution is to not use a string literal with the
> preprocessor stringification operator.
>
> In this case, since __section unconditionally uses the stringification
> operator, we actually want the more verbose
> __attribute__((__section__())).

Let's add a comment about this in the code -- otherwise we/someone
will convert it back without noticing. Also we could add another on
`__section` itself warning about this.

> Link: https://bugs.llvm.org/show_bug.cgi?id=42950

Is there a link / have we opened a bug on GCC's side too?

Thanks!

Cheers,
Miguel
================================================================================

From: Miguel Ojeda <miguel.ojeda.sandonis () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Tue, 29 Sep 2020 21:33:10 +0000
Message-ID: <CANiq72kHEhTm3-7WbZwmoKQV5Qn9fD_sk+yrVrdj_K0AqT6dNQ () mail ! gmail ! com>
--------------------
Hi Nick,

On Tue, Sep 29, 2020 at 9:43 PM Nick Desaulniers
<ndesaulniers@google.com> wrote:
>
> The stringification operator, `#`, in the preprocessor escapes strings.
> For example, `# "foo"` becomes `"\"foo\""`.  GCC and Clang differ in how
> they treat section names that contain \".
>
> The portable solution is to not use a string literal with the
> preprocessor stringification operator.
>
> In this case, since __section unconditionally uses the stringification
> operator, we actually want the more verbose
> __attribute__((__section__())).

Let's add a comment about this in the code -- otherwise we/someone
will convert it back without noticing. Also we could add another on
`__section` itself warning about this.

> Link: https://bugs.llvm.org/show_bug.cgi?id=42950

Is there a link / have we opened a bug on GCC's side too?

Thanks!

Cheers,
Miguel
================================================================================

From: David Laight <David.Laight () ACULAB ! COM>
To: linux-kernel
Subject: RE: [PATCH] compiler.h: avoid escaped section names
Date: Wed, 30 Sep 2020 08:33:20 +0000
Message-ID: <059f629fcf5a4fe0825287a44fd24f52 () AcuMS ! aculab ! com>
--------------------
RnJvbTogTmljayBEZXNhdWxuaWVycw0KPiBTZW50OiAyOSBTZXB0ZW1iZXIgMjAyMCAyMDo0Mw0K
PiANCj4gVGhlIHN0cmluZ2lmaWNhdGlvbiBvcGVyYXRvciwgYCNgLCBpbiB0aGUgcHJlcHJvY2Vz
c29yIGVzY2FwZXMgc3RyaW5ncy4NCj4gRm9yIGV4YW1wbGUsIGAjICJmb28iYCBiZWNvbWVzIGAi
XCJmb29cIiJgLiAgR0NDIGFuZCBDbGFuZyBkaWZmZXIgaW4gaG93DQo+IHRoZXkgdHJlYXQgc2Vj
dGlvbiBuYW1lcyB0aGF0IGNvbnRhaW4gXCIuDQo+IA0KPiBUaGUgcG9ydGFibGUgc29sdXRpb24g
aXMgdG8gbm90IHVzZSBhIHN0cmluZyBsaXRlcmFsIHdpdGggdGhlDQo+IHByZXByb2Nlc3NvciBz
dHJpbmdpZmljYXRpb24gb3BlcmF0b3IuDQo+IA0KPiBJbiB0aGlzIGNhc2UsIHNpbmNlIF9fc2Vj
dGlvbiB1bmNvbmRpdGlvbmFsbHkgdXNlcyB0aGUgc3RyaW5naWZpY2F0aW9uDQo+IG9wZXJhdG9y
LCB3ZSBhY3R1YWxseSB3YW50IHRoZSBtb3JlIHZlcmJvc2UNCj4gX19hdHRyaWJ1dGVfXygoX19z
ZWN0aW9uX18oKSkpLg0KPiANCj4gTGluazogaHR0cHM6Ly9idWdzLmxsdm0ub3JnL3Nob3dfYnVn
LmNnaT9pZD00Mjk1MA0KPiBGaXhlczogY29tbWl0IGUwNDQ2MmZiODJmOCAoIkNvbXBpbGVyIEF0
dHJpYnV0ZXM6IHJlbW92ZSB1c2VzIG9mIF9fYXR0cmlidXRlX18gZnJvbSBjb21waWxlci5oIikN
Cj4gU2lnbmVkLW9mZi1ieTogTmljayBEZXNhdWxuaWVycyA8bmRlc2F1bG5pZXJzQGdvb2dsZS5j
b20+DQo+IC0tLQ0KPiAgaW5jbHVkZS9saW51eC9jb21waWxlci5oIHwgMiArLQ0KPiAgMSBmaWxl
IGNoYW5nZWQsIDEgaW5zZXJ0aW9uKCspLCAxIGRlbGV0aW9uKC0pDQo+IA0KPiBkaWZmIC0tZ2l0
IGEvaW5jbHVkZS9saW51eC9jb21waWxlci5oIGIvaW5jbHVkZS9saW51eC9jb21waWxlci5oDQo+
IGluZGV4IDkyZWYxNjNhNzQ3OS4uYWM0NWY2ZDQwZDM5IDEwMDY0NA0KPiAtLS0gYS9pbmNsdWRl
L2xpbnV4L2NvbXBpbGVyLmgNCj4gKysrIGIvaW5jbHVkZS9saW51eC9jb21waWxlci5oDQo+IEBA
IC0xNTUsNyArMTU1LDcgQEAgdm9pZCBmdHJhY2VfbGlrZWx5X3VwZGF0ZShzdHJ1Y3QgZnRyYWNl
X2xpa2VseV9kYXRhICpmLCBpbnQgdmFsLA0KPiAgCWV4dGVybiB0eXBlb2Yoc3ltKSBzeW07CQkJ
CQlcDQo+ICAJc3RhdGljIGNvbnN0IHVuc2lnbmVkIGxvbmcgX19rZW50cnlfIyNzeW0JCVwNCj4g
IAlfX3VzZWQJCQkJCQkJXA0KPiAtCV9fc2VjdGlvbigiX19fa2VudHJ5IiAiKyIgI3N5bSApCQkJ
XA0KPiArCV9fYXR0cmlidXRlX18oKF9fc2VjdGlvbl9fKCJfX19rZW50cnkrIiAjc3ltKSkpCQlc
DQo+ICAJPSAodW5zaWduZWQgbG9uZykmc3ltOw0KPiAgI2VuZGlmDQoNCkkgZ3Vlc3Mgd2hhdCB0
aGlzIHJlYWxseSB3YW50cyBpczoNCglfX3NlY3Rpb24oX19rZW50cnkrIyNzeW0pDQpidXQgdGhh
dCBnZW5lcmF0ZXMgYW4gZXJyb3IgYmVjYXVzZSB5b3UgY2FuIG9ubHkgdXNlICMjIGJldHdlZW4N
CnZhcmlhYmxlIG5hbWVzLg0KDQpQZXJoYXBzIHNvbWVvbmUgc2hvdWxkbid0IGhhdmUgdHJpZXMg
dG8gYmUgY2xldmVyIGFuZCBub3QgcHV0DQphbiB1bnVzdWFsIGNoYXJhY3RlciBpbiB0aGUgc2Vj
dGlvbiBuYW1lLg0KDQoJRGF2aWQNCg0KLQ0KUmVnaXN0ZXJlZCBBZGRyZXNzIExha2VzaWRlLCBC
cmFtbGV5IFJvYWQsIE1vdW50IEZhcm0sIE1pbHRvbiBLZXluZXMsIE1LMSAxUFQsIFVLDQpSZWdp
c3RyYXRpb24gTm86IDEzOTczODYgKFdhbGVzKQ0K

================================================================================

From: David Laight <David.Laight () ACULAB ! COM>
To: linux-sparse
Subject: RE: [PATCH] compiler.h: avoid escaped section names
Date: Wed, 30 Sep 2020 08:33:20 +0000
Message-ID: <059f629fcf5a4fe0825287a44fd24f52 () AcuMS ! aculab ! com>
--------------------
RnJvbTogTmljayBEZXNhdWxuaWVycw0KPiBTZW50OiAyOSBTZXB0ZW1iZXIgMjAyMCAyMDo0Mw0K
PiANCj4gVGhlIHN0cmluZ2lmaWNhdGlvbiBvcGVyYXRvciwgYCNgLCBpbiB0aGUgcHJlcHJvY2Vz
c29yIGVzY2FwZXMgc3RyaW5ncy4NCj4gRm9yIGV4YW1wbGUsIGAjICJmb28iYCBiZWNvbWVzIGAi
XCJmb29cIiJgLiAgR0NDIGFuZCBDbGFuZyBkaWZmZXIgaW4gaG93DQo+IHRoZXkgdHJlYXQgc2Vj
dGlvbiBuYW1lcyB0aGF0IGNvbnRhaW4gXCIuDQo+IA0KPiBUaGUgcG9ydGFibGUgc29sdXRpb24g
aXMgdG8gbm90IHVzZSBhIHN0cmluZyBsaXRlcmFsIHdpdGggdGhlDQo+IHByZXByb2Nlc3NvciBz
dHJpbmdpZmljYXRpb24gb3BlcmF0b3IuDQo+IA0KPiBJbiB0aGlzIGNhc2UsIHNpbmNlIF9fc2Vj
dGlvbiB1bmNvbmRpdGlvbmFsbHkgdXNlcyB0aGUgc3RyaW5naWZpY2F0aW9uDQo+IG9wZXJhdG9y
LCB3ZSBhY3R1YWxseSB3YW50IHRoZSBtb3JlIHZlcmJvc2UNCj4gX19hdHRyaWJ1dGVfXygoX19z
ZWN0aW9uX18oKSkpLg0KPiANCj4gTGluazogaHR0cHM6Ly9idWdzLmxsdm0ub3JnL3Nob3dfYnVn
LmNnaT9pZD00Mjk1MA0KPiBGaXhlczogY29tbWl0IGUwNDQ2MmZiODJmOCAoIkNvbXBpbGVyIEF0
dHJpYnV0ZXM6IHJlbW92ZSB1c2VzIG9mIF9fYXR0cmlidXRlX18gZnJvbSBjb21waWxlci5oIikN
Cj4gU2lnbmVkLW9mZi1ieTogTmljayBEZXNhdWxuaWVycyA8bmRlc2F1bG5pZXJzQGdvb2dsZS5j
b20+DQo+IC0tLQ0KPiAgaW5jbHVkZS9saW51eC9jb21waWxlci5oIHwgMiArLQ0KPiAgMSBmaWxl
IGNoYW5nZWQsIDEgaW5zZXJ0aW9uKCspLCAxIGRlbGV0aW9uKC0pDQo+IA0KPiBkaWZmIC0tZ2l0
IGEvaW5jbHVkZS9saW51eC9jb21waWxlci5oIGIvaW5jbHVkZS9saW51eC9jb21waWxlci5oDQo+
IGluZGV4IDkyZWYxNjNhNzQ3OS4uYWM0NWY2ZDQwZDM5IDEwMDY0NA0KPiAtLS0gYS9pbmNsdWRl
L2xpbnV4L2NvbXBpbGVyLmgNCj4gKysrIGIvaW5jbHVkZS9saW51eC9jb21waWxlci5oDQo+IEBA
IC0xNTUsNyArMTU1LDcgQEAgdm9pZCBmdHJhY2VfbGlrZWx5X3VwZGF0ZShzdHJ1Y3QgZnRyYWNl
X2xpa2VseV9kYXRhICpmLCBpbnQgdmFsLA0KPiAgCWV4dGVybiB0eXBlb2Yoc3ltKSBzeW07CQkJ
CQlcDQo+ICAJc3RhdGljIGNvbnN0IHVuc2lnbmVkIGxvbmcgX19rZW50cnlfIyNzeW0JCVwNCj4g
IAlfX3VzZWQJCQkJCQkJXA0KPiAtCV9fc2VjdGlvbigiX19fa2VudHJ5IiAiKyIgI3N5bSApCQkJ
XA0KPiArCV9fYXR0cmlidXRlX18oKF9fc2VjdGlvbl9fKCJfX19rZW50cnkrIiAjc3ltKSkpCQlc
DQo+ICAJPSAodW5zaWduZWQgbG9uZykmc3ltOw0KPiAgI2VuZGlmDQoNCkkgZ3Vlc3Mgd2hhdCB0
aGlzIHJlYWxseSB3YW50cyBpczoNCglfX3NlY3Rpb24oX19rZW50cnkrIyNzeW0pDQpidXQgdGhh
dCBnZW5lcmF0ZXMgYW4gZXJyb3IgYmVjYXVzZSB5b3UgY2FuIG9ubHkgdXNlICMjIGJldHdlZW4N
CnZhcmlhYmxlIG5hbWVzLg0KDQpQZXJoYXBzIHNvbWVvbmUgc2hvdWxkbid0IGhhdmUgdHJpZXMg
dG8gYmUgY2xldmVyIGFuZCBub3QgcHV0DQphbiB1bnVzdWFsIGNoYXJhY3RlciBpbiB0aGUgc2Vj
dGlvbiBuYW1lLg0KDQoJRGF2aWQNCg0KLQ0KUmVnaXN0ZXJlZCBBZGRyZXNzIExha2VzaWRlLCBC
cmFtbGV5IFJvYWQsIE1vdW50IEZhcm0sIE1pbHRvbiBLZXluZXMsIE1LMSAxUFQsIFVLDQpSZWdp
c3RyYXRpb24gTm86IDEzOTczODYgKFdhbGVzKQ0K

================================================================================

From: Joe Perches <joe () perches ! com>
To: linux-kernel
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Wed, 30 Sep 2020 15:40:11 +0000
Message-ID: <ffe0224b2dc88e091d4d3bb32ee073ffc0585882.camel () perches ! com>
--------------------

--=-b2mXhRFB+I/U/qMewy+F
Content-Type: text/plain; charset="ISO-8859-1"
Content-Transfer-Encoding: 7bit

On Tue, 2020-09-29 at 13:25 -0700, Nick Desaulniers wrote:
> And I don't remember what ever happened to Joe's script for treewide
> conversion of __section.

Nor do I but here (attached) is the script.

My recollection is there was some problem with mscros
with ## concatenation in some converted uses.


--=-b2mXhRFB+I/U/qMewy+F
Content-Type: application/x-perl; name="convert_section.pl"
Content-Disposition: attachment; filename="convert_section.pl"
Content-Transfer-Encoding: base64

IyBjb252ZXJ0IGxpbnV4LWtlcm5lbCBfX3NlY3Rpb24gdXNlcyBmcm9tIHVucXVvdGVkIHN0cmlu
ZyB0byBxdW90ZWQgc3RyaW5nCiMgY29udmVydCBfX2F0dHJpYnV0ZV9fKChzZWN0aW9uKCJmb28i
KSkpIHRvIF9fc2VjdGlvbigiZm9vIikKIyBjb252ZXJ0IF9fYXR0cmlidXRlX18oKGZvbywgc2Vj
dGlvbj0oImJhciIpLCBiYXopKQojICAgICAgdG8gX19zZWN0aW9uKCJiYXIiKSBhdHRyaWJ1dGUo
KGZvbywgYmF6KSkKIyBjb252ZXJ0IF9fYXR0cmlidXRlX18KCnVzZSBzdHJpY3Q7CgojIHBhdGNo
IGNvbXBpbGVyX2F0dHJpYnV0ZXMuaCB0byByZW1vdmUgcXVvdGluZyBvZiBzZWN0aW9uIG5hbWUK
Cm15ICRyZXN1bHQgPSBxeHtwYXRjaCAtcDEgPDwiRU9GIgogaW5jbHVkZS9saW51eC9jb21waWxl
cl9hdHRyaWJ1dGVzLmggfCAxMiArLS0tLS0tLS0tLS0KIDEgZmlsZSBjaGFuZ2VkLCAxIGluc2Vy
dGlvbigrKSwgMTEgZGVsZXRpb25zKC0pCgpkaWZmIC0tZ2l0IGEvaW5jbHVkZS9saW51eC9jb21w
aWxlcl9hdHRyaWJ1dGVzLmggYi9pbmNsdWRlL2xpbnV4L2NvbXBpbGVyX2F0dHJpYnV0ZXMuaApp
bmRleCA5Y2EwNDBmYTFjYzYuLjg4ZDNlZWExY2JiYSAxMDA2NDQKLS0tIGEvaW5jbHVkZS9saW51
eC9jb21waWxlcl9hdHRyaWJ1dGVzLmgKKysrIGIvaW5jbHVkZS9saW51eC9jb21waWxlcl9hdHRy
aWJ1dGVzLmgKQEAgLTIyNSwyMSArMjI1LDExIEBACiAjZGVmaW5lIF9fcHVyZSAgICAgICAgICAg
ICAgICAgICAgICAgICAgX19hdHRyaWJ1dGVfXygoX19wdXJlX18pKQogCiAvKgotICogTm90ZTog
U2luY2UgdGhpcyBtYWNybyBtYWtlcyB1c2Ugb2YgdGhlICJzdHJpbmdpZmljYXRpb24gb3BlcmF0
b3IiIGAjYCwKLSAqIGEgcXVvdGVkIHN0cmluZyBsaXRlcmFsIHNob3VsZCBub3QgYmUgcGFzc2Vk
IHRvIGl0LiBlZy4gcHJlZmVyOgotICogICAgIF9fc2VjdGlvbiguZm9vKQotICogdG86Ci0gKiAg
ICAgX19zZWN0aW9uKCIuZm9vIikKLSAqIHVubGVzcyB0aGUgc2VjdGlvbiBuYW1lIGlzIGR5bmFt
aWNhbGx5IGJ1aWx0IHVwLCBpbiB3aGljaCBjYXNlIHRoZQotICogdmVyYm9zZSBfX2F0dHJpYnV0
ZV9fKChfX3NlY3Rpb25fXygiLmZvbyIgeCkpKSBzaG91bGQgYmUgcHJlZmVycmVkLgotICoKLSAq
IFNlZSBhbHNvOiBodHRwczovL2J1Z3MubGx2bS5vcmcvc2hvd19idWcuY2dpP2lkPTQyOTUwCi0g
KgogICogICBnY2M6IGh0dHBzOi8vZ2NjLmdudS5vcmcvb25saW5lZG9jcy9nY2MvQ29tbW9uLUZ1
bmN0aW9uLUF0dHJpYnV0ZXMuaHRtbCNpbmRleC1zZWN0aW9uLWZ1bmN0aW9uLWF0dHJpYnV0ZQog
ICogICBnY2M6IGh0dHBzOi8vZ2NjLmdudS5vcmcvb25saW5lZG9jcy9nY2MvQ29tbW9uLVZhcmlh
YmxlLUF0dHJpYnV0ZXMuaHRtbCNpbmRleC1zZWN0aW9uLXZhcmlhYmxlLWF0dHJpYnV0ZQogICog
Y2xhbmc6IGh0dHBzOi8vY2xhbmcubGx2bS5vcmcvZG9jcy9BdHRyaWJ1dGVSZWZlcmVuY2UuaHRt
bCNzZWN0aW9uLWRlY2xzcGVjLWFsbG9jYXRlCiAgKi8KLSNkZWZpbmUgX19zZWN0aW9uKFMpICAg
ICAgICAgICAgICAgICAgICBfX2F0dHJpYnV0ZV9fKChfX3NlY3Rpb25fXygjUykpKQorI2RlZmlu
ZSBfX3NlY3Rpb24oc2VjdGlvbikgICAgICAgICAgICAgIF9fYXR0cmlidXRlX18oKF9fc2VjdGlv
bl9fKHNlY3Rpb24pKSkKIAogLyoKICAqICAgZ2NjOiBodHRwczovL2djYy5nbnUub3JnL29ubGlu
ZWRvY3MvZ2NjL0NvbW1vbi1GdW5jdGlvbi1BdHRyaWJ1dGVzLmh0bWwjaW5kZXgtdW51c2VkLWZ1
bmN0aW9uLWF0dHJpYnV0ZQpFT0Z9OwoKIyBHZXQgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbW9kaWZ5
IChjb250YWlucyBfX3NlY3Rpb24gb3IgX19hdHRyaWJ1dGVfXy4qc2VjdGlvbgojIChpZ25vcmUg
c2NyaXB0cywgdG9vbHMsIHVhcGksIGFuZCBjb21waWxlcl9hdHRyaWJ1dGVzLmgpCgpteSAkb3V0
cHV0ID0gYGdpdCBncmVwIC0tbmFtZS1vbmx5IC1QICIoPzpcXGJfX3NlY3Rpb25cXGJcfFxcYl9f
YXR0cmlidXRlX19cXGIuKnNlY3Rpb24pIiB8IGdyZXAgLXZQICdeKD86aW5jbHVkZS9saW51eC9j
b21waWxlcl9hdHRyaWJ1dGVzXFwuaHxzY3JpcHRzL3x0b29scy98L3VhcGkvKSdgOwpteSBAZmls
ZXMgPSBzcGxpdCgiXG4iLCAkb3V0cHV0KTsKCiMgTW9kaWZ5IGVhY2ggcG9zc2libGUgZmlsZQpm
b3JlYWNoIChAZmlsZXMpIHsKICAgIGNob21wOwogICAgbXkgJGZpbGUgPSAkXzsKCiAgICAjIHJl
YWQgdGhlIG9yaWdpbmFsIGZpbGUKICAgIG9wZW4oRkgsICc8JywgJGZpbGUpIG9yIGRpZSAkITsK
ICAgIG15IEBsaW5lcyA9IDxGSD47CiAgICBjbG9zZSBGSDsKCiAgICAjIHdyaXRlIHRoZSBtb2Rp
ZmllZCBmaWxlIGxpbmUgYnkgbGluZQogICAgb3BlbiAoRkgsICc+JywgJGZpbGUpIG9yIGRpZSAk
ITsKICAgIGZvcmVhY2ggbXkgJGxpbmUgKEBsaW5lcykgewoJY2hvbXAgJGxpbmU7CglteSAkbmV3
bGluZSA9ICRsaW5lOwoKCSMgQ29udmVydCBfX3NlY3Rpb24oZm9vKSB0byBfX3NlY3Rpb24oImZv
byIpCgkjIGlmICJmb28iIHVzZXMgdG9rZW4gcGFzdGluZywgcHJlIGFuZCBwb3N0IHRva2VucyBh
cmUgYWxzbyBxdW90ZWQKCWlmICgkbGluZSA9fiBtL1xiX19zZWN0aW9uXHMqXChccyooPyEiKShb
XlwpXSspXCkvKSB7CgkgICAgbXkgJG9sZHNlY3Rpb24gPSAkMTsKCSAgICBteSAkbmV3c2VjdGlv
biA9ICQxOwoJICAgIGlmICgkb2xkc2VjdGlvbiA9fiAvKC4qKSMjKC4qKSMjKC4qKS8pIHsKCQkk
bmV3c2VjdGlvbiA9ICciJyAuIHRyaW0oJDEpIC4gJyIgIyMgJyAuIHRyaW0oJDIpIC4gJyAjIyAi
JyAuIHRyaW0oJDMpIC4gJyInOwoJICAgIH0gZWxzZSB7CgkJJG5ld3NlY3Rpb24gPSAnIicgLiB0
cmltKCRvbGRzZWN0aW9uKSAuICciJzsKCSAgICB9CgkgICAgJG5ld2xpbmUgPX4gcy9fX3NlY3Rp
b25ccypcKFxzKlxRJG9sZHNlY3Rpb25cRVxzKlwpL19fc2VjdGlvbigkbmV3c2VjdGlvbikvOwoJ
fQoKCSMgY29udmVydCBfX2F0dHJpYnV0ZV9fKChzZWN0aW9uKCJmb28iKSkpIHRvIF9fc2VjdGlv
bigiZm9vIikKCSRuZXdsaW5lID1+IHMvXGJfX2F0dHJpYnV0ZV9fXHMqXChccypcKFxzKl8qc2Vj
dGlvbl8qXHMqXChccyooIlteIl0rIilccypcKVxzKlwpXHMqXCkvX19zZWN0aW9uKCQxKS87CgoJ
IyBjb252ZXJ0IF9fYXR0cmlidXRlX18oKGZvbywgc2VjdGlvbj0oImJhciIpLCBiYXopKQoJIyB0
byBfX3NlY3Rpb24oImJhciIpIGF0dHJpYnV0ZSgoZm9vLCBiYXopKQoJaWYgKCRuZXdsaW5lID1+
IC8oXGJfX2F0dHJpYnV0ZV9fXHMqXChccypcKChbXixfXSspPyhccyosP1xzKl8qc2VjdGlvbl8q
XHMqXChccyooIlteIl0rIilccypcKVxzKiw/XHMqKSguKilccypcKVxzKlwpKS8pIHsKCSAgICBt
eSAkc2VjdGlvbiA9ICQzOwoJICAgIG15ICRjb21tYSA9ICIiOwoJICAgICRjb21tYSA9ICIsICIg
aWYgKCRzZWN0aW9uID1+IC9eXHMqLC8gJiYgJHNlY3Rpb24gPX4gLyxccyokLyk7CgkgICAgJG5l
d2xpbmUgPX4gcy9cUSRzZWN0aW9uXEUvJGNvbW1hLzsKCSAgICAkc2VjdGlvbiA9fiBzL15bXiJd
Ki8vOwoJICAgICRzZWN0aW9uID1+IHMvXigiW14iXSoiKS4qLyQxLzsKCSAgICAkbmV3bGluZSA9
fiBzL1xiX19hdHRyaWJ1dGVfXy9fX3NlY3Rpb24oJHNlY3Rpb24pIF9fYXR0cmlidXRlX18vOwoJ
fQoKCSMgaWYgdGhlIGxpbmUgZW5kZWQgd2l0aCBhIGxpbmUgY29udGludWF0aW9uIFwsIHRyeSB0
byBtb3ZlIHRoZQoJIyBjb250aW51YXRpb24gdG8gdGhlIHNhbWUgbG9jYXRpb24gYnkgcmVtb3Zp
bmcgb3IgYWRkaW5nIHRhYnMKCWlmICgkbGluZSA9fiAvXFwkLykgewoJICAgIG15ICRvbGVuID0g
bGVuZ3RoKGV4cGFuZF90YWJzKCRsaW5lKSk7CgkgICAgbXkgJG5sZW4gPSBsZW5ndGgoZXhwYW5k
X3RhYnMoJG5ld2xpbmUpKTsKCSAgICBpZiAoJG5ld2xpbmUgPX4gL1x0XFwkLykgewoJCWlmICgk
bmxlbiA+ICRvbGVuKSB7CgkJICAgICRuZXdsaW5lID1+IHMvXHRcXCQvXFwvOwoJCX0gZWxzZSB7
CgkJICAgIHdoaWxlICgkbmxlbiA8ICRvbGVuKSB7CgkJCSRuZXdsaW5lID1+IHMvXFwkL1x0XFwv
OwoJCQkkbmxlbiA9IGxlbmd0aChleHBhbmRfdGFicygkbmV3bGluZSkpOwoJCSAgICB9CgkJfQoJ
ICAgIH0KCX0KCXByaW50IEZIICIkbmV3bGluZVxuIjsKICAgIH0KICAgIGNsb3NlIEZIOwp9Cgoj
IEFuZCBnaXQgY29tbWl0IHRoZSBjaGFuZ2VzCiRyZXN1bHQgPSBxeHtnaXQgY29tbWl0IC1hIC0t
YXV0aG9yPSdKb2UgUGVyY2hlcyA8am9lXEBwZXJjaGVzLmNvbT4nIC1GLSA8PCJFT0YiCnRyZWV3
aWRlOiBDb252ZXJ0IG1hY3JvIGFuZCB1c2VzIG9mIF9fc2VjdGlvbihmb28pIHRvIF9fc2VjdGlv
bigiZm9vIikKClVzZSBhIG1vcmUgZ2VuZXJpYyBmb3JtIGZvciBfX3NlY3Rpb24gdGhhdCByZXF1
aXJlcyBxdW90ZXMgdG8gYXZvaWQKY29tcGxpY2F0aW9ucyB3aXRoIGNsYW5nIGFuZCBnY2MgZGlm
ZmVyZW5jZXMuCgpSZW1vdmUgdGhlIHF1b3RlIG9wZXJhdG9yICMgZnJvbSBjb21waWxlcl9hdHRy
aWJ1dGVzLmggX19zZWN0aW9uIG1hY3JvLgoKQ29udmVydCBhbGwgdW5xdW90ZWQgX19zZWN0aW9u
KGZvbykgdXNlcyB0byBxdW90ZWQgX19zZWN0aW9uKCJmb28iKS4KQWxzbyBjb252ZXJ0IF9fYXR0
cmlidXRlX18oKHNlY3Rpb24oImZvbyIpKSkgdXNlcyB0byBfX3NlY3Rpb24oImZvbyIpCmV2ZW4g
aWYgdGhlIF9fYXR0cmlidXRlX18gaGFzIG11bHRpcGxlIGxpc3QgZW50cnkgZm9ybXMuCgpTaWdu
ZWQtb2ZmLWJ5OiBKb2UgUGVyY2hlcyA8am9lXEBwZXJjaGVzLmNvbT4KRU9GCn07CgojIHV0aWxp
dHkgc3Vicm91dGluZXMKc3ViIHRyaW0gewogICAgbXkgKCRzdHJpbmcpID0gQF87CiAgICAkc3Ry
aW5nID1+IHMvXlxzK3xccyskLy9nOwogICAgcmV0dXJuICRzdHJpbmc7Cn0KCnN1YiBleHBhbmRf
dGFicyB7CiAgICBteSAoJHN0cikgPSBAXzsKCiAgICBteSAkcmVzID0gJyc7CiAgICBteSAkbiA9
IDA7CiAgICBmb3IgbXkgJGMgKHNwbGl0KC8vLCAkc3RyKSkgewoJaWYgKCRjIGVxICJcdCIpIHsK
CSAgICAkcmVzIC49ICcgJzsKCSAgICAkbisrOwoJICAgIGZvciAoOyAoJG4gJSA4KSAhPSAwOyAk
bisrKSB7CgkJJHJlcyAuPSAnICc7CgkgICAgfQoJICAgIG5leHQ7Cgl9CgkkcmVzIC49ICRjOwoJ
JG4rKzsKICAgIH0KCiAgICByZXR1cm4gJHJlczsKfQo=


--=-b2mXhRFB+I/U/qMewy+F--

================================================================================

From: Joe Perches <joe () perches ! com>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Wed, 30 Sep 2020 15:40:11 +0000
Message-ID: <ffe0224b2dc88e091d4d3bb32ee073ffc0585882.camel () perches ! com>
--------------------

--=-b2mXhRFB+I/U/qMewy+F
Content-Type: text/plain; charset="ISO-8859-1"
Content-Transfer-Encoding: 7bit

On Tue, 2020-09-29 at 13:25 -0700, Nick Desaulniers wrote:
> And I don't remember what ever happened to Joe's script for treewide
> conversion of __section.

Nor do I but here (attached) is the script.

My recollection is there was some problem with mscros
with ## concatenation in some converted uses.


--=-b2mXhRFB+I/U/qMewy+F
Content-Type: application/x-perl; name="convert_section.pl"
Content-Disposition: attachment; filename="convert_section.pl"
Content-Transfer-Encoding: base64

IyBjb252ZXJ0IGxpbnV4LWtlcm5lbCBfX3NlY3Rpb24gdXNlcyBmcm9tIHVucXVvdGVkIHN0cmlu
ZyB0byBxdW90ZWQgc3RyaW5nCiMgY29udmVydCBfX2F0dHJpYnV0ZV9fKChzZWN0aW9uKCJmb28i
KSkpIHRvIF9fc2VjdGlvbigiZm9vIikKIyBjb252ZXJ0IF9fYXR0cmlidXRlX18oKGZvbywgc2Vj
dGlvbj0oImJhciIpLCBiYXopKQojICAgICAgdG8gX19zZWN0aW9uKCJiYXIiKSBhdHRyaWJ1dGUo
KGZvbywgYmF6KSkKIyBjb252ZXJ0IF9fYXR0cmlidXRlX18KCnVzZSBzdHJpY3Q7CgojIHBhdGNo
IGNvbXBpbGVyX2F0dHJpYnV0ZXMuaCB0byByZW1vdmUgcXVvdGluZyBvZiBzZWN0aW9uIG5hbWUK
Cm15ICRyZXN1bHQgPSBxeHtwYXRjaCAtcDEgPDwiRU9GIgogaW5jbHVkZS9saW51eC9jb21waWxl
cl9hdHRyaWJ1dGVzLmggfCAxMiArLS0tLS0tLS0tLS0KIDEgZmlsZSBjaGFuZ2VkLCAxIGluc2Vy
dGlvbigrKSwgMTEgZGVsZXRpb25zKC0pCgpkaWZmIC0tZ2l0IGEvaW5jbHVkZS9saW51eC9jb21w
aWxlcl9hdHRyaWJ1dGVzLmggYi9pbmNsdWRlL2xpbnV4L2NvbXBpbGVyX2F0dHJpYnV0ZXMuaApp
bmRleCA5Y2EwNDBmYTFjYzYuLjg4ZDNlZWExY2JiYSAxMDA2NDQKLS0tIGEvaW5jbHVkZS9saW51
eC9jb21waWxlcl9hdHRyaWJ1dGVzLmgKKysrIGIvaW5jbHVkZS9saW51eC9jb21waWxlcl9hdHRy
aWJ1dGVzLmgKQEAgLTIyNSwyMSArMjI1LDExIEBACiAjZGVmaW5lIF9fcHVyZSAgICAgICAgICAg
ICAgICAgICAgICAgICAgX19hdHRyaWJ1dGVfXygoX19wdXJlX18pKQogCiAvKgotICogTm90ZTog
U2luY2UgdGhpcyBtYWNybyBtYWtlcyB1c2Ugb2YgdGhlICJzdHJpbmdpZmljYXRpb24gb3BlcmF0
b3IiIGAjYCwKLSAqIGEgcXVvdGVkIHN0cmluZyBsaXRlcmFsIHNob3VsZCBub3QgYmUgcGFzc2Vk
IHRvIGl0LiBlZy4gcHJlZmVyOgotICogICAgIF9fc2VjdGlvbiguZm9vKQotICogdG86Ci0gKiAg
ICAgX19zZWN0aW9uKCIuZm9vIikKLSAqIHVubGVzcyB0aGUgc2VjdGlvbiBuYW1lIGlzIGR5bmFt
aWNhbGx5IGJ1aWx0IHVwLCBpbiB3aGljaCBjYXNlIHRoZQotICogdmVyYm9zZSBfX2F0dHJpYnV0
ZV9fKChfX3NlY3Rpb25fXygiLmZvbyIgeCkpKSBzaG91bGQgYmUgcHJlZmVycmVkLgotICoKLSAq
IFNlZSBhbHNvOiBodHRwczovL2J1Z3MubGx2bS5vcmcvc2hvd19idWcuY2dpP2lkPTQyOTUwCi0g
KgogICogICBnY2M6IGh0dHBzOi8vZ2NjLmdudS5vcmcvb25saW5lZG9jcy9nY2MvQ29tbW9uLUZ1
bmN0aW9uLUF0dHJpYnV0ZXMuaHRtbCNpbmRleC1zZWN0aW9uLWZ1bmN0aW9uLWF0dHJpYnV0ZQog
ICogICBnY2M6IGh0dHBzOi8vZ2NjLmdudS5vcmcvb25saW5lZG9jcy9nY2MvQ29tbW9uLVZhcmlh
YmxlLUF0dHJpYnV0ZXMuaHRtbCNpbmRleC1zZWN0aW9uLXZhcmlhYmxlLWF0dHJpYnV0ZQogICog
Y2xhbmc6IGh0dHBzOi8vY2xhbmcubGx2bS5vcmcvZG9jcy9BdHRyaWJ1dGVSZWZlcmVuY2UuaHRt
bCNzZWN0aW9uLWRlY2xzcGVjLWFsbG9jYXRlCiAgKi8KLSNkZWZpbmUgX19zZWN0aW9uKFMpICAg
ICAgICAgICAgICAgICAgICBfX2F0dHJpYnV0ZV9fKChfX3NlY3Rpb25fXygjUykpKQorI2RlZmlu
ZSBfX3NlY3Rpb24oc2VjdGlvbikgICAgICAgICAgICAgIF9fYXR0cmlidXRlX18oKF9fc2VjdGlv
bl9fKHNlY3Rpb24pKSkKIAogLyoKICAqICAgZ2NjOiBodHRwczovL2djYy5nbnUub3JnL29ubGlu
ZWRvY3MvZ2NjL0NvbW1vbi1GdW5jdGlvbi1BdHRyaWJ1dGVzLmh0bWwjaW5kZXgtdW51c2VkLWZ1
bmN0aW9uLWF0dHJpYnV0ZQpFT0Z9OwoKIyBHZXQgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbW9kaWZ5
IChjb250YWlucyBfX3NlY3Rpb24gb3IgX19hdHRyaWJ1dGVfXy4qc2VjdGlvbgojIChpZ25vcmUg
c2NyaXB0cywgdG9vbHMsIHVhcGksIGFuZCBjb21waWxlcl9hdHRyaWJ1dGVzLmgpCgpteSAkb3V0
cHV0ID0gYGdpdCBncmVwIC0tbmFtZS1vbmx5IC1QICIoPzpcXGJfX3NlY3Rpb25cXGJcfFxcYl9f
YXR0cmlidXRlX19cXGIuKnNlY3Rpb24pIiB8IGdyZXAgLXZQICdeKD86aW5jbHVkZS9saW51eC9j
b21waWxlcl9hdHRyaWJ1dGVzXFwuaHxzY3JpcHRzL3x0b29scy98L3VhcGkvKSdgOwpteSBAZmls
ZXMgPSBzcGxpdCgiXG4iLCAkb3V0cHV0KTsKCiMgTW9kaWZ5IGVhY2ggcG9zc2libGUgZmlsZQpm
b3JlYWNoIChAZmlsZXMpIHsKICAgIGNob21wOwogICAgbXkgJGZpbGUgPSAkXzsKCiAgICAjIHJl
YWQgdGhlIG9yaWdpbmFsIGZpbGUKICAgIG9wZW4oRkgsICc8JywgJGZpbGUpIG9yIGRpZSAkITsK
ICAgIG15IEBsaW5lcyA9IDxGSD47CiAgICBjbG9zZSBGSDsKCiAgICAjIHdyaXRlIHRoZSBtb2Rp
ZmllZCBmaWxlIGxpbmUgYnkgbGluZQogICAgb3BlbiAoRkgsICc+JywgJGZpbGUpIG9yIGRpZSAk
ITsKICAgIGZvcmVhY2ggbXkgJGxpbmUgKEBsaW5lcykgewoJY2hvbXAgJGxpbmU7CglteSAkbmV3
bGluZSA9ICRsaW5lOwoKCSMgQ29udmVydCBfX3NlY3Rpb24oZm9vKSB0byBfX3NlY3Rpb24oImZv
byIpCgkjIGlmICJmb28iIHVzZXMgdG9rZW4gcGFzdGluZywgcHJlIGFuZCBwb3N0IHRva2VucyBh
cmUgYWxzbyBxdW90ZWQKCWlmICgkbGluZSA9fiBtL1xiX19zZWN0aW9uXHMqXChccyooPyEiKShb
XlwpXSspXCkvKSB7CgkgICAgbXkgJG9sZHNlY3Rpb24gPSAkMTsKCSAgICBteSAkbmV3c2VjdGlv
biA9ICQxOwoJICAgIGlmICgkb2xkc2VjdGlvbiA9fiAvKC4qKSMjKC4qKSMjKC4qKS8pIHsKCQkk
bmV3c2VjdGlvbiA9ICciJyAuIHRyaW0oJDEpIC4gJyIgIyMgJyAuIHRyaW0oJDIpIC4gJyAjIyAi
JyAuIHRyaW0oJDMpIC4gJyInOwoJICAgIH0gZWxzZSB7CgkJJG5ld3NlY3Rpb24gPSAnIicgLiB0
cmltKCRvbGRzZWN0aW9uKSAuICciJzsKCSAgICB9CgkgICAgJG5ld2xpbmUgPX4gcy9fX3NlY3Rp
b25ccypcKFxzKlxRJG9sZHNlY3Rpb25cRVxzKlwpL19fc2VjdGlvbigkbmV3c2VjdGlvbikvOwoJ
fQoKCSMgY29udmVydCBfX2F0dHJpYnV0ZV9fKChzZWN0aW9uKCJmb28iKSkpIHRvIF9fc2VjdGlv
bigiZm9vIikKCSRuZXdsaW5lID1+IHMvXGJfX2F0dHJpYnV0ZV9fXHMqXChccypcKFxzKl8qc2Vj
dGlvbl8qXHMqXChccyooIlteIl0rIilccypcKVxzKlwpXHMqXCkvX19zZWN0aW9uKCQxKS87CgoJ
IyBjb252ZXJ0IF9fYXR0cmlidXRlX18oKGZvbywgc2VjdGlvbj0oImJhciIpLCBiYXopKQoJIyB0
byBfX3NlY3Rpb24oImJhciIpIGF0dHJpYnV0ZSgoZm9vLCBiYXopKQoJaWYgKCRuZXdsaW5lID1+
IC8oXGJfX2F0dHJpYnV0ZV9fXHMqXChccypcKChbXixfXSspPyhccyosP1xzKl8qc2VjdGlvbl8q
XHMqXChccyooIlteIl0rIilccypcKVxzKiw/XHMqKSguKilccypcKVxzKlwpKS8pIHsKCSAgICBt
eSAkc2VjdGlvbiA9ICQzOwoJICAgIG15ICRjb21tYSA9ICIiOwoJICAgICRjb21tYSA9ICIsICIg
aWYgKCRzZWN0aW9uID1+IC9eXHMqLC8gJiYgJHNlY3Rpb24gPX4gLyxccyokLyk7CgkgICAgJG5l
d2xpbmUgPX4gcy9cUSRzZWN0aW9uXEUvJGNvbW1hLzsKCSAgICAkc2VjdGlvbiA9fiBzL15bXiJd
Ki8vOwoJICAgICRzZWN0aW9uID1+IHMvXigiW14iXSoiKS4qLyQxLzsKCSAgICAkbmV3bGluZSA9
fiBzL1xiX19hdHRyaWJ1dGVfXy9fX3NlY3Rpb24oJHNlY3Rpb24pIF9fYXR0cmlidXRlX18vOwoJ
fQoKCSMgaWYgdGhlIGxpbmUgZW5kZWQgd2l0aCBhIGxpbmUgY29udGludWF0aW9uIFwsIHRyeSB0
byBtb3ZlIHRoZQoJIyBjb250aW51YXRpb24gdG8gdGhlIHNhbWUgbG9jYXRpb24gYnkgcmVtb3Zp
bmcgb3IgYWRkaW5nIHRhYnMKCWlmICgkbGluZSA9fiAvXFwkLykgewoJICAgIG15ICRvbGVuID0g
bGVuZ3RoKGV4cGFuZF90YWJzKCRsaW5lKSk7CgkgICAgbXkgJG5sZW4gPSBsZW5ndGgoZXhwYW5k
X3RhYnMoJG5ld2xpbmUpKTsKCSAgICBpZiAoJG5ld2xpbmUgPX4gL1x0XFwkLykgewoJCWlmICgk
bmxlbiA+ICRvbGVuKSB7CgkJICAgICRuZXdsaW5lID1+IHMvXHRcXCQvXFwvOwoJCX0gZWxzZSB7
CgkJICAgIHdoaWxlICgkbmxlbiA8ICRvbGVuKSB7CgkJCSRuZXdsaW5lID1+IHMvXFwkL1x0XFwv
OwoJCQkkbmxlbiA9IGxlbmd0aChleHBhbmRfdGFicygkbmV3bGluZSkpOwoJCSAgICB9CgkJfQoJ
ICAgIH0KCX0KCXByaW50IEZIICIkbmV3bGluZVxuIjsKICAgIH0KICAgIGNsb3NlIEZIOwp9Cgoj
IEFuZCBnaXQgY29tbWl0IHRoZSBjaGFuZ2VzCiRyZXN1bHQgPSBxeHtnaXQgY29tbWl0IC1hIC0t
YXV0aG9yPSdKb2UgUGVyY2hlcyA8am9lXEBwZXJjaGVzLmNvbT4nIC1GLSA8PCJFT0YiCnRyZWV3
aWRlOiBDb252ZXJ0IG1hY3JvIGFuZCB1c2VzIG9mIF9fc2VjdGlvbihmb28pIHRvIF9fc2VjdGlv
bigiZm9vIikKClVzZSBhIG1vcmUgZ2VuZXJpYyBmb3JtIGZvciBfX3NlY3Rpb24gdGhhdCByZXF1
aXJlcyBxdW90ZXMgdG8gYXZvaWQKY29tcGxpY2F0aW9ucyB3aXRoIGNsYW5nIGFuZCBnY2MgZGlm
ZmVyZW5jZXMuCgpSZW1vdmUgdGhlIHF1b3RlIG9wZXJhdG9yICMgZnJvbSBjb21waWxlcl9hdHRy
aWJ1dGVzLmggX19zZWN0aW9uIG1hY3JvLgoKQ29udmVydCBhbGwgdW5xdW90ZWQgX19zZWN0aW9u
KGZvbykgdXNlcyB0byBxdW90ZWQgX19zZWN0aW9uKCJmb28iKS4KQWxzbyBjb252ZXJ0IF9fYXR0
cmlidXRlX18oKHNlY3Rpb24oImZvbyIpKSkgdXNlcyB0byBfX3NlY3Rpb24oImZvbyIpCmV2ZW4g
aWYgdGhlIF9fYXR0cmlidXRlX18gaGFzIG11bHRpcGxlIGxpc3QgZW50cnkgZm9ybXMuCgpTaWdu
ZWQtb2ZmLWJ5OiBKb2UgUGVyY2hlcyA8am9lXEBwZXJjaGVzLmNvbT4KRU9GCn07CgojIHV0aWxp
dHkgc3Vicm91dGluZXMKc3ViIHRyaW0gewogICAgbXkgKCRzdHJpbmcpID0gQF87CiAgICAkc3Ry
aW5nID1+IHMvXlxzK3xccyskLy9nOwogICAgcmV0dXJuICRzdHJpbmc7Cn0KCnN1YiBleHBhbmRf
dGFicyB7CiAgICBteSAoJHN0cikgPSBAXzsKCiAgICBteSAkcmVzID0gJyc7CiAgICBteSAkbiA9
IDA7CiAgICBmb3IgbXkgJGMgKHNwbGl0KC8vLCAkc3RyKSkgewoJaWYgKCRjIGVxICJcdCIpIHsK
CSAgICAkcmVzIC49ICcgJzsKCSAgICAkbisrOwoJICAgIGZvciAoOyAoJG4gJSA4KSAhPSAwOyAk
bisrKSB7CgkJJHJlcyAuPSAnICc7CgkgICAgfQoJICAgIG5leHQ7Cgl9CgkkcmVzIC49ICRjOwoJ
JG4rKzsKICAgIH0KCiAgICByZXR1cm4gJHJlczsKfQo=


--=-b2mXhRFB+I/U/qMewy+F--

================================================================================

From: Joe Perches <joe () perches ! com>
To: linux-sparse
Subject: Re: [PATCH] compiler.h: avoid escaped section names
Date: Wed, 30 Sep 2020 18:33:59 +0000
Message-ID: <0e582a7f5144a33f465978d97701f9b3dcc377f3.camel () perches ! com>
--------------------

--=-aBohwTz58WA21h5mfNas
Content-Type: text/plain; charset="ISO-8859-1"
Content-Transfer-Encoding: 7bit

On Wed, 2020-09-30 at 08:40 -0700, Joe Perches wrote:
> On Tue, 2020-09-29 at 13:25 -0700, Nick Desaulniers wrote:
> > And I don't remember what ever happened to Joe's script for treewide
> > conversion of __section.
> 
> Nor do I but here (attached) is the script.
> 
> My recollection is there was some problem with mscros
> with ## concatenation in some converted uses.

I believe I have it sorted now and I've attached
a new version of the script.

It runs against -next (or any other tree) and
produces a single commit.

It converts all the various uses of
	__attribute__((section(<foo>)))
to
	__section("<foo>")

changes the various macros with token pasting uses
I believe appropriately as well.

Please give it a spin.

There were 4 problems as below.

With these 4 items fixed, the build works (seems to at least)

1:  compiler_attributes.h needed to unquote the __section__(#S)
    the old automated patch didn't apply as the file had changed

diff --git a/include/linux/compiler_attributes.h b/include/linux/compiler_attri>
index ea7b756b1c8f..b6fef9033c0b 100644
--- a/include/linux/compiler_attributes.h
+++ b/include/linux/compiler_attributes.h
@@ -254,7 +254,7 @@
  *   gcc: https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#i>
  * clang: https://clang.llvm.org/docs/AttributeReference.html#section-declspec>
  */
-#define __section(S)                    __attribute__((__section__(#S)))
+#define __section(section)              __attribute__((__section__(section)))

2:  The script needed to use different token pasting for
    __section(foo##bar##baz)

    The script converted this to
	__section("foo" ## bar ## "baz")
    instead this needed to be
	__section("foo" #bar "baz")

3:  scripts/mod/modpost.c needed quoting of its internal __section uses:

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 69341b36f271..f882ce0d9327 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2254,7 +2254,7 @@ static void add_header(struct buffer *b, struct module *mod)
        buf_printf(b, "MODULE_INFO(name, KBUILD_MODNAME);\n");
        buf_printf(b, "\n");
        buf_printf(b, "__visible struct module __this_module\n");
-       buf_printf(b, "__section(.gnu.linkonce.this_module) = {\n");
+       buf_printf(b, "__section(\".gnu.linkonce.this_module\") = {\n");
        buf_printf(b, "\t.name = KBUILD_MODNAME,\n");
        if (mod->has_init)
                buf_printf(b, "\t.init = init_module,\n");
@@ -2308,7 +2308,7 @@ static int add_versions(struct buffer *b, struct module *mod)
 
        buf_printf(b, "\n");
        buf_printf(b, "static const struct modversion_info ____versions[]\n");
-       buf_printf(b, "__used __section(__versions) = {\n");
+       buf_printf(b, "__used __section(\"__versions\") = {\n");

4: tools/ was excluded, but now needs conversion

 tools/include/linux/objtool.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/include/linux/objtool.h b/tools/include/linux/objtool.h
index ab82c793c897..577f51436cf9 100644
--- a/tools/include/linux/objtool.h
+++ b/tools/include/linux/objtool.h
@@ -60,7 +60,7 @@ struct unwind_hint {
  * For more information, see tools/objtool/Documentation/stack-validation.txt.
  */
 #define STACK_FRAME_NON_STANDARD(func) \
-	static void __used __section(.discard.func_stack_frame_non_standard) \
+	static void __used __section(".discard.func_stack_frame_non_standard") \
 		*__func_stack_frame_non_standard_##func = func
 
 #else /* __ASSEMBLY__ */

--=-aBohwTz58WA21h5mfNas
Content-Type: application/x-perl; name="convert_section.pl"
Content-Disposition: attachment; filename="convert_section.pl"
Content-Transfer-Encoding: base64

IyEvdXNyL2Jpbi9lbnYgcGVybAoKIyBjb252ZXJ0IGxpbnV4LWtlcm5lbCBfX3NlY3Rpb24gdXNl
cyBmcm9tIHVucXVvdGVkIHN0cmluZyB0byBxdW90ZWQgc3RyaW5nCiMgY29udmVydCBfX2F0dHJp
YnV0ZV9fKChzZWN0aW9uKCJmb28iKSkpIHRvIF9fc2VjdGlvbigiZm9vIikKIyBjb252ZXJ0IF9f
YXR0cmlidXRlX18oKGZvbywgc2VjdGlvbj0oImJhciIpLCBiYXopKQojICAgICAgdG8gX19zZWN0
aW9uKCJiYXIiKSBhdHRyaWJ1dGUoKGZvbywgYmF6KSkKIyBjb252ZXJ0IF9fYXR0cmlidXRlX18K
CnVzZSBzdHJpY3Q7CgojIHBhdGNoIGNvbXBpbGVyX2F0dHJpYnV0ZXMuaCB0byByZW1vdmUgcXVv
dGluZyBvZiBzZWN0aW9uIG5hbWUKCm15ICRyZXN1bHQgPSBgcGF0Y2ggLXAxIDw8IkVPRiIKIGlu
Y2x1ZGUvbGludXgvY29tcGlsZXJfYXR0cmlidXRlcy5oIHwgMiArLQogMSBmaWxlIGNoYW5nZWQs
IDEgaW5zZXJ0aW9uKCspLCAxIGRlbGV0aW9uKC0pCgpkaWZmIC0tZ2l0IGEvaW5jbHVkZS9saW51
eC9jb21waWxlcl9hdHRyaWJ1dGVzLmggYi9pbmNsdWRlL2xpbnV4L2NvbXBpbGVyX2F0dHJpYnV0
ZXMuaAppbmRleCBlYTdiNzU2YjFjOGYuLmIyYTNmNGY2NDFhNyAxMDA2NDQKLS0tIGEvaW5jbHVk
ZS9saW51eC9jb21waWxlcl9hdHRyaWJ1dGVzLmgKKysrIGIvaW5jbHVkZS9saW51eC9jb21waWxl
cl9hdHRyaWJ1dGVzLmgKQEAgLTI1NCw3ICsyNTQsNyBAQAogICogICBnY2M6IGh0dHBzOi8vZ2Nj
LmdudS5vcmcvb25saW5lZG9jcy9nY2MvQ29tbW9uLVZhcmlhYmxlLUF0dHJpYnV0ZXMuaHRtbCNp
bmRleC1zZWN0aW9uLXZhcmlhYmxlLWF0dHJpYnV0ZQogICogY2xhbmc6IGh0dHBzOi8vY2xhbmcu
bGx2bS5vcmcvZG9jcy9BdHRyaWJ1dGVSZWZlcmVuY2UuaHRtbCNzZWN0aW9uLWRlY2xzcGVjLWFs
bG9jYXRlCiAgKi8KLSNkZWZpbmUgX19zZWN0aW9uKFMpICAgICAgICAgICAgICAgICAgICBfX2F0
dHJpYnV0ZV9fKChfX3NlY3Rpb25fXygjUykpKQorI2RlZmluZSBfX3NlY3Rpb24oc2VjdGlvbikg
ICAgICAgICAgICAgIF9fYXR0cmlidXRlX18oKF9fc2VjdGlvbl9fKHNlY3Rpb24pKSkKIAogLyoK
ICAqICAgZ2NjOiBodHRwczovL2djYy5nbnUub3JnL29ubGluZWRvY3MvZ2NjL0NvbW1vbi1GdW5j
dGlvbi1BdHRyaWJ1dGVzLmh0bWwjaW5kZXgtdW51c2VkLWZ1bmN0aW9uLWF0dHJpYnV0ZQpFT0Zg
OwoKIyBwYXRjaCBzY3JpcHRzL21vZC9tb2Rwb3N0LmMgdG8gYWRkIHF1b3Rpbmcgb2Ygc2VjdGlv
biBuYW1lCgpteSAkcmVzdWx0ID0gYHBhdGNoIC1wMSA8PCJFT0YiCiBzY3JpcHRzL21vZC9tb2Rw
b3N0LmMgfCA0ICsrLS0KIDEgZmlsZSBjaGFuZ2VkLCAyIGluc2VydGlvbnMoKyksIDIgZGVsZXRp
b25zKC0pCgpkaWZmIC0tZ2l0IGEvc2NyaXB0cy9tb2QvbW9kcG9zdC5jIGIvc2NyaXB0cy9tb2Qv
bW9kcG9zdC5jCmluZGV4IDY5MzQxYjM2ZjI3MS4uZjg4MmNlMGQ5MzI3IDEwMDY0NAotLS0gYS9z
Y3JpcHRzL21vZC9tb2Rwb3N0LmMKKysrIGIvc2NyaXB0cy9tb2QvbW9kcG9zdC5jCkBAIC0yMjU0
LDcgKzIyNTQsNyBAQCBzdGF0aWMgdm9pZCBhZGRfaGVhZGVyKHN0cnVjdCBidWZmZXIgKmIsIHN0
cnVjdCBtb2R1bGUgKm1vZCkKIAlidWZfcHJpbnRmKGIsICJNT0RVTEVfSU5GTyhuYW1lLCBLQlVJ
TERfTU9ETkFNRSk7XFxuIik7CiAJYnVmX3ByaW50ZihiLCAiXFxuIik7CiAJYnVmX3ByaW50Zihi
LCAiX192aXNpYmxlIHN0cnVjdCBtb2R1bGUgX190aGlzX21vZHVsZVxcbiIpOwotCWJ1Zl9wcmlu
dGYoYiwgIl9fc2VjdGlvbiguZ251LmxpbmtvbmNlLnRoaXNfbW9kdWxlKSA9IHtcXG4iKTsKKwli
dWZfcHJpbnRmKGIsICJfX3NlY3Rpb24oXFwiLmdudS5saW5rb25jZS50aGlzX21vZHVsZVxcIikg
PSB7XFxuIik7CiAJYnVmX3ByaW50ZihiLCAiXFx0Lm5hbWUgPSBLQlVJTERfTU9ETkFNRSxcXG4i
KTsKIAlpZiAobW9kLT5oYXNfaW5pdCkKIAkJYnVmX3ByaW50ZihiLCAiXFx0LmluaXQgPSBpbml0
X21vZHVsZSxcXG4iKTsKQEAgLTIzMDgsNyArMjMwOCw3IEBAIHN0YXRpYyBpbnQgYWRkX3ZlcnNp
b25zKHN0cnVjdCBidWZmZXIgKmIsIHN0cnVjdCBtb2R1bGUgKm1vZCkKIAogCWJ1Zl9wcmludGYo
YiwgIlxcbiIpOwogCWJ1Zl9wcmludGYoYiwgInN0YXRpYyBjb25zdCBzdHJ1Y3QgbW9kdmVyc2lv
bl9pbmZvIF9fX192ZXJzaW9uc1tdXFxuIik7Ci0JYnVmX3ByaW50ZihiLCAiX191c2VkIF9fc2Vj
dGlvbihfX3ZlcnNpb25zKSA9IHtcXG4iKTsKKwlidWZfcHJpbnRmKGIsICJfX3VzZWQgX19zZWN0
aW9uKFxcIl9fdmVyc2lvbnNcXCIpID0ge1xcbiIpOwogCiAJZm9yIChzID0gbW9kLT51bnJlczsg
czsgcyA9IHMtPm5leHQpIHsKIAkJaWYgKCFzLT5tb2R1bGUpCkVPRmA7CgojIEdldCB0aGUgbGlz
dCBvZiBmaWxlcyB0byBtb2RpZnkgKGNvbnRhaW5zIF9fc2VjdGlvbiBvciBfX2F0dHJpYnV0ZV9f
LipzZWN0aW9uCiMgKGlnbm9yZSBzY3JpcHRzLCB0b29scywgdWFwaSwgYW5kIGNvbXBpbGVyX2F0
dHJpYnV0ZXMuaCkKCm15ICRvdXRwdXQgPSBgZ2l0IGdyZXAgLS1uYW1lLW9ubHkgLVAgIig/Olxc
Yl9fc2VjdGlvblxcYlx8XFxiX19hdHRyaWJ1dGVfX1xcYi4qc2VjdGlvbikiIHwgZ3JlcCAtdlAg
J14oPzppbmNsdWRlL2xpbnV4L2NvbXBpbGVyX2F0dHJpYnV0ZXNcXC5ofHNjcmlwdHMvfHRvb2xz
L3wvdWFwaS8pJ2A7Cm15IEBmaWxlcyA9IHNwbGl0KCJcbiIsICRvdXRwdXQpOwojIEFkZCB0aGUg
b25seSBmaWxlIGluIHRvb2xzIHRoYXQgbmVlZHMgY29udmVyc2lvbgpwdXNoIChAZmlsZXMsICJ0
b29scy9pbmNsdWRlL2xpbnV4L29ianRvb2wuaCIpOwoKIyBNb2RpZnkgZWFjaCBwb3NzaWJsZSBm
aWxlCmZvcmVhY2ggKEBmaWxlcykgewogICAgY2hvbXA7CiAgICBteSAkZmlsZSA9ICRfOwoKICAg
ICMgcmVhZCB0aGUgb3JpZ2luYWwgZmlsZQogICAgb3BlbihGSCwgJzwnLCAkZmlsZSkgb3IgZGll
ICQhOwogICAgbXkgQGxpbmVzID0gPEZIPjsKICAgIGNsb3NlIEZIOwoKICAgICMgd3JpdGUgdGhl
IG1vZGlmaWVkIGZpbGUgbGluZSBieSBsaW5lCiAgICBvcGVuIChGSCwgJz4nLCAkZmlsZSkgb3Ig
ZGllICQhOwogICAgZm9yZWFjaCBteSAkbGluZSAoQGxpbmVzKSB7CgljaG9tcCAkbGluZTsKCW15
ICRuZXdsaW5lID0gJGxpbmU7CgoJIyBDb252ZXJ0IF9fc2VjdGlvbihmb28pIHRvIF9fc2VjdGlv
bigiZm9vIikKCSMgaWYgImZvbyIgdXNlcyBtdWx0aXBsZSB0b2tlbiBwYXN0aW5nLAoJIyAgIHBy
ZSBhbmQgcG9zdCB0b2tlbnMgcmVtb3ZlZCBhbmQgYSBzaW5nbGUgIyBpcyB1c2VkIHRoZW4gIiAi
IGFkZGVkCgkjICAgZS5nLjogIGZvbyAjIyBiYXIgIyMgYmF6IGJlY29tZXMgImZvbyIgI2JhciAi
YmF6IgoJaWYgKCRsaW5lID1+IG0vXGJfX3NlY3Rpb25ccypcKFxzKig/ISIpKFteXCldKylcKS8p
IHsKCSAgICBteSAkb2xkc2VjdGlvbiA9ICQxOwoJICAgIG15ICRuZXdzZWN0aW9uID0gJDE7Cgkg
ICAgaWYgKCRvbGRzZWN0aW9uID1+IC8oLiopIyMoLiopIyMoLiopLykgewoJCSRuZXdzZWN0aW9u
ID0gJyInIC4gdHJpbSgkMSkgLiAnIiAjJyAuIHRyaW0oJDIpIC4gJyAiJyAuIHRyaW0oJDMpIC4g
JyInOwoJICAgIH0gZWxzZSB7CgkJJG5ld3NlY3Rpb24gPSAnIicgLiB0cmltKCRvbGRzZWN0aW9u
KSAuICciJzsKCSAgICB9CgkgICAgJG5ld2xpbmUgPX4gcy9fX3NlY3Rpb25ccypcKFxzKlxRJG9s
ZHNlY3Rpb25cRVxzKlwpL19fc2VjdGlvbigkbmV3c2VjdGlvbikvOwoJfQoKCSMgY29udmVydCBf
X2F0dHJpYnV0ZV9fKChzZWN0aW9uKCJmb28iKSkpIHRvIF9fc2VjdGlvbigiZm9vIikKCSRuZXds
aW5lID1+IHMvXGJfX2F0dHJpYnV0ZV9fXHMqXChccypcKFxzKl8qc2VjdGlvbl8qXHMqXChccyoo
IlteIl0rIilccypcKVxzKlwpXHMqXCkvX19zZWN0aW9uKCQxKS87CgoJIyBjb252ZXJ0IF9fYXR0
cmlidXRlX18oKGZvbywgc2VjdGlvbj0oImJhciIpLCBiYXopKQoJIyB0byBfX3NlY3Rpb24oImJh
ciIpIGF0dHJpYnV0ZSgoZm9vLCBiYXopKQoJaWYgKCRuZXdsaW5lID1+IC8oXGJfX2F0dHJpYnV0
ZV9fXHMqXChccypcKChbXixfXSspPyhccyosP1xzKl8qc2VjdGlvbl8qXHMqXChccyooIlteIl0r
IilccypcKVxzKiw/XHMqKSguKilccypcKVxzKlwpKS8pIHsKCSAgICBteSAkc2VjdGlvbiA9ICQz
OwoJICAgIG15ICRjb21tYSA9ICIiOwoJICAgICRjb21tYSA9ICIsICIgaWYgKCRzZWN0aW9uID1+
IC9eXHMqLC8gJiYgJHNlY3Rpb24gPX4gLyxccyokLyk7CgkgICAgJG5ld2xpbmUgPX4gcy9cUSRz
ZWN0aW9uXEUvJGNvbW1hLzsKCSAgICAkc2VjdGlvbiA9fiBzL15bXiJdKi8vOwoJICAgICRzZWN0
aW9uID1+IHMvXigiW14iXSoiKS4qLyQxLzsKCSAgICAkbmV3bGluZSA9fiBzL1xiX19hdHRyaWJ1
dGVfXy9fX3NlY3Rpb24oJHNlY3Rpb24pIF9fYXR0cmlidXRlX18vOwoJfQoKCSMgaWYgdGhlIGxp
bmUgZW5kZWQgd2l0aCBhIGxpbmUgY29udGludWF0aW9uIFwsIHRyeSB0byBtb3ZlIHRoZQoJIyBj
b250aW51YXRpb24gdG8gdGhlIHNhbWUgbG9jYXRpb24gYnkgcmVtb3Zpbmcgb3IgYWRkaW5nIHRh
YnMKCWlmICgkbGluZSA9fiAvXFwkLykgewoJICAgIG15ICRvbGVuID0gbGVuZ3RoKGV4cGFuZF90
YWJzKCRsaW5lKSk7CgkgICAgbXkgJG5sZW4gPSBsZW5ndGgoZXhwYW5kX3RhYnMoJG5ld2xpbmUp
KTsKCSAgICBpZiAoJG5ld2xpbmUgPX4gL1x0XFwkLykgewoJCWlmICgkbmxlbiA+ICRvbGVuKSB7
CgkJICAgICRuZXdsaW5lID1+IHMvXHRcXCQvXFwvOwoJCX0gZWxzZSB7CgkJICAgIHdoaWxlICgk
bmxlbiA8ICRvbGVuKSB7CgkJCSRuZXdsaW5lID1+IHMvXFwkL1x0XFwvOwoJCQkkbmxlbiA9IGxl
bmd0aChleHBhbmRfdGFicygkbmV3bGluZSkpOwoJCSAgICB9CgkJfQoJICAgIH0KCX0KCXByaW50
IEZIICIkbmV3bGluZVxuIjsKICAgIH0KICAgIGNsb3NlIEZIOwp9CgojIEFuZCBnaXQgY29tbWl0
IHRoZSBjaGFuZ2VzCiRyZXN1bHQgPSBxeHtnaXQgY29tbWl0IC1hIC0tYXV0aG9yPSdKb2UgUGVy
Y2hlcyA8am9lXEBwZXJjaGVzLmNvbT4nIC1GLSA8PCJFT0YiCnRyZWV3aWRlOiBDb252ZXJ0IG1h
Y3JvIGFuZCB1c2VzIG9mIF9fc2VjdGlvbihmb28pIHRvIF9fc2VjdGlvbigiZm9vIikKClVzZSBh
IG1vcmUgZ2VuZXJpYyBmb3JtIGZvciBfX3NlY3Rpb24gdGhhdCByZXF1aXJlcyBxdW90ZXMgdG8g
YXZvaWQKY29tcGxpY2F0aW9ucyB3aXRoIGNsYW5nIGFuZCBnY2MgZGlmZmVyZW5jZXMuCgpSZW1v
dmUgdGhlIHF1b3RlIG9wZXJhdG9yICMgZnJvbSBjb21waWxlcl9hdHRyaWJ1dGVzLmggX19zZWN0
aW9uIG1hY3JvLgoKQ29udmVydCBhbGwgdW5xdW90ZWQgX19zZWN0aW9uKGZvbykgdXNlcyB0byBx
dW90ZWQgX19zZWN0aW9uKCJmb28iKS4KQWxzbyBjb252ZXJ0IF9fYXR0cmlidXRlX18oKHNlY3Rp
b24oImZvbyIpKSkgdXNlcyB0byBfX3NlY3Rpb24oImZvbyIpCmV2ZW4gaWYgdGhlIF9fYXR0cmli
dXRlX18gaGFzIG11bHRpcGxlIGxpc3QgZW50cnkgZm9ybXMuCgpTaWduZWQtb2ZmLWJ5OiBKb2Ug
UGVyY2hlcyA8am9lXEBwZXJjaGVzLmNvbT4KRU9GCn07CgojIHV0aWxpdHkgc3Vicm91dGluZXMK
c3ViIHRyaW0gewogICAgbXkgKCRzdHJpbmcpID0gQF87CiAgICAkc3RyaW5nID1+IHMvXlxzK3xc
cyskLy9nOwogICAgcmV0dXJuICRzdHJpbmc7Cn0KCnN1YiBleHBhbmRfdGFicyB7CiAgICBteSAo
JHN0cikgPSBAXzsKCiAgICBteSAkcmVzID0gJyc7CiAgICBteSAkbiA9IDA7CiAgICBmb3IgbXkg
JGMgKHNwbGl0KC8vLCAkc3RyKSkgewoJaWYgKCRjIGVxICJcdCIpIHsKCSAgICAkcmVzIC49ICcg
JzsKCSAgICAkbisrOwoJICAgIGZvciAoOyAoJG4gJSA4KSAhPSAwOyAkbisrKSB7CgkJJHJlcyAu
PSAnICc7CgkgICAgfQoJICAgIG5leHQ7Cgl9CgkkcmVzIC49ICRjOwoJJG4rKzsKICAgIH0KCiAg
ICByZXR1cm4gJHJlczsKfQo=


--=-aBohwTz58WA21h5mfNas--

================================================================================


################################################################################

=== Thread: [PATCH] correct sparcv9 defines ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] correct sparcv9 defines
Date: Tue, 21 Jan 2020 00:13:22 +0000
Message-ID: <20200121001322.zikj2xsacqt765fi () ltop ! local>
--------------------
On Mon, Jan 20, 2020 at 02:38:24AM -0800, john.levon@joyent.com wrote:
> From: Toomas Soome <tsoome@me.com>
> 
> The SPARCV9 compile check needs to look for __sparcv9 on some systems,
> and should also define "sparc".

Hi.

Thanks for the patch.
Is it possible to have Toomas' Signed-off-by for this patch?
No need to resend the patch, just a reply to this email
saying it's OK is enough.

>  	case MACH_SPARC32:
>  		predefine("__sparc__", 1, "1");
>  		predefine("__sparc", 1, "1");
> +		predefine("sparc", 1, "1");

I'm wondering if there is a real need for this one or if
it's just to reflect what GCC do? I'm a bit reluctant to
add it since it lies in the user's namespace. But I'm fine
to add it if there is a real use case for it (in which case
I'll just slightly change the patch to not predefine it if
one of the ISO dialect is selected (via --std=c99, ...)).

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] cpp: sanitize redefining a macro during its own expansion ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] cpp: sanitize redefining a macro during its own expansion
Date: Thu, 12 Mar 2020 20:30:52 +0000
Message-ID: <20200312203052.52764-1-luc.vanoostenryck () gmail ! com>
--------------------
The presence of preprocessor directives within the arguments
of a macro invocation is Undefined Behaviour. Some of these
directives, like the conditionals, are harmless.

OTOH, the redefinition of a macro during its own expansion
is really nasty. However, it can be given a reasonable meaning:
* use the initial definition for the macro body
* use the new defintion for its arguments, in text order.
It's what gcc & clang do. But Sparse can't handle this
because during the expansion, a reference to the initial
macro's body is not kept. What is used instead is the
'body currently associated with the macro'.

Fix this by always using the body associated with the
macro at the time of its invocation.

Testcase-by: Oleg Nesterov <oleg@redhat.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 pre-process.c                          |  4 ++--
 validation/preprocessor/expand-redef.c | 15 +++++++++++++++
 2 files changed, 17 insertions(+), 2 deletions(-)
 create mode 100644 validation/preprocessor/expand-redef.c

diff --git a/pre-process.c b/pre-process.c
index 2893c3ab65d4..6670fb0cd557 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -756,7 +756,7 @@ static int expand(struct token **list, struct symbol *sym)
 	struct token *last;
 	struct token *token = *list;
 	struct ident *expanding = token->ident;
-	struct token **tail;
+	struct token **tail, *expansion = sym->expansion;
 	int nargs = sym->arglist ? sym->arglist->count.normal : 0;
 	struct arg args[nargs];
 
@@ -776,7 +776,7 @@ static int expand(struct token **list, struct symbol *sym)
 	expanding->tainted = 1;
 
 	last = token->next;
-	tail = substitute(list, sym->expansion, args);
+	tail = substitute(list, expansion, args);
 	/*
 	 * Note that it won't be eof - at least TOKEN_UNTAINT will be there.
 	 * We still can lose the newline flag if the sucker expands to nothing,
diff --git a/validation/preprocessor/expand-redef.c b/validation/preprocessor/expand-redef.c
new file mode 100644
index 000000000000..4ca13e661fa4
--- /dev/null
+++ b/validation/preprocessor/expand-redef.c
@@ -0,0 +1,15 @@
+#define f(x) x x
+f(1
+#undef  f
+#define f 2
+  f)
+
+/*
+ * check-name: expand-redef
+ * check-command: sparse -E -Wno-directive-within-macro $file
+ *
+ * check-output-start
+
+1 2 1 2
+ * check-output-end
+ */
-- 
2.25.1

================================================================================


################################################################################

=== Thread: [PATCH] cpp: silently allow conditional directives within macro ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] cpp: silently allow conditional directives within macro
Date: Thu, 12 Mar 2020 21:16:30 +0000
Message-ID: <20200312211630.53710-1-luc.vanoostenryck () gmail ! com>
--------------------
The presence of preprocessor directives within the arguments
of a macro invocation is Undefined Behaviour [6.10.3p11].
However, conditional directives are harmless here and are
useful (and commonly used in the kernel).

So, relax the warning by restricting it to non-conditional
directives.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 pre-process.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/pre-process.c b/pre-process.c
index 6670fb0cd557..4b2cd054f897 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -48,6 +48,7 @@ static struct ident_list *macros;	// only needed for -dD
 static int false_nesting = 0;
 static int counter_macro = 0;		// __COUNTER__ expansion
 static int include_level = 0;
+static int expanding = 0;
 
 #define INCLUDEPATHS 300
 const char *includepath[INCLUDEPATHS+1] = {
@@ -232,8 +233,13 @@ static int expand_one_symbol(struct token **list)
 		sym->expander(token);
 		return 1;
 	} else {
+		int rc;
+
 		sym->used_in = file_scope;
-		return expand(list, sym);
+		expanding = 1;
+		rc = expand(list, sym);
+		expanding = 0;
+		return rc;
 	}
 }
 
@@ -271,9 +277,6 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position
 	while (!eof_token(next = scan_next(p))) {
 		if (next->pos.newline && match_op(next, '#')) {
 			if (!next->pos.noexpand) {
-				if (Wdirective_within_macro)
-					warning(next->pos,
-						"directive in macro's argument list");
 				preprocessor_line(stream, p);
 				__free_token(next);	/* Free the '#' token */
 				continue;
@@ -2075,6 +2078,7 @@ static void handle_preprocessor_line(struct stream *stream, struct token **line,
 	int (*handler)(struct stream *, struct token **, struct token *);
 	struct token *token = start->next;
 	int is_normal = 1;
+	int is_cond = 0;	// is one of {is,ifdef,ifndef,elif,else,endif}
 
 	if (eof_token(token))
 		return;
@@ -2084,6 +2088,7 @@ static void handle_preprocessor_line(struct stream *stream, struct token **line,
 		if (sym) {
 			handler = sym->handler;
 			is_normal = sym->normal;
+			is_cond = !sym->normal;
 		} else {
 			handler = handle_nondirective;
 		}
@@ -2098,6 +2103,12 @@ static void handle_preprocessor_line(struct stream *stream, struct token **line,
 		if (false_nesting)
 			goto out;
 	}
+
+	if (expanding) {
+		if (Wdirective_within_macro && !is_cond)
+			warning(start->pos, "directive in macro's argument list");
+		expanding = 0;		// warn only once
+	}
 	if (!handler(stream, line, token))	/* all set */
 		return;
 
-- 
2.25.1

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] cpp: silently allow conditional directives within macro
Date: Mon, 16 Mar 2020 00:46:22 +0000
Message-ID: <20200316004622.hoiz72yi2wloz25g () ltop ! local>
--------------------
On Fri, Mar 13, 2020 at 05:17:48PM +0100, Oleg Nesterov wrote:
> On 03/12, Luc Van Oostenryck wrote:
> >
> > @@ -2098,6 +2103,12 @@ static void handle_preprocessor_line(struct stream *stream, struct token **line,
> >  		if (false_nesting)
> >  			goto out;
> >  	}
> > +
> > +	if (expanding) {
> > +		if (Wdirective_within_macro && !is_cond)
>                     ^^^^^^^^^^^^^^^^^^^^^^^
> I am not sure Wdirective_within_macro is really useful after this change,
> I'd suggest to drop my patch but this is up to you.

Yes, it makes much less sense now. I've replaced that by supporting
-pedantic.
 
> > +			warning(start->pos, "directive in macro's argument list");
> > +		expanding = 0;		// warn only once
> > +	}
> 
> then you should probably update preprocessor22.c ? See below.
> 
> I am not sure about validation/preprocessor/expand-redef.c added by the
> previous patch,

Yes, I hadn't updated the testcases because the patch just a RFC
to see if just allowing the #if/... was OK (but I forgot to mark
is as such) and they also depended on the previous RFC patch about
the expansion of newline.

Series updated and pushed now.
Thanks for the review.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH] define __PRAGMA_REDEFINE_EXTNAME ===

From: john.levon () joyent ! com
To: linux-sparse
Subject: [PATCH] define __PRAGMA_REDEFINE_EXTNAME
Date: Mon, 20 Jan 2020 10:47:24 +0000
Message-ID: <20200120104724.20812-1-john.levon () joyent ! com>
--------------------
From: John Levon <john.levon@joyent.com>

As per:

https://gcc.gnu.org/onlinedocs/gcc-4.6.3/gcc/Symbol_002dRenaming-Pragmas.html

we should set this define.

Signed-off-by: John Levon <john.levon@joyent.com>
---
 lib.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/lib.c b/lib.c
index 14e51979..9b03895c 100644
--- a/lib.c
+++ b/lib.c
@@ -1507,6 +1507,8 @@ static void predefined_macros(void)
 	if (optimize_size)
 		predefine("__OPTIMIZE_SIZE__", 0, "1");
 
+	predefine("__PRAGMA_REDEFINE_EXTNAME", 1, "1");
+
 	// Temporary hacks
 	predefine("__extension__", 0, NULL);
 	predefine("__pragma__", 0, NULL);
-- 
2.23.0

================================================================================


################################################################################

=== Thread: [PATCH] dissect: add support for _Generic ===

From: Alexey Gladkov <gladkov.alexey () gmail ! com>
To: linux-sparse
Subject: [PATCH] dissect: add support for _Generic
Date: Tue, 28 Jul 2020 18:35:07 +0000
Message-ID: <20200728183507.422662-1-gladkov.alexey () gmail ! com>
--------------------
No special support needed for _Generic, so just suppress the warning
about unknown type.

Before:

$ ./test-dissect validation/generic-functions.c

FILE: validation/generic-functions.c

  13:1                    def   f testf                            void ( ... )
  13:1   testf            def . v a                                float
validation/generic-functions.c:13:1: warning: bad expr->type: 31
  13:1   testf            -r- . v a                                float
  14:1                    def   f testd                            void ( ... )
  14:1   testd            def . v a                                double
validation/generic-functions.c:14:1: warning: bad expr->type: 31
  14:1   testd            -r- . v a                                double
  15:1                    def   f testl                            void ( ... )
  15:1   testl            def . v a                                long double
validation/generic-functions.c:15:1: warning: bad expr->type: 31
  15:1   testl            -r- . v a                                long double

After:

$ ./test-dissect validation/generic-functions.c

FILE: validation/generic-functions.c

  13:1                    def   f testf                            void ( ... )
  13:1   testf            def . v a                                float
  13:1   testf            -r- . v a                                float
  14:1                    def   f testd                            void ( ... )
  14:1   testd            def . v a                                double
  14:1   testd            -r- . v a                                double
  15:1                    def   f testl                            void ( ... )
  15:1   testl            def . v a                                long double
  15:1   testl            -r- . v a                                long double

Signed-off-by: Alexey Gladkov <gladkov.alexey@gmail.com>
---
 dissect.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dissect.c b/dissect.c
index ccb7897b..b494f93c 100644
--- a/dissect.c
+++ b/dissect.c
@@ -342,6 +342,7 @@ again:
 	case EXPR_TYPE:		// [struct T]; Why ???
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
+	case EXPR_GENERIC:
 
 	break; case EXPR_LABEL:
 		ret = &label_ctype;
-- 
2.25.4

================================================================================

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: add support for _Generic
Date: Tue, 28 Jul 2020 19:49:38 +0000
Message-ID: <20200728194937.GA2467 () redhat ! com>
--------------------
On 07/28, Alexey Gladkov wrote:
>
> No special support needed for _Generic,

Hmm. I am already sleeping and didn't read the _Generic code yet... but
shouldn't dissect() inspect ->control/map/def?

That said,

> so just suppress the warning
> about unknown type.

probably better than nothing, lets shut up the warning first.

Oleg.

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: add support for _Generic
Date: Tue, 28 Jul 2020 23:10:58 +0000
Message-ID: <20200728231058.3yakpfw3dqslxq5t () ltop ! local>
--------------------
On Tue, Jul 28, 2020 at 09:49:38PM +0200, Oleg Nesterov wrote:
> On 07/28, Alexey Gladkov wrote:
> >
> > No special support needed for _Generic,
> 
> Hmm. I am already sleeping and didn't read the _Generic code yet... but
> shouldn't dissect() inspect ->control/map/def?
> 
> That said,
> 
> > so just suppress the warning
> > about unknown type.
> 
> probably better than nothing, lets shut up the warning first.

OK, since there is some urgency, I applied it directly but
my first reaction was also "eh, you can't just ignore
EXPR_GENERIC / pretend it's one of the top-level expression".
OTOH, I wonder what can be done without first evaluating
(the type of) the controlling expression and the types of the map
(if I understand correctly, evaluation is avoided in dissect).

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: add support for _Generic
Date: Wed, 29 Jul 2020 14:50:25 +0000
Message-ID: <20200729145025.g26jqfpqcnhd5wed () ltop ! local>
--------------------
On Wed, Jul 29, 2020 at 01:28:02PM +0200, Oleg Nesterov wrote:
> On 07/29, Luc Van Oostenryck wrote:
> >
> > OTOH, I wonder what can be done without first evaluating
> > (the type of) the controlling expression and the types of the map
> > (if I understand correctly, evaluation is avoided in dissect).
> 
> Yes. I'll try to think a bit more, but so far I think I'll simply
> send the patch below.

... 

> Of course, technically this is wrong, it looks as if all 3 variables are
> modified. But not that bad imo, dissect doesn't even try to be "precise",
> and this output still looks useful for the indexing/etc.
> 
> --- a/dissect.c
> +++ b/dissect.c
> @@ -342,7 +342,6 @@ again:
>  	case EXPR_TYPE:		// [struct T]; Why ???
>  	case EXPR_VALUE:
>  	case EXPR_FVALUE:
> -	case EXPR_GENERIC:
>  
>  	break; case EXPR_LABEL:
>  		ret = &label_ctype;
> @@ -472,6 +471,17 @@ again:
>  		} while ((expr = expr->down));
>  	}
>  
> +	break; case EXPR_GENERIC: {
> +		struct type_expression *map;
> +
> +		do_expression(U_VOID, expr->control);
> +
> +		for (map = expr->map; map; map = map->next)
> +			ret = do_expression(mode, map->expr);
> +		if (expr->def)
> +			ret = do_expression(mode, expr->def);
> +	}
> +
>  	break; case EXPR_SYMBOL:
>  		ret = report_symbol(mode, expr);
>  	}

Yes, that should do the 'walking'. The returned type will just be
quite arbitrary, but I don't know how much it matters.

-- Luc
================================================================================

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: add support for _Generic
Date: Thu, 30 Jul 2020 15:08:37 +0000
Message-ID: <20200730150837.GA6956 () redhat ! com>
--------------------
On 07/29, Luc Van Oostenryck wrote:
>
> > +	break; case EXPR_GENERIC: {
> > +		struct type_expression *map;
> > +
> > +		do_expression(U_VOID, expr->control);
> > +
> > +		for (map = expr->map; map; map = map->next)
> > +			ret = do_expression(mode, map->expr);
> > +		if (expr->def)
> > +			ret = do_expression(mode, expr->def);
> > +	}
> > +
> >  	break; case EXPR_SYMBOL:
> >  		ret = report_symbol(mode, expr);
> >  	}
>
> Yes, that should do the 'walking'.

OK, I am sending this stupid patch. Better than nothing.

> The returned type will just be
> quite arbitrary, but I don't know how much it matters.

Of course. And this is not good. For example:

	void func(void)
	{
		struct B *b; struct C *c; struct D *d;
		_Generic(a,
			int:		b,
			void*:		c,
			default:	d
		) ->mem++;
	}

output:

   1:6                    def   f func                             void ( ... )
   3:18  func             def . v b                                struct B *
   3:31  func             def . v c                                struct C *
   3:44  func             def . v d                                struct D *
   4:18  func             ---   v a                                bad type
   5:33  func             --m . v b                                struct B *
   6:33  func             --m . v c                                struct C *
   7:33  func             --m . v d                                struct D *
   8:11  func             -m-   m D.mem                            bad type

But I do not know how to improve it without serious complications, and
(so far) I think it doesn't worth the effort.

Oleg.

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: add support for _Generic
Date: Thu, 30 Jul 2020 20:00:46 +0000
Message-ID: <20200730200046.qsbaw4iabb4idjly () ltop ! local>
--------------------
On Thu, Jul 30, 2020 at 05:08:37PM +0200, Oleg Nesterov wrote:
> On 07/29, Luc Van Oostenryck wrote:
> > The returned type will just be
> > quite arbitrary, but I don't know how much it matters.
> 
> Of course. And this is not good. For example:
> 
> 	void func(void)
> 	{
> 		struct B *b; struct C *c; struct D *d;
> 		_Generic(a,
> 			int:		b,
> 			void*:		c,
> 			default:	d
> 		) ->mem++;
> 	}
> 
> output:
> 
>    1:6                    def   f func                             void ( ... )
>    3:18  func             def . v b                                struct B *
>    3:31  func             def . v c                                struct C *
>    3:44  func             def . v d                                struct D *
>    4:18  func             ---   v a                                bad type
>    5:33  func             --m . v b                                struct B *
>    6:33  func             --m . v c                                struct C *
>    7:33  func             --m . v d                                struct D *
>    8:11  func             -m-   m D.mem                            bad type
> 
> But I do not know how to improve it without serious complications, and

Are you thinking about calling evaluate_symbol_list() or about
something else? What kind of complications?

> (so far) I think it doesn't worth the effort.

Yes, _Generic() clearly makes things a bit more complicated here.
Same for __auto_type, which is not yet used by the kernel but will
probably be soon.

-- Luc
================================================================================

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: add support for _Generic
Date: Fri, 31 Jul 2020 14:43:01 +0000
Message-ID: <20200731144300.GB13775 () redhat ! com>
--------------------
On 07/30, Luc Van Oostenryck wrote:
>
> On Thu, Jul 30, 2020 at 05:08:37PM +0200, Oleg Nesterov wrote:
> > On 07/29, Luc Van Oostenryck wrote:
> > > The returned type will just be
> > > quite arbitrary, but I don't know how much it matters.
> >
> > Of course. And this is not good. For example:
> >
> > 	void func(void)
> > 	{
> > 		struct B *b; struct C *c; struct D *d;
> > 		_Generic(a,
> > 			int:		b,
> > 			void*:		c,
> > 			default:	d
> > 		) ->mem++;
> > 	}
> >
> > output:
> >
> >    1:6                    def   f func                             void ( ... )
> >    3:18  func             def . v b                                struct B *
> >    3:31  func             def . v c                                struct C *
> >    3:44  func             def . v d                                struct D *
> >    4:18  func             ---   v a                                bad type
> >    5:33  func             --m . v b                                struct B *
> >    6:33  func             --m . v c                                struct C *
> >    7:33  func             --m . v d                                struct D *
> >    8:11  func             -m-   m D.mem                            bad type
> >
> > But I do not know how to improve it without serious complications, and
>
> Are you thinking about calling evaluate_symbol_list()

I meant, it is not simple to teach dissect() to handle this case correctly.
It understand the types, but for example it doesn't even try to distinguish
"int" and "float".

And I would like to avoid evaluate_expression/etc.

> or about
> something else?

And something else. See the example above, this code is incomplete and in this
case evaluate can't help. Ideally dissect should also report the (possible) usage
of B.mem and C.mem.

> > (so far) I think it doesn't worth the effort.
>
> Yes, _Generic() clearly makes things a bit more complicated here.
> Same for __auto_type,

Yes, but hopefully dissect needs much more simple changes to handle __auto_type.

Thanks,

Oleg.

================================================================================


################################################################################

=== Thread: [PATCH] dissect: change do_symbol(SYM_FN) to check base_type->stmt != NULL ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: change do_symbol(SYM_FN) to check base_type->stmt != NULL
Date: Fri, 07 Feb 2020 10:32:07 +0000
Message-ID: <20200207103207.GA16991 () redhat ! com>
--------------------
examine_fn_arguments() silently degenerates function arguments into
pointers but dissect doesn't do evaluate_symbol_list(), that is why
do_sym_list(type->arguments) can report the bogus definitions.

Test case:

	void extf(int MUST_NOT_BE_REPORTED);
	typedef void (fptr_t)(int MUST_NOT_BE_REPORTED);

	void func1(fptr_t fptr) {}
	void func2(typeof(extf) fptr) {}
	void func3(void) { typeof(extf) fptr; };
	void func4(void (fptr)(int MUST_NOT_BE_REPORTED)) {}

without this patch:

	4:6                    def  func1                            void ( ... )
	4:12  func1            def  fptr                             void ( ... )
	2:23  fptr             def  MUST_NOT_BE_REPORTED             int
	5:6                    def  func2                            void ( ... )
	5:19  func2            ---  extf                             void ( ... )
	5:12  func2            def  fptr                             void ( ... )
	1:11  fptr             def  MUST_NOT_BE_REPORTED             int
	6:6                    def  func3                            void ( ... )
	6:27  func3            ---  extf                             void ( ... )
	6:33  func3            def  fptr                             void ( ... )
	1:11  fptr             def  MUST_NOT_BE_REPORTED             int
	7:6                    def  func4                            void ( ... )
	7:12  func4            def  fptr                             void ( ... )
	7:24  fptr             def  MUST_NOT_BE_REPORTED             int

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/dissect.c b/dissect.c
index 54e11d2..b48cd85 100644
--- a/dissect.c
+++ b/dissect.c
@@ -589,6 +589,7 @@ static inline struct symbol *do_symbol(struct symbol *sym)
 {
 	struct symbol *type = base_type(sym);
 	struct symbol *dctx = dissect_ctx;
+	struct statement *stmt;
 
 	reporter->r_symdef(sym);
 
@@ -603,12 +604,22 @@ static inline struct symbol *do_symbol(struct symbol *sym)
 		dissect_ctx = dctx;
 
 	break; case SYM_FN:
+		stmt = sym->ctype.modifiers & MOD_INLINE
+			? type->inline_stmt
+			: type->stmt;
+		if (!stmt)
+			break;
+
+		if (dctx)
+			sparse_error(dctx->pos,
+				"dissect_ctx change %.*s -> %s",
+				dctx->ident->len, dctx->ident->name,
+				show_ident(sym->ident));
+
 		dissect_ctx = sym;
 		return_type = base_type(type);
 		do_sym_list(type->arguments);
-		do_statement(U_VOID, sym->ctype.modifiers & MOD_INLINE
-					? type->inline_stmt
-					: type->stmt);
+		do_statement(U_VOID, stmt);
 		dissect_ctx = dctx;
 		return_type = NULL;
 	}
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH] dissect: enforce toplevel() if SYM_STRUCT was not defined ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: enforce toplevel() if SYM_STRUCT was not defined
Date: Thu, 27 Feb 2020 15:21:15 +0000
Message-ID: <20200227152115.GA19970 () redhat ! com>
--------------------
A separate change for documentation purposes.

Test-case:

	void func(void)
	{
		struct UNDEFINED x;
		x.member = 0;
	}

output:

   1:6                    def   f func                             void ( ... )
   3:26  func             def . v x                                struct UNDEFINED
   4:9   func             -w- . v x                                struct UNDEFINED
   4:10  func             -w- . m UNDEFINED.member                 bad type

but in this case is_sym_local(UNDEFINED) = F makes more sense, most
probably this struct was defined somewhere else but __sparse() didn't
see its definition.

Change lookup_member() to set type->scope = file_scope if !symbol_list.
This is not 100% correct, but struct_union_enum_specifier() does the
same check with the following comment:

	// The following test is actually wrong for empty
	// structs, but (1) they are not C99, (2) gcc does
	// the same thing, and (3) it's easier.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dissect.c b/dissect.c
index c48214b9..1970e46f 100644
--- a/dissect.c
+++ b/dissect.c
@@ -304,6 +304,9 @@ static struct symbol *lookup_member(struct symbol *type, struct ident *name, int
 			.kind = 'm',
 		};
 
+		if (!type->symbol_list)
+			type->scope = file_scope;
+
 		mem = &bad_member;
 		mem->ident = name;
 	}
-- 
2.25.1.362.g51ebf55


================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: enforce toplevel() if SYM_STRUCT was not defined
Date: Mon, 02 Mar 2020 13:17:04 +0000
Message-ID: <20200302131704.4oiixurruvcmjduj () ltop ! local>
--------------------
On Thu, Feb 27, 2020 at 04:21:15PM +0100, Oleg Nesterov wrote:
> A separate change for documentation purposes.

Thanks.
Applied & pushed.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH] dissect: introduce dissect_ctx ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: introduce dissect_ctx
Date: Thu, 06 Feb 2020 17:01:32 +0000
Message-ID: <20200206170132.GA8908 () redhat ! com>
--------------------
Points to the current function or to the global variable in case of
compound initializer.

Kill the ugly test-dissect.c:storage() and change print_usage() to
report dissect_ctx->ident instead.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c      | 17 +++++++++++++++--
 dissect.h      |  2 ++
 test-dissect.c | 21 ++++++++-------------
 3 files changed, 25 insertions(+), 15 deletions(-)

diff --git a/dissect.c b/dissect.c
index 60fccbd..54e11d2 100644
--- a/dissect.c
+++ b/dissect.c
@@ -51,6 +51,8 @@
 
 typedef unsigned usage_t;
 
+struct symbol *dissect_ctx;
+
 static struct reporter *reporter;
 static struct symbol *return_type;
 
@@ -211,7 +213,7 @@ static void report_memdef(struct symbol *sym, struct symbol *mem)
 
 static void examine_sym_node(struct symbol *node, struct symbol *parent)
 {
-	struct symbol *base;
+	struct symbol *base, *dctx;
 	struct ident *name;
 
 	if (node->examined)
@@ -240,6 +242,9 @@ static void examine_sym_node(struct symbol *node, struct symbol *parent)
 				return;
 			base->evaluated = 1;
 
+			dctx = dissect_ctx;
+			dissect_ctx = NULL;
+
 			if (base->ident || deanon(base, name, parent))
 				reporter->r_symdef(base);
 
@@ -248,6 +253,7 @@ static void examine_sym_node(struct symbol *node, struct symbol *parent)
 			DO_LIST(base->symbol_list, mem,
 				examine_sym_node(mem, parent);
 				report_memdef(parent, mem));
+			dissect_ctx = dctx;
 		default:
 			return;
 		}
@@ -582,6 +588,7 @@ static struct symbol *do_initializer(struct symbol *type, struct expression *exp
 static inline struct symbol *do_symbol(struct symbol *sym)
 {
 	struct symbol *type = base_type(sym);
+	struct symbol *dctx = dissect_ctx;
 
 	reporter->r_symdef(sym);
 
@@ -590,14 +597,20 @@ static inline struct symbol *do_symbol(struct symbol *sym)
 		if (!sym->initializer)
 			break;
 		reporter->r_symbol(U_W_VAL, &sym->pos, sym);
+		if (!dctx)
+			dissect_ctx = sym;
 		do_initializer(type, sym->initializer);
+		dissect_ctx = dctx;
 
 	break; case SYM_FN:
-		do_sym_list(type->arguments);
+		dissect_ctx = sym;
 		return_type = base_type(type);
+		do_sym_list(type->arguments);
 		do_statement(U_VOID, sym->ctype.modifiers & MOD_INLINE
 					? type->inline_stmt
 					: type->stmt);
+		dissect_ctx = dctx;
+		return_type = NULL;
 	}
 
 	return type;
diff --git a/dissect.h b/dissect.h
index 1f5b1d9..efe2c0b 100644
--- a/dissect.h
+++ b/dissect.h
@@ -25,6 +25,8 @@ struct reporter
 	void (*r_member)(unsigned, struct position *, struct symbol *, struct symbol *);
 };
 
+extern struct symbol *dissect_ctx;
+
 extern void dissect(struct symbol_list *, struct reporter *);
 
 #endif
diff --git a/test-dissect.c b/test-dissect.c
index e725eec..d93a2a0 100644
--- a/test-dissect.c
+++ b/test-dissect.c
@@ -2,17 +2,6 @@
 
 static unsigned dotc_stream;
 
-static inline char storage(struct symbol *sym)
-{
-	int t = sym->type;
-	unsigned m = sym->ctype.modifiers;
-
-	if (m & MOD_INLINE || t == SYM_STRUCT || t == SYM_UNION /*|| t == SYM_ENUM*/)
-		return sym->pos.stream == dotc_stream ? 's' : 'g';
-
-	return (m & MOD_STATIC) ? 's' : (m & MOD_NONLOCAL) ? 'g' : 'l';
-}
-
 static inline const char *show_mode(unsigned mode)
 {
 	static char str[3];
@@ -32,14 +21,20 @@ static inline const char *show_mode(unsigned mode)
 static void print_usage(struct position *pos, struct symbol *sym, unsigned mode)
 {
 	static unsigned curr_stream = -1;
+	static struct ident null;
+	struct ident *ctx = &null;
 
 	if (curr_stream != pos->stream) {
 		curr_stream = pos->stream;
 		printf("\nFILE: %s\n\n", stream_name(curr_stream));
 	}
 
-	printf("%4d:%-3d %c %-5.3s",
-		pos->line, pos->pos, storage(sym), show_mode(mode));
+	if (dissect_ctx)
+		ctx = dissect_ctx->ident;
+
+	printf("%4d:%-3d %-16.*s %-5.3s",
+		pos->line, pos->pos, ctx->len, ctx->name, show_mode(mode));
+
 }
 
 static void r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
-- 
2.5.0


================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: introduce dissect_ctx
Date: Thu, 06 Feb 2020 20:45:18 +0000
Message-ID: <20200206204518.qx5qtyl52al37njy () ltop ! local>
--------------------
On Thu, Feb 06, 2020 at 06:01:32PM +0100, Oleg Nesterov wrote:
> Points to the current function or to the global variable in case of
> compound initializer.
> 
> Kill the ugly test-dissect.c:storage() and change print_usage() to
> report dissect_ctx->ident instead.

Having the ful ident will be good, I think, but the cost is to have
to maintain this context. I suppose it would be too painful to 
propgate this context via an additional argument to all involved
functions?

-- Luc 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: introduce dissect_ctx
Date: Fri, 07 Feb 2020 11:21:08 +0000
Message-ID: <20200207112108.elchvmg3ikcu67pn () ltop ! local>
--------------------
On Fri, Feb 07, 2020 at 11:01:50AM +0100, Oleg Nesterov wrote:
> On 02/06, Luc Van Oostenryck wrote:
> >
> > On Thu, Feb 06, 2020 at 06:01:32PM +0100, Oleg Nesterov wrote:
> > > Points to the current function or to the global variable in case of
> > > compound initializer.
> > >
> > > Kill the ugly test-dissect.c:storage() and change print_usage() to
> > > report dissect_ctx->ident instead.
> >
> > Having the ful ident will be good, I think, but the cost is to have
> > to maintain this context. I suppose it would be too painful to
> > propgate this context via an additional argument to all involved
> > functions?
> 
> Oh, I'd prefer to not do this. This needs to add the additional "ctx"
> arg to every do_.*() function in dissect.c, and for what? IMHO, this
> will just complicate the code for no reason.

Yes, I guessed so. No problem.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH] dissect: introduce reporter->r_memdef() ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: introduce reporter->r_memdef()
Date: Wed, 05 Feb 2020 12:53:18 +0000
Message-ID: <20200205125318.GA14560 () redhat ! com>
--------------------
To report where is the member of struct/union defined.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c      | 12 +++++++++++-
 dissect.h      |  1 +
 test-dissect.c |  6 ++++++
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/dissect.c b/dissect.c
index 88eaab1..60fccbd 100644
--- a/dissect.c
+++ b/dissect.c
@@ -203,6 +203,12 @@ static bool deanon(struct symbol *base, struct ident *node, struct symbol *paren
 	return true;
 }
 
+static void report_memdef(struct symbol *sym, struct symbol *mem)
+{
+	if (sym && mem->ident)
+		reporter->r_memdef(sym, mem);
+}
+
 static void examine_sym_node(struct symbol *node, struct symbol *parent)
 {
 	struct symbol *base;
@@ -236,8 +242,12 @@ static void examine_sym_node(struct symbol *node, struct symbol *parent)
 
 			if (base->ident || deanon(base, name, parent))
 				reporter->r_symdef(base);
+
+			if (base->ident)
+				parent = base;
 			DO_LIST(base->symbol_list, mem,
-				examine_sym_node(mem, base->ident ? base : parent));
+				examine_sym_node(mem, parent);
+				report_memdef(parent, mem));
 		default:
 			return;
 		}
diff --git a/dissect.h b/dissect.h
index 664736c..1f5b1d9 100644
--- a/dissect.h
+++ b/dissect.h
@@ -19,6 +19,7 @@
 struct reporter
 {
 	void (*r_symdef)(struct symbol *);
+	void (*r_memdef)(struct symbol *, struct symbol *);
 
 	void (*r_symbol)(unsigned, struct position *, struct symbol *);
 	void (*r_member)(unsigned, struct position *, struct symbol *, struct symbol *);
diff --git a/test-dissect.c b/test-dissect.c
index af1212a..e725eec 100644
--- a/test-dissect.c
+++ b/test-dissect.c
@@ -75,10 +75,16 @@ static void r_symdef(struct symbol *sym)
 	r_symbol(-1, &sym->pos, sym);
 }
 
+static void r_memdef(struct symbol *sym, struct symbol *mem)
+{
+	r_member(-1, &mem->pos, sym, mem);
+}
+
 int main(int argc, char **argv)
 {
 	static struct reporter reporter = {
 		.r_symdef = r_symdef,
+		.r_memdef = r_memdef,
 		.r_symbol = r_symbol,
 		.r_member = r_member,
 	};
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH] dissect: introduce sym_is_local() for reporter ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: introduce sym_is_local() for reporter
Date: Tue, 11 Feb 2020 16:01:36 +0000
Message-ID: <20200211160136.GA14027 () redhat ! com>
--------------------
Can be used to filter out the usage of local variables.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c      |  2 +-
 dissect.h      |  5 +++++
 test-dissect.c | 18 ++++++++++++++----
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/dissect.c b/dissect.c
index d9ca142..823a348 100644
--- a/dissect.c
+++ b/dissect.c
@@ -165,7 +165,7 @@ static inline struct symbol *expr_symbol(struct expression *expr)
 		if (!sym) {
 			sym = alloc_symbol(expr->pos, SYM_BAD);
 			bind_symbol(sym, expr->symbol_name, NS_SYMBOL);
-			sym->ctype.modifiers = MOD_EXTERN;
+			sym->ctype.modifiers = MOD_EXTERN | MOD_TOPLEVEL;
 			sym->kind = expr->op ?: 'v'; /* see EXPR_CALL */
 		}
 	}
diff --git a/dissect.h b/dissect.h
index efe2c0b..178dba5 100644
--- a/dissect.h
+++ b/dissect.h
@@ -27,6 +27,11 @@ struct reporter
 
 extern struct symbol *dissect_ctx;
 
+static inline bool sym_is_local(struct symbol *sym)
+{
+	return sym->kind == 'v' && !(sym->ctype.modifiers & MOD_TOPLEVEL);
+}
+
 extern void dissect(struct symbol_list *, struct reporter *);
 
 #endif
diff --git a/test-dissect.c b/test-dissect.c
index ece2253..c4b454c 100644
--- a/test-dissect.c
+++ b/test-dissect.c
@@ -37,6 +37,16 @@ static void print_usage(struct position *pos, struct symbol *sym, unsigned mode)
 
 }
 
+static char symscope(struct symbol *sym)
+{
+	if (sym_is_local(sym)) {
+		if (!dissect_ctx)
+			warning(sym->pos, "no context");
+		return '.';
+	}
+	return ' ';
+}
+
 static void r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
 {
 	print_usage(pos, sym, mode);
@@ -44,8 +54,8 @@ static void r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
 	if (!sym->ident)
 		sym->ident = built_in_ident("__asm__");
 
-	printf("%c %-32.*s %s\n",
-		sym->kind, sym->ident->len, sym->ident->name,
+	printf("%c %c %-32.*s %s\n",
+		symscope(sym), sym->kind, sym->ident->len, sym->ident->name,
 		show_typename(sym->ctype.base_type));
 
 	switch (sym->kind) {
@@ -80,8 +90,8 @@ static void r_member(unsigned mode, struct position *pos, struct symbol *sym, st
 	/* mem == NULL means entire struct accessed */
 	mi = mem ? mem->ident : built_in_ident("*");
 
-	printf("m %.*s.%-*.*s %s\n",
-		si->len, si->name,
+	printf("%c m %.*s.%-*.*s %s\n",
+		symscope(sym), si->len, si->name,
 		32-1 - si->len, mi->len, mi->name,
 		show_typename(mem ? mem->ctype.base_type : sym));
 
-- 
2.5.0


================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: introduce sym_is_local() for reporter
Date: Wed, 12 Feb 2020 00:41:35 +0000
Message-ID: <20200212004135.cyzcqtwwcuewa4gj () ltop ! local>
--------------------
On Tue, Feb 11, 2020 at 05:01:36PM +0100, Oleg Nesterov wrote:
> Can be used to filter out the usage of local variables.

...
 
> diff --git a/dissect.h b/dissect.h
> index efe2c0b..178dba5 100644
> --- a/dissect.h
> +++ b/dissect.h
> @@ -27,6 +27,11 @@ struct reporter
>  
>  extern struct symbol *dissect_ctx;
>  
> +static inline bool sym_is_local(struct symbol *sym)
> +{
> +	return sym->kind == 'v' && !(sym->ctype.modifiers & MOD_TOPLEVEL);
> +}
> +

Shouldn't MOD_STATIC be added to the test?
It depends on what exactly you want for 'local'.

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: introduce sym_is_local() for reporter
Date: Thu, 13 Feb 2020 17:41:30 +0000
Message-ID: <20200213174130.vzc3tj3l3dj3xrpc () ltop ! local>
--------------------
On Wed, Feb 12, 2020 at 10:06:27AM +0100, Oleg Nesterov wrote:
> On 02/12, Luc Van Oostenryck wrote:
> > It depends on what exactly you want for 'local'.
> 
> Yes, it should only return T if the symbol was defined inside some function.
> If we have
> 
> 	static int I;
> 
> in file scope, sym_is_local() should return false and so it does, test-dissect
> outputs
> 
> 	1:12                   def   v I                                int

OK, then everything is fine.
 
> Thanks for looking!

You're welcome!
This and the other pending ones are now pushed to main.

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] dissect: move __sparse() callsite from test-dissect.c to dissect.c ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: move __sparse() callsite from test-dissect.c to dissect.c
Date: Tue, 11 Feb 2020 17:04:15 +0000
Message-ID: <20200211170415.GA18497 () redhat ! com>
--------------------
This is more flexible. For example, we can change dissect() to inspect
file_scope->symbols too without changing its callers.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c      |  5 +++--
 dissect.h      |  2 +-
 test-dissect.c | 11 ++---------
 3 files changed, 6 insertions(+), 12 deletions(-)

diff --git a/dissect.c b/dissect.c
index 823a348..499e0a0 100644
--- a/dissect.c
+++ b/dissect.c
@@ -642,8 +642,9 @@ static void do_sym_list(struct symbol_list *list)
 	DO_LIST(list, sym, do_symbol(sym));
 }
 
-void dissect(struct symbol_list *list, struct reporter *rep)
+void dissect(struct reporter *rep, struct string_list *filelist)
 {
 	reporter = rep;
-	do_sym_list(list);
+
+	DO_LIST(filelist, file, do_sym_list(__sparse(file)));
 }
diff --git a/dissect.h b/dissect.h
index 178dba5..326d3dc 100644
--- a/dissect.h
+++ b/dissect.h
@@ -32,6 +32,6 @@ static inline bool sym_is_local(struct symbol *sym)
 	return sym->kind == 'v' && !(sym->ctype.modifiers & MOD_TOPLEVEL);
 }
 
-extern void dissect(struct symbol_list *, struct reporter *);
+extern void dissect(struct reporter *, struct string_list *);
 
 #endif
diff --git a/test-dissect.c b/test-dissect.c
index c4b454c..4b2d3be 100644
--- a/test-dissect.c
+++ b/test-dissect.c
@@ -1,7 +1,5 @@
 #include "dissect.h"
 
-static unsigned dotc_stream;
-
 static inline const char *show_mode(unsigned mode)
 {
 	static char str[3];
@@ -119,15 +117,10 @@ int main(int argc, char **argv)
 		.r_symbol = r_symbol,
 		.r_member = r_member,
 	};
-	struct string_list *filelist = NULL;
-	char *file;
 
+	struct string_list *filelist = NULL;
 	sparse_initialize(argc, argv, &filelist);
-
-	FOR_EACH_PTR(filelist, file) {
-		dotc_stream = input_stream_nr;
-		dissect(__sparse(file), &reporter);
-	} END_FOR_EACH_PTR(file);
+	dissect(&reporter, filelist);
 
 	return 0;
 }
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH] dissect: use show_ident() to print dctx->ident ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: [PATCH] dissect: use show_ident() to print dctx->ident
Date: Wed, 12 Feb 2020 09:21:40 +0000
Message-ID: <20200212092140.GA21571 () redhat ! com>
--------------------
I didn't know show_ident() uses 4 buffers for the string it returns and
thus it is safe to call it twice in a row.

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
---
 dissect.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/dissect.c b/dissect.c
index 499e0a0..6706690 100644
--- a/dissect.c
+++ b/dissect.c
@@ -617,16 +617,13 @@ static inline struct symbol *do_symbol(struct symbol *sym)
 
 	break; case SYM_FN:
 		stmt = sym->ctype.modifiers & MOD_INLINE
-			? type->inline_stmt
-			: type->stmt;
+			? type->inline_stmt : type->stmt;
 		if (!stmt)
 			break;
 
 		if (dctx)
-			sparse_error(dctx->pos,
-				"dissect_ctx change %.*s -> %s",
-				dctx->ident->len, dctx->ident->name,
-				show_ident(sym->ident));
+			sparse_error(dctx->pos, "dissect_ctx change %s -> %s",
+				show_ident(dctx->ident), show_ident(sym->ident));
 
 		dissect_ctx = sym;
 		do_sym_list(type->arguments);
-- 
2.5.0


================================================================================


################################################################################

=== Thread: [PATCH] dissect: use struct symbol::visited/inspected instead of ::examined/evaluated ===

From: Oleg Nesterov <oleg () redhat ! com>
To: linux-sparse
Subject: Re: [PATCH] dissect: use struct symbol::visited/inspected instead of ::examined/evaluated
Date: Wed, 29 Jul 2020 15:34:13 +0000
Message-ID: <20200729153413.GB4360 () redhat ! com>
--------------------
On 07/29, Luc Van Oostenryck wrote:
>
> The dissect client uses struct symbol's fields 'examined' & 'evaluated'
> to avoid reprocessing the same symbols. But these fields are used
> internally by sparse for type examination & evaluation and despite
> dissect not doing these operations explicitly, they can be done
> implicitly

Yes. For example, test_dissect.c calls show_typename() and this can
lead to examine/evaluate.

I didn't bother to fix this because test_dissect.c is the very basic
debugging tool.

> So, add a new field to struct symbol: 'inspected' and use it, as
> well as the existing 'visited', instead of 'evaluated' & 'examined'.

Thanks! Looks good to me.

> Note: when used on the kernel, this patch avoids a lot of warnings:
> 	"warning: r_member bad sym type=7 kind=0"
> 	"warning: r_member bad mem->kind = 0"
>       and creates substantially more normal output.

So this is test-dissect, sindex should be fine even without this patch.

Acked-by: Oleg Nesterov <oleg@redhat.com>

================================================================================


################################################################################

=== Thread: [PATCH] do the tree inlining during expansion phase ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] do the tree inlining during expansion phase
Date: Sat, 08 Feb 2020 23:57:18 +0000
Message-ID: <20200208235718.96389-1-luc.vanoostenryck () gmail ! com>
--------------------
Currently, the tree inlining is done very early, during the
evaluation phase. This means that the inlining is done even
if the corresponding call belong to a sub-expression that
will be discarded during the expansion phase.
Usually this is not a problem but in some pathological
cases it can lead to a huge waste of memory and CPU time.

So, move this inline expansion to ... the expansion phase.
Also, re-expand the resulting expression since constant
arguments may create new opportunities for simplification.

Note: the motivation for thsi is a pathological case in the
      kernel where a combination of max_t() + const_ilog2() +
      roundup_pow_of_two() + cpumask_weight() + __const_hweight*()
      caused Sparse to use 2.3Gb of memory. With this patch
      the memory consumption is down to 247Mb.

Link: https://marc.info/?l=linux-sparse&m=158098958501220
Link: https://lore.kernel.org/netdev/CAHk-=whvS9x5NKtOqcUgJeTY7dfdAHc
Reported-by: Randy Dunlap <rdunlap@infradead.org>
Originally-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 16 ----------------
 expand.c   | 19 +++++++++++++++++++
 inline.c   |  5 -----
 3 files changed, 19 insertions(+), 21 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index f1a266beccfd..b7bb1f52aa91 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3107,22 +3107,6 @@ static int evaluate_symbol_call(struct expression *expr)
 	if (ctype->op && ctype->op->evaluate)
 		return ctype->op->evaluate(expr);
 
-	if (ctype->ctype.modifiers & MOD_INLINE) {
-		int ret;
-		struct symbol *curr = current_fn;
-
-		if (ctype->definition)
-			ctype = ctype->definition;
-
-		current_fn = ctype->ctype.base_type;
-
-		ret = inline_function(expr, ctype);
-
-		/* restore the old function */
-		current_fn = curr;
-		return ret;
-	}
-
 	return 0;
 }
 
diff --git a/expand.c b/expand.c
index 36612c8672dd..e75598781b6c 100644
--- a/expand.c
+++ b/expand.c
@@ -910,6 +910,25 @@ static int expand_symbol_call(struct expression *expr, int cost)
 	if (fn->type != EXPR_PREOP)
 		return SIDE_EFFECTS;
 
+	if (ctype->ctype.modifiers & MOD_INLINE) {
+		struct symbol *def;
+
+		def = ctype->definition ? ctype->definition : ctype;
+		if (inline_function(expr, def)) {
+			struct symbol *fn = def->ctype.base_type;
+			struct symbol *curr = current_fn;
+
+			current_fn = fn;
+			evaluate_statement(expr->statement);
+			current_fn = curr;
+
+			fn->expanding = 1;
+			cost = expand_expression(expr);
+			fn->expanding = 0;
+			return cost;
+		}
+	}
+
 	if (ctype->op && ctype->op->expand)
 		return ctype->op->expand(expr, cost);
 
diff --git a/inline.c b/inline.c
index 6f73a30556bc..a959728013f1 100644
--- a/inline.c
+++ b/inline.c
@@ -519,8 +519,6 @@ int inline_function(struct expression *expr, struct symbol *sym)
 	if (fn->expanding)
 		return 0;
 
-	fn->expanding = 1;
-
 	name_list = fn->arguments;
 
 	expr->type = EXPR_STATEMENT;
@@ -558,9 +556,6 @@ int inline_function(struct expression *expr, struct symbol *sym)
 
 	unset_replace_list(fn_symbol_list);
 
-	evaluate_statement(stmt);
-
-	fn->expanding = 0;
 	return 1;
 }
 
-- 
2.25.0

================================================================================


################################################################################

=== Thread: [PATCH] doc: add some info to the main page ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] doc: add some info to the main page
Date: Sun, 21 Jun 2020 09:39:28 +0000
Message-ID: <20200621093928.40272-1-luc.vanoostenryck () gmail ! com>
--------------------
Add some info about:
* how to get sparse
* how to install it,
* the mailing list and how to report bugs.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/index.rst | 40 ++++++++++++++++++++++++++++++----------
 1 file changed, 30 insertions(+), 10 deletions(-)

diff --git a/Documentation/index.rst b/Documentation/index.rst
index 415da4bb27af..737f442323b5 100644
--- a/Documentation/index.rst
+++ b/Documentation/index.rst
@@ -25,23 +25,43 @@ by Christopher Li in 2009 and by Luc Van Oostenryck in late 2018.
 Getting Sparse
 --------------
 
-You can find released versions of sparse at http://www.kernel.org/pub/software/devel/sparse/dist/
+You can find tarballs of released versions of Sparse at
+http://www.kernel.org/pub/software/devel/sparse/dist/.
 
-Obtaining sparse via Git
-~~~~~~~~~~~~~~~~~~~~~~~~
-
-Sparse uses the `Git version control system <http://git-scm.com/>`_. You can obtain the most recent version of sparse directly from the Git repository with the command::
+The most recent version can be obtained directly from the Git
+repository with the command::
 
 	git clone git://git.kernel.org/pub/scm/devel/sparse/sparse.git
 
-You can also `browse the Git repository <https://git.kernel.org/pub/scm/devel/sparse/sparse.git>`_.
+You can also `browse the Git repository <https://git.kernel.org/pub/scm/devel/sparse/sparse.git>`_
+or use the mirror at https://github.com/lucvoo/sparse.
+
+Once you have the sources, to build Sparse and install it in your ~/bin
+directory, just do::
+
+	cd sparse
+	make
+	make install
+
+To install it in another directory, use::
+
+	make PREFIX=<some directory> install
+
+Contributing and reporting bugs
+-------------------------------
 
-Mailing list
-~~~~~~~~~~~~
+Submission of patches and reporting of bugs, as well as discussions
+related to Sparse, should be done via the mailing list:
+linux-sparse@vger.kernel.org.
+You do not have to be subscribed to the list to send a message there.
+Previous discussions and bug reports are available on the list
+archives at https://marc.info/?l=linux-sparse.
 
-Discussions about sparse occurs on the sparse mailing list, linux-sparse@vger.kernel.org. To subscribe to the list, send an email with ``subscribe linux-sparse`` in the body to ``majordomo@vger.kernel.org``.
+To subscribe to the list, send an email with
+``subscribe linux-sparse`` in the body to ``majordomo@vger.kernel.org``.
 
-You can browse the list archives at https://marc.info/?l=linux-sparse.
+Bugs can also be reported and tracked via the Linux kernel's bugzilla:
+http://bugzilla.kernel.org/enter_bug.cgi?component=Sparse&product=Tools.
 
 User documentation
 ------------------
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] doc: reformulate an item in the TODO ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] doc: reformulate an item in the TODO
Date: Tue, 16 Jun 2020 21:04:13 +0000
Message-ID: <20200616210413.77884-1-luc.vanoostenryck () gmail ! com>
--------------------
One of the item wasn't even grammatical. Reformulate it.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/TODO.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Documentation/TODO.md b/Documentation/TODO.md
index 64c1523cdbd0..e2043e481f99 100644
--- a/Documentation/TODO.md
+++ b/Documentation/TODO.md
@@ -84,8 +84,8 @@ Longer term/to investigate
 
 	"warning: Variable length array is used. (-Wno-vla)"
 
-* ptrlists must have elements be removed while being iterated but this
-  is hard to insure it is not done.
+* ptrlists must not have elements removed while being iterated;
+  this should somehow be enforced.
 * having 'struct symbol' used to represent symbols *and* types is
   quite handy but it also creates lots of problems and complications
 * Possible mixup of symbol for a function designator being not a pointer?
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] doc: use https URLs ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] doc: use https URLs
Date: Wed, 22 Jul 2020 21:47:26 +0000
Message-ID: <20200722214726.36945-1-luc.vanoostenryck () gmail ! com>
--------------------
Use 'https' instead of 'http' for pages needing some level of trust.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/index.rst | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Documentation/index.rst b/Documentation/index.rst
index 737f442323b5..1ea87ae5e0d9 100644
--- a/Documentation/index.rst
+++ b/Documentation/index.rst
@@ -26,7 +26,7 @@ Getting Sparse
 --------------
 
 You can find tarballs of released versions of Sparse at
-http://www.kernel.org/pub/software/devel/sparse/dist/.
+https://www.kernel.org/pub/software/devel/sparse/dist/.
 
 The most recent version can be obtained directly from the Git
 repository with the command::
@@ -61,7 +61,7 @@ To subscribe to the list, send an email with
 ``subscribe linux-sparse`` in the body to ``majordomo@vger.kernel.org``.
 
 Bugs can also be reported and tracked via the Linux kernel's bugzilla:
-http://bugzilla.kernel.org/enter_bug.cgi?component=Sparse&product=Tools.
+https://bugzilla.kernel.org/enter_bug.cgi?component=Sparse&product=Tools.
 
 User documentation
 ------------------
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] evaluate.c: fix a gcc 'may be used uninitialized' warning ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] evaluate.c: fix a gcc 'may be used uninitialized' warning
Date: Sun, 21 Jun 2020 20:18:04 +0000
Message-ID: <20200621201804.iww6chjwknkldo7n () ltop ! local>
--------------------
On Sun, Jun 21, 2020 at 08:34:31PM +0100, Ramsay Jones wrote:
> 
> Signed-off-by: Ramsay Jones <ramsay@ramsayjones.plus.com>
> ---
> 
> Hi Luc,
> 
> Thanks for v0.6.2! :-D
> 
> However, I am seeing a gcc compiler warning:
> 
>     CC      evaluate.o
>   evaluate.c: In function âevaluate_generic_selectionâ:
>   evaluate.c:3310:38: warning: âbaseâ may be used uninitialized in this function [-Wmaybe-uninitialized]
>      if (base->type == SYM_ARRAY && base->array_size) {
>                                     ~~~~^~~~~~~~~~~~
> 
> This patch is just an FYI/quick-fix for this warning. The patch
> I wanted to send, moved the declaration of the base symbol into
> a new block at the 'if (stype->type == SYM_NODE)' conditional,
> which would now include the (indented) SYM_ARRAY conditional
> block. This, of course, meant that the SYM_ARRAY conditional was
> indented too far to the right ... ;-)
> 
> [perhaps this argues for that code to be refactored into a function]

I just saw this warning too. Of course, *after* the release is made.
 
What I had in made while writing the code was:
		base = stype;
		if (stype->type == SYM_NODE)
			base = stype->ctype.base_type;

Your patch here below will work correctly but is not semantically
correct if stype->type != SYM_NODE. Fortunately, it's guaranteed
to always be a SYM_NODE (typename() is so). So, I'll probably
commit the following:

-               if (stype->type == SYM_NODE)
-                       base = stype->ctype.base_type;
-
+               base = stype->ctype.base_type;

Thanks for the bug report and for giving a try to the release.
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] evaluate: mark evaluate_generic_selection() as static ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: [PATCH] evaluate: mark evaluate_generic_selection() as static
Date: Sat, 30 May 2020 17:51:38 +0000
Message-ID: <37ef319f-ed1e-071d-ff4b-cb3a997fbf65 () ramsayjones ! plus ! com>
--------------------

Commit c100a7ab (add support for _Generic, 2020-05-28) added the
function evaluate_generic_selection() as an external symbol, without
providing an external declaration in a header file. This causes
sparse to issue a warning as part of the 'selfcheck' target.

Since this function does not (currently) need to be an external symbol,
mark it as static.

Signed-off-by: Ramsay Jones <ramsay@ramsayjones.plus.com>
---
 evaluate.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index 5f2b7d6f..8d2e6869 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3280,7 +3280,7 @@ static int type_selection(struct symbol *ctrl, struct symbol *type)
 	return !type_difference(&c, &t, 0, 0);
 }
 
-struct symbol *evaluate_generic_selection(struct expression *expr)
+static struct symbol *evaluate_generic_selection(struct expression *expr)
 {
 	struct type_expression *map;
 	struct expression *res;
-- 
2.26.2
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] evaluate: mark evaluate_generic_selection() as static
Date: Sat, 30 May 2020 17:58:46 +0000
Message-ID: <20200530175846.65it7dkpk4shjhrk () ltop ! local>
--------------------
On Sat, May 30, 2020 at 06:51:38PM +0100, Ramsay Jones wrote:
> 
> Commit c100a7ab (add support for _Generic, 2020-05-28) added the
> function evaluate_generic_selection() as an external symbol, without
> providing an external declaration in a header file. This causes
> sparse to issue a warning as part of the 'selfcheck' target.
> 
> Since this function does not (currently) need to be an external symbol,
> mark it as static.

Hmm, yes. I should taste my own dogfood and use 'make selfcheck' ...
Thanks.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH] fix Hurd PATH_MAX ... ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix Hurd PATH_MAX ...
Date: Wed, 30 Sep 2020 23:38:56 +0000
Message-ID: <20200930233856.67063-1-luc.vanoostenryck () gmail ! com>
--------------------
The fix quickly added for Hurd not defining PATH_MAX is not correct:
the local define must be guaranteed to be done only after <limits.h>
is included, which is not.

Since this problem only exists with Hurd, simply conditionalize
the local define by __gnu_hurd__. Horrible but well ... Hurd.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib.h b/lib.h
index b35debc83288..0b1d4492e6bd 100644
--- a/lib.h
+++ b/lib.h
@@ -44,7 +44,7 @@
 #define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
 #endif
 
-#ifndef PATH_MAX
+#ifdef __gnu_hurd__
 #define PATH_MAX 4096			// Hurd doesn't define this
 #endif
 
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH] fix evaluate_ptr_add() when sizeof(offset) != sizeof(pointer) ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix evaluate_ptr_add() when sizeof(offset) != sizeof(pointer)
Date: Sat, 15 Aug 2020 16:12:53 +0000
Message-ID: <20200815161253.3397-1-luc.vanoostenryck () gmail ! com>
--------------------
For a binary op, both sides need to be converted to the resulting
type of the usual conversion. For a compound-assignment (which
is equivalent to a binary op followed by an assignment), the LHS
can't be so converted since its type needs to preserved for
the assignment, so only the RHS is converted at evaluation and
the type of the RHS is used at linearization to convert the LHS.

However, in the case of pointer arithmetics, a number of shortcuts
are taken and as a result additions with mixed sizes can be produced
producing invalid IR.

So, fix this by converting the RHS to the same size as pointers,
as done for 'normal' binops.

Note: On 32-bit kernel, this patch also removes a few warnings
      about non size-preserving casts. It's fine as these warnings
      were designed for when an address would be stored in an
      integer, not for storing an offset like it's the case here.

Reported-by: Valentin Schneider <valentin.schneider@arm.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 63a9390b5ee7..1839e35d039f 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -619,7 +619,7 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
 		ctype = &ptr_ctype;
 	expr->ctype = ctype;
 
-	if (multiply == 1 && itype->bit_size >= bits_in_pointer)
+	if (multiply == 1 && itype->bit_size == bits_in_pointer)
 		return ctype;
 
 	if (index->type == EXPR_VALUE) {
@@ -639,7 +639,7 @@ static struct symbol *evaluate_ptr_add(struct expression *expr, struct symbol *i
 		return ctype;
 	}
 
-	if (itype->bit_size < bits_in_pointer)
+	if (itype->bit_size != bits_in_pointer)
 		index = cast_to(index, ssize_t_ctype);
 
 	if (multiply > 1) {
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH] fix init_linearized_builtins() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix init_linearized_builtins()
Date: Fri, 30 Oct 2020 15:36:29 +0000
Message-ID: <20201030153629.18989-1-luc.vanoostenryck () gmail ! com>
--------------------
Hmmm ... the wrong pointer was updated. Fix this.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index 1081bda86425..85d370de5728 100644
--- a/linearize.c
+++ b/linearize.c
@@ -2631,6 +2631,6 @@ void init_linearized_builtins(int stream)
 		if (!sym->op)
 			sym->op = &ptr->op;
 		sym->op->type |= KW_BUILTIN;
-		ptr->op.linearize = ptr->linearize;
+		sym->op->linearize = ptr->linearize;
 	}
 }
-- 
2.29.1

================================================================================


################################################################################

=== Thread: [PATCH] fix stream_prev() for invalid (negative) stream ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix stream_prev() for invalid (negative) stream
Date: Wed, 29 Jul 2020 22:01:49 +0000
Message-ID: <20200729220149.96272-1-luc.vanoostenryck () gmail ! com>
--------------------
Now that the parent stream is stored as a position, the validity
of a stream can't anymore be tested by checking if its number
is non-negative because inside a struct position stream number
are stored as an unsigned (and changing it to signed would halve
the maximum number of stream).

So, add a check against input_stream_nr before returning the
previous stream.

Fixes: 4c6cbe557c48205f9b3d2aae4c166cd66446b240
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 tokenize.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/tokenize.c b/tokenize.c
index d68fbcd8eebd..ca842f52882b 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -66,7 +66,10 @@ int stream_prev(int stream)
 {
 	if (stream < 0 || stream > input_stream_nr)
 		return -1;
-	return input_streams[stream].pos.stream;
+	stream = input_streams[stream].pos.stream;
+	if (stream > input_stream_nr)
+		return -1;
+	return stream;
 }
 
 static struct position stream_pos(stream_t *stream)
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH] fix type compatibility of _Atomic ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix type compatibility of _Atomic
Date: Thu, 06 Feb 2020 21:43:51 +0000
Message-ID: <20200206214351.20197-1-luc.vanoostenryck () gmail ! com>
--------------------
When _atomic was introduced, for most purposes it was treated
like the other qualifiers.

However, it's best to consider _Atomic as an qualifier only for
syntaxic reasons. In particular, an _Atomic type may have different
size and alignment that its corresponding unqualified type.
Also, an _Atomic type is never compatible with its corresponding
unqualified type, and thus, for type checking, this qualifier must
never be ignored.

Fix this by removing MOD_ATOMIC from MOD_QUALIFIER. Essentially, this
has the effect to stop to ignore MOD_ATOMIC when comparing types.

Fixes: ffe9f9fef003d29b65d29b8da5416aff72baff5a
Repoted-by: Ramsay Jones <ramsay@ramsayjones.plus.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h                 |  6 ++---
 validation/c11-atomic.c  | 58 +++++++++++++++++++++++++---------------
 validation/typeof-mods.c |  2 +-
 3 files changed, 41 insertions(+), 25 deletions(-)

diff --git a/symbol.h b/symbol.h
index 9ef5a886172f..2b8aa2d831dd 100644
--- a/symbol.h
+++ b/symbol.h
@@ -248,10 +248,10 @@ struct symbol {
 #define MOD_SIGNEDNESS	(MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED)
 #define MOD_SPECIFIER	MOD_SIGNEDNESS
 #define MOD_IGNORE	(MOD_STORAGE | MOD_ACCESS | MOD_USERTYPE | MOD_EXPLICITLY_SIGNED | MOD_EXT_VISIBLE)
-#define	MOD_QUALIFIER	(MOD_CONST | MOD_VOLATILE | MOD_RESTRICT | MOD_ATOMIC)
-#define MOD_PTRINHERIT	(MOD_QUALIFIER | MOD_NODEREF | MOD_NORETURN | MOD_NOCAST)
+#define MOD_QUALIFIER	(MOD_CONST | MOD_VOLATILE | MOD_RESTRICT)
+#define MOD_PTRINHERIT	(MOD_QUALIFIER | MOD_ATOMIC | MOD_NODEREF | MOD_NORETURN | MOD_NOCAST)
 /* modifiers preserved by typeof() operator */
-#define MOD_TYPEOF	(MOD_QUALIFIER | MOD_NOCAST | MOD_SPECIFIER)
+#define MOD_TYPEOF	(MOD_QUALIFIER | MOD_ATOMIC | MOD_NOCAST | MOD_SPECIFIER)
 /* modifiers for function attributes */
 #define MOD_FUN_ATTR	(MOD_PURE|MOD_NORETURN)
 /* like cvr-qualifiers but 'reversed' (OK: source <= target) */
diff --git a/validation/c11-atomic.c b/validation/c11-atomic.c
index 17720861ffb7..85461f64d1d3 100644
--- a/validation/c11-atomic.c
+++ b/validation/c11-atomic.c
@@ -6,7 +6,7 @@ void f03(int _Atomic *dst);
 int _Atomic qo;
 int         uo;
 
-void f00(int dst)	  { }	/* check-should-pass */
+void f00(int dst)	  { }	/* check-should-fail */
 void f01(typeof(&qo) dst) { }	/* check-should-pass */
 void f02(int *dst)	  { }	/* check-should-fail */
 void f03(typeof(&uo) dst) { }	/* check-should-fail */
@@ -21,12 +21,12 @@ void ref(void)
 {
 	const int qo;
 	int uo;
-	extern const int *pqo;
-	extern       int *puo;
+	const int *pqo;
+	      int *puo;
 
 	pqo = &qo;		/* check-should-pass */
 	pqo = &uo;		/* check-should-pass */
-	pqo = puo;
+	pqo = puo;		/* check-should-pass */
 
 	puo = &uo;		/* check-should-pass */
 
@@ -36,12 +36,12 @@ void ref(void)
 
 void bar(void)
 {
-	extern int _Atomic *pqo;
-	extern int         *puo;
+	int _Atomic *pqo;
+	int         *puo;
 
 	pqo = &qo;		/* check-should-pass */
-	pqo = &uo;		/* check-should-pass */
-	pqo = puo;
+	pqo = &uo;		/* check-should-fail */
+	pqo = puo;		/* check-should-fail */
 
 	puo = &uo;		/* check-should-pass */
 
@@ -51,12 +51,12 @@ void bar(void)
 
 void baz(void)
 {
-	extern typeof(&qo) pqo;
-	extern typeof(&uo) puo;
+	typeof(&qo) pqo;
+	typeof(&uo) puo;
 
 	pqo = &qo;		/* check-should-pass */
-	pqo = &uo;		/* check-should-pass */
-	pqo = puo;
+	pqo = &uo;		/* check-should-fail*/
+	pqo = puo;		/* check-should-fail */
 
 	puo = &uo;		/* check-should-pass */
 
@@ -69,6 +69,10 @@ void baz(void)
  * check-command: sparse -Wno-decl $file
  *
  * check-error-start
+c11-atomic.c:9:6: error: symbol 'f00' redeclared with different type (incompatible argument 1 (different modifiers)):
+c11-atomic.c:9:6:    void extern [addressable] [toplevel] f00( ... )
+c11-atomic.c:1:6: note: previously declared as:
+c11-atomic.c:1:6:    void extern [addressable] [toplevel] f00( ... )
 c11-atomic.c:11:6: error: symbol 'f02' redeclared with different type (incompatible argument 1 (different modifiers)):
 c11-atomic.c:11:6:    void extern [addressable] [toplevel] f02( ... )
 c11-atomic.c:3:6: note: previously declared as:
@@ -78,22 +82,34 @@ c11-atomic.c:12:6:    void extern [addressable] [toplevel] f03( ... )
 c11-atomic.c:4:6: note: previously declared as:
 c11-atomic.c:4:6:    void extern [addressable] [toplevel] f03( ... )
 c11-atomic.c:33:13: warning: incorrect type in assignment (different modifiers)
-c11-atomic.c:33:13:    expected int *extern [assigned] puo
+c11-atomic.c:33:13:    expected int *[assigned] puo
 c11-atomic.c:33:13:    got int const *
 c11-atomic.c:34:13: warning: incorrect type in assignment (different modifiers)
-c11-atomic.c:34:13:    expected int *extern [assigned] puo
-c11-atomic.c:34:13:    got int const *extern [assigned] pqo
+c11-atomic.c:34:13:    expected int *[assigned] puo
+c11-atomic.c:34:13:    got int const *[assigned] pqo
+c11-atomic.c:43:13: warning: incorrect type in assignment (different modifiers)
+c11-atomic.c:43:13:    expected int [atomic] *[assigned] pqo
+c11-atomic.c:43:13:    got int *
+c11-atomic.c:44:13: warning: incorrect type in assignment (different modifiers)
+c11-atomic.c:44:13:    expected int [atomic] *[assigned] pqo
+c11-atomic.c:44:13:    got int *puo
 c11-atomic.c:48:13: warning: incorrect type in assignment (different modifiers)
-c11-atomic.c:48:13:    expected int *extern [assigned] puo
+c11-atomic.c:48:13:    expected int *[assigned] puo
 c11-atomic.c:48:13:    got int [atomic] *
 c11-atomic.c:49:13: warning: incorrect type in assignment (different modifiers)
-c11-atomic.c:49:13:    expected int *extern [assigned] puo
-c11-atomic.c:49:13:    got int [atomic] *extern [assigned] pqo
+c11-atomic.c:49:13:    expected int *[assigned] puo
+c11-atomic.c:49:13:    got int [atomic] *[assigned] pqo
+c11-atomic.c:58:13: warning: incorrect type in assignment (different modifiers)
+c11-atomic.c:58:13:    expected int [atomic] *[assigned] pqo
+c11-atomic.c:58:13:    got int *
+c11-atomic.c:59:13: warning: incorrect type in assignment (different modifiers)
+c11-atomic.c:59:13:    expected int [atomic] *[assigned] pqo
+c11-atomic.c:59:13:    got int *puo
 c11-atomic.c:63:13: warning: incorrect type in assignment (different modifiers)
-c11-atomic.c:63:13:    expected int *extern [assigned] puo
+c11-atomic.c:63:13:    expected int *[assigned] puo
 c11-atomic.c:63:13:    got int [atomic] *
 c11-atomic.c:64:13: warning: incorrect type in assignment (different modifiers)
-c11-atomic.c:64:13:    expected int *extern [assigned] puo
-c11-atomic.c:64:13:    got int [atomic] *extern [assigned] pqo
+c11-atomic.c:64:13:    expected int *[assigned] puo
+c11-atomic.c:64:13:    got int [atomic] *[assigned] pqo
  * check-error-end
  */
diff --git a/validation/typeof-mods.c b/validation/typeof-mods.c
index aa880f373088..117269c027ed 100644
--- a/validation/typeof-mods.c
+++ b/validation/typeof-mods.c
@@ -102,7 +102,7 @@ static void test_static(void)
 
 static void test_tls(void)
 {
-	__thread int obj, *ptr;
+	static __thread int obj, *ptr;
 	typeof(obj) var = obj;
 	typeof(ptr) ptr2 = ptr;
 	typeof(*ptr) var2 = obj;

base-commit: 100509c0789f1176fc5881da45917e9af77597ca
-- 
2.25.0

================================================================================


################################################################################

=== Thread: [PATCH] force to 0 expressions which are erroneously non-constant ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] force to 0 expressions which are erroneously non-constant
Date: Sun, 09 Aug 2020 16:41:05 +0000
Message-ID: <20200809164105.36446-1-luc.vanoostenryck () gmail ! com>
--------------------
When an expression that needs to be constant but is, in fact,
not constant, sparse throws an error and leaves it as-is.
But some code makes the assumption that the expression is
constant and uses its value, with some random result.

One situation where this happens is in code like:
	switch (x) {
	case <some non-const expression>: ...

In this case, the linearization of the switch/case statement
will unconditionally use the value of the case expression
but the expression has no value.

One way to avoid this would be to add defensive checks each
time a value is retrieved but this is a lot of work and time
for no benefits.

So, change this by forcing the expression to be a constant
value of 0 just after the error message has been issued.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expand.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/expand.c b/expand.c
index 623b180025ad..c4f806dee1ba 100644
--- a/expand.c
+++ b/expand.c
@@ -1177,8 +1177,12 @@ static void expand_const_expression(struct expression *expr, const char *where)
 {
 	if (expr) {
 		expand_expression(expr);
-		if (expr->type != EXPR_VALUE)
+		if (expr->type != EXPR_VALUE) {
 			expression_error(expr, "Expected constant expression in %s", where);
+			expr->ctype = &int_ctype;
+			expr->type = EXPR_VALUE;
+			expr->value = 0;
+		}
 	}
 }
 
-- 
2.28.0

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] force to 0 expressions which are erroneously non-constant
Date: Mon, 10 Aug 2020 05:51:03 +0000
Message-ID: <20200810055103.67977-1-luc.vanoostenryck () gmail ! com>
--------------------
When an expression that needs to be constant but is, in fact,
not constant, sparse throws an error and leaves it as-is.
But some code makes the assumption that the expression is
constant and uses its value, with some random result.

One situation where this happens is in code like:
	switch (x) {
	case <some non-const expression>: ...

In this case, the linearization of the switch/case statement
will unconditionally use the value of the case expression
but the expression has no value.

One way to avoid this would be to add defensive checks each
time a value is retrieved but this is a lot of work and time
for no benefits.

So, change this by forcing the expression to be a constant
value of 0 just after the error message has been issued.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expand.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/expand.c b/expand.c
index 623b180025ad..c4f806dee1ba 100644
--- a/expand.c
+++ b/expand.c
@@ -1177,8 +1177,12 @@ static void expand_const_expression(struct expression *expr, const char *where)
 {
 	if (expr) {
 		expand_expression(expr);
-		if (expr->type != EXPR_VALUE)
+		if (expr->type != EXPR_VALUE) {
 			expression_error(expr, "Expected constant expression in %s", where);
+			expr->ctype = &int_ctype;
+			expr->type = EXPR_VALUE;
+			expr->value = 0;
+		}
 	}
 }
 
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH] generic: fix missing inlining of generic expression ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] generic: fix missing inlining of generic expression
Date: Fri, 24 Jul 2020 22:26:54 +0000
Message-ID: <20200724222654.43141-1-luc.vanoostenryck () gmail ! com>
--------------------
Inlining in sparse works slightly differently than what my
mental model is: the body is only evaluated after the inline
expansion. IOW, an inline function is not evaluated until it
is effectively inlined. That's fine but it means that generic
expressions also need to be handled during the inlining.

However, since the body of inline functions is evaluated just
after inline expansion, so (recursively) copying the expression
and its type - expression map is quite useless here.

So, just copy the expression itself and its control expression
to 'isolate' them from evaluation, evaluate it and then just
copy the selected expression.

Reported-by: Peter Zijlstra <peterz@infradead.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 inline.c                    |  8 ++++++++
 validation/inline-generic.c | 10 ++++++++++
 2 files changed, 18 insertions(+)

This patch is also available for testing on sparse-dev repo:
 git://git.kernel.org/pub/scm/devel/sparse/sparse-dev.git gen-crash

diff --git a/inline.c b/inline.c
index a959728013f1..eceef8ba0443 100644
--- a/inline.c
+++ b/inline.c
@@ -274,6 +274,14 @@ static struct expression * copy_expression(struct expression *expr)
 		}
 		break;
 	}
+	case EXPR_GENERIC:
+		expr = dup_expression(expr);
+		expr->control = copy_expression(expr->control);
+		if (!evaluate_expression(expr))
+			return NULL;
+		expr = copy_expression(expr);
+		break;
+
 	default:
 		warning(expr->pos, "trying to copy expression type %d", expr->type);
 	}
diff --git a/validation/inline-generic.c b/validation/inline-generic.c
new file mode 100644
index 000000000000..1f05c07904b5
--- /dev/null
+++ b/validation/inline-generic.c
@@ -0,0 +1,10 @@
+extern int a, b;
+inline int c(void) { return a++; }
+inline int e(int d) { return 0; }
+inline unsigned f(void) { return e(_Generic(b, int: c())); }
+static int g(void) { return f(); }
+static int h(void) { return f(); }
+
+/*
+ * check-name: inline-generic
+ */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] gensel: remove unneeded test/uninitialized warning ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] gensel: remove unneeded test/uninitialized warning
Date: Mon, 22 Jun 2020 22:38:54 +0000
Message-ID: <20200622223854.87802-1-luc.vanoostenryck () gmail ! com>
--------------------
When evaluation generic selections, it is tested if the type in
the selection is a SYM_NODE or not, but:
* all these are SYM_NODE
* the variable for the base type would be uninitialized
  if not a SYM_NODE.

So, remove the test and unconditionally set the base type.

Reported-by: Ramsay Jones <ramsay@ramsayjones.plus.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index aa0f208006bb..461c2547285f 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3304,9 +3304,7 @@ static struct symbol *evaluate_generic_selection(struct expression *expr)
 		if (!evaluate_symbol(stype))
 			continue;
 
-		if (stype->type == SYM_NODE)
-			base = stype->ctype.base_type;
-
+		base = stype->ctype.base_type;
 		if (base->type == SYM_ARRAY && base->array_size) {
 			get_expression_value_silent(base->array_size);
 			if (base->array_size->type == EXPR_VALUE)
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] handle more graciously labels with no statement ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] handle more graciously labels with no statement
Date: Mon, 26 Oct 2020 04:53:38 +0000
Message-ID: <20201026045338.55218-1-luc.vanoostenryck () gmail ! com>
--------------------
In C a label must precede a statement. A null statement is OK
but a closing braces is not.

So, catch this situation, emit a warning and continue as if a
null statement was there.

This occurs currently on v5.10-rc1 because of some ifdefery.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/parse.c b/parse.c
index 31ecef0f554d..b6090d38cc61 100644
--- a/parse.c
+++ b/parse.c
@@ -2468,6 +2468,11 @@ static struct token *statement(struct token *token, struct statement **tree)
 					warn_label_usage(stmt->pos, s->label_pos, s->ident);
 			}
 			s->stmt = stmt;
+			if (match_op(token, '}')) {
+				warning(token->pos, "statement expected after label");
+				stmt->label_statement = alloc_statement(token->pos, STMT_NONE);
+				return token;
+			}
 			return statement(token, &stmt->label_statement);
 		}
 	}
-- 
2.29.0

================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] handle more graciously labels with no statement
Date: Mon, 26 Oct 2020 17:41:36 +0000
Message-ID: <CAHk-=wigYApoRH_LS2wu-i7fNp0wF1eJz27od02oo124qXvBjw () mail ! gmail ! com>
--------------------
On Sun, Oct 25, 2020 at 9:53 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> This occurs currently on v5.10-rc1 because of some ifdefery.

Well, sparse being more robust is good, so the patch looks sane to me..

But can you point to the actual 5.10-rc1 problem? I haven't seen the
report, and afaik gcc will complain about this too ("label at end of
compound statement") so I'm surprised sparse hits it..

                Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] handle more graciously labels with no statement
Date: Mon, 26 Oct 2020 20:48:47 +0000
Message-ID: <20201026204847.h3uokzvm74g5ykcn () ltop ! local>
--------------------
On Mon, Oct 26, 2020 at 10:41:36AM -0700, Linus Torvalds wrote:
> On Sun, Oct 25, 2020 at 9:53 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > This occurs currently on v5.10-rc1 because of some ifdefery.
> 
> Well, sparse being more robust is good, so the patch looks sane to me..
> 
> But can you point to the actual 5.10-rc1 problem? I haven't seen the
> report, and afaik gcc will complain about this too ("label at end of
> compound statement") so I'm surprised sparse hits it..

Well, I was surprised it wasn't caught and was ready to send a patch
but it can only happen when using sparse, see below, quite ironical:
	drivers/scsi/qla2xxx/qla_tmpl.c:1052.
	1050         }
	1051 
	1052 bailout:
	1053 #ifndef __CHECKER__
	1054         if (!hardware_locked)
	1055                 spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
	1056 #endif
	1057 }


-- Luc
================================================================================

From: Bart Van Assche <bvanassche () acm ! org>
To: linux-sparse
Subject: Re: [PATCH] handle more graciously labels with no statement
Date: Mon, 26 Oct 2020 23:22:12 +0000
Message-ID: <3abeaeef-ddde-5c47-f79b-4c61a0820c08 () acm ! org>
--------------------
On 10/26/20 3:56 PM, Linus Torvalds wrote:
> On Mon, Oct 26, 2020 at 1:48 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> On Mon, Oct 26, 2020 at 10:41:36AM -0700, Linus Torvalds wrote:
>>> But can you point to the actual 5.10-rc1 problem? I haven't seen the
>>> report, and afaik gcc will complain about this too ("label at end of
>>> compound statement") so I'm surprised sparse hits it..
>>
>> Well, I was surprised it wasn't caught and was ready to send a patch
>> but it can only happen when using sparse, see below, quite ironic:
>>         drivers/scsi/qla2xxx/qla_tmpl.c:1052.
>>         1050         }
>>         1051
>>         1052 bailout:
>>         1053 #ifndef __CHECKER__
>>         1054         if (!hardware_locked)
>>         1055                 spin_unlock_irqrestore(&vha->hw->hardware_lock, flags);
>>         1056 #endif
>>         1057 }
> 
> Yeah, that "don't sparse this" pattern has been problematic before.
> 
> I removed it.
> 
> Bart, Arun - see commit 4525c8781ec0 ("scsi: qla2xxx: remove incorrect
> sparse #ifdef").

Hi Linus,

Thank you for having Cc-ed me. I agree that it's better to make the
kernel code compliant with the C standard than to make sparse accept
non-standard code.

The #ifndef __CHECKER__ / #endif that I added in 2015 in the above code
(commit 8d16366b5f23) was added because at that time I didn't see a
better solution.

BTW, personally I'm neither enthusiast about #ifndef __CHECKER__ /
#endif nor about if (expression) <locking statement>.

Bart.
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] handle more graciously labels with no statement
Date: Mon, 26 Oct 2020 23:39:23 +0000
Message-ID: <CAHk-=wh=Uf4DydFyii-nFe-a2SjRemPr9w0iw+aK8rL8_MjEYA () mail ! gmail ! com>
--------------------
On Mon, Oct 26, 2020 at 4:22 PM Bart Van Assche <bvanassche@acm.org> wrote:
>
> The #ifndef __CHECKER__ / #endif that I added in 2015 in the above code
> (commit 8d16366b5f23) was added because at that time I didn't see a
> better solution.

I think there are only a couple of callers, and all of them just have
a constant "device_locked" argument.

It should be easy to make the (I think single) use that _didn't_ lock
the device just do the locking, and then all of them have
"device_locked = 1", and then that argument can be removed and the
whole conditional be replaced by a lockdep assert.

Exactly like y9ou did in 8ae178760b23 ("scsi: qla2xxx: Simplify the
functions for dumping firmware") in other words.

But I didn't really look _that_ much into it, this is just from a
simple "grep" thing and maybe I missed something. I just did the
minimal "don't do invalid C" thing.

              Linus
================================================================================


################################################################################

=== Thread: [PATCH] ir-validate: remove orphan comments ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] ir-validate: remove orphan comments
Date: Thu, 18 Jun 2020 18:58:47 +0000
Message-ID: <20200618185847.ib25p2kt7kbsudbo () ltop ! local>
--------------------
On Thu, Jun 18, 2020 at 04:09:14PM +0200, garritfra wrote:

Hi,

> Please let me know if these comments have a right to be there, but I
> think they are orphans and can be removed.

Indeed, they have been commited more or less by error and have
never been removed.

Thanks for the patch.
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] kill dead instructions before any other simplifications ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] kill dead instructions before any other simplifications
Date: Sun, 25 Oct 2020 12:52:29 +0000
Message-ID: <20201025125229.20350-1-luc.vanoostenryck () gmail ! com>
--------------------
Dead instructions are removed when simplify_instruction() is
called but this is done in various places, depending on the kind
of instructions, sometimes after other simplifications.

Change this by using the instruction's flag OPF_TARGET at the very
beginning of simplify_instruction() to test which instructions are
dead and thus can be removed.

Note: OP_CALLs are special here as they're considered as always
      returning a value but only calls to pure functions are
      removed. This is OK since pure functions should always
      return a value.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 51 +++++----------------------------------------------
 1 file changed, 5 insertions(+), 46 deletions(-)

diff --git a/simplify.c b/simplify.c
index 6caf6cbcf918..f91aaa69dd81 100644
--- a/simplify.c
+++ b/simplify.c
@@ -388,20 +388,6 @@ int kill_insn(struct instruction *insn, int force)
 	return repeat_phase |= REPEAT_CSE;
 }
 
-///
-// kill trivially dead instructions
-static int dead_insn(struct instruction *insn, pseudo_t *src1, pseudo_t *src2, pseudo_t *src3)
-{
-	if (has_users(insn->target))
-		return 0;
-
-	insn->bb = NULL;
-	kill_use(src1);
-	kill_use(src2);
-	kill_use(src3);
-	return REPEAT_CSE;
-}
-
 static inline bool has_target(struct instruction *insn)
 {
 	return opcode_table[insn->opcode].flags & OPF_TARGET;
@@ -1270,8 +1256,6 @@ static int simplify_binop_same_args(struct instruction *insn, pseudo_t arg)
 
 static int simplify_binop(struct instruction *insn)
 {
-	if (dead_insn(insn, &insn->src1, &insn->src2, NULL))
-		return REPEAT_CSE;
 	if (constant(insn->src1)) {
 		if (constant(insn->src2))
 			return simplify_constant_binop(insn);
@@ -1451,8 +1435,6 @@ static int simplify_constant_unop(struct instruction *insn)
 
 static int simplify_unop(struct instruction *insn)
 {
-	if (dead_insn(insn, &insn->src1, NULL, NULL))
-		return REPEAT_CSE;
 	if (constant(insn->src1))
 		return simplify_constant_unop(insn);
 
@@ -1543,16 +1525,11 @@ static int simplify_cast(struct instruction *insn)
 {
 	unsigned long long mask;
 	struct instruction *def;
-	pseudo_t src;
+	pseudo_t src = insn->src;
 	pseudo_t val;
 	int osize;
 	int size;
 
-	if (dead_insn(insn, &insn->src, NULL, NULL))
-		return REPEAT_CSE;
-
-	src = insn->src;
-
 	/* A cast of a constant? */
 	if (constant(src))
 		return simplify_constant_unop(insn);
@@ -1687,9 +1664,6 @@ static int simplify_select(struct instruction *insn)
 {
 	pseudo_t cond, src1, src2;
 
-	if (dead_insn(insn, &insn->src1, &insn->src2, &insn->src3))
-		return REPEAT_CSE;
-
 	cond = insn->src1;
 	src1 = insn->src2;
 	src2 = insn->src3;
@@ -1861,6 +1835,10 @@ int simplify_instruction(struct instruction *insn)
 		return 0;
 
 	flags = opcode_table[insn->opcode].flags;
+	if (flags & OPF_TARGET) {
+		if (!has_users(insn->target))
+			return kill_instruction(insn);
+	}
 	if (flags & OPF_COMMU)
 		canonicalize_commutative(insn) ;
 	if (flags & OPF_COMPARE)
@@ -1906,14 +1884,9 @@ int simplify_instruction(struct instruction *insn)
 	case OP_SET_AE:
 		break;
 	case OP_LOAD:
-		if (!has_users(insn->target))
-			return kill_instruction(insn);
-		/* fall-through */
 	case OP_STORE:
 		return simplify_memop(insn);
 	case OP_SYMADDR:
-		if (dead_insn(insn, &insn->src, NULL, NULL))
-			return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
 		return replace_with_pseudo(insn, insn->src);
 	case OP_SEXT: case OP_ZEXT:
 	case OP_TRUNC:
@@ -1923,30 +1896,18 @@ int simplify_instruction(struct instruction *insn)
 	case OP_UCVTF: case OP_SCVTF:
 	case OP_FCVTF:
 	case OP_PTRCAST:
-		if (dead_insn(insn, &insn->src, NULL, NULL))
-			return REPEAT_CSE;
 		break;
 	case OP_UTPTR:
 	case OP_PTRTU:
 		return replace_with_pseudo(insn, insn->src);
 	case OP_SLICE:
-		if (dead_insn(insn, &insn->src, NULL, NULL))
-			return REPEAT_CSE;
 		break;
 	case OP_SETVAL:
 	case OP_SETFVAL:
-		if (dead_insn(insn, NULL, NULL, NULL))
-			return REPEAT_CSE;
 		break;
 	case OP_PHI:
-		if (dead_insn(insn, NULL, NULL, NULL)) {
-			kill_use_list(insn->phi_list);
-			return REPEAT_CSE;
-		}
 		return clean_up_phi(insn);
 	case OP_PHISOURCE:
-		if (dead_insn(insn, &insn->phi_src, NULL, NULL))
-			return REPEAT_CSE;
 		break;
 	case OP_SEL:
 		return simplify_select(insn);
@@ -1960,8 +1921,6 @@ int simplify_instruction(struct instruction *insn)
 	case OP_FSUB:
 	case OP_FMUL:
 	case OP_FDIV:
-		if (dead_insn(insn, &insn->src1, &insn->src2, NULL))
-			return REPEAT_CSE;
 		break;
 	}
 	return 0;

base-commit: cfca7b4c6cb48283cb554fc91dc859ff669f2547
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH] linearize __builtin_isdigit() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] linearize __builtin_isdigit()
Date: Fri, 30 Oct 2020 16:36:05 +0000
Message-ID: <20201030163605.20165-1-luc.vanoostenryck () gmail ! com>
--------------------
As an experiment about the linearization of builtins,
try this easy one (and statically expand it if the
argument is constant).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 builtin.c   | 21 +++++++++++++++++++++
 linearize.c | 22 ++++++++++++++++++++++
 2 files changed, 43 insertions(+)

diff --git a/builtin.c b/builtin.c
index acc49871644c..5c7321cad3e4 100644
--- a/builtin.c
+++ b/builtin.c
@@ -305,6 +305,26 @@ static struct symbol_op fp_unop_op = {
 };
 
 
+static int expand_isdigit(struct expression *expr, int cost)
+{
+	struct expression *arg = first_expression(expr->args);
+	long long val = get_expression_value_silent(arg);
+
+	if (cost)
+		return cost;
+
+	expr->value = (val >= '0') && (val <= '9');
+	expr->type = EXPR_VALUE;
+	expr->taint = 0;
+	return 0;
+}
+
+static struct symbol_op isdigit_op = {
+	.evaluate = evaluate_pure_unop,
+	.expand = expand_isdigit,
+};
+
+
 static int evaluate_overflow_gen(struct expression *expr, int ptr)
 {
 	struct expression *arg;
@@ -552,6 +572,7 @@ static const struct builtin_fn builtins_common[] = {
 	{ "__builtin_inf", &double_ctype, 0 },
 	{ "__builtin_inff", &float_ctype, 0 },
 	{ "__builtin_infl", &ldouble_ctype, 0 },
+	{ "__builtin_isdigit", &int_ctype, 0, { &int_ctype }, .op = &isdigit_op },
 	{ "__builtin_isfinite", &int_ctype, 1, .op = &fp_unop_op },
 	{ "__builtin_isgreater", &int_ctype, 0, { &float_ctype, &float_ctype }},
 	{ "__builtin_isgreaterequal", &int_ctype, 0, { &float_ctype, &float_ctype }},
diff --git a/linearize.c b/linearize.c
index bf9b6ecdc92e..b74651765f6c 100644
--- a/linearize.c
+++ b/linearize.c
@@ -2602,6 +2602,27 @@ static pseudo_t linearize_fma(struct entrypoint *ep, struct expression *expr)
 	return insn->target = alloc_pseudo(insn);
 }
 
+static pseudo_t linearize_isdigit(struct entrypoint *ep, struct expression *expr)
+{
+	struct instruction *insn;
+	pseudo_t src;
+
+	insn = alloc_typed_instruction(OP_SUB, &int_ctype);
+	src = linearize_expression(ep, first_expression(expr->args));
+	use_pseudo(insn, src, &insn->src1);
+	insn->src2 = value_pseudo('0');
+	src = insn->target = alloc_pseudo(insn);
+	add_one_insn(ep, insn);
+
+	insn = alloc_typed_instruction(OP_SET_BE, &int_ctype);
+	use_pseudo(insn, src, &insn->src1);
+	insn->src2 = value_pseudo(9);
+	insn->target = alloc_pseudo(insn);
+	add_one_insn(ep, insn);
+
+	return insn->target;
+}
+
 static pseudo_t linearize_unreachable(struct entrypoint *ep, struct expression *exp)
 {
 	add_unreachable(ep);
@@ -2617,6 +2638,7 @@ static struct sym_init {
 	{ "__builtin_fma", linearize_fma },
 	{ "__builtin_fmaf", linearize_fma },
 	{ "__builtin_fmal", linearize_fma },
+	{ "__builtin_isdigit", linearize_isdigit },
 	{ "__builtin_unreachable", linearize_unreachable },
 	{ }
 };
-- 
2.29.1

================================================================================


################################################################################

=== Thread: [PATCH] linearize: OP_INLINE do not use the function symbol ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] linearize: OP_INLINE do not use the function symbol
Date: Sat, 24 Oct 2020 22:47:16 +0000
Message-ID: <20201024224716.9599-1-luc.vanoostenryck () gmail ! com>
--------------------
The instruction OP_INLINE is a kind of note or comment, indicating
that the code below it used to be the body of a function which has
now been inlined. The symbol of the original function is displayed
when this instruction is displayed but this symbol should not be
considered as being used by the instruction since there is no
dependency or def-use chain between the two.

So, replace the use_pseudo() by a simple assignment.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index 1081bda86425..e16c686ca73a 100644
--- a/linearize.c
+++ b/linearize.c
@@ -2065,7 +2065,7 @@ static pseudo_t linearize_inlined_call(struct entrypoint *ep, struct statement *
 	pseudo = linearize_fn_statement(ep, stmt);
 	insn->target = pseudo;
 
-	use_pseudo(insn, symbol_pseudo(ep, stmt->inline_fn), &insn->func);
+	insn->func = symbol_pseudo(ep, stmt->inline_fn);
 	bb = ep->active;
 	if (!bb->insns)
 		bb->pos = stmt->pos;
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions ===

From: Eric Biggers <ebiggers () kernel ! org>
To: linux-kernel
Subject: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Thu, 26 Dec 2019 15:29:22 +0000
Message-ID: <20191226152922.2034-1-ebiggers () kernel ! org>
--------------------
From: Eric Biggers <ebiggers@google.com>

Wrap refcount_dec_and_lock() and refcount_dec_and_lock_irqsave() with
macros using __cond_lock() so that 'sparse' doesn't report warnings
about unbalanced locking when using them.

This is the same thing that's done for their atomic_t equivalents.

Don't annotate refcount_dec_and_mutex_lock(), because mutexes don't
currently have sparse annotations.

Signed-off-by: Eric Biggers <ebiggers@google.com>
---
 include/linux/refcount.h | 45 ++++++++++++++++++++++++++++++++++++----
 lib/refcount.c           | 39 +++++-----------------------------
 2 files changed, 46 insertions(+), 38 deletions(-)

diff --git a/include/linux/refcount.h b/include/linux/refcount.h
index 0ac50cf62d06..6bb5ab9e98ed 100644
--- a/include/linux/refcount.h
+++ b/include/linux/refcount.h
@@ -300,8 +300,45 @@ static inline void refcount_dec(refcount_t *r)
 extern __must_check bool refcount_dec_if_one(refcount_t *r);
 extern __must_check bool refcount_dec_not_one(refcount_t *r);
 extern __must_check bool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock);
-extern __must_check bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock);
-extern __must_check bool refcount_dec_and_lock_irqsave(refcount_t *r,
-						       spinlock_t *lock,
-						       unsigned long *flags);
+
+/**
+ * refcount_dec_and_lock - return holding spinlock if able to decrement
+ *                         refcount to 0
+ * @r: the refcount
+ * @lock: the spinlock to be locked
+ *
+ * Similar to atomic_dec_and_lock(), it will WARN on underflow and fail to
+ * decrement when saturated at REFCOUNT_SATURATED.
+ *
+ * Provides release memory ordering, such that prior loads and stores are done
+ * before, and provides a control dependency such that free() must come after.
+ * See the comment on top.
+ *
+ * Return: true and hold spinlock if able to decrement refcount to 0, false
+ *         otherwise
+ */
+extern __must_check bool _refcount_dec_and_lock(refcount_t *r,
+						spinlock_t *lock);
+#define refcount_dec_and_lock(r, lock) \
+	__cond_lock(lock, _refcount_dec_and_lock(r, lock))
+
+/**
+ * refcount_dec_and_lock_irqsave - return holding spinlock with disabled
+ *                                 interrupts if able to decrement refcount to 0
+ * @r: the refcount
+ * @lock: the spinlock to be locked
+ * @flags: saved IRQ-flags if the is acquired
+ *
+ * Same as refcount_dec_and_lock() above except that the spinlock is acquired
+ * with disabled interrupts.
+ *
+ * Return: true and hold spinlock if able to decrement refcount to 0, false
+ *         otherwise
+ */
+extern __must_check bool _refcount_dec_and_lock_irqsave(refcount_t *r,
+							spinlock_t *lock,
+							unsigned long *flags);
+#define refcount_dec_and_lock_irqsave(r, lock, flags) \
+	__cond_lock(lock, _refcount_dec_and_lock_irqsave(r, lock, flags))
+
 #endif /* _LINUX_REFCOUNT_H */
diff --git a/lib/refcount.c b/lib/refcount.c
index ebac8b7d15a7..f0eb996b28c0 100644
--- a/lib/refcount.c
+++ b/lib/refcount.c
@@ -125,23 +125,7 @@ bool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock)
 }
 EXPORT_SYMBOL(refcount_dec_and_mutex_lock);
 
-/**
- * refcount_dec_and_lock - return holding spinlock if able to decrement
- *                         refcount to 0
- * @r: the refcount
- * @lock: the spinlock to be locked
- *
- * Similar to atomic_dec_and_lock(), it will WARN on underflow and fail to
- * decrement when saturated at REFCOUNT_SATURATED.
- *
- * Provides release memory ordering, such that prior loads and stores are done
- * before, and provides a control dependency such that free() must come after.
- * See the comment on top.
- *
- * Return: true and hold spinlock if able to decrement refcount to 0, false
- *         otherwise
- */
-bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock)
+bool _refcount_dec_and_lock(refcount_t *r, spinlock_t *lock)
 {
 	if (refcount_dec_not_one(r))
 		return false;
@@ -154,23 +138,10 @@ bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock)
 
 	return true;
 }
-EXPORT_SYMBOL(refcount_dec_and_lock);
+EXPORT_SYMBOL(_refcount_dec_and_lock);
 
-/**
- * refcount_dec_and_lock_irqsave - return holding spinlock with disabled
- *                                 interrupts if able to decrement refcount to 0
- * @r: the refcount
- * @lock: the spinlock to be locked
- * @flags: saved IRQ-flags if the is acquired
- *
- * Same as refcount_dec_and_lock() above except that the spinlock is acquired
- * with disabled interupts.
- *
- * Return: true and hold spinlock if able to decrement refcount to 0, false
- *         otherwise
- */
-bool refcount_dec_and_lock_irqsave(refcount_t *r, spinlock_t *lock,
-				   unsigned long *flags)
+bool _refcount_dec_and_lock_irqsave(refcount_t *r, spinlock_t *lock,
+				    unsigned long *flags)
 {
 	if (refcount_dec_not_one(r))
 		return false;
@@ -183,4 +154,4 @@ bool refcount_dec_and_lock_irqsave(refcount_t *r, spinlock_t *lock,
 
 	return true;
 }
-EXPORT_SYMBOL(refcount_dec_and_lock_irqsave);
+EXPORT_SYMBOL(_refcount_dec_and_lock_irqsave);
-- 
2.24.1

================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Sat, 28 Dec 2019 11:49:18 +0000
Message-ID: <20191228114918.GU2827 () hirez ! programming ! kicks-ass ! net>
--------------------
On Thu, Dec 26, 2019 at 09:29:22AM -0600, Eric Biggers wrote:
> From: Eric Biggers <ebiggers@google.com>
> 
> Wrap refcount_dec_and_lock() and refcount_dec_and_lock_irqsave() with
> macros using __cond_lock() so that 'sparse' doesn't report warnings
> about unbalanced locking when using them.
> 
> This is the same thing that's done for their atomic_t equivalents.
> 
> Don't annotate refcount_dec_and_mutex_lock(), because mutexes don't
> currently have sparse annotations.

I so f'ing hate that __cond_lock() crap. Previously I've suggested
fixing sparse instead of making such an atrocious trainwreck of the
code.
================================================================================

From: Eric Biggers <ebiggers () kernel ! org>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Sat, 28 Dec 2019 20:15:18 +0000
Message-ID: <20191228201518.GA266348 () zzz ! localdomain>
--------------------
On Sat, Dec 28, 2019 at 12:49:18PM +0100, Peter Zijlstra wrote:
> On Thu, Dec 26, 2019 at 09:29:22AM -0600, Eric Biggers wrote:
> > From: Eric Biggers <ebiggers@google.com>
> > 
> > Wrap refcount_dec_and_lock() and refcount_dec_and_lock_irqsave() with
> > macros using __cond_lock() so that 'sparse' doesn't report warnings
> > about unbalanced locking when using them.
> > 
> > This is the same thing that's done for their atomic_t equivalents.
> > 
> > Don't annotate refcount_dec_and_mutex_lock(), because mutexes don't
> > currently have sparse annotations.
> 
> I so f'ing hate that __cond_lock() crap. Previously I've suggested
> fixing sparse instead of making such an atrocious trainwreck of the
> code.

What is your suggestion exactly?  There has to be an annotation for this,
because by design sparse only analyzes individual translation units; it's not a
full-blown static analyzer that operates on the AST for the whole kernel.

- Eric
================================================================================

From: Eric Biggers <ebiggers () kernel ! org>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 30 Dec 2019 19:15:47 +0000
Message-ID: <20191230191547.GA1501 () zzz ! localdomain>
--------------------
On Mon, Dec 30, 2019 at 10:43:20AM -0800, Kees Cook wrote:
> On Sat, Dec 28, 2019 at 12:49:18PM +0100, Peter Zijlstra wrote:
> > On Thu, Dec 26, 2019 at 09:29:22AM -0600, Eric Biggers wrote:
> > > From: Eric Biggers <ebiggers@google.com>
> > > 
> > > Wrap refcount_dec_and_lock() and refcount_dec_and_lock_irqsave() with
> > > macros using __cond_lock() so that 'sparse' doesn't report warnings
> > > about unbalanced locking when using them.
> > > 
> > > This is the same thing that's done for their atomic_t equivalents.
> > > 
> > > Don't annotate refcount_dec_and_mutex_lock(), because mutexes don't
> > > currently have sparse annotations.
> > 
> > I so f'ing hate that __cond_lock() crap. Previously I've suggested
> > fixing sparse instead of making such an atrocious trainwreck of the
> > code.
> 
> Ew, I never noticed these before. That is pretty ugly. Can't __acquire()
> be used directly in the functions instead of building the nasty
> wrappers?

The annotation needs to go in the .h file, not the .c file, because sparse only
analyzes individual translation units.

It needs to be a wrapper macro because it needs to tie the acquisition of the
lock to the return value being true.  I.e. there's no annotation you can apply
directly to the function prototype that means "if this function returns true, it
acquires the lock that was passed in parameter N".

- Eric
================================================================================

From: Kees Cook <keescook () chromium ! org>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 30 Dec 2019 19:32:31 +0000
Message-ID: <201912301131.2C7C51E8C6 () keescook>
--------------------
On Mon, Dec 30, 2019 at 01:15:47PM -0600, Eric Biggers wrote:
> On Mon, Dec 30, 2019 at 10:43:20AM -0800, Kees Cook wrote:
> > On Sat, Dec 28, 2019 at 12:49:18PM +0100, Peter Zijlstra wrote:
> > > On Thu, Dec 26, 2019 at 09:29:22AM -0600, Eric Biggers wrote:
> > > > From: Eric Biggers <ebiggers@google.com>
> > > > 
> > > > Wrap refcount_dec_and_lock() and refcount_dec_and_lock_irqsave() with
> > > > macros using __cond_lock() so that 'sparse' doesn't report warnings
> > > > about unbalanced locking when using them.
> > > > 
> > > > This is the same thing that's done for their atomic_t equivalents.
> > > > 
> > > > Don't annotate refcount_dec_and_mutex_lock(), because mutexes don't
> > > > currently have sparse annotations.
> > > 
> > > I so f'ing hate that __cond_lock() crap. Previously I've suggested
> > > fixing sparse instead of making such an atrocious trainwreck of the
> > > code.
> > 
> > Ew, I never noticed these before. That is pretty ugly. Can't __acquire()
> > be used directly in the functions instead of building the nasty
> > wrappers?
> 
> The annotation needs to go in the .h file, not the .c file, because sparse only
> analyzes individual translation units.
> 
> It needs to be a wrapper macro because it needs to tie the acquisition of the
> lock to the return value being true.  I.e. there's no annotation you can apply
> directly to the function prototype that means "if this function returns true, it
> acquires the lock that was passed in parameter N".

Gotcha. Well, I guess I leave it to Will and Peter to hash out...

Is there a meaningful proposal anywhere for sparse to DTRT here? If
not, it seems best to use what you've proposed until sparse reaches the
point of being able to do this on its own.

-- 
Kees Cook
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 30 Dec 2019 23:38:14 +0000
Message-ID: <20191230233814.2fgmsgtnhruhklnu () ltop ! local>
--------------------
On Mon, Dec 30, 2019 at 11:32:31AM -0800, Kees Cook wrote:
> On Mon, Dec 30, 2019 at 01:15:47PM -0600, Eric Biggers wrote:
> > 
> > The annotation needs to go in the .h file, not the .c file, because sparse only
> > analyzes individual translation units.
> > 
> > It needs to be a wrapper macro because it needs to tie the acquisition of the
> > lock to the return value being true.  I.e. there's no annotation you can apply
> > directly to the function prototype that means "if this function returns true, it
> > acquires the lock that was passed in parameter N".
> 
> Gotcha. Well, I guess I leave it to Will and Peter to hash out...
> 
> Is there a meaningful proposal anywhere for sparse to DTRT here? If
> not, it seems best to use what you've proposed until sparse reaches the
> point of being able to do this on its own.

What "Right Thing" are you thinking about?
One of the simplest situation with these conditional locks is:

	if (test)
		lock();

	do_stuff();

	if (test)
		unlock();

No program can check that the second test gives the same result than
the first one, it's undecidable. I mean, it's undecidable even on
if single threaded and without interrupts. The best you can do is
to simulate the whole thing (and be sure your simulation will halt).

As far as I understand, it was the intention behind Sparse's design
regarding locking ("context in sparse's parlance) to discourage
such code and instead encourage to write things like:

	if (test) {
		do_stuff_unlocked();
	} else {
		lock();
		do_stuff_unlocked();
		unlock();
	}

where it is easy to check localy that the lock/unlock are balanced.

So, of course Sparse could be improved to prove that some of the
conditional locks are equivalent to unconditional ones like here
just above (it already does but only for very simple cases where
everything is inlined) but I don't thing there is a RT.

-- Luc Van Oostenryck
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 30 Dec 2019 23:38:14 +0000
Message-ID: <20191230233814.2fgmsgtnhruhklnu () ltop ! local>
--------------------
On Mon, Dec 30, 2019 at 11:32:31AM -0800, Kees Cook wrote:
> On Mon, Dec 30, 2019 at 01:15:47PM -0600, Eric Biggers wrote:
> > 
> > The annotation needs to go in the .h file, not the .c file, because sparse only
> > analyzes individual translation units.
> > 
> > It needs to be a wrapper macro because it needs to tie the acquisition of the
> > lock to the return value being true.  I.e. there's no annotation you can apply
> > directly to the function prototype that means "if this function returns true, it
> > acquires the lock that was passed in parameter N".
> 
> Gotcha. Well, I guess I leave it to Will and Peter to hash out...
> 
> Is there a meaningful proposal anywhere for sparse to DTRT here? If
> not, it seems best to use what you've proposed until sparse reaches the
> point of being able to do this on its own.

What "Right Thing" are you thinking about?
One of the simplest situation with these conditional locks is:

	if (test)
		lock();

	do_stuff();

	if (test)
		unlock();

No program can check that the second test gives the same result than
the first one, it's undecidable. I mean, it's undecidable even on
if single threaded and without interrupts. The best you can do is
to simulate the whole thing (and be sure your simulation will halt).

As far as I understand, it was the intention behind Sparse's design
regarding locking ("context in sparse's parlance) to discourage
such code and instead encourage to write things like:

	if (test) {
		do_stuff_unlocked();
	} else {
		lock();
		do_stuff_unlocked();
		unlock();
	}

where it is easy to check localy that the lock/unlock are balanced.

So, of course Sparse could be improved to prove that some of the
conditional locks are equivalent to unconditional ones like here
just above (it already does but only for very simple cases where
everything is inlined) but I don't thing there is a RT.

-- Luc Van Oostenryck
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Fri, 03 Jan 2020 01:35:34 +0000
Message-ID: <CAHk-=wgkoUeLGEdUF2nsibsK8YFrOOXMd9j5Y1ND4R+1a-6n8w () mail ! gmail ! com>
--------------------
On Mon, Dec 30, 2019 at 3:38 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> One of the simplest situation with these conditional locks is:
>
>         if (test)
>                 lock();
>
>         do_stuff();
>
>         if (test)
>                 unlock();
>
> No program can check that the second test gives the same result than
> the first one, it's undecidable. I mean, it's undecidable even on
> if single threaded and without interrupts. The best you can do is
> to simulate the whole thing (and be sure your simulation will halt).

No, no.

It's undecidable in the general case, but it's usually actually
trivially decidable in most real-world kernel cases.

Because "test" tends to be an argument to the function (or one bit of
an argument), and after it has been turned into SSA form, it's
literally using the same exact register for the conditional thanks to
CSE and simplification.

Perhaps not every time, but I bet it would be most times.

So I guess sparse could in theory notice that certain basic blocks are
conditional on the same thing, so if one is done, then the other is
always done (assuming there is conditional branch out in between, of
course).

IOW, the context tracking *could* do check son a bigger state than
just one basic block. It doesn't, and it would probably be painful to
do, but it's certainly not impossible.

So to make a trivial example for sparse:

    extern int testfn(int);
    extern int do_something(void);

    int testfn(int flag)
    {
        if (flag & 1)
                __context__(1);
        do_something();
        if (flag & 1)
                __context__(-1);
    }

this causes a warning:

    c.c:4:5: warning: context imbalance in 'testfn' - different lock
contexts for basic block

because "do_something()" is called with different lock contexts. And
that's definitely a real issue. But if we were to want to extend the
"make sure we enter/exit with the same lock context", we _could_ do
it, because look at the linearization:

    testfn:
    .L0:
        <entry-point>
        and.32      %r2 <- %arg1, $1
        cbr         %r2, .L1, .L2
    .L1:
        context     1
        br          .L2
    .L2:
        call.32     %r4 <- do_something
        cbr         %r2, .L3, .L5
    .L3:
        context     -1
        br          .L5
    .L5:
        ret.32      UNDEF

becasue the conditional branch always uses "%r2" as the conditional.
Notice? Not at all undecideable, and it would not be *impossible* to
say that "we can see that all context changes are conditional on %r2
not being true".

So sparse has already done all the real work to know that the two "if
(test)" conditionals test the exact same thing. We _know_ that the
second test has the same result as the first test, we're using the
same SSA register for both of them!

              Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Fri, 03 Jan 2020 02:18:19 +0000
Message-ID: <20200103021819.jq6h53h3ktlatyj7 () ltop ! local>
--------------------
On Thu, Jan 02, 2020 at 05:35:34PM -0800, Linus Torvalds wrote:
> On Mon, Dec 30, 2019 at 3:38 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > One of the simplest situation with these conditional locks is:
> >
> >         if (test)
> >                 lock();
> >
> >         do_stuff();
> >
> >         if (test)
> >                 unlock();
> >
> > No program can check that the second test gives the same result than
> > the first one, it's undecidable. I mean, it's undecidable even on
> > if single threaded and without interrupts. The best you can do is
> > to simulate the whole thing (and be sure your simulation will halt).
> 
> No, no.
> 
> It's undecidable in the general case, but it's usually actually
> trivially decidable in most real-world kernel cases.
> 
> Because "test" tends to be an argument to the function (or one bit of
> an argument), and after it has been turned into SSA form, it's
> literally using the same exact register for the conditional thanks to
> CSE and simplification.
> 
> Perhaps not every time, but I bet it would be most times.

Yes, sure. I was, in fact, speaking for for all the cases where
'test' is more complex than an argument or local var. When I looked
at these false warnings about context imbalance, maybe 18 months ago,
my vague impression was that in most cases the test contained a pointer
dereference or worse. But I didn't look much.

> So I guess sparse could in theory notice that certain basic blocks are
> conditional on the same thing, so if one is done, then the other is
> always done (assuming there is conditional branch out in between, of
> course).
> 
> IOW, the context tracking *could* do check son a bigger state than
> just one basic block. It doesn't, and it would probably be painful to
> do, but it's certainly not impossible.
> 
> So to make a trivial example for sparse:
> 
>     extern int testfn(int);
>     extern int do_something(void);
> 
>     int testfn(int flag)
>     {
>         if (flag & 1)
>                 __context__(1);
>         do_something();
>         if (flag & 1)
>                 __context__(-1);
>     }
> 
> this causes a warning:
> 
>     c.c:4:5: warning: context imbalance in 'testfn' - different lock
> contexts for basic block
> 
> because "do_something()" is called with different lock contexts. And
> that's definitely a real issue. But if we were to want to extend the
> "make sure we enter/exit with the same lock context", we _could_ do
> it, because look at the linearization:
> 
>     testfn:
>     .L0:
>         <entry-point>
>         and.32      %r2 <- %arg1, $1
>         cbr         %r2, .L1, .L2
>     .L1:
>         context     1
>         br          .L2
>     .L2:
>         call.32     %r4 <- do_something
>         cbr         %r2, .L3, .L5
>     .L3:
>         context     -1
>         br          .L5
>     .L5:
>         ret.32      UNDEF
> 
> becasue the conditional branch always uses "%r2" as the conditional.
> Notice? Not at all undecideable, and it would not be *impossible* to
> say that "we can see that all context changes are conditional on %r2
> not being true".
> 
> So sparse has already done all the real work to know that the two "if
> (test)" conditionals test the exact same thing. We _know_ that the
> second test has the same result as the first test, we're using the
> same SSA register for both of them!

Absolutely. I'm more than willing to look at this but I just fear
that in most cases the conditional is more complex. I'll make
some investigations.

-- Luc
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Fri, 03 Jan 2020 02:18:19 +0000
Message-ID: <20200103021819.jq6h53h3ktlatyj7 () ltop ! local>
--------------------
On Thu, Jan 02, 2020 at 05:35:34PM -0800, Linus Torvalds wrote:
> On Mon, Dec 30, 2019 at 3:38 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > One of the simplest situation with these conditional locks is:
> >
> >         if (test)
> >                 lock();
> >
> >         do_stuff();
> >
> >         if (test)
> >                 unlock();
> >
> > No program can check that the second test gives the same result than
> > the first one, it's undecidable. I mean, it's undecidable even on
> > if single threaded and without interrupts. The best you can do is
> > to simulate the whole thing (and be sure your simulation will halt).
> 
> No, no.
> 
> It's undecidable in the general case, but it's usually actually
> trivially decidable in most real-world kernel cases.
> 
> Because "test" tends to be an argument to the function (or one bit of
> an argument), and after it has been turned into SSA form, it's
> literally using the same exact register for the conditional thanks to
> CSE and simplification.
> 
> Perhaps not every time, but I bet it would be most times.

Yes, sure. I was, in fact, speaking for for all the cases where
'test' is more complex than an argument or local var. When I looked
at these false warnings about context imbalance, maybe 18 months ago,
my vague impression was that in most cases the test contained a pointer
dereference or worse. But I didn't look much.

> So I guess sparse could in theory notice that certain basic blocks are
> conditional on the same thing, so if one is done, then the other is
> always done (assuming there is conditional branch out in between, of
> course).
> 
> IOW, the context tracking *could* do check son a bigger state than
> just one basic block. It doesn't, and it would probably be painful to
> do, but it's certainly not impossible.
> 
> So to make a trivial example for sparse:
> 
>     extern int testfn(int);
>     extern int do_something(void);
> 
>     int testfn(int flag)
>     {
>         if (flag & 1)
>                 __context__(1);
>         do_something();
>         if (flag & 1)
>                 __context__(-1);
>     }
> 
> this causes a warning:
> 
>     c.c:4:5: warning: context imbalance in 'testfn' - different lock
> contexts for basic block
> 
> because "do_something()" is called with different lock contexts. And
> that's definitely a real issue. But if we were to want to extend the
> "make sure we enter/exit with the same lock context", we _could_ do
> it, because look at the linearization:
> 
>     testfn:
>     .L0:
>         <entry-point>
>         and.32      %r2 <- %arg1, $1
>         cbr         %r2, .L1, .L2
>     .L1:
>         context     1
>         br          .L2
>     .L2:
>         call.32     %r4 <- do_something
>         cbr         %r2, .L3, .L5
>     .L3:
>         context     -1
>         br          .L5
>     .L5:
>         ret.32      UNDEF
> 
> becasue the conditional branch always uses "%r2" as the conditional.
> Notice? Not at all undecideable, and it would not be *impossible* to
> say that "we can see that all context changes are conditional on %r2
> not being true".
> 
> So sparse has already done all the real work to know that the two "if
> (test)" conditionals test the exact same thing. We _know_ that the
> second test has the same result as the first test, we're using the
> same SSA register for both of them!

Absolutely. I'm more than willing to look at this but I just fear
that in most cases the conditional is more complex. I'll make
some investigations.

-- Luc
================================================================================

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Fri, 03 Jan 2020 12:55:21 +0000
Message-ID: <20200103125521.GJ3911 () kadam>
--------------------
I re-wrote Smatch's locking check last month to use the cross function
DB.  Now Smatch can parse refcount_dec_and_lock() directly without any
modifications or annotations.

regards,
dan carpenter

================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-sparse
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 06 Jan 2020 15:26:29 +0000
Message-ID: <20200106152629.GU2810 () hirez ! programming ! kicks-ass ! net>
--------------------
On Mon, Dec 30, 2019 at 11:32:31AM -0800, Kees Cook wrote:

> Is there a meaningful proposal anywhere for sparse to DTRT here?

These are what I found going through my Sent folder and Google'ing the
resulting subjects:

  https://markmail.org/message/4obybcgqscznnx63
  https://markmail.org/message/pp4ofksgactvgjbd?q=inverted_lock

> If
> not, it seems best to use what you've proposed until sparse reaches the
> point of being able to do this on its own.

Or just leave the silly sparse warning, they're easy to ignore.
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 06 Jan 2020 15:41:19 +0000
Message-ID: <20200106154119.GV2810 () hirez ! programming ! kicks-ass ! net>
--------------------
On Tue, Dec 31, 2019 at 12:38:14AM +0100, Luc Van Oostenryck wrote:
> On Mon, Dec 30, 2019 at 11:32:31AM -0800, Kees Cook wrote:
> > On Mon, Dec 30, 2019 at 01:15:47PM -0600, Eric Biggers wrote:
> > > 
> > > The annotation needs to go in the .h file, not the .c file, because sparse only
> > > analyzes individual translation units.
> > > 
> > > It needs to be a wrapper macro because it needs to tie the acquisition of the
> > > lock to the return value being true.  I.e. there's no annotation you can apply
> > > directly to the function prototype that means "if this function returns true, it
> > > acquires the lock that was passed in parameter N".
> > 
> > Gotcha. Well, I guess I leave it to Will and Peter to hash out...
> > 
> > Is there a meaningful proposal anywhere for sparse to DTRT here? If
> > not, it seems best to use what you've proposed until sparse reaches the
> > point of being able to do this on its own.
> 
> What "Right Thing" are you thinking about?
> One of the simplest situation with these conditional locks is:
> 
> 	if (test)
> 		lock();
> 
> 	do_stuff();
> 
> 	if (test)
> 		unlock();
> 
> No program can check that the second test gives the same result than
> the first one, it's undecidable. I mean, it's undecidable even on
> if single threaded and without interrupts. The best you can do is
> to simulate the whole thing (and be sure your simulation will halt).

Not quite what we're talking about. Instead consider this:

The normal flow would be something like:

extern void spin_lock(spinlock_t *lock) __acquires(lock);
extern void spin_unlock(spinlock_t *lock) __releases(lock);

extern bool _spin_trylock(spinlock_t *lock) __acquires(lock);

#define __cond_lock(x, c) ((c) ? ({ __acquire(x); 1; }) : 0)
#define spin_trylock(lock) __cond_lock(lock, _spin_lock)


	if (spin_trylock(lock)) {

		/* do crap */

		spin_unlock();
	}


So the proposal here:

  https://markmail.org/message/4obybcgqscznnx63

would have us write:

extern bool spin_trylock(spinlock_t *lock) __attribute__((context(lock, 0, spin_trylock(lock));

Basically have sparse do a transform on its own expression tree and
inject the very same crud we now do manually. This avoids cluttering the
kernel tree with this nonsense.
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-sparse
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 06 Jan 2020 15:41:19 +0000
Message-ID: <20200106154119.GV2810 () hirez ! programming ! kicks-ass ! net>
--------------------
On Tue, Dec 31, 2019 at 12:38:14AM +0100, Luc Van Oostenryck wrote:
> On Mon, Dec 30, 2019 at 11:32:31AM -0800, Kees Cook wrote:
> > On Mon, Dec 30, 2019 at 01:15:47PM -0600, Eric Biggers wrote:
> > > 
> > > The annotation needs to go in the .h file, not the .c file, because sparse only
> > > analyzes individual translation units.
> > > 
> > > It needs to be a wrapper macro because it needs to tie the acquisition of the
> > > lock to the return value being true.  I.e. there's no annotation you can apply
> > > directly to the function prototype that means "if this function returns true, it
> > > acquires the lock that was passed in parameter N".
> > 
> > Gotcha. Well, I guess I leave it to Will and Peter to hash out...
> > 
> > Is there a meaningful proposal anywhere for sparse to DTRT here? If
> > not, it seems best to use what you've proposed until sparse reaches the
> > point of being able to do this on its own.
> 
> What "Right Thing" are you thinking about?
> One of the simplest situation with these conditional locks is:
> 
> 	if (test)
> 		lock();
> 
> 	do_stuff();
> 
> 	if (test)
> 		unlock();
> 
> No program can check that the second test gives the same result than
> the first one, it's undecidable. I mean, it's undecidable even on
> if single threaded and without interrupts. The best you can do is
> to simulate the whole thing (and be sure your simulation will halt).

Not quite what we're talking about. Instead consider this:

The normal flow would be something like:

extern void spin_lock(spinlock_t *lock) __acquires(lock);
extern void spin_unlock(spinlock_t *lock) __releases(lock);

extern bool _spin_trylock(spinlock_t *lock) __acquires(lock);

#define __cond_lock(x, c) ((c) ? ({ __acquire(x); 1; }) : 0)
#define spin_trylock(lock) __cond_lock(lock, _spin_lock)


	if (spin_trylock(lock)) {

		/* do crap */

		spin_unlock();
	}


So the proposal here:

  https://markmail.org/message/4obybcgqscznnx63

would have us write:

extern bool spin_trylock(spinlock_t *lock) __attribute__((context(lock, 0, spin_trylock(lock));

Basically have sparse do a transform on its own expression tree and
inject the very same crud we now do manually. This avoids cluttering the
kernel tree with this nonsense.
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Mon, 06 Jan 2020 17:54:59 +0000
Message-ID: <20200106175459.tjuhmdrsusax3s4z () ltop ! local>
--------------------
On Mon, Jan 06, 2020 at 04:41:19PM +0100, Peter Zijlstra wrote:
> On Tue, Dec 31, 2019 at 12:38:14AM +0100, Luc Van Oostenryck wrote:

...
 
> Not quite what we're talking about. Instead consider this:
> 
> The normal flow would be something like:
> 
> extern void spin_lock(spinlock_t *lock) __acquires(lock);
> extern void spin_unlock(spinlock_t *lock) __releases(lock);
> 
> extern bool _spin_trylock(spinlock_t *lock) __acquires(lock);
> 
> #define __cond_lock(x, c) ((c) ? ({ __acquire(x); 1; }) : 0)
> #define spin_trylock(lock) __cond_lock(lock, _spin_lock)
> 
> 
> 	if (spin_trylock(lock)) {
> 
> 		/* do crap */
> 
> 		spin_unlock();
> 	}
> 
> 
> So the proposal here:
> 
>   https://markmail.org/message/4obybcgqscznnx63
> 
> would have us write:
> 
> extern bool spin_trylock(spinlock_t *lock) __attribute__((context(lock, 0, spin_trylock(lock));

Well, allowing arbitrary conditions would be hard/impossible but you're
only asking to have the *return value* as condition, right? That looks
as reasonably feasible.

> Basically have sparse do a transform on its own expression tree and
> inject the very same crud we now do manually. This avoids cluttering the
> kernel tree with this nonsense.

So, a call of a function declared with __acquires() or releases() is
interpreted by Sparse as if the call is immediately followed by an
increase or a decrease of the context. It wouldn't be very hard to
add a new attribute (something like __cond_context) and let Sparse do
as if a call to a function with such attribute is directly followed
by a test of its return value and a corresponding change in the context.
It would boil down to:

	extern bool spin_trylock(lock) __cond_context(lock);

	if (spin_trylock(lock)) {
		/* do crap */
		spin_unlock();
	}

behaving like the following code currently would:

	extern bool spin_trylock(lock);

	if (spin_trylock(lock)) {
		__acquire(lock);
		/* do crap */
		spin_unlock();
	}


Would something like this be satisfactory?

-- Luc
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-sparse
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Tue, 07 Jan 2020 09:29:35 +0000
Message-ID: <20200107092935.GU2844 () hirez ! programming ! kicks-ass ! net>
--------------------
On Mon, Jan 06, 2020 at 06:54:59PM +0100, Luc Van Oostenryck wrote:
> On Mon, Jan 06, 2020 at 04:41:19PM +0100, Peter Zijlstra wrote:

> > extern bool spin_trylock(spinlock_t *lock) __attribute__((context(lock, 0, spin_trylock(lock));
> 
> Well, allowing arbitrary conditions would be hard/impossible but you're
> only asking to have the *return value* as condition, right? That looks
> as reasonably feasible.

Just the return value would cover all the known cases yes. At the time
I might have been somewhat over ambitious..

> > Basically have sparse do a transform on its own expression tree and
> > inject the very same crud we now do manually. This avoids cluttering the
> > kernel tree with this nonsense.
> 
> So, a call of a function declared with __acquires() or releases() is
> interpreted by Sparse as if the call is immediately followed by an
> increase or a decrease of the context. It wouldn't be very hard to
> add a new attribute (something like __cond_context) and let Sparse do
> as if a call to a function with such attribute is directly followed
> by a test of its return value and a corresponding change in the context.
> It would boil down to:
> 
> 	extern bool spin_trylock(lock) __cond_context(lock);
> 
> 	if (spin_trylock(lock)) {
> 		/* do crap */
> 		spin_unlock();
> 	}
> 
> behaving like the following code currently would:
> 
> 	extern bool spin_trylock(lock);
> 
> 	if (spin_trylock(lock)) {
> 		__acquire(lock);
> 		/* do crap */
> 		spin_unlock();
> 	}
> 
> 
> Would something like this be satisfactory?

Very much so, Thanks!
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-kernel
Subject: Re: [PATCH] locking/refcount: add sparse annotations to dec-and-lock functions
Date: Tue, 07 Jan 2020 09:29:35 +0000
Message-ID: <20200107092935.GU2844 () hirez ! programming ! kicks-ass ! net>
--------------------
On Mon, Jan 06, 2020 at 06:54:59PM +0100, Luc Van Oostenryck wrote:
> On Mon, Jan 06, 2020 at 04:41:19PM +0100, Peter Zijlstra wrote:

> > extern bool spin_trylock(spinlock_t *lock) __attribute__((context(lock, 0, spin_trylock(lock));
> 
> Well, allowing arbitrary conditions would be hard/impossible but you're
> only asking to have the *return value* as condition, right? That looks
> as reasonably feasible.

Just the return value would cover all the known cases yes. At the time
I might have been somewhat over ambitious..

> > Basically have sparse do a transform on its own expression tree and
> > inject the very same crud we now do manually. This avoids cluttering the
> > kernel tree with this nonsense.
> 
> So, a call of a function declared with __acquires() or releases() is
> interpreted by Sparse as if the call is immediately followed by an
> increase or a decrease of the context. It wouldn't be very hard to
> add a new attribute (something like __cond_context) and let Sparse do
> as if a call to a function with such attribute is directly followed
> by a test of its return value and a corresponding change in the context.
> It would boil down to:
> 
> 	extern bool spin_trylock(lock) __cond_context(lock);
> 
> 	if (spin_trylock(lock)) {
> 		/* do crap */
> 		spin_unlock();
> 	}
> 
> behaving like the following code currently would:
> 
> 	extern bool spin_trylock(lock);
> 
> 	if (spin_trylock(lock)) {
> 		__acquire(lock);
> 		/* do crap */
> 		spin_unlock();
> 	}
> 
> 
> Would something like this be satisfactory?

Very much so, Thanks!
================================================================================


################################################################################

=== Thread: [PATCH] manpage: replace homepage to sparse.docs.kernel.org ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] manpage: replace homepage to sparse.docs.kernel.org
Date: Wed, 22 Jul 2020 21:42:47 +0000
Message-ID: <20200722214247.36824-1-luc.vanoostenryck () gmail ! com>
--------------------
The online documentation was updated for the new homepage
but the manpages were forgotten.

So, update them now.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 sindex.1 | 2 +-
 sparse.1 | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/sindex.1 b/sindex.1
index e3e14ca3ad23..508e2d52cfed 100644
--- a/sindex.1
+++ b/sindex.1
@@ -144,7 +144,7 @@ read and write
 .BR sparse (1)
 .
 .SH HOMEPAGE
-http://www.kernel.org/pub/software/devel/sparse/
+https://sparse.docs.kernel.org
 .
 .SH MAILING LIST
 linux-sparse@vger.kernel.org
diff --git a/sparse.1 b/sparse.1
index 399a63fa2a0a..60203d5a6463 100644
--- a/sparse.1
+++ b/sparse.1
@@ -513,7 +513,7 @@ By default chars are signed.
 .BR cgcc (1)
 .
 .SH HOMEPAGE
-http://www.kernel.org/pub/software/devel/sparse/
+https://sparse.docs.kernel.org
 .
 .SH MAILING LIST
 linux-sparse@vger.kernel.org
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] pre-define __unix__ and friends ===

From: john.levon () joyent ! com
To: linux-sparse
Subject: [PATCH] pre-define __unix__ and friends
Date: Mon, 20 Jan 2020 10:48:03 +0000
Message-ID: <20200120104803.20864-1-john.levon () joyent ! com>
--------------------
From: John Levon <john.levon@joyent.com>

GCC defines these, so should we.

Signed-off-by: John Levon <john.levon@joyent.com>
---
 lib.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/lib.c b/lib.c
index 9b03895c..739074d1 100644
--- a/lib.c
+++ b/lib.c
@@ -1507,6 +1507,10 @@ static void predefined_macros(void)
 	if (optimize_size)
 		predefine("__OPTIMIZE_SIZE__", 0, "1");
 
+	predefine("__unix__", 1, "1");
+	predefine("__unix", 1, "1");
+	predefine("unix", 1, "1");
+
 	predefine("__PRAGMA_REDEFINE_EXTNAME", 1, "1");
 
 	// Temporary hacks
-- 
2.23.0

================================================================================


################################################################################

=== Thread: [PATCH] predefine "i386" if needed ===

From: john.levon () joyent ! com
To: linux-sparse
Subject: [PATCH] predefine "i386" if needed
Date: Thu, 23 Jan 2020 00:01:36 +0000
Message-ID: <20200123000136.24109-1-john.levon () joyent ! com>
--------------------
From: John Levon <john.levon@joyent.com>

Signed-off-by: John Levon <john.levon@joyent.com>
---
 target-x86.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/target-x86.c b/target-x86.c
index 01d213ef..d770349c 100644
--- a/target-x86.c
+++ b/target-x86.c
@@ -29,6 +29,7 @@ static void predefine_i386(const struct target *self)
 {
 	predefine("__i386__", 1, "1");
 	predefine("__i386", 1, "1");
+	predefine_nostd("i386");
 }
 
 const struct target target_i386 = {
-- 
2.23.0

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] predefine "i386" if needed
Date: Thu, 23 Jan 2020 17:37:57 +0000
Message-ID: <20200123173757.p4tgt5yd5eu5ermp () ltop ! local>
--------------------
Applied and upstreamed.
Thank you.

-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] preprocess: use predefine() also for __%s__TYPE__ ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] preprocess: use predefine() also for __%s__TYPE__
Date: Mon, 29 Jun 2020 19:20:47 +0000
Message-ID: <20200629192047.92114-1-luc.vanoostenryck () gmail ! com>
--------------------
Most predefined macros are created by predefine() which
avoid the 'write then parse' done with add_pre_buffer() but
those defined by predefined_type() did not.

So, convert predefine_type() to use predefine().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/lib.c b/lib.c
index e56788260cb7..d8fbe8b1a006 100644
--- a/lib.c
+++ b/lib.c
@@ -1274,7 +1274,10 @@ static void predefined_min(const char *name, struct symbol *type)
 static void predefined_type(const char *name, struct symbol *type)
 {
 	const char *typename = builtin_typename(type);
-	add_pre_buffer("#weak_define __%s_TYPE__ %s\n", name, typename);
+	char buf[32];
+
+	snprintf(buf, sizeof(buf), "__%s_TYPE__", name);
+	predefine(buf, 1, typename);
 }
 
 static void predefined_ctype(const char *name, struct symbol *type, int flags)
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] ptrlist: avoid mixing reverse and non-reverse macros ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] ptrlist: avoid mixing reverse and non-reverse macros
Date: Sun, 27 Dec 2020 11:04:01 +0000
Message-ID: <20201227110401.34501-1-luc.vanoostenryck () gmail ! com>
--------------------
The macros used to iterate the ptrlists exist in two kinds:
those to iterate forward direction and those to iterate in the
reverse direction.

Those macros must be used in pair: one for the top of the loop and
one at the end of the loop. However, if we mix them, for example like:
	FOR_EACH_PTR(list, var) {
		...
	} FOR_EACH_PTR_REVERSE(var);

things will still work for lists with a single block (most of them)
but will behave strangely and of course wrongly when reaching the
next block.

So, to avoid future debugging fun, add a unused variable, discarded
at compile time, but with distinct prefix for each direction. This way,
mixing the macros will create a warning at compile time.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 ptrlist.h | 29 +++++++++++++++++------------
 1 file changed, 17 insertions(+), 12 deletions(-)

diff --git a/ptrlist.h b/ptrlist.h
index 2411e745ab24..4bf8c709ac08 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -89,27 +89,27 @@ extern void __free_ptr_list(struct ptr_list **);
 	DO_FINISH(ptr, __head##ptr, __list##ptr, __nr##ptr)
 
 #define RECURSE_PTR_REVERSE(ptr, new)					\
-	DO_REVERSE(ptr, __head##ptr, __list##ptr, __nr##ptr,		\
+	DO_REVERSE(ptr, __head##ptr, __list##ptr, __nr##ptr, __rname##new, \
 		   new, __head##new, __list##new, __nr##new, PTR_ENTRY_UNTAG)
 
 
 #define FOR_EACH_PTR(head, ptr) \
-	DO_FOR_EACH(head, ptr, __head##ptr, __list##ptr, __nr##ptr, PTR_ENTRY_NOTAG)
+	DO_FOR_EACH(head, ptr, __head##ptr, __list##ptr, __nr##ptr, __name##ptr, PTR_ENTRY_NOTAG)
 
 #define FOR_EACH_PTR_TAG(head, ptr) \
-	DO_FOR_EACH(head, ptr, __head##ptr, __list##ptr, __nr##ptr, PTR_ENTRY_UNTAG)
+	DO_FOR_EACH(head, ptr, __head##ptr, __list##ptr, __nr##ptr, __name##ptr,  PTR_ENTRY_UNTAG)
 
 #define END_FOR_EACH_PTR(ptr) \
-	DO_END_FOR_EACH(ptr, __head##ptr, __list##ptr, __nr##ptr)
+	DO_END_FOR_EACH(ptr, __head##ptr, __list##ptr, __nr##ptr, __name##ptr)
 
 #define FOR_EACH_PTR_REVERSE(head, ptr) \
-	DO_FOR_EACH_REVERSE(head, ptr, __head##ptr, __list##ptr, __nr##ptr, PTR_ENTRY_NOTAG)
+	DO_FOR_EACH_REVERSE(head, ptr, __head##ptr, __list##ptr, __nr##ptr, __rname##ptr,  PTR_ENTRY_NOTAG)
 
 #define FOR_EACH_PTR_REVERSE_TAG(head, ptr) \
-	DO_FOR_EACH_REVERSE(head, ptr, __head##ptr, __list##ptr, __nr##ptr, PTR_ENTRY_UNTAG)
+	DO_FOR_EACH_REVERSE(head, ptr, __head##ptr, __list##ptr, __nr##ptr, __rname##ptr, PTR_ENTRY_UNTAG)
 
 #define END_FOR_EACH_PTR_REVERSE(ptr) \
-	DO_END_FOR_EACH_REVERSE(ptr, __head##ptr, __list##ptr, __nr##ptr)
+	DO_END_FOR_EACH_REVERSE(ptr, __head##ptr, __list##ptr, __nr##ptr, __rname##ptr)
 
 #define THIS_ADDRESS(ptr) \
 	DO_THIS_ADDRESS(ptr, __head##ptr, __list##ptr, __nr##ptr)
@@ -184,9 +184,10 @@ extern void __free_ptr_list(struct ptr_list **);
 		VRFY_PTR_LIST(__head); /* Sanity-check nesting */	\
 	} while (0)
 
-#define DO_FOR_EACH(head, ptr, __head, __list, __nr, PTR_ENTRY) do {	\
+#define DO_FOR_EACH(head, ptr, __head, __list, __nr, __name, PTR_ENTRY) do {	\
 	__typeof__(head) __head = (head);				\
 	__typeof__(head) __list = __head;				\
+	__typeof__(head) __name = __head;				\
 	int __nr;							\
 	if (!__head)							\
 		break;							\
@@ -196,14 +197,16 @@ extern void __free_ptr_list(struct ptr_list **);
 			if (__list->rm && !ptr)				\
 				continue;				\
 
-#define DO_END_FOR_EACH(ptr, __head, __list, __nr)			\
+#define DO_END_FOR_EACH(ptr, __head, __list, __nr, __name)		\
 		}							\
 	} while ((__list = __list->next) != __head);			\
+	(void) __name;						\
 } while (0)
 
-#define DO_FOR_EACH_REVERSE(head, ptr, __head, __list, __nr, PTR_ENTRY) do { \
+#define DO_FOR_EACH_REVERSE(head, ptr, __head, __list, __nr, __name, PTR_ENTRY) do { \
 	__typeof__(head) __head = (head);				\
 	__typeof__(head) __list = __head;				\
+	__typeof__(head) __name = __head;				\
 	int __nr;							\
 	if (!head)							\
 		break;							\
@@ -216,15 +219,17 @@ extern void __free_ptr_list(struct ptr_list **);
 				continue;				\
 
 
-#define DO_END_FOR_EACH_REVERSE(ptr, __head, __list, __nr)		\
+#define DO_END_FOR_EACH_REVERSE(ptr, __head, __list, __nr, __name)	\
 		}							\
 	} while (__list != __head);					\
+	(void) __name;							\
 } while (0)
 
-#define DO_REVERSE(ptr, __head, __list, __nr, new, __newhead,		\
+#define DO_REVERSE(ptr, __head, __list, __nr, __name, new, __newhead,	\
 		   __newlist, __newnr, PTR_ENTRY) do {			\
 	__typeof__(__head) __newhead = __head;				\
 	__typeof__(__head) __newlist = __list;				\
+	__typeof__(__head) __name = __list;				\
 	int __newnr = __nr;						\
 	new = ptr;							\
 	goto __inside##new;						\
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH] replace nbr_users() by  multi_users() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] replace nbr_users() by  multi_users()
Date: Sun, 25 Oct 2020 13:59:47 +0000
Message-ID: <20201025135947.32822-1-luc.vanoostenryck () gmail ! com>
--------------------
During simplification, we're only interested to know if a pseudo
is used only once or more than once. This can be checked quicker
than getting the exact number of users.

So, replace the last call to nbr_users() by a call to multi_users().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index 6caf6cbcf918..191c9e4928b2 100644
--- a/simplify.c
+++ b/simplify.c
@@ -871,7 +871,7 @@ static int simplify_shift(struct instruction *insn, pseudo_t pseudo, long long v
 				return replace_with_value(insn, 0);
 			if (nmask == mask)
 				return replace_pseudo(insn, &insn->src1, def->src1);
-			if (nbr_users(pseudo) > 1)
+			if (multi_users(pseudo))
 				break;
 			def->opcode = OP_LSR;
 			def->src2 = insn->src2;
-- 
2.29.0

================================================================================


################################################################################

=== Thread: [PATCH] shrink struct BB ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] shrink struct BB
Date: Sun, 27 Dec 2020 10:08:29 +0000
Message-ID: <20201227100829.33456-1-luc.vanoostenryck () gmail ! com>
--------------------
Reorganize the members of struct BB, avoiding padding and making better
use of the union, to shrink its size from 104 to 96 bytes.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.h | 12 +++++-------
 ssa.c       |  1 +
 2 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/linearize.h b/linearize.h
index 2c548d43526f..7093a815312a 100644
--- a/linearize.h
+++ b/linearize.h
@@ -160,21 +160,19 @@ struct instruction_list;
 struct basic_block {
 	struct position pos;
 	unsigned long generation;
-	union {
-		int context;
-		int postorder_nr;	/* postorder number */
-		int dom_level;		/* level in the dominance tree */
-	};
 	struct entrypoint *ep;
 	struct basic_block_list *parents; /* sources */
 	struct basic_block_list *children; /* destinations */
 	struct instruction_list *insns;	/* Linear list of instructions */
 	struct basic_block *idom;	/* link to the immediate dominator */
+	unsigned int nr;		/* unique id for label's names */
+	int dom_level;			/* level in the dominance tree */
 	struct basic_block_list *doms;	/* list of BB idominated by this one */
-	struct phi_map *phi_map;
 	struct pseudo_list *needs, *defines;
 	union {
-		unsigned int nr;	/* unique id for label's names */
+		struct phi_map *phi_map;/* needed during SSA conversion */
+		int postorder_nr;	/* postorder number */
+		int context;		/* needed during context checking */
 		void *priv;
 	};
 };
diff --git a/ssa.c b/ssa.c
index a2e27030e4b6..4c86c55c2ec1 100644
--- a/ssa.c
+++ b/ssa.c
@@ -387,6 +387,7 @@ void ssa_convert(struct entrypoint *ep)
 		int nr = bb->nr;
 		if (nr > last)
 			last = nr;
+		bb->phi_map = NULL;
 	} END_FOR_EACH_PTR(bb);
 
 	processed = sset_init(first, last);
-- 
2.29.2

================================================================================


################################################################################

=== Thread: [PATCH] sindex.1: Use ' for a plain quote char ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH] sindex.1: Use ' for a plain quote char
Date: Fri, 31 Jul 2020 21:41:25 +0000
Message-ID: <20200731214125.21424-1-uwe () kleine-koenig ! org>
--------------------
lintian (a linter for Debian packages) warns:

N:    This manual page uses the \' groff sequence. Usually, the intent to
N:    generate an apostrophe, but that sequence actually renders as a an acute
N:    accent.
N:
N:    For an apostrophe or a single closing quote, use plain '. For single
N:    opening quote, i.e. a straight downward line ' like the one used in
N:    shell commands, use &#92;(aq.

I'm not following its advice but stick to ' as is done in other places
of sindex.1.

Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
 sindex.1 | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/sindex.1 b/sindex.1
index e3e14ca3ad23..d7c5173a85f2 100644
--- a/sindex.1
+++ b/sindex.1
@@ -128,8 +128,8 @@ struct member
 .
 .SH MODE
 The \fBMODE\fR is dumped as a 3-letter string. The first letter denotes address
-of part, 2-nd - access by value, 3-rd - access by pointer. A special value
-\'\fIdef\fR\' means a symbol definition.
+of part, 2-nd - access by value, 3-rd - access by pointer. A special
+value '\fIdef\fR' means a symbol definition.
 .TP
 \fBr\fR
 read
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] sindex: Add option to search by location ===

From: Alexey Gladkov <gladkov.alexey () gmail ! com>
To: linux-sparse
Subject: [PATCH] sindex: Add option to search by location
Date: Wed, 18 Mar 2020 18:39:24 +0000
Message-ID: <20200318183924.343365-1-gladkov.alexey () gmail ! com>
--------------------
To create plugin for text editor, it may be useful to be able to search
by position in a file.

$ sindex search -l include/uapi/linux/msdos_fs.h:91:8
(---) fs/fat/dir.c 759 1 fat_ioctl_filldir FAT_IOCTL_FILLDIR_FUNC(fat_ioctl_filldir, __fat_dirent)
(r--) fs/fat/dir.c 759 1 fat_ioctl_filldir FAT_IOCTL_FILLDIR_FUNC(fat_ioctl_filldir, __fat_dirent)
(m--) fs/fat/dir.c 759 1 fat_ioctl_filldir FAT_IOCTL_FILLDIR_FUNC(fat_ioctl_filldir, __fat_dirent)
(def) include/uapi/linux/msdos_fs.h 91 8   long  d_ino;

$ sindex search -l -m w include/uapi/linux/msdos_fs.h:91:8
(m--) fs/fat/dir.c 759 1 fat_ioctl_filldir FAT_IOCTL_FILLDIR_FUNC(fat_ioctl_filldir, __fat_dirent)

Another use is to get the full name of symbol in case of a high level
of nesting:

$ sindex search -e fs/dcache.c:567
(--r) fs/dcache.c 567 9 __dentry_kill   dentry->d_op->d_prune(dentry);
(--r) fs/dcache.c 567 15 __dentry_kill   dentry->d_op->d_prune(dentry);

$ sindex search -e --format='%n' fs/dcache.c:567
dentry.d_op
dentry_operations.d_prune

$ sindex search -e --format='%n' fs/dcache.c:567:9
dentry.d_op

Signed-off-by: Alexey Gladkov <gladkov.alexey@gmail.com>
---
 sindex.1 |  8 ++++++
 sindex.c | 74 ++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 80 insertions(+), 2 deletions(-)

diff --git a/sindex.1 b/sindex.1
index ef39f0f9..e3e14ca3 100644
--- a/sindex.1
+++ b/sindex.1
@@ -17,6 +17,8 @@ sindex \- Semantic Indexer for C
 .B sindex
 [\fIoptions\fR] \fIsearch\fR [\fIcommand options\fR] [\fIpattern\fR]
 .br
+.B sindex [\fIoptions\fR] \fIsearch\fR [\fIcommand options\fR] (\fI-e\fR|\fI-l\fR) \fIfilename\fR:\fIlinenr\fR:\fIcolumn\fR
+.br
 .SH DESCRIPTION
 .P
 sindex is the simple to use cscope-like tool based on sparse/dissect.  Unlike
@@ -75,6 +77,12 @@ specify a kind of symbol (see
 .BR KIND
 below).
 .TP
+\fB-e\fR, \fB--explain\fR
+Show what happens in the specified file position;
+.TP
+\fB-l\fR, \fB--location\fR
+Show usage of symbols from a specific file position;
+.TP
 \fB-v\fR, \fB--verbose\fR
 show information about what is being done;
 .TP
diff --git a/sindex.c b/sindex.c
index c950254b..ea092a4a 100644
--- a/sindex.c
+++ b/sindex.c
@@ -53,6 +53,13 @@ static char *sindex_search_path = NULL;
 static char *sindex_search_symbol = NULL;
 static const char *sindex_search_format = "(%m) %f\t%l\t%c\t%C\t%s";
 
+#define EXPLAIN_LOCATION 1
+#define USAGE_BY_LOCATION 2
+static int sindex_search_by_location;
+static char *sindex_search_filename;
+static int sindex_search_line;
+static int sindex_search_column;
+
 static sqlite3 *sindex_db = NULL;
 static sqlite3_stmt *lock_stmt = NULL;
 static sqlite3_stmt *unlock_stmt = NULL;
@@ -150,6 +157,7 @@ static void show_help_search(int ret)
 {
 	printf(
 	    "Usage: %1$s search [options] [pattern]\n"
+	    "   or: %1$s search [options] (-e|-l) filename[:linenr[:column]]\n"
 	    "\n"
 	    "Utility searches information about symbol by pattern.\n"
 	    "The pattern is a glob(7) wildcard pattern.\n"
@@ -159,6 +167,8 @@ static void show_help_search(int ret)
 	    "  -p, --path=PATTERN     Search symbols only in specified directories;\n"
 	    "  -m, --mode=MODE        Search only the specified type of access;\n"
 	    "  -k, --kind=KIND        Specify a kind of symbol;\n"
+	    "  -e, --explain          Show what happens in the specified file position;\n"
+	    "  -l, --location         Show usage of symbols from a specific file position;\n"
 	    "  -v, --verbose          Show information about what is being done;\n"
 	    "  -h, --help             Show this text and exit.\n"
 	    "\n"
@@ -339,8 +349,10 @@ static void parse_cmdline_rm(int argc, char **argv)
 static void parse_cmdline_search(int argc, char **argv)
 {
 	static const struct option long_options[] = {
+		{ "explain", no_argument, NULL, 'e' },
 		{ "format", required_argument, NULL, 'f' },
 		{ "path", required_argument, NULL, 'p' },
+		{ "location", no_argument, NULL, 'l' },
 		{ "mode", required_argument, NULL, 'm' },
 		{ "kind", required_argument, NULL, 'k' },
 		{ "verbose", no_argument, NULL, 'v' },
@@ -349,8 +361,14 @@ static void parse_cmdline_search(int argc, char **argv)
 	};
 	int c;
 
-	while ((c = getopt_long(argc, argv, "+f:m:k:p:vh", long_options, NULL)) != -1) {
+	while ((c = getopt_long(argc, argv, "+ef:m:k:p:lvh", long_options, NULL)) != -1) {
 		switch (c) {
+			case 'e':
+				sindex_search_by_location = EXPLAIN_LOCATION;
+				break;
+			case 'l':
+				sindex_search_by_location = USAGE_BY_LOCATION;
+				break;
 			case 'f':
 				sindex_search_format = optarg;
 				break;
@@ -371,7 +389,32 @@ static void parse_cmdline_search(int argc, char **argv)
 		}
 	}
 
-	if (optind < argc)
+	if (sindex_search_by_location) {
+		char *str;
+
+		if (optind == argc)
+			sindex_error(1, 0, "one argument required");
+
+		str = argv[optind];
+
+		while (str) {
+			char *ptr;
+
+			if ((ptr = strchr(str, ':')) != NULL)
+				*ptr++ = '\0';
+
+			if (*str != '\0') {
+				if (!sindex_search_filename) {
+					sindex_search_filename = str;
+				} else if (!sindex_search_line) {
+					sindex_search_line = atoi(str);
+				} else if (!sindex_search_column) {
+					sindex_search_column = atoi(str);
+				}
+			}
+			str = ptr;
+		}
+	} else if (optind < argc)
 		sindex_search_symbol = argv[optind++];
 }
 
@@ -1016,6 +1059,33 @@ static void command_search(int argc, char **argv)
 			goto fail;
 	}
 
+	if (sindex_search_by_location == EXPLAIN_LOCATION) {
+		if (query_appendf(query, " AND file.name == %Q", sindex_search_filename) < 0)
+			goto fail;
+		if (sindex_search_line &&
+		    query_appendf(query, " AND sindex.line == %d", sindex_search_line) < 0)
+			goto fail;
+		if (sindex_search_column &&
+		    query_appendf(query, " AND sindex.column == %d", sindex_search_column) < 0)
+			goto fail;
+	} else if (sindex_search_by_location == USAGE_BY_LOCATION) {
+		if (query_appendf(query, " AND sindex.symbol IN (") < 0)
+			goto fail;
+		if (query_appendf(query,
+		                 "SELECT sindex.symbol FROM sindex, file WHERE"
+				 " sindex.file == file.id AND"
+		                 " file.name == %Q", sindex_search_filename) < 0)
+			goto fail;
+		if (sindex_search_line &&
+		    query_appendf(query, " AND sindex.line == %d", sindex_search_line) < 0)
+			goto fail;
+		if (sindex_search_column &&
+		    query_appendf(query, " AND sindex.column == %d", sindex_search_column) < 0)
+			goto fail;
+		if (query_appendf(query, ")") < 0)
+			goto fail;
+	}
+
 	if (query_appendf(query, " ORDER BY file.name, sindex.line, sindex.column ASC", sindex_search_path) < 0)
 		goto fail;
 
-- 
2.25.1

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] sindex: Add option to search by location
Date: Wed, 18 Mar 2020 22:51:27 +0000
Message-ID: <20200318225127.o6pjwwyxrluahqfe () ltop ! local>
--------------------
On Wed, Mar 18, 2020 at 07:39:24PM +0100, Alexey Gladkov wrote:
> To create plugin for text editor, it may be useful to be able to search
> by position in a file.

Look Good. Thanks.
Applied and pushed.

-- Luc 
================================================================================


################################################################################

=== Thread: [PATCH] syntax errors in numbers are not fatal ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] syntax errors in numbers are not fatal
Date: Tue, 14 Jul 2020 21:43:51 +0000
Message-ID: <20200714214351.14516-1-luc.vanoostenryck () gmail ! com>
--------------------
When parsing expressions, if an invalid number is reached, a fatal
error is issued. But this is not the kind of error for which
continuing the processing doesn't make sense, since the token
was already categorized as a number during the tokenization.

So, change the fatal error into a normal one (and set the value to 0).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expression.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/expression.c b/expression.c
index 1160cd9cc593..02bb5b159d9f 100644
--- a/expression.c
+++ b/expression.c
@@ -379,7 +379,10 @@ Float:
 	return;
 
 Enoint:
-	error_die(expr->pos, "constant %s is not a valid number", show_token(token));
+	sparse_error(expr->pos, "constant %s is not a valid number", show_token(token));
+	expr->type = EXPR_VALUE;
+	expr->value = 0;
+	expr->ctype = &int_ctype;
 }
 
 static struct token *generic_selection(struct token *token, struct expression **tree)
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] teach sparse about __STDC_HOSTED__ ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] teach sparse about __STDC_HOSTED__
Date: Mon, 22 Jun 2020 23:12:26 +0000
Message-ID: <20200622231226.89625-1-luc.vanoostenryck () gmail ! com>
--------------------
It seems that some system libraries expect __STDC_HOSTED__ to
be always defined.

So, teach sparse the options flags -f[no-]{hosted,freestanding}
and define __STDC_HOSTED__ accordingly.
---
 lib.c                                  |  4 ++++
 lib.h                                  |  1 +
 validation/preprocessor/freestanding.c | 11 +++++++++++
 validation/preprocessor/hosted.c       | 11 +++++++++++
 4 files changed, 27 insertions(+)
 create mode 100644 validation/preprocessor/freestanding.c
 create mode 100644 validation/preprocessor/hosted.c

diff --git a/lib.c b/lib.c
index 88bb31093deb..e56788260cb7 100644
--- a/lib.c
+++ b/lib.c
@@ -311,6 +311,7 @@ int dbg_ir = 0;
 int dbg_postorder = 0;
 
 unsigned long fdump_ir;
+int fhosted = 1;
 int fmem_report = 0;
 unsigned long long fmemcpy_max_count = 100000;
 unsigned long fpasses = ~0UL;
@@ -994,6 +995,8 @@ static int handle_fmax_warnings(const char *arg, const char *opt, const struct f
 static struct flag fflags[] = {
 	{ "diagnostic-prefix",	NULL,	handle_fdiagnostic_prefix },
 	{ "dump-ir",		NULL,	handle_fdump_ir },
+	{ "freestanding",	&fhosted, NULL, OPT_INVERSE },
+	{ "hosted",		&fhosted },
 	{ "linearize",		NULL,	handle_fpasses,	PASS_LINEARIZE },
 	{ "max-warnings=",	NULL,	handle_fmax_warnings },
 	{ "mem-report",		&fmem_report },
@@ -1300,6 +1303,7 @@ static void predefined_macros(void)
 	predefine("__GNUC_PATCHLEVEL__", 1, "%d", gcc_patchlevel);
 
 	predefine("__STDC__", 1, "1");
+	predefine("__STDC_HOSTED__", 0, fhosted ? "1" : "0");
 	switch (standard) {
 	default:
 		break;
diff --git a/lib.h b/lib.h
index e767840c1038..4f67958efdb9 100644
--- a/lib.h
+++ b/lib.h
@@ -202,6 +202,7 @@ extern int dbg_postorder;
 extern unsigned int fmax_warnings;
 extern int fmem_report;
 extern unsigned long fdump_ir;
+extern int fhosted;
 extern unsigned long long fmemcpy_max_count;
 extern unsigned long fpasses;
 extern int fpic;
diff --git a/validation/preprocessor/freestanding.c b/validation/preprocessor/freestanding.c
new file mode 100644
index 000000000000..7ee35354f711
--- /dev/null
+++ b/validation/preprocessor/freestanding.c
@@ -0,0 +1,11 @@
+__STDC_HOSTED__
+
+/*
+ * check-name: freestanding
+ * check-command: sparse -E -ffreestanding $file
+ *
+ * check-output-start
+
+0
+ * check-output-end
+ */
diff --git a/validation/preprocessor/hosted.c b/validation/preprocessor/hosted.c
new file mode 100644
index 000000000000..e6b3d3c1d6b7
--- /dev/null
+++ b/validation/preprocessor/hosted.c
@@ -0,0 +1,11 @@
+__STDC_HOSTED__
+
+/*
+ * check-name: hosted
+ * check-command: sparse -E -fhosted $file
+ *
+ * check-output-start
+
+1
+ * check-output-end
+ */
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] testsuite: be less paranoid with timeout ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] testsuite: be less paranoid with timeout
Date: Tue, 16 Jun 2020 21:11:06 +0000
Message-ID: <20200616211106.78251-1-luc.vanoostenryck () gmail ! com>
--------------------
For some testcases, the testsuite use the command 'timeout'
to ensure that the test finish after a reasonable amount of
time. This is mainly used for some testcases which, in the past,
were stuck in an infinite loop. This the command 'timeout' is
used with an extra option (-k 1s) to issue a second kill signal
in case the first one would have been ignored.

However, this extra option is not supported on all implementations
(Alpine) and its use seems a bit paranoid for sparse.

So, remove this extra option.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/validation/test-suite b/validation/test-suite
index 64a3e08fb4dd..a22f70135fb3 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -338,7 +338,7 @@ do_test()
 	# do we want a timeout?
 	pre_cmd=""
 	if [ $check_timeout -ne 0 ]; then
-		pre_cmd="timeout -k 1s $check_timeout"
+		pre_cmd="timeout $check_timeout"
 	fi
 
 	shift
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [PATCH] testsuite: fix erroneous comment ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] testsuite: fix erroneous comment
Date: Wed, 30 Sep 2020 23:40:58 +0000
Message-ID: <20200930234058.67157-1-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/optim/canonical-mul.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/validation/optim/canonical-mul.c b/validation/optim/canonical-mul.c
index 3ae9e3a64c0f..0c14226faaaf 100644
--- a/validation/optim/canonical-mul.c
+++ b/validation/optim/canonical-mul.c
@@ -7,7 +7,7 @@ uint xtc_umul_ytc(uint x, uint y) { return (x * 3) * (y * 2); }
  * check-description:
  *	1) verify that constants in mul chains are
  *	   pushed at the right of the whole chain.
- *	   For example '(a * 3) * b' must be canonicalized into '(a * b) * 1'
+ *	   For example '(a * 3) * b' must be canonicalized into '(a * b) * 3'
  *	   This is needed in general for constant simplification;
  *	   for example, for:
  *		'(a * 3) * (b * 2)'
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH] univ-init: set default to -Wno-universal-initializer ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] univ-init: set default to -Wno-universal-initializer
Date: Sat, 30 May 2020 15:49:45 +0000
Message-ID: <20200530154945.44985-1-luc.vanoostenryck () gmail ! com>
--------------------
'{ 0 }' is the standard idiom for the universal zero initializer '{ }'.

But if the '0' is taken literally, warnings can be issued, for exemple
for 'using 0 as NULL pointer' or for 'using a positional initializer'
when the attribute 'designated_init' is used.
These warnings were not intended to be issued for this initializer
and are confusing and annoying when people have to use or want to
use standard code or ignore that '{ }' is fine to use with GCC,
clang or Sparse.

So, set sparse default to -Wno-universal-initializer, suppressing
any warnings caused by using '{ 0 }' instead of '{ }'.

Reference: https://lore.kernel.org/git/e6796c60-a870-e761-3b07-b680f934c537@ramsayjones.plus.com/
Reference: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95379
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib.c b/lib.c
index 9ee8d3cf6b21..37c09d914c56 100644
--- a/lib.c
+++ b/lib.c
@@ -295,7 +295,7 @@ int Wtransparent_union = 0;
 int Wtypesign = 0;
 int Wundef = 0;
 int Wuninitialized = 1;
-int Wuniversal_initializer = 1;
+int Wuniversal_initializer = 0;
 int Wunknown_attribute = 0;
 int Wvla = 1;
 
-- 
2.26.2

================================================================================


################################################################################

=== Thread: [PATCH] warning: conditionalize "advancing past deep designator" ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] warning: conditionalize "advancing past deep designator"
Date: Mon, 10 Aug 2020 05:52:33 +0000
Message-ID: <20200810055233.68045-1-luc.vanoostenryck () gmail ! com>
--------------------
The warning "advancing past deep designator" is issued when a
multi-level (deep) designator is followed by a non-designated one.

But it's far from clear what is the value of this warning, what
could be the confusion about this situation and what is special
about these 'deep' designators?

There are hundreds such occurrences in the kernel (394 in the configs
I use for testing) and GCC, clang and sparse have no problems to handle
them correctly. This means that there is also 0 chances that they
will be 'corrected'.

So, add conditionalize this warning with a '-Wpast-deep-designator'
and make it false by default.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 4 ++--
 options.c  | 2 ++
 options.h  | 1 +
 sparse.1   | 7 +++++++
 4 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 9990b57bba78..794f8425f064 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2614,7 +2614,7 @@ static void handle_list_initializer(struct expression *expr,
 		int class, struct symbol *ctype, unsigned long mods)
 {
 	struct expression *e, *last = NULL, *top = NULL, *next;
-	int jumped = 0;
+	int jumped = 0;	// has the last designator multiple levels?
 
 	if (expr->zero_init)
 		free_ptr_list(&expr->expr_list);
@@ -2647,7 +2647,7 @@ static void handle_list_initializer(struct expression *expr,
 					ctype->ident ? ": " : "",
 					get_type_name(struct_sym->type),
 					show_ident(struct_sym->ident));
-			if (jumped) {
+			if (jumped && Wpast_deep_designator) {
 				warning(e->pos, "advancing past deep designator");
 				jumped = 0;
 			}
diff --git a/options.c b/options.c
index f7e81b84d749..9538a2171d33 100644
--- a/options.c
+++ b/options.c
@@ -113,6 +113,7 @@ int Woverride_init = 1;
 int Woverride_init_all = 0;
 int Woverride_init_whole_range = 0;
 int Wparen_string = 0;
+int Wpast_deep_designator = 0;
 int Wpedantic = 0;
 int Wpointer_arith = 0;
 int Wpointer_to_int_cast = 1;
@@ -850,6 +851,7 @@ static const struct flag warnings[] = {
 	{ "override-init", &Woverride_init },
 	{ "override-init-all", &Woverride_init_all },
 	{ "paren-string", &Wparen_string },
+	{ "past-deep-designator", &Wpast_deep_designator },
 	{ "pedantic", &Wpedantic },
 	{ "pointer-to-int-cast", &Wpointer_to_int_cast },
 	{ "ptr-subtraction-blows", &Wptr_subtraction_blows },
diff --git a/options.h b/options.h
index 070c0dd87183..90358752f213 100644
--- a/options.h
+++ b/options.h
@@ -112,6 +112,7 @@ extern int Woverride_init;
 extern int Woverride_init_all;
 extern int Woverride_init_whole_range;
 extern int Wparen_string;
+extern int Wpast_deep_designator;
 extern int Wpedantic;
 extern int Wpointer_arith;
 extern int Wpointer_to_int_cast;
diff --git a/sparse.1 b/sparse.1
index 60203d5a6463..34e66088f307 100644
--- a/sparse.1
+++ b/sparse.1
@@ -345,6 +345,13 @@ Standard C syntax does not permit a parenthesized string as an array
 initializer.  GCC allows this syntax as an extension.  With
 \fB\-Wparen\-string\fR, Sparse will warn about this syntax.
 
+Sparse does not issue these warnings by default.
+.
+.TP
+.B -Wpast-deep-designator
+Warn when, in a initializer-list, a initializer with a deep (nested)
+designator is followed by a non-designated one.
+
 Sparse does not issue these warnings by default.
 .
 .TP
-- 
2.28.0

================================================================================


################################################################################

=== Thread: [PATCH] warnings: ensure the source filename is shown at least once ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] warnings: ensure the source filename is shown at least once
Date: Sat, 18 Jul 2020 18:39:55 +0000
Message-ID: <20200718183955.16718-1-luc.vanoostenryck () gmail ! com>
--------------------
When checking a series of files, if some warnings or errors
are issued but only coming from some includes, it's not possible
to identify which source file is responsible since its filename
is not displayed.

So, if the first warning is from a file other than the source
file, display first a note coming from the source file itself.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c                         | 13 +++++++++++++
 validation/cast-kinds-check.c |  1 +
 2 files changed, 14 insertions(+)

diff --git a/lib.c b/lib.c
index 4e8d7b451747..b94c2c83c1c5 100644
--- a/lib.c
+++ b/lib.c
@@ -50,6 +50,18 @@
 #include "bits.h"
 
 
+static void show_top_filename(const char *name)
+{
+	static const char *last;
+
+	if (name == base_filename)
+		return;
+	if (name == last)
+		return;
+	fprintf(stderr, "%s: note: in included file:\n", base_filename);
+	last = name;
+}
+
 static void do_warn(const char *type, struct position pos, const char * fmt, va_list args)
 {
 	static char buffer[512];
@@ -63,6 +75,7 @@ static void do_warn(const char *type, struct position pos, const char * fmt, va_
 	name = stream_name(pos.stream);
 		
 	fflush(stdout);
+	show_top_filename(name);
 	fprintf(stderr, "%s:%d:%d: %s%s%s\n",
 		name, pos.line, pos.pos, diag_prefix, type, buffer);
 }
diff --git a/validation/cast-kinds-check.c b/validation/cast-kinds-check.c
index 0c0cd67368a3..32a106d413da 100644
--- a/validation/cast-kinds-check.c
+++ b/validation/cast-kinds-check.c
@@ -6,6 +6,7 @@
  * check-assert: sizeof(long) == 8
  *
  * check-error-start
+cast-kinds-check.c: note: in included file:
 optim/cast-kinds.c:5:45: warning: cast drops bits
 optim/cast-kinds.c:6:47: warning: cast drops bits
 optim/cast-kinds.c:7:46: warning: cast drops bits
-- 
2.27.0

================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH] warnings: ensure the source filename is shown at least once
Date: Sat, 18 Jul 2020 20:21:35 +0000
Message-ID: <CAHk-=wjAe_XCz9O2z_FRAOw4iA1+zF9Mcvi3Mp17tpH9y+cLkQ () mail ! gmail ! com>
--------------------
--00000000000014402305aabd0649
Content-Type: text/plain; charset="UTF-8"

On Sat, Jul 18, 2020 at 11:40 AM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> When checking a series of files, if some warnings or errors
> are issued but only coming from some includes, it's not possible
> to identify which source file is responsible since its filename
> is not displayed.
>
> So, if the first warning is from a file other than the source
> file, display first a note coming from the source file itself.

This really isn't enough when the include chain is deeper and more complex.

How about something a bit more complex? This is only lightly tested,
but I don't have time for anything more right now..

It results in things like

    kernel/exit.c: note: in included file (through
include/linux/sched/signal.h, include/linux/rcuwait.h,
include/linux/percpu-rwsem.h, include/linux/fs.h,
include/linux/huge_mm.h, include/linux/mm.h):
    ./include/linux/sched/task.h:115:34: warning: context imbalance in
'wait_task_zombie' - unexpected unlock
    ./include/linux/sched/task.h:115:34: warning: context imbalance in
'wait_task_stopped' - unexpected unlock
    ./include/linux/sched/task.h:115:34: warning: context imbalance in
'wait_task_continued' - unexpected unlock

to give an example of a warning happening in a header file that got
included through a deeper chain.

That stream chaining information might perhaps be useful for other cases too?

Would it be better to save the whole 'pos' for the chain, so that
you'd get line numbers etc for the chain? Probably. As mentioned, this
is a quick "how about something like this".

If you extend it and do more testing, you can have my sign-off, or
just take ownership of the patch entirely with my ack..

Now off for more kernel stuff after a quick sparse excursion...

                   Linus

--00000000000014402305aabd0649
Content-Type: application/octet-stream; name=patch
Content-Disposition: attachment; filename=patch
Content-Transfer-Encoding: base64
Content-ID: <f_kcs3e4a20>
X-Attachment-Id: f_kcs3e4a20

IGxpYi5jICAgICAgICAgfCA4NiArKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysr
KysrKysrKysrKysrKysrKysrLS0tLQogcHJlLXByb2Nlc3MuYyB8IDEyICsrKystLS0tLQogc3lt
Ym9sLmMgICAgICB8ICAyICstCiB0b2tlbi5oICAgICAgIHwgIDcgKystLS0KIHRva2VuaXplLmMg
ICAgfCAxNCArKysrKysrLS0tCiA1IGZpbGVzIGNoYW5nZWQsIDEwMyBpbnNlcnRpb25zKCspLCAx
OCBkZWxldGlvbnMoLSkKCmRpZmYgLS1naXQgYS9saWIuYyBiL2xpYi5jCmluZGV4IDRlOGQ3YjQ1
Li5kY2JiYjViMyAxMDA2NDQKLS0tIGEvbGliLmMKKysrIGIvbGliLmMKQEAgLTQ5LDIyICs0OSw5
OCBAQAogI2luY2x1ZGUgInZlcnNpb24uaCIKICNpbmNsdWRlICJiaXRzLmgiCiAKK3N0YXRpYyBp
bnQgcHJldHRpZnkoY29uc3QgY2hhciAqKmZuYW1lcCkKK3sKKwljb25zdCBjaGFyICpuYW1lID0g
KmZuYW1lcDsKKwlpbnQgbGVuID0gc3RybGVuKG5hbWUpOworCisJaWYgKGxlbiA+IDIgJiYgIW1l
bWNtcChuYW1lLCAiLi8iLCAyKSkgeworCQluYW1lICs9IDI7CisJCWxlbiAtPSAyOworCX0KKwor
CSpmbmFtZXAgPSBuYW1lOworCXJldHVybiBsZW47Cit9CisKK3N0YXRpYyBjb25zdCBjaGFyICpz
aG93X2luY2x1ZGVfY2hhaW4oaW50IHN0cmVhbSwgY29uc3QgY2hhciAqYmFzZSkKK3sKKwlzdGF0
aWMgY2hhciBidWZmZXJbMjAwXTsKKwlpbnQgbGVuID0gMDsKKworCXdoaWxlICgoc3RyZWFtID0g
c3RyZWFtX3ByZXYoc3RyZWFtKSkgPj0gMCkgeworCQljb25zdCBjaGFyICpwID0gc3RyZWFtX25h
bWUoc3RyZWFtKTsKKwkJaW50IHByZXR0eV9sZW47CisKKwkJaWYgKHAgPT0gYmFzZSkKKwkJCWJy
ZWFrOworCisJCXByZXR0eV9sZW4gPSBwcmV0dGlmeSgmcCk7CisJCWlmIChwcmV0dHlfbGVuIDw9
IDApCisJCQlicmVhazsKKworCQkvKgorCQkgKiBBdCB3b3JzdCwgd2UnbGwgbmVlZCAiICh0aHJv
dWdoICVzLCAuLi4pIiBpbiBhZGRpdGlvbiB0byB0aGUKKwkJICogbmV3IGZpbGVuYW1lCisJCSAq
LworCQlpZiAocHJldHR5X2xlbiArIGxlbiArIDIwID4gc2l6ZW9mKGJ1ZmZlcikpIHsKKwkJCWlm
ICghbGVuKQorCQkJCXJldHVybiAiIjsKKwkJCW1lbWNweShidWZmZXIrbGVuLCAiLCAuLi4iLCA1
KTsKKwkJCWxlbiArPSA1OworCQkJYnJlYWs7CisJCX0KKworCQlpZiAoIWxlbikgeworCQkJbWVt
Y3B5KGJ1ZmZlciwgIiAodGhyb3VnaCAiLCAxMCk7CisJCQlsZW4gPSAxMDsKKwkJfSBlbHNlIHsK
KwkJCWJ1ZmZlcltsZW4rK10gPSAnLCc7CisJCQlidWZmZXJbbGVuKytdID0gJyAnOworCQl9CisK
KwkJbWVtY3B5KGJ1ZmZlcitsZW4sIHAsIHByZXR0eV9sZW4pOworCQlsZW4gKz0gcHJldHR5X2xl
bjsKKwl9CisJaWYgKCFsZW4pCisJCXJldHVybiAiIjsKKworCWJ1ZmZlcltsZW5dID0gJyknOwor
CWJ1ZmZlcltsZW4rMV0gPSAwOworCXJldHVybiBidWZmZXI7Cit9CisKK3N0YXRpYyBjb25zdCBj
aGFyICpzaG93X3N0cmVhbV9uYW1lKHN0cnVjdCBwb3NpdGlvbiBwb3MpCit7CisJY29uc3QgY2hh
ciAqbmFtZSA9IHN0cmVhbV9uYW1lKHBvcy5zdHJlYW0pOworCXN0YXRpYyBjb25zdCBjaGFyICps
YXN0OworCisJaWYgKG5hbWUgPT0gYmFzZV9maWxlbmFtZSkKKwkJcmV0dXJuIG5hbWU7CisJaWYg
KG5hbWUgPT0gbGFzdCkKKwkJcmV0dXJuIG5hbWU7CisJbGFzdCA9IG5hbWU7CisKKwlmcHJpbnRm
KHN0ZGVyciwgIiVzOiBub3RlOiBpbiBpbmNsdWRlZCBmaWxlJXM6XG4iLAorCQliYXNlX2ZpbGVu
YW1lLAorCQlzaG93X2luY2x1ZGVfY2hhaW4ocG9zLnN0cmVhbSwgYmFzZV9maWxlbmFtZSkpOwor
CXJldHVybiBuYW1lOworfQogCiBzdGF0aWMgdm9pZCBkb193YXJuKGNvbnN0IGNoYXIgKnR5cGUs
IHN0cnVjdCBwb3NpdGlvbiBwb3MsIGNvbnN0IGNoYXIgKiBmbXQsIHZhX2xpc3QgYXJncykKIHsK
IAlzdGF0aWMgY2hhciBidWZmZXJbNTEyXTsKLQljb25zdCBjaGFyICpuYW1lOwogCiAJLyogU2h1
dCB1cCB3YXJuaW5ncyBpZiBwb3NpdGlvbiBpcyBiYWRfdG9rZW4ucG9zICovCiAJaWYgKHBvcy50
eXBlID09IFRPS0VOX0JBRCkKIAkJcmV0dXJuOwogCiAJdnNwcmludGYoYnVmZmVyLCBmbXQsIGFy
Z3MpOwkKLQluYW1lID0gc3RyZWFtX25hbWUocG9zLnN0cmVhbSk7Ci0JCQorCiAJZmZsdXNoKHN0
ZG91dCk7CiAJZnByaW50ZihzdGRlcnIsICIlczolZDolZDogJXMlcyVzXG4iLAotCQluYW1lLCBw
b3MubGluZSwgcG9zLnBvcywgZGlhZ19wcmVmaXgsIHR5cGUsIGJ1ZmZlcik7CisJCXNob3dfc3Ry
ZWFtX25hbWUocG9zKSwgcG9zLmxpbmUsIHBvcy5wb3MsCisJCWRpYWdfcHJlZml4LCB0eXBlLCBi
dWZmZXIpOwogfQogCiBzdGF0aWMgaW50IHNob3dfaW5mbyA9IDE7CkBAIC0yNzUsNyArMzUxLDcg
QEAgc3RhdGljIHN0cnVjdCBzeW1ib2xfbGlzdCAqc3BhcnNlX2ZpbGUoY29uc3QgY2hhciAqZmls
ZW5hbWUpCiAJYmFzZV9maWxlbmFtZSA9IGZpbGVuYW1lOwogCiAJLy8gVG9rZW5pemUgdGhlIGlu
cHV0IHN0cmVhbQotCXRva2VuID0gdG9rZW5pemUoZmlsZW5hbWUsIGZkLCBOVUxMLCBpbmNsdWRl
cGF0aCk7CisJdG9rZW4gPSB0b2tlbml6ZShmaWxlbmFtZSwgZmQsIC0xLCBOVUxMLCBpbmNsdWRl
cGF0aCk7CiAJY2xvc2UoZmQpOwogCiAJcmV0dXJuIHNwYXJzZV90b2tlbnN0cmVhbSh0b2tlbik7
CmRpZmYgLS1naXQgYS9wcmUtcHJvY2Vzcy5jIGIvcHJlLXByb2Nlc3MuYwppbmRleCA0MDNlMzUw
Ny4uYWI5NzRiMjIgMTAwNjQ0Ci0tLSBhL3ByZS1wcm9jZXNzLmMKKysrIGIvcHJlLXByb2Nlc3Mu
YwpAQCAtODk0LDcgKzg5NCw3IEBAIHN0YXRpYyB2b2lkIHNldF9zdHJlYW1faW5jbHVkZV9wYXRo
KHN0cnVjdCBzdHJlYW0gKnN0cmVhbSkKICNkZWZpbmUgUEFUSF9NQVggNDA5NgkvLyBmb3IgSHVy
ZCB3aGVyZSBpdCdzIG5vdCBkZWZpbmVkCiAjZW5kaWYKIAotc3RhdGljIGludCB0cnlfaW5jbHVk
ZShjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICpmaWxlbmFtZSwgaW50IGZsZW4sIHN0cnVj
dCB0b2tlbiAqKndoZXJlLCBjb25zdCBjaGFyICoqbmV4dF9wYXRoKQorc3RhdGljIGludCB0cnlf
aW5jbHVkZShzdHJ1Y3QgcG9zaXRpb24gcG9zLCBjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFy
ICpmaWxlbmFtZSwgaW50IGZsZW4sIHN0cnVjdCB0b2tlbiAqKndoZXJlLCBjb25zdCBjaGFyICoq
bmV4dF9wYXRoKQogewogCWludCBmZDsKIAlpbnQgcGxlbiA9IHN0cmxlbihwYXRoKTsKQEAgLTkx
MCw4ICs5MTAsOCBAQCBzdGF0aWMgaW50IHRyeV9pbmNsdWRlKGNvbnN0IGNoYXIgKnBhdGgsIGNv
bnN0IGNoYXIgKmZpbGVuYW1lLCBpbnQgZmxlbiwgc3RydWN0CiAJCXJldHVybiAxOwogCWZkID0g
b3BlbihmdWxsbmFtZSwgT19SRE9OTFkpOwogCWlmIChmZCA+PSAwKSB7Ci0JCWNoYXIgKnN0cmVh
bW5hbWUgPSB4bWVtZHVwKGZ1bGxuYW1lLCBwbGVuICsgZmxlbik7Ci0JCSp3aGVyZSA9IHRva2Vu
aXplKHN0cmVhbW5hbWUsIGZkLCAqd2hlcmUsIG5leHRfcGF0aCk7CisJCWNoYXIgKnN0cmVhbW5h
bWUgPSBzdHJlYW1uYW1lID0geG1lbWR1cChmdWxsbmFtZSwgcGxlbiArIGZsZW4pOworCQkqd2hl
cmUgPSB0b2tlbml6ZShzdHJlYW1uYW1lLCBmZCwgcG9zLnN0cmVhbSwgKndoZXJlLCBuZXh0X3Bh
dGgpOwogCQljbG9zZShmZCk7CiAJCXJldHVybiAxOwogCX0KQEAgLTkyMyw3ICs5MjMsNyBAQCBz
dGF0aWMgaW50IGRvX2luY2x1ZGVfcGF0aChjb25zdCBjaGFyICoqcHB0ciwgc3RydWN0IHRva2Vu
ICoqbGlzdCwgc3RydWN0IHRva2VuCiAJY29uc3QgY2hhciAqcGF0aDsKIAogCXdoaWxlICgocGF0
aCA9ICpwcHRyKyspICE9IE5VTEwpIHsKLQkJaWYgKCF0cnlfaW5jbHVkZShwYXRoLCBmaWxlbmFt
ZSwgZmxlbiwgbGlzdCwgcHB0cikpCisJCWlmICghdHJ5X2luY2x1ZGUodG9rZW4tPnBvcywgcGF0
aCwgZmlsZW5hbWUsIGZsZW4sIGxpc3QsIHBwdHIpKQogCQkJY29udGludWU7CiAJCXJldHVybiAx
OwogCX0KQEAgLTk2Niw3ICs5NjYsNyBAQCBzdGF0aWMgaW50IGhhbmRsZV9pbmNsdWRlX3BhdGgo
c3RydWN0IHN0cmVhbSAqc3RyZWFtLCBzdHJ1Y3QgdG9rZW4gKipsaXN0LCBzdHJ1YwogCiAJLyog
QWJzb2x1dGUgcGF0aD8gKi8KIAlpZiAoZmlsZW5hbWVbMF0gPT0gJy8nKSB7Ci0JCWlmICh0cnlf
aW5jbHVkZSgiIiwgZmlsZW5hbWUsIGZsZW4sIGxpc3QsIGluY2x1ZGVwYXRoKSkKKwkJaWYgKHRy
eV9pbmNsdWRlKHRva2VuLT5wb3MsICIiLCBmaWxlbmFtZSwgZmxlbiwgbGlzdCwgaW5jbHVkZXBh
dGgpKQogCQkJcmV0dXJuIDA7CiAJCWdvdG8gb3V0OwogCX0KQEAgLTIwOTEsNyArMjA5MSw3IEBA
IHN0YXRpYyB2b2lkIGNyZWF0ZV9hcmdsaXN0KHN0cnVjdCBzeW1ib2wgKnN5bSwgaW50IGNvdW50
KQogc3RhdGljIHZvaWQgaW5pdF9wcmVwcm9jZXNzb3Iodm9pZCkKIHsKIAlpbnQgaTsKLQlpbnQg
c3RyZWFtID0gaW5pdF9zdHJlYW0oInByZXByb2Nlc3NvciIsIC0xLCBpbmNsdWRlcGF0aCk7CisJ
aW50IHN0cmVhbSA9IGluaXRfc3RyZWFtKCJwcmVwcm9jZXNzb3IiLCAtMSwgaW5jbHVkZXBhdGgs
IC0xKTsKIAlzdGF0aWMgc3RydWN0IHsKIAkJY29uc3QgY2hhciAqbmFtZTsKIAkJaW50ICgqaGFu
ZGxlcikoc3RydWN0IHN0cmVhbSAqLCBzdHJ1Y3QgdG9rZW4gKiosIHN0cnVjdCB0b2tlbiAqKTsK
ZGlmZiAtLWdpdCBhL3N5bWJvbC5jIGIvc3ltYm9sLmMKaW5kZXggYzBjYTc5ZTQuLjJjYzlmODJk
IDEwMDY0NAotLS0gYS9zeW1ib2wuYworKysgYi9zeW1ib2wuYwpAQCAtNzc2LDcgKzc3Niw3IEBA
IHN0cnVjdCBzeW1ib2wJemVyb19pbnQ7CiAKIHZvaWQgaW5pdF9zeW1ib2xzKHZvaWQpCiB7Ci0J
aW50IHN0cmVhbSA9IGluaXRfc3RyZWFtKCJidWlsdGluIiwgLTEsIGluY2x1ZGVwYXRoKTsKKwlp
bnQgc3RyZWFtID0gaW5pdF9zdHJlYW0oImJ1aWx0aW4iLCAtMSwgaW5jbHVkZXBhdGgsIC0xKTsK
IAogI2RlZmluZSBfX0lERU5UKG4sc3RyLHJlcykgXAogCWhhc2hfaWRlbnQoJm4pCmRpZmYgLS1n
aXQgYS90b2tlbi5oIGIvdG9rZW4uaAppbmRleCBjNWZkZjNkMC4uNmQyYjBiNjUgMTAwNjQ0Ci0t
LSBhL3Rva2VuLmgKKysrIGIvdG9rZW4uaApAQCAtNDksNyArNDksNyBAQCBlbnVtIGNvbnN0YW50
ZmlsZSB7CiBleHRlcm4gY29uc3QgY2hhciAqaW5jbHVkZXBhdGhbXTsKIAogc3RydWN0IHN0cmVh
bSB7Ci0JaW50IGZkOworCWludCBmZCwgcHJldjsKIAljb25zdCBjaGFyICpuYW1lOwogCWNvbnN0
IGNoYXIgKnBhdGg7ICAgIC8vIGlucHV0LWZpbGUgcGF0aCAtIHNlZSBzZXRfc3RyZWFtX2luY2x1
ZGVfcGF0aCgpCiAJY29uc3QgY2hhciAqKm5leHRfcGF0aDsKQEAgLTIxNCw3ICsyMTQsOCBAQCBz
dGF0aWMgaW5saW5lIHN0cnVjdCB0b2tlbiAqY29udGFpbmluZ190b2tlbihzdHJ1Y3QgdG9rZW4g
KipwKQogZXh0ZXJuIHN0cnVjdCB0b2tlbiBlb2ZfdG9rZW5fZW50cnk7CiAjZGVmaW5lIGVvZl90
b2tlbih4KSAoKHgpID09ICZlb2ZfdG9rZW5fZW50cnkpCiAKLWV4dGVybiBpbnQgaW5pdF9zdHJl
YW0oY29uc3QgY2hhciAqLCBpbnQgZmQsIGNvbnN0IGNoYXIgKipuZXh0X3BhdGgpOworZXh0ZXJu
IGludCBpbml0X3N0cmVhbShjb25zdCBjaGFyICosIGludCBmZCwgY29uc3QgY2hhciAqKm5leHRf
cGF0aCwgaW50IHByZXZfc3RyZWFtKTsKK2V4dGVybiBpbnQgc3RyZWFtX3ByZXYoaW50IHN0cmVh
bSk7CiBleHRlcm4gY29uc3QgY2hhciAqc3RyZWFtX25hbWUoaW50IHN0cmVhbSk7CiBleHRlcm4g
c3RydWN0IGlkZW50ICpoYXNoX2lkZW50KHN0cnVjdCBpZGVudCAqKTsKIGV4dGVybiBzdHJ1Y3Qg
aWRlbnQgKmJ1aWx0X2luX2lkZW50KGNvbnN0IGNoYXIgKik7CkBAIC0yMjQsNyArMjI1LDcgQEAg
ZXh0ZXJuIGNvbnN0IGNoYXIgKnNob3dfaWRlbnQoY29uc3Qgc3RydWN0IGlkZW50ICopOwogZXh0
ZXJuIGNvbnN0IGNoYXIgKnNob3dfc3RyaW5nKGNvbnN0IHN0cnVjdCBzdHJpbmcgKnN0cmluZyk7
CiBleHRlcm4gY29uc3QgY2hhciAqc2hvd190b2tlbihjb25zdCBzdHJ1Y3QgdG9rZW4gKik7CiBl
eHRlcm4gY29uc3QgY2hhciAqcXVvdGVfdG9rZW4oY29uc3Qgc3RydWN0IHRva2VuICopOwotZXh0
ZXJuIHN0cnVjdCB0b2tlbiAqIHRva2VuaXplKGNvbnN0IGNoYXIgKiwgaW50LCBzdHJ1Y3QgdG9r
ZW4gKiwgY29uc3QgY2hhciAqKm5leHRfcGF0aCk7CitleHRlcm4gc3RydWN0IHRva2VuICogdG9r
ZW5pemUoY29uc3QgY2hhciAqLCBpbnQsIGludCwgc3RydWN0IHRva2VuICosIGNvbnN0IGNoYXIg
KipuZXh0X3BhdGgpOwogZXh0ZXJuIHN0cnVjdCB0b2tlbiAqIHRva2VuaXplX2J1ZmZlcih2b2lk
ICosIHVuc2lnbmVkIGxvbmcsIHN0cnVjdCB0b2tlbiAqKik7CiAKIGV4dGVybiB2b2lkIHNob3df
aWRlbnRpZmllcl9zdGF0cyh2b2lkKTsKZGlmZiAtLWdpdCBhL3Rva2VuaXplLmMgYi90b2tlbml6
ZS5jCmluZGV4IGQzMzcxZTFlLi5jNWJhNmU2YiAxMDA2NDQKLS0tIGEvdG9rZW5pemUuYworKysg
Yi90b2tlbml6ZS5jCkBAIC02Miw2ICs2MiwxMyBAQCBjb25zdCBjaGFyICpzdHJlYW1fbmFtZShp
bnQgc3RyZWFtKQogCXJldHVybiBpbnB1dF9zdHJlYW1zW3N0cmVhbV0ubmFtZTsKIH0KIAoraW50
IHN0cmVhbV9wcmV2KGludCBzdHJlYW0pCit7CisJaWYgKHN0cmVhbSA8IDAgfHwgc3RyZWFtID4g
aW5wdXRfc3RyZWFtX25yKQorCQlyZXR1cm4gLTE7CisJcmV0dXJuIGlucHV0X3N0cmVhbXNbc3Ry
ZWFtXS5wcmV2OworfQorCiBzdGF0aWMgc3RydWN0IHBvc2l0aW9uIHN0cmVhbV9wb3Moc3RyZWFt
X3QgKnN0cmVhbSkKIHsKIAlzdHJ1Y3QgcG9zaXRpb24gcG9zOwpAQCAtMzAwLDcgKzMwNyw3IEBA
IGludCAqaGFzaF9zdHJlYW0oY29uc3QgY2hhciAqbmFtZSkKIAlyZXR1cm4gaW5wdXRfc3RyZWFt
X2hhc2hlcyArIGhhc2g7CiB9CiAKLWludCBpbml0X3N0cmVhbShjb25zdCBjaGFyICpuYW1lLCBp
bnQgZmQsIGNvbnN0IGNoYXIgKipuZXh0X3BhdGgpCitpbnQgaW5pdF9zdHJlYW0oY29uc3QgY2hh
ciAqbmFtZSwgaW50IGZkLCBjb25zdCBjaGFyICoqbmV4dF9wYXRoLCBpbnQgcHJldl9zdHJlYW0p
CiB7CiAJaW50IHN0cmVhbSA9IGlucHV0X3N0cmVhbV9uciwgKmhhc2g7CiAJc3RydWN0IHN0cmVh
bSAqY3VycmVudDsKQEAgLTMxOSw2ICszMjYsNyBAQCBpbnQgaW5pdF9zdHJlYW0oY29uc3QgY2hh
ciAqbmFtZSwgaW50IGZkLCBjb25zdCBjaGFyICoqbmV4dF9wYXRoKQogCWN1cnJlbnQtPm5leHRf
cGF0aCA9IG5leHRfcGF0aDsKIAljdXJyZW50LT5wYXRoID0gTlVMTDsKIAljdXJyZW50LT5jb25z
dGFudCA9IENPTlNUQU5UX0ZJTEVfTUFZQkU7CisJY3VycmVudC0+cHJldiA9IHByZXZfc3RyZWFt
OwogCWlucHV0X3N0cmVhbV9uciA9IHN0cmVhbSsxOwogCWhhc2ggPSBoYXNoX3N0cmVhbShuYW1l
KTsKIAljdXJyZW50LT5uZXh0X3N0cmVhbSA9ICpoYXNoOwpAQCAtMTAwNiwxNCArMTAxNCwxNCBA
QCBzdHJ1Y3QgdG9rZW4gKiB0b2tlbml6ZV9idWZmZXIodm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBs
b25nIHNpemUsIHN0cnVjdCB0b2tlbiAqKgogCXJldHVybiBiZWdpbjsKIH0KIAotc3RydWN0IHRv
a2VuICogdG9rZW5pemUoY29uc3QgY2hhciAqbmFtZSwgaW50IGZkLCBzdHJ1Y3QgdG9rZW4gKmVu
ZHRva2VuLCBjb25zdCBjaGFyICoqbmV4dF9wYXRoKQorc3RydWN0IHRva2VuICogdG9rZW5pemUo
Y29uc3QgY2hhciAqbmFtZSwgaW50IGZkLCBpbnQgcHJldl9zdHJlYW0sIHN0cnVjdCB0b2tlbiAq
ZW5kdG9rZW4sIGNvbnN0IGNoYXIgKipuZXh0X3BhdGgpCiB7CiAJc3RydWN0IHRva2VuICpiZWdp
biwgKmVuZDsKIAlzdHJlYW1fdCBzdHJlYW07CiAJdW5zaWduZWQgY2hhciBidWZmZXJbQlVGU0la
RV07CiAJaW50IGlkeDsKIAotCWlkeCA9IGluaXRfc3RyZWFtKG5hbWUsIGZkLCBuZXh0X3BhdGgp
OworCWlkeCA9IGluaXRfc3RyZWFtKG5hbWUsIGZkLCBuZXh0X3BhdGgsIHByZXZfc3RyZWFtKTsK
IAlpZiAoaWR4IDwgMCkgewogCQkvLyBpbmZvKGVuZHRva2VuLT5wb3MsICJGaWxlICVzIGlzIGNv
bnN0IiwgbmFtZSk7CiAJCXJldHVybiBlbmR0b2tlbjsK
--00000000000014402305aabd0649--
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] warnings: ensure the source filename is shown at least once
Date: Sat, 18 Jul 2020 23:36:58 +0000
Message-ID: <20200718233658.nf7ry2nbw4mrviry () ltop ! local>
--------------------
On Sat, Jul 18, 2020 at 01:21:35PM -0700, Linus Torvalds wrote:
> On Sat, Jul 18, 2020 at 11:40 AM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > When checking a series of files, if some warnings or errors
> > are issued but only coming from some includes, it's not possible
> > to identify which source file is responsible since its filename
> > is not displayed.
> >
> > So, if the first warning is from a file other than the source
> > file, display first a note coming from the source file itself.
> 
> This really isn't enough when the include chain is deeper and more complex.

Yes, my use case was much more limited.
 
> How about something a bit more complex? This is only lightly tested,
> but I don't have time for anything more right now..
> 
> It results in things like

I like it a lot and it works nicely.
 
> That stream chaining information might perhaps be useful for other cases too?

For sparse itself, I don't know, but for some other tools that would
analyze the code/#include structure, yes surely.
 
> Would it be better to save the whole 'pos' for the chain, so that
> you'd get line numbers etc for the chain? Probably. As mentioned, this
> is a quick "how about something like this".

I added this in a following patch.
 
> If you extend it and do more testing, you can have my sign-off, or
> just take ownership of the patch entirely with my ack..

I only removed a repetition in an initialization, so I added your s-o-b.

> Now off for more kernel stuff after a quick sparse excursion...

Yes, sure!
Thanks a lot because it's, I think, a really nice improvement.
-- Luc
================================================================================


################################################################################

=== Thread: [PATCH] xtensa: fix configuration of endianness ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] xtensa: fix configuration of endianness
Date: Sat, 25 Jul 2020 20:56:57 +0000
Message-ID: <20200725205657.73768-1-luc.vanoostenryck () gmail ! com>
--------------------
Since gcc 3.4.0 there is no option to specify the endianness for
the Xtensa architecture, so the kernel relies on autodetecting
the endianness and then defining the macros __XTENSA_E{B,L}__.

But this means that sparse's 'arch_big_endian' can't be used
for the predefine.

So, do not predefine these macros anymore, they will transparently
be set directly from the command line.

Reported-by: Peter Zijlstra <peterz@infradead.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 target-xtensa.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/target-xtensa.c b/target-xtensa.c
index 26bda47f02f0..3620b4a311cc 100644
--- a/target-xtensa.c
+++ b/target-xtensa.c
@@ -17,11 +17,6 @@ static void predefine_xtensa(const struct target *self)
 {
 	predefine("__XTENSA__", 1, "1");
 	predefine("__xtensa__", 1, "1");
-
-	if (arch_big_endian)
-		predefine("__XTENSA_EB__", 1, "1");
-	else
-		predefine("__XTENSA_EL__", 1, "1");
 }
 
 const struct target target_xtensa = {
-- 
2.27.0

================================================================================


################################################################################

=== Thread: [RFC] cpp: remove extra newlines during macro expansion ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC] cpp: remove extra newlines during macro expansion
Date: Thu, 12 Mar 2020 20:25:33 +0000
Message-ID: <20200312202533.52465-1-luc.vanoostenryck () gmail ! com>
--------------------
During macro expansion, Sparse doesn't strip newlines from
the arguments as required by 6.10.3p10 and done by gcc & clang.

So, remove these newlines.

Note: the current behaviour may make the preprocessed output
      more readable (and so may be considered as a feature).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 pre-process.c                           |  1 +
 validation/preprocessor/expand-and-nl.c | 14 ++++++++++++++
 2 files changed, 15 insertions(+)
 create mode 100644 validation/preprocessor/expand-and-nl.c

diff --git a/pre-process.c b/pre-process.c
index 479c8d225602..2893c3ab65d4 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -306,6 +306,7 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position
 		next->pos.stream = pos->stream;
 		next->pos.line = pos->line;
 		next->pos.pos = pos->pos;
+		next->pos.newline = 0;
 		p = &next->next;
 	}
 	*p = &eof_token_entry;
diff --git a/validation/preprocessor/expand-and-nl.c b/validation/preprocessor/expand-and-nl.c
new file mode 100644
index 000000000000..06f6ab5cd91b
--- /dev/null
+++ b/validation/preprocessor/expand-and-nl.c
@@ -0,0 +1,14 @@
+#define M(X) X-X
+
+M(a
+b)
+/*
+ * check-name: expand-and-nl
+ * check-command: sparse -E $file
+ * check-known-to-fail
+ *
+ * check-output-start
+
+a b-a b
+ * check-output-end
+ */
-- 
2.25.1

================================================================================


################################################################################

=== Thread: [SPARSE PATCH] univ-init: conditionally accept { 0 } without warnings ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [SPARSE PATCH] univ-init: conditionally accept { 0 } without warnings
Date: Mon, 18 May 2020 23:54:46 +0000
Message-ID: <20200518235446.84256-1-luc.vanoostenryck () gmail ! com>
--------------------
In standard C '{ 0 }' is valid to initialize any compound object.
OTOH, Sparse allows '{ }' for the same purpose but:
1) '{ }' is not standard
2) Sparse warns when using '0' to initialize pointers.

Some projects (git) legitimately like to be able to use the
standard '{ 0 }' without the null-pointer warnings

So, add a new warning flag (-Wno-universal-initializer) to
handle '{ 0 }' as '{ }', suppressing the warnings.

Reference: https://lore.kernel.org/git/1df91aa4-dda5-64da-6ae3-5d65e50a55c5@ramsayjones.plus.com/
Reference: https://lore.kernel.org/git/e6796c60-a870-e761-3b07-b680f934c537@ramsayjones.plus.com/
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---

Suggestions for a better name than this -W[no-]universal-initializer
are warmly welcome.

-- Luc


 lib.c                      |  2 ++
 lib.h                      |  1 +
 parse.c                    |  7 +++++++
 sparse.1                   |  8 ++++++++
 token.h                    |  7 +++++++
 validation/Wuniv-init-ko.c | 14 ++++++++++++++
 validation/Wuniv-init-ok.c | 11 +++++++++++
 7 files changed, 50 insertions(+)
 create mode 100644 validation/Wuniv-init-ko.c
 create mode 100644 validation/Wuniv-init-ok.c

diff --git a/lib.c b/lib.c
index f9ec285e8fea..9ee8d3cf6b21 100644
--- a/lib.c
+++ b/lib.c
@@ -295,6 +295,7 @@ int Wtransparent_union = 0;
 int Wtypesign = 0;
 int Wundef = 0;
 int Wuninitialized = 1;
+int Wuniversal_initializer = 1;
 int Wunknown_attribute = 0;
 int Wvla = 1;
 
@@ -782,6 +783,7 @@ static const struct flag warnings[] = {
 	{ "typesign", &Wtypesign },
 	{ "undef", &Wundef },
 	{ "uninitialized", &Wuninitialized },
+	{ "universal-initializer", &Wuniversal_initializer },
 	{ "unknown-attribute", &Wunknown_attribute },
 	{ "vla", &Wvla },
 };
diff --git a/lib.h b/lib.h
index b18295a889cb..5e6db111170a 100644
--- a/lib.h
+++ b/lib.h
@@ -184,6 +184,7 @@ extern int Wtransparent_union;
 extern int Wtypesign;
 extern int Wundef;
 extern int Wuninitialized;
+extern int Wuniversal_initializer;
 extern int Wunknown_attribute;
 extern int Wvla;
 
diff --git a/parse.c b/parse.c
index a29c67c8cf41..48494afc6f2c 100644
--- a/parse.c
+++ b/parse.c
@@ -2750,6 +2750,13 @@ static struct token *initializer_list(struct expression_list **list, struct toke
 {
 	struct expression *expr;
 
+	// '{ 0 }' is equivalent to '{ }' unless wanting all possible
+	// warnings about using '0' to initialize a null-pointer.
+	if (!Wuniversal_initializer) {
+		if (match_token_zero(token) && match_op(token->next, '}'))
+			token = token->next;
+	}
+
 	for (;;) {
 		token = single_initializer(&expr, token);
 		if (!expr)
diff --git a/sparse.1 b/sparse.1
index 574caef3acbb..50e928392573 100644
--- a/sparse.1
+++ b/sparse.1
@@ -428,6 +428,14 @@ However, this behavior can lead to subtle errors.
 
 Sparse does not issue these warnings by default.
 .
+.TP
+.B \-Wuniversal\-initializer
+Do not suppress warnings about 0 used to initialize a null-pointer
+when using '{ 0 }' as initializer.
+
+Sparse issues these warnings by default.  To turn them off, use
+\fB\-Wno\-universal\-initializer\fR.
+.
 .SH MISC OPTIONS
 .TP
 .B \-\-arch=\fIARCH\fR
diff --git a/token.h b/token.h
index 292db167e4a8..33a6eda1cc53 100644
--- a/token.h
+++ b/token.h
@@ -241,4 +241,11 @@ static inline int match_ident(struct token *token, struct ident *id)
 	return token->pos.type == TOKEN_IDENT && token->ident == id;
 }
 
+static inline int match_token_zero(struct token *token)
+{
+	if (token_type(token) != TOKEN_NUMBER)
+		return false;
+	return token->number[0] == '0' && !token->number[1];
+}
+
 #endif
diff --git a/validation/Wuniv-init-ko.c b/validation/Wuniv-init-ko.c
new file mode 100644
index 000000000000..315c211a5db6
--- /dev/null
+++ b/validation/Wuniv-init-ko.c
@@ -0,0 +1,14 @@
+struct s {
+	void *ptr;
+};
+
+
+static struct s s = { 0 };
+
+/*
+ * check-name: univ-init-ko
+ *
+ * check-error-start
+Wuniv-init-ko.c:6:23: warning: Using plain integer as NULL pointer
+ * check-error-end
+ */
diff --git a/validation/Wuniv-init-ok.c b/validation/Wuniv-init-ok.c
new file mode 100644
index 000000000000..c39647517323
--- /dev/null
+++ b/validation/Wuniv-init-ok.c
@@ -0,0 +1,11 @@
+struct s {
+	void *ptr;
+};
+
+
+static struct s s = { 0 };
+
+/*
+ * check-name: univ-init-ok
+ * check-command: sparse -Wno-universal-initializer $file
+ */
-- 
2.26.2

================================================================================

From: =?utf-8?B?xJBvw6BuIFRy4bqnbiBDw7RuZw==?= Danh  <congdanhqx () gmail ! com>
To: linux-sparse
Subject: Re: [SPARSE PATCH] univ-init: conditionally accept { 0 } without warnings
Date: Wed, 20 May 2020 00:41:51 +0000
Message-ID: <20200520004151.GB12509 () danh ! dev>
--------------------
Hi Luc,

On 2020-05-20 01:22:22+0100, Ramsay Jones <ramsay@ramsayjones.plus.com> wrote:
> > In standard C '{ 0 }' is valid to initialize any compound object.
> > OTOH, Sparse allows '{ }' for the same purpose but:
> > 1) '{ }' is not standard
> > 2) Sparse warns when using '0' to initialize pointers.
> > 
> > Some projects (git) legitimately like to be able to use the
> > standard '{ 0 }' without the null-pointer warnings
> > 
> > So, add a new warning flag (-Wno-universal-initializer) to
> > handle '{ 0 }' as '{ }', suppressing the warnings.
> 
> Hmm, I didn't think this would use a warning flag at all!
> 
> I remember the discussion (on lkml and sparse ml) in which
> there was general agreement that '{}' would be preferred
> solution (if only it was standard C!). However, I thought
> that (since some compilers don't support it e.g. msvc) the
> next best solution would be for sparse to suppress the
> warning if given the '= { 0 }' token sequence. (ie. no mention
> of it being conditional on a option).

I'm also in the camp of favouring no -W at all.
But, have another -W is fine to me.

> > Suggestions for a better name than this -W[no-]universal-initializer
> > are warmly welcome.
> 
> Heh, you know that I am no good at naming things - but this may well
> give the impression of a C++ like 'int i{}' type initializer!


================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [SPARSE PATCH] univ-init: conditionally accept { 0 } without warnings
Date: Wed, 20 May 2020 22:03:27 +0000
Message-ID: <0e81e382-5dde-6029-35d7-0de72e5a0a99 () ramsayjones ! plus ! com>
--------------------


On 20/05/2020 21:40, Luc Van Oostenryck wrote:
> On Wed, May 20, 2020 at 01:22:22AM +0100, Ramsay Jones wrote:
[snip]

>>
>> I remember the discussion (on lkml and sparse ml) in which
>> there was general agreement that '{}' would be preferred
>> solution (if only it was standard C!). However, I thought
>> that (since some compilers don't support it e.g. msvc) the
>> next best solution would be for sparse to suppress the
>> warning if given the '= { 0 }' token sequence. (ie. no mention
>> of it being conditional on a option).
> 
> Yes, I kinda agree but concerning the kernel, my understanding is
> that the warning is desired (cfr. https://marc.info/?t=154704602900003 ) 

Oh, my lord, I had no recollection of that thread - and it was
only just over a year ago! ;-P

Hmm, yes it's a shame, but I guess the kernel usage takes precedence.

> For example, for cases like:
> 	int *array[16] = { 0 };
> 
> So, I want to keep the current behavior as the default.
> 
>>> @@ -2750,6 +2750,13 @@ static struct token *initializer_list(struct expression_list **list, struct toke
>>>  {
>>>  	struct expression *expr;
>>>  
>>> +	// '{ 0 }' is equivalent to '{ }' unless wanting all possible
>>> +	// warnings about using '0' to initialize a null-pointer.
>>> +	if (!Wuniversal_initializer) {
>>> +		if (match_token_zero(token) && match_op(token->next, '}'))
>>> +			token = token->next;
>>> +	}
>>> +
>>
>> Ha! This made me LOL! (see my patch below).
>>
>> So simple. (I did think, at first, that deleting the '0' token was
>> not a good idea - then I realized that it's more like skipping/ignoring
>> the token than deleting it.)
> 
> Well ... I'm lazy, so ... and it gave me the garantee that it will
> behave exactly like '{ }'.
> 
>> The patch below was (I think) my third attempt. If memory serves
>> me, the first patch attempted to determine the '{0}' initializer
>> from the 'struct expession *' passed to bad_null() alone. However,
>> that did not allow me to distinguish '= { 0 }' from '= { 0, }',
>> so I needed to backup from evaluation to the parse.
> 
> I think it's fine to allow the comma, I probably need to change
> this is my version.

No, No, that would definitely be wrong. In fact, I would go further
and say _only_ '= { 0 } ;' should suppress the warning (yes I added
the semi-colon). (I did think that maybe other forms of 'integer
constant with value zero' could be added; e.g. 0x0, but I am not
sure even that is useful).

['designated initializers' would also not work to suppress the
warnings, of course!]

BTW, I was not entirely convinced by the git-list discussion which
lead to this patch. However, limiting the suppression of the warning
to _just_ '= { 0 } ;' would leave the majority of use-cases issuing
the warning anyway. The main benefit would be, as argued by others,
that when you switch the order/type of fields in a struct (say) that
you would not have to change the initializer from/to {0}/{NULL}.
(Again, I don't see that as a huge advantage ...)

>> Also, I didn't test the initialization of embedded struct/array fields
>> (and what should happen anyway? should '{ 0 }' also work for initializing
>> the sub-structure(s), or should it only work at the top-level?).

And so, given the above, I don't think the warnings should be suppressed
on sub-structures.

> In fact, it works for literally anything: simple arrays, multi-dimensional
> arrays (it must be because the braces doesn't need to match:
> 	int a[2][2] = { 1, 2, 3, 4 };

Heh, yes indeed.

> is perfectly legal), structures with a scalar as first member, more complex
> strutures, sub-structures, and more suprisingly even for simple types:
> 	int a = { 0 };
> 	_Bool b = { 0 };
> 	double f = { 0 };
> 	int *ptr = { 0 };

Ah, yes, I wonder if that would be a problem. ;-)
My initial reaction would be that non-aggregate types would still
issue warnings (even with ={0};), but that starts getting harder
to do ... :(

I don't have any simple answers.

ATB,
Ramsay Jones

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [SPARSE PATCH] univ-init: conditionally accept { 0 } without warnings
Date: Tue, 02 Jun 2020 16:41:58 +0000
Message-ID: <20200602164158.lovn2dsuc2g74l55 () ltop ! local>
--------------------
On Wed, May 20, 2020 at 01:22:22AM +0100, Ramsay Jones wrote:
> >  
> > diff --git a/parse.c b/parse.c
> > index a29c67c8cf41..48494afc6f2c 100644
> > --- a/parse.c
> > +++ b/parse.c
> > @@ -2750,6 +2750,13 @@ static struct token *initializer_list(struct expression_list **list, struct toke
> >  {
> >  	struct expression *expr;
> >  
> > +	// '{ 0 }' is equivalent to '{ }' unless wanting all possible
> > +	// warnings about using '0' to initialize a null-pointer.
> > +	if (!Wuniversal_initializer) {
> > +		if (match_token_zero(token) && match_op(token->next, '}'))
> > +			token = token->next;
> > +	}
> > +
> 
> Ha! This made me LOL! (see my patch below).
> 
> So simple. (I did think, at first, that deleting the '0' token was
> not a good idea - then I realized that it's more like skipping/ignoring
> the token than deleting it.)
> 
> I wish I had thought of it.

Well, it ended that it wasn't that smart after all because it
caused several regressions when used with scalars.
So, I finally had to do a sort of hybrid between your version
(for the parsing) and mine (dropping the '0' element from the list,
but now, later, at evaluation time).

-- Luc
================================================================================


################################################################################

=== Thread: [SPARSE v2 00/28] detect invalid branches ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [SPARSE v2 00/28] detect invalid branches
Date: Tue, 19 May 2020 00:57:00 +0000
Message-ID: <20200519005728.84594-1-luc.vanoostenryck () gmail ! com>
--------------------
It's not allowed to do a goto into an expression statement.
For example, it's not well defined what should happen if such
an expression is not otherwise reachable and/or can be optimized
away. For such situations GCC issues an error, clang doesn't
and produce a valid IR but Spare produce an invalid IR with
branches to unexisting BBs.

The goals of the patches in this series are:
*) to detect such gotos at evaluation time;
*) issue a sensible error message;
*) avoid the linearization of functions with invalid gotos.

The implementation principle behind these is to add a new kind
of scope (label_scope), one for the usual function scope of
labels one for each statement expressions. This new scope,
instead of being used as a real scope for the visibility of
labels, is used to mark where labels are defined and where
they're used. 

Using this label scope as a real scope controling the
visibility of labels was quite appealing and was the initial
drive for this implementation but has the problem of inner
scope shadowing earlier occurence of labels identically
named. This is of course desired for 'normal' symbols but for
labels (which are normally visible in the whole function
and which may be used before being declared/defined)
it has the disadvantage of:
*) inhibiting the detecting of misuses once an inner scope
   is closed
*) allowing several distinct labels with the same name
   in a single function (this can be regarded as a feature
   but __label__ at block scope should be used for this)
*) create diffrences about what is permssble or not between
   sparse and GCC or clang.


Changes since v1:
* move most of the checks from eveluation time to parsing time
* add warnings for unused labels based on code from Linus
* add support for label attributes 'unused'
* add to label-expressions the same kind of checks than
  those done for gotos
* use the correct position in warnings
* lots of small improvements


Luc Van Oostenryck (28):
  misc: fix testcase typeof-safe
  misc: s/fntype/rettype/
  misc: always use the node for current_fn
  bad-goto: add testcase for 'jump inside discarded expression statement'
  bad-goto: add testcases for linearization of invalid labels
  bad-goto: reorganize testcases and add some more
  bad-goto: do not linearize if the IR will be invalid
  bad-goto: reorg test in evaluate_goto_statement()
  bad-goto: simplify testing of undeclared labels
  bad-goto: do not linearize function with undeclared labels
  bad-goto: catch labels with reserved names
  scope: no memset() needed after __alloc_scope()
  scope: move scope opening/ending inside compound_statement()
  scope: extract bind_symbol_with_scope() from bind_symbol()
  scope: __func__ is special
  scope: __label__ is special
  scope: s/{start,end}_symbol_scope/{start,end}_block_scope/
  scope: make function_scope invalid outside functions
  scope: let labels have their own scope
  scope: add is_in_scope()
  scope: give a scope for labels & gotos
  bad-goto: jumping inside a statemet expression is an error
  bad-goto: label expression inside a statement expression is UB
  bad-goto: extract check_label_declaration()
  bad-goto: check declaration of label expressions
  bad-label: check for unused labels
  bad-label: mark labels as used when needed
  bad-label: respect attribute((unused))

 evaluate.c                                    | 36 ++++++--
 expand.c                                      |  2 +-
 expression.c                                  | 12 +--
 linearize.c                                   |  2 +-
 parse.c                                       | 73 +++++++++++++----
 parse.h                                       |  4 +-
 scope.c                                       | 46 +++++++++--
 scope.h                                       | 10 ++-
 symbol.c                                      | 13 ++-
 symbol.h                                      |  7 ++
 validation/__func__-scope.c                   |  8 ++
 .../{asm-goto-lables.c => asm-goto-labels.c}  |  0
 validation/label-asm.c                        |  1 +
 validation/label-attr.c                       |  2 +-
 validation/label-scope-cgoto.c                | 82 +++++++++++++++++++
 validation/label-scope.c                      |  5 +-
 validation/label-scope1.c                     | 42 ++++++++++
 validation/label-scope2.c                     | 31 +++++++
 validation/label-stmt-expr0.c                 | 38 +++++++++
 validation/label-stmt-expr1.c                 | 28 +++++++
 validation/label-stmt-expr2.c                 | 46 +++++++++++
 validation/label-unused.c                     | 29 +++++++
 validation/linear/goto-invalid.c              | 18 ++++
 .../linear/goto-stmt-expr-conditional.c       | 27 ++++++
 .../linear/goto-stmt-expr-short-circuit.c     | 31 +++++++
 validation/linear/label-scope-cgoto.c         | 10 +++
 .../label-stmt-dropped.c}                     |  4 +-
 .../label-stmt-expr0.c}                       |  4 +-
 ...reachable-label0.c => label-unreachable.c} |  3 +-
 validation/typeof-safe.c                      | 26 ++++--
 30 files changed, 576 insertions(+), 64 deletions(-)
 create mode 100644 validation/__func__-scope.c
 rename validation/{asm-goto-lables.c => asm-goto-labels.c} (100%)
 create mode 100644 validation/label-scope-cgoto.c
 create mode 100644 validation/label-scope1.c
 create mode 100644 validation/label-scope2.c
 create mode 100644 validation/label-stmt-expr0.c
 create mode 100644 validation/label-stmt-expr1.c
 create mode 100644 validation/label-stmt-expr2.c
 create mode 100644 validation/label-unused.c
 create mode 100644 validation/linear/goto-invalid.c
 create mode 100644 validation/linear/goto-stmt-expr-conditional.c
 create mode 100644 validation/linear/goto-stmt-expr-short-circuit.c
 create mode 100644 validation/linear/label-scope-cgoto.c
 rename validation/{discarded-label-statement.c => linear/label-stmt-dropped.c} (84%)
 rename validation/{label-expr.c => linear/label-stmt-expr0.c} (75%)
 rename validation/linear/{unreachable-label0.c => label-unreachable.c} (80%)


base-commit: 146e6a63e715e0c3e08aacbcaa79ff8930289297
-- 
2.26.2

================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [SPARSE v2 00/28] detect invalid branches
Date: Tue, 19 May 2020 01:41:07 +0000
Message-ID: <CAHk-=wiaZgBKwC2-ku3UeV4Rdv=tPcKLAfjy96PbJSntcLBWHw () mail ! gmail ! com>
--------------------
On Mon, May 18, 2020 at 5:57 PM Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> The goals of the patches in this series are:
> *) to detect such gotos at evaluation time;
> *) issue a sensible error message;
> *) avoid the linearization of functions with invalid gotos.

Ack. Apart from that one question I had, which I didn't actually
verify whether it was a problem for the insane test-case I posted.

I only _read_ the patches, I didn't actually apply and test them in any way.

               Linus
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [SPARSE v2 00/28] detect invalid branches
Date: Tue, 19 May 2020 21:16:37 +0000
Message-ID: <20200519211637.4hjorseu675acihh () ltop ! local>
--------------------
On Mon, May 18, 2020 at 06:41:07PM -0700, Linus Torvalds wrote:
> On Mon, May 18, 2020 at 5:57 PM Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > The goals of the patches in this series are:
> > *) to detect such gotos at evaluation time;
> > *) issue a sensible error message;
> > *) avoid the linearization of functions with invalid gotos.
> 
> Ack. Apart from that one question I had, which I didn't actually
> verify whether it was a problem for the insane test-case I posted.
> 
> I only _read_ the patches, I didn't actually apply and test them in any way.

Sure, I understand that very well. I tend to give to this kind of
series a decent amount of testing and its mostly fully automatic
anyway (and, I think, the tests cover well most situations),
but having another eye and another opinion on the patches is very
much appreciated.

-- Luc
================================================================================


################################################################################

=== Thread: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault      sparse -D__linux__ -Dlinu ===

From: kbuild test robot <lkp () intel ! com>
To: linux-kernel
Subject: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault      sparse -D__linux__ -Dlinu
Date: Wed, 27 May 2020 23:39:31 +0000
Message-ID: <202005280727.lXn1VnTw%lkp () intel ! com>
--------------------

--J2SCkAp4GZ/dPZZf
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

tree:   https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git locking=
/kcsan
head:   a5dead405f6be1fb80555bdcb77c406bf133fdc8
commit: a5dead405f6be1fb80555bdcb77c406bf133fdc8 [12/12] compiler_types.h: =
Optimize __unqual_scalar_typeof compilation time
config: i386-randconfig-s002-20200527 (attached as .config)
compiler: gcc-9 (Debian 9.3.0-13) 9.3.0
reproduce:
        # apt-get install sparse
        # sparse version: v0.6.1-240-gf0fe1cd9-dirty
        git checkout a5dead405f6be1fb80555bdcb77c406bf133fdc8
        # save the attached .config to linux build tree
        make W=3D1 C=3D1 ARCH=3Di386 CF=3D'-fdiagnostic-prefix -D__CHECK_EN=
DIAN__'

If you fix the issue, kindly add following tag as appropriate
Reported-by: kbuild test robot <lkp@intel.com>

All errors (new ones prefixed by >>, old ones prefixed by <<):

include/linux/compiler.h:256:16: sparse: sparse: got :
include/linux/list.h:282:16: sparse: sparse: typename in expression
include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
include/linux/list.h:282:16: sparse: sparse: got :
include/linux/list.h:794:17: sparse: sparse: typename in expression
include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
include/linux/list.h:794:17: sparse: sparse: got :
include/linux/list.h:803:17: sparse: sparse: typename in expression
include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
include/linux/list.h:803:17: sparse: sparse: got :
arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in expression
arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in function=
 call
arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in exp=
ression
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) in f=
unction call
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) in e=
xpression
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in exp=
ression
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) in f=
unction call
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to use r=
eserved word 'do' as identifier
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; at e=
nd of declaration
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) in f=
unction declarator
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to use r=
eserved word 'if' as identifier
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) in f=
unction declarator
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to use r=
eserved word 'typeof' as identifier
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at th=
e end of type declaration
include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in fu=
nction declarator
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use re=
served word 'if' as identifier
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at th=
e end of type declaration
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use re=
served word 'do' as identifier
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at en=
d of declaration
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in fu=
nction declarator
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use re=
served word 'if' as identifier
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at th=
e end of type declaration
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use re=
served word 'do' as identifier
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at en=
d of declaration
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at th=
e end of type declaration
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at th=
e end of type declaration
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at th=
e end of type declaration
include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at th=
e end of type declaration
include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; at t=
he end of type declaration
include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many errors
>> /bin/bash: line 1: 61526 Segmentation fault      sparse -D__linux__ -Dli=
nux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -Wno-unknown-at=
tribute -fdiagnostic-prefix -D__CHECK_ENDIAN__ -D__i386__ --arch=3Di386 -ml=
ittle-endian -m32 -Wp,-MD,arch/x86/kernel/.dumpstack.o.d -nostdinc -isystem=
 /usr/lib/gcc/x86_64-linux-gnu/9/include -Iarch/x86/include -I./arch/x86/in=
clude/generated -Iinclude -I./include -Iarch/x86/include/uapi -I./arch/x86/=
include/generated/uapi -Iinclude/uapi -I./include/generated/uapi -include i=
nclude/linux/kconfig.h -include include/linux/compiler_types.h -D__KERNEL__=
 -DKBUILD_EXTRA_WARN1 -Wall -Wundef -Werror=3Dstrict-prototypes -Wno-trigra=
phs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=3Dimpli=
cit-function-declaration -Werror=3Dimplicit-int -Wno-format-security -std=
=3Dgnu89 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -m32 -msoft-float =
-mregparm=3D3 -freg-struct-return -fno-pic -mpreferred-stack-boundary=3D2 -=
march=3Di686 -mtune=3Dpentium2 -Wa,-mtune=3Dgeneric32 -ffreestanding -Wno-s=
ign-compare -fno-asynchronous-unwind-tables -mindirect-branch=3Dthunk-exter=
n -mindirect-branch-register -fno-jump-tables -fno-delete-null-pointer-chec=
ks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-addr=
ess-of-packed-member -O2 -Wno-maybe-uninitialized --param=3Dallow-store-dat=
a-races=3D0 -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining -Wf=
rame-larger-than=3D8192 -fno-stack-protector -Wno-unused-but-set-variable -=
Wimplicit-fallthrough -Wno-unused-const-variable -fno-var-tracking-assignme=
nts -g -femit-struct-debug-baseonly -fno-var-tracking -pg -mrecord-mcount -=
mfentry -DCC_USING_FENTRY -fno-inline-functions-called-once -Wdeclaration-a=
fter-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -fno-strict=
-overflow -fno-merge-all-constants -fmerge-constants -fno-stack-check -fcon=
serve-stack -Werror=3Ddate-time -Werror=3Dincompatible-pointer-types -Werro=
r=3Ddesignated-init -fmacro-prefix-map=3D=3D -fcf-protection=3Dnone -Wno-pa=
cked-not-aligned -Wextra -Wunused -Wno-unused-parameter -Wmissing-declarati=
ons -Wmissing-format-attribute -Wmissing-prototypes -Wold-style-definition =
-Wmissing-include-dirs -Wunused-but-set-variable -Wunused-const-variable -W=
packed-not-aligned -Wstringop-truncation -Wno-missing-field-initializers -W=
no-sign-compare -I arch/x86/kernel -I ./arch/x86/kernel -DKBUILD_MODFILE=3D=
'"arch/x86/kernel/dumpstack"' -DKBUILD_BASENAME=3D'"dumpstack"' -DKBUILD_MO=
DNAME=3D'"dumpstack"' arch/x86/kernel/dumpstack.c

sparse warnings: (new ones prefixed by >>)

   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
>> include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many err=
ors
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:689:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:689:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:698:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:698:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:1090:9: sparse: sparse: Trying to u=
se reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:1090:12: sparse: sparse: Expected ;=
 at end of declaration
   include/linux/atomic-arch-fallback.h:1090:12: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:1093:9: sparse: sparse: Expected ; =
at the end of type declaration
   include/linux/atomic-arch-fallback.h:1093:9: sparse: sparse: too many er=
rors
--
   /usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h:406:9: sparse: sparse: =
preprocessor token offsetof redefined
   include/linux/stddef.h:17:9: sparse: this was the original definition
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
>> include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many err=
ors
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
>> include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many err=
ors
   drivers/net/ethernet/intel/e1000/e1000_main.c:3442:29: sparse: sparse: r=
edefinition of struct my_u
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
   include/linux/list_nulls.h:83:17: sparse: sparse: typename in expression
   include/linux/list_nulls.h:83:17: sparse: sparse: Expected ) in function=
 call
   include/linux/list_nulls.h:83:17: sparse: sparse: got :
   include/linux/list_nulls.h:88:27: sparse: sparse: typename in expression
   include/linux/list_nulls.h:88:27: sparse: sparse: Expected ) in function=
 call
   include/linux/list_nulls.h:88:27: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: too many err=
ors
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
>> include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many err=
ors
   /bin/bash: line 1: 61526 Segmentation fault      sparse -D__linux__ -Dli=
nux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -Wno-unknown-at=
tribute -fdiagnostic-prefix -D__CHECK_ENDIAN__ -D__i386__ --arch=3Di386 -ml=
ittle-endian -m32 -Wp,-MD,arch/x86/kernel/.dumpstack.o.d -nostdinc -isystem=
 /usr/lib/gcc/x86_64-linux-gnu/9/include -Iarch/x86/include -I./arch/x86/in=
clude/generated -Iinclude -I./include -Iarch/x86/include/uapi -I./arch/x86/=
include/generated/uapi -Iinclude/uapi -I./include/generated/uapi -include i=
nclude/linux/kconfig.h -include include/linux/compiler_types.h -D__KERNEL__=
 -DKBUILD_EXTRA_WARN1 -Wall -Wundef -Werror=3Dstrict-prototypes -Wno-trigra=
phs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=3Dimpli=
cit-function-declaration -Werror=3Dimplicit-int -Wno-format-security -std=
=3Dgnu89 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -m32 -msoft-float =
-mregparm=3D3 -freg-struct-return -fno-pic -mpreferred-stack-boundary=3D2 -=
march=3Di686 -mtune=3Dpentium2 -Wa,-mtune=3Dgeneric32 -ffreestanding -Wno-s=
ign-compare -fno-asynchronous-unwind-tables -mindirect-branch=3Dthunk-exter=
n -mindirect-branch-register -fno-jump-tables -fno-delete-null-pointer-chec=
ks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-addr=
ess-of-packed-member -O2 -Wno-maybe-uninitialized --param=3Dallow-store-dat=
a-races=3D0 -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining -Wf=
rame-larger-than=3D8192 -fno-stack-protector -Wno-unused-but-set-variable -=
Wimplicit-fallthrough -Wno-unused-const-variable -fno-var-tracking-assignme=
nts -g -femit-struct-debug-baseonly -fno-var-tracking -pg -mrecord-mcount -=
mfentry -DCC_USING_FENTRY -fno-inline-functions-called-once -Wdeclaration-a=
fter-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -fno-strict=
-overflow -fno-merge-all-constants -fmerge-constants -fno-stack-check -fcon=
serve-stack -Werror=3Ddate-time -Werror=3Dincompatible-pointer-types -Werro=
r=3Ddesignated-init -fmacro-prefix-map=3D=3D -fcf-protection=3Dnone -Wno-pa=
cked-not-aligned -Wextra -Wunused -Wno-unused-parameter -Wmissing-declarati=
ons -Wmissing-format-attribute -Wmissing-prototypes -Wold-style-definition =
-Wmissing-include-dirs -Wunused-but-set-variable -Wunused-const-variable -W=
packed-not-aligned -Wstringop-truncation -Wno-missing-field-initializers -W=
no-sign-compare -I arch/x86/kernel -I ./arch/x86/kernel -DKBUILD_MODFILE=3D=
'"arch/x86/kernel/dumpstack"' -DKBUILD_BASENAME=3D'"dumpstack"' -DKBUILD_MO=
DNAME=3D'"dumpstack"' arch/x86/kernel/dumpstack.c
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
>> include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many err=
ors
   /bin/bash: line 1: 68245 Segmentation fault      sparse -D__linux__ -Dli=
nux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -Wno-unknown-at=
tribute -fdiagnostic-prefix -D__CHECK_ENDIAN__ -D__i386__ --arch=3Di386 -ml=
ittle-endian -m32 -Wp,-MD,arch/x86/kernel/.process.o.d -nostdinc -isystem /=
usr/lib/gcc/x86_64-linux-gnu/9/include -Iarch/x86/include -I./arch/x86/incl=
ude/generated -Iinclude -I./include -Iarch/x86/include/uapi -I./arch/x86/in=
clude/generated/uapi -Iinclude/uapi -I./include/generated/uapi -include inc=
lude/linux/kconfig.h -include include/linux/compiler_types.h -D__KERNEL__ -=
DKBUILD_EXTRA_WARN1 -Wall -Wundef -Werror=3Dstrict-prototypes -Wno-trigraph=
s -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=3Dimplici=
t-function-declaration -Werror=3Dimplicit-int -Wno-format-security -std=3Dg=
nu89 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -m32 -msoft-float -mre=
gparm=3D3 -freg-struct-return -fno-pic -mpreferred-stack-boundary=3D2 -marc=
h=3Di686 -mtune=3Dpentium2 -Wa,-mtune=3Dgeneric32 -ffreestanding -Wno-sign-=
compare -fno-asynchronous-unwind-tables -mindirect-branch=3Dthunk-extern -m=
indirect-branch-register -fno-jump-tables -fno-delete-null-pointer-checks -=
Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-=
of-packed-member -O2 -Wno-maybe-uninitialized --param=3Dallow-store-data-ra=
ces=3D0 -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining -Wframe=
-larger-than=3D8192 -fno-stack-protector -Wno-unused-but-set-variable -Wimp=
licit-fallthrough -Wno-unused-const-variable -fno-var-tracking-assignments =
-g -femit-struct-debug-baseonly -fno-var-tracking -pg -mrecord-mcount -mfen=
try -DCC_USING_FENTRY -fno-inline-functions-called-once -Wdeclaration-after=
-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -fno-strict-ove=
rflow -fno-merge-all-constants -fmerge-constants -fno-stack-check -fconserv=
e-stack -Werror=3Ddate-time -Werror=3Dincompatible-pointer-types -Werror=3D=
designated-init -fmacro-prefix-map=3D=3D -fcf-protection=3Dnone -Wno-packed=
-not-aligned -Wextra -Wunused -Wno-unused-parameter -Wmissing-declarations =
-Wmissing-format-attribute -Wmissing-prototypes -Wold-style-definition -Wmi=
ssing-include-dirs -Wunused-but-set-variable -Wunused-const-variable -Wpack=
ed-not-aligned -Wstringop-truncation -Wno-missing-field-initializers -Wno-s=
ign-compare -I arch/x86/kernel -I ./arch/x86/kernel -DKBUILD_MODFILE=3D'"ar=
ch/x86/kernel/process"' -DKBUILD_BASENAME=3D'"process"' -DKBUILD_MODNAME=3D=
'"process"' arch/x86/kernel/process.c
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
>> include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many err=
ors
   /bin/bash: line 1: 80534 Segmentation fault      sparse -D__linux__ -Dli=
nux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -Wno-unknown-at=
tribute -fdiagnostic-prefix -D__CHECK_ENDIAN__ -D__i386__ --arch=3Di386 -ml=
ittle-endian -m32 -Wp,-MD,arch/x86/kernel/.unwind_guess.o.d -nostdinc -isys=
tem /usr/lib/gcc/x86_64-linux-gnu/9/include -Iarch/x86/include -I./arch/x86=
/include/generated -Iinclude -I./include -Iarch/x86/include/uapi -I./arch/x=
86/include/generated/uapi -Iinclude/uapi -I./include/generated/uapi -includ=
e include/linux/kconfig.h -include include/linux/compiler_types.h -D__KERNE=
L__ -DKBUILD_EXTRA_WARN1 -Wall -Wundef -Werror=3Dstrict-prototypes -Wno-tri=
graphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=3Dim=
plicit-function-declaration -Werror=3Dimplicit-int -Wno-format-security -st=
d=3Dgnu89 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -m32 -msoft-float=
 -mregparm=3D3 -freg-struct-return -fno-pic -mpreferred-stack-boundary=3D2 =
-march=3Di686 -mtune=3Dpentium2 -Wa,-mtune=3Dgeneric32 -ffreestanding -Wno-=
sign-compare -fno-asynchronous-unwind-tables -mindirect-branch=3Dthunk-exte=
rn -mindirect-branch-register -fno-jump-tables -fno-delete-null-pointer-che=
cks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-add=
ress-of-packed-member -O2 -Wno-maybe-uninitialized --param=3Dallow-store-da=
ta-races=3D0 -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining -W=
frame-larger-than=3D8192 -fno-stack-protector -Wno-unused-but-set-variable =
-Wimplicit-fallthrough -Wno-unused-const-variable -fno-var-tracking-assignm=
ents -g -femit-struct-debug-baseonly -fno-var-tracking -pg -mrecord-mcount =
-mfentry -DCC_USING_FENTRY -fno-inline-functions-called-once -Wdeclaration-=
after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -fno-stric=
t-overflow -fno-merge-all-constants -fmerge-constants -fno-stack-check -fco=
nserve-stack -Werror=3Ddate-time -Werror=3Dincompatible-pointer-types -Werr=
or=3Ddesignated-init -fmacro-prefix-map=3D=3D -fcf-protection=3Dnone -Wno-p=
acked-not-aligned -Wextra -Wunused -Wno-unused-parameter -Wmissing-declarat=
ions -Wmissing-format-attribute -Wmissing-prototypes -Wold-style-definition=
 -Wmissing-include-dirs -Wunused-but-set-variable -Wunused-const-variable -=
Wpacked-not-aligned -Wstringop-truncation -Wno-missing-field-initializers -=
Wno-sign-compare -I arch/x86/kernel -I ./arch/x86/kernel -DKBUILD_MODFILE=
=3D'"arch/x86/kernel/unwind_guess"' -DKBUILD_BASENAME=3D'"unwind_guess"' -D=
KBUILD_MODNAME=3D'"unwind_guess"' arch/x86/kernel/unwind_guess.c
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:655:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:671:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: Expected ; a=
t the end of type declaration
>> include/linux/atomic-arch-fallback.h:680:1: sparse: sparse: too many err=
ors
   /bin/bash: line 1: 64064 Segmentation fault      sparse -D__linux__ -Dli=
nux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -Wno-unknown-at=
tribute -fdiagnostic-prefix -D__CHECK_ENDIAN__ -D__i386__ --arch=3Di386 -ml=
ittle-endian -m32 -Wp,-MD,kernel/trace/.trace_stack.o.d -nostdinc -isystem =
/usr/lib/gcc/x86_64-linux-gnu/9/include -Iarch/x86/include -I./arch/x86/inc=
lude/generated -Iinclude -I./include -Iarch/x86/include/uapi -I./arch/x86/i=
nclude/generated/uapi -Iinclude/uapi -I./include/generated/uapi -include in=
clude/linux/kconfig.h -include include/linux/compiler_types.h -D__KERNEL__ =
-DKBUILD_EXTRA_WARN1 -Wall -Wundef -Werror=3Dstrict-prototypes -Wno-trigrap=
hs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=3Dimplic=
it-function-declaration -Werror=3Dimplicit-int -Wno-format-security -std=3D=
gnu89 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -m32 -msoft-float -mr=
egparm=3D3 -freg-struct-return -fno-pic -mpreferred-stack-boundary=3D2 -mar=
ch=3Di686 -mtune=3Dpentium2 -Wa,-mtune=3Dgeneric32 -ffreestanding -Wno-sign=
-compare -fno-asynchronous-unwind-tables -mindirect-branch=3Dthunk-extern -=
mindirect-branch-register -fno-jump-tables -fno-delete-null-pointer-checks =
-Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address=
-of-packed-member -O2 -Wno-maybe-uninitialized --param=3Dallow-store-data-r=
aces=3D0 -fno-reorder-blocks -fno-ipa-cp-clone -fno-partial-inlining -Wfram=
e-larger-than=3D8192 -fno-stack-protector -Wno-unused-but-set-variable -Wim=
plicit-fallthrough -Wno-unused-const-variable -fno-var-tracking-assignments=
 -g -femit-struct-debug-baseonly -fno-var-tracking -DCC_USING_FENTRY -fno-i=
nline-functions-called-once -Wdeclaration-after-statement -Wvla -Wno-pointe=
r-sign -Wno-stringop-truncation -fno-strict-overflow -fno-merge-all-constan=
ts -fmerge-constants -fno-stack-check -fconserve-stack -Werror=3Ddate-time =
-Werror=3Dincompatible-pointer-types -Werror=3Ddesignated-init -fmacro-pref=
ix-map=3D=3D -fcf-protection=3Dnone -Wno-packed-not-aligned -Wextra -Wunuse=
d -Wno-unused-parameter -Wmissing-declarations -Wmissing-format-attribute -=
Wmissing-prototypes -Wold-style-definition -Wmissing-include-dirs -Wunused-=
but-set-variable -Wunused-const-variable -Wpacked-not-aligned -Wstringop-tr=
uncation -Wno-missing-field-initializers -Wno-sign-compare -I kernel/trace =
-I ./kernel/trace -DKBUILD_MODFILE=3D'"kernel/trace/trace_stack"' -DKBUILD_=
BASENAME=3D'"trace_stack"' -DKBUILD_MODNAME=3D'"trace_stack"' kernel/trace/=
trace_stack.c
--
   include/linux/compiler.h:256:16: sparse: sparse: typename in expression
   include/linux/compiler.h:256:16: sparse: sparse: Expected ) in function =
call
   include/linux/compiler.h:256:16: sparse: sparse: got :
   include/linux/list_nulls.h:83:17: sparse: sparse: typename in expression
   include/linux/list_nulls.h:83:17: sparse: sparse: Expected ) in function=
 call
   include/linux/list_nulls.h:83:17: sparse: sparse: got :
   include/linux/list_nulls.h:88:27: sparse: sparse: typename in expression
   include/linux/list_nulls.h:88:27: sparse: sparse: Expected ) in function=
 call
   include/linux/list_nulls.h:88:27: sparse: sparse: got :
   include/linux/list.h:282:16: sparse: sparse: typename in expression
   include/linux/list.h:282:16: sparse: sparse: Expected ) in function call
   include/linux/list.h:282:16: sparse: sparse: got :
   include/linux/list.h:794:17: sparse: sparse: typename in expression
   include/linux/list.h:794:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:794:17: sparse: sparse: got :
   include/linux/list.h:803:17: sparse: sparse: typename in expression
   include/linux/list.h:803:17: sparse: sparse: Expected ) in function call
   include/linux/list.h:803:17: sparse: sparse: got :
>> arch/x86/include/asm/atomic.h:31:16: sparse: sparse: typename in express=
ion
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: Expected ) in funct=
ion call
   arch/x86/include/asm/atomic.h:31:16: sparse: sparse: got :
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got while
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: typename in =
expression
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function call
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got :
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got )
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t end of declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got !
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ) i=
n function declarator
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got *
>> include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Trying to us=
e reserved word 'typeof' as identifier
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:84:16: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:85:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ) in=
 function declarator
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got !
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'if' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Trying to use=
 reserved word 'do' as identifier
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 end of declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got {
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:93:9: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: Expected ; at=
 the end of type declaration
   include/linux/atomic-arch-fallback.h:94:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:287:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:296:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:305:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:314:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:368:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:377:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:386:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:395:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:458:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:467:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:476:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:485:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:539:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:548:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:557:1: sparse: sparse: got }
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: Expected ; a=
t the end of type declaration
   include/linux/atomic-arch-fallback.h:566:1: sparse: sparse: too many err=
ors

---
0-DAY CI Kernel Test Service, Intel Corporation
https://lists.01.org/hyperkitty/list/kbuild-all@lists.01.org

--J2SCkAp4GZ/dPZZf
Content-Type: application/gzip
Content-Disposition: attachment; filename=".config.gz"
Content-Transfer-Encoding: base64

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
aOOR8+4i0KN30xJi3XrdcV3oNgbajvr2+Pb599WN22JmmSRpUJ+73aqkB+3nvaQr4fAp6vzM
rYcjQV4VBcio7ycvy/1Da1EXLQUW9t83C9gPb7rA++Z7pheC1bsLmKke7KQoWb+bNr38rYlN
+PvrTmOLyEWQ8nfXimLD35qaU5rX71+Kp3evEXn7835qER7tFpuWxLnX1lZuPZCk5dHyMEFR
/50BK5hFpaFI37/k5R1QZYmVQBQoD++4FJiorVIfQXot378g5Avbu6nv27/DgFfk6yXxu4/E
gTxluUWGpohjgwHbaYV+vr461yR0ghq99v8OsbjnfX8BM4fAGvXyHF6lNuyH12jPvhHBc/TL
Xrtp0x7RuGVIAXVZig5Z/f++4wLvgLf3DROXnxvjhkvOosDYFCKpTy1Ilvo61m5o5agprdTd
iufb1cZl3ZZXUV2PWn7djebF/Z5RtYleKy6VY9vIwJQBTVZP+po6mYAZ5Dnry/NEYjtkVZq2
pQ81SbO8ADYIRomW0I01OkPF0ArfkLY12hU9RKNbFfnH7y+PFqdcSdCw6woWhPiz1RxWksAK
Wb5lzyaVK3tw2KT/s13bpvR2pINwatuRilCibcetZTva6p62o6VmfbNt6c1m7fi8W6wkw4aj
ms/qrX07bd+xnxSa9Jxt6U2tkSHPvE1V1ZaLd43KInNqNPjl0mr0Nm3xjs+0iGEaDW9WK1pl
HNsbnGPZ4spO3a5v1a1tr+oUC/60/TsMSiUu69ay3dd2M3nmbse7uiSNvz+9vYsXAKnIYXbo
jw3bn3MzrtvUn1t1UqepfBm0bcJJb12jGx8XD326p5jjSFavHz2mHqsIQoYEir/7ZH/EW+yY
FGMlxWgGIayG5LNskQSaEZuNzurSYi1hZhdV6Zc9sGGxXcO+R7ZoGPg0llSDoHJRZnms1TNw
tRjK0vIOhMjc9pKEyH3jbSNKyjH1WPy9Es5RoC+KE58AZIqFhQCkrZIXhKtvhXLhmb/77FjA
mimrqjbSpw74C3zdwM3o53XphosWUpwZL/QIIkqIKiPHcz+q9DO0P14soqVCU1xIyVZuf9Xq
R7AD0/4xz2PthxrWoWWqVzc69bC6zlMdnLe1Hva2qmmLvSQxzBkBgM6EFiGu8wJq8lm9nye6
PlXay8cWpIualQuAlrTZQJUnWkfM0jTFAQ5IlUVssJOwlhA89+MfT388PX//16+Db4zh/TjQ
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

--J2SCkAp4GZ/dPZZf--
================================================================================


################################################################################

=== Thread: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault  sparse ... ===

From: Borislav Petkov <bp () suse ! de>
To: linux-kernel
Subject: Re: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault  sparse ...
Date: Wed, 27 May 2020 23:54:42 +0000
Message-ID: <20200527235442.GC1805 () zn ! tnic>
--------------------
On Thu, May 28, 2020 at 07:39:31AM +0800, kbuild test robot wrote:
> tree:   https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git locking/kcsan
> head:   a5dead405f6be1fb80555bdcb77c406bf133fdc8
> commit: a5dead405f6be1fb80555bdcb77c406bf133fdc8 [12/12] compiler_types.h: Optimize __unqual_scalar_typeof compilation time
> config: i386-randconfig-s002-20200527 (attached as .config)
> compiler: gcc-9 (Debian 9.3.0-13) 9.3.0
> reproduce:
>         # apt-get install sparse
>         # sparse version: v0.6.1-240-gf0fe1cd9-dirty
>         git checkout a5dead405f6be1fb80555bdcb77c406bf133fdc8
>         # save the attached .config to linux build tree
>         make W=1 C=1 ARCH=i386 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__'
> 
> If you fix the issue, kindly add following tag as appropriate
> Reported-by: kbuild test robot <lkp@intel.com>
> 
> All errors (new ones prefixed by >>, old ones prefixed by <<):

I'll say.

Looking at the subject, that broke the 0day bot too. :-)

/me trims it.

Looks like we need __CHECKER__ ifdeffery somewhere but it is too late
for me to think straight so tomorrow...

-- 
Regards/Gruss,
    Boris.

SUSE Software Solutions Germany GmbH, GF: Felix ImendÃ¶rffer, HRB 36809, AG NÃ¼rnberg
================================================================================

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-kernel
Subject: Re: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault  sparse ...
Date: Thu, 28 May 2020 07:55:53 +0000
Message-ID: <20200528075553.GC706478 () hirez ! programming ! kicks-ass ! net>
--------------------
On Thu, May 28, 2020 at 01:54:42AM +0200, Borislav Petkov wrote:
> On Thu, May 28, 2020 at 07:39:31AM +0800, kbuild test robot wrote:
> > tree:   https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git locking/kcsan
> > head:   a5dead405f6be1fb80555bdcb77c406bf133fdc8
> > commit: a5dead405f6be1fb80555bdcb77c406bf133fdc8 [12/12] compiler_types.h: Optimize __unqual_scalar_typeof compilation time
> > config: i386-randconfig-s002-20200527 (attached as .config)
> > compiler: gcc-9 (Debian 9.3.0-13) 9.3.0
> > reproduce:
> >         # apt-get install sparse
> >         # sparse version: v0.6.1-240-gf0fe1cd9-dirty
> >         git checkout a5dead405f6be1fb80555bdcb77c406bf133fdc8
> >         # save the attached .config to linux build tree
> >         make W=1 C=1 ARCH=i386 CF='-fdiagnostic-prefix -D__CHECK_ENDIAN__'
> > 
> > If you fix the issue, kindly add following tag as appropriate
> > Reported-by: kbuild test robot <lkp@intel.com>
> > 
> > All errors (new ones prefixed by >>, old ones prefixed by <<):
> 
> I'll say.
> 
> Looking at the subject, that broke the 0day bot too. :-)
> 
> /me trims it.
> 
> Looks like we need __CHECKER__ ifdeffery somewhere but it is too late
> for me to think straight so tomorrow...

I think the problem is that sparse can't parse the C11 _Generic thing.
Someone needs to teach it new tricks.
================================================================================

From: Marco Elver <elver () google ! com>
To: linux-kernel
Subject: Re: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault  sparse ...
Date: Thu, 28 May 2020 07:59:00 +0000
Message-ID: <20200528075900.GA236442 () google ! com>
--------------------
On Thu, 28 May 2020, Borislav Petkov wrote:

> On Thu, May 28, 2020 at 07:39:31AM +0800, kbuild test robot wrote:
> > tree:   https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git loc=
king/kcsan
> > head:   a5dead405f6be1fb80555bdcb77c406bf133fdc8
> > commit: a5dead405f6be1fb80555bdcb77c406bf133fdc8 [12/12] compiler_types=
=2Eh: Optimize __unqual_scalar_typeof compilation time
> > config: i386-randconfig-s002-20200527 (attached as .config)
> > compiler: gcc-9 (Debian 9.3.0-13) 9.3.0
> > reproduce:
> >         # apt-get install sparse
> >         # sparse version: v0.6.1-240-gf0fe1cd9-dirty
> >         git checkout a5dead405f6be1fb80555bdcb77c406bf133fdc8
> >         # save the attached .config to linux build tree
> >         make W=3D1 C=3D1 ARCH=3Di386 CF=3D'-fdiagnostic-prefix -D__CHEC=
K_ENDIAN__'
> >=20
> > If you fix the issue, kindly add following tag as appropriate
> > Reported-by: kbuild test robot <lkp@intel.com>
> >=20
> > All errors (new ones prefixed by >>, old ones prefixed by <<):
>=20
> I'll say.
>=20
> Looking at the subject, that broke the 0day bot too. :-)
>=20
> /me trims it.
>=20
> Looks like we need __CHECKER__ ifdeffery somewhere but it is too late
> for me to think straight so tomorrow...

Ouch. The below should be all we need, assuming it's the best we can do
for sparse right now.

Thanks,
-- Marco

------ >8 ------

=46rom: Marco Elver <elver@google.com>
Date: Thu, 28 May 2020 09:43:13 +0200
Subject: [PATCH] compiler_types.h: Use unoptimized __unqual_scalar_typeof f=
or
 sparse

If the file is being checked with sparse, use the unoptimized version of
__unqual_scalar_typeof(), since sparse does not support _Generic.

Reported-by: kbuild test robot <lkp@intel.com>
Signed-off-by: Marco Elver <elver@google.com>
---
 include/linux/compiler_types.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index a529fa263906..c1ee20812a8c 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -246,7 +246,7 @@ struct ftrace_likely_data {
  * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving
  *			       non-scalar types unchanged.
  */
-#if defined(CONFIG_CC_IS_GCC) && CONFIG_GCC_VERSION < 40900
+#if (defined(CONFIG_CC_IS_GCC) && CONFIG_GCC_VERSION < 40900) || defined(_=
_CHECKER__)
 /*
  * We build this out of a couple of helper macros in a vain attempt to
  * help you keep your lunch down while reading it.
--=20
2.27.0.rc0.183.gde8f92d652-goog

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-kernel
Subject: Re: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault  sparse ...
Date: Thu, 28 May 2020 15:22:18 +0000
Message-ID: <20200528152218.npq53zode7hh7qh4 () ltop ! local>
--------------------
On Thu, May 28, 2020 at 09:59:00AM +0200, Marco Elver wrote:
> 
> Ouch. The below should be all we need, assuming it's the best we can do
> for sparse right now.

Upstream sparse should be OK with it now.

-- Luc 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault  sparse ...
Date: Thu, 28 May 2020 15:22:18 +0000
Message-ID: <20200528152218.npq53zode7hh7qh4 () ltop ! local>
--------------------
On Thu, May 28, 2020 at 09:59:00AM +0200, Marco Elver wrote:
> 
> Ouch. The below should be all we need, assuming it's the best we can do
> for sparse right now.

Upstream sparse should be OK with it now.

-- Luc 
================================================================================


################################################################################

=== Thread: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault sparse ... ===

From: Marco Elver <elver () google ! com>
To: linux-sparse
Subject: Re: [tip:locking/kcsan 12/12] /bin/bash: line 1: 61526 Segmentation fault sparse ...
Date: Thu, 28 May 2020 15:30:44 +0000
Message-ID: <CANpmjNPOu2rduGN-jbpMi77vsfz2J5q-EPfkvHqr48K9DEcmSQ () mail ! gmail ! com>
--------------------
On Thu, 28 May 2020 at 17:22, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> On Thu, May 28, 2020 at 09:59:00AM +0200, Marco Elver wrote:
> >
> > Ouch. The below should be all we need, assuming it's the best we can do
> > for sparse right now.
>
> Upstream sparse should be OK with it now.

Very good, thank you! For 5.8 we probably still want the ifdef
__CHECKER__, otherwise we might break too many existing workflows. But
hopefully we can remove it again at some point. At the latest when the
kernel deprecates GCC 4.8 support, because then we can just remove the
whole unoptimized __unqual_scalar_typeof() definition.

Thanks,
-- Marco
================================================================================


################################################################################

=== Thread: contact Dhl office New York to receive your Prepaid ATM Master Card worth $15.8Million US DOLLARS no ===

From: "Dr. William Johnson" <currency1000000 () gmail ! com>
To: linux-sparse
Subject: contact Dhl office New York to receive your Prepaid ATM Master Card worth $15.8Million US DOLLARS no
Date: Tue, 07 Jan 2020 19:54:18 +0000
Message-ID: <CAPqfnSFyOwF0m-QsrOdcFV_PCC3TSBr=YQHoQHvH0baKHfeF6Q () mail ! gmail ! com>
--------------------
ATTN Dear Beneficiary.
Goodnews
I have Registered your Prepaid ATM Master Card
worth $15.800,000.00 US DOLLARS Courier company asigned to deliver it
to you today.
So contact Dhl office New York to receive your Prepaid ATM Master Card
worth $15.8Million US DOLLARS now.
Contact Person: Mrs. Mary Michael, Director, DHL Courier Company-NY USA. 10218
Email. dhlexpresscouriercompany.nyusa@gmail.com
Call the office +(202) 890-8752
Rec-Confirmed your mailing address to the office as I listed below.
Your Full Name--------------
House Address-----------
Your working Phone Number----------------
ID copy-------------------------
Sex-----------------------------
Note,delivery fee to your address is only $50.00. send it to this
company urgent on itunes card today so that DHL will deliver this
Prepaid ATM Master Card to you today according to our finally
agreement.
Thanks for coperations,
Dr. William Johnson
================================================================================


################################################################################

=== Thread: convert_section.pl attached ===

From: Joe Perches <joe () perches ! com>
To: linux-sparse
Subject: convert_section.pl attached
Date: Wed, 30 Sep 2020 23:10:31 +0000
Message-ID: <75393e5ddc272dc7403de74d645e6c6e0f4e70eb.camel () perches ! com>
--------------------

--=-C0QQNuhA3ALce9aKym+T
Content-Type: text/plain; charset="ISO-8859-1"
Content-Transfer-Encoding: 7bit

Here's a new version that does not update arch/powerpc/boot/ files
to avoid the defective conversions that Nick found in powerpc.



--=-C0QQNuhA3ALce9aKym+T
Content-Type: application/x-perl; name="convert_section.pl"
Content-Disposition: attachment; filename="convert_section.pl"
Content-Transfer-Encoding: base64

IyEvdXNyL2Jpbi9lbnYgcGVybAoKIyBjb252ZXJ0IGxpbnV4LWtlcm5lbCBfX3NlY3Rpb24gdXNl
cyBmcm9tIHVucXVvdGVkIHN0cmluZyB0byBxdW90ZWQgc3RyaW5nCiMgY29udmVydCBfX2F0dHJp
YnV0ZV9fKChzZWN0aW9uKCJmb28iKSkpIHRvIF9fc2VjdGlvbigiZm9vIikKIyBjb252ZXJ0IF9f
YXR0cmlidXRlX18oKGZvbywgc2VjdGlvbj0oImJhciIpLCBiYXopKQojICAgICAgdG8gX19zZWN0
aW9uKCJiYXIiKSBhdHRyaWJ1dGUoKGZvbywgYmF6KSkKIyBjb252ZXJ0IF9fYXR0cmlidXRlX18K
CnVzZSBzdHJpY3Q7CgojIHBhdGNoIGNvbXBpbGVyX2F0dHJpYnV0ZXMuaCB0byByZW1vdmUgcXVv
dGluZyBvZiBzZWN0aW9uIG5hbWUKCm15ICRyZXN1bHQgPSBgcGF0Y2ggLXAxIDw8IkVPRiIKIGlu
Y2x1ZGUvbGludXgvY29tcGlsZXJfYXR0cmlidXRlcy5oIHwgMiArLQogMSBmaWxlIGNoYW5nZWQs
IDEgaW5zZXJ0aW9uKCspLCAxIGRlbGV0aW9uKC0pCgpkaWZmIC0tZ2l0IGEvaW5jbHVkZS9saW51
eC9jb21waWxlcl9hdHRyaWJ1dGVzLmggYi9pbmNsdWRlL2xpbnV4L2NvbXBpbGVyX2F0dHJpYnV0
ZXMuaAppbmRleCBlYTdiNzU2YjFjOGYuLmIyYTNmNGY2NDFhNyAxMDA2NDQKLS0tIGEvaW5jbHVk
ZS9saW51eC9jb21waWxlcl9hdHRyaWJ1dGVzLmgKKysrIGIvaW5jbHVkZS9saW51eC9jb21waWxl
cl9hdHRyaWJ1dGVzLmgKQEAgLTI1NCw3ICsyNTQsNyBAQAogICogICBnY2M6IGh0dHBzOi8vZ2Nj
LmdudS5vcmcvb25saW5lZG9jcy9nY2MvQ29tbW9uLVZhcmlhYmxlLUF0dHJpYnV0ZXMuaHRtbCNp
bmRleC1zZWN0aW9uLXZhcmlhYmxlLWF0dHJpYnV0ZQogICogY2xhbmc6IGh0dHBzOi8vY2xhbmcu
bGx2bS5vcmcvZG9jcy9BdHRyaWJ1dGVSZWZlcmVuY2UuaHRtbCNzZWN0aW9uLWRlY2xzcGVjLWFs
bG9jYXRlCiAgKi8KLSNkZWZpbmUgX19zZWN0aW9uKFMpICAgICAgICAgICAgICAgICAgICBfX2F0
dHJpYnV0ZV9fKChfX3NlY3Rpb25fXygjUykpKQorI2RlZmluZSBfX3NlY3Rpb24oc2VjdGlvbikg
ICAgICAgICAgICAgIF9fYXR0cmlidXRlX18oKF9fc2VjdGlvbl9fKHNlY3Rpb24pKSkKIAogLyoK
ICAqICAgZ2NjOiBodHRwczovL2djYy5nbnUub3JnL29ubGluZWRvY3MvZ2NjL0NvbW1vbi1GdW5j
dGlvbi1BdHRyaWJ1dGVzLmh0bWwjaW5kZXgtdW51c2VkLWZ1bmN0aW9uLWF0dHJpYnV0ZQpFT0Zg
OwoKIyBwYXRjaCBzY3JpcHRzL21vZC9tb2Rwb3N0LmMgdG8gYWRkIHF1b3Rpbmcgb2Ygc2VjdGlv
biBuYW1lCgpteSAkcmVzdWx0ID0gYHBhdGNoIC1wMSA8PCJFT0YiCiBzY3JpcHRzL21vZC9tb2Rw
b3N0LmMgfCA0ICsrLS0KIDEgZmlsZSBjaGFuZ2VkLCAyIGluc2VydGlvbnMoKyksIDIgZGVsZXRp
b25zKC0pCgpkaWZmIC0tZ2l0IGEvc2NyaXB0cy9tb2QvbW9kcG9zdC5jIGIvc2NyaXB0cy9tb2Qv
bW9kcG9zdC5jCmluZGV4IDY5MzQxYjM2ZjI3MS4uZjg4MmNlMGQ5MzI3IDEwMDY0NAotLS0gYS9z
Y3JpcHRzL21vZC9tb2Rwb3N0LmMKKysrIGIvc2NyaXB0cy9tb2QvbW9kcG9zdC5jCkBAIC0yMjU0
LDcgKzIyNTQsNyBAQCBzdGF0aWMgdm9pZCBhZGRfaGVhZGVyKHN0cnVjdCBidWZmZXIgKmIsIHN0
cnVjdCBtb2R1bGUgKm1vZCkKIAlidWZfcHJpbnRmKGIsICJNT0RVTEVfSU5GTyhuYW1lLCBLQlVJ
TERfTU9ETkFNRSk7XFxuIik7CiAJYnVmX3ByaW50ZihiLCAiXFxuIik7CiAJYnVmX3ByaW50Zihi
LCAiX192aXNpYmxlIHN0cnVjdCBtb2R1bGUgX190aGlzX21vZHVsZVxcbiIpOwotCWJ1Zl9wcmlu
dGYoYiwgIl9fc2VjdGlvbiguZ251LmxpbmtvbmNlLnRoaXNfbW9kdWxlKSA9IHtcXG4iKTsKKwli
dWZfcHJpbnRmKGIsICJfX3NlY3Rpb24oXFwiLmdudS5saW5rb25jZS50aGlzX21vZHVsZVxcIikg
PSB7XFxuIik7CiAJYnVmX3ByaW50ZihiLCAiXFx0Lm5hbWUgPSBLQlVJTERfTU9ETkFNRSxcXG4i
KTsKIAlpZiAobW9kLT5oYXNfaW5pdCkKIAkJYnVmX3ByaW50ZihiLCAiXFx0LmluaXQgPSBpbml0
X21vZHVsZSxcXG4iKTsKQEAgLTIzMDgsNyArMjMwOCw3IEBAIHN0YXRpYyBpbnQgYWRkX3ZlcnNp
b25zKHN0cnVjdCBidWZmZXIgKmIsIHN0cnVjdCBtb2R1bGUgKm1vZCkKIAogCWJ1Zl9wcmludGYo
YiwgIlxcbiIpOwogCWJ1Zl9wcmludGYoYiwgInN0YXRpYyBjb25zdCBzdHJ1Y3QgbW9kdmVyc2lv
bl9pbmZvIF9fX192ZXJzaW9uc1tdXFxuIik7Ci0JYnVmX3ByaW50ZihiLCAiX191c2VkIF9fc2Vj
dGlvbihfX3ZlcnNpb25zKSA9IHtcXG4iKTsKKwlidWZfcHJpbnRmKGIsICJfX3VzZWQgX19zZWN0
aW9uKFxcIl9fdmVyc2lvbnNcXCIpID0ge1xcbiIpOwogCiAJZm9yIChzID0gbW9kLT51bnJlczsg
czsgcyA9IHMtPm5leHQpIHsKIAkJaWYgKCFzLT5tb2R1bGUpCkVPRmA7CgojIEdldCB0aGUgbGlz
dCBvZiBmaWxlcyB0byBtb2RpZnkgKGNvbnRhaW5zIF9fc2VjdGlvbiBvciBfX2F0dHJpYnV0ZV9f
LipzZWN0aW9uCiMgKGlnbm9yZSBzY3JpcHRzLCB0b29scywgdWFwaSwgYXJjaC9wb3dlcnBjL2Jv
b3QgYW5kIGNvbXBpbGVyX2F0dHJpYnV0ZXMuaCkKCm15ICRvdXRwdXQgPSBgZ2l0IGdyZXAgLS1u
YW1lLW9ubHkgLVAgIig/OlxcYl9fc2VjdGlvblxcYlx8XFxiX19hdHRyaWJ1dGVfX1xcYi4qc2Vj
dGlvbikiIHwgZ3JlcCAtdlAgJ14oPzppbmNsdWRlL2xpbnV4L2NvbXBpbGVyX2F0dHJpYnV0ZXNc
XC5ofHNjcmlwdHMvfHRvb2xzL3wvdWFwaS98YXJjaC9wb3dlcnBjL2Jvb3QvKSdgOwpteSBAZmls
ZXMgPSBzcGxpdCgiXG4iLCAkb3V0cHV0KTsKIyBBZGQgdGhlIG9ubHkgZmlsZSBpbiB0b29scyB0
aGF0IG5lZWRzIGNvbnZlcnNpb24KcHVzaCAoQGZpbGVzLCAidG9vbHMvaW5jbHVkZS9saW51eC9v
Ymp0b29sLmgiKTsKCiMgTW9kaWZ5IGVhY2ggcG9zc2libGUgZmlsZQpmb3JlYWNoIChAZmlsZXMp
IHsKICAgIGNob21wOwogICAgbXkgJGZpbGUgPSAkXzsKCiAgICAjIHJlYWQgdGhlIG9yaWdpbmFs
IGZpbGUKICAgIG9wZW4oRkgsICc8JywgJGZpbGUpIG9yIGRpZSAkITsKICAgIG15IEBsaW5lcyA9
IDxGSD47CiAgICBjbG9zZSBGSDsKCiAgICAjIHdyaXRlIHRoZSBtb2RpZmllZCBmaWxlIGxpbmUg
YnkgbGluZQogICAgb3BlbiAoRkgsICc+JywgJGZpbGUpIG9yIGRpZSAkITsKICAgIGZvcmVhY2gg
bXkgJGxpbmUgKEBsaW5lcykgewoJY2hvbXAgJGxpbmU7CglteSAkbmV3bGluZSA9ICRsaW5lOwoK
CSMgQ29udmVydCBfX3NlY3Rpb24oZm9vKSB0byBfX3NlY3Rpb24oImZvbyIpCgkjIGlmICJmb28i
IHVzZXMgbXVsdGlwbGUgdG9rZW4gcGFzdGluZywKCSMgICBwcmUgYW5kIHBvc3QgdG9rZW5zIHJl
bW92ZWQgYW5kIGEgc2luZ2xlICMgaXMgdXNlZCB0aGVuICIgIiBhZGRlZAoJIyAgIGUuZy46ICBm
b28gIyMgYmFyICMjIGJheiBiZWNvbWVzICJmb28iICNiYXIgImJheiIKCWlmICgkbGluZSA9fiBt
L1xiX19zZWN0aW9uXHMqXChccyooPyEiKShbXlwpXSspXCkvKSB7CgkgICAgbXkgJG9sZHNlY3Rp
b24gPSAkMTsKCSAgICBteSAkbmV3c2VjdGlvbiA9ICQxOwoJICAgIGlmICgkb2xkc2VjdGlvbiA9
fiAvKC4qKSMjKC4qKSMjKC4qKS8pIHsKCQkkbmV3c2VjdGlvbiA9ICciJyAuIHRyaW0oJDEpIC4g
JyIgIycgLiB0cmltKCQyKSAuICcgIicgLiB0cmltKCQzKSAuICciJzsKCSAgICB9IGVsc2UgewoJ
CSRuZXdzZWN0aW9uID0gJyInIC4gdHJpbSgkb2xkc2VjdGlvbikgLiAnIic7CgkgICAgfQoJICAg
ICRuZXdsaW5lID1+IHMvX19zZWN0aW9uXHMqXChccypcUSRvbGRzZWN0aW9uXEVccypcKS9fX3Nl
Y3Rpb24oJG5ld3NlY3Rpb24pLzsKCX0KCgkjIGNvbnZlcnQgX19hdHRyaWJ1dGVfXygoc2VjdGlv
bigiZm9vIikpKSB0byBfX3NlY3Rpb24oImZvbyIpCgkkbmV3bGluZSA9fiBzL1xiX19hdHRyaWJ1
dGVfX1xzKlwoXHMqXChccypfKnNlY3Rpb25fKlxzKlwoXHMqKCJbXiJdKyIpXHMqXClccypcKVxz
KlwpL19fc2VjdGlvbigkMSkvOwoKCSMgY29udmVydCBfX2F0dHJpYnV0ZV9fKChmb28sIHNlY3Rp
b249KCJiYXIiKSwgYmF6KSkKCSMgdG8gX19zZWN0aW9uKCJiYXIiKSBhdHRyaWJ1dGUoKGZvbywg
YmF6KSkKCWlmICgkbmV3bGluZSA9fiAvKFxiX19hdHRyaWJ1dGVfX1xzKlwoXHMqXCgoW14sX10r
KT8oXHMqLD9ccypfKnNlY3Rpb25fKlxzKlwoXHMqKCJbXiJdKyIpXHMqXClccyosP1xzKikoLiop
XHMqXClccypcKSkvKSB7CgkgICAgbXkgJHNlY3Rpb24gPSAkMzsKCSAgICBteSAkY29tbWEgPSAi
IjsKCSAgICAkY29tbWEgPSAiLCAiIGlmICgkc2VjdGlvbiA9fiAvXlxzKiwvICYmICRzZWN0aW9u
ID1+IC8sXHMqJC8pOwoJICAgICRuZXdsaW5lID1+IHMvXFEkc2VjdGlvblxFLyRjb21tYS87Cgkg
ICAgJHNlY3Rpb24gPX4gcy9eW14iXSovLzsKCSAgICAkc2VjdGlvbiA9fiBzL14oIlteIl0qIiku
Ki8kMS87CgkgICAgJG5ld2xpbmUgPX4gcy9cYl9fYXR0cmlidXRlX18vX19zZWN0aW9uKCRzZWN0
aW9uKSBfX2F0dHJpYnV0ZV9fLzsKCX0KCgkjIGlmIHRoZSBsaW5lIGVuZGVkIHdpdGggYSBsaW5l
IGNvbnRpbnVhdGlvbiBcLCB0cnkgdG8gbW92ZSB0aGUKCSMgY29udGludWF0aW9uIHRvIHRoZSBz
YW1lIGxvY2F0aW9uIGJ5IHJlbW92aW5nIG9yIGFkZGluZyB0YWJzCglpZiAoJGxpbmUgPX4gL1xc
JC8pIHsKCSAgICBteSAkb2xlbiA9IGxlbmd0aChleHBhbmRfdGFicygkbGluZSkpOwoJICAgIG15
ICRubGVuID0gbGVuZ3RoKGV4cGFuZF90YWJzKCRuZXdsaW5lKSk7CgkgICAgaWYgKCRuZXdsaW5l
ID1+IC9cdFxcJC8pIHsKCQlpZiAoJG5sZW4gPiAkb2xlbikgewoJCSAgICAkbmV3bGluZSA9fiBz
L1x0XFwkL1xcLzsKCQl9IGVsc2UgewoJCSAgICB3aGlsZSAoJG5sZW4gPCAkb2xlbikgewoJCQkk
bmV3bGluZSA9fiBzL1xcJC9cdFxcLzsKCQkJJG5sZW4gPSBsZW5ndGgoZXhwYW5kX3RhYnMoJG5l
d2xpbmUpKTsKCQkgICAgfQoJCX0KCSAgICB9Cgl9CglwcmludCBGSCAiJG5ld2xpbmVcbiI7CiAg
ICB9CiAgICBjbG9zZSBGSDsKfQoKIyBBbmQgZ2l0IGNvbW1pdCB0aGUgY2hhbmdlcwokcmVzdWx0
ID0gcXh7Z2l0IGNvbW1pdCAtYSAtLWF1dGhvcj0nSm9lIFBlcmNoZXMgPGpvZVxAcGVyY2hlcy5j
b20+JyAtRi0gPDwiRU9GIgp0cmVld2lkZTogQ29udmVydCBtYWNybyBhbmQgdXNlcyBvZiBfX3Nl
Y3Rpb24oZm9vKSB0byBfX3NlY3Rpb24oImZvbyIpCgpVc2UgYSBtb3JlIGdlbmVyaWMgZm9ybSBm
b3IgX19zZWN0aW9uIHRoYXQgcmVxdWlyZXMgcXVvdGVzIHRvIGF2b2lkCmNvbXBsaWNhdGlvbnMg
d2l0aCBjbGFuZyBhbmQgZ2NjIGRpZmZlcmVuY2VzLgoKUmVtb3ZlIHRoZSBxdW90ZSBvcGVyYXRv
ciAjIGZyb20gY29tcGlsZXJfYXR0cmlidXRlcy5oIF9fc2VjdGlvbiBtYWNyby4KCkNvbnZlcnQg
YWxsIHVucXVvdGVkIF9fc2VjdGlvbihmb28pIHVzZXMgdG8gcXVvdGVkIF9fc2VjdGlvbigiZm9v
IikuCkFsc28gY29udmVydCBfX2F0dHJpYnV0ZV9fKChzZWN0aW9uKCJmb28iKSkpIHVzZXMgdG8g
X19zZWN0aW9uKCJmb28iKQpldmVuIGlmIHRoZSBfX2F0dHJpYnV0ZV9fIGhhcyBtdWx0aXBsZSBs
aXN0IGVudHJ5IGZvcm1zLgoKU2lnbmVkLW9mZi1ieTogSm9lIFBlcmNoZXMgPGpvZVxAcGVyY2hl
cy5jb20+CkVPRgp9OwoKIyB1dGlsaXR5IHN1YnJvdXRpbmVzCnN1YiB0cmltIHsKICAgIG15ICgk
c3RyaW5nKSA9IEBfOwogICAgJHN0cmluZyA9fiBzL15ccyt8XHMrJC8vZzsKICAgIHJldHVybiAk
c3RyaW5nOwp9CgpzdWIgZXhwYW5kX3RhYnMgewogICAgbXkgKCRzdHIpID0gQF87CgogICAgbXkg
JHJlcyA9ICcnOwogICAgbXkgJG4gPSAwOwogICAgZm9yIG15ICRjIChzcGxpdCgvLywgJHN0cikp
IHsKCWlmICgkYyBlcSAiXHQiKSB7CgkgICAgJHJlcyAuPSAnICc7CgkgICAgJG4rKzsKCSAgICBm
b3IgKDsgKCRuICUgOCkgIT0gMDsgJG4rKykgewoJCSRyZXMgLj0gJyAnOwoJICAgIH0KCSAgICBu
ZXh0OwoJfQoJJHJlcyAuPSAkYzsKCSRuKys7CiAgICB9CgogICAgcmV0dXJuICRyZXM7Cn0K


--=-C0QQNuhA3ALce9aKym+T--

================================================================================


################################################################################

=== Thread: jjCompliment ===

From: mrs chantal <mrs.chantalas1 () gmail ! com>
To: linux-sparse
Subject: jjCompliment
Date: Sat, 23 May 2020 18:00:37 +0000
Message-ID: <CAMdkyyDY_0O7YgysHCjgRTJ=8-B7XurK7o1razRHDVOjgr2V2g () mail ! gmail ! com>
--------------------
     Compliment of the day to you. I am Mrs.CHANTAL I am sending this brief
    letter to solicit your partnership to transfer $13.5 Million US
    Dollars.I shall send you more information and procedures when I receive
    positive response From you. Please send me a message in My private
    email address is ( mrschantal066@gmail.com  )
    Best Regards
    MrS.Chantal
================================================================================


################################################################################

=== Thread: smatch/sparse complaints on static assertion ===

From: Shannon Nelson <snelson () pensando ! io>
To: linux-sparse
Subject: smatch/sparse complaints on static assertion
Date: Tue, 11 Feb 2020 17:41:05 +0000
Message-ID: <ecdd10cb-0022-8f8a-ec36-9d51b3ae85ee () pensando ! io>
--------------------
Hi All,

I'm getting complaints from smatch on the ionic network driver's static 
assertions and am not sure why it was complaining.Â  Dan Carpenter 
suggested this might be an issue in sparse with how it is calculating 
the sizes of the unions.

I ran this at the top of a pretty recent net-next tree 
(v5.5-rc7-1839-g8192c36)
$ ../smatch/smatch_scripts/kchecker drivers/net/ethernet/pensando/ionic/

And got several copies of this:

drivers/net/ethernet/pensando/ionic/ionic_dev.h:38:1: error: static 
assertion failed: "sizeof(union ionic_dev_regs) == 4096"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:40:1: error: static 
assertion failed: "sizeof(union ionic_dev_cmd_regs) == 2048"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:56:1: error: static 
assertion failed: "sizeof(struct ionic_dev_getattr_comp) == 16"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:57:1: error: static 
assertion failed: "sizeof(struct ionic_dev_setattr_cmd) == 64"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:58:1: error: static 
assertion failed: "sizeof(struct ionic_dev_setattr_comp) == 16"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:68:1: error: static 
assertion failed: "sizeof(struct ionic_port_getattr_comp) == 16"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:78:1: error: static 
assertion failed: "sizeof(struct ionic_lif_getattr_comp) == 16"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:79:1: error: static 
assertion failed: "sizeof(struct ionic_lif_setattr_cmd) == 64"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:80:1: error: static 
assertion failed: "sizeof(struct ionic_lif_setattr_comp) == 16"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:82:1: error: static 
assertion failed: "sizeof(struct ionic_q_init_cmd) == 64"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:117:1: error: static 
assertion failed: "sizeof(struct ionic_vf_setattr_cmd) == 64"
drivers/net/ethernet/pensando/ionic/ionic_dev.h:120:1: error: static 
assertion failed: "sizeof(struct ionic_vf_getattr_comp) == 16"

These static assertion lines have been fine up until now and I'm pretty 
sure they are correct.

Has this issue been seen elsewhere?Â  Or is there something I can do in 
our code to get rid of the complaints?

Thanks,
sln



================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: smatch/sparse complaints on static assertion
Date: Wed, 12 Feb 2020 00:36:10 +0000
Message-ID: <CAHk-=wi7jGZ+bVbt-UfXOkpEQdHzF3Z2HBjkGdjh8q4dvPPGWQ () mail ! gmail ! com>
--------------------
On Tue, Feb 11, 2020 at 9:41 AM Shannon Nelson <snelson@pensando.io> wrote:
>
> drivers/net/ethernet/pensando/ionic/ionic_dev.h:56:1: error: static
> assertion failed: "sizeof(struct ionic_dev_getattr_comp) == 16"

As Luc says, this is because those structures are mis-declared.

See this, for example:

  struct ionic_dev_getattr_comp {
        u8     status;
        u8     rsvd[3];
        union {
                __le64  features;
                u8      rsvd2[11];
        };
        u8     color;
  };

and notice how "__le64  features" is a 64-bit entity but it's in a
union with a "u8 rsvd2[11];".

That makes the whole union align to the same as the __le64 (on x86-32,
that's 32-bit, for bad legacy reasons, on everything else it's
64-bit).

Mark the associated types properly packed individually, rather than
use the disgusting "pragma pack()" that should never be used.

This is not a recent sparse change, it must never have worked.

            Linus
================================================================================

From: Shannon Nelson <snelson () pensando ! io>
To: linux-sparse
Subject: Re: smatch/sparse complaints on static assertion
Date: Wed, 12 Feb 2020 01:01:45 +0000
Message-ID: <23e34336-22fa-d14d-c765-877abc05df12 () pensando ! io>
--------------------
On 2/11/20 4:31 PM, Luc Van Oostenryck wrote:
> On Tue, Feb 11, 2020 at 09:41:05AM -0800, Shannon Nelson wrote:
>> Hi All,
>>
>> I'm getting complaints from smatch on the ionic network driver's static
>> assertions and am not sure why it was complaining.Â  Dan Carpenter suggested
>> this might be an issue in sparse with how it is calculating the sizes of the
>> unions.
>>
>> I ran this at the top of a pretty recent net-next tree
>> (v5.5-rc7-1839-g8192c36)
>> $ ../smatch/smatch_scripts/kchecker drivers/net/ethernet/pensando/ionic/
>>
>> And got several copies of this:
>>
>> drivers/net/ethernet/pensando/ionic/ionic_dev.h:38:1: error: static
>> assertion failed: "sizeof(union ionic_dev_regs) == 4096"
> ...
>   
>> These static assertion lines have been fine up until now and I'm pretty sure
>> they are correct.
>>
>> Has this issue been seen elsewhere?Â  Or is there something I can do in our
>> code to get rid of the complaints?
> This is caused by the packing of the structs. It's using
> 	#pragma pack(push, 1) / #pragma pack(pop)
> which is not supported by Sparse. Packing via __attribute__((packed))
> is incomplete but the pragmas are currently completly ignored.
>
> -- Luc Van Oostenryck

Ah, that makes sense.Â  Thanks.
sln

================================================================================


################################################################################

=== Thread: sparse multiple address spaces? ===

From: Randy Dunlap <rdunlap () infradead ! org>
To: linux-sparse
Subject: sparse multiple address spaces?
Date: Wed, 19 Aug 2020 19:15:46 +0000
Message-ID: <e9deb689-e470-49e5-a339-252cb05ee119 () infradead ! org>
--------------------
On Linux kernel tree v5.9-rc1, with sparse v0.6.2-180-g49f7e13a,
I see this sparse warning which I don't grok:

../include/uapi/asm-generic/signal-defs.h:19:29: CK: error: multiple address spaces given

for this source code:

typedef void __signalfn_t(int);
typedef __signalfn_t __user *__sighandler_t; <<<<< line 19

Are there multiple address spaces there?  What are they?



or: is the warning related to the other nearby warnings?  (e.g.:)

../kernel/signal.c:541:53: CK: warning: incorrect type in initializer (different address spaces)
../kernel/signal.c:541:53: CK:    expected struct k_sigaction *ka
../kernel/signal.c:541:53: CK:    got struct k_sigaction [noderef] __rcu *
../include/uapi/asm-generic/signal-defs.h:19:29: CK: error: multiple address spaces given
../kernel/signal.c:694:33: CK: warning: incorrect type in argument 1 (different address spaces)
../kernel/signal.c:694:33: CK:    expected struct spinlock [usertype] *lock
../kernel/signal.c:694:33: CK:    got struct spinlock [noderef] __rcu *


thanks.
-- 
~Randy

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse multiple address spaces?
Date: Wed, 19 Aug 2020 20:52:34 +0000
Message-ID: <20200819205234.ulgeccdi4fsidwou () ltop ! local>
--------------------
On Wed, Aug 19, 2020 at 10:06:55PM +0200, Luc Van Oostenryck wrote:
> On Wed, Aug 19, 2020 at 12:15:46PM -0700, Randy Dunlap wrote:
> > On Linux kernel tree v5.9-rc1, with sparse v0.6.2-180-g49f7e13a,
> > I see this sparse warning which I don't grok:
> > 
> > ../include/uapi/asm-generic/signal-defs.h:19:29: CK: error: multiple address spaces given
> > 
> > for this source code:
> > 
> > typedef void __signalfn_t(int);
> > typedef __signalfn_t __user *__sighandler_t; <<<<< line 19
> > 
> > Are there multiple address spaces there?  What are they?
> > 
> > 
> > 
> > or: is the warning related to the other nearby warnings?  (e.g.:)
> > 
> > ../kernel/signal.c:541:53: CK: warning: incorrect type in initializer (different address spaces)
> > ../kernel/signal.c:541:53: CK:    expected struct k_sigaction *ka
> > ../kernel/signal.c:541:53: CK:    got struct k_sigaction [noderef] __rcu *
> > ../include/uapi/asm-generic/signal-defs.h:19:29: CK: error: multiple address spaces given
> > ../kernel/signal.c:694:33: CK: warning: incorrect type in argument 1 (different address spaces)
> > ../kernel/signal.c:694:33: CK:    expected struct spinlock [usertype] *lock
> > ../kernel/signal.c:694:33: CK:    got struct spinlock [noderef] __rcu *
> 
> I would guess that this __sighandler_t is used somewhere in a
> struct which is itself accessed via a __rcu pointer.
> But that would not explain the level of dereference.
> 
> I'll need to check this one.

The location of the warning should be the assignment in kernel/signal.c:69

	static void __user *sig_handler(struct task_struct *t, int sig) 
	{
		return t->sighand->action[sig - 1].sa.sa_handler;
	}
 
There is a lot of type abuses in this file, between 'void __user *' and
__sighandler_t, but the root cause of the warning is the '__rcu' in 

	struct task_struct {
		...
		struct sighand_struct __rcu *sighand;
		...
	}

Best regards,
-- Luc
================================================================================


################################################################################

=== Thread: sparse problem with duplicate __iomem? ===

From: Randy Dunlap <rdunlap () infradead ! org>
To: linux-sparse
Subject: Re: sparse problem with duplicate __iomem?
Date: Tue, 18 Aug 2020 20:11:40 +0000
Message-ID: <7fcb4469-2f5e-e4f3-087a-a115c1f27292 () infradead ! org>
--------------------
On 8/18/20 12:23 PM, Luc Van Oostenryck wrote:
> On Tue, Aug 18, 2020 at 11:09:52AM -0700, Randy Dunlap wrote:
>> Hi,
>>
>> On kernel 5.9-rc1, either i386 or x86_64 builds, I am seeing these
>> sparse warnings:
>>
>> ../drivers/gpu/drm/ast/ast_cursor.c:256:26: CK: warning: duplicate [noderef]
>> ../drivers/gpu/drm/ast/ast_cursor.c:256:26: CK: error: multiple address space given: __iomem & __iomem
>>
>> for this source line:
>>
>> 	u8 __iomem *dst, __iomem *sig;
>>
>>
>> Should one of those __iomem-s be removed?
> 
> I think so. It's a bit like writing
> 	int const *a, const *b;
> or
> 	int unsigned *a, unsigned *b;
> 
>> I.e., does "__iomem" apply to everything after it, up to the ending ';',
>> or just up to the next comma ','? 
> 
> The (simplified) syntax for declarations is:
> 	declaration:
> 		declaration-specifiers [init-declarator-list] ;
> 	init-declarator-list:
> 		init-declarator
> 		init-declarator-list , init-declarator
> 	init-declarator
> 		declarator
> 		declarator = initializer
> 	declarator:
> 		[pointer] direct-declarator
> 	pointer:
> 		* [type-qualifier-list]
> 		* [type-qualifier-list] pointer
> 	direct-declarator:
> 		identifier
> 		...
> 
> Essentially, attributes are type modifiers, some acting like
> qualifiers and others are more like specifiers. But qualifiers
> and specifiers are never allowed directly after the comma because
> they appertain to the declaration-specifier part of the declaration.
> So, yes, the first __iomem applies to the whole declaration and
> the second one should be removed.
> 
> But maybe it's not 100% clear and the best should be to use a
> separate declaration for each variable?

Yes, that was my patch plan. :)

Thanks for the explanation.

-- 
~Randy

================================================================================


################################################################################

=== Thread: spende von 2,000,000 euro ===

From: ''Tayeb souami'' <vanessa.ramirez () hlgd ! gob ! ec>
To: linux-sparse
Subject: spende von 2,000,000 euro
Date: Fri, 25 Sep 2020 03:37:37 +0000
Message-ID: <20200925033747.2FDF634C8020 () mail ! hlgd ! gob ! ec>
--------------------

Hallo mein lieber Freund
Mein Name ist Tayeb Souami aus New Jersey in Amerika und ich habe den America Lottery Jackpot von 315 Millionen Euro gewonnen. Ich habe mich entschlossen, die Summe von 2.000.000 Euro an fünf glückliche Personen zu spenden, und Sie wurden als einer der Begünstigten ausgewählt. Bitte klicken Sie auf diesen Link, um mehr über meinen Gewinn zu erfahren.


UHR MICH HIER: https://www.youtube.com/watch?v=Z6ui8ZDQ6Ks

Bitte kontaktieren Sie mich über diese E-Mail: Tayebsouam.spende@gmail.com


Ich hoffe, Sie und Ihre Familie glücklich zu machen.

Grüße
Herr Tayeb Souami
================================================================================


################################################################################

=== Thread: update to format parsing branch ===

From: Ben Dooks <ben.dooks () codethink ! co ! uk>
To: linux-sparse
Subject: update to format parsing branch
Date: Wed, 30 Sep 2020 08:35:50 +0000
Message-ID: <3960bea7-69ef-ed00-66cf-ac73d5cd8876 () codethink ! co ! uk>
--------------------
I've done a rebase to v0.6.2 and put the result up at:

https://gitlab.com/CodethinkLabs/sparse bjdooks/printf-new3

Should I put this through a new round of review?

-- 
Ben Dooks				http://www.codethink.co.uk/
Senior Engineer				Codethink - Providing Genius

https://www.codethink.co.uk/privacy.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: update to format parsing branch
Date: Wed, 30 Sep 2020 20:29:34 +0000
Message-ID: <20200930202934.rjcfxikrzfvesxnc () ltop ! local>
--------------------
On Wed, Sep 30, 2020 at 09:35:50AM +0100, Ben Dooks wrote:
> I've done a rebase to v0.6.2 and put the result up at:
> 
> https://gitlab.com/CodethinkLabs/sparse bjdooks/printf-new3

Great.
It just needs a few very mnor changes:

%% diff --git a/evaluate.h b/evaluate.h
%% index a16e97036b2a..bb8ec480691c 100644
%% --- a/evaluate.h
%% +++ b/evaluate.h
%% @@ -26,10 +26,14 @@ struct symbol *evaluate_statement(struct statement *stmt);
%%  // @list: the list of the symbol to be evaluated
%%  void evaluate_symbol_list(struct symbol_list *list);
%%  
%% -///

This is the marker for autodoc, so it needs to stay.

%%  // evaluate the arguments of a function
%% +// @fn: the symbol of the prototype
%%  // @argtypes: the list of the types in the prototype
%%  // @args: the list of the effective arguments
%% -int evaluate_arguments(struct symbol_list *argtypes, struct expression_list *args);
%% +int evaluate_arguments(struct symbol *fn, struct symbol_list *argtypes, struct expression_list *args);
%%  
%% +// check if assignment types are compatible
%% +// todo

I've removed the 'todo'

%% diff --git a/parse.c b/parse.c
%% index 31ecef0f554d..a7ab5fd6e531 100644
%% --- a/parse.c
%% +++ b/parse.c
%% @@ -377,6 +383,10 @@ static struct symbol_op attr_force_op = {
%%  	.attribute = attribute_force,
%%  };
%%  
%% +static struct symbol_op attr_format = {

To stay coherent with existent naming, I've rename this into 'attr_format_op'

%% @@ -515,6 +535,7 @@ static struct init_keyword {
%%  	N("_Float64",		&spec_op,	.type = &float64_ctype),
%%  	N("_Float64x",		&spec_op,	.type = &float64x_ctype),
%%  	N("_Float128",		&spec_op,	.type = &float128_ctype),
%% +

Removd unneeded line.

%% @@ -551,6 +572,9 @@ static struct init_keyword {
%%  	D("pure",		&attr_fun_op,		.mods = MOD_PURE),
%%  	A("const",		&attr_fun_op,		.mods = MOD_PURE),
%%  	D("gnu_inline",		&attr_fun_op,		.mods = MOD_GNU_INLINE),
%% +	N("format",		&attr_format),
%% +	N("printf",		&attr_printf_op),
%% +	N("scanf",		&attr_scanf_op),

I've changed the 'N' into 'D' since the underscore versions are legit and
often favored.

%% diff --git a/sparse.1 b/sparse.1
%% index 48dab7a9a5c1..e46aafdb3e5e 100644
%% --- a/sparse.1
%% +++ b/sparse.1
%% @@ -275,6 +275,15 @@ trouble.
%%  Sparse does not issue these warnings by default.
%%  .
%%  .TP
%% +.B \-Wformat
%% +Warn about parameter mismatch to any variadic function which specifies
%% +where the format string is specified with the 
%% +.BI __attribute__((format( type, message, va_start )))
%% +attribute.
%% +
%% +Sparse does not issue these warnings by default. To turn them on, use
%% +\fB\-Wno\-format\fR
%% +.TP

I've moved this one position above, between '-Wexternal-...' and -Winit-..
to keep the alphabetical order, removed some unneeded whitespace and
added a final dot.

%% diff --git a/symbol.h b/symbol.h
%% index a3ed95678ee5..47e26816430c 100644
%% --- a/symbol.h
%% +++ b/symbol.h
%% @@ -84,6 +84,7 @@ enum keyword {
%%  	KW_STATIC	= 1 << 7,
%%       // KW UNUSED	= 1 << 8,
%%  	KW_EXACT	= 1 << 9,
%% +	KW_FORMAT	= 1 << 10,
%%  };

I've just reused the UNUSED slot.


I've also exchanged patch 3 & 4 because the 3rd needed the definition of
Wformat only added in patch 4 and fixed 2 or 3 typos in the commit messages. 
I've pushed these changes at gitlab.com/lucvoo/sparse-dev format-check

I've left for now the changelog parts in the commit messages but I would
prefer to not have them in the final version.

> Should I put this through a new round of review?

I'm fine with the changes (moving the check to a verify-format.c +
some changes related to excessively long lines).

I've one last request, the email address given as author is not the same
as the one used in the Signed-off-by and the copyright notice.

So, is it possible to respin the series with:
* the small changes I've made here above
* removing the changelogs from the commit messages
* using the same email address for the author and the SoB?

Thanks,
-- Luc
================================================================================

From: Ben Dooks <ben.dooks () codethink ! co ! uk>
To: linux-sparse
Subject: Re: update to format parsing branch
Date: Wed, 30 Sep 2020 20:59:12 +0000
Message-ID: <e73b1efe-16ac-883f-4d33-4982d1a5782a () codethink ! co ! uk>
--------------------
On 30/09/2020 21:29, Luc Van Oostenryck wrote:
> On Wed, Sep 30, 2020 at 09:35:50AM +0100, Ben Dooks wrote:
>> I've done a rebase to v0.6.2 and put the result up at:
>>
>> https://gitlab.com/CodethinkLabs/sparse bjdooks/printf-new3

[snip]

> So, is it possible to respin the series with:
> * the small changes I've made here above
> * removing the changelogs from the commit messages
> * using the same email address for the author and the SoB?

Ok, will sort these out tonight.

What's the best branch to base-on for merge?

-- 
Ben Dooks				http://www.codethink.co.uk/
Senior Engineer				Codethink - Providing Genius

https://www.codethink.co.uk/privacy.html
================================================================================

From: Ben Dooks <ben.dooks () codethink ! co ! uk>
To: linux-sparse
Subject: Re: update to format parsing branch
Date: Wed, 30 Sep 2020 21:05:36 +0000
Message-ID: <fb7680ab-eab1-9c32-f515-c2737b78d6a5 () codethink ! co ! uk>
--------------------
On 30/09/2020 21:29, Luc Van Oostenryck wrote:
> On Wed, Sep 30, 2020 at 09:35:50AM +0100, Ben Dooks wrote:
>> I've done a rebase to v0.6.2 and put the result up at:
>>
>> https://gitlab.com/CodethinkLabs/sparse bjdooks/printf-new3
> 
> Great.
> 
> I've one last request, the email address given as author is not the same
> as the one used in the Signed-off-by and the copyright notice.
> 
> So, is it possible to respin the series with:
> * the small changes I've made here above
> * removing the changelogs from the commit messages
> * using the same email address for the author and the SoB?

I can't see any diffs between git-authour and the SoB in the series.



-- 
Ben Dooks				http://www.codethink.co.uk/
Senior Engineer				Codethink - Providing Genius

https://www.codethink.co.uk/privacy.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: update to format parsing branch
Date: Wed, 30 Sep 2020 21:37:09 +0000
Message-ID: <20200930213709.n2n6qwv5vrso3r5g () ltop ! local>
--------------------
On Wed, Sep 30, 2020 at 09:59:12PM +0100, Ben Dooks wrote:
> On 30/09/2020 21:29, Luc Van Oostenryck wrote:
> > On Wed, Sep 30, 2020 at 09:35:50AM +0100, Ben Dooks wrote:
> > > I've done a rebase to v0.6.2 and put the result up at:
> > > 
> > > https://gitlab.com/CodethinkLabs/sparse bjdooks/printf-new3
> 
> [snip]
> 
> > So, is it possible to respin the series with:
> > * the small changes I've made here above
> > * removing the changelogs from the commit messages
> > * using the same email address for the author and the SoB?
> 
> Ok, will sort these out tonight.
> 
> What's the best branch to base-on for merge?

The one you used for your printf-new3:
	24bdaac6682c ("Merge branch 'linear-fma' into next")

is perfect.
-- Luc
================================================================================

From: Ben Dooks <ben.dooks () codethink ! co ! uk>
To: linux-sparse
Subject: Re: update to format parsing branch
Date: Wed, 30 Sep 2020 22:15:02 +0000
Message-ID: <2ddc169e-f996-c4bd-0339-7f1fd3c124d2 () codethink ! co ! uk>
--------------------
On 30/09/2020 22:39, Luc Van Oostenryck wrote:
> On Wed, Sep 30, 2020 at 10:05:36PM +0100, Ben Dooks wrote:
>> On 30/09/2020 21:29, Luc Van Oostenryck wrote:
>>> On Wed, Sep 30, 2020 at 09:35:50AM +0100, Ben Dooks wrote:
>>>> I've done a rebase to v0.6.2 and put the result up at:
>>>>
>>>> https://gitlab.com/CodethinkLabs/sparse bjdooks/printf-new3
>>>
>>> Great.
>>>
>>> I've one last request, the email address given as author is not the same
>>> as the one used in the Signed-off-by and the copyright notice.
>>>
>>> So, is it possible to respin the series with:
>>> * the small changes I've made here above
>>> * removing the changelogs from the commit messages
>>> * using the same email address for the author and the SoB?
>>
>> I can't see any diffs between git-authour and the SoB in the series.
> 
> 	$ git log 5c15b086cd50
> 	commit 5c15b086cd501633be2ad5fedeeb97c09874409a (bjdooks/bjdooks/printf-new3)
> 	Author: Ben Dooks <ben-linux@fluff.org>
> 	Date:   2018-10-30 10:36:26 +0000
> 	
> 	    add -Wformat
> 	
> 	    Add option to enable/disable format checking (and default it to off)
> 	
> 	    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>

Ah, looks like my rebasing has re-authoured it.



-- 
Ben Dooks				http://www.codethink.co.uk/
Senior Engineer				Codethink - Providing Genius

https://www.codethink.co.uk/privacy.html
================================================================================


################################################################################

