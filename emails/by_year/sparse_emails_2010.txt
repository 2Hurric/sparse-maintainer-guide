--- Emails for Year 2010 ---

=== Thread: [No Subject] ===

From: "Mr. Milton Daniel" <jkayal () 4u ! com ! gh>
To: linux-sparse
Subject: 
Date: Wed, 29 Dec 2010 00:58:16 +0000
Message-ID: <1cc857e07fb57ea453ccf65f2ed11e4a.squirrel () webmail ! 4u ! com ! gh>
--------------------



Dear Value Customer,

I am Mr. Milton Daniel from Western Union®, On behalf of the International
Monetary Fund/United Nation/ ECOWAS, I once again try to notify you as my
earlier letter was returned undelivered. I hereby attempt to reach you
again by this same email address been the beneficiary today been 7th Dec
2010. If you received this mail, we are writing to inform you that we have
been given the mandate to transfer your full compensation payment of
$300,000.00USD via Western Union by the International Monetary Fund with
United Nation and ECOWAS.

We have decided to email you the MTCN and sender name, so you can pick up
this $5000.00USD to enable us send another $5000.00USD by tomorrow(8th
Dec.2010) as you know we will be sending you only $5000.00USD per day. 
Please pick up this information and run to any Western Union® office in
your location and your full name is the receivers name and don't forget
that you have to pick up this money after receiving our mail, if you don't
pick up the money in the next 3hrs, then the management will put the money
on hold.

Here is the Western Union® information to pick up the first $5,000

Sender's First name: Duncan
Sender's Last name: Pitts
MTCN: 486508002
Amount: $5,000
Test Question:  Pay
Test Answer: Cash

For verification Kindly check the availability of your via our web site
below. https://wumt.westernunion.com/asp/orderStatus.asp?country=global

If you are having any problem in picking up the money, Simply note that
its because you didn't pick it on time, that is why you are having
problem. If you wish to know more details or if you are having problem in
picking up the money kindly contact post officer.

Mr. Milton Daniel.
Phone :(+234)-807-139-5036
Email: wst-union-direct@admin.in.th

Sincerely,
Western Union®  Customer Centre.







--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: "wrong count at exit" after spin_lock/_unlock pair ===

From: Sven Eckelmann <sven.eckelmann () gmx ! de>
To: linux-sparse
Subject: "wrong count at exit" after spin_lock/_unlock pair
Date: Thu, 28 Oct 2010 10:03:43 +0000
Message-ID: <201010281203.46522.sven.eckelmann () gmx ! de>
--------------------
--nextPart1575344.vSG0leIoSf
Content-Type: Text/Plain;
  charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

Hi,

I use sparse (cgcc) with different kernel versions to do some quick checks =
on=20
the batman-adv kernel module. I noticed that my change from UP to SMP kerne=
l=20
generated some 'weird' warnings regarding a 'context imbalance' which I=20
couldn't find, but went away when switching from spin_(un)lock to=20
spin_(un)lock_bh - something which doesn't make sense in my mind.

I am not quite sure if this is linux-headers or sparse related - so I try t=
o=20
post it here first. I choose 2.6.32 because it is the latest long stable=20
kernel and will be used in by Debian Squeeze.

My current test was done like that (on debian squeeze i386):
=2D----------------------------------------------------------
$ cd $MY_v2.6.32
$ make mrproper
$ make allnoconfig
$ grep -v 'CONFIG_MODULES is not set' .config > .config.tmp; mv .config.tmp=
 \
 .config
$ grep -v 'CONFIG_NET is not set' .config > .config.tmp; mv .config.tmp \
 .config
$ grep -v 'CONFIG_SMP is not set' .config > .config.tmp; mv .config.tmp \
 .config
$ grep -v 'CONFIG_MODULE_UNLOAD is not set' .config > .config.tmp; mv \
 .config.tmp .config
$ echo 'CONFIG_MODULES=3Dy' >> .config
$ echo 'CONFIG_NET=3Dy' >> .config
$ echo 'CONFIG_SMP=3Dy' >> .config
$ echo 'CONFIG_MODULE_UNLOAD=3Dy' >> .config
$ echo 'xy'|make menuconfig
$ make prepare
$ make modules


$ mkdir test
$ cd test
$ cat << EOF > Makefile
obj-m +=3D test.o
test-y +=3D main.o
EOF
$ cat << EOF > main.c
#include <linux/module.h>
#include <linux/spinlock.h>

static DEFINE_SPINLOCK(testlock);

static int __init test_init(void)
{
        spin_lock(&testlock);
        spin_unlock(&testlock);
        return 0;
}

static void __exit test_exit(void)
{
}

module_init(test_init);
module_exit(test_exit);
EOF


$ make CC=3Dcgcc -C $MY_v2.6.32/linux-next M=3D$(pwd) modules         =20
make: Entering directory `$MY_v2.6.32'
  CC [M]  $MY_v2.6.32/testmodule/main.o
$MY_v2.6.32/test/main.c:6:19: warning: context imbalance in 'test_init' -=20
wrong count at exit
  LD [M]  $MY_v2.6.32/test/test.o
  Building modules, stage 2.
  MODPOST 1 modules
  LD [M]  $MY_v2.6.32/test/test.ko
make: Leaving directory `$MY_v2.6.32'
=2D----------------------------------------------------------

The sparse version was v0.4.3. It was obtained from git and and build using=
=20
the current Debian squeeze tools provided by build-essential. It was run fr=
om=20
the build dir by specifying it in $PATH

$ export PATH=3D$MY_SPARSE_CHECKOUT:$PATH

Best regards,
	Sven

--nextPart1575344.vSG0leIoSf
Content-Type: application/pgp-signature; name=signature.asc 
Content-Description: This is a digitally signed message part.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.10 (GNU/Linux)

iQIcBAABCgAGBQJMyUqBAAoJEF2HCgfBJntGq38QAMx7z4FgX+zQfuCGxGXLd/Es
K9MkSitY/ifFPaOqAYnLCd1tX8jtNw2aFoxi7zslvpRM+ei33iwtMaz/GPuE0Fzg
OF92E7SptpreaYQOwj3ZD+E0JuQjkSCCrqai7STwQT3EQX74PoyWzhb+1FnknGTL
FNyhTyxnHE9zQuQ2XbnQe6xsOVsxjVKKTgyqQPa3rWIBzfZhiOSXMPc/1aLDuhoL
+Zh2EJCVMxkBHNoppDUP63EwQE0Ax99VrTn+wWMLWQ8NBMfeHDvFCHZ8g/Hz1+5X
TTlcbzCsakhwr3LG8qQE6oGZ20IMDyKRWSNgf6bUNskJyGWVI+gPVKj8jUzLC7Ff
qU7adE4ymm+yosg0+bTseyuuuy5cZ+nJtAYg2+Q9I75HAGOHbqXNLSKHHs9dbqS+
PfjfO1WZ5wDF5Ry5SdjxZIAeDxmks9AeGRPTGbcXGr5SNSF5kJmKVDQBF3GVmnKu
pziGePgzLe5KrUypLYEcZqOiE6kB+GXUad/MbzsEOqBDym3AMlSL664bTR8O0rL3
V+xpjJWfhlLGNb7fKoMSt9KcPQ0j6WmtWg651boKUosrtQ+ZSSINUXE5fr8WPH0s
hJRrkouxqcZHtBdevgstLS+auSiny9+g8NE8X+Iqr+nTtccdqk2NYIV7J8DZxWys
cNZeq37BkZC6++4vM57L
=V/7C
-----END PGP SIGNATURE-----

--nextPart1575344.vSG0leIoSf--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bogus warning when comparing nocast short variables ===

From: Chris Li <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: Bogus warning when comparing nocast short variables
Date: Thu, 22 Jul 2010 22:35:01 +0000
Message-ID: <AANLkTimxVUO9UNbv6rgKgiukDbCTzMeaKEAoVD7FAt1T () mail ! gmail ! com>
--------------------
--0022152d7c8f637a5c048c018786
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

On Wed, Jul 21, 2010 at 9:51 AM, Pavel Roskin <proski@gnu.org> wrote:
> Hello!
>
> This test file causes a warning:
>
> typedef short __attribute__((nocast)) u16;
> int main(int argc, char **argv)
> {
> =A0 =A0 =A0 =A0u16 i =3D (u16)argc;
> =A0 =A0 =A0 =A0u16 j =3D (u16)2;
> =A0 =A0 =A0 =A0return (i =3D=3D j);
> }
>
> $ sparse test1.c
> test1.c:6:17: warning: implicit cast from nocast type
> test1.c:6:22: warning: implicit cast from nocast type

The warning come from the implicit cast in the compare
expression. It try to cast "i" and "j" into "int" type before the
compare.

The following patch allow the test-inspect to show the cast
expression.

No patch for the fix yet.

Chris

--0022152d7c8f637a5c048c018786
Content-Type: application/octet-stream; name="inspect-cast.patch"
Content-Disposition: attachment; filename="inspect-cast.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_gby5n9k10

ZGlmZiAtLWdpdCBhL2FzdC1pbnNwZWN0LmMgYi9hc3QtaW5zcGVjdC5jCmluZGV4IDI5MzMzNGUu
LjUzNjNkZTMgMTAwNjQ0Ci0tLSBhL2FzdC1pbnNwZWN0LmMKKysrIGIvYXN0LWluc3BlY3QuYwpA
QCAtNjYsNiArNjYsMTIgQEAgdm9pZCBpbnNwZWN0X3N0YXRlbWVudChBc3ROb2RlICpub2RlKQog
CQkJYXN0X2FwcGVuZF9jaGlsZChub2RlLCAicG9zdF9zdGF0ZW1lbnQ6Iiwgc3RtdC0+aXRlcmF0
b3JfcG9zdF9zdGF0ZW1lbnQsCiAJCQkJCSBpbnNwZWN0X3N0YXRlbWVudCk7CiAJCQlicmVhazsK
KworCQljYXNlIFNUTVRfUkVUVVJOOgorCQkJYXN0X2FwcGVuZF9jaGlsZChub2RlLCAicmV0X3Zh
bHVlOiIsIHN0bXQtPnJldF92YWx1ZSwgaW5zcGVjdF9leHByZXNzaW9uKTsKKwkJCWFzdF9hcHBl
bmRfY2hpbGQobm9kZSwgInJldF90YXJnZXQ6Iiwgc3RtdC0+cmV0X3RhcmdldCwgaW5zcGVjdF9z
eW1ib2wpOworCQkJYnJlYWs7CisKIAkJZGVmYXVsdDoKIAkJCWJyZWFrOwogCX0KQEAgLTEwOSw3
ICsxMTUsNyBAQCB2b2lkIGluc3BlY3Rfc3ltYm9sKEFzdE5vZGUgKm5vZGUpCiB7CiAJc3RydWN0
IHN5bWJvbCAqc3ltID0gbm9kZS0+cHRyOwogCW5vZGUtPnRleHQgPSBnX3N0cmR1cF9wcmludGYo
IiVzICVzOiAlcyIsIG5vZGUtPnRleHQsIHN5bWJvbF90eXBlX25hbWUoc3ltLT50eXBlKSwKLQkJ
CQkgICAgICBzaG93X2lkZW50KHN5bS0+aWRlbnQpKTsKKwkJCQkgICAgICBidWlsdGluX3R5cGVu
YW1lKHN5bSkgPzogc2hvd19pZGVudChzeW0tPmlkZW50KSk7CiAJYXN0X2FwcGVuZF9jaGlsZChu
b2RlLCAiY3R5cGUuYmFzZV90eXBlOiIsIHN5bS0+Y3R5cGUuYmFzZV90eXBlLGluc3BlY3Rfc3lt
Ym9sKTsKIAogCXN3aXRjaCAoc3ltLT50eXBlKSB7CkBAIC0xODEsNiArMTg3LDE4IEBAIHZvaWQg
aW5zcGVjdF9leHByZXNzaW9uKEFzdE5vZGUgKm5vZGUpCiAJCQlhc3RfYXBwZW5kX2NoaWxkKG5v
ZGUsICJsZWZ0OiIsIGV4cHItPmxlZnQsIGluc3BlY3RfZXhwcmVzc2lvbik7CiAJCQlhc3RfYXBw
ZW5kX2NoaWxkKG5vZGUsICJyaWdodDoiLCBleHByLT5yaWdodCwgaW5zcGVjdF9leHByZXNzaW9u
KTsKIAkJCWJyZWFrOworCisJCWNhc2UgRVhQUl9DQVNUOgorCQljYXNlIEVYUFJfRk9SQ0VfQ0FT
VDoKKwkJY2FzZSBFWFBSX0lNUExJRURfQ0FTVDoKKwkJCWFzdF9hcHBlbmRfY2hpbGQobm9kZSwg
ImNhc3RfdHlwZToiLCBleHByLT5jYXN0X3R5cGUsIGluc3BlY3Rfc3ltYm9sKTsKKwkJCWFzdF9h
cHBlbmRfY2hpbGQobm9kZSwgImNhc3RfZXhwcmVzc2lvbjoiLCBleHByLT5jYXN0X2V4cHJlc3Np
b24sIGluc3BlY3RfZXhwcmVzc2lvbik7CisJCQlicmVhazsKKworCQljYXNlIEVYUFJfUFJFT1A6
CisJCQlhc3RfYXBwZW5kX2NoaWxkKG5vZGUsICJ1bm9wOiIsIGV4cHItPnVub3AsIGluc3BlY3Rf
ZXhwcmVzc2lvbik7CisJCQlicmVhazsKKwkJCiAJCWRlZmF1bHQ6CiAJCQlicmVhazsKIAl9Cg==
--0022152d7c8f637a5c048c018786--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Confirm Receipt ===

From: "Nilva Re Poppi" <npoppi () nin ! ufms ! br>
To: linux-sparse
Subject: Confirm Receipt
Date: Mon, 13 Dec 2010 13:30:11 +0000
Message-ID: <20101213132956.M60590 () nin ! ufms ! br>
--------------------
Good Day.
Power-Horse Energy Drink Company,this e-mail is to inform you that,your Email
ID has won you the sum of $540,000.00 US Dollars  on our online draws contact
us via email: powerhorseclearingpaymenthouse@gmail.com  Phone: +44 704-571-6072

Yours Sincerely, 
Nilva Re Poppi
(Online Coordinator).
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Congratulations - Promo Winner ===

From: "MICROSOFT EMAIL PROMOTION" <information () microsoft ! com>
To: linux-sparse
Subject: Congratulations - Promo Winner
Date: Tue, 02 Nov 2010 06:38:28 +0000
Message-ID: <57916.220.101.190.178.1288679908.squirrel () 220 ! 101 ! 190 ! 178>
--------------------
Congratulations - Promo Winner

The MICROSOFT EMAIL PROMO TEAM is glad to announce that
after a successful completion of the PROMO DRAWS held on the
1st November 2010, your e-mail address,attached to winning
numbers:(11) (80) (12)(96) (09) (43) won in the Tenth
lottery category.

You have therefore been approved to claim a total sum of
£450,000,00 Pounds Sterling in cash credited to REF NO:MICRO-L/2009-END10.

All participants were selected through our Microsoft computer
ballot system drawn from 167,000 Names,as part of our
International  "E-MAIL" Promotion Program for our prominent
MS-WORD users all over the world and for the continuous use
of the internet. You are advised to contact the claims
processor with the details below via his e-mail address :

NAME:  Glenn Bradley
EMAIL: mrglenn_bradley01@yahoo.com.hk

PLEASE NOTE YOU ARE TO SEND THE FOLLOWING INFORMATION TO CLAIM YOUR PRIZE:
1.Full Name:... 2.Address:... 3.Phone:... 4.Country:... 5.Sex/Gender:...


YOURS SINCERELY,
RACHEL STEWART.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Defect in linearization of short circuit && ===

From: =?UTF-8?B?SmFjZWsgxZpsaXdlcnNraQ==?= <sliwers () googlemail ! com>
To: linux-sparse
Subject: Defect in linearization of short circuit &&
Date: Sun, 14 Feb 2010 13:39:27 +0000
Message-ID: <4B77FD0F.50401 () googlemail ! com>
--------------------
This is a multi-part message in MIME format.
--------------060905080506010208080305
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit

I am attaching a small sample of code that triggers an issue with the 
linearization of &&.  Consider the condition within the parser_check 
function.  If st == NULL, then no more checks should be performed; the 
execution flow should immediately be directed to the "else" branch. 
However, if you output linearized version (e.g. by using "example" 
program), you will notice that it only skips the second check.

Could you help me investigate this issue?

I am using the latest sparse version from git.

Thank you!
Jacek


--------------060905080506010208080305
Content-Type: text/x-csrc;
 name="parser_check.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="parser_check.c"

struct st {
        int value;
        struct st *other;
};

static void
execute_a (struct st *st, int i)
{
}

static void
execute_b (struct st *st)
{
}

static void
parser_check (struct st *st, int i)
{
        if (st && st->other && st->value > i && i > 0){
                execute_a (st, i);
        } else {
                execute_b (st);
        }
}

--------------060905080506010208080305--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?B?SmFjZWsgxZpsaXdlcnNraQ==?= <sliwers () googlemail ! com>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Sun, 14 Feb 2010 21:04:29 +0000
Message-ID: <4B78655D.2080007 () googlemail ! com>
--------------------
Apparently, the issue is not with the linearization.  I noticed that the 
condition has been parsed as:

EXPR_BINOP
  * EXPR_LOGICAL
     * EXPR_LOGICAL
        * EXPR_PREOP
        * EXPR_PREOP
     * EXPR_COMPARE
  * EXPR_COMPARE

After replacing EXPR_BINOP with EXPR_LOGICAL in the top node of the 
tree, the linearization works just fine.  Could someone explain me the 
difference between EXPR_BINOP and EXPR_LOGICAL in this context?

Thanks!
Jacek
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?B?SmFjZWsgxZpsaXdlcnNraQ==?= <sliwers () googlemail ! com>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Mon, 15 Feb 2010 19:12:38 +0000
Message-ID: <4B799CA6.70807 () googlemail ! com>
--------------------
Christopher Li pisze:
> 
> EXPR_BINOP used in normal operation require two operands.
> e.g.  a + b, a | b
> Both operands will get evaluated.
> 
> EXPR_LOGICAL using for condition branching and it has the short curcit
> behavior in mind. e.g. a || b

I found the offending block of code.  It is in expand.c, in function 
expand_logical:

       /*
        * If the right side is safe and cheaper than a branch,
        * just avoid the branch and turn it into a regular binop
        * style SAFELOGICAL.
        */
       if (rcost < BRANCH_COST) {
               expr->type = EXPR_BINOP;
               rcost -= BRANCH_COST - 1;
       }

After removing these lines, everything works fine.

But I guess that there must have been a reason to add them in the first 
place.  I see it checking the cost of the operation, but I don't know 
why somebody assumes that it would be safe not to make a branch. Does 
anybody know how to fix it without simply removing these lines?

Thanks!
Jacek
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?B?SmFjZWsgxZpsaXdlcnNraQ==?= <sliwers () googlemail ! com>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Mon, 15 Feb 2010 20:18:11 +0000
Message-ID: <4B79AC03.4010608 () googlemail ! com>
--------------------
Christopher Li pisze:
> 
> That is an optimization from Linus. It basically find out the simple variable
> case comparing variable and turn it into binary operations and avoiding the
> branch. It is cheaper to use "setne" than "cmp; jne; mov;".
> 
> It is safe because all the unsafe operations, e.g. dereferencing memory,
> should have set the cost high enough to avoid this optimization.
> e.g. all local variable dereferencing should be safe, because the address
> is in the stack.
> 
> Deferencing a pointer is not, so sparse will not optimize it.

Please, check my case.  The condition is:

if (st && st->other && st->value > i && i > 0)...

Obviously, if st is NULL, then the execution should be transferred 
immediately to the else branch.  But it does not.  It skips the second 
test and goes directly to the third one: st->value > i.  If a compiler 
was built with sparse as a frontend, execution of the generated code 
would end up with a segmentation fault.  And this code is perfectly valid.

So either it is an issue with the costs or it is an issue with the 
linearization.

Anyway, I believe that this case is worth fixing.
Jacek

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () petrovitsch ! priv ! at>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Tue, 16 Feb 2010 09:28:02 +0000
Message-ID: <1266312482.3433.33.camel () thorin>
--------------------
On Mon, 2010-02-15 at 13:11 -0800, Christopher Li wrote:
> 2010/2/15 Jacek Åliwerski <sliwers@googlemail.com>:
> >
> > Please, check my case.  The condition is:
> 
> I did, I did not see any thing wrong with it.
> 
> >
> > if (st && st->other && st->value > i && i > 0)...
> >
> > Obviously, if st is NULL, then the execution should be transferred
> > immediately to the else branch.  But it does not.  It skips the second test
> > and goes directly to the third one: st->value > i.  If a compiler was built
> > with sparse as a frontend, execution of the generated code would end up with
> > a segmentation fault.  And this code is perfectly valid.
> 
> I totally agree the source code is valid.
> I just haven't see the seg fault part.
> 
> $ ./test-linearize parser_check.c
> parser_check:
> .L0x7f4e12de3130:
> 	<entry-point>
> 	br          %arg1, .L0x7f4e12de32e0, .L0x7f4e12de3250
I assume this means "if %arg1 == NULL goto .L0x7f4e12de32e0 else goto .L0x7f4e12de3250"

> .L0x7f4e12de32e0:
> 	load.32     %r3 <- 4[%arg1]
> 	br          %r3, .L0x7f4e12de3208, .L0x7f4e12de3250
> 
> .L0x7f4e12de3208:
> 	load.32     %r5 <- 0[%arg1]
> 	setgt.32    %r7 <- %r5, %arg2
> 	phisrc.1    %phi1 <- %r7
> 	br          .L0x7f4e12de3298
> 
> .L0x7f4e12de3250:
I assume this is the "i > 0" check.
> 	phisrc.1    %phi2 <- $0
> 	br          .L0x7f4e12de3298
> 
> .L0x7f4e12de3298:
> 	phi.1       %r8 <- %phi1, %phi2
> 	setgt.32    %r10 <- %arg2, $0
> 	and-bool.1  %r11 <- %r8, %r10
> 	br          %r11, .L0x7f4e12de3178, .L0x7f4e12de31c0
> 
> .L0x7f4e12de3178:
> 	call        execute_a, %arg1, %arg2
> 	br          .L0x7f4e12de3328
> 
> .L0x7f4e12de31c0:
> 	call        execute_b, %arg1
> 	br          .L0x7f4e12de3328
> 
> .L0x7f4e12de3328:
> 	ret
> 
> In the fast test, the false branch is L0x7f4e12de3250.
> Which is doing the (i > 0) part and it is safe to do so.
Are saying that he "i >0 " test done while "st == NULL"?
This is actually wrong as it shouldn't be done (independent of the used
variables and especially if the expression has side effects).

> It skip the two load.32 operation. It will not generate the seg fault.
> I still don't see where the is seg fault part. Please let me know if I am
> missing some thing obvious.

Or am I missing something (presumbly) obvious?

	Bernd
-- 
Bernd Petrovitsch                  Email : bernd@petrovitsch.priv.at
                     LUGA : http://www.luga.at

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Tue, 16 Feb 2010 19:02:40 +0000
Message-ID: <70318cbf1002161102n63995222o914299dd358f594d () mail ! gmail ! com>
--------------------
On Tue, Feb 16, 2010 at 1:28 AM, Bernd Petrovitsch
<bernd@petrovitsch.priv.at> wrote:
>> $ ./test-linearize parser_check.c
>> parser_check:
>> .L0x7f4e12de3130:
>>       <entry-point>
>>       br          %arg1, .L0x7f4e12de32e0, .L0x7f4e12de3250
> I assume this means "if %arg1 == NULL goto .L0x7f4e12de32e0 else goto .L0x7f4e12de3250"

That is right.

> I assume this is the "i > 0" check.

No, this is the not the i > 0 check yet. This is setting the expression value
of the false branch to 0.

>>       phisrc.1    %phi2 <- $0
>>       br          .L0x7f4e12de3298
>>
>> .L0x7f4e12de3298:
>>       phi.1       %r8 <- %phi1, %phi2
>>       setgt.32    %r10 <- %arg2, $0

This is the "i > 0" check. (%arg2 is "i")

>>       and-bool.1  %r11 <- %r8, %r10
>>       br          %r11, .L0x7f4e12de3178, .L0x7f4e12de31c0
>>
>> .L0x7f4e12de3178:
>>       call        execute_a, %arg1, %arg2
>>       br          .L0x7f4e12de3328
>>
>> In the fast test, the false branch is L0x7f4e12de3250.
>> Which is doing the (i > 0) part and it is safe to do so.

> Are saying that he "i >0 " test done while "st == NULL"?
> This is actually wrong as it shouldn't be done (independent of the used
> variables and especially if the expression has side effects).

That is right. "i > 0" is still being tested.

Consider this example. The same source code and be compile into two
different piece of machine code. They produce the exact same result.
The one with this optimization runs faster than the other one. Do you still
thing that is wrong? How about x86 CPU internally re-ordering the instruction,
is that wrong too?

So I think as long as this behavior is *internal* and *correct*. It is fine.
Of course it'd better be faster as well. Otherwise, what is the point.

The goal of the this optimization is trading the branch instruction
with cheaper arithmetic instruction.

For modern CPU, the branch instruction is likely more expensive
than normal arithmetic instruction. In X86, branch instruction *might*
flush the instruction pipe line while arithmetic operation can usually done
in one cycle.

That is why this optimization is using a cost model. If the left hand
side cost is lower than the branch instruction cost, and it is *safe* to
do so. It turn the branch instruction into arithmetic instruction.

However, in this case, the optimization did not consider this expression
is used in the if statement, and if statement has build-in branch instruction
associate with it. So this optimization might not worthy while here.

But for this expression:

a = st && st->foo && st->bar && i > 0;

This optimization might be worth while.

If the optimization produce incorrect result. That is fatal and that
is a serious bug.
I just want to confirm that is no the case here.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?B?SmFjZWsgxZpsaXdlcnNraQ==?= <sliwers () googlemail ! com>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Tue, 16 Feb 2010 19:19:59 +0000
Message-ID: <4B7AEFDF.3000608 () googlemail ! com>
--------------------
I understand your point and I agree that the optimization might make 
sense.  The problem is that my version of sparse gives different results.

parser_check:
.L0xb7ef00ac:
	<entry-point>
	br          %arg1, .L0xb7ef019c, ****.L0xb7ef014c****

.L0xb7ef019c:
	load.32     %r3 <- 4[%arg1]
	br          %r3, .L0xb7ef0124, .L0xb7ef014c

.L0xb7ef0124:
	phisrc.1    %phi1 <- $0
	br          .L0xb7ef0174

****.L0xb7ef014c:****
	load.32     %r5 <- 0[%arg1]
	setgt.32    %r7 <- %r5, %arg2
	phisrc.1    %phi2 <- %r7
	br          .L0xb7ef0174

.L0xb7ef0174:
	phi.1       %r8 <- %phi1, %phi2
	setgt.32    %r10 <- %arg2, $0
	and-bool.1  %r11 <- %r8, %r10
	br          %r11, .L0xb7ef00d4, .L0xb7ef00fc

.L0xb7ef00d4:
	call        execute_a, %arg1, %arg2
	br          .L0xb7ef01c4

.L0xb7ef00fc:
	call        execute_b, %arg1
	br          .L0xb7ef01c4

.L0xb7ef01c4:
	ret

Above, you can see that the execution will segfault within the label 
.L0xb7ef014c, on load 0[%arg1].

So my question is: do you have any code that is not committed to 
git.kernel.org?

Jacek
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () petrovitsch ! priv ! at>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Wed, 17 Feb 2010 11:47:38 +0000
Message-ID: <1266407258.11294.194.camel () thorin>
--------------------
On Die, 2010-02-16 at 11:02 -0800, Christopher Li wrote:
> On Tue, Feb 16, 2010 at 1:28 AM, Bernd Petrovitsch
> <bernd@petrovitsch.priv.at> wrote:
> >> $ ./test-linearize parser_check.c
> >> parser_check:
> >> .L0x7f4e12de3130:
> >>       <entry-point>
> >>       br          %arg1, .L0x7f4e12de32e0, .L0x7f4e12de3250
> > I assume this means "if %arg1 == NULL goto .L0x7f4e12de32e0 else goto .L0x7f4e12de3250"
> 
> That is right.
> 
> > I assume this is the "i > 0" check.
> 
> No, this is the not the i > 0 check yet. This is setting the expression value
> of the false branch to 0.
> 
> >>       phisrc.1    %phi2 <- $0
> >>       br          .L0x7f4e12de3298
> >>
> >> .L0x7f4e12de3298:
> >>       phi.1       %r8 <- %phi1, %phi2
> >>       setgt.32    %r10 <- %arg2, $0
> 
> This is the "i > 0" check. (%arg2 is "i")
> 
> >>       and-bool.1  %r11 <- %r8, %r10
> >>       br          %r11, .L0x7f4e12de3178, .L0x7f4e12de31c0
> >>
> >> .L0x7f4e12de3178:
> >>       call        execute_a, %arg1, %arg2
> >>       br          .L0x7f4e12de3328
> >>
> >> In the fast test, the false branch is L0x7f4e12de3250.
> >> Which is doing the (i > 0) part and it is safe to do so.
> 
> > Are saying that he "i >0 " test done while "st == NULL"?
> > This is actually wrong as it shouldn't be done (independent of the used
> > variables and especially if the expression has side effects).
> 
> That is right. "i > 0" is still being tested.
> 
> Consider this example. The same source code and be compile into two
> different piece of machine code. They produce the exact same result.
> The one with this optimization runs faster than the other one. Do you still
> thing that is wrong? How about x86 CPU internally re-ordering the instruction,
No. The above is the conceptual point of view as it's the definition
(for the C programming language).
As long as the outside observed behaviour is as if the "i > 0" (in this
example) has never been executed (IOW: any side effect didn't show up),
it's correct.
"Speculative execution" works that way.
> is that wrong too?
As long as the program behaves as if it did not happen, it' correct. So
calculating all conditions in parallel is IMHO fine as long as any
"writeback operation" (which are outside relevant) happen if and only if
the conditions were "true" (in the above example).

> So I think as long as this behavior is *internal* and *correct*. It is fine.
I think we are actually in violent agreement. I got the impression that
this was a general strategy (and not where all parts of the && sequence
are side-effect free).

> Of course it'd better be faster as well. Otherwise, what is the point.
Yup.

> The goal of the this optimization is trading the branch instruction
> with cheaper arithmetic instruction.
> 
> For modern CPU, the branch instruction is likely more expensive
> than normal arithmetic instruction. In X86, branch instruction *might*
> flush the instruction pipe line while arithmetic operation can usually done
> in one cycle.
> 
> That is why this optimization is using a cost model. If the left hand
> side cost is lower than the branch instruction cost, and it is *safe* to
> do so. It turn the branch instruction into arithmetic instruction.
> 
> However, in this case, the optimization did not consider this expression
> is used in the if statement, and if statement has build-in branch instruction
> associate with it. So this optimization might not worthy while here.
> 
> But for this expression:
> 
> a = st && st->foo && st->bar && i > 0;
> 
> This optimization might be worth while.
ACK. But this example has no side effect (assuming no preprocessor
trickery, no "volatile" somewhere relevant, etc.) so it' not
"dangerous".
Above I was talking about the general case.

> If the optimization produce incorrect result. That is fatal and that
> is a serious bug.
> I just want to confirm that is no the case here.

	Bernd
-- 
Bernd Petrovitsch                  Email : bernd@petrovitsch.priv.at
                     LUGA : http://www.luga.at

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Defect in linearization of short circuit &&
Date: Wed, 17 Feb 2010 20:22:12 +0000
Message-ID: <70318cbf1002171222p652692eerc3aa0f31f69dbe6b () mail ! gmail ! com>
--------------------
On Wed, Feb 17, 2010 at 3:47 AM, Bernd Petrovitsch
<bernd@petrovitsch.priv.at> wrote:
>>
>> But for this expression:
>>
>> a = st && st->foo && st->bar && i > 0;
>>
>> This optimization might be worth while.
> ACK. But this example has no side effect (assuming no preprocessor
> trickery, no "volatile" somewhere relevant, etc.) so it' not
> "dangerous".
> Above I was talking about the general case.
Then we are in agreement.

Sparse actually go the extra mile to make sure the expression is
safe. So whenever the expression has side effects or unsafe, it set the cost
of the expression prohibitively high.

E.g:
expand_dereference() return UNSAFE because the expression can segfault.
expand_call() return SIDE_EFFECT.

So if there is a bug cause the some unsafe optimization. We just just fix the
bug instead of disable the optimization.

It is harder to do this optimization in the linearized instructions because
the linearized instruction does not have the expression boundary any more.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: L'\0' handling ===

From: Yura Pakhuchiy <pakhuchiy () gmail ! com>
To: linux-sparse
Subject: L'\0' handling
Date: Thu, 08 Apr 2010 14:59:59 +0000
Message-ID: <1270738799.2167.7.camel () yura-tl>
--------------------
Hi,

It looks like sparse do not understand constructions like L'\0'.

.-(~)------------------------------------------------------------(yura@yura-tl)-
`--> cat b.c
int main(void)
{
	L'\0';
	return 0;
}
.-(~)------------------------------------------------------------(yura@yura-tl)-
`--> gcc b.c
.-(~)------------------------------------------------------------(yura@yura-tl)-
`--> cgcc b.c
b.c:3:10: error: Expected ; at end of statement
b.c:3:10: error: got `\0'
b.c:3:9: error: undefined identifier `L'

This causes problems with /usr/include/wchar.h
and  /usr/include/bits/wchar.h includes from ubuntu.

/usr/include/bits/wchar.h:38:8: error: garbage at end: `\0' - 1 > 0

/usr/include/wchar.h:393:51: error: Expected ) in expression
/usr/include/wchar.h:393:51: error: got `\0'

Relevant lines from these headers:

extern int __wctob_alias (wint_t __c) __asm ("wctob");
__extern_inline int
__NTH (wctob (wint_t __wc))
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
	  ? (int) __wc : __wctob_alias (__wc)); }

and

#ifdef __WCHAR_UNSIGNED__
#define __WCHAR_MIN       L'\0'

/* Failing that, rely on the preprocessor's knowledge of the
   signedness of wchar_t.  */
#elif L'\0' - 1 > 0
#define __WCHAR_MIN       L'\0'
#else
#define __WCHAR_MIN       (-__WCHAR_MAX - 1)
#endif


-- 
Best regards,
        Yura

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Thu, 08 Apr 2010 15:22:40 +0000
Message-ID: <4BBDF4C0.8020305 () redhat ! com>
--------------------
Hello,

Yura Pakhuchiy wrote:
> It looks like sparse do not understand constructions like L'\0'.
yepp, it doesn't. I have run into that problem 2 years ago. But for Wine
that is actually a "feature" as wide char/string literals are forbidden
aka cannot be used. Thus my interest in adding support for that in
sparse died.

bye
	michael

> 
> .-(~)------------------------------------------------------------(yura@yura-tl)-
> `--> cat b.c
> int main(void)
> {
> 	L'\0';
> 	return 0;
> }
> .-(~)------------------------------------------------------------(yura@yura-tl)-
> `--> gcc b.c
> .-(~)------------------------------------------------------------(yura@yura-tl)-
> `--> cgcc b.c
> b.c:3:10: error: Expected ; at end of statement
> b.c:3:10: error: got `\0'
> b.c:3:9: error: undefined identifier `L'
> 
> This causes problems with /usr/include/wchar.h
> and  /usr/include/bits/wchar.h includes from ubuntu.
> 
> /usr/include/bits/wchar.h:38:8: error: garbage at end: `\0' - 1 > 0
> 
> /usr/include/wchar.h:393:51: error: Expected ) in expression
> /usr/include/wchar.h:393:51: error: got `\0'
> 
> Relevant lines from these headers:
> 
> extern int __wctob_alias (wint_t __c) __asm ("wctob");
> __extern_inline int
> __NTH (wctob (wint_t __wc))
> { return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
> 	  ? (int) __wc : __wctob_alias (__wc)); }
> 
> and
> 
> #ifdef __WCHAR_UNSIGNED__
> #define __WCHAR_MIN       L'\0'
> 
> /* Failing that, rely on the preprocessor's knowledge of the
>    signedness of wchar_t.  */
> #elif L'\0' - 1 > 0
> #define __WCHAR_MIN       L'\0'
> #else
> #define __WCHAR_MIN       (-__WCHAR_MAX - 1)
> #endif
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Yura Pakhuchiy <pakhuchiy () gmail ! com>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Thu, 08 Apr 2010 15:39:32 +0000
Message-ID: <1270741172.2167.9.camel () yura-tl>
--------------------
Ð£ Ð§ÑÐ², 08/04/2010 Ñ 17:22 +0200, Michael Stefaniuc Ð¿ÑÑÐ°:
> Yura Pakhuchiy wrote:
> > It looks like sparse do not understand constructions like L'\0'.
> yepp, it doesn't. I have run into that problem 2 years ago. But for Wine
> that is actually a "feature" as wide char/string literals are forbidden
> aka cannot be used. Thus my interest in adding support for that in
> sparse died.

Wine is not the only project which uses sparse. Sparse is broken for any
userspace program which includes wchar.h in Ubuntu with out supporting
this.

-- 
Best regards,
        Yura

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Thu, 08 Apr 2010 20:19:56 +0000
Message-ID: <r2q70318cbf1004081319yc4bf61ccw252798cb98bc760b () mail ! gmail ! com>
--------------------
--00151757748401806d0483bf67c0
Content-Type: text/plain; charset=ISO-8859-1

On Thu, Apr 8, 2010 at 8:54 AM, Michael Stefaniuc <mstefani@redhat.com> wrote:
> I didn't assert that the feature shouldn't be implemented, just that it
> is a known missing feature that the normal sparse consumer didn't need
> until now.

Yura, do you want to give this patch a try?

It is nasty that L'\0' start from an identifier letter. I try my best
not to slow down the
hot path. The test is done inside get_one_identifier() after the ident
hash is built.
It look a little bit out of palace but faster than testing 'L' before hand.

Chris

--00151757748401806d0483bf67c0
Content-Type: application/octet-stream; name="0005-Allow-parsing-L-0.patch"
Content-Disposition: attachment; filename="0005-Allow-parsing-L-0.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_g7s2g73s0

RnJvbSA2YzhkOTE2OWViZTgxOThkOGI5OTQ4MjVjZTlkNGViMWI3MzM5MTI5IE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBUaHUsIDggQXByIDIwMTAgMTQ6MDU6MjkgLTA3MDAKU3ViamVjdDogW1BBVENIIDUvNV0g
QWxsb3cgcGFyc2luZyBMJ1wwJwoKU2lnbmVkLW9mZi1ieTogQ2hyaXN0b3BoZXIgTGkgPHNwYXJz
ZUBjaHJpc2xpLm9yZz4KLS0tCiBleHByZXNzaW9uLmMgIHwgICAgMyArKy0KIGlkZW50LWxpc3Qu
aCAgfCAgICAzICsrKwogcHJlLXByb2Nlc3MuYyB8ICAgIDEgKwogdG9rZW4uaCAgICAgICB8ICAg
IDEgKwogdG9rZW5pemUuYyAgICB8ICAgMTIgKysrKysrKystLS0tCiA1IGZpbGVzIGNoYW5nZWQs
IDE1IGluc2VydGlvbnMoKyksIDUgZGVsZXRpb25zKC0pCgpkaWZmIC0tZ2l0IGEvZXhwcmVzc2lv
bi5jIGIvZXhwcmVzc2lvbi5jCmluZGV4IGM5Mjc3ZGEuLjY3ZTA1ZTcgMTAwNjQ0Ci0tLSBhL2V4
cHJlc3Npb24uYworKysgYi9leHByZXNzaW9uLmMKQEAgLTM5Nyw5ICszOTcsMTAgQEAgc3RydWN0
IHRva2VuICpwcmltYXJ5X2V4cHJlc3Npb24oc3RydWN0IHRva2VuICp0b2tlbiwgc3RydWN0IGV4
cHJlc3Npb24gKip0cmVlKQogCiAJc3dpdGNoICh0b2tlbl90eXBlKHRva2VuKSkgewogCWNhc2Ug
VE9LRU5fQ0hBUjoKKwljYXNlIFRPS0VOX0xPTkdfQ0hBUjoKIAkJZXhwciA9IGFsbG9jX2V4cHJl
c3Npb24odG9rZW4tPnBvcywgRVhQUl9WQUxVRSk7ICAgCiAJCWV4cHItPmZsYWdzID0gSW50X2Nv
bnN0X2V4cHI7Ci0JCWV4cHItPmN0eXBlID0gJmludF9jdHlwZTsgCisJCWV4cHItPmN0eXBlID0g
dG9rZW5fdHlwZSh0b2tlbikgPT0gVE9LRU5fQ0hBUiA/ICZpbnRfY3R5cGUgOiAmbG9uZ19jdHlw
ZTsKIAkJZXhwci0+dmFsdWUgPSAodW5zaWduZWQgY2hhcikgdG9rZW4tPmNoYXJhY3RlcjsKIAkJ
dG9rZW4gPSB0b2tlbi0+bmV4dDsKIAkJYnJlYWs7CmRpZmYgLS1naXQgYS9pZGVudC1saXN0Lmgg
Yi9pZGVudC1saXN0LmgKaW5kZXggMGVlODFiYy4uYjk0YWVjZSAxMDA2NDQKLS0tIGEvaWRlbnQt
bGlzdC5oCisrKyBiL2lkZW50LWxpc3QuaApAQCAtMjUsNiArMjUsOSBAQCBJREVOVChfX2F0dHJp
YnV0ZSk7IElERU5UKF9fYXR0cmlidXRlX18pOwogSURFTlQodm9sYXRpbGUpOyBJREVOVChfX3Zv
bGF0aWxlKTsgSURFTlQoX192b2xhdGlsZV9fKTsKIElERU5UKGRvdWJsZSk7CiAKKy8qIFNwZWNp
YWwgY2FzZSBmb3IgTCdcdCcgKi8KK0lERU5UKEwpOworCiAvKiBFeHRlbmRlZCBnY2MgaWRlbnRp
ZmllcnMgKi8KIElERU5UKGFzbSk7IElERU5UX1JFU0VSVkVEKF9fYXNtKTsgSURFTlRfUkVTRVJW
RUQoX19hc21fXyk7CiBJREVOVChhbGlnbm9mKTsgSURFTlRfUkVTRVJWRUQoX19hbGlnbm9mKTsg
SURFTlRfUkVTRVJWRUQoX19hbGlnbm9mX18pOyAKZGlmZiAtLWdpdCBhL3ByZS1wcm9jZXNzLmMg
Yi9wcmUtcHJvY2Vzcy5jCmluZGV4IDM0YjIxZmYuLjA1OGYyNGIgMTAwNjQ0Ci0tLSBhL3ByZS1w
cm9jZXNzLmMKKysrIGIvcHJlLXByb2Nlc3MuYwpAQCAtODY0LDYgKzg2NCw3IEBAIHN0YXRpYyBp
bnQgdG9rZW5fZGlmZmVyZW50KHN0cnVjdCB0b2tlbiAqdDEsIHN0cnVjdCB0b2tlbiAqdDIpCiAJ
CWRpZmZlcmVudCA9IHQxLT5hcmdudW0gIT0gdDItPmFyZ251bTsKIAkJYnJlYWs7CiAJY2FzZSBU
T0tFTl9DSEFSOgorCWNhc2UgVE9LRU5fTE9OR19DSEFSOgogCQlkaWZmZXJlbnQgPSB0MS0+Y2hh
cmFjdGVyICE9IHQyLT5jaGFyYWN0ZXI7CiAJCWJyZWFrOwogCWNhc2UgVE9LRU5fU1RSSU5HOiB7
CmRpZmYgLS1naXQgYS90b2tlbi5oIGIvdG9rZW4uaAppbmRleCBlYmM5NGI0Li5jNTI3ZTc4IDEw
MDY0NAotLS0gYS90b2tlbi5oCisrKyBiL3Rva2VuLmgKQEAgLTY3LDYgKzY3LDcgQEAgZW51bSB0
b2tlbl90eXBlIHsKIAlUT0tFTl9aRVJPX0lERU5ULAogCVRPS0VOX05VTUJFUiwKIAlUT0tFTl9D
SEFSLAorCVRPS0VOX0xPTkdfQ0hBUiwKIAlUT0tFTl9TVFJJTkcsCiAJVE9LRU5fU1BFQ0lBTCwK
IAlUT0tFTl9TVFJFQU1CRUdJTiwKZGlmZiAtLWdpdCBhL3Rva2VuaXplLmMgYi90b2tlbml6ZS5j
CmluZGV4IDkzZGQwMDcuLmNmMDU4MjYgMTAwNjQ0Ci0tLSBhL3Rva2VuaXplLmMKKysrIGIvdG9r
ZW5pemUuYwpAQCAtMTQ1LDcgKzE0NSw4IEBAIGNvbnN0IGNoYXIgKnNob3dfdG9rZW4oY29uc3Qg
c3RydWN0IHRva2VuICp0b2tlbikKIAljYXNlIFRPS0VOX1NQRUNJQUw6CiAJCXJldHVybiBzaG93
X3NwZWNpYWwodG9rZW4tPnNwZWNpYWwpOwogCi0JY2FzZSBUT0tFTl9DSEFSOiB7CisJY2FzZSBU
T0tFTl9DSEFSOiAKKwljYXNlIFRPS0VOX0xPTkdfQ0hBUjogewogCQljaGFyICpwdHIgPSBidWZm
ZXI7CiAJCWludCBjID0gdG9rZW4tPmNoYXJhY3RlcjsKIAkJKnB0cisrID0gJ1wnJzsKQEAgLTUy
Nyw3ICs1MjgsNyBAQCBzdGF0aWMgaW50IGVzY2FwZWNoYXIoaW50IGZpcnN0LCBpbnQgdHlwZSwg
c3RyZWFtX3QgKnN0cmVhbSwgaW50ICp2YWxwKQogCXJldHVybiBuZXh0OwogfQogCi1zdGF0aWMg
aW50IGdldF9jaGFyX3Rva2VuKGludCBuZXh0LCBzdHJlYW1fdCAqc3RyZWFtKQorc3RhdGljIGlu
dCBnZXRfY2hhcl90b2tlbihpbnQgbmV4dCwgc3RyZWFtX3QgKnN0cmVhbSwgZW51bSB0b2tlbl90
eXBlIHR5cGUpCiB7CiAJaW50IHZhbHVlOwogCXN0cnVjdCB0b2tlbiAqdG9rZW47CkBAIC01NDAs
NyArNTQxLDcgQEAgc3RhdGljIGludCBnZXRfY2hhcl90b2tlbihpbnQgbmV4dCwgc3RyZWFtX3Qg
KnN0cmVhbSkKIAl9CiAKIAl0b2tlbiA9IHN0cmVhbS0+dG9rZW47Ci0JdG9rZW5fdHlwZSh0b2tl
bikgPSBUT0tFTl9DSEFSOworCXRva2VuX3R5cGUodG9rZW4pID0gdHlwZTsKIAl0b2tlbi0+Y2hh
cmFjdGVyID0gdmFsdWUgJiAweGZmOwogCiAJYWRkX3Rva2VuKHN0cmVhbSk7CkBAIC03MDIsNyAr
NzAzLDcgQEAgc3RhdGljIGludCBnZXRfb25lX3NwZWNpYWwoaW50IGMsIHN0cmVhbV90ICpzdHJl
YW0pCiAJY2FzZSAnIic6CiAJCXJldHVybiBnZXRfc3RyaW5nX3Rva2VuKG5leHQsIHN0cmVhbSk7
CiAJY2FzZSAnXCcnOgotCQlyZXR1cm4gZ2V0X2NoYXJfdG9rZW4obmV4dCwgc3RyZWFtKTsKKwkJ
cmV0dXJuIGdldF9jaGFyX3Rva2VuKG5leHQsIHN0cmVhbSwgVE9LRU5fQ0hBUik7CiAJY2FzZSAn
Lyc6CiAJCWlmIChuZXh0ID09ICcvJykKIAkJCXJldHVybiBkcm9wX3N0cmVhbV9lb2xuKHN0cmVh
bSk7CkBAIC04ODAsNiArODgxLDkgQEAgc3RhdGljIGludCBnZXRfb25lX2lkZW50aWZpZXIoaW50
IGMsIHN0cmVhbV90ICpzdHJlYW0pCiAKIAlpZGVudCA9IGNyZWF0ZV9oYXNoZWRfaWRlbnQoYnVm
LCBsZW4sIGhhc2gpOwogCisJaWYgKGlkZW50ID09ICZMX2lkZW50ICYmIG5leHQgPT0gJ1wnJykK
KwkJcmV0dXJuIGdldF9jaGFyX3Rva2VuKG5leHRjaGFyKHN0cmVhbSksIHN0cmVhbSwgVE9LRU5f
TE9OR19DSEFSKTsKKwogCS8qIFBhc3MgaXQgb24uLiAqLwogCXRva2VuID0gc3RyZWFtLT50b2tl
bjsKIAl0b2tlbl90eXBlKHRva2VuKSA9IFRPS0VOX0lERU5UOwotLSAKMS42LjYuMQoK
--00151757748401806d0483bf67c0--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Thu, 08 Apr 2010 20:46:10 +0000
Message-ID: <g2p70318cbf1004081346t11dc0507u28f148c8b0706513 () mail ! gmail ! com>
--------------------
On Thu, Apr 8, 2010 at 1:33 PM, Yura Pakhuchiy <pakhuchiy@gmail.com> wrote:
> Hi Chris,
>
> Ð£ Ð§ÑÐ², 08/04/2010 Ñ 13:19 -0700, Christopher Li Ð¿ÑÑÐ°:
>> Yura, do you want to give this patch a try?
>
> Works great for me! Fixed all problems with wchar.h related includes.
> Thanks!

Great. Change pushed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Thu, 08 Apr 2010 23:18:39 +0000
Message-ID: <i2q70318cbf1004081618j1d677d34q438c89f715515520 () mail ! gmail ! com>
--------------------
On Thu, Apr 8, 2010 at 1:58 PM, Michael Stefaniuc <mstefani@redhat.com> wrote:
>
> I have looked at the patch but I don't see it handle wchar_t string literals
> like L"Hello World\n".

That is on purpose. L"Hello worlds" is very questionable.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Fri, 09 Apr 2010 20:07:16 +0000
Message-ID: <s2m70318cbf1004091307q1f1ec7a6h679452199c9cbf06 () mail ! gmail ! com>
--------------------
On Fri, Apr 9, 2010 at 1:57 AM, Michael Stefaniuc <mstefani@redhat.com> wrote:
> Christopher Li wrote:
>> On Thu, Apr 8, 2010 at 1:58 PM, Michael Stefaniuc <mstefani@redhat.com> wrote:
>>> I have looked at the patch but I don't see it handle wchar_t string literals
>>> like L"Hello World\n".
>>
>> That is on purpose. L"Hello worlds" is very questionable.
> Huh? Care to explain this one? That is a valid wide char string literal
> in C and sparse doesn't support those. I don't see much point in
> supporting only wide char literals and not the wide char string literals.

Ah, silly me. I did not realized the nature of this change is to support wide
char literals. Just look up what wide char string literals is, now I
have a better
idea. You are right. We should support both. My previous patch is wrong
to set the type of wide char string as "long" type.

So L"hello word\n" pointer are incompatible with char * pointer right?
And the wchar_t is implementation specific. I am wondering should I just
pick 16 bit or 32 bit in sparse. Maybe just make it compatible with what
gcc does.

Obviously, it need more patches to support wide char string literals.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Fri, 09 Apr 2010 20:28:55 +0000
Message-ID: <4BBF8E07.5030306 () redhat ! com>
--------------------
On 04/09/2010 10:07 PM, Christopher Li wrote:
> On Fri, Apr 9, 2010 at 1:57 AM, Michael Stefaniuc<mstefani@redhat.com>  wrote:
>> Christopher Li wrote:
>>> On Thu, Apr 8, 2010 at 1:58 PM, Michael Stefaniuc<mstefani@redhat.com>  wrote:
>>>> I have looked at the patch but I don't see it handle wchar_t string literals
>>>> like L"Hello World\n".
>>>
>>> That is on purpose. L"Hello worlds" is very questionable.
>> Huh? Care to explain this one? That is a valid wide char string literal
>> in C and sparse doesn't support those. I don't see much point in
>> supporting only wide char literals and not the wide char string literals.
>
> Ah, silly me. I did not realized the nature of this change is to support wide
> char literals. Just look up what wide char string literals is, now I
> have a better
> idea. You are right. We should support both. My previous patch is wrong
> to set the type of wide char string as "long" type.
>
> So L"hello word\n" pointer are incompatible with char * pointer right?
Yes, they are incompatible.

> And the wchar_t is implementation specific. I am wondering should I just
> pick 16 bit or 32 bit in sparse. Maybe just make it compatible with what
> gcc does.
I know only about Windows that has 16bit wide chars; the rest seems to 
be all 32bit.

gcc supports -fshort-wchar to have the wide chars be 16bit; primary 
consumer of that is mingw; for probably everything else it is useless.

> Obviously, it need more patches to support wide char string literals.
Yeah, that's what I remember from having looked back then at sparse. 
Luckily the correct fix for Wine was to remove the wide char literals :)

bye
	michael
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: L'\0' handling
Date: Fri, 18 Jun 2010 00:30:40 +0000
Message-ID: <AANLkTikeLwjc-OKk-tVGqRoz2uaf0MVzWJJSFWMinETM () mail ! gmail ! com>
--------------------
--0016363b916492cc6a0489431002
Content-Type: text/plain; charset=ISO-8859-1

On Fri, Apr 9, 2010 at 1:28 PM, Michael Stefaniuc <mstefani@redhat.com> wrote:
>> Ah, silly me. I did not realized the nature of this change is to support
>> wide
>> char literals. Just look up what wide char string literals is, now I
>> have a better
>> idea. You are right. We should support both. My previous patch is wrong
>> to set the type of wide char string as "long" type.
>>
>> So L"hello word\n" pointer are incompatible with char * pointer right?
>
> Yes, they are incompatible.

A blast from the past. I found this patch while I am cleaning up my
tree. Totally forget about it already.

At least it should parse the L"hello world" now.
Make the base type correct is more work though.

Chris

--0016363b916492cc6a0489431002
Content-Type: application/octet-stream; 
	name="0001-Parsing-wide-char-string.patch"
Content-Disposition: attachment; 
	filename="0001-Parsing-wide-char-string.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_gaka73zw0

RnJvbSA0OWFkZjExYjk5Y2ZjZTA0ZGRjYWU3YmUwYTI3MmNjMmRmMzE0MzZkIE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBUaHUsIDE3IEp1biAyMDEwIDE3OjA4OjA5IC0wNzAwClN1YmplY3Q6IFtQQVRDSCAxLzRd
IFBhcnNpbmcgd2lkZSBjaGFyIHN0cmluZwoKQSBmb2xsb3cgdXAgY2hhbmdlIHRvIHBhcnNlIHRo
ZSB3aWRlIGNoYXIgc3RyaW5nLgpJdCBjdXJyZW50bHkgb25seSBwYXJzZSBhbmQgc3RvcmUgaXQg
bGlrZSBub3JtYWwgc3RyaW5ncy4KTmVlZCBtb3JlIGNoYW5nZSB0byByZWZsZWN0IHRoZSBiYXNl
IHR5cGUgYW5kIHNpemUgZXRjLgoKU2lnbmVkLW9mZi1ieTogQ2hyaXN0b3BoZXIgTGkgPHNwYXJz
ZUBjaHJpc2xpLm9yZz4KLS0tCiBleHByZXNzaW9uLmMgIHwgICAxMyArKysrKysrKy0tLS0tCiBl
eHByZXNzaW9uLmggIHwgICAgNSArKysrLQogcHJlLXByb2Nlc3MuYyB8ICAgIDUgKysrLS0KIHRv
a2VuLmggICAgICAgfCAgICAzICsrLQogdG9rZW5pemUuYyAgICB8ICAgMTcgKysrKysrKysrKyst
LS0tLS0KIDUgZmlsZXMgY2hhbmdlZCwgMjggaW5zZXJ0aW9ucygrKSwgMTUgZGVsZXRpb25zKC0p
CgpkaWZmIC0tZ2l0IGEvZXhwcmVzc2lvbi5jIGIvZXhwcmVzc2lvbi5jCmluZGV4IDY3ZTA1ZTcu
LjdlMDZlNjAgMTAwNjQ0Ci0tLSBhL2V4cHJlc3Npb24uYworKysgYi9leHByZXNzaW9uLmMKQEAg
LTIyNCwxNyArMjI0LDE4IEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKnN0cmluZ19leHByZXNzaW9u
KHN0cnVjdCB0b2tlbiAqdG9rZW4sIHN0cnVjdCBleHByZXNzaW9uICplCiB7CiAJc3RydWN0IHN0
cmluZyAqc3RyaW5nID0gdG9rZW4tPnN0cmluZzsKIAlzdHJ1Y3QgdG9rZW4gKm5leHQgPSB0b2tl
bi0+bmV4dDsKKwlpbnQgc3RyaW5ndHlwZSA9IHRva2VuX3R5cGUodG9rZW4pOwogCiAJY29udmVy
dF9mdW5jdGlvbih0b2tlbik7CiAKLQlpZiAodG9rZW5fdHlwZShuZXh0KSA9PSBUT0tFTl9TVFJJ
TkcpIHsKKwlpZiAodG9rZW5fdHlwZShuZXh0KSA9PSBzdHJpbmd0eXBlKSB7CiAJCWludCB0b3Rs
ZW4gPSBzdHJpbmctPmxlbmd0aC0xOwogCQljaGFyICpkYXRhOwogCiAJCWRvIHsKIAkJCXRvdGxl
biArPSBuZXh0LT5zdHJpbmctPmxlbmd0aC0xOwogCQkJbmV4dCA9IG5leHQtPm5leHQ7Ci0JCX0g
d2hpbGUgKHRva2VuX3R5cGUobmV4dCkgPT0gVE9LRU5fU1RSSU5HKTsKKwkJfSB3aGlsZSAodG9r
ZW5fdHlwZShuZXh0KSA9PSBzdHJpbmd0eXBlKTsKIAogCQlpZiAodG90bGVuID4gTUFYX1NUUklO
RykgewogCQkJd2FybmluZyh0b2tlbi0+cG9zLCAidHJ5aW5nIHRvIGNvbmNhdGVuYXRlICVkLWNo
YXJhY3RlciBzdHJpbmcgKCVkIGJ5dGVzIG1heCkiLCB0b3RsZW4sIE1BWF9TVFJJTkcpOwpAQCAt
MjU2LDcgKzI1Nyw3IEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKnN0cmluZ19leHByZXNzaW9uKHN0
cnVjdCB0b2tlbiAqdG9rZW4sIHN0cnVjdCBleHByZXNzaW9uICplCiAJCQluZXh0ID0gbmV4dC0+
bmV4dDsKIAkJCW1lbWNweShkYXRhLCBzLT5kYXRhLCBsZW4pOwogCQkJZGF0YSArPSBsZW47Ci0J
CX0gd2hpbGUgKHRva2VuX3R5cGUobmV4dCkgPT0gVE9LRU5fU1RSSU5HKTsKKwkJfSB3aGlsZSAo
dG9rZW5fdHlwZShuZXh0KSA9PSBzdHJpbmd0eXBlKTsKIAkJKmRhdGEgPSAnXDAnOwogCX0KIAll
eHByLT5zdHJpbmcgPSBzdHJpbmc7CkBAIC0zOTcsNyArMzk4LDcgQEAgc3RydWN0IHRva2VuICpw
cmltYXJ5X2V4cHJlc3Npb24oc3RydWN0IHRva2VuICp0b2tlbiwgc3RydWN0IGV4cHJlc3Npb24g
Kip0cmVlKQogCiAJc3dpdGNoICh0b2tlbl90eXBlKHRva2VuKSkgewogCWNhc2UgVE9LRU5fQ0hB
UjoKLQljYXNlIFRPS0VOX0xPTkdfQ0hBUjoKKwljYXNlIFRPS0VOX1dJREVfQ0hBUjoKIAkJZXhw
ciA9IGFsbG9jX2V4cHJlc3Npb24odG9rZW4tPnBvcywgRVhQUl9WQUxVRSk7ICAgCiAJCWV4cHIt
PmZsYWdzID0gSW50X2NvbnN0X2V4cHI7CiAJCWV4cHItPmN0eXBlID0gdG9rZW5fdHlwZSh0b2tl
bikgPT0gVE9LRU5fQ0hBUiA/ICZpbnRfY3R5cGUgOiAmbG9uZ19jdHlwZTsKQEAgLTQ2NCw5ICs0
NjUsMTEgQEAgc3RydWN0IHRva2VuICpwcmltYXJ5X2V4cHJlc3Npb24oc3RydWN0IHRva2VuICp0
b2tlbiwgc3RydWN0IGV4cHJlc3Npb24gKip0cmVlKQogCQlicmVhazsKIAl9CiAKLQljYXNlIFRP
S0VOX1NUUklORzogeworCWNhc2UgVE9LRU5fU1RSSU5HOgorCWNhc2UgVE9LRU5fV0lERV9TVFJJ
Tkc6IHsKIAloYW5kbGVfc3RyaW5nOgogCQlleHByID0gYWxsb2NfZXhwcmVzc2lvbih0b2tlbi0+
cG9zLCBFWFBSX1NUUklORyk7CisJCWV4cHItPndpZGUgPSB0b2tlbl90eXBlKHRva2VuKSA9PSBU
T0tFTl9XSURFX1NUUklORzsKIAkJdG9rZW4gPSBzdHJpbmdfZXhwcmVzc2lvbih0b2tlbiwgZXhw
cik7CiAJCWJyZWFrOwogCX0KZGlmZiAtLWdpdCBhL2V4cHJlc3Npb24uaCBiL2V4cHJlc3Npb24u
aAppbmRleCA2MzEyMjRmLi45Nzc4ZGU4IDEwMDY0NAotLS0gYS9leHByZXNzaW9uLmgKKysrIGIv
ZXhwcmVzc2lvbi5oCkBAIC03Niw3ICs3NiwxMCBAQCBzdHJ1Y3QgZXhwcmVzc2lvbiB7CiAJCWxv
bmcgZG91YmxlIGZ2YWx1ZTsKIAogCQkvLyBFWFBSX1NUUklORwotCQlzdHJ1Y3Qgc3RyaW5nICpz
dHJpbmc7CisJCXN0cnVjdCB7CisJCQlpbnQgd2lkZTsKKwkJCXN0cnVjdCBzdHJpbmcgKnN0cmlu
ZzsKKwkJfTsKIAogCQkvLyBFWFBSX1VOT1AsIEVYUFJfUFJFT1AgYW5kIEVYUFJfUE9TVE9QCiAJ
CXN0cnVjdCAvKiB1bm9wICovIHsKZGlmZiAtLWdpdCBhL3ByZS1wcm9jZXNzLmMgYi9wcmUtcHJv
Y2Vzcy5jCmluZGV4IDA1OGYyNGIuLjY1NmFjYWEgMTAwNjQ0Ci0tLSBhL3ByZS1wcm9jZXNzLmMK
KysrIGIvcHJlLXByb2Nlc3MuYwpAQCAtODY0LDEwICs4NjQsMTEgQEAgc3RhdGljIGludCB0b2tl
bl9kaWZmZXJlbnQoc3RydWN0IHRva2VuICp0MSwgc3RydWN0IHRva2VuICp0MikKIAkJZGlmZmVy
ZW50ID0gdDEtPmFyZ251bSAhPSB0Mi0+YXJnbnVtOwogCQlicmVhazsKIAljYXNlIFRPS0VOX0NI
QVI6Ci0JY2FzZSBUT0tFTl9MT05HX0NIQVI6CisJY2FzZSBUT0tFTl9XSURFX0NIQVI6CiAJCWRp
ZmZlcmVudCA9IHQxLT5jaGFyYWN0ZXIgIT0gdDItPmNoYXJhY3RlcjsKIAkJYnJlYWs7Ci0JY2Fz
ZSBUT0tFTl9TVFJJTkc6IHsKKwljYXNlIFRPS0VOX1NUUklORzoKKwljYXNlIFRPS0VOX1dJREVf
U1RSSU5HOiB7CiAJCXN0cnVjdCBzdHJpbmcgKnMxLCAqczI7CiAKIAkJczEgPSB0MS0+c3RyaW5n
OwpkaWZmIC0tZ2l0IGEvdG9rZW4uaCBiL3Rva2VuLmgKaW5kZXggYzUyN2U3OC4uYTdlYzc3ZSAx
MDA2NDQKLS0tIGEvdG9rZW4uaAorKysgYi90b2tlbi5oCkBAIC02Nyw4ICs2Nyw5IEBAIGVudW0g
dG9rZW5fdHlwZSB7CiAJVE9LRU5fWkVST19JREVOVCwKIAlUT0tFTl9OVU1CRVIsCiAJVE9LRU5f
Q0hBUiwKLQlUT0tFTl9MT05HX0NIQVIsCisJVE9LRU5fV0lERV9DSEFSLAogCVRPS0VOX1NUUklO
RywKKwlUT0tFTl9XSURFX1NUUklORywKIAlUT0tFTl9TUEVDSUFMLAogCVRPS0VOX1NUUkVBTUJF
R0lOLAogCVRPS0VOX1NUUkVBTUVORCwKZGlmZiAtLWdpdCBhL3Rva2VuaXplLmMgYi90b2tlbml6
ZS5jCmluZGV4IGNmMDU4MjYuLjRjOTc1MTcgMTAwNjQ0Ci0tLSBhL3Rva2VuaXplLmMKKysrIGIv
dG9rZW5pemUuYwpAQCAtMTM3LDYgKzEzNyw3IEBAIGNvbnN0IGNoYXIgKnNob3dfdG9rZW4oY29u
c3Qgc3RydWN0IHRva2VuICp0b2tlbikKIAkJcmV0dXJuIHNob3dfaWRlbnQodG9rZW4tPmlkZW50
KTsKIAogCWNhc2UgVE9LRU5fU1RSSU5HOgorCWNhc2UgVE9LRU5fV0lERV9TVFJJTkc6CiAJCXJl
dHVybiBzaG93X3N0cmluZyh0b2tlbi0+c3RyaW5nKTsKIAogCWNhc2UgVE9LRU5fTlVNQkVSOgpA
QCAtMTQ2LDcgKzE0Nyw3IEBAIGNvbnN0IGNoYXIgKnNob3dfdG9rZW4oY29uc3Qgc3RydWN0IHRv
a2VuICp0b2tlbikKIAkJcmV0dXJuIHNob3dfc3BlY2lhbCh0b2tlbi0+c3BlY2lhbCk7CiAKIAlj
YXNlIFRPS0VOX0NIQVI6IAotCWNhc2UgVE9LRU5fTE9OR19DSEFSOiB7CisJY2FzZSBUT0tFTl9X
SURFX0NIQVI6IHsKIAkJY2hhciAqcHRyID0gYnVmZmVyOwogCQlpbnQgYyA9IHRva2VuLT5jaGFy
YWN0ZXI7CiAJCSpwdHIrKyA9ICdcJyc7CkBAIC01NDgsNyArNTQ5LDcgQEAgc3RhdGljIGludCBn
ZXRfY2hhcl90b2tlbihpbnQgbmV4dCwgc3RyZWFtX3QgKnN0cmVhbSwgZW51bSB0b2tlbl90eXBl
IHR5cGUpCiAJcmV0dXJuIG5leHRjaGFyKHN0cmVhbSk7CiB9CiAKLXN0YXRpYyBpbnQgZ2V0X3N0
cmluZ190b2tlbihpbnQgbmV4dCwgc3RyZWFtX3QgKnN0cmVhbSkKK3N0YXRpYyBpbnQgZ2V0X3N0
cmluZ190b2tlbihpbnQgbmV4dCwgc3RyZWFtX3QgKnN0cmVhbSwgZW51bSB0b2tlbl90eXBlIHR5
cGUpCiB7CiAJc3RhdGljIGNoYXIgYnVmZmVyW01BWF9TVFJJTkddOwogCXN0cnVjdCBzdHJpbmcg
KnN0cmluZzsKQEAgLTU4MSw3ICs1ODIsNyBAQCBzdGF0aWMgaW50IGdldF9zdHJpbmdfdG9rZW4o
aW50IG5leHQsIHN0cmVhbV90ICpzdHJlYW0pCiAKIAkvKiBQYXNzIGl0IG9uLi4gKi8KIAl0b2tl
biA9IHN0cmVhbS0+dG9rZW47Ci0JdG9rZW5fdHlwZSh0b2tlbikgPSBUT0tFTl9TVFJJTkc7CisJ
dG9rZW5fdHlwZSh0b2tlbikgPSB0eXBlOwogCXRva2VuLT5zdHJpbmcgPSBzdHJpbmc7CiAJYWRk
X3Rva2VuKHN0cmVhbSk7CiAJCkBAIC03MDEsNyArNzAyLDcgQEAgc3RhdGljIGludCBnZXRfb25l
X3NwZWNpYWwoaW50IGMsIHN0cmVhbV90ICpzdHJlYW0pCiAJCQlyZXR1cm4gZ2V0X29uZV9udW1i
ZXIoYywgbmV4dCwgc3RyZWFtKTsKIAkJYnJlYWs7CiAJY2FzZSAnIic6Ci0JCXJldHVybiBnZXRf
c3RyaW5nX3Rva2VuKG5leHQsIHN0cmVhbSk7CisJCXJldHVybiBnZXRfc3RyaW5nX3Rva2VuKG5l
eHQsIHN0cmVhbSwgVE9LRU5fU1RSSU5HKTsKIAljYXNlICdcJyc6CiAJCXJldHVybiBnZXRfY2hh
cl90b2tlbihuZXh0LCBzdHJlYW0sIFRPS0VOX0NIQVIpOwogCWNhc2UgJy8nOgpAQCAtODgxLDgg
Kzg4MiwxMiBAQCBzdGF0aWMgaW50IGdldF9vbmVfaWRlbnRpZmllcihpbnQgYywgc3RyZWFtX3Qg
KnN0cmVhbSkKIAogCWlkZW50ID0gY3JlYXRlX2hhc2hlZF9pZGVudChidWYsIGxlbiwgaGFzaCk7
CiAKLQlpZiAoaWRlbnQgPT0gJkxfaWRlbnQgJiYgbmV4dCA9PSAnXCcnKQotCQlyZXR1cm4gZ2V0
X2NoYXJfdG9rZW4obmV4dGNoYXIoc3RyZWFtKSwgc3RyZWFtLCBUT0tFTl9MT05HX0NIQVIpOwor
CWlmIChpZGVudCA9PSAmTF9pZGVudCkgeworCQlpZiAobmV4dCA9PSAnXCcnKQorCQkJcmV0dXJu
IGdldF9jaGFyX3Rva2VuKG5leHRjaGFyKHN0cmVhbSksIHN0cmVhbSwgVE9LRU5fV0lERV9DSEFS
KTsKKwkJaWYgKG5leHQgPT0gJ1wiJykKKwkJCXJldHVybiBnZXRfc3RyaW5nX3Rva2VuKG5leHRj
aGFyKHN0cmVhbSksIHN0cmVhbSwgVE9LRU5fV0lERV9TVFJJTkcpOworCX0KIAogCS8qIFBhc3Mg
aXQgb24uLiAqLwogCXRva2VuID0gc3RyZWFtLT50b2tlbjsKLS0gCjEuNi42LjEKCg==
--0016363b916492cc6a0489431002--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Manufacturers Database - 1,057,119 records with 476,509 emails ===

From: "Maxine acyclic" <adam () smtp ! hq ! iskhus ! co ! za>
To: linux-sparse
Subject: Manufacturers Database - 1,057,119 records with 476,509 emails
Date: Fri, 18 Jun 2010 00:36:48 +0000
Message-ID: <BABE7BF0-0916-4421-8A19-8FEF1810ED9A () smtp ! hq ! iskhus ! co ! za>
--------------------
I have many different good quality lists from various sources. The prices are relatively low as well. Drop me a line here:  Andrea.Fischer@listgenius.info
I'll get you all the details and samples. 
  


to get off please email disappear@listgenius.info

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Mental Health Counselors - 283,184 records 7,206 emails ===

From: edelweiss Dill
To: linux-sparse
Subject: Mental Health Counselors - 283,184 records 7,206 emails
Date: Thu, 29 Apr 2010 16:55:24 +0000
Message-ID: <e324aede-6112-4bf4-a838-7d2f00795e66 () CAPS01 ! caps-domain ! local>
--------------------
Here's a couple of our healthcare list packages on sale this week only:

Package 1

Alternative Medicine - 1,141,602 total records with 36,320 emails and 38.935 fax numbers
Massage Therapists - 76,701 records and 8,305 emails
Physical Therapists - 125,460 total records with 5,483 emails and 4,405 fax numbers

All complete lists above: $277

Package 2

Chiropractors - 108,421 total records * 3,414 emails * 6,553 fax numbers
Acupuncturists - 23,988 records 1,826 emails
Massage Therapists - 76,701 records and 8,305 emails

All complete lists above: $247

There are more packages and not just for healthcare contact me here for more info or to get samples: Petra.Talbot@goodlists.co.cc

  


Send email to disappear@goodlists.co.cc to ensure no further communication
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Physicians (34 specialties) - 788k records, 17k emails, 200k fax numbers ===

From: "Veronica Russell" <fourteenthirty1430 () gmail ! com>
To: linux-sparse
Subject: Physicians (34 specialties) - 788k records, 17k emails, 200k fax numbers
Date: Wed, 10 Mar 2010 06:18:43 +0000
Message-ID: <1268197739101511473 () mailserver>
--------------------
I have alot of good quality American Databases at decent prices. Contact me here:  Valentin.Mcelroy@superlistmarket.net for a complete catalog of what we have.

 
  


Forward email to rembox@superlistmarket.net to purge you from our records
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Psychologists - 272,188 records and 9,874 emails ===

From: "Jess T Corbett" <frankjohnson () 64 ! 27 ! 26 ! 70>
To: linux-sparse
Subject: Psychologists - 272,188 records and 9,874 emails
Date: Mon, 24 May 2010 14:17:28 +0000
Message-ID: <201005241403617.SM01048 () toni>
--------------------
Here's some of the healthcare lists we have:

Veterinarians - 78,986 total records with 1,438  emails and 1,050  fax numbers
National Health Service Corp Clinics - 1,300 total records with emails for government run free clinics
Medical Equipment Suppliers - 167,425 total records with 6,940 emails and 5,812 fax numbers
Optometrists - 63,837 records 2,015 emails

Theres many more too, just send me an email here for additional info/samples: Nellie.Reilly@inspiresuccess.in

  


Forward email to disappear@inspiresuccess.in to purge you from our records
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Registration of NGO for a Grant,contact me for more details. ===

From: NGO REGISTRATION <fieldofficer () tudor ! org>
To: linux-sparse
Subject: Registration of NGO for a Grant,contact me for more details.
Date: Sun, 07 Nov 2010 17:53:47 +0000
Message-ID: <0LBJ00KY70FYLGD0 () mmp2 ! hacettepe ! edu ! tr>
--------------------
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Small patch for __builtin_fabs and an attribute ===

From: Morten Welinder <mortenw () gnome ! org>
To: linux-sparse
Subject: Small patch for __builtin_fabs and an attribute
Date: Sat, 10 Jul 2010 03:15:04 +0000
Message-ID: <AANLkTilLz1Tgfnf8nwvocJeX5B2bpBG5ZzObHdNKF_ee () mail ! gmail ! com>
--------------------
FYI.


diff --git a/lib.c b/lib.c
index a218bfc..7f0b524 100644
--- a/lib.c
+++ b/lib.c
@@ -716,6 +716,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long __builtin_alpha_inslh(long, long);\n");
 	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 	add_pre_buffer("extern long __builtin_labs(long);\n");
+	add_pre_buffer("extern double __builtin_fabs(double);\n");

 	/* And some floating point stuff.. */
 	add_pre_buffer("extern int __builtin_isgreater(float, float);\n");
diff --git a/parse.c b/parse.c
index f81b19f..0645538 100644
--- a/parse.c
+++ b/parse.c
@@ -515,6 +515,8 @@ const char *ignored_attributes[] = {
 	"__format_arg__",
 	"hot",
 	"__hot__",
+	"may_alias",
+	"__may_alias__",
 	"malloc",
 	"__malloc__",
 	"model",
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Small patch for __builtin_fabs and an attribute
Date: Tue, 13 Jul 2010 07:33:36 +0000
Message-ID: <AANLkTilt83WWkm4wJnfLZucaKbHF8AZj-aoU2aMDZehY () mail ! gmail ! com>
--------------------
On Fri, Jul 9, 2010 at 8:15 PM, Morten Welinder <mortenw@gnome.org> wrote:
> FYI.
>
>
> diff --git a/lib.c b/lib.c
> index a218bfc..7f0b524 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -716,6 +716,7 @@ void declare_builtin_functions(void)
>        add_pre_buffer("extern long __builtin_alpha_inslh(long, long);\n");
>        add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
>        add_pre_buffer("extern long __builtin_labs(long);\n");
> +       add_pre_buffer("extern double __builtin_fabs(double);\n");
>
>        /* And some floating point stuff.. */
>        add_pre_buffer("extern int __builtin_isgreater(float, float);\n");
> diff --git a/parse.c b/parse.c
> index f81b19f..0645538 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -515,6 +515,8 @@ const char *ignored_attributes[] = {
>        "__format_arg__",
>        "hot",
>        "__hot__",
> +       "may_alias",
> +       "__may_alias__",
>        "malloc",
>        "__malloc__",
>        "model",

Hi Morten,

I forget one thing. Can you signed off your patch?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse crash when mixing int and enum in ternary operator ===

From: Pavel Roskin <proski () gnu ! org>
To: linux-sparse
Subject: Re: Sparse crash when mixing int and enum in ternary operator
Date: Tue, 30 Mar 2010 05:29:59 +0000
Message-ID: <1269926999.6838.177.camel () mj>
--------------------
On Mon, 2010-03-29 at 21:23 +0200, Kamil Dudka wrote:

> Sure, I don't object it anyhow.  As a C++ programmer I've certainly different 
> attitude to type safety, thus biased.  I believe kernel developers would more 
> likely agree with your point of view.

If you run patched sparse on the kernel and fix the first ten warnings
in a nice, unobtrusive way, and there is no warning that you cannot fix,
chances are that the kernel developers will like your changes, even if
it makes the code look more like C++ or even Java :-)

If the fixes involve casts or conversion of enum types to integers or a
serious code reorganization, then perhaps the kernel developers won't
like your changes.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Spurious symbol 'foo' was not declared ===

From: Morten Welinder <mortenw () gnome ! org>
To: linux-sparse
Subject: Spurious symbol 'foo' was not declared
Date: Sun, 18 Jul 2010 20:16:37 +0000
Message-ID: <AANLkTikqtMvb3fdg4aKR1KStEBhg1yDM-0YpR0VGHtiT () mail ! gmail ! com>
--------------------
I think sparse issues a spurious warning about "static" for this program.
Right?

Morten

static void foo (int);
void foo (int a) { }

welinder@anemone:~> cgcc -Wall -c sss.c
sss.c:2:6: warning: symbol 'foo' was not declared. Should it be static?
sss.c:2: warning: foo defined but not used
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: Spurious symbol 'foo' was not declared
Date: Sun, 18 Jul 2010 20:35:43 +0000
Message-ID: <20100718203542.GA3665 () feather>
--------------------
On Sun, Jul 18, 2010 at 04:16:37PM -0400, Morten Welinder wrote:
> I think sparse issues a spurious warning about "static" for this program.
> Right?
> 
> Morten
> 
> static void foo (int);
> void foo (int a) { }
> 
> welinder@anemone:~> cgcc -Wall -c sss.c
> sss.c:2:6: warning: symbol 'foo' was not declared. Should it be static?
> sss.c:2: warning: âfooâ defined but not used

The second warning comes from gcc, I think.  But yes, the first warning
represents a long-standing sparse bug; "static" in the prototype doesn't
propagate to the definition.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Warning message when using sparse ===

From: Larry Finger <Larry.Finger () lwfinger ! net>
To: linux-kernel
Subject: Warning message when using sparse
Date: Fri, 09 Jul 2010 01:52:17 +0000
Message-ID: <4C3680D1.5070601 () lwfinger ! net>
--------------------
On recent kernels, sparse reports the following message for every source 
file that is processed. The warning does not seem to affect the results. 
I'm not sure when the problem started, but I think it was with 2.6.35-rc1.


   CHECK   drivers/staging/rtl8712/rtl871x_rf.c
/home/finger/linux-2.6/arch/x86/include/asm/cpufeature.h:297:21: error: 
Expected ( after asm
/home/finger/linux-2.6/arch/x86/include/asm/cpufeature.h:297:21: error: 
got goto


Larry
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Jiri Slaby <jirislaby () gmail ! com>
To: linux-kernel
Subject: Re: Warning message when using sparse
Date: Fri, 09 Jul 2010 20:47:21 +0000
Message-ID: <4C378AD9.1070602 () gmail ! com>
--------------------
On 07/09/2010 03:52 AM, Larry Finger wrote:
> On recent kernels, sparse reports the following message for every source
> file that is processed. The warning does not seem to affect the results.
> I'm not sure when the problem started, but I think it was with 2.6.35-rc1.
> 
> 
>   CHECK   drivers/staging/rtl8712/rtl871x_rf.c
> /home/finger/linux-2.6/arch/x86/include/asm/cpufeature.h:297:21: error:
> Expected ( after asm
> /home/finger/linux-2.6/arch/x86/include/asm/cpufeature.h:297:21: error:
> got goto
> 

Yeah, I posted a support for that already:
http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=summary

The patch is not 100% correct, it doesn't support asm volatile goto and
similar.

What distro you use? I will fix it in opensuse (which provide gcc 4.5
already), if there will be no new release of sparse.

regards,
-- 
js
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Larry Finger <Larry.Finger () lwfinger ! net>
To: linux-kernel
Subject: Re: Warning message when using sparse
Date: Fri, 09 Jul 2010 21:22:43 +0000
Message-ID: <4C379323.1090004 () lwfinger ! net>
--------------------
Obviously, I pulled the wrong git tree. I got the one from the wiki. When 
I built the one from the kernel.org tree, all is well.

Larry

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Larry Finger <Larry.Finger () lwfinger ! net>
To: linux-sparse
Subject: Re: Warning message when using sparse
Date: Fri, 09 Jul 2010 21:22:43 +0000
Message-ID: <4C379323.1090004 () lwfinger ! net>
--------------------
Obviously, I pulled the wrong git tree. I got the one from the wiki. When 
I built the one from the kernel.org tree, all is well.

Larry

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jiri Slaby <jirislaby () gmail ! com>
To: linux-kernel
Subject: Re: Warning message when using sparse
Date: Fri, 09 Jul 2010 21:26:19 +0000
Message-ID: <4C3793FB.4080907 () gmail ! com>
--------------------
On 07/09/2010 11:22 PM, Larry Finger wrote:
> Obviously, I pulled the wrong git tree. I got the one from the wiki.
> When I built the one from the kernel.org tree, all is well.

Both are from kernel.org. But the one I sent is a Chris'es "fork" with
my and other fixes.

-- 
js
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Warning message when using sparse
Date: Fri, 09 Jul 2010 22:04:20 +0000
Message-ID: <AANLkTikFmeXz9og4t98jm6QcAdRa6rIeCAv3oeFnTgd8 () mail ! gmail ! com>
--------------------
On Fri, Jul 9, 2010 at 2:26 PM, Jiri Slaby <jirislaby@gmail.com> wrote:
> On 07/09/2010 11:22 PM, Larry Finger wrote:
>> Obviously, I pulled the wrong git tree. I got the one from the wiki.
>> When I built the one from the kernel.org tree, all is well.
>
> Both are from kernel.org. But the one I sent is a Chris'es "fork" with
> my and other fixes.
>

Yes, you caught me slacking off. It is time to cut a new release
and flush all the bits into the official tree.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: Warning message when using sparse
Date: Fri, 09 Jul 2010 22:04:20 +0000
Message-ID: <AANLkTikFmeXz9og4t98jm6QcAdRa6rIeCAv3oeFnTgd8 () mail ! gmail ! com>
--------------------
On Fri, Jul 9, 2010 at 2:26 PM, Jiri Slaby <jirislaby@gmail.com> wrote:
> On 07/09/2010 11:22 PM, Larry Finger wrote:
>> Obviously, I pulled the wrong git tree. I got the one from the wiki.
>> When I built the one from the kernel.org tree, all is well.
>
> Both are from kernel.org. But the one I sent is a Chris'es "fork" with
> my and other fixes.
>

Yes, you caught me slacking off. It is time to cut a new release
and flush all the bits into the official tree.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [0/4] inspector for sparse ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [0/4] inspector for sparse
Date: Fri, 02 Apr 2010 18:36:45 +0000
Message-ID: <u2n70318cbf1004021136t65b4d8acmf8bfd7e18b410dfe () mail ! gmail ! com>
--------------------
Hi,

When I debug the enum int patch, some times I wish I have a better tools
to help me understand what is going on with the internal sprase data structure.
There is debug_symbol() to help in some degree, but it does not show anything
other than symbol type. E.g. expression and statments.

test-parsing's output is more like assembly rather than a syntax tree.
There is debug_symbol() but it only print out the symbol type. It does not
go into expression. So the interesting stuff like expression  is hard to see.

I want some thing it can display different types of C structure with expandable
sub node for its member. Some thing like a file folder you can expand it see its
content.

I first look at the GtkTreeView. It seems capable of doing what I want.
The interface is cumbersome to use and I am really not a GUI person.
So I build some custom tree model to simplify the interaction with GTK.
That is the first patch in the series.

The second patch of the series try to inspect C structure one at time.
It is driven by the gtk tree model. It use a some glib function but it does
not have any GTK knowledge.

The interface is generic enough that you should be able to do a cursor
version from it without changing the code.

The third patch adds the test-inspect program which launch a gtk window.
Oh, I did not bother to make the first two patches compile itself
until this one.

Please play with it. As always, feed back are welcome.

The C structure inspection is rather incomplete currently. It is very easy to
expand it to show additional types and members. The last patch is an example.
It is going to be very rewarding to extend the inspector. It does not
require you have deep understanding of the sparse AST tree, it helps
*you* to understand how sparse internal AST works.

So patches are very welcome as well. Any one want to help?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [0/4] inspector for sparse
Date: Fri, 02 Apr 2010 18:59:39 +0000
Message-ID: <w2j70318cbf1004021159y2fa50d58y62bd878c6355a972 () mail ! gmail ! com>
--------------------
I add a treeview branch on sparse/chrisl so you can pull from it.

http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=shortlog;h=refs/heads/treeview

In fedora, you need to install gtk2-devel package to enable it.

Chris

On Fri, Apr 2, 2010 at 11:36 AM, Christopher Li <sparse@chrisli.org> wrote:
> Hi,
>
> When I debug the enum int patch, some times I wish I have a better tools
> to help me understand what is going on with the internal sprase data structure.
> There is debug_symbol() to help in some degree, but it does not show anything
> other than symbol type. E.g. expression and statments.
>
> test-parsing's output is more like assembly rather than a syntax tree.
> There is debug_symbol() but it only print out the symbol type. It does not
> go into expression. So the interesting stuff like expression  is hard to see.
>
> I want some thing it can display different types of C structure with expandable
> sub node for its member. Some thing like a file folder you can expand it see its
> content.
>
> I first look at the GtkTreeView. It seems capable of doing what I want.
> The interface is cumbersome to use and I am really not a GUI person.
> So I build some custom tree model to simplify the interaction with GTK.
> That is the first patch in the series.
>
> The second patch of the series try to inspect C structure one at time.
> It is driven by the gtk tree model. It use a some glib function but it does
> not have any GTK knowledge.
>
> The interface is generic enough that you should be able to do a cursor
> version from it without changing the code.
>
> The third patch adds the test-inspect program which launch a gtk window.
> Oh, I did not bother to make the first two patches compile itself
> until this one.
>
> Please play with it. As always, feed back are welcome.
>
> The C structure inspection is rather incomplete currently. It is very easy to
> expand it to show additional types and members. The last patch is an example.
> It is going to be very rewarding to extend the inspector. It does not
> require you have deep understanding of the sparse AST tree, it helps
> *you* to understand how sparse internal AST works.
>
> So patches are very welcome as well. Any one want to help?
>
> Chris
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-sparse
Subject: Re: [0/4] inspector for sparse
Date: Fri, 23 Apr 2010 20:37:51 +0000
Message-ID: <20100423203751.GM29093 () bicker>
--------------------
On Fri, Apr 23, 2010 at 10:30:40PM +0200, Dan Carpenter wrote:
> On Fri, Apr 02, 2010 at 11:59:39AM -0700, Christopher Li wrote:
> > I add a treeview branch on sparse/chrisl so you can pull from it.
> > 
> > http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=shortlog;h=refs/heads/treeview
> > 
> > In fedora, you need to install gtk2-devel package to enable it.
> > 
> > Chris
> 
> This is an really useful program.
> 
> Inline functions don't show up in the list of functions.  Is there a way 
> to inspect these as well?  This is more a general sparse question, since
> smatch doesn't parse inline functions either.

Crap.  I'm dumb.  You actually can click through your program to where the
inline function is called and see it.

Really useful program as I said before.

regards,
dan carpenter

> 
> regards,
> dan carpenter
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [B.A.T.M.A.N.] "wrong count at exit" after spin_lock/_unlock pair ===

From: Sven Eckelmann <sven.eckelmann () gmx ! de>
To: linux-sparse
Subject: Re: [B.A.T.M.A.N.] "wrong count at exit" after spin_lock/_unlock pair
Date: Sat, 30 Oct 2010 19:05:18 +0000
Message-ID: <201010302105.19912.sven.eckelmann () gmx ! de>
--------------------
--nextPart1708996.RN1acd3PlT
Content-Type: Text/Plain;
  charset="us-ascii"
Content-Transfer-Encoding: quoted-printable

Sven Eckelmann wrote:
> Hi,
>=20
> I use sparse (cgcc) with different kernel versions to do some quick checks
> on the batman-adv kernel module. I noticed that my change from UP to SMP
> kernel generated some 'weird' warnings regarding a 'context imbalance'
> which I couldn't find, but went away when switching from spin_(un)lock to
> spin_(un)lock_bh - something which doesn't make sense in my mind.
>=20
> I am not quite sure if this is linux-headers or sparse related - so I try
> to post it here first. I choose 2.6.32 because it is the latest long
> stable kernel and will be used in by Debian Squeeze.

I looked a little more at the problem and it is not a real sparse problem. =
The=20
problem came with bb7bed082500179519c7caf0678ba3bed9752658 and and was=20
corrected with b97c4bc16734a2e597dac7f91ee9eb78f4aeef9a. So patching 2.6.32=
=20
and v2.6.33 by reverting bb7bed082500179519c7caf0678ba3bed9752658 is enough=
=20
for me.

Best regards,
	Sven

--nextPart1708996.RN1acd3PlT
Content-Type: application/pgp-signature; name=signature.asc 
Content-Description: This is a digitally signed message part.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIcBAABCgAGBQJMzGxvAAoJEF2HCgfBJntGNe0P/iugfHRd+2lwEQBHaKZZ/fio
8pQHeaVzLm+ZLfE2syhdRsBRZBVpb0Q7L1pQ9CnDULaIRcwDZbhLRiMp0vO7iVDx
/6myO9xonOykeOAd03z0IID2gLkrGxdkOui3UDic3P6nbEo2DdnSgLc7ZlK3WnJk
33hphLCNiNfBC/rmB7ljpLoJomtyAQSXGCAdVrasi+E8tZOGHXAu13ycBA6Ph6Ln
EbnYfYBec3hblXa9zOP/XE3lEhkV3AfFGwoY4IObEc514eBrcpDdvfkaF+He5KGh
PdS1Y0jsABEEPHADZjXaxFwdM9SQAf2y/dN0SmnzLczpf0sAqtCfFUg3N/qgDbEa
ut4T3h2gljUbN9nOWipXMoWOOBGLM98iaTdvIG2tqWjgk4UzxQzkJe/17l8RYwSl
uwst5PaPkbSnt7m60d02NNaVtiNNYK8BGJPXfW+EqB1x3WN8V9obyqViD+1+Z77T
ZBaea961mtXikFqrNMAgKXjX44IeJxk1EJXdSzyCgcbmNbE6T74g7dLo0ByzyPKY
SGecdPwKZn8mwE9FOnsiw16YvRAIM7EVz4SFhI0xDg3myNVfAddqT5naniEyuQ+J
IJ8LK9V/8ZjqMQCQ7w9Fg5KuqLu20Mvwtg/VyVC7RU2E2BE5xqV64MKXxjrcq/CE
DTWYdK5vpWnjgfPKAOp8
=xJ5J
-----END PGP SIGNATURE-----

--nextPart1708996.RN1acd3PlT--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files ===

From: wellsk40 () gmail ! com
To: linux-arm-kernel
Subject: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 00:11:22 +0000
Message-ID: <1265674295-23996-2-git-send-email-wellsk40 () gmail ! com>
--------------------
From: Kevin Wells <wellsk40@gmail.com>

Initial header files for the LPC32XX architecture

Signed-off-by: Kevin Wells <wellsk40@gmail.com>
---
 arch/arm/mach-lpc32xx/include/mach/board.h      |   23 +
 arch/arm/mach-lpc32xx/include/mach/clkdev.h     |   25 +
 arch/arm/mach-lpc32xx/include/mach/gpio.h       |   74 +++
 arch/arm/mach-lpc32xx/include/mach/hardware.h   |   34 ++
 arch/arm/mach-lpc32xx/include/mach/i2c.h        |   63 ++
 arch/arm/mach-lpc32xx/include/mach/io.h         |   27 +
 arch/arm/mach-lpc32xx/include/mach/irqs.h       |  114 ++++
 arch/arm/mach-lpc32xx/include/mach/memory.h     |   28 +
 arch/arm/mach-lpc32xx/include/mach/platform.h   |  697 +++++++++++++++++++++++
 arch/arm/mach-lpc32xx/include/mach/system.h     |   52 ++
 arch/arm/mach-lpc32xx/include/mach/timex.h      |   29 +
 arch/arm/mach-lpc32xx/include/mach/uncompress.h |   63 ++
 arch/arm/mach-lpc32xx/include/mach/vmalloc.h    |   24 +
 13 files changed, 1253 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-lpc32xx/include/mach/board.h b/arch/arm/mach-lpc32xx/include/mach/board.h
new file mode 100644
index 0000000..30424bc
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/board.h
@@ -0,0 +1,23 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/board.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/clkdev.h b/arch/arm/mach-lpc32xx/include/mach/clkdev.h
new file mode 100644
index 0000000..9bf0637
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/clkdev.h
@@ -0,0 +1,25 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/clkdev.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_CLKDEV_H
+#define __ASM_ARCH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/gpio.h b/arch/arm/mach-lpc32xx/include/mach/gpio.h
new file mode 100644
index 0000000..67d03da
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/gpio.h
@@ -0,0 +1,74 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/gpio.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm-generic/gpio.h>
+
+/*
+ * Note!
+ * Muxed GP pins need to be setup to the GP state in the board level
+ * code prior to using this driver.
+ * GPI pins : 28xP3 group
+ * GPO pins : 24xP3 group
+ * GPIO pins: 8xP0 group, 24xP1 group, 13xP2 group, 6xP3 group
+ */
+
+#define LPC32XX_GPIO_P0_MAX 8
+#define LPC32XX_GPIO_P1_MAX 24
+#define LPC32XX_GPIO_P2_MAX 13
+#define LPC32XX_GPIO_P3_MAX 6
+#define LPC32XX_GPI_P3_MAX 28
+#define LPC32XX_GPO_P3_MAX 24
+
+#define LPC32XX_GPIO_P0_GRP 0
+#define LPC32XX_GPIO_P1_GRP (LPC32XX_GPIO_P0_GRP + LPC32XX_GPIO_P0_MAX)
+#define LPC32XX_GPIO_P2_GRP (LPC32XX_GPIO_P1_GRP + LPC32XX_GPIO_P1_MAX)
+#define LPC32XX_GPIO_P3_GRP (LPC32XX_GPIO_P2_GRP + LPC32XX_GPIO_P2_MAX)
+#define LPC32XX_GPI_P3_GRP (LPC32XX_GPIO_P3_GRP + LPC32XX_GPIO_P3_MAX)
+#define LPC32XX_GPO_P3_GRP (LPC32XX_GPI_P3_GRP + LPC32XX_GPI_P3_MAX)
+
+/*
+ * A specific GPIO can be selected with this macro
+ * ie, GPIO_05 can be selected with LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
+ * See the LPC32x0 User's guide for GPIO group numbers
+ */
+#define LPC32XX_GPIO(x, y) ((x) + (y))
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	__gpio_set_value(gpio, value);
+}
+
+static inline int gpio_cansleep(unsigned gpio)
+{
+	return __gpio_cansleep(gpio);
+}
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+	return __gpio_to_irq(gpio);
+}
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/hardware.h b/arch/arm/mach-lpc32xx/include/mach/hardware.h
new file mode 100644
index 0000000..33e1dde
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/hardware.h
@@ -0,0 +1,34 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/hardware.h
+ *
+ * Copyright (c) 2005 MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/*
+ * Start of virtual addresses for IO devices
+ */
+#define IO_BASE		0xF0000000
+
+/*
+ * This macro relies on fact that for all HW i/o addresses bits 20-23 are 0
+ */
+#define IO_ADDRESS(x)	(((((x) & 0xff000000) >> 4) | ((x) & 0xfffff)) |\
+			 IO_BASE)
+
+#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
+#define io_v2p(x)	((((x) & 0x0ff00000) << 4) | ((x) & 0x000fffff))
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/i2c.h b/arch/arm/mach-lpc32xx/include/mach/i2c.h
new file mode 100644
index 0000000..a2d810b
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/i2c.h
@@ -0,0 +1,63 @@
+/*
+ * PNX4008-specific tweaks for I2C IP3204 block
+ *
+ * Author: Vitaly Wool <vwool@ru.mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef __ASM_ARCH_I2C_H__
+#define __ASM_ARCH_I2C_H__
+
+enum {
+	mstatus_tdi = 0x00000001,
+	mstatus_afi = 0x00000002,
+	mstatus_nai = 0x00000004,
+	mstatus_drmi = 0x00000008,
+	mstatus_active = 0x00000020,
+	mstatus_scl = 0x00000040,
+	mstatus_sda = 0x00000080,
+	mstatus_rff = 0x00000100,
+	mstatus_rfe = 0x00000200,
+	mstatus_tff = 0x00000400,
+	mstatus_tfe = 0x00000800,
+};
+
+enum {
+	mcntrl_tdie = 0x00000001,
+	mcntrl_afie = 0x00000002,
+	mcntrl_naie = 0x00000004,
+	mcntrl_drmie = 0x00000008,
+	mcntrl_daie = 0x00000020,
+	mcntrl_rffie = 0x00000040,
+	mcntrl_tffie = 0x00000080,
+	mcntrl_reset = 0x00000100,
+	mcntrl_cdbmode = 0x00000400,
+};
+
+enum {
+	rw_bit = 1 << 0,
+	start_bit = 1 << 8,
+	stop_bit = 1 << 9,
+};
+
+#define I2C_REG_RX(a)	((a)->ioaddr)		/* Rx FIFO reg (RO) */
+#define I2C_REG_TX(a)	((a)->ioaddr)		/* Tx FIFO reg (WO) */
+#define I2C_REG_STS(a)	((a)->ioaddr + 0x04)	/* Status reg (RO) */
+#define I2C_REG_CTL(a)	((a)->ioaddr + 0x08)	/* Ctl reg */
+#define I2C_REG_CKL(a)	((a)->ioaddr + 0x0c)	/* Clock divider low */
+#define I2C_REG_CKH(a)	((a)->ioaddr + 0x10)	/* Clock divider high */
+#define I2C_REG_ADR(a)	((a)->ioaddr + 0x14)	/* I2C address */
+#define I2C_REG_RFL(a)	((a)->ioaddr + 0x18)	/* Rx FIFO level (RO) */
+#define I2C_REG_TFL(a)	((a)->ioaddr + 0x1c)	/* Tx FIFO level (RO) */
+#define I2C_REG_RXB(a)	((a)->ioaddr + 0x20)	/* Num of bytes Rx-ed (RO) */
+#define I2C_REG_TXB(a)	((a)->ioaddr + 0x24)	/* Num of bytes Tx-ed (RO) */
+#define I2C_REG_TXS(a)	((a)->ioaddr + 0x28)	/* Tx slave FIFO (RO) */
+#define I2C_REG_STFL(a)	((a)->ioaddr + 0x2c)	/* Tx slave FIFO level (RO) */
+
+#define I2C_CHIP_NAME		"PNX4008-I2C"
+
+#endif				/* __ASM_ARCH_I2C_H___ */
diff --git a/arch/arm/mach-lpc32xx/include/mach/io.h b/arch/arm/mach-lpc32xx/include/mach/io.h
new file mode 100644
index 0000000..9b59ab5
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/io.h
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/io.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT	0xffffffff
+
+#define __io(a)		__typesafe_io(a)
+#define __mem_pci(a)	(a)
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/irqs.h b/arch/arm/mach-lpc32xx/include/mach/irqs.h
new file mode 100644
index 0000000..7a78057
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/irqs.h
@@ -0,0 +1,114 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/irqs.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARM_ARCH_IRQS_H
+#define __ASM_ARM_ARCH_IRQS_H
+
+/*
+ * MIC interrupts
+ */
+#define IRQ_LPC32XX_SUB1IRQ		0
+#define IRQ_LPC32XX_SUB2IRQ		1
+#define IRQ_LPC32XX_PWM3		3
+#define IRQ_LPC32XX_PWM4		4
+#define IRQ_LPC32XX_HSTIMER		5
+#define IRQ_LPC32XX_WATCH		6
+#define IRQ_LPC32XX_UART_IIR3		7
+#define IRQ_LPC32XX_UART_IIR4		8
+#define IRQ_LPC32XX_UART_IIR5		9
+#define IRQ_LPC32XX_UART_IIR6		10
+#define IRQ_LPC32XX_FLASH		11
+#define IRQ_LPC32XX_SD1			13
+#define IRQ_LPC32XX_LCD			14
+#define IRQ_LPC32XX_SD0			15
+#define IRQ_LPC32XX_TIMER0		16
+#define IRQ_LPC32XX_TIMER1		17
+#define IRQ_LPC32XX_TIMER2		18
+#define IRQ_LPC32XX_TIMER3		19
+#define IRQ_LPC32XX_SSP0		20
+#define IRQ_LPC32XX_SSP1		21
+#define IRQ_LPC32XX_I2S0		22
+#define IRQ_LPC32XX_I2S1		23
+#define IRQ_LPC32XX_UART_IIR7		24
+#define IRQ_LPC32XX_UART_IIR2		25
+#define IRQ_LPC32XX_UART_IIR1		26
+#define IRQ_LPC32XX_MSTIMER		27
+#define IRQ_LPC32XX_DMA			28
+#define IRQ_LPC32XX_ETHERNET		29
+#define IRQ_LPC32XX_SUB1FIQ		30
+#define IRQ_LPC32XX_SUB2FIQ		31
+
+/*
+ * SIC1 interrupts start at offset 32
+ */
+#define IRQ_LPC32XX_JTAG_COMM_TX	(32 + 1)
+#define IRQ_LPC32XX_JTAG_COMM_RX	(32 + 2)
+#define IRQ_LPC32XX_GPI_11		(32 + 4)
+#define IRQ_LPC32XX_TS_P		(32 + 6)
+#define IRQ_LPC32XX_TS_IRQ		(32 + 7)
+#define IRQ_LPC32XX_TS_AUX		(32 + 8)
+#define IRQ_LPC32XX_SPI2		(32 + 12)
+#define IRQ_LPC32XX_PLLUSB		(32 + 13)
+#define IRQ_LPC32XX_PLLHCLK		(32 + 14)
+#define IRQ_LPC32XX_PLL397		(32 + 17)
+#define IRQ_LPC32XX_I2C_2		(32 + 18)
+#define IRQ_LPC32XX_I2C_1		(32 + 19)
+#define IRQ_LPC32XX_RTC			(32 + 20)
+#define IRQ_LPC32XX_KEY			(32 + 22)
+#define IRQ_LPC32XX_SPI1		(32 + 23)
+#define IRQ_LPC32XX_SW			(32 + 24)
+#define IRQ_LPC32XX_USB_OTG_TIMER	(32 + 25)
+#define IRQ_LPC32XX_USB_OTG_ATX		(32 + 26)
+#define IRQ_LPC32XX_USB_HOST		(32 + 27)
+#define IRQ_LPC32XX_USB_DEV_DMA		(32 + 28)
+#define IRQ_LPC32XX_USB_DEV_LP		(32 + 29)
+#define IRQ_LPC32XX_USB_DEV_HP		(32 + 30)
+#define IRQ_LPC32XX_USB_I2C		(32 + 31)
+
+/*
+ * SIC2 interrupts start at offset 64
+ */
+#define IRQ_LPC32XX_GPIO_00		(64 + 0)
+#define IRQ_LPC32XX_GPIO_01		(64 + 1)
+#define IRQ_LPC32XX_GPIO_02		(64 + 2)
+#define IRQ_LPC32XX_GPIO_03		(64 + 3)
+#define IRQ_LPC32XX_GPIO_04		(64 + 4)
+#define IRQ_LPC32XX_GPIO_05		(64 + 5)
+#define IRQ_LPC32XX_SPI2_DATAIN		(64 + 6)
+#define IRQ_LPC32XX_U2_HCTS		(64 + 7)
+#define IRQ_LPC32XX_P0_P1_IRQ		(64 + 8)
+#define IRQ_LPC32XX_GPI_08		(64 + 9)
+#define IRQ_LPC32XX_GPI_09		(64 + 10)
+#define IRQ_LPC32XX_GPI_19		(64 + 11)
+#define IRQ_LPC32XX_U7_HCTS		(64 + 12)
+#define IRQ_LPC32XX_GPI_07		(64 + 15)
+#define IRQ_LPC32XX_SDIO		(64 + 18)
+#define IRQ_LPC32XX_U5_RX		(64 + 19)
+#define IRQ_LPC32XX_SPI1_DATAIN		(64 + 20)
+#define IRQ_LPC32XX_GPI_00		(64 + 22)
+#define IRQ_LPC32XX_GPI_01		(64 + 23)
+#define IRQ_LPC32XX_GPI_02		(64 + 24)
+#define IRQ_LPC32XX_GPI_03		(64 + 25)
+#define IRQ_LPC32XX_GPI_04		(64 + 26)
+#define IRQ_LPC32XX_GPI_05		(64 + 27)
+#define IRQ_LPC32XX_GPI_06		(64 + 28)
+#define IRQ_LPC32XX_SYSCLK		(64 + 31)
+
+#define NR_IRQS				96
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/memory.h b/arch/arm/mach-lpc32xx/include/mach/memory.h
new file mode 100644
index 0000000..b4d8156
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/memory.h
@@ -0,0 +1,28 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/memory.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset of bank 0
+ */
+#define PHYS_OFFSET	UL(0x80000000)
+
+#endif
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/platform.h b/arch/arm/mach-lpc32xx/include/mach/platform.h
new file mode 100644
index 0000000..e01181f
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/platform.h
@@ -0,0 +1,697 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/platform.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_PLATFORM_H
+#define __ASM_ARCH_PLATFORM_H
+
+#define _REG(x)					(void __iomem *)(io_p2v(x))
+
+#define _SBF(f, v)				((v) << (f))
+#define _BIT(n)					_SBF(n, 1)
+
+/*
+ * AHB 0 physical base addresses
+ */
+#define LPC32XX_SLC_BASE			0x20020000
+#define LPC32XX_SSP0_BASE			0x20084000
+#define LPC32XX_SPI1_BASE			0x20088000
+#define LPC32XX_SSP1_BASE			0x2008C000
+#define LPC32XX_SPI2_BASE			0x20090000
+#define LPC32XX_I2S0_BASE			0x20094000
+#define LPC32XX_SD_BASE				0x20098000
+#define LPC32XX_I2S1_BASE			0x2009C000
+#define LPC32XX_MLC_BASE			0x200A8000
+#define LPC32XX_AHB0_START			LPC32XX_SLC_BASE
+#define LPC32XX_AHB0_SIZE			((LPC32XX_MLC_BASE -\
+						LPC32XX_SLC_BASE) + SZ_4K)
+/*
+ * AHB 1 physical base addresses
+ */
+#define LPC32XX_DMA_BASE			0x31000000
+#define LPC32XX_USB_BASE			0x31020000
+#define LPC32XX_USBH_BASE			0x31020000
+#define LPC32XX_USB_OTG_BASE			0x31020000
+#define LPC32XX_OTG_I2C_BASE			0x31020300
+#define LPC32XX_LCD_BASE			0x31040000
+#define LPC32XX_ETHERNET_BASE			0x31060000
+#define LPC32XX_EMC_BASE			0x31080000
+#define LPC32XX_ETB_CFG_BASE			0x310C0000
+#define LPC32XX_ETB_DATA_BASE			0x310E0000
+#define LPC32XX_AHB1_START			LPC32XX_DMA_BASE
+#define LPC32XX_AHB1_SIZE			((LPC32XX_EMC_BASE -\
+						LPC32XX_DMA_BASE) + SZ_4K)
+/*
+ * FAB physical base addresses
+ */
+#define LPC32XX_CLK_PM_BASE			0x40004000
+#define LPC32XX_MIC_BASE			0x40008000
+#define LPC32XX_SIC1_BASE			0x4000C000
+#define LPC32XX_SIC2_BASE			0x40010000
+#define LPC32XX_HS_UART1_BASE			0x40014000
+#define LPC32XX_HS_UART2_BASE			0x40018000
+#define LPC32XX_HS_UART7_BASE			0x4001C000
+#define LPC32XX_RTC_BASE			0x40024000
+#define LPC32XX_RTC_RAM_BASE			0x40024080
+#define LPC32XX_GPIO_BASE			0x40028000
+#define LPC32XX_PWM3_BASE			0x4002C000
+#define LPC32XX_PWM4_BASE			0x40030000
+#define LPC32XX_MSTIM_BASE			0x40034000
+#define LPC32XX_HSTIM_BASE			0x40038000
+#define LPC32XX_WDTIM_BASE			0x4003C000
+#define LPC32XX_DEBUG_CTRL_BASE			0x40040000
+#define LPC32XX_TIMER0_BASE			0x40044000
+#define LPC32XX_ADC_BASE			0x40048000
+#define LPC32XX_TIMER1_BASE			0x4004C000
+#define LPC32XX_KSCAN_BASE			0x40050000
+#define LPC32XX_UART_CTRL_BASE			0x40054000
+#define LPC32XX_TIMER2_BASE			0x40058000
+#define LPC32XX_PWM1_BASE			0x4005C000
+#define LPC32XX_PWM2_BASE			0x4005C004
+#define LPC32XX_TIMER3_BASE			0x40060000
+
+/*
+ * APB physical base addresses
+ */
+#define LPC32XX_UART3_BASE			0x40080000
+#define LPC32XX_UART4_BASE			0x40088000
+#define LPC32XX_UART5_BASE			0x40090000
+#define LPC32XX_UART6_BASE			0x40098000
+#define LPC32XX_I2C1_BASE			0x400A0000
+#define LPC32XX_I2C2_BASE			0x400A8000
+
+/*
+ * FAB and APB base and sizing
+ */
+#define LPC32XX_FABAPB_START			LPC32XX_CLK_PM_BASE
+#define LPC32XX_FABAPB_SIZE			((LPC32XX_I2C2_BASE -\
+						LPC32XX_CLK_PM_BASE) + SZ_4K)
+
+/*
+ * Internal memory Bases
+ */
+#define LPC32XX_IRAM_BASE			0x08000000
+#define LPC32XX_IROM_BASE			0x0C000000
+
+/*
+ * External Static Memory Bank Address Space Bases
+ */
+#define LPC32XX_EMC_CS0_BASE			0xE0000000
+#define LPC32XX_EMC_CS1_BASE			0xE1000000
+#define LPC32XX_EMC_CS2_BASE			0xE2000000
+#define LPC32XX_EMC_CS3_BASE			0xE3000000
+
+/*
+ * External SDRAM Memory Bank Address Space Bases
+ */
+#define LPC32XX_EMC_DYCS0_BASE			0x80000000
+#define LPC32XX_EMC_DYCS1_BASE			0xA0000000
+
+/*
+ * Clock and crystal information
+ */
+#define LPC32XX_MAIN_OSC_FREQ			13000000
+#define LPC32XX_CLOCK_OSC_FREQ			32768
+
+/*
+ * Clock and Power control register offsets
+ */
+#define _PMREG(x)				_REG(LPC32XX_CLK_PM_BASE + (x))
+#define LPC32XX_CLKPWR_DEBUG_CTRL		_PMREG(0x000)
+#define LPC32XX_CLKPWR_BOOTMAP			_PMREG(0x014)
+#define LPC32XX_CLKPWR_P01_ER			_PMREG(0x018)
+#define LPC32XX_CLKPWR_USBCLK_PDIV		_PMREG(0x01C)
+#define LPC32XX_CLKPWR_INT_ER			_PMREG(0x020)
+#define LPC32XX_CLKPWR_INT_RS			_PMREG(0x024)
+#define LPC32XX_CLKPWR_INT_SR			_PMREG(0x028)
+#define LPC32XX_CLKPWR_INT_AP			_PMREG(0x02C)
+#define LPC32XX_CLKPWR_PIN_ER			_PMREG(0x030)
+#define LPC32XX_CLKPWR_PIN_RS			_PMREG(0x034)
+#define LPC32XX_CLKPWR_PIN_SR			_PMREG(0x038)
+#define LPC32XX_CLKPWR_PIN_AP			_PMREG(0x03C)
+#define LPC32XX_CLKPWR_HCLK_DIV			_PMREG(0x040)
+#define LPC32XX_CLKPWR_PWR_CTRL			_PMREG(0x044)
+#define LPC32XX_CLKPWR_PLL397_CTRL		_PMREG(0x048)
+#define LPC32XX_CLKPWR_MAIN_OSC_CTRL		_PMREG(0x04C)
+#define LPC32XX_CLKPWR_SYSCLK_CTRL		_PMREG(0x050)
+#define LPC32XX_CLKPWR_LCDCLK_CTRL		_PMREG(0x054)
+#define LPC32XX_CLKPWR_HCLKPLL_CTRL		_PMREG(0x058)
+#define LPC32XX_CLKPWR_ADC_CLK_CTRL_1		_PMREG(0x060)
+#define LPC32XX_CLKPWR_USB_CTRL			_PMREG(0x064)
+#define LPC32XX_CLKPWR_SDRAMCLK_CTRL		_PMREG(0x068)
+#define LPC32XX_CLKPWR_DDR_LAP_NOM		_PMREG(0x06C)
+#define LPC32XX_CLKPWR_DDR_LAP_COUNT		_PMREG(0x070)
+#define LPC32XX_CLKPWR_DDR_LAP_DELAY		_PMREG(0x074)
+#define LPC32XX_CLKPWR_SSP_CLK_CTRL		_PMREG(0x078)
+#define LPC32XX_CLKPWR_I2S_CLK_CTRL		_PMREG(0x07C)
+#define LPC32XX_CLKPWR_MS_CTRL			_PMREG(0x080)
+#define LPC32XX_CLKPWR_MACCLK_CTRL		_PMREG(0x090)
+#define LPC32XX_CLKPWR_TEST_CLK_SEL		_PMREG(0x0A4)
+#define LPC32XX_CLKPWR_SFW_INT			_PMREG(0x0A8)
+#define LPC32XX_CLKPWR_I2C_CLK_CTRL		_PMREG(0x0AC)
+#define LPC32XX_CLKPWR_KEY_CLK_CTRL		_PMREG(0x0B0)
+#define LPC32XX_CLKPWR_ADC_CLK_CTRL		_PMREG(0x0B4)
+#define LPC32XX_CLKPWR_PWM_CLK_CTRL		_PMREG(0x0B8)
+#define LPC32XX_CLKPWR_TIMER_CLK_CTRL		_PMREG(0x0BC)
+#define LPC32XX_CLKPWR_TIMERS_PWMS_CLK_CTRL_1	_PMREG(0x0C0)
+#define LPC32XX_CLKPWR_SPI_CLK_CTRL		_PMREG(0x0C4)
+#define LPC32XX_CLKPWR_NAND_CLK_CTRL		_PMREG(0x0C8)
+#define LPC32XX_CLKPWR_UART3_CLK_CTRL		_PMREG(0x0D0)
+#define LPC32XX_CLKPWR_UART4_CLK_CTRL		_PMREG(0x0D4)
+#define LPC32XX_CLKPWR_UART5_CLK_CTRL		_PMREG(0x0D8)
+#define LPC32XX_CLKPWR_UART6_CLK_CTRL		_PMREG(0x0DC)
+#define LPC32XX_CLKPWR_IRDA_CLK_CTRL		_PMREG(0x0E0)
+#define LPC32XX_CLKPWR_UART_CLK_CTRL		_PMREG(0x0E4)
+#define LPC32XX_CLKPWR_DMA_CLK_CTRL		_PMREG(0x0E8)
+#define LPC32XX_CLKPWR_AUTOCLOCK		_PMREG(0x0EC)
+#define LPC32XX_CLKPWR_DEVID(x)			_PMREG(0x130 + (x))
+
+/*
+ * clkpwr_debug_ctrl register definitions
+*/
+#define LPC32XX_CLKPWR_VFP_CLOCK_ENABLE_BIT	_BIT(4)
+
+/*
+ * clkpwr_bootmap register definitions
+ */
+#define LPC32XX_CLKPWR_BOOTMAP_SEL_BIT		_BIT(1)
+
+/*
+ * clkpwr_start_gpio register bit definitions
+ */
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO23_BIT	_BIT(31)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO22_BIT	_BIT(30)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO21_BIT	_BIT(29)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO20_BIT	_BIT(28)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO19_BIT	_BIT(27)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO18_BIT	_BIT(26)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO17_BIT	_BIT(25)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO16_BIT	_BIT(24)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO15_BIT	_BIT(23)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO14_BIT	_BIT(22)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO13_BIT	_BIT(21)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO12_BIT	_BIT(20)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO11_BIT	_BIT(19)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO10_BIT	_BIT(18)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO9_BIT	_BIT(17)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO8_BIT	_BIT(16)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO7_BIT	_BIT(15)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO6_BIT	_BIT(14)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO5_BIT	_BIT(13)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO4_BIT	_BIT(12)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO3_BIT	_BIT(11)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO2_BIT	_BIT(10)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO1_BIT	_BIT(9)
+#define LPC32XX_CLKPWR_GPIOSRC_P1IO0_BIT	_BIT(8)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO7_BIT	_BIT(7)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO6_BIT	_BIT(6)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO5_BIT	_BIT(5)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO4_BIT	_BIT(4)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO3_BIT	_BIT(3)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO2_BIT	_BIT(2)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO1_BIT	_BIT(1)
+#define LPC32XX_CLKPWR_GPIOSRC_P0IO0_BIT	_BIT(0)
+
+/*
+ * clkpwr_usbclk_pdiv register definitions
+ */
+#define LPC32XX_CLKPWR_SET_PLL_USBPDIV(n)	((n) & 0xF)
+#define LPC32XX_CLKPWR_USBPDIV_PLL_MASK		0xF
+
+/*
+ * clkpwr_start_int, clkpwr_start_raw_sts_int, clkpwr_start_sts_int,
+ * clkpwr_start_pol_int, register bit definitions
+ */
+#define LPC32XX_CLKPWR_INTSRC_ADC_BIT		_BIT(31)
+#define LPC32XX_CLKPWR_INTSRC_TS_P_BIT		_BIT(30)
+#define LPC32XX_CLKPWR_INTSRC_TS_AUX_BIT	_BIT(29)
+#define LPC32XX_CLKPWR_INTSRC_USBAHNEEDCLK_BIT	_BIT(26)
+#define LPC32XX_CLKPWR_INTSRC_MSTIMER_BIT	_BIT(25)
+#define LPC32XX_CLKPWR_INTSRC_RTC_BIT		_BIT(24)
+#define LPC32XX_CLKPWR_INTSRC_USBNEEDCLK_BIT	_BIT(23)
+#define LPC32XX_CLKPWR_INTSRC_USB_BIT		_BIT(22)
+#define LPC32XX_CLKPWR_INTSRC_I2C_BIT		_BIT(21)
+#define LPC32XX_CLKPWR_INTSRC_USBOTGTIMER_BIT	_BIT(20)
+#define LPC32XX_CLKPWR_INTSRC_USBATXINT_BIT	_BIT(19)
+#define LPC32XX_CLKPWR_INTSRC_KEY_BIT		_BIT(16)
+#define LPC32XX_CLKPWR_INTSRC_MAC_BIT		_BIT(7)
+#define LPC32XX_CLKPWR_INTSRC_P0P1_BIT		_BIT(6)
+#define LPC32XX_CLKPWR_INTSRC_GPIO_05_BIT	_BIT(5)
+#define LPC32XX_CLKPWR_INTSRC_GPIO_04_BIT	_BIT(4)
+#define LPC32XX_CLKPWR_INTSRC_GPIO_03_BIT	_BIT(3)
+#define LPC32XX_CLKPWR_INTSRC_GPIO_02_BIT	_BIT(2)
+#define LPC32XX_CLKPWR_INTSRC_GPIO_01_BIT	_BIT(1)
+#define LPC32XX_CLKPWR_INTSRC_GPIO_00_BIT	_BIT(0)
+
+/*
+ * clkpwr_start_pin, clkpwr_start_raw_sts_pin, clkpwr_start_sts_pin,
+ * clkpwr_start_pol_pin register bit definitions
+ */
+#define LPC32XX_CLKPWR_EXTSRC_U7_RX_BIT		_BIT(31)
+#define LPC32XX_CLKPWR_EXTSRC_U7_HCTS_BIT	_BIT(30)
+#define LPC32XX_CLKPWR_EXTSRC_U6_IRRX_BIT	_BIT(28)
+#define LPC32XX_CLKPWR_EXTSRC_U5_RX_BIT		_BIT(26)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_28_BIT	_BIT(25)
+#define LPC32XX_CLKPWR_EXTSRC_U3_RX_BIT		_BIT(24)
+#define LPC32XX_CLKPWR_EXTSRC_U2_HCTS_BIT	_BIT(23)
+#define LPC32XX_CLKPWR_EXTSRC_U2_RX_BIT		_BIT(22)
+#define LPC32XX_CLKPWR_EXTSRC_U1_RX_BIT		_BIT(21)
+#define LPC32XX_CLKPWR_EXTSRC_MSDIO_INT_BIT	_BIT(18)
+#define LPC32XX_CLKPWR_EXTSRC_MSDIO_SRT_BIT	_BIT(17)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_06_BIT	_BIT(16)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_05_BIT	_BIT(15)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_04_BIT	_BIT(14)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_03_BIT	_BIT(13)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_02_BIT	_BIT(12)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_01_BIT	_BIT(11)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_00_BIT	_BIT(10)
+#define LPC32XX_CLKPWR_EXTSRC_SYSCLKEN_BIT	_BIT(9)
+#define LPC32XX_CLKPWR_EXTSRC_SPI1_DATIN_BIT	_BIT(8)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_07_BIT	_BIT(7)
+#define LPC32XX_CLKPWR_EXTSRC_SPI2_DATIN_BIT	_BIT(6)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_19_BIT	_BIT(5)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_09_BIT	_BIT(4)
+#define LPC32XX_CLKPWR_EXTSRC_GPI_08_BIT	_BIT(3)
+
+/*
+ * clkpwr_hclk_div register definitions
+ */
+#define LPC32XX_CLKPWR_HCLKDIV_DDRCLK_STOP	(0x0 << 7)
+#define LPC32XX_CLKPWR_HCLKDIV_DDRCLK_NORM	(0x1 << 7)
+#define LPC32XX_CLKPWR_HCLKDIV_DDRCLK_HALF	(0x2 << 7)
+#define LPC32XX_CLKPWR_HCLKDIV_PCLK_DIV(n)	(((n) & 0x1F) << 2)
+#define LPC32XX_CLKPWR_HCLKDIV_DIV_2POW(n)	((n) & 0x3)
+
+/*
+ * clkpwr_pwr_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_CTRL_FORCE_PCLK		_BIT(10)
+#define LPC32XX_CLKPWR_SDRAM_SELF_RFSH		_BIT(9)
+#define LPC32XX_CLKPWR_UPD_SDRAM_SELF_RFSH	_BIT(8)
+#define LPC32XX_CLKPWR_AUTO_SDRAM_SELF_RFSH	_BIT(7)
+#define LPC32XX_CLKPWR_HIGHCORE_STATE_BIT	_BIT(5)
+#define LPC32XX_CLKPWR_SYSCLKEN_STATE_BIT	_BIT(4)
+#define LPC32XX_CLKPWR_SYSCLKEN_GPIO_EN		_BIT(3)
+#define LPC32XX_CLKPWR_SELECT_RUN_MODE		_BIT(2)
+#define LPC32XX_CLKPWR_HIGHCORE_GPIO_EN		_BIT(1)
+#define LPC32XX_CLKPWR_STOP_MODE_CTRL		_BIT(0)
+
+/*
+ * clkpwr_pll397_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_PLL397_MSLOCK_STS	_BIT(10)
+#define LPC32XX_CLKPWR_PLL397_BYPASS		_BIT(9)
+#define LPC32XX_CLKPWR_PLL397_BIAS_NORM		0x000
+#define LPC32XX_CLKPWR_PLL397_BIAS_N12_5	0x040
+#define LPC32XX_CLKPWR_PLL397_BIAS_N25		0x080
+#define LPC32XX_CLKPWR_PLL397_BIAS_N37_5	0x0C0
+#define LPC32XX_CLKPWR_PLL397_BIAS_P12_5	0x100
+#define LPC32XX_CLKPWR_PLL397_BIAS_P25		0x140
+#define LPC32XX_CLKPWR_PLL397_BIAS_P37_5	0x180
+#define LPC32XX_CLKPWR_PLL397_BIAS_P50		0x1C0
+#define LPC32XX_CLKPWR_PLL397_BIAS_MASK		0x1C0
+#define LPC32XX_CLKPWR_SYSCTRL_PLL397_DIS	_BIT(1)
+#define LPC32XX_CLKPWR_SYSCTRL_PLL397_STS	_BIT(0)
+
+/*
+ * clkpwr_main_osc_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_MOSC_ADD_CAP(n)		(((n) & 0x7F) << 2)
+#define LPC32XX_CLKPWR_MOSC_CAP_MASK		(0x7F << 2)
+#define LPC32XX_CLKPWR_TEST_MODE		_BIT(1)
+#define LPC32XX_CLKPWR_MOSC_DISABLE		_BIT(0)
+
+/*
+ * clkpwr_sysclk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_SYSCTRL_BP_TRIG(n)	(((n) & 0x3FF) << 2)
+#define LPC32XX_CLKPWR_SYSCTRL_BP_MASK		(0x3FF << 2)
+#define LPC32XX_CLKPWR_SYSCTRL_USEPLL397	_BIT(1)
+#define LPC32XX_CLKPWR_SYSCTRL_SYSCLKMUX	_BIT(0)
+
+/*
+ * clkpwr_lcdclk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT12	0x000
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT16	0x040
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT15	0x080
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT24	0x0C0
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_STN4M	0x100
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_STN8C	0x140
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_DSTN4M	0x180
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_DSTN8C	0x1C0
+#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_MSK	0x01C0
+#define LPC32XX_CLKPWR_LCDCTRL_CLK_EN		0x020
+#define LPC32XX_CLKPWR_LCDCTRL_SET_PSCALE(n)	((n - 1) & 0x1F)
+#define LPC32XX_CLKPWR_LCDCTRL_PSCALE_MSK	0x001F
+
+/*
+ * clkpwr_hclkpll_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_HCLKPLL_POWER_UP		_BIT(16)
+#define LPC32XX_CLKPWR_HCLKPLL_CCO_BYPASS	_BIT(15)
+#define LPC32XX_CLKPWR_HCLKPLL_POSTDIV_BYPASS	_BIT(14)
+#define LPC32XX_CLKPWR_HCLKPLL_FDBK_SEL_FCLK	_BIT(13)
+#define LPC32XX_CLKPWR_HCLKPLL_POSTDIV_2POW(n)	(((n) & 0x3) << 11)
+#define LPC32XX_CLKPWR_HCLKPLL_PREDIV_PLUS1(n)	(((n) & 0x3) << 9)
+#define LPC32XX_CLKPWR_HCLKPLL_PLLM(n)		(((n) & 0xFF) << 1)
+#define LPC32XX_CLKPWR_HCLKPLL_PLL_STS		_BIT(0)
+
+/*
+ * clkpwr_adc_clk_ctrl_1 register definitions
+ */
+#define LPC32XX_CLKPWR_ADCCTRL1_RTDIV(n)	(((n) & 0xFF) << 0)
+#define LPC32XX_CLKPWR_ADCCTRL1_PCLK_SEL	_BIT(8)
+
+/*
+ * clkpwr_usb_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_USBCTRL_HCLK_EN		_BIT(24)
+#define LPC32XX_CLKPWR_USBCTRL_USBI2C_EN	_BIT(23)
+#define LPC32XX_CLKPWR_USBCTRL_USBDVND_EN	_BIT(22)
+#define LPC32XX_CLKPWR_USBCTRL_USBHSTND_EN	_BIT(21)
+#define LPC32XX_CLKPWR_USBCTRL_PU_ADD		(0x0 << 19)
+#define LPC32XX_CLKPWR_USBCTRL_BUS_KEEPER	(0x1 << 19)
+#define LPC32XX_CLKPWR_USBCTRL_PD_ADD		(0x3 << 19)
+#define LPC32XX_CLKPWR_USBCTRL_CLK_EN2		_BIT(18)
+#define LPC32XX_CLKPWR_USBCTRL_CLK_EN1		_BIT(17)
+#define LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP	_BIT(16)
+#define LPC32XX_CLKPWR_USBCTRL_CCO_BYPASS	_BIT(15)
+#define LPC32XX_CLKPWR_USBCTRL_POSTDIV_BYPASS	_BIT(14)
+#define LPC32XX_CLKPWR_USBCTRL_FDBK_SEL_FCLK	_BIT(13)
+#define LPC32XX_CLKPWR_USBCTRL_POSTDIV_2POW(n)	(((n) & 0x3) << 11)
+#define LPC32XX_CLKPWR_USBCTRL_PREDIV_PLUS1(n)	(((n) & 0x3) << 9)
+#define LPC32XX_CLKPWR_USBCTRL_FDBK_PLUS1(n)	(((n) & 0xFF) << 1)
+#define LPC32XX_CLKPWR_USBCTRL_PLL_STS		_BIT(0)
+
+/*
+ * clkpwr_sdramclk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_SDRCLK_FASTSLEW_CLK	_BIT(22)
+#define LPC32XX_CLKPWR_SDRCLK_FASTSLEW		_BIT(21)
+#define LPC32XX_CLKPWR_SDRCLK_FASTSLEW_DAT	_BIT(20)
+#define LPC32XX_CLKPWR_SDRCLK_SW_DDR_RESET	_BIT(19)
+#define LPC32XX_CLKPWR_SDRCLK_HCLK_DLY(n)	(((n) & 0x1F) << 14)
+#define LPC32XX_CLKPWR_SDRCLK_DLY_ADDR_STS	_BIT(13)
+#define LPC32XX_CLKPWR_SDRCLK_SENS_FACT(n)	(((n) & 0x7) << 10)
+#define LPC32XX_CLKPWR_SDRCLK_USE_CAL		_BIT(9)
+#define LPC32XX_CLKPWR_SDRCLK_DO_CAL		_BIT(8)
+#define LPC32XX_CLKPWR_SDRCLK_CAL_ON_RTC	_BIT(7)
+#define LPC32XX_CLKPWR_SDRCLK_DQS_DLY(n)	(((n) & 0x1F) << 2)
+#define LPC32XX_CLKPWR_SDRCLK_USE_DDR		_BIT(1)
+#define LPC32XX_CLKPWR_SDRCLK_CLK_DIS		_BIT(0)
+
+/*
+ * clkpwr_ssp_blk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP1RX	_BIT(5)
+#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP1TX	_BIT(4)
+#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP0RX	_BIT(3)
+#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP0TX	_BIT(2)
+#define LPC32XX_CLKPWR_SSPCTRL_SSPCLK1_EN	_BIT(1)
+#define LPC32XX_CLKPWR_SSPCTRL_SSPCLK0_EN	_BIT(0)
+
+/*
+ * clkpwr_i2s_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_I2SCTRL_I2S1_RX_FOR_TX	_BIT(6)
+#define LPC32XX_CLKPWR_I2SCTRL_I2S1_TX_FOR_RX	_BIT(5)
+#define LPC32XX_CLKPWR_I2SCTRL_I2S1_USE_DMA	_BIT(4)
+#define LPC32XX_CLKPWR_I2SCTRL_I2S0_RX_FOR_TX	_BIT(3)
+#define LPC32XX_CLKPWR_I2SCTRL_I2S0_TX_FOR_RX	_BIT(2)
+#define LPC32XX_CLKPWR_I2SCTRL_I2SCLK1_EN	_BIT(1)
+#define LPC32XX_CLKPWR_I2SCTRL_I2SCLK0_EN	_BIT(0)
+
+/*
+ * clkpwr_ms_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_MSCARD_MSDIO_PIN_DIS	_BIT(10)
+#define LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN	_BIT(9)
+#define LPC32XX_CLKPWR_MSCARD_MSDIO23_DIS	_BIT(8)
+#define LPC32XX_CLKPWR_MSCARD_MSDIO1_DIS	_BIT(7)
+#define LPC32XX_CLKPWR_MSCARD_MSDIO0_DIS	_BIT(6)
+#define LPC32XX_CLKPWR_MSCARD_SDCARD_EN		_BIT(5)
+#define LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(n)	((n) & 0xF)
+
+/*
+ * clkpwr_macclk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_MACCTRL_NO_ENET_PIS	0x00
+#define LPC32XX_CLKPWR_MACCTRL_USE_MII_PINS	0x08
+#define LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS	0x18
+#define LPC32XX_CLKPWR_MACCTRL_PINS_MSK		0x18
+#define LPC32XX_CLKPWR_MACCTRL_DMACLK_EN	_BIT(2)
+#define LPC32XX_CLKPWR_MACCTRL_MMIOCLK_EN	_BIT(1)
+#define LPC32XX_CLKPWR_MACCTRL_HRCCLK_EN	_BIT(0)
+
+/*
+ * clkpwr_test_clk_sel register definitions
+ */
+#define LPC32XX_CLKPWR_TESTCLK1_SEL_PERCLK	(0x0 << 5)
+#define LPC32XX_CLKPWR_TESTCLK1_SEL_RTC		(0x1 << 5)
+#define LPC32XX_CLKPWR_TESTCLK1_SEL_MOSC	(0x2 << 5)
+#define LPC32XX_CLKPWR_TESTCLK1_SEL_MASK	(0x3 << 5)
+#define LPC32XX_CLKPWR_TESTCLK_TESTCLK1_EN	_BIT(4)
+#define LPC32XX_CLKPWR_TESTCLK2_SEL_HCLK	(0x0 << 1)
+#define LPC32XX_CLKPWR_TESTCLK2_SEL_PERCLK	(0x1 << 1)
+#define LPC32XX_CLKPWR_TESTCLK2_SEL_USBCLK	(0x2 << 1)
+#define LPC32XX_CLKPWR_TESTCLK2_SEL_MOSC	(0x5 << 1)
+#define LPC32XX_CLKPWR_TESTCLK2_SEL_PLL397	(0x7 << 1)
+#define LPC32XX_CLKPWR_TESTCLK2_SEL_MASK	(0x7 << 1)
+#define LPC32XX_CLKPWR_TESTCLK_TESTCLK2_EN	_BIT(0)
+
+/*
+ * clkpwr_sw_int register definitions
+ */
+#define LPC32XX_CLKPWR_SW_INT(n)		(_BIT(0) | (((n) & 0x7F) << 1))
+#define LPC32XX_CLKPWR_SW_GET_ARG(n)		(((n) & 0xFE) >> 1)
+
+/*
+ * clkpwr_i2c_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_I2CCLK_USBI2CHI_DRIVE	_BIT(4)
+#define LPC32XX_CLKPWR_I2CCLK_I2C2HI_DRIVE	_BIT(3)
+#define LPC32XX_CLKPWR_I2CCLK_I2C1HI_DRIVE	_BIT(2)
+#define LPC32XX_CLKPWR_I2CCLK_I2C2CLK_EN	_BIT(1)
+#define LPC32XX_CLKPWR_I2CCLK_I2C1CLK_EN	_BIT(0)
+
+/*
+ * clkpwr_key_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_KEYCLKCTRL_CLK_EN	0x1
+
+/*
+ * clkpwr_adc_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_ADC32CLKCTRL_CLK_EN	0x1
+
+/*
+ * clkpwr_pwm_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_PWMCLK_PWM2_DIV(n)	(((n) & 0xF) << 8)
+#define LPC32XX_CLKPWR_PWMCLK_PWM1_DIV(n)	(((n) & 0xF) << 4)
+#define LPC32XX_CLKPWR_PWMCLK_PWM2SEL_PCLK	0x8
+#define LPC32XX_CLKPWR_PWMCLK_PWM2CLK_EN	0x4
+#define LPC32XX_CLKPWR_PWMCLK_PWM1SEL_PCLK	0x2
+#define LPC32XX_CLKPWR_PWMCLK_PWM1CLK_EN	0x1
+
+/*
+ * clkpwr_timer_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_PWMCLK_HSTIMER_EN	0x2
+#define LPC32XX_CLKPWR_PWMCLK_WDOG_EN		0x1
+
+/*
+ * clkpwr_timers_pwms_clk_ctrl_1 register definitions
+ */
+#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER3_EN	0x20
+#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER2_EN	0x10
+#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER1_EN	0x08
+#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER0_EN	0x04
+#define LPC32XX_CLKPWR_TMRPWMCLK_PWM4_EN	0x02
+#define LPC32XX_CLKPWR_TMRPWMCLK_PWM3_EN	0x01
+
+/*
+ * clkpwr_spi_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_SPICLK_SET_SPI2DATIO	0x80
+#define LPC32XX_CLKPWR_SPICLK_SET_SPI2CLK	0x40
+#define LPC32XX_CLKPWR_SPICLK_USE_SPI2		0x20
+#define LPC32XX_CLKPWR_SPICLK_SPI2CLK_EN	0x10
+#define LPC32XX_CLKPWR_SPICLK_SET_SPI1DATIO	0x08
+#define LPC32XX_CLKPWR_SPICLK_SET_SPI1CLK	0x04
+#define LPC32XX_CLKPWR_SPICLK_USE_SPI1		0x02
+#define LPC32XX_CLKPWR_SPICLK_SPI1CLK_EN	0x01
+
+/*
+ * clkpwr_nand_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_NANDCLK_INTSEL_MLC	0x20
+#define LPC32XX_CLKPWR_NANDCLK_DMA_RNB		0x10
+#define LPC32XX_CLKPWR_NANDCLK_DMA_INT		0x08
+#define LPC32XX_CLKPWR_NANDCLK_SEL_SLC		0x04
+#define LPC32XX_CLKPWR_NANDCLK_MLCCLK_EN	0x02
+#define LPC32XX_CLKPWR_NANDCLK_SLCCLK_EN	0x01
+
+/*
+ * clkpwr_uart3_clk_ctrl, clkpwr_uart4_clk_ctrl, clkpwr_uart5_clk_ctrl
+ * and clkpwr_uart6_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_UART_Y_DIV(y)		((y) & 0xFF)
+#define LPC32XX_CLKPWR_UART_X_DIV(x)		(((x) & 0xFF) << 8)
+#define LPC32XX_CLKPWR_UART_USE_HCLK		_BIT(16)
+
+/*
+ * clkpwr_irda_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_IRDA_Y_DIV(y)		((y) & 0xFF)
+#define LPC32XX_CLKPWR_IRDA_X_DIV(x)		(((x) & 0xFF) << 8)
+
+/*
+ * clkpwr_uart_clk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_UARTCLKCTRL_UART6_EN	_BIT(3)
+#define LPC32XX_CLKPWR_UARTCLKCTRL_UART5_EN	_BIT(2)
+#define LPC32XX_CLKPWR_UARTCLKCTRL_UART4_EN	_BIT(1)
+#define LPC32XX_CLKPWR_UARTCLKCTRL_UART3_EN	_BIT(0)
+
+/*
+ * clkpwr_dmaclk_ctrl register definitions
+ */
+#define LPC32XX_CLKPWR_DMACLKCTRL_CLK_EN	0x1
+
+/*
+ * clkpwr_autoclock register definitions
+ */
+#define LPC32XX_CLKPWR_AUTOCLK_USB_EN		0x40
+#define LPC32XX_CLKPWR_AUTOCLK_IRAM_EN		0x02
+#define LPC32XX_CLKPWR_AUTOCLK_IROM_EN		0x01
+
+/*
+ * Interrupt controller register offsets
+ */
+#define LPC32XX_INTC_MASK(x)			_REG((x) + 0x00)
+#define LPC32XX_INTC_RAW_STAT(x)		_REG((x) + 0x04)
+#define LPC32XX_INTC_STAT(x)			_REG((x) + 0x08)
+#define LPC32XX_INTC_POLAR(x)			_REG((x) + 0x0C)
+#define LPC32XX_INTC_ACT_TYPE(x)		_REG((x) + 0x10)
+#define LPC32XX_INTC_TYPE(x)			_REG((x) + 0x14)
+
+/*
+ * Timer/counter register offsets
+ */
+#define LCP32XX_TIMER_IR(x)			_REG((x) + 0x00)
+#define LCP32XX_TIMER_TCR(x)			_REG((x) + 0x04)
+#define LCP32XX_TIMER_TC(x)			_REG((x) + 0x08)
+#define LCP32XX_TIMER_PR(x)			_REG((x) + 0x0C)
+#define LCP32XX_TIMER_PC(x)			_REG((x) + 0x10)
+#define LCP32XX_TIMER_MCR(x)			_REG((x) + 0x14)
+#define LCP32XX_TIMER_MR0(x)			_REG((x) + 0x18)
+#define LCP32XX_TIMER_MR1(x)			_REG((x) + 0x1C)
+#define LCP32XX_TIMER_MR2(x)			_REG((x) + 0x20)
+#define LCP32XX_TIMER_MR3(x)			_REG((x) + 0x24)
+#define LCP32XX_TIMER_CCR(x)			_REG((x) + 0x28)
+#define LCP32XX_TIMER_CR0(x)			_REG((x) + 0x2C)
+#define LCP32XX_TIMER_CR1(x)			_REG((x) + 0x30)
+#define LCP32XX_TIMER_CR2(x)			_REG((x) + 0x34)
+#define LCP32XX_TIMER_CR3(x)			_REG((x) + 0x38)
+#define LCP32XX_TIMER_EMR(x)			_REG((x) + 0x3C)
+#define LCP32XX_TIMER_CTCR(x)			_REG((x) + 0x70)
+
+/*
+ * ir register definitions
+ */
+#define LCP32XX_TIMER_CNTR_MTCH_BIT(n)		(1 << ((n) & 0x3))
+#define LCP32XX_TIMER_CNTR_CAPT_BIT(n)		(1 << (4 + ((n) & 0x3)))
+
+/*
+ * tcr register definitions
+ */
+#define LCP32XX_TIMER_CNTR_TCR_EN		0x1
+#define LCP32XX_TIMER_CNTR_TCR_RESET		0x2
+
+/*
+ * mcr register definitions
+ */
+#define LCP32XX_TIMER_CNTR_MCR_MTCH(n)		(0x1 << ((n) * 3))
+#define LCP32XX_TIMER_CNTR_MCR_RESET(n)		(0x1 << (((n) * 3) + 1))
+#define LCP32XX_TIMER_CNTR_MCR_STOP(n)		(0x1 << (((n) * 3) + 2))
+
+/*
+ * Standard UART register offsets
+ */
+#define LPC32XX_UART_DLL_FIFO(x)		_REG((x) + 0x00)
+#define LPC32XX_UART_DLM_IER(x)			_REG((x) + 0x04)
+#define LPC32XX_UART_IIR_FCR(x)			_REG((x) + 0x08)
+#define LPC32XX_UART_LCR(x)			_REG((x) + 0x0C)
+#define LPC32XX_UART_MODEM_CTRL(x)		_REG((x) + 0x10)
+#define LPC32XX_UART_LSR(x)			_REG((x) + 0x14)
+#define LPC32XX_UART_MODEM_STATUS(x)		_REG((x) + 0x18)
+#define LPC32XX_UART_RXLEV(x)			_REG((x) + 0x1C)
+
+/*
+ * UART control structure offsets
+ */
+#define _UCREG(x)				_REG(LPC32XX_UART_CTRL_BASE +\
+						(x))
+#define LPC32XX_UARTCTL_CTRL			_UCREG(0x00)
+#define LPC32XX_UARTCTL_CLKMODE			_UCREG(0x04)
+#define LPC32XX_UARTCTL_CLOOP			_UCREG(0x08)
+
+/*
+ * ctrl register definitions
+ */
+#define LPC32XX_UART_U3_MD_CTRL_EN		_BIT(11)
+#define LPC32XX_UART_IRRX6_INV_EN		_BIT(10)
+#define LPC32XX_UART_HDPX_EN			_BIT(9)
+#define LPC32XX_UART_UART6_IRDAMOD_BYPASS	_BIT(5)
+#define LPC32XX_RT_IRTX6_INV_EN			_BIT(4)
+#define LPC32XX_RT_IRTX6_INV_MIR_EN		_BIT(3)
+#define LPC32XX_RT_RX_IRPULSE_3_16_115K		_BIT(2)
+#define LPC32XX_RT_TX_IRPULSE_3_16_115K		_BIT(1)
+#define LPC32XX_UART_U5_ROUTE_TO_USB		_BIT(0)
+
+/*
+ * clkmode register definitions
+ */
+#define LPC32XX_UART_ENABLED_CLOCKS(n)		(((n) >> 16) & 0x7F)
+#define LPC32XX_UART_ENABLED_CLOCK(n, u)	(((n) >> (16 + (u))) & 0x1)
+#define LPC32XX_UART_ENABLED_CLKS_ANY		_BIT(14)
+#define LPC32XX_UART_CLKMODE_OFF		0x0
+#define LPC32XX_UART_CLKMODE_ON			0x1
+#define LPC32XX_UART_CLKMODE_AUTO		0x2
+#define LPC32XX_UART_CLKMODE_MASK(u)		(0x3 << ((((u) - 3) * 2) + 4))
+#define LPC32XX_UART_CLKMODE_LOAD(m, u)		((m) << ((((u) - 3) * 2) + 4))
+
+/*
+ * GPIO Module Register offsets
+ */
+#define _GPREG(x)				_REG(LPC32XX_GPIO_BASE + (x))
+#define LPC32XX_GPIO_P_MUX_SET			_GPREG(0x100)
+#define LPC32XX_GPIO_P_MUX_CLR			_GPREG(0x104)
+#define LPC32XX_GPIO_P_MUX_STATE		_GPREG(0x108)
+#define LPC32XX_GPIO_P3_MUX_SET			_GPREG(0x110)
+#define LPC32XX_GPIO_P3_MUX_CLR			_GPREG(0x114)
+#define LPC32XX_GPIO_P3_MUX_STATE		_GPREG(0x118)
+#define LPC32XX_GPIO_P0_MUX_SET			_GPREG(0x120)
+#define LPC32XX_GPIO_P0_MUX_CLR			_GPREG(0x124)
+#define LPC32XX_GPIO_P0_MUX_STATE		_GPREG(0x128)
+#define LPC32XX_GPIO_P1_MUX_SET			_GPREG(0x130)
+#define LPC32XX_GPIO_P1_MUX_CLR			_GPREG(0x134)
+#define LPC32XX_GPIO_P1_MUX_STATE		_GPREG(0x138)
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/system.h b/arch/arm/mach-lpc32xx/include/mach/system.h
new file mode 100644
index 0000000..df3b0de
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/system.h
@@ -0,0 +1,52 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/system.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	extern void lpc32xx_watchdog_reset(void);
+
+	switch (mode) {
+	case 's':
+	case 'h':
+		printk(KERN_CRIT "RESET: Rebooting system\n");
+
+		/* Disable interrupts */
+		local_irq_disable();
+
+		lpc32xx_watchdog_reset();
+		break;
+
+	default:
+		/* Do nothing */
+		break;
+	}
+
+	/* Wait for watchdog to reset system */
+	while (1)
+		;
+}
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/timex.h b/arch/arm/mach-lpc32xx/include/mach/timex.h
new file mode 100644
index 0000000..1b2a20f
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/timex.h
@@ -0,0 +1,29 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/timex.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+/*
+ * Rate in Hz of the main system oscillator. This value should match
+ * the value 'MAIN_OSC_FREQ' in platform.h
+ */
+#define CLOCK_TICK_RATE	13000000
+
+#endif
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/uncompress.h b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
new file mode 100644
index 0000000..7effa54
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
@@ -0,0 +1,63 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/uncompress.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARM_ARCH_UNCOMPRESS_H
+#define __ASM_ARM_ARCH_UNCOMPRESS_H
+
+#include <linux/io.h>
+
+#include <mach/platform.h>
+
+/*
+ * Uncompress output is hardcoded to standard UART 5
+ */
+
+#define UART_FIFO_CTL_TX_RESET	(1 << 2)
+#define UART_STATUS_TX_MT	(1 << 6)
+
+#define LPC32XX_UART_DLLFIFO_O	0x00
+#define LPC32XX_UART_IIRFCR_O	0x08
+#define LPC32XX_UART_LSR_O	0x14
+
+#define LPC32XX_SUART_DATA	(*(volatile unsigned long *)\
+				(LPC32XX_UART5_BASE + LPC32XX_UART_DLLFIFO_O))
+#define LPC32XX_SUART_STATUS	(*(volatile unsigned long *)\
+				(LPC32XX_UART5_BASE + LPC32XX_UART_LSR_O))
+#define LPC32XX_SUART_FIFOCTRL	(*(volatile unsigned long *)\
+				(LPC32XX_UART5_BASE + LPC32XX_UART_IIRFCR_O))
+
+static inline void putc(int ch)
+{
+	/* Wait for transmit FIFO to empty */
+	while ((LPC32XX_SUART_STATUS & UART_STATUS_TX_MT) == 0)
+		;
+
+	LPC32XX_SUART_DATA = (u32) ch;
+}
+
+static inline void flush(void)
+{
+	LPC32XX_SUART_FIFOCTRL |= UART_FIFO_CTL_TX_RESET;
+}
+
+/* NULL functions; we don't presently need them */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/vmalloc.h b/arch/arm/mach-lpc32xx/include/mach/vmalloc.h
new file mode 100644
index 0000000..d1d936c
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/vmalloc.h
@@ -0,0 +1,24 @@
+/*
+ * arch/arm/mach-lpc32xx/include/mach/vmalloc.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END	0xF0000000
+
+#endif
-- 
1.6.6


_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?= <u.kleine-koenig () pengutronix ! de>
To: linux-arm-kernel
Subject: Re: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 09:31:29 +0000
Message-ID: <20100209093129.GA2284 () pengutronix ! de>
--------------------
Hey Kevin,

On Mon, Feb 08, 2010 at 04:11:22PM -0800, wellsk40@gmail.com wrote:
> From: Kevin Wells <wellsk40@gmail.com>
> 
> Initial header files for the LPC32XX architecture
> 
> Signed-off-by: Kevin Wells <wellsk40@gmail.com>
> ---
>  arch/arm/mach-lpc32xx/include/mach/board.h      |   23 +
>  arch/arm/mach-lpc32xx/include/mach/clkdev.h     |   25 +
>  arch/arm/mach-lpc32xx/include/mach/gpio.h       |   74 +++
>  arch/arm/mach-lpc32xx/include/mach/hardware.h   |   34 ++
>  arch/arm/mach-lpc32xx/include/mach/i2c.h        |   63 ++
>  arch/arm/mach-lpc32xx/include/mach/io.h         |   27 +
>  arch/arm/mach-lpc32xx/include/mach/irqs.h       |  114 ++++
>  arch/arm/mach-lpc32xx/include/mach/memory.h     |   28 +
>  arch/arm/mach-lpc32xx/include/mach/platform.h   |  697 +++++++++++++++++++++++
>  arch/arm/mach-lpc32xx/include/mach/system.h     |   52 ++
>  arch/arm/mach-lpc32xx/include/mach/timex.h      |   29 +
>  arch/arm/mach-lpc32xx/include/mach/uncompress.h |   63 ++
>  arch/arm/mach-lpc32xx/include/mach/vmalloc.h    |   24 +
>  13 files changed, 1253 insertions(+), 0 deletions(-)
> 
> diff --git a/arch/arm/mach-lpc32xx/include/mach/board.h b/arch/arm/mach-lpc32xx/include/mach/board.h
> new file mode 100644
> index 0000000..30424bc
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/board.h
> @@ -0,0 +1,23 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/board.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +
nitpick: there is an empty line too much.

> +#ifndef __ASM_ARCH_BOARD_H
> +#define __ASM_ARCH_BOARD_H
> +
> +#endif
Do you really need this file?

> diff --git a/arch/arm/mach-lpc32xx/include/mach/clkdev.h b/arch/arm/mach-lpc32xx/include/mach/clkdev.h
> new file mode 100644
> index 0000000..9bf0637
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/clkdev.h
> @@ -0,0 +1,25 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/clkdev.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
hmmm, I wonder why you use your nxp address here, but gmail in the
S-o-b.

> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_CLKDEV_H
> +#define __ASM_ARCH_CLKDEV_H
> +
> +#define __clk_get(clk) ({ 1; })
> +#define __clk_put(clk) do { } while (0)
> +
> +#endif
> diff --git a/arch/arm/mach-lpc32xx/include/mach/gpio.h b/arch/arm/mach-lpc32xx/include/mach/gpio.h
> new file mode 100644
> index 0000000..67d03da
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/gpio.h
> @@ -0,0 +1,74 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/gpio.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_GPIO_H
> +#define __ASM_ARCH_GPIO_H
> +
> +#include <asm-generic/gpio.h>
> +
> +/*
> + * Note!
> + * Muxed GP pins need to be setup to the GP state in the board level
> + * code prior to using this driver.
> + * GPI pins : 28xP3 group
> + * GPO pins : 24xP3 group
> + * GPIO pins: 8xP0 group, 24xP1 group, 13xP2 group, 6xP3 group
> + */
> +
> +#define LPC32XX_GPIO_P0_MAX 8
> +#define LPC32XX_GPIO_P1_MAX 24
> +#define LPC32XX_GPIO_P2_MAX 13
> +#define LPC32XX_GPIO_P3_MAX 6
> +#define LPC32XX_GPI_P3_MAX 28
> +#define LPC32XX_GPO_P3_MAX 24
> +
> +#define LPC32XX_GPIO_P0_GRP 0
> +#define LPC32XX_GPIO_P1_GRP (LPC32XX_GPIO_P0_GRP + LPC32XX_GPIO_P0_MAX)
> +#define LPC32XX_GPIO_P2_GRP (LPC32XX_GPIO_P1_GRP + LPC32XX_GPIO_P1_MAX)
> +#define LPC32XX_GPIO_P3_GRP (LPC32XX_GPIO_P2_GRP + LPC32XX_GPIO_P2_MAX)
> +#define LPC32XX_GPI_P3_GRP (LPC32XX_GPIO_P3_GRP + LPC32XX_GPIO_P3_MAX)
> +#define LPC32XX_GPO_P3_GRP (LPC32XX_GPI_P3_GRP + LPC32XX_GPI_P3_MAX)
> +
> +/*
> + * A specific GPIO can be selected with this macro
> + * ie, GPIO_05 can be selected with LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
> + * See the LPC32x0 User's guide for GPIO group numbers
> + */
> +#define LPC32XX_GPIO(x, y) ((x) + (y))
> +
> +static inline int gpio_get_value(unsigned gpio)
> +{
> +	return __gpio_get_value(gpio);
> +}
> +
> +static inline void gpio_set_value(unsigned gpio, int value)
> +{
> +	__gpio_set_value(gpio, value);
> +}
> +
> +static inline int gpio_cansleep(unsigned gpio)
> +{
> +	return __gpio_cansleep(gpio);
> +}
> +
> +static inline int gpio_to_irq(unsigned gpio)
> +{
> +	return __gpio_to_irq(gpio);
> +}
> +
> +#endif
> diff --git a/arch/arm/mach-lpc32xx/include/mach/hardware.h b/arch/arm/mach-lpc32xx/include/mach/hardware.h
> new file mode 100644
> index 0000000..33e1dde
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/hardware.h
> @@ -0,0 +1,34 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/hardware.h
> + *
> + * Copyright (c) 2005 MontaVista Software, Inc. <source@mvista.com>
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_HARDWARE_H
> +#define __ASM_ARCH_HARDWARE_H
> +
> +/*
> + * Start of virtual addresses for IO devices
> + */
> +#define IO_BASE		0xF0000000
> +
> +/*
> + * This macro relies on fact that for all HW i/o addresses bits 20-23 are 0
> + */
> +#define IO_ADDRESS(x)	(((((x) & 0xff000000) >> 4) | ((x) & 0xfffff)) |\
> +			 IO_BASE)
> +
> +#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
Is this cast to unsigned long needed?  AFAIK IO_ADDRESS(x) has
type unsigned for x in { 0x0 ... 0xffffffff } (provided that int uses a
32 bit 2s-complement representation).  If unsigned long is really
needed, maybe put it into the IO_ADDRESS macro?

> +#define io_v2p(x)	((((x) & 0x0ff00000) << 4) | ((x) & 0x000fffff))
> +
> +#endif
> diff --git a/arch/arm/mach-lpc32xx/include/mach/i2c.h b/arch/arm/mach-lpc32xx/include/mach/i2c.h
> new file mode 100644
> index 0000000..a2d810b
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/i2c.h
> @@ -0,0 +1,63 @@
> +/*
> + * PNX4008-specific tweaks for I2C IP3204 block
> + *
> + * Author: Vitaly Wool <vwool@ru.mvista.com>
> + *
> + * 2005 (c) MontaVista Software, Inc. This file is licensed under
> + * the terms of the GNU General Public License version 2. This program
> + * is licensed "as is" without any warranty of any kind, whether express
> + * or implied.
> + */
> +
> +#ifndef __ASM_ARCH_I2C_H__
> +#define __ASM_ARCH_I2C_H__
inconsistant macro naming.  The headers above don't end in _H__, only
_H.

> +
> +enum {
> +	mstatus_tdi = 0x00000001,
> +	mstatus_afi = 0x00000002,
> +	mstatus_nai = 0x00000004,
> +	mstatus_drmi = 0x00000008,
> +	mstatus_active = 0x00000020,
> +	mstatus_scl = 0x00000040,
> +	mstatus_sda = 0x00000080,
> +	mstatus_rff = 0x00000100,
> +	mstatus_rfe = 0x00000200,
> +	mstatus_tff = 0x00000400,
> +	mstatus_tfe = 0x00000800,
> +};
> +
> +enum {
> +	mcntrl_tdie = 0x00000001,
> +	mcntrl_afie = 0x00000002,
> +	mcntrl_naie = 0x00000004,
> +	mcntrl_drmie = 0x00000008,
> +	mcntrl_daie = 0x00000020,
> +	mcntrl_rffie = 0x00000040,
> +	mcntrl_tffie = 0x00000080,
> +	mcntrl_reset = 0x00000100,
> +	mcntrl_cdbmode = 0x00000400,
> +};
> +
> +enum {
> +	rw_bit = 1 << 0,
> +	start_bit = 1 << 8,
> +	stop_bit = 1 << 9,
> +};
> +
> +#define I2C_REG_RX(a)	((a)->ioaddr)		/* Rx FIFO reg (RO) */
> +#define I2C_REG_TX(a)	((a)->ioaddr)		/* Tx FIFO reg (WO) */
> +#define I2C_REG_STS(a)	((a)->ioaddr + 0x04)	/* Status reg (RO) */
> +#define I2C_REG_CTL(a)	((a)->ioaddr + 0x08)	/* Ctl reg */
> +#define I2C_REG_CKL(a)	((a)->ioaddr + 0x0c)	/* Clock divider low */
> +#define I2C_REG_CKH(a)	((a)->ioaddr + 0x10)	/* Clock divider high */
> +#define I2C_REG_ADR(a)	((a)->ioaddr + 0x14)	/* I2C address */
> +#define I2C_REG_RFL(a)	((a)->ioaddr + 0x18)	/* Rx FIFO level (RO) */
> +#define I2C_REG_TFL(a)	((a)->ioaddr + 0x1c)	/* Tx FIFO level (RO) */
> +#define I2C_REG_RXB(a)	((a)->ioaddr + 0x20)	/* Num of bytes Rx-ed (RO) */
> +#define I2C_REG_TXB(a)	((a)->ioaddr + 0x24)	/* Num of bytes Tx-ed (RO) */
> +#define I2C_REG_TXS(a)	((a)->ioaddr + 0x28)	/* Tx slave FIFO (RO) */
> +#define I2C_REG_STFL(a)	((a)->ioaddr + 0x2c)	/* Tx slave FIFO level (RO) */
> +
> +#define I2C_CHIP_NAME		"PNX4008-I2C"
> +
> +#endif				/* __ASM_ARCH_I2C_H___ */
nitpick: is i2c.h needed in the first patch?  (Ok Ok, you work for NXP :-)

> diff --git a/arch/arm/mach-lpc32xx/include/mach/io.h b/arch/arm/mach-lpc32xx/include/mach/io.h
> new file mode 100644
> index 0000000..9b59ab5
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/io.h
> @@ -0,0 +1,27 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/io.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARM_ARCH_IO_H
> +#define __ASM_ARM_ARCH_IO_H
> +
> +#define IO_SPACE_LIMIT	0xffffffff
> +
> +#define __io(a)		__typesafe_io(a)
> +#define __mem_pci(a)	(a)
> +
> +#endif
> diff --git a/arch/arm/mach-lpc32xx/include/mach/irqs.h b/arch/arm/mach-lpc32xx/include/mach/irqs.h
> new file mode 100644
> index 0000000..7a78057
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/irqs.h
> @@ -0,0 +1,114 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/irqs.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARM_ARCH_IRQS_H
> +#define __ASM_ARM_ARCH_IRQS_H
> +
> +/*
> + * MIC interrupts
> + */
> +#define IRQ_LPC32XX_SUB1IRQ		0
> +#define IRQ_LPC32XX_SUB2IRQ		1
> +#define IRQ_LPC32XX_PWM3		3
> +#define IRQ_LPC32XX_PWM4		4
> +#define IRQ_LPC32XX_HSTIMER		5
> +#define IRQ_LPC32XX_WATCH		6
> +#define IRQ_LPC32XX_UART_IIR3		7
> +#define IRQ_LPC32XX_UART_IIR4		8
> +#define IRQ_LPC32XX_UART_IIR5		9
> +#define IRQ_LPC32XX_UART_IIR6		10
> +#define IRQ_LPC32XX_FLASH		11
> +#define IRQ_LPC32XX_SD1			13
> +#define IRQ_LPC32XX_LCD			14
> +#define IRQ_LPC32XX_SD0			15
> +#define IRQ_LPC32XX_TIMER0		16
> +#define IRQ_LPC32XX_TIMER1		17
> +#define IRQ_LPC32XX_TIMER2		18
> +#define IRQ_LPC32XX_TIMER3		19
> +#define IRQ_LPC32XX_SSP0		20
> +#define IRQ_LPC32XX_SSP1		21
> +#define IRQ_LPC32XX_I2S0		22
> +#define IRQ_LPC32XX_I2S1		23
> +#define IRQ_LPC32XX_UART_IIR7		24
> +#define IRQ_LPC32XX_UART_IIR2		25
> +#define IRQ_LPC32XX_UART_IIR1		26
> +#define IRQ_LPC32XX_MSTIMER		27
> +#define IRQ_LPC32XX_DMA			28
> +#define IRQ_LPC32XX_ETHERNET		29
> +#define IRQ_LPC32XX_SUB1FIQ		30
> +#define IRQ_LPC32XX_SUB2FIQ		31
> +
> +/*
> + * SIC1 interrupts start at offset 32
> + */
> +#define IRQ_LPC32XX_JTAG_COMM_TX	(32 + 1)
> +#define IRQ_LPC32XX_JTAG_COMM_RX	(32 + 2)
> +#define IRQ_LPC32XX_GPI_11		(32 + 4)
> +#define IRQ_LPC32XX_TS_P		(32 + 6)
> +#define IRQ_LPC32XX_TS_IRQ		(32 + 7)
> +#define IRQ_LPC32XX_TS_AUX		(32 + 8)
> +#define IRQ_LPC32XX_SPI2		(32 + 12)
> +#define IRQ_LPC32XX_PLLUSB		(32 + 13)
> +#define IRQ_LPC32XX_PLLHCLK		(32 + 14)
> +#define IRQ_LPC32XX_PLL397		(32 + 17)
> +#define IRQ_LPC32XX_I2C_2		(32 + 18)
> +#define IRQ_LPC32XX_I2C_1		(32 + 19)
> +#define IRQ_LPC32XX_RTC			(32 + 20)
> +#define IRQ_LPC32XX_KEY			(32 + 22)
> +#define IRQ_LPC32XX_SPI1		(32 + 23)
> +#define IRQ_LPC32XX_SW			(32 + 24)
> +#define IRQ_LPC32XX_USB_OTG_TIMER	(32 + 25)
> +#define IRQ_LPC32XX_USB_OTG_ATX		(32 + 26)
> +#define IRQ_LPC32XX_USB_HOST		(32 + 27)
> +#define IRQ_LPC32XX_USB_DEV_DMA		(32 + 28)
> +#define IRQ_LPC32XX_USB_DEV_LP		(32 + 29)
> +#define IRQ_LPC32XX_USB_DEV_HP		(32 + 30)
> +#define IRQ_LPC32XX_USB_I2C		(32 + 31)
Maybe make these:

	#define LPC32XX_SIC1_IRQ(x)	(32 + (x))
	#define IRQ_LPC32XX_JTAG_COMM_TX	LPC32XX_SIC1_IRQ(1)

?  Then you can use that in lpc32xx_sic1_handler instead of an
equivalent local #define.

> +/*
> + * SIC2 interrupts start at offset 64
> + */
> +#define IRQ_LPC32XX_GPIO_00		(64 + 0)
> +#define IRQ_LPC32XX_GPIO_01		(64 + 1)
> +#define IRQ_LPC32XX_GPIO_02		(64 + 2)
> +#define IRQ_LPC32XX_GPIO_03		(64 + 3)
> +#define IRQ_LPC32XX_GPIO_04		(64 + 4)
> +#define IRQ_LPC32XX_GPIO_05		(64 + 5)
> +#define IRQ_LPC32XX_SPI2_DATAIN		(64 + 6)
> +#define IRQ_LPC32XX_U2_HCTS		(64 + 7)
> +#define IRQ_LPC32XX_P0_P1_IRQ		(64 + 8)
> +#define IRQ_LPC32XX_GPI_08		(64 + 9)
> +#define IRQ_LPC32XX_GPI_09		(64 + 10)
> +#define IRQ_LPC32XX_GPI_19		(64 + 11)
> +#define IRQ_LPC32XX_U7_HCTS		(64 + 12)
> +#define IRQ_LPC32XX_GPI_07		(64 + 15)
> +#define IRQ_LPC32XX_SDIO		(64 + 18)
> +#define IRQ_LPC32XX_U5_RX		(64 + 19)
> +#define IRQ_LPC32XX_SPI1_DATAIN		(64 + 20)
> +#define IRQ_LPC32XX_GPI_00		(64 + 22)
> +#define IRQ_LPC32XX_GPI_01		(64 + 23)
> +#define IRQ_LPC32XX_GPI_02		(64 + 24)
> +#define IRQ_LPC32XX_GPI_03		(64 + 25)
> +#define IRQ_LPC32XX_GPI_04		(64 + 26)
> +#define IRQ_LPC32XX_GPI_05		(64 + 27)
> +#define IRQ_LPC32XX_GPI_06		(64 + 28)
> +#define IRQ_LPC32XX_SYSCLK		(64 + 31)
> +
> +#define NR_IRQS				96
> +
> +#endif
> diff --git a/arch/arm/mach-lpc32xx/include/mach/memory.h b/arch/arm/mach-lpc32xx/include/mach/memory.h
> new file mode 100644
> index 0000000..b4d8156
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/memory.h
> @@ -0,0 +1,28 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/memory.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_MEMORY_H
> +#define __ASM_ARCH_MEMORY_H
> +
> +/*
> + * Physical DRAM offset of bank 0
> + */
> +#define PHYS_OFFSET	UL(0x80000000)
> +
> +#endif
> +
trailing newline

> diff --git a/arch/arm/mach-lpc32xx/include/mach/platform.h b/arch/arm/mach-lpc32xx/include/mach/platform.h
> new file mode 100644
> index 0000000..e01181f
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/platform.h
> @@ -0,0 +1,697 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/platform.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_PLATFORM_H
> +#define __ASM_ARCH_PLATFORM_H
> +
> +#define _REG(x)					(void __iomem *)(io_p2v(x))
> +
> +#define _SBF(f, v)				((v) << (f))
> +#define _BIT(n)					_SBF(n, 1)
> +
> +/*
> + * AHB 0 physical base addresses
> + */
> +#define LPC32XX_SLC_BASE			0x20020000
> +#define LPC32XX_SSP0_BASE			0x20084000
> +#define LPC32XX_SPI1_BASE			0x20088000
> +#define LPC32XX_SSP1_BASE			0x2008C000
> +#define LPC32XX_SPI2_BASE			0x20090000
> +#define LPC32XX_I2S0_BASE			0x20094000
> +#define LPC32XX_SD_BASE				0x20098000
> +#define LPC32XX_I2S1_BASE			0x2009C000
> +#define LPC32XX_MLC_BASE			0x200A8000
> +#define LPC32XX_AHB0_START			LPC32XX_SLC_BASE
> +#define LPC32XX_AHB0_SIZE			((LPC32XX_MLC_BASE -\
> +						LPC32XX_SLC_BASE) + SZ_4K)
As LPC32XX_AHB0_SIZE isn't a nice difference, I don't see the benefit of
not using a plain number here.

> +/*
> + * AHB 1 physical base addresses
> + */
> +#define LPC32XX_DMA_BASE			0x31000000
> +#define LPC32XX_USB_BASE			0x31020000
> +#define LPC32XX_USBH_BASE			0x31020000
> +#define LPC32XX_USB_OTG_BASE			0x31020000
> +#define LPC32XX_OTG_I2C_BASE			0x31020300
> +#define LPC32XX_LCD_BASE			0x31040000
> +#define LPC32XX_ETHERNET_BASE			0x31060000
> +#define LPC32XX_EMC_BASE			0x31080000
> +#define LPC32XX_ETB_CFG_BASE			0x310C0000
> +#define LPC32XX_ETB_DATA_BASE			0x310E0000
> +#define LPC32XX_AHB1_START			LPC32XX_DMA_BASE
> +#define LPC32XX_AHB1_SIZE			((LPC32XX_EMC_BASE -\
> +						LPC32XX_DMA_BASE) + SZ_4K)
> +/*
> + * FAB physical base addresses
> + */
> +#define LPC32XX_CLK_PM_BASE			0x40004000
> +#define LPC32XX_MIC_BASE			0x40008000
> +#define LPC32XX_SIC1_BASE			0x4000C000
> +#define LPC32XX_SIC2_BASE			0x40010000
> +#define LPC32XX_HS_UART1_BASE			0x40014000
> +#define LPC32XX_HS_UART2_BASE			0x40018000
> +#define LPC32XX_HS_UART7_BASE			0x4001C000
> +#define LPC32XX_RTC_BASE			0x40024000
> +#define LPC32XX_RTC_RAM_BASE			0x40024080
> +#define LPC32XX_GPIO_BASE			0x40028000
> +#define LPC32XX_PWM3_BASE			0x4002C000
> +#define LPC32XX_PWM4_BASE			0x40030000
> +#define LPC32XX_MSTIM_BASE			0x40034000
> +#define LPC32XX_HSTIM_BASE			0x40038000
> +#define LPC32XX_WDTIM_BASE			0x4003C000
> +#define LPC32XX_DEBUG_CTRL_BASE			0x40040000
> +#define LPC32XX_TIMER0_BASE			0x40044000
> +#define LPC32XX_ADC_BASE			0x40048000
> +#define LPC32XX_TIMER1_BASE			0x4004C000
> +#define LPC32XX_KSCAN_BASE			0x40050000
> +#define LPC32XX_UART_CTRL_BASE			0x40054000
> +#define LPC32XX_TIMER2_BASE			0x40058000
> +#define LPC32XX_PWM1_BASE			0x4005C000
> +#define LPC32XX_PWM2_BASE			0x4005C004
> +#define LPC32XX_TIMER3_BASE			0x40060000
> +
> +/*
> + * APB physical base addresses
> + */
> +#define LPC32XX_UART3_BASE			0x40080000
> +#define LPC32XX_UART4_BASE			0x40088000
> +#define LPC32XX_UART5_BASE			0x40090000
> +#define LPC32XX_UART6_BASE			0x40098000
> +#define LPC32XX_I2C1_BASE			0x400A0000
> +#define LPC32XX_I2C2_BASE			0x400A8000
> +
> +/*
> + * FAB and APB base and sizing
> + */
> +#define LPC32XX_FABAPB_START			LPC32XX_CLK_PM_BASE
> +#define LPC32XX_FABAPB_SIZE			((LPC32XX_I2C2_BASE -\
> +						LPC32XX_CLK_PM_BASE) + SZ_4K)
> +
> +/*
> + * Internal memory Bases
> + */
> +#define LPC32XX_IRAM_BASE			0x08000000
> +#define LPC32XX_IROM_BASE			0x0C000000
> +
> +/*
> + * External Static Memory Bank Address Space Bases
> + */
> +#define LPC32XX_EMC_CS0_BASE			0xE0000000
> +#define LPC32XX_EMC_CS1_BASE			0xE1000000
> +#define LPC32XX_EMC_CS2_BASE			0xE2000000
> +#define LPC32XX_EMC_CS3_BASE			0xE3000000
> +
> +/*
> + * External SDRAM Memory Bank Address Space Bases
> + */
> +#define LPC32XX_EMC_DYCS0_BASE			0x80000000
> +#define LPC32XX_EMC_DYCS1_BASE			0xA0000000
> +
> +/*
> + * Clock and crystal information
> + */
> +#define LPC32XX_MAIN_OSC_FREQ			13000000
> +#define LPC32XX_CLOCK_OSC_FREQ			32768
> +
> +/*
> + * Clock and Power control register offsets
> + */
> +#define _PMREG(x)				_REG(LPC32XX_CLK_PM_BASE + (x))
> +#define LPC32XX_CLKPWR_DEBUG_CTRL		_PMREG(0x000)
> +#define LPC32XX_CLKPWR_BOOTMAP			_PMREG(0x014)
> +#define LPC32XX_CLKPWR_P01_ER			_PMREG(0x018)
> +#define LPC32XX_CLKPWR_USBCLK_PDIV		_PMREG(0x01C)
> +#define LPC32XX_CLKPWR_INT_ER			_PMREG(0x020)
> +#define LPC32XX_CLKPWR_INT_RS			_PMREG(0x024)
> +#define LPC32XX_CLKPWR_INT_SR			_PMREG(0x028)
> +#define LPC32XX_CLKPWR_INT_AP			_PMREG(0x02C)
> +#define LPC32XX_CLKPWR_PIN_ER			_PMREG(0x030)
> +#define LPC32XX_CLKPWR_PIN_RS			_PMREG(0x034)
> +#define LPC32XX_CLKPWR_PIN_SR			_PMREG(0x038)
> +#define LPC32XX_CLKPWR_PIN_AP			_PMREG(0x03C)
> +#define LPC32XX_CLKPWR_HCLK_DIV			_PMREG(0x040)
> +#define LPC32XX_CLKPWR_PWR_CTRL			_PMREG(0x044)
> +#define LPC32XX_CLKPWR_PLL397_CTRL		_PMREG(0x048)
> +#define LPC32XX_CLKPWR_MAIN_OSC_CTRL		_PMREG(0x04C)
> +#define LPC32XX_CLKPWR_SYSCLK_CTRL		_PMREG(0x050)
> +#define LPC32XX_CLKPWR_LCDCLK_CTRL		_PMREG(0x054)
> +#define LPC32XX_CLKPWR_HCLKPLL_CTRL		_PMREG(0x058)
> +#define LPC32XX_CLKPWR_ADC_CLK_CTRL_1		_PMREG(0x060)
> +#define LPC32XX_CLKPWR_USB_CTRL			_PMREG(0x064)
> +#define LPC32XX_CLKPWR_SDRAMCLK_CTRL		_PMREG(0x068)
> +#define LPC32XX_CLKPWR_DDR_LAP_NOM		_PMREG(0x06C)
> +#define LPC32XX_CLKPWR_DDR_LAP_COUNT		_PMREG(0x070)
> +#define LPC32XX_CLKPWR_DDR_LAP_DELAY		_PMREG(0x074)
> +#define LPC32XX_CLKPWR_SSP_CLK_CTRL		_PMREG(0x078)
> +#define LPC32XX_CLKPWR_I2S_CLK_CTRL		_PMREG(0x07C)
> +#define LPC32XX_CLKPWR_MS_CTRL			_PMREG(0x080)
> +#define LPC32XX_CLKPWR_MACCLK_CTRL		_PMREG(0x090)
> +#define LPC32XX_CLKPWR_TEST_CLK_SEL		_PMREG(0x0A4)
> +#define LPC32XX_CLKPWR_SFW_INT			_PMREG(0x0A8)
> +#define LPC32XX_CLKPWR_I2C_CLK_CTRL		_PMREG(0x0AC)
> +#define LPC32XX_CLKPWR_KEY_CLK_CTRL		_PMREG(0x0B0)
> +#define LPC32XX_CLKPWR_ADC_CLK_CTRL		_PMREG(0x0B4)
> +#define LPC32XX_CLKPWR_PWM_CLK_CTRL		_PMREG(0x0B8)
> +#define LPC32XX_CLKPWR_TIMER_CLK_CTRL		_PMREG(0x0BC)
> +#define LPC32XX_CLKPWR_TIMERS_PWMS_CLK_CTRL_1	_PMREG(0x0C0)
> +#define LPC32XX_CLKPWR_SPI_CLK_CTRL		_PMREG(0x0C4)
> +#define LPC32XX_CLKPWR_NAND_CLK_CTRL		_PMREG(0x0C8)
> +#define LPC32XX_CLKPWR_UART3_CLK_CTRL		_PMREG(0x0D0)
> +#define LPC32XX_CLKPWR_UART4_CLK_CTRL		_PMREG(0x0D4)
> +#define LPC32XX_CLKPWR_UART5_CLK_CTRL		_PMREG(0x0D8)
> +#define LPC32XX_CLKPWR_UART6_CLK_CTRL		_PMREG(0x0DC)
> +#define LPC32XX_CLKPWR_IRDA_CLK_CTRL		_PMREG(0x0E0)
> +#define LPC32XX_CLKPWR_UART_CLK_CTRL		_PMREG(0x0E4)
> +#define LPC32XX_CLKPWR_DMA_CLK_CTRL		_PMREG(0x0E8)
> +#define LPC32XX_CLKPWR_AUTOCLOCK		_PMREG(0x0EC)
> +#define LPC32XX_CLKPWR_DEVID(x)			_PMREG(0x130 + (x))
> +
> +/*
> + * clkpwr_debug_ctrl register definitions
> +*/
> +#define LPC32XX_CLKPWR_VFP_CLOCK_ENABLE_BIT	_BIT(4)
> +
> +/*
> + * clkpwr_bootmap register definitions
> + */
> +#define LPC32XX_CLKPWR_BOOTMAP_SEL_BIT		_BIT(1)
> +
> +/*
> + * clkpwr_start_gpio register bit definitions
> + */
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO23_BIT	_BIT(31)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO22_BIT	_BIT(30)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO21_BIT	_BIT(29)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO20_BIT	_BIT(28)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO19_BIT	_BIT(27)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO18_BIT	_BIT(26)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO17_BIT	_BIT(25)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO16_BIT	_BIT(24)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO15_BIT	_BIT(23)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO14_BIT	_BIT(22)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO13_BIT	_BIT(21)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO12_BIT	_BIT(20)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO11_BIT	_BIT(19)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO10_BIT	_BIT(18)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO9_BIT	_BIT(17)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO8_BIT	_BIT(16)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO7_BIT	_BIT(15)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO6_BIT	_BIT(14)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO5_BIT	_BIT(13)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO4_BIT	_BIT(12)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO3_BIT	_BIT(11)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO2_BIT	_BIT(10)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO1_BIT	_BIT(9)
> +#define LPC32XX_CLKPWR_GPIOSRC_P1IO0_BIT	_BIT(8)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO7_BIT	_BIT(7)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO6_BIT	_BIT(6)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO5_BIT	_BIT(5)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO4_BIT	_BIT(4)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO3_BIT	_BIT(3)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO2_BIT	_BIT(2)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO1_BIT	_BIT(1)
> +#define LPC32XX_CLKPWR_GPIOSRC_P0IO0_BIT	_BIT(0)
> +
> +/*
> + * clkpwr_usbclk_pdiv register definitions
> + */
> +#define LPC32XX_CLKPWR_SET_PLL_USBPDIV(n)	((n) & 0xF)
> +#define LPC32XX_CLKPWR_USBPDIV_PLL_MASK		0xF
are these two 0xf the same?  If so, you can define
LPC32XX_CLKPWR_SET_PLL_USBPDIV without hardcoding it?

> +
> +/*
> + * clkpwr_start_int, clkpwr_start_raw_sts_int, clkpwr_start_sts_int,
> + * clkpwr_start_pol_int, register bit definitions
> + */
> +#define LPC32XX_CLKPWR_INTSRC_ADC_BIT		_BIT(31)
> +#define LPC32XX_CLKPWR_INTSRC_TS_P_BIT		_BIT(30)
> +#define LPC32XX_CLKPWR_INTSRC_TS_AUX_BIT	_BIT(29)
> +#define LPC32XX_CLKPWR_INTSRC_USBAHNEEDCLK_BIT	_BIT(26)
> +#define LPC32XX_CLKPWR_INTSRC_MSTIMER_BIT	_BIT(25)
> +#define LPC32XX_CLKPWR_INTSRC_RTC_BIT		_BIT(24)
> +#define LPC32XX_CLKPWR_INTSRC_USBNEEDCLK_BIT	_BIT(23)
> +#define LPC32XX_CLKPWR_INTSRC_USB_BIT		_BIT(22)
> +#define LPC32XX_CLKPWR_INTSRC_I2C_BIT		_BIT(21)
> +#define LPC32XX_CLKPWR_INTSRC_USBOTGTIMER_BIT	_BIT(20)
> +#define LPC32XX_CLKPWR_INTSRC_USBATXINT_BIT	_BIT(19)
> +#define LPC32XX_CLKPWR_INTSRC_KEY_BIT		_BIT(16)
> +#define LPC32XX_CLKPWR_INTSRC_MAC_BIT		_BIT(7)
> +#define LPC32XX_CLKPWR_INTSRC_P0P1_BIT		_BIT(6)
> +#define LPC32XX_CLKPWR_INTSRC_GPIO_05_BIT	_BIT(5)
> +#define LPC32XX_CLKPWR_INTSRC_GPIO_04_BIT	_BIT(4)
> +#define LPC32XX_CLKPWR_INTSRC_GPIO_03_BIT	_BIT(3)
> +#define LPC32XX_CLKPWR_INTSRC_GPIO_02_BIT	_BIT(2)
> +#define LPC32XX_CLKPWR_INTSRC_GPIO_01_BIT	_BIT(1)
> +#define LPC32XX_CLKPWR_INTSRC_GPIO_00_BIT	_BIT(0)
> +
> +/*
> + * clkpwr_start_pin, clkpwr_start_raw_sts_pin, clkpwr_start_sts_pin,
> + * clkpwr_start_pol_pin register bit definitions
> + */
> +#define LPC32XX_CLKPWR_EXTSRC_U7_RX_BIT		_BIT(31)
> +#define LPC32XX_CLKPWR_EXTSRC_U7_HCTS_BIT	_BIT(30)
> +#define LPC32XX_CLKPWR_EXTSRC_U6_IRRX_BIT	_BIT(28)
> +#define LPC32XX_CLKPWR_EXTSRC_U5_RX_BIT		_BIT(26)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_28_BIT	_BIT(25)
> +#define LPC32XX_CLKPWR_EXTSRC_U3_RX_BIT		_BIT(24)
> +#define LPC32XX_CLKPWR_EXTSRC_U2_HCTS_BIT	_BIT(23)
> +#define LPC32XX_CLKPWR_EXTSRC_U2_RX_BIT		_BIT(22)
> +#define LPC32XX_CLKPWR_EXTSRC_U1_RX_BIT		_BIT(21)
> +#define LPC32XX_CLKPWR_EXTSRC_MSDIO_INT_BIT	_BIT(18)
> +#define LPC32XX_CLKPWR_EXTSRC_MSDIO_SRT_BIT	_BIT(17)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_06_BIT	_BIT(16)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_05_BIT	_BIT(15)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_04_BIT	_BIT(14)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_03_BIT	_BIT(13)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_02_BIT	_BIT(12)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_01_BIT	_BIT(11)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_00_BIT	_BIT(10)
> +#define LPC32XX_CLKPWR_EXTSRC_SYSCLKEN_BIT	_BIT(9)
> +#define LPC32XX_CLKPWR_EXTSRC_SPI1_DATIN_BIT	_BIT(8)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_07_BIT	_BIT(7)
> +#define LPC32XX_CLKPWR_EXTSRC_SPI2_DATIN_BIT	_BIT(6)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_19_BIT	_BIT(5)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_09_BIT	_BIT(4)
> +#define LPC32XX_CLKPWR_EXTSRC_GPI_08_BIT	_BIT(3)
> +
> +/*
> + * clkpwr_hclk_div register definitions
> + */
> +#define LPC32XX_CLKPWR_HCLKDIV_DDRCLK_STOP	(0x0 << 7)
> +#define LPC32XX_CLKPWR_HCLKDIV_DDRCLK_NORM	(0x1 << 7)
> +#define LPC32XX_CLKPWR_HCLKDIV_DDRCLK_HALF	(0x2 << 7)
> +#define LPC32XX_CLKPWR_HCLKDIV_PCLK_DIV(n)	(((n) & 0x1F) << 2)
> +#define LPC32XX_CLKPWR_HCLKDIV_DIV_2POW(n)	((n) & 0x3)
> +
> +/*
> + * clkpwr_pwr_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_CTRL_FORCE_PCLK		_BIT(10)
> +#define LPC32XX_CLKPWR_SDRAM_SELF_RFSH		_BIT(9)
> +#define LPC32XX_CLKPWR_UPD_SDRAM_SELF_RFSH	_BIT(8)
> +#define LPC32XX_CLKPWR_AUTO_SDRAM_SELF_RFSH	_BIT(7)
> +#define LPC32XX_CLKPWR_HIGHCORE_STATE_BIT	_BIT(5)
> +#define LPC32XX_CLKPWR_SYSCLKEN_STATE_BIT	_BIT(4)
> +#define LPC32XX_CLKPWR_SYSCLKEN_GPIO_EN		_BIT(3)
> +#define LPC32XX_CLKPWR_SELECT_RUN_MODE		_BIT(2)
> +#define LPC32XX_CLKPWR_HIGHCORE_GPIO_EN		_BIT(1)
> +#define LPC32XX_CLKPWR_STOP_MODE_CTRL		_BIT(0)
> +
> +/*
> + * clkpwr_pll397_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_PLL397_MSLOCK_STS	_BIT(10)
> +#define LPC32XX_CLKPWR_PLL397_BYPASS		_BIT(9)
> +#define LPC32XX_CLKPWR_PLL397_BIAS_NORM		0x000
> +#define LPC32XX_CLKPWR_PLL397_BIAS_N12_5	0x040
> +#define LPC32XX_CLKPWR_PLL397_BIAS_N25		0x080
> +#define LPC32XX_CLKPWR_PLL397_BIAS_N37_5	0x0C0
> +#define LPC32XX_CLKPWR_PLL397_BIAS_P12_5	0x100
> +#define LPC32XX_CLKPWR_PLL397_BIAS_P25		0x140
> +#define LPC32XX_CLKPWR_PLL397_BIAS_P37_5	0x180
> +#define LPC32XX_CLKPWR_PLL397_BIAS_P50		0x1C0
> +#define LPC32XX_CLKPWR_PLL397_BIAS_MASK		0x1C0
> +#define LPC32XX_CLKPWR_SYSCTRL_PLL397_DIS	_BIT(1)
> +#define LPC32XX_CLKPWR_SYSCTRL_PLL397_STS	_BIT(0)
> +
> +/*
> + * clkpwr_main_osc_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_MOSC_ADD_CAP(n)		(((n) & 0x7F) << 2)
> +#define LPC32XX_CLKPWR_MOSC_CAP_MASK		(0x7F << 2)
> +#define LPC32XX_CLKPWR_TEST_MODE		_BIT(1)
> +#define LPC32XX_CLKPWR_MOSC_DISABLE		_BIT(0)
> +
> +/*
> + * clkpwr_sysclk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_SYSCTRL_BP_TRIG(n)	(((n) & 0x3FF) << 2)
> +#define LPC32XX_CLKPWR_SYSCTRL_BP_MASK		(0x3FF << 2)
> +#define LPC32XX_CLKPWR_SYSCTRL_USEPLL397	_BIT(1)
> +#define LPC32XX_CLKPWR_SYSCTRL_SYSCLKMUX	_BIT(0)
> +
> +/*
> + * clkpwr_lcdclk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT12	0x000
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT16	0x040
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT15	0x080
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT24	0x0C0
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_STN4M	0x100
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_STN8C	0x140
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_DSTN4M	0x180
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_DSTN8C	0x1C0
> +#define LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_MSK	0x01C0
> +#define LPC32XX_CLKPWR_LCDCTRL_CLK_EN		0x020
> +#define LPC32XX_CLKPWR_LCDCTRL_SET_PSCALE(n)	((n - 1) & 0x1F)
> +#define LPC32XX_CLKPWR_LCDCTRL_PSCALE_MSK	0x001F
> +
> +/*
> + * clkpwr_hclkpll_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_HCLKPLL_POWER_UP		_BIT(16)
> +#define LPC32XX_CLKPWR_HCLKPLL_CCO_BYPASS	_BIT(15)
> +#define LPC32XX_CLKPWR_HCLKPLL_POSTDIV_BYPASS	_BIT(14)
> +#define LPC32XX_CLKPWR_HCLKPLL_FDBK_SEL_FCLK	_BIT(13)
> +#define LPC32XX_CLKPWR_HCLKPLL_POSTDIV_2POW(n)	(((n) & 0x3) << 11)
> +#define LPC32XX_CLKPWR_HCLKPLL_PREDIV_PLUS1(n)	(((n) & 0x3) << 9)
> +#define LPC32XX_CLKPWR_HCLKPLL_PLLM(n)		(((n) & 0xFF) << 1)
> +#define LPC32XX_CLKPWR_HCLKPLL_PLL_STS		_BIT(0)
> +
> +/*
> + * clkpwr_adc_clk_ctrl_1 register definitions
> + */
> +#define LPC32XX_CLKPWR_ADCCTRL1_RTDIV(n)	(((n) & 0xFF) << 0)
> +#define LPC32XX_CLKPWR_ADCCTRL1_PCLK_SEL	_BIT(8)
> +
> +/*
> + * clkpwr_usb_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_USBCTRL_HCLK_EN		_BIT(24)
> +#define LPC32XX_CLKPWR_USBCTRL_USBI2C_EN	_BIT(23)
> +#define LPC32XX_CLKPWR_USBCTRL_USBDVND_EN	_BIT(22)
> +#define LPC32XX_CLKPWR_USBCTRL_USBHSTND_EN	_BIT(21)
> +#define LPC32XX_CLKPWR_USBCTRL_PU_ADD		(0x0 << 19)
> +#define LPC32XX_CLKPWR_USBCTRL_BUS_KEEPER	(0x1 << 19)
> +#define LPC32XX_CLKPWR_USBCTRL_PD_ADD		(0x3 << 19)
> +#define LPC32XX_CLKPWR_USBCTRL_CLK_EN2		_BIT(18)
> +#define LPC32XX_CLKPWR_USBCTRL_CLK_EN1		_BIT(17)
> +#define LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP	_BIT(16)
> +#define LPC32XX_CLKPWR_USBCTRL_CCO_BYPASS	_BIT(15)
> +#define LPC32XX_CLKPWR_USBCTRL_POSTDIV_BYPASS	_BIT(14)
> +#define LPC32XX_CLKPWR_USBCTRL_FDBK_SEL_FCLK	_BIT(13)
> +#define LPC32XX_CLKPWR_USBCTRL_POSTDIV_2POW(n)	(((n) & 0x3) << 11)
> +#define LPC32XX_CLKPWR_USBCTRL_PREDIV_PLUS1(n)	(((n) & 0x3) << 9)
> +#define LPC32XX_CLKPWR_USBCTRL_FDBK_PLUS1(n)	(((n) & 0xFF) << 1)
> +#define LPC32XX_CLKPWR_USBCTRL_PLL_STS		_BIT(0)
> +
> +/*
> + * clkpwr_sdramclk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_SDRCLK_FASTSLEW_CLK	_BIT(22)
> +#define LPC32XX_CLKPWR_SDRCLK_FASTSLEW		_BIT(21)
> +#define LPC32XX_CLKPWR_SDRCLK_FASTSLEW_DAT	_BIT(20)
> +#define LPC32XX_CLKPWR_SDRCLK_SW_DDR_RESET	_BIT(19)
> +#define LPC32XX_CLKPWR_SDRCLK_HCLK_DLY(n)	(((n) & 0x1F) << 14)
> +#define LPC32XX_CLKPWR_SDRCLK_DLY_ADDR_STS	_BIT(13)
> +#define LPC32XX_CLKPWR_SDRCLK_SENS_FACT(n)	(((n) & 0x7) << 10)
> +#define LPC32XX_CLKPWR_SDRCLK_USE_CAL		_BIT(9)
> +#define LPC32XX_CLKPWR_SDRCLK_DO_CAL		_BIT(8)
> +#define LPC32XX_CLKPWR_SDRCLK_CAL_ON_RTC	_BIT(7)
> +#define LPC32XX_CLKPWR_SDRCLK_DQS_DLY(n)	(((n) & 0x1F) << 2)
> +#define LPC32XX_CLKPWR_SDRCLK_USE_DDR		_BIT(1)
> +#define LPC32XX_CLKPWR_SDRCLK_CLK_DIS		_BIT(0)
> +
> +/*
> + * clkpwr_ssp_blk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP1RX	_BIT(5)
> +#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP1TX	_BIT(4)
> +#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP0RX	_BIT(3)
> +#define LPC32XX_CLKPWR_SSPCTRL_DMA_SSP0TX	_BIT(2)
> +#define LPC32XX_CLKPWR_SSPCTRL_SSPCLK1_EN	_BIT(1)
> +#define LPC32XX_CLKPWR_SSPCTRL_SSPCLK0_EN	_BIT(0)
> +
> +/*
> + * clkpwr_i2s_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_I2SCTRL_I2S1_RX_FOR_TX	_BIT(6)
> +#define LPC32XX_CLKPWR_I2SCTRL_I2S1_TX_FOR_RX	_BIT(5)
> +#define LPC32XX_CLKPWR_I2SCTRL_I2S1_USE_DMA	_BIT(4)
> +#define LPC32XX_CLKPWR_I2SCTRL_I2S0_RX_FOR_TX	_BIT(3)
> +#define LPC32XX_CLKPWR_I2SCTRL_I2S0_TX_FOR_RX	_BIT(2)
> +#define LPC32XX_CLKPWR_I2SCTRL_I2SCLK1_EN	_BIT(1)
> +#define LPC32XX_CLKPWR_I2SCTRL_I2SCLK0_EN	_BIT(0)
> +
> +/*
> + * clkpwr_ms_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_MSCARD_MSDIO_PIN_DIS	_BIT(10)
> +#define LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN	_BIT(9)
> +#define LPC32XX_CLKPWR_MSCARD_MSDIO23_DIS	_BIT(8)
> +#define LPC32XX_CLKPWR_MSCARD_MSDIO1_DIS	_BIT(7)
> +#define LPC32XX_CLKPWR_MSCARD_MSDIO0_DIS	_BIT(6)
> +#define LPC32XX_CLKPWR_MSCARD_SDCARD_EN		_BIT(5)
> +#define LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(n)	((n) & 0xF)
> +
> +/*
> + * clkpwr_macclk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_MACCTRL_NO_ENET_PIS	0x00
> +#define LPC32XX_CLKPWR_MACCTRL_USE_MII_PINS	0x08
> +#define LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS	0x18
> +#define LPC32XX_CLKPWR_MACCTRL_PINS_MSK		0x18
> +#define LPC32XX_CLKPWR_MACCTRL_DMACLK_EN	_BIT(2)
> +#define LPC32XX_CLKPWR_MACCTRL_MMIOCLK_EN	_BIT(1)
> +#define LPC32XX_CLKPWR_MACCTRL_HRCCLK_EN	_BIT(0)
> +
> +/*
> + * clkpwr_test_clk_sel register definitions
> + */
> +#define LPC32XX_CLKPWR_TESTCLK1_SEL_PERCLK	(0x0 << 5)
> +#define LPC32XX_CLKPWR_TESTCLK1_SEL_RTC		(0x1 << 5)
> +#define LPC32XX_CLKPWR_TESTCLK1_SEL_MOSC	(0x2 << 5)
> +#define LPC32XX_CLKPWR_TESTCLK1_SEL_MASK	(0x3 << 5)
> +#define LPC32XX_CLKPWR_TESTCLK_TESTCLK1_EN	_BIT(4)
> +#define LPC32XX_CLKPWR_TESTCLK2_SEL_HCLK	(0x0 << 1)
> +#define LPC32XX_CLKPWR_TESTCLK2_SEL_PERCLK	(0x1 << 1)
> +#define LPC32XX_CLKPWR_TESTCLK2_SEL_USBCLK	(0x2 << 1)
> +#define LPC32XX_CLKPWR_TESTCLK2_SEL_MOSC	(0x5 << 1)
> +#define LPC32XX_CLKPWR_TESTCLK2_SEL_PLL397	(0x7 << 1)
> +#define LPC32XX_CLKPWR_TESTCLK2_SEL_MASK	(0x7 << 1)
> +#define LPC32XX_CLKPWR_TESTCLK_TESTCLK2_EN	_BIT(0)
> +
> +/*
> + * clkpwr_sw_int register definitions
> + */
> +#define LPC32XX_CLKPWR_SW_INT(n)		(_BIT(0) | (((n) & 0x7F) << 1))
> +#define LPC32XX_CLKPWR_SW_GET_ARG(n)		(((n) & 0xFE) >> 1)
> +
> +/*
> + * clkpwr_i2c_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_I2CCLK_USBI2CHI_DRIVE	_BIT(4)
> +#define LPC32XX_CLKPWR_I2CCLK_I2C2HI_DRIVE	_BIT(3)
> +#define LPC32XX_CLKPWR_I2CCLK_I2C1HI_DRIVE	_BIT(2)
> +#define LPC32XX_CLKPWR_I2CCLK_I2C2CLK_EN	_BIT(1)
> +#define LPC32XX_CLKPWR_I2CCLK_I2C1CLK_EN	_BIT(0)
> +
> +/*
> + * clkpwr_key_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_KEYCLKCTRL_CLK_EN	0x1
> +
> +/*
> + * clkpwr_adc_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_ADC32CLKCTRL_CLK_EN	0x1
> +
> +/*
> + * clkpwr_pwm_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_PWMCLK_PWM2_DIV(n)	(((n) & 0xF) << 8)
> +#define LPC32XX_CLKPWR_PWMCLK_PWM1_DIV(n)	(((n) & 0xF) << 4)
> +#define LPC32XX_CLKPWR_PWMCLK_PWM2SEL_PCLK	0x8
> +#define LPC32XX_CLKPWR_PWMCLK_PWM2CLK_EN	0x4
> +#define LPC32XX_CLKPWR_PWMCLK_PWM1SEL_PCLK	0x2
> +#define LPC32XX_CLKPWR_PWMCLK_PWM1CLK_EN	0x1
> +
> +/*
> + * clkpwr_timer_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_PWMCLK_HSTIMER_EN	0x2
> +#define LPC32XX_CLKPWR_PWMCLK_WDOG_EN		0x1
> +
> +/*
> + * clkpwr_timers_pwms_clk_ctrl_1 register definitions
> + */
> +#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER3_EN	0x20
> +#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER2_EN	0x10
> +#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER1_EN	0x08
> +#define LPC32XX_CLKPWR_TMRPWMCLK_TIMER0_EN	0x04
> +#define LPC32XX_CLKPWR_TMRPWMCLK_PWM4_EN	0x02
> +#define LPC32XX_CLKPWR_TMRPWMCLK_PWM3_EN	0x01
> +
> +/*
> + * clkpwr_spi_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_SPICLK_SET_SPI2DATIO	0x80
> +#define LPC32XX_CLKPWR_SPICLK_SET_SPI2CLK	0x40
> +#define LPC32XX_CLKPWR_SPICLK_USE_SPI2		0x20
> +#define LPC32XX_CLKPWR_SPICLK_SPI2CLK_EN	0x10
> +#define LPC32XX_CLKPWR_SPICLK_SET_SPI1DATIO	0x08
> +#define LPC32XX_CLKPWR_SPICLK_SET_SPI1CLK	0x04
> +#define LPC32XX_CLKPWR_SPICLK_USE_SPI1		0x02
> +#define LPC32XX_CLKPWR_SPICLK_SPI1CLK_EN	0x01
> +
> +/*
> + * clkpwr_nand_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_NANDCLK_INTSEL_MLC	0x20
> +#define LPC32XX_CLKPWR_NANDCLK_DMA_RNB		0x10
> +#define LPC32XX_CLKPWR_NANDCLK_DMA_INT		0x08
> +#define LPC32XX_CLKPWR_NANDCLK_SEL_SLC		0x04
> +#define LPC32XX_CLKPWR_NANDCLK_MLCCLK_EN	0x02
> +#define LPC32XX_CLKPWR_NANDCLK_SLCCLK_EN	0x01
> +
> +/*
> + * clkpwr_uart3_clk_ctrl, clkpwr_uart4_clk_ctrl, clkpwr_uart5_clk_ctrl
> + * and clkpwr_uart6_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_UART_Y_DIV(y)		((y) & 0xFF)
> +#define LPC32XX_CLKPWR_UART_X_DIV(x)		(((x) & 0xFF) << 8)
> +#define LPC32XX_CLKPWR_UART_USE_HCLK		_BIT(16)
> +
> +/*
> + * clkpwr_irda_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_IRDA_Y_DIV(y)		((y) & 0xFF)
> +#define LPC32XX_CLKPWR_IRDA_X_DIV(x)		(((x) & 0xFF) << 8)
> +
> +/*
> + * clkpwr_uart_clk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_UARTCLKCTRL_UART6_EN	_BIT(3)
> +#define LPC32XX_CLKPWR_UARTCLKCTRL_UART5_EN	_BIT(2)
> +#define LPC32XX_CLKPWR_UARTCLKCTRL_UART4_EN	_BIT(1)
> +#define LPC32XX_CLKPWR_UARTCLKCTRL_UART3_EN	_BIT(0)
> +
> +/*
> + * clkpwr_dmaclk_ctrl register definitions
> + */
> +#define LPC32XX_CLKPWR_DMACLKCTRL_CLK_EN	0x1
> +
> +/*
> + * clkpwr_autoclock register definitions
> + */
> +#define LPC32XX_CLKPWR_AUTOCLK_USB_EN		0x40
> +#define LPC32XX_CLKPWR_AUTOCLK_IRAM_EN		0x02
> +#define LPC32XX_CLKPWR_AUTOCLK_IROM_EN		0x01
> +
> +/*
> + * Interrupt controller register offsets
> + */
> +#define LPC32XX_INTC_MASK(x)			_REG((x) + 0x00)
> +#define LPC32XX_INTC_RAW_STAT(x)		_REG((x) + 0x04)
> +#define LPC32XX_INTC_STAT(x)			_REG((x) + 0x08)
> +#define LPC32XX_INTC_POLAR(x)			_REG((x) + 0x0C)
> +#define LPC32XX_INTC_ACT_TYPE(x)		_REG((x) + 0x10)
> +#define LPC32XX_INTC_TYPE(x)			_REG((x) + 0x14)
> +
> +/*
> + * Timer/counter register offsets
> + */
> +#define LCP32XX_TIMER_IR(x)			_REG((x) + 0x00)
> +#define LCP32XX_TIMER_TCR(x)			_REG((x) + 0x04)
> +#define LCP32XX_TIMER_TC(x)			_REG((x) + 0x08)
> +#define LCP32XX_TIMER_PR(x)			_REG((x) + 0x0C)
> +#define LCP32XX_TIMER_PC(x)			_REG((x) + 0x10)
> +#define LCP32XX_TIMER_MCR(x)			_REG((x) + 0x14)
> +#define LCP32XX_TIMER_MR0(x)			_REG((x) + 0x18)
> +#define LCP32XX_TIMER_MR1(x)			_REG((x) + 0x1C)
> +#define LCP32XX_TIMER_MR2(x)			_REG((x) + 0x20)
> +#define LCP32XX_TIMER_MR3(x)			_REG((x) + 0x24)
> +#define LCP32XX_TIMER_CCR(x)			_REG((x) + 0x28)
> +#define LCP32XX_TIMER_CR0(x)			_REG((x) + 0x2C)
> +#define LCP32XX_TIMER_CR1(x)			_REG((x) + 0x30)
> +#define LCP32XX_TIMER_CR2(x)			_REG((x) + 0x34)
> +#define LCP32XX_TIMER_CR3(x)			_REG((x) + 0x38)
> +#define LCP32XX_TIMER_EMR(x)			_REG((x) + 0x3C)
> +#define LCP32XX_TIMER_CTCR(x)			_REG((x) + 0x70)
> +
> +/*
> + * ir register definitions
> + */
> +#define LCP32XX_TIMER_CNTR_MTCH_BIT(n)		(1 << ((n) & 0x3))
> +#define LCP32XX_TIMER_CNTR_CAPT_BIT(n)		(1 << (4 + ((n) & 0x3)))
> +
> +/*
> + * tcr register definitions
> + */
> +#define LCP32XX_TIMER_CNTR_TCR_EN		0x1
> +#define LCP32XX_TIMER_CNTR_TCR_RESET		0x2
> +
> +/*
> + * mcr register definitions
> + */
> +#define LCP32XX_TIMER_CNTR_MCR_MTCH(n)		(0x1 << ((n) * 3))
> +#define LCP32XX_TIMER_CNTR_MCR_RESET(n)		(0x1 << (((n) * 3) + 1))
> +#define LCP32XX_TIMER_CNTR_MCR_STOP(n)		(0x1 << (((n) * 3) + 2))
> +
> +/*
> + * Standard UART register offsets
> + */
> +#define LPC32XX_UART_DLL_FIFO(x)		_REG((x) + 0x00)
> +#define LPC32XX_UART_DLM_IER(x)			_REG((x) + 0x04)
> +#define LPC32XX_UART_IIR_FCR(x)			_REG((x) + 0x08)
> +#define LPC32XX_UART_LCR(x)			_REG((x) + 0x0C)
> +#define LPC32XX_UART_MODEM_CTRL(x)		_REG((x) + 0x10)
> +#define LPC32XX_UART_LSR(x)			_REG((x) + 0x14)
> +#define LPC32XX_UART_MODEM_STATUS(x)		_REG((x) + 0x18)
> +#define LPC32XX_UART_RXLEV(x)			_REG((x) + 0x1C)
> +
> +/*
> + * UART control structure offsets
> + */
> +#define _UCREG(x)				_REG(LPC32XX_UART_CTRL_BASE +\
> +						(x))
> +#define LPC32XX_UARTCTL_CTRL			_UCREG(0x00)
> +#define LPC32XX_UARTCTL_CLKMODE			_UCREG(0x04)
> +#define LPC32XX_UARTCTL_CLOOP			_UCREG(0x08)
> +
> +/*
> + * ctrl register definitions
> + */
> +#define LPC32XX_UART_U3_MD_CTRL_EN		_BIT(11)
> +#define LPC32XX_UART_IRRX6_INV_EN		_BIT(10)
> +#define LPC32XX_UART_HDPX_EN			_BIT(9)
> +#define LPC32XX_UART_UART6_IRDAMOD_BYPASS	_BIT(5)
> +#define LPC32XX_RT_IRTX6_INV_EN			_BIT(4)
> +#define LPC32XX_RT_IRTX6_INV_MIR_EN		_BIT(3)
> +#define LPC32XX_RT_RX_IRPULSE_3_16_115K		_BIT(2)
> +#define LPC32XX_RT_TX_IRPULSE_3_16_115K		_BIT(1)
> +#define LPC32XX_UART_U5_ROUTE_TO_USB		_BIT(0)
> +
> +/*
> + * clkmode register definitions
> + */
> +#define LPC32XX_UART_ENABLED_CLOCKS(n)		(((n) >> 16) & 0x7F)
> +#define LPC32XX_UART_ENABLED_CLOCK(n, u)	(((n) >> (16 + (u))) & 0x1)
> +#define LPC32XX_UART_ENABLED_CLKS_ANY		_BIT(14)
> +#define LPC32XX_UART_CLKMODE_OFF		0x0
> +#define LPC32XX_UART_CLKMODE_ON			0x1
> +#define LPC32XX_UART_CLKMODE_AUTO		0x2
> +#define LPC32XX_UART_CLKMODE_MASK(u)		(0x3 << ((((u) - 3) * 2) + 4))
> +#define LPC32XX_UART_CLKMODE_LOAD(m, u)		((m) << ((((u) - 3) * 2) + 4))
> +
> +/*
> + * GPIO Module Register offsets
> + */
> +#define _GPREG(x)				_REG(LPC32XX_GPIO_BASE + (x))
> +#define LPC32XX_GPIO_P_MUX_SET			_GPREG(0x100)
> +#define LPC32XX_GPIO_P_MUX_CLR			_GPREG(0x104)
> +#define LPC32XX_GPIO_P_MUX_STATE		_GPREG(0x108)
> +#define LPC32XX_GPIO_P3_MUX_SET			_GPREG(0x110)
> +#define LPC32XX_GPIO_P3_MUX_CLR			_GPREG(0x114)
> +#define LPC32XX_GPIO_P3_MUX_STATE		_GPREG(0x118)
> +#define LPC32XX_GPIO_P0_MUX_SET			_GPREG(0x120)
> +#define LPC32XX_GPIO_P0_MUX_CLR			_GPREG(0x124)
> +#define LPC32XX_GPIO_P0_MUX_STATE		_GPREG(0x128)
> +#define LPC32XX_GPIO_P1_MUX_SET			_GPREG(0x130)
> +#define LPC32XX_GPIO_P1_MUX_CLR			_GPREG(0x134)
> +#define LPC32XX_GPIO_P1_MUX_STATE		_GPREG(0x138)
> +
> +#endif
> diff --git a/arch/arm/mach-lpc32xx/include/mach/system.h b/arch/arm/mach-lpc32xx/include/mach/system.h
> new file mode 100644
> index 0000000..df3b0de
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/system.h
> @@ -0,0 +1,52 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/system.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_SYSTEM_H
> +#define __ASM_ARCH_SYSTEM_H
> +
> +static void arch_idle(void)
> +{
> +	cpu_do_idle();
> +}
> +
> +static inline void arch_reset(char mode, const char *cmd)
> +{
> +	extern void lpc32xx_watchdog_reset(void);
> +
> +	switch (mode) {
> +	case 's':
> +	case 'h':
> +		printk(KERN_CRIT "RESET: Rebooting system\n");
> +
> +		/* Disable interrupts */
> +		local_irq_disable();
> +
> +		lpc32xx_watchdog_reset();
> +		break;
> +
> +	default:
> +		/* Do nothing */
> +		break;
> +	}
> +
> +	/* Wait for watchdog to reset system */
> +	while (1)
> +		;
> +}
> +
> +#endif
> diff --git a/arch/arm/mach-lpc32xx/include/mach/timex.h b/arch/arm/mach-lpc32xx/include/mach/timex.h
> new file mode 100644
> index 0000000..1b2a20f
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/timex.h
> @@ -0,0 +1,29 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/timex.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_TIMEX_H
> +#define __ASM_ARCH_TIMEX_H
> +
> +/*
> + * Rate in Hz of the main system oscillator. This value should match
> + * the value 'MAIN_OSC_FREQ' in platform.h
> + */
> +#define CLOCK_TICK_RATE	13000000
> +
> +#endif
> +
> diff --git a/arch/arm/mach-lpc32xx/include/mach/uncompress.h b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
> new file mode 100644
> index 0000000..7effa54
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
> @@ -0,0 +1,63 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/uncompress.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARM_ARCH_UNCOMPRESS_H
> +#define __ASM_ARM_ARCH_UNCOMPRESS_H
> +
> +#include <linux/io.h>
> +
> +#include <mach/platform.h>
> +
> +/*
> + * Uncompress output is hardcoded to standard UART 5
> + */
> +
> +#define UART_FIFO_CTL_TX_RESET	(1 << 2)
> +#define UART_STATUS_TX_MT	(1 << 6)
> +
> +#define LPC32XX_UART_DLLFIFO_O	0x00
> +#define LPC32XX_UART_IIRFCR_O	0x08
> +#define LPC32XX_UART_LSR_O	0x14
> +
> +#define LPC32XX_SUART_DATA	(*(volatile unsigned long *)\
> +				(LPC32XX_UART5_BASE + LPC32XX_UART_DLLFIFO_O))
> +#define LPC32XX_SUART_STATUS	(*(volatile unsigned long *)\
> +				(LPC32XX_UART5_BASE + LPC32XX_UART_LSR_O))
> +#define LPC32XX_SUART_FIFOCTRL	(*(volatile unsigned long *)\
> +				(LPC32XX_UART5_BASE + LPC32XX_UART_IIRFCR_O))
> +
> +static inline void putc(int ch)
> +{
> +	/* Wait for transmit FIFO to empty */
> +	while ((LPC32XX_SUART_STATUS & UART_STATUS_TX_MT) == 0)
> +		;
> +
> +	LPC32XX_SUART_DATA = (u32) ch;
> +}
Why do you use volatile here and not __raw_readl/writel as in the other
files?

> +
> +static inline void flush(void)
> +{
> +	LPC32XX_SUART_FIFOCTRL |= UART_FIFO_CTL_TX_RESET;
> +}
> +
> +/* NULL functions; we don't presently need them */
> +#define arch_decomp_setup()
> +#define arch_decomp_wdog()
> +
> +#endif
> +
trailing newline

> diff --git a/arch/arm/mach-lpc32xx/include/mach/vmalloc.h b/arch/arm/mach-lpc32xx/include/mach/vmalloc.h
> new file mode 100644
> index 0000000..d1d936c
> --- /dev/null
> +++ b/arch/arm/mach-lpc32xx/include/mach/vmalloc.h
> @@ -0,0 +1,24 @@
> +/*
> + * arch/arm/mach-lpc32xx/include/mach/vmalloc.h
> + *
> + * Author: Kevin Wells <kevin.wells@nxp.com>
> + *
> + * Copyright (C) 2010 NXP Semiconductors
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; either version 2 of the License, or
> + * (at your option) any later version.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + */
> +
> +#ifndef __ASM_ARCH_VMALLOC_H
> +#define __ASM_ARCH_VMALLOC_H
> +
> +#define VMALLOC_END	0xF0000000
> +
> +#endif
> -- 
> 1.6.6

Best regards
Uwe
-- 
Pengutronix e.K.                              | Uwe Kleine-König            |
Industrial Linux Solutions                    | http://www.pengutronix.de/  |

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel

================================================================================

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?= <u.kleine-koenig () pengutronix ! de>
To: linux-arm-kernel
Subject: Re: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 09:52:27 +0000
Message-ID: <20100209095227.GC2284 () pengutronix ! de>
--------------------
Hello,

while replying to to patch 02, I noticed yet another thing.

On Tue, Feb 09, 2010 at 10:31:29AM +0100, Uwe Kleine-König wrote:
> > +/*
> > + * Start of virtual addresses for IO devices
> > + */
> > +#define IO_BASE		0xF0000000
> > +
> > +/*
> > + * This macro relies on fact that for all HW i/o addresses bits 20-23 are 0
> > + */
> > +#define IO_ADDRESS(x)	(((((x) & 0xff000000) >> 4) | ((x) & 0xfffff)) |\
> > +			 IO_BASE)
> > +
> > +#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
> Is this cast to unsigned long needed?  AFAIK IO_ADDRESS(x) has
> type unsigned for x in { 0x0 ... 0xffffffff } (provided that int uses a
> 32 bit 2s-complement representation).  If unsigned long is really
> needed, maybe put it into the IO_ADDRESS macro?
> 
> > ...
> > +#define _REG(x)					(void __iomem *)(io_p2v(x))

_REG gets (void __iomem *) twice.

Why not simply do:

	#define io_p2v(x)	(((((x) & 0xff000000) >> 4) | ((x) & 0xfffff)) | IO_BASE)

	#define _REG(x)		(void __iomem *)(io_p2v(x))

and get rid of IO_ADDRESS completely?  BTW, AFAIK IO_BASE isn't a needed
name, so it should have the LPC32XX_ prefix, too.

Best regards
Uwe

-- 
Pengutronix e.K.                              | Uwe Kleine-König            |
Industrial Linux Solutions                    | http://www.pengutronix.de/  |

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel

================================================================================

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?= <u.kleine-koenig () pengutronix ! de>
To: linux-arm-kernel
Subject: Re: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 16:52:23 +0000
Message-ID: <20100209165223.GA11113 () pengutronix ! de>
--------------------
[Added linux-sparse@vger.kernel.org to Cc:]

On Tue, Feb 09, 2010 at 09:59:34AM +0000, Russell King - ARM Linux wrote:
> On Tue, Feb 09, 2010 at 10:31:29AM +0100, Uwe Kleine-König wrote:
> > > +#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
> > Is this cast to unsigned long needed?  AFAIK IO_ADDRESS(x) has
> > type unsigned for x in { 0x0 ... 0xffffffff } (provided that int uses a
> > 32 bit 2s-complement representation).  If unsigned long is really
> > needed, maybe put it into the IO_ADDRESS macro?
> 
> int -> void __iomem * = sparse warning
> unsigned long -> void __iomem * = no sparse warning
Ah, OK, I see.  But IMHO it's a poor reason to add the cast.  Either
the cast is necessary/recommended or sparse is wrong.  In the first case
the reasoning shouldn't have to do with sparse, in the latter sparse
should be fixed.

I found the responsible code in sparse.  It reads:

	static struct symbol *evaluate_cast(struct expression *expr)
	{
		int as1 = 0, as2 = 0;
		...
		ctype = examine_symbol_type(expr->cast_type);
		...
		class1 = classify_type(ctype, &t1);
		...
		if (t1 == &ulong_ctype)
			as1 = -1;
		else if (class1 == TYPE_PTR) {
			examine_pointer_target(t1);
			as1 = t1->ctype.as;
		}
		
		if (t2 == &ulong_ctype)
			as2 = -1;
		else if (class2 == TYPE_PTR) {
			examine_pointer_target(t2);
			as2 = t2->ctype.as;
		}
		...
		if (as1 > 0 && !as2 &&
		    !is_null_pointer_constant(target) && Wcast_to_as)
			warning(expr->pos,
				"cast adds address space to expression (<asn:%d>)", as1);

so it seems to be explicitly allowed to make a pointer in any address
space from an unsigned long, but not from a (signed or unsigned) int.
Unfortunately there is no comment describing why unsigned long is
allowed.

Is this intended?  What is the preferred way to define iomem pointers?

I found the following variants in the kernel[1]

	#define ...	((void __iomem *)(unsigned long)0x12345678)
	#define ...	((void __iomem __force *)0x12345678)
	#define ...	((void __iomem *)0x12345678)

where __iomem is defined as __attribute__((noderef, address_space(2)))
for sparse.

The first variant with the extra cast to unsigned long seems unnecessary
long, the third results in the "cast adds address space to expression"
warning.

So what do you recommend?

Best regards and thanks
Uwe

[1] I only checked a few files, so maybe there are more.
-- 
Pengutronix e.K.                           | Uwe Kleine-König            |
Industrial Linux Solutions                 | http://www.pengutronix.de/  |

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel

================================================================================

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?=
To: linux-sparse
Subject: Re: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 16:52:23 +0000
Message-ID: <20100209165223.GA11113 () pengutronix ! de>
--------------------
[Added linux-sparse@vger.kernel.org to Cc:]

On Tue, Feb 09, 2010 at 09:59:34AM +0000, Russell King - ARM Linux wrote:
> On Tue, Feb 09, 2010 at 10:31:29AM +0100, Uwe Kleine-König wrote:
> > > +#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
> > Is this cast to unsigned long needed?  AFAIK IO_ADDRESS(x) has
> > type unsigned for x in { 0x0 ... 0xffffffff } (provided that int uses a
> > 32 bit 2s-complement representation).  If unsigned long is really
> > needed, maybe put it into the IO_ADDRESS macro?
> 
> int -> void __iomem * = sparse warning
> unsigned long -> void __iomem * = no sparse warning
Ah, OK, I see.  But IMHO it's a poor reason to add the cast.  Either
the cast is necessary/recommended or sparse is wrong.  In the first case
the reasoning shouldn't have to do with sparse, in the latter sparse
should be fixed.

I found the responsible code in sparse.  It reads:

	static struct symbol *evaluate_cast(struct expression *expr)
	{
		int as1 = 0, as2 = 0;
		...
		ctype = examine_symbol_type(expr->cast_type);
		...
		class1 = classify_type(ctype, &t1);
		...
		if (t1 == &ulong_ctype)
			as1 = -1;
		else if (class1 == TYPE_PTR) {
			examine_pointer_target(t1);
			as1 = t1->ctype.as;
		}
		
		if (t2 == &ulong_ctype)
			as2 = -1;
		else if (class2 == TYPE_PTR) {
			examine_pointer_target(t2);
			as2 = t2->ctype.as;
		}
		...
		if (as1 > 0 && !as2 &&
		    !is_null_pointer_constant(target) && Wcast_to_as)
			warning(expr->pos,
				"cast adds address space to expression (<asn:%d>)", as1);

so it seems to be explicitly allowed to make a pointer in any address
space from an unsigned long, but not from a (signed or unsigned) int.
Unfortunately there is no comment describing why unsigned long is
allowed.

Is this intended?  What is the preferred way to define iomem pointers?

I found the following variants in the kernel[1]

	#define ...	((void __iomem *)(unsigned long)0x12345678)
	#define ...	((void __iomem __force *)0x12345678)
	#define ...	((void __iomem *)0x12345678)

where __iomem is defined as __attribute__((noderef, address_space(2)))
for sparse.

The first variant with the extra cast to unsigned long seems unnecessary
long, the third results in the "cast adds address space to expression"
warning.

So what do you recommend?

Best regards and thanks
Uwe

[1] I only checked a few files, so maybe there are more.
-- 
Pengutronix e.K.                           | Uwe Kleine-König            |
Industrial Linux Solutions                 | http://www.pengutronix.de/  |
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "H Hartley Sweeten" <hartleys () visionengravers ! com>
To: linux-arm-kernel
Subject: RE: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 17:10:39 +0000
Message-ID: <BD79186B4FD85F4B8E60E381CAEE190902152FCF () mi8nycmail19 ! Mi8 ! com>
--------------------
On Tuesday, February 09, 2010 9:52 AM, Uwe Kleine-König wrote:
> [Added linux-sparse@vger.kernel.org to Cc:]
>
> On Tue, Feb 09, 2010 at 09:59:34AM +0000, Russell King - ARM Linux wrote:
>> On Tue, Feb 09, 2010 at 10:31:29AM +0100, Uwe Kleine-König wrote:
>>>> +#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
>>> Is this cast to unsigned long needed?  AFAIK IO_ADDRESS(x) has
>>> type unsigned for x in { 0x0 ... 0xffffffff } (provided that int uses a
>>> 32 bit 2s-complement representation).  If unsigned long is really
>>> needed, maybe put it into the IO_ADDRESS macro?
>> 
>> int -> void __iomem * = sparse warning
>> unsigned long -> void __iomem * = no sparse warning
> Ah, OK, I see.  But IMHO it's a poor reason to add the cast.  Either
> the cast is necessary/recommended or sparse is wrong.  In the first case
> the reasoning shouldn't have to do with sparse, in the latter sparse
> should be fixed.
>
> I found the responsible code in sparse.  It reads:

[snip]

> so it seems to be explicitly allowed to make a pointer in any address
> space from an unsigned long, but not from a (signed or unsigned) int.
> Unfortunately there is no comment describing why unsigned long is
> allowed.
>
> Is this intended?  What is the preferred way to define iomem pointers?
>
> I found the following variants in the kernel[1]
>
>	#define ...	((void __iomem *)(unsigned long)0x12345678)
>	#define ...	((void __iomem __force *)0x12345678)
>	#define ...	((void __iomem *)0x12345678)
>
> where __iomem is defined as __attribute__((noderef, address_space(2)))
> for sparse.
>
> The first variant with the extra cast to unsigned long seems unnecessary
> long, the third results in the "cast adds address space to expression"
> warning.
>
> So what do you recommend?

Would this fix the third variant?

	#define ... ((void __iomem *)0x12345678UL)

Regards,
Hartley

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel

================================================================================

From: Russell King - ARM Linux <linux () arm ! linux ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 17:58:57 +0000
Message-ID: <20100209175857.GA20924 () n2100 ! arm ! linux ! org ! uk>
--------------------
On Tue, Feb 09, 2010 at 05:52:23PM +0100, Uwe Kleine-König wrote:
> [Added linux-sparse@vger.kernel.org to Cc:]
> 
> On Tue, Feb 09, 2010 at 09:59:34AM +0000, Russell King - ARM Linux wrote:
> > On Tue, Feb 09, 2010 at 10:31:29AM +0100, Uwe Kleine-König wrote:
> > > > +#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
> > > Is this cast to unsigned long needed?  AFAIK IO_ADDRESS(x) has
> > > type unsigned for x in { 0x0 ... 0xffffffff } (provided that int uses a
> > > 32 bit 2s-complement representation).  If unsigned long is really
> > > needed, maybe put it into the IO_ADDRESS macro?
> > 
> > int -> void __iomem * = sparse warning
> > unsigned long -> void __iomem * = no sparse warning
> Ah, OK, I see.  But IMHO it's a poor reason to add the cast.  Either
> the cast is necessary/recommended or sparse is wrong.  In the first case
> the reasoning shouldn't have to do with sparse, in the latter sparse
> should be fixed.

The point is that on 64-bit architectures, a pointer may be representable
by an unsigned long, but not an int.

> Is this intended?  What is the preferred way to define iomem pointers?

Define a numerical address with a UL suffix is the simplest way.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 18:22:12 +0000
Message-ID: <20100209182210.GB23822 () feather>
--------------------
On Tue, Feb 09, 2010 at 05:52:23PM +0100, Uwe Kleine-König wrote:
> [Added linux-sparse@vger.kernel.org to Cc:]
> 
> On Tue, Feb 09, 2010 at 09:59:34AM +0000, Russell King - ARM Linux wrote:
> > On Tue, Feb 09, 2010 at 10:31:29AM +0100, Uwe Kleine-König wrote:
> > > > +#define io_p2v(x)	((void __iomem *) (unsigned long) IO_ADDRESS(x))
> > > Is this cast to unsigned long needed?  AFAIK IO_ADDRESS(x) has
> > > type unsigned for x in { 0x0 ... 0xffffffff } (provided that int uses a
> > > 32 bit 2s-complement representation).  If unsigned long is really
> > > needed, maybe put it into the IO_ADDRESS macro?
> > 
> > int -> void __iomem * = sparse warning
> > unsigned long -> void __iomem * = no sparse warning
> Ah, OK, I see.  But IMHO it's a poor reason to add the cast.  Either
> the cast is necessary/recommended or sparse is wrong.  In the first case
> the reasoning shouldn't have to do with sparse, in the latter sparse
> should be fixed.
>
> I found the responsible code in sparse.  It reads:
> 
> 	static struct symbol *evaluate_cast(struct expression *expr)
> 	{
> 		int as1 = 0, as2 = 0;
> 		...
> 		ctype = examine_symbol_type(expr->cast_type);
> 		...
> 		class1 = classify_type(ctype, &t1);
> 		...
> 		if (t1 == &ulong_ctype)
> 			as1 = -1;
> 		else if (class1 == TYPE_PTR) {
> 			examine_pointer_target(t1);
> 			as1 = t1->ctype.as;
> 		}
> 		
> 		if (t2 == &ulong_ctype)
> 			as2 = -1;
> 		else if (class2 == TYPE_PTR) {
> 			examine_pointer_target(t2);
> 			as2 = t2->ctype.as;
> 		}
> 		...
> 		if (as1 > 0 && !as2 &&
> 		    !is_null_pointer_constant(target) && Wcast_to_as)
> 			warning(expr->pos,
> 				"cast adds address space to expression (<asn:%d>)", as1);
> 
> so it seems to be explicitly allowed to make a pointer in any address
> space from an unsigned long, but not from a (signed or unsigned) int.
> Unfortunately there is no comment describing why unsigned long is
> allowed.
> 
> Is this intended?  What is the preferred way to define iomem pointers?
> 
> I found the following variants in the kernel[1]
> 
> 	#define ...	((void __iomem *)(unsigned long)0x12345678)
> 	#define ...	((void __iomem __force *)0x12345678)
> 	#define ...	((void __iomem *)0x12345678)
> 
> where __iomem is defined as __attribute__((noderef, address_space(2)))
> for sparse.
> 
> The first variant with the extra cast to unsigned long seems unnecessary
> long, the third results in the "cast adds address space to expression"
> warning.
> 
> So what do you recommend?

I don't know the reasoning behind allowing casts from unsigned long,
except perhaps to allow creating pointer literals, but explicitly
casting by way of unsigned long seems wrong.  In general, the couple of
places that legitimately convert addresses between address spaces should
use __force.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kevin Wells <kevin.wells () nxp ! com>
To: linux-arm-kernel
Subject: RE: [PATCH 01/14] ARM: LPC32XX: Initial architecture header files
Date: Tue, 09 Feb 2010 19:17:58 +0000
Message-ID: <083DF309106F364B939360100EC290F805C8C7550B () eu1rdcrdc1wx030 ! exi ! nxp ! com>
--------------------
Thanks again Uwe for your time spent reviewing this and your
helpful comments!

> > diff --git a/arch/arm/mach-lpc32xx/include/mach/board.h b/arch/arm/mach-
> lpc32xx/include/mach/board.h
> > new file mode 100644
> > index 0000000..30424bc
> > --- /dev/null
> > +++ b/arch/arm/mach-lpc32xx/include/mach/board.h
> > @@ -0,0 +1,23 @@
> > +/*
> > + * arch/arm/mach-lpc32xx/include/mach/board.h
> > + *
> > + * Author: Kevin Wells <kevin.wells@nxp.com>
> > + *
> > + * Copyright (C) 2010 NXP Semiconductors
> > + *
> > + * This program is free software; you can redistribute it and/or modify
> > + * it under the terms of the GNU General Public License as published by
> > + * the Free Software Foundation; either version 2 of the License, or
> > + * (at your option) any later version.
> > + *
> > + * This program is distributed in the hope that it will be useful,
> > + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> > + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> > + * GNU General Public License for more details.
> > + */
> > +
> > +
> nitpick: there is an empty line too much.
> 
> > +#ifndef __ASM_ARCH_BOARD_H
> > +#define __ASM_ARCH_BOARD_H
> > +
> > +#endif
> Do you really need this file?
> 

This file is a place holder. most of the other drivers for this
platform are already complete and a few add structures to this
file that are shared via platform data. I can remove it, but
would have to replace it later so I prefer to keep it now.

> > diff --git a/arch/arm/mach-lpc32xx/include/mach/clkdev.h
> b/arch/arm/mach-lpc32xx/include/mach/clkdev.h
> > new file mode 100644
> > index 0000000..9bf0637
> > --- /dev/null
> > +++ b/arch/arm/mach-lpc32xx/include/mach/clkdev.h
> > @@ -0,0 +1,25 @@
> > +/*
> > + * arch/arm/mach-lpc32xx/include/mach/clkdev.h
> > + *
> > + * Author: Kevin Wells <kevin.wells@nxp.com>
> hmmm, I wonder why you use your nxp address here, but gmail in the
> S-o-b.
> 

Corporate email + corporate IT + outlook = lots of problems with mailing lists
I'll change that address in git too.

Kevin

_______________________________________________
linux-arm-kernel mailing list
linux-arm-kernel@lists.infradead.org
http://lists.infradead.org/mailman/listinfo/linux-arm-kernel
================================================================================


################################################################################

=== Thread: [PATCH 1/1] parser: add support for asm goto ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 1/1] parser: add support for asm goto
Date: Fri, 18 Jun 2010 09:40:42 +0000
Message-ID: <AANLkTil84_v2xi2HR_HjTTLMDAOZmyXbSmPrJ-KiQIzl () mail ! gmail ! com>
--------------------
On Fri, Jun 18, 2010 at 1:29 AM, Jiri Slaby <jslaby@suse.cz> wrote:
> On 06/18/2010 10:21 AM, Jiri Slaby wrote:
>> Holy crap, in docco, there is nothing like that, but I checked gcc
>> parser sources to be sure, and there indeed is:
>>      asm type-qualifier[opt] ( asm-argument ) ;
>>      asm type-qualifier[opt] goto ( asm-goto-argument ) ;
>> So yes, asm volatile goto is valid. Would you take care of that?
>
> It is as easy as:
> diff --git a/parse.c b/parse.c
> index caf10b9..1d20658 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -1915,7 +1915,8 @@ static struct token *parse_asm_statement(struct
> token *token, struct statement *
>        stmt->type = STMT_ASM;
>        if (match_idents(token, &__volatile___ident, &__volatile_ident,
> &volatile_ident, NULL)) {
>                token = token->next;
> -       } else if (match_idents(token, &goto_ident, NULL)) {
> +       }
> +       if (match_idents(token, &goto_ident, NULL)) {
>                is_goto = 1;
>                token = token->next;
>        }

Looks good to me.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] Fix tokenizer for octal escape sequences ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] Fix tokenizer for octal escape sequences
Date: Thu, 16 Dec 2010 19:35:06 +0000
Message-ID: <AANLkTimM3neAiMyq3j_SbuhM=vK+MLL-AvZbmHXoeRVj () mail ! gmail ! com>
--------------------
On Thu, Dec 16, 2010 at 1:14 AM, Namhyung Kim <namhyung@gmail.com> wrote:
> Don't allow 8 and 9 to be included in octal escape sequences.
> -                               while (next >= '0' && next <= '9') {
> +                               while (next >= '0' && next <= '7') {

Wow, good catch.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] parser: fix and simplify support of asm goto ===

From: Chris Li <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] parser: fix and simplify support of asm goto
Date: Sat, 10 Jul 2010 18:36:10 +0000
Message-ID: <AANLkTik60ShxdSb8mE0BLGKPmSe3saUTPVHbxCBXqPGp () mail ! gmail ! com>
--------------------
On Sat, Jul 10, 2010 at 1:39 AM, Jiri Slaby <jslaby@suse.cz> wrote:
> +       if (token->ident == &goto_ident) {

You need to test the token type is TOKEN_IDENT before using token->ident.
I will apply your patch with the fix up.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/4] inspect: add custom ast treeview model ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 1/4] inspect: add custom ast treeview model
Date: Fri, 02 Apr 2010 18:40:06 +0000
Message-ID: <w2g70318cbf1004021140j5c2aaf3ka5f50baf589e0e57 () mail ! gmail ! com>
--------------------
--000e0cd6316ce90d070483454e8a
Content-Type: text/plain; charset=ISO-8859-1

It is custom gtk treeview model to wrap the C data structure
use by sparse. The ast model does not have any sparse specific
stuff in it. Instead, it provide a simplier call back based
API to allow user construct tree view object very easily.

Chris

--000e0cd6316ce90d070483454e8a
Content-Type: application/octet-stream; 
	name="0001-inspect-add-custom-ast-treeview-model.patch"
Content-Disposition: attachment; 
	filename="0001-inspect-add-custom-ast-treeview-model.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_g7jedcdg0

RnJvbSAzMGRkNzNiNTZmN2YwMThlMDU5MDg4Yjc5MzdiMTYyOWQ1NzgyNzU5IE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBUdWUsIDMwIE1hciAyMDEwIDE1OjQ4OjM4IC0wNzAwClN1YmplY3Q6IFtQQVRDSCAxLzRd
IGluc3BlY3Q6IGFkZCBjdXN0b20gYXN0IHRyZWV2aWV3IG1vZGVsCgpJdCBpcyBjdXN0b20gZ3Rr
IHRyZWV2aWV3IG1vZGVsIHRvIHdyYXAgdGhlIEMgZGF0YSBzdHJ1Y3R1cmUKdXNlIGJ5IHNwYXJz
ZS4gVGhlIGFzdCBtb2RlbCBkb2VzIG5vdCBoYXZlIGFueSBzcGFyc2Ugc3BlY2lmaWMKc3R1ZmYg
aW4gaXQuIEluc3RlYWQsIGl0IHByb3ZpZGUgYSBzaW1wbGllciBjYWxsIGJhY2sgYmFzZWQKQVBJ
IHRvIGFsbG93IHVzZXIgY29uc3RydWN0IHRyZWUgdmlldyBvYmplY3QgdmVyeSBlYXNpbHkuCi0t
LQogYXN0LW1vZGVsLmMgfCAgNDY4ICsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysr
KysrKysrKysrKysrKysrKysrKysrKysrCiBhc3QtbW9kZWwuaCB8ICAgODggKysrKysrKysrKysK
IGFzdC12aWV3LmMgIHwgICA0OCArKysrKysKIGFzdC12aWV3LmggIHwgICAgNyArCiA0IGZpbGVz
IGNoYW5nZWQsIDYxMSBpbnNlcnRpb25zKCspLCAwIGRlbGV0aW9ucygtKQogY3JlYXRlIG1vZGUg
MTAwNjQ0IGFzdC1tb2RlbC5jCiBjcmVhdGUgbW9kZSAxMDA2NDQgYXN0LW1vZGVsLmgKIGNyZWF0
ZSBtb2RlIDEwMDY0NCBhc3Qtdmlldy5jCiBjcmVhdGUgbW9kZSAxMDA2NDQgYXN0LXZpZXcuaAoK
ZGlmZiAtLWdpdCBhL2FzdC1tb2RlbC5jIGIvYXN0LW1vZGVsLmMKbmV3IGZpbGUgbW9kZSAxMDA2
NDQKaW5kZXggMDAwMDAwMC4uZjUxNjM0MAotLS0gL2Rldi9udWxsCisrKyBiL2FzdC1tb2RlbC5j
CkBAIC0wLDAgKzEsNDY4IEBACisvKgorICogICBhc3QtbW9kZWwuYyAKKyAqCisgKiAgIEEgY3Vz
dG9tIHRyZWUgbW9kZWwgdG8gc2ltcGxpZnkgdmlld2luZyBvZiBBU1Qgb2JqZWN0cy4KKyAqICAg
TW9kaWZ5IGZyb20gdGhlIEd0aysgdHJlZSB2aWV3IHR1dG9yaWFsLCBjdXN0b20tbGlzdC5jCisg
KiAgIGJ5IFRpbS1QaGlsaXBwIE11ZWxsZXIgPCB0aW0gYXQgY2VudHJpY3VsYXIgZG90IG5ldCA+
CisgKgorICogICBDb3B5cmlnaHQgKEMpIDIwMTAgQ2hyaXN0b3BoZXIgTGkKKyAqLworCisKKyNp
bmNsdWRlICJhc3QtbW9kZWwuaCIKKyNpbmNsdWRlICJzdGRpbnQuaCIKKworLyogYm9yaW5nIGRl
Y2xhcmF0aW9ucyBvZiBsb2NhbCBmdW5jdGlvbnMgKi8KKworc3RhdGljIHZvaWQgYXN0X2luaXQo
QXN0Tm9kZSAqcGtnX3RyZWUpOworc3RhdGljIHZvaWQgYXN0X2NsYXNzX2luaXQoQXN0Tm9kZUNs
YXNzICprbGFzcyk7CitzdGF0aWMgdm9pZCBhc3RfdHJlZV9tb2RlbF9pbml0KEd0a1RyZWVNb2Rl
bElmYWNlICppZmFjZSk7CitzdGF0aWMgdm9pZCBhc3RfZmluYWxpemUoR09iamVjdCAqb2JqZWN0
KTsKK3N0YXRpYyBHdGtUcmVlTW9kZWxGbGFncyBhc3RfZ2V0X2ZsYWdzKEd0a1RyZWVNb2RlbCAq
dHJlZV9tb2RlbCk7CitzdGF0aWMgZ2ludCBhc3RfZ2V0X25fY29sdW1ucyhHdGtUcmVlTW9kZWwg
KnRyZWVfbW9kZWwpOworc3RhdGljIEdUeXBlIGFzdF9nZXRfY29sdW1uX3R5cGUoR3RrVHJlZU1v
ZGVsICp0cmVlX21vZGVsLCBnaW50IGluZGV4KTsKK3N0YXRpYyBnYm9vbGVhbiBhc3RfZ2V0X2l0
ZXIoR3RrVHJlZU1vZGVsICp0cmVlX21vZGVsLCBHdGtUcmVlSXRlciAqaXRlciwKKwkJCQkgIEd0
a1RyZWVQYXRoICpwYXRoKTsKK3N0YXRpYyBHdGtUcmVlUGF0aCAqYXN0X2dldF9wYXRoKEd0a1Ry
ZWVNb2RlbCAqdHJlZV9tb2RlbCwgR3RrVHJlZUl0ZXIgKml0ZXIpOyAKK3N0YXRpYyB2b2lkIGFz
dF9nZXRfdmFsdWUoR3RrVHJlZU1vZGVsICp0cmVlX21vZGVsLCBHdGtUcmVlSXRlciAqaXRlciwK
KwkJCSAgICAgICBnaW50IGNvbHVtbiwgR1ZhbHVlICp2YWx1ZSk7CitzdGF0aWMgZ2Jvb2xlYW4g
YXN0X2l0ZXJfbmV4dChHdGtUcmVlTW9kZWwgKnRyZWVfbW9kZWwsIEd0a1RyZWVJdGVyICppdGVy
KTsKK3N0YXRpYyBnYm9vbGVhbiBhc3RfaXRlcl9jaGlsZHJlbihHdGtUcmVlTW9kZWwgKnRyZWVf
bW9kZWwsCisgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHdGtUcmVlSXRl
ciAqaXRlciwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEd0a1RyZWVJ
dGVyICpwYXJlbnQpOworc3RhdGljIGdib29sZWFuIGFzdF9pdGVyX2hhc19jaGlsZChHdGtUcmVl
TW9kZWwgKnRyZWVfbW9kZWwsIEd0a1RyZWVJdGVyICppdGVyKTsKK3N0YXRpYyBnaW50IGFzdF9p
dGVyX25fY2hpbGRyZW4gKEd0a1RyZWVNb2RlbCAqdHJlZV9tb2RlbCwgR3RrVHJlZUl0ZXIgKml0
ZXIpOworc3RhdGljIGdib29sZWFuIGFzdF9pdGVyX250aF9jaGlsZChHdGtUcmVlTW9kZWwgKnRy
ZWVfbW9kZWwsIEd0a1RyZWVJdGVyICppdGVyLAorICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgIEd0a1RyZWVJdGVyICpwYXJlbnQsIGdpbnQgbik7CitzdGF0aWMgZ2Jvb2xl
YW4gYXN0X2l0ZXJfcGFyZW50KEd0a1RyZWVNb2RlbCAqdHJlZV9tb2RlbCwKKyAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICBHdGtUcmVlSXRlciAqaXRlciwKKyAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICBHdGtUcmVlSXRlciAqY2hpbGQpOworCitzdGF0aWMg
R09iamVjdENsYXNzICpwYXJlbnRfY2xhc3MgPSBOVUxMOyAgLyogR09iamVjdCBzdHVmZiAtIG5v
dGhpbmcgdG8gd29ycnkgYWJvdXQgKi8KKworc3RhdGljIGlubGluZQordm9pZCBpbnNwZWN0X2No
aWxkX25vZGUoQXN0Tm9kZSAqbm9kZSkKK3sKKwlpZiAobm9kZS0+aW5zcGVjdCkgeworCQlub2Rl
LT5pbnNwZWN0KG5vZGUpOworCQlub2RlLT5pbnNwZWN0ID0gTlVMTDsKKwl9Cit9CisKKworc3Rh
dGljIGlubGluZQorQXN0Tm9kZSogYXN0X250aF9jaGlsZChBc3ROb2RlICpub2RlLCBpbnQgbikK
K3sKKwlpZiAoIW5vZGUpCisJCXJldHVybiBOVUxMOworCisJaW5zcGVjdF9jaGlsZF9ub2RlKG5v
ZGUpOworCisJaWYgKG4gPj0gbm9kZS0+Y2hpbGRub2Rlcy0+bGVuKQorCQlyZXR1cm4gRkFMU0U7
CisJcmV0dXJuIGdfYXJyYXlfaW5kZXgobm9kZS0+Y2hpbGRub2RlcywgQXN0Tm9kZSAqLCBuKTsK
K30KKworCitzdGF0aWMgaW5saW5lCitnYm9vbGVhbiBhc3Rfc2V0X2l0ZXIoR3RrVHJlZUl0ZXIg
Kml0ZXIsIEFzdE5vZGUgKm5vZGUpCit7CisJaXRlci0+dXNlcl9kYXRhID0gbm9kZTsKKwlpdGVy
LT51c2VyX2RhdGEyID0gaXRlci0+dXNlcl9kYXRhMyA9IE5VTEw7CisJcmV0dXJuIG5vZGUgIT0g
TlVMTDsKK30KKworCisvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKKyAqCisgKiAgYXN0X2dldF90eXBl
OiBoZXJlIHdlIHJlZ2lzdGVyIG91ciBuZXcgdHlwZSBhbmQgaXRzIGludGVyZmFjZXMKKyAqICAg
ICAgICAgICAgICAgIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBJZiB5b3Ugd2FudCB0byBpbXBsZW1l
bnQKKyAqICAgICAgICAgICAgICAgIGFkZGl0aW9uYWwgaW50ZXJmYWNlcyBsaWtlIEd0a1RyZWVT
b3J0YWJsZSwgeW91CisgKiAgICAgICAgICAgICAgICB3aWxsIG5lZWQgdG8gZG8gaXQgaGVyZS4K
KyAqCisgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKiovCisKK0dUeXBlCithc3RfZ2V0X3R5cGUgKHZvaWQp
Cit7CisJc3RhdGljIEdUeXBlIGFzdF90eXBlID0gMDsKKwlzdGF0aWMgY29uc3QgR1R5cGVJbmZv
IGFzdF9pbmZvID0geworCQlzaXplb2YgKEFzdE5vZGVDbGFzcyksCisJCU5VTEwsICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBiYXNlX2luaXQgKi8KKwkJTlVMTCwg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJhc2VfZmluYWxpemUg
Ki8KKwkJKEdDbGFzc0luaXRGdW5jKSBhc3RfY2xhc3NfaW5pdCwKKwkJTlVMTCwgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNsYXNzIGZpbmFsaXplICovCisJCU5V
TEwsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjbGFzc19kYXRh
ICovCisJCXNpemVvZiAoQXN0Tm9kZSksCisJCTAsICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgIC8qIG5fcHJlYWxsb2NzICovCisJCShHSW5zdGFuY2VJbml0RnVuYykg
YXN0X2luaXQKKwl9OworCXN0YXRpYyBjb25zdCBHSW50ZXJmYWNlSW5mbyB0cmVlX21vZGVsX2lu
Zm8gPSB7CisJCShHSW50ZXJmYWNlSW5pdEZ1bmMpIGFzdF90cmVlX21vZGVsX2luaXQsCisJCU5V
TEwsCisJCU5VTEwKKwl9OworCisKKworCWlmIChhc3RfdHlwZSkKKwkJcmV0dXJuIGFzdF90eXBl
OworCisJLyogU29tZSBib2lsZXJwbGF0ZSB0eXBlIHJlZ2lzdHJhdGlvbiBzdHVmZiAqLworCWFz
dF90eXBlID0gZ190eXBlX3JlZ2lzdGVyX3N0YXRpYyhHX1RZUEVfT0JKRUNULCAiQXN0Tm9kZSIs
CisJCQkJCQkmYXN0X2luZm8sIChHVHlwZUZsYWdzKTApOworCisJLyogSGVyZSB3ZSByZWdpc3Rl
ciBvdXIgR3RrVHJlZU1vZGVsIGludGVyZmFjZSB3aXRoIHRoZSB0eXBlIHN5c3RlbSAqLworCWdf
dHlwZV9hZGRfaW50ZXJmYWNlX3N0YXRpYyhhc3RfdHlwZSwgR1RLX1RZUEVfVFJFRV9NT0RFTCwg
JnRyZWVfbW9kZWxfaW5mbyk7CisKKwlyZXR1cm4gYXN0X3R5cGU7Cit9CisKKworLyoqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqCisgKgorICogIGFzdF9jbGFzc19pbml0OiBtb3JlIGJvaWxlcnBsYXRlIEdP
YmplY3QvR1R5cGUgc3R1ZmYuCisgKiAgICAgICAgICAgICAgICAgIEluaXQgY2FsbGJhY2sgZm9y
IHRoZSB0eXBlIHN5c3RlbSwKKyAqICAgICAgICAgICAgICAgICAgY2FsbGVkIG9uY2Ugd2hlbiBv
dXIgbmV3IGNsYXNzIGlzIGNyZWF0ZWQuCisgKgorICoqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLworCitz
dGF0aWMgdm9pZAorYXN0X2NsYXNzX2luaXQgKEFzdE5vZGVDbGFzcyAqa2xhc3MpCit7CisJR09i
amVjdENsYXNzICpvYmplY3RfY2xhc3M7CisKKwlwYXJlbnRfY2xhc3MgPSAoR09iamVjdENsYXNz
KikgZ190eXBlX2NsYXNzX3BlZWtfcGFyZW50IChrbGFzcyk7CisJb2JqZWN0X2NsYXNzID0gKEdP
YmplY3RDbGFzcyopIGtsYXNzOworCisJb2JqZWN0X2NsYXNzLT5maW5hbGl6ZSA9IGFzdF9maW5h
bGl6ZTsKK30KKworLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCisgKgorICogIGFzdF90cmVlX21vZGVs
X2luaXQ6IGluaXQgY2FsbGJhY2sgZm9yIHRoZSBpbnRlcmZhY2UgcmVnaXN0cmF0aW9uCisgKiAg
ICAgICAgICAgICAgICAgICAgICAgaW4gYXN0X2dldF90eXBlLiBIZXJlIHdlIG92ZXJyaWRlCisg
KiAgICAgICAgICAgICAgICAgICAgICAgdGhlIEd0a1RyZWVNb2RlbCBpbnRlcmZhY2UgZnVuY3Rp
b25zIHRoYXQKKyAqICAgICAgICAgICAgICAgICAgICAgICB3ZSBpbXBsZW1lbnQuCisgKgorICoq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqLworCitzdGF0aWMgdm9pZAorYXN0X3RyZWVfbW9kZWxfaW5pdCAo
R3RrVHJlZU1vZGVsSWZhY2UgKmlmYWNlKQoreworCWlmYWNlLT5nZXRfZmxhZ3MgICAgICAgPSBh
c3RfZ2V0X2ZsYWdzOworCWlmYWNlLT5nZXRfbl9jb2x1bW5zICAgPSBhc3RfZ2V0X25fY29sdW1u
czsKKwlpZmFjZS0+Z2V0X2NvbHVtbl90eXBlID0gYXN0X2dldF9jb2x1bW5fdHlwZTsKKwlpZmFj
ZS0+Z2V0X2l0ZXIgICAgICAgID0gYXN0X2dldF9pdGVyOworCWlmYWNlLT5nZXRfcGF0aCAgICAg
ICAgPSBhc3RfZ2V0X3BhdGg7CisJaWZhY2UtPmdldF92YWx1ZSAgICAgICA9IGFzdF9nZXRfdmFs
dWU7CisJaWZhY2UtPml0ZXJfbmV4dCAgICAgICA9IGFzdF9pdGVyX25leHQ7CisJaWZhY2UtPml0
ZXJfY2hpbGRyZW4gICA9IGFzdF9pdGVyX2NoaWxkcmVuOworCWlmYWNlLT5pdGVyX2hhc19jaGls
ZCAgPSBhc3RfaXRlcl9oYXNfY2hpbGQ7CisJaWZhY2UtPml0ZXJfbl9jaGlsZHJlbiA9IGFzdF9p
dGVyX25fY2hpbGRyZW47CisJaWZhY2UtPml0ZXJfbnRoX2NoaWxkICA9IGFzdF9pdGVyX250aF9j
aGlsZDsKKwlpZmFjZS0+aXRlcl9wYXJlbnQgICAgID0gYXN0X2l0ZXJfcGFyZW50OworfQorCisK
Ky8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKgorICoKKyAqICBhc3RfaW5pdDogdGhpcyBpcyBjYWxsZWQg
ZXZlcnl0aW1lIGEgbmV3IGFzdCBub2RlIG9iamVjdAorICogICAgICAgICAgICBpbnN0YW5jZSBp
cyBjcmVhdGVkICh3ZSBkbyB0aGF0IGluIGFzdF9uZXcpLgorICogICAgICAgICAgICBJbml0aWFs
aXNlIHRoZSBsaXN0IHN0cnVjdHVyZSdzIGZpZWxkcyBoZXJlLgorICoKKyAqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKi8KKworc3RhdGljIHZvaWQKK2FzdF9pbml0IChBc3ROb2RlICpub2RlKQoreworCW5v
ZGUtPmNoaWxkbm9kZXMgPSBnX2FycmF5X25ldyhGQUxTRSwgVFJVRSwgc2l6ZW9mKEFzdE5vZGUg
KikpOworCW5vZGUtPnN0YW1wICAgID0gZ19yYW5kb21faW50KCk7IC8qIFJhbmRvbSBpbnQgdG8g
Y2hlY2sgd2hldGhlciBpdGVycyBiZWxvbmcgdG8gb3V0IG1vZGVsICovCit9CisKKworLyoqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqCisgKgorICogIGFzdF9maW5hbGl6ZTogdGhpcyBpcyBjYWxsZWQganVz
dCBiZWZvcmUgYW4gYXN0IG5vZGUgaXMKKyAqICAgICAgICAgICAgICAgIGRlc3Ryb3llZC4gRnJl
ZSBkeW5hbWljYWxseSBhbGxvY2F0ZWQgbWVtb3J5IGhlcmUuCisgKgorICoqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqLworCitzdGF0aWMgdm9pZAorYXN0X2ZpbmFsaXplIChHT2JqZWN0ICpvYmplY3QpCit7
CisJLyogIEFzdE5vZGUgKm5vZGUgPSBBU1RfTk9ERShvYmplY3QpOyAqLworCisJLyogRklYTUU6
IGZyZWUgYWxsIG5vZGUgbWVtb3J5ICovCisKKwkvKiBtdXN0IGNoYWluIHVwIC0gZmluYWxpemUg
cGFyZW50ICovCisJKCogcGFyZW50X2NsYXNzLT5maW5hbGl6ZSkgKG9iamVjdCk7Cit9CisKKwor
LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqCisgKgorICogIGFzdF9nZXRfZmxhZ3M6IHRlbGxzIHRoZSBy
ZXN0IG9mIHRoZSB3b3JsZCB3aGV0aGVyIG91ciB0cmVlIG1vZGVsCisgKiAgICAgICAgICAgICAg
ICAgaGFzIGFueSBzcGVjaWFsIGNoYXJhY3RlcmlzdGljcy4gSW4gb3VyIGNhc2UsCisgKiAgICAg
ICAgICAgICAgICAgd2UgaGF2ZSBhIGxpc3QgbW9kZWwgKGluc3RlYWQgb2YgYSB0cmVlKSwgYW5k
IGVhY2gKKyAqICAgICAgICAgICAgICAgICB0cmVlIGl0ZXIgaXMgdmFsaWQgYXMgbG9uZyBhcyB0
aGUgcm93IGluIHF1ZXN0aW9uCisgKiAgICAgICAgICAgICAgICAgZXhpc3RzLCBhcyBpdCBvbmx5
IGNvbnRhaW5zIGEgcG9pbnRlciB0byBvdXIgc3RydWN0LgorICoKKyAqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKi8KKworc3RhdGljIEd0a1RyZWVNb2RlbEZsYWdzCithc3RfZ2V0X2ZsYWdzKEd0a1RyZWVN
b2RlbCAqdHJlZV9tb2RlbCkKK3sKKwlyZXR1cm4gKEdUS19UUkVFX01PREVMX0lURVJTX1BFUlNJ
U1QpOworfQorCisKKy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgorICoKKyAqICBhc3RfZ2V0X25fY29s
dW1uczogdGVsbHMgdGhlIHJlc3Qgb2YgdGhlIHdvcmxkIGhvdyBtYW55IGRhdGEKKyAqICAgICAg
ICAgICAgICAgICAgICAgICAgICBjb2x1bW5zIHdlIGV4cG9ydCB2aWEgdGhlIHRyZWUgbW9kZWwg
aW50ZXJmYWNlCisgKgorICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLworCitzdGF0aWMgZ2ludAorYXN0
X2dldF9uX2NvbHVtbnMoR3RrVHJlZU1vZGVsICp0cmVlX21vZGVsKQoreworCXJldHVybiAxOwor
fQorCisKKy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKgorICoKKyAqICBhc3RfZ2V0X2NvbHVtbl90eXBl
OiB0ZWxscyB0aGUgcmVzdCBvZiB0aGUgd29ybGQgd2hpY2ggdHlwZSBvZgorICogICAgICAgICAg
ICAgICAgICAgICAgIGRhdGEgYW4gZXhwb3J0ZWQgbW9kZWwgY29sdW1uIGNvbnRhaW5zCisgKgor
ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqLworCitzdGF0aWMgR1R5cGUKK2FzdF9nZXRfY29sdW1uX3R5
cGUoR3RrVHJlZU1vZGVsICp0cmVlX21vZGVsLAorICAgICAgICAgICAgICAgICAgICAgICAgIGdp
bnQgaW5kZXgpCit7CisJcmV0dXJuIEdfVFlQRV9TVFJJTkc7Cit9CisKKworLyoqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqCisgKgorICogIGFzdF9nZXRfaXRlcjogY29udmVydHMgYSB0cmVlIHBhdGggKHBo
eXNpY2FsIHBvc2l0aW9uKSBpbnRvIGEKKyAqICAgICAgICAgICAgICAgIHRyZWUgaXRlciBzdHJ1
Y3R1cmUgKHRoZSBjb250ZW50IG9mIHRoZSBpdGVyCisgKiAgICAgICAgICAgICAgICBmaWVsZHMg
d2lsbCBvbmx5IGJlIHVzZWQgaW50ZXJuYWxseSBieSBvdXIgbW9kZWwpLgorICogICAgICAgICAg
ICAgICAgV2Ugc2ltcGx5IHN0b3JlIGEgcG9pbnRlciB0byBvdXIgQXN0Tm9kZUl0ZW0KKyAqICAg
ICAgICAgICAgICAgIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgdGhhdCByb3cgaW4gdGhlIHRy
ZWUgaXRlci4KKyAqCisgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovCisKK3N0YXRpYyBnYm9vbGVhbgor
YXN0X2dldF9pdGVyKEd0a1RyZWVNb2RlbCAqdHJlZV9tb2RlbCwKKyAgICAgICAgICAgICAgICAg
IEd0a1RyZWVJdGVyICAqaXRlciwKKyAgICAgICAgICAgICAgICAgIEd0a1RyZWVQYXRoICAqcGF0
aCkKK3sKKwlBc3ROb2RlICAgICpub2RlOworCWdpbnQgICAgICAgICAgKmluZGljZXMsIGRlcHRo
OworCWludCBpOworCisJbm9kZSA9IEFTVF9OT0RFKHRyZWVfbW9kZWwpOworCWluZGljZXMgPSBn
dGtfdHJlZV9wYXRoX2dldF9pbmRpY2VzKHBhdGgpOworCWRlcHRoICAgPSBndGtfdHJlZV9wYXRo
X2dldF9kZXB0aChwYXRoKTsKKworCWZvciAoaSA9IDA7IGkgPCBkZXB0aDsgaSsrKQorCQlub2Rl
ID0gYXN0X250aF9jaGlsZChub2RlLCBpbmRpY2VzW2ldKTsKKworCXJldHVybiBhc3Rfc2V0X2l0
ZXIoaXRlciwgbm9kZSk7Cit9CisKKworLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCisgKgorICogIGFz
dF9nZXRfcGF0aDogY29udmVydHMgYSB0cmVlIGl0ZXIgaW50byBhIHRyZWUgcGF0aCAoaWUuIHRo
ZQorICogICAgICAgICAgICAgICAgcGh5c2ljYWwgcG9zaXRpb24gb2YgdGhhdCByb3cgaW4gdGhl
IGxpc3QpLgorICoKKyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KKworc3RhdGljIEd0a1RyZWVQYXRo
ICoKK2FzdF9nZXRfcGF0aChHdGtUcmVlTW9kZWwgKnRyZWVfbW9kZWwsCisgICAgICAgICAgICAg
ICAgICBHdGtUcmVlSXRlciAgKml0ZXIpCit7CisJR3RrVHJlZVBhdGggICpwYXRoOworCUFzdE5v
ZGUgICAqcm9vdCA9IEFTVF9OT0RFKHRyZWVfbW9kZWwpOworCUFzdE5vZGUgICAqbm9kZSA9IEFT
VF9OT0RFKGl0ZXItPnVzZXJfZGF0YSk7CisKKwlwYXRoID0gZ3RrX3RyZWVfcGF0aF9uZXcoKTsK
Kwl3aGlsZSAobm9kZSAhPSByb290KSB7CisJCWd0a190cmVlX3BhdGhfcHJlcGVuZF9pbmRleChw
YXRoLCBub2RlLT5pbmRleCk7CisJCW5vZGUgPSBub2RlLT5wYXJlbnQ7CisJfQorCXJldHVybiBw
YXRoOworfQorCisKKy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgorICoKKyAqICBhc3RfZ2V0X3ZhbHVl
OiBSZXR1cm5zIGEgcm93J3MgZXhwb3J0ZWQgZGF0YSBjb2x1bW5zCisgKiAgICAgICAgICAgICAg
ICAgKF9nZXRfdmFsdWUgaXMgd2hhdCBndGtfdHJlZV9tb2RlbF9nZXQgdXNlcykKKyAqCisgKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKiovCisKK3N0YXRpYyB2b2lkCithc3RfZ2V0X3ZhbHVlKEd0a1RyZWVN
b2RlbCAqdHJlZV9tb2RlbCwKKyAgICAgICAgICAgICAgICAgICBHdGtUcmVlSXRlciAgKml0ZXIs
CisgICAgICAgICAgICAgICAgICAgZ2ludCAgICAgICAgICBjb2x1bW4sCisgICAgICAgICAgICAg
ICAgICAgR1ZhbHVlICAgICAgICp2YWx1ZSkKK3sKKwlBc3ROb2RlICAgICpub2RlID0gaXRlci0+
dXNlcl9kYXRhOworCisJZ19hc3NlcnQoQVNUX0lTX05PREUodHJlZV9tb2RlbCkpOworCWlmIChj
b2x1bW4gIT0gMSkKKwkJcmV0dXJuOworCisJaW5zcGVjdF9jaGlsZF9ub2RlKG5vZGUpOworCisJ
Z192YWx1ZV9pbml0KHZhbHVlLCBHX1RZUEVfU1RSSU5HKTsKKwlnX3ZhbHVlX3NldF9zdHJpbmco
dmFsdWUsIG5vZGUtPnRleHQpOworCXJldHVybjsKK30KKworCisvKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioKKyAqCisgKiAgYXN0X2l0ZXJfbmV4dDogVGFrZXMgYW4gaXRlciBzdHJ1Y3R1cmUgYW5kIHNl
dHMgaXQgdG8gcG9pbnQKKyAqICAgICAgICAgICAgICAgICB0byB0aGUgbmV4dCByb3cuCisgKgor
ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqLworCitzdGF0aWMgZ2Jvb2xlYW4KK2FzdF9pdGVyX25leHQo
R3RrVHJlZU1vZGVsICAqdHJlZV9tb2RlbCwKKyAgICAgICAgICAgICAgICAgICBHdGtUcmVlSXRl
ciAgICppdGVyKQoreworCUFzdE5vZGUgICAgKm5vZGUgPSBpdGVyLT51c2VyX2RhdGE7CisJCisJ
Z19hc3NlcnQoQVNUX0lTX05PREUgKHRyZWVfbW9kZWwpKTsKKworCW5vZGUgPSBhc3RfbnRoX2No
aWxkKG5vZGUtPnBhcmVudCwgbm9kZS0+aW5kZXggKyAxKTsKKwlyZXR1cm4gYXN0X3NldF9pdGVy
KGl0ZXIsIG5vZGUpOworfQorCisKKy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgorICoKKyAqICBhc3Rf
aXRlcl9jaGlsZHJlbjogUmV0dXJucyBUUlVFIG9yIEZBTFNFIGRlcGVuZGluZyBvbiB3aGV0aGVy
CisgKiAgICAgICAgICAgICAgICAgICAgIHRoZSByb3cgc3BlY2lmaWVkIGJ5ICdwYXJlbnQnIGhh
cyBhbnkgY2hpbGRyZW4uCisgKiAgICAgICAgICAgICAgICAgICAgIElmIGl0IGhhcyBjaGlsZHJl
biwgdGhlbiAnaXRlcicgaXMgc2V0IHRvCisgKiAgICAgICAgICAgICAgICAgICAgIHBvaW50IHRv
IHRoZSBmaXJzdCBjaGlsZC4gU3BlY2lhbCBjYXNlOiBpZgorICogICAgICAgICAgICAgICAgICAg
ICAncGFyZW50JyBpcyBOVUxMLCB0aGVuIHRoZSBmaXJzdCB0b3AtbGV2ZWwKKyAqICAgICAgICAg
ICAgICAgICAgICAgcm93IHNob3VsZCBiZSByZXR1cm5lZCBpZiBpdCBleGlzdHMuCisgKgorICoq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqLworCitzdGF0aWMgZ2Jvb2xlYW4KK2FzdF9pdGVyX2NoaWxkcmVu
KEd0a1RyZWVNb2RlbCAqdHJlZV9tb2RlbCwKKyAgICAgICAgICAgICAgICAgICAgICAgR3RrVHJl
ZUl0ZXIgICppdGVyLAorICAgICAgICAgICAgICAgICAgICAgICBHdGtUcmVlSXRlciAgKnBhcmVu
dCkKK3sKKwlyZXR1cm4gYXN0X2l0ZXJfbnRoX2NoaWxkKHRyZWVfbW9kZWwsIGl0ZXIsIHBhcmVu
dCwgMCk7Cit9CisKKworLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCisgKgorICogIGFzdF9pdGVyX2hh
c19jaGlsZDogUmV0dXJucyBUUlVFIG9yIEZBTFNFIGRlcGVuZGluZyBvbiB3aGV0aGVyCisgKiAg
ICAgICAgICAgICAgICAgICAgICB0aGUgcm93IHNwZWNpZmllZCBieSAnaXRlcicgaGFzIGFueSBj
aGlsZHJlbi4KKyAqICAgICAgICAgICAgICAgICAgICAgIFdlIG9ubHkgaGF2ZSBhIGxpc3QgYW5k
IHRodXMgbm8gY2hpbGRyZW4uCisgKgorICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLworCitzdGF0aWMg
Z2Jvb2xlYW4KK2FzdF9pdGVyX2hhc19jaGlsZCAoR3RrVHJlZU1vZGVsICp0cmVlX21vZGVsLAor
ICAgICAgICAgICAgICAgICAgICAgICAgIEd0a1RyZWVJdGVyICAqaXRlcikKK3sKKwlBc3ROb2Rl
ICAgICpub2RlID0gaXRlci0+dXNlcl9kYXRhOworCWluc3BlY3RfY2hpbGRfbm9kZShub2RlKTsK
KwlyZXR1cm4gbm9kZS0+Y2hpbGRub2Rlcy0+bGVuID4gMDsKK30KKworCisvKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioKKyAqCisgKiAgYXN0X2l0ZXJfbl9jaGlsZHJlbjogUmV0dXJucyB0aGUgbnVtYmVy
IG9mIGNoaWxkcmVuIHRoZSByb3cKKyAqICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWQg
YnkgJ2l0ZXInIGhhcy4gVGhpcyBpcyB1c3VhbGx5IDAsCisgKiAgICAgICAgICAgICAgICAgICAg
ICAgYXMgd2Ugb25seSBoYXZlIGEgbGlzdCBhbmQgdGh1cyBkbyBub3QgaGF2ZQorICogICAgICAg
ICAgICAgICAgICAgICAgIGFueSBjaGlsZHJlbiB0byBhbnkgcm93cy4gQSBzcGVjaWFsIGNhc2Ug
aXMKKyAqICAgICAgICAgICAgICAgICAgICAgICB3aGVuICdpdGVyJyBpcyBOVUxMLCBpbiB3aGlj
aCBjYXNlIHdlIG5lZWQKKyAqICAgICAgICAgICAgICAgICAgICAgICB0byByZXR1cm4gdGhlIG51
bWJlciBvZiB0b3AtbGV2ZWwgbm9kZSwKKyAqICAgICAgICAgICAgICAgICAgICAgICBpZS4gdGhl
IG51bWJlciBvZiByb3dzIGluIG91ciBsaXN0LgorICoKKyAqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8K
Kworc3RhdGljIGdpbnQKK2FzdF9pdGVyX25fY2hpbGRyZW4gKEd0a1RyZWVNb2RlbCAqdHJlZV9t
b2RlbCwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgR3RrVHJlZUl0ZXIgICppdGVyKQorewor
CUFzdE5vZGUgICpub2RlID0gaXRlci0+dXNlcl9kYXRhOworCisJaW5zcGVjdF9jaGlsZF9ub2Rl
KG5vZGUpOworCXJldHVybiBub2RlLT5jaGlsZG5vZGVzLT5sZW47Cit9CisKKworLyoqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqCisgKgorICogIGFzdF9pdGVyX250aF9jaGlsZDogSWYgdGhlIHJvdyBzcGVj
aWZpZWQgYnkgJ3BhcmVudCcgaGFzIGFueQorICogICAgICAgICAgICAgICAgICAgICAgY2hpbGRy
ZW4sIHNldCAnaXRlcicgdG8gdGhlIG4tdGggY2hpbGQgYW5kCisgKiAgICAgICAgICAgICAgICAg
ICAgICByZXR1cm4gVFJVRSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBGQUxTRS4KKyAqICAgICAg
ICAgICAgICAgICAgICAgIEEgc3BlY2lhbCBjYXNlIGlzIHdoZW4gJ3BhcmVudCcgaXMgTlVMTCwg
aW4KKyAqICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGNhc2Ugd2UgbmVlZCB0byBzZXQgJ2l0
ZXInIHRvIHRoZSBuLXRoCisgKiAgICAgICAgICAgICAgICAgICAgICByb3cgaWYgaXQgZXhpc3Rz
LgorICoKKyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KKworc3RhdGljIGdib29sZWFuCithc3RfaXRl
cl9udGhfY2hpbGQoR3RrVHJlZU1vZGVsICp0cmVlX21vZGVsLAorICAgICAgICAgICAgICAgICAg
ICAgICAgR3RrVHJlZUl0ZXIgICppdGVyLAorICAgICAgICAgICAgICAgICAgICAgICAgR3RrVHJl
ZUl0ZXIgICpwYXJlbnQsCisgICAgICAgICAgICAgICAgICAgICAgICBnaW50ICAgICAgICAgIG4p
Cit7CisJQXN0Tm9kZSAgICAqbm9kZSA9IHBhcmVudCA/IHBhcmVudC0+dXNlcl9kYXRhIDogKEFz
dE5vZGUqKSB0cmVlX21vZGVsOworCUdBcnJheSAqYXJyYXkgPSBub2RlLT5jaGlsZG5vZGVzOwor
CWlmIChuID49IGFycmF5LT5sZW4pCisJCXJldHVybiBGQUxTRTsKKwlpdGVyLT51c2VyX2RhdGEg
PSBnX2FycmF5X2luZGV4KGFycmF5LCBBc3ROb2RlICosIG4pOworCXJldHVybiBUUlVFOworfQor
CisKKy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKgorICoKKyAqICBhc3RfaXRlcl9wYXJlbnQ6IFBvaW50
ICdpdGVyJyB0byB0aGUgcGFyZW50IG5vZGUgb2YgJ2NoaWxkJy4gQXMKKyAqICAgICAgICAgICAg
ICAgICAgIHdlIGhhdmUgYSBsaXN0IGFuZCB0aHVzIG5vIGNoaWxkcmVuIGFuZCBubworICogICAg
ICAgICAgICAgICAgICAgcGFyZW50cyBvZiBjaGlsZHJlbiwgd2UgY2FuIGp1c3QgcmV0dXJuIEZB
TFNFLgorICoKKyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KKworc3RhdGljIGdib29sZWFuCithc3Rf
aXRlcl9wYXJlbnQgKEd0a1RyZWVNb2RlbCAqdHJlZV9tb2RlbCwKKyAgICAgICAgICAgICAgICAg
ICAgICBHdGtUcmVlSXRlciAgKml0ZXIsCisgICAgICAgICAgICAgICAgICAgICAgR3RrVHJlZUl0
ZXIgICpjaGlsZCkKK3sKKwlBc3ROb2RlICpub2RlID0gKEFzdE5vZGUgKikgY2hpbGQtPnVzZXJf
ZGF0YTsKKwlpdGVyLT51c2VyX2RhdGEgPSBub2RlLT5wYXJlbnQ7CisJcmV0dXJuIG5vZGUtPnBh
cmVudCAhPSBOVUxMOworfQorCisKK0FzdE5vZGUgKgorYXN0X25ldyAoQXN0Tm9kZSAqcGFyZW50
LCBpbnQgaW5kZXgsIGNvbnN0IGNoYXIgKnRleHQsIHZvaWQgKnB0ciwgdm9pZCAoKmluc3BlY3Qp
KEFzdE5vZGUqKSkKK3sKKwlBc3ROb2RlICpub2RlID0gKEFzdE5vZGUqKSBnX29iamVjdF9uZXcg
KEFTVF9UWVBFX05PREUsIE5VTEwpOworCWdfYXNzZXJ0KG5vZGUgIT0gTlVMTCk7CisJbm9kZS0+
cGFyZW50ID0gcGFyZW50OworCW5vZGUtPmluZGV4ID0gaW5kZXg7CisJbm9kZS0+dGV4dCA9IHRl
eHQ7CisJbm9kZS0+aW5zcGVjdCA9IGluc3BlY3Q7CisJbm9kZS0+cHRyID0gcHRyOworCXJldHVy
biBub2RlOworfQorCmRpZmYgLS1naXQgYS9hc3QtbW9kZWwuaCBiL2FzdC1tb2RlbC5oCm5ldyBm
aWxlIG1vZGUgMTAwNjQ0CmluZGV4IDAwMDAwMDAuLjJlZWEwNTYKLS0tIC9kZXYvbnVsbAorKysg
Yi9hc3QtbW9kZWwuaApAQCAtMCwwICsxLDg4IEBACisKKy8qCisgKiBhc3QtbW9kZWwuaAorICoK
KyAqIENvcHlyaWdodCAoQykgMjAxMCBDaHJpc3RvcGhlciBMaS4KKyAqCisgKi8KKworI2lmbmRl
ZiBfYXN0X21vZGVsX2hfCisjZGVmaW5lIF9hc3RfbW9kZWxfaF8KKworI2luY2x1ZGUgPHN0ZGlu
dC5oPgorI2luY2x1ZGUgPGd0ay9ndGsuaD4KKyNpbmNsdWRlICJsaWIuaCIKKworI2RlZmluZSBB
U1RfVFlQRV9OT0RFICAgICAgICAgICAgICAgICAgKGFzdF9nZXRfdHlwZSAoKSkKKyNkZWZpbmUg
QVNUX05PREUob2JqKSAgICAgICAgICAgICAgICAgIChHX1RZUEVfQ0hFQ0tfSU5TVEFOQ0VfQ0FT
VCAoKG9iaiksIEFTVF9UWVBFX05PREUsIEFzdE5vZGUpKQorI2RlZmluZSBBU1RfTk9ERV9DTEFT
UyhrbGFzcykgICAgICAgICAgKEdfVFlQRV9DSEVDS19DTEFTU19DQVNUICgoa2xhc3MpLCAgQVNU
X1RZUEVfTk9ERSwgQXN0Tm9kZUNsYXNzKSkKKyNkZWZpbmUgQVNUX0lTX05PREUob2JqKSAgICAg
ICAgICAgICAgIChHX1RZUEVfQ0hFQ0tfSU5TVEFOQ0VfVFlQRSAoKG9iaiksIEFTVF9UWVBFX05P
REUpKQorI2RlZmluZSBBU1RfSVNfTk9ERV9DTEFTUyhrbGFzcykgICAgICAgKEdfVFlQRV9DSEVD
S19DTEFTU19UWVBFICgoa2xhc3MpLCAgQVNUX1RZUEVfTk9ERSkpCisjZGVmaW5lIEFTVF9OT0RF
X0dFVF9DTEFTUyhvYmopICAgICAgICAoR19UWVBFX0lOU1RBTkNFX0dFVF9DTEFTUyAoKG9iaiks
ICBBU1RfVFlQRV9OT0RFLCBBc3ROb2RlQ2xhc3MpKQorCitlbnVtCit7CisJQVNUX0NPTF9SRUNP
UkQgPSAwLAorCUFTVF9DT0xfTkFNRSwKKwlBU1RfTl9DT0xVTU5TLAorfSA7CisKKwordHlwZWRl
ZiBzdHJ1Y3QgQXN0Tm9kZSBBc3ROb2RlOwordHlwZWRlZiBzdHJ1Y3QgQXN0Tm9kZUNsYXNzIEFz
dE5vZGVDbGFzczsKKworCisKKy8qIEFzdE5vZGU6IHRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGV2
ZXJ5dGhpbmcgd2UgbmVlZCBmb3Igb3VyCisgKiAgICAgICAgICAgICBtb2RlbCBpbXBsZW1lbnRh
dGlvbi4gWW91IGNhbiBhZGQgZXh0cmEgZmllbGRzIHRvCisgKiAgICAgICAgICAgICB0aGlzIHN0
cnVjdHVyZSwgZS5nLiBoYXNodGFibGVzIHRvIHF1aWNrbHkgbG9va3VwCisgKiAgICAgICAgICAg
ICByb3dzIG9yIHdoYXRldmVyIGVsc2UgeW91IG1pZ2h0IG5lZWQsIGJ1dCBpdCBpcworICogICAg
ICAgICAgICAgY3J1Y2lhbCB0aGF0ICdwYXJlbnQnIGlzIHRoZSBmaXJzdCBtZW1iZXIgb2YgdGhl
CisgKiAgICAgICAgICAgICBzdHJ1Y3R1cmUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgKi8KKworc3RydWN0IEFzdE5vZGUKK3sKKwlHT2JqZWN0ICAgICAgICAgYmFz
ZTsgICAgICAvKiB0aGlzIE1VU1QgYmUgdGhlIGZpcnN0IG1lbWJlciAqLworCisJQXN0Tm9kZQkq
cGFyZW50OworCWludCBpbmRleDsKKwljb25zdCBnY2hhciAqdGV4dDsKKwl2b2lkICgqaW5zcGVj
dCkoc3RydWN0IEFzdE5vZGUqIG5vZGUpOworCXZvaWQgKnB0cjsKKwlHQXJyYXkgKmNoaWxkbm9k
ZXM7CisJZ2ludCBzdGFtcDsKK307CisKKworCisvKiBBc3ROb2RlQ2xhc3M6IG1vcmUgYm9pbGVy
cGxhdGUgR09iamVjdCBzdHVmZiAqLworCitzdHJ1Y3QgQXN0Tm9kZUNsYXNzCit7CisJR09iamVj
dENsYXNzIGJhc2VfY2xhc3M7Cit9OworCisKK0dUeXBlIGFzdF9nZXRfdHlwZSh2b2lkKTsKK0Fz
dE5vZGUqIGFzdF9uZXcoQXN0Tm9kZSAqcGFyZW50LCBpbnQgaW5kZXgsIGNvbnN0IGNoYXIgKnBy
ZWZpeCwgdm9pZCAqcHRyLCB2b2lkICgqZXhwYW5kKShBc3ROb2RlKikpOworCisKK3N0YXRpYyBp
bmxpbmUKK3ZvaWQgYXN0X2FwcGVuZF9jaGlsZChBc3ROb2RlICpwYXJlbnQsIGNvbnN0IGNoYXIg
KnRleHQsCisJCQkgICB2b2lkICpwdHIsIHZvaWQgKCppbnNwZWN0KShBc3ROb2RlKikpCit7CisJ
aWYgKHB0cikgeworCQlBc3ROb2RlICpjaGlsZCA9IGFzdF9uZXcocGFyZW50LCBwYXJlbnQtPmNo
aWxkbm9kZXMtPmxlbiwKKwkJCQkJCXRleHQsIHB0ciwgaW5zcGVjdCk7CisJCWdfYXJyYXlfYXBw
ZW5kX3ZhbChwYXJlbnQtPmNoaWxkbm9kZXMsIGNoaWxkKTsKKwl9Cit9CisKK3N0YXRpYyBpbmxp
bmUKK3ZvaWQgYXN0X2FwcGVuZF9hdHRyaWJ1dGUoQXN0Tm9kZSAqcGFyZW50LCBjb25zdCBjaGFy
ICp0ZXh0KQoreworCUFzdE5vZGUgKmNoaWxkID0gYXN0X25ldyhwYXJlbnQsIHBhcmVudC0+Y2hp
bGRub2Rlcy0+bGVuLCB0ZXh0LCBOVUxMLCBOVUxMKTsKKwlnX2FycmF5X2FwcGVuZF92YWwocGFy
ZW50LT5jaGlsZG5vZGVzLCBjaGlsZCk7Cit9CisKKyNlbmRpZiAvKiBfYXN0X2hfKi8KZGlmZiAt
LWdpdCBhL2FzdC12aWV3LmMgYi9hc3Qtdmlldy5jCm5ldyBmaWxlIG1vZGUgMTAwNjQ0CmluZGV4
IDAwMDAwMDAuLjQwYmYwNjAKLS0tIC9kZXYvbnVsbAorKysgYi9hc3Qtdmlldy5jCkBAIC0wLDAg
KzEsNDggQEAKKworI2luY2x1ZGUgPHN0ZGxpYi5oPgorI2luY2x1ZGUgImFzdC1tb2RlbC5oIgor
I2luY2x1ZGUgImFzdC1pbnNwZWN0LmgiCisKK0d0a1dpZGdldCAqCitjcmVhdGVfdmlld19hbmRf
bW9kZWwgKHZvaWQgKnB0cikKK3sKKwlHdGtUcmVlVmlld0NvbHVtbiAgICp0ZXh0OworCUd0a0Nl
bGxSZW5kZXJlciAqcmVuZGVyZXI7CisJQXN0Tm9kZSAqcm9vdDsKKwlHdGtXaWRnZXQgKnZpZXc7
CisKKwlyb290ID0gYXN0X25ldyhOVUxMLCAwLCAiIiwgcHRyLCBpbnNwZWN0X3N5bWJvbF9saXN0
KTsKKworCXZpZXcgPSBndGtfdHJlZV92aWV3X25ld193aXRoX21vZGVsKEdUS19UUkVFX01PREVM
KHJvb3QpKTsKKworCWdfb2JqZWN0X3VucmVmKHJvb3QpOyAvKiBkZXN0cm95IHN0b3JlIGF1dG9t
YXRpY2FsbHkgd2l0aCB2aWV3ICovCisKKwlyZW5kZXJlciA9IGd0a19jZWxsX3JlbmRlcmVyX3Rl
eHRfbmV3KCk7CisJdGV4dCA9IGd0a190cmVlX3ZpZXdfY29sdW1uX25ld193aXRoX2F0dHJpYnV0
ZXMoIk5vZGUiLCByZW5kZXJlciwKKwkJCQkJCSAgICAgICAidGV4dCIsIEFTVF9DT0xfTkFNRSwK
KwkJCQkJCSAgICAgICBOVUxMKTsKKwlndGtfdHJlZV92aWV3X2FwcGVuZF9jb2x1bW4oR1RLX1RS
RUVfVklFVyh2aWV3KSwgdGV4dCk7CisKKwlyZXR1cm4gdmlldzsKK30KKwordm9pZAordHJlZXZp
ZXdfbWFpbiAoc3RydWN0IHN5bWJvbF9saXN0ICpzeW1zKQoreworCUd0a1dpZGdldCAqd2luZG93
LCAqdmlldywgKnNjcm9sbHdpbjsKKworCXdpbmRvdyA9IGd0a193aW5kb3dfbmV3KEdUS19XSU5E
T1dfVE9QTEVWRUwpOworCWd0a193aW5kb3dfc2V0X2RlZmF1bHRfc2l6ZSAoR1RLX1dJTkRPVyh3
aW5kb3cpLCA0MDAsIDYwMCk7CisJZ19zaWduYWxfY29ubmVjdCh3aW5kb3csICJkZWxldGVfZXZl
bnQiLCBndGtfbWFpbl9xdWl0LCBOVUxMKTsKKworCXNjcm9sbHdpbiA9IGd0a19zY3JvbGxlZF93
aW5kb3dfbmV3KE5VTEwsTlVMTCk7CisKKwl2aWV3ID0gY3JlYXRlX3ZpZXdfYW5kX21vZGVsKHN5
bXMpOworCisJZ3RrX2NvbnRhaW5lcl9hZGQoR1RLX0NPTlRBSU5FUihzY3JvbGx3aW4pLCB2aWV3
KTsKKwlndGtfY29udGFpbmVyX2FkZChHVEtfQ09OVEFJTkVSKHdpbmRvdyksIHNjcm9sbHdpbik7
CisKKwlndGtfd2lkZ2V0X3Nob3dfYWxsKHdpbmRvdyk7CisKKwlndGtfbWFpbigpOworfQpkaWZm
IC0tZ2l0IGEvYXN0LXZpZXcuaCBiL2FzdC12aWV3LmgKbmV3IGZpbGUgbW9kZSAxMDA2NDQKaW5k
ZXggMDAwMDAwMC4uZGE4ZjVmNQotLS0gL2Rldi9udWxsCisrKyBiL2FzdC12aWV3LmgKQEAgLTAs
MCArMSw3IEBACisKKyNpbmNsdWRlIDxndGsvZ3RrLmg+CisjaW5jbHVkZSAibGliLmgiCisKK2V4
dGVybiB2b2lkIHRyZWV2aWV3X21haW4oc3RydWN0IHN5bWJvbF9saXN0ICpzeW1zKTsKKworCi0t
IAoxLjYuNi4xCgo=
--000e0cd6316ce90d070483454e8a--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] parser: define __builtin_unreachable ===

From: Jiri Slaby <jslaby () suse ! cz>
To: linux-kernel
Subject: [PATCH 2/2] parser: define __builtin_unreachable
Date: Sat, 10 Jul 2010 08:39:22 +0000
Message-ID: <1278751162-10053-2-git-send-email-jslaby () suse ! cz>
--------------------
Gcc 4.5 defines
extern void __builtin_unreachable(void);
so, add it also to sparse.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 lib.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index a218bfc..ae6a20c 100644
--- a/lib.c
+++ b/lib.c
@@ -740,6 +740,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer ("extern char * __builtin___strncpy_chk(char *, const char *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
 	add_pre_buffer ("extern int __builtin___vsprintf_chk(char *, int, __SIZE_TYPE__, const char *, __builtin_va_list);\n");
 	add_pre_buffer ("extern int __builtin___vsnprintf_chk(char *, __SIZE_TYPE__, int, __SIZE_TYPE__, const char *, __builtin_va_list ap);\n");
+	add_pre_buffer ("extern void __builtin_unreachable(void);\n");
 }
 
 void create_builtin_stream(void)
-- 
1.7.1


--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] parser: define __builtin_unreachable
Date: Sat, 10 Jul 2010 09:07:06 +0000
Message-ID: <20100710090705.GA14881 () feather>
--------------------
On Sat, Jul 10, 2010 at 10:39:22AM +0200, Jiri Slaby wrote:
> Gcc 4.5 defines
> extern void __builtin_unreachable(void);
> so, add it also to sparse.
> 
> Signed-off-by: Jiri Slaby <jslaby@suse.cz>
> ---
>  lib.c |    1 +
>  1 files changed, 1 insertions(+), 0 deletions(-)
> 
> diff --git a/lib.c b/lib.c
> index a218bfc..ae6a20c 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -740,6 +740,7 @@ void declare_builtin_functions(void)
>  	add_pre_buffer ("extern char * __builtin___strncpy_chk(char *, const char *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
>  	add_pre_buffer ("extern int __builtin___vsprintf_chk(char *, int, __SIZE_TYPE__, const char *, __builtin_va_list);\n");
>  	add_pre_buffer ("extern int __builtin___vsnprintf_chk(char *, __SIZE_TYPE__, int, __SIZE_TYPE__, const char *, __builtin_va_list ap);\n");
> +	add_pre_buffer ("extern void __builtin_unreachable(void);\n");

__builtin_unreachable has special semantics beyond just a function.
This definition will suffice to allow compilation, but
__builtin_unreachable should have the same effect in sparse that it does
in GCC: mark the point (and the remainder of the basic block) as
unreachable.  Something like the mechanism used for handling noreturn
would work here as well; declaring the function to have attribute
noreturn would probably have almost the right semantics.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-kernel
Subject: Re: [PATCH 2/2] parser: define __builtin_unreachable
Date: Sat, 10 Jul 2010 09:07:06 +0000
Message-ID: <20100710090705.GA14881 () feather>
--------------------
On Sat, Jul 10, 2010 at 10:39:22AM +0200, Jiri Slaby wrote:
> Gcc 4.5 defines
> extern void __builtin_unreachable(void);
> so, add it also to sparse.
> 
> Signed-off-by: Jiri Slaby <jslaby@suse.cz>
> ---
>  lib.c |    1 +
>  1 files changed, 1 insertions(+), 0 deletions(-)
> 
> diff --git a/lib.c b/lib.c
> index a218bfc..ae6a20c 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -740,6 +740,7 @@ void declare_builtin_functions(void)
>  	add_pre_buffer ("extern char * __builtin___strncpy_chk(char *, const char *, __SIZE_TYPE__, __SIZE_TYPE__);\n");
>  	add_pre_buffer ("extern int __builtin___vsprintf_chk(char *, int, __SIZE_TYPE__, const char *, __builtin_va_list);\n");
>  	add_pre_buffer ("extern int __builtin___vsnprintf_chk(char *, __SIZE_TYPE__, int, __SIZE_TYPE__, const char *, __builtin_va_list ap);\n");
> +	add_pre_buffer ("extern void __builtin_unreachable(void);\n");

__builtin_unreachable has special semantics beyond just a function.
This definition will suffice to allow compilation, but
__builtin_unreachable should have the same effect in sparse that it does
in GCC: mark the point (and the remainder of the basic block) as
unreachable.  Something like the mechanism used for handling noreturn
would work here as well; declaring the function to have attribute
noreturn would probably have almost the right semantics.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Chris Li <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] parser: define __builtin_unreachable
Date: Tue, 13 Jul 2010 07:52:48 +0000
Message-ID: <AANLkTimf821jhfhU-Rsj7xa2S4EzuP23weoUSZVWsD2u () mail ! gmail ! com>
--------------------
On Sat, Jul 10, 2010 at 2:07 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> __builtin_unreachable has special semantics beyond just a function.
> This definition will suffice to allow compilation, but
> __builtin_unreachable should have the same effect in sparse that it does
> in GCC: mark the point (and the remainder of the basic block) as
> unreachable.  Something like the mechanism used for handling noreturn
> would work here as well; declaring the function to have attribute
> noreturn would probably have almost the right semantics.
>

The attribute noreturn will apply to the whole function. The function
NEVER returns.
__builtin_unreachable only apply to current basic block. e.g. some
error handling path like panic. The function can still return a value on the
normal path. It has different meaning than attribute noreturn. So I don't think
automatically give the function noreturn attribute is the right thing to do.

I will apply the patch until we got better way to handle this.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Li <christ.li () gmail ! com>
To: linux-kernel
Subject: Re: [PATCH 2/2] parser: define __builtin_unreachable
Date: Tue, 13 Jul 2010 07:52:48 +0000
Message-ID: <AANLkTimf821jhfhU-Rsj7xa2S4EzuP23weoUSZVWsD2u () mail ! gmail ! com>
--------------------
On Sat, Jul 10, 2010 at 2:07 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> __builtin_unreachable has special semantics beyond just a function.
> This definition will suffice to allow compilation, but
> __builtin_unreachable should have the same effect in sparse that it does
> in GCC: mark the point (and the remainder of the basic block) as
> unreachable.  Something like the mechanism used for handling noreturn
> would work here as well; declaring the function to have attribute
> noreturn would probably have almost the right semantics.
>

The attribute noreturn will apply to the whole function. The function
NEVER returns.
__builtin_unreachable only apply to current basic block. e.g. some
error handling path like panic. The function can still return a value on the
normal path. It has different meaning than attribute noreturn. So I don't think
automatically give the function noreturn attribute is the right thing to do.

I will apply the patch until we got better way to handle this.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] parser: define __builtin_unreachable
Date: Tue, 13 Jul 2010 18:12:13 +0000
Message-ID: <20100713181212.GB20289 () feather>
--------------------
On Tue, Jul 13, 2010 at 12:52:48AM -0700, Chris Li wrote:
> On Sat, Jul 10, 2010 at 2:07 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> > __builtin_unreachable has special semantics beyond just a function.
> > This definition will suffice to allow compilation, but
> > __builtin_unreachable should have the same effect in sparse that it does
> > in GCC: mark the point (and the remainder of the basic block) as
> > unreachable.  Something like the mechanism used for handling noreturn
> > would work here as well; declaring the function to have attribute
> > noreturn would probably have almost the right semantics.
> >
> 
> The attribute noreturn will apply to the whole function. The function
> NEVER returns.
> __builtin_unreachable only apply to current basic block. e.g. some
> error handling path like panic. The function can still return a value on the
> normal path. It has different meaning than attribute noreturn. So I don't think
> automatically give the function noreturn attribute is the right thing to do.

No, I didn't mean that using __builtin_unreachable should mark the
function calling it as noreturn.  I meant that as an approximation to
the right behavior, __builtin_unreachable *itself* could have attribute
noreturn.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Li <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] parser: define __builtin_unreachable
Date: Tue, 13 Jul 2010 18:49:12 +0000
Message-ID: <AANLkTinC0TTj1KLp-l_GWO79V4tX4Q62WVEH77_imEtL () mail ! gmail ! com>
--------------------
On Tue, Jul 13, 2010 at 11:12 AM, Josh Triplett <josh@joshtriplett.org> wrote:
> No, I didn't mean that using __builtin_unreachable should mark the
> function calling it as noreturn.  I meant that as an approximation to
> the right behavior, __builtin_unreachable *itself* could have attribute
> noreturn.

Ah, that make sense.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/4] inspect: Add test-inspect program ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 3/4] inspect: Add test-inspect program
Date: Fri, 02 Apr 2010 18:43:40 +0000
Message-ID: <m2i70318cbf1004021143lfb587e90zd66d9de22535a6d6 () mail ! gmail ! com>
--------------------
--000e0cd76280a32e950483455bce
Content-Type: text/plain; charset=ISO-8859-1

The test program will launch a gtk treeview windows to
display the symbol node in the AST.

Chris

--000e0cd76280a32e950483455bce
Content-Type: application/octet-stream; 
	name="0003-inspect-Add-test-inspect-program.patch"
Content-Disposition: attachment; 
	filename="0003-inspect-Add-test-inspect-program.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_g7jejh010

RnJvbSA1NDg4OTYwMTYyYjg1ZTRiYWNlMjlkMjBhYzQ0ZGNlYTE5Yjk0ODg4IE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBUdWUsIDMwIE1hciAyMDEwIDE1OjQ5OjE2IC0wNzAwClN1YmplY3Q6IFtQQVRDSCAzLzRd
IGluc3BlY3Q6IEFkZCB0ZXN0LWluc3BlY3QgcHJvZ3JhbQoKVGhlIHRlc3QgcHJvZ3JhbSB3aWxs
IGxhdW5jaCBhIGd0ayB0cmVldmlldyB3aW5kb3dzIHRvCmRpc3BsYXkgdGhlIHN5bWJvbCBub2Rl
IGluIHRoZSBBU1QuCi0tLQogTWFrZWZpbGUgICAgICAgfCAgIDE3ICsrKysrKysrKysrKysrLS0t
CiB0ZXN0LWluc3BlY3QuYyB8ICAgNDMgKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysr
KysrKysrKysrKwogMiBmaWxlcyBjaGFuZ2VkLCA1NyBpbnNlcnRpb25zKCspLCAzIGRlbGV0aW9u
cygtKQogY3JlYXRlIG1vZGUgMTAwNjQ0IHRlc3QtaW5zcGVjdC5jCgpkaWZmIC0tZ2l0IGEvTWFr
ZWZpbGUgYi9NYWtlZmlsZQppbmRleCBiMDdmNDcyLi4yODI1ZTU4IDEwMDY0NAotLS0gYS9NYWtl
ZmlsZQorKysgYi9NYWtlZmlsZQpAQCAtMTUsMTAgKzE1LDExIEBAIEFSID0gYXIKICMgICAgIENG
TEFHUyArPSAtTzAgLURERUJVRyAtZzMgLWdkd2FyZi0yCiAjCiAKLUhBVkVfTElCWE1MPSQoc2hl
bGwgcGtnLWNvbmZpZyAtLWV4aXN0cyBsaWJ4bWwtMi4wIDI+L2Rldi9udWxsICYmIGVjaG8gJ3ll
cycpCi1IQVZFX0dDQ19ERVA9JChzaGVsbCB0b3VjaCAuZ2NjLXRlc3QuYyAmJiAJCQkJXAorSEFW
RV9MSUJYTUw6PSQoc2hlbGwgcGtnLWNvbmZpZyAtLWV4aXN0cyBsaWJ4bWwtMi4wIDI+L2Rldi9u
dWxsICYmIGVjaG8gJ3llcycpCitIQVZFX0dDQ19ERVA6PSQoc2hlbGwgdG91Y2ggLmdjYy10ZXN0
LmMgJiYgCQkJCVwKIAkJJChDQykgLWMgLVdwLC1NRCwuZ2NjLXRlc3QuZCAuZ2NjLXRlc3QuYyAy
Pi9kZXYvbnVsbCAmJiBcCiAJCWVjaG8gJ3llcyc7IHJtIC1mIC5nY2MtdGVzdC5kIC5nY2MtdGVz
dC5vIC5nY2MtdGVzdC5jKQorSEFWRV9HVEsyOj0kKHNoZWxsIHBrZy1jb25maWcgLS1leGlzdHMg
Z3RrKy0yLjAgMj4vZGV2L251bGwgJiYgZWNobyAneWVzJykKIAogQ0ZMQUdTICs9IC1ER0NDX0JB
U0U9XCIkKHNoZWxsICQoQ0MpIC0tcHJpbnQtZmlsZS1uYW1lPSlcIgogCkBAIC00Niw2ICs0Nywx
NiBAQCBJTlNUX1BST0dSQU1TKz1jMnhtbAogYzJ4bWxfRVhUUkFfT0JKUyA9IGBwa2ctY29uZmln
IC0tbGlicyBsaWJ4bWwtMi4wYAogZW5kaWYKIAoraWZlcSAoJChIQVZFX0dUSzIpLHllcykKK0dU
SzJfQ0ZMQUdTIDo9ICQoc2hlbGwgcGtnLWNvbmZpZyAtLWNmbGFncyBndGsrLTIuMCkKK0dUSzJf
TElCUyA6PSAkKHNoZWxsIHBrZy1jb25maWcgLS1saWJzIGd0aystMi4wKQorUFJPR1JBTVMgKz0g
dGVzdC1pbnNwZWN0CitJTlNUX1BST0dSQU1TICs9IHRlc3QtaW5zcGVjdAordGVzdC1pbnNwZWN0
X0VYVFJBX0RFUFMgOj0gYXN0LW1vZGVsLm8gYXN0LXZpZXcubyBhc3QtaW5zcGVjdC5vCit0ZXN0
LWluc3BlY3QubyAkKHRlc3QtaW5zcGVjdF9FWFRSQV9ERVBTKTogQ0ZMQUdTICs9ICQoR1RLMl9D
RkxBR1MpCit0ZXN0LWluc3BlY3RfRVhUUkFfT0JKUyA6PSAkKEdUSzJfTElCUykKK2VuZGlmCisK
IExJQl9IPSAgICB0b2tlbi5oIHBhcnNlLmggbGliLmggc3ltYm9sLmggc2NvcGUuaCBleHByZXNz
aW9uLmggdGFyZ2V0LmggXAogCSAgbGluZWFyaXplLmggYml0bWFwLmggaWRlbnQtbGlzdC5oIGNv
bXBhdC5oIGZsb3cuaCBhbGxvY2F0ZS5oIFwKIAkgIHN0b3JhZ2UuaCBwdHJsaXN0LmggZGlzc2Vj
dC5oCkBAIC0xNDEsNyArMTUyLDcgQEAgY29tcGF0LXNvbGFyaXMubzogY29tcGF0L21tYXAtYmxv
Yi5jICQoTElCX0gpCiBjb21wYXQtbWluZ3cubzogJChMSUJfSCkKIGNvbXBhdC1jeWd3aW4ubzog
JChMSUJfSCkKIAotLmMubzoKKyUubzogJS5jCiAJJChRVUlFVF9DQykkKENDKSAtbyAkQCAtYyAk
KENGTEFHUykgJDwKIAogY2xlYW46IGNsZWFuLWNoZWNrCmRpZmYgLS1naXQgYS90ZXN0LWluc3Bl
Y3QuYyBiL3Rlc3QtaW5zcGVjdC5jCm5ldyBmaWxlIG1vZGUgMTAwNjQ0CmluZGV4IDAwMDAwMDAu
LmU0MzdlMTEKLS0tIC9kZXYvbnVsbAorKysgYi90ZXN0LWluc3BlY3QuYwpAQCAtMCwwICsxLDQz
IEBACisKKyNpbmNsdWRlIDxzdGRhcmcuaD4KKyNpbmNsdWRlIDxzdGRsaWIuaD4KKyNpbmNsdWRl
IDxzdGRpby5oPgorI2luY2x1ZGUgPHN0cmluZy5oPgorI2luY2x1ZGUgPGN0eXBlLmg+CisjaW5j
bHVkZSA8dW5pc3RkLmg+CisjaW5jbHVkZSA8ZmNudGwuaD4KKworI2luY2x1ZGUgImxpYi5oIgor
I2luY2x1ZGUgImFsbG9jYXRlLmgiCisjaW5jbHVkZSAidG9rZW4uaCIKKyNpbmNsdWRlICJwYXJz
ZS5oIgorI2luY2x1ZGUgInN5bWJvbC5oIgorI2luY2x1ZGUgImV4cHJlc3Npb24uaCIKKworI2lu
Y2x1ZGUgImFzdC12aWV3LmgiCisKK3N0YXRpYyB2b2lkIGV4cGFuZF9zeW1ib2xzKHN0cnVjdCBz
eW1ib2xfbGlzdCAqbGlzdCkKK3sKKwlzdHJ1Y3Qgc3ltYm9sICpzeW07CisJRk9SX0VBQ0hfUFRS
KGxpc3QsIHN5bSkgeworCQlleHBhbmRfc3ltYm9sKHN5bSk7CisJfSBFTkRfRk9SX0VBQ0hfUFRS
KHN5bSk7Cit9CisKK2ludCBtYWluKGludCBhcmdjLCBjaGFyICoqYXJndikKK3sKKwlzdHJ1Y3Qg
c3RyaW5nX2xpc3QgKmZpbGVsaXN0ID0gTlVMTDsKKwljaGFyICpmaWxlOworCXN0cnVjdCBzeW1i
b2xfbGlzdCAqdmlld19zeW1zID0gTlVMTDsKKworCWd0a19pbml0KCZhcmdjLCZhcmd2KTsKKwll
eHBhbmRfc3ltYm9scyhzcGFyc2VfaW5pdGlhbGl6ZShhcmdjLCBhcmd2LCAmZmlsZWxpc3QpKTsK
KwlGT1JfRUFDSF9QVFJfTk9UQUcoZmlsZWxpc3QsIGZpbGUpIHsKKwkJc3RydWN0IHN5bWJvbF9s
aXN0ICpzeW1zID0gc3BhcnNlKGZpbGUpOworCQlleHBhbmRfc3ltYm9scyhzeW1zKTsKKwkJY29u
Y2F0X3N5bWJvbF9saXN0KHN5bXMsICZ2aWV3X3N5bXMpOworCX0gRU5EX0ZPUl9FQUNIX1BUUl9O
T1RBRyhmaWxlKTsKKwl0cmVldmlld19tYWluKHZpZXdfc3ltcyk7CisJcmV0dXJuIDA7Cit9Cisg
Ci0tIAoxLjYuNi4xCgo=
--000e0cd76280a32e950483455bce--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] parser: add Blackfin gcc info ===

From: Mike Frysinger <vapier () gentoo ! org>
To: linux-sparse
Subject: [PATCH v2] parser: add Blackfin gcc info
Date: Thu, 07 Oct 2010 00:09:48 +0000
Message-ID: <1286410188-6074-1-git-send-email-vapier () gentoo ! org>
--------------------
The Blackfin port uses some custom attributes to control memory placement,
and it has some custom builtins.  So add the ones that the kernel actually
utilizes to avoid massive build errors with sparse.

Signed-off-by: Mike Frysinger <vapier@gentoo.org>
---
v2
	- put Blackin builtins behind __bfin__

 lib.c   |    9 +++++++++
 parse.c |    6 ++++++
 2 files changed, 15 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index ae6a20c..e33d3a5 100644
--- a/lib.c
+++ b/lib.c
@@ -717,6 +717,15 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 	add_pre_buffer("extern long __builtin_labs(long);\n");
 
+	/* Add Blackfin-specific stuff */
+	add_pre_buffer(
+		"#ifdef __bfin__\n"
+		"extern void __builtin_bfin_csync(void);\n"
+		"extern void __builtin_bfin_ssync(void);\n"
+		"extern int __builtin_bfin_norm_fr1x32(int);\n"
+		"#endif\n"
+	);
+
 	/* And some floating point stuff.. */
 	add_pre_buffer("extern int __builtin_isgreater(float, float);\n");
 	add_pre_buffer("extern int __builtin_isgreaterequal(float, float);\n");
diff --git a/parse.c b/parse.c
index 9074b1d..32d2d0a 100644
--- a/parse.c
+++ b/parse.c
@@ -515,6 +515,12 @@ const char *ignored_attributes[] = {
 	"__format_arg__",
 	"hot",
 	"__hot__",
+	"l1_text",
+	"__l1_text__",
+	"l1_data",
+	"__l1_data__",
+	"l2",
+	"__l2__",
 	"malloc",
 	"__malloc__",
 	"may_alias",
-- 
1.7.3.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v2] parser: add Blackfin gcc info
Date: Thu, 07 Oct 2010 02:24:41 +0000
Message-ID: <AANLkTimC+9VeiZ6rszO6B7hg5tG+TzsQy-XjK5T0pKuz () mail ! gmail ! com>
--------------------
On Wed, Oct 6, 2010 at 5:09 PM, Mike Frysinger <vapier@gentoo.org> wrote:
> The Blackfin port uses some custom attributes to control memory placement,
> and it has some custom builtins.  So add the ones that the kernel actually
> utilizes to avoid massive build errors with sparse.


The change looks good. Will apply.

Thanks for the patch.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Ignore the may_alias GCC attribute ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Ignore the may_alias GCC attribute
Date: Tue, 01 Jun 2010 22:31:44 +0000
Message-ID: <AANLkTim4BaJ2JGBU1vUi-GguEZAdZY70Oo070J0hfHoq () mail ! gmail ! com>
--------------------
On Tue, Jun 1, 2010 at 9:35 AM, Damien Lespiau <damien.lespiau@gmail.com> wrote:
> Unfortunately, linux-sparse seems to reject my git send-emails with
> GMail's SMTP server, so I'm attaching the git format-patch instead.
>
> may_alias is used in the wild (glib) and makes sparse spew a lot of
> unhelpful warning messages. Ignore it (for now?).
>

The patch looks good. Will apply.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Make headers usable in Cxx code. ===

From: Tomas Klacko <tomas.klacko@gmail.com>
To: Unknown
Subject: [PATCH] Make headers usable in Cxx code.
Date: Tue, 12 Oct 2010 00:25:46 +0000
Message-ID: 
--------------------
---
 c2xml.c       |    6 +++---
 ctags.c       |    6 +++---
 expression.c  |   12 ++++++------
 expression.h  |    8 ++++++--
 graph.c       |    2 +-
 lib.h         |   34 ++++++++++++++++++++++++++++++++++
 linearize.h   |    4 ++--
 parse.c       |   22 +++++++++++-----------
 parse.h       |    2 ++
 pre-process.c |   10 +++++-----
 ptrlist.h     |   22 ++++++++++++++++++++--
 symbol.c      |   10 +++++-----
 symbol.h      |   14 +++++++-------
 token.h       |    8 ++++++++
 14 files changed, 113 insertions(+), 47 deletions(-)

diff --git a/c2xml.c b/c2xml.c
index 37f29cf..749c699 100644
--- a/c2xml.c
+++ b/c2xml.c
@@ -128,7 +128,7 @@ static void examine_modifiers(struct symbol *sym,
xmlNodePtr node)

 	int i;

-	if (sym->namespace != NS_SYMBOL)
+	if (sym->ns != NS_SYMBOL)
 		return;

 	/*iterate over the 32 bit bitfield*/
@@ -236,7 +236,7 @@ static void examine_namespace(struct symbol *sym)
 	if (sym->ident && sym->ident->reserved)
 		return;

-	switch(sym->namespace) {
+	switch(sym->ns) {
 	case NS_MACRO:
 		examine_macro(sym, root_node);
 		break;
@@ -253,7 +253,7 @@ static void examine_namespace(struct symbol *sym)
 	case NS_KEYWORD:
 		break;
 	default:
-		die("Unrecognised namespace type %d",sym->namespace);
+		die("Unrecognised namespace type %d",sym->ns);
 	}

 }
diff --git a/ctags.c b/ctags.c
index 7e129a6..7e09c95 100644
--- a/ctags.c
+++ b/ctags.c
@@ -145,7 +145,7 @@ static void examine_symbol(struct symbol *sym)

 	default:
 		die("unknown symbol %s namespace:%d type:%d\n", show_ident(sym->ident),
-		    sym->namespace, sym->type);
+		    sym->ns, sym->type);
 	}
 	if (!sym->kind)
 		sym->kind = 'v';
@@ -159,7 +159,7 @@ static void examine_namespace(struct symbol *sym)
 	if (sym->ident && sym->ident->reserved)
 		return;

-	switch(sym->namespace) {
+	switch(sym->ns) {
 	case NS_KEYWORD:
 	case NS_PREPROCESSOR:
 		return;
@@ -177,7 +177,7 @@ static void examine_namespace(struct symbol *sym)
 		examine_symbol(sym);
 		break;
 	default:
-		die("unknown namespace %d symbol:%s type:%d\n", sym->namespace,
+		die("unknown namespace %d symbol:%s type:%d\n", sym->ns,
 		    show_ident(sym->ident), sym->type);
 	}
 	add_tag(sym);
diff --git a/expression.c b/expression.c
index 7e06e60..e02f5b0 100644
--- a/expression.c
+++ b/expression.c
@@ -118,7 +118,7 @@ static struct token *parse_type(struct token
*token, struct expression **tree)
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
 	(*tree)->flags = Int_const_expr; /* sic */
-	token = typename(token, &sym, NULL);
+	token = type_name(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -167,7 +167,7 @@ static struct token *builtin_offsetof_expr(struct
token *token,
 		return expect(token, '(', "after __builtin_offset");

 	token = token->next;
-	token = typename(token, &sym, NULL);
+	token = type_name(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -455,7 +455,7 @@ struct token *primary_expression(struct token
*token, struct expression **tree)
 		 *
 		 *	if (typeof(a) == int) ..
 		 */
-		if (sym && sym->namespace == NS_TYPEDEF) {
+		if (sym && sym->ns == NS_TYPEDEF) {
 			sparse_error(token->pos, "typename in expression");
 			sym = NULL;
 		}
@@ -486,7 +486,7 @@ struct token *primary_expression(struct token
*token, struct expression **tree)
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
 			expr->flags = Int_const_expr; /* sic */
-			token = typename(token->next, &expr->symbol, NULL);
+			token = type_name(token->next, &expr->symbol, NULL);
 			token = expect(token, ']', "in type expression");
 			break;
 		}
@@ -606,7 +606,7 @@ static struct token *type_info_expression(struct
token *token,
 	if (!match_op(token, '(') || !lookup_type(token->next))
 		return unary_expression(token, &expr->cast_expression);
 	p = token;
-	token = typename(token->next, &expr->cast_type, NULL);
+	token = type_name(token->next, &expr->cast_type, NULL);

 	if (!match_op(token, ')')) {
 		static const char * error[] = {
@@ -731,7 +731,7 @@ static struct token *cast_expression(struct token
*token, struct expression **tr
 			struct symbol *sym;
 			int is_force;

-			token = typename(next, &sym, &is_force);
+			token = type_name(next, &sym, &is_force);
 			cast->cast_type = sym;
 			token = expect(token, ')', "at end of cast operator");
 			if (match_op(token, '{')) {
diff --git a/expression.h b/expression.h
index 9778de8..d85f16c 100644
--- a/expression.h
+++ b/expression.h
@@ -196,13 +196,17 @@ static inline struct expression
*alloc_const_expression(struct position pos, int
 }

 /* Type name parsing */
-struct token *typename(struct token *, struct symbol **, int *);
+struct token *type_name(struct token *, struct symbol **, int *);

 static inline int lookup_type(struct token *token)
 {
 	if (token->pos.type == TOKEN_IDENT) {
+#ifndef __cplusplus
 		struct symbol *sym = lookup_symbol(token->ident, NS_SYMBOL | NS_TYPEDEF);
-		return sym && (sym->namespace & NS_TYPEDEF);
+#else
+		struct symbol *sym = lookup_symbol(token->ident, (enum
name_space)(NS_SYMBOL | NS_TYPEDEF));
+#endif
+		return sym && (sym->ns & NS_TYPEDEF);
 	}
 	return 0;
 }
diff --git a/graph.c b/graph.c
index 1a77d75..7e0868f 100644
--- a/graph.c
+++ b/graph.c
@@ -124,7 +124,7 @@ static void graph_calls(struct entrypoint *ep, int internal)
 				if (insn->func->type == PSEUDO_SYM) {
 					for (sym = insn->func->sym->ident->symbols;
 					     sym; sym = sym->next_id) {
-						if (sym->namespace & NS_SYMBOL && sym->ep)
+						if (sym->ns & NS_SYMBOL && sym->ep)
 							break;
 					}

diff --git a/lib.h b/lib.h
index 2cea252..4acd61e 100644
--- a/lib.h
+++ b/lib.h
@@ -120,6 +120,10 @@ extern int Wdeclarationafterstatement;
 extern int dbg_entry;
 extern int dbg_dead;

+#ifdef __cplusplus
+extern "C" {
+#endif
+
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
 extern struct symbol_list *sparse_initialize(int argc, char **argv,
struct string_list **files);
@@ -127,6 +131,10 @@ extern struct symbol_list *__sparse(char *filename);
 extern struct symbol_list *sparse_keep_tokens(char *filename);
 extern struct symbol_list *sparse(char *filename);

+#ifdef __cplusplus
+}
+#endif
+
 static inline int symbol_list_size(struct symbol_list *list)
 {
 	return ptr_list_size((struct ptr_list *)(list));
@@ -164,31 +172,57 @@ static inline void free_instruction_list(struct
instruction_list **head)

 static inline struct instruction * delete_last_instruction(struct
instruction_list **head)
 {
+#ifndef __cplusplus
 	return undo_ptr_list_last((struct ptr_list **)head);
+#else
+	return (struct instruction *)undo_ptr_list_last((struct ptr_list **)head);
+#endif
 }

 static inline struct basic_block * delete_last_basic_block(struct
basic_block_list **head)
 {
+#ifndef __cplusplus
 	return delete_ptr_list_last((struct ptr_list **)head);
+#else
+	return (struct basic_block *)delete_ptr_list_last((struct ptr_list **)head);
+
+#endif
 }

 static inline struct basic_block *first_basic_block(struct
basic_block_list *head)
 {
+#ifndef __cplusplus
 	return first_ptr_list((struct ptr_list *)head);
+#else
+	return (struct basic_block *)first_ptr_list((struct ptr_list *)head);
+
+#endif
 }
 static inline struct instruction *last_instruction(struct
instruction_list *head)
 {
+#ifndef __cplusplus
 	return last_ptr_list((struct ptr_list *)head);
+#else
+	return (struct instruction *)last_ptr_list((struct ptr_list *)head);
+#endif
 }

 static inline struct instruction *first_instruction(struct
instruction_list *head)
 {
+#ifndef __cplusplus
 	return first_ptr_list((struct ptr_list *)head);
+#else
+	return (struct instruction *)first_ptr_list((struct ptr_list *)head);
+#endif
 }

 static inline pseudo_t first_pseudo(struct pseudo_list *head)
 {
+#ifndef __cplusplus
 	return first_ptr_list((struct ptr_list *)head);
+#else
+	return (pseudo_t)first_ptr_list((struct ptr_list *)head);
+#endif
 }

 static inline void concat_symbol_list(struct symbol_list *from,
struct symbol_list **to)
diff --git a/linearize.h b/linearize.h
index 50b3601..a385968 100644
--- a/linearize.h
+++ b/linearize.h
@@ -314,9 +314,9 @@ static inline void remove_bb_from_list(struct
basic_block_list **list, struct ba
 }

 static inline void replace_bb_in_list(struct basic_block_list **list,
-	struct basic_block *old, struct basic_block *new, int count)
+	struct basic_block *old, struct basic_block *new_list, int count)
 {
-	replace_ptr_list_entry((struct ptr_list **)list, old, new, count);
+	replace_ptr_list_entry((struct ptr_list **)list, old, new_list, count);
 }

 struct entrypoint {
diff --git a/parse.c b/parse.c
index 537055f..29d6e16 100644
--- a/parse.c
+++ b/parse.c
@@ -188,7 +188,7 @@ static struct symbol_op char_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_T|Set_Long|Set_Short,
 	.set = Set_T|Set_Char,
-	.class = CChar,
+	.cls = CChar,
 };

 static struct symbol_op int_op = {
@@ -201,14 +201,14 @@ static struct symbol_op double_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_T|Set_Signed|Set_Unsigned|Set_Short|Set_Vlong,
 	.set = Set_T|Set_Double,
-	.class = CReal,
+	.cls = CReal,
 };

 static struct symbol_op float_op = {
 	.type = KW_SPECIFIER | KW_SHORT,
 	.test = Set_T|Set_Signed|Set_Unsigned|Set_Short|Set_Long,
 	.set = Set_T|Set_Float,
-	.class = CReal,
+	.cls = CReal,
 };

 static struct symbol_op short_op = {
@@ -221,14 +221,14 @@ static struct symbol_op signed_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_S|Set_Float|Set_Double|Set_Signed|Set_Unsigned,
 	.set = Set_Signed,
-	.class = CSInt,
+	.cls = CSInt,
 };

 static struct symbol_op unsigned_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_S|Set_Float|Set_Double|Set_Signed|Set_Unsigned,
 	.set = Set_Unsigned,
-	.class = CUInt,
+	.cls = CUInt,
 };

 static struct symbol_op long_op = {
@@ -364,7 +364,7 @@ static struct symbol_op mode_word_op = {

 static struct init_keyword {
 	const char *name;
-	enum namespace ns;
+	enum name_space ns;
 	unsigned long modifiers;
 	struct symbol_op *op;
 	struct symbol *type;
@@ -979,7 +979,7 @@ static struct token *typeof_specifier(struct token
*token, struct decl_state *ct
 		return token;
 	}
 	if (lookup_type(token->next)) {
-		token = typename(token->next, &sym, NULL);
+		token = type_name(token->next, &sym, NULL);
 		ctx->ctype.base_type = sym->ctype.base_type;
 		apply_ctype(token->pos, &sym->ctype, &ctx->ctype);
 	} else {
@@ -1433,7 +1433,7 @@ static struct token
*declaration_specifiers(struct token *token, struct decl_sta
 	while (token_type(token) == TOKEN_IDENT) {
 		struct symbol *s = lookup_symbol(token->ident,
 						 NS_TYPEDEF | NS_SYMBOL);
-		if (!s || !(s->namespace & NS_TYPEDEF))
+		if (!s || !(s->ns & NS_TYPEDEF))
 			break;
 		if (s->type != SYM_KEYWORD) {
 			if (seen & Set_Any)
@@ -1452,7 +1452,7 @@ static struct token
*declaration_specifiers(struct token *token, struct decl_sta
 				break;
 			}
 			seen |= s->op->set;
-			class += s->op->class;
+			class += s->op->cls;
 			if (s->op->type & KW_SHORT) {
 				size = -1;
 			} else if (s->op->type & KW_LONG && size++) {
@@ -1831,7 +1831,7 @@ static struct token
*parameter_declaration(struct token *token, struct symbol *s
 	return token;
 }

-struct token *typename(struct token *token, struct symbol **p, int *forced)
+struct token *type_name(struct token *token, struct symbol **p, int *forced)
 {
 	struct decl_state ctx = {.prefer_abstract = 1};
 	int class;
@@ -2295,7 +2295,7 @@ static struct token *label_statement(struct token *token)
 		struct symbol *sym = alloc_symbol(token->pos, SYM_LABEL);
 		/* it's block-scope, but we want label namespace */
 		bind_symbol(sym, token->ident, NS_SYMBOL);
-		sym->namespace = NS_LABEL;
+		sym->ns = NS_LABEL;
 		fn_local_symbol(sym);
 		token = token->next;
 		if (!match_op(token, ','))
diff --git a/parse.h b/parse.h
index 6b21e23..f2193e7 100644
--- a/parse.h
+++ b/parse.h
@@ -35,10 +35,12 @@ struct statement {
 		struct /* declaration */ {
 			struct symbol_list *declaration;
 		};
+#ifndef __cplusplus
 		struct /* label_arg */ {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
+#endif
 		struct {
 			struct expression *expression;
 			struct expression *context;
diff --git a/pre-process.c b/pre-process.c
index 656acaa..b7371f3 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -109,7 +109,7 @@ static void replace_with_integer(struct token
*token, unsigned int val)
 static struct symbol *lookup_macro(struct ident *ident)
 {
 	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_UNDEF);
-	if (sym && sym->namespace != NS_MACRO)
+	if (sym && sym->ns != NS_MACRO)
 		sym = NULL;
 	return sym;
 }
@@ -1146,7 +1146,7 @@ static int do_handle_define(struct stream
*stream, struct token **line, struct t
 		if (attr < sym->attr)
 			goto out;

-		clean = (attr == sym->attr && sym->namespace == NS_MACRO);
+		clean = (attr == sym->attr && sym->ns == NS_MACRO);

 		if (token_list_different(sym->expansion, expansion) ||
 		    token_list_different(sym->arglist, arglist)) {
@@ -1173,7 +1173,7 @@ static int do_handle_define(struct stream
*stream, struct token **line, struct t
 		__free_token(token);	/* Free the "define" token, but not the rest
of the line */
 	}

-	sym->namespace = NS_MACRO;
+	sym->ns = NS_MACRO;
 	sym->used_in = NULL;
 	sym->attr = attr;
 out:
@@ -1209,7 +1209,7 @@ static int do_handle_undef(struct stream
*stream, struct token **line, struct to
 	if (sym) {
 		if (attr < sym->attr)
 			return 1;
-		if (attr == sym->attr && sym->namespace == NS_UNDEF)
+		if (attr == sym->attr && sym->ns == NS_UNDEF)
 			return 1;
 	} else if (attr <= SYM_ATTR_NORMAL)
 		return 1;
@@ -1219,7 +1219,7 @@ static int do_handle_undef(struct stream
*stream, struct token **line, struct to
 		bind_symbol(sym, left->ident, NS_MACRO);
 	}

-	sym->namespace = NS_UNDEF;
+	sym->ns = NS_UNDEF;
 	sym->used_in = NULL;
 	sym->attr = attr;

diff --git a/ptrlist.h b/ptrlist.h
index fbfc080..7da875e 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -14,10 +14,16 @@

 /* Silly type-safety check ;) */
 #define DECLARE_PTR_LIST(listname,type)	struct listname { type *list[1]; }
-#define CHECK_TYPE(head,ptr)		(void)(&(ptr) == &(head)->list[0])
 #define TYPEOF(head)			__typeof__(&(head)->list[0])
 #define VRFY_PTR_LIST(head)		(void)(sizeof((head)->list[0]))

+#ifndef __cplusplus
+#define CHECK_TYPE(head,ptr)		(void)(&(ptr) == &(head)->list[0])
+#else
+/* I don't know yet how to do this better in C++. */
+#define CHECK_TYPE(head,ptr) (void)((void*)&(ptr) == (void*)&(head)->list[0])
+#endif
+
 /*
  * The "unnecessary" statement expression is there to shut up a totally
  * bogus gcc warning about unused expressions, brought on by the fact
@@ -36,10 +42,14 @@ struct ptr_list {

 #define ptr_list_empty(x) ((x) == NULL)

+#ifdef __cplusplus
+extern "C" {
+#endif
+
 void * undo_ptr_list_last(struct ptr_list **head);
 void * delete_ptr_list_last(struct ptr_list **head);
 int delete_ptr_list_entry(struct ptr_list **, void *, int);
-int replace_ptr_list_entry(struct ptr_list **, void *old, void *new, int);
+int replace_ptr_list_entry(struct ptr_list **, void *old, void *new_list, int);
 extern void sort_list(struct ptr_list **, int (*)(const void *, const void *));

 extern void **__add_ptr_list(struct ptr_list **, void *, unsigned long);
@@ -48,6 +58,10 @@ extern void __free_ptr_list(struct ptr_list **);
 extern int ptr_list_size(struct ptr_list *);
 extern int linearize_ptr_list(struct ptr_list *, void **, int);

+#ifdef __cplusplus
+}
+#endif
+
 /*
  * Hey, who said that you can't do overloading in C?
  *
@@ -270,7 +284,11 @@ extern void pack_ptr_list(struct ptr_list **);

 static inline void update_tag(void *p, unsigned long tag)
 {
+#ifndef __cplusplus
 	unsigned long *ptr = p;
+#else
+	unsigned long *ptr = (unsigned long *)p;
+#endif
 	*ptr = tag | (~3UL & *ptr);
 }

diff --git a/symbol.c b/symbol.c
index 96dfbfa..a8cd999 100644
--- a/symbol.c
+++ b/symbol.c
@@ -39,12 +39,12 @@ void access_symbol(struct symbol *sym)
 	}
 }

-struct symbol *lookup_symbol(struct ident *ident, enum namespace ns)
+struct symbol *lookup_symbol(struct ident *ident, enum name_space ns)
 {
 	struct symbol *sym;

 	for (sym = ident->symbols; sym; sym = sym->next_id) {
-		if (sym->namespace & ns) {
+		if (sym->ns & ns) {
 			sym->used = 1;
 			return sym;
 		}
@@ -515,7 +515,7 @@ void check_declaration(struct symbol *sym)
 	struct symbol *next = sym;

 	while ((next = next->next_id) != NULL) {
-		if (next->namespace != sym->namespace)
+		if (next->ns != sym->ns)
 			continue;
 		if (sym->scope == next->scope) {
 			sym->same_symbol = next;
@@ -538,7 +538,7 @@ void check_declaration(struct symbol *sym)
 	}
 }

-void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
+void bind_symbol(struct symbol *sym, struct ident *ident, enum name_space ns)
 {
 	struct scope *scope;
 	if (sym->bound) {
@@ -549,7 +549,7 @@ void bind_symbol(struct symbol *sym, struct ident
*ident, enum namespace ns)
 		sparse_error(sym->pos, "Trying to use reserved word '%s' as
identifier", show_ident(ident));
 		return;
 	}
-	sym->namespace = ns;
+	sym->ns = ns;
 	sym->next_id = ident->symbols;
 	ident->symbols = sym;
 	if (sym->ident && sym->ident != ident)
diff --git a/symbol.h b/symbol.h
index e567305..fdb5d2e 100644
--- a/symbol.h
+++ b/symbol.h
@@ -24,7 +24,7 @@
  * token contains the information on where the symbol was
  * declared.
  */
-enum namespace {
+enum name_space {
 	NS_NONE = 0,
 	NS_MACRO = 1,
 	NS_TYPEDEF = 2,
@@ -109,7 +109,7 @@ struct symbol_op {
 	struct token *(*attribute)(struct token *token, struct symbol *attr,
struct decl_state *ctx);
 	struct symbol *(*to_mode)(struct symbol *);

-	int test, set, class;
+	int test, set, cls;
 };

 extern int expand_safe_p(struct expression *expr, int cost);
@@ -121,7 +121,7 @@ extern int expand_constant_p(struct expression
*expr, int cost);

 struct symbol {
 	enum type type:8;
-	enum namespace namespace:9;
+	enum name_space ns:9;
 	unsigned char used:1, attr:2, enum_member:1, bound:1;
 	struct position pos;		/* Where this symbol was declared */
 	struct position endpos;		/* Where this symbol ends*/
@@ -267,8 +267,8 @@ extern void access_symbol(struct symbol *);
 extern const char * type_difference(struct ctype *c1, struct ctype *c2,
 	unsigned long mod1, unsigned long mod2);

-extern struct symbol *lookup_symbol(struct ident *, enum namespace);
-extern struct symbol *create_symbol(int stream, const char *name, int
type, int namespace);
+extern struct symbol *lookup_symbol(struct ident *, enum name_space);
+extern struct symbol *create_symbol(int stream, const char *name, int
type, int name_space);
 extern void init_symbols(void);
 extern void init_ctype(void);
 extern struct symbol *alloc_symbol(struct position, int type);
@@ -279,7 +279,7 @@ extern int show_symbol_expr_init(struct symbol *sym);
 extern void show_type_list(struct symbol *);
 extern void show_symbol_list(struct symbol_list *, const char *);
 extern void add_symbol(struct symbol_list **, struct symbol *);
-extern void bind_symbol(struct symbol *, struct ident *, enum namespace);
+extern void bind_symbol(struct symbol *, struct ident *, enum name_space);

 extern struct symbol *examine_symbol_type(struct symbol *);
 extern struct symbol *examine_pointer_target(struct symbol *);
@@ -367,7 +367,7 @@ static inline int get_sym_type(struct symbol *type)
 	return type->type;
 }

-static inline struct symbol *lookup_keyword(struct ident *ident, enum
namespace ns)
+static inline struct symbol *lookup_keyword(struct ident *ident, enum
name_space ns)
 {
 	if (!ident->keyword)
 		return NULL;
diff --git a/token.h b/token.h
index a7ec77e..7d17296 100644
--- a/token.h
+++ b/token.h
@@ -175,7 +175,11 @@ struct token {
 static inline struct token *containing_token(struct token **p)
 {
 	void *addr = (char *)p - ((char *)&((struct token *)0)->next - (char *)0);
+#ifndef __cplusplus
 	return addr;
+#else
+	return (struct token*)addr;
+#endif
 }

 #define token_type(x) ((x)->pos.type)
@@ -205,7 +209,11 @@ extern struct token *preprocess(struct token *);

 static inline int match_op(struct token *token, int op)
 {
+#ifndef __cplusplus
 	return token->pos.type == TOKEN_SPECIAL && token->special == op;
+#else
+	return token->pos.type == TOKEN_SPECIAL && token->special == (unsigned int)op;
+#endif
 }

 static inline int match_ident(struct token *token, struct ident *id)
-- 
1.5.4.3


Tomas Klacko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tomas Klacko <tomas.klacko@gmail.com>
To: Unknown
Subject: [PATCH] Make headers usable in Cxx code.
Date: Sat, 16 Oct 2010 15:48:27 +0200
Message-ID: 
--------------------
---
 c2xml.c       |    6 +++---
 ctags.c       |    6 +++---
 expression.c  |   12 ++++++------
 expression.h  |    6 +++---
 graph.c       |    2 +-
 lib.h         |   13 +++++++------
 linearize.h   |    4 ++--
 parse.c       |   22 +++++++++++-----------
 parse.h       |    2 ++
 pre-process.c |   10 +++++-----
 ptrlist.h     |   12 +++++++++---
 symbol.c      |   10 +++++-----
 symbol.h      |   15 ++++++++-------
 token.h       |    4 ++--
 14 files changed, 67 insertions(+), 57 deletions(-)

diff --git a/c2xml.c b/c2xml.c
index 37f29cf..749c699 100644
--- a/c2xml.c
+++ b/c2xml.c
@@ -128,7 +128,7 @@ static void examine_modifiers(struct symbol *sym,
xmlNodePtr node)

 	int i;

-	if (sym->namespace != NS_SYMBOL)
+	if (sym->ns != NS_SYMBOL)
 		return;

 	/*iterate over the 32 bit bitfield*/
@@ -236,7 +236,7 @@ static void examine_namespace(struct symbol *sym)
 	if (sym->ident && sym->ident->reserved)
 		return;

-	switch(sym->namespace) {
+	switch(sym->ns) {
 	case NS_MACRO:
 		examine_macro(sym, root_node);
 		break;
@@ -253,7 +253,7 @@ static void examine_namespace(struct symbol *sym)
 	case NS_KEYWORD:
 		break;
 	default:
-		die("Unrecognised namespace type %d",sym->namespace);
+		die("Unrecognised namespace type %d",sym->ns);
 	}

 }
diff --git a/ctags.c b/ctags.c
index 7e129a6..7e09c95 100644
--- a/ctags.c
+++ b/ctags.c
@@ -145,7 +145,7 @@ static void examine_symbol(struct symbol *sym)

 	default:
 		die("unknown symbol %s namespace:%d type:%d\n", show_ident(sym->ident),
-		    sym->namespace, sym->type);
+		    sym->ns, sym->type);
 	}
 	if (!sym->kind)
 		sym->kind = 'v';
@@ -159,7 +159,7 @@ static void examine_namespace(struct symbol *sym)
 	if (sym->ident && sym->ident->reserved)
 		return;

-	switch(sym->namespace) {
+	switch(sym->ns) {
 	case NS_KEYWORD:
 	case NS_PREPROCESSOR:
 		return;
@@ -177,7 +177,7 @@ static void examine_namespace(struct symbol *sym)
 		examine_symbol(sym);
 		break;
 	default:
-		die("unknown namespace %d symbol:%s type:%d\n", sym->namespace,
+		die("unknown namespace %d symbol:%s type:%d\n", sym->ns,
 		    show_ident(sym->ident), sym->type);
 	}
 	add_tag(sym);
diff --git a/expression.c b/expression.c
index 7e06e60..e02f5b0 100644
--- a/expression.c
+++ b/expression.c
@@ -118,7 +118,7 @@ static struct token *parse_type(struct token
*token, struct expression **tree)
 	struct symbol *sym;
 	*tree = alloc_expression(token->pos, EXPR_TYPE);
 	(*tree)->flags = Int_const_expr; /* sic */
-	token = typename(token, &sym, NULL);
+	token = type_name(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -167,7 +167,7 @@ static struct token *builtin_offsetof_expr(struct
token *token,
 		return expect(token, '(', "after __builtin_offset");

 	token = token->next;
-	token = typename(token, &sym, NULL);
+	token = type_name(token, &sym, NULL);
 	if (sym->ident)
 		sparse_error(token->pos,
 			     "type expression should not include identifier "
@@ -455,7 +455,7 @@ struct token *primary_expression(struct token
*token, struct expression **tree)
 		 *
 		 *	if (typeof(a) == int) ..
 		 */
-		if (sym && sym->namespace == NS_TYPEDEF) {
+		if (sym && sym->ns == NS_TYPEDEF) {
 			sparse_error(token->pos, "typename in expression");
 			sym = NULL;
 		}
@@ -486,7 +486,7 @@ struct token *primary_expression(struct token
*token, struct expression **tree)
 		if (token->special == '[' && lookup_type(token->next)) {
 			expr = alloc_expression(token->pos, EXPR_TYPE);
 			expr->flags = Int_const_expr; /* sic */
-			token = typename(token->next, &expr->symbol, NULL);
+			token = type_name(token->next, &expr->symbol, NULL);
 			token = expect(token, ']', "in type expression");
 			break;
 		}
@@ -606,7 +606,7 @@ static struct token *type_info_expression(struct
token *token,
 	if (!match_op(token, '(') || !lookup_type(token->next))
 		return unary_expression(token, &expr->cast_expression);
 	p = token;
-	token = typename(token->next, &expr->cast_type, NULL);
+	token = type_name(token->next, &expr->cast_type, NULL);

 	if (!match_op(token, ')')) {
 		static const char * error[] = {
@@ -731,7 +731,7 @@ static struct token *cast_expression(struct token
*token, struct expression **tr
 			struct symbol *sym;
 			int is_force;

-			token = typename(next, &sym, &is_force);
+			token = type_name(next, &sym, &is_force);
 			cast->cast_type = sym;
 			token = expect(token, ')', "at end of cast operator");
 			if (match_op(token, '{')) {
diff --git a/expression.h b/expression.h
index 9778de8..698c778 100644
--- a/expression.h
+++ b/expression.h
@@ -196,13 +196,13 @@ static inline struct expression
*alloc_const_expression(struct position pos, int
 }

 /* Type name parsing */
-struct token *typename(struct token *, struct symbol **, int *);
+struct token *type_name(struct token *, struct symbol **, int *);

 static inline int lookup_type(struct token *token)
 {
 	if (token->pos.type == TOKEN_IDENT) {
-		struct symbol *sym = lookup_symbol(token->ident, NS_SYMBOL | NS_TYPEDEF);
-		return sym && (sym->namespace & NS_TYPEDEF);
+		struct symbol *sym = lookup_symbol(token->ident, NS_SYMBOL_OR_TYPEDEF);
+		return sym && (sym->ns & NS_TYPEDEF);
 	}
 	return 0;
 }
diff --git a/graph.c b/graph.c
index 1a77d75..7e0868f 100644
--- a/graph.c
+++ b/graph.c
@@ -124,7 +124,7 @@ static void graph_calls(struct entrypoint *ep, int internal)
 				if (insn->func->type == PSEUDO_SYM) {
 					for (sym = insn->func->sym->ident->symbols;
 					     sym; sym = sym->next_id) {
-						if (sym->namespace & NS_SYMBOL && sym->ep)
+						if (sym->ns & NS_SYMBOL && sym->ep)
 							break;
 					}

diff --git a/lib.h b/lib.h
index 2cea252..6d24fc8 100644
--- a/lib.h
+++ b/lib.h
@@ -164,31 +164,32 @@ static inline void free_instruction_list(struct
instruction_list **head)

 static inline struct instruction * delete_last_instruction(struct
instruction_list **head)
 {
-	return undo_ptr_list_last((struct ptr_list **)head);
+	return (struct instruction *)undo_ptr_list_last((struct ptr_list **)head);
 }

 static inline struct basic_block * delete_last_basic_block(struct
basic_block_list **head)
 {
-	return delete_ptr_list_last((struct ptr_list **)head);
+	return (struct basic_block *)delete_ptr_list_last((struct ptr_list **)head);
 }

 static inline struct basic_block *first_basic_block(struct
basic_block_list *head)
 {
-	return first_ptr_list((struct ptr_list *)head);
+	return (struct basic_block *)first_ptr_list((struct ptr_list *)head);
 }
+
 static inline struct instruction *last_instruction(struct
instruction_list *head)
 {
-	return last_ptr_list((struct ptr_list *)head);
+	return (struct instruction *)last_ptr_list((struct ptr_list *)head);
 }

 static inline struct instruction *first_instruction(struct
instruction_list *head)
 {
-	return first_ptr_list((struct ptr_list *)head);
+	return (struct instruction *)first_ptr_list((struct ptr_list *)head);
 }

 static inline pseudo_t first_pseudo(struct pseudo_list *head)
 {
-	return first_ptr_list((struct ptr_list *)head);
+	return (pseudo_t)first_ptr_list((struct ptr_list *)head);
 }

 static inline void concat_symbol_list(struct symbol_list *from,
struct symbol_list **to)
diff --git a/linearize.h b/linearize.h
index 50b3601..a6d629f 100644
--- a/linearize.h
+++ b/linearize.h
@@ -314,9 +314,9 @@ static inline void remove_bb_from_list(struct
basic_block_list **list, struct ba
 }

 static inline void replace_bb_in_list(struct basic_block_list **list,
-	struct basic_block *old, struct basic_block *new, int count)
+	struct basic_block *old, struct basic_block *newlist, int count)
 {
-	replace_ptr_list_entry((struct ptr_list **)list, old, new, count);
+	replace_ptr_list_entry((struct ptr_list **)list, old, newlist, count);
 }

 struct entrypoint {
diff --git a/parse.c b/parse.c
index 537055f..0f6fc4b 100644
--- a/parse.c
+++ b/parse.c
@@ -188,7 +188,7 @@ static struct symbol_op char_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_T|Set_Long|Set_Short,
 	.set = Set_T|Set_Char,
-	.class = CChar,
+	.klass = CChar,
 };

 static struct symbol_op int_op = {
@@ -201,14 +201,14 @@ static struct symbol_op double_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_T|Set_Signed|Set_Unsigned|Set_Short|Set_Vlong,
 	.set = Set_T|Set_Double,
-	.class = CReal,
+	.klass = CReal,
 };

 static struct symbol_op float_op = {
 	.type = KW_SPECIFIER | KW_SHORT,
 	.test = Set_T|Set_Signed|Set_Unsigned|Set_Short|Set_Long,
 	.set = Set_T|Set_Float,
-	.class = CReal,
+	.klass = CReal,
 };

 static struct symbol_op short_op = {
@@ -221,14 +221,14 @@ static struct symbol_op signed_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_S|Set_Float|Set_Double|Set_Signed|Set_Unsigned,
 	.set = Set_Signed,
-	.class = CSInt,
+	.klass = CSInt,
 };

 static struct symbol_op unsigned_op = {
 	.type = KW_SPECIFIER,
 	.test = Set_S|Set_Float|Set_Double|Set_Signed|Set_Unsigned,
 	.set = Set_Unsigned,
-	.class = CUInt,
+	.klass = CUInt,
 };

 static struct symbol_op long_op = {
@@ -364,7 +364,7 @@ static struct symbol_op mode_word_op = {

 static struct init_keyword {
 	const char *name;
-	enum namespace ns;
+	enum name_space ns;
 	unsigned long modifiers;
 	struct symbol_op *op;
 	struct symbol *type;
@@ -979,7 +979,7 @@ static struct token *typeof_specifier(struct token
*token, struct decl_state *ct
 		return token;
 	}
 	if (lookup_type(token->next)) {
-		token = typename(token->next, &sym, NULL);
+		token = type_name(token->next, &sym, NULL);
 		ctx->ctype.base_type = sym->ctype.base_type;
 		apply_ctype(token->pos, &sym->ctype, &ctx->ctype);
 	} else {
@@ -1433,7 +1433,7 @@ static struct token
*declaration_specifiers(struct token *token, struct decl_sta
 	while (token_type(token) == TOKEN_IDENT) {
 		struct symbol *s = lookup_symbol(token->ident,
 						 NS_TYPEDEF | NS_SYMBOL);
-		if (!s || !(s->namespace & NS_TYPEDEF))
+		if (!s || !(s->ns & NS_TYPEDEF))
 			break;
 		if (s->type != SYM_KEYWORD) {
 			if (seen & Set_Any)
@@ -1452,7 +1452,7 @@ static struct token
*declaration_specifiers(struct token *token, struct decl_sta
 				break;
 			}
 			seen |= s->op->set;
-			class += s->op->class;
+			class += s->op->klass;
 			if (s->op->type & KW_SHORT) {
 				size = -1;
 			} else if (s->op->type & KW_LONG && size++) {
@@ -1831,7 +1831,7 @@ static struct token
*parameter_declaration(struct token *token, struct symbol *s
 	return token;
 }

-struct token *typename(struct token *token, struct symbol **p, int *forced)
+struct token *type_name(struct token *token, struct symbol **p, int *forced)
 {
 	struct decl_state ctx = {.prefer_abstract = 1};
 	int class;
@@ -2295,7 +2295,7 @@ static struct token *label_statement(struct token *token)
 		struct symbol *sym = alloc_symbol(token->pos, SYM_LABEL);
 		/* it's block-scope, but we want label namespace */
 		bind_symbol(sym, token->ident, NS_SYMBOL);
-		sym->namespace = NS_LABEL;
+		sym->ns = NS_LABEL;
 		fn_local_symbol(sym);
 		token = token->next;
 		if (!match_op(token, ','))
diff --git a/parse.h b/parse.h
index 6b21e23..f2193e7 100644
--- a/parse.h
+++ b/parse.h
@@ -35,10 +35,12 @@ struct statement {
 		struct /* declaration */ {
 			struct symbol_list *declaration;
 		};
+#ifndef __cplusplus
 		struct /* label_arg */ {
 			struct symbol *label;
 			struct statement *label_statement;
 		};
+#endif
 		struct {
 			struct expression *expression;
 			struct expression *context;
diff --git a/pre-process.c b/pre-process.c
index 656acaa..b7371f3 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -109,7 +109,7 @@ static void replace_with_integer(struct token
*token, unsigned int val)
 static struct symbol *lookup_macro(struct ident *ident)
 {
 	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_UNDEF);
-	if (sym && sym->namespace != NS_MACRO)
+	if (sym && sym->ns != NS_MACRO)
 		sym = NULL;
 	return sym;
 }
@@ -1146,7 +1146,7 @@ static int do_handle_define(struct stream
*stream, struct token **line, struct t
 		if (attr < sym->attr)
 			goto out;

-		clean = (attr == sym->attr && sym->namespace == NS_MACRO);
+		clean = (attr == sym->attr && sym->ns == NS_MACRO);

 		if (token_list_different(sym->expansion, expansion) ||
 		    token_list_different(sym->arglist, arglist)) {
@@ -1173,7 +1173,7 @@ static int do_handle_define(struct stream
*stream, struct token **line, struct t
 		__free_token(token);	/* Free the "define" token, but not the rest
of the line */
 	}

-	sym->namespace = NS_MACRO;
+	sym->ns = NS_MACRO;
 	sym->used_in = NULL;
 	sym->attr = attr;
 out:
@@ -1209,7 +1209,7 @@ static int do_handle_undef(struct stream
*stream, struct token **line, struct to
 	if (sym) {
 		if (attr < sym->attr)
 			return 1;
-		if (attr == sym->attr && sym->namespace == NS_UNDEF)
+		if (attr == sym->attr && sym->ns == NS_UNDEF)
 			return 1;
 	} else if (attr <= SYM_ATTR_NORMAL)
 		return 1;
@@ -1219,7 +1219,7 @@ static int do_handle_undef(struct stream
*stream, struct token **line, struct to
 		bind_symbol(sym, left->ident, NS_MACRO);
 	}

-	sym->namespace = NS_UNDEF;
+	sym->ns = NS_UNDEF;
 	sym->used_in = NULL;
 	sym->attr = attr;

diff --git a/ptrlist.h b/ptrlist.h
index fbfc080..99e50da 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -14,10 +14,16 @@

 /* Silly type-safety check ;) */
 #define DECLARE_PTR_LIST(listname,type)	struct listname { type *list[1]; }
-#define CHECK_TYPE(head,ptr)		(void)(&(ptr) == &(head)->list[0])
 #define TYPEOF(head)			__typeof__(&(head)->list[0])
 #define VRFY_PTR_LIST(head)		(void)(sizeof((head)->list[0]))

+#ifndef __cplusplus
+#define CHECK_TYPE(head,ptr)		(void)(&(ptr) == &(head)->list[0])
+#else
+/* I don't know yet how to do this better in C++. */
+#define CHECK_TYPE(head,ptr)   (void)(1)
+#endif
+
 /*
  * The "unnecessary" statement expression is there to shut up a totally
  * bogus gcc warning about unused expressions, brought on by the fact
@@ -39,7 +45,7 @@ struct ptr_list {
 void * undo_ptr_list_last(struct ptr_list **head);
 void * delete_ptr_list_last(struct ptr_list **head);
 int delete_ptr_list_entry(struct ptr_list **, void *, int);
-int replace_ptr_list_entry(struct ptr_list **, void *old, void *new, int);
+int replace_ptr_list_entry(struct ptr_list **, void *old, void *newlist, int);
 extern void sort_list(struct ptr_list **, int (*)(const void *, const void *));

 extern void **__add_ptr_list(struct ptr_list **, void *, unsigned long);
@@ -270,7 +276,7 @@ extern void pack_ptr_list(struct ptr_list **);

 static inline void update_tag(void *p, unsigned long tag)
 {
-	unsigned long *ptr = p;
+	unsigned long *ptr = (unsigned long *)p;
 	*ptr = tag | (~3UL & *ptr);
 }

diff --git a/symbol.c b/symbol.c
index 96dfbfa..a8cd999 100644
--- a/symbol.c
+++ b/symbol.c
@@ -39,12 +39,12 @@ void access_symbol(struct symbol *sym)
 	}
 }

-struct symbol *lookup_symbol(struct ident *ident, enum namespace ns)
+struct symbol *lookup_symbol(struct ident *ident, enum name_space ns)
 {
 	struct symbol *sym;

 	for (sym = ident->symbols; sym; sym = sym->next_id) {
-		if (sym->namespace & ns) {
+		if (sym->ns & ns) {
 			sym->used = 1;
 			return sym;
 		}
@@ -515,7 +515,7 @@ void check_declaration(struct symbol *sym)
 	struct symbol *next = sym;

 	while ((next = next->next_id) != NULL) {
-		if (next->namespace != sym->namespace)
+		if (next->ns != sym->ns)
 			continue;
 		if (sym->scope == next->scope) {
 			sym->same_symbol = next;
@@ -538,7 +538,7 @@ void check_declaration(struct symbol *sym)
 	}
 }

-void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
+void bind_symbol(struct symbol *sym, struct ident *ident, enum name_space ns)
 {
 	struct scope *scope;
 	if (sym->bound) {
@@ -549,7 +549,7 @@ void bind_symbol(struct symbol *sym, struct ident
*ident, enum namespace ns)
 		sparse_error(sym->pos, "Trying to use reserved word '%s' as
identifier", show_ident(ident));
 		return;
 	}
-	sym->namespace = ns;
+	sym->ns = ns;
 	sym->next_id = ident->symbols;
 	ident->symbols = sym;
 	if (sym->ident && sym->ident != ident)
diff --git a/symbol.h b/symbol.h
index e567305..a483096 100644
--- a/symbol.h
+++ b/symbol.h
@@ -24,13 +24,14 @@
  * token contains the information on where the symbol was
  * declared.
  */
-enum namespace {
+enum name_space {
 	NS_NONE = 0,
 	NS_MACRO = 1,
 	NS_TYPEDEF = 2,
 	NS_STRUCT = 4,  // Also used for unions and enums.
 	NS_LABEL = 8,
 	NS_SYMBOL = 16,
+	NS_SYMBOL_OR_TYPEDEF = 18,
 	NS_ITERATOR = 32,
 	NS_PREPROCESSOR = 64,
 	NS_UNDEF = 128,
@@ -109,7 +110,7 @@ struct symbol_op {
 	struct token *(*attribute)(struct token *token, struct symbol *attr,
struct decl_state *ctx);
 	struct symbol *(*to_mode)(struct symbol *);

-	int test, set, class;
+	int test, set, klass;
 };

 extern int expand_safe_p(struct expression *expr, int cost);
@@ -121,7 +122,7 @@ extern int expand_constant_p(struct expression
*expr, int cost);

 struct symbol {
 	enum type type:8;
-	enum namespace namespace:9;
+	enum name_space ns:9;
 	unsigned char used:1, attr:2, enum_member:1, bound:1;
 	struct position pos;		/* Where this symbol was declared */
 	struct position endpos;		/* Where this symbol ends*/
@@ -267,8 +268,8 @@ extern void access_symbol(struct symbol *);
 extern const char * type_difference(struct ctype *c1, struct ctype *c2,
 	unsigned long mod1, unsigned long mod2);

-extern struct symbol *lookup_symbol(struct ident *, enum namespace);
-extern struct symbol *create_symbol(int stream, const char *name, int
type, int namespace);
+extern struct symbol *lookup_symbol(struct ident *, enum name_space);
+extern struct symbol *create_symbol(int stream, const char *name, int
type, int name_space);
 extern void init_symbols(void);
 extern void init_ctype(void);
 extern struct symbol *alloc_symbol(struct position, int type);
@@ -279,7 +280,7 @@ extern int show_symbol_expr_init(struct symbol *sym);
 extern void show_type_list(struct symbol *);
 extern void show_symbol_list(struct symbol_list *, const char *);
 extern void add_symbol(struct symbol_list **, struct symbol *);
-extern void bind_symbol(struct symbol *, struct ident *, enum namespace);
+extern void bind_symbol(struct symbol *, struct ident *, enum name_space);

 extern struct symbol *examine_symbol_type(struct symbol *);
 extern struct symbol *examine_pointer_target(struct symbol *);
@@ -367,7 +368,7 @@ static inline int get_sym_type(struct symbol *type)
 	return type->type;
 }

-static inline struct symbol *lookup_keyword(struct ident *ident, enum
namespace ns)
+static inline struct symbol *lookup_keyword(struct ident *ident, enum
name_space ns)
 {
 	if (!ident->keyword)
 		return NULL;
diff --git a/token.h b/token.h
index a7ec77e..fd854a0 100644
--- a/token.h
+++ b/token.h
@@ -175,7 +175,7 @@ struct token {
 static inline struct token *containing_token(struct token **p)
 {
 	void *addr = (char *)p - ((char *)&((struct token *)0)->next - (char *)0);
-	return addr;
+	return (struct token*)addr;
 }

 #define token_type(x) ((x)->pos.type)
@@ -205,7 +205,7 @@ extern struct token *preprocess(struct token *);

 static inline int match_op(struct token *token, int op)
 {
-	return token->pos.type == TOKEN_SPECIAL && token->special == op;
+	return token->pos.type == TOKEN_SPECIAL && token->special == (unsigned int)op;
 }

 static inline int match_ident(struct token *token, struct ident *id)
-- 
1.5.4.3


Also, I have notices this:

lib.h:static inline void add_symbol(struct symbol_list **list, struct
symbol *sym)
symbol.h:extern void add_symbol(struct symbol_list **, struct symbol *);

but I did not find add_symbol definition in *.c.
What's the purpose?

Tomas Klacko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] eliminate insane conversions from int to enum ===

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: [PATCH] eliminate insane conversions from int to enum
Date: Sat, 27 Mar 2010 09:53:46 +0000
Message-ID: <201003271053.47206.kdudka () redhat ! com>
--------------------
--Boundary-00=_rWdrLJTd/Cu0I5l
Content-Type: text/plain;
  charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline

On Saturday 27 of March 2010 10:29:50 Josh Triplett wrote:
> > Here is what sparse gives:
> > $ ./sparse enum.c
> > enum.c:1:10: warning: non-ANSI function declaration of function 'main'
> > enum.c:6:15: warning: conversion of
> > enum.c:6:15:     int to
> > enum.c:6:15:     int enum <noident>
> >
> >
> > Here is what g++ gives:
> > $ g++ enum.c
> > enum.c: In function =E2=80=98int main()=E2=80=99:
> > enum.c:6: error: invalid conversion from =E2=80=98int=E2=80=99 to =E2=
=80=98main()::<anonymous
> > enum>=E2=80=99
>
> Yup, both of these warnings seem correct.  Don't fix them by casting,
> fix them by declaring "val" with an appropriate integral type.

patch attached

Kamil

--Boundary-00=_rWdrLJTd/Cu0I5l
Content-Type: text/x-diff;
  charset="iso 8859-15";
  name="0001-eliminate-insane-conversions-from-int-to-enum.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="0001-eliminate-insane-conversions-from-int-to-enum.patch"

=46rom 44d964b9479affff31ad5690bedfe580ee3b50fa Mon Sep 17 00:00:00 2001
=46rom: Kamil Dudka <kdudka@redhat.com>
Date: Sat, 27 Mar 2010 10:48:34 +0100
Subject: [PATCH] eliminate insane conversions from int to enum


Signed-off-by: Kamil Dudka <kdudka@redhat.com>
=2D--
 expression.h |    1 -
 parse.c      |    2 +-
 parse.h      |    2 ++
 symbol.c     |    4 ++--
 symbol.h     |    8 ++++----
 5 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/expression.h b/expression.h
index 81f70ad..fe08a5f 100644
=2D-- a/expression.h
+++ b/expression.h
@@ -206,7 +206,6 @@ static inline int lookup_type(struct token *token)
 }
=20
 /* Statement parsing */
=2Dstruct statement *alloc_statement(struct position pos, int type);
 struct token *initializer(struct expression **tree, struct token *token);
 struct token *compound_statement(struct token *, struct statement *);
=20
diff --git a/parse.c b/parse.c
index 7c6dce7..adaa132 100644
=2D-- a/parse.c
+++ b/parse.c
@@ -613,7 +613,7 @@ static int SENTINEL_ATTR match_idents(struct token *tok=
en, ...)
 }
=20
=20
=2Dstruct statement *alloc_statement(struct position pos, int type)
+struct statement *alloc_statement(struct position pos, enum statement_type=
 type)
 {
 	struct statement *stmt =3D __alloc_statement(0);
 	stmt->type =3D type;
diff --git a/parse.h b/parse.h
index 02b8585..6d51726 100644
=2D-- a/parse.h
+++ b/parse.h
@@ -115,6 +115,8 @@ struct statement {
 	};
 };
=20
+struct statement *alloc_statement(struct position pos, enum statement_type=
 type);
+
 extern struct symbol_list *function_computed_target_list;
 extern struct statement_list *function_computed_goto_list;
=20
diff --git a/symbol.c b/symbol.c
index 96dfbfa..8c46e20 100644
=2D-- a/symbol.c
+++ b/symbol.c
@@ -39,12 +39,12 @@ void access_symbol(struct symbol *sym)
 	}
 }
=20
=2Dstruct symbol *lookup_symbol(struct ident *ident, enum namespace ns)
+struct symbol *lookup_symbol(struct ident *ident, int ns_mask)
 {
 	struct symbol *sym;
=20
 	for (sym =3D ident->symbols; sym; sym =3D sym->next_id) {
=2D		if (sym->namespace & ns) {
+		if (sym->namespace & ns_mask) {
 			sym->used =3D 1;
 			return sym;
 		}
diff --git a/symbol.h b/symbol.h
index e567305..7921aa1 100644
=2D-- a/symbol.h
+++ b/symbol.h
@@ -97,7 +97,7 @@ struct decl_state {
 };
=20
 struct symbol_op {
=2D	enum keyword type;
+	int type;
 	int (*evaluate)(struct expression *);
 	int (*expand)(struct expression *, int);
 	int (*args)(struct expression *);
@@ -267,7 +267,7 @@ extern void access_symbol(struct symbol *);
 extern const char * type_difference(struct ctype *c1, struct ctype *c2,
 	unsigned long mod1, unsigned long mod2);
=20
=2Dextern struct symbol *lookup_symbol(struct ident *, enum namespace);
+extern struct symbol *lookup_symbol(struct ident *, int ns_mask);
 extern struct symbol *create_symbol(int stream, const char *name, int type=
, int namespace);
 extern void init_symbols(void);
 extern void init_ctype(void);
@@ -367,11 +367,11 @@ static inline int get_sym_type(struct symbol *type)
 	return type->type;
 }
=20
=2Dstatic inline struct symbol *lookup_keyword(struct ident *ident, enum na=
mespace ns)
+static inline struct symbol *lookup_keyword(struct ident *ident, int ns_ma=
sk)
 {
 	if (!ident->keyword)
 		return NULL;
=2D	return lookup_symbol(ident, ns);
+	return lookup_symbol(ident, ns_mask);
 }
=20
 #define is_restricted_type(type) (get_sym_type(type) =3D=3D SYM_RESTRICT)
=2D-=20
1.7.0.2


--Boundary-00=_rWdrLJTd/Cu0I5l--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] memops.c: always true expression ===

From: Nicolas Kaiser <nikai () nikai ! net>
To: linux-sparse
Subject: [PATCH] memops.c: always true expression
Date: Sun, 21 Nov 2010 20:25:48 +0000
Message-ID: <20101121212548.6230da08 () absol ! kitzblitz>
--------------------
I noticed that the second part of this conditional is always true.
Just a shot in the dark: Could that be a typo?

Signed-off-by: Nicolas Kaiser <nikai@nikai.net>
---
 memops.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/memops.c b/memops.c
index 9eafb72..45bd340 100644
--- a/memops.c
+++ b/memops.c
@@ -69,7 +69,7 @@ static int address_taken(pseudo_t pseudo)
 	struct pseudo_user *pu;
 	FOR_EACH_PTR(pseudo->users, pu) {
 		struct instruction *insn = pu->insn;
-		if (insn->bb && (insn->opcode != OP_LOAD || insn->opcode != OP_STORE))
+		if (insn->bb && (insn->opcode != OP_LOAD && insn->opcode != OP_STORE))
 			return 1;
 	} END_FOR_EACH_PTR(pu);
 	return 0;
-- 
1.7.2.2
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] memops.c: always true expression
Date: Tue, 23 Nov 2010 10:10:22 +0000
Message-ID: <AANLkTi=3FoqcPvaub=TuF5c5G9B1LpTuabRqWiw8nmhd () mail ! gmail ! com>
--------------------
On Sun, Nov 21, 2010 at 12:25 PM, Nicolas Kaiser <nikai@nikai.net> wrote:
> I noticed that the second part of this conditional is always true.
> Just a shot in the dark: Could that be a typo?
> -               if (insn->bb && (insn->opcode != OP_LOAD || insn->opcode != OP_STORE))
> +               if (insn->bb && (insn->opcode != OP_LOAD && insn->opcode != OP_STORE))

I think you are right. The insn->opcode can't be both OP_LOAD and OP_STORE.

The fix seems right to me. That is a good catch.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Anderson Lizardo <anderson.lizardo () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] memops.c: always true expression
Date: Tue, 23 Nov 2010 14:50:33 +0000
Message-ID: <AANLkTikvAHyp6oDWStQQmCGD7zA2qFumeHbV-FQ_BqrW () mail ! gmail ! com>
--------------------
On Tue, Nov 23, 2010 at 6:10 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Sun, Nov 21, 2010 at 12:25 PM, Nicolas Kaiser <nikai@nikai.net> wrote:
>> I noticed that the second part of this conditional is always true.
>> Just a shot in the dark: Could that be a typo?
>> -               if (insn->bb && (insn->opcode != OP_LOAD || insn->opcode != OP_STORE))
>> +               if (insn->bb && (insn->opcode != OP_LOAD && insn->opcode != OP_STORE))
>
> I think you are right. The insn->opcode can't be both OP_LOAD and OP_STORE.
>
> The fix seems right to me. That is a good catch.

I wonder if running sparse on it could catch this...

Regards,
-- 
Anderson Lizardo
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] parser: add Blackfin gcc info ===

From: Mike Frysinger <vapier () gentoo ! org>
To: linux-sparse
Subject: [PATCH] parser: add Blackfin gcc info
Date: Tue, 05 Oct 2010 08:34:30 +0000
Message-ID: <1286267670-20974-1-git-send-email-vapier () gentoo ! org>
--------------------
The Blackfin port uses some custom attributes to control memory placement,
and it has some custom builtins.  So add the ones that the kernel actually
utilizes to avoid massive build errors with sparse.

Signed-off-by: Mike Frysinger <vapier@gentoo.org>
---
 lib.c   |    3 +++
 parse.c |    6 ++++++
 2 files changed, 9 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index ae6a20c..24176d8 100644
--- a/lib.c
+++ b/lib.c
@@ -716,6 +716,9 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long __builtin_alpha_inslh(long, long);\n");
 	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 	add_pre_buffer("extern long __builtin_labs(long);\n");
+	add_pre_buffer("extern void __builtin_bfin_csync(void);\n");
+	add_pre_buffer("extern void __builtin_bfin_ssync(void);\n");
+	add_pre_buffer("extern int __builtin_bfin_norm_fr1x32(int);\n");
 
 	/* And some floating point stuff.. */
 	add_pre_buffer("extern int __builtin_isgreater(float, float);\n");
diff --git a/parse.c b/parse.c
index 9074b1d..32d2d0a 100644
--- a/parse.c
+++ b/parse.c
@@ -515,6 +515,12 @@ const char *ignored_attributes[] = {
 	"__format_arg__",
 	"hot",
 	"__hot__",
+	"l1_text",
+	"__l1_text__",
+	"l1_data",
+	"__l1_data__",
+	"l2",
+	"__l2__",
 	"malloc",
 	"__malloc__",
 	"may_alias",
-- 
1.7.3.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] parser: add Blackfin gcc info
Date: Tue, 05 Oct 2010 16:18:30 +0000
Message-ID: <20101005161829.GB1859 () feather>
--------------------
On Tue, Oct 05, 2010 at 04:34:30AM -0400, Mike Frysinger wrote:
> The Blackfin port uses some custom attributes to control memory placement,
> and it has some custom builtins.  So add the ones that the kernel actually
> utilizes to avoid massive build errors with sparse.
> 
> Signed-off-by: Mike Frysinger <vapier@gentoo.org>

I wonder, does it make sense to support these kinds of
architecture-specific builtins on all architectures, rather than
limiting them based on some specified target architecture?

Since Sparse doesn't generate code, it can easily target all
architectures simultaneously, but that doesn't mean we couldn't tell it
what architecture to target.  Sparse could default to targeting the
host architecture, which would avoid the need to pass extra flags in the
common case.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] parser: add Blackfin gcc info
Date: Wed, 06 Oct 2010 02:33:21 +0000
Message-ID: <AANLkTi=_MVVqr_hBx9GbhB5pmJWznakp8bmUXggfZAOi () mail ! gmail ! com>
--------------------
On Tue, Oct 5, 2010 at 6:34 PM, Mike Frysinger <vapier@gentoo.org> wrote:
>> I wonder, does it make sense to support these kinds of
>> architecture-specific builtins on all architectures, rather than
>> limiting them based on some specified target architecture?
>>
>> Since Sparse doesn't generate code, it can easily target all
>> architectures simultaneously, but that doesn't mean we couldn't tell it
>> what architecture to target.  Sparse could default to targeting the
>> host architecture, which would avoid the need to pass extra flags in the
>> common case.
>
> it does sound like it'd be useful to add an arch command line option.  but i
> hoped we could sneak in the Blackfin stuff first since other arches (like
> alpha) have been whitelisted.

Can we have some "ifdef" for the blackfin architecture in the pre buffer?
I agree with Josh, that do look like very much blackfin specific. We can leave
the ignore attribute alone for now.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Mike Frysinger <vapier () gentoo ! org>
To: linux-sparse
Subject: Re: [PATCH] parser: add Blackfin gcc info
Date: Wed, 06 Oct 2010 05:38:02 +0000
Message-ID: <201010060138.04508.vapier () gentoo ! org>
--------------------
--nextPart1673841.SLxWo6Zo0n
Content-Type: Text/Plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

On Tuesday, October 05, 2010 22:33:21 Christopher Li wrote:
> On Tue, Oct 5, 2010 at 6:34 PM, Mike Frysinger wrote:
> >> I wonder, does it make sense to support these kinds of
> >> architecture-specific builtins on all architectures, rather than
> >> limiting them based on some specified target architecture?
> >>=20
> >> Since Sparse doesn't generate code, it can easily target all
> >> architectures simultaneously, but that doesn't mean we couldn't tell it
> >> what architecture to target.  Sparse could default to targeting the
> >> host architecture, which would avoid the need to pass extra flags in t=
he
> >> common case.
> >=20
> > it does sound like it'd be useful to add an arch command line option.
> >  but i hoped we could sneak in the Blackfin stuff first since other
> > arches (like alpha) have been whitelisted.
>=20
> Can we have some "ifdef" for the blackfin architecture in the pre buffer?
> I agree with Josh, that do look like very much blackfin specific. We can
> leave the ignore attribute alone for now.

how would #ifdefs help ?  i'm not building sparse for a Blackfin arch, host=
 or=20
target wise.  if there's something more, you'd have to be specific as to wh=
at=20
you mean, otherwise i wont be able to send an updated patch.

yes, these things are completely Blackfin specific, but i dont see how that=
's=20
a barrier for entry when both attributes and the builtin ignore lists conta=
in=20
completely architecture specific stuff without any #ifdef logic.  using spa=
rse=20
on the Linux kernel for the Blackfin port is pretty useless atm because of=
=20
these missing pieces.
=2Dmike

--nextPart1673841.SLxWo6Zo0n
Content-Type: application/pgp-signature; name=signature.asc 
Content-Description: This is a digitally signed message part.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.16 (GNU/Linux)

iQIcBAABAgAGBQJMrAs8AAoJEEFjO5/oN/WBNPwP/j4mMoKlG+Ri5R5pBO/iUEog
t1TmKfRycFbPzLlH5hncn4zCd27oeOAriYiiN4Qr/ZDvlpHCGz18mdYyWifO0xfF
HdtIdTKIe89zQD5nLWgVZfmG8tocpOx8kJezSUeH9KUEfQ0lL4hSrLjkl5faR3v3
qP+XmKG3qZHD1ETK1kD8DAHFNJzu1txgiLUlqc+Y809aK5BgjLaWOaUXQJKk7Nox
Asg+O5r855fqLZsKjr/b4yGa/zSqTvQ1EDqqqjZg13HP+/OZXWenCHigrpNd9y2p
DLWXRMnge+9CMBiipZWnWJqw/pPWOO+GUTbDX2jRNbcvcihOz/vADXdI+KYneS/C
QJLEZsdSjqr8oFQOHgTPBDB06GNQOEL7p5Bv5pYXKJxry4s3pzZquDHImazSZvwF
OtgAAd0VpJiB3l7Q1sxYQkhxpqqxhWJNaMkn+bdtPXbbtfjcOcW23RqLa/2fgIpD
6pn5gQE2S2FwtYeAZKtcnqTPY2R6iFY5erqlkdYBkb0h3smuoE8yRlxDqm1giEpN
PUCC54kGaPl9+YdU2bJB6PBe5Fv6tz62Hy0Rl8b7xNrlC5pma2HpKKDYImBUEWv2
pV0MgnpVhIO+RDJdWZZULXsAFNVzOSqeynW2/xOoZN8OJ9W/+laioWXp49ke6ktf
HoF4mVs/CyNDeIKh6NJv
=oK0g
-----END PGP SIGNATURE-----

--nextPart1673841.SLxWo6Zo0n--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] parser: add Blackfin gcc info
Date: Wed, 06 Oct 2010 07:05:10 +0000
Message-ID: <20101006070509.GA2320 () feather>
--------------------
On Tue, Oct 05, 2010 at 09:34:41PM -0400, Mike Frysinger wrote:
> On Tuesday, October 05, 2010 12:18:30 Josh Triplett wrote:
> > On Tue, Oct 05, 2010 at 04:34:30AM -0400, Mike Frysinger wrote:
> > > The Blackfin port uses some custom attributes to control memory
> > > placement, and it has some custom builtins.  So add the ones that the
> > > kernel actually utilizes to avoid massive build errors with sparse.
> > 
> > I wonder, does it make sense to support these kinds of
> > architecture-specific builtins on all architectures, rather than
> > limiting them based on some specified target architecture?
> > 
> > Since Sparse doesn't generate code, it can easily target all
> > architectures simultaneously, but that doesn't mean we couldn't tell it
> > what architecture to target.  Sparse could default to targeting the
> > host architecture, which would avoid the need to pass extra flags in the
> > common case.
> 
> it does sound like it'd be useful to add an arch command line option.  but i 
> hoped we could sneak in the Blackfin stuff first since other arches (like 
> alpha) have been whitelisted.

Absolutely.  I took the opportunity to raise the general problem, but
that doesn't mean that Blackfin should have to wait for the general
solution. :)

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] parser: add Blackfin gcc info
Date: Wed, 06 Oct 2010 08:40:09 +0000
Message-ID: <AANLkTim=hG4BQ2fxy-_LKR1z-NZOqJYffaOJw+0yJvYK () mail ! gmail ! com>
--------------------
On Wed, Oct 6, 2010 at 12:10 AM, Josh Triplett <josh@joshtriplett.org> wrote:
>> > Can we have some "ifdef" for the blackfin architecture in the pre buffer?
>> > I agree with Josh, that do look like very much blackfin specific. We can
>> > leave the ignore attribute alone for now.
>>
>> how would #ifdefs help ?  i'm not building sparse for a Blackfin arch, host or
>> target wise.  if there's something more, you'd have to be specific as to what
>> you mean, otherwise i wont be able to send an updated patch.
>
> I suspect that Chris meant that you could add_pre_buffer an #ifdef and
> #endif surrounding the #define, so that the #define would only take
> effect if Sparse (or the command-line options passed by cgcc or Linux)
> defined some appropriate architecture-specific symbol for Blackfin.

Thanks for the clarification. The pre buffer is just a build in piece of the
header file. You can still use #ifdef inside the pre buffer. I just don't want
 those blackfin specific declare show up in every other platform

>> yes, these things are completely Blackfin specific, but i dont see how that's
>> a barrier for entry when both attributes and the builtin ignore lists contain
>> completely architecture specific stuff without any #ifdef logic.  using sparse
>> on the Linux kernel for the Blackfin port is pretty useless atm because of
>> these missing pieces.

No, I don't mean that is a deal breaker. That is some thing nice to have.
Do you know any typical architecture defined symbol to identify the blackfin
port? Some thing similar to __x86_64__. How does gcc know it is compiling
for a Blackfin port?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Mike Frysinger <vapier () gentoo ! org>
To: linux-sparse
Subject: Re: [PATCH] parser: add Blackfin gcc info
Date: Wed, 06 Oct 2010 14:52:49 +0000
Message-ID: <201010061052.50958.vapier () gentoo ! org>
--------------------
--nextPart1379503.nFIMnxHk52
Content-Type: Text/Plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

On Wednesday, October 06, 2010 04:40:09 Christopher Li wrote:
> On Wed, Oct 6, 2010 at 12:10 AM, Josh Triplett wrote:
> >> > Can we have some "ifdef" for the blackfin architecture in the pre
> >> > buffer? I agree with Josh, that do look like very much blackfin
> >> > specific. We can leave the ignore attribute alone for now.
> >>=20
> >> how would #ifdefs help ?  i'm not building sparse for a Blackfin arch,
> >> host or target wise.  if there's something more, you'd have to be
> >> specific as to what you mean, otherwise i wont be able to send an
> >> updated patch.
> >=20
> > I suspect that Chris meant that you could add_pre_buffer an #ifdef and
> > #endif surrounding the #define, so that the #define would only take
> > effect if Sparse (or the command-line options passed by cgcc or Linux)
> > defined some appropriate architecture-specific symbol for Blackfin.
>=20
> Thanks for the clarification. The pre buffer is just a build in piece of
> the header file. You can still use #ifdef inside the pre buffer. I just
> don't want those blackfin specific declare show up in every other platform
>=20
> >> yes, these things are completely Blackfin specific, but i dont see how
> >> that's a barrier for entry when both attributes and the builtin ignore
> >> lists contain completely architecture specific stuff without any #ifdef
> >> logic.  using sparse on the Linux kernel for the Blackfin port is
> >> pretty useless atm because of these missing pieces.
>=20
> No, I don't mean that is a deal breaker. That is some thing nice to have.
> Do you know any typical architecture defined symbol to identify the
> blackfin port? Some thing similar to __x86_64__. How does gcc know it is
> compiling for a Blackfin port?

Blackfin's gcc always outputs __bfin__.  i'll send an updated patch once i=
=20
test it out.
=2Dmike

--nextPart1379503.nFIMnxHk52
Content-Type: application/pgp-signature; name=signature.asc 
Content-Description: This is a digitally signed message part.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.16 (GNU/Linux)

iQIcBAABAgAGBQJMrI1CAAoJEEFjO5/oN/WB6FIP/i704ccdy4HvQh1rDmEZiLjl
RYy5nObrZyPYAZ2g+7v8w3V3xudYhIbf3MFEGcYbTkpgQyld56sy4gF0Sq7+6PUh
4k3lS89zE/rEB8qrZaEFz0/NzTt0qMIBmNp7IdGbaWq9KSAoQbduXghMveAUj7+U
8ufw+Vqj9b76SQnxWhDzThkvR1WUNB1KHQLzZiKPtxwu6RV6DikLW2R6Ks6VFmRL
cUK0WAN+wG5Y8Cx3RhPG+iUPX289SroJ3pEETAMPST4sO+Hz86SOCeKIXDKLKvCk
VrE6pf4uH21szGKCHG6uEbF0BZqA0iryECJRpLZvg4mH7yyhujT6P2LSIBdl0bO5
d5dYoBfHcOkuWQT+CaKi27447g+KUrZlCky1IPTp4H4yXsGg2eUOySZDgRQImhBI
f3VK2WbkWnAKb+pqdfdcVYUQRmzZyDx0fOwaSXCCWbEbAKhmK2NSPtW2Kof27QbS
FShhTGU3Z+relOjfaHr2qiCH1g+10x+zqvL2CBWoGgvO4SpwsbnKNZZxeJ44L0f8
jjS6cS5fPTdA6NlieDIHIux4vItlGKJlDtZWl3KUjdKh36meLQTa2r5oi4yYpEoM
ZhVJNb9A01uZQSwDXsTLlJ7bPaFk6IdwPdHumczsCKhDdZHYhHiy1Hw/CsCRZ0Ld
55KUHhslfnWr/z1LEhJL
=eD1O
-----END PGP SIGNATURE-----

--nextPart1379503.nFIMnxHk52--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] trivial: disable sparse' warning for "potentially ===

From: Bernd Petrovitsch <bernd () sysprog ! at>
To: linux-sparse
Subject: Re: [PATCH] trivial: disable sparse' warning for "potentially
Date: Thu, 23 Sep 2010 12:41:43 +0000
Message-ID: <1285245703.32001.19.camel () thorin>
--------------------
Also Cc:ed linux-sparse@vger.kernel.org

On Don, 2010-09-23 at 13:23 +0200, Jiri Kosina wrote:
> On Fri, 20 Aug 2010, Bernd Petrovitsch wrote:
> 
> > Rationale: With a somewhat current gcc (or a somewhat sane peephole
> > optimizer), the (expensive) "div" is converted to a "shift" or
> > "mul" with the inverse.
> > This warning is disabled per default in sparse but the "-Wall" in
> > the kernels CFLAGS enables it.
> > 
> > Signed-off-by: Bernd Petrovitsch <bernd@sysprog.at>
> > ---
> > This patch is trivial and affects only calls to sparse (read: make C=1) and
> > removes false warnings. So it should be considered for inclusion immediately.
> > 
> > Sorry for the long Cc: - I included everyone in the thread and added
> > linux-kbuild@ (as it IMHO belongs there) and trivial@ (because of the
> > complexity of the patch).
> > 
> >  Makefile |    2 +-
> >  1 files changed, 1 insertions(+), 1 deletions(-)
> > 
> > diff --git a/Makefile b/Makefile
> > index f3bdff8..851c0fa 100644
> > --- a/Makefile
> > +++ b/Makefile
> > @@ -330,7 +330,7 @@ PERL		= perl
> >  CHECK		= sparse
> >  
> >  CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
> > -		  -Wbitwise -Wno-return-void $(CF)
> > +		  -Wbitwise -Wno-return-void -Wno-ptr-subtraction-blows $(CF)
> >  CFLAGS_MODULE   =
> >  AFLAGS_MODULE   =
> >  LDFLAGS_MODULE  =
> 
> What is the status of this patch? I don't see it Nacked, but it's not in 
> linux-next either.

More details:

The head (as in
git://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git) has "-Wall"
renamed to "-Wsparse-all". So the above patch is pretty pointless.

But sparse-0.4.2 - the latest release according to
https://sparse.wiki.kernel.org/index.php/Main_Page - hasn't that
renamed.

	Bernd
-- 
mobile: +43 664 4416156              http://www.sysprog.at/
    Linux Software Development, Consulting and Services

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] use ARRAY_SIZE() when possible ===

From: Namhyung Kim <namhyung () gmail ! com>
To: linux-sparse
Subject: [PATCH] use ARRAY_SIZE() when possible
Date: Thu, 09 Dec 2010 11:27:00 +0000
Message-ID: <1291894020-3388-1-git-send-email-namhyung () gmail ! com>
--------------------
Convert (sizeof arr / sizeof arr[0]) to ARRAY_SIZE(arr).

Signed-off-by: Namhyung Kim <namhyung@gmail.com>
---
 lib.c         |    8 ++++----
 pre-process.c |    4 ++--
 show-parse.c  |    4 ++--
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/lib.c b/lib.c
index c4a6f87..1d96129 100644
--- a/lib.c
+++ b/lib.c
@@ -437,7 +437,7 @@ static char **handle_onoff_switch(char *arg, char **next, const struct warning w
 
 static char **handle_switch_W(char *arg, char **next)
 {
-	char ** ret = handle_onoff_switch(arg, next, warnings, sizeof warnings/sizeof warnings[0]);
+	char ** ret = handle_onoff_switch(arg, next, warnings, ARRAY_SIZE(warnings));
 	if (ret)
 		return ret;
 
@@ -453,7 +453,7 @@ static struct warning debugs[] = {
 
 static char **handle_switch_v(char *arg, char **next)
 {
-	char ** ret = handle_onoff_switch(arg, next, debugs, sizeof debugs/sizeof debugs[0]);
+	char ** ret = handle_onoff_switch(arg, next, debugs, ARRAY_SIZE(debugs));
 	if (ret)
 		return ret;
 
@@ -477,7 +477,7 @@ static void handle_onoff_switch_finalize(const struct warning warnings[], int n)
 
 static void handle_switch_W_finalize(void)
 {
-	handle_onoff_switch_finalize(warnings, sizeof(warnings) / sizeof(warnings[0]));
+	handle_onoff_switch_finalize(warnings, ARRAY_SIZE(warnings));
 
 	/* default Wdeclarationafterstatement based on the C dialect */
 	if (-1 == Wdeclarationafterstatement)
@@ -504,7 +504,7 @@ static void handle_switch_W_finalize(void)
 
 static void handle_switch_v_finalize(void)
 {
-	handle_onoff_switch_finalize(debugs, sizeof(debugs) / sizeof(debugs[0]));
+	handle_onoff_switch_finalize(debugs, ARRAY_SIZE(debugs));
 }
 
 static char **handle_switch_U(char *arg, char **next)
diff --git a/pre-process.c b/pre-process.c
index 656acaa..603cc00 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -1718,13 +1718,13 @@ static void init_preprocessor(void)
 		{ "elif",	handle_elif },
 	};
 
-	for (i = 0; i < (sizeof (normal) / sizeof (normal[0])); i++) {
+	for (i = 0; i < ARRAY_SIZE(normal); i++) {
 		struct symbol *sym;
 		sym = create_symbol(stream, normal[i].name, SYM_PREPROCESSOR, NS_PREPROCESSOR);
 		sym->handler = normal[i].handler;
 		sym->normal = 1;
 	}
-	for (i = 0; i < (sizeof (special) / sizeof (special[0])); i++) {
+	for (i = 0; i < ARRAY_SIZE(special); i++) {
 		struct symbol *sym;
 		sym = create_symbol(stream, special[i].name, SYM_PREPROCESSOR, NS_PREPROCESSOR);
 		sym->handler = special[i].handler;
diff --git a/show-parse.c b/show-parse.c
index c97debe..73cc86a 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -239,7 +239,7 @@ const char *builtin_typename(struct symbol *sym)
 {
 	int i;
 
-	for (i = 0; i < sizeof(typenames)/sizeof(typenames[0]); i++)
+	for (i = 0; i < ARRAY_SIZE(typenames); i++)
 		if (typenames[i].sym == sym)
 			return typenames[i].name;
 	return NULL;
@@ -249,7 +249,7 @@ const char *builtin_ctypename(struct ctype *ctype)
 {
 	int i;
 
-	for (i = 0; i < sizeof(typenames)/sizeof(typenames[0]); i++)
+	for (i = 0; i < ARRAY_SIZE(typenames); i++)
 		if (&typenames[i].sym->ctype == ctype)
 			return typenames[i].name;
 	return NULL;
-- 
1.7.2.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Nicholas Mc Guire <der.herr () hofr ! at>
To: linux-sparse
Subject: Re: [PATCH] use ARRAY_SIZE() when possible
Date: Thu, 09 Dec 2010 12:36:02 +0000
Message-ID: <20101209123602.GB5470 () opentech ! at>
--------------------
On Thu, 09 Dec 2010, Namhyung Kim wrote:

> Convert (sizeof arr / sizeof arr[0]) to ARRAY_SIZE(arr).
>
would that not be a cadidate for coccinelle/spatch rather than a potentially
error prone and repetitive manual patch?
array.cocci from the current 0.4.2 coccinelle distribution below should du
the job. 
Might make sense to add a coccinelle directory in sparse to handle such cases ?

hofrat
 
// Use the macro ARRAY_SIZE when possible
//
// Confidence: High
// Copyright: (C) Gilles Muller, Julia Lawall, EMN, INRIA, DIKU.  GPLv2.
// URL: http://coccinelle.lip6.fr/rules/array.html
// Options: -I ... -all_includes can give more complete results
virtual org
virtual patch

@i@
@@

#include <linux/kernel.h>

/////////////////////////////////////
/////////////////////////////////////
@depends on i && patch && !org@
type T;
T[] E;
@@

- (sizeof(E)/sizeof(*E))
+ ARRAY_SIZE(E)

@depends on i && patch && !org@
type T;
T[] E;
@@

- (sizeof(E)/sizeof(E[...]))
+ ARRAY_SIZE(E)

@depends on i && patch && !org@
type T;
T[] E;
@@

- (sizeof(E)/sizeof(T))
+ ARRAY_SIZE(E)

@n_patch depends on patch && !org@
identifier AS,E;
@@

- #define AS(E) ARRAY_SIZE(E)

@ depends on patch && !org@
expression E;
identifier n_patch.AS;
@@

- AS(E)
+ ARRAY_SIZE(E)


/////////////////////////////////////
/////////////////////////////////////
@arr_ptr depends on i && !patch && org@
type T;
T[] E;
position p;
@@

 (sizeof(E@p)/sizeof(*E))

@arr_tab depends on i && !patch && org@
type T;
T[] E;
position p;
@@

 (sizeof(E@p)/sizeof(E[...]))

@arr_typ depends on i && !patch && org@
type T;
T[] E;
position p;
@@

 (sizeof(E@p)/sizeof(T))

@n_org depends on !patch && org@
identifier AS,E;
@@

#define AS(E) ARRAY_SIZE(E)

@arr_def depends on !patch && org@
expression E;
identifier n_org.AS;
position p;
@@

AS@p(E)

@script:python@
p << arr_ptr.p;
e << arr_ptr.E;
@@
cocci.print_main(e,p)

@script:python@
p << arr_tab.p;
e << arr_tab.E;
@@
cocci.print_main(e,p)

@script:python@
p << arr_typ.p;
e << arr_typ.E;
@@
cocci.print_main(e,p)

@script:python@
p << arr_def.p;
e << arr_def.E;
@@
cocci.print_main(e,p)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] use ARRAY_SIZE() when possible
Date: Fri, 10 Dec 2010 08:51:50 +0000
Message-ID: <AANLkTin6mzDoAYNP1RSGxy-7O3w+hg5EZi8JLonGKGMS () mail ! gmail ! com>
--------------------
On Thu, Dec 9, 2010 at 3:27 AM, Namhyung Kim <namhyung@gmail.com> wrote:
> Convert (sizeof arr / sizeof arr[0]) to ARRAY_SIZE(arr).
>
> Signed-off-by: Namhyung Kim <namhyung@gmail.com>

Looks good.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [alsa-devel] [patch 1/2] OSS: soundcard: locking bug in sound_ioctl() ===

From: error27 () gmail ! com (Dan Carpenter)
To: alsa-devel
Subject: [alsa-devel] [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Sun, 10 Oct 2010 17:33:52 +0000
Message-ID: <20101010173352.GB5851 () bicker>
--------------------
We shouldn't return directly here because we're still holding the
&soundcard_mutex.

This bug goes all the way back to the start of git.  It's strange that
no one has complained about it as a runtime bug.

CC: stable at kernel.org
Signed-off-by: Dan Carpenter <error27 at gmail.com>

diff --git a/sound/oss/soundcard.c b/sound/oss/soundcard.c
index 938ed94..a5ab61e 100644
--- a/sound/oss/soundcard.c
+++ b/sound/oss/soundcard.c
@@ -392,11 +392,11 @@ static long sound_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	case SND_DEV_DSP:
 	case SND_DEV_DSP16:
 	case SND_DEV_AUDIO:
-		return audio_ioctl(dev, file, cmd, p);
+		ret = audio_ioctl(dev, file, cmd, p);
 		break;
 
 	case SND_DEV_MIDIN:
-		return MIDIbuf_ioctl(dev, file, cmd, p);
+		ret = MIDIbuf_ioctl(dev, file, cmd, p);
 		break;
 
 	}

================================================================================

From: arnd () arndb ! de (Arnd Bergmann)
To: alsa-devel
Subject: [alsa-devel] [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Sun, 10 Oct 2010 18:39:34 +0000
Message-ID: <201010102039.34858.arnd () arndb ! de>
--------------------
On Sunday 10 October 2010 19:33:52 Dan Carpenter wrote:
> We shouldn't return directly here because we're still holding the
> &soundcard_mutex.
> 
> This bug goes all the way back to the start of git.  It's strange that
> no one has complained about it as a runtime bug.
> 
> CC: stable at kernel.org
> Signed-off-by: Dan Carpenter <error27 at gmail.com>

It was only recently converted to a mutex from the BKL, which is much
more friendly to misusage because it is automatically released when
the kernel sleeps or when the program exits.

The behavior was already broken with the BKL but the problem was far
less visible. I fear we might be seeing more of these as fallout from
the BKL removal. Sparse should be able to detect most of these cases
though, so maybe we can look more carefully for them.

Acked-by: Arnd Bergmann <arnd at arndb.de>

	Arnd

================================================================================

From: johannes () sipsolutions ! net (Johannes Berg)
To: alsa-devel
Subject: [alsa-devel] [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 10:52:06 +0000
Message-ID: <1286794326.3634.13.camel () jlt3 ! sipsolutions ! net>
--------------------
On Mon, 2010-10-11 at 12:50 +0200, Arnd Bergmann wrote:
> On Monday 11 October 2010, Johannes Berg wrote:
> > On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:
> > 
> > > Hmm, actually sparse does not warn about sound_ioctl returning in
> > > different lock contexts. Sparse developers: is there a known limitation
> > > in sparse for this? I expected to see context warnings because
> > > sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> > > in some cases returns while holding the lock.
> > 
> > Arnd, mutexes aren't annotated in the kernel source to make use of
> > sparse's context checking.
> 
> D'oh. I never realized this was only done for some types of locks.
> Is there a reason why we don't want mutexes to be annotated or do
> we just need someone to do it?

I don't know. Could be related to trylock issues, could be just historic
since semaphores can't really be annotated, or could be something else
entirely... I would expect a huge amount of warnings from sparse though
if you "just" annotate them since there are things like rtnl_lock()
which would have to propagate context.

johannes


================================================================================

From: tiwai () suse ! de (Takashi Iwai)
To: alsa-devel
Subject: [alsa-devel] [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 11:59:35 +0000
Message-ID: <s5hsk0dgct4.wl%tiwai () suse ! de>
--------------------
At Sun, 10 Oct 2010 19:33:52 +0200,
Dan Carpenter wrote:
> 
> We shouldn't return directly here because we're still holding the
> &soundcard_mutex.
> 
> This bug goes all the way back to the start of git.  It's strange that
> no one has complained about it as a runtime bug.
> 
> CC: stable at kernel.org
> Signed-off-by: Dan Carpenter <error27 at gmail.com>

Applied now.  Thanks.


Takashi


> diff --git a/sound/oss/soundcard.c b/sound/oss/soundcard.c
> index 938ed94..a5ab61e 100644
> --- a/sound/oss/soundcard.c
> +++ b/sound/oss/soundcard.c
> @@ -392,11 +392,11 @@ static long sound_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
>  	case SND_DEV_DSP:
>  	case SND_DEV_DSP16:
>  	case SND_DEV_AUDIO:
> -		return audio_ioctl(dev, file, cmd, p);
> +		ret = audio_ioctl(dev, file, cmd, p);
>  		break;
>  
>  	case SND_DEV_MIDIN:
> -		return MIDIbuf_ioctl(dev, file, cmd, p);
> +		ret = MIDIbuf_ioctl(dev, file, cmd, p);
>  		break;
>  
>  	}
> 

================================================================================

From: arnd () arndb ! de (Arnd Bergmann)
To: alsa-devel
Subject: [alsa-devel] [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 20:42:18 +0000
Message-ID: <201010112242.19246.arnd () arndb ! de>
--------------------
On Monday 11 October 2010 20:54:56 Josh Triplett wrote:
> On Mon, Oct 11, 2010 at 12:52:06PM +0200, Johannes Berg wrote:
>
> > I don't know. Could be related to trylock issues, could be just historic
> > since semaphores can't really be annotated, or could be something else
> > entirely... I would expect a huge amount of warnings from sparse though
> > if you "just" annotate them since there are things like rtnl_lock()
> > which would have to propagate context.
> 
> As far as I know, no reason exists to not just annotate mutexes; I think
> mutexes just came along later and nobody happened to add the appropriate
> annotations.  (Also, sparse does handle trylock.)
> 
> But yes, annotating mutexes will then introduce a giant pile of lock
> warnings that need further annotation propagation.  It will also
> introduce lock warnings that represent actual bugs, making it important
> to not just blindly propagate annotations to make warnings go away.

I've given it a try, wrapping the trylock/interruptible/killable variants
into macros and the number of additional warnings was much less than
I had feared. This is the diff for today's sparse with today's linux-next
x86_64_defconfig:

> arch/x86/kernel/smpboot.c:100:6: warning: context imbalance in 'cpu_hotplug_driver_lock' - wrong count at exit
> arch/x86/kernel/smpboot.c:105:6: warning: context imbalance in 'cpu_hotplug_driver_unlock' - unexpected unlock
> kernel/cpu.c:27:6: warning: context imbalance in 'cpu_maps_update_begin' - wrong count at exit
> kernel/cpu.c:32:6: warning: context imbalance in 'cpu_maps_update_done' - unexpected unlock
> kernel/cpu.c:110:9: warning: context imbalance in 'cpu_hotplug_begin' - wrong count at exit
> kernel/cpu.c:120:13: warning: context imbalance in 'cpu_hotplug_done' - unexpected unlock
> kernel/params.c:565:6: warning: context imbalance in '__kernel_param_lock' - wrong count at exit
> kernel/params.c:571:6: warning: context imbalance in '__kernel_param_unlock' - unexpected unlock
> kernel/irq/autoprobe.c:110:9: warning: context imbalance in 'probe_irq_on' - wrong count at exit
> kernel/irq/autoprobe.c:145:9: warning: context imbalance in 'probe_irq_mask' - unexpected unlock
> kernel/irq/autoprobe.c:189:9: warning: context imbalance in 'probe_irq_off' - unexpected unlock
> kernel/trace/trace.c:1716:26: warning: context imbalance in 's_start' - different lock contexts for basic block
> kernel/trace/trace.c:303:31: warning: context imbalance in 's_stop' - unexpected unlock
> kernel/trace/trace.c:2277:9: warning: context imbalance in 't_start' - wrong count at exit
> kernel/trace/trace.c:2280:13: warning: context imbalance in 't_stop' - unexpected unlock
> kernel/trace/trace.c:3196:28: warning: context imbalance in 'tracing_read_pipe' - different lock contexts for basic block
> kernel/trace/trace.c:3349:28: warning: context imbalance in 'tracing_splice_read_pipe' - different lock contexts for basic block
> kernel/trace/trace.c:303:31: warning: context imbalance in 'tracing_buffers_read' - unexpected unlock
> kernel/trace/trace.c:303:31: warning: context imbalance in 'tracing_buffers_splice_read' - unexpected unlock
> kernel/trace/trace_stat.c:203:13: warning: context imbalance in 'stat_seq_start' - wrong count at exit
> kernel/trace/trace_stat.c:240:13: warning: context imbalance in 'stat_seq_stop' - unexpected unlock
> kernel/trace/trace_events.c:399:9: warning: context imbalance in 't_start' - wrong count at exit
> kernel/trace/trace_events.c:430:9: warning: context imbalance in 's_start' - wrong count at exit
> kernel/trace/trace_events.c:444:13: warning: context imbalance in 't_stop' - unexpected unlock
> kernel/trace/trace_kprobe.c:1064:13: warning: context imbalance in 'probes_seq_start' - wrong count at exit
> kernel/trace/trace_kprobe.c:1075:13: warning: context imbalance in 'probes_seq_stop' - unexpected unlock
> kernel/cgroup.c:737:6: warning: context imbalance in 'cgroup_lock' - wrong count at exit
> kernel/cgroup.c:748:6: warning: context imbalance in 'cgroup_unlock' - unexpected unlock
> kernel/cgroup.c:1867:6: warning: context imbalance in 'cgroup_lock_live_group' - different lock contexts for basic block
> kernel/cgroup.c:2155:12: warning: context imbalance in 'cgroup_create_file' - different lock contexts for basic block
> kernel/cgroup.c:3273:47: warning: context imbalance in 'cgroup_lock_hierarchy' - different lock contexts for basic block
> kernel/cgroup.c:3291:25: warning: context imbalance in 'cgroup_unlock_hierarchy' - unexpected unlock
> kernel/cgroup.c:3362:9: warning: context imbalance in 'cgroup_create' - unexpected unlock
> kernel/cpuset.c:2449:6: warning: context imbalance in 'cpuset_unlock' - unexpected unlock
> kernel/audit_watch.c:439:5: warning: context imbalance in 'audit_add_watch' - unexpected unlock
> kernel/audit_tree.c:662:9: warning: context imbalance in 'audit_add_tree_rule' - unexpected unlock
> mm/shmem.c:943:9: warning: context imbalance in 'shmem_unuse_inode' - unexpected unlock
> mm/shmem.c:1029:9: warning: context imbalance in 'shmem_unuse' - wrong count at exit
> mm/mmap.c:2598:9: warning: context imbalance in 'mm_take_all_locks' - wrong count at exit
> mm/mmap.c:2657:9: warning: context imbalance in 'mm_drop_all_locks' - unexpected unlock
> mm/swapfile.c:1692:13: warning: context imbalance in 'swap_start' - wrong count at exit
> mm/swapfile.c:1737:13: warning: context imbalance in 'swap_stop' - unexpected unlock
> mm/swapfile.c:2114:17: warning: context imbalance in 'sys_swapon' - unexpected unlock
> fs/super.c:239:6: warning: context imbalance in 'lock_super' - wrong count at exit
> fs/super.c:245:6: warning: context imbalance in 'unlock_super' - unexpected unlock
> fs/exec.c:1079:5: warning: context imbalance in 'prepare_bprm_creds' - different lock contexts for basic block
> arch/x86/include/asm/current.h:14:16: warning: context imbalance in 'free_bprm' - unexpected unlock
> fs/exec.c:1105:6: warning: context imbalance in 'install_exec_creds' - unexpected unlock
> fs/pipe.c:55:9: warning: context imbalance in 'pipe_lock_nested' - wrong count at exit
> fs/pipe.c:71:17: warning: context imbalance in 'pipe_unlock' - unexpected unlock
> fs/namei.c:1346:15: warning: context imbalance in 'lock_rename' - wrong count at exit
> fs/namei.c:1376:6: warning: context imbalance in 'unlock_rename' - unexpected unlock
> fs/namei.c:1491:36: warning: context imbalance in '__open_namei_create' - unexpected unlock
> fs/namei.c:1730:20: warning: context imbalance in 'do_last' - different lock contexts for basic block
> fs/namei.c:1905:15: warning: context imbalance in 'lookup_create' - wrong count at exit
> fs/namei.c:2040:9: warning: context imbalance in 'sys_mknodat' - unexpected unlock
> fs/namei.c:2103:9: warning: context imbalance in 'sys_mkdirat' - unexpected unlock
> fs/namei.c:2391:9: warning: context imbalance in 'sys_symlinkat' - unexpected unlock
> fs/namei.c:2490:9: warning: context imbalance in 'sys_linkat' - unexpected unlock
> fs/namei.c:2577:9: warning: context imbalance in 'vfs_rename_dir' - different lock contexts for basic block
> fs/namei.c:2609:9: warning: context imbalance in 'vfs_rename_other' - different lock contexts for basic block
> fs/readdir.c:43:9: warning: context imbalance in 'vfs_readdir' - unexpected unlock
> fs/dcache.c:1792:17: warning: context imbalance in '__d_unalias' - unexpected unlock
> fs/libfs.c:783:9: warning: context imbalance in 'simple_attr_read' - unexpected unlock
> fs/libfs.c:815:9: warning: context imbalance in 'simple_attr_write' - unexpected unlock
> fs/direct-io.c:1095:17: warning: context imbalance in 'direct_io_worker' - unexpected unlock
> fs/direct-io.c:1253:9: warning: context imbalance in '__blockdev_direct_IO' - different lock contexts for basic block
> fs/autofs4/root.c:582:17: warning: context imbalance in 'autofs4_lookup' - unexpected unlock
> fs/autofs4/waitq.c:274:25: warning: context imbalance in 'validate_request' - unexpected unlock
> fs/autofs4/waitq.c:366:17: warning: context imbalance in 'autofs4_wait' - different lock contexts for basic block
> include/linux/spinlock_api_smp.h:152:27: warning: context imbalance in 'journal_lock_updates' - wrong count at exit
> fs/jbd/transaction.c:484:9: warning: context imbalance in 'journal_unlock_updates' - unexpected unlock
> fs/proc/base.c:2313:9: warning: context imbalance in 'proc_pid_attr_write' - unexpected unlock
> fs/proc/proc_tty.c:107:13: warning: context imbalance in 't_start' - wrong count at exit
> fs/proc/proc_tty.c:118:13: warning: context imbalance in 't_stop' - unexpected unlock
> fs/sysfs/dir.c:350:6: warning: context imbalance in 'sysfs_addrm_start' - wrong count at exit
> fs/sysfs/dir.c:504:6: warning: context imbalance in 'sysfs_addrm_finish' - unexpected unlock
> arch/x86/include/asm/current.h:14:16: warning: context imbalance in 'ata_eh_acquire' - wrong count at exit
> drivers/ata/libata-eh.c:495:9: warning: context imbalance in 'ata_eh_release' - unexpected unlock
> drivers/base/bus.c:181:17: warning: context imbalance in 'driver_unbind' - different lock contexts for basic block
> drivers/base/bus.c:211:17: warning: context imbalance in 'driver_bind' - different lock contexts for basic block
> drivers/base/bus.c:731:9: warning: context imbalance in 'bus_rescan_devices_helper' - different lock contexts for basic block
> drivers/base/bus.c:766:9: warning: context imbalance in 'device_reprobe' - different lock contexts for basic block
> drivers/base/dd.c:265:12: warning: context imbalance in '__driver_attach' - different lock contexts for basic block
> drivers/base/dd.c:395:17: warning: context imbalance in 'driver_detach' - different lock contexts for basic block
> drivers/base/power/main.c:73:6: warning: context imbalance in 'device_pm_lock' - wrong count at exit
> drivers/base/power/main.c:81:6: warning: context imbalance in 'device_pm_unlock' - unexpected unlock
> drivers/block/loop.c:1064:9: warning: context imbalance in 'loop_clr_fd' - unexpected unlock
> drivers/block/loop.c:1352:9: warning: context imbalance in 'lo_ioctl' - different lock contexts for basic block
> drivers/block/loop.c:1553:9: warning: context imbalance in 'lo_release' - different lock contexts for basic block
> drivers/char/tty_io.c:960:6: warning: context imbalance in 'tty_write_unlock' - unexpected unlock
> drivers/char/tty_io.c:966:5: warning: context imbalance in 'tty_write_lock' - wrong count at exit
> drivers/char/tty_io.c:1077:6: warning: context imbalance in 'tty_write_message' - wrong count at exit
> drivers/char/tty_mutex.c:31:9: warning: context imbalance in 'tty_lock' - wrong count at exit
> drivers/char/tty_mutex.c:42:9: warning: context imbalance in 'tty_unlock' - unexpected unlock
> drivers/char/misc.c:66:13: warning: context imbalance in 'misc_seq_start' - wrong count at exit
> drivers/char/misc.c:77:13: warning: context imbalance in 'misc_seq_stop' - unexpected unlock
> drivers/cpuidle/cpuidle.c:138:6: warning: context imbalance in 'cpuidle_pause_and_lock' - wrong count at exit
> drivers/cpuidle/cpuidle.c:149:6: warning: context imbalance in 'cpuidle_resume_and_unlock' - unexpected unlock
> drivers/gpu/drm/drm_pci.c:215:9: warning: context imbalance in 'drm_get_pci_dev' - unexpected unlock
> drivers/gpu/drm/i915/i915_debugfs.c:202:9: warning: context imbalance in 'i915_gem_object_info' - unexpected unlock
> drivers/gpu/drm/i915/i915_debugfs.c:827:9: warning: context imbalance in 'i915_emon_status' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:144:12: warning: context imbalance in 'i915_mutex_lock_interruptible' - different lock contexts for basic block
> drivers/gpu/drm/i915/i915_gem.c:417:9: warning: context imbalance in 'i915_gem_shmem_pread_fast' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:554:9: warning: context imbalance in 'i915_gem_shmem_pread_slow' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:706:17: warning: context imbalance in 'i915_gem_gtt_pwrite_fast' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:847:9: warning: context imbalance in 'i915_gem_gtt_pwrite_slow' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:918:9: warning: context imbalance in 'i915_gem_shmem_pwrite_fast' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1032:9: warning: context imbalance in 'i915_gem_shmem_pwrite_slow' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1184:35: warning: context imbalance in 'i915_gem_set_domain_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1217:35: warning: context imbalance in 'i915_gem_sw_finish_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1529:43: warning: context imbalance in 'i915_gem_mmap_gtt_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:3770:17: warning: context imbalance in 'i915_gem_do_execbuffer' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4248:43: warning: context imbalance in 'i915_gem_pin_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4310:43: warning: context imbalance in 'i915_gem_unpin_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4375:35: warning: context imbalance in 'i915_gem_busy_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4419:43: warning: context imbalance in 'i915_gem_madvise_ioctl' - unexpected unlock
> drivers/hid/usbhid/hid-core.c:127:47: warning: context imbalance in 'hid_reset' - unexpected unlock
> drivers/input/input.c:1021:13: warning: context imbalance in 'input_devices_seq_start' - different lock contexts for basic block
> drivers/input/input.c:1050:17: warning: context imbalance in 'input_seq_stop' - unexpected unlock
> drivers/input/input.c:1143:13: warning: context imbalance in 'input_handlers_seq_start' - different lock contexts for basic block
> drivers/input/mouse/psmouse-base.c:1534:9: warning: context imbalance in 'psmouse_attr_set_helper' - unexpected unlock
> drivers/input/serio/i8042.c:129:6: warning: context imbalance in 'i8042_lock_chip' - wrong count at exit
> drivers/input/serio/i8042.c:135:6: warning: context imbalance in 'i8042_unlock_chip' - unexpected unlock
> drivers/input/serio/libps2.c:62:9: warning: context imbalance in 'ps2_begin_command' - wrong count at exit
> drivers/input/serio/libps2.c:72:9: warning: context imbalance in 'ps2_end_command' - unexpected unlock
> drivers/md/dm.c:2088:6: warning: context imbalance in 'dm_lock_md_type' - wrong count at exit
> drivers/md/dm.c:2093:6: warning: context imbalance in 'dm_unlock_md_type' - unexpected unlock
> drivers/md/md.c:578:17: warning: context imbalance in 'mddev_unlock' - unexpected unlock
> drivers/md/md.c:546:19: warning: context imbalance in 'rdev_size_store' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'rdev_attr_show' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'rdev_attr_store' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_attr_show' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_attr_store' - different lock contexts for basic block
> drivers/md/md.c:4871:17: warning: context imbalance in 'autorun_devices' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_ioctl' - different lock contexts for basic block
> drivers/md/md.c:5911:9: warning: context imbalance in 'md_open' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_seq_show' - different lock contexts for basic block
> drivers/md/md.c:6985:6: warning: context imbalance in 'md_check_recovery' - different lock contexts for basic block
> drivers/md/md.c:7180:17: warning: context imbalance in 'md_notify_reboot' - different lock contexts for basic block
> drivers/pci/pci.c:2494:30: warning: context imbalance in 'pci_dev_reset' - unexpected unlock
> drivers/pcmcia/rsrc_nonstatic.c:281:17: warning: context imbalance in 'readable' - unexpected unlock
> drivers/serial/serial_core.c:1546:26: warning: context imbalance in 'uart_get' - different lock contexts for basic block
> drivers/serial/serial_core.c:1632:17: warning: context imbalance in 'uart_open' - unexpected unlock
> drivers/thermal/thermal_sys.c:74:9: warning: context imbalance in 'get_idr' - different lock contexts for basic block
> drivers/thermal/thermal_sys.c:88:9: warning: context imbalance in 'release_idr' - different lock contexts for basic block
> drivers/usb/class/usblp.c:842:9: warning: context imbalance in 'usblp_read' - unexpected unlock
> arch/x86/include/asm/current.h:14:16: warning: context imbalance in 'usblp_rwait_and_lock' - different lock contexts for basic block
> drivers/usb/core/usb.c:561:5: warning: context imbalance in 'usb_lock_device_for_reset' - different lock contexts for basic block
> drivers/usb/core/message.c:1605:17: warning: context imbalance in '__usb_queue_reset_device' - unexpected unlock
> drivers/usb/storage/transport.c:1315:17: warning: context imbalance in 'usb_stor_port_reset' - unexpected unlock
> drivers/usb/storage/usb.c:191:5: warning: context imbalance in 'usb_stor_pre_reset' - wrong count at exit
> drivers/usb/storage/usb.c:203:5: warning: context imbalance in 'usb_stor_post_reset' - unexpected unlock
> drivers/video/fbmem.c:48:5: warning: context imbalance in 'lock_fb_info' - wrong count at exit
> drivers/video/fbmem.c:1047:17: warning: context imbalance in 'do_fb_ioctl' - unexpected unlock
> drivers/video/fbmem.c:1608:9: warning: context imbalance in 'register_framebuffer' - unexpected unlock
> drivers/video/fbmem.c:1646:9: warning: context imbalance in 'unregister_framebuffer' - unexpected unlock
> drivers/video/fbmem.c:1696:23: warning: context imbalance in 'fb_set_suspend' - unexpected unlock
> drivers/video/fbmem.c:1768:17: warning: context imbalance in 'fb_new_modelist' - unexpected unlock
> drivers/video/fbcmap.c:276:23: warning: context imbalance in 'fb_set_user_cmap' - unexpected unlock
> drivers/video/console/fbcon.c:2299:9: warning: context imbalance in 'fbcon_generic_blank' - unexpected unlock
> sound/core/sound.c:124:25: warning: context imbalance in 'autoload_device' - unexpected unlock
> net/netfilter/core.c:40:9: warning: context imbalance in 'nf_register_afinfo' - unexpected unlock
> net/netfilter/core.c:71:21: warning: context imbalance in 'nf_register_hook' - unexpected unlock
> net/netfilter/nf_log.c:132:13: warning: context imbalance in 'seq_start' - wrong count at exit
> net/netfilter/nf_log.c:152:13: warning: context imbalance in 'seq_stop' - unexpected unlock
> net/netfilter/x_tables.c:710:17: warning: context imbalance in 'xt_find_table_lock' - different lock contexts for basic block
> net/netfilter/x_tables.c:726:6: warning: context imbalance in 'xt_table_unlock' - unexpected unlock
> net/netfilter/x_tables.c:733:6: warning: context imbalance in 'xt_compat_lock' - wrong count at exit
> net/netfilter/x_tables.c:739:6: warning: context imbalance in 'xt_compat_unlock' - unexpected unlock
> net/netfilter/x_tables.c:876:9: warning: context imbalance in 'xt_register_table' - unexpected unlock
> net/netfilter/x_tables.c:903:13: warning: context imbalance in 'xt_table_seq_start' - wrong count at exit
> net/netfilter/x_tables.c:922:13: warning: context imbalance in 'xt_table_seq_stop' - unexpected unlock
> net/netfilter/x_tables.c:985:13: warning: context imbalance in 'xt_mttg_seq_next' - wrong count at exit
> net/netfilter/x_tables.c:1044:17: warning: context imbalance in 'xt_mttg_seq_stop' - unexpected unlock
> net/netlink/genetlink.c:24:6: warning: context imbalance in 'genl_lock' - wrong count at exit
> net/netlink/genetlink.c:30:6: warning: context imbalance in 'genl_unlock' - unexpected unlock
> net/unix/af_unix.c:919:9: warning: context imbalance in 'unix_bind' - different lock contexts for basic block
> net/wireless/core.c:150:9: warning: context imbalance in 'cfg80211_get_dev_from_info' - different lock contexts for basic block
> net/wireless/core.c:172:9: warning: context imbalance in 'cfg80211_get_dev_from_ifindex' - wrong count at exit
> net/wireless/core.h:191:9: warning: context imbalance in 'cfg80211_wext_siwscan' - unexpected unlock
> net/wireless/core.h:191:9: warning: context imbalance in 'cfg80211_wext_giwscan' - unexpected unlock
> net/wireless/core.h:191:9: warning: context imbalance in 'nl80211_finish_netdev_dump' - unexpected unlock
> net/wireless/nl80211.c:901:12: warning: context imbalance in 'nl80211_set_wiphy' - different lock contexts for basic block
> net/wireless/core.h:191:9: warning: context imbalance in 'nl80211_pre_doit' - unexpected unlock
> net/wireless/core.h:191:9: warning: context imbalance in 'nl80211_post_doit' - unexpected unlock

And this is the patch I used for testing. There may still be some flaws in it,
but it seems to do the trick.

Signed-off-by: Arnd Bergmann <arnd at arndb.de>

diff --git a/include/linux/mutex.h b/include/linux/mutex.h
index f363bc8..d4940af 100644
--- a/include/linux/mutex.h
+++ b/include/linux/mutex.h
@@ -14,6 +14,7 @@
 #include <linux/spinlock_types.h>
 #include <linux/linkage.h>
 #include <linux/lockdep.h>
+#include <linux/compiler.h>
 
 #include <asm/atomic.h>
 
@@ -131,20 +132,35 @@ static inline int mutex_is_locked(struct mutex *lock)
  * Also see Documentation/mutex-design.txt.
  */
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
-extern void mutex_lock_nested(struct mutex *lock, unsigned int subclass);
-extern int __must_check mutex_lock_interruptible_nested(struct mutex *lock,
-					unsigned int subclass);
-extern int __must_check mutex_lock_killable_nested(struct mutex *lock,
-					unsigned int subclass);
-
+extern void mutex_lock_nested(struct mutex *lock, unsigned int subclass)
+				__acquires(lock);
+extern int __must_check __mutex_lock_interruptible_nested(struct mutex *lock,
+						unsigned int subclass);
+extern int __must_check __mutex_lock_killable_nested(struct mutex *lock,
+						unsigned int subclass);
+#define mutex_lock_interruptible_nested(lock, subclass)	({		\
+   int __mutex_ret = __mutex_lock_interruptible_nested(lock, subclass);	\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
+#define mutex_lock_killable_nested(lock, subclass)	({		\
+   int __mutex_ret = __mutex_lock_killable_nested(lock, subclass);	\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
 #define mutex_lock(lock) mutex_lock_nested(lock, 0)
 #define mutex_lock_interruptible(lock) mutex_lock_interruptible_nested(lock, 0)
 #define mutex_lock_killable(lock) mutex_lock_killable_nested(lock, 0)
 #else
-extern void mutex_lock(struct mutex *lock);
-extern int __must_check mutex_lock_interruptible(struct mutex *lock);
-extern int __must_check mutex_lock_killable(struct mutex *lock);
-
+extern void mutex_lock(struct mutex *lock) __acquires(lock);
+extern int __must_check __mutex_lock_interruptible(struct mutex *lock);
+extern int __must_check __mutex_lock_killable(struct mutex *lock);
+#define mutex_lock_interruptible(lock)	({				\
+   int __mutex_ret = __mutex_lock_interruptible(lock);			\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
+#define mutex_lock_killable(lock)	({				\
+   int __mutex_ret = __mutex_lock_killable(lock);			\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
 # define mutex_lock_nested(lock, subclass) mutex_lock(lock)
 # define mutex_lock_interruptible_nested(lock, subclass) mutex_lock_interruptible(lock)
 # define mutex_lock_killable_nested(lock, subclass) mutex_lock_killable(lock)
@@ -156,8 +172,16 @@ extern int __must_check mutex_lock_killable(struct mutex *lock);
  *
  * Returns 1 if the mutex has been acquired successfully, and 0 on contention.
  */
-extern int mutex_trylock(struct mutex *lock);
-extern void mutex_unlock(struct mutex *lock);
-extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
+extern int __mutex_trylock(struct mutex *lock);
+#define mutex_trylock(lock)	({					\
+   int __mutex_ret = __mutex_trylock(lock);				\
+   if (__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
+extern void mutex_unlock(struct mutex *lock) __releases(lock);
+extern int __atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
+#define atomic_dec_and_mutex_lock(cnt, lock)	({			\
+   int __mutex_ret = __atomic_dec_and_mutex_lock(cnt, lock);		\
+   if (__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
 
 #endif
diff --git a/kernel/mutex.c b/kernel/mutex.c
index 200407c..09b70b7 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -282,22 +282,22 @@ mutex_lock_nested(struct mutex *lock, unsigned int subclass)
 EXPORT_SYMBOL_GPL(mutex_lock_nested);
 
 int __sched
-mutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)
+__mutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)
 {
 	might_sleep();
 	return __mutex_lock_common(lock, TASK_KILLABLE, subclass, _RET_IP_);
 }
-EXPORT_SYMBOL_GPL(mutex_lock_killable_nested);
+EXPORT_SYMBOL_GPL(__mutex_lock_killable_nested);
 
 int __sched
-mutex_lock_interruptible_nested(struct mutex *lock, unsigned int subclass)
+__mutex_lock_interruptible_nested(struct mutex *lock, unsigned int subclass)
 {
 	might_sleep();
 	return __mutex_lock_common(lock, TASK_INTERRUPTIBLE,
 				   subclass, _RET_IP_);
 }
 
-EXPORT_SYMBOL_GPL(mutex_lock_interruptible_nested);
+EXPORT_SYMBOL_GPL(__mutex_lock_interruptible_nested);
 #endif
 
 /*
@@ -366,7 +366,7 @@ __mutex_lock_interruptible_slowpath(atomic_t *lock_count);
  *
  * This function is similar to (but not equivalent to) down_interruptible().
  */
-int __sched mutex_lock_interruptible(struct mutex *lock)
+int __sched __mutex_lock_interruptible(struct mutex *lock)
 {
 	int ret;
 
@@ -379,9 +379,9 @@ int __sched mutex_lock_interruptible(struct mutex *lock)
 	return ret;
 }
 
-EXPORT_SYMBOL(mutex_lock_interruptible);
+EXPORT_SYMBOL(__mutex_lock_interruptible);
 
-int __sched mutex_lock_killable(struct mutex *lock)
+int __sched __mutex_lock_killable(struct mutex *lock)
 {
 	int ret;
 
@@ -393,7 +393,7 @@ int __sched mutex_lock_killable(struct mutex *lock)
 
 	return ret;
 }
-EXPORT_SYMBOL(mutex_lock_killable);
+EXPORT_SYMBOL(__mutex_lock_killable);
 
 static __used noinline void __sched
 __mutex_lock_slowpath(atomic_t *lock_count)
@@ -461,7 +461,7 @@ static inline int __mutex_trylock_slowpath(atomic_t *lock_count)
  * This function must not be used in interrupt context. The
  * mutex must be released by the same task that acquired it.
  */
-int __sched mutex_trylock(struct mutex *lock)
+int __sched __mutex_trylock(struct mutex *lock)
 {
 	int ret;
 
@@ -471,7 +471,7 @@ int __sched mutex_trylock(struct mutex *lock)
 
 	return ret;
 }
-EXPORT_SYMBOL(mutex_trylock);
+EXPORT_SYMBOL(__mutex_trylock);
 
 /**
  * atomic_dec_and_mutex_lock - return holding mutex if we dec to 0
@@ -480,7 +480,7 @@ EXPORT_SYMBOL(mutex_trylock);
  *
  * return true and hold lock if we dec to 0, return false otherwise
  */
-int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
+int __atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
 {
 	/* dec if we can't possibly hit 0 */
 	if (atomic_add_unless(cnt, -1, 1))
@@ -495,4 +495,4 @@ int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
 	/* we hit 0, and we hold the lock */
 	return 1;
 }
-EXPORT_SYMBOL(atomic_dec_and_mutex_lock);
+EXPORT_SYMBOL(__atomic_dec_and_mutex_lock);

================================================================================

From: josh () joshtriplett ! org (Josh Triplett)
To: alsa-devel
Subject: [alsa-devel] [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Tue, 12 Oct 2010 06:43:26 +0000
Message-ID: <20101012064326.GB1702 () feather>
--------------------
On Tue, Oct 12, 2010 at 08:39:14AM +0200, Arnd Bergmann wrote:
> On Tuesday 12 October 2010 00:23:08 Josh Triplett wrote:
> > Assuming that the underlying function only returns zero/non-zero and
> > that the actual return value doesn't matter, then you can use the
> > __cond_lock macro from compiler.h for this:
> > 
> > # define __cond_lock(x,c)       ((c) ? ({ __acquire(x); 1; }) : 0)
> > 
> 
> The return from mutex_lock_{killable,interruptible} is an error
> value, not true/false, so it actually matters. We know that the only
> possible error that is currently returned is -EINTR though, so we
> could do a similar trick and define another
> 
> #define __cond_mutex(x, c)	((!c) ? ({ __acquire(x); 0; }) : -EINTR)
> 
> My fear was that this would impact code generation.

If __cond_lock doesn't fit, then you could just define a generic wrapper
to capture the pattern of preserving a function's return value, and use
that for all the mutex calls.  And if you just preserve the return
value, and __acquire compiles to nothing for GCC, then GCC should just
optimize away the extra copy into a local variable.

- Josh Triplett

================================================================================


################################################################################

=== Thread: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl() ===

From: Arnd Bergmann <arnd () arndb ! de>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 08:13:27 +0000
Message-ID: <201010111013.28952.arnd () arndb ! de>
--------------------
On Sunday 10 October 2010 20:39:34 Arnd Bergmann wrote:
> On Sunday 10 October 2010 19:33:52 Dan Carpenter wrote:
> > We shouldn't return directly here because we're still holding the
> > &soundcard_mutex.
> > 
> > This bug goes all the way back to the start of git.  It's strange that
> > no one has complained about it as a runtime bug.
> > 
> > CC: stable@kernel.org
> > Signed-off-by: Dan Carpenter <error27@gmail.com>
> 
> It was only recently converted to a mutex from the BKL, which is much
> more friendly to misusage because it is automatically released when
> the kernel sleeps or when the program exits.
> 
> The behavior was already broken with the BKL but the problem was far
> less visible. I fear we might be seeing more of these as fallout from
> the BKL removal. Sparse should be able to detect most of these cases
> though, so maybe we can look more carefully for them.
 
Hmm, actually sparse does *not* warn about sound_ioctl returning in
different lock contexts. Sparse developers: is there a known limitation
in sparse for this? I expected to see context warnings because
sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
in some cases returns while holding the lock.

	Arnd
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 08:50:00 +0000
Message-ID: <1286787000.3634.1.camel () jlt3 ! sipsolutions ! net>
--------------------
On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:

> Hmm, actually sparse does *not* warn about sound_ioctl returning in
> different lock contexts. Sparse developers: is there a known limitation
> in sparse for this? I expected to see context warnings because
> sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> in some cases returns while holding the lock.

Arnd, mutexes aren't annotated in the kernel source to make use of
sparse's context checking.

johannes

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 08:50:00 +0000
Message-ID: <1286787000.3634.1.camel () jlt3 ! sipsolutions ! net>
--------------------
On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:

> Hmm, actually sparse does *not* warn about sound_ioctl returning in
> different lock contexts. Sparse developers: is there a known limitation
> in sparse for this? I expected to see context warnings because
> sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> in some cases returns while holding the lock.

Arnd, mutexes aren't annotated in the kernel source to make use of
sparse's context checking.

johannes

--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnd Bergmann <arnd () arndb ! de>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 10:50:16 +0000
Message-ID: <201010111250.16299.arnd () arndb ! de>
--------------------
On Monday 11 October 2010, Johannes Berg wrote:
> On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:
> 
> > Hmm, actually sparse does not warn about sound_ioctl returning in
> > different lock contexts. Sparse developers: is there a known limitation
> > in sparse for this? I expected to see context warnings because
> > sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> > in some cases returns while holding the lock.
> 
> Arnd, mutexes aren't annotated in the kernel source to make use of
> sparse's context checking.

D'oh. I never realized this was only done for some types of locks.
Is there a reason why we don't want mutexes to be annotated or do
we just need someone to do it?

	Arnd
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnd Bergmann <arnd () arndb ! de>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 10:50:16 +0000
Message-ID: <201010111250.16299.arnd () arndb ! de>
--------------------
On Monday 11 October 2010, Johannes Berg wrote:
> On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:
> 
> > Hmm, actually sparse does not warn about sound_ioctl returning in
> > different lock contexts. Sparse developers: is there a known limitation
> > in sparse for this? I expected to see context warnings because
> > sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> > in some cases returns while holding the lock.
> 
> Arnd, mutexes aren't annotated in the kernel source to make use of
> sparse's context checking.

D'oh. I never realized this was only done for some types of locks.
Is there a reason why we don't want mutexes to be annotated or do
we just need someone to do it?

	Arnd
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 10:52:06 +0000
Message-ID: <1286794326.3634.13.camel () jlt3 ! sipsolutions ! net>
--------------------
On Mon, 2010-10-11 at 12:50 +0200, Arnd Bergmann wrote:
> On Monday 11 October 2010, Johannes Berg wrote:
> > On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:
> > 
> > > Hmm, actually sparse does not warn about sound_ioctl returning in
> > > different lock contexts. Sparse developers: is there a known limitation
> > > in sparse for this? I expected to see context warnings because
> > > sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> > > in some cases returns while holding the lock.
> > 
> > Arnd, mutexes aren't annotated in the kernel source to make use of
> > sparse's context checking.
> 
> D'oh. I never realized this was only done for some types of locks.
> Is there a reason why we don't want mutexes to be annotated or do
> we just need someone to do it?

I don't know. Could be related to trylock issues, could be just historic
since semaphores can't really be annotated, or could be something else
entirely... I would expect a huge amount of warnings from sparse though
if you "just" annotate them since there are things like rtnl_lock()
which would have to propagate context.

johannes

--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 10:52:06 +0000
Message-ID: <1286794326.3634.13.camel () jlt3 ! sipsolutions ! net>
--------------------
On Mon, 2010-10-11 at 12:50 +0200, Arnd Bergmann wrote:
> On Monday 11 October 2010, Johannes Berg wrote:
> > On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:
> > 
> > > Hmm, actually sparse does not warn about sound_ioctl returning in
> > > different lock contexts. Sparse developers: is there a known limitation
> > > in sparse for this? I expected to see context warnings because
> > > sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> > > in some cases returns while holding the lock.
> > 
> > Arnd, mutexes aren't annotated in the kernel source to make use of
> > sparse's context checking.
> 
> D'oh. I never realized this was only done for some types of locks.
> Is there a reason why we don't want mutexes to be annotated or do
> we just need someone to do it?

I don't know. Could be related to trylock issues, could be just historic
since semaphores can't really be annotated, or could be something else
entirely... I would expect a huge amount of warnings from sparse though
if you "just" annotate them since there are things like rtnl_lock()
which would have to propagate context.

johannes

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Takashi Iwai <tiwai () suse ! de>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 11:59:35 +0000
Message-ID: <s5hsk0dgct4.wl%tiwai () suse ! de>
--------------------
At Sun, 10 Oct 2010 19:33:52 +0200,
Dan Carpenter wrote:
> 
> We shouldn't return directly here because we're still holding the
> &soundcard_mutex.
> 
> This bug goes all the way back to the start of git.  It's strange that
> no one has complained about it as a runtime bug.
> 
> CC: stable@kernel.org
> Signed-off-by: Dan Carpenter <error27@gmail.com>

Applied now.  Thanks.


Takashi


> diff --git a/sound/oss/soundcard.c b/sound/oss/soundcard.c
> index 938ed94..a5ab61e 100644
> --- a/sound/oss/soundcard.c
> +++ b/sound/oss/soundcard.c
> @@ -392,11 +392,11 @@ static long sound_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
>  	case SND_DEV_DSP:
>  	case SND_DEV_DSP16:
>  	case SND_DEV_AUDIO:
> -		return audio_ioctl(dev, file, cmd, p);
> +		ret = audio_ioctl(dev, file, cmd, p);
>  		break;
>  
>  	case SND_DEV_MIDIN:
> -		return MIDIbuf_ioctl(dev, file, cmd, p);
> +		ret = MIDIbuf_ioctl(dev, file, cmd, p);
>  		break;
>  
>  	}
> 
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 18:54:56 +0000
Message-ID: <20101011185455.GB8537 () feather>
--------------------
On Mon, Oct 11, 2010 at 12:52:06PM +0200, Johannes Berg wrote:
> On Mon, 2010-10-11 at 12:50 +0200, Arnd Bergmann wrote:
> > On Monday 11 October 2010, Johannes Berg wrote:
> > > On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:
> > > 
> > > > Hmm, actually sparse does not warn about sound_ioctl returning in
> > > > different lock contexts. Sparse developers: is there a known limitation
> > > > in sparse for this? I expected to see context warnings because
> > > > sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> > > > in some cases returns while holding the lock.
> > > 
> > > Arnd, mutexes aren't annotated in the kernel source to make use of
> > > sparse's context checking.
> > 
> > D'oh. I never realized this was only done for some types of locks.
> > Is there a reason why we don't want mutexes to be annotated or do
> > we just need someone to do it?
> 
> I don't know. Could be related to trylock issues, could be just historic
> since semaphores can't really be annotated, or could be something else
> entirely... I would expect a huge amount of warnings from sparse though
> if you "just" annotate them since there are things like rtnl_lock()
> which would have to propagate context.

As far as I know, no reason exists to not just annotate mutexes; I think
mutexes just came along later and nobody happened to add the appropriate
annotations.  (Also, sparse does handle trylock.)

But yes, annotating mutexes will then introduce a giant pile of lock
warnings that need further annotation propagation.  It will also
introduce lock warnings that represent actual bugs, making it important
to not just blindly propagate annotations to make warnings go away.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 18:54:56 +0000
Message-ID: <20101011185455.GB8537 () feather>
--------------------
On Mon, Oct 11, 2010 at 12:52:06PM +0200, Johannes Berg wrote:
> On Mon, 2010-10-11 at 12:50 +0200, Arnd Bergmann wrote:
> > On Monday 11 October 2010, Johannes Berg wrote:
> > > On Mon, 2010-10-11 at 10:13 +0200, Arnd Bergmann wrote:
> > > 
> > > > Hmm, actually sparse does not warn about sound_ioctl returning in
> > > > different lock contexts. Sparse developers: is there a known limitation
> > > > in sparse for this? I expected to see context warnings because
> > > > sound_ioctl normally releases soundcard_mutex (previously lock_kernel)
> > > > in some cases returns while holding the lock.
> > > 
> > > Arnd, mutexes aren't annotated in the kernel source to make use of
> > > sparse's context checking.
> > 
> > D'oh. I never realized this was only done for some types of locks.
> > Is there a reason why we don't want mutexes to be annotated or do
> > we just need someone to do it?
> 
> I don't know. Could be related to trylock issues, could be just historic
> since semaphores can't really be annotated, or could be something else
> entirely... I would expect a huge amount of warnings from sparse though
> if you "just" annotate them since there are things like rtnl_lock()
> which would have to propagate context.

As far as I know, no reason exists to not just annotate mutexes; I think
mutexes just came along later and nobody happened to add the appropriate
annotations.  (Also, sparse does handle trylock.)

But yes, annotating mutexes will then introduce a giant pile of lock
warnings that need further annotation propagation.  It will also
introduce lock warnings that represent actual bugs, making it important
to not just blindly propagate annotations to make warnings go away.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnd Bergmann <arnd () arndb ! de>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 20:42:18 +0000
Message-ID: <201010112242.19246.arnd () arndb ! de>
--------------------
On Monday 11 October 2010 20:54:56 Josh Triplett wrote:
> On Mon, Oct 11, 2010 at 12:52:06PM +0200, Johannes Berg wrote:
>
> > I don't know. Could be related to trylock issues, could be just historic
> > since semaphores can't really be annotated, or could be something else
> > entirely... I would expect a huge amount of warnings from sparse though
> > if you "just" annotate them since there are things like rtnl_lock()
> > which would have to propagate context.
> 
> As far as I know, no reason exists to not just annotate mutexes; I think
> mutexes just came along later and nobody happened to add the appropriate
> annotations.  (Also, sparse does handle trylock.)
> 
> But yes, annotating mutexes will then introduce a giant pile of lock
> warnings that need further annotation propagation.  It will also
> introduce lock warnings that represent actual bugs, making it important
> to not just blindly propagate annotations to make warnings go away.

I've given it a try, wrapping the trylock/interruptible/killable variants
into macros and the number of additional warnings was much less than
I had feared. This is the diff for today's sparse with today's linux-next
x86_64_defconfig:

> arch/x86/kernel/smpboot.c:100:6: warning: context imbalance in 'cpu_hotplug_driver_lock' - wrong count at exit
> arch/x86/kernel/smpboot.c:105:6: warning: context imbalance in 'cpu_hotplug_driver_unlock' - unexpected unlock
> kernel/cpu.c:27:6: warning: context imbalance in 'cpu_maps_update_begin' - wrong count at exit
> kernel/cpu.c:32:6: warning: context imbalance in 'cpu_maps_update_done' - unexpected unlock
> kernel/cpu.c:110:9: warning: context imbalance in 'cpu_hotplug_begin' - wrong count at exit
> kernel/cpu.c:120:13: warning: context imbalance in 'cpu_hotplug_done' - unexpected unlock
> kernel/params.c:565:6: warning: context imbalance in '__kernel_param_lock' - wrong count at exit
> kernel/params.c:571:6: warning: context imbalance in '__kernel_param_unlock' - unexpected unlock
> kernel/irq/autoprobe.c:110:9: warning: context imbalance in 'probe_irq_on' - wrong count at exit
> kernel/irq/autoprobe.c:145:9: warning: context imbalance in 'probe_irq_mask' - unexpected unlock
> kernel/irq/autoprobe.c:189:9: warning: context imbalance in 'probe_irq_off' - unexpected unlock
> kernel/trace/trace.c:1716:26: warning: context imbalance in 's_start' - different lock contexts for basic block
> kernel/trace/trace.c:303:31: warning: context imbalance in 's_stop' - unexpected unlock
> kernel/trace/trace.c:2277:9: warning: context imbalance in 't_start' - wrong count at exit
> kernel/trace/trace.c:2280:13: warning: context imbalance in 't_stop' - unexpected unlock
> kernel/trace/trace.c:3196:28: warning: context imbalance in 'tracing_read_pipe' - different lock contexts for basic block
> kernel/trace/trace.c:3349:28: warning: context imbalance in 'tracing_splice_read_pipe' - different lock contexts for basic block
> kernel/trace/trace.c:303:31: warning: context imbalance in 'tracing_buffers_read' - unexpected unlock
> kernel/trace/trace.c:303:31: warning: context imbalance in 'tracing_buffers_splice_read' - unexpected unlock
> kernel/trace/trace_stat.c:203:13: warning: context imbalance in 'stat_seq_start' - wrong count at exit
> kernel/trace/trace_stat.c:240:13: warning: context imbalance in 'stat_seq_stop' - unexpected unlock
> kernel/trace/trace_events.c:399:9: warning: context imbalance in 't_start' - wrong count at exit
> kernel/trace/trace_events.c:430:9: warning: context imbalance in 's_start' - wrong count at exit
> kernel/trace/trace_events.c:444:13: warning: context imbalance in 't_stop' - unexpected unlock
> kernel/trace/trace_kprobe.c:1064:13: warning: context imbalance in 'probes_seq_start' - wrong count at exit
> kernel/trace/trace_kprobe.c:1075:13: warning: context imbalance in 'probes_seq_stop' - unexpected unlock
> kernel/cgroup.c:737:6: warning: context imbalance in 'cgroup_lock' - wrong count at exit
> kernel/cgroup.c:748:6: warning: context imbalance in 'cgroup_unlock' - unexpected unlock
> kernel/cgroup.c:1867:6: warning: context imbalance in 'cgroup_lock_live_group' - different lock contexts for basic block
> kernel/cgroup.c:2155:12: warning: context imbalance in 'cgroup_create_file' - different lock contexts for basic block
> kernel/cgroup.c:3273:47: warning: context imbalance in 'cgroup_lock_hierarchy' - different lock contexts for basic block
> kernel/cgroup.c:3291:25: warning: context imbalance in 'cgroup_unlock_hierarchy' - unexpected unlock
> kernel/cgroup.c:3362:9: warning: context imbalance in 'cgroup_create' - unexpected unlock
> kernel/cpuset.c:2449:6: warning: context imbalance in 'cpuset_unlock' - unexpected unlock
> kernel/audit_watch.c:439:5: warning: context imbalance in 'audit_add_watch' - unexpected unlock
> kernel/audit_tree.c:662:9: warning: context imbalance in 'audit_add_tree_rule' - unexpected unlock
> mm/shmem.c:943:9: warning: context imbalance in 'shmem_unuse_inode' - unexpected unlock
> mm/shmem.c:1029:9: warning: context imbalance in 'shmem_unuse' - wrong count at exit
> mm/mmap.c:2598:9: warning: context imbalance in 'mm_take_all_locks' - wrong count at exit
> mm/mmap.c:2657:9: warning: context imbalance in 'mm_drop_all_locks' - unexpected unlock
> mm/swapfile.c:1692:13: warning: context imbalance in 'swap_start' - wrong count at exit
> mm/swapfile.c:1737:13: warning: context imbalance in 'swap_stop' - unexpected unlock
> mm/swapfile.c:2114:17: warning: context imbalance in 'sys_swapon' - unexpected unlock
> fs/super.c:239:6: warning: context imbalance in 'lock_super' - wrong count at exit
> fs/super.c:245:6: warning: context imbalance in 'unlock_super' - unexpected unlock
> fs/exec.c:1079:5: warning: context imbalance in 'prepare_bprm_creds' - different lock contexts for basic block
> arch/x86/include/asm/current.h:14:16: warning: context imbalance in 'free_bprm' - unexpected unlock
> fs/exec.c:1105:6: warning: context imbalance in 'install_exec_creds' - unexpected unlock
> fs/pipe.c:55:9: warning: context imbalance in 'pipe_lock_nested' - wrong count at exit
> fs/pipe.c:71:17: warning: context imbalance in 'pipe_unlock' - unexpected unlock
> fs/namei.c:1346:15: warning: context imbalance in 'lock_rename' - wrong count at exit
> fs/namei.c:1376:6: warning: context imbalance in 'unlock_rename' - unexpected unlock
> fs/namei.c:1491:36: warning: context imbalance in '__open_namei_create' - unexpected unlock
> fs/namei.c:1730:20: warning: context imbalance in 'do_last' - different lock contexts for basic block
> fs/namei.c:1905:15: warning: context imbalance in 'lookup_create' - wrong count at exit
> fs/namei.c:2040:9: warning: context imbalance in 'sys_mknodat' - unexpected unlock
> fs/namei.c:2103:9: warning: context imbalance in 'sys_mkdirat' - unexpected unlock
> fs/namei.c:2391:9: warning: context imbalance in 'sys_symlinkat' - unexpected unlock
> fs/namei.c:2490:9: warning: context imbalance in 'sys_linkat' - unexpected unlock
> fs/namei.c:2577:9: warning: context imbalance in 'vfs_rename_dir' - different lock contexts for basic block
> fs/namei.c:2609:9: warning: context imbalance in 'vfs_rename_other' - different lock contexts for basic block
> fs/readdir.c:43:9: warning: context imbalance in 'vfs_readdir' - unexpected unlock
> fs/dcache.c:1792:17: warning: context imbalance in '__d_unalias' - unexpected unlock
> fs/libfs.c:783:9: warning: context imbalance in 'simple_attr_read' - unexpected unlock
> fs/libfs.c:815:9: warning: context imbalance in 'simple_attr_write' - unexpected unlock
> fs/direct-io.c:1095:17: warning: context imbalance in 'direct_io_worker' - unexpected unlock
> fs/direct-io.c:1253:9: warning: context imbalance in '__blockdev_direct_IO' - different lock contexts for basic block
> fs/autofs4/root.c:582:17: warning: context imbalance in 'autofs4_lookup' - unexpected unlock
> fs/autofs4/waitq.c:274:25: warning: context imbalance in 'validate_request' - unexpected unlock
> fs/autofs4/waitq.c:366:17: warning: context imbalance in 'autofs4_wait' - different lock contexts for basic block
> include/linux/spinlock_api_smp.h:152:27: warning: context imbalance in 'journal_lock_updates' - wrong count at exit
> fs/jbd/transaction.c:484:9: warning: context imbalance in 'journal_unlock_updates' - unexpected unlock
> fs/proc/base.c:2313:9: warning: context imbalance in 'proc_pid_attr_write' - unexpected unlock
> fs/proc/proc_tty.c:107:13: warning: context imbalance in 't_start' - wrong count at exit
> fs/proc/proc_tty.c:118:13: warning: context imbalance in 't_stop' - unexpected unlock
> fs/sysfs/dir.c:350:6: warning: context imbalance in 'sysfs_addrm_start' - wrong count at exit
> fs/sysfs/dir.c:504:6: warning: context imbalance in 'sysfs_addrm_finish' - unexpected unlock
> arch/x86/include/asm/current.h:14:16: warning: context imbalance in 'ata_eh_acquire' - wrong count at exit
> drivers/ata/libata-eh.c:495:9: warning: context imbalance in 'ata_eh_release' - unexpected unlock
> drivers/base/bus.c:181:17: warning: context imbalance in 'driver_unbind' - different lock contexts for basic block
> drivers/base/bus.c:211:17: warning: context imbalance in 'driver_bind' - different lock contexts for basic block
> drivers/base/bus.c:731:9: warning: context imbalance in 'bus_rescan_devices_helper' - different lock contexts for basic block
> drivers/base/bus.c:766:9: warning: context imbalance in 'device_reprobe' - different lock contexts for basic block
> drivers/base/dd.c:265:12: warning: context imbalance in '__driver_attach' - different lock contexts for basic block
> drivers/base/dd.c:395:17: warning: context imbalance in 'driver_detach' - different lock contexts for basic block
> drivers/base/power/main.c:73:6: warning: context imbalance in 'device_pm_lock' - wrong count at exit
> drivers/base/power/main.c:81:6: warning: context imbalance in 'device_pm_unlock' - unexpected unlock
> drivers/block/loop.c:1064:9: warning: context imbalance in 'loop_clr_fd' - unexpected unlock
> drivers/block/loop.c:1352:9: warning: context imbalance in 'lo_ioctl' - different lock contexts for basic block
> drivers/block/loop.c:1553:9: warning: context imbalance in 'lo_release' - different lock contexts for basic block
> drivers/char/tty_io.c:960:6: warning: context imbalance in 'tty_write_unlock' - unexpected unlock
> drivers/char/tty_io.c:966:5: warning: context imbalance in 'tty_write_lock' - wrong count at exit
> drivers/char/tty_io.c:1077:6: warning: context imbalance in 'tty_write_message' - wrong count at exit
> drivers/char/tty_mutex.c:31:9: warning: context imbalance in 'tty_lock' - wrong count at exit
> drivers/char/tty_mutex.c:42:9: warning: context imbalance in 'tty_unlock' - unexpected unlock
> drivers/char/misc.c:66:13: warning: context imbalance in 'misc_seq_start' - wrong count at exit
> drivers/char/misc.c:77:13: warning: context imbalance in 'misc_seq_stop' - unexpected unlock
> drivers/cpuidle/cpuidle.c:138:6: warning: context imbalance in 'cpuidle_pause_and_lock' - wrong count at exit
> drivers/cpuidle/cpuidle.c:149:6: warning: context imbalance in 'cpuidle_resume_and_unlock' - unexpected unlock
> drivers/gpu/drm/drm_pci.c:215:9: warning: context imbalance in 'drm_get_pci_dev' - unexpected unlock
> drivers/gpu/drm/i915/i915_debugfs.c:202:9: warning: context imbalance in 'i915_gem_object_info' - unexpected unlock
> drivers/gpu/drm/i915/i915_debugfs.c:827:9: warning: context imbalance in 'i915_emon_status' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:144:12: warning: context imbalance in 'i915_mutex_lock_interruptible' - different lock contexts for basic block
> drivers/gpu/drm/i915/i915_gem.c:417:9: warning: context imbalance in 'i915_gem_shmem_pread_fast' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:554:9: warning: context imbalance in 'i915_gem_shmem_pread_slow' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:706:17: warning: context imbalance in 'i915_gem_gtt_pwrite_fast' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:847:9: warning: context imbalance in 'i915_gem_gtt_pwrite_slow' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:918:9: warning: context imbalance in 'i915_gem_shmem_pwrite_fast' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1032:9: warning: context imbalance in 'i915_gem_shmem_pwrite_slow' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1184:35: warning: context imbalance in 'i915_gem_set_domain_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1217:35: warning: context imbalance in 'i915_gem_sw_finish_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:1529:43: warning: context imbalance in 'i915_gem_mmap_gtt_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:3770:17: warning: context imbalance in 'i915_gem_do_execbuffer' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4248:43: warning: context imbalance in 'i915_gem_pin_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4310:43: warning: context imbalance in 'i915_gem_unpin_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4375:35: warning: context imbalance in 'i915_gem_busy_ioctl' - unexpected unlock
> drivers/gpu/drm/i915/i915_gem.c:4419:43: warning: context imbalance in 'i915_gem_madvise_ioctl' - unexpected unlock
> drivers/hid/usbhid/hid-core.c:127:47: warning: context imbalance in 'hid_reset' - unexpected unlock
> drivers/input/input.c:1021:13: warning: context imbalance in 'input_devices_seq_start' - different lock contexts for basic block
> drivers/input/input.c:1050:17: warning: context imbalance in 'input_seq_stop' - unexpected unlock
> drivers/input/input.c:1143:13: warning: context imbalance in 'input_handlers_seq_start' - different lock contexts for basic block
> drivers/input/mouse/psmouse-base.c:1534:9: warning: context imbalance in 'psmouse_attr_set_helper' - unexpected unlock
> drivers/input/serio/i8042.c:129:6: warning: context imbalance in 'i8042_lock_chip' - wrong count at exit
> drivers/input/serio/i8042.c:135:6: warning: context imbalance in 'i8042_unlock_chip' - unexpected unlock
> drivers/input/serio/libps2.c:62:9: warning: context imbalance in 'ps2_begin_command' - wrong count at exit
> drivers/input/serio/libps2.c:72:9: warning: context imbalance in 'ps2_end_command' - unexpected unlock
> drivers/md/dm.c:2088:6: warning: context imbalance in 'dm_lock_md_type' - wrong count at exit
> drivers/md/dm.c:2093:6: warning: context imbalance in 'dm_unlock_md_type' - unexpected unlock
> drivers/md/md.c:578:17: warning: context imbalance in 'mddev_unlock' - unexpected unlock
> drivers/md/md.c:546:19: warning: context imbalance in 'rdev_size_store' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'rdev_attr_show' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'rdev_attr_store' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_attr_show' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_attr_store' - different lock contexts for basic block
> drivers/md/md.c:4871:17: warning: context imbalance in 'autorun_devices' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_ioctl' - different lock contexts for basic block
> drivers/md/md.c:5911:9: warning: context imbalance in 'md_open' - different lock contexts for basic block
> drivers/md/md.c:546:19: warning: context imbalance in 'md_seq_show' - different lock contexts for basic block
> drivers/md/md.c:6985:6: warning: context imbalance in 'md_check_recovery' - different lock contexts for basic block
> drivers/md/md.c:7180:17: warning: context imbalance in 'md_notify_reboot' - different lock contexts for basic block
> drivers/pci/pci.c:2494:30: warning: context imbalance in 'pci_dev_reset' - unexpected unlock
> drivers/pcmcia/rsrc_nonstatic.c:281:17: warning: context imbalance in 'readable' - unexpected unlock
> drivers/serial/serial_core.c:1546:26: warning: context imbalance in 'uart_get' - different lock contexts for basic block
> drivers/serial/serial_core.c:1632:17: warning: context imbalance in 'uart_open' - unexpected unlock
> drivers/thermal/thermal_sys.c:74:9: warning: context imbalance in 'get_idr' - different lock contexts for basic block
> drivers/thermal/thermal_sys.c:88:9: warning: context imbalance in 'release_idr' - different lock contexts for basic block
> drivers/usb/class/usblp.c:842:9: warning: context imbalance in 'usblp_read' - unexpected unlock
> arch/x86/include/asm/current.h:14:16: warning: context imbalance in 'usblp_rwait_and_lock' - different lock contexts for basic block
> drivers/usb/core/usb.c:561:5: warning: context imbalance in 'usb_lock_device_for_reset' - different lock contexts for basic block
> drivers/usb/core/message.c:1605:17: warning: context imbalance in '__usb_queue_reset_device' - unexpected unlock
> drivers/usb/storage/transport.c:1315:17: warning: context imbalance in 'usb_stor_port_reset' - unexpected unlock
> drivers/usb/storage/usb.c:191:5: warning: context imbalance in 'usb_stor_pre_reset' - wrong count at exit
> drivers/usb/storage/usb.c:203:5: warning: context imbalance in 'usb_stor_post_reset' - unexpected unlock
> drivers/video/fbmem.c:48:5: warning: context imbalance in 'lock_fb_info' - wrong count at exit
> drivers/video/fbmem.c:1047:17: warning: context imbalance in 'do_fb_ioctl' - unexpected unlock
> drivers/video/fbmem.c:1608:9: warning: context imbalance in 'register_framebuffer' - unexpected unlock
> drivers/video/fbmem.c:1646:9: warning: context imbalance in 'unregister_framebuffer' - unexpected unlock
> drivers/video/fbmem.c:1696:23: warning: context imbalance in 'fb_set_suspend' - unexpected unlock
> drivers/video/fbmem.c:1768:17: warning: context imbalance in 'fb_new_modelist' - unexpected unlock
> drivers/video/fbcmap.c:276:23: warning: context imbalance in 'fb_set_user_cmap' - unexpected unlock
> drivers/video/console/fbcon.c:2299:9: warning: context imbalance in 'fbcon_generic_blank' - unexpected unlock
> sound/core/sound.c:124:25: warning: context imbalance in 'autoload_device' - unexpected unlock
> net/netfilter/core.c:40:9: warning: context imbalance in 'nf_register_afinfo' - unexpected unlock
> net/netfilter/core.c:71:21: warning: context imbalance in 'nf_register_hook' - unexpected unlock
> net/netfilter/nf_log.c:132:13: warning: context imbalance in 'seq_start' - wrong count at exit
> net/netfilter/nf_log.c:152:13: warning: context imbalance in 'seq_stop' - unexpected unlock
> net/netfilter/x_tables.c:710:17: warning: context imbalance in 'xt_find_table_lock' - different lock contexts for basic block
> net/netfilter/x_tables.c:726:6: warning: context imbalance in 'xt_table_unlock' - unexpected unlock
> net/netfilter/x_tables.c:733:6: warning: context imbalance in 'xt_compat_lock' - wrong count at exit
> net/netfilter/x_tables.c:739:6: warning: context imbalance in 'xt_compat_unlock' - unexpected unlock
> net/netfilter/x_tables.c:876:9: warning: context imbalance in 'xt_register_table' - unexpected unlock
> net/netfilter/x_tables.c:903:13: warning: context imbalance in 'xt_table_seq_start' - wrong count at exit
> net/netfilter/x_tables.c:922:13: warning: context imbalance in 'xt_table_seq_stop' - unexpected unlock
> net/netfilter/x_tables.c:985:13: warning: context imbalance in 'xt_mttg_seq_next' - wrong count at exit
> net/netfilter/x_tables.c:1044:17: warning: context imbalance in 'xt_mttg_seq_stop' - unexpected unlock
> net/netlink/genetlink.c:24:6: warning: context imbalance in 'genl_lock' - wrong count at exit
> net/netlink/genetlink.c:30:6: warning: context imbalance in 'genl_unlock' - unexpected unlock
> net/unix/af_unix.c:919:9: warning: context imbalance in 'unix_bind' - different lock contexts for basic block
> net/wireless/core.c:150:9: warning: context imbalance in 'cfg80211_get_dev_from_info' - different lock contexts for basic block
> net/wireless/core.c:172:9: warning: context imbalance in 'cfg80211_get_dev_from_ifindex' - wrong count at exit
> net/wireless/core.h:191:9: warning: context imbalance in 'cfg80211_wext_siwscan' - unexpected unlock
> net/wireless/core.h:191:9: warning: context imbalance in 'cfg80211_wext_giwscan' - unexpected unlock
> net/wireless/core.h:191:9: warning: context imbalance in 'nl80211_finish_netdev_dump' - unexpected unlock
> net/wireless/nl80211.c:901:12: warning: context imbalance in 'nl80211_set_wiphy' - different lock contexts for basic block
> net/wireless/core.h:191:9: warning: context imbalance in 'nl80211_pre_doit' - unexpected unlock
> net/wireless/core.h:191:9: warning: context imbalance in 'nl80211_post_doit' - unexpected unlock

And this is the patch I used for testing. There may still be some flaws in it,
but it seems to do the trick.

Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/mutex.h b/include/linux/mutex.h
index f363bc8..d4940af 100644
--- a/include/linux/mutex.h
+++ b/include/linux/mutex.h
@@ -14,6 +14,7 @@
 #include <linux/spinlock_types.h>
 #include <linux/linkage.h>
 #include <linux/lockdep.h>
+#include <linux/compiler.h>
 
 #include <asm/atomic.h>
 
@@ -131,20 +132,35 @@ static inline int mutex_is_locked(struct mutex *lock)
  * Also see Documentation/mutex-design.txt.
  */
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
-extern void mutex_lock_nested(struct mutex *lock, unsigned int subclass);
-extern int __must_check mutex_lock_interruptible_nested(struct mutex *lock,
-					unsigned int subclass);
-extern int __must_check mutex_lock_killable_nested(struct mutex *lock,
-					unsigned int subclass);
-
+extern void mutex_lock_nested(struct mutex *lock, unsigned int subclass)
+				__acquires(lock);
+extern int __must_check __mutex_lock_interruptible_nested(struct mutex *lock,
+						unsigned int subclass);
+extern int __must_check __mutex_lock_killable_nested(struct mutex *lock,
+						unsigned int subclass);
+#define mutex_lock_interruptible_nested(lock, subclass)	({		\
+   int __mutex_ret = __mutex_lock_interruptible_nested(lock, subclass);	\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
+#define mutex_lock_killable_nested(lock, subclass)	({		\
+   int __mutex_ret = __mutex_lock_killable_nested(lock, subclass);	\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
 #define mutex_lock(lock) mutex_lock_nested(lock, 0)
 #define mutex_lock_interruptible(lock) mutex_lock_interruptible_nested(lock, 0)
 #define mutex_lock_killable(lock) mutex_lock_killable_nested(lock, 0)
 #else
-extern void mutex_lock(struct mutex *lock);
-extern int __must_check mutex_lock_interruptible(struct mutex *lock);
-extern int __must_check mutex_lock_killable(struct mutex *lock);
-
+extern void mutex_lock(struct mutex *lock) __acquires(lock);
+extern int __must_check __mutex_lock_interruptible(struct mutex *lock);
+extern int __must_check __mutex_lock_killable(struct mutex *lock);
+#define mutex_lock_interruptible(lock)	({				\
+   int __mutex_ret = __mutex_lock_interruptible(lock);			\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
+#define mutex_lock_killable(lock)	({				\
+   int __mutex_ret = __mutex_lock_killable(lock);			\
+   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
 # define mutex_lock_nested(lock, subclass) mutex_lock(lock)
 # define mutex_lock_interruptible_nested(lock, subclass) mutex_lock_interruptible(lock)
 # define mutex_lock_killable_nested(lock, subclass) mutex_lock_killable(lock)
@@ -156,8 +172,16 @@ extern int __must_check mutex_lock_killable(struct mutex *lock);
  *
  * Returns 1 if the mutex has been acquired successfully, and 0 on contention.
  */
-extern int mutex_trylock(struct mutex *lock);
-extern void mutex_unlock(struct mutex *lock);
-extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
+extern int __mutex_trylock(struct mutex *lock);
+#define mutex_trylock(lock)	({					\
+   int __mutex_ret = __mutex_trylock(lock);				\
+   if (__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
+extern void mutex_unlock(struct mutex *lock) __releases(lock);
+extern int __atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
+#define atomic_dec_and_mutex_lock(cnt, lock)	({			\
+   int __mutex_ret = __atomic_dec_and_mutex_lock(cnt, lock);		\
+   if (__mutex_ret) __acquire(lock); __mutex_ret; 			\
+})
 
 #endif
diff --git a/kernel/mutex.c b/kernel/mutex.c
index 200407c..09b70b7 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -282,22 +282,22 @@ mutex_lock_nested(struct mutex *lock, unsigned int subclass)
 EXPORT_SYMBOL_GPL(mutex_lock_nested);
 
 int __sched
-mutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)
+__mutex_lock_killable_nested(struct mutex *lock, unsigned int subclass)
 {
 	might_sleep();
 	return __mutex_lock_common(lock, TASK_KILLABLE, subclass, _RET_IP_);
 }
-EXPORT_SYMBOL_GPL(mutex_lock_killable_nested);
+EXPORT_SYMBOL_GPL(__mutex_lock_killable_nested);
 
 int __sched
-mutex_lock_interruptible_nested(struct mutex *lock, unsigned int subclass)
+__mutex_lock_interruptible_nested(struct mutex *lock, unsigned int subclass)
 {
 	might_sleep();
 	return __mutex_lock_common(lock, TASK_INTERRUPTIBLE,
 				   subclass, _RET_IP_);
 }
 
-EXPORT_SYMBOL_GPL(mutex_lock_interruptible_nested);
+EXPORT_SYMBOL_GPL(__mutex_lock_interruptible_nested);
 #endif
 
 /*
@@ -366,7 +366,7 @@ __mutex_lock_interruptible_slowpath(atomic_t *lock_count);
  *
  * This function is similar to (but not equivalent to) down_interruptible().
  */
-int __sched mutex_lock_interruptible(struct mutex *lock)
+int __sched __mutex_lock_interruptible(struct mutex *lock)
 {
 	int ret;
 
@@ -379,9 +379,9 @@ int __sched mutex_lock_interruptible(struct mutex *lock)
 	return ret;
 }
 
-EXPORT_SYMBOL(mutex_lock_interruptible);
+EXPORT_SYMBOL(__mutex_lock_interruptible);
 
-int __sched mutex_lock_killable(struct mutex *lock)
+int __sched __mutex_lock_killable(struct mutex *lock)
 {
 	int ret;
 
@@ -393,7 +393,7 @@ int __sched mutex_lock_killable(struct mutex *lock)
 
 	return ret;
 }
-EXPORT_SYMBOL(mutex_lock_killable);
+EXPORT_SYMBOL(__mutex_lock_killable);
 
 static __used noinline void __sched
 __mutex_lock_slowpath(atomic_t *lock_count)
@@ -461,7 +461,7 @@ static inline int __mutex_trylock_slowpath(atomic_t *lock_count)
  * This function must not be used in interrupt context. The
  * mutex must be released by the same task that acquired it.
  */
-int __sched mutex_trylock(struct mutex *lock)
+int __sched __mutex_trylock(struct mutex *lock)
 {
 	int ret;
 
@@ -471,7 +471,7 @@ int __sched mutex_trylock(struct mutex *lock)
 
 	return ret;
 }
-EXPORT_SYMBOL(mutex_trylock);
+EXPORT_SYMBOL(__mutex_trylock);
 
 /**
  * atomic_dec_and_mutex_lock - return holding mutex if we dec to 0
@@ -480,7 +480,7 @@ EXPORT_SYMBOL(mutex_trylock);
  *
  * return true and hold lock if we dec to 0, return false otherwise
  */
-int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
+int __atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
 {
 	/* dec if we can't possibly hit 0 */
 	if (atomic_add_unless(cnt, -1, 1))
@@ -495,4 +495,4 @@ int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
 	/* we hit 0, and we hold the lock */
 	return 1;
 }
-EXPORT_SYMBOL(atomic_dec_and_mutex_lock);
+EXPORT_SYMBOL(__atomic_dec_and_mutex_lock);
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Mon, 11 Oct 2010 22:23:08 +0000
Message-ID: <20101011222307.GA10570 () feather>
--------------------
On Mon, Oct 11, 2010 at 10:42:18PM +0200, Arnd Bergmann wrote:
> On Monday 11 October 2010 20:54:56 Josh Triplett wrote:
> > On Mon, Oct 11, 2010 at 12:52:06PM +0200, Johannes Berg wrote:
> >
> > > I don't know. Could be related to trylock issues, could be just historic
> > > since semaphores can't really be annotated, or could be something else
> > > entirely... I would expect a huge amount of warnings from sparse though
> > > if you "just" annotate them since there are things like rtnl_lock()
> > > which would have to propagate context.
> > 
> > As far as I know, no reason exists to not just annotate mutexes; I think
> > mutexes just came along later and nobody happened to add the appropriate
> > annotations.  (Also, sparse does handle trylock.)
> > 
> > But yes, annotating mutexes will then introduce a giant pile of lock
> > warnings that need further annotation propagation.  It will also
> > introduce lock warnings that represent actual bugs, making it important
> > to not just blindly propagate annotations to make warnings go away.
> 
> I've given it a try, wrapping the trylock/interruptible/killable variants
> into macros and the number of additional warnings was much less than
> I had feared. This is the diff for today's sparse with today's linux-next
> x86_64_defconfig:
> 
[...snip...]
> 
> And this is the patch I used for testing. There may still be some flaws in it,
> but it seems to do the trick.
> 
> Signed-off-by: Arnd Bergmann <arnd@arndb.de>

Thanks!

One minor suggetsion below to simplify the patch; with that added,
Reviewed-by: Josh Triplett <josh@joshtriplett.org>

> diff --git a/include/linux/mutex.h b/include/linux/mutex.h
> index f363bc8..d4940af 100644
> --- a/include/linux/mutex.h
> +++ b/include/linux/mutex.h
> @@ -14,6 +14,7 @@
>  #include <linux/spinlock_types.h>
>  #include <linux/linkage.h>
>  #include <linux/lockdep.h>
> +#include <linux/compiler.h>
>  
>  #include <asm/atomic.h>
>  
> @@ -131,20 +132,35 @@ static inline int mutex_is_locked(struct mutex *lock)
>   * Also see Documentation/mutex-design.txt.
>   */
>  #ifdef CONFIG_DEBUG_LOCK_ALLOC
> -extern void mutex_lock_nested(struct mutex *lock, unsigned int subclass);
> -extern int __must_check mutex_lock_interruptible_nested(struct mutex *lock,
> -					unsigned int subclass);
> -extern int __must_check mutex_lock_killable_nested(struct mutex *lock,
> -					unsigned int subclass);
> -
> +extern void mutex_lock_nested(struct mutex *lock, unsigned int subclass)
> +				__acquires(lock);
> +extern int __must_check __mutex_lock_interruptible_nested(struct mutex *lock,
> +						unsigned int subclass);
> +extern int __must_check __mutex_lock_killable_nested(struct mutex *lock,
> +						unsigned int subclass);
> +#define mutex_lock_interruptible_nested(lock, subclass)	({		\
> +   int __mutex_ret = __mutex_lock_interruptible_nested(lock, subclass);	\
> +   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
> +})
> +#define mutex_lock_killable_nested(lock, subclass)	({		\
> +   int __mutex_ret = __mutex_lock_killable_nested(lock, subclass);	\
> +   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
> +})

Assuming that the underlying function only returns zero/non-zero and
that the actual return value doesn't matter, then you can use the
__cond_lock macro from compiler.h for this:

# define __cond_lock(x,c)       ((c) ? ({ __acquire(x); 1; }) : 0)

>  #define mutex_lock(lock) mutex_lock_nested(lock, 0)
>  #define mutex_lock_interruptible(lock) mutex_lock_interruptible_nested(lock, 0)
>  #define mutex_lock_killable(lock) mutex_lock_killable_nested(lock, 0)
>  #else
> -extern void mutex_lock(struct mutex *lock);
> -extern int __must_check mutex_lock_interruptible(struct mutex *lock);
> -extern int __must_check mutex_lock_killable(struct mutex *lock);
> -
> +extern void mutex_lock(struct mutex *lock) __acquires(lock);
> +extern int __must_check __mutex_lock_interruptible(struct mutex *lock);
> +extern int __must_check __mutex_lock_killable(struct mutex *lock);
> +#define mutex_lock_interruptible(lock)	({				\
> +   int __mutex_ret = __mutex_lock_interruptible(lock);			\
> +   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
> +})
> +#define mutex_lock_killable(lock)	({				\
> +   int __mutex_ret = __mutex_lock_killable(lock);			\
> +   if (!__mutex_ret) __acquire(lock); __mutex_ret; 			\
> +})

Same here.

>  # define mutex_lock_nested(lock, subclass) mutex_lock(lock)
>  # define mutex_lock_interruptible_nested(lock, subclass) mutex_lock_interruptible(lock)
>  # define mutex_lock_killable_nested(lock, subclass) mutex_lock_killable(lock)
> @@ -156,8 +172,16 @@ extern int __must_check mutex_lock_killable(struct mutex *lock);
>   *
>   * Returns 1 if the mutex has been acquired successfully, and 0 on contention.
>   */
> -extern int mutex_trylock(struct mutex *lock);
> -extern void mutex_unlock(struct mutex *lock);
> -extern int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
> +extern int __mutex_trylock(struct mutex *lock);
> +#define mutex_trylock(lock)	({					\
> +   int __mutex_ret = __mutex_trylock(lock);				\
> +   if (__mutex_ret) __acquire(lock); __mutex_ret; 			\
> +})
> +extern void mutex_unlock(struct mutex *lock) __releases(lock);
> +extern int __atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);
> +#define atomic_dec_and_mutex_lock(cnt, lock)	({			\
> +   int __mutex_ret = __atomic_dec_and_mutex_lock(cnt, lock);		\
> +   if (__mutex_ret) __acquire(lock); __mutex_ret; 			\
> +})

And here.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnd Bergmann <arnd () arndb ! de>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Tue, 12 Oct 2010 06:39:14 +0000
Message-ID: <201010120839.15257.arnd () arndb ! de>
--------------------
On Tuesday 12 October 2010 00:23:08 Josh Triplett wrote:
> Assuming that the underlying function only returns zero/non-zero and
> that the actual return value doesn't matter, then you can use the
> __cond_lock macro from compiler.h for this:
> 
> # define __cond_lock(x,c)       ((c) ? ({ __acquire(x); 1; }) : 0)
> 

The return from mutex_lock_{killable,interruptible} is an error
value, not true/false, so it actually matters. We know that the only
possible error that is currently returned is -EINTR though, so we
could do a similar trick and define another

#define __cond_mutex(x, c)	((!c) ? ({ __acquire(x); 0; }) : -EINTR)

My fear was that this would impact code generation.

	Arnd
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnd Bergmann <arnd () arndb ! de>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Tue, 12 Oct 2010 06:39:14 +0000
Message-ID: <201010120839.15257.arnd () arndb ! de>
--------------------
On Tuesday 12 October 2010 00:23:08 Josh Triplett wrote:
> Assuming that the underlying function only returns zero/non-zero and
> that the actual return value doesn't matter, then you can use the
> __cond_lock macro from compiler.h for this:
> 
> # define __cond_lock(x,c)       ((c) ? ({ __acquire(x); 1; }) : 0)
> 

The return from mutex_lock_{killable,interruptible} is an error
value, not true/false, so it actually matters. We know that the only
possible error that is currently returned is -EINTR though, so we
could do a similar trick and define another

#define __cond_mutex(x, c)	((!c) ? ({ __acquire(x); 0; }) : -EINTR)

My fear was that this would impact code generation.

	Arnd
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: kernel-janitors
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Tue, 12 Oct 2010 06:43:26 +0000
Message-ID: <20101012064326.GB1702 () feather>
--------------------
On Tue, Oct 12, 2010 at 08:39:14AM +0200, Arnd Bergmann wrote:
> On Tuesday 12 October 2010 00:23:08 Josh Triplett wrote:
> > Assuming that the underlying function only returns zero/non-zero and
> > that the actual return value doesn't matter, then you can use the
> > __cond_lock macro from compiler.h for this:
> > 
> > # define __cond_lock(x,c)       ((c) ? ({ __acquire(x); 1; }) : 0)
> > 
> 
> The return from mutex_lock_{killable,interruptible} is an error
> value, not true/false, so it actually matters. We know that the only
> possible error that is currently returned is -EINTR though, so we
> could do a similar trick and define another
> 
> #define __cond_mutex(x, c)	((!c) ? ({ __acquire(x); 0; }) : -EINTR)
> 
> My fear was that this would impact code generation.

If __cond_lock doesn't fit, then you could just define a generic wrapper
to capture the pattern of preserving a function's return value, and use
that for all the mutex calls.  And if you just preserve the return
value, and __acquire compiles to nothing for GCC, then GCC should just
optimize away the extra copy into a local variable.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe kernel-janitors" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [patch 1/2] OSS: soundcard: locking bug in sound_ioctl()
Date: Tue, 12 Oct 2010 06:43:26 +0000
Message-ID: <20101012064326.GB1702 () feather>
--------------------
On Tue, Oct 12, 2010 at 08:39:14AM +0200, Arnd Bergmann wrote:
> On Tuesday 12 October 2010 00:23:08 Josh Triplett wrote:
> > Assuming that the underlying function only returns zero/non-zero and
> > that the actual return value doesn't matter, then you can use the
> > __cond_lock macro from compiler.h for this:
> > 
> > # define __cond_lock(x,c)       ((c) ? ({ __acquire(x); 1; }) : 0)
> > 
> 
> The return from mutex_lock_{killable,interruptible} is an error
> value, not true/false, so it actually matters. We know that the only
> possible error that is currently returned is -EINTR though, so we
> could do a similar trick and define another
> 
> #define __cond_mutex(x, c)	((!c) ? ({ __acquire(x); 0; }) : -EINTR)
> 
> My fear was that this would impact code generation.

If __cond_lock doesn't fit, then you could just define a generic wrapper
to capture the pattern of preserving a function's return value, and use
that for all the mutex calls.  And if you just preserve the return
value, and __acquire compiles to nothing for GCC, then GCC should just
optimize away the extra copy into a local variable.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: b2b marketing lists ===

From: "Alton N Christopher" <jane () base ! ecco-tumen ! ru>
To: linux-sparse
Subject: b2b marketing lists
Date: Mon, 24 May 2010 22:14:18 +0000
Message-ID: <BASEphqaa2RjASs38Cf000015cb () base ! ecco-tumen ! ru>
--------------------
Here's a couple of our healthcare list packages on sale this week only:

Package 1

Alternative Medicine - 1,141,602 total records with 36,320 emails and 38.935 fax numbers
Massage Therapists - 76,701 records and 8,305 emails
Physical Therapists - 125,460 total records with 5,483 emails and 4,405 fax numbers

All complete lists above: $277

Package 2

Chiropractors - 108,421 total records * 3,414 emails * 6,553 fax numbers
Acupuncturists - 23,988 records 1,826 emails
Massage Therapists - 76,701 records and 8,305 emails

All complete lists above: $247

There are more packages and not just for healthcare contact me here for more info or to get samples: Brendan.Irving@inspiresuccess.in

  


to subtract your address from our databa#se look here please email disappear@inspiresuccess.in 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: bad asm goto ? ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: bad asm goto ?
Date: Mon, 25 Oct 2010 21:31:45 +0000
Message-ID: <20101025213145.GA1822 () redhat ! com>
--------------------
I just ran sparse on a kernel tree for the first time in ages, and got
hundreds of warnings, many of which related to the tracepoint macros
in the kernel, which use the new asm goto feature.

Looking at the git log of sparse, I see there was some support added
for asm goto, but it seems to choke every time, printing ..

include/trace/events/kmem.h:45:1: error: bad asm output
include/trace/events/kmem.h:45:1: error: incompatible types in comparison expression (different address spaces)


(this is with a sparse built from git head from a few minutes ago)

	Dave

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: bad asm goto ?
Date: Mon, 25 Oct 2010 22:10:29 +0000
Message-ID: <AANLkTikVt5BJ+2W3P+wYUR3DLzhTatXhAW45wdc0eoOe () mail ! gmail ! com>
--------------------
On Mon, Oct 25, 2010 at 2:31 PM, Dave Jones <davej@redhat.com> wrote:
> I just ran sparse on a kernel tree for the first time in ages, and got
> hundreds of warnings, many of which related to the tracepoint macros
> in the kernel, which use the new asm goto feature.
>
> Looking at the git log of sparse, I see there was some support added
> for asm goto, but it seems to choke every time, printing ..
>
> include/trace/events/kmem.h:45:1: error: bad asm output
> include/trace/events/kmem.h:45:1: error: incompatible types in comparison expression (different address spaces)
>
>
> (this is with a sparse built from git head from a few minutes ago)

Do you have a smaller test case to reproduce the error?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: bad asm goto ?
Date: Mon, 25 Oct 2010 23:44:32 +0000
Message-ID: <AANLkTi=r6U3CVS5Br5ZTVVyNEfKzhqTcKkEk5+itwNe1 () mail ! gmail ! com>
--------------------
On Mon, Oct 25, 2010 at 3:39 PM, Dave Jones <davej@redhat.com> wrote:
> I tried unwinding some of the nested macros, and came up with ..
>
> # define __ASM_FORM(x)  " " #x " "
> # define JUMP_LABEL_INITIAL_NOP ".byte 0xe9 \n\t .long 0\n\t"
> # define __ASM_SEL(a,b) __ASM_FORM(b)
> #define _ASM_PTR        __ASM_SEL(.long, .quad)
>
> # define JUMP_LABEL(key, label)                                 \
>        do {                                                    \
>                asm goto("1:"                                   \
>                        JUMP_LABEL_INITIAL_NOP                  \
>                        ".pushsection __jump_table,  \"a\" \n\t"\
>                        _ASM_PTR "1b, %l[" #label "], %c0 \n\t" \
>                        ".popsection \n\t"                      \
>                        : :  "i" (key) :  : label);             \
>        } while (0)
>
> int main(int argc, char *argv[])
> {
>        JUMP_LABEL("1", do_trace );
>        return 1;
> do_trace:
>        return 0;
> }
>

Thanks, I got this example working for me too. You are right, sparse is
choking on it. Let me take a look tonight.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: bad asm goto ?
Date: Thu, 28 Oct 2010 02:45:31 +0000
Message-ID: <AANLkTim6DeB4BAxQv87-mjLjabGrHKY1z+roEuHDznbF () mail ! gmail ! com>
--------------------
On Mon, Oct 25, 2010 at 8:10 PM, Christopher Li <sparse@chrisli.org> wrote:
> It seems that the error is not from the goto. It is from the malformed
> asm_clobber.
> For empty asm_clobber list, sparse currently add nil expr into the
> list. Evaluate will
> complain about the nil pointer thinking it has a bad type.
>
> Any way, this patch should fix it.
>
> Please let me know that help you or not. I am going to apply it after
> the 0.4.3 release.
>

I'm afraid this didn't solve it for me when applying on top of v0.4.3,
if you have any other patches to try,
I'd be glad to test them out.

Harvey
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: bad asm goto ?
Date: Thu, 28 Oct 2010 06:33:52 +0000
Message-ID: <AANLkTi=8arp9k3Y-Jo6bkmGKUp60h7rZYRzQhpiHF-mT () mail ! gmail ! com>
--------------------
On Wed, Oct 27, 2010 at 11:12 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Wed, Oct 27, 2010 at 7:45 PM, Harvey Harrison
> <harvey.harrison@gmail.com> wrote:
> \>
>> I'm afraid this didn't solve it for me when applying on top of v0.4.3,
>> if you have any other patches to try,
>> I'd be glad to test them out.
>
> What is your test case? The patch does work for me on the small test
> case provide by
> Dave. I am just wondering if you are running the same thing.
> If not, please let me know what you run and what is the error message.
>

Sorry about that, just ran again and had a leftover binary elsewhere
in my path, your patch does fix
the error, all that's left is the:

include/trace/events/kmem.h:45:1: error: incompatible types in
comparison expression (different address spaces)

Sorry for the noise.

Harvey
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Harvey Harrison <harvey.harrison () gmail ! com>
To: linux-sparse
Subject: Re: bad asm goto ?
Date: Mon, 22 Aug 2011 04:01:27 +0000
Message-ID: <CAHLZz10y6-bxMRv=aJhza9EqT92gp=72f_w+7WopAL7GqPDP3A () mail ! gmail ! com>
--------------------
Ping, noticed you moving towards a 0.4.4 release and this was still not applied.

Harvey

On Mon, Oct 25, 2010 at 8:10 PM, Christopher Li <sparse@chrisli.org> wrote:
> It seems that the error is not from the goto. It is from the malformed
> asm_clobber.
> For empty asm_clobber list, sparse currently add nil expr into the
> list. Evaluate will
> complain about the nil pointer thinking it has a bad type.
>
> Any way, this patch should fix it.
>
> Please let me know that help you or not. I am going to apply it after
> the 0.4.3 release.
>
> Chris
>
> diff --git a/evaluate.c b/evaluate.c
> index f8343c2..1fb03ed 100644
> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -3221,7 +3221,7 @@ static void evaluate_asm_statement(struct statement *stmt)
>
> Â  Â  Â  Â FOR_EACH_PTR(stmt->asm_clobbers, expr) {
> Â  Â  Â  Â  Â  Â  Â  Â if (!expr) {
> - Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sparse_error(stmt->pos, "bad asm output");
> + Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sparse_error(stmt->pos, "bad asm clobbers");
> Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;
> Â  Â  Â  Â  Â  Â  Â  Â }
> Â  Â  Â  Â  Â  Â  Â  Â if (expr->type == EXPR_STRING)
> diff --git a/parse.c b/parse.c
> index 537055f..6b7d656 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -1894,7 +1894,8 @@ static struct token *parse_asm_clobbers(struct
> token *token, struct statement *s
>
> Â  Â  Â  Â do {
> Â  Â  Â  Â  Â  Â  Â  Â token = primary_expression(token->next, &expr);
> - Â  Â  Â  Â  Â  Â  Â  add_expression(clobbers, expr);
> + Â  Â  Â  Â  Â  Â  Â  if (expr)
> + Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  add_expression(clobbers, expr);
> Â  Â  Â  Â } while (match_op(token, ','));
> Â  Â  Â  Â return token;
> Â }
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at Â http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: bad asm goto ?
Date: Tue, 23 Aug 2011 21:55:58 +0000
Message-ID: <CANeU7QkFrvRMjAo4m11tEhi9QMVjqu_bnNEHMkzbh_zKSvzWmQ () mail ! gmail ! com>
--------------------
On Sun, Aug 21, 2011 at 9:01 PM, Harvey Harrison
<harvey.harrison@gmail.com> wrote:
> Ping, noticed you moving towards a 0.4.4 release and this was still not applied.

It falls through the cracks. I just add a test case and commit the fix.

Thanks for the reminder.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: building of call tree ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: building of call tree
Date: Fri, 02 Apr 2010 17:55:19 +0000
Message-ID: <y2v70318cbf1004021055i2aa4ec82h1d6b2f43a2af01d0 () mail ! gmail ! com>
--------------------
On Fri, Apr 2, 2010 at 9:16 AM, Sergey Lapin <slapinid@gmail.com> wrote:
> but I fail with scoping. I need to detect which function that
> particular reference belongs to,
> and how to detect if that reference is really a function.

What do you mean by "reference"? If you mean the struct symbol *
in the AST. It can point to the function prototype or declaration. It is easy to
find out the symbol is a function or not.

Some thing along the lines of :

if (sym->type == SYM_NODE)
    sym = sym->ctype.base_type
if (sym && sym->type = SYM_FN) {
    /* sym is a function */
}


> sym->type isn't what I need, sym->ctype.base_type is used to print base type,
> but I'd like to print type as is, and detect if that is a function a proper way.

You need understand that, each local variable or function start with a SYM_NODE.
SYM_NODE bind a type to a instance of the type. e.g. a variable.
A function is just a SYM_NODE with base type as SYM_FN.

You can also try debug_symbol(), see how it print out the function prototype.

I am about to post a AST inspection patch series. That tool should
help you understand
the AST as well. Stay tuned.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: enum warning patch (was Re: Defect in linearization of short ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: enum warning patch (was Re: Defect in linearization of short
Date: Tue, 16 Feb 2010 22:44:08 +0000
Message-ID: <70318cbf1002161444m6daa6a9dh7f30d347b4e9ebbb () mail ! gmail ! com>
--------------------
On Tue, Feb 16, 2010 at 12:18 PM, Kamil Dudka <kdudka@redhat.com> wrote:
> I've just remembered.  There was problem on a 32bit system - 32 bytes before
> and 36 bytes after the patch applied...

Yes, size is one of the aspect. I am more worry about putting the enum
information
at the wrong place.

It is about the enum type. It should store in the type system. The
expression is one
level above the type system, it contain a ctype there.

I am much happier if that enum information can be reach from the
expr->ctype some how,
which I haven't find out yet.

While you are here. I have a question for you.

Most simple enum declare has very small set of values. So naturally I
might want to use
some thing smaller than int type to store the enum value. I can't find
a good way to play
well with the enum warnings.

If I use "char type" to store it. It trigger warning when you assign to it.
If I use "enum foo_type type:8" to store it, it will use int type
alignment and padding which
defeat the purpose of using a smaller type.

Any suggestion?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: enum warning patch (was Re: Defect in linearization of short circuit &&) ===

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: enum warning patch (was Re: Defect in linearization of short circuit &&)
Date: Tue, 16 Feb 2010 20:18:28 +0000
Message-ID: <201002162118.28516.kdudka () redhat ! com>
--------------------
On Tuesday 16 of February 2010 21:11:31 Kamil Dudka wrote:
> It makes no sense to me - on my box I am getting the same
> sizeof(struct expression)==64 before/after the patch applied.

I've just remembered.  There was problem on a 32bit system - 32 bytes before 
and 36 bytes after the patch applied...

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Kamil Dudka <kdudka () redhat ! com>
To: linux-sparse
Subject: Re: enum warning patch (was Re: Defect in linearization of short circuit &&)
Date: Wed, 17 Feb 2010 14:00:26 +0000
Message-ID: <201002171500.27119.kdudka () redhat ! com>
--------------------
On Tue February 16 2010 23:44:08 Christopher Li wrote:
> Most simple enum declare has very small set of values. So naturally I
> might want to use
> some thing smaller than int type to store the enum value. I can't find
> a good way to play
> well with the enum warnings.
> 
> If I use "char type" to store it. It trigger warning when you assign to it.
> If I use "enum foo_type type:8" to store it, it will use int type
> alignment and padding which
> defeat the purpose of using a smaller type.
> 
> Any suggestion?

I don't think it's that easy to implement while keeping it enough generic.  
You need either a type able to store _any_ enum value, or a kind of type
with variable size to keep it still working.  The second seems like quite
a lot of fuss over 4 bytes of memory.

Kamil
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: help for using sparse ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: help for using sparse
Date: Wed, 09 Jun 2010 16:00:38 +0000
Message-ID: <AANLkTim1Gr-k3BZ-hsdPdZQ8j1QPCEeWycwFGdqKwbxj () mail ! gmail ! com>
--------------------
On Wed, Jun 9, 2010 at 8:09 AM, bonneta <bonneta@ensimag.fr> wrote:
> I've basically tried "sparse file.c", but it always returns with an error
> like :
> "git-compat-util.h:140:11: error: unable to open 'openssl/ssl.h'"
> or
> "builtin/blame.c:7:10: error: unable to open 'cache.h'"
>
> I don't know how to resolve it...

You need to tell sparse where is your openssl/ssl.h.

BTW, can you compile file.c using git's make system?
You can try to copy the file searching path to sparse.

Another thing to try is using the cgcc. Cgcc is a wrapper
script that try to behave like gcc + sparse check.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-sparse
Subject: Re: help for using sparse
Date: Wed, 09 Jun 2010 16:01:31 +0000
Message-ID: <20100609160131.GG5483 () bicker>
--------------------
On Wed, Jun 09, 2010 at 05:09:54PM +0200, bonneta wrote:
> I've basically tried "sparse file.c", but it always returns with an error
> like :
> "git-compat-util.h:140:11: error: unable to open 'openssl/ssl.h'"
> or
> "builtin/blame.c:7:10: error: unable to open 'cache.h'"
> 

make CC=~/path/to/sparse/cgcc 

regards,
dan carpenter
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: help for using sparse
Date: Wed, 09 Jun 2010 16:10:59 +0000
Message-ID: <20100609161058.GA4204 () feather>
--------------------
On Wed, Jun 09, 2010 at 05:09:54PM +0200, bonneta wrote:
> I am working on git, and i would like to apply sparse on its source code.
> 
> I've downloaded the source of sparse from its git repository, and compiled
> it successfully.
> 
> I've read the little documentation furnished with the code, but i didn't
> manage to apply sparse on the sources of git.
> 
> I've basically tried "sparse file.c", but it always returns with an error
> like :
> "git-compat-util.h:140:11: error: unable to open 'openssl/ssl.h'"
> or
> "builtin/blame.c:7:10: error: unable to open 'cache.h'"
> 
> I don't know how to resolve it...

These errors occur because you haven't supplied the full compiler
command-line that Git supplies in its build process, which includes
flags for include paths.

The script "cgcc", provided with sparse, provides the most convenient
way to integrate Sparse into an existing build system with minimal work.
Once you've done a "make install" of Sparse into a directory on your
$PATH (or just put the Sparse source directory on your $PATH), just do
"make CC=cgcc".

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: bonneta <bonneta () ensimag ! fr>
To: linux-sparse
Subject: Re: help for using sparse
Date: Wed, 09 Jun 2010 16:35:31 +0000
Message-ID: <6d9debf589b058363c8b89ea9248a811 () ensimag ! fr>
--------------------
On Wed, 9 Jun 2010 09:10:59 -0700, Josh Triplett <josh@joshtriplett.org>
wrote:
> On Wed, Jun 09, 2010 at 05:09:54PM +0200, bonneta wrote:
>> I am working on git, and i would like to apply sparse on its source
code.
>> 
>> I've downloaded the source of sparse from its git repository, and
>> compiled
>> it successfully.
>> 
>> I've read the little documentation furnished with the code, but i
didn't
>> manage to apply sparse on the sources of git.
>> 
>> I've basically tried "sparse file.c", but it always returns with an
error
>> like :
>> "git-compat-util.h:140:11: error: unable to open 'openssl/ssl.h'"
>> or
>> "builtin/blame.c:7:10: error: unable to open 'cache.h'"
>> 
>> I don't know how to resolve it...
> 
> These errors occur because you haven't supplied the full compiler
> command-line that Git supplies in its build process, which includes
> flags for include paths.
> 
> The script "cgcc", provided with sparse, provides the most convenient
> way to integrate Sparse into an existing build system with minimal work.
> Once you've done a "make install" of Sparse into a directory on your
> $PATH (or just put the Sparse source directory on your $PATH), just do
> "make CC=cgcc".

Thank you all, it works fine.
Does sparse look for all the errors with this method?

I saw in the sparse man page that a "Wsparse-all" option exists. 
Is it used by default? Otherwise how to use it in the "make" command line?

Axel Bonnet

> 
> - Josh Triplett
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse"
in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: help for using sparse
Date: Wed, 09 Jun 2010 18:48:11 +0000
Message-ID: <20100609184811.GA20200 () merkur ! ravnborg ! org>
--------------------
On Wed, Jun 09, 2010 at 05:09:54PM +0200, bonneta wrote:
> Hello,
> 
> I am working on git, and i would like to apply sparse on its source code.
> 
> I've downloaded the source of sparse from its git repository, and compiled
> it successfully.
> 
> I've read the little documentation furnished with the code, but i didn't
> manage to apply sparse on the sources of git.

It looks like git already supports sparse.

Try "make check"

Try to search for "sparse" in the makefile of git.

	Sam
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: hi ===

From: "Gabriel kante" <gabkante1 () gmail ! com>
To: linux-sparse
Subject: hi
Date: Sat, 06 Nov 2010 08:24:47 +0000
Message-ID: <7a051d23232d18854e35b4ec6962b9e4.squirrel () macmail ! unitelsd ! com>
--------------------
I write to seek your help in the retrieval sum funds from US Bank account
belonging to my late Dad.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: homeowner mailing lists ===

From: "Kristin 2 Foster" <mary () mail ! patranusa ! com>
To: linux-sparse
Subject: homeowner mailing lists
Date: Thu, 20 May 2010 03:57:28 +0000
Message-ID: <20100520035728.E09901C5300 () mail ! patranusa ! com>
--------------------
Here's a couple of our healthcare list packages on sale this week only:

Package 1

Physicians (34 specialties) - 788k records, 17k emails, 200k fax numbers
Hospitals - 23,747 Hospital Administrators in over 7,145 Hospitals (full contact info no emails)
Dentists - 164k records, 45k emails, 77k fax numbers
Chiropractors - 108,421 total records * 3,414 emails * 6,553 fax numbers
Pharmaceutical Companies - Email only list 47,000 emails of pharma company employees
Physical Therapists - 125,460 total records with 5,483 emails and 4,405 fax numbers

All complete lists above: $439

Package 2

Physicians (34 specialties) - 788k records, 17k emails, 200k fax numbers
Psychologists - 272,188 records and 9,874 emails
Mental Health Counselors - 283,184 records 7,206 emails


All complete lists above: $347

There are more packages and not just for healthcare contact me here for more info or to get samples: successtools@gmx.com

  


To invoke no further correspondence status please send an email to remfiles@gmx.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: including sparse headers in C++ code ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Mon, 11 Oct 2010 23:37:07 +0000
Message-ID: <20101011233706.GA10991 () feather>
--------------------
On Tue, Oct 12, 2010 at 12:33:32AM +0200, Tomas Klacko wrote:
> On Sat, Oct 9, 2010 at 11:46 PM, Christopher Li <sparse@chrisli.org> wrote:
> > On Sat, Oct 9, 2010 at 1:59 PM, Josh Triplett <josh@joshtriplett.org> wrote:
> >> It seems reasonable to avoid the use of C++ keywords in Sparse *headers*
> >> (though unnecessary in *source*). Â Looks like this will primarily cause
> >> pain due to "enum namespace" and the various places using it. Â Seems
> >> easy enough to change those all to "ns". Â "new" mostly seems to get used
> >> as a parameter name or local variable name; for the former we could omit
> >> it, and for the latter we could trivially call it something more
> >> specific like "newlist" or "newptr".
> >>
> >> So, I'd tend to guess "patches welcome" (again, for headers only, plus
> >> minimal corresponding source changes when required). Â I wouldn't
> >> anticipate other Sparse developers objecting strongly, but if they do
> >> your mail seems like the right way to find out. Â The various reasons
> >> given for *not* making the Linux kernel headers compatible don't seem to
> >> apply here, though.
> >
> > Well said. I don't expect sparse to compile in the C++ mode. Making
> > sparse header usable in C++ seems reasonable to me.
> 
> Great. I am posting my current status (as a patch) so that you can comment on it
> and that I can refine it further.

> --- a/c2xml.c
> +++ b/c2xml.c
> @@ -128,7 +128,7 @@ static void examine_modifiers(struct symbol *sym,
> xmlNodePtr node)
> 
>  	int i;
> 
> -	if (sym->namespace != NS_SYMBOL)
> +	if (sym->Namespace != NS_SYMBOL)

How about "ns"?

> --- a/compile-i386.c
> +++ b/compile-i386.c
> @@ -332,9 +332,9 @@ busy:
>  	return 1;
>  }
> 
> -static struct storage *get_reg(struct regclass *class)
> +static struct storage *get_reg(struct regclass *Class)

Just call it "regclass".

> --- a/evaluate.c
> +++ b/evaluate.c
> @@ -357,7 +357,7 @@ static inline int classify_type(struct symbol
> *type, struct symbol **base)
>  	return type_class[type->type];
>  }
> 
> -#define is_int(class) ((class & (TYPE_NUM | TYPE_FLOAT)) == TYPE_NUM)
> +#define is_int(Class) ((Class & (TYPE_NUM | TYPE_FLOAT)) == TYPE_NUM)

"c" or "cls"?

> --- a/expression.c
> +++ b/expression.c
> @@ -118,7 +118,7 @@ static struct token *parse_type(struct token
> *token, struct expression **tree)
>  	struct symbol *sym;
>  	*tree = alloc_expression(token->pos, EXPR_TYPE);
>  	(*tree)->flags = Int_const_expr; /* sic */
> -	token = typename(token, &sym, NULL);
> +	token = Typename(token, &sym, NULL);

"type_name"?

> --- a/lib.h
> +++ b/lib.h
> @@ -120,6 +120,10 @@ extern int Wdeclarationafterstatement;
>  extern int dbg_entry;
>  extern int dbg_dead;
> 
> +#ifdef __cplusplus
> +extern "C" {
> +#endif
> +

> @@ -162,33 +170,41 @@ static inline void free_instruction_list(struct
> instruction_list **head)
>  	free_ptr_list((struct ptr_list **)head);
>  }
> 
> -static inline struct instruction * delete_last_instruction(struct
> instruction_list **head)
> +static inline struct instruction * delete_last_instruction(
> +        struct instruction_list **head)

Huh?  I don't see a change here, just formatting (and what looks like
whitespace damage).

>  {
> -	return undo_ptr_list_last((struct ptr_list **)head);
> +	return (struct instruction *)undo_ptr_list_last(
> +                (struct ptr_list **)head);
>  }

Wow.  I had to double-check this because I couldn't quite believe C++
had that degree of dain bramage, but sure enough:

/tmp$ cat test.c
extern void *pv(void);

int *pi(void)
{
    return pv();
}
/tmp$ gcc -c test.c -o /dev/null
/tmp$ g++ -c test.c -o /dev/null
test.c: In function âint* pi()â:
test.c:5: error: invalid conversion from âvoid*â to âint*â
(1) /tmp$


I can understand C++ having stronger typechecking, but void pointers
*exist* for this purpose.  *Really* debatable whether Sparse should work
around this.  Avoiding keywords, sure, but casting void pointers
everywhere?  People *remove* these kinds of casts from C programs as a
cleanup.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () sysprog ! at>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 12 Oct 2010 10:42:31 +0000
Message-ID: <1286880151.24953.50.camel () thorin>
--------------------
On Mon, 2010-10-11 at 16:37 -0700, Josh Triplett wrote:
[....] 
> Wow.  I had to double-check this because I couldn't quite believe C++
> had that degree of dain bramage, but sure enough:
> 
> /tmp$ cat test.c
> extern void *pv(void);
> 
> int *pi(void)
> {
>     return pv();
> }
> /tmp$ gcc -c test.c -o /dev/null
> /tmp$ g++ -c test.c -o /dev/null
> test.c: In function âint* pi()â:
> test.c:5: error: invalid conversion from âvoid*â to âint*â
> (1) /tmp$

Welcome to one of the (more obvious) differences between C and C++: you
can't assign/convert/promote a "void *" to any other pointer type (and
vice versa) without explicit type-cast.
For a library written in C, that is the point where "compile it also as
C++" ends IMHO. Just keep the 'extern "C" {' stuff in headers (under
'#ifdef __cplusplus') and compile it as C (and not C++).

BTW there are other similar issues if one digs deep enough.
BTDT (read: looked after a library which was used in 2 "applications" -
one in pure C, the other C++. No way without explicit type-casts which
look somewhat funny and are surely superfluous in C as such).

> I can understand C++ having stronger typechecking, but void pointers
> *exist* for this purpose.  *Really* debatable whether Sparse should work
> around this.  Avoiding keywords, sure, but casting void pointers
> everywhere?  People *remove* these kinds of casts from C programs as a
> cleanup.

Type-casts are inherently evil. But in several situations there is in C
no other (or better) workaround. The above - kill warnings through "void
*" type-casts - makes it worse because some people (including /me) use
the type system in C and want the compiler to check as much as possible.

Bernd
-- 
mobile: +43 664 4416156              http://www.sysprog.at/
    Linux Software Development, Consulting and Services

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tomas Klacko <tomas.klacko () gmail ! com>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 12 Oct 2010 22:45:53 +0000
Message-ID: <AANLkTimdy9TwwSJM=rwTjXdRsnove6A2b0=d4M_dOin0 () mail ! gmail ! com>
--------------------
Hi,

Thanks everyone for your comments, I have refined the patch
and I am posting the next version (below).

On Tue, Oct 12, 2010 at 1:01 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Mon, Oct 11, 2010 at 3:46 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
>> On Tue, Oct 12, 2010 at 12:33:32AM +0200, Tomas Klacko wrote:
>>
>>> Great. I am posting my current status (as a patch) so that you can comment on it
>>> and that I can refine it further.
>>
>> ehh...  Use of capitalized variable names is a Bad Idea(tm).  Especially
>> since you are doing that well outside of headers, so even compatibility
>> with Straustrups's Mistake does not serve as a reason.
>
> I am about to complain the same thing. Al beats me to it.
>
> Tomas, can you limit the change on the header file C++ friendly first?
> I don't think the rest of the C code need to be compile in C++, so it is fine
> using C++ key words.

I don't think I quite get your question. I have limited the amount of changes
to the C source files, but there are still some. Which result for instance
from renaming "struct symbol->namespace" to "struct symbol->ns".
However, I can probably try doing:
struct symbol
{
...
#ifndef __cplusplus
  enum namespace namespace;
#else
  enum name_space ns;
#endif
...
};
and then try to work out any consequences solely in the header files.
After all, using different names for the same types in C++ versus C
should still result in correct code.
Is this what you mean?


This is the patch:


================================================================================

From: Bernd Petrovitsch <bernd () petrovitsch ! priv ! at>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Wed, 13 Oct 2010 11:39:53 +0000
Message-ID: <1286969993.14103.38.camel () thorin>
--------------------
On Die, 2010-10-12 at 17:37 -0700, Christopher Li wrote:
[...] 
> > However, I can probably try doing:
> > struct symbol
> > {
> > ...
> > #ifndef __cplusplus
> >  enum namespace namespace;
> > #else
> >  enum name_space ns;
> > #endif
> 
> Even worse.

FullACK. That's IMHO the worst solution - sprinkling "#ifndef
__cplusplus" all over the place.

> I don't like the #ifndef __cplusplus at all. Try to keep it minimal.
> Just make it "enum name_space ns;" is clear better than maintain two
> different names.

*eg*
----  snip  ----
#ifdef __cplusplus 
#define namespace ns
#endif
----  snip  ----
at the top would be simpler and keep the source readable. Nevertheless I
wouldn't do it either.

[...] 
> > +#ifdef __cplusplus
> > +extern "C" {
> > +#endif
> 
> Can you move this into your C++ code before including the sparse headers?
> I don't want it in the sparse headers. Sparse is compiled in C,
> shouldn't need to know
> C++ at all.

That is something common in .h files if they are intended for "mixed
use" and C libs use in C++ applications.

[...] 
> > +#ifdef __cplusplus
> > +}
> > +#endif
> > +
[...]

Bernd
-- 
Bernd Petrovitsch                  Email : bernd@petrovitsch.priv.at
                     LUGA : http://www.luga.at

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () petrovitsch ! priv ! at>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Wed, 13 Oct 2010 14:45:10 +0000
Message-ID: <1286981110.14103.86.camel () thorin>
--------------------

--=-duiMdDuJF6vwHCOp5/Vn
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 8bit

On Mon, 2010-10-11 at 12:12 -0700, Josh Triplett wrote:
[...] 
> Actually, Sparse seems to use "true" and "false" as variable names in
> several cases; for instance:
> 
> static struct symbol *evaluate_conditional_expression(struct expression *expr)
> {
>         struct expression **true;
> [...]
>         true = &expr->conditional;
> 
> 
> I think this only works because evaluate.c doesn't include stdbool.h.
> And sure enough, if I include stdbool.h from evaluate.c:
> 
>      CC       evaluate.o
> evaluate.c: In function âevaluate_conditional_expressionâ:
> evaluate.c:1081: error: expected identifier or â(â before numeric constant
> evaluate.c:1095: error: lvalue required as left operand of assignment
> evaluate.c:1101: error: lvalue required as left operand of assignment
> evaluate.c:1106: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1114: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1116: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1116: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1122: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1126: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1126: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1133: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1134: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1134: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1202: error: invalid type argument of âunary *â (have âintâ)
> evaluate.c:1202: error: invalid type argument of âunary *â (have âintâ)

FWIW, the attached patch should fix that.

Bernd
-- 
Bernd Petrovitsch                  Email : bernd@petrovitsch.priv.at
                     LUGA : http://www.luga.at

--=-duiMdDuJF6vwHCOp5/Vn
Content-Disposition: attachment; filename="0001-avoid-the-use-of-true-and-false-as-variable-names.patch"
Content-Type: text/x-patch; name="0001-avoid-the-use-of-true-and-false-as-variable-names.patch"; charset="UTF-8"
Content-Transfer-Encoding: 7bit

rename the local variables "true" and "false" to "if_true" and "if_false",
respectively to not clash with the well-known "keywords" defined by C99.
This is similar to commit 0be55c9.

Signed-off-by: Bernd Petrovitsch <bernd@sysprog.at>
---
 compile-i386.c |   18 +++++++++---------
 evaluate.c     |   22 +++++++++++-----------
 expand.c       |   18 +++++++++---------
 flow.c         |   18 +++++++++---------
 inline.c       |   26 +++++++++++++-------------
 linearize.c    |   12 ++++++------
 pre-process.c  |    4 ++--
 show-parse.c   |    6 +++---
 simplify.c     |   16 ++++++++--------
 9 files changed, 70 insertions(+), 70 deletions(-)

diff --git a/compile-i386.c b/compile-i386.c
index abe9313..0770147 100644
--- a/compile-i386.c
+++ b/compile-i386.c
@@ -1542,7 +1542,7 @@ static struct storage *emit_return_stmt(struct statement *stmt)
 
 static struct storage *emit_conditional_expr(struct expression *expr)
 {
-	struct storage *cond, *true = NULL, *false = NULL;
+	struct storage *cond, *if_true = NULL, *if_false = NULL;
 	struct storage *new = stack_alloc(expr->ctype->bit_size / 8);
 	int target_false, cond_end;
 
@@ -1551,16 +1551,16 @@ static struct storage *emit_conditional_expr(struct expression *expr)
 	target_false = emit_conditional_test(cond);
 
 	/* handle if-true part of the expression */
-	true = x86_expression(expr->cond_true);
+	if_true = x86_expression(expr->cond_true);
 
-	emit_copy(new, true, expr->ctype);
+	emit_copy(new, if_true, expr->ctype);
 
 	cond_end = emit_conditional_end(target_false);
 
 	/* handle if-false part of the expression */
-	false = x86_expression(expr->cond_false);
+	if_false = x86_expression(expr->cond_false);
 
-	emit_copy(new, false, expr->ctype);
+	emit_copy(new, if_false, expr->ctype);
 
 	/* end of conditional; jump target for if-true branch */
 	emit_label(cond_end, "end conditional");
@@ -1571,15 +1571,15 @@ static struct storage *emit_conditional_expr(struct expression *expr)
 static struct storage *emit_select_expr(struct expression *expr)
 {
 	struct storage *cond = x86_expression(expr->conditional);
-	struct storage *true = x86_expression(expr->cond_true);
-	struct storage *false = x86_expression(expr->cond_false);
+	struct storage *if_true = x86_expression(expr->cond_true);
+	struct storage *if_false = x86_expression(expr->cond_false);
 	struct storage *reg_cond, *reg_true, *reg_false;
 	struct storage *new = stack_alloc(4);
 
 	emit_comment("begin SELECT");
 	reg_cond = get_reg_value(cond, get_regclass(expr->conditional));
-	reg_true = get_reg_value(true, get_regclass(expr));
-	reg_false = get_reg_value(false, get_regclass(expr));
+	reg_true = get_reg_value(if_true, get_regclass(expr));
+	reg_false = get_reg_value(if_false, get_regclass(expr));
 
 	/*
 	 * Do the actual select: check the conditional for zero,
diff --git a/evaluate.c b/evaluate.c
index f8343c2..e243be5 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1077,7 +1077,7 @@ OK:
  */
 static struct symbol *evaluate_conditional_expression(struct expression *expr)
 {
-	struct expression **true;
+	struct expression **if_true;
 	struct symbol *ctype, *ltype, *rtype, *lbase, *rbase;
 	int lclass, rclass;
 	const char * typediff;
@@ -1091,18 +1091,18 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	ctype = degenerate(expr->conditional);
 	rtype = degenerate(expr->cond_false);
 
-	true = &expr->conditional;
+	if_true = &expr->conditional;
 	ltype = ctype;
 	if (expr->cond_true) {
 		if (!evaluate_expression(expr->cond_true))
 			return NULL;
 		ltype = degenerate(expr->cond_true);
-		true = &expr->cond_true;
+		if_true = &expr->cond_true;
 	}
 
 	if (expr->flags) {
 		int flags = expr->conditional->flags & Int_const_expr;
-		flags &= (*true)->flags & expr->cond_false->flags;
+		flags &= (*if_true)->flags & expr->cond_false->flags;
 		if (!flags)
 			expr->flags = 0;
 	}
@@ -1110,27 +1110,27 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	lclass = classify_type(ltype, &ltype);
 	rclass = classify_type(rtype, &rtype);
 	if (lclass & rclass & TYPE_NUM) {
-		ctype = usual_conversions('?', *true, expr->cond_false,
+		ctype = usual_conversions('?', *if_true, expr->cond_false,
 					  lclass, rclass, ltype, rtype);
-		*true = cast_to(*true, ctype);
+		*if_true = cast_to(*if_true, ctype);
 		expr->cond_false = cast_to(expr->cond_false, ctype);
 		goto out;
 	}
 
 	if ((lclass | rclass) & TYPE_PTR) {
-		int is_null1 = is_null_pointer_constant(*true);
+		int is_null1 = is_null_pointer_constant(*if_true);
 		int is_null2 = is_null_pointer_constant(expr->cond_false);
 
 		if (is_null1 && is_null2) {
-			*true = cast_to(*true, &ptr_ctype);
+			*if_true = cast_to(*if_true, &ptr_ctype);
 			expr->cond_false = cast_to(expr->cond_false, &ptr_ctype);
 			ctype = &ptr_ctype;
 			goto out;
 		}
 		if (is_null1 && (rclass & TYPE_PTR)) {
 			if (is_null1 == 2)
-				bad_null(*true);
-			*true = cast_to(*true, rtype);
+				bad_null(*if_true);
+			*if_true = cast_to(*if_true, rtype);
 			ctype = rtype;
 			goto out;
 		}
@@ -1198,7 +1198,7 @@ Qual:
 		sym->ctype.modifiers |= qual;
 		ctype = sym;
 	}
-	*true = cast_to(*true, ctype);
+	*if_true = cast_to(*if_true, ctype);
 	expr->cond_false = cast_to(expr->cond_false, ctype);
 	goto out;
 }
diff --git a/expand.c b/expand.c
index b965dc3..8d7de3e 100644
--- a/expand.c
+++ b/expand.c
@@ -508,27 +508,27 @@ static int expand_compare(struct expression *expr)
 static int expand_conditional(struct expression *expr)
 {
 	struct expression *cond = expr->conditional;
-	struct expression *true = expr->cond_true;
-	struct expression *false = expr->cond_false;
+	struct expression *if_true = expr->cond_true;
+	struct expression *if_false = expr->cond_false;
 	int cost, cond_cost;
 
 	cond_cost = expand_expression(cond);
 	if (cond->type == EXPR_VALUE) {
 		unsigned flags = expr->flags;
 		if (!cond->value)
-			true = false;
-		if (!true)
-			true = cond;
-		cost = expand_expression(true);
-		*expr = *true;
+			if_true = if_false;
+		if (!if_true)
+			if_true = cond;
+		cost = expand_expression(if_true);
+		*expr = *if_true;
 		expr->flags = flags;
 		if (expr->type == EXPR_VALUE)
 			expr->taint |= cond->taint;
 		return cost;
 	}
 
-	cost = expand_expression(true);
-	cost += expand_expression(false);
+	cost = expand_expression(if_true);
+	cost += expand_expression(if_false);
 
 	if (cost < SELECT_COST) {
 		expr->type = EXPR_SELECT;
diff --git a/flow.c b/flow.c
index 5bd9a1d..1df8646 100644
--- a/flow.c
+++ b/flow.c
@@ -100,7 +100,7 @@ static int try_to_simplify_bb(struct basic_block *bb, struct instruction *first,
 		struct basic_block *source, *target;
 		pseudo_t pseudo;
 		struct instruction *br;
-		int true;
+		int if_true;
 
 		if (!def)
 			continue;
@@ -113,10 +113,10 @@ static int try_to_simplify_bb(struct basic_block *bb, struct instruction *first,
 			continue;
 		if (br->opcode != OP_BR)
 			continue;
-		true = pseudo_truth_value(pseudo);
-		if (true < 0)
+		if_true = pseudo_truth_value(pseudo);
+		if (if_true < 0)
 			continue;
-		target = true ? second->bb_true : second->bb_false;
+		target = if_true ? second->bb_true : second->bb_false;
 		if (bb_depends_on(target, bb))
 			continue;
 		changed |= rewrite_branch(source, &br->bb_true, bb, target);
@@ -165,7 +165,7 @@ static int simplify_phi_branch(struct basic_block *bb, struct instruction *br)
 }
 
 static int simplify_branch_branch(struct basic_block *bb, struct instruction *br,
-	struct basic_block **target_p, int true)
+	struct basic_block **target_p, int if_true)
 {
 	struct basic_block *target = *target_p, *final;
 	struct instruction *insn;
@@ -181,7 +181,7 @@ static int simplify_branch_branch(struct basic_block *bb, struct instruction *br
 	 * Now we just need to see if we can rewrite the branch..
 	 */
 	retval = 0;
-	final = true ? insn->bb_true : insn->bb_false;
+	final = if_true ? insn->bb_true : insn->bb_false;
 	if (bb_has_side_effects(target))
 		goto try_to_rewrite_target;
 	if (bb_depends_on(final, target))
@@ -823,13 +823,13 @@ static struct basic_block * rewrite_branch_bb(struct basic_block *bb, struct ins
 {
 	struct basic_block *parent;
 	struct basic_block *target = br->bb_true;
-	struct basic_block *false = br->bb_false;
+	struct basic_block *if_false = br->bb_false;
 
-	if (target && false) {
+	if (target && if_false) {
 		pseudo_t cond = br->cond;
 		if (cond->type != PSEUDO_VAL)
 			return NULL;
-		target = cond->value ? target : false;
+		target = cond->value ? target : if_false;
 	}
 
 	/*
diff --git a/inline.c b/inline.c
index 860c0ee..612b843 100644
--- a/inline.c
+++ b/inline.c
@@ -162,14 +162,14 @@ static struct expression * copy_expression(struct expression *expr)
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL: {
 		struct expression *cond = copy_expression(expr->conditional);
-		struct expression *true = copy_expression(expr->cond_true);
-		struct expression *false = copy_expression(expr->cond_false);
-		if (cond == expr->conditional && true == expr->cond_true && false == expr->cond_false)
+		struct expression *if_true = copy_expression(expr->cond_true);
+		struct expression *if_false = copy_expression(expr->cond_false);
+		if (cond == expr->conditional && if_true == expr->cond_true && if_false == expr->cond_false)
 			break;
 		expr = dup_expression(expr);
 		expr->conditional = cond;
-		expr->cond_true = true;
-		expr->cond_false = false;
+		expr->cond_true = if_true;
+		expr->cond_false = if_false;
 		break;
 	}
 
@@ -353,20 +353,20 @@ static struct statement *copy_one_statement(struct statement *stmt)
 	}
 	case STMT_IF: {
 		struct expression *cond = stmt->if_conditional;
-		struct statement *true = stmt->if_true;
-		struct statement *false = stmt->if_false;
+		struct statement *if_true = stmt->if_true;
+		struct statement *if_false = stmt->if_false;
 
 		cond = copy_expression(cond);
-		true = copy_one_statement(true);
-		false = copy_one_statement(false);
+		if_true = copy_one_statement(if_true);
+		if_false = copy_one_statement(if_false);
 		if (stmt->if_conditional == cond &&
-		    stmt->if_true == true &&
-		    stmt->if_false == false)
+		    stmt->if_true == if_true &&
+		    stmt->if_false == if_false)
 			break;
 		stmt = dup_statement(stmt);
 		stmt->if_conditional = cond;
-		stmt->if_true = true;
-		stmt->if_false = false;
+		stmt->if_true = if_true;
+		stmt->if_false = if_false;
 		break;
 	}
 	case STMT_RETURN: {
diff --git a/linearize.c b/linearize.c
index f2034ce..d29efce 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1287,19 +1287,19 @@ pseudo_t linearize_cond_branch(struct entrypoint *ep, struct expression *expr, s
 
 static pseudo_t linearize_select(struct entrypoint *ep, struct expression *expr)
 {
-	pseudo_t cond, true, false, res;
+	pseudo_t cond, if_true, if_false, res;
 	struct instruction *insn;
 
-	true = linearize_expression(ep, expr->cond_true);
-	false = linearize_expression(ep, expr->cond_false);
+	if_true = linearize_expression(ep, expr->cond_true);
+	if_false = linearize_expression(ep, expr->cond_false);
 	cond = linearize_expression(ep, expr->conditional);
 
 	insn = alloc_typed_instruction(OP_SEL, expr->ctype);
 	if (!expr->cond_true)
-		true = cond;
+		if_true = cond;
 	use_pseudo(insn, cond, &insn->src1);
-	use_pseudo(insn, true, &insn->src2);
-	use_pseudo(insn, false, &insn->src3);
+	use_pseudo(insn, if_true, &insn->src2);
+	use_pseudo(insn, if_false, &insn->src3);
 
 	res = alloc_pseudo(insn);
 	insn->target = res;
diff --git a/pre-process.c b/pre-process.c
index 656acaa..7317d57 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -1236,13 +1236,13 @@ static int handle_strong_undef(struct stream *stream, struct token **line, struc
 	return do_handle_undef(stream, line, token, SYM_ATTR_STRONG);
 }
 
-static int preprocessor_if(struct stream *stream, struct token *token, int true)
+static int preprocessor_if(struct stream *stream, struct token *token, int if_true)
 {
 	token_type(token) = false_nesting ? TOKEN_SKIP_GROUPS : TOKEN_IF;
 	free_preprocessor_line(token->next);
 	token->next = stream->top_if;
 	stream->top_if = token;
-	if (false_nesting || true != 1)
+	if (false_nesting || if_true != 1)
 		false_nesting++;
 	return 0;
 }
diff --git a/show-parse.c b/show-parse.c
index c97debe..d47d832 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -1001,11 +1001,11 @@ static int show_label_expr(struct expression *expr)
 static int show_conditional_expr(struct expression *expr)
 {
 	int cond = show_expression(expr->conditional);
-	int true = show_expression(expr->cond_true);
-	int false = show_expression(expr->cond_false);
+	int if_true = show_expression(expr->cond_true);
+	int if_false = show_expression(expr->cond_false);
 	int new = new_pseudo();
 
-	printf("[v%d]\tcmov.%d\t\tv%d,v%d,v%d\n", cond, expr->ctype->bit_size, new, true, false);
+	printf("[v%d]\tcmov.%d\t\tv%d,v%d,v%d\n", cond, expr->ctype->bit_size, new, if_true, if_false);
 	return new;
 }
 
diff --git a/simplify.c b/simplify.c
index 8200584..2d70743 100644
--- a/simplify.c
+++ b/simplify.c
@@ -780,10 +780,10 @@ static int simplify_cond_branch(struct instruction *br, pseudo_t cond, struct in
 	use_pseudo(br, *pp, &br->cond);
 	remove_usage(cond, &br->cond);
 	if (def->opcode == OP_SET_EQ) {
-		struct basic_block *true = br->bb_true;
-		struct basic_block *false = br->bb_false;
-		br->bb_false = true;
-		br->bb_true = false;
+		struct basic_block *if_true = br->bb_true;
+		struct basic_block *if_false = br->bb_false;
+		br->bb_false = if_true;
+		br->bb_true = if_false;
 	}
 	return REPEAT_CSE;
 }
@@ -836,10 +836,10 @@ static int simplify_branch(struct instruction *insn)
 					return REPEAT_CSE;
 				}
 				if (val2) {
-					struct basic_block *true = insn->bb_true;
-					struct basic_block *false = insn->bb_false;
-					insn->bb_false = true;
-					insn->bb_true = false;
+					struct basic_block *if_true = insn->bb_true;
+					struct basic_block *if_false = insn->bb_false;
+					insn->bb_false = if_true;
+					insn->bb_true = if_false;
 				}
 				use_pseudo(insn, def->src1, &insn->cond);
 				remove_usage(cond, &insn->cond);
-- 
1.7.2.3


--=-duiMdDuJF6vwHCOp5/Vn--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tomas Klacko <tomas.klacko () gmail ! com>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Sat, 16 Oct 2010 16:03:53 +0000
Message-ID: <AANLkTimZb1PsnKcMQ_Ka6dkk7fNwXiJb6_U4GcckLsF4 () mail ! gmail ! com>
--------------------
Hi,

On Wed, Oct 13, 2010 at 2:37 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Oct 12, 2010 at 3:45 PM, Tomas Klacko <tomas.klacko@gmail.com> wrote:

>> diff --git a/parse.h b/parse.h
>> index 6b21e23..f2193e7 100644
>> --- a/parse.h
>> +++ b/parse.h
>> @@ -35,10 +35,12 @@ struct statement {
>>                struct /* declaration */ {
>>                        struct symbol_list *declaration;
>>                };
>> +#ifndef __cplusplus
>>                struct /* label_arg */ {
>>                        struct symbol *label;
>>                        struct statement *label_statement;
>>                };
>> +#endif
>
> What is this #ifndef  for?

I use it to avoid this error:

[...]/sparse/parse.h:65: error: declaration of statement*
statement::<anonymous union>::<anonymous struct>::label_statement
[...]sparse/parse.h:41: error: conflicts with previous declaration
statement* statement::<anonymous union>::<anonymous
struct>::label_statement

>>  /* Silly type-safety check ;) */
>>  #define DECLARE_PTR_LIST(listname,type)        struct listname { type *list[1]; }
>> -#define CHECK_TYPE(head,ptr)           (void)(&(ptr) == &(head)->list[0])
>>  #define TYPEOF(head)                   __typeof__(&(head)->list[0])
>>  #define VRFY_PTR_LIST(head)            (void)(sizeof((head)->list[0]))
>>
>> +#ifndef __cplusplus
>> +#define CHECK_TYPE(head,ptr)           (void)(&(ptr) == &(head)->list[0])
>> +#else
>> +/* I don't know yet how to do this better in C++. */
>> +#define CHECK_TYPE(head,ptr) (void)((void*)&(ptr) == (void*)&(head)->list[0])
>> +#endif
>
> If you can't get CHECK_TYPE work in C++, you might just make it an empty define
> instead of doing useless point dancing. At least it is clear that it does not
> do any thing here.

True. How about
#define CHECK_TYPE (head,ptr)   (void)(1)
?

I have processed your comments and this is the next patch version:


================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Sat, 16 Oct 2010 19:11:54 +0000
Message-ID: <20101016191153.GA19324 () feather>
--------------------
On Sat, Oct 16, 2010 at 06:03:53PM +0200, Tomas Klacko wrote:
> On Wed, Oct 13, 2010 at 2:37 AM, Christopher Li <sparse@chrisli.org> wrote:
> > On Tue, Oct 12, 2010 at 3:45 PM, Tomas Klacko <tomas.klacko@gmail.com> wrote:
> >> diff --git a/parse.h b/parse.h
> >> index 6b21e23..f2193e7 100644
> >> --- a/parse.h
> >> +++ b/parse.h
> >> @@ -35,10 +35,12 @@ struct statement {
> >> Â  Â  Â  Â  Â  Â  Â  Â struct /* declaration */ {
> >> Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â struct symbol_list *declaration;
> >> Â  Â  Â  Â  Â  Â  Â  Â };
> >> +#ifndef __cplusplus
> >> Â  Â  Â  Â  Â  Â  Â  Â struct /* label_arg */ {
> >> Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â struct symbol *label;
> >> Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â struct statement *label_statement;
> >> Â  Â  Â  Â  Â  Â  Â  Â };
> >> +#endif
> >
> > What is this #ifndef Â for?
> 
> I use it to avoid this error:
> 
> [...]/sparse/parse.h:65: error: declaration of âstatement*
> statement::<anonymous union>::<anonymous struct>::label_statementâ
> [...]sparse/parse.h:41: error: conflicts with previous declaration
> âstatement* statement::<anonymous union>::<anonymous
> struct>::label_statementâ

Huh, interesting.  Turns out that giant union contains two different
structs of the form { struct symbol *, struct statement * }; one for
label_arg and one for labeled_struct.  They have different names for the
symbol, but the same name for the statement.  We should fix that for C
as well, either by renaming one of the statements, or by just making
both variations use the same set of fields and dropping one of the
sub-structs.  Either way, that should happen as an independent patch,
separate from the C++ compatibility changes.

Chris, what do you think?

> >> Â /* Silly type-safety check ;) */
> >> Â #define DECLARE_PTR_LIST(listname,type) Â  Â  Â  Â struct listname { type *list[1]; }
> >> -#define CHECK_TYPE(head,ptr) Â  Â  Â  Â  Â  (void)(&(ptr) == &(head)->list[0])
> >> Â #define TYPEOF(head) Â  Â  Â  Â  Â  Â  Â  Â  Â  __typeof__(&(head)->list[0])
> >> Â #define VRFY_PTR_LIST(head) Â  Â  Â  Â  Â  Â (void)(sizeof((head)->list[0]))
> >>
> >> +#ifndef __cplusplus
> >> +#define CHECK_TYPE(head,ptr) Â  Â  Â  Â  Â  (void)(&(ptr) == &(head)->list[0])
> >> +#else
> >> +/* I don't know yet how to do this better in C++. */
> >> +#define CHECK_TYPE(head,ptr) (void)((void*)&(ptr) == (void*)&(head)->list[0])
> >> +#endif
> >
> > If you can't get CHECK_TYPE work in C++, you might just make it an empty define
> > instead of doing useless point dancing. At least it is clear that it does not
> > do any thing here.
> 
> True. How about
> #define CHECK_TYPE (head,ptr)   (void)(1)
> ?

As far as I can tell, CHECK_TYPE works just fine in C++.  I could easily
compile an invocation of CHECK_TYPE, as well as some simple examples
that called the macros which invoked CHECK_TYPE.  When I tried
FOR_EACH_PTR, I encountered *other* warnings (related to assigning (void
*) to some other type without a cast), but those warnings didn't come
from CHECK_TYPE.

What warning do you encounter about CHECK_TYPE?

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Mon, 18 Oct 2010 03:16:22 +0000
Message-ID: <AANLkTikQ8OXUtoAd1Jn+Awn+4RXCEF6=_NAz1Xiq0WW- () mail ! gmail ! com>
--------------------
On Sat, Oct 16, 2010 at 12:11 PM, Josh Triplett <josh@joshtriplett.org> wrote:
> Huh, interesting.  Turns out that giant union contains two different
> structs of the form { struct symbol *, struct statement * }; one for
> label_arg and one for labeled_struct.  They have different names for the
> symbol, but the same name for the statement.  We should fix that for C
> as well, either by renaming one of the statements, or by just making
> both variations use the same set of fields and dropping one of the
> sub-structs.  Either way, that should happen as an independent patch,
> separate from the C++ compatibility changes.

That make sense. It seems to me that label_arg is not actually used.
It might used in very early code.  The member statement->label is never
referenced now. There is no point to keep it as far as I can tell.
Just remove that  label_arg union and sparse compile just fine.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Mon, 18 Oct 2010 04:13:15 +0000
Message-ID: <AANLkTimyOUX8a6ZjrcW3jxuFK5+gAEUuVPheHVKzFcVs () mail ! gmail ! com>
--------------------
On Sun, Oct 17, 2010 at 3:31 AM, Tomas Klacko <tomas.klacko@gmail.com> wrote:
>> What warning do you encounter about CHECK_TYPE?
> I get:
> main.cc: In function int main(int, char**):
> main.cc:19: error: comparison between distinct pointer types void*
> and char* lacks a cast
>
> compiler and (important) flags:
> g++ (GCC) 4.2.4 (Ubuntu 4.2.4-1ubuntu4), -Wall -Werror
>
>
> Now, the code2 (file main.cc):
> I get error:
> main.cc: In function int main(int, char**):
> main.cc:18: error: invalid conversion from void* to char*

That sounds like some thing need to be fixed before the patch can go in.

I give this C++ changes more thought. The sparse code is written in
pure C. I don't
want to make C++ as another burden of sparse developers. The
alternative always exist,
which is compiling your sparse related code in C then link to your C++ program.
Here is my guide line for the C++ related changes.

The change needs to make sense in C alone. That means no "#ifdef __cplusplus".
Sparse itself is pure C.I am not a C++ expert, I really  don't know
what is going on
inside the C++ portion of the code. It is pure burden for most sparse
developers who
don't deal with C++, me included.

Personally I don't care about including sparse header in C++. But that
being said,
I am willing to make some compromise. e.g. the keyword renaming adds no value
for the C code, if that is all it takes to make C++ happy, fine.

The rest still need to make sense in C. E.g. removing the dead label_arg union
is a good change by itself.

Fundamentally the C++ and C99 are not compatible.  So there is a limit
you can push
for including C code in C++. Sparse uses a lot of C specific code in
the header file.
For the nasty case, it seems that using the alternative method is not too bad.
It is inconvenient, but only limit to very few users.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Mon, 18 Oct 2010 05:39:56 +0000
Message-ID: <20101018053955.GA1628 () feather>
--------------------
On Sun, Oct 17, 2010 at 12:31:26PM +0200, Tomas Klacko wrote:
> On Sat, Oct 16, 2010 at 9:11 PM, Josh Triplett <josh@joshtriplett.org> wrote:
> > On Sat, Oct 16, 2010 at 06:03:53PM +0200, Tomas Klacko wrote:
> >> On Wed, Oct 13, 2010 at 2:37 AM, Christopher Li <sparse@chrisli.org> wrote:
> >> > On Tue, Oct 12, 2010 at 3:45 PM, Tomas Klacko <tomas.klacko@gmail.com> wrote:
> 
> >> >> Â /* Silly type-safety check ;) */
> >> >> Â #define DECLARE_PTR_LIST(listname,type) Â  Â  Â  Â struct listname { type *list[1]; }
> >> >> -#define CHECK_TYPE(head,ptr) Â  Â  Â  Â  Â  (void)(&(ptr) == &(head)->list[0])
> >> >> Â #define TYPEOF(head) Â  Â  Â  Â  Â  Â  Â  Â  Â  __typeof__(&(head)->list[0])
> >> >> Â #define VRFY_PTR_LIST(head) Â  Â  Â  Â  Â  Â (void)(sizeof((head)->list[0]))
> >> >>
> >> >> +#ifndef __cplusplus
> >> >> +#define CHECK_TYPE(head,ptr) Â  Â  Â  Â  Â  (void)(&(ptr) == &(head)->list[0])
> >> >> +#else
> >> >> +/* I don't know yet how to do this better in C++. */
> >> >> +#define CHECK_TYPE(head,ptr) (void)((void*)&(ptr) == (void*)&(head)->list[0])
> >> >> +#endif
> >> >
> >> > If you can't get CHECK_TYPE work in C++, you might just make it an empty define
> >> > instead of doing useless point dancing. At least it is clear that it does not
> >> > do any thing here.
> >>
> >> True. How about
> >> #define CHECK_TYPE (head,ptr) Â  (void)(1)
> >> ?
> >
> > As far as I can tell, CHECK_TYPE works just fine in C++. Â I could easily
> > compile an invocation of CHECK_TYPE, as well as some simple examples
> > that called the macros which invoked CHECK_TYPE. Â When I tried
> > FOR_EACH_PTR, I encountered *other* warnings (related to assigning (void
> > *) to some other type without a cast), but those warnings didn't come
> > from CHECK_TYPE.
> 
> Maybe I did not investigate deeply enough to find out the origin of
> the warnings.
> But I get no warnings/errors, when I disable CHECK_TYPE in C++ code.
> 
> > What warning do you encounter about CHECK_TYPE?
> 
> In the following code1 (file main.cc):
> int main(int argc, char* argv[])
> {
>     struct string_list *files=NULL;
> 
>     void* file_void;
>     char* file_char;
> 
>     struct symbol_list *symbols=NULL;
>     struct symbol_list *all_symbols=NULL;
> 
>     symbols=sparse_initialize(argc, argv, &files);
>     concat_symbol_list(symbols, &all_symbols);
> 
>     FOR_EACH_PTR_NOTAG(files, file_void) {  // line 19
>         file_char=(char*)file_void;
>         symbols=sparse(file_char);
>         concat_symbol_list(symbols, &all_symbols);
>     } END_FOR_EACH_PTR_NOTAG(file_void);
> 
>     exit(EXIT_SUCCESS);
> }
> 
> I get:
> main.cc: In function âint main(int, char**)â:
> main.cc:19: error: comparison between distinct pointer types âvoid*â
> and âchar*â lacks a cast

This warning means that CHECK_TYPE has done its job correctly; you
should not use the void * file_void to iterate over a list of files.Â 
FOR_EACH_PTR (and the _NOTAG variant) expect a list type and the
corresponding element type, and they use CHECK_TYPE to make this
type-safe.

> compiler and (important) flags:
> g++ (GCC) 4.2.4 (Ubuntu 4.2.4-1ubuntu4), -Wall -Werror
> 
> 
> Now, the code2 (file main.cc):
> int main(int argc, char* argv[])
> {
>     struct string_list *files=NULL;
> 
>     char* file_char;
> 
>     struct symbol_list *symbols=NULL;
>     struct symbol_list *all_symbols=NULL;
> 
>     symbols=sparse_initialize(argc, argv, &files);
>     concat_symbol_list(symbols, &all_symbols);
> 
>     FOR_EACH_PTR_NOTAG(files, file_char) {  // line 18
>         symbols=sparse(file_char);
>         concat_symbol_list(symbols, &all_symbols);
>     } END_FOR_EACH_PTR_NOTAG(file_char);
> 
>     exit(EXIT_SUCCESS);
> }
> 
> I get error:
> main.cc: In function âint main(int, char**)â:
> main.cc:18: error: invalid conversion from âvoid*â to âchar*â

This warning doesn't come from CHECK_TYPE; it comes from the subsequent
implicit conversion from the list's void * to the desired type char *,
which will indeed need a cast to work correctly when included from C++.

Based on these two code examples, I think you don't need to change
CHECK_TYPE at all.  (And the user should always use code like your
second example, not your first example.)

(Of course, if someone really wants to use these lists from C++, they
might want to build appropriate type-safe C++ iterator types on top of
the ptrlist bits. :) )

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Mon, 18 Oct 2010 18:37:18 +0000
Message-ID: <AANLkTim2ti8+aht_f=Mv=0iLZCvF65CFF6GNP2gHF=Kq () mail ! gmail ! com>
--------------------
On Sun, Oct 17, 2010 at 10:39 PM, Josh Triplett <josh@joshtriplett.org> wrote:
>
> Based on these two code examples, I think you don't need to change
> CHECK_TYPE at all.  (And the user should always use code like your
> second example, not your first example.)

Oh good, then we can completely remove the #ifdef __cplusplus.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Mon, 18 Oct 2010 18:43:50 +0000
Message-ID: <AANLkTikebbsOaTAE6-hVd5H99KptTsMgfSu0tYoyzJSA () mail ! gmail ! com>
--------------------
On Wed, Oct 13, 2010 at 7:45 AM, Bernd Petrovitsch
<bernd@petrovitsch.priv.at> wrote:
> FWIW, the attached patch should fix that.
>


I will get to that after the 0.4.3 release.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 19 Oct 2010 21:31:09 +0000
Message-ID: <20101019213109.GV19804 () ZenIV ! linux ! org ! uk>
--------------------
On Tue, Oct 19, 2010 at 10:03:42PM +0200, Tomas Klacko wrote:
> @@ -188,7 +188,7 @@ static struct symbol_op char_op = {
>  	.type = KW_SPECIFIER,
>  	.test = Set_T|Set_Long|Set_Short,
>  	.set = Set_T|Set_Char,
> -	.class = CChar,
> +	.klass = CChar,
>  };

Egads...  Why not "kC1455", while you are at it?  Seriously, if you feel the
need to rename that, at least use something more palatable.  Hell, even
adjust_type would be better...

The only thing using that field is parsing of declaration specifiers.  We
keep track of what's acceptable after the prefix we'd seen (and report
conflicts).  We remember if we'd seen a speficier that doesn't combine with
anything (struct/union/enum/void/_Bool/typeof/__builtin_va_list) and for
numeric ones we are using a bit of trick: assign them pairs of integers as
below and add those up.
	int: (0,0)
	short: (-1,0)
	long: (1,0)
	signed: (0,1)
	unsigned: (0,2)
	double: (0, 3)
	float: (-1, 3)
	char: (0, 4)
Then the sum will be sufficient to discriminate between the resulting types
of acceptable sequences of numeric specifiers.  Namely, if the sum is (s,t),
the type we have is
   |  s = -1          |  0          |  1              |  2                   |
t=0|short int         |int          |long int         |long long int         |
t=1|short signed int  |signed int   |long signed int  |long long signed int  |
t=2|short unsigned int|unsigned int |long unsigned int|long long unsigned int|
t=3|float             |double       |long double      |                      |
t=4|                  |char         |                 |                      |
t=5|                  |signed char  |                 |                      |
t=6|                  |unsigned char|                 |                      |
and neither reordering the sequence nor omitting int affect the sum.

The first component of pair is encoded in ->type (KW_SHORT and KW_LONG bits),
the second is stored in ->class.  ->test and ->set drive the rejection of
unacceptable sequences.  For the sake of completeness, meanings of the bits
in these are:
Set_T		seen int/char/double/float/any non-combinable
Set_S		seen any non-combinable
Set_{Char,Int,Double,Float,Signed,Unsigned,Short,Long}	obvious
Set_Vlong	seen either long twice or both long and double
We could conflate e.g. Set_Signed with Set_Unsigned, but we'd have harder
time generating error messages that way.  ->test is "reject if we'd already
seen..." and ->set is "we've just seen...".  The only things not covered by
the above are
	* double long and long double are OK, but triple long and long long
double should be rejected
	* if we'd already seen any type specifiers by the time we run into
a typedef name, the sequence ends just before that typedef name (i.e.
typedef char T; int f(long T) is OK and declares f as int(long int)).
That's it...

>  static inline int match_op(struct token *token, int op)
>  {
> -	return token->pos.type == TOKEN_SPECIAL && token->special == op;
> +	return token->pos.type == TOKEN_SPECIAL && token->special == (unsigned int)op;

What was that one for?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: David Malcolm <dmalcolm () redhat ! com>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 19 Oct 2010 21:46:44 +0000
Message-ID: <1287524804.3483.26.camel () radiator ! bos ! redhat ! com>
--------------------
On Tue, 2010-10-19 at 22:31 +0100, Al Viro wrote:
> On Tue, Oct 19, 2010 at 10:03:42PM +0200, Tomas Klacko wrote:
> > @@ -188,7 +188,7 @@ static struct symbol_op char_op = {
> >  	.type = KW_SPECIFIER,
> >  	.test = Set_T|Set_Long|Set_Short,
> >  	.set = Set_T|Set_Char,
> > -	.class = CChar,
> > +	.klass = CChar,
> >  };
> 
> Egads...  Why not "kC1455", while you are at it?  Seriously, if you feel the
> need to rename that, at least use something more palatable.  Hell, even
> adjust_type would be better...
FWIW, "klass" is used as a spelling of "class" in .c code by Ruby, by
the GTK/GNOME stack, Mono, OpenJDK, Dalvik, and others.

See e.g.:
http://www.google.com/codesearch?hl=en&start=20&sa=N&as_case=y&q=klass+lang:c


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 19 Oct 2010 22:12:46 +0000
Message-ID: <20101019221246.GW19804 () ZenIV ! linux ! org ! uk>
--------------------
On Tue, Oct 19, 2010 at 05:46:44PM -0400, David Malcolm wrote:
> On Tue, 2010-10-19 at 22:31 +0100, Al Viro wrote:
> > On Tue, Oct 19, 2010 at 10:03:42PM +0200, Tomas Klacko wrote:
> > > @@ -188,7 +188,7 @@ static struct symbol_op char_op = {
> > >  	.type = KW_SPECIFIER,
> > >  	.test = Set_T|Set_Long|Set_Short,
> > >  	.set = Set_T|Set_Char,
> > > -	.class = CChar,
> > > +	.klass = CChar,
> > >  };
> > 
> > Egads...  Why not "kC1455", while you are at it?  Seriously, if you feel the
> > need to rename that, at least use something more palatable.  Hell, even
> > adjust_type would be better...
> FWIW, "klass" is used as a spelling of "class" in .c code by Ruby, by
> the GTK/GNOME stack, Mono, OpenJDK, Dalvik, and others.

I'd say that it's an argument _against_ doing that, if anything...
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tomas Klacko <tomas.klacko () gmail ! com>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 19 Oct 2010 22:49:33 +0000
Message-ID: <AANLkTi=QryvTC=Q3xsNh4fyhT3V-WZ1VSaE4=JPntz=n () mail ! gmail ! com>
--------------------
On Tue, Oct 19, 2010 at 11:31 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> On Tue, Oct 19, 2010 at 10:03:42PM +0200, Tomas Klacko wrote:

>>  static inline int match_op(struct token *token, int op)
>>  {
>> -     return token->pos.type == TOKEN_SPECIAL && token->special == op;
>> +     return token->pos.type == TOKEN_SPECIAL && token->special == (unsigned int)op;
>
> What was that one for?

"warning: comparison between signed and unsigned integer expressions"

Tomas Klacko
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 19 Oct 2010 23:07:42 +0000
Message-ID: <AANLkTin1VwzZ=nwEpfxD4WBXjo=Pyn0a+s=DnsSvQOg8 () mail ! gmail ! com>
--------------------
On Tue, Oct 19, 2010 at 2:31 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> On Tue, Oct 19, 2010 at 10:03:42PM +0200, Tomas Klacko wrote:
>> @@ -188,7 +188,7 @@ static struct symbol_op char_op = {
>>       .type = KW_SPECIFIER,
>>       .test = Set_T|Set_Long|Set_Short,
>>       .set = Set_T|Set_Char,
>> -     .class = CChar,
>> +     .klass = CChar,
>>  };
>
> Egads...  Why not "kC1455", while you are at it?  Seriously, if you feel the
> need to rename that, at least use something more palatable.  Hell, even
> adjust_type would be better...

I suggested the "klass", my bad. How about your suggest a perfect name
and we will use it. Is "adjust_type" good enough?


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Wed, 20 Oct 2010 07:29:45 +0000
Message-ID: <20101020072945.GA3232 () ZenIV ! linux ! org ! uk>
--------------------
On Wed, Oct 13, 2010 at 04:45:10PM +0200, Bernd Petrovitsch wrote:

> rename the local variables "true" and "false" to "if_true" and "if_false",
> respectively to not clash with the well-known "keywords" defined by C99.
> This is similar to commit 0be55c9.

These are not keywords...  Said that, things like
                if (!cond->value)
                        true = false;
                if (!true)
                        true = cond;
certainly reek of IOCCC.  I'd rather avoid "if_true" as replacement, though.
If anything, true_expr and false_expr would make more sense.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Wed, 20 Oct 2010 07:40:34 +0000
Message-ID: <20101020074034.GY19804 () ZenIV ! linux ! org ! uk>
--------------------
On Tue, Oct 19, 2010 at 04:07:42PM -0700, Christopher Li wrote:
> On Tue, Oct 19, 2010 at 2:31 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> > On Tue, Oct 19, 2010 at 10:03:42PM +0200, Tomas Klacko wrote:
> >> @@ -188,7 +188,7 @@ static struct symbol_op char_op = {
> >> ? ? ? .type = KW_SPECIFIER,
> >> ? ? ? .test = Set_T|Set_Long|Set_Short,
> >> ? ? ? .set = Set_T|Set_Char,
> >> - ? ? .class = CChar,
> >> + ? ? .klass = CChar,
> >> ?};
> >
> > Egads... ?Why not "kC1455", while you are at it? ?Seriously, if you feel the
> > need to rename that, at least use something more palatable. ?Hell, even
> > adjust_type would be better...
> 
> I suggested the "klass", my bad. How about your suggest a perfect name
> and we will use it. Is "adjust_type" good enough?

type_group, probably...  FWIW, I'd probably spell that enum in parse.c as
	CInt = 0, CSInt = 1, CUInt = 2, CReal = 3, CChar = 4,
	CSChar = CChar + CSInt, CUChar = CChar + CUInt
while we are at it.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () sysprog ! at>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Wed, 20 Oct 2010 09:39:04 +0000
Message-ID: <1287567544.7542.7.camel () thorin>
--------------------
On Mit, 2010-10-20 at 08:29 +0100, Al Viro wrote: 
> On Wed, Oct 13, 2010 at 04:45:10PM +0200, Bernd Petrovitsch wrote:
> 
> > rename the local variables "true" and "false" to "if_true" and "if_false",
> > respectively to not clash with the well-known "keywords" defined by C99.
> > This is similar to commit 0be55c9.
> 
> These are not keywords...  Said that, things like

ACK, that's why "keywords" is quoted above.

> if (!cond->value)
>                         true = false;
>                 if (!true)
>                         true = cond;
> certainly reek of IOCCC.  I'd rather avoid "if_true" as replacement, though.
> If anything, true_expr and false_expr would make more sense.

I have no strong feelings about the replacement and just followed the
change in the referenced commit.
Chris, should I respin the patch with *_expr?

Bernd
-- 
mobile: +43 664 4416156              http://www.sysprog.at/
    Linux Software Development, Consulting and Services

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () sysprog ! at>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Wed, 20 Oct 2010 10:19:02 +0000
Message-ID: <1287569942.7542.8.camel () thorin>
--------------------
On Mit, 2010-10-20 at 00:49 +0200, Tomas Klacko wrote: 
> On Tue, Oct 19, 2010 at 11:31 PM, Al Viro <viro@zeniv.linux.org.uk> wrote:
> > On Tue, Oct 19, 2010 at 10:03:42PM +0200, Tomas Klacko wrote:
> 
> >>  static inline int match_op(struct token *token, int op)
> >>  {
> >> -     return token->pos.type == TOKEN_SPECIAL && token->special == op;
> >> +     return token->pos.type == TOKEN_SPECIAL && token->special == (unsigned int)op;
> >
> > What was that one for?
> 
> "warning: comparison between signed and unsigned integer expressions"

Add "-Wsign-compare" to the CFLAGS (for a pure C compile) and you will
find many more of them.
IMHO it needs a decision if the goal is to prefer signed or unsigned int
(where no negative values ever used/assigned) and convert struct members
and/or global variables. Most of them TTBOMK are never negative anyways.

For the "C vs C++" issue: if you have an enum, the rules (or at least
the reality defined by gcc) are subtly different if it's a signed int or
an unsigned int and the values of their members.

Bernd
-- 
mobile: +43 664 4416156              http://www.sysprog.at/
    Linux Software Development, Consulting and Services


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () sysprog ! at>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Fri, 29 Oct 2010 13:22:40 +0000
Message-ID: <1288358560.7795.34.camel () thorin>
--------------------

--=-QNCxE5A9XGayUpIR+y09
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 7bit

On Mit, 2010-10-20 at 08:34 -0700, Christopher Li wrote: 
> On Wed, Oct 20, 2010 at 2:39 AM, Bernd Petrovitsch <bernd@sysprog.at> wrote:
> >> certainly reek of IOCCC.  I'd rather avoid "if_true" as replacement, though.
> >> If anything, true_expr and false_expr would make more sense.
> >
> > I have no strong feelings about the replacement and just followed the
> > change in the referenced commit.
> > Chris, should I respin the patch with *_expr?
> 
> Please do. As far as I can remember, Al is always right.

Voila.

Bernd
-- 
mobile: +43 664 4416156              http://www.sysprog.at/
    Linux Software Development, Consulting and Services

--=-QNCxE5A9XGayUpIR+y09
Content-Disposition: attachment; filename*0=0001-Rename-the-local-variables-true-and-false-to-true_ex.pat; filename*1=ch
Content-Type: text/x-patch; name="0001-Rename-the-local-variables-true-and-false-to-true_ex.patch"; charset="UTF-8"
Content-Transfer-Encoding: 7bit

Rename the local variables "true" and "false" to "true_expr" and
"false_expr" (or another context-sensitive name), respectively to
not clash with the identical  "keywords" defined by C99.

The commit 0be55c9 was a step in that direction for .h files only.
Now it is complete.

Signed-off-by: Bernd Petrovitsch <bernd@sysprog.at>
---
 compile-i386.c |   18 +++++++++---------
 evaluate.c     |   22 +++++++++++-----------
 expand.c       |   18 +++++++++---------
 flow.c         |   18 +++++++++---------
 inline.c       |   26 +++++++++++++-------------
 linearize.c    |   12 ++++++------
 pre-process.c  |    4 ++--
 show-parse.c   |    6 +++---
 simplify.c     |   16 ++++++++--------
 9 files changed, 70 insertions(+), 70 deletions(-)

diff --git a/compile-i386.c b/compile-i386.c
index abe9313..1aaf98f 100644
--- a/compile-i386.c
+++ b/compile-i386.c
@@ -1542,7 +1542,7 @@ static struct storage *emit_return_stmt(struct statement *stmt)
 
 static struct storage *emit_conditional_expr(struct expression *expr)
 {
-	struct storage *cond, *true = NULL, *false = NULL;
+	struct storage *cond, *true_expr = NULL, *false_expr = NULL;
 	struct storage *new = stack_alloc(expr->ctype->bit_size / 8);
 	int target_false, cond_end;
 
@@ -1551,16 +1551,16 @@ static struct storage *emit_conditional_expr(struct expression *expr)
 	target_false = emit_conditional_test(cond);
 
 	/* handle if-true part of the expression */
-	true = x86_expression(expr->cond_true);
+	true_expr = x86_expression(expr->cond_true);
 
-	emit_copy(new, true, expr->ctype);
+	emit_copy(new, true_expr, expr->ctype);
 
 	cond_end = emit_conditional_end(target_false);
 
 	/* handle if-false part of the expression */
-	false = x86_expression(expr->cond_false);
+	false_expr = x86_expression(expr->cond_false);
 
-	emit_copy(new, false, expr->ctype);
+	emit_copy(new, false_expr, expr->ctype);
 
 	/* end of conditional; jump target for if-true branch */
 	emit_label(cond_end, "end conditional");
@@ -1571,15 +1571,15 @@ static struct storage *emit_conditional_expr(struct expression *expr)
 static struct storage *emit_select_expr(struct expression *expr)
 {
 	struct storage *cond = x86_expression(expr->conditional);
-	struct storage *true = x86_expression(expr->cond_true);
-	struct storage *false = x86_expression(expr->cond_false);
+	struct storage *true_expr = x86_expression(expr->cond_true);
+	struct storage *false_expr = x86_expression(expr->cond_false);
 	struct storage *reg_cond, *reg_true, *reg_false;
 	struct storage *new = stack_alloc(4);
 
 	emit_comment("begin SELECT");
 	reg_cond = get_reg_value(cond, get_regclass(expr->conditional));
-	reg_true = get_reg_value(true, get_regclass(expr));
-	reg_false = get_reg_value(false, get_regclass(expr));
+	reg_true = get_reg_value(true_expr, get_regclass(expr));
+	reg_false = get_reg_value(false_expr, get_regclass(expr));
 
 	/*
 	 * Do the actual select: check the conditional for zero,
diff --git a/evaluate.c b/evaluate.c
index f8343c2..a3ac414 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1077,7 +1077,7 @@ OK:
  */
 static struct symbol *evaluate_conditional_expression(struct expression *expr)
 {
-	struct expression **true;
+	struct expression **true_expr;
 	struct symbol *ctype, *ltype, *rtype, *lbase, *rbase;
 	int lclass, rclass;
 	const char * typediff;
@@ -1091,18 +1091,18 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	ctype = degenerate(expr->conditional);
 	rtype = degenerate(expr->cond_false);
 
-	true = &expr->conditional;
+	true_expr = &expr->conditional;
 	ltype = ctype;
 	if (expr->cond_true) {
 		if (!evaluate_expression(expr->cond_true))
 			return NULL;
 		ltype = degenerate(expr->cond_true);
-		true = &expr->cond_true;
+		true_expr = &expr->cond_true;
 	}
 
 	if (expr->flags) {
 		int flags = expr->conditional->flags & Int_const_expr;
-		flags &= (*true)->flags & expr->cond_false->flags;
+		flags &= (*true_expr)->flags & expr->cond_false->flags;
 		if (!flags)
 			expr->flags = 0;
 	}
@@ -1110,27 +1110,27 @@ static struct symbol *evaluate_conditional_expression(struct expression *expr)
 	lclass = classify_type(ltype, &ltype);
 	rclass = classify_type(rtype, &rtype);
 	if (lclass & rclass & TYPE_NUM) {
-		ctype = usual_conversions('?', *true, expr->cond_false,
+		ctype = usual_conversions('?', *true_expr, expr->cond_false,
 					  lclass, rclass, ltype, rtype);
-		*true = cast_to(*true, ctype);
+		*true_expr = cast_to(*true_expr, ctype);
 		expr->cond_false = cast_to(expr->cond_false, ctype);
 		goto out;
 	}
 
 	if ((lclass | rclass) & TYPE_PTR) {
-		int is_null1 = is_null_pointer_constant(*true);
+		int is_null1 = is_null_pointer_constant(*true_expr);
 		int is_null2 = is_null_pointer_constant(expr->cond_false);
 
 		if (is_null1 && is_null2) {
-			*true = cast_to(*true, &ptr_ctype);
+			*true_expr = cast_to(*true_expr, &ptr_ctype);
 			expr->cond_false = cast_to(expr->cond_false, &ptr_ctype);
 			ctype = &ptr_ctype;
 			goto out;
 		}
 		if (is_null1 && (rclass & TYPE_PTR)) {
 			if (is_null1 == 2)
-				bad_null(*true);
-			*true = cast_to(*true, rtype);
+				bad_null(*true_expr);
+			*true_expr = cast_to(*true_expr, rtype);
 			ctype = rtype;
 			goto out;
 		}
@@ -1198,7 +1198,7 @@ Qual:
 		sym->ctype.modifiers |= qual;
 		ctype = sym;
 	}
-	*true = cast_to(*true, ctype);
+	*true_expr = cast_to(*true_expr, ctype);
 	expr->cond_false = cast_to(expr->cond_false, ctype);
 	goto out;
 }
diff --git a/expand.c b/expand.c
index b965dc3..b7a7a67 100644
--- a/expand.c
+++ b/expand.c
@@ -508,27 +508,27 @@ static int expand_compare(struct expression *expr)
 static int expand_conditional(struct expression *expr)
 {
 	struct expression *cond = expr->conditional;
-	struct expression *true = expr->cond_true;
-	struct expression *false = expr->cond_false;
+	struct expression *true_expr = expr->cond_true;
+	struct expression *false_expr = expr->cond_false;
 	int cost, cond_cost;
 
 	cond_cost = expand_expression(cond);
 	if (cond->type == EXPR_VALUE) {
 		unsigned flags = expr->flags;
 		if (!cond->value)
-			true = false;
-		if (!true)
-			true = cond;
-		cost = expand_expression(true);
-		*expr = *true;
+			true_expr = false_expr;
+		if (!true_expr)
+			true_expr = cond;
+		cost = expand_expression(true_expr);
+		*expr = *true_expr;
 		expr->flags = flags;
 		if (expr->type == EXPR_VALUE)
 			expr->taint |= cond->taint;
 		return cost;
 	}
 
-	cost = expand_expression(true);
-	cost += expand_expression(false);
+	cost = expand_expression(true_expr);
+	cost += expand_expression(false_expr);
 
 	if (cost < SELECT_COST) {
 		expr->type = EXPR_SELECT;
diff --git a/flow.c b/flow.c
index 5bd9a1d..aafca03 100644
--- a/flow.c
+++ b/flow.c
@@ -100,7 +100,7 @@ static int try_to_simplify_bb(struct basic_block *bb, struct instruction *first,
 		struct basic_block *source, *target;
 		pseudo_t pseudo;
 		struct instruction *br;
-		int true;
+		int true_value;
 
 		if (!def)
 			continue;
@@ -113,10 +113,10 @@ static int try_to_simplify_bb(struct basic_block *bb, struct instruction *first,
 			continue;
 		if (br->opcode != OP_BR)
 			continue;
-		true = pseudo_truth_value(pseudo);
-		if (true < 0)
+		true_value = pseudo_truth_value(pseudo);
+		if (true_value < 0)
 			continue;
-		target = true ? second->bb_true : second->bb_false;
+		target = true_value ? second->bb_true : second->bb_false;
 		if (bb_depends_on(target, bb))
 			continue;
 		changed |= rewrite_branch(source, &br->bb_true, bb, target);
@@ -165,7 +165,7 @@ static int simplify_phi_branch(struct basic_block *bb, struct instruction *br)
 }
 
 static int simplify_branch_branch(struct basic_block *bb, struct instruction *br,
-	struct basic_block **target_p, int true)
+	struct basic_block **target_p, int true_expr)
 {
 	struct basic_block *target = *target_p, *final;
 	struct instruction *insn;
@@ -181,7 +181,7 @@ static int simplify_branch_branch(struct basic_block *bb, struct instruction *br
 	 * Now we just need to see if we can rewrite the branch..
 	 */
 	retval = 0;
-	final = true ? insn->bb_true : insn->bb_false;
+	final = true_expr ? insn->bb_true : insn->bb_false;
 	if (bb_has_side_effects(target))
 		goto try_to_rewrite_target;
 	if (bb_depends_on(final, target))
@@ -823,13 +823,13 @@ static struct basic_block * rewrite_branch_bb(struct basic_block *bb, struct ins
 {
 	struct basic_block *parent;
 	struct basic_block *target = br->bb_true;
-	struct basic_block *false = br->bb_false;
+	struct basic_block *false_expr = br->bb_false;
 
-	if (target && false) {
+	if (target && false_expr) {
 		pseudo_t cond = br->cond;
 		if (cond->type != PSEUDO_VAL)
 			return NULL;
-		target = cond->value ? target : false;
+		target = cond->value ? target : false_expr;
 	}
 
 	/*
diff --git a/inline.c b/inline.c
index 860c0ee..8fa5a7a 100644
--- a/inline.c
+++ b/inline.c
@@ -162,14 +162,14 @@ static struct expression * copy_expression(struct expression *expr)
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL: {
 		struct expression *cond = copy_expression(expr->conditional);
-		struct expression *true = copy_expression(expr->cond_true);
-		struct expression *false = copy_expression(expr->cond_false);
-		if (cond == expr->conditional && true == expr->cond_true && false == expr->cond_false)
+		struct expression *true_expr = copy_expression(expr->cond_true);
+		struct expression *false_expr = copy_expression(expr->cond_false);
+		if (cond == expr->conditional && true_expr == expr->cond_true && false_expr == expr->cond_false)
 			break;
 		expr = dup_expression(expr);
 		expr->conditional = cond;
-		expr->cond_true = true;
-		expr->cond_false = false;
+		expr->cond_true = true_expr;
+		expr->cond_false = false_expr;
 		break;
 	}
 
@@ -353,20 +353,20 @@ static struct statement *copy_one_statement(struct statement *stmt)
 	}
 	case STMT_IF: {
 		struct expression *cond = stmt->if_conditional;
-		struct statement *true = stmt->if_true;
-		struct statement *false = stmt->if_false;
+		struct statement *true_expr = stmt->if_true;
+		struct statement *false_expr = stmt->if_false;
 
 		cond = copy_expression(cond);
-		true = copy_one_statement(true);
-		false = copy_one_statement(false);
+		true_expr = copy_one_statement(true_expr);
+		false_expr = copy_one_statement(false_expr);
 		if (stmt->if_conditional == cond &&
-		    stmt->if_true == true &&
-		    stmt->if_false == false)
+		    stmt->if_true == true_expr &&
+		    stmt->if_false == false_expr)
 			break;
 		stmt = dup_statement(stmt);
 		stmt->if_conditional = cond;
-		stmt->if_true = true;
-		stmt->if_false = false;
+		stmt->if_true = true_expr;
+		stmt->if_false = false_expr;
 		break;
 	}
 	case STMT_RETURN: {
diff --git a/linearize.c b/linearize.c
index f2034ce..94d5ea2 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1287,19 +1287,19 @@ pseudo_t linearize_cond_branch(struct entrypoint *ep, struct expression *expr, s
 
 static pseudo_t linearize_select(struct entrypoint *ep, struct expression *expr)
 {
-	pseudo_t cond, true, false, res;
+	pseudo_t cond, true_expr, false_expr, res;
 	struct instruction *insn;
 
-	true = linearize_expression(ep, expr->cond_true);
-	false = linearize_expression(ep, expr->cond_false);
+	true_expr = linearize_expression(ep, expr->cond_true);
+	false_expr = linearize_expression(ep, expr->cond_false);
 	cond = linearize_expression(ep, expr->conditional);
 
 	insn = alloc_typed_instruction(OP_SEL, expr->ctype);
 	if (!expr->cond_true)
-		true = cond;
+		true_expr = cond;
 	use_pseudo(insn, cond, &insn->src1);
-	use_pseudo(insn, true, &insn->src2);
-	use_pseudo(insn, false, &insn->src3);
+	use_pseudo(insn, true_expr, &insn->src2);
+	use_pseudo(insn, false_expr, &insn->src3);
 
 	res = alloc_pseudo(insn);
 	insn->target = res;
diff --git a/pre-process.c b/pre-process.c
index 656acaa..56ddcb6 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -1236,13 +1236,13 @@ static int handle_strong_undef(struct stream *stream, struct token **line, struc
 	return do_handle_undef(stream, line, token, SYM_ATTR_STRONG);
 }
 
-static int preprocessor_if(struct stream *stream, struct token *token, int true)
+static int preprocessor_if(struct stream *stream, struct token *token, int condition_is_true)
 {
 	token_type(token) = false_nesting ? TOKEN_SKIP_GROUPS : TOKEN_IF;
 	free_preprocessor_line(token->next);
 	token->next = stream->top_if;
 	stream->top_if = token;
-	if (false_nesting || true != 1)
+	if (false_nesting || condition_is_true != 1)
 		false_nesting++;
 	return 0;
 }
diff --git a/show-parse.c b/show-parse.c
index c97debe..fb84bdc 100644
--- a/show-parse.c
+++ b/show-parse.c
@@ -1001,11 +1001,11 @@ static int show_label_expr(struct expression *expr)
 static int show_conditional_expr(struct expression *expr)
 {
 	int cond = show_expression(expr->conditional);
-	int true = show_expression(expr->cond_true);
-	int false = show_expression(expr->cond_false);
+	int true_expr = show_expression(expr->cond_true);
+	int false_expr = show_expression(expr->cond_false);
 	int new = new_pseudo();
 
-	printf("[v%d]\tcmov.%d\t\tv%d,v%d,v%d\n", cond, expr->ctype->bit_size, new, true, false);
+	printf("[v%d]\tcmov.%d\t\tv%d,v%d,v%d\n", cond, expr->ctype->bit_size, new, true_expr, false_expr);
 	return new;
 }
 
diff --git a/simplify.c b/simplify.c
index 8200584..68eeb45 100644
--- a/simplify.c
+++ b/simplify.c
@@ -780,10 +780,10 @@ static int simplify_cond_branch(struct instruction *br, pseudo_t cond, struct in
 	use_pseudo(br, *pp, &br->cond);
 	remove_usage(cond, &br->cond);
 	if (def->opcode == OP_SET_EQ) {
-		struct basic_block *true = br->bb_true;
-		struct basic_block *false = br->bb_false;
-		br->bb_false = true;
-		br->bb_true = false;
+		struct basic_block *true_expr = br->bb_true;
+		struct basic_block *false_expr = br->bb_false;
+		br->bb_false = true_expr;
+		br->bb_true = false_expr;
 	}
 	return REPEAT_CSE;
 }
@@ -836,10 +836,10 @@ static int simplify_branch(struct instruction *insn)
 					return REPEAT_CSE;
 				}
 				if (val2) {
-					struct basic_block *true = insn->bb_true;
-					struct basic_block *false = insn->bb_false;
-					insn->bb_false = true;
-					insn->bb_true = false;
+					struct basic_block *true_expr = insn->bb_true;
+					struct basic_block *false_expr = insn->bb_false;
+					insn->bb_false = true_expr;
+					insn->bb_true = false_expr;
 				}
 				use_pseudo(insn, def->src1, &insn->cond);
 				remove_usage(cond, &insn->cond);
-- 
1.7.2.3


--=-QNCxE5A9XGayUpIR+y09--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Fri, 05 Nov 2010 00:57:47 +0000
Message-ID: <AANLkTinmmLf9dMvLfWk09kGV6RbEo9HMV8ds=yGEQyMw () mail ! gmail ! com>
--------------------
On Fri, Oct 29, 2010 at 6:22 AM, Bernd Petrovitsch <bernd@sysprog.at> wrote:
>
> Voila.

-               struct basic_block *true = br->bb_true;
-               struct basic_block *false = br->bb_false;
-               br->bb_false = true;
-               br->bb_true = false;
+               struct basic_block *true_expr = br->bb_true;
+               struct basic_block *false_expr = br->bb_false;
+               br->bb_false = true_expr;
+               br->bb_true = false_expr;

Hmm, not very "true" symbol is an expression type. You end up calling
basicl_block pointer as true_expr, that is misleading.
Same thing happen to pseudo_t pointers.

Looks fine otherwise.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Tue, 09 Nov 2010 22:52:09 +0000
Message-ID: <AANLkTi=Z2J24+ECrLFDY6PQZOi04C1ecLPvhorbSUut4 () mail ! gmail ! com>
--------------------
On Tue, Nov 9, 2010 at 5:28 AM, Bernd Petrovitsch <bernd@sysprog.at> wrote:
> Frankly, I don't understand what you mean (especially with the pseudo_t)
> - which also explains why the suboptimal variable naming and I cannot
> come up with a better name.

Oh, sorry for the confusion. I mean the you can use some thing like:
true_pseudo and
false_pseudo instead of calling it expressions. Pseduo is not an expression.

I will make that adjustment for you and post the patch on the list. If Al don't
complain I will submit it. All right?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () sysprog ! at>
To: linux-sparse
Subject: Re: including sparse headers in C++ code
Date: Wed, 10 Nov 2010 10:52:17 +0000
Message-ID: <1289386337.2606.0.camel () thorin>
--------------------
On Die, 2010-11-09 at 14:52 -0800, Christopher Li wrote: 
> On Tue, Nov 9, 2010 at 5:28 AM, Bernd Petrovitsch <bernd@sysprog.at> wrote:
> > Frankly, I don't understand what you mean (especially with the pseudo_t)
> > - which also explains why the suboptimal variable naming and I cannot
> > come up with a better name.
> 
> Oh, sorry for the confusion. I mean the you can use some thing like:
> true_pseudo and
> false_pseudo instead of calling it expressions. Pseduo is not an expression.
> 
> I will make that adjustment for you and post the patch on the list. If Al don't
> complain I will submit it. All right?

Yes, please.
Signed-off-by: Bernd Petrovitsch <bernd@sysprog.at>

Bernd
-- 
mobile: +43 664 4416156              http://www.sysprog.at/
    Linux Software Development, Consulting and Services

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: linux kernel warnings/errors ===

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: linux kernel warnings/errors
Date: Tue, 23 Feb 2010 20:59:42 +0000
Message-ID: <20100223205942.GA32491 () feather>
--------------------
On Tue, Feb 23, 2010 at 11:49:06AM -0800, Randy Dunlap wrote:
> Hi,
> 
> You probably know that sparse produces a ton of errors & warnings when
> run on the Linux kernel tree (a little over 1 MB in my latest 'make C=1'
> on x86_64 arch.).
> 
> I'm wondering if all of these are valid.
> 
> Examples:
> 
> 
> 1.  Use of the BUILD_BUG_ON() macro causes this error from sparse:
> 
> arch/x86/kernel/paravirt.c:101:9: error: invalid bitfield width, -1.
> 
> include/linux/kernel.h:
> 
> /* Force a compilation error if condition is true */
> #define BUILD_BUG_ON(condition) ((void)BUILD_BUG_ON_ZERO(condition))
> 
> /* Force a compilation error if condition is true, but also produce a
>    result (of value 0 and type size_t), so the expression can be used
>    e.g. in a structure initializer (or where-ever else comma expressions
>    aren't permitted). */
> #define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))

In theory that should only happen if the BUILD_BUG_ON_ZERO actually
triggers, and thus sparse fails to build just as GCC would.  If sparse
has this problem and GCC doesn't, could you please provide a minimal
test case?

> 2.  drivers/block/drbd/drbd_int.h uses __protected_by(var);
> this seems to be unknown to sparse.
> 
> #ifdef __CHECKER__
> # define __protected_by(x)       __attribute__((require_context(x,1,999,"rdwr")))
> 
> sparse says many times:
> 
> drivers/block/drbd/drbd_int.h:887:39: error: attribute 'require_context': unknown attribute

That looks broken.  A few patches went around for new Sparse
context-tracking features, one of which got reverted before the 0.4.2
release, but I don't think any of them would have allowed *that*.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: linux kernel warnings/errors
Date: Tue, 23 Feb 2010 22:20:49 +0000
Message-ID: <4B8454C1.6010402 () xenotime ! net>
--------------------
This is a multi-part message in MIME format.
--------------060107030101060204000403
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

On 02/23/10 12:59, Josh Triplett wrote:
> On Tue, Feb 23, 2010 at 11:49:06AM -0800, Randy Dunlap wrote:
>> Hi,
>>
>> You probably know that sparse produces a ton of errors & warnings when
>> run on the Linux kernel tree (a little over 1 MB in my latest 'make C=1'
>> on x86_64 arch.).
>>
>> I'm wondering if all of these are valid.
>>
>> Examples:
>>
>>
>> 1.  Use of the BUILD_BUG_ON() macro causes this error from sparse:
>>
>> arch/x86/kernel/paravirt.c:101:9: error: invalid bitfield width, -1.
>>
>> include/linux/kernel.h:
>>
>> /* Force a compilation error if condition is true */
>> #define BUILD_BUG_ON(condition) ((void)BUILD_BUG_ON_ZERO(condition))
>>
>> /* Force a compilation error if condition is true, but also produce a
>>    result (of value 0 and type size_t), so the expression can be used
>>    e.g. in a structure initializer (or where-ever else comma expressions
>>    aren't permitted). */
>> #define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
> 
> In theory that should only happen if the BUILD_BUG_ON_ZERO actually
> triggers, and thus sparse fails to build just as GCC would.  If sparse
> has this problem and GCC doesn't, could you please provide a minimal
> test case?

Sure, attached.


>> 2.  drivers/block/drbd/drbd_int.h uses __protected_by(var);
>> this seems to be unknown to sparse.
>>
>> #ifdef __CHECKER__
>> # define __protected_by(x)       __attribute__((require_context(x,1,999,"rdwr")))
>>
>> sparse says many times:
>>
>> drivers/block/drbd/drbd_int.h:887:39: error: attribute 'require_context': unknown attribute
> 
> That looks broken.  A few patches went around for new Sparse
> context-tracking features, one of which got reverted before the 0.4.2
> release, but I don't think any of them would have allowed *that*.

Yeah, I recall seeing some of the context patches.

Thanks.
-- 
~Randy

--------------060107030101060204000403
Content-Type: text/x-csrc;
 name="build_bug_on.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="build_bug_on.c"

/* Force a compilation error if condition is true */
#define BUILD_BUG_ON(condition) ((void)BUILD_BUG_ON_ZERO(condition))

/* Force a compilation error if condition is true, but also produce a
   result (of value 0 and type size_t), so the expression can be used
   e.g. in a structure initializer (or where-ever else comma expressions
   aren't permitted). */
#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))

struct branch {
	unsigned char opcode;
	int delta;
} __attribute__((packed));

unsigned paravirt_patch_call(void *insnbuf)
{
	struct branch *b = insnbuf;

	b->opcode = 0xe8; /* call */
	b->delta = 0x1234;
	BUILD_BUG_ON(sizeof(*b) != 5);

	return 5;
}

int main(int argc, char *argv[])
{
}

--------------060107030101060204000403--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: linux kernel warnings/errors (#7) ===

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: linux kernel warnings/errors (#7)
Date: Tue, 23 Feb 2010 22:40:03 +0000
Message-ID: <4B845943.10507 () xenotime ! net>
--------------------
On 02/23/10 11:49, Randy Dunlap wrote:
> Hi,
> 
> You probably know that sparse produces a ton of errors & warnings when
> run on the Linux kernel tree (a little over 1 MB in my latest 'make C=1'
> on x86_64 arch.).
> 
> I'm wondering if all of these are valid.
> 
> Examples:

(one addition)


7.  from drivers/gpu/drm/radeon/atombios.h:

#define VESA_OEM_PRODUCT_REV			            '01.00'
#define VESA_MODE_ATTRIBUTE_MODE_SUPPORT	     0xBB	/* refer to VBE spec p.32, no TTY support */


causes sparse to say:

drivers/gpu/drm/radeon/atombios.h:4091:63: error: Bad character constant
drivers/gpu/drm/radeon/atombios.h:4092:1: error: Bad character constant


That second one is a bit confusing.  It's just a remnant of the first one...

-- 
~Randy
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: linux kernel warnings/errors (#8) ===

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: linux kernel warnings/errors (#8)
Date: Wed, 24 Feb 2010 00:55:29 +0000
Message-ID: <4B847901.2050803 () xenotime ! net>
--------------------
This is a multi-part message in MIME format.
--------------090705020802090902050503
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

On 02/23/10 11:49, Randy Dunlap wrote:
> Hi,
> 
> You probably know that sparse produces a ton of errors & warnings when
> run on the Linux kernel tree (a little over 1 MB in my latest 'make C=1'
> on x86_64 arch.).
> 
> I'm wondering if all of these are valid.
> 
> Examples:


8.  There are many cases of sparse "error: bad integer constant expression"
that gcc handles without a problem, when the constant expression uses a
macro or static inline function:

a.  drivers/gpu/drm/drm_drv.c:59:9: error: bad integer constant expression

static struct drm_ioctl_desc drm_ioctls[] = {
	DRM_IOCTL_DEF(DRM_IOCTL_VERSION, drm_version, 0),

b.  drivers/media/video/v4l2-ioctl.c:185:10: error: bad integer constant expression

static const char *v4l1_ioctls[] = {
	[_IOC_NR(VIDIOCGCAP)]       = "VIDIOCGCAP",
};

c.  fs/proc/array.c:154:9: error: bad integer constant expression

	BUILD_BUG_ON(1 + ilog2(TASK_STATE_MAX) != ARRAY_SIZE(task_state_array));

d.  sound/pci/hda/hda_proc.c:422:18: error: bad integer constant expression

	static char *names[] = {
		[ilog2(AC_PWRST_D0SUP)]		= "D0",
	};

e.  drivers/gpu/drm/drm_ioc32.c:1017:10: error: bad integer constant expression

drm_ioctl_compat_t *drm_compat_ioctls[] = {
	[DRM_IOCTL_NR(DRM_IOCTL_VERSION32)] = compat_drm_version,
};


I have a test case for "d." above.
(attached)

> sparse  const_sound.c 
const_sound.c:114:18: error: bad integer constant expression



-- 
~Randy

--------------090705020802090902050503
Content-Type: text/x-csrc;
 name="const_sound.c"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="const_sound.c"

#include <asm-generic/ioctl.h>


static inline __attribute__((const))
int fls(unsigned int n)
{
	return 0;
}

static inline __attribute__((const))
int fls64(unsigned int n)
{
	return 63;
}

static inline __attribute__((const))
int __ilog2_u32(unsigned int n)
{
	return fls(n) - 1;
}

static inline __attribute__((const))
int __ilog2_u64(unsigned long n)
{
	return fls64(n) - 1;
}

static inline __attribute__((const))
int ____ilog2_NaN(void)
{
	return -1;
}

#define ilog2(n)				\
(						\
	__builtin_constant_p(n) ? (		\
		(n) < 1 ? ____ilog2_NaN() :	\
		(n) & (1ULL << 63) ? 63 :	\
		(n) & (1ULL << 62) ? 62 :	\
		(n) & (1ULL << 61) ? 61 :	\
		(n) & (1ULL << 60) ? 60 :	\
		(n) & (1ULL << 59) ? 59 :	\
		(n) & (1ULL << 58) ? 58 :	\
		(n) & (1ULL << 57) ? 57 :	\
		(n) & (1ULL << 56) ? 56 :	\
		(n) & (1ULL << 55) ? 55 :	\
		(n) & (1ULL << 54) ? 54 :	\
		(n) & (1ULL << 53) ? 53 :	\
		(n) & (1ULL << 52) ? 52 :	\
		(n) & (1ULL << 51) ? 51 :	\
		(n) & (1ULL << 50) ? 50 :	\
		(n) & (1ULL << 49) ? 49 :	\
		(n) & (1ULL << 48) ? 48 :	\
		(n) & (1ULL << 47) ? 47 :	\
		(n) & (1ULL << 46) ? 46 :	\
		(n) & (1ULL << 45) ? 45 :	\
		(n) & (1ULL << 44) ? 44 :	\
		(n) & (1ULL << 43) ? 43 :	\
		(n) & (1ULL << 42) ? 42 :	\
		(n) & (1ULL << 41) ? 41 :	\
		(n) & (1ULL << 40) ? 40 :	\
		(n) & (1ULL << 39) ? 39 :	\
		(n) & (1ULL << 38) ? 38 :	\
		(n) & (1ULL << 37) ? 37 :	\
		(n) & (1ULL << 36) ? 36 :	\
		(n) & (1ULL << 35) ? 35 :	\
		(n) & (1ULL << 34) ? 34 :	\
		(n) & (1ULL << 33) ? 33 :	\
		(n) & (1ULL << 32) ? 32 :	\
		(n) & (1ULL << 31) ? 31 :	\
		(n) & (1ULL << 30) ? 30 :	\
		(n) & (1ULL << 29) ? 29 :	\
		(n) & (1ULL << 28) ? 28 :	\
		(n) & (1ULL << 27) ? 27 :	\
		(n) & (1ULL << 26) ? 26 :	\
		(n) & (1ULL << 25) ? 25 :	\
		(n) & (1ULL << 24) ? 24 :	\
		(n) & (1ULL << 23) ? 23 :	\
		(n) & (1ULL << 22) ? 22 :	\
		(n) & (1ULL << 21) ? 21 :	\
		(n) & (1ULL << 20) ? 20 :	\
		(n) & (1ULL << 19) ? 19 :	\
		(n) & (1ULL << 18) ? 18 :	\
		(n) & (1ULL << 17) ? 17 :	\
		(n) & (1ULL << 16) ? 16 :	\
		(n) & (1ULL << 15) ? 15 :	\
		(n) & (1ULL << 14) ? 14 :	\
		(n) & (1ULL << 13) ? 13 :	\
		(n) & (1ULL << 12) ? 12 :	\
		(n) & (1ULL << 11) ? 11 :	\
		(n) & (1ULL << 10) ? 10 :	\
		(n) & (1ULL <<  9) ?  9 :	\
		(n) & (1ULL <<  8) ?  8 :	\
		(n) & (1ULL <<  7) ?  7 :	\
		(n) & (1ULL <<  6) ?  6 :	\
		(n) & (1ULL <<  5) ?  5 :	\
		(n) & (1ULL <<  4) ?  4 :	\
		(n) & (1ULL <<  3) ?  3 :	\
		(n) & (1ULL <<  2) ?  2 :	\
		(n) & (1ULL <<  1) ?  1 :	\
		(n) & (1ULL <<  0) ?  0 :	\
		____ilog2_NaN()			\
				   ) :		\
	(sizeof(n) <= 4) ?			\
	__ilog2_u32(n) :			\
	__ilog2_u64(n)				\
 )

// d.  sound/pci/hda/hda_proc.c:422:18: error: bad integer constant expression

#define AC_PWRST_D0SUP			(1<<0)

	static char *names[] = {
		[ilog2(AC_PWRST_D0SUP)]		= "D0",
	};


int main(int argc, char *argv[])
{
}

--------------090705020802090902050503--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: segfault in sparse snapshot 2010-02-13 ===

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: segfault in sparse snapshot 2010-02-13
Date: Wed, 24 Mar 2010 17:41:44 +0000
Message-ID: <20100324104144.0817c22b.rdunlap () xenotime ! net>
--------------------
(snapshot from Dave Jones:
  http://www.codemonkey.org.uk/projects/git-snapshots/sparse/ )


In the linux-next-20100324 or akpm's kernel patchset (mmotm-2010-03-23),
sparse segfaults when checking net/bridge/br_fdb.c. (does not happen in
Linus's mainline kernel tree)


The last messages are:

net/bridge/br_fdb.c:225:9: error: no member 'hash' in struct net_bridge
net/bridge/br_fdb.c:225:9: error: incompatible types for operation (+)
net/bridge/br_fdb.c:225:9:    left side has type bad type
net/bridge/br_fdb.c:225:9:    right side has type int
net/bridge/br_fdb.c:225:9: error: cannot dereference this type
/bin/sh: line 1: 28041 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -D__x86_64__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -Wp,-MD,net/bridge/.br_fdb.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -I/lnx/src/NEXT/linux-next-20100324/arch/x86/include -Iinclude -I/lnx/src/NEXT/linux-next-20100324/include -include include/generated/autoconf.h -I/lnx/src/NEXT/linux-next-20100324/net/bridge -Inet/bridge -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -m64 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -fstack-protector -fno-builtin-memcpy -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-larger-than=2048 -fno-omit-frame-pointer -fno-optimize-sibling-calls -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -fprofile-arcs -ftest-coverage -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(br_fdb)" -D"KBUILD_MODNAME=KBUILD_STR(bridge)" -D"DEBUG_HASH=21" -D"DEBUG_HASH2=11" /lnx/src/NEXT/linux-next-20100324/net/bridge/br_fdb.c
make[3]: *** [net/bridge/br_fdb.o] Error 139


---
~Randy
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Wed, 24 Mar 2010 19:36:22 +0000
Message-ID: <20100324193622.GC4331 () feather>
--------------------
On Wed, Mar 24, 2010 at 10:41:44AM -0700, Randy Dunlap wrote:
> (snapshot from Dave Jones:
>   http://www.codemonkey.org.uk/projects/git-snapshots/sparse/ )
> 
> 
> In the linux-next-20100324 or akpm's kernel patchset (mmotm-2010-03-23),
> sparse segfaults when checking net/bridge/br_fdb.c. (does not happen in
> Linus's mainline kernel tree)
> 
> 
> The last messages are:
> 
> net/bridge/br_fdb.c:225:9: error: no member 'hash' in struct net_bridge
> net/bridge/br_fdb.c:225:9: error: incompatible types for operation (+)
> net/bridge/br_fdb.c:225:9:    left side has type bad type
> net/bridge/br_fdb.c:225:9:    right side has type int
> net/bridge/br_fdb.c:225:9: error: cannot dereference this type
> /bin/sh: line 1: 28041 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -D__x86_64__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -Wp,-MD,net/bridge/.br_fdb.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -I/lnx/src/NEXT/linux-next-20100324/arch/x86/include -Iinclude -I/lnx/src/NEXT/linux-next-20100324/include -include include/generated/autoconf.h -I/lnx/src/NEXT/linux-next-20100324/net/bridge -Inet/bridge -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -m64 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -fstack-protector -fno-builtin-memcpy -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wframe-
>  larger-than=2048 -fno-omit-frame-pointer -fno-optimize-sibling-calls -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -fprofile-arcs -ftest-coverage -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(br_fdb)" -D"KBUILD_MODNAME=KBUILD_STR(bridge)" -D"DEBUG_HASH=21" -D"DEBUG_HASH2=11" /lnx/src/NEXT/linux-next-20100324/net/bridge/br_fdb.c
> make[3]: *** [net/bridge/br_fdb.o] Error 139

Ouch.

Can you attach a preprocessed source .i file that reproduces the
problem? "make net/bridge/br_fdb.i" should work.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Wed, 24 Mar 2010 21:01:47 +0000
Message-ID: <4BAA7DBB.4000201 () xenotime ! net>
--------------------
On 03/24/10 13:34, Josh Triplett wrote:
> On Wed, Mar 24, 2010 at 12:47:24PM -0700, Randy Dunlap wrote:
>> On 03/24/10 12:36, Josh Triplett wrote:
>>> On Wed, Mar 24, 2010 at 10:41:44AM -0700, Randy Dunlap wrote:
>>>> (snapshot from Dave Jones:
>>>>   http://www.codemonkey.org.uk/projects/git-snapshots/sparse/ )
>>>>
>>>>
>>>> In the linux-next-20100324 or akpm's kernel patchset (mmotm-2010-03-23),
>>>> sparse segfaults when checking net/bridge/br_fdb.c. (does not happen in
>>>> Linus's mainline kernel tree)
>>>>
>>>>
>>>> The last messages are:
>>>>
>>>> net/bridge/br_fdb.c:225:9: error: no member 'hash' in struct net_bridge
>>>> net/bridge/br_fdb.c:225:9: error: incompatible types for operation (+)
>>>> net/bridge/br_fdb.c:225:9:    left side has type bad type
>>>> net/bridge/br_fdb.c:225:9:    right side has type int
>>>> net/bridge/br_fdb.c:225:9: error: cannot dereference this type
>>>> /bin/sh: line 1: 28041 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -D__x86_64__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -Wp,-MD,net/bridge/.br_fdb.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -I/lnx/src/NEXT/linux-next-20100324/arch/x86/include -Iinclude -I/lnx/src/NEXT/linux-next-20100324/include -include include/generated/autoconf.h -I/lnx/src/NEXT/linux-next-20100324/net/bridge -Inet/bridge -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -m64 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -fstack-protector -fno-builtin-memcpy -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wf
ra
>> me-
>>>>  larger-than=2048 -fno-omit-frame-pointer -fno-optimize-sibling-calls -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -fprofile-arcs -ftest-coverage -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(br_fdb)" -D"KBUILD_MODNAME=KBUILD_STR(bridge)" -D"DEBUG_HASH=21" -D"DEBUG_HASH2=11" /lnx/src/NEXT/linux-next-20100324/net/bridge/br_fdb.c
>>>> make[3]: *** [net/bridge/br_fdb.o] Error 139
>>>
>>> Ouch.
>>>
>>> Can you attach a preprocessed source .i file that reproduces the
>>> problem? "make net/bridge/br_fdb.i" should work.
>>
>> Sure, attached.
> 
> I tried to reproduce this segfault with this file and current Sparse
> from Git, and couldn't seem to reproduce it.  I tried the posted command
> line and many variations on it.
> 
> I had to explicitly drop -Wall or add -Wno-shadow to get the code to
> pass Sparse, due to a pile of warnings about ______f and ______r.  Apart
> from that, I didn't see any issue.

OK, maybe I'll blame it on gcc then.  I cloned the current git tree
and still have the sparse segfault...

thanks for looking.

-- 
~Randy
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Randy Dunlap <rdunlap () xenotime ! net>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Wed, 24 Mar 2010 22:02:43 +0000
Message-ID: <4BAA8C03.4050007 () xenotime ! net>
--------------------
On 03/24/10 15:00, Josh Triplett wrote:
> On Wed, Mar 24, 2010 at 02:01:47PM -0700, Randy Dunlap wrote:
>> On 03/24/10 13:34, Josh Triplett wrote:
>>> On Wed, Mar 24, 2010 at 12:47:24PM -0700, Randy Dunlap wrote:
>>>> On 03/24/10 12:36, Josh Triplett wrote:
>>>>> On Wed, Mar 24, 2010 at 10:41:44AM -0700, Randy Dunlap wrote:
>>>>>> (snapshot from Dave Jones:
>>>>>>   http://www.codemonkey.org.uk/projects/git-snapshots/sparse/ )
>>>>>>
>>>>>>
>>>>>> In the linux-next-20100324 or akpm's kernel patchset (mmotm-2010-03-23),
>>>>>> sparse segfaults when checking net/bridge/br_fdb.c. (does not happen in
>>>>>> Linus's mainline kernel tree)
>>>>>>
>>>>>>
>>>>>> The last messages are:
>>>>>>
>>>>>> net/bridge/br_fdb.c:225:9: error: no member 'hash' in struct net_bridge
>>>>>> net/bridge/br_fdb.c:225:9: error: incompatible types for operation (+)
>>>>>> net/bridge/br_fdb.c:225:9:    left side has type bad type
>>>>>> net/bridge/br_fdb.c:225:9:    right side has type int
>>>>>> net/bridge/br_fdb.c:225:9: error: cannot dereference this type
>>>>>> /bin/sh: line 1: 28041 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -D__x86_64__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -Wp,-MD,net/bridge/.br_fdb.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -I/lnx/src/NEXT/linux-next-20100324/arch/x86/include -Iinclude -I/lnx/src/NEXT/linux-next-20100324/include -include include/generated/autoconf.h -I/lnx/src/NEXT/linux-next-20100324/net/bridge -Inet/bridge -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -m64 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -fstack-protector -fno-builtin-memcpy -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -
Wf
>> ra
>>>> me-
>>>>>>  larger-than=2048 -fno-omit-frame-pointer -fno-optimize-sibling-calls -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -fprofile-arcs -ftest-coverage -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(br_fdb)" -D"KBUILD_MODNAME=KBUILD_STR(bridge)" -D"DEBUG_HASH=21" -D"DEBUG_HASH2=11" /lnx/src/NEXT/linux-next-20100324/net/bridge/br_fdb.c
>>>>>> make[3]: *** [net/bridge/br_fdb.o] Error 139
>>>>>
>>>>> Ouch.
>>>>>
>>>>> Can you attach a preprocessed source .i file that reproduces the
>>>>> problem? "make net/bridge/br_fdb.i" should work.
>>>>
>>>> Sure, attached.
>>>
>>> I tried to reproduce this segfault with this file and current Sparse
>>> from Git, and couldn't seem to reproduce it.  I tried the posted command
>>> line and many variations on it.
>>>
>>> I had to explicitly drop -Wall or add -Wno-shadow to get the code to
>>> pass Sparse, due to a pile of warnings about ______f and ______r.  Apart
>>> from that, I didn't see any issue.
>>
>> OK, maybe I'll blame it on gcc then.  I cloned the current git tree
>> and still have the sparse segfault...
>>
>> thanks for looking.
> 
> Can you successfully reproduce the segfault with the .i file, or only
> as part of the kernel build?

Only as part of the kernel build.

-- 
~Randy
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Thu, 25 Mar 2010 10:49:47 +0000
Message-ID: <20100325104947.GC5069 () bicker>
--------------------
On Wed, Mar 24, 2010 at 01:34:29PM -0700, Josh Triplett wrote:
> On Wed, Mar 24, 2010 at 12:47:24PM -0700, Randy Dunlap wrote:
> > On 03/24/10 12:36, Josh Triplett wrote:
> > > On Wed, Mar 24, 2010 at 10:41:44AM -0700, Randy Dunlap wrote:
> > >> (snapshot from Dave Jones:
> > >>   http://www.codemonkey.org.uk/projects/git-snapshots/sparse/ )
> > >>
> > >>
> > >> In the linux-next-20100324 or akpm's kernel patchset (mmotm-2010-03-23),
> > >> sparse segfaults when checking net/bridge/br_fdb.c. (does not happen in
> > >> Linus's mainline kernel tree)
> > >>
> > >>
> > >> The last messages are:
> > >>
> > >> net/bridge/br_fdb.c:225:9: error: no member 'hash' in struct net_bridge
> > >> net/bridge/br_fdb.c:225:9: error: incompatible types for operation (+)
> > >> net/bridge/br_fdb.c:225:9:    left side has type bad type
> > >> net/bridge/br_fdb.c:225:9:    right side has type int
> > >> net/bridge/br_fdb.c:225:9: error: cannot dereference this type
> > >> /bin/sh: line 1: 28041 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -D__x86_64__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -Wp,-MD,net/bridge/.br_fdb.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -I/lnx/src/NEXT/linux-next-20100324/arch/x86/include -Iinclude -I/lnx/src/NEXT/linux-next-20100324/include -include include/generated/autoconf.h -I/lnx/src/NEXT/linux-next-20100324/net/bridge -Inet/bridge -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -m64 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -fstack-protector -fno-builtin-memcpy -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -Wfra
> > me-
> > >>  larger-than=2048 -fno-omit-frame-pointer -fno-optimize-sibling-calls -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -fprofile-arcs -ftest-coverage -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(br_fdb)" -D"KBUILD_MODNAME=KBUILD_STR(bridge)" -D"DEBUG_HASH=21" -D"DEBUG_HASH2=11" /lnx/src/NEXT/linux-next-20100324/net/bridge/br_fdb.c
> > >> make[3]: *** [net/bridge/br_fdb.o] Error 139
> > > 
> > > Ouch.
> > > 
> > > Can you attach a preprocessed source .i file that reproduces the
> > > problem? "make net/bridge/br_fdb.i" should work.
> > 
> > Sure, attached.
> 
> I tried to reproduce this segfault with this file and current Sparse
> from Git, and couldn't seem to reproduce it.  I tried the posted command
> line and many variations on it.
> 
> I had to explicitly drop -Wall or add -Wno-shadow to get the code to
> pass Sparse, due to a pile of warnings about ______f and ______r.  Apart
> from that, I didn't see any issue.

Those are from the __branch_check__ macro in include/linux/compiler.h.
They get turned off if __CHECKER__ is defined, but doing the
"make net/bridge/br_fdb.i" will not have that.

That change could explain why the preprocessed code doesn't segfault.

regards,
dan carpenter

> 
> - Josh Triplett
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Thu, 25 Mar 2010 15:46:15 +0000
Message-ID: <20100325154614.GD30147 () feather>
--------------------
On Thu, Mar 25, 2010 at 01:49:47PM +0300, Dan Carpenter wrote:
> On Wed, Mar 24, 2010 at 01:34:29PM -0700, Josh Triplett wrote:
> > On Wed, Mar 24, 2010 at 12:47:24PM -0700, Randy Dunlap wrote:
> > > On 03/24/10 12:36, Josh Triplett wrote:
> > > > On Wed, Mar 24, 2010 at 10:41:44AM -0700, Randy Dunlap wrote:
> > > >> (snapshot from Dave Jones:
> > > >>   http://www.codemonkey.org.uk/projects/git-snapshots/sparse/ )
> > > >>
> > > >>
> > > >> In the linux-next-20100324 or akpm's kernel patchset (mmotm-2010-03-23),
> > > >> sparse segfaults when checking net/bridge/br_fdb.c. (does not happen in
> > > >> Linus's mainline kernel tree)
> > > >>
> > > >>
> > > >> The last messages are:
> > > >>
> > > >> net/bridge/br_fdb.c:225:9: error: no member 'hash' in struct net_bridge
> > > >> net/bridge/br_fdb.c:225:9: error: incompatible types for operation (+)
> > > >> net/bridge/br_fdb.c:225:9:    left side has type bad type
> > > >> net/bridge/br_fdb.c:225:9:    right side has type int
> > > >> net/bridge/br_fdb.c:225:9: error: cannot dereference this type
> > > >> /bin/sh: line 1: 28041 Segmentation fault      sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -Wno-return-void -D__x86_64__ -m64 -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -Wp,-MD,net/bridge/.br_fdb.o.d -nostdinc -isystem /usr/lib/gcc/x86_64-redhat-linux/4.4.1/include -I/lnx/src/NEXT/linux-next-20100324/arch/x86/include -Iinclude -I/lnx/src/NEXT/linux-next-20100324/include -include include/generated/autoconf.h -I/lnx/src/NEXT/linux-next-20100324/net/bridge -Inet/bridge -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -m64 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -fstack-protector -fno-builtin-memcpy -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -
>  Wfra
> > > me-
> > > >>  larger-than=2048 -fno-omit-frame-pointer -fno-optimize-sibling-calls -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -fprofile-arcs -ftest-coverage -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(br_fdb)" -D"KBUILD_MODNAME=KBUILD_STR(bridge)" -D"DEBUG_HASH=21" -D"DEBUG_HASH2=11" /lnx/src/NEXT/linux-next-20100324/net/bridge/br_fdb.c
> > > >> make[3]: *** [net/bridge/br_fdb.o] Error 139
> > > > 
> > > > Ouch.
> > > > 
> > > > Can you attach a preprocessed source .i file that reproduces the
> > > > problem? "make net/bridge/br_fdb.i" should work.
> > > 
> > > Sure, attached.
> > 
> > I tried to reproduce this segfault with this file and current Sparse
> > from Git, and couldn't seem to reproduce it.  I tried the posted command
> > line and many variations on it.
> > 
> > I had to explicitly drop -Wall or add -Wno-shadow to get the code to
> > pass Sparse, due to a pile of warnings about ______f and ______r.  Apart
> > from that, I didn't see any issue.
> 
> Those are from the __branch_check__ macro in include/linux/compiler.h.
> They get turned off if __CHECKER__ is defined, but doing the
> "make net/bridge/br_fdb.i" will not have that.
> 
> That change could explain why the preprocessed code doesn't segfault.

Good catch!

Randy, could you perhaps add a "#define __CHECKER__" at the top of
br_fdb.c and then do "make net/bridge/br_fdb.i" again?  That *should*
produce a .i file which matches what Sparse would see.  Hopefully we can
reproduce the bug with that.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Thu, 25 Mar 2010 17:20:30 +0000
Message-ID: <70318cbf1003251020j11ad7dd9m5e22b52699265526 () mail ! gmail ! com>
--------------------
On Thu, Mar 25, 2010 at 9:28 AM, Randy Dunlap <rdunlap@xenotime.net> wrote:
>
> OK, I emailed that file, but it's huge -- it probably won't be on the
> mailing list, so I also uploaded it to here:
>  http://www.xenotime.net/linux/doc/br_fdb.i

Thanks, I can duplicate the segfault now.

Looking at it.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Mon, 29 Mar 2010 07:50:31 +0000
Message-ID: <70318cbf1003290050x7f15655ra07edba3668eb4a3 () mail ! gmail ! com>
--------------------
On Thu, Mar 25, 2010 at 10:20 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Mar 25, 2010 at 9:28 AM, Randy Dunlap <rdunlap@xenotime.net> wrote:
>>
>> OK, I emailed that file, but it's huge -- it probably won't be on the
>> mailing list, so I also uploaded it to here:
>>  http://www.xenotime.net/linux/doc/br_fdb.i
>
> Thanks, I can duplicate the segfault now.
>
> Looking at it.

Hi,

I check in a change at.

commit 703499e552b45542a328e3016868419d65143f2b
Author: Christopher <sparse@chrisli.org>
Date:   Sun Mar 28 22:41:49 2010 -0700

    evaluate: check for NULL type inside typeof

    This should fix the segfault report by Randy.
    It still doesn't parse the struct attribute correctly though.

    Signed-off-by: Christopher <sparse@chrisli.org>

diff --git a/evaluate.c b/evaluate.c
index 28bfd7c..cdbd064 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -340,7 +340,9 @@ static inline int classify_type(struct symbol
*type, struct sy
                type = type->ctype.base_type;
        if (type->type == SYM_TYPEOF) {
                type = evaluate_expression(type->initializer);
-               if (type->type == SYM_NODE)
+               if (!type)
+                       type = &bad_ctype;
+               else if (type->type == SYM_NODE)
                        type = type->ctype.base_type;
        }
        if (type->type == SYM_ENUM)


That should stop the segfault. Please verify. More work needs to be done
to parse the struct attribute correctly.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: segfault in sparse snapshot 2010-02-13
Date: Mon, 29 Mar 2010 17:29:10 +0000
Message-ID: <70318cbf1003291029h15b54a56ia1f39781d3986a2d () mail ! gmail ! com>
--------------------
On Mon, Mar 29, 2010 at 9:46 AM, Randy Dunlap <rdunlap@xenotime.net> wrote:
> Hi Chris,
>
> Yes, this gets it past the segfault problem.  Thanks.
>
> [Ju:st had a little trouble applying it because it's full of spaces
> instead of tabs.  Once I realized that, it was no problem.]

You can just pull from the sparse chrisl branch. Sorry I did not make it clear.

Proper parsing the struct foo __attribute__() { ...} is more challenging than
this simple fix. But I guess a NULL pointer check shouldn't hurt for now.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse 0.4.3 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: sparse 0.4.3
Date: Wed, 03 Nov 2010 04:16:28 +0000
Message-ID: <AANLkTikifud_O4moqrqi7zuvH-77tyGtBFeZBAFjdXy_ () mail ! gmail ! com>
--------------------
Hi,

It is finial there. The sparse version 0.4.3 is released.

Mostly small fix up. It can parse the recent kernel better, less noise.

For people interested in the sparse internals, there is a sparse inspecting
tools now. Currently it has limited knowledge of AST. It is very easy to
extent though.

Thanks every one for the contribution.

Chris

--

Bernd Petrovitsch (1):
      Fix a typo - "typdef" is neither C nor plain English

Christopher (3):
      evaluate: check for NULL type inside typeof
      Add test case for builtin_unreachable()
      inspect: add some expression inspection

Christopher Li (15):
      Make MOD_NORETURN fits into 32 bit
      Move noreturn attribute out of ignore attr area
      Declare ignored attributres into a list of string.
      Simplify Makefile using static pattern rules
      Adding test case for "x && y && z" .
      Pointer don't inherent the alignment from base type
      Allow parsing L'\0'
      Parsing wide char string
      Adding asm goto label test case
      inspect: add custom ast treeview model
      inspect: add some example inspect for symbol and statement
      inspect: Add test-inspect program
      inspect: cast expression
      Fixup and cleanup modifier_string() function.
      sparse 0.4.3 finial

Damien Lespiau (1):
      Ignore the may_alias GCC attribute

Dan Carpenter (1):
      add test-inspect to .gitignore

Dan McGee (1):
      Makefile: fix permissions mixup on install

Daniel De Graaf (1):
      Fix incorrect linearization of "x && y && z"

Jiri Slaby (3):
      parser: add support for asm goto
      parser: fix and simplify support of asm goto
      parser: define __builtin_unreachable

Joel Soete (1):
      possible fix to cgcc issue in sparse 0.4.2:

Josh Triplett (2):
      Rename -Wall to Wsparse-all, so it doesn't get turned on unintentionally
      New attribute designated_init: mark a struct as requiring designated init

Kamil Dudka (1):
      do not ignore attribute 'noreturn'...

Michael Buesch (2):
      ignore attributes "externally_visible" and "signal"
      Ignore "naked" attribute

Michael Stefaniuc (3):
      Ignore the ms_abi/sysv_abi attributes.
      Ignore the alloc_size attribute.
      Handle __builtin_ms_va_list.

Mike Frysinger (1):
      parser: add Blackfin gcc info

Morten Welinder (1):
      skip may_alias and declare builtin_fabs
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse 2.4.3-rc1 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: sparse 2.4.3-rc1
Date: Fri, 08 Oct 2010 23:54:37 +0000
Message-ID: <AANLkTin4yz3GdHQiWGJZ8yoVTvJbn6CpTzE7y=t868cr () mail ! gmail ! com>
--------------------
It is about time to get another sparse release.
Mostly small fix up. Some help to reduce the noise level on recent
kernel checking.

For people interested in the sparse internals, there is a sparse inspecting
tools now. Currently it has limited knowledge of AST. It is very easy to
extent though.

Give it a try and report back any problem you have.

Chris

--

Bernd Petrovitsch (1):
      Fix a typo - "typdef" is neither C nor plain English

Christopher (3):
      evaluate: check for NULL type inside typeof
      Add test case for builtin_unreachable()
      inspect: add some expression inspection

Christopher Li (15):
      Make MOD_NORETURN fits into 32 bit
      Move noreturn attribute out of ignore attr area
      Declare ignored attributres into a list of string.
      Simplify Makefile using static pattern rules
      Adding test case for "x && y && z" .
      Pointer don't inherent the alignment from base type
      Allow parsing L'\0'
      Parsing wide char string
      Adding asm goto label test case
      inspect: add custom ast treeview model
      inspect: add some example inspect for symbol and statement
      inspect: Add test-inspect program
      inspect: cast expression
      Fixup and cleanup modifier_string() function.
      sparse 4.2.3-rc1

Damien Lespiau (1):
      Ignore the may_alias GCC attribute

Dan Carpenter (1):
      add test-inspect to .gitignore

Dan McGee (1):
      Makefile: fix permissions mixup on install

Daniel De Graaf (1):
      Fix incorrect linearization of "x && y && z"

Jiri Slaby (3):
      parser: add support for asm goto
      parser: fix and simplify support of asm goto
      parser: define __builtin_unreachable

Joel Soete (1):
      possible fix to cgcc issue in sparse 0.4.2:

Josh Triplett (2):
      Rename -Wall to Wsparse-all, so it doesn't get turned on unintentionally
      New attribute designated_init: mark a struct as requiring designated init

Kamil Dudka (1):
      do not ignore attribute 'noreturn'...

Michael Buesch (2):
      ignore attributes "externally_visible" and "signal"
      Ignore "naked" attribute

Michael Stefaniuc (3):
      Ignore the ms_abi/sysv_abi attributes.
      Ignore the alloc_size attribute.
      Handle __builtin_ms_va_list.

Mike Frysinger (1):
      parser: add Blackfin gcc info

Morten Welinder (1):
      skip may_alias and declare builtin_fabs
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: typedefs and alignment ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: typedefs and alignment
Date: Wed, 10 Feb 2010 01:36:27 +0000
Message-ID: <70318cbf1002091736s3ca92377pfc97c2fcf9e15478 () mail ! gmail ! com>
--------------------
On Mon, Feb 8, 2010 at 2:35 AM, Dan Carpenter <error27@gmail.com> wrote:
> I've found an issue handling typedefs and alignment.  In the appended
> code sparse things 'ptr' has to be aligned so the size of 'bar' is 1024.
> I haven't looked at how to fix this at all, I thought I would ask the
> experts for hints first.

Hmm, there is a bug there.

For the simplified code:

typedef struct aligned_struct {
       int a;
}  __attribute__ ((aligned(1024))) ali_t;

ali_t *ppr;

running test-parsing will show:

.align 1024
struct aligned_struct [usertype] *[addressable] [toplevel] ppr

I am looking at it right now.

Chris



>
> regards,
> dan carpenter
>
> #include <stdio.h>
>
> typedef struct aligned_struct {
>        int a;
> }  __attribute__ ((aligned(1024))) ali_t;
>
> struct foo {
>        int b;
>        ali_t *ptr;
> };

It does look wrong. The easier way to expose it


>
> int mainx(void)
> {
>        struct foo bar;
>
>        printf("%d\n", sizeof(bar));
>        return 0;
> }
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Li <christ.li () gmail ! com>
To: linux-sparse
Subject: Re: typedefs and alignment
Date: Wed, 10 Feb 2010 09:46:39 +0000
Message-ID: <70318cbf1002100146r4b1ae748ida389c688d3fc4ce () mail ! gmail ! com>
--------------------
--00c09f99e37a5601e6047f3be9e0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

On Mon, Feb 8, 2010 at 2:35 AM, Dan Carpenter <error27@gmail.com> wrote:
> I've found an issue handling typedefs and alignment. =A0In the appended
> code sparse things 'ptr' has to be aligned so the size of 'bar' is 1024.
> I haven't looked at how to fix this at all, I thought I would ask the
> experts for hints first.

Can you try this one line patch?

Thanks

Chris

--00c09f99e37a5601e6047f3be9e0
Content-Type: application/octet-stream; 
	name="0002-Pointer-don-t-inherent-the-alignment-from-base-type.patch"
Content-Disposition: attachment; 
	filename="0002-Pointer-don-t-inherent-the-alignment-from-base-type.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_g5hxp1kd0

RnJvbSAyN2FmMDRjNDcxNjRkNmM2YTQ5ZjY0YzU2OGQyNGQ5OWE5MDJlNDQ5IE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8Y2hyaXNsQGhlbGkuKG5vbmUpPgpE
YXRlOiBXZWQsIDEwIEZlYiAyMDEwIDAxOjMyOjMwIC0wODAwClN1YmplY3Q6IFtQQVRDSCAyLzJd
IFBvaW50ZXIgZG9uJ3QgaW5oZXJlbnQgdGhlIGFsaWdubWVudCBmcm9tIGJhc2UgdHlwZQoKU2ln
bmVkLW9mZi1ieTogQ2hyaXN0b3BoZXIgTGkgPHNwYXJzZUBjaHJpc2xpLm9yZz4KLS0tCiBwYXJz
ZS5jIHwgICAgMSArCiAxIGZpbGVzIGNoYW5nZWQsIDEgaW5zZXJ0aW9ucygrKSwgMCBkZWxldGlv
bnMoLSkKCmRpZmYgLS1naXQgYS9wYXJzZS5jIGIvcGFyc2UuYwppbmRleCA2NmI4MTEyLi5mODFi
MTlmIDEwMDY0NAotLS0gYS9wYXJzZS5jCisrKyBiL3BhcnNlLmMKQEAgLTE2OTgsNiArMTY5OCw3
IEBAIHN0YXRpYyBzdHJ1Y3QgdG9rZW4gKnBvaW50ZXIoc3RydWN0IHRva2VuICp0b2tlbiwgc3Ry
dWN0IGRlY2xfc3RhdGUgKmN0eCkKIAkJY3R4LT5jdHlwZS5iYXNlX3R5cGUgPSBwdHI7CiAJCWN0
eC0+Y3R5cGUuYXMgPSAwOwogCQljdHgtPmN0eXBlLmNvbnRleHRzID0gTlVMTDsKKwkJY3R4LT5j
dHlwZS5hbGlnbm1lbnQgPSAwOwogCiAJCXRva2VuID0gaGFuZGxlX3F1YWxpZmllcnModG9rZW4t
Pm5leHQsIGN0eCk7CiAJCWN0eC0+Y3R5cGUuYmFzZV90eXBlLT5lbmRwb3MgPSB0b2tlbi0+cG9z
OwotLSAKMS42LjIuNQoK
--00c09f99e37a5601e6047f3be9e0--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <error27 () gmail ! com>
To: linux-sparse
Subject: Re: typedefs and alignment
Date: Wed, 10 Feb 2010 10:11:48 +0000
Message-ID: <20100210101148.GD14210 () bicker>
--------------------
On Wed, Feb 10, 2010 at 01:46:39AM -0800, Chris Li wrote:
> On Mon, Feb 8, 2010 at 2:35 AM, Dan Carpenter <error27@gmail.com> wrote:
> > I've found an issue handling typedefs and alignment.  In the appended
> > code sparse things 'ptr' has to be aligned so the size of 'bar' is 1024.
> > I haven't looked at how to fix this at all, I thought I would ask the
> > experts for hints first.
> 
> Can you try this one line patch?
> 

Works great.  Thanks so much.

regards,
dan carpenter

> Thanks
> 
> Chris


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

