--- Emails for Year 2005 ---

=== Thread: [No Subject] ===

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
with absent true part of the conditional and a undefined second part;
but the problem seems very general.

The following patch fix the problem by checking for NULL ep->active, but I suppose
that there is nicer way to solve this problem.

Luc


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1311,7 +1311,7 @@ static pseudo_t linearize_short_conditio
 	pseudo_t phi1, phi2;
 	int size = type_size(expr->ctype);
 
-	if (!expr_false)
+	if (!expr_false || !ep->active)
 		return VOID;
 
 	bb_false = alloc_basic_block(ep, expr_false->pos);
@@ -1337,7 +1337,7 @@ static pseudo_t linearize_conditional(st
 	struct basic_block *bb_true, *bb_false, *merge;
 	int size = type_size(expr->ctype);
 
-	if (!cond || !expr_true || !expr_false)
+	if (!cond || !expr_true || !expr_false || !ep->active)
 		return VOID;
 	bb_true = alloc_basic_block(ep, expr_true->pos);
 	bb_false = alloc_basic_block(ep, expr_false->pos);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
	struct reporter
	{
		void (*r_symdef)(struct symbol*);

		void (*r_symbol)(unsigned mode, struct position*, struct symbol*);
		void (*r_member)(unsigned mode, struct position*, struct symbol*, struct symbol*);
	};

	extern void dissect(struct symbol_list*, struct reporter*);

dissect() walks the output of the sparse_file() and calls reporter's
callbacks.

->r_symdef() is called when the symbol (variable or function) is defined.

->r_symbol() - when the symbol is used in any way. The 'mode' parameter
denotes how this symbol was used. It is a bitmask of possible flags:

	FLAG:		Code example:

	U_R_VAL		return VAR;
	U_W_VAL		VAR = 0;

	U_R_PTR		return *VAR;
	U_W_PTR		*VAR = 0;

	U_R_AOF		const void *... = &VAR;
	U_W_AOF		memset(&VAR, ...);

->r_member() tracks the use of members of structures in the same way.

This patch also adds test-dissect.c, a simple and stupid example. It
prints the 'mode' parameter in a human readable format along with the
storage info, variable's name (or struct_name.member_name), and it's
type.

The 'mode' is dumped as a 3-letter string. The first letter denotes
AOF part, 2-nd - VAL, 3-rd - PTR.

	0			-> '-'
	U_R_xxx			-> 'r'
	U_W_xxx			-> 'w'
	U_R_xxx | U_W_xxx	-> 'm'

Example:
	$ cat -n T.c
	     1  int var;
	     2
	     3  static void func(void)
	     4  {
	     5          int *ptr;
	     6
	     7          ptr = &var;
	     8          *ptr = var;
	     9
	    10          var = *++ptr;
	    11  }

	$ ./test-dissect T.c

	FILE: T.c

	   1:5   g def  var                              int
	   3:13  s def  func                             void (  )( ... )
	   5:6   l def  ptr                              int *
	   7:2   l -w-  ptr                              int *
	   7:9   g m--  var                              int
	   8:3   l --w  ptr                              int *
	   8:9   g -r-  var                              int
	  10:2   g -w-  var                              int
	  10:11  l -mr  ptr                              int *


Note that '*ptr' does not add U_R_VAL flag, this is a feature, not a bug,
even if technically wrong.

dissect() does not check the code for correctness, for example:

	0 = X = Y;

gives this output:

   5:6   g -w-  X                                bad type
   5:10  g -r-  Y                                bad type

Again, X has no U_R_VAL, notabug.


Members of structures usage:

	task_t *tsk;
	tsk->parent->real_parent->pid++;

output:

   7:2   l --r  tsk                              struct task_struct [usertype] *
   7:5   g --r  task_struct.parent               struct task_struct *
   7:13  g --m  task_struct.real_parent          struct task_struct *
   7:26  g -m-  task_struct.pid                  int


dissect() tries to de-anonymize unnamed structures/unions:

     1  struct T {
     2          struct {
     3                  int x, y;
     4          } m;
     5  } t = {
     6          { undeclared }
     7  };

output:

   5:3   g def  t                                struct T
   5:3   g -w-  t                                struct T
   6:2   s -w-  T.m                              struct T:m
   6:4   s -w-  T:m.x                            int
   6:4   g -r-  undeclared                       bad type


Function calls use U_R_PTR bit:

     5          func();
     6          pf = func;
     7          pf();

   5:2   g --r  func                             void (  )( ... )
   6:2   l -w-  pf                               void ( * )( ... )
   6:7   g r--  func                             void (  )( ... )
   7:2   l --r  pf                               void ( * )( ... )


BUGS:

1. dissect() confuses array-in-container with pointer:

     3          struct T { int ary[]; } t;
     4
     5          t.ary[0] = 0;

output:

   5:2   l -r-  t     /* BUG, should be -w- */   struct T
   5:3   s -w-  T.ary                            int [0]

2. It can't detect the case when the address is taken only for writing,
eg: *(&i + 1) = 0, so U_W_AOF always implies U_R_AOF.

3. It does not support "flat" initializers without braces:

     3          struct O {
     4                  struct I {
     5                          int x, y;
     6                  } a, b;
     7          };
     8
     9          struct O o1 = { 1, 2, 3 };

buggy output:

   9:11  l -w-  o1                               struct O
   9:18  s -w-  O.a                              struct I
   9:21  s -w-  O.b                              struct I
   9:24  s -w-  O.?                              bad type

This is ok:

    11          struct O o2 = { { 1 }, .b = { .y = 0 } };

  11:11  l -w-  o2                               struct O
  11:18  s -w-  O.a                              struct I
  11:20  s -w-  I.x                              int
  11:30  s -w-  O.b                              struct I
  11:37  s -w-  I.y                              int

4. test-dissect.c redefines evaluate_symbol_list(), so it can't
be linked statically with libsparse.a.

5. The implementation is far from perfect. It was really done
in "add some code + printf and see what happens" manner, without
studying the sources first. However I beleive it may be useful
for others, that is why I am posting it.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>


 dissect.h      |   40 ++++
 dissect.c      |  547 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 test-dissect.c |   96 ++++++++++
 Makefile       |    9
 4 files changed, 690 insertions(+), 2 deletions(-)


--- /dev/null	2000-01-01 03:00:00.000000000 +0300
+++ git-snapshot-20050818/dissect.h	2005-09-05 00:03:49.000000000 +0400
@@ -0,0 +1,40 @@
+#ifndef	DISSECT_H
+#define	DISSECT_H
+
+#include <stdio.h>
+#include "parse.h"
+#include "expression.h"
+
+#define	U_SHIFT		8
+
+#define	U_R_AOF		0x01
+#define	U_W_AOF		0x02
+
+#define	U_R_VAL		0x04
+#define	U_W_VAL		0x08
+
+#define	U_R_PTR		(U_R_VAL << U_SHIFT)
+#define	U_W_PTR		(U_W_VAL << U_SHIFT)
+
+struct reporter
+{
+	void (*r_symdef)(struct symbol*);
+
+	void (*r_symbol)(unsigned, struct position*, struct symbol*);
+	void (*r_member)(unsigned, struct position*, struct symbol*, struct symbol*);
+};
+
+extern void dissect(struct symbol_list*, struct reporter*);
+
+#define	MK_IDENT(s)	({				\
+	static struct {					\
+		struct ident ident;			\
+		char __[sizeof(s)];			\
+	} ident = {{					\
+		.len  = sizeof(s)-1,			\
+		.name = s,				\
+	}};						\
+	&ident.ident;					\
+})
+
+#endif
--- /dev/null	2000-01-01 03:00:00.000000000 +0300
+++ git-snapshot-20050818/dissect.c	2005-09-04 23:45:27.000000000 +0400
@@ -0,0 +1,547 @@
+/*
+ * sparse/dissect.c
+ *
+ * Started by Oleg Nesterov <oleg@tv-sign.ru>
+ *
+ * Licensed under the Open Software License version 1.1
+ */
+
+#include "dissect.h"
+
+#define	U_VOID	 0x00
+#define	U_SELF	((1 << U_SHIFT) - 1)
+#define	U_MASK	(U_R_VAL | U_W_VAL | U_R_AOF)
+
+#define	DO_LIST(l__, p__, expr__)		\
+	do {					\
+		typeof(l__->list[0]) p__;	\
+		FOR_EACH_PTR(l__, p__)		\
+			expr__;			\
+		END_FOR_EACH_PTR(p__);		\
+	} while (0)
+
+#define	DO_2_LIST(l1__,l2__, p1__,p2__, expr__)	\
+	do {					\
+		typeof(l1__->list[0]) p1__;	\
+		typeof(l2__->list[0]) p2__;	\
+		PREPARE_PTR_LIST(l1__, p1__);	\
+		FOR_EACH_PTR(l2__, p2__)	\
+			expr__;			\
+			NEXT_PTR_LIST(p1__);	\
+		END_FOR_EACH_PTR(p2__);		\
+		FINISH_PTR_LIST(p1__);		\
+	} while (0)
+
+
+typedef unsigned usage_t;
+
+static struct reporter *reporter;
+static struct symbol *return_type;
+
+static void do_sym_list(struct symbol_list *list);
+
+static struct symbol
+	*base_type(struct symbol *sym),
+	*do_initializer(struct symbol *type, struct expression* expr),
+	*do_expression(usage_t mode, struct expression *expr),
+	*do_statement(usage_t mode, struct statement *stmt);
+
+static inline int is_ptr(struct symbol *type)
+{
+	return type->type == SYM_PTR || type->type == SYM_ARRAY;
+}
+
+static inline usage_t u_rval(usage_t mode)
+{
+	return mode & (U_R_VAL | (U_MASK << U_SHIFT))
+		? U_R_VAL : 0;
+}
+
+static inline usage_t u_addr(usage_t mode)
+{
+	return mode = mode & U_MASK
+		? U_R_AOF | (mode & U_W_AOF) : 0;
+}
+
+static usage_t u_lval(struct symbol *type)
+{
+	int wptr = is_ptr(type) && !(type->ctype.modifiers & MOD_CONST);
+	return wptr || type == &bad_ctype
+		? U_W_AOF | U_R_VAL : U_R_VAL;
+}
+
+static usage_t fix_mode(struct symbol *type, usage_t mode)
+{
+	mode &= (U_SELF | (U_SELF << U_SHIFT));
+
+	switch (type->type) {
+		case SYM_BASETYPE:
+			if (!type->ctype.base_type)
+				break;
+		case SYM_ENUM:
+		case SYM_BITFIELD:
+			if (mode & U_MASK)
+				mode &= U_SELF;
+		default:
+
+		break; case SYM_FN:
+			if (mode & U_R_VAL)
+				mode |= U_R_AOF;
+			mode &= ~(U_R_VAL | U_W_AOF);
+
+		break; case SYM_ARRAY:
+			if (mode & (U_MASK << U_SHIFT))
+				mode >>= U_SHIFT;
+			else if (mode != U_W_VAL)
+				mode = u_addr(mode);
+	}
+
+	if (!(mode & U_R_AOF))
+		mode &= ~U_W_AOF;
+
+	return mode;
+}
+
+static inline struct symbol *no_member(struct ident *name)
+{
+	static struct symbol sym = {
+		.type = SYM_BAD,
+	};
+
+	sym.ctype.base_type = &bad_ctype;
+	sym.ident = name;
+
+	return &sym;
+}
+
+static struct symbol *report_member(unsigned mode, struct position *pos,
+					struct symbol *type, struct symbol *mem)
+{
+	struct symbol *ret = mem->ctype.base_type;
+
+	if (reporter->r_member)
+		reporter->r_member(fix_mode(ret, mode), pos, type, mem);
+
+	return ret;
+}
+
+static inline struct symbol *expr_symbol(struct expression *expr)
+{
+	struct symbol *sym = expr->symbol;
+
+	if (!sym) {
+		sym = lookup_symbol(expr->symbol_name, NS_SYMBOL);
+
+		if (!sym) {
+			sym = alloc_symbol(expr->pos, SYM_BAD);
+			bind_symbol(sym, expr->symbol_name, NS_SYMBOL);
+			sym->ctype.modifiers = MOD_EXTERN;
+		}
+	}
+
+	if (!sym->ctype.base_type)
+		sym->ctype.base_type = &bad_ctype;
+
+	return sym;
+}
+
+static struct symbol *report_symbol(usage_t mode, struct expression *expr)
+{
+	struct symbol *sym = expr_symbol(expr);
+//	struct symbol *ret = sym->ctype.base_type;
+	struct symbol *ret = base_type(sym);
+
+	if (0 && ret->type == SYM_ENUM)
+		return report_member(mode, &expr->pos, ret, expr->symbol);
+
+	if (reporter->r_symbol)
+		reporter->r_symbol(fix_mode(ret, mode), &expr->pos, sym);
+
+	return ret;
+}
+
+static inline struct ident *mk_name(struct ident *root, struct ident *node)
+{
+	char name[256];
+
+	snprintf(name, sizeof(name), "%.*s:%.*s",
+			root ? root->len : 0, root->name,
+			node ? node->len : 0, node->name);
+
+	return built_in_ident(name);
+}
+
+static void examine_sym_node(struct symbol *node, struct ident *root)
+{
+	struct symbol *curr, *base;
+
+	if (node->examined)
+		return;
+	node->examined = 1;
+
+	for (curr = node; (base = curr->ctype.base_type); curr = base)
+	{
+		if (base->type == SYM_TYPEOF)
+			base = curr->ctype.base_type =
+				do_expression(U_VOID, base->initializer);
+
+		switch (base->type) {
+		case SYM_FN: case SYM_PTR: case SYM_ARRAY:
+			continue;
+		case SYM_STRUCT: case SYM_UNION: //case SYM_ENUM:
+			if (!base->ident && node->ident)
+				base->ident = mk_name(root, node->ident);
+		default:
+			return;
+		}
+	}
+}
+
+static struct symbol *base_type(struct symbol *sym)
+{
+	if (!sym)
+		return &bad_ctype;
+
+	if (sym->type == SYM_NODE)
+		examine_sym_node(sym, NULL);
+
+	return sym->ctype.base_type	// builtin_fn_type
+		?: &bad_ctype;
+}
+
+static struct symbol *__lookup_member(struct symbol *type, struct ident *name, int *p_addr)
+{
+	struct symbol *node;
+	int addr = 0;
+
+	FOR_EACH_PTR(type->symbol_list, node)
+		if (!name) {
+			if (addr == *p_addr)
+				return node;
+		}
+		else if (node->ident == NULL) {
+			node = __lookup_member(node->ctype.base_type, name, NULL);
+			if (node)
+				goto found;
+		}
+		else if (node->ident == name) {
+found:
+			if (p_addr)
+				*p_addr = addr;
+			return node;
+		}
+		addr++;
+	END_FOR_EACH_PTR(node);
+
+	return NULL;
+}
+
+static struct symbol *lookup_member(struct symbol *type, struct ident *name, int *addr)
+{
+	struct symbol *node = __lookup_member(type, name, addr);
+
+	if (node != NULL)
+		examine_sym_node(node, type->ident);
+	else
+		node = no_member(name);
+
+	return node;
+}
+
+static struct expression *peek_preop(struct expression *expr, int op)
+{
+	do {
+		if (expr->type != EXPR_PREOP)
+			break;
+		if (expr->op == op)
+			return expr->unop;
+		if (expr->op == '(')
+			expr = expr->unop;
+		else
+			break;
+	} while (expr);
+
+	return NULL;
+}
+
+static struct symbol *do_expression(usage_t mode, struct expression *expr)
+{
+	struct symbol *ret = &int_ctype;
+
+again:
+	if (expr) switch (expr->type) {
+	default:
+		warning(expr->pos, "bad expr->type: %d", expr->type);
+
+	case EXPR_TYPE:		// [struct T]; Why ???
+	case EXPR_VALUE:
+	case EXPR_FVALUE:
+
+	break; case EXPR_LABEL:
+		ret = &label_ctype;
+
+	break; case EXPR_STRING:
+		ret = &string_ctype;
+
+	break; case EXPR_STATEMENT:
+		ret = do_statement(mode, expr->statement);
+
+	break; case EXPR_SIZEOF: case EXPR_ALIGNOF: case EXPR_PTRSIZEOF:
+		do_expression(U_VOID, expr->cast_expression);
+
+	break; case EXPR_COMMA:
+		do_expression(U_VOID, expr->left);
+		ret = do_expression(mode, expr->right);
+
+	break; case EXPR_CAST: //case EXPR_IMPLIED_CAST:
+		ret = base_type(expr->cast_type);
+		do_initializer(ret, expr->cast_expression);
+
+	break; case EXPR_COMPARE: case EXPR_LOGICAL:
+		mode = u_rval(mode);
+		do_expression(mode, expr->left);
+		do_expression(mode, expr->right);
+
+	break; case EXPR_CONDITIONAL: //case EXPR_SELECT:
+		do_expression(expr->cond_true
+					? U_R_VAL
+					: U_R_VAL | mode,
+				expr->conditional);
+		ret = do_expression(mode, expr->cond_true);
+		ret = do_expression(mode, expr->cond_false);
+
+	break; case EXPR_CALL:
+		ret = do_expression(U_R_PTR, expr->fn);
+		if (is_ptr(ret))
+			ret = ret->ctype.base_type;
+		DO_2_LIST(ret->arguments, expr->args, arg, val,
+			do_expression(u_lval(base_type(arg)), val));
+		ret = ret->type == SYM_FN ? base_type(ret)
+			: &bad_ctype;
+
+	break; case EXPR_ASSIGNMENT:
+		mode |= U_W_VAL | U_R_VAL;
+		if (expr->op == '=')
+			mode &= ~U_R_VAL;
+		ret = do_expression(mode, expr->left);
+		mode = expr->op == '='
+			? u_lval(ret) : U_R_VAL;
+		do_expression(mode, expr->right);
+
+	break; case EXPR_BINOP: {
+		struct symbol *l, *r;
+		mode |= u_rval(mode);
+		l = do_expression(mode, expr->left);
+		r = do_expression(mode, expr->right);
+		if (expr->op != '+' && expr->op != '-')
+			;
+		else if (!is_ptr_type(r))
+			ret = l;
+		else if (!is_ptr_type(l))
+			ret = r;
+	}
+
+	break; case EXPR_PREOP: case EXPR_POSTOP: {
+		struct expression *unop = expr->unop;
+
+		switch (expr->op) {
+		case SPECIAL_INCREMENT:
+		case SPECIAL_DECREMENT:
+			mode |= U_W_VAL | U_R_VAL;
+		default:
+			mode |= u_rval(mode);
+		case '(':
+			ret = do_expression(mode, unop);
+
+		break; case '&':
+			if ((expr = peek_preop(unop, '*')))
+				goto again;
+			ret = alloc_symbol(unop->pos, SYM_PTR);
+			ret->ctype.base_type =
+				do_expression(u_addr(mode), unop);
+
+		break; case '*':
+			if ((expr = peek_preop(unop, '&')))
+				goto again;
+			if (mode & (U_MASK << U_SHIFT))
+				mode |= U_R_VAL;
+			mode <<= U_SHIFT;
+			if (mode & (U_R_AOF << U_SHIFT))
+				mode |= U_R_VAL;
+			if (mode & (U_W_VAL << U_SHIFT))
+				mode |= U_W_AOF;
+			ret = do_expression(mode, unop);
+			ret = is_ptr(ret) ? base_type(ret)
+				: &bad_ctype;
+		}
+	}
+
+	break; case EXPR_DEREF: {
+		struct symbol *p_type;
+		usage_t p_mode;
+
+		p_mode = mode & U_SELF;
+		if (!(mode & U_MASK) && (mode & (U_MASK << U_SHIFT)))
+			p_mode = U_R_VAL;
+		p_type = do_expression(p_mode, expr->deref);
+
+		ret = report_member(mode, &expr->pos, p_type,
+			lookup_member(p_type, expr->member, NULL));
+	}
+
+	break; case EXPR_SYMBOL:
+		ret = report_symbol(mode, expr);
+	}
+
+	return ret;
+}
+
+static void do_asm_xputs(usage_t mode, struct expression_list *xputs)
+{
+	int nr = 0;
+
+	DO_LIST(xputs, expr,
+		if (++nr % 3 == 0)
+			do_expression(U_W_AOF | mode, expr));
+}
+
+static struct symbol *do_statement(usage_t mode, struct statement *stmt)
+{
+	struct symbol *ret = &void_ctype;
+
+	if (stmt) switch (stmt->type) {
+	default:
+		warning(stmt->pos, "bad stmt->type: %d", stmt->type);
+
+	case STMT_NONE:
+	case STMT_RANGE:
+	case STMT_CONTEXT:
+
+	break; case STMT_EXPRESSION:
+		ret = do_expression(mode, stmt->expression);
+
+	break; case STMT_RETURN:
+		do_expression(u_lval(return_type), stmt->expression);
+
+	break; case STMT_ASM:
+		do_expression(U_R_VAL, stmt->asm_string);
+		do_asm_xputs(U_W_VAL, stmt->asm_outputs);
+		do_asm_xputs(U_R_VAL, stmt->asm_inputs);
+
+	break; case STMT_COMPOUND: {
+		int count;
+
+		do_sym_list(stmt->syms);
+		count = statement_list_size(stmt->stmts);
+		DO_LIST(stmt->stmts, st,
+			ret = do_statement(--count ? U_VOID : mode, st));
+	}
+
+	break; case STMT_ITERATOR:
+		do_sym_list(stmt->iterator_syms);
+		do_statement(U_VOID, stmt->iterator_pre_statement);
+		do_expression(U_R_VAL, stmt->iterator_pre_condition);
+		do_statement(U_VOID, stmt->iterator_post_statement);
+		do_statement(U_VOID, stmt->iterator_statement);
+		do_expression(U_R_VAL, stmt->iterator_post_condition);
+
+	break; case STMT_IF:
+		do_expression(U_R_VAL, stmt->if_conditional);
+		do_statement(U_VOID, stmt->if_true);
+		do_statement(U_VOID, stmt->if_false);
+
+	break; case STMT_SWITCH:
+		do_expression(U_R_VAL, stmt->switch_expression);
+		do_statement(U_VOID, stmt->switch_statement);
+
+	break; case STMT_CASE:
+		do_expression(U_R_VAL, stmt->case_expression);
+		do_expression(U_R_VAL, stmt->case_to);
+		do_statement(U_VOID, stmt->case_statement);
+
+	break; case STMT_GOTO:
+		do_expression(U_R_PTR, stmt->goto_expression);
+
+	break; case STMT_LABEL:
+		do_statement(mode, stmt->label_statement);
+
+	}
+
+	return ret;
+}
+
+static struct symbol *do_initializer(struct symbol *type, struct expression* expr)
+{
+	struct symbol *m_type;
+	struct expression *m_expr;
+	struct ident *m_name;
+	int m_addr;
+
+	if (type->type == SYM_ARRAY)
+		do_expression(U_R_VAL, type->array_size);
+
+	if (expr) switch (expr->type) {
+	default:
+		do_expression(u_lval(type), expr);
+
+	break; case EXPR_INITIALIZER:
+		m_addr = 0;
+		FOR_EACH_PTR(expr->expr_list, m_expr)
+			if(type->type == SYM_ARRAY) {
+				m_type = base_type(type);
+				if (m_expr->type == EXPR_INDEX)
+					m_expr = m_expr->idx_expression;
+			} else {
+				m_name = NULL;
+				if (m_expr->type == EXPR_IDENTIFIER) {
+					m_name = m_expr->expr_ident;
+					m_expr = m_expr->ident_expression;
+				}
+
+				m_type = report_member(U_W_VAL, &m_expr->pos, type,
+						lookup_member(type, m_name, &m_addr));
+				m_addr++;
+			}
+			do_initializer(m_type, m_expr);
+		END_FOR_EACH_PTR(m_expr);
+	}
+
+	return type;
+}
+
+static inline struct symbol *do_symbol(struct symbol *sym)
+{
+	struct symbol *type;
+
+	type = base_type(sym);
+
+	if (reporter->r_symdef)
+		reporter->r_symdef(sym);
+
+	switch (type->type) {
+	default:
+		if (reporter->r_symbol && sym->initializer)
+			reporter->r_symbol(U_W_VAL, &sym->pos, sym);
+		do_initializer(type, sym->initializer);
+
+	break; case SYM_FN:
+		do_sym_list(type->arguments);
+		return_type = base_type(type);
+		do_statement(U_VOID, sym->ctype.modifiers & MOD_INLINE
+					? type->inline_stmt
+					: type->stmt);
+	}
+
+	return type;
+}
+
+static void do_sym_list(struct symbol_list *list)
+{
+	DO_LIST(list, sym, do_symbol(sym));
+}
+
+void dissect(struct symbol_list *list, struct reporter *rep)
+{
+	reporter = rep;
+	do_sym_list(list);
+}
--- /dev/null	2000-01-01 03:00:00.000000000 +0300
+++ git-snapshot-20050818/test-dissect.c	2005-09-04 23:45:39.000000000 +0400
@@ -0,0 +1,96 @@
+#include "dissect.h"
+
+static unsigned dotc_stream;
+
+static inline char storage(struct symbol *sym)
+{
+	int t = sym->type;
+	unsigned m = sym->ctype.modifiers;
+
+	if (m & MOD_INLINE || t == SYM_STRUCT || t == SYM_UNION /*|| t == SYM_ENUM*/)
+		return sym->pos.stream == dotc_stream ? 's' : 'g';
+
+	return (m & MOD_STATIC) ? 's' : (m & MOD_NONLOCAL) ? 'g' : 'l';
+}
+
+static inline const char *show_mode(unsigned mode)
+{
+	static char str[3];
+
+	if (mode == -1)
+		return "def";
+
+#define	U(u_r)	"-rwm"[(mode / u_r) & 3]
+	str[0] = U(U_R_AOF);
+	str[1] = U(U_R_VAL);
+	str[2] = U(U_R_PTR);
+#undef	U
+
+	return str;
+}
+
+static void print_usage(struct position *pos, struct symbol *sym, unsigned mode)
+{
+	static unsigned curr_stream = -1;
+
+	if (curr_stream != pos->stream) {
+		curr_stream = pos->stream;
+		printf("\nFILE: %s\n\n", stream_name(curr_stream));
+	}
+
+	printf("%4d:%-3d %c %-5.3s",
+		pos->line, pos->pos, storage(sym), show_mode(mode));
+}
+
+static void r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
+{
+	print_usage(pos, sym, mode);
+
+	printf("%-32.*s %s\n",
+		sym->ident->len, sym->ident->name,
+		show_typename(sym->ctype.base_type));
+}
+
+static void r_member(unsigned mode, struct position *pos, struct symbol *sym, struct symbol *mem)
+{
+	struct ident *ni, *si, *mi;
+
+	print_usage(pos, sym, mode);
+
+	ni = MK_IDENT("?");
+	si = sym->ident ?: ni;
+	mi = mem->ident ?: ni;
+
+	printf("%.*s.%-*.*s %s\n",
+		si->len, si->name,
+		32-1 - si->len, mi->len, mi->name,
+		show_typename(mem->ctype.base_type));
+}
+
+static void r_symdef(struct symbol *sym)
+{
+	r_symbol(-1, &sym->pos, sym);
+}
+
+void evaluate_symbol_list(struct symbol_list *list)
+{
+	static struct reporter reporter = {
+		.r_symdef = r_symdef,
+		.r_symbol = r_symbol,
+		.r_member = r_member,
+	};
+
+	dissect(list, &reporter);
+}
+
+int main(int argc, char **argv)
+{
+	sparse_initialize(argc, argv);
+
+	while (*argv) {
+		dotc_stream = input_stream_nr;
+		sparse(argv);
+	}
+
+	return 0;
+}
--- git-snapshot-20050818/Makefile~ds	2005-08-17 23:58:51.000000000 +0400
+++ git-snapshot-20050818/Makefile	2005-09-05 00:00:58.000000000 +0400
@@ -21,7 +21,7 @@ CFLAGS += -DDEBUG
 
 PREFIX=$(HOME)
 BINDIR=$(PREFIX)/bin
-PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example
+PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize test-dissect example
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
@@ -30,7 +30,7 @@ LIB_H=    token.h parse.h lib.h symbol.h
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
-	  flow.o cse.o simplify.o memops.o liveness.o storage.o
+	  flow.o cse.o simplify.o memops.o liveness.o storage.o dissect.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -65,6 +65,9 @@ test-parsing: test-parsing.o $(LIBS)
 test-linearize: test-linearize.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+test-dissect: test-dissect.o $(SLIB_FILE)
+	$(CC) $(LDFLAGS) -o $@ $< $(SLIB_FILE)
+
 test-sort: test-sort.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
@@ -108,6 +111,7 @@ target.o: $(LIB_H)
 test-lexing.o: $(LIB_H)
 test-parsing.o: $(LIB_H)
 test-linearize.o: $(LIB_H)
+test-dissect.o: $(LIB_H) dissect.h
 compile.o: $(LIB_H) compile.h
 compile-i386.o: $(LIB_H) compile.h
 tokenize.o: $(LIB_H)
@@ -115,6 +119,7 @@ check.o: $(LIB_H)
 obfuscate.o: $(LIB_H)
 example.o: $(LIB_H)
 storage.o: $(LIB_H) storage.h
+dissect.o: $(LIB_H) dissect.h
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
	struct reporter
	{
		void (*r_symdef)(struct symbol*);

		void (*r_symbol)(unsigned mode, struct position*, struct symbol*);
		void (*r_member)(unsigned mode, struct position*, struct symbol*, struct symbol*);
	};

	extern void dissect(struct symbol_list*, struct reporter*);

dissect() walks the output of the sparse_file() and calls reporter's
callbacks.

->r_symdef() is called when the symbol (variable or function) is defined.

->r_symbol() - when the symbol is used in any way. The 'mode' parameter
denotes how this symbol was used. It is a bitmask of possible flags:

	FLAG:		Code example:

	U_R_VAL		return VAR;
	U_W_VAL		VAR = 0;

	U_R_PTR		return *VAR;
	U_W_PTR		*VAR = 0;

	U_R_AOF		const void *... = &VAR;
	U_W_AOF		memset(&VAR, ...);

->r_member() tracks the use of members of structures in the same way.

This patch also adds test-dissect.c, a simple and stupid example. It
prints the 'mode' parameter in a human readable format along with the
storage info, variable's name (or struct_name.member_name), and it's
type.

The 'mode' is dumped as a 3-letter string. The first letter denotes
AOF part, 2-nd - VAL, 3-rd - PTR.

	0			-> '-'
	U_R_xxx			-> 'r'
	U_W_xxx			-> 'w'
	U_R_xxx | U_W_xxx	-> 'm'

Example:
	$ cat -n T.c
	     1  int var;
	     2
	     3  static void func(void)
	     4  {
	     5          int *ptr;
	     6
	     7          ptr = &var;
	     8          *ptr = var;
	     9
	    10          var = *++ptr;
	    11  }

	$ ./test-dissect T.c

	FILE: T.c

	   1:5   g def  var                              int
	   3:13  s def  func                             void (  )( ... )
	   5:6   l def  ptr                              int *
	   7:2   l -w-  ptr                              int *
	   7:9   g m--  var                              int
	   8:3   l --w  ptr                              int *
	   8:9   g -r-  var                              int
	  10:2   g -w-  var                              int
	  10:11  l -mr  ptr                              int *


Note that '*ptr' does not add U_R_VAL flag, this is a feature, not a bug,
even if technically wrong.

dissect() does not check the code for correctness, for example:

	0 = X = Y;

gives this output:

   5:6   g -w-  X                                bad type
   5:10  g -r-  Y                                bad type

Again, X has no U_R_VAL, notabug.


Members of structures usage:

	task_t *tsk;
	tsk->parent->real_parent->pid++;

output:

   7:2   l --r  tsk                              struct task_struct [usertype] *
   7:5   g --r  task_struct.parent               struct task_struct *
   7:13  g --m  task_struct.real_parent          struct task_struct *
   7:26  g -m-  task_struct.pid                  int


dissect() tries to de-anonymize unnamed structures/unions:

     1  struct T {
     2          struct {
     3                  int x, y;
     4          } m;
     5  } t = {
     6          { undeclared }
     7  };

output:

   5:3   g def  t                                struct T
   5:3   g -w-  t                                struct T
   6:2   s -w-  T.m                              struct T:m
   6:4   s -w-  T:m.x                            int
   6:4   g -r-  undeclared                       bad type


When entire struct is overwritten, ->r_member() is called with mem == NULL,
this reported as struct_name.*, example:

	*new_vma = *vma;

output:

2028:5   l --w  new_vma                          struct vm_area_struct *
2028:13  g -w-  vm_area_struct.*                 struct vm_area_struct
2028:13  g -w-  pgprot_t.*                       struct pgprot_t
2028:13  g -w-  rb_node.*                        struct rb_node
2028:13  g -w-  vm_area_struct:shared.*          union vm_area_struct:shared
2028:13  g -w-  vm_area_struct:shared:vm_set.*   struct vm_area_struct:shared:vm_set
2028:13  g -w-  list_head.*                      struct list_head
2028:13  g -w-  raw_prio_tree_node.*             struct raw_prio_tree_node
2028:13  g -w-  list_head.*                      struct list_head
2028:16  l --r  vma                              struct vm_area_struct *


Function calls use U_R_PTR bit:

     5          func();
     6          pf = func;
     7          pf();

   5:2   g --r  func                             void (  )( ... )
   6:2   l -w-  pf                               void ( * )( ... )
   6:7   g r--  func                             void (  )( ... )
   7:2   l --r  pf                               void ( * )( ... )


BUGS:

1. dissect() confuses array-in-container with a pointer:

     3          struct T { int ary[]; } t;
     4
     5          t.ary[0] = 0;

output:

   5:2   l -r-  t     /* BUG, should be -w- */   struct T
   5:3   s -w-  T.ary                            int [0]

2. It can't detect the case when the address is taken only for writing,
eg: *(&i + 1) = 0, so U_W_AOF always implies U_R_AOF.

3. It does not support "flat" initializers without braces:

     3          struct O {
     4                  struct I {
     5                          int x, y;
     6                  } a, b;
     7          };
     8
     9          struct O o1 = { 1, 2, 3 };

buggy output:

   9:11  l -w-  o1                               struct O
   9:18  s -w-  O.a                              struct I
   9:21  s -w-  O.b                              struct I
   9:24  s -w-  O.?                              bad type

This is ok:

    11          struct O o2 = { { 1 }, .b = { .y = 0 } };

  11:11  l -w-  o2                               struct O
  11:18  s -w-  O.a                              struct I
  11:20  s -w-  I.x                              int
  11:30  s -w-  O.b                              struct I
  11:37  s -w-  I.y                              int

4. The implementation is far from perfect. It was really done
in "add some code + printf and see what happens" manner, without
studying the sources first. However I beleive it may be useful
for others, that is why I am posting it.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20051210/Makefile~2_DISSECT	2005-11-28 04:40:51.000000000 +0300
+++ git-snapshot-20051210/Makefile	2005-12-19 23:35:40.000000000 +0300
@@ -21,7 +21,7 @@ CFLAGS += -DDEBUG
 
 PREFIX=$(HOME)
 BINDIR=$(PREFIX)/bin
-PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example test-unssa
+PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example test-unssa test-dissect
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
@@ -30,7 +30,7 @@ LIB_H=    token.h parse.h lib.h symbol.h
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
-	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o
+	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -83,6 +83,9 @@ example: example.o $(LIBS)
 test-unssa: test-unssa.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+test-dissect: test-dissect.o $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+
 $(LIB_FILE): $(LIB_OBJS)
 	$(AR) rcs $@ $(LIB_OBJS)
 
@@ -111,6 +114,7 @@ target.o: $(LIB_H)
 test-lexing.o: $(LIB_H)
 test-parsing.o: $(LIB_H)
 test-linearize.o: $(LIB_H)
+test-dissect.o: $(LIB_H) dissect.h
 compile.o: $(LIB_H) compile.h
 compile-i386.o: $(LIB_H) compile.h
 tokenize.o: $(LIB_H)
@@ -118,6 +122,7 @@ check.o: $(LIB_H)
 obfuscate.o: $(LIB_H)
 example.o: $(LIB_H)
 storage.o: $(LIB_H) storage.h
+dissect.o: $(LIB_H) dissect.h
 
 compat-linux.o: compat/strtold.c compat/mmap-blob.c \
 	$(LIB_H)
--- /dev/null	2000-01-01 03:00:00.000000000 +0300
+++ git-snapshot-20051210/dissect.h	2005-09-04 06:52:02.000000000 +0400
@@ -0,0 +1,40 @@
+#ifndef	DISSECT_H
+#define	DISSECT_H
+
+#include <stdio.h>
+#include "parse.h"
+#include "expression.h"
+
+#define	U_SHIFT		8
+
+#define	U_R_AOF		0x01
+#define	U_W_AOF		0x02
+
+#define	U_R_VAL		0x04
+#define	U_W_VAL		0x08
+
+#define	U_R_PTR		(U_R_VAL << U_SHIFT)
+#define	U_W_PTR		(U_W_VAL << U_SHIFT)
+
+struct reporter
+{
+	void (*r_symdef)(struct symbol*);
+
+	void (*r_symbol)(unsigned, struct position*, struct symbol*);
+	void (*r_member)(unsigned, struct position*, struct symbol*, struct symbol*);
+};
+
+extern void dissect(struct symbol_list*, struct reporter*);
+
+#define	MK_IDENT(s)	({				\
+	static struct {					\
+		struct ident ident;			\
+		char __[sizeof(s)];			\
+	} ident = {{					\
+		.len  = sizeof(s)-1,			\
+		.name = s,				\
+	}};						\
+	&ident.ident;					\
+})
+
+#endif
--- /dev/null	2000-01-01 03:00:00.000000000 +0300
+++ git-snapshot-20051210/dissect.c	2005-12-19 21:07:43.000000000 +0300
@@ -0,0 +1,574 @@
+/*
+ * sparse/dissect.c
+ *
+ * Started by Oleg Nesterov <oleg@tv-sign.ru>
+ *
+ * Licensed under the Open Software License version 1.1
+ */
+
+#include "dissect.h"
+
+#define	U_VOID	 0x00
+#define	U_SELF	((1 << U_SHIFT) - 1)
+#define	U_MASK	(U_R_VAL | U_W_VAL | U_R_AOF)
+
+#define	DO_LIST(l__, p__, expr__)		\
+	do {					\
+		typeof(l__->list[0]) p__;	\
+		FOR_EACH_PTR(l__, p__)		\
+			expr__;			\
+		END_FOR_EACH_PTR(p__);		\
+	} while (0)
+
+#define	DO_2_LIST(l1__,l2__, p1__,p2__, expr__)	\
+	do {					\
+		typeof(l1__->list[0]) p1__;	\
+		typeof(l2__->list[0]) p2__;	\
+		PREPARE_PTR_LIST(l1__, p1__);	\
+		FOR_EACH_PTR(l2__, p2__)	\
+			expr__;			\
+			NEXT_PTR_LIST(p1__);	\
+		END_FOR_EACH_PTR(p2__);		\
+		FINISH_PTR_LIST(p1__);		\
+	} while (0)
+
+
+typedef unsigned usage_t;
+
+static struct reporter *reporter;
+static struct symbol *return_type;
+
+static void do_sym_list(struct symbol_list *list);
+
+static struct symbol
+	*base_type(struct symbol *sym),
+	*do_initializer(struct symbol *type, struct expression* expr),
+	*do_expression(usage_t mode, struct expression *expr),
+	*do_statement(usage_t mode, struct statement *stmt);
+
+static inline int is_ptr(struct symbol *type)
+{
+	return type->type == SYM_PTR || type->type == SYM_ARRAY;
+}
+
+static inline usage_t u_rval(usage_t mode)
+{
+	return mode & (U_R_VAL | (U_MASK << U_SHIFT))
+		? U_R_VAL : 0;
+}
+
+static inline usage_t u_addr(usage_t mode)
+{
+	return mode = mode & U_MASK
+		? U_R_AOF | (mode & U_W_AOF) : 0;
+}
+
+static usage_t u_lval(struct symbol *type)
+{
+	int wptr = is_ptr(type) && !(type->ctype.modifiers & MOD_CONST);
+	return wptr || type == &bad_ctype
+		? U_W_AOF | U_R_VAL : U_R_VAL;
+}
+
+static usage_t fix_mode(struct symbol *type, usage_t mode)
+{
+	mode &= (U_SELF | (U_SELF << U_SHIFT));
+
+	switch (type->type) {
+		case SYM_BASETYPE:
+			if (!type->ctype.base_type)
+				break;
+		case SYM_ENUM:
+		case SYM_BITFIELD:
+			if (mode & U_MASK)
+				mode &= U_SELF;
+		default:
+
+		break; case SYM_FN:
+			if (mode & U_R_VAL)
+				mode |= U_R_AOF;
+			mode &= ~(U_R_VAL | U_W_AOF);
+
+		break; case SYM_ARRAY:
+			if (mode & (U_MASK << U_SHIFT))
+				mode >>= U_SHIFT;
+			else if (mode != U_W_VAL)
+				mode = u_addr(mode);
+	}
+
+	if (!(mode & U_R_AOF))
+		mode &= ~U_W_AOF;
+
+	return mode;
+}
+
+static inline struct symbol *no_member(struct ident *name)
+{
+	static struct symbol sym = {
+		.type = SYM_BAD,
+	};
+
+	sym.ctype.base_type = &bad_ctype;
+	sym.ident = name;
+
+	return &sym;
+}
+
+static struct symbol *report_member(mode_t mode, struct position *pos,
+					struct symbol *type, struct symbol *mem)
+{
+	struct symbol *ret = mem->ctype.base_type;
+
+	if (reporter->r_member)
+		reporter->r_member(fix_mode(ret, mode), pos, type, mem);
+
+	return ret;
+}
+
+static void report_implicit(usage_t mode, struct position *pos, struct symbol *type)
+{
+	if (type->type != SYM_STRUCT && type->type != SYM_UNION)
+		return;
+
+	if (reporter->r_member) {
+		reporter->r_member(mode, pos, type, NULL);
+
+		DO_LIST(type->symbol_list, mem,
+			report_implicit(mode, pos, base_type(mem)));
+	}
+}
+
+static inline struct symbol *expr_symbol(struct expression *expr)
+{
+	struct symbol *sym = expr->symbol;
+
+	if (!sym) {
+		sym = lookup_symbol(expr->symbol_name, NS_SYMBOL);
+
+		if (!sym) {
+			sym = alloc_symbol(expr->pos, SYM_BAD);
+			bind_symbol(sym, expr->symbol_name, NS_SYMBOL);
+			sym->ctype.modifiers = MOD_EXTERN;
+		}
+	}
+
+	if (!sym->ctype.base_type)
+		sym->ctype.base_type = &bad_ctype;
+
+	return sym;
+}
+
+static struct symbol *report_symbol(usage_t mode, struct expression *expr)
+{
+	struct symbol *sym = expr_symbol(expr);
+	struct symbol *ret = base_type(sym);
+
+	if (0 && ret->type == SYM_ENUM)
+		return report_member(mode, &expr->pos, ret, expr->symbol);
+
+	if (reporter->r_symbol)
+		reporter->r_symbol(fix_mode(ret, mode), &expr->pos, sym);
+
+	return ret;
+}
+
+static inline struct ident *mk_name(struct ident *root, struct ident *node)
+{
+	char name[256];
+
+	snprintf(name, sizeof(name), "%.*s:%.*s",
+			root ? root->len : 0, root->name,
+			node ? node->len : 0, node->name);
+
+	return built_in_ident(name);
+}
+
+static void examine_sym_node(struct symbol *node, struct ident *root)
+{
+	struct symbol *base;
+	struct ident *name;
+
+	if (node->examined)
+		return;
+
+	node->examined = 1;
+	name = node->ident;
+
+	while ((base = node->ctype.base_type) != NULL)
+		switch (base->type) {
+		case SYM_TYPEOF:
+			node->ctype.base_type =
+				do_expression(U_VOID, base->initializer);
+			break;
+
+		case SYM_ARRAY:
+			do_expression(U_R_VAL, base->array_size);
+		case SYM_PTR: case SYM_FN:
+			node = base;
+			break;
+
+		case SYM_STRUCT: case SYM_UNION: //case SYM_ENUM:
+			if (base->evaluated)
+				return;
+			if (!base->ident && name)
+				base->ident = mk_name(root, name);
+			if (!base->ident || !base->symbol_list)
+				return;
+			if (reporter->r_symdef)
+				reporter->r_symdef(base);
+			base->evaluated = 1;
+		default:
+			return;
+		}
+}
+
+static struct symbol *base_type(struct symbol *sym)
+{
+	if (!sym)
+		return &bad_ctype;
+
+	if (sym->type == SYM_NODE)
+		examine_sym_node(sym, NULL);
+
+	return sym->ctype.base_type	// builtin_fn_type
+		?: &bad_ctype;
+}
+
+static struct symbol *__lookup_member(struct symbol *type, struct ident *name, int *p_addr)
+{
+	struct symbol *node;
+	int addr = 0;
+
+	FOR_EACH_PTR(type->symbol_list, node)
+		if (!name) {
+			if (addr == *p_addr)
+				return node;
+		}
+		else if (node->ident == NULL) {
+			node = __lookup_member(node->ctype.base_type, name, NULL);
+			if (node)
+				goto found;
+		}
+		else if (node->ident == name) {
+found:
+			if (p_addr)
+				*p_addr = addr;
+			return node;
+		}
+		addr++;
+	END_FOR_EACH_PTR(node);
+
+	return NULL;
+}
+
+static struct symbol *lookup_member(struct symbol *type, struct ident *name, int *addr)
+{
+	struct symbol *node = __lookup_member(type, name, addr);
+
+	if (node != NULL)
+		examine_sym_node(node, type->ident);
+	else
+		node = no_member(name);
+
+	return node;
+}
+
+static struct expression *peek_preop(struct expression *expr, int op)
+{
+	do {
+		if (expr->type != EXPR_PREOP)
+			break;
+		if (expr->op == op)
+			return expr->unop;
+		if (expr->op == '(')
+			expr = expr->unop;
+		else
+			break;
+	} while (expr);
+
+	return NULL;
+}
+
+static struct symbol *do_expression(usage_t mode, struct expression *expr)
+{
+	struct symbol *ret = &int_ctype;
+
+again:
+	if (expr) switch (expr->type) {
+	default:
+		warning(expr->pos, "bad expr->type: %d", expr->type);
+
+	case EXPR_TYPE:		// [struct T]; Why ???
+	case EXPR_VALUE:
+	case EXPR_FVALUE:
+
+	break; case EXPR_LABEL:
+		ret = &label_ctype;
+
+	break; case EXPR_STRING:
+		ret = &string_ctype;
+
+	break; case EXPR_STATEMENT:
+		ret = do_statement(mode, expr->statement);
+
+	break; case EXPR_SIZEOF: case EXPR_ALIGNOF: case EXPR_PTRSIZEOF:
+		do_expression(U_VOID, expr->cast_expression);
+
+	break; case EXPR_COMMA:
+		do_expression(U_VOID, expr->left);
+		ret = do_expression(mode, expr->right);
+
+	break; case EXPR_CAST: //case EXPR_IMPLIED_CAST:
+		ret = base_type(expr->cast_type);
+		do_initializer(ret, expr->cast_expression);
+
+	break; case EXPR_COMPARE: case EXPR_LOGICAL:
+		mode = u_rval(mode);
+		do_expression(mode, expr->left);
+		do_expression(mode, expr->right);
+
+	break; case EXPR_CONDITIONAL: //case EXPR_SELECT:
+		do_expression(expr->cond_true
+					? U_R_VAL : U_R_VAL | mode,
+				expr->conditional);
+		ret = do_expression(mode, expr->cond_true);
+		ret = do_expression(mode, expr->cond_false);
+
+	break; case EXPR_CALL:
+		ret = do_expression(U_R_PTR, expr->fn);
+		if (is_ptr(ret))
+			ret = ret->ctype.base_type;
+		DO_2_LIST(ret->arguments, expr->args, arg, val,
+			do_expression(u_lval(base_type(arg)), val));
+		ret = ret->type == SYM_FN ? base_type(ret)
+			: &bad_ctype;
+
+	break; case EXPR_ASSIGNMENT:
+		mode |= U_W_VAL | U_R_VAL;
+		if (expr->op == '=')
+			mode &= ~U_R_VAL;
+		ret = do_expression(mode, expr->left);
+		report_implicit(mode, &expr->pos, ret);
+		mode = expr->op == '='
+			? u_lval(ret) : U_R_VAL;
+		do_expression(mode, expr->right);
+
+	break; case EXPR_BINOP: {
+		struct symbol *l, *r;
+		mode |= u_rval(mode);
+		l = do_expression(mode, expr->left);
+		r = do_expression(mode, expr->right);
+		if (expr->op != '+' && expr->op != '-')
+			;
+		else if (!is_ptr_type(r))
+			ret = l;
+		else if (!is_ptr_type(l))
+			ret = r;
+	}
+
+	break; case EXPR_PREOP: case EXPR_POSTOP: {
+		struct expression *unop = expr->unop;
+
+		switch (expr->op) {
+		case SPECIAL_INCREMENT:
+		case SPECIAL_DECREMENT:
+			mode |= U_W_VAL | U_R_VAL;
+		default:
+			mode |= u_rval(mode);
+		case '(':
+			ret = do_expression(mode, unop);
+
+		break; case '&':
+			if ((expr = peek_preop(unop, '*')))
+				goto again;
+			ret = alloc_symbol(unop->pos, SYM_PTR);
+			ret->ctype.base_type =
+				do_expression(u_addr(mode), unop);
+
+		break; case '*':
+			if ((expr = peek_preop(unop, '&')))
+				goto again;
+			if (mode & (U_MASK << U_SHIFT))
+				mode |= U_R_VAL;
+			mode <<= U_SHIFT;
+			if (mode & (U_R_AOF << U_SHIFT))
+				mode |= U_R_VAL;
+			if (mode & (U_W_VAL << U_SHIFT))
+				mode |= U_W_AOF;
+			ret = do_expression(mode, unop);
+			ret = is_ptr(ret) ? base_type(ret)
+				: &bad_ctype;
+		}
+	}
+
+	break; case EXPR_DEREF: {
+		struct symbol *p_type;
+		usage_t p_mode;
+
+		p_mode = mode & U_SELF;
+		if (!(mode & U_MASK) && (mode & (U_MASK << U_SHIFT)))
+			p_mode = U_R_VAL;
+		p_type = do_expression(p_mode, expr->deref);
+
+		ret = report_member(mode, &expr->pos, p_type,
+			lookup_member(p_type, expr->member, NULL));
+	}
+
+	break; case EXPR_SYMBOL:
+		ret = report_symbol(mode, expr);
+	}
+
+	return ret;
+}
+
+static void do_asm_xputs(usage_t mode, struct expression_list *xputs)
+{
+	int nr = 0;
+
+	DO_LIST(xputs, expr,
+		if (++nr % 3 == 0)
+			do_expression(U_W_AOF | mode, expr));
+}
+
+static struct symbol *do_statement(usage_t mode, struct statement *stmt)
+{
+	struct symbol *ret = &void_ctype;
+
+	if (stmt) switch (stmt->type) {
+	default:
+		warning(stmt->pos, "bad stmt->type: %d", stmt->type);
+
+	case STMT_NONE:
+	case STMT_RANGE:
+	case STMT_CONTEXT:
+
+	break; case STMT_EXPRESSION:
+		ret = do_expression(mode, stmt->expression);
+
+	break; case STMT_RETURN:
+		do_expression(u_lval(return_type), stmt->expression);
+
+	break; case STMT_ASM:
+		do_expression(U_R_VAL, stmt->asm_string);
+		do_asm_xputs(U_W_VAL, stmt->asm_outputs);
+		do_asm_xputs(U_R_VAL, stmt->asm_inputs);
+
+	break; case STMT_COMPOUND: {
+		int count;
+
+		do_sym_list(stmt->syms);
+		count = statement_list_size(stmt->stmts);
+		DO_LIST(stmt->stmts, st,
+			ret = do_statement(--count ? U_VOID : mode, st));
+	}
+
+	break; case STMT_ITERATOR:
+		do_sym_list(stmt->iterator_syms);
+		do_statement(U_VOID, stmt->iterator_pre_statement);
+		do_expression(U_R_VAL, stmt->iterator_pre_condition);
+		do_statement(U_VOID, stmt->iterator_post_statement);
+		do_statement(U_VOID, stmt->iterator_statement);
+		do_expression(U_R_VAL, stmt->iterator_post_condition);
+
+	break; case STMT_IF:
+		do_expression(U_R_VAL, stmt->if_conditional);
+		do_statement(U_VOID, stmt->if_true);
+		do_statement(U_VOID, stmt->if_false);
+
+	break; case STMT_SWITCH:
+		do_expression(U_R_VAL, stmt->switch_expression);
+		do_statement(U_VOID, stmt->switch_statement);
+
+	break; case STMT_CASE:
+		do_expression(U_R_VAL, stmt->case_expression);
+		do_expression(U_R_VAL, stmt->case_to);
+		do_statement(U_VOID, stmt->case_statement);
+
+	break; case STMT_GOTO:
+		do_expression(U_R_PTR, stmt->goto_expression);
+
+	break; case STMT_LABEL:
+		do_statement(mode, stmt->label_statement);
+
+	}
+
+	return ret;
+}
+
+static struct symbol *do_initializer(struct symbol *type, struct expression* expr)
+{
+	struct symbol *m_type;
+	struct expression *m_expr;
+	int m_addr;
+
+	if (expr) switch (expr->type) {
+	default:
+		do_expression(u_lval(type), expr);
+
+	break; case EXPR_INITIALIZER:
+		m_addr = 0;
+		FOR_EACH_PTR(expr->expr_list, m_expr)
+			if(type->type == SYM_ARRAY) {
+				m_type = base_type(type);
+				if (m_expr->type == EXPR_INDEX)
+					m_expr = m_expr->idx_expression;
+			} else {
+				struct position *pos = &m_expr->pos;
+				struct ident *m_name = NULL;
+
+				if (m_expr->type == EXPR_IDENTIFIER) {
+					m_name = m_expr->expr_ident;
+					m_expr = m_expr->ident_expression;
+				}
+
+				m_type = report_member(U_W_VAL, pos, type,
+						lookup_member(type, m_name, &m_addr));
+				if (m_expr->type != EXPR_INITIALIZER)
+					report_implicit(U_W_VAL, pos, m_type);
+			}
+			do_initializer(m_type, m_expr);
+			m_addr++;
+		END_FOR_EACH_PTR(m_expr);
+	}
+
+	return type;
+}
+
+static inline struct symbol *do_symbol(struct symbol *sym)
+{
+	struct symbol *type;
+
+	type = base_type(sym);
+
+	if (reporter->r_symdef)
+		reporter->r_symdef(sym);
+
+	switch (type->type) {
+	default:
+		if (!sym->initializer)
+			break;
+		if (reporter->r_symbol)
+			reporter->r_symbol(U_W_VAL, &sym->pos, sym);
+		do_initializer(type, sym->initializer);
+
+	break; case SYM_FN:
+		do_sym_list(type->arguments);
+		return_type = base_type(type);
+		do_statement(U_VOID, sym->ctype.modifiers & MOD_INLINE
+					? type->inline_stmt
+					: type->stmt);
+	}
+
+	return type;
+}
+
+static void do_sym_list(struct symbol_list *list)
+{
+	DO_LIST(list, sym, do_symbol(sym));
+}
+
+void dissect(struct symbol_list *list, struct reporter *rep)
+{
+	reporter = rep;
+	do_sym_list(list);
+}
--- /dev/null	2000-01-01 03:00:00.000000000 +0300
+++ git-snapshot-20051210/test-dissect.c	2005-12-19 23:21:50.000000000 +0300
@@ -0,0 +1,95 @@
+#include "dissect.h"
+
+static unsigned dotc_stream;
+
+static inline char storage(struct symbol *sym)
+{
+	int t = sym->type;
+	unsigned m = sym->ctype.modifiers;
+
+	if (m & MOD_INLINE || t == SYM_STRUCT || t == SYM_UNION /*|| t == SYM_ENUM*/)
+		return sym->pos.stream == dotc_stream ? 's' : 'g';
+
+	return (m & MOD_STATIC) ? 's' : (m & MOD_NONLOCAL) ? 'g' : 'l';
+}
+
+static inline const char *show_mode(unsigned mode)
+{
+	static char str[3];
+
+	if (mode == -1)
+		return "def";
+
+#define	U(u_r)	"-rwm"[(mode / u_r) & 3]
+	str[0] = U(U_R_AOF);
+	str[1] = U(U_R_VAL);
+	str[2] = U(U_R_PTR);
+#undef	U
+
+	return str;
+}
+
+static void print_usage(struct position *pos, struct symbol *sym, unsigned mode)
+{
+	static unsigned curr_stream = -1;
+
+	if (curr_stream != pos->stream) {
+		curr_stream = pos->stream;
+		printf("\nFILE: %s\n\n", stream_name(curr_stream));
+	}
+
+	printf("%4d:%-3d %c %-5.3s",
+		pos->line, pos->pos, storage(sym), show_mode(mode));
+}
+
+static void r_symbol(unsigned mode, struct position *pos, struct symbol *sym)
+{
+	print_usage(pos, sym, mode);
+
+	if (!sym->ident)
+		sym->ident = MK_IDENT("__asm__");
+
+	printf("%-32.*s %s\n",
+		sym->ident->len, sym->ident->name,
+		show_typename(sym->ctype.base_type));
+}
+
+static void r_member(unsigned mode, struct position *pos, struct symbol *sym, struct symbol *mem)
+{
+	struct ident *ni, *si, *mi;
+
+	print_usage(pos, sym, mode);
+
+	ni = MK_IDENT("?");
+	si = sym->ident ?: ni;
+	/* mem == NULL means entire struct accessed */
+	mi = mem ? (mem->ident ?: ni) : MK_IDENT("*");
+
+	printf("%.*s.%-*.*s %s\n",
+		si->len, si->name,
+		32-1 - si->len, mi->len, mi->name,
+		show_typename(mem ? mem->ctype.base_type : sym));
+}
+
+static void r_symdef(struct symbol *sym)
+{
+	r_symbol(-1, &sym->pos, sym);
+}
+
+int main(int argc, char **argv)
+{
+	static struct reporter reporter = {
+		.r_symdef = r_symdef,
+		.r_symbol = r_symbol,
+		.r_member = r_member,
+	};
+
+	sparse_initialize(argc, argv);
+
+	while (*argv) {
+		dotc_stream = input_stream_nr;
+		dissect(__sparse(argv), &reporter);
+	}
+
+	return 0;
+}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: :), pastry cook ===

From: "Rudy Raines" <RudyRaines () 1-tel ! com>
To: linux-sparse
Subject: :), pastry cook
Date: Thu, 16 Jun 2005 15:22:27 +0000
Message-ID: <81095787.20050616144627 () 1-tel ! com>
--------------------
Even if you have no erectin problems SOFT CIAzLIS 
would help you to make BETTER SE  X MORE OFTEN!
and to bring  unimagnable plesure to her.

Just disolve half a pil under your tongue 
and get ready for action in 15 minutes. 

The tests showed that the majority of men 
after taking this medic ation were able to have 
PERFECT ER ECTI ON during 36 hours!

VISIT US, AND GET OUR SPECIAL 70% DISC OUNT OFER!

http://pmwhpp.motivefood.com/?76413330

==========
one, all the same limitations and lead weights to overcome."
tone.
     Sullivan sighed, but he did  not  argue.  "I  think  I'll  miss  you,
sergeant was digging through the metal file cabinet in the corner. A new guy
affords a new perspective on the nature  of ours and ourselves; it even  has
once and for all, understand?"

before we even gor the first idea that there is more to life than  eating,
poker--that Noonan is a great player, the louse."
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Another enum funny.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Another enum funny..
Date: Tue, 01 Nov 2005 15:48:25 +0000
Message-ID: <Pine.LNX.4.64.0511010740580.27915 () g5 ! osdl ! org>
--------------------

Al,
 lookie here:

	enum {
		a = 0x100000000001ull,
		b = a+1,
	};
	
	static int first = a;
	static long long second = a;

it gets two warnings:

	t.c:3:6: warning: cast truncates bits from constant value (100000000001 becomes 1)
	t.c:6:20: warning: cast truncates bits from constant value (100000000001 becomes 1)

where the second one ("first = a") is expected, since we _are_ truncating 
a big "unsigned long long" value to "int".

But the first one is interesting. And incorrect (since we do support 
gcc-style "big enums"). Do you see why it happens?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Tue, 01 Nov 2005 19:08:57 +0000
Message-ID: <20051101190857.GZ7992 () ftp ! linux ! org ! uk>
--------------------
On Tue, Nov 01, 2005 at 07:48:25AM -0800, Linus Torvalds wrote:
> 
> Al,
>  lookie here:
> 
> 	enum {
> 		a = 0x100000000001ull,
> 		b = a+1,
> 	};
> 	
> 	static int first = a;
> 	static long long second = a;
> 
> it gets two warnings:
> 
> 	t.c:3:6: warning: cast truncates bits from constant value (100000000001 becomes 1)
> 	t.c:6:20: warning: cast truncates bits from constant value (100000000001 becomes 1)
> 
> where the second one ("first = a") is expected, since we _are_ truncating 
> a big "unsigned long long" value to "int".
> 
> But the first one is interesting. And incorrect (since we do support 
> gcc-style "big enums"). Do you see why it happens?

Almost certainly integer promotion gone wrong...  Looking into that.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ftp ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Tue, 01 Nov 2005 19:17:32 +0000
Message-ID: <20051101191732.GA7992 () ftp ! linux ! org ! uk>
--------------------
On Tue, Nov 01, 2005 at 07:48:25AM -0800, Linus Torvalds wrote:
> 	t.c:3:6: warning: cast truncates bits from constant value (100000000001 becomes 1)
> 	t.c:6:20: warning: cast truncates bits from constant value (100000000001 becomes 1)
> 
> where the second one ("first = a") is expected, since we _are_ truncating 
> a big "unsigned long long" value to "int".
> 
> But the first one is interesting. And incorrect (since we do support 
> gcc-style "big enums"). Do you see why it happens?

Because you set type of all enum members to that of enum (parent).  And
do not update parent->ctype.base_type until the very end.  Until then
it's int.  See parse_enum_declaration()...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Wed, 02 Nov 2005 23:32:51 +0000
Message-ID: <20051102233251.GF24619 () daikokuya ! co ! uk>
--------------------
Derek M Jones wrote:-

> 
> The C Standard clearly states that enumeration constants have
> type int:
> http://www.coding-guidelines.com/C99/html/6.4.4.3.html
> 
> The gcc support for uses such as the above essentially
> derives from the more perverse^H^H^H^H^Hmissive approach taken
> by C++.
> 
> So the first warning should be expected and the second warning is
> unexpected (both operands have type int).

Agreed:

neil@duron:~/src/cfe$ ./cfe /tmp/bug.c
"/tmp/bug.c", line 2: error: value of enumeration constant "a" is not
        representable as an "int"
                a = 0x100000000001ull,
                    ^

1 error found compiling "/tmp/bug.c".

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Thu, 03 Nov 2005 02:39:04 +0000
Message-ID: <Pine.LNX.4.64.0511021838140.27915 () g5 ! osdl ! org>
--------------------


On Thu, 3 Nov 2005, Neil Booth wrote:
> 
> Agreed:
> 
> neil@duron:~/src/cfe$ ./cfe /tmp/bug.c
> "/tmp/bug.c", line 2: error: value of enumeration constant "a" is not
>         representable as an "int"
>                 a = 0x100000000001ull,
>                     ^
> 
> 1 error found compiling "/tmp/bug.c".

Yeah, well, gcc not only allows these things, linux actually uses it 
pretty heavily on some architectures. So sparse supports it, although 
incorrectly right now.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Thu, 03 Nov 2005 02:59:08 +0000
Message-ID: <Pine.LNX.4.64.0511021840570.27915 () g5 ! osdl ! org>
--------------------


On Tue, 1 Nov 2005, Al Viro wrote:
> 
> Because you set type of all enum members to that of enum (parent).  And
> do not update parent->ctype.base_type until the very end.  Until then
> it's int.  See parse_enum_declaration()...

Yes. Gaah. Damn, that's nasty. Our code does the right thing in the end, 
but _during_ parsing it's hard to know what the final type will be.

This is the cleanest thing I can imagine. If we see different types for 
the enum cases, we will temporarily use the biggest type we've seen during 
parsing (but at _least_ "int_ctype"), and then at the end we'll go back 
and clamp the type to the range of values we've seen.

Al? I'm not proud of it, but I don't see many alternatives. Not any better 
ones at least.

		Linus

---
diff --git a/parse.c b/parse.c
index 8d39064..e6782af 100644
--- a/parse.c
+++ b/parse.c
@@ -206,6 +206,19 @@ static int type_is_ok(struct symbol *typ
 	return 0;
 }
 
+static struct symbol *bigger_enum_type(struct symbol *s1, struct symbol *s2)
+{
+	if (s1->bit_size < s2->bit_size) {
+		s1 = s2;
+	} else if (s1->bit_size == s2->bit_size) {
+		if (s2->ctype.modifiers & MOD_UNSIGNED)
+			s1 = s2;
+	}
+	if (s1->bit_size < bits_in_int)
+		return &int_ctype;
+	return s1;
+}
+
 static struct token *parse_enum_declaration(struct token *token, struct symbol *parent)
 {
 	unsigned long long lastval = 0;
@@ -261,7 +274,7 @@ static struct token *parse_enum_declarat
 			 *    cases)
 			 *  - if enums are of different types, they
 			 *    all have to be integer types, and the
-			 *    base type is "int_ctype".
+			 *    base type is at least "int_ctype".
 			 *  - otherwise the base_type is "bad_ctype".
 			 */
 			if (!base_type) {
@@ -269,9 +282,10 @@ static struct token *parse_enum_declarat
 			} else if (ctype == base_type) {
 				/* nothing */
 			} else if (is_int_type(base_type) && is_int_type(ctype)) {
-				base_type = &int_ctype;
+				base_type = bigger_enum_type(base_type, ctype);
 			} else
 				base_type = &bad_ctype;
+			parent->ctype.base_type = base_type;
 		}
 		if (is_int_type(base_type)) {
 			Num v = {.y = lastval};
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Thu, 03 Nov 2005 03:28:03 +0000
Message-ID: <436983C3.3040900 () knosof ! co ! uk>
--------------------
>>neil@duron:~/src/cfe$ ./cfe /tmp/bug.c
>>"/tmp/bug.c", line 2: error: value of enumeration constant "a" is not
>>        representable as an "int"
>>                a = 0x100000000001ull,
>>                    ^
>>
>>1 error found compiling "/tmp/bug.c".
> 
> 
> Yeah, well, gcc not only allows these things, linux actually uses it 
> pretty heavily on some architectures. So sparse supports it, although 
> incorrectly right now.

In their own way both C and C++ get it wrong.  C limits the type to
int and C++ allows different enumerators of the same enum type to
have different integer types (which throws lots of people).

There is a lot of developer expectation that all the enumerators of
the same enum type have the same type (ie, the same as that of an
object declared to have that enum type {incidently compilers have
plenty of freedom to choose almost any integer type they like, but
that is another story}).

Perhaps sparse ought to check that enumerators in the same enum
type are likely to be given the same integer type by gcc.  For
instance, if one had type int and another type unsigned long,
then readers of the source might have an expectation that both
have an unsigned type (this expectation leading to assumptions of
behavior that do not occur).

Please don't tell me that there is code in the kernel that makes
use of the fact that different enumerators of the same enum type
have different integer types.....

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Thu, 03 Nov 2005 04:01:53 +0000
Message-ID: <Pine.LNX.4.64.0511021942210.27915 () g5 ! osdl ! org>
--------------------


On Thu, 3 Nov 2005, Derek M Jones wrote:
> 
> Perhaps sparse ought to check that enumerators in the same enum
> type are likely to be given the same integer type by gcc.  For
> instance, if one had type int and another type unsigned long,
> then readers of the source might have an expectation that both
> have an unsigned type (this expectation leading to assumptions of
> behavior that do not occur).

Yeah, we could do something like that. In fact, we could warn if our 
"temporary base type" doesn't end up matching the final base type, because 
that's actually using _both_ of the two sane implementations (the 
"temporary base type" uses the biggest type we've seen so far, while the 
"final base type" looks at the range of the registers).

> Please don't tell me that there is code in the kernel that makes
> use of the fact that different enumerators of the same enum type
> have different integer types.....

No, but some architectures like using enum's instead of #defines, and 
often for bitfields etc that won't in "int". 

So it wants to have values that mustn't be truncated, and the thign that 
made me notice it was that sometimes the values of an earlier enum are 
used to compute the values of later ones, ie

    enum {
	...
	CPU_MAGIC_MASK1 = 0x10000000000,
	CPU_MAGIC_MASK2 = 0x20000000000,
	CPU_MAGIC_MASK_COMBINED = CPU_MAGIC_MASK1 | CPU_MAGIC_MASK2,
	...

which just depends on the type of the enum being updated _while_ the enum 
is being parsed.

At the same time, the final type wants to be as close to the "standard" as 
possible, so the final type for the enum ends up depending on the range of 
values, and that one can't be calculated until you've seen it all. So now 
we have this strange situation that we calculate the type two different 
ways, and enum's that are used _while_ parsing the enum may end up being 
calculated with different types than the final one.

Such a really degenerate example might be

	enum {
		a = 2147483646,
		b,
		c = a+b,
		d = -123456789012
	};


where "a+b" is caluculated in "int" (since both "a" and "b" are "int", and 
the enum type is thus int), but the _final_ type of the enum ends up being 
"signed long long", since "d" needs it.

I dunno. I must have done something wrong, because I can't get this to 
make "c" calculate to "-3" like I thought it should have.

Probably some other bug in sparse ;^p

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Thu, 03 Nov 2005 16:12:51 +0000
Message-ID: <Pine.LNX.4.64.0511030753570.27915 () g5 ! osdl ! org>
--------------------


On Wed, 2 Nov 2005, Linus Torvalds wrote:
> 
> Such a really degenerate example might be
> 
> 	enum {
> 		a = 2147483646,
> 		b,
> 		c = a+b,
> 		d = -123456789012
> 	};
> 
> where "a+b" is caluculated in "int" (since both "a" and "b" are "int", and 
> the enum type is thus int), but the _final_ type of the enum ends up being 
> "signed long long", since "d" needs it.
> 
> I dunno. I must have done something wrong, because I can't get this to 
> make "c" calculate to "-3" like I thought it should have.
> 
> Probably some other bug in sparse ;^p

Heh. I see why. A buglet, but not a big one. And a fairly interesting one.

We change the types of the enums by changing the base type, but when we 
change the base type we do _not_ cast the old values to the new type. So 
they stay in whatever bit representation that they had in the old type.

Thus, in the above example, the _value_ of "c" was -3 (int), and it's bit 
representation was 0xfffffffd. Then, because we had other values that 
didn't fit in "int", we expanded the type to "long long", but we didn't go 
back and cast the old enums to that new type, so when we just changed the 
type, "c" magically changed from "-3(int)" to "0xfffffffd(long long)".

Now, arguably we don't care for the above example because it's outside the 
scope of the standard anyway. Sadly, it also holds true for

	enum {
		a = (short) -1,
		b = 2;
	};

where we also start out with value "-1(short)" and then change it to "int" 
without actually doing a cast, which means that it ends up being 
"65536(int)". Which is obviously wrong, and is not in any way 
non-standard.

So the enum handling code is just switching the types around unsafely. It 
always was. It's a special case, since the final type depends on all the 
intermediate types and values, and sparse just does it wrong.

It's straightforward enough to fix by doing the thing in two phases (just 
add a list of the symbols and go back and cast the expressions to the 
final type). Oh, well.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Thu, 03 Nov 2005 16:40:50 +0000
Message-ID: <Pine.LNX.4.64.0511030832090.27915 () g5 ! osdl ! org>
--------------------


On Thu, 3 Nov 2005, Linus Torvalds wrote:
> 
> So the enum handling code is just switching the types around unsafely. It 
> always was. It's a special case, since the final type depends on all the 
> intermediate types and values, and sparse just does it wrong.
> 
> It's straightforward enough to fix by doing the thing in two phases (just 
> add a list of the symbols and go back and cast the expressions to the 
> final type). Oh, well.

Done, and pushed out.

This has the interesting effect of resulting in:

	enum {
		a = 2147483646,
		b,
		c = a+b,
		d = 0x100000000
	};

where the final type will be "long" or "long long" (depending on whether 
-m64 is in effect or not), but "c" will have been calculated as an "int" 
(because at that time, it was the right type), so it will end up being 
"-3(long)", while (a+b) later on will be _different_ (since they will be 
calculated in 64 bits).

If the definition of "d" is moved to be before "a" or "b", then one or the 
other (or both) will suddely also become 64-bit, and then the calculation 
for "c" will _also_ be done in 64 bits, and then "c" won't be "-3" after 
all.

So in this case, the value of "c" will depend on "nonlocal" changes. 
Strange, but true.

However, that's definitely the right thing. You can't really do it any 
other way unless you actually want to limit yourself to the C standard 
and thus have well-defined types all along.

We should probably add a flag that forces standard C behaviour.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: Another enum funny..
Date: Sun, 06 Nov 2005 08:55:17 +0000
Message-ID: <20051106085517.GG24619 () daikokuya ! co ! uk>
--------------------
Linus Torvalds wrote:-

> This has the interesting effect of resulting in:
> 
> 	enum {
> 		a = 2147483646,
> 		b,
> 		c = a+b,
> 		d = 0x100000000
> 	};
> 
> where the final type will be "long" or "long long" (depending on whether 
> -m64 is in effect or not), but "c" will have been calculated as an "int" 
> (because at that time, it was the right type), so it will end up being 
> "-3(long)", while (a+b) later on will be _different_ (since they will be 
> calculated in 64 bits).
> 
> If the definition of "d" is moved to be before "a" or "b", then one or the 
> other (or both) will suddely also become 64-bit, and then the calculation 
> for "c" will _also_ be done in 64 bits, and then "c" won't be "-3" after 
> all.
> 
> So in this case, the value of "c" will depend on "nonlocal" changes. 
> Strange, but true.
> 
> However, that's definitely the right thing. You can't really do it any 
> other way unless you actually want to limit yourself to the C standard 
> and thus have well-defined types all along.

You could always use the type of the first constant throughout,
and diagnose as errors those that are not representable in that
type.  It restricts slightly the way such enumerated types can be
declared, without restricting the type that is ultimately used.
Encouraging developers to be explicit and put the 'd' first above
is probably a good thing for this kind of extension.

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Asking about typechecking between different typedef types. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Asking about typechecking between different typedef types.
Date: Tue, 15 Nov 2005 17:50:36 +0000
Message-ID: <Pine.LNX.4.64.0511150934310.3945 () g5 ! osdl ! org>
--------------------


On Tue, 15 Nov 2005, Byoung-jip Kim wrote:
> 
> I want sparse to check the assignment between two types which have the same
> base type but are defined differently with typedef.

The "bitwise" attribute does this asa side effect.

In fact, internally this is a fairly generic "SYM_RESTRICT" type, but we 
only expose that for bitwise types, so right now you get all the other 
restrictions that you have with SYM_RESTRICT.

> Can I do this only with existing sparse attributes? or do I need to add a
> custom attribute into sparse? If then, how can I add the attributes into
> the sparse? I will appriciate that if you could let me know how to make it
> possible using sparse.

If you can live with the rules for bitwise, use that.

Another possibility is to use enums and mark the types "nocast", something 
like

	typedef enum {
		yellow,
		red,
		blue
	} __attribute__((nocast)) mytype_t;

and now "mytype_t" is that enum with a "nocast" modifier. HOWEVER, this 
really doesn't end up working all that well if you ever do anything that 
causes integer conversion of these things, because that will always force 
them to be cast to regular integers.

You may think you'd never do that, but even things like

	mytype_t color = some_test ? yellow : red;

would complain about "warning: implicit cast to nocast type", because 
"color" has been declared to only accept that particular enum, but the 
conditional operator has turned yellow/red from that enum into a plain 
integer ;/

In other words, the "nocast" thing tends to work only with pure 
assignments, or with a regular integer or pointer type (ie the kernel uses 
it to make sure that "unsigned int" _stays_ as "unsigned int", and isn't 
converted to a plain "int" or "long" by any implicit cast).

Btw, in the above example, "yellow", "red" and "blue" themselves are 
_not_ "nocast": they're just plain enums and will be cast to integers 
without any warning. Only "mytype_t" (and everything it declares) is 
nocast, so only the _variables_ would generate warnings when assigned to 
or used in a not-strictly-that-type context.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Asking about typechecking between different typedef types.
Date: Tue, 15 Nov 2005 18:15:52 +0000
Message-ID: <Pine.LNX.4.64.0511151008400.3945 () g5 ! osdl ! org>
--------------------


On Tue, 15 Nov 2005, Linus Torvalds wrote:
> 
> You may think you'd never do that, but even things like
> 
> 	mytype_t color = some_test ? yellow : red;
> 
> would complain about "warning: implicit cast to nocast type", because 
> "color" has been declared to only accept that particular enum, but the 
> conditional operator has turned yellow/red from that enum into a plain 
> integer ;/

Actually, this may be due to an over-eager "integer promotion" thing. It 
always turns a type into its base type, but if the type was already big 
enough (like in the above case, where the type was an enum that was 
already big enough - it's the same size as an "int"), that seems a bit 
unnecessary.

Al, what do you think about a patch like this? (Largely untested, but it 
allows the above conditional expression to keep its type as long as 
possible. Which would seem to be what we want to do.

That's the only piece of code I've tested it on, though ;^).

		Linus

---
diff --git a/evaluate.c b/evaluate.c
index f2baea6..17e3353 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -99,6 +99,7 @@ static struct symbol *evaluate_string(st
 
 static inline struct symbol *integer_promotion(struct symbol *type)
 {
+	struct symbol *orig_type = type;
 	unsigned long mod =  type->ctype.modifiers;
 	int width;
 
@@ -107,19 +108,27 @@ static inline struct symbol *integer_pro
 	if (type->type == SYM_ENUM)
 		type = type->ctype.base_type;
 	width = type->bit_size;
-	if (type->type == SYM_BITFIELD)
+
+	/*
+	 * Bitfields always promote to the base type,
+	 * even if the bitfield might be bigger than
+	 * an "int".
+	 */
+	if (type->type == SYM_BITFIELD) {
 		type = type->ctype.base_type;
+		orig_type = type;
+	}
 	mod = type->ctype.modifiers;
 	if (width < bits_in_int)
 		return &int_ctype;
 
 	/* If char/short has as many bits as int, it still gets "promoted" */
 	if (mod & (MOD_CHAR | MOD_SHORT)) {
-		type = &int_ctype;
 		if (mod & MOD_UNSIGNED)
-			type = &uint_ctype;
+			return &uint_ctype;
+		return &int_ctype;
 	}
-	return type;
+	return orig_type;
 }
 
 /*
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Derek M Jones <derek () knosof ! co ! uk>
To: linux-sparse
Subject: Re: Asking about typechecking between different typedef types.
Date: Tue, 15 Nov 2005 18:36:10 +0000
Message-ID: <437A2A9A.5000105 () knosof ! co ! uk>
--------------------
Byoung-jip Kim wrote:
> All experts,

Ok, you sweet talked me ;-)

> I want sparse to check the assignment between two types which have the same
> base type but are defined differently with typedef.

This has traditionally been known as "strong" type checking.
In fact type often has little to do with what is desired, it
just so happens that people understand the idea of type
compatibility.

I would like to introduce this list to the term "role".
A variable can have a role and it can only be used in
a way that is compatible with its role.  For instance,
a  variable whose role is "counter for oranges" cannot
be mixed with a variable whose role is "counter for apples".

People might like to start off as thinking of about roles
as a kind of strong typing.

sparse already supports the bitwise role (or at least one of
the possible definitions of that role).  What you are asking for
is the ability to have user defined roles that are associated with
a set of actions that variables having that role may take part in.

For instance, variables having the role unordered might not
be operands of the relational operators.

#role unordered not {<, <=, >, >=}

variables having the counter role might only be incremented
or decremented

#role counter {++, --}

implementation is left as an exercise to the reader ;-)

-- 
Derek M. Jones                              tel: +44 (0) 1252 520 667
Knowledge Software Ltd                      mailto:derek@knosof.co.uk
Applications Standards Conformance Testing    http://www.knosof.co.uk
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Hubertus Franke <frankeh () watson ! ibm ! com>
To: linux-sparse
Subject: Re: Asking about typechecking between different typedef types.
Date: Tue, 15 Nov 2005 18:52:00 +0000
Message-ID: <437A2E50.5070003 () watson ! ibm ! com>
--------------------
 > On Tue, 15 Nov 2005, Linus Torvalds wrote:
 > >
 > > You may think you'd never do that, but even things like
 > >
 > >    mytype_t color = some_test ? yellow : red;
 > >
 > > would complain about "warning: implicit cast to nocast type", because
 > > "color" has been declared to only accept that particular enum, but the
 > > conditional operator has turned yellow/red from that enum into a plain
 > > integer ;/
 >

This we are not too worried about.
We are interested in catching ( like in the __user/__kernel case)
semantically wrong ids that first need to go through some transformation.

 > Actually, this may be due to an over-eager "integer promotion" thing. It
 > always turns a type into its base type, but if the type was already big
 > enough (like in the above case, where the type was an enum that was
 > already big enough - it's the same size as an "int"), that seems a bit
 > unnecessary.
 >
 > Al, what do you think about a patch like this? (Largely untested, but it
 > allows the above conditional expression to keep its type as long as
 > possible. Which would seem to be what we want to do.
 >
 > That's the only piece of code I've tested it on, though ;^).
 >

Essentially what we like to see is that any promotion in and out of
a type is prohibited. I hope you code piece does that.
So in the case of

typedef int __attribute__((nocast)) typ1_t;
typedef int __attribute__((nocast)) typ2_t;

typ1_t   x;
typ2_t	 y;
int      z;

all permutations of assignments should create a warning.


On a different note, does it make sense to extend sparses
recognized modifier to a expandable set?

With __bitwise / __user/__kernel particular cases were picked and pushed in.
Maybe a flexible way of defining those __keywords and their semantics
could be useful? Just a thought.

Thanks

-- Hubertus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Asking about typechecking between different typedef types.
Date: Tue, 15 Nov 2005 19:28:17 +0000
Message-ID: <Pine.LNX.4.64.0511151125360.3945 () g5 ! osdl ! org>
--------------------


On Tue, 15 Nov 2005, Hubertus Franke wrote:
> 
> Essentially what we like to see is that any promotion in and out of
> a type is prohibited. I hope you code piece does that.
> So in the case of
> 
> typedef int __attribute__((nocast)) typ1_t;
> typedef int __attribute__((nocast)) typ2_t;

No. "nocast" doesn't work that way, and doesn't create a new type.

What you're asking for is what "__attribute__((bitwise))" does. You _will_ 
get a new type for each typedef (each use, in fact). But it also restricts 
you in other ways (ie it will warn about operations that don't work on 
bitwise types.

> With __bitwise / __user/__kernel particular cases were picked and pushed in.
> Maybe a flexible way of defining those __keywords and their semantics
> could be useful? Just a thought.

I strongly syspect that the semantics are pretty hard to make generic. At 
some point it becomes just too complex to parse and remember the semantic 
description efficiently.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Asking about typechecking between different typedef types.
Date: Tue, 15 Nov 2005 19:35:51 +0000
Message-ID: <Pine.LNX.4.64.0511151129220.3945 () g5 ! osdl ! org>
--------------------


On Tue, 15 Nov 2005, Linus Torvalds wrote:
> On Tue, 15 Nov 2005, Hubertus Franke wrote:
> > 
> > Essentially what we like to see is that any promotion in and out of
> > a type is prohibited. I hope you code piece does that.
> > So in the case of
> > 
> > typedef int __attribute__((nocast)) typ1_t;
> > typedef int __attribute__((nocast)) typ2_t;
> 
> No. "nocast" doesn't work that way, and doesn't create a new type.

More detail about what I mean..

Both of those are just regular "int" types, and they will warn if cast 
away to something else than that. But they are compatible, so you can 
assign one to the other, or indeed sign it to a regular "int" variable and 
then cast _that_.

So "nocast" is a pretty weak thing, not some hard type-checking. It's 
useful for things like function arguments, where you don't want to 
_by_mistake_ cast it to something else during arithmetic or when passing 
it on to another function, but it's really just a way to give a warning on 
otherwise perfectly regular conversionse.

The "bitwise" thing is much stronger, and actually creates a strong type 
with full typechecking. I'd love to split up "bitwise" into two bits (the 
"create new type" bit and the "limit to bitwise ops"), but we never really 
had the reason (and thus energy) to..

(As mentioned, internally in sparse it actually already _is_ split up, 
with the "new type" part being a "struct symbol *" node of type 
SYM_RESTRICTED that stops type conversions. So the split-up should be 
largely a type parsing thing, together with some testing..)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bogus "invalid access past the end of" warnings. ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: Bogus "invalid access past the end of" warnings.
Date: Fri, 07 Jan 2005 20:46:46 +0000
Message-ID: <200501072342.27457.adobriyan () mail ! ru>
--------------------
Given the code:
==============================================================================
struct foo {
	/* long, int, short, char are fine */
        long long b:1;
};

void f(void)
{
        struct foo a;

        a.b = 1;
}
==============================================================================
latest sparse will complain:

test.c:5:6: warning: invalid access past the end of 'a' (0 4)

Same thing when checking drivers/w1/w1.c:

  CHECK   drivers/w1/w1.c
drivers/w1/w1.c:569:34: warning: invalid access past the end of 'rn' (4 8)

	Alexey
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Bogus "invalid access past the end of" warnings.
Date: Fri, 07 Jan 2005 22:26:07 +0000
Message-ID: <Pine.LNX.4.58.0501071417330.2272 () ppc970 ! osdl ! org>
--------------------


On Fri, 7 Jan 2005, Alexey Dobriyan wrote:
>
> Given the code:
> ==============================================================================
> struct foo {
> 	/* long, int, short, char are fine */
>         long long b:1;
> };
> 
> void f(void)
> {
>         struct foo a;
> 
>         a.b = 1;
> }
> ==============================================================================
> latest sparse will complain:

Ahh. Interesting. It really is an invalid access, even if it happens to be 
for the wrong reason. Sparse will access the bit as a "long long", and it 
really doesn't fit in the structure, because the structure has only been 
padded up in size to the _alignment_ of "long long", which is 4.

That's actually carefully done to match gcc behaviour, but it does end up 
in the illogical situation that we have decided that the "base size" of 
"b" is a 8-byte "long long", but that we only actually allocated 4 bytes 
for it because we didn't need any more.

I think the "illegal access" warning is correct per se, and that the bug
is that sparse should have downgraded the "long long" to a "long", when it
downgraded the size.

Or maybe it should warn about this with a better warning, and we should 
just make it clear that this is undefined behaviour. It's patently 
illogical to have a "long long" bitfield and not actually have a "long 
long" anywhere ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: How new Check 21 legislation is affecting you... ===

From: Cathleen Baer <CathleenB () concord ! etransmail4 ! com>
To: linux-sparse
Subject: How new Check 21 legislation is affecting you...
Date: Wed, 16 Feb 2005 04:48:56 +0000
Message-ID: <15345857.1108529336334.JavaMail.customerService () etransmail4 ! com>
--------------------
Good Afternoon!

Recenty intrdocuced legislation requires business and home users to print personal and business checks with security blank check stock and magnetic ink.
Please find qualified suppliers at Google by clicking on the followingl link.

http://www.google.com/search?sourceid=navclient&ie=UTF-8&rls=GGLC,GGLC:1969-53,GGLC:en&q=blank+check+paper%2C+magnetic+ink+for+inkjets


Thank you very much. 

Cathleen Baer                                     
Marketing & Relationship Representative
Globalzon Consulting Group 


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Is there a problem with list_for_each_entry_reverse() ? ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Is there a problem with list_for_each_entry_reverse() ?
Date: Tue, 14 Jun 2005 19:27:41 +0000
Message-ID: <Pine.LNX.4.58.0506141216090.8487 () ppc970 ! osdl ! org>
--------------------


On Tue, 14 Jun 2005, Mika Kukkonen wrote:
>
> Sparse complains in (at least) three places:
> 
> drivers/base/sys.c:261:2: warning: invalid access past the end of 'system_subsys' (12 12)

This would seem to be a sparse bug.

It claims an access at byte offset 12 of "system_subsys", and claims that 
the size of that identifier is 12 bytes long.

The "offset 12" part seems to be correct, but the size seems crap. I don't 
see why, though. It's a perfectly normal structure, even if it's declared 
with a macro that generates some ugly initializer..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Is there a problem with list_for_each_entry_reverse() ?
Date: Tue, 14 Jun 2005 19:32:51 +0000
Message-ID: <Pine.LNX.4.58.0506141231000.8487 () ppc970 ! osdl ! org>
--------------------


On Tue, 14 Jun 2005, Linus Torvalds wrote:
> 
> The "offset 12" part seems to be correct, but the size seems crap. I don't 
> see why, though. It's a perfectly normal structure, even if it's declared 
> with a macro that generates some ugly initializer..

Hmm.. Doing a breakpoint and a "show_symbol()" on that system_subsys 
symbol gives:

	struct subsystem static [addressable] [toplevel] system_subsys {
	        kset:0:0 at offset 0.0
	        rwsem:192:8 at offset 0.0
	}

which clearly shows that we have some problem with the "kset" structure 
(it's zero-sized in this thing).

Looks like we screwed up when recursing into the structure definition. 
I'll have to dig deeper..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Is there a problem with list_for_each_entry_reverse() ?
Date: Thu, 16 Jun 2005 22:25:36 +0000
Message-ID: <20050616222536.GE10613 () 64m ! dyndns ! org>
--------------------
Did you solved this problem already?

I try "make C=1" on latest git tree did not reproduce the problem.

  CHECK   drivers/base/sys.c
/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include/stdarg.h:58:9: warning: preprocessor token va_copy redefined
include/linux/compiler-gcc2.h:29:9: this was the original definition
drivers/base/sys.c:254:6: warning: symbol 'sysdev_shutdown' was not declared. Should it be static?
drivers/base/sys.c:306:5: warning: symbol 'sysdev_suspend' was not declared. Should it be static?
drivers/base/sys.c:353:5: warning: symbol 'sysdev_resume' was not declared. Should it be static?
drivers/base/sys.c:391:12: warning: symbol 'system_bus_init' was not declared. Should it be static?

Chris

On Tue, Jun 14, 2005 at 12:32:51PM -0700, Linus Torvalds wrote:
> 
> 
> On Tue, 14 Jun 2005, Linus Torvalds wrote:
> > 
> > The "offset 12" part seems to be correct, but the size seems crap. I don't 
> > see why, though. It's a perfectly normal structure, even if it's declared 
> > with a macro that generates some ugly initializer..
> 
> Hmm.. Doing a breakpoint and a "show_symbol()" on that system_subsys 
> symbol gives:
> 
> 	struct subsystem static [addressable] [toplevel] system_subsys {
> 	        kset:0:0 at offset 0.0
> 	        rwsem:192:8 at offset 0.0
> 	}
> 
> which clearly shows that we have some problem with the "kset" structure 
> (it's zero-sized in this thing).
> 
> Looks like we screwed up when recursing into the structure definition. 
> I'll have to dig deeper..
> 
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Is there a problem with list_for_each_entry_reverse() ?
Date: Fri, 17 Jun 2005 02:46:51 +0000
Message-ID: <Pine.LNX.4.58.0506161916230.8487 () ppc970 ! osdl ! org>
--------------------


On Thu, 16 Jun 2005, Christopher Li wrote:
>
> Did you solved this problem already?
> 
> I try "make C=1" on latest git tree did not reproduce the problem.

No, the bug is still there.

I know what it's about though. It's that damn recursive symbol type 
examination code again.

What happens is that we start to examine a "strict kset", which 
contains a pointer to a "struct subsystem", so we examine that. 
That in turn, contains a "struct kset", but when we examine that 
one we notice that we've already marked it "examined" and we decide 
that it has size zero (because we've _started_ examining it, but 
haven't finished, so we haven't set the size yet).

The problem is that we shouldn't follow pointers _at_all_ when we examine
objects (because they don't matter - a pointer is a pointer, so we can
examine them without examining what they point to).

However, the obvious fix (which is to remove the "examine_base_type()"
call entirely from "examine_pointer_type()") sadly leaves us with a lot of 
types not examined at all, because the rest of sparse just expects that a 
"examine type" will examine all sub-types too.

That obvious fix _is_ the correct fix, but I haven't had the energy to 
deal with the fall-out. We'd need to add a lot of "examine_symbol_type()" 
calls to things that follow pointers..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Is there a problem with list_for_each_entry_reverse() ?
Date: Fri, 17 Jun 2005 03:29:59 +0000
Message-ID: <Pine.LNX.4.58.0506162025240.8487 () ppc970 ! osdl ! org>
--------------------


On Thu, 16 Jun 2005, Linus Torvalds wrote:
> 
> That obvious fix _is_ the correct fix, but I haven't had the energy to 
> deal with the fall-out. We'd need to add a lot of "examine_symbol_type()" 
> calls to things that follow pointers..

Well, I did a first cut of this, and checked it in.

No guarantees - I may not follow enough pointers, and in general I may 
have broken tons of cases, but I fixed it well enough that that one file 
no longer complains.

I suspect I may have broken more than I fixed, but the old code was
definitely wrong in a very fundamental way, and I can now fix up any
breakage that results from some path that now doesn't examine all the
types "deep enough".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Is there a problem with list_for_each_entry_reverse() ?
Date: Fri, 17 Jun 2005 14:59:51 +0000
Message-ID: <20050617145951.GB12852 () 64m ! dyndns ! org>
--------------------

How about we keep a list of the pending for examine types. So at the
end of the out side scope we can re-examine the those types in the list.
Repeat until the list is empty.
Then we don't have the not "deep enough" problem.

I run into similar problem before try to generate python objects
for every C type.  I wish I can reproduce the bug so I have some thing to
play with.

Chris

On Thu, Jun 16, 2005 at 08:29:59PM -0700, Linus Torvalds wrote:
> I suspect I may have broken more than I fixed, but the old code was
> definitely wrong in a very fundamental way, and I can now fix up any
> breakage that results from some path that now doesn't examine all the
> types "deep enough".
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Is there a problem with list_for_each_entry_reverse() ?
Date: Fri, 17 Jun 2005 18:39:26 +0000
Message-ID: <Pine.LNX.4.58.0506171134160.2268 () ppc970 ! osdl ! org>
--------------------


On Fri, 17 Jun 2005, Christopher Li wrote:
> 
> How about we keep a list of the pending for examine types. So at the
> end of the out side scope we can re-examine the those types in the list.
> Repeat until the list is empty.
> Then we don't have the not "deep enough" problem.

Well, there _are_ actually advantages with the "not deep enough" thing, so
the old behaviour was just because I was lazy and it seemed to be the
easiest approach to not have to worry about partially examined types
anywhere else..

But the advantages are:

 - it avoids the bug/problems with recursion. 'nuff said.

 - it's really how C works. You can use pointers to totally undefined 
   objects in C (you just can't dereference them), so in many ways what 
   sparse used to do was "impossible" in C anyway.

 - it's potentially useful behaviour - we now examine less of a type, 
   which might mean that we perform better (not that this is going to be
   noticeable, I bet) but more importantly it might also be useful for 
   anything that tries to figure out "which header files were actually
   needed".

So I'm happy adding a few "examine_symbol_type()" in places where we need 
them. If we need them. (And I made a "symbol_base_type()" helper function 
that does the examine for you as it delves into the base type, so it's 
actually fairly easy in most cases).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Mercurial mirror of sparse repository now available ===

From: "Bryan O'Sullivan" <bos () serpentine ! com>
To: linux-sparse
Subject: Mercurial mirror of sparse repository now available
Date: Mon, 26 Dec 2005 22:27:11 +0000
Message-ID: <1135636031.1527.12.camel () serpentine ! pathscale ! com>
--------------------
Updated several times a day from the git master at kernel.org.

http://hg.serpentine.com/linux/sparse


	<b

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Missing offset of fields or bitfields inside structure ===

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Missing offset of fields or bitfields inside structure
Date: Sun, 27 Nov 2005 20:29:01 +0000
Message-ID: <438A170D.1090001 () looxix ! net>
--------------------
Somewhere in the process, sparse forget to take in account the offset
of fields inside structure, but not in al cases, because __buitin_offsetof(),
which basical use the same code sequence as the ones below is correct.

For example, test-linearize give the same output for the functions in
the following code:

         struct int_struct {
                 unsigned int    u_0;
                 unsigned int    u_1;
                 int             s_2;
         };


         unsigned int extract_u_0(struct int_struct *is)
         {
                 return is->u_0;
         }

         unsigned int extract_u_1(struct int_struct *is)
         {
                 return is->u_1;
         }

=>
         extract_u_0:
                 load.32     %r37 <- 0[%arg1]
                 ret.32      %r37


         extract_u_1:
                 load.32     %r40 <- 0[%arg1]
                 ret.32      %r40


But, with offsetof():

         unsigned int get_offset_u_1(void)
         {
                 return __builtin_offsetof(struct int_struct, u_1);
         }

=>
         get_offset_u_1:
                 ret.32      $4



Bitfields have the same problems:

         struct bitfield {
                 unsigned int    u_0_1:1;
                 unsigned int    u_1_1:1;
         };

         unsigned int extract_u_0_1(struct bitfield *bf)
         {
                 return bf->u_0_1;
         }

         unsigned int extract_u_1_1(struct bitfield *bf)
         {
                 return bf->u_1_1;
         }

=>
         extract_u_0_1:
                 load.32     %r6 <- 0[%arg1]
                 cast.32     %r7 <- (1) %r6
                 ret.32      %r7


         extract_u_1_1:
         .L0xf7f810ac:
                 load.32     %r10 <- 0[%arg1]
                 cast.32     %r11 <- (1) %r10
                 ret.32      %r11



Luc Van Oostenryck

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Missing offset of fields or bitfields inside structure
Date: Mon, 28 Nov 2005 01:23:07 +0000
Message-ID: <Pine.LNX.4.64.0511271718540.13959 () g5 ! osdl ! org>
--------------------


On Sun, 27 Nov 2005, Luc Van Oostenryck wrote:
>
> Somewhere in the process, sparse forget to take in account the offset
> of fields inside structure, but not in al cases, because __buitin_offsetof(),
> which basical use the same code sequence as the ones below is correct.

Thanks.

Doing a bit of bisecting shows that it was commit 

  017034ed49eb0c0fdf91a4109faedf389c81fa9b:
	Fix up type examination.

that introduced this bug, and it turns out that it seems to be a lost type 
examination when we dereference a pointer.

I think the attached patch fixes your problem case, but it's not the right 
fix. We really shouldn't examine the type behind a pointer until the point 
where the pointer is actually used, otherwise we can get into nasty 
problems with pointers to structures that aren't defined yet etc.

		Linus

----
diff --git a/symbol.c b/symbol.c
index 67576fe..0d1552e 100644
--- a/symbol.c
+++ b/symbol.c
@@ -345,6 +345,7 @@ static struct symbol *examine_pointer_ty
 		sym->bit_size = bits_in_pointer;
 	if (!sym->ctype.alignment)
 		sym->ctype.alignment = pointer_alignment;
+	examine_base_type(sym);
 	return sym;
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Multi-object module oddity ===

From: Tommy Reynolds <Tommy.Reynolds () MegaCoder ! com>
To: linux-sparse
Subject: Multi-object module oddity
Date: Sat, 01 Jan 2005 01:56:00 +0000
Message-ID: <20041231195600.28d99b7b.Tommy.Reynolds () MegaCoder ! com>
--------------------
--Signature=_Fri__31_Dec_2004_19_56_00_-0600_2pU6ha/ccyk_wh./
Content-Type: text/plain; charset=US-ASCII
Content-Disposition: inline
Content-Transfer-Encoding: 7bit

Hi, all!

I have a two-file module and the Makefile:

	obj-m	:= hello.o
	hello-objs := file1.o file2.o

The module builds fine, but sparse complains:

$ make -C /usr/src/linux M=$PWD O=$PWD/../obj-kernel C=1 clean modules
make: Entering directory `/usr/src/linux-2.6.9'
  CLEAN   /home/reynolds/labs/twofiles/.tmp_versions
  CHECK   /home/reynolds/labs/twofiles/file1.c
  CC [M]  /home/reynolds/labs/twofiles/file1.o
  CHECK   /home/reynolds/labs/twofiles/file2.c
  CC [M]  /home/reynolds/labs/twofiles/file2.o
  LD [M]  /home/reynolds/labs/twofiles/hello.o
  Building modules, stage 2.
  MODPOST
*** Warning: "message" [/home/reynolds/labs/twofiles/hello.ko] undefined!
  CC      /home/reynolds/labs/twofiles/hello.mod.o
  LD [M]  /home/reynolds/labs/twofiles/hello.ko

How do I turn this warning off?

Thanks!

--Signature=_Fri__31_Dec_2004_19_56_00_-0600_2pU6ha/ccyk_wh./
Content-Type: application/pgp-signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.6 (GNU/Linux)

iD8DBQFB1gM2/0ydqkQDlQERAlWiAJ9jPXU9mabbVshklsfBE1npQxGcygCdEFCB
ua4fnGCp+DT6i6VzOWGbZUI=
=EOlP
-----END PGP SIGNATURE-----

--Signature=_Fri__31_Dec_2004_19_56_00_-0600_2pU6ha/ccyk_wh./--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Old "sparse" archive converted.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Old "sparse" archive converted..
Date: Sun, 24 Apr 2005 01:25:05 +0000
Message-ID: <Pine.LNX.4.58.0504231815350.2344 () ppc970 ! osdl ! org>
--------------------

Ok, I expanded on "convert-cache" quite a bit, to the point where it could
actually re-write "commit" and "tree" objects entirely, at which point it
now became possible to convert the broken old sparse archive that had the
wrong date format in its commit objects, and had the old flat-file format
for the "tree" objects.

I updated the tree at

	kernel.org:/pub/linux/kernel/people/torvalds/sparse.git

to be this modern-format tree that fsck-cache no longer complains about.

If anybody is keeping an old-format tree around, I'll just warn you that 
I'm not going to necessarily guarantee that git will be able to read it in 
the future, so you should replace it with the modern one (which should 
just be a matter of either deleting the old one and getting a new copy, or 
you could do a

	convert-cache $(cat .git/HEAD)
	echo ..result.. > .git/HEAD
	git-prune-script
	read-tree $(cat .git/HEAD)
	update-cache --refresh
	fsck-cache --unreachable $(cat .git/HEAD)

which _should_ get you a clean tree with a top commit with the name
f765413f020fd2c97c22716320dc96b33cda7c43 if everything went right.

I'm considering turning on SHA1 validation by default when reading
objects, just because it's the right thing to do from a "find any fs
corruption early" angle, and it should be fairly cheap. That will make old 
pre-conversion trees no longer work.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: git
Subject: Old "sparse" archive converted..
Date: Sun, 24 Apr 2005 01:25:05 +0000
Message-ID: <Pine.LNX.4.58.0504231815350.2344 () ppc970 ! osdl ! org>
--------------------

Ok, I expanded on "convert-cache" quite a bit, to the point where it could
actually re-write "commit" and "tree" objects entirely, at which point it
now became possible to convert the broken old sparse archive that had the
wrong date format in its commit objects, and had the old flat-file format
for the "tree" objects.

I updated the tree at

	kernel.org:/pub/linux/kernel/people/torvalds/sparse.git

to be this modern-format tree that fsck-cache no longer complains about.

If anybody is keeping an old-format tree around, I'll just warn you that 
I'm not going to necessarily guarantee that git will be able to read it in 
the future, so you should replace it with the modern one (which should 
just be a matter of either deleting the old one and getting a new copy, or 
you could do a

	convert-cache $(cat .git/HEAD)
	echo ..result.. > .git/HEAD
	git-prune-script
	read-tree $(cat .git/HEAD)
	update-cache --refresh
	fsck-cache --unreachable $(cat .git/HEAD)

which _should_ get you a clean tree with a top commit with the name
f765413f020fd2c97c22716320dc96b33cda7c43 if everything went right.

I'm considering turning on SHA1 validation by default when reading
objects, just because it's the right thing to do from a "find any fs
corruption early" angle, and it should be fairly cheap. That will make old 
pre-conversion trees no longer work.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Old "sparse" archive converted..
Date: Sun, 24 Apr 2005 05:24:18 +0000
Message-ID: <426B2D82.5000906 () pobox ! com>
--------------------
Linus Torvalds wrote:
> Ok, I expanded on "convert-cache" quite a bit, to the point where it could
> actually re-write "commit" and "tree" objects entirely, at which point it
> now became possible to convert the broken old sparse archive that had the
> wrong date format in its commit objects, and had the old flat-file format
> for the "tree" objects.
> 
> I updated the tree at
> 
> 	kernel.org:/pub/linux/kernel/people/torvalds/sparse.git

Any chance you could copy it to

	/pub/scm/linux/kernel/git/torvalds/sparse.git

?

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: git
Subject: Re: Old "sparse" archive converted..
Date: Sun, 24 Apr 2005 05:24:18 +0000
Message-ID: <426B2D82.5000906 () pobox ! com>
--------------------
Linus Torvalds wrote:
> Ok, I expanded on "convert-cache" quite a bit, to the point where it could
> actually re-write "commit" and "tree" objects entirely, at which point it
> now became possible to convert the broken old sparse archive that had the
> wrong date format in its commit objects, and had the old flat-file format
> for the "tree" objects.
> 
> I updated the tree at
> 
> 	kernel.org:/pub/linux/kernel/people/torvalds/sparse.git

Any chance you could copy it to

	/pub/scm/linux/kernel/git/torvalds/sparse.git

?

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Old "sparse" archive converted..
Date: Sun, 24 Apr 2005 19:53:52 +0000
Message-ID: <Pine.LNX.4.58.0504241252360.15879 () ppc970 ! osdl ! org>
--------------------


On Sun, 24 Apr 2005, Jeff Garzik wrote:
> 
> Any chance you could copy it to
> 
> 	/pub/scm/linux/kernel/git/torvalds/sparse.git

Done.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: git
Subject: Re: Old "sparse" archive converted..
Date: Sun, 24 Apr 2005 19:53:52 +0000
Message-ID: <Pine.LNX.4.58.0504241252360.15879 () ppc970 ! osdl ! org>
--------------------


On Sun, 24 Apr 2005, Jeff Garzik wrote:
> 
> Any chance you could copy it to
> 
> 	/pub/scm/linux/kernel/git/torvalds/sparse.git

Done.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: PATCH: add 2 attributes ===

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: PATCH: add 2 attributes
Date: Mon, 18 Apr 2005 22:32:57 +0000
Message-ID: <20050418223256.GA20992 () redhat ! com>
--------------------

--17pEHd4RhPHOinZp
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

Hello,

the __stdcall__ and __cdecl__ attributes are used a lot in Wine and are
driving sparse into printing "warning: too many warnings"

Changelog:
Michael Stefaniuc <mstefani@redhat.com>
- add handling for __stdcall__ and __cdecl__ attributes aka ignore them
  for now


diff -urp sparse.orig/ident-list.h sparse/ident-list.h
--- sparse.orig/ident-list.h	2005-04-19 00:22:46.000000000 +0200
+++ sparse/ident-list.h	2005-04-18 23:54:38.000000000 +0200
@@ -54,6 +54,7 @@ IDENT(syscall_linkage); IDENT(visibility
 IDENT(bitwise);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
+IDENT(__cdecl__); IDENT(__stdcall__);
=20
 /* Preprocessor idents */
 __IDENT(pragma_ident, "__pragma__", 0);
diff -urp sparse.orig/parse.c sparse/parse.c
--- sparse.orig/parse.c	2005-04-19 00:22:46.000000000 +0200
+++ sparse/parse.c	2005-04-19 00:18:47.000000000 +0200
@@ -471,6 +471,9 @@ static const char * handle_attribute(str
 	if (attribute =3D=3D &model_ident ||
 	    attribute =3D=3D &__model___ident)
 		return NULL;
+	if (attribute =3D=3D &__cdecl___ident ||
+	    attribute =3D=3D &__stdcall___ident)
+		return NULL;
=20
 	return "unknown attribute";
 }
=09
--=20
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart

--17pEHd4RhPHOinZp
Content-Type: application/pgp-signature
Content-Disposition: inline

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.1 (GNU/Linux)

iD8DBQFCZDWY08alQ5mXm14RAk0TAKCRRDyHRs7uPLKL/kHMhhRgTLodCACfffWq
g3Ve9ElPJhM0nvMH5dfxb/A=
=MRxU
-----END PGP SIGNATURE-----

--17pEHd4RhPHOinZp--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Random code generation question ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Random code generation question
Date: Wed, 16 Feb 2005 17:35:27 +0000
Message-ID: <4213845F.8090500 () pobox ! com>
--------------------

One of my long term goals is to create a highly portable C compiler 
backend, with _little_ or no optimization, to ship as "c99" along with 
the other posixutils I am writing:
http://www.opengroup.org/onlinepubs/009695399/utilities/c99.html
http://www.opengroup.org/onlinepubs/009695399/idx/utilities.html


As such, after I got compile-i386 working, I was going to work on 
getting sparse to generate a high-level intermediate language.  This 
intermediate language (IL) is essentially a high level assembly language 
that knows about simple types.  My [non-existent] backend would take 
this intermediate language -- which could be produced by sparse or a 
fortran-77 front-end -- and turns it into binary code.


My question:  do people think its better to generate this intermediate 
language from the high-level tree (a la compile-i386), or the 
lower-level linearized basic blocks?

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 17:55:43 +0000
Message-ID: <Pine.LNX.4.58.0502160952550.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Jeff Garzik wrote:
> 
> My question:  do people think its better to generate this intermediate 
> language from the high-level tree (a la compile-i386), or the 
> lower-level linearized basic blocks?

Please use the linearized blocks. It currently may lose some type
information, but that should be easy to fix (you'd just have to add a
"ctype" to each "struct instruction", something I've been considering 
anyway instead of the current "size" field).

The linearized format should pretty much _be_ a high-level IL already in 
many ways, and then you have the option of doing CSE or not on it as you 
please..

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:09:42 +0000
Message-ID: <42138C66.9050002 () pobox ! com>
--------------------
Linus Torvalds wrote:
> 
> On Wed, 16 Feb 2005, Jeff Garzik wrote:
> 
>>My question:  do people think its better to generate this intermediate 
>>language from the high-level tree (a la compile-i386), or the 
>>lower-level linearized basic blocks?
> 
> 
> Please use the linearized blocks. It currently may lose some type
> information, but that should be easy to fix (you'd just have to add a
> "ctype" to each "struct instruction", something I've been considering 
> anyway instead of the current "size" field).

Yeah, I need the full type info, in order to properly align things on 
the stack, and in order to implement automatic and static initializers, 
among other things.

I also need to make the target runtime-switchable (x86 vs. x86-64 vs. 
big endian sparc64), if it's not already.


> The linearized format should pretty much _be_ a high-level IL already in 
> many ways, and then you have the option of doing CSE or not on it as you 
> please..

Since the linearized format is an SSA-like form, that makes a few things 
in the backend easier.

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:28:25 +0000
Message-ID: <Pine.LNX.4.58.0502161015140.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Jeff Garzik wrote:
> 
> I also need to make the target runtime-switchable (x86 vs. x86-64 vs. 
> big endian sparc64), if it's not already.

Everything should be run-time-switchable, but of course "everything" right 
now means "32-bit vs 64-bit". None of the generic passes should care about 
anything else.

There's a lack of switchability of default alignments, and that does
differ. The defaults are sane, but not necessarily correct (ie the
alignment of a 64-bit entity might be 32-bit or 64-bit, there's no switch
to select which). See "max_int_alignment" and "max_fp_alignment". Right 
now the default is:

 - 32-bit architectures: 4-byte alignment for 64-bit integers
 - 64-bit architectures: 8-byte alignment for 64-bit integers

and I think there are potentially 32-bit architectures that might want to 
see the 8byte/64-bit alignment, but I don't know.

Byte order is not visibile to the linearized format, since it will not
optimize away loads/stores for partially overlapping regions.

> > The linearized format should pretty much _be_ a high-level IL already in 
> > many ways, and then you have the option of doing CSE or not on it as you 
> > please..
> 
> Since the linearized format is an SSA-like form, that makes a few things 
> in the backend easier.

It's not just SSA-like, it _is_ SSA. Of course, later phases may choose to
break the SSA requirements (and right now you get some of the later passes
by default, like "pseudo death tracking"), but the basic linearizer should
be strictly SSA, and note how CSE is already done.

Ie you really do get CSE and a number of trivial simplifications (like
canonical argument type ordering forcommutative ops, which means that you
know where you'll find constants etc) for free if you use the linearizer.

The biggest problem (and that's not a big one) is if you want to only get
part of the work done - then you need to split up (or conditionalize)  
parts of "linearize_fn()".

The current "./test-linearizer" thing really already comes pretty close to 
what you're talking about. Modulo types, again.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:32:40 +0000
Message-ID: <Pine.LNX.4.58.0502161029190.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Linus Torvalds wrote:
> 
> The current "./test-linearizer" thing really already comes pretty close to 
> what you're talking about. Modulo types, again.

Oh, forgot to mention: the "storage.c" phase, which is used by "example.c" 
is also meant to be entirely architecture-neutral, and does liveness 
analysis both within and between basic blocks, and allocates "storage" for 
any pseudo that has inter-bb visibility.

It needs an architecture-specific part to set up incoming argument storage
types and calling conventions, though. See "example.c" for the generic
part ("set_up_storage(ep);") and the arch-specific part
("arch_set_up_storage(ep);").

Whether you want to use the storage module or not, I can't tell. I _think_ 
it's reasonably well-suited to whatever you need to do, but who knows..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:41:49 +0000
Message-ID: <20050216184149.AD6191422D5E () darter ! rentec ! com>
--------------------

> Everything should be run-time-switchable

Ah, the power of modal verbs.

The evaluation of constant expressions is pretty solidly tied between the
target platform and the host platform.

For integers that is probably not a huge problem unless your target
platform has 128-bit long longs.  Or uses 1-complement representation,
oh horror.

For floating point, if you care, there are practical differences that it
is going to be really hard to get rid of.  Your x86 chip's long double
isn't going to emulate the sparc's long double very well.  It's 80-bit
vs. 128-bit.  To even get to compile-time switchability you are looking
at floating-point emulation.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:44:44 +0000
Message-ID: <4213949C.7090305 () pobox ! com>
--------------------
Morten Welinder wrote:
> For floating point, if you care, there are practical differences that it
> is going to be really hard to get rid of.  Your x86 chip's long double
> isn't going to emulate the sparc's long double very well.  It's 80-bit
> vs. 128-bit.  To even get to compile-time switchability you are looking
> at floating-point emulation.


Eventually... yes.  RTH did this for gcc many moons ago.

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:46:49 +0000
Message-ID: <42139519.6020401 () pobox ! com>
--------------------
In example.c:

         FOR_EACH_PTR(list, sym) {
                 struct entrypoint *ep;
                 expand_symbol(sym);
                 ep = linearize_symbol(sym);
                 if (ep)
                         output(ep);
         } END_FOR_EACH_PTR(sym);

Does 'struct entrypoint' include stuff outside function scope like 
global and static variables?

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:49:35 +0000
Message-ID: <Pine.LNX.4.58.0502161044260.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Morten Welinder wrote:
> 
> The evaluation of constant expressions is pretty solidly tied between the
> target platform and the host platform.

Integers are perfectly defined by the word-size. Nobody sane cares about 
anything else than normal 2s-complement.

> For floating point, if you care, there are practical differences that it
> is going to be really hard to get rid of.  Your x86 chip's long double
> isn't going to emulate the sparc's long double very well.  It's 80-bit
> vs. 128-bit.  To even get to compile-time switchability you are looking
> at floating-point emulation.

I'm very much against the idea of even trying. Somebody else can if they 
care, but I won't merge it into my tree. It's a total waste of compiler 
time, imnsho, and you absolutely cannot do it "correctly" anyway. Even 
trying just shows how misguided you are.

Anybody who cares about the precision difference of compile-time vs 
run-time would also care about things like rounding modes, which are 
_dynamic_, for christ sake. Ie you have two and exactly two options:

 - do no FP constants at _all_ at compile-time
 - do a best-effort that you say up-front is not going to be the same as 
   the run-time one because of issues like dynamic rounding etc.

Notice: in neither case is it at all interesting to have SW FP emulation
in the compiler.

Yeah, yeah, some FP people will disagree. FP people are a damn 
disagreeable lot, and I just don't care. 

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 18:53:17 +0000
Message-ID: <4213969D.9070008 () pobox ! com>
--------------------
Linus Torvalds wrote:
> I'm very much against the idea of even trying. Somebody else can if they 
> care, but I won't merge it into my tree. It's a total waste of compiler 
> time, imnsho, and you absolutely cannot do it "correctly" anyway. Even 
> trying just shows how misguided you are.


RTH already did it, so it can be linked in as a lib to avoid polluting 
sparse :)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 19:04:04 +0000
Message-ID: <Pine.LNX.4.58.0502161052430.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Linus Torvalds wrote:
> 
> Yeah, yeah, some FP people will disagree. FP people are a damn 
> disagreeable lot, and I just don't care. 

Side note: from what I've seen, even the disagreeable FP people have long
since given up, and if they don't trust the compiler (and they won't,
since by definition they are disagreeable), they'll make their strict
bit-for-bit requirements by just writing the FP number as a hexadecimal
constant. Again - the compiler FP constant code has nothing to do with it.

What the compiler FP constant arithmetic should care about is the 
"obvious" cases, because it can't get the non-obvious cases right anyway. 

So FP constant folding should try to get the "obvious" answer to things 
like "2*0.5" right, which btw means that it should absolutely avoid tryign 
to think about rounding modes (ie it should always round-to-nearest, and 
screw the fact that maybe the user has asked for a different rounding 
mode).

Try this program:

	#include <math.h>
	#include <fenv.h>
	#include <sched.h>

	double hide(double);

	int main(int argc, char **argv)
	{
		double x = hide(3);
		double y = hide(1/3.0);

		fesetround(FE_TOWARDZERO);
	
		printf("%.20lf\n", x*y);	
		return 0;
	}

	double hide(double x)
	{
		return x;
	}

with and without the "fesetround()" to see what I'm talking about. One
case will return 1 (with a lot of zeroes), while the other will return
0.99999999999999988898 (on the particular architecture where I happened to
test this).

The compiler CANNOT do that FP math simplification "right" (where "right"  
means "same as if it didn't simplify"). End of story.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 19:07:58 +0000
Message-ID: <Pine.LNX.4.58.0502161104410.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Jeff Garzik wrote:
>
> In example.c:
> 
>          FOR_EACH_PTR(list, sym) {
>                  struct entrypoint *ep;
>                  expand_symbol(sym);
>                  ep = linearize_symbol(sym);
>                  if (ep)
>                          output(ep);
>          } END_FOR_EACH_PTR(sym);
> 
> Does 'struct entrypoint' include stuff outside function scope like 
> global and static variables?

No. The linearizer will do nothign with those. So you'd generally do 
something like this:

	FOR_EACH_PTR(list, sym) {
		struct entrypoint *ep;
		expand_symbol(sym);
		ep = linearize_symbol(sym);
		if (ep)
			output_code(ep);
		else if (sym->initializer)
			output_initializer(sym);
		else 
			output_bss(sym);
	} END_FOR_EACH_PTR(sym);

(or _something_ like that, you get the idea)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 19:26:26 +0000
Message-ID: <20050216192626.6773B1422D5E () darter ! rentec ! com>
--------------------

All good and fine, but come out of the bush and let us know that you
never do any floating point stuff at all.

It is entirely reasonable to expect this to work:

// --------------------------------------------------------------------------
#include <whateveritis.h>
static const long double l = LDBL_MIN;
// _static_ rounding mode, btw., since that was a static.

int main ()
{
  assert (l != 0);
  return 0;
}
// --------------------------------------------------------------------------

That leaves you two choices:

1. Target==host, i.e., no run-time or compile-time switchability.
2. Emulation.

(1) isn't too bad to live with as long as you can cross-compile enough
to bootstrap.  gcc pretends to be a serious cross-compilation setup so
they really have no choice but to do (2).

Oh, and your sample program is pointless for this discussion: what you are
observing is that printf produces different results for the same argument
depending on rounding mode.  Your "hide" function is called before you set
rounding mode so it has no effect whatsoever.

M.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 19:26:51 +0000
Message-ID: <Pine.LNX.4.58.0502161115220.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Chris Lattner wrote:
>
> > The compiler CANNOT do that FP math simplification "right" (where "right"
> > means "same as if it didn't simplify"). End of story.
> 
> Note that your example isn't a conformant C99 program unless you use the 
> "#pragma STDC FENV_ACCESS" pragma, to tell the compiler that you're 
> messing with rounding modes.
> 
> http://www.iyonix.com/tools/c99pragmas.shtml
> 
> Given conformant programs and a correct compiler, the things you're 
> claiming are impossible are quite possible.  That said, those two 
> assumptions are hard to satisfy these days. :)

I stand by my claim.

The compiler can _avoid_ doing any FP simplification at all. But the 
compiler ABSOLUTELY CANNOT do FP math simplification and still give the 
same result as run-time would. It's one of either: "don't simplify 
constants" or "simplify constants and perhaps get it wrong".

See my argument? In neither case is it a case of "add complex software 
calculation routines". It's an "either do, or do not".

What you can do is have a notion of "exact", of course. "2.0*0.5" can
always be simplified, simply because they are exactly representable
regardless of rounding modes. You don't actually need to have any SW Fp
for that, though, since the HW FP itself will obviously be perfectly fine
for this case.

You'd need to have the host architecture able to handle FE_INEXACT etc, of 
course. And trust your "ascii-to-fp" routine to do the right thing. I 
still maintain that the number of people that really care is starting to 
be infinitesimal.

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 19:41:08 +0000
Message-ID: <Pine.LNX.4.58.0502161136490.2383 () ppc970 ! osdl ! org>
--------------------


On Wed, 16 Feb 2005, Morten Welinder wrote:
> 
> Oh, and your sample program is pointless for this discussion: what you are
> observing is that printf produces different results for the same argument
> depending on rounding mode.  Your "hide" function is called before you set
> rounding mode so it has no effect whatsoever.

That's part of the _point_. 

The point was that

	(1.0/3.0)*3.0

cannot be simplified without knowing the rounding mode.

I'm perfectly happy to support the standard "float" and "double" modes, 
and just say that everybody is IEEE.  That absolutely covers all of the 
interesting market as far as I'm concerned. 

Come back to me when sparse has no issues on the regular side, and maybe 
I'll change my mind. I'm nothing if not flexible. I refuse to bother with 
stupid cases that nobody sane cares about until we handle all the _normal_ 
cases.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: Random code generation question
Date: Wed, 16 Feb 2005 19:46:02 +0000
Message-ID: <Pine.LNX.4.61.0502161343110.31934 () nondot ! org>
--------------------
On Wed, 16 Feb 2005, Linus Torvalds wrote:
> On Wed, 16 Feb 2005, Chris Lattner wrote:
>>
>>> The compiler CANNOT do that FP math simplification "right" (where "right"
>>> means "same as if it didn't simplify"). End of story.
>>
>> Note that your example isn't a conformant C99 program unless you use the
>> "#pragma STDC FENV_ACCESS" pragma, to tell the compiler that you're
>> messing with rounding modes.
>>
>> http://www.iyonix.com/tools/c99pragmas.shtml
>>
>> Given conformant programs and a correct compiler, the things you're
>> claiming are impossible are quite possible.  That said, those two
>> assumptions are hard to satisfy these days. :)
>
> I stand by my claim.
>
> The compiler can _avoid_ doing any FP simplification at all. But the
> compiler ABSOLUTELY CANNOT do FP math simplification and still give the
> same result as run-time would. It's one of either: "don't simplify
> constants" or "simplify constants and perhaps get it wrong".
> See my argument? In neither case is it a case of "add complex software
> calculation routines". It's an "either do, or do not".

No, you're missing the point.  The point is that C allows the compiler to 
do exactly the simplifications we all want, UNLESS, FENV_ACCESS is 
explicitly used to tell it not to.  IFF the pragma is set, the compiler's 
"hands" are tied: otherwise (common case) it can do whatever it wants.

This is similar to how volatile affects redundancy elimination.

> What you can do is have a notion of "exact", of course. "2.0*0.5" can
> always be simplified, simply because they are exactly representable
> regardless of rounding modes. You don't actually need to have any SW Fp
> for that, though, since the HW FP itself will obviously be perfectly fine
> for this case.

Sure, and that's an example of the kind of optimization you could do even 
if the FENV_ACCESS pragma is set.

> I still maintain that the number of people that really care is starting 
> to be infinitesimal.

Note that I'm not claiming that *you* or *sparse* should care, I'm just 
saying that C99 makes all of these things quite possible for conformant 
compilers.

-Chris

-- 
http://nondot.org/sabre/
http://llvm.cs.uiuc.edu/
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Rationale for OP_PHISOURCE ? ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 20:22:23 +0000
Message-ID: <4380DAFF.2010007 () looxix ! net>
--------------------
I'm playing a bit with test-linearize and example.c and I'm wondering
what is the rationale for OP_PHISOURCE.
While I think I understand what are these phi-sources (it add def-use
information for phi-nodes "arguments"), I'm not sure I understand for what
they should be used.
For example, they are used in example.c to eliminate the OP_PHI but I think
this is wrong, like in the "lost copy problem":

Source:
	int p(void);

	int foo(int a)
	{
         	int x, y;

         	x = 0;

         	do {
                 	y = x;
                 	x = x + 1;
         	} while (p());
		// If p() return 0 the first time it is called,
		// the return value should also be 0.

         	return y;
	}


Output of test-linearize:
	foo:
	.L0xf7f8900c:
         	<entry-point>
         	phisrc.32   %phi2(x) <- $0     (%r1)
         	br          .L0xf7f89034

	.L0xf7f89034:
         	phi.32      %r1 <- %phi2(x), %phi3(x)
         	dead        %r1				# wrong! used in the next bb
         	add.32      %r3 <- %r1, $1
         	dead        %r3
         	phisrc.32   %phi3(x) <- %r3     (%r1)
         	call.32     %r4 <- p
         	dead        %r4
         	br          %r4, .L0xf7f89034, .L0xf7f890ac

	.L0xf7f890ac:
         	dead        %r1
         	ret.32      %r1

In .L0xf7f89034, %r1 is marked as death but it is used as the return value in .L0xf7f890ac.
On .L0xf7f89034 entry, y and x have the same value = %r1;
while on exit x is now %r3 / %phi3, y is still %r1.

Output of example:
.globl foo
foo:
         movl $0,%eax                    # fill_reg
         jmp .L0xf7f89034                # generate_branch

.L0xf7f89034:
         add.32 $1,%eax          	# do_binop
         movl %eax,0(SP)         	# flush_one_pseudo
         call p          		# generate_call
         testl %eax,%eax         	# generate_branch
         movl 0(SP),%eax         	# fill_output
         jne .L0xf7f89034                # generate_branch
         jmp .L0xf7f890ac                # generate_branch

.L0xf7f890ac:
         ret             		# generate_ret


The phi node is now removed, the phisrc have been replaced by moves to %eax,
but we have lost the value of y (%r1) at the entry of the loop.

Thus my questions are:
- are the phisrc only present to beable the later remove the phi-nodes or
   are they also usefull for other things?
- is the problem above only a consequence of the wrong death annotation,
   or are the phisrc part of the problem?
- is there any reference on these phisrc or are they something new, specific to sparse?


Thanks,

Luc Van Oostenryck

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 20:50:51 +0000
Message-ID: <Pine.LNX.4.64.0511201231570.13959 () g5 ! osdl ! org>
--------------------


On Sun, 20 Nov 2005, Luc Van Oostenryck wrote:
>
> I'm playing a bit with test-linearize and example.c and I'm wondering
> what is the rationale for OP_PHISOURCE.

The OP_PHISOURCE allows the combination and removal of basic blocks, 
without having to worry about a basic block being a phi source.

If you go back in history in sparse, before OP_PHISOURCE, it used to be a 
_major_ pain to track where the phi sources came from, with a phi being a 
more traditional list of "basic-block + pseudo". That was all replaced by 
just making it a list of these "OP_PHISOURCE" instructions, since the 
instructions fundamentally already have exactly that information (ie the 
pseudo is the pseudo that the instruction defines, and the basic block is 
the basic block that all instructions already have).

In other words, OP_PHISOURCE made it trivial to notice (for example) that 
when a basic block became unreachable, that particular part of the phi was 
no longer interesting.

There were other major simplifications from it too (combining basic blocks 
suddenly became possible).

Just as an example: if we have a basic block that is empty and just 
branches to another basic block (very common, happens for trivial reasons 
around most loops), we can "obviously" trivially combine it into all of 
its callers. But if there's a phi-node associated with that basic block, 
that would be wrong. So by having that OP_PHISOURCE instruction, that 
"empty" basic block simply isn't empty any more, and the problem never 
arises.

> While I think I understand what are these phi-sources (it add def-use
> information for phi-nodes "arguments"), I'm not sure I understand for what
> they should be used.

Normally they shouldn't be used, they really are more of an abstraction 
that just automatically helps track phi sources, and makes them much more 
regular.

If you think of OP_PHISOURCE as just a convenient way to encode "bb + 
pseudo", you should be golden.

> For example, they are used in example.c to eliminate the OP_PHI but I think
> this is wrong, like in the "lost copy problem":

I don't think that's a bug in OP_PHISOURCE itself, as much as probably 
just a bug in liveness analysis.  Phi nodes obviously are very much 
special from a liveness standpoint, and I wouldn't be surprised if I just 
got it wrong, since the liveness info has effectively never been tested.

This, btw, is just another reason why I'd absolutely _love_ to see a real 
(even if it's really really stupid) code generator - because when I wrote 
the liveness stuff, I had absolutely no tests for it, just doing some very 
basic eye-balling of the results.

And I think we can all agree that code that hasn't been tested is pretty 
much invariably buggy ;)

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 21:05:47 +0000
Message-ID: <Pine.LNX.4.64.0511201257030.13959 () g5 ! osdl ! org>
--------------------


On Sun, 20 Nov 2005, Linus Torvalds wrote:
> 
> > For example, they are used in example.c to eliminate the OP_PHI but I think
> > this is wrong, like in the "lost copy problem":
> 
> I don't think that's a bug in OP_PHISOURCE itself, as much as probably 
> just a bug in liveness analysis.

Doing a "./test-linearize -v t.c" seems to say that the liveness is 
correct, and the bug is probably just in the death-notes:

	.L0xf7fa100c:
	t.c:3
	  **defines %r1 **
	  **to 0xf7fa1034 (t.c:10:3)**
	        <entry-point>
	        phisrc.32   %phi2(x) <- $0     (%r1)
	        br          .L0xf7fa1034
	
	.L0xf7fa1034:
	t.c:10
	  **uses %r1 (from (%phi2(x):.L0xf7fa100c), (%phi3(x):.L0xf7fa1034))**
	  **defines %r1 **
	  **from 0xf7fa100c (t.c:3:5)**
	  **from 0xf7fa1034 (t.c:10:3)**
	  **to 0xf7fa1034 (t.c:10:3)**
	  **to 0xf7fa10ac (t.c:3:5)**
	        phi.32      %r1 <- %phi2(x), %phi3(x)
	        dead        %r1
	        add.32      %r3 <- %r1, $1
	        dead        %r3
	        phisrc.32   %phi3(x) <- %r3     (%r1)
	        call.32     %r4 <- p
	        dead        %r4
	        br          %r4, .L0xf7fa1034, .L0xf7fa10ac
	
	.L0xf7fa10ac:
	t.c:3
	  **uses %r1 (from (%phi2(x):.L0xf7fa100c), (%phi3(x):.L0xf7fa1034))**
	  **from 0xf7fa1034 (t.c:10:3)**
	        dead        %r1
	        ret.32      %r1

ie notice that basic block .L0xf7fa1034 (which has the buggy death-note) 
definitely knows that it "defines %r1" which is used by both itself and 
the next basic block (the "to" notes).

So I think it's "track_pseudo_death" that screws up. And I think I see 
why: it thinks that the other phisrc (that defines %phi3) will also define 
%r1.

This trivial patch should make it do the right thing, although I didn't 
remove the buggy code, because I don't remember what I thought I was doing 
when I wrote it.

It's entirely possible (nay, likely) that that code was just a total 
braindamage. I _think_ it was me trying to be "clever" (read: "not 
clever") and relieve register pressure by removing phi sources that were 
shadowed by other phi sources (and doing it all totally wrong ;).

		Linus

---
diff --git a/liveness.c b/liveness.c
index c1387fe..24c5c65 100644
--- a/liveness.c
+++ b/liveness.c
@@ -331,6 +331,7 @@ static void track_pseudo_death_bb(struct
 		if (!insn->bb)
 			continue;
 
+#if 0
 		/*
 		 * A "def" of a pseudo removes it from the liveness
 		 * list. However, we only bother doing that for
@@ -343,6 +344,7 @@ static void track_pseudo_death_bb(struct
 				remove_pseudo(live_list, phi->target);
 			} END_FOR_EACH_PTR(phi);
 		}
+#endif
 
 		dead_list = NULL;
 		track_instruction_usage(bb, insn, death_def, death_use);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 21:13:20 +0000
Message-ID: <4380E6F0.9000708 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Sun, 20 Nov 2005, Luc Van Oostenryck wrote:
> 


> 
>>While I think I understand what are these phi-sources (it add def-use
>>information for phi-nodes "arguments"), I'm not sure I understand for what
>>they should be used.
> 
> 
> Normally they shouldn't be used, they really are more of an abstraction 
> that just automatically helps track phi sources, and makes them much more 
> regular.
> 
> If you think of OP_PHISOURCE as just a convenient way to encode "bb + 
> pseudo", you should be golden.
>

OK, thanks for the info, I will try to digest this.

> 
>>For example, they are used in example.c to eliminate the OP_PHI but I think
>>this is wrong, like in the "lost copy problem":
> 
> 
> I don't think that's a bug in OP_PHISOURCE itself, as much as probably 
> just a bug in liveness analysis.  Phi nodes obviously are very much 
> special from a liveness standpoint, and I wouldn't be surprised if I just 
> got it wrong, since the liveness info has effectively never been tested.

Yes, anyway there is a problem with the liveness analysis.
I'm looking at it.

> This, btw, is just another reason why I'd absolutely _love_ to see a real 
> (even if it's really really stupid) code generator - because when I wrote 
> the liveness stuff, I had absolutely no tests for it, just doing some very 
> basic eye-balling of the results.

Well, it's what I'm trying to do: a stupid but real compiler using sparse.
I've a working draft of a code generator similar to iburg and a predraft of
a register allocator by graph coloring that need more work.
I need to glue everything together and these phisrc annoyed me.

> And I think we can all agree that code that hasn't been tested is pretty 
> much invariably buggy ;)
> 
> 			Linus

Sure, but it's just of question of time.


Thanks for all,

Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 21:25:52 +0000
Message-ID: <Pine.LNX.4.64.0511201314130.13959 () g5 ! osdl ! org>
--------------------


On Sun, 20 Nov 2005, Luc Van Oostenryck wrote:
> 
> Yes, anyway there is a problem with the liveness analysis.
> I'm looking at it.

The patch I just sent out definitely fixes at least your trivial 
test-case.

I think I have the same thinko in storage handling (and thus example.c), 
where I think that a phi source somehow always overwrites the phi it 
defines.

Which should actually be true _except_ for the case of the OP_PHI being 
earlier in the same basic block, which is why I think I had the thinko in 
the first place.

> > This, btw, is just another reason why I'd absolutely _love_ to see a real
> > (even if it's really really stupid) code generator - because when I wrote
> > the liveness stuff, I had absolutely no tests for it, just doing some very
> > basic eye-balling of the results.
> 
> Well, it's what I'm trying to do: a stupid but real compiler using sparse.
> I've a working draft of a code generator similar to iburg and a predraft of
> a register allocator by graph coloring that need more work.
> I need to glue everything together and these phisrc annoyed me.

Ahh, wonderful.

You can just basically ignore the OP_PHISOURCE instructions, if you're 
already used to just do PHI nodes.

My plan in example.c was to instead ignore OP_PHI, and only base things on 
OP_PHISOURCE instead. Sadly, as you point out, it doesn't work (and while 
I _think_ it fails only for the case where the OP_PHI and the OP_PHISOURCE 
are in the same basic block, I haven't thought it through entirely).

Gaah.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 21:44:51 +0000
Message-ID: <Pine.LNX.4.64.0511201339020.13959 () g5 ! osdl ! org>
--------------------


On Sun, 20 Nov 2005, Luc Van Oostenryck wrote:
> 
> Yes, this indeed solve the wrong death annotation.
> The output of example better but still incorrect but this is another story:

example has the same bug in another guise: the "storage allocator" ends up 
giving the same storage to the PHI pseudo as for the phisource. 

So as a result, it first keeps them separate:

>         movl %eax,%edx          # copy_reg
>         add.32 $1,%edx          # do_binop

where %eax is the old incoming thing, %edx is the new phisource.

>         movl %edx,0(SP)         # flush_one_pseudo

we flush the new phi source to memory over the call. We've got two 
registers, but they both point to the same storage and we think they're 
the same because of that same phisource braindamage.

>         call p          # generate_call
>         testl %eax,%eax         # generate_branch
>         movl 0(SP),%eax         # fill_output

and then we re-load it, and because we gave it the same storage, we this 
reload reloads "both" the new and the old thing.

So it's not the exact same bug, but it's the exact same thinko.

Are you actually using that example.c/storage.c thing as a base for your 
simple compiler? It was this horribly stupid thing I wrote just as an 
example, and it grew bigger and more complex than I ever intended, but it 
wasn't really ever intended to be "real".

I guess I should fix at least "storage.c", since that was at least meant 
to be generically useful. That might or might not fix example.c by 
mistake. But if you don't actually use the storage allocator, I'm not 
going to give that very high priority..

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 21:55:55 +0000
Message-ID: <4380F281.2070708 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Sun, 20 Nov 2005, Luc Van Oostenryck wrote:
> 
>>Yes, this indeed solve the wrong death annotation.
>>The output of example better but still incorrect but this is another story:
> 
> 
> example has the same bug in another guise: the "storage allocator" ends up 
> giving the same storage to the PHI pseudo as for the phisource. 
> 
> So as a result, it first keeps them separate:
> 
> 
>>        movl %eax,%edx          # copy_reg
>>        add.32 $1,%edx          # do_binop
> 
> 
> where %eax is the old incoming thing, %edx is the new phisource.
> 
> 
>>        movl %edx,0(SP)         # flush_one_pseudo
> 
> 
> we flush the new phi source to memory over the call. We've got two 
> registers, but they both point to the same storage and we think they're 
> the same because of that same phisource braindamage.
> 
> 
>>        call p          # generate_call
>>        testl %eax,%eax         # generate_branch
>>        movl 0(SP),%eax         # fill_output
> 
> 
> and then we re-load it, and because we gave it the same storage, we this 
> reload reloads "both" the new and the old thing.
> 
> So it's not the exact same bug, but it's the exact same thinko.

Yes, I'm trying to see where the decision to give them the same storage come.

> Are you actually using that example.c/storage.c thing as a base for your 
> simple compiler? It was this horribly stupid thing I wrote just as an 
> example, and it grew bigger and more complex than I ever intended, but it 
> wasn't really ever intended to be "real".

In fact, no.
I've tried 6 months ago, but have decided it was not a good idea.
I prefer to separate in classical steps: code selection + register allocation.

> I guess I should fix at least "storage.c", since that was at least meant 
> to be generically useful. That might or might not fix example.c by 
> mistake. But if you don't actually use the storage allocator, I'm not 
> going to give that very high priority..
> 
> 			Linus

Yes, I understand. No problem.
I will probably try to reuse the helpers, but not the logical behind it.
For the moment, I don't use it; the register allocation is still in a very abstract state
and I try to focus on the code generation.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 22:13:33 +0000
Message-ID: <Pine.LNX.4.64.0511201408420.13959 () g5 ! osdl ! org>
--------------------


On Sun, 20 Nov 2005, Luc Van Oostenryck wrote:
> 
> Yes, I'm trying to see where the decision to give them the same storage come.

It's combine_phi_storage(), methinks.

But it won't actually help with "example.c", because even if you fix that 
(combining phi storage is probably correct per se, but I should have 
combined it with _other_ phisource objects, not with the PHI pseudo 
itself) the fact is, example.c won't do the right thing about PHI nodes, 
exactly because it expects the broken PHISOURCE code to take care of 
everything.

But if you aren't using it, I'll just leave it in the broken state.

I never actually wanted to write a back-end at all, and if you get 
something working (even if it's really stupid), I'll just remove the 
existing example.c and storage.c. 

As it is, "example.c" can be useful to see what CSE does etc (I find the 
more traditional-looking assembly easier to read than test-linearize), but 
it's not actually useful for anything else.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Sun, 20 Nov 2005 22:37:07 +0000
Message-ID: <4380FA93.3010602 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Sun, 20 Nov 2005, Luc Van Oostenryck wrote:
> 
>>Yes, I'm trying to see where the decision to give them the same storage come.
> 
> 
> It's combine_phi_storage(), methinks.
> 
> But it won't actually help with "example.c", because even if you fix that 
> (combining phi storage is probably correct per se, but I should have 
> combined it with _other_ phisource objects, not with the PHI pseudo 
> itself) the fact is, example.c won't do the right thing about PHI nodes, 
> exactly because it expects the broken PHISOURCE code to take care of 
> everything.

Yes, for example, al least the beginning of generate_phisource() is also
broken: the "Mark all the target pseudos dead first" make %r1 dead again.

> But if you aren't using it, I'll just leave it in the broken state.

OK.

> I never actually wanted to write a back-end at all, and if you get 
> something working (even if it's really stupid), I'll just remove the 
> existing example.c and storage.c. 

OK, but expect something too soon; I can only do this on my spare time.

> As it is, "example.c" can be useful to see what CSE does etc (I find the 
> more traditional-looking assembly easier to read than test-linearize), but 
> it's not actually useful for anything else.
> 
> 		Linus


At least it was usefull for me; with it I discovered that all the basic optimization
were already there and I think to myself "hey look, in fact it's not so difficult to
use this to generated some code".


Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Mon, 21 Nov 2005 00:58:42 +0000
Message-ID: <43811BC2.4050205 () looxix ! net>
--------------------
Linus Torvalds wrote:

> 
> You can just basically ignore the OP_PHISOURCE instructions, if you're 
> already used to just do PHI nodes.

What I obtain for the same code after removal of the OP_PHI and OP_PHISOURCE is
the following:

.globl foo
foo:
         <entry-point>
         copy.32     %r0 <- $0
         br          .L0xf7f89034

.L0xf7f89034:
         copy.32     %r1 <- %r0
         add.32      %r3 <- %r1, $1
         dead        %r3
         copy.32     %r0 <- %r3
         call.32     %r4 <- p
         dead        %r4
         br          %r4, .L0xf7f89034, .L0xf7f890ac

.L0xf7f890ac:
         dead        %r1
         ret.32      %r1


But I need both the phi nodes and the phi sources.
I'll post the code tomorrow after verification and cleanup.

The register allocation pass should merge %r0 and %r3.


Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Mon, 21 Nov 2005 02:40:09 +0000
Message-ID: <Pine.LNX.4.64.0511201830420.13959 () g5 ! osdl ! org>
--------------------


On Mon, 21 Nov 2005, Luc Van Oostenryck wrote:
>
> What I obtain for the same code after removal of the OP_PHI and OP_PHISOURCE
> is the following:

Goodie. Looks fine.

> But I need both the phi nodes and the phi sources.

Well, you obviously always need the phi sources in the sense that you need 
to look at them, but a lot of other (all?) SSA form compilers don't 
consider them to be actual instructions in the instruction stream. 

Rather, they just keep track of the basic blocks separately, I think.

> I'll post the code tomorrow after verification and cleanup.

Thanks.

> The register allocation pass should merge %r0 and %r3.

Well, I'd be very happy indeed even with a back-end that didn't try to do 
anything fancy wrt register allocation at all. With the front end already 
doing basic CSE, memory disambiguoation (and all the trivial stuff, of 
course) it already should be perfectly readable code.

(Assuming some trivial tricks like the lazy conditional evaluation that 
the "example" compiler already did - keeping track of what pseudo was 
represented in the condition code registers along with what comparison 
just was a really simple way to generate perfectly fine code for most 
conditional branches.)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Mon, 21 Nov 2005 23:57:16 +0000
Message-ID: <43826077.6060902 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Mon, 21 Nov 2005, Luc Van Oostenryck wrote:
> 
> 
>>But I need both the phi nodes and the phi sources.
> 
> 
> Well, you obviously always need the phi sources in the sense that you need 
> to look at them, but a lot of other (all?) SSA form compilers don't 
> consider them to be actual instructions in the instruction stream. 
> 
> Rather, they just keep track of the basic blocks separately, I think.
> 

In the articles and books I have read, I have nowhere seen somthing like these phisrc.
Teh tendency seems more to store in the phi-nodes the list of the pseudo with the
predecessor basic block from which the pseudo come.

>>The register allocation pass should merge %r0 and %r3.
> 
> 
> Well, I'd be very happy indeed even with a back-end that didn't try to do 
> anything fancy wrt register allocation at all. With the front end already 
> doing basic CSE, memory disambiguoation (and all the trivial stuff, of 
> course) it already should be perfectly readable code.
> 
> (Assuming some trivial tricks like the lazy conditional evaluation that 
> the "example" compiler already did - keeping track of what pseudo was 
> represented in the condition code registers along with what comparison 
> just was a really simple way to generate perfectly fine code for most 
> conditional branches.)
> 
> 		Linus

I will first work on the code generation part.
For the register allocation, I had planned to do a very basic allocation via
graph colouring, which will have lot of place for further enhancement.
I just want a generic framework that can be easily adapted for several target.


Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Tue, 22 Nov 2005 00:04:11 +0000
Message-ID: <9913.65.113.40.130.1132617851.squirrel () numba-tu ! com>
--------------------
Luc Van Oostenryck said:
> In the articles and books I have read, I have nowhere seen somthing like these
> phisrc.
> Teh tendency seems more to store in the phi-nodes the list of the pseudo with
> the
> predecessor basic block from which the pseudo come.

Articles != industry practice.  What works well in a paper is sometimes
crumbersome in practice.  IIRC, LLVM does something similar here.

Your change looked good to me though.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Tue, 22 Nov 2005 01:40:55 +0000
Message-ID: <Pine.LNX.4.64.0511211727250.13959 () g5 ! osdl ! org>
--------------------


On Tue, 22 Nov 2005, Luc Van Oostenryck wrote:
> 
> In the articles and books I have read, I have nowhere seen somthing like 
> these phisrc. Teh tendency seems more to store in the phi-nodes the list 
> of the pseudo with the predecessor basic block from which the pseudo 
> come.

Yeah. I think the sparse way is _much_ superior, but I'll also have to 
admit that I never did anything but "compilers 101" in uni, and that was 
using the dragon book, which is so old that I think it didn't even mention 
SSA ;)

I've read some random papers afterwards, but I literally didn't know what 
the rules for SSA and PHI-nodes were when I started sparse. I think I had 
Tommy Thorn walk me through it (Hi Tommy - are you still on the list?)

Anyway, the sparse form allows two basic blocks which both are associated 
with the same phi to be combined effortlessly: the "latter" phi source 
always wins, and there is never any confusion. So allowign phi sources to 
have positions within a basic block and not just be "basic block + pseudo" 
really does make things a lot clearer and less error-prone, I'm convinced.

I did it the traditional way originally, and you wouldn't _believe_ how 
hairy it was to do any basic block operations at all. Every single 
friggin' time you had to walk all the phi's that were associated with that 
basic block and do magic operations.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: Rationale for OP_PHISOURCE ?
Date: Tue, 22 Nov 2005 02:25:30 +0000
Message-ID: <4382819A.8040907 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Tue, 22 Nov 2005, Luc Van Oostenryck wrote:
> 
>>In the articles and books I have read, I have nowhere seen somthing like 
>>these phisrc. Teh tendency seems more to store in the phi-nodes the list 
>>of the pseudo with the predecessor basic block from which the pseudo 
>>come.
> 
> 
> Yeah. I think the sparse way is _much_ superior, but I'll also have to 
> admit that I never did anything but "compilers 101" in uni, and that was 
> using the dragon book, which is so old that I think it didn't even mention 
> SSA ;)

More or less the same for me. Unfortunately ;-)

> I've read some random papers afterwards, but I literally didn't know what 
> the rules for SSA and PHI-nodes were when I started sparse. I think I had 
> Tommy Thorn walk me through it (Hi Tommy - are you still on the list?)
> 
> Anyway, the sparse form allows two basic blocks which both are associated 
> with the same phi to be combined effortlessly: the "latter" phi source 
> always wins, and there is never any confusion. So allowign phi sources to 

Yes, I see it now.

> have positions within a basic block and not just be "basic block + pseudo" 
> really does make things a lot clearer and less error-prone, I'm convinced.

I easily believe you ;-)

> I did it the traditional way originally, and you wouldn't _believe_ how 
> hairy it was to do any basic block operations at all. Every single 
> friggin' time you had to walk all the phi's that were associated with that 
> basic block and do magic operations.
> 
> 			Linus


Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Repository corrupt? ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: Repository corrupt?
Date: Tue, 12 Jul 2005 18:36:45 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHEEPACEAA.mshah () teja ! com>
--------------------
Hi,

When I try to cg-clone the sparse repository, I get the following error
message.

----------------------------------
$ cg-clone
http://www.kernel.org/pub/scm/linux/kernel/git/torvalds/sparse.git
defaulting to local storage area
11:33:15
URL:http://www.kernel.org/pub/scm/linux/kernel/git/torvalds/sparse.git/
refs/heads/master [41/41] -> "refs/heads/origin" [1]
error: File 121b8d7d9d8efd29ac593b59f32fa1925cb8b1e9
(http://www.kernel.org/pub/
scm/linux/kernel/git/torvalds/sparse.git/objects/12/1b8d7d9d8efd29ac593b59f3
2fa1
925cb8b1e9) corrupt

Cannot obtain needed object 121b8d7d9d8efd29ac593b59f32fa1925cb8b1e9
while processing commit 0000000000000000000000000000000000000000.
cg-pull: objects pull failed
cg-init: pull failed

-------------------------------------

Has anyone else getting this?

Thanks,

-Mitesh



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Resend: Repository corrupt? ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: Resend: Repository corrupt?
Date: Sat, 16 Jul 2005 00:31:42 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHGEAJCFAA.mshah () teja ! com>
--------------------

It still does not work. Does anyone know why it is happening? Is it
something I am missing in cogito installation?

Thanks,

-Mitesh



-----Original Message-----
From: linux-sparse-owner@vger.kernel.org
[mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Mitesh Shah
Sent: Tuesday, July 12, 2005 11:37 AM
To: Linux-Sparse
Subject: Repository corrupt?


Hi,

When I try to cg-clone the sparse repository, I get the following error
message.

----------------------------------
$ cg-clone
http://www.kernel.org/pub/scm/linux/kernel/git/torvalds/sparse.git
defaulting to local storage area
11:33:15
URL:http://www.kernel.org/pub/scm/linux/kernel/git/torvalds/sparse.git/
refs/heads/master [41/41] -> "refs/heads/origin" [1]
error: File 121b8d7d9d8efd29ac593b59f32fa1925cb8b1e9
(http://www.kernel.org/pub/
scm/linux/kernel/git/torvalds/sparse.git/objects/12/1b8d7d9d8efd29ac593b59f3
2fa1
925cb8b1e9) corrupt

Cannot obtain needed object 121b8d7d9d8efd29ac593b59f32fa1925cb8b1e9
while processing commit 0000000000000000000000000000000000000000.
cg-pull: objects pull failed
cg-init: pull failed

-------------------------------------

Has anyone else getting this?

Thanks,

-Mitesh



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html




-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Resend: Repository corrupt?
Date: Sat, 16 Jul 2005 00:47:27 +0000
Message-ID: <Pine.LNX.4.58.0507151744470.19183 () g5 ! osdl ! org>
--------------------


On Fri, 15 Jul 2005, Mitesh Shah wrote:
> 
> It still does not work. Does anyone know why it is happening? Is it
> something I am missing in cogito installation?

No, http:// doesn't work with packed repositories right now.

Switch the "http://www.kernel.org" into "rsync://rsync.kernel.org" and you 
should be ok (assuming you have cogito-0.12 or newer - older versions 
won't understand packs at all).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: Resend: Repository corrupt?
Date: Sat, 16 Jul 2005 00:55:37 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHCEAKCFAA.mshah () teja ! com>
--------------------
It worked, thanks. 

-Mitesh



-----Original Message-----
From: linux-sparse-owner@vger.kernel.org
[mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Linus Torvalds
Sent: Friday, July 15, 2005 5:47 PM
To: Mitesh Shah
Cc: Linux-Sparse
Subject: Re: Resend: Repository corrupt?




On Fri, 15 Jul 2005, Mitesh Shah wrote:
> 
> It still does not work. Does anyone know why it is happening? Is it
> something I am missing in cogito installation?

No, http:// doesn't work with packed repositories right now.

Switch the "http://www.kernel.org" into "rsync://rsync.kernel.org" and you 
should be ok (assuming you have cogito-0.12 or newer - older versions 
won't understand packs at all).

		Linus


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Segfault in function pointer initialization ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Segfault in function pointer initialization
Date: Fri, 15 Apr 2005 01:19:41 +0000
Message-ID: <20050415011941.GD18655 () 64m ! dyndns ! org>
--------------------
> while trying to run sparse on the Wine sources I got a segfault which
> can be reproduced with following code:
> 
> int (*oink)() = (void *)0;
> 
>
I believe the following patch should fix the problem. Sparse is about
to complain the function is non-ANSI declaration.

Can you give it a try?

Chris

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2005-04-11 16:15:52.000000000 -0400
+++ sparse/parse.c	2005-04-14 21:15:36.000000000 -0400
@@ -1355,7 +1355,7 @@
 		// No warning for "void oink ();"
 		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
 		if (!match_op(token->next, ';'))
-			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
+			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(p ? *p : NULL));
 		return token;
 	}


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: Segfault in function pointer initialization
Date: Fri, 15 Apr 2005 08:36:52 +0000
Message-ID: <425F7D24.2090008 () redhat ! com>
--------------------
Christopher Li wrote:
>>while trying to run sparse on the Wine sources I got a segfault which
>>can be reproduced with following code:
>>
>>int (*oink)() = (void *)0;
>>
>>
> 
> I believe the following patch should fix the problem. Sparse is about
> to complain the function is non-ANSI declaration.
> 
> Can you give it a try?
I know that works, I used an analog patch to keep going, but is this the 
correct fix or only a quick workaround?

> Index: sparse/parse.c
> ===================================================================
> --- sparse.orig/parse.c	2005-04-11 16:15:52.000000000 -0400
> +++ sparse/parse.c	2005-04-14 21:15:36.000000000 -0400
> @@ -1355,7 +1355,7 @@
>  		// No warning for "void oink ();"
>  		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
>  		if (!match_op(token->next, ';'))
> -			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
> +			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(p ? *p : NULL));
>  		return token;
>  	}

bye
	michael
-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
Sr. Network Engineer            Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Segfault in function pointer initialization
Date: Fri, 15 Apr 2005 18:36:57 +0000
Message-ID: <20050415183657.GA31586 () 64m ! dyndns ! org>
--------------------
On Fri, Apr 15, 2005 at 10:36:52AM +0200, Michael Stefaniuc wrote:
> Christopher Li wrote:
> >>while trying to run sparse on the Wine sources I got a segfault which
> >>can be reproduced with following code:
> >>
> >>int (*oink)() = (void *)0;
> >>
> >>
> >
> I know that works, I used an analog patch to keep going, but is this the 
> correct fix or only a quick workaround?
> 
> >-			warning(token->pos, "non-ANSI function declaration 
> >of function '%s'", show_ident(*p));
> >+			warning(token->pos, "non-ANSI function declaration 

Well, it is a lazy fix. I am not sure about that is the best fix.

I think "p" the place holder for return idents, which is the ident of the symbol
get created.

int a;

eventually (*p) will set to a point of ident which is "a".
There is code set p to NULL when after a grouping, e.g. "(a)"
so after ")" there is no more ident expect from the group.

the p for parameter_type_list is just for print out warning.
But the ident can still be NULL. e.g.

void foo(void(*)(void));

so if you want to see the symbol name that is causing the warning,
I have the following patch will show the "oink" instead of "<noident>"
in the warning.

I dunno.

Chris


Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2005-04-11 16:15:52.000000000 -0400
+++ sparse/parse.c	2005-04-15 14:11:12.000000000 -0400
@@ -762,6 +762,7 @@
 static struct token *direct_declarator(struct token *token, struct symbol *decl, struct ident **p)
 {
 	struct ctype *ctype = &decl->ctype;
+	struct ident **ident = p;
 
 	if (p && token_type(token) == TOKEN_IDENT) {
 		*p = token->ident;
@@ -797,7 +798,7 @@
 			}
 
 			sym = indirect(token->pos, ctype, SYM_FN);
-			token = parameter_type_list(next, sym, p);
+			token = parameter_type_list(next, sym, ident);
 			token = expect(token, ')', "in function declarator");
 			continue;
 		}
@@ -1355,7 +1356,7 @@
 		// No warning for "void oink ();"
 		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
 		if (!match_op(token->next, ';'))
-			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
+			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(p ? *p : NULL));
 		return token;
 	}
 


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Segfault in function pointer initialization
Date: Fri, 15 Apr 2005 23:47:18 +0000
Message-ID: <20050415234718.GA32742 () 64m ! dyndns ! org>
--------------------
On Sat, Apr 16, 2005 at 02:43:18AM +0200, Michael Stefaniuc wrote:
> Christopher Li wrote:
> >On Fri, Apr 15, 2005 at 10:36:52AM +0200, Michael Stefaniuc wrote:
> >
> >>Christopher Li wrote:
> Yeah, it works now. But there is one thing that feels strange:
> Why is the declaration of the function pointer with empty parameter list 
> a correct ANSI function declaration
>   int (*oink)();
> but the initialization of the same function pointer is not?
>   int (*oink)() = NULL;

The ANSI C allow you declare abstraction function then make it more
detail.
e.g. void foo(); then void foo(void);

So sparse don't warn on the the first one. But once you make it 
a real instance, it need to have the full prototype.

That is what I guess.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michael Stefaniuc <mstefani () redhat ! com>
To: linux-sparse
Subject: Re: Segfault in function pointer initialization
Date: Sat, 16 Apr 2005 00:43:18 +0000
Message-ID: <42605FA6.2050907 () redhat ! com>
--------------------
Christopher Li wrote:
> On Fri, Apr 15, 2005 at 10:36:52AM +0200, Michael Stefaniuc wrote:
> 
>>Christopher Li wrote:
>>
>>>>while trying to run sparse on the Wine sources I got a segfault which
>>>>can be reproduced with following code:
>>>>
>>>>int (*oink)() = (void *)0;

> Well, it is a lazy fix. I am not sure about that is the best fix.
> 
> I think "p" the place holder for return idents, which is the ident of the symbol
> get created.
> 
> int a;
> 
> eventually (*p) will set to a point of ident which is "a".
> There is code set p to NULL when after a grouping, e.g. "(a)"
> so after ")" there is no more ident expect from the group.
Thanks for the explanation.

> the p for parameter_type_list is just for print out warning.
> But the ident can still be NULL. e.g.
> 
> void foo(void(*)(void));
> 
> so if you want to see the symbol name that is causing the warning,
> I have the following patch will show the "oink" instead of "<noident>"
> in the warning.
Yeah, it works now. But there is one thing that feels strange:
Why is the declaration of the function pointer with empty parameter list 
a correct ANSI function declaration
   int (*oink)();
but the initialization of the same function pointer is not?
   int (*oink)() = NULL;

bye
	michael
-- 
Michael Stefaniuc               Tel.: +49-711-96437-199
System Administration           Fax.: +49-711-96437-111
Red Hat GmbH                    Email: mstefani@redhat.com
Hauptstaetterstr. 58            http://www.redhat.de/
D-70178 Stuttgart
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Segmentation fault on bad enums. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Segmentation fault on bad enums.
Date: Mon, 28 Feb 2005 21:56:47 +0000
Message-ID: <20050228215647.GA13541 () 64m ! dyndns ! org>
--------------------
The problem is here:

                if (match_op(next, '=')) {
                        struct expression *expr;
                        next = constant_expression(next->next, &expr);
                        lastval = get_expression_value(expr);
                        ctype = expr->ctype; <---------- ctype is NULL
                } else if (!ctype) {

And later on it use ctype->type and get a segment fault.

You can try the following quick and dirty patch to fix the problem.

However, to fix the problem right, the get_expression_value() should be
able to indicate error instead of blindly return zero.

Chris

Index: sparse-be/parse.c
===================================================================
--- sparse-be.orig/parse.c	2005-02-18 02:56:50.000000000 -0500
+++ sparse-be/parse.c	2005-02-28 16:54:11.000000000 -0500
@@ -223,6 +223,10 @@
 		if (match_op(next, '=')) {
 			struct expression *expr;
 			next = constant_expression(next->next, &expr);
+
+			if (!evaluate_expression(expr))
+				error_die(valtok->pos, "enumerator value for `%s' not integer constant\n",
+					  show_ident(token->ident));
 			lastval = get_expression_value(expr);
 			ctype = expr->ctype;
 		} else if (!ctype) {



On Tue, Mar 01, 2005 at 03:08:20AM +0200, Alexey Dobriyan wrote:
> Ran sparse on subversion source code. Trimmed down real file to this:
> 
> 	enum a {
> 		b = c,
> 	};
> 
> $ sparse cle.h
> cle.h:2:6: warning: undefined identifier 'c'
> cle.h:2:6: warning: bad constant expression type
> Segmentation fault
> 
> 	Alexey
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Segmentation fault on bad enums.
Date: Mon, 28 Feb 2005 21:56:47 +0000
Message-ID: <20050228215647.GA13541 () 64m ! dyndns ! org>
--------------------
The problem is here:

                if (match_op(next, '=')) {
                        struct expression *expr;
                        next = constant_expression(next->next, &expr);
                        lastval = get_expression_value(expr);
                        ctype = expr->ctype; <---------- ctype is NULL
                } else if (!ctype) {

And later on it use ctype->type and get a segment fault.

You can try the following quick and dirty patch to fix the problem.

However, to fix the problem right, the get_expression_value() should be
able to indicate error instead of blindly return zero.

Chris

Index: sparse-be/parse.c
===================================================================
--- sparse-be.orig/parse.c	2005-02-18 02:56:50.000000000 -0500
+++ sparse-be/parse.c	2005-02-28 16:54:11.000000000 -0500
@@ -223,6 +223,10 @@
 		if (match_op(next, '=')) {
 			struct expression *expr;
 			next = constant_expression(next->next, &expr);
+
+			if (!evaluate_expression(expr))
+				error_die(valtok->pos, "enumerator value for `%s' not integer constant\n",
+					  show_ident(token->ident));
 			lastval = get_expression_value(expr);
 			ctype = expr->ctype;
 		} else if (!ctype) {



On Tue, Mar 01, 2005 at 03:08:20AM +0200, Alexey Dobriyan wrote:
> Ran sparse on subversion source code. Trimmed down real file to this:
> 
> 	enum a {
> 		b = c,
> 	};
> 
> $ sparse cle.h
> cle.h:2:6: warning: undefined identifier 'c'
> cle.h:2:6: warning: bad constant expression type
> Segmentation fault
> 
> 	Alexey
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: Segmentation fault on bad enums.
Date: Tue, 01 Mar 2005 00:08:16 +0000
Message-ID: <200503010308.20814.adobriyan () mail ! ru>
--------------------
Ran sparse on subversion source code. Trimmed down real file to this:

	enum a {
		b = c,
	};

$ sparse cle.h
cle.h:2:6: warning: undefined identifier 'c'
cle.h:2:6: warning: bad constant expression type
Segmentation fault

	Alexey
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Segmentation fault on bad enums.
Date: Tue, 01 Mar 2005 00:44:37 +0000
Message-ID: <Pine.LNX.4.58.0502281644180.25732 () ppc970 ! osdl ! org>
--------------------


On Tue, 1 Mar 2005, Alexey Dobriyan wrote:
>
> Ran sparse on subversion source code. Trimmed down real file to this:
> 
> 	enum a {
> 		b = c,
> 	};

Heh. Thanks. Fixed.

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse compilation warning. ===

From: Luiz Fernando Capitulino <lcapitulino () conectiva ! com ! br>
To: linux-sparse
Subject: Sparse compilation warning.
Date: Fri, 01 Jul 2005 15:09:55 +0000
Message-ID: <42C55CC3.4040009 () conectiva ! com ! br>
--------------------
Hi,

I'm getting this warning when compiling the latest
sparse snapshot (from the git repository):

gcc -O -g -Wall -Wwrite-strings -fpic   -c -o compile-i386.o compile-i386.c
compile-i386.c: In function `x86_statement':
compile-i386.c:2047: warning: enumeration value `STMT_CONTEXT' not handled in switch
compile-i386.c:2047: warning: enumeration value `STMT_RANGE' not handled in switch
compile-i386.c: In function `x86_expression':
compile-i386.c:2385: warning: enumeration value `EXPR_PTRSIZEOF' not handled in switch
compile-i386.c:2385: warning: enumeration value `EXPR_SLICE' not handled in switch

But I don't know how to fix it..

(gcc-3.3.3)

PS: I'm not subscribed.

Thanks,
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse segfault ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Sparse segfault
Date: Tue, 09 Aug 2005 16:29:21 +0000
Message-ID: <Pine.LNX.4.58.0508090927080.3258 () g5 ! osdl ! org>
--------------------


On Tue, 9 Aug 2005, Peter Hagervall wrote:
>
> Sparse segfaults when checking crypto/des.c in latest 2.6-git tree.

Hmm.. Not for me, not on x86, not on ppc64. This is top-of-tree sparse?

> Seems like clean_up_one_instruction() is called with bogus insn-pointer.
> Valgrind reports invalid reads in clean_up_insns, somewhere within the
> FOR_EACH_PTR-macros.

Do you have a convenient way to run valgrind on it? Since I normally just 
do kernel work, I've not used valgrind before.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Hagervall <hager () cs ! umu ! se>
To: linux-sparse
Subject: Re: Sparse segfault
Date: Tue, 09 Aug 2005 18:15:28 +0000
Message-ID: <20050809181528.GB28692 () peppar ! cs ! umu ! se>
--------------------
On Tue, Aug 09, 2005 at 09:29:21AM -0700, Linus Torvalds wrote:
> 
> 
> On Tue, 9 Aug 2005, Peter Hagervall wrote:
> >
> > Sparse segfaults when checking crypto/des.c in latest 2.6-git tree.
> 
> Hmm.. Not for me, not on x86, not on ppc64. This is top-of-tree sparse?
>
Yes, assuming c8b9ce8f1ef27a0e77c87ea1581c6e2b33753e7a is the current
HEAD. My arch is x86. 
 
> > Seems like clean_up_one_instruction() is called with bogus insn-pointer.
> > Valgrind reports invalid reads in clean_up_insns, somewhere within the
> > FOR_EACH_PTR-macros.
> 
> Do you have a convenient way to run valgrind on it? Since I normally just 
> do kernel work, I've not used valgrind before.
> 
> 			Linus
The straightforward way of using it is just prepending the command line
with 'valgrind', so in this case I have:

valgrind sparse -D__linux__ -Dlinux -D__STDC__ -Dunix \
-D__unix__ -D__i386__ -nostdinc -isystem \
/usr/lib/gcc/i686-pc-linux-gnu/3.4.4/include -Wp,-MD,crypto/.des.o.d \
-nostdinc -isystem /usr/lib/gcc/i686-pc-linux-gnu/3.4.4/include \
-D__KERNEL__ -Iinclude -Wall -Wstrict-prototypes -Wno-trigraphs \
-fno-strict-aliasing -fno-common -ffreestanding -Os \
-fno-omit-frame-pointer -fno-optimize-sibling-calls -g -pipe \
-msoft-float -mpreferred-stack-boundary=2 -fno-unit-at-a-time \
-march=i686 -mregparm=3 -Iinclude/asm-i386/mach-default \
-Wdeclaration-after-statement -DMODULE -DKBUILD_BASENAME=des \
-DKBUILD_MODNAME=des crypto/des.c

However, when running under valgrind it doesn't segfault, but a few
invalid reads are reported.

I'll try to track down the problem later tonight.

-- 
Peter Hagervall
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Sparse segfault
Date: Tue, 09 Aug 2005 18:29:31 +0000
Message-ID: <Pine.LNX.4.58.0508091121330.3258 () g5 ! osdl ! org>
--------------------


On Tue, 9 Aug 2005, Peter Hagervall wrote:
>
> Yes, assuming c8b9ce8f1ef27a0e77c87ea1581c6e2b33753e7a is the current
> HEAD. My arch is x86. 

Yup, that's what I tested too.

> The straightforward way of using it is just prepending the command line
> with 'valgrind', so in this case I have:

I just get "missing --tool option" from that.

I did a "valgrind --tool=memcheck" thing, and yes, I see two invalid reads
in clean_up_insns too.

I suspect that valgrind could find better errors if it was told about 
"allocate()" and "free_one_entry()". As it is, it won't notice any normal 
allocation mis-use, because it just sees them as one mmap. The 
clean_up_insns one seems to be from some of the (rare) malloc/free users, 
namely the ptr_list allocations.

The fact that the pointer list that is warned about was free'd by
"simplify_switch()" is interesting - that sure as hell is some very 
special code. And valgrind did _not_ complain about kernel/sched.c, for 
example, so it's certainly not a normal error.

> I'll try to track down the problem later tonight.

Thanks. I'll see if I get around to looking closer later too.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Hagervall <hager () cs ! umu ! se>
To: linux-sparse
Subject: Re: Sparse segfault
Date: Thu, 11 Aug 2005 14:36:49 +0000
Message-ID: <20050811143649.GA317 () peppar ! cs ! umu ! se>
--------------------
On Tue, Aug 09, 2005 at 11:29:31AM -0700, Linus Torvalds wrote:
> 
> 
> On Tue, 9 Aug 2005, Peter Hagervall wrote:
> >
> > Yes, assuming c8b9ce8f1ef27a0e77c87ea1581c6e2b33753e7a is the current
> > HEAD. My arch is x86. 
> 
> Yup, that's what I tested too.
> 
> > The straightforward way of using it is just prepending the command line
> > with 'valgrind', so in this case I have:
> 
> I just get "missing --tool option" from that.
> 
> I did a "valgrind --tool=memcheck" thing, and yes, I see two invalid reads
> in clean_up_insns too.
> 
> I suspect that valgrind could find better errors if it was told about 
> "allocate()" and "free_one_entry()". As it is, it won't notice any normal 
> allocation mis-use, because it just sees them as one mmap. The 
> clean_up_insns one seems to be from some of the (rare) malloc/free users, 
> namely the ptr_list allocations.
> 
> The fact that the pointer list that is warned about was free'd by
> "simplify_switch()" is interesting - that sure as hell is some very 
> special code. And valgrind did _not_ complain about kernel/sched.c, for 
> example, so it's certainly not a normal error.
> 
> > I'll try to track down the problem later tonight.
> 
> Thanks. I'll see if I get around to looking closer later too.
> 
> 		Linus

I think I have it narrowed down a bit now, it seems that
ac8ce3636d83e25d8a316fdce221e36c04c02dc1 is OK, whereas its child,
972609f0d10e3bcb10a9132802b2edb8b01d305f is not.

valgrind still complains about invalid reads in clean_up_insns, but at
least it doesn't segfault.

--
Peter Hagervall
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Sparse segfault
Date: Thu, 11 Aug 2005 22:07:35 +0000
Message-ID: <Pine.LNX.4.58.0508111453510.3295 () g5 ! osdl ! org>
--------------------


On Tue, 9 Aug 2005, Linus Torvalds wrote:
> 
> Thanks. I'll see if I get around to looking closer later too.

Ok, found it.

It's a really silly one. What happens is:

 - clean_up_insns() loops over ep->bbs, and over bb->insns and calls
   clean_up_one_instruction()
 - clean_up_one_instruction() will call "simplify_instruction()"
 - simplify_instruction() calls "simplify_switch()" for a switch 
   instruction, which will replace the switch with a branch.
 - However, the way it replaces the OP_SWITCH with an OP_BR is to remove 
   the OP_SWITCH and insert a OP_BR, and if the OP_SWITCH happens to be 
   the only instruction in a particular ptr-list block, the removal will 
   unallocate the old block (and then inserting OP_BR will allocate a new 
   one).
 - this instruction block happens to be the one we're iterating over in 
   clean_up_insns(), and we keep a pointer to it, so when we return all 
   the way up, the block will have been free'd.

I'll have to rewrite "insert_branch()" to not delete the instruction, but 
just replace it in place or something. Give me ten minutes.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Hagervall <hager () cs ! umu ! se>
To: linux-sparse
Subject: Re: Sparse segfault
Date: Fri, 12 Aug 2005 10:07:34 +0000
Message-ID: <20050812100734.GA5165 () peppar ! cs ! umu ! se>
--------------------
On Thu, Aug 11, 2005 at 03:19:11PM -0700, Linus Torvalds wrote:
> 
> 
> On Thu, 11 Aug 2005, Linus Torvalds wrote:
> > 
> > I'll have to rewrite "insert_branch()" to not delete the instruction, but 
> > just replace it in place or something. Give me ten minutes.
> 
> Ok, fix checked in and pushed out. Peter, does this fix the problem for
> you (I never saw a SIGSEGV, but it did fix the valgrind errors that I
> could reproduce).
>
Yes, works like a charm now. I find it a bit strange though that you
couldn't reproduce the segfault on x86, since i got it on two totally
different systems (Debian stable and Gentoo semi-stable), different
compiler versions, different glibc versions etc. Not that it matters
now.

Thanks,

Peter Hagervall
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Strange "cast to nocast" warnings ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: Strange "cast to nocast" warnings
Date: Mon, 23 May 2005 04:17:27 +0000
Message-ID: <200505230817.27657.adobriyan () gmail ! com>
--------------------
$ cat test.c
#define __nocast __attribute__((nocast))

void f(unsigned int __nocast gfp)
{
}

void g(void)
{
	f(0);
}
$ sparse test.c
test.c:9:4: warning: implicit cast to nocast type
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Strange "cast to nocast" warnings
Date: Mon, 23 May 2005 14:22:31 +0000
Message-ID: <Pine.LNX.4.58.0505230717480.2307 () ppc970 ! osdl ! org>
--------------------


On Mon, 23 May 2005, Alexey Dobriyan wrote:
>
> $ cat test.c
> #define __nocast __attribute__((nocast))
> 
> void f(unsigned int __nocast gfp)
> {
> }
> 
> void g(void)
> {
> 	f(0);
> }
> $ sparse test.c
> test.c:9:4: warning: implicit cast to nocast type

You start out with "int", and you end up with "unsigned int __nocast gfp".

There's an implicit cast in there.

Avoid the warning by using "0U" instead of 0.

That said, I've considered having a "constant integer" rule that allows
constants in the right range. However, for some uses like gfp, it actually 
makes sense to have even constants warn, since we _do_ want to catch it 
when you pass in "sizeof()", for example (*). So I considered splitting 
"nocast" up into "nocast_strict" and "nocast", where the latter allows 
casts of constants.

		Linus

(*) on x86, that doesn't help us, since "sizeof()" is "unsigned int" 
anyway, but on other architectures like ppc64 you get a nice warning.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Strange sparse inlining bug... ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Strange sparse inlining bug...
Date: Wed, 05 Jan 2005 04:50:12 +0000
Message-ID: <Pine.LNX.4.58.0501042044120.4111 () ppc970 ! osdl ! org>
--------------------


On Tue, 4 Jan 2005, Linus Torvalds wrote:
> 
> However, it also shows a bug somewhere in sparse array handling and
> inlining, and I haven't figured it out yet. It happens when inlining the
> same function _twice_, here's a trivial example:

Ahh. I think I know what's up.

We're sharing expressions as part of inlining, which includes sharing the 
expression when we evaluate

	*((int *)a+1)

into

	*(a + 4)

and then the second time the "4" gets multiplied by the array entry size 
again.

IOW, we evaluate the expression twice, and change it in-place. Normally
type evaluation is idempotent, but not in this case.

That's a design mistake. I hope it won't be nasty to fix.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () parcelfarce ! linux ! theplanet ! co ! uk>
To: linux-sparse
Subject: Re: Strange sparse inlining bug...
Date: Wed, 05 Jan 2005 05:32:45 +0000
Message-ID: <20050105053245.GG26051 () parcelfarce ! linux ! theplanet ! co ! uk>
--------------------
On Tue, Jan 04, 2005 at 08:50:12PM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 4 Jan 2005, Linus Torvalds wrote:
> > 
> > However, it also shows a bug somewhere in sparse array handling and
> > inlining, and I haven't figured it out yet. It happens when inlining the
> > same function _twice_, here's a trivial example:
> 
> Ahh. I think I know what's up.
> 
> We're sharing expressions as part of inlining, which includes sharing the 
> expression when we evaluate
> 
> 	*((int *)a+1)
> 
> into
> 
> 	*(a + 4)
> 
> and then the second time the "4" gets multiplied by the array entry size 
> again.
> 
> IOW, we evaluate the expression twice, and change it in-place. Normally
> type evaluation is idempotent, but not in this case.

Aha...  How about we introduce a ternary operation: x + const * z and rewrite
to it instead?  That would also avoid piles of extra allocations and
simplification rules for that puppy are not too tricky...
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Strange sparse inlining bug...
Date: Wed, 05 Jan 2005 05:44:59 +0000
Message-ID: <Pine.LNX.4.58.0501042140380.4111 () ppc970 ! osdl ! org>
--------------------


On Wed, 5 Jan 2005, Al Viro wrote:
> 
> Aha...  How about we introduce a ternary operation: x + const * z and rewrite
> to it instead?  That would also avoid piles of extra allocations and
> simplification rules for that puppy are not too tricky...

Yes, I considered that. We effectively have that situation for the
"--"/"++" expressions, where "unop_value" is the third (well, second, in
that case) operand.

It might be the right solution, with the actual multiply expanded out at 
linearization time.

However, I chickened out. It was simpler in this case to just not re-write
the constant in place, and since expression type evaluation is generally
protected by checking whether we've already done it ("if (expr->ctype)
return expr->ctype"), the avoidance of changing the constant in place was
actually the only thing necessary to make things work.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Warning vs. Errors? ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: Warning vs. Errors?
Date: Wed, 07 Sep 2005 23:56:13 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHKEBKCGAA.mshah () teja ! com>
--------------------

Is there a way to distinguish between the warnings and the errors? I see
that sparse is trying to continue even if it encounters an error (error in
gcc sense). For example, missing semicolon is printed as a warning. Is there
a way to print such things (that treated as errors by gcc) as errors?

Thanks,

-Mitesh



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Warning vs. Errors?
Date: Thu, 08 Sep 2005 00:07:27 +0000
Message-ID: <Pine.LNX.4.58.0509071706260.11102 () g5 ! osdl ! org>
--------------------


On Wed, 7 Sep 2005, Mitesh Shah wrote:
> 
> Is there a way to distinguish between the warnings and the errors? I see
> that sparse is trying to continue even if it encounters an error (error in
> gcc sense). For example, missing semicolon is printed as a warning. Is there
> a way to print such things (that treated as errors by gcc) as errors?

I think we should make "error()" just die. Continuing was fine back in the 
old days when we had tons of bogus errors, but there's little point to it 
any more, I suspect.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: Warning vs. Errors?
Date: Thu, 08 Sep 2005 00:27:24 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHIEBLCGAA.mshah () teja ! com>
--------------------

>
> I think we should make "error()" just die. Continuing was fine
> back in the
> old days when we had tons of bogus errors, but there's little point to it
> any more, I suspect.
>
> 		Linus
>

That should be just fine but I see that at many places "warning()" is used
instead of "error()". For example, sparse is calling "warning()" for missing
semicolon, etc. Also, I see that many places in preprocess.c and parse.c,
"warning()" is called instead of "error()".

-Mitesh





-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Wedgwood <cw () f00f ! org>
To: linux-sparse
Subject: Re: Warning vs. Errors?
Date: Sun, 11 Sep 2005 05:49:54 +0000
Message-ID: <20050911054954.GA18409 () taniwha ! stupidest ! org>
--------------------
On Wed, Sep 07, 2005 at 05:07:27PM -0700, Linus Torvalds wrote:

> I think we should make "error()" just die.

Why?  It's not like it's producing code which we wouldn't be able to
usefully complete by continuing, it's doing checks some of which might
be valid.

> Continuing was fine back in the old days when we had tons of bogus
> errors, but there's little point to it any more, I suspect.

Why not have it die after n-errors so if something heinous is wrong it
bails out early but we can still have it continue in other cases?
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] Add a new opcode: OP_COPY. ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH 1/2] Add a new opcode: OP_COPY.
Date: Mon, 21 Nov 2005 23:37:53 +0000
Message-ID: <20051121233753.GA1331 () ralph05 ! lan>
--------------------
This is needed to translate SSA back to normal form.

Maybe we should split this in two distinct ops:
The first ones correspond to the old OP_PHISOURCE (but if the same
phisrc feed several phi-nodes, we need sevarel distinct copy instruction);
at thistage they are the only instruction that can define a pseudo in
multiple places.
The other ones are "normal" copies.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---

 linearize.c |    5 +++++
 linearize.h |    3 +++
 2 files changed, 8 insertions(+), 0 deletions(-)

applies-to: b17ed2220e63ca115f6d81848fc45d0d156a8350
diff-tree f68fd7e5dfe08615b5b483c2e35f7bd467949881 (from b85ec4bb7f5b1c522d7c71782dbd9cf1c4c49b2f)
tree 5fc802ec8b8f33482ee12688187b99ed8ac7e4fa
parent b85ec4bb7f5b1c522d7c71782dbd9cf1c4c49b2f
author Luc Van Oostenryck <luc.vanoostenryck@looxix.net> 1132610222 +0100
committer Luc Van Oostenryck <luc.vanoostenryck@looxix.net> 1132610222 +0100

    Add a new opcode: OP_COPY.
    
    Needed to translate SSA back to normal form.

diff --git a/linearize.c b/linearize.c
index 61d35a7..29d76cf 100644
--- a/linearize.c
+++ b/linearize.c
@@ -235,6 +235,8 @@ static const char* opcodes[] = {
 	/* Sparse tagging (line numbers, context, whatever) */
 	[OP_CONTEXT] = "context",
 	[OP_RANGE] = "range-check",
+
+	[OP_COPY] = "copy",
 };
 
 static char *show_asm_constraints(char *buf, const char *sep, struct asm_constraint_list *list)
@@ -445,6 +447,9 @@ const char *show_instruction(struct inst
 	case OP_ASM:
 		buf = show_asm(buf, insn);
 		break;
+	case OP_COPY:
+		buf += sprintf(buf, "%s <- %s", show_pseudo(insn->target), show_pseudo(insn->src));
+		break;
 	default:
 		break;
 	}
diff --git a/linearize.h b/linearize.h
index 3b761d9..1626449 100644
--- a/linearize.h
+++ b/linearize.h
@@ -198,6 +198,9 @@ enum opcode {
 	/* Sparse tagging (line numbers, context, whatever) */
 	OP_CONTEXT,
 	OP_RANGE,
+
+	/* Needed to translate SSA back to normal form */
+	OP_COPY,
 };
 
 struct basic_block_list;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] introduce __sparse() function ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 1/2] introduce __sparse() function
Date: Mon, 19 Dec 2005 17:20:50 +0000
Message-ID: <43A6FD94.62011D1 () tv-sign ! ru>
--------------------
This patch adds __sparse() function for those users which
don't need evaluate.c (see the next patch).

Without this patch it is not possible to link test-dissect
statically, it has to redefine evaluate_symbol_list().

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20051210/lib.h~1_SPARSE	2005-11-28 04:40:51.000000000 +0300
+++ git-snapshot-20051210/lib.h	2005-12-19 22:49:49.000000000 +0300
@@ -84,6 +84,7 @@ extern int Wone_bit_signed_bitfield;
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
 extern struct symbol_list *sparse_initialize(int argc, char **argv);
+extern struct symbol_list *__sparse(char **argv);
 extern struct symbol_list *sparse(char **argv);
 
 static inline int symbol_list_size(struct symbol_list* list)
--- git-snapshot-20051210/lib.c~1_SPARSE	2005-11-28 04:40:51.000000000 +0300
+++ git-snapshot-20051210/lib.c	2005-12-19 22:47:50.000000000 +0300
@@ -629,7 +629,7 @@ struct symbol_list *sparse_initialize(in
 	return list;
 }
 
-struct symbol_list * sparse(char **argv)
+struct symbol_list * __sparse(char **argv)
 {
 	struct symbol_list *res;
 	char *filename, *next;
@@ -652,9 +652,16 @@ struct symbol_list * sparse(char **argv)
 	/* Drop the tokens for this file after parsing */
 	clear_token_alloc();
 
+	/* And return it */
+	return res;
+}
+
+struct symbol_list * sparse(char **argv)
+{
+	struct symbol_list *res = __sparse(argv);
+
 	/* Evaluate the complete symbol list */
 	evaluate_symbol_list(res);
 
-	/* And return it */
 	return res;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] sparse: mention available platforms ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/3] sparse: mention available platforms
Date: Thu, 01 Dec 2005 13:22:29 +0000
Message-ID: <20051201132229.GA8250 () mipter ! zuzino ! mipt ! ru>
--------------------
Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
---

 Makefile |    2 ++
 1 file changed, 2 insertions(+)

--- sparse-000/Makefile
+++ sparse-001/Makefile
@@ -1,6 +1,8 @@
 #
 # Turkey time!
 #
+
+# cygwin linux mingw solaris
 OS=linux
 
 CC=gcc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error
Date: Mon, 07 Nov 2005 21:54:35 +0000
Message-ID: <Pine.LNX.4.64.0511071349160.3247 () g5 ! osdl ! org>
--------------------


On Mon, 7 Nov 2005, Greg KH wrote:
> 
> >  enum pci_channel_state {
> > -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> > -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> > -	pci_channel_io_perm_failure,	/* PCI card is dead */
> > +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> > +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> > +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
> >  };
> 
> You don't have to use an enum anymore, just use a #define.

The enum works fine, though, and has less namespace pollution than a 
#define, so sometimes an enum can be preferred.

HOWEVER. For sanity, if possible please avoid using the value "0". It's 
magic for __bitwise, in that a zero is always acceptable as a bitwise 
thing (which makes sense if you think of bitwise as being about bits: the 
zero representation is totally independent of any bit ordering).

So it's better to start counting from 1 if possible.

> Sparse developers, I see code in the kernel that that does both 
> (__force foo_t) and (foo_t __force).  Which one is correct?

sparse doesn't care. Whatever scans better for humans. Attributes like 
"force" parse the same way things like "const" and "volatile" parses, and 
while most people _tend_ to write "const int", it's not incorrect to write 
"int const". Same with "__attribute__((force))", aka __force.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-pci
Subject: Re: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error
Date: Mon, 07 Nov 2005 21:54:35 +0000
Message-ID: <Pine.LNX.4.64.0511071349160.3247 () g5 ! osdl ! org>
--------------------


On Mon, 7 Nov 2005, Greg KH wrote:
> 
> >  enum pci_channel_state {
> > -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> > -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> > -	pci_channel_io_perm_failure,	/* PCI card is dead */
> > +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> > +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> > +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
> >  };
> 
> You don't have to use an enum anymore, just use a #define.

The enum works fine, though, and has less namespace pollution than a 
#define, so sometimes an enum can be preferred.

HOWEVER. For sanity, if possible please avoid using the value "0". It's 
magic for __bitwise, in that a zero is always acceptable as a bitwise 
thing (which makes sense if you think of bitwise as being about bits: the 
zero representation is totally independent of any bit ordering).

So it's better to start counting from 1 if possible.

> Sparse developers, I see code in the kernel that that does both 
> (__force foo_t) and (foo_t __force).  Which one is correct?

sparse doesn't care. Whatever scans better for humans. Attributes like 
"force" parse the same way things like "const" and "volatile" parses, and 
while most people _tend_ to write "const int", it's not incorrect to write 
"int const". Same with "__attribute__((force))", aka __force.

			Linus
================================================================================

From: torvalds () osdl ! org (Linus Torvalds)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error
Date: Mon, 07 Nov 2005 21:54:35 +0000
Message-ID: <Pine.LNX.4.64.0511071349160.3247 () g5 ! osdl ! org>
--------------------


On Mon, 7 Nov 2005, Greg KH wrote:
> 
> >  enum pci_channel_state {
> > -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> > -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> > -	pci_channel_io_perm_failure,	/* PCI card is dead */
> > +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> > +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> > +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
> >  };
> 
> You don't have to use an enum anymore, just use a #define.

The enum works fine, though, and has less namespace pollution than a 
#define, so sometimes an enum can be preferred.

HOWEVER. For sanity, if possible please avoid using the value "0". It's 
magic for __bitwise, in that a zero is always acceptable as a bitwise 
thing (which makes sense if you think of bitwise as being about bits: the 
zero representation is totally independent of any bit ordering).

So it's better to start counting from 1 if possible.

> Sparse developers, I see code in the kernel that that does both 
> (__force foo_t) and (foo_t __force).  Which one is correct?

sparse doesn't care. Whatever scans better for humans. Attributes like 
"force" parse the same way things like "const" and "volatile" parses, and 
while most people _tend_ to write "const int", it's not incorrect to write 
"int const". Same with "__attribute__((force))", aka __force.

			Linus


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-kernel
Subject: Re: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error
Date: Mon, 07 Nov 2005 21:54:35 +0000
Message-ID: <Pine.LNX.4.64.0511071349160.3247 () g5 ! osdl ! org>
--------------------


On Mon, 7 Nov 2005, Greg KH wrote:
> 
> >  enum pci_channel_state {
> > -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> > -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> > -	pci_channel_io_perm_failure,	/* PCI card is dead */
> > +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> > +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> > +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
> >  };
> 
> You don't have to use an enum anymore, just use a #define.

The enum works fine, though, and has less namespace pollution than a 
#define, so sometimes an enum can be preferred.

HOWEVER. For sanity, if possible please avoid using the value "0". It's 
magic for __bitwise, in that a zero is always acceptable as a bitwise 
thing (which makes sense if you think of bitwise as being about bits: the 
zero representation is totally independent of any bit ordering).

So it's better to start counting from 1 if possible.

> Sparse developers, I see code in the kernel that that does both 
> (__force foo_t) and (foo_t __force).  Which one is correct?

sparse doesn't care. Whatever scans better for humans. Attributes like 
"force" parse the same way things like "const" and "volatile" parses, and 
while most people _tend_ to write "const int", it's not incorrect to write 
"int const". Same with "__attribute__((force))", aka __force.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error reporting callbacks ===

From: linas <linas () austin ! ibm ! com>
To: linux-kernel
Subject: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 21:21:28 +0000
Message-ID: <20051107212128.GH19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 12:03:52PM -0800, Greg KH was heard to remark:
> On Mon, Nov 07, 2005 at 01:57:27PM -0600, linas wrote:
> > On Mon, Nov 07, 2005 at 10:27:27AM -0800, Greg KH was heard to remark:
> > > 3) realy strong typing that sparse can detect.
> Please go look at the __bitwise documentation.

PCI Error Recovery: header file patch

Change enums and subroutine signatures to be strongly typed, per recent
discussion with GregKH. Also, change the acronym to the more unique, 
less generic "PERS" "PCI Error Recovery System".

Greg, Please apply.

Signed-off-by: Linas Vepstas <linas@austin.ibm.com>

--
Index: linux-2.6.14-mm1/include/linux/pci.h
===================================================================
--- linux-2.6.14-mm1.orig/include/linux/pci.h	2005-11-07 13:55:28.528843983 -0600
+++ linux-2.6.14-mm1/include/linux/pci.h	2005-11-07 14:56:04.917367579 -0600
@@ -82,10 +82,12 @@
  *  the pci device.  If some PCI bus between here and the pci device
  *  has crashed or locked up, this info is reflected here.
  */
+typedef int __bitwise pci_channel_state_t;
+
 enum pci_channel_state {
-	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
-	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
-	pci_channel_io_perm_failure,	/* PCI card is dead */
+	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
+	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
+	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
 };
 
 /*
@@ -121,7 +123,7 @@
 					   this is D0-D3, D0 being fully functional,
 					   and D3 being off. */
 
-	enum pci_channel_state error_state;	/* current connectivity state */
+	pci_channel_state_t error_state;	/* current connectivity state */
 	struct	device	dev;		/* Generic device interface */
 
 	/* device is compatible with these IDs */
@@ -245,35 +247,37 @@
 };
 
 /* ---------------------------------------------------------------- */
-/** PCI error recovery infrastructure.  If a PCI device driver provides
+/** PCI Error Recovery System (PERS).  If a PCI device driver provides
  *  a set fof callbacks in struct pci_error_handlers, then that device driver
  *  will be notified of PCI bus errors, and will be driven to recovery
  *  when an error occurs.
  */
 
-enum pcierr_result {
-	PCIERR_RESULT_NONE = 0,		/* no result/none/not supported in device driver */
-	PCIERR_RESULT_CAN_RECOVER=1,	/* Device driver can recover without slot reset */
-	PCIERR_RESULT_NEED_RESET,	/* Device driver wants slot to be reset. */
-	PCIERR_RESULT_DISCONNECT,	/* Device has completely failed, is unrecoverable */
-	PCIERR_RESULT_RECOVERED,	/* Device driver is fully recovered and operational */
+typedef int __bitwise pers_result_t;
+
+enum pers_result {
+	PERS_RESULT_NONE = (__force pers_result_t) 0,		/* no result/none/not supported in device driver */
+	PERS_RESULT_CAN_RECOVER = (__force pers_result_t) 1,	/* Device driver can recover without slot reset */
+	PERS_RESULT_NEED_RESET = (__force pers_result_t) 2,	/* Device driver wants slot to be reset. */
+	PERS_RESULT_DISCONNECT = (__force pers_result_t) 3,	/* Device has completely failed, is unrecoverable */
+	PERS_RESULT_RECOVERED = (__force pers_result_t) 4,	/* Device driver is fully recovered and operational */
 };
 
 /* PCI bus error event callbacks */
 struct pci_error_handlers
 {
 	/* PCI bus error detected on this device */
-	int (*error_detected)(struct pci_dev *dev,
-	                      enum pci_channel_state error);
+	pers_result_t (*error_detected)(struct pci_dev *dev,
+	                      pci_channel_state_t error);
 
 	/* MMIO has been re-enabled, but not DMA */
-	int (*mmio_enabled)(struct pci_dev *dev);
+	pers_result_t (*mmio_enabled)(struct pci_dev *dev);
 
 	/* PCI Express link has been reset */
-	int (*link_reset)(struct pci_dev *dev);
+	pers_result_t (*link_reset)(struct pci_dev *dev);
 
 	/* PCI slot has been reset */
-	int (*slot_reset)(struct pci_dev *dev);
+	pers_result_t (*slot_reset)(struct pci_dev *dev);
 
 	/* Device driver may resume normal operations */
 	void (*resume)(struct pci_dev *dev);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: linas <linas () austin ! ibm ! com>
To: linux-pci
Subject: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 21:21:28 +0000
Message-ID: <20051107212128.GH19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 12:03:52PM -0800, Greg KH was heard to remark:
> On Mon, Nov 07, 2005 at 01:57:27PM -0600, linas wrote:
> > On Mon, Nov 07, 2005 at 10:27:27AM -0800, Greg KH was heard to remark:
> > > 3) realy strong typing that sparse can detect.
> Please go look at the __bitwise documentation.

PCI Error Recovery: header file patch

Change enums and subroutine signatures to be strongly typed, per recent
discussion with GregKH. Also, change the acronym to the more unique, 
less generic "PERS" "PCI Error Recovery System".

Greg, Please apply.

Signed-off-by: Linas Vepstas <linas@austin.ibm.com>

--
Index: linux-2.6.14-mm1/include/linux/pci.h
===================================================================
--- linux-2.6.14-mm1.orig/include/linux/pci.h	2005-11-07 13:55:28.528843983 -0600
+++ linux-2.6.14-mm1/include/linux/pci.h	2005-11-07 14:56:04.917367579 -0600
@@ -82,10 +82,12 @@
  *  the pci device.  If some PCI bus between here and the pci device
  *  has crashed or locked up, this info is reflected here.
  */
+typedef int __bitwise pci_channel_state_t;
+
 enum pci_channel_state {
-	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
-	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
-	pci_channel_io_perm_failure,	/* PCI card is dead */
+	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
+	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
+	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
 };
 
 /*
@@ -121,7 +123,7 @@
 					   this is D0-D3, D0 being fully functional,
 					   and D3 being off. */
 
-	enum pci_channel_state error_state;	/* current connectivity state */
+	pci_channel_state_t error_state;	/* current connectivity state */
 	struct	device	dev;		/* Generic device interface */
 
 	/* device is compatible with these IDs */
@@ -245,35 +247,37 @@
 };
 
 /* ---------------------------------------------------------------- */
-/** PCI error recovery infrastructure.  If a PCI device driver provides
+/** PCI Error Recovery System (PERS).  If a PCI device driver provides
  *  a set fof callbacks in struct pci_error_handlers, then that device driver
  *  will be notified of PCI bus errors, and will be driven to recovery
  *  when an error occurs.
  */
 
-enum pcierr_result {
-	PCIERR_RESULT_NONE = 0,		/* no result/none/not supported in device driver */
-	PCIERR_RESULT_CAN_RECOVER=1,	/* Device driver can recover without slot reset */
-	PCIERR_RESULT_NEED_RESET,	/* Device driver wants slot to be reset. */
-	PCIERR_RESULT_DISCONNECT,	/* Device has completely failed, is unrecoverable */
-	PCIERR_RESULT_RECOVERED,	/* Device driver is fully recovered and operational */
+typedef int __bitwise pers_result_t;
+
+enum pers_result {
+	PERS_RESULT_NONE = (__force pers_result_t) 0,		/* no result/none/not supported in device driver */
+	PERS_RESULT_CAN_RECOVER = (__force pers_result_t) 1,	/* Device driver can recover without slot reset */
+	PERS_RESULT_NEED_RESET = (__force pers_result_t) 2,	/* Device driver wants slot to be reset. */
+	PERS_RESULT_DISCONNECT = (__force pers_result_t) 3,	/* Device has completely failed, is unrecoverable */
+	PERS_RESULT_RECOVERED = (__force pers_result_t) 4,	/* Device driver is fully recovered and operational */
 };
 
 /* PCI bus error event callbacks */
 struct pci_error_handlers
 {
 	/* PCI bus error detected on this device */
-	int (*error_detected)(struct pci_dev *dev,
-	                      enum pci_channel_state error);
+	pers_result_t (*error_detected)(struct pci_dev *dev,
+	                      pci_channel_state_t error);
 
 	/* MMIO has been re-enabled, but not DMA */
-	int (*mmio_enabled)(struct pci_dev *dev);
+	pers_result_t (*mmio_enabled)(struct pci_dev *dev);
 
 	/* PCI Express link has been reset */
-	int (*link_reset)(struct pci_dev *dev);
+	pers_result_t (*link_reset)(struct pci_dev *dev);
 
 	/* PCI slot has been reset */
-	int (*slot_reset)(struct pci_dev *dev);
+	pers_result_t (*slot_reset)(struct pci_dev *dev);
 
 	/* Device driver may resume normal operations */
 	void (*resume)(struct pci_dev *dev);
================================================================================

From: Greg KH <greg () kroah ! com>
To: linux-sparse
Subject: Re: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 21:37:29 +0000
Message-ID: <20051107213729.GA24700 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> +typedef int __bitwise pci_channel_state_t;

Closer but...

>  enum pci_channel_state {
> -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> -	pci_channel_io_perm_failure,	/* PCI card is dead */
> +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
>  };

You don't have to use an enum anymore, just use a #define.

Sparse developers, I see code in the kernel that that does both 
(__force foo_t) and (foo_t __force).  Which one is correct?


> +typedef int __bitwise pers_result_t;

Ugh, I don't like that name, but I can't think of anything better right
now.  You should at least keep "pci" at the beginning to make it make
more sense to people looking at it for the first time.

thanks,

greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Greg KH <greg () kroah ! com>
To: linux-kernel
Subject: Re: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 21:37:29 +0000
Message-ID: <20051107213729.GA24700 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> +typedef int __bitwise pci_channel_state_t;

Closer but...

>  enum pci_channel_state {
> -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> -	pci_channel_io_perm_failure,	/* PCI card is dead */
> +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
>  };

You don't have to use an enum anymore, just use a #define.

Sparse developers, I see code in the kernel that that does both 
(__force foo_t) and (foo_t __force).  Which one is correct?


> +typedef int __bitwise pers_result_t;

Ugh, I don't like that name, but I can't think of anything better right
now.  You should at least keep "pci" at the beginning to make it make
more sense to people looking at it for the first time.

thanks,

greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Greg KH <greg () kroah ! com>
To: linux-sparse
Subject: Re: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 22:54:29 +0000
Message-ID: <20051107225429.GD27787 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 01:54:35PM -0800, Linus Torvalds wrote:
> On Mon, 7 Nov 2005, Greg KH wrote:
> > >  enum pci_channel_state {
> > > -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> > > -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> > > -	pci_channel_io_perm_failure,	/* PCI card is dead */
> > > +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> > > +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> > > +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
> > >  };
> > 
> > You don't have to use an enum anymore, just use a #define.
> 
> The enum works fine, though, and has less namespace pollution than a 
> #define, so sometimes an enum can be preferred.

Good point.

> > Sparse developers, I see code in the kernel that that does both 
> > (__force foo_t) and (foo_t __force).  Which one is correct?
> 
> sparse doesn't care. Whatever scans better for humans. Attributes like 
> "force" parse the same way things like "const" and "volatile" parses, and 
> while most people _tend_ to write "const int", it's not incorrect to write 
> "int const". Same with "__attribute__((force))", aka __force.

Ok, thanks for clearing this up.

greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Greg KH <greg () kroah ! com>
To: linux-kernel
Subject: Re: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 22:54:29 +0000
Message-ID: <20051107225429.GD27787 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 01:54:35PM -0800, Linus Torvalds wrote:
> On Mon, 7 Nov 2005, Greg KH wrote:
> > >  enum pci_channel_state {
> > > -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> > > -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> > > -	pci_channel_io_perm_failure,	/* PCI card is dead */
> > > +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> > > +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> > > +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
> > >  };
> > 
> > You don't have to use an enum anymore, just use a #define.
> 
> The enum works fine, though, and has less namespace pollution than a 
> #define, so sometimes an enum can be preferred.

Good point.

> > Sparse developers, I see code in the kernel that that does both 
> > (__force foo_t) and (foo_t __force).  Which one is correct?
> 
> sparse doesn't care. Whatever scans better for humans. Attributes like 
> "force" parse the same way things like "const" and "volatile" parses, and 
> while most people _tend_ to write "const int", it's not incorrect to write 
> "int const". Same with "__attribute__((force))", aka __force.

Ok, thanks for clearing this up.

greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI: PCI Error ===

From: linas () austin ! ibm ! com (linas)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI: PCI Error
Date: Mon, 07 Nov 2005 21:21:28 +0000
Message-ID: <20051107212128.GH19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 12:03:52PM -0800, Greg KH was heard to remark:
> On Mon, Nov 07, 2005 at 01:57:27PM -0600, linas wrote:
> > On Mon, Nov 07, 2005 at 10:27:27AM -0800, Greg KH was heard to remark:
> > > 3) realy strong typing that sparse can detect.
> Please go look at the __bitwise documentation.

PCI Error Recovery: header file patch

Change enums and subroutine signatures to be strongly typed, per recent
discussion with GregKH. Also, change the acronym to the more unique, 
less generic "PERS" "PCI Error Recovery System".

Greg, Please apply.

Signed-off-by: Linas Vepstas <linas at austin.ibm.com>

--
Index: linux-2.6.14-mm1/include/linux/pci.h
===================================================================
--- linux-2.6.14-mm1.orig/include/linux/pci.h	2005-11-07 13:55:28.528843983 -0600
+++ linux-2.6.14-mm1/include/linux/pci.h	2005-11-07 14:56:04.917367579 -0600
@@ -82,10 +82,12 @@
  *  the pci device.  If some PCI bus between here and the pci device
  *  has crashed or locked up, this info is reflected here.
  */
+typedef int __bitwise pci_channel_state_t;
+
 enum pci_channel_state {
-	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
-	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
-	pci_channel_io_perm_failure,	/* PCI card is dead */
+	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
+	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
+	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
 };
 
 /*
@@ -121,7 +123,7 @@
 					   this is D0-D3, D0 being fully functional,
 					   and D3 being off. */
 
-	enum pci_channel_state error_state;	/* current connectivity state */
+	pci_channel_state_t error_state;	/* current connectivity state */
 	struct	device	dev;		/* Generic device interface */
 
 	/* device is compatible with these IDs */
@@ -245,35 +247,37 @@
 };
 
 /* ---------------------------------------------------------------- */
-/** PCI error recovery infrastructure.  If a PCI device driver provides
+/** PCI Error Recovery System (PERS).  If a PCI device driver provides
  *  a set fof callbacks in struct pci_error_handlers, then that device driver
  *  will be notified of PCI bus errors, and will be driven to recovery
  *  when an error occurs.
  */
 
-enum pcierr_result {
-	PCIERR_RESULT_NONE = 0,		/* no result/none/not supported in device driver */
-	PCIERR_RESULT_CAN_RECOVER=1,	/* Device driver can recover without slot reset */
-	PCIERR_RESULT_NEED_RESET,	/* Device driver wants slot to be reset. */
-	PCIERR_RESULT_DISCONNECT,	/* Device has completely failed, is unrecoverable */
-	PCIERR_RESULT_RECOVERED,	/* Device driver is fully recovered and operational */
+typedef int __bitwise pers_result_t;
+
+enum pers_result {
+	PERS_RESULT_NONE = (__force pers_result_t) 0,		/* no result/none/not supported in device driver */
+	PERS_RESULT_CAN_RECOVER = (__force pers_result_t) 1,	/* Device driver can recover without slot reset */
+	PERS_RESULT_NEED_RESET = (__force pers_result_t) 2,	/* Device driver wants slot to be reset. */
+	PERS_RESULT_DISCONNECT = (__force pers_result_t) 3,	/* Device has completely failed, is unrecoverable */
+	PERS_RESULT_RECOVERED = (__force pers_result_t) 4,	/* Device driver is fully recovered and operational */
 };
 
 /* PCI bus error event callbacks */
 struct pci_error_handlers
 {
 	/* PCI bus error detected on this device */
-	int (*error_detected)(struct pci_dev *dev,
-	                      enum pci_channel_state error);
+	pers_result_t (*error_detected)(struct pci_dev *dev,
+	                      pci_channel_state_t error);
 
 	/* MMIO has been re-enabled, but not DMA */
-	int (*mmio_enabled)(struct pci_dev *dev);
+	pers_result_t (*mmio_enabled)(struct pci_dev *dev);
 
 	/* PCI Express link has been reset */
-	int (*link_reset)(struct pci_dev *dev);
+	pers_result_t (*link_reset)(struct pci_dev *dev);
 
 	/* PCI slot has been reset */
-	int (*slot_reset)(struct pci_dev *dev);
+	pers_result_t (*slot_reset)(struct pci_dev *dev);
 
 	/* Device driver may resume normal operations */
 	void (*resume)(struct pci_dev *dev);


================================================================================

From: greg () kroah ! com (Greg KH)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI: PCI Error
Date: Mon, 07 Nov 2005 21:37:29 +0000
Message-ID: <20051107213729.GA24700 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> +typedef int __bitwise pci_channel_state_t;

Closer but...

>  enum pci_channel_state {
> -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> -	pci_channel_io_perm_failure,	/* PCI card is dead */
> +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
>  };

You don't have to use an enum anymore, just use a #define.

Sparse developers, I see code in the kernel that that does both 
(__force foo_t) and (foo_t __force).  Which one is correct?


> +typedef int __bitwise pers_result_t;

Ugh, I don't like that name, but I can't think of anything better right
now.  You should at least keep "pci" at the beginning to make it make
more sense to people looking at it for the first time.

thanks,

greg k-h


================================================================================

From: greg () kroah ! com (Greg KH)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (2) [PATCH 16/42]: PCI: PCI Error
Date: Mon, 07 Nov 2005 22:54:29 +0000
Message-ID: <20051107225429.GD27787 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 01:54:35PM -0800, Linus Torvalds wrote:
> On Mon, 7 Nov 2005, Greg KH wrote:
> > >  enum pci_channel_state {
> > > -	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
> > > -	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
> > > -	pci_channel_io_perm_failure,	/* PCI card is dead */
> > > +	pci_channel_io_normal = (__force pci_channel_state_t) 0,	/* I/O channel is in normal state */
> > > +	pci_channel_io_frozen = (__force pci_channel_state_t) 1,	/* I/O to channel is blocked */
> > > +	pci_channel_io_perm_failure = (__force pci_channel_state_t) 2,	/* PCI card is dead */
> > >  };
> > 
> > You don't have to use an enum anymore, just use a #define.
> 
> The enum works fine, though, and has less namespace pollution than a 
> #define, so sometimes an enum can be preferred.

Good point.

> > Sparse developers, I see code in the kernel that that does both 
> > (__force foo_t) and (foo_t __force).  Which one is correct?
> 
> sparse doesn't care. Whatever scans better for humans. Attributes like 
> "force" parse the same way things like "const" and "volatile" parses, and 
> while most people _tend_ to write "const int", it's not incorrect to write 
> "int const". Same with "__attribute__((force))", aka __force.

Ok, thanks for clearing this up.

greg k-h


================================================================================


################################################################################

=== Thread: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks ===

From: linas <linas () austin ! ibm ! com>
To: linux-sparse
Subject: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 22:43:38 +0000
Message-ID: <20051107224338.GQ19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 01:37:29PM -0800, Greg KH was heard to remark:
> On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> > +typedef int __bitwise pci_channel_state_t;
> 
> You don't have to use an enum anymore, just use a #define.

Per Linus's remarks about namespace pollution, I've kept the enums.

> > +typedef int __bitwise pers_result_t;
> 
> You should at least keep "pci" at the beginning to make it make
> more sense to people looking at it for the first time.

PCI_ERS and pci_ers, then.

I'm feeling like a blinkin' spammer, splatting out all these emails.

--linas

PCI Error Recovery: header file patch

Change enums and subroutine signatures to be strongly typed, per recent
discussion with GregKH. Also, change the acronym to the more unique, 
less generic "PCI-ERS" "PCI Error Recovery System".

Please apply.

Signed-off-by: Linas Vepstas <linas@austin.ibm.com>

--
Index: linux-2.6.14-mm1/include/linux/pci.h
===================================================================
--- linux-2.6.14-mm1.orig/include/linux/pci.h	2005-11-07 13:55:28.000000000 -0600
+++ linux-2.6.14-mm1/include/linux/pci.h	2005-11-07 16:34:29.790592784 -0600
@@ -82,10 +82,12 @@
  *  the pci device.  If some PCI bus between here and the pci device
  *  has crashed or locked up, this info is reflected here.
  */
+typedef int __bitwise pci_channel_state_t;
+
 enum pci_channel_state {
-	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
-	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
-	pci_channel_io_perm_failure,	/* PCI card is dead */
+	pci_channel_io_normal = (__force pci_channel_state_t) 1,	/* I/O channel is in normal state */
+	pci_channel_io_frozen = (__force pci_channel_state_t) 2,	/* I/O to channel is blocked */
+	pci_channel_io_perm_failure = (__force pci_channel_state_t) 3,	/* PCI card is dead */
 };
 
 /*
@@ -121,7 +123,7 @@
 					   this is D0-D3, D0 being fully functional,
 					   and D3 being off. */
 
-	enum pci_channel_state error_state;	/* current connectivity state */
+	pci_channel_state_t error_state;	/* current connectivity state */
 	struct	device	dev;		/* Generic device interface */
 
 	/* device is compatible with these IDs */
@@ -245,35 +247,46 @@
 };
 
 /* ---------------------------------------------------------------- */
-/** PCI error recovery infrastructure.  If a PCI device driver provides
+/** PCI Error Recovery System (PCI-ERS).  If a PCI device driver provides
  *  a set fof callbacks in struct pci_error_handlers, then that device driver
  *  will be notified of PCI bus errors, and will be driven to recovery
  *  when an error occurs.
  */
 
-enum pcierr_result {
-	PCIERR_RESULT_NONE = 0,		/* no result/none/not supported in device driver */
-	PCIERR_RESULT_CAN_RECOVER=1,	/* Device driver can recover without slot reset */
-	PCIERR_RESULT_NEED_RESET,	/* Device driver wants slot to be reset. */
-	PCIERR_RESULT_DISCONNECT,	/* Device has completely failed, is unrecoverable */
-	PCIERR_RESULT_RECOVERED,	/* Device driver is fully recovered and operational */
+typedef int __bitwise pci_ers_result_t;
+
+enum pci_ers_result {
+	/* no result/none/not supported in device driver */
+	PCI_ERS_RESULT_NONE = (__force pci_ers_result_t) 1,
+	
+	/* Device driver can recover without slot reset */
+	PCI_ERS_RESULT_CAN_RECOVER = (__force pci_ers_result_t) 2,
+	
+	/* Device driver wants slot to be reset. */
+	PCI_ERS_RESULT_NEED_RESET = (__force pci_ers_result_t) 3,
+	
+	/* Device has completely failed, is unrecoverable */
+	PCI_ERS_RESULT_DISCONNECT = (__force pci_ers_result_t) 4,
+	
+	/* Device driver is fully recovered and operational */
+	PCI_ERS_RESULT_RECOVERED = (__force pci_ers_result_t) 5,
 };
 
 /* PCI bus error event callbacks */
 struct pci_error_handlers
 {
 	/* PCI bus error detected on this device */
-	int (*error_detected)(struct pci_dev *dev,
-	                      enum pci_channel_state error);
+	pci_ers_result_t (*error_detected)(struct pci_dev *dev,
+	                      pci_channel_state_t error);
 
 	/* MMIO has been re-enabled, but not DMA */
-	int (*mmio_enabled)(struct pci_dev *dev);
+	pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev);
 
 	/* PCI Express link has been reset */
-	int (*link_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*link_reset)(struct pci_dev *dev);
 
 	/* PCI slot has been reset */
-	int (*slot_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*slot_reset)(struct pci_dev *dev);
 
 	/* Device driver may resume normal operations */
 	void (*resume)(struct pci_dev *dev);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: linas <linas () austin ! ibm ! com>
To: linux-kernel
Subject: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 22:43:38 +0000
Message-ID: <20051107224338.GQ19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 01:37:29PM -0800, Greg KH was heard to remark:
> On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> > +typedef int __bitwise pci_channel_state_t;
> 
> You don't have to use an enum anymore, just use a #define.

Per Linus's remarks about namespace pollution, I've kept the enums.

> > +typedef int __bitwise pers_result_t;
> 
> You should at least keep "pci" at the beginning to make it make
> more sense to people looking at it for the first time.

PCI_ERS and pci_ers, then.

I'm feeling like a blinkin' spammer, splatting out all these emails.

--linas

PCI Error Recovery: header file patch

Change enums and subroutine signatures to be strongly typed, per recent
discussion with GregKH. Also, change the acronym to the more unique, 
less generic "PCI-ERS" "PCI Error Recovery System".

Please apply.

Signed-off-by: Linas Vepstas <linas@austin.ibm.com>

--
Index: linux-2.6.14-mm1/include/linux/pci.h
===================================================================
--- linux-2.6.14-mm1.orig/include/linux/pci.h	2005-11-07 13:55:28.000000000 -0600
+++ linux-2.6.14-mm1/include/linux/pci.h	2005-11-07 16:34:29.790592784 -0600
@@ -82,10 +82,12 @@
  *  the pci device.  If some PCI bus between here and the pci device
  *  has crashed or locked up, this info is reflected here.
  */
+typedef int __bitwise pci_channel_state_t;
+
 enum pci_channel_state {
-	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
-	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
-	pci_channel_io_perm_failure,	/* PCI card is dead */
+	pci_channel_io_normal = (__force pci_channel_state_t) 1,	/* I/O channel is in normal state */
+	pci_channel_io_frozen = (__force pci_channel_state_t) 2,	/* I/O to channel is blocked */
+	pci_channel_io_perm_failure = (__force pci_channel_state_t) 3,	/* PCI card is dead */
 };
 
 /*
@@ -121,7 +123,7 @@
 					   this is D0-D3, D0 being fully functional,
 					   and D3 being off. */
 
-	enum pci_channel_state error_state;	/* current connectivity state */
+	pci_channel_state_t error_state;	/* current connectivity state */
 	struct	device	dev;		/* Generic device interface */
 
 	/* device is compatible with these IDs */
@@ -245,35 +247,46 @@
 };
 
 /* ---------------------------------------------------------------- */
-/** PCI error recovery infrastructure.  If a PCI device driver provides
+/** PCI Error Recovery System (PCI-ERS).  If a PCI device driver provides
  *  a set fof callbacks in struct pci_error_handlers, then that device driver
  *  will be notified of PCI bus errors, and will be driven to recovery
  *  when an error occurs.
  */
 
-enum pcierr_result {
-	PCIERR_RESULT_NONE = 0,		/* no result/none/not supported in device driver */
-	PCIERR_RESULT_CAN_RECOVER=1,	/* Device driver can recover without slot reset */
-	PCIERR_RESULT_NEED_RESET,	/* Device driver wants slot to be reset. */
-	PCIERR_RESULT_DISCONNECT,	/* Device has completely failed, is unrecoverable */
-	PCIERR_RESULT_RECOVERED,	/* Device driver is fully recovered and operational */
+typedef int __bitwise pci_ers_result_t;
+
+enum pci_ers_result {
+	/* no result/none/not supported in device driver */
+	PCI_ERS_RESULT_NONE = (__force pci_ers_result_t) 1,
+	
+	/* Device driver can recover without slot reset */
+	PCI_ERS_RESULT_CAN_RECOVER = (__force pci_ers_result_t) 2,
+	
+	/* Device driver wants slot to be reset. */
+	PCI_ERS_RESULT_NEED_RESET = (__force pci_ers_result_t) 3,
+	
+	/* Device has completely failed, is unrecoverable */
+	PCI_ERS_RESULT_DISCONNECT = (__force pci_ers_result_t) 4,
+	
+	/* Device driver is fully recovered and operational */
+	PCI_ERS_RESULT_RECOVERED = (__force pci_ers_result_t) 5,
 };
 
 /* PCI bus error event callbacks */
 struct pci_error_handlers
 {
 	/* PCI bus error detected on this device */
-	int (*error_detected)(struct pci_dev *dev,
-	                      enum pci_channel_state error);
+	pci_ers_result_t (*error_detected)(struct pci_dev *dev,
+	                      pci_channel_state_t error);
 
 	/* MMIO has been re-enabled, but not DMA */
-	int (*mmio_enabled)(struct pci_dev *dev);
+	pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev);
 
 	/* PCI Express link has been reset */
-	int (*link_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*link_reset)(struct pci_dev *dev);
 
 	/* PCI slot has been reset */
-	int (*slot_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*slot_reset)(struct pci_dev *dev);
 
 	/* Device driver may resume normal operations */
 	void (*resume)(struct pci_dev *dev);
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: linas <linas () austin ! ibm ! com>
To: linux-pci
Subject: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 22:43:38 +0000
Message-ID: <20051107224338.GQ19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 01:37:29PM -0800, Greg KH was heard to remark:
> On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> > +typedef int __bitwise pci_channel_state_t;
> 
> You don't have to use an enum anymore, just use a #define.

Per Linus's remarks about namespace pollution, I've kept the enums.

> > +typedef int __bitwise pers_result_t;
> 
> You should at least keep "pci" at the beginning to make it make
> more sense to people looking at it for the first time.

PCI_ERS and pci_ers, then.

I'm feeling like a blinkin' spammer, splatting out all these emails.

--linas

PCI Error Recovery: header file patch

Change enums and subroutine signatures to be strongly typed, per recent
discussion with GregKH. Also, change the acronym to the more unique, 
less generic "PCI-ERS" "PCI Error Recovery System".

Please apply.

Signed-off-by: Linas Vepstas <linas@austin.ibm.com>

--
Index: linux-2.6.14-mm1/include/linux/pci.h
===================================================================
--- linux-2.6.14-mm1.orig/include/linux/pci.h	2005-11-07 13:55:28.000000000 -0600
+++ linux-2.6.14-mm1/include/linux/pci.h	2005-11-07 16:34:29.790592784 -0600
@@ -82,10 +82,12 @@
  *  the pci device.  If some PCI bus between here and the pci device
  *  has crashed or locked up, this info is reflected here.
  */
+typedef int __bitwise pci_channel_state_t;
+
 enum pci_channel_state {
-	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
-	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
-	pci_channel_io_perm_failure,	/* PCI card is dead */
+	pci_channel_io_normal = (__force pci_channel_state_t) 1,	/* I/O channel is in normal state */
+	pci_channel_io_frozen = (__force pci_channel_state_t) 2,	/* I/O to channel is blocked */
+	pci_channel_io_perm_failure = (__force pci_channel_state_t) 3,	/* PCI card is dead */
 };
 
 /*
@@ -121,7 +123,7 @@
 					   this is D0-D3, D0 being fully functional,
 					   and D3 being off. */
 
-	enum pci_channel_state error_state;	/* current connectivity state */
+	pci_channel_state_t error_state;	/* current connectivity state */
 	struct	device	dev;		/* Generic device interface */
 
 	/* device is compatible with these IDs */
@@ -245,35 +247,46 @@
 };
 
 /* ---------------------------------------------------------------- */
-/** PCI error recovery infrastructure.  If a PCI device driver provides
+/** PCI Error Recovery System (PCI-ERS).  If a PCI device driver provides
  *  a set fof callbacks in struct pci_error_handlers, then that device driver
  *  will be notified of PCI bus errors, and will be driven to recovery
  *  when an error occurs.
  */
 
-enum pcierr_result {
-	PCIERR_RESULT_NONE = 0,		/* no result/none/not supported in device driver */
-	PCIERR_RESULT_CAN_RECOVER=1,	/* Device driver can recover without slot reset */
-	PCIERR_RESULT_NEED_RESET,	/* Device driver wants slot to be reset. */
-	PCIERR_RESULT_DISCONNECT,	/* Device has completely failed, is unrecoverable */
-	PCIERR_RESULT_RECOVERED,	/* Device driver is fully recovered and operational */
+typedef int __bitwise pci_ers_result_t;
+
+enum pci_ers_result {
+	/* no result/none/not supported in device driver */
+	PCI_ERS_RESULT_NONE = (__force pci_ers_result_t) 1,
+	
+	/* Device driver can recover without slot reset */
+	PCI_ERS_RESULT_CAN_RECOVER = (__force pci_ers_result_t) 2,
+	
+	/* Device driver wants slot to be reset. */
+	PCI_ERS_RESULT_NEED_RESET = (__force pci_ers_result_t) 3,
+	
+	/* Device has completely failed, is unrecoverable */
+	PCI_ERS_RESULT_DISCONNECT = (__force pci_ers_result_t) 4,
+	
+	/* Device driver is fully recovered and operational */
+	PCI_ERS_RESULT_RECOVERED = (__force pci_ers_result_t) 5,
 };
 
 /* PCI bus error event callbacks */
 struct pci_error_handlers
 {
 	/* PCI bus error detected on this device */
-	int (*error_detected)(struct pci_dev *dev,
-	                      enum pci_channel_state error);
+	pci_ers_result_t (*error_detected)(struct pci_dev *dev,
+	                      pci_channel_state_t error);
 
 	/* MMIO has been re-enabled, but not DMA */
-	int (*mmio_enabled)(struct pci_dev *dev);
+	pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev);
 
 	/* PCI Express link has been reset */
-	int (*link_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*link_reset)(struct pci_dev *dev);
 
 	/* PCI slot has been reset */
-	int (*slot_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*slot_reset)(struct pci_dev *dev);
 
 	/* Device driver may resume normal operations */
 	void (*resume)(struct pci_dev *dev);
================================================================================

From: Greg KH <greg () kroah ! com>
To: linux-kernel
Subject: Re: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 22:53:08 +0000
Message-ID: <20051107225308.GB27787 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 04:43:38PM -0600, linas wrote:
> On Mon, Nov 07, 2005 at 01:37:29PM -0800, Greg KH was heard to remark:
> > On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> > > +typedef int __bitwise pci_channel_state_t;
> > 
> > You don't have to use an enum anymore, just use a #define.
> 
> Per Linus's remarks about namespace pollution, I've kept the enums.

That's fine.

> > > +typedef int __bitwise pers_result_t;
> > 
> > You should at least keep "pci" at the beginning to make it make
> > more sense to people looking at it for the first time.
> 
> PCI_ERS and pci_ers, then.

Sounds good.

> I'm feeling like a blinkin' spammer, splatting out all these emails.

Care to just resend the whole series over again?  No "patch on top of
patch" stuff is needed here.

thanks,

greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: linas <linas () austin ! ibm ! com>
To: linux-sparse
Subject: Re: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 23:19:55 +0000
Message-ID: <20051107231955.GR19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 02:53:08PM -0800, Greg KH was heard to remark:
> > I'm feeling like a blinkin' spammer, splatting out all these emails.
> 
> Care to just resend the whole series over again?  No "patch on top of
> patch" stuff is needed here.

So that I can avoid that spammin' feelin' ... 

I'll send patches against -git10, then, so as to start with a clean
slate; unless you wanted something aginst -mm1?

"The whole series": do you want all 42 patches? Or just the seven
discussed today?

-----

In the series-of-42, the staging of some of the patches in the 
middle require simultaneous update to both the drivers/pci/hotplug
and the arch/powerpc/xxx; otherwise, build breaks result. I am
not sure how to handle that: the obvious solution is to split these
up... but that will probably result in a bigger series, and was
not a step I wanted to take unless someone asked...

--linas

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: linas <linas () austin ! ibm ! com>
To: linux-pci
Subject: Re: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 23:19:55 +0000
Message-ID: <20051107231955.GR19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 02:53:08PM -0800, Greg KH was heard to remark:
> > I'm feeling like a blinkin' spammer, splatting out all these emails.
> 
> Care to just resend the whole series over again?  No "patch on top of
> patch" stuff is needed here.

So that I can avoid that spammin' feelin' ... 

I'll send patches against -git10, then, so as to start with a clean
slate; unless you wanted something aginst -mm1?

"The whole series": do you want all 42 patches? Or just the seven
discussed today?

-----

In the series-of-42, the staging of some of the patches in the 
middle require simultaneous update to both the drivers/pci/hotplug
and the arch/powerpc/xxx; otherwise, build breaks result. I am
not sure how to handle that: the obvious solution is to split these
up... but that will probably result in a bigger series, and was
not a step I wanted to take unless someone asked...

--linas

================================================================================

From: linas <linas () austin ! ibm ! com>
To: linux-kernel
Subject: Re: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Mon, 07 Nov 2005 23:19:55 +0000
Message-ID: <20051107231955.GR19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 02:53:08PM -0800, Greg KH was heard to remark:
> > I'm feeling like a blinkin' spammer, splatting out all these emails.
> 
> Care to just resend the whole series over again?  No "patch on top of
> patch" stuff is needed here.

So that I can avoid that spammin' feelin' ... 

I'll send patches against -git10, then, so as to start with a clean
slate; unless you wanted something aginst -mm1?

"The whole series": do you want all 42 patches? Or just the seven
discussed today?

-----

In the series-of-42, the staging of some of the patches in the 
middle require simultaneous update to both the drivers/pci/hotplug
and the arch/powerpc/xxx; otherwise, build breaks result. I am
not sure how to handle that: the obvious solution is to split these
up... but that will probably result in a bigger series, and was
not a step I wanted to take unless someone asked...

--linas

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Greg KH <greg () kroah ! com>
To: linux-sparse
Subject: Re: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Tue, 08 Nov 2005 02:43:45 +0000
Message-ID: <20051108024344.GA538 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 05:19:55PM -0600, linas wrote:
> On Mon, Nov 07, 2005 at 02:53:08PM -0800, Greg KH was heard to remark:
> > > I'm feeling like a blinkin' spammer, splatting out all these emails.
> > 
> > Care to just resend the whole series over again?  No "patch on top of
> > patch" stuff is needed here.
> 
> So that I can avoid that spammin' feelin' ... 
> 
> I'll send patches against -git10, then, so as to start with a clean
> slate; unless you wanted something aginst -mm1?

-git10 would be great.

> "The whole series": do you want all 42 patches? Or just the seven
> discussed today?

Just the 7 discussed.  The others should go to their proper maintainers
(which I am not.)

> -----
> 
> In the series-of-42, the staging of some of the patches in the 
> middle require simultaneous update to both the drivers/pci/hotplug
> and the arch/powerpc/xxx; otherwise, build breaks result. I am
> not sure how to handle that: the obvious solution is to split these
> up... but that will probably result in a bigger series, and was
> not a step I wanted to take unless someone asked...

The drivers/pci/hotplug/ stuff only touches the rpaphp driver, right?
If so, I don't have a problem with Paul/Ben sending those on with the
other PPC64 changes to keep everything building properly for your arch.

thanks,

greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Greg KH <greg () kroah ! com>
To: linux-kernel
Subject: Re: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI:  PCI Error reporting callbacks
Date: Tue, 08 Nov 2005 02:43:45 +0000
Message-ID: <20051108024344.GA538 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 05:19:55PM -0600, linas wrote:
> On Mon, Nov 07, 2005 at 02:53:08PM -0800, Greg KH was heard to remark:
> > > I'm feeling like a blinkin' spammer, splatting out all these emails.
> > 
> > Care to just resend the whole series over again?  No "patch on top of
> > patch" stuff is needed here.
> 
> So that I can avoid that spammin' feelin' ... 
> 
> I'll send patches against -git10, then, so as to start with a clean
> slate; unless you wanted something aginst -mm1?

-git10 would be great.

> "The whole series": do you want all 42 patches? Or just the seven
> discussed today?

Just the 7 discussed.  The others should go to their proper maintainers
(which I am not.)

> -----
> 
> In the series-of-42, the staging of some of the patches in the 
> middle require simultaneous update to both the drivers/pci/hotplug
> and the arch/powerpc/xxx; otherwise, build breaks result. I am
> not sure how to handle that: the obvious solution is to split these
> up... but that will probably result in a bigger series, and was
> not a step I wanted to take unless someone asked...

The drivers/pci/hotplug/ stuff only touches the rpaphp driver, right?
If so, I don't have a problem with Paul/Ben sending those on with the
other PPC64 changes to keep everything building properly for your arch.

thanks,

greg k-h
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI: PCI Error ===

From: linas () austin ! ibm ! com (linas)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI: PCI Error
Date: Mon, 07 Nov 2005 22:43:38 +0000
Message-ID: <20051107224338.GQ19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 01:37:29PM -0800, Greg KH was heard to remark:
> On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> > +typedef int __bitwise pci_channel_state_t;
> 
> You don't have to use an enum anymore, just use a #define.

Per Linus's remarks about namespace pollution, I've kept the enums.

> > +typedef int __bitwise pers_result_t;
> 
> You should at least keep "pci" at the beginning to make it make
> more sense to people looking at it for the first time.

PCI_ERS and pci_ers, then.

I'm feeling like a blinkin' spammer, splatting out all these emails.

--linas

PCI Error Recovery: header file patch

Change enums and subroutine signatures to be strongly typed, per recent
discussion with GregKH. Also, change the acronym to the more unique, 
less generic "PCI-ERS" "PCI Error Recovery System".

Please apply.

Signed-off-by: Linas Vepstas <linas at austin.ibm.com>

--
Index: linux-2.6.14-mm1/include/linux/pci.h
===================================================================
--- linux-2.6.14-mm1.orig/include/linux/pci.h	2005-11-07 13:55:28.000000000 -0600
+++ linux-2.6.14-mm1/include/linux/pci.h	2005-11-07 16:34:29.790592784 -0600
@@ -82,10 +82,12 @@
  *  the pci device.  If some PCI bus between here and the pci device
  *  has crashed or locked up, this info is reflected here.
  */
+typedef int __bitwise pci_channel_state_t;
+
 enum pci_channel_state {
-	pci_channel_io_normal = 0,	/* I/O channel is in normal state */
-	pci_channel_io_frozen = 1,	/* I/O to channel is blocked */
-	pci_channel_io_perm_failure,	/* PCI card is dead */
+	pci_channel_io_normal = (__force pci_channel_state_t) 1,	/* I/O channel is in normal state */
+	pci_channel_io_frozen = (__force pci_channel_state_t) 2,	/* I/O to channel is blocked */
+	pci_channel_io_perm_failure = (__force pci_channel_state_t) 3,	/* PCI card is dead */
 };
 
 /*
@@ -121,7 +123,7 @@
 					   this is D0-D3, D0 being fully functional,
 					   and D3 being off. */
 
-	enum pci_channel_state error_state;	/* current connectivity state */
+	pci_channel_state_t error_state;	/* current connectivity state */
 	struct	device	dev;		/* Generic device interface */
 
 	/* device is compatible with these IDs */
@@ -245,35 +247,46 @@
 };
 
 /* ---------------------------------------------------------------- */
-/** PCI error recovery infrastructure.  If a PCI device driver provides
+/** PCI Error Recovery System (PCI-ERS).  If a PCI device driver provides
  *  a set fof callbacks in struct pci_error_handlers, then that device driver
  *  will be notified of PCI bus errors, and will be driven to recovery
  *  when an error occurs.
  */
 
-enum pcierr_result {
-	PCIERR_RESULT_NONE = 0,		/* no result/none/not supported in device driver */
-	PCIERR_RESULT_CAN_RECOVER=1,	/* Device driver can recover without slot reset */
-	PCIERR_RESULT_NEED_RESET,	/* Device driver wants slot to be reset. */
-	PCIERR_RESULT_DISCONNECT,	/* Device has completely failed, is unrecoverable */
-	PCIERR_RESULT_RECOVERED,	/* Device driver is fully recovered and operational */
+typedef int __bitwise pci_ers_result_t;
+
+enum pci_ers_result {
+	/* no result/none/not supported in device driver */
+	PCI_ERS_RESULT_NONE = (__force pci_ers_result_t) 1,
+	
+	/* Device driver can recover without slot reset */
+	PCI_ERS_RESULT_CAN_RECOVER = (__force pci_ers_result_t) 2,
+	
+	/* Device driver wants slot to be reset. */
+	PCI_ERS_RESULT_NEED_RESET = (__force pci_ers_result_t) 3,
+	
+	/* Device has completely failed, is unrecoverable */
+	PCI_ERS_RESULT_DISCONNECT = (__force pci_ers_result_t) 4,
+	
+	/* Device driver is fully recovered and operational */
+	PCI_ERS_RESULT_RECOVERED = (__force pci_ers_result_t) 5,
 };
 
 /* PCI bus error event callbacks */
 struct pci_error_handlers
 {
 	/* PCI bus error detected on this device */
-	int (*error_detected)(struct pci_dev *dev,
-	                      enum pci_channel_state error);
+	pci_ers_result_t (*error_detected)(struct pci_dev *dev,
+	                      pci_channel_state_t error);
 
 	/* MMIO has been re-enabled, but not DMA */
-	int (*mmio_enabled)(struct pci_dev *dev);
+	pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev);
 
 	/* PCI Express link has been reset */
-	int (*link_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*link_reset)(struct pci_dev *dev);
 
 	/* PCI slot has been reset */
-	int (*slot_reset)(struct pci_dev *dev);
+	pci_ers_result_t (*slot_reset)(struct pci_dev *dev);
 
 	/* Device driver may resume normal operations */
 	void (*resume)(struct pci_dev *dev);


================================================================================

From: greg () kroah ! com (Greg KH)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI: PCI Error
Date: Mon, 07 Nov 2005 22:53:08 +0000
Message-ID: <20051107225308.GB27787 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 04:43:38PM -0600, linas wrote:
> On Mon, Nov 07, 2005 at 01:37:29PM -0800, Greg KH was heard to remark:
> > On Mon, Nov 07, 2005 at 03:21:28PM -0600, linas wrote:
> > > +typedef int __bitwise pci_channel_state_t;
> > 
> > You don't have to use an enum anymore, just use a #define.
> 
> Per Linus's remarks about namespace pollution, I've kept the enums.

That's fine.

> > > +typedef int __bitwise pers_result_t;
> > 
> > You should at least keep "pci" at the beginning to make it make
> > more sense to people looking at it for the first time.
> 
> PCI_ERS and pci_ers, then.

Sounds good.

> I'm feeling like a blinkin' spammer, splatting out all these emails.

Care to just resend the whole series over again?  No "patch on top of
patch" stuff is needed here.

thanks,

greg k-h


================================================================================

From: linas () austin ! ibm ! com (linas)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI: PCI Error
Date: Mon, 07 Nov 2005 23:19:55 +0000
Message-ID: <20051107231955.GR19593 () austin ! ibm ! com>
--------------------
On Mon, Nov 07, 2005 at 02:53:08PM -0800, Greg KH was heard to remark:
> > I'm feeling like a blinkin' spammer, splatting out all these emails.
> 
> Care to just resend the whole series over again?  No "patch on top of
> patch" stuff is needed here.

So that I can avoid that spammin' feelin' ... 

I'll send patches against -git10, then, so as to start with a clean
slate; unless you wanted something aginst -mm1?

"The whole series": do you want all 42 patches? Or just the seven
discussed today?

-----

In the series-of-42, the staging of some of the patches in the 
middle require simultaneous update to both the drivers/pci/hotplug
and the arch/powerpc/xxx; otherwise, build breaks result. I am
not sure how to handle that: the obvious solution is to split these
up... but that will probably result in a bigger series, and was
not a step I wanted to take unless someone asked...

--linas



================================================================================

From: greg () kroah ! com (Greg KH)
To: linuxppc64-dev
Subject: [PATCH 1/7]: PCI revised (3) [PATCH 16/42]: PCI: PCI Error
Date: Tue, 08 Nov 2005 02:43:45 +0000
Message-ID: <20051108024344.GA538 () kroah ! com>
--------------------
On Mon, Nov 07, 2005 at 05:19:55PM -0600, linas wrote:
> On Mon, Nov 07, 2005 at 02:53:08PM -0800, Greg KH was heard to remark:
> > > I'm feeling like a blinkin' spammer, splatting out all these emails.
> > 
> > Care to just resend the whole series over again?  No "patch on top of
> > patch" stuff is needed here.
> 
> So that I can avoid that spammin' feelin' ... 
> 
> I'll send patches against -git10, then, so as to start with a clean
> slate; unless you wanted something aginst -mm1?

-git10 would be great.

> "The whole series": do you want all 42 patches? Or just the seven
> discussed today?

Just the 7 discussed.  The others should go to their proper maintainers
(which I am not.)

> -----
> 
> In the series-of-42, the staging of some of the patches in the 
> middle require simultaneous update to both the drivers/pci/hotplug
> and the arch/powerpc/xxx; otherwise, build breaks result. I am
> not sure how to handle that: the obvious solution is to split these
> up... but that will probably result in a bigger series, and was
> not a step I wanted to take unless someone asked...

The drivers/pci/hotplug/ stuff only touches the rpaphp driver, right?
If so, I don't have a problem with Paul/Ben sending those on with the
other PPC64 changes to keep everything building properly for your arch.

thanks,

greg k-h


================================================================================


################################################################################

=== Thread: [PATCH 2/2] Add a function to translate the SSA form back to ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] Add a function to translate the SSA form back to
Date: Tue, 22 Nov 2005 02:02:52 +0000
Message-ID: <Pine.LNX.4.64.0511211755540.13959 () g5 ! osdl ! org>
--------------------


On Tue, 22 Nov 2005, Luc Van Oostenryck wrote:
>
> For now, it use a simple method but which introduce a lot more copies
> than necessary. Can be "fixed" later.

Ok, I've applied it and pushed the result out, but I think it's buggy.. 

Do a

	./test-unssa parse.c

and it will loop forever on the "struct_union_enum_specifier()" function 
for me (both on ppc64 and x86).

Doing it in gdb and just doing ^C at some random point gave me a traceback 
of

#0  insert_insn_before (old=0xf7d12cac, new=0xf7afa10c) at unssa.c:45
#1  0x1001ef88 in insert_copy (phisrc=0xf7d12cac, tmp=0xf7b01fa0) at unssa.c:62
#2  0x1001f03c in copy_phi_args (phi=Variable "phi" is not available.) at unssa.c:79
#3  0x1001f0ec in unssa_bb (bb=Variable "bb" is not available.) at unssa.c:93
#4  0x1001f1e4 in unssa (ep=Variable "ep" is not available.) at unssa.c:112
#5  0x10002e50 in output_fn (ep=0xf7d2109c) at test-unssa.c:39
#6  0x10002fb8 in compile (list=Variable "list" is not available.) at test-unssa.c:66
#7  0x10003044 in main (argc=Variable "argc" is not available.) at test-unssa.c:79

but I didn't look any closer into it.

(The same is true of some of the other sparse source files like flow.c and 
linearize.c, and parse.c just happened to be the first one I tested.)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: [PATCH 2/2] Add a function to translate the SSA form back to
Date: Tue, 22 Nov 2005 03:19:32 +0000
Message-ID: <43828E44.50906 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Tue, 22 Nov 2005, Luc Van Oostenryck wrote:
> 
>>For now, it use a simple method but which introduce a lot more copies
>>than necessary. Can be "fixed" later.
> 
> 
> Ok, I've applied it and pushed the result out, but I think it's buggy.. 
> 
> Do a
> 
> 	./test-unssa parse.c
> 
> and it will loop forever on the "struct_union_enum_specifier()" function 
> for me (both on ppc64 and x86).
> 

Grrrr; Silly me, I only tested it on some small function whithout thinking
to test it against the file in the current directory.


It happen at a place where a phisrc is just before the phinode it defines:
	phisrc.1    %phi17 <- %r94     (%r95)
         phi.1       %r95 <- %phi16, %phi17

I think, that there is a bad interaction between my silly insert_insn_before()
and the first loop of unssa_bb(): they use the same instruction list.
It the same as if the some code should have been like this:

	FOR_EACH_PTR(list, p1) {
		FOR_EACH_PTR(list, p2) {
			INSERT_CURRENT(new, p2);
		} END_FOR_EACH_PTR(p2);
	} END_FOR_EACH_PTR(p1);

Is it legal to use the lists like this?
Anyway, I should try to do something less silly in insert_insn_before().
I'm looking at ptrlist.h for doing the insertion directly at the right place.
But I need some sleep first.


Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] Add a function to translate the SSA form back to
Date: Tue, 22 Nov 2005 03:31:02 +0000
Message-ID: <Pine.LNX.4.64.0511211920140.13959 () g5 ! osdl ! org>
--------------------


On Tue, 22 Nov 2005, Luc Van Oostenryck wrote:
> 
> I think, that there is a bad interaction between my silly insert_insn_before()
> and the first loop of unssa_bb(): they use the same instruction list.
> It the same as if the some code should have been like this:
> 
> 	FOR_EACH_PTR(list, p1) {
> 		FOR_EACH_PTR(list, p2) {
> 			INSERT_CURRENT(new, p2);
> 		} END_FOR_EACH_PTR(p2);
> 	} END_FOR_EACH_PTR(p1);
> 
> Is it legal to use the lists like this?

Nope.

INSERT_CURRENT will correctly update the list pointers for the iterator 
that it is active in at that time, but the "outer" iterator will have the 
list that it is iterating over change from underneath it.

Which is ok if you append to the end of the list, but not if you insert to 
before where the outer iterator was (I suspect it will make the outer 
iterator do strange thing if the pointer block it was using is split, but 
even if that doesn't happen, at a minimum it will make the outer iterator 
re-do the same entry, I think).

Those iterators are very useful and powerful, but you have to be _very_ 
careful not to modify a list while something else is walking it.

In fact, deleting entries is even more fragile: a DELETE_CURRENT_PTR() 
will work happily with the current iterator, but you will need to then do 
a final "PACK_PTR_LIST()" on the resulting thing afterwards, because 
otherwise you might end up with empty pointer blocks, which causes 
problems for some of the iterators.

So they are often pretty useful, but in the name of efficiency and easy 
syntax (and they _are_ very efficient) they do have their limitations.

If you do big changes it may be better to just create a new list and 
end up replacing the old one. One of the advantages of the ptrlist thing 
is that you can have the same entry on arbitrarily many lists, since the 
pointer lists don't depend on any "next" pointers embedded in the entries 
themselves.

That makes is much easier to create a whole new list - it doesn't 
invalidate an old list like so many other list implementations do.

> Anyway, I should try to do something less silly in insert_insn_before().
> I'm looking at ptrlist.h for doing the insertion directly at the right place.
> But I need some sleep first.

No problem. It's not like anything is depending on this, which is why I 
had no issues with merging it even though I could see that it didn't do a 
very good job ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] Add a function to translate the SSA form back to normal form. ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH 2/2] Add a function to translate the SSA form back to normal form.
Date: Mon, 21 Nov 2005 23:41:56 +0000
Message-ID: <20051121234156.GB1331 () ralph05 ! lan>
--------------------
For now, it use a simple method but which introduce a lot more copies
than necessary. Can be "fixed" later.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---

diff --git a/.gitignore b/.gitignore
index 6c331ac..a7e5514 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,3 +15,4 @@ check
 compile
 test-linearize
 example
+test-unssa
diff --git a/Makefile b/Makefile
index 714348a..d7c2d09 100644
--- a/Makefile
+++ b/Makefile
@@ -21,7 +21,7 @@ CFLAGS += -DDEBUG
 
 PREFIX=$(HOME)
 BINDIR=$(PREFIX)/bin
-PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example
+PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example test-unssa
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 	  linearize.h bitmap.h ident-list.h compat.h flow.h allocate.h \
@@ -30,7 +30,7 @@ LIB_H=    token.h parse.h lib.h symbol.h
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
-	  flow.o cse.o simplify.o memops.o liveness.o storage.o
+	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
@@ -80,6 +80,9 @@ check: check.o $(LIBS)
 example: example.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+test-unssa: test-unssa.o $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+
 $(LIB_FILE): $(LIB_OBJS)
 	$(AR) rcs $@ $(LIB_OBJS)
 
diff --git a/linearize.h b/linearize.h
index 1626449..5f021a3 100644
--- a/linearize.h
+++ b/linearize.h
@@ -306,6 +306,7 @@ pseudo_t alloc_pseudo(struct instruction
 pseudo_t value_pseudo(long long val);
 
 struct entrypoint *linearize_symbol(struct symbol *sym);
+int unssa(struct entrypoint *ep);
 void show_entry(struct entrypoint *ep);
 const char *show_pseudo(pseudo_t pseudo);
 void show_bb(struct basic_block *bb);
diff --git a/test-unssa.c b/test-unssa.c
new file mode 100644
index 0000000..15ff9d7
--- /dev/null
+++ b/test-unssa.c
@@ -0,0 +1,81 @@
+#include <stdio.h>
+#include <assert.h>
+
+#include "symbol.h"
+#include "expression.h"
+#include "linearize.h"
+#include "flow.h"
+
+
+static void output_bb(struct basic_block *bb, unsigned long generation)
+{
+	struct instruction *insn;
+
+	bb->generation = generation;
+	printf(".L%p\n", bb);
+
+	FOR_EACH_PTR(bb->insns, insn) {
+		if (!insn->bb)
+			continue;
+		printf("\t%s\n", show_instruction(insn));
+	}
+	END_FOR_EACH_PTR(insn);
+
+	printf("\n");
+}
+
+static void output_fn(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+	unsigned long generation = ++bb_generation;
+	struct symbol *sym = ep->name;
+	const char *name = show_ident(sym->ident);
+
+	if (sym->ctype.modifiers & MOD_STATIC)
+		printf("\n\n%s:\n", name);
+	else
+		printf("\n\n.globl %s\n%s:\n", name, name);
+
+	unssa(ep);
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		if (bb->generation == generation)
+			continue;
+		output_bb(bb, generation);
+	}
+	END_FOR_EACH_PTR(bb);
+}
+
+static int output_data(struct symbol *sym)
+{
+	printf("symbol %s:\n", show_ident(sym->ident));
+	printf("\ttype = %d\n", sym->ctype.base_type->type);
+	printf("\tmodif= %lx\n", sym->ctype.modifiers);
+
+	return 0;
+}
+
+static int compile(struct symbol_list *list)
+{
+	struct symbol *sym;
+	FOR_EACH_PTR(list, sym) {
+		struct entrypoint *ep;
+		expand_symbol(sym);
+		ep = linearize_symbol(sym);
+		if (ep)
+			output_fn(ep);
+		else
+			output_data(sym);
+	}
+	END_FOR_EACH_PTR(sym);
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	compile(sparse_initialize(argc, argv));
+	while (*argv)
+		compile(sparse(argv));
+	return 0;
+}
diff --git a/unssa.c b/unssa.c
new file mode 100644
index 0000000..b12cf4b
--- /dev/null
+++ b/unssa.c
@@ -0,0 +1,116 @@
+/*
+ * UnSSA - translate the SSA back to normal form.
+ *
+ * For now it's done by replacing to set of copies:
+ * 1) For each phi-node, replace all their phisrc by copies to a common
+ *    temporary.
+ * 2) Replace all the phi-nodes by copies of the temporaries to the phi-node target.
+ *    This is node to preserve the semantic of the phi-node (they should all "execute"
+ *    simultaneously on entry in the basic block in which they belong).
+ *
+ * This is similar to the "Sreedhar method I" except that the copies to the
+ * temporaries are not placed at the end of the predecessor basic blocks, but
+ * at the place where the phi-node operands are defined (the same place where the
+ * phisrc were present).
+ * Is this a problem? 
+ *
+ * While very simple this method create a lot more copies that really necessary.
+ * Ideally, "Sreedhar method III" should be used:
+ * "Translating Out of Static Single Assignment Form", V. C. Sreedhar, R. D.-C. Ju,
+ * D. M. Gillies and V. Santhanam.  SAS'99, Vol. 1694 of Lecture Notes in Computer
+ * Science, Springer-Verlag, pp. 194-210, 1999.
+ *
+ * Copyright (C) 2005 Luc Van Oostenryck
+ */
+
+#include "lib.h"
+#include "linearize.h"
+#include "allocate.h"
+#include <assert.h>
+
+static struct instruction *alloc_copy_insn(struct instruction *phisrc)
+{
+	struct instruction *insn = __alloc_instruction(0);
+	insn->opcode = OP_COPY;
+	insn->size = phisrc->size;
+	insn->pos = phisrc->pos;
+	return insn;
+}
+
+// Is there a better way to do this ???
+static void insert_insn_before(struct instruction *old, struct instruction *new)
+{
+	struct instruction *insn;
+
+	FOR_EACH_PTR_REVERSE(old->bb->insns, insn) {
+		if (insn == old)
+			INSERT_CURRENT(new, insn);
+	}
+	END_FOR_EACH_PTR_REVERSE(insn);
+}
+
+static void insert_copy(struct instruction *phisrc, pseudo_t tmp)
+{
+	struct instruction *cpy;
+
+	assert(phisrc->opcode == OP_PHISOURCE);
+
+	cpy =  alloc_copy_insn(phisrc);
+	cpy->target = tmp;
+	cpy->src = phisrc->phi_src;
+	cpy->bb = phisrc->bb;
+	insert_insn_before(phisrc, cpy);
+}
+
+static void copy_phi_args(struct instruction *phi, struct pseudo_list **list)
+{
+	pseudo_t tmp, orig = phi->target;
+	pseudo_t phisrc;
+
+	tmp = alloc_pseudo(NULL);
+	tmp->type = orig->type;
+	tmp->def = phi;			// wrongly set to the phi-node !!!
+					// but used later
+	add_pseudo(list, tmp);
+
+	FOR_EACH_PTR(phi->phi_list, phisrc) {
+		if (!phisrc->def)
+			continue;
+		insert_copy(phisrc->def, tmp);
+	} END_FOR_EACH_PTR(phisrc);
+}
+
+static void unssa_bb(struct basic_block *bb)
+{
+	struct pseudo_list *list = NULL;
+	struct pseudo *tmp;
+	struct instruction *insn;
+
+	// copy all the phi nodes arguments to a new temporary pseudo
+	FOR_EACH_PTR(bb->insns, insn) {
+		if (insn->opcode != OP_PHI)
+			continue;
+		copy_phi_args(insn, &list);
+	} END_FOR_EACH_PTR(insn);
+
+	// now replace all the phi nodes themselves by copies of the
+	// temporaries to the phi nodes targets
+	FOR_EACH_PTR(list, tmp) {
+		struct instruction *phi = tmp->def;
+
+		phi->opcode = OP_COPY;
+		phi->src = tmp;
+	} END_FOR_EACH_PTR(tmp);
+	free_ptr_list(&list);
+}
+
+int unssa(struct entrypoint *ep)
+{
+	struct basic_block *bb;
+
+	FOR_EACH_PTR(ep->bbs, bb) {
+		unssa_bb(bb);
+	} END_FOR_EACH_PTR(bb);
+
+	return 0;
+}
---
0.99.9.GIT

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] [RFC] dissect.c ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH 2/2] [RFC] dissect.c
Date: Mon, 19 Dec 2005 17:20:50 +0000
Message-ID: <43A6FD9A.D63247CF () tv-sign ! ru>
--------------------
I completely forgot to re-send this patch, sorry. Nothing was changed,
except now ->r_symdef() is called for NS_STRUCT symbols too, to report
a struct/union definition.

 Makefile       |    9 
 dissect.h      |   40 +++
 dissect.c      |  574 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 test-dissect.c |   95 +++++++++
 4 files changed, 716 insertions(+), 2 deletions(-)

This patch adds dissect.{h,c} files to the sparse distribution.

================================================================================


################################################################################

=== Thread: [PATCH 2/2] remove old comment ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH 2/2] remove old comment
Date: Thu, 24 Nov 2005 01:08:46 +0000
Message-ID: <20051124010846.GB10626 () ralph05 ! lan>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>


---

 unssa.c |    3 ---
 1 files changed, 0 insertions(+), 3 deletions(-)

applies-to: 5a4e7419401206169b893cd9a1c7a5bc2cf419a0
ea4cd6b7d4ae4b4047990371ce67c068158fc63a
diff --git a/unssa.c b/unssa.c
index bb0802d..cd18313 100644
--- a/unssa.c
+++ b/unssa.c
@@ -56,9 +56,6 @@ static void replace_phi_node(struct inst
 	phi->src = tmp;
 
 	// FIXME: free phi->phi_list;
-	// FIXME: remove the %phi from bb->needs
-	// FIXME: add tmp to bb->needs
-	// FIXME: same but more tricky for bb->defines
 }
 
 static void rewrite_phi_bb(struct basic_block *bb)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] sparse: ignore __bounded__ and sentinel attributes ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] sparse: ignore __bounded__ and sentinel attributes
Date: Thu, 01 Dec 2005 13:23:28 +0000
Message-ID: <20051201132328.GB8250 () mipter ! zuzino ! mipt ! ru>
--------------------
OpenBSD has them in system includes.

Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
---

 ident-list.h |    2 ++
 parse.c      |    4 ++++
 2 files changed, 6 insertions(+)

--- sparse-001/ident-list.h
+++ sparse-002/ident-list.h
@@ -65,6 +65,8 @@ IDENT(__malloc__);
 IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
 IDENT(__deprecated__);
 IDENT(__warn_unused_result__);
+IDENT(__bounded__);
+IDENT(sentinel);
 
 /* Preprocessor idents */
 __IDENT(pragma_ident, "__pragma__", 0);
--- sparse-001/parse.c
+++ sparse-002/parse.c
@@ -543,6 +543,10 @@ static const char * handle_attribute(str
 	if (attribute == &model_ident ||
 	    attribute == &__model___ident)
 		return NULL;
+	if (attribute == &__bounded___ident)
+		return NULL;
+	if (attribute == &sentinel_ident)
+		return NULL;
 
 	return "unknown attribute";
 }

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] sparse: OpenBSD port ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] sparse: OpenBSD port
Date: Thu, 01 Dec 2005 13:24:24 +0000
Message-ID: <20051201132424.GC8250 () mipter ! zuzino ! mipt ! ru>
--------------------
* install(1) doesn't have "-v" option. Workaround with echo(1).
* make(1) doesn't like "$<". Mention object file explicitly (hey, only
  9 lines!).
* libc doesn't have strtold(3). Workaround with strtod(3).

Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
---

 Makefile         |   28 +++++++++++++++++-----------
 compat-openbsd.c |   10 ++++++++++
 2 files changed, 27 insertions(+), 11 deletions(-)

--- sparse-002/Makefile
+++ sparse-003/Makefile
@@ -2,7 +2,7 @@
 # Turkey time!
 #
 
-# cygwin linux mingw solaris
+# cygwin linux mingw openbsd solaris
 OS=linux
 
 CC=gcc
@@ -47,7 +47,12 @@ all: $(PROGRAMS) $(SLIB_FILE)
 #		"The better to keep you on your toes, my dear".
 #
 install: check $(SLIB_FILE) bin-dir
-	if test $< -nt $(PREFIX)/bin/sparse ; then install -v $< $(BINDIR)/sparse ; install -v $(SLIB_FILE) $(BINDIR) ; fi
+	@if test check -nt $(PREFIX)/bin/sparse ; then	\
+		echo "install check $(BINDIR)/sparse" ;	\
+		install check $(BINDIR)/sparse ;	\
+		echo "install $(SLIB_FILE) $(BINDIR)";	\
+		install $(SLIB_FILE) $(BINDIR) ;	\
+	fi
 
 bin-dir:
 	@if ! test -d $(PREFIX)/bin; then \
@@ -59,31 +64,31 @@ bin-dir:
 .PHONY: bin-dir
 
 test-lexing: test-lexing.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ test-lexing.o $(LIBS)
 
 test-parsing: test-parsing.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ test-parsing.o $(LIBS)
 
 test-linearize: test-linearize.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ test-linearize.o $(LIBS)
 
 test-sort: test-sort.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ test-sort.o $(LIBS)
 
 compile: compile.o compile-i386.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ compile.o compile-i386.o $(LIBS)
 
 obfuscate: obfuscate.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ obfuscate.o $(LIBS)
 
 check: check.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ check.o $(LIBS)
 
 example: example.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ example.o $(LIBS)
 
 test-unssa: test-unssa.o $(LIBS)
-	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ test-unssa.o $(LIBS)
 
 $(LIB_FILE): $(LIB_OBJS)
 	$(AR) rcs $@ $(LIB_OBJS)
@@ -126,6 +131,7 @@ compat-linux.o: compat/strtold.c compat/
 compat-solaris.o: compat/mmap-blob.c $(LIB_H)
 compat-mingw.o: $(LIB_H)
 compat-cygwin.o: $(LIB_H)
+compat-openbsd.o: compat/mmap-blob.c $(LIB_H)
 
 pre-process.h:
 	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=include`\"" > pre-process.h
--- sparse-002/compat-openbsd.c
+++ sparse-003/compat-openbsd.c
@@ -0,0 +1,10 @@
+#include <stdlib.h>
+
+#include "compat.h"
+#include "lib.h"
+#include "compat/mmap-blob.c"
+
+long double string_to_ld(const char *nptr, char **endptr)
+{
+	return strtod(nptr, endptr);
+}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add __builtin_expect to lib.c to avoid problems with kernel checks ===

From: Mika Kukkonen <mikukkon () gmail ! com>
To: linux-sparse
Subject: [PATCH] Add __builtin_expect to lib.c to avoid problems with kernel checks
Date: Tue, 14 Jun 2005 07:29:02 +0000
Message-ID: <4301cff605061400292f0a16e7 () mail ! gmail ! com>
--------------------
Without following patch I get a bunch of "creative" sparse warnings
for example from
arch/i386/kernel/signal.c

--- sparse.orig/lib.c	2005-06-13 09:31:35.000000000 +0300
+++ sparse/lib.c	2005-06-14 09:05:30.792366776 +0300
@@ -407,6 +407,7 @@
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(int);\n");
 	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+	add_pre_buffer("extern long __builtin_expect(long, long);\n");
 }
 
 void create_builtin_stream(void)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add support for a few gcc intrinsics ===

From: Peter Hagervall <hager () cs ! umu ! se>
To: linux-sparse
Subject: [PATCH] Add support for a few gcc intrinsics
Date: Wed, 23 Nov 2005 21:32:55 +0000
Message-ID: <20051123213255.GA16025 () peppar ! cs ! umu ! se>
--------------------
Give sparse knowledge about __builtin_strncat and __builtin_strncmp.

Signed-off-by: Peter Hagervall <hager@cs.umu.se>
---

diff --git a/lib.c b/lib.c
index 8082011..18a56e1 100644
--- a/lib.c
+++ b/lib.c
@@ -455,8 +455,10 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
 	add_pre_buffer("extern int __builtin_memcmp(const void *, const void *, __SIZE_TYPE__);\n");	
 	add_pre_buffer("extern int __builtin_strcmp(const char *, const char *);\n");
+	add_pre_buffer("extern int __builtin_strncmp(const char *, const char *, __SIZE_TYPE__);\n");
 	add_pre_buffer("extern char *__builtin_strchr(const char *, int);\n");
 	add_pre_buffer("extern char *__builtin_strcpy(char *, const char *);\n");
+	add_pre_buffer("extern char *__builtin_strncat(char *, const char *, __SIZE_TYPE__);\n");
 	add_pre_buffer("extern char *__builtin_strncpy(char *, const char *, __SIZE_TYPE__);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strspn(const char *, const char *);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strcspn(const char *, const char *);\n");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Avoid segfault when code is present after a goto statement ===

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: [PATCH] Avoid segfault when code is present after a goto statement
Date: Sun, 26 Jun 2005 21:51:27 +0000
Message-ID: <42BF235F.1070704 () looxix ! net>
--------------------
Sparse can segfault when code is present after a goto statement.

The problem arise because after a goto statement (same with break and continue) ep->active is set to NULL but processing
of code present after this statement can dereference ep->active (alloc_phi()).

The following piece of code reproduce the problem:
	static int foo(int a)
	{
		goto end;
		return a ? : b;

	end:
		return 0;
	}

 From what I have tested, the whole "a ? : b;" is needed to reproduce the problem,
with absent true part of the conditional and a undefined second part;
but the problem seems very general.

The following patch fix the problem by checking for NULL ep->active, but I suppose
thet there is nicer way to solve this problem.

Luc


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1311,7 +1311,7 @@ static pseudo_t linearize_short_conditio
  	pseudo_t phi1, phi2;
  	int size = type_size(expr->ctype);

-	if (!expr_false)
+	if (!expr_false || !ep->active)
  		return VOID;

  	bb_false = alloc_basic_block(ep, expr_false->pos);
@@ -1337,7 +1337,7 @@ static pseudo_t linearize_conditional(st
  	struct basic_block *bb_true, *bb_false, *merge;
  	int size = type_size(expr->ctype);

-	if (!cond || !expr_true || !expr_false)
+	if (!cond || !expr_true || !expr_false || !ep->active)
  		return VOID;
  	bb_true = alloc_basic_block(ep, expr_true->pos);
  	bb_false = alloc_basic_block(ep, expr_false->pos);

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Avoid segfault when code is present after a goto statement
Date: Sun, 26 Jun 2005 22:50:05 +0000
Message-ID: <Pine.LNX.4.58.0506261548360.19755 () ppc970 ! osdl ! org>
--------------------


Luc, 
 all your patches are whitespace-damaged and none of them will apply. You 
seem to be using some Gecko-based mail-reader, please make sure that line 
flowing etc is turned _off_ when sending patches.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] Avoid segfault when code is present after a goto statement
Date: Sun, 26 Jun 2005 23:31:15 +0000
Message-ID: <20050626233115.GA8582 () ralph05 ! lan>
--------------------
Sparse can segfault when code is present after a goto statement.

The problem arise because after a goto statement (same with break and continue) ep->active is set to NULL but processing
of code present after this statement can dereference ep->active (alloc_phi()).

The following piece of code reproduce the problem:
	static int foo(int a)
	{
		goto end;
		return a ? : b;

	end:
		return 0;
	}


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Avoid segfault when code is present after a goto statement
Date: Mon, 27 Jun 2005 00:24:08 +0000
Message-ID: <Pine.LNX.4.58.0506261723490.19755 () ppc970 ! osdl ! org>
--------------------


On Mon, 27 Jun 2005, Luc Van Oostenryck wrote:
> 
> I will resend them, but I think I will look for a method to automatise this.

Thanks, the new series was good.

Applied,

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Check pointer types for compatibility in evaluate_compare(). ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH] Check pointer types for compatibility in evaluate_compare().
Date: Sat, 08 Jan 2005 19:19:36 +0000
Message-ID: <200501082218.33914.adobriyan () mail ! ru>
--------------------
Gives nice warnings on "if (pointer == 0)" and "if (pointer == 1)".

--- a/evaluate.c	2005-01-08 22:13:33 +02:00
+++ b/evaluate.c	2005-01-08 22:13:33 +02:00
@@ -30,6 +30,8 @@
 
 static struct symbol *degenerate(struct expression *expr);
 static struct symbol *evaluate_symbol(struct symbol *sym);
+static struct symbol *compatible_ptr_type(struct expression *left,
+					  struct expression *right);
 
 static struct symbol *evaluate_symbol_expression(struct expression *expr)
 {
@@ -885,8 +887,8 @@
 
 	/* Pointer types? */
 	if (is_ptr_type(ltype) || is_ptr_type(rtype)) {
-		// FIXME! Check the types for compatibility
-		goto OK;
+		if (compatible_ptr_type(left, right))
+			goto OK;
 	}
 
 	ctype = compatible_integer_binop(&expr->left, &expr->right);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] FAQ: add sparse git repository ===

From: "Michael S. Tsirkin" <mst () mellanox ! co ! il>
To: linux-sparse
Subject: [PATCH] FAQ: add sparse git repository
Date: Thu, 30 Jun 2005 11:02:37 +0000
Message-ID: <20050630110237.GO18642 () mellanox ! co ! il>
--------------------
Hi!
No idea whether the bitkeeper repository is still updated.
Add sparse git repository to the FAQ.

Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>

diff -u sparse-current/FAQ sparse-current-fix/FAQ
--- sparse-current/FAQ	2005-06-30 13:00:09.000000000 +0300
+++ sparse-current-fix/FAQ	2005-06-30 13:56:31.000000000 +0300
@@ -91,5 +91,6 @@
 A.  Mailing list:  linux-sparse@vger.kernel.org
     (email majordomo@vger.kernel.org to subscribe)
 
+    Git repository:  devel/sparse/sparse.git under http://kernel.org/git/
     BitKeeper repository:  bk://sparse.bkbits.net/sparse
 
-- 
MST
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix SIGSEGV on unterminated preprocessor conditional ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] Fix SIGSEGV on unterminated preprocessor conditional
Date: Thu, 19 May 2005 20:33:45 +0000
Message-ID: <20050519203345.GA1879 () ralph05 ! lan>
--------------------
Hi,

sparse segfault with the following input:
---
	// pblm 1: segfault
	// pblm 2: give a bogus warning:
	//      <bad stream>:5:11770: warning: unterminated preprocessor conditional
	
	#ifdef notdef
	oops!
---

The segfault occurs at pre-processor.c:free_preprocessor_line()
because of the extra calls of handle_endif done in do_preproccess()
while trying to do error recoverage.

I propose two patch to fix this.
The first one add a general protection for null token in free_preprocessor_line().
It have the advantage to also give the correct name of the stream.
The second on protect only agaisnt this specific case but the "<bad stream>" remains.
I can't explain the difference of behavior regarding the name of the stream.
I investigate further.

Luc


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

Index: pre-process.c
===================================================================
--- defd4f30824865c785115b1452367dc0187b972c/pre-process.c  (mode:100644)
+++ uncommitted/pre-process.c  (mode:100644)
@@ -730,6 +730,9 @@
 
 static int free_preprocessor_line(struct token *token)
 {
+	if (!token)
+		return 1;
+
 	do {
 		struct token *free = token;
 		token = token->next;


Index: pre-process.c
===================================================================
--- defd4f30824865c785115b1452367dc0187b972c/pre-process.c  (mode:100644)
+++ uncommitted/pre-process.c  (mode:100644)
@@ -1321,6 +1321,8 @@
 		false_nesting--;
 	else
 		true_nesting--;
+	if (!token)
+		return 1;
 	return free_preprocessor_line(token);
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix compile warning in symbol.c ===

From: Mika Kukkonen <mikukkon () gmail ! com>
To: linux-sparse
Subject: [PATCH] Fix compile warning in symbol.c
Date: Tue, 21 Jun 2005 06:29:10 +0000
Message-ID: <4301cff6050620232979ec62a4 () mail ! gmail ! com>
--------------------
This patch adds the same unused int parameter to expand_expect() as in
expand_warning()
to match the required function template. Without this I get the
following warning:

symbol.c:644: warning: initialization from incompatible pointer type

Signed-off-by: Mika Kukkonen <mikukkon@iki.fi>

Index: sparse/symbol.c
===================================================================
--- sparse.orig/symbol.c	2005-06-20 08:41:38.000000000 +0300
+++ sparse/symbol.c	2005-06-21 09:21:26.792137048 +0300
@@ -496,7 +496,7 @@
 	return 1;
 }
 
-static int expand_expect(struct expression *expr)
+static int expand_expect(struct expression *expr, int cost)
 {
 	struct expression *arg = first_ptr_list((struct ptr_list *) expr->args);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix compiler version confusion with linux kernel and sparse ===

From: Mika Kukkonen <mikukkon () gmail ! com>
To: linux-sparse
Subject: [PATCH] Fix compiler version confusion with linux kernel and sparse
Date: Mon, 13 Jun 2005 06:31:33 +0000
Message-ID: <4301cff605061223319ff6615 () mail ! gmail ! com>
--------------------
I wonder why nobody has complained about this before here:

mika@test1:~/repos/linux-2.6$ make C=1
  CHK     include/linux/version.h
  HOSTCC  scripts/basic/fixdep
  HOSTCC  scripts/basic/split-include
  HOSTCC  scripts/basic/docproc
  HOSTCC  scripts/conmakehash
  CC      arch/i386/kernel/asm-offsets.s
  CHK     include/asm-i386/asm_offsets.h
  UPD     include/asm-i386/asm_offsets.h
  CHECK   init/main.c
/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h:54:9: warning:
preprocessor token va_copy redefined
include/linux/compiler-gcc2.h:29:9: this was the original definition

The problem is, that sparse defines __GNUC__ to 2, which causes
include/linux/compiler.h to #include wrong file compiler-gcc2.h which
contains the redefinition above. Now that acme made the version
configurable, how about just using the installed gcc-versions as default?

--- sparse.orig/lib.c    2005-06-06 09:08:11.000000000 +0300
+++ sparse/lib.c    2005-06-13 08:59:19.329067736 +0300
@@ -29,8 +29,8 @@
 #include "target.h"
 
  int verbose, optimize, preprocessing;
-int gcc_major = 2;
-int gcc_minor = 95;
+int gcc_major = __GNUC__;
+int gcc_minor = __GNUC_MINOR__;
 
  struct token *skip_to(struct token *token, int op)
 {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Fix emitting warnings after "too many warnings". ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH] Fix emitting warnings after "too many warnings".
Date: Tue, 18 Jan 2005 19:19:36 +0000
Message-ID: <200501182218.44932.adobriyan () mail ! ru>
--------------------
After "too many warnings" sparse continues to produce the rest of multiline
warnings.

test2.c:106:4: warning: incorrect type in assignment (different base types)
test2.c:106:4:    expected int [signed] a
test2.c:106:4:    got int *<noident>[0]
test2.c:107:4: warning: too many warnings
test2.c:106:4:    expected int [signed] a
test2.c:106:4:    got int *<noident>[0]
test2.c:106:4:    expected int [signed] a
test2.c:106:4:    got int *<noident>[0]

So introduce warning_info(). The only difference from info() is that
warning_info shuts up after certain amount of warnings.

--- 1.1236/evaluate.c	2005-01-18 13:46:08.000000000 +0200
+++ 1.1236-toomany/evaluate.c	2005-01-18 21:25:48.000000000 +0200
@@ -272,12 +272,15 @@ static struct symbol *bad_expr_type(stru
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
-		info(expr->pos, "   left side has type %s", show_typename(expr->left->ctype));
-		info(expr->pos, "   right side has type %s", show_typename(expr->right->ctype));
+		warning_info(expr->pos, "   left side has type %s",
+				show_typename(expr->left->ctype));
+		warning_info(expr->pos, "   right side has type %s",
+				show_typename(expr->right->ctype));
 		break;
 	case EXPR_PREOP:
 	case EXPR_POSTOP:
-		info(expr->pos, "   argument has type %s", show_typename(expr->unop->ctype));
+		warning_info(expr->pos, "   argument has type %s",
+				show_typename(expr->unop->ctype));
 		break;
 	default:
 		break;
@@ -1086,8 +1089,8 @@ static int compatible_assignment_types(s
 	}
 
 	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
-	info(expr->pos, "   expected %s", show_typename(target));
-	info(expr->pos, "   got %s", show_typename(source));
+	warning_info(expr->pos, "   expected %s", show_typename(target));
+	warning_info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
 	return 0;
 Cast:
--- 1.1236/lib.c	2005-01-18 13:45:54.000000000 +0200
+++ 1.1236-toomany/lib.c	2005-01-18 21:30:36.000000000 +0200
@@ -302,12 +302,13 @@ void info(struct position pos, const cha
 	va_end(args);
 }
 
+static int warnings_nr = 0;
+
 void warning(struct position pos, const char * fmt, ...)
 {
-	static int warnings = 0;
 	va_list args;
 
-	if (warnings > 100) {
+	if (warnings_nr > 100) {
 		static int once = 0;
 		if (once)
 			return;
@@ -318,9 +319,21 @@ void warning(struct position pos, const 
 	va_start(args, fmt);
 	do_warn("warning: ", pos, fmt, args);
 	va_end(args);
-	warnings++;
+	warnings_nr++;
 }	
 
+void warning_info(struct position pos, const char *fmt, ...)
+{
+	va_list args;
+
+	if (warnings_nr > 100 + 1)
+		return;
+
+	va_start(args, fmt);
+	do_warn("", pos, fmt, args);
+	va_end(args);
+}
+
 void error(struct position pos, const char * fmt, ...)
 {
 	static int errors = 0;
--- 1.1236/lib.h	2005-01-18 13:45:54.000000000 +0200
+++ 1.1236-toomany/lib.h	2005-01-18 21:11:08.000000000 +0200
@@ -71,6 +71,7 @@ struct token *expect(struct token *, int
 extern void die(const char *, ...) FORMAT_ATTR(1);
 extern void info(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void warning(struct position, const char *, ...) FORMAT_ATTR(2);
+extern void warning_info(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void error(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void error_die(struct position, const char *, ...) FORMAT_ATTR(2);
 #undef FORMAT_ATTR
--- 1.1236/pre-process.c	2005-01-18 13:45:54.000000000 +0200
+++ 1.1236-toomany/pre-process.c	2005-01-18 21:41:25.000000000 +0200
@@ -1044,7 +1044,8 @@ static int do_handle_define(struct strea
 				return 1;
 			warning(left->pos, "preprocessor token %.*s redefined",
 					name->len, name->name);
-			info(sym->pos, "this was the original definition");
+			warning_info(sym->pos,
+					"this was the original definition");
 			sym->expansion = expansion;
 			sym->arglist = arglist;
 		}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Ignore --param flag ===

From: Adam Jackson <ajax () nwnk ! net>
To: linux-sparse
Subject: [PATCH] Ignore --param flag
Date: Tue, 20 Sep 2005 03:36:58 +0000
Message-ID: <200509192337.04470.ajax () nwnk ! net>
--------------------
--nextPart31326209.nqlqJ0N449
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline

Ignore the --param option to gcc.  Without this, sparse will choke on fbmmx=
=2Ec=20
in Xorg because it treats the word after --param as the filename.

=2D ajax

=2D-- git-snapshot-20050920/lib.c.old 2005-09-15 13:42:45.000000000 -0400
+++ git-snapshot-20050920/lib.c 2005-09-19 23:19:30.000000000 -0400
@@ -388,6 +388,14 @@ static char **handle_dirafter(char *arg,
  return next;
 }
=20
+static char **handle_dashparam(char *arg, char **next)
+{
+ if (!strcmp (arg, "-param") && *next)
+  return next + 1;
+ else
+  return NULL; /* bogus */
+}
+
 struct switches {
  const char *name;
  char **(*fn)(char *, char**);
@@ -398,6 +406,7 @@ char **handle_switch(char *arg, char **n
  static struct switches cmd[] =3D {
   { "nostdinc", handle_nostdinc },
   { "dirafter", handle_dirafter },
+  { "-param",   handle_dashparam },
   { NULL, NULL }
  };
  struct switches *s;

--nextPart31326209.nqlqJ0N449
Content-Type: application/pgp-signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.4 (GNU/Linux)

iD8DBQBDL4PgW4otUKDs0NMRAsnaAJ0VKuU0uq/PjGzFfXY5Kx1rQGDJwACff/Jn
NyCnxZpm+LNB5qnrmOHUR+o=
=A44K
-----END PGP SIGNATURE-----

--nextPart31326209.nqlqJ0N449--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Adam Jackson <ajax () nwnk ! net>
To: linux-sparse
Subject: Re: [PATCH] Ignore --param flag
Date: Tue, 20 Sep 2005 03:55:35 +0000
Message-ID: <200509192355.35887.ajax () nwnk ! net>
--------------------
--Boundary-00=_3g4LDEgc94pkz6T
Content-Type: text/plain;
  charset="iso-8859-6"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Monday 19 September 2005 23:36, you wrote:
> Ignore the --param option to gcc.  Without this, sparse will choke on
> fbmmx.c in Xorg because it treats the word after --param as the filename.

Once more in the attachment, maybe this time kmail won't mangle the 
whitespace.

- ajax

--Boundary-00=_3g4LDEgc94pkz6T
Content-Type: text/x-diff;
  charset="iso-8859-6";
  name="sparse-dashparam-1.patch"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline;
	filename="sparse-dashparam-1.patch"

--- git-snapshot-20050920/lib.c.old	2005-09-15 13:42:45.000000000 -0400
+++ git-snapshot-20050920/lib.c	2005-09-19 23:19:30.000000000 -0400
@@ -388,6 +388,14 @@ static char **handle_dirafter(char *arg,
 	return next;
 }
 
+static char **handle_dashparam(char *arg, char **next)
+{
+	if (!strcmp (arg, "-param") && *next)
+		return next + 1;
+	else
+		return NULL; /* bogus */
+}
+
 struct switches {
 	const char *name;
 	char **(*fn)(char *, char**);
@@ -398,6 +406,7 @@ char **handle_switch(char *arg, char **n
 	static struct switches cmd[] = {
 		{ "nostdinc", handle_nostdinc },
 		{ "dirafter", handle_dirafter },
+		{ "-param",   handle_dashparam },
 		{ NULL, NULL }
 	};
 	struct switches *s;

--Boundary-00=_3g4LDEgc94pkz6T--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Kept the alignment info for memops. ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] Kept the alignment info for memops.
Date: Mon, 28 Nov 2005 23:38:21 +0000
Message-ID: <20051128233821.GA1073 () g5 ! pc ! home>
--------------------
linearize() generate the same code for loads and stores via pointers
of structure of the same size but different alignment, because the
alignment info is simply not stored in the instruction.

This patch augment the instruction structure for memops to keep the
alignment info along the size.

PS. I find that the format I've used to show these instruction is ugly
but since its only purpose is for debuging ...


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---

 linearize.c |    4 ++++
 linearize.h |    1 +
 2 files changed, 5 insertions(+), 0 deletions(-)

applies-to: 81f6482469756e71fd9ae52565c60912b16fce7a
d338c7e729d9b4bee913e0cde4623cc9a3814564
diff --git a/linearize.c b/linearize.c
index 29d76cf..292a9ed 100644
--- a/linearize.c
+++ b/linearize.c
@@ -283,6 +283,8 @@ const char *show_instruction(struct inst
 			buf += sprintf(buf, "%s", op);
 		if (insn->size)
 			buf += sprintf(buf, ".%d", insn->size);
+		if (opcode == OP_LOAD || opcode == OP_STORE)
+			buf += sprintf(buf, ".%d", insn->alignment);
 		memset(buf, ' ', 20);
 		buf++;
 	}
@@ -905,6 +907,7 @@ static pseudo_t add_load(struct entrypoi
 
 	insn->target = new;
 	insn->offset = ad->offset;
+	insn->alignment = ad->alignment;
 	use_pseudo(ad->address, &insn->src);
 	add_one_insn(ep, insn);
 	return new;
@@ -917,6 +920,7 @@ static void add_store(struct entrypoint 
 	if (bb_reachable(bb)) {
 		struct instruction *store = alloc_typed_instruction(OP_STORE, ad->source_type);
 		store->offset = ad->offset;
+		store->alignment = ad->alignment;
 		use_pseudo(value, &store->target);
 		use_pseudo(ad->address, &store->src);
 		add_one_insn(ep, store);
diff --git a/linearize.h b/linearize.h
index 5f021a3..3f678fa 100644
--- a/linearize.h
+++ b/linearize.h
@@ -83,6 +83,7 @@ struct instruction {
 			pseudo_t src;
 			struct symbol *orig_type;	/* casts */
 			unsigned int offset;		/* memops */
+			unsigned int alignment;
 		};
 		struct /* binops and sel */ {
 			pseudo_t src1, src2, src3;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Lets 'test-unssa -v' give some info about the liveness of the pseudos. ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] Lets 'test-unssa -v' give some info about the liveness of the pseudos.
Date: Wed, 23 Nov 2005 22:56:43 +0000
Message-ID: <20051123225642.GB1267 () ralph05 ! lan>
--------------------

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---

 test-unssa.c |   29 +++++++++++++++++++++++++++++
 1 files changed, 29 insertions(+), 0 deletions(-)

applies-to: 8863131167d09ef70b60340e0743f4bf4516c3fa
b499a633c3a2cc56002b3ca69abb974a2526e31d
diff --git a/test-unssa.c b/test-unssa.c
index 15ff9d7..7613356 100644
--- a/test-unssa.c
+++ b/test-unssa.c
@@ -1,5 +1,6 @@
 #include <stdio.h>
 #include <assert.h>
+#include <stdarg.h>
 
 #include "symbol.h"
 #include "expression.h"
@@ -7,6 +8,29 @@
 #include "flow.h"
 
 
+static void output_comment(void *state, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
+static void output_comment(void *state, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!verbose)
+		return;
+	va_start(args, fmt);
+	vprintf(fmt, args);
+	va_end(args);
+}
+
+static void show_pseudo_list(const char *msg, struct pseudo_list *lst)
+{
+	pseudo_t p;
+
+	if (!verbose)
+		return;
+	FOR_EACH_PTR(lst, p) {
+		output_comment(NULL, "\t# %s: %s\n", msg, show_pseudo(p));
+	} END_FOR_EACH_PTR(p);
+}
+
 static void output_bb(struct basic_block *bb, unsigned long generation)
 {
 	struct instruction *insn;
@@ -14,6 +38,8 @@ static void output_bb(struct basic_block
 	bb->generation = generation;
 	printf(".L%p\n", bb);
 
+	show_pseudo_list("needs", bb->needs);
+
 	FOR_EACH_PTR(bb->insns, insn) {
 		if (!insn->bb)
 			continue;
@@ -21,6 +47,7 @@ static void output_bb(struct basic_block
 	}
 	END_FOR_EACH_PTR(insn);
 
+	show_pseudo_list("defines", bb->defines);
 	printf("\n");
 }
 
@@ -38,6 +65,8 @@ static void output_fn(struct entrypoint 
 
 	unssa(ep);
 
+	output_comment(NULL, "\t# number of arguments: %d\n", ptr_list_size((struct ptr_list *)ep->entry->bb->needs));
+
 	FOR_EACH_PTR(ep->bbs, bb) {
 		if (bb->generation == generation)
 			continue;
---
0.99.9.GIT
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: segfault on non-ANSI function-like declaration ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Re: segfault on non-ANSI function-like declaration
Date: Tue, 17 May 2005 19:44:56 +0000
Message-ID: <20050517194456.GA12538 () 64m ! dyndns ! org>
--------------------
On Tue, May 17, 2005 at 11:01:43PM +0200, Luc Van Oostenryck wrote:
> Hi,
> 
> sparse segfault on non-ANSI function-like declarations/casts like
> 	void (*foo)();          // OK
> 	void (*bar)() = 0;      // segfault
> 
> The problem come from the warning emited by parameter_type_list()
> which don't have a valid pointer for the ident of the "function".
> 
> NB. I don't think that the following patch is the right solution,
>     but at least it avoid the segfault.
> 
> -- 
> Luc Van Oostenryck
> 
> 
> Index: parse.c
> ===================================================================
> --- f748cf9add41be8404ed8bf7eda43ba28314483b/parse.c  (mode:100644)
> +++ uncommitted/parse.c  (mode:100644)
> @@ -1355,7 +1355,7 @@
>  		// No warning for "void oink ();"
>  		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
>  		if (!match_op(token->next, ';'))
> -			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
> +			warning(token->pos, "non-ANSI function declaration of function '%s'", p ? show_ident(*p) : NULL);
>  		return token;
>  	}
>

This problem has been discuss on the list before. Here is my version of
the fix, which print out the function pointer which causing the problem
instead of a "<noident>". May be more close to what it originally mean
to do.

Chris

  
This patch will try to avoid crash of using *p while print out
the function pointer which cause the error.

Signed-Off-by: Christopher Li<sparse@chrisli.org>


Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2005-04-11 16:15:52.000000000 -0400
+++ sparse/parse.c	2005-04-15 14:11:12.000000000 -0400
@@ -762,6 +762,7 @@
 static struct token *direct_declarator(struct token *token, struct symbol *decl, struct ident **p)
 {
 	struct ctype *ctype = &decl->ctype;
+	struct ident **ident = p;
 
 	if (p && token_type(token) == TOKEN_IDENT) {
 		*p = token->ident;
@@ -797,7 +798,7 @@
 			}
 
 			sym = indirect(token->pos, ctype, SYM_FN);
-			token = parameter_type_list(next, sym, p);
+			token = parameter_type_list(next, sym, ident);
 			token = expect(token, ')', "in function declarator");
 			continue;
 		}
@@ -1355,7 +1356,7 @@
 		// No warning for "void oink ();"
 		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
 		if (!match_op(token->next, ';'))
-			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
+			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(p ? *p : NULL));
 		return token;
 	}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: sparse and gcc-4.0.0 testsuite: results. ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] Re: sparse and gcc-4.0.0 testsuite: results.
Date: Mon, 23 May 2005 19:53:35 +0000
Message-ID: <429234BF.2000303 () looxix ! net>
--------------------
Alexey Dobriyan wrote:
> Tarball attached. Trimmed down testcases (C only) inline.
> 
> This time I ran sparse on all files (Ada, C++, C, Fortran, shell scripts,
> other random crap) ;-).
> 
> Segmentation faults
> ============================================================================
> ...
> --------------------------------------
> gcc.dg/asm-wide-1.c
> 
> void f(void)
> {
> 	int a;
> 	asm ("foo" : L"=g" (a));
> }


Here is two patches that avoid the segfault for some (but not alls) "bad asm" statement
like the one here above.

Luc



Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

Index: linearize.c
===================================================================
--- defd4f30824865c785115b1452367dc0187b972c/linearize.c  (mode:100644)
+++ uncommitted/linearize.c  (mode:100644)
@@ -1730,7 +1730,7 @@

  		case 1:	/* Constraint */
  			state = 2;
-			constraint = expr->string->data;
+			constraint = expr ? expr->string->data : "";
  			continue;

  		case 2:


Index: linearize.c
===================================================================
--- defd4f30824865c785115b1452367dc0187b972c/linearize.c  (mode:100644)
+++ uncommitted/linearize.c  (mode:100644)
@@ -1662,7 +1662,7 @@
  	pseudo_t pseudo = alloc_pseudo(insn);
  	struct asm_constraint *rule;

-	if (!linearize_address_gen(ep, expr, &ad))
+	if (!expr || !linearize_address_gen(ep, expr, &ad))
  		return;
  	linearize_store_gen(ep, pseudo, &ad);
  	finish_address_gen(ep, &ad);

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Rewrite command line parsing. ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH] Rewrite command line parsing.
Date: Mon, 17 Jan 2005 23:43:28 +0000
Message-ID: <200501180235.32679.adobriyan () mail ! ru>
--------------------
* Use getopt_long_only().
* Mark handle_* functions as static.
* Support for easy adding new command line options rests in place.

--- 1.1233/lib.c	2005-01-16 01:09:02.000000000 +0200
+++ 1.1233-getopt/lib.c	2005-01-18 02:26:45.000000000 +0200
@@ -15,6 +15,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <assert.h>
+#include <getopt.h>
 
 #include <sys/types.h>
 
@@ -389,218 +390,81 @@ void add_pre_buffer(const char *fmt, ...
 	va_end(args);
 }
 
-char **handle_switch_D(char *arg, char **next)
+static void handle_switch_D(char *name)
 {
-	const char *name = arg + 1;
-	const char *value = "1";
-	for (;;) {
-		char c;
-		c = *++arg;
-		if (!c)
-			break;
-		if (isspace((unsigned char)c) || c == '=') {
-			*arg = '\0';
-			value = arg + 1;
-			break;
-		}
-	}
-	add_pre_buffer("#define %s %s\n", name, value);
-	return next;
-}
+	char *p, *value, one[2] = {'1', '\0'};
 
-char **handle_switch_E(char *arg, char **next)
-{
-	preprocess_only = 1;
-	return next;
+	p = strchr(name, '=');
+	if (p) {
+		*p = '\0';
+		value = p + 1;
+	} else
+		value = &one[0];
+	add_pre_buffer("#define %s %s\n", name, value);
 }
 
-char **handle_switch_v(char *arg, char **next)
+static void handle_switch_I(char *path)
 {
-	do {
-		verbose++;
-	} while (*++arg == 'v');
-	return next;
+	/* Explaining '-I-' with a google search:
+	 *
+	 *	"Specifying -I after -I- searches for #include directories.
+	 *	 If -I- is specified before, it searches for #include "file"
+	 *	 and not #include ."
+	 *
+	 * Which didn't explain it at all to me. Maybe somebody else can
+	 * explain it properly. We ignore it for now.
+	 */
+	add_pre_buffer("#add_include \"%s/\"\n", path);
 }
 
-char **handle_switch_I(char *arg, char **next)
+static void handle_include(char *name)
 {
-	char *path = arg+1;
+	int fd = open(name, O_RDONLY);
 
-	switch (arg[1]) {
-	case '-':
-		/* Explaining '-I-' with a google search:
-		 *
-		 *	"Specifying -I after -I- searches for #include directories.
-		 *	 If -I- is specified before, it searches for #include "file"
-		 *	 and not #include ."
-		 *
-		 * Which didn't explain it at all to me. Maybe somebody else can
-		 * explain it properly. We ignore it for now.
-		 */
-		return next;
+	if (fd < 0)
+		perror(name);
 
-	case '\0':	/* Plain "-I" */
-		path = *++next;
-		if (!path)
-			die("missing argument for -I option");
-		/* Fallthrough */
-	default:
-		add_pre_buffer("#add_include \"%s/\"\n", path);
-	}
-	return next;
+	include_fd = fd;
+	include = name;
 }
 
-char **handle_switch_i(char *arg, char **next)
+static void handle_isystem(char *path)
 {
-	if (*next && !strcmp(arg, "include")) {
-		char *name = *++next;
-		int fd = open(name, O_RDONLY);
-
-		include_fd = fd;
-		include = name;
-		if (fd < 0)
-			perror(name);
-	}
-	else if (*next && !strcmp(arg, "isystem")) {
-		char *path = *++next;
-		if (!path)
-			die("missing argument for -isystem option");
-		add_pre_buffer("#add_include \"%s/\"\n", path);
-	}
-	return next;
+	add_pre_buffer("#add_include \"%s/\"\n", path);
 }
 
-char **handle_switch_M(char *arg, char **next)
+static void handle_MF(char *file)
 {
-	if (!strcmp(arg, "MF") || !strcmp(arg,"MQ") || !strcmp(arg,"MT")) {
-		if (!*next)
-			die("missing argument for -%s option", arg);
-		return next + 1;
-	}
-	return next;
 }
 
-char **handle_switch_m(char *arg, char **next)
+static void handle_MT(char *target)
 {
-	if (!strcmp(arg, "m64")) {
-		bits_in_long = 64;
-		max_int_alignment = 8;
-		bits_in_pointer = 64;
-		pointer_alignment = 8;
-	}
-	return next;
 }
 
-char **handle_switch_o(char *arg, char **next)
+static void handle_MQ(char *target)
 {
-	if (!strcmp (arg, "o") && *next)
-		return next + 1; // "-o foo"
-	else
-		return next;     // "-ofoo" or (bogus) terminal "-o"
 }
 
-const struct warning {
-	const char *name;
-	int *flag;
-} warnings[] = {
-	{ "ptr-subtraction-blows", &Wptr_subtraction_blows },
-	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
-	{ "undef", &Wundefined_preprocessor },
-	{ "bitwise", &Wbitwise },
-	{ "typesign", &Wtypesign },
-	{ "context", &Wcontext },
-};
-
-
-char **handle_switch_W(char *arg, char **next)
+static void handle_m64(void)
 {
-	int no = 0;
-	char *p = arg + 1;
-	unsigned i;
-
-	// Prefixes "no" and "no-" mean to turn warning off.
-	if (p[0] == 'n' && p[1] == 'o') {
-		p += 2;
-		if (p[0] == '-')
-			p++;
-		no = 1;
-	}
-
-	for (i = 0; i < sizeof(warnings) / sizeof(warnings[0]); i++) {
-		if (!strcmp(p,warnings[i].name)) {
-			*warnings[i].flag = !no;
-			return next;
-		}
-	}
-
-	// Unknown.
-	return next;
+	bits_in_long = 64;
+	max_int_alignment = 8;
+	bits_in_pointer = 64;
+	pointer_alignment = 8;
 }
 
-char **handle_switch_U(char *arg, char **next)
+static void handle_switch_o(char *outfile)
 {
-	const char *name = arg + 1;
-	add_pre_buffer ("#undef %s\n", name);
-	return next;
 }
 
-char **handle_switch_O(char *arg, char **next)
+static void handle_switch_U(char *name)
 {
-	int level = 1;
-	if (arg[1] >= '0' && arg[1] <= '9')
-		level = arg[1] - '0';
-	optimize = level;
-	return next;
+	add_pre_buffer("#undef %s\n", name);
 }
 
-char **handle_nostdinc(char *arg, char **next)
+static void handle_nostdinc(void)
 {
 	add_pre_buffer("#nostdinc\n");
-	return next;
-}
-
-struct switches {
-	const char *name;
-	char **(*fn)(char *, char**);
-};
-
-char **handle_switch(char *arg, char **next)
-{
-	char **rc = next;
-	static struct switches cmd[] = {
-		{ "nostdinc", handle_nostdinc },
-		{ NULL, NULL }
-	};
-	struct switches *s;
-
-	switch (*arg) {
-	case 'D': rc = handle_switch_D(arg, next); break;
-	case 'E': rc = handle_switch_E(arg, next); break;
-	case 'I': rc = handle_switch_I(arg, next); break;
-	case 'i': rc = handle_switch_i(arg, next); break;
-	case 'M': rc = handle_switch_M(arg, next); break;
-	case 'm': rc = handle_switch_m(arg, next); break;
-	case 'o': rc = handle_switch_o(arg, next); break;
-	case 'U': rc = handle_switch_U(arg, next); break;
-	case 'v': rc = handle_switch_v(arg, next); break;
-	case 'W': rc = handle_switch_W(arg, next); break;
-	case 'O': rc = handle_switch_O(arg, next); break;
-	default:
-		break;
-	}
-
-	s = cmd;
-	while (s->name) {
-		if (!strcmp(s->name, arg))
-			return s->fn(arg, next);
-		s++;
-	}
-
-	/*
-	 * Ignore unknown command line options:
-	 * they're probably gcc switches
-	 */
-	return rc;
 }
 
 void declare_builtin_functions(void)
@@ -644,27 +508,93 @@ static void do_predefined(char *filename
 	add_pre_buffer("#define __TIME__ \"??:??:??\"\n");
 }
 
+static struct option long_options[] = {
+	{"nostdinc", no_argument, NULL, 0x100},
+	{"include", required_argument, NULL, 0x101},
+	{"isystem", required_argument, NULL, 0x102},
+	{"MF", required_argument, NULL, 0x103},
+	{"MT", required_argument, NULL, 0x104},
+	{"MQ", required_argument, NULL, 0x105},
+	{"m64", no_argument, NULL, 0x106},
+	{"O0", no_argument, &optimize, 0},
+	{"O", no_argument, &optimize, 1},
+	{"O1", no_argument, &optimize, 1},
+	{"O2", no_argument, &optimize, 2},
+	{"O3", no_argument, &optimize, 3},
+	{"E", no_argument, &preprocess_only, 1},
+	{"v", no_argument, &verbose, 1},
+	{"Wcontext", no_argument, &Wcontext, 1},
+	{"Wnocontext", no_argument, &Wcontext, 0},
+	{"Wno-context", no_argument, &Wcontext, 0},
+	{"Wtypesign", no_argument, &Wtypesign, 1},
+	{"Wnotypesign", no_argument, &Wtypesign, 0},
+	{"Wno-typesign", no_argument, &Wtypesign, 0},
+	{"Wbitwise", no_argument, &Wbitwise, 1},
+	{"Wnobitwise", no_argument, &Wbitwise, 0},
+	{"Wno-bitwise", no_argument, &Wbitwise, 0},
+	{"Wundef", no_argument, &Wundefined_preprocessor, 1},
+	{"Wnoundef", no_argument, &Wundefined_preprocessor, 0},
+	{"Wno-undef", no_argument, &Wundefined_preprocessor, 0},
+	{"Wdefault-bitfield-sign", no_argument, &Wdefault_bitfield_sign, 1},
+	{"Wnodefault-bitfield-sign", no_argument, &Wdefault_bitfield_sign, 0},
+	{"Wno-default-bitfield-sign", no_argument, &Wdefault_bitfield_sign, 0},
+	{"Wptr-subtraction-blows", no_argument, &Wptr_subtraction_blows, 1},
+	{"Wnoptr-subtraction-blows", no_argument, &Wptr_subtraction_blows, 0},
+	{"Wno-ptr-subtraction-blows", no_argument, &Wptr_subtraction_blows, 0},
+	{NULL, 0, NULL, 0}
+};
+
 struct symbol_list *sparse(int argc, char **argv)
 {
 	int fd;
-	char *filename = NULL, **args;
+	char *filename = NULL;
 	struct token *token;
+	int c;
 
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
 
-	args = argv;
-	for (;;) {
-		char *arg = *++args;
-		if (!arg)
-			break;
-		if (arg[0] == '-' && arg[1]) {
-			args = handle_switch(arg+1, args);
-			continue;
+	while ((c = getopt_long_only(argc, argv, "D:I:o:U:",
+					long_options, NULL)) != -1)
+		switch (c) {
+		case 'D':
+			handle_switch_D(optarg);
+			break;
+		case 'I':
+			handle_switch_I(optarg);
+			break;
+		case 'o':
+			handle_switch_o(optarg);
+			break;
+		case 'U':
+			handle_switch_U(optarg);
+			break;
+		case 0x100:
+			handle_nostdinc();
+			break;
+		case 0x101:
+			handle_include(optarg);
+			break;
+		case 0x102:
+			handle_isystem(optarg);
+			break;
+		case 0x103:
+			handle_MF(optarg);
+			break;
+		case 0x104:
+			handle_MT(optarg);
+			break;
+		case 0x105:
+			handle_MQ(optarg);
+			break;
+		case 0x106:
+			handle_m64();
+			break;
+		default:
+			break;
 		}
-		filename = arg;
-	}
 
+	filename = argv[optind];
 	if (!filename)
 		die("no input files given");
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Rewrite of unssa(). ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Rewrite of unssa().
Date: Wed, 23 Nov 2005 03:08:20 +0000
Message-ID: <Pine.LNX.4.64.0511221850040.13959 () g5 ! osdl ! org>
--------------------


On Wed, 23 Nov 2005, Luc Van Oostenryck wrote:
>
> This is almost a total rewrite of unssa().
> It work now in two passs:

Thanks, this works better for me.

I made some trivial changes to the example compiler to not handle phi 
stuff itself, but just use your unssa code instead.

It gets really confused by the copy operations, since it kind of expects 
things to be in SSA form, so it effectively loses a few copies ("hey, I 
already _have_ that pseudo in a register"), but it's kind of fun to see 
how it generates some messed-up code.

I'm sure it's messed up in other ways too, but hey, it was a quick hack.

(One thing to also look out for when looking at the "code" generated by 
the example compiler: right now it actually thinks that it should push the 
arguments on the stack on calls, but then on function entry it thinks the 
arguments come in registers. That's actually on purpose, because that way 
it tests both calling conventions at once ;)

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: Re: [PATCH] Rewrite of unssa().
Date: Wed, 23 Nov 2005 22:52:11 +0000
Message-ID: <20051123225211.GA1267 () ralph05 ! lan>
--------------------
On Tue, Nov 22, 2005 at 07:08:20PM -0800, Linus Torvalds wrote:
> 
> On Wed, 23 Nov 2005, Luc Van Oostenryck wrote:
> >
> > This is almost a total rewrite of unssa().
> 
> Thanks, this works better for me.
> 

There are a few crashes when used on the kernel sources (4 with my .config),
but it happen also when test-linearize is used on the same files:
	drivers/cdrom/cdrom.c
	drivers/char/vt_ioctl.c
	drivers/scsi/sg.c
	arch/i386/lib/usercopy.c

One place where it may not work correctly is where a phi node is
present in a bb but not at it's beginning. I must check.

> I made some trivial changes to the example compiler to not handle phi 
> stuff itself, but just use your unssa code instead.
> 
> It gets really confused by the copy operations, since it kind of expects 
> things to be in SSA form, so it effectively loses a few copies ("hey, I 
> already _have_ that pseudo in a register"), but it's kind of fun to see 
> how it generates some messed-up code.

Yes, and the lost liveness information certainly doesn't help.
I'm working on it.

> I'm sure it's messed up in other ways too, but hey, it was a quick hack.
> 
> (One thing to also look out for when looking at the "code" generated by 
> the example compiler: right now it actually thinks that it should push the 
> arguments on the stack on calls, but then on function entry it thinks the 
> arguments come in registers. That's actually on purpose, because that way 
> it tests both calling conventions at once ;)

I was a bit perturbated by this the first time I played with it ;-)


Luc
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Sparse: fix the setting of __SIZE_TYPE__ in lib.c ===

From: Mika Kukkonen <mikukkon () iki ! fi>
To: linux-sparse
Subject: [PATCH] Sparse: fix the setting of __SIZE_TYPE__ in lib.c
Date: Sat, 17 Dec 2005 20:40:49 +0000
Message-ID: <4301cff60512171240v3436593ei44e662a82893cc0a () mail ! gmail ! com>
--------------------
------=_Part_22916_7462055.1134852049048
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline

I was doing some janitorial work on kernel lib/string.c (patch to
kernel mailing list coming later), and in particular removed the
"#undef memcmp" line. This caused sparse to barf:

mika@desktop:~/work/repos/git/linux-2.6$ make C=3D1 lib
  CHK     include/linux/version.h
  CHECK   lib/string.c
lib/string.c:519:5: error: symbol '__builtin_memcmp' redeclared with
different type (originally declared at builtin:37) - incompatible
argument 3 (different type sizes)
  CC      lib/string.o

Does the attached patch make sense?

--MiKu

------=_Part_22916_7462055.1134852049048
Content-Type: application/octet-stream; name=fix-size_type-setting.patch
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename="fix-size_type-setting.patch"

---

 lib.c |    9 ++++++---
 1 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/lib.c b/lib.c
index d765d75..d80bc28 100644
--- a/lib.c
+++ b/lib.c
@@ -479,10 +479,13 @@ void create_builtin_stream(void)
 
 	// gcc defines __SIZE_TYPE__ to be size_t.  For linux/i86 and
 	// solaris/sparc that is really "unsigned int" and for linux/x86_64
-	// it is "long unsigned int".  In either case we can probably
-	// get away with this.  We need the #ifndef as cgcc will define
+	// it is "long unsigned int". We need the #ifndef as cgcc will define
 	// the right __SIZE_TYPE__.
-	add_pre_buffer("#weak_define __SIZE_TYPE__ long unsigned int\n");
+	if (sizeof(size_t) == sizeof(unsigned int))
+		add_pre_buffer("#weak_define __SIZE_TYPE__ unsigned int\n");
+	else
+		add_pre_buffer("#weak_define __SIZE_TYPE__ long unsigned int\n");
+
 	add_pre_buffer("#weak_define __STDC__ 1\n");
 
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");



------=_Part_22916_7462055.1134852049048--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Sparse: fix the setting of __SIZE_TYPE__ in lib.c
Date: Sat, 17 Dec 2005 20:56:23 +0000
Message-ID: <Pine.LNX.4.64.0512171251150.3698 () g5 ! osdl ! org>
--------------------


On Sat, 17 Dec 2005, Mika Kukkonen wrote:
> 
> Does the attached patch make sense?

Please don't use attachments, but most _especially_ not attachements that 
aren't even marked "text/plain". It means that you have to save the 
attachment to a file, and can't quote it in the reply sanely.

Anyway, I'd much prefer a solution that just involves using a real type, 
ie a "__builtin_size_t" type or something, and then we just do

	#define __SIZE_T__ __builtin_size_t

We actually already have a builtin [s]size_t pointer: do a 

	git grep size_t_ctype

to see what I mean (although right now it always ends up pointing to 
"unsigned long", regardless of what __SIZE_T__ is, which means that you 
can end up with

	sizeof(__SIZE_T__) != sizeof(sizeof(int))

which is wrong.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] add support for -imacros ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: [PATCH] add support for -imacros
Date: Wed, 14 Sep 2005 20:15:28 +0000
Message-ID: <20050914201528.GA7978 () mars ! ravnborg ! org>
--------------------
Gcc has two ways to specify on the commandline files
to be read before processign normal files.
"-include file" will include file in ordinary way.
"-imacros file" will include file but do not generate any output
gcc will include files specified with -imacros before files specified
with -include.

Following patch adds very basic support for -imacros, just
duplicating the code used for -include.
To obtain the real functionality we would have to build a list of
filenames specified, and process all files specifed with -imacros before
files specified with -include.

In -mm a patch is now included that uses -imacros, so applying
following patch will let us stay compatible with kernel source.
The last bit deletes two references from lib.h that are there for no
good reason.

Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
---
diff --git a/lib.c b/lib.c
--- a/lib.c
+++ b/lib.c
@@ -256,6 +256,15 @@ static char **handle_switch_i(char *arg,
 		if (fd < 0)
 			perror(name);
 	}
+	if (*next && !strcmp(arg, "imacros")) {
+		char *name = *++next;
+		int fd = open(name, O_RDONLY);
+
+		include_fd = fd;
+		include = name;
+		if (fd < 0)
+			perror(name);
+	}
 	else if (*next && !strcmp(arg, "isystem")) {
 		char *path = *++next;
 		if (!path)
diff --git a/lib.h b/lib.h
--- a/lib.h
+++ b/lib.h
@@ -71,8 +71,6 @@ extern void error_die(struct position, c
 extern char **handle_switch(char *arg, char **next);
 extern void add_pre_buffer(const char *fmt, ...);
 
-extern int include_fd;
-extern char *include;
 extern int preprocess_only;
 extern int Wptr_subtraction_blows;
 extern int Wdefault_bitfield_sign;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] added collection of the symbol_list from -include file. ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: [PATCH] added collection of the symbol_list from -include file.
Date: Tue, 01 Nov 2005 18:32:37 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHCEDBCHAA.mshah () teja ! com>
--------------------

Any comment about this patch?

Thanks,

-Mitesh



> -----Original Message-----
> From: linux-sparse-owner@vger.kernel.org
> [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Mitesh Shah
> Sent: Monday, October 24, 2005 5:12 PM
> To: Linux-Sparse
> Subject: [PATCH] added collection of the symbol_list from
> -include file.
>
>
>
> When we added the multiple file support, we stopped
> collecting symbol_list from the -include file. This patch
> adds support for collection of the symbol_list from -include file.
>
> -Mitesh
>
> ----------------------------------------------------
>
>
>
>
> diff --git a/check.c b/check.c
> --- a/check.c
> +++ b/check.c
> @@ -266,7 +266,9 @@ static void check_symbols(struct symbol_
>  int main(int argc, char **argv)
>  {
>  	// Expand, linearize and show it.
> -	sparse_initialize(argc, argv);
> +	struct symbol_list * initial_list;
> +	sparse_initialize(argc, argv, &initial_list);
> +	check_symbols(initial_list);
>  	while (*argv)
>  		check_symbols(sparse(argv));
>  	return 0;
> diff --git a/compile.c b/compile.c
> --- a/compile.c
> +++ b/compile.c
> @@ -39,7 +39,9 @@ int main(int argc, char **argv)
>  {
>  	const char *filename;
>
> -	sparse_initialize(argc, argv);
> +	struct symbol_list * initial_list;
> +	sparse_initialize(argc, argv, &initial_list);
> +	clean_up_symbols(initial_list);
>  	while ((filename = *argv) != NULL) {
>  		struct symbol_list *list;
>  		const char *basename = strrchr(filename, '/');
> diff --git a/example.c b/example.c
> --- a/example.c
> +++ b/example.c
> @@ -1958,7 +1958,9 @@ static int compile(struct symbol_list *l
>
>  int main(int argc, char **argv)
>  {
> -	sparse_initialize(argc, argv);
> +	struct symbol_list * initial_list;
> +	sparse_initialize(argc, argv, &initial_list);
> +	compile(initial_list);
>  	while (*argv)
>  		compile(sparse(argv));
>  	return 0;
> diff --git a/lib.c b/lib.c
> --- a/lib.c
> +++ b/lib.c
> @@ -560,7 +560,7 @@ static struct symbol_list *sparse_file(c
>   * affect all subsequent files too, ie we can have non-local
>   * behaviour between files!
>   */
> -static void sparse_initial(void)
> +static struct symbol_list * sparse_initial(void)
>  {
>  	struct token *token;
>
> @@ -572,10 +572,10 @@ static void sparse_initial(void)
>
>  	// Prepend the initial built-in stream
>  	token = tokenize_buffer(pre_buffer, pre_buffer_size, token);
> -	sparse_tokenstream(token);
> +	return sparse_tokenstream(token);
>  }
>
> -int sparse_initialize(int argc, char **argv)
> +int sparse_initialize(int argc, char **argv, struct
> symbol_list ** return_list)
>  {
>  	char **args;
>  	int files = 0;
> @@ -611,7 +611,7 @@ int sparse_initialize(int argc, char **a
>  		if (!preprocess_only)
>  			declare_builtin_functions();
>
> -		sparse_initial();
> +		*return_list = sparse_initial();
>
>  		/*
>  		 * Protect the initial token allocations, since
> diff --git a/lib.h b/lib.h
> --- a/lib.h
> +++ b/lib.h
> @@ -81,7 +81,7 @@ extern int Wcast_to_address_space;
>
>  extern void declare_builtin_functions(void);
>  extern void create_builtin_stream(void);
> -extern int sparse_initialize(int argc, char **argv);
> +extern int sparse_initialize(int argc, char **argv, struct
symbol_list ** list);
>  extern struct symbol_list *sparse(char **argv);
>
>  static inline int symbol_list_size(struct symbol_list* list)
> diff --git a/obfuscate.c b/obfuscate.c
> --- a/obfuscate.c
> +++ b/obfuscate.c
> @@ -49,7 +49,9 @@ static void emit_symbol_list(struct symb
>
>  int main(int argc, char **argv)
>  {
> -	sparse_initialize(argc, argv);
> +	struct symbol_list * initial_list;
> +	sparse_initialize(argc, argv, &initial_list);
> +	emit_symbol_list(initial_list);
>  	while (*argv)
>  		emit_symbol_list(sparse(argv));
>  	return 0;
> diff --git a/test-lexing.c b/test-lexing.c
> --- a/test-lexing.c
> +++ b/test-lexing.c
> @@ -21,7 +21,8 @@
>  int main(int argc, char **argv)
>  {
>  	preprocess_only = 1;
> -	sparse_initialize(argc, argv);
> +	struct symbol_list * initial_list;
> +	sparse_initialize(argc, argv, &initial_list);
>  	while (*argv)
>  		sparse(argv);
>  	show_identifier_stats();
> diff --git a/test-linearize.c b/test-linearize.c
> --- a/test-linearize.c
> +++ b/test-linearize.c
> @@ -38,7 +38,9 @@ static void clean_up_symbols(struct symb
>
>  int main(int argc, char **argv)
>  {
> -	sparse_initialize(argc, argv);
> +	struct symbol_list * initial_list;
> +	sparse_initialize(argc, argv, &initial_list);
> +	clean_up_symbols(initial_list);
>  	while (*argv)
>  		clean_up_symbols(sparse(argv));
>  	return 0;
> diff --git a/test-parsing.c b/test-parsing.c
> --- a/test-parsing.c
> +++ b/test-parsing.c
> @@ -34,7 +34,9 @@ static void clean_up_symbols(struct symb
>
>  int main(int argc, char **argv)
>  {
> -	sparse_initialize(argc, argv);
> +	struct symbol_list * initial_list;
> +	sparse_initialize(argc, argv, &initial_list);
> +	show_symbol_list(initial_list, "\n\n");
>  	while (*argv) {
>  		struct symbol_list *list = sparse(argv);
>
>
>
>
> -
> To unsubscribe from this list: send the line "unsubscribe
> linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
>



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid a crash caused by the phisrc OP_COPY who have a NULL ->def. ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid a crash caused by the phisrc OP_COPY who have a NULL ->def.
Date: Thu, 24 Nov 2005 01:16:14 +0000
Message-ID: <20051124011614.GA10642 () ralph05 ! lan>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---

 example.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

applies-to: fe5c8217add7c31e1c5504a8fabae86669e5d25b
aaf022fe16dc6545c18b14722a16b490c99edfea
diff --git a/example.c b/example.c
index 97d2fcb..7e30c22 100644
--- a/example.c
+++ b/example.c
@@ -1529,7 +1529,7 @@ static void fill_output(struct bb_state 
 		return;
 	case PSEUDO_REG:
 		def = pseudo->def;
-		if (def->opcode == OP_SETVAL) {
+		if (def && def->opcode == OP_SETVAL) {
 			write_val_to_storage(state, pseudo, out);
 			return;
 		}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid a crash on bad asm statement ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] avoid a crash on bad asm statement
Date: Wed, 18 May 2005 16:31:10 +0000
Message-ID: <Pine.LNX.4.58.0505180930250.18337 () ppc970 ! osdl ! org>
--------------------


On Wed, 18 May 2005, Christopher Li wrote:
>
> I think that should be fixed in the source, which did not assign
> expr->pos a proper value. No the one that use it.

Chris, the problem was that "expr" is NULL.

We could make the asm parser always have a non-NULL expression, of course.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid dereferencing a null pointer after parse errors in ===

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid dereferencing a null pointer after parse errors in
Date: Sun, 26 Jun 2005 16:57:23 +0000
Message-ID: <42BEDF3E.8080803 () looxix ! net>
--------------------
This patch avoid dereferencing a null pointer after parse errors in assignements.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1160,6 +1160,9 @@ static pseudo_t linearize_assignment(str
  		};
  		int opcode;

+		if (!src)
+			return VOID;
+
  		oldvalue = cast_pseudo(ep, oldvalue, src->ctype, expr->ctype);
  		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], src->ctype);
  		dst = add_binary_op(ep, src->ctype, opcode, oldvalue, value);
diff --git a/validation/bad-assignement.c b/validation/bad-assignement.c
new file mode 100644
--- /dev/null
+++ b/validation/bad-assignement.c
@@ -0,0 +1,6 @@
+static int foo(int a)
+{
+	a |=\1;
+
+	return a;
+}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid segafult after parse errors in casts ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid segafult after parse errors in casts
Date: Sun, 26 Jun 2005 23:42:51 +0000
Message-ID: <20050626234251.GF8582 () ralph05 ! lan>
--------------------
This patch avoid deferencing a null pointer after parse errors in casts.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1449,6 +1449,9 @@ pseudo_t linearize_cast(struct entrypoin
 	pseudo_t src;
 	struct expression *orig = expr->cast_expression;
 
+	if (!orig)
+		return VOID;
+
 	src = linearize_expression(ep, orig);
 	return cast_pseudo(ep, src, orig->ctype, expr->ctype);
 }
diff --git a/validation/bad-cast.c b/validation/bad-cast.c
new file mode 100644
--- /dev/null
+++ b/validation/bad-cast.c
@@ -0,0 +1,6 @@
+struct st;
+
+static int foo(int a)
+{
+	return (struct/st *) a;
+}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid segfault after parse errors in array designated initializer ===

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid segfault after parse errors in array designated initializer
Date: Sun, 26 Jun 2005 16:57:13 +0000
Message-ID: <42BEDF38.5050906 () looxix ! net>
--------------------
This patch avoid deferencing a null pointer after parse errors in array designated initializer.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/parse.c b/parse.c
--- a/parse.c
+++ b/parse.c
@@ -1473,6 +1473,10 @@ static struct token *single_initializer(
  		} else if (match_op(token, '[')) {
  			struct expression *from = NULL, *to = NULL, *expr;
  			token = constant_expression(token->next, &from);
+			if (!from) {
+				warning(token->pos, "Expected constant expression");
+				break;
+			}
  			if (match_op(token, SPECIAL_ELLIPSIS))
  				token = constant_expression(token->next, &to);
  			expr = index_expression(from, to);
diff --git a/validation/bad-array-designated-initializer.c b/validation/bad-array-designated-initializer.c
new file mode 100644
--- /dev/null
+++ b/validation/bad-array-designated-initializer.c
@@ -0,0 +1,4 @@
+static int a[] = {
+	[0] = 0,		// OK
+	[\0] = 1,		// KO
+};

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid segfault after parse errors in array designated initializer
Date: Sun, 26 Jun 2005 23:38:44 +0000
Message-ID: <20050626233844.GD8582 () ralph05 ! lan>
--------------------
This patch avoid deferencing a null pointer after parse errors in array designated initializer.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/parse.c b/parse.c
--- a/parse.c
+++ b/parse.c
@@ -1473,6 +1473,10 @@ static struct token *single_initializer(
 		} else if (match_op(token, '[')) {
 			struct expression *from = NULL, *to = NULL, *expr;
 			token = constant_expression(token->next, &from);
+			if (!from) {
+				warning(token->pos, "Expected constant expression");
+				break;
+			}
 			if (match_op(token, SPECIAL_ELLIPSIS))
 				token = constant_expression(token->next, &to);
 			expr = index_expression(from, to);
diff --git a/validation/bad-array-designated-initializer.c b/validation/bad-array-designated-initializer.c
new file mode 100644
--- /dev/null
+++ b/validation/bad-array-designated-initializer.c
@@ -0,0 +1,4 @@
+static int a[] = {
+	[0] = 0,		// OK
+	[\0] = 1,		// KO
+};

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid segfault after parse errors in casts ===

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid segfault after parse errors in casts
Date: Sun, 26 Jun 2005 16:57:09 +0000
Message-ID: <42BEDF33.5030106 () looxix ! net>
--------------------
This patch avoid deferencing a null pointer after parse errors in casts.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1449,6 +1449,9 @@ pseudo_t linearize_cast(struct entrypoin
  	pseudo_t src;
  	struct expression *orig = expr->cast_expression;

+	if (!orig)
+		return VOID;
+
  	src = linearize_expression(ep, orig);
  	return cast_pseudo(ep, src, orig->ctype, expr->ctype);
  }
diff --git a/validation/bad-cast.c b/validation/bad-cast.c
new file mode 100644
--- /dev/null
+++ b/validation/bad-cast.c
@@ -0,0 +1,6 @@
+struct st;
+
+static int foo(int a)
+{
+	return (struct/st *) a;
+}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid segfault in add_asm_output() after a parse error in ===

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid segfault in add_asm_output() after a parse error in
Date: Sun, 26 Jun 2005 16:56:57 +0000
Message-ID: <42BEDF27.8010906 () looxix ! net>
--------------------
This patch avoid deferencing a null pointer in add_asm_output() after a parse error in asm statement.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1676,7 +1676,7 @@ static void add_asm_output(struct entryp
  	pseudo_t pseudo = alloc_pseudo(insn);
  	struct asm_constraint *rule;

-	if (!linearize_address_gen(ep, expr, &ad))
+	if (!expr || !linearize_address_gen(ep, expr, &ad))
  		return;
  	linearize_store_gen(ep, pseudo, &ad);
  	finish_address_gen(ep, &ad);

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] avoid segfault in check_byte_count() ===

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: [PATCH] avoid segfault in check_byte_count()
Date: Sun, 26 Jun 2005 16:57:18 +0000
Message-ID: <42BEDF3B.6020204 () looxix ! net>
--------------------
This patch avoid deferencing a null pointer in check_byte_count() after parse errors in the checked function.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/check.c b/check.c
--- a/check.c
+++ b/check.c
@@ -133,6 +133,8 @@ static void check_range_instruction(stru

  static void check_byte_count(struct instruction *insn, pseudo_t count)
  {
+	if (!count)
+		return;
  	if (count->type == PSEUDO_VAL) {
  		long long val = count->value;
  		if (val <= 0 || val > 100000)
diff --git a/validation/check_byte_count-ice.c b/validation/check_byte_count-ice.c
new file mode 100644
--- /dev/null
+++ b/validation/check_byte_count-ice.c
@@ -0,0 +1,6 @@
+#include <string.h>
+
+static void foo(void *a)
+{
+	memset(foo, + ', 20);
+}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build shared libs as well ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] build shared libs as well
Date: Fri, 18 Feb 2005 18:44:42 +0000
Message-ID: <20050218184442.GC28874 () 64m ! dyndns ! org>
--------------------
Hi Linus,

This patch build shared library for sparse.
That save me a lot of time rebuilding the python modules
when I debug the sparse.

Chris

Index: sparse-be/Makefile
===================================================================
--- sparse-be.orig/Makefile	2004-12-09 16:48:33.000000000 -0500
+++ sparse-be/Makefile	2005-02-18 11:57:40.000000000 -0500
@@ -4,7 +4,7 @@
 OS=linux
 
 CC=gcc
-CFLAGS=-O -g -Wall -Wwrite-strings
+CFLAGS=-O -g -Wall -Wwrite-strings -fPIC
 LDFLAGS=-g
 AR=ar
 
@@ -23,7 +23,10 @@
 LIB_FILE= sparse.a
 LIBS=$(LIB_FILE)
 
-all: $(PROGRAMS)
+SHARE_LIB_FILE= libsparse.so
+SHARE_LIBS=$(SHARE_LIB_FILE)
+
+all: $(PROGRAMS) $(SHARE_LIBS)
 
 #
 # Install the 'check' binary as 'sparse', just to confuse people.
@@ -69,6 +72,9 @@
 $(LIB_FILE): $(LIB_OBJS)
 	$(AR) rcs $(LIB_FILE) $(LIB_OBJS)
 
+$(SHARE_LIB_FILE): $(LIB_OBJS)
+	$(CC) -shared -o $(SHARE_LIB_FILE) $(LIB_OBJS)
+
 evaluate.o: $(LIB_H)
 expression.o: $(LIB_H)
 lib.o: $(LIB_H)
@@ -109,4 +115,4 @@
 	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=include`\"" > pre-process.h
 
 clean:
-	rm -f *.[oasi] core core.[0-9]* $(PROGRAMS) pre-process.h
+	rm -f *.[oasi] *.so core core.[0-9]* $(PROGRAMS) pre-process.h 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [PATCH] build shared libs as well
Date: Fri, 18 Feb 2005 22:47:06 +0000
Message-ID: <4216706A.8000409 () pobox ! com>
--------------------
Christopher Li wrote:
> Hi Linus,
> 
> This patch build shared library for sparse.
> That save me a lot of time rebuilding the python modules
> when I debug the sparse.

Speaking of which, on the code generation side, I was wondering if 
generating PIC code would require any changes in sparse.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] change error to sparse_error ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] change error to sparse_error
Date: Wed, 16 Nov 2005 22:33:42 +0000
Message-ID: <Pine.LNX.4.64.0511161432410.13959 () g5 ! osdl ! org>
--------------------


On Wed, 16 Nov 2005, Mitesh Shah wrote:
> 
> on my linux machine error() interferes with error() defined in 
> /usr/include/error.h so I changed error to sparse_error. Here is the 
> patch.

Your patches are whitespace corrupted (missing spaces at end of lines). 
Please fix your mailer.

I did a stupid sed script to do the same, and checked in the result, 
though. Pushed out.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] drivers/usb/*: s/0/NULL/ in pointer context ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: Re: [PATCH] drivers/usb/*: s/0/NULL/ in pointer context
Date: Wed, 12 Jan 2005 10:48:00 +0000
Message-ID: <200501121346.50586.adobriyan () mail ! ru>
--------------------
On Wednesday 12 January 2005 03:00, Greg KH wrote:
> On Sun, Jan 09, 2005 at 12:59:14PM +0200, Alexey Dobriyan wrote:

[snip diffstat of s/0/NULL/ in comparisons patch]

> Hm, I get a number of conflicts against -bk14.  Care to redo this?  Or I
> can try to merge it myself, if you trust me :)

Will resend against 2.6.11-rc1.

> What did you use to find these, sparse doesn't spit out these warnings
> for me, last I checked.

:-) Apply this sooper sekret and broken patch, then grep for "incompatible 
types for operation". It will give bogus warnings on WARN_ON(pointer), 
BUG_ON(pointer), maybe on something else.

	Alexey

--- sparse-1.1230/evaluate.c    2005-01-12 13:42:44.332269760 +0200
+++ sparse-ad/evaluate.c        2005-01-12 13:32:32.917218976 +0200
@@ -884,7 +884,7 @@ static struct symbol *evaluate_compare(s
                warning(expr->pos, "testing a 'safe expression'");

        /* Pointer types? */
-       if (is_ptr_type(ltype) || is_ptr_type(rtype)) {
+       if (is_ptr_type(ltype) && is_ptr_type(rtype)) {
                // FIXME! Check the types for compatibility
                goto OK;
        }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix "wrong" NS_STRUCT symbol->pos ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [PATCH] fix "wrong" NS_STRUCT symbol->pos
Date: Mon, 19 Dec 2005 17:20:50 +0000
Message-ID: <43A6FD8E.19FAAC85 () tv-sign ! ru>
--------------------
NS_STRUCT symbol gets it's ->pos from alloc_symbol(), it
could be called when sparse sees struct's forward declaration.

This patch ensures that ->pos identifies position where this
struct/union is actually defined.

Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>

--- git-snapshot-20051210/parse.c~	2005-12-18 20:01:25.000000000 +0300
+++ git-snapshot-20051210/parse.c	2005-12-18 20:08:13.000000000 +0300
@@ -109,6 +109,7 @@ static struct token *struct_union_enum_s
 	struct token *(*parse)(struct token *, struct symbol *))
 {
 	struct symbol *sym;
+	struct position *repos;
 
 	ctype->modifiers = 0;
 	if (token_type(token) == TOKEN_IDENT) {
@@ -123,14 +124,16 @@ static struct token *struct_union_enum_s
 		}
 		if (sym->type != type)
 			error_die(token->pos, "invalid tag applied to %s", show_typename (sym));
-		token = token->next;
 		ctype->base_type = sym;
+		repos = &token->pos;
+		token = token->next;
 		if (match_op(token, '{')) {
 			// The following test is actually wrong for empty
 			// structs, but (1) they are not C99, (2) gcc does
 			// the same thing, and (3) it's easier.
 			if (sym->symbol_list)
 				error_die(token->pos, "redefinition of %s", show_typename (sym));
+			sym->pos = *repos;
 			token = parse(token->next, sym);
 			token = expect(token, '}', "at end of struct-union-enum-specifier");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix a memory leak in pack_ptr_list ===

From: Alecs King <alecsk () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix a memory leak in pack_ptr_list
Date: Sat, 31 Dec 2005 07:20:27 +0000
Message-ID: <20051231072027.GA1619 () localhost>
--------------------
Free the last entry when the whole list gets empty.

Signed-off-by: Alecs King <alecsk@gmail.com>


diff --git a/ptrlist.c b/ptrlist.c
index 14d8416..467a108 100644
--- a/ptrlist.c
+++ b/ptrlist.c
@@ -72,6 +72,7 @@ restart:
 			if (!entry->nr) {
 				struct ptr_list *prev;
 				if (next == entry) {
+					free(entry);
 					*listp = NULL;
 					return;
 				}

-- 
Alecs King
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix sparse warnings ===

From: Alecs King <alecsk () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix sparse warnings
Date: Sat, 31 Dec 2005 07:21:18 +0000
Message-ID: <20051231072118.GA3574 () localhost>
--------------------
sort.c:192:5: warning: mixing declarations and code
sort.c:234:2: warning: mixing declarations and code

Signed-off-by: Alecs King <alecsk@gmail.com>


diff --git a/sort.c b/sort.c
index c2ac8b7..749339a 100644
--- a/sort.c
+++ b/sort.c
@@ -186,10 +186,10 @@ merge_block_seqs (struct ptr_list *b1, i
 			// Element from b2 is smaller
 			buffer[nbuf++] = d2;
 			if (++i2 >= b2->nr) {
+				struct ptr_list *l = b2;
 				BEEN_THERE('M');
 				// Ok, we finished with b2.  Pull it out
 				// and plug it in before b1.
-				struct ptr_list *l = b2;
 
 				b2 = b2->next;
 				b2->prev = l->prev;
@@ -224,14 +224,13 @@ merge_block_seqs (struct ptr_list *b1, i
 
 void sort_list(struct ptr_list **plist, int (*cmp)(const void *, const void *))
 {
-	struct ptr_list *head = *plist;
+	struct ptr_list *head = *plist, *list = head;
 	int blocks = 1;
 
 	if (!head)
 		return;
 
 	// Sort all the sub-lists
-	struct ptr_list *list = head;
 	do {
 		array_sort(list->list, list->nr, cmp);
 #ifdef PARANOIA

-- 
Alecs King
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] git: some sparse fixes ===

From: mikukkon () miku ! homelinux ! net (Mika Kukkonen)
To: linux-sparse
Subject: [PATCH] git: some sparse fixes
Date: Sun, 03 Jul 2005 20:37:57 +0000
Message-ID: <20050703203757.GB19220 () miku ! homelinux ! net>
--------------------
Here is trivial fixes to git about things that sparse complains about.
The mkdelta.c fix might need checking, though. Of course the file does
not even compile now, so ...

Signed-off-by: Mika Kukkonen <mikukkon@iki.fi>

diffstat:
 apply.c        |    4 ++--
 ls-tree.c      |    2 +-
 mkdelta.c      |    2 +-
 receive-pack.c |    2 +-
 rev-list.c     |    2 +-
 sha1_file.c    |    2 +-
 ssh-pull.c     |    2 +-
 ssh-push.c     |   12 ++++++------
 8 files changed, 14 insertions(+), 14 deletions(-)
 
Index: git/apply.c
===================================================================
--- git.orig/apply.c
+++ git/apply.c
@@ -724,8 +724,8 @@ static int parse_chunk(char *buffer, uns
 	return offset + hdrsize + patchsize;
 }
 
-const char pluses[] = "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++";
-const char minuses[]= "----------------------------------------------------------------------";
+static const char pluses[] = "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++";
+static const char minuses[]= "----------------------------------------------------------------------";
 
 static void show_stats(struct patch *patch)
 {
Index: git/ls-tree.c
===================================================================
--- git.orig/ls-tree.c
+++ git/ls-tree.c
@@ -79,7 +79,7 @@ static struct tree_entry_list *find_entr
 		slash = strchr(path, '/');
 		if (!slash) {
 			len = strlen(path);
-			next = 0;
+			next = NULL;
 		}
 		else {
 			next = slash + 1;
Index: git/mkdelta.c
===================================================================
--- git.orig/mkdelta.c
+++ git/mkdelta.c
@@ -278,7 +278,7 @@ int main(int argc, char **argv)
 				continue;
 			}
 			delta_buf = diff_delta(ref[r].buf, ref[r].size,
-					       trg.buf, trg.size, &delta_size);
+					       trg.buf, trg.size, &delta_size, 0);
 			if (!delta_buf)
 				die("out of memory");
 			if (trg.depth < max_depth &&
Index: git/receive-pack.c
===================================================================
--- git.orig/receive-pack.c
+++ git/receive-pack.c
@@ -25,7 +25,7 @@ struct command {
 	char ref_name[0];
 };
 
-struct command *commands = NULL;
+static struct command *commands = NULL;
 
 static int is_all_zeroes(const char *hex)
 {
Index: git/rev-list.c
===================================================================
--- git.orig/rev-list.c
+++ git/rev-list.c
@@ -310,7 +310,7 @@ static struct commit_list *find_bisectio
 	return best;
 }
 
-struct commit_list *limit_list(struct commit_list *list)
+static struct commit_list *limit_list(struct commit_list *list)
 {
 	struct commit_list *newlist = NULL;
 	struct commit_list **p = &newlist;
Index: git/sha1_file.c
===================================================================
--- git.orig/sha1_file.c
+++ git/sha1_file.c
@@ -531,7 +531,7 @@ int unpack_sha1_header(z_stream *stream,
 	return inflate(stream, 0);
 }
 
-void *unpack_sha1_rest(z_stream *stream, void *buffer, unsigned long size)
+static void *unpack_sha1_rest(z_stream *stream, void *buffer, unsigned long size)
 {
 	int bytes = strlen(buffer) + 1;
 	unsigned char *buf = xmalloc(1+size);
Index: git/ssh-pull.c
===================================================================
--- git.orig/ssh-pull.c
+++ git/ssh-pull.c
@@ -29,7 +29,7 @@ int fetch(unsigned char *sha1)
 	return ret;
 }
 
-int get_version(void)
+static int get_version(void)
 {
 	char type = 'v';
 	write(fd_out, &type, 1);
Index: git/ssh-push.c
===================================================================
--- git.orig/ssh-push.c
+++ git/ssh-push.c
@@ -4,10 +4,10 @@
 
 #include <string.h>
 
-unsigned char local_version = 1;
-unsigned char remote_version = 0;
+static unsigned char local_version = 1;
+static unsigned char remote_version = 0;
 
-int serve_object(int fd_in, int fd_out) {
+static int serve_object(int fd_in, int fd_out) {
 	ssize_t size;
 	int posn = 0;
 	unsigned char sha1[20];
@@ -57,7 +57,7 @@ int serve_object(int fd_in, int fd_out) 
 	return 0;
 }
 
-int serve_version(int fd_in, int fd_out)
+static int serve_version(int fd_in, int fd_out)
 {
 	if (read(fd_in, &remote_version, 1) < 1)
 		return -1;
@@ -65,7 +65,7 @@ int serve_version(int fd_in, int fd_out)
 	return 0;
 }
 
-int serve_ref(int fd_in, int fd_out)
+static int serve_ref(int fd_in, int fd_out)
 {
 	char ref[PATH_MAX];
 	unsigned char sha1[20];
@@ -86,7 +86,7 @@ int serve_ref(int fd_in, int fd_out)
 }
 
 
-void service(int fd_in, int fd_out) {
+static void service(int fd_in, int fd_out) {
 	char type;
 	int retval;
 	do {

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] git: some sparse fixes
Date: Sun, 03 Jul 2005 21:34:55 +0000
Message-ID: <Pine.LNX.4.58.0507031433070.3570 () g5 ! osdl ! org>
--------------------


On Sun, 3 Jul 2005, Mika Kukkonen wrote:
>
> Here is trivial fixes to git about things that sparse complains about.
> The mkdelta.c fix might need checking, though. Of course the file does
> not even compile now, so ...

You shouldn't even have that file. Anyway, I actually did both of these 
things earlier, and the changes shoul dhave percolated out already on the 
mirrors (they're visible on gitweb, at least).

		Linsu
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] handle_switch_G for mips ===

From: Atsushi Nemoto <anemo () mba ! ocn ! ne ! jp>
To: linux-sparse
Subject: [PATCH] handle_switch_G for mips
Date: Sat, 24 Sep 2005 16:30:24 +0000
Message-ID: <20050925.013024.126140972.anemo () mba ! ocn ! ne ! jp>
--------------------
Hi.  When I ran make C=1 on linux-mips kernel, I got:

  CHECK   /home/cvs/linux-mips/scripts/mod/empty.c
No such file: 0

If I ran make C=1 V=1, I got:

  sparse -D__linux__ -D__mips__ -D_MIPS_SZLONG=32 -D__PTRDIFF_TYPE__=int -D__MIPSEL__  -nostdinc -isystem /usr/lib/gcc/mipsel-linux/3.4.4/include -Wp,-MD,scripts/mod/.empty.o.d  -nostdinc -isystem /usr/lib/gcc/mipsel-linux/3.4.4/include -D__KERNEL__ -Iinclude -Iinclude2 -I/home/cvs/linux-mips/include -I/home/cvs/linux-mips/scripts/mod -Iscripts/mod -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -ffreestanding -O2 -fomit-frame-pointer -I/home/cvs/linux-mips/ -I /home/cvs/linux-mips/include/asm/gcc -G 0 -mno-abicalls -fno-pic -pipe -finline-limit=100000 -mabi=32 -march=r3000 -Wa,-32 -Wa,-march=r3000 -Wa,-mips1 -I/home/cvs/linux-mips/include/asm-mips/mach-dec -Iinclude/asm-mips/mach-dec -I/home/cvs/linux-mips/include/asm-mips/mach-generic -Iinclude/asm-mips/mach-generic  -DKBUILD_BASENAME=empty -DKBUILD_MODNAME=empty /home/cvs/linux-mips/scripts/mod/empty.c ;
No such file: 0

It seems sparse is confused by '-G 0' option.

How about this patch?

--- git-snapshot-20050921/lib.c	2005-09-16 02:42:45.000000000 +0900
+++ sparse/lib.c	2005-09-25 01:13:42.486077000 +0900
@@ -373,6 +373,14 @@
 	return next;
 }
 
+static char **handle_switch_G(char *arg, char **next)
+{
+	if (!strcmp (arg, "G") && *next)
+		return next + 1; // "-G 0"
+	else
+		return next;     // "-G0" or (bogus) terminal "-G"
+}
+
 static char **handle_nostdinc(char *arg, char **next)
 {
 	add_pre_buffer("#nostdinc\n");
@@ -415,6 +423,7 @@
 	case 'W': return handle_switch_W(arg, next);
 	case 'O': return handle_switch_O(arg, next);
 	case 'f': return handle_switch_f(arg, next);
+	case 'G': return handle_switch_G(arg, next);
 	default:
 		break;
 	}

---
Atsushi Nemoto
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] makes some needlessly global code static ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] makes some needlessly global code static
Date: Mon, 27 Jun 2005 21:26:34 +0000
Message-ID: <20050627212634.GB3016 () ralph05 ! lan>
--------------------
This patch makes some needlessly global code static so that sparse don't complain when self checking.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c
+++ b/compile-i386.c
@@ -169,8 +169,8 @@ struct atom {
 };
 
 
-struct function *current_func = NULL;
-struct textbuf *unit_post_text = NULL;
+static struct function *current_func = NULL;
+static struct textbuf *unit_post_text = NULL;
 static const char *current_section;
 
 static void emit_comment(const char * fmt, ...);
@@ -256,7 +256,7 @@ static inline struct storage * reginfo_r
 	return hardreg_storage_table + info->own_regno;
 }
 
-struct storage * get_hardreg(struct storage *reg, int clear)
+static struct storage * get_hardreg(struct storage *reg, int clear)
 {
 	struct reg_info *info = reg->reg;
 	const unsigned char *aliases;
@@ -278,7 +278,7 @@ busy:
 	exit(1);
 }
 
-void put_reg(struct storage *reg)
+static void put_reg(struct storage *reg)
 {
 	struct reg_info *info = reg->reg;
 	int regno = info->own_regno;
@@ -298,7 +298,7 @@ static struct regclass regclass_16 = { "
 static struct regclass regclass_32 = { "32-bit", { EAX, EDX, ECX, EBX, ESI, EDI, EBP }};
 static struct regclass regclass_64 = { "64-bit", { EAX_EDX, ECX_EBX, ESI_EDI }};
 
-struct regclass regclass_32_8 = { "32-bit bytes", { EAX, EDX, ECX, EBX }};
+static struct regclass regclass_32_8 = { "32-bit bytes", { EAX, EDX, ECX, EBX }};
 
 static struct regclass *get_regclass_bits(int bits)
 {
@@ -332,7 +332,7 @@ busy:
 	return 1;
 }
 
-struct storage *get_reg(struct regclass *class)
+static struct storage *get_reg(struct regclass *class)
 {
 	const unsigned char *regs = class->regs;
 	int regno;
@@ -347,7 +347,7 @@ struct storage *get_reg(struct regclass 
 	exit(1);
 }
 
-struct storage *get_reg_value(struct storage *value, struct regclass *class)
+static struct storage *get_reg_value(struct storage *value, struct regclass *class)
 {
 	struct reg_info *info;
 	struct storage *reg;
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1447,7 +1447,7 @@ static pseudo_t linearize_logical_branch
 	return VOID;
 }
 
-pseudo_t linearize_cast(struct entrypoint *ep, struct expression *expr)
+static pseudo_t linearize_cast(struct entrypoint *ep, struct expression *expr)
 {
 	pseudo_t src;
 	struct expression *orig = expr->cast_expression;
@@ -1459,7 +1459,7 @@ pseudo_t linearize_cast(struct entrypoin
 	return cast_pseudo(ep, src, orig->ctype, expr->ctype);
 }
 
-pseudo_t linearize_position(struct entrypoint *ep, struct expression *pos, struct access_data *ad)
+static pseudo_t linearize_position(struct entrypoint *ep, struct expression *pos, struct access_data *ad)
 {
 	struct expression *init_expr = pos->init_expr;
 
@@ -1493,7 +1493,7 @@ pseudo_t linearize_initializer(struct en
 	return VOID;
 }
 
-void linearize_argument(struct entrypoint *ep, struct symbol *arg, int nr)
+static void linearize_argument(struct entrypoint *ep, struct symbol *arg, int nr)
 {
 	struct access_data ad = { NULL, };
 
@@ -1629,7 +1629,7 @@ static pseudo_t linearize_compound_state
 	return pseudo;
 }
 
-pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
+static pseudo_t linearize_context(struct entrypoint *ep, struct statement *stmt)
 {
 	struct instruction *insn = alloc_instruction(OP_CONTEXT, 0);
 	struct expression *expr = stmt->expression;
@@ -1643,7 +1643,7 @@ pseudo_t linearize_context(struct entryp
 	return VOID;
 }
 
-pseudo_t linearize_range(struct entrypoint *ep, struct statement *stmt)
+static pseudo_t linearize_range(struct entrypoint *ep, struct statement *stmt)
 {
 	struct instruction *insn = alloc_instruction(OP_RANGE, 0);
 
@@ -1687,7 +1687,7 @@ static void add_asm_output(struct entryp
 	add_ptr_list(&insn->asm_rules->outputs, rule);
 }
 
-pseudo_t linearize_asm_statement(struct entrypoint *ep, struct statement *stmt)
+static pseudo_t linearize_asm_statement(struct entrypoint *ep, struct statement *stmt)
 {
 	int state;
 	struct expression *expr;
diff --git a/storage.c b/storage.c
--- a/storage.c
+++ b/storage.c
@@ -19,7 +19,7 @@ ALLOCATOR(storage, "storages");
 ALLOCATOR(storage_hash, "storage hash");
 
 #define MAX_STORAGE_HASH 64
-struct storage_hash_list *storage_hash_table[MAX_STORAGE_HASH];
+static struct storage_hash_list *storage_hash_table[MAX_STORAGE_HASH];
 
 static inline unsigned int storage_hash(struct basic_block *bb, pseudo_t pseudo, enum inout_enum inout)
 {
@@ -128,7 +128,7 @@ static int storage_hash_cmp(const void *
 	return 0;
 }
 
-void vrfy_storage(struct storage_hash_list **listp)
+static void vrfy_storage(struct storage_hash_list **listp)
 {
 	struct storage_hash *entry, *last;
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] member dereferencing didn't examine the parent type, as consequence the member offset were n ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATCH] member dereferencing didn't examine the parent type, as consequence the member offset were n
Date: Mon, 28 Nov 2005 00:15:09 +0000
Message-ID: <20051128001509.GA2065 () g5 ! pc ! home>
--------------------

---

 evaluate.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

applies-to: 1d5cc33dcef44d411342f69801fa0b3e93bddc0d
06d914c2d71146ef36bfa4d04f401ebd138c5afd
diff --git a/evaluate.c b/evaluate.c
index 07f8b8c..224b064 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1634,6 +1634,7 @@ static struct symbol *evaluate_member_de
 		sparse_error(expr->pos, "expected structure or union");
 		return NULL;
 	}
+	examine_symbol_type(ctype);
 	offset = 0;
 	member = find_identifier(ident, ctype->symbol_list, &offset);
 	if (!member) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] replaced warnings with errors. ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: [PATCH] replaced warnings with errors.
Date: Fri, 16 Sep 2005 23:33:14 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHGEEPCGAA.mshah () teja ! com>
--------------------
Any input about this patch?
---------------------

I have replaced calls to warning() with error() at places where (I think)
the gcc reports an error. Also added a global variable die_if_error which is
set if there is one or more errors. If someone wants to stop processing
further, can check for the variable.

Please send me your comments/suggestions.

Thanks,

-Mitesh

---------------------------------------------------

diff --git a/evaluate.c b/evaluate.c
--- a/evaluate.c
+++ b/evaluate.c
@@ -38,7 +38,7 @@ static struct symbol *evaluate_symbol_ex
 	struct symbol *base_type;

 	if (!sym) {
-		warning(expr->pos, "undefined identifier '%s'",
show_ident(expr->symbol_name));
+		error(expr->pos, "undefined identifier '%s'",
show_ident(expr->symbol_name));
 		return NULL;
 	}

@@ -46,7 +46,7 @@ static struct symbol *evaluate_symbol_ex

 	base_type = get_base_type(sym);
 	if (!base_type) {
-		warning(expr->pos, "identifier '%s' has no type",
show_ident(expr->symbol_name));
+		error(expr->pos, "identifier '%s' has no type",
show_ident(expr->symbol_name));
 		return NULL;
 	}

@@ -312,7 +312,7 @@ static inline int is_string_type(struct

 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warning(expr->pos, "incompatible types for operation (%s)",
show_special(expr->op));
+	error(expr->pos, "incompatible types for operation (%s)",
show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
@@ -498,7 +498,7 @@ static struct symbol *evaluate_ptr_add(s
 	examine_symbol_type(ctype);

 	if (!ctype->ctype.base_type) {
-		warning(expr->pos, "missing type information");
+		error(expr->pos, "missing type information");
 		return NULL;
 	}

@@ -756,7 +756,7 @@ static struct symbol *evaluate_ptr_sub(s
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			warning(expr->pos, "subtraction of different types can't work (%s)",
typediff);
+			error(expr->pos, "subtraction of different types can't work (%s)",
typediff);
 			return NULL;
 		}
 	}
@@ -766,7 +766,7 @@ static struct symbol *evaluate_ptr_sub(s
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		warning(expr->pos, "subtraction of functions? Share your drugs");
+		error(expr->pos, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = get_base_type(ctype);
@@ -1023,7 +1023,7 @@ static struct symbol *evaluate_condition
 	typediff = type_difference(ltype, rtype, MOD_IGN, MOD_IGN);
 	if (!typediff)
 		goto out;
-	warning(expr->pos, "incompatible types in conditional expression (%s)",
typediff);
+	error(expr->pos, "incompatible types in conditional expression (%s)",
typediff);
 	return NULL;

 out:
@@ -1055,7 +1055,7 @@ static int compatible_assignment_types(s
 			goto Cast;
 	} else if (is_float_type(target)) {
 		if (!compatible_float_op(op)) {
-			warning(expr->pos, "invalid assignment");
+			error(expr->pos, "invalid assignment");
 			return 0;
 		}
 		if (is_int_type(source))
@@ -1064,7 +1064,7 @@ static int compatible_assignment_types(s
 			goto Cast;
 	} else if (is_restricted_type(target)) {
 		if (restricted_binop(op, target)) {
-			warning(expr->pos, "bad restricted assignment");
+			error(expr->pos, "bad restricted assignment");
 			return 0;
 		}
 		if (!restricted_value(*rp, target))
@@ -1075,11 +1075,11 @@ static int compatible_assignment_types(s
 			return 1;
 		}
 		if (op != '=') {
-			warning(expr->pos, "invalid pointer assignment");
+			error(expr->pos, "invalid pointer assignment");
 			return 0;
 		}
 	} else if (op != '=') {
-		warning(expr->pos, "invalid assignment");
+		error(expr->pos, "invalid assignment");
 		return 0;
 	}

@@ -1118,7 +1118,7 @@ static int compatible_assignment_types(s
 		}
 	}

-	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
+	error(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
@@ -1131,7 +1131,7 @@ Cast:
 static void evaluate_assign_to(struct expression *left, struct symbol
*type)
 {
 	if (type->ctype.modifiers & MOD_CONST)
-		warning(left->pos, "assignment to const expression");
+		error(left->pos, "assignment to const expression");
 	if (type->type == SYM_NODE)
 		type->ctype.modifiers |= MOD_ASSIGNED;
 }
@@ -1143,7 +1143,7 @@ static struct symbol *evaluate_assignmen
 	struct symbol *ltype, *rtype;

 	if (!lvalue_expression(left)) {
-		warning(expr->pos, "not an lvalue");
+		error(expr->pos, "not an lvalue");
 		return NULL;
 	}

@@ -1308,7 +1308,7 @@ static struct symbol *degenerate(struct
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			warning(expr->pos, "strange non-value function or array");
+			error(expr->pos, "strange non-value function or array");
 			return &bad_ctype;
 		}
 		*expr = *expr->unop;
@@ -1326,7 +1326,7 @@ static struct symbol *evaluate_addressof
 	struct symbol *ctype;

 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		warning(expr->pos, "not addressable");
+		error(expr->pos, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1370,7 +1370,7 @@ static struct symbol *evaluate_dereferen

 	switch (ctype->type) {
 	default:
-		warning(expr->pos, "cannot derefence this type");
+		error(expr->pos, "cannot derefence this type");
 		return NULL;
 	case SYM_PTR:
 		node->ctype.modifiers = target->ctype.modifiers & MOD_SPECIFIER;
@@ -1379,7 +1379,7 @@ static struct symbol *evaluate_dereferen

 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			warning(op->pos, "non-lvalue array??");
+			error(op->pos, "non-lvalue array??");
 			return NULL;
 		}

@@ -1411,11 +1411,11 @@ static struct symbol *evaluate_postop(st
 	struct symbol *ctype = op->ctype;

 	if (!lvalue_expression(expr->unop)) {
-		warning(expr->pos, "need lvalue expression for ++/--");
+		error(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
-		warning(expr->pos, "bad operation on restricted");
+		error(expr->pos, "bad operation on restricted");
 		return NULL;
 	}

@@ -1574,7 +1574,7 @@ static struct symbol *evaluate_member_de
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		warning(expr->pos, "bad member name");
+		error(expr->pos, "bad member name");
 		return NULL;
 	}

@@ -1587,7 +1587,7 @@ static struct symbol *evaluate_member_de
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		warning(expr->pos, "expected structure or union");
+		error(expr->pos, "expected structure or union");
 		return NULL;
 	}
 	offset = 0;
@@ -1600,7 +1600,7 @@ static struct symbol *evaluate_member_de
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		warning(expr->pos, "no member '%s' in %s %.*s",
+		error(expr->pos, "no member '%s' in %s %.*s",
 			show_ident(ident), type, namelen, name);
 		return NULL;
 	}
@@ -1690,7 +1690,7 @@ static struct symbol *evaluate_type_info
 	}
 	examine_symbol_type(sym);
 	if (is_bitfield_type(sym)) {
-		warning(expr->pos, "trying to examine bitfield type");
+		error(expr->pos, "trying to examine bitfield type");
 		return NULL;
 	}
 	return sym;
@@ -1707,7 +1707,7 @@ static struct symbol *evaluate_sizeof(st

 	size = type->bit_size;
 	if ((size < 0) || (size & 7))
-		warning(expr->pos, "cannot size expression");
+		error(expr->pos, "cannot size expression");
 	expr->type = EXPR_VALUE;
 	expr->value = size >> 3;
 	expr->ctype = size_t_ctype;
@@ -1735,7 +1735,7 @@ static struct symbol *evaluate_ptrsizeof
 		if (type)
 			break;
 	default:
-		warning(expr->pos, "expected pointer expression");
+		error(expr->pos, "expected pointer expression");
 		return NULL;
 	}
 	size = type->bit_size;
@@ -1854,7 +1854,7 @@ static void evaluate_array_initializer(s
 static void evaluate_scalar_initializer(struct symbol *ctype, struct
expression *expr)
 {
 	if (expression_list_size(expr->expr_list) != 1) {
-		warning(expr->pos, "unexpected compound initializer");
+		error(expr->pos, "unexpected compound initializer");
 		return;
 	}
 	evaluate_array_initializer(ctype, expr);
@@ -2128,7 +2128,7 @@ static struct symbol *evaluate_cast(stru

 	t2 = target->ctype;
 	if (!t2) {
-		warning(expr->pos, "cast from unknown type");
+		error(expr->pos, "cast from unknown type");
 		goto out;
 	}
 	if (t2->type == SYM_NODE)
@@ -2217,15 +2217,15 @@ static struct symbol *evaluate_call(stru
 	if (!evaluate_arguments(sym, ctype, arglist))
 		return NULL;
 	if (ctype->type != SYM_FN) {
-		warning(expr->pos, "not a function %s", show_ident(sym->ident));
+		error(expr->pos, "not a function %s", show_ident(sym->ident));
 		return NULL;
 	}
 	args = expression_list_size(expr->args);
 	fnargs = symbol_list_size(ctype->arguments);
 	if (args < fnargs)
-		warning(expr->pos, "not enough arguments for function %s",
show_ident(sym->ident));
+		error(expr->pos, "not enough arguments for function %s",
show_ident(sym->ident));
 	if (args > fnargs && !ctype->variadic)
-		warning(expr->pos, "too many arguments for function %s",
show_ident(sym->ident));
+		error(expr->pos, "too many arguments for function %s",
show_ident(sym->ident));
 	if (sym->type == SYM_NODE) {
 		if (evaluate_symbol_call(expr))
 			return expr->ctype;
@@ -2244,7 +2244,7 @@ struct symbol *evaluate_expression(struc
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		warning(expr->pos, "value expression without a type");
+		error(expr->pos, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2319,10 +2319,10 @@ struct symbol *evaluate_expression(struc
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		warning(expr->pos, "internal front-end error: initializer in
expression");
+		error(expr->pos, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		warning(expr->pos, "internal front-end error: SLICE re-evaluated");
+		error(expr->pos, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
@@ -2339,7 +2339,7 @@ static void check_duplicates(struct symb
 		declared++;
 		typediff = type_difference(sym, next, 0, 0);
 		if (typediff) {
-			warning(sym->pos, "symbol '%s' redeclared with different type
(originally declared at %s:%d) - %s",
+			error(sym->pos, "symbol '%s' redeclared with different type (originally
declared at %s:%d) - %s",
 				show_ident(sym->ident),
 				stream_name(next->pos.stream), next->pos.line, typediff);
 			return;
@@ -2411,12 +2411,12 @@ static struct symbol *evaluate_return_ex
 	fntype = current_fn->ctype.base_type;
 	if (!fntype || fntype == &void_ctype) {
 		if (expr && ctype != &void_ctype)
-			warning(expr->pos, "return expression in %s function",
fntype?"void":"typeless");
+			error(expr->pos, "return expression in %s function",
fntype?"void":"typeless");
 		return NULL;
 	}

 	if (!expr) {
-		warning(stmt->pos, "return with no return value");
+		error(stmt->pos, "return with no return value");
 		return NULL;
 	}
 	if (!ctype)
@@ -2451,7 +2451,7 @@ static void verify_output_constraint(str
 	case '+':	/* Update */
 		break;
 	default:
-		warning(expr->pos, "output constraint is not an assignment constraint
(\"%s\")", constraint);
+		error(expr->pos, "output constraint is not an assignment constraint
(\"%s\")", constraint);
 	}
 }

@@ -2460,7 +2460,7 @@ static void verify_input_constraint(stru
 	switch (*constraint) {
 	case '=':	/* Assignment */
 	case '+':	/* Update */
-		warning(expr->pos, "input constraint with assignment (\"%s\")",
constraint);
+		error(expr->pos, "input constraint with assignment (\"%s\")",
constraint);
 	}
 }

@@ -2471,7 +2471,7 @@ static void evaluate_asm_statement(struc

 	expr = stmt->asm_string;
 	if (!expr || expr->type != EXPR_STRING) {
-		warning(stmt->pos, "need constant string for inline asm");
+		error(stmt->pos, "need constant string for inline asm");
 		return;
 	}

@@ -2488,7 +2488,7 @@ static void evaluate_asm_statement(struc
 		case 1: /* Constraint */
 			state = 2;
 			if (!expr || expr->type != EXPR_STRING) {
-				warning(expr ? expr->pos : stmt->pos, "asm output constraint is not a
string");
+				error(expr ? expr->pos : stmt->pos, "asm output constraint is not a
string");
 				*THIS_ADDRESS(expr) = NULL;
 				continue;
 			}
@@ -2519,7 +2519,7 @@ static void evaluate_asm_statement(struc
 		case 1:	/* Constraint */
 			state = 2;
 			if (!expr || expr->type != EXPR_STRING) {
-				warning(expr ? expr->pos : stmt->pos, "asm input constraint is not a
string");
+				error(expr ? expr->pos : stmt->pos, "asm input constraint is not a
string");
 				*THIS_ADDRESS(expr) = NULL;
 				continue;
 			}
@@ -2536,12 +2536,12 @@ static void evaluate_asm_statement(struc

 	FOR_EACH_PTR(stmt->asm_clobbers, expr) {
 		if (!expr) {
-			warning(stmt->pos, "bad asm output");
+			error(stmt->pos, "bad asm output");
 			return;
 		}
 		if (expr->type == EXPR_STRING)
 			continue;
-		warning(expr->pos, "asm clobber is not a string");
+		error(expr->pos, "asm clobber is not a string");
 	} END_FOR_EACH_PTR(expr);
 }

diff --git a/expand.c b/expand.c
--- a/expand.c
+++ b/expand.c
@@ -41,7 +41,7 @@ static int expand_symbol_expression(stru

 	if (sym == &zero_int) {
 		if (Wundefined_preprocessor)
-			warning(expr->pos, "undefined preprocessor identifier '%s'",
show_ident(expr->symbol_name));
+			error(expr->pos, "undefined preprocessor identifier '%s'",
show_ident(expr->symbol_name));
 		expr->type = EXPR_VALUE;
 		expr->value = 0;
 		return 0;
@@ -900,7 +900,7 @@ static int expand_expression(struct expr
 	case EXPR_SIZEOF:
 	case EXPR_PTRSIZEOF:
 	case EXPR_ALIGNOF:
-		warning(expr->pos, "internal front-end error: sizeof in expansion?");
+		error(expr->pos, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -911,7 +911,7 @@ static void expand_const_expression(stru
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			warning(expr->pos, "Expected constant expression in %s", where);
+			error(expr->pos, "Expected constant expression in %s", where);
 	}
 }

@@ -1083,12 +1083,12 @@ long long get_expression_value(struct ex
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		warning(expr->pos, "bad constant expression type");
+		error(expr->pos, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		warning(expr->pos, "bad constant expression");
+		error(expr->pos, "bad constant expression");
 		return 0;
 	}

diff --git a/expression.c b/expression.c
--- a/expression.c
+++ b/expression.c
@@ -326,7 +326,7 @@ struct token *primary_expression(struct
 		 *	if (typeof(a) == int) ..
 		 */
 		if (sym && sym->namespace == NS_TYPEDEF) {
-			warning(token->pos, "typename in expression");
+			error(token->pos, "typename in expression");
 			sym = NULL;
 		}
 		expr->symbol_name = token->ident;
@@ -428,7 +428,7 @@ static struct token *postfix_expression(
 			deref->deref = expr;
 			token = token->next;
 			if (token_type(token) != TOKEN_IDENT) {
-				warning(token->pos, "Expected member name");
+				error(token->pos, "Expected member name");
 				break;
 			}
 			deref->member = token->ident;
@@ -520,7 +520,7 @@ static struct token *unary_expression(st

 			next = cast_expression(token->next, &unop);
 			if (!unop) {
-				warning(token->pos, "Syntax error in unary expression");
+				error(token->pos, "Syntax error in unary expression");
 				return next;
 			}
 			unary = alloc_expression(token->pos, EXPR_PREOP);
@@ -607,7 +607,7 @@ static struct token *cast_expression(str
 			top = alloc_expression(next->pos, type);	\
 			next = inner(next->next, &right);		\
 			if (!right) {					\
-				warning(next->pos, "No right hand side of '%s'-expression",
show_special(op));	\
+				error(next->pos, "No right hand side of '%s'-expression",
show_special(op));	\
 				break;					\
 			}						\
 			top->op = op;					\
diff --git a/inline.c b/inline.c
--- a/inline.c
+++ b/inline.c
@@ -469,7 +469,7 @@ int inline_function(struct expression *e
 	struct expression *arg;

 	if (!fn->inline_stmt) {
-		warning(fn->pos, "marked inline, but without a definition");
+		error(fn->pos, "marked inline, but without a definition");
 		return 0;
 	}
 	if (fn->expanding)
diff --git a/lib.c b/lib.c
--- a/lib.c
+++ b/lib.c
@@ -29,6 +29,7 @@
 #include "target.h"

 int verbose, optimize, optimize_size, preprocessing;
+int die_if_error = 0;

 #ifndef __GNUC__
 # define __GNUC__ 2
@@ -53,8 +54,8 @@ struct token *expect(struct token *token
 		static struct token bad_token;
 		if (token != &bad_token) {
 			bad_token.next = token;
-			warning(token->pos, "Expected %s %s", show_special(op), where);
-			warning(token->pos, "got %s", show_token(token));
+			error(token->pos, "Expected %s %s", show_special(op), where);
+			error(token->pos, "got %s", show_token(token));
 		}
 		if (op == ';')
 			return skip_to(token, op);
@@ -124,7 +125,7 @@ void error(struct position pos, const ch
 {
 	static int errors = 0;
 	va_list args;
-
+        die_if_error = 1;
 	/* Shut up warnings after an error */
 	max_warnings = 0;
 	if (errors > 100) {
@@ -178,6 +179,7 @@ int preprocess_only;
 char *include;
 int include_fd = -1;

+
 void add_pre_buffer(const char *fmt, ...)
 {
 	va_list args;
diff --git a/parse.c b/parse.c
--- a/parse.c
+++ b/parse.c
@@ -142,7 +142,7 @@ static struct token *struct_union_enum_s

 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected declaration");
+		error(token->pos, "expected declaration");
 		ctype->base_type = &bad_ctype;
 		return token;
 	}
@@ -290,7 +290,7 @@ static struct token *parse_enum_declarat
 		token = token->next;
 	}
 	if (!base_type) {
-		warning(token->pos, "bad enum definition");
+		error(token->pos, "bad enum definition");
 		base_type = &bad_ctype;
 	}
 	else if (!is_int_type(base_type))
@@ -333,7 +333,7 @@ static struct token *typeof_specifier(st
 	struct symbol *sym;

 	if (!match_op(token, '(')) {
-		warning(token->pos, "expected '(' after typeof");
+		error(token->pos, "expected '(' after typeof");
 		return token;
 	}
 	if (lookup_type(token->next)) {
@@ -517,7 +517,7 @@ static struct token *attribute_specifier
 	token = expect(token, '(', "after attribute");

 	for (;;) {
-		const char *error;
+		const char *error_str;
 		struct ident *attribute_name;
 		struct expression *attribute_expr;

@@ -532,9 +532,9 @@ static struct token *attribute_specifier
 		attribute_expr = NULL;
 		if (match_op(token, '('))
 			token = parens_expression(token, &attribute_expr, "in attribute");
-		error = handle_attribute(ctype, attribute_name, attribute_expr);
-		if (error)
-			warning(token->pos, "attribute '%s': %s", show_ident(attribute_name),
error);
+		error_str = handle_attribute(ctype, attribute_name, attribute_expr);
+		if (error_str)
+			error(token->pos, "attribute '%s': %s", show_ident(attribute_name),
error_str);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -603,22 +603,22 @@ static void apply_ctype(struct position
 		}
 		dup = (mod & old) | (extra & old) | (extra & mod);
 		if (dup)
-			warning(pos, "Just how %sdo you want this type to be?",
+			error(pos, "Just how %sdo you want this type to be?",
 				modifier_string(dup));

 		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
 		if (conflict)
-			warning(pos, "You cannot have both long and short modifiers.");
+			error(pos, "You cannot have both long and short modifiers.");

 		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
 		if (conflict)
-			warning(pos, "You cannot have both signed and unsigned modifiers.");
+			error(pos, "You cannot have both signed and unsigned modifiers.");

 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
-			warning(pos, "multiple storage classes");
+			error(pos, "multiple storage classes");

 		ctype->modifiers = old | mod | extra;
 	}
@@ -665,7 +665,7 @@ static void check_modifiers(struct posit

 	wrong = mod & banned;
 	if (wrong)
-		warning(*pos, "modifier %sis invalid in this context",
+		error(*pos, "modifier %sis invalid in this context",
 		     modifier_string (wrong));
 }

@@ -747,7 +747,7 @@ static struct token *declaration_specifi
 		struct symbol *type;
 		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
 		if (!is_int_type(ctype->base_type)) {
-			warning(token->pos, "invalid modifier");
+			error(token->pos, "invalid modifier");
 			return token;
 		}
 		type = alloc_symbol(token->pos, SYM_BASETYPE);
@@ -893,7 +893,7 @@ static struct token *handle_bitfield(str
 	long long width;

 	if (!is_int_type(ctype->base_type)) {
-		warning(token->pos, "invalid bitfield specifier for type %s.",
+		error(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
 		return conditional_expression(token->next, &expr);
@@ -905,10 +905,10 @@ static struct token *handle_bitfield(str
 	bitfield->bit_size = width;

 	if (width < 0 || width > INT_MAX) {
-		warning(token->pos, "invalid bitfield width, %lld.", width);
+		error(token->pos, "invalid bitfield width, %lld.", width);
 		width = -1;
 	} else if (decl->ident && width == 0) {
-		warning(token->pos, "invalid named zero-width bitfield `%s'",
+		error(token->pos, "invalid named zero-width bitfield `%s'",
 		     show_ident(decl->ident));
 		width = -1;
 	} else if (decl->ident) {
@@ -917,14 +917,14 @@ static struct token *handle_bitfield(str
 		if (width == 1 && is_signed) {
 			// Valid values are either {-1;0} or {0}, depending on integer
 			// representation.  The latter makes for very efficient code...
-			warning(token->pos, "dubious one-bit signed bitfield");
+			error(token->pos, "dubious one-bit signed bitfield");
 		}
 		if (Wdefault_bitfield_sign &&
 		    base_type->type != SYM_ENUM &&
 		    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) &&
 		    is_signed) {
 			// The sign of bitfields is unspecified by default.
-			warning (token->pos, "dubious bitfield without explicit `signed' or
`unsigned'");
+			error (token->pos, "dubious bitfield without explicit `signed' or
`unsigned'");
 		}
 	}
 	bitfield->bit_size = width;
@@ -953,7 +953,7 @@ static struct token *struct_declaration_
 			token = token->next;
 		}
 		if (!match_op(token, ';')) {
-			warning(token->pos, "expected ; at end of declaration");
+			error(token->pos, "expected ; at end of declaration");
 			break;
 		}
 		token = token->next;
@@ -1159,7 +1159,7 @@ static void add_case_statement(struct st
 	struct symbol *sym;

 	if (!target) {
-		warning(stmt->pos, "not in switch scope");
+		error(stmt->pos, "not in switch scope");
 		stmt->type = STMT_NONE;
 		return;
 	}
@@ -1243,7 +1243,7 @@ static struct token *parse_do_statement(
 	if (token_type(token) == TOKEN_IDENT && token->ident == &while_ident)
 		token = token->next;
 	else
-		warning(token->pos, "expected 'while' after 'do'");
+		error(token->pos, "expected 'while' after 'do'");
 	token = parens_expression(token, &expr, "after 'do-while'");

 	stmt->iterator_post_condition = expr;
@@ -1278,7 +1278,7 @@ static struct token *statement(struct to
 			stmt->type = STMT_GOTO;
 			stmt->goto_label = target;
 			if (!target)
-				warning(stmt->pos, "break/continue not in iterator scope");
+				error(stmt->pos, "break/continue not in iterator scope");
 			return expect(token->next, ';', "at end of statement");
 		}
 		if (token->ident == &default_ident) {
@@ -1322,7 +1322,7 @@ default_statement:
 				stmt->goto_label = label_symbol(token);
 				token = token->next;
 			} else {
-				warning(token->pos, "Expected identifier or goto expression");
+				error(token->pos, "Expected identifier or goto expression");
 			}
 			return expect(token, ';', "at end of statement");
 		}
@@ -1482,7 +1482,7 @@ static struct token *single_initializer(
 			struct expression *from = NULL, *to = NULL, *expr;
 			token = constant_expression(token->next, &from);
 			if (!from) {
-				warning(token->pos, "Expected constant expression");
+				error(token->pos, "Expected constant expression");
 				break;
 			}
 			if (match_op(token, SPECIAL_ELLIPSIS))
@@ -1542,7 +1542,7 @@ struct token *initializer(struct express
 static void declare_argument(struct symbol *sym, struct symbol *fn)
 {
 	if (!sym->ident) {
-		warning(sym->pos, "no identifier for function argument");
+		error(sym->pos, "no identifier for function argument");
 		return;
 	}
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
@@ -1622,7 +1622,7 @@ static void apply_k_r_types(struct symbo
 			if (type->ident == arg->ident)
 				goto match;
 		} END_FOR_EACH_PTR(type);
-		warning(arg->pos, "missing type declaration for parameter '%s'",
show_ident(arg->ident));
+		error(arg->pos, "missing type declaration for parameter '%s'",
show_ident(arg->ident));
 		continue;
 match:
 		type->used = 1;
@@ -1652,7 +1652,7 @@ static struct token *parse_k_r_arguments
 	apply_k_r_types(args, decl);

 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected function body");
+		error(token->pos, "expected function body");
 		return token;
 	}
 	return parse_function_body(token, decl, list);
@@ -1720,7 +1720,7 @@ struct token *external_declaration(struc
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
 	} else if (base_type == &void_ctype && !(decl->ctype.modifiers &
MOD_EXTERN)) {
-		warning(token->pos, "void declaration");
+		error(token->pos, "void declaration");
 	}

 	for (;;) {
@@ -1749,7 +1749,7 @@ struct token *external_declaration(struc
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, decl, &ident);
 		if (!ident) {
-			warning(token->pos, "expected identifier name in type definition");
+			error(token->pos, "expected identifier name in type definition");
 			return token;
 		}

diff --git a/pre-process.c b/pre-process.c
--- a/pre-process.c
+++ b/pre-process.c
@@ -113,7 +113,7 @@ static int token_defined(struct token *t
 		return 0;
 	}

-	warning(token->pos, "expected preprocessor identifier");
+	error(token->pos, "expected preprocessor identifier");
 	return 0;
 }

@@ -257,7 +257,7 @@ static int collect_arguments(struct toke
 	return 1;

 Efew:
-	warning(what->pos, "macro \"%s\" requires %d arguments, but only %d
given",
+	error(what->pos, "macro \"%s\" requires %d arguments, but only %d given",
 		show_token(what), wanted, count);
 	goto out;
 Emany:
@@ -267,11 +267,11 @@ Emany:
 	}
 	if (eof_token(next))
 		goto Eclosing;
-	warning(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
+	error(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
 		show_token(what), count, wanted);
 	goto out;
 Eclosing:
-	warning(what->pos, "unterminated argument list invoking macro \"%s\"",
+	error(what->pos, "unterminated argument list invoking macro \"%s\"",
 		show_token(what));
 out:
 	what->next = next->next;
@@ -421,7 +421,7 @@ static int merge(struct token *left, str
 	default:
 		;
 	}
-	warning(left->pos, "'##' failed: concatenation is not a valid token");
+	error(left->pos, "'##' failed: concatenation is not a valid token");
 	return 0;
 }

@@ -602,7 +602,7 @@ static const char *token_name_sequence(s
 	}
 	*ptr = 0;
 	if (endop && !match_op(token, endop))
-		warning(start->pos, "expected '>' at end of filename");
+		error(start->pos, "expected '>' at end of filename");
 	return buffer;
 }

@@ -938,20 +938,20 @@ static struct token *parse_arguments(str


 Emissing:
-	warning(arg->pos, "parameter name missing");
+	error(arg->pos, "parameter name missing");
 	return NULL;
 Ebadstuff:
-	warning(arg->pos, "\"%s\" may not appear in macro parameter list",
+	error(arg->pos, "\"%s\" may not appear in macro parameter list",
 		show_token(arg));
 	return NULL;
 Enotclosed:
-	warning(arg->pos, "missing ')' in macro parameter list");
+	error(arg->pos, "missing ')' in macro parameter list");
 	return NULL;
 Eva_args:
-	warning(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99
variadic macro");
+	error(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99
variadic macro");
 	return NULL;
 Eargs:
-	warning(arg->pos, "too many arguments in macro definition");
+	error(arg->pos, "too many arguments in macro definition");
 	return NULL;
 }

@@ -1045,14 +1045,14 @@ static struct token *parse_expansion(str
 	return expansion;

 Equote:
-	warning(token->pos, "'#' is not followed by a macro parameter");
+	error(token->pos, "'#' is not followed by a macro parameter");
 	return NULL;

 Econcat:
-	warning(token->pos, "'##' cannot appear at the ends of macro expansion");
+	error(token->pos, "'##' cannot appear at the ends of macro expansion");
 	return NULL;
 Earg:
-	warning(token->pos, "too many instances of argument in body");
+	error(token->pos, "too many instances of argument in body");
 	return NULL;
 }

@@ -1064,7 +1064,7 @@ static int do_handle_define(struct strea
 	struct ident *name;

 	if (token_type(left) != TOKEN_IDENT) {
-		warning(token->pos, "expected identifier to 'define'");
+		error(token->pos, "expected identifier to 'define'");
 		return 0;
 	}
 	if (false_nesting)
@@ -1136,7 +1136,7 @@ static int handle_undef(struct stream *s
 	struct symbol **sym;

 	if (token_type(left) != TOKEN_IDENT) {
-		warning(token->pos, "expected identifier to 'undef'");
+		error(token->pos, "expected identifier to 'undef'");
 		return 0;
 	}
 	if (false_nesting)
@@ -1239,7 +1239,7 @@ static int expression_value(struct token
 		case 3:
 			state = 0;
 			if (!match_op(p, ')'))
-				warning(p->pos, "missing ')' after \"defined\"");
+				error(p->pos, "missing ')' after \"defined\"");
 			*list = p->next;
 			continue;
 		}
@@ -1248,7 +1248,7 @@ static int expression_value(struct token

 	p = constant_expression(*where, &expr);
 	if (!eof_token(p))
-		warning(p->pos, "garbage at end: %s", show_token_sequence(p));
+		error(p->pos, "garbage at end: %s", show_token_sequence(p));
 	value = get_expression_value(expr);
 	return value != 0;
 }
@@ -1274,10 +1274,10 @@ static int handle_elif(struct stream * s
 		MARK_STREAM_NONCONST(token->pos);

 	if (stream->nesting > if_nesting)
-		warning(token->pos, "unmatched #elif within stream");
+		error(token->pos, "unmatched #elif within stream");

 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warning(token->pos, "#elif after #else");
+		error(token->pos, "#elif after #else");

 	if (false_nesting) {
 		/* If this whole if-thing is if'ed out, an elif cannot help */
@@ -1301,10 +1301,10 @@ static int handle_else(struct stream *st
 		MARK_STREAM_NONCONST(token->pos);

 	if (stream->nesting > if_nesting)
-		warning(token->pos, "unmatched #else within stream");
+		error(token->pos, "unmatched #else within stream");

 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warning(token->pos, "#else after #else");
+		error(token->pos, "#else after #else");
 	else
 		elif_ignore[if_nesting-1] |= ELIF_SEEN_ELSE;

@@ -1328,7 +1328,7 @@ static int handle_endif(struct stream *s
 		stream->constant = CONSTANT_FILE_MAYBE;

 	if (stream->nesting > if_nesting)
-		warning(token->pos, "unmatched #endif in stream");
+		error(token->pos, "unmatched #endif in stream");
 	if (false_nesting)
 		false_nesting--;
 	else
@@ -1351,7 +1351,7 @@ static const char *show_token_sequence(s
 		int len = strlen(val);

 		if (ptr + whitespace + len >= buffer + sizeof(buffer)) {
-			warning(token->pos, "too long token expansion");
+			error(token->pos, "too long token expansion");
 			break;
 		}

@@ -1382,7 +1382,7 @@ static int handle_error(struct stream *s
 		return free_preprocessor_line(token);
 	if (stream->constant == CONSTANT_FILE_MAYBE)
 		MARK_STREAM_NONCONST(token->pos);
-	warning(token->pos, "%s", show_token_sequence(token->next));
+	error(token->pos, "%s", show_token_sequence(token->next));
 	return free_preprocessor_line(token);
 }

@@ -1454,7 +1454,7 @@ static int handle_add_isystem(struct str
 		if (eof_token(token))
 			return 1;
 		if (token_type(token) != TOKEN_STRING) {
-			warning(token->pos, "expected path string");
+			error(token->pos, "expected path string");
 			return 1;
 		}
 		add_path_entry(token, token->string->data, &sys_includepath,
sys_includepath);
@@ -1485,7 +1485,7 @@ static int handle_add_dirafter(struct st
 		if (eof_token(token))
 			return 1;
 		if (token_type(token) != TOKEN_STRING) {
-			warning(token->pos, "expected path string");
+			error(token->pos, "expected path string");
 			return 1;
 		}
 		add_dirafter_entry(token, token->string->data);
@@ -1604,7 +1604,7 @@ static void handle_preprocessor_line(str
 			return;
 	}

-	warning(token->pos, "unrecognized preprocessor line '%s'",
show_token_sequence(token));
+	error(token->pos, "unrecognized preprocessor line '%s'",
show_token_sequence(token));
 }

 static void preprocessor_line(struct stream *stream, struct token **line)
@@ -1641,7 +1641,7 @@ static void do_preprocess(struct token *
 		switch (token_type(next)) {
 		case TOKEN_STREAMEND:
 			if (stream->nesting < if_nesting + 1) {
-				warning(unmatched_if_pos, "unterminated preprocessor conditional");
+				error(unmatched_if_pos, "unterminated preprocessor conditional");
 				// Pretend to see a series of #endifs
 				MARK_STREAM_NONCONST(next->pos);
 				do {
diff --git a/symbol.c b/symbol.c
--- a/symbol.c
+++ b/symbol.c
@@ -394,16 +394,16 @@ struct symbol *examine_symbol_type(struc
 		break;
 	}
 	case SYM_PREPROCESSOR:
-		warning(sym->pos, "ctype on preprocessor command? (%s)",
show_ident(sym->ident));
+		error(sym->pos, "ctype on preprocessor command? (%s)",
show_ident(sym->ident));
 		return NULL;
 	case SYM_UNINITIALIZED:
-		warning(sym->pos, "ctype on uninitialized symbol %p", sym);
+		error(sym->pos, "ctype on uninitialized symbol %p", sym);
 		return NULL;
 	case SYM_RESTRICT:
 		examine_base_type(sym);
 		return sym;
 	default:
-		warning(sym->pos, "Examining unknown symbol type %d", sym->type);
+		error(sym->pos, "Examining unknown symbol type %d", sym->type);
 		break;
 	}
 	return sym;
@@ -441,11 +441,11 @@ void bind_symbol(struct symbol *sym, str
 {
 	struct scope *scope;
 	if (sym->id_list) {
-		warning(sym->pos, "internal error: symbol type already bound");
+		error(sym->pos, "internal error: symbol type already bound");
 		return;
 	}
 	if (ident->reserved && (ns & (NS_TYPEDEF | NS_STRUCT | NS_LABEL |
NS_SYMBOL))) {
-		warning(sym->pos, "Trying to use reserved word '%s' as identifier",
show_ident(ident));
+		error(sym->pos, "Trying to use reserved word '%s' as identifier",
show_ident(ident));
 		return;
 	}
 	sym->namespace = ns;
diff --git a/tokenize.c b/tokenize.c
--- a/tokenize.c
+++ b/tokenize.c
@@ -522,7 +522,7 @@ static int get_char_token(int next, stre

 	next = escapechar(next, '\'', stream, &value);
 	if (value == '\'' || next != '\'') {
-		warning(stream_pos(stream), "Bad character constant");
+		error(stream_pos(stream), "Bad character constant");
 		drop_token(stream);
 		return next;
 	}



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: [PATCH] replaced warnings with errors.
Date: Wed, 21 Sep 2005 18:53:08 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHGEGBCGAA.mshah () teja ! com>
--------------------

> -----Original Message-----
> From: linux-sparse-owner@vger.kernel.org
> [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Linus Torvalds
> Sent: Friday, September 16, 2005 4:44 PM
> To: Mitesh Shah
> Cc: Linux-Sparse
> Subject: Re: [PATCH] replaced warnings with errors.
> 
> 
> 
> 
> On Fri, 16 Sep 2005, Mitesh Shah wrote:
> >
> > Any input about this patch?
> 
> It's seriously whitespace-damaged, and won't apply.
> 
> Also, there's at least some warnings that shouldn't have been converted:
> 
> >  	if (sym == &zero_int) {
> >  		if (Wundefined_preprocessor)
> > -			warning(expr->pos, "undefined preprocessor identifier '%s'", show_ident(expr->symbol_name));
> > +			error(expr->pos, "undefined preprocessor identifier '%s'", show_ident(expr->symbol_name));
> 
> That's definitely just a warning. The -Wundefined-preprocessor thing is
> meant for "warn if undefined symbol degenerates into 0 in the
> preprocessor".
> 
> Also, it would be good to hear whether doing a "make C=2" for the kernel 
> with this has any errors..
> 
> 		Linus
> -

Ok, resending it after the fix. Hopefully, the white-space should not be an issue this time or else I will attach it as a file.




diff --git a/evaluate.c b/evaluate.c
--- a/evaluate.c
+++ b/evaluate.c
@@ -38,7 +38,7 @@ static struct symbol *evaluate_symbol_ex
 	struct symbol *base_type;
 
 	if (!sym) {
-		warning(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
+		error(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -46,7 +46,7 @@ static struct symbol *evaluate_symbol_ex
 
 	base_type = get_base_type(sym);
 	if (!base_type) {
-		warning(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
+		error(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -312,7 +312,7 @@ static inline int is_string_type(struct 
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warning(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
+	error(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
@@ -498,7 +498,7 @@ static struct symbol *evaluate_ptr_add(s
 	examine_symbol_type(ctype);
 
 	if (!ctype->ctype.base_type) {
-		warning(expr->pos, "missing type information");
+		error(expr->pos, "missing type information");
 		return NULL;
 	}
 
@@ -756,7 +756,7 @@ static struct symbol *evaluate_ptr_sub(s
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			warning(expr->pos, "subtraction of different types can't work (%s)", typediff);
+			error(expr->pos, "subtraction of different types can't work (%s)", typediff);
 			return NULL;
 		}
 	}
@@ -766,7 +766,7 @@ static struct symbol *evaluate_ptr_sub(s
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		warning(expr->pos, "subtraction of functions? Share your drugs");
+		error(expr->pos, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = get_base_type(ctype);
@@ -1023,7 +1023,7 @@ static struct symbol *evaluate_condition
 	typediff = type_difference(ltype, rtype, MOD_IGN, MOD_IGN);
 	if (!typediff)
 		goto out;
-	warning(expr->pos, "incompatible types in conditional expression (%s)", typediff);
+	error(expr->pos, "incompatible types in conditional expression (%s)", typediff);
 	return NULL;
 
 out:
@@ -1055,7 +1055,7 @@ static int compatible_assignment_types(s
 			goto Cast;
 	} else if (is_float_type(target)) {
 		if (!compatible_float_op(op)) {
-			warning(expr->pos, "invalid assignment");
+			error(expr->pos, "invalid assignment");
 			return 0;
 		}
 		if (is_int_type(source))
@@ -1064,7 +1064,7 @@ static int compatible_assignment_types(s
 			goto Cast;
 	} else if (is_restricted_type(target)) {
 		if (restricted_binop(op, target)) {
-			warning(expr->pos, "bad restricted assignment");
+			error(expr->pos, "bad restricted assignment");
 			return 0;
 		}
 		if (!restricted_value(*rp, target))
@@ -1075,11 +1075,11 @@ static int compatible_assignment_types(s
 			return 1;
 		}
 		if (op != '=') {
-			warning(expr->pos, "invalid pointer assignment");
+			error(expr->pos, "invalid pointer assignment");
 			return 0;
 		}
 	} else if (op != '=') {
-		warning(expr->pos, "invalid assignment");
+		error(expr->pos, "invalid assignment");
 		return 0;
 	}
 
@@ -1118,7 +1118,7 @@ static int compatible_assignment_types(s
 		}
 	}
 
-	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
+	error(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
@@ -1131,7 +1131,7 @@ Cast:
 static void evaluate_assign_to(struct expression *left, struct symbol *type)
 {
 	if (type->ctype.modifiers & MOD_CONST)
-		warning(left->pos, "assignment to const expression");
+		error(left->pos, "assignment to const expression");
 	if (type->type == SYM_NODE)
 		type->ctype.modifiers |= MOD_ASSIGNED;
 }
@@ -1143,7 +1143,7 @@ static struct symbol *evaluate_assignmen
 	struct symbol *ltype, *rtype;
 
 	if (!lvalue_expression(left)) {
-		warning(expr->pos, "not an lvalue");
+		error(expr->pos, "not an lvalue");
 		return NULL;
 	}
 
@@ -1308,7 +1308,7 @@ static struct symbol *degenerate(struct 
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			warning(expr->pos, "strange non-value function or array");
+			error(expr->pos, "strange non-value function or array");
 			return &bad_ctype;
 		}
 		*expr = *expr->unop;
@@ -1326,7 +1326,7 @@ static struct symbol *evaluate_addressof
 	struct symbol *ctype;
 
 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		warning(expr->pos, "not addressable");
+		error(expr->pos, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1370,7 +1370,7 @@ static struct symbol *evaluate_dereferen
 
 	switch (ctype->type) {
 	default:
-		warning(expr->pos, "cannot derefence this type");
+		error(expr->pos, "cannot derefence this type");
 		return NULL;
 	case SYM_PTR:
 		node->ctype.modifiers = target->ctype.modifiers & MOD_SPECIFIER;
@@ -1379,7 +1379,7 @@ static struct symbol *evaluate_dereferen
 
 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			warning(op->pos, "non-lvalue array??");
+			error(op->pos, "non-lvalue array??");
 			return NULL;
 		}
 
@@ -1411,11 +1411,11 @@ static struct symbol *evaluate_postop(st
 	struct symbol *ctype = op->ctype;
 
 	if (!lvalue_expression(expr->unop)) {
-		warning(expr->pos, "need lvalue expression for ++/--");
+		error(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
-		warning(expr->pos, "bad operation on restricted");
+		error(expr->pos, "bad operation on restricted");
 		return NULL;
 	}
 
@@ -1574,7 +1574,7 @@ static struct symbol *evaluate_member_de
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		warning(expr->pos, "bad member name");
+		error(expr->pos, "bad member name");
 		return NULL;
 	}
 
@@ -1587,7 +1587,7 @@ static struct symbol *evaluate_member_de
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		warning(expr->pos, "expected structure or union");
+		error(expr->pos, "expected structure or union");
 		return NULL;
 	}
 	offset = 0;
@@ -1600,7 +1600,7 @@ static struct symbol *evaluate_member_de
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		warning(expr->pos, "no member '%s' in %s %.*s",
+		error(expr->pos, "no member '%s' in %s %.*s",
 			show_ident(ident), type, namelen, name);
 		return NULL;
 	}
@@ -1690,7 +1690,7 @@ static struct symbol *evaluate_type_info
 	}
 	examine_symbol_type(sym);
 	if (is_bitfield_type(sym)) {
-		warning(expr->pos, "trying to examine bitfield type");
+		error(expr->pos, "trying to examine bitfield type");
 		return NULL;
 	}
 	return sym;
@@ -1707,7 +1707,7 @@ static struct symbol *evaluate_sizeof(st
 
 	size = type->bit_size;
 	if ((size < 0) || (size & 7))
-		warning(expr->pos, "cannot size expression");
+		error(expr->pos, "cannot size expression");
 	expr->type = EXPR_VALUE;
 	expr->value = size >> 3;
 	expr->ctype = size_t_ctype;
@@ -1735,7 +1735,7 @@ static struct symbol *evaluate_ptrsizeof
 		if (type)
 			break;
 	default:
-		warning(expr->pos, "expected pointer expression");
+		error(expr->pos, "expected pointer expression");
 		return NULL;
 	}
 	size = type->bit_size;
@@ -1854,7 +1854,7 @@ static void evaluate_array_initializer(s
 static void evaluate_scalar_initializer(struct symbol *ctype, struct expression *expr)
 {
 	if (expression_list_size(expr->expr_list) != 1) {
-		warning(expr->pos, "unexpected compound initializer");
+		error(expr->pos, "unexpected compound initializer");
 		return;
 	}
 	evaluate_array_initializer(ctype, expr);
@@ -2128,7 +2128,7 @@ static struct symbol *evaluate_cast(stru
 
 	t2 = target->ctype;
 	if (!t2) {
-		warning(expr->pos, "cast from unknown type");
+		error(expr->pos, "cast from unknown type");
 		goto out;
 	}
 	if (t2->type == SYM_NODE)
@@ -2217,15 +2217,15 @@ static struct symbol *evaluate_call(stru
 	if (!evaluate_arguments(sym, ctype, arglist))
 		return NULL;
 	if (ctype->type != SYM_FN) {
-		warning(expr->pos, "not a function %s", show_ident(sym->ident));
+		error(expr->pos, "not a function %s", show_ident(sym->ident));
 		return NULL;
 	}
 	args = expression_list_size(expr->args);
 	fnargs = symbol_list_size(ctype->arguments);
 	if (args < fnargs)
-		warning(expr->pos, "not enough arguments for function %s", show_ident(sym->ident));
+		error(expr->pos, "not enough arguments for function %s", show_ident(sym->ident));
 	if (args > fnargs && !ctype->variadic)
-		warning(expr->pos, "too many arguments for function %s", show_ident(sym->ident));
+		error(expr->pos, "too many arguments for function %s", show_ident(sym->ident));
 	if (sym->type == SYM_NODE) {
 		if (evaluate_symbol_call(expr))
 			return expr->ctype;
@@ -2244,7 +2244,7 @@ struct symbol *evaluate_expression(struc
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		warning(expr->pos, "value expression without a type");
+		error(expr->pos, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2319,10 +2319,10 @@ struct symbol *evaluate_expression(struc
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		warning(expr->pos, "internal front-end error: initializer in expression");
+		error(expr->pos, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		warning(expr->pos, "internal front-end error: SLICE re-evaluated");
+		error(expr->pos, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
@@ -2339,7 +2339,7 @@ static void check_duplicates(struct symb
 		declared++;
 		typediff = type_difference(sym, next, 0, 0);
 		if (typediff) {
-			warning(sym->pos, "symbol '%s' redeclared with different type (originally declared at %s:%d) - %s",
+			error(sym->pos, "symbol '%s' redeclared with different type (originally declared at %s:%d) - %s",
 				show_ident(sym->ident),
 				stream_name(next->pos.stream), next->pos.line, typediff);
 			return;
@@ -2411,12 +2411,12 @@ static struct symbol *evaluate_return_ex
 	fntype = current_fn->ctype.base_type;
 	if (!fntype || fntype == &void_ctype) {
 		if (expr && ctype != &void_ctype)
-			warning(expr->pos, "return expression in %s function", fntype?"void":"typeless");
+			error(expr->pos, "return expression in %s function", fntype?"void":"typeless");
 		return NULL;
 	}
 
 	if (!expr) {
-		warning(stmt->pos, "return with no return value");
+		error(stmt->pos, "return with no return value");
 		return NULL;
 	}
 	if (!ctype)
@@ -2451,7 +2451,7 @@ static void verify_output_constraint(str
 	case '+':	/* Update */
 		break;
 	default:
-		warning(expr->pos, "output constraint is not an assignment constraint (\"%s\")", constraint);
+		error(expr->pos, "output constraint is not an assignment constraint (\"%s\")", constraint);
 	}
 }
 
@@ -2460,7 +2460,7 @@ static void verify_input_constraint(stru
 	switch (*constraint) {
 	case '=':	/* Assignment */
 	case '+':	/* Update */
-		warning(expr->pos, "input constraint with assignment (\"%s\")", constraint);
+		error(expr->pos, "input constraint with assignment (\"%s\")", constraint);
 	}
 }
 
@@ -2471,7 +2471,7 @@ static void evaluate_asm_statement(struc
 
 	expr = stmt->asm_string;
 	if (!expr || expr->type != EXPR_STRING) {
-		warning(stmt->pos, "need constant string for inline asm");
+		error(stmt->pos, "need constant string for inline asm");
 		return;
 	}
 
@@ -2488,7 +2488,7 @@ static void evaluate_asm_statement(struc
 		case 1: /* Constraint */
 			state = 2;
 			if (!expr || expr->type != EXPR_STRING) {
-				warning(expr ? expr->pos : stmt->pos, "asm output constraint is not a string");
+				error(expr ? expr->pos : stmt->pos, "asm output constraint is not a string");
 				*THIS_ADDRESS(expr) = NULL;
 				continue;
 			}
@@ -2519,7 +2519,7 @@ static void evaluate_asm_statement(struc
 		case 1:	/* Constraint */
 			state = 2;
 			if (!expr || expr->type != EXPR_STRING) {
-				warning(expr ? expr->pos : stmt->pos, "asm input constraint is not a string");
+				error(expr ? expr->pos : stmt->pos, "asm input constraint is not a string");
 				*THIS_ADDRESS(expr) = NULL;
 				continue;
 			}
@@ -2536,12 +2536,12 @@ static void evaluate_asm_statement(struc
 
 	FOR_EACH_PTR(stmt->asm_clobbers, expr) {
 		if (!expr) {
-			warning(stmt->pos, "bad asm output");
+			error(stmt->pos, "bad asm output");
 			return;
 		}
 		if (expr->type == EXPR_STRING)
 			continue;
-		warning(expr->pos, "asm clobber is not a string");
+		error(expr->pos, "asm clobber is not a string");
 	} END_FOR_EACH_PTR(expr);
 }
 
diff --git a/expand.c b/expand.c
--- a/expand.c
+++ b/expand.c
@@ -900,7 +900,7 @@ static int expand_expression(struct expr
 	case EXPR_SIZEOF:
 	case EXPR_PTRSIZEOF:
 	case EXPR_ALIGNOF:
-		warning(expr->pos, "internal front-end error: sizeof in expansion?");
+		error(expr->pos, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -911,7 +911,7 @@ static void expand_const_expression(stru
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			warning(expr->pos, "Expected constant expression in %s", where);
+			error(expr->pos, "Expected constant expression in %s", where);
 	}
 }
 
@@ -1083,12 +1083,12 @@ long long get_expression_value(struct ex
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		warning(expr->pos, "bad constant expression type");
+		error(expr->pos, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		warning(expr->pos, "bad constant expression");
+		error(expr->pos, "bad constant expression");
 		return 0;
 	}
 
diff --git a/expression.c b/expression.c
--- a/expression.c
+++ b/expression.c
@@ -326,7 +326,7 @@ struct token *primary_expression(struct 
 		 *	if (typeof(a) == int) ..
 		 */
 		if (sym && sym->namespace == NS_TYPEDEF) {
-			warning(token->pos, "typename in expression");
+			error(token->pos, "typename in expression");
 			sym = NULL;
 		}
 		expr->symbol_name = token->ident;
@@ -428,7 +428,7 @@ static struct token *postfix_expression(
 			deref->deref = expr;
 			token = token->next;
 			if (token_type(token) != TOKEN_IDENT) {
-				warning(token->pos, "Expected member name");
+				error(token->pos, "Expected member name");
 				break;
 			}
 			deref->member = token->ident;
@@ -520,7 +520,7 @@ static struct token *unary_expression(st
 
 			next = cast_expression(token->next, &unop);
 			if (!unop) {
-				warning(token->pos, "Syntax error in unary expression");
+				error(token->pos, "Syntax error in unary expression");
 				return next;
 			}
 			unary = alloc_expression(token->pos, EXPR_PREOP);
@@ -607,7 +607,7 @@ static struct token *cast_expression(str
 			top = alloc_expression(next->pos, type);	\
 			next = inner(next->next, &right);		\
 			if (!right) {					\
-				warning(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
+				error(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
 			top->op = op;					\
diff --git a/inline.c b/inline.c
--- a/inline.c
+++ b/inline.c
@@ -469,7 +469,7 @@ int inline_function(struct expression *e
 	struct expression *arg;
 
 	if (!fn->inline_stmt) {
-		warning(fn->pos, "marked inline, but without a definition");
+		error(fn->pos, "marked inline, but without a definition");
 		return 0;
 	}
 	if (fn->expanding)
diff --git a/lib.c b/lib.c
--- a/lib.c
+++ b/lib.c
@@ -29,6 +29,7 @@
 #include "target.h"
 
 int verbose, optimize, optimize_size, preprocessing;
+int die_if_error = 0;
 
 #ifndef __GNUC__
 # define __GNUC__ 2
@@ -53,8 +54,8 @@ struct token *expect(struct token *token
 		static struct token bad_token;
 		if (token != &bad_token) {
 			bad_token.next = token;
-			warning(token->pos, "Expected %s %s", show_special(op), where);
-			warning(token->pos, "got %s", show_token(token));
+			error(token->pos, "Expected %s %s", show_special(op), where);
+			error(token->pos, "got %s", show_token(token));
 		}
 		if (op == ';')
 			return skip_to(token, op);
@@ -124,7 +125,7 @@ void error(struct position pos, const ch
 {
 	static int errors = 0;
 	va_list args;
-
+        die_if_error = 1;
 	/* Shut up warnings after an error */
 	max_warnings = 0;
 	if (errors > 100) {
@@ -178,6 +179,7 @@ int preprocess_only;
 char *include;
 int include_fd = -1;
 
+
 void add_pre_buffer(const char *fmt, ...)
 {
 	va_list args;
diff --git a/parse.c b/parse.c
--- a/parse.c
+++ b/parse.c
@@ -142,7 +142,7 @@ static struct token *struct_union_enum_s
 
 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected declaration");
+		error(token->pos, "expected declaration");
 		ctype->base_type = &bad_ctype;
 		return token;
 	}
@@ -290,7 +290,7 @@ static struct token *parse_enum_declarat
 		token = token->next;
 	}
 	if (!base_type) {
-		warning(token->pos, "bad enum definition");
+		error(token->pos, "bad enum definition");
 		base_type = &bad_ctype;
 	}
 	else if (!is_int_type(base_type))
@@ -333,7 +333,7 @@ static struct token *typeof_specifier(st
 	struct symbol *sym;
 
 	if (!match_op(token, '(')) {
-		warning(token->pos, "expected '(' after typeof");
+		error(token->pos, "expected '(' after typeof");
 		return token;
 	}
 	if (lookup_type(token->next)) {
@@ -517,7 +517,7 @@ static struct token *attribute_specifier
 	token = expect(token, '(', "after attribute");
 
 	for (;;) {
-		const char *error;
+		const char *error_str;
 		struct ident *attribute_name;
 		struct expression *attribute_expr;
 
@@ -532,9 +532,9 @@ static struct token *attribute_specifier
 		attribute_expr = NULL;
 		if (match_op(token, '('))
 			token = parens_expression(token, &attribute_expr, "in attribute");
-		error = handle_attribute(ctype, attribute_name, attribute_expr);
-		if (error)
-			warning(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
+		error_str = handle_attribute(ctype, attribute_name, attribute_expr);
+		if (error_str)
+			error(token->pos, "attribute '%s': %s", show_ident(attribute_name), error_str);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -603,22 +603,22 @@ static void apply_ctype(struct position 
 		}
 		dup = (mod & old) | (extra & old) | (extra & mod);
 		if (dup)
-			warning(pos, "Just how %sdo you want this type to be?",
+			error(pos, "Just how %sdo you want this type to be?",
 				modifier_string(dup));
 
 		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
 		if (conflict)
-			warning(pos, "You cannot have both long and short modifiers.");
+			error(pos, "You cannot have both long and short modifiers.");
 
 		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
 		if (conflict)
-			warning(pos, "You cannot have both signed and unsigned modifiers.");
+			error(pos, "You cannot have both signed and unsigned modifiers.");
 
 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
-			warning(pos, "multiple storage classes");
+			error(pos, "multiple storage classes");
 
 		ctype->modifiers = old | mod | extra;
 	}
@@ -665,7 +665,7 @@ static void check_modifiers(struct posit
 
 	wrong = mod & banned;
 	if (wrong)
-		warning(*pos, "modifier %sis invalid in this context",
+		error(*pos, "modifier %sis invalid in this context",
 		     modifier_string (wrong));
 }
 
@@ -747,7 +747,7 @@ static struct token *declaration_specifi
 		struct symbol *type;
 		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
 		if (!is_int_type(ctype->base_type)) {
-			warning(token->pos, "invalid modifier");
+			error(token->pos, "invalid modifier");
 			return token;
 		}
 		type = alloc_symbol(token->pos, SYM_BASETYPE);
@@ -893,7 +893,7 @@ static struct token *handle_bitfield(str
 	long long width;
 
 	if (!is_int_type(ctype->base_type)) {
-		warning(token->pos, "invalid bitfield specifier for type %s.",
+		error(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
 		return conditional_expression(token->next, &expr);
@@ -905,10 +905,10 @@ static struct token *handle_bitfield(str
 	bitfield->bit_size = width;
 
 	if (width < 0 || width > INT_MAX) {
-		warning(token->pos, "invalid bitfield width, %lld.", width);
+		error(token->pos, "invalid bitfield width, %lld.", width);
 		width = -1;
 	} else if (decl->ident && width == 0) {
-		warning(token->pos, "invalid named zero-width bitfield `%s'",
+		error(token->pos, "invalid named zero-width bitfield `%s'",
 		     show_ident(decl->ident));
 		width = -1;
 	} else if (decl->ident) {
@@ -917,14 +917,14 @@ static struct token *handle_bitfield(str
 		if (width == 1 && is_signed) {
 			// Valid values are either {-1;0} or {0}, depending on integer
 			// representation.  The latter makes for very efficient code...
-			warning(token->pos, "dubious one-bit signed bitfield");
+			error(token->pos, "dubious one-bit signed bitfield");
 		}
 		if (Wdefault_bitfield_sign &&
 		    base_type->type != SYM_ENUM &&
 		    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) &&
 		    is_signed) {
 			// The sign of bitfields is unspecified by default.
-			warning (token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
+			error (token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
 		}
 	}
 	bitfield->bit_size = width;
@@ -953,7 +953,7 @@ static struct token *struct_declaration_
 			token = token->next;
 		}
 		if (!match_op(token, ';')) {
-			warning(token->pos, "expected ; at end of declaration");
+			error(token->pos, "expected ; at end of declaration");
 			break;
 		}
 		token = token->next;
@@ -1159,7 +1159,7 @@ static void add_case_statement(struct st
 	struct symbol *sym;
 
 	if (!target) {
-		warning(stmt->pos, "not in switch scope");
+		error(stmt->pos, "not in switch scope");
 		stmt->type = STMT_NONE;
 		return;
 	}
@@ -1243,7 +1243,7 @@ static struct token *parse_do_statement(
 	if (token_type(token) == TOKEN_IDENT && token->ident == &while_ident)
 		token = token->next;
 	else
-		warning(token->pos, "expected 'while' after 'do'");
+		error(token->pos, "expected 'while' after 'do'");
 	token = parens_expression(token, &expr, "after 'do-while'");
 
 	stmt->iterator_post_condition = expr;
@@ -1278,7 +1278,7 @@ static struct token *statement(struct to
 			stmt->type = STMT_GOTO;
 			stmt->goto_label = target;
 			if (!target)
-				warning(stmt->pos, "break/continue not in iterator scope");
+				error(stmt->pos, "break/continue not in iterator scope");
 			return expect(token->next, ';', "at end of statement");
 		}
 		if (token->ident == &default_ident) {
@@ -1322,7 +1322,7 @@ default_statement:
 				stmt->goto_label = label_symbol(token);
 				token = token->next;
 			} else {
-				warning(token->pos, "Expected identifier or goto expression");
+				error(token->pos, "Expected identifier or goto expression");
 			}
 			return expect(token, ';', "at end of statement");
 		}
@@ -1482,7 +1482,7 @@ static struct token *single_initializer(
 			struct expression *from = NULL, *to = NULL, *expr;
 			token = constant_expression(token->next, &from);
 			if (!from) {
-				warning(token->pos, "Expected constant expression");
+				error(token->pos, "Expected constant expression");
 				break;
 			}
 			if (match_op(token, SPECIAL_ELLIPSIS))
@@ -1542,7 +1542,7 @@ struct token *initializer(struct express
 static void declare_argument(struct symbol *sym, struct symbol *fn)
 {
 	if (!sym->ident) {
-		warning(sym->pos, "no identifier for function argument");
+		error(sym->pos, "no identifier for function argument");
 		return;
 	}
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
@@ -1622,7 +1622,7 @@ static void apply_k_r_types(struct symbo
 			if (type->ident == arg->ident)
 				goto match;
 		} END_FOR_EACH_PTR(type);
-		warning(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
+		error(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
 		continue;
 match:
 		type->used = 1;
@@ -1652,7 +1652,7 @@ static struct token *parse_k_r_arguments
 	apply_k_r_types(args, decl);
 
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected function body");
+		error(token->pos, "expected function body");
 		return token;
 	}
 	return parse_function_body(token, decl, list);
@@ -1720,7 +1720,7 @@ struct token *external_declaration(struc
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
 	} else if (base_type == &void_ctype && !(decl->ctype.modifiers & MOD_EXTERN)) {
-		warning(token->pos, "void declaration");
+		error(token->pos, "void declaration");
 	}
 
 	for (;;) {
@@ -1749,7 +1749,7 @@ struct token *external_declaration(struc
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, decl, &ident);
 		if (!ident) {
-			warning(token->pos, "expected identifier name in type definition");
+			error(token->pos, "expected identifier name in type definition");
 			return token;
 		}
 
diff --git a/pre-process.c b/pre-process.c
--- a/pre-process.c
+++ b/pre-process.c
@@ -113,7 +113,7 @@ static int token_defined(struct token *t
 		return 0;
 	}
 
-	warning(token->pos, "expected preprocessor identifier");
+	error(token->pos, "expected preprocessor identifier");
 	return 0;
 }
 
@@ -257,7 +257,7 @@ static int collect_arguments(struct toke
 	return 1;
 
 Efew:
-	warning(what->pos, "macro \"%s\" requires %d arguments, but only %d given",
+	error(what->pos, "macro \"%s\" requires %d arguments, but only %d given",
 		show_token(what), wanted, count);
 	goto out;
 Emany:
@@ -267,11 +267,11 @@ Emany:
 	}
 	if (eof_token(next))
 		goto Eclosing;
-	warning(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
+	error(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
 		show_token(what), count, wanted);
 	goto out;
 Eclosing:
-	warning(what->pos, "unterminated argument list invoking macro \"%s\"",
+	error(what->pos, "unterminated argument list invoking macro \"%s\"",
 		show_token(what));
 out:
 	what->next = next->next;
@@ -421,7 +421,7 @@ static int merge(struct token *left, str
 	default:
 		;
 	}
-	warning(left->pos, "'##' failed: concatenation is not a valid token");
+	error(left->pos, "'##' failed: concatenation is not a valid token");
 	return 0;
 }
 
@@ -602,7 +602,7 @@ static const char *token_name_sequence(s
 	}
 	*ptr = 0;
 	if (endop && !match_op(token, endop))
-		warning(start->pos, "expected '>' at end of filename");
+		error(start->pos, "expected '>' at end of filename");
 	return buffer;
 }
 
@@ -938,20 +938,20 @@ static struct token *parse_arguments(str
 
 
 Emissing:
-	warning(arg->pos, "parameter name missing");
+	error(arg->pos, "parameter name missing");
 	return NULL;
 Ebadstuff:
-	warning(arg->pos, "\"%s\" may not appear in macro parameter list",
+	error(arg->pos, "\"%s\" may not appear in macro parameter list",
 		show_token(arg));
 	return NULL;
 Enotclosed:
-	warning(arg->pos, "missing ')' in macro parameter list");
+	error(arg->pos, "missing ')' in macro parameter list");
 	return NULL;
 Eva_args:
-	warning(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro");
+	error(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro");
 	return NULL;
 Eargs:
-	warning(arg->pos, "too many arguments in macro definition");
+	error(arg->pos, "too many arguments in macro definition");
 	return NULL;
 }
 
@@ -1045,14 +1045,14 @@ static struct token *parse_expansion(str
 	return expansion;
 
 Equote:
-	warning(token->pos, "'#' is not followed by a macro parameter");
+	error(token->pos, "'#' is not followed by a macro parameter");
 	return NULL;
 
 Econcat:
-	warning(token->pos, "'##' cannot appear at the ends of macro expansion");
+	error(token->pos, "'##' cannot appear at the ends of macro expansion");
 	return NULL;
 Earg:
-	warning(token->pos, "too many instances of argument in body");
+	error(token->pos, "too many instances of argument in body");
 	return NULL;
 }
 
@@ -1064,7 +1064,7 @@ static int do_handle_define(struct strea
 	struct ident *name;
 
 	if (token_type(left) != TOKEN_IDENT) {
-		warning(token->pos, "expected identifier to 'define'");
+		error(token->pos, "expected identifier to 'define'");
 		return 0;
 	}
 	if (false_nesting)
@@ -1136,7 +1136,7 @@ static int handle_undef(struct stream *s
 	struct symbol **sym;
 
 	if (token_type(left) != TOKEN_IDENT) {
-		warning(token->pos, "expected identifier to 'undef'");
+		error(token->pos, "expected identifier to 'undef'");
 		return 0;
 	}
 	if (false_nesting)
@@ -1239,7 +1239,7 @@ static int expression_value(struct token
 		case 3:
 			state = 0;
 			if (!match_op(p, ')'))
-				warning(p->pos, "missing ')' after \"defined\"");
+				error(p->pos, "missing ')' after \"defined\"");
 			*list = p->next;
 			continue;
 		}
@@ -1248,7 +1248,7 @@ static int expression_value(struct token
 
 	p = constant_expression(*where, &expr);
 	if (!eof_token(p))
-		warning(p->pos, "garbage at end: %s", show_token_sequence(p));
+		error(p->pos, "garbage at end: %s", show_token_sequence(p));
 	value = get_expression_value(expr);
 	return value != 0;
 }
@@ -1274,10 +1274,10 @@ static int handle_elif(struct stream * s
 		MARK_STREAM_NONCONST(token->pos);
 
 	if (stream->nesting > if_nesting)
-		warning(token->pos, "unmatched #elif within stream");
+		error(token->pos, "unmatched #elif within stream");
 
 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warning(token->pos, "#elif after #else");
+		error(token->pos, "#elif after #else");
 
 	if (false_nesting) {
 		/* If this whole if-thing is if'ed out, an elif cannot help */
@@ -1301,10 +1301,10 @@ static int handle_else(struct stream *st
 		MARK_STREAM_NONCONST(token->pos);
 
 	if (stream->nesting > if_nesting)
-		warning(token->pos, "unmatched #else within stream");
+		error(token->pos, "unmatched #else within stream");
 
 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warning(token->pos, "#else after #else");
+		error(token->pos, "#else after #else");
 	else
 		elif_ignore[if_nesting-1] |= ELIF_SEEN_ELSE;
 
@@ -1328,7 +1328,7 @@ static int handle_endif(struct stream *s
 		stream->constant = CONSTANT_FILE_MAYBE;
 
 	if (stream->nesting > if_nesting)
-		warning(token->pos, "unmatched #endif in stream");
+		error(token->pos, "unmatched #endif in stream");
 	if (false_nesting)
 		false_nesting--;
 	else
@@ -1351,7 +1351,7 @@ static const char *show_token_sequence(s
 		int len = strlen(val);
 
 		if (ptr + whitespace + len >= buffer + sizeof(buffer)) {
-			warning(token->pos, "too long token expansion");
+			error(token->pos, "too long token expansion");
 			break;
 		}
 
@@ -1382,7 +1382,7 @@ static int handle_error(struct stream *s
 		return free_preprocessor_line(token);
 	if (stream->constant == CONSTANT_FILE_MAYBE)
 		MARK_STREAM_NONCONST(token->pos);
-	warning(token->pos, "%s", show_token_sequence(token->next));
+	error(token->pos, "%s", show_token_sequence(token->next));
 	return free_preprocessor_line(token);
 }
 
@@ -1454,7 +1454,7 @@ static int handle_add_isystem(struct str
 		if (eof_token(token))
 			return 1;
 		if (token_type(token) != TOKEN_STRING) {
-			warning(token->pos, "expected path string");
+			error(token->pos, "expected path string");
 			return 1;
 		}
 		add_path_entry(token, token->string->data, &sys_includepath, sys_includepath);
@@ -1485,7 +1485,7 @@ static int handle_add_dirafter(struct st
 		if (eof_token(token))
 			return 1;
 		if (token_type(token) != TOKEN_STRING) {
-			warning(token->pos, "expected path string");
+			error(token->pos, "expected path string");
 			return 1;
 		}
 		add_dirafter_entry(token, token->string->data);
@@ -1604,7 +1604,7 @@ static void handle_preprocessor_line(str
 			return;
 	}
 
-	warning(token->pos, "unrecognized preprocessor line '%s'", show_token_sequence(token));
+	error(token->pos, "unrecognized preprocessor line '%s'", show_token_sequence(token));
 }
 
 static void preprocessor_line(struct stream *stream, struct token **line)
@@ -1641,7 +1641,7 @@ static void do_preprocess(struct token *
 		switch (token_type(next)) {
 		case TOKEN_STREAMEND:
 			if (stream->nesting < if_nesting + 1) {
-				warning(unmatched_if_pos, "unterminated preprocessor conditional");
+				error(unmatched_if_pos, "unterminated preprocessor conditional");
 				// Pretend to see a series of #endifs
 				MARK_STREAM_NONCONST(next->pos);
 				do {
diff --git a/symbol.c b/symbol.c
--- a/symbol.c
+++ b/symbol.c
@@ -394,16 +394,16 @@ struct symbol *examine_symbol_type(struc
 		break;
 	}
 	case SYM_PREPROCESSOR:
-		warning(sym->pos, "ctype on preprocessor command? (%s)", show_ident(sym->ident));
+		error(sym->pos, "ctype on preprocessor command? (%s)", show_ident(sym->ident));
 		return NULL;
 	case SYM_UNINITIALIZED:
-		warning(sym->pos, "ctype on uninitialized symbol %p", sym);
+		error(sym->pos, "ctype on uninitialized symbol %p", sym);
 		return NULL;
 	case SYM_RESTRICT:
 		examine_base_type(sym);
 		return sym;
 	default:
-		warning(sym->pos, "Examining unknown symbol type %d", sym->type);
+		error(sym->pos, "Examining unknown symbol type %d", sym->type);
 		break;
 	}
 	return sym;
@@ -441,11 +441,11 @@ void bind_symbol(struct symbol *sym, str
 {
 	struct scope *scope;
 	if (sym->id_list) {
-		warning(sym->pos, "internal error: symbol type already bound");
+		error(sym->pos, "internal error: symbol type already bound");
 		return;
 	}
 	if (ident->reserved && (ns & (NS_TYPEDEF | NS_STRUCT | NS_LABEL | NS_SYMBOL))) {
-		warning(sym->pos, "Trying to use reserved word '%s' as identifier", show_ident(ident));
+		error(sym->pos, "Trying to use reserved word '%s' as identifier", show_ident(ident));
 		return;
 	}
 	sym->namespace = ns;
diff --git a/tokenize.c b/tokenize.c
--- a/tokenize.c
+++ b/tokenize.c
@@ -522,7 +522,7 @@ static int get_char_token(int next, stre
 
 	next = escapechar(next, '\'', stream, &value);
 	if (value == '\'' || next != '\'') {
-		warning(stream_pos(stream), "Bad character constant");
+		error(stream_pos(stream), "Bad character constant");
 		drop_token(stream);
 		return next;
 	}





-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] resend: build shared libs as well ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] resend: build shared libs as well
Date: Fri, 18 Feb 2005 22:17:23 +0000
Message-ID: <20050218221723.GB31120 () 64m ! dyndns ! org>
--------------------
On Fri, Feb 18, 2005 at 01:44:42PM -0500, Christopher Li wrote:
> Hi Linus,
> 
> This patch build shared library for sparse.
> That save me a lot of time rebuilding the python modules
> when I debug the sparse.

OK, I resend this one without the -fPIC flags so it doesn't
affect other part of the build in any way. Seems works for me.


Chris

Index: sparse-be/Makefile
===================================================================
--- sparse-be.orig/Makefile	2004-12-09 16:48:33.000000000 -0500
+++ sparse-be/Makefile	2005-02-18 14:45:02.000000000 -0500
@@ -23,7 +23,10 @@
 LIB_FILE= sparse.a
 LIBS=$(LIB_FILE)
 
-all: $(PROGRAMS)
+SHARE_LIB_FILE= libsparse.so
+SHARE_LIBS=$(SHARE_LIB_FILE)
+
+all: $(PROGRAMS) $(SHARE_LIBS)
 
 #
 # Install the 'check' binary as 'sparse', just to confuse people.
@@ -69,6 +72,9 @@
 $(LIB_FILE): $(LIB_OBJS)
 	$(AR) rcs $(LIB_FILE) $(LIB_OBJS)
 
+$(SHARE_LIB_FILE): $(LIB_OBJS)
+	$(CC) -shared -o $(SHARE_LIB_FILE) $(LIB_OBJS)
+
 evaluate.o: $(LIB_H)
 expression.o: $(LIB_H)
 lib.o: $(LIB_H)
@@ -109,4 +115,4 @@
 	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=include`\"" > pre-process.h
 
 clean:
-	rm -f *.[oasi] core core.[0-9]* $(PROGRAMS) pre-process.h
+	rm -f *.[oasi] *.so core core.[0-9]* $(PROGRAMS) pre-process.h 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] resend: build shared libs as well
Date: Sat, 19 Feb 2005 17:17:27 +0000
Message-ID: <20050219171727.GA16380 () 64m ! dyndns ! org>
--------------------
That looks good.

I update the pysparse to use the run time path.

http://cgen.home.comcast.net/pysparse-0.1.0.tar.gz

Thanks

Chris

On Sat, Feb 19, 2005 at 11:15:48AM -0800, Linus Torvalds wrote:
> 
> 
> On Sat, 19 Feb 2005, Linus Torvalds wrote:
> > 
> > Somebody who builds shared libraries more, please correct me/us.
> 
> Here's what I believe is a better example of building (and using) sparse 
> as a dynamic library. Dunno if we want to go this way.
> 
> 		Linus
> 
> ----
> ===== Makefile 1.62 vs edited =====
> --- 1.62/Makefile	2004-12-09 09:21:45 -08:00
> +++ edited/Makefile	2005-02-19 11:12:44 -08:00
> @@ -4,11 +4,12 @@
>  OS=linux
>  
>  CC=gcc
> -CFLAGS=-O -g -Wall -Wwrite-strings
> -LDFLAGS=-g
> +CFLAGS=-O -g -Wall -Wwrite-strings -fpic
> +LDFLAGS=-g -Wl,-rpath,$(BINDIR)
>  AR=ar
>  
>  PREFIX=$(HOME)
> +BINDIR=$(PREFIX)/bin
>  PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize example
>  
>  LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
> @@ -21,17 +22,19 @@
>  	  flow.o cse.o simplify.o memops.o liveness.o storage.o
>  
>  LIB_FILE= sparse.a
> -LIBS=$(LIB_FILE)
> +SLIB_FILE= libsparse.so
>  
> -all: $(PROGRAMS)
> +LIBS=$(SLIB_FILE)
> +
> +all: $(PROGRAMS) $(SLIB_FILE)
>  
>  #
>  # Install the 'check' binary as 'sparse', just to confuse people.
>  #
>  #		"The better to keep you on your toes, my dear".
>  #
> -install: check bin-dir
> -	if test $< -nt $(PREFIX)/bin/sparse ; then install -v $< $(PREFIX)/bin/sparse ; fi
> +install: check $(SLIB_FILE) bin-dir
> +	if test $< -nt $(PREFIX)/bin/sparse ; then install -v $< $(BINDIR)/sparse ; install -v $(SLIB_FILE) $(BINDIR) ; fi
>  
>  bin-dir:
>  	@if ! test -d $(PREFIX)/bin; then \
> @@ -42,32 +45,35 @@
>  
>  .PHONY: bin-dir
>  
> -test-lexing: test-lexing.o $(LIB_FILE)
> +test-lexing: test-lexing.o $(LIBS)
>  	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
>  
> -test-parsing: test-parsing.o $(LIB_FILE)
> +test-parsing: test-parsing.o $(LIBS)
>  	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
>  
> -test-linearize: test-linearize.o $(LIB_FILE)
> +test-linearize: test-linearize.o $(LIBS)
>  	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
>  
> -test-sort: test-sort.o $(LIB_FILE)
> +test-sort: test-sort.o $(LIBS)
>  	gcc $(LDFLAGS) -o $@ $< $(LIBS)
>  
> -compile: compile.o compile-i386.o $(LIB_FILE)
> +compile: compile.o compile-i386.o $(LIBS)
>  	$(CC) $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
>  
> -obfuscate: obfuscate.o $(LIB_FILE)
> +obfuscate: obfuscate.o $(LIBS)
>  	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
>  
> -check: check.o $(LIB_FILE)
> +check: check.o $(LIBS)
>  	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
>  
> -example: example.o $(LIB_FILE)
> +example: example.o $(LIBS)
>  	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
>  
>  $(LIB_FILE): $(LIB_OBJS)
> -	$(AR) rcs $(LIB_FILE) $(LIB_OBJS)
> +	$(AR) rcs $@ $(LIB_OBJS)
> +
> +$(SLIB_FILE): $(LIB_OBJS)
> +	$(CC) -shared -o $@ $(LIB_OBJS)
>  
>  evaluate.o: $(LIB_H)
>  expression.o: $(LIB_H)
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] resend: build shared libs as well
Date: Sat, 19 Feb 2005 18:53:37 +0000
Message-ID: <Pine.LNX.4.58.0502191048350.2371 () ppc970 ! osdl ! org>
--------------------


On Fri, 18 Feb 2005, Christopher Li wrote:
> 
> OK, I resend this one without the -fPIC flags so it doesn't
> affect other part of the build in any way. Seems works for me.

I _think_ you want "-fpic". Without any kind of -fPIC/pic, the code won't 
be suitable for a shared library on many platforms.

The difference between -fPIC and -fpic is architecture-dependent, but it 
basically boils down to "-fPIC always works, but -fpic is smaller and 
faster by having limits that may make it unsuitable for large projects".

Sparse is definitely small enough that "-fpic" shoulf be fine.

Somebody who builds shared libraries more, please correct me/us.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] skip already evaluated symbols ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: [PATCH] skip already evaluated symbols
Date: Wed, 16 Nov 2005 19:47:00 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHKEHMCHAA.mshah () teja ! com>
--------------------
Hi,

Here is the patch that skips the already evaluated symbols. I think if
the symbol is already evaluated once, there is no change in the
conditions so it should not be evaluated again. This helps when we are
evaluating for multiple files.


Thanks,

-Mitesh

-----------------------------------------------------------
diff --git a/evaluate.c b/evaluate.c
--- a/evaluate.c
+++ b/evaluate.c
@@ -2396,6 +2396,9 @@ static struct symbol *evaluate_symbol(st

        if (!sym)
                return sym;
+       if (sym->evaluated)
+               return sym;
+       sym->evaluated = 1;

        sym = examine_symbol_type(sym);
        base_type = get_base_type(sym);
diff --git a/symbol.h b/symbol.h
--- a/symbol.h
+++ b/symbol.h
@@ -99,7 +99,8 @@ struct symbol {
                                        variadic:1,
                                        initialized:1,
                                        examined:1,
-                                       expanding:1;
+                                       expanding:1,
+                                       evaluated:1;
                        struct expression *array_size;
                        struct ctype ctype;
                        struct symbol_list *arguments;




-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: Makefile trivialities ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH] sparse: Makefile trivialities
Date: Tue, 01 Mar 2005 00:13:09 +0000
Message-ID: <200503010313.16044.adobriyan () mail ! ru>
--------------------
--- 1.1271/Makefile	2005-02-26 14:03:29.000000000 +0200
+++ 1.1271-Makefile/Makefile	2005-03-01 03:09:54.000000000 +0200
@@ -12,7 +12,7 @@ AR=ar
 # If building with shared libraries, you might
 # want to add this
 #
-# LDFLAG += -Wl,-rpath,$(BINDIR)
+# LDFLAGS += -Wl,-rpath,$(BINDIR)
 
 PREFIX=$(HOME)
 BINDIR=$(PREFIX)/bin
@@ -61,7 +61,7 @@ test-linearize: test-linearize.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
 test-sort: test-sort.o $(LIBS)
-	gcc $(LDFLAGS) -o $@ $< $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
 compile: compile.o compile-i386.o $(LIBS)
 	$(CC) $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: add __GNUC_PATCHLEVEL__ ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: [PATCH] sparse: add __GNUC_PATCHLEVEL__
Date: Sat, 10 Sep 2005 22:09:47 +0000
Message-ID: <20050910220947.GA22381 () mipter ! zuzino ! mipt ! ru>
--------------------
Fix logs flooding on sparc:

include/asm/bug.h:12:46: warning: undefined preprocessor identifier '__GNUC_PATCHLEVEL__'

--- sparse-vanilla/lib.c
+++ sparse-__GNUC_PATCHLEVEL__/lib.c
@@ -33,10 +33,12 @@ int verbose, optimize, optimize_size, pr
 #ifndef __GNUC__
 # define __GNUC__ 2
 # define __GNUC_MINOR__ 95
+# define __GNUC_PATCHLEVEL__ 0
 #endif
 
 int gcc_major = __GNUC__;
 int gcc_minor = __GNUC_MINOR__;
+int gcc_patchlevel = __GNUC_PATCHLEVEL__;
 
 struct token *skip_to(struct token *token, int op)
 {
@@ -437,6 +439,7 @@ void create_builtin_stream(void)
 {
 	add_pre_buffer("#define __GNUC__ %d\n", gcc_major);
 	add_pre_buffer("#define __GNUC_MINOR__ %d\n", gcc_minor);
+	add_pre_buffer("#define __GNUC_PATCHLEVEL__ %d\n", gcc_patchlevel);
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
 

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] static declear ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] static declear
Date: Sat, 02 Apr 2005 05:55:41 +0000
Message-ID: <20050402055541.GA3177 () 64m ! dyndns ! org>
--------------------
This patch add static declare to make sparse happy of checking itself.

Chris

Index: sparse-be/parse.c
===================================================================
--- sparse-be.orig/parse.c	2005-03-28 17:29:07.000000000 -0500
+++ sparse-be/parse.c	2005-04-02 00:39:42.000000000 -0500
@@ -105,7 +105,7 @@
 	return lookup_or_create_symbol(NS_LABEL, SYM_LABEL, token);
 }
 
-struct token *struct_union_enum_specifier(enum type type,
+static struct token *struct_union_enum_specifier(enum type type,
 	struct token *token, struct ctype *ctype,
 	struct token *(*parse)(struct token *, struct symbol *))
 {
@@ -159,7 +159,7 @@
 	return struct_declaration_list(token, &sym->symbol_list);
 }
 
-struct token *struct_or_union_specifier(enum type type, struct token *token, struct ctype *ctype)
+static struct token *struct_or_union_specifier(enum type type, struct token *token, struct ctype *ctype)
 {
 	return struct_union_enum_specifier(type, token, ctype, parse_struct_declaration);
 }
@@ -316,12 +316,12 @@
 	return token;
 }
 
-struct token *enum_specifier(struct token *token, struct ctype *ctype)
+static struct token *enum_specifier(struct token *token, struct ctype *ctype)
 {
 	return struct_union_enum_specifier(SYM_ENUM, token, ctype, parse_enum_declaration);
 }
 
-struct token *typeof_specifier(struct token *token, struct ctype *ctype)
+static struct token *typeof_specifier(struct token *token, struct ctype *ctype)
 {
 	struct symbol *sym;
 
@@ -948,7 +948,7 @@
 	return declarator(token, sym, NULL);
 }
 
-struct token *expression_statement(struct token *token, struct expression **tree)
+static struct token *expression_statement(struct token *token, struct expression **tree)
 {
 	token = parse_expression(token, tree);
 	return expect(token, ';', "at end of statement");
@@ -1180,7 +1180,7 @@
 	return token;
 }
 
-struct token *parse_while_statement(struct token *token, struct statement *stmt)
+static struct token *parse_while_statement(struct token *token, struct statement *stmt)
 {
 	struct expression *expr;
 	struct statement *iterator;
@@ -1197,7 +1197,7 @@
 	return token;
 }
 
-struct token *parse_do_statement(struct token *token, struct statement *stmt)
+static struct token *parse_do_statement(struct token *token, struct statement *stmt)
 {
 	struct expression *expr;
 	struct statement *iterator;
Index: sparse-be/tokenize.c
===================================================================
--- sparse-be.orig/tokenize.c	2005-01-19 00:24:12.000000000 -0500
+++ sparse-be/tokenize.c	2005-04-02 00:39:42.000000000 -0500
@@ -44,7 +44,7 @@
 	return input_streams[stream].name;
 }
 
-struct position stream_pos(stream_t *stream)
+static struct position stream_pos(stream_t *stream)
 {
 	struct position pos;
 	pos.type = 0;
@@ -78,7 +78,7 @@
 	return buffer;
 }
 
-char *charstr(char *ptr, unsigned char c, unsigned char escape, unsigned char next)
+static char *charstr(char *ptr, unsigned char c, unsigned char escape, unsigned char next)
 {
 	if (isprint(c)) {
 		if (c == escape || c == '\\')
@@ -679,7 +679,7 @@
 #define ident_hash_end(hash)		((((hash) >> IDENT_HASH_BITS) + (hash)) & IDENT_HASH_MASK)
 
 static struct ident *hash_table[IDENT_HASH_SIZE];
-int ident_hit, ident_miss, idents;
+static int ident_hit, ident_miss, idents;
 
 void show_identifier_stats(void)
 {
Index: sparse-be/pre-process.c
===================================================================
--- sparse-be.orig/pre-process.c	2005-01-19 00:24:12.000000000 -0500
+++ sparse-be/pre-process.c	2005-04-02 00:39:42.000000000 -0500
@@ -383,7 +383,6 @@
 
 static int merge(struct token *left, struct token *right)
 {
-	extern unsigned char combinations[][3];
 	static char buffer[512];
 	int n;
 
@@ -1535,7 +1534,7 @@
 }
 
 
-void init_preprocessor(void)
+static void init_preprocessor(void)
 {
 	int i;
 	int stream = init_stream("preprocessor", -1, includepath);
Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2005-04-02 00:34:25.000000000 -0500
+++ sparse-be/lib.c	2005-04-02 00:45:50.000000000 -0500
@@ -180,7 +180,7 @@
 	va_end(args);
 }
 
-char **handle_switch_D(char *arg, char **next)
+static char **handle_switch_D(char *arg, char **next)
 {
 	const char *name = arg + 1;
 	const char *value = "1";
@@ -199,13 +199,13 @@
 	return next;
 }
 
-char **handle_switch_E(char *arg, char **next)
+static char **handle_switch_E(char *arg, char **next)
 {
 	preprocess_only = 1;
 	return next;
 }
 
-char **handle_switch_v(char *arg, char **next)
+static char **handle_switch_v(char *arg, char **next)
 {
 	do {
 		verbose++;
@@ -213,7 +213,7 @@
 	return next;
 }
 
-char **handle_switch_I(char *arg, char **next)
+static char **handle_switch_I(char *arg, char **next)
 {
 	char *path = arg+1;
 
@@ -233,7 +233,7 @@
 	return next;
 }
 
-char **handle_switch_i(char *arg, char **next)
+static char **handle_switch_i(char *arg, char **next)
 {
 	if (*next && !strcmp(arg, "include")) {
 		char *name = *++next;
@@ -253,7 +253,7 @@
 	return next;
 }
 
-char **handle_switch_M(char *arg, char **next)
+static char **handle_switch_M(char *arg, char **next)
 {
 	if (!strcmp(arg, "MF") || !strcmp(arg,"MQ") || !strcmp(arg,"MT")) {
 		if (!*next)
@@ -263,7 +263,7 @@
 	return next;
 }
 
-char **handle_switch_m(char *arg, char **next)
+static char **handle_switch_m(char *arg, char **next)
 {
 	if (!strcmp(arg, "m64")) {
 		bits_in_long = 64;
@@ -274,7 +274,7 @@
 	return next;
 }
 
-char **handle_switch_o(char *arg, char **next)
+static char **handle_switch_o(char *arg, char **next)
 {
 	if (!strcmp (arg, "o") && *next)
 		return next + 1; // "-o foo"
@@ -282,7 +282,7 @@
 		return next;     // "-ofoo" or (bogus) terminal "-o"
 }
 
-const struct warning {
+static const struct warning {
 	const char *name;
 	int *flag;
 } warnings[] = {
@@ -295,7 +295,7 @@
 };
 
 
-char **handle_switch_W(char *arg, char **next)
+static char **handle_switch_W(char *arg, char **next)
 {
 	int no = 0;
 	char *p = arg + 1;
@@ -320,14 +320,14 @@
 	return next;
 }
 
-char **handle_switch_U(char *arg, char **next)
+static char **handle_switch_U(char *arg, char **next)
 {
 	const char *name = arg + 1;
 	add_pre_buffer ("#undef %s\n", name);
 	return next;
 }
 
-char **handle_switch_O(char *arg, char **next)
+static char **handle_switch_O(char *arg, char **next)
 {
 	int level = 1;
 	if (arg[1] >= '0' && arg[1] <= '9')
@@ -336,13 +336,13 @@
 	return next;
 }
 
-char **handle_nostdinc(char *arg, char **next)
+static char **handle_nostdinc(char *arg, char **next)
 {
 	add_pre_buffer("#nostdinc\n");
 	return next;
 }
 
-char **handle_dirafter(char *arg, char **next)
+static char **handle_dirafter(char *arg, char **next)
 {
 	char *path = *++next;
 	if (!path)
Index: sparse-be/show-parse.c
===================================================================
--- sparse-be.orig/show-parse.c	2005-02-17 22:51:09.000000000 -0500
+++ sparse-be/show-parse.c	2005-04-02 00:39:42.000000000 -0500
@@ -110,7 +110,7 @@
 	return buffer;
 }
 
-void show_struct_member(struct symbol *sym)
+static void show_struct_member(struct symbol *sym)
 {
 	printf("\t%s:%d:%ld at offset %ld.%d", show_ident(sym->ident), sym->bit_size, sym->ctype.alignment, sym->offset, sym->bit_offset);
 	printf("\n");
@@ -874,7 +874,7 @@
 	return new;
 }
 
-int show_label_expr(struct expression *expr)
+static int show_label_expr(struct expression *expr)
 {
 	int new = new_pseudo();
 	printf("\tmovi.%d\t\tv%d,.L%p\n",bits_in_pointer, new, expr->label_symbol);
Index: sparse-be/evaluate.c
===================================================================
--- sparse-be.orig/evaluate.c	2005-03-28 17:29:07.000000000 -0500
+++ sparse-be/evaluate.c	2005-04-02 00:39:42.000000000 -0500
@@ -1481,7 +1481,7 @@
 	return &bool_ctype;
 }
 
-struct symbol *find_identifier(struct ident *ident, struct symbol_list *_list, int *offset)
+static struct symbol *find_identifier(struct ident *ident, struct symbol_list *_list, int *offset)
 {
 	struct ptr_list *head = (struct ptr_list *)_list;
 	struct ptr_list *list = head;
Index: sparse-be/inline.c
===================================================================
--- sparse-be.orig/inline.c	2005-02-17 22:51:09.000000000 -0500
+++ sparse-be/inline.c	2005-04-02 00:39:42.000000000 -0500
@@ -258,13 +258,13 @@
 	return out;
 }
 
-void set_replace(struct symbol *old, struct symbol *new)
+static void set_replace(struct symbol *old, struct symbol *new)
 {
 	new->replace = old;
 	old->replace = new;
 }
 
-void unset_replace(struct symbol *sym)
+static void unset_replace(struct symbol *sym)
 {
 	struct symbol *r = sym->replace;
 	if (!r) {
Index: sparse-be/token.h
===================================================================
--- sparse-be.orig/token.h	2005-04-02 00:22:51.000000000 -0500
+++ sparse-be/token.h	2005-04-02 00:39:42.000000000 -0500
@@ -95,6 +95,8 @@
 	"<", ">", "<=", ">="	\
 }
 
+extern unsigned char combinations[][3];
+
 enum special_token {
 	SPECIAL_BASE = 256,
 	SPECIAL_ADD_ASSIGN = SPECIAL_BASE,
Index: sparse-be/parse.h
===================================================================
--- sparse-be.orig/parse.h	2005-02-17 22:51:09.000000000 -0500
+++ sparse-be/parse.h	2005-04-02 00:39:42.000000000 -0500
@@ -116,6 +116,7 @@
 extern int show_statement(struct statement *);
 extern void show_statement_list(struct statement_list *, const char *);
 extern int show_expression(struct expression *);
+
 extern struct symbol_list *translation_unit(struct token *);
 
 extern struct symbol *ctype_integer(unsigned long spec);
Index: sparse-be/symbol.h
===================================================================
--- sparse-be.orig/symbol.h	2005-04-02 00:30:04.000000000 -0500
+++ sparse-be/symbol.h	2005-04-02 00:39:42.000000000 -0500
@@ -208,6 +208,7 @@
 extern void show_type(struct symbol *);
 extern const char *modifier_string(unsigned long mod);
 extern void show_symbol(struct symbol *);
+extern int show_symbol_expr_init(struct symbol *sym);
 extern void show_type_list(struct symbol *);
 extern void show_symbol_list(struct symbol_list *, const char *);
 extern void add_symbol(struct symbol_list **, struct symbol *);
Index: sparse-be/symbol.c
===================================================================
--- sparse-be.orig/symbol.c	2005-04-02 00:34:25.000000000 -0500
+++ sparse-be/symbol.c	2005-04-02 00:39:42.000000000 -0500
@@ -542,7 +542,7 @@
  *
  * "double" == "long float", "long double" == "long long float"
  */
-struct sym_init {
+static struct sym_init {
 	const char *name;
 	struct symbol *base_type;
 	unsigned int modifiers;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] using 0 as NULL in sparse ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] using 0 as NULL in sparse
Date: Fri, 18 Feb 2005 18:38:37 +0000
Message-ID: <20050218183837.GB28874 () 64m ! dyndns ! org>
--------------------
On Fri, Feb 18, 2005 at 08:12:30AM -0800, Linus Torvalds wrote:
> 
> 
> On Fri, 18 Feb 2005, Christopher Li wrote:
> 
> Yeah, I should just allow that internally, and then just have a flag that 
> enables the warning for kernel code. Sparse internally already has some 
> support for a dynamic "array_size" (it _is_ a "struct expression *"), but 
> to actually do the right thing is not trivial.

I agree, even if you copy the expression, now sizeof becomes an
expression instead of constant value. Any thought of handling the
type size in bit_size then?

I am thinking of insert an internal symbol for the new sizeof
expression, at the place where size of array get evaluated.
Then all the later sizeof reference will be come using that
symbol.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]: "make clean" doesn't delete libsparse.so ===

From: Rui Saraiva <rmps () joel ! ist ! utl ! pt>
To: linux-sparse
Subject: [PATCH]: "make clean" doesn't delete libsparse.so
Date: Tue, 22 Feb 2005 01:22:18 +0000
Message-ID: <Pine.LNX.4.58.0502220117190.14193 () joel ! ist ! utl ! pt>
--------------------

Small patch to also delete libsparse.so (SLIB_FILE) in "clean" target.

Regards,
  Rui Saraiva


--- Makefile.orig	2005-02-22 01:15:50.000000000 +0000
+++ Makefile	2005-02-22 01:15:47.000000000 +0000
@@ -121,4 +121,4 @@
 	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=include`\"" > pre-process.h

 clean:
-	rm -f *.[oasi] core core.[0-9]* $(PROGRAMS) pre-process.h
+	rm -f *.[oasi] core core.[0-9]* $(PROGRAMS) $(SLIB_FILE) pre-process.h
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on ===

From: Prarit Bhargava <prarit () sgi ! com>
To: linux-sparse
Subject: Re: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on
Date: Wed, 11 May 2005 11:39:54 +0000
Message-ID: <4281EF0A.9080403 () sgi ! com>
--------------------
Christopher Li wrote:

> 
> It looks good to me. Another way I am thinking is add some options to skip
> the specific attribute or turn off the warning of unknown attribute all
> together. 
> 

Chris,

I'm working on a patch to do this right now.

I'm thinking of something along the lines of the following.  What do you 
think?

	sparse -omit-attribute (value) would turn off the warnings for value
	sparse -omit-attribute unknown would turn off all unknown warnings
	sparse -omit-attribute all would turn off all warnings

P.
> Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Prarit Bhargava <prarit () sgi ! com>
To: linux-sparse
Subject: Re: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on
Date: Wed, 11 May 2005 13:22:08 +0000
Message-ID: <42820700.20203 () sgi ! com>
--------------------
This is a multi-part message in MIME format.
--------------000208090200070201040801
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

Christopher Li wrote:

> 
> It looks good to me. Another way I am thinking is add some options to skip
> the specific attribute or turn off the warning of unknown attribute all
> together. 
> 
> Chris

New patch version that adds this support as well.  I was unsure if I 
should dynamically allocate or statically allocate the ignored attribute 
strings -- I chose to dynamically allocate.

However, I'm unsure of where to do a cleanup of the memory.  I put it at 
the end of main in check.c -- if anyone has a better suggestion on 
cleaning up within check.c, I'm all for it.

P.

--------------000208090200070201040801
Content-Type: text/plain;
 name="sparse.diff"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="sparse.diff"

[PATCH]: sparse: updates for gcc 3.4.3

After manually changing the gcc version values in lib.c to gcc3,
I discovered that a few attributes and a builtin were missing.
They were __used__, deprecated, warn_unused_result, and
__builtin_expect (from likely and unlikely).

Additionally, support for the -omit_attribute (all, unknown, or target)
has also been added.  This sparse option allows one to ignore all, unknown,
or a specific attribute's warnings.

Index: check.c
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/check.c  (mode:100644 sha1:089833d65c5e8cee45f9fcd47edc2ba1c1d6c402)
+++ uncommitted/check.c  (mode:100644)
@@ -265,5 +265,6 @@
 {
 	// Expand, linearize and show it.
 	check_symbols(sparse(argc, argv));
+	sparse_cleanup();
 	return 0;
 }
Index: ident-list.h
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/ident-list.h  (mode:100644 sha1:9cbdec342b60e9f47563d204a7b16c70ef236e9a)
+++ uncommitted/ident-list.h  (mode:100644)
@@ -46,6 +46,7 @@
 IDENT(SI); IDENT(__DI__); IDENT(DI);
 IDENT(__word__); IDENT(word); IDENT(format);
 IDENT(__format__); IDENT(section); IDENT(__section__);
+IDENT(used); IDENT(__used__);
 IDENT(unused); IDENT(__unused__); IDENT(const);
 IDENT(__const); IDENT(__const__); IDENT(noreturn);
 IDENT(__noreturn__); IDENT(regparm); IDENT(weak);
@@ -54,6 +55,8 @@
 IDENT(bitwise);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
+IDENT(deprecated);
+IDENT(warn_unused_result);
 
 /* Preprocessor idents */
 __IDENT(pragma_ident, "__pragma__", 0);
Index: lib.c
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/lib.c  (mode:100644 sha1:b1b97db07051ddc07bb7edd8e75f6a8f23e0b8ed)
+++ uncommitted/lib.c  (mode:100644)
@@ -351,6 +351,51 @@
 	return next;
 }
 
+int ignore_unknown_attributes = 0;
+int ignore_all_attributes = 0;
+static char *ignore_attr[29];
+static int ignore_attr_cnt = 0;
+
+static void cleanup_ignore_attributes(void)
+{
+	int i;
+
+	for (i = 0; i < ignore_attr_cnt; i++)
+		free(ignore_attr[ignore_attr_cnt]);
+}
+
+int ignore_attribute(char * attr_name)
+{
+	int i;
+
+	for (i = 0; i < ignore_attr_cnt; i++)
+		if (!strcmp(attr_name,ignore_attr[i]))
+			return 1;
+	return 0;
+}
+
+static char **handle_omit_attribute(char *arg, char **next)
+{
+        if (strlen(*++next) < 0)
+		die ("missing argument for -omit option");
+
+	/* do more stuff here */
+	if (!strcmp(*next, "all"))
+		ignore_all_attributes = 1;
+	else if (!strcmp(*next, "unknown"))
+		ignore_unknown_attributes = 1;
+	else {
+		if (ignore_attr_cnt > 29)
+			die ("too many -omit options");
+		ignore_attr[ignore_attr_cnt] = malloc(strlen(*next) + 1);
+		if (!ignore_attr[ignore_attr_cnt])
+			die ("out of memory");
+		strcpy(ignore_attr[ignore_attr_cnt],*next);
+		ignore_attr_cnt++;
+	}
+	return next;
+}
+
 struct switches {
 	const char *name;
 	char **(*fn)(char *, char**);
@@ -362,6 +407,7 @@
 	static struct switches cmd[] = {
 		{ "nostdinc", handle_nostdinc },
 		{ "dirafter", handle_dirafter },
+		{ "omit_attribute", handle_omit_attribute },
 		{ NULL, NULL }
 	};
 	struct switches *s;
@@ -405,6 +451,7 @@
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(int);\n");
 	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+	add_pre_buffer("extern int __builtin_expect(long, long);\n");
 }
 
 void create_builtin_stream(void)
@@ -437,6 +484,15 @@
 	add_pre_buffer("#define __TIME__ \"??:??:??\"\n");
 }
 
+void sparse_cleanup(void)
+{
+	/*
+	 * as we add more options, we can clean up memory allocations,
+	 * etc., right here.
+	 */
+	cleanup_ignore_attributes();
+}
+
 struct symbol_list *sparse(int argc, char **argv)
 {
 	int fd;
Index: lib.h
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/lib.h  (mode:100644 sha1:cf672e648f275e1354a9dc9c7fbec1d8c9733b6b)
+++ uncommitted/lib.h  (mode:100644)
@@ -79,10 +79,14 @@
 extern int Wdefault_bitfield_sign;
 extern int Wundefined_preprocessor;
 extern int Wbitwise, Wtypesign, Wcontext;
+extern int ignore_unknown_attributes;
+extern int ignore_all_attributes;
+extern int ignore_attribute(char * attr_name);
 
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
 extern struct symbol_list *sparse(int argc, char **argv);
+extern void sparse_cleanup(void);
 
 static inline int symbol_list_size(struct symbol_list* list)
 {
Index: parse.c
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/parse.c  (mode:100644 sha1:2d48db2b7262306d238997fd43ae4bb902d044a3)
+++ uncommitted/parse.c  (mode:100644)
@@ -344,6 +344,9 @@
 
 static const char * handle_attribute(struct ctype *ctype, struct ident *attribute, struct expression *expr)
 {
+	if (ignore_all_attributes)
+		return NULL;
+
 	if (attribute == &packed_ident ||
 	    attribute == &__packed___ident) {
 		ctype->alignment = 1;
@@ -444,6 +447,9 @@
 	if (attribute == &section_ident ||
 	    attribute == &__section___ident)
 		return NULL;
+	if (attribute == &used_ident ||
+	    attribute == &__used___ident)
+		return NULL;
 	if (attribute == &unused_ident ||
 	    attribute == &__unused___ident)
 		return NULL;
@@ -471,6 +477,17 @@
 	if (attribute == &model_ident ||
 	    attribute == &__model___ident)
 		return NULL;
+	if (attribute == &deprecated_ident)
+		return NULL;
+	if (attribute == &warn_unused_result_ident)
+		return NULL;
+
+	if (ignore_unknown_attributes)
+		return NULL;
+	else {
+		if (ignore_attribute(attribute->name))
+			return NULL;
+	}
 
 	return "unknown attribute";
 }

--------------000208090200070201040801--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on ia64 ===

From: Prarit Bhargava <prarit () sgi ! com>
To: linux-sparse
Subject: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on ia64
Date: Tue, 10 May 2005 01:24:43 +0000
Message-ID: <42800D5B.3080901 () sgi ! com>
--------------------
This is a multi-part message in MIME format.
--------------020005040704030704020701
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

Christopher Li wrote:
> Yes, sparse pretend to be gcc 2.95.
> 
> Can you try the following experiment patch and see if that help?
> 
> I don't have RHEL 4 so I can't verify myself. Ideally we can
> detect the gcc version which compiled  the kernel.
> 

Chris,

Thank you very much for the patch and the insight into sparse.  Your 
patch provided me with exactly what I needed.

I did find some issues when using gcc3 -- a builtin function definition 
and a few attributes needed to be defined.  I'm not sure if these should 
be included in sparse yet but I've included a patch.

This is (obviously) my first sparse patch.  If you would kindly review 
it, I'll submit it for inclusion later in the week.  It is based on a 
new git pull of sparse.

P.

--------------020005040704030704020701
Content-Type: text/plain;
 name="cgsparse.diff"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="cgsparse.diff"

[PATCH]: sparse: updates for gcc 3.4.3

After manually changing the gcc version values in lib.c to gcc3,
I discovered that a few attributes and a builtin were missing.
They were __used__, deprecated, warn_unused_result, and 
__builtin_expect (from likely and unlikely).

This patch adds this support.

Signed-off-by: Prarit Bhargava <prarit@sgi.com>

Index: ident-list.h
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/ident-list.h  (mode:100644 sha1:9cbdec342b60e9f47563d204a7b16c70ef236e9a)
+++ uncommitted/ident-list.h  (mode:100644)
@@ -46,6 +46,7 @@
 IDENT(SI); IDENT(__DI__); IDENT(DI);
 IDENT(__word__); IDENT(word); IDENT(format);
 IDENT(__format__); IDENT(section); IDENT(__section__);
+IDENT(used); IDENT(__used__);
 IDENT(unused); IDENT(__unused__); IDENT(const);
 IDENT(__const); IDENT(__const__); IDENT(noreturn);
 IDENT(__noreturn__); IDENT(regparm); IDENT(weak);
@@ -54,6 +55,8 @@
 IDENT(bitwise);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
+IDENT(deprecated);
+IDENT(warn_unused_result);
 
 /* Preprocessor idents */
 __IDENT(pragma_ident, "__pragma__", 0);
Index: lib.c
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/lib.c  (mode:100644 sha1:b1b97db07051ddc07bb7edd8e75f6a8f23e0b8ed)
+++ uncommitted/lib.c  (mode:100644)
@@ -405,6 +405,7 @@
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(int);\n");
 	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+	add_pre_buffer("extern int __builtin_expect(long, long);\n");
 }
 
 void create_builtin_stream(void)
Index: parse.c
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/parse.c  (mode:100644 sha1:2d48db2b7262306d238997fd43ae4bb902d044a3)
+++ uncommitted/parse.c  (mode:100644)
@@ -444,6 +444,9 @@
 	if (attribute == &section_ident ||
 	    attribute == &__section___ident)
 		return NULL;
+	if (attribute == &used_ident ||
+	    attribute == &__used___ident)
+		return NULL;
 	if (attribute == &unused_ident ||
 	    attribute == &__unused___ident)
 		return NULL;
@@ -471,6 +474,10 @@
 	if (attribute == &model_ident ||
 	    attribute == &__model___ident)
 		return NULL;
+	if (attribute == &deprecated_ident)
+		return NULL;
+	if (attribute == &warn_unused_result_ident)
+		return NULL;
 
 	return "unknown attribute";
 }

--------------020005040704030704020701--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on ia64 -- using gcc2?) ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on ia64 -- using gcc2?)
Date: Tue, 10 May 2005 16:33:36 +0000
Message-ID: <20050510163336.GA21111 () 64m ! dyndns ! org>
--------------------
On Mon, May 09, 2005 at 09:24:43PM -0400, Prarit Bhargava wrote:
> I did find some issues when using gcc3 -- a builtin function definition 
> and a few attributes needed to be defined.  I'm not sure if these should 
> be included in sparse yet but I've included a patch.
> 
> This is (obviously) my first sparse patch.  If you would kindly review 
> it, I'll submit it for inclusion later in the week.  It is based on a 
> new git pull of sparse.

It looks good to me. Another way I am thinking is add some options to skip
the specific attribute or turn off the warning of unknown attribute all
together. 

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on ia64 -- using gcc2?)
Date: Wed, 11 May 2005 22:54:05 +0000
Message-ID: <20050511225405.GA22122 () 64m ! dyndns ! org>
--------------------
On Wed, May 11, 2005 at 07:39:54AM -0400, Prarit Bhargava wrote:
> Christopher Li wrote:
> 
> >
> >It looks good to me. Another way I am thinking is add some options to skip
> >the specific attribute or turn off the warning of unknown attribute all
> >together. 
> >
> 
> Chris,
> 
> I'm working on a patch to do this right now.
> 
> I'm thinking of something along the lines of the following.  What do you 
> think?
> 
> 	sparse -omit-attribute (value) would turn off the warnings for value

Seems gcc is using -W for warning options prefix. might consider using it as well.
-Wingore-attribute value.

> 	sparse -omit-attribute unknown would turn off all unknown warnings
> 	sparse -omit-attribute all would turn off all warnings

It overlap with the previous option. What if there is a attribute named "unknown" or "all"?
It will be better like "-Wignore-attribute-all" instead.

Known option don't generate warnings, so what is the difference between this two option?

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH]: Some gcc3 attributes and builtin (was Re: sparse on ia64 -- using gcc2?)
Date: Wed, 11 May 2005 22:55:32 +0000
Message-ID: <20050511225532.GB22122 () 64m ! dyndns ! org>
--------------------
Linus is on vacations this week.  I think he might have some thing to
said about it when he comes back.  I can continue offer my suggestions
but don't buy into it too much, I often prove to be wrong while Linus
is always right.

On Wed, May 11, 2005 at 09:22:08AM -0400, Prarit Bhargava wrote:
> Christopher Li wrote:
> 
> New patch version that adds this support as well.  I was unsure if I 
> should dynamically allocate or statically allocate the ignored attribute 
> strings -- I chose to dynamically allocate.
> 
> However, I'm unsure of where to do a cleanup of the memory.  I put it at 
> the end of main in check.c -- if anyone has a better suggestion on 
> cleaning up within check.c, I'm all for it.

No, that is not the way you do it in sparse.  Sparse has this very nice
hashed ident structure. You should just create new ident for it, then
just compare the pointer of the ident. If you are making cmpstr for ident,
you are possible doing some thing wrong.

You don't need to clean up that if you allocate as idents.

> 
> Index: check.c
> ===================================================================
> +int ignore_all_attributes = 0;
> +static char *ignore_attr[29];

Why not using a ptr_list for ignored idents?


Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH][IDENT] Add some more attributes ===

From: acme () ghostprotocols ! net (Arnaldo Carvalho de Melo)
To: linux-sparse
Subject: [PATCH][IDENT] Add some more attributes
Date: Tue, 31 May 2005 08:09:48 +0000
Message-ID: <20050531080948.GI27105 () conectiva ! com ! br>
--------------------
Linus, please consider pulling from:

rsync://master.kernel.org/pub/scm/linux/kernel/git/acme/ostra.git

Best Regards,

- Arnaldo

tree 6b9b8d8eafad245dd9bfd5db3539293146e5b7a6
parent 877bb40e2f130c8d390660f06fcfeab35ebdb1e0
author Arnaldo Carvalho de Melo <acme@ghostprotocols.net> 1117518097 -0300
committer Arnaldo Carvalho de Melo <acme@ghostprotocols.net> 1117518097 -0300

[IDENT] Add some more attributes

And, like others, ignore it for now.

Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

------------------------------------------------------------------------------

 ident-list.h |    4 ++++
 parse.c      |    8 ++++++++
 2 files changed, 12 insertions(+)

------------------------------------------------------------------------------

diff --git a/ident-list.h b/ident-list.h
--- a/ident-list.h
+++ b/ident-list.h
@@ -47,6 +47,10 @@ IDENT(SI); IDENT(__DI__); IDENT(DI);
 IDENT(__word__); IDENT(word); IDENT(format);
 IDENT(__format__); IDENT(section); IDENT(__section__);
 IDENT(unused); IDENT(__unused__); IDENT(const);
+IDENT(__used__);
+IDENT(warn_unused_result);
+IDENT(noinline);
+IDENT(deprecated);
 IDENT(__const); IDENT(__const__); IDENT(noreturn);
 IDENT(__noreturn__); IDENT(regparm); IDENT(weak);
 IDENT(alias); IDENT(pure); IDENT(always_inline);
diff --git a/parse.c b/parse.c
--- a/parse.c
+++ b/parse.c
@@ -468,6 +468,14 @@ static const char * handle_attribute(str
 		return NULL;
 	if (attribute == &visibility_ident)
 		return NULL;
+	if (attribute == &deprecated_ident)
+		return NULL;
+	if (attribute == &noinline_ident)
+		return NULL;
+	if (attribute == &__used___ident)
+		return NULL;
+	if (attribute == &warn_unused_result_ident)
+		return NULL;
 	if (attribute == &model_ident ||
 	    attribute == &__model___ident)
 		return NULL;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH][LIB] allow changing the gcc version in the defines ===

From: Arnaldo Carvalho de Melo <acme () ghostprotocols ! net>
To: linux-sparse
Subject: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sat, 04 Jun 2005 21:01:51 +0000
Message-ID: <20050604210151.GE27333 () conectiva ! com ! br>
--------------------
Linus, please consider pulling from:

rsync://rsync.kernel.org/pub/scm/linux/kernel/git/acme/sparse.git/

Best Regards,

- Arnaldo

tree bf5663203d17f7a43e40c98c853f4ec20f4edeec
parent 5085b14f147fbe17be33edfaf6735aa131cd9c73
author Arnaldo Carvalho de Melo <acme@ghostprotocols.net> 1117916989 -0300
committer Arnaldo Carvalho de Melo <acme@ghostprotocols.net> 1117916989 -0300

[LIB] allow changing the gcc version in the defines

Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

------------------------------------------------------------------------------

 lib.c |    6 ++++--
 lib.h |    1 +
 2 files changed, 5 insertions(+), 2 deletions(-)

------------------------------------------------------------------------------

diff --git a/lib.c b/lib.c
--- a/lib.c
+++ b/lib.c
@@ -29,6 +29,8 @@
 #include "target.h"
 
 int verbose, optimize, preprocessing;
+int gcc_major = 2;
+int gcc_minor = 95;
 
 struct token *skip_to(struct token *token, int op)
 {
@@ -409,8 +411,8 @@ void declare_builtin_functions(void)
 
 void create_builtin_stream(void)
 {
-	add_pre_buffer("#define __GNUC__ 2\n");
-	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
+	add_pre_buffer("#define __GNUC__ %d\n", gcc_major);
+	add_pre_buffer("#define __GNUC_MINOR__ %d\n", gcc_minor);
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
 
diff --git a/lib.h b/lib.h
--- a/lib.h
+++ b/lib.h
@@ -19,6 +19,7 @@
 
 extern int verbose, optimize, preprocessing;
 extern int repeat_phase, merge_phi_sources;
+extern int gcc_major, gcc_minor;
 
 extern unsigned int hexval(unsigned int c);
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sat, 04 Jun 2005 21:05:40 +0000
Message-ID: <20050604210540.GC32022 () 64m ! dyndns ! org>
--------------------
On Sat, Jun 04, 2005 at 06:01:51PM -0300, Arnaldo Carvalho de Melo wrote:
> +int gcc_major = 2;
> +int gcc_minor = 95;
> ...
> +	add_pre_buffer("#define __GNUC__ %d\n", gcc_major);
> +	add_pre_buffer("#define __GNUC_MINOR__ %d\n", gcc_minor);
> ...
> +extern int gcc_major, gcc_minor;

I am sorry where is the place you change the version? I can't find
the place that actually change the version other than 2.95.
Are you missing a file in the patch?

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sat, 04 Jun 2005 21:22:42 +0000
Message-ID: <Pine.LNX.4.58.0506041421480.1876 () ppc970 ! osdl ! org>
--------------------


On Sat, 4 Jun 2005, Arnaldo Carvalho de Melo wrote:
> 
> rsync://rsync.kernel.org/pub/scm/linux/kernel/git/acme/sparse.git/

I think you've screwed up the repo: it's 

	pub/scm/linux/kernel/git/acme/sparse.git/sparse.git

which is probably not what you wanted to do.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnaldo Carvalho de Melo <acme () ghostprotocols ! net>
To: linux-sparse
Subject: Re: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sat, 04 Jun 2005 21:26:18 +0000
Message-ID: <20050604212618.GF27333 () conectiva ! com ! br>
--------------------
Em Sat, Jun 04, 2005 at 02:22:42PM -0700, Linus Torvalds escreveu:
> 
> 
> On Sat, 4 Jun 2005, Arnaldo Carvalho de Melo wrote:
> > 
> > rsync://rsync.kernel.org/pub/scm/linux/kernel/git/acme/sparse.git/
> 
> I think you've screwed up the repo: it's 
> 
> 	pub/scm/linux/kernel/git/acme/sparse.git/sparse.git
> 
> which is probably not what you wanted to do.

Yup, I fixed this one minute ago, sorry for the confusion.

- Arnaldo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnaldo Carvalho de Melo <acme () ghostprotocols ! net>
To: linux-sparse
Subject: Re: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sun, 05 Jun 2005 01:50:51 +0000
Message-ID: <20050605015050.GG27333 () conectiva ! com ! br>
--------------------
Em Sat, Jun 04, 2005 at 05:05:40PM -0400, Christopher Li escreveu:
> On Sat, Jun 04, 2005 at 06:01:51PM -0300, Arnaldo Carvalho de Melo wrote:
> > +int gcc_major = 2;
> > +int gcc_minor = 95;
> > ...
> > +	add_pre_buffer("#define __GNUC__ %d\n", gcc_major);
> > +	add_pre_buffer("#define __GNUC_MINOR__ %d\n", gcc_minor);
> > ...
> > +extern int gcc_major, gcc_minor;
> 
> I am sorry where is the place you change the version? I can't find
> the place that actually change the version other than 2.95.
> Are you missing a file in the patch?

Sorry, its a tool I'm writing, that uses sparse as a lib and I'll keep it
outside the sparse git tree, just using libsparse.so, if you are curious,
its described here (a bit inacurate at some points, I have to update it):

http://dccp.ghostprotocols.net:81/ostra/ostra.README

Further details here:

http://dccp.ghostprotocols.net:81/ostra/ostra.README.automatic_kernel_module_and_callgraphs

And a nice resulting call graph done with one of the tools here:

http://dccp.ghostprotocols.net:81/ostra/ostra-trace-of-scp-linux-2.6.11.tar.bz2-from-master.kernel.org/

Source code is still outside revision control but the files are
in the same base URL:

http://dccp.ghostprotocols.net:81/ostra/ostra-patch.c
http://dccp.ghostprotocols.net:81/ostra/ostra-grep.c

BEWARE: this thing uses nasty, ugly hacks and probably I'll rewrite it upon
any much appreciated advise people like you and Linus that know more about
compilers and sparse than me may provide :-)

I'm now pushing the few patches I made to sparse, the gcc_version being
the last one and will put the ostra files under revision control and
send an announce to lkml in the next days.

Regards,

- Arnaldo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sun, 05 Jun 2005 02:06:13 +0000
Message-ID: <20050605020613.GE32022 () 64m ! dyndns ! org>
--------------------
On Sat, Jun 04, 2005 at 10:50:51PM -0300, Arnaldo Carvalho de Melo wrote:
> 
> Sorry, its a tool I'm writing, that uses sparse as a lib and I'll keep it
> http://dccp.ghostprotocols.net:81/ostra/ostra.README

Interesting. I wonder how you handle the macro expanded function name.

Chris

PS, I enjoy reading your "understanding the linux virtual memory".

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnaldo Carvalho de Melo <acme () ghostprotocols ! net>
To: linux-sparse
Subject: Re: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sun, 05 Jun 2005 05:30:33 +0000
Message-ID: <20050605053033.GA11145 () conectiva ! com ! br>
--------------------
Em Sat, Jun 04, 2005 at 10:06:13PM -0400, Christopher Li escreveu:
> On Sat, Jun 04, 2005 at 10:50:51PM -0300, Arnaldo Carvalho de Melo wrote:
> > 
> > Sorry, its a tool I'm writing, that uses sparse as a lib and I'll keep it
> > http://dccp.ghostprotocols.net:81/ostra/ostra.README
> 
> Interesting. I wonder how you handle the macro expanded function name.

As I said the README is not up to latest state of the tools, the hooks are
actually called with just codes, one for the file (e.g. net/ipv4/tcp.c) and
other for the function, ostra-create-table searches the files created by
ostra-grep and creates to tables, excerpts:

[acme@toy trunk]$ head .ostra_sock.files
0:net/dccp/ccid.c
1:net/dccp/dccp_proto.c
2:net/dccp/dccp_diag.c
3:net/dccp/dccp_minisocks.c
4:net/dccp/dccp_ipv4.c
5:net/dccp/dccp_output.c
6:net/dccp/dccp_input.c
7:net/dccp/dccp_timer.c
8:net/dccp/dccp_options.c
9:net/dccp/ccids/dccp_ccid3.c
[acme@toy trunk]$ head .ostra_sock.functions
0:0:ccid_init:no
0:1:ccid_exit:no
1:0:dccp_disconnect:no
1:1:dccp_ioctl:no
1:2:dccp_setsockopt:no
1:3:dccp_getsockopt:no
1:4:dccp_sendmsg:no
1:5:dccp_recvmsg:no
1:6:dccp_close_state:no
1:7:dccp_close:no
[acme@toy trunk]$

The encoded trace looks like this:

[acme@toy trunk]$ head ~/encoded_trace.txt
1117864098.898869 i:27:15:97b4d020:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
1117864098.899104 i:18:0:97b4d020:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
1117864098.899199 i:11:0:97b4d020:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
1117864098.899293 o:11:0:97b4d020:0
1117864098.899322 o:18:0:97b4d020:0
1117864098.899363 o:27:15:97b4d020:0
1117864098.899627 i:26:8:97b4d020:0:0:0:0:0:0:0:536:536:0:0:0:0:0:0:2:0:0:0:0:0:2147483647:0:0:0:300:0:0:0:300:0:0:0:0:0:3:0:0:0:0:65535:0:0:0:0:0:0:0
1117864098.899721 i:12:24:97b4d020:0:0:0:0:0:0:0:536:536:0:0:0:0:0:0:2:0:0:0:0:0:2147483647:0:0:0:300:0:0:0:300:0:0:0:0:0:3:0:0:0:0:65535:0:0:0:0:0:0:0
1117864098.899808 o:12:24:97b4d020:0
1117864098.899860 i:27:5:97b4d020:0:0:0:0:0:0:0:536:536:0:0:0:0:0:0:2:0:0:0:0:0:2147483647:0:0:0:300:0:0:0:300:0:0:0:0:0:3:0:0:0:0:65535:0:0:0:0:0:0:0
[acme@toy trunk]$

And the fields table:

[acme@toy trunk]$ head .ostra_sock_tcp.fields
0:action:no:None:None:entry,exit
1:file_id:no:None:None:entry,exit
2:function_id:no:None:None:entry,exit
3:object:yes:None:%p:entry,exit
4:saddr:no:inet_sk(%object)->saddr:d:entry
5:sport:no:ntohs(inet_sk(%object)->sport):d:entry
6:daddr:no:inet_sk(%object)->daddr:d:entry
7:dport:no:ntohs(inet_sk(%object)->dport):d:entry
8:wmem_alloc:yes:atomic_read(&%object->sk_wmem_alloc):d:entry
9:rmem_alloc:yes:atomic_read(&%object->sk_rmem_alloc):d:entry
[acme@toy trunk]$

ostra-cg creates the callgraphs reading the above files and generating a
txt file with a callgraph like this:

1117660575.543400 tcp_v4_init_sock(pkts_out=0, advmss=0, rcv_wnd=0, max_window=0, snd_cwnd=0, ecn_flags=0, mss=0, snd_nxt=0, westwood_rtt=0, pmtu=0, rcv_ssthresh=0, wclamp=0, object=97b57020, mdev=0, snd_ssthresh=0, retrans_out=0, westwood_bw_est=0, rmem_alloc=0, srtt=0, wmem_alloc=0)  {
1117660575.543957 	tcp_init_xmit_timers()  {
1117660575.544030 		csk_init_xmit_timers()  { } EXIT #1 64us
1117660575.544124 	} EXIT #1 (tcp_init_xmit_timers) 167us
1117660575.544165 } EXIT #1 (tcp_v4_init_sock) 765us 1117660575.544790 lock_sock(snd_cwnd=2, mss=536, snd_ssthresh=2147483647, retrans_out=2147483647)  { } EXIT #1 95us
1117660575.544934 tcp_v4_connect()  {
1117660575.545957 	ip_route_output_flow()  { } EXIT #2 194us
1117660575.546371 	inet_csk_bind_hash()  { } EXIT #1 85us
1117660575.546539 	ip_route_output_flow()  { } EXIT #3 99us
1117660575.546716 	tcp_connect()  {
1117660575.546788 		tcp_sync_mss()  { } EXIT #1 72us
1117660575.547134 		tcp_transmit_skb(pkts_out=1, advmss=1460, rcv_wnd=5840, mss=524, pmtu=1500, rcv_ssthresh=5840, wclamp=262140, mdev=-1493474123)  {
1117660575.547264 			tcp_advertise_mss(wmem_alloc=376) { } EXIT #1 75us
1117660575.547399 			tcp_v4_send_check()  { } EXIT #1 115us
1117660575.548505 		} EXIT #1 (tcp_transmit_skb) 1371us
1117660575.548580 		sk_reset_timer(wmem_alloc=0)  { } EXIT #1 146us
1117660575.548756 	} EXIT #2 (tcp_connect) 2040us
1117660575.548790 } EXIT #6 (tcp_v4_connect) 3856us
1117660575.548838 release_sock()  { } EXIT #1 80us

(Actually is a bit better, this one is a bit old)

Or if in html + javascript mode generates a callgraph with buttons to see
the tracked internal state of the struct $OSTRA_TRACED_CLASS, and also
creates a changes.html file with the places in the trace where each field
changed, I plan to also do gnuplot like graphs of fields x time, etc.

The latest HTML + javascript callgraph is at:

http://dccp.ghostprotocols.net:81/ostra/ostra-trace-of-scp-linux-2.6.11.tar.bz2-from-master.kernel.org/

Tracing all the non-inline, non macro functions that have a struct sock
pointer as a parameter found by ostra-grep plus some manually added inline
functions that receive a struct sock as one of its arguments plus some
functions that receive a struct that has as one of its members a struct
sock pointer, such as struct socket and struct sk_buff (ip_queue_xmit, for
instance).

These manually added functions are to test the concept of "superclasses",
i.e. struct socket has a struct sock as one of its members, the name
"superclass" isn't that precise, as struct sk_buff is not conceptually a
struct sock superclass, just having a struct sock backpointer, anyway,
the idea is that one will be able to say "follow struct foo methods and
also struct bar methods, passing bar->baz to the trace collecting hooks".

> Chris
> 
> PS, I enjoy reading your "understanding the linux virtual memory".

Huh, I think you are making some confusion here, I'm not a VM hacker :)

- Arnaldo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnaldo Carvalho de Melo <acme () ghostprotocols ! net>
To: linux-sparse
Subject: Re: [PATCH][LIB] allow changing the gcc version in the defines
Date: Sun, 05 Jun 2005 05:33:11 +0000
Message-ID: <20050605053311.GB11145 () conectiva ! com ! br>
--------------------
Em Sun, Jun 05, 2005 at 02:30:33AM -0300, Arnaldo Carvalho de Melo escreveu:
> Em Sat, Jun 04, 2005 at 10:06:13PM -0400, Christopher Li escreveu:
> > On Sat, Jun 04, 2005 at 10:50:51PM -0300, Arnaldo Carvalho de Melo wrote:
> > > 
> > > Sorry, its a tool I'm writing, that uses sparse as a lib and I'll keep it
> > > http://dccp.ghostprotocols.net:81/ostra/ostra.README
> > 
> > Interesting. I wonder how you handle the macro expanded function name.
> 
> As I said the README is not up to latest state of the tools, the hooks are
> actually called with just codes, one for the file (e.g. net/ipv4/tcp.c) and
> other for the function, ostra-create-table searches the files created by
> ostra-grep and creates to tables, excerpts:

Ah, and I have already created a git repo for ostra, is at:

rsync://rsync.kernel.org/pub/scm/linux/kernel/git/acme/ostra.git/

- Arnaldo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH][RESEND] Don't emit warnings after "too many warnings". ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH][RESEND] Don't emit warnings after "too many warnings".
Date: Mon, 31 Jan 2005 16:25:15 +0000
Message-ID: <200501311923.24686.adobriyan () mail ! ru>
--------------------
After "too many warnings" sparse continues to produce the rest of multiline
warnings.

drivers/net/tokenring/ibmtr.c:1274:19: warning: incorrect type in argument 1 (different base types)
drivers/net/tokenring/ibmtr.c:1274:19:    expected void const volatile [noderef] *addr<asn:2>
drivers/net/tokenring/ibmtr.c:1274:19:    got unsigned int srb
drivers/net/tokenring/ibmtr.c:1277:34: warning: too many warnings
drivers/net/tokenring/ibmtr.c:1277:34:    expected void const volatile [noderef] *addr<asn:2>
drivers/net/tokenring/ibmtr.c:1277:34:    got unsigned int

So introduce warning_info(). The only difference from info() is that
warning_info shuts up after certain amount of warnings.

diff -uprN 1.1240/evaluate.c 1.1240-toomany/evaluate.c
--- 1.1240/evaluate.c	2005-01-23 21:52:43.000000000 +0200
+++ 1.1240-toomany/evaluate.c	2005-01-24 21:32:53.000000000 +0200
@@ -272,12 +272,15 @@ static struct symbol *bad_expr_type(stru
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
-		info(expr->pos, "   left side has type %s", show_typename(expr->left->ctype));
-		info(expr->pos, "   right side has type %s", show_typename(expr->right->ctype));
+		warning_info(expr->pos, "   left side has type %s",
+				show_typename(expr->left->ctype));
+		warning_info(expr->pos, "   right side has type %s",
+				show_typename(expr->right->ctype));
 		break;
 	case EXPR_PREOP:
 	case EXPR_POSTOP:
-		info(expr->pos, "   argument has type %s", show_typename(expr->unop->ctype));
+		warning_info(expr->pos, "   argument has type %s",
+				show_typename(expr->unop->ctype));
 		break;
 	default:
 		break;
@@ -1086,8 +1089,8 @@ static int compatible_assignment_types(s
 	}
 
 	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
-	info(expr->pos, "   expected %s", show_typename(target));
-	info(expr->pos, "   got %s", show_typename(source));
+	warning_info(expr->pos, "   expected %s", show_typename(target));
+	warning_info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
 	return 0;
 Cast:
diff -uprN 1.1240/lib.c 1.1240-toomany/lib.c
--- 1.1240/lib.c	2005-01-23 21:52:43.000000000 +0200
+++ 1.1240-toomany/lib.c	2005-01-24 21:32:53.000000000 +0200
@@ -302,12 +302,13 @@ void info(struct position pos, const cha
 	va_end(args);
 }
 
+static int warnings_nr = 0;
+
 void warning(struct position pos, const char * fmt, ...)
 {
-	static int warnings = 0;
 	va_list args;
 
-	if (warnings > 100) {
+	if (warnings_nr > 100) {
 		static int once = 0;
 		if (once)
 			return;
@@ -318,9 +319,21 @@ void warning(struct position pos, const 
 	va_start(args, fmt);
 	do_warn("warning: ", pos, fmt, args);
 	va_end(args);
-	warnings++;
+	warnings_nr++;
 }	
 
+void warning_info(struct position pos, const char *fmt, ...)
+{
+	va_list args;
+
+	if (warnings_nr > 100 + 1)
+		return;
+
+	va_start(args, fmt);
+	do_warn("", pos, fmt, args);
+	va_end(args);
+}
+
 void error(struct position pos, const char * fmt, ...)
 {
 	static int errors = 0;
diff -uprN 1.1240/lib.h 1.1240-toomany/lib.h
--- 1.1240/lib.h	2005-01-23 21:52:43.000000000 +0200
+++ 1.1240-toomany/lib.h	2005-01-24 21:32:53.000000000 +0200
@@ -71,6 +71,7 @@ struct token *expect(struct token *, int
 extern void die(const char *, ...) FORMAT_ATTR(1);
 extern void info(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void warning(struct position, const char *, ...) FORMAT_ATTR(2);
+extern void warning_info(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void error(struct position, const char *, ...) FORMAT_ATTR(2);
 extern void error_die(struct position, const char *, ...) FORMAT_ATTR(2);
 #undef FORMAT_ATTR
diff -uprN 1.1240/pre-process.c 1.1240-toomany/pre-process.c
--- 1.1240/pre-process.c	2005-01-23 21:52:43.000000000 +0200
+++ 1.1240-toomany/pre-process.c	2005-01-24 21:32:53.000000000 +0200
@@ -1091,7 +1091,8 @@ static int do_handle_define(struct strea
 				return 1;
 			warning(left->pos, "preprocessor token %.*s redefined",
 					name->len, name->name);
-			info(sym->pos, "this was the original definition");
+			warning_info(sym->pos,
+					"this was the original definition");
 			sym->expansion = expansion;
 			sym->arglist = arglist;
 		}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATH] remove multi-inclusion guard from target.c ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [PATH] remove multi-inclusion guard from target.c
Date: Mon, 27 Jun 2005 21:16:04 +0000
Message-ID: <20050627211604.GA3016 () ralph05 ! lan>
--------------------
This patch remove the multi-inclusion guard present in target.c
(coming, I suppose, from target.h from which it was copied).


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/target.c b/target.c
--- a/target.c
+++ b/target.c
@@ -1,6 +1,3 @@
-#ifndef TARGET_H
-#define TARGET_H
-
 #include <stdio.h>
 
 #include "symbol.h"
@@ -46,5 +43,3 @@ int pointer_alignment = 4;
  */
 int bits_in_enum = 32;
 int enum_alignment = 4;
-
-#endif
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] INSN_HASH_SIZE too big? ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: [RFC] INSN_HASH_SIZE too big?
Date: Sun, 15 May 2005 14:34:18 +0000
Message-ID: <20050515143418.GA1924 () ralph05 ! lan>
--------------------
Hi,

I'm playing with test-linearize and example and I found that these are rather slow.
gprof identify cleanup_and_cse() as the most time consuming function
(called 167 times; 0.19 sec; 62% of the execution time for "test-linearize evaluate.c").
Further investigation show that the loop is executed 19267878 times
(a bit less than 2*167*INSN_HASH_SIZE)
but that the real code inside this loop, the one for non-empty entry in the hash-table, is executed only 5401 times.
So, for this "compilation", only one slot in ~3500 is non-empty.
Changing INSN_HASH_SIZE from 65536 to 1024, make the loop only being executed
301056 times and as consequence cleanup_and_cse() take only 0.01-0.02 sec, 7% of the total execution time.

A value of 1024-4096 seems to give good result, but may impact (very-)large function.
Maybe the solution should be to adapt this value to the size of the compiled function?


-- 
Luc Van Oostenryck


Index: cse.c
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/cse.c  (mode:100644)
+++ uncommitted/cse.c  (mode:100644)
@@ -17,7 +17,7 @@
 #include "linearize.h"
 #include "flow.h"
 
-#define INSN_HASH_SIZE 65536
+#define INSN_HASH_SIZE 1024
 static struct instruction_list *insn_hash_table[INSN_HASH_SIZE];
 
 int repeat_phase;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: [RFC] INSN_HASH_SIZE too big?
Date: Sun, 15 May 2005 23:44:39 +0000
Message-ID: <4287DEE7.7010301 () looxix ! net>
--------------------
Christopher Li wrote:
> Do you number of total execution time of the whole program before and
> after the change? Compiling the kernel source will be a good test case.

I haven't tried with the kernel, but with a bigger test (a concatenation of misc source files, 480Kb in total)
the total execution time (as mesured by the time command) change from 2.847 to 0.723 sec.

> It sounds like not worthy the complexity at this point.

Yes, not for the moment.

> Chris
> 

Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] [PATCH] clean up cclass ===

From: Alecs King <alecsk () gmail ! com>
To: linux-sparse
Subject: [RFC] [PATCH] clean up cclass
Date: Sat, 31 Dec 2005 07:20:55 +0000
Message-ID: <20051231072055.GA2323 () localhost>
--------------------
Is there a good reason to always add that '+ 1' in both initialization
and dereference of cclass?

This patch just remove that unnecessary '+ 1'.

Signed-off-by: Alecs King <alecsk@gmail.com>


diff --git a/tokenize.c b/tokenize.c
index 497da13..7464b5a 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -347,30 +347,30 @@ enum {
 	ValidSecond = 32,
 };
 
-static const long cclass[257] = {
-	['0' + 1 ... '9' + 1] = Digit | Hex,
-	['A' + 1 ... 'D' + 1] = Letter | Hex,
-	['E' + 1] = Letter | Hex | Exp,
-	['F' + 1] = Letter | Hex,
-	['G' + 1 ... 'O' + 1] = Letter,
-	['P' + 1] = Letter | Exp,
-	['Q' + 1 ... 'Z' + 1] = Letter,
-	['a' + 1 ... 'd' + 1] = Letter | Hex,
-	['e' + 1] = Letter | Hex | Exp,
-	['f' + 1] = Letter | Hex,
-	['g' + 1 ... 'o' + 1] = Letter,
-	['p' + 1] = Letter | Exp,
-	['q' + 1 ... 'z' + 1] = Letter,
-	['_' + 1] = Letter,
-	['.' + 1] = Dot | ValidSecond,
-	['=' + 1] = ValidSecond,
-	['+' + 1] = ValidSecond,
-	['-' + 1] = ValidSecond,
-	['>' + 1] = ValidSecond,
-	['<' + 1] = ValidSecond,
-	['&' + 1] = ValidSecond,
-	['|' + 1] = ValidSecond,
-	['#' + 1] = ValidSecond,
+static const long cclass[256] = {
+	['0' ... '9'] = Digit | Hex,
+	['A' ... 'D'] = Letter | Hex,
+	['E'] = Letter | Hex | Exp,
+	['F'] = Letter | Hex,
+	['G' ... 'O'] = Letter,
+	['P'] = Letter | Exp,
+	['Q' ... 'Z'] = Letter,
+	['a' ... 'd'] = Letter | Hex,
+	['e'] = Letter | Hex | Exp,
+	['f'] = Letter | Hex,
+	['g' ... 'o'] = Letter,
+	['p'] = Letter | Exp,
+	['q' ... 'z'] = Letter,
+	['_'] = Letter,
+	['.'] = Dot | ValidSecond,
+	['='] = ValidSecond,
+	['+'] = ValidSecond,
+	['-'] = ValidSecond,
+	['>'] = ValidSecond,
+	['<'] = ValidSecond,
+	['&'] = ValidSecond,
+	['|'] = ValidSecond,
+	['#'] = ValidSecond,
 };
 
 /*
@@ -394,7 +394,7 @@ static int get_one_number(int c, int nex
 
 	*p++ = c;
 	for (;;) {
-		long class =  cclass[next + 1];
+		long class =  cclass[next];
 		if (!(class & (Dot | Digit | Letter)))
 			break;
 		if (p != buffer_end)
@@ -647,7 +647,7 @@ static int get_one_special(int c, stream
 	 * Check for combinations
 	 */
 	value = c;
-	if (cclass[next + 1] & ValidSecond) {
+	if (cclass[next] & ValidSecond) {
 		comb = combinations[0];
 		c1 = c; c2 = next; c3 = 0;
 		for (i = 0; i < NR_COMBINATIONS; i++) {
@@ -810,7 +810,7 @@ static int get_one_identifier(int c, str
 	buf[0] = c;
 	for (;;) {
 		next = nextchar(stream);
-		if (!(cclass[next + 1] & (Letter | Digit)))
+		if (!(cclass[next] & (Letter | Digit)))
 			break;
 		if (len >= sizeof(buf))
 			break;
@@ -832,7 +832,7 @@ static int get_one_identifier(int c, str
 
 static int get_one_token(int c, stream_t *stream)
 {
-	long class = cclass[c + 1];
+	long class = cclass[c];
 	if (class & Digit)
 		return get_one_number(c, nextchar(stream), stream);
 	if (class & Letter)

-- 
Alecs King
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [RFC] [PATCH] clean up cclass
Date: Sat, 31 Dec 2005 21:26:39 +0000
Message-ID: <Pine.LNX.4.64.0512311320350.3249 () g5 ! osdl ! org>
--------------------


On Sat, 31 Dec 2005, Alecs King wrote:
>
> Is there a good reason to always add that '+ 1' in both initialization
> and dereference of cclass?

EOF, aka -1.

Now, whether that's a good enough reason for ugly code, I don't know. You 
could do the same by doing something like

	static const struct {
		long eof;
		long c[256];
	} cclass = { 0 , { ..sane initializer.. } };

and then using

	cclass.c[next]

without the "+1". It might noe be strictly conforming, but it sure as hell 
should work in practice.

Another (perhaps better) alternative is to change the #define of EOF from 
-1 to 256, and then make sure that we don't rely on "next < 0" anywhere 
(which we might do by changing the type to "unsigned int" and expecting 
the compiler to complain.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] [PATCH] minor cleanup of type-checking for ptrlist.h ===

From: Alecs King <alecsk () gmail ! com>
To: linux-sparse
Subject: [RFC] [PATCH] minor cleanup of type-checking for ptrlist.h
Date: Sat, 31 Dec 2005 07:20:40 +0000
Message-ID: <20051231072040.GA1638 () localhost>
--------------------
DECLARE_PTR_LIST and friends are for 'Silly type-safety check'.  The
member (type *list[1]) of strust listname is never directly
dereferenced or used except for CHECK_TYPE things.  So why was it made
an array of pointer instead of simply a pointer?  IMHO, it gives no
benefits but complicates things a bit.  Or am i missing something?

This patch just change the array of pointer to a pointer.

Signed-off-by: Alecs King <alecsk@gmail.com>


diff --git a/dissect.c b/dissect.c
index 7a13ffa..be809f1 100644
--- a/dissect.c
+++ b/dissect.c
@@ -14,7 +14,7 @@
 
 #define	DO_LIST(l__, p__, expr__)		\
 	do {					\
-		typeof(l__->list[0]) p__;	\
+		typeof(l__->list) p__;	\
 		FOR_EACH_PTR(l__, p__)		\
 			expr__;			\
 		END_FOR_EACH_PTR(p__);		\
@@ -22,8 +22,8 @@
 
 #define	DO_2_LIST(l1__,l2__, p1__,p2__, expr__)	\
 	do {					\
-		typeof(l1__->list[0]) p1__;	\
-		typeof(l2__->list[0]) p2__;	\
+		typeof(l1__->list) p1__;	\
+		typeof(l2__->list) p2__;	\
 		PREPARE_PTR_LIST(l1__, p1__);	\
 		FOR_EACH_PTR(l2__, p2__)	\
 			expr__;			\
diff --git a/ptrlist.h b/ptrlist.h
index b42a0ca..6f1a289 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -11,10 +11,10 @@
 	(type *)((void *)(ptr) - offsetof(type, member))
 
 /* Silly type-safety check ;) */
-#define DECLARE_PTR_LIST(listname,type)	struct listname { type *list[1]; }
-#define CHECK_TYPE(head,ptr)		(void)(&(ptr) == &(head)->list[0])
-#define TYPEOF(head)			__typeof__(&(head)->list[0])
-#define VRFY_PTR_LIST(head)		(void)(sizeof((head)->list[0]))
+#define DECLARE_PTR_LIST(listname,type)	struct listname { type *list; }
+#define CHECK_TYPE(head,ptr)		(void)(&(ptr) == &(head)->list)
+#define TYPEOF(head)			__typeof__(&(head)->list)
+#define VRFY_PTR_LIST(head)		(void)(sizeof((head)->list))
 
 #define LIST_NODE_NR (29)
 

-- 
Alecs King
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] sparse(1) manpage: 0-order approximation ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: [RFC] sparse(1) manpage: 0-order approximation
Date: Sun, 18 Sep 2005 18:32:42 +0000
Message-ID: <20050918183241.GA787 () mipter ! zuzino ! mipt ! ru>
--------------------
This is a _very_ rough cut of future sparse manpage. I just want to
share it with the rest of the class early.

#include <disclaimers/first-manpage.h>
#include <disclaimers/english-is-not-native-language.h>
--------------------------------------------------------------------------------
SPARSE(1)                                                            SPARSE(1)



NAME
       sparse - static C code analysis tool with emphasis on type checking

SYNOPSIS
       sparse  [-Dmacro[=def]]  [-E]  [-I-] [-Ipath] [-include file] [-imacros
       file] [-isystem path] [-m64] [-Umacro] [-v] [-Wwarn...] file [file] ...


FEATURES
   Stricter type-checking
       1


   Address spaces
       1


OPTIONS
       -Dmacro[=def]
              Equivalent of #define macro def at the beginning of a file.


       -E     Preprocess only.


       -I-    1


       -Ipath 1


       -include file
              1


       -imacros file
              1


       -isystem path
              1


       -m64   Pretend  to  check  on  a 64-bit machine. In particular, enforce
              sizeof(long) = 8.


       -Umacro
              Equivalent of #undef macro at the beginning of a file.


       -v     Be verbose.


              All -Wwarn options also have -W[no-]warn form.


       -Wcast-to-as
              1


       -Wptr-subtraction-blows
              Warn about potentially expensive pointer subtractions.


       -Wdefault-bitfield-sign
              Warn about bitfields without explicit signedness.


       -Wundef
              Warn about undefined preprocessor identifiers.


       -Wbitwise
              1


       -Wtypesign
              1


       -Wcontext
              1


NOT BUGS
   Nested functions
       They're broken by design and only parsed  to  the  extent  that  sparse
       doesn't segfaults on them.


   K&R function prototypes
       They're parsed but you won't get any types for function parameters. Use
       ANSI C prototypes.


REPORTING BUGS
       Please, report bugs to linux-sparse@vger.kernel.org




                                                                     SPARSE(1)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC][PATCH] dissect.c ===

From: Oleg Nesterov <oleg () tv-sign ! ru>
To: linux-sparse
Subject: [RFC][PATCH] dissect.c
Date: Sun, 04 Sep 2005 16:36:12 +0000
Message-ID: <431B227C.1B4507DB () tv-sign ! ru>
--------------------
Hello.

This patch adds dissect.{h,c} files to the sparse distribution.

================================================================================


################################################################################

=== Thread: [patch] __attribute__ handling for attributes used in the ===

From: Peter Jones <pjones () redhat ! com>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the
Date: Mon, 20 Jun 2005 20:42:48 +0000
Message-ID: <1119300168.19644.64.camel () localhost ! localdomain>
--------------------
On Mon, 2005-06-20 at 11:33 -0700, Linus Torvalds wrote:
> 
> On Mon, 20 Jun 2005, Peter Jones wrote:
> > 
> > It also handles c99's "int *foo[restrict]" syntax, but only in a minimal
> > way.  This part could use some work.
> 
> Indeed. Please make it a proper identifier, and use
> 
> 	token->ident == restrict_ident || token->ident == __restrict_ident
> 
> instead of using a "strcmp()". The sparse identifier core is really quite 
> good, if I say so myself, and it's easy to add a new identifier in 
> ident-list.h (and it does not make it "reserved" in any other way, you 
> need to do other things to mark something reserved).

That's a good point, thanks for pointing it out.  Fixed in the patch
below.

But that's not what I was getting at.  I was actually thinking that it
aught to check that it's being used in an array size.  And in general,
restrict probably needs some special handling like const and volatile
get.

> > This also changes it to claim to be gcc 4.0, and defines
> > __STDC_VERSION__ as 199901L.
> 
> Hmm.. My current tree already claims "same as host compiler" by default, 
> with 2.95 as the default for a non-gcc host compiler.

Oh, then I just didn't do enough work when I merged my changes, which
were originally against a checkout from ~2 weeks ago.  Back then they
were constants, not variables, and I didn't look to see if there was
already code doing something with the vars.  Reverted in the patch
below.

> As to the std C version, I'm wondering what C99 stuff we don't even parse 
> yet, and that could make people validly unhappy? Does anybody have a list?

The obvious things grep found that this will do in a normal-ish (i.e.
glibc) userland are:

#define __GLIBC_HAVE_LONG_LONG
 -> declare atoll, strtoq, strtoll
 -> declare __int64_t, __uint64_t, __quad_t, __u_quad_t on boxes with
    32-bit words, with "__extension__"
 -> define gnu_dev_major, gnu_dev_minor, and gnu_dev_makedev, with
    __extension__, and make major(), minor(), and makedev() macros
    using these.
 -> declare int64_t and u_int64_t
 -> makes __pthread_cond_align_t a long long instead of a long

#define __USE_ISOC99
 -> define acosh, asinh, atanh, expm1, log1p, logb, exp2, log2,
    hypot, copysign, nan,erf, erfc, lgamma, tgamma, rint, and a
    bunch of other math functions.
 -> declare isblank
 -> define LLONG_MAX, LLONG_MIN, and ULLONG_MAX without using
    LONG_LONG_MAX
 -> add lots of stuff to "struct lconv"
 -> declare snprintf, vsnprintf, vfscanf, vscanf, vsscanf
 -> declare strtof, strtold, strtoll, strtoull, atoll
 -> declare wint_t, vfwscanf, vwscanf, vswscanf, fwide, fwprintf, etc.
 
_not_ "#define inline __inline__" (in c99 it's a keyword)
"#define __restrict restrict" if it's not already defined
make assert use __func__

"#define _HAVE_UINT64_T" and declare the associated types (this might
happen anyway, depending on other #defs)

defines __flexarr with the syntax for a c99 flexible array instead of
the GNU C zero-length array extension.

adds a unsigned char __flexarr field to "struct cmsghdr" for the msg
data.

"#define __restrict_arr restrict" if you're not using gcc

Ok, here's a new patch:

Index: expression.c
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/expression.c  (mode:100644 sha1:8a1b40e65726d3d66ecc195e9f4eb2954e334176)
+++ uncommitted/expression.c  (mode:100664)
@@ -316,7 +316,9 @@
 		 *
 		 *	if (typeof(a) == int) ..
 		 */
-		if (sym && sym->namespace == NS_TYPEDEF) {
+		if (sym && sym->namespace == NS_TYPEDEF &&
+                    (token->ident == &restrict_ident ||
+                     token->ident == &__restrict_ident)) {
 			warning(token->pos, "typename in expression");
 			sym = NULL;
 		}
Index: ident-list.h
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/ident-list.h  (mode:100644 sha1:913b26231b5ea443aabe968def38be5f42e97630)
+++ uncommitted/ident-list.h  (mode:100664)
@@ -52,12 +52,20 @@
 IDENT(noinline);
 IDENT(deprecated);
 IDENT(__const); IDENT(__const__); IDENT(noreturn);
-IDENT(__noreturn__); IDENT(regparm); IDENT(weak);
+IDENT(__noreturn__); IDENT(regparm); IDENT(weak); IDENT(__weak__);
 IDENT(alias); IDENT(pure); IDENT(always_inline);
 IDENT(syscall_linkage); IDENT(visibility);
-IDENT(bitwise);
+IDENT(bitwise); IDENT(__bitwise__);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
+IDENT(nothrow); IDENT(__nothrow); IDENT(__nothrow__);
+IDENT(__transparent_union__);
+IDENT(__pure__);
+IDENT(__malloc__);
+IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
+IDENT(__deprecated__);
+IDENT(__warn_unused_result__);
+IDENT(restrict); IDENT(__restrict);
 
 /* Preprocessor idents */
 __IDENT(pragma_ident, "__pragma__", 0);
Index: lib.c
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/lib.c  (mode:100644 sha1:8a2bc72e4a915b9e7c58359e3fbedd9094fbafa6)
+++ uncommitted/lib.c  (mode:100664)
@@ -164,6 +164,7 @@
 int Wcontext = 0;
 int Wundefined_preprocessor = 0;
 int Wptr_subtraction_blows = 0;
+int Wtransparent_union = 1;
 int preprocess_only;
 char *include;
 int include_fd = -1;
@@ -294,6 +295,7 @@
 	{ "bitwise", &Wbitwise },
 	{ "typesign", &Wtypesign },
 	{ "context", &Wcontext },
+	{ "transparent-union", &Wtransparent_union },
 };
 
 
@@ -423,6 +425,7 @@
 	// the right __SIZE_TYPE__.
 	add_pre_buffer("#weak_define __SIZE_TYPE__ long unsigned int\n");
 	add_pre_buffer("#weak_define __STDC__ 1\n");
+	add_pre_buffer("#weak_define __STDC_VERSION__ 199901L\n");
 
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
Index: lib.h
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/lib.h  (mode:100644 sha1:564c836fdd7e7de15241567774247d685e75541e)
+++ uncommitted/lib.h  (mode:100664)
@@ -80,6 +80,7 @@
 extern int Wdefault_bitfield_sign;
 extern int Wundefined_preprocessor;
 extern int Wbitwise, Wtypesign, Wcontext;
+extern int Wtransparent_union;
 
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
Index: parse.c
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/parse.c  (mode:100644 sha1:629d638fda2ce959f55b7324055e32f042ac7991)
+++ uncommitted/parse.c  (mode:100664)
@@ -373,7 +373,8 @@
 		ctype->modifiers |= MOD_FORCE;
 		return NULL;
 	}
-	if (attribute == &bitwise_ident) {
+	if (attribute == &bitwise_ident ||
+            attribute == &__bitwise___ident) {
 		if (Wbitwise)
 			ctype->modifiers |= MOD_BITWISE;
 		return NULL;
@@ -437,6 +438,21 @@
 	}
 
 	/* Throw away for now.. */
+	if (attribute == &__transparent_union___ident) {
+		if (Wtransparent_union)
+		    return "ignoring attribute __transparent_union__";
+		return NULL;
+	}
+	if (attribute == &nothrow_ident ||
+	    attribute == &__nothrow_ident ||
+	    attribute == &__nothrow___ident)
+		return NULL;
+	if (attribute == &__malloc___ident)
+		return NULL;
+	if (attribute == &nonnull_ident ||
+	    attribute == &__nonnull_ident ||
+	    attribute == &__nonnull___ident)
+		return NULL;
 	if (attribute == &format_ident ||
 	    attribute == &__format___ident ||
 	    attribute == &__format_arg___ident)
@@ -456,11 +472,13 @@
 		return NULL;
 	if (attribute == &regparm_ident)
 		return NULL;
-	if (attribute == &weak_ident)
+	if (attribute == &weak_ident ||
+	    attribute == &__weak___ident)
 		return NULL;
 	if (attribute == &alias_ident)
 		return NULL;
-	if (attribute == &pure_ident)
+	if (attribute == &pure_ident ||
+	    attribute == &__pure___ident)
 		return NULL;
 	if (attribute == &always_inline_ident)
 		return NULL;
@@ -468,13 +486,15 @@
 		return NULL;
 	if (attribute == &visibility_ident)
 		return NULL;
-	if (attribute == &deprecated_ident)
+	if (attribute == &deprecated_ident ||
+	    attribute == &__deprecated___ident)
 		return NULL;
 	if (attribute == &noinline_ident)
 		return NULL;
 	if (attribute == &__used___ident)
 		return NULL;
-	if (attribute == &warn_unused_result_ident)
+	if (attribute == &warn_unused_result_ident ||
+	    attribute == &__warn_unused_result___ident)
 		return NULL;
 	if (attribute == &model_ident ||
 	    attribute == &__model___ident)


-- 
        Peter

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Peter Jones <pjones () redhat ! com>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the
Date: Tue, 21 Jun 2005 05:00:08 +0000
Message-ID: <1119330008.6309.17.camel () localhost ! localdomain>
--------------------
On Mon, 2005-06-20 at 19:54 -0700, Linus Torvalds wrote:
> Well, I already applied a edited version of your previous patch, with just 
> the attribute changes. Mind re-diffing and testing?

Will do, but probably later tonight or tomorrow.  I seem to have messed
up my git checkout somehow.

> (Also in general, I tend to much prefer getting two separate patches doing 
> two separate things, even if it's a bit more work both for the sender and 
> for me. It just makes things _so_ much cleaner in the revision history, 
> and it also helps if I end up liking one patch but not the other for some 
> reason).

So noted.

> Ah.. And yes, the horrid example that Luc posted had a lot more than 
> "restrict" inside the []. So clearly this is more than just pointing out 
> that the pointer is restricted, you can point out other type attributes.
> 
> I don't quite see why you'd put them inside the [] instead of outside, but 
> maybe it has some deeper meaning that I just haven't fathomed. Or maybe 
> it's just syntactic fluff. 

"char * restrict a;" means you've got a restricted pointer to a char.
"char a[restrict];" is the same thing, but it's an array object still,
not merely a pointer.

"static" is more interesting here -- "char a[static 10]" as an argument
means "a pointer that's not null and points to an array of at least 10
char elements".

I'm not sure why you'd stick volatile inside the brackets.

> Ok, looks like "restrict" and the strange array declarations are the main 
> ones from a parsing perspective.
> 
> Probably not very commonly used either.

4 times in glibc's headers.  So yeah, not much.

-- 
        Peter

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [patch] __attribute__ handling for attributes used in the userland ===

From: Peter Jones <pjones () redhat ! com>
To: linux-sparse
Subject: [patch] __attribute__ handling for attributes used in the userland
Date: Mon, 20 Jun 2005 17:51:55 +0000
Message-ID: <1119289915.19644.15.camel () localhost ! localdomain>
--------------------
Here's a patch that adds stubs for several attributes used in userland.
This version of the patch includes a warning, which defaults to on, if
you use gcc's "transparent_union" attribute, and has a flag
(-Wno-transparent-union) to turn the warning off.

It also handles c99's "int *foo[restrict]" syntax, but only in a minimal
way.  This part could use some work.

This also changes it to claim to be gcc 4.0, and defines
__STDC_VERSION__ as 199901L.

Comments are welcome.

Index: expression.c
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/expression.c  (mode:100644 sha1:8a1b40e65726d3d66ecc195e9f4eb2954e334176)
+++ uncommitted/expression.c  (mode:100664)
@@ -316,7 +316,9 @@
 		 *
 		 *	if (typeof(a) == int) ..
 		 */
-		if (sym && sym->namespace == NS_TYPEDEF) {
+		if (sym && sym->namespace == NS_TYPEDEF &&
+                    strcmp(token->ident->name, "restrict") &&
+                    strcmp(token->ident->name, "__restrict")) {
 			warning(token->pos, "typename in expression");
 			sym = NULL;
 		}
Index: ident-list.h
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/ident-list.h  (mode:100644 sha1:913b26231b5ea443aabe968def38be5f42e97630)
+++ uncommitted/ident-list.h  (mode:100664)
@@ -52,12 +52,19 @@
 IDENT(noinline);
 IDENT(deprecated);
 IDENT(__const); IDENT(__const__); IDENT(noreturn);
-IDENT(__noreturn__); IDENT(regparm); IDENT(weak);
+IDENT(__noreturn__); IDENT(regparm); IDENT(weak); IDENT(__weak__);
 IDENT(alias); IDENT(pure); IDENT(always_inline);
 IDENT(syscall_linkage); IDENT(visibility);
-IDENT(bitwise);
+IDENT(bitwise); IDENT(__bitwise__);
 IDENT(model); IDENT(__model__);
 IDENT(__format_arg__);
+IDENT(nothrow); IDENT(__nothrow); IDENT(__nothrow__);
+IDENT(__transparent_union__);
+IDENT(__pure__);
+IDENT(__malloc__);
+IDENT(nonnull); IDENT(__nonnull); IDENT(__nonnull__);
+IDENT(__deprecated__);
+IDENT(__warn_unused_result__);
 
 /* Preprocessor idents */
 __IDENT(pragma_ident, "__pragma__", 0);
Index: lib.c
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/lib.c  (mode:100644 sha1:8a2bc72e4a915b9e7c58359e3fbedd9094fbafa6)
+++ uncommitted/lib.c  (mode:100664)
@@ -29,8 +29,8 @@
 #include "target.h"
 
 int verbose, optimize, preprocessing;
-int gcc_major = 2;
-int gcc_minor = 95;
+int gcc_major = 4;
+int gcc_minor = 0;
 
 struct token *skip_to(struct token *token, int op)
 {
@@ -164,6 +164,7 @@
 int Wcontext = 0;
 int Wundefined_preprocessor = 0;
 int Wptr_subtraction_blows = 0;
+int Wtransparent_union = 1;
 int preprocess_only;
 char *include;
 int include_fd = -1;
@@ -294,6 +295,7 @@
 	{ "bitwise", &Wbitwise },
 	{ "typesign", &Wtypesign },
 	{ "context", &Wcontext },
+	{ "transparent-union", &Wtransparent_union },
 };
 
 
@@ -423,6 +425,7 @@
 	// the right __SIZE_TYPE__.
 	add_pre_buffer("#weak_define __SIZE_TYPE__ long unsigned int\n");
 	add_pre_buffer("#weak_define __STDC__ 1\n");
+	add_pre_buffer("#weak_define __STDC_VERSION__ 199901L\n");
 
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
Index: lib.h
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/lib.h  (mode:100644 sha1:564c836fdd7e7de15241567774247d685e75541e)
+++ uncommitted/lib.h  (mode:100664)
@@ -80,6 +80,7 @@
 extern int Wdefault_bitfield_sign;
 extern int Wundefined_preprocessor;
 extern int Wbitwise, Wtypesign, Wcontext;
+extern int Wtransparent_union;
 
 extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
Index: parse.c
===================================================================
--- 8623a33cc63aec82a0f1a1ccc1ca97ac1e3d8f22/parse.c  (mode:100644 sha1:629d638fda2ce959f55b7324055e32f042ac7991)
+++ uncommitted/parse.c  (mode:100664)
@@ -373,7 +373,8 @@
 		ctype->modifiers |= MOD_FORCE;
 		return NULL;
 	}
-	if (attribute == &bitwise_ident) {
+	if (attribute == &bitwise_ident ||
+            attribute == &__bitwise___ident) {
 		if (Wbitwise)
 			ctype->modifiers |= MOD_BITWISE;
 		return NULL;
@@ -437,6 +438,21 @@
 	}
 
 	/* Throw away for now.. */
+	if (attribute == &__transparent_union___ident) {
+		if (Wtransparent_union)
+		    return "ignoring attribute __transparent_union__";
+		return NULL;
+	}
+	if (attribute == &nothrow_ident ||
+	    attribute == &__nothrow_ident ||
+	    attribute == &__nothrow___ident)
+		return NULL;
+	if (attribute == &__malloc___ident)
+		return NULL;
+	if (attribute == &nonnull_ident ||
+	    attribute == &__nonnull_ident ||
+	    attribute == &__nonnull___ident)
+		return NULL;
 	if (attribute == &format_ident ||
 	    attribute == &__format___ident ||
 	    attribute == &__format_arg___ident)
@@ -456,11 +472,13 @@
 		return NULL;
 	if (attribute == &regparm_ident)
 		return NULL;
-	if (attribute == &weak_ident)
+	if (attribute == &weak_ident ||
+	    attribute == &__weak___ident)
 		return NULL;
 	if (attribute == &alias_ident)
 		return NULL;
-	if (attribute == &pure_ident)
+	if (attribute == &pure_ident ||
+	    attribute == &__pure___ident)
 		return NULL;
 	if (attribute == &always_inline_ident)
 		return NULL;
@@ -468,13 +486,15 @@
 		return NULL;
 	if (attribute == &visibility_ident)
 		return NULL;
-	if (attribute == &deprecated_ident)
+	if (attribute == &deprecated_ident ||
+	    attribute == &__deprecated___ident)
 		return NULL;
 	if (attribute == &noinline_ident)
 		return NULL;
 	if (attribute == &__used___ident)
 		return NULL;
-	if (attribute == &warn_unused_result_ident)
+	if (attribute == &warn_unused_result_ident ||
+	    attribute == &__warn_unused_result___ident)
 		return NULL;
 	if (attribute == &model_ident ||
 	    attribute == &__model___ident)

-- 
        Peter

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Mon, 20 Jun 2005 18:33:46 +0000
Message-ID: <Pine.LNX.4.58.0506201129580.2268 () ppc970 ! osdl ! org>
--------------------


On Mon, 20 Jun 2005, Peter Jones wrote:
> 
> It also handles c99's "int *foo[restrict]" syntax, but only in a minimal
> way.  This part could use some work.

Indeed. Please make it a proper identifier, and use

	token->ident == restrict_ident || token->ident == __restrict_ident

instead of using a "strcmp()". The sparse identifier core is really quite 
good, if I say so myself, and it's easy to add a new identifier in 
ident-list.h (and it does not make it "reserved" in any other way, you 
need to do other things to mark something reserved).

> This also changes it to claim to be gcc 4.0, and defines
> __STDC_VERSION__ as 199901L.

Hmm.. My current tree already claims "same as host compiler" by default, 
with 2.95 as the default for a non-gcc host compiler.

As to the std C version, I'm wondering what C99 stuff we don't even parse 
yet, and that could make people validly unhappy? Does anybody have a list?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Tue, 21 Jun 2005 00:09:01 +0000
Message-ID: <42B75A9D.4090100 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Mon, 20 Jun 2005, Peter Jones wrote:
> 

...

> As to the std C version, I'm wondering what C99 stuff we don't even parse 
> yet, and that could make people validly unhappy? Does anybody have a list?
> 
> 		Linus


Here is one more validation file with the new array declarations introduced by C99.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

diff --git a/validation/c99-array-decl-in-proto.c b/validation/c99-array-decl-in-proto.c
new file mode 100644
--- /dev/null
+++ b/validation/c99-array-decl-in-proto.c
@@ -0,0 +1,8 @@
+static int f0(int a[const restrict volatile]);			// OK
+static int f1(int a[const restrict volatile 3]);		// OK
+static int f2(int a[static 3]);					// OK
+static int f3(int a[const restrict volatile static 3]);		// OK
+static int f4(int n, int [*]);					// OK
+static int f5(int n, int a[const restrict volatile *]);		// OK
+
+static int f2(int a[static]);					// KO

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Tue, 21 Jun 2005 02:05:42 +0000
Message-ID: <Pine.LNX.4.58.0506201904110.2268 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Jun 2005, Luc Van Oostenryck wrote:
>
> +static int f5(int n, int a[const restrict volatile *]);		// OK

Ok, just out of a perverse interest, what the _heck_ does that mean?

Is it effectively the same as

	static int f5(int n, const restrict volatile int *a)

or what?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Tue, 21 Jun 2005 02:54:39 +0000
Message-ID: <Pine.LNX.4.58.0506201949000.2268 () ppc970 ! osdl ! org>
--------------------


On Mon, 20 Jun 2005, Peter Jones wrote:
> 
> That's a good point, thanks for pointing it out.  Fixed in the patch
> below.

Well, I already applied a edited version of your previous patch, with just 
the attribute changes. Mind re-diffing and testing?

(Also in general, I tend to much prefer getting two separate patches doing 
two separate things, even if it's a bit more work both for the sender and 
for me. It just makes things _so_ much cleaner in the revision history, 
and it also helps if I end up liking one patch but not the other for some 
reason).

> But that's not what I was getting at.  I was actually thinking that it
> aught to check that it's being used in an array size.  And in general,
> restrict probably needs some special handling like const and volatile
> get.

Ah.. And yes, the horrid example that Luc posted had a lot more than 
"restrict" inside the []. So clearly this is more than just pointing out 
that the pointer is restricted, you can point out other type attributes.

I don't quite see why you'd put them inside the [] instead of outside, but 
maybe it has some deeper meaning that I just haven't fathomed. Or maybe 
it's just syntactic fluff. 

> > As to the std C version, I'm wondering what C99 stuff we don't even parse 
> > yet, and that could make people validly unhappy? Does anybody have a list?
> 
> The obvious things grep found that this will do in a normal-ish (i.e.
> glibc) userland are:

Ok, looks like "restrict" and the strange array declarations are the main 
ones from a parsing perspective.

Probably not very commonly used either.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Tue, 21 Jun 2005 12:06:27 +0000
Message-ID: <20050621120627.GB1382 () duron ! akihabara ! co ! uk>
--------------------

On the first half of your file my front end gives:

neil@duron:~/src/cfe$ ./cfe /tmp/foo.c
"/tmp/foo.c", line 14: error: variable-length arrays cannot have static storage
        duration
  extern int a[n];
             ^
"/tmp/foo.c", line 23: error: variable-length arrays cannot have static storage
        duration
  static int a[n];
             ^

2 errors found compiling "/tmp/foo.c".
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Tue, 21 Jun 2005 12:11:53 +0000
Message-ID: <20050621121153.GC1382 () duron ! akihabara ! co ! uk>
--------------------
Sorry Luc I now notice you had that in your comment.

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Tue, 21 Jun 2005 15:50:55 +0000
Message-ID: <Pine.LNX.4.58.0506210845590.2268 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Jun 2005, Peter Jones wrote:
> 
> More sick than that are C99's variable length arrays, which just need to
> be taken out and shot.  They're nasty to begin with, but they make
> "sizeof" sometimes be a proper function that gets evaluated at runtime:

I agree that they are nasty critters, but at least they are 
_syntactically_ clean. So your example:

> int f(int n) {
>   char b[n+3];
>   return sizeof b;
> }

to me it actually says "fair enough, I can see what that does". There's no
hackery in there. For a lot of languages I'd say that it should be
expected to just work (ie for scripting languages etc, although they
usually don't even need to have any explicit size at all).

Now, I absolutely do agree that it's nasty to generate code for, and it 
violates my belief that C should be considered a portable assembler, but:

> Needless to say sparse complains about both lines in the function.

I'm actually hoping to fix that (and then have a flag to say whether it
should cause a warning or not, but probably defaulting to "allowed").
> 
			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: [patch] __attribute__ handling for attributes used in the userland
Date: Tue, 21 Jun 2005 18:33:48 +0000
Message-ID: <42B85D8C.4010402 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Tue, 21 Jun 2005, Luc Van Oostenryck wrote:
> 
>>+static int f5(int n, int a[const restrict volatile *]);		// OK
> 
> 
> Ok, just out of a perverse interest, what the _heck_ does that mean?

I knew that something like this exist in C99 but, until now, I didn't knew it's exact meaning.

> Is it effectively the same as
> 
> 	static int f5(int n, const restrict volatile int *a)
> 
> or what?
> 
> 		Linus

Sort of, but for variable lenght arrays.

Extracted from the C99 standard, section 6.7.5:

The syntax is:
	direct-declarator:
		...
		direct-declarator [ type-qualifier-listopt assignment-expressionopt ]
		direct-declarator [ static type-qualifier-listopt assignment-expression ]
		direct-declarator [ type-qualifier-list static assignment-expression ]
		direct-declarator [ type-qualifier-listopt * ]
		...

And for the semantic:
Section 6.7.5.2 (array declarators)
	- If the size is not present (assignment-expressionopt), the array type is an incomplete type.
	- If the size is * instead of being an expression, the array type is a variable length array type of unspecified size.
	  (can only be used in a function prototype).
	  Such a type declaration must be considered as a complete type.
	- If the size is an expression that is not an integer constant expression:
	  if it occurs in a declaration at function prototype scope, it is treated as if it were replaced by *;
	  otherwise its value must be greater than zero.
Section 6.7.5.3 (function declarators and prototypes), constraint 7.
	- A declaration of a parameter as ``array of type'' shall be adjusted to ``qualified pointer to type'',
	  where the type qualifiers (if any) are those specified within the [ and ] of the array type derivation.
	- If the keyword static also appears within the [ and ] of the array type derivation,
	  then for each call to the function, the value of the corresponding actual argument shall provide access
	  to the first element of an array with at least as many elements as specified by the size expression.


Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: avoid segfault in check_byte_count() ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: avoid segfault in check_byte_count()
Date: Sun, 26 Jun 2005 23:36:35 +0000
Message-ID: <20050626233635.GC8582 () ralph05 ! lan>
--------------------
This patch avoid deferencing a null pointer in check_byte_count() after parse errors in the checked function.


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/check.c b/check.c
--- a/check.c
+++ b/check.c
@@ -133,6 +133,8 @@ static void check_range_instruction(stru
 
 static void check_byte_count(struct instruction *insn, pseudo_t count)
 {
+	if (!count)
+		return;
 	if (count->type == PSEUDO_VAL) {
 		long long val = count->value;
 		if (val <= 0 || val > 100000)
diff --git a/validation/check_byte_count-ice.c b/validation/check_byte_count-ice.c
new file mode 100644
--- /dev/null
+++ b/validation/check_byte_count-ice.c
@@ -0,0 +1,6 @@
+#include <string.h>
+
+static void foo(void *a)
+{
+	memset(foo, + ', 20);
+}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: avoid segfault in linearize_asm_statement() after a parse error in asm statement ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: avoid segfault in linearize_asm_statement() after a parse error in asm statement
Date: Sun, 26 Jun 2005 23:34:29 +0000
Message-ID: <20050626233429.GB8582 () ralph05 ! lan>
--------------------
This patch avoid deferencing a null pointer in linearize_asm_statement() after a parse error in asm statement.

Note: the problem was already fixed (or never been there) for the asm_inputs part.
This patch use the same protection for the output part: use "".


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

---
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1738,7 +1738,7 @@ pseudo_t linearize_asm_statement(struct 
 
 		case 1:	/* Constraint */
 			state = 2;
-			constraint = expr->string->data;
+			constraint = expr ? expr->string->data : "";
 			continue;
 
 		case 2:
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: const vs __nocast interference ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: const vs __nocast interference
Date: Mon, 11 Jul 2005 12:27:57 +0000
Message-ID: <200507111627.57576.adobriyan () gmail ! com>
--------------------
There are some "unkillable" nocast warnings in net/sctp/associola.c Removing
"const" from, say, sctp_assoc_add_peer() will work, but that is not I'm going
to do.
----------------------------------------------------------------------------
$ cat -n test.c
     1  #define __nocast __attribute__((nocast))
     2
     3  static void f(unsigned int __nocast gfp)
     4  {
     5  }
     6
     7  static void g(const unsigned int __nocast gfp)
     8  {
     9  }
    10
    11  static void h(void)
    12  {
    13          f(0u);
    14          g(0u);
    15  }
$ sparse test.c
test.c:14:4: warning: implicit cast to nocast type
----------------------------------------------------------------------------
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: const vs __nocast interference
Date: Mon, 11 Jul 2005 16:13:15 +0000
Message-ID: <Pine.LNX.4.58.0507110911430.17536 () g5 ! osdl ! org>
--------------------


On Mon, 11 Jul 2005, Alexey Dobriyan wrote:
>
> There are some "unkillable" nocast warnings in net/sctp/associola.c Removing
> "const" from, say, sctp_assoc_add_peer() will work, but that is not I'm going
> to do.

Ahh, ok. That's definitely not intentional, I just never thought of this 
case in my nocast cases.

I'll make it not complain about just adding a const or something like 
that.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: const vs __nocast interference
Date: Tue, 12 Jul 2005 13:30:37 +0000
Message-ID: <20050712133037.GA12865 () duron ! akihabara ! co ! uk>
--------------------
Linus Torvalds wrote:-

> 
> 
> On Mon, 11 Jul 2005, Linus Torvalds wrote:
> > 
> > I'll make it not complain about just adding a const or something like 
> > that.
> 
> Done. Right now it only allows "const" changes, but it's set up so that we 
> can easily do the same for "volatile" if we decide we want to. 
> 
> 		Linus

There shouldn't be any type qualifiers remaining here.  Type qualifiers
in function parameters are dropped w.r.t. the type of the function,
but not w.r.t. the declarations of the parameters in the function body.

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: header file cleanup tool? ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: header file cleanup tool?
Date: Sun, 05 Jun 2005 18:10:21 +0000
Message-ID: <42A3400D.7030802 () pobox ! com>
--------------------
randy_dunlap wrote:
> Anyone know if there is already a tool to do header file (usage)
> analysis, meaning if a file (kernel/sched.c) contains:
> 
> #include <linux/mm.h>
> #include <linux/module.h>
> #include <linux/nmi.h>
> #include <linux/init.h>
> #include <asm/uaccess.h>
> #include <linux/highmem.h>
> #include <linux/smp_lock.h>
> #include <asm/mmu_context.h>
> #include <linux/interrupt.h>
> #include <linux/completion.h>
> #include <linux/kernel_stat.h>
> #include <linux/security.h>
> #include <linux/notifier.h>
> #include <linux/profile.h>
> #include <linux/suspend.h>
> #include <linux/blkdev.h>
> #include <linux/delay.h>
> #include <linux/smp.h>
> #include <linux/threads.h>
> #include <linux/timer.h>
> #include <linux/rcupdate.h>
> #include <linux/cpu.h>
> #include <linux/cpuset.h>
> #include <linux/percpu.h>
> #include <linux/kthread.h>
> #include <linux/seq_file.h>
> #include <linux/syscalls.h>
> #include <linux/times.h>
> #include <linux/acct.h>
> #include <asm/tlb.h>
> #include <asm/unistd.h>
> 
> are all of these needed and are there other header files that are
> needed but not listed?
> 
> If there isn't such a tool, which would be a better starting point
> for one?  sparse, gcc, some other cc, or a new standalone program?

If sparse records where a symbol is defined, its doable in sparse...

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: header file cleanup tool?
Date: Sun, 05 Jun 2005 18:24:05 +0000
Message-ID: <Pine.LNX.4.58.0506051120020.1876 () ppc970 ! osdl ! org>
--------------------


On Sun, 5 Jun 2005, Jeff Garzik wrote:
> 
> If sparse records where a symbol is defined, its doable in sparse...

Handling #define's is hard. Regular C symbols is easy, and sparse handles
those trivially. But what about a #define that is defined in one header,
and used by another #define (or inline function) in _another_ header, and
then that second macro is used by the .c source file..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: header file cleanup tool?
Date: Sun, 05 Jun 2005 19:40:09 +0000
Message-ID: <42A35519.1010700 () pobox ! com>
--------------------
Linus Torvalds wrote:
> 
> On Sun, 5 Jun 2005, Jeff Garzik wrote:
> 
>>If sparse records where a symbol is defined, its doable in sparse...
> 
> 
> Handling #define's is hard. Regular C symbols is easy, and sparse handles
> those trivially. But what about a #define that is defined in one header,
> and used by another #define (or inline function) in _another_ header, and
> then that second macro is used by the .c source file..

I presumed he would mostly be interested in C symbols, and simply need 
to know what file those symbols were defined in.  New kernel code is 
actually pretty good about using enums rather than #defines for numeric 
constants [code from old codgers like DaveM aside :)]

That still leaves plenty of #defines, granted...

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?iso-8859-1?Q?J=F6rn?= Engel <joern () wohnheim ! fh-wedel ! de>
To: linux-sparse
Subject: Re: header file cleanup tool?
Date: Sun, 05 Jun 2005 21:10:17 +0000
Message-ID: <20050605211017.GB24826 () wohnheim ! fh-wedel ! de>
--------------------
On Sun, 5 June 2005 11:01:53 -0700, randy_dunlap wrote:
> 
> Anyone know if there is already a tool to do header file (usage)
> analysis, meaning if a file (kernel/sched.c) contains:
> 
> #include <linux/mm.h>
> #include <linux/module.h>
> #include <linux/nmi.h>
> #include <linux/init.h>
> #include <asm/uaccess.h>
> #include <linux/highmem.h>
> #include <linux/smp_lock.h>
> #include <asm/mmu_context.h>
> #include <linux/interrupt.h>
> #include <linux/completion.h>
> #include <linux/kernel_stat.h>
> #include <linux/security.h>
> #include <linux/notifier.h>
> #include <linux/profile.h>
> #include <linux/suspend.h>
> #include <linux/blkdev.h>
> #include <linux/delay.h>
> #include <linux/smp.h>
> #include <linux/threads.h>
> #include <linux/timer.h>
> #include <linux/rcupdate.h>
> #include <linux/cpu.h>
> #include <linux/cpuset.h>
> #include <linux/percpu.h>
> #include <linux/kthread.h>
> #include <linux/seq_file.h>
> #include <linux/syscalls.h>
> #include <linux/times.h>
> #include <linux/acct.h>
> #include <asm/tlb.h>
> #include <asm/unistd.h>
> 
> are all of these needed and are there other header files that are
> needed but not listed?
> 
> If there isn't such a tool, which would be a better starting point
> for one?  sparse, gcc, some other cc, or a new standalone program?

I had something similar once for header files.  But after thinking
about symbols/defines only needed when CONFIG_FOO is defined, I shyed
away.

Unless people agree on a rule like "if it's needed with CONFIG_FOO, it
must always be needed" or accept a certain amount of breakage caused
by the cleanups, this is a tough problem.

Jrn

-- 
Simplicity is prerequisite for reliability.
-- Edsger W. Dijkstra
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: k&r style arguments are added at the toplevel ===

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: k&r style arguments are added at the toplevel
Date: Wed, 16 Nov 2005 21:40:37 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHEEHOCHAA.mshah () teja ! com>
--------------------
I get an error for following piece of code:

-----------------------
int main(mode)
   char * mode;
{
  mode = "test";
}

int mode;


t.c:2:4: warning: non-ANSI function declaration of function 'main'
t.c:7:5: error: symbol 'mode' redeclared with different type (originally declared at t.c:2) - different base types
-----------------------

I think this is because we call external_declaration() for k&r arguments and the symbol is bound at the toplevel.


-Mitesh










-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: k&r style arguments are added at the toplevel
Date: Wed, 16 Nov 2005 22:20:15 +0000
Message-ID: <Pine.LNX.4.64.0511161418350.13959 () g5 ! osdl ! org>
--------------------


On Wed, 16 Nov 2005, Mitesh Shah wrote:
>
> I get an error for following piece of code:

Thanks. That ws really a hack. The K&R parsing code was done to pass some 
very minimal sanity tests, and it did totally the wrong thing here by 
binding things at the wrong level (using external_declaration also meant 
that you could insert top-level things like inline assembly, typedef etc 
there).

I pushed out something that should fix it (tested with your trivial 
test-case, but nothing else, so it's worth giving some more testing).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh Shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: k&r style arguments are added at the toplevel
Date: Thu, 17 Nov 2005 00:26:14 +0000
Message-ID: <AKEOJDDJLNPHDAKOMMBHKEIBCHAA.mshah () teja ! com>
--------------------

Looks like when we have more than one parameter, it still does not work.

e.g.
--------------------------------
int main(mode, parm2)
   char * mode, parm2;
{
  mode = "test";
}

int mode;

t.c:2:4: warning: non-ANSI function declaration of function 'main'
t.c:2:15: error: expected ';' at end of parameter declaration
t.c:1:16: error: missing type declaration for parameter 'parm2'
t.c:2:15: error: expected function body
t.c:2:15: error: Expected ; end of type declaration
t.c:2:15: error: got ,
t.c:3:1: error: Expected ; end of type declaration
t.c:3:1: error: got {
t.c:5:1: error: Expected ; end of type declaration
t.c:5:1: error: got }
-------------------------------

-Mitesh


> -----Original Message-----
> From: linux-sparse-owner@vger.kernel.org
> [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Linus Torvalds
> Sent: Wednesday, November 16, 2005 2:20 PM
> To: Mitesh Shah
> Cc: Linux-Sparse
> Subject: Re: k&r style arguments are added at the toplevel
> 
> 
> 
> 
> On Wed, 16 Nov 2005, Mitesh Shah wrote:
> >
> > I get an error for following piece of code:
> 
> Thanks. That ws really a hack. The K&R parsing code was done to pass some 
> very minimal sanity tests, and it did totally the wrong thing here by 
> binding things at the wrong level (using external_declaration also meant 
> that you could insert top-level things like inline assembly, typedef etc 
> there).
> 
> I pushed out something that should fix it (tested with your trivial 
> test-case, but nothing else, so it's worth giving some more testing).
> 
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 
> 


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: RE: k&r style arguments are added at the toplevel
Date: Thu, 17 Nov 2005 01:02:43 +0000
Message-ID: <Pine.LNX.4.64.0511161642230.13959 () g5 ! osdl ! org>
--------------------


On Wed, 16 Nov 2005, Mitesh Shah wrote:
> 
> Looks like when we have more than one parameter, it still does not work.

Ahh, thanks. My bad. Stupid of me, I forgot about that.

(If you have more than one parameter and you declare them independently, 
it should be fine).

I pushed out the fix.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: missing bitwise switch/case type checks? ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: missing bitwise switch/case type checks?
Date: Thu, 03 Nov 2005 23:56:34 +0000
Message-ID: <Pine.LNX.4.64.0511031530160.27915 () g5 ! osdl ! org>
--------------------


On Thu, 3 Nov 2005, Zach Brown wrote:
> 
> Is it just me or should the switch()/case: also generate a similar error?

It's not just you - it definitely should. The switch () case is a totally 
different code sequence for sparse, but the fact that it doesn't give a 
warning shows that we don't properly match up the case statement types 
with the switch statement, which might well hide other problems too.

Something like the appended should catch it. Hmm?

		Linus

----
diff --git a/evaluate.c b/evaluate.c
index dd0c32b..f2baea6 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2578,6 +2578,45 @@ static void evaluate_asm_statement(struc
 	} END_FOR_EACH_PTR(expr);
 }
 
+static void evaluate_case_statement(struct statement *stmt)
+{
+	evaluate_expression(stmt->case_expression);
+	evaluate_expression(stmt->case_to);
+	evaluate_statement(stmt->case_statement);
+}
+
+static void check_case_type(struct expression *switch_expr, struct expression *case_expr)
+{
+	struct symbol *switch_type, *case_type;
+	if (!case_expr)
+		return;
+	switch_type = switch_expr->ctype;
+	case_type = case_expr->ctype;
+
+	/* Both integer types? */
+	if (is_int_type(switch_type) && is_int_type(case_type))
+		return;
+	if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
+		return;
+
+	error(case_expr->pos, "incompatible types for 'case' statement");
+}
+
+static void evaluate_switch_statement(struct statement *stmt)
+{
+	struct symbol *sym;
+
+	evaluate_expression(stmt->switch_expression);
+	evaluate_statement(stmt->switch_statement);
+	if (!stmt->switch_expression)
+		return;
+	FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
+		struct statement *case_stmt = sym->stmt;
+		check_case_type(stmt->switch_expression, case_stmt->case_expression);
+		check_case_type(stmt->switch_expression, case_stmt->case_to);
+	} END_FOR_EACH_PTR(sym);
+}
+
 struct symbol *evaluate_statement(struct statement *stmt)
 {
 	if (!stmt)
@@ -2622,13 +2661,10 @@ struct symbol *evaluate_statement(struct
 		evaluate_iterator(stmt);
 		return NULL;
 	case STMT_SWITCH:
-		evaluate_expression(stmt->switch_expression);
-		evaluate_statement(stmt->switch_statement);
+		evaluate_switch_statement(stmt);
 		return NULL;
 	case STMT_CASE:
-		evaluate_expression(stmt->case_expression);
-		evaluate_expression(stmt->case_to);
-		evaluate_statement(stmt->case_statement);
+		evaluate_case_statement(stmt);
 		return NULL;
 	case STMT_LABEL:
 		return evaluate_statement(stmt->label_statement);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Zach Brown <zach.brown () oracle ! com>
To: linux-sparse
Subject: Re: missing bitwise switch/case type checks?
Date: Fri, 04 Nov 2005 00:05:29 +0000
Message-ID: <436AA5C9.3040006 () oracle ! com>
--------------------
Linus Torvalds wrote:
> 
> On Thu, 3 Nov 2005, Zach Brown wrote:
>> Is it just me or should the switch()/case: also generate a similar error?
> 
> It's not just you - it definitely should. The switch () case is a totally 
> different code sequence for sparse, but the fact that it doesn't give a 
> warning shows that we don't properly match up the case statement types 
> with the switch statement, which might well hide other problems too.
> 
> Something like the appended should catch it. Hmm?

Nice, it sure seems to do the trick here (no surprise :)):

$ sparse -o switch switch.c -Wbitwise
switch.c:5:8: error: incompatible types for operation (==)
switch.c:9:8: error: incompatible types for 'case' statement
$

- z
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steve French <smfrench () austin ! rr ! com>
To: linux-sparse
Subject: Re: missing bitwise switch/case type checks?
Date: Fri, 04 Nov 2005 18:39:03 +0000
Message-ID: <436BAAC7.4000901 () austin ! rr ! com>
--------------------
> Back when we were auditing endian use in OCFS2 we ran into a case where sparse
> wasn't warning when we used a little-endian type


I feel like I am missing something obvious, I used to be able to 
generate a sparse warning on the endianness of the use of the inmemory 
posix acl structures (which is correct endianness I wanted to work 
through once and for all) when running
    make modules C=2 -Wbitwise
but I was not able to generate that warning even with current sparse, 
although Shaggy can on the same kernel code and similar level of sparse 
code.  At first I thought it was due to old vs. new sparse, and then 
using Athlon64 vs. x86 but I no longer believe that is the case.   Is 
there some obvious make option (for sparse itself) or change to the 
kernel makefile that is required to turn on endian checks?  

In addition I was curious what the "maximum sparse verbosity" options 
would be.   I see in lib.c what looks like six or seven different -W 
options that could be passed to sparse, but it is not clear to me where 
the writeup on those is.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: missing bitwise switch/case type checks?
Date: Fri, 04 Nov 2005 19:02:54 +0000
Message-ID: <Pine.LNX.4.64.0511041049540.28804 () g5 ! osdl ! org>
--------------------


On Fri, 4 Nov 2005, Steve French wrote:
> 
> I feel like I am missing something obvious, I used to be able to generate a
> sparse warning on the endianness of the use of the inmemory posix acl
> structures (which is correct endianness I wanted to work through once and for
> all) when running
>    make modules C=2 -Wbitwise
> but I was not able to generate that warning even with current sparse, although
> Shaggy can on the same kernel code and similar level of sparse code.

Can you point to exactly which error you don't see and Shaggy does see?

Also, if you're talking about the really current kernel, then we've 
actually turned on the -Wbitwise warning by default, but the endianness 
warning in the _kernel_ is turned off by default because it was simply too 
verbose to be useful.

Use -D__CHECK_ENDIAN__ on the kernel to enable endianness checks again. 
You can enable it with

	make C=2 CF="-D__CHECK_ENDIAN__"

or similar.

I'd love to turn on endianness checking by default, but there really are a 
lot of normal code-paths that just don't use the proper endianness types, 
so we can't do it.

> In addition I was curious what the "maximum sparse verbosity" options would
> be.   I see in lib.c what looks like six or seven different -W options that
> could be passed to sparse, but it is not clear to me where the writeup on
> those is.

Most of them aren't worth it right now - the ones that are enabled by 
default are the usable ones (with the exception of -Wbitwise, which I 
should probably enable now that the kernel has its own way of disabling 
the really loud ones).

Using -Wundef is probably also worthwhile for non-kernel projects. It too 
got turned off in sparse by default because it's on by default for the 
kernel.

"-Wcast-to-as" is maybe interesting if you want to be really address-space 
safe, but again, the kernel right now often casts _to_ an address space, 
and since the bugs we have tend to be that we _lose_ the address space and 
dereference a user pointer by mistake, we don't want to get a warning for 
that in the kernel. And no other project uses address spaces, I think, 
although they are certainly generic enough.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: oddness in net/sched/cls_api.c ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: oddness in net/sched/cls_api.c
Date: Wed, 16 Feb 2005 05:09:00 +0000
Message-ID: <4212D56C.2050408 () osdl ! org>
--------------------
sparse on net/sched/cls_api.c (2.6.11-rc4) reports:

   CHECK   net/sched/cls_api.c
net/sched/cls_api.c:595:17: warning: typename in expression
net/sched/cls_api.c:596:2: warning: Expected ; at end of statement
net/sched/cls_api.c:596:2: warning: got return
net/sched/cls_api.c:613:17: warning: typename in expression
net/sched/cls_api.c:614:2: warning: Expected ; at end of statement
net/sched/cls_api.c:614:2: warning: got return
net/sched/cls_api.c:595:17: warning: undefined identifier '__attribute__'
net/sched/cls_api.c:613:17: warning: undefined identifier '__attribute__'
net/sched/cls_api.c:595:31: warning: call with no type!
net/sched/cls_api.c:613:31: warning: call with no type!
   CC      net/sched/cls_api.o



sparse isn't liking constructs like:

         return 0;
rtattr_failure: __attribute__ ((unused))
         return -1;

[same constructs in 2 functions]

On x86-64 if it matters.

sparse is happy after removing the "__attribute__ ((unused))"...

-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: pre-process.c:569:18: error: bad constant expression ===

From: Alecs King <alecsk () gmail ! com>
To: linux-sparse
Subject: pre-process.c:569:18: error: bad constant expression
Date: Sat, 31 Dec 2005 07:30:06 +0000
Message-ID: <20051231073006.GA3583 () localhost>
--------------------
        int nargs = sym->arglist ? sym->arglist->count.normal : 0;
        struct arg args[nargs];

gcc went fine but sparse complaint about this.  Declaring such kind of
variable-sized arrays is allowed or not?  Seems 'nargs' cannot be
evaluated until runtime..?

-- 
Alecs King
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: pre-process.c:569:18: error: bad constant expression
Date: Sat, 31 Dec 2005 19:31:44 +0000
Message-ID: <Pine.LNX.4.64.0512311122400.3249 () g5 ! osdl ! org>
--------------------


On Sat, 31 Dec 2005, Alecs King wrote:
>
>         int nargs = sym->arglist ? sym->arglist->count.normal : 0;
>         struct arg args[nargs];
> 
> gcc went fine but sparse complaint about this.  Declaring such kind of
> variable-sized arrays is allowed or not?  Seems 'nargs' cannot be
> evaluated until runtime..?

sparse doesn't really do C99, it does a mixture of traditional ANSI C with 
many (but not all) of the newer features.  And sometimes it refuses to do 
traditional ANSI C too (warning about function prototypes without an 
explicit "(void)" to show that there are no arguments etc).

And one of the things it doesn't like is variable-sized arrays. It will 
actually correctly handle _some_ aspects of them (it should parse them and 
so on)), but never got it working properly even enough to make "sizeof" 
work, and they are not liked in the kernel sources, so it warns about 
them.

Variable-sized arrays really are pretty nasty to handle. I'e made 
"array_size" be a "struct expression *" in preparation for allowing it to 
be supported, but much more is needed.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: pre-process.c:569:18: error: bad constant expression
Date: Sat, 31 Dec 2005 19:50:39 +0000
Message-ID: <Pine.LNX.4.64.0512311140290.3249 () g5 ! osdl ! org>
--------------------


On Sat, 31 Dec 2005, Linus Torvalds wrote:
> 
> And one of the things it doesn't like is variable-sized arrays. It will 
> actually correctly handle _some_ aspects of them (it should parse them and 
> so on), but never got it working properly even enough to make "sizeof" 
> work

Just in case somebody cares, a partial list of the problems I know 
about with variable-sized arrays as far as current sparse is concerned:

 - sparse just generates a list of symbols per block (and per function). 
   That's correct and proper for _all_ other kinds of variables, but not 
   for variable-sized ones. Why? Because those depend on where in the 
   block they are declared.

   Example:

	int main(int argc, char **argv)
	{
		char p[argc];
		argc++;
		char q[argc];
		return sizeof(p) + sizeof(q);
	}

   iow, we'd have to make variable declarations real statements in the 
   statement list. Which is by no means impossible, but it's a big change 
   for something that has little gain for _me_ (ie the kernel). So I'm 
   personally not very likely to do it.

   Side note: it's not just variable-sized arrays that need this. Any 
   initializers of mixed declarations also have this same issue. That's 
   another thing sparse warns about right now, as you already noticed.

 - "sizeof()" needs to generate a temporary variable. Example:

	int main(int argc, char **argv)
	{
		char p[argc++];
		return sizeof(p);
	}

   should obviously return the original value of "argc", and only evaluate 
   the expression once. The way sparse is set up right now, we parse the 
   expression properly, but we don't create the internal temporary result 
   for it.

   This is likely a fairly small change, though.

If those two problems are fixed, sparse probably could handle 
variable-sized arrays fairly well.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: pre-process.c:569:18: error: bad constant expression
Date: Sat, 31 Dec 2005 21:19:16 +0000
Message-ID: <Pine.LNX.4.64.0512311314000.3249 () g5 ! osdl ! org>
--------------------


On Sat, 31 Dec 2005, Linus Torvalds wrote:
> 
> Just in case somebody cares, a partial list of the problems I know 
> about with variable-sized arrays as far as current sparse is concerned:
> 
>  - sparse just generates a list of symbols per block (and per function). 

Ok, I fixed this one. Instead of having just a list of symbols per block, 
declarations are not a special kind of statement in the block. It wasn't 
even that hard to do, although the amount of testing my change-over has 
gotten is pretty minimal.

So sparse now gets

	int test(int arg)
	{
		int a = arg;
		arg++;
		int b = arg;
		return a+b;
	}

right, which it didn't use to do (it would end up rewriting the above as

	symbol_list: a = arg; b = arg;

	statement_list: arg++;
			return a+b;

and thus return "arg+arg" rather than "arg+arg+1".

It still warns about mixing code and declarations, and there are still 
other issues that keep it from handling variable-sized arrays, but I think 
this was the main "conceptual" difficulty in sparse to handling some of 
it.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: pysparse-0.1 uploaded ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: pysparse-0.1 uploaded
Date: Sat, 19 Feb 2005 05:33:40 +0000
Message-ID: <20050219053340.GA2274 () 64m ! dyndns ! org>
--------------------
Not sure how many python fans here. For people who want to try out
sparse in python, I have upload my first release of the python
module for sparse at:

http://cgen.home.comcast.net/pysparse-0.1.tar.gz

Things is still rough, well, works for me.

Feedback are always welcome.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: segfault on bad ternary conditional ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: segfault on bad ternary conditional
Date: Mon, 20 Jun 2005 19:54:24 +0000
Message-ID: <20050620195424.GA28123 () 64m ! dyndns ! org>
--------------------
On Tue, Jun 21, 2005 at 12:29:29AM +0200, Luc Van Oostenryck wrote:
> 
> The following patches add a new validation file and fix the segfault.
> But I not sure at all that this is the right way to solve this sort of 
> problem:
> shouldn't be much simpler to ignore the whole statement when it contains a 
> syntax error?
>

If it has syntax error, it should no go to linearize at all.

Chris

 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: segfault on bad ternary conditional
Date: Mon, 20 Jun 2005 22:29:29 +0000
Message-ID: <42B74349.302 () looxix ! net>
--------------------
Hi,

sparse segfault on the following input:

	static int foo(int a)
	{
		return a ?? 1 : 0;
	}


The following patches add a new validation file and fix the segfault.
But I not sure at all that this is the right way to solve this sort of problem:
shouldn't be much simpler to ignore the whole statement when it contains a syntax error?


Luc


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

diff --git a/validation/bad-ternary-cond.c b/validation/bad-ternary-cond.c
new file mode 100644
--- /dev/null
+++ b/validation/bad-ternary-cond.c
@@ -0,0 +1,7 @@
+// should warn: "warning: Expected : in conditional expression"
+// and should not segfault
+
+static int foo(int a)
+{
+	return a ?? 1 : 0;
+}
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1306,11 +1306,15 @@ static pseudo_t linearize_short_conditio
  					    struct expression *expr_false)
  {
  	pseudo_t src1, src2;
-	struct basic_block *bb_false = alloc_basic_block(ep, expr_false->pos);
+	struct basic_block *bb_false;
  	struct basic_block *merge = alloc_basic_block(ep, expr->pos);
  	pseudo_t phi1, phi2;
  	int size = type_size(expr->ctype);

+	if (!expr_false)
+		return VOID;
+
+	bb_false = alloc_basic_block(ep, expr_false->pos);
  	src1 = linearize_expression(ep, cond);
  	phi1 = alloc_phi(ep->active, src1, size);
  	add_branch(ep, expr, src1, merge, bb_false);


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: segfault on bad ternary conditional
Date: Tue, 21 Jun 2005 21:10:25 +0000
Message-ID: <42B88241.1000308 () looxix ! net>
--------------------
Linus Torvalds wrote:
> 
> On Tue, 21 Jun 2005, Luc Van Oostenryck wrote:
> 
>>The following patches add a new validation file and fix the segfault.
>>But I not sure at all that this is the right way to solve this sort of problem:
>>shouldn't be much simpler to ignore the whole statement when it contains a syntax error?
> 
> 
> The sparse parser has traditionally been _very_ permissive, and passed up 
> as much as possible of what it parsed, even if the end result didn't make 
> any sense and was just a partial tree.
> 
> I agree that it probably isn't a sensible strategy - it mainly made sense
> as a debugging and testing aid ("we don't handle that, so ignore it").  
> It's not very nice to upper levels that now as a result have to worry
> about parse trees that may be incomplete.
> 
> I'll apply your patch, since it looks fine on its own. But you're right,
> "expression.c" could - and probably should - also refuse to pass up
> half-way-parsed conditionals.
> 
> 		Linus


Ok, I understand.
The same sort of problem is also present in linearize_conditional() when parsing the simpler:
	return a ? 0;

Here is a patch:


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

diff --git a/validation/bad-ternary-cond.c b/validation/bad-ternary-cond.c
--- a/validation/bad-ternary-cond.c
+++ b/validation/bad-ternary-cond.c
@@ -1,6 +1,11 @@
  // should warn: "warning: Expected : in conditional expression"
  // and should not segfault

+static int bar(int a)
+{
+	return a ? 0;
+}
+
  static int foo(int a)
  {
  	return a ?? 1 : 0;
diff --git a/linearize.c b/linearize.c
--- a/linearize.c
+++ b/linearize.c
@@ -1335,10 +1335,14 @@ static pseudo_t linearize_conditional(st
  	pseudo_t src1, src2;
  	pseudo_t phi1, phi2;
  	struct basic_block *bb_true = alloc_basic_block(ep, expr_true->pos);
-	struct basic_block *bb_false = alloc_basic_block(ep, expr_false->pos);
+	struct basic_block *bb_false;
  	struct basic_block *merge = alloc_basic_block(ep, expr->pos);
  	int size = type_size(expr->ctype);

+	if (!expr_false)
+		return VOID;
+
+	bb_false = alloc_basic_block(ep, expr_false->pos);
  	linearize_cond_branch(ep, cond, bb_true, bb_false);

  	set_activeblock(ep, bb_true);

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: segfault on non-ANSI function-like declaration ===

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: segfault on non-ANSI function-like declaration
Date: Tue, 17 May 2005 21:01:43 +0000
Message-ID: <20050517210143.GA20035 () ralph05 ! lan>
--------------------
Hi,

sparse segfault on non-ANSI function-like declarations/casts like
	void (*foo)();          // OK
	void (*bar)() = 0;      // segfault

The problem come from the warning emited by parameter_type_list()
which don't have a valid pointer for the ident of the "function".

NB. I don't think that the following patch is the right solution,
    but at least it avoid the segfault.

-- 
Luc Van Oostenryck


Index: parse.c
===================================================================
--- f748cf9add41be8404ed8bf7eda43ba28314483b/parse.c  (mode:100644)
+++ uncommitted/parse.c  (mode:100644)
@@ -1355,7 +1355,7 @@
 		// No warning for "void oink ();"
 		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
 		if (!match_op(token->next, ';'))
-			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
+			warning(token->pos, "non-ANSI function declaration of function '%s'", p ? show_ident(*p) : NULL);
 		return token;
 	}
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () looxix ! net>
To: linux-sparse
Subject: Re: segfault on non-ANSI function-like declaration
Date: Wed, 18 May 2005 21:29:41 +0000
Message-ID: <428BB3C5.9000307 () looxix ! net>
--------------------
Luc Van Oostenryck wrote:
> Hi,
> 
> sparse segfault on non-ANSI function-like declarations/casts like
> 	void (*foo)();          // OK
> 	void (*bar)() = 0;      // segfault
> 
> The problem come from the warning emited by parameter_type_list()
> which don't have a valid pointer for the ident of the "function".
> 

The applied patch:

@@ -1354,7 +1354,7 @@
         if (match_op(token, ')')) {
                 // No warning for "void oink ();"
                 // Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
-               if (!match_op(token->next, ';'))
+               if (*p && !match_op(token->next, ';'))
                         warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
                 return token;
         }


doesn't solve the problem because, at least in this case, it's p that is NULL.
Trivial patch follow but I'm not sure what was the intent of the fix: just avoid the segfault
or avoid the incorrect message?

Luc


Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@looxix.net>

Index: parse.c
===================================================================
--- defd4f30824865c785115b1452367dc0187b972c/parse.c  (mode:100644)
+++ uncommitted/parse.c  (mode:100644)
@@ -1354,7 +1354,7 @@
	if (match_op(token, ')')) {
		// No warning for "void oink ();"
		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
-		if (*p && !match_op(token->next, ';'))
+		if (p && *p && !match_op(token->next, ';'))
			warning(token->pos, "non-ANSI function declaration of function '%s'", show_ident(*p));
		return token;
	}


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse and gcc-4.0.0 testsuite: results. ===

From: Alexey Dobriyan <adobriyan () gmail ! com>
To: linux-sparse
Subject: sparse and gcc-4.0.0 testsuite: results.
Date: Mon, 23 May 2005 18:49:30 +0000
Message-ID: <200505232249.30482.adobriyan () gmail ! com>
--------------------
--Boundary-00=_6WikC059zDjIpxE
Content-Type: text/plain;
  charset="us-ascii"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Tarball attached. Trimmed down testcases (C only) inline.

This time I ran sparse on all files (Ada, C++, C, Fortran, shell scripts,
other random crap) ;-).

Segmentation faults
============================================================================
gcc.c-torture/compile/20000804-1.c

__complex__ void f(void)
{
	v += f();
	asm("" : : "r" (0));
}
--------------------------------------
gcc.dg/pr18809-1.c

void a(enum E e)
{
}

void bar(void)
{
	a(0);
}
--------------------------------------
gcc.dg/asm-wide-1.c

void f(void)
{
	int a;
	asm ("foo" : L"=g" (a));
}
--------------------------------------
gcc.dg/noncompile/920721-2.c

void f(void)
{
	1 ? 0 1;
}
--------------------------------------
gcc.dg/pr14475.c

struct a {
	enum b c:1;
};
--------------------------------------
gcc.dg/pr18614-1.c

void a(void)
{
	double b = { 1.0, 4.0 };
	c();
}
--------------------------------------
	OMG, C++!

g++.dg/ext/max.C
g++.dg/ext/asm1.C
g++.dg/opt/pr7503-2.C
g++.dg/opt/pr7503-3.C
g++.dg/opt/pr7503-4.C
g++.dg/opt/pr7503-5.C
g++.dg/opt/max1.C
g++.dg/opt/static3.C
g++.dg/expr/static_cast2.C
g++.dg/warn/minmax.C
g++.dg/parse/crash23.C
g++.dg/parse/parens2.C
g++.dg/parse/angle-bracket.C
g++.dg/other/conversion1.C
g++.dg/lookup/enum1.C
g++.old-deja/g++.warn/compare1.C
g++.old-deja/g++.eh/cond1.C
g++.old-deja/g++.abi/align.C
g++.old-deja/g++.law/cvt12.C
g++.old-deja/g++.jason/bool4.C
g++.old-deja/g++.other/cond5.C
g++.old-deja/g++.other/overcnv2.C
g++.old-deja/g++.other/builtins5.C
g++.old-deja/g++.mike/pmf8.C
============================================================================
P. S.: Linus, gcc testsuite (for all languages) is at
ftp://ftp.gnu.org/gnu/gcc/gcc-4.0.0/gcc-testsuite-4.0.0.tar.bz2 (2952k)

--Boundary-00=_6WikC059zDjIpxE
Content-Type: application/x-tbz;
  name="sparse-20050519-crashsuite.tar.bz2"
Content-Transfer-Encoding: base64
Content-Disposition: attachment;
	filename="sparse-20050519-crashsuite.tar.bz2"

QlpoOTFBWSZTWT0N3jEAJu5/9///5hB7////////7v////8AAgABAUIEAQCYEAgAiGAcHPCcn22u
qXu57se96PTKVK6F7vdzzGzebXrbbzseZreOrDOvd3c1r2r3s07c3J57oHvde2lLt0eXtunNsPez
3mFbvc7z3NrKnHhJEgmmhpqYmCno1PFT9Min6p5Jo9E9RtTTQ9TQbRB5qQAAeoAADEEkSaYICBEw
lNnopP01R6g2gmhp5QaaNHqGgaHqNAANABoAQYAAAAAAAAAAAAAAAAAAAAASaSRJMjKNPUT9KMmj
TTamTMUBtE9RoAaeoAYjRo2ppkMgNAABEkQICZJhU09NTZGmmg9RqY1NNHoE0ADE0NNAAA0aAAAS
JBAINTCaGmpmqNqk/0JJ+mk2QJPCnqPSPUGgAABow0gANDjPTkkf/ecW31IrBYoFYuddMfiSE8xm
YMV9qQltBlQipID0pCSE7O3l9rtZ2eMtjRfHCmiVaxVY2rI6O0uSroiuFKvRNLFNGmq2ovhhhIed
aznepkq64KyRkQDVEAgIyBIgsQBglAxWCEQkA1uz0LBb+DeXhXCmpG2F7paPCI0CXgXhHhqvbtne
MubSudnWofJ2zwNYCnJGqOx1bmS782jMFQWFk3iB070B+s2/R7lPPeWQP4GMOI/QyQibN+LfB2v9
Ac+PD77DhOlbza839T9n6ZVweexOyZOG0NdLyoxcbmlOmHXz3ApXr8+KdmblExL0nQzN1d8SkIcb
D1F1QDiVFpASAgobdHWHi4nfeSzsYUwoKeFebJYJNDQNkN3KVMKK0JwDDBNjaFmb71Ne3u6+Sx4M
8u7ncZYESw9JlPJb9V2E2VnYRDOl29gxZajI1rN9ThaTgkPAZvvhgbITEXZqIrJDVVgs2JBGqmDM
MCAucNOcIIcnNhJgKROR048HWVHeEPHgAgQhmWEeS5tSqeGqxFG4F5QSAikaCKmUUkohyKyDKMsY
VgBwpkhPZBBCKxGT53RzkgXLmmWVySEg2M8xAugc7xMIbIurYskIoSIhIKjCKSCkRhIs9HbqiDk9
nQd0YMQSMGTn9rhv8amRvVBdgRI6eJgp47YL4AQGwxKkkgnTPncgSykoM1w2NVZ+S0pUH1W8apIn
E1MA0Nf2/WtFSb59Epd+kUorKvVIQd5u0sn9VwgmIrVMnfTys8Plu/BVXppIWDz2qKlASIk6fTyY
a5jYzIxUUkKCBRVVzMzwaXmZvKdBpSO1URlnObKHP7ul2MTU4uskuJEbkZd+DoGXK3K3DJI1EqC6
yM3Re3rWWjatmExakX+o/z9GINE+7tmBHlwFQ8IbIy2BUGTBoHYJJzTT0SIL388ik4E97NPYoXfd
3Q46Qpei+343IZupFIPIT7/FvzHARd9IosnCBnRhDCKRRMxb2SwyDvmEUv5p4lkcc6KwmYE3kvNX
hNRkfB8EhvIrUZ5mUVWV6h+Q5wNkysfjEwumOrdYTYVfRMeJBu0c57vFnYfqsvCzXuuo/c0799Aw
8bJCxlAHjvFmJiYmKyBU0dsz7JS0GE74bNtwap7pCvVjB2QI1sDw3cRQIGL0nmm/PQoQQe5zO0xw
/xEFep4MQXj8QGz2he2xVv7+3+6M2kzJQCmdiWOtPfzztkFk3rWEhQVy4cFBQXJ8myuzZmj2m9uX
yUIMG2gYfdPtdNWF+hXd3ubuk0i67u6NM9tDVNNjbyxkSyNQBSYxeCt5WyReRfDd2TOj8/4fG+Kh
IaZKb7e5C2LxUjff35GcmYld+DdKkcZgdDDuJghA4de3zXHt06M7FmcltndLvF+Xjb4DaXittAe2
/fW7GCjWRML/ubIJ4m9q+9K/iPkGqXdyx46aZGKjHkhJGOsRrry/N3LvP7/c8AZhJZStpwfU5b+/
PaFIxuhcNox0wNzQaL7SHiuPcOF06zIFqNlgxXx1g3JzceuNSJvLsmmQbyBZL2ReyqEguIfz70Gj
HXQOUWEBNhhBZhBs+9EgsWcZK+r7D1ZQqHZ1UGMN2ZwpqHtOzBJ7g10JDihU18BFr+aHCsyN3TE+
dELA0+R1z6Fv67e83xbUbGZjgnolnh+B4aLrxza6Uj13z7sHhwkbqUyit7he2tJ7vJlzbTjHdjz3
7m1pKxPLW1hD5QBI4cDWBiUTxuuTCt5ccBrcNO4XZ166JL6U5VsO2dbp3IbamOnkygjGMYwIxjGJ
krexnm6DKnORTZsnhKClhs80WjeT4G4DaBqVdbrLdBqn871EzBy+8z6Au4DJcXDvLSGccrzVPZfe
eId/oqGGJ0x1seN1Dag6bddaM1XxvH3TObAtzjtr44R9yth2LO6KX+qszynkmX841o1DTTAbE2IY
kSDGQIRJACZYTpfiLu3TPTHPbut3v2ZT2O2cLW/MUrcx8Xl50nKwKphzTXv9TT8XchaNGEJvFkXM
L2PXtaNpS9O51Pak6EMsOruy+2fRPZPZ9o5x9Z3BzWEpGayXm5iQoS1kUXPz6yuSpJd5abrN2HfP
D68gTCeknmjbL0wyc8i+fn9UCxGR7NGUtS34Xa7mtcMkplpA2nMAH1Fl5OY9AtzbTIbnsSycBtpA
SUaVhEST0nU5yUDlY+dYG/egLRvd6/lQTEVvyJTaF9XshB8XuEBhYbvX6vVOq+kXui+YUptcO2JL
dy2fCBmRPXcW53caTC4Lhh8rUTaFOA1NzvbU02BN0dsOswygKVDoiHPsKRYXcLJjHdEGwSobzk44
3KCB6h4DCxNJDOyoWghaLnDOCHrTOYMJDX5vW6Os1e455+YrXw5kmnuE2nDVmiazV0GTaekXAy3h
07fvrf8+rWK5k3Y0gt8SJRAvrYRv1nQOcRaRwICcGokUNgypyO4zKhaMswuqtnVud2VQx6k4+7ge
XB28uZONS5092RfdwYy8ITLwrJxhy6du7dtFfXenUyIawCLvGfTacZPfwhR97wvNwMNjrnThR5Bo
UxDS4Hh9iCfwuosY5OopkkxytrAVGCkaqt7+2WjlUxTGx2QMt8l0qHAHbr6vEzPOIdj6PGVcq6LF
54co8h26h2CisKwBiwipGEyPfeYNpbzvGd1hB5ztaJCqBZ2kCjd09TsF/mMEG7rZ9FOgNlXWpa3W
7YsWzn0Em5uSj2auJZQWe9fJKuyRwXSM6cKTcz27qJJQt9kupLWMsSb6VdTeYnlYGxV7o+EKWypU
Mo8PCmBs2UF/RxBuZ0IPJkkkrwbcGJ1UvHsY4FXTP1sPcrWQZMsF1jAajBvz1a0iyIlYo9pyntir
tddxeSC22feXPUbt/gdBU1UXZpLGUPHOcnt2Lw4dPYVTqEHpIqJ++j0mEP8AjElkGfVZKnb0WBiR
QsiFxpFbZfVVAqMdQsYMsDQwUKES/QHSPKMPUu3c8LRTkgJxLaNgdbhMOCrCS19ObNYPIirFW/Vj
fDBVTt9yNOVraHZJQYd+2FY3thWWpVoVS0NdVUFUxehV9z2g8Hy6rvQ/FON62dfN40YZ6epPj7do
qw3KsUDpN2258Xhkq2EDYklyA7A/pemX7IleDzSSYAHjrgVynM21OwpLmtR1FkFxudnpJsYQtSl/
OFKjHdh0Vvjw5OiPKXRCfS4HCXSUnwQjosOPFJNEtuTJqOrVCSdXnDvW4ttJLsQjyH44YaMZj6Si
Hv49LVngBHd0SIjsR5cbTFKSTeXpkWgZeLQhFWNA9bQ1Xb6uOZdVlzTVJRWSSgODDYldcCvQ+aNx
mQZdq0IMJUloZM9HQLrnAodcbq2F1jQWNY/Ly+DF2JI2DIgkl2PNtNj1Z7/CLt3QklEu66KPdHAl
WRaSkA1jGMiybzvhZiDMM/LMv0hGcYIxugJA+OzvrceQu7c7qDeO22lOj1rRXnurNxfBtghBbF8s
GlYSdEJKKY0DNglDaY1VuHYwvrxmOl4q1trhjfxttWVchWYqqMkktcymFZzL6wpjKicotYpytCVa
N0rXC5y+S3iHPu59V5lAE0aVZpFpV2VI7IYVGEbOAFmJpM+EEvO+1Kd49IVKTTIWia5JLqbCkTG/
PaL2+aMaiS6fCELs2thp2qG7Wb6ayvjsoXSnfdk1pzhN8HpHos8azuuADvB54YX3sw1MZRKPACIH
SYcdDgUHKHEfsVjtgOaVHi+UMclWOwTRSSxHdXlKomKXdfK+dDl5pB7S+SEc2CpRQzw38gmb2Ioz
tYHWg0WC9hsXT9tlCz5sO8h/EmDPVrrPjK6Sm5llzYR3yQeDu47u78foEkmwHBY3+CQO0wWmlaf0
/R96U98Li9XpjLGL2rsdL2T8RmT11Dwrc0afhbYltXws7SeSXG06t1dW64vM+CNbT3176mreoHAT
ikLds1RVnn78gAbd2UOFqTJHZV+Zj3zR6KuZs5Q4OKs1TBwPPmjBU03mgW3MUEEjECsDoLzIkPvH
f0UkUGcjyQm890Uv8ZeVKQfnPFeURMINmBPJZHj78w9N8UYuknRl7xAGEPNLSJFIJAQEIkEJaQbC
UfjhE8hKY6cr15o6KkoRZgt2gqzOShgs9XiMsVsbi7+F7m5Uk5C1yej0E8XQTqMj3NZPOPlC2FKs
RVshbYFUcJrwhdKcyjYxtjbbodhTb2Dw3+75pU2y0fGIFBAiCQEfJ8pDMecPQ90deynuesHtmSRO
aISAaEXXDmmgDO2GA1tiJc1fWtTlSgeEB7wfYE72kFWjEflYP3D9LP49BWTwB68zyO1cfXeZjzWX
IopwX92z2qLjx5fhEt7kAjD4dsA+k0tCl+NhkOY2UpJflNW+QBk9+f37ia3A0iMwlgXAyTCDALju
CPV8Pf4+CfusDD+Z5Fw5AYc2O/Y3zrGriXCzsQZVq7Qg0fH2uT1L6aRYumzXwkD4tJ0Bxb7YgMIb
gZDg9SrP6NcL1/rKgSNowmmCiz3ywv6UkmVZRgV5MaGpyx98Z7DqVKEDTokDo7BeUNCP2S9JLu+v
PWvUHkEqsdO8wQeSFP6x/s4HXtSRCvGmXRYCduT4eWX2ZlbmNZyDOZgw35rXbYa/QaFVJL5Qoj4I
ITTAmr+H4BRHYVUPBD3CakIGKhggFrNtpyABZ68Xwp91A2rNghVgLVMFAzRvFtFx2U/ewQhIS17T
oHQREjB+trfBgMHXqqhfnGUzllXseN6h3bhlCZQIGndYZDKLda9tOHYTJFgsmS5i4q+l3JUQEzJd
d1Q6HauqVMoO3AuXJoGNJ5AwD5g0Jw4wYxjc0uPYU7lhJU6aJYnomSH1rRCa0oDBGG3WDUcUSLEH
gw7BpTthoo1HULgaZS032EGFDaWdOZL3NOey2JRgGBY2kjExifBjWdXVePJpzIyETcVWeWw3KuYY
NSoQe5DE732sANBx2Xr0jbBIKgeJlwL0vA0G5tJCwpbWSUF4MOhzWxnXTDpu3zut1OUeL1ePiUWO
ZQKJlZkp/Vzu0NrDoV43iJk/2tI5EdYDbqr3DqCwSM2AgyT2QZ3CRMXF9blKEzuKma1lBzhnx2By
eBhU8NZ9foakmxiKKvF2PhX0oPXdg12cGv63xMlmQJ4EL5DaBeSLD97EcniNB6DLBIb1DW6WL34E
ZKbWwa5aQQR1cJMZbIXtXFJLdJSxNiSVA5WxtClyhGwwTZsAmO7iWSuzFkXVD2hTx0M2vGEUSYJT
vNsLg2MDsM2+SSee6yOwghWBmWd4QRLD2BbOUUXeZmb9upqg2YQTIcuK00vgxlohUaYoYFu9JMWD
S11JHBSTFoSd9hYrt+hLy74Bfm8Y9/fPRMM16FQw8dCqd6r5WO3dQG7srTNngY6xzprzOhjXsqfo
jaaQixB28TvsNFC4AS8Nj8HpnM9hN/AU8Um8pcLShCggpFQGEjJtekZTyC8qW2sKbws5Yb3xJ7HZ
3Li6gRI54xxVVpRQ9IUOgNUHc15BDFAmBaOd8zoNWGUwi85wGk1CEgD2yedjGh5xUjad4xGgH5Q9
31Hu5bryxBozs3iWCJlZJJWtJK6xUK1NQ7g71zpiSHpVpdWZJlBjEDDtWfB2vewEMfbgV1EdLUBp
IypNYlIkVcwMDArZSS9Hgd0gYC60UvJTNsIg/nGB7z40gmUgL3d3HNYnLycBaCE0mmup6uIgmxIG
xce50oehMZ5fmFecbB7uhxFA6Yh3i2AurcQFMwMIUd/ME2FLVy0Wc4rhVSJgYDeZxGQUQYLWzRuL
DvOAg36qbBEtk1K67z2Y/dNpkFE13NIFhCinWw9fNQ9dDy8hNkMCiRRUGDQdwL0aTR7VeXZqWxtj
TTY2NgHVZtDs3Isu9BRkQmhpkGO8JdiGFqSVwjt6jr1EtNrGy8v1DshJGzFJNitFu5rxuatkBVS2
FJyuBqmc2NfBRwhso5ckRd0Z3XqZgQkUnfeVSXSiVgjP0dEUYUGYTJbNr3U1IKh5bio1wtUks9Oe
UCJ2ErpEDFfwFusOLX0NSB6VZe7hbIBbDHbJ1wtfM6bEB03jYYWB0KrRvCBNsF32eKsNp8UskY1G
JElaMmd0RYcvv2oaxCkAzOBI0lCnAxUkDRZAVO/VoORSrNCyRCkguEMmMkJuxMrWCtzKFhiaHNWw
jRDD/IpRBvHlQLV1w2lEDI/mHZUXbZUkFBqk6H6CrOmBJKVgESYMByJHEdBpu9AoIbw7mu4pgQhF
IkIMzY9rkEKzmRCgNZmeWNlSkJB0V2EJjqMlbWC6MWoLJAVQgLEYCCQihHxizaYTQ7FZAim9lEuo
7I5tbW+uOYoQ0qwsHKUz6bAXISwmUAyMR0sJ2exB6wbz3ufkXacBTDdsFKEtXRfqHwZ+QKBmphve
Tmcd4ECjSlfRwOOjTtKpLSmBZYmAlk4q2QLI4pF5QPeiBEieS9bNTjIDkPJvVDKVUwYcUEDocJsS
LpCMqgjOMpxWVEcYrfb7Nq2Lpas9OdCwDeLlWhCW7tF2vVIMV0682RzmJvK1tcla9jLtJ0+p2DG7
tQjuLeVtXukQt78m/E4d3YXW4uPs81GBycN9QW5rj5rcduA8usruqsEKiCrIWBzuYLI2FKeCds9b
DabRAu8DEjsGdpgofk42JHlABoJlF51K9cAYE3KZH2q4iXRMt7u8TqGmuYPG3FuSxGJekE2kAw+a
RoScTByMkjADUPAeyOR88bqcHMzLFVDZAiK6QKgtCG5Tk8NEczgIY5AiZyXKDNAIvf5UwVb4m3+W
G0AsJ5mmbGGxV15cYdJ3bWoHr4Y3JZMgjuuYY1a9aeC1QqUdFIa8fZTfTVUIJWz+XCmRBDpDjt1E
aXGat+TWwzo2zyYHXtw4m7I6A5JSrj6oSzELmdlXxzgcXGHUELJJ3xz55u+g3FR0UoiIiWDTJEGO
e+8SOqIWEKQa1+E0xkx8k/rx6P7f9973v8T/nx8HJ5/+el0eHRv/99n+yeHP4vF9ufIC22kYSyQM
ozBvO4MhpeVASoCQxTtPQqxfXJ6k83UmrquD9k9UPEtQ1DdY6vTVaD7d1v16CuRQrEa4rbZjQgib
2kBtsO/0dW60OjNbaQzmuHdQvSLAuGEgoVJK1iUYweL9OJasXkW1JOg1S6BWUVRSQUYYq+kggkEA
yZAj7da45W+k+QkQR0oFRiACGE5kT80SbIxiSgIC9AyQ5kNEdarE2YVSRXHGr8oezmmYmosmnfyD
yogmoyw5a8G42hki+kHGjblQJRu15JIE+I2oymWxAoJgs5Odkgx3mCFeOygD0/GbrXeKy3fQxsie
CIISbLIyw8ZqAIj3BVW3XzufmHioiaMcl0mrXehdAszVrAN9gwLRlGcz5e8Q5qvPrDQ2ieqygOZu
PAojxEks5ms3ACVY1GJI/+VfY/mq4bwk7/WG1hrdx2TAeThsOT785cGEFgG4kdebGObLWS7MCC1K
MrRX2jbbQUdyBUYkVLKU9kMTQgBvG/rCE15QKnWQCpymSLBheDudw1JLuiSYKSDmUJA0j+iCZvFl
ZWMytM19QWzkmR/Ld2mhI6hSOfH0BJh0p7yAiCiIERjGCMFYsAJ3WEPd/1YdggcxSBuKSRiwRYQS
EO6kk+xGBiSDFEygfxzO8rr5HjJ1wAX/i7kinChIHobvGIA=

--Boundary-00=_6WikC059zDjIpxE--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <lkml () looxix ! net>
To: linux-sparse
Subject: Re: sparse and gcc-4.0.0 testsuite: results.
Date: Mon, 23 May 2005 20:06:20 +0000
Message-ID: <429237BC.2090605 () looxix ! net>
--------------------
Alexey Dobriyan wrote:
> Tarball attached. Trimmed down testcases (C only) inline.
> 
> This time I ran sparse on all files (Ada, C++, C, Fortran, shell scripts,
> other random crap) ;-).
> 
> Segmentation faults
> ============================================================================
> ...
> --------------------------------------
> gcc.dg/pr18809-1.c
> 
> void a(enum E e)
> {
> }
> 
> void bar(void)
> {
> 	a(0);
> }

I have looked at this one last week.
The problem come from the incomplete enum type which base type don't have itself a base type,
a call to is_int_type() provoque the crash.

Others use of incomplete enums like the one below have the same effect.
	enum foo;

	static enum foo a;
	static enum foo b = 0;		// Oops
	static void* c = &a;		// Oops


But the problem is more general, if I have understand correctly, sparse don't have for the moment
the notion of incomplete type and accept without warning code like this:
	struct bar;

	struct baz {
		struct bar  b;		// should warn
	};

	static struct foo st1;		// should warn
	static struct foo st2 = { };	// should warn

	static void* p1 = &st1;		// should warn


Luc

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse bug when goto label between end braces ===

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: sparse bug when goto label between end braces
Date: Wed, 20 Apr 2005 20:50:15 +0000
Message-ID: <18601.65.113.40.130.1114030215.squirrel () numba-tu ! com>
--------------------
Nope, l: } is legal K&R but not legal ANSI-C and C99.  Sparse is right.

Tommy



Steve French said:
> I ran into a bug in sparse when I added a label for a goto.  I changed
> the code I was planning to add to avoid it (by adding a continue at the
> bottom of the loop) but it shows that there is a bug in parsing goto
> labels.  The sparse version is current (at least matches the one that
> was in sparse.bkbits.net).  The sparse tool generated the following:
>
> test.c:15:2: warning: Expected ; at end of statement
> test.c:15:2: warning: got }
> builtin:0:0: warning: Expected } at end of compound statement
> builtin:0:0: warning: got end-of-input
> builtin:0:0: warning: Expected } at end of function
> builtin:0:0: warning: got end-of-input
>
> You can see it from the following tests which differ in only one line
> (the 1st generates the warning, the second does not).
>
> void some_junk_function_with_sparse_error(void)
> {
>         int i;
>         int j = 0;
>
>         while(j!=2) {
>                 for(i=0;i<10;i++) {
>                         if(i==9) {
>                                 j = 1;
>                                 goto out;
>                         }
>                 }
>                 j = 2;
> out:
>         }
> }
>
>
>
> The error can be avoided by adding a superflous continue statement e.g.
>
> void some_junk_function_without_sparse_error(void)
> {
>         int i;
>         int j = 0;
>
>         while(j!=2) {
>                 for(i=0;i<10;i++) {
>                         if(i==9) {
>                                 j = 1;
>                                 goto out;
>                         }
>                 }
>                 j = 2;
> out:
>                 continue;
>         }
> }
>
> which is ugly.  As an aside, I hate gotos, but the kind of case I was
> dealing with was someting C did not provide - ie a way to use break or
> continue as if we were in the outer while loop while inside the inner
> for loop.  It can be coded differently, but it ends up with longer code
> - and while I was debating which was less ugly (to use goto or not), I
> hit the sparse bug which the junk code above demonstrates.
>
>
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse emit wrong: unreplaced symbol 'noident' ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: sparse emit wrong: unreplaced symbol 'noident'
Date: Sun, 09 Jan 2005 21:32:00 +0000
Message-ID: <20050109213159.GA6513 () mars ! ravnborg ! org>
--------------------
When running sparse on kernel/ subdirectory the following
warning is emmitted:

kernel/audit.c:172:9: warning: unreplaced symbol 'noident'

I have tracked it down to the following minimal testcase:



#define SPINLOCK_UNLOCKED (int) {1}
static inline int fun(void)
{
	static int x = SPINLOCK_UNLOCKED;
}
int fun2(void)
{
	fun();
}
int fun3(void)
{
	fun();
}

The culprint is the second use of the inline function in fun3.
Hope this may help chasing this bug.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse emit wrong: unreplaced symbol 'noident'
Date: Sun, 09 Jan 2005 21:40:08 +0000
Message-ID: <20050109214008.GA6768 () mars ! ravnborg ! org>
--------------------
On Sun, Jan 09, 2005 at 10:32:00PM +0100, Sam Ravnborg wrote:
> When running sparse on kernel/ subdirectory the following
> warning is emmitted:
> 
> kernel/audit.c:172:9: warning: unreplaced symbol 'noident'
> 
> I have tracked it down to the following minimal testcase:

Grumble - that was waste of time.
Forgot to update sparse before usage - it is fixed in latest sparse.

1.1227 or maybe 1.1228 fixed this I assume.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse on ia64 -- using gcc2? ===

From: Prarit Bhargava <prarit () sgi ! com>
To: linux-sparse
Subject: sparse on ia64 -- using gcc2?
Date: Mon, 09 May 2005 14:12:15 +0000
Message-ID: <427F6FBF.6010900 () sgi ! com>
--------------------
Hi -- I'm using sparse to clean up some of the compile issues with sn 
ia64.  I'm not overly familiar with the internal workings of sparse and 
have the following question.

I'm using RHEL 4, with gcc 3.4.3:

[root@altix3 linux-2.5]# rpm -q gcc
gcc-3.4.3-22
[root@altix3 linux-2.5]# gcc --version
gcc (GCC) 3.4.3 20050227 (Red Hat 3.4.3-22)
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

[root@altix3 linux-2.5]#

After compiling and installing sparse I am doing the following in the 
latest 2.6.12-rc3 tree.

[root@altix3 linux-2.5]# make C=1

This results in the following error (amongst others) when compiling 
arch/ia64/kernel/perfmon.c:

/usr/lib/gcc/ia64-redhat-linux/3.4.3/include/stdarg.h:54:9: warning: 
preprocessor token va_copy redefined
include/linux/compiler-gcc2.h:29:9: this was the original definition

A compile with

[root@altix3 linux-2.5]# make C=1 V=1

on the same file yields:

sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -m64 -D__ia64=1 
-D__ia64__=1 -D_LP64 -D__LP64__ -nostdinc -isystem 
/usr/lib/gcc/ia64-redhat-linux/3.4.3/include 
-Wp,-MD,arch/ia64/kernel/.perfmon.o.d -nostdinc -isystem 
/usr/lib/gcc/ia64-redhat-linux/3.4.3/include -D__KERNEL__ -Iinclude 
-DHAVE_WORKING_TEXT_ALIGN -DHAVE_MODEL_SMALL_ATTRIBUTE 
-DHAVE_SERIALIZE_DIRECTIVE -Wall -Wstrict-prototypes -Wno-trigraphs 
-fno-strict-aliasing -fno-common -ffreestanding -O2 
-fomit-frame-pointer -g -pipe  -ffixed-r13 
-mfixed-range=f12-f15,f32-f127 -falign-functions=32 -frename-registers 
-fno-optimize-sibling-calls -mtune=mckinley 
-Wdeclaration-after-statement    -mconstant-gp -DKBUILD_BASENAME=perfmon 
-DKBUILD_MODNAME=perfmon arch/ia64/kernel/perfmon.c
/usr/lib/gcc/ia64-redhat-linux/3.4.3/include/stdarg.h:54:9: warning: 
preprocessor token va_copy redefined
include/linux/compiler-gcc2.h:29:9: this was the original definition

Oddly it looks like the compile thinks it is using gcc2 and 
include/linux/compiler-gcc2.h?

AFAICT, a clean compile using

[root@altix3 linux-2.5]# make compressed; make modules

appears to correctly use gcc3.  In addition, scripts/gcc-version.sh gcc 
returns 0304.

Is there some setting/config that I'm missing?

Thanks,

P.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse refuses to work due to stdarg.h ===

From: Pavel Machek <pavel () ucw ! cz>
To: linux-kernel
Subject: sparse refuses to work due to stdarg.h
Date: Sun, 16 Jan 2005 22:49:22 +0000
Message-ID: <20050116224922.GA4454 () elf ! ucw ! cz>
--------------------
Hi!

I'm probably doing something wrong, but... how do I force it to work?
I'm pretty sure it worked before, I'm not sure what changed in my
config.

pavel@amd:/usr/src/linux$ make C=2
  CHK     include/linux/version.h
  CHECK   scripts/mod/empty.c
make[1]: `arch/i386/kernel/asm-offsets.s' is up to date.
  CHECK   init/main.c
include/linux/kernel.h:10:11: error: unable to open 'stdarg.h'


								Pavel
-- 
People were complaining that M$ turns users into beta-testers...
...jr ghea gurz vagb qrirybcref, naq gurl frrz gb yvxr vg gung jnl!
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Pavel Machek <pavel () suse ! cz>
To: linux-kernel
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 11:49:27 +0000
Message-ID: <20050117114927.GD1354 () elf ! ucw ! cz>
--------------------
Hi!

> > I'm probably doing something wrong, but... how do I force it to work?
> > I'm pretty sure it worked before, I'm not sure what changed in my
> > config.
> 
> kbuild was changed to reliably pick up the stdarg.h for the gcc used.
> Two issues has popped up:
> 1) sparse did not support -isystem dir
> 	- fixed a few days ago, and fix is at sparse.bkbits.net

Thanks, I installed -01-17 version.

> 2) misconfigured gcc's that report a wrong directory when using
> gcc -print-file-name=include
> The directory given must include stdarg.h - otherwise gcc config is
> broken.

That seems to be ok here:

pavel@amd:~$ gcc -print-file-name=include
/usr/lib/gcc-lib/i486-linux/3.3.5/include
pavel@amd:~$ gcc --version
gcc (GCC) 3.3.5 (Debian 1:3.3.5-5)
Copyright (C) 2003 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There
is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.

pavel@amd:~$ ls /usr/lib/gcc-lib/i486-linux/3.3.5/
SYSCALLS.c.X  cc1plus       crtbegin.o    crtbeginT.o   crtendS.o
libgcc.a      libgcc_s.so   libstdc++.so  specs
cc1           collect2      crtbeginS.o   crtend.o      include
libgcc_eh.a   libstdc++.a   libsupc++.a
pavel@amd:~$ ls /usr/lib/gcc-lib/i486-linux/3.3.5/include/st
stdarg.h   stdbool.h  stddef.h
pavel@amd:~$ ls /usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h
/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h
pavel@amd:~$

but now I'm getting:

pavel@amd:/usr/src/linux-cvs$ make C=2
  CHK     include/linux/version.h
  CHECK   scripts/mod/empty.c
make[1]: `arch/i386/kernel/asm-offsets.s' is up to date.
  CHECK   init/main.c
/usr/lib/gcc-lib/i486-linux/3.3.5/include/asm/posix_types.h:29:35: warning: no newline at end of file
/usr/lib/gcc-lib/i486-linux/3.3.5/include/asm/posix_types.h:13:11: error: unable to open 'features.h'
make[1]: *** [init/main.o] Error 1
make: *** [init] Error 2
pavel@amd:/usr/src/linux-cvs$

Any ideas?
								Pavel

-- 
People were complaining that M$ turns users into beta-testers...
...jr ghea gurz vagb qrirybcref, naq gurl frrz gb yvxr vg gung jnl!
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-kernel
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 15:46:26 +0000
Message-ID: <20050117154626.GA16111 () mars ! ravnborg ! org>
--------------------
On Mon, Jan 17, 2005 at 12:49:27PM +0100, Pavel Machek wrote:
 
> pavel@amd:/usr/src/linux-cvs$ make C=2
>   CHK     include/linux/version.h
>   CHECK   scripts/mod/empty.c
> make[1]: `arch/i386/kernel/asm-offsets.s' is up to date.
>   CHECK   init/main.c
> /usr/lib/gcc-lib/i486-linux/3.3.5/include/asm/posix_types.h:29:35: warning: no newline at end of file
> /usr/lib/gcc-lib/i486-linux/3.3.5/include/asm/posix_types.h:13:11: error: unable to open 'features.h'
> make[1]: *** [init/main.o] Error 1
> make: *** [init] Error 2
> pavel@amd:/usr/src/linux-cvs$

You seems to have a symlink? to /usr/include/asm in your 3.3.5/include
directory.
But real issue is search order of include paths in sparse.
sparse searches standard system dirs before dir's specified with -I ...
This in contradiction to 'info gcc - see description for -I'.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 18:21:14 +0000
Message-ID: <Pine.LNX.4.58.0501171013000.8178 () ppc970 ! osdl ! org>
--------------------


On Mon, 17 Jan 2005, Sam Ravnborg wrote:
> 
> You seems to have a symlink? to /usr/include/asm in your 3.3.5/include
> directory.
> But real issue is search order of include paths in sparse.
> sparse searches standard system dirs before dir's specified with -I ...
> This in contradiction to 'info gcc - see description for -I'.

I don't do info-files (what a stupid idea they are - before html they were
detrimental as they caused normal man-pages to be useless, and after html
they have no reason for existence what-so-ever).

Is the gcc logic documented somewhere? Ie what are the relevant rules for 
-I, -isystem, -iprefix, -idirafter etc, and how do they interact with

	#include "file.h"
	#include <file.h>

The sparse logic itself is pretty simple: I know gcc has this stupid
notion of two separate include-paths, and sparse used to do that too, but
it sucked so bad with "#include_next" that it's now just one include-path,
but it has a couple of "marker pointers" that get updated to show where
the "system" headers start and where the "normal" headers are..

So it's not like I can't make sparse do anything I like, but the gcc 
behaviour is so confusing that...

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 19:45:25 +0000
Message-ID: <Pine.LNX.4.58.0501171134530.8178 () ppc970 ! osdl ! org>
--------------------


On Mon, 17 Jan 2005, Sam Ravnborg wrote:
>
> I'm trying to implement the above 'logic' right now.
> The basis datastructure looks like this so far:
> 
> struct includepath {
> 	int searchlocaldir;   /* =0 if -I- has been given */
> 	struct path {
> 		enum dirtype {
> 			systemdir,  /* defined here or by -isystemdir */
> 			userdir,    /* defined by -I */
> 			userlim,    /* limited to include "" (by -I-) */
> 			empty       /* skip, try next */

Do you really need to have a dirtype?

Why not just have the "system directories start here" pointer, and reverse 
the meaning of it (right now sparse puts them _first_ in the list, not 
last)? Then:

 - always put the "" paths first (put the "current .c directory" and "." 
   very first), make "angle_includepaths" point past them (replace 
   "gcc_includepath" with renamed "angle_includepath".

 - -I- removes the "current .c directory" entry, which is easy to test 
   for: it would be the first one, except if the first one is "."

   This means that "userlim" is not needed

 - "add_include" always checks whether it existed already, and does 
   nothing if it did (regardless of whether the thing is added to the end 
   or to the middle of the list).

   This means that "userdir" is not needed.

 - "-isystemdir" always adds to the end of the list (no need to mark them 
   "systemdir" either)

 - "-I" always adds to _before_ the "sys_includepath" marker.

Then at lookup you just do:

 - if it uses "", start at the beginning
 - if it uses <>, start at "angle_includepath"
 - if it uses "include_next", start at the previous include-path entry

so at least the lookup is always a total no-brainer, and has no special
cases at all, and all the special cases would be at "insert into path" 
time.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 20:30:43 +0000
Message-ID: <Pine.LNX.4.58.0501171227370.8178 () ppc970 ! osdl ! org>
--------------------


On Mon, 17 Jan 2005, Sam Ravnborg wrote:
>
> On Mon, Jan 17, 2005 at 11:45:25AM -0800, Linus Torvalds wrote:
>  
> > Why not just have the "system directories start here" pointer, and reverse 
> > the meaning of it (right now sparse puts them _first_ in the list, not 
> > last)? Then:
> > 
> >  - always put the "" paths first (put the "current .c directory" and "." 
> >    very first), make "angle_includepaths" point past them (replace 
> >    "gcc_includepath" with renamed "angle_includepath".
> 
> I messed something up here. "." is actually "current .c directory".

Ok. If there's always just one, then why not just keep it always there at 
the beginning of the array, and then you have "quote_includepath" that is 
initialized to point there, but "-I-" will do

	quote_includepath = include_paths + 1;

(which is idempotent, so you can have as many -I-'s as you want, without
even worrying about it).

And then lookup makes tons of sense with the beginning just always being
one of "angle_includepath", "quote_includepath" or "stream->next_path".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 21:55:45 +0000
Message-ID: <20050117215545.GA18293 () mars ! ravnborg ! org>
--------------------
> 
> And then lookup makes tons of sense with the beginning just always being
> one of "angle_includepath", "quote_includepath" or "stream->next_path".

Something like this.
First cut - it seems to work but rather untested.

I succeeded doing a 'make C=2 kernel/'

I will test tomorrow - heading for bed now.

The "fetch dir of input file" looks wrong and needs to go to a better
place. No need to do it once for all include files.

	Sam
	
===== lib.c 1.112 vs edited =====
--- 1.112/lib.c	2005-01-14 23:11:01 +01:00
+++ edited/lib.c	2005-01-17 22:27:14 +01:00
@@ -428,16 +428,8 @@
 
 	switch (arg[1]) {
 	case '-':
-		/* Explaining '-I-' with a google search:
-		 *
-		 *	"Specifying -I after -I- searches for #include directories.
-		 *	 If -I- is specified before, it searches for #include "file"
-		 *	 and not #include ."
-		 *
-		 * Which didn't explain it at all to me. Maybe somebody else can
-		 * explain it properly. We ignore it for now.
-		 */
-		return next;
+		add_pre_buffer("#split_include\n");
+		break;
 
 	case '\0':	/* Plain "-I" */
 		path = *++next;
@@ -465,7 +457,7 @@
 		char *path = *++next;
 		if (!path)
 			die("missing argument for -isystem option");
-		add_pre_buffer("#add_include \"%s/\"\n", path);
+		add_pre_buffer("#add_system \"%s/\"\n", path);
 	}
 	return next;
 }
===== pre-process.c 1.123 vs edited =====
--- 1.123/pre-process.c	2004-12-09 19:55:29 +01:00
+++ edited/pre-process.c	2005-01-17 22:50:20 +01:00
@@ -36,16 +36,20 @@
 static unsigned char elif_ignore[MAX_NEST];
 enum { ELIF_IGNORE = 1, ELIF_SEEN_ELSE = 2 };
 
+static char current_c_file[PATH_MAX];
+
 #define INCLUDEPATHS 300
 const char *includepath[INCLUDEPATHS+1] = {
+	current_c_file,
 	"/usr/include",
 	"/usr/local/include",
 	GCC_INTERNAL_INCLUDE,
 	NULL
 };
 
-static const char **sys_includepath = includepath + 0;
-static const char **gcc_includepath = includepath + 2;
+static const char **quote_includepath = includepath;
+static const char **angle_includepath = includepath + 1;
+static const char **sys_includepath   = includepath + 1;
 
 #define MARK_STREAM_NONCONST(pos) do {					\
 	if (stream->constant != CONSTANT_FILE_NOPE) {			\
@@ -613,9 +617,10 @@
 	return 0;
 }
 
-static int try_include(const char *path, int plen, const char *filename, int flen, struct token **where, const char **next_path)
+static int try_include(const char *path, const char *filename, int flen, struct token **where, const char **next_path)
 {
 	int fd;
+	int plen = strlen(path);
 	static char fullname[PATH_MAX];
 
 	memcpy(fullname, path, plen);
@@ -642,38 +647,34 @@
 	const char *path;
 
 	while ((path = *pptr++) != NULL) {
-		if (!try_include(path, strlen(path), filename, flen, list, pptr))
+		if (!try_include(path, filename, flen, list, pptr))
 			continue;
 		return 1;
 	}
 	return 0;
 }
-	
+
 
 static void do_include(int local, struct stream *stream, struct token **list, struct token *token, const char *filename, const char **path)
 {
+	char *slash;
 	int flen = strlen(filename) + 1;
 
 	/* Absolute path? */
 	if (filename[0] == '/') {
-		if (try_include("", 0, filename, flen, list, includepath))
+		if (try_include("", filename, flen, list, includepath))
 			return;
 		goto out;
 	}
 
-	/* Same directory as current stream? */
-	if (local) {
-		const char *path;
-		char *slash;
-		int plen;
-
-		path = stream->name;
-		slash = strrchr(path, '/');
-		plen = slash ? slash - path : 0;
-
-		if (try_include(path, plen, filename, flen, list, includepath))
-			return;
-	}
+	/* Fetch dir of input file */
+	strcpy(current_c_file, stream->name);
+	if ((slash = strrchr(current_c_file, '/')) != NULL)
+		*slash = '\0';
+
+	if (!path)
+		/* Do not search quote include if <> is in use */
+		path = local ? quote_includepath : angle_includepath;
 
 	/* Check the standard include paths.. */
 	if (do_include_path(path, list, token, filename, flen))
@@ -723,7 +724,7 @@
 
 static int handle_include(struct stream *stream, struct token **list, struct token *token)
 {
-	return handle_include_path(stream, list, token, includepath);
+	return handle_include_path(stream, list, token, NULL);
 }
 
 static int handle_include_next(struct stream *stream, struct token **list, struct token *token)
@@ -1328,8 +1329,6 @@
 
 static int handle_nostdinc(struct stream *stream, struct token **line, struct token *token)
 {
-	int stdinc;
-
 	if (false_nesting)
 		return free_preprocessor_line(token);
 
@@ -1337,18 +1336,7 @@
 	 * Do we have any non-system includes?
 	 * Clear them out if so..
 	 */
-	stdinc = gcc_includepath - sys_includepath;
-	if (stdinc) {
-		const char **src = gcc_includepath;
-		const char **dst = sys_includepath;
-		for (;;) {
-			if (!(*dst = *src))
-				break;
-			dst++;
-			src++;
-		}
-		gcc_includepath -= stdinc;
-	}
+	*sys_includepath = NULL;
 	return free_preprocessor_line(token);
 }
 
@@ -1361,10 +1349,16 @@
 	if (includepath[INCLUDEPATHS-2])
 		error_die(token->pos, "too many include path entries");
 
+	/* check that this is not a duplicate */
+	dst = includepath;
+	while (*dst) {
+		if (strcmp(*dst, path) == 0)
+			return;
+		dst++;
+	}
 	next = path;
 	dst = sys_includepath;
 	sys_includepath++;
-	gcc_includepath++;
 
 	/*
 	 * Move them all up starting at "sys_includepath",
@@ -1394,6 +1388,58 @@
 	}
 }
 
+static void add_system_entry(struct token *token, const char *path)
+{
+	const char **dst = includepath;
+
+	/* Need one free entry.. */
+	if (includepath[INCLUDEPATHS-2])
+		error_die(token->pos, "too many include path entries");
+
+	/* Add to the end */
+	while (*dst)
+		dst++;
+	*dst = path;
+	dst++;
+	*dst = NULL;
+}
+
+static int handle_add_system(struct stream *stream, struct token **line, struct token *token)
+{
+	for (;;) {
+		token = token->next;
+		if (eof_token(token))
+			return 1;
+		if (token_type(token) != TOKEN_STRING) {
+			warning(token->pos, "expected path string");
+			return 1;
+		}
+		add_system_entry(token, token->string->data);
+	}
+}
+
+static int handle_split_include(struct stream *stream, struct token **line, struct token *token)
+{
+	if (false_nesting)
+		return free_preprocessor_line(token);
+
+	/*
+	 * -I-
+	 *  From info gcc:
+	 *  Split the include path.  Any directories specified with `-I'
+	 *  options before `-I-' are searched only for headers requested with
+	 *  `#include "FILE"'; they are not searched for `#include <FILE>'.
+	 *  If additional directories are specified with `-I' options after
+	 *  the `-I-', those directories are searched for all `#include'
+	 *  directives.
+	 *  In addition, `-I-' inhibits the use of the directory of the current
+	 *  file directory as the first search directory for `#include "FILE"'.
+	 */
+	quote_includepath = includepath+1;
+	angle_includepath = sys_includepath;
+	return free_preprocessor_line(token);
+}
+
 /*
  * We replace "#pragma xxx" with "__pragma__" in the token
  * stream. Just as an example.
@@ -1453,8 +1499,10 @@
 		{ "line",	handle_line },
 
 		// our internal preprocessor tokens
-		{ "nostdinc",	handle_nostdinc },
-		{ "add_include", handle_add_include },
+		{ "nostdinc",	   handle_nostdinc },
+		{ "add_include",   handle_add_include },
+		{ "add_system",    handle_add_system },
+		{ "split_include", handle_split_include },
 	};
 
 	for (i = 0; i < (sizeof (handlers) / sizeof (handlers[0])); i++) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Machek <pavel () suse ! cz>
To: linux-sparse
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 22:32:02 +0000
Message-ID: <20050117223202.GI1379 () elf ! ucw ! cz>
--------------------
Hi!

> > And then lookup makes tons of sense with the beginning just always being
> > one of "angle_includepath", "quote_includepath" or "stream->next_path".
> 
> Something like this.
> First cut - it seems to work but rather untested.
> 
> I succeeded doing a 'make C=2 kernel/'
> 
> I will test tomorrow - heading for bed now.

Thanks; it now works for me (tm).
								Pavel
-- 
People were complaining that M$ turns users into beta-testers...
...jr ghea gurz vagb qrirybcref, naq gurl frrz gb yvxr vg gung jnl!
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Neil Booth <neil () daikokuya ! co ! uk>
To: linux-sparse
Subject: Re: sparse refuses to work due to stdarg.h
Date: Mon, 17 Jan 2005 23:26:08 +0000
Message-ID: <20050117232608.GF5429 () duron ! akihabara ! co ! uk>
--------------------
Linus Torvalds wrote:-

> Ok. If there's always just one, then why not just keep it always there at 
> the beginning of the array, and then you have "quote_includepath" that is 
> initialized to point there, but "-I-" will do
> 
> 	quote_includepath = include_paths + 1;
> 
> (which is idempotent, so you can have as many -I-'s as you want, without
> even worrying about it).
> 
> And then lookup makes tons of sense with the beginning just always being
> one of "angle_includepath", "quote_includepath" or "stream->next_path".

This is what GCC's CPP itself does internally.

Neil.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse refuses to work due to stdarg.h
Date: Tue, 18 Jan 2005 00:40:15 +0000
Message-ID: <Pine.LNX.4.58.0501171630280.8178 () ppc970 ! osdl ! org>
--------------------


On Mon, 17 Jan 2005, Sam Ravnborg wrote:
> 
> Something like this.
> First cut - it seems to work but rather untested.

Looks good to me. But since you seem to do more testing, I'll just wait 
for that before committing, and yes, it would be good to have a better 
"current_c_file" setup.

Maybe just make that path be another "const char *" as part of "struct 
stream" (initialized once, at stream setup time), and then just do

	includepath[0] = stream->path;

at each include. Instead of the full "strcpy + strrchr" thing.

Bonus points for making it lazy instead (ie initialize "stream->path" to 
NULL, and then have a small helper function to set includepath, something 
like

	static void set_stream_include_path(struct stream *stream)
	{
		const char *path = stream->path;
		if (!path) {
			const char *p = strrchr(stream->name, '/');
			path = "";
			if (p) {
				int len = p - stream->name + 1;
				char *m = malloc(len+1);
				/* This includes the final "/" */
				memcpy(m, stream->name, len);
				m[len] = 0;
				path = m;
			}
			stream->path = path;
		}
		includepath[0] = path;
	}

which should do ok (with a bit of testing, of course, I probably got 
some fencepost error in all those games).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse segfault ===

From: Roland Dreier <roland () topspin ! com>
To: linux-sparse
Subject: sparse segfault
Date: Mon, 20 Jun 2005 03:24:43 +0000
Message-ID: <52vf491zic.fsf () topspin ! com>
--------------------
The following .c file:

	int foo(void)
	{
		return = -1;
	}

causes sparse to seg fault.  Obviously not valid C but I would have
expected sparse to be able to cope with my typo...

gdb gives this traceback:

Program received signal SIGSEGV, Segmentation fault.
0x08057aa9 in linearize_address_gen (ep=0x0, expr=0x0, ad=0xffffd610) at linearize.c:871
warning: Source file is more recent than executable.

871		struct symbol *ctype = expr->ctype;
(gdb) bt
#0  0x08057aa9 in linearize_address_gen (ep=0x0, expr=0x0, ad=0xffffd610)
    at linearize.c:871
#1  0x0805864e in linearize_assignment (ep=0x5556d00c, expr=0x556e800c)
    at linearize.c:1144
#2  0x08059530 in linearize_expression (ep=0x5556d00c, expr=0x556e800c)
    at linearize.c:1540
#3  0x08059fbb in linearize_statement (ep=0x5556d00c, stmt=0x556d8038)
    at linearize.c:1803
#4  0x080596f6 in linearize_compound_statement (ep=0x5556d00c, stmt=0x556d800c)
    at linearize.c:1598
#5  0x0805a30f in linearize_statement (ep=0x5556d00c, stmt=0x556d800c)
    at linearize.c:1882
#6  0x0805a97b in linearize_fn (sym=0x556f800c, base_type=0x556c393c)
    at linearize.c:2048
#7  0x0805ab0f in linearize_symbol (sym=0x80c9898) at linearize.c:2116
#8  0x0804afe0 in check_symbols (list=0x80c9788) at check.c:258
#9  0x0804b037 in main (argc=0, argv=0x0) at check.c:267

Thanks,
  Roland
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse segfault
Date: Mon, 20 Jun 2005 03:57:06 +0000
Message-ID: <Pine.LNX.4.58.0506192056050.2268 () ppc970 ! osdl ! org>
--------------------


On Sun, 19 Jun 2005, Roland Dreier wrote:
>
> The following .c file:
> 
> 	int foo(void)
> 	{
> 		return = -1;
> 	}
> 
> causes sparse to seg fault.  Obviously not valid C but I would have
> expected sparse to be able to cope with my typo...

Thanks, I fixed the SIGSEGV. It still doesn't complain properly about the
syntax error, but that's a separate issue.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse segfault
Date: Mon, 20 Jun 2005 04:11:44 +0000
Message-ID: <Pine.LNX.4.58.0506192109410.2268 () ppc970 ! osdl ! org>
--------------------


On Sun, 19 Jun 2005, Linus Torvalds wrote:
> 
> Thanks, I fixed the SIGSEGV. It still doesn't complain properly about the
> syntax error, but that's a separate issue.

Ok, I fixed that too. Your trivial test program now results in:

	torvalds@ppc970:~/sparse> ./check t.c 
	t.c:3:9: warning: Expected ; at end of statement
	t.c:3:9: warning: got =
	t.c:1:5: warning: symbol 'foo' was not declared. Should it be static?
	t.c:3:2: warning: return with no return value

which might be a bit _too_ much complaining, but at least it doesn't 
silently ignore crud.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse segfaults ===

From: Adrian Bunk <bunk () stusta ! de>
To: linux-sparse
Subject: sparse segfaults
Date: Sat, 19 Nov 2005 08:35:17 +0000
Message-ID: <20051119083517.GJ16060 () stusta ! de>
--------------------
I got the following segfault when running a current sparse against
2.6.15-rc1-mm2:


$ make V=1 C=2 fs/reiser4/plugin/plugin_set.o
make -f scripts/Makefile.build obj=scripts/basic
make -f scripts/Makefile.build obj=scripts
make -f scripts/Makefile.build obj=fs/reiser4/plugin 
fs/reiser4/plugin/plugin_set.o
  sparse -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise  
-D__i386__  -nostdinc -isystem /usr/lib/gcc/i486-linux-gnu/4.0.3/include 
-Wp,-MD,fs/reiser4/plugin/.plugin_set.o.d  -nostdinc -isystem 
/usr/lib/gcc/i486-linux-gnu/4.0.3/include -D__KERNEL__ -Iinclude  
-include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes 
-Wno-trigraphs -fno-strict-aliasing -fno-common -ffreestanding 
-Werror-implicit-function-declaration -Wmissing-prototypes -O2     
-fomit-frame-pointer -pipe -msoft-float -mpreferred-stack-boundary=2 
-fno-unit-at-a-time -march=athlon -Iinclude/asm-i386/mach-default 
-Wdeclaration-after-statement -Wno-pointer-sign    
-DKBUILD_BASENAME=plugin_set -DKBUILD_MODNAME=plugins 
fs/reiser4/plugin/plugin_set.c ;
/bin/sh: line 1: 10137 Segmentation fault      sparse -D__linux__ 
-Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise -D__i386__ -nostdinc 
-isystem /usr/lib/gcc/i486-linux-gnu/4.0.3/include 
-Wp,-MD,fs/reiser4/plugin/.plugin_set.o.d -nostdinc -isystem 
/usr/lib/gcc/i486-linux-gnu/4.0.3/include -D__KERNEL__ -Iinclude 
-include include/linux/autoconf.h -Wall -Wundef -Wstrict-prototypes 
-Wno-trigraphs -fno-strict-aliasing -fno-common -ffreestanding 
-Werror-implicit-function-declaration -Wmissing-prototypes -O2 
-fomit-frame-pointer -pipe -msoft-float -mpreferred-stack-boundary=2 
-fno-unit-at-a-time -march=athlon -Iinclude/asm-i386/mach-default 
-Wdeclaration-after-statement -Wno-pointer-sign 
-DKBUILD_BASENAME=plugin_set -DKBUILD_MODNAME=plugins 
fs/reiser4/plugin/plugin_set.c
make[1]: *** [fs/reiser4/plugin/plugin_set.o] Error 139
make: *** [fs/reiser4/plugin/plugin_set.o] Error 2
$ 


gdb says:


check_case_type (switch_expr=0xb74258cc, case_expr=0xb74258ec) at 
symbol.h:236
236             if (type->type == SYM_NODE)


(gdb) bt
#0  check_case_type (switch_expr=0xb74258cc, case_expr=0xb74258ec)
    at symbol.h:236
#1  0x08053491 in evaluate_switch_statement (stmt=0xb73ef240)
    at evaluate.c:2627
#2  0x08053617 in evaluate_statement (stmt=0xb73ef240) at 
evaluate.c:2676
#3  0x080535bd in evaluate_statement (stmt=0xb73ef164) at 
evaluate.c:2663
#4  0x08052bf5 in evaluate_expression (expr=0xb73d570c) at 
evaluate.c:2345
#5  0x08052b33 in evaluate_expression (expr=0xb73d572c) at 
evaluate.c:2321
#6  0x08053511 in evaluate_statement (stmt=0xb73ef26c) at 
evaluate.c:2642
#7  0x080535bd in evaluate_statement (stmt=0xb73ef138) at 
evaluate.c:2663
#8  0x0805667a in inline_function (expr=0xb73fbdec, sym=0xb741893c)
    at inline.c:508
#9  0x08052838 in evaluate_symbol_call (expr=0xb73fbd4c) at 
evaluate.c:2235
#10 0x08052989 in evaluate_call (expr=0xb73fbd4c) at evaluate.c:2272
#11 0x08052bd4 in evaluate_expression (expr=0xb73fbd4c) at 
evaluate.c:2340
#12 0x08050052 in evaluate_conditional (expr=0xb73fbd4c, iterator=0)
    at evaluate.c:834
#13 0x08052f76 in evaluate_if_statement (stmt=0xb73eec10) at 
evaluate.c:2478
#14 0x080535eb in evaluate_statement (stmt=0xb73eec10) at 
evaluate.c:2670
#15 0x080535bd in evaluate_statement (stmt=0xb73eeb34) at 
evaluate.c:2663
#16 0x08052fda in evaluate_iterator (stmt=0xb73eeadc) at evaluate.c:2488
#17 0x08053601 in evaluate_statement (stmt=0xb73eeadc) at 
evaluate.c:2673
#18 0x080535bd in evaluate_statement (stmt=0xb73eea84) at 
evaluate.c:2663
#19 0x0805667a in inline_function (expr=0xb73fb84c, sym=0xb741c17c)
    at inline.c:508
#20 0x08052838 in evaluate_symbol_call (expr=0xb73fb7ac) at 
evaluate.c:2235
#21 0x08052989 in evaluate_call (expr=0xb73fb7ac) at evaluate.c:2272
#22 0x08052bd4 in evaluate_expression (expr=0xb73fb7ac) at 
evaluate.c:2340
#23 0x08052eac in evaluate_return_expression (stmt=0xb73eea00)
    at evaluate.c:2454
#24 0x080534fe in evaluate_statement (stmt=0xb73eea00) at 
evaluate.c:2639
#25 0x080535bd in evaluate_statement (stmt=0xb73ee9d4) at 
evaluate.c:2663
#26 0x0805667a in inline_function (expr=0xb74072ec, sym=0xb740ea4c)
    at inline.c:508
#27 0x08052838 in evaluate_symbol_call (expr=0xb740724c) at 
evaluate.c:2235
#28 0x08052989 in evaluate_call (expr=0xb740724c) at evaluate.c:2272
#29 0x08052bd4 in evaluate_expression (expr=0xb740724c) at 
evaluate.c:2340
#30 0x08052b0c in evaluate_expression (expr=0xb740720c) at 
evaluate.c:2317
#31 0x08053511 in evaluate_statement (stmt=0xb745a704) at 
evaluate.c:2642
#32 0x080535bd in evaluate_statement (stmt=0xb745a050) at 
evaluate.c:2663
#33 0x08052e05 in evaluate_symbol (sym=0xb741309c) at evaluate.c:2431
#34 0x08052e63 in evaluate_symbol_list (list=0x80f2238) at 
evaluate.c:2445
#35 0x0804e9b8 in sparse (argv=Variable "argv" is not available.
) at lib.c:651
#36 0x0804b20a in main (argc=41, argv=0xbffff624) at check.c:271


cu
Adrian

-- 

       "Is there not promise of rain?" Ling Tan asked suddenly out
        of the darkness. There had been need of rain for many days.
       "Only a promise," Lao Er said.
                                       Pearl S. Buck - Dragon Seed


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse segfaults
Date: Sat, 19 Nov 2005 20:27:26 +0000
Message-ID: <Pine.LNX.4.64.0511191225100.13959 () g5 ! osdl ! org>
--------------------


On Sat, 19 Nov 2005, Adrian Bunk wrote:
>
> I got the following segfault when running a current sparse against
> 2.6.15-rc1-mm2:

Hmm. Does this fix it for you? I don't have reiser4 in any trees I have 
trivial access to, so this patch is totally untested..

		Linus

---
diff --git a/evaluate.c b/evaluate.c
index 23decdb..24acefe 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2603,13 +2603,15 @@ static void check_case_type(struct expre
 	if (!case_expr)
 		return;
 	switch_type = switch_expr->ctype;
-	case_type = case_expr->ctype;
+	case_type = evaluate_expression(case_expr);
 
-	/* Both integer types? */
-	if (is_int_type(switch_type) && is_int_type(case_type))
-		return;
-	if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
-		return;
+	if (case_type && switch_type) {
+		/* Both integer types? */
+		if (is_int_type(switch_type) && is_int_type(case_type))
+			return;
+		if (compatible_restricted_binop(SPECIAL_EQUAL, &switch_expr, &case_expr))
+			return;
+	}
 
 	sparse_error(case_expr->pos, "incompatible types for 'case' statement");
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Adrian Bunk <bunk () stusta ! de>
To: linux-sparse
Subject: Re: sparse segfaults
Date: Sat, 19 Nov 2005 20:38:47 +0000
Message-ID: <20051119203847.GM16060 () stusta ! de>
--------------------
On Sat, Nov 19, 2005 at 12:27:26PM -0800, Linus Torvalds wrote:
> 
> 
> On Sat, 19 Nov 2005, Adrian Bunk wrote:
> >
> > I got the following segfault when running a current sparse against
> > 2.6.15-rc1-mm2:
> 
> Hmm. Does this fix it for you? I don't have reiser4 in any trees I have 
> trivial access to, so this patch is totally untested..

Yes thanks, this fixed it.

> 		Linus
>...

cu
Adrian

-- 

       "Is there not promise of rain?" Ling Tan asked suddenly out
        of the darkness. There had been need of rain for many days.
       "Only a promise," Lao Er said.
                                       Pearl S. Buck - Dragon Seed

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse segfaults
Date: Sat, 19 Nov 2005 20:56:46 +0000
Message-ID: <Pine.LNX.4.64.0511191254520.13959 () g5 ! osdl ! org>
--------------------


On Sat, 19 Nov 2005, Adrian Bunk wrote:

> On Sat, Nov 19, 2005 at 12:27:26PM -0800, Linus Torvalds wrote:
> > 
> > 
> > On Sat, 19 Nov 2005, Adrian Bunk wrote:
> > >
> > > I got the following segfault when running a current sparse against
> > > 2.6.15-rc1-mm2:
> > 
> > Hmm. Does this fix it for you? I don't have reiser4 in any trees I have 
> > trivial access to, so this patch is totally untested..
> 
> Yes thanks, this fixed it.

Can you show what the switch statement in question looks like, since I 
would have _expected_ the evaluation of the statement inside the switch 
to have already evaluated the type of the individual case statements.

It's possible that the real bug is that some expression or statement type 
doesn't fully evaluate its sub-statements..

Or did you get a warning due to a bad type?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Adrian Bunk <bunk () stusta ! de>
To: linux-sparse
Subject: Re: sparse segfaults
Date: Sat, 19 Nov 2005 21:42:11 +0000
Message-ID: <20051119214211.GS16060 () stusta ! de>
--------------------
On Sat, Nov 19, 2005 at 12:56:46PM -0800, Linus Torvalds wrote:
> 
> 
> On Sat, 19 Nov 2005, Adrian Bunk wrote:
> 
> > On Sat, Nov 19, 2005 at 12:27:26PM -0800, Linus Torvalds wrote:
> > > 
> > > 
> > > On Sat, 19 Nov 2005, Adrian Bunk wrote:
> > > >
> > > > I got the following segfault when running a current sparse against
> > > > 2.6.15-rc1-mm2:
> > > 
> > > Hmm. Does this fix it for you? I don't have reiser4 in any trees I have 
> > > trivial access to, so this patch is totally untested..
> > 
> > Yes thanks, this fixed it.
> 
> Can you show what the switch statement in question looks like, since I 
> would have _expected_ the evaluation of the statement inside the switch 
> to have already evaluated the type of the individual case statements.
> 
> It's possible that the real bug is that some expression or statement type 
> doesn't fully evaluate its sub-statements..
> 
> Or did you get a warning due to a bad type?

I've sent the complete messages in my bug report, there was no warning 
before the segfault occured.

There is no switch statement directly in this file, and I've given up 
searching after seeing that one statement in this file was #define'd in 
a header file to expand to more than a dozen functions with over 200 
lines of code...

Please check yourself in a 2.6.15-rc1-mm2 tree.

> 		Linus

cu
Adrian

-- 

       "Is there not promise of rain?" Ling Tan asked suddenly out
        of the darkness. There had been need of rain for many days.
       "Only a promise," Lao Er said.
                                       Pearl S. Buck - Dragon Seed

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse segfaults
Date: Sat, 19 Nov 2005 23:19:36 +0000
Message-ID: <20051119231936.GA17977 () mars ! ravnborg ! org>
--------------------

[I sent Linus the preprocessed version of the relevant file in private
mail - this brings the thread back on sparse ml].

Linus wrote:
> 
> But I don't see quite why that happens - although it definitely happens 
> there, and it only happens when that function is inlined (if it's not 
> inlined, all is well).

Here is a small code sample that provokes the segmentation fault (with
the old sparse - I have not yet tested the fixed version).


static inline __attribute__((always_inline)) int pseq(void)
{
	int a;
	switch(-1) {
	case (sizeof(a)):
	case 0:
		break;
	}
}

void foo(void)
{
	pseq();
}

As you already concluded the error does not show up when not inlined.
Replacing the sizeof() with a function yields a segmentation
fault too.


	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse segfaults
Date: Sat, 19 Nov 2005 23:39:45 +0000
Message-ID: <Pine.LNX.4.64.0511191533550.13959 () g5 ! osdl ! org>
--------------------


On Sun, 20 Nov 2005, Sam Ravnborg wrote:
> 
> Here is a small code sample that provokes the segmentation fault (with
> the old sparse - I have not yet tested the fixed version).

The fixed version is fine, but to debug this, I'm using the appended patch 
which does a graceful warning if the case expression hasn't been 
type-evaluated, and avoids the SIGSEGV.

Now, the _reason_ for that warning is that in evaluate_switch_statement(), 
we do

	...
        evaluate_expression(stmt->switch_expression);
        evaluate_statement(stmt->switch_statement);
	...

and that "evaluate_statement(stmt->switch_statement);" should do type 
evaluation on the statement inside the switch. Which very much includes 
the case-statement, and thus the case expression.

So all case expressions _should_ have been type-evaluated by the time we 
do the loop that does the type comparison of the switch value and the case 
expressions. The appended patch just warns about it, and points to the 
case statement and the switch statement it belongs to.

Interestingly, if you call the inline function multiple times, you only 
get the warning once. Which I think means that we haven't copied the case 
statement expressions in inlining or something similar. It definitely 
feels like an inlining bug, but I've not looked at it any more closely 
(inlining is _complicated_, so I'm not surprised - and we've had bugs like 
that before).

		Linus

---
diff --git a/evaluate.c b/evaluate.c
index 24acefe..499d0a0 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2603,6 +2603,11 @@ static void check_case_type(struct expre
 	if (!case_expr)
 		return;
 	switch_type = switch_expr->ctype;
+
+	if (!case_expr->ctype) {
+		warning(case_expr->pos, "not evaluated yet");
+		info(switch_expr->pos, "from here");
+	}
 	case_type = evaluate_expression(case_expr);
 
 	if (case_type && switch_type) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: check multiple files in the kernel ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse: check multiple files in the kernel
Date: Sun, 27 Nov 2005 09:51:50 +0000
Message-ID: <20051127095150.GA9242 () mars ! ravnborg ! org>
--------------------
On Wed, Oct 19, 2005 at 12:15:55AM +0200, Sam Ravnborg wrote:
> Fist cut of adding support for checking multiple files in the kernel.

Does this do what we want for the kernel?
I assume we still like both the possibilities to run sparse on a single
file "C=1/2" and on all files "C=A".

There is no way to say "sparse all the files in one go but only if files
are changed".

	Sam

> 
> Syntax:
> make C=A
> A for all files.
> 
> So we now have:
> make C=1 - test files that are compiled
> make C=2 - test individual files no matter if build or not
> make C=A - test all files in each dir
> All other options to C= will be ignored.
> 
> It pick up all .o specific flags, but obviously cannot limit them to a
> single file.
> In the non-verbose view is display only filename and not directory. This
> was done to keep noise level down but still it gets ugly.
> Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
> ---
> It has seen only very light testing.
> 
> The output often spill over more than one line.
> Any better ideas welcome.
> 
> Maybe something like:
> CHECK file1.c file2.c file3.c file4.c ...
> ... only printed if there are more files.
> Would that be OK or too dense?
> 
> 	Sam
> 
> diff --git a/scripts/Makefile.build b/scripts/Makefile.build
> index 506e3f3..73761a5 100644
> --- a/scripts/Makefile.build
> +++ b/scripts/Makefile.build
> @@ -85,16 +85,23 @@ __build: $(if $(KBUILD_BUILTIN),$(builti
>  	@:
>  
>  # Linus' kernel sanity checking tool
> -ifneq ($(KBUILD_CHECKSRC),0)
> -  ifeq ($(KBUILD_CHECKSRC),2)
> -    quiet_cmd_force_checksrc = CHECK   $<
> -          cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
> -  else
> -      quiet_cmd_checksrc     = CHECK   $<
> -            cmd_checksrc     = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
> -  endif
> +ifeq ($(KBUILD_CHECKSRC),1)
> +  quiet_cmd_checksrc     = CHECK   $<
> +        cmd_checksrc     = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
> +endif
> +ifeq ($(KBUILD_CHECKSRC),2)
> +  quiet_cmd_force_checksrc = CHECK   $<
> +        cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $< ;
> +endif
> +ifeq ($(KBUILD_CHECKSRC),A)
> +  all-c-files = $(wildcard $(patsubst %.o, %.c, $(real-objs-y) $(real-objs-m)))
> +  all-o-files = $(patsubst %.c, %.o, $(all-c-files))
> +  all-o-flags = $(strip $(foreach o, $(all-o-files), $(CFLAGS_$(notdir $(o)))))
> +  quiet_cmd_sparse-all = CHECK $(notdir $(all-c-files))
> +        cmd_sparse-all = $(CHECK) $(CHECKFLAGS) \
> +                                  $(c_flags) $(all-o-flags) $(all-c-files)
> +  sparse-all = $(call cmd,sparse-all)
>  endif
> -
>  
>  # Compile C sources (.c)
>  # ---------------------------------------------------------------------------
> @@ -256,6 +263,7 @@ cmd_link_o_target = $(if $(strip $(obj-y
>  		      rm -f $@; $(AR) rcs $@)
>  
>  $(builtin-target): $(obj-y) FORCE
> +	$(call sparse-all)
>  	$(call if_changed,link_o_target)
>  
>  targets += $(builtin-target)
> 
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: emitting wrong 'noident' warning ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: sparse: emitting wrong 'noident' warning
Date: Fri, 14 Jan 2005 23:06:29 +0000
Message-ID: <20050114230629.GA15242 () mars ! ravnborg ! org>
--------------------
Hi Linus et al.

When playing with spare I noticed that again it emitted

kernel/audit.c:172:9: warning: unreplaced symbol '<noident>'

A few days ago I reported this as fixed - but apparently I did something
wrong.

The following snippet provokes the same warning:


static inline int fun(void)
{
        static int x = (int) {1};
}
int fun2(void)
{
        fun();
}
int fun3(void)
{
        fun();
}

The variable 'x' needs to be static and the curly braces are needed.
Maybe this has something to do with the bug where the initialisers was
not handled correct?

I have tried firing up gdb on this - but did not manage to find
where to look.
The warning is emitted in inline.c when copying a symbol copy_symbol()

In the codesnippet above copy_symbol is called once for the (int) cast
but only when the second inlie is used in the code. If only one inline
is used copy_symbol is not used for the cast.

If a third inlining is done of fun() the warning is emitted twice.

HTH,
	Sam


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse: emitting wrong 'noident' warning
Date: Sat, 15 Jan 2005 18:19:03 +0000
Message-ID: <Pine.LNX.4.58.0501151010060.2310 () ppc970 ! osdl ! org>
--------------------


On Sat, 15 Jan 2005, Sam Ravnborg wrote:
> 
> When playing with spare I noticed that again it emitted
> 
> kernel/audit.c:172:9: warning: unreplaced symbol '<noident>'
> 
> A few days ago I reported this as fixed - but apparently I did something
> wrong.
> 
> The following snippet provokes the same warning:
> 
> static inline int fun(void)
> {
>         static int x = (int) {1};
> }

Ahhh...

Indeed. The inliner knows that static (or extern) symbols should not be 
replaced, but it does _not_ know that static _initializers_ end up being 
static too.

So what we have is an anonymous node for the initializer, and sparse
hasn't marked it static, so when inlining it we try to replace it, but we
don't have any replacement for it.

This should fix it.. (Only duplicate the initializer if the symbol itself
has been duplicated)

		Linus

----
===== linearize.c 1.49 vs edited =====
--- 1.49/linearize.c	2004-08-20 11:43:58 -07:00
+++ edited/linearize.c	2004-09-04 17:52:44 -07:00
@@ -1114,7 +1114,7 @@
 	}
 }
 
-void pack_basic_blocks(struct basic_block_list **bblist)
+void pack_basic_blocks(struct basic_block *entry, struct basic_block_list **bblist)
 {
 	struct basic_block *bb;
 	struct list_iterator iterator;
@@ -1129,7 +1129,8 @@
 
 		if (!is_branch_goto(jmp=last_instruction(bb->insns)))
 			continue;
-
+		if (bb == entry)
+			continue;
 		target = jmp->bb_true ? jmp->bb_true : jmp->bb_false;
 		if (target == bb)
 			continue;
@@ -1189,7 +1190,7 @@
 				insn->src = result;
 				add_one_insn(ep, pos, insn);
 			}
-			pack_basic_blocks(&ep->bbs);
+			pack_basic_blocks(bb, &ep->bbs);
 			ret_ep = ep;
 		}
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse: emitting wrong 'noident' warning
Date: Sat, 15 Jan 2005 21:05:01 +0000
Message-ID: <20050115210501.GA7081 () mars ! ravnborg ! org>
--------------------
On Sat, Jan 15, 2005 at 10:19:03AM -0800, Linus Torvalds wrote:
> This should fix it.. (Only duplicate the initializer if the symbol itself
> has been duplicated)

Pulled sparse from bkbits - I can confirm it is fixed both for
my test-case and for the kernel.
With defconfig kernel/ is now sparse clean.

But the patch below did not make sense to me - seems like a very old
one?

Anyway - the patch at bkbits looked nice.

	Sam


> ----
> ===== linearize.c 1.49 vs edited =====
> --- 1.49/linearize.c	2004-08-20 11:43:58 -07:00
> +++ edited/linearize.c	2004-09-04 17:52:44 -07:00
> @@ -1114,7 +1114,7 @@
>  	}
>  }
>  
> -void pack_basic_blocks(struct basic_block_list **bblist)
> +void pack_basic_blocks(struct basic_block *entry, struct basic_block_list **bblist)
>  {
>  	struct basic_block *bb;
>  	struct list_iterator iterator;
> @@ -1129,7 +1129,8 @@
>  
>  		if (!is_branch_goto(jmp=last_instruction(bb->insns)))
>  			continue;
> -
> +		if (bb == entry)
> +			continue;
>  		target = jmp->bb_true ? jmp->bb_true : jmp->bb_false;
>  		if (target == bb)
>  			continue;
> @@ -1189,7 +1190,7 @@
>  				insn->src = result;
>  				add_one_insn(ep, pos, insn);
>  			}
> -			pack_basic_blocks(&ep->bbs);
> +			pack_basic_blocks(bb, &ep->bbs);
>  			ret_ep = ep;
>  		}
>  	}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse: emitting wrong 'noident' warning
Date: Sat, 15 Jan 2005 21:56:22 +0000
Message-ID: <Pine.LNX.4.58.0501151355180.8178 () ppc970 ! osdl ! org>
--------------------


On Sat, 15 Jan 2005, Sam Ravnborg wrote:
>
> But the patch below did not make sense to me - seems like a very old
> one?

Duh. I just inserted a "sparse-diff" file, but from the wrong
subdirectory, so it was indeed an old one from last September, not the one
from todat ;)

BK is right,

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: fails to locate stdarg.h ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: Re: sparse: fails to locate stdarg.h
Date: Sun, 16 Jan 2005 12:44:01 +0000
Message-ID: <200501161543.14574.adobriyan () mail ! ru>
--------------------
On Fri, 14 Jan 2005 23:13:57 +0100, Sam Ravnborg wrote:

> Following patch adds support of -isystem to sparse.

...

> ===== lib.c 1.111 vs edited =====
> --- 1.111/lib.c2005-01-07 23:06:23 +01:00
> +++ edited/lib.c2005-01-14 23:11:01 +01:00
> @@ -461,6 +461,12 @@
> if (fd < 0)
> perror(name);
> }
> +else if (*next && !strcmp(arg, "isystem")) {
> +char *path = *++next;
> +if (!path)
> +die("missing argument for -isystem option");
> +add_pre_buffer("#add_include \"%s/\"\n", path);
> +}
> return next;
> }

It screwes checking kernel tree if kernel CC is different from CC sparse was 
built with.

$ make -k C=2 CC=/usr/local/gcc-4.0/bin/gcc

 CHECK  init/main.c
/usr/local/gcc-4.0/lib/gcc/i686-pc-linux-gnu/4.0.0/include/asm/posix_types.h:13:11: 
error: unable to open 'features.h'
make[1]: *** [init/main.o] Error 1

Alexey
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse: fails to locate stdarg.h
Date: Sun, 16 Jan 2005 16:11:46 +0000
Message-ID: <20050116161146.GB3090 () mars ! ravnborg ! org>
--------------------
On Sun, Jan 16, 2005 at 03:43:14PM +0200, Alexey Dobriyan wrote:
> It screwes checking kernel tree if kernel CC is different from CC sparse was 
> built with.
> 
> $ make -k C=2 CC=/usr/local/gcc-4.0/bin/gcc
> 
> ? CHECK ? init/main.c
> /usr/local/gcc-4.0/lib/gcc/i686-pc-linux-gnu/4.0.0/include/asm/posix_types.h:13:11: 
> error: unable to open 'features.h'
> make[1]: *** [init/main.o] Error 1

What's the output of:
/usr/local/gcc-4.0/bin/gcc --print-file-name=include

It smells like a misconfigured gcc - which we hit by this stricter
implmentation.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: Re: sparse: fails to locate stdarg.h
Date: Sun, 16 Jan 2005 16:51:11 +0000
Message-ID: <200501161950.25686.adobriyan () mail ! ru>
--------------------
[Linus isn't CC'ed because osdl.org banned mail.ru]

On Sunday 16 January 2005 18:11, Sam Ravnborg wrote:
> On Sun, Jan 16, 2005 at 03:43:14PM +0200, Alexey Dobriyan wrote:
> > It screwes checking kernel tree if kernel CC is different from CC sparse
> > was built with.
> >
> > $ make -k C=2 CC=/usr/local/gcc-4.0/bin/gcc
> >
> > ? CHECK ? init/main.c
> > /usr/local/gcc-4.0/lib/gcc/i686-pc-linux-gnu/4.0.0/include/asm/posix_type
> >s.h:13:11: error: unable to open 'features.h'
> > make[1]: *** [init/main.o] Error 1
>
> What's the output of:
> /usr/local/gcc-4.0/bin/gcc --print-file-name=include
>
> It smells like a misconfigured gcc - which we hit by this stricter
> implmentation.

$ /usr/local/gcc-4.0/bin/gcc --print-file-name=include
/usr/local/gcc-4.0/lib/gcc/i686-pc-linux-gnu/4.0.0/include

I moved ^^^^^^^^^/asm/posix_types.h and everything is ok now. Thanks.

	Alexey
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: faulty: unexpected initializer expression (22 0) ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse: faulty: unexpected initializer expression (22 0)
Date: Mon, 10 Jan 2005 01:50:24 +0000
Message-ID: <Pine.LNX.4.58.0501091744430.2373 () ppc970 ! osdl ! org>
--------------------


On Sun, 9 Jan 2005, Sam Ravnborg wrote:

> When copiling kernel with _latest_ sparse I get a warning in kernel/fork.c:
> warning: unexpected initializer expression
> 
> I have narrowed it down to the following code snippet:

Hmm. "expand_pos_expression()" should have "flattened" it all out, and an 
EXPR_POS should no longer contain any EXPR_INITIALIZERs. See 
"expand_pos_expression()" in expand.c.

But clearly your example _does_ have an EXPR_INITIALIZER inside the
EXPR_POS, since the call trace is:

	#1  0x1000a048 in linearize_expression (ep=0xf7fe200c, expr=0xf7fa60d8) at linearize.c:1508
	#2  0x10009ca0 in linearize_position (ep=0xf7fe200c, pos=0xf7fa60b0, ad=0xffffe5d8) at linearize.c:1398
	#3  0x10009da0 in linearize_initializer (ep=0xf7fe200c, initializer=0x0, ad=0x0) at linearize.c:1418
	#4  0x10009d7c in linearize_initializer (ep=0xf7fe200c, initializer=0x10094940, ad=0xffffe5d8) at linearize.c:1413

I'm clearly missing something. I suspect I should expand the nested 
expression _first_ in "expand_pos_expression()", and then re-expand it if 
I do one of the simplifications. Hmm.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: include path handling gcc compatible ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: sparse: include path handling gcc compatible
Date: Tue, 18 Jan 2005 20:37:40 +0000
Message-ID: <20050118203740.GA18458 () mars ! ravnborg ! org>
--------------------
Hi Linus - please apply.
I had mixed up -isystem, and -dirafter in my original explanation.
They add a path in either end of the chain - implementation is OK.
Added a bit of a comment also - may be helpful for the next poor soul to
look into this area.



Search include paths in same order as gcc does.
In other words search directories specified with -I before system
directories.

This fixes a bug reported by a few persons after the kernel switched
over to use -isystem to specify where to find compiler specific include files.

Sparse now supports the following include path relevant options:
-I dir		Add dir to list of directories to search for. Search dir
		before system dirs. USed for both <> and "" includes.
-I-		Split include path - previous -I dir paths only used for
		include "".
		Also disable searching same dir as input file.
-isystem dir	Add dir first in row of system dirs to search.
-dirafter dir	Add dir in end of system dirs to search.
-nostdinc	Discard all defined system dirs

The -iwithprefix, -iprefix and -iwithprefixbefore options are not not
supported and silently ignored. gcc discourage use of these options.

	Sam
	
===== lib.c 1.112 vs edited =====
--- 1.112/lib.c	2005-01-14 23:11:01 +01:00
+++ edited/lib.c	2005-01-18 21:21:17 +01:00
@@ -428,16 +428,8 @@
 
 	switch (arg[1]) {
 	case '-':
-		/* Explaining '-I-' with a google search:
-		 *
-		 *	"Specifying -I after -I- searches for #include directories.
-		 *	 If -I- is specified before, it searches for #include "file"
-		 *	 and not #include ."
-		 *
-		 * Which didn't explain it at all to me. Maybe somebody else can
-		 * explain it properly. We ignore it for now.
-		 */
-		return next;
+		add_pre_buffer("#split_include\n");
+		break;
 
 	case '\0':	/* Plain "-I" */
 		path = *++next;
@@ -465,7 +457,7 @@
 		char *path = *++next;
 		if (!path)
 			die("missing argument for -isystem option");
-		add_pre_buffer("#add_include \"%s/\"\n", path);
+		add_pre_buffer("#add_isystem \"%s/\"\n", path);
 	}
 	return next;
 }
@@ -559,6 +551,15 @@
 	return next;
 }
 
+char **handle_dirafter(char *arg, char **next)
+{
+	char *path = *++next;
+	if (!path)
+		die("missing argument for -dirafter option");
+	add_pre_buffer("#add_dirafter \"%s/\"\n", path);
+	return next;
+}
+
 struct switches {
 	const char *name;
 	char **(*fn)(char *, char**);
@@ -569,6 +570,7 @@
 	char **rc = next;
 	static struct switches cmd[] = {
 		{ "nostdinc", handle_nostdinc },
+		{ "dirafter", handle_dirafter },
 		{ NULL, NULL }
 	};
 	struct switches *s;
===== pre-process.c 1.123 vs edited =====
--- 1.123/pre-process.c	2004-12-09 19:55:29 +01:00
+++ edited/pre-process.c	2005-01-18 21:20:49 +01:00
@@ -38,14 +38,16 @@
 
 #define INCLUDEPATHS 300
 const char *includepath[INCLUDEPATHS+1] = {
+	"",
 	"/usr/include",
 	"/usr/local/include",
 	GCC_INTERNAL_INCLUDE,
 	NULL
 };
 
-static const char **sys_includepath = includepath + 0;
-static const char **gcc_includepath = includepath + 2;
+static const char **quote_includepath = includepath;
+static const char **angle_includepath = includepath + 1;
+static const char **sys_includepath   = includepath + 1;
 
 #define MARK_STREAM_NONCONST(pos) do {					\
 	if (stream->constant != CONSTANT_FILE_NOPE) {			\
@@ -613,9 +615,62 @@
 	return 0;
 }
 
-static int try_include(const char *path, int plen, const char *filename, int flen, struct token **where, const char **next_path)
+/* Hande include of header files.
+ * The relevant options are made compatible with gcc. The only options that
+ * are not supported is -withprefix and friends.
+ *
+ * Three set of include paths are known:
+ * quote_includepath:	Path to search when using #include "file.h"
+ * angle_includepath:	Path to search when using #include <file.h>
+ * sys_includepath:	Built-in include paths
+ *
+ * The above is implmented as one array with pointes
+ *                         +--------------+
+ * quote_includepath --->  |              |
+ *                         +--------------+
+ *                         |              |
+ *                         +--------------+
+ * angle_includepath --->  |              |
+ *                         +--------------+
+ * sys_includepath   --->  |              |
+ *                         +--------------+
+ *                         |              |
+ *                         +--------------+
+ *
+ * -I dir insert dir just before sys_includepath and move the rest
+ * -I- makes all dirs specified with -I before to quote dirs only and
+ *   angle_includepath is set equal to sys_includepath.
+ * -nostdinc removes all sys dirs be storing NULL in entry pointed
+ *   to by * sys_includepath. Note this will reset all dirs built-in and added
+ *   before -nostdinc by -isystem and -dirafter
+ * -isystem dir adds dir where sys_includepath points adding this dir as
+ *   first systemdir
+ * -dirafter dir adds dir to the end of the list
+ **/
+
+static void set_stream_include_path(struct stream *stream)
+{
+	const char *path = stream->path;
+	if (!path) {
+		const char *p = strrchr(stream->name, '/');
+		path = "";
+		if (p) {
+			int len = p - stream->name + 1;
+			char *m = malloc(len+1);
+			/* This includes the final "/" */
+			memcpy(m, stream->name, len);
+			m[len] = 0;
+			path = m;
+		}
+		stream->path = path;
+	}
+	includepath[0] = path;
+}
+
+static int try_include(const char *path, const char *filename, int flen, struct token **where, const char **next_path)
 {
 	int fd;
+	int plen = strlen(path);
 	static char fullname[PATH_MAX];
 
 	memcpy(fullname, path, plen);
@@ -642,13 +697,12 @@
 	const char *path;
 
 	while ((path = *pptr++) != NULL) {
-		if (!try_include(path, strlen(path), filename, flen, list, pptr))
+		if (!try_include(path, filename, flen, list, pptr))
 			continue;
 		return 1;
 	}
 	return 0;
 }
-	
 
 static void do_include(int local, struct stream *stream, struct token **list, struct token *token, const char *filename, const char **path)
 {
@@ -656,24 +710,17 @@
 
 	/* Absolute path? */
 	if (filename[0] == '/') {
-		if (try_include("", 0, filename, flen, list, includepath))
+		if (try_include("", filename, flen, list, includepath))
 			return;
 		goto out;
 	}
 
-	/* Same directory as current stream? */
-	if (local) {
-		const char *path;
-		char *slash;
-		int plen;
-
-		path = stream->name;
-		slash = strrchr(path, '/');
-		plen = slash ? slash - path : 0;
+	/* Dir of inputfile is first dir to search for quoted includes */
+	set_stream_include_path(stream);
 
-		if (try_include(path, plen, filename, flen, list, includepath))
-			return;
-	}
+	if (!path)
+		/* Do not search quote include if <> is in use */
+		path = local ? quote_includepath : angle_includepath;
 
 	/* Check the standard include paths.. */
 	if (do_include_path(path, list, token, filename, flen))
@@ -723,7 +770,7 @@
 
 static int handle_include(struct stream *stream, struct token **list, struct token *token)
 {
-	return handle_include_path(stream, list, token, includepath);
+	return handle_include_path(stream, list, token, NULL);
 }
 
 static int handle_include_next(struct stream *stream, struct token **list, struct token *token)
@@ -1328,8 +1375,6 @@
 
 static int handle_nostdinc(struct stream *stream, struct token **line, struct token *token)
 {
-	int stdinc;
-
 	if (false_nesting)
 		return free_preprocessor_line(token);
 
@@ -1337,22 +1382,11 @@
 	 * Do we have any non-system includes?
 	 * Clear them out if so..
 	 */
-	stdinc = gcc_includepath - sys_includepath;
-	if (stdinc) {
-		const char **src = gcc_includepath;
-		const char **dst = sys_includepath;
-		for (;;) {
-			if (!(*dst = *src))
-				break;
-			dst++;
-			src++;
-		}
-		gcc_includepath -= stdinc;
-	}
+	*sys_includepath = NULL;
 	return free_preprocessor_line(token);
 }
 
-static void add_path_entry(struct token *token, const char *path)
+static void add_path_entry(struct token *token, const char *path, const char ***where, const char **new_path)
 {
 	const char **dst;
 	const char *next;
@@ -1361,13 +1395,19 @@
 	if (includepath[INCLUDEPATHS-2])
 		error_die(token->pos, "too many include path entries");
 
+	/* check that this is not a duplicate */
+	dst = includepath;
+	while (*dst) {
+		if (strcmp(*dst, path) == 0)
+			return;
+		dst++;
+	}
 	next = path;
-	dst = sys_includepath;
-	sys_includepath++;
-	gcc_includepath++;
+	dst = *where;
+	*where = new_path;
 
 	/*
-	 * Move them all up starting at "sys_includepath",
+	 * Move them all up starting at dst,
 	 * insert the new entry..
 	 */
 	for (;;) {
@@ -1390,10 +1430,77 @@
 			warning(token->pos, "expected path string");
 			return 1;
 		}
-		add_path_entry(token, token->string->data);
+		add_path_entry(token, token->string->data, &sys_includepath, sys_includepath + 1);
+	}
+}
+
+static int handle_add_isystem(struct stream *stream, struct token **line, struct token *token)
+{
+	for (;;) {
+		token = token->next;
+		if (eof_token(token))
+			return 1;
+		if (token_type(token) != TOKEN_STRING) {
+			warning(token->pos, "expected path string");
+			return 1;
+		}
+		add_path_entry(token, token->string->data, &sys_includepath, sys_includepath);
+	}
+}
+
+/* Add to end on includepath list - no pointer updates */
+static void add_dirafter_entry(struct token *token, const char *path)
+{
+	const char **dst = includepath;
+
+	/* Need one free entry.. */
+	if (includepath[INCLUDEPATHS-2])
+		error_die(token->pos, "too many include path entries");
+
+	/* Add to the end */
+	while (*dst)
+		dst++;
+	*dst = path;
+	dst++;
+	*dst = NULL;
+}
+
+static int handle_add_dirafter(struct stream *stream, struct token **line, struct token *token)
+{
+	for (;;) {
+		token = token->next;
+		if (eof_token(token))
+			return 1;
+		if (token_type(token) != TOKEN_STRING) {
+			warning(token->pos, "expected path string");
+			return 1;
+		}
+		add_dirafter_entry(token, token->string->data);
 	}
 }
 
+static int handle_split_include(struct stream *stream, struct token **line, struct token *token)
+{
+	if (false_nesting)
+		return free_preprocessor_line(token);
+
+	/*
+	 * -I-
+	 *  From info gcc:
+	 *  Split the include path.  Any directories specified with `-I'
+	 *  options before `-I-' are searched only for headers requested with
+	 *  `#include "FILE"'; they are not searched for `#include <FILE>'.
+	 *  If additional directories are specified with `-I' options after
+	 *  the `-I-', those directories are searched for all `#include'
+	 *  directives.
+	 *  In addition, `-I-' inhibits the use of the directory of the current
+	 *  file directory as the first search directory for `#include "FILE"'.
+	 */
+	quote_includepath = includepath+1;
+	angle_includepath = sys_includepath;
+	return free_preprocessor_line(token);
+}
+
 /*
  * We replace "#pragma xxx" with "__pragma__" in the token
  * stream. Just as an example.
@@ -1453,8 +1560,11 @@
 		{ "line",	handle_line },
 
 		// our internal preprocessor tokens
-		{ "nostdinc",	handle_nostdinc },
-		{ "add_include", handle_add_include },
+		{ "nostdinc",	   handle_nostdinc },
+		{ "add_include",   handle_add_include },
+		{ "add_isystem",   handle_add_isystem },
+		{ "add_dirafter",  handle_add_dirafter },
+		{ "split_include", handle_split_include },
 	};
 
 	for (i = 0; i < (sizeof (handlers) / sizeof (handlers[0])); i++) {
===== token.h 1.50 vs edited =====
--- 1.50/token.h	2004-12-09 19:55:29 +01:00
+++ edited/token.h	2005-01-18 20:24:47 +01:00
@@ -35,6 +35,7 @@
 struct stream {
 	int fd;
 	const char *name;
+	const char *path;    // inputfile path - see set_stream_include_path()
 	const char **next_path;
 
 	/* Use these to check for "already parsed" */
===== tokenize.c 1.64 vs edited =====
--- 1.64/tokenize.c	2004-12-09 19:55:29 +01:00
+++ edited/tokenize.c	2005-01-18 20:26:14 +01:00
@@ -185,6 +185,7 @@
 	current->name = name;
 	current->fd = fd;
 	current->next_path = next_path;
+	current->path = NULL;
 	current->constant = CONSTANT_FILE_MAYBE;
 	input_stream_nr = stream+1;
 	return stream;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: invalid access past the end of 'unused' ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse: invalid access past the end of 'unused'
Date: Sat, 15 Jan 2005 22:40:36 +0000
Message-ID: <Pine.LNX.4.58.0501151436210.8178 () ppc970 ! osdl ! org>
--------------------


On Sat, 15 Jan 2005, Sam Ravnborg wrote:
>
> In several cases sparse complains about:
> invalid access pastthe end of 'xxx'
> 
> Examples are in arch/i386/kernel/signal.c, ioport.c
> The warning is correct but a bit annoying.

Hmm.. I actually added the warning after we had a bug where that warning 
would have saved us. So the warning literally does show bugs, and I think 
it's very valid.

And there _are_ ways of annotating it properly:

> The following code snippet make sparse emit the same warning:
> 
> struct big
> {
> 	long a;
> 	long b;
> };
> 
> struct big fun(long a)
> {
> 	struct big *p = (struct big *) &a;
> 	return *p;
> }
> 
> The pattern above is used to play tricks with the stack frame - so the
> code in question is OK and the warning is correct.
> Are there any way to quiet sparse without uglifying the code (too much)?

You can fix it by hiding the pointer, the same way we do RELOC_HIDE() in
<linux/compiler-gcc.h>. For basically the same reasons - gcc does 
something similar for static symbols only.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse: invalid access past the end of 'unused'
Date: Sat, 15 Jan 2005 22:50:23 +0000
Message-ID: <Pine.LNX.4.58.0501151440470.8178 () ppc970 ! osdl ! org>
--------------------


On Sat, 15 Jan 2005, Linus Torvalds wrote:
> 
> You can fix it by hiding the pointer, the same way we do RELOC_HIDE() in
> <linux/compiler-gcc.h>. For basically the same reasons - gcc does 
> something similar for static symbols only.

The empty asm trick (asm("")) may be a bit of an overkill, btw. There are
alternatives. Sparse may be pretty good at doign CSE etc these days, which
is why doing various syntactic changes (casts and offsets in different
places) doesn't help one whit, but it's still all very much local.

So to take your example:

	struct big
	{
	        long a;
	        long b;
	};

	struct big fun(long a)
	{
	        struct big *p = (struct big *) &a;
	        return *p;
	}

you can also add an extra level of indirection, and do

	struct big {
		long a;
		long b;
	};

	struct big fun2(struct big *p)
	{
		return *p;
	}

	struct big fun(long a)
	{
		return fun2((struct big *)&a);
	}

and sparse won't complain, because now the violation is no longer locally 
visible.

Of course, if you make "fun2()" be inline, now sparse will see the illegal 
access again, so..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: warning: call with no type! (kcalloc) ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: warning: call with no type! (kcalloc)
Date: Wed, 16 Feb 2005 04:42:58 +0000
Message-ID: <4212CF52.5040509 () osdl ! org>
--------------------
In 2.6.11-rc4, any idea what these mean, what causes them?
They are all kcalloc() calls.

sound/pci/emu10k1/emufx.c:1004:18: warning: call with no type!
sound/pci/emu10k1/emufx.c:1459:25: warning: call with no type!
sound/pci/emu10k1/emufx.c:1460:14: warning: call with no type!

Thanks,
-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: warning: call with no type! (kcalloc)
Date: Wed, 16 Feb 2005 15:40:44 +0000
Message-ID: <Pine.LNX.4.58.0502160735250.2383 () ppc970 ! osdl ! org>
--------------------


On Tue, 15 Feb 2005, Randy.Dunlap wrote:
>
> In 2.6.11-rc4, any idea what these mean, what causes them?
> They are all kcalloc() calls.

Tends to imply that something wasn't declared, or was declared with no 
explicit type.  Alternatively, it was parsed as a call, but type 
evaluation failed for the call for some other reason (maybe the arguments 
couldn't be evaluated).

If it wasn't declared (or some other error happened during evaluation),
you should see a warning about undefined symbol too. Strange.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: x86_64: use UL on TASK_SIZE ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: x86_64: use UL on TASK_SIZE
Date: Sun, 23 Jan 2005 19:13:05 +0000
Message-ID: <Pine.LNX.4.58.0501231110130.4191 () ppc970 ! osdl ! org>
--------------------


On Sun, 23 Jan 2005, Randy.Dunlap wrote:
>
> I had proposed a kernel patch to TASK_SIZE on x86_64 to
> eliminate 3,214 (!) sparse warnings in 2.6.11-rc2, but
> Andi thinks this is a sparse (data type) bug.  Comments?

It's not a sparse bug - sparse correctly notices that the constant is
"long", and it very much on purpose warns about it. A lot of people don't
know what the conversion rules for big constants are (they are _different_
from all other conversion rules, and as an example, hex constants act
differently from decimal constants).

So the warning is the same kind of warning as "don't use assignments in 
logical expression" - the code isn't wrong per se, but the code is 
definitely open to surprising behaviour.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-sparse
Subject: Re: x86_64: use UL on TASK_SIZE
Date: Sun, 23 Jan 2005 19:21:11 +0000
Message-ID: <20050123192110.GC6784 () wotan ! suse ! de>
--------------------
On Sun, Jan 23, 2005 at 11:13:05AM -0800, Linus Torvalds wrote:
> 
> 
> On Sun, 23 Jan 2005, Randy.Dunlap wrote:
> >
> > I had proposed a kernel patch to TASK_SIZE on x86_64 to
> > eliminate 3,214 (!) sparse warnings in 2.6.11-rc2, but
> > Andi thinks this is a sparse (data type) bug.  Comments?
> 
> It's not a sparse bug - sparse correctly notices that the constant is
> "long", and it very much on purpose warns about it. A lot of people don't
> know what the conversion rules for big constants are (they are _different_
> from all other conversion rules, and as an example, hex constants act
> differently from decimal constants).
> 
> So the warning is the same kind of warning as "don't use assignments in 
> logical expression" - the code isn't wrong per se, but the code is 
> definitely open to surprising behaviour.

Not sure what surprising behaviour you mean - it should be clear
to everybody that 0x8000000000000 can only be a 64bit or long long or
long on 64bit constant.

I doubt there is significantconfusion even with newbie C programmers about this.

Perhaps you mean the signed/unsigned promotion. I can see this being
a trap for some people, but how about only warning about this, but
not when using clear >32bit constants? 

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: x86_64: use UL on TASK_SIZE
Date: Sun, 23 Jan 2005 20:09:02 +0000
Message-ID: <Pine.LNX.4.58.0501231159310.4191 () ppc970 ! osdl ! org>
--------------------


On Sun, 23 Jan 2005, Andi Kleen wrote:
> 
> Not sure what surprising behaviour you mean - it should be clear
> to everybody that 0x8000000000000 can only be a 64bit or long long or
> long on 64bit constant.

If you count the zeroes, yes. Me, if it's more than 5 or so digits, I have 
a hard time distinguishing them without thinking about it.

And what about a number that looks very similar: 0x80000000. What do you
think that one is? Or the same number written a different way: 2147483648.

Hint: one of them is "long". The other is not. One of them
is unsigned, the other is not.

In fact, on a 32-bit machine, the types of those two _differ_ between C90
and C99. Can you tell me how.

And don't tell me you can count zeroes without thinking about it. A week
ago, there was a bug between because a 0xffffe000 was written as
0xfffe000. And that's just a matter of 3 vs 4 "f"'s.

> I doubt there is significantconfusion even with newbie C programmers about this.
> 
> Perhaps you mean the signed/unsigned promotion. I can see this being
> a trap for some people, but how about only warning about this, but
> not when using clear >32bit constants? 

If it's so clearly a >32bit constant, why not just make it explicit? 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: x86_64: use UL on TASK_SIZE
Date: Sun, 23 Jan 2005 20:18:59 +0000
Message-ID: <Pine.LNX.4.58.0501231213050.4191 () ppc970 ! osdl ! org>
--------------------


On Sun, 23 Jan 2005, Linus Torvalds wrote:
> 
> And what about a number that looks very similar: 0x80000000. What do you
> think that one is? Or the same number written a different way: 2147483648.

Btw, you can get real differences from this. It's extremely uncommon, but 
try it:

	#define A 0x80000000
	#define B 2147483648

	int a(void)
	{
		return A == B;
	}

	int b(void)
	{
		return A+A == B+B;
	}

and see how one of them is false in 64-bits, even though the numbers are
"the same". Things like this can happen with numbers that are used in 
macros.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: x86_64: use UL on TASK_SIZE
Date: Sun, 23 Jan 2005 20:40:21 +0000
Message-ID: <41F40BB5.9010408 () numba-tu ! com>
--------------------
Linus Torvalds wrote:

>On Sun, 23 Jan 2005, Andi Kleen wrote:
>  
>
>>Not sure what surprising behaviour you mean - it should be clear
>>to everybody that 0x8000000000000 can only be a 64bit or long long or
>>long on 64bit constant.
>>    
>>
>
>If you count the zeroes, yes. Me, if it's more than 5 or so digits, I have 
>a hard time distinguishing them without thinking about it.
>  
>
Does C99 allow underscores in numbers?  I can't read the above number 
without rewriting it as 0x8_0000_0000_0000

Tommy


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-sparse
Subject: Re: x86_64: use UL on TASK_SIZE
Date: Mon, 24 Jan 2005 05:53:51 +0000
Message-ID: <20050124055351.GA9752 () wotan ! suse ! de>
--------------------
> Does C99 allow underscores in numbers?  I can't read the above number 
> without rewriting it as 0x8_0000_0000_0000

No, it doesn't, although I'd agree it would be an useful extension.

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: x86_64: use UL on TASK_SIZE
Date: Mon, 24 Jan 2005 16:08:25 +0000
Message-ID: <Pine.LNX.4.58.0501240807010.4191 () ppc970 ! osdl ! org>
--------------------


On Mon, 24 Jan 2005, Andi Kleen wrote:
>
> > Does C99 allow underscores in numbers?  I can't read the above number 
> > without rewriting it as 0x8_0000_0000_0000
> 
> No, it doesn't, although I'd agree it would be an useful extension.

Sparse used to, exactly because of this. But since we can't use that
syntax anyway with gcc, and Al worked on making the preprocessor do the
right thing with various test-cases, it got removed.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

