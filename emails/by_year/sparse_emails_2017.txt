--- Emails for Year 2017 ---

=== Thread: [No Subject] ===

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
section gets executed. From the time stamp point of view, it is not.

>
> Another "problem" with the current approach is that version.h is
> generated synchronously and so it is not parallelized as it should.
> (IMHO doesn't matter much because build time is short enough, but IMHO
> still a good hint that the construct is broken.)

That is not a problem at all. I consider version.h at the bottom of
the dependency chain, so there is no paralleled when every body
depend on it.

The most common case, the version.h does not need to get
updated.

>
> Do you still think that after the failure reported above?

I think that failure is "user error". Should not try to mix "clean"
with other targets. Nothing good can come out of it.

>> Then there is another thing I consider slightly unclean.
>> The check rules will optionally update another target "version.h" withou=
t
>> specificity in its rules.
>
> I don't understand that.
>
>> We can use order only rules for check target. The whole thing seems
>> gets more complicated than it needs to.

The conflicting view is version.h gets updated or not.
I think the cleaner way to do it is some thing like:

check_version:
             <update version.h only if needed>

version.h: | check_version

Because I don't plan to support mixing clean vs
other targets. I think using $(MAKECMDGOALS)
is simpler and faster, no need to execute external
shells for the common case.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "miteshriya" <emiko () izumiya-nzk ! co ! jp>
To: linux-sparse
Subject: 
Date: Sun, 23 Jul 2017 23:48:18 +0000
Message-ID: <2gbqnpp4d8k1ducban1e9cz8.15008536982 () email ! android ! com>
--------------------
aGkgTGludXgNCg0KaHR0cDovL21ubWZpYmVycy5jb20vcXVlc3Rpb25uYWlyZS5waHA/ZmFzdGVy
PWZ2YW0ybjc0OTJtDQoNCg0KDQpSZWdhcmRzDQpNaXRlc2hyaXlh

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh Shah" <mpshah () gmail ! com>
To: linux-sparse
Subject: 
Date: Sun, 19 Nov 2017 20:07:00 +0000
Message-ID: <D2F3E6CC-2488-47BB-CB2F-BAA5B1C0532F () gdou ! edu ! cn>
--------------------
Salutations Linux


http://bit.ly/2ATC9sN




Mitesh Shah

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: =?utf-8?q?Spende_von_=E2=82=AC_3=2E400=2E000=2C00_EUR?= ===

From: foundation () gmail ! com
To: linux-sparse
Subject: =?utf-8?q?Spende_von_=E2=82=AC_3=2E400=2E000=2C00_EUR?=
Date: Sun, 31 Dec 2017 22:10:08 +0000
Message-ID: <20171231223057.782DE27056D3 () wsbmail01 ! wsb ! wroclaw ! pl>
--------------------
Hallo, ich Roy Cockrum, 58, aus Knoxville, Tennessee Vereinigte Staaten von Amerika, du hast eine WohltÃ¤tigkeitsspende von â¬ 3.400.000,00 EUR, ich gewann die America Lotterie in Amerika im Wert von $ 259,9 Millionen, und ich gebe einen Teil davon Zu fÃ¼nf glÃ¼cklichen Leuten und WohltÃ¤tigkeitshÃ¤usern in GelÃ¼bde, um die Armut vor dieser Welt zu beseitigen, ich kÃ¤mpfe gegen die Armut. Kontaktieren Sie mich fÃ¼r weitere Details: roycockrumpovertyfoundation@gmail.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Bug#873508: sparse test failures on ppc32le (and other not so common archs) ===

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: Re: Bug#873508: sparse test failures on ppc32le (and other not so common archs)
Date: Thu, 21 Sep 2017 18:58:23 +0000
Message-ID: <20170921185823.5fnxchdowq5krxy3 () taurus ! defre ! kleine-koenig ! org>
--------------------

--3us2cpllse3iam2r
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

Control: clone 873508 -1
Control: retitle -1 Please use cgcc to check hosted C code instead of sparse
Control: severity -1 normal
Control: reassign -1 horst

On Fri, Sep 01, 2017 at 09:46:44AM +0200, Uwe Kleine-K=F6nig wrote:
> @anarcat: Given that cgcc seems to work, would you agree to apply the
> following patch to horst:
>=20
> diff --git a/Makefile b/Makefile
> index 4f924fa..d563652 100644
> --- a/Makefile
> +++ b/Makefile
> @@ -110,7 +110,7 @@ $(NAME): $(OBJS)
>  $(OBJS): .buildflags
> =20
>  check:
> -	sparse $(CFLAGS) *.[ch]
> +	cgcc -no-compile $(CFLAGS) *.[ch]
> =20
>  clean:
>  	-rm -f *.o radiotap/*.o *~
>=20

In the meantime I learned from upstream that sparse is not expected to
grok arbitrary hosted code. For that it is needed to use the cgcc
wrapper to handle the required cpp symbols. That it works on some
architectures with plain sparse is mostly luck.

I still expect some platforms to fail with the wrapper, too, because
cgcc doesn't know about all platforms yet. But I intend to upload a new
sparse package soon that includes a build time check for that, and the
respective fixes are easy.

> and downgrade the bug to "important"? That would be a compromise that
> buys us a bit of time.

I'd say sparse failing on hosted code isn't "important", but cgcc should
have all necessary definitions for Debian platforms. So I'm keeping this
bug at important and intend to close it once all platforms are known to
it.

Best regards
Uwe

--3us2cpllse3iam2r
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQEzBAABCgAdFiEEfnIqFpAYrP8+dKQLwfwUeK3K7AkFAlnEC8sACgkQwfwUeK3K
7Algrgf+NdflGLzJ2yt74LlEtKUJoSUJnBUm7HuZZXHUQ2AO4DqC7ZO0WvkIwv4j
soZVe5RCwmR97h4d1I2r0kEYqtVuM1qXW6uQgUXR/gRBsrYee0LfzhqlWMZ8y8Gk
96foK+f//z45pJVPGyL5leaX7UJmBZXrSvpAy6RG+FQJwQV6TwuONcS+1y0MG4j+
8dFRk1rLfhLVUBP0hC4naU3zfr5suJiL0t5DxzSqnLCSNz0NKC0gv7hdEfzkRhJH
jAQeSx97HyqkLJ89F39Bv36T8ZZS5PmPfX+plKmnlty9r1uD/M/uVUG4jiOY/jso
uqBVSe49SnOVVwOw6BWtrJo51bBQDw==
=8JvN
-----END PGP SIGNATURE-----

--3us2cpllse3iam2r--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: Re: Bug#873508: sparse test failures on ppc32le (and other not so common archs)
Date: Wed, 27 Sep 2017 08:00:07 +0000
Message-ID: <20170927080007.jz2vfe4ekjjowkbe () taurus ! defre ! kleine-koenig ! org>
--------------------

--2hb4smhc5jdd3gp7
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

Hello,

On Tue, Sep 26, 2017 at 08:11:01PM +0200, Uwe Kleine-K=F6nig wrote:
> And ppc64 and x32 need the respective cpp defines added I think. If
> noone beats me to it, I will look into the latter at least during the
> next few days.

Looking at ppc64, the following fixes the build:=20

diff --git a/cgcc b/cgcc
index a8d7b4f217fe..a1c02899c623 100755
--- a/cgcc
+++ b/cgcc
@@ -286,7 +286,7 @@ sub add_specs {
     } elsif ($spec eq 'ppc64') {
 	return (' -D__powerpc__=3D1 -D__PPC__=3D1 -D_STRING_ARCH_unaligned=3D1' .
 		' -D__powerpc64__=3D1 -D__PPC64__=3D1' .
-		' -D_CALL_ELF=3D2' .
+		' -D_CALL_ELF=3D1' .
 		' -m64' .
 		&float_types (1, 1, 21, [24,8], [53,11], [113,15]));
     } elsif ($spec eq 's390x') {

I wonder if that could be right. Luc, you added =3D2 in
e0306fe0b725af6e2e7ff59d7f0d99c96315791a, maybe you can comment?

Best regards
Uwe

--2hb4smhc5jdd3gp7
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQEzBAABCgAdFiEEfnIqFpAYrP8+dKQLwfwUeK3K7AkFAlnLWoQACgkQwfwUeK3K
7Alekgf/dW4RbMhVlzCDAIEjGL6YodklVRQcazc4KaOn9pezEpFC1it+Aq3F23XR
Ha0qO8Cn7INhL10z5ZxPBqF3RWsY4RDMGdsanY/vUCyFWzlFgnEt1nXoQBK8z7H1
sXx8cAd4Za1Z/EdzwGTaOAcSOnGQUO6phwmuUDjtbHWQ5e94kopN1db1jHHI7nXW
Nh4tCs0fjBvwINvtnDBTB0mirszTAGS9eBct2s06+Ug1XwTWwo2PzNbtR07Fj4Tj
nV+3U1qh7IWi3jjkhylIToCVvbt2TSl+Ugqpg3hGYUfT0tVa4U5tOKxgJDt4U1XL
DzfJONYLe+ZaGYNFf8EXDQbNZIJxjA==
=vq7E
-----END PGP SIGNATURE-----

--2hb4smhc5jdd3gp7--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Bug#873508: sparse test failures on ppc32le (and other not so common archs)
Date: Wed, 27 Sep 2017 08:40:55 +0000
Message-ID: <CAExDi1R4cFouc2YmCv6dfn2cKqWErN7YQ1r-_Caj9K1s_yH90A () mail ! gmail ! com>
--------------------
On Wed, Sep 27, 2017 at 10:00 AM, Uwe Kleine-K=C3=B6nig
<uwe@kleine-koenig.org> wrote:
> Hello,
>
> On Tue, Sep 26, 2017 at 08:11:01PM +0200, Uwe Kleine-K=C3=B6nig wrote:
>> And ppc64 and x32 need the respective cpp defines added I think. If
>> noone beats me to it, I will look into the latter at least during the
>> next few days.
>
> Looking at ppc64, the following fixes the build:
>
> diff --git a/cgcc b/cgcc
> index a8d7b4f217fe..a1c02899c623 100755
> --- a/cgcc
> +++ b/cgcc
> @@ -286,7 +286,7 @@ sub add_specs {
>      } elsif ($spec eq 'ppc64') {
>         return (' -D__powerpc__=3D1 -D__PPC__=3D1 -D_STRING_ARCH_unaligne=
d=3D1' .
>                 ' -D__powerpc64__=3D1 -D__PPC64__=3D1' .
> -               ' -D_CALL_ELF=3D2' .
> +               ' -D_CALL_ELF=3D1' .
>                 ' -m64' .
>                 &float_types (1, 1, 21, [24,8], [53,11], [113,15]));
>      } elsif ($spec eq 's390x') {
>
> I wonder if that could be right. Luc, you added =3D2 in
> e0306fe0b725af6e2e7ff59d7f0d99c96315791a, maybe you can comment?

Neither =3D2 or =3D1 is correct, it depends on which version of the ELF
ABI you're using.
This in turn (as I understood) is most of the time tied to fact that
you're using ppc64le
(which normally needs ELFv2) or not.

I can't look at this now but will do this evening.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Dear Talented ===

From: "BSFS" <amunoz () transito ! go ! cr>
To: linux-sparse
Subject: Dear Talented
Date: Wed, 30 Aug 2017 03:30:08 +0000
Message-ID: <20170830031652.1FF514F5076C () webmail ! csv ! go ! cr>
--------------------
Dear Talented,

I am Talent Scout For BLUE SKY FILM STUDIO, Present Blue sky Studio a Film Corporation Located in the United State, is Soliciting for the Right to use Your Photo/Face and Personality as One of the Semi -Major Role/ Character in our Upcoming ANIMATED Stereoscope 3D Movie-The Story of Anubis (Anubis 2018) The Movie is Currently Filming (In Production) Please Note That There Will Be No Auditions, Traveling or Any Special / Professional Acting Skills, Since the Production of This Movie Will Be Done with our State of Art Computer - Generating Imagery Equipment. We Are Prepared to Pay the Total Sum of $620,000.00 USD. For
More Information/Understanding, Please Write us via this email.

Note: Only the Response send to this mail will be Given a Prior Consideration.

Talent Scout
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: EXTREMELY IMPORTANT ===

From: "Ms. Katherine" <ulia () distral ! ro>
To: linux-sparse
Subject: EXTREMELY IMPORTANT
Date: Mon, 24 Apr 2017 18:52:15 +0000
Message-ID: <20170424185220.E460351B3353 () mail ! distral ! ro>
--------------------
Dear Beloved, Sorry for the inconvenience, I am getting in touch with you regarding an extremely important and urgent matter, Please I need your urgent assistance and idea to finish up a project (Orphanage Home) Due to my health condition, Everything is available to finish up the project, All I need is your idea and trust.

Sehr geehrte Geliebte, traurig für die Unannehmlichkeiten, ich bin in Kontakt mit Ihnen über eine äußerst wichtige und dringende Angelegenheit, Bitte brauche ich Ihre dringende Hilfe und Idee, um ein Projekt zu beenden (Orphanage Home) Wegen meines Gesundheitszustandes ist alles verfügbar Beenden Sie das Projekt, Alles was ich brauche ist Ihre Idee und Vertrauen.

Please contact me for more details.
Contact Email: kathrynnmison@gmail.com

Thanks

---
This email has been checked for viruses by Avast antivirus software.
https://www.avast.com/antivirus


-- 
This message has been scanned for viruses and
dangerous content by MailScanner, and is
believed to be clean.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Hello Dear... ===

From: "M,Shakour Rosarita" <hassantara789 () gmail ! com>
To: linux-sparse
Subject: Hello Dear...
Date: Mon, 13 Nov 2017 12:08:18 +0000
Message-ID: <CAMyxZDE63FQAQ=JTZN_2Ks1T4PC7+RQ2oo6+S3vs4Q0Mp-K2iQ () mail ! gmail ! com>
--------------------
Hello Dear...

I know that this message will come to you as a surprise. I hoped that
you will not expose or betray this trust and confident that I am about
to repose on you, my name is M, Shakour Rosarita. I am 19 years old
Girl, female, from Tartu Syria, (never married) 61 kg, white in
complexion, and I am currently living in the refugee camp here in
Abidjan Ivory Coast, My late beloved father M,Shakour Hassin was a
renowned businessman and owner of Natour Petrol Station in Syria, he
was killed in a stampede riot in Tartu, Syria.
When I got the news about my parents. I fled to a nearby country
Jordan before I joined a ferry to Africa and came to Abidjan capital
city Ivory Coast West Africa find safety here.
I came in 2015 to Abidjan and I now live in refugee camps here as
refugees are allowed freely to enter here without, My late father
deposited (US$6.200.000.00m) My late father kept the money at the bank
of Africa, I want you to help me transfer the money to your hand so
that you will help me bring me into your country for my continue
education.

I sent my pictures here for you to see. Who I am seriously looking for
a good-person in my life, so I want to hear from you soon and learn
more about you.

I am an open-minded and friendly girl to share a good time with you
and have fun and enjoy on the go, bird watching, the rest of our
lives. My Hobbies, tourism books, dance, music, soccer, tennis,
swimming and cinema.
I would just think about you, including your dose and doesn=E2=80=99t .I
believe we will do well together, and live like one family.
Thank you and God bless you, for you in your promise to help me here,
looking forward to your reply by the grace of God and have a good day.
I hope you send me your photos as well? I await your next reply in
faith please reply through my private email at
(mshakourrosarita22@gmail.com):
Thanks.
Ms Rosarita
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Infinite loop with OOM while testing Sparse on Wine code ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Tue, 18 Jul 2017 15:11:50 +0000
Message-ID: <CANeU7QkZmX9YKaT5xs_mdSo0ggvGjefzvfjSrEPZbfKaGzTF1g () mail ! gmail ! com>
--------------------
On Tue, Jul 18, 2017 at 10:47 AM, Michael Stefaniuc
<mstefani@mykolab.com> wrote:
> But I seem to get an infinite loop with a mem leak: 100% CPU with the
> memory utilization increasing until this line triggers
> sparse/allocate.c:105:                 die("out of memory");

Thank you for the report. I will take a look at it.
> To reproduce:
> git clone git://source.winehq.org/git/wine.git
> cd wine
> ./configure --enable-win64
> make -j`getconf _NPROCESSORS_ONLN` CC=cgcc

I will try to reproduce it.

>
>
> Though I'm not sure that this qualifies as a blocker for the 0.5.1
> release. The Wine code was pretty tough on sparse previously; it has
> been years since I last tried. Crashes and mis-parses were normal back
> then as Wine uses language features that are still unimplemented (wide
> character string literals). But I do not remember to have encountered an
> infinite loop with a mem leak.

That sounds like a blocker to me. Hopefully it is not too hard to fix.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Tue, 18 Jul 2017 23:12:17 +0000
Message-ID: <CANeU7QnEui=yTjf+=TYU89mEhOrOj3b3X_W0csxJJ-eLRokWcg () mail ! gmail ! com>
--------------------
On Tue, Jul 18, 2017 at 10:47 AM, Michael Stefaniuc
<mstefani@mykolab.com> wrote:
> Hello guys,
>
> I thought I'll test the new sparse on the Wine source code, especially
> as I remember to have gotten 1-2 of those famous "Crazy programmer" errors.
>
> But I seem to get an infinite loop with a mem leak: 100% CPU with the
> memory utilization increasing until this line triggers
> sparse/allocate.c:105:                 die("out of memory");


OK, I have shrink the test program into the following code.
It can still reproduce the dead loop. It is related to simplify
the phi source.

Unfortunately I need to go now.

Luc, you want to take a look?

Chris

==========================================

extern char *strcpy (char *__dest, const char *__src);

static void test_menu_iteminfo( void )
{
int ansi = 1;
void *init, *string;
char stringA[0x80];
do {
if(ansi)
string=stringA;
if(ansi)
strcpy( string, init );
} while( !(ansi = !ansi) );
}
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Wed, 19 Jul 2017 00:07:19 +0000
Message-ID: <CANeU7Qk37weXva_-_M4bXeTTAT-DYGcccy+6jYv8pO6gzZNLcA () mail ! gmail ! com>
--------------------
On Tue, Jul 18, 2017 at 7:12 PM, Christopher Li <sparse@chrisli.org> wrote:
>
> OK, I have shrink the test program into the following code.
> It can still reproduce the dead loop. It is related to simplify
> the phi source.

So I add a show_entry() in side each of the CSE loop.
Here is what I have so far. Commends in <==========

Chris

====================== The original
test_menu_iteminfo:
.L0:
        <entry-point>
        phisrc.32   %phi3(ansi) <- $1
        br          .L1

.L1:
        phi.32      %r1(ansi) <- %phi3(ansi), %phi4(ansi)
        cbr         %r1(ansi), .L4, .L5

.L4:
        symaddr.64  %r2 <- stringA
        cast.64     %r3 <- (64) %r2
        br          .L5

.L5:
        cbr         %r1(ansi), .L6, .L7

.L6:
        ptrcast.64  %r6 <- (64) %r3
        ptrcast.64  %r8 <- (64) VOID
        call.64     %r9 <- strcpy, %r6, %r8
        br          .L7

.L7:
        br          .L2

.L2:
        seteq.32    %r11 <- %r1(ansi), $0
        phisrc.32   %phi4(ansi) <- %r11
        cbr         %r11, .L3, .L1

.L3:
        ret

======================
test_menu_iteminfo:
.L0:
        <entry-point>
        phisrc.32   %phi3(ansi) <- $1
        br          .L1

.L1:
        phi.32      %r1(ansi) <- %phi3(ansi), %phi4(ansi)
        cbr         %r1(ansi), .L4, .L5

.L4:
   ### <======= r2 getsymaddr get simplify away
        cast.64     %r3 <- (64) stringA
        br          .L5

.L5:
        cbr         %r1(ansi), .L6, .L7

.L6:
        ptrcast.64  %r6 <- (64) %r3
        ptrcast.64  %r8 <- (64) VOID
        call.64     %r9 <- strcpy, %r6, %r8
        br          .L7

.L7:
        br          .L2

.L2:
        seteq.32    %r11 <- %r1(ansi), $0
        phisrc.32   %phi4(ansi) <- %r11
        cbr         %r1(ansi), .L1, .L3

.L3:
        ret
======================
test_menu_iteminfo:
.L0:
        <entry-point>
        phisrc.32   %phi3(ansi) <- $1
        br          .L1

.L1:
        phi.32      %r1(ansi) <- %phi3(ansi), %phi4(ansi)
        cbr         %r1(ansi), .L4, .L5

.L4:
        cast.64     %r3 <- (64) stringA
        br          .L5

.L5:
        cbr         %r1(ansi), .L6, .L2

.L6:
        ptrcast.64  %r6 <- (64) %r3
        ptrcast.64  %r8 <- (64) VOID
        call.64     %r9 <- strcpy, %r6, %r8
        br          .L2   <=============== L2 merge with L7

.L2:
        seteq.32    %r11 <- %r1(ansi), $0
        phisrc.32   %phi4(ansi) <- %r11
        cbr         %r1(ansi), .L1, .L3

.L3:
        ret
======================
test_menu_iteminfo:
.L0:
        <entry-point>
        br          .L4 <========= phisrc3 get optimize away. This seems wrong

.L1:
        phi.32      %r1(ansi) <- VOID, %phi4(ansi) <======= this seems wrong.
        cbr         %r1(ansi), .L4, .L5

.L4:
        cast.64     %r3 <- (64) stringA
        br          .L5

.L5:
        cbr         %r1(ansi), .L6, .L3

.L6:
        ptrcast.64  %r6 <- (64) %r3
        ptrcast.64  %r8 <- (64) VOID
        call.64     %r9 <- strcpy, %r6, %r8
        br          .L2

.L2:
        seteq.32    %r11 <- %r1(ansi), $0
        phisrc.32   %phi4(ansi) <- %r11
        cbr         %r1(ansi), .L4, .L3

.L3:
        ret
======================
test_menu_iteminfo:
.L0:
        <entry-point>
        br          .L4

.L4:
        cast.64     %r3 <- (64) stringA
        br          .L5

.L5:
        cbr         %r11, .L3, .L6

.L6:
        ptrcast.64  %r6 <- (64) %r3
        ptrcast.64  %r8 <- (64) VOID
        call.64     %r9 <- strcpy, %r6, %r8
        br          .L2

.L2:
        setne.32    %r11 <- %r11, $0 <====== this seems very wrong
        cbr         %r11, .L4, .L3

.L3:
        ret
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Wed, 19 Jul 2017 13:26:29 +0000
Message-ID: <CANeU7Qkm_V8cYW3yKKBHo6PY9r0CA+XoTfJCVZbcOS14Am_PiA () mail ! gmail ! com>
--------------------
On Tue, Jul 18, 2017 at 8:07 PM, Christopher Li <sparse@chrisli.org> wrote:
> ======================
> test_menu_iteminfo:
> .L0:
>         <entry-point>
>         phisrc.32   %phi3(ansi) <- $1
>         br          .L1
>
> .L1:
>         phi.32      %r1(ansi) <- %phi3(ansi), %phi4(ansi)
>         cbr         %r1(ansi), .L4, .L5
>
> .L4:
>         cast.64     %r3 <- (64) stringA
>         br          .L5
>
> .L5:
>         cbr         %r1(ansi), .L6, .L2
>
> .L6:
>         ptrcast.64  %r6 <- (64) %r3
>         ptrcast.64  %r8 <- (64) VOID
>         call.64     %r9 <- strcpy, %r6, %r8
>         br          .L2   <=============== L2 merge with L7
>
> .L2:
>         seteq.32    %r11 <- %r1(ansi), $0
>         phisrc.32   %phi4(ansi) <- %r11
>         cbr         %r1(ansi), .L1, .L3
>
> .L3:
>         ret
> ======================
> test_menu_iteminfo:
> .L0:
>         <entry-point>
>         br          .L4 <========= phisrc3 get optimize away. This seems wrong

I see more what is going on there now.
Basically we have %phi3 = 1, a constant.
There for when control flow go from L0->L1, %r1 = %phi3 = 1.
It will go to L4 for sure.

So L0 modify to goto L4 directly. That is fine.

>
> .L1:
>         phi.32      %r1(ansi) <- VOID, %phi4(ansi) <======= this seems wrong.
>         cbr         %r1(ansi), .L4, .L5

phisrc3 has only one usage on L1. phisrc3 can be optimize away
and replace it with value 1. Showing VOID there is wrong.
it should be:

phi.32 %r1(ansi) <- 1, %phi4(ansi)

This phi instruction can't be deleted. Even though the control flow
has skip L1 and go to L4 directly. Makes L1 seems unreachable.
But the %r1(ansi) inside L1 is still used.

I think that is the nature of this bug.

Once sparse mistakenly remove %r1(ansi), it goes all crazy.
It result in the
 "setne.32    %r11 <- %r11, $0 "

which does not make sense at all.

I have revert the change cause this problem on sparse-next.

Wine compile should be able to complete now.

Luc, do you have time to take a look at this? Without your input,
RC5 will be released with commit  11b1a83b disabled.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Wed, 19 Jul 2017 15:25:57 +0000
Message-ID: <CANeU7Q=aKJ_JHNBAeG_yatjb7hb_S1D5vfHJ72_B3EK-nrutdg () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 9:26 AM, Christopher Li <sparse@chrisli.org> wrote:
> I have revert the change cause this problem on sparse-next.
>
> Wine compile should be able to complete now.

Yes, I have single CPU build the wine package to a complete.
The test sparse is on the sparse-next branch.

cgcc -o wineserver async.o atom.o change.o class.o clipboard.o
completion.o console.o debugger.o device.o \
  directory.o event.o fd.o file.o handle.o hook.o mach.o mailslot.o
main.o mapping.o mutex.o \
  named_pipe.o object.o process.o procfs.o ptrace.o queue.o region.o
registry.o request.o \
  semaphore.o serial.o signal.o snapshot.o sock.o symlink.o thread.o
timer.o token.o trace.o \
  unicode.o user.o window.o winstation.o -Wl,--rpath,\$ORIGIN/../libs/wine \
  ../libs/port/libwine_port.a -lwine -L../libs/wine
make[1]: Leaving directory '/home/xxx/git/oss/wine/server'
Wine build complete.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Wed, 19 Jul 2017 20:43:01 +0000
Message-ID: <CAExDi1Quxc_ZfmdW2-kY=Q312Dnbi_7OsRX85_uGrHWTk1vtpw () mail ! gmail ! com>
--------------------
> Luc, do you have time to take a look at this? Without your input,
> RC5 will be released with commit  11b1a83b disabled.

I'm not yet fully back but I'll be able to look at it later, probably
tomorrow (it's already evening here).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Thu, 20 Jul 2017 22:44:53 +0000
Message-ID: <20170720224451.goobbxuteej7aksd () ltop ! local>
--------------------
On Wed, Jul 19, 2017 at 02:16:54PM -0700, Christopher Li wrote:
> On Wed, Jul 19, 2017 at 4:43 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > I'm not yet fully back but I'll be able to look at it later, probably
> > tomorrow (it's already evening here).
> 
> That is fine. How about we temporary disable that in the 0.5.1 release.
> Re-enable it with some proper fix of the phi domination problem. e.g.
> 0.5.2.
> 
> Right now I feel a little bit uncomfortable with 11b1a83b. Already two bugs
> trigger in the field. The previous fix d7985338 is not a proper fix any way.
> I think the right thing to do is just release 0.5.1 with 11b1a83b disabled.
> Turn on 11b1a83b in sparse-next and do more fixing there. Release
> 0.5.2 when it settle down with other new merges.

I can't run all the validation I had done for -rc4 but I have no objections
about the revert (I'm pretty sure there will be some side-effects though).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Wed, 26 Jul 2017 17:29:00 +0000
Message-ID: <CANeU7QkmV-i1jL0BgrMbZy0DzKQdMeYw7=M0WfDnV7e+G-8Lmw () mail ! gmail ! com>
--------------------
On Thu, Jul 20, 2017 at 6:44 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> I can't run all the validation I had done for -rc4 but I have no objections
> about the revert (I'm pretty sure there will be some side-effects though).
>

OK. That is good to know.  Do you have any chance to take a closer
look at this bug or still be away yet?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Sat, 29 Jul 2017 14:39:15 +0000
Message-ID: <20170729143914.amo3vkoiqv7rkvmz () ltop ! local>
--------------------
On Wed, Jul 19, 2017 at 09:26:29AM -0400, Christopher Li wrote:

OK I finally had the time to look at this closely.

> On Tue, Jul 18, 2017 at 8:07 PM, Christopher Li <sparse@chrisli.org> wrote:
> > ======================
> > test_menu_iteminfo:
> > .L0:
> >         <entry-point>
> >         phisrc.32   %phi3(ansi) <- $1
> >         br          .L1
> >
> > .L1:
> >         phi.32      %r1(ansi) <- %phi3(ansi), %phi4(ansi)
> >         cbr         %r1(ansi), .L4, .L5
> >
> > .L4:
> >         cast.64     %r3 <- (64) stringA
> >         br          .L5
> >
> > .L5:
> >         cbr         %r1(ansi), .L6, .L2
> >
> > .L6:
> >         ptrcast.64  %r6 <- (64) %r3
> >         ptrcast.64  %r8 <- (64) VOID
> >         call.64     %r9 <- strcpy, %r6, %r8
> >         br          .L2   <=============== L2 merge with L7
> >
> > .L2:
> >         seteq.32    %r11 <- %r1(ansi), $0
> >         phisrc.32   %phi4(ansi) <- %r11
> >         cbr         %r1(ansi), .L1, .L3
> >
> > .L3:
> >         ret
> > ======================
> > test_menu_iteminfo:
> > .L0:
> >         <entry-point>
> >         br          .L4 <========= phisrc3 get optimize away. This seems wrong
> 
> I see more what is going on there now.
> Basically we have %phi3 = 1, a constant.
> There for when control flow go from L0->L1, %r1 = %phi3 = 1.
> It will go to L4 for sure.
> 
> So L0 modify to goto L4 directly. That is fine.

Indeed, it's fine.
 
> >
> > .L1:
> >         phi.32      %r1(ansi) <- VOID, %phi4(ansi) <======= this seems wrong.
> >         cbr         %r1(ansi), .L4, .L5
> 
> phisrc3 has only one usage on L1. phisrc3 can be optimize away
> and replace it with value 1. Showing VOID there is wrong.

No it's fine. It's the way of displaying that the element have been removed.

> it should be:
> 
> phi.32 %r1(ansi) <- 1, %phi4(ansi)

No, not really.
L1 has now only a single parent, the phi-node is now a trivial one,
not really a join anymore.
An explicit way of displaying it should simply be:
	phi.32      %r1(ansi) <- %phi4(ansi)
 
Everything is correct until:
	test_menu_iteminfo:
	.L0:
		<entry-point>
		br          .L4
	.L1:
		phi.32      %r1(ansi) <- VOID, %phi4(ansi)
		cbr         %r1(ansi), .L4, .L5
	.L4:
		cast.64     %r3 <- (64) stringA
		br          .L5
	.L5:
		cbr         %r1(ansi), .L6, .L3
	.L6:
		ptrcast.64  %r6 <- (64) %r3
		ptrcast.64  %r8 <- (64) VOID			<== wrong but unrelated
		call.64     %r9 <- strcpy, %r6, %r8
		br          .L2
	.L2:
		seteq.32    %r11 <- %r1(ansi), $0
		phisrc.32   %phi4(ansi) <- %r11
		cbr         %r1(ansi), .L1, .L3
	.L3:
		ret

Then simplify_branch_branch() is called on L2 -> L1
and wrongly succeed giving:
	.L0:
	        <entry-point>
	        br          .L4
	.L1:
	        phi.32      %r1(ansi) <- VOID, %phi4(ansi)	<== now dead
	        cbr         %r1(ansi), .L4, .L5
	.L4:
	        cast.64     %r3 <- (64) stringA
	        br          .L5
	.L5:
	        cbr         %r1(ansi), .L6, .L3
	.L6:
	        ptrcast.64  %r6 <- (64) %r3
		ptrcast.64  %r8 <- (64) VOID			<== wrong but unrelated
	        call.64     %r9 <- strcpy, %r6, %r8
	        br          .L2
	.L2:
	        seteq.32    %r11 <- %r1(ansi), $0
	        phisrc.32   %phi4(ansi) <- %r11
	        cbr         %r1(ansi), .L4, .L3			<== bad change
	.L3:
	        ret

This will then trigger the wrong simplifications:
	%phi4 <- %r11
and
	%r1   <- %r11
giving finally:
	        setne.32    %r11 <- %r11, $0

As far as I can see, simplify_branch_branch() needs something
like the bb_defines_phi() I had to add to try_to_simplify_bb()
(basically it's bb_depends_on() which is not 'strong' enough).

I'll need a bit more time to see exactly what is needed, for
example if we can simply reuse bb_defines_phi() or not, and
to test all this.

At this point I don't think anymore that the revert is the most
appropriate thing to do.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Sat, 29 Jul 2017 23:38:07 +0000
Message-ID: <20170729233805.lvdhpk5bnyaj5zq6 () ltop ! local>
--------------------
On Wed, Jul 19, 2017 at 09:26:29AM -0400, Christopher Li wrote:
> On Tue, Jul 18, 2017 at 8:07 PM, Christopher Li <sparse@chrisli.org> wrote:
> > ======================
> > test_menu_iteminfo:
> > .L0:
> >         <entry-point>
> >         phisrc.32   %phi3(ansi) <- $1
> >         br          .L1
> >
> > .L1:
> >         phi.32      %r1(ansi) <- %phi3(ansi), %phi4(ansi)
> >         cbr         %r1(ansi), .L4, .L5
> >
> > .L4:
> >         cast.64     %r3 <- (64) stringA
> >         br          .L5
> >
> > .L5:
> >         cbr         %r1(ansi), .L6, .L2
> >
> > .L6:
> >         ptrcast.64  %r6 <- (64) %r3
> >         ptrcast.64  %r8 <- (64) VOID
> >         call.64     %r9 <- strcpy, %r6, %r8
> >         br          .L2   <=============== L2 merge with L7
> >
> > .L2:
> >         seteq.32    %r11 <- %r1(ansi), $0
> >         phisrc.32   %phi4(ansi) <- %r11
> >         cbr         %r1(ansi), .L1, .L3
> >
> > .L3:
> >         ret
> > ======================
> > test_menu_iteminfo:
> > .L0:
> >         <entry-point>
> >         br          .L4 <========= phisrc3 get optimize away. This seems wrong
> 
> I see more what is going on there now.
> Basically we have %phi3 = 1, a constant.
> There for when control flow go from L0->L1, %r1 = %phi3 = 1.
> It will go to L4 for sure.
> 
> So L0 modify to goto L4 directly. That is fine.

My first analysis was wrong, the real problem is closer from here.

As far as I can currently see, the problem is related to the fact that:
- the joint was at L1 (who had 2 parents: L0 & L2)
- L4 wasn't a joint (the only parent was L1)
but after the first call to try_to_simplify_bb() it's not true anymore:
- L1 is not a trivial joint, this is fine
- L4 become a *real* joint (it can receive %r1 value from L1 or
  implicitely from L0). This is still fine for L4 but not anymore
  for its successor L5.
One way to see the problem is that the fix 852801f8b is not enough.
My first guess would be that the simplification made by try_to_simplify_bb()
is valid only if the controlling pseudo is local to the current BB.

Still looking at this.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Infinite loop with OOM while testing Sparse on Wine code
Date: Sun, 30 Jul 2017 00:01:54 +0000
Message-ID: <20170730000152.e7ptsets43tamcv6 () ltop ! local>
--------------------
On Sun, Jul 30, 2017 at 01:38:07AM +0200, Luc Van Oostenryck wrote:
> Still looking at this.

I just sent a patch.
At first sight it seems to be correct but it will need more testing.
I'll do that tomorrow as it is already quite late here.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Output from linearize and LLVM error ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Output from linearize and LLVM error
Date: Sun, 29 Jan 2017 09:15:19 +0000
Message-ID: <20170129091518.jbyfkm2xw2ooqufd () macbook ! local>
--------------------
On Sun, Jan 29, 2017 at 12:26:40AM +0000, Dibyendu Majumdar wrote:
> Hi Luc,
> 
> On 27 January 2017 at 20:43, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > To get the type of malloc()'s arg and this is done by calling
> > pseudo_to_value() with the malloc instruction and the pseudo
> > for the size (but no info about this pseudo being malloc()'s arg).
> > LLVMConstInt() is then called with the constant value and the type
> > is given by calling insn_symbol_type() with the malloc instruction
> > but again, it's not possible to get the right type without specifying
> > we try to get the type of the first argument of the called function
> > and not the type of the result.
> >
> 
> I think that there is a problem wherever pseudo_to_value() is being
> used and the pseudo is an integer constant.

Indeed, and possibly in other cases too.

> Firstly the logic for
> determining the size of the constant needs to cover all cases and
> secondly depending upon the context the constant may need to be cast
> to a pointer. So while the patch you mentioned before tries to solve
> this for comparison operations, I think that the solution needs to
> cater for all use cases not just those. The handling of arguments is
> an example of this.

Absolutely, the patch I wrote was only to fix a sparse-llvm breakage
I saw after some changes with sparse dealing of comparisons.
I didn't realized that the problem was bigger.

> 
> My suggestion is that pseudo_to_value() for PSEUDO_VAL should always
> return an integer constant of type 'long long'  and the caller of
> pseudo_to_value() should adjust the constant to right size (by
> truncating or extending) or to pointer type if necessary as the caller
> has more information. For instance, in the handling of OP_CALL, the
> function output_op_call() knows when the call is for an argument, etc.
> Currently pseudo_to_value() tries to work out the integer size, but
> cannot do this correctly due to lack of information, and also even if
> it did work out the size, the cast to pointer would be missed I think.
> 
> Does this make sense?

Yes, it make a lot of sense but I'm not so sure about the approach.
* I'm not sure how easy it is to adjust the constant size/type.
* adjusting the constant size/type instead of gettign directly the
  right type will create a superfluous cast (not a big deal as LLVM
  will optimize it away later but well ...).
* I think that in general passing the pointer to the instruction to
  pseudo_to_value() and insn_symbol_type() is an error since what is
  really needed is the type, thus those function can only make assumptions
  about the type, maybe most of the time a correct one, but they can't do
  for all cases.
* I think that this problem would be better handled if the caller could
  directly give the type information to pseudo_to_value() instead of 
  adjusting it after the fact (but I have no idea how difficult and
  how much work it will be).
* I have no idea about the constant-to-pointer case.
* I think you will have a problem with void pointer since in this case
  sparse doesn't have the information about the real type (but maybe it
  will be easy to solve, I have no idea).

Note: I known next to nothing about LLVM
Note: I've added in CC the authors of sparse-llvm.c


Regards,
Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Proposal ===

From: "Ms.Lev" <VALETRANSPORTEADM () PMF ! SC ! GOV ! BR>
To: linux-sparse
Subject: Proposal
Date: Tue, 24 Oct 2017 16:40:20 +0000
Message-ID: <20171024162932.7455B1A3914 () lnpmf-zimbra ! pmf ! sc ! gov ! br>
--------------------
 I have a confidential deal for you, please contact me for more details via this email immediately.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Query regarding sizeof long ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Query regarding sizeof long
Date: Tue, 24 Jan 2017 14:47:12 +0000
Message-ID: <20170124144711.evipzg47ka572qgd () macpro ! local>
--------------------
On Tue, Jan 24, 2017 at 02:23:13PM +0000, Dibyendu Majumdar wrote:
> Hi
> 
> I am working on porting Sparse to Windows, and I noticed that in
> 64-bit architecture the bits_in_long is set to 64. This is not true
> for Windows where long is 32 bits on a 64-bit machine. I was wondering
> if I just need to set this parameter to 32 or if there are other
> implications that I need to be aware of.

Hi,

If you just change the initial value in target.c, it won't do what you
need because currently, if you compile sparse on a machine where
__x86_64__ is defined, it will automatically enable the -m64 option
which will setup things for an LP64 architecture instead of the LLP64
that you need (inside handle_arch_m64_finalize()).

Ideally, we should have a mean to configure the default value of such
things at building time.

Hope it helps,
Luc 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Query regarding sizeof long
Date: Tue, 24 Jan 2017 18:00:03 +0000
Message-ID: <CAMHZB6EB31xGf6C-j=x0MpPnKjyap5Hb7P5BJd1V5DsycT92DA () mail ! gmail ! com>
--------------------
On Tue, Jan 24, 2017 at 4:08 PM, Dibyendu Majumdar
<mobile@majumdar.org.uk> wrote:
> Hi Luc,
>
> On 24 January 2017 at 14:47, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> On Tue, Jan 24, 2017 at 02:23:13PM +0000, Dibyendu Majumdar wrote:
>>> I am working on porting Sparse to Windows, and I noticed that in
>>> 64-bit architecture the bits_in_long is set to 64. This is not true
>>> for Windows where long is 32 bits on a 64-bit machine. I was wondering
>>> if I just need to set this parameter to 32 or if there are other
>>> implications that I need to be aware of.
>>
>> If you just change the initial value in target.c, it won't do what you
>> need because currently, if you compile sparse on a machine where
>> __x86_64__ is defined, it will automatically enable the -m64 option
>> which will setup things for an LP64 architecture instead of the LLP64
>> that you need (inside handle_arch_m64_finalize()).
>>
>
> Yes I noticed that and I can easily make that conditional on MSVC. I
> guess my question is more whether there are any assumptions in the
> code that a long in a 64-bit environment is 64-bits (e.g. pointers fit
> into long). I have not yet been able to run all the tests on Windows,
> but I guess that is one way I can find out if there are any issues.

There shouldn't be any such assumptions :)
And I think, you shouldn't have much bad surprised,
but I'm a bit less confident regarding the test-suite. It's very possible
that some tests have the assumption that sizeof(long) == sizeof(pointer).
And I'm pretty sure that this LLP64 situation have been very little tested,
very possibly never been tested at all.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse preprocessing bug with zero-arg variadic macros ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Sparse preprocessing bug with zero-arg variadic macros
Date: Thu, 31 Aug 2017 17:19:32 +0000
Message-ID: <CA+55aFy8sXZKibU_RK-+hu_SD-QMaWxxsAQNYALkmvMiYfEo=Q () mail ! gmail ! com>
--------------------
On Thu, Aug 31, 2017 at 6:34 AM, Josh Poimboeuf <jpoimboe@redhat.com> wrote:
>
> I think I'm seeing a bug in the sparse preprocessor.  I've reduced it to
> the following test case.

I think the real reduced test-case is just this:

    #define ARGS_APPEND(...) ,## __VA_ARGS__
    ARGS_APPEND()

and you can run if through "sparse -E" to see the comma (while gcc -E
does not have it).

I'm adding Al to the cc list because he's the pre-processor person.
Hopefully he has gotten out from under most of his emails from his
move.

sparse gets it right if there is any non-VA_ARGS argument to the
symbol, but not if __VA_ARGS__ is all of the argument to the macro.

Al?

                 Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () ZenIV ! linux ! org ! uk>
To: linux-sparse
Subject: Re: Sparse preprocessing bug with zero-arg variadic macros
Date: Thu, 31 Aug 2017 21:09:22 +0000
Message-ID: <20170831210922.GA9227 () ZenIV ! linux ! org ! uk>
--------------------
On Thu, Aug 31, 2017 at 09:54:33PM +0100, Al Viro wrote:
> What a mess...  Note that for non-vararg it *is* the right interpretation
> (with #define A(x) [x] we will have A() interpreted as "empty token sequence
> as the only argument", not "no arguments given").  For vararg case we
> normally do not need to distinguish "not given" and "empty" - the only
> thing that cares is exactly the ,## kludge.  There with
> #define B(x,...) [x,##__VA_ARGS__]
> B(1) and B(1,) yield [1] and [1,] resp.  And for everything other than
> "just ..." we even get it right...
> 
> I see what's going on there; will post a fix in a few.


Fix macro argument parsing for (...) case

Nasty corner case for the sake of ,##__VA_ARGS__ perversion - for something
like #define A(x,...) [x,##__VA_ARGS] we want A(1) to expand to [1] and
A(1,) - to [1,].  In other words, "no vararg given" and "vararg empty" are
different and need to be distinguished.  Unfortunately, in case when there
was nothing but vararg we got it wrong - #define A(...) ,##__VA_ARGS ended
up with A() interpreted as "one empty argument" (as it would in non-vararg
case) rather than "zero arguments".

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
---
diff --git a/pre-process.c b/pre-process.c
index 74414df..8800dce 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -296,9 +296,11 @@ static int collect_arguments(struct token *start, struct token *arglist, struct
 		for (count = 0; count < wanted; count++) {
 			struct argcount *p = &arglist->next->count;
 			next = collect_arg(start, p->vararg, &what->pos, p->normal);
-			arglist = arglist->next->next;
 			if (eof_token(next))
 				goto Eclosing;
+			if (p->vararg && wanted == 1 && eof_token(start->next))
+				break;
+			arglist = arglist->next->next;
 			args[count].arg = start->next;
 			args[count].n_normal = p->normal;
 			args[count].n_quoted = p->quoted;
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: Sparse preprocessing bug with zero-arg variadic macros
Date: Thu, 31 Aug 2017 21:34:44 +0000
Message-ID: <20170831213444.6yeyfcrry6utaeih () cloud>
--------------------
On Thu, Aug 31, 2017 at 10:09:22PM +0100, Al Viro wrote:
> On Thu, Aug 31, 2017 at 09:54:33PM +0100, Al Viro wrote:
> > What a mess...  Note that for non-vararg it *is* the right interpretation
> > (with #define A(x) [x] we will have A() interpreted as "empty token sequence
> > as the only argument", not "no arguments given").  For vararg case we
> > normally do not need to distinguish "not given" and "empty" - the only
> > thing that cares is exactly the ,## kludge.  There with
> > #define B(x,...) [x,##__VA_ARGS__]
> > B(1) and B(1,) yield [1] and [1,] resp.  And for everything other than
> > "just ..." we even get it right...
> > 
> > I see what's going on there; will post a fix in a few.
> 
> 
> Fix macro argument parsing for (...) case
> 
> Nasty corner case for the sake of ,##__VA_ARGS__ perversion - for something
> like #define A(x,...) [x,##__VA_ARGS] we want A(1) to expand to [1] and
> A(1,) - to [1,].  In other words, "no vararg given" and "vararg empty" are
> different and need to be distinguished.  Unfortunately, in case when there
> was nothing but vararg we got it wrong - #define A(...) ,##__VA_ARGS ended
> up with A() interpreted as "one empty argument" (as it would in non-vararg
> case) rather than "zero arguments".
> 
> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
> ---
> diff --git a/pre-process.c b/pre-process.c
> index 74414df..8800dce 100644
> --- a/pre-process.c
> +++ b/pre-process.c
> @@ -296,9 +296,11 @@ static int collect_arguments(struct token *start, struct token *arglist, struct
>  		for (count = 0; count < wanted; count++) {
>  			struct argcount *p = &arglist->next->count;
>  			next = collect_arg(start, p->vararg, &what->pos, p->normal);
> -			arglist = arglist->next->next;
>  			if (eof_token(next))
>  				goto Eclosing;
> +			if (p->vararg && wanted == 1 && eof_token(start->next))
> +				break;
> +			arglist = arglist->next->next;
>  			args[count].arg = start->next;
>  			args[count].n_normal = p->normal;
>  			args[count].n_quoted = p->quoted;

This looks plausible; we should also add a test for it, though.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse warnings on GENMASK + arm32 ===

From: Stephen Boyd <sboyd () codeaurora ! org>
To: linux-kernel
Subject: Sparse warnings on GENMASK + arm32
Date: Wed, 26 Jul 2017 01:30:20 +0000
Message-ID: <20170726013020.GL2146 () codeaurora ! org>
--------------------
I see sparse warning when I check a clk driver file in the kernel
on a 32-bit ARM build.

drivers/clk/sunxi/clk-sun6i-ar100.c:65:20: warning: cast truncates bits from constant value (3ffffffff becomes ffffffff)

The code in question looks like:

static const struct factors_data sun6i_ar100_data = {
	.mux = 16,
	.muxmask = GENMASK(1, 0),
	.table = &sun6i_ar100_config,
	.getter = sun6i_get_ar100_factors,
};

where factors_data is

struct factors_data {
	int enable;
	int mux;
	int muxmask;
	const struct clk_factors_config *table;
	void (*getter)(struct factors_request *req);
	void (*recalc)(struct factors_request *req);
	const char *name;
};


and sparse seems to be complaining about the muxmask assignment
here. Oddly, this doesn't happen on arm64 builds. Both times, I'm
checking this on an x86-64 machine.

 $ sparse --version
 v0.5.1-rc4-1-gfa71b7ac0594

Is there something confusing to sparse in the GENMASK macro?

-- 
Qualcomm Innovation Center, Inc. is a member of Code Aurora Forum,
a Linux Foundation Collaborative Project
================================================================================

From: Stephen Boyd <sboyd () codeaurora ! org>
To: linux-sparse
Subject: Sparse warnings on GENMASK + arm32
Date: Wed, 26 Jul 2017 01:30:20 +0000
Message-ID: <20170726013020.GL2146 () codeaurora ! org>
--------------------
I see sparse warning when I check a clk driver file in the kernel
on a 32-bit ARM build.

drivers/clk/sunxi/clk-sun6i-ar100.c:65:20: warning: cast truncates bits from constant value (3ffffffff becomes ffffffff)

The code in question looks like:

static const struct factors_data sun6i_ar100_data = {
	.mux = 16,
	.muxmask = GENMASK(1, 0),
	.table = &sun6i_ar100_config,
	.getter = sun6i_get_ar100_factors,
};

where factors_data is

struct factors_data {
	int enable;
	int mux;
	int muxmask;
	const struct clk_factors_config *table;
	void (*getter)(struct factors_request *req);
	void (*recalc)(struct factors_request *req);
	const char *name;
};


and sparse seems to be complaining about the muxmask assignment
here. Oddly, this doesn't happen on arm64 builds. Both times, I'm
checking this on an x86-64 machine.

 $ sparse --version
 v0.5.1-rc4-1-gfa71b7ac0594

Is there something confusing to sparse in the GENMASK macro?

-- 
Qualcomm Innovation Center, Inc. is a member of Code Aurora Forum,
a Linux Foundation Collaborative Project
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Lance Richardson <lrichard () redhat ! com>
To: linux-kernel
Subject: Re: Sparse warnings on GENMASK + arm32
Date: Wed, 26 Jul 2017 13:33:01 +0000
Message-ID: <1000702648.38599568.1501075981880.JavaMail.zimbra () redhat ! com>
--------------------
> From: "Stephen Boyd" <sboyd@codeaurora.org>
> To: linux-sparse@vger.kernel.org
> Cc: linux-kernel@vger.kernel.org
> Sent: Tuesday, 25 July, 2017 9:30:20 PM
> Subject: Sparse warnings on GENMASK + arm32
> 
> I see sparse warning when I check a clk driver file in the kernel
> on a 32-bit ARM build.
> 
> drivers/clk/sunxi/clk-sun6i-ar100.c:65:20: warning: cast truncates bits from
> constant value (3ffffffff becomes ffffffff)
> 
> The code in question looks like:
> 
> static const struct factors_data sun6i_ar100_data = {
> 	.mux = 16,
> 	.muxmask = GENMASK(1, 0),
> 	.table = &sun6i_ar100_config,
> 	.getter = sun6i_get_ar100_factors,
> };
> 
> where factors_data is
> 
> struct factors_data {
> 	int enable;
> 	int mux;
> 	int muxmask;
> 	const struct clk_factors_config *table;
> 	void (*getter)(struct factors_request *req);
> 	void (*recalc)(struct factors_request *req);
> 	const char *name;
> };
> 
> 
> and sparse seems to be complaining about the muxmask assignment
> here. Oddly, this doesn't happen on arm64 builds. Both times, I'm
> checking this on an x86-64 machine.
> 
>  $ sparse --version
>  v0.5.1-rc4-1-gfa71b7ac0594
> 
> Is there something confusing to sparse in the GENMASK macro?
> 

Hmm, it seems sparse is incorrectly taking ~0UL to be a 64-bit value
while BITS_PER_LONG is (correctly) evaluated to be 32.

#define GENMASK(h, l) \
	(((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))

> --
> Qualcomm Innovation Center, Inc. is a member of Code Aurora Forum,
> a Linux Foundation Collaborative Project
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse warnings on GENMASK + arm32
Date: Wed, 26 Jul 2017 13:46:17 +0000
Message-ID: <20170726134616.grjb7metn7rv5alu () ltop ! local>
--------------------
On Wed, Jul 26, 2017 at 09:33:01AM -0400, Lance Richardson wrote:
> > From: "Stephen Boyd" <sboyd@codeaurora.org>
> > I see sparse warning when I check a clk driver file in the kernel
> > on a 32-bit ARM build.
> > 
> > drivers/clk/sunxi/clk-sun6i-ar100.c:65:20: warning: cast truncates bits from
> > constant value (3ffffffff becomes ffffffff)
> 
> Hmm, it seems sparse is incorrectly taking ~0UL to be a 64-bit value
> while BITS_PER_LONG is (correctly) evaluated to be 32.
> 
> #define GENMASK(h, l) \
> 	(((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))

It's the kernel CHECKFLAGS that should be using -m32/-m64 if built
on a machine with a different wordsize tht the arch.

I sent earlier a patch for ARM, I just forgot to CC the mailing list here.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-kernel
Subject: Re: Sparse warnings on GENMASK + arm32
Date: Wed, 26 Jul 2017 13:46:17 +0000
Message-ID: <20170726134616.grjb7metn7rv5alu () ltop ! local>
--------------------
On Wed, Jul 26, 2017 at 09:33:01AM -0400, Lance Richardson wrote:
> > From: "Stephen Boyd" <sboyd@codeaurora.org>
> > I see sparse warning when I check a clk driver file in the kernel
> > on a 32-bit ARM build.
> > 
> > drivers/clk/sunxi/clk-sun6i-ar100.c:65:20: warning: cast truncates bits from
> > constant value (3ffffffff becomes ffffffff)
> 
> Hmm, it seems sparse is incorrectly taking ~0UL to be a 64-bit value
> while BITS_PER_LONG is (correctly) evaluated to be 32.
> 
> #define GENMASK(h, l) \
> 	(((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))

It's the kernel CHECKFLAGS that should be using -m32/-m64 if built
on a machine with a different wordsize tht the arch.

I sent earlier a patch for ARM, I just forgot to CC the mailing list here.

-- Luc
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Sparse warnings on GENMASK + arm32
Date: Wed, 26 Jul 2017 13:47:15 +0000
Message-ID: <CANeU7Qme-sAvpFhuaA-YjRoCu_-zyySVpnYuSTYjZoM9D64PYQ () mail ! gmail ! com>
--------------------
On Wed, Jul 26, 2017 at 9:33 AM, Lance Richardson <lrichard@redhat.com> wrote:
> Hmm, it seems sparse is incorrectly taking ~0UL to be a 64-bit value
> while BITS_PER_LONG is (correctly) evaluated to be 32.
>
> #define GENMASK(h, l) \
>         (((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
>
What is the sizeof(unsigned long) in ARM 32 bit world?

~0UL has the type of "unsigned long", I assume BITS_PER_LONG
is just plain "int"? Using sparse -E should be able to get the expression
after the macro expression.

The kernel compile invoke sparse directly. That is the assumption
that the host gcc has the same type size as the target gcc.
That is no longer true if you have cross compiler.

If you want to have sparse understand the proper architecture difference,
the current practices is using cgcc to handle the architecture specific
macros.

you can try to invoke the kernel building with: CHECK="cgcc -no-compile".
Warning: I haven't try that myself, it might not work as expected.

In the long run, I do wish sparse can implement the proper handling of
the architecture specific stuff by itself without go through of cgcc.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: Sparse warnings on GENMASK + arm32
Date: Wed, 26 Jul 2017 13:47:15 +0000
Message-ID: <CANeU7Qme-sAvpFhuaA-YjRoCu_-zyySVpnYuSTYjZoM9D64PYQ () mail ! gmail ! com>
--------------------
On Wed, Jul 26, 2017 at 9:33 AM, Lance Richardson <lrichard@redhat.com> wrote:
> Hmm, it seems sparse is incorrectly taking ~0UL to be a 64-bit value
> while BITS_PER_LONG is (correctly) evaluated to be 32.
>
> #define GENMASK(h, l) \
>         (((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
>
What is the sizeof(unsigned long) in ARM 32 bit world?

~0UL has the type of "unsigned long", I assume BITS_PER_LONG
is just plain "int"? Using sparse -E should be able to get the expression
after the macro expression.

The kernel compile invoke sparse directly. That is the assumption
that the host gcc has the same type size as the target gcc.
That is no longer true if you have cross compiler.

If you want to have sparse understand the proper architecture difference,
the current practices is using cgcc to handle the architecture specific
macros.

you can try to invoke the kernel building with: CHECK="cgcc -no-compile".
Warning: I haven't try that myself, it might not work as expected.

In the long run, I do wish sparse can implement the proper handling of
the architecture specific stuff by itself without go through of cgcc.

Chris
================================================================================


################################################################################

=== Thread: Sparse-LLVM issue compiling NULL pointers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 16:04:04 +0000
Message-ID: <20170302160403.zz5efgh34jvjh5q5 () macpro ! local>
--------------------
On Thu, Mar 02, 2017 at 02:33:09PM +0000, Dibyendu Majumdar wrote:
> This occurs in calc_memop_addr() function when it tries to do following:
> 
>  as = LLVMGetPointerAddressSpace(LLVMTypeOf(src));
> 
> If I dump insn, insn->src, and the LLVM value and type before this line, I get:
> 
> 1) insn load.64     %r18 <- 8[%r2]
> 2) pseudo %r2
> 3) store %struct.buffer_type_st* %R2, %struct.buffer_type_st** %26
> 4) void
> 
> The type of the LLVM store instruction is 'void'.
> 
> My guess is that something is going horribly wrong in the way member
> access is handled.
> 
> If you are able to reproduce this and have any suggestions then please
> let me know.

Why I try your code (without LLVM assertions), I got indeed several
problems:
	Call parameter type does not match function signature!
	i0 16
	 i64  %1 = call i8* @malloc(i0 16)
	Invalid bitcast
	  %27 = bitcast void <badref> to i8**
	Both operands to a binary operator are not of the same type!
	  %R31 = add void <badref>, i64 %R30
	Stored value type does not match pointer operand type!
	  store void %R31, i8** %46

The first one is really weird but I think you don't see it.
The next two I have no idea.
The fourth have something obviously wrong with the type of its 'target'.
None of these seems to correspond to the problem you're seeing.

However, while running sparse-llvm on some code sample I use to test
the linearization, I see that most errors are type errors and are
related to pointer arithmetic, exactly where LLVM's getelemptr is used.
Most offending instructions are OP_ADD (but since I have tests for 
bitfields I see also errors for OP_AND, OP_OR & OP_LSR).
I guess that if you test OP_ADD instruction with pointer on one side
and integer on tne other side and issue an appropriate LLVMBuildGEP(),
things will already be much better.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 16:29:13 +0000
Message-ID: <CACXZuxefWw7VT8VJPXuYZ2kBLK-N=eYGc6BF5Lnbg9vP-RqLWw () mail ! gmail ! com>
--------------------
Hi Luc,

On 2 March 2017 at 16:04, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Mar 02, 2017 at 02:33:09PM +0000, Dibyendu Majumdar wrote:
>> This occurs in calc_memop_addr() function when it tries to do following:
>>
>>  as = LLVMGetPointerAddressSpace(LLVMTypeOf(src));
>>
>> If I dump insn, insn->src, and the LLVM value and type before this line, I get:
>>
>> 1) insn load.64     %r18 <- 8[%r2]
>> 2) pseudo %r2
>> 3) store %struct.buffer_type_st* %R2, %struct.buffer_type_st** %26
>> 4) void
>>
>> The type of the LLVM store instruction is 'void'.
>>
>> My guess is that something is going horribly wrong in the way member
>> access is handled.
>>
>> If you are able to reproduce this and have any suggestions then please
>> let me know.
>
> Why I try your code (without LLVM assertions), I got indeed several
> problems:
>         Call parameter type does not match function signature!
>         i0 16
>          i64  %1 = call i8* @malloc(i0 16)

I have the function argument fix so I don't get the malloc error.

>         Invalid bitcast
>           %27 = bitcast void <badref> to i8**
>         Both operands to a binary operator are not of the same type!

I think this corresponds to the code that fails - the type of the LLVM
instruction is 'void' and the code is trying to cast to it or
something.

>           %R31 = add void <badref>, i64 %R30
>         Stored value type does not match pointer operand type!
>           store void %R31, i8** %46
>

The code aborts at previous step

> The first one is really weird but I think you don't see it.

It is the function call issue, for which I have a fix I described.

> The next two I have no idea.
> The fourth have something obviously wrong with the type of its 'target'.

> However, while running sparse-llvm on some code sample I use to test
> the linearization, I see that most errors are type errors and are
> related to pointer arithmetic, exactly where LLVM's getelemptr is used.
> Most offending instructions are OP_ADD (but since I have tests for
> bitfields I see also errors for OP_AND, OP_OR & OP_LSR).
> I guess that if you test OP_ADD instruction with pointer on one side
> and integer on tne other side and issue an appropriate LLVMBuildGEP(),
> things will already be much better.
>

Here is the output from linearize. I think the way stores and loads
are handled is broken. It appears that the last store / load
instruction is stored in insn->target->priv, and then used later on
... I do not understand what the code is trying to do. Is it trying to
optimize away stores and loads?

grow_allocator:
.L0000022DAFA94A88:
        <entry-point>
        call.64     %r1 <- malloc, $16
        ptrcast.64  %r2 <- (64) %r1
        load.64     %r4 <- 32[%arg1]
        load.64     %r6 <- 40[%arg1]
        mulu.64     %r7 <- %r4, %r6
        call.64     %r8 <- malloc, %r7
        ptrcast.64  %r9 <- (64) %r8
        store.64    %r9 -> 8[%r2]
        load.64     %r12 <- 0[%arg1]
        store.64    %r12 -> 0[%r2]
        store.64    %r2 -> 0[%arg1]
        load.64     %r18 <- 8[%r2]
        store.64    %r18 -> 16[%arg1]
        load.64     %r23 <- 32[%arg1]
        load.64     %r25 <- 40[%arg1]
        mulu.64     %r26 <- %r23, %r25
        add.64      %r27 <- %r18, %r26
        store.64    %r27 -> 24[%arg1]
        ret
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 16:30:53 +0000
Message-ID: <CACXZuxdr9ubL6S8PEzAHtOt9AT=PjYcv_8EotLD8_Cagc7ZGPw () mail ! gmail ! com>
--------------------
On 2 March 2017 at 16:29, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
> Hi Luc,
>
> On 2 March 2017 at 16:04, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> On Thu, Mar 02, 2017 at 02:33:09PM +0000, Dibyendu Majumdar wrote:
>>> This occurs in calc_memop_addr() function when it tries to do following:
>>>
>>>  as = LLVMGetPointerAddressSpace(LLVMTypeOf(src));
>>>
>>> If I dump insn, insn->src, and the LLVM value and type before this line, I get:
>>>
>>> 1) insn load.64     %r18 <- 8[%r2]
>>> 2) pseudo %r2
>>> 3) store %struct.buffer_type_st* %R2, %struct.buffer_type_st** %26
>>> 4) void
>>>
>>> The type of the LLVM store instruction is 'void'.
>>>
>>> My guess is that something is going horribly wrong in the way member
>>> access is handled.
>>>
>>> If you are able to reproduce this and have any suggestions then please
>>> let me know.
>>
>> Why I try your code (without LLVM assertions), I got indeed several
>> problems:
>>         Call parameter type does not match function signature!
>>         i0 16
>>          i64  %1 = call i8* @malloc(i0 16)
>
> I have the function argument fix so I don't get the malloc error.
>
>>         Invalid bitcast
>>           %27 = bitcast void <badref> to i8**
>>         Both operands to a binary operator are not of the same type!
>
> I think this corresponds to the code that fails - the type of the LLVM
> instruction is 'void' and the code is trying to cast to it or
> something.
>
>>           %R31 = add void <badref>, i64 %R30
>>         Stored value type does not match pointer operand type!
>>           store void %R31, i8** %46
>>
>
> The code aborts at previous step
>
>> The first one is really weird but I think you don't see it.
>
> It is the function call issue, for which I have a fix I described.
>
>> The next two I have no idea.
>> The fourth have something obviously wrong with the type of its 'target'.
>
>> However, while running sparse-llvm on some code sample I use to test
>> the linearization, I see that most errors are type errors and are
>> related to pointer arithmetic, exactly where LLVM's getelemptr is used.
>> Most offending instructions are OP_ADD (but since I have tests for
>> bitfields I see also errors for OP_AND, OP_OR & OP_LSR).
>> I guess that if you test OP_ADD instruction with pointer on one side
>> and integer on tne other side and issue an appropriate LLVMBuildGEP(),
>> things will already be much better.
>>
>
> Here is the output from linearize. I think the way stores and loads
> are handled is broken. It appears that the last store / load
> instruction is stored in insn->target->priv, and then used later on
> ... I do not understand what the code is trying to do. Is it trying to
> optimize away stores and loads?
>
> grow_allocator:
> .L0000022DAFA94A88:
>         <entry-point>
>         call.64     %r1 <- malloc, $16
>         ptrcast.64  %r2 <- (64) %r1
>         load.64     %r4 <- 32[%arg1]
>         load.64     %r6 <- 40[%arg1]
>         mulu.64     %r7 <- %r4, %r6
>         call.64     %r8 <- malloc, %r7
>         ptrcast.64  %r9 <- (64) %r8
>         store.64    %r9 -> 8[%r2]
>         load.64     %r12 <- 0[%arg1]
>         store.64    %r12 -> 0[%r2]
>         store.64    %r2 -> 0[%arg1]
>         load.64     %r18 <- 8[%r2]
>         store.64    %r18 -> 16[%arg1]
>         load.64     %r23 <- 32[%arg1]
>         load.64     %r25 <- 40[%arg1]
>         mulu.64     %r26 <- %r23, %r25
>         add.64      %r27 <- %r18, %r26
>         store.64    %r27 -> 24[%arg1]
>         ret

Just to clarify I mean above that the way Sparse-LLVM handles it is broken.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 16:39:38 +0000
Message-ID: <CACXZuxemR+d9J+PZN0wpUOSFS8eP+1QhzM=YiJQ13xV3hYKvJQ () mail ! gmail ! com>
--------------------
Hi Luc,

On 2 March 2017 at 05:21, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Wed, Mar 01, 2017 at 02:45:03PM +0000, Dibyendu Majumdar wrote:
>> On 1 March 2017 at 10:58, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
>> > On 28 February 2017 at 17:03, Luc Van Oostenryck
>> > <luc.vanoostenryck@gmail.com> wrote:
>> >> On Tue, Feb 28, 2017 at 4:09 PM, Luc Van Oostenryck
>> >> <luc.vanoostenryck@gmail.com> wrote:
>> >>> There is indeed some problems regarding this, we looked a bit at this
>> >>> some weeks ago. However I firmly believe that the information about
>> >>> the type belong to the operations and not the values.
>> >>
>> >
>> > I am trying to work out how a value pseudo correct type can be
>> > determined when the pseudo is a function call argument. Would
>> > appreciate any pointers on this. The current implementation of
>> > pseudo_to_value() uses the function call instruction which is
>> > incorrect.
>> >
>>
>> I have implemented a solution that get the type information from the
>> function prototype for pseudo values when processing function
>> arguments, but not sure this is correct.
>
> You need something like:
> +struct symbol *argument_type(pseudo_t src)
> +{
> +       struct entrypoint *ep = src->def->bb->ep;
> +       struct symbol_list *args = ep->name->ctype.base_type->arguments;
> +       struct symbol *arg;
> +       int i = 0;
> +       FOR_EACH_PTR(args, arg) {
> +               if (++i == src->nr)
> +                       return arg;
> +       } END_FOR_EACH_PTR(arg);
> +
> +       assert(0);
> +}
>
>> Anyway have hit a bunch of other issues with sparse-llvm ... :-(
>
> Each day its problem (and happily its solution too!).
>

I am using the following fix. There is some noise below as this code
is from modified version.


static LLVMValueRef pseudo_val_to_value(struct dmr_C *C, struct
function *fn, LLVMTypeRef type, pseudo_t pseudo)
{
 assert(pseudo->type == PSEUDO_VAL);
 LLVMValueRef result = NULL;
 switch (LLVMGetTypeKind(type)) {
 case LLVMPointerTypeKind:
  if (pseudo->value == 0)
   result = LLVMConstPointerNull(type);
  else
   result = LLVMConstIntToPtr(
    LLVMConstInt(
     LLVMIntType(C->target->bits_in_pointer),
     pseudo->value, 1),
    type);
  break;
 case LLVMIntegerTypeKind:
  result = LLVMConstInt(type, pseudo->value, 1);
  break;
 default:
  assert(0);
 }
 // ORIGINAL result = LLVMConstInt(type, pseudo->value, 1);
 // PREVIOUS FIX result = LLVMConstInt(LLVMInt64Type(), pseudo->value, 1);
 return result;
}

static LLVMValueRef pseudo_to_value(struct dmr_C *C, struct function
*fn, struct instruction *insn, pseudo_t pseudo)
{
 ...
 case PSEUDO_VAL: {
  LLVMTypeRef type = insn_symbol_type(C, fn->module, insn);
  result = pseudo_val_to_value(C, fn, type, pseudo);
  break;
 }
 ...
}

static void output_op_call(struct dmr_C *C, struct function *fn,
struct instruction *insn)
{
 LLVMValueRef target, func;
 int n_arg = 0, i;
 struct pseudo *arg;
 LLVMValueRef *args;
 pseudo_t function_proto = insn->func;
 int n_proto_args = 0;
 struct symbol *proto_symbol = function_proto->sym->ctype.base_type;
 struct symbol *proto_arg;
 struct symbol **proto_args;
 /* count function prototype args, get prototype argument symbols */
 FOR_EACH_PTR(proto_symbol->arguments, proto_arg) {
  n_proto_args++;
 } END_FOR_EACH_PTR(proto_arg);
 proto_args = alloca(n_proto_args * sizeof(struct symbol *));
 int idx = 0;
 FOR_EACH_PTR(proto_symbol->arguments, proto_arg) {
  proto_args[idx++] = proto_arg->ctype.base_type;
 } END_FOR_EACH_PTR(proto_arg);
 n_arg = 0;
 FOR_EACH_PTR(insn->arguments, arg) {
  n_arg++;
 } END_FOR_EACH_PTR(arg);
 if (n_arg != n_proto_args) {
  fprintf(stderr, "Mismatch in function arguments\n");
  abort();
 }
 args = alloca(n_arg * sizeof(LLVMValueRef));
 i = 0;
 FOR_EACH_PTR(insn->arguments, arg) {
  if (arg->type == PSEUDO_VAL) {
   /* as value pseudo do not have type information we use the
      function prototype to decide types */
   LLVMTypeRef type = symbol_type(C, fn->module, proto_args[i]);
   args[i] = pseudo_val_to_value(C, fn, type, arg);
  }
  else {
   args[i] = pseudo_to_value(C, fn, insn, arg);
  }
  i++;
 } END_FOR_EACH_PTR(arg);
 func = pseudo_to_value(C, fn, insn, insn->func);
 target = LLVMBuildCall(fn->builder, func, args, n_arg, "");
 insn->target->priv = target;
}
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 17:18:16 +0000
Message-ID: <CACXZuxdaYwKm2pJV3zbusUbUdKx2M-nVjSJBfV6G4QwTY1vJ-A () mail ! gmail ! com>
--------------------
Hi Luc,

I was looking at whether I can use the standard LLVM GEP api to access
struct and array members in sparse-llvm. I noticed that the output
from sparse has byte offsets of each member - but not the member's
ordinal position. To use the native LLVM methods we would have to
allow LLVM to work out byte offsets, and just use the struct or array
definition. This would I think make the code more robust and also lead
to better optimisation.

Unfortunately LLVM does not support unions so for unions a bit of what
is being done now is probably needed, but even here it is better to
cast a union to its member struct type and then use LLVM GEP api to
access its members.

What do you think?

I think adding the ordinal position to sparse symbols is a trivial
enhancement - do you agree?

Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 17:21:55 +0000
Message-ID: <20170302172154.5wpphmfnvtfhyu4c () macpro ! local>
--------------------
On Thu, Mar 02, 2017 at 04:39:38PM +0000, Dibyendu Majumdar wrote:
> I am using the following fix. There is some noise below as this code
> is from modified version.

OK, thanks.
I'll look at this a bit later, possibly tomorrow.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 17:27:50 +0000
Message-ID: <20170302172749.xopyshzxwcags4m6 () macpro ! local>
--------------------
On Thu, Mar 02, 2017 at 05:04:04PM +0100, Luc Van Oostenryck wrote:
> However, while running sparse-llvm on some code sample I use to test
> the linearization, I see that most errors are type errors and are
> related to pointer arithmetic, exactly where LLVM's getelemptr is used.
> Most offending instructions are OP_ADD (but since I have tests for 
> bitfields I see also errors for OP_AND, OP_OR & OP_LSR).
> I guess that if you test OP_ADD instruction with pointer on one side
> and integer on tne other side and issue an appropriate LLVMBuildGEP(),
> things will already be much better.

Another place, that clearly need some more love and attention is
output_op_ptrcast() (and possibly outpout_op_cast() too):
Not all OP_PTRCAST can be mapped to an LLVM bitcast, only the ones
wich doesn't change the size can (and even, I'm not suer all can).

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 17:36:13 +0000
Message-ID: <CACXZuxfjJfDFuHkgMA+2V0tpuh-is15_sx0AJt+2EyjG7v6Y2g () mail ! gmail ! com>
--------------------
On 2 March 2017 at 17:18, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Mar 02, 2017 at 04:30:53PM +0000, Dibyendu Majumdar wrote:
>> > Here is the output from linearize. I think the way stores and loads
>> > are handled is broken. It appears that the last store / load
>> > instruction is stored in insn->target->priv, and then used later on
>> > ... I do not understand what the code is trying to do. Is it trying to
>> > optimize away stores and loads?
>
> No, no.
> What is stored in ->priv is the target's  LLVMValueRef (and for a store
> the 'target' is what need to be stored).
> And indeed there is a bug there: it's target_in that should be stored in
> ->priv (in fact, for a store, there is no need to put anything at all
> in this field; at least I don't see any reason why it should).
> Nice catch.
> I don't know how it's related to your problem though.
>

My question was why is something being stored in 'priv' and used
later? That seems to be an optimisation? Why not recompute every time?

I think this caching in 'priv' and using it later is the cause of the
wrong code - unless as you say the value stored in 'priv' is incorrect
and needs fixing.

Regards
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 17:43:54 +0000
Message-ID: <20170302174353.4tb664cnfjjtxk5t () macpro ! local>
--------------------
On Thu, Mar 02, 2017 at 05:18:16PM +0000, Dibyendu Majumdar wrote:
> Hi Luc,
> 
> I was looking at whether I can use the standard LLVM GEP api to access
> struct and array members in sparse-llvm. I noticed that the output
> from sparse has byte offsets of each member - but not the member's
> ordinal position.

Indeed, when the offset is a compile constant otherwise the offset
is set to zero and there is a pair OP_MUL/OP_ADD before that does
the needed pointer arithmetic.

> To use the native LLVM methods we would have to
> allow LLVM to work out byte offsets, and just use the struct or array
> definition. This would I think make the code more robust and also lead
> to better optimisation.

I'm not sure to understand here: which byte offsets need to be worked out?

Also, for the optimization, I wouldn't worry for now because:
- the linearized code is already optimized (nothing sophisticated but the
  essential is already there)
- you can always later call LLVM's optimization passes
- the code selector will also do some optimization.

> Unfortunately LLVM does not support unions so for unions a bit of what
> is being done now is probably needed, but even here it is better to
> cast a union to its member struct type and then use LLVM GEP api to
> access its members.
> 
> What do you think?

Honestly, I think nothing because I don't understand enough the issues
with sparse-llvm and what LLVM needs.

> I think adding the ordinal position to sparse symbols is a trivial
> enhancement - do you agree?

Unless I'm misunderstand what you mean, these postion are already there
but not explicitly: you can lookup the lists to see what position a field
in a structure is.
If you need the byte offsets, those are already available (or trivialy
calculable).

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 17:50:00 +0000
Message-ID: <20170302174959.kh7x5bmwccl7fpig () macpro ! local>
--------------------
On Thu, Mar 02, 2017 at 05:03:06PM +0000, Dibyendu Majumdar wrote:
> On 2 March 2017 at 16:29, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
> > Here is the output from linearize. I think the way stores and loads
> > are handled is broken. It appears that the last store / load
> > instruction is stored in insn->target->priv, and then used later on
> > ... I do not understand what the code is trying to do. Is it trying to
> > optimize away stores and loads?
> >
> > grow_allocator:
> > .L0000022DAFA94A88:
> >         <entry-point>
> >         call.64     %r1 <- malloc, $16
> >         ptrcast.64  %r2 <- (64) %r1
> >         load.64     %r4 <- 32[%arg1]
> >         load.64     %r6 <- 40[%arg1]
> >         mulu.64     %r7 <- %r4, %r6
> >         call.64     %r8 <- malloc, %r7
> >         ptrcast.64  %r9 <- (64) %r8
> >         store.64    %r9 -> 8[%r2]
> >         load.64     %r12 <- 0[%arg1]
> >         store.64    %r12 -> 0[%r2]
> 
> It appears that the sparse-llvm code is storing the LLVM instruction
> for '%r2' in pseudo->priv.
> 
> >         store.64    %r2 -> 0[%arg1]

Ah yes, it overwrite the correct value previously stored there (the
LLVMValueRef corresponding to %r2) with the return value of LLVMBuildStore().

> And then it using the value of the store instruction whenever it sees '%r2'?
> 
> >         load.64     %r18 <- 8[%r2]
> 
> But here it fails because it needs to cast the LLVM store instruction
> to be a pointer to access 8[]?

Yes, now anything using %r2 will go wrong.

Removing the last line of output_op_store() (insn->target->priv = target;)
should fix this.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 17:57:22 +0000
Message-ID: <CAExDi1QY1+KEsdzBuy0aorDwzvoL2Vos-F5P1HsJZCjT9o0R0w () mail ! gmail ! com>
--------------------
On Thu, Mar 2, 2017 at 6:49 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>>
>> It appears that the sparse-llvm code is storing the LLVM instruction
>> for '%r2' in pseudo->priv.
>>
>> >         store.64    %r2 -> 0[%arg1]
>
> Ah yes, it overwrite the correct value previously stored there (the
> LLVMValueRef corresponding to %r2) with the return value of LLVMBuildStore().
>
>> And then it using the value of the store instruction whenever it sees '%r2'?
>>
>> >         load.64     %r18 <- 8[%r2]
>>
>> But here it fails because it needs to cast the LLVM store instruction
>> to be a pointer to access 8[]?
>
> Yes, now anything using %r2 will go wrong.
>
> Removing the last line of output_op_store() (insn->target->priv = target;)
> should fix this.


In fact LLVMBuildStore() return a LLVMValueRef.
Could this be the 'void' we seen?

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 18:02:10 +0000
Message-ID: <CACXZuxfR6HNzvzkCLy1R2bik4R2p9t1i1+fga91GP-SnMAkwmQ () mail ! gmail ! com>
--------------------
On 2 March 2017 at 17:57, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> Removing the last line of output_op_store() (insn->target->priv = target;)
>> should fix this.
>
> In fact LLVMBuildStore() return a LLVMValueRef.
> Could this be the 'void' we seen?
>

It returns a Value that is a store instruction, or at least that's the
way I interpret this and so yes, I think the type of this was void.

BTW removing the line makes progress, but it fails at the add
instruction later. Are there other issues like this you can spot? I am
a bit lost here I am afraid.

Regards
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 18:41:35 +0000
Message-ID: <CACXZuxf8-L6hy+TOd6pfmiAhoOXc-K5YJwUjonmmOGxv_djVnA () mail ! gmail ! com>
--------------------
Hi Luc,

On 2 March 2017 at 16:04, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> However, while running sparse-llvm on some code sample I use to test
> the linearization, I see that most errors are type errors and are
> related to pointer arithmetic, exactly where LLVM's getelemptr is used.
> Most offending instructions are OP_ADD (but since I have tests for
> bitfields I see also errors for OP_AND, OP_OR & OP_LSR).
> I guess that if you test OP_ADD instruction with pointer on one side
> and integer on tne other side and issue an appropriate LLVMBuildGEP(),
> things will already be much better.
>

This seems spot on as by making change as below, the final assertion
failure went away. I have not yet checked the generated code but that
is next.

 case OP_ADD:
  if (symbol_is_fp_type(C, insn->type))
   target = LLVMBuildFAdd(fn->builder, lhs, rhs, target_name);
  else {
   if (LLVMGetTypeKind(LLVMTypeOf(lhs)) == LLVMPointerTypeKind) {
    target = LLVMBuildGEP(fn->builder, lhs, &rhs, 1, "");
   }
   else if (LLVMGetTypeKind(LLVMTypeOf(lhs)) == LLVMPointerTypeKind) {
    target = LLVMBuildGEP(fn->builder, rhs, &lhs, 1, "");
   }
   else {
    target = LLVMBuildAdd(fn->builder, lhs, rhs, target_name);
   }
  }
  break;

Thanks and Regards
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 18:58:26 +0000
Message-ID: <CACXZuxfkYqgPxE3OGdz7funUJtB6=K3TTwhzyZLJ=Kcio_7HXg () mail ! gmail ! com>
--------------------
On 2 March 2017 at 17:43, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Mar 02, 2017 at 05:18:16PM +0000, Dibyendu Majumdar wrote:
>> Hi Luc,
>>
>> I was looking at whether I can use the standard LLVM GEP api to access
>> struct and array members in sparse-llvm. I noticed that the output
>> from sparse has byte offsets of each member - but not the member's
>> ordinal position.
>
> Indeed, when the offset is a compile constant otherwise the offset
> is set to zero and there is a pair OP_MUL/OP_ADD before that does
> the needed pointer arithmetic.
>
>> To use the native LLVM methods we would have to
>> allow LLVM to work out byte offsets, and just use the struct or array
>> definition. This would I think make the code more robust and also lead
>> to better optimisation.
>
> I'm not sure to understand here: which byte offsets need to be worked out?

You use the GEP API which allows you say that you want to access field
5 from a struct, and so on. Here 5 is the fifth field. LLVM works out
the rest. This is better than casting the struct to char* and then
doing pointer arithmetic.

>
> Also, for the optimization, I wouldn't worry for now because:
> - the linearized code is already optimized (nothing sophisticated but the
>   essential is already there)
> - you can always later call LLVM's optimization passes
> - the code selector will also do some optimization.
>

Sure but my experience with LLVM is that it needs to have type
metadata for each store and load instruction to properly do type based
alias analysis. Otherwise it will miss optimisation opportunities.
Maybe we can still provide type metadata as we do have the symbol
definition etc.

But I agree that if sparse-llvm works correctly for all inputs then
that is a big step forward (for me) !

Regards
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Thu, 02 Mar 2017 20:09:17 +0000
Message-ID: <20170302200916.4agmd5jihtkzyvp5 () macpro ! local>
--------------------
On Thu, Mar 02, 2017 at 06:18:43PM +0100, Luc Van Oostenryck wrote:
> > > Here is the output from linearize. I think the way stores and loads
> > > are handled is broken. It appears that the last store / load
> > > instruction is stored in insn->target->priv, and then used later on
> > > ... I do not understand what the code is trying to do. Is it trying to
> > > optimize away stores and loads?
> 
> No, no.
> What is stored in ->priv is the target's  LLVMValueRef (and for a store
> the 'target' is what need to be stored).
> And indeed there is a bug there: it's target_in that should be stored in
> ->priv (in fact, for a store, there is no need to put anything at all
> in this field; at least I don't see any reason why it should).
> Nice catch.
> I don't know how it's related to your problem though.

OK, I've just checked and indeed removing this assignment to ->priv
in output_op_store() was wrong and is most probably very related to
your problem. I used something as simple as:
	void foo(int *p, int a, int b)
	{
		int c = a + b;
	
		p[0] = c;
		p[1] = c;
	}

Which returned:
	Stored value type does not match pointer operand type!
	  store void <badref>, i32* %8

And with this assignment removed this error is no more and the
generated LLVM IR is:
	define void @foo(i32*, i32, i32) {
	  %R3 = add i32 %1, %2
	  %3 = bitcast i32* %0 to i8*
	  %4 = getelementptr inbounds i8, i8* %3, i64 0
	  %5 = bitcast i8* %4 to i32*
	  store i32 %R3, i32* %5
	  %6 = bitcast i32* %0 to i8*
	  %7 = getelementptr inbounds i8, i8* %6, i64 4
	  %8 = bitcast i8* %7 to i32*
	  store i32 %R3, i32* %8
	  ret void
	}

And the generated x86 code is:
	addl	%edx, %esi
	movl	%esi, (%rdi)
	movl	%esi, 0x4(%rdi)
	retq


Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Fri, 03 Mar 2017 03:01:12 +0000
Message-ID: <CACXZuxfSUVhOis7449hLZPrFvoTy_cV5UTJSS3VVtTGKDZy64Q () mail ! gmail ! com>
--------------------
On 3 March 2017 at 02:52, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
> Hi Luc,
>
> Next problem:
>
> The following fails.
>
> typedef unsigned long long size_t;
> struct buffer_type_st {
>  struct buffer_type_st    *next_buffer;
>  char           *buffer;
> };
> typedef struct buffer_type_st buffer_type_t;
> struct link_st {
>  struct link_st           *next;
> };
> typedef struct link_st link_t;
> struct allocator_st {
>  buffer_type_t    *buffer_list;
>  link_t           *free_list;
>  char           *next_avail;
>  char           *last;
>  size_t          size;
>  size_t          n;
> };
> typedef struct allocator_st allocator;
> extern void *
> alloc_node(allocator * a);
> extern void
> grow_allocator(allocator * a);
> void *
> alloc_node(allocator * a)
> {
>  link_t           *tmp;
>  tmp = a->free_list;
>  return (void *) tmp;
> }
>
>
> I get LLVM assertion failure for following instruction:
>
> insn cast.64     %r4 <- (64) %r2
>
> Assertion failed: isa<X>(Val) && "cast<Ty>() argument of incompatible
> type!", file C:\d\llvm-3.9.0.src\include\llvm/Support/Casting.h, line
> 237
>
> I think this is because the linearize is outputting an integer cast
> rather than pointer cast so LLVM is not happy.
>

Simpler example:

void *
alloc_node(void)
{
 char *tmp;
 tmp = (void *)0;
 return tmp;
}
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Fri, 03 Mar 2017 04:16:27 +0000
Message-ID: <20170303041625.h23go4vlynqitvy3 () macpro ! local>
--------------------
On Fri, Mar 03, 2017 at 02:52:00AM +0000, Dibyendu Majumdar wrote:
> I think this is because the linearize is outputting an integer cast
> rather than pointer cast so LLVM is not happy.

Yes, it's very possible.
As I said, in another mail yesterday, output_op_ptrcast()
need some changes. It makes the assumption that the cast
is always between type of the same size (and so generate
a LLVM's bitcast). But in sparse, OP_PTRCAST is used for
all cast to a non-void pointer type.

Luc

> p.s. should I start a new thread for each separate issue?

Yes, please.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Fri, 03 Mar 2017 04:21:22 +0000
Message-ID: <CAExDi1SyhYmf7i6htgGXjU1pKmoz_53m4HjkP=PS11zRK8m38w () mail ! gmail ! com>
--------------------
On Thu, Mar 2, 2017 at 7:02 PM, Dibyendu Majumdar
<mobile@majumdar.org.uk> wrote:
>> In fact LLVMBuildStore() return a LLVMValueRef.
>> Could this be the 'void' we seen?
>>
>
> It returns a Value that is a store instruction, or at least that's the
> way I interpret this and so yes, I think the type of this was void.

I failed to find doc about it. But anwyay, overwritting the target->priv
can't be correct.

> BTW removing the line makes progress, but it fails at the add
> instruction later. Are there other issues like this you can spot? I am
> a bit lost here I am afraid.
No, not like this. What I saw was just the result of looking at your
example and trying to understand what's happening.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Fri, 03 Mar 2017 04:38:35 +0000
Message-ID: <CACXZuxd-ZbSdwENfSaqCEtQEf8i22CXhDjA_hkyigKhL2wZTiw () mail ! gmail ! com>
--------------------
On 3 March 2017 at 04:27, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Fri, Mar 03, 2017 at 02:52:00AM +0000, Dibyendu Majumdar wrote:
>> I get LLVM assertion failure for following instruction:
>>
>> insn cast.64     %r4 <- (64) %r2
>>
>> Assertion failed: isa<X>(Val) && "cast<Ty>() argument of incompatible
>> type!", file C:\d\llvm-3.9.0.src\include\llvm/Support/Casting.h, line
>> 237
>>
>> I think this is because the linearize is outputting an integer cast
>> rather than pointer cast so LLVM is not happy.
>
> Yes.
> Here I have something that talk more to me:
>         ZExt only operates on integer
>           %R4 = zext %struct.link_st* %load_target to i8*
>

Also by casting to an integer subsequent operations fail. Any idea why
cast is being output rather than ptrcast?

Regards
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Sparse-LLVM issue compiling NULL pointers
Date: Fri, 03 Mar 2017 07:50:44 +0000
Message-ID: <CAExDi1T++WcupS6iiOkhuzuV8pgtuqAL9ftbQF00AQdABeoQFQ () mail ! gmail ! com>
--------------------
On Fri, Mar 3, 2017 at 5:38 AM, Dibyendu Majumdar
<mobile@majumdar.org.uk> wrote:
> Also by casting to an integer subsequent operations fail. Any idea why
> cast is being output rather than ptrcast?

Yes, it's because casts to void* is not considered as a pointer cast,
the rationale
being that a void* will need to be casted toa real pointer before being used.

Have you still problem after the patch I sent earlier (cfr:
https://patchwork.kernel.org/patch/9602045/ )?

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse-llvm question ===

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Sparse-llvm question
Date: Thu, 26 Jan 2017 17:27:17 +0000
Message-ID: <CACXZuxeosx_qH3E5+gjnhx1czrSup5ZT0tm=kUqcp5u178twhA () mail ! gmail ! com>
--------------------
Hi

I am hoping to reuse the Sparse-llvm component as a JIT compiler for C
in an application. I was playing around with it a bit and hit an
immediate issue. For instance compilation of a simple program like
this fails:

const char ident[] = "";

Is there a list of what works and what doesn't anywhere?

Thanks and Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Unreachable code diagnostic ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: Unreachable code diagnostic
Date: Fri, 24 Feb 2017 18:33:37 +0000
Message-ID: <CA+55aFwwv+tMb1-7u7EzVxLrn1CtdQ2Wu7jXTfxV7DrzrROmvg () mail ! gmail ! com>
--------------------
On Fri, Feb 24, 2017 at 10:07 AM, Matthew Wilcox <willy@infradead.org> wrote:
>
> Maybe sparse could warn about code after an unconditional return
> statement?

This is not likely to be a very successful model, I suspect.

You already partly see the problem:

> I wouldn't like to see it warn about code after a conditional
> return statement where the condition is always true; I think that would
> have a lot of false positives due to macros.

because the thing is, we actually have tons and tons of unreachable
code due to things like

   if (IS_ENABLED(CONFIG_XYZ)) {...

which allows us much cleaner code than using things like #ifdef's.

So yes, unreachable code in general is actually very common.

And it's not just in Linux - think of all the code you've ever seen
that has used "ASSERT()", which often ends up doing exactly the same
things. Even if you'd think that "when debugging isn't enabled, it
just goes away entirely", you often end up having things that
basically end up expanding to things like

    do { if (0) {..} } while (0)

inside macros very consciously in order to avoid compiler warnings
about unused variables etc when the variable is only used inside that
debug statement.

I realize that on the face of it, such a "if (0)" sounds insane, but
you can seriously just grep for that pattern in Linux:

    [torvalds@i7 linux]$ git grep 'if (0)' | wc -l
    156

now, getting back to your "limit it _only_ to code after an
unconditional 'return' statement" suggestion. The reason I don't
believe that will be all that useful either, is that a reasonable C
compiler (or something like sparse) simply doesn't even see many
conditionals.

That comes largely from how the C pre-processor is such a separate
phase and not actually integrated with the C syntax itself. So if any
of the conditionals above end up being done as cpp macros, it's
basically pretty much impossible to see them.

You'd actually likely be better off with something that doesn't
actually really parse the C code, but parses the code _without_ doing
preprocessor expansion, and basically look at it without doing the
full code analysis. More like what tools like checkpatch etc do -
lookign for the superficial patterns, rather than the patterns that
you see when you actually expand everything.

I'm not disputing that you can always find particular cases where a
warning would make sense, I just have a very strong suspicion that you
end up having to limit the condition you search for _so_ much that it
ends up being basically pointless for anything but the one or two
cases you already knew about and that triggered it.

              Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: Re: Unreachable code diagnostic
Date: Fri, 24 Feb 2017 19:26:53 +0000
Message-ID: <20170224192653.GA4480 () mwanda>
--------------------
Smatch works pretty well for finding unreachable code.

regards,
dan carpenter


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Unreachable code diagnostic
Date: Fri, 24 Feb 2017 19:56:55 +0000
Message-ID: <20170224195654.3cd7bc2dz5mzhnlh () macpro ! local>
--------------------
On Fri, Feb 24, 2017 at 10:57:07AM -0800, Josh Triplett wrote:
> On Fri, Feb 24, 2017 at 10:07:59AM -0800, Matthew Wilcox wrote:
> > I was recently sent some code that looked like this:
> > 
> > int foo()
> > {
> > 	lock();
> > 	return bar();
> > 	unlock();
> > }
> > 
> > When you're restructuring code that contains locks, this is a
> > *really* easy mistake to make.  I've done it myself.  But there's no
> > compiler warning for it!  gcc doesn't have it, sparse doesn't have it.
> 
> Sparse does have a warning (via -Wcontext) for this, if you annotate
> lock() and unlock() with __acquires(somelock) and __releases(somelock),
> which expand to __attribute__((context(somelock,0,1))) and
> __attribute__((context(somelock,0,1))) respectively.  You'll get a
> warning that foo() returns with the lock held.
> 
> Not at all perfect, but it does have reasonable handling of
> conditionals, including a way to handle cond_lock().

Absolutely, -Wcontext is even enabled by default.
So with what is done in the kernel, you have something like:
	#define __acquires(x)  __attribute__((context(x,0,1)))
	#define __releases(x)  __attribute__((context(x,1,0)))
	
	void lock(void) __acquires(lock);
	void unlock(void) __releases(lock);
	
	int bar(void);
	
	static int foo(void)
	{
	        lock();
	        return bar();
	        unlock();
	}

For which sparse returns the following warning:
	zz.c:9:5: warning: context imbalance in 'foo' - wrong count at exit

But of course, that's just for code properly lock/context annotated and I'm
not sure if what you're asking, which is much more general, is only motivated
by lock/unlock problems or by others problems too.

Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Unreachable code diagnostic
Date: Fri, 24 Feb 2017 20:11:53 +0000
Message-ID: <20170224201152.7skvolezq4j75su6 () macpro ! local>
--------------------
On Fri, Feb 24, 2017 at 10:33:37AM -0800, Linus Torvalds wrote:
> On Fri, Feb 24, 2017 at 10:07 AM, Matthew Wilcox <willy@infradead.org> wrote:
> >
> > Maybe sparse could warn about code after an unconditional return
> > statement?
> 
> This is not likely to be a very successful model, I suspect.
> 
> You already partly see the problem:
> 
> > I wouldn't like to see it warn about code after a conditional
> > return statement where the condition is always true; I think that would
> > have a lot of false positives due to macros.
> 
> because the thing is, we actually have tons and tons of unreachable
> code due to things like
> 
>    if (IS_ENABLED(CONFIG_XYZ)) {...
> 
> which allows us much cleaner code than using things like #ifdef's.
> 
> So yes, unreachable code in general is actually very common.
> 

snip snip 

> 
> now, getting back to your "limit it _only_ to code after an
> unconditional 'return' statement" suggestion. The reason I don't
> believe that will be all that useful either, is that a reasonable C
> compiler (or something like sparse) simply doesn't even see many
> conditionals.
> 
> That comes largely from how the C pre-processor is such a separate
> phase and not actually integrated with the C syntax itself. So if any
> of the conditionals above end up being done as cpp macros, it's
> basically pretty much impossible to see them.
> 
> You'd actually likely be better off with something that doesn't
> actually really parse the C code, but parses the code _without_ doing
> preprocessor expansion, and basically look at it without doing the
> full code analysis. More like what tools like checkpatch etc do -
> lookign for the superficial patterns, rather than the patterns that
> you see when you actually expand everything.
> 
> I'm not disputing that you can always find particular cases where a
> warning would make sense, I just have a very strong suspicion that you
> end up having to limit the condition you search for _so_ much that it
> ends up being basically pointless for anything but the one or two
> cases you already knew about and that triggered it.
> 
>               Linus


I'm not very sure what are the cases in wich Matthew is really
interested but I suppose that, even after preprocessing and
elimination of if (0) {...}, a return statement in the middle
of a compound statement is very often unintentional. 
That should be easy to check.


Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: Unreachable code diagnostic
Date: Fri, 24 Feb 2017 20:43:56 +0000
Message-ID: <20170224204356.hhfvnd6ballotrqu () x>
--------------------
On Fri, Feb 24, 2017 at 09:11:53PM +0100, Luc Van Oostenryck wrote:
> I'm not very sure what are the cases in wich Matthew is really
> interested but I suppose that, even after preprocessing and
> elimination of if (0) {...}, a return statement in the middle
> of a compound statement is very often unintentional. 
> That should be easy to check.

By "middle of a compound statement", you mean an unconditional return
followed by more code?  Yes, that seems like something reasonable to
statically check.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: Unreachable code diagnostic
Date: Fri, 24 Feb 2017 20:47:10 +0000
Message-ID: <20170224204710.hlhjv7ncir25ptd6 () macpro ! local>
--------------------
On Fri, Feb 24, 2017 at 12:43:56PM -0800, Josh Triplett wrote:
> On Fri, Feb 24, 2017 at 09:11:53PM +0100, Luc Van Oostenryck wrote:
> > I'm not very sure what are the cases in wich Matthew is really
> > interested but I suppose that, even after preprocessing and
> > elimination of if (0) {...}, a return statement in the middle
> > of a compound statement is very often unintentional. 
> > That should be easy to check.
> 
> By "middle of a compound statement", you mean an unconditional return
> followed by more code?  Yes, that seems like something reasonable to
> statically check.
> 
> - Josh Triplett

Yes, it's what I meant.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Matthew Wilcox <willy () infradead ! org>
To: linux-sparse
Subject: Re: Unreachable code diagnostic
Date: Fri, 24 Feb 2017 21:05:51 +0000
Message-ID: <20170224210551.GC16328 () bombadil ! infradead ! org>
--------------------
On Fri, Feb 24, 2017 at 10:57:07AM -0800, Josh Triplett wrote:
> On Fri, Feb 24, 2017 at 10:07:59AM -0800, Matthew Wilcox wrote:
> > I was recently sent some code that looked like this:
> > 
> > int foo()
> > {
> > 	lock();
> > 	return bar();
> > 	unlock();
> > }
> > 
> > When you're restructuring code that contains locks, this is a
> > *really* easy mistake to make.  I've done it myself.  But there's no
> > compiler warning for it!  gcc doesn't have it, sparse doesn't have it.
> 
> Sparse does have a warning (via -Wcontext) for this, if you annotate
> lock() and unlock() with __acquires(somelock) and __releases(somelock),
> which expand to __attribute__((context(somelock,0,1))) and
> __attribute__((context(somelock,0,1))) respectively.  You'll get a
> warning that foo() returns with the lock held.
> 
> Not at all perfect, but it does have reasonable handling of
> conditionals, including a way to handle cond_lock().

Ah, yes, thanks.  I didn't actually try to compile the patch I was
sent ... I was just bemused that the compiler didn't warn about this
"obvious" wrongness.  So I wrote a test-case, which of course didn't have
any lock annotations.  rcu_read_lock()/unlock() are correctly annotated
and applying the patch I sent produces a sparse (and not gcc) warning.
So I've asked the submitter to run sparse in future.

(of course, this means they have to ignore all the *other* pre-existing
sparse warnings, but that's not the fault of anyone on this mailing list)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Urgent Please,, ===

From: Joyes Dadi <"YD." () biscuit ! ocn ! ne ! jp>
To: linux-sparse
Subject: Urgent Please,,
Date: Mon, 23 Jan 2017 14:07:54 +0000
Message-ID: <1307460608.25784291.1485180474314.JavaMail.root () biscuit ! ocn ! ne ! jp>
--------------------
Good Day Dear,

My name is Ms. Joyes Dadi, I am glad you are reading this letter and I hope
we will start our communication and I know that this message will look strange,
surprising and probably unbelievable to you, but it is the reality. I want to
make a donation of money to you.

I contact you by the will of God. I am a firm German woman specialized in
mining gold and diamonds in Africa. But now, I'm very sick of a cancer. My
husband died in an accident two years ago with our two children and now I have
cancer of the esophagus that damaged almost all the cells in my system/agencies
and I'll die soon according to my doctor.

My most concern now is, we grew up in the orphanage and were married in
orphanage. If I die this deposited fund will soon be left alone in the hand of
the bank, and I do want to it that  way. Please, if you can be reliable and
sincere to accept my humble proposal; I have (10.5Millions Euro) in a fixed
deposit account; I will order the Bank to transfer the money into your account
in your country immediately, and then you will take the fund to  your country
and invest it to the orphanage homes Please, answer as quickly as possible.

God bless you.
Ms. Joyes Dadi
Email: joyesdadi767@citromail.hu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Work With Us! ===

From: "YCIL" <jefepolitico.atahualpa () mdieloro ! gob ! ec>
To: linux-sparse
Subject: Work With Us!
Date: Wed, 15 Nov 2017 21:07:32 +0000
Message-ID: <20171115205520.234BB9645E7 () mail ! mdieloro ! gob ! ec>
--------------------
 Our Company Yunnan Copper Industry (Group) Co., Ltd, based in India is
in search of a competent Corporate Individual or Company/Firm that will be responsible in handling funds as our ''Representative Manager'' in the United
States/Canada region. If interested kindly email our Human Resources
Department for more description of the job, compensations and monthly salary involved.

Note: It is a part time job that won't interrupt your present work or
business. Also please note especially that we will require a Company/Business Account where the
payments from our clients will be sent to for you to help us receive.

Looking forward to your response.

PLEASE IGNORE IF THIS IS NOT YOUR DIRECT EMAIL ADDRESS AND ALSO 
IF YOU DO NOT HAVE A COMPANY/BUSINESS ACCOUNT TO RECEIVE THE FUNDS!
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [GIT PULL] debug build of sparse v4 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [GIT PULL] debug build of sparse v4
Date: Wed, 18 Oct 2017 21:26:18 +0000
Message-ID: <CANeU7QmUzmvhTVpiKmET76qgoZf60yxM3_URAt-auiR12trh4A () mail ! gmail ! com>
--------------------
Hi,

This is the V4 version of the debug build change.

https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=debug-target-v4

This change allow sparse to build debug version of sparse
along side of the release version. The debug build of sparse
can be used by patches like ptrlist ref count to check the nest
loop modify usage. The debug build can add other verification feature
that might slow down sparse.

I plan to merge that to master. If there is other objections, it is
a good time to raise it now.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: Re: [GIT PULL] debug build of sparse v4
Date: Thu, 19 Oct 2017 12:42:07 +0000
Message-ID: <8f1174fe-6d7c-e640-d0cf-db7000658570 () kleine-koenig ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 4880 and 3156)
--G5RrnNAWmLFH5g2QNFXV8cQ7o60JhRSS7
Content-Type: multipart/mixed; boundary="U2Glc9nt2DajUKA7dsJvjkqIqUPLWkkWo";
 protected-headers="v1"
From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe@kleine-koenig.org>
To: Christopher Li <sparse@chrisli.org>,
 Linux-Sparse <linux-sparse@vger.kernel.org>
Cc: Jeff Layton <jlayton@redhat.com>,
 Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Message-ID: <8f1174fe-6d7c-e640-d0cf-db7000658570@kleine-koenig.org>
Subject: Re: [GIT PULL] debug build of sparse v4
References: <CANeU7QmUzmvhTVpiKmET76qgoZf60yxM3_URAt-auiR12trh4A@mail.gmail.com>
In-Reply-To: <CANeU7QmUzmvhTVpiKmET76qgoZf60yxM3_URAt-auiR12trh4A@mail.gmail.com>

--U2Glc9nt2DajUKA7dsJvjkqIqUPLWkkWo
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: quoted-printable

Hello,

On 10/18/2017 11:26 PM, Christopher Li wrote:
> This change allow sparse to build debug version of sparse
> along side of the release version. The debug build of sparse
> can be used by patches like ptrlist ref count to check the nest
> loop modify usage. The debug build can add other verification feature
> that might slow down sparse.

I wonder about the name. From a debug build (in contrast to a release
build) I would expect that it allows to debug sparse itself (Think: add
-g to gcc, or (not) -DNODEBUG for assert(3)), but I understand you use
that term differently here.

Why not do the the extra tests when called as (say)

	sparse --aggressive

=2E Then there is no need for an extra binary at all keeping the build
system simple and that also makes it it easier to understand for users
(but I might judge others by my own standards here?) For gcc this flag
is -Wall, there isn't an extra binary either.

Best regards
Uwe


--U2Glc9nt2DajUKA7dsJvjkqIqUPLWkkWo--

--G5RrnNAWmLFH5g2QNFXV8cQ7o60JhRSS7
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEfnIqFpAYrP8+dKQLwfwUeK3K7AkFAlnonZ8ACgkQwfwUeK3K
7AnBAAf7BgBn1LQGgDABT2owwoliYBRzE7vvdpTGjwWzzMiNjkkN/JTf8bxGdrws
gnbAVSQO/JRyC7XjwgXg8sqFV+4F1gErj3W+xpNgxF6B0FL/70bca6CmGzyIZK1W
SvOABnWw4qYScCMqGt/of+lvzUHnvbKuWzgEaNjqVz6wPi/ebGAilFWLfOxJr9SK
0hNm5K8+ejXRiDpj5I2cQKx6fasGpVAkWXwSvOJM9qUrDI987XhZcAA0JctrKmqw
XyHtZQNiIrqoMbpawPNsUVwNkB9TgxiwGObwq+fUqHF47R2UI9bl6Gjiqd+ileRg
XLCym9FRU8w8l59Hgt5HFxlbD0omNw==
=KKWe
-----END PGP SIGNATURE-----

--G5RrnNAWmLFH5g2QNFXV8cQ7o60JhRSS7--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] debug build of sparse v4
Date: Thu, 19 Oct 2017 16:50:31 +0000
Message-ID: <CANeU7Qk8-YwH77roYfHf2++wbRY72AY5nqL8P+C7VF2JJ30J1g () mail ! gmail ! com>
--------------------
On Thu, Oct 19, 2017 at 5:42 AM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.o=
rg> wrote:
>
> I wonder about the name. From a debug build (in contrast to a release
> build) I would expect that it allows to debug sparse itself (Think: add
> -g to gcc, or (not) -DNODEBUG for assert(3)), but I understand you use
> that term differently here.

The name if mechanical. You can suggest better names. I am
more focus on allowing two version of sparse can be compile
at the same time.

>
> Why not do the the extra tests when called as (say)
>
>         sparse --aggressive
>

Yes, actually that is what I have in mind. When "--aggressive"
is turn on, sparse will execute "dbg-sparse" to enable those aggressive
code path. The optional name is subject to change.

> . Then there is no need for an extra binary at all keeping the build
> system simple and that also makes it it easier to understand for users
> (but I might judge others by my own standards here?) For gcc this flag
> is -Wall, there isn't an extra binary either.

There is still need for extra binary because some verification can be
slow sparse and hard to turn off without impact the sparse performance.
For example the ptr list ref count patch. It is execute at every ptrlist
bucket iteration.

If there is no performance impact on when those verification
is turn off. Then yes, there is no need for a separate binary.
I haven't done concrete measurement of the slow down.
I just assume that there will be some.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] debug build of sparse v4
Date: Thu, 19 Oct 2017 19:17:15 +0000
Message-ID: <CAMHZB6GA3jGm7n6bsoZzhEz0CaiTVzhKfJ7EwnUwZBDzoTMqpQ () mail ! gmail ! com>
--------------------
On Thu, Oct 19, 2017 at 6:50 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Oct 19, 2017 at 5:42 AM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig=
.org> wrote:
>
> Yes, actually that is what I have in mind. When "--aggressive"
> is turn on, sparse will execute "dbg-sparse" to enable those aggressive
> code path. The optional name is subject to change.
>
>> . Then there is no need for an extra binary at all keeping the build
>> system simple and that also makes it it easier to understand for users
>> (but I might judge others by my own standards here?) For gcc this flag
>> is -Wall, there isn't an extra binary either.
>
> There is still need for extra binary because some verification can be
> slow sparse and hard to turn off without impact the sparse performance.
> For example the ptr list ref count patch. It is execute at every ptrlist
> bucket iteration.
>
> If there is no performance impact on when those verification
> is turn off. Then yes, there is no need for a separate binary.

The questions that really matter are:
- who will use these extra binaries?
- in which circonstances?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] debug build of sparse v4
Date: Thu, 19 Oct 2017 19:39:08 +0000
Message-ID: <CAMHZB6G_1NkgucsVN1oiw2na_9BZKCOgqS9yggEL517LPsFFcg () mail ! gmail ! com>
--------------------
On Thu, Oct 19, 2017 at 6:39 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Wed, Oct 18, 2017 at 3:18 PM, Luc Van Oostenryck <luc.vanoostenryck@gmail.com> wrote:
>> No real objections but I have some doubts about all the debug part.
>> I think that people hacking on sparse and who need to debug know
>> what they need and want to debug.
>
> Right, this change is to allow a separate debug binary let say "dbg-sparse",
> to be execute from "sparse" when needed.

My point is: if "when needed" means "when sparse developpers
need to debug something" then I really think all this is not needed
as the dev can very well build the executable he needs, with the
options he needs, use his own workflow, ...

> Take the ptrlist ref count checking for example. I image have
> sparse --check-ptrlist, which will invoke dbg-sparse to do the
> checking. I expect the distro will include dbg-sparse as part
> of the sparse package as well.

Really? Are the distros interested in this sort of things? Is there
a real need for it? Who do you really think will use this?

> The end result is that. The user of sparse, not sparse developers,
> can invoke sparse with those extra verification (at cost of slow
> down sparse) on the custom input source without modify and
> recompile sparse.

Yes *can* ... but will they?
Why isn't there a dbg-gcc, dbg-bash, ... ?

>> For example, the OPT=0 is, IMO, useless as you generally need
>> others flags too. Also, when you debug, you generally need to rerun
>> things several times, so using extra options on the command line is
>> not ideal (a mechanism like local.mk is better suited but local.mk
>> itself is not).
>
> In that case, you can just OPT=0 into local.mk and problem solved?
> Even if you do that, you still need to provide OPT variable for overwrite
> purpose. Append and reset the whole variable is easy.
> Partial modify the content of variable from one to another is harder and
> annoying.
>
> Can you clarify "but local.mk itself is not".

If you have a sort of config file, or anything allowing to adapt things
to your needs, you want at least to have a dot file for it.
But for a project using git, you also want that the file doesn't interfer
with git status but also with git clean (including git clean -x).

>> Also, what's the real need for dbgbuild/ & debug/ ?
>> IMO, it's a big complexification of all the rules with plenty of
>> duplicated things for very few, if any, benefits.
>
> Provide extra verification on user input files. Another candidate
> of those verification can be, the sorting of ptrlist.

> There is function  verify_seq_sorted () verify the list is indeed sorted.
> But that function currently is not turn on in sparse. Presumably
> it is used in the development phase of the ptr list sorting.
> That verification function can be turn on in the debug build for example.

Yes *can* ...
Same questions: who will use this and when? Are extra binaries and
duplicated build rules a good answer for this?

More broadly: what problem do you try to solve with these patches?
What values do these patches bring to sparse?
Does sparse need these patches?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: Re: [GIT PULL] debug build of sparse v4
Date: Sun, 22 Oct 2017 13:09:18 +0000
Message-ID: <39fa7788-cfba-eee5-9085-41f08b42f0a8 () kleine-koenig ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 4880 and 3156)
--5t2e6AjjmN2AX2JfSUUi6sIBhWaOPweeG
Content-Type: multipart/mixed; boundary="en5AAjxAIfCukmOLRdILL64lb3LjdElwL";
 protected-headers="v1"
From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe@kleine-koenig.org>
To: Christopher Li <sparse@chrisli.org>
Cc: Linux-Sparse <linux-sparse@vger.kernel.org>,
 Jeff Layton <jlayton@redhat.com>,
 Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Message-ID: <39fa7788-cfba-eee5-9085-41f08b42f0a8@kleine-koenig.org>
Subject: Re: [GIT PULL] debug build of sparse v4
References: <CANeU7QmUzmvhTVpiKmET76qgoZf60yxM3_URAt-auiR12trh4A@mail.gmail.com>
 <8f1174fe-6d7c-e640-d0cf-db7000658570@kleine-koenig.org>
 <CANeU7Qk8-YwH77roYfHf2++wbRY72AY5nqL8P+C7VF2JJ30J1g@mail.gmail.com>
In-Reply-To: <CANeU7Qk8-YwH77roYfHf2++wbRY72AY5nqL8P+C7VF2JJ30J1g@mail.gmail.com>

--en5AAjxAIfCukmOLRdILL64lb3LjdElwL
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: quoted-printable

On 10/19/2017 06:50 PM, Christopher Li wrote:
> On Thu, Oct 19, 2017 at 5:42 AM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koen=
ig.org> wrote:
>>
>> I wonder about the name. From a debug build (in contrast to a release
>> build) I would expect that it allows to debug sparse itself (Think: ad=
d
>> -g to gcc, or (not) -DNODEBUG for assert(3)), but I understand you use=

>> that term differently here.
>=20
> The name if mechanical. You can suggest better names. I am
> more focus on allowing two version of sparse can be compile
> at the same time.
>=20
>>
>> Why not do the the extra tests when called as (say)
>>
>>         sparse --aggressive
>>
>=20
> Yes, actually that is what I have in mind. When "--aggressive"
> is turn on, sparse will execute "dbg-sparse" to enable those aggressive=

> code path. The optional name is subject to change.
>=20
>> . Then there is no need for an extra binary at all keeping the build
>> system simple and that also makes it it easier to understand for users=

>> (but I might judge others by my own standards here?) For gcc this flag=

>> is -Wall, there isn't an extra binary either.
>=20
> There is still need for extra binary because some verification can be
> slow sparse and hard to turn off without impact the sparse performance.=

> For example the ptr list ref count patch. It is execute at every ptrlis=
t
> bucket iteration.
>=20
> If there is no performance impact on when those verification
> is turn off. Then yes, there is no need for a separate binary.
> I haven't done concrete measurement of the slow down.
> I just assume that there will be some.

I would first implement doing everything in a single binary and only
think about the complicated split in a "normal" and an "aggressive"
sparse binary if the overhead is too high and people start wailing.

(And even then I'd first check if using the equivalent of unlikely() in
the kernel would help by assuming that passing --aggressive is "unlikely"=
=2E)

IMHO the cost of a complicated build system is to high to not first try
the alternatives.

Best regards
Uwe


--en5AAjxAIfCukmOLRdILL64lb3LjdElwL--

--5t2e6AjjmN2AX2JfSUUi6sIBhWaOPweeG
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEfnIqFpAYrP8+dKQLwfwUeK3K7AkFAlnsmH4ACgkQwfwUeK3K
7AkCjAf7Be7PPIKCq2tnG+V0M9XUIugZ5TNyjfh6L5CNRkUy1gdh92rBNwjWLkja
KJjrnqWew5vLExBV2ZUjhMhQ2GMuAN+Uc7Q/ForzWyaOrIzcwi8LG6l53cI5gPS4
NJhuvq/Cr/Q+SwClIa3voUlXH40LCAhDXn4cVtuxS85dMXfRqyJpqIWCex9Mp59x
QfbvI0Wx44rFZEhp9ihg8bOfnAb+rRWf5xS003gip+wdnH/VViWJBJElC40gVANy
wtYVHO6VShesIFP7vH4sCf9tDE7rBxXdMTDiOzUmElAu6QeVXxEqWyC6Q8aXEsnu
DcxZCW7UKsaaVVf0BxMjTt7t6BIh8Q==
=2Em4
-----END PGP SIGNATURE-----

--5t2e6AjjmN2AX2JfSUUi6sIBhWaOPweeG--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] debug build of sparse v4
Date: Sun, 05 Nov 2017 07:24:57 +0000
Message-ID: <CANeU7Q=D2GVN+XzQa=y=zsN8pyQ+CAPJeAmAp_UZ9JC=7AY2Gw () mail ! gmail ! com>
--------------------
On Fri, Oct 20, 2017 at 3:39 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> My point is: if "when needed" means "when sparse developpers
> need to debug something" then I really think all this is not needed
> as the dev can very well build the executable he needs, with the
> options he needs, use his own workflow, ...
>
>> Take the ptrlist ref count checking for example. I image have
>> sparse --check-ptrlist, which will invoke dbg-sparse to do the
>> checking. I expect the distro will include dbg-sparse as part
>> of the sparse package as well.
>
> Really? Are the distros interested in this sort of things? Is there
> a real need for it? Who do you really think will use this?

To get back on this. I think we user report sparse bugs.
We can ask them to run debug version of sparse to report
or catch more bugs.

For example. The default version of sparse does not have
the ptrlist nest modify detect feature. The debug version of
sparse has. It is actually hard to ask user to check out a git
version of sparse, build it with debug options, then run the
test again.

With debug version of sparse shipped as part of sparse, this
can be simplified.

>
>> The end result is that. The user of sparse, not sparse developers,
>> can invoke sparse with those extra verification (at cost of slow
>> down sparse) on the custom input source without modify and
>> recompile sparse.
>
> Yes *can* ... but will they?
> Why isn't there a dbg-gcc, dbg-bash, ... ?

If we install debug version and invoke them properly, I don't see
why distro will not take it.

Debug version of clang exist. It just not everybody use it.
I don't see a need to for debug version of bash. Because sparse
doing optimization and transformation etc. It is very delicate.
As long as the debug version does provide some value, I think
it is fine to include them as part of the binary.

>
> If you have a sort of config file, or anything allowing to adapt things
> to your needs, you want at least to have a dot file for it.
> But for a project using git, you also want that the file doesn't interfer
> with git status but also with git clean (including git clean -x).

I think that is why local.mk was in .gitignore. For my usage
case, there is clearly need that I want some per host
config to plug into the Makefile.


> Yes *can* ...
> Same questions: who will use this and when? Are extra binaries and
> duplicated build rules a good answer for this?

Again, it is for the user who report sparse bugs.

> More broadly: what problem do you try to solve with these patches?

I want to include the ptrlist nest  modify detect patch into sparse.

> What values do these patches bring to sparse?

See above.

> Does sparse need these patches?

I think so.


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [GIT PULL] fix for rare crashes ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] fix for rare crashes
Date: Sat, 29 Jul 2017 16:07:16 +0000
Message-ID: <CANeU7QmcSUQBQ0WZz35a9CnZJavFq3X-k=KakhvS4q4+Y70hww () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 8:53 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Chris, this pull request is for the rare crashes fixes
> discovered after -rc4.
> The changes since the initial post are:
> - add a note to patch 1
> - avoid an unneeded allocation in patch 4
> - add a missing signoff

Thanks for the patches.

Pull and push to sparse-next already. I rebase some other patch in the
sparse-next
after you change. Let me know if you notices any problems.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [GIT PULL] llvm fixes ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [GIT PULL] llvm fixes
Date: Mon, 18 Sep 2017 09:51:35 +0000
Message-ID: <20170918095135.12066-1-luc.vanoostenryck () gmail ! com>
--------------------
Chris,

Please, pull these patches for master. 

No surprises here, it's just all March's good old fixes
for sparse-llvm which have been rebased on top of rc5.

Thanks,
Luc

----------------------------------------------------------------
The following changes since commit 90859bb4e3f9ad11f76ad42e3dce84043bdc3176:

  Bump sparse's version to -rc5 (2017-08-11 18:17:41 +0200)

are available in the git repository at:

  git://github.com/lucvoo/sparse.git llvm-fixes

for you to fetch changes up to fa5266b1770cf8d97158beb290af084082cd335a:

  llvm: fix creation of sparsec's tmp files (2017-08-12 16:05:11 +0200)

----------------------------------------------------------------
Luc Van Oostenryck (68):
      show OP_PHI without VOID
      don't output value of anonymous symbol's pointer
      add table to "negate" some opcode
      use opcode table for compare_opcode()
      canonicalize binops before simplification
      canonicalize compare instructions
      add is_signed_type()
      fix usage of inlined calls
      inlined calls should not block BB packing
      give function's arguments a type via OP_PUSH
      insure that all OP_PUSHs are just before their OP_CALL
      give a type to OP_PHISOURCEs
      give a type to OP_SELs, always
      give a type to OP_SWITCHs
      add doc about sparse's instructions/IR
      add support for wider type in switch-case
      llvm: remove unneeded arg 'module'
      llvm: remove unneeded 'generation'
      llvm: remove unneeded function::type
      llvm: reduce scope of 'bb_nr'
      llvm: use pseudo_list_size() instead of open coding it
      llvm: give arguments a name
      llvm: give a name to call's return values
      llvm: avoid useless temp variable
      llvm: extract get_sym_value() from pseudo_to_value()
      llvm: fix test of floating-point type
      llvm: fix translation of PSEUDO_VALs into a ValueRefs
      llvm: fix output_op_store() which modify its operand
      llvm: fix output_op_[ptr]cast()
      llvm: take care of degenerated rvalues
      llvm: add test cases for symbol's address
      llvm: add test cases for pointers passed as argument
      llvm: add test cases for arrays passed as argument
      llvm: add test cases for degenerated pointers
      llvm: add support for OP_NEG
      llvm: add support for OP_SETVAL with floats
      llvm: add support for OP_SETVAL with labels
      llvm: ignore OP_INLINED_CALL
      llvm: fix pointer/float mixup in comparisons
      llvm: fix type in comparison with an address constant
      llvm: give correct type to binops
      llvm: adjust OP_RET's type
      llvm: variadic functions are not being marked as such
      llvm: fix type of switch constants
      llvm: make pseudo_name() more flexible
      llvm: give a name to all values
      llvm: add support for OP_SWITCH with a range
      llvm: fix OP_SWITCH has no target
      llvm: make value_to_pvalue() more flexible
      llvm: make value_to_ivalue() more flexible
      llvm: add test case pointer compare with cast
      llvm: let pseudo_to_value() directly use the type
      llvm: remove unneeded pseudo_to_value() unneeded argument
      llvm: introduce get_ioperand()
      llvm: fix mutating function pointer
      llvm: fix mutated OP_RET
      llvm: fix mutated OP_SEL
      llvm: fix mutated OP_SWITCH
      llvm: fix mutated OP_PHISOURCE
      llvm: fix mutated OP_[PTR]CAST
      llvm: add support for restricted types
      llvm: fix get value from initialized symbol
      llvm: fix get value from non-anonymous symbol
      llvm: fix type of bitfields
      llvm: add support for OP_FPCAST
      llvm: add support for cast from floats
      llvm: cleanup of output_[ptr]cast()
      llvm: fix creation of sparsec's tmp files

 Documentation/instructions.txt          | 296 ++++++++++++++++
 Makefile                                |   1 +
 compile-i386.c                          |  14 +-
 example.c                               |   4 +-
 flow.c                                  |   3 +-
 linearize.c                             |  80 +++--
 linearize.h                             |  17 +-
 liveness.c                              |  14 +-
 memops.c                                |   2 +-
 opcode.c                                |  36 ++
 opcode.h                                |  10 +
 show-parse.c                            |  11 +-
 simplify.c                              |  77 ++---
 sparse-llvm.c                           | 586 +++++++++++++++++++++-----------
 sparsec                                 |   4 +-
 symbol.h                                |   9 +
 validation/backend/cast.c               |   7 +-
 validation/backend/compare-with-null.c  |  12 +
 validation/backend/constant-pointer.c   |  24 ++
 validation/backend/degenerate-ptr.c     |  72 ++++
 validation/backend/function-ptr-xtype.c |  37 ++
 validation/backend/function-ptr.c       | 148 +++++++-
 validation/backend/label-as-value.c     |  13 +
 validation/backend/load-global.c        |  21 ++
 validation/backend/pointer-add.c        |  54 +++
 validation/backend/pointer-cmp.c        |  12 +
 validation/backend/pointer-param.c      |  42 +++
 validation/backend/pointer-sub.c        |  17 +
 validation/backend/setval.c             |   7 +
 validation/backend/shift-special.c      |  13 +
 validation/backend/store-x2.c           |  16 +
 validation/backend/string-value.c       |  21 ++
 validation/backend/switch.c             | 248 ++++++++++++++
 validation/backend/symaddr.c            |  70 ++++
 validation/backend/type-constant.c      |  23 ++
 validation/call-inlined.c               |  54 +++
 validation/call-variadic.c              |  31 ++
 validation/loop-linearization.c         |   9 +-
 validation/optim/call-inlined.c         |  30 ++
 validation/optim/canonical-cmp.c        | 124 +++++++
 validation/push-call.c                  |  26 ++
 validation/switch-long.c                |  47 +++
 42 files changed, 2024 insertions(+), 318 deletions(-)
 create mode 100644 Documentation/instructions.txt
 create mode 100644 opcode.c
 create mode 100644 opcode.h
 create mode 100644 validation/backend/compare-with-null.c
 create mode 100644 validation/backend/constant-pointer.c
 create mode 100644 validation/backend/degenerate-ptr.c
 create mode 100644 validation/backend/function-ptr-xtype.c
 create mode 100644 validation/backend/label-as-value.c
 create mode 100644 validation/backend/load-global.c
 create mode 100644 validation/backend/pointer-add.c
 create mode 100644 validation/backend/pointer-cmp.c
 create mode 100644 validation/backend/pointer-param.c
 create mode 100644 validation/backend/pointer-sub.c
 create mode 100644 validation/backend/setval.c
 create mode 100644 validation/backend/shift-special.c
 create mode 100644 validation/backend/store-x2.c
 create mode 100644 validation/backend/string-value.c
 create mode 100644 validation/backend/switch.c
 create mode 100644 validation/backend/symaddr.c
 create mode 100644 validation/backend/type-constant.c
 create mode 100644 validation/call-inlined.c
 create mode 100644 validation/call-variadic.c
 create mode 100644 validation/optim/call-inlined.c
 create mode 100644 validation/optim/canonical-cmp.c
 create mode 100644 validation/push-call.c
 create mode 100644 validation/switch-long.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [GIT PULL] llvm fixes
Date: Mon, 18 Sep 2017 09:51:35 +0000
Message-ID: <20170918095135.12066-1-luc.vanoostenryck () gmail ! com>
--------------------
Chris,

Please, pull these patches for master. 

No surprises here, it's just all March's good old fixes
for sparse-llvm which have been rebased on top of rc5.

Thanks,
Luc

----------------------------------------------------------------
The following changes since commit 90859bb4e3f9ad11f76ad42e3dce84043bdc3176:

  Bump sparse's version to -rc5 (2017-08-11 18:17:41 +0200)

are available in the git repository at:

  git://github.com/lucvoo/sparse.git llvm-fixes

for you to fetch changes up to fa5266b1770cf8d97158beb290af084082cd335a:

  llvm: fix creation of sparsec's tmp files (2017-08-12 16:05:11 +0200)

----------------------------------------------------------------
Luc Van Oostenryck (68):
      show OP_PHI without VOID
      don't output value of anonymous symbol's pointer
      add table to "negate" some opcode
      use opcode table for compare_opcode()
      canonicalize binops before simplification
      canonicalize compare instructions
      add is_signed_type()
      fix usage of inlined calls
      inlined calls should not block BB packing
      give function's arguments a type via OP_PUSH
      insure that all OP_PUSHs are just before their OP_CALL
      give a type to OP_PHISOURCEs
      give a type to OP_SELs, always
      give a type to OP_SWITCHs
      add doc about sparse's instructions/IR
      add support for wider type in switch-case
      llvm: remove unneeded arg 'module'
      llvm: remove unneeded 'generation'
      llvm: remove unneeded function::type
      llvm: reduce scope of 'bb_nr'
      llvm: use pseudo_list_size() instead of open coding it
      llvm: give arguments a name
      llvm: give a name to call's return values
      llvm: avoid useless temp variable
      llvm: extract get_sym_value() from pseudo_to_value()
      llvm: fix test of floating-point type
      llvm: fix translation of PSEUDO_VALs into a ValueRefs
      llvm: fix output_op_store() which modify its operand
      llvm: fix output_op_[ptr]cast()
      llvm: take care of degenerated rvalues
      llvm: add test cases for symbol's address
      llvm: add test cases for pointers passed as argument
      llvm: add test cases for arrays passed as argument
      llvm: add test cases for degenerated pointers
      llvm: add support for OP_NEG
      llvm: add support for OP_SETVAL with floats
      llvm: add support for OP_SETVAL with labels
      llvm: ignore OP_INLINED_CALL
      llvm: fix pointer/float mixup in comparisons
      llvm: fix type in comparison with an address constant
      llvm: give correct type to binops
      llvm: adjust OP_RET's type
      llvm: variadic functions are not being marked as such
      llvm: fix type of switch constants
      llvm: make pseudo_name() more flexible
      llvm: give a name to all values
      llvm: add support for OP_SWITCH with a range
      llvm: fix OP_SWITCH has no target
      llvm: make value_to_pvalue() more flexible
      llvm: make value_to_ivalue() more flexible
      llvm: add test case pointer compare with cast
      llvm: let pseudo_to_value() directly use the type
      llvm: remove unneeded pseudo_to_value() unneeded argument
      llvm: introduce get_ioperand()
      llvm: fix mutating function pointer
      llvm: fix mutated OP_RET
      llvm: fix mutated OP_SEL
      llvm: fix mutated OP_SWITCH
      llvm: fix mutated OP_PHISOURCE
      llvm: fix mutated OP_[PTR]CAST
      llvm: add support for restricted types
      llvm: fix get value from initialized symbol
      llvm: fix get value from non-anonymous symbol
      llvm: fix type of bitfields
      llvm: add support for OP_FPCAST
      llvm: add support for cast from floats
      llvm: cleanup of output_[ptr]cast()
      llvm: fix creation of sparsec's tmp files

 Documentation/instructions.txt          | 296 ++++++++++++++++
 Makefile                                |   1 +
 compile-i386.c                          |  14 +-
 example.c                               |   4 +-
 flow.c                                  |   3 +-
 linearize.c                             |  80 +++--
 linearize.h                             |  17 +-
 liveness.c                              |  14 +-
 memops.c                                |   2 +-
 opcode.c                                |  36 ++
 opcode.h                                |  10 +
 show-parse.c                            |  11 +-
 simplify.c                              |  77 ++---
 sparse-llvm.c                           | 586 +++++++++++++++++++++-----------
 sparsec                                 |   4 +-
 symbol.h                                |   9 +
 validation/backend/cast.c               |   7 +-
 validation/backend/compare-with-null.c  |  12 +
 validation/backend/constant-pointer.c   |  24 ++
 validation/backend/degenerate-ptr.c     |  72 ++++
 validation/backend/function-ptr-xtype.c |  37 ++
 validation/backend/function-ptr.c       | 148 +++++++-
 validation/backend/label-as-value.c     |  13 +
 validation/backend/load-global.c        |  21 ++
 validation/backend/pointer-add.c        |  54 +++
 validation/backend/pointer-cmp.c        |  12 +
 validation/backend/pointer-param.c      |  42 +++
 validation/backend/pointer-sub.c        |  17 +
 validation/backend/setval.c             |   7 +
 validation/backend/shift-special.c      |  13 +
 validation/backend/store-x2.c           |  16 +
 validation/backend/string-value.c       |  21 ++
 validation/backend/switch.c             | 248 ++++++++++++++
 validation/backend/symaddr.c            |  70 ++++
 validation/backend/type-constant.c      |  23 ++
 validation/call-inlined.c               |  54 +++
 validation/call-variadic.c              |  31 ++
 validation/loop-linearization.c         |   9 +-
 validation/optim/call-inlined.c         |  30 ++
 validation/optim/canonical-cmp.c        | 124 +++++++
 validation/push-call.c                  |  26 ++
 validation/switch-long.c                |  47 +++
 42 files changed, 2024 insertions(+), 318 deletions(-)
 create mode 100644 Documentation/instructions.txt
 create mode 100644 opcode.c
 create mode 100644 opcode.h
 create mode 100644 validation/backend/compare-with-null.c
 create mode 100644 validation/backend/constant-pointer.c
 create mode 100644 validation/backend/degenerate-ptr.c
 create mode 100644 validation/backend/function-ptr-xtype.c
 create mode 100644 validation/backend/label-as-value.c
 create mode 100644 validation/backend/load-global.c
 create mode 100644 validation/backend/pointer-add.c
 create mode 100644 validation/backend/pointer-cmp.c
 create mode 100644 validation/backend/pointer-param.c
 create mode 100644 validation/backend/pointer-sub.c
 create mode 100644 validation/backend/setval.c
 create mode 100644 validation/backend/shift-special.c
 create mode 100644 validation/backend/store-x2.c
 create mode 100644 validation/backend/string-value.c
 create mode 100644 validation/backend/switch.c
 create mode 100644 validation/backend/symaddr.c
 create mode 100644 validation/backend/type-constant.c
 create mode 100644 validation/call-inlined.c
 create mode 100644 validation/call-variadic.c
 create mode 100644 validation/optim/call-inlined.c
 create mode 100644 validation/optim/canonical-cmp.c
 create mode 100644 validation/push-call.c
 create mode 100644 validation/switch-long.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [GIT PULL] llvm fixes
Date: Mon, 18 Sep 2017 09:51:35 +0000
Message-ID: <20170918095135.12066-1-luc.vanoostenryck () gmail ! com>
--------------------
Chris,

Please, pull these patches for master. 

No surprises here, it's just all March's good old fixes
for sparse-llvm which have been rebased on top of rc5.

Thanks,
Luc

----------------------------------------------------------------
The following changes since commit 90859bb4e3f9ad11f76ad42e3dce84043bdc3176:

  Bump sparse's version to -rc5 (2017-08-11 18:17:41 +0200)

are available in the git repository at:

  git://github.com/lucvoo/sparse.git llvm-fixes

for you to fetch changes up to fa5266b1770cf8d97158beb290af084082cd335a:

  llvm: fix creation of sparsec's tmp files (2017-08-12 16:05:11 +0200)

----------------------------------------------------------------
Luc Van Oostenryck (68):
      show OP_PHI without VOID
      don't output value of anonymous symbol's pointer
      add table to "negate" some opcode
      use opcode table for compare_opcode()
      canonicalize binops before simplification
      canonicalize compare instructions
      add is_signed_type()
      fix usage of inlined calls
      inlined calls should not block BB packing
      give function's arguments a type via OP_PUSH
      insure that all OP_PUSHs are just before their OP_CALL
      give a type to OP_PHISOURCEs
      give a type to OP_SELs, always
      give a type to OP_SWITCHs
      add doc about sparse's instructions/IR
      add support for wider type in switch-case
      llvm: remove unneeded arg 'module'
      llvm: remove unneeded 'generation'
      llvm: remove unneeded function::type
      llvm: reduce scope of 'bb_nr'
      llvm: use pseudo_list_size() instead of open coding it
      llvm: give arguments a name
      llvm: give a name to call's return values
      llvm: avoid useless temp variable
      llvm: extract get_sym_value() from pseudo_to_value()
      llvm: fix test of floating-point type
      llvm: fix translation of PSEUDO_VALs into a ValueRefs
      llvm: fix output_op_store() which modify its operand
      llvm: fix output_op_[ptr]cast()
      llvm: take care of degenerated rvalues
      llvm: add test cases for symbol's address
      llvm: add test cases for pointers passed as argument
      llvm: add test cases for arrays passed as argument
      llvm: add test cases for degenerated pointers
      llvm: add support for OP_NEG
      llvm: add support for OP_SETVAL with floats
      llvm: add support for OP_SETVAL with labels
      llvm: ignore OP_INLINED_CALL
      llvm: fix pointer/float mixup in comparisons
      llvm: fix type in comparison with an address constant
      llvm: give correct type to binops
      llvm: adjust OP_RET's type
      llvm: variadic functions are not being marked as such
      llvm: fix type of switch constants
      llvm: make pseudo_name() more flexible
      llvm: give a name to all values
      llvm: add support for OP_SWITCH with a range
      llvm: fix OP_SWITCH has no target
      llvm: make value_to_pvalue() more flexible
      llvm: make value_to_ivalue() more flexible
      llvm: add test case pointer compare with cast
      llvm: let pseudo_to_value() directly use the type
      llvm: remove unneeded pseudo_to_value() unneeded argument
      llvm: introduce get_ioperand()
      llvm: fix mutating function pointer
      llvm: fix mutated OP_RET
      llvm: fix mutated OP_SEL
      llvm: fix mutated OP_SWITCH
      llvm: fix mutated OP_PHISOURCE
      llvm: fix mutated OP_[PTR]CAST
      llvm: add support for restricted types
      llvm: fix get value from initialized symbol
      llvm: fix get value from non-anonymous symbol
      llvm: fix type of bitfields
      llvm: add support for OP_FPCAST
      llvm: add support for cast from floats
      llvm: cleanup of output_[ptr]cast()
      llvm: fix creation of sparsec's tmp files

 Documentation/instructions.txt          | 296 ++++++++++++++++
 Makefile                                |   1 +
 compile-i386.c                          |  14 +-
 example.c                               |   4 +-
 flow.c                                  |   3 +-
 linearize.c                             |  80 +++--
 linearize.h                             |  17 +-
 liveness.c                              |  14 +-
 memops.c                                |   2 +-
 opcode.c                                |  36 ++
 opcode.h                                |  10 +
 show-parse.c                            |  11 +-
 simplify.c                              |  77 ++---
 sparse-llvm.c                           | 586 +++++++++++++++++++++-----------
 sparsec                                 |   4 +-
 symbol.h                                |   9 +
 validation/backend/cast.c               |   7 +-
 validation/backend/compare-with-null.c  |  12 +
 validation/backend/constant-pointer.c   |  24 ++
 validation/backend/degenerate-ptr.c     |  72 ++++
 validation/backend/function-ptr-xtype.c |  37 ++
 validation/backend/function-ptr.c       | 148 +++++++-
 validation/backend/label-as-value.c     |  13 +
 validation/backend/load-global.c        |  21 ++
 validation/backend/pointer-add.c        |  54 +++
 validation/backend/pointer-cmp.c        |  12 +
 validation/backend/pointer-param.c      |  42 +++
 validation/backend/pointer-sub.c        |  17 +
 validation/backend/setval.c             |   7 +
 validation/backend/shift-special.c      |  13 +
 validation/backend/store-x2.c           |  16 +
 validation/backend/string-value.c       |  21 ++
 validation/backend/switch.c             | 248 ++++++++++++++
 validation/backend/symaddr.c            |  70 ++++
 validation/backend/type-constant.c      |  23 ++
 validation/call-inlined.c               |  54 +++
 validation/call-variadic.c              |  31 ++
 validation/loop-linearization.c         |   9 +-
 validation/optim/call-inlined.c         |  30 ++
 validation/optim/canonical-cmp.c        | 124 +++++++
 validation/push-call.c                  |  26 ++
 validation/switch-long.c                |  47 +++
 42 files changed, 2024 insertions(+), 318 deletions(-)
 create mode 100644 Documentation/instructions.txt
 create mode 100644 opcode.c
 create mode 100644 opcode.h
 create mode 100644 validation/backend/compare-with-null.c
 create mode 100644 validation/backend/constant-pointer.c
 create mode 100644 validation/backend/degenerate-ptr.c
 create mode 100644 validation/backend/function-ptr-xtype.c
 create mode 100644 validation/backend/label-as-value.c
 create mode 100644 validation/backend/load-global.c
 create mode 100644 validation/backend/pointer-add.c
 create mode 100644 validation/backend/pointer-cmp.c
 create mode 100644 validation/backend/pointer-param.c
 create mode 100644 validation/backend/pointer-sub.c
 create mode 100644 validation/backend/setval.c
 create mode 100644 validation/backend/shift-special.c
 create mode 100644 validation/backend/store-x2.c
 create mode 100644 validation/backend/string-value.c
 create mode 100644 validation/backend/switch.c
 create mode 100644 validation/backend/symaddr.c
 create mode 100644 validation/backend/type-constant.c
 create mode 100644 validation/call-inlined.c
 create mode 100644 validation/call-variadic.c
 create mode 100644 validation/optim/call-inlined.c
 create mode 100644 validation/optim/canonical-cmp.c
 create mode 100644 validation/push-call.c
 create mode 100644 validation/switch-long.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Mon, 02 Oct 2017 19:49:54 +0000
Message-ID: <20171002194953.msf7j2uhoneczlob () ltop ! local>
--------------------
On Mon, Sep 18, 2017 at 11:51:35AM +0200, Luc Van Oostenryck wrote:
> Chris,
> 
> Please, pull these patches for master. 
> 
> No surprises here, it's just all March's good old fixes
> for sparse-llvm which have been rebased on top of rc5.
> 
> Thanks,
> Luc


Chris,

Can you handle this, please?


-- Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Mon, 16 Oct 2017 14:41:44 +0000
Message-ID: <20171016144143.5v2jehfmxcyhutrb () ltop ! local>
--------------------
On Mon, Sep 18, 2017 at 11:51:35AM +0200, Luc Van Oostenryck wrote:
> Chris,
> 
> Please, pull these patches for master. 
> 
> No surprises here, it's just all March's good old fixes
> for sparse-llvm which have been rebased on top of rc5.
> 
> Thanks,
> Luc


Chris,

This have been posted 4 weeks ago and I sent a reminder two weeks ago
but I haven't seen anything from you. Same for the patches series I sent
about the same time.

Is there any hopes to see things moving forward soon?

Regards,
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Mon, 16 Oct 2017 14:41:44 +0000
Message-ID: <20171016144143.5v2jehfmxcyhutrb () ltop ! local>
--------------------
On Mon, Sep 18, 2017 at 11:51:35AM +0200, Luc Van Oostenryck wrote:
> Chris,
> 
> Please, pull these patches for master. 
> 
> No surprises here, it's just all March's good old fixes
> for sparse-llvm which have been rebased on top of rc5.
> 
> Thanks,
> Luc


Chris,

This have been posted 4 weeks ago and I sent a reminder two weeks ago
but I haven't seen anything from you. Same for the patches series I sent
about the same time.

Is there any hopes to see things moving forward soon?

Regards,
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 29 Oct 2017 23:13:20 +0000
Message-ID: <CANeU7Qnu7h09YHhGVOY3r4M9FNOvOrs+kB_yJT-i0cSeLtKhAw () mail ! gmail ! com>
--------------------
On Mon, Sep 18, 2017 at 5:51 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Chris,
>
> Please, pull these patches for master.
>
> No surprises here, it's just all March's good old fixes
> for sparse-llvm which have been rebased on top of rc5.
>

Hi Luc,

Sorry for the delay. I will start to reply to your patch email in this series.
I have some feed back store on my computer a while back but I haven't
have to the chance send out the email.

Over all the the series seems good. It seems have some measurable
speed up in my stress test. There is one of two patch I will comment more
in the follow up email. I will reply in the order of the patch send
out. If a patch
does not have comment, that means it looks good to me.

BTW, I think a lot of the 68 patches can be break into smaller series.
There is some inter dependency but not that much especially relate to
the testsuite. Smaller series will make it easier to review.

More email to follow up.

Thanks for the series and sorry for the delay.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 29 Oct 2017 23:31:28 +0000
Message-ID: <CANeU7QmSeq8x4D3KK4_qkfjzb1T+4J=bJsnKNggBZrh6wC7n8Q () mail ! gmail ! com>
--------------------
On Mon, Sep 18, 2017 at 5:51 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Chris,
>
> Please, pull these patches for master.

Ah, I can't find the exact corresponding patch series in the email.
So I will just comment from the git change.
=========quote===========
commit ae7fd3b06c225fd8faf67c3e20db07b64eca7fc3
 don't output value of anonymous symbol's pointer

    The value of this pointer is of no use unless you're
    using a debugger (or just to see if two things are
    identical or not) and it's presence produces noise
    when comparing the output of two runs for testing.

    Change this by issuing it only if 'verbose' is set.
diff --git a/linearize.c b/linearize.c
index 42d1680..b69f838 100644
--- a/linearize.c
+++ b/linearize.c
@@ -120,7 +120,7 @@ const char *show_pseudo(pseudo_t pseudo)
                        break;
                }
                expr = sym->initializer;
-               snprintf(buf, 64, "<anon symbol:%p>", sym);
+               snprintf(buf, 64, "<anon symbol:%p>", verbose ? sym : NULL);
=======================================================

Very trivial feed back:

I think it is better not print out the %p for NULL.
Just skip the %p if not verbose was set.

BTW, I understand you are reluctant to make trivial change to very
old series of branch. That make sense.

In that case, I can make a topic branch to track the feedback and fix up
as incremental change. Then integrate that branch when all the feedback
settle down. I don't mind writing some feedback patches myself if
you prefer.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Mon, 30 Oct 2017 06:14:30 +0000
Message-ID: <20171030061429.uwdyfzjrr52hx6p3 () ltop ! local>
--------------------
On Mon, Oct 30, 2017 at 07:31:28AM +0800, Christopher Li wrote:
> On Mon, Sep 18, 2017 at 5:51 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > Chris,
> >
> > Please, pull these patches for master.
> 
> Ah, I can't find the exact corresponding patch series in the email.
> So I will just comment from the git change.
> =========quote===========
> commit ae7fd3b06c225fd8faf67c3e20db07b64eca7fc3
>  don't output value of anonymous symbol's pointer
> 
>     The value of this pointer is of no use unless you're
>     using a debugger (or just to see if two things are
>     identical or not) and it's presence produces noise
>     when comparing the output of two runs for testing.
> 
>     Change this by issuing it only if 'verbose' is set.
> diff --git a/linearize.c b/linearize.c
> index 42d1680..b69f838 100644
> --- a/linearize.c
> +++ b/linearize.c
> @@ -120,7 +120,7 @@ const char *show_pseudo(pseudo_t pseudo)
>                         break;
>                 }
>                 expr = sym->initializer;
> -               snprintf(buf, 64, "<anon symbol:%p>", sym);
> +               snprintf(buf, 64, "<anon symbol:%p>", verbose ? sym : NULL);
> =======================================================
> 
> Very trivial feed back:
> 
> I think it is better not print out the %p for NULL.
> Just skip the %p if not verbose was set.

Skipping the '%p' is more complex than what the patch here is doing.
Printing the NULL has also the advantage to have the same output format
which is usefull when the output is analysed by scripts.
 
> BTW, I understand you are reluctant to make trivial change to very
> old series of branch. That make sense.

Yes, "old series" is the keywords here: this series have been posted
in March, 7 months ago, and have never received any feedback.

> In that case, I can make a topic branch to track the feedback and fix up
> as incremental change. Then integrate that branch when all the feedback
> settle down. I don't mind writing some feedback patches myself if
> you prefer.

Well, given it has taken 7 months to have the first feedback, the
usefulness of this feedback and given the 'speed' at wich you handle
patches, pull requests or questions, I wonder how much months or years
this will take (and this series is only the very first one, many others
are waiing, albeit smaller ones, totalling about 230-400 patches).

If it wasn't clear yet: nor the quality of your feedback, nor its 'speed'
is of any use for doing development, on the contrary.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Mon, 30 Oct 2017 06:14:30 +0000
Message-ID: <20171030061429.uwdyfzjrr52hx6p3 () ltop ! local>
--------------------
On Mon, Oct 30, 2017 at 07:31:28AM +0800, Christopher Li wrote:
> On Mon, Sep 18, 2017 at 5:51 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > Chris,
> >
> > Please, pull these patches for master.
> 
> Ah, I can't find the exact corresponding patch series in the email.
> So I will just comment from the git change.
> =========quote===========
> commit ae7fd3b06c225fd8faf67c3e20db07b64eca7fc3
>  don't output value of anonymous symbol's pointer
> 
>     The value of this pointer is of no use unless you're
>     using a debugger (or just to see if two things are
>     identical or not) and it's presence produces noise
>     when comparing the output of two runs for testing.
> 
>     Change this by issuing it only if 'verbose' is set.
> diff --git a/linearize.c b/linearize.c
> index 42d1680..b69f838 100644
> --- a/linearize.c
> +++ b/linearize.c
> @@ -120,7 +120,7 @@ const char *show_pseudo(pseudo_t pseudo)
>                         break;
>                 }
>                 expr = sym->initializer;
> -               snprintf(buf, 64, "<anon symbol:%p>", sym);
> +               snprintf(buf, 64, "<anon symbol:%p>", verbose ? sym : NULL);
> =======================================================
> 
> Very trivial feed back:
> 
> I think it is better not print out the %p for NULL.
> Just skip the %p if not verbose was set.

Skipping the '%p' is more complex than what the patch here is doing.
Printing the NULL has also the advantage to have the same output format
which is usefull when the output is analysed by scripts.
 
> BTW, I understand you are reluctant to make trivial change to very
> old series of branch. That make sense.

Yes, "old series" is the keywords here: this series have been posted
in March, 7 months ago, and have never received any feedback.

> In that case, I can make a topic branch to track the feedback and fix up
> as incremental change. Then integrate that branch when all the feedback
> settle down. I don't mind writing some feedback patches myself if
> you prefer.

Well, given it has taken 7 months to have the first feedback, the
usefulness of this feedback and given the 'speed' at wich you handle
patches, pull requests or questions, I wonder how much months or years
this will take (and this series is only the very first one, many others
are waiing, albeit smaller ones, totalling about 230-400 patches).

If it wasn't clear yet: nor the quality of your feedback, nor its 'speed'
is of any use for doing development, on the contrary.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 08:29:57 +0000
Message-ID: <CANeU7QnFkJC4YePAdSTmKXNKiraCZHKJPSaNbKVPqdf01NhrYg () mail ! gmail ! com>
--------------------
>commit e4a0824120939235e40277a57425a72fbfcd5b9b
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Sun Mar 26 19:35:14 2017 +0200
>
>    add table to "negate" some opcode
>
>    Some optimizations transform an instruction opcode
>    into another. For example, it may be needed to know
>    the opcode corresponding to the negation of a comparison.
>
>    This patch make this easy and flexible by adding a table
>    for the relation between opcodes.

>+const struct opcode_table opcode_table[OP_LAST] = {
>+      [OP_SET_EQ] = { .negate = OP_SET_NE, },
>+      [OP_SET_NE] = { .negate = OP_SET_EQ, },
>+      [OP_SET_LT] = { .negate = OP_SET_GE, },
>+      [OP_SET_LE] = { .negate = OP_SET_GT, },
>+      [OP_SET_GE] = { .negate = OP_SET_LT, },
>+      [OP_SET_GT] = { .negate = OP_SET_LE, },
>+      [OP_SET_B ] = { .negate = OP_SET_AE, },
>+      [OP_SET_BE] = { .negate = OP_SET_A , },
>+      [OP_SET_AE] = { .negate = OP_SET_B , },
>+      [OP_SET_A ] = { .negate = OP_SET_BE, },
>+};

I think this patch ideally should be combined with the next patch.
As it is, this patch is not self contain. There is no user of this table.


>commit b38e2263075d1caa7694f47cc5f1cc8d78a2871d
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Mon Mar 27 17:19:43 2017 +0200
>
>    use opcode table for compare_opcode()
>
>    At the same time, change also the name of the function.
>
...
> static int simplify_seteq_setne(struct instruction *insn, long long value)
> {
>       pseudo_t old = insn->src1;
>@@ -484,7 +460,7 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)
>               // and similar for setne/eq ... 0/1
>               src1 = def->src1;
>               src2 = def->src2;
>-              insn->opcode = compare_opcode(opcode, inverse);
>+              insn->opcode = inverse ? opcode_table[opcode].negate : opcode;

I think it would be better to have some kind of assert check here, the opcode
you swap from the table is indeep opcode. Because you assign the opcode
array using sparse index. It is easy to miss a spot creating the empty slot in
the table.

Also, the opcode table might be able to compressed only contain
section of the BINCMP opcodes.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 08:29:57 +0000
Message-ID: <CANeU7QnFkJC4YePAdSTmKXNKiraCZHKJPSaNbKVPqdf01NhrYg () mail ! gmail ! com>
--------------------
>commit e4a0824120939235e40277a57425a72fbfcd5b9b
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Sun Mar 26 19:35:14 2017 +0200
>
>    add table to "negate" some opcode
>
>    Some optimizations transform an instruction opcode
>    into another. For example, it may be needed to know
>    the opcode corresponding to the negation of a comparison.
>
>    This patch make this easy and flexible by adding a table
>    for the relation between opcodes.

>+const struct opcode_table opcode_table[OP_LAST] = {
>+      [OP_SET_EQ] = { .negate = OP_SET_NE, },
>+      [OP_SET_NE] = { .negate = OP_SET_EQ, },
>+      [OP_SET_LT] = { .negate = OP_SET_GE, },
>+      [OP_SET_LE] = { .negate = OP_SET_GT, },
>+      [OP_SET_GE] = { .negate = OP_SET_LT, },
>+      [OP_SET_GT] = { .negate = OP_SET_LE, },
>+      [OP_SET_B ] = { .negate = OP_SET_AE, },
>+      [OP_SET_BE] = { .negate = OP_SET_A , },
>+      [OP_SET_AE] = { .negate = OP_SET_B , },
>+      [OP_SET_A ] = { .negate = OP_SET_BE, },
>+};

I think this patch ideally should be combined with the next patch.
As it is, this patch is not self contain. There is no user of this table.


>commit b38e2263075d1caa7694f47cc5f1cc8d78a2871d
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Mon Mar 27 17:19:43 2017 +0200
>
>    use opcode table for compare_opcode()
>
>    At the same time, change also the name of the function.
>
...
> static int simplify_seteq_setne(struct instruction *insn, long long value)
> {
>       pseudo_t old = insn->src1;
>@@ -484,7 +460,7 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)
>               // and similar for setne/eq ... 0/1
>               src1 = def->src1;
>               src2 = def->src2;
>-              insn->opcode = compare_opcode(opcode, inverse);
>+              insn->opcode = inverse ? opcode_table[opcode].negate : opcode;

I think it would be better to have some kind of assert check here, the opcode
you swap from the table is indeep opcode. Because you assign the opcode
array using sparse index. It is easy to miss a spot creating the empty slot in
the table.

Also, the opcode table might be able to compressed only contain
section of the BINCMP opcodes.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 08:49:37 +0000
Message-ID: <CANeU7Qk4AGhSzzpPXT1-NmWRzSprUXEjWm6o1iy8yKAb-TceQg () mail ! gmail ! com>
--------------------
>commit 5674da2d1af2467605fcc9b798fb54ee2d28efc7
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Mon Mar 20 15:18:53 2017 +0100
>
>    canonicalize compare instructions
>
>    Currently only commutative instructions are canonicalized
>    (the "simpler" operands, often a constant, is forced, if present
>    to be in the second operand). This improve CSE (more cases are
>    considered as equivalent) and help to reduce the number of "pattern"
>    to be handled at simplification.
>
> const struct opcode_table opcode_table[OP_LAST] = {
>-      [OP_SET_EQ] = { .negate = OP_SET_NE, },
>-      [OP_SET_NE] = { .negate = OP_SET_EQ, },
>-      [OP_SET_LT] = { .negate = OP_SET_GE, },
>-      [OP_SET_LE] = { .negate = OP_SET_GT, },
>-      [OP_SET_GE] = { .negate = OP_SET_LT, },
>-      [OP_SET_GT] = { .negate = OP_SET_LE, },
>-      [OP_SET_B ] = { .negate = OP_SET_AE, },
>-      [OP_SET_BE] = { .negate = OP_SET_A , },
>-      [OP_SET_AE] = { .negate = OP_SET_B , },
>-      [OP_SET_A ] = { .negate = OP_SET_BE, },
>+      [OP_SET_EQ] = { .negate = OP_SET_NE, .swap = OP_SET_EQ, },
>+      [OP_SET_NE] = { .negate = OP_SET_EQ, .swap = OP_SET_NE, },
>+      [OP_SET_LT] = { .negate = OP_SET_GE, .swap = OP_SET_GT, },
>+      [OP_SET_LE] = { .negate = OP_SET_GT, .swap = OP_SET_GE, },
>+      [OP_SET_GE] = { .negate = OP_SET_LT, .swap = OP_SET_LE, },
>+      [OP_SET_GT] = { .negate = OP_SET_LE, .swap = OP_SET_LT, },
>+      [OP_SET_B ] = { .negate = OP_SET_AE, .swap = OP_SET_A , },
>+      [OP_SET_BE] = { .negate = OP_SET_A , .swap = OP_SET_AE, },
>+      [OP_SET_AE] = { .negate = OP_SET_B , .swap = OP_SET_BE, },
>+      [OP_SET_A ] = { .negate = OP_SET_BE, .swap = OP_SET_B , },


Notice that LT and GT and equivalent instructions after swapping the src.
Another way to do it we might just remove one kind of instruction from the
sparse IR. From the linearization point just map GT into LT and swap the source.

So the IR does not allow those duplicated equilateral instructions. There is
less canonization to be done.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 08:49:37 +0000
Message-ID: <CANeU7Qk4AGhSzzpPXT1-NmWRzSprUXEjWm6o1iy8yKAb-TceQg () mail ! gmail ! com>
--------------------
>commit 5674da2d1af2467605fcc9b798fb54ee2d28efc7
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Mon Mar 20 15:18:53 2017 +0100
>
>    canonicalize compare instructions
>
>    Currently only commutative instructions are canonicalized
>    (the "simpler" operands, often a constant, is forced, if present
>    to be in the second operand). This improve CSE (more cases are
>    considered as equivalent) and help to reduce the number of "pattern"
>    to be handled at simplification.
>
> const struct opcode_table opcode_table[OP_LAST] = {
>-      [OP_SET_EQ] = { .negate = OP_SET_NE, },
>-      [OP_SET_NE] = { .negate = OP_SET_EQ, },
>-      [OP_SET_LT] = { .negate = OP_SET_GE, },
>-      [OP_SET_LE] = { .negate = OP_SET_GT, },
>-      [OP_SET_GE] = { .negate = OP_SET_LT, },
>-      [OP_SET_GT] = { .negate = OP_SET_LE, },
>-      [OP_SET_B ] = { .negate = OP_SET_AE, },
>-      [OP_SET_BE] = { .negate = OP_SET_A , },
>-      [OP_SET_AE] = { .negate = OP_SET_B , },
>-      [OP_SET_A ] = { .negate = OP_SET_BE, },
>+      [OP_SET_EQ] = { .negate = OP_SET_NE, .swap = OP_SET_EQ, },
>+      [OP_SET_NE] = { .negate = OP_SET_EQ, .swap = OP_SET_NE, },
>+      [OP_SET_LT] = { .negate = OP_SET_GE, .swap = OP_SET_GT, },
>+      [OP_SET_LE] = { .negate = OP_SET_GT, .swap = OP_SET_GE, },
>+      [OP_SET_GE] = { .negate = OP_SET_LT, .swap = OP_SET_LE, },
>+      [OP_SET_GT] = { .negate = OP_SET_LE, .swap = OP_SET_LT, },
>+      [OP_SET_B ] = { .negate = OP_SET_AE, .swap = OP_SET_A , },
>+      [OP_SET_BE] = { .negate = OP_SET_A , .swap = OP_SET_AE, },
>+      [OP_SET_AE] = { .negate = OP_SET_B , .swap = OP_SET_BE, },
>+      [OP_SET_A ] = { .negate = OP_SET_BE, .swap = OP_SET_B , },


Notice that LT and GT and equivalent instructions after swapping the src.
Another way to do it we might just remove one kind of instruction from the
sparse IR. From the linearization point just map GT into LT and swap the source.

So the IR does not allow those duplicated equilateral instructions. There is
less canonization to be done.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 17:03:52 +0000
Message-ID: <20171105170349.o7r7z3qb4a36pmtf () ltop ! local>
--------------------
On Sun, Nov 05, 2017 at 04:49:37PM +0800, Christopher Li wrote:
> >commit 5674da2d1af2467605fcc9b798fb54ee2d28efc7
> >Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> >Date:   Mon Mar 20 15:18:53 2017 +0100
> >
> >    canonicalize compare instructions
> >
> >    Currently only commutative instructions are canonicalized
> >    (the "simpler" operands, often a constant, is forced, if present
> >    to be in the second operand). This improve CSE (more cases are
> >    considered as equivalent) and help to reduce the number of "pattern"
> >    to be handled at simplification.
> >
> 
> 
> Notice that LT and GT and equivalent instructions after swapping the src.
> Another way to do it we might just remove one kind of instruction from the
> sparse IR. From the linearization point just map GT into LT and swap the source.
> 
> So the IR does not allow those duplicated equilateral instructions. There is
> less canonization to be done.

The principal and most important action done during canonicalization is
insuring that constants are on the RHS.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 17:10:15 +0000
Message-ID: <20171105171013.mktkihyuuagqthaq () ltop ! local>
--------------------
On Sun, Nov 05, 2017 at 04:29:57PM +0800, Christopher Li wrote:
> >commit e4a0824120939235e40277a57425a72fbfcd5b9b
> >Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> >Date:   Sun Mar 26 19:35:14 2017 +0200
> >
> 
> I think this patch ideally should be combined with the next patch.
> As it is, this patch is not self contain. There is no user of this table.

I'm fine with this. Certainly when:
*) the user is introduced in the next patch  
*) there is 'static but unused' warnings issued

> ...
> > static int simplify_seteq_setne(struct instruction *insn, long long value)
> > {
> >       pseudo_t old = insn->src1;
> >@@ -484,7 +460,7 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)
> >               // and similar for setne/eq ... 0/1
> >               src1 = def->src1;
> >               src2 = def->src2;
> >-              insn->opcode = compare_opcode(opcode, inverse);
> >+              insn->opcode = inverse ? opcode_table[opcode].negate : opcode;
> 
> I think it would be better to have some kind of assert check here, the opcode
> you swap from the table is indeep opcode. Because you assign the opcode
> array using sparse index. It is easy to miss a spot creating the empty slot in
> the table.

Sorry, I see the words, I sorta gues what you mean but I can't parse
what you wrote.

> Also, the opcode table might be able to compressed only contain
> section of the BINCMP opcodes.

Yes, it's something that may be done after all the related changes
are done if the speedup is worth the added complexity.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 17:10:15 +0000
Message-ID: <20171105171013.mktkihyuuagqthaq () ltop ! local>
--------------------
On Sun, Nov 05, 2017 at 04:29:57PM +0800, Christopher Li wrote:
> >commit e4a0824120939235e40277a57425a72fbfcd5b9b
> >Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> >Date:   Sun Mar 26 19:35:14 2017 +0200
> >
> 
> I think this patch ideally should be combined with the next patch.
> As it is, this patch is not self contain. There is no user of this table.

I'm fine with this. Certainly when:
*) the user is introduced in the next patch  
*) there is 'static but unused' warnings issued

> ...
> > static int simplify_seteq_setne(struct instruction *insn, long long value)
> > {
> >       pseudo_t old = insn->src1;
> >@@ -484,7 +460,7 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)
> >               // and similar for setne/eq ... 0/1
> >               src1 = def->src1;
> >               src2 = def->src2;
> >-              insn->opcode = compare_opcode(opcode, inverse);
> >+              insn->opcode = inverse ? opcode_table[opcode].negate : opcode;
> 
> I think it would be better to have some kind of assert check here, the opcode
> you swap from the table is indeep opcode. Because you assign the opcode
> array using sparse index. It is easy to miss a spot creating the empty slot in
> the table.

Sorry, I see the words, I sorta gues what you mean but I can't parse
what you wrote.

> Also, the opcode table might be able to compressed only contain
> section of the BINCMP opcodes.

Yes, it's something that may be done after all the related changes
are done if the speedup is worth the added complexity.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 05 Nov 2017 23:18:46 +0000
Message-ID: <CANeU7QkXyUonK-wKjrGp_Ka6vBsFaJ65S3OvjMzLTKc8VUoW4w () mail ! gmail ! com>
--------------------
On Mon, Nov 6, 2017 at 1:10 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> >-              insn->opcode = compare_opcode(opcode, inverse);
>> >+              insn->opcode = inverse ? opcode_table[opcode].negate : opcode;
>>
>> I think it would be better to have some kind of assert check here, the opcode
>> you swap from the table is indeep opcode. Because you assign the opcode
>> array using sparse index. It is easy to miss a spot creating the empty slot in
>> the table.
>
> Sorry, I see the words, I sorta gues what you mean but I can't parse
> what you wrote.

Let me re phrase. The opcode_table has a lot of zero in them.
Even though you thing you give all the op code worthwhile to have .negate
an opcode. The rest of op has .negate to zero.

My suggestion is that make a assert check this new opcode you get back
from the table is not zero.

You initialize the op code table using position index. It is possible to missing
a slot. So have an assert check here is good.

>
>> Also, the opcode table might be able to compressed only contain
>> section of the BINCMP opcodes.
>
> Yes, it's something that may be done after all the related changes
> are done if the speedup is worth the added complexity.

This series will first go into a topic branch any way.
Clearly your opcode is only apply to OP_SETXXXX friends.
I more compact data section is good.


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 12 Nov 2017 01:04:43 +0000
Message-ID: <CANeU7Q=qa4Je13z65nHa_V=QAC4w-30GiO3e72Lp5C49QYcDVg () mail ! gmail ! com>
--------------------
OK, this is the most difficult review for me to write, the OP_PUSH patch:
I have think this long and hard.

>commit 92fed40628f932a20a6cc95a67e4e5b03d280757
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Fri Mar 17 11:49:42 2017 +0100
>
>    give function's arguments a type via OP_PUSH
>
>    The linearized code, sparse's IR, have no use of C's complex type
>    system. Those types are checked in previous phases and the pseudos
>    doesn't a type directly attached to them as all needed type info
>    are now conveyed by the instructions (like (register) size,
>    signedness (OP_DIVU vs OP_DIVS), ...).
>
>    In particular, PSEUDO_VAL (used for integer and address constants)
>    are completely typeless.

I think the PSEUDO_VAL being typeless is the problem here.

>    There is a problem with this when calling a variadic function
>    with a constant argument as in this case there is no type in the
>    function prototype (for the variadic part, of course) and there is
>    no defining instructions holding the type of the argument.

No only here as problem. As you hint in your change

======================quote ===========================
>commit e154d59f375bdb307c4d778bab8055a380e2840e
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Wed Mar 8 08:19:50 2017 +0100
>
>    llvm: fix translation of PSEUDO_VALs into a ValueRefs
>
>    In sparse-llvm there is the assumption that a PSEUDO_VAL is always
>    of integer type. But this is not always the case: constant pointers,
>    like NULL, are also of the PSEUDO_VAL kind.
>
>    Fix this by adding a helper 'val_to_value()' and using the
>    instruction's type where this pseudo is used as the type of the value.
>
>    Note: while this patch improve the situation, like for example for the
>    test cases added here, it's still not correct because now we're making
>    the assumption that 'insn->type' is the type we need for the pseudo.
>    This is often true, but certainly not always.
>    For example this is not true for:
>    - OP_STORE/OP_LOAD's insn->src
>    - OP_SET{EQ,...}'s   insn->src[12]
>    - probably some  others ones
>    - in general, obviously, for any instructions where the target has
>      a different type than the operands.
========================quote ==========================

There is other place  want to have PSEUDO_VAL size which is not provide by
instruction type.

>
>    Fix this by adding a new instruction, OP_PUSH, which will be used
>    to pass arguments to function calls and whose purpose is to give
>    a correct type/size to function's arguments.

This OP_PUSH is fixing a uncommon case (function call variance part
has constant).

I did purpose a different way to fix this problem, actually also
suggested by Linus, you are CC on the email, back in Aug 13.

https://patchwork.kernel.org/patch/9897573/
https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=pseudo-sized-value

Compare OP_PUSH vs PSEUDO_VAL with size.

OP_PUSH:
- break sparse IR compatibility.
- Allocate more memory (mostly duplicate information)
- create special instruction that is not part of bb->insns. Push
instruction in insn.arguments.
- PSEUDO_VAL size still have other case not covered by instruction type.
- more verbose output on linearize instructions.

PSEUDO_VAL with size:
- compatible to previous IR if you don't care about the size.
- no extra memory allocation for storing the size part.
  (there will be extra memory allocation for same value with different size).
- fix other place PSEUDO_VAL size is needed but not provide by instruction type.
- less impact to the code all around.

So far I see PSEUDO_VAL with size has advantage over
OP_PUSH. If I am wrong, please correct me, I am listening.

I think that is the biggest worry I have on this series. The rest
of my feed back is kind of trivial I don't mind merge then fix it.


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 12 Nov 2017 01:04:43 +0000
Message-ID: <CANeU7Q=qa4Je13z65nHa_V=QAC4w-30GiO3e72Lp5C49QYcDVg () mail ! gmail ! com>
--------------------
OK, this is the most difficult review for me to write, the OP_PUSH patch:
I have think this long and hard.

>commit 92fed40628f932a20a6cc95a67e4e5b03d280757
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Fri Mar 17 11:49:42 2017 +0100
>
>    give function's arguments a type via OP_PUSH
>
>    The linearized code, sparse's IR, have no use of C's complex type
>    system. Those types are checked in previous phases and the pseudos
>    doesn't a type directly attached to them as all needed type info
>    are now conveyed by the instructions (like (register) size,
>    signedness (OP_DIVU vs OP_DIVS), ...).
>
>    In particular, PSEUDO_VAL (used for integer and address constants)
>    are completely typeless.

I think the PSEUDO_VAL being typeless is the problem here.

>    There is a problem with this when calling a variadic function
>    with a constant argument as in this case there is no type in the
>    function prototype (for the variadic part, of course) and there is
>    no defining instructions holding the type of the argument.

No only here as problem. As you hint in your change

======================quote ===========================
>commit e154d59f375bdb307c4d778bab8055a380e2840e
>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>Date:   Wed Mar 8 08:19:50 2017 +0100
>
>    llvm: fix translation of PSEUDO_VALs into a ValueRefs
>
>    In sparse-llvm there is the assumption that a PSEUDO_VAL is always
>    of integer type. But this is not always the case: constant pointers,
>    like NULL, are also of the PSEUDO_VAL kind.
>
>    Fix this by adding a helper 'val_to_value()' and using the
>    instruction's type where this pseudo is used as the type of the value.
>
>    Note: while this patch improve the situation, like for example for the
>    test cases added here, it's still not correct because now we're making
>    the assumption that 'insn->type' is the type we need for the pseudo.
>    This is often true, but certainly not always.
>    For example this is not true for:
>    - OP_STORE/OP_LOAD's insn->src
>    - OP_SET{EQ,...}'s   insn->src[12]
>    - probably some  others ones
>    - in general, obviously, for any instructions where the target has
>      a different type than the operands.
========================quote ==========================

There is other place  want to have PSEUDO_VAL size which is not provide by
instruction type.

>
>    Fix this by adding a new instruction, OP_PUSH, which will be used
>    to pass arguments to function calls and whose purpose is to give
>    a correct type/size to function's arguments.

This OP_PUSH is fixing a uncommon case (function call variance part
has constant).

I did purpose a different way to fix this problem, actually also
suggested by Linus, you are CC on the email, back in Aug 13.

https://patchwork.kernel.org/patch/9897573/
https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=pseudo-sized-value

Compare OP_PUSH vs PSEUDO_VAL with size.

OP_PUSH:
- break sparse IR compatibility.
- Allocate more memory (mostly duplicate information)
- create special instruction that is not part of bb->insns. Push
instruction in insn.arguments.
- PSEUDO_VAL size still have other case not covered by instruction type.
- more verbose output on linearize instructions.

PSEUDO_VAL with size:
- compatible to previous IR if you don't care about the size.
- no extra memory allocation for storing the size part.
  (there will be extra memory allocation for same value with different size).
- fix other place PSEUDO_VAL size is needed but not provide by instruction type.
- less impact to the code all around.

So far I see PSEUDO_VAL with size has advantage over
OP_PUSH. If I am wrong, please correct me, I am listening.

I think that is the biggest worry I have on this series. The rest
of my feed back is kind of trivial I don't mind merge then fix it.


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 12 Nov 2017 05:05:15 +0000
Message-ID: <CAExDi1SkKZ=dK_u7rPmwyhrL6t224u7HjevL5DszzSkEQDO+bA () mail ! gmail ! com>
--------------------
On Sun, Nov 12, 2017 at 2:04 AM, Christopher Li <sparse@chrisli.org> wrote:
> OK, this is the most difficult review for me to write, the OP_PUSH patch:
> I have think this long and hard.
>
>>commit 92fed40628f932a20a6cc95a67e4e5b03d280757
>>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>>Date:   Fri Mar 17 11:49:42 2017 +0100
>>
>>    give function's arguments a type via OP_PUSH
>>
>>    The linearized code, sparse's IR, have no use of C's complex type
>>    system. Those types are checked in previous phases and the pseudos
>>    doesn't a type directly attached to them as all needed type info
>>    are now conveyed by the instructions (like (register) size,
>>    signedness (OP_DIVU vs OP_DIVS), ...).
>>
>>    In particular, PSEUDO_VAL (used for integer and address constants)
>>    are completely typeless.
>
> I think the PSEUDO_VAL being typeless is the problem here.

And it has already been explained to you why they are typeless
and why it's fine.

>
> OP_PUSH:
> - break sparse IR compatibility.

What compatibility are you talking about?

>
> So far I see PSEUDO_VAL with size has advantage over
> OP_PUSH. If I am wrong, please correct me, I am listening.

The OP_PUSH solution has at least the advantage to work, to
be integrated with all the other IR generation fixes and to be tested.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 12 Nov 2017 05:05:15 +0000
Message-ID: <CAExDi1SkKZ=dK_u7rPmwyhrL6t224u7HjevL5DszzSkEQDO+bA () mail ! gmail ! com>
--------------------
On Sun, Nov 12, 2017 at 2:04 AM, Christopher Li <sparse@chrisli.org> wrote:
> OK, this is the most difficult review for me to write, the OP_PUSH patch:
> I have think this long and hard.
>
>>commit 92fed40628f932a20a6cc95a67e4e5b03d280757
>>Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>>Date:   Fri Mar 17 11:49:42 2017 +0100
>>
>>    give function's arguments a type via OP_PUSH
>>
>>    The linearized code, sparse's IR, have no use of C's complex type
>>    system. Those types are checked in previous phases and the pseudos
>>    doesn't a type directly attached to them as all needed type info
>>    are now conveyed by the instructions (like (register) size,
>>    signedness (OP_DIVU vs OP_DIVS), ...).
>>
>>    In particular, PSEUDO_VAL (used for integer and address constants)
>>    are completely typeless.
>
> I think the PSEUDO_VAL being typeless is the problem here.

And it has already been explained to you why they are typeless
and why it's fine.

>
> OP_PUSH:
> - break sparse IR compatibility.

What compatibility are you talking about?

>
> So far I see PSEUDO_VAL with size has advantage over
> OP_PUSH. If I am wrong, please correct me, I am listening.

The OP_PUSH solution has at least the advantage to work, to
be integrated with all the other IR generation fixes and to be tested.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 12 Nov 2017 05:45:52 +0000
Message-ID: <20171112054550.cppako2mchvyhmmg () ltop ! local>
--------------------
On Sun, Nov 12, 2017 at 09:04:43AM +0800, Christopher Li wrote:
> - create special instruction that is not part of bb->insns. Push
> instruction in insn.arguments.

You already came with this previously and I already replied you about it.
I don't know what make you think that OP_PUSH are not in bb->insns
but you're wrong: they are normal instructions and are thus stored
in the bb->insns, the second patch even change their position inside
this list.


-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 12 Nov 2017 05:45:52 +0000
Message-ID: <20171112054550.cppako2mchvyhmmg () ltop ! local>
--------------------
On Sun, Nov 12, 2017 at 09:04:43AM +0800, Christopher Li wrote:
> - create special instruction that is not part of bb->insns. Push
> instruction in insn.arguments.

You already came with this previously and I already replied you about it.
I don't know what make you think that OP_PUSH are not in bb->insns
but you're wrong: they are normal instructions and are thus stored
in the bb->insns, the second patch even change their position inside
this list.


-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Fri, 17 Nov 2017 09:51:49 +0000
Message-ID: <20171117095147.a4v4alrcr77rafut () ltop ! local>
--------------------
FWIW, I've now pushed this to my dev tree at:
	git://github.com/lucvoo/sparse.git master

with the two patches related to OP_PUSH removed and
replaced by something with minimal impact and directly
storing the type of the arguments into the OP_CALL
instructions.

-- Luc Van Oostenryck 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Fri, 17 Nov 2017 09:51:49 +0000
Message-ID: <20171117095147.a4v4alrcr77rafut () ltop ! local>
--------------------
FWIW, I've now pushed this to my dev tree at:
	git://github.com/lucvoo/sparse.git master

with the two patches related to OP_PUSH removed and
replaced by something with minimal impact and directly
storing the type of the arguments into the OP_CALL
instructions.

-- Luc Van Oostenryck 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Fri, 17 Nov 2017 19:50:06 +0000
Message-ID: <20171117195004.s472oqlldfrgiz2t () ltop ! local>
--------------------
On Fri, Nov 17, 2017 at 06:24:09PM +0800, Christopher Li wrote:
> On Fri, Nov 17, 2017 at 5:51 PM, Luc Van Oostenryck wrote:
> > FWIW, I've now pushed this to my dev tree at:
> >         git://github.com/lucvoo/sparse.git master
> >
> > with the two patches related to OP_PUSH removed and
> > replaced by something with minimal impact and directly
> > storing the type of the arguments into the OP_CALL
> > instructions.
> 
> Isn't type of arguments can be get from the call function prototype?
> 
> So those kind of the information is duplicated most of the time.
> The only useful place is variable arguments that the argument is
> from the variable part and the argument is constant value.

Yes, this has been pretty clear since the beginning:
- Currently, nowhere in the "normal" sparse code is the type or
  the size of a constant something we care about.
- The only place it is needed is:
  - for sparse-llvm and then only for variadic arguments
    (where there is nothing in the prototype about these type).
- Other backends will, obviously, need the same information.

Also, but maybe less obvious:
- Till now, no pseudo has any kind of typing *directly* attached
  to it. In fact, the pseudos are typeless (all of them) and the
  code is designed around this. The types are given by the usage
  or other secondary information.
- Here under, by 'type', you often need to understand
  'some type system', either:
  - the full typing represented by 'struct symbol' 
  - a subset of the this full type, like 'size + integer/float'
  
> I did try to remove the OP_PUSH and the associate type from
> your git series. Removing the OP_PUSH is not too bad. But undoing
> the associate type is a major hassle.
> 
> Do you see any problem using the pseudo value with size patch?
> Now it has the second patch to work with llvm as well. Should be testable.

I already said in June-August that I tried this approach and that
it didn't work (well, I'm sure that it is possible to make it work,
it's just more complex that it seems).

I'm sure it's testable (but what does that mean exactly?).
I'm convinced it passes the testsuite and kernel check.
But given that, as stated here above, nowhere in the code
this information is needed, it's pretty normal that the
changes have zero effect there. OTOH, these changes have
impact on a few things related to the level below, thus
*it is needed* to test things at IR level.

Now, I have no hard problem with the PSEUDO_VAL.size
approach from a theorical point of view (even if I would
prefer the mathematical PoV that 0 is 0, 1 is 1, etc.).
I even think that *eventually* it may very well be
the right solution (probably the whole typing at IR
level need to be revisited).

On a practical level, things are differents:
- The introduction of PSEUDO_VAL.size create
  a segragation between pseudos of the same value
  but different uses (different sizes).
  This has impact on the CSE.
  Admittingly, there shouldn't be any impact and it's
  maybe a sign that something is wrong elsewhere.
- There are places in the code where kinds of implicit
  castings are done (the OP_SET_* instructions are
  especially concerned). Some may consider this as a
  bug, to me it's at least a problem.
  To solve the problems there you need to:
  1) identify all places where such is done
  2) look if the pseudo is a constant
  3) if it is a constant, look at its type/size
  4) make the needed adjustment.
- On another level, even if your patch is quite small
  and simple, it's still relatively invasive and is
  guaranted to create bad conflicts in numerous pending patches.

Now, aren't these not solvable?
I'm sure they are solvable. The problems are the price/work
and the moment. Of course, the price and moment mostly
concerns the person who will make the work.

For my part, I consider that there are others things
immensely more important than trying to solve this now,
like, for example, fixing the SSA conversion.

-- Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 26 Nov 2017 17:42:55 +0000
Message-ID: <CANeU7Q=pZAuzju8EJACZ9HVKzM6C=L0PDY6xnid6Ub5=RkuXwg () mail ! gmail ! com>
--------------------
On Sat, Nov 18, 2017 at 3:50 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> Do you see any problem using the pseudo value with size patch?
>> Now it has the second patch to work with llvm as well. Should be testable.
>
> I already said in June-August that I tried this approach and that
> it didn't work (well, I'm sure that it is possible to make it work,
> it's just more complex that it seems).
>
> I'm sure it's testable (but what does that mean exactly?).
> I'm convinced it passes the testsuite and kernel check.
> But given that, as stated here above, nowhere in the code
> this information is needed, it's pretty normal that the
> changes have zero effect there. OTOH, these changes have
> impact on a few things related to the level below, thus
> *it is needed* to test things at IR level.
>
> Now, I have no hard problem with the PSEUDO_VAL.size
> approach from a theorical point of view (even if I would
> prefer the mathematical PoV that 0 is 0, 1 is 1, etc.).
> I even think that *eventually* it may very well be
> the right solution (probably the whole typing at IR
> level need to be revisited).

I think constant pseudo have a size is the right
solution in the long run. I

> On a practical level, things are differents:
> - The introduction of PSEUDO_VAL.size create
>   a segragation between pseudos of the same value
>   but different uses (different sizes).
>   This has impact on the CSE.
>   Admittingly, there shouldn't be any impact and it's
>   maybe a sign that something is wrong elsewhere.

As you said, it should be some thing CSE done wrong
to cause it a problem. The pseudo register has a size
being implicit on that. If CSE merge two instruction with
different source pseudo size into one, that seems wrong.

If you know a special test case can trigger that, I would
like to see it as well.

> - There are places in the code where kinds of implicit
>   castings are done (the OP_SET_* instructions are
>   especially concerned). Some may consider this as a
>   bug, to me it's at least a problem.
>   To solve the problems there you need to:
>   1) identify all places where such is done
>   2) look if the pseudo is a constant
>   3) if it is a constant, look at its type/size
>   4) make the needed adjustment.

If there is a size change during the implicit cast,
it can be a good thing to make the truncate and
size extend more obvious. I think you have some idea
relate to that.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 26 Nov 2017 17:42:55 +0000
Message-ID: <CANeU7Q=pZAuzju8EJACZ9HVKzM6C=L0PDY6xnid6Ub5=RkuXwg () mail ! gmail ! com>
--------------------
On Sat, Nov 18, 2017 at 3:50 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> Do you see any problem using the pseudo value with size patch?
>> Now it has the second patch to work with llvm as well. Should be testable.
>
> I already said in June-August that I tried this approach and that
> it didn't work (well, I'm sure that it is possible to make it work,
> it's just more complex that it seems).
>
> I'm sure it's testable (but what does that mean exactly?).
> I'm convinced it passes the testsuite and kernel check.
> But given that, as stated here above, nowhere in the code
> this information is needed, it's pretty normal that the
> changes have zero effect there. OTOH, these changes have
> impact on a few things related to the level below, thus
> *it is needed* to test things at IR level.
>
> Now, I have no hard problem with the PSEUDO_VAL.size
> approach from a theorical point of view (even if I would
> prefer the mathematical PoV that 0 is 0, 1 is 1, etc.).
> I even think that *eventually* it may very well be
> the right solution (probably the whole typing at IR
> level need to be revisited).

I think constant pseudo have a size is the right
solution in the long run. I

> On a practical level, things are differents:
> - The introduction of PSEUDO_VAL.size create
>   a segragation between pseudos of the same value
>   but different uses (different sizes).
>   This has impact on the CSE.
>   Admittingly, there shouldn't be any impact and it's
>   maybe a sign that something is wrong elsewhere.

As you said, it should be some thing CSE done wrong
to cause it a problem. The pseudo register has a size
being implicit on that. If CSE merge two instruction with
different source pseudo size into one, that seems wrong.

If you know a special test case can trigger that, I would
like to see it as well.

> - There are places in the code where kinds of implicit
>   castings are done (the OP_SET_* instructions are
>   especially concerned). Some may consider this as a
>   bug, to me it's at least a problem.
>   To solve the problems there you need to:
>   1) identify all places where such is done
>   2) look if the pseudo is a constant
>   3) if it is a constant, look at its type/size
>   4) make the needed adjustment.

If there is a size change during the implicit cast,
it can be a good thing to make the truncate and
size extend more obvious. I think you have some idea
relate to that.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 26 Nov 2017 19:34:47 +0000
Message-ID: <20171126193445.zc6frfjle7xq7ug2 () ltop ! local>
--------------------
On Mon, Nov 27, 2017 at 01:42:55AM +0800, Christopher Li wrote:
> 
> If there is a size change during the implicit cast,
> it can be a good thing to make the truncate and
> size extend more obvious. I think you have some idea
> relate to that.

Yes, I have essentially finished the cast rework. However,
my tests now reveals some forgotten cases and some bugs.
It's a good thing but they must be fixed.

It also won't solve problems with pseudos silently changing
from type/size (which is more a question of IR simplification).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [GIT PULL] llvm fixes
Date: Sun, 26 Nov 2017 19:34:47 +0000
Message-ID: <20171126193445.zc6frfjle7xq7ug2 () ltop ! local>
--------------------
On Mon, Nov 27, 2017 at 01:42:55AM +0800, Christopher Li wrote:
> 
> If there is a size change during the implicit cast,
> it can be a good thing to make the truncate and
> size extend more obvious. I think you have some idea
> relate to that.

Yes, I have essentially finished the cast rework. However,
my tests now reveals some forgotten cases and some bugs.
It's a good thing but they must be fixed.

It also won't solve problems with pseudos silently changing
from type/size (which is more a question of IR simplification).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [GIT PULL] next batch of patches ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [GIT PULL] next batch of patches
Date: Sat, 20 May 2017 16:14:31 +0000
Message-ID: <20170520161430.rojzqbt7rl6rud5b () desk ! local>
--------------------
Chris,

Please pull these patches for sparse's next release.
More or less half of them are fixes, the remaining ones
are utilities like -fmem-report, -fdump-linearize and
support for -dD.

Thank you,
Luc

--->8

The following changes since commit 51de1cca1bde56d9a1c73142fa2c93eeba65d0bf:

  Merge branches 'quiets-bool-cast-restricted-v2', 'keyword-cleanup-v2', 'not-so-crazy-v2' and 'ignore-void-if-convert-v3' into tip (2017-05-12 12:59:06 +0200)

are available in the git repository at:

  git://github.com/lucvoo/sparse.git tags/fixes-for-stable-20170520

for you to fetch changes up to 88578349140acf4405b768a60be05e10b7b8b158:

  Merge branches 'dump-macros-v2', 'fix-predefined-size', 'fix-bool-context', 'fix-missing-reload', 'fix-insert-branch', 'fix-NULL-type', 'testsuite-clean', 'fix-bitfield-init-v3' and 'fdump-linearize' into tip (2017-05-19 16:11:51 +0200)

----------------------------------------------------------------
Pending fixes for sparse's next release

----------------------------------------------------------------
Luc Van Oostenryck (24):
      fix boolean context for OP_AND_BOOL & OP_OR_BOOL
      fix missing reload
      add get_<allocator>_stats()
      add show_allocation_stats()
      add helper handle_simple_switch()
      teach sparse how to handle '-fmem-report'
      use -fmem-report to report allocation stats
      testsuite: cleanup result files
      fix: kill old branch in insert_branch()
      returns the correct type when evaluating NULL
      remove bit_size & bit_offset from struct access_data
      add test case for linearize_initializer() of bitfields
      fix implicit zero initializer.
      remove alignment from struct access_data
      remove origval from struct access_data
      add support for a new flag: -fdump-linearize[=only]
      define ident_list
      teach sparse how to dump macro definitions
      fix hardcoded size of wide chars
      avoid to redefine __INT_MAX__ and friends
      fix definition of __SCHAR_MAX__ & friends
      teach sparse how to handle -dD flag
      let -dD report macro definitions
      Merge branches 'dump-macros-v2', 'fix-predefined-size', 'fix-bool-context', 'fix-missing-reload', 'fix-insert-branch', 'fix-NULL-type', 'testsuite-clean', 'fix-bitfield-init-v3' and 'fdump-linearize' into tip

 Makefile                                    |   1 +
 allocate.c                                  |   8 +++
 allocate.h                                  |  13 ++++
 char.c                                      |   4 +-
 evaluate.c                                  |   2 +-
 flow.c                                      |  12 +++-
 lib.c                                       |  91 +++++++++++++++++++++----
 lib.h                                       |  13 ++++
 linearize.c                                 |  86 +++++++++++++++++------
 pre-process.c                               |  55 +++++++++++++++
 sparse-llvm.c                               |   1 +
 sparse.1                                    |  10 +++
 sparse.c                                    |   2 +
 stats.c                                     |  62 +++++++++++++++++
 target.c                                    |   2 +
 target.h                                    |   2 +
 test-linearize.c                            |   2 +
 test-unssa.c                                |   1 +
 validation/alias-distinct.c                 |  17 +++++
 validation/alias-mixed.c                    |  30 ++++++++
 validation/alias-same.c                     |  17 +++++
 validation/empty-file                       |   0
 validation/kill-insert-branch.c             |  22 ++++++
 validation/linear/bitfield-init-mask.c      |  27 ++++++++
 validation/linear/bitfield-init-zero.c      | 102 ++++++++++++++++++++++++++++
 validation/linear/struct-init-full.c        |  28 ++++++++
 validation/linear/struct-init-partial.c     |  41 +++++++++++
 validation/optim/bool-context.c             |  12 ++++
 validation/optim/bool-simplify.c            |   8 ++-
 validation/preprocessor/dump-macros-empty.c |   7 ++
 validation/preprocessor/dump-macros-multi.c |   7 ++
 validation/preprocessor/dump-macros.c       |  18 +++++
 validation/test-suite                       |   1 +
 33 files changed, 663 insertions(+), 41 deletions(-)
 create mode 100644 stats.c
 create mode 100644 validation/alias-distinct.c
 create mode 100644 validation/alias-mixed.c
 create mode 100644 validation/alias-same.c
 create mode 100644 validation/empty-file
 create mode 100644 validation/kill-insert-branch.c
 create mode 100644 validation/linear/bitfield-init-mask.c
 create mode 100644 validation/linear/bitfield-init-zero.c
 create mode 100644 validation/linear/struct-init-full.c
 create mode 100644 validation/linear/struct-init-partial.c
 create mode 100644 validation/optim/bool-context.c
 create mode 100644 validation/preprocessor/dump-macros-empty.c
 create mode 100644 validation/preprocessor/dump-macros-multi.c
 create mode 100644 validation/preprocessor/dump-macros.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [GIT PULL] pending fixes for sparse's next release ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [GIT PULL] pending fixes for sparse's next release
Date: Sun, 30 Apr 2017 03:41:49 +0000
Message-ID: <20170430034149.iltu3kctg6n7w4g2 () macpro ! local>
--------------------
Hi Chris,

Please pull these patches for sparse's next release.
They are fixes, for sparse itself, but also for the testsuite
which contained test cases that failed on 32bit machines.

Regards,
Luc

--->8

The following changes since commit 14964df5373292af78b29529d4fc7e1a26b67a97:

  avoid crash with test-linearize -vv (2017-03-31 13:14:17 +0800)

are available in the git repository at:

  git://github.com/lucvoo/sparse.git tags/fixes-for-stable-20170430

for you to fetch changes up to e35efe330c6ae7d154197c29b127560d569016d0:

  Merge branches 'sent/float-expand-v2', 'sent/fix-kill-ttsb-v2', 'sent/fix-cond-address' and 'careful-concat-user-list' into tip (2017-04-30 02:08:54 +0200)

----------------------------------------------------------------
Pending fixes for sparse's next release

----------------------------------------------------------------
Luc Van Oostenryck (17):
      teach sparse about -Waddress
      add is_func_type()
      warn if testing the address of a function
      add is_array_type()
      warn if testing the address of an array
      fix evaluation of a function or array symbol in conditionals
      fix is_scalar_type()
      fix test for cast to bool on 32bit machines
      predefine __INT_MAX__ and friends
      predefine __SIZEOF_INT__ & friends
      fix test validation/div.c
      do not depends on limits.h to test __CHAR_BIT__
      fix cast to pointer to floating-point
      fix expansion of integers to floats
      fix OP_PHI usage in try_to_simplify_bb(), correctly
      be more careful with concat_user_list()
      Merge branches 'sent/float-expand-v2', 'sent/fix-kill-ttsb-v2', 'sent/fix-cond-address' and 'careful-concat-user-list' into tip

 evaluate.c                                |   9 +-
 expand.c                                  |   3 +-
 flow.c                                    |  33 ++-
 lib.c                                     |  35 ++-
 lib.h                                     |   1 +
 linearize.c                               |   3 +-
 symbol.h                                  |  16 +-
 validation/bool-cast-explicit.c           |   2 +-
 validation/bool-cast-implicit.c           |   2 +-
 validation/builtin_char_bit.c             |   7 -
 validation/cast-constant-to-float.c       |  35 +++
 validation/cast-constants.c               | 357 ++++++++++++++++++++++++++++++
 validation/cond-address-array.c           |  26 +++
 validation/cond-address-function.c        |  18 ++
 validation/cond-address.c                 |  14 ++
 validation/div.c                          |  22 +-
 validation/fp-vs-ptrcast.c                |  13 ++
 validation/kill-phi-ttsbb2.c              |  40 ++++
 validation/preprocessor/predef-char-bit.c |  16 ++
 validation/preprocessor/predef-max.c      |  18 ++
 validation/preprocessor/predef-sizeof.c   |  25 +++
 21 files changed, 662 insertions(+), 33 deletions(-)
 delete mode 100644 validation/builtin_char_bit.c
 create mode 100644 validation/cast-constant-to-float.c
 create mode 100644 validation/cast-constants.c
 create mode 100644 validation/cond-address-array.c
 create mode 100644 validation/cond-address-function.c
 create mode 100644 validation/cond-address.c
 create mode 100644 validation/fp-vs-ptrcast.c
 create mode 100644 validation/kill-phi-ttsbb2.c
 create mode 100644 validation/preprocessor/predef-char-bit.c
 create mode 100644 validation/preprocessor/predef-max.c
 create mode 100644 validation/preprocessor/predef-sizeof.c

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] Fix illegal simplification of volatile stores ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/2] Fix illegal simplification of volatile stores
Date: Mon, 13 Nov 2017 01:27:26 +0000
Message-ID: <CANeU7Qn0o+_wVaq3Q9usBduq0Jx=K=Sc7Kq70sdeW=+QEsyQrg () mail ! gmail ! com>
--------------------
On Mon, Nov 13, 2017 at 7:06 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> But did you sent this review out? When?
>

I start to send review for this series out at Oct 30 and Nov 5.

For this peculiarity OP_PUSH, I thought I have send out already
but I just find a few days ago I did not. That was my bad.

But the whole process of evaluating your OP_PUSH start much
earlier. Not only do I join the discussion of the thread that
cause the OP_PUSH in the first place. I also purpose the
alternative patch at Aug 13.
https://patchwork.kernel.org/patch/9897573/

That is before you send out the git pull for llvm-fix at Sep.

You drop out of the email discussion.
There is many level of participation of the review process.
Email discussion is one. Sending out patches are the higher
level of participation.

Those email are not directly response to your llvm-fix.
But you know very well those are alternative approach to
OP_PUSH. You make claim that I did not response to
your git pull request for 8 month and you know that is not true.
It just more mud on the wall.

> I have already explained that giving some review in a reasonable
> amount of time after a series is first submitted is one thing.
> Asking for cosmetic changes (or what I tend to call "surface"
> changes) months later is another thing.
> The difference being that new code is developed on top
> of the old one. And yes, it's always possible to rebase
> everything, when it's valuable functional changes.

But the OP_PUSH vs OP_SETVAL.size is not surface change.
Your OP_PUSH break the byte code compatibility and
increase the instruction count.

I would let the surface change slide and just merge it
consider you have other change depend on it.

>
>> You are making your series not touchable. Amount all
>> all patch email send over the mailing list. How much can
>> I actually pull from according our agreement? Zero.
>
> I consider our agreement as finished.

Per our agreement. If I am not complete happy about any
thing in the series. The solutions is I don't pull and you are
going to purpose a new git pull request address my concerns.

Given that you have patch depend on it and I have this
in my backlog for a long time. I am willing to help out and
create fix up patches.

I do care about make things easy for you. But I have to make
a stand on some critical issue like OP_PUSH.

>
> The reason why I insisted about the llvm series is that
> because it's the oldest and a lot of further development
> depends on it.

I understand the pain. But is it possible for you to pick a stable
point as your base like master? In the old days the master
update not very frequently. Now days master are update
reasonably. Wouldn't master serve better as base for the
topic branch?

>
> You seem to have missed the word "code" here above.
> I'll rephrase:
>    I don't comment on code if I disagree with the code
>    or if the code is not to my taste but still I find
>    the code valuable enough that I don't want to block
>    it's inclusion.

That is just a cryptic way of saying I don't like your code.

>
>> And what is the reason for not reviewing this:
>> "Simplify expr->flags assignement":
>>
>> https://patchwork.kernel.org/patch/10042019/
>
> That's exactly the kind of code I find completly without any
> value:
> - if you make some measurement, please add the mean value
>   *AND* the standard deviation
> - it's a change for some "optimization" but you state yourself
>   in the mail that you don't know if it make any kind of difference.

OK. That establish you did saw  the email and chose not
to response to it.

Let me ask this question. If this exact patch is not send by me,
It is send by let say  Ramsay Jones. Would it be much more likely
you did reply to the email? I think so. After all, that did match you
behavior pattern promptly reply to patch by others just not me.

That is the different between you and me. I did not response
due to lack of time. I treat your patch the same way as mine.
If I am not happy about it, I want to make it better. You ignore patch
intentionally and has strong correlation base on me send the patch or not.

And you are still saying this is not personal?

> I don't insist on anything. You have said yourself that I gave no
> arguments and it's kinda true.
> What I have is a working, integrated and tested set of patches.

Thanks. Will do then.

> Funny thing when you have yourself said in late July:
>         Warning ahead, the OP_PUSH need more discussion.
>         It is not going to apply very quickly.
>
> To which I replied:
>         The fact that you said in advance, without any
>         kind of discussion, and without having participated
>         in any sort of way in the initial discussion, that
>         it will be a slow thing (thus a painful thing) make me
>         just want to drop the whole thing and move on with
>         something else.
>
>
> I've now spend enough time with this and this is my last email
> on the whole subject.

Guilty.

That is why I did dig out the discussion and have exchange
some email with you.  I point out your mistake of using earler
Linus' email to counter his own later suggestion.
Your don't have an validate argument and you are the last one
did not response to my reasoning.

Further more, I send out alternative patch to match my suggestion.
You did not follow up.

Luc, I do have a lot of respect for you. Thank you for your contribution
to sparse.

I do want to merge your patches. I do want to do it in a way
that is less painful for you.

I might be a moron of insist certain things at times. Actually,
remove the might, I am.

I do mean to do good with sparse with the best intentions.
I don't want to screw you and I don't want to fork sparse.

Let me see what I can do with the OP_SETVAL.size.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] V2 llvm constant value pseudo size fix ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 0/2] V2 llvm constant value pseudo size fix
Date: Mon, 13 Nov 2017 15:27:54 +0000
Message-ID: <CANeU7QknH=xpuButjBpVved131s8Kw4AJRZZGTBDLN+LBH_H9A () mail ! gmail ! com>
--------------------
Per Luc's feed back. This is the more complete version
of the pseudo-size-value branch.

I add the second patch to allow sparse-llvm to use
the new size store in constant value pseudo.

The whole series is very simple, only two patches.
It directly address the problem of sparse-llvm wasn't
able to get the integer size from constant value pseudo.

I am consider this as better alternative compare to OP_PUSH.
- OP_PUSH break byte code compatibility at source level, this does not.
- OP_PUSH has more instruction (more memory).
- OP_PUSH only cover constant value used in function call.
  this cover all usage of constant value.

It pass the "make check" test ( I have to fix a problem with
the bool type which is 1 bit integer). The V1 pass the kernel
checker test with no change to output.

Dibyendu, can you give this series some test since you report
it?

The git url:
https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=pseudo-sized-value-v2

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 0/2] V2 llvm constant value pseudo size fix
Date: Mon, 13 Nov 2017 20:31:31 +0000
Message-ID: <CACXZuxcAp_YEVwpi=9f7n_srWM8VRauaRBfFfxrryNfjj=s30w () mail ! gmail ! com>
--------------------
Hi Chris,

On 13 November 2017 at 15:27, Christopher Li <sparse@chrisli.org> wrote:
> I add the second patch to allow sparse-llvm to use
> the new size store in constant value pseudo.
>
> The whole series is very simple, only two patches.
> It directly address the problem of sparse-llvm wasn't
> able to get the integer size from constant value pseudo.
>
> Dibyendu, can you give this series some test since you report
> it?
>

I am happy to test but it might take a week or two, due to other commitments.

Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] cleanup prototype ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] cleanup prototype
Date: Tue, 19 Sep 2017 03:08:38 +0000
Message-ID: <20170919030840.12525-1-luc.vanoostenryck () gmail ! com>
--------------------
This series contains two patches removing unneeded prototypes.


The series is also available for review in the git repository at:

  git://github.com/lucvoo/sparse.git cleanup-prototype

----------------------------------------------------------------
Luc Van Oostenryck (2):
      remove prototype extern int is_ptr_type()
      remove prototype for unexistant examine_simple_symbol_type()

 symbol.h | 2 --
 1 file changed, 2 deletions(-)
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] extend canonical order ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/2] extend canonical order
Date: Wed, 12 Apr 2017 13:08:45 +0000
Message-ID: <20170412130844.6rfns4lstgwej2au () macbook ! local>
--------------------
On Wed, Apr 12, 2017 at 02:59:10PM +0200, Luc Van Oostenryck wrote:
> After linearization, operands of binops of binops are
> maintained in a 'canonical' order but this order is only:
> 	anything > symbols > integer literals
> but there is some value to impose a more complete order
> as this creates more opportunities for CSE and help to
> limit the number of patterns that need to be checked
> at simplification of even during code generation.
> 
> This is what is done by this (almost single patch) series.
> 
> This series is available at:
> 	git://github.com/lucvoo/sparse.git base-file
> based on commit:
> 	c9585071d02590f40175ea90c395d15ef70e9a1e (cset-setfval)
> up to commit:
> 	462a61a21b1e3bb17abce88fb1bdbc93d9653245

Sorry, I forgot the completely edit my template.
This need to be read as:
	git://github.com/lucvoo/sparse.git cse-canonical

The SHA1 references are OK, though.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] fix crash on bad expression in linearize_switch() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] fix crash on bad expression in linearize_switch()
Date: Thu, 28 Dec 2017 17:25:17 +0000
Message-ID: <20171228172519.16550-1-luc.vanoostenryck () gmail ! com>
--------------------
This two patches series contains a fix for a crash caused
by a null-pointer dereference when the condition in a switch
contains no expression at all.
As a bonus, sparse now warns on such empty expressions.

Luc Van Oostenryck (2):
  warn on empty parenthesized expressions
  fix crash on bad expression in linearize_switch()

 expression.c            |  6 ++++++
 linearize.c             |  2 ++
 validation/empty-expr.c | 26 ++++++++++++++++++++++++++
 3 files changed, 34 insertions(+)
 create mode 100644 validation/empty-expr.c

-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] fix examination of base type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] fix examination of base type
Date: Thu, 21 Dec 2017 00:30:15 +0000
Message-ID: <20171221003017.57211-1-luc.vanoostenryck () gmail ! com>
--------------------
This two patches series contains a fix for the evaluation
of dereferences which, in some cases, can be done
while the base type is still unexamined.

Luc Van Oostenryck (2):
  add testcases for unexamined base type
  fix: evaluate_dereference() unexamined base type

 evaluate.c                               |  1 +
 validation/linear/deref-ptr-ptr.c        | 26 +++++++++++++++++++++++
 validation/linear/unexamined-base-type.c | 36 ++++++++++++++++++++++++++++++++
 3 files changed, 63 insertions(+)
 create mode 100644 validation/linear/deref-ptr-ptr.c
 create mode 100644 validation/linear/unexamined-base-type.c

-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] fix missing base type examination ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] fix missing base type examination
Date: Sat, 25 Nov 2017 09:31:13 +0000
Message-ID: <20171125093115.95791-1-luc.vanoostenryck () gmail ! com>
--------------------
The goal of this series is to add te missing
examination of the base type in evaluate_dereference().

Luc Van Oostenryck (2):
  add test case unexamined base type
  fix: evaluate_dereference() unexamined base type

 evaluate.c                                |  2 +-
 validation/bugs/unexamined-base-type-00.c | 28 ++++++++++++++++++++++++++++
 2 files changed, 29 insertions(+), 1 deletion(-)
 create mode 100644 validation/bugs/unexamined-base-type-00.c


The series is available for testing at:
	git://github.com/lucvoo/sparse-dev.git fix-unexamined

-- Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] restore CSE of floating-point compares ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] restore CSE of floating-point compares
Date: Thu, 28 Dec 2017 22:17:33 +0000
Message-ID: <20171228221735.38902-1-luc.vanoostenryck () gmail ! com>
--------------------
This series contains a fix to restore the CSE of
floating point compares which wasn't done anymore after
the introduction of the new FP instructions.

Luc Van Oostenryck (2):
  add testcase for CSE of floating-point compares
  fix: restore CSE on floating-point compares

 cse.c                       |  4 +++-
 validation/optim/cse-fcmp.c | 19 +++++++++++++++++++
 2 files changed, 22 insertions(+), 1 deletion(-)
 create mode 100644 validation/optim/cse-fcmp.c

-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/2] teach sparse about -funsigned-char & friends ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/2] teach sparse about -funsigned-char & friends
Date: Fri, 29 Dec 2017 21:46:23 +0000
Message-ID: <20171229214625.41368-1-luc.vanoostenryck () gmail ! com>
--------------------
This series contains a change allowing to change the signedness
of plain chars.

This series is available in the Git repository at:
  git://github.com/lucvoo/sparse-dev.git funsigned-char

Luc Van Oostenryck (2):
  let handle_switches() also handle reverse logic
  add support for '-f[no-][un]signed-char'

 lib.c                      |  5 +++++
 lib.h                      |  1 +
 sparse.1                   |  5 +++++
 symbol.c                   |  6 ++++++
 validation/char-signed.c   |  9 +++++++++
 validation/char-unsigned.c | 11 +++++++++++
 6 files changed, 37 insertions(+)
 create mode 100644 validation/char-signed.c
 create mode 100644 validation/char-unsigned.c

-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] Simplify booleans ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] Simplify booleans
Date: Wed, 12 Apr 2017 14:17:59 +0000
Message-ID: <20170412141802.81231-1-luc.vanoostenryck () gmail ! com>
--------------------
The goal of this series is to add some simplification
concerning booleans and is a preparatory steps to give
a proper boolean context when required.


This series is available at:
	git://github.com/lucvoo/sparse.git simplify-bool-mask
based on commit:
	d440a16358aefd718029963bb2261f1deccfddab (fpos)
up to commit:
	d4208cd1ef7df00f7d79dba1ccb365136d382914

Luc Van Oostenryck (3):
  simplify 'x | ~0' and 'x & ~0'
  simplify 'x ^ ~0' to '~x'
  simplify casts bool -> int -> bool

 simplify.c                       | 35 +++++++++++++++++++++++++++++++++--
 validation/optim/bool-int-bool.c | 12 ++++++++++++
 validation/optim/bool-not-zero.c | 30 ++++++++++++++++++++++++++++++
 3 files changed, 75 insertions(+), 2 deletions(-)
 create mode 100644 validation/optim/bool-int-bool.c
 create mode 100644 validation/optim/bool-not-zero.c

-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] builtins expansion ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] builtins expansion
Date: Mon, 23 Jan 2017 21:37:25 +0000
Message-ID: <20170123213728.89900-1-luc.vanoostenryck () gmail ! com>
--------------------
This serie propose a clean solution to the expansion of some builtins
like __builtin_bswap16() which gcc consider as an integer constant
expression when the arg is itself an integer constant and is used as
such in the kernel in code like:
	#define htons(x) __builtin_bswap16(x)
	...
	switch (protocol) {
	case htons(ETH_P_IPV6):
		...

This serie needs to be applied on top of Johannes Berg's patch
concerning the same problem and the tests depends on the testsuite
extensions posted previously.

Alternatively, this serie can also be found as:
  git://github.com/lucvoo/sparse.git sent/builtin-bswap
      

Luc Van Oostenryck (3):
  move evaluation & expansion of builtins in a separate file
  allow builtins to have prototype and evaluate/expand methods
  expand __builtin_bswap*() with constant args

 Makefile                            |   1 +
 builtin.c                           | 241 ++++++++++++++++++++++++++++++++++++
 evaluate.c                          |   6 +
 expand.c                            |  24 +---
 expand.h                            |  34 +++++
 lib.c                               |  35 +-----
 lib.h                               |   5 +
 symbol.c                            | 160 +-----------------------
 symbol.h                            |   3 +-
 token.h                             |   1 +
 validation/builtin-bswap-constant.c |  48 +++++++
 validation/builtin-bswap.c          |  52 ++++++++
 12 files changed, 394 insertions(+), 216 deletions(-)
 create mode 100644 builtin.c
 create mode 100644 expand.h
 create mode 100644 validation/builtin-bswap-constant.c
 create mode 100644 validation/builtin-bswap.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] multiple dereference in function calls ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] multiple dereference in function calls
Date: Thu, 21 Dec 2017 00:19:12 +0000
Message-ID: <20171221001915.57047-1-luc.vanoostenryck () gmail ! com>
--------------------
In most situations of function type is implicitly
converted to the corresponding pointer.
This pointer can be dereferenced but the implicit
conversion will make it to immediatly decay back
to a pointer. In consequence, in a function call
the function designator can be preceded by an unlimited
number of deref operator ('*').

This series makes it effective.

Luc Van Oostenryck (3):
  add testcases for multiple deref of calls
  avoid unneeded alloc on error path
  dereference of a function is a no-op

 evaluate.c                         | 6 +++++-
 validation/function-pointer-type.c | 3 +++
 validation/linear/call-builtin.c   | 5 ++++-
 validation/linear/call-direct.c    | 5 ++++-
 validation/linear/call-indirect.c  | 4 +++-
 validation/linear/call-inline.c    | 5 ++++-
 validation/sizeof-function.c       | 1 -
 7 files changed, 23 insertions(+), 6 deletions(-)

-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] return type's testcases ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] return type's testcases
Date: Mon, 18 Sep 2017 14:10:54 +0000
Message-ID: <20170918141057.69745-1-luc.vanoostenryck () gmail ! com>
--------------------
These are just a few patches adding or fixing some testcases about
return type.

These patches are also available for review in the git repository at:

  git://github.com/lucvoo/sparse.git testcases-return-type

----------------------------------------------------------------
Luc Van Oostenryck (3):
      fix test case kill-phi-ttsb
      add test case for incomplete type
      add test case for bad return type

 validation/bad-return-type.c   | 19 +++++++++++++++++++
 validation/incomplete-struct.c | 23 +++++++++++++++++++++++
 validation/kill-phi-ttsbb.c    |  2 +-
 3 files changed, 43 insertions(+), 1 deletion(-)
 create mode 100644 validation/bad-return-type.c
 create mode 100644 validation/incomplete-struct.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] use internal size for __INT_MAX__ & friends ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] use internal size for __INT_MAX__ & friends
Date: Fri, 19 May 2017 11:20:50 +0000
Message-ID: <20170519112053.24632-1-luc.vanoostenryck () gmail ! com>
--------------------
The goal of this series is to predefine macros like __INT_MAX__
with the same size of the one used by sparse while is used to be
size of the machine on which sparse was compiled.

Luc Van Oostenryck (3):
  fix hardcoded size of wide chars
  avoid to redefine __INT_MAX__ and friends
  fix definition of __SCHAR_MAX__ & friends

 char.c   |  4 ++--
 lib.c    | 21 ++++++++++-----------
 target.c |  2 ++
 target.h |  2 ++
 4 files changed, 16 insertions(+), 13 deletions(-)

-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/3] validate expression's type in conditionals ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/3] validate expression's type in conditionals
Date: Sun, 29 Jan 2017 11:34:06 +0000
Message-ID: <20170129113409.9834-1-luc.vanoostenryck () gmail ! com>
--------------------
This serie aims to detect incorrect types used in conditionals.

Patch 1 fix a test case where a void was used ina conditional.
Patch 2 is an helper for the next patch.
Patch 3 do the validation.

Luc Van Oostenryck (3):
  fix conditional context test case with void
  add helper: is_scalar_type()
  validate expression's type in conditionals

 evaluate.c                    |  5 +++
 symbol.h                      | 22 ++++++++++
 validation/conditional-type.c | 99 +++++++++++++++++++++++++++++++++++++++++++
 validation/context.c          |  2 +-
 4 files changed, 127 insertions(+), 1 deletion(-)
 create mode 100644 validation/conditional-type.c

-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/4] assorted cleanups ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/4] assorted cleanups
Date: Thu, 16 Feb 2017 02:29:47 +0000
Message-ID: <CANeU7Qnnjzn6+8UTa2hnEYPujnrO-cER-hu-wyrrpk7ODSEOQQ () mail ! gmail ! com>
--------------------
On Thu, Feb 16, 2017 at 6:13 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This serie is only a small collections of independent
> cleanups, mainly removal of unused struct members.
>
> Patches 1-4 have no functional changes.
> Patch 4 make show_statement() slightly more useful.

Thanks,

Applied and pushed to sparse-next.

Do you have more patches coming? If not I am going to cut
a sparse release RC soon.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/4] assorted cleanups
Date: Thu, 16 Feb 2017 02:56:21 +0000
Message-ID: <20170216025620.cl5je57nn76hmfp6 () macpro ! local>
--------------------
On Thu, Feb 16, 2017 at 10:29:47AM +0800, Christopher Li wrote:
> On Thu, Feb 16, 2017 at 6:13 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > This serie is only a small collections of independent
> > cleanups, mainly removal of unused struct members.
> >
> > Patches 1-4 have no functional changes.
> > Patch 4 make show_statement() slightly more useful.
> 
> Thanks,
> 
> Applied and pushed to sparse-next.
Thanks.
 
> Do you have more patches coming? If not I am going to cut
> a sparse release RC soon.
I have lots of patches in diverse state of completeness but only
a dozen or so really ready.

In fact I was going to send some of them while I saw your email.
And I'll probably send a few others in the coming days.

Would it be possible to have the previous sparse-next promoted
to the master branch? I could then merge my features branches
with an up-to-date official branch that I'm sure is stable before
making some testing.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/4] assorted cleanups
Date: Fri, 24 Feb 2017 08:11:38 +0000
Message-ID: <CAExDi1Th1v5G7Hg3HY7ViMumY8PzfUENztwfvnuAS2xz26ZKnQ () mail ! gmail ! com>
--------------------
On Thu, Feb 16, 2017 at 3:29 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Feb 16, 2017 at 6:13 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> This serie is only a small collections of independent
>> cleanups, mainly removal of unused struct members.
>>
>> Patches 1-4 have no functional changes.
>> Patch 4 make show_statement() slightly more useful.
>
> Thanks,
>
> Applied and pushed to sparse-next.
>
> Do you have more patches coming? If not I am going to cut
> a sparse release RC soon.
>
> Chris

What I sent one hour ago was my last pending fix.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/6] build: various updates ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH 0/6] build: various updates
Date: Wed, 04 Oct 2017 13:25:59 +0000
Message-ID: <20171004132605.24734-1-uwe () kleine-koenig ! org>
--------------------
Hello,

this series motiviation is to support CPPFLAGS which is needed for
Debian packaging and includes the stuff I found while adding this.

Best regards
Uwe

Uwe Kleine-KÃ¶nig (6):
  build: make PREFIX overwritable from the environment
  build: put comment about local.mk to the place where it is included
  build: drop BASIC_CFLAGS and ALL_CFLAGS
  build: drop -g from LDFLAGS
  build: pass standard make variables to compiler and linker
  build: replace *_EXTRA_OBJS by local assignments to LDFLAGS and
    LOADLIBES

 Makefile | 41 +++++++++++++++++++----------------------
 1 file changed, 19 insertions(+), 22 deletions(-)

-- 
2.14.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/6] build: various updates
Date: Fri, 06 Oct 2017 21:30:31 +0000
Message-ID: <CANeU7Q=v5rXzxdtm7_ppW7q=G6qRiymdTQKRzQimXijCsgpR9Q () mail ! gmail ! com>
--------------------
On Fri, Oct 6, 2017 at 1:10 PM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.or=
g> wrote:
>
> Note I don't feel strong for most of my changes. There is little user
> visible change intended by them, just making the build system more
> standard by using expected variable names, which might also be subjective=
?!

Exactly. I also CC sparse mailing list.

>
>> Can you give the debug-target-v3 a review?
>
> I don't like
>         Makefile: Adding OPT variable for optmize level

Thanks for the review.

>
> I'd expect a Makefile to do something like that:
>
>         CFLAGS ?=3D -O2 ...
>
> such that I can overrule it by doing
>
>         make CFLAGS=3D"-O0 -g"

I can't see how that will work. CFLAGS has a lot of other options in it.
" -finline-functions -fno-strict-aliasing" just to name a few.
Overwrite the CFLAG
will drop those options as well, which is not desirable.

That is why the OPT variable was needed. Overwrite OPT will just change
the "-O2" an nothing else. Currently over write CFLAGS does not have the sa=
me
effect.

In general, overwrite CFLAGS in command line is a bad idea. Most of
the open source project I saw will not able to handle that properly.

>
> Commit
>
>         Makefile: introduce minimal target
>
> has a typo, s/minial/minimal/. And I wonder why it removes debug from

Thanks for catching that. I will update the V4 soon.

> the dependencies of check. This was added in "Makefile: release and
> debug target" needlessly?

Because this change make "all" depend on "debug" as well.
And "check" depend on "all". That makes "check" implicit depend on
"debug" already.

Before this change, "all" target actually did not build all possible target=
.
That is why I want to change "all" explicit build "release" and "debug" at =
the
same time.


>
> Other than that I don't see the motivation for this series and I'd
> always compile everything and wonder if
>
>         make CFLAGS=3D"-DSPARSE_DEBUG"
>
> would be good enough.

The motivation is speed. For most user that use sparse to run
the kernel checking. We want sparse run as fast as possible.
However, we also want a debug mode of sparse can run more
validation and error diagnostic at the cost of speed.

One patch series I want to use this debug mode is the ptrlist
reference count patch. The ptrlist reference count has running
over head. However, it can catch the "nest loop modify" bug.
If that code path was triggered, it means a possible list
iteration corruption.

I kind of want sparse can have option  that run the debug
version at run time request. In other words, distributios
will ship both the release and debug version of sparse.
The release version of sparse will invoke the debug
options if there is debug option is specified in command line.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/6] fix boolean context ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/6] fix boolean context
Date: Wed, 12 Apr 2017 19:33:38 +0000
Message-ID: <20170412193344.95935-1-luc.vanoostenryck () gmail ! com>
--------------------
The goal of this series is to add explicit comparisons
against zero to create a boolean context when issuing
OP_AND_BOOL & OP_OR_BOOL. This is needed to fix an incorrect
simplification.
A consequence of adding this boolean context is that
OP_AND_BOOL and OP_OR_BOOL become unneeded and are simply
replaced by OP_AND and OP_OR.


This series is available at:
	git://github.com/lucvoo/sparse.git bool-context
based on commits (a merge):
	d4208cd1ef7df00f7d79dba1ccb365136d382914 (simplify-bool-mask)
	462a61a21b1e3bb17abce88fb1bdbc93d9653245 (cse-canonical)
up to commit:
	ac6c25bc066eab36942539ba11c7ab6cf0c63674

Luc Van Oostenryck (6):
  fix boolean context for OP_AND_BOOL & OP_OR_BOOL
  simplify intermediate casts in boolean expressions
  avoid useless compare with zero
  generate plain OP_{AND,OR} instead of OP_{AND,OR}_BOOL
  llvm: no need to special-case OP_AND_BOOL and OP_OR_BOOL
  remove OP_{AND,OR}_BOOL instructions

 cse.c                              |  4 +---
 example.c                          |  3 ---
 linearize.c                        | 44 ++++++++++++++++++++++++++++++++----
 linearize.h                        |  4 +---
 simplify.c                         | 44 ++++++++++++++++--------------------
 sparse-llvm.c                      | 24 --------------------
 validation/optim/bool-context-fp.c | 46 ++++++++++++++++++++++++++++++++++++++
 validation/optim/bool-context.c    | 12 ++++++++++
 validation/optim/bool-simplify.c   | 30 +++++++++++++++++++++++--
 validation/optim/bool-simplify2.c  | 11 +++++++++
 10 files changed, 158 insertions(+), 64 deletions(-)
 create mode 100644 validation/optim/bool-context.c
 create mode 100644 validation/optim/bool-simplify2.c

-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/6] testsuite speedup ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/6] testsuite speedup
Date: Sun, 28 May 2017 19:29:00 +0000
Message-ID: <20170528192906.1023-1-luc.vanoostenryck () gmail ! com>
--------------------
The goal of this series is to speedup the testsuite,
mainly by avoiding to unneedlessly spawn child processes.

The resulting speedup here is over 2.5, which is quite appreciable.

Luc Van Oostenryck (6):
  testsuite: get all tags in once
  testsuite: grep the expected output only when needed
  testsuite: grep the output patterns only when needed
  testsuite: use shell arithmetic instead of fork-execing expr
  testsuite: remove unneeded './' before commands
  testsuite: avoid fork+execing basename

 validation/backend/arithmetic-ops.c   |   2 +-
 validation/backend/array.c            |   2 +-
 validation/backend/bitwise-ops.c      |   2 +-
 validation/backend/bool-test.c        |   2 +-
 validation/backend/cast.c             |   2 +-
 validation/backend/cmp-ops.c          |   2 +-
 validation/backend/extern.c           |   2 +-
 validation/backend/function-ptr.c     |   2 +-
 validation/backend/hello.c            |   2 +-
 validation/backend/int-cond.c         |   2 +-
 validation/backend/load-type.c        |   2 +-
 validation/backend/logical-ops.c      |   2 +-
 validation/backend/loop.c             |   2 +-
 validation/backend/loop2.c            |   2 +-
 validation/backend/ptrcast.c          |   2 +-
 validation/backend/store-type.c       |   2 +-
 validation/backend/struct-access.c    |   2 +-
 validation/backend/struct.c           |   2 +-
 validation/backend/sum.c              |   2 +-
 validation/backend/union.c            |   2 +-
 validation/backend/void-return-type.c |   2 +-
 validation/prototype.c                |   2 +-
 validation/test-suite                 | 137 +++++++++++++++++++---------------
 23 files changed, 97 insertions(+), 84 deletions(-)

-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 0/6] testsuite speedup
Date: Sun, 28 May 2017 22:04:28 +0000
Message-ID: <47420cd6-74bc-8037-5d92-7e65f8aa8560 () ramsayjones ! plus ! com>
--------------------


On 28/05/17 20:29, Luc Van Oostenryck wrote:
> The goal of this series is to speedup the testsuite,
> mainly by avoiding to unneedlessly spawn child processes.
> 
> The resulting speedup here is over 2.5, which is quite appreciable.

I would have liked to try these out, particularly on cygwin, but I
could not get them to apply. (patch #4 has a line: 'rm -f $file.{error,output}.{expected,got,diff}' in the context which I don't have).

I was attempting to apply on top of 'sparse-next-20170516'.
Should I apply to a different branch?
Were they built on a branch I don't have?

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 0/6] testsuite speedup
Date: Mon, 29 May 2017 01:44:52 +0000
Message-ID: <b5d44360-82c0-5a3f-ecdc-98a9b7e9f35a () ramsayjones ! plus ! com>
--------------------


On 28/05/17 23:39, Luc Van Oostenryck wrote:
> On Mon, May 29, 2017 at 12:04 AM, Ramsay Jones
> <ramsay@ramsayjones.plus.com> wrote:
>>
>>
>> On 28/05/17 20:29, Luc Van Oostenryck wrote:
>>> The goal of this series is to speedup the testsuite,
>>> mainly by avoiding to unneedlessly spawn child processes.
>>>
>>> The resulting speedup here is over 2.5, which is quite appreciable.
>>
>> I would have liked to try these out, particularly on cygwin, but I
>> could not get them to apply. (patch #4 has a line: 'rm -f $file.{error,output}.{expected,got,diff}' in the context which I don't have).
>>
>> I was attempting to apply on top of 'sparse-next-20170516'.
>> Should I apply to a different branch?
>> Were they built on a branch I don't have?
> 
> Ah yes, sorry for that.
> It should be applied on top of the next sparse-next but Chris hasn't yet
> pulled it.
> 
> If you wish you can directly use the branch on my github tree:
>         git://github.com/lucvoo/sparse.git testsuite-faster

Thanks. I very quickly tried it on cygwin and the time to run the
testsuite fell from 2m14.607s down to 1m0.298s. So, a nice time
saver. ;-)

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/6] testsuite speedup
Date: Thu, 01 Jun 2017 09:16:11 +0000
Message-ID: <CANeU7Q=DrsNrLdnSH55pUk1fAcNPUzUh5bHQ76fqt18PtRgOPQ () mail ! gmail ! com>
--------------------
On Sun, May 28, 2017 at 12:29 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The goal of this series is to speedup the testsuite,
> mainly by avoiding to unneedlessly spawn child processes.
>
> The resulting speedup here is over 2.5, which is quite appreciable.

This series looks fine to me.

BTW, another way to speed up the test suit is using makefile to invoke
more than one job of test suite. Currently all test suit are execute
one by one. But there is no inter dependency between the test.
So in theory we can change the Makefile a bit to run more than one
job on the test suit using pattern rules.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/6] testsuite speedup
Date: Thu, 01 Jun 2017 14:05:01 +0000
Message-ID: <CAExDi1SZv31NHPZ2ddCsQQKpr5T-H6j3ZBwi_0p8EfCG-ycYUA () mail ! gmail ! com>
--------------------
On Thu, Jun 1, 2017 at 11:16 AM, Christopher Li <sparse@chrisli.org> wrote:
> BTW, another way to speed up the test suit is using makefile to invoke
> more than one job of test suite. Currently all test suit are execute
> one by one. But there is no inter dependency between the test.
> So in theory we can change the Makefile a bit to run more than one
> job on the test suit using pattern rules.

Yes, but there is a few issues with this:
- 'test-suite single file.c' doesn't exit with the right return code yet
- parallelizing tests with make won't return the summary of the tests
  (which may or may not be needed)
- the error messages could be mixed in
- make would stop at the first error (which may be OK or not)
- would be better used with something like 'test-suite --very-quiet file.c'

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 0/6] testsuite speedup
Date: Fri, 02 Jun 2017 07:29:47 +0000
Message-ID: <CANeU7QkDj5eKxGZHpJ_QZVpq5dhbxYRu4_+D93PzO8to+THaqQ () mail ! gmail ! com>
--------------------
On Thu, Jun 1, 2017 at 7:05 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Yes, but there is a few issues with this:
> - 'test-suite single file.c' doesn't exit with the right return code yet
> - parallelizing tests with make won't return the summary of the tests
>   (which may or may not be needed)
> - the error messages could be mixed in
> - make would stop at the first error (which may be OK or not)
> - would be better used with something like 'test-suite --very-quiet file.c'

How about the parallel running just run individual test and
save the result/error in per test file. Have the a report target that process
all the individual run result. That will get rid of the result
ordering issue, no
error mix in, no early stop etc.

test-suite will need to change a bit for the separate report phrase.
I am not suggesting make that into this series. This series is fine
as it is. I am only making suggestion that parallelizing can speed
up the check run by a few times.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 0/8] avoid creating orphaned OP_PHISRCs ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 0/8] avoid creating orphaned OP_PHISRCs
Date: Thu, 13 Apr 2017 16:55:43 +0000
Message-ID: <20170413165551.2785-1-luc.vanoostenryck () gmail ! com>
--------------------
The goal of this series is to avoid the creation of
orphaned OP_PHISRCs by simplify_loads() when it appears
that the loads con't be simplified afterall but that some
OP_PHISRC have already been created.
This change then lead to some code restructuration and
simplification.

This series is available at:
	git://github.com/lucvoo/sparse.git fix-orphaned-phisrc
based on commits (a merge)
	ac6c25bc066eab36942539ba11c7ab6cf0c63674 (bool-context)
	ecda2093f19088fa94c3a4ac85359c6d0f1c64af (fix-cond-address)
	fc981fe285c37ee297e93ef1cc8725caac75f9b3 (fix-bitfield-init-v2)
up to commit:
	8b6716908788dfd1713215e7d4ddaa4f3d341948


Luc Van Oostenryck (8):
  extract add_dominator() from find_dominating_parents()
  add helper add_load_dominators()
  remove test on initial phi->ident
  avoid phisrc orphaned by simplify_loads()
  avoid phisrc orphaned by find_dominating_stores()
  integrate add_load_dominators() into rewrite_load_instruction()
  check duplicated phi-nodes directly on dominators
  avoid creating unneeded phi-sources

 flow.c                               | 79 +++++++++++++++++++++++-------------
 flow.h                               |  2 +-
 memops.c                             | 14 ++-----
 validation/linear/phisrc-orphan-ld.c | 22 ++++++++++
 validation/linear/phisrc-orphan-st.c | 17 ++++++++
 validation/loop-linearization.c      | 30 +++++++-------
 6 files changed, 110 insertions(+), 54 deletions(-)
 create mode 100644 validation/linear/phisrc-orphan-ld.c
 create mode 100644 validation/linear/phisrc-orphan-st.c

-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 0/8] avoid creating orphaned OP_PHISRCs
Date: Thu, 18 May 2017 17:04:26 +0000
Message-ID: <20170518170425.ozrccywqkkglpgd6 () desk ! local>
--------------------
Another problem with the creation and placement of phi-nodes
is with some code like:
	#define	CHECK(t,  c, N)	\
		t = ptr[N];	\
		if (t)		\
			c++;

	int foo(int *ptr);
	int foo(int *ptr)
	{
		int c = 0;
		int t;

		CHECK(t, c, 0x000);
		CHECK(t, c, 0x001);

		return c;
	}

which will be linearized as:
	foo:
		load.32     %r2 <- 0[%arg1]
		phisrc.32   %phi2(c) <- $0
		phisrc.32   %phi5(c) <- $0
		cbr         %r2, .L1, .L2
	.L1:
		phisrc.32   %phi3(c) <- $1
		phisrc.32   %phi6(c) <- $1
		br          .L2
	.L2:
		load.32     %r7 <- 4[%arg1]
		cbr         %r7, .L3, .L4
	.L3:
		phi.32      %r9 <- %phi5(c), %phi6(c)
		add.32      %r10 <- %r9, $1
		phisrc.32   %phi4(c) <- %r10
		br          .L4
	.L4:
		phi.32      %r11 <- %phi2(c), %phi3(c), %phi4(c)
		ret.32      %r11

This is with the last phi-node and the placement of its phisrcs.
- .L4 has 2 parents, .L2 & .L3, so the phi-node should have 2 sources
- the 2 sources should be placed (at the end of) .L2 & L3
- only %phi4 is really well placed
- %phi3 is not placed at .L2 but before (which is fine too)
- the real problem is with %phi2: all paths to .L4 go where %phi3
  & %phi4 are defined, so %phi2 is in fact dead and should never
  be a source for the last phi-node.
There is worst though, here the CHECK is only two times.
If called N times, the last phi-node will have N sources
(while still having only 2 reaching paths), quadratic behaviour
thus (at N=300, the show_instruction() buffer is too small, at
N=2000 it needs 50 secs of processing).
Note that the CHECK macro is called here with the array ptr and the
problem may seem a bit artificial since it's like a manual loop
unrolling, but I can very well imagine some similar code called
not on the array elements but on a few functions (checking for
some ressources availability for example).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 00/28] testsuite improvements ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 00/28] testsuite improvements
Date: Fri, 15 Sep 2017 07:13:30 +0000
Message-ID: <20170915071358.7312-1-luc.vanoostenryck () gmail ! com>
--------------------
This series contains diverse small improvements to
the testsuite.


The series is also available for review in the git repository at:
  git://github.com/lucvoo/sparse.git testsuite-clean

----------------------------------------------------------------
Luc Van Oostenryck (28):
      testsuite: 'echo -n' may not be interpreted as '-n'
      testsuite: allow to test a few cases at once
      testsuite: move verbose() & error()
      testsuite: better message for pattern nbr checking
      testsuite: better message for pattern absence/presence
      testsuite: saner checking of pattern occurences
      testsuite: clearer result summary
      testsuite: check error messages first
      testsuite: saner handling of 'must_fail'
      testsuite: allow to parse several options
      testsuite: add support for -q|--quiet
      testsuite: add support for -a|--abort
      testsuite: get options from env too
      testsuite: allow --format & --single
      testsuite: remove useless selftest
      testsuite: remove useless test-be.c
      testsuite: extract disable()
      testsuite: simplify documentation
      testsuite: allow arch-specific tests
      testsuite: save screen real estate
      testsuite: add a blank line before format
      testsuite: 'quiet' must be initialized earlier
      testsuite: move up arg_file()
      testsuite: make do_format() more self-contained
      testsuite: format: saner defaults handling
      testsuite: format: strip .c from default name
      testsuite: add support for 'format -f'
      testsuite: add support for 'format -l'

 Documentation/test-suite          |  35 +++--
 validation/test-be.c              |  46 ------
 validation/test-suite             | 286 ++++++++++++++++++++++++++++++--------
 validation/testsuite-selfcheck1.c |  10 --
 validation/testsuite-selfcheck2.c |  10 --
 validation/testsuite-selfcheck3.c |  10 --
 6 files changed, 249 insertions(+), 148 deletions(-)
 delete mode 100644 validation/test-be.c
 delete mode 100644 validation/testsuite-selfcheck1.c
 delete mode 100644 validation/testsuite-selfcheck2.c
 delete mode 100644 validation/testsuite-selfcheck3.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 00/28] testsuite improvements
Date: Fri, 15 Sep 2017 17:35:41 +0000
Message-ID: <CAExDi1SJcbups-y7Xr0VngMg1hM2jvKEYrHd6Ps_xKN=+q+8pw () mail ! gmail ! com>
--------------------
On Fri, Sep 15, 2017 at 7:03 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Fri, Sep 15, 2017 at 3:13 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> This series contains diverse small improvements to
>> the testsuite.
>>
>
> Thanks for the patch. It will keep me busy for a little while.
>
> I am might not able to finish reading it today.
>
> BTW, patchworks seems not updating. I haven't able to fetch
> yours and some other  patch on the sparse mailing list.
>
> https://patchwork.kernel.org/project/linux-sparse/list/

Yes, I saw that too.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 00/28] testsuite improvements
Date: Wed, 20 Sep 2017 05:53:28 +0000
Message-ID: <CANeU7QkwOYet=oqDon2azex-PgEsx+EvK4BGCGLEdNSfPus29g () mail ! gmail ! com>
--------------------
On Fri, Sep 15, 2017 at 3:13 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This series contains diverse small improvements to
> the testsuite.
>
>
> The series is also available for review in the git repository at:
>   git://github.com/lucvoo/sparse.git testsuite-clean

I take a brief look at this series. It seems fine to me.

I will wait for the git pull for it then.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] V2 Give the constant pseudo value a size ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Mon, 13 Nov 2017 15:28:03 +0000
Message-ID: <CANeU7Q=VPubjUkjWP20Ye8rA8d42OfVD=xM1U-quVqGK4kQb+g () mail ! gmail ! com>
--------------------
Currently value pseudo does not have size.
This create a problem pointed out by Dibyendu.
When using LLVM, calling varidic function with
constant value, there is no where to find the
size.

Linus give out two suggestions. One is give pseudo
a size. The other one is the push instruction.
This is the implementation of the first suggestion.

The model is actual very simple. The pseudo is
exactly as before if you are not looking at the size.
There is a size at create time, which tag alone with
it.

I might not get all the type and cast of the constant
right, we can fix it later if we found some case I did
not cover.

Testing done:

- Test suite passed.
- Kernel compile get the exact same output as the RC5
  at similar time.

Reported-by: Dibyendu Majumdar <mobile@majumdar.org.uk>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Christopher Li <sparse@chrisli.org>
---
 flow.c      |  2 +-
 linearize.c | 23 +++++++++++++----------
 linearize.h |  8 ++++++--
 memops.c    |  2 +-
 simplify.c  | 20 ++++++++++----------
 5 files changed, 31 insertions(+), 24 deletions(-)

diff --git a/flow.c b/flow.c
index 6b2c879a..fa5d31c8 100644
--- a/flow.c
+++ b/flow.c
@@ -517,7 +517,7 @@ found:
  if (!local)
  return 0;
  check_access(insn);
- convert_load_instruction(insn, value_pseudo(0));
+ convert_load_instruction(insn, value_pseudo(insn->type, 0));
  return 1;
  }

diff --git a/linearize.c b/linearize.c
index ba76397e..2aa3acb2 100644
--- a/linearize.c
+++ b/linearize.c
@@ -785,22 +785,25 @@ static pseudo_t symbol_pseudo(struct entrypoint
*ep, struct symbol *sym)
  return pseudo;
 }

-pseudo_t value_pseudo(long long val)
+pseudo_t value_pseudo(struct symbol *type, long long val)
 {
 #define MAX_VAL_HASH 64
  static struct pseudo_list *prev[MAX_VAL_HASH];
  int hash = val & (MAX_VAL_HASH-1);
  struct pseudo_list **list = prev + hash;
+ int size = type ? type->bit_size : value_size(val);
  pseudo_t pseudo;

+
  FOR_EACH_PTR(*list, pseudo) {
- if (pseudo->value == val)
+ if (pseudo->value == val && pseudo->size == size)
  return pseudo;
  } END_FOR_EACH_PTR(pseudo);

  pseudo = __alloc_pseudo(0);
  pseudo->type = PSEUDO_VAL;
  pseudo->value = val;
+ pseudo->size = size;
  add_pseudo(list, pseudo);

  /* Value pseudos have neither nr, usage nor def */
@@ -954,10 +957,10 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
  unsigned long long mask = (1ULL << size) - 1;

  if (shift) {
- store = add_binary_op(ep, ad->source_type, OP_SHL, value,
value_pseudo(shift));
+ store = add_binary_op(ep, ad->source_type, OP_SHL, value,
value_pseudo(ctype, shift));
  mask <<= shift;
  }
- orig = add_binary_op(ep, ad->source_type, OP_AND, orig, value_pseudo(~mask));
+ orig = add_binary_op(ep, ad->source_type, OP_AND, orig,
value_pseudo(ctype, ~mask));
  store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
  }
  add_store(ep, ad, store);
@@ -1002,7 +1005,7 @@ static pseudo_t linearize_load_gen(struct
entrypoint *ep, struct access_data *ad
  pseudo_t new = add_load(ep, ad);

  if (ctype->bit_offset) {
- pseudo_t shift = value_pseudo(ctype->bit_offset);
+ pseudo_t shift = value_pseudo(ctype, ctype->bit_offset);
  pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
  new = newval;
  }
@@ -1034,7 +1037,7 @@ static pseudo_t linearize_inc_dec(struct
entrypoint *ep, struct expression *expr
  return VOID;

  old = linearize_load_gen(ep, &ad);
- one = value_pseudo(expr->op_value);
+ one = value_pseudo(expr->ctype, expr->op_value);
  new = add_binary_op(ep, expr->ctype, op, old, one);
  linearize_store_gen(ep, new, &ad);
  finish_address_gen(ep, &ad);
@@ -1073,7 +1076,7 @@ static pseudo_t linearize_regular_preop(struct
entrypoint *ep, struct expression
  case '+':
  return pre;
  case '!': {
- pseudo_t zero = value_pseudo(0);
+ pseudo_t zero = value_pseudo(expr->ctype, 0);
  return add_binary_op(ep, expr->ctype, OP_SET_EQ, pre, zero);
  }
  case '~':
@@ -1165,7 +1168,7 @@ static inline pseudo_t
add_convert_to_bool(struct entrypoint *ep, pseudo_t src,

  if (is_bool_type(type))
  return src;
- zero = value_pseudo(0);
+ zero = value_pseudo(type, 0);
  op = OP_SET_NE;
  return add_binary_op(ep, &bool_ctype, op, src, zero);
 }
@@ -1591,7 +1594,7 @@ pseudo_t linearize_expression(struct entrypoint
*ep, struct expression *expr)
  return add_symbol_address(ep, expr->symbol);

  case EXPR_VALUE:
- return value_pseudo(expr->value);
+ return value_pseudo(expr->ctype, expr->value);

  case EXPR_STRING: case EXPR_FVALUE: case EXPR_LABEL:
  return add_setval(ep, expr->ctype, expr);
@@ -1681,7 +1684,7 @@ static pseudo_t linearize_one_symbol(struct
entrypoint *ep, struct symbol *sym)
  ad.result_type = sym;
  ad.source_type = base_type(sym);
  ad.address = symbol_pseudo(ep, sym);
- linearize_store_gen(ep, value_pseudo(0), &ad);
+ linearize_store_gen(ep, value_pseudo(sym, 0), &ad);
  }

  value = linearize_initializer(ep, sym->initializer, &ad);
diff --git a/linearize.h b/linearize.h
index bac82d7f..fd8e00d3 100644
--- a/linearize.h
+++ b/linearize.h
@@ -32,7 +32,10 @@ struct pseudo {
  int nr;
  enum pseudo_type type;
  struct pseudo_user_list *users;
- struct ident *ident;
+ union {
+ struct ident *ident;
+ int size; /* OP_SETVAL only */
+ };
  union {
  struct symbol *sym;
  struct instruction *def;
@@ -333,7 +336,8 @@ extern void insert_branch(struct basic_block *bb,
struct instruction *br, struct

 pseudo_t alloc_phi(struct basic_block *source, pseudo_t pseudo, int size);
 pseudo_t alloc_pseudo(struct instruction *def);
-pseudo_t value_pseudo(long long val);
+pseudo_t value_pseudo(struct symbol *type, long long val);
+unsigned int value_size(long long value);

 struct entrypoint *linearize_symbol(struct symbol *sym);
 int unssa(struct entrypoint *ep);
diff --git a/memops.c b/memops.c
index aeacdf56..6a795c19 100644
--- a/memops.c
+++ b/memops.c
@@ -127,7 +127,7 @@ static void simplify_loads(struct basic_block *bb)
  if (!dominators) {
  if (local) {
  assert(pseudo->type != PSEUDO_ARG);
- convert_load_instruction(insn, value_pseudo(0));
+ convert_load_instruction(insn, value_pseudo(insn->type, 0));
  }
  goto next_load;
  }
diff --git a/simplify.c b/simplify.c
index 2bc86f53..1e926e7d 100644
--- a/simplify.c
+++ b/simplify.c
@@ -352,7 +352,7 @@ static int replace_with_pseudo(struct instruction
*insn, pseudo_t pseudo)
  return REPEAT_CSE;
 }

-static unsigned int value_size(long long value)
+unsigned int value_size(long long value)
 {
  value >>= 8;
  if (!value)
@@ -398,7 +398,7 @@ static int simplify_asr(struct instruction *insn,
pseudo_t pseudo, long long val

  if (value >= size) {
  warning(insn->pos, "right shift by bigger than source value");
- return replace_with_pseudo(insn, value_pseudo(0));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 0));
  }
  if (!value)
  return replace_with_pseudo(insn, pseudo);
@@ -508,7 +508,7 @@ static int simplify_constant_rightside(struct
instruction *insn)
  case OP_SUB:
  if (value) {
  insn->opcode = OP_ADD;
- insn->src2 = value_pseudo(-value);
+ insn->src2 = value_pseudo(insn->type, -value);
  return REPEAT_CSE;
  }
  /* Fall through */
@@ -525,7 +525,7 @@ static int simplify_constant_rightside(struct
instruction *insn)

  case OP_MODU: case OP_MODS:
  if (value == 1)
- return replace_with_pseudo(insn, value_pseudo(0));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 0));
  return 0;

  case OP_DIVU: case OP_DIVS:
@@ -686,7 +686,7 @@ static int simplify_constant_binop(struct instruction *insn)
  }
  res &= bits;

- replace_with_pseudo(insn, value_pseudo(res));
+ replace_with_pseudo(insn, value_pseudo(insn->type, res));
  return REPEAT_CSE;
 }

@@ -700,14 +700,14 @@ static int simplify_binop_same_args(struct
instruction *insn, pseudo_t arg)
  warning(insn->pos, "self-comparison always evaluates to false");
  case OP_SUB:
  case OP_XOR:
- return replace_with_pseudo(insn, value_pseudo(0));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 0));

  case OP_SET_EQ:
  case OP_SET_LE: case OP_SET_GE:
  case OP_SET_BE: case OP_SET_AE:
  if (Wtautological_compare)
  warning(insn->pos, "self-comparison always evaluates to true");
- return replace_with_pseudo(insn, value_pseudo(1));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 1));

  case OP_AND:
  case OP_OR:
@@ -716,7 +716,7 @@ static int simplify_binop_same_args(struct
instruction *insn, pseudo_t arg)
  case OP_AND_BOOL:
  case OP_OR_BOOL:
  remove_usage(arg, &insn->src2);
- insn->src2 = value_pseudo(0);
+ insn->src2 = value_pseudo(insn->type, 0);
  insn->opcode = OP_SET_NE;
  return REPEAT_CSE;

@@ -819,7 +819,7 @@ static int simplify_constant_unop(struct instruction *insn)
  mask = 1ULL << (insn->size-1);
  res &= mask | (mask-1);

- replace_with_pseudo(insn, value_pseudo(res));
+ replace_with_pseudo(insn, value_pseudo(insn->type, res));
  return REPEAT_CSE;
 }

@@ -952,7 +952,7 @@ static int simplify_cast(struct instruction *insn)
  if (constant(src)) {
  int sign = orig_type->ctype.modifiers & MOD_SIGNED;
  long long val = get_cast_value(src->value, orig_size, size, sign);
- src = value_pseudo(val);
+ src = value_pseudo(orig_type, val);
  goto simplify;
  }

-- 
2.13.6
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Mon, 13 Nov 2017 15:28:03 +0000
Message-ID: <CANeU7Q=VPubjUkjWP20Ye8rA8d42OfVD=xM1U-quVqGK4kQb+g () mail ! gmail ! com>
--------------------
Currently value pseudo does not have size.
This create a problem pointed out by Dibyendu.
When using LLVM, calling varidic function with
constant value, there is no where to find the
size.

Linus give out two suggestions. One is give pseudo
a size. The other one is the push instruction.
This is the implementation of the first suggestion.

The model is actual very simple. The pseudo is
exactly as before if you are not looking at the size.
There is a size at create time, which tag alone with
it.

I might not get all the type and cast of the constant
right, we can fix it later if we found some case I did
not cover.

Testing done:

- Test suite passed.
- Kernel compile get the exact same output as the RC5
  at similar time.

Reported-by: Dibyendu Majumdar <mobile@majumdar.org.uk>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Christopher Li <sparse@chrisli.org>
---
 flow.c      |  2 +-
 linearize.c | 23 +++++++++++++----------
 linearize.h |  8 ++++++--
 memops.c    |  2 +-
 simplify.c  | 20 ++++++++++----------
 5 files changed, 31 insertions(+), 24 deletions(-)

diff --git a/flow.c b/flow.c
index 6b2c879a..fa5d31c8 100644
--- a/flow.c
+++ b/flow.c
@@ -517,7 +517,7 @@ found:
  if (!local)
  return 0;
  check_access(insn);
- convert_load_instruction(insn, value_pseudo(0));
+ convert_load_instruction(insn, value_pseudo(insn->type, 0));
  return 1;
  }

diff --git a/linearize.c b/linearize.c
index ba76397e..2aa3acb2 100644
--- a/linearize.c
+++ b/linearize.c
@@ -785,22 +785,25 @@ static pseudo_t symbol_pseudo(struct entrypoint
*ep, struct symbol *sym)
  return pseudo;
 }

-pseudo_t value_pseudo(long long val)
+pseudo_t value_pseudo(struct symbol *type, long long val)
 {
 #define MAX_VAL_HASH 64
  static struct pseudo_list *prev[MAX_VAL_HASH];
  int hash = val & (MAX_VAL_HASH-1);
  struct pseudo_list **list = prev + hash;
+ int size = type ? type->bit_size : value_size(val);
  pseudo_t pseudo;

+
  FOR_EACH_PTR(*list, pseudo) {
- if (pseudo->value == val)
+ if (pseudo->value == val && pseudo->size == size)
  return pseudo;
  } END_FOR_EACH_PTR(pseudo);

  pseudo = __alloc_pseudo(0);
  pseudo->type = PSEUDO_VAL;
  pseudo->value = val;
+ pseudo->size = size;
  add_pseudo(list, pseudo);

  /* Value pseudos have neither nr, usage nor def */
@@ -954,10 +957,10 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
  unsigned long long mask = (1ULL << size) - 1;

  if (shift) {
- store = add_binary_op(ep, ad->source_type, OP_SHL, value,
value_pseudo(shift));
+ store = add_binary_op(ep, ad->source_type, OP_SHL, value,
value_pseudo(ctype, shift));
  mask <<= shift;
  }
- orig = add_binary_op(ep, ad->source_type, OP_AND, orig, value_pseudo(~mask));
+ orig = add_binary_op(ep, ad->source_type, OP_AND, orig,
value_pseudo(ctype, ~mask));
  store = add_binary_op(ep, ad->source_type, OP_OR, orig, store);
  }
  add_store(ep, ad, store);
@@ -1002,7 +1005,7 @@ static pseudo_t linearize_load_gen(struct
entrypoint *ep, struct access_data *ad
  pseudo_t new = add_load(ep, ad);

  if (ctype->bit_offset) {
- pseudo_t shift = value_pseudo(ctype->bit_offset);
+ pseudo_t shift = value_pseudo(ctype, ctype->bit_offset);
  pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
  new = newval;
  }
@@ -1034,7 +1037,7 @@ static pseudo_t linearize_inc_dec(struct
entrypoint *ep, struct expression *expr
  return VOID;

  old = linearize_load_gen(ep, &ad);
- one = value_pseudo(expr->op_value);
+ one = value_pseudo(expr->ctype, expr->op_value);
  new = add_binary_op(ep, expr->ctype, op, old, one);
  linearize_store_gen(ep, new, &ad);
  finish_address_gen(ep, &ad);
@@ -1073,7 +1076,7 @@ static pseudo_t linearize_regular_preop(struct
entrypoint *ep, struct expression
  case '+':
  return pre;
  case '!': {
- pseudo_t zero = value_pseudo(0);
+ pseudo_t zero = value_pseudo(expr->ctype, 0);
  return add_binary_op(ep, expr->ctype, OP_SET_EQ, pre, zero);
  }
  case '~':
@@ -1165,7 +1168,7 @@ static inline pseudo_t
add_convert_to_bool(struct entrypoint *ep, pseudo_t src,

  if (is_bool_type(type))
  return src;
- zero = value_pseudo(0);
+ zero = value_pseudo(type, 0);
  op = OP_SET_NE;
  return add_binary_op(ep, &bool_ctype, op, src, zero);
 }
@@ -1591,7 +1594,7 @@ pseudo_t linearize_expression(struct entrypoint
*ep, struct expression *expr)
  return add_symbol_address(ep, expr->symbol);

  case EXPR_VALUE:
- return value_pseudo(expr->value);
+ return value_pseudo(expr->ctype, expr->value);

  case EXPR_STRING: case EXPR_FVALUE: case EXPR_LABEL:
  return add_setval(ep, expr->ctype, expr);
@@ -1681,7 +1684,7 @@ static pseudo_t linearize_one_symbol(struct
entrypoint *ep, struct symbol *sym)
  ad.result_type = sym;
  ad.source_type = base_type(sym);
  ad.address = symbol_pseudo(ep, sym);
- linearize_store_gen(ep, value_pseudo(0), &ad);
+ linearize_store_gen(ep, value_pseudo(sym, 0), &ad);
  }

  value = linearize_initializer(ep, sym->initializer, &ad);
diff --git a/linearize.h b/linearize.h
index bac82d7f..fd8e00d3 100644
--- a/linearize.h
+++ b/linearize.h
@@ -32,7 +32,10 @@ struct pseudo {
  int nr;
  enum pseudo_type type;
  struct pseudo_user_list *users;
- struct ident *ident;
+ union {
+ struct ident *ident;
+ int size; /* OP_SETVAL only */
+ };
  union {
  struct symbol *sym;
  struct instruction *def;
@@ -333,7 +336,8 @@ extern void insert_branch(struct basic_block *bb,
struct instruction *br, struct

 pseudo_t alloc_phi(struct basic_block *source, pseudo_t pseudo, int size);
 pseudo_t alloc_pseudo(struct instruction *def);
-pseudo_t value_pseudo(long long val);
+pseudo_t value_pseudo(struct symbol *type, long long val);
+unsigned int value_size(long long value);

 struct entrypoint *linearize_symbol(struct symbol *sym);
 int unssa(struct entrypoint *ep);
diff --git a/memops.c b/memops.c
index aeacdf56..6a795c19 100644
--- a/memops.c
+++ b/memops.c
@@ -127,7 +127,7 @@ static void simplify_loads(struct basic_block *bb)
  if (!dominators) {
  if (local) {
  assert(pseudo->type != PSEUDO_ARG);
- convert_load_instruction(insn, value_pseudo(0));
+ convert_load_instruction(insn, value_pseudo(insn->type, 0));
  }
  goto next_load;
  }
diff --git a/simplify.c b/simplify.c
index 2bc86f53..1e926e7d 100644
--- a/simplify.c
+++ b/simplify.c
@@ -352,7 +352,7 @@ static int replace_with_pseudo(struct instruction
*insn, pseudo_t pseudo)
  return REPEAT_CSE;
 }

-static unsigned int value_size(long long value)
+unsigned int value_size(long long value)
 {
  value >>= 8;
  if (!value)
@@ -398,7 +398,7 @@ static int simplify_asr(struct instruction *insn,
pseudo_t pseudo, long long val

  if (value >= size) {
  warning(insn->pos, "right shift by bigger than source value");
- return replace_with_pseudo(insn, value_pseudo(0));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 0));
  }
  if (!value)
  return replace_with_pseudo(insn, pseudo);
@@ -508,7 +508,7 @@ static int simplify_constant_rightside(struct
instruction *insn)
  case OP_SUB:
  if (value) {
  insn->opcode = OP_ADD;
- insn->src2 = value_pseudo(-value);
+ insn->src2 = value_pseudo(insn->type, -value);
  return REPEAT_CSE;
  }
  /* Fall through */
@@ -525,7 +525,7 @@ static int simplify_constant_rightside(struct
instruction *insn)

  case OP_MODU: case OP_MODS:
  if (value == 1)
- return replace_with_pseudo(insn, value_pseudo(0));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 0));
  return 0;

  case OP_DIVU: case OP_DIVS:
@@ -686,7 +686,7 @@ static int simplify_constant_binop(struct instruction *insn)
  }
  res &= bits;

- replace_with_pseudo(insn, value_pseudo(res));
+ replace_with_pseudo(insn, value_pseudo(insn->type, res));
  return REPEAT_CSE;
 }

@@ -700,14 +700,14 @@ static int simplify_binop_same_args(struct
instruction *insn, pseudo_t arg)
  warning(insn->pos, "self-comparison always evaluates to false");
  case OP_SUB:
  case OP_XOR:
- return replace_with_pseudo(insn, value_pseudo(0));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 0));

  case OP_SET_EQ:
  case OP_SET_LE: case OP_SET_GE:
  case OP_SET_BE: case OP_SET_AE:
  if (Wtautological_compare)
  warning(insn->pos, "self-comparison always evaluates to true");
- return replace_with_pseudo(insn, value_pseudo(1));
+ return replace_with_pseudo(insn, value_pseudo(insn->type, 1));

  case OP_AND:
  case OP_OR:
@@ -716,7 +716,7 @@ static int simplify_binop_same_args(struct
instruction *insn, pseudo_t arg)
  case OP_AND_BOOL:
  case OP_OR_BOOL:
  remove_usage(arg, &insn->src2);
- insn->src2 = value_pseudo(0);
+ insn->src2 = value_pseudo(insn->type, 0);
  insn->opcode = OP_SET_NE;
  return REPEAT_CSE;

@@ -819,7 +819,7 @@ static int simplify_constant_unop(struct instruction *insn)
  mask = 1ULL << (insn->size-1);
  res &= mask | (mask-1);

- replace_with_pseudo(insn, value_pseudo(res));
+ replace_with_pseudo(insn, value_pseudo(insn->type, res));
  return REPEAT_CSE;
 }

@@ -952,7 +952,7 @@ static int simplify_cast(struct instruction *insn)
  if (constant(src)) {
  int sign = orig_type->ctype.modifiers & MOD_SIGNED;
  long long val = get_cast_value(src->value, orig_size, size, sign);
- src = value_pseudo(val);
+ src = value_pseudo(orig_type, val);
  goto simplify;
  }

-- 
2.13.6
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Sun, 24 Dec 2017 13:10:34 +0000
Message-ID: <CACXZuxdHeCqQ5x7i2a6ZTHAFSMJWHm3Myyq3TkP6Wj5Ca6bcVQ () mail ! gmail ! com>
--------------------
Hi Chris,

On 13 November 2017 at 15:28, Christopher Li <sparse@chrisli.org> wrote:
> Currently value pseudo does not have size.
> This create a problem pointed out by Dibyendu.
> When using LLVM, calling varidic function with
> constant value, there is no where to find the
> size.
>
> Linus give out two suggestions. One is give pseudo
> a size. The other one is the push instruction.
> This is the implementation of the first suggestion.

I tested out this change in my code base and it seems fine. I hope this helps.

Thanks and Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Sat, 03 Mar 2018 21:26:52 +0000
Message-ID: <CACXZuxeYjytN3SD=79zYeivf3HQ0rwPvJyoq86OAe_U5wORb3w () mail ! gmail ! com>
--------------------
On 13 November 2017 at 15:28, Christopher Li <sparse@chrisli.org> wrote:
> Currently value pseudo does not have size.
> This create a problem pointed out by Dibyendu.
> When using LLVM, calling varidic function with
> constant value, there is no where to find the
> size.
>
> Linus give out two suggestions. One is give pseudo
> a size. The other one is the push instruction.
> This is the implementation of the first suggestion.
>
> The model is actual very simple. The pseudo is
> exactly as before if you are not looking at the size.
> There is a size at create time, which tag alone with
> it.
>

Chris, I think the discussion of this topic should be moved to this thread.

I found a problem with this as I mentioned in the other thread. Last
year a change was introduced to initialize aggregate structures in
Sparse using a store instruction that uses a PSEUDO_VAL. However when
this creates a pseudo the size is set to the size of the aggregate
types - and this size (> 64 bits) is kind of nonsensical for a
PSEUDO_VAL.

I suggested that when creating a PSEUDO_VAL we should only create
distinct values when size is register size - i.e. one of 8, 16, 32, or
64. Else we should set size to 0.

Couple of more points:

a) We should also set size to 0 when we create a PSEUDO_VAL in CSE for
uninitialized vars.
b) We should ideally avoid CSE on PSEUDO_VAL with size = 0 because I
don't think it makes sense to do so - i.e. they either represent
uninitialized vars or aggregates > 64 bits.

The above aggregate initialization change is one of the changes I did
not merge into my project as I wasn't happy with it. I still think
this change is not correct and needs to be removed or redone. I am not
100% sure but presumably creating PSEUDO_VAL where the instruction
size is > 64-bits means that these PSEUDO_VAL values might be
considered 'same as' any other PSEUDO_VAL with value 0.

Thanks and Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Sat, 03 Mar 2018 22:18:09 +0000
Message-ID: <CACXZuxdHgXhTtifO5taHLpomEWJcL3RiosW8N=Xphyz7JTP67Q () mail ! gmail ! com>
--------------------
On 3 March 2018 at 21:42, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
> On 3 March 2018 at 21:26, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
>> On 13 November 2017 at 15:28, Christopher Li <sparse@chrisli.org> wrote:
>>> Currently value pseudo does not have size.
>>> This create a problem pointed out by Dibyendu.
>>> When using LLVM, calling varidic function with
>>> constant value, there is no where to find the
>>> size.
>>>
>>> Linus give out two suggestions. One is give pseudo
>>> a size. The other one is the push instruction.
>>> This is the implementation of the first suggestion.
>>>
>>> The model is actual very simple. The pseudo is
>>> exactly as before if you are not looking at the size.
>>> There is a size at create time, which tag alone with
>>> it.
>>>
>>
>> Chris, I think the discussion of this topic should be moved to this thread.
>>
>> I found a problem with this as I mentioned in the other thread. Last
>> year a change was introduced to initialize aggregate structures in
>> Sparse using a store instruction that uses a PSEUDO_VAL. However when
>> this creates a pseudo the size is set to the size of the aggregate
>> types - and this size (> 64 bits) is kind of nonsensical for a
>> PSEUDO_VAL.
>>
>> I suggested that when creating a PSEUDO_VAL we should only create
>> distinct values when size is register size - i.e. one of 8, 16, 32, or
>> 64. Else we should set size to 0.
>>
>> Couple of more points:
>>
>> a) We should also set size to 0 when we create a PSEUDO_VAL in CSE for
>> uninitialized vars.
>> b) We should ideally avoid CSE on PSEUDO_VAL with size = 0 because I
>> don't think it makes sense to do so - i.e. they either represent
>> uninitialized vars or aggregates > 64 bits.
>>
>> The above aggregate initialization change is one of the changes I did
>> not merge into my project as I wasn't happy with it. I still think
>> this change is not correct and needs to be removed or redone. I am not
>> 100% sure but presumably creating PSEUDO_VAL where the instruction
>> size is > 64-bits means that these PSEUDO_VAL values might be
>> considered 'same as' any other PSEUDO_VAL with value 0.
>>
>
> Forgot to add a simple example from my test pack:
>
> struct foo {
>     long long int i,j;
> };
>
> extern void dosomething(struct foo *foo);
>
> int main(void)
> {
>     struct foo bar = { 99 };
>     dosomething(&bar);
>     return 0;
> }
>
> Here you will see a PESUDO_VAL with value 0 being created with size 16 bytes.
>

In case you are wondering where this is happening - look at:

static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym)
{
struct access_data ad = { NULL, };
pseudo_t value;

if (!sym || !sym->initializer || sym->initialized)
return VOID;

/* We need to output these puppies some day too.. */
if (sym->ctype.modifiers & (MOD_STATIC | MOD_TOPLEVEL))
return VOID;

sym->initialized = 1;
ad.address = symbol_pseudo(ep, sym);

if (sym->initializer && !is_scalar_type(sym)) {
// default zero initialization [6.7.9.21]
// FIXME: this init the whole aggregate while
// only the existing fields need to be initialized.
// FIXME: this init the whole aggregate even if
// all fields arelater  explicitely initialized.
struct expression *expr = sym->initializer;
ad.pos = expr->pos;
ad.result_type = sym;
ad.source_type = base_type(sym);
ad.address = symbol_pseudo(ep, sym);
linearize_store_gen(ep, value_pseudo(sym, 0), &ad);
}

value = linearize_initializer(ep, sym->initializer, &ad);
finish_address_gen(ep, &ad);
return value;
}
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Mon, 05 Mar 2018 21:21:40 +0000
Message-ID: <CACXZuxc2AWzaymAEMAYrZua9=ECuqKyvbfifhFJ2GUEBPyMrXQ () mail ! gmail ! com>
--------------------
Hi,

Almost a year ago I had reported a problem with Sparse simplification phase.

https://marc.info/?l=linux-sparse&m=148953605610758&w=2

Given below is a test program.

With the release Sparse 0.5.1 release, the output from test-linearizer is:

cbrtl:
ep 0x7f5a27050010: cbrtl

.L0:
bug1.c:1
        <entry-point>
        set.64      %r4 <- 0.000000
        ret.64      %r4

Now I had a hunch that the bug may be resolved when PSEUDO_VALs have a
size. So I tried the same program with Chris' git repo version.

The output is:

cbrtl:
.L0x7f4c4c3b0010:
        <entry-point>
        set.64      %r1 <- 1.000000
        set.64      %r4 <- 0.000000
        ret.64      %r4

Hurray!

I think some of the bugs in Sparse simplification phase is because all
PSEUDO_VALs with same value are considered equal - irrespective of
size!

Here is the test:

double cbrtl (double x)
{
    int hx;
    double r,s,w;
    double lt;
    unsigned sign;
    union {
 double t;
 unsigned pt[2];
    } ut, ux;
    int n0;
    ut.t = 1.0;
    n0 = (ut.pt[0] == 0);
    ut.t = 0.0;
    ux.t = x;
    return ut.t;
}

Regards
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Mon, 05 Mar 2018 21:32:49 +0000
Message-ID: <CACXZuxfYMa6724fk5wL2Z=3+DQP=tjKcUJoLpRtEkEgKG8vP7A () mail ! gmail ! com>
--------------------
On 5 March 2018 at 21:21, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
> Hi,
>
> Almost a year ago I had reported a problem with Sparse simplification phase.
>
> https://marc.info/?l=linux-sparse&m=148953605610758&w=2
>
> Given below is a test program.
>
> With the release Sparse 0.5.1 release, the output from test-linearizer is:
>
> cbrtl:
> ep 0x7f5a27050010: cbrtl
>
> .L0:
> bug1.c:1
>         <entry-point>
>         set.64      %r4 <- 0.000000
>         ret.64      %r4
>
> Now I had a hunch that the bug may be resolved when PSEUDO_VALs have a
> size. So I tried the same program with Chris' git repo version.
>
> The output is:
>
> cbrtl:
> .L0x7f4c4c3b0010:
>         <entry-point>
>         set.64      %r1 <- 1.000000
>         set.64      %r4 <- 0.000000
>         ret.64      %r4
>
> Hurray!
>
> I think some of the bugs in Sparse simplification phase is because all
> PSEUDO_VALs with same value are considered equal - irrespective of
> size!
>
> Here is the test:
>
> double cbrtl (double x)
> {
>     int hx;
>     double r,s,w;
>     double lt;
>     unsigned sign;
>     union {
>  double t;
>  unsigned pt[2];
>     } ut, ux;
>     int n0;
>     ut.t = 1.0;
>     n0 = (ut.pt[0] == 0);
>     ut.t = 0.0;
>     ux.t = x;
>     return ut.t;
> }
>

Apologies looks like my example above is wrong (i.e. does not reflect
the original issue) ... please ignore.

Regards
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH 1/2] V2 Give the constant pseudo value a size
Date: Mon, 05 Mar 2018 21:56:51 +0000
Message-ID: <CACXZuxdHAB=OT2xTAKiaheVT51MJFV1U4605y5JUzJoMZBMP1Q () mail ! gmail ! com>
--------------------
On 5 March 2018 at 21:32, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
> On 5 March 2018 at 21:21, Dibyendu Majumdar <mobile@majumdar.org.uk> wrote:
>> Hi,
>>
>> Almost a year ago I had reported a problem with Sparse simplification phase.
>>
>> https://marc.info/?l=linux-sparse&m=148953605610758&w=2
>>
>> Given below is a test program.
>>
>> With the release Sparse 0.5.1 release, the output from test-linearizer is:
>>
>> cbrtl:
>> ep 0x7f5a27050010: cbrtl
>>
>> .L0:
>> bug1.c:1
>>         <entry-point>
>>         set.64      %r4 <- 0.000000
>>         ret.64      %r4
>>
>> Now I had a hunch that the bug may be resolved when PSEUDO_VALs have a
>> size. So I tried the same program with Chris' git repo version.
>>
>> The output is:
>>
>> cbrtl:
>> .L0x7f4c4c3b0010:
>>         <entry-point>
>>         set.64      %r1 <- 1.000000
>>         set.64      %r4 <- 0.000000
>>         ret.64      %r4
>>
>> Hurray!
>>
>> I think some of the bugs in Sparse simplification phase is because all
>> PSEUDO_VALs with same value are considered equal - irrespective of
>> size!
>>
>> Here is the test:
>>
>> double cbrtl (double x)
>> {
>>     int hx;
>>     double r,s,w;
>>     double lt;
>>     unsigned sign;
>>     union {
>>  double t;
>>  unsigned pt[2];
>>     } ut, ux;
>>     int n0;
>>     ut.t = 1.0;
>>     n0 = (ut.pt[0] == 0);
>>     ut.t = 0.0;
>>     ux.t = x;
>>     return ut.t;
>> }
>>
>
> Apologies looks like my example above is wrong (i.e. does not reflect
> the original issue) ... please ignore.
>

The actual test is:
https://github.com/dibyendumajumdar/sparse-testing/blob/master/eic/testcbrt.c.
I messed it up by trying to shorten it.

Here is the first few lines of output from Sparse 0.5.1:

cbrtl:
.L0:
        <entry-point>
        load.32     %r2 <- 0[ut]
        seteq.32    %r3 <- %r2, $0
        set.64      %r4 <- 0.000000
        store.64    %r4 -> 0[ut]
        store.64    %arg1 -> 0[ux]

And here is the output from Chris version:

cbrtl:
.L0x7f29db910010:
        <entry-point>
        set.64      %r1 <- 1.000000
        load.32     %r2 <- 0[ut]
        seteq.32    %r3 <- %r2, $0
        set.64      %r4 <- 0.000000
        store.64    %r4 -> 0[ut]
        store.64    %arg1 -> 0[ux]

And here is the output from dmr_C:

cbrtl:
.L0:
        <entry-point>
        set.f64     %r1 <- 1.000000
        store.f64   %r1 -> 0[ut]
        load.32     %r2 <- 0[ut]
        seteq.32    %r3 <- %r2, $0
        set.f64     %r4 <- 0.000000
        store.f64   %r4 -> 0[ut]
        store.f64   %arg1 -> 0[ux]


So the problem still seems to be there I think :-(

Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] add test case for bogus volatile simplification ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] add test case for bogus volatile simplification
Date: Sat, 11 Nov 2017 16:24:59 +0000
Message-ID: <20171111162500.69476-2-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/memops-volatile.c | 16 ++++++----------
 1 file changed, 6 insertions(+), 10 deletions(-)

diff --git a/validation/memops-volatile.c b/validation/memops-volatile.c
index 0f3e12ad2..71299f49d 100644
--- a/validation/memops-volatile.c
+++ b/validation/memops-volatile.c
@@ -1,6 +1,7 @@
 static int foo(volatile int *a, int v)
 {
 	*a = v;
+	*a = 0;
 	return *a;
 }
 
@@ -8,14 +9,9 @@ static int foo(volatile int *a, int v)
  * check-name: memops-volatile
  * check-command: test-linearize $file
  *
- * check-output-start
-foo:
-.L0:
-	<entry-point>
-	store.32    %arg2 -> 0[%arg1]
-	load.32     %r5 <- 0[%arg1]
-	ret.32      %r5
-
-
- * check-output-end
+ * check-known-to-fail
+ * check-output-ignore
+ * check-output-contains: store\\..*%arg2 -> 0\\[%arg1]
+ * check-output-contains: store\\..*\\$0 -> 0\\[%arg1]
+ * check-output-contains: load\\..*%r.* <- 0\\[%arg1]
  */
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] add test case unexamined base type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] add test case unexamined base type
Date: Sat, 25 Nov 2017 09:31:14 +0000
Message-ID: <20171125093115.95791-2-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/bugs/unexamined-base-type-00.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 validation/bugs/unexamined-base-type-00.c

diff --git a/validation/bugs/unexamined-base-type-00.c b/validation/bugs/unexamined-base-type-00.c
new file mode 100644
index 000000000..2032599b7
--- /dev/null
+++ b/validation/bugs/unexamined-base-type-00.c
@@ -0,0 +1,29 @@
+# define __force	__attribute__((force))
+
+
+struct s {
+	int a;
+};
+
+static int foo(struct s *s)
+{
+	return (*((typeof(s->a) __force *) &s->a)) & 1;
+}
+
+
+/*
+ * check-name: unexamined base type 00
+ * check-command: test-linearize -Wno-decl $file
+ * check-description:
+ *	The wrong generated is:
+ *		ptrcast.64  %r3 <- (64) %arg1
+ *		load        %r4 <- 0[%r3]	; !! WRONG
+ *		cast.32     %r5 <- (0) %r4	; !! WRONG
+ *		and.32      %r6 <- %r5, $1
+ *		ret.32      %r6
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-excludes: load[^.]
+ * check-output-excludes: cast\..*(0)
+ */
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] add testcase for CSE of floating-point compares ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] add testcase for CSE of floating-point compares
Date: Thu, 28 Dec 2017 22:17:34 +0000
Message-ID: <20171228221735.38902-2-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/optim/cse-fcmp.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)
 create mode 100644 validation/optim/cse-fcmp.c

diff --git a/validation/optim/cse-fcmp.c b/validation/optim/cse-fcmp.c
new file mode 100644
index 000000000..9e6872302
--- /dev/null
+++ b/validation/optim/cse-fcmp.c
@@ -0,0 +1,20 @@
+extern void fun(void);
+
+int foo(double a, double b)
+{
+	if (a < b)
+		fun();
+	if (a < b)
+		return 1;
+
+	return 0;
+}
+
+/*
+ * check-name: cse-fcmp
+ * check-command: test-linearize -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-pattern(1): fcmp
+ */
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] add testcases for unexamined base type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] add testcases for unexamined base type
Date: Thu, 21 Dec 2017 00:30:16 +0000
Message-ID: <20171221003017.57211-2-luc.vanoostenryck () gmail ! com>
--------------------
evaluate_dereference() lacks an explicit examination of the
base type. Most of the time, the base type has already been
examined via another path, but in some case, it's not.

The symptom here is the dereferenced value having a null size.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/linear/deref-ptr-ptr.c        | 27 +++++++++++++++++++++++
 validation/linear/unexamined-base-type.c | 37 ++++++++++++++++++++++++++++++++
 2 files changed, 64 insertions(+)
 create mode 100644 validation/linear/deref-ptr-ptr.c
 create mode 100644 validation/linear/unexamined-base-type.c

diff --git a/validation/linear/deref-ptr-ptr.c b/validation/linear/deref-ptr-ptr.c
new file mode 100644
index 000000000..022595d78
--- /dev/null
+++ b/validation/linear/deref-ptr-ptr.c
@@ -0,0 +1,27 @@
+char *foo(char **pfmt)
+{
+	return ++*pfmt;
+}
+
+/*
+ * check-name: deref-ptr-ptr
+ * check-command: test-linearize -m64 -Wno-decl $file
+ * check-known-to-fail
+ *
+ * check-output-excludes: load[^.]
+ * check-output-contains: load\.
+ * check-output-excludes: store[^.]
+ * check-output-contains: store\.
+ *
+ * check-output-start
+foo:
+.L0:
+	<entry-point>
+	load.64     %r2 <- 0[%arg1]
+	add.64      %r3 <- %r2, $1
+	store.64    %r3 -> 0[%arg1]
+	ret.64      %r3
+
+
+ * check-output-end
+ */
diff --git a/validation/linear/unexamined-base-type.c b/validation/linear/unexamined-base-type.c
new file mode 100644
index 000000000..a138ba132
--- /dev/null
+++ b/validation/linear/unexamined-base-type.c
@@ -0,0 +1,37 @@
+# define __force	__attribute__((force))
+
+struct s {
+	int a;
+};
+
+static int foo(struct s *s)
+{
+	return (*((typeof(s->a) __force *) &s->a)) & 1;
+}
+
+static void bar(struct s *d, struct s *s1, struct s *s2)
+{
+	*d = *s1, *d = *s2;
+}
+
+/*
+ * check-name: unexamined base type
+ * check-command: test-linearize -Wno-decl $file
+ * check-description:
+ *	Test case for missing examine in evaluate_dereference()'s
+ *	target base type. In this case, the loaded value has a
+ *	a null size, giving the wrongly generated code for foo():
+ *		ptrcast.64  %r3 <- (64) %arg1
+ *		load        %r4 <- 0[%r3]
+ *		    ^^^				!! WRONG !!
+ *		cast.32     %r5 <- (0) %r4
+ *		                   ^^^		!! WRONG !!
+ *		and.32      %r6 <- %r5, $1
+ *		ret.32      %r6
+ * check-known-to-fail
+ *
+ * check-output-ignore
+ * check-output-excludes: load[^.]
+ * check-output-excludes: cast\..*(0)
+ * check-output-excludes: store[^.]
+ */
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] cclass: char is wide enough ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] cclass: char is wide enough
Date: Tue, 19 Sep 2017 02:55:59 +0000
Message-ID: <20170919025600.11900-2-luc.vanoostenryck () gmail ! com>
--------------------
The table for character classes is declared as 'long cclass[]'
but there is no more reasons for such a wide type, 'int', or even
'char' is enough here.

Change this to use 'char' instead of 'long'.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 tokenize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tokenize.c b/tokenize.c
index 99b958035..7e68cf1ee 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -483,7 +483,7 @@ enum {
 	Quote = 64,
 };
 
-static const long cclass[257] = {
+static const char cclass[257] = {
 	['0' + 1 ... '7' + 1] = Digit | Hex,	/* \<octal> */
 	['8' + 1 ... '9' + 1] = Digit | Hex,
 	['A' + 1 ... 'D' + 1] = Letter | Hex,
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] let handle_switches() also handle reverse logic ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] let handle_switches() also handle reverse logic
Date: Fri, 29 Dec 2017 21:46:24 +0000
Message-ID: <20171229214625.41368-2-luc.vanoostenryck () gmail ! com>
--------------------
Some flags, for good or less good reasons, exist under two
different names: like a positive version and a negative one.
This is in addition of the 'no-' prefix.

The use case here is '-f[no-][un]signed-char'.

Make it easy and allow to specify that a given flag is the
negative version of another one so that '-fsigned-char' is
handled exactly as '-fno-unsigned-char'.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/lib.c b/lib.c
index e4bb639e5..b018eb972 100644
--- a/lib.c
+++ b/lib.c
@@ -578,6 +578,8 @@ static int handle_switches(const char *ori, const char *opt, const struct flag *
 
 		// boolean flag
 		if (opt[0] == '\0' && flags->flag) {
+			if (flags->mask & OPT_INVERSE)
+				val = !val;
 			*flags->flag = val;
 			return 1;
 		}
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] llvm: simplify emit of null pointers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] llvm: simplify emit of null pointers
Date: Thu, 28 Dec 2017 22:30:25 +0000
Message-ID: <20171228223026.39089-2-luc.vanoostenryck () gmail ! com>
--------------------
Most pointers with a constant value are simply null-pointers.
The only exception is when a known address is casted to pointer.

The current code only handle code for the general case:
emit code for a constant integer and then cast this to a pointer.
This obfuscate a bit the ouput, making it hard to read.

Change this by special handling the normal case of null-pointers
by directly using LLVM's LLVMConstPointerNull().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 sparse-llvm.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/sparse-llvm.c b/sparse-llvm.c
index a8186df5b..4c64f1aaa 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -340,14 +340,16 @@ static LLVMValueRef get_sym_value(struct function *fn, struct symbol *sym)
 
 static LLVMValueRef constant_value(unsigned long long val, LLVMTypeRef dtype)
 {
-	LLVMTypeRef itype;
 	LLVMValueRef result;
 
 	switch (LLVMGetTypeKind(dtype)) {
 	case LLVMPointerTypeKind:
-		itype = LLVMIntType(bits_in_pointer);
-		result = LLVMConstInt(itype, val, 1);
-		result = LLVMConstIntToPtr(result, dtype);
+		if (val != 0) {	 // for example: ... = (void*) 0x123;
+			LLVMTypeRef itype = LLVMIntType(bits_in_pointer);
+			result = LLVMConstInt(itype, val, 1);
+			result = LLVMConstIntToPtr(result, dtype);
+		}
+		result = LLVMConstPointerNull(dtype);
 		break;
 	case LLVMIntegerTypeKind:
 		result = LLVMConstInt(dtype, val, 1);
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] remove prototype extern int is_ptr_type() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] remove prototype extern int is_ptr_type()
Date: Tue, 19 Sep 2017 03:08:39 +0000
Message-ID: <20170919030840.12525-2-luc.vanoostenryck () gmail ! com>
--------------------
because the function was already defined as an inline function
in the same header file.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/symbol.h b/symbol.h
index 327449611..614763404 100644
--- a/symbol.h
+++ b/symbol.h
@@ -438,7 +438,6 @@ static inline struct symbol *lookup_keyword(struct ident *ident, enum namespace
 #define is_restricted_type(type) (get_sym_type(type) == SYM_RESTRICT)
 #define is_fouled_type(type) (get_sym_type(type) == SYM_FOULED)
 #define is_bitfield_type(type)   (get_sym_type(type) == SYM_BITFIELD)
-extern int is_ptr_type(struct symbol *);
 
 void create_fouled(struct symbol *type);
 struct symbol *befoul(struct symbol *type);
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] split OP_BR between unconditional & conditional: OP_CBR ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] split OP_BR between unconditional & conditional: OP_CBR
Date: Sat, 18 Feb 2017 01:28:47 +0000
Message-ID: <20170218012848.27417-2-luc.vanoostenryck () gmail ! com>
--------------------
OP_BR instructions exist in two flavours: conditional &
non-conditional. There is some significant differences
between them:
1) one has an operand (and thus needs correct handling of
   its usage, must be handled in liveness analysis, ..) while
   the other has none
2) one has two BB targets, the other only one.

There is essentially no places in the code where both flavours
are handled the same. Sometimes they both must be handled but
each with their specificities but in most cases only one of
them is concerned and we need to filter out the other one.
In both cases it means that we need to make to make a test
to know what kind we're dealing with.

There is a problem with this because there is several ways
to test this and they are not exactly equivalent:
1) testing if insn->cond is NULL
2) testing if one of insn->bb_true or ->bb_false is NULL.
There exist also an helper (is_branch_goto()) which does
the second tests but which is never used.

It appears that the first test should not be used because
in some cases an conditional OP_BR is changed into
a non-conditional one by (amongst others things) setting
it's ->cond to VOID. We should thus always use the second
test (which need two compares with NULL).

This could be corrected in several ways (like changing all
the places wheer the first test is used, use the helper
everywhere or never set ->cond to VOID) but the simplest
is to simply split them in two separated instructions:
OP_BR & OP_CBR, especailly given the fact that in most cases
the OP_BR was first selected by a switch (opcode).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 example.c                       |   2 +
 flow.c                          |  13 ++--
 linearize.c                     |  14 +++--
 linearize.h                     |   1 +
 liveness.c                      |   3 +-
 simplify.c                      |  11 ++--
 sparse-llvm.c                   |  25 ++++----
 validation/loop-linearization.c | 136 ++++++++++++++++++++++++++++++++++++++++
 8 files changed, 176 insertions(+), 29 deletions(-)
 create mode 100644 validation/loop-linearization.c

diff --git a/example.c b/example.c
index 24444c6c0..691e0f97c 100644
--- a/example.c
+++ b/example.c
@@ -23,6 +23,7 @@ static const char *opcodes[] = {
 	/* Terminator */
 	[OP_RET] = "ret",
 	[OP_BR] = "br",
+	[OP_CBR] = "cbr",
 	[OP_SWITCH] = "switch",
 	[OP_INVOKE] = "invoke",
 	[OP_COMPUTEDGOTO] = "jmp *",
@@ -1428,6 +1429,7 @@ static void generate_one_insn(struct instruction *insn, struct bb_state *state)
 		break;
 
 	case OP_BR:
+	case OP_CBR:
 		generate_branch(state, insn);
 		break;
 
diff --git a/flow.c b/flow.c
index 088c21785..7730e70f1 100644
--- a/flow.c
+++ b/flow.c
@@ -111,7 +111,7 @@ static int try_to_simplify_bb(struct basic_block *bb, struct instruction *first,
 		br = last_instruction(source->insns);
 		if (!br)
 			continue;
-		if (br->opcode != OP_BR)
+		if (br->opcode != OP_CBR && br->opcode != OP_BR)
 			continue;
 		true = pseudo_truth_value(pseudo);
 		if (true < 0)
@@ -176,7 +176,7 @@ static int simplify_branch_branch(struct basic_block *bb, struct instruction *br
 	if (target == bb)
 		return 0;
 	insn = last_instruction(target->insns);
-	if (!insn || insn->opcode != OP_BR || insn->cond != br->cond)
+	if (!insn || insn->opcode != OP_CBR  || insn->cond != br->cond)
 		return 0;
 	/*
 	 * Ahhah! We've found a branch to a branch on the same conditional!
@@ -218,7 +218,7 @@ static int simplify_branch_nodes(struct entrypoint *ep)
 	FOR_EACH_PTR(ep->bbs, bb) {
 		struct instruction *br = last_instruction(bb->insns);
 
-		if (!br || br->opcode != OP_BR || !br->bb_false)
+		if (!br || br->opcode != OP_CBR)
 			continue;
 		changed |= simplify_one_branch(bb, br);
 	} END_FOR_EACH_PTR(bb);
@@ -811,9 +811,10 @@ static int rewrite_parent_branch(struct basic_block *bb, struct basic_block *old
 		return 0;
 
 	switch (insn->opcode) {
+	case OP_CBR:
+		changed |= rewrite_branch(bb, &insn->bb_false, old, new);
 	case OP_BR:
 		changed |= rewrite_branch(bb, &insn->bb_true, old, new);
-		changed |= rewrite_branch(bb, &insn->bb_false, old, new);
 		assert(changed);
 		return changed;
 	case OP_SWITCH: {
@@ -886,9 +887,10 @@ static void vrfy_children(struct basic_block *bb)
 	}
 	switch (br->opcode) {
 		struct multijmp *jmp;
+	case OP_CBR:
+		vrfy_bb_in_list(br->bb_false, bb->children);
 	case OP_BR:
 		vrfy_bb_in_list(br->bb_true, bb->children);
-		vrfy_bb_in_list(br->bb_false, bb->children);
 		break;
 	case OP_SWITCH:
 	case OP_COMPUTEDGOTO:
@@ -945,6 +947,7 @@ void pack_basic_blocks(struct entrypoint *ep)
 			switch (first->opcode) {
 			case OP_NOP: case OP_LNOP: case OP_SNOP:
 				continue;
+			case OP_CBR:
 			case OP_BR: {
 				struct basic_block *replace;
 				replace = rewrite_branch_bb(bb, first);
diff --git a/linearize.c b/linearize.c
index 99203d915..3b4741822 100644
--- a/linearize.c
+++ b/linearize.c
@@ -169,6 +169,7 @@ static const char *opcodes[] = {
 	/* Terminator */
 	[OP_RET] = "ret",
 	[OP_BR] = "br",
+	[OP_CBR] = "cbr",
 	[OP_SWITCH] = "switch",
 	[OP_INVOKE] = "invoke",
 	[OP_COMPUTEDGOTO] = "jmp *",
@@ -303,12 +304,13 @@ const char *show_instruction(struct instruction *insn)
 		if (insn->src && insn->src != VOID)
 			buf += sprintf(buf, "%s", show_pseudo(insn->src));
 		break;
+
+	case OP_CBR:
+		buf += sprintf(buf, "%s, .L%u, .L%u", show_pseudo(insn->cond), insn->bb_true->nr, insn->bb_false->nr);
+		break;
+
 	case OP_BR:
-		if (insn->bb_true && insn->bb_false) {
-			buf += sprintf(buf, "%s, .L%u, .L%u", show_pseudo(insn->cond), insn->bb_true->nr, insn->bb_false->nr);
-			break;
-		}
-		buf += sprintf(buf, ".L%u", insn->bb_true ? insn->bb_true->nr : insn->bb_false->nr);
+		buf += sprintf(buf, ".L%u", insn->bb_true->nr);
 		break;
 
 	case OP_SYMADDR: {
@@ -723,7 +725,7 @@ static void add_branch(struct entrypoint *ep, struct expression *expr, pseudo_t
 	struct instruction *br;
 
 	if (bb_reachable(bb)) {
-       		br = alloc_instruction(OP_BR, 0);
+		br = alloc_instruction(OP_CBR, 0);
 		use_pseudo(br, cond, &br->cond);
 		br->bb_true = bb_true;
 		br->bb_false = bb_false;
diff --git a/linearize.h b/linearize.h
index 5c938cd5d..2aa255154 100644
--- a/linearize.h
+++ b/linearize.h
@@ -137,6 +137,7 @@ enum opcode {
 	OP_TERMINATOR,
 	OP_RET = OP_TERMINATOR,
 	OP_BR,
+	OP_CBR,
 	OP_SWITCH,
 	OP_INVOKE,
 	OP_COMPUTEDGOTO,
diff --git a/liveness.c b/liveness.c
index 2e5139433..7461738b4 100644
--- a/liveness.c
+++ b/liveness.c
@@ -56,7 +56,8 @@ static void track_instruction_usage(struct basic_block *bb, struct instruction *
 		USES(src);
 		break;
 
-	case OP_BR: case OP_SWITCH:
+	case OP_CBR:
+	case OP_SWITCH:
 		USES(cond);
 		break;
 
diff --git a/simplify.c b/simplify.c
index 3bc9985e8..c157c6153 100644
--- a/simplify.c
+++ b/simplify.c
@@ -67,7 +67,7 @@ static int if_convert_phi(struct instruction *insn)
 	 * stuff. Verify that here.
 	 */
 	br = last_instruction(source->insns);
-	if (!br || br->opcode != OP_BR)
+	if (!br || br->opcode != OP_CBR)
 		return 0;
 
 	assert(br->cond);
@@ -227,11 +227,7 @@ void kill_insn(struct instruction *insn, int force)
 		repeat_phase |= REPEAT_SYMBOL_CLEANUP;
 		break;
 
-	case OP_BR:
-		if (!insn->bb_true || !insn->bb_false)
-			break;
-		/* fall through */
-
+	case OP_CBR:
 	case OP_COMPUTEDGOTO:
 		kill_use(&insn->cond);
 		break;
@@ -266,6 +262,7 @@ void kill_insn(struct instruction *insn, int force)
 		/* ignore */
 		return;
 
+	case OP_BR:
 	default:
 		break;
 	}
@@ -1052,6 +1049,7 @@ static int simplify_branch(struct instruction *insn)
 		insn->bb_false = NULL;
 		kill_use(&insn->cond);
 		insn->cond = NULL;
+		insn->opcode = OP_BR;
 		return REPEAT_CSE;
 	}
 
@@ -1181,6 +1179,7 @@ int simplify_instruction(struct instruction *insn)
 		break;
 	case OP_SEL:
 		return simplify_select(insn);
+	case OP_CBR:
 	case OP_BR:
 		return simplify_branch(insn);
 	case OP_SWITCH:
diff --git a/sparse-llvm.c b/sparse-llvm.c
index 3d2218ef6..9f362b3ed 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -642,19 +642,19 @@ static LLVMValueRef bool_value(struct function *fn, LLVMValueRef value)
 	return value;
 }
 
-static void output_op_br(struct function *fn, struct instruction *br)
+static void output_op_cbr(struct function *fn, struct instruction *br)
 {
-	if (br->cond) {
-		LLVMValueRef cond = bool_value(fn,
-				pseudo_to_value(fn, br, br->cond));
+	LLVMValueRef cond = bool_value(fn,
+			pseudo_to_value(fn, br, br->cond));
 
-		LLVMBuildCondBr(fn->builder, cond,
-				br->bb_true->priv,
-				br->bb_false->priv);
-	} else
-		LLVMBuildBr(fn->builder,
-			    br->bb_true ? br->bb_true->priv :
-			    br->bb_false->priv);
+	LLVMBuildCondBr(fn->builder, cond,
+			br->bb_true->priv,
+			br->bb_false->priv);
+}
+
+static void output_op_br(struct function *fn, struct instruction *br)
+{
+	LLVMBuildBr(fn->builder, br->bb_true->priv);
 }
 
 static void output_op_sel(struct function *fn, struct instruction *insn)
@@ -810,6 +810,9 @@ static void output_insn(struct function *fn, struct instruction *insn)
 	case OP_BR:
 		output_op_br(fn, insn);
 		break;
+	case OP_CBR:
+		output_op_cbr(fn, insn);
+		break;
 	case OP_SYMADDR:
 		assert(0);
 		break;
diff --git a/validation/loop-linearization.c b/validation/loop-linearization.c
new file mode 100644
index 000000000..25c6dfb87
--- /dev/null
+++ b/validation/loop-linearization.c
@@ -0,0 +1,136 @@
+extern int p(int);
+
+static int ffor(void)
+{
+	int i;
+	for (int i = 0; i < 10; i++) {
+		if (!p(i))
+			return 0;
+	}
+	return 1;
+}
+
+static int fwhile(void)
+{
+	int i = 0;
+	while (i < 10) {
+		if (!p(i))
+			return 0;
+		i++;
+	}
+	return 1;
+}
+
+static int fdo(void)
+{
+	int i = 0;
+	do {
+		if (!p(i))
+			return 0;
+	} while (i++ < 10);
+	return 1;
+}
+
+/*
+ * check-name: loop-linearization
+ * check-command: test-linearize $file
+ *
+ * check-output-start
+ffor:
+.L0:
+	<entry-point>
+	phisrc.32   %phi5(i) <- $0
+	br          .L4
+
+.L4:
+	phi.32      %r1(i) <- %phi5(i), %phi6(i)
+	setlt.32    %r2 <- %r1(i), $10
+	cbr         %r2, .L1, .L3
+
+.L1:
+	call.32     %r4 <- p, %r1(i)
+	cbr         %r4, .L2, .L5
+
+.L5:
+	phisrc.32   %phi1(return) <- $0
+	br          .L7
+
+.L2:
+	add.32      %r7 <- %r1(i), $1
+	phisrc.32   %phi6(i) <- %r7
+	br          .L4
+
+.L3:
+	phisrc.32   %phi2(return) <- $1
+	br          .L7
+
+.L7:
+	phi.32      %r5 <- %phi1(return), %phi2(return)
+	ret.32      %r5
+
+
+fwhile:
+.L8:
+	<entry-point>
+	phisrc.32   %phi11(i) <- $0
+	br          .L12
+
+.L12:
+	phi.32      %r8(i) <- %phi11(i), %phi12(i)
+	setlt.32    %r9 <- %r8(i), $10
+	cbr         %r9, .L9, .L11
+
+.L9:
+	call.32     %r11 <- p, %r8(i)
+	cbr         %r11, .L14, .L13
+
+.L13:
+	phisrc.32   %phi7(return) <- $0
+	br          .L15
+
+.L14:
+	add.32      %r14 <- %r8(i), $1
+	phisrc.32   %phi12(i) <- %r14
+	br          .L12
+
+.L11:
+	phisrc.32   %phi8(return) <- $1
+	br          .L15
+
+.L15:
+	phi.32      %r12 <- %phi7(return), %phi8(return)
+	ret.32      %r12
+
+
+fdo:
+.L16:
+	<entry-point>
+	phisrc.32   %phi16(i) <- $0
+	br          .L17
+
+.L17:
+	phi.32      %r15(i) <- %phi16(i), %phi17(i)
+	call.32     %r16 <- p, %r15(i)
+	cbr         %r16, .L18, .L20
+
+.L20:
+	phisrc.32   %phi13(return) <- $0
+	br          .L22
+
+.L18:
+	add.32      %r19 <- %r15(i), $1
+	setlt.32    %r20 <- %r15(i), $10
+	phisrc.32   %phi17(i) <- %r19
+	cbr         %r20, .L17, .L19
+
+.L19:
+	phisrc.32   %phi14(return) <- $1
+	br          .L22
+
+.L22:
+	phi.32      %r17 <- %phi13(return), %phi14(return)
+	ret.32      %r17
+
+
+ * check-output-end
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] split OP_BR between unconditional & conditional: OP_CBR
Date: Mon, 27 Feb 2017 15:02:23 +0000
Message-ID: <CANeU7Q=60E+2tvn=bdjaYnZFS3U3PMiTTq0=eYS-NkPDK3aJNA () mail ! gmail ! com>
--------------------
On Sat, Feb 18, 2017 at 9:28 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This could be corrected in several ways (like changing all
> the places wheer the first test is used, use the helper
> everywhere or never set ->cond to VOID) but the simplest
> is to simply split them in two separated instructions:
> OP_BR & OP_CBR, especailly given the fact that in most cases
> the OP_BR was first selected by a switch (opcode).

I think that change itself is fine. The implications is that all sparse
back end user will need to be updated to use CBR instead of BR.

Sparse can be compiled as a lib to link against. We might want to
have some API version for sprase to check which version of sparse
it is.  Currently there is SPARSE_VERSION but that is a macro
which does not reflect in the lib version of sparse. That is a separate
patch though.

> @@ -811,9 +811,10 @@ static int rewrite_parent_branch(struct basic_block *bb, struct basic_block *old
>                 return 0;
>
>         switch (insn->opcode) {
> +       case OP_CBR:
> +               changed |= rewrite_branch(bb, &insn->bb_false, old, new);

We can use some comment of fall though the case here.

>         case OP_BR:
>                 changed |= rewrite_branch(bb, &insn->bb_true, old, new);
> -               changed |= rewrite_branch(bb, &insn->bb_false, old, new);
>                 assert(changed);
>                 return changed;
>         case OP_SWITCH: {
> @@ -886,9 +887,10 @@ static void vrfy_children(struct basic_block *bb)
>         }
>         switch (br->opcode) {
>                 struct multijmp *jmp;
> +       case OP_CBR:
> +               vrfy_bb_in_list(br->bb_false, bb->children);

Same here.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] warn on empty parenthesized expressions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/2] warn on empty parenthesized expressions
Date: Thu, 28 Dec 2017 17:25:18 +0000
Message-ID: <20171228172519.16550-2-luc.vanoostenryck () gmail ! com>
--------------------
Empty sub-expressions are normally caught as syntax error
in most expressions but this is not the case for parenthesized
expressions.

Fix this by adding a check at the end of parens_expressions()
and warning if needed.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expression.c            |  6 ++++++
 validation/empty-expr.c | 27 +++++++++++++++++++++++++++
 2 files changed, 33 insertions(+)
 create mode 100644 validation/empty-expr.c

diff --git a/expression.c b/expression.c
index e5ebad65b..6f4300b9a 100644
--- a/expression.c
+++ b/expression.c
@@ -62,7 +62,10 @@ static struct token *comma_expression(struct token *, struct expression **);
 
 struct token *parens_expression(struct token *token, struct expression **expr, const char *where)
 {
+	struct token *p;
+
 	token = expect(token, '(', where);
+	p = token;
 	if (match_op(token, '{')) {
 		struct expression *e = alloc_expression(token->pos, EXPR_STATEMENT);
 		struct statement *stmt = alloc_statement(token->pos, STMT_COMPOUND);
@@ -74,6 +77,9 @@ struct token *parens_expression(struct token *token, struct expression **expr, c
 		token = expect(token, '}', "at end of statement expression");
 	} else
 		token = parse_expression(token, expr);
+
+	if (token == p)
+		sparse_error(token->pos, "an expression is expected before ')'");
 	return expect(token, ')', where);
 }
 
diff --git a/validation/empty-expr.c b/validation/empty-expr.c
new file mode 100644
index 000000000..506cfba7e
--- /dev/null
+++ b/validation/empty-expr.c
@@ -0,0 +1,27 @@
+static int foo(void)
+{
+	switch () {
+	case 0:
+		return 0;
+	default:
+		return 1;
+	}
+}
+
+static int bar(void)
+{
+	if ()
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * check-name: empty expression
+ * check-known-to-fail
+ *
+ * check-error-start
+empty-expr.c:3:17: error: an expression is expected before ')'
+empty-expr.c:13:13: error: an expression is expected before ')'
+ * check-error-end
+ */
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] fix conditional context test case with void ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/3] fix conditional context test case with void
Date: Sun, 29 Jan 2017 11:34:07 +0000
Message-ID: <20170129113409.9834-2-luc.vanoostenryck () gmail ! com>
--------------------
The test file for context checking contains a few test cases
with a conditional, mimicking kernels's __cond_lock().
But the macro involved use as condition the return value of
a function, _ca(), which itself returns void ...

Fix the test by giving _ca() a return type of 'int'.

CC: Josh Triplett <josh@joshtriplett.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/context.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/validation/context.c b/validation/context.c
index 33b70b84b..b9500dc75 100644
--- a/validation/context.c
+++ b/validation/context.c
@@ -10,7 +10,7 @@ static void r(void) __attribute__((context(1,0)))
 	__context__(-1);
 }
 
-extern void _ca(int fail);
+extern int _ca(int fail);
 #define ca(fail) __cond_lock(_ca(fail))
 
 static void good_paired1(void)
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] fix test case kill-phi-ttsb ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/3] fix test case kill-phi-ttsb
Date: Mon, 18 Sep 2017 14:10:55 +0000
Message-ID: <20170918141057.69745-2-luc.vanoostenryck () gmail ! com>
--------------------
The function used in te test case has a return type of 'int'
but has nothing to return.

Fix this by using the correct return type: 'void'

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/kill-phi-ttsbb.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/validation/kill-phi-ttsbb.c b/validation/kill-phi-ttsbb.c
index 178a65d19..7fea30bfd 100644
--- a/validation/kill-phi-ttsbb.c
+++ b/validation/kill-phi-ttsbb.c
@@ -1,7 +1,7 @@
 int def(void);
 void use(int);
 
-static int foo(int a, int b)
+static void foo(int a, int b)
 {
 	int c;
 
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] move evaluation & expansion of builtins in a separate file ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/3] move evaluation & expansion of builtins in a separate file
Date: Mon, 23 Jan 2017 21:37:26 +0000
Message-ID: <20170123213728.89900-2-luc.vanoostenryck () gmail ! com>
--------------------
No functional changes, just move some code around, and rename
'eval_init_table[]' to 'builtins_table[]'.
---
 Makefile  |   1 +
 builtin.c | 210 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 expand.c  |  24 +------
 expand.h  |  34 ++++++++++
 symbol.c  | 160 +----------------------------------------------
 symbol.h  |   3 +-
 6 files changed, 248 insertions(+), 184 deletions(-)
 create mode 100644 builtin.c
 create mode 100644 expand.h

diff --git a/Makefile b/Makefile
index f59993f7c..76902b75e 100644
--- a/Makefile
+++ b/Makefile
@@ -105,6 +105,7 @@ LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  char.o sort.o allocate.o compat-$(OS).o ptrlist.o \
+	  builtin.o \
 	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o
 
 LIB_FILE= libsparse.a
diff --git a/builtin.c b/builtin.c
new file mode 100644
index 000000000..c6c97ed85
--- /dev/null
+++ b/builtin.c
@@ -0,0 +1,210 @@
+/*
+ * builtin evaluation & expansion.
+ *
+ * Copyright (C) 2003 Transmeta Corp.
+ *               2003-2004 Linus Torvalds
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "expression.h"
+#include "expand.h"
+#include "symbol.h"
+
+static int evaluate_to_integer(struct expression *expr)
+{
+	expr->ctype = &int_ctype;
+	return 1;
+}
+
+static int evaluate_expect(struct expression *expr)
+{
+	/* Should we evaluate it to return the type of the first argument? */
+	expr->ctype = &int_ctype;
+	return 1;
+}
+
+static int arguments_choose(struct expression *expr)
+{
+	struct expression_list *arglist = expr->args;
+	struct expression *arg;
+	int i = 0;
+
+	FOR_EACH_PTR (arglist, arg) {
+		if (!evaluate_expression(arg))
+			return 0;
+		i++;
+	} END_FOR_EACH_PTR(arg);
+	if (i < 3) {
+		sparse_error(expr->pos,
+			     "not enough arguments for __builtin_choose_expr");
+		return 0;
+	} if (i > 3) {
+		sparse_error(expr->pos,
+			     "too many arguments for __builtin_choose_expr");
+		return 0;
+	}
+	return 1;
+}
+
+static int evaluate_choose(struct expression *expr)
+{
+	struct expression_list *list = expr->args;
+	struct expression *arg, *args[3];
+	int n = 0;
+
+	/* there will be exactly 3; we'd already verified that */
+	FOR_EACH_PTR(list, arg) {
+		args[n++] = arg;
+	} END_FOR_EACH_PTR(arg);
+
+	*expr = get_expression_value(args[0]) ? *args[1] : *args[2];
+
+	return 1;
+}
+
+static int expand_expect(struct expression *expr, int cost)
+{
+	struct expression *arg = first_ptr_list((struct ptr_list *) expr->args);
+
+	if (arg)
+		*expr = *arg;
+	return 0;
+}
+
+/*
+ * __builtin_warning() has type "int" and always returns 1,
+ * so that you can use it in conditionals or whatever
+ */
+static int expand_warning(struct expression *expr, int cost)
+{
+	struct expression *arg;
+	struct expression_list *arglist = expr->args;
+
+	FOR_EACH_PTR (arglist, arg) {
+		/*
+		 * Constant strings get printed out as a warning. By the
+		 * time we get here, the EXPR_STRING has been fully 
+		 * evaluated, so by now it's an anonymous symbol with a
+		 * string initializer.
+		 *
+		 * Just for the heck of it, allow any constant string
+		 * symbol.
+		 */
+		if (arg->type == EXPR_SYMBOL) {
+			struct symbol *sym = arg->symbol;
+			if (sym->initializer && sym->initializer->type == EXPR_STRING) {
+				struct string *string = sym->initializer->string;
+				warning(expr->pos, "%*s", string->length-1, string->data);
+			}
+			continue;
+		}
+
+		/*
+		 * Any other argument is a conditional. If it's
+		 * non-constant, or it is false, we exit and do
+		 * not print any warning.
+		 */
+		if (arg->type != EXPR_VALUE)
+			goto out;
+		if (!arg->value)
+			goto out;
+	} END_FOR_EACH_PTR(arg);
+out:
+	expr->type = EXPR_VALUE;
+	expr->value = 1;
+	expr->taint = 0;
+	return 0;
+}
+
+/* The arguments are constant if the cost of all of them is zero */
+static int expand_constant_p(struct expression *expr, int cost)
+{
+	expr->type = EXPR_VALUE;
+	expr->value = !cost;
+	expr->taint = 0;
+	return 0;
+}
+
+/* The arguments are safe, if their cost is less than SIDE_EFFECTS */
+static int expand_safe_p(struct expression *expr, int cost)
+{
+	expr->type = EXPR_VALUE;
+	expr->value = (cost < SIDE_EFFECTS);
+	expr->taint = 0;
+	return 0;
+}
+
+static struct symbol_op constant_p_op = {
+	.evaluate = evaluate_to_integer,
+	.expand = expand_constant_p
+};
+
+static struct symbol_op safe_p_op = {
+	.evaluate = evaluate_to_integer,
+	.expand = expand_safe_p
+};
+
+static struct symbol_op warning_op = {
+	.evaluate = evaluate_to_integer,
+	.expand = expand_warning
+};
+
+static struct symbol_op expect_op = {
+	.evaluate = evaluate_expect,
+	.expand = expand_expect
+};
+
+static struct symbol_op choose_op = {
+	.evaluate = evaluate_choose,
+	.args = arguments_choose,
+};
+
+
+/*
+ * Builtin functions
+ */
+static struct symbol builtin_fn_type = { .type = SYM_FN /* , .variadic =1 */ };
+static struct sym_init {
+	const char *name;
+	struct symbol *base_type;
+	unsigned int modifiers;
+	struct symbol_op *op;
+} builtins_table[] = {
+	{ "__builtin_constant_p", &builtin_fn_type, MOD_TOPLEVEL, &constant_p_op },
+	{ "__builtin_safe_p", &builtin_fn_type, MOD_TOPLEVEL, &safe_p_op },
+	{ "__builtin_warning", &builtin_fn_type, MOD_TOPLEVEL, &warning_op },
+	{ "__builtin_expect", &builtin_fn_type, MOD_TOPLEVEL, &expect_op },
+	{ "__builtin_choose_expr", &builtin_fn_type, MOD_TOPLEVEL, &choose_op },
+	{ NULL,		NULL,		0 }
+};
+
+void init_builtins(int stream)
+{
+	struct sym_init *ptr;
+
+	builtin_fn_type.variadic = 1;
+	for (ptr = builtins_table; ptr->name; ptr++) {
+		struct symbol *sym;
+		sym = create_symbol(stream, ptr->name, SYM_NODE, NS_SYMBOL);
+		sym->ctype.base_type = ptr->base_type;
+		sym->ctype.modifiers = ptr->modifiers;
+		sym->op = ptr->op;
+	}
+}
diff --git a/expand.c b/expand.c
index 0f6720c44..7af12707e 100644
--- a/expand.c
+++ b/expand.c
@@ -41,12 +41,8 @@
 #include "symbol.h"
 #include "target.h"
 #include "expression.h"
+#include "expand.h"
 
-/* Random cost numbers */
-#define SIDE_EFFECTS 10000	/* The expression has side effects */
-#define UNSAFE 100		/* The expression may be "infinitely costly" due to exceptions */
-#define SELECT_COST 20		/* Cut-off for turning a conditional into a select */
-#define BRANCH_COST 10		/* Cost of a conditional branch */
 
 static int expand_expression(struct expression *);
 static int expand_statement(struct statement *);
@@ -784,24 +780,6 @@ static int expand_cast(struct expression *expr)
 	return cost + 1;
 }
 
-/* The arguments are constant if the cost of all of them is zero */
-int expand_constant_p(struct expression *expr, int cost)
-{
-	expr->type = EXPR_VALUE;
-	expr->value = !cost;
-	expr->taint = 0;
-	return 0;
-}
-
-/* The arguments are safe, if their cost is less than SIDE_EFFECTS */
-int expand_safe_p(struct expression *expr, int cost)
-{
-	expr->type = EXPR_VALUE;
-	expr->value = (cost < SIDE_EFFECTS);
-	expr->taint = 0;
-	return 0;
-}
-
 /*
  * expand a call expression with a symbol. This
  * should expand builtins.
diff --git a/expand.h b/expand.h
new file mode 100644
index 000000000..27e10c0a8
--- /dev/null
+++ b/expand.h
@@ -0,0 +1,34 @@
+#ifndef EXPAND_H
+#define EXPAND_H
+/*
+ * sparse/expand.h
+ *
+ * Copyright (C) 2003 Transmeta Corp.
+ *               2003 Linus Torvalds
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* Random cost numbers */
+#define SIDE_EFFECTS 10000	/* The expression has side effects */
+#define UNSAFE 100		/* The expression may be "infinitely costly" due to exceptions */
+#define SELECT_COST 20		/* Cut-off for turning a conditional into a select */
+#define BRANCH_COST 10		/* Cost of a conditional branch */
+
+#endif
diff --git a/symbol.c b/symbol.c
index 92a7a6253..5b6cb7fde 100644
--- a/symbol.c
+++ b/symbol.c
@@ -642,155 +642,6 @@ struct symbol *create_symbol(int stream, const char *name, int type, int namespa
 	return sym;
 }
 
-static int evaluate_to_integer(struct expression *expr)
-{
-	expr->ctype = &int_ctype;
-	return 1;
-}
-
-static int evaluate_expect(struct expression *expr)
-{
-	/* Should we evaluate it to return the type of the first argument? */
-	expr->ctype = &int_ctype;
-	return 1;
-}
-
-static int arguments_choose(struct expression *expr)
-{
-	struct expression_list *arglist = expr->args;
-	struct expression *arg;
-	int i = 0;
-
-	FOR_EACH_PTR (arglist, arg) {
-		if (!evaluate_expression(arg))
-			return 0;
-		i++;
-	} END_FOR_EACH_PTR(arg);
-	if (i < 3) {
-		sparse_error(expr->pos,
-			     "not enough arguments for __builtin_choose_expr");
-		return 0;
-	} if (i > 3) {
-		sparse_error(expr->pos,
-			     "too many arguments for __builtin_choose_expr");
-		return 0;
-	}
-	return 1;
-}
-
-static int evaluate_choose(struct expression *expr)
-{
-	struct expression_list *list = expr->args;
-	struct expression *arg, *args[3];
-	int n = 0;
-
-	/* there will be exactly 3; we'd already verified that */
-	FOR_EACH_PTR(list, arg) {
-		args[n++] = arg;
-	} END_FOR_EACH_PTR(arg);
-
-	*expr = get_expression_value(args[0]) ? *args[1] : *args[2];
-
-	return 1;
-}
-
-static int expand_expect(struct expression *expr, int cost)
-{
-	struct expression *arg = first_ptr_list((struct ptr_list *) expr->args);
-
-	if (arg)
-		*expr = *arg;
-	return 0;
-}
-
-/*
- * __builtin_warning() has type "int" and always returns 1,
- * so that you can use it in conditionals or whatever
- */
-static int expand_warning(struct expression *expr, int cost)
-{
-	struct expression *arg;
-	struct expression_list *arglist = expr->args;
-
-	FOR_EACH_PTR (arglist, arg) {
-		/*
-		 * Constant strings get printed out as a warning. By the
-		 * time we get here, the EXPR_STRING has been fully 
-		 * evaluated, so by now it's an anonymous symbol with a
-		 * string initializer.
-		 *
-		 * Just for the heck of it, allow any constant string
-		 * symbol.
-		 */
-		if (arg->type == EXPR_SYMBOL) {
-			struct symbol *sym = arg->symbol;
-			if (sym->initializer && sym->initializer->type == EXPR_STRING) {
-				struct string *string = sym->initializer->string;
-				warning(expr->pos, "%*s", string->length-1, string->data);
-			}
-			continue;
-		}
-
-		/*
-		 * Any other argument is a conditional. If it's
-		 * non-constant, or it is false, we exit and do
-		 * not print any warning.
-		 */
-		if (arg->type != EXPR_VALUE)
-			goto out;
-		if (!arg->value)
-			goto out;
-	} END_FOR_EACH_PTR(arg);
-out:
-	expr->type = EXPR_VALUE;
-	expr->value = 1;
-	expr->taint = 0;
-	return 0;
-}
-
-static struct symbol_op constant_p_op = {
-	.evaluate = evaluate_to_integer,
-	.expand = expand_constant_p
-};
-
-static struct symbol_op safe_p_op = {
-	.evaluate = evaluate_to_integer,
-	.expand = expand_safe_p
-};
-
-static struct symbol_op warning_op = {
-	.evaluate = evaluate_to_integer,
-	.expand = expand_warning
-};
-
-static struct symbol_op expect_op = {
-	.evaluate = evaluate_expect,
-	.expand = expand_expect
-};
-
-static struct symbol_op choose_op = {
-	.evaluate = evaluate_choose,
-	.args = arguments_choose,
-};
-
-/*
- * Builtin functions
- */
-static struct symbol builtin_fn_type = { .type = SYM_FN /* , .variadic =1 */ };
-static struct sym_init {
-	const char *name;
-	struct symbol *base_type;
-	unsigned int modifiers;
-	struct symbol_op *op;
-} eval_init_table[] = {
-	{ "__builtin_constant_p", &builtin_fn_type, MOD_TOPLEVEL, &constant_p_op },
-	{ "__builtin_safe_p", &builtin_fn_type, MOD_TOPLEVEL, &safe_p_op },
-	{ "__builtin_warning", &builtin_fn_type, MOD_TOPLEVEL, &warning_op },
-	{ "__builtin_expect", &builtin_fn_type, MOD_TOPLEVEL, &expect_op },
-	{ "__builtin_choose_expr", &builtin_fn_type, MOD_TOPLEVEL, &choose_op },
-	{ NULL,		NULL,		0 }
-};
-
 
 /*
  * Abstract types
@@ -825,22 +676,13 @@ struct symbol	zero_int;
 void init_symbols(void)
 {
 	int stream = init_stream("builtin", -1, includepath);
-	struct sym_init *ptr;
 
 #define __IDENT(n,str,res) \
 	hash_ident(&n)
 #include "ident-list.h"
 
 	init_parser(stream);
-
-	builtin_fn_type.variadic = 1;
-	for (ptr = eval_init_table; ptr->name; ptr++) {
-		struct symbol *sym;
-		sym = create_symbol(stream, ptr->name, SYM_NODE, NS_SYMBOL);
-		sym->ctype.base_type = ptr->base_type;
-		sym->ctype.modifiers = ptr->modifiers;
-		sym->op = ptr->op;
-	}
+	init_builtins(stream);
 }
 
 #define MOD_ESIGNED (MOD_SIGNED | MOD_EXPLICITLY_SIGNED)
diff --git a/symbol.h b/symbol.h
index 9b3f1604e..f18306094 100644
--- a/symbol.h
+++ b/symbol.h
@@ -128,8 +128,6 @@ struct symbol_op {
 	int test, set, class;
 };
 
-extern int expand_safe_p(struct expression *expr, int cost);
-extern int expand_constant_p(struct expression *expr, int cost);
 
 #define SYM_ATTR_WEAK		0
 #define SYM_ATTR_NORMAL		1
@@ -289,6 +287,7 @@ extern const char * type_difference(struct ctype *c1, struct ctype *c2,
 extern struct symbol *lookup_symbol(struct ident *, enum namespace);
 extern struct symbol *create_symbol(int stream, const char *name, int type, int namespace);
 extern void init_symbols(void);
+extern void init_builtins(int stream);
 extern void init_ctype(void);
 extern struct symbol *alloc_symbol(struct position, int type);
 extern void show_type(struct symbol *);
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/3] simplify 'x | ~0' and 'x & ~0' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/3] simplify 'x | ~0' and 'x & ~0'
Date: Wed, 12 Apr 2017 14:18:00 +0000
Message-ID: <20170412141802.81231-2-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                       | 11 ++++++++++-
 validation/optim/bool-not-zero.c | 22 ++++++++++++++++++++++
 2 files changed, 32 insertions(+), 1 deletion(-)
 create mode 100644 validation/optim/bool-not-zero.c

diff --git a/simplify.c b/simplify.c
index 2286440e0..e4ccb6c5f 100644
--- a/simplify.c
+++ b/simplify.c
@@ -453,6 +453,8 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)
 static int simplify_constant_rightside(struct instruction *insn)
 {
 	long long value = insn->src2->value;
+	long long sbit = 1ULL << (insn->size - 1);
+	long long bits = sbit | (sbit - 1);
 
 	switch (insn->opcode) {
 	case OP_OR_BOOL:
@@ -460,6 +462,11 @@ static int simplify_constant_rightside(struct instruction *insn)
 			return replace_with_pseudo(insn, insn->src2);
 		goto case_neutral_zero;
 
+	case OP_OR:
+		if ((value & bits) == bits)
+			return replace_with_pseudo(insn, insn->src2);
+		goto case_neutral_zero;
+
 	case OP_SUB:
 		if (value) {
 			insn->opcode = OP_ADD;
@@ -468,7 +475,7 @@ static int simplify_constant_rightside(struct instruction *insn)
 		}
 	/* Fall through */
 	case OP_ADD:
-	case OP_OR: case OP_XOR:
+	case OP_XOR:
 	case OP_SHL:
 	case OP_LSR:
 	case_neutral_zero:
@@ -492,6 +499,8 @@ static int simplify_constant_rightside(struct instruction *insn)
 			return replace_with_pseudo(insn, insn->src1);
 	/* Fall through */
 	case OP_AND:
+		if ((value & bits) == bits)
+			return replace_with_pseudo(insn, insn->src1);
 		if (!value)
 			return replace_with_pseudo(insn, insn->src2);
 		return 0;
diff --git a/validation/optim/bool-not-zero.c b/validation/optim/bool-not-zero.c
new file mode 100644
index 000000000..ce74705e8
--- /dev/null
+++ b/validation/optim/bool-not-zero.c
@@ -0,0 +1,22 @@
+int  or_not0(int a) { return a | ~0; }
+int and_not0(int a) { return a & ~0; }
+
+/*
+ * check-name: bool-not-zero
+ * check-command: test-linearize -Wno-decl $file
+ *
+ * check-output-start
+or_not0:
+.L0:
+	<entry-point>
+	ret.32      $0xffffffff
+
+
+and_not0:
+.L2:
+	<entry-point>
+	ret.32      %arg1
+
+
+ * check-output-end
+ */
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/5] do not linearize expressions without a type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/5] do not linearize expressions without a type
Date: Tue, 19 Sep 2017 02:13:31 +0000
Message-ID: <20170919021335.5881-2-luc.vanoostenryck () gmail ! com>
--------------------
Expressions without a type are the result of previous
errors which left them unevaluated or only partially
evaluated.

Further processing, like here linearization, then
produce nonsensical or erroneous results, with error
messages unrelated to the cause of the error, like:
"unknown expression (...)" or "call with no type!".

Fix this by refusing to linearize an expressions without
a type.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index ba76397ea..c36735cdd 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1581,7 +1581,7 @@ static void linearize_argument(struct entrypoint *ep, struct symbol *arg, int nr
 
 pseudo_t linearize_expression(struct entrypoint *ep, struct expression *expr)
 {
-	if (!expr)
+	if (!expr || !expr->ctype)
 		return VOID;
 
 	current_pos = expr->pos;
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/5] plugins: implement format_template attribute ===

From: Rasmus Villemoes <linux () rasmusvillemoes ! dk>
To: linux-sparse
Subject: [PATCH 1/5] plugins: implement format_template attribute
Date: Sun, 12 Nov 2017 21:19:07 +0000
Message-ID: <20171112211911.27779-1-linux () rasmusvillemoes ! dk>
--------------------
Most format strings in the kernel are string literals, so the compiler
and other static analyzers can do type checking. This plugin covers a
few of the remaining cases, by introducing a format_template
attribute.

Consider struct usb_class_driver. Its member 'name' is used as a
format string in usb_register_dev(), and that use obviously expects
that the format string contains a single "%d" (or maybe %u). So the
idea is that we simply attach __format_template("%d") to the
declaration of the name member of struct usb_class_driver. We can then
check that any static initialization of that member is with a string
literal with the same set of specifiers. This is what the plugin
currently does. There are a number of things it also could/should do:

- Check run-time assignments of literals to a __format_template
annotated struct member.

- Use this at call sites of *printf functions, where the format string
argument is a __format_template annotated struct member - that is, use
the template in lieu of a string literal. For now, this is not
implemented - mostly because I'm lazy and don't want to write my own
format checking code (again), and I suppose there should be an internal
gcc function I could (ab)use to say "check this variadic function call,
but use _this_ as format string".

- It should also be possible to attach it to function parameters -
e.g. the namefmt parameter to kthread_create_on_cpu should have
__format_template("%u"); its only caller is __smpboot_create_thread
which passes struct smp_hotplug_thread->thread_comm, which in turn
should also have that attribute. Combined with the above, this would
check the entire chain from initializer to sprintf().

While strictly speaking "%*s" and "%d %s" both expect (int, const
char*), they're morally distinct, so I don't want to treat them as
equivalent. If this is ever a problem, I think one should let the
attribute take an optional flag argument, which could then control how
strict or lax the checking should be.

I'm not sure how much this affects compilation time, but there's not
really any point in building with this all the time - it should
suffice that the various build bots do it once in a while. Even
without the plugin, the __format_template(...) in headers serve
as concise documentation.

Applying this attribute to smp_hotplug_thread::thread_comm and modifying
kernel/watchdog.c slightly, an example of the error message produced for
violations is:

kernel/watchdog.c:528:1: error: initializer string 'watchdog/%u %d' contains extra format specifier '%d' compared to format template 'foobar/%u'

Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
---
 arch/Kconfig                                 |  18 ++
 include/linux/compiler.h                     |   6 +
 scripts/Makefile.gcc-plugins                 |   2 +
 scripts/gcc-plugins/format_template_plugin.c | 331 +++++++++++++++++++++++++++
 4 files changed, 357 insertions(+)
 create mode 100644 scripts/gcc-plugins/format_template_plugin.c

diff --git a/arch/Kconfig b/arch/Kconfig
index 057370a0ac4e..71c582eaeb69 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -517,6 +517,24 @@ config GCC_PLUGIN_RANDSTRUCT_PERFORMANCE
 	  in structures.  This reduces the performance hit of RANDSTRUCT
 	  at the cost of weakened randomization.
 
+config GCC_PLUGIN_FORMAT_TEMPLATE
+	bool "Enable format_template attribute"
+	depends on GCC_PLUGINS
+	help
+	  This plugin implements a format_template attribute which can
+	  be attached to struct members which are supposed to hold a
+	  (printf) format string. This allows the compiler to check
+	  that (a) any string statically assigned to such a struct
+	  member has format specifiers compatible with those in the
+	  template and (b) when such a struct member is used as the
+	  format argument to a printf function, use the template in
+	  lieu of a string literal to do type checking of the variadic
+	  arguments.
+
+	  Even without using the plugin, attaching the format_template
+	  attribute can be beneficial, since it serves as
+	  documentation.
+
 config HAVE_CC_STACKPROTECTOR
 	bool
 	help
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 202710420d6d..478914ad280b 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -625,4 +625,10 @@ static __always_inline void __write_once_size(volatile void *p, void *res, int s
 	(_________p1); \
 })
 
+#ifdef HAVE_ATTRIBUTE_FORMAT_TEMPLATE
+#define __format_template(x) __attribute__((__format_template__(x)))
+#else
+#define __format_template(x)
+#endif
+
 #endif /* __LINUX_COMPILER_H */
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index b2a95af7df18..2f9bc96aab90 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -35,6 +35,8 @@ ifdef CONFIG_GCC_PLUGINS
   gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_RANDSTRUCT)	+= -DRANDSTRUCT_PLUGIN
   gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_RANDSTRUCT_PERFORMANCE)	+= -fplugin-arg-randomize_layout_plugin-performance-mode
 
+  gcc-plugin-$(CONFIG_GCC_PLUGIN_FORMAT_TEMPLATE)	+= format_template_plugin.so
+
   GCC_PLUGINS_CFLAGS := $(strip $(addprefix -fplugin=$(objtree)/scripts/gcc-plugins/, $(gcc-plugin-y)) $(gcc-plugin-cflags-y))
 
   export PLUGINCC GCC_PLUGINS_CFLAGS GCC_PLUGIN GCC_PLUGIN_SUBDIR
diff --git a/scripts/gcc-plugins/format_template_plugin.c b/scripts/gcc-plugins/format_template_plugin.c
new file mode 100644
index 000000000000..09a798773cfd
--- /dev/null
+++ b/scripts/gcc-plugins/format_template_plugin.c
@@ -0,0 +1,331 @@
+#include <string.h>
+#include <assert.h>
+
+#include "gcc-common.h"
+#include "c-family/c-pragma.h"
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info format_template_plugin_info = {
+	.version	= "20151209",
+	.help		= "format_template_plugin\n",
+};
+
+static tree handle_format_template_attribute(tree *node, tree name, tree args, int __unused flags, bool *no_add_attrs)
+{
+	tree tmpl, orig_attr;
+
+	*no_add_attrs = true;
+	switch (TREE_CODE(*node)) {
+	case FIELD_DECL:
+		break;
+	default:
+		error("%qE attribute only applies to struct members", name);
+		return NULL_TREE;
+	}
+
+	tmpl = TREE_VALUE(args);
+	if (TREE_CODE(tmpl) != STRING_CST) {
+		error("%qE parameter of the %qE attribute is not a string constant", args, name);
+		return NULL_TREE;
+	}
+
+	orig_attr = lookup_attribute("format_template", DECL_ATTRIBUTES(*node));
+	if (orig_attr) {
+		error("%qE attribute applied twice", name);
+		return NULL_TREE;
+	}
+	else
+		*no_add_attrs = false;
+
+	return NULL_TREE;
+}
+
+static struct attribute_spec format_template_attr = {
+	.name				= "format_template",
+	.min_length			= 1,
+	.max_length			= 1,
+	.decl_required			= true,
+	.type_required			= false,
+	.function_type_required		= false,
+	.handler			= handle_format_template_attribute,
+#if BUILDING_GCC_VERSION >= 4007
+	.affects_type_identity		= false
+#endif
+};
+
+static void register_attributes(void __unused *event_data, void __unused *data)
+{
+	register_attribute(&format_template_attr);
+}
+
+static void define_feature_macro(void __unused *event_data, void __unused *data)
+{
+	cpp_define(parse_in, "HAVE_ATTRIBUTE_FORMAT_TEMPLATE");
+}
+
+enum {
+	QUAL_NONE,
+	QUAL_SHORT, /* h */
+	QUAL_BYTE, /* hh, == QUAL_SHORT+1*/
+	QUAL_LONG, /* l */
+	QUAL_LONGLONG, /* ll, == QUAL_LONG+1 */
+	QUAL_MAX, /* j */
+	QUAL_SIZE, /* z */
+	QUAL_PTRDIFF, /* t */
+};
+#define FW_P_NONE (-1)
+#define FW_P_ARG (-2)
+
+struct spec_iter {
+	const char *spec;
+	int len;
+
+	int field_width;
+	int precision;
+	int qual;
+	char type;
+
+};
+
+static inline void
+spec_iter_init(struct spec_iter *spec, const char *s)
+{
+	spec->spec = s;
+	spec->len = 0;
+}
+
+static void get_fw_p(const char **c, int *dst, int prec)
+{
+	*dst = FW_P_NONE;
+	if (prec) {
+		if (**c != '.')
+			return;
+		++(*c);
+		*dst = 0;
+	}
+	if (**c == '*') {
+		++(*c);
+		*dst = FW_P_ARG;
+		return;
+	}
+	if (!ISDIGIT(**c))
+		return;
+	*dst = **c - '0';
+	++(*c);
+	while (ISDIGIT(**c)) {
+		/* should do if (*dst > 10000) warn("insane explicit field width/precision"); */
+		*dst *= 10;
+		*dst += **c - '0';
+		++(*c);
+	}
+}
+
+static int spec_next(struct spec_iter *spec)
+{
+	const char *c;
+	int slen = 0;
+
+	spec->spec += spec->len;
+again:
+	c = strchrnul(spec->spec, '%');
+	slen += c - spec->spec;
+	if (!c[0]) {
+		spec->spec = NULL;
+		return slen;
+	}
+	assert(c[0] == '%');
+	if (c[1] == '%') {
+		slen++;
+		spec->spec = c+2;
+		goto again;
+	}
+
+	spec->spec = c;
+	++c;
+	/* skip flags */
+	while (strchr("#0- +", *c))
+		++c;
+
+	get_fw_p(&c, &spec->field_width, 0);
+	get_fw_p(&c, &spec->precision, 1);
+
+	spec->qual = QUAL_NONE;
+	switch (*c) {
+	case 'h': spec->qual = QUAL_SHORT; break;
+	case 'l': spec->qual = QUAL_LONG; break;
+#if 0 /* The kernel doesn't grok the j qualifier */
+	case 'j': spec->qual = QUAL_MAX; break;
+#endif
+	case 'z': spec->qual = QUAL_SIZE; break;
+	case 't': spec->qual = QUAL_PTRDIFF; break;
+	}
+	if (spec->qual) {
+		++c;
+		if (*c == c[-1] && (*c == 'h' || *c == 'l')) {
+			spec->qual++;
+			++c;
+		}
+	}
+
+	spec->type = *c++;
+	spec->len = c - spec->spec;
+
+	switch (spec->type) {
+	case 'd':
+	case 'u':
+	case 'x':
+	case 'X':
+	case 'o':
+	case 'c':
+	case 's':
+		break;
+	/*
+	 * Disallowing %p is the safe and sane thing to do, given the
+	 * different interpretations based on following alphanumerics.
+	 */
+	case 'p':
+	/*
+	 * Why are there two with the same meaning? %i is the lesser
+	 * used one and should just die.
+	 */
+	case 'i':
+		error("unsupported specifier '%.*s' in template or initializer", spec->len, spec->spec);
+	default:
+		error("invalid specifier '%.*s' in template or initializer", spec->len, spec->spec);
+	}
+
+	return slen;
+}
+
+static bool specs_compatible(const struct spec_iter *a, const struct spec_iter *b)
+{
+	if (a->qual != b->qual)
+		return false;
+	if (a->field_width != b->field_width)
+		return false;
+	if (a->precision != b->precision)
+		return false;
+	if (a->type != b->type)
+		return false;
+	return true;
+}
+
+static void check_literal(tree attr, const char *str)
+{
+	const char *pattern = TREE_STRING_POINTER(TREE_VALUE(TREE_VALUE(attr)));
+	struct spec_iter sp, ss;
+	int i;
+
+	spec_iter_init(&sp, pattern);
+	spec_iter_init(&ss, str);
+
+	/*
+	 * Walk over the pattern and string in lockstep.
+	 */
+	for (i = 1; ; ++i) {
+		spec_next(&sp);
+		spec_next(&ss);
+		/*
+		 * It's ok for the template to have more specifiers
+		 * than the actual string. But issue warning(s)
+		 * anyway, conditional on -Wformat-extra-args.
+		 */
+		if (ss.spec == NULL) {
+			while (sp.spec != NULL) {
+			       warning(OPT_Wformat_extra_args,
+				       "format template '%s' contains extra specifier '%.*s' compared to initializer string '%s'",
+				       pattern, sp.len, sp.spec, str);
+			       spec_next(&sp);
+			}
+			return;
+		}
+		/*
+		 * It's absolutely not ok for the actual string to
+		 * have more specifiers than the template.
+		 */
+		if (!sp.spec) {
+			do {
+				error("initializer string '%s' contains extra format specifier '%.*s' compared to format template '%s'",
+					str, ss.len, ss.spec, pattern);
+				spec_next(&ss);
+			} while (ss.spec != NULL);
+			return;
+		}
+		if (!specs_compatible(&ss, &sp)) {
+			error("specifier %d in '%s' ('%.*s') incompatible with format template '%s'",
+			      i, str, ss.len, ss.spec, pattern);
+		}
+	}
+}
+
+static void check_declaration(void *event_data, void *data __unused)
+{
+	tree decl = (tree)event_data;
+	tree ini, type;
+	unsigned idx;
+	tree field, value;
+
+	switch (TREE_CODE(decl)) {
+	case VAR_DECL:
+		break;
+	default:
+		return;
+	}
+
+	ini = DECL_INITIAL(decl);
+	if (!ini)
+		return;
+
+	type = TREE_TYPE(decl);
+	if (TREE_CODE(type) != RECORD_TYPE)
+		return;
+
+	if (TREE_CODE(ini) != CONSTRUCTOR) {
+		// warning(0, "weird, initializer is not a CONSTRUCTOR, tree_code=%d", TREE_CODE(ini));
+		return;
+	}
+
+	FOR_EACH_CONSTRUCTOR_ELT(CONSTRUCTOR_ELTS(ini), idx, field, value) {
+		tree attr;
+
+		/* if (TREE_CODE(value) != STRING_CST) */
+		/* 	continue; */
+
+		attr = lookup_attribute("format_template", DECL_ATTRIBUTES(field));
+		if (!attr)
+			continue;
+
+		/*
+		 * Hm, apparently the string literal is hidden behind
+		 * a NOP_EXPR and a ADDR_EXPR.
+		 */
+		STRIP_NOPS(value);
+		if (TREE_CODE(value) == ADDR_EXPR)
+			value = TREE_OPERAND(value, 0);
+
+		if (TREE_CODE(value) != STRING_CST)
+			continue;
+
+		check_literal(attr, TREE_STRING_POINTER(value));
+
+	}
+
+}
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char *const plugin_name = plugin_info->base_name;
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &format_template_plugin_info);
+	register_callback(plugin_name, PLUGIN_START_UNIT, &define_feature_macro, NULL);
+	register_callback(plugin_name, PLUGIN_FINISH_DECL, &check_declaration, NULL);
+	register_callback(plugin_name, PLUGIN_ATTRIBUTES, &register_attributes, NULL);
+
+	return 0;
+}
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/5] testsuite: check the nbr of times a pattern should be present ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/5] testsuite: check the nbr of times a pattern should be present
Date: Thu, 05 Jan 2017 05:16:28 +0000
Message-ID: <20170105051632.8392-2-luc.vanoostenryck () gmail ! com>
--------------------
Complement the 'check-output-contains/excludes' tags to also
be able to specify the number of times a given pattern should
occurs in the output.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Documentation/test-suite |  4 ++++
 validation/test-suite    | 28 ++++++++++++++++++++++++++++
 2 files changed, 32 insertions(+)

diff --git a/Documentation/test-suite b/Documentation/test-suite
index a0f205f4..2e786bbf 100644
--- a/Documentation/test-suite
+++ b/Documentation/test-suite
@@ -49,6 +49,10 @@ check-output-excludes: <pattern> (optional)
 	Several such tags can be given, in which case the output
 	must contains none of the patterns.
 
+check-output-pattern-<nbr>-times: <pattern> (optional)
+	Similar than the contains/excludes her above, but with full control
+	of the number of times the pattern should occurs in the output.
+
 	Using test-suite
 	~~~~~~~~~~~~~~~~
 
diff --git a/validation/test-suite b/validation/test-suite
index e5317109..c14a4c5a 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -93,6 +93,27 @@ has_none_patterns()
 	has_patterns "$1" "$2" "$3" -eq
 }
 
+##
+# nbr_patterns(ifile tag ofile) - does ofile contains the
+#                        the patterns given by ifile's tags
+#                        the right number of time?
+nbr_patterns()
+{
+	ifile="$1"
+	patt="$2"
+	ofile="$3"
+	grep "$patt-[0-9][0-9]*-times:" "$ifile" | \
+	sed -e "s/^.*$patt-\([0-9][0-9]*\)-times: *\(.*\)/\1 \2/" | \
+	while read nbr pat; do
+		n=$(grep -s "$pat" "$ofile" | wc -l)
+		if [ "$n" -ne "$nbr" ]; then
+			return 1
+		fi
+	done
+
+	return $?
+}
+
 ##
 # verbose(string) - prints string if we are in verbose mode
 verbose()
@@ -221,6 +242,13 @@ do_test()
 		test_failed=1
 	fi
 
+	# verify the 'check-output-pattern-X-times' tags
+	nbr_patterns "$file" 'check-output-pattern' $file.output.got
+	if [ "$?" -ne "0" ]; then
+		error "Actual output doesn't contain the pattern the expected number."
+		test_failed=1
+	fi
+
 	get_tag "check-known-to-fail" $file
 	must_fail=`expr "$?" = 0`
 	known_ko_tests=`expr $known_ko_tests + $must_fail`
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/6] build: make PREFIX overwritable from the environment ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH 1/6] build: make PREFIX overwritable from the environment
Date: Wed, 04 Oct 2017 13:26:00 +0000
Message-ID: <20171004132605.24734-2-uwe () kleine-koenig ! org>
--------------------
This way I can just use

	env PREFIX=/usr make install

on the command line to install sparse into the system.

Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
 Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index d0341764158e..e011df3cc0dc 100644
--- a/Makefile
+++ b/Makefile
@@ -54,7 +54,7 @@ BASIC_CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
 endif
 
 DESTDIR=
-PREFIX=$(HOME)
+PREFIX ?= $(HOME)
 BINDIR=$(PREFIX)/bin
 LIBDIR=$(PREFIX)/lib
 MANDIR=$(PREFIX)/share/man
-- 
2.14.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/6] fix boolean context for OP_AND_BOOL & OP_OR_BOOL ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/6] fix boolean context for OP_AND_BOOL & OP_OR_BOOL
Date: Wed, 12 Apr 2017 19:33:39 +0000
Message-ID: <20170412193344.95935-2-luc.vanoostenryck () gmail ! com>
--------------------
Current simplification of 'x && 1 --> x' and its dual
'x || 0 --> x' are wrong because the '||' and '&&' operators
demand that their operands are first compared against zero
which then always give a boolean valued result.
For example: '3 && 1' is not equal to '3' but to '1'.
The correct simplification is thus 'x && 1 --> x != 0' and
'x || 0 --> x != 0'.

Fix this by always first doing the comparison against zero
before generating the OP_AND_BOOL and OP_OR_BOOL instructions.

Note: of course, we could decide that the semantic of OP_AND_BOOL
      and OP_OR_BOOL is that these ops take care themselves of
      making a boolean context (which I think was why these
      ops were created) but then these simplifications cannot be
      done (or when they are done, we need to add the comparison
      against zero).

Fixes: b85ec4bb7f5b1c522d7c71782dbd9cf1c4c49b2f
Fixes: a0886db12307d2633b04ec44342099a2955794a5
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c                        | 42 +++++++++++++++++++++++++++++++--
 validation/optim/bool-context-fp.c | 48 ++++++++++++++++++++++++++++++++++++++
 validation/optim/bool-context.c    | 12 ++++++++++
 validation/optim/bool-simplify.c   |  8 +++++--
 4 files changed, 106 insertions(+), 4 deletions(-)
 create mode 100644 validation/optim/bool-context.c

diff --git a/linearize.c b/linearize.c
index 9fda0a1ad..e730ab56f 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1209,6 +1209,31 @@ static int map_opcode(int opcode, struct symbol *ctype)
 	return opcode;
 }
 
+static inline pseudo_t add_convert_to_bool(struct entrypoint *ep, pseudo_t src, struct symbol *type)
+{
+	pseudo_t zero;
+	int op;
+
+	if (is_bool_type(type))
+		return src;
+	if (is_float_type(type)) {
+		zero = add_setfval(ep, type, 0.0);
+		op = map_opcode(OP_SET_NE, type);
+	} else {
+		zero = value_pseudo(0);
+		op = OP_SET_NE;
+	}
+	return add_binary_op(ep, &bool_ctype, op, src, zero);
+}
+
+static pseudo_t linearize_expression_to_bool(struct entrypoint *ep, struct expression *expr)
+{
+	pseudo_t dst;
+	dst = linearize_expression(ep, expr);
+	dst = add_convert_to_bool(ep, dst, expr->ctype);
+	return dst;
+}
+
 static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *expr)
 {
 	struct access_data ad = { NULL, };
@@ -1351,6 +1376,19 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 	return retval;
 }
 
+static pseudo_t linearize_binop_bool(struct entrypoint *ep, struct expression *expr)
+{
+	pseudo_t src1, src2, dst;
+	int op = (expr->op == SPECIAL_LOGICAL_OR) ? OP_OR_BOOL : OP_AND_BOOL;
+
+	src1 = linearize_expression_to_bool(ep, expr->left);
+	src2 = linearize_expression_to_bool(ep, expr->right);
+	dst = add_binary_op(ep, &bool_ctype, op, src1, src2);
+	if (expr->ctype != &bool_ctype)
+		dst = cast_pseudo(ep, dst, &bool_ctype, expr->ctype);
+	return dst;
+}
+
 static pseudo_t linearize_binop(struct entrypoint *ep, struct expression *expr)
 {
 	pseudo_t src1, src2, dst;
@@ -1361,8 +1399,6 @@ static pseudo_t linearize_binop(struct entrypoint *ep, struct expression *expr)
 		['|'] = OP_OR,  ['^'] = OP_XOR,
 		[SPECIAL_LEFTSHIFT] = OP_SHL,
 		[SPECIAL_RIGHTSHIFT] = OP_LSR,
-		[SPECIAL_LOGICAL_AND] = OP_AND_BOOL,
-		[SPECIAL_LOGICAL_OR] = OP_OR_BOOL,
 	};
 	int op;
 
@@ -1647,6 +1683,8 @@ pseudo_t linearize_expression(struct entrypoint *ep, struct expression *expr)
 		return linearize_call_expression(ep, expr);
 
 	case EXPR_BINOP:
+		if (expr->op == SPECIAL_LOGICAL_AND || expr->op == SPECIAL_LOGICAL_OR)
+			return linearize_binop_bool(ep, expr);
 		return linearize_binop(ep, expr);
 
 	case EXPR_LOGICAL:
diff --git a/validation/optim/bool-context-fp.c b/validation/optim/bool-context-fp.c
index ad075c56e..6b3e8d181 100644
--- a/validation/optim/bool-context-fp.c
+++ b/validation/optim/bool-context-fp.c
@@ -5,6 +5,10 @@ bool bfexp(float a) { return (bool)a; }
 
 bool bfnot(float a) { return !a; }
 int  ifnot(float a) { return !a; }
+bool bfior(float a, float b) { return a || b; }
+int  ifior(float a, float b) { return a || b; }
+bool bfand(float a, float b) { return a && b; }
+int  ifand(float a, float b) { return a && b; }
 
 /*
  * check-name: bool context fp
@@ -43,5 +47,49 @@ ifnot:
 	ret.32      %r16
 
 
+bfior:
+.L8:
+	<entry-point>
+	setfval.32  %r19 <- 0.000000
+	fcmpune.1   %r20 <- %arg1, %r19
+	fcmpune.1   %r23 <- %arg2, %r19
+	or-bool.1   %r24 <- %r23, %r20
+	setne.1     %r26 <- %r24, $0
+	ret.1       %r26
+
+
+ifior:
+.L10:
+	<entry-point>
+	setfval.32  %r29 <- 0.000000
+	fcmpune.1   %r30 <- %arg1, %r29
+	fcmpune.1   %r33 <- %arg2, %r29
+	or-bool.1   %r34 <- %r33, %r30
+	cast.32     %r35 <- (1) %r34
+	ret.32      %r35
+
+
+bfand:
+.L12:
+	<entry-point>
+	setfval.32  %r38 <- 0.000000
+	fcmpune.1   %r39 <- %arg1, %r38
+	fcmpune.1   %r42 <- %arg2, %r38
+	and-bool.1  %r43 <- %r42, %r39
+	setne.1     %r45 <- %r43, $0
+	ret.1       %r45
+
+
+ifand:
+.L14:
+	<entry-point>
+	setfval.32  %r48 <- 0.000000
+	fcmpune.1   %r49 <- %arg1, %r48
+	fcmpune.1   %r52 <- %arg2, %r48
+	and-bool.1  %r53 <- %r52, %r49
+	cast.32     %r54 <- (1) %r53
+	ret.32      %r54
+
+
  * check-output-end
  */
diff --git a/validation/optim/bool-context.c b/validation/optim/bool-context.c
new file mode 100644
index 000000000..11326d391
--- /dev/null
+++ b/validation/optim/bool-context.c
@@ -0,0 +1,12 @@
+#define bool _Bool
+
+bool bool_ior(int a, int b) { return a || b; }
+bool bool_and(int a, int b) { return a && b; }
+
+/*
+ * check-name: bool-context
+ * check-command: test-linearize -Wno-decl $file
+ * check-output-ignore
+ *
+ * check-output-pattern-4-times: setne\\..* %arg[12]
+ */
diff --git a/validation/optim/bool-simplify.c b/validation/optim/bool-simplify.c
index e0ff1c2d4..05be11497 100644
--- a/validation/optim/bool-simplify.c
+++ b/validation/optim/bool-simplify.c
@@ -32,13 +32,17 @@ and_0:
 and_1:
 .L2:
 	<entry-point>
-	ret.32      %arg1
+	setne.1     %r8 <- %arg1, $0
+	cast.32     %r11 <- (1) %r8
+	ret.32      %r11
 
 
 or_0:
 .L4:
 	<entry-point>
-	ret.32      %arg1
+	setne.1     %r14 <- %arg1, $0
+	cast.32     %r17 <- (1) %r14
+	ret.32      %r17
 
 
 or_1:
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/6] testsuite: get all tags in once ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/6] testsuite: get all tags in once
Date: Sun, 28 May 2017 19:29:01 +0000
Message-ID: <20170528192906.1023-2-luc.vanoostenryck () gmail ! com>
--------------------
The test cases contain annotations with the following:
	check-<tagname>[: <value>]
These are extracted with grep & sed but this is done
separately for each tags which means that we need fork+exec
two processes for each possible tags.

Change this by trying to get all the tag+value in once by storing
the result in a variables instead of doing the grep & sed thing
at each time we need to check the tag.

This speedup the testsuite by around 30% for me.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 77 ++++++++++++++++++++++++++++-----------------------
 1 file changed, 43 insertions(+), 34 deletions(-)

diff --git a/validation/test-suite b/validation/test-suite
index 904a2dbbd..fa4cd36cf 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -33,24 +33,39 @@ known_ko_tests=0
 [ -z "$V" ] && V=0
 
 ##
-# get_value(key, file) - gets the value of a (key, value) pair in file.
-#
-# returns 0 on success, 1 if the file does not have the key
-get_value()
-{
-	last_result=`grep $1: $2 | sed -e "s/^.*$1:\(.*\)$/\1/"`
-	[ -z "$last_result" ] && return 1
-	return 0
-}
-
-##
-# get_tag(key, file) - does file has the tag key in it ?
-#
-# returns 0 if present, 1 otherwise
-get_tag()
+# get_tag_value(file) - get the 'check-<...>' tags & values
+get_tag_value()
 {
-	last_result=`grep $1 $2`
-	return $?
+	check_name=""
+	check_command="$default_cmd"
+	check_exit_value=0
+	check_known_to_fail=0
+	check_error_ignore=0
+	check_output_ignore=0
+	check_output_contains=0
+	check_output_excludes=0
+	check_output_pattern=0
+
+	lines=$(grep 'check-[a-z-]*' $1 | \
+		sed -e 's/^.*\(check-[a-z-]*:*\) *\(.*\)$/\1 \2/')
+
+	while read tag val; do
+		#echo "-> tag: '$tag'"
+		#echo "-> val: '$val'"
+		case $tag in
+		check-name:)		check_name="$val" ;;
+		check-command:)		check_command="$val" ;;
+		check-exit-value:)	check_exit_value="$val" ;;
+		check-known-to-fail)	check_known_to_fail=1 ;;
+		check-error-ignore)	check_error_ignore=1 ;;
+		check-output-ignore)	check_output_ignore=1 ;;
+		check-output-contains:)	check_output_contains=1 ;;
+		check-output-excludes:)	check_output_excludes=1 ;;
+		check-output-pattern-)	check_output_pattern=1 ;;
+		esac
+	done << EOT
+	$lines
+EOT
 }
 
 ##
@@ -159,23 +174,22 @@ do_test()
 	test_failed=0
 	file="$1"
 
+	get_tag_value $file
+
 	# can this test be handled by test-suite ?
 	# (it has to have a check-name key in it)
-	get_value "check-name" $file
-	if [ "$?" -eq 1 ]; then
+	if [ "$check_name" = "" ]; then
 		echo "warning: test '$file' unhandled"
 		unhandled_tests=`expr $unhandled_tests + 1`
 		return 2
 	fi
-	test_name=$last_result
+	test_name="$check_name"
 
 	# does the test provide a specific command ?
-	cmd=`eval echo $default_path/$default_cmd`
-	get_value "check-command" $file
-	if [ "$?" -eq "0" ]; then
-		last_result=`echo $last_result | sed -e 's/^ *//'`
-		cmd=`eval echo $default_path/$last_result`
+	if [ "$check_command" = "" ]; then
+		check_command="$defaut_command"
 	fi
+	cmd=`eval echo $default_path/$check_command`
 
 	# check for disabled commands
 	set -- $cmd
@@ -199,12 +213,7 @@ do_test()
 		| grep -v check-error > "$file".error.expected
 
 	# grab the expected exit value
-	get_value "check-exit-value" $file
-	if [ "$?" -eq "0" ]; then
-		expected_exit_value=`echo $last_result | tr -d ' '`
-	else
-		expected_exit_value=0
-	fi
+	expected_exit_value=$check_exit_value
 	verbose "Expecting exit value: $expected_exit_value"
 
 
@@ -212,14 +221,14 @@ do_test()
 	$cmd 1> $file.output.got 2> $file.error.got
 	actual_exit_value=$?
 
-	get_tag "check-known-to-fail" $file
-	must_fail=`expr "$?" = 0`
+	must_fail=$check_known_to_fail
 	quiet=0
 	[ $must_fail -eq 1 ] && [ $V -eq 0 ] && quiet=1
 	known_ko_tests=`expr $known_ko_tests + $must_fail`
 
 	for stream in output error; do
-		grep -s -q "check-$stream-ignore" $file && continue
+		eval ignore=\$check_${stream}_ignore
+		[ $ignore -eq 1 ] && continue
 
 		diff -u "$file".$stream.expected "$file".$stream.got > "$file".$stream.diff
 		if [ "$?" -ne "0" ]; then
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/9] add is_pseudo_value() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 1/9] add is_pseudo_value()
Date: Wed, 31 May 2017 03:21:59 +0000
Message-ID: <20170531032207.95830-2-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/linearize.h b/linearize.h
index bac82d7ff..c704b87b4 100644
--- a/linearize.h
+++ b/linearize.h
@@ -45,6 +45,13 @@ extern struct pseudo void_pseudo;
 
 #define VOID (&void_pseudo)
 
+
+static inline int is_pseudo_value(pseudo_t p, long long value)
+{
+	return p->type == PSEUDO_VAL && p->value == value;
+}
+
+
 struct multijmp {
 	struct basic_block *target;
 	int begin, end;
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] Introduce __cond_lock_err ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] Introduce __cond_lock_err
Date: Wed, 27 Dec 2017 14:38:50 +0000
Message-ID: <20171227143850.nnuatshhezurbu7r () ltop ! local>
--------------------
On Sat, Dec 23, 2017 at 05:06:21AM -0800, Matthew Wilcox wrote:
> On Sat, Dec 23, 2017 at 01:39:11AM -0800, Josh Triplett wrote:
> > +linux-sparse
> 
> Ehh ... we've probably trimmed too much to give linux-sparse a good summary.
> 
> Here're the important lines from my patch:
> 
> +# define __cond_lock_err(x,c)  ((c) ? 1 : ({ __acquire(x); 0; }))
> 
> +       return __cond_lock_err(*ptlp, __follow_pte_pmd(mm, address, start, end,
> +                                                   ptepp, pmdpp, ptlp));
> 
> This is supposed to be "If "c" is an error value, we don't have a lock,
> otherwise we have a lock".  And to translate from linux-speak into
> sparse-speak:
> 
>  # define __acquire(x)  __context__(x,1)
> 
> Josh & Ross pointed out (quite correctly) that code which does something like
> 
> if (foo())
> 	return;
> 
> will work with this, but code that does
> 
> if (foo() < 0)
> 	return;
> 
> will not because we're now returning 1 instead of -ENOMEM (for example).
> 
> So they made the very sensible suggestion that I change the definition
> of __cond_lock to:
> 
> # define __cond_lock_err(x,c)  ((c) ?: ({ __acquire(x); 0; }))
> 
> Unfortunately, when I do that, the context imbalance warning returns.
> As I said below, this is with sparse 0.5.1.

I think this __cond_lock_err() is now OK (but some comment about
how its use is different from __cond_lock() would be welcome).

For the context imbalance, I would really need a concrete example
to be able to help more because it depends heavily on what the
test is and what code is before and after.

If you can point me to a tree, a .config and a specific warning,
I'll be glad to take a look.

-- Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] V2 sparse-llvm: use pseudo->size to select llvm integer type ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH 2/2] V2 sparse-llvm: use pseudo->size to select llvm integer type
Date: Mon, 13 Nov 2017 15:28:20 +0000
Message-ID: <CANeU7Q=Rnm1XxCRvU_fm1TPy1U3EBMQH+63kpMirpXLecbGrqA () mail ! gmail ! com>
--------------------
Now constant pseudo has size saved in pseudo->size.
Use that size to select proper integer type for sparse-llvm.

Reported-by: Dibyendu Majumdar <mobile@majumdar.org.uk>
Signed-off-by: Christopher Li <sparse@chrisli.org>
---
 sparse-llvm.c | 21 +++++++++++++--------
 1 file changed, 13 insertions(+), 8 deletions(-)

diff --git a/sparse-llvm.c b/sparse-llvm.c
index 29fb65f1..31f87f0b 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -242,25 +242,30 @@ static LLVMTypeRef symbol_type(LLVMModuleRef
module, struct symbol *sym)
  return ret;
 }

-static LLVMTypeRef insn_symbol_type(LLVMModuleRef module, struct
instruction *insn)
+static LLVMTypeRef int_type_by_size(int size)
 {
- if (insn->type)
- return symbol_type(module, insn->type);
-
- switch (insn->size) {
+ switch (size) {
+ case 1: return LLVMInt1Type();
  case 8: return LLVMInt8Type();
  case 16: return LLVMInt16Type();
  case 32: return LLVMInt32Type();
  case 64: return LLVMInt64Type();

  default:
- die("invalid bit size %d", insn->size);
+ die("invalid bit size %d", size);
  break;
  }
-
  return NULL; /* not reached */
 }

+static LLVMTypeRef insn_symbol_type(LLVMModuleRef module, struct
instruction *insn)
+{
+ if (insn->type)
+ return symbol_type(module, insn->type);
+
+ return int_type_by_size(insn->size);
+}
+
 static LLVMLinkage data_linkage(struct symbol *sym)
 {
  if (sym->ctype.modifiers & MOD_STATIC)
@@ -360,7 +365,7 @@ static LLVMValueRef pseudo_to_value(struct
function *fn, struct instruction *ins
  break;
  }
  case PSEUDO_VAL:
- result = LLVMConstInt(insn_symbol_type(fn->module, insn), pseudo->value, 1);
+ result = LLVMConstInt(int_type_by_size(pseudo->size), pseudo->value, 1);
  break;
  case PSEUDO_ARG: {
  result = LLVMGetParam(fn->fn, pseudo->nr - 1);
-- 
2.13.6
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] add support for '-f[no-][un]signed-char' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] add support for '-f[no-][un]signed-char'
Date: Fri, 29 Dec 2017 21:46:25 +0000
Message-ID: <20171229214625.41368-3-luc.vanoostenryck () gmail ! com>
--------------------
Till now, sparse's plain chars where signed with no possibility
to change it. This is a problem when using sparse on code
for architectures like ARM where chars are by default unsigned
or simply for code compiled with GCC's '-f[no-][un]signed-char'.

Change this by parsing these options and adjusting the type
of plain chars accordingly.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c                      |  3 +++
 lib.h                      |  1 +
 sparse.1                   |  5 +++++
 symbol.c                   |  6 ++++++
 validation/char-signed.c   |  9 +++++++++
 validation/char-unsigned.c | 11 +++++++++++
 6 files changed, 35 insertions(+)
 create mode 100644 validation/char-signed.c
 create mode 100644 validation/char-unsigned.c

diff --git a/lib.c b/lib.c
index b018eb972..fb11738ca 100644
--- a/lib.c
+++ b/lib.c
@@ -263,6 +263,7 @@ unsigned long fdump_ir;
 int fmem_report = 0;
 unsigned long long fmemcpy_max_count = 100000;
 unsigned long fpasses = ~0UL;
+int funsigned_char = 0;
 
 int preprocess_only;
 
@@ -878,6 +879,8 @@ static struct flag fflags[] = {
 	{ "tabstop=",		NULL,	handle_ftabstop },
 	{ "mem2reg",		NULL,	handle_fpasses,	PASS_MEM2REG },
 	{ "optim",		NULL,	handle_fpasses,	PASS_OPTIM },
+	{ "signed-char",	&funsigned_char, NULL,	OPT_INVERSE },
+	{ "unsigned-char",	&funsigned_char, NULL, },
 	{ },
 };
 
diff --git a/lib.h b/lib.h
index b0f342658..37d486727 100644
--- a/lib.h
+++ b/lib.h
@@ -171,6 +171,7 @@ extern int fmem_report;
 extern unsigned long fdump_ir;
 extern unsigned long long fmemcpy_max_count;
 extern unsigned long fpasses;
+extern int funsigned_char;
 
 extern int arch_m64;
 extern int arch_msize_long;
diff --git a/sparse.1 b/sparse.1
index 5b2bcd9c2..efb012933 100644
--- a/sparse.1
+++ b/sparse.1
@@ -381,6 +381,11 @@ Set the distance between tab stops.  This helps sparse report correct
 column numbers in warnings or errors.  If the value is less than 1 or
 greater than 100, the option is ignored.  The default is 8.
 .
+.TP
+.B \-f[no-]unsigned-char, \-f[no-]signed-char
+Let plain 'char' be unsigned or signed.
+By default chars are signed.
+.
 .SH SEE ALSO
 .BR cgcc (1)
 .
diff --git a/symbol.c b/symbol.c
index 2f4afd515..773060ec1 100644
--- a/symbol.c
+++ b/symbol.c
@@ -767,4 +767,10 @@ void init_ctype(void)
 		sym->ctype.base_type = ctype->base_type;
 		sym->ctype.modifiers = ctype->modifiers;
 	}
+
+	// and now some adjustments
+	if (funsigned_char) {
+		char_ctype.ctype.modifiers |= MOD_UNSIGNED;
+		char_ctype.ctype.modifiers &= ~MOD_SIGNED;
+	}
 }
diff --git a/validation/char-signed.c b/validation/char-signed.c
new file mode 100644
index 000000000..7f657dacb
--- /dev/null
+++ b/validation/char-signed.c
@@ -0,0 +1,9 @@
+void foo(void)
+{
+	_Static_assert((char) -1 == -1, "plain char is not signed");
+}
+
+/*
+ * check-name: fsigned-char
+ * check-command: sparse -fsigned-char -Wno-decl $file
+ */
diff --git a/validation/char-unsigned.c b/validation/char-unsigned.c
new file mode 100644
index 000000000..19cadbda3
--- /dev/null
+++ b/validation/char-unsigned.c
@@ -0,0 +1,11 @@
+#define	MASK ((1 << __CHAR_BIT__) - 1)
+
+void foo(void)
+{
+	_Static_assert((char) -1 == (-1 & MASK), "plain char is not unsigned");
+}
+
+/*
+ * check-name: fsigned-char
+ * check-command: sparse -funsigned-char -Wno-decl $file
+ */
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] fix crash on bad expression in linearize_switch() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] fix crash on bad expression in linearize_switch()
Date: Thu, 28 Dec 2017 17:25:19 +0000
Message-ID: <20171228172519.16550-3-luc.vanoostenryck () gmail ! com>
--------------------
If the expression for the condition is dereferenced
for its type even if it is NULL.

Fix this by returning early if the expression linearize to NULL.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c             | 2 ++
 validation/empty-expr.c | 1 -
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/linearize.c b/linearize.c
index 2e146de7a..deed3ca2f 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1945,6 +1945,8 @@ static pseudo_t linearize_switch(struct entrypoint *ep, struct statement *stmt)
 	pseudo_t pseudo;
 
 	pseudo = linearize_expression(ep, expr);
+	if (pseudo == VOID)
+		return pseudo;
 
 	active = ep->active;
 	if (!bb_reachable(active))
diff --git a/validation/empty-expr.c b/validation/empty-expr.c
index 506cfba7e..61decf737 100644
--- a/validation/empty-expr.c
+++ b/validation/empty-expr.c
@@ -18,7 +18,6 @@ static int bar(void)
 
 /*
  * check-name: empty expression
- * check-known-to-fail
  *
  * check-error-start
 empty-expr.c:3:17: error: an expression is expected before ')'
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] fix: evaluate_dereference() unexamined base type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] fix: evaluate_dereference() unexamined base type
Date: Thu, 21 Dec 2017 00:30:17 +0000
Message-ID: <20171221003017.57211-3-luc.vanoostenryck () gmail ! com>
--------------------
Examination of a pointer type doesn't examine the corresponding
base type (this base type may not yet be complete). So, this
examination must be done later, when the base type is needed.

However, in some cases it's possible to call evaluate_dereference()
while the base type is still unexamined.

Fix this by adding the missing examine_symbol_type() on the base type.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                               | 1 +
 validation/linear/deref-ptr-ptr.c        | 1 -
 validation/linear/unexamined-base-type.c | 1 -
 3 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 6b3e2c257..85f1b21bb 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1778,6 +1778,7 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 
 	node = alloc_symbol(expr->pos, SYM_NODE);
 	target = ctype->ctype.base_type;
+	examine_symbol_type(target);
 
 	switch (ctype->type) {
 	default:
diff --git a/validation/linear/deref-ptr-ptr.c b/validation/linear/deref-ptr-ptr.c
index 022595d78..963acd36c 100644
--- a/validation/linear/deref-ptr-ptr.c
+++ b/validation/linear/deref-ptr-ptr.c
@@ -6,7 +6,6 @@ char *foo(char **pfmt)
 /*
  * check-name: deref-ptr-ptr
  * check-command: test-linearize -m64 -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-excludes: load[^.]
  * check-output-contains: load\.
diff --git a/validation/linear/unexamined-base-type.c b/validation/linear/unexamined-base-type.c
index a138ba132..96aee3f0e 100644
--- a/validation/linear/unexamined-base-type.c
+++ b/validation/linear/unexamined-base-type.c
@@ -28,7 +28,6 @@ static void bar(struct s *d, struct s *s1, struct s *s2)
  *		                   ^^^		!! WRONG !!
  *		and.32      %r6 <- %r5, $1
  *		ret.32      %r6
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: load[^.]
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] fix: restore CSE on floating-point compares ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] fix: restore CSE on floating-point compares
Date: Thu, 28 Dec 2017 22:17:35 +0000
Message-ID: <20171228221735.38902-3-luc.vanoostenryck () gmail ! com>
--------------------
Since commit "1c182507c (fix support of floating-point compare)",
CSE wasn't done anymore on floating-point compare.

Fix this by adding the two missing 'case OP_FPCMP ...'

Fixes: 1c182507c3981aa20193c68d7cfd32d750b571cf
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 cse.c                       | 4 +++-
 validation/optim/cse-fcmp.c | 1 -
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/cse.c b/cse.c
index d5da26fba..6987645c1 100644
--- a/cse.c
+++ b/cse.c
@@ -71,7 +71,8 @@ static void clean_up_one_instruction(struct basic_block *bb, struct instruction
 	case OP_SET_B:  case OP_SET_A:
 	case OP_SET_BE: case OP_SET_AE:
 
-	/* floating-point arithmetic */
+	/* floating-point arithmetic & comparison */
+	case OP_FPCMP ... OP_FPCMP_END:
 	case OP_FADD:
 	case OP_FSUB:
 	case OP_FMUL:
@@ -214,6 +215,7 @@ static int insn_compare(const void *_i1, const void *_i2)
 	case OP_SET_BE: case OP_SET_AE:
 
 	/* floating-point arithmetic */
+	case OP_FPCMP ... OP_FPCMP_END:
 	case OP_FADD:
 	case OP_FSUB:
 	case OP_FMUL:
diff --git a/validation/optim/cse-fcmp.c b/validation/optim/cse-fcmp.c
index 9e6872302..f2a73f57f 100644
--- a/validation/optim/cse-fcmp.c
+++ b/validation/optim/cse-fcmp.c
@@ -13,7 +13,6 @@ int foo(double a, double b)
 /*
  * check-name: cse-fcmp
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-pattern(1): fcmp
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] fix: volatile stores must not be simplified ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] fix: volatile stores must not be simplified
Date: Sat, 11 Nov 2017 16:25:00 +0000
Message-ID: <20171111162500.69476-3-luc.vanoostenryck () gmail ! com>
--------------------
kill_dominated_stores() simplify away redundant stores.
Nice but volatile stores are never redundant and must
never be simplified away.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 memops.c                     | 6 +++++-
 validation/memops-volatile.c | 1 -
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/memops.c b/memops.c
index aeacdf566..1c845a5f9 100644
--- a/memops.c
+++ b/memops.c
@@ -158,8 +158,12 @@ static void kill_dominated_stores(struct basic_block *bb)
 		if (insn->opcode == OP_STORE) {
 			struct instruction *dom;
 			pseudo_t pseudo = insn->src;
-			int local = local_pseudo(pseudo);
+			int local;
+
+			if (insn->type->ctype.modifiers & MOD_VOLATILE)
+				continue;
 
+			local = local_pseudo(pseudo);
 			RECURSE_PTR_REVERSE(insn, dom) {
 				int dominance;
 				if (!dom->bb)
diff --git a/validation/memops-volatile.c b/validation/memops-volatile.c
index 71299f49d..15314e1ce 100644
--- a/validation/memops-volatile.c
+++ b/validation/memops-volatile.c
@@ -9,7 +9,6 @@ static int foo(volatile int *a, int v)
  * check-name: memops-volatile
  * check-command: test-linearize $file
  *
- * check-known-to-fail
  * check-output-ignore
  * check-output-contains: store\\..*%arg2 -> 0\\[%arg1]
  * check-output-contains: store\\..*\\$0 -> 0\\[%arg1]
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] llvm: default init of arrays & structs ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] llvm: default init of arrays & structs
Date: Thu, 28 Dec 2017 22:30:26 +0000
Message-ID: <20171228223026.39089-3-luc.vanoostenryck () gmail ! com>
--------------------
Linearization of arrays & structs default initialization is done
as if these objects would be an integer as large as the object.
This integer is then simply zero-initialized.
(This may be objectionable and will be done differently).

However, sparse-llvm is not ready to handle this situation where
a non-scalar is initialized with a scalar value.

Workaround this by using LLVMConstNull() when possible.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 sparse-llvm.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/sparse-llvm.c b/sparse-llvm.c
index 4c64f1aaa..a1a48fd0f 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -354,6 +354,12 @@ static LLVMValueRef constant_value(unsigned long long val, LLVMTypeRef dtype)
 	case LLVMIntegerTypeKind:
 		result = LLVMConstInt(dtype, val, 1);
 		break;
+	case LLVMArrayTypeKind:
+	case LLVMStructTypeKind:
+		if (val != 0)
+			return NULL;
+		result = LLVMConstNull(dtype);
+		break;
 	default:
 		return NULL;
 	}
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] pre-process: replace use of vla's with heap allocation ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] pre-process: replace use of vla's with heap allocation
Date: Thu, 20 Jul 2017 12:02:33 +0000
Message-ID: <CANeU7QkmtVVPhhanR2M7=3P9cCse0B9rXJSfx8c1NCC4aHZ-qw () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 4:13 PM, Ramsay Jones
<ramsay@ramsayjones.plus.com> wrote:
>
> The 'selfcheck' make target issues warnings about using vla's in the
> pre-processor code, like so:
>
>        CHECK    pre-process.c
>   pre-process.c:712:25: warning: Variable length array is used.
>   pre-process.c:2019:28: warning: Variable length array is used.
>
> A Makefile change to pass '-Wno-vla' to sparse when processing this
> source file (or all source files) may be a better solution than the
> one given here.
>
> Replace the use of vla's with heap allocation. This has performance
> implications (although it may me safer), due to the dynamic memory
> allocation and the zero initialisation of the memory (using calloc).
> I have not done any timing measurements to see if this is a problem
> in practice.

I purpose the following patch. Make the expand using stack for small
argument numbers. That should not have much performance impact
at all because long macro arguments are rare.

Incremental patch follows. If you think that is fine, I will apply the
combined patch as yours.

> +       if (nargs > 0)
> +               args = calloc(nargs, sizeof(*args));

Need to check alloc failed.

> +
>         if (sym->arglist) {
>                 if (!match_op(scan_next(&token->next), '('))
>                         return 1;

Need to free alloc memory.


> +       if (nargs > 0)
> +               args = calloc(nargs, sizeof(*args));

Same here need to check alloc failed.

Chris

Purposed incremental fix up follows:

--- sparse.chrisl.orig/pre-process.c
+++ sparse.chrisl/pre-process.c
@@ -709,21 +709,30 @@ static int expand(struct token **list, s
  struct ident *expanding = token->ident;
  struct token **tail;
  int nargs = sym->arglist ? sym->arglist->count.normal : 0;
- struct arg *args = NULL;
+#define ARG_LIMIT 8
+ struct arg arg_array[ARG_LIMIT], *args = arg_array;
+ int err = 0;

  if (expanding->tainted) {
  token->pos.noexpand = 1;
  return 1;
  }

- if (nargs > 0)
+ if (nargs >= ARG_LIMIT) {
  args = calloc(nargs, sizeof(*args));
+ if (!args)
+ die("calloc(%d, %lu) failed", nargs, sizeof(*args));
+ }

  if (sym->arglist) {
- if (!match_op(scan_next(&token->next), '('))
- return 1;
- if (!collect_arguments(token->next, sym->arglist, args, token))
- return 1;
+ if (!match_op(scan_next(&token->next), '(')) {
+ err = 1;
+ goto exit;
+ }
+ if (!collect_arguments(token->next, sym->arglist, args, token)) {
+ err = 1;
+ goto exit;
+ }
  expand_arguments(nargs, args);
  }

@@ -741,9 +750,11 @@ static int expand(struct token **list, s
  (*list)->pos.whitespace = token->pos.whitespace;
  *tail = last;

- free(args);
+exit:
+ if (nargs >= ARG_LIMIT)
+ free(args);

- return 0;
+ return err;
 }

 static const char *token_name_sequence(struct token *token, int
endop, struct token *start)
@@ -2024,8 +2035,11 @@ static void dump_macro(struct symbol *sy
  struct token **args = NULL;
  struct token *token;

- if (nargs > 0)
+ if (nargs > 0) {
  args = calloc(nargs, sizeof(*args));
+ if (!args)
+ die("calloc %ld", nargs * sizeof(*args));
+ }

  printf("#define %s", show_ident(sym->ident));
  token = sym->arglist;
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] pre-process: replace use of vla's with heap allocation
Date: Thu, 20 Jul 2017 16:44:48 +0000
Message-ID: <cce05c3f-a309-9fa7-3107-e6e6831972aa () ramsayjones ! plus ! com>
--------------------


On 20/07/17 13:02, Christopher Li wrote:
> On Wed, Jul 19, 2017 at 4:13 PM, Ramsay Jones
> <ramsay@ramsayjones.plus.com> wrote:
>>
>> The 'selfcheck' make target issues warnings about using vla's in the
>> pre-processor code, like so:
>>
>>        CHECK    pre-process.c
>>   pre-process.c:712:25: warning: Variable length array is used.
>>   pre-process.c:2019:28: warning: Variable length array is used.
>>
>> A Makefile change to pass '-Wno-vla' to sparse when processing this
>> source file (or all source files) may be a better solution than the
>> one given here.
>>
>> Replace the use of vla's with heap allocation. This has performance
>> implications (although it may me safer), due to the dynamic memory
>> allocation and the zero initialisation of the memory (using calloc).
>> I have not done any timing measurements to see if this is a problem
>> in practice.
> 
> I purpose the following patch. Make the expand using stack for small
> argument numbers. That should not have much performance impact
> at all because long macro arguments are rare.

My first reaction was surprise that you didn't go for the Makefile
idea - setting '-Wno-vla' would be the simplest solution. ;-)

I can understand warning about vla usage (especially in the kernel),
but it a 'standard' supported feature. I don't use them myself, partly
because they are a 'relatively' new feature, but also because I have had
some bad experience in the past using alloca in similar circumstances.

My second thought was, have you done some timing tests (no I haven't)
and determined that this causes a noticeable slowdown?

> Incremental patch follows. If you think that is fine, I will apply the
> combined patch as yours.
> 
>> +       if (nargs > 0)
>> +               args = calloc(nargs, sizeof(*args));
> 
> Need to check alloc failed.

Yes, indeed! *blush*

>> +
>>         if (sym->arglist) {
>>                 if (!match_op(scan_next(&token->next), '('))
>>                         return 1;
> 
> Need to free alloc memory.

Ahem, I obviously didn't think about this patch too much! :-D

> 
> 
>> +       if (nargs > 0)
>> +               args = calloc(nargs, sizeof(*args));
> 
> Same here need to check alloc failed.
> 
> Chris
> 
> Purposed incremental fix up follows:

Hmm, dunno.

I did, briefly, think about adding an 'array' capability to the
sparse ALLOCATOR facility (you can only allocate single instances
from the current allocators - ignoring 'string' and 'bytes').

ATB,
Ramsay Jones

> 
> --- sparse.chrisl.orig/pre-process.c
> +++ sparse.chrisl/pre-process.c
> @@ -709,21 +709,30 @@ static int expand(struct token **list, s
>   struct ident *expanding = token->ident;
>   struct token **tail;
>   int nargs = sym->arglist ? sym->arglist->count.normal : 0;
> - struct arg *args = NULL;
> +#define ARG_LIMIT 8
> + struct arg arg_array[ARG_LIMIT], *args = arg_array;
> + int err = 0;
> 
>   if (expanding->tainted) {
>   token->pos.noexpand = 1;
>   return 1;
>   }
> 
> - if (nargs > 0)
> + if (nargs >= ARG_LIMIT) {
>   args = calloc(nargs, sizeof(*args));
> + if (!args)
> + die("calloc(%d, %lu) failed", nargs, sizeof(*args));
> + }
> 
>   if (sym->arglist) {
> - if (!match_op(scan_next(&token->next), '('))
> - return 1;
> - if (!collect_arguments(token->next, sym->arglist, args, token))
> - return 1;
> + if (!match_op(scan_next(&token->next), '(')) {
> + err = 1;
> + goto exit;
> + }
> + if (!collect_arguments(token->next, sym->arglist, args, token)) {
> + err = 1;
> + goto exit;
> + }
>   expand_arguments(nargs, args);
>   }
> 
> @@ -741,9 +750,11 @@ static int expand(struct token **list, s
>   (*list)->pos.whitespace = token->pos.whitespace;
>   *tail = last;
> 
> - free(args);
> +exit:
> + if (nargs >= ARG_LIMIT)
> + free(args);
> 
> - return 0;
> + return err;
>  }
> 
>  static const char *token_name_sequence(struct token *token, int
> endop, struct token *start)
> @@ -2024,8 +2035,11 @@ static void dump_macro(struct symbol *sy
>   struct token **args = NULL;
>   struct token *token;
> 
> - if (nargs > 0)
> + if (nargs > 0) {
>   args = calloc(nargs, sizeof(*args));
> + if (!args)
> + die("calloc %ld", nargs * sizeof(*args));
> + }
> 
>   printf("#define %s", show_ident(sym->ident));
>   token = sym->arglist;
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] pre-process: replace use of vla's with heap allocation
Date: Sat, 29 Jul 2017 13:17:06 +0000
Message-ID: <CAExDi1S_mQRHQmAOOhdctbJOgLCo0pArXO6_QKY2WaNMsb9Y0Q () mail ! gmail ! com>
--------------------
On Thu, Jul 20, 2017 at 6:44 PM, Ramsay Jones
<ramsay@ramsayjones.plus.com> wrote:
>
>
> On 20/07/17 13:02, Christopher Li wrote:
>> On Wed, Jul 19, 2017 at 4:13 PM, Ramsay Jones
>> <ramsay@ramsayjones.plus.com> wrote:
>>>
>>> The 'selfcheck' make target issues warnings about using vla's in the
>>> pre-processor code, like so:
>>>
>>>        CHECK    pre-process.c
>>>   pre-process.c:712:25: warning: Variable length array is used.
>>>   pre-process.c:2019:28: warning: Variable length array is used.
>>>
>>> A Makefile change to pass '-Wno-vla' to sparse when processing this
>>> source file (or all source files) may be a better solution than the
>>> one given here.
>>>
>>> Replace the use of vla's with heap allocation. This has performance
>>> implications (although it may me safer), due to the dynamic memory
>>> allocation and the zero initialisation of the memory (using calloc).
>>> I have not done any timing measurements to see if this is a problem
>>> in practice.
>>
>> I purpose the following patch. Make the expand using stack for small
>> argument numbers. That should not have much performance impact
>> at all because long macro arguments are rare.
>
> My first reaction was surprise that you didn't go for the Makefile
> idea - setting '-Wno-vla' would be the simplest solution. ;-)
>
> I can understand warning about vla usage (especially in the kernel),
> but it a 'standard' supported feature. I don't use them myself, partly
> because they are a 'relatively' new feature, but also because I have had
> some bad experience in the past using alloca in similar circumstances.

I second this opinion.
In the kernel, stacks are quite small and it's very natural to:
- limit stack use to the minimal
- control stack usage
and so VLAs are avoided (but not banned).
But in userspace this limit doesn't exist so why make the code
more complicated?

> My second thought was, have you done some timing tests (no I haven't)
> and determined that this causes a noticeable slowdown?

Also, this is not IMO -rc4+ material.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] pre-process: replace use of vla's with heap allocation
Date: Sat, 29 Jul 2017 16:16:53 +0000
Message-ID: <CANeU7Q=eCq6Ndxsq8GnVNb7J=MYD=3vHjBf1R1miLPbyWkXYxg () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 9:17 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> My first reaction was surprise that you didn't go for the Makefile
>> idea - setting '-Wno-vla' would be the simplest solution. ;-)

Yes, I am convince too. I haven't thought of that.
You can submit a patch for '-Wno-vla'. I will apply it, but most
likely after this release.

>> My second thought was, have you done some timing tests (no I haven't)
>> and determined that this causes a noticeable slowdown?

I did some limited test it is within std on kernel compile. But I am
not very happy
about the stack usage per macro will expand to 8 argument structs regardless
how few arguments used myself. The -Wno-vla is better idea.

> Also, this is not IMO -rc4+ material.

Agree, because it changes the code behavior. Do you mind have the '-Wno-vla'
in -rc5? That should not change any code it generate. I am fine either way.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] remove prototype for unexistant examine_simple_symbol_type() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/2] remove prototype for unexistant examine_simple_symbol_type()
Date: Tue, 19 Sep 2017 03:08:40 +0000
Message-ID: <20170919030840.12525-3-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/symbol.h b/symbol.h
index 614763404..0c50884af 100644
--- a/symbol.h
+++ b/symbol.h
@@ -303,7 +303,6 @@ extern void bind_symbol(struct symbol *, struct ident *, enum namespace);
 
 extern struct symbol *examine_symbol_type(struct symbol *);
 extern struct symbol *examine_pointer_target(struct symbol *);
-extern void examine_simple_symbol_type(struct symbol *);
 extern const char *show_typename(struct symbol *sym);
 extern const char *builtin_typename(struct symbol *sym);
 extern const char *builtin_ctypename(struct ctype *ctype);
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] add helper: is_scalar_type() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] add helper: is_scalar_type()
Date: Sun, 29 Jan 2017 11:34:08 +0000
Message-ID: <20170129113409.9834-3-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 symbol.h | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/symbol.h b/symbol.h
index 9b3f1604e..b0176bc5e 100644
--- a/symbol.h
+++ b/symbol.h
@@ -372,6 +372,28 @@ static inline int is_bool_type(struct symbol *type)
 	return type == &bool_ctype;
 }
 
+static inline int is_scalar_type(struct symbol *type)
+{
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	switch (type->type) {
+	case SYM_ENUM:
+	case SYM_BITFIELD:
+	case SYM_PTR:
+	case SYM_ARRAY:		// OK, will be a PTR after conversion
+	case SYM_FN:
+	case SYM_RESTRICT:	// OK, always integer types
+		return 1;
+	default:
+		break;
+	}
+	if (type->ctype.base_type == &int_type)
+		return 1;
+	if (type->ctype.base_type == &fp_type)
+		return 1;
+	return 0;
+}
+
 static inline int is_function(struct symbol *type)
 {
 	return type && type->type == SYM_FN;
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] avoid to redefine __INT_MAX__ and friends ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] avoid to redefine __INT_MAX__ and friends
Date: Fri, 19 May 2017 11:20:52 +0000
Message-ID: <20170519112053.24632-3-luc.vanoostenryck () gmail ! com>
--------------------
Since commit 4fae9be00 & 5466cf8f3 ("predefine __INT_MAX__ and friends" &
"predefine __SIZEOF_INT__ & friends"), macros like __INT_MAX__  and
__SIZEOF_POINTER__ are predefine twice.

Fix this by removing the old definition, based on the size of these
types on the machine where sparse was compiled.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/lib.c b/lib.c
index cf6bea645..20eb72e95 100644
--- a/lib.c
+++ b/lib.c
@@ -1072,11 +1072,7 @@ void create_builtin_stream(void)
 	/* GCC defines these for limits.h */
 	add_pre_buffer("#weak_define __SHRT_MAX__ " STRINGIFY(__SHRT_MAX__) "\n");
 	add_pre_buffer("#weak_define __SCHAR_MAX__ " STRINGIFY(__SCHAR_MAX__) "\n");
-	add_pre_buffer("#weak_define __INT_MAX__ " STRINGIFY(__INT_MAX__) "\n");
-	add_pre_buffer("#weak_define __LONG_MAX__ " STRINGIFY(__LONG_MAX__) "\n");
-	add_pre_buffer("#weak_define __LONG_LONG_MAX__ " STRINGIFY(__LONG_LONG_MAX__) "\n");
 	add_pre_buffer("#weak_define __WCHAR_MAX__ " STRINGIFY(__WCHAR_MAX__) "\n");
-	add_pre_buffer("#weak_define __SIZEOF_POINTER__ " STRINGIFY(__SIZEOF_POINTER__) "\n");
 	add_pre_buffer("#weak_define __CHAR_BIT__ " STRINGIFY(__CHAR_BIT__) "\n");
 }
 
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] avoid unneeded alloc on error path ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] avoid unneeded alloc on error path
Date: Thu, 21 Dec 2017 00:19:14 +0000
Message-ID: <20171221001915.57047-3-luc.vanoostenryck () gmail ! com>
--------------------
In evaluate_dereference(), a node is allocated but
is not used if there is an error.

Fix this by allocating the node after the error checks.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index 6b3e2c257..e6dbe3d8d 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1776,7 +1776,6 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 
-	node = alloc_symbol(expr->pos, SYM_NODE);
 	target = ctype->ctype.base_type;
 
 	switch (ctype->type) {
@@ -1784,6 +1783,7 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 		expression_error(expr, "cannot dereference this type");
 		return NULL;
 	case SYM_PTR:
+		node = alloc_symbol(expr->pos, SYM_NODE);
 		node->ctype.modifiers = target->ctype.modifiers & MOD_SPECIFIER;
 		merge_type(node, ctype);
 		break;
@@ -1801,6 +1801,7 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 		 * When an array is dereferenced, we need to pick
 		 * up the attributes of the original node too..
 		 */
+		node = alloc_symbol(expr->pos, SYM_NODE);
 		merge_type(node, op->ctype);
 		merge_type(node, ctype);
 		break;
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/3] simplify linearize_call_expression() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/3] simplify linearize_call_expression()
Date: Thu, 21 Dec 2017 00:06:41 +0000
Message-ID: <20171221000642.56954-3-luc.vanoostenryck () gmail ! com>
--------------------
Use the fact that fn->ctype can't be NULL if expr->ctype
is not NULL.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/linearize.c b/linearize.c
index eff7d95f1..7ad348c00 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1279,15 +1279,10 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 	}
 
 	fn = expr->fn;
-
-	if (fn->ctype)
-		ctype = &fn->ctype->ctype;
-
 	fntype = fn->ctype;
-	if (fntype) {
-		if (fntype->type == SYM_NODE)
-			fntype = fntype->ctype.base_type;
-	}
+	ctype = &fntype->ctype;
+	if (fntype->type == SYM_NODE)
+		fntype = fntype->ctype.base_type;
 
 	add_symbol(&insn->fntypes, fntype);
 	FOR_EACH_PTR(expr->args, arg) {
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/5] add test case for warnings about overlapping initializers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/5] add test case for warnings about overlapping initializers
Date: Wed, 22 Feb 2017 15:30:03 +0000
Message-ID: <20170222153006.3035-3-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/field-override.c | 88 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 88 insertions(+)
 create mode 100644 validation/field-override.c

diff --git a/validation/field-override.c b/validation/field-override.c
new file mode 100644
index 000000000..d5d00dfa8
--- /dev/null
+++ b/validation/field-override.c
@@ -0,0 +1,88 @@
+static int ref[] = {
+	[1] = 3,
+	[2] = 3,
+	[3] = 3,
+	[2] = 2,		/* check-should-warn */
+	[1] = 1,		/* check-should-warn */
+};
+
+static int foo[] = {
+	[1 ... 3] = 3,
+};
+
+static int foz[4] = {
+	[0 ... 3] = 3,
+	[0] = 0,
+	[1] = 0,
+	[2 ... 3] = 1,
+	[2] = 3,		/* check-should-warn */
+	[3] = 3,		/* check-should-warn */
+};
+
+static int bar[] = {
+	[1 ... 3] = 3,
+	[1]       = 1,		/* check-should-warn */
+	[2]       = 2,		/* check-should-warn */
+	[2 ... 4] = 2,		/* check-should-warn */
+	[2 ... 3] = 2,		/* check-should-warn */
+	[4] = 4,		/* check-should-warn */
+	[0] = 0,
+	[5] = 5,
+};
+
+static int baz[3][3] = {
+	[0 ... 2][0 ... 2] = 0,
+	[0] = { 0, 0, 0, },	/* check-should-warn */
+	[0][0] = 1,		/* check-should-warn */
+	[1] = { 0, 0, 0, },	/* check-should-warn */
+	[1][0] = 1,		/* check-should-warn */
+	[1][1] = 1,		/* check-should-warn */
+	[1 ... 2][1 ... 2] = 2,
+};
+
+
+struct s {
+	int i;
+	int a[2];
+};
+
+static struct s s = {
+	.a[0] = 0,
+	.a[1] = 1,
+};
+
+static struct s a[2] = {
+	[0].i = 0,
+	[1].i = 1,
+	[0].a[0] = 2,
+	[0].a[1] = 3,
+};
+
+static struct s b[2] = {
+	[0 ... 1] = { 0, { 1, 2 }, },
+	[0].i = 0,
+	[1].i = 1,
+	[0].a[0] = 2,
+	[0].a[1] = 3,
+};
+
+/*
+ * check-name: field-override
+ * check-command: sparse -Woverride-init $file
+ * check-known-to-fail
+ *
+ * check-error-start
+field-override.c:2:10: warning: Initializer entry defined twice
+field-override.c:6:10:   also defined here
+field-override.c:14:10: warning: Initializer entry defined twice
+field-override.c:15:10:   also defined here
+field-override.c:23:10: warning: Initializer entry defined twice
+field-override.c:24:10:   also defined here
+field-override.c:23:10: warning: Initializer entry defined twice
+field-override.c:25:10:   also defined here
+field-override.c:34:10: warning: Initializer entry defined twice
+field-override.c:35:10:   also defined here
+field-override.c:62:10: warning: Initializer entry defined twice
+field-override.c:63:10:   also defined here
+ * check-error-end
+ */
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/5] avoid crash when ep->active is NULL ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/5] avoid crash when ep->active is NULL
Date: Thu, 20 Jul 2017 04:37:49 +0000
Message-ID: <CANeU7QnkroKeCbALvQ_VVjzDmiEhQhFtLB4wpiEUzXOhnHVoPg () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 3:20 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This patch fixes a reproducible crash and have been ignored
> since it has been posted two weeks ago.
> Is there any reasons why?

Because you are away? We are discussing the different approach of the first
patch and all the sudden you stop response to email.

Those small patch are trivial to review. Just a ping would be good enough.

BTW, the check should happen before the allocation. Otherwise there is
memory leak.

Chris

        pseudo_t phi = __alloc_pseudo(0);
        static int nr = 0;

+       if (!source)
+               return VOID;
+
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/5] testsuite: use 'error' instead of 'info' for successful tests known to fail ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/5] testsuite: use 'error' instead of 'info' for successful tests known to fail
Date: Thu, 05 Jan 2017 05:16:29 +0000
Message-ID: <20170105051632.8392-3-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/validation/test-suite b/validation/test-suite
index c14a4c5a..852904a4 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -259,7 +259,7 @@ do_test()
 		if [ "$test_failed" -eq "1" ]; then
 			echo "info: test '$file' is known to fail"
 		else
-			echo "info: test '$file' is known to fail but succeed!"
+			echo "error: test '$file' is known to fail but succeed!"
 			test_failed=1
 		fi
 	fi
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/6] build: put comment about local.mk to the place where it is included ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/6] build: put comment about local.mk to the place where it is included
Date: Fri, 06 Oct 2017 19:04:36 +0000
Message-ID: <CANeU7Qn4TB-xEzQyYaT6yd2K-ge_dvoOL04A_jwUkZwWn-Dppg () mail ! gmail ! com>
--------------------
On Wed, Oct 4, 2017 at 6:26 AM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.or=
g> wrote:
>
>  # Allow users to override build settings without dirtying their trees
> +# For debugging, put this in local.mk:
> +#
> +#     CFLAGS +=3D -O0 -DDEBUG -g3 -gdwarf-2
> +#
>  -include local.mk

This and the first patch is fine. Subject to impact of the
debug-target-v3 branch.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/6] simplify intermediate casts in boolean expressions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/6] simplify intermediate casts in boolean expressions
Date: Wed, 12 Apr 2017 19:33:40 +0000
Message-ID: <20170412193344.95935-3-luc.vanoostenryck () gmail ! com>
--------------------
For example:
	int ibior(bool a) { return a || a; }

before simplification gives:
	<entry-point>
	setne.1   %r40 <- %arg1
	setne.1   %r42 <- %arg2
	or.1      %r43 <- %r40, %r42
        cast.32   %r44 <- (1) %r43
	ret.32    %r44

after simplification of the 'or', it used to give:
        setne.1     %r40 <- %arg1, $0
        cast.32     %r44 <- (1) %r40
        ret.32      %r44

and now give:
        setne.32    %r44 <- %arg1, $0
        ret.32      %r44

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                       | 17 +++++++++++++++++
 validation/optim/bool-simplify.c |  6 ++----
 2 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/simplify.c b/simplify.c
index b46acd9c2..09d7ae056 100644
--- a/simplify.c
+++ b/simplify.c
@@ -982,6 +982,23 @@ static int simplify_cast(struct instruction *insn)
 			goto simplify;
 	}
 
+	if (insn->opcode == OP_CAST) {
+		struct instruction *def = src->def;
+		if (!def)
+			return 0;
+		switch (def->opcode) {
+		case OP_BINCMP ... OP_BINCMP_END:
+			insn->opcode = def->opcode;
+			use_pseudo(insn, def->src1, &insn->src1);
+			use_pseudo(insn, def->src2, &insn->src2);
+			remove_usage(src, &insn->src);
+			return REPEAT_CSE;
+
+		default:
+			break;
+		}
+	}
+
 	return 0;
 
 simplify:
diff --git a/validation/optim/bool-simplify.c b/validation/optim/bool-simplify.c
index 05be11497..2014d344c 100644
--- a/validation/optim/bool-simplify.c
+++ b/validation/optim/bool-simplify.c
@@ -32,16 +32,14 @@ and_0:
 and_1:
 .L2:
 	<entry-point>
-	setne.1     %r8 <- %arg1, $0
-	cast.32     %r11 <- (1) %r8
+	setne.32    %r11 <- %arg1, $0
 	ret.32      %r11
 
 
 or_0:
 .L4:
 	<entry-point>
-	setne.1     %r14 <- %arg1, $0
-	cast.32     %r17 <- (1) %r14
+	setne.32    %r17 <- %arg1, $0
 	ret.32      %r17
 
 
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/6] testsuite: grep the expected output only when needed ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/6] testsuite: grep the expected output only when needed
Date: Sun, 28 May 2017 19:29:02 +0000
Message-ID: <20170528192906.1023-3-luc.vanoostenryck () gmail ! com>
--------------------
Currently the testsuite always try to extract the expected
output from the test case description.
This is done with grep & sed.

But in some case we're not interested to compare the actual
output with the expected one. And in those cases the grep & sed
are just wasted CPU cycles.

Fix this by extracting the expected output only when we know
that it won't be ignored.

This speedup the testsuite by a modest 1%.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/validation/test-suite b/validation/test-suite
index fa4cd36cf..ce2ca454c 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -206,12 +206,6 @@ do_test()
 
 	verbose "Using command       : $cmd"
 
-	# grab the expected output
-	sed -n '/check-output-start/,/check-output-end/p' $file \
-		| grep -v check-output > "$file".output.expected
-	sed -n '/check-error-start/,/check-error-end/p' $file \
-		| grep -v check-error > "$file".error.expected
-
 	# grab the expected exit value
 	expected_exit_value=$check_exit_value
 	verbose "Expecting exit value: $expected_exit_value"
@@ -230,6 +224,10 @@ do_test()
 		eval ignore=\$check_${stream}_ignore
 		[ $ignore -eq 1 ] && continue
 
+		# grab the expected output
+		sed -n "/check-$stream-start/,/check-$stream-end/p" $file \
+		| grep -v check-$stream > "$file".$stream.expected
+
 		diff -u "$file".$stream.expected "$file".$stream.got > "$file".$stream.diff
 		if [ "$?" -ne "0" ]; then
 			error "actual $stream text does not match expected $stream text."
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/8] add helper add_load_dominators() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/8] add helper add_load_dominators()
Date: Thu, 13 Apr 2017 16:55:45 +0000
Message-ID: <20170413165551.2785-3-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c | 12 ++++++++++++
 flow.h |  1 +
 2 files changed, 13 insertions(+)

diff --git a/flow.c b/flow.c
index 50507a5e7..25a5bffbe 100644
--- a/flow.c
+++ b/flow.c
@@ -417,6 +417,18 @@ void add_dominator(struct pseudo_list **phi_list, struct instruction *insn,
 	use_pseudo(insn, phi, add_pseudo(phi_list, phi));
 }
 
+struct pseudo_list *add_load_dominators(struct instruction *insn, struct instruction_list *doms,
+	struct ident *ident)
+{
+	struct pseudo_list *phi_list = NULL;
+	struct instruction *dom;
+
+	FOR_EACH_PTR(doms, dom) {
+		add_dominator(&phi_list, insn, dom, ident);
+	} END_FOR_EACH_PTR(dom);
+	return phi_list;
+}
+
 /*
  * We should probably sort the phi list just to make it easier to compare
  * later for equality. 
diff --git a/flow.h b/flow.h
index 800585547..a6d0881c2 100644
--- a/flow.h
+++ b/flow.h
@@ -39,6 +39,7 @@ void check_access(struct instruction *insn);
 void convert_load_instruction(struct instruction *, pseudo_t);
 void rewrite_load_instruction(struct instruction *, struct pseudo_list *);
 void add_dominator(struct pseudo_list **, struct instruction *, struct instruction *, struct ident*);
+struct pseudo_list *add_load_dominators(struct instruction *, struct instruction_list *, struct ident*);
 int dominates(pseudo_t pseudo, struct instruction *insn, struct instruction *dom, int local);
 
 extern void clear_liveness(struct entrypoint *ep);
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/9] add a .warned field to struct instruction ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 2/9] add a .warned field to struct instruction
Date: Wed, 31 May 2017 03:22:00 +0000
Message-ID: <20170531032207.95830-3-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.h | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/linearize.h b/linearize.h
index c704b87b4..2b6cb0c86 100644
--- a/linearize.h
+++ b/linearize.h
@@ -75,8 +75,9 @@ struct asm_rules {
 DECLARE_ALLOCATOR(asm_rules);
 
 struct instruction {
-	unsigned opcode:8,
-		 size:24;
+	unsigned opcode:7;
+	unsigned warned:1;
+	unsigned size:24;
 	struct basic_block *bb;
 	struct position pos;
 	struct symbol *type;
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] add test case for bad return type ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] add test case for bad return type
Date: Mon, 18 Sep 2017 14:10:57 +0000
Message-ID: <20170918141057.69745-4-luc.vanoostenryck () gmail ! com>
--------------------
add test cases for the diagnostic of:
- void function returning an integer
- int  function returning with a bare 'return'

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/bad-return-type.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)
 create mode 100644 validation/bad-return-type.c

diff --git a/validation/bad-return-type.c b/validation/bad-return-type.c
new file mode 100644
index 000000000..0f3b3f516
--- /dev/null
+++ b/validation/bad-return-type.c
@@ -0,0 +1,19 @@
+void foo(int a)
+{
+	return a;
+}
+
+int bar(void)
+{
+	return;
+}
+
+/*
+ * check-name: bad return type
+ * check-command: sparse -Wno-decl $file
+ *
+ * check-error-start
+bad-return-type.c:3:16: error: return expression in void function
+bad-return-type.c:8:9: error: return with no return value
+ * check-error-end
+ */
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] dereference of a function is a no-op ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] dereference of a function is a no-op
Date: Thu, 21 Dec 2017 00:19:15 +0000
Message-ID: <20171221001915.57047-4-luc.vanoostenryck () gmail ! com>
--------------------
For the '*' operator and functions, the C standard says:
        "If the operand points to a function, the result is a
         function designator; ... If the operand has type
         âpointer to typeâ, the result has type âtypeâ".
but also (C11 6.3.2.1p4):
        "(except with 'sizeof' ...) a function designator with type
         âfunction returning typeâ is converted to an expression
          that has type âpointer to function returning typeâ".

This means that in dereferencement of a function-designator is
a no-op since the resulting expression is immediately back converted
to a pointer to the function.

The change effectively drop any dereferencement of function types
during their evaluation.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                         | 3 +++
 validation/function-pointer-type.c | 1 -
 validation/linear/call-builtin.c   | 1 -
 validation/linear/call-direct.c    | 1 -
 validation/linear/call-indirect.c  | 1 -
 validation/linear/call-inline.c    | 1 -
 validation/sizeof-function.c       | 1 -
 7 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index e6dbe3d8d..840f98d3e 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1782,6 +1782,9 @@ static struct symbol *evaluate_dereference(struct expression *expr)
 	default:
 		expression_error(expr, "cannot dereference this type");
 		return NULL;
+	case SYM_FN:
+		*expr = *op;
+		return expr->ctype;
 	case SYM_PTR:
 		node = alloc_symbol(expr->pos, SYM_NODE);
 		node->ctype.modifiers = target->ctype.modifiers & MOD_SPECIFIER;
diff --git a/validation/function-pointer-type.c b/validation/function-pointer-type.c
index cb1f59b2a..ebc4007ba 100644
--- a/validation/function-pointer-type.c
+++ b/validation/function-pointer-type.c
@@ -9,5 +9,4 @@ void f3(void) { int (*f)(void); f = ***fun; }	// C99,C11 6.5.3.2p4
 /*
  * check-name: type of function pointers
  * check-command: sparse -Wno-decl $file
- * check-known-to-fail
  */
diff --git a/validation/linear/call-builtin.c b/validation/linear/call-builtin.c
index b0261e992..b15113593 100644
--- a/validation/linear/call-builtin.c
+++ b/validation/linear/call-builtin.c
@@ -10,7 +10,6 @@ u32 f3(u32 a) { return (***__builtin_popcount)(a); }	// C99,C11 6.5.3.2p4
 /*
  * check-name: builtin calls
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: load
diff --git a/validation/linear/call-direct.c b/validation/linear/call-direct.c
index 176bfe229..52f86306b 100644
--- a/validation/linear/call-direct.c
+++ b/validation/linear/call-direct.c
@@ -10,7 +10,6 @@ int f3(void) { return (***fun)(); }	// C99,C11 6.5.3.2p4
 /*
  * check-name: direct calls
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: load
diff --git a/validation/linear/call-indirect.c b/validation/linear/call-indirect.c
index d8797b024..1275910c4 100644
--- a/validation/linear/call-indirect.c
+++ b/validation/linear/call-indirect.c
@@ -8,7 +8,6 @@ int g3(int (*fun)(void)) { return (***fun)(); }	// C99,C11 6.5.3.2p4
 /*
  * check-name: indirect calls
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: load
diff --git a/validation/linear/call-inline.c b/validation/linear/call-inline.c
index d931a3cba..a33f0a1c8 100644
--- a/validation/linear/call-inline.c
+++ b/validation/linear/call-inline.c
@@ -10,7 +10,6 @@ int i3(void) { return (***fun)(); }		// C99,C11 6.5.3.2p4
 /*
  * check-name: inline calls
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: load
diff --git a/validation/sizeof-function.c b/validation/sizeof-function.c
index 20c795e94..27d535d4e 100644
--- a/validation/sizeof-function.c
+++ b/validation/sizeof-function.c
@@ -36,7 +36,6 @@ int test(void)
 /*
  * check-name: sizeof-function
  * check-command: sparse -Wno-decl $file
- * check-known-to-fail
  *
  * check-error-start
 sizeof-function.c:22:14: warning: expression using sizeof on a function
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] expand __builtin_bswap*() with constant args ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] expand __builtin_bswap*() with constant args
Date: Mon, 23 Jan 2017 21:37:28 +0000
Message-ID: <20170123213728.89900-4-luc.vanoostenryck () gmail ! com>
--------------------
Things are greatly simplified now that such builtins can have a
prototype: the args and result are already evaluated, the argument
number and type are already checked, ...

Based-on-patch-by: Christopher Li <sparse@chrisli.org>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 builtin.c                           | 30 +++++++++++++++++++++
 lib.c                               | 35 +++----------------------
 lib.h                               |  5 ++++
 validation/builtin-bswap-constant.c | 48 ++++++++++++++++++++++++++++++++++
 validation/builtin-bswap.c          | 52 +++++++++++++++++++++++++++++++++++++
 5 files changed, 138 insertions(+), 32 deletions(-)
 create mode 100644 validation/builtin-bswap-constant.c
 create mode 100644 validation/builtin-bswap.c

diff --git a/builtin.c b/builtin.c
index ddc71f785..4dddb1e1d 100644
--- a/builtin.c
+++ b/builtin.c
@@ -176,6 +176,33 @@ static struct symbol_op choose_op = {
 	.args = arguments_choose,
 };
 
+/* The argument is constant and valid if the cost is zero */
+static int expand_bswap(struct expression *expr, int cost)
+{
+	long long input;
+
+	if (cost)
+		return cost;
+
+	/* the argument's number have already been checked */
+	input = const_expression_value(first_expression(expr->args));
+	switch (expr->ctype->bit_size) {
+	case 16: expr->value = __builtin_bswap16(input); break;
+	case 32: expr->value = __builtin_bswap32(input); break;
+	case 64: expr->value = __builtin_bswap64(input); break;
+	default: /* impossible error */
+		return SIDE_EFFECTS;
+	}
+
+	expr->type = EXPR_VALUE;
+	expr->taint = 0;
+	return 0;
+}
+
+static struct symbol_op bswap_op = {
+	.expand = expand_bswap,
+};
+
 
 /*
  * Builtin functions
@@ -192,6 +219,9 @@ static struct sym_init {
 	{ "__builtin_warning", &builtin_fn_type, MOD_TOPLEVEL, &warning_op },
 	{ "__builtin_expect", &builtin_fn_type, MOD_TOPLEVEL, &expect_op },
 	{ "__builtin_choose_expr", &builtin_fn_type, MOD_TOPLEVEL, &choose_op },
+	{ "__builtin_bswap16", NULL, MOD_TOPLEVEL, &bswap_op },
+	{ "__builtin_bswap32", NULL, MOD_TOPLEVEL, &bswap_op },
+	{ "__builtin_bswap64", NULL, MOD_TOPLEVEL, &bswap_op },
 	{ NULL,		NULL,		0 }
 };
 
diff --git a/lib.c b/lib.c
index 2660575b1..460e07609 100644
--- a/lib.c
+++ b/lib.c
@@ -820,38 +820,9 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern int __builtin_popcountll(unsigned long long);\n");
 
 	/* And byte swaps.. */
-	add_pre_buffer("extern unsigned short ____builtin_bswap16(unsigned short);\n");
-	add_pre_buffer("extern unsigned int ____builtin_bswap32(unsigned int);\n");
-	add_pre_buffer("extern unsigned long long ____builtin_bswap64(unsigned long long);\n");
-	add_pre_buffer("#define __sparse_constant_swab16(x) ((unsigned short)("
-		       "	(((unsigned short)(x) & (unsigned short)0x00ffU) << 8) |"
-		       "	(((unsigned short)(x) & (unsigned short)0xff00U) >> 8)))\n");
-	add_pre_buffer("#define __sparse_constant_swab32(x) ((unsigned int)("
-		       "	(((unsigned int)(x) & (unsigned int)0x000000ffUL) << 24) |"
-		       "	(((unsigned int)(x) & (unsigned int)0x0000ff00UL) <<  8) |"
-		       "	(((unsigned int)(x) & (unsigned int)0x00ff0000UL) >>  8) |"
-		       "	(((unsigned int)(x) & (unsigned int)0xff000000UL) >> 24)))\n");
-	add_pre_buffer("#define __sparse_constant_swab64(x) ((unsigned long long)("
-		       "	(((unsigned long long)(x) & (unsigned long long)0x00000000000000ffULL) << 56) |"
-		       "	(((unsigned long long)(x) & (unsigned long long)0x000000000000ff00ULL) << 40) |"
-		       "	(((unsigned long long)(x) & (unsigned long long)0x0000000000ff0000ULL) << 24) |"
-		       "	(((unsigned long long)(x) & (unsigned long long)0x00000000ff000000ULL) <<  8) |"
-		       "	(((unsigned long long)(x) & (unsigned long long)0x000000ff00000000ULL) >>  8) |"
-		       "	(((unsigned long long)(x) & (unsigned long long)0x0000ff0000000000ULL) >> 24) |"
-		       "	(((unsigned long long)(x) & (unsigned long long)0x00ff000000000000ULL) >> 40) |"
-		       "	(((unsigned long long)(x) & (unsigned long long)0xff00000000000000ULL) >> 56)))\n");
-	add_pre_buffer("#define __builtin_bswap16(x)"
-		       "	(__builtin_constant_p((unsigned short)(x)) ?"
-		       "	__sparse_constant_swab16(x) :"
-		       "	____builtin_bswap16(x))\n");
-	add_pre_buffer("#define __builtin_bswap32(x)"
-		       "	(__builtin_constant_p((unsigned int)(x)) ?"
-		       "	__sparse_constant_swab32(x) :"
-		       "	____builtin_bswap32(x))\n");
-	add_pre_buffer("#define __builtin_bswap64(x)"
-		       "	(__builtin_constant_p((unsigned long long)(x)) ?"
-		       "	__sparse_constant_swab64(x) :"
-		       "	____builtin_bswap64(x))\n");
+	add_pre_buffer("extern unsigned short __builtin_bswap16(unsigned short);\n");
+	add_pre_buffer("extern unsigned int __builtin_bswap32(unsigned int);\n");
+	add_pre_buffer("extern unsigned long long __builtin_bswap64(unsigned long long);\n");
 
 	/* And atomic memory access functions.. */
 	add_pre_buffer("extern int __sync_fetch_and_add(void *, ...);\n");
diff --git a/lib.h b/lib.h
index b778bdcd0..306ee4545 100644
--- a/lib.h
+++ b/lib.h
@@ -200,6 +200,11 @@ static inline struct instruction *first_instruction(struct instruction_list *hea
 	return first_ptr_list((struct ptr_list *)head);
 }
 
+static inline struct expression *first_expression(struct expression_list *head)
+{
+	return first_ptr_list((struct ptr_list *)head);
+}
+
 static inline pseudo_t first_pseudo(struct pseudo_list *head)
 {
 	return first_ptr_list((struct ptr_list *)head);
diff --git a/validation/builtin-bswap-constant.c b/validation/builtin-bswap-constant.c
new file mode 100644
index 000000000..788806f0b
--- /dev/null
+++ b/validation/builtin-bswap-constant.c
@@ -0,0 +1,48 @@
+unsigned short bswap16(void);
+unsigned short bswap16(void)
+{
+	return __builtin_bswap16(0x1234);
+}
+
+unsigned int bswap32(void);
+unsigned int bswap32(void)
+{
+	return __builtin_bswap32(0x12345678);
+}
+
+unsigned long long bswap64(void);
+unsigned long long bswap64(void)
+{
+	return __builtin_bswap64(0x123456789abcdef0ULL);
+}
+
+static unsigned int bad_nbr_args(int a)
+{
+	a |=  __builtin_bswap16();
+	a |=  __builtin_bswap16(1, 2);
+	a |=  __builtin_bswap32();
+	a |=  __builtin_bswap32(1, 2);
+	a |=  __builtin_bswap64();
+	a |=  __builtin_bswap64(1, 2);
+	return a;
+}
+
+/*
+ * check-name: builtin-bswap-constant
+ * check-command: test-linearize $file
+ *
+ * check-output-ignore
+ * check-output-excludes: __builtin_bswap
+ * check-output-contains:ret.16 *.0x3412
+ * check-output-contains:ret.32 *.0x78563412
+ * check-output-contains:ret.64 *.0xf0debc9a78563412
+ *
+ * check-error-start
+builtin-bswap-constant.c:21:32: error: not enough arguments for function __builtin_bswap16
+builtin-bswap-constant.c:22:32: error: too many arguments for function __builtin_bswap16
+builtin-bswap-constant.c:23:32: error: not enough arguments for function __builtin_bswap32
+builtin-bswap-constant.c:24:32: error: too many arguments for function __builtin_bswap32
+builtin-bswap-constant.c:25:32: error: not enough arguments for function __builtin_bswap64
+builtin-bswap-constant.c:26:32: error: too many arguments for function __builtin_bswap64
+ * check-error-end
+ */
diff --git a/validation/builtin-bswap.c b/validation/builtin-bswap.c
new file mode 100644
index 000000000..f98b7fc07
--- /dev/null
+++ b/validation/builtin-bswap.c
@@ -0,0 +1,52 @@
+typedef unsigned short	   u16;
+typedef unsigned int	   u32;
+typedef unsigned long long u64;
+
+static u16 swap16v(u16 a)
+{
+	return __builtin_bswap16(a);
+}
+
+static u32 swap32v(u64 a)
+{
+	return __builtin_bswap32(a);
+}
+
+static u64 swap64v(u32 a)
+{
+	return __builtin_bswap64(a);
+}
+
+static unsigned int bad_nbr_args(int a, int b)
+{
+	a |=  __builtin_bswap16();
+	a |=  __builtin_bswap16(a, b);
+	a |=  __builtin_bswap32();
+	a |=  __builtin_bswap32(a, b);
+	a |=  __builtin_bswap64();
+	a |=  __builtin_bswap64(a, b);
+	return a;
+}
+
+/*
+ * check-name: builtin-bswap
+ * check-command: test-linearize $file
+ * check-description: Check that the right builtin function is called, and
+ *                    that the args are correctly promoted or truncated.
+ *
+ * check-error-start
+builtin-bswap.c:22:32: error: not enough arguments for function __builtin_bswap16
+builtin-bswap.c:23:32: error: too many arguments for function __builtin_bswap16
+builtin-bswap.c:24:32: error: not enough arguments for function __builtin_bswap32
+builtin-bswap.c:25:32: error: too many arguments for function __builtin_bswap32
+builtin-bswap.c:26:32: error: not enough arguments for function __builtin_bswap64
+builtin-bswap.c:27:32: error: too many arguments for function __builtin_bswap64
+ * check-error-end
+ *
+ * check-output-ignore
+ * check-output-contains:call.16 .* __builtin_bswap16
+ * check-output-contains:cast.32 .* (64) %arg1
+ * check-output-contains:call.32 .* __builtin_bswap32
+ * check-output-contains:cast.64 .* (32) %arg1
+ * check-output-contains:call.64 .* __builtin_bswap64
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] fix linearize (*fun)() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] fix linearize (*fun)()
Date: Thu, 21 Dec 2017 00:06:42 +0000
Message-ID: <20171221000642.56954-4-luc.vanoostenryck () gmail ! com>
--------------------
A function call via a function pointer can be written like:
	fp(), (fp)() or (*fp)()
In the latter case the dereference is unneeded but legal and
idiomatic.

However, the linearization doesn't handle this unneeded deref
and leads to the generation of a load of the pointer:

	int foo(int a, int (*fun)(int))
	{
		(*fun)(a);
	}

gives something like:
	foo:
		load        %r2 <- 0[%arg2]
		call.32     %r3 <- %r2, %arg1
		ret.32      %r3

This happens because, at linearization, the deref is dropped
but only if the sub-expression is a symbol and the test for
node is not done.

Fix this by using is_func_type() to test the type of all call
expressions.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c                             | 10 +++-------
 validation/linear/call-basic.c          |  1 -
 validation/linear/call-casted-pointer.c |  1 -
 validation/linear/call-indirect.c       |  1 -
 4 files changed, 3 insertions(+), 10 deletions(-)

diff --git a/linearize.c b/linearize.c
index 7ad348c00..2e146de7a 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1291,13 +1291,9 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 		add_symbol(&insn->fntypes, arg->ctype);
 	} END_FOR_EACH_PTR(arg);
 
-	if (fn->type == EXPR_PREOP) {
-		if (fn->unop->type == EXPR_SYMBOL) {
-			struct symbol *sym = fn->unop->symbol;
-			if (sym->ctype.base_type->type == SYM_FN)
-				fn = fn->unop;
-		}
-	}
+	if (fn->type == EXPR_PREOP && fn->op == '*' && is_func_type(fn->ctype))
+		fn = fn->unop;
+
 	if (fn->type == EXPR_SYMBOL) {
 		call = symbol_pseudo(ep, fn->symbol);
 	} else {
diff --git a/validation/linear/call-basic.c b/validation/linear/call-basic.c
index 235b443d2..60517e2e3 100644
--- a/validation/linear/call-basic.c
+++ b/validation/linear/call-basic.c
@@ -23,7 +23,6 @@ int builtin(int a)
 /*
  * check-name: basic function calls
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-start
 symbol:
diff --git a/validation/linear/call-casted-pointer.c b/validation/linear/call-casted-pointer.c
index e66f69990..610d67482 100644
--- a/validation/linear/call-casted-pointer.c
+++ b/validation/linear/call-casted-pointer.c
@@ -23,7 +23,6 @@ int quz(void *a, void *fun)
 /*
  * check-name: call via casted function pointer
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: load
diff --git a/validation/linear/call-indirect.c b/validation/linear/call-indirect.c
index 8ab78676b..f5f2adaf1 100644
--- a/validation/linear/call-indirect.c
+++ b/validation/linear/call-indirect.c
@@ -6,7 +6,6 @@ int g1(int (*fun)(void)) { return (*fun)(); }	// C99,C11 6.5.3.2p4
 /*
  * check-name: indirect calls
  * check-command: test-linearize -Wno-decl $file
- * check-known-to-fail
  *
  * check-output-ignore
  * check-output-excludes: load
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] simplify casts bool -> int -> bool ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] simplify casts bool -> int -> bool
Date: Wed, 12 Apr 2017 14:18:02 +0000
Message-ID: <20170412141802.81231-4-luc.vanoostenryck () gmail ! com>
--------------------
Because of C's integer promotion, in code like 'a == 0',
the operand 'a' must be promoted to int, which result in
following linearization if the type of 'a' was _Bool:
	cast.32  %t <- (1) %a
	setne.32 %r <- %t, $0
While required by the standard, this promotion is unneeded
in the given situation.

Change this by simplifying away such casts.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                       | 18 +++++++++++++++++-
 validation/optim/bool-int-bool.c | 12 ++++++++++++
 2 files changed, 29 insertions(+), 1 deletion(-)
 create mode 100644 validation/optim/bool-int-bool.c

diff --git a/simplify.c b/simplify.c
index 775c1e2dd..96448a666 100644
--- a/simplify.c
+++ b/simplify.c
@@ -445,9 +445,25 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)
 		remove_usage(old, &insn->src1);
 		return REPEAT_CSE;
 
+	case OP_CAST:
+		if (def->orig_type->bit_size != 1)
+			break;
+
+		// Convert:
+		//	cast.n	%t <- (1) %a
+		//	setne.m %r <- %t, $0
+		// into:
+		//	...
+		//	setne.m %r <- %a, $0
+		// and similar for setne/eq ... 0/1
+		use_pseudo(insn, def->src1, &insn->src1);
+		remove_usage(old, &insn->src1);
+		return REPEAT_CSE;
+
 	default:
-		return 0;
+		break;
 	}
+	return 0;
 }
 
 static int simplify_constant_rightside(struct instruction *insn)
diff --git a/validation/optim/bool-int-bool.c b/validation/optim/bool-int-bool.c
new file mode 100644
index 000000000..de34a68bb
--- /dev/null
+++ b/validation/optim/bool-int-bool.c
@@ -0,0 +1,12 @@
+_Bool beq0(_Bool a) { return (a == 0); }
+_Bool beq1(_Bool a) { return (a == 1); }
+_Bool bne0(_Bool a) { return (a != 0); }
+_Bool bne1(_Bool a) { return (a != 1); }
+
+/*
+ * check-name: bool - int - bool constants
+ * check-command: test-linearize -Wno-decl $file
+ *
+ * check-output-ignore
+ * check-output-excludes: cast\\.
+ */
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/3] validate expression's type in conditionals ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/3] validate expression's type in conditionals
Date: Sun, 29 Jan 2017 11:34:09 +0000
Message-ID: <20170129113409.9834-4-luc.vanoostenryck () gmail ! com>
--------------------
This wasn't done yet, in particular void values was accepted
inside if statements, which lead to strange situations after
linearization.

Implement this simply by calling the newly created is_scalar_type()
in evaluate_conditional() and issuing an appropriate diagnostic
when the check fail.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                    |  5 +++
 validation/conditional-type.c | 99 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 104 insertions(+)
 create mode 100644 validation/conditional-type.c

diff --git a/evaluate.c b/evaluate.c
index e350c0c08..f3616e450 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -865,6 +865,11 @@ static struct symbol *evaluate_conditional(struct expression *expr, int iterator
 	if (ctype) {
 		if (is_safe_type(ctype))
 			warning(expr->pos, "testing a 'safe expression'");
+		if (!is_scalar_type(ctype)) {
+			sparse_error(expr->pos, "incorrect type in conditional");
+			info(expr->pos, "   got %s", show_typename(ctype));
+			ctype = NULL;
+		}
 	}
 
 	return ctype;
diff --git a/validation/conditional-type.c b/validation/conditional-type.c
new file mode 100644
index 000000000..a14c05ec1
--- /dev/null
+++ b/validation/conditional-type.c
@@ -0,0 +1,99 @@
+extern void afun(void);
+extern void vcond(void);
+static int array[3];
+
+struct state {
+	int nr:2;
+};
+
+enum number {
+	zero,
+	one,
+	two,
+	many,
+};
+
+static int bad_if(struct state s)
+{
+	if (vcond()) return 1;
+	if (s) return 1;
+	return 0;
+}
+static void bad_if2(int *a, int *b)
+{
+	if (vcond()) *a = 1;
+	*b = 0;
+}
+static int bad_sel(struct state s)
+{
+	return vcond() ? 1 : 0;
+	return s ? 1 : 0;
+}
+static int bad_loop_void(void)
+{
+	while (vcond())
+		;
+	for (;vcond();)
+		;
+	do
+		;
+	while (vcond());
+	return 0;
+}
+
+
+static int good_if_int(int a, _Bool b, long c, unsigned char d)
+{
+	if (a) return 1;
+	if (b) return 1;
+	if (c) return 1;
+	if (d) return 1;
+	return 0;
+}
+static int good_if_float(float a, double b)
+{
+	if (a) return 1;
+	if (b) return 1;
+	return 0;
+}
+static int good_if_enum(void)
+{
+	if (many) return 1;
+	return 0;
+}
+static int good_if_bitfield(struct state s, struct state *p)
+{
+	if (s.nr) return 1;
+	if (p->nr) return 1;
+	return 0;
+}
+static int good_if_ptr(void *ptr)
+{
+	if (ptr) return 1;
+	if (array) return 1;
+	if (afun) return 1;
+	return 0;
+}
+
+/*
+ * check-name: conditional-type
+ *
+ * check-error-start
+conditional-type.c:18:18: error: incorrect type in conditional
+conditional-type.c:18:18:    got void
+conditional-type.c:19:13: error: incorrect type in conditional
+conditional-type.c:19:13:    got struct state s
+conditional-type.c:24:18: error: incorrect type in conditional
+conditional-type.c:24:18:    got void
+conditional-type.c:29:21: error: incorrect type in conditional
+conditional-type.c:29:21:    got void
+conditional-type.c:30:16: error: incorrect type in conditional
+conditional-type.c:30:16:    got struct state s
+conditional-type.c:34:21: error: incorrect type in conditional
+conditional-type.c:34:21:    got void
+conditional-type.c:36:20: error: incorrect type in conditional
+conditional-type.c:36:20:    got void
+conditional-type.c:40:21: error: incorrect type in conditional
+conditional-type.c:40:21:    got void
+ * check-error-end
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/5] add helper: valid_expr_subtype() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/5] add helper: valid_expr_subtype()
Date: Tue, 19 Sep 2017 02:13:33 +0000
Message-ID: <20170919021335.5881-4-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/evaluate.c b/evaluate.c
index 649e132b8..0394dcbb9 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -47,6 +47,17 @@ struct symbol *current_fn;
 static struct symbol *degenerate(struct expression *expr);
 static struct symbol *evaluate_symbol(struct symbol *sym);
 
+static inline int valid_expr_type(struct expression *expr)
+{
+	return expr && valid_type(expr->ctype);
+}
+
+static inline int valid_expr_subtype(struct expression *expr)
+{
+	return valid_expr_type(expr->left)
+	    && valid_expr_type(expr->right);
+}
+
 static struct symbol *evaluate_symbol_expression(struct expression *expr)
 {
 	struct expression *addr;
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/5] allow to warn on all overlapping initializers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/5] allow to warn on all overlapping initializers
Date: Wed, 22 Feb 2017 15:30:04 +0000
Message-ID: <20170222153006.3035-4-luc.vanoostenryck () gmail ! com>
--------------------
By default, sparse only warns on the first overlapping initialier.

While this may be sensible for most situation, it's not always wanted
to hide those others errors. This is especially annoying when testing.

Change this by introducing a new warning flag '-Woverride-init-all',
disabled by default and whose intented use is sparse's testsuite.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expand.c                    |  3 ++-
 lib.c                       |  2 ++
 lib.h                       |  1 +
 validation/field-override.c | 34 +++++++++++++++++++++++++++++++++-
 4 files changed, 38 insertions(+), 2 deletions(-)

diff --git a/expand.c b/expand.c
index 7457c94dd..48cfa33d8 100644
--- a/expand.c
+++ b/expand.c
@@ -925,7 +925,8 @@ static void verify_nonoverlapping(struct expression_list **list)
 		if (a && bit_offset(a) == bit_offset(b)) {
 			warning(a->pos, "Initializer entry defined twice");
 			info(b->pos, "  also defined here");
-			return;
+			if (!Woverride_init_all)
+				return;
 		}
 		a = b;
 	} END_FOR_EACH_PTR(b);
diff --git a/lib.c b/lib.c
index a20f68aa2..b3b38a43f 100644
--- a/lib.c
+++ b/lib.c
@@ -232,6 +232,7 @@ int Wnon_pointer_null = 1;
 int Wold_initializer = 1;
 int Wone_bit_signed_bitfield = 1;
 int Woverride_init = 1;
+int Woverride_init_all = 0;
 int Wparen_string = 0;
 int Wptr_subtraction_blows = 0;
 int Wreturn_void = 0;
@@ -482,6 +483,7 @@ static const struct warning {
 	{ "old-initializer", &Wold_initializer },
 	{ "one-bit-signed-bitfield", &Wone_bit_signed_bitfield },
 	{ "override-init", &Woverride_init },
+	{ "override-init-all", &Woverride_init_all },
 	{ "paren-string", &Wparen_string },
 	{ "ptr-subtraction-blows", &Wptr_subtraction_blows },
 	{ "return-void", &Wreturn_void },
diff --git a/lib.h b/lib.h
index 35edd3217..265c5ec7f 100644
--- a/lib.h
+++ b/lib.h
@@ -118,6 +118,7 @@ extern int Wnon_pointer_null;
 extern int Wold_initializer;
 extern int Wone_bit_signed_bitfield;
 extern int Woverride_init;
+extern int Woverride_init_all;
 extern int Wparen_string;
 extern int Wptr_subtraction_blows;
 extern int Wreturn_void;
diff --git a/validation/field-override.c b/validation/field-override.c
index d5d00dfa8..cae30b4a2 100644
--- a/validation/field-override.c
+++ b/validation/field-override.c
@@ -68,21 +68,53 @@ static struct s b[2] = {
 
 /*
  * check-name: field-override
- * check-command: sparse -Woverride-init $file
+ * check-command: sparse -Woverride-init -Woverride-init-all $file
  * check-known-to-fail
  *
  * check-error-start
 field-override.c:2:10: warning: Initializer entry defined twice
 field-override.c:6:10:   also defined here
+field-override.c:3:10: warning: Initializer entry defined twice
+field-override.c:5:10:   also defined here
 field-override.c:14:10: warning: Initializer entry defined twice
 field-override.c:15:10:   also defined here
+field-override.c:14:10: warning: Initializer entry defined twice
+field-override.c:16:10:   also defined here
+field-override.c:14:10: warning: Initializer entry defined twice
+field-override.c:17:10:   also defined here
+field-override.c:14:10: warning: Initializer entry defined twice
+field-override.c:18:10:   also defined here
+field-override.c:14:10: warning: Initializer entry defined twice
+field-override.c:19:10:   also defined here
 field-override.c:23:10: warning: Initializer entry defined twice
 field-override.c:24:10:   also defined here
 field-override.c:23:10: warning: Initializer entry defined twice
 field-override.c:25:10:   also defined here
+field-override.c:23:10: warning: Initializer entry defined twice
+field-override.c:26:10:   also defined here
+field-override.c:26:10: warning: Initializer entry defined twice
+field-override.c:27:10:   also defined here
+field-override.c:26:10: warning: Initializer entry defined twice
+field-override.c:28:10:   also defined here
 field-override.c:34:10: warning: Initializer entry defined twice
 field-override.c:35:10:   also defined here
+field-override.c:34:10: warning: Initializer entry defined twice
+field-override.c:36:10:   also defined here
+field-override.c:34:10: warning: Initializer entry defined twice
+field-override.c:37:10:   also defined here
+field-override.c:34:10: warning: Initializer entry defined twice
+field-override.c:38:10:   also defined here
+field-override.c:34:10: warning: Initializer entry defined twice
+field-override.c:39:10:   also defined here
+field-override.c:34:10: warning: Initializer entry defined twice
+field-override.c:40:10:   also defined here
 field-override.c:62:10: warning: Initializer entry defined twice
 field-override.c:63:10:   also defined here
+field-override.c:62:10: warning: Initializer entry defined twice
+field-override.c:65:10:   also defined here
+field-override.c:62:10: warning: Initializer entry defined twice
+field-override.c:66:10:   also defined here
+field-override.c:62:10: warning: Initializer entry defined twice
+field-override.c:64:10:   also defined here
  * check-error-end
  */
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/5] avoid crash in rewrite_branch() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 3/5] avoid crash in rewrite_branch()
Date: Thu, 06 Jul 2017 19:19:48 +0000
Message-ID: <20170706191950.81268-4-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c                            |  2 +-
 validation/crash-rewrite-branch.c | 24 ++++++++++++++++++++++++
 2 files changed, 25 insertions(+), 1 deletion(-)
 create mode 100644 validation/crash-rewrite-branch.c

diff --git a/flow.c b/flow.c
index 3974984de..d8198ce8d 100644
--- a/flow.c
+++ b/flow.c
@@ -30,7 +30,7 @@ static int rewrite_branch(struct basic_block *bb,
 	struct basic_block *old,
 	struct basic_block *new)
 {
-	if (*ptr != old || new == old)
+	if (*ptr != old || new == old || !bb->ep)
 		return 0;
 
 	/* We might find new if-conversions or non-dominating CSEs */
diff --git a/validation/crash-rewrite-branch.c b/validation/crash-rewrite-branch.c
new file mode 100644
index 000000000..eb310df1c
--- /dev/null
+++ b/validation/crash-rewrite-branch.c
@@ -0,0 +1,24 @@
+void a(int c, int e)
+{
+	for(;                   b; c ;
+
+	if (()) {
+		unsigned short d = e;
+		if (())
+			while ()
+				;
+		&d;
+	}
+
+	if (()) {
+		int f = &f;
+	}
+}
+
+/*
+ * check-name: crash rewrite_branch
+ * check-command: test-linearize $file
+ *
+ * check-error-ignore
+ * check-output-ignore
+ */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 3/5] avoid crash in rewrite_branch()
Date: Wed, 19 Jul 2017 22:21:35 +0000
Message-ID: <20170719222132.jixz37orrmfwkobq () ltop ! local>
--------------------
This patch fixes a reproducible crash and have been ignored
since it has been posted two weeks ago.
Is there any reasons why?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 3/6] build: drop BASIC_CFLAGS and ALL_CFLAGS ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH 3/6] build: drop BASIC_CFLAGS and ALL_CFLAGS
Date: Wed, 04 Oct 2017 13:26:02 +0000
Message-ID: <20171004132605.24734-4-uwe () kleine-koenig ! org>
--------------------
There is no good reason to not use plain CFLAGS for all usages.
This simplifies understanding the Makefile for the casual reader.

Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
 Makefile | 16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/Makefile b/Makefile
index ddb4c5e3de02..069dae6c8fdb 100644
--- a/Makefile
+++ b/Makefile
@@ -21,8 +21,6 @@ PKG_CONFIG = pkg-config
 CHECKER = ./cgcc -no-compile
 CHECKER_FLAGS =
 
-ALL_CFLAGS = $(CFLAGS) $(BASIC_CFLAGS)
-
 HAVE_LIBXML:=$(shell $(PKG_CONFIG) --exists libxml-2.0 2>/dev/null && echo 'yes')
 HAVE_GCC_DEP:=$(shell touch .gcc-test.c && 				\
 		$(CC) -c -Wp,-MD,.gcc-test.d .gcc-test.c 2>/dev/null && \
@@ -39,13 +37,13 @@ LLVM_CONFIG:=llvm-config
 HAVE_LLVM:=$(shell $(LLVM_CONFIG) --version >/dev/null 2>&1 && echo 'yes')
 
 GCC_BASE := $(shell $(CC) --print-file-name=)
-BASIC_CFLAGS = -DGCC_BASE=\"$(GCC_BASE)\"
+CFLAGS += -DGCC_BASE=\"$(GCC_BASE)\"
 
 MULTIARCH_TRIPLET := $(shell $(CC) -print-multiarch 2>/dev/null)
-BASIC_CFLAGS += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"
+CFLAGS += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"
 
 ifeq ($(HAVE_GCC_DEP),yes)
-BASIC_CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
+CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
 endif
 
 DESTDIR=
@@ -96,7 +94,7 @@ LLVM_LIBS := $(shell $(LLVM_CONFIG) --libs)
 LLVM_LIBS += $(shell $(LLVM_CONFIG) --system-libs 2>/dev/null)
 PROGRAMS += $(LLVM_PROGS)
 INST_PROGRAMS += sparse-llvm sparsec
-sparse-llvm.o: BASIC_CFLAGS += $(LLVM_CFLAGS)
+sparse-llvm.o: CFLAGS += $(LLVM_CFLAGS)
 sparse-llvm_EXTRA_OBJS := $(LLVM_LIBS) $(LLVM_LDFLAGS)
 else
 $(warning LLVM 3.0 or later required. Your system has version $(LLVM_VERSION) installed.)
@@ -122,7 +120,7 @@ LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
 
-# If you add $(SLIB_FILE) to this, you also need to add -fpic to BASIC_CFLAGS above.
+# If you add $(SLIB_FILE) to this, you also need to add -fpic to CFLAGS above.
 # Doing so incurs a noticeable performance hit, and Sparse does not have a
 # stable shared library interface, so this does not occur by default.  If you
 # really want a shared library, you may want to build Sparse twice: once
@@ -212,10 +210,10 @@ c2xml.o c2xml.sc: CFLAGS += $(LIBXML_CFLAGS)
 pre-process.sc: CHECKER_FLAGS += -Wno-vla
 
 %.o: %.c $(LIB_H)
-	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $<
+	$(QUIET_CC)$(CC) -o $@ -c $(CFLAGS) $<
 
 %.sc: %.c sparse
-	$(QUIET_CHECK) $(CHECKER) $(CHECKER_FLAGS) -c $(ALL_CFLAGS) $<
+	$(QUIET_CHECK) $(CHECKER) $(CHECKER_FLAGS) -c $(CFLAGS) $<
 
 ALL_OBJS :=  $(LIB_OBJS) $(foreach p,$(PROGRAMS),$(p).o $($(p)_EXTRA_DEPS))
 selfcheck: $(ALL_OBJS:.o=.sc)
-- 
2.14.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 3/6] build: drop BASIC_CFLAGS and ALL_CFLAGS
Date: Fri, 06 Oct 2017 19:09:23 +0000
Message-ID: <CANeU7QmRzBJde5t4_tJ6pog3uAz8aP34NX6ozZnno638w_Ahug () mail ! gmail ! com>
--------------------
On Wed, Oct 4, 2017 at 6:26 AM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.or=
g> wrote:
> There is no good reason to not use plain CFLAGS for all usages.
> This simplifies understanding the Makefile for the casual reader.

Have more fine grain variable allow partial overwrite some
part of the CFLAG in some specific locations. For example
some flags have order over other flags etc.

I don't see a strong reason to change it. The change did not gain
any function.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/4] CSE: improve hashing of non-commutative binops ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/4] CSE: improve hashing of non-commutative binops
Date: Thu, 16 Feb 2017 23:12:31 +0000
Message-ID: <20170216231231.5781-5-luc.vanoostenryck () gmail ! com>
--------------------
During CSE equivalent instructions should hash to the same value
but we should also try to *not* hash to the same value instructions
that cannot be equivalent.
For commutative ops this means that the hash function should itself
be commutative/symmetrical regarding the exchange of its operands.
This is already the case but the current hash function is symmetrical
for all binops, not only the commutative ones. Thus expressions like
'a - b' and 'b - a' hash to the same value while it should be the case
only when 'a == b'.

Fix this by changing the hashing of non-commutative binops so that it
is anti-symmetrical regarding the exchange of operands while keeping
commutative ones symmetrical.

This change have no functional effects (in the sense that it shoudl
CSE exactly the same instructiosn as before), it should only improve
the efficiency of the hashing+comparing.

Note: on the 5000+ test set I'm using, I can't see any significant
  speedup which is quite normal since most of the functions therein
  have (much) less instructions than the size of the hash table.
  The effect of this patch should only be on much bigger functions.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 cse.c | 26 ++++++++++++++------------
 1 file changed, 14 insertions(+), 12 deletions(-)

diff --git a/cse.c b/cse.c
index 0d3815c5a..89812afae 100644
--- a/cse.c
+++ b/cse.c
@@ -51,28 +51,30 @@ static void clean_up_one_instruction(struct basic_block *bb, struct instruction
 		hash += hashval(insn->src3);
 		/* Fall through */	
 
-	/* Binary arithmetic */
-	case OP_ADD: case OP_SUB:
-	case OP_MULU: case OP_MULS:
+	/* non-commutative binops */
+	case OP_SUB:
 	case OP_DIVU: case OP_DIVS:
 	case OP_MODU: case OP_MODS:
 	case OP_SHL:
 	case OP_LSR: case OP_ASR:
-	case OP_AND: case OP_OR:
-
-	/* Binary logical */
-	case OP_XOR: case OP_AND_BOOL:
-	case OP_OR_BOOL:
-
-	/* Binary comparison */
-	case OP_SET_EQ: case OP_SET_NE:
 	case OP_SET_LE: case OP_SET_GE:
 	case OP_SET_LT: case OP_SET_GT:
 	case OP_SET_B:  case OP_SET_A:
 	case OP_SET_BE: case OP_SET_AE:
+		hash -= hashval(insn->src2);
+		hash += hashval(insn->src1);
+		break;
+
+	/* commutative binops */
+	case OP_SET_EQ: case OP_SET_NE:
+	case OP_ADD:
+	case OP_MULU: case OP_MULS:
+	case OP_AND_BOOL: case OP_OR_BOOL:
+	case OP_AND: case OP_OR:
+	case OP_XOR:
 		hash += hashval(insn->src2);
 		/* Fall through */
-	
+
 	/* Unary */
 	case OP_NOT: case OP_NEG:
 		hash += hashval(insn->src1);
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 4/4] CSE: improve hashing of non-commutative binops
Date: Thu, 23 Feb 2017 12:39:17 +0000
Message-ID: <CANeU7Q=2un=p62S5ToDt8djfhDLVtv=mgYoAcuOFGTQ9D_P+7w () mail ! gmail ! com>
--------------------
On Fri, Feb 17, 2017 at 7:12 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> During CSE equivalent instructions should hash to the same value
> but we should also try to *not* hash to the same value instructions
> that cannot be equivalent.
> For commutative ops this means that the hash function should itself
> be commutative/symmetrical regarding the exchange of its operands.
> This is already the case but the current hash function is symmetrical
> for all binops, not only the commutative ones. Thus expressions like
> 'a - b' and 'b - a' hash to the same value while it should be the case
> only when 'a == b'.
>
> Fix this by changing the hashing of non-commutative binops so that it
> is anti-symmetrical regarding the exchange of operands while keeping
> commutative ones symmetrical.
>
> This change have no functional effects (in the sense that it shoudl
> CSE exactly the same instructiosn as before), it should only improve
> the efficiency of the hashing+comparing.
>
> Note: on the 5000+ test set I'm using, I can't see any significant
>   speedup which is quite normal since most of the functions therein
>   have (much) less instructions than the size of the hash table.
>   The effect of this patch should only be on much bigger functions.

I apply and push this series to sparse-next.

Just curious if there is test case can show the performance increase.
As far as I can tell, this patch has down side as well, it hash the non
commutative operation *twice*. If for most of the case this actually
is the higher cost we might want to keep the old behavior.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 4/4] CSE: improve hashing of non-commutative binops
Date: Thu, 23 Feb 2017 14:13:14 +0000
Message-ID: <20170223141313.o2vdjzv5y3c4lo5f () macpro ! local>
--------------------
On Thu, Feb 23, 2017 at 08:39:17PM +0800, Christopher Li wrote:
> On Fri, Feb 17, 2017 at 7:12 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > During CSE equivalent instructions should hash to the same value
> > but we should also try to *not* hash to the same value instructions
> > that cannot be equivalent.
> > For commutative ops this means that the hash function should itself
> > be commutative/symmetrical regarding the exchange of its operands.
> > This is already the case but the current hash function is symmetrical
> > for all binops, not only the commutative ones. Thus expressions like
> > 'a - b' and 'b - a' hash to the same value while it should be the case
> > only when 'a == b'.
> >
> > Fix this by changing the hashing of non-commutative binops so that it
> > is anti-symmetrical regarding the exchange of operands while keeping
> > commutative ones symmetrical.
> >
> > This change have no functional effects (in the sense that it shoudl
> > CSE exactly the same instructiosn as before), it should only improve
> > the efficiency of the hashing+comparing.
> >
> > Note: on the 5000+ test set I'm using, I can't see any significant
> >   speedup which is quite normal since most of the functions therein
> >   have (much) less instructions than the size of the hash table.
> >   The effect of this patch should only be on much bigger functions.
> 
> I apply and push this series to sparse-next.
I don't see them yet, but it's not important.

> Just curious if there is test case can show the performance increase.
I don't have such test case. To see any effect you would need a
function with a number of instructions quite large relatively to
the size of the hash table. It's even worse than that, it's the
number of pair of dual instructions (like 'a - b' / 'b - a') that
should be large (and to see a significant relative difference,
those pairs should also be a significant proportion of the total
numbers of instructions).

If needed I could try to build some artificial cases to determine
when a difference appears but ... (see below).

> As far as I can tell, this patch has down side as well, it hash the non
> commutative operation *twice*.
Sure it has some down fall but I it's not true that they are now
hashed twice. The number of operations is exactly the same as for
the commutative ones: each of src1 & src2 are 'hashed' together with
the opcode and the instruction size (and the hash() function is
essentially a no-op, not a costly thing anyway). The difference
between the two cases is that for commutative instructions src2
is first hashed and then there is a fall-through to the unary ops
to add src1's hash.
The down side is only a slight increase in code complexity.

> If for most of the case this actually
> is the higher cost we might want to keep the old behavior.
I can redo my tests and give the numbers but the measurements
I made didn't didn't showed any significant differences:
no speedup but also no slowdown.


That said, I completly agree that there is not much justification
to this patch. The only reason I made it was because when I modified
the code for the commutative case (which don't give a speedup but
eliminate more common expression) I took a look at the non-commutative
situation and said to myself something like: "Oh, they are hashed
symmetrically, like the commutative ones, that's not very logical".

So, I have absolutely no problems if this patch is dropped.
(much more interesting is the patch following this in the serie:
 "[RFC] CSE: relax type checking in hashing/compare").

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 4/4] CSE: improve hashing of non-commutative binops
Date: Thu, 23 Feb 2017 15:03:52 +0000
Message-ID: <20170223150351.ebdi473jxbm4nkgt () macpro ! local>
--------------------
On Thu, Feb 23, 2017 at 03:13:14PM +0100, Luc Van Oostenryck wrote:
> 
> So, I have absolutely no problems if this patch is dropped.

After some more thoughts I'm convinced that this patch was
a bad idea, please drop it.

The rationale being that even if there is a lot of pair of
dual instructions ('Xi - Yi' / 'Yi - Xi'), their hashing
will still be spreaded relatively evenly because there
will be a lot of Xi & Yi but with the patch *every*
instruction like 'Xi - Xi' will give the same hash
indenpendently of the Xi.

Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 4/4] CSE: improve hashing of non-commutative binops
Date: Mon, 27 Feb 2017 08:03:13 +0000
Message-ID: <CANeU7QkO40CHEzFft=8aK5CtW+DSxDJPc-XJjESzJLy2Te01zw () mail ! gmail ! com>
--------------------
On Thu, Feb 23, 2017 at 11:03 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Feb 23, 2017 at 03:13:14PM +0100, Luc Van Oostenryck wrote:
>>
>> So, I have absolutely no problems if this patch is dropped.
>
> After some more thoughts I'm convinced that this patch was
> a bad idea, please drop it.

OK. Patch dropped in the current sparse-next.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] add a method to external_declaration() ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 4/5] add a method to external_declaration()
Date: Mon, 27 Feb 2017 15:37:09 +0000
Message-ID: <CANeU7Q=X66U4F1nGTdNH1q+mNF=JU9s8z=we0Gbpep4F6X-vgA () mail ! gmail ! com>
--------------------
On Sun, Feb 19, 2017 at 4:30 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> After parsing and validation, the symbols in the declaration
> are added to the list given in argument, *if* they are not extern
> symbols. The symbols that are extern are them not added to the list.
>
> This is what is needed for usual declarations but ignoring extern
> symbols make it impossible to emit a diagnostic in less usual
> situation.

I have other situation want to use this as well.

> --- a/parse.h
> +++ b/parse.h
> @@ -129,7 +129,8 @@ extern int show_statement(struct statement *);
>  extern void show_statement_list(struct statement_list *, const char *);
>  extern int show_expression(struct expression *);
>
> -extern struct token *external_declaration(struct token *token, struct symbol_list **list);
> +typedef void (*add_decl_t)(struct symbol_list **list, struct symbol *decl);
> +extern struct token *external_declaration(struct token *token, add_decl_t add_decl, struct symbol_list **list);
>

I think the logic should be, "external_declaration" accept token as input.
For each newly declared symbol, it call to the callbacks function
to receive the symbol. The receive behavior is depend on the callback
function. The default function can be adding the symbol to a list.

So the struct symbol_list **list should turn into transparent argument as
context for the call back.

> --- a/lib.c
> +++ b/lib.c
> @@ -1080,7 +1080,7 @@ static struct symbol_list *sparse_tokenstream(struct token *token)
>
>         // Parse the resulting C code
>         while (!eof_token(token))
> -               token = external_declaration(token, &translation_unit_used_list);
> +               token = external_declaration(token, NULL, &translation_unit_used_list);

I prefer here just provide the default call back which is
add_stmt_decl in your case.

>         return translation_unit_used_list;
>  }
>
> diff --git a/parse.c b/parse.c
> index a4a126720..866186fd2 100644
> --- a/parse.c
> +++ b/parse.c
> @@ -2230,7 +2230,7 @@ static struct token *parse_for_statement(struct token *token, struct statement *
>         e1 = NULL;
>         /* C99 variable declaration? */
>         if (lookup_type(token)) {
> -               token = external_declaration(token, &syms);
> +               token = external_declaration(token, NULL, &syms);

Same here.


>         } else {
>                 token = parse_expression(token, &e1);
>                 token = expect(token, ';', "in 'for'");
> @@ -2457,7 +2457,7 @@ static struct token * statement_list(struct token *token, struct statement_list
>                                 seen_statement = 0;
>                         }
>                         stmt = alloc_statement(token->pos, STMT_DECLARATION);
> -                       token = external_declaration(token, &stmt->declaration);
> +                       token = external_declaration(token, NULL, &stmt->declaration);

And here.

> +       if (!add_decl)
> +               add_decl = add_stmt_decl;
> +

We don't need this if we ask the caller to provide the call back.


>         for (;;) {
>                 if (!is_typedef && match_op(token, '=')) {
>                         if (decl->ctype.modifiers & MOD_EXTERN) {
> @@ -2873,10 +2884,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
>                         token = initializer(&decl->initializer, token->next);
>                 }
>                 if (!is_typedef) {
> -                       if (!(decl->ctype.modifiers & (MOD_EXTERN | MOD_INLINE))) {
> -                               add_symbol(list, decl);
> -                               fn_local_symbol(decl);
> -                       }
> +                       add_decl(list, decl);
change this to some thing like:

if (add_decl)
                   add_decl(decl, decl_args);


>                 }
>                 check_declaration(decl);
>                 if (decl->same_symbol) {


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 4/5] add a method to external_declaration()
Date: Mon, 27 Feb 2017 21:34:43 +0000
Message-ID: <CAExDi1Td-ygRZNqRi=1NOhD43QA1pTQGB9Bo4K3aRKvKgEOOaQ () mail ! gmail ! com>
--------------------
On Mon, Feb 27, 2017 at 4:37 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Sun, Feb 19, 2017 at 4:30 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> After parsing and validation, the symbols in the declaration
>> are added to the list given in argument, *if* they are not extern
>> symbols. The symbols that are extern are them not added to the list.
>>
>> This is what is needed for usual declarations but ignoring extern
>> symbols make it impossible to emit a diagnostic in less usual
>> situation.
>
> I have other situation want to use this as well.
>
>> --- a/parse.h
>> +++ b/parse.h
>> @@ -129,7 +129,8 @@ extern int show_statement(struct statement *);
>>  extern void show_statement_list(struct statement_list *, const char *);
>>  extern int show_expression(struct expression *);
>>
>> -extern struct token *external_declaration(struct token *token, struct symbol_list **list);
>> +typedef void (*add_decl_t)(struct symbol_list **list, struct symbol *decl);
>> +extern struct token *external_declaration(struct token *token, add_decl_t add_decl, struct symbol_list **list);
>>
>
> I think the logic should be, "external_declaration" accept token as input.
> For each newly declared symbol, it call to the callbacks function
> to receive the symbol. The receive behavior is depend on the callback
> function. The default function can be adding the symbol to a list.
>
> So the struct symbol_list **list should turn into transparent argument as
> context for the call back.

Yes, it can certainly be more general.

By 'transparent' you mean a void pointer?

For the two case currently concerned the callback argument can be a
statement pointer
because the two symbol list belong to a statement and I fact I
hesitated to use it or the list.
I choose the smallest change.

If for the other situation you talked here above, we can also use a
statement pointer,
I would prefrer to do so instead than using a void pointer but well it
doesn't matter much
anyway.


>> --- a/lib.c
>> +++ b/lib.c
>> @@ -1080,7 +1080,7 @@ static struct symbol_list *sparse_tokenstream(struct token *token)
>>
>>         // Parse the resulting C code
>>         while (!eof_token(token))
>> -               token = external_declaration(token, &translation_unit_used_list);
>> +               token = external_declaration(token, NULL, &translation_unit_used_list);
>
> I prefer here just provide the default call back which is
> add_stmt_decl in your case.

Sure, I can do this.


Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 4/5] add a method to external_declaration()
Date: Tue, 28 Feb 2017 09:46:36 +0000
Message-ID: <20170228094635.qbod5dwqwrw6etvt () macbook ! local>
--------------------
On Mon, Feb 27, 2017 at 11:37:09PM +0800, Christopher Li wrote:
> On Sun, Feb 19, 2017 at 4:30 AM, Luc Van Oostenryck wrote:
> >
> > This is what is needed for usual declarations but ignoring extern
> > symbols make it impossible to emit a diagnostic in less usual
> > situation.
> 
> I have other situation want to use this as well.

...

> So the struct symbol_list **list should turn into transparent argument as
> context for the call back.
> 

...

> I prefer here just provide the default call back which is
> add_stmt_decl in your case.

OK. I've made the changes related to this and also prepared
for something more generic (like the name of the method).

I've left the arg type as 'symbol_list **' for the moment though,
it will be easy enough to change when/if needed.

Luc 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] avoid some crashes in add_dominators() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/5] avoid some crashes in add_dominators()
Date: Thu, 06 Jul 2017 19:19:49 +0000
Message-ID: <20170706191950.81268-5-luc.vanoostenryck () gmail ! com>
--------------------
---
 memops.c                    |  2 ++
 validation/crash-add-doms.c | 22 ++++++++++++++++++++++
 2 files changed, 24 insertions(+)
 create mode 100644 validation/crash-add-doms.c

diff --git a/memops.c b/memops.c
index 5efdd6f2d..aeacdf566 100644
--- a/memops.c
+++ b/memops.c
@@ -29,6 +29,8 @@ static int find_dominating_parents(pseudo_t pseudo, struct instruction *insn,
 
 		FOR_EACH_PTR_REVERSE(parent->insns, one) {
 			int dominance;
+			if (!one->bb)
+				continue;
 			if (one == insn)
 				goto no_dominance;
 			dominance = dominates(pseudo, insn, one, local);
diff --git a/validation/crash-add-doms.c b/validation/crash-add-doms.c
new file mode 100644
index 000000000..54ad93e84
--- /dev/null
+++ b/validation/crash-add-doms.c
@@ -0,0 +1,22 @@
+char a;
+int b;
+void c(void)
+{
+	if (0) {
+		char *d;
+		for (;;)
+			for (;;)
+e:
+				*d *= (a && 0) ^ b && *d;
+	}
+	goto e;
+}
+
+
+/*
+ * check-name: crash add-doms
+ * check-command: test-linearize $file
+ *
+ * check-error-ignore
+ * check-output-ignore
+ */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 4/5] avoid some crashes in add_dominators()
Date: Wed, 19 Jul 2017 22:22:51 +0000
Message-ID: <20170719222249.7drqmufjxcpazkx3 () ltop ! local>
--------------------
This patch fixes a reproducible crash and have been ignored
since it has been posted two weeks ago.
Is there any reasons why?

BTW, I had forgot the SoB. Here it is:

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] do not report bad types twice or more ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/5] do not report bad types twice or more
Date: Tue, 19 Sep 2017 02:13:34 +0000
Message-ID: <20170919021335.5881-5-luc.vanoostenryck () gmail ! com>
--------------------
The type 'bad_ctype' is only used after an error has been detected.
Since this error has also been reported, there is no reasons
to issue more errors when a 'bad_ctype' is involved. This allow
to focus on the root cause of the error.

Fix this by checking in bad_expr_type() if one of the operands
is already a 'bad_ctype' and do not issue an diagnostic message
in this case.

Note: the kernel has a bunch of these situation where sometimes
      the exact same warning is given several times in a row,
      sometimes as much as a dozen time.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/evaluate.c b/evaluate.c
index 0394dcbb9..c16ee9624 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -400,15 +400,20 @@ static inline int is_string_type(struct symbol *type)
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	sparse_error(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
+		if (!valid_expr_subtype(expr))
+			break;
+		sparse_error(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 		info(expr->pos, "   left side has type %s", show_typename(expr->left->ctype));
 		info(expr->pos, "   right side has type %s", show_typename(expr->right->ctype));
 		break;
 	case EXPR_PREOP:
 	case EXPR_POSTOP:
+		if (!valid_type(expr->unop->ctype))
+			break;
+		sparse_error(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 		info(expr->pos, "   argument has type %s", show_typename(expr->unop->ctype));
 		break;
 	default:
@@ -887,6 +892,8 @@ static struct symbol *evaluate_conditional(struct expression *expr, int iterator
 			if (Waddress)
 				warning(expr->pos, "the address of %s will always evaluate as true", "an array");
 		} else if (!is_scalar_type(ctype)) {
+			if (!valid_type(ctype))
+				return NULL;
 			sparse_error(expr->pos, "incorrect type in conditional");
 			info(expr->pos, "   got %s", show_typename(ctype));
 			ctype = NULL;
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] fix checking of overlapping initializer ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/5] fix checking of overlapping initializer
Date: Wed, 22 Feb 2017 15:30:05 +0000
Message-ID: <20170222153006.3035-5-luc.vanoostenryck () gmail ! com>
--------------------
The current routine checking if some initializers overlap with each
others only check the offset of the initialierd fields, not taking
in account that array elements can be initialized by range with the
'[a ... b]' notation.

Fix this by changing the check so that now we compare the offset of
the current field with the end of the previous one.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expand.c                    | 25 +++++++++++++++++++++++--
 validation/field-override.c |  1 -
 2 files changed, 23 insertions(+), 3 deletions(-)

diff --git a/expand.c b/expand.c
index 48cfa33d8..80699c4d6 100644
--- a/expand.c
+++ b/expand.c
@@ -896,6 +896,20 @@ static unsigned long bit_offset(const struct expression *expr)
 	return offset;
 }
 
+static unsigned long bit_range(const struct expression *expr)
+{
+	unsigned long range = 0;
+	unsigned long size = 0;
+	while (expr->type == EXPR_POS) {
+		unsigned long nr = expr->init_nr;
+		size = expr->ctype->bit_size;
+		range += (nr - 1) * size;
+		expr = expr->init_expr;
+	}
+	range += size;
+	return range;
+}
+
 static int compare_expressions(const void *_a, const void *_b)
 {
 	const struct expression *a = _a;
@@ -914,21 +928,28 @@ static void sort_expression_list(struct expression_list **list)
 static void verify_nonoverlapping(struct expression_list **list)
 {
 	struct expression *a = NULL;
+	unsigned long max = 0;
 	struct expression *b;
 
 	if (!Woverride_init)
 		return;
 
 	FOR_EACH_PTR(*list, b) {
+		unsigned long off, end;
 		if (!b->ctype || !b->ctype->bit_size)
 			continue;
-		if (a && bit_offset(a) == bit_offset(b)) {
+		off = bit_offset(b);
+		if (a && off < max) {
 			warning(a->pos, "Initializer entry defined twice");
 			info(b->pos, "  also defined here");
 			if (!Woverride_init_all)
 				return;
 		}
-		a = b;
+		end = off + bit_range(b);
+		if (end > max) {
+			max = end;
+			a = b;
+		}
 	} END_FOR_EACH_PTR(b);
 }
 
diff --git a/validation/field-override.c b/validation/field-override.c
index cae30b4a2..5b77af73e 100644
--- a/validation/field-override.c
+++ b/validation/field-override.c
@@ -69,7 +69,6 @@ static struct s b[2] = {
 /*
  * check-name: field-override
  * check-command: sparse -Woverride-init -Woverride-init-all $file
- * check-known-to-fail
  *
  * check-error-start
 field-override.c:2:10: warning: Initializer entry defined twice
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/5] testsuite: allow quieter error reporting ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/5] testsuite: allow quieter error reporting
Date: Thu, 05 Jan 2017 05:16:31 +0000
Message-ID: <20170105051632.8392-5-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/validation/test-suite b/validation/test-suite
index fdb7cbc2..47015c61 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -126,7 +126,7 @@ verbose()
 # error(string[, die]) - prints an error and exits with value die if given
 error()
 {
-	echo "error: $1"
+	[ "$quiet" -ne 1 ] && echo "error: $1"
 	[ -n "$2" ] && exit $2
 	return 0
 }
@@ -223,7 +223,7 @@ do_test()
 		if [ "$?" -ne "0" ]; then
 			error "actual $stream text does not match expected $stream text."
 			error  "see $file.$stream.* for further investigation."
-			cat "$file".$stream.diff
+			[ $quiet -ne 1 ] && cat "$file".$stream.diff
 			test_failed=1
 		fi
 	done
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/6] build: drop -g from LDFLAGS ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH 4/6] build: drop -g from LDFLAGS
Date: Wed, 04 Oct 2017 13:26:03 +0000
Message-ID: <20171004132605.24734-5-uwe () kleine-koenig ! org>
--------------------
-g is a compiler option that is ignored by the linker. So it should be
included in CFLAGS (it already is) but not LDFLAGS.

Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
 Makefile | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Makefile b/Makefile
index 069dae6c8fdb..39b34f90107d 100644
--- a/Makefile
+++ b/Makefile
@@ -14,7 +14,6 @@ OS = linux
 CC = gcc
 CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
 CFLAGS += -Wall -Wwrite-strings
-LDFLAGS += -g
 LD = gcc
 AR = ar
 PKG_CONFIG = pkg-config
-- 
2.14.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 4/6] build: drop -g from LDFLAGS
Date: Fri, 06 Oct 2017 19:14:38 +0000
Message-ID: <CANeU7QmRedShU-++=NORJBm+rPetnQFfeQ3-K5=dnXb4MMMkWQ () mail ! gmail ! com>
--------------------
On Wed, Oct 4, 2017 at 6:26 AM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.or=
g> wrote:
> -g is a compiler option that is ignored by the linker. So it should be
> included in CFLAGS (it already is) but not LDFLAGS.

Our linker "LD =3D gcc" so it might have impact on gcc as the finial
linking program?
I am actually not sure, I can be wrong.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/6] generate plain OP_{AND,OR} instead of OP_{AND,OR}_BOOL ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/6] generate plain OP_{AND,OR} instead of OP_{AND,OR}_BOOL
Date: Wed, 12 Apr 2017 19:33:42 +0000
Message-ID: <20170412193344.95935-5-luc.vanoostenryck () gmail ! com>
--------------------
Now that OP_AND_BOOL and OP_OR_BOOL are always given boolean
operands, they are just a special case of 1 bit OP_AND & OP_OR.

To avoid to have to repeat CSE, simplification patterns, ...
better to simply generate OP_AND & OP_OR instructions instead.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c                        |  2 +-
 validation/optim/bool-context-fp.c |  8 ++++----
 validation/optim/bool-simplify.c   | 24 ++++++++++++++++++++++++
 3 files changed, 29 insertions(+), 5 deletions(-)

diff --git a/linearize.c b/linearize.c
index e730ab56f..e6b77ec01 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1379,7 +1379,7 @@ static pseudo_t linearize_call_expression(struct entrypoint *ep, struct expressi
 static pseudo_t linearize_binop_bool(struct entrypoint *ep, struct expression *expr)
 {
 	pseudo_t src1, src2, dst;
-	int op = (expr->op == SPECIAL_LOGICAL_OR) ? OP_OR_BOOL : OP_AND_BOOL;
+	int op = (expr->op == SPECIAL_LOGICAL_OR) ? OP_OR : OP_AND;
 
 	src1 = linearize_expression_to_bool(ep, expr->left);
 	src2 = linearize_expression_to_bool(ep, expr->right);
diff --git a/validation/optim/bool-context-fp.c b/validation/optim/bool-context-fp.c
index 2f15fe94d..3ce1574b9 100644
--- a/validation/optim/bool-context-fp.c
+++ b/validation/optim/bool-context-fp.c
@@ -53,7 +53,7 @@ bfior:
 	setfval.32  %r19 <- 0.000000
 	fcmpune.1   %r20 <- %arg1, %r19
 	fcmpune.1   %r23 <- %arg2, %r19
-	or-bool.1   %r24 <- %r23, %r20
+	or.1        %r24 <- %r23, %r20
 	ret.1       %r24
 
 
@@ -63,7 +63,7 @@ ifior:
 	setfval.32  %r29 <- 0.000000
 	fcmpune.1   %r30 <- %arg1, %r29
 	fcmpune.1   %r33 <- %arg2, %r29
-	or-bool.1   %r34 <- %r33, %r30
+	or.1        %r34 <- %r33, %r30
 	cast.32     %r35 <- (1) %r34
 	ret.32      %r35
 
@@ -74,7 +74,7 @@ bfand:
 	setfval.32  %r38 <- 0.000000
 	fcmpune.1   %r39 <- %arg1, %r38
 	fcmpune.1   %r42 <- %arg2, %r38
-	and-bool.1  %r43 <- %r42, %r39
+	and.1       %r43 <- %r42, %r39
 	ret.1       %r43
 
 
@@ -84,7 +84,7 @@ ifand:
 	setfval.32  %r48 <- 0.000000
 	fcmpune.1   %r49 <- %arg1, %r48
 	fcmpune.1   %r52 <- %arg2, %r48
-	and-bool.1  %r53 <- %r52, %r49
+	and.1       %r53 <- %r52, %r49
 	cast.32     %r54 <- (1) %r53
 	ret.32      %r54
 
diff --git a/validation/optim/bool-simplify.c b/validation/optim/bool-simplify.c
index 2014d344c..b872764ca 100644
--- a/validation/optim/bool-simplify.c
+++ b/validation/optim/bool-simplify.c
@@ -18,6 +18,17 @@ int or_1(int a)
 	return a || 1;
 }
 
+// try again but with something true but != 1
+int and_2(int a)
+{
+	return a && 2;
+}
+
+int or_2(int a)
+{
+	return a || 2;
+}
+
 /*
  * check-name: bool-simplify
  * check-command: test-linearize -Wno-decl $file
@@ -49,5 +60,18 @@ or_1:
 	ret.32      $1
 
 
+and_2:
+.L8:
+	<entry-point>
+	setne.32    %r29 <- %arg1, $0
+	ret.32      %r29
+
+
+or_2:
+.L10:
+	<entry-point>
+	ret.32      $1
+
+
  * check-output-end
  */
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/6] testsuite: use shell arithmetic instead of fork-execing expr ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/6] testsuite: use shell arithmetic instead of fork-execing expr
Date: Sun, 28 May 2017 19:29:04 +0000
Message-ID: <20170528192906.1023-5-luc.vanoostenryck () gmail ! com>
--------------------
The tessuite use a few counters to keep track of things.
These counters are incremented via the 'expr' command.

But this command is not a shell builtin and need thus
to be fork+execed which need more CPU ressources than
using some builtin operation.

Change this by doing all the arithmetic via the portable
'$(( ... ))' shell builtin.

This speedup the testsuite by another 10%.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/validation/test-suite b/validation/test-suite
index e33d97804..da9d88159 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -180,7 +180,7 @@ do_test()
 	# (it has to have a check-name key in it)
 	if [ "$check_name" = "" ]; then
 		echo "warning: test '$file' unhandled"
-		unhandled_tests=`expr $unhandled_tests + 1`
+		unhandled_tests=$(($unhandled_tests + 1))
 		return 2
 	fi
 	test_name="$check_name"
@@ -196,7 +196,7 @@ do_test()
 	base_cmd=`basename $1`
 	for i in $disabled_cmds; do
 		if [ "$i" = "$base_cmd" ] ; then
-			disabled_tests=`expr $disabled_tests + 1`
+			disabled_tests=$(($disabled_tests + 1))
 			echo "     DISABLE $test_name ($file)"
 			return 3
 		fi
@@ -218,7 +218,7 @@ do_test()
 	must_fail=$check_known_to_fail
 	quiet=0
 	[ $must_fail -eq 1 ] && [ $V -eq 0 ] && quiet=1
-	known_ko_tests=`expr $known_ko_tests + $must_fail`
+	known_ko_tests=$(($known_ko_tests + $must_fail))
 
 	for stream in output error; do
 		eval ignore=\$check_${stream}_ignore
@@ -279,9 +279,9 @@ do_test()
 	fi
 
 	if [ "$test_failed" -eq "1" ]; then
-		ko_tests=`expr $ko_tests + 1`
+		ko_tests=$(($ko_tests + 1))
 	else
-		ok_tests=`expr $ok_tests + 1`
+		ok_tests=$(($ok_tests + 1))
 		rm -f $file.{error,output}.{expected,got,diff}
 	fi
 	return $test_failed
@@ -294,7 +294,7 @@ do_test_suite()
 	done
 
 	# prints some numbers
-	tests_nr=`expr $ok_tests + $ko_tests`
+	tests_nr=$(($ok_tests + $ko_tests))
 	echo -n "Out of $tests_nr tests, $ok_tests passed, $ko_tests failed"
 	echo " ($known_ko_tests of them are known to fail)"
 	if [ "$unhandled_tests" -ne "0" ]; then
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/8] avoid phisrc orphaned by simplify_loads() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/8] avoid phisrc orphaned by simplify_loads()
Date: Thu, 13 Apr 2017 16:55:47 +0000
Message-ID: <20170413165551.2785-5-luc.vanoostenryck () gmail ! com>
--------------------
simplify_loads() calls find_dominating_parents() which can
add an OP_PHISRC in each BB it visits and the corresponding
%phi are collected in a list.
Then, depending on find_dominating_parents()'s returned
value, either an OP_PHI is created with this list as phi_list,
or no such OP_PHI is created and the phi_list is discarded.
In the later case, the added OP_PHISRCs are of no use but are
left there nevertheless.

These orphaned OP_PHISRCs can only bring confusion later.
It seems also (but I can't strictly confirm this) that this can
sometimes happen at each CSE-simplification cycle, creating one
more such OP_PHISRC at each cycle, into each concerned BB.
Not good.

Change this by not creating these OP_PHISRC but instead just
collecting their source pseudo. And then only created them
together with the corresponding OP_PHI, or simply discarding
the list, depending on the returned value.

The situation can clearly be seen with the following code:
	struct s { void *x, *z; };
	extern void use(struct s *);
	void *foo(struct s *s)
	{
		if (s->x == s->z)
			use(s);
		return s->x;
	}
which was linearized as:
	foo:
		load.64     %r2 <- 0[%arg1]
		load.64     %r4 <- 8[%arg1]
		seteq.32    %r5 <- %r4, %r2
->		phisrc.64   %phi2 <- %r2
->		phisrc.64   %phi3 <- %r2
		cbr         %r5, .L1, .L2
	.L1:
		push.64     %arg1
		call        use
		br          .L2
	.L2:
		load.64     %r8 <- 0[%arg1]
		ret.64      %r8

and is now simply linearized as:
	foo:
		load.64     %r2 <- 0[%arg1]
		load.64     %r4 <- 8[%arg1]
		seteq.32    %r5 <- %r4, %r2
		cbr         %r5, .L1, .L2
	.L1:
		push.64     %arg1
		call        use
		br          .L2
	.L2:
		load.64     %r8 <- 0[%arg1]
		ret.64      %r8

Note: this situation seems to have existed since a long time
      but have been made worse by the patch:
      (5636cd5cb "missing load simplification")

Fixes: 5636cd5cbf816f30ee57d580ec4debd8e0bd7581
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 memops.c                             | 10 ++++++----
 validation/linear/phisrc-orphan-ld.c | 22 ++++++++++++++++++++++
 2 files changed, 28 insertions(+), 4 deletions(-)
 create mode 100644 validation/linear/phisrc-orphan-ld.c

diff --git a/memops.c b/memops.c
index ac43b6a0a..39469e260 100644
--- a/memops.c
+++ b/memops.c
@@ -17,7 +17,7 @@
 #include "flow.h"
 
 static int find_dominating_parents(pseudo_t pseudo, struct instruction *insn,
-	struct basic_block *bb, unsigned long generation, struct pseudo_list **dominators,
+	struct basic_block *bb, unsigned long generation, struct instruction_list **dominators,
 	int local)
 {
 	struct basic_block *parent;
@@ -49,7 +49,7 @@ no_dominance:
 		continue;
 
 found_dominator:
-		add_dominator(dominators, insn, one, NULL);
+		add_instruction(dominators, one);
 	} END_FOR_EACH_PTR(parent);
 	return 1;
 }		
@@ -83,7 +83,7 @@ static void simplify_loads(struct basic_block *bb)
 			struct instruction *dom;
 			pseudo_t pseudo = insn->src;
 			int local = local_pseudo(pseudo);
-			struct pseudo_list *dominators;
+			struct instruction_list *dominators;
 			unsigned long generation;
 
 			/* Check for illegal offsets.. */
@@ -115,6 +115,7 @@ static void simplify_loads(struct basic_block *bb)
 			bb->generation = generation;
 			dominators = NULL;
 			if (find_dominating_parents(pseudo, insn, bb, generation, &dominators, local)) {
+				struct pseudo_list *phi_list;
 				/* This happens with initial assignments to structures etc.. */
 				if (!dominators) {
 					if (local) {
@@ -123,7 +124,8 @@ static void simplify_loads(struct basic_block *bb)
 					}
 					goto next_load;
 				}
-				rewrite_load_instruction(insn, dominators);
+				phi_list = add_load_dominators(insn, dominators, NULL);
+				rewrite_load_instruction(insn, phi_list);
 			}
 		}
 next_load:
diff --git a/validation/linear/phisrc-orphan-ld.c b/validation/linear/phisrc-orphan-ld.c
new file mode 100644
index 000000000..a10aedba6
--- /dev/null
+++ b/validation/linear/phisrc-orphan-ld.c
@@ -0,0 +1,22 @@
+struct s {
+	void *x;
+	void *z;
+};
+
+extern void use(struct s *);
+
+void *foo(struct s *s)
+{
+	if (s->x == s->z)
+		use(s);
+
+	return s->x;
+}
+
+/*
+ * check-name: phisrc orphaned (loads)
+ * check-command: test-linearize -Wno-decl $file
+ *
+ * check-output-ignore
+ * check-output-excludes: phisrc
+ */
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 4/9] div0: warn on division by zero - general case ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 4/9] div0: warn on division by zero - general case
Date: Wed, 31 May 2017 03:22:02 +0000
Message-ID: <20170531032207.95830-5-luc.vanoostenryck () gmail ! com>
--------------------
sparse warn about division by zero but only in plain
expression: no checks are done when the division is
part of a compound assignement.

Change this by adding the appropriate check and warning
during linearization and take care to avoid warning twice.

Note: if should be simpler to drop the checks done at
      expansion time but some expressions are discarded
      before reaching linearization and we want to check
      and warn for those too.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c              | 19 +++++++++++++++++++
 validation/div-by-zero.c | 12 ++++++++++++
 2 files changed, 31 insertions(+)

diff --git a/linearize.c b/linearize.c
index 7313e72d8..7760ea996 100644
--- a/linearize.c
+++ b/linearize.c
@@ -959,6 +959,23 @@ static pseudo_t linearize_store_gen(struct entrypoint *ep,
 	return value;
 }
 
+static void warn_undef_insn(struct instruction *insn, int warn)
+{
+	switch (insn->opcode) {
+	case OP_DIVU:
+	case OP_DIVS:
+	case OP_MODU:
+	case OP_MODS:
+		if (is_pseudo_value(insn->src2, 0)) {
+			if (warn)
+				warning(insn->pos, "division by zero");
+		}
+		break;
+	default:
+		break;
+	}
+}
+
 static pseudo_t add_binary_op(struct entrypoint *ep, struct symbol *ctype, int op, pseudo_t left, pseudo_t right)
 {
 	struct instruction *insn = alloc_typed_instruction(op, ctype);
@@ -1208,6 +1225,7 @@ static pseudo_t linearize_assignment(struct entrypoint *ep, struct expression *e
 		oldvalue = cast_pseudo(ep, oldvalue, target->ctype, ctype);
 		opcode = opcode_sign(op_trans[expr->op - SPECIAL_BASE], ctype);
 		dst = add_binary_op(ep, ctype, opcode, oldvalue, value);
+		warn_undef_insn(dst->def, 1);
 		value = cast_pseudo(ep, dst, ctype, expr->ctype);
 	}
 	value = linearize_store_gen(ep, value, &ad);
@@ -1323,6 +1341,7 @@ static pseudo_t linearize_binop(struct entrypoint *ep, struct expression *expr)
 	src2 = linearize_expression(ep, expr->right);
 	op = opcode_sign(opcode[expr->op], expr->ctype);
 	dst = add_binary_op(ep, expr->ctype, op, src1, src2);
+	warn_undef_insn(dst->def, 0);
 	return dst;
 }
 
diff --git a/validation/div-by-zero.c b/validation/div-by-zero.c
index 786e48298..a06944a58 100644
--- a/validation/div-by-zero.c
+++ b/validation/div-by-zero.c
@@ -18,6 +18,14 @@ int isvmod(int a) { return a % (int) 0; }
 int lsvmod(int a) { return a % (long) 0; }
 int usvmod(int a) { return a % (unsigned int) 0; }
 
+int xsvdiv(int a) { if (a && 0) return a / 0; return 0; }
+int asvdiv(int a) { return a /= 0; }
+int osvdiv(int a) { return a / (a && 0); }
+
+int xsvmod(int a) { if (a && 0) return a % 0; return 0; }
+int asvmod(int a) { return a %= 0; }
+int osvmod(int a) { return a % (a && 0); }
+
 /*
  * check-name: div-by-zero.c
  * check-command: sparse -Wno-decl $file
@@ -39,5 +47,9 @@ div-by-zero.c:16:30: warning: division by zero
 div-by-zero.c:17:30: warning: division by zero
 div-by-zero.c:18:30: warning: division by zero
 div-by-zero.c:19:30: warning: division by zero
+div-by-zero.c:21:42: warning: division by zero
+div-by-zero.c:22:33: warning: division by zero
+div-by-zero.c:25:42: warning: division by zero
+div-by-zero.c:26:33: warning: division by zero
  * check-error-end
  */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/5] always evaluate both operands ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/5] always evaluate both operands
Date: Tue, 19 Sep 2017 02:13:35 +0000
Message-ID: <20170919021335.5881-6-luc.vanoostenryck () gmail ! com>
--------------------
When evaluating a binary expression, the evaluation
already stop if the left operand is found erroneous.
The right one is thus not evaluated but it may contain
another error which will only be diagnosticated after the
first one is corrected and the file rechecked.
This is especially annoying when there are several independent
errors in some complex expression since it will need several
cycles of check-edit-recheck to get all errrors out.

Fix this by always evaluating both left & right operands
(and returning NULL if one of them is erroneous).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index c16ee9624..9f8cf5be4 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -3101,9 +3101,9 @@ struct symbol *evaluate_expression(struct expression *expr)
 	case EXPR_SYMBOL:
 		return evaluate_symbol_expression(expr);
 	case EXPR_BINOP:
-		if (!evaluate_expression(expr->left))
-			return NULL;
-		if (!evaluate_expression(expr->right))
+		evaluate_expression(expr->left);
+		evaluate_expression(expr->right);
+		if (!valid_expr_subtype(expr))
 			return NULL;
 		return evaluate_binop(expr);
 	case EXPR_LOGICAL:
@@ -3114,15 +3114,15 @@ struct symbol *evaluate_expression(struct expression *expr)
 			return NULL;
 		return evaluate_comma(expr);
 	case EXPR_COMPARE:
-		if (!evaluate_expression(expr->left))
-			return NULL;
-		if (!evaluate_expression(expr->right))
+		evaluate_expression(expr->left);
+		evaluate_expression(expr->right);
+		if (!valid_expr_subtype(expr))
 			return NULL;
 		return evaluate_compare(expr);
 	case EXPR_ASSIGNMENT:
-		if (!evaluate_expression(expr->left))
-			return NULL;
-		if (!evaluate_expression(expr->right))
+		evaluate_expression(expr->left);
+		evaluate_expression(expr->right);
+		if (!valid_expr_subtype(expr))
 			return NULL;
 		return evaluate_assignment(expr);
 	case EXPR_PREOP:
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/5] avoid crash with sym->bb_target == NULL ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/5] avoid crash with sym->bb_target == NULL
Date: Thu, 06 Jul 2017 19:19:50 +0000
Message-ID: <20170706191950.81268-6-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c                  |  5 ++++-
 validation/crash-bb_target.c | 10 ++++++++++
 2 files changed, 14 insertions(+), 1 deletion(-)
 create mode 100644 validation/crash-bb_target.c

diff --git a/linearize.c b/linearize.c
index b76e980dc..d868c4551 100644
--- a/linearize.c
+++ b/linearize.c
@@ -334,6 +334,7 @@ const char *show_instruction(struct instruction *insn)
 		
 	case OP_SETVAL: {
 		struct expression *expr = insn->val;
+		struct symbol *sym;
 		buf += sprintf(buf, "%s <- ", show_pseudo(insn->target));
 
 		if (!expr) {
@@ -355,7 +356,9 @@ const char *show_instruction(struct instruction *insn)
 			buf += sprintf(buf, "%s", show_ident(expr->symbol->ident));
 			break;
 		case EXPR_LABEL:
-			buf += sprintf(buf, ".L%u", expr->symbol->bb_target->nr);
+			sym = expr->symbol;
+			if (sym->bb_target)
+				buf += sprintf(buf, ".L%u", sym->bb_target->nr);
 			break;
 		default:
 			buf += sprintf(buf, "SETVAL EXPR TYPE %d", expr->type);
diff --git a/validation/crash-bb_target.c b/validation/crash-bb_target.c
new file mode 100644
index 000000000..bc5a3d354
--- /dev/null
+++ b/validation/crash-bb_target.c
@@ -0,0 +1,10 @@
+a() {
+  &&b
+
+/*
+ * check-name: crash bb_target
+ * check-command: test-linearize $file
+ *
+ * check-error-ignore
+ * check-output-ignore
+ */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 5/5] avoid crash with sym->bb_target == NULL
Date: Wed, 19 Jul 2017 22:23:33 +0000
Message-ID: <20170719222331.uxi5he3eki3lwmrh () ltop ! local>
--------------------
This patch fixes a reproducible crash and have been ignored
since it has been posted two weeks ago.
Is there any reasons why?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 5/5] avoid crash with sym->bb_target == NULL
Date: Sat, 29 Jul 2017 12:30:08 +0000
Message-ID: <CAExDi1RgcMd9e6mw6h-K3ERG6zd30hbv2Ka+7Ek8RJjLT0u2gg () mail ! gmail ! com>
--------------------
On Thu, Jul 20, 2017 at 12:57 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Jul 6, 2017 at 3:19 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> +                       sym = expr->symbol;
>> +                       if (sym->bb_target)
>> +                               buf += sprintf(buf, ".L%u", sym->bb_target->nr);
> You chould do:
> bb = expr->symbol->target;
> if (bb)
>     buf +=  sprintf(buf, ".L%u", bb ? bb->nr);
> else
>     buf += sprintf(buf, ".L<invalid>");
>
> It is up to you.

Yes, it's more informative but I have a later series which convert all these
to calls to a function show_label() which then do the right thing.
So, I prefer to leave like this for the moment.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/5] testsuite: quieter error reporting for 'known-to-fail' ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/5] testsuite: quieter error reporting for 'known-to-fail'
Date: Thu, 05 Jan 2017 05:16:32 +0000
Message-ID: <20170105051632.8392-6-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/validation/test-suite b/validation/test-suite
index 47015c61..a5f5e25e 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -214,6 +214,8 @@ do_test()
 
 	get_tag "check-known-to-fail" $file
 	must_fail=`expr "$?" = 0`
+	quiet=0
+	[ $must_fail -eq 1 ] && [ $V -eq 0 ] && quiet=1
 	known_ko_tests=`expr $known_ko_tests + $must_fail`
 
 	for stream in output error; do
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 5/9] div0: add warning option -Wdiv-by-zero ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 5/9] div0: add warning option -Wdiv-by-zero
Date: Wed, 31 May 2017 03:22:03 +0000
Message-ID: <20170531032207.95830-6-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 lib.c | 2 ++
 lib.h | 1 +
 2 files changed, 3 insertions(+)

diff --git a/lib.c b/lib.c
index e1e6a1cbf..af2ad83a2 100644
--- a/lib.c
+++ b/lib.c
@@ -225,6 +225,7 @@ int Wdecl = 1;
 int Wdeclarationafterstatement = -1;
 int Wdefault_bitfield_sign = 0;
 int Wdesignated_init = 1;
+int Wdiv_by_zero = 1;
 int Wdo_while = 0;
 int Winit_cstring = 0;
 int Wenum_mismatch = 1;
@@ -502,6 +503,7 @@ static const struct warning {
 	{ "declaration-after-statement", &Wdeclarationafterstatement },
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
 	{ "designated-init", &Wdesignated_init },
+	{ "div-by-zero", &Wdiv_by_zero },
 	{ "do-while", &Wdo_while },
 	{ "enum-mismatch", &Wenum_mismatch },
 	{ "sparse-error", &Wsparse_error },
diff --git a/lib.h b/lib.h
index 2c8529f93..820e69476 100644
--- a/lib.h
+++ b/lib.h
@@ -112,6 +112,7 @@ extern int Wdecl;
 extern int Wdeclarationafterstatement;
 extern int Wdefault_bitfield_sign;
 extern int Wdesignated_init;
+extern int Wdiv_by_zero;
 extern int Wdo_while;
 extern int Wenum_mismatch;
 extern int Wsparse_error;
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/6] build: replace *_EXTRA_OBJS by local assignments to LDFLAGS and LOADLIBES ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 6/6] build: replace *_EXTRA_OBJS by local assignments to LDFLAGS and LOADLIBES
Date: Fri, 06 Oct 2017 19:19:15 +0000
Message-ID: <CANeU7Q=Ucf62ZXCNo8JuYooXpPmtESentW1XwpW4XU8OymZ66Q () mail ! gmail ! com>
--------------------
On Wed, Oct 4, 2017 at 6:26 AM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.or=
g> wrote:
> ---
>  Makefile | 11 ++++++-----
>  1 file changed, 6 insertions(+), 5 deletions(-)
>
> diff --git a/Makefile b/Makefile
> index f6c577c02143..50e7b99b6107 100644
> --- a/Makefile
> +++ b/Makefile
> @@ -62,8 +62,8 @@ INST_MAN1=3Dsparse.1 cgcc.1
>  ifeq ($(HAVE_LIBXML),yes)
>  PROGRAMS+=3Dc2xml
>  INST_PROGRAMS+=3Dc2xml
> -c2xml_EXTRA_OBJS =3D `$(PKG_CONFIG) --libs libxml-2.0`
> -LIBXML_CFLAGS :=3D $(shell $(PKG_CONFIG) --cflags libxml-2.0)
> +c2xml: LOADLIBES +=3D $(shell $(PKG_CONFIG) --libs libxml-2.0)
> +c2xml: CFLAGS +=3D $(shell $(PKG_CONFIG) --cflags libxml-2.0)


This is by design.

The problem with target specific variable is that, you can't easily
access it out side of the target specific scope.

For example in the debug target branch, it go through a loop
to process all objects, including the extra objects. You can't do that if
you use target specific variables.

 $(foreach @F,$(PROGRAMS),$(eval $(@F): $(EXTRA_OBJS) $(LIBS)))
-$(foreach @F,$(PROGRAMS),$(eval debug/$(@F): $(addprefix debug/,
$(EXTRA_OBJS)) $(DBG_LIBS)))
+$(foreach @F,$(PROGRAMS),$(eval dbgbuild/$(@F): $(addprefix
dbgbuild/, $(EXTRA_OBJS)) $(DBG_LIBS)))

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/6] remove OP_{AND,OR}_BOOL instructions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 6/6] remove OP_{AND,OR}_BOOL instructions
Date: Wed, 12 Apr 2017 19:33:44 +0000
Message-ID: <20170412193344.95935-7-luc.vanoostenryck () gmail ! com>
--------------------
Now that OP_AND_BOOL and OP_OR_BOOL are not generated anymore
we can remove all related code & defines.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 cse.c       |  4 +---
 example.c   |  3 ---
 linearize.c |  2 --
 linearize.h |  4 +---
 simplify.c  | 24 ------------------------
 5 files changed, 2 insertions(+), 35 deletions(-)

diff --git a/cse.c b/cse.c
index cd1e8942c..0ea9b3241 100644
--- a/cse.c
+++ b/cse.c
@@ -61,8 +61,7 @@ static void clean_up_one_instruction(struct basic_block *bb, struct instruction
 	case OP_AND: case OP_OR:
 
 	/* Binary logical */
-	case OP_XOR: case OP_AND_BOOL:
-	case OP_OR_BOOL:
+	case OP_XOR:
 
 	/* Binary comparison */
 	case OP_SET_EQ: case OP_SET_NE:
@@ -192,7 +191,6 @@ static int insn_compare(const void *_i1, const void *_i2)
 	/* commutative binop */
 	case OP_ADD:
 	case OP_MULU: case OP_MULS:
-	case OP_AND_BOOL: case OP_OR_BOOL:
 	case OP_AND: case OP_OR:
 	case OP_XOR:
 	case OP_SET_EQ: case OP_SET_NE:
diff --git a/example.c b/example.c
index 69e00b325..ca1077876 100644
--- a/example.c
+++ b/example.c
@@ -46,8 +46,6 @@ static const char *opcodes[] = {
 	[OP_AND] = "and",
 	[OP_OR] = "or",
 	[OP_XOR] = "xor",
-	[OP_AND_BOOL] = "and-bool",
-	[OP_OR_BOOL] = "or-bool",
 
 	/* Binary comparison */
 	[OP_SET_EQ] = "seteq",
@@ -1406,7 +1404,6 @@ static void generate_one_insn(struct instruction *insn, struct bb_state *state)
 
 	case OP_ADD: case OP_MULU: case OP_MULS:
 	case OP_AND: case OP_OR: case OP_XOR:
-	case OP_AND_BOOL: case OP_OR_BOOL:
 		generate_commutative_binop(state, insn);
 		break;
 
diff --git a/linearize.c b/linearize.c
index e6b77ec01..8e8c99e4a 100644
--- a/linearize.c
+++ b/linearize.c
@@ -199,8 +199,6 @@ static const char *opcodes[] = {
 	[OP_AND] = "and",
 	[OP_OR] = "or",
 	[OP_XOR] = "xor",
-	[OP_AND_BOOL] = "and-bool",
-	[OP_OR_BOOL] = "or-bool",
 
 	/* Binary comparison */
 	[OP_SET_EQ] = "seteq",
diff --git a/linearize.h b/linearize.h
index 24cbcf94d..12a8fe3a7 100644
--- a/linearize.h
+++ b/linearize.h
@@ -175,9 +175,7 @@ enum opcode {
 	OP_AND,
 	OP_OR,
 	OP_XOR,
-	OP_AND_BOOL,
-	OP_OR_BOOL,
-	OP_BINARY_END = OP_OR_BOOL,
+	OP_BINARY_END = OP_XOR,
 
 	/* floating-point comparison */
 	OP_FPCMP,
diff --git a/simplify.c b/simplify.c
index 30bbc9b99..f730dc8ce 100644
--- a/simplify.c
+++ b/simplify.c
@@ -475,11 +475,6 @@ static int simplify_constant_rightside(struct instruction *insn)
 	long long bits = sbit | (sbit - 1);
 
 	switch (insn->opcode) {
-	case OP_OR_BOOL:
-		if (value == 1)
-			return replace_with_pseudo(insn, insn->src2);
-		goto case_neutral_zero;
-
 	case OP_OR:
 		if ((value & bits) == bits)
 			return replace_with_pseudo(insn, insn->src2);
@@ -518,10 +513,6 @@ static int simplify_constant_rightside(struct instruction *insn)
 	case OP_MULU: case OP_MULS:
 		return simplify_mul_div(insn, value);
 
-	case OP_AND_BOOL:
-		if (value == 1)
-			return replace_with_pseudo(insn, insn->src1);
-	/* Fall through */
 	case OP_AND:
 		if ((value & bits) == bits)
 			return replace_with_pseudo(insn, insn->src1);
@@ -631,13 +622,6 @@ static int simplify_constant_binop(struct instruction *insn)
 	case OP_XOR:
 		res = left ^ right;
 		break;
-	case OP_AND_BOOL:
-		res = left && right;
-		break;
-	case OP_OR_BOOL:
-		res = left || right;
-		break;
-			       
 	/* Binary comparison */
 	case OP_SET_EQ:
 		res = left == right;
@@ -701,13 +685,6 @@ static int simplify_binop_same_args(struct instruction *insn, pseudo_t arg)
 	case OP_OR:
 		return replace_with_pseudo(insn, arg);
 
-	case OP_AND_BOOL:
-	case OP_OR_BOOL:
-		remove_usage(arg, &insn->src2);
-		insn->src2 = value_pseudo(0);
-		insn->opcode = OP_SET_NE;
-		return REPEAT_CSE;
-
 	default:
 		break;
 	}
@@ -1190,7 +1167,6 @@ int simplify_instruction(struct instruction *insn)
 	switch (insn->opcode) {
 	case OP_ADD: case OP_MULS:
 	case OP_AND: case OP_OR: case OP_XOR:
-	case OP_AND_BOOL: case OP_OR_BOOL:
 		canonicalize_commutative(insn);
 		if (simplify_binop(insn))
 			return REPEAT_CSE;
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/6] testsuite: avoid fork+execing basename ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 6/6] testsuite: avoid fork+execing basename
Date: Sun, 28 May 2017 19:29:06 +0000
Message-ID: <20170528192906.1023-7-luc.vanoostenryck () gmail ! com>
--------------------
Some testcase (the ones related to sparse-llvm) are disabled if
the needed support is not present. This is done by checking
the name of the command used by the testcase.

The previous possible presence of './' before the command meant
that the command was checked via the 'basename' command, which
need to ne fork+execed.
Since the './' have now been stripped from all command names
this is no more needed.

Change this by comparing directly the command name.

This speedup the testsuite by another 6%.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/test-suite | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/validation/test-suite b/validation/test-suite
index da9d88159..3056fce90 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -189,11 +189,10 @@ do_test()
 	if [ "$check_command" = "" ]; then
 		check_command="$defaut_command"
 	fi
-	cmd=`eval echo $default_path/$check_command`
 
 	# check for disabled commands
-	set -- $cmd
-	base_cmd=`basename $1`
+	set -- $check_command
+	base_cmd=$1
 	for i in $disabled_cmds; do
 		if [ "$i" = "$base_cmd" ] ; then
 			disabled_tests=$(($disabled_tests + 1))
@@ -202,6 +201,8 @@ do_test()
 		fi
 	done
 
+	cmd=`eval echo $default_path/$check_command`
+
 	echo "     TEST    $test_name ($file)"
 
 	verbose "Using command       : $cmd"
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/8] integrate add_load_dominators() into rewrite_load_instruction() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 6/8] integrate add_load_dominators() into rewrite_load_instruction()
Date: Thu, 13 Apr 2017 16:55:49 +0000
Message-ID: <20170413165551.2785-7-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c   | 12 ++++++++----
 flow.h   |  4 +---
 memops.c |  4 +---
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/flow.c b/flow.c
index 678f9ba86..b64a3f74a 100644
--- a/flow.c
+++ b/flow.c
@@ -406,6 +406,7 @@ found_dominator:
 	return 1;
 }		
 
+static
 void add_dominator(struct pseudo_list **phi_list, struct instruction *insn,
 	struct instruction *dom, struct ident *ident)
 {
@@ -417,6 +418,7 @@ void add_dominator(struct pseudo_list **phi_list, struct instruction *insn,
 	use_pseudo(insn, phi, add_pseudo(phi_list, phi));
 }
 
+static
 struct pseudo_list *add_load_dominators(struct instruction *insn, struct instruction_list *doms,
 	struct ident *ident)
 {
@@ -433,10 +435,14 @@ struct pseudo_list *add_load_dominators(struct instruction *insn, struct instruc
  * We should probably sort the phi list just to make it easier to compare
  * later for equality. 
  */
-void rewrite_load_instruction(struct instruction *insn, struct pseudo_list *dominators)
+void rewrite_load_instruction(struct instruction *insn, struct instruction_list *doms,
+	struct ident *ident)
 {
+	struct pseudo_list *dominators;
 	pseudo_t new, phi;
 
+	dominators = add_load_dominators(insn, doms, ident);
+
 	/*
 	 * Check for somewhat common case of duplicate
 	 * phi nodes.
@@ -473,7 +479,6 @@ static int find_dominating_stores(pseudo_t pseudo, struct instruction *insn,
 	struct basic_block *bb = insn->bb;
 	struct instruction *one, *dom = NULL;
 	struct instruction_list *dominators;
-	struct pseudo_list *phi_list;
 	int partial;
 
 	/* Unreachable load? Undo it */
@@ -535,8 +540,7 @@ found:
 	 * have to turn the load into a phi-node of the
 	 * dominators.
 	 */
-	phi_list = add_load_dominators(insn, dominators, pseudo->ident);
-	rewrite_load_instruction(insn, phi_list);
+	rewrite_load_instruction(insn, dominators, pseudo->ident);
 	return 1;
 }
 
diff --git a/flow.h b/flow.h
index a6d0881c2..99bfcc879 100644
--- a/flow.h
+++ b/flow.h
@@ -37,9 +37,7 @@ static inline void kill_instruction_force(struct instruction *insn)
 
 void check_access(struct instruction *insn);
 void convert_load_instruction(struct instruction *, pseudo_t);
-void rewrite_load_instruction(struct instruction *, struct pseudo_list *);
-void add_dominator(struct pseudo_list **, struct instruction *, struct instruction *, struct ident*);
-struct pseudo_list *add_load_dominators(struct instruction *, struct instruction_list *, struct ident*);
+void rewrite_load_instruction(struct instruction *, struct instruction_list *, struct ident*);
 int dominates(pseudo_t pseudo, struct instruction *insn, struct instruction *dom, int local);
 
 extern void clear_liveness(struct entrypoint *ep);
diff --git a/memops.c b/memops.c
index 39469e260..bbb1831af 100644
--- a/memops.c
+++ b/memops.c
@@ -115,7 +115,6 @@ static void simplify_loads(struct basic_block *bb)
 			bb->generation = generation;
 			dominators = NULL;
 			if (find_dominating_parents(pseudo, insn, bb, generation, &dominators, local)) {
-				struct pseudo_list *phi_list;
 				/* This happens with initial assignments to structures etc.. */
 				if (!dominators) {
 					if (local) {
@@ -124,8 +123,7 @@ static void simplify_loads(struct basic_block *bb)
 					}
 					goto next_load;
 				}
-				phi_list = add_load_dominators(insn, dominators, NULL);
-				rewrite_load_instruction(insn, phi_list);
+				rewrite_load_instruction(insn, dominators, NULL);
 			}
 		}
 next_load:
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 6/9] div0: use -Wdiv-by-zero ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 6/9] div0: use -Wdiv-by-zero
Date: Wed, 31 May 2017 03:22:04 +0000
Message-ID: <20170531032207.95830-7-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 expand.c    | 4 ++--
 linearize.c | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/expand.c b/expand.c
index 0b528ea5a..8fd258e25 100644
--- a/expand.c
+++ b/expand.c
@@ -278,7 +278,7 @@ static int simplify_int_binop(struct expression *expr, struct symbol *ctype)
 	expr->taint = left->taint | right->taint;
 	return 1;
 Div:
-	if (!conservative)
+	if (!conservative && Wdiv_by_zero)
 		warning(expr->pos, "division by zero");
 	return 0;
 Overflow:
@@ -363,7 +363,7 @@ static int simplify_float_binop(struct expression *expr)
 	expr->fvalue = res;
 	return 1;
 Div:
-	if (!conservative)
+	if (!conservative && Wdiv_by_zero)
 		warning(expr->pos, "division by zero");
 	return 0;
 }
diff --git a/linearize.c b/linearize.c
index 7760ea996..604a67b82 100644
--- a/linearize.c
+++ b/linearize.c
@@ -967,7 +967,7 @@ static void warn_undef_insn(struct instruction *insn, int warn)
 	case OP_MODU:
 	case OP_MODS:
 		if (is_pseudo_value(insn->src2, 0)) {
-			if (warn)
+			if (warn && Wdiv_by_zero)
 				warning(insn->pos, "division by zero");
 		}
 		break;
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/8] check duplicated phi-nodes directly on dominators ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 7/8] check duplicated phi-nodes directly on dominators
Date: Thu, 13 Apr 2017 16:55:50 +0000
Message-ID: <20170413165551.2785-8-luc.vanoostenryck () gmail ! com>
--------------------
Now that add_load_dominators() is integrated into
rewrite_load_instruction() we can check for duplicated
phi sources directly in the dominators list instead
to have to check the corresponding phi sources.

This is a preparatory step for the next patch where
unneeded phi sources are not created anymore.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/flow.c b/flow.c
index b64a3f74a..d705abe2e 100644
--- a/flow.c
+++ b/flow.c
@@ -439,6 +439,7 @@ void rewrite_load_instruction(struct instruction *insn, struct instruction_list
 	struct ident *ident)
 {
 	struct pseudo_list *dominators;
+	struct instruction *dom;
 	pseudo_t new, phi;
 
 	dominators = add_load_dominators(insn, doms, ident);
@@ -447,12 +448,12 @@ void rewrite_load_instruction(struct instruction *insn, struct instruction_list
 	 * Check for somewhat common case of duplicate
 	 * phi nodes.
 	 */
-	new = first_pseudo(dominators)->def->src1;
-	FOR_EACH_PTR(dominators, phi) {
-		if (new != phi->def->src1)
+	new = first_instruction(doms)->target;
+	FOR_EACH_PTR(doms, dom) {
+		if (new != dom->target)
 			goto complex_phi;
-		new->ident = new->ident ? : phi->ident;
-	} END_FOR_EACH_PTR(phi);
+		new->ident = new->ident ? : ident ? : dom->target->ident;
+	} END_FOR_EACH_PTR(dom);
 
 	/*
 	 * All the same pseudo - mark the phi-nodes unused
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 7/9] div0: warn also during simplification ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 7/9] div0: warn also during simplification
Date: Wed, 31 May 2017 03:22:05 +0000
Message-ID: <20170531032207.95830-8-luc.vanoostenryck () gmail ! com>
--------------------
sparse now warn about divion by zero during linearization
but during simplification some expression can become constants
and so some new divisions by zero can appears.

Warn also on those new and to avoid to warn also here on the old
ones, mark the instructions for wich we have already be warned.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c              |  1 +
 simplify.c               | 12 ++++++++++++
 validation/div-by-zero.c |  2 ++
 3 files changed, 15 insertions(+)

diff --git a/linearize.c b/linearize.c
index 604a67b82..51405539d 100644
--- a/linearize.c
+++ b/linearize.c
@@ -969,6 +969,7 @@ static void warn_undef_insn(struct instruction *insn, int warn)
 		if (is_pseudo_value(insn->src2, 0)) {
 			if (warn && Wdiv_by_zero)
 				warning(insn->pos, "division by zero");
+			insn->warned = 1;
 		}
 		break;
 	default:
diff --git a/simplify.c b/simplify.c
index a141ddd43..40e1c253b 100644
--- a/simplify.c
+++ b/simplify.c
@@ -404,6 +404,15 @@ static int simplify_asr(struct instruction *insn, pseudo_t pseudo, long long val
 	return 0;
 }
 
+static void check_divide_by_zero(struct instruction *insn, long long value)
+{
+	if (value != 0 || insn->warned)
+		return;
+	if (Wdiv_by_zero)
+		warning(insn->pos, "division by zero");
+	insn->warned = 1;
+}
+
 static int simplify_mul_div(struct instruction *insn, long long value)
 {
 	unsigned long long sbit = 1ULL << (insn->size - 1);
@@ -525,9 +534,12 @@ static int simplify_constant_rightside(struct instruction *insn)
 	case OP_MODU: case OP_MODS:
 		if (value == 1)
 			return replace_with_pseudo(insn, value_pseudo(0));
+		check_divide_by_zero(insn, value);
 		return 0;
 
 	case OP_DIVU: case OP_DIVS:
+		check_divide_by_zero(insn, value);
+		/* Fall through */
 	case OP_MULU: case OP_MULS:
 		return simplify_mul_div(insn, value);
 
diff --git a/validation/div-by-zero.c b/validation/div-by-zero.c
index a06944a58..353c85889 100644
--- a/validation/div-by-zero.c
+++ b/validation/div-by-zero.c
@@ -49,7 +49,9 @@ div-by-zero.c:18:30: warning: division by zero
 div-by-zero.c:19:30: warning: division by zero
 div-by-zero.c:21:42: warning: division by zero
 div-by-zero.c:22:33: warning: division by zero
+div-by-zero.c:23:38: warning: division by zero
 div-by-zero.c:25:42: warning: division by zero
 div-by-zero.c:26:33: warning: division by zero
+div-by-zero.c:27:38: warning: division by zero
  * check-error-end
  */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 8/8] avoid creating unneeded phi-sources ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 8/8] avoid creating unneeded phi-sources
Date: Thu, 13 Apr 2017 16:55:51 +0000
Message-ID: <20170413165551.2785-9-luc.vanoostenryck () gmail ! com>
--------------------
In rewrite_load_instruction(), it's tested if the dominators
are in fact all the same and if they are, as there is then no
need for a phi-node, the newly created OP_PHISRCs are killed
and the unique dominator is used in place of the phi-node.

But in this case, it's a waste to have created the OP_PHISRCs
as they are destroyed just after being created.

Fix this by basically switching the order 'creating phi sources'
and 'checking for uniqueness'. If the dominators are found to be
all the same then use this unique dominator as the loaded value
and no OP_PHISRC need to be created.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c                          | 17 ++++++++---------
 validation/loop-linearization.c | 30 +++++++++++++++---------------
 2 files changed, 23 insertions(+), 24 deletions(-)

diff --git a/flow.c b/flow.c
index d705abe2e..317074545 100644
--- a/flow.c
+++ b/flow.c
@@ -440,9 +440,7 @@ void rewrite_load_instruction(struct instruction *insn, struct instruction_list
 {
 	struct pseudo_list *dominators;
 	struct instruction *dom;
-	pseudo_t new, phi;
-
-	dominators = add_load_dominators(insn, doms, ident);
+	pseudo_t new;
 
 	/*
 	 * Check for somewhat common case of duplicate
@@ -456,17 +454,18 @@ void rewrite_load_instruction(struct instruction *insn, struct instruction_list
 	} END_FOR_EACH_PTR(dom);
 
 	/*
-	 * All the same pseudo - mark the phi-nodes unused
-	 * and convert the load into a LNOP and replace the
-	 * pseudo.
+	 * All the same pseudo - convert the load into a pseudo.
 	 */
-	FOR_EACH_PTR(dominators, phi) {
-		kill_instruction(phi->def);
-	} END_FOR_EACH_PTR(phi);
 	convert_load_instruction(insn, new);
 	return;
 
 complex_phi:
+	/*
+	 * Not identical pseudos - create a phisrc for each
+	 * dominators and convert the load into a phi-node.
+	 */
+	dominators = add_load_dominators(insn, doms, ident);
+
 	/* We leave symbol pseudos with a bogus usage list here */
 	if (insn->src->type != PSEUDO_SYM)
 		kill_use(&insn->src);
diff --git a/validation/loop-linearization.c b/validation/loop-linearization.c
index d53366bde..ab731dc15 100644
--- a/validation/loop-linearization.c
+++ b/validation/loop-linearization.c
@@ -39,11 +39,11 @@ static int fdo(void)
 ffor:
 .L0:
 	<entry-point>
-	phisrc.32   %phi5(i) <- $0
+	phisrc.32   %phi3(i) <- $0
 	br          .L4
 
 .L4:
-	phi.32      %r1(i) <- %phi5(i), %phi6(i)
+	phi.32      %r1(i) <- %phi3(i), %phi4(i)
 	setlt.32    %r2 <- %r1(i), $10
 	cbr         %r2, .L1, .L3
 
@@ -58,7 +58,7 @@ ffor:
 
 .L2:
 	add.32      %r7 <- %r1(i), $1
-	phisrc.32   %phi6(i) <- %r7
+	phisrc.32   %phi4(i) <- %r7
 	br          .L4
 
 .L3:
@@ -73,11 +73,11 @@ ffor:
 fwhile:
 .L8:
 	<entry-point>
-	phisrc.32   %phi11(i) <- $0
+	phisrc.32   %phi7(i) <- $0
 	br          .L12
 
 .L12:
-	phi.32      %r8(i) <- %phi11(i), %phi12(i)
+	phi.32      %r8(i) <- %phi7(i), %phi8(i)
 	setlt.32    %r9 <- %r8(i), $10
 	cbr         %r9, .L9, .L11
 
@@ -87,51 +87,51 @@ fwhile:
 	cbr         %r11, .L14, .L13
 
 .L13:
-	phisrc.32   %phi7(return) <- $0
+	phisrc.32   %phi5(return) <- $0
 	br          .L15
 
 .L14:
 	add.32      %r14 <- %r8(i), $1
-	phisrc.32   %phi12(i) <- %r14
+	phisrc.32   %phi8(i) <- %r14
 	br          .L12
 
 .L11:
-	phisrc.32   %phi8(return) <- $1
+	phisrc.32   %phi6(return) <- $1
 	br          .L15
 
 .L15:
-	phi.32      %r12 <- %phi7(return), %phi8(return)
+	phi.32      %r12 <- %phi5(return), %phi6(return)
 	ret.32      %r12
 
 
 fdo:
 .L16:
 	<entry-point>
-	phisrc.32   %phi16(i) <- $0
+	phisrc.32   %phi11(i) <- $0
 	br          .L17
 
 .L17:
-	phi.32      %r15(i) <- %phi16(i), %phi17(i)
+	phi.32      %r15(i) <- %phi11(i), %phi12(i)
 	push.32     %r15(i)
 	call.32     %r16 <- p
 	cbr         %r16, .L18, .L20
 
 .L20:
-	phisrc.32   %phi13(return) <- $0
+	phisrc.32   %phi9(return) <- $0
 	br          .L22
 
 .L18:
 	add.32      %r19 <- %r15(i), $1
 	setlt.32    %r20 <- %r15(i), $10
-	phisrc.32   %phi17(i) <- %r19
+	phisrc.32   %phi12(i) <- %r19
 	cbr         %r20, .L17, .L19
 
 .L19:
-	phisrc.32   %phi14(return) <- $1
+	phisrc.32   %phi10(return) <- $1
 	br          .L22
 
 .L22:
-	phi.32      %r17 <- %phi13(return), %phi14(return)
+	phi.32      %r17 <- %phi9(return), %phi10(return)
 	ret.32      %r17
 
 
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 9/9] div0: add missing tests for floating point div by zero ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH 9/9] div0: add missing tests for floating point div by zero
Date: Wed, 31 May 2017 03:22:07 +0000
Message-ID: <20170531032207.95830-10-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/div-by-zero-fp.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/validation/div-by-zero-fp.c b/validation/div-by-zero-fp.c
index 787af1636..957bc732c 100644
--- a/validation/div-by-zero-fp.c
+++ b/validation/div-by-zero-fp.c
@@ -3,14 +3,22 @@ double gbad(double a) { return 2.0 / 0.0; }
 double fool(double a) { return a / 0; }
 double ffoo(double a) { return a / 0.0; }
 
+double fbar(double a) { if (a && 0) a / 0.0; return 0; }
+double fbaz(double a) { return a /= 0.0; }
+double fquz(double a) { return a / (a && 0); }
+
 /*
  * check-name: div-by-zero-fp.c
  * check-command: sparse -Wno-decl $file
+ * check-known-to-fail
  *
  * check-error-start
 div-by-zero-fp.c:1:36: warning: division by zero
 div-by-zero-fp.c:2:36: warning: division by zero
 div-by-zero-fp.c:3:34: warning: division by zero
 div-by-zero-fp.c:4:34: warning: division by zero
+div-by-zero-fp.c:6:39: warning: division by zero
+div-by-zero-fp.c:7:34: warning: division by zero
+div-by-zero-fp.c:8:34: warning: division by zero
  * check-error-end
  */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH RFC] Let pseudo->users loop on duplicate version of list ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Mon, 10 Jul 2017 15:32:46 +0000
Message-ID: <CANeU7QmpvfZutvnSwrjH7ZYXhw3S3HDh19eHXkBGY7oz7ADtmw () mail ! gmail ! com>
--------------------
I found a temporary solution is simple enough.

Instead of marking the entry deleted. I just use a duplicate
version of the list->list[] when doing the loop. It will have
unwanted effect that iterator will issue some ptr are already
deleted. Other than that, it is very straight forward.

It pass the kernel compile test without issue different warnings.
It also pass the ptrlist ref checking. The ref count patch can now
complete the full kernel check without die() on it. Again no difference
in warning.

Chris



================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Tue, 11 Jul 2017 21:04:08 +0000
Message-ID: <CACXZuxerM5i33YgKn=GfnWQe+pViCUfUmJ10sz0K-+PjG28uwA () mail ! gmail ! com>
--------------------
Hi Chris,

On 11 July 2017 at 21:53, Christopher Li <sparse@chrisli.org> wrote:
> Ping, Any taker want to review or suggest alternative
> way to fix the nested loop delete bug?
>
>> Instead of marking the entry deleted. I just use a duplicate
>> version of the list->list[] when doing the loop. It will have
>> unwanted effect that iterator will issue some ptr are already
>> deleted. Other than that, it is very straight forward.
>>

I think that duplicating a list because that list is being modified is
quite a sensible thing to do. My only suggestion would be that perhaps
you could have a dup() step that is separate so that you can use the
normal iterator macro after duplicating.

Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Wed, 12 Jul 2017 05:29:36 +0000
Message-ID: <CANeU7QkTAQ6XaAGrd1PmQ_4Jcv2vxD-cK_9+kKFbyX5b+Pg+Wg () mail ! gmail ! com>
--------------------
On Tue, Jul 11, 2017 at 2:04 PM, Dibyendu Majumdar
<mobile@majumdar.org.uk> wrote:
> I think that duplicating a list because that list is being modified is
> quite a sensible thing to do. My only suggestion would be that perhaps
> you could have a dup() step that is separate so that you can use the
> normal iterator macro after duplicating.

So are you suggesting some thing like this:

struct ptr_list *dup_list = NULL:
concat_ptr_list(orign_list, &dup_list);
FOR_EACH_PTR(dup_list, ptr) {
...
} END_FOR_EACH_PTR(ptr);
free_ptr_list(dup_list);

I think that should work. But it come with a price
allocating and freeing the list (otherwise it is a memory leak).

Also run slightly slower. My current way will only duplicate
the list struct one at a time. It never duplicate the full list.
It has fixed memory usage, no allocating, no duplicate of
the ->next and ->prev pointer.

So what macro do you have in mind? I think any thing modify
the duplicate list does not make sense.

On thing I can do is rename the __list into __orig, then rename
__dup into __list. Then most of the list macro using __list should
work. It also means I have to use END_FOR_EACH_PTR_DUP()
as well.


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Wed, 12 Jul 2017 15:56:16 +0000
Message-ID: <CACXZuxeGmWGFbMmJCKi+aZbbxx89upb=_Vzqe7Ta99mOGHuVrg () mail ! gmail ! com>
--------------------
Hi Chris,

On 12 July 2017 at 06:29, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Jul 11, 2017 at 2:04 PM, Dibyendu Majumdar
> <mobile@majumdar.org.uk> wrote:
>> I think that duplicating a list because that list is being modified is
>> quite a sensible thing to do. My only suggestion would be that perhaps
>> you could have a dup() step that is separate so that you can use the
>> normal iterator macro after duplicating.
>
> So are you suggesting some thing like this:
>
> struct ptr_list *dup_list = NULL:
> concat_ptr_list(orign_list, &dup_list);
> FOR_EACH_PTR(dup_list, ptr) {
> ...
> } END_FOR_EACH_PTR(ptr);
> free_ptr_list(dup_list);
>
> I think that should work. But it come with a price
> allocating and freeing the list (otherwise it is a memory leak).

Yes that is what I meant. This is a typical solution to this type of problem.

>
> Also run slightly slower. My current way will only duplicate
> the list struct one at a time. It never duplicate the full list.
> It has fixed memory usage, no allocating, no duplicate of
> the ->next and ->prev pointer.
>

Okay - but is your approach generic enough? What if there was a split
in the node that you copied? I don't have a full understanding but it
appears to be a very specific solution rather than a general one.

> So what macro do you have in mind? I think any thing modify
> the duplicate list does not make sense.
>
> On thing I can do is rename the __list into __orig, then rename
> __dup into __list. Then most of the list macro using __list should
> work. It also means I have to use END_FOR_EACH_PTR_DUP()
> as well.
>

I was just saying that you can use the standard /existing iterator
macros once you have duplicated the list.

Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Wed, 12 Jul 2017 17:03:41 +0000
Message-ID: <CANeU7Qk+81ABEnGLxwbHnx510JWk7U8s=RnFqm_jM8pj-4EyDw () mail ! gmail ! com>
--------------------
On Wed, Jul 12, 2017 at 8:56 AM, Dibyendu Majumdar
<mobile@majumdar.org.uk> wrote:
>>
>
> Okay - but is your approach generic enough? What if there was a split
> in the node that you copied? I don't have a full understanding but it
> appears to be a very specific solution rather than a general one.

You have a very good point. I have never thought about splitting the
node. If split the node then there will be some ptr iterate twice. Because
some node move to the next bucket and the dup node know nothing
about it. It would be a problem for the existing code as well.

My ptrlist ref count patch haven't check the split node situation.
Even Luc's suggestion for "mark and sweep" to delete the ptrlist
is not going to help with the nested loop split. I will add that check.
I don't expect new offenders but let's make sure about it.

It means it would be so much nicer if we can avoid nested loop modify at all.

> I was just saying that you can use the standard /existing iterator
> macros once you have duplicated the list.

It was not mean to a temporary fix not generic. But may be just add
a function for duplicate list is needed for long run.

We try to avoid nest loop modify, if it has to be done. Outer loop
use a duplicated list.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Thu, 13 Jul 2017 05:27:25 +0000
Message-ID: <CANeU7Qk8VCsj_EDBrj9H1bjR5a-_bLPQJiza_-eC90j=qiw7xw () mail ! gmail ! com>
--------------------
On Wed, Jul 12, 2017 at 11:05 AM, Dibyendu Majumdar
<mobile@majumdar.org.uk> wrote:
>
> I did raise this before
> (http://marc.info/?l=linux-sparse&m=149943353732715&w=2) but maybe it
> got lost in the other stuff.

Sorry I must miss that part. Yes. the ptrlist ref count will not able to
handle the insert and split the node. The whole idea is def the modify to
the last owner of holding the node. Insert need to split the node right there.

Even lock will not work. The inner loop guy try to get the lock and failed.
What can it do? It can't just retry because the parent is holding the lock.
It is going to be very nasty.

Any way, the patch has been updated to use a full duplicated list.
The git branch is at:
https://git.kernel.org/pub/scm/devel/sparse/sparse.git/log/?h=sparse-next-20170712

The patch follows.

Chris


================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Wed, 19 Jul 2017 21:14:40 +0000
Message-ID: <20170719211437.7axhrrjrvr4k6dvg () ltop ! local>
--------------------
On Wed, Jul 12, 2017 at 10:27:25PM -0700, Christopher Li wrote:
> From 7264a822d9d9e545152ac675fbc5b5e970ce254b Mon Sep 17 00:00:00 2001
> From: Christopher Li <sparse@chrisli.org>
> Date: Wed, 12 Jul 2017 14:46:50 -0700
> Subject: [PATCH] Let pseudo->users loop on duplicate versin of list
> 
> pseudo->users list will change during find dominator.
> That cause a bug in the ptrlist because the outer loop iterator
> is not award of the deletion of the entry.
> 
> Let the outer loop using a duplicate version of entry
> to avoid this problem for now.

When I see this description, the first thing I think is:
"you have a problem with an object, you duplicate the object,
 not you have two problem (at least)".
In short, how you will keep coherency between the two?

So yes, without any doubts, this fixes the iteration in the outer loop
not taking correctly in account the deletion in the inner loop.

But is the code working correctly now? I don't think so.
In fact, since the outer loop is using a copy of the initial list,
now *any* changes in the list will siply be ignored by the outer loop.
- if an user is removed from the users list (for example in a
  position much further than the current position in the inner),
  previously, the inner loop will of course not have processed
  this user, while now it will process it although this user no
  more a user of this pseudo.
  It there any explanation which could explain that the current
  behaviour is correct?
- same if the inner loop add a new user, now the outer loop will
  never process this user.

To be clear, the issue I'm raising here is not about 'maybe missing
an optimisation' but well a question of applying an optimization
while the real condition are in fatc not met, and thus producings
incorrect code.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Wed, 19 Jul 2017 21:42:33 +0000
Message-ID: <CANeU7QmQ4JmD_wLoZ6r7bV7Uu4BASnvuHpmQ7VKAoZXR9FD93w () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 2:14 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> When I see this description, the first thing I think is:
> "you have a problem with an object, you duplicate the object,
>  not you have two problem (at least)".
> In short, how you will keep coherency between the two?

We don't :-). Both the remove case and insert case has been
discussed. First of all, the ptrlist-refcount patch check for the
insert case, there is none so far. If you believe there is one,
I would like to know.

About the looping on the deleted entry. That is the very first
thing I shout in the V1 version of the patch. The thing is,
the pseudo_user have a point to instruction. If the instruction
is deleted then that instruction will have insn->bb = NULL.

Not a perfect fix. But better than the previous. Because
the for loop is actually looping on reverse order. Any delete
will cause major align problem __nr counting from the tail.

Any way, My V1 and email asking for suggestion how to fix it
About 10 days  ago. I haven't heard any thing better. If you
have other way to fix it properly, I am all for it. It is not too late
but time is running out soon.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Wed, 19 Jul 2017 22:51:00 +0000
Message-ID: <CAMHZB6E9LkHc4KR5ktoS2MzZpZpW09h4_U8XH+PVE4HTmi1LcQ () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 11:42 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Wed, Jul 19, 2017 at 2:14 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> When I see this description, the first thing I think is:
>> "you have a problem with an object, you duplicate the object,
>>  not you have two problem (at least)".
>> In short, how you will keep coherency between the two?
>
> We don't :-). Both the remove case and insert case has been
> discussed. First of all, the ptrlist-refcount patch check for the
> insert case, there is none so far. If you believe there is one,
> I would like to know.

Some add_user() can be called in this loop. so it's just a question
to some input code complex enough to have an add_user()
done on the same pseudo as the one concerned in the outer
loop.

> About the looping on the deleted entry. That is the very first
> thing I shout in the V1 version of the patch. The thing is,
> the pseudo_user have a point to instruction. If the instruction
> is deleted then that instruction will have insn->bb = NULL.
>
> Not a perfect fix. But better than the previous. Because
> the for loop is actually looping on reverse order. Any delete
> will cause major align problem __nr counting from the tail.

Yes, those list delete inside iteration loops are definitively to avoid.

> Any way, My V1 and email asking for suggestion how to fix it
> About 10 days  ago. I haven't heard any thing better. If you
> have other way to fix it properly, I am all for it. It is not too late
> but time is running out soon.

I stated several times that the only real solution will be to mark the
elements as being deleted (and only effectively delete them in some
safe situations) exactly like it is done for instruction (which are probably
the type the most often deleted from lists. Trying to effectively
removing them from lists like it is currently done for the others types
would most probably fail in the most horrible ways).
It's a simple & clean solution, provably correct in *all* situations.
But I don't remember having seen any replies from you on this subject.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Wed, 02 Aug 2017 23:44:32 +0000
Message-ID: <CAExDi1Tt4P9oFZVoEL9yWwU4N_Te5ZEtNe=KcvAYJuaHtbEVyQ () mail ! gmail ! com>
--------------------
On Thu, Jul 20, 2017 at 4:34 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Wed, Jul 19, 2017 at 3:51 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> Some add_user() can be called in this loop. so it's just a question
>> to some input code complex enough to have an add_user()
>> done on the same pseudo as the one concerned in the outer
>> loop.
>
> Can you point me to a call stack that trigger the add_user()?
>
> I have run the full kernel compile did not trigger it. The other two
> nested loop delete was catches within the first 15 files or so.
>
>> I stated several times that the only real solution will be to mark the
>> elements as being deleted (and only effectively delete them in some
>> safe situations) exactly like it is done for instruction (which are probably
>> the type the most often deleted from lists. Trying to effectively
>> removing them from lists like it is currently done for the others types
>> would most probably fail in the most horrible ways).
>> It's a simple & clean solution, provably correct in *all* situations.
>> But I don't remember having seen any replies from you on this subject.
>
> That is because you are away and you did not read through the email.
> I did comment on it. It doesn't correct in *all* situations. We need bigger
> hammer.
>
> I locate it out for you.
>
> http://marc.info/?l=linux-sparse&m=149987902920449&w=3
> ==========quote================
> Even Luc's suggestion for "mark and sweep" to delete the ptrlist
> is not going to help with the nested loop split. I will add that check.
> I don't expect new offenders but let's make sure about it.
> ==========end quote=============

I don't think you understood what I meant.

> http://marc.info/?l=linux-sparse&m=149969288517115&w=3
> =============quote===============
>> I earlier suggested to instead change the way elements are 'deleted'
>> (like instructions are already never removed from their list but
>> just marked as deleted).
>
> That looks simple but it has hidden complications as well. The issue is that
> we need to find out which list need this kind of special treatment.

It's very simple: *all* lists need this 'treatement'.

> Who is
> the outer loop. If the same function can be both call as the outer
> loop and inner
> loop then it is complicate to decide when it should do the finalize.
> There is also
> the price to pay for walking the list twice which does not exist if nested loop
> can be avoided.

Walking twice?

In general, we can't avoid nested loops.

Look at what is done currently with instructions: when we want to 'delete'
an instruction we simply set it's ->bb to NULL which basically means:
"for now, please just ignore this instruction". In other words, instructions
are *never* removed from their lists, they are simply marked as being
deleted. You don't need to know if you're in a nested loop or not.
You will never have the problem with deletion on nested list walking
because they are never removed from the lists.

Why do you think it has been done so?
Do you think it's bad and it would be better to effectively remove
instructions from their lists like others types?
Do you think it would be good or even possible to avoid having
nested loops of instructions?
I don't think so.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Thu, 03 Aug 2017 10:18:38 +0000
Message-ID: <20170803101835.qhxbyrvly3bhfxyd () ltop ! local>
--------------------
On Wed, Aug 02, 2017 at 08:50:14PM -0400, Christopher Li wrote:
> On Wed, Aug 2, 2017 at 7:44 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >> http://marc.info/?l=linux-sparse&m=149987902920449&w=3
> >> ==========quote================
> >> Even Luc's suggestion for "mark and sweep" to delete the ptrlist
> >> is not going to help with the nested loop split. I will add that check.
> >> I don't expect new offenders but let's make sure about it.
> >> ==========end quote=============
> >
> > I don't think you understood what I meant.
> 
> I don't think so. Can you please explain?
> 
> Let's give it an example on the insert case.

Yes yes.
I already said the 7th July that reverse list walking and list
splitting will be another beast but the subject of this patch
is the *deletion* of elements from lists.
 
> > It's very simple: *all* lists need this 'treatement'.
> 
> I mean you need to identify the caller who is the outer loop, the outer
> loop caller need to do the list packing. That is what I mean by
> special treatment.
> If packing inside the inner loop, that is the problem we try to avoid.
> 
> That is assume we still pack list. If we never pack list, then it is
> not a problem
> here per say.

We don't have to pack all lists.
The ones that we pack can be packed at some specific place/moment.

> >
> > Walking twice?
> 
> I am more worry about the incorrect behavior on insert and packing
> than walk twice.
> 
> >
> > In general, we can't avoid nested loops.
> 
> I am thinking breaking the recursive calling into work queue.
> Then there is no nest loop. If you known why that will not work,
> please point out. I do assume I can convert the recursive call
> to non recursive using work queue. Again I haven't dig very deep yet.

Oh, I'm sure that using a work queue will work in some case.
I'm even sure that it's a good idea for some case. But I don't
think it will solve all problems because:
- some nested loops will remains
- it will be hard to avoid nested loops because we generaly don't
  know if we're nested or not. The mains ep - bbs - insns loop
  is obvious but what for other loops?
- using a work list is not without problems either. For example,
  we'll have no/few control over when things are effectively be
  done. Sometimes it will be fine, sometimes it won't be acceptable.
  If during some operation, we must delete *this* element or
  add a new element *here in the list* just pushing something
  on a work list and saying "OK, it will be done some time later"
  won't solve the problem, won't keep things coherent, ...

> >
> > Look at what is done currently with instructions: when we want to 'delete'
> > an instruction we simply set it's ->bb to NULL which basically means:
> > "for now, please just ignore this instruction". In other words, instructions
> > are *never* removed from their lists, they are simply marked as being
> > deleted. You don't need to know if you're in a nested loop or not.
> > You will never have the problem with deletion on nested list walking
> > because they are never removed from the lists.
> 
> Right, but does not help the insert case.

Sure, it's another problem.
 
> > Why do you think it has been done so?
> > Do you think it's bad and it would be better to effectively remove
> > instructions from their lists like others types?
> > Do you think it would be good or even possible to avoid having
> > nested loops of instructions?
> > I don't think so.
> 
> Please, I *do* understand why it is done that way. I am trying to point out that
> did not solve all the problem if inner function want to modify the list.
> aka insert. That seems to be the point haven't come across to you.
> 
> If you know how to solve the insert case, please explain.

Well, it's not as if saying "let's do everything with work queues"
solve anything in itself. It's a idea that would need lot of patches
and big changes in a lot of code to show if it's up to its promise
(and as I explain shortly here above, I have reasons to believe
that it won't be possible to solve all the list problems with it).

For the reverse walking and insert, I haven't thought much about
it yet. I won't be surprised that it will need some change in the
ptrlist struct & macros.
Maybe it's an operation that is not common enough that trying to ban
it wouldn't be a big constraint on existing & future code.
If all the ones we have go away once everything have been converted
to using work queues then fine, but what if they don't, what if
we can't convert everything to using work queues?

On the other hand, avoiding the problem of list deletion (which seems
to be an operation much more common than reverse & insert) by marking
deleted elements is something that can be done easily, with minimal
code impact and that *will* solve *all* problems with list deletion
(but yes, only list deletion).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Thu, 03 Aug 2017 23:48:59 +0000
Message-ID: <CANeU7Q=nH-mfJ4=ggHhN2xCS9OPHZhUPPXkXd9HGoc6gEhGm7w () mail ! gmail ! com>
--------------------
On Thu, Aug 3, 2017 at 6:18 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Wed, Aug 02, 2017 at 08:50:14PM -0400, Christopher Li wrote:
>> On Wed, Aug 2, 2017 at 7:44 PM, Luc Van Oostenryck
>> <luc.vanoostenryck@gmail.com> wrote:
>> >> http://marc.info/?l=linux-sparse&m=149987902920449&w=3
>> >> ==========quote================
>> >> Even Luc's suggestion for "mark and sweep" to delete the ptrlist
>> >> is not going to help with the nested loop split. I will add that check.
>> >> I don't expect new offenders but let's make sure about it.
>> >> ==========end quote=============
>> >
>> > I don't think you understood what I meant.
>>
>> I don't think so. Can you please explain?
>>
>> Let's give it an example on the insert case.
>
> Yes yes.
> I already said the 7th July that reverse list walking and list
> splitting will be another beast but the subject of this patch
> is the *deletion* of elements from lists.

The text you quote from me clearing is discussing node split here.
" nested loop *split*". Even though the title of the email was original
about delete. The discussion expand to split because I haven't realize
that is a problem earlier. I consider this as the same category delete.
It is basically looping and modify the list at the same time.
I want to find a solution to solve this both situations.

> We don't have to pack all lists.
> The ones that we pack can be packed at some specific place/moment.

Right, we need to make sure the packing *never* call from the same list
looping body. There is no easy way to find out this did not happen.

>> I am thinking breaking the recursive calling into work queue.
>> Then there is no nest loop. If you known why that will not work,
>> please point out. I do assume I can convert the recursive call
>> to non recursive using work queue. Again I haven't dig very deep yet.
>
> Oh, I'm sure that using a work queue will work in some case.
> I'm even sure that it's a good idea for some case. But I don't
> think it will solve all problems because:
> - some nested loops will remains

Can you give an example what nest looping will have to remain.

Converting recursive call into work queue without recursive
is pretty stander algorithm. In theory, as long as you defer
the inner loop calling into the work queue. It can always
avoid the nest looping. In the extreme case you can think
the work queue holding a copy of the list and move the inner
loop body to the outer work queue.

In reality, we don't want to move every thing into work queue.
I think the loop just observe. Defer the modification into work queue
is relative conceptually clean.

> - it will be hard to avoid nested loops because we generaly don't
>   know if we're nested or not. The mains ep - bbs - insns loop

We don't mind nested looping as long as we don't modify it.
We can always know that we are about to modify the bb or insns.
That is a good place to move to the work queue.

My mental model is that, have the detect and modify phase.
The detect phase do all the looping as needed. Look but don't touch.
The modify request is push into work queue and execute after the
loop has been done.

>   is obvious but what for other loops?
> - using a work list is not without problems either. For example,
>   we'll have no/few control over when things are effectively be
>   done. Sometimes it will be fine, sometimes it won't be acceptable.
>   If during some operation, we must delete *this* element or
>   add a new element *here in the list* just pushing something
>   on a work list and saying "OK, it will be done some time later"
>   won't solve the problem, won't keep things coherent, ...

That usually means you have some other things need to defer as well.
You don't have to do it on the spot on the loop. Have a work queue is
actually easier to reason and enforce such ordering.
You can consider our current CSE loop as a poor form of work queue.
It just have one bit of flag for each stage. It does not point to which
insn need to be changed.

You can think it this way, the delete mark and sweep is just another way
to defer the delete as well. In the extreme case, we defer to never delete.

>>
>> If you know how to solve the insert case, please explain.
>
> Well, it's not as if saying "let's do everything with work queues"
> solve anything in itself. It's a idea that would need lot of patches
> and big changes in a lot of code to show if it's up to its promise
> (and as I explain shortly here above, I have reasons to believe
> that it won't be possible to solve all the list problems with it).

Right. It need a lot of discussion and patch experiment. Definitely
after the release.

As I said in the other email. If you have better  patch to solve the
nest loop delete on pseudo list for RC5. Feel free to replace the
current one on sparse. I am aware of the current solution is not perfect.
It can iterate on deleted ptr entry.

>
> For the reverse walking and insert, I haven't thought much about
> it yet. I won't be surprised that it will need some change in the
> ptrlist struct & macros.
> Maybe it's an operation that is not common enough that trying to ban
> it wouldn't be a big constraint on existing & future code.

I think that is let the tail wag the dog. Plus, I can demonstrate,
node split in FOR_EACH_PTR() can also have incorrect behavior as well.
Basically node split will change list->list[] and list->nr. That can have
impact on forward iteration too. The reverse one is just more obvious.


> If all the ones we have go away once everything have been converted
> to using work queues then fine, but what if they don't, what if
> we can't convert everything to using work queues?

We will have to use bigger hammer.  In short, it is going to be ugly.
e.g. have the list node has ref count and a pending change single list.

>
> On the other hand, avoiding the problem of list deletion (which seems
> to be an operation much more common than reverse & insert) by marking
> deleted elements is something that can be done easily, with minimal
> code impact and that *will* solve *all* problems with list deletion
> (but yes, only list deletion).

Yes, I consider that as a short term thing until we find a better way to handle
more general modification including insert.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Fri, 04 Aug 2017 00:41:12 +0000
Message-ID: <20170804004110.ctq3w6lcv5jclur7 () ltop ! local>
--------------------
On Thu, Aug 03, 2017 at 07:48:59PM -0400, Christopher Li wrote:
> On Thu, Aug 3, 2017 at 6:18 AM, Luc Van Oostenryck wrote:
> > We don't have to pack all lists.
> > The ones that we pack can be packed at some specific place/moment.
> 
> Right, we need to make sure the packing *never* call from the same list
> looping body. There is no easy way to find out this did not happen.
> 
> >> I am thinking breaking the recursive calling into work queue.
> >> Then there is no nest loop. If you known why that will not work,
> >> please point out. I do assume I can convert the recursive call
> >> to non recursive using work queue. Again I haven't dig very deep yet.
> >
> > Oh, I'm sure that using a work queue will work in some case.
> > I'm even sure that it's a good idea for some case. But I don't
> > think it will solve all problems because:
> > - some nested loops will remains
> 
> Can you give an example what nest looping will have to remain.

Can you give the assurance that none will remains? 

I said "I think that ..." and of course, I have reasons to
think so. It was explained here under.

> Converting recursive call into work queue without recursive
> is pretty stander algorithm. In theory, as long as you defer
> the inner loop calling into the work queue. It can always
> avoid the nest looping. In the extreme case you can think
> the work queue holding a copy of the list and move the inner
> loop body to the outer work queue.

*standard algorithm*, *in theory*, ...
 
> In reality, we don't want to move every thing into work queue.
> I think the loop just observe. Defer the modification into work queue
> is relative conceptually clean.
> 
> > - it will be hard to avoid nested loops because we generaly don't
> >   know if we're nested or not. The mains ep - bbs - insns loop
> 
> We don't mind nested looping as long as we don't modify it.
> We can always know that we are about to modify the bb or insns.
> That is a good place to move to the work queue.
> 
> My mental model is that, have the detect and modify phase.
> The detect phase do all the looping as needed. Look but don't touch.
> The modify request is push into work queue and execute after the
> loop has been done.
> 
> >   is obvious but what for other loops?
> > - using a work list is not without problems either. For example,
> >   we'll have no/few control over when things are effectively be
> >   done. Sometimes it will be fine, sometimes it won't be acceptable.
> >   If during some operation, we must delete *this* element or
> >   add a new element *here in the list* just pushing something
> >   on a work list and saying "OK, it will be done some time later"
> >   won't solve the problem, won't keep things coherent, ...
> 
> That usually means you have some other things need to defer as well.
> You don't have to do it on the spot on the loop. Have a work queue is
> actually easier to reason and enforce such ordering.

You have all the advantages to decouple things and
you have all the disadvantges to have decoupled things.
It's not a B&W thing.

> > Well, it's not as if saying "let's do everything with work queues"
> > solve anything in itself. It's a idea that would need lot of patches
> > and big changes in a lot of code to show if it's up to its promise
> > (and as I explain shortly here above, I have reasons to believe
> > that it won't be possible to solve all the list problems with it).
> 
> Right. It need a lot of discussion and patch experiment. Definitely
> after the release.

I think you very seriously underestimate the amount of work that will
need to be done.
 
> As I said in the other email. If you have better  patch to solve the
> nest loop delete on pseudo list for RC5. Feel free to replace the
> current one on sparse. I am aware of the current solution is not perfect.
> It can iterate on deleted ptr entry.

I just send a patch.
It's not very pretty and is only lightly tested but IMO it's vastly
superior to the duplication of list.

> > For the reverse walking and insert, I haven't thought much about
> > it yet. I won't be surprised that it will need some change in the
> > ptrlist struct & macros.
> > Maybe it's an operation that is not common enough that trying to ban
> > it wouldn't be a big constraint on existing & future code.
> 
> I think that is let the tail wag the dog. Plus, I can demonstrate,
> node split in FOR_EACH_PTR() can also have incorrect behavior as well.

Yes yes, we know that since the beginning.

> > If all the ones we have go away once everything have been converted
> > to using work queues then fine, but what if they don't, what if
> > we can't convert everything to using work queues?
> 
> We will have to use bigger hammer.  In short, it is going to be ugly.
> e.g. have the list node has ref count and a pending change single list.

Other solutions exist :)
 
> > On the other hand, avoiding the problem of list deletion (which seems
> > to be an operation much more common than reverse & insert) by marking
> > deleted elements is something that can be done easily, with minimal
> > code impact and that *will* solve *all* problems with list deletion
> > (but yes, only list deletion).
> 
> Yes, I consider that as a short term thing until we find a better way to handle
> more general modification including insert.

Good to hear that.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Fri, 04 Aug 2017 02:22:34 +0000
Message-ID: <CANeU7Q=qSLDM99=S3btE1OqZ_n_nHChtYvqi8H_48EHhc04JkA () mail ! gmail ! com>
--------------------
On Thu, Aug 3, 2017 at 8:41 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>>
>> Can you give an example what nest looping will have to remain.
>
> Can you give the assurance that none will remains?

I can have the ptr ref count patch to check if such thing
happen. But I am sure that is not what you are asking :-)

If you follow the observe and modify model. Put the modify
stage on the outer loop. Modify only one thing at  a time.
Then it is easy to reason weather "nest loop modify" exist.

What you are asking in more general setting is not going to
have trivial answer any way. It is equivalent of the truing halting
problem.

On the other hand, if you want to disprove this, you only need
one counter example.


>> Converting recursive call into work queue without recursive
>> is pretty stander algorithm. In theory, as long as you defer
>> the inner loop calling into the work queue. It can always
>> avoid the nest looping. In the extreme case you can think
>> the work queue holding a copy of the list and move the inner
>> loop body to the outer work queue.
>
> *standard algorithm*, *in theory*, ...

I am actually don't worry about weather it can be done or not.
I am sure you don't need me to google converting recursion
to iteration for you.

The question is weather it can be done on sparse cleanly.
It is hard to say without trying.


> You have all the advantages to decouple things and
> you have all the disadvantges to have decoupled things.
> It's not a B&W thing.

It is a white-gray-black thing if you know what I mean :-)
Black is the terminate condition.

>> > Well, it's not as if saying "let's do everything with work queues"
>> > solve anything in itself. It's a idea that would need lot of patches
>> > and big changes in a lot of code to show if it's up to its promise
>> > (and as I explain shortly here above, I have reasons to believe
>> > that it won't be possible to solve all the list problems with it).
>>
>> Right. It need a lot of discussion and patch experiment. Definitely
>> after the release.
>
> I think you very seriously underestimate the amount of work that will
> need to be done.

I realize there will be a lot of change. But actually sparse will need ssa
version of the dead code removal (correctness) and ssa version of constant
propagation any way. (performance, current we scan the whole insn list
to find out
optimization opportunity). A lot of similar algorithm already using work
queue. Some rewrites is expected as far as I can tell.

> I just send a patch.
> It's not very pretty and is only lightly tested but IMO it's vastly
> superior to the duplication of list.

I haven't see it. I saw there is an constant expression patch on the
mailing list.

>> I think that is let the tail wag the dog. Plus, I can demonstrate,
>> node split in FOR_EACH_PTR() can also have incorrect behavior as well.
>
> Yes yes, we know that since the beginning.

Then why ban reverse ptr loop? It is not going to help avoid the bad
situation.

>> We will have to use bigger hammer.  In short, it is going to be ugly.
>> e.g. have the list node has ref count and a pending change single list.
>
> Other solutions exist :)

Yes, idea and patch welcome.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Fri, 04 Aug 2017 14:48:35 +0000
Message-ID: <CANeU7Qk8LrOG7+n3=r0B7m+CK6DTNeKs9cWzoZKTzckEz_96Fw () mail ! gmail ! com>
--------------------
On Fri, Aug 4, 2017 at 6:38 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> It was a rethorical question as a reponse to your own question
> because your own asking to show something while we're talking
> design and potentiality doesn't help at all.

That is exactly the feeling I am getting from you. You said some thing
might not work. I want to find out exactly what do you have in mind might
not work.  Otherwise the conversion is base on doubt is not very
useful. I want details. This goes both ways. You can also ask me to clarify
more details on certain things in my mental model.
>
> 1) Converting a recursive algo to an iterative one is not always
>    a good solution, for example the iterative one can be much
>    more complex/less elegant. You may also need more memory
>    (because you often need to store additional info).
>    A typical example is searching in a tree: it can be done
>    with iteration but it's generaly not done because the
>    recursive version is so much simpler & elegant (and probably
>    efficient too).

In my observe and modify model, the traverse of a tree can use
recursive, even on the same ptrlist. It is the modify get deferred.
I think I mention that observe and modify in previous email already.
So what you are describing above is not a good example to against it.

> 2) Converting something to a work queue is not the same as
>    converting recursion to iteration anyway.
>    Recursion vs. iteration is something about how walking through
>    a data structure. Using a work queue is about how/when doing an
>    operation on an object.

You walk the graph to do some thing. That is given. Nobody walk the graph
for the sake of just walking the graph. The optimize can be model
as an algorithm walk the graph and make modification of the graph.
Is that a fair statement?

>
> An example among other of complications you can have when converting
> to work queue is something like:
> Imagine you're iterating through a list of instruction checking/
> searching after something. If found, you want to do an operation
> on the instruction just found.

Now we are talking.

> Sound like something for a work queue, right? Just put the
> object you found in the work queue and let do the operation later.
> Now what if the operation is about inserting another instruction
> just before the one just found (like done when adding death notes)?
> - if you do it immediatly, you have the context of the instruction
>   and inserting the death notes is easy/cheap

Here you make some assumption that you can't save the context of
the instruction in the work queue. That is not necessary true. In
my mental model, the work queue will contain the context of what
needs to be done, e.g. the pointer to the instruct. Other context
if needed. I want to know more about what context you can't save.

BTW, most of the context can be found on the graph does not
need to save in to work queue.

Take simplify_branch_branch for example, when you know this
instruction should be simplified, there is very little information
need to be save in the work queue. Basically we can start with
call arguments to rewrite_branch(), go from there.

> - if you do the insertion later when processing the work queue
>   you won't have anymore the context of the instruction
>   and to insert the death note you will first have to
>   search after it (to have the context back) before you will
>   be able to do the insertion and this search will cost you.

Again, I don't have a clear picture of what context you are talking
about. Please clarify. If it is the instruction before this instruction,
I can't image why I need it. If really need it I can still cache it or
search it in the bb->insns list.

BTW, my impression is that, the algorithm "constant propagation using ssa"
is such an example what you are describing here. In the constant
propagation, you first find the instruction that use constant.
Then you find out if that instruction can be simplify as constant.
Next thing is put the instruction using of this simplify instruction result
into the queue to see if they can be simplify as well.

It is actually a lot better than our current approach to rescan the
whole instruction list just to find out, oh, we got some new instruction
have constant input now (due to last round constant propagation).

> It's just an example but there is a whole class of similar situations.
> Delaying thing by moving it to a work queue will also have negative
> impact on cache (but in a way, it's also a problem of having lost the
> context).

Caching, maybe. But I don't think caching is a strong point to against it.
I am just a system guy playing catch up game on compiler designs. The more
I read, the more I find out using work queue is a very common
thing amount those classic optimization algorithms.

> And again, I'm not telling that using workqueue is never a good solution,
> I'm saying that most probably it won't always be a good solution.

My reading is that, "I have doubt but I can't articulate precisely why it
is the case." Fill in more detail we can have more discussion.

Granted, no algorithm is *always" a good solution to all problem.
As I express in my previous email, I have no doubt this can be done.
The question is weather it can be done *clean* enough for sparse.

When we introduce "dead code elimination using ssa", work queue like
frame work will be needed any way.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH RFC] Let pseudo->users loop on duplicate version of list
Date: Fri, 04 Aug 2017 16:58:41 +0000
Message-ID: <20170804165839.shbkk2eb7w743nri () ltop ! local>
--------------------
On Fri, Aug 04, 2017 at 10:48:35AM -0400, Christopher Li wrote:
> On Fri, Aug 4, 2017 at 6:38 AM, Luc Van Oostenryck wrote:
> > It was a rethorical question as a reponse to your own question
> > because your own asking to show something while we're talking
> > design and potentiality doesn't help at all.
> 
> That is exactly the feeling I am getting from you. You said some thing
> might not work. I want to find out exactly what do you have in mind might
> not work.  Otherwise the conversion is base on doubt is not very
> useful.

Replace 'doubt' by 'warning' and it give already another sense to it.
My whole message has always been the same: "Warning, it's not so easy
or obvious and I have reasons to think that it won't always be possible
or desirable (so it may be good to also think about alternative or to
somehow accept thet idea that maybe not all cases will be solved the
same way".

> I want details. This goes both ways. You can also ask me to clarify
> more details on certain things in my mental model.

You can ask details about an existing implementation, you can ask
details about some idea already well elaborated. 
You can't ask details about something that by nature have not yet details,
but I have already tried to give you all sort of indices that would
give some matter to think about.

> > 1) Converting a recursive algo to an iterative one is not always
> >    a good solution, for example the iterative one can be much
> >    more complex/less elegant. You may also need more memory
> >    (because you often need to store additional info).
> >    A typical example is searching in a tree: it can be done
> >    with iteration but it's generaly not done because the
> >    recursive version is so much simpler & elegant (and probably
> >    efficient too).
> 
> In my observe and modify model, the traverse of a tree can use
> recursive, even on the same ptrlist.

When you're searching in a (binary) tree, at some point you will need
to backtrack, to return to some previous branching point. The usual
way to do that is to use recursion and the branching point is
implicitely stored in the stack. You can do the same without recursion,
without using the call stack but then you need to store info about the
branching point.
It's an example that this sort of changes is no for free.

> > 2) Converting something to a work queue is not the same as
> >    converting recursion to iteration anyway.
> >    Recursion vs. iteration is something about how walking through
> >    a data structure. Using a work queue is about how/when doing an
> >    operation on an object.
> 
> You walk the graph to do some thing. That is given. Nobody walk the graph
> for the sake of just walking the graph. The optimize can be model
> as an algorithm walk the graph and make modification of the graph.
> Is that a fair statement?

Sorry, I don't understand what you mean. 

> > An example among other of complications you can have when converting
> > to work queue is something like:
> > Imagine you're iterating through a list of instruction checking/
> > searching after something. If found, you want to do an operation
> > on the instruction just found.
> 
> Now we are talking.
> 
> > Sound like something for a work queue, right? Just put the
> > object you found in the work queue and let do the operation later.
> > Now what if the operation is about inserting another instruction
> > just before the one just found (like done when adding death notes)?
> > - if you do it immediatly, you have the context of the instruction
> >   and inserting the death notes is easy/cheap
> 
> Here you make some assumption that you can't save the context of
> the instruction in the work queue.

No, I don't make such assumption, it's an example showing that not
doing things there may have a cost. Saving the context is such a cost.

> That is not necessary true. In
> my mental model, the work queue will contain the context of what
> needs to be done, e.g. the pointer to the instruct. Other context
> if needed. I want to know more about what context you can't save.

I never said you can't save context.
On the contrary I've said that you'll most probably have to store
some context to be able to do things in a deferred way and this
will have a cost (and I use here the word 'context' in a very general
abstract meaning).

> BTW, most of the context can be found on the graph does not
> need to save in to work queue.
> 
> Take simplify_branch_branch for example, when you know this
> instruction should be simplified, there is very little information
> need to be save in the work queue.

Absolutely, in this example yes.
In some others examples, it is less so.

> > - if you do the insertion later when processing the work queue
> >   you won't have anymore the context of the instruction
> >   and to insert the death note you will first have to
> >   search after it (to have the context back) before you will
> >   be able to do the insertion and this search will cost you.
> 
> Again, I don't have a clear picture of what context you are talking
> about.

You have an instruction and you need to insert another instruction
in front of it. If you do that while you was searching after this
instruction, it's very easy because you have the head-list-nr trio
implicitely available via the ptrlist macros. This trio is here
the context you need in order to efficiently insert an instruction
in front ot it.

Now, for some reasons you want to defer this instruction.
What will you put in the work queue?
- the pointer to the instruction?
  then to insert you will need to search again in the list until
  you found the instruction. At this point you will have back
  the context needed to do the insertion but you had to do a search.
- the pointer to where the instruction stored in the list?
  then you can easily exchange this instruction with another one
  but how will this be usefull to the insertion? Well sure,
  with the pointer you can get back the original head-list-nr
  but is this usefull here? If you store somewhere the instruction
  pointer pointer, in practice that mean that the list that contain
  it become immutable (presumably you also hold pointers for the
  neighbour instructions). The only thing that can work at this point
  is a normal liked list, nor the block-based ptrlist.
  Is that a problem? Maybe, maybe not much.

> Please clarify. If it is the instruction before this instruction,
> I can't image why I need it. If really need it I can still cache it or
> search it in the bb->insns list.
> 
> BTW, my impression is that, the algorithm "constant propagation using ssa"
> is such an example what you are describing here. In the constant
> propagation, you first find the instruction that use constant.
> Then you find out if that instruction can be simplify as constant.
> Next thing is put the instruction using of this simplify instruction result
> into the queue to see if they can be simplify as well.

No, because in this case each instruction is still independend, you 
don't need to know anything about the surrounding instructions.
So it's a case where it should be easy to convert it.
The example for the deathnotes insertion is not like this.

> > It's just an example but there is a whole class of similar situations.
> > Delaying thing by moving it to a work queue will also have negative
> > impact on cache (but in a way, it's also a problem of having lost the
> > context).
> 
> Caching, maybe. But I don't think caching is a strong point to against it.
> I am just a system guy playing catch up game on compiler designs. The more
> I read, the more I find out using work queue is a very common
> thing amount those classic optimization algorithms.
> 
> > And again, I'm not telling that using workqueue is never a good solution,
> > I'm saying that most probably it won't always be a good solution.
> 
> My reading is that, "I have doubt but I can't articulate precisely why it
> is the case." Fill in more detail we can have more discussion.

If by "I have doubt" you understand "I have doubt about using it
systematically to avoid problems with nested lists", you would be
quite close. If you mean instead "I have doubt about using
it preferably (for cleanless and effective solution to avoid problems
with nested lists" you would be very wrong.

> Granted, no algorithm is *always" a good solution to all problem.
> As I express in my previous email, I have no doubt this can be done.

You have no doubts that it can be done everywhere in sparse to avoid
problems with nested lists or you have no doubts that it can be
done at least in some or most case?

Like I have already told since the beginning, I have doubts about doing
it everywhere and I have already explained why (or at least tried to).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 0/2] split OP_BR between OP_BR & OP_CBR ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 0/2] split OP_BR between OP_BR & OP_CBR
Date: Tue, 28 Feb 2017 13:30:26 +0000
Message-ID: <20170228133028.45237-1-luc.vanoostenryck () gmail ! com>
--------------------
This series introduces a new instruction opcode (OP_CBR)
for conditional branches. Previously both conditional and
non-conditional branches used the OP_BR opcode which is
now reserved for non-conditional branches.

The motivation is the correctness of the test between
the two kind of branches and an added benefit is the
simplicity of this test now.


Changes since v1:
- add missing '/* fall through */' 
- convert 2 more tests of ->cond/->bb_{true,false}
  into tests of ->opcode == OP_CBR/OP_BR

Luc Van Oostenryck (2):
  split OP_BR between unconditional & conditional: OP_CBR
  remove unused helper is_branch_goto()

 example.c                       |   2 +
 flow.c                          |  17 +++--
 linearize.c                     |  14 +++--
 linearize.h                     |   5 +-
 liveness.c                      |   3 +-
 simplify.c                      |  15 ++---
 sparse-llvm.c                   |  25 ++++----
 validation/loop-linearization.c | 136 ++++++++++++++++++++++++++++++++++++++++
 8 files changed, 179 insertions(+), 38 deletions(-)
 create mode 100644 validation/loop-linearization.c

-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 1/2] split OP_BR between unconditional & conditional: OP_CBR ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 1/2] split OP_BR between unconditional & conditional: OP_CBR
Date: Tue, 28 Feb 2017 13:30:27 +0000
Message-ID: <20170228133028.45237-2-luc.vanoostenryck () gmail ! com>
--------------------
OP_BR instructions exist in two flavours, relatively much
differentiated: conditional & non-conditional. One has an
operand (and thus its usage need to be cared for, must be
handled in liveness analysis, ..) the other has not; one has
two BB target, the other only one.

There is essentially no places in the code where both flavours
are handled the same. Sometimes they both must be handled but
each with their specificities but in most cases only one of
them is concerned and we need to filter out the other one.
In both cases it means that we need to check what kind we're
dealing with.

There is already a problem with this because there is
several ways to test which kind an OP_BR is and they
are not exactly equivalent:
1) testing if insn->cond is NULL
2) testing if one of insn->bb_true or ->bb_false is NULL.
There exist also an helper (is_branch_goto()) which does
the second tests but which is never used.

It appears that the first test should not be used because
in some cases an conditional OP_BR is changed into
a non-conditional one by (amongst others things) setting
it's ->cond to VOID. We should thus always use the seconds
test (which need two compares with NULL).

This could be corrected in several ways (like changing all
the places wheer the first test is used, use the helper
everywhere or never set ->cond to VOID) but the simplest
is to simply split them in two separated instructions:
OP_BR & OP_CBR, especailly given the fact that in most cases
the OP_BR was first selected by a switch (opcode).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 example.c                       |   2 +
 flow.c                          |  17 +++--
 linearize.c                     |  14 +++--
 linearize.h                     |   1 +
 liveness.c                      |   3 +-
 simplify.c                      |  15 ++---
 sparse-llvm.c                   |  25 ++++----
 validation/loop-linearization.c | 136 ++++++++++++++++++++++++++++++++++++++++
 8 files changed, 179 insertions(+), 34 deletions(-)
 create mode 100644 validation/loop-linearization.c

diff --git a/example.c b/example.c
index 24444c6c0..691e0f97c 100644
--- a/example.c
+++ b/example.c
@@ -23,6 +23,7 @@ static const char *opcodes[] = {
 	/* Terminator */
 	[OP_RET] = "ret",
 	[OP_BR] = "br",
+	[OP_CBR] = "cbr",
 	[OP_SWITCH] = "switch",
 	[OP_INVOKE] = "invoke",
 	[OP_COMPUTEDGOTO] = "jmp *",
@@ -1428,6 +1429,7 @@ static void generate_one_insn(struct instruction *insn, struct bb_state *state)
 		break;
 
 	case OP_BR:
+	case OP_CBR:
 		generate_branch(state, insn);
 		break;
 
diff --git a/flow.c b/flow.c
index 088c21785..a5332203f 100644
--- a/flow.c
+++ b/flow.c
@@ -111,7 +111,7 @@ static int try_to_simplify_bb(struct basic_block *bb, struct instruction *first,
 		br = last_instruction(source->insns);
 		if (!br)
 			continue;
-		if (br->opcode != OP_BR)
+		if (br->opcode != OP_CBR && br->opcode != OP_BR)
 			continue;
 		true = pseudo_truth_value(pseudo);
 		if (true < 0)
@@ -176,7 +176,7 @@ static int simplify_branch_branch(struct basic_block *bb, struct instruction *br
 	if (target == bb)
 		return 0;
 	insn = last_instruction(target->insns);
-	if (!insn || insn->opcode != OP_BR || insn->cond != br->cond)
+	if (!insn || insn->opcode != OP_CBR || insn->cond != br->cond)
 		return 0;
 	/*
 	 * Ahhah! We've found a branch to a branch on the same conditional!
@@ -218,7 +218,7 @@ static int simplify_branch_nodes(struct entrypoint *ep)
 	FOR_EACH_PTR(ep->bbs, bb) {
 		struct instruction *br = last_instruction(bb->insns);
 
-		if (!br || br->opcode != OP_BR || !br->bb_false)
+		if (!br || br->opcode != OP_CBR)
 			continue;
 		changed |= simplify_one_branch(bb, br);
 	} END_FOR_EACH_PTR(bb);
@@ -811,9 +811,11 @@ static int rewrite_parent_branch(struct basic_block *bb, struct basic_block *old
 		return 0;
 
 	switch (insn->opcode) {
+	case OP_CBR:
+		changed |= rewrite_branch(bb, &insn->bb_false, old, new);
+		/* fall through */
 	case OP_BR:
 		changed |= rewrite_branch(bb, &insn->bb_true, old, new);
-		changed |= rewrite_branch(bb, &insn->bb_false, old, new);
 		assert(changed);
 		return changed;
 	case OP_SWITCH: {
@@ -835,7 +837,7 @@ static struct basic_block * rewrite_branch_bb(struct basic_block *bb, struct ins
 	struct basic_block *target = br->bb_true;
 	struct basic_block *false = br->bb_false;
 
-	if (target && false) {
+	if (br->opcode == OP_CBR) {
 		pseudo_t cond = br->cond;
 		if (cond->type != PSEUDO_VAL)
 			return NULL;
@@ -886,9 +888,11 @@ static void vrfy_children(struct basic_block *bb)
 	}
 	switch (br->opcode) {
 		struct multijmp *jmp;
+	case OP_CBR:
+		vrfy_bb_in_list(br->bb_false, bb->children);
+		/* fall through */
 	case OP_BR:
 		vrfy_bb_in_list(br->bb_true, bb->children);
-		vrfy_bb_in_list(br->bb_false, bb->children);
 		break;
 	case OP_SWITCH:
 	case OP_COMPUTEDGOTO:
@@ -945,6 +949,7 @@ void pack_basic_blocks(struct entrypoint *ep)
 			switch (first->opcode) {
 			case OP_NOP: case OP_LNOP: case OP_SNOP:
 				continue;
+			case OP_CBR:
 			case OP_BR: {
 				struct basic_block *replace;
 				replace = rewrite_branch_bb(bb, first);
diff --git a/linearize.c b/linearize.c
index 99203d915..3b4741822 100644
--- a/linearize.c
+++ b/linearize.c
@@ -169,6 +169,7 @@ static const char *opcodes[] = {
 	/* Terminator */
 	[OP_RET] = "ret",
 	[OP_BR] = "br",
+	[OP_CBR] = "cbr",
 	[OP_SWITCH] = "switch",
 	[OP_INVOKE] = "invoke",
 	[OP_COMPUTEDGOTO] = "jmp *",
@@ -303,12 +304,13 @@ const char *show_instruction(struct instruction *insn)
 		if (insn->src && insn->src != VOID)
 			buf += sprintf(buf, "%s", show_pseudo(insn->src));
 		break;
+
+	case OP_CBR:
+		buf += sprintf(buf, "%s, .L%u, .L%u", show_pseudo(insn->cond), insn->bb_true->nr, insn->bb_false->nr);
+		break;
+
 	case OP_BR:
-		if (insn->bb_true && insn->bb_false) {
-			buf += sprintf(buf, "%s, .L%u, .L%u", show_pseudo(insn->cond), insn->bb_true->nr, insn->bb_false->nr);
-			break;
-		}
-		buf += sprintf(buf, ".L%u", insn->bb_true ? insn->bb_true->nr : insn->bb_false->nr);
+		buf += sprintf(buf, ".L%u", insn->bb_true->nr);
 		break;
 
 	case OP_SYMADDR: {
@@ -723,7 +725,7 @@ static void add_branch(struct entrypoint *ep, struct expression *expr, pseudo_t
 	struct instruction *br;
 
 	if (bb_reachable(bb)) {
-       		br = alloc_instruction(OP_BR, 0);
+		br = alloc_instruction(OP_CBR, 0);
 		use_pseudo(br, cond, &br->cond);
 		br->bb_true = bb_true;
 		br->bb_false = bb_false;
diff --git a/linearize.h b/linearize.h
index 5c938cd5d..2aa255154 100644
--- a/linearize.h
+++ b/linearize.h
@@ -137,6 +137,7 @@ enum opcode {
 	OP_TERMINATOR,
 	OP_RET = OP_TERMINATOR,
 	OP_BR,
+	OP_CBR,
 	OP_SWITCH,
 	OP_INVOKE,
 	OP_COMPUTEDGOTO,
diff --git a/liveness.c b/liveness.c
index 2e5139433..7461738b4 100644
--- a/liveness.c
+++ b/liveness.c
@@ -56,7 +56,8 @@ static void track_instruction_usage(struct basic_block *bb, struct instruction *
 		USES(src);
 		break;
 
-	case OP_BR: case OP_SWITCH:
+	case OP_CBR:
+	case OP_SWITCH:
 		USES(cond);
 		break;
 
diff --git a/simplify.c b/simplify.c
index 3bc9985e8..71687b940 100644
--- a/simplify.c
+++ b/simplify.c
@@ -67,7 +67,7 @@ static int if_convert_phi(struct instruction *insn)
 	 * stuff. Verify that here.
 	 */
 	br = last_instruction(source->insns);
-	if (!br || br->opcode != OP_BR)
+	if (!br || br->opcode != OP_CBR)
 		return 0;
 
 	assert(br->cond);
@@ -227,11 +227,7 @@ void kill_insn(struct instruction *insn, int force)
 		repeat_phase |= REPEAT_SYMBOL_CLEANUP;
 		break;
 
-	case OP_BR:
-		if (!insn->bb_true || !insn->bb_false)
-			break;
-		/* fall through */
-
+	case OP_CBR:
 	case OP_COMPUTEDGOTO:
 		kill_use(&insn->cond);
 		break;
@@ -266,6 +262,7 @@ void kill_insn(struct instruction *insn, int force)
 		/* ignore */
 		return;
 
+	case OP_BR:
 	default:
 		break;
 	}
@@ -1034,9 +1031,6 @@ static int simplify_branch(struct instruction *insn)
 {
 	pseudo_t cond = insn->cond;
 
-	if (!cond)
-		return 0;
-
 	/* Constant conditional */
 	if (constant(cond)) {
 		insert_branch(insn->bb, insn, cond->value ? insn->bb_true : insn->bb_false);
@@ -1052,6 +1046,7 @@ static int simplify_branch(struct instruction *insn)
 		insn->bb_false = NULL;
 		kill_use(&insn->cond);
 		insn->cond = NULL;
+		insn->opcode = OP_BR;
 		return REPEAT_CSE;
 	}
 
@@ -1181,7 +1176,7 @@ int simplify_instruction(struct instruction *insn)
 		break;
 	case OP_SEL:
 		return simplify_select(insn);
-	case OP_BR:
+	case OP_CBR:
 		return simplify_branch(insn);
 	case OP_SWITCH:
 		return simplify_switch(insn);
diff --git a/sparse-llvm.c b/sparse-llvm.c
index 3d2218ef6..9f362b3ed 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -642,19 +642,19 @@ static LLVMValueRef bool_value(struct function *fn, LLVMValueRef value)
 	return value;
 }
 
-static void output_op_br(struct function *fn, struct instruction *br)
+static void output_op_cbr(struct function *fn, struct instruction *br)
 {
-	if (br->cond) {
-		LLVMValueRef cond = bool_value(fn,
-				pseudo_to_value(fn, br, br->cond));
+	LLVMValueRef cond = bool_value(fn,
+			pseudo_to_value(fn, br, br->cond));
 
-		LLVMBuildCondBr(fn->builder, cond,
-				br->bb_true->priv,
-				br->bb_false->priv);
-	} else
-		LLVMBuildBr(fn->builder,
-			    br->bb_true ? br->bb_true->priv :
-			    br->bb_false->priv);
+	LLVMBuildCondBr(fn->builder, cond,
+			br->bb_true->priv,
+			br->bb_false->priv);
+}
+
+static void output_op_br(struct function *fn, struct instruction *br)
+{
+	LLVMBuildBr(fn->builder, br->bb_true->priv);
 }
 
 static void output_op_sel(struct function *fn, struct instruction *insn)
@@ -810,6 +810,9 @@ static void output_insn(struct function *fn, struct instruction *insn)
 	case OP_BR:
 		output_op_br(fn, insn);
 		break;
+	case OP_CBR:
+		output_op_cbr(fn, insn);
+		break;
 	case OP_SYMADDR:
 		assert(0);
 		break;
diff --git a/validation/loop-linearization.c b/validation/loop-linearization.c
new file mode 100644
index 000000000..25c6dfb87
--- /dev/null
+++ b/validation/loop-linearization.c
@@ -0,0 +1,136 @@
+extern int p(int);
+
+static int ffor(void)
+{
+	int i;
+	for (int i = 0; i < 10; i++) {
+		if (!p(i))
+			return 0;
+	}
+	return 1;
+}
+
+static int fwhile(void)
+{
+	int i = 0;
+	while (i < 10) {
+		if (!p(i))
+			return 0;
+		i++;
+	}
+	return 1;
+}
+
+static int fdo(void)
+{
+	int i = 0;
+	do {
+		if (!p(i))
+			return 0;
+	} while (i++ < 10);
+	return 1;
+}
+
+/*
+ * check-name: loop-linearization
+ * check-command: test-linearize $file
+ *
+ * check-output-start
+ffor:
+.L0:
+	<entry-point>
+	phisrc.32   %phi5(i) <- $0
+	br          .L4
+
+.L4:
+	phi.32      %r1(i) <- %phi5(i), %phi6(i)
+	setlt.32    %r2 <- %r1(i), $10
+	cbr         %r2, .L1, .L3
+
+.L1:
+	call.32     %r4 <- p, %r1(i)
+	cbr         %r4, .L2, .L5
+
+.L5:
+	phisrc.32   %phi1(return) <- $0
+	br          .L7
+
+.L2:
+	add.32      %r7 <- %r1(i), $1
+	phisrc.32   %phi6(i) <- %r7
+	br          .L4
+
+.L3:
+	phisrc.32   %phi2(return) <- $1
+	br          .L7
+
+.L7:
+	phi.32      %r5 <- %phi1(return), %phi2(return)
+	ret.32      %r5
+
+
+fwhile:
+.L8:
+	<entry-point>
+	phisrc.32   %phi11(i) <- $0
+	br          .L12
+
+.L12:
+	phi.32      %r8(i) <- %phi11(i), %phi12(i)
+	setlt.32    %r9 <- %r8(i), $10
+	cbr         %r9, .L9, .L11
+
+.L9:
+	call.32     %r11 <- p, %r8(i)
+	cbr         %r11, .L14, .L13
+
+.L13:
+	phisrc.32   %phi7(return) <- $0
+	br          .L15
+
+.L14:
+	add.32      %r14 <- %r8(i), $1
+	phisrc.32   %phi12(i) <- %r14
+	br          .L12
+
+.L11:
+	phisrc.32   %phi8(return) <- $1
+	br          .L15
+
+.L15:
+	phi.32      %r12 <- %phi7(return), %phi8(return)
+	ret.32      %r12
+
+
+fdo:
+.L16:
+	<entry-point>
+	phisrc.32   %phi16(i) <- $0
+	br          .L17
+
+.L17:
+	phi.32      %r15(i) <- %phi16(i), %phi17(i)
+	call.32     %r16 <- p, %r15(i)
+	cbr         %r16, .L18, .L20
+
+.L20:
+	phisrc.32   %phi13(return) <- $0
+	br          .L22
+
+.L18:
+	add.32      %r19 <- %r15(i), $1
+	setlt.32    %r20 <- %r15(i), $10
+	phisrc.32   %phi17(i) <- %r19
+	cbr         %r20, .L17, .L19
+
+.L19:
+	phisrc.32   %phi14(return) <- $1
+	br          .L22
+
+.L22:
+	phi.32      %r17 <- %phi13(return), %phi14(return)
+	ret.32      %r17
+
+
+ * check-output-end
+ */
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 1/8] fix crash while testing between conditional & unconditional OP_BR ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 1/8] fix crash while testing between conditional & unconditional OP_BR
Date: Sun, 29 Jan 2017 10:48:01 +0000
Message-ID: <20170129104808.2500-2-luc.vanoostenryck () gmail ! com>
--------------------
It seems that testing for a NULL insn->cond is not the right test,
what must be done is to test if either of ->bb_{true,false} is NULL.

Fixes: 556dbc8d75 ("Update usage chain for dead instructions")
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index b5cd0ea77..3dea03b5e 100644
--- a/simplify.c
+++ b/simplify.c
@@ -221,7 +221,7 @@ void kill_instruction(struct instruction *insn)
 	case OP_BR:
 		insn->bb = NULL;
 		repeat_phase |= REPEAT_CSE;
-		if (insn->cond)
+		if (insn->bb_true && insn->bb_false)
 			kill_use(&insn->cond);
 		return;
 	}
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 2/8] kill uses of replaced instructions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 2/8] kill uses of replaced instructions
Date: Sun, 29 Jan 2017 10:48:02 +0000
Message-ID: <20170129104808.2500-3-luc.vanoostenryck () gmail ! com>
--------------------
When an instruction is replaced by a pseudo, the 'usage' of its
operands should be removed too but it's not the case.

The fix consists in calling kill_use() for each operands after
the pseudo is replaced.
Not all types of instruction are considered, only those which
can be replaced by a pseudo.

The following example illustrate the situation. When looking at
the output of test-linearize, the following function:

	static int kill_add(int a, int b)
	{
		return (a + b) && 0;
	}

without the patch, gives this output:

	kill_add:
		add.32      %r3 <- %arg1, %arg2
		ret.32      $0

The 'add' instruction is obviously unneeded but nevertheless present.

Before any optimization the code was something like:

	kill_add:
		add.32      %r3 <- %arg1, %arg2
		and_bool.32 %r4 <- %r3, $0
		ret.32      %r4

During the simplification phase, the result of the 'and' instruction (%r4)
have been replaced by '0' and the instruction itself is discarded.
But '%r3' usage has not been adjusted and the further phases are not
aware that '%r3' is not needed anymore and so the 'add' instruction is kept
while not needed by anything.

With the patch the 'add' instruction is correctly discarded, giving the
expected output:

	kill_add:
		ret.32      $0

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                      | 20 +++++++++++++++
 validation/kill-replaced-insn.c | 54 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 74 insertions(+)
 create mode 100644 validation/kill-replaced-insn.c

diff --git a/simplify.c b/simplify.c
index 3dea03b5e..ed41e441a 100644
--- a/simplify.c
+++ b/simplify.c
@@ -253,6 +253,26 @@ static inline int constant(pseudo_t pseudo)
 static int replace_with_pseudo(struct instruction *insn, pseudo_t pseudo)
 {
 	convert_instruction_target(insn, pseudo);
+
+	switch (insn->opcode) {
+	case OP_SEL:
+	case OP_RANGE:
+		kill_use(&insn->src3);
+	case OP_BINARY ... OP_BINCMP_END:
+		kill_use(&insn->src2);
+	case OP_NOT:
+	case OP_NEG:
+	case OP_SYMADDR:
+	case OP_CAST:
+	case OP_SCAST:
+	case OP_FPCAST:
+	case OP_PTRCAST:
+		kill_use(&insn->src1);
+		break;
+
+	default:
+		assert(0);
+	}
 	insn->bb = NULL;
 	return REPEAT_CSE;
 }
diff --git a/validation/kill-replaced-insn.c b/validation/kill-replaced-insn.c
new file mode 100644
index 000000000..be031b6c1
--- /dev/null
+++ b/validation/kill-replaced-insn.c
@@ -0,0 +1,54 @@
+// See if the replaced operation is effectively killed or not
+
+static int kill_add(int a, int b)
+{
+	return (a + b) && 0;
+}
+
+static int kill_scast(short a)
+{
+	return ((int) a) && 0;
+}
+
+static int kill_ucast(unsigned char a)
+{
+	return ((int) a) && 0;
+}
+
+static int kill_pcast(int *a)
+{
+	return ((void*) a) && 0;
+}
+
+static int kill_fcast(double a)
+{
+	return ((int) a) && 0;
+}
+
+static int kill_select(int a)
+{
+	return (a ? 1 : 0) && 0;
+}
+
+static int kill_load(int *a)
+{
+	return *a && 0;
+}
+
+static int kill_store(int *a)
+{
+	return (*a = 1) && 0;
+}
+
+/*
+ * check-name: kill-replaced-insn
+ * check-command: test-linearize $file
+ *
+ * check-output-ignore
+ * check-output-excludes: add\\.
+ * check-output-excludes: scast\\.
+ * check-output-excludes: \\<cast\\.
+ * check-output-excludes: ptrcast\\.
+ * check-output-excludes: fpcast\\.
+ * check-output-excludes: sel\\.
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 3/8] fix killing OP_PHI instructions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 3/8] fix killing OP_PHI instructions
Date: Sun, 29 Jan 2017 10:48:03 +0000
Message-ID: <20170129104808.2500-4-luc.vanoostenryck () gmail ! com>
--------------------
Currently kill_instruction() doesn't do anything with the
sources of OP_PHI instructions. But when these instructions
are removed the 'usage' of the associated sources must also
be removed. This is not done and as result the instructions
producing the phi-sources are not optimized away as expected.

This patch fixes that by calling clear_phi() when killing a
phi-instruction.

For example, when looking at the output of test-linearize,
the following function:
	void foo(int a, int *b, unsigned int g);
	void foo(int a, int *b, unsigned int g)
	{
		int d = 0;

		if ((!a || *b) && g)
			d = 16;
		else
			d = 8;
	}

gives this output without the patch:
	foo:
		br          %arg1, .L1, .L2
	.L1:
		phisrc.32   %phi1 <- $1
		br          .L3
	.L2:
		load.32     %r3 <- 0[%arg2]
		phisrc.32   %phi2 <- %r3
		br          .L3
	.L3:
		ret

The 'phisrc' instructions are obviously unneeded but nevertheless present.

With the patch, the output is much closer to what's expected:
	foo:
		br          %arg1, .L3, .L2
	.L2:
		load.32     %r3 <- 0[%arg2]
		br          .L3
	.L3:
		ret

Note 1) The 'load' instruction is also dead and should have been removed
but it's separate problem.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                 |  1 +
 validation/kill-phi-node.c | 18 ++++++++++++++++++
 2 files changed, 19 insertions(+)
 create mode 100644 validation/kill-phi-node.c

diff --git a/simplify.c b/simplify.c
index ed41e441a..90998021d 100644
--- a/simplify.c
+++ b/simplify.c
@@ -202,6 +202,7 @@ void kill_instruction(struct instruction *insn)
 		return;
 
 	case OP_PHI:
+		clear_phi(insn);
 		insn->bb = NULL;
 		repeat_phase |= REPEAT_CSE;
 		return;
diff --git a/validation/kill-phi-node.c b/validation/kill-phi-node.c
new file mode 100644
index 000000000..88de9f962
--- /dev/null
+++ b/validation/kill-phi-node.c
@@ -0,0 +1,18 @@
+void foo(int a, int *b, unsigned int g);
+void foo(int a, int *b, unsigned int g)
+{
+	int d = 0;
+
+	if ((!a || *b) && g)
+		d = 16;
+	else
+		d = 8;
+}
+
+/*
+ * check-name: kill-phi-node
+ * check-command: test-linearize $file
+ *
+ * check-output-ignore
+ * check-output-excludes: phisrc\\.
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 5/8] fix killing OP_SELECT ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 5/8] fix killing OP_SELECT
Date: Sun, 29 Jan 2017 10:48:05 +0000
Message-ID: <20170129104808.2500-6-luc.vanoostenryck () gmail ! com>
--------------------
Currently kill_instruction() doesn't do anything with the
operands of select instructions (OP_SELECT). But when these
instructions are removed we must also remove the operands 'usage'.
Without this the instructions which provides the select's
operands are not optimized away as expected.

This patch fixes this by doing for OP_SELECTs the basic
kill_instruction() for ternary instruction, like OP_RANGE.

As an example, when looking at the output of test-linearize,
the following code:

	void foo(int x)
	{
		unsigned int ui;

		ui = x + 1;
		ui = ui ? 0 : 1;
	}

gives this output:

	foo:
		add.32      %r2 <- %arg1, $1
		ret

Since the result of the ?: is never used, the whole code should be
optimized away. The 'select' instruction itself is indeed discarded
but the 'add' is not.

With the patch, the output is much closer to what's expected:

	foo:
		ret

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c               |  1 +
 validation/kill-select.c | 16 ++++++++++++++++
 2 files changed, 17 insertions(+)
 create mode 100644 validation/kill-select.c

diff --git a/simplify.c b/simplify.c
index fc6bae791..1e4aa63b4 100644
--- a/simplify.c
+++ b/simplify.c
@@ -216,6 +216,7 @@ void kill_instruction(struct instruction *insn)
 		repeat_phase |= REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
 		return;
 
+	case OP_SEL:
 	case OP_RANGE:
 		insn->bb = NULL;
 		repeat_phase |= REPEAT_CSE;
diff --git a/validation/kill-select.c b/validation/kill-select.c
new file mode 100644
index 000000000..445472be8
--- /dev/null
+++ b/validation/kill-select.c
@@ -0,0 +1,16 @@
+void foo(int x);
+void foo(int x)
+{
+	unsigned int ui;
+
+	ui = x + 1;
+	ui = ui ? 0 : 1;
+}
+
+/*
+ * check-name: kill-select
+ * check-command: test-linearize $file
+ *
+ * check-output-ignore
+ * check-output-excludes: add\\.
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 6/8] fix killing OP_COMPUTEDGOTO ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 6/8] fix killing OP_COMPUTEDGOTO
Date: Sun, 29 Jan 2017 10:48:06 +0000
Message-ID: <20170129104808.2500-7-luc.vanoostenryck () gmail ! com>
--------------------
Currently kill_instruction() doesn't do anything with the
operands of computed gotos (OP_COMPUTEDGOTO). But when these
instructions are removed we must also remove the operands 'usage'.
Without this some instructions, which provides the select's
operands, are not optimized away as expected.

The fix consists by killing it's operand much like what is done for
conditional branches.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c                     |  1 +
 validation/kill-computedgoto.c | 17 +++++++++++++++++
 2 files changed, 18 insertions(+)
 create mode 100644 validation/kill-computedgoto.c

diff --git a/simplify.c b/simplify.c
index 1e4aa63b4..690fdc4e8 100644
--- a/simplify.c
+++ b/simplify.c
@@ -225,6 +225,7 @@ void kill_instruction(struct instruction *insn)
 		kill_use(&insn->src3);
 		return;
 	case OP_BR:
+	case OP_COMPUTEDGOTO:
 		insn->bb = NULL;
 		repeat_phase |= REPEAT_CSE;
 		if (insn->bb_true && insn->bb_false)
diff --git a/validation/kill-computedgoto.c b/validation/kill-computedgoto.c
new file mode 100644
index 000000000..3b3ed8ff2
--- /dev/null
+++ b/validation/kill-computedgoto.c
@@ -0,0 +1,17 @@
+void foo(int a);
+void foo(int a)
+{
+	void *l = &&end + 3;
+
+end:
+	if (a * 0)
+		goto *l;
+}
+
+/*
+ * check-name: kill-computedgoto
+ * check-command: test-linearize $file
+ *
+ * check-output-ignore
+ * check-output-excludes: add\\.
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 7/8] explicitely ignore killing OP_ENTRY ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 7/8] explicitely ignore killing OP_ENTRY
Date: Sun, 29 Jan 2017 10:48:07 +0000
Message-ID: <20170129104808.2500-8-luc.vanoostenryck () gmail ! com>
--------------------
It doesn't change anything, it's more for documentation
purpose.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/simplify.c b/simplify.c
index 690fdc4e8..66550fa3d 100644
--- a/simplify.c
+++ b/simplify.c
@@ -231,6 +231,10 @@ void kill_instruction(struct instruction *insn)
 		if (insn->bb_true && insn->bb_false)
 			kill_use(&insn->cond);
 		return;
+
+	case OP_ENTRY:
+		/* ignore */
+		return;
 	}
 }
 
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 8/8] cleanup kill_instruction() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2 8/8] cleanup kill_instruction()
Date: Sun, 29 Jan 2017 10:48:08 +0000
Message-ID: <20170129104808.2500-9-luc.vanoostenryck () gmail ! com>
--------------------
No functional changes:
- factorize out the '->bb = NULL' and '|= REPEAT_CSE'.
- fall through the switch cases for ternary/bunary/unary ops.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 47 +++++++++++++++++++++--------------------------
 1 file changed, 21 insertions(+), 26 deletions(-)

diff --git a/simplify.c b/simplify.c
index 66550fa3d..f62fc83a1 100644
--- a/simplify.c
+++ b/simplify.c
@@ -188,54 +188,49 @@ void kill_instruction(struct instruction *insn)
 		return;
 
 	switch (insn->opcode) {
+	case OP_SEL:
+	case OP_RANGE:
+		kill_use(&insn->src3);
+		/* fall through */
+
 	case OP_BINARY ... OP_BINCMP_END:
-		insn->bb = NULL;
-		kill_use(&insn->src1);
 		kill_use(&insn->src2);
-		repeat_phase |= REPEAT_CSE;
-		return;
+		/* fall through */
 
 	case OP_CAST:
 	case OP_SCAST:
 	case OP_FPCAST:
 	case OP_PTRCAST:
 	case OP_NOT: case OP_NEG:
-		insn->bb = NULL;
 		kill_use(&insn->src1);
-		repeat_phase |= REPEAT_CSE;
-		return;
+		break;
 
 	case OP_PHI:
 		clear_phi(insn);
-		insn->bb = NULL;
-		repeat_phase |= REPEAT_CSE;
-		return;
+		break;
 
 	case OP_SYMADDR:
-		insn->bb = NULL;
-		repeat_phase |= REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
-		return;
+		repeat_phase |= REPEAT_SYMBOL_CLEANUP;
+		break;
 
-	case OP_SEL:
-	case OP_RANGE:
-		insn->bb = NULL;
-		repeat_phase |= REPEAT_CSE;
-		kill_use(&insn->src1);
-		kill_use(&insn->src2);
-		kill_use(&insn->src3);
-		return;
 	case OP_BR:
+		if (!insn->bb_true || !insn->bb_false)
+			break;
+		/* fall through */
+
 	case OP_COMPUTEDGOTO:
-		insn->bb = NULL;
-		repeat_phase |= REPEAT_CSE;
-		if (insn->bb_true && insn->bb_false)
-			kill_use(&insn->cond);
-		return;
+		kill_use(&insn->cond);
+		break;
 
 	case OP_ENTRY:
+	default:
 		/* ignore */
 		return;
 	}
+
+	insn->bb = NULL;
+	repeat_phase |= REPEAT_CSE;
+	return;
 }
 
 /*
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] Allow casting to a restricted type if !restricted_value ===

From: Edward Cree <ecree () solarflare ! com>
To: linux-sparse
Subject: [PATCH v2] Allow casting to a restricted type if !restricted_value
Date: Tue, 21 Feb 2017 12:22:18 +0000
Message-ID: <05504e5f-16ab-276b-b53e-77f71102a154 () solarflare ! com>
--------------------
If the operand of a cast to a restricted type is an unrestricted value,
 the cast should not produce a warning, since an equivalent implied cast
 (e.g. in an initialiser) would not do so.

Also adds a test case (bitwise-cast.c) testing implicit and explicit
 conversions of zero and nonzero integers to bitwise type.

Signed-off-by: Edward Cree <ecree@solarflare.com>
---
v2: combined change and test case into one patch;
    removed RFC tags.

 evaluate.c                |  2 +-
 validation/bitwise-cast.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 45 insertions(+), 1 deletion(-)
 create mode 100644 validation/bitwise-cast.c

diff --git a/evaluate.c b/evaluate.c
index e350c0c..8e855b1 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2771,7 +2771,7 @@ static struct symbol *evaluate_cast(struct expression *expr)
 		t2 = unfoul(t2);
 
 	if (t1 != t2) {
-		if (class1 & TYPE_RESTRICT)
+		if ((class1 & TYPE_RESTRICT) && restricted_value(target, t1))
 			warning(expr->pos, "cast to %s",
 				show_typename(t1));
 		if (class2 & TYPE_RESTRICT)
diff --git a/validation/bitwise-cast.c b/validation/bitwise-cast.c
new file mode 100644
index 0000000..baeca29
--- /dev/null
+++ b/validation/bitwise-cast.c
@@ -0,0 +1,44 @@
+typedef unsigned int u32;
+typedef u32 __attribute__((bitwise)) __be32;
+
+/* Implicit casts of 0, legal */
+static __be32 foo(void)
+{
+	__be32 x = 0;
+
+	return 0;
+}
+
+/* Explicit cast of 0, legal */
+static __be32 bar(void)
+{
+	return (__be32)0;
+}
+
+/* Implicit casts of nonzero, bad */
+static __be32 baz(void)
+{
+	__be32 x = 0x2a;
+
+	return 99;
+}
+
+/* Explicit cast of nonzero, bad */
+static __be32 quux(void)
+{
+	return (__be32)1729;
+}
+
+/*
+ * check-name: conversions to bitwise types
+ * check-command: sparse -Wbitwise $file
+ * check-error-start
+bitwise-cast.c:21:20: warning: incorrect type in initializer (different base types)
+bitwise-cast.c:21:20:    expected restricted __be32 [usertype] x
+bitwise-cast.c:21:20:    got int
+bitwise-cast.c:23:16: warning: incorrect type in return expression (different base types)
+bitwise-cast.c:23:16:    expected restricted __be32
+bitwise-cast.c:23:16:    got int
+bitwise-cast.c:29:17: warning: cast to restricted __be32
+ * check-error-end
+ */
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] add __builtin functions for isinf_sign, isfinite and isnan ===

From: Logan Gunthorpe <logang () deltatee ! com>
To: linux-sparse
Subject: [PATCH v2] add __builtin functions for isinf_sign, isfinite and isnan
Date: Thu, 16 Nov 2017 23:08:17 +0000
Message-ID: <20171116230817.10011-1-logang () deltatee ! com>
--------------------
These bultins are defined by in gcc since 4.4. They are also now
used by the isinf, isfinite and isnan macros. So using them with a
newer gcc causes 'undefined identifier' errors.

Add the builtin definitions and some validation checks for these
functions.

Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
---

Changes since v1:
 * Remove math.h dependancy from validation tests. As a consequnce
   we don't test that the math functions work. (Per a request from
   Christopher.)

 lib.c                    | 3 +++
 validation/builtin_inf.c | 3 +++
 2 files changed, 6 insertions(+)

diff --git a/lib.c b/lib.c
index 4602cf8..cc740e9 100644
--- a/lib.c
+++ b/lib.c
@@ -1105,6 +1105,9 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern double __builtin_nan(const char *);\n");
 	add_pre_buffer("extern float __builtin_nanf(const char *);\n");
 	add_pre_buffer("extern long double __builtin_nanl(const char *);\n");
+	add_pre_buffer("extern int __builtin_isinf_sign(float);\n");
+	add_pre_buffer("extern int __builtin_isfinite(float);\n");
+	add_pre_buffer("extern int __builtin_isnan(float);\n");

 	/* And some __FORTIFY_SOURCE ones.. */
 	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(const void *, int);\n");
diff --git a/validation/builtin_inf.c b/validation/builtin_inf.c
index 48546e4..f09f53f 100644
--- a/validation/builtin_inf.c
+++ b/validation/builtin_inf.c
@@ -7,6 +7,9 @@ static long double li = __builtin_infl();
 static double dn = __builtin_nan("");
 static float fn = __builtin_nanf("");
 static long double ln = __builtin_nanl("");
+static int inf = __builtin_isinf_sign(0.0);
+static int fin = __builtin_isfinite(0.0);
+static int nan = __builtin_isnan(0.0);

 /*
  * check-name: __builtin INFINITY / nan()
--
2.11.0
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Logan Gunthorpe <logang () deltatee ! com>
To: linux-sparse
Subject: Re: [PATCH v2] add __builtin functions for isinf_sign, isfinite and isnan
Date: Fri, 17 Nov 2017 01:04:56 +0000
Message-ID: <f37fa631-edac-8de1-1cb4-4bd1edd807b2 () deltatee ! com>
--------------------
On 11/16/2017 5:02 PM, Christopher Li wrote:
> In the history we are having header file issue with cygwin and other compile
> environment due to sparse don't understand other system macros. It is
> better to have sparse able to run the validations test without have to fix
> every single system macro define. It is kind of expect to be broken on new
> and untested platform. There for, best to have no system header in the
> validation test.

Fair enough,

Thanks.

Logan

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2] add __builtin functions for isinf_sign, isfinite and isnan
Date: Fri, 17 Nov 2017 08:13:49 +0000
Message-ID: <20171117081348.5cdzuctwi6i3ltu6 () ltop ! local>
--------------------
On Thu, Nov 16, 2017 at 04:08:17PM -0700, Logan Gunthorpe wrote:
> These bultins are defined by in gcc since 4.4. They are also now
> used by the isinf, isfinite and isnan macros. So using them with a
> newer gcc causes 'undefined identifier' errors.
> 
> Add the builtin definitions and some validation checks for these
> functions.
> 
> Signed-off-by: Logan Gunthorpe <logang@deltatee.com>

Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

> ---
> 
> Changes since v1:
>  * Remove math.h dependancy from validation tests. As a consequnce
>    we don't test that the math functions work. (Per a request from
>    Christopher.)

It would only have tested if your <math.h> doesn't have errors.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v2] add __builtin functions for isinf_sign, isfinite and isnan
Date: Fri, 17 Nov 2017 23:28:59 +0000
Message-ID: <CAExDi1QA-NV0JYKnOzxxnkLfimzr9Bw6Q0irKxmmnByfP5XeWA () mail ! gmail ! com>
--------------------
On Fri, Nov 17, 2017 at 9:13 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Nov 16, 2017 at 04:08:17PM -0700, Logan Gunthorpe wrote:
>> These bultins are defined by in gcc since 4.4. They are also now
>> used by the isinf, isfinite and isnan macros. So using them with a
>> newer gcc causes 'undefined identifier' errors.
>>
>> Add the builtin definitions and some validation checks for these
>> functions.
>>
>> Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
>
> Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

Hmmm, looking at this closer, I only notice now that those builtins
are of the type-generic kind. Declaring them with a prototype as if
taking a float won't play nicely once you use them with a double or
a long double. Alas, there is not yet real support for type-generic
builtins. One solution would be:
        extern int __builtin_isfinite(long double);
Another one would be to use:
        extern int __builtin_isfinite(...);
but that is not C99 compliant (not sure if sparse complain).

Note, that there is also a few more builtins of the same family.

-- Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Logan Gunthorpe <logang () deltatee ! com>
To: linux-sparse
Subject: Re: [PATCH v2] add __builtin functions for isinf_sign, isfinite and isnan
Date: Fri, 17 Nov 2017 23:39:37 +0000
Message-ID: <b16d895e-d4fa-3590-4f0d-b9c0e8a754d3 () deltatee ! com>
--------------------


On 17/11/17 04:28 PM, Luc Van Oostenryck wrote:
> Hmmm, looking at this closer, I only notice now that those builtins
> are of the type-generic kind. Declaring them with a prototype as if
> taking a float won't play nicely once you use them with a double or
> a long double. Alas, there is not yet real support for type-generic
> builtins. One solution would be:
>          extern int __builtin_isfinite(long double);
> Another one would be to use:
>          extern int __builtin_isfinite(...);
> but that is not C99 compliant (not sure if sparse complain).

This is true, but when I test with the validation suite sparse does not 
seem to complain if it's a long double, double or float. So I don't 
really see an actual issue.

> Note, that there is also a few more builtins of the same family.

Yes, though GCC's documentation is less than clear on all that are 
available... I only added ones I knew to exist based on the code I'm 
working on and examining the system headers.

Logan
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] cgcc: teach cgcc about GNU/kFreeBSD ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH v2] cgcc: teach cgcc about GNU/kFreeBSD
Date: Wed, 20 Sep 2017 15:10:49 +0000
Message-ID: <20170920151049.19939-1-uwe () kleine-koenig ! org>
--------------------
Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
Changes in v2:
 - add a Sob line
 - add a missing ;

 cgcc | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/cgcc b/cgcc
index a8d7b4f217fe..95d70efc11c5 100755
--- a/cgcc
+++ b/cgcc
@@ -235,6 +235,9 @@ sub add_specs {
     } elsif ($spec eq 'linux') {
 	return &add_specs ('unix') .
 	    ' -D__linux__=1 -D__linux=1 -Dlinux=linux';
+    } elsif ($spec eq 'gnu/kfreebsd') {
+	return &add_specs ('unix') .
+	    ' -D__FreeBSD_kernel__=1';
     } elsif ($spec eq 'openbsd') {
 	return &add_specs ('unix') .
 	    ' -D__OpenBSD__=1';
-- 
2.14.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] fix expansion of integers to floats ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v2] fix expansion of integers to floats
Date: Thu, 27 Apr 2017 22:47:23 +0000
Message-ID: <CANeU7Qkv_23-6yQv639AS=Gp1Gdd-vE0v8V13=vVP-hbYFQR=Q () mail ! gmail ! com>
--------------------
On Mon, Mar 27, 2017 at 10:34 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The test wasn't using is_float_type() and thus missed
> SYM_NODE->SUM_BASETYPE::fp_type.


Looks good to me.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2] fix size of loaded bitfields ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v2] fix size of loaded bitfields
Date: Mon, 27 Feb 2017 09:27:49 +0000
Message-ID: <20170227092749.30083-1-luc.vanoostenryck () gmail ! com>
--------------------
Loading a bitfield correctly take in account the offset
of the bitfield inside the whole container integer.
But truncating it to the width of the bitfield is not done
or is done very implicitely (because the correct size is not lost).
For example, with the following code:
	struct bfu {
		unsigned int a:3;
	};
	unsigned int get__bfu_a(struct bfu bf) { return bf.a; }

test-linearize gives as output something like:
	get__bfu_a:
		cast.32     %r2 <- (3) %arg1
		ret.32      %r2

We can notice the (3) in the cast instruction but this is misleading
as %arg1 is not 3bit wide.

Fix this by adding the missing truncating cast.
This will then gives something like:
	get__bfu_a:
		cast.3      %r2 <- (32) %arg1
		cast.32     %r3 <- (3) %r2
		ret.32      %r3

Note the truncation could also be done by a and-mask but the cast
is more logical since we're here only changing size and not doing
some arithmetic operations.

Fixes: 1688f039c ("Re-do memory access linearization.")
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
Changes since v1:
- Fix the test case that was still at the and-mask version instead
  of the cast for doing the truncation.
- Slightly change the bitfield's width in the test case for easier
  parsing of the result.


 linearize.c                |  4 +++-
 validation/bitfield-size.c | 41 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 44 insertions(+), 1 deletion(-)
 create mode 100644 validation/bitfield-size.c

diff --git a/linearize.c b/linearize.c
index 99203d915..c77555bd6 100644
--- a/linearize.c
+++ b/linearize.c
@@ -32,6 +32,7 @@ static pseudo_t linearize_one_symbol(struct entrypoint *ep, struct symbol *sym);
 struct access_data;
 static pseudo_t add_load(struct entrypoint *ep, struct access_data *);
 static pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer, struct access_data *);
+static pseudo_t cast_pseudo(struct entrypoint *ep, pseudo_t src, struct symbol *from, struct symbol *to);
 
 struct pseudo void_pseudo = {};
 
@@ -999,7 +1000,8 @@ static pseudo_t linearize_load_gen(struct entrypoint *ep, struct access_data *ad
 		pseudo_t newval = add_binary_op(ep, ad->source_type, OP_LSR, new, shift);
 		new = newval;
 	}
-		
+	if (ad->bit_size != type_size(ad->source_type))
+		new = cast_pseudo(ep, new, ad->source_type, ad->result_type);
 	return new;
 }
 
diff --git a/validation/bitfield-size.c b/validation/bitfield-size.c
new file mode 100644
index 000000000..ce78ecf21
--- /dev/null
+++ b/validation/bitfield-size.c
@@ -0,0 +1,41 @@
+struct bfu {
+	unsigned int a:4;
+	unsigned int  :2;
+	unsigned int b:4;
+};
+unsigned int get__bfu_a(struct bfu bf) { return bf.a; }
+unsigned int get__bfu_b(struct bfu bf) { return bf.b; }
+unsigned int get_pbfu_a(struct bfu *bf) { return bf->a; }
+unsigned int get_pbfu_b(struct bfu *bf) { return bf->b; }
+
+
+struct bfs {
+	signed int a:4;
+	signed int  :2;
+	signed int b:4;
+};
+signed int get__bfs_a(struct bfs bf) { return bf.a; }
+signed int get__bfs_b(struct bfs bf) { return bf.b; }
+signed int get_pbfs_a(struct bfs *bf) { return bf->a; }
+signed int get_pbfs_b(struct bfs *bf) { return bf->b; }
+
+
+struct bfi {
+	int a:4;
+	int  :2;
+	int b:4;
+};
+unsigned int get__bfi_a(struct bfi bf) { return bf.a; }
+unsigned int get__bfi_b(struct bfi bf) { return bf.b; }
+unsigned int get_pbfi_a(struct bfi *bf) { return bf->a; }
+unsigned int get_pbfi_b(struct bfi *bf) { return bf->b; }
+
+/*
+ * check-name: bitfield size
+ * check-command: test-linearize -Wno-decl $file
+ * check-output-ignore
+ *
+ * check-output-pattern-24-times: cast\\.
+ * check-output-pattern-12-times: cast\\.4
+ * check-output-pattern-6-times: lsr\\..*\\$6
+ */
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 0/7] fixes for rare issues ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] fixes for rare issues
Date: Mon, 31 Jul 2017 21:01:35 +0000
Message-ID: <CANeU7Qk4cRLtKmPxSVCEe9WJLEb8VajdCiokNV=ic4YALvKcqw () mail ! gmail ! com>
--------------------
On Mon, Jul 31, 2017 at 4:36 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This series contains some fixes for crashes I found during
> some fuzzy-testing, as well as for some infinite loops
> that may happen during simplification.

Thank you so much for the patch.

I have to ask, is it for review (for now) or request to pull to
sparse-next (drop the previous version in sparse-next)?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] fixes for rare issues
Date: Mon, 31 Jul 2017 22:34:34 +0000
Message-ID: <CAExDi1Qoq21smgUvkqmdTxeJwdYJikC8taFYTdzBmx6Zea5tYg () mail ! gmail ! com>
--------------------
On Mon, Jul 31, 2017 at 11:54 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Mon, Jul 31, 2017 at 11:01 PM, Christopher Li <sparse@chrisli.org> wrote:
>> On Mon, Jul 31, 2017 at 4:36 PM, Luc Van Oostenryck
>> <luc.vanoostenryck@gmail.com> wrote:
>>> This series contains some fixes for crashes I found during
>>> some fuzzy-testing, as well as for some infinite loops
>>> that may happen during simplification.
>>
>> Thank you so much for the patch.
>>
>> I have to ask, is it for review (for now) or request to pull to
>> sparse-next (drop the previous version in sparse-next)?
>
> It's for review & test as one patch is really changed and two
> are new and while small induce big changes.

One of the thing I haven't tested is the performance.
Several things here can make things slower:
- REPEAT_CFG_CLEANUP is now set after every call to rewrite_branch()
  (and will then trigger at some point a call to kill_unreachable_bbs())
- kill_unreachable_bbs() set REPEAT_CSE is a BB have been deleted
  (which may trigger another CSE cycle possibly not present before)
- the bb_depends_on() change add some code with looping through
  the BB's instructions, nothing really heavy but still some more code
  to run
All these are needed though.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] fixes for rare issues
Date: Mon, 31 Jul 2017 22:42:17 +0000
Message-ID: <CAExDi1Sm1dUM3FQ838_5kr2maejva6tzc8NYzRtxV1KprgijhA () mail ! gmail ! com>
--------------------
On Tue, Aug 1, 2017 at 12:34 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Mon, Jul 31, 2017 at 11:54 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> On Mon, Jul 31, 2017 at 11:01 PM, Christopher Li <sparse@chrisli.org> wrote:
>>> On Mon, Jul 31, 2017 at 4:36 PM, Luc Van Oostenryck
>>> <luc.vanoostenryck@gmail.com> wrote:
>>>> This series contains some fixes for crashes I found during
>>>> some fuzzy-testing, as well as for some infinite loops
>>>> that may happen during simplification.
>>>
>>> Thank you so much for the patch.
>>>
>>> I have to ask, is it for review (for now) or request to pull to
>>> sparse-next (drop the previous version in sparse-next)?
>>
>> It's for review & test as one patch is really changed and two
>> are new and while small induce big changes.
>
> One of the thing I haven't tested is the performance.
> Several things here can make things slower:
> - REPEAT_CFG_CLEANUP is now set after every call to rewrite_branch()
>   (and will then trigger at some point a call to kill_unreachable_bbs())
> - kill_unreachable_bbs() set REPEAT_CSE is a BB have been deleted
>   (which may trigger another CSE cycle possibly not present before)
> - the bb_depends_on() change add some code with looping through
>   the BB's instructions, nothing really heavy but still some more code
>   to run
> All these are needed though.

And indeed I see that some tests that took me 38s now take 48s.
I'll look tomorrow for the real cause and see what can be done there.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] fixes for rare issues
Date: Tue, 01 Aug 2017 20:46:02 +0000
Message-ID: <CAExDi1Tq2SuzS9iCyR0ct00uw8ACnGBiAND58drfeXSUoFd5LQ () mail ! gmail ! com>
--------------------
On Tue, Aug 1, 2017 at 12:42 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:

>> One of the thing I haven't tested is the performance.
>> Several things here can make things slower:
>> - REPEAT_CFG_CLEANUP is now set after every call to rewrite_branch()
>>   (and will then trigger at some point a call to kill_unreachable_bbs())
>> - kill_unreachable_bbs() set REPEAT_CSE is a BB have been deleted
>>   (which may trigger another CSE cycle possibly not present before)
>> - the bb_depends_on() change add some code with looping through
>>   the BB's instructions, nothing really heavy but still some more code
>>   to run
>> All these are needed though.
>
> And indeed I see that some tests that took me 38s now take 48s.
> I'll look tomorrow for the real cause and see what can be done there.

OK. That was a false alert, I was still running with debug on.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] fixes for rare issues
Date: Tue, 01 Aug 2017 21:49:03 +0000
Message-ID: <CANeU7QmOoZuYiAtDzpoY+b9Pgt1MhTQTXV3-y+s=DUBfUxfMVg () mail ! gmail ! com>
--------------------
On Tue, Aug 1, 2017 at 4:46 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> OK. That was a false alert, I was still running with debug on.

My sparse full kernel test shows that:

With -rc4:
1145.61user 517.15system 2:36.62elapsed 1061%CPU (0avgtext+0avgdata
235532maxresident)k
0inputs+12744outputs (0major+126771950minor)pagefaults 0swaps

With fix-fuzzy-crashes-v3:
1128.17user 514.33system 2:34.92elapsed 1060%CPU (0avgtext+0avgdata
235556maxresident)k
0inputs+12744outputs (0major+126769380minor)pagefaults 0swaps

It seems about the same or slightly faster. Obviously only one run of each here.
I have another run before that to warm up the machine, that run also
shows V3 is slightly faster.
But not enough run to say for sure. It is within the variance of run to run.

The warning output is exactly the same, no changes.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] fixes for rare issues
Date: Tue, 01 Aug 2017 22:10:25 +0000
Message-ID: <CAExDi1Th4amvy61BKD_oD8wLUTBgdZtB4o3oHKBO5oC5zip5pg () mail ! gmail ! com>
--------------------
On Tue, Aug 1, 2017 at 11:49 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Aug 1, 2017 at 4:46 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> OK. That was a false alert, I was still running with debug on.
>
> My sparse full kernel test shows that:
>
> With -rc4:
> 1145.61user 517.15system 2:36.62elapsed 1061%CPU (0avgtext+0avgdata
> 235532maxresident)k
> 0inputs+12744outputs (0major+126771950minor)pagefaults 0swaps
>
> With fix-fuzzy-crashes-v3:
> 1128.17user 514.33system 2:34.92elapsed 1060%CPU (0avgtext+0avgdata
> 235556maxresident)k
> 0inputs+12744outputs (0major+126769380minor)pagefaults 0swaps
>
> It seems about the same or slightly faster. Obviously only one run of each here.
> I have another run before that to warm up the machine, that run also
> shows V3 is slightly faster.
> But not enough run to say for sure. It is within the variance of run to run.

Yes, it's what I really have too.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 0/7] more validation of C99 for-loop initializers ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] more validation of C99 for-loop initializers
Date: Tue, 28 Feb 2017 16:34:54 +0000
Message-ID: <CANeU7Q=x2RqnbtyrBo5yQTNTkk_C=AmABAZ_pD5L0gtgtuBj5w () mail ! gmail ! com>
--------------------
On Tue, Feb 28, 2017 at 6:03 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This serie adds scope & storage validations of C99-style for-loop
> initializers.

Just a heads up I am traveling in the next few days. My time and internet access
is unpredictable. I will try to apply them if I got a chance.  In the
worse case, I will
work on it on Sunday.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v3 0/7] more validation of C99 for-loop initializers
Date: Tue, 28 Feb 2017 16:40:11 +0000
Message-ID: <CAExDi1SW=Z+a1K2rAipQm0qrsTv26f6XBwYUmGpVnSSqyqdoiA () mail ! gmail ! com>
--------------------
On Tue, Feb 28, 2017 at 5:34 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Feb 28, 2017 at 6:03 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> This serie adds scope & storage validations of C99-style for-loop
>> initializers.
>
> Just a heads up I am traveling in the next few days. My time and internet access
> is unpredictable. I will try to apply them if I got a chance.  In the
> worse case, I will
> work on it on Sunday.
>
> Chris

OK. There is no urgency anyway but thanks for letting known.
Have a nice travel.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 1/2] avoid warning on implicit 'bool <- restricted' casts ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 1/2] avoid warning on implicit 'bool <- restricted' casts
Date: Fri, 19 May 2017 02:47:01 +0000
Message-ID: <20170519024702.31443-2-luc.vanoostenryck () gmail ! com>
--------------------
Conversion to bool is special in C since this conversion
is essentially the result of the comparison with zero.
As such, some operations which are normally unsafe to
do with restricted types, like casting to an unrestricted
type, are in fact safe to do when converting to bool
and issuing a warning in those case is useless, confusing
and causes people to add useless casts in the code in
order to shut up the warning.

Fix this by catching implicit 'bool <- restricted type' casts
and not emit a warning like for others casts of restricted
type to non-restrictes ones.

Originally-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                        |  6 ++++++
 validation/bool-cast-bad.c        |  3 ---
 validation/bool-cast-implicit.c   |  3 ---
 validation/bool-cast-restricted.c | 34 ++++++++++++++++++++++++++++++++++
 4 files changed, 40 insertions(+), 6 deletions(-)
 create mode 100644 validation/bool-cast-restricted.c

diff --git a/evaluate.c b/evaluate.c
index 976857915..3dc26fc09 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1345,6 +1345,12 @@ static int check_assignment_types(struct symbol *target, struct expression **rp,
 				return 1;
 		} else if (!(sclass & TYPE_RESTRICT))
 			goto Cast;
+                if (t == &bool_ctype) {
+                        if (is_fouled_type(s))
+                                warning((*rp)->pos, "%s degrades to integer",
+                                        show_typename(s->ctype.base_type));
+                        goto Cast;
+                }
 		*typediff = "different base types";
 		return 0;
 	}
diff --git a/validation/bool-cast-bad.c b/validation/bool-cast-bad.c
index b7e7c058d..a0b091e1c 100644
--- a/validation/bool-cast-bad.c
+++ b/validation/bool-cast-bad.c
@@ -15,9 +15,6 @@ static _Bool fstse(struct s a) { return (_Bool)a; }
  * check-command: sparse $file
  *
  * check-error-start
-bool-cast-bad.c:8:41: warning: incorrect type in return expression (different base types)
-bool-cast-bad.c:8:41:    expected bool
-bool-cast-bad.c:8:41:    got restricted le16 [usertype] a
 bool-cast-bad.c:9:42: warning: cast from restricted le16
 bool-cast-bad.c:10:41: warning: incorrect type in return expression (different base types)
 bool-cast-bad.c:10:41:    expected bool
diff --git a/validation/bool-cast-implicit.c b/validation/bool-cast-implicit.c
index ee8b705b9..9d89443b1 100644
--- a/validation/bool-cast-implicit.c
+++ b/validation/bool-cast-implicit.c
@@ -21,8 +21,5 @@ static _Bool fres(le16 a) { return a; }
  * check-output-excludes: cast\\.
  *
  * check-error-start
-bool-cast-implicit.c:15:36: warning: incorrect type in return expression (different base types)
-bool-cast-implicit.c:15:36:    expected bool
-bool-cast-implicit.c:15:36:    got restricted le16 [usertype] a
  * check-error-end
  */
diff --git a/validation/bool-cast-restricted.c b/validation/bool-cast-restricted.c
new file mode 100644
index 000000000..0aa9f35b4
--- /dev/null
+++ b/validation/bool-cast-restricted.c
@@ -0,0 +1,34 @@
+typedef unsigned   int __attribute__((bitwise)) large_t;
+#define	LBIT	((__attribute__((force)) large_t) 1)
+
+_Bool lfoo(large_t x) { return x; }
+_Bool qfoo(large_t x) { _Bool r = x; return r; }
+_Bool lbar(large_t x) { return ~x; }
+_Bool qbar(large_t x) { _Bool r = ~x; return r; }
+_Bool lbaz(large_t x) { return !x; }
+_Bool qbaz(large_t x) { _Bool r = !x; return r; }
+_Bool lqux(large_t x) { return x & LBIT; }
+_Bool qqux(large_t x) { _Bool r = x & LBIT; return r; }
+
+
+typedef unsigned short __attribute__((bitwise)) small_t;
+#define	SBIT	((__attribute__((force)) small_t) 1)
+
+_Bool sfoo(small_t x) { return x; }
+_Bool tfoo(small_t x) { _Bool r = x; return r; }
+_Bool sbar(small_t x) { return ~x; }
+_Bool tbar(small_t x) { _Bool r = ~x; return r; }
+_Bool sbaz(small_t x) { return !x; }
+_Bool tbaz(small_t x) { _Bool r = !x; return r; }
+_Bool squx(small_t x) { return x & SBIT; }
+_Bool tqux(small_t x) { _Bool r = x & SBIT; return r; }
+
+/*
+ * check-name: bool-cast-restricted.c
+ * check-command: sparse -Wno-decl $file
+ *
+ * check-error-start
+bool-cast-restricted.c:19:32: warning: restricted small_t degrades to integer
+bool-cast-restricted.c:20:35: warning: restricted small_t degrades to integer
+ * check-error-end
+ */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 1/7] fix ptrlist corruption while killing unreachable BBs ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH v3 1/7] fix ptrlist corruption while killing unreachable BBs
Date: Mon, 31 Jul 2017 21:41:07 +0000
Message-ID: <CANeU7QmGhg0T0ZkGthDoER3QxbV696OZLJ602dc9Tnv0bojFgA () mail ! gmail ! com>
--------------------
On Mon, Jul 31, 2017 at 4:36 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Fix this by:
> 1) refuse to emit the "crazy programmer" warning if there
>    is a potential dead BB
> 2) move kill_unreachable_bbs() in the main cleanup loop
>    which will avoid nested ep->bbs loop.

Great!

>
> Note: this solution is preferable to some others because
>       the "crazy programmer" condition happens very rarely.
>       It this thus better to delay this check than to call
>       kill_unreachable_bbs() preventively.
>
> Note: the reproducer is one with very broken syntax but nothing
>       forbid the same situation to happen with a valid program.
>
> Fixes: 51cfbc90a5e1462fcd624a1598ecd985a508a5d6
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> ---
>  cse.c                       |  2 ++
>  flow.c                      |  2 --
>  linearize.c                 |  3 ---
>  simplify.c                  |  9 +++++++++
>  validation/crash-ptrlist.c  | 23 +++++++++++++++++++++++
>  validation/crazy02-not-so.c | 18 ++++++++++++++++++
>  6 files changed, 52 insertions(+), 5 deletions(-)
>  create mode 100644 validation/crash-ptrlist.c
>
> diff --git a/cse.c b/cse.c
> index 0d3815c5a..17b3da01a 100644
> --- a/cse.c
> +++ b/cse.c
> @@ -364,6 +364,8 @@ void cleanup_and_cse(struct entrypoint *ep)
>  repeat:
>         repeat_phase = 0;
>         clean_up_insns(ep);
> +       if (repeat_phase & REPEAT_CFG_CLEANUP)
> +               kill_unreachable_bbs(ep);
>         for (i = 0; i < INSN_HASH_SIZE; i++) {

Interesting.  So my reading is that, this is similar to the other
alternative patch
we discuss with different that:
1. move up kill_unreachable_bbs(ep) right after clean_up_insns(ep)

> +               /*
> +                * If some BB have been removed it is possible that this
> +                * memop is in fact part of a dead BB. In this case
> +                * we must not warn since nothing is wrong.
> +                * If not part of a dead BB this will be redone after
> +                * the BBs have been cleaned up.
> +                */
> +               if (repeat_phase & REPEAT_CFG_CLEANUP)
> +                       return 0;

2. Avoid issue "crazy programmer" if we still have dead code to clean up.

That sound very reasonable and I feel that is better than the previous version
which eager to kill bbs. That is great.

I really appreciate the change.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 1/7] replace test for c99 for-loop initializers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 1/7] replace test for c99 for-loop initializers
Date: Tue, 28 Feb 2017 10:03:57 +0000
Message-ID: <20170228100403.33184-2-luc.vanoostenryck () gmail ! com>
--------------------
This test is to insure that a for-loop with C99-style initializer
linearize correctly: the same as a C89-style one (modulo any effect
on the scope of the variables). For example that code like:
	for (int = 0; i < 10; i++)
		do_stuff(i);
is linearized the same as  code like:
	int i;
	for (i = 0; i < 10; i++)
		do_stuff(i);

A test for this already exist in the testsuite:
	0e91f878 ("validation: Check C99 for loop variables")
which show the correctness of the fix::
	ed73fd32 ("linearize: Emit C99 declarations correctly")
But this test is an indirect one, using the presence or absence of
warning about context imbalance to show that some part of code is
present or not.

Now that we have the minimal tools to test the output of
test-linearize, use them to replace the test by a direct one.

Note: ideally we would like to show that the C89 & the C99 version
generate the same code but the testsuie deosn't allow this (yet).

Test-case-for: ed73fd32 ("linearize: Emit C99 declarations correctly")
Replaces:      0e91f878 ("validation: Check C99 for loop variables")
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/c99-for-loop.c | 36 ++++++++++++------------------------
 1 file changed, 12 insertions(+), 24 deletions(-)

diff --git a/validation/c99-for-loop.c b/validation/c99-for-loop.c
index 42246c513..427fde268 100644
--- a/validation/c99-for-loop.c
+++ b/validation/c99-for-loop.c
@@ -1,33 +1,21 @@
-int op(int);
-
-static int good(void)
+int c99(void);
+int c99(void)
 {
-	__context__(1);
-	for (int i = 0; i < 10; i++) {
-		if (!op(i)) {
-			__context__(-1);
-			return 0;
-		}
-	}
-	__context__(-1);
-	return 1;
-}
+	int r = -1;
 
-static int bad(void)
-{
-	__context__(1);
 	for (int i = 0; i < 10; i++) {
-		if (!op(i)) {
-			__context__(-1);
-			return 0;
-		}
+		r = i;
 	}
-	return 1;
+
+	return r;
 }
+
 /*
  * check-name: C99 for loop variable declaration
+ * check-command: test-linearize $file
  *
- * check-error-start
-c99-for-loop.c:16:12: warning: context imbalance in 'bad' - different lock contexts for basic block
- * check-error-end
+ * check-output-ignore
+ * check-output-contains: phisrc\\.
+ * check-output-contains: phi\\.
+ * check-output-contains: add\\.
  */
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 2/2] avoid warning on explicit 'bool <- restricted' casts ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 2/2] avoid warning on explicit 'bool <- restricted' casts
Date: Fri, 19 May 2017 02:47:02 +0000
Message-ID: <20170519024702.31443-3-luc.vanoostenryck () gmail ! com>
--------------------
Conversion to bool is special in C since this conversion
is essentially the result of the comparison with zero.
As such, some operations which are normally unsafe to
do with restricted types, like casting to an unrestricted
type, are in fact safe to do when converting to bool
and issuing a warning in those case is useless, confusing
and causes people to add useless casts in the code in
order to shut up the warning.

Fix this by catching explicit 'bool <- restricted type' casts
and not emit a warning like for others casts of restricted
type to non-restrictes ones.

Based-on-patch-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c                        | 13 ++++++++++---
 validation/bool-cast-bad.c        |  1 -
 validation/bool-cast-explicit.c   |  4 ----
 validation/bool-cast-restricted.c | 13 +++++++++++--
 4 files changed, 21 insertions(+), 10 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index 3dc26fc09..6bcccde2a 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2821,9 +2821,16 @@ static struct symbol *evaluate_cast(struct expression *expr)
 		if ((class1 & TYPE_RESTRICT) && restricted_value(target, t1))
 			warning(expr->pos, "cast to %s",
 				show_typename(t1));
-		if (class2 & TYPE_RESTRICT)
-			warning(expr->pos, "cast from %s",
-				show_typename(t2));
+		if (class2 & TYPE_RESTRICT) {
+			if (t1 == &bool_ctype) {
+				if (class2 & TYPE_FOULED)
+					warning(expr->pos, "%s degrades to integer",
+						show_typename(t2));
+			} else {
+				warning(expr->pos, "cast from %s",
+					show_typename(t2));
+			}
+		}
 	}
 
 	if (t1 == &ulong_ctype)
diff --git a/validation/bool-cast-bad.c b/validation/bool-cast-bad.c
index a0b091e1c..ae8b96018 100644
--- a/validation/bool-cast-bad.c
+++ b/validation/bool-cast-bad.c
@@ -15,7 +15,6 @@ static _Bool fstse(struct s a) { return (_Bool)a; }
  * check-command: sparse $file
  *
  * check-error-start
-bool-cast-bad.c:9:42: warning: cast from restricted le16
 bool-cast-bad.c:10:41: warning: incorrect type in return expression (different base types)
 bool-cast-bad.c:10:41:    expected bool
 bool-cast-bad.c:10:41:    got struct s a
diff --git a/validation/bool-cast-explicit.c b/validation/bool-cast-explicit.c
index 4e3c2b7ce..dbb67cc42 100644
--- a/validation/bool-cast-explicit.c
+++ b/validation/bool-cast-explicit.c
@@ -19,8 +19,4 @@ static _Bool fres(le16 a) { return (_Bool)a; }
  * check-command: test-linearize -m64 $file
  * check-output-ignore
  * check-output-excludes: cast\\.
- *
- * check-error-start
-bool-cast-explicit.c:15:37: warning: cast from restricted le16
- * check-error-end
  */
diff --git a/validation/bool-cast-restricted.c b/validation/bool-cast-restricted.c
index 0aa9f35b4..9985d6e32 100644
--- a/validation/bool-cast-restricted.c
+++ b/validation/bool-cast-restricted.c
@@ -3,12 +3,16 @@ typedef unsigned   int __attribute__((bitwise)) large_t;
 
 _Bool lfoo(large_t x) { return x; }
 _Bool qfoo(large_t x) { _Bool r = x; return r; }
+_Bool xfoo(large_t x) { return (_Bool)x; }
 _Bool lbar(large_t x) { return ~x; }
 _Bool qbar(large_t x) { _Bool r = ~x; return r; }
+_Bool xbar(large_t x) { return (_Bool)~x; }
 _Bool lbaz(large_t x) { return !x; }
 _Bool qbaz(large_t x) { _Bool r = !x; return r; }
+_Bool xbaz(large_t x) { return (_Bool)!x; }
 _Bool lqux(large_t x) { return x & LBIT; }
 _Bool qqux(large_t x) { _Bool r = x & LBIT; return r; }
+_Bool xqux(large_t x) { return (_Bool)(x & LBIT); }
 
 
 typedef unsigned short __attribute__((bitwise)) small_t;
@@ -16,19 +20,24 @@ typedef unsigned short __attribute__((bitwise)) small_t;
 
 _Bool sfoo(small_t x) { return x; }
 _Bool tfoo(small_t x) { _Bool r = x; return r; }
+_Bool zfoo(small_t x) { return (_Bool)x; }
 _Bool sbar(small_t x) { return ~x; }
 _Bool tbar(small_t x) { _Bool r = ~x; return r; }
+_Bool zbar(small_t x) { return (_Bool)~x; }
 _Bool sbaz(small_t x) { return !x; }
 _Bool tbaz(small_t x) { _Bool r = !x; return r; }
+_Bool zbaz(small_t x) { return (_Bool)!x; }
 _Bool squx(small_t x) { return x & SBIT; }
 _Bool tqux(small_t x) { _Bool r = x & SBIT; return r; }
+_Bool zqux(small_t x) { return (_Bool)(x & SBIT); }
 
 /*
  * check-name: bool-cast-restricted.c
  * check-command: sparse -Wno-decl $file
  *
  * check-error-start
-bool-cast-restricted.c:19:32: warning: restricted small_t degrades to integer
-bool-cast-restricted.c:20:35: warning: restricted small_t degrades to integer
+bool-cast-restricted.c:24:32: warning: restricted small_t degrades to integer
+bool-cast-restricted.c:25:35: warning: restricted small_t degrades to integer
+bool-cast-restricted.c:26:33: warning: restricted small_t degrades to integer
  * check-error-end
  */
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 2/7] add test case for scope of C99 for-loop declarations ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 2/7] add test case for scope of C99 for-loop declarations
Date: Tue, 28 Feb 2017 10:03:58 +0000
Message-ID: <20170228100403.33184-3-luc.vanoostenryck () gmail ! com>
--------------------
Insure that variable declared inside a C99 for-loop
have their scope restricted to this loop.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 validation/c99-for-loop-decl.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)
 create mode 100644 validation/c99-for-loop-decl.c

diff --git a/validation/c99-for-loop-decl.c b/validation/c99-for-loop-decl.c
new file mode 100644
index 000000000..c2ceaab99
--- /dev/null
+++ b/validation/c99-for-loop-decl.c
@@ -0,0 +1,18 @@
+static int bad_scope(void)
+{
+	int r = 0;
+
+	for (int i = 0; i < 10; i++) {
+		r = i;
+	}
+
+	return i;			/* check-should-fail */
+}
+
+/*
+ * check-name: C99 for-loop declarations
+ *
+ * check-error-start
+c99-for-loop-decl.c:9:16: error: undefined identifier 'i'
+ * check-error-end
+ */
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 2/7] fix infinite simplification loops ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 2/7] fix infinite simplification loops
Date: Mon, 31 Jul 2017 20:36:19 +0000
Message-ID: <20170731203624.58971-3-luc.vanoostenryck () gmail ! com>
--------------------
Each time a parent is removed from a BB there is
the possibility that the BB become unreachable.
This in turn can create cycles of dead BBs which
can the create inifinite loops during the
simplification process.

Fix this by setting the flag REPEAT_CFG_CLEANUP when
a branch is rewritten, this will in turn trigger
a call to kill_unreachable_bbs() which will break
these loops.

Reported-by: Michael Stefaniuc <mstefani@mykolab.com>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c                       |  3 ++-
 validation/infinite-loop02.c | 11 +++++++++++
 validation/infinite-loop03.c | 16 ++++++++++++++++
 3 files changed, 29 insertions(+), 1 deletion(-)
 create mode 100644 validation/infinite-loop02.c
 create mode 100644 validation/infinite-loop03.c

diff --git a/flow.c b/flow.c
index fce8bde21..536bf257f 100644
--- a/flow.c
+++ b/flow.c
@@ -34,7 +34,8 @@ static int rewrite_branch(struct basic_block *bb,
 		return 0;
 
 	/* We might find new if-conversions or non-dominating CSEs */
-	repeat_phase |= REPEAT_CSE;
+	/* we may also create new dead cycles */
+	repeat_phase |= REPEAT_CSE | REPEAT_CFG_CLEANUP;
 	*ptr = new;
 	replace_bb_in_list(&bb->children, old, new, 1);
 	remove_bb_from_list(&old->parents, bb, 1);
diff --git a/validation/infinite-loop02.c b/validation/infinite-loop02.c
new file mode 100644
index 000000000..7d0761d87
--- /dev/null
+++ b/validation/infinite-loop02.c
@@ -0,0 +1,11 @@
+void foo(void)
+{
+	int a = 1;
+	while ((a = !a))
+		;
+}
+
+/*
+ * check-name: infinite loop 02
+ * check-command: sparse -Wno-decl $file
+ */
diff --git a/validation/infinite-loop03.c b/validation/infinite-loop03.c
new file mode 100644
index 000000000..ac8a9519d
--- /dev/null
+++ b/validation/infinite-loop03.c
@@ -0,0 +1,16 @@
+static void foo(int *buf)
+{
+	int a = 1;
+	int *b;
+	do {
+		if (a)
+			b = buf;
+		if (a)
+			*buf = 0;
+	} while (!(a = !a));
+}
+
+/*
+ * check-name: infinite loop 03
+ * check-command: sparse -Wno-decl $file
+ */
-- 
2.13.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 3/7] fix BB dependencies on phi-nodes ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 3/7] fix BB dependencies on phi-nodes
Date: Mon, 31 Jul 2017 20:36:20 +0000
Message-ID: <20170731203624.58971-4-luc.vanoostenryck () gmail ! com>
--------------------
Simplification of BBs (via try_to_siplify_bb() or
simplify_branch_branch()) can only be done under
some conditions:
- the removed/bypassed BB is free of side-effects
- the removed/bypassed BB doesn't define some pseudos
  needed later.
This last check is efficiently done by bb_depends_on()
using liveness info. However, there is no liveness
done on OP_PHI thus the dependencies involving OP_PHI
are missing, resulting in illegal simplifications.

Fix this by explicitly adding the missing dependencies.

Supersedes: 852801f8b966407544326cd1c485f9bc7681a2e6
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c | 31 +++++++++++++++----------------
 1 file changed, 15 insertions(+), 16 deletions(-)

diff --git a/flow.c b/flow.c
index 536bf257f..23fa7c21b 100644
--- a/flow.c
+++ b/flow.c
@@ -81,26 +81,23 @@ static int bb_depends_on(struct basic_block *target, struct basic_block *src)
 }
 
 /*
- * This is only to be used by try_to_simplify_bb().
- * It really should be handled by bb_depends_on(), only
- * that there is no liveness done on OP_PHI/OP_PHISRC.
- * So we consider for now that if there is an OP_PHI
- * then some block in fact depends on this one.
- * The OP_PHI controling the conditional branch of this bb
- * is excluded since the branch will be removed.
+ * This really should be handled by bb_depends_on()
+ * which efficiently check the dependence using the
+ * defines - needs liveness info. Problem is that
+ * there is no liveness done on OP_PHI & OP_PHISRC.
+ *
+ * This function add the missing dependency checks.
  */
-static int bb_defines_phi(struct basic_block *bb, struct instruction *def)
+static int bb_depends_on_phi(struct basic_block *target, struct basic_block *src)
 {
 	struct instruction *insn;
-	FOR_EACH_PTR(bb->insns, insn) {
-		switch (insn->opcode) {
-		case OP_PHI:
-			if (def && insn != def)
-				return 1;
+	FOR_EACH_PTR(src->insns, insn) {
+		if (!insn->bb)
 			continue;
-		default:
+		if (insn->opcode != OP_PHI)
 			continue;
-		}
+		if (pseudo_in_list(target->needs, insn->target))
+			return 1;
 	} END_FOR_EACH_PTR(insn);
 	return 0;
 }
@@ -153,7 +150,7 @@ static int try_to_simplify_bb(struct basic_block *bb, struct instruction *first,
 		target = true ? second->bb_true : second->bb_false;
 		if (bb_depends_on(target, bb))
 			continue;
-		if (bb_defines_phi(bb, first))
+		if (bb_depends_on_phi(target, bb))
 			continue;
 		changed |= rewrite_branch(source, &br->bb_true, bb, target);
 		changed |= rewrite_branch(source, &br->bb_false, bb, target);
@@ -224,6 +221,8 @@ static int simplify_branch_branch(struct basic_block *bb, struct instruction *br
 		goto try_to_rewrite_target;
 	if (bb_depends_on(final, target))
 		goto try_to_rewrite_target;
+	if (bb_depends_on_phi(final, target))
+		return 0;
 	return rewrite_branch(bb, target_p, target, final);
 
 try_to_rewrite_target:
-- 
2.13.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 4/7] add a method to external_declaration() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 4/7] add a method to external_declaration()
Date: Tue, 28 Feb 2017 10:04:00 +0000
Message-ID: <20170228100403.33184-5-luc.vanoostenryck () gmail ! com>
--------------------
After parsing and validation, the symbols in the declaration
are added to the list given in argument, *if* they are not extern
symbols. The symbols that are extern are them not added to the list.

This is what is needed for usual declarations but ignoring extern
symbols make it impossible to emit a diagnostic in less usual
situation.

This is motivated by the validation of variable declaration inside
a for-loop initializer, which is valid in C99 but only for variable
with local storage.

The changes are made up of:
- extract the part 'add local symbols to the list' to a separate
  function: default_process_decl() as preparatory step to make
- replace the part 'add local symbols to the list' by a call
  to a new function pointer given in argument,

Also, to make the change non-invasive for others files:
- rename 'external_declaration()' into 'external_decl()'
- make 'external_declaration()' a small helper calling
  'external_decl()' with 'default_process_decl()' as the method.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 27 ++++++++++++++++++++-------
 1 file changed, 20 insertions(+), 7 deletions(-)

diff --git a/parse.c b/parse.c
index d07b27a21..b9b8d1ae0 100644
--- a/parse.c
+++ b/parse.c
@@ -48,6 +48,9 @@ static struct symbol_list **function_symbol_list;
 struct symbol_list *function_computed_target_list;
 struct statement_list *function_computed_goto_list;
 
+typedef void (*process_decl_t)(struct symbol_list **list, struct symbol *decl);
+static struct token *external_decl(struct token *, process_decl_t, struct symbol_list **);
+
 static struct token *statement(struct token *token, struct statement **tree);
 static struct token *handle_attributes(struct token *token, struct decl_state *ctx, unsigned int keywords);
 
@@ -2797,7 +2800,8 @@ static struct token *toplevel_asm_declaration(struct token *token, struct symbol
 	return token;
 }
 
-struct token *external_declaration(struct token *token, struct symbol_list **list)
+static struct token *external_decl(struct token *token, process_decl_t process_decl,
+		struct symbol_list **list)
 {
 	struct ident *ident = NULL;
 	struct symbol *decl;
@@ -2884,12 +2888,8 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 			}
 			token = initializer(&decl->initializer, token->next);
 		}
-		if (!is_typedef) {
-			if (!(decl->ctype.modifiers & (MOD_EXTERN | MOD_INLINE))) {
-				add_symbol(list, decl);
-				fn_local_symbol(decl);
-			}
-		}
+		if (!is_typedef)
+			process_decl(list, decl);
 		check_declaration(decl);
 		if (decl->same_symbol) {
 			decl->definition = decl->same_symbol->definition;
@@ -2929,3 +2929,16 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis
 	}
 	return expect(token, ';', "at end of declaration");
 }
+
+static void default_process_decl(struct symbol_list **list, struct symbol *decl)
+{
+	if (!(decl->ctype.modifiers & (MOD_EXTERN | MOD_INLINE))) {
+		add_symbol(list, decl);
+		fn_local_symbol(decl);
+	}
+}
+
+struct token *external_declaration(struct token *token, struct symbol_list **list)
+{
+	return external_decl(token, default_process_decl, list);
+}
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 5/7] fix crash in rewrite_branch() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 5/7] fix crash in rewrite_branch()
Date: Mon, 31 Jul 2017 20:36:22 +0000
Message-ID: <20170731203624.58971-6-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 flow.c                            |  2 +-
 validation/crash-rewrite-branch.c | 24 ++++++++++++++++++++++++
 2 files changed, 25 insertions(+), 1 deletion(-)
 create mode 100644 validation/crash-rewrite-branch.c

diff --git a/flow.c b/flow.c
index 23fa7c21b..6cac21b24 100644
--- a/flow.c
+++ b/flow.c
@@ -30,7 +30,7 @@ static int rewrite_branch(struct basic_block *bb,
 	struct basic_block *old,
 	struct basic_block *new)
 {
-	if (*ptr != old || new == old)
+	if (*ptr != old || new == old || !bb->ep)
 		return 0;
 
 	/* We might find new if-conversions or non-dominating CSEs */
diff --git a/validation/crash-rewrite-branch.c b/validation/crash-rewrite-branch.c
new file mode 100644
index 000000000..eb310df1c
--- /dev/null
+++ b/validation/crash-rewrite-branch.c
@@ -0,0 +1,24 @@
+void a(int c, int e)
+{
+	for(;                   b; c ;
+
+	if (()) {
+		unsigned short d = e;
+		if (())
+			while ()
+				;
+		&d;
+	}
+
+	if (()) {
+		int f = &f;
+	}
+}
+
+/*
+ * check-name: crash rewrite_branch
+ * check-command: test-linearize $file
+ *
+ * check-error-ignore
+ * check-output-ignore
+ */
-- 
2.13.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 6/7] fix some crashes in add_dominators() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 6/7] fix some crashes in add_dominators()
Date: Mon, 31 Jul 2017 20:36:23 +0000
Message-ID: <20170731203624.58971-7-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 memops.c                    |  2 ++
 validation/crash-add-doms.c | 22 ++++++++++++++++++++++
 2 files changed, 24 insertions(+)
 create mode 100644 validation/crash-add-doms.c

diff --git a/memops.c b/memops.c
index 5efdd6f2d..aeacdf566 100644
--- a/memops.c
+++ b/memops.c
@@ -29,6 +29,8 @@ static int find_dominating_parents(pseudo_t pseudo, struct instruction *insn,
 
 		FOR_EACH_PTR_REVERSE(parent->insns, one) {
 			int dominance;
+			if (!one->bb)
+				continue;
 			if (one == insn)
 				goto no_dominance;
 			dominance = dominates(pseudo, insn, one, local);
diff --git a/validation/crash-add-doms.c b/validation/crash-add-doms.c
new file mode 100644
index 000000000..54ad93e84
--- /dev/null
+++ b/validation/crash-add-doms.c
@@ -0,0 +1,22 @@
+char a;
+int b;
+void c(void)
+{
+	if (0) {
+		char *d;
+		for (;;)
+			for (;;)
+e:
+				*d *= (a && 0) ^ b && *d;
+	}
+	goto e;
+}
+
+
+/*
+ * check-name: crash add-doms
+ * check-command: test-linearize $file
+ *
+ * check-error-ignore
+ * check-output-ignore
+ */
-- 
2.13.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 6/7] make process_decl() aware of the presence of an initializer ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 6/7] make process_decl() aware of the presence of an initializer
Date: Tue, 28 Feb 2017 10:04:02 +0000
Message-ID: <20170228100403.33184-7-luc.vanoostenryck () gmail ! com>
--------------------
The call to the method external_decl::process_decl() is
preceded by some processing and validation if there is also
an initializer.

Make the process_decl() method aware of the presence of such
an initializer in order to be able to make appropriate
validations.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/parse.c b/parse.c
index 693bb497f..c3c877b10 100644
--- a/parse.c
+++ b/parse.c
@@ -48,7 +48,7 @@ static struct symbol_list **function_symbol_list;
 struct symbol_list *function_computed_target_list;
 struct statement_list *function_computed_goto_list;
 
-typedef void (*process_decl_t)(struct symbol_list **list, struct symbol *decl);
+typedef void (*process_decl_t)(struct symbol_list **list, struct symbol *decl, int has_init);
 static struct token *external_decl(struct token *, process_decl_t, struct symbol_list **);
 
 static struct token *statement(struct token *token, struct statement **tree);
@@ -2232,7 +2232,7 @@ static struct token *parse_return_statement(struct token *token, struct statemen
 	return expression_statement(token->next, &stmt->ret_value);
 }
 
-static void process_for_loop_decl(struct symbol_list **list, struct symbol *sym)
+static void process_for_loop_decl(struct symbol_list **list, struct symbol *sym, int has_init)
 {
 	unsigned long storage;
 
@@ -2896,7 +2896,9 @@ static struct token *external_decl(struct token *token, process_decl_t process_d
 	}
 
 	for (;;) {
+		int has_init = 0;
 		if (!is_typedef && match_op(token, '=')) {
+			has_init = 1;
 			if (decl->ctype.modifiers & MOD_EXTERN) {
 				warning(decl->pos, "symbol with external linkage has initializer");
 				decl->ctype.modifiers &= ~MOD_EXTERN;
@@ -2904,7 +2906,7 @@ static struct token *external_decl(struct token *token, process_decl_t process_d
 			token = initializer(&decl->initializer, token->next);
 		}
 		if (!is_typedef)
-			process_decl(list, decl);
+			process_decl(list, decl, has_init);
 		check_declaration(decl);
 		if (decl->same_symbol) {
 			decl->definition = decl->same_symbol->definition;
@@ -2945,7 +2947,7 @@ static struct token *external_decl(struct token *token, process_decl_t process_d
 	return expect(token, ';', "at end of declaration");
 }
 
-static void default_process_decl(struct symbol_list **list, struct symbol *decl)
+static void default_process_decl(struct symbol_list **list, struct symbol *decl, int has_init)
 {
 	if (!(decl->ctype.modifiers & (MOD_EXTERN | MOD_INLINE))) {
 		add_symbol(list, decl);
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 7/7] fix crash with sym->bb_target == NULL ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v3 7/7] fix crash with sym->bb_target == NULL
Date: Mon, 31 Jul 2017 20:36:24 +0000
Message-ID: <20170731203624.58971-8-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c                  |  5 ++++-
 validation/crash-bb_target.c | 10 ++++++++++
 2 files changed, 14 insertions(+), 1 deletion(-)
 create mode 100644 validation/crash-bb_target.c

diff --git a/linearize.c b/linearize.c
index 12209492b..ba76397ea 100644
--- a/linearize.c
+++ b/linearize.c
@@ -334,6 +334,7 @@ const char *show_instruction(struct instruction *insn)
 		
 	case OP_SETVAL: {
 		struct expression *expr = insn->val;
+		struct symbol *sym;
 		buf += sprintf(buf, "%s <- ", show_pseudo(insn->target));
 
 		if (!expr) {
@@ -355,7 +356,9 @@ const char *show_instruction(struct instruction *insn)
 			buf += sprintf(buf, "%s", show_ident(expr->symbol->ident));
 			break;
 		case EXPR_LABEL:
-			buf += sprintf(buf, ".L%u", expr->symbol->bb_target->nr);
+			sym = expr->symbol;
+			if (sym->bb_target)
+				buf += sprintf(buf, ".L%u", sym->bb_target->nr);
 			break;
 		default:
 			buf += sprintf(buf, "SETVAL EXPR TYPE %d", expr->type);
diff --git a/validation/crash-bb_target.c b/validation/crash-bb_target.c
new file mode 100644
index 000000000..bc5a3d354
--- /dev/null
+++ b/validation/crash-bb_target.c
@@ -0,0 +1,10 @@
+a() {
+  &&b
+
+/*
+ * check-name: crash bb_target
+ * check-command: test-linearize $file
+ *
+ * check-error-ignore
+ * check-output-ignore
+ */
-- 
2.13.2

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 00/38] Makefile reognization ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH v4 00/38] Makefile reognization
Date: Fri, 17 Nov 2017 09:23:27 +0000
Message-ID: <20171117092326.jje4m4o5np567y6z () ltop ! local>
--------------------
On Sat, Nov 11, 2017 at 03:23:59PM +0100, Luc Van Oostenryck wrote:
> The goal of this series is to reorganize sparse's Makefile
> in order to offer a few features asked by the distros:
> 1) allow CFLAGS & CPPFLAGS to be taken from the command line
> 2) allow PREFIX to be taken from the environment
> Support for pkg-config is removed as well as some old crufts.
> 
> This cleanup is based on a previous series by Uwe Kleine-König
> and further inspired by a patch and a need from Jeff Layton.
> 
> The changes since v1 are:
> *) fold the two patches concerning the removal of shared lib support
> *) remove the patch using git-clean for 'make clean'
> 
> The changes since v2 are:
> *) change a commit message to make explicit the fact that
>    quiet's commands abbreviated part are also issued for V=1
> *) add a convenience rule for running a single test via:
>         make validation/<name-of-testfile>.t
> 
> The changes since v3 are:
> *) make the name 'local.mk' be configurable instead of
>    the renaming that was done.
> *) move '-fno-strict-aliasing' out of the overridable CFLAGS
> *) rename the ...{_OBJS,_LDFLAGS,_LDLIBS} to ...{-objs,-ldflags,-ldlibs}
>    to be consistent about the private 'cflags'.

This has now been pushed to my dev tree at:
	git://github.com/lucvoo/sparse.git master

-- Luc Van Oostenryck 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 31/38] build: simplify quiet commands ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v4 31/38] build: simplify quiet commands
Date: Sat, 11 Nov 2017 14:24:30 +0000
Message-ID: <20171111142437.67359-32-luc.vanoostenryck () gmail ! com>
--------------------
The current mechanism for the quiet commands, what's
hiding the true command and emitting instead things like:
	CC      target.o
is, IMO, somehow unneedlessly sophisticated and this doesn't help
to understand what's happening and to adapt things when needed.

Change this by using simple 'echo' commands and make's '@' to
display the short command and hiding the long one.

Warning: There is a small change in behaviour with this:
  previously, when displaying the non-quiet commands with
  'make V=1' the quiet ones were not emitted. Now, with this
  patch, the short/quiet command is emitted in both case.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Makefile | 25 ++++++++++++-------------
 1 file changed, 12 insertions(+), 13 deletions(-)

diff --git a/Makefile b/Makefile
index 5b3cd66f9..bf2f82042 100644
--- a/Makefile
+++ b/Makefile
@@ -159,13 +159,6 @@ LIBS := libsparse.a
 #
 V	      = @
 Q	      = $(V:1=)
-QUIET_CC      = $(Q:@=@echo    "  CC      $@";)
-QUIET_CHECK   = $(Q:@=@echo    "  CHECK   $<";)
-QUIET_AR      = $(Q:@=@echo    "  AR      $@";)
-QUIET_GEN     = $(Q:@=@echo    "  GEN     $@";)
-QUIET_LINK    = $(Q:@=@echo    "  LINK    $@";)
-# We rely on the -v switch of install to print 'file -> $install_dir/file'
-QUIET_INST    = $(Q:@=@echo -n "  INSTALL ";)
 
 
 compile_OBJS := compile-i386.o
@@ -176,10 +169,12 @@ ldflags += $($(@)-ldflags) $(LDFLAGS)
 ldlibs  += $($(@)-ldlibs)  $(LDLIBS)
 $(foreach p,$(PROGRAMS),$(eval $(p): $($(p)-objs)))
 $(PROGRAMS): % : %.o $(LIBS)
-	$(QUIET_LINK)$(LD) $(ldflags) $^ $(ldlibs) -o $@
+	@echo "  LD      $@"
+	$(Q)$(LD) $(ldflags) $^ $(ldlibs) -o $@
 
 libsparse.a: $(LIB_OBJS)
-	$(QUIET_AR)$(AR) rcs $@ $^
+	@echo "  AR      $@"
+	$(Q)$(AR) rcs $@ $^
 
 OBJS := $(LIB_OBJS) $(PROGRAMS:%=%.o) $(foreach p,$(PROGRAMS),$($(p)-objs))
 DEPS := $(OBJS:%.o=.%.o.d)
@@ -189,10 +184,12 @@ DEPS := $(OBJS:%.o=.%.o.d)
 
 cflags   += $($(*)-cflags) $(CPPFLAGS) $(CFLAGS)
 %.o: %.c
-	$(QUIET_CC)$(CC) $(cflags) -c -o $@ $<
+	@echo "  CC      $@"
+	$(Q)$(CC) $(cflags) -c -o $@ $<
 
 %.sc: %.c sparse
-	$(QUIET_CHECK) $(CHECKER) $(CHECKER_FLAGS) $(cflags) -c $<
+	@echo "  CHECK   $<"
+	$(Q) $(CHECKER) $(CHECKER_FLAGS) $(cflags) -c $<
 
 selfcheck: $(OBJS:.o=.sc)
 
@@ -234,8 +231,10 @@ install-bin: $(INST_PROGRAMS:%=$(DESTDIR)$(BINDIR)/%)
 install-man: $(INST_MAN1:%=$(DESTDIR)$(MAN1DIR)/%)
 
 $(DESTDIR)$(BINDIR)/%: %
-	$(QUIET_INST)install -v        $< $@ || exit 1;
+	@echo "  INSTALL $@"
+	$(Q)install        $< $@ || exit 1;
 $(DESTDIR)$(MAN1DIR)/%: %
-	$(QUIET_INST)install -v -m 644 $< $@ || exit 1;
+	@echo "  INSTALL $@"
+	$(Q)install -m 644 $< $@ || exit 1;
 
 .PHONY: FORCE
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 33/38] build: add *.o to clean-check pattern ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v4 33/38] build: add *.o to clean-check pattern
Date: Sat, 11 Nov 2017 14:24:32 +0000
Message-ID: <20171111142437.67359-34-luc.vanoostenryck () gmail ! com>
--------------------
.o files are also created in the validation directory
(currently only tmp.o, for sparse-llvm/sparsec testing).

Aso remove them during make clean-check.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Makefile | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Makefile b/Makefile
index d0e616ba5..e57934c92 100644
--- a/Makefile
+++ b/Makefile
@@ -216,6 +216,7 @@ clean-check:
 	@echo "  CLEAN"
 	@find validation/ \( -name "*.c.output.*" \
 			  -o -name "*.c.error.*" \
+			  -o -name "*.o" \
 	                  \) -exec rm {} \;
 
 
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 35/38] build: reorg & add comment ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v4 35/38] build: reorg & add comment
Date: Sat, 11 Nov 2017 14:24:34 +0000
Message-ID: <20171111142437.67359-36-luc.vanoostenryck () gmail ! com>
--------------------
No functionnal changes here, only shuffling a few lines around,
adding separators and adding a few comments

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Makefile | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/Makefile b/Makefile
index d67f54afe..92bf9e726 100644
--- a/Makefile
+++ b/Makefile
@@ -85,6 +85,9 @@ cflags += -DGCC_BASE=\"$(GCC_BASE)\"
 MULTIARCH_TRIPLET := $(shell $(CC) -print-multiarch 2>/dev/null)
 cflags += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"
 
+########################################################################
+# target specificities
+
 compile: compile-i386.o
 EXTRA_OBJS += compile-i386.o
 
@@ -157,15 +160,15 @@ else
 $(warning Your system does not have llvm, disabling sparse-llvm)
 endif
 
+########################################################################
 LIBS := libsparse.a
+OBJS := $(LIB_OBJS) $(EXTRA_OBJS) $(PROGRAMS:%=%.o)
 
-#
 # Pretty print
-#
 V	      = @
 Q	      = $(V:1=)
 
-
+########################################################################
 all: $(PROGRAMS)
 
 ldflags += $($(@)-ldflags) $(LDFLAGS)
@@ -178,11 +181,6 @@ libsparse.a: $(LIB_OBJS)
 	@echo "  AR      $@"
 	$(Q)$(AR) rcs $@ $^
 
-OBJS := $(LIB_OBJS) $(EXTRA_OBJS) $(PROGRAMS:%=%.o)
-DEPS := $(OBJS:%.o=.%.o.d)
-
--include $(DEPS)
-
 
 cflags   += $($(*)-cflags) $(CPPFLAGS) $(CFLAGS)
 %.o: %.c
@@ -237,3 +235,6 @@ $(DESTDIR)$(MAN1DIR)/%: %
 	$(Q)install -m 644 $< $@ || exit 1;
 
 .PHONY: FORCE
+
+# GCC's dependencies
+-include $(OBJS:%.o=.%.o.d)
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 37/38] build: add rule to run a single test ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v4 37/38] build: add rule to run a single test
Date: Sat, 11 Nov 2017 14:24:36 +0000
Message-ID: <20171111142437.67359-38-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Makefile | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/Makefile b/Makefile
index 2c70d904b..a2d3e8c89 100644
--- a/Makefile
+++ b/Makefile
@@ -208,6 +208,8 @@ version.h: FORCE
 
 check: all
 	$(Q)cd validation && ./test-suite
+validation/%.t: FORCE
+	@validation/test-suite single $*.c
 
 
 clean: clean-check
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 38/38] build: let -fno-strict-aliasing be a mandatory flag ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH v4 38/38] build: let -fno-strict-aliasing be a mandatory flag
Date: Sat, 11 Nov 2017 14:24:37 +0000
Message-ID: <20171111142437.67359-39-luc.vanoostenryck () gmail ! com>
--------------------
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Makefile | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index a2d3e8c89..f26c1f962 100644
--- a/Makefile
+++ b/Makefile
@@ -6,7 +6,7 @@ OS = linux
 
 
 CC = gcc
-CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
+CFLAGS = -O2 -finline-functions -g
 CFLAGS += -Wall -Wwrite-strings
 LD = gcc
 AR = ar
@@ -79,6 +79,11 @@ INST_MAN1=sparse.1 cgcc.1
 
 all:
 
+########################################################################
+# common flags/options/...
+
+cflags = -fno-strict-aliasing
+
 GCC_BASE := $(shell $(CC) --print-file-name=)
 cflags += -DGCC_BASE=\"$(GCC_BASE)\"
 
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add -gcc-version option ===

From: Pavel Roskin <plroskin () gmail ! com>
To: linux-sparse
Subject: [PATCH] Add -gcc-version option
Date: Tue, 18 Jul 2017 21:59:45 +0000
Message-ID: <CAN_72e10vHGWwmovq_ra7FKE9EQgo-T+r8AavwFErkEV9Hnuww () mail ! gmail ! com>
--------------------
The option argument is parsed into major, minor and patchlevel versions,
which are defined as __GNUC__, __GNUC_MINOR__, and __GNUC_PATCHLEVEL__ in
the preprocessor.

One possible use is running sparse compiled with the lastest gcc compiler
on a Linux kernel that doesn't support that compiler.

Signed-off-by: Pavel Roskin <pavel.roskin@virginorbit.com>
---
 lib.c    | 45 +++++++++++++++++++++++++++++++++++++++++++++
 sparse.1 |  7 +++++++
 2 files changed, 52 insertions(+)

diff --git a/lib.c b/lib.c
index ce66a81..aff6862 100644
--- a/lib.c
+++ b/lib.c
@@ -24,6 +24,7 @@
  */
 #include <ctype.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stddef.h>
 #include <stdio.h>
@@ -831,10 +832,54 @@ static char **handle_base_dir(char *arg, char **next)
     return next;
 }

+static char **handle_gcc_version(char *arg, char **next)
+{
+    unsigned long gcc_major_ul, gcc_minor_ul = 0, gcc_patchlevel_ul = 0;
+    char *gcc_version, *p;
+
+    gcc_version = *++next;
+    if (!gcc_version)
+        die("missing argument for -gcc-version option");
+
+    gcc_major_ul = strtoul(gcc_version, &p, 10);
+    if (gcc_major_ul > INT_MAX)
+        die("bad gcc major version");
+
+    if (*p == '\0')
+        goto good;
+    else if (*p != '.')
+        die("bad character after gcc major version");
+
+    gcc_minor_ul = strtoul(p + 1, &p, 10);
+    if (gcc_minor_ul > INT_MAX)
+        die("bad gcc minor version");
+
+    if (*p == '\0')
+        goto good;
+    else if (*p != '.')
+        die("bad character after gcc minor version");
+
+    gcc_patchlevel_ul = strtoul(p + 1, &p, 10);
+    if (gcc_patchlevel_ul > INT_MAX)
+        die("bad gcc patchlevel version");
+
+    if (*p != '\0')
+        die("bad character after gcc patchlevel version");
+
+good:
+    gcc_major = gcc_major_ul;
+    gcc_minor = gcc_minor_ul;
+    gcc_patchlevel = gcc_patchlevel_ul;
+
+    return next;
+}
+
 static char **handle_switch_g(char *arg, char **next)
 {
     if (!strcmp (arg, "gcc-base-dir"))
         return handle_base_dir(arg, next);
+    else if (!strcmp (arg, "gcc-version"))
+        return handle_gcc_version(arg, next);

     return next;
 }
diff --git a/sparse.1 b/sparse.1
index b79c587..9f2c52d 100644
--- a/sparse.1
+++ b/sparse.1
@@ -355,6 +355,13 @@ Look for system headers in the multiarch
subdirectory \fIdir\fR.
 The \fIdir\fR name would normally take the form of the target's
 normalized GNU triplet. (e.g. i386-linux-gnu).
 .
+.TP
+.B \-gcc-version \fIversion\fR
+Simulate behavior of gcc of the specified version. At this time, this
+switch only affects macros \fI__GNUC__\fR, \fI__GNUC_MINOR__\fR, and
+\fI__GNUC_PATCHLEVEL__\fR. The default value is the version of gcc that
+compiled sparse, or \fI2.95.0\fR if that information is missing.
+.
 .SH DEBUG OPTIONS
 .TP
 .B \-fdump-linearize[=only]
-- 
2.13.3


-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Add -gcc-version option
Date: Tue, 18 Jul 2017 23:35:14 +0000
Message-ID: <CANeU7Qn7Te3kxzcWAzC_4Hn2MLSsGFTdNX2AjJwmWdb6e2n+pA () mail ! gmail ! com>
--------------------
On Tue, Jul 18, 2017 at 5:59 PM, Pavel Roskin <plroskin@gmail.com> wrote:
> The option argument is parsed into major, minor and patchlevel versions,
> which are defined as __GNUC__, __GNUC_MINOR__, and __GNUC_PATCHLEVEL__ in
> the preprocessor.
>
> One possible use is running sparse compiled with the lastest gcc compiler
> on a Linux kernel that doesn't support that compiler.

I am curious, can you just invoke sparse with -D__GNUC__=1 -D__GNUC_MINOR__=2
to do the same thing?

The current __GNUC__ was a weak define it is suitable for overriding
if you wants to.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <plroskin () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Add -gcc-version option
Date: Tue, 18 Jul 2017 23:46:47 +0000
Message-ID: <CAN_72e2SE4pcUNNUSOJVRW31YdXmm-tR0ybOjpT7QDV2fmne4g () mail ! gmail ! com>
--------------------
On Tue, Jul 18, 2017 at 4:35 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Jul 18, 2017 at 5:59 PM, Pavel Roskin <plroskin@gmail.com> wrote:
>> The option argument is parsed into major, minor and patchlevel versions,
>> which are defined as __GNUC__, __GNUC_MINOR__, and __GNUC_PATCHLEVEL__ in
>> the preprocessor.
>>
>> One possible use is running sparse compiled with the lastest gcc compiler
>> on a Linux kernel that doesn't support that compiler.
>
> I am curious, can you just invoke sparse with -D__GNUC__=1 -D__GNUC_MINOR__=2
> to do the same thing?
>
> The current __GNUC__ was a weak define it is suitable for overriding
> if you wants to.

Yes, that works! I wish I thought of it earlier and did not waste time
writing that patch.

That option may still be useful if sparse attempts to imitate the
behavior of specific gcc versions (in addition to the defines).

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pavel Roskin <plroskin () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Add -gcc-version option
Date: Wed, 19 Jul 2017 17:27:07 +0000
Message-ID: <CAN_72e0f6Zg3YeDrMmb5OOHHr4qj14Wc_WeomeZirjXx0zOU=w () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 6:07 AM, Christopher Li <sparse@chrisli.org> wrote:

> When you specify the gcc version, there is also implicit version
> specific behavior
> go with it. I can see user file bugs said I give sparse gcc version X,
> but gcc has
> macro Y in X. That is not the case with sparse, that is a bug. I don't
> want to give
> the user false impression that sparse can set a gcc version and simulate the gcc
> version specific behavior.

Makes sense.

> It is simpler just put the version specific macro into a header file and ask
> sparse to include it. You should be able to add that to command line as well.
>
> Chris

I did not realize that sparse supports -include. It turns out it does,
which is even better than specifying three defines.

I don't see any references to -D or -include in the sparse manual
page. I think they should be documented.

-- 
Regards,
Pavel Roskin
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Add -gcc-version option
Date: Wed, 19 Jul 2017 19:16:43 +0000
Message-ID: <CANeU7QnUdVGruZV=acWuOwx5_euJJyY8dxmqLtmTbDNxhD+Urg () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 1:27 PM, Pavel Roskin <plroskin@gmail.com> wrote:
>
> I did not realize that sparse supports -include. It turns out it does,
> which is even better than specifying three defines.
>
> I don't see any references to -D or -include in the sparse manual
> page. I think they should be documented.

It is kind of expected due to usage of cgcc. cgcc expect to be run like
gcc but with one extra step of sparse check checking on it. In order to
duplicate the gcc behavior on macro, sparse will need to  accept most
of the gcc preprocessor command line options.

As for the document, patch are welcome :-)

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Handle SForced in storage_modifiers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Handle SForced in storage_modifiers
Date: Thu, 05 Jan 2017 06:39:48 +0000
Message-ID: <20170105063947.GA9300 () macpro ! local>
--------------------
On Thu, Nov 17, 2016 at 06:28:15AM +0800, Christopher Li wrote:
> On Tue, Nov 15, 2016 at 10:07 AM, Jeff Layton <jlayton@redhat.com> wrote:
> >
> > That looks fine to me. If you want to merge that one, then:
> >
> > Reviewed-by: Jeff Layton <jlayton@redhat.com>
> 
> The patches is applied on "chrisl" repo and pushed out.
> 
> Actually I want to merge the patch having you as the author.
> 
> Chris
> --


I just noticed now, while doing some merging, that what have been commited
on the master tree is not the patch discussed here.
What have been commited is the same change but with 'CMax' (integer class)
while it was supposed to be 'SMax' (for the array of specifier).
The version on sparse-next is correct though.

Here is a patch fixing this:


================================================================================


################################################################################

=== Thread: [PATCH] Let pseudo->users loop on duplicate versin of list ===

From: Christopher Li <sparse@chrisli.org>
To: Unknown
Subject: [PATCH] Let pseudo->users loop on duplicate versin of list
Date: Wed, 12 Jul 2017 14:46:50 -0700
Message-ID: 
--------------------
pseudo->users list will change during find dominator.
That cause a bug in the ptrlist because the outer loop iterator
is not award of the deletion of the entry.

Let the outer loop using a duplicate version of entry
to avoid this problem for now.

This is to fix the bug report by the ptrlist ref counting check.
With this change, the ptrlist ref counting check can complete
the kernel compile without reporting an error.

Signed-of-By: Christopher Li <sparse@chrisli.org>
---
 flow.c | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/flow.c b/flow.c
index fce8bde..bfe54f7 100644
--- a/flow.c
+++ b/flow.c
@@ -729,12 +729,21 @@ static void simplify_one_symbol(struct
entrypoint *ep, struct symbol *sym)
 multi_def:
 complex_def:
 external_visibility:
- all = 1;
- FOR_EACH_PTR_REVERSE(pseudo->users, pu) {
- struct instruction *insn = pu->insn;
- if (insn->opcode == OP_LOAD)
- all &= find_dominating_stores(pseudo, insn, ++bb_generation, !mod);
- } END_FOR_EACH_PTR_REVERSE(pu);
+ {
+ /*
+ * find_dominating_stores() will modify the pesudo->users list.
+ * Make a duplicate copy before using it.
+ */
+ struct pseudo_user_list *users = NULL;
+ all = 1;
+ concat_user_list(pseudo->users, &users);
+ FOR_EACH_PTR_REVERSE(users, pu) {
+ struct instruction *insn = pu->insn;
+ if (insn->opcode == OP_LOAD)
+ all &= find_dominating_stores(pseudo, insn, ++bb_generation, !mod);
+ } END_FOR_EACH_PTR_REVERSE(pu);
+ free_ptr_list(&users);
+ }

  /* If we converted all the loads, remove the stores. They are dead */
  if (all && !mod) {
-- 
2.9.4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Let pseudo->users loop on duplicate version of list ===

From: Christopher Li <sparse@chrisli.org>
To: Unknown
Subject: [PATCH] Let pseudo->users loop on duplicate version of list
Date: Mon, 10 Jul 2017 07:53:21 -0700
Message-ID: 
--------------------
pseudo->users list will change during find dominator.
That cause a bug in the ptrlist because the outer loop iterator
is not award of the deletion of the entry.

Let the outer loop using a duplicate version of entry
to avoid this problem for now.

This is to fix the bug report by the ptrlist ref counting check.
With this change, the ptrlist ref counting check can complete
the kernel compile without reporting an error.

Signed-of-By: Christopher Li <sparse@chrisli.org>
---
 flow.c    |  7 ++++++-
 ptrlist.h | 17 +++++++++++++++++
 2 files changed, 23 insertions(+), 1 deletion(-)

diff --git a/flow.c b/flow.c
index fce8bde..2705448 100644
--- a/flow.c
+++ b/flow.c
@@ -730,7 +730,12 @@ multi_def:
 complex_def:
 external_visibility:
  all = 1;
- FOR_EACH_PTR_REVERSE(pseudo->users, pu) {
+ /*
+ * FIXME: pseudo->users will have some entry deleted during looping.
+ * The loop will run on a duplicated version of the list entry for now.
+ * Should fix it properly later.
+ */
+ FOR_EACH_PTR_REVERSE_DUP(pseudo->users, pu) {
  struct instruction *insn = pu->insn;
  if (insn->opcode == OP_LOAD)
  all &= find_dominating_stores(pseudo, insn, ++bb_generation, !mod);
diff --git a/ptrlist.h b/ptrlist.h
index d09be2f..5299ee5 100644
--- a/ptrlist.h
+++ b/ptrlist.h
@@ -184,6 +184,20 @@ static inline void *last_ptr_list(struct ptr_list *list)
  ptr = PTR_ENTRY(__list,__nr); \
  do {

+#define DO_FOR_EACH_REVERSE_DUP(head, ptr, __head, __list, __dup,
__nr, PTR_ENTRY) do { \
+ struct ptr_list *__head = (struct ptr_list *) (head); \
+ struct ptr_list *__list = __head; \
+ CHECK_TYPE(head,ptr); \
+ if (__head) { \
+ do { int __nr; \
+ __list = __list->prev; \
+ __nr = __list->nr; \
+ struct ptr_list __dup; \
+ memcpy(__dup.list, __list->list, sizeof(ptr)*__nr); \
+ while (--__nr >= 0) { \
+ do { \
+ ptr = PTR_ENTRY(&__dup,__nr); \
+ do {

 #define DO_END_FOR_EACH_REVERSE(ptr, __head, __list, __nr) \
  } while (0); \
@@ -231,6 +245,9 @@ static inline void *last_ptr_list(struct ptr_list *list)
 #define FOR_EACH_PTR_REVERSE(head, ptr) \
  DO_FOR_EACH_REVERSE(head, ptr, __head##ptr, __list##ptr, __nr##ptr, PTR_ENTRY)

+#define FOR_EACH_PTR_REVERSE_DUP(head, ptr) \
+ DO_FOR_EACH_REVERSE_DUP(head, ptr, __head##ptr, __list##ptr,
__dup##ptr, __nr##ptr, PTR_ENTRY)
+
 #define END_FOR_EACH_PTR_REVERSE(ptr) \
  DO_END_FOR_EACH_REVERSE(ptr, __head##ptr, __list##ptr, __nr##ptr)

-- 
2.9.4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Makefile: provide CFLAGS for command line override. ===

From: Christopher Li <sparse@chrisli.org>
To: Unknown
Subject: [PATCH] Makefile: provide CFLAGS for command line override.
Date: Sun, 29 Oct 2017 19:16:44 +0800
Message-ID: 
--------------------
Avoid assign to CFLAGS in Makefile.
Rename BASIC_CFLAGS to COMMON_CFLAGS.
Use PKG_CFLAGS to store external package related cflags.

Signed-off-by: Christopher Li <sparse@chrisli.org>
Acked-by: Jeff Layton <jlayton@kernel.org>
---
 Makefile | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/Makefile b/Makefile
index d0341764..66cb1ae1 100644
--- a/Makefile
+++ b/Makefile
@@ -12,8 +12,8 @@ OS = linux


 CC = gcc
-CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
-CFLAGS += -Wall -Wwrite-strings
+COMMON_CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
+COMMON_CFLAGS += -Wall -Wwrite-strings
 LDFLAGS += -g
 LD = gcc
 AR = ar
@@ -21,7 +21,7 @@ PKG_CONFIG = pkg-config
 CHECKER = ./cgcc -no-compile
 CHECKER_FLAGS =

-ALL_CFLAGS = $(CFLAGS) $(BASIC_CFLAGS)
+ALL_CFLAGS = $(COMMON_CFLAGS) $(PKG_CFLAGS) $(CFLAGS)
 #
 # For debugging, put this in local.mk:
 #
@@ -44,13 +44,13 @@ LLVM_CONFIG:=llvm-config
 HAVE_LLVM:=$(shell $(LLVM_CONFIG) --version >/dev/null 2>&1 && echo 'yes')

 GCC_BASE := $(shell $(CC) --print-file-name=)
-BASIC_CFLAGS = -DGCC_BASE=\"$(GCC_BASE)\"
+COMMON_CFLAGS += -DGCC_BASE=\"$(GCC_BASE)\"

 MULTIARCH_TRIPLET := $(shell $(CC) -print-multiarch 2>/dev/null)
-BASIC_CFLAGS += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"
+COMMON_CFLAGS += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"

 ifeq ($(HAVE_GCC_DEP),yes)
-BASIC_CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
+COMMON_CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
 endif

 DESTDIR=
@@ -83,7 +83,7 @@ PROGRAMS += test-inspect
 INST_PROGRAMS += test-inspect
 test-inspect_EXTRA_DEPS := ast-model.o ast-view.o ast-inspect.o
 test-inspect_OBJS := test-inspect.o $(test-inspect_EXTRA_DEPS)
-$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): CFLAGS += $(GTK_CFLAGS)
+$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): PKG_CFLAGS += $(GTK_CFLAGS)
 test-inspect_EXTRA_OBJS := $(GTK_LIBS)
 else
 $(warning Your system does not have gtk3/gtk2, disabling test-inspect)
@@ -101,7 +101,7 @@ LLVM_LIBS := $(shell $(LLVM_CONFIG) --libs)
 LLVM_LIBS += $(shell $(LLVM_CONFIG) --system-libs 2>/dev/null)
 PROGRAMS += $(LLVM_PROGS)
 INST_PROGRAMS += sparse-llvm sparsec
-sparse-llvm.o: BASIC_CFLAGS += $(LLVM_CFLAGS)
+sparse-llvm.o: PKG_CFLAGS += $(LLVM_CFLAGS)
 sparse-llvm_EXTRA_OBJS := $(LLVM_LIBS) $(LLVM_LDFLAGS)
 else
 $(warning LLVM 3.0 or later required. Your system has version
$(LLVM_VERSION) installed.)
-- 
2.13.6
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Makefile: use locally built sparse in the selfcheck target ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Thu, 09 Nov 2017 16:30:48 +0000
Message-ID: <10d6a020-ebe8-6a31-e4cb-ff67c1a1009c () ramsayjones ! plus ! com>
--------------------

Signed-off-by: Ramsay Jones <ramsay@ramsayjones.plus.com>
---

Hi Chris,

I was recently setting up a new system and didn't have sparse
installed. The 'make selfcheck' target failed ...

ATB,
Ramsay Jones

 Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index d034176..d1a303e 100644
--- a/Makefile
+++ b/Makefile
@@ -18,7 +18,7 @@ LDFLAGS += -g
 LD = gcc
 AR = ar
 PKG_CONFIG = pkg-config
-CHECKER = ./cgcc -no-compile
+CHECKER = CHECK=./sparse ./cgcc -no-compile
 CHECKER_FLAGS =
 
 ALL_CFLAGS = $(CFLAGS) $(BASIC_CFLAGS)
-- 
2.15.0
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Thu, 09 Nov 2017 17:37:45 +0000
Message-ID: <628e13fc-1fbd-fbc6-d662-a5050ce59c86 () ramsayjones ! plus ! com>
--------------------


On 09/11/17 17:06, Luc Van Oostenryck wrote:
> 
> Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> 
> 
> BTW, selfcheck also fails when reaching sparse-llvm.c because of
> the use of CFLAGS/BASIC_CFLAGS/ALL_CFLAGS/COMMON_CFLAGS/PKG_CFLAGS.

Hmm, I used to have LLVM installed on Linux as well as cygwin, but
I didn't install it the last time I did a 'nuke-n-pave' Linux
installation. (Linux Mint is much easier to upgrade these days, which
is to say it actually works now, but that wasn't always the case!).

On cygwin, sparse-llvm.c complains for a cygwin-only reason, so it
may be that those errors a hiding the ones you are seeing. I have been
meaning to get around to fix the cygwin problems.

What kind of errors are you seeing?

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Thu, 09 Nov 2017 17:43:21 +0000
Message-ID: <CAMHZB6EjHuVVchrWsST_igO+Cj+KuqL3O5ezBG8pcDpp45u1ew () mail ! gmail ! com>
--------------------
On Thu, Nov 9, 2017 at 6:37 PM, Ramsay Jones
<ramsay@ramsayjones.plus.com> wrote:
>
>
> On 09/11/17 17:06, Luc Van Oostenryck wrote:
>>
>> Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>>
>>
>> BTW, selfcheck also fails when reaching sparse-llvm.c because of
>> the use of CFLAGS/BASIC_CFLAGS/ALL_CFLAGS/COMMON_CFLAGS/PKG_CFLAGS.
>
> Hmm, I used to have LLVM installed on Linux as well as cygwin, but
> I didn't install it the last time I did a 'nuke-n-pave' Linux
> installation. (Linux Mint is much easier to upgrade these days, which
> is to say it actually works now, but that wasn't always the case!).
>
> On cygwin, sparse-llvm.c complains for a cygwin-only reason, so it
> may be that those errors a hiding the ones you are seeing. I have been
> meaning to get around to fix the cygwin problems.
>
> What kind of errors are you seeing?

The specific error message is:
    sparse-llvm.c:6:11: error: unable to open 'llvm-c/Core.h'
but the cause is simply because the LLVM CFLAGS are used like:
    sparse-llvm.o: BASIC_CFLAGS += $(LLVM_CFLAGS)
but selfcheck/cgcc, correctly, doesn't know about BASIC_CFLAGS.

Chris should be already aware of it and is busy to cook a patch
changing the way the CFLAGS are used.

Regards,
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Thu, 09 Nov 2017 17:55:02 +0000
Message-ID: <aae6d72a-013d-4342-de15-28bab1ac15e4 () ramsayjones ! plus ! com>
--------------------


On 09/11/17 17:43, Luc Van Oostenryck wrote:
> On Thu, Nov 9, 2017 at 6:37 PM, Ramsay Jones
> <ramsay@ramsayjones.plus.com> wrote:
>>
>>
>> On 09/11/17 17:06, Luc Van Oostenryck wrote:
>>>
>>> Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>>>
>>>
>>> BTW, selfcheck also fails when reaching sparse-llvm.c because of
>>> the use of CFLAGS/BASIC_CFLAGS/ALL_CFLAGS/COMMON_CFLAGS/PKG_CFLAGS.
>>
>> Hmm, I used to have LLVM installed on Linux as well as cygwin, but
>> I didn't install it the last time I did a 'nuke-n-pave' Linux
>> installation. (Linux Mint is much easier to upgrade these days, which
>> is to say it actually works now, but that wasn't always the case!).
>>
>> On cygwin, sparse-llvm.c complains for a cygwin-only reason, so it
>> may be that those errors a hiding the ones you are seeing. I have been
>> meaning to get around to fix the cygwin problems.
>>
>> What kind of errors are you seeing?
> 
> The specific error message is:
>     sparse-llvm.c:6:11: error: unable to open 'llvm-c/Core.h'
> but the cause is simply because the LLVM CFLAGS are used like:
>     sparse-llvm.o: BASIC_CFLAGS += $(LLVM_CFLAGS)
> but selfcheck/cgcc, correctly, doesn't know about BASIC_CFLAGS.

Hmm, that doesn't make much sense - the selfcheck target uses
the $(ALL_CFLAGS), just like the '%.o %.c' target. So, if the
file is compiled by gcc, then cgcc should have the same flags
(plus some sparse specific flags).

[This is the Makefile on the master branch @ c408da2].

puzzled ...

ATB,
Ramsay Jones


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Thu, 09 Nov 2017 17:57:40 +0000
Message-ID: <CANeU7Qm8PsNKNo8VCf-AP5u2_x+OHjHSPmMFvd64BqNm-xtTbQ () mail ! gmail ! com>
--------------------
On Fri, Nov 10, 2017 at 1:55 AM, Ramsay Jones
<ramsay@ramsayjones.plus.com> wrote:
>> The specific error message is:
>>     sparse-llvm.c:6:11: error: unable to open 'llvm-c/Core.h'
>> but the cause is simply because the LLVM CFLAGS are used like:
>>     sparse-llvm.o: BASIC_CFLAGS += $(LLVM_CFLAGS)
>> but selfcheck/cgcc, correctly, doesn't know about BASIC_CFLAGS.
>
> Hmm, that doesn't make much sense - the selfcheck target uses
> the $(ALL_CFLAGS), just like the '%.o %.c' target. So, if the

Right. But selfcheck using *.sc target.

So the likely fix is just:
sparse-llvm.o sparse-llvm.sc: XXX_CFLAGS += $(LLVM_CFLAGS)

I am looking at this right now.

Interesting enough, on my FC 26 it is not triggering the header
file error.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Thu, 09 Nov 2017 18:03:46 +0000
Message-ID: <e3aaace9-77b9-7b63-ee6b-9f5069c11b92 () ramsayjones ! plus ! com>
--------------------


On 09/11/17 17:55, Ramsay Jones wrote:
> 
> 
> On 09/11/17 17:43, Luc Van Oostenryck wrote:
>> On Thu, Nov 9, 2017 at 6:37 PM, Ramsay Jones
>> <ramsay@ramsayjones.plus.com> wrote:
>>>
>>>
>>> On 09/11/17 17:06, Luc Van Oostenryck wrote:
>>>>
>>>> Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>>>>
>>>>
>>>> BTW, selfcheck also fails when reaching sparse-llvm.c because of
>>>> the use of CFLAGS/BASIC_CFLAGS/ALL_CFLAGS/COMMON_CFLAGS/PKG_CFLAGS.
>>>
>>> Hmm, I used to have LLVM installed on Linux as well as cygwin, but
>>> I didn't install it the last time I did a 'nuke-n-pave' Linux
>>> installation. (Linux Mint is much easier to upgrade these days, which
>>> is to say it actually works now, but that wasn't always the case!).
>>>
>>> On cygwin, sparse-llvm.c complains for a cygwin-only reason, so it
>>> may be that those errors a hiding the ones you are seeing. I have been
>>> meaning to get around to fix the cygwin problems.
>>>
>>> What kind of errors are you seeing?
>>
>> The specific error message is:
>>     sparse-llvm.c:6:11: error: unable to open 'llvm-c/Core.h'
>> but the cause is simply because the LLVM CFLAGS are used like:
>>     sparse-llvm.o: BASIC_CFLAGS += $(LLVM_CFLAGS)
>> but selfcheck/cgcc, correctly, doesn't know about BASIC_CFLAGS.
> 
> Hmm, that doesn't make much sense - the selfcheck target uses
> the $(ALL_CFLAGS), just like the '%.o %.c' target. So, if the
> file is compiled by gcc, then cgcc should have the same flags
> (plus some sparse specific flags).
> 
> [This is the Makefile on the master branch @ c408da2].
> 
> puzzled ...

Ah, no longer puzzled. Hmm, didn't there used to be a rule like:

sparse-llvm.o sparse-llvm.sc: BASIC_CFLAGS += $(LLVM_CFLAGS)

this?

ATB,
Ramsay Jones


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Thu, 09 Nov 2017 18:32:07 +0000
Message-ID: <d1e128a0-93e8-657a-6f0c-a025713ec0c1 () ramsayjones ! plus ! com>
--------------------


On 09/11/17 18:09, Christopher Li wrote:
> On Fri, Nov 10, 2017 at 2:03 AM, Ramsay Jones
> <ramsay@ramsayjones.plus.com> wrote:
>>
>> Ah, no longer puzzled. Hmm, didn't there used to be a rule like:
>>
>> sparse-llvm.o sparse-llvm.sc: BASIC_CFLAGS += $(LLVM_CFLAGS)
>>
> 
> I search the history. Nope, I miss that when I add the selfcheck.
> I did not catch this error because on FC26 missing the LLVM_CFLAGS
> does not cause compile error.

Heh, our emails crossed.

> 
> $ llvm-config --cflags
> -I/usr/include -O2 -g -pipe -Wall -Werror=format-security
> -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong
> --param=ssp-buffer-size=4 -grecord-gcc-switches
> -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic
> -fPIC -Wall -W -Wno-unused-parameter -Wwrite-strings
> -Wno-missing-field-initializers -pedantic -Wno-long-long -Wno-comment
> -Werror=date-time -ffunction-sections -fdata-sections -O2 -g -DNDEBUG
> -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS
> -D__STDC_LIMIT_MACROS
> 
> "llvm-config --cflags" does not introduce new header file searching directory.

Ah, OK.

So, 'llvm-config --cflags' produces different output on
whichever platform Luc is on?

ATB,
Ramsay Jones


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Makefile: use locally built sparse in the selfcheck target
Date: Sat, 11 Nov 2017 14:44:17 +0000
Message-ID: <CAExDi1QY_+bC02cFLm0+fHoVM59WL8664p8AJ=EA51Y7TSbDLQ () mail ! gmail ! com>
--------------------
On Thu, Nov 9, 2017 at 7:32 PM, Ramsay Jones
<ramsay@ramsayjones.plus.com> wrote:
>>
>> $ llvm-config --cflags
>> -I/usr/include -O2 -g -pipe -Wall -Werror=format-security
>> -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong
>> --param=ssp-buffer-size=4 -grecord-gcc-switches
>> -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic
>> -fPIC -Wall -W -Wno-unused-parameter -Wwrite-strings
>> -Wno-missing-field-initializers -pedantic -Wno-long-long -Wno-comment
>> -Werror=date-time -ffunction-sections -fdata-sections -O2 -g -DNDEBUG
>> -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS
>> -D__STDC_LIMIT_MACROS
>>
>> "llvm-config --cflags" does not introduce new header file searching directory.
>
> Ah, OK.
>
> So, 'llvm-config --cflags' produces different output on
> whichever platform Luc is on?

Usually, I have nothing (of interest) in /usr since most of my stuff
is installed in somewhere in $HOME or /opt.

Regards,
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] RFC: remove warning "advancing past deep designator" ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] RFC: remove warning "advancing past deep designator"
Date: Fri, 19 May 2017 13:58:47 +0000
Message-ID: <20170519135847.40720-1-luc.vanoostenryck () gmail ! com>
--------------------
This warning is issued in code like:
	struct s {
		union {
			int  i;
			long l;
		} u;
		int b;
	};
	static struct s s = {
		.u.i = 1,
		2,
	};
in other words, it is issued when a 'deep' designated initializer
is followed by a non-designated initializer.

I wonder what's really the value of this warning.
Is there really some confusion we would like to avoid?

NB. I'm not sure if this situation is covered by the standard
    (status of 'deep' designated initializers is not very clear).
NB. GCC accept this, without any option to warn about it.

CC: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 evaluate.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index f8ed10f13..ef4da2371 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -2501,10 +2501,6 @@ static void handle_list_initializer(struct expression *expr,
 					ctype->ident ? ": " : "",
 					get_type_name(struct_sym->type),
 					show_ident(struct_sym->ident));
-			if (jumped) {
-				warning(e->pos, "advancing past deep designator");
-				jumped = 0;
-			}
 			REPLACE_CURRENT_PTR(e, last);
 		} else {
 			next = check_designators(e, ctype);
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli
Date: Sun, 09 Jul 2017 16:52:00 +0000
Message-ID: <20170709165157.w6jnjkwca7dwxj64 () ltop ! local>
--------------------
On Sun, Jul 09, 2017 at 09:07:06AM -0700, Christopher Li wrote:
> On Sun, Jul 9, 2017 at 3:26 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >>
> >> - repeat_phase &= ~REPEAT_CFG_CLEANUP;
> >> + repeat_phase |=  REPEAT_CSE ;
> >
> > It would be good to add a comment for why the '|= REPEAT_CSE' is needed here.
> >
> 
> You are right.
> 
> Actually I just find out that is not needed. I was having impression that I
> need that to pass one of the test-suit. It seems fine without.

It could have made a difference in the test suite because killing
unreachable code can create new simplification opportunities.

> It pass the
> full kernel check as well.

What do you mean exactly by 'pass full kernel check'? That you get
exactly the same warnings with & without the patch?

> From 484a3a27d95b4bf3be9ac4b9bcf1aca1abe3ac19 Mon Sep 17 00:00:00 2001
> From: Christopher Li <sparse@chrisli.org>
> Date: Sat, 8 Jul 2017 19:34:49 -0700
> Subject: [PATCH] move kill_unreachable_bbs to outer cse stage
> 
> The current way of kill_unreach_bbs in insert_branch()
> cause delete entry in ptrlist that the upper level
> caller is looping on.

I know what you're talking about but otherwise, I really can't parse
this sentence.
 
Anyway, I think that this bug merit a much better commit message.
 
It would also be nice to know why the patch that came with the bug
report have been discarded without a single comment.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli
Date: Mon, 10 Jul 2017 00:19:27 +0000
Message-ID: <CANeU7Qms0KKSWU0dyHomz1iEczdiYn_7SwsJZmPCSXDhsag0Tw () mail ! gmail ! com>
--------------------
On Sun, Jul 9, 2017 at 9:52 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> It could have made a difference in the test suite because killing
> unreachable code can create new simplification opportunities.

Yes. As far as I can tell, when the kill instruction get invoked, it should
have cause the REPEAT_CSE. "Kill unreachable bb" shouldn't need
to set CSE flag.

> What do you mean exactly by 'pass full kernel check'? That you get
> exactly the same warnings with & without the patch?

Yes, that is what I usually do to give sparse some workload other
than the test-suite.


>
>> From 484a3a27d95b4bf3be9ac4b9bcf1aca1abe3ac19 Mon Sep 17 00:00:00 2001
>> From: Christopher Li <sparse@chrisli.org>
>> Date: Sat, 8 Jul 2017 19:34:49 -0700
>> Subject: [PATCH] move kill_unreachable_bbs to outer cse stage
>>
>> The current way of kill_unreach_bbs in insert_branch()
>> cause delete entry in ptrlist that the upper level
>> caller is looping on.
>
> I know what you're talking about but otherwise, I really can't parse
> this sentence.
>
> Anyway, I think that this bug merit a much better commit message.
>

Of course. Can you take my patch and merge it with your validation
test? Do what you see fit. I think it'd better commit together, and get
a better commit message.

I was overwhelming by the ptr ref counting. I need some thing in my
branch to stop die on those ep->bbs.

> It would also be nice to know why the patch that came with the bug
> report have been discarded without a single comment.

Sorry I haven't been more specific. I think the original patch is a bit
too complicated. Also just as I suspected, there is more than the bb
list get affected. If possible, I think we should try to avoid get into nested
loop delete in the first place rather than make the nested loop delete
work.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli
Date: Mon, 10 Jul 2017 13:21:22 +0000
Message-ID: <CANeU7QnoP5g2kww5Up1gW7ucWB2H7xuGdzQ-0bTei4cWxjAz=w () mail ! gmail ! com>
--------------------
On Mon, Jul 10, 2017 at 12:05 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> > It would also be nice to know why the patch that came with the bug
>> > report have been discarded without a single comment.
>>
>> Sorry I haven't been more specific. I think the original patch is a bit
>> too complicated. Also just as I suspected, there is more than the bb
>> list get affected. If possible, I think we should try to avoid get into nested
>> loop delete in the first place rather than make the nested loop delete
>> work.
>
> I can hardly qualify my patch as 'complicated' but well ...
> This patch have been done with two goals in mind:
> 1) solve the problem with the deleted BB
> 2) do not change anything at the simplification since interaction
>    between differents parts there can have bad effects (it's to fix
>    a problem there that the kill_unreachable_bbs() had been added).
>
> Your patch, take care of point 1) but not 2) and effectively
> change when the BBs are removed and this change the interaction
> between insert_branch() and some others parts.

You are right. I will never consider 2) as my goal. Simply because
if the compiler has to depend on certain order of optimization (delete
dead BB vs memops, CSE) and it can't figure out the order by itself.
Then I consider a bug in the compiler.

> I have given a run of some of my tests I run here and there
> is indeed some changes.
> Most of these changes are obviously correct.
> Some are not obvious at all and would need to be investigated.
> Some look scary (and of course would need to be investigated too).

Great to have you looking at those. That is why I want to get your
insight on this.

> In short, I can't guarantee that the "crazy programmer" problem
> won't come back or that a similar one haven't been created.

Nobody can.That "crazy programmer" fix is not even a complete fix.
We will need to work on it any way.

> Sure, but this have nothing to do with the choice of patches here
> since your pacth also just tak ecare of the deleted BBs from the
> inner kill_unreachable_bbs().

It does in my thinking process. If there is other list involved, then
we need to look for other solutions for those. That other solution
might work on the BB list as well. There for, I don't want to invest
too much into this temporary change, especially the API change
of kill unreachable BB.

>> If possible, I think we should try to avoid get into nested
>> loop delete in the first place rather than make the nested loop delete
>> work.
>
> This seems an obvious and easy way to avoid problems but this won't
> something that will be sustainable. It would put a huge constraint
> on what can be done and what can't done, which is why, of course,

I would not rule out that possibility so quickly without consider it.
For example,
we can design the optimization process using work queue to defer certain
things do be done outside of the loop. There are many different things we
can do to solve the problem.

If nested loop deleted can be avoided, that is likely cheaper and less
complicate.

> I earlier suggested to instead change the way elements are 'deleted'
> (like instructions are already never removed from their list but
> just marked as deleted).

That looks simple but it has hidden complications as well. The issue is that
we need to find out which list need this kind of special treatment. Who is
the outer loop. If the same function can be both call as the outer
loop and inner
loop then it is complicate to decide when it should do the finalize.
There is also
the price to pay for walking the list twice which does not exist if nested loop
can be avoided.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli
Date: Tue, 11 Jul 2017 09:26:26 +0000
Message-ID: <20170711092625.ux6xonjiqxhotczf () ltop ! local>
--------------------
On Mon, Jul 10, 2017 at 06:21:22AM -0700, Christopher Li wrote:
> On Mon, Jul 10, 2017 at 12:05 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >> > It would also be nice to know why the patch that came with the bug
> >> > report have been discarded without a single comment.
> >>
> >> Sorry I haven't been more specific. I think the original patch is a bit
> >> too complicated. Also just as I suspected, there is more than the bb
> >> list get affected. If possible, I think we should try to avoid get into nested
> >> loop delete in the first place rather than make the nested loop delete
> >> work.
> >
> > I can hardly qualify my patch as 'complicated' but well ...
> > This patch have been done with two goals in mind:
> > 1) solve the problem with the deleted BB
> > 2) do not change anything at the simplification since interaction
> >    between differents parts there can have bad effects (it's to fix
> >    a problem there that the kill_unreachable_bbs() had been added).
> >
> > Your patch, take care of point 1) but not 2) and effectively
> > change when the BBs are removed and this change the interaction
> > between insert_branch() and some others parts.
> 
> You are right. I will never consider 2) as my goal. Simply because
> if the compiler has to depend on certain order of optimization (delete
> dead BB vs memops, CSE) and it can't figure out the order by itself.
> Then I consider a bug in the compiler.

You may qualify this as a bug but in the real world it's totally
normal to have interactions between optimization passes (yes, this
means that the result will depend on the order of the passes).
This is especially true when it concern dead code elimination.

Any decent compiler book will tell you a bit more about this.

But well, you're the maintainer, it's your responsability to
make the good choices for the project.

-- Luc Van Oostenryck 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli
Date: Tue, 11 Jul 2017 20:41:12 +0000
Message-ID: <CANeU7Qm+R4q_6ZF1=Oa-d5TtVcNfz+YhDePXq4-L6GoTyYAwvQ () mail ! gmail ! com>
--------------------
On Tue, Jul 11, 2017 at 2:26 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>>
>> You are right. I will never consider 2) as my goal. Simply because
>> if the compiler has to depend on certain order of optimization (delete
>> dead BB vs memops, CSE) and it can't figure out the order by itself.
>> Then I consider a bug in the compiler.
>
> You may qualify this as a bug but in the real world it's totally
> normal to have interactions between optimization passes (yes, this
> means that the result will depend on the order of the passes).
> This is especially true when it concern dead code elimination.
>
> Any decent compiler book will tell you a bit more about this.

OK. Apparently I haven't read any decent compiler books yet, that
is why I am not a good maintainer.

My sentence have two parts. You only read the first part about
the ordering. The second part you seem missing is that, if the
order make a difference, *and* the compiler can't to figure out
a the (optimal) order by itself, that is a bug.

It is just command sense. If I re-order my C source file
with some goto and moving code blocks around. The C compiler
should generate pretty much the same optimal code in the end.

If your investigation of comparing two approach to compile
the same source code, your patch generate better result. Then
we need to look at it. That might be reason to use your patch.
Maybe there is some other simple way to modify my patch to
generate as good a result as well. Do you have any example
you believe my simpler approach will generate worse code
then your not so complicate approach?

> But well, you're the maintainer, it's your responsability to
> make the good choices for the project.

Of course. I try really hard to make the right choice. I can only
make decision base on the information I have in hand. So far you
haven't conclude your investigation that the simpler approach will
generate worse code. You said it is different, different can be better
or be worse. If it turn out to be different but equivalent, then why not
just use the simpler approach?

If it is not, then let's look at why this pack blocks earlier will make
code better. Make some adjustment in the code, possible remove
dead block earlier like your patch suggested.

Chris

PS, Any decent compiler book you want to recommend? I want to
see it.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli
Date: Wed, 19 Jul 2017 20:48:57 +0000
Message-ID: <20170719204854.6jwkt6q7shnlfelu () ltop ! local>
--------------------
> From 484a3a27d95b4bf3be9ac4b9bcf1aca1abe3ac19 Mon Sep 17 00:00:00 2001
> From: Christopher Li <sparse@chrisli.org>
> Date: Sat, 8 Jul 2017 19:34:49 -0700
> Subject: [PATCH] move kill_unreachable_bbs to outer cse stage
> 
> The current way of kill_unreach_bbs in insert_branch()
> cause delete entry in ptrlist that the upper level
> caller is looping on.
> 
> Move it outside to the cse stage avoid that problem.
> 
> Reported-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> Signed-of-By: Christopher Li <sparse@chrisli.org>
> ---
>  cse.c       | 3 +++
>  flow.c      | 2 --
>  linearize.c | 3 ---
>  3 files changed, 3 insertions(+), 5 deletions(-)

The original patch had a testcase for the regressions testsuite.
Is there a reasons why there it has been dropped here?

The original patch had a reference to the patch it fixed,
which is quite helpful to understand the exact situation.
Is there a reason why it has been dropped here?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrli
Date: Wed, 19 Jul 2017 20:57:38 +0000
Message-ID: <CANeU7Qk3N2F+yOUC5SHGJ=jzWMNhgVL=EV3tbSWPZj-7JRVEHw () mail ! gmail ! com>
--------------------
On Wed, Jul 19, 2017 at 4:48 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> The original patch had a testcase for the regressions testsuite.
> Is there a reasons why there it has been dropped here?
>
> The original patch had a reference to the patch it fixed,
> which is quite helpful to understand the exact situation.
> Is there a reason why it has been dropped here?

Nope, I was hoping your can merge the patch with your test
case and resubmit as a combine patch. I haven't heard from
you so far so that is what I have.

It feel wrong for me to take your test case and submit as mine.
Again I consider my change just an alternative incremental change
build on top of yours.

If you want to improve the commit message or comment on the
source, I am all for it. I am glad to see that. I haven't push my
change to master for that reason. On the other hand, I can't
hold the release for ever.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrlist w ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] V2 move kill_unreachable_bbs to outer cse stage Was Re: [PATCH 1/5] do not corrupt ptrlist w
Date: Sun, 09 Jul 2017 16:07:06 +0000
Message-ID: <CANeU7QkCcx1d29megDn9bQ0g7rw04=ujsWCe_bN1Kc1NW_-NZw () mail ! gmail ! com>
--------------------
On Sun, Jul 9, 2017 at 3:26 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>>
>> - repeat_phase &= ~REPEAT_CFG_CLEANUP;
>> + repeat_phase |=  REPEAT_CSE ;
>
> It would be good to add a comment for why the '|= REPEAT_CSE' is needed here.
>

You are right.

Actually I just find out that is not needed. I was having impression that I
need that to pass one of the test-suit. It seems fine without. It pass the
full kernel check as well. It is likely due to I have an unclean tree of the
ptr ref count stuff.

Patch refreshed.
https://git.kernel.org/pub/scm/devel/sparse/sparse.git/log/?h=sparse-next-20170709

Thanks

Chris


================================================================================


################################################################################

=== Thread: [PATCH] add __builtin functions for isinf_sign, isfinite and isnan ===

From: Logan Gunthorpe <logang () deltatee ! com>
To: linux-sparse
Subject: [PATCH] add __builtin functions for isinf_sign, isfinite and isnan
Date: Thu, 16 Nov 2017 21:27:19 +0000
Message-ID: <20171116212719.1217-1-logang () deltatee ! com>
--------------------
These bultins are defined by in gcc since 4.4. They are also now
used by the isinf, isfinite and isnan macros. So using them with a
newer gcc causes 'undefined identifier' errors.

Add the builtin definitions and some validation checks for these
functions.

Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
---
 lib.c                    | 3 +++
 validation/builtin_inf.c | 8 ++++++++
 2 files changed, 11 insertions(+)

diff --git a/lib.c b/lib.c
index 4602cf8..cc740e9 100644
--- a/lib.c
+++ b/lib.c
@@ -1105,6 +1105,9 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern double __builtin_nan(const char *);\n");
 	add_pre_buffer("extern float __builtin_nanf(const char *);\n");
 	add_pre_buffer("extern long double __builtin_nanl(const char *);\n");
+	add_pre_buffer("extern int __builtin_isinf_sign(float);\n");
+	add_pre_buffer("extern int __builtin_isfinite(float);\n");
+	add_pre_buffer("extern int __builtin_isnan(float);\n");
 
 	/* And some __FORTIFY_SOURCE ones.. */
 	add_pre_buffer ("extern __SIZE_TYPE__ __builtin_object_size(const void *, int);\n");
diff --git a/validation/builtin_inf.c b/validation/builtin_inf.c
index 48546e4..0855ab0 100644
--- a/validation/builtin_inf.c
+++ b/validation/builtin_inf.c
@@ -7,6 +7,14 @@ static long double li = __builtin_infl();
 static double dn = __builtin_nan("");
 static float fn = __builtin_nanf("");
 static long double ln = __builtin_nanl("");
+static int inf = __builtin_isinf_sign(0.0);
+static int fin = __builtin_isfinite(0.0);
+static int nan = __builtin_isnan(0.0);
+
+#include <math.h>
+static int inf2 = isinf(0.0);
+static int fin2 = isfinite(0.0);
+static int nan2 = isnan(0.0);
 
 /*
  * check-name: __builtin INFINITY / nan()
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] add __builtin functions for isinf_sign, isfinite and isnan
Date: Thu, 16 Nov 2017 23:02:39 +0000
Message-ID: <CANeU7Q=ivP59nwzyW-G16TwTNBP+D6iPa9R-Lch4d9PuscyxWA () mail ! gmail ! com>
--------------------
On Fri, Nov 17, 2017 at 5:27 AM, Logan Gunthorpe <logang@deltatee.com> wrote:
> These bultins are defined by in gcc since 4.4. They are also now
> used by the isinf, isfinite and isnan macros. So using them with a
> newer gcc causes 'undefined identifier' errors.
>
> Add the builtin definitions and some validation checks for these
> functions.

Thanks for the patch.

> diff --git a/validation/builtin_inf.c b/validation/builtin_inf.c
> index 48546e4..0855ab0 100644
> --- a/validation/builtin_inf.c
> +++ b/validation/builtin_inf.c
> @@ -7,6 +7,14 @@ static long double li = __builtin_infl();
>  static double dn = __builtin_nan("");
>  static float fn = __builtin_nanf("");
>  static long double ln = __builtin_nanl("");
> +static int inf = __builtin_isinf_sign(0.0);
> +static int fin = __builtin_isfinite(0.0);
> +static int nan = __builtin_isnan(0.0);
> +
> +#include <math.h>

Can you remove the <math.h>?

For the validation test, it would be best to not depend on
system header file. You can use sparse -E to dig out the
related function call after the pre-process.

Other than that, it looks good.

I want to apply with the math.h removed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build: allow to override CFLAGS via the command line ===

From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
To: Unknown
Subject: [PATCH] build: allow to override CFLAGS via the command line
Date: Wed, 25 Oct 2017 14:38:01 +0200
Message-ID: 
--------------------
Some distros (fedora) and some developers want to specifiy their
own CFLAGS. OTOH most of CFLAGS's content is automatically
contructed or must not be changed.

This patch, allow to extend CFLAGS via the command line, like:
	make CFLAGS=-some-extra-flags

The patch also get rid of the confusing CFLAGS/BASIC_CFLAGS/ALL_CFLAGS

With this change, target specific CFLAGS can be given either via
	target.o: CFLAGS += -some-specific-flags
or via
	target_CFLAGS = -some-specific-flags

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 Makefile | 26 +++++++++++++++-----------
 1 file changed, 15 insertions(+), 11 deletions(-)

diff --git a/Makefile b/Makefile
index d03417641..f53d66d70 100644
--- a/Makefile
+++ b/Makefile
@@ -11,6 +11,11 @@ endif
 OS = linux
 
 
+# This save any CFLAGS given in the command line
+# and let us use 'CFLAGS' here under
+CLI_CFLAGS := $(CFLAGS)
+override undefine CFLAGS
+
 CC = gcc
 CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
 CFLAGS += -Wall -Wwrite-strings
@@ -21,7 +26,6 @@ PKG_CONFIG = pkg-config
 CHECKER = ./cgcc -no-compile
 CHECKER_FLAGS =
 
-ALL_CFLAGS = $(CFLAGS) $(BASIC_CFLAGS)
 #
 # For debugging, put this in local.mk:
 #
@@ -44,13 +48,13 @@ LLVM_CONFIG:=llvm-config
 HAVE_LLVM:=$(shell $(LLVM_CONFIG) --version >/dev/null 2>&1 && echo 'yes')
 
 GCC_BASE := $(shell $(CC) --print-file-name=)
-BASIC_CFLAGS = -DGCC_BASE=\"$(GCC_BASE)\"
+CFLAGS += -DGCC_BASE=\"$(GCC_BASE)\"
 
 MULTIARCH_TRIPLET := $(shell $(CC) -print-multiarch 2>/dev/null)
-BASIC_CFLAGS += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"
+CFLAGS += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"
 
 ifeq ($(HAVE_GCC_DEP),yes)
-BASIC_CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
+CFLAGS += -Wp,-MD,$(@D)/.$(@F).d
 endif
 
 DESTDIR=
@@ -71,7 +75,7 @@ ifeq ($(HAVE_LIBXML),yes)
 PROGRAMS+=c2xml
 INST_PROGRAMS+=c2xml
 c2xml_EXTRA_OBJS = `$(PKG_CONFIG) --libs libxml-2.0`
-LIBXML_CFLAGS := $(shell $(PKG_CONFIG) --cflags libxml-2.0)
+c2xml_CFLAGS := $(shell $(PKG_CONFIG) --cflags libxml-2.0)
 else
 $(warning Your system does not have libxml, disabling c2xml)
 endif
@@ -101,7 +105,7 @@ LLVM_LIBS := $(shell $(LLVM_CONFIG) --libs)
 LLVM_LIBS += $(shell $(LLVM_CONFIG) --system-libs 2>/dev/null)
 PROGRAMS += $(LLVM_PROGS)
 INST_PROGRAMS += sparse-llvm sparsec
-sparse-llvm.o: BASIC_CFLAGS += $(LLVM_CFLAGS)
+sparse-llvm_CFLAGS := $(LLVM_CFLAGS)
 sparse-llvm_EXTRA_OBJS := $(LLVM_LIBS) $(LLVM_LDFLAGS)
 else
 $(warning LLVM 3.0 or later required. Your system has version $(LLVM_VERSION) installed.)
@@ -127,7 +131,7 @@ LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
 
-# If you add $(SLIB_FILE) to this, you also need to add -fpic to BASIC_CFLAGS above.
+# If you add $(SLIB_FILE) to this, you also need to add -fpic to CFLAGS above.
 # Doing so incurs a noticeable performance hit, and Sparse does not have a
 # stable shared library interface, so this does not occur by default.  If you
 # really want a shared library, you may want to build Sparse twice: once
@@ -208,15 +212,15 @@ ifneq ($(DEP_FILES),)
 include $(DEP_FILES)
 endif
 
-c2xml.o c2xml.sc: CFLAGS += $(LIBXML_CFLAGS)
-
 pre-process.sc: CHECKER_FLAGS += -Wno-vla
 
+CFLAGS += $(${*}_CFLAGS) $(CLI_CFLAGS)
+
 %.o: %.c $(LIB_H)
-	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $<
+	$(QUIET_CC)$(CC) -o $@ -c $(CFLAGS) $<
 
 %.sc: %.c sparse
-	$(QUIET_CHECK) $(CHECKER) $(CHECKER_FLAGS) -c $(ALL_CFLAGS) $<
+	$(QUIET_CHECK) $(CHECKER) $(CHECKER_FLAGS) -c $(CFLAGS) $<
 
 ALL_OBJS :=  $(LIB_OBJS) $(foreach p,$(PROGRAMS),$(p).o $($(p)_EXTRA_DEPS))
 selfcheck: $(ALL_OBJS:.o=.sc)
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS ===

From: Jeff Layton <jlayton () kernel ! org>
To: linux-sparse
Subject: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 15:07:27 +0000
Message-ID: <20171018150727.26821-1-jlayton () kernel ! org>
--------------------
From: Jeff Layton <jlayton@redhat.com>

The fedora packaging tools want to override $CFLAGS when building
sparse, but that fails on a couple of targets.

There are a couple of build targets in the makefile that want to add
options to $CFLAGS. When we do a build though, we pass $ALL_CFLAGS
to the compiler, and that ends up not getting options passed in
via $CFLAGS on the command line.

Fix the two specific build targets to add the options to $ALL_CFLAGS
instead of $CFLAGS.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
---
 Makefile | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Makefile b/Makefile
index d0341764158e..b24680b885fe 100644
--- a/Makefile
+++ b/Makefile
@@ -83,7 +83,7 @@ PROGRAMS += test-inspect
 INST_PROGRAMS += test-inspect
 test-inspect_EXTRA_DEPS := ast-model.o ast-view.o ast-inspect.o
 test-inspect_OBJS := test-inspect.o $(test-inspect_EXTRA_DEPS)
-$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): CFLAGS += $(GTK_CFLAGS)
+$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): ALL_CFLAGS += $(GTK_CFLAGS)
 test-inspect_EXTRA_OBJS := $(GTK_LIBS)
 else
 $(warning Your system does not have gtk3/gtk2, disabling test-inspect)
@@ -208,7 +208,7 @@ ifneq ($(DEP_FILES),)
 include $(DEP_FILES)
 endif
 
-c2xml.o c2xml.sc: CFLAGS += $(LIBXML_CFLAGS)
+c2xml.o c2xml.sc: ALL_CFLAGS += $(LIBXML_CFLAGS)
 
 pre-process.sc: CHECKER_FLAGS += -Wno-vla
 
-- 
2.13.6

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Layton <jlayton () poochiereds ! net>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 15:12:25 +0000
Message-ID: <1508339545.4628.4.camel () poochiereds ! net>
--------------------
On Wed, 2017-10-18 at 11:07 -0400, Jeff Layton wrote:
> From: Jeff Layton <jlayton@redhat.com>
> 
> The fedora packaging tools want to override $CFLAGS when building
> sparse, but that fails on a couple of targets.
> 
> There are a couple of build targets in the makefile that want to add
> options to $CFLAGS. When we do a build though, we pass $ALL_CFLAGS
> to the compiler, and that ends up not getting options passed in
> via $CFLAGS on the command line.
> 
> Fix the two specific build targets to add the options to $ALL_CFLAGS
> instead of $CFLAGS.
> 
> Signed-off-by: Jeff Layton <jlayton@redhat.com>


I had revised this and still sent out the old version. That patch
description should read:

    build: assign extra flags to ALL_CFLAGS instead of CFLAGS
    
    The fedora packaging tools want to override $CFLAGS when building
    sparse, but that fails on a couple of targets.
    
    There are a couple of build targets in the makefile that want to add
    options to $CFLAGS. When we do a build though, we pass $ALL_CFLAGS to
    the compiler, and that ends up without those extra options, if CFLAGS=
    was specified on the command line.
    
    I'm not sure if this is a recursive variable expansion bug in make, but
    we can work around it either way. Fix the two specific build targets to
    add the options to $ALL_CFLAGS instead of $CFLAGS.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>


Let me know if you'd like me to resend it.

> ---
>  Makefile | 4 ++--
>  1 file changed, 2 insertions(+), 2 deletions(-)
> 
> diff --git a/Makefile b/Makefile
> index d0341764158e..b24680b885fe 100644
> --- a/Makefile
> +++ b/Makefile
> @@ -83,7 +83,7 @@ PROGRAMS += test-inspect
>  INST_PROGRAMS += test-inspect
>  test-inspect_EXTRA_DEPS := ast-model.o ast-view.o ast-inspect.o
>  test-inspect_OBJS := test-inspect.o $(test-inspect_EXTRA_DEPS)
> -$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): CFLAGS += $(GTK_CFLAGS)
> +$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): ALL_CFLAGS += $(GTK_CFLAGS)
>  test-inspect_EXTRA_OBJS := $(GTK_LIBS)
>  else
>  $(warning Your system does not have gtk3/gtk2, disabling test-inspect)
> @@ -208,7 +208,7 @@ ifneq ($(DEP_FILES),)
>  include $(DEP_FILES)
>  endif
>  
> -c2xml.o c2xml.sc: CFLAGS += $(LIBXML_CFLAGS)
> +c2xml.o c2xml.sc: ALL_CFLAGS += $(LIBXML_CFLAGS)
>  
>  pre-process.sc: CHECKER_FLAGS += -Wno-vla
>  

-- 
Jeff Layton <jlayton@poochiereds.net>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 19:36:41 +0000
Message-ID: <CANeU7QmPgxKqjZpvudX_MYwhwGWx6nnZrats3brDMVvUUvBTFg () mail ! gmail ! com>
--------------------
On Wed, Oct 18, 2017 at 8:07 AM, Jeff Layton <jlayton@kernel.org> wrote:
> From: Jeff Layton <jlayton@redhat.com>
>
> The fedora packaging tools want to override $CFLAGS when building
> sparse, but that fails on a couple of targets.
>
> There are a couple of build targets in the makefile that want to add
> options to $CFLAGS. When we do a build though, we pass $ALL_CFLAGS
> to the compiler, and that ends up not getting options passed in
> via $CFLAGS on the command line.

Can you give example of what CFLAGS it passed in the command line?
Does it append some flags only?

It seems wrong to overwrite CFLAGS from command line. That are
other flags store in the CFLAGS will get overwritten.

We have add some variable in the ALL_CFLAGS list for overwrite
purpose  e.g. CFLAGS_CMD then have command line over write that?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 19:41:21 +0000
Message-ID: <CAMHZB6FegDPHeNw4tKr59CDz-QXv5NvC-r-+NPto3p7O4BcVmA () mail ! gmail ! com>
--------------------
On Wed, Oct 18, 2017 at 5:12 PM, Jeff Layton <jlayton@poochiereds.net> wrote:
>
>     The fedora packaging tools want to override $CFLAGS when building
>     sparse, but that fails on a couple of targets.
>
>     There are a couple of build targets in the makefile that want to add
>     options to $CFLAGS. When we do a build though, we pass $ALL_CFLAGS to
>     the compiler, and that ends up without those extra options, if CFLAGS=
>     was specified on the command line.
>
>     I'm not sure if this is a recursive variable expansion bug in make, but

I think it's just an effect of CFLAGS being then used as a
target-specific variable

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Layton <jlayton () poochiereds ! net>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 20:00:57 +0000
Message-ID: <1508356857.4628.17.camel () poochiereds ! net>
--------------------
On Wed, 2017-10-18 at 21:41 +0200, Luc Van Oostenryck wrote:
> On Wed, Oct 18, 2017 at 5:12 PM, Jeff Layton <jlayton@poochiereds.net> wrote:
> > 
> >     The fedora packaging tools want to override $CFLAGS when building
> >     sparse, but that fails on a couple of targets.
> > 
> >     There are a couple of build targets in the makefile that want to add
> >     options to $CFLAGS. When we do a build though, we pass $ALL_CFLAGS to
> >     the compiler, and that ends up without those extra options, if CFLAGS=
> >     was specified on the command line.
> > 
> >     I'm not sure if this is a recursive variable expansion bug in make, but
> 
> I think it's just an effect of CFLAGS being then used as a
> target-specific variable
> 
> -- Luc

Ahh ok...so this is probably the correct fix then?

Thanks for looking!
-- 
Jeff Layton <jlayton@poochiereds.net>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 20:21:23 +0000
Message-ID: <CAMHZB6EQq-KV=QXF0VK=G5v6wX+SViWwt-JRph03FV+McEBavg () mail ! gmail ! com>
--------------------
On Wed, Oct 18, 2017 at 10:00 PM, Jeff Layton <jlayton@poochiereds.net> wrote:
> On Wed, 2017-10-18 at 21:41 +0200, Luc Van Oostenryck wrote:
>> On Wed, Oct 18, 2017 at 5:12 PM, Jeff Layton <jlayton@poochiereds.net> wrote:
>> >
>> >     The fedora packaging tools want to override $CFLAGS when building
>> >     sparse, but that fails on a couple of targets.
>> >
>> >     There are a couple of build targets in the makefile that want to add
>> >     options to $CFLAGS. When we do a build though, we pass $ALL_CFLAGS to
>> >     the compiler, and that ends up without those extra options, if CFLAGS=
>> >     was specified on the command line.
>> >
>> >     I'm not sure if this is a recursive variable expansion bug in make, but
>>
>> I think it's just an effect of CFLAGS being then used as a
>> target-specific variable
>>
>> -- Luc
>
> Ahh ok...so this is probably the correct fix then?

I guess so but I don't really know how and what you're overriding.
Something like:
    make CFLAGS="-O3 -some-others-flags"

To be honest, I don't like much sparse's makefile and I don't see the real need
for BASIC_CFLAGS & ALL_CFLAGS.
On the other hand, I understand very well the need for an explicit mechanism for
adding or changing some CFLAGS's flags

> Thanks for looking!

You're most welcome
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 21:25:45 +0000
Message-ID: <CAMHZB6HSkswB1Kar-JDYZXu5=NvQ9gQgkdEL_zVNBtzgs+teqA () mail ! gmail ! com>
--------------------
On Wed, Oct 18, 2017 at 11:08 PM, Jeff Layton <jlayton@poochiereds.net> wrote:
> On Wed, 2017-10-18 at 22:21 +0200, Luc Van Oostenryck wrote:
>> On Wed, Oct 18, 2017 at 10:00 PM, Jeff Layton <jlayton@poochiereds.net> wrote:
>> >
>> > Ahh ok...so this is probably the correct fix then?
>>
>> I guess so but I don't really know how and what you're overriding.
>> Something like:
>>     make CFLAGS="-O3 -some-others-flags"
>>
>
> Yes, quite similar to that.

Yes, I saw in your other email.

> Overriding is probably the wrong word. We just want to pass in a
> baseline set of CFLAGS and then make can add that on to whatever it likes.

Yes, very usual.

> IIUC, the CFLAGS variable is sort of an autotools-ism. We could call it
> something else, but that's sort of the bog-standard way that this is
> done.

I tend to avoid autotool but CFLAGS and friends are used with (g)make
builtin rules, so yes, very standard (and probably predate autotool).

> FWIW, the weird bit here is that the ALL_CFLAGS variable gets reexpanded
> like you'd expect when you don't pass in CFLAGS on the command line.
> It's only when we do that this thing seems to break.
>
> That seems sort of unexpected, IMO, but since we're passing ALL_CFLAGS
> to gcc, it makes sense to add these extra options on there in the
> makefile.
>
>
>> To be honest, I don't like much sparse's makefile and I don't see the real need
>> for BASIC_CFLAGS & ALL_CFLAGS.
>> On the other hand, I understand very well the need for an explicit mechanism for
>> adding or changing some CFLAGS's flags
>>
>
> Yeah, even though it's a pretty simple program, using something like
> autotools or cmake would give all of this the benefit of better
> familiarity for packaging. That also tends to be lower maintenance over
> the long haul of a project in my experience.

It's really not the way I would go but, yes, some cleanups and standardization
would be very welcome.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Wed, 18 Oct 2017 22:14:34 +0000
Message-ID: <CANeU7QnRU7EgQTX1DiDHQj7JZBeKs2ZAeHKKSJNQxhKPXwoKjA () mail ! gmail ! com>
--------------------
On Wed, Oct 18, 2017 at 1:20 PM, Jeff Layton <jlayton@poochiereds.net> wrot=
e:
>
> Fedora, Red Hat, etc., define some macros that are considered "standard"
> build options during packaging. These get passed into "make" and make is
> expected to add to that list as necessary.

Does all open source package follow this convention or that is a result
of a lot of open source project using autotools

>
> Here's what the make command looks like when called by rpmbuild with the
> fedora package (built out of my homedir):
>
>     $ make DESTDIR=3D/home/jlayton/rpmbuild/BUILDROOT/sparse-0.5.1-1.fc26=
.x86_64 PREFIX=3D/usr BINDIR=3D/usr/bin LIBDIR=3D/usr/lib64 INCLUDEDIR=3D/u=
sr/include PKGCONFIGDIR=3D/usr/lib64/pkgconfig -j16 'CFLAGS=3D-O2 -g -pipe =
-Wall -Werror=3Dformat-security -Wp,-D_FORTIFY_SOURCE=3D2 -fexceptions -fst=
ack-protector-strong --param=3Dssp-buffer-size=3D4 -grecord-gcc-switches -s=
pecs=3D/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=3Dgeneric' HAVE_=
LLVM=3Dno

So here by specifying CFLAGS, the original assign for CFLAGS:

CFLAGS =3D -O$(OPT) -finline-functions -fno-strict-aliasing -g

The above assignment will be ignored. Is that intentional?

Put it in a different way, Now " -finline-functions
-fno-strict-aliasing" are no longer
pass to gcc when compile sparse files any more.

>
> This is how things like FORTIFY_SOURCE end up being widespread in
> distros without having to touch every program.
>
>
>> It seems wrong to overwrite CFLAGS from command line. That are
>> other flags store in the CFLAGS will get overwritten.
>>
>
> I'm not sure I understand the objection here. Basically we just want to
> pass in a "base" set of CFLAGS and then let make add others as it sees
> fit.

So your intention is just adding arguments. No removing existing CFLAG
arguments. e.g. removing " -finline-functions -fno-strict-aliasing" from
your invocation is just accident.

>> We have add some variable in the ALL_CFLAGS list for overwrite
>> purpose  e.g. CFLAGS_CMD then have command line over write that?
>>
>
> FWIW, I inherited this specfile long ago and have only tweaked it since.
> It could probably be better, but I'd like to make it less of a special
> snowflake over the long haul. Hand rolled makefiles are generally a pain
> in this regard.

Well, sparse is not using autotools. So it is always be special if you cons=
ider
autotools the norm.

If your goal is just add some baseline compile options to gcc.
It seems better by provide some thing like CFLAGS_CMD as part of the
ALL_CFLAGS group. Then you can just add your options there. The variable
name of "CFLAGS_CMD" is subject to discussion. You can make suggestions.
Overwrite the CFLAGS variable from command line does have side effect
of dropping some options like " -finline-functions -fno-strict-aliasing".
It comes down to is your intend to drop those?

>
> I can certainly adapt the specfile this to pass in some other variable
> than CFLAGS if you like, but I don't really see how that would improve
> anything.

" -finline-functions -fno-strict-aliasing" has impact on the output code
it produce. Unless you are intentionally dropping them. Provide other varia=
ble
for you to overwrite can preserve those compile flags.

You do know that once you specify CFLAGS in the make command line,
by default all other assign to CFLAGS from the Makefile will be ignored.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Layton <jlayton () poochiereds ! net>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Thu, 19 Oct 2017 01:47:43 +0000
Message-ID: <1508377663.19876.20.camel () poochiereds ! net>
--------------------
On Wed, 2017-10-18 at 15:14 -0700, Christopher Li wrote:
> On Wed, Oct 18, 2017 at 1:20 PM, Jeff Layton <jlayton@poochiereds.net
> > wrote:
> > 
> > Fedora, Red Hat, etc., define some macros that are considered
> > "standard"
> > build options during packaging. These get passed into "make" and
> > make is
> > expected to add to that list as necessary.
> 
> Does all open source package follow this convention or that is a
> result
> of a lot of open source project using autotools
> 

Both. Most open source packages use autotools for historical reasons.

> > 
> > Here's what the make command looks like when called by rpmbuild
> > with the
> > fedora package (built out of my homedir):
> > 
> >     $ make DESTDIR=/home/jlayton/rpmbuild/BUILDROOT/sparse-0.5.1-
> > 1.fc26.x86_64 PREFIX=/usr BINDIR=/usr/bin LIBDIR=/usr/lib64
> > INCLUDEDIR=/usr/include PKGCONFIGDIR=/usr/lib64/pkgconfig -j16
> > 'CFLAGS=-O2 -g -pipe -Wall -Werror=format-security -Wp,-
> > D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --
> > param=ssp-buffer-size=4 -grecord-gcc-switches
> > -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic'
> > HAVE_LLVM=no
> 
> So here by specifying CFLAGS, the original assign for CFLAGS:
> 
> CFLAGS = -O$(OPT) -finline-functions -fno-strict-aliasing -g
> 
> The above assignment will be ignored. Is that intentional?
> 
> Put it in a different way, Now " -finline-functions
> -fno-strict-aliasing" are no longer
> pass to gcc when compile sparse files any more.
> 

No, it wasn't intentional. Could we just turn that into a +=
assignment?

> > 
> > This is how things like FORTIFY_SOURCE end up being widespread in
> > distros without having to touch every program.
> > 
> > 
> > > It seems wrong to overwrite CFLAGS from command line. That are
> > > other flags store in the CFLAGS will get overwritten.
> > > 
> > 
> > I'm not sure I understand the objection here. Basically we just
> > want to
> > pass in a "base" set of CFLAGS and then let make add others as it
> > sees
> > fit.
> 
> So your intention is just adding arguments. No removing existing
> CFLAG
> arguments. e.g. removing " -finline-functions -fno-strict-aliasing"
> from
> your invocation is just accident.
> 

Yes.

> > > We have add some variable in the ALL_CFLAGS list for overwrite
> > > purpose  e.g. CFLAGS_CMD then have command line over write that?
> > > 
> > 
> > FWIW, I inherited this specfile long ago and have only tweaked it
> > since.
> > It could probably be better, but I'd like to make it less of a
> > special
> > snowflake over the long haul. Hand rolled makefiles are generally a
> > pain
> > in this regard.
> 
> Well, sparse is not using autotools. So it is always be special if
> you consider
> autotools the norm.
> 
> If your goal is just add some baseline compile options to gcc.
> It seems better by provide some thing like CFLAGS_CMD as part of the
> ALL_CFLAGS group. Then you can just add your options there. The
> variable
> name of "CFLAGS_CMD" is subject to discussion. You can make
> suggestions.
> Overwrite the CFLAGS variable from command line does have side effect
> of dropping some options like " -finline-functions -fno-strict-
> aliasing".
> It comes down to is your intend to drop those?
> 
> > 
> > I can certainly adapt the specfile this to pass in some other
> > variable
> > than CFLAGS if you like, but I don't really see how that would
> > improve
> > anything.
> 
> " -finline-functions -fno-strict-aliasing" has impact on the output
> code
> it produce. Unless you are intentionally dropping them. Provide other
> variable
> for you to overwrite can preserve those compile flags.
> 
> You do know that once you specify CFLAGS in the make command line,
> by default all other assign to CFLAGS from the Makefile will be
> ignored.
> 

Got it, thanks. Basically I just need a way to pass in a basic set of
flags to gcc, that are either appended or prepended to whatever you
need to have in there. If we need to call it something other than
CFLAGS, then that's fine.

Thanks,
-- 
Jeff Layton <jlayton@poochiereds.net>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Layton <jlayton () poochiereds ! net>
To: linux-sparse
Subject: Re: [PATCH] build: assign extra flags to ALL_CFLAGS instead of CFLAGS
Date: Thu, 19 Oct 2017 10:41:35 +0000
Message-ID: <1508409695.4912.7.camel () poochiereds ! net>
--------------------
On Wed, 2017-10-18 at 19:25 -0700, Christopher Li wrote:
> On Wed, Oct 18, 2017 at 6:47 PM, Jeff Layton <jlayton@poochiereds.net> wrote:
> > 
> > No, it wasn't intentional. Could we just turn that into a +=
> > assignment?
> 
> No, turn that into += does not work either. The variable come from
> command line has the $(origin varname) set to "command line".
> make will ignore normal modification to that variable, including "+="
> 
> If you really need to make modification of that variable.
> You need to use the "override" directive.
> 
> https://www.gnu.org/software/make/manual/make.html
> 
>      6.7 The override Directive
> 
> override CFLAGS += "...."
> 
> For that reason, I would suggest using a different variable
> to assign from the command line.
> 
> > 
> > Got it, thanks. Basically I just need a way to pass in a basic set of
> > flags to gcc, that are either appended or prepended to whatever you
> > need to have in there. If we need to call it something other than
> > CFLAGS, then that's fine.
> 
> Right. Given any makefile, I can always pick some internal variable,
> assign that variable from command line, then the make process does
> not work as intended. In our case, CFLAGS is such a variable.
> 
> I would suggest have one variable like CFLAGS_CMD to get
> overwrite from command line. You can suggest the variable name.
> 
> You should also examine your rpmbuild script for other open
> source packages. Weather they suffer from the same CFLAGS overwrite
> problems.
> 

I don't think it's generally a problem. Most of them use autotools or
cmake, which handle this correctly. This is mainly an issue with hand-
rolled makefiles.

> Again, patch is welcome.

Ok, how about this instead? This changes the makefile to just use
BASIC_CFLAGS internally. If CFLAGS is specified on the command line,
it's appended to the list of options.

This allows us to stick with passing in CFLAGS= to make during the build
process:

---------------------8<-------------------------

[PATCH] build: clean up CFLAGS handling in the makefile

The fedora packaging tools want to override $CFLAGS when building
sparse, but that fails on a couple of targets. There are a couple of
build targets in the makefile that want to add options to $CFLAGS.  When
we do a build though, we pass $ALL_CFLAGS to the compiler, and that ends
up without those extra options, if CFLAGS= was specified on the command
line. Change the code to append the options to ALL_CFLAGS instead of
CFLAGS.

At the same time, passing a CFLAGS argument to make ends up the initial
CFLAGS assignment being clobbered such that we lose the options that
are assigned to it internally. Fold the internal usage of CFLAGS into
BASIC_CFLAGS. They both just end up as part of ALL_CFLAGS anyway, so
this should be functionally equivalent.

Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Signed-off-by: Jeff Layton <jlayton@redhat.com>
---
 Makefile | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/Makefile b/Makefile
index d0341764158e..335dcfff54ce 100644
--- a/Makefile
+++ b/Makefile
@@ -12,8 +12,8 @@ OS = linux
 
 
 CC = gcc
-CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
-CFLAGS += -Wall -Wwrite-strings
+BASIC_CFLAGS = -O2 -finline-functions -fno-strict-aliasing -g
+BASIC_CFLAGS += -Wall -Wwrite-strings
 LDFLAGS += -g
 LD = gcc
 AR = ar
@@ -21,7 +21,7 @@ PKG_CONFIG = pkg-config
 CHECKER = ./cgcc -no-compile
 CHECKER_FLAGS =
 
-ALL_CFLAGS = $(CFLAGS) $(BASIC_CFLAGS)
+ALL_CFLAGS = $(BASIC_CFLAGS) $(CFLAGS)
 #
 # For debugging, put this in local.mk:
 #
@@ -44,7 +44,7 @@ LLVM_CONFIG:=llvm-config
 HAVE_LLVM:=$(shell $(LLVM_CONFIG) --version >/dev/null 2>&1 && echo 'yes')
 
 GCC_BASE := $(shell $(CC) --print-file-name=)
-BASIC_CFLAGS = -DGCC_BASE=\"$(GCC_BASE)\"
+BASIC_CFLAGS += -DGCC_BASE=\"$(GCC_BASE)\"
 
 MULTIARCH_TRIPLET := $(shell $(CC) -print-multiarch 2>/dev/null)
 BASIC_CFLAGS += -DMULTIARCH_TRIPLET=\"$(MULTIARCH_TRIPLET)\"
@@ -83,7 +83,7 @@ PROGRAMS += test-inspect
 INST_PROGRAMS += test-inspect
 test-inspect_EXTRA_DEPS := ast-model.o ast-view.o ast-inspect.o
 test-inspect_OBJS := test-inspect.o $(test-inspect_EXTRA_DEPS)
-$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): CFLAGS += $(GTK_CFLAGS)
+$(test-inspect_OBJS) $(test-inspect_OBJS:.o=.sc): ALL_CFLAGS += $(GTK_CFLAGS)
 test-inspect_EXTRA_OBJS := $(GTK_LIBS)
 else
 $(warning Your system does not have gtk3/gtk2, disabling test-inspect)
@@ -208,7 +208,7 @@ ifneq ($(DEP_FILES),)
 include $(DEP_FILES)
 endif
 
-c2xml.o c2xml.sc: CFLAGS += $(LIBXML_CFLAGS)
+c2xml.o c2xml.sc: ALL_CFLAGS += $(LIBXML_CFLAGS)
 
 pre-process.sc: CHECKER_FLAGS += -Wno-vla
 
-- 
2.13.6

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build: clean up $CFLAGS handling in the makefile ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Wed, 25 Oct 2017 14:20:10 +0000
Message-ID: <20171025142009.foxh2rblmfpxvm7d () ltop ! local>
--------------------
On Wed, Oct 25, 2017 at 06:02:22AM -0400, Jeff Layton wrote:
> From: Jeff Layton <jlayton@redhat.com>
> 
> The fedora packaging tools want to provide a base set of $CFLAGS when
> building packages, but that fails when building sparse.
> 
> There are a couple of build targets in the makefile that add options to
> $CFLAGS.  When we do a build though, we pass $ALL_CFLAGS to the
> compiler, and that ends up without those extra options, if CFLAGS= was
> passed to the make command.
> 
> This patch changes the code to append the options to $ALL_CFLAGS instead
> of $CFLAGS. At the same time, passing a CFLAGS argument to make ends up
> with the initial CFLAGS assignment being clobbered such that we lose the
> options that are assigned to it internally. Fold the internal usage of
> CFLAGS into BASIC_CFLAGS. They both just end up as part of ALL_CFLAGS
> anyway, so this should be functionally equivalent.
> 
> Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> Signed-off-by: Jeff Layton <jlayton@redhat.com>
> ---
>  Makefile | 12 ++++++------
>  1 file changed, 6 insertions(+), 6 deletions(-)
> 
> I sent this last week in a reply to a different thread. Re-posting it
> here since it got no replies.
> 

Hi,

I'm fine with this patch but I would prefer to go one step further
and get rid of BASIC_CFLAGS/ALL_CFLAGS while at the same time
being more explicit. I have in mind something like:


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Thu, 26 Oct 2017 10:08:13 +0000
Message-ID: <CANeU7Qnvvezdc62s-cAWNonw2cKOJPWH2xSdgTdAL4M4skSnJw () mail ! gmail ! com>
--------------------
Hi Luc and Jeff,

That get me curious how other package using CFLAGS in their make file
generated by automake and cmake.

I have look at gcc, clang and a few others. My observation is that,
it is up to the package to provide what flags to be override.
There is no fix way to assign and override CFLAGS.

For example, This is one of the line I found in gcc, very typical:

$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS)
$(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS)  -c

The  CFLAGS variable does not contain every thing.
Also explicit overriding the CFLAGS in Makefile is rare. There are
some example doing that. But there is a lot of Makefile don't
explicit override CFLAGS at all.

I also found case that CFLAGS was detect and assigned by ./configure
as part of @CFLAGS@ template. For those case, it is very easy
to mistakenly over written CFLAGS set by ./configure.

For cmake. I have seen some package using C_FLAGS and clang
is using CXX.Flags.

Over all I think having ALL_CFLAGS is fine.

BASIC_CFLAGS might be a bad name.
Our current usage case, we can divide that into three groups.
I still want some name space for CFLAGS instead of adding
every thing to CFLAGS.

ALL_CFLAGS = $(CFLAGS) $(PKG_CFLAGS) $(COMMON_CFLAGS)

COMMON_CFLAGS is the CFLAGS shared by all objects.
It serve as the base line.

PKG_CFLAGS is the CFLAGS introduce by  external packages. like LLVM,
libxml, gtk etc.

CFLAGS just for others to assign from the command line.

That should handle all the CFLAGS we have in sparse right now.

Chris



On Wed, Oct 25, 2017 at 7:20 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> From: Jeff Layton <jlayton@redhat.com>
>>
>> The fedora packaging tools want to provide a base set of $CFLAGS when
>> building packages, but that fails when building sparse.
>>
>> There are a couple of build targets in the makefile that add options to
>> $CFLAGS.  When we do a build though, we pass $ALL_CFLAGS to the
>> compiler, and that ends up without those extra options, if CFLAGS= was
>> passed to the make command.
>>
>> This patch changes the code to append the options to $ALL_CFLAGS instead
>> of $CFLAGS. At the same time, passing a CFLAGS argument to make ends up
>> with the initial CFLAGS assignment being clobbered such that we lose the
>> options that are assigned to it internally. Fold the internal usage of
>> CFLAGS into BASIC_CFLAGS. They both just end up as part of ALL_CFLAGS
>> anyway, so this should be functionally equivalent.
>>
>> Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
>> Signed-off-by: Jeff Layton <jlayton@redhat.com>
>> ---
>>  Makefile | 12 ++++++------
>>  1 file changed, 6 insertions(+), 6 deletions(-)
>>
>> I sent this last week in a reply to a different thread. Re-posting it
>> here since it got no replies.
>>
>
> Hi,
>
> I'm fine with this patch but I would prefer to go one step further
> and get rid of BASIC_CFLAGS/ALL_CFLAGS while at the same time
> being more explicit. I have in mind something like:
>
> From 258efc92cff090bba5ea14a05819514779d7992a Mon Sep 17 00:00:00 2001
> From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> Date: Wed, 25 Oct 2017 14:38:01 +0200
> Subject: [PATCH] build: allow to override CFLAGS via the command line
>
> Some distros (fedora) and some developers want to specifiy their
> own CFLAGS. OTOH most of CFLAGS's content is automatically
> contructed or must not be changed.
>
> This patch, allow to extend CFLAGS via the command line, like:
>         make CFLAGS=-some-extra-flags
>
> The patch also get rid of the confusing CFLAGS/BASIC_CFLAGS/ALL_CFLAGS
>
> With this change, target specific CFLAGS can be given either via
>         target.o: CFLAGS += -some-specific-flags
> or via
>         target_CFLAGS = -some-specific-flags
>
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Layton <jlayton () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Thu, 26 Oct 2017 12:11:25 +0000
Message-ID: <1509019885.29077.6.camel () kernel ! org>
--------------------
I don't have a particular attachment to the patch I proposed. It just
seemed like the simplest change that fixes the problem I'm having,
without changing anything in the common case where no CFLAGS are passed
to make. Luc's patch would be fine with me too.

It's not clear to me what Chris is suggesting below. It sounds sort of
like you're OK with the patch I originally suggested, but want different
variable names?

Perhaps instead of describing it, you could roll up an alternative patch
that shows what you would prefer to see here?

-- Jeff

On Thu, 2017-10-26 at 03:08 -0700, Christopher Li wrote:
> Hi Luc and Jeff,
> 
> That get me curious how other package using CFLAGS in their make file
> generated by automake and cmake.
> 
> I have look at gcc, clang and a few others. My observation is that,
> it is up to the package to provide what flags to be override.
> There is no fix way to assign and override CFLAGS.
> 
> For example, This is one of the line I found in gcc, very typical:
> 
> $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS)
> $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS)  -c
> 
> The  CFLAGS variable does not contain every thing.
> Also explicit overriding the CFLAGS in Makefile is rare. There are
> some example doing that. But there is a lot of Makefile don't
> explicit override CFLAGS at all.
> 
> I also found case that CFLAGS was detect and assigned by ./configure
> as part of @CFLAGS@ template. For those case, it is very easy
> to mistakenly over written CFLAGS set by ./configure.
> 
> For cmake. I have seen some package using C_FLAGS and clang
> is using CXX.Flags.
> 
> Over all I think having ALL_CFLAGS is fine.
> 
> BASIC_CFLAGS might be a bad name.
> Our current usage case, we can divide that into three groups.
> I still want some name space for CFLAGS instead of adding
> every thing to CFLAGS.
> 
> ALL_CFLAGS = $(CFLAGS) $(PKG_CFLAGS) $(COMMON_CFLAGS)
> 
> COMMON_CFLAGS is the CFLAGS shared by all objects.
> It serve as the base line.
> 
> PKG_CFLAGS is the CFLAGS introduce by  external packages. like LLVM,
> libxml, gtk etc.
> 
> CFLAGS just for others to assign from the command line.
> 
> That should handle all the CFLAGS we have in sparse right now.
> 
> Chris
> 
> 
> 
> On Wed, Oct 25, 2017 at 7:20 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > > From: Jeff Layton <jlayton@redhat.com>
> > > 
> > > The fedora packaging tools want to provide a base set of $CFLAGS when
> > > building packages, but that fails when building sparse.
> > > 
> > > There are a couple of build targets in the makefile that add options to
> > > $CFLAGS.  When we do a build though, we pass $ALL_CFLAGS to the
> > > compiler, and that ends up without those extra options, if CFLAGS= was
> > > passed to the make command.
> > > 
> > > This patch changes the code to append the options to $ALL_CFLAGS instead
> > > of $CFLAGS. At the same time, passing a CFLAGS argument to make ends up
> > > with the initial CFLAGS assignment being clobbered such that we lose the
> > > options that are assigned to it internally. Fold the internal usage of
> > > CFLAGS into BASIC_CFLAGS. They both just end up as part of ALL_CFLAGS
> > > anyway, so this should be functionally equivalent.
> > > 
> > > Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> > > Signed-off-by: Jeff Layton <jlayton@redhat.com>
> > > ---
> > >  Makefile | 12 ++++++------
> > >  1 file changed, 6 insertions(+), 6 deletions(-)
> > > 
> > > I sent this last week in a reply to a different thread. Re-posting it
> > > here since it got no replies.
> > > 
> > 
> > Hi,
> > 
> > I'm fine with this patch but I would prefer to go one step further
> > and get rid of BASIC_CFLAGS/ALL_CFLAGS while at the same time
> > being more explicit. I have in mind something like:
> > 
> > From 258efc92cff090bba5ea14a05819514779d7992a Mon Sep 17 00:00:00 2001
> > From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> > Date: Wed, 25 Oct 2017 14:38:01 +0200
> > Subject: [PATCH] build: allow to override CFLAGS via the command line
> > 
> > Some distros (fedora) and some developers want to specifiy their
> > own CFLAGS. OTOH most of CFLAGS's content is automatically
> > contructed or must not be changed.
> > 
> > This patch, allow to extend CFLAGS via the command line, like:
> >         make CFLAGS=-some-extra-flags
> > 
> > The patch also get rid of the confusing CFLAGS/BASIC_CFLAGS/ALL_CFLAGS
> > 
> > With this change, target specific CFLAGS can be given either via
> >         target.o: CFLAGS += -some-specific-flags
> > or via
> >         target_CFLAGS = -some-specific-flags
> > 
> > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

-- 
Jeff Layton <jlayton@kernel.org>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Thu, 26 Oct 2017 17:11:50 +0000
Message-ID: <CANeU7Qmv5qcN-MDbwHRbF74Cahu6xCjzEZ3PAk3EEai93umdMA () mail ! gmail ! com>
--------------------
On Thu, Oct 26, 2017 at 5:11 AM, Jeff Layton <jlayton@kernel.org> wrote:
>
> It's not clear to me what Chris is suggesting below. It sounds sort of
> like you're OK with the patch I originally suggested, but want different
> variable names?
>
> Perhaps instead of describing it, you could roll up an alternative patch
> that shows what you would prefer to see here?

Sure. I am traveling today so I am not able to send out the patch today.

I will do that.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Sun, 29 Oct 2017 17:28:10 +0000
Message-ID: <20171029172809.6nlaz5lvxdcs677w () ltop ! local>
--------------------
On Sun, Oct 29, 2017 at 07:32:39PM +0800, Christopher Li wrote:
> On Thu, Oct 26, 2017 at 8:11 PM, Jeff Layton <jlayton@kernel.org> wrote:
> >
> > Perhaps instead of describing it, you could roll up an alternative patch
> > that shows what you would prefer to see here?
> 
> Here it is the patch.
> 
> I push it on https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=cflags
> 
> Chris
> 
> From 9fc170ec5e5814ae858922496dea668bb80dbf34 Mon Sep 17 00:00:00 2001
> From: Christopher Li <sparse@chrisli.org>
> Date: Sun, 29 Oct 2017 19:16:44 +0800
> Subject: [PATCH] Makefile: provide CFLAGS for command line override.
> 
> Avoid assign to CFLAGS in Makefile.
> Rename BASIC_CFLAGS to COMMON_CFLAGS.
> Use PKG_CFLAGS to store external package related cflags.

The goal of the initial patch, as stated by Jeff, was:
"The fedora packaging tools want to *override* $CFLAGS when building sparse"

This version doesn't allow to override CFLAGS.
See what happens with 'make CFLAGS=-O3' for example.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Sun, 29 Oct 2017 21:53:49 +0000
Message-ID: <CANeU7QnQi3313pVMiv4pGTZE51XU2EUbrB3Dg=DHgM-T-7f0EA () mail ! gmail ! com>
--------------------
On Mon, Oct 30, 2017 at 1:28 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The goal of the initial patch, as stated by Jeff, was:
> "The fedora packaging tools want to *override* $CFLAGS when building sparse"
>
> This version doesn't allow to override CFLAGS.
> See what happens with 'make CFLAGS=-O3' for example.

The original patch proposed by Jeff does not allow usage of
"make CFLAGS=-O3" either.  I take a look at your patch, it behave
the same way in this regard. Do you mean I should change the
commit title to *append* CFLAGS instead of override?

May be Jeff can clarify the intention?

BTW, I am actually leaning toward just expose some thing like
CLI_CFLAGS to be override by package builders. I am not that
convince override CFLAGS is established stander practices from
the project that I have look at.

On the other hand, it is trivial to avoid using CFLAGS in sparse
Makefile. If Jeff really want CFLAGS instead of CLI_CFLAGS,
it is not a big a deal.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Sun, 29 Oct 2017 22:11:56 +0000
Message-ID: <20171029221155.gqki2qshonjhyy66 () s>
--------------------
On Mon, Oct 30, 2017 at 05:53:49AM +0800, Christopher Li wrote:
> On Mon, Oct 30, 2017 at 1:28 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > The goal of the initial patch, as stated by Jeff, was:
> > "The fedora packaging tools want to *override* $CFLAGS when building sparse"
> >
> > This version doesn't allow to override CFLAGS.
> > See what happens with 'make CFLAGS=-O3' for example.
> 
> The original patch proposed by Jeff does not allow usage of
> "make CFLAGS=-O3" either.  I take a look at your patch, it behave
> the same way in this regard. Do you mean I should change the
> commit title to *append* CFLAGS instead of override?
> 
> May be Jeff can clarify the intention?
> 
> BTW, I am actually leaning toward just expose some thing like
> CLI_CFLAGS to be override by package builders. I am not that
> convince override CFLAGS is established stander practices from
> the project that I have look at.

`make CFLAGS='-arbitrary -flags'` is quite common, and people generally
expect it to work, though it isn't *shocking* when it breaks. Though the
exact boundary for what should get overridden by that and what should
remain seems a bit fuzzy. Roughly speaking, if the application normally
wants to build with "-O2 -ffooish-bar -Wall -Wanother -I/some/path" ,
then `make CFLAGS='-Os -arbitrary -flags'` should build with "-Os
-arbitrary -flags -Wall -Wanother -Isome-path`. I think.

> On the other hand, it is trivial to avoid using CFLAGS in sparse
> Makefile. If Jeff really want CFLAGS instead of CLI_CFLAGS,
> it is not a big a deal.

I think it's worth not putting anything into CFLAGS that would break the
build if missing.

For instance, git's Makefile specifically says "# CFLAGS and LDFLAGS are
for the users to override from the command line.", and then just has
"CFLAGS = -g -O2 -Wall". It then has additional variables like
ALL_CFLAGS that include both CFLAGS and other things.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Sun, 29 Oct 2017 22:48:50 +0000
Message-ID: <CANeU7Qm5MhX45crgY-oWLHqBBUHRJ5bK6RiBOKT9+8c3Ar3orA () mail ! gmail ! com>
--------------------
On Mon, Oct 30, 2017 at 6:11 AM, Josh Triplett <josh@joshtriplett.org> wrote:

> `make CFLAGS='-arbitrary -flags'` is quite common, and people generally
> expect it to work, though it isn't *shocking* when it breaks. Though the
> exact boundary for what should get overridden by that and what should
> remain seems a bit fuzzy. Roughly speaking, if the application normally
> wants to build with "-O2 -ffooish-bar -Wall -Wanother -I/some/path" ,
> then `make CFLAGS='-Os -arbitrary -flags'` should build with "-Os
> -arbitrary -flags -Wall -Wanother -Isome-path`. I think.

Thanks for the feed back. Yes, there is some project do that.
Those project also document it.
On the other hand, some cmake project don't use CFLAGS
at all as far as I can tell.


So I think as long as the project provide clear document for what
it expect to be override from command line, the package builder
use it consistently. That is fine.

> I think it's worth not putting anything into CFLAGS that would break the
> build if missing.
>
> For instance, git's Makefile specifically says "# CFLAGS and LDFLAGS are
> for the users to override from the command line.", and then just has
> "CFLAGS = -g -O2 -Wall". It then has additional variables like

We can do that for sparse if some one want to use it his way.
On the other hand, I think it is up to the package to decide what
to be allow to override.

The package builder should not take it for granted that very package
should work in this way. Some project don't use CFLAGS at all.

Provide the interface as needed, then document it. That seems to
be the right thing to do.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Mon, 30 Oct 2017 05:40:40 +0000
Message-ID: <20171030054039.4qjxtpcpxq2xnvcd () ltop ! local>
--------------------
On Mon, Oct 30, 2017 at 05:53:49AM +0800, Christopher Li wrote:
> On Mon, Oct 30, 2017 at 1:28 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > The goal of the initial patch, as stated by Jeff, was:
> > "The fedora packaging tools want to *override* $CFLAGS when building sparse"
> >
> > This version doesn't allow to override CFLAGS.
> > See what happens with 'make CFLAGS=-O3' for example.
> 
> The original patch proposed by Jeff does not allow usage of
> "make CFLAGS=-O3" either.  I take a look at your patch, it behave
> the same way in this regard. Do you mean I should change the
> commit title to *append* CFLAGS instead of override?

Since for flags like -O[0123] but also for all flags like -f[no-]xxx
and all sort of others settings in GCC and in a multitude of others
programs it's the last value that matters, appending to CFLAGS *is*
the usual way to *override* previous settings.
Jeff's patch allowed that, mine too but yours not.
 
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Wed, 01 Nov 2017 00:56:47 +0000
Message-ID: <CANeU7Qm8YHpYLLW8O=y=m9m6kRAD_5MiTnS79N5ffCk-PVcxFQ () mail ! gmail ! com>
--------------------
On Tue, Oct 31, 2017 at 2:57 PM, Jeff Layton <jlayton@kernel.org> wrote:
> As Luc and Josh pointed out, I think we want $(CFLAGS) last here. That
> allows you to pass in options that can supersede what the makefile puts
> in there.
> ...other than that, I'm fine with this. Assuming you fix that, you can
> add:

I update the patch here and git url:
https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=cflags-v2

Chris


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Sun, 05 Nov 2017 00:45:53 +0000
Message-ID: <CANeU7Qm4+DWdcDrMytWqxTELrwuyMEkhs2hFGj6599ghetBE8A () mail ! gmail ! com>
--------------------
On Wed, Nov 1, 2017 at 10:17 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:

> This is still not correct. It still doesn't allow to compile sparse
> via 'make CFLAGS=<some extra flags, possibly none>'.
>
> Visibly this hasn't been tested.

Sorry about that.

There is one spot I miss after solving conflict of rebase master.

How about this one:

https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=cflags-v3

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Sun, 05 Nov 2017 16:57:53 +0000
Message-ID: <20171105165751.iqqlaxz6yu27nouj () ltop ! local>
--------------------
On Sun, Nov 05, 2017 at 08:45:53AM +0800, Christopher Li wrote:
> On Wed, Nov 1, 2017 at 10:17 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> 
> > This is still not correct. It still doesn't allow to compile sparse
> > via 'make CFLAGS=<some extra flags, possibly none>'.
> >
> > Visibly this hasn't been tested.
> 
> Sorry about that.
> 
> There is one spot I miss after solving conflict of rebase master.

You rejected the patch, wrote your own version and you had to rebase it
and you had a conflict?
 
> How about this one:
> 
> https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/log/?h=cflags-v3

Much better!
Now you can give it a try at 'make CFLAGS=-O3 selfcheck'.


-- Luc Van Oostenryck 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Thu, 09 Nov 2017 21:10:48 +0000
Message-ID: <CANeU7Qk=pg0kWEoT6KUK_+6PVEjfAJeh+-_=dB_LqT-Bh+88CQ () mail ! gmail ! com>
--------------------
On Mon, Nov 6, 2017 at 12:57 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Much better!
> Now you can give it a try at 'make CFLAGS=-O3 selfcheck'.
>
The selfcheck on sparse-llvm.sc is independent of the CFLAGS changes.
BTW, I never saw the brakage on FC 26. because "llvm-config --cflags" does not
add new search path.

Here is the V4:

https://git.kernel.org/pub/scm/devel/sparse/chrisl/sparse.git/commit/?h=cflags-v4

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Thu, 09 Nov 2017 21:26:10 +0000
Message-ID: <20171109212607.4lnd6aedr63c5ta2 () ltop ! local>
--------------------
On Fri, Nov 10, 2017 at 05:10:48AM +0800, Christopher Li wrote:
> On Mon, Nov 6, 2017 at 12:57 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > Much better!
> > Now you can give it a try at 'make CFLAGS=-O3 selfcheck'.
> >
> The selfcheck on sparse-llvm.sc is independent of the CFLAGS changes.

On the contrary, it's very much at the core of the way the
different CFLAGS variable are used.

Everywhere you will use something like:
   <sometarget>.o: <some CFLAGS variant> += <something>
you will also need to add <sometarget>.sc
It's the way you solve the problem and it may seems to you 
independent of the CFLAGS changes and yet in my version of
the CFLAGS changes this bug was solved automatically by how
the CFLAGS were used (I discovered the bug while writting the
patch; you know this "ohoh, this can't possibly be correct").

But well, more than enough time have already spend on these CFLAGS.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: clean up $CFLAGS handling in the makefile
Date: Thu, 09 Nov 2017 22:18:46 +0000
Message-ID: <CANeU7QkW=UuptVXFwnv-5f2GmZQVuHBvk_H5Hu13-MG=jeDduA () mail ! gmail ! com>
--------------------
On Fri, Nov 10, 2017 at 5:26 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> The selfcheck on sparse-llvm.sc is independent of the CFLAGS changes.
>
> On the contrary, it's very much at the core of the way the
> different CFLAGS variable are used.

I mean the bug is triggerable even before the CFLAGS patch applied.

>
> Everywhere you will use something like:
>    <sometarget>.o: <some CFLAGS variant> += <something>
> you will also need to add <sometarget>.sc
> It's the way you solve the problem and it may seems to you
> independent of the CFLAGS changes and yet in my version of
> the CFLAGS changes this bug was solved automatically by how
> the CFLAGS were used (I discovered the bug while writting the
> patch; you know this "ohoh, this can't possibly be correct").

I see. You avoid using target specific variables. That might be
a good idea. I was looking for the smallest fix to so that
don't impact too much on the other Makefile changes.

I don't like to have CFLAGS += for every thing though.
It only works if the options always append from the tail.
If it is order sensitive, need to insert in the middle, then
you will need to have sub variable to group from any way,
like your CPPFLAGS.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build: make PREFIX overwritable on the commandline ===

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: Re: [PATCH] build: make PREFIX overwritable on the commandline
Date: Sat, 23 Sep 2017 18:31:53 +0000
Message-ID: <20170923183153.i4mt4zlsniv22jbv () taurus ! defre ! kleine-koenig ! org>
--------------------

--5or4puarkrrril6i
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Sat, Sep 23, 2017 at 07:20:27AM -0400, Christopher Li wrote:
> On Fri, Sep 22, 2017 at 5:25 PM, Uwe Kleine-K=F6nig <uwe@kleine-koenig.or=
g> wrote:
> > This way I can just use
> >
> >         make install PREFIX=3D/usr
> >
> > on the command line to install sparse into the system.
> >
> >  DESTDIR=3D
> > -PREFIX=3D$(HOME)
> > +PREFIX ?=3D $(HOME)
>=20
> Are you sure you need this patch to use "make install PREFIX=3D/usr" ?

Oh, you're right. I pass PREFIX via the environment. But as there are
already other things I pass on the command line I can also pass PREFIX
there. I still consider ?=3D as the right thing to do there, but it's not
important any more. If you still consider the patch fine, I can update
the commit log accordingly.

Best regards
Uwe

--5or4puarkrrril6i
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQEzBAABCgAdFiEEfnIqFpAYrP8+dKQLwfwUeK3K7AkFAlnGqJYACgkQwfwUeK3K
7AmeUwgAkxO061p5nGFxJstStE+wQV1OVJVnrvFp7PlMnJQaoggbs4INDKx2Goz/
jaWyHeKSoVKoOojNENrjKaiu0KxGRJ/WGfIXDQe0At3U63dWI0F8Ao9BUi54il1O
OqRzZvrarKGL7xsEFcjQdrpBfnlGjhWHADB2+hRy7TevspqS5RYqymKFYhK9HzIz
KpfkOEzY/HL7dprVgtwwSM5x94leXpt6UhAfRjkBnAEKB4OAa38vBycs7b+x08j4
TrleupvntjRCPiGb6OvcjauWFTSF+JwP+QLoBszYQLleatanjPd+oaUdlGJQ/wSh
fueBrQrMT7M+RKcvJqFDLheCgjjzdw==
=gI+S
-----END PGP SIGNATURE-----

--5or4puarkrrril6i--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: make PREFIX overwritable on the commandline
Date: Tue, 03 Oct 2017 04:38:05 +0000
Message-ID: <CANeU7Q=KhrFivJ5DriRDX_R102uvN=4UteMbSwsxGHvaeatPLA () mail ! gmail ! com>
--------------------
On Sat, Sep 23, 2017 at 2:31 PM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.o=
rg> wrote:
>> Are you sure you need this patch to use "make install PREFIX=3D/usr" ?
>
> Oh, you're right. I pass PREFIX via the environment. But as there are
> already other things I pass on the command line I can also pass PREFIX
> there. I still consider ?=3D as the right thing to do there, but it's not
> important any more. If you still consider the patch fine, I can update
> the commit log accordingly.

Sorry for the delay. I am catching up with the patches.
I don't mind having the patch if you want to pass PREFIX from the
environment.

Please update the comments.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build: only generate version.h when needed and remove it in
 clean target ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe@kleine-koenig.org>
To: Unknown
Subject: [PATCH] build: only generate version.h when needed and remove it in
 clean target
Date: Thu, 14 Sep 2017 20:45:40 +0200
Message-ID: 
--------------------
This way version.h isn't generated when running $(make clean) but only
when lib.c is about to be compiled.

This simplifies packaging for Debian because the package building programs
abort when there are additional files after $(make clean).

---
 Makefile | 19 +++++++++++++------
 1 file changed, 13 insertions(+), 6 deletions(-)

diff --git a/Makefile b/Makefile
index ee1334c42..1491accb0 100644
--- a/Makefile
+++ b/Makefile
@@ -1,12 +1,6 @@
 VERSION=0.5.1
 
-# Generating file version.h if current version has changed
 SPARSE_VERSION:=$(shell git describe 2>/dev/null || echo '$(VERSION)')
-VERSION_H := $(shell cat version.h 2>/dev/null)
-ifneq ($(lastword $(VERSION_H)),"$(SPARSE_VERSION)")
-$(info $(shell echo '     GEN      'version.h))
-$(shell echo '#define SPARSE_VERSION "$(SPARSE_VERSION)"' > version.h)
-endif
 
 OS = linux
 
@@ -204,6 +198,17 @@ CFLAGS += ${${*}_CFLAGS}
 selfcheck: $(OBJS:.o=.sc)
 
 
+lib.o: version.h
+version.h: FORCE
+	@echo '#define SPARSE_VERSION "$(SPARSE_VERSION)"' > version.h.tmp
+	@if cmp -s version.h version.h.tmp; then \
+		rm version.h.tmp; \
+	else \
+		echo    '     GEN      '$@; \
+		mv version.h.tmp version.h; \
+	fi
+
+
 clean: clean-check
 	rm -f *.[oa] .*.d *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc version.h
 
@@ -225,3 +230,5 @@ clean-check:
 	                 -o -name "*.c.error.got" \
 	                 -o -name "*.c.error.diff" \
 	                 \) -exec rm {} \;
+
+.PHONY: FORCE
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] build: only generate version.h when needed and remove it in clean target ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: only generate version.h when needed and remove it in clean target
Date: Fri, 15 Sep 2017 16:52:19 +0000
Message-ID: <CANeU7QnQ-fFvvUfqjCjXfUT5Dn-+vEY-u0KxnNPML3G3iuNBZw () mail ! gmail ! com>
--------------------
On Thu, Sep 14, 2017 at 2:45 PM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.o=
rg> wrote:
>
> -# Generating file version.h if current version has changed
>  SPARSE_VERSION:=3D$(shell git describe 2>/dev/null || echo '$(VERSION)')
> -VERSION_H :=3D $(shell cat version.h 2>/dev/null)
> -ifneq ($(lastword $(VERSION_H)),"$(SPARSE_VERSION)")
> -$(info $(shell echo '     GEN      'version.h))
> -$(shell echo '#define SPARSE_VERSION "$(SPARSE_VERSION)"' > version.h)
> -endif

You don't need to move them to into a rule section.

You can use "ifneq ($(MAKECMDGOALS),clean)"
to wrap it. GNU make document even show that as examples
of using $(MAKECMDGOALS).


> +version.h: FORCE
> +       $(QUIET_GEN)echo '#define SPARSE_VERSION "$(SPARSE_VERSION)"' > v=
ersion.h.tmp; \
> +       if cmp -s version.h version.h.tmp; then \
> +               rm version.h.tmp; \
> +       else \
> +               mv version.h.tmp version.h; \
> +       fi
> +
> +.PHONY: FORCE
> +
> +lib.o: version.h
> +

The above section is not needed if you use the ifneq test on $(MAKECMDGOALS=
).
I also test it and found the problem that, the version.h was force
to obsolete. Two consequent make will always show "GEN version.h"
line.

>  clean: clean-check
> -       rm -f *.[oa] .*.d *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h spa=
rse.pc
> +       rm -f *.[oa] .*.d *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h spa=
rse.pc version.h

This line is good.

If you don't mind I am going to apply this (the 3 liner version) after
my debug build patches.
It has conflict with my debug build patch and it is much easier to fix conf=
lict
on this 3 liner patch than the other way around.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: only generate version.h when needed and remove it in clean target
Date: Tue, 19 Sep 2017 13:13:06 +0000
Message-ID: <CANeU7Q=DcKL2qjHvwN50UM5nQ5bcs-WuhC2Yx26FVm6NTkP5fQ () mail ! gmail ! com>
--------------------
On Thu, Sep 14, 2017 at 2:45 PM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.o=
rg> wrote:
> This way version.h isn't generated when running $(make clean) but only
> when lib.c is about to be compiled.
>
> This simplifies packaging for Debian because the package building program=
s
> abort when there are additional files after $(make clean).

BTW, this one needs a SOB as well. I want to apply the modify 3 liner
version using the $(MAKECMDGOALS).

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: Re: [PATCH] build: only generate version.h when needed and remove it in clean target
Date: Tue, 19 Sep 2017 14:50:00 +0000
Message-ID: <8d555c9d-6eb0-85a2-5f78-999aaf0b12e7 () kleine-koenig ! org>
--------------------
This is an OpenPGP/MIME signed message (RFC 4880 and 3156)
--r2ikxPjIXpmvSGEguUpS1VDt5CX2knoaR
Content-Type: multipart/mixed; boundary="g1Ktx3tAlQ32Ov9iTbeXhODu2XXrAM2eW";
 protected-headers="v1"
From: =?UTF-8?Q?Uwe_Kleine-K=c3=b6nig?= <uwe@kleine-koenig.org>
To: Christopher Li <sparse@chrisli.org>
Cc: Linux-Sparse <linux-sparse@vger.kernel.org>
Message-ID: <8d555c9d-6eb0-85a2-5f78-999aaf0b12e7@kleine-koenig.org>
Subject: Re: [PATCH] build: only generate version.h when needed and remove it
 in clean target
References: <20170914184540.26650-1-uwe@kleine-koenig.org>
 <CANeU7QnQ-fFvvUfqjCjXfUT5Dn-+vEY-u0KxnNPML3G3iuNBZw@mail.gmail.com>
In-Reply-To: <CANeU7QnQ-fFvvUfqjCjXfUT5Dn-+vEY-u0KxnNPML3G3iuNBZw@mail.gmail.com>

--g1Ktx3tAlQ32Ov9iTbeXhODu2XXrAM2eW
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: quoted-printable

On 09/15/2017 06:52 PM, Christopher Li wrote:
> On Thu, Sep 14, 2017 at 2:45 PM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koen=
ig.org> wrote:
>>
>> -# Generating file version.h if current version has changed
>>  SPARSE_VERSION:=3D$(shell git describe 2>/dev/null || echo '$(VERSION=
)')
>> -VERSION_H :=3D $(shell cat version.h 2>/dev/null)
>> -ifneq ($(lastword $(VERSION_H)),"$(SPARSE_VERSION)")
>> -$(info $(shell echo '     GEN      'version.h))
>> -$(shell echo '#define SPARSE_VERSION "$(SPARSE_VERSION)"' > version.h=
)
>> -endif
>=20
> You don't need to move them to into a rule section.
>=20
> You can use "ifneq ($(MAKECMDGOALS),clean)"

So it still triggers when doing

	make clean all

Also you don't want to generate it for $(make check).

IMHO that's hardly manageable to get done consistently this way and the
easiest is a separate rule for version.h that is triggered by make
dependencies as I suggested

> to wrap it. GNU make document even show that as examples
> of using $(MAKECMDGOALS).

IMHO that is no prove that the idea is sane.

>> +version.h: FORCE
>> +       $(QUIET_GEN)echo '#define SPARSE_VERSION "$(SPARSE_VERSION)"' =
> version.h.tmp; \
>> +       if cmp -s version.h version.h.tmp; then \
>> +               rm version.h.tmp; \
>> +       else \
>> +               mv version.h.tmp version.h; \
>> +       fi
>> +
>> +.PHONY: FORCE
>> +
>> +lib.o: version.h
>> +
>=20
> The above section is not needed if you use the ifneq test on $(MAKECMDG=
OALS).> I also test it and found the problem that, the version.h was forc=
e
> to obsolete. Two consequent make will always show "GEN version.h"
> line.

Then maybe split it into

	CHECK version.h
	GEN   version.h

? The GEN would be skipped if version.h doesn't need an update.

Best regards
Uwe


--g1Ktx3tAlQ32Ov9iTbeXhODu2XXrAM2eW--

--r2ikxPjIXpmvSGEguUpS1VDt5CX2knoaR
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: OpenPGP digital signature
Content-Disposition: attachment; filename="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEfnIqFpAYrP8+dKQLwfwUeK3K7AkFAlnBLpgACgkQwfwUeK3K
7Ak5vwf/ee+G9MIceNmNIBAm7Bba/UsIjAaGtZ/T+uYMYDlCVPzu6x/DFkA6Xdsq
kqALKDwlCS7EyIaPvrSzcNR3q3P0Tj3+BGyJOVWU39YOQ4mOO3MpmYZbOzNJp1lH
LrGAX+tdiqAhcTm+duwT7x1oAjjdsBVBLKM7QRBZDsr75YdK37zu4NuEhUYO9I1G
P8onHgggUKE/8PE1CjeQd5jQWVhB2hIgGk7WJ1YeAFdmM8r8plQeFR7kLy70PMjI
KMsFNKg/00+NDK1eKru8v/sQv+MF7Ww3C22k6Ha5UtjKOcMOevvwZ1xGZK67MeQR
6xCkXddy1M1RzW8iLksXKBzSh0H9DQ==
=rBvY
-----END PGP SIGNATURE-----

--r2ikxPjIXpmvSGEguUpS1VDt5CX2knoaR--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: only generate version.h when needed and remove it in clean target
Date: Tue, 19 Sep 2017 15:42:30 +0000
Message-ID: <CANeU7Q=+pM5=Lezf1Wo750ULaKGvLTOMCvTMp6zvPdiKzu_S3w () mail ! gmail ! com>
--------------------
On Tue, Sep 19, 2017 at 10:50 AM, Uwe Kleine-K=C3=B6nig
<uwe@kleine-koenig.org> wrote:
>> You can use "ifneq ($(MAKECMDGOALS),clean)"
>
> So it still triggers when doing
>
>         make clean all

That is the correct behavior. Because "all" require version.h.
It is a silly thing to put clean and all together, but the makefile
actually do the right thing.

>
> Also you don't want to generate it for $(make check).

check is depend on all which depend on version.h.
So that seems acceptable to me.

Plus in the make check case, it will only look at the version.h,
it will not regenerate it if data is the same.

> IMHO that's hardly manageable to get done consistently this way and the
> easiest is a separate rule for version.h that is triggered by make
> dependencies as I suggested

The problem is that, you end up updating the version.h from make's
point of view. Then make detect the version.h's time stamp haven't
change and take a short cut. That is the part I consider not clean.

In other words, if you only look at the make rules and ignore the
time stamp short cut. "version.h" will be force to update every
time. It should also recompile lib.o without the short cut.

>> to wrap it. GNU make document even show that as examples
>> of using $(MAKECMDGOALS).
>
> IMHO that is no prove that the idea is sane.

All the example you give seems give sane result.


>> The above section is not needed if you use the ifneq test on $(MAKECMDGO=
ALS).> I also test it and found the problem that, the version.h was force
>> to obsolete. Two consequent make will always show "GEN version.h"
>> line.
>
> Then maybe split it into
>
>         CHECK version.h
>         GEN   version.h
>
> ? The GEN would be skipped if version.h doesn't need an update.

Then there is another thing I consider slightly unclean.
The check rules will optionally update another target "version.h" without
specificity in its rules.

We can use order only rules for check target. The whole thing seems
gets more complicated than it needs to.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] build: only generate version.h when needed and remove it in clean target
Date: Tue, 19 Sep 2017 20:11:21 +0000
Message-ID: <CANeU7Qm5F7-OJz9URvxXwu7Uwy4JV-pP7C5k1dGkGxkOxxjN9g () mail ! gmail ! com>
--------------------
On Tue, Sep 19, 2017 at 2:19 PM, Uwe Kleine-K=C3=B6nig <uwe@kleine-koenig.o=
rg> wrote:
>              CC       pre-process.o
>              CC       symbol.o
>              CC       lib.o
>         lib.c:46:10: fatal error: version.h: No such file or directory
>          #include "version.h"
>                   ^~~~~~~~~~~
>         compilation terminated.
>         Makefile:212: recipe for target 'lib.o' failed
>         make: *** [lib.o] Error 1
>
> I'd say this is not correct behaviour. The problem is that as is done now=
,
> version.h is created while make parses the Makefile and doesn't really
> know about the dependencies (yet). As a consequence make doesn't notice
> that version.h is missing while compiling lib.c.

No, that is not what is happening. What is happen is that, your "make clean=
 all"
is incorrect command in the sense that, "clean" and "all" does not have
dependency and order between them. So it is just a race condition which get
to run first in the parallel build environment.

In your case, there is only one job. Clean runs first.

But if there is more than one job, even you specify the
lib.o depend on version.h. It is still not safe.
It can happen in the order of:

1) job1 "create version.h",
2) job2 "clean" remove version.h
3) job1 compile lib.o -> missing version.h

The root of the evil is that, your "make clean all" does not make
sense. It does not specify order between "clean" vs "all".
make can invoke it whichever order it see fit.
You get it working it is just because you are on the lucky path.

> So here are needlessly two things mixed: parsing the Makefile and
> generating version.h. It all gets easier if Makefile is parsed first
> without caring about version.h as something special and then treat the
> header just like every other target.

You should not mix clean with other target. Period.
Try to support that create a lot of complexity and corner cases.

>> Plus in the make check case, it will only look at the version.h,
>> it will not regenerate it if data is the same.
>
> That's shared with my approach.

it is slightly different in the sense that, the checking is all done
in GNU make function instead of invoking external shell. Granted, we
can use $(file ) function to remove the $(sell cat ) part.

It is slightly harder to do that inside the rule section.

Your patch will always update the version.h and force it to
run the command section. Which has a few shell commands.

>
> I cannot follow here. lib.c depends on version.h and always when you
> update version.h you want to recompile lib.c, don't you? Checking

Yes, of course.

> timestamps is what make is good at (and there for), so I don't
> understand your concern. And conditionally updating a target to keep the
> old file if no update is needed is a usual approach.

As I said, you need to use order only prerequisites to do it properly.
Otherwise it is kind of conflicting view version.h is updated or not.

================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] build: only generate version.h when needed and remove it in clean target
Date: Sat, 04 Nov 2017 16:54:36 +0000
Message-ID: <20171104165434.gg4e7fhu6rjfqe5s () ltop ! local>
--------------------
On Thu, Sep 14, 2017 at 08:45:40PM +0200, Uwe Kleine-König wrote:
> This way version.h isn't generated when running $(make clean) but only
> when lib.c is about to be compiled.

Hi,

I would like to use in my development tree the following slightly updated version.
Would you mind to give your SoB?

Regards,
-- Luc Van Oostenryck


================================================================================


################################################################################

=== Thread: [PATCH] build: remove version.h in clean target ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH] build: remove version.h in clean target
Date: Wed, 20 Sep 2017 15:08:14 +0000
Message-ID: <20170920150814.19794-1-uwe () kleine-koenig ! org>
--------------------
Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
Hello,

I think this is the inarguable part and that alone is still a
considerable improvement for me.

Best regards
Uwe

 Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index a4653aa1b747..d0341764158e 100644
--- a/Makefile
+++ b/Makefile
@@ -223,7 +223,7 @@ selfcheck: $(ALL_OBJS:.o=.sc)
 
 
 clean: clean-check
-	rm -f *.[oa] .*.d *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc
+	rm -f *.[oa] .*.d *.so $(PROGRAMS) $(SLIB_FILE) pre-process.h sparse.pc version.h
 
 dist:
 	@if test "$(SPARSE_VERSION)" != "v$(VERSION)" ; then \
-- 
2.14.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] cgcc: fix __DECIMAL_DIG__ ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] cgcc: fix __DECIMAL_DIG__
Date: Mon, 29 May 2017 00:41:53 +0000
Message-ID: <20170529004153.3951-1-luc.vanoostenryck () gmail ! com>
--------------------
There seems to be a mixup about how to calculate __DECIMAL_DIG__
especially for PPC.

Fix it by using the correct values: 21 for 80 bit long double (i386)
and 36 for 128 bits long double (all the others).

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 cgcc | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/cgcc b/cgcc
index c29fa587e..456369655 100755
--- a/cgcc
+++ b/cgcc
@@ -258,25 +258,25 @@ sub add_specs {
     } elsif ($spec eq 'sparc') {
 	return (' -D__sparc=1 -D__sparc__=1' .
 		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
-		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
+		&float_types (1, 1, 36, [24,8], [53,11], [113,15]) .
 		&define_size_t ($m64 ? "long unsigned int" : "unsigned int") .
 		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
     } elsif ($spec eq 'sparc64') {
 	return (' -D__sparc=1 -D__sparc__=1 -D__sparcv9__=1 -D__sparc64__=1 -D__arch64__=1 -D__LP64__=1' .
 		&integer_types (8, 16, 32, 64, 64, 128) .
-		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
+		&float_types (1, 1, 36, [24,8], [53,11], [113,15]) .
 		&define_size_t ("long unsigned int") .
 		' -D__SIZEOF_POINTER__=8');
     } elsif ($spec eq 'x86_64') {
 	return (' -D__x86_64=1 -D__x86_64__=1' . ($m32 ? '' : ' -D__LP64__=1') .
 		&integer_types (8, 16, 32, $m32 ? 32 : 64, 64, 128) .
-		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
+		&float_types (1, 1, 36, [24,8], [53,11], [113,15]) .
 		&define_size_t ($m32 ? "unsigned int" : "long unsigned int") .
 		' -D__SIZEOF_POINTER__=' . ($m32 ? '4' : '8'));
     } elsif ($spec eq 'ppc') {
 	return (' -D__powerpc__=1 -D_BIG_ENDIAN -D_STRING_ARCH_unaligned=1' .
 		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
-		&float_types (1, 1, 21, [24,8], [53,11], [113,15]) .
+		&float_types (1, 1, 36, [24,8], [53,11], [113,15]) .
 		&define_size_t ($m64 ? "long unsigned int" : "unsigned int") .
 		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
     } elsif ($spec eq 's390x') {
-- 
2.13.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] cgcc: provide __ARM_PCS_VFP for armhf ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH] cgcc: provide __ARM_PCS_VFP for armhf
Date: Tue, 26 Sep 2017 07:15:20 +0000
Message-ID: <20170926071520.26507-1-uwe () kleine-koenig ! org>
--------------------
This fixes:

	$ uname -m
	armv8l
	$ env CHECK=./sparse ./cgcc -no-compile memops.c
	/usr/include/arm-linux-gnueabihf/gnu/stubs.h:7:12: error: unable to open 'gnu/stubs-soft.h'

Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
Hello,

I added

	env CHECK=./sparse ./cgcc -no-compile memops.c

to the package building process and that failed on armhf (i.e.  Armv7
CPU with Thumb-2 and VFP3D16 or better) with the above error.

With that applied all Debian primary architectures work fine; see
https://buildd.debian.org/status/package.php?p=sparse&suite=unstable

Best regards
Uwe

 cgcc | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/cgcc b/cgcc
index a8d7b4f..ee59201 100755
--- a/cgcc
+++ b/cgcc
@@ -296,7 +296,14 @@ sub add_specs {
 		&define_size_t ("long unsigned int") .
 		' -D__SIZEOF_POINTER__=' . ($m64 ? '8' : '4'));
     } elsif ($spec eq 'arm') {
-	return (' -D__arm__=1 -m32' .
+	chomp (my $gccmachine = `$cc -dumpmachine`);
+	my $cppsymbols = ' -D__arm__=1 -m32';
+
+	if ($gccmachine eq 'arm-linux-gnueabihf') {
+	    $cppsymbols .= ' -D__ARM_PCS_VFP=1';
+	}
+
+	return ($cppsymbols .
 		&float_types (1, 1, 36, [24,8], [53,11], [53, 11]));
     } elsif ($spec eq 'aarch64') {
 	return (' -D__aarch64__=1 -m64' .
@@ -324,7 +331,7 @@ sub add_specs {
 	    return &add_specs ('s390x');
 	} elsif ($arch =~ /^(sparc64)$/i) {
 	    return &add_specs ('sparc64');
-	} elsif ($arch =~ /^(arm)$/i) {
+	} elsif ($arch =~ /^arm(?:v[78]l)?$/i) {
 	    return &add_specs ('arm');
 	} elsif ($arch =~ /^(aarch64)$/i) {
 	    return &add_specs ('aarch64');
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] cgcc: provide __ARM_PCS_VFP for armhf
Date: Tue, 26 Sep 2017 20:35:20 +0000
Message-ID: <20170926203518.3m3b2e4aeejkidq4 () ltop ! local>
--------------------
On Tue, Sep 26, 2017 at 09:15:20AM +0200, Uwe Kleine-König wrote:
> This fixes:
> 
> 	$ uname -m
> 	armv8l
> 	$ env CHECK=./sparse ./cgcc -no-compile memops.c
> 	/usr/include/arm-linux-gnueabihf/gnu/stubs.h:7:12: error: unable to open 'gnu/stubs-soft.h'
> 
...
> 
> With that applied all Debian primary architectures work fine; see
> https://buildd.debian.org/status/package.php?p=sparse&suite=unstable

Nice!
 
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] compile-i386: Use SPARSE_VERSION instead of __DATE__ ===

From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: [PATCH] compile-i386: Use SPARSE_VERSION instead of __DATE__
Date: Fri, 22 Sep 2017 08:14:10 +0000
Message-ID: <20170922081410.29162-1-uwe () kleine-koenig ! org>
--------------------
The compile date isn't very informative for a tool, the version is what really
matters. Additionally using __DATE__ makes the build unreprodicible.

Signed-off-by: Uwe Kleine-KÃ¶nig <uwe@kleine-koenig.org>
---
 compile-i386.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/compile-i386.c b/compile-i386.c
index e4d3f27dd8a9..1cedcbda73d8 100644
--- a/compile-i386.c
+++ b/compile-i386.c
@@ -57,6 +57,7 @@
 #include "target.h"
 #include "compile.h"
 #include "bitmap.h"
+#include "version.h"
 
 struct textbuf {
 	unsigned int	len;	/* does NOT include terminating null */
@@ -691,7 +692,7 @@ void emit_unit_begin(const char *basename)
 void emit_unit_end(void)
 {
 	textbuf_emit(&unit_post_text);
-	printf("\t.ident\t\"sparse silly x86 backend (built %s)\"\n", __DATE__);
+	printf("\t.ident\t\"sparse silly x86 backend (version %s)\"\n", SPARSE_VERSION);
 }
 
 /* conditionally switch sections */
-- 
2.14.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] compile-i386: Use SPARSE_VERSION instead of __DATE__
Date: Mon, 02 Oct 2017 19:47:20 +0000
Message-ID: <20171002194717.hfgwkgrzcf2nuefo () ltop ! local>
--------------------
On Fri, Sep 22, 2017 at 10:14:10AM +0200, Uwe Kleine-König wrote:
> The compile date isn't very informative for a tool, the version is what really
> matters. Additionally using __DATE__ makes the build unreprodicible.
> 

Acked-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix 'simplification' of float-to-int casts ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix 'simplification' of float-to-int casts
Date: Wed, 12 Apr 2017 13:21:47 +0000
Message-ID: <20170412132147.46876-1-luc.vanoostenryck () gmail ! com>
--------------------
Currently, simplify_cast() don't really take floating-points
in account and happily simplify away a float-to-int cast
if both types have the same size.

Fix this by not touching such casts.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
This patch is available at:
	git://github.com/lucvoo/sparse.git fix-f2i-casts
based on commit:
	d440a16358aefd718029963bb2261f1deccfddab (fpops)
up to commit:
	604e7ef9c37100c4ca3dc0b3bee00d114e265684

 simplify.c              |  4 ++++
 validation/cast-kinds.c | 12 ++++++++----
 validation/fp2i-cast.c  | 30 ++++++++++++++++++++++++++++++
 3 files changed, 42 insertions(+), 4 deletions(-)
 create mode 100644 validation/fp2i-cast.c

diff --git a/simplify.c b/simplify.c
index 2286440e0..256a68b22 100644
--- a/simplify.c
+++ b/simplify.c
@@ -900,6 +900,10 @@ static int simplify_cast(struct instruction *insn)
 	if (is_ptr_type(orig_type) || is_ptr_type(insn->type))
 		return 0;
 
+	/* Keep float-to-int casts */
+	if (is_float_type(orig_type) && !is_float_type(insn->type))
+		return 0;
+
 	orig_size = orig_type->bit_size;
 	size = insn->size;
 	src = insn->src;
diff --git a/validation/cast-kinds.c b/validation/cast-kinds.c
index 697f9735e..e686c01ea 100644
--- a/validation/cast-kinds.c
+++ b/validation/cast-kinds.c
@@ -92,7 +92,8 @@ iptr_2_int:
 float_2_int:
 .L10:
 	<entry-point>
-	ret.32      %arg1
+	cast.32     %r17 <- (32) %arg1
+	ret.32      %r17
 
 
 double_2_int:
@@ -139,7 +140,8 @@ iptr_2_uint:
 float_2_uint:
 .L24:
 	<entry-point>
-	ret.32      %arg1
+	cast.32     %r38 <- (32) %arg1
+	ret.32      %r38
 
 
 double_2_uint:
@@ -193,7 +195,8 @@ float_2_long:
 double_2_long:
 .L40:
 	<entry-point>
-	ret.64      %arg1
+	cast.64     %r62 <- (64) %arg1
+	ret.64      %r62
 
 
 int_2_ulong:
@@ -240,7 +243,8 @@ float_2_ulong:
 double_2_ulong:
 .L54:
 	<entry-point>
-	ret.64      %arg1
+	cast.64     %r83 <- (64) %arg1
+	ret.64      %r83
 
 
 int_2_vptr:
diff --git a/validation/fp2i-cast.c b/validation/fp2i-cast.c
new file mode 100644
index 000000000..08f8c9252
--- /dev/null
+++ b/validation/fp2i-cast.c
@@ -0,0 +1,30 @@
+#if __SIZEOF_INT__ == __SIZEOF_FLOAT__
+typedef   signed int si;
+typedef unsigned int ui;
+#else
+#error "no float-sized integer type"
+#endif
+
+#if __SIZEOF_LONG_LONG__ == __SIZEOF_DOUBLE__
+typedef   signed long long sl;
+typedef unsigned long long ul;
+#else
+#error "no double-sized integer type"
+#endif
+
+si f2si(float  a) { return a; }
+ui f2ui(float  a) { return a; }
+sl f2sl(float  a) { return a; }
+ul f2ul(float  a) { return a; }
+si d2si(double a) { return a; }
+ui d2ui(double a) { return a; }
+sl d2sl(double a) { return a; }
+ul d2ul(double a) { return a; }
+
+/*
+ * check-name: fp2i cast
+ * check-command: test-linearize -Wno-decl $file
+ *
+ * check-output-ignore
+ * check-output-pattern-8-times: cast\\.
+ */
-- 
2.12.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix cast's target type info ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix cast's target type info
Date: Fri, 13 Jan 2017 17:23:59 +0000
Message-ID: <20170113172359.23297-1-luc.vanoostenryck () gmail ! com>
--------------------
commit a0962f7893 ("Fix cast instruction generation") correctly
used the source type instead of the destination type to decide
between OP_CAST & OP_SCAST but at the same time made the choice
between OP_PTRCAST & OP_FPCAST depends on the source's type too,
thus losing all information about the target type (but its size).
In other words, in the code here below:
	int i ;
	...
	(long) i;
	(void*) i;
	(double) i;
	(float) i;
the three first casts generate exactly the same code (for a LP64 arch):
	scast.64   %r.. <- (32) %r..
and the last one will not generate any code at all.

Fix this by using the source type only to determine if the cast is an
OP_CAST or an OP_SCAST but using the target type to determine if the
cast is a cast to a pointer type (OP_PTRCAST), a floating-point type
(OP_FPCAST) or an integer type (OP_CAST or OP_SCAST).

Note: this is still not correct for floating-point to integer cast
as it is needed to know if the destination is a signed or unsigned
integer type.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 linearize.c             |   4 +-
 validation/cast-kinds.c | 387 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 389 insertions(+), 2 deletions(-)
 create mode 100644 validation/cast-kinds.c

diff --git a/linearize.c b/linearize.c
index cb252282..a50699d1 100644
--- a/linearize.c
+++ b/linearize.c
@@ -1104,9 +1104,9 @@ static pseudo_t linearize_postop(struct entrypoint *ep, struct expression *expr)
 static struct instruction *alloc_cast_instruction(struct symbol *src, struct symbol *ctype)
 {
 	int opcode = OP_CAST;
-	struct symbol *base = src;
+	struct symbol *base = ctype;
 
-	if (base->ctype.modifiers & MOD_SIGNED)
+	if (src->ctype.modifiers & MOD_SIGNED)
 		opcode = OP_SCAST;
 	if (base->type == SYM_NODE)
 		base = base->ctype.base_type;
diff --git a/validation/cast-kinds.c b/validation/cast-kinds.c
new file mode 100644
index 00000000..697f9735
--- /dev/null
+++ b/validation/cast-kinds.c
@@ -0,0 +1,387 @@
+typedef unsigned int uint;
+typedef unsigned long ulong;
+
+static int uint_2_int(uint a) { return (int)a; }
+static int long_2_int(long a) { return (int)a; }
+static int ulong_2_int(ulong a) { return (int)a; }
+static int vptr_2_int(void *a) { return (int)a; }
+static int iptr_2_int(int *a) { return (int)a; }
+static int float_2_int(float a) { return (int)a; }
+static int double_2_int(double a) { return (int)a; }
+static uint int_2_uint(int a) { return (uint)a; }
+static uint long_2_uint(long a) { return (uint)a; }
+static uint ulong_2_uint(ulong a) { return (uint)a; }
+static uint vptr_2_uint(void *a) { return (uint)a; }
+static uint iptr_2_uint(int *a) { return (uint)a; }
+static uint float_2_uint(float a) { return (uint)a; }
+static uint double_2_uint(double a) { return (uint)a; }
+static long int_2_long(int a) { return (long)a; }
+static long uint_2_long(uint a) { return (long)a; }
+static long ulong_2_long(ulong a) { return (long)a; }
+static long vptr_2_long(void *a) { return (long)a; }
+static long iptr_2_long(int *a) { return (long)a; }
+static long float_2_long(float a) { return (long)a; }
+static long double_2_long(double a) { return (long)a; }
+static ulong int_2_ulong(int a) { return (ulong)a; }
+static ulong uint_2_ulong(uint a) { return (ulong)a; }
+static ulong long_2_ulong(long a) { return (ulong)a; }
+static ulong vptr_2_ulong(void *a) { return (ulong)a; }
+static ulong iptr_2_ulong(int *a) { return (ulong)a; }
+static ulong float_2_ulong(float a) { return (ulong)a; }
+static ulong double_2_ulong(double a) { return (ulong)a; }
+static void * int_2_vptr(int a) { return (void *)a; }
+static void * uint_2_vptr(uint a) { return (void *)a; }
+static void * long_2_vptr(long a) { return (void *)a; }
+static void * ulong_2_vptr(ulong a) { return (void *)a; }
+static void * iptr_2_vptr(int *a) { return (void *)a; }
+static int * int_2_iptr(int a) { return (int *)a; }
+static int * uint_2_iptr(uint a) { return (int *)a; }
+static int * long_2_iptr(long a) { return (int *)a; }
+static int * ulong_2_iptr(ulong a) { return (int *)a; }
+static int * vptr_2_iptr(void *a) { return (int *)a; }
+static float int_2_float(int a) { return (float)a; }
+static float uint_2_float(uint a) { return (float)a; }
+static float long_2_float(long a) { return (float)a; }
+static float ulong_2_float(ulong a) { return (float)a; }
+static float double_2_float(double a) { return (float)a; }
+static double int_2_double(int a) { return (double)a; }
+static double uint_2_double(uint a) { return (double)a; }
+static double long_2_double(long a) { return (double)a; }
+static double ulong_2_double(ulong a) { return (double)a; }
+static double float_2_double(float a) { return (double)a; }
+
+/*
+ * check-name: cast-kinds
+ * check-command: test-linearize -m64 $file
+ *
+ * check-output-start
+uint_2_int:
+.L0:
+	<entry-point>
+	ret.32      %arg1
+
+
+long_2_int:
+.L2:
+	<entry-point>
+	scast.32    %r5 <- (64) %arg1
+	ret.32      %r5
+
+
+ulong_2_int:
+.L4:
+	<entry-point>
+	cast.32     %r8 <- (64) %arg1
+	ret.32      %r8
+
+
+vptr_2_int:
+.L6:
+	<entry-point>
+	cast.32     %r11 <- (64) %arg1
+	ret.32      %r11
+
+
+iptr_2_int:
+.L8:
+	<entry-point>
+	cast.32     %r14 <- (64) %arg1
+	ret.32      %r14
+
+
+float_2_int:
+.L10:
+	<entry-point>
+	ret.32      %arg1
+
+
+double_2_int:
+.L12:
+	<entry-point>
+	cast.32     %r20 <- (64) %arg1
+	ret.32      %r20
+
+
+int_2_uint:
+.L14:
+	<entry-point>
+	ret.32      %arg1
+
+
+long_2_uint:
+.L16:
+	<entry-point>
+	scast.32    %r26 <- (64) %arg1
+	ret.32      %r26
+
+
+ulong_2_uint:
+.L18:
+	<entry-point>
+	cast.32     %r29 <- (64) %arg1
+	ret.32      %r29
+
+
+vptr_2_uint:
+.L20:
+	<entry-point>
+	cast.32     %r32 <- (64) %arg1
+	ret.32      %r32
+
+
+iptr_2_uint:
+.L22:
+	<entry-point>
+	cast.32     %r35 <- (64) %arg1
+	ret.32      %r35
+
+
+float_2_uint:
+.L24:
+	<entry-point>
+	ret.32      %arg1
+
+
+double_2_uint:
+.L26:
+	<entry-point>
+	cast.32     %r41 <- (64) %arg1
+	ret.32      %r41
+
+
+int_2_long:
+.L28:
+	<entry-point>
+	scast.64    %r44 <- (32) %arg1
+	ret.64      %r44
+
+
+uint_2_long:
+.L30:
+	<entry-point>
+	cast.64     %r47 <- (32) %arg1
+	ret.64      %r47
+
+
+ulong_2_long:
+.L32:
+	<entry-point>
+	ret.64      %arg1
+
+
+vptr_2_long:
+.L34:
+	<entry-point>
+	cast.64     %r53 <- (64) %arg1
+	ret.64      %r53
+
+
+iptr_2_long:
+.L36:
+	<entry-point>
+	cast.64     %r56 <- (64) %arg1
+	ret.64      %r56
+
+
+float_2_long:
+.L38:
+	<entry-point>
+	cast.64     %r59 <- (32) %arg1
+	ret.64      %r59
+
+
+double_2_long:
+.L40:
+	<entry-point>
+	ret.64      %arg1
+
+
+int_2_ulong:
+.L42:
+	<entry-point>
+	scast.64    %r65 <- (32) %arg1
+	ret.64      %r65
+
+
+uint_2_ulong:
+.L44:
+	<entry-point>
+	cast.64     %r68 <- (32) %arg1
+	ret.64      %r68
+
+
+long_2_ulong:
+.L46:
+	<entry-point>
+	ret.64      %arg1
+
+
+vptr_2_ulong:
+.L48:
+	<entry-point>
+	cast.64     %r74 <- (64) %arg1
+	ret.64      %r74
+
+
+iptr_2_ulong:
+.L50:
+	<entry-point>
+	cast.64     %r77 <- (64) %arg1
+	ret.64      %r77
+
+
+float_2_ulong:
+.L52:
+	<entry-point>
+	cast.64     %r80 <- (32) %arg1
+	ret.64      %r80
+
+
+double_2_ulong:
+.L54:
+	<entry-point>
+	ret.64      %arg1
+
+
+int_2_vptr:
+.L56:
+	<entry-point>
+	scast.64    %r86 <- (32) %arg1
+	ret.64      %r86
+
+
+uint_2_vptr:
+.L58:
+	<entry-point>
+	cast.64     %r89 <- (32) %arg1
+	ret.64      %r89
+
+
+long_2_vptr:
+.L60:
+	<entry-point>
+	scast.64    %r92 <- (64) %arg1
+	ret.64      %r92
+
+
+ulong_2_vptr:
+.L62:
+	<entry-point>
+	cast.64     %r95 <- (64) %arg1
+	ret.64      %r95
+
+
+iptr_2_vptr:
+.L64:
+	<entry-point>
+	cast.64     %r98 <- (64) %arg1
+	ret.64      %r98
+
+
+int_2_iptr:
+.L66:
+	<entry-point>
+	ptrcast.64  %r101 <- (32) %arg1
+	ret.64      %r101
+
+
+uint_2_iptr:
+.L68:
+	<entry-point>
+	ptrcast.64  %r104 <- (32) %arg1
+	ret.64      %r104
+
+
+long_2_iptr:
+.L70:
+	<entry-point>
+	ptrcast.64  %r107 <- (64) %arg1
+	ret.64      %r107
+
+
+ulong_2_iptr:
+.L72:
+	<entry-point>
+	ptrcast.64  %r110 <- (64) %arg1
+	ret.64      %r110
+
+
+vptr_2_iptr:
+.L74:
+	<entry-point>
+	ptrcast.64  %r113 <- (64) %arg1
+	ret.64      %r113
+
+
+int_2_float:
+.L76:
+	<entry-point>
+	fpcast.32   %r116 <- (32) %arg1
+	ret.32      %r116
+
+
+uint_2_float:
+.L78:
+	<entry-point>
+	fpcast.32   %r119 <- (32) %arg1
+	ret.32      %r119
+
+
+long_2_float:
+.L80:
+	<entry-point>
+	fpcast.32   %r122 <- (64) %arg1
+	ret.32      %r122
+
+
+ulong_2_float:
+.L82:
+	<entry-point>
+	fpcast.32   %r125 <- (64) %arg1
+	ret.32      %r125
+
+
+double_2_float:
+.L84:
+	<entry-point>
+	fpcast.32   %r128 <- (64) %arg1
+	ret.32      %r128
+
+
+int_2_double:
+.L86:
+	<entry-point>
+	fpcast.64   %r131 <- (32) %arg1
+	ret.64      %r131
+
+
+uint_2_double:
+.L88:
+	<entry-point>
+	fpcast.64   %r134 <- (32) %arg1
+	ret.64      %r134
+
+
+long_2_double:
+.L90:
+	<entry-point>
+	fpcast.64   %r137 <- (64) %arg1
+	ret.64      %r137
+
+
+ulong_2_double:
+.L92:
+	<entry-point>
+	fpcast.64   %r140 <- (64) %arg1
+	ret.64      %r140
+
+
+float_2_double:
+.L94:
+	<entry-point>
+	fpcast.64   %r143 <- (32) %arg1
+	ret.64      %r143
+
+
+ * check-output-end
+ */
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix cgcc ELF version for ppc64/pcc64le ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix cgcc ELF version for ppc64/pcc64le
Date: Wed, 27 Sep 2017 21:11:37 +0000
Message-ID: <20170927211137.16461-1-luc.vanoostenryck () gmail ! com>
--------------------
Commit e0306fe0 "cgcc: teach cgcc about ppc64[le]" add support
for PPC64 to cgcc by adding the needed options like '-m64' &
'-m{little,big}-endian' and defines likes '-D__PPC64__=1'.

In this commit the defined '-D_CALL_ELF=2' was also added
but the value of 2 is for ELF v2 ABI, normally used for ppc64le,
while the older ELF ABI, normally used for plain ppc64 should use
'-D_CALL_ELF=2'.

Fix this by using the value of 1 or 2 for '_CALL_ELF' depending
if the architecture is ppc64 or ppc64le.

Fixes: e0306fe0b725af6e2e7ff59d7f0d99c96315791a
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 cgcc | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/cgcc b/cgcc
index a8d7b4f21..909cd2477 100755
--- a/cgcc
+++ b/cgcc
@@ -286,7 +286,6 @@ sub add_specs {
     } elsif ($spec eq 'ppc64') {
 	return (' -D__powerpc__=1 -D__PPC__=1 -D_STRING_ARCH_unaligned=1' .
 		' -D__powerpc64__=1 -D__PPC64__=1' .
-		' -D_CALL_ELF=2' .
 		' -m64' .
 		&float_types (1, 1, 21, [24,8], [53,11], [113,15]));
     } elsif ($spec eq 's390x') {
@@ -317,9 +316,9 @@ sub add_specs {
 	} elsif ($arch =~ /^(ppc)$/i) {
 	    return &add_specs ('ppc');
 	} elsif ($arch =~ /^(ppc64)$/i) {
-	    return &add_specs ('ppc64') . ' -mbig-endian';
+	    return &add_specs ('ppc64') . ' -mbig-endian -D_CALL_ELF=1';
 	} elsif ($arch =~ /^(ppc64le)$/i) {
-	    return &add_specs ('ppc64') . ' -mlittle-endian';
+	    return &add_specs ('ppc64') . ' -mlittle-endian -D_CALL_ELF=2';
 	} elsif ($arch =~ /^(s390x)$/i) {
 	    return &add_specs ('s390x');
 	} elsif ($arch =~ /^(sparc64)$/i) {
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Uwe =?iso-8859-1?Q?Kleine-K=F6nig?= <uwe () kleine-koenig ! org>
To: linux-sparse
Subject: Re: [PATCH] fix cgcc ELF version for ppc64/pcc64le
Date: Sat, 30 Sep 2017 08:49:13 +0000
Message-ID: <20170930084913.raksvxhqlceh6qgs () taurus ! defre ! kleine-koenig ! org>
--------------------

--3nb7obr4ooyru2vn
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

Hello Luc,

On Wed, Sep 27, 2017 at 11:11:37PM +0200, Luc Van Oostenryck wrote:
> Commit e0306fe0 "cgcc: teach cgcc about ppc64[le]" add support
> for PPC64 to cgcc by adding the needed options like '-m64' &
> '-m{little,big}-endian' and defines likes '-D__PPC64__=3D1'.
>=20
> In this commit the defined '-D_CALL_ELF=3D2' was also added
> but the value of 2 is for ELF v2 ABI, normally used for ppc64le,
> while the older ELF ABI, normally used for plain ppc64 should use
> '-D_CALL_ELF=3D2'.
>=20
> Fix this by using the value of 1 or 2 for '_CALL_ELF' depending
> if the architecture is ppc64 or ppc64le.
>=20
> Fixes: e0306fe0b725af6e2e7ff59d7f0d99c96315791a
> Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

I tested that patch on the following machines:

hostname/chroot                 uname -m        gcc -dumpmachine
partch/sid                      ppc             powerpc-linux-gnu
pizzetti/sid_ppc64-dchroot      ppc64           powerpc64-linux-gnu
plummer/sid_ppc64el-dchroot     ppc64le         powerpc64le-linux-gnu

and my test case (env CHECK=3D./sparse ./cgcc -no-compile memops.c) works
on all of them now.

Tested-by: Uwe Kleine-K=F6nig <uwe@kleine-koenig.org>

Thanks
Uwe

--3nb7obr4ooyru2vn
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQEzBAABCgAdFiEEfnIqFpAYrP8+dKQLwfwUeK3K7AkFAlnPWoUACgkQwfwUeK3K
7AkRzgf9HyGKomI7ypXFN/ucoWhuUImga/NESn+pOPTntgzzIx7MI+orTR06u5ea
QM8uQg9wd7b8QTRlCDooTiIcEXFS+GBLH39AZwrYiq4MR4suLyQwy37LZ9kFRElV
lefUavoHpQtBmMKvpBRpJFMO+UfD48rPnjLwt+dq+07OlnU1KMrqdMgEGBtnbSIo
tQEEnHTO92W+u1yv/6wMsPSGIB+8m4FPF3NXvGUBec2CC4OtCMdkYoNNXGWnJS4x
bKjvGfEkQz4E3fQiZdBp/U7ycq6sBe0KZjSS599w4FyxsiryUZZCuW36T9D8boiB
8hHCwqC2p/2JSxftXt710fkVSZ4IGA==
=Q5na
-----END PGP SIGNATURE-----

--3nb7obr4ooyru2vn--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] fix cgcc ELF version for ppc64/pcc64le
Date: Mon, 02 Oct 2017 19:45:07 +0000
Message-ID: <20171002194505.peltjzj5f7q6bbqr () ltop ! local>
--------------------
On Sat, Sep 30, 2017 at 10:49:13AM +0200, Uwe Kleine-König wrote:
> Hello Luc,
> 
> On Wed, Sep 27, 2017 at 11:11:37PM +0200, Luc Van Oostenryck wrote:
> > Commit e0306fe0 "cgcc: teach cgcc about ppc64[le]" add support
> > for PPC64 to cgcc by adding the needed options like '-m64' &
> > '-m{little,big}-endian' and defines likes '-D__PPC64__=1'.
> > 
> > In this commit the defined '-D_CALL_ELF=2' was also added
> > but the value of 2 is for ELF v2 ABI, normally used for ppc64le,
> > while the older ELF ABI, normally used for plain ppc64 should use
> > '-D_CALL_ELF=2'.
> > 
> > Fix this by using the value of 1 or 2 for '_CALL_ELF' depending
> > if the architecture is ppc64 or ppc64le.
> > 
> > Fixes: e0306fe0b725af6e2e7ff59d7f0d99c96315791a
> > Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> 
> I tested that patch on the following machines:
> 
> hostname/chroot                 uname -m        gcc -dumpmachine
> partch/sid                      ppc             powerpc-linux-gnu
> pizzetti/sid_ppc64-dchroot      ppc64           powerpc64-linux-gnu
> plummer/sid_ppc64el-dchroot     ppc64le         powerpc64le-linux-gnu
> 
> and my test case (env CHECK=./sparse ./cgcc -no-compile memops.c) works
> on all of them now.
> 
> Tested-by: Uwe Kleine-König <uwe@kleine-koenig.org>
> 
> Thanks
> Uwe

Many thanks for the testing.


@ Chris,

Can you take the patch as is or do you prefer that I send a pull request?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] fix cgcc ELF version for ppc64/pcc64le
Date: Tue, 03 Oct 2017 04:46:44 +0000
Message-ID: <CANeU7QkHASgSkVuKT0yj6MD_g+KoXDGj5XWY1pw=0vwhYAriBg () mail ! gmail ! com>
--------------------
On Wed, Sep 27, 2017 at 5:11 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Commit e0306fe0 "cgcc: teach cgcc about ppc64[le]" add support
> for PPC64 to cgcc by adding the needed options like '-m64' &
> '-m{little,big}-endian' and defines likes '-D__PPC64__=1'.
>
> In this commit the defined '-D_CALL_ELF=2' was also added
> but the value of 2 is for ELF v2 ABI, normally used for ppc64le,
> while the older ELF ABI, normally used for plain ppc64 should use
> '-D_CALL_ELF=2'.
>
> Fix this by using the value of 1 or 2 for '_CALL_ELF' depending
> if the architecture is ppc64 or ppc64le.

Applied on master.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix crash while testing between conditional & unconditional OP_BR ===

From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
To: Unknown
Subject: [PATCH] fix crash while testing between conditional & unconditional OP_BR
Date: Fri, 27 Jan 2017 11:03:32 +0100
Message-ID: 
--------------------
It seems that testing for a NULL insn->cond is not the right test,
what must be done is to test if either of ->bb_{true,false} is NULL.

Fixes: 556dbc8d75 ("Update usage chain for dead instructions")
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/simplify.c b/simplify.c
index b5cd0ea77..3dea03b5e 100644
--- a/simplify.c
+++ b/simplify.c
@@ -221,7 +221,7 @@ void kill_instruction(struct instruction *insn)
 	case OP_BR:
 		insn->bb = NULL;
 		repeat_phase |= REPEAT_CSE;
-		if (insn->cond)
+		if (insn->bb_true && insn->bb_false)
 			kill_use(&insn->cond);
 		return;
 	}
-- 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix crash while testing between conditional & unconditional OP_BR
Date: Fri, 27 Jan 2017 11:38:18 +0000
Message-ID: <20170127113817.6p2274s44jis66og () macpro ! local>
--------------------
While testing the newly updated sparse-next I saw that a patch of mine
(3eadf3e6a "kill uses of replaced instructions") triggered an old
hidden bug.

To preserve bissectability the following patch should be applied
somewhere before the triggering one (but it will produce a small
conflict later with (dae3a1022 "cleanup kill_instruction()")
where the offending if-statement will need to be inversed.



================================================================================


################################################################################

=== Thread: [PATCH] fix expansion cost of pure functions ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] fix expansion cost of pure functions
Date: Thu, 23 Feb 2017 09:56:39 +0000
Message-ID: <CANeU7Q=6ikz206rW-EhQ2cB2i3+n1wopk=E0kLBnRdOdCYKvkg () mail ! gmail ! com>
--------------------
On Thu, Feb 23, 2017 at 9:01 AM, Linus Torvalds
<torvalds@linux-foundation.org> wrote:
> No, I think the zero is just a bug, introduced in commit 8376ab091a
> ("sparse: Fix __builtin_safe_p for pure and const functions").
>
> I might be missing something, but I think Luc's patch is fine.

Thanks for the insight. I will apply it.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix implicit size of unsized arrays ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix implicit size of unsized arrays
Date: Thu, 28 Dec 2017 15:07:47 +0000
Message-ID: <20171228150747.77209-1-luc.vanoostenryck () gmail ! com>
--------------------
When an array is declared without an explicit size. In this case,
an implicit size is given by the number of elements in its initializer
if one is present.

Currently, in sparse, this implicit size is only associated with
the node corresponding to the initializer while the base type is
left unsized. This is a problem because the node is only used for
the modifiers & address-space and the bitsize of nodes are expected
to match the size of the basetype. So this implicit size can be used
for when directly using the bit_size of the node but the array is
still left, essentially unsized.

It's not enough to simply copy the bitsize of the node to the base
type because:
1) sym->array_size need to be set in the node & the base type.
2) the base type can be shared between several declarators.
It's thus needed to copy the the base type to unshare it before
setting the sym->array_size.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---

This patch is available in the Git repository at:
  git://github.com/lucvoo/sparse-dev.git size-unsized-arrays

 symbol.c                         | 19 ++++++++++++++++++-
 validation/array-implicit-size.c | 26 ++++++++++++++++++++++++++
 validation/constexpr-preop.c     |  2 ++
 3 files changed, 46 insertions(+), 1 deletion(-)
 create mode 100644 validation/array-implicit-size.c

diff --git a/symbol.c b/symbol.c
index 2f4afd515..61d1acbea 100644
--- a/symbol.c
+++ b/symbol.c
@@ -364,6 +364,23 @@ static struct expression *get_symbol_initializer(struct symbol *sym)
 	return NULL;
 }
 
+static unsigned int implicit_array_size(struct symbol *node, unsigned int count)
+{
+	struct symbol *arr_ori = node->ctype.base_type;
+	struct symbol *arr_new = alloc_symbol(node->pos, SYM_ARRAY);
+	struct symbol *elem_type = arr_ori->ctype.base_type;
+	struct expression *size = alloc_const_expression(node->pos, count);
+	unsigned int bit_size = array_element_offset(elem_type->bit_size, count);
+
+	*arr_new = *arr_ori;
+	arr_new->bit_size = bit_size;
+	arr_new->array_size = size;
+	node->array_size = size;
+	node->ctype.base_type = arr_new;
+
+	return bit_size;
+}
+
 static struct symbol * examine_node_type(struct symbol *sym)
 {
 	struct symbol *base_type = examine_base_type(sym);
@@ -393,7 +410,7 @@ static struct symbol * examine_node_type(struct symbol *sym)
 			int count = count_array_initializer(node_type, initializer);
 
 			if (node_type && node_type->bit_size >= 0)
-				bit_size = array_element_offset(node_type->bit_size, count);
+				bit_size = implicit_array_size(sym, count);
 		}
 	}
 	
diff --git a/validation/array-implicit-size.c b/validation/array-implicit-size.c
new file mode 100644
index 000000000..7011008b6
--- /dev/null
+++ b/validation/array-implicit-size.c
@@ -0,0 +1,26 @@
+static int array[] = { 0, 1, 2, 3, };
+_Static_assert(sizeof(array) == 4 * sizeof(int), "size of array");
+
+
+typedef int table_t[];
+static table_t tbl2 = {
+	0,
+	1,
+};
+_Static_assert(sizeof(tbl2) == 2 * sizeof(int), "size of tbl2");
+
+static table_t tbl1 = {
+	0,
+};
+_Static_assert(sizeof(tbl1) == 1 * sizeof(int), "size of tbl1");
+
+static table_t tbl3 = {
+	0,
+	1,
+	2,
+};
+_Static_assert(sizeof(tbl3) == 3 * sizeof(int), "size of tbl3");
+
+/*
+ * check-name: array-implicit-size
+ */
diff --git a/validation/constexpr-preop.c b/validation/constexpr-preop.c
index 4b54defd9..3fd577459 100644
--- a/validation/constexpr-preop.c
+++ b/validation/constexpr-preop.c
@@ -25,5 +25,7 @@ constexpr-preop.c:8:4: error: bad constant expression
 constexpr-preop.c:9:4: error: bad constant expression
 constexpr-preop.c:14:4: error: bad integer constant expression
 constexpr-preop.c:15:4: error: bad integer constant expression
+constexpr-preop.c:10:4: error: index out of bounds in initializer
+constexpr-preop.c:11:4: error: index out of bounds in initializer
  * check-error-end
  */
-- 
2.15.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] fix implicit size of unsized arrays
Date: Thu, 28 Dec 2017 21:02:27 +0000
Message-ID: <CACXZuxebnX36BjVyJjSecw7Uef0PaRcgYfLCgkqYz5tLrKHLpA () mail ! gmail ! com>
--------------------
Hi Luc,

On 28 December 2017 at 15:07, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> When an array is declared without an explicit size. In this case,
> an implicit size is given by the number of elements in its initializer
> if one is present.
>
> Currently, in sparse, this implicit size is only associated with
> the node corresponding to the initializer while the base type is
> left unsized. This is a problem because the node is only used for
> the modifiers & address-space and the bitsize of nodes are expected
> to match the size of the basetype. So this implicit size can be used
> for when directly using the bit_size of the node but the array is
> still left, essentially unsized.
>

Previous thread on this issue:

https://www.spinics.net/lists/linux-sparse/msg05427.html

Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] fix implicit size of unsized arrays
Date: Thu, 28 Dec 2017 21:19:11 +0000
Message-ID: <20171228211911.4mkylgyk44ymtyna () ltop ! local>
--------------------
On Thu, Dec 28, 2017 at 09:02:27PM +0000, Dibyendu Majumdar wrote:
> Hi Luc,
> 
> Previous thread on this issue:
> 
> https://www.spinics.net/lists/linux-sparse/msg05427.html

Ah yes, sorry, I forgot you already specifically reported this one.
 
It should be fixed now.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] fix implicit size of unsized arrays
Date: Thu, 28 Dec 2017 21:20:41 +0000
Message-ID: <CACXZuxdphqLErKYwxwK=EDuNGO=r2UMttOLRQ7RxhS=pWMYVNw () mail ! gmail ! com>
--------------------
Hi Luc,

On 28 December 2017 at 21:19, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Dec 28, 2017 at 09:02:27PM +0000, Dibyendu Majumdar wrote:
>> Previous thread on this issue:
>>
>> https://www.spinics.net/lists/linux-sparse/msg05427.html
>
> Ah yes, sorry, I forgot you already specifically reported this one.
>
> It should be fixed now.
>

Well last time I thought the view was that a fix was not needed? What's changed?

Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dibyendu Majumdar <mobile () majumdar ! org ! uk>
To: linux-sparse
Subject: Re: [PATCH] fix implicit size of unsized arrays
Date: Thu, 28 Dec 2017 21:44:25 +0000
Message-ID: <CACXZuxdxdAybNJr6jzj2B02TWTw3PsZbV7YjSmE1CgQ1yzSm9A () mail ! gmail ! com>
--------------------
Hi Luc,

On 28 December 2017 at 21:40, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Dec 28, 2017 at 09:20:41PM +0000, Dibyendu Majumdar wrote:
>> On 28 December 2017 at 21:19, Luc Van Oostenryck
>> <luc.vanoostenryck@gmail.com> wrote:
>> > On Thu, Dec 28, 2017 at 09:02:27PM +0000, Dibyendu Majumdar wrote:
>> >> Previous thread on this issue:
>> >>
>> >> https://www.spinics.net/lists/linux-sparse/msg05427.html
>> >
>> > Ah yes, sorry, I forgot you already specifically reported this one.
>> >
>> > It should be fixed now.
>> >
>>
>> Well last time I thought the view was that a fix was not needed? What's changed?
>
> Another case which led to a better understanding of the situation.
>

I understood that the correct solution was for the symbol to hold the size.

https://www.spinics.net/lists/linux-sparse/msg05442.html
https://www.spinics.net/lists/linux-sparse/msg05444.html


Regards
Dibyendu
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix mixup in "Handle SForced in storage_modifiers" ===

From: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
To: Unknown
Subject: [PATCH] fix mixup in "Handle SForced in storage_modifiers"
Date: Thu, 5 Jan 2017 07:31:46 +0100
Message-ID: 
--------------------
The patch used the wrong enum for the maximum size of the array.

Fixes: 1db3b627 ("Handle SForced in storage_modifiers")
Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 parse.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/parse.c b/parse.c
index b52c6abe..385e40ce 100644
--- a/parse.c
+++ b/parse.c
@@ -105,11 +105,11 @@ enum {
 };
 
 enum {
-	CInt = 0, CSInt, CUInt, CReal, CChar, CSChar, CUChar, CMax,
+	CInt = 0, CSInt, CUInt, CReal, CChar, CSChar, CUChar,
 };
 
 enum {
-	SNone = 0, STypedef, SAuto, SRegister, SExtern, SStatic, SForced
+	SNone = 0, STypedef, SAuto, SRegister, SExtern, SStatic, SForced, SMax,
 };
 
 static struct symbol_op typedef_op = {
@@ -1281,7 +1281,7 @@ static const char *storage_class[] =
 
 static unsigned long storage_modifiers(struct decl_state *ctx)
 {
-	static unsigned long mod[CMax] =
+	static unsigned long mod[SMax] =
 	{
 		[SAuto] = MOD_AUTO,
 		[SExtern] = MOD_EXTERN,
-- 
2.11.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix size of loaded bitfields ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] fix size of loaded bitfields
Date: Mon, 27 Feb 2017 09:25:46 +0000
Message-ID: <20170227092545.ymha35znxh6vzsni () macbook ! local>
--------------------
On Mon, Feb 27, 2017 at 04:32:50PM +0800, Christopher Li wrote:
> On Mon, Feb 27, 2017 at 4:22 PM, Christopher Li <sparse@chrisli.org> wrote:
> > On Fri, Feb 17, 2017 at 10:44 AM, Luc Van Oostenryck
> > <luc.vanoostenryck@gmail.com> wrote:
> >> Loading a bitfield correctly take in account the offset
> >> of the bitfield inside the whole container integer.
> >> But truncating it to the width of the bitfield is not done
> >> or is done very implicitely (because the correct size is not lost).
> >
> >> Fix this by adding the missing truncating cast.
> >> This will then gives something like:
> >>         get__bfu_a:
> >>                 cast.3      %r2 <- (32) %arg1
> >>                 cast.32     %r3 <- (3) %r2
> >>                 ret.32      %r3
> >
> > The patch looks good. Applied to sparse-next.
> 
> Actually, after apply this patch. The testsuite failed
> on matching the test case of the bitfield-size.c.

Sorry for that. I changed my mind about the cast vs. and-mask
and forgot to update the test case.
Updated patch is coming.

Luc Van Oostenryck
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix usage in simplify_seteq_setne() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] fix usage in simplify_seteq_setne()
Date: Fri, 24 Feb 2017 06:54:34 +0000
Message-ID: <20170224065434.46976-1-luc.vanoostenryck () gmail ! com>
--------------------
The usage was removed before the new operands were used
which can lead to undefined pseudos.

Fix this by moving the call to remove_usage() where
it should always have been: after the call to use_pseudo().

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 simplify.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/simplify.c b/simplify.c
index 3bc9985e8..76a599e50 100644
--- a/simplify.c
+++ b/simplify.c
@@ -432,7 +432,8 @@ static int compare_opcode(int opcode, int inverse)
 
 static int simplify_seteq_setne(struct instruction *insn, long long value)
 {
-	struct instruction *def = insn->src1->def;
+	pseudo_t old = insn->src1;
+	struct instruction *def = old->def;
 	pseudo_t src1, src2;
 	int inverse;
 	int opcode;
@@ -456,10 +457,10 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)
 		// and similar for setne/eq ... 0/1
 		src1 = def->src1;
 		src2 = def->src2;
-		remove_usage(insn->src1, &insn->src1);
 		insn->opcode = compare_opcode(opcode, inverse);
 		use_pseudo(insn, src1, &insn->src1);
 		use_pseudo(insn, src2, &insn->src2);
+		remove_usage(old, &insn->src1);
 		return REPEAT_CSE;
 
 	default:
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] fix: try_to_simplify_bb eargerness part 2 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] fix: try_to_simplify_bb eargerness part 2
Date: Sun, 30 Jul 2017 15:38:04 +0000
Message-ID: <CANeU7QkYo13a+7wJMpEFWpXKdDGm4ufkn18Nvfh14x65FSUEGw () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 7:58 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This is a temptative patch for the wine infinitive loop.

First thing first, is this patch for this RC5 release or after the release ?

I have no objection for this patch. If you want me to apply it, I am
happy to.

That being said, I am still not very comfortable with this situation
even with the patch applied. The patch is definitely an improvement, it
stop at least one bug situation. I am not able to reason this patch to make
sure that is enough.

Yes, we observe from there is a case simplify a branch with bb has
some phi cause problem.

Does all phi cause problem? Or only phi has uninitialized value cause
problem? Will adding this check enough for all possible input source code?
There is a lot of unknown we can't answer. There is not a good theory behind
it we can reason and prove it one way or the other. That is what I feel
uncomfortable about, the unknown.

This "try and error" process is very scary. The more I read on this
subject, what is the recommended best practices in the academia,
The more I realized sparse has been doing a lot of stuff relate to optimization
wrong. The phi node placement as you point out is a big one, there are others.
That is my general observation, not reason to against you patch though.
That is way beyond the scope of this patch any way.

I will apply it. My feel that it is still work in progress, not perfect yet.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] fix: try_to_simplify_bb eargerness part 2
Date: Sun, 30 Jul 2017 16:04:49 +0000
Message-ID: <CAMHZB6ECGgH4GAaMow9NN4x-NZhb5T7H44KjjUE2L9=iyWUYFA () mail ! gmail ! com>
--------------------
On Sun, Jul 30, 2017 at 5:38 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Sat, Jul 29, 2017 at 7:58 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> This is a temptative patch for the wine infinitive loop.
>
> First thing first, is this patch for this RC5 release or after the release ?

It's was draft/temptative patch for -rc5.

> I have no objection for this patch. If you want me to apply it, I am
> happy to.

Please don't, I'm still working on it.

> That being said, I am still not very comfortable with this situation
> even with the patch applied. The patch is definitely an improvement, it
> stop at least one bug situation. I am not able to reason this patch to make
> sure that is enough.

I don't like at all this situation also.
The problem is quite complex and deep.

This patch seems to solve the problem and (at least something
similar) is needed but my first analysis was also right and thus something
similar is still needed for simplify_branch_branch().

Also, the revert would not be a good solution because it would
only avoid to trigger the problem on this input but won't solve anything.

> Yes, we observe from there is a case simplify a branch with bb has
> some phi cause problem.
>
> Does all phi cause problem? Or only phi has uninitialized value cause
> problem?

The problem is unrelated to undefined *var* but these wrong branch
simplification bypass some pseudo definition which, in a way,
become undefined on some paths which then create the problem
you saw with setne %r11, %r11, 0

> Will adding this check enough for all possible input source code?
> There is a lot of unknown we can't answer. There is not a good theory behind
> it we can reason and prove it one way or the other. That is what I feel
> uncomfortable about, the unknown.

You're not alone.

> This "try and error" process is very scary.

Well, I don't see things exactly the same.
For me, there is a code base, there are bugs in the code,
we discover the bugs and we fix them.

But yes, this is quite annoying, especially with try_to_simplify_bb()
on which I already spend many hours on it.

> The more I realized sparse has been doing a lot of stuff relate to optimization
> wrong. The phi node placement as you point out is a big one, there are others.
> That is my general observation, not reason to against you patch though.
> That is way beyond the scope of this patch any way.

The two big things that need to be fixed regarding optimization are:
- the placement of the phi-node
- associate each phi's source to the phi-node's parent
  (Linus may object on this, he at least objected 10 years ago)
The last point will then allow tfix some issues I'm aware of regarding
liveness and make things much easier when manipulating phis.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] fix: try_to_simplify_bb eargerness part 2
Date: Sun, 30 Jul 2017 17:06:32 +0000
Message-ID: <CANeU7Qk+UOfbiggFDC5YfGGiWQVeGrarTsqk0DKsA==Gp_ndyw () mail ! gmail ! com>
--------------------
On Sun, Jul 30, 2017 at 12:04 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> It's was draft/temptative patch for -rc5.
>
Thanks for the clarification.

>
> Please don't, I'm still working on it.

Of course, I don't apply it now. I will wait for your git pull to apply.

> I don't like at all this situation also.
> The problem is quite complex and deep.
>
> This patch seems to solve the problem and (at least something
> similar) is needed but my first analysis was also right and thus something
> similar is still needed for simplify_branch_branch().
>
> Also, the revert would not be a good solution because it would
> only avoid to trigger the problem on this input but won't solve anything.

I totally agree. The revert is temporary bandage to buy us more time to fix
the real problem. That is well understood. We still have the question to answer
will RC5 and follow up official release have the revert or not.

Currently I am leaning towards keep the revert for this release but I can
be convinced otherwise.

> The problem is unrelated to undefined *var* but these wrong branch
> simplification bypass some pseudo definition which, in a way,
> become undefined on some paths which then create the problem
> you saw with setne %r11, %r11, 0

Yes, we all know "setne %r11, %r11, 0" is the big offender.
We just don't have a clear picture why it get there.

> Well, I don't see things exactly the same.
> For me, there is a code base, there are bugs in the code,
> we discover the bugs and we fix them.

Sorry that came out wrong, I mean to said there is some more
deeper issue.

> But yes, this is quite annoying, especially with try_to_simplify_bb()
> on which I already spend many hours on it.

I also spend many hours on it haven't able to crack it yet. The best I can
do is make it simplify the original huge test input as a much smaller
test case.

"Help me, Obi-Wan Kenobi. You're my only hope."


> The two big things that need to be fixed regarding optimization are:
> - the placement of the phi-node
> - associate each phi's source to the phi-node's parent
>   (Linus may object on this, he at least objected 10 years ago)

We will revisit this after the release. I have my wish list as well.

Right now let's solve this bug first. At least come to a decision
what to do with it on the upcoming release.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] llvm: add script to display the deserialized LLVM IR ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] llvm: add script to display the deserialized LLVM IR
Date: Sat, 11 Mar 2017 11:58:13 +0000
Message-ID: <20170311115813.23249-1-luc.vanoostenryck () gmail ! com>
--------------------
The goal is to use this in some of test cases, by comparing
the expected output with the actual one.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---
 sparse-llvm-dis | 13 +++++++++++++
 1 file changed, 13 insertions(+)
 create mode 100755 sparse-llvm-dis

diff --git a/sparse-llvm-dis b/sparse-llvm-dis
new file mode 100755
index 000000000..573f8bbd0
--- /dev/null
+++ b/sparse-llvm-dis
@@ -0,0 +1,13 @@
+#!/bin/sh
+
+set +e
+
+DIRNAME=`dirname $0`
+DIS=`"${LLVM_CONFIG:-llvm-config}" --bindir`/llvm-dis
+
+if [ $# -eq 0 ]; then
+  echo "`basename $0`: no input files"
+  exit 1
+fi
+
+$DIRNAME/sparse-llvm $@ | $DIS
-- 
2.11.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] llvm: add script to display the deserialized LLVM IR
Date: Tue, 25 Apr 2017 20:43:28 +0000
Message-ID: <CANeU7Q=B=+j1YmbmH1=wkoxizVm0Tu8+PQLJQ5j_UMKv2n-V9g () mail ! gmail ! com>
--------------------
On Sat, Mar 11, 2017 at 7:58 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> The goal is to use this in some of test cases, by comparing
> the expected output with the actual one.
>
> diff --git a/sparse-llvm-dis b/sparse-llvm-dis
> new file mode 100755
> index 000000000..573f8bbd0
> --- /dev/null
> +++ b/sparse-llvm-dis
> @@ -0,0 +1,13 @@
> +#!/bin/sh
> +
> +set +e
> +
> +DIRNAME=`dirname $0`
> +DIS=`"${LLVM_CONFIG:-llvm-config}" --bindir`/llvm-dis
> +
> +if [ $# -eq 0 ]; then
> +  echo "`basename $0`: no input files"
> +  exit 1
> +fi
> +
> +$DIRNAME/sparse-llvm $@ | $DIS

Looks good. You might want to check llvm-dis and sparse-llvm is
there. I assume this script will not be invoked if llvm is not there
so it is not a big deal.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] llvm: add script to display the deserialized LLVM IR
Date: Wed, 26 Apr 2017 02:11:21 +0000
Message-ID: <CAMHZB6HsOF+bO=FMXkX1MbBneAZRqC=07MDUG5hzgDLbVAma8w () mail ! gmail ! com>
--------------------
On Tue, Apr 25, 2017 at 10:43 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Sat, Mar 11, 2017 at 7:58 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> The goal is to use this in some of test cases, by comparing
>> the expected output with the actual one.
>>
>
> Looks good. You might want to check llvm-dis and sparse-llvm is
> there. I assume this script will not be invoked if llvm is not there
> so it is not a big deal.
>
> Chris

Yes, it need sparse-llvm anyway.

OTOH, there is no users for this script so it can kept on hold too.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] move kill_unreachable_bbs to outer cse stage ===

From: Christopher Li <sparse@chrisli.org>
To: Unknown
Subject: [PATCH] move kill_unreachable_bbs to outer cse stage
Date: Sat, 8 Jul 2017 19:34:49 -0700
Message-ID: 
--------------------
The current way of kill_unreach_bbs in insert_branch()
cause delete entry in ptrlist that the upper level
caller is looping on.

Move it outside to the cse stage avoid that problem.

Reported-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Signed-of-By: Christopher Li <sparse@chrisli.org>
---
 cse.c       | 3 +++
 flow.c      | 2 --
 linearize.c | 3 ---
 3 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/cse.c b/cse.c
index 0d3815c..af9863f 100644
--- a/cse.c
+++ b/cse.c
@@ -387,6 +387,9 @@ repeat:
  }
  }

+ if (repeat_phase & REPEAT_CFG_CLEANUP)
+ kill_unreachable_bbs(ep);
+
  if (repeat_phase & REPEAT_SYMBOL_CLEANUP)
  simplify_memops(ep);

diff --git a/flow.c b/flow.c
index c7161d4..fce8bde 100644
--- a/flow.c
+++ b/flow.c
@@ -840,8 +840,6 @@ void kill_unreachable_bbs(struct entrypoint *ep)
  DELETE_CURRENT_PTR(bb);
  } END_FOR_EACH_PTR(bb);
  PACK_PTR_LIST(&ep->bbs);
-
- repeat_phase &= ~REPEAT_CFG_CLEANUP;
 }

 static int rewrite_parent_branch(struct basic_block *bb, struct
basic_block *old, struct basic_block *new)
diff --git a/linearize.c b/linearize.c
index 7313e72..a367207 100644
--- a/linearize.c
+++ b/linearize.c
@@ -671,9 +671,6 @@ void insert_branch(struct basic_block *bb, struct
instruction *jmp, struct basic
  remove_parent(child, bb);
  } END_FOR_EACH_PTR(child);
  PACK_PTR_LIST(&bb->children);
-
- if (repeat_phase & REPEAT_CFG_CLEANUP)
- kill_unreachable_bbs(bb->ep);
 }


-- 
2.9.4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] temporary revert commit 11b1a83b d7985338 cause deadloop ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] temporary revert commit 11b1a83b d7985338 cause deadloop
Date: Wed, 19 Jul 2017 11:43:24 +0000
Message-ID: <CANeU7Q=DKhxVrVab8VwQczFuJ4UK7ucu08JBXseQtjYH729ZsA () mail ! gmail ! com>
--------------------
Michael Stefaniuc report that sparse deadloop on one of the
wine source file. The minimal test case to reproduced the
deadloop has been add to validation as "kill-unreachable-phi.c".

The change that introduce the deadloop can be trace back to
11b1a83b "fix OP_PHI usage in try_to_simplify_bb()" and later
d7985338 "fix OP_PHI usage in try_to_simplify_bb() only when non-bogus"

Temporary revert the change to avoid the deadloop.

The revert cause one of the test case fail because some phi
related optimization was not done. I set that test case to
known to fail.

Reported-by: Michael Stefaniuc <mstefani@mykolab.com>
Signed-off-by: Christopher Li <sparse@chrisli.org>
---
 flow.c                            | 16 +++++++---------
 validation/kill-phi-ttsbb.c       |  1 +
 validation/kill-unreachable-phi.c | 27 +++++++++++++++++++++++++++
 3 files changed, 35 insertions(+), 9 deletions(-)
 create mode 100644 validation/kill-unreachable-phi.c

diff --git a/flow.c b/flow.c
index bfe54f7..4ff6745 100644
--- a/flow.c
+++ b/flow.c
@@ -119,14 +119,6 @@ static int try_to_simplify_bb(struct basic_block
*bb, struct instruction *first,
 {
  int changed = 0;
  pseudo_t phi;
- int bogus;
-
- /*
- * This a due to improper dominance tracking during
- * simplify_symbol_usage()/conversion to SSA form.
- * No sane simplification can be done when we have this.
- */
- bogus = bb_list_size(bb->parents) != pseudo_list_size(first->phi_list);

  FOR_EACH_PTR(first->phi_list, phi) {
  struct instruction *def = phi->def;
@@ -156,8 +148,14 @@ static int try_to_simplify_bb(struct basic_block
*bb, struct instruction *first,
  continue;
  changed |= rewrite_branch(source, &br->bb_true, bb, target);
  changed |= rewrite_branch(source, &br->bb_false, bb, target);
- if (changed && !bogus)
+ /*
+ * FIXME: change 11b1a83 cause deadloop on wine compile,
+ * disable for now.
+ */
+#if 0
+ if (changed)
  kill_use(THIS_ADDRESS(phi));
+#endif
  } END_FOR_EACH_PTR(phi);
  return changed;
 }
diff --git a/validation/kill-phi-ttsbb.c b/validation/kill-phi-ttsbb.c
index 178a65d..b05c4c2 100644
--- a/validation/kill-phi-ttsbb.c
+++ b/validation/kill-phi-ttsbb.c
@@ -22,6 +22,7 @@ static int foo(int a, int b)
  * Verify if OP_PHI usage is adjusted after successful try_to_simplify_bb()
  * check-command: test-linearize $file
  * check-output-ignore
+ * check-known-to-fail
  *
  * check-output-excludes: phi\\.
  * check-output-excludes: phisrc\\.
diff --git a/validation/kill-unreachable-phi.c
b/validation/kill-unreachable-phi.c
new file mode 100644
index 0000000..4c7e249
--- /dev/null
+++ b/validation/kill-unreachable-phi.c
@@ -0,0 +1,27 @@
+extern char *strcpy (char *__dest, const char *__src);
+
+static void test_menu_iteminfo( void )
+{
+ int ansi = 1;
+ void *init, *string;
+ char initA[]="XYZ";
+ char stringA[0x80];
+ do {
+ if(ansi) {
+ string=stringA;
+ init = initA;
+ }
+ if(ansi)
+ strcpy( string, init );
+ } while( !(ansi = !ansi) );
+}
+/*
+ * check-name: kill-unreachable-phi
+ * check-description:
+ * In wine source tests/menu.c
+ * Improper killing a phi instruction inside not reachable BB cause
+ * dead loop on sparse.
+ *
+ * check-output-ignore
+ *
+ */
-- 
2.13.3
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] testsuite: respect command line's quotes & whitespaces ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [PATCH] testsuite: respect command line's quotes & whitespaces
Date: Mon, 18 Sep 2017 13:52:27 +0000
Message-ID: <20170918135227.65141-1-luc.vanoostenryck () gmail ! com>
--------------------
Currently the testsuite use 'eval echo $cmd' to expand
the name of the test file to be given on the command line.

This as the annoying consequence to go a bit too far in
the expansion of variables and to destroy any quotes and
whitespaces escaping that would have done.

Fix this by doing the eval later, when effectively executing
the command.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
---

The patch is also available for review & testing in the git repository at:
  git://github.com/lucvoo/sparse.git testsuite-fix-quotes-cmdline

 validation/preprocessor/arg-cli-ko.c | 1 -
 validation/test-suite                | 6 +++---
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/validation/preprocessor/arg-cli-ko.c b/validation/preprocessor/arg-cli-ko.c
index d4e2803c0..104bb8b0f 100644
--- a/validation/preprocessor/arg-cli-ko.c
+++ b/validation/preprocessor/arg-cli-ko.c
@@ -6,7 +6,6 @@ M2(0,1)
  * check-command: sparse -E '-DM1(X)=X' '-DM2(X, Y)=B Y S X T' $file
  *
  * check-description: this is a failure of the testsuite.
- * check-known-to-fail
  *
  * check-output-start
 
diff --git a/validation/test-suite b/validation/test-suite
index 055eecc21..bd92e14a4 100755
--- a/validation/test-suite
+++ b/validation/test-suite
@@ -309,13 +309,13 @@ do_test()
 		fi
 	fi
 
-	cmd=`eval echo $default_path/$check_command`
+	cmd="$default_path/$check_command"
 
 	if [ -z "$vquiet" ]; then
 		echo "  TEST	$test_name ($file)"
 	fi
 
-	verbose "Using command       : $cmd"
+	verbose "Using command       : $(eval echo $cmd)"
 
 	# grab the expected exit value
 	expected_exit_value=$check_exit_value
@@ -327,7 +327,7 @@ do_test()
 	fi
 
 	# grab the actual output & exit value
-	$cmd 1> $file.output.got 2> $file.error.got
+	eval $cmd 1> $file.output.got 2> $file.error.got
 	actual_exit_value=$?
 
 	must_fail=$check_known_to_fail
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] thread_info: suppress sparse warning in check_copy_size() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] thread_info: suppress sparse warning in check_copy_size()
Date: Fri, 28 Jul 2017 09:16:49 +0000
Message-ID: <CAExDi1QnPdUfrLgAzJUq=4ZQ9r+cLF26oyq=rm20bLj0XAYZiQ () mail ! gmail ! com>
--------------------
On Thu, Jul 27, 2017 at 12:41 AM, Linus Torvalds
<torvalds@linux-foundation.org> wrote:
> This is wrong. The sparse version of __compiletime_object_size()
> should just be fixed to take a 'const' pointer without complaints.

The underlying __builtin_object_size() has been fixed in the sparse tree
6 months ago or so.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] use VOID instead of directly using &void_pseudo ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] use VOID instead of directly using &void_pseudo
Date: Mon, 27 Feb 2017 15:40:52 +0000
Message-ID: <CANeU7Q=VUj_deEkgopRXAEAsKtgkP3i_Kd6SzE15t+yjCse6Yg () mail ! gmail ! com>
--------------------
On Mon, Feb 20, 2017 at 6:45 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> diff --git a/linearize.c b/linearize.c
> index 99203d915..6908e9f57 100644
> --- a/linearize.c
> +++ b/linearize.c
> @@ -1862,7 +1862,7 @@ static pseudo_t linearize_return(struct entrypoint *ep, struct statement *stmt)
>         struct basic_block *active;
>         pseudo_t src = linearize_expression(ep, expr);
>         active = ep->active;
> -       if (active && src != &void_pseudo) {
> +       if (active && src != VOID) {

Looks good.  Can you add S-O-B for this?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] use VOID instead of directly using &void_pseudo
Date: Mon, 27 Feb 2017 21:23:14 +0000
Message-ID: <CAExDi1S3_sUZPB3zMzzdQKM33UJaVbvOU2YHFTnFhJXUYEcfEg () mail ! gmail ! com>
--------------------
On Mon, Feb 27, 2017 at 4:40 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Mon, Feb 20, 2017 at 6:45 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> diff --git a/linearize.c b/linearize.c
>> index 99203d915..6908e9f57 100644
>> --- a/linearize.c
>> +++ b/linearize.c
>> @@ -1862,7 +1862,7 @@ static pseudo_t linearize_return(struct entrypoint *ep, struct statement *stmt)
>>         struct basic_block *active;
>>         pseudo_t src = linearize_expression(ep, expr);
>>         active = ep->active;
>> -       if (active && src != &void_pseudo) {
>> +       if (active && src != VOID) {
>
> Looks good.  Can you add S-O-B for this?
>
> Thanks

Sure.

Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 06/22] kvm: Adapt assembly for PIE support ===

From: "H. Peter Anvin" <hpa () zytor ! com>
To: linux-sparse
Subject: Re: [RFC 06/22] kvm: Adapt assembly for PIE support
Date: Wed, 19 Jul 2017 23:47:45 +0000
Message-ID: <201707192348.v6JNm8Rg003916 () mail ! zytor ! com>
--------------------
<paul.gortmaker@windriver.com>,Chris Metcalf <cmetcalf@mellanox.com>,"Paul E . McKenney" <paulmck@linux.vnet.ibm.com>,Andrew Morton <akpm@linux-foundation.org>,Christopher Li <sparse@chrisli.org>,Dou Liyang <douly.fnst@cn.fujitsu.com>,Masahiro Yamada <yamada.masahiro@socionext.com>,Daniel Borkmann <daniel@iogearbox.net>,Markus Trippelsdorf <markus@trippelsdorf.de>,Peter Foley <pefoley2@pefoley.com>,Steven Rostedt <rostedt@goodmis.org>,Tim Chen <tim.c.chen@linux.intel.com>,Catalin Marinas <catalin.marinas@arm.com>,Matthew Wilcox <mawilcox@microsoft.com>,Michal Hocko <mhocko@suse.com>,Rob Landley <rob@landley.net>,Jiri Kosina <jkosina@suse.cz>,"H . J . Lu" <hjl.tools@gmail.com>,Paul Bolle <pebolle@tiscali.nl>,Baoquan He <bhe@redhat.com>,Daniel Micay <danielmicay@gmail.com>,the arch/x86 maintainers <x86@kernel.org>,"linux-crypto@vger.kernel.org" <linux-crypto@vger.kernel.org>,Linux Kernel Mailing List <linux-kernel@vger.kernel.org>,xen-devel@lists.xenproject.org,kvm list
<kvm@vger.kernel.org>,linux-pm <linux-pm@vger.kernel.org>,linux-arch <linux-arch@vger.kernel.org>,Linux-Sparse <linux-sparse@vger.kernel.org>,Kernel Hardening <kernel-hardening@lists.openwall.com>
From: hpa@zytor.com
Message-ID: <83BA7600-BC8D-4C91-812C-DD2A0BF4474B@zytor.com>

On July 19, 2017 3:58:07 PM PDT, Ard Biesheuvel <ard.biesheuvel@linaro.org> wrote:
>On 19 July 2017 at 23:27, H. Peter Anvin <hpa@zytor.com> wrote:
>> On 07/19/17 08:40, Thomas Garnier wrote:
>>>>
>>>> This doesn't look right.  It's accessing a per-cpu variable.  The
>>>> per-cpu section is an absolute, zero-based section and not subject
>to
>>>> relocation.
>>>
>>> PIE does not respect the zero-based section, it tries to have
>>> everything relative. Patch 16/22 also adapt per-cpu to work with PIE
>>> (while keeping the zero absolute design by default).
>>>
>>
>> This is silly.  The right thing is for PIE is to be explicitly
>absolute,
>> without (%rip).  The use of (%rip) memory references for percpu is
>just
>> an optimization.
>>
>
>Sadly, there is an issue in binutils that may prevent us from doing
>this as cleanly as we would want.
>
>For historical reasons, bfd.ld emits special symbols like
>__GLOBAL_OFFSET_TABLE__ as absolute symbols with a section index of
>SHN_ABS, even though it is quite obvious that they are relative like
>any other symbol that points into the image. Unfortunately, this means
>that binutils needs to emit R_X86_64_RELATIVE relocations even for
>SHN_ABS symbols, which means we lose the ability to use both absolute
>and relocatable symbols in the same PIE image (unless the reloc tool
>can filter them out)
>
>More info here:
>https://sourceware.org/bugzilla/show_bug.cgi?id=19818

The reloc tool already has the ability to filter symbols.
-- 
Sent from my Android device with K-9 Mail. Please excuse my brevity.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC 20/22] x86/relocs: Add option to generate 64-bit relocations ===

From: "H. Peter Anvin" <hpa () zytor ! com>
To: linux-sparse
Subject: Re: [RFC 20/22] x86/relocs: Add option to generate 64-bit relocations
Date: Wed, 19 Jul 2017 23:45:37 +0000
Message-ID: <201707192346.v6JNk3QR002981 () mail ! zytor ! com>
--------------------
<cmetcalf@mellanox.com>,"Paul E . McKenney" <paulmck@linux.vnet.ibm.com>,Andrew Morton <akpm@linux-foundation.org>,Christopher Li <sparse@chrisli.org>,Dou Liyang <douly.fnst@cn.fujitsu.com>,Masahiro Yamada <yamada.masahiro@socionext.com>,Daniel Borkmann <daniel@iogearbox.net>,Markus Trippelsdorf <markus@trippelsdorf.de>,Peter Foley <pefoley2@pefoley.com>,Steven Rostedt <rostedt@goodmis.org>,Tim Chen <tim.c.chen@linux.intel.com>,Ard Biesheuvel <ard.biesheuvel@linaro.org>,Catalin Marinas <catalin.marinas@arm.com>,Matthew Wilcox <mawilcox@microsoft.com>,Michal Hocko <mhocko@suse.com>,Rob Landley <rob@landley.net>,Jiri Kosina <jkosina@suse.cz>,"H . J . Lu" <hjl.tools@gmail.com>,Paul Bolle <pebolle@tiscali.nl>,Baoquan He <bhe@redhat.com>,Daniel Micay <danielmicay@gmail.com>,the arch/x86 maintainers <x86@kernel.org>,linux-crypto@vger.kernel.org,LKML <linux-kernel@vger.kernel.org>,xen-devel@lists.xenproject.org,kvm list <kvm@vger.kernel.org>,Linux PM list
<linux-pm@vger.kernel.org>,linux-arch <linux-arch@vger.kernel.org>,linux-sparse@vger.kernel.org,Kernel Hardening <kernel-hardening@lists.openwall.com>
From: hpa@zytor.com
Message-ID: <0EF6FAAA-A99C-4F0D-9E4A-AD25E93957FB@zytor.com>

On July 19, 2017 4:25:56 PM PDT, Thomas Garnier <thgarnie@google.com> wrote:
>On Wed, Jul 19, 2017 at 4:08 PM, H. Peter Anvin <hpa@zytor.com> wrote:
>> On 07/19/17 15:47, Thomas Garnier wrote:
>>> On Wed, Jul 19, 2017 at 3:33 PM, H. Peter Anvin <hpa@zytor.com>
>wrote:
>>>> On 07/18/17 15:33, Thomas Garnier wrote:
>>>>> The x86 relocation tool generates a list of 32-bit signed
>integers. There
>>>>> was no need to use 64-bit integers because all addresses where
>above the 2G
>>>>> top of the memory.
>>>>>
>>>>> This change add a large-reloc option to generate 64-bit unsigned
>integers.
>>>>> It can be used when the kernel plan to go below the top 2G and
>32-bit
>>>>> integers are not enough.
>>>>
>>>> Why on Earth?  This would only be necessary if the *kernel itself*
>was
>>>> more than 2G, which isn't going to happen for the forseeable
>future.
>>>
>>> Because the relocation integer is an absolute address, not an offset
>>> in the binary. Next iteration, I can try using a 32-bit offset for
>>> everyone.
>>
>> It is an absolute address *as the kernel was originally linked*, for
>> obvious reasons.
>
>Sure when the kernel was just above 0xffffffff80000000, it doesn't
>work when it goes down to 0xffffffff00000000. That's why using an
>offset might make more sense in general.
>
>>
>>         -hpa
>>

What is the motivation for changing the pre linked address at all?
-- 
Sent from my Android device with K-9 Mail. Please excuse my brevity.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 00/48] fix promotion of symbol to register ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC PATCH 00/48] fix promotion of symbol to register
Date: Tue, 29 Aug 2017 12:37:39 +0000
Message-ID: <CANeU7QmsSLc1wt5Qc6kknk9=7ZO8EKC-Zg4YD53-uhyJXdHV_Q () mail ! gmail ! com>
--------------------
On Sun, Aug 27, 2017 at 1:16 AM, Christopher Li <sparse@chrisli.org> wrote:
> Hmm, with all the patch applied. sparse seems takes forever on
> two files of the full kernel check stress test. It looks like it is
> in a deadloop.
>
>  sound/pci/hda/hda_generic.c
>  drivers/block/drbd/drbd_receiver.c

Hi Luc, are you seeing this at all?

The full kernel check sparse is hanging on these two files.

>>>   git://github.com/lucvoo/sparse.git mem2reg
>>>

I haven't able to fetch your branch yet. The above
result is by applying patches to master.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 17/48] dump-ir: rename -fdump-linearize to -fdump-ir ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC PATCH 17/48] dump-ir: rename -fdump-linearize to -fdump-ir
Date: Sun, 27 Aug 2017 04:44:10 +0000
Message-ID: <CANeU7Qnhm4T1_baixTMyP06oDXAW2r6LU8j34K0JsFcUQUmdBw () mail ! gmail ! com>
--------------------
FYI, this one and the few follows does not have a signed off.
I assume you will add commit messages and signed off later.

Chris


On Wed, Aug 23, 2017 at 4:15 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> ---
>  cgcc                                   |  2 +-
>  lib.c                                  | 10 +++++-----
>  lib.h                                  |  2 +-
>  linearize.c                            |  4 ++--
>  sparse.1                               |  2 +-
>  validation/linear/bitfield-init-mask.c |  2 +-
>  6 files changed, 11 insertions(+), 11 deletions(-)
>
> diff --git a/cgcc b/cgcc
> index a8d7b4f21..644627109 100755
> --- a/cgcc
> +++ b/cgcc
> @@ -103,7 +103,7 @@ sub check_only_option {
>      my ($arg) =3D @_;
>      return 1 if $arg =3D~ /^-W(no-?)?(address-space|bitwise|cast-to-as|c=
ast-truncate|context|decl|default-bitfield-sign|designated-init|do-while|en=
um-mismatch|init-cstring|memcpy-max-count|non-pointer-null|old-initializer|=
one-bit-signed-bitfield|override-init-all|paren-string|ptr-subtraction-blow=
s|return-void|sizeof-bool|sparse-all|sparse-error|transparent-union|typesig=
n|undef|unknown-attribute)$/;
>      return 1 if $arg =3D~ /^-v(no-?)?(entry|dead)$/;
> -    return 1 if $arg =3D~ /^-f(dump-linearize|memcpy-max-count)(=3D\S*)?=
$/;
> +    return 1 if $arg =3D~ /^-f(dump-ir|memcpy-max-count)(=3D\S*)?$/;
>      return 0;
>  }
>
> diff --git a/lib.c b/lib.c
> index c46798d0f..a0ed29c3e 100644
> --- a/lib.c
> +++ b/lib.c
> @@ -258,7 +258,7 @@ int dbg_entry =3D 0;
>  int dbg_dead =3D 0;
>
>  int fmem_report =3D 0;
> -int fdump_linearize;
> +int fdump_ir;
>  unsigned long long fmemcpy_max_count =3D 100000;
>
>  int preprocess_only;
> @@ -724,12 +724,12 @@ static char **handle_switch_ftabstop(char *arg, cha=
r **next)
>
>  static char **handle_switch_fdump(char *arg, char **next)
>  {
> -       if (!strncmp(arg, "linearize", 9)) {
> -               arg +=3D 9;
> +       if (!strncmp(arg, "ir", 2)) {
> +               arg +=3D 2;
>                 if (*arg =3D=3D '\0')
> -                       fdump_linearize =3D 1;
> +                       fdump_ir =3D 1;
>                 else if (!strcmp(arg, "=3Donly"))
> -                       fdump_linearize =3D 2;
> +                       fdump_ir =3D 2;
>                 else
>                         goto err;
>         }
> diff --git a/lib.h b/lib.h
> index 307ccaeb2..ccac27d0b 100644
> --- a/lib.h
> +++ b/lib.h
> @@ -151,7 +151,7 @@ extern int dbg_entry;
>  extern int dbg_dead;
>
>  extern int fmem_report;
> -extern int fdump_linearize;
> +extern int fdump_ir;
>  extern unsigned long long fmemcpy_max_count;
>
>  extern int arch_m64;
> diff --git a/linearize.c b/linearize.c
> index 6cf97a42e..85acfd9c1 100644
> --- a/linearize.c
> +++ b/linearize.c
> @@ -2262,8 +2262,8 @@ static struct entrypoint *linearize_fn(struct symbo=
l *sym, struct symbol *base_t
>                 add_one_insn(ep, insn);
>         }
>
> -       if (fdump_linearize) {
> -               if (fdump_linearize =3D=3D 2)
> +       if (fdump_ir) {
> +               if (fdump_ir =3D=3D 2)
>                         return ep;
>                 show_entry(ep);
>         }
> diff --git a/sparse.1 b/sparse.1
> index b79c58767..c7ad4483b 100644
> --- a/sparse.1
> +++ b/sparse.1
> @@ -357,7 +357,7 @@ normalized GNU triplet. (e.g. i386-linux-gnu).
>  .
>  .SH DEBUG OPTIONS
>  .TP
> -.B \-fdump-linearize[=3Donly]
> +.B \-fdump-ir[=3Donly]
>  Dump the IR code of a function directly after its linearization,
>  before any simplifications is made. If the argument \fB=3Donly\fR is
>  also given no further processing is done on the function.
> diff --git a/validation/linear/bitfield-init-mask.c b/validation/linear/b=
itfield-init-mask.c
> index 94afa400c..f43605855 100644
> --- a/validation/linear/bitfield-init-mask.c
> +++ b/validation/linear/bitfield-init-mask.c
> @@ -18,7 +18,7 @@ struct bfu bfu_init_20_23(int a)
>
>  /*
>   * check-name: bitfield initializer mask
> - * check-command: test-linearize -fdump-linearize=3Donly -Wno-decl $file
> + * check-command: test-linearize -fdump-ir=3Donly -Wno-decl $file
>   * check-output-ignore
>   *
>   * check-output-contains: and\\..*fffff800\$
> --
> 2.14.0
>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 26/48] mem2reg: ignore all killed instructions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 26/48] mem2reg: ignore all killed instructions
Date: Wed, 23 Aug 2017 20:15:32 +0000
Message-ID: <20170823201554.90551-27-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index a9bf78ed4..7096a4bf2 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -253,14 +253,15 @@ static unsigned long externaly_visible(struct symbol *sym, unsigned long mod)
 		/* We know that the symbol-pseudo use is the "src" in the instruction */
 		struct instruction *insn = pu->insn;
 
+		if (!insn->bb)
+			continue;
+
 		switch (insn->opcode) {
 		case OP_STORE:
 			break;
 		case OP_LOAD:
 			break;
 		case OP_SYMADDR:
-			if (!insn->bb)
-				continue;
 			return MOD_ADDRESSABLE;
 		case OP_NOP:
 		case OP_SNOP:
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 28/48] mem2reg: extract kill_pseudo_dominated_stores() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 28/48] mem2reg: extract kill_pseudo_dominated_stores()
Date: Wed, 23 Aug 2017 20:15:34 +0000
Message-ID: <20170823201554.90551-29-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index 4671d4710..d13af1dd2 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -251,6 +251,17 @@ static void kill_dominated_stores(pseudo_t pseudo, struct instruction *insn,
 	} END_FOR_EACH_PTR(parent);
 }
 
+static void kill_pseudo_dominated_stores(pseudo_t pseudo, int local)
+{
+	struct pseudo_user *pu;
+
+	FOR_EACH_PTR(pseudo->users, pu) {
+		struct instruction *insn = pu->insn;
+		if (insn->opcode == OP_STORE)
+			kill_dominated_stores(pseudo, insn, ++bb_generation, insn->bb, local, 0);
+	} END_FOR_EACH_PTR(pu);
+}
+
 
 static unsigned long externaly_visible(struct symbol *sym, unsigned long mod)
 {
@@ -324,11 +335,7 @@ static void promote_symbol(struct entrypoint *ep, struct symbol *sym)
 		 * If we couldn't take the shortcut, see if we can at least kill some
 		 * of them..
 		 */
-		FOR_EACH_PTR(pseudo->users, pu) {
-			struct instruction *insn = pu->insn;
-			if (insn->opcode == OP_STORE)
-				kill_dominated_stores(pseudo, insn, ++bb_generation, insn->bb, !mod, 0);
-		} END_FOR_EACH_PTR(pu);
+		kill_pseudo_dominated_stores(pseudo, !mod);
 
 		if (!(mod & (MOD_NONLOCAL | MOD_STATIC))) {
 			struct basic_block *bb;
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 29/48] mem2reg: extract kill_pseudo_dead_stores() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 29/48] mem2reg: extract kill_pseudo_dead_stores()
Date: Wed, 23 Aug 2017 20:15:35 +0000
Message-ID: <20170823201554.90551-30-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index d13af1dd2..2a976e826 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -200,6 +200,15 @@ static void kill_dead_stores(pseudo_t pseudo, unsigned long generation, struct b
 	} END_FOR_EACH_PTR(parent);
 }
 
+static void kill_pseudo_dead_stores(struct entrypoint *ep, pseudo_t pseudo, int local)
+{
+	struct basic_block *bb;
+	FOR_EACH_PTR(ep->bbs, bb) {
+		if (!bb->children)
+			kill_dead_stores(pseudo, ++bb_generation, bb, local);
+	} END_FOR_EACH_PTR(bb);
+}
+
 /*
  * This should see if the "insn" trivially dominates some previous store, and kill the
  * store if unnecessary.
@@ -338,11 +347,7 @@ static void promote_symbol(struct entrypoint *ep, struct symbol *sym)
 		kill_pseudo_dominated_stores(pseudo, !mod);
 
 		if (!(mod & (MOD_NONLOCAL | MOD_STATIC))) {
-			struct basic_block *bb;
-			FOR_EACH_PTR(ep->bbs, bb) {
-				if (!bb->children)
-					kill_dead_stores(pseudo, ++bb_generation, bb, !mod);
-			} END_FOR_EACH_PTR(bb);
+			kill_pseudo_dead_stores(ep, pseudo, !mod);
 		}
 	}
 
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 30/48] mem2reg: remove one indent level ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 30/48] mem2reg: remove one indent level
Date: Wed, 23 Aug 2017 20:15:36 +0000
Message-ID: <20170823201554.90551-31-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 22 +++++++++-------------
 1 file changed, 9 insertions(+), 13 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index 2a976e826..b7dc3cb4b 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -337,21 +337,17 @@ static void promote_symbol(struct entrypoint *ep, struct symbol *sym)
 	} END_FOR_EACH_PTR_REVERSE(pu);
 
 	/* If we converted all the loads, remove the stores. They are dead */
-	if (all && !mod) {
+	if (all && !mod)
 		return kill_pseudo_stores(pseudo);
-	} else {
-		/*
-		 * If we couldn't take the shortcut, see if we can at least kill some
-		 * of them..
-		 */
-		kill_pseudo_dominated_stores(pseudo, !mod);
-
-		if (!(mod & (MOD_NONLOCAL | MOD_STATIC))) {
-			kill_pseudo_dead_stores(ep, pseudo, !mod);
-		}
-	}
 
-	return;
+	/*
+	 * If we couldn't take the shortcut, see if we can at least kill some
+	 * of them..
+	 */
+	kill_pseudo_dominated_stores(pseudo, !mod);
+
+	if (!(mod & (MOD_NONLOCAL | MOD_STATIC)))
+		kill_pseudo_dead_stores(ep, pseudo, !mod);
 }
 
 void promote_symbols_usage(struct entrypoint *ep)
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 31/48] mem2reg: add comment to find_dominating_stores() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 31/48] mem2reg: add comment to find_dominating_stores()
Date: Wed, 23 Aug 2017 20:15:37 +0000
Message-ID: <20170823201554.90551-32-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/mem2reg.c b/mem2reg.c
index b7dc3cb4b..26837935c 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -68,6 +68,11 @@ found_dominator:
 	return 1;
 }
 
+/*
+ * pseudo: pseudo for a symbol
+ * insn: is a load of the symbol 'pseudo'.
+ * local: is the symbol local or externally visible?
+ */
 static int find_dominating_stores(pseudo_t pseudo, struct instruction *insn,
 	unsigned long generation, int local)
 {
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 32/48] mem2reg: add flags to enable/disable some parts ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 32/48] mem2reg: add flags to enable/disable some parts
Date: Wed, 23 Aug 2017 20:15:38 +0000
Message-ID: <20170823201554.90551-33-luc.vanoostenryck () gmail ! com>
--------------------
---
 lib.c     |  8 ++++++++
 lib.h     |  6 +++++-
 mem2reg.c |  3 +++
 memops.c  | 17 ++++++++++++++++-
 sparse.1  | 28 ++++++++++++++++++++++++++++
 5 files changed, 60 insertions(+), 2 deletions(-)

diff --git a/lib.c b/lib.c
index d3aaf10d2..0705775e5 100644
--- a/lib.c
+++ b/lib.c
@@ -260,6 +260,10 @@ int dbg_dead = 0;
 int fmem_report = 0;
 int fdump_ir;
 unsigned long long fmemcpy_max_count = 100000;
+int fpromote_symbols_usage = 1;
+int fsimplify_loads = 1;
+int fsimplify_loads_full = 0;		// currently broken
+int fsimplify_stores = 1;
 
 int preprocess_only;
 
@@ -780,6 +784,10 @@ err:
 
 static struct flag fflags[] = {
 	{ "mem-report",			&fmem_report },
+	{ "promote-symbols-usage",	&fpromote_symbols_usage },
+	{ "simplify-loads",		&fsimplify_loads },
+	{ "simplify-loads-full",	&fsimplify_loads_full },
+	{ "simplify-stores",		&fsimplify_stores },
 	{ },
 };
 
diff --git a/lib.h b/lib.h
index d0b699535..a2fd04e67 100644
--- a/lib.h
+++ b/lib.h
@@ -154,9 +154,13 @@ extern int dump_macro_defs;
 extern int dbg_entry;
 extern int dbg_dead;
 
-extern int fmem_report;
 extern int fdump_ir;
+extern int fmem_report;
 extern unsigned long long fmemcpy_max_count;
+extern int fpromote_symbols_usage;
+extern int fsimplify_loads;
+extern int fsimplify_loads_full;
+extern int fsimplify_stores;
 
 extern int arch_m64;
 extern int arch_msize_long;
diff --git a/mem2reg.c b/mem2reg.c
index 26837935c..c2f77ffbe 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -359,6 +359,9 @@ void promote_symbols_usage(struct entrypoint *ep)
 {
 	pseudo_t pseudo;
 
+	if (!fpromote_symbols_usage)
+		return;
+
 	FOR_EACH_PTR(ep->accesses, pseudo) {
 		promote_symbol(ep, pseudo->sym);
 	} END_FOR_EACH_PTR(pseudo);
diff --git a/memops.c b/memops.c
index 99430e455..501973788 100644
--- a/memops.c
+++ b/memops.c
@@ -120,15 +120,30 @@ next_store:
 	} END_FOR_EACH_PTR_REVERSE(insn);
 }
 
-void simplify_memops(struct entrypoint *ep)
+static void simplify_all_loads(struct entrypoint *ep)
 {
 	struct basic_block *bb;
 
+	if (!fsimplify_loads)
+		return;
 	FOR_EACH_PTR_REVERSE(ep->bbs, bb) {
 		simplify_loads(bb);
 	} END_FOR_EACH_PTR_REVERSE(bb);
+}
+
+static void simplify_all_stores(struct entrypoint *ep)
+{
+	struct basic_block *bb;
 
+	if (!fsimplify_stores)
+		return;
 	FOR_EACH_PTR_REVERSE(ep->bbs, bb) {
 		kill_dominated_stores(bb);
 	} END_FOR_EACH_PTR_REVERSE(bb);
 }
+
+void simplify_memops(struct entrypoint *ep)
+{
+	simplify_all_loads(ep);
+	simplify_all_stores(ep);
+}
diff --git a/sparse.1 b/sparse.1
index c7ad4483b..87958ef35 100644
--- a/sparse.1
+++ b/sparse.1
@@ -378,6 +378,34 @@ Set the distance between tab stops.  This helps sparse report correct
 column numbers in warnings or errors.  If the value is less than 1 or
 greater than 100, the option is ignored.  The default is 8.
 .
+.SH DEVELOPER OPTIONS
+.TP
+.B \-fno-promote-symbol-usage
+Enable or disable the promotion of memory accesses via symbol to registers.
+
+This option is enabled by default.
+.
+.TP
+.B \-fno-simplify-loads
+Enable or disable the promotion of memory loads to registers during
+the optimization passes.
+
+This option is enabled by default.
+.
+.TP
+.B \-fsimplify-loads-full
+Enable or disable the promotion of complex memory loads to registers during
+the optimization passes.
+
+This option is disabled by default.
+.
+.TP
+.B \-fno-simplify-stores
+Enable or disable the elimination of some stores to memory during
+the optimization passes.
+
+This option is enabled by default.
+.
 .SH SEE ALSO
 .BR cgcc (1)
 .
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 33/48] mem2reg: rename the other kill_dominated_stores() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 33/48] mem2reg: rename the other kill_dominated_stores()
Date: Wed, 23 Aug 2017 20:15:39 +0000
Message-ID: <20170823201554.90551-34-luc.vanoostenryck () gmail ! com>
--------------------
---
 memops.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/memops.c b/memops.c
index 501973788..294c89cbd 100644
--- a/memops.c
+++ b/memops.c
@@ -85,10 +85,11 @@ static void kill_store(struct instruction *insn)
 	}
 }
 
-static void kill_dominated_stores(struct basic_block *bb)
+static void simplify_stores(struct basic_block *bb)
 {
 	struct instruction *insn;
 
+	/* kill the dominated stores */
 	FOR_EACH_PTR_REVERSE(bb->insns, insn) {
 		if (!insn->bb)
 			continue;
@@ -138,7 +139,7 @@ static void simplify_all_stores(struct entrypoint *ep)
 	if (!fsimplify_stores)
 		return;
 	FOR_EACH_PTR_REVERSE(ep->bbs, bb) {
-		kill_dominated_stores(bb);
+		simplify_stores(bb);
 	} END_FOR_EACH_PTR_REVERSE(bb);
 }
 
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 35/48] mem2reg: be clear that we're using a symbol/var ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 35/48] mem2reg: be clear that we're using a symbol/var
Date: Wed, 23 Aug 2017 20:15:41 +0000
Message-ID: <20170823201554.90551-36-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index dca409f5d..641a1f65d 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -107,16 +107,17 @@ found_dominator:
 }
 
 /*
- * pseudo: pseudo for a symbol
- * insn: is a load of the symbol 'pseudo'.
+ * sym: a symbol/variable
+ * insn: is a load of the symbol 'sym'.
  * local: is the symbol local or externally visible?
  */
-static int find_dominating_stores(pseudo_t pseudo, struct instruction *insn,
+static int find_dominating_stores(struct symbol *sym, struct instruction *insn,
 	unsigned long generation, int local)
 {
 	struct basic_block *bb = insn->bb;
 	struct instruction *one, *dom = NULL;
 	struct pseudo_list *dominators;
+	pseudo_t pseudo = sym->pseudo;
 	int partial;
 
 	/* Unreachable load? Undo it */
@@ -376,7 +377,7 @@ static void promote_symbol(struct entrypoint *ep, struct symbol *sym)
 	FOR_EACH_PTR_REVERSE(pseudo->users, pu) {
 		struct instruction *insn = pu->insn;
 		if (insn->opcode == OP_LOAD)
-			all &= find_dominating_stores(pseudo, insn, ++bb_generation, !mod);
+			all &= find_dominating_stores(sym, insn, ++bb_generation, !mod);
 	} END_FOR_EACH_PTR_REVERSE(pu);
 
 	/* If we converted all the loads, remove the stores. They are dead */
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 36/48] mem2reg: be clear that we're using a symbol/var here too ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 36/48] mem2reg: be clear that we're using a symbol/var here too
Date: Wed, 23 Aug 2017 20:15:42 +0000
Message-ID: <20170823201554.90551-37-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index 641a1f65d..793a1d730 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -57,10 +57,11 @@ static int phisrc_in_bb(struct pseudo_list *list, struct basic_block *bb)
 	return 0;
 }
 
-static int find_dominating_parents(pseudo_t pseudo, struct instruction *insn,
+static int find_dominating_parents(struct symbol *sym, struct instruction *insn,
 	struct basic_block *bb, unsigned long generation, struct pseudo_list **dominators,
 	int local)
 {
+	pseudo_t pseudo = sym->pseudo;
 	struct basic_block *parent;
 
 	if (!bb->parents)
@@ -90,7 +91,7 @@ no_dominance:
 			continue;
 		parent->generation = generation;
 
-		if (!find_dominating_parents(pseudo, insn, parent, generation, dominators, local))
+		if (!find_dominating_parents(sym, insn, parent, generation, dominators, local))
 			return 0;
 		continue;
 
@@ -161,7 +162,7 @@ found:
 	bb->generation = generation;
 
 	dominators = NULL;
-	if (!find_dominating_parents(pseudo, insn, bb, generation, &dominators, local))
+	if (!find_dominating_parents(sym, insn, bb, generation, &dominators, local))
 		return 0;
 
 	/* This happens with initial assignments to structures etc.. */
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 37/48] mem2reg: add description for find_dominating_parents() ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 37/48] mem2reg: add description for find_dominating_parents()
Date: Wed, 23 Aug 2017 20:15:43 +0000
Message-ID: <20170823201554.90551-38-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/mem2reg.c b/mem2reg.c
index 793a1d730..0078485da 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -57,6 +57,16 @@ static int phisrc_in_bb(struct pseudo_list *list, struct basic_block *bb)
 	return 0;
 }
 
+/*
+ * sym - the symbol/var we're looking the value for
+ * insn - a load of 'sym'
+ * bb - the current bb we're looking
+ * generation - ditto
+ * dominators - list of dominators for this load
+ * local: is the symbol local or externally visible?
+ *
+ * returns 1 if we found a value, 0 otherwise.
+ */
 static int find_dominating_parents(struct symbol *sym, struct instruction *insn,
 	struct basic_block *bb, unsigned long generation, struct pseudo_list **dominators,
 	int local)
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 38/48] mem2reg: let rewrite_load_instruction() take the symbol as arg ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 38/48] mem2reg: let rewrite_load_instruction() take the symbol as arg
Date: Wed, 23 Aug 2017 20:15:44 +0000
Message-ID: <20170823201554.90551-39-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index 0078485da..4ba0f3408 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -12,7 +12,7 @@
  * We should probably sort the phi list just to make it easier to compare
  * later for equality.
  */
-static void rewrite_load_instruction(struct instruction *insn, struct pseudo_list *dominators)
+static void rewrite_load_instruction(struct symbol *sym, struct instruction *insn, struct pseudo_list *dominators)
 {
 	pseudo_t new, phi;
 
@@ -24,7 +24,7 @@ static void rewrite_load_instruction(struct instruction *insn, struct pseudo_lis
 	FOR_EACH_PTR(dominators, phi) {
 		if (new != phi->def->src1)
 			goto complex_phi;
-		new->ident = new->ident ? : phi->ident;
+		new->ident = new->ident ? : sym->ident;
 	} END_FOR_EACH_PTR(phi);
 
 	/*
@@ -190,7 +190,7 @@ found:
 	 * have to turn the load into a phi-node of the
 	 * dominators.
 	 */
-	rewrite_load_instruction(insn, dominators);
+	rewrite_load_instruction(sym, insn, dominators);
 	return 1;
 }
 
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 40/48] mem2reg: delay the creation of phi-sources ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 40/48] mem2reg: delay the creation of phi-sources
Date: Wed, 23 Aug 2017 20:15:46 +0000
Message-ID: <20170823201554.90551-41-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 67 ++++++++++++++++++++++++++++++++++++++++-----------------------
 1 file changed, 43 insertions(+), 24 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index ecda6675f..d0873b051 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -12,38 +12,63 @@
  * We should probably sort the phi list just to make it easier to compare
  * later for equality.
  */
-static void rewrite_load_instruction(struct symbol *sym, struct instruction *insn, struct pseudo_list *dominators)
+static void rewrite_load_instruction(struct symbol *sym, struct instruction *insn,
+	struct basic_block *bb, struct pseudo_list *dominators)
 {
-	pseudo_t new, phi;
+	struct basic_block *parent;
+	struct instruction *node;
+	pseudo_t new, val;
 
 	/*
 	 * Check for somewhat common case of duplicate
 	 * phi nodes.
 	 */
-	new = first_pseudo(dominators)->def->src1;
-	FOR_EACH_PTR(dominators, phi) {
-		if (new != phi->def->src1)
+	new = first_pseudo(dominators);
+	FOR_EACH_PTR(dominators, val) {
+		if (new != val)
 			goto complex_phi;
 		new->ident = new->ident ? : sym->ident;
-	} END_FOR_EACH_PTR(phi);
+	} END_FOR_EACH_PTR(val);
 
 	/*
-	 * All the same pseudo - mark the phi-nodes unused
-	 * and convert the load into a LNOP and replace the
-	 * pseudo.
+	 * All the same pseudo - replace the load by the unique val
 	 */
-	FOR_EACH_PTR(dominators, phi) {
-		kill_instruction(phi->def);
-	} END_FOR_EACH_PTR(phi);
-	convert_load_instruction(insn, new);
-	return;
+	goto convert;
 
 complex_phi:
+	/*
+	 * insert a new phi-node on top and
+	 * insert a phi-src at the end of each parents
+	 */
+	new = insert_phi_node(bb, sym);
+	node = new->def;
+
+	PREPARE_PTR_LIST(bb->parents, parent)
+	FOR_EACH_PTR(dominators, val) {
+		struct instruction *br;
+		pseudo_t src;
+
+		br = delete_last_instruction(&parent->insns);
+		/*
+		 * We could check if br is really a branch
+		 * We could check if the type of val & sym matches
+		 */
+		src = alloc_phi(parent, val, sym);
+		add_instruction(&parent->insns, br);
+		use_pseudo(node, src, add_pseudo(&node->phi_list, src));
+
+		NEXT_PTR_LIST(parent);
+	} END_FOR_EACH_PTR(val);
+	FINISH_PTR_LIST(parent);
+
+#if 0	// FIXME
 	/* We leave symbol pseudos with a bogus usage list here */
 	if (insn->src->type != PSEUDO_SYM)
 		kill_use(&insn->src);
-	insn->opcode = OP_PHI;
-	insn->phi_list = dominators;
+#endif
+
+convert:
+	convert_load_instruction(insn, new);
 }
 
 /*
@@ -68,8 +93,6 @@ static int find_dominating_parents(struct symbol *sym, struct instruction *insn,
 
 	FOR_EACH_PTR(bb->parents, parent) {
 		struct instruction *one;
-		struct instruction *br;
-		pseudo_t phi;
 
 		FOR_EACH_PTR_REVERSE(parent->insns, one) {
 			int dominance;
@@ -95,11 +118,7 @@ no_dominance:
 		continue;
 
 found_dominator:
-		br = delete_last_instruction(&parent->insns);
-		phi = alloc_phi(parent, one->target, one->type);
-		phi->ident = phi->ident ? : pseudo->ident;
-		add_instruction(&parent->insns, br);
-		use_pseudo(insn, phi, add_pseudo(dominators, phi));
+		add_pseudo(dominators, one->target);
 	} END_FOR_EACH_PTR(parent);
 	return 1;
 }
@@ -177,7 +196,7 @@ found:
 	 * have to turn the load into a phi-node of the
 	 * dominators.
 	 */
-	rewrite_load_instruction(sym, insn, dominators);
+	rewrite_load_instruction(sym, insn, bb, dominators);
 	return 1;
 }
 
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 41/48] mem2reg: make rewrite_load_instruction() functional ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 41/48] mem2reg: make rewrite_load_instruction() functional
Date: Wed, 23 Aug 2017 20:15:47 +0000
Message-ID: <20170823201554.90551-42-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c                       | 25 ++++++++++-------
 validation/loop-linearization.c | 60 ++++++++++++++++++++---------------------
 2 files changed, 45 insertions(+), 40 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index d0873b051..bb5fadbf2 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -12,7 +12,7 @@
  * We should probably sort the phi list just to make it easier to compare
  * later for equality.
  */
-static void rewrite_load_instruction(struct symbol *sym, struct instruction *insn,
+static pseudo_t dominating_value(struct symbol *sym,
 	struct basic_block *bb, struct pseudo_list *dominators)
 {
 	struct basic_block *parent;
@@ -31,9 +31,9 @@ static void rewrite_load_instruction(struct symbol *sym, struct instruction *ins
 	} END_FOR_EACH_PTR(val);
 
 	/*
-	 * All the same pseudo - replace the load by the unique val
+	 * All the same pseudo - use it!
 	 */
-	goto convert;
+	return new;
 
 complex_phi:
 	/*
@@ -67,8 +67,7 @@ complex_phi:
 		kill_use(&insn->src);
 #endif
 
-convert:
-	convert_load_instruction(insn, new);
+	return new;
 }
 
 /*
@@ -135,6 +134,7 @@ static int find_dominating_stores(struct symbol *sym, struct instruction *insn,
 	struct instruction *one, *dom = NULL;
 	struct pseudo_list *dominators;
 	pseudo_t pseudo = sym->pseudo;
+	pseudo_t val;
 	int partial;
 
 	/* Unreachable load? Undo it */
@@ -170,8 +170,8 @@ found:
 		return 0;
 
 	if (dom) {
-		convert_load_instruction(insn, dom->target);
-		return 1;
+		val = dom->target;
+		goto convert;
 	}
 
 	/* OK, go find the parents */
@@ -186,8 +186,10 @@ found:
 		if (!local)
 			return 0;
 		check_access(insn);
-		convert_load_instruction(insn, value_pseudo(0));
-		return 1;
+
+		// FIXME: should be UNDEF
+		val = value_pseudo(0);
+		goto convert;
 	}
 
 	/*
@@ -196,7 +198,10 @@ found:
 	 * have to turn the load into a phi-node of the
 	 * dominators.
 	 */
-	rewrite_load_instruction(sym, insn, bb, dominators);
+	val = dominating_value(sym, bb, dominators);
+
+convert:
+	convert_load_instruction(insn, val);
 	return 1;
 }
 
diff --git a/validation/loop-linearization.c b/validation/loop-linearization.c
index 25c6dfb87..6c531d056 100644
--- a/validation/loop-linearization.c
+++ b/validation/loop-linearization.c
@@ -39,16 +39,16 @@ static int fdo(void)
 ffor:
 .L0:
 	<entry-point>
-	phisrc.32   %phi5(i) <- $0
+	phisrc.32   %phi3 <- $0
 	br          .L4
 
 .L4:
-	phi.32      %r1(i) <- %phi5(i), %phi6(i)
-	setlt.32    %r2 <- %r1(i), $10
+	phi.32      %r8 <- %phi3, %phi4
+	setlt.32    %r2 <- %r8, $10
 	cbr         %r2, .L1, .L3
 
 .L1:
-	call.32     %r4 <- p, %r1(i)
+	call.32     %r4 <- p, %r8
 	cbr         %r4, .L2, .L5
 
 .L5:
@@ -56,8 +56,8 @@ ffor:
 	br          .L7
 
 .L2:
-	add.32      %r7 <- %r1(i), $1
-	phisrc.32   %phi6(i) <- %r7
+	add.32      %r7 <- %r8, $1
+	phisrc.32   %phi4 <- %r7
 	br          .L4
 
 .L3:
@@ -72,64 +72,64 @@ ffor:
 fwhile:
 .L8:
 	<entry-point>
-	phisrc.32   %phi11(i) <- $0
+	phisrc.32   %phi7 <- $0
 	br          .L12
 
 .L12:
-	phi.32      %r8(i) <- %phi11(i), %phi12(i)
-	setlt.32    %r9 <- %r8(i), $10
-	cbr         %r9, .L9, .L11
+	phi.32      %r16 <- %phi7, %phi8
+	setlt.32    %r10 <- %r16, $10
+	cbr         %r10, .L9, .L11
 
 .L9:
-	call.32     %r11 <- p, %r8(i)
-	cbr         %r11, .L14, .L13
+	call.32     %r12 <- p, %r16
+	cbr         %r12, .L14, .L13
 
 .L13:
-	phisrc.32   %phi7(return) <- $0
+	phisrc.32   %phi5(return) <- $0
 	br          .L15
 
 .L14:
-	add.32      %r14 <- %r8(i), $1
-	phisrc.32   %phi12(i) <- %r14
+	add.32      %r15 <- %r16, $1
+	phisrc.32   %phi8 <- %r15
 	br          .L12
 
 .L11:
-	phisrc.32   %phi8(return) <- $1
+	phisrc.32   %phi6(return) <- $1
 	br          .L15
 
 .L15:
-	phi.32      %r12 <- %phi7(return), %phi8(return)
-	ret.32      %r12
+	phi.32      %r13 <- %phi5(return), %phi6(return)
+	ret.32      %r13
 
 
 fdo:
 .L16:
 	<entry-point>
-	phisrc.32   %phi16(i) <- $0
+	phisrc.32   %phi11 <- $0
 	br          .L17
 
 .L17:
-	phi.32      %r15(i) <- %phi16(i), %phi17(i)
-	call.32     %r16 <- p, %r15(i)
-	cbr         %r16, .L18, .L20
+	phi.32      %r23 <- %phi11, %phi12
+	call.32     %r18 <- p, %r23
+	cbr         %r18, .L18, .L20
 
 .L20:
-	phisrc.32   %phi13(return) <- $0
+	phisrc.32   %phi9(return) <- $0
 	br          .L22
 
 .L18:
-	add.32      %r19 <- %r15(i), $1
-	setlt.32    %r20 <- %r15(i), $10
-	phisrc.32   %phi17(i) <- %r19
-	cbr         %r20, .L17, .L19
+	add.32      %r21 <- %r23, $1
+	setlt.32    %r22 <- %r23, $10
+	phisrc.32   %phi12 <- %r21
+	cbr         %r22, .L17, .L19
 
 .L19:
-	phisrc.32   %phi14(return) <- $1
+	phisrc.32   %phi10(return) <- $1
 	br          .L22
 
 .L22:
-	phi.32      %r17 <- %phi13(return), %phi14(return)
-	ret.32      %r17
+	phi.32      %r19 <- %phi9(return), %phi10(return)
+	ret.32      %r19
 
 
  * check-output-end
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 42/48] mem2reg: rename one->target to dom ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 42/48] mem2reg: rename one->target to dom
Date: Wed, 23 Aug 2017 20:15:48 +0000
Message-ID: <20170823201554.90551-43-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/mem2reg.c b/mem2reg.c
index bb5fadbf2..e27739701 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -86,6 +86,7 @@ static int find_dominating_parents(struct symbol *sym, struct instruction *insn,
 {
 	pseudo_t pseudo = sym->pseudo;
 	struct basic_block *parent;
+	pseudo_t dom;
 
 	if (!bb->parents)
 		return !!local;
@@ -105,6 +106,7 @@ static int find_dominating_parents(struct symbol *sym, struct instruction *insn,
 			}
 			if (!dominance)
 				continue;
+			dom = one->target;
 			goto found_dominator;
 		} END_FOR_EACH_PTR_REVERSE(one);
 no_dominance:
@@ -117,7 +119,7 @@ no_dominance:
 		continue;
 
 found_dominator:
-		add_pseudo(dominators, one->target);
+		add_pseudo(dominators, dom);
 	} END_FOR_EACH_PTR(parent);
 	return 1;
 }
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 43/48] mem2reg: get recursion right ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 43/48] mem2reg: get recursion right
Date: Wed, 23 Aug 2017 20:15:49 +0000
Message-ID: <20170823201554.90551-44-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c                       | 71 ++++++++++++++++++++++++-----------------
 validation/loop-linearization.c |  4 +--
 2 files changed, 43 insertions(+), 32 deletions(-)

diff --git a/mem2reg.c b/mem2reg.c
index e27739701..5f1c968a0 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -70,6 +70,10 @@ complex_phi:
 	return new;
 }
 
+
+static pseudo_t find_dominating_value(struct symbol *sym, struct instruction *insn,
+	struct basic_block *bb, unsigned long generation, int local);
+
 /*
  * sym - the symbol/var we're looking the value for
  * insn - a load of 'sym'
@@ -110,13 +114,9 @@ static int find_dominating_parents(struct symbol *sym, struct instruction *insn,
 			goto found_dominator;
 		} END_FOR_EACH_PTR_REVERSE(one);
 no_dominance:
-		if (parent->generation == generation)
-			continue;
-		parent->generation = generation;
-
-		if (!find_dominating_parents(sym, insn, parent, generation, dominators, local))
+		dom = find_dominating_value(sym, insn, parent, generation, local);
+		if (!dom)
 			return 0;
-		continue;
 
 found_dominator:
 		add_pseudo(dominators, dom);
@@ -124,6 +124,39 @@ found_dominator:
 	return 1;
 }
 
+static pseudo_t find_dominating_value(struct symbol *sym, struct instruction *insn,
+	struct basic_block *bb, unsigned long generation, int local)
+{
+	struct pseudo_list *dominators = NULL;
+
+	if (bb->generation == generation) {
+		return insn->target;
+		// FIXME: is that exact ?
+	}
+
+	bb->generation = generation;
+	if (!find_dominating_parents(sym, insn, bb, generation, &dominators, local))
+		return NULL;
+
+	/* This happens with initial assignments to structures etc.. */
+	if (!dominators) {
+		if (!local)
+			return NULL;
+		check_access(insn);
+
+		// FIXME: should be UNDEF
+		return value_pseudo(0);
+	}
+
+	/*
+	 * If we find just one dominating instruction, we
+	 * can turn it into a direct thing. Otherwise we'll
+	 * have to turn the load into a phi-node of the
+	 * dominators.
+	 */
+	return dominating_value(sym, bb, dominators);
+}
+
 /*
  * sym: a symbol/variable
  * insn: is a load of the symbol 'sym'.
@@ -134,7 +167,6 @@ static int find_dominating_stores(struct symbol *sym, struct instruction *insn,
 {
 	struct basic_block *bb = insn->bb;
 	struct instruction *one, *dom = NULL;
-	struct pseudo_list *dominators;
 	pseudo_t pseudo = sym->pseudo;
 	pseudo_t val;
 	int partial;
@@ -177,31 +209,10 @@ found:
 	}
 
 	/* OK, go find the parents */
-	bb->generation = generation;
-
-	dominators = NULL;
-	if (!find_dominating_parents(sym, insn, bb, generation, &dominators, local))
+	val = find_dominating_value(sym, insn, bb, generation, local);
+	if (!val)
 		return 0;
 
-	/* This happens with initial assignments to structures etc.. */
-	if (!dominators) {
-		if (!local)
-			return 0;
-		check_access(insn);
-
-		// FIXME: should be UNDEF
-		val = value_pseudo(0);
-		goto convert;
-	}
-
-	/*
-	 * If we find just one dominating instruction, we
-	 * can turn it into a direct thing. Otherwise we'll
-	 * have to turn the load into a phi-node of the
-	 * dominators.
-	 */
-	val = dominating_value(sym, bb, dominators);
-
 convert:
 	convert_load_instruction(insn, val);
 	return 1;
diff --git a/validation/loop-linearization.c b/validation/loop-linearization.c
index 6c531d056..9b35cf699 100644
--- a/validation/loop-linearization.c
+++ b/validation/loop-linearization.c
@@ -89,8 +89,8 @@ fwhile:
 	br          .L15
 
 .L14:
-	add.32      %r15 <- %r16, $1
-	phisrc.32   %phi8 <- %r15
+	add.32      %r15(i) <- %r16, $1
+	phisrc.32   %phi8 <- %r15(i)
 	br          .L12
 
 .L11:
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 44/48] mem2reg: don't check dominance by removed instructions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 44/48] mem2reg: don't check dominance by removed instructions
Date: Wed, 23 Aug 2017 20:15:50 +0000
Message-ID: <20170823201554.90551-45-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/mem2reg.c b/mem2reg.c
index 5f1c968a0..493274df5 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -100,6 +100,8 @@ static int find_dominating_parents(struct symbol *sym, struct instruction *insn,
 
 		FOR_EACH_PTR_REVERSE(parent->insns, one) {
 			int dominance;
+			if (!one->bb)
+				continue;
 			if (one == insn)
 				goto no_dominance;
 			dominance = dominates(pseudo, insn, one, local);
@@ -180,6 +182,8 @@ static int find_dominating_stores(struct symbol *sym, struct instruction *insn,
 	partial = 0;
 	FOR_EACH_PTR(bb->insns, one) {
 		int dominance;
+		if (!one->bb)
+			continue;
 		if (one == insn)
 			goto found;
 		dominance = dominates(pseudo, insn, one, local);
@@ -250,6 +254,8 @@ static void kill_dead_stores(pseudo_t pseudo, unsigned long generation, struct b
 	FOR_EACH_PTR_REVERSE(bb->insns, insn) {
 		int opcode = insn->opcode;
 
+		if (!insn->bb)
+			continue;
 		if (opcode != OP_LOAD && opcode != OP_STORE) {
 			if (local)
 				continue;
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 45/48] mem2reg: update copyright ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 45/48] mem2reg: update copyright
Date: Wed, 23 Aug 2017 20:15:51 +0000
Message-ID: <20170823201554.90551-46-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/mem2reg.c b/mem2reg.c
index 493274df5..d31cd4121 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -2,6 +2,7 @@
  * mem2reg - promote memory accesses to registers.
  *
  * Copyright (C) 2004 Linus Torvalds
+ * Copyright (C) 2017 Luc Van Oostenryck
  */
 
 #include "linearize.h"
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 46/48] mem2reg: allow dumping IR ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 46/48] mem2reg: allow dumping IR
Date: Wed, 23 Aug 2017 20:15:52 +0000
Message-ID: <20170823201554.90551-47-luc.vanoostenryck () gmail ! com>
--------------------
---
 lib.c       | 1 +
 lib.h       | 1 +
 linearize.c | 5 +++++
 3 files changed, 7 insertions(+)

diff --git a/lib.c b/lib.c
index 0705775e5..f32fbda9f 100644
--- a/lib.c
+++ b/lib.c
@@ -763,6 +763,7 @@ static char **handle_switch_ftabstop(char *arg, char **next)
 static const struct mask_map dump_ir_options[] = {
 	{ "$default",		DUMP_IR_LINEARIZE },
 	{ "linearize",		DUMP_IR_LINEARIZE },
+	{ "mem2reg",		DUMP_IR_MEM2REG },
 	{ "only",		DUMP_IR_ONLY },
 	{ },
 };
diff --git a/lib.h b/lib.h
index a2fd04e67..30e097338 100644
--- a/lib.h
+++ b/lib.h
@@ -109,6 +109,7 @@ extern int has_error;
 
 #define	DUMP_IR_ONLY		(1 << 0)
 #define	DUMP_IR_LINEARIZE	(1 << 1)
+#define	DUMP_IR_MEM2REG		(1 << 2)
 #define	DUMP_IR_STOP(F,D)	(((F) & DUMP_IR_ONLY) && ((F) < ((D) << 1)))
 
 extern void add_pre_buffer(const char *fmt, ...) FORMAT_ATTR(1);
diff --git a/linearize.c b/linearize.c
index 2c49d29d9..8db4638bc 100644
--- a/linearize.c
+++ b/linearize.c
@@ -2278,6 +2278,11 @@ static struct entrypoint *linearize_fn(struct symbol *sym, struct symbol *base_t
 	 * Turn symbols into pseudos
 	 */
 	promote_symbols_usage(ep);
+	if (fdump_ir & DUMP_IR_MEM2REG) {
+		if (DUMP_IR_STOP(fdump_ir, DUMP_IR_MEM2REG))
+			return ep;
+		show_entry(ep);
+	}
 
 repeat:
 	/*
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC PATCH 48/48] mem2reg: don't promote unused or already promoted vars ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC PATCH 48/48] mem2reg: don't promote unused or already promoted vars
Date: Wed, 23 Aug 2017 20:15:54 +0000
Message-ID: <20170823201554.90551-49-luc.vanoostenryck () gmail ! com>
--------------------
---
 mem2reg.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/mem2reg.c b/mem2reg.c
index d31cd4121..490077d67 100644
--- a/mem2reg.c
+++ b/mem2reg.c
@@ -405,6 +405,10 @@ static void promote_symbol(struct entrypoint *ep, struct symbol *sym)
 	if (!pseudo)
 		return;
 
+	/* already converted ? */
+	if (!pseudo->users)
+		return;
+
 	mod = sym->ctype.modifiers;
 
 	/* We don't do coverage analysis of volatiles.. */
-- 
2.14.0

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] CSE: relax type checking in hashing/compare ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC] CSE: relax type checking in hashing/compare
Date: Fri, 17 Feb 2017 00:06:07 +0000
Message-ID: <20170217000608.6433-1-luc.vanoostenryck () gmail ! com>
--------------------
Currently in a function like here below the comparision is not
optimized away. This is because CSE doesn't recognize 'a = &g'
and 'b = &g' as being equivalent expressions.
	static int foo(void) {
		extern int g;
		void *a = &g;
		void *b = &g;
		return a == b;
	}

The problem come in fact from the implicit cast, more precisely, 
because the two '&g' generate their own symbol and thus have
distinct types.

I made a patch (see the second one in this non-serie) so that
cast from equivalent types hash identically. It worked well
but after a while I concluded that it was not really needed.
Indeed, in the context of CSE, to consider two instructions as
equivalent, the first thing that need to be equal is their source
operands. Isn't it already the case that if we use the same pseudo
in two instructions, the type of these pseudo in each instructions
must already be, if not identical, at least 'sufficently equivalent'?

I'm missing something?

If not, then the following simple patch should be correct.

Note: this patch give almost the same results as my original,
complex version. Both can eliminate quite a few casts (the
output of test-linearize on a subset of GCC's testsuite gives
a good 33K diff), both gives correct results for the case I've
checked and when using sparse on a kernel's allyesconfig run,
both give exactly the same warnings with ot without the patch).

Luc Van Oostenryck

---
 cse.c | 12 ------------
 1 file changed, 12 deletions(-)

diff --git a/cse.c b/cse.c
index 89812afae..d7f5de302 100644
--- a/cse.c
+++ b/cse.c
@@ -91,13 +91,6 @@ static void clean_up_one_instruction(struct basic_block *bb, struct instruction
 	case OP_CAST:
 	case OP_SCAST:
 	case OP_PTRCAST:
-		/*
-		 * This is crap! Many "orig_types" are the
-		 * same as far as casts go, we should generate
-		 * some kind of "type hash" that is identical
-		 * for identical casts
-		 */
-		hash += hashval(insn->orig_type);
 		hash += hashval(insn->src);
 		break;
 
@@ -235,11 +228,6 @@ static int insn_compare(const void *_i1, const void *_i2)
 	case OP_CAST:
 	case OP_SCAST:
 	case OP_PTRCAST:
-		/*
-		 * This is crap! See the comments on hashing.
-		 */
-		if (i1->orig_type != i2->orig_type)
-			return i1->orig_type < i2->orig_type ? -1 : 1;
 		if (i1->src != i2->src)
 			return i1->src < i2->src ? -1 : 1;
 		break;
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Mon, 27 Feb 2017 08:09:45 +0000
Message-ID: <CANeU7Qmo49EXqTs3EaMdgKMiii4VBYjEmef7P3AnjjPd2xTyKg () mail ! gmail ! com>
--------------------
On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> I made a patch (see the second one in this non-serie) so that
> cast from equivalent types hash identically. It worked well
> but after a while I concluded that it was not really needed.
> Indeed, in the context of CSE, to consider two instructions as
> equivalent, the first thing that need to be equal is their source
> operands. Isn't it already the case that if we use the same pseudo
> in two instructions, the type of these pseudo in each instructions
> must already be, if not identical, at least 'sufficently equivalent'?

I think so. I will apply this version to sparse-next.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Mon, 27 Feb 2017 08:11:44 +0000
Message-ID: <CANeU7Q=Uv0Xb=9PvpSdeoe4epMD0d5UTHED+xx2N7e7XmDkY9w () mail ! gmail ! com>
--------------------
On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> I'm missing something?
>
> If not, then the following simple patch should be correct.

This patch is missing a S-O-B. Can you add one?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Mon, 27 Feb 2017 09:40:13 +0000
Message-ID: <20170227094013.pevbixjonnebaaxa () macbook ! local>
--------------------
On Mon, Feb 27, 2017 at 04:11:44PM +0800, Christopher Li wrote:
> On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > I'm missing something?
> >
> > If not, then the following simple patch should be correct.
> 
> This patch is missing a S-O-B. Can you add one?

I did this purposely because it was a RFC.
Also:
- I still have some doubts about this patch
- It won't solve anything, only allow more CSE (but maybe more than
  really wanted)
- There is no urgency at all.

So I think it would be better to not include it in the coming release
and instead let it ripe a little bit.

But if you really prefer to include it, maybe not in a release but
in another branch, it's fine for me also.

    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Mon, 27 Feb 2017 09:40:13 +0000
Message-ID: <20170227094013.pevbixjonnebaaxa () macbook ! local>
--------------------
On Mon, Feb 27, 2017 at 04:11:44PM +0800, Christopher Li wrote:
> On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > I'm missing something?
> >
> > If not, then the following simple patch should be correct.
> 
> This patch is missing a S-O-B. Can you add one?

I did this purposely because it was a RFC.
Also:
- I still have some doubts about this patch
- It won't solve anything, only allow more CSE (but maybe more than
  really wanted)
- There is no urgency at all.

So I think it would be better to not include it in the coming release
and instead let it ripe a little bit.

But if you really prefer to include it, maybe not in a release but
in another branch, it's fine for me also.

    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Wed, 19 Apr 2017 00:32:25 +0000
Message-ID: <CANeU7QmbJTuZ5B_9V3ns7d67KZLcK229SGc2OWBdCcCLeZ6TqQ () mail ! gmail ! com>
--------------------
On Mon, Feb 27, 2017 at 1:40 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Mon, Feb 27, 2017 at 04:11:44PM +0800, Christopher Li wrote:
>> On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
>> <luc.vanoostenryck@gmail.com> wrote:
>> > I'm missing something?
>> >
>> > If not, then the following simple patch should be correct.
>>
>> This patch is missing a S-O-B. Can you add one?
>
> I did this purposely because it was a RFC.
> Also:
> - I still have some doubts about this patch
> - It won't solve anything, only allow more CSE (but maybe more than
>   really wanted)
> - There is no urgency at all.
>
> So I think it would be better to not include it in the coming release
> and instead let it ripe a little bit.

I am catching up with the patches in the order it was send out. I will
leave this
one alone then.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Wed, 19 Apr 2017 00:32:25 +0000
Message-ID: <CANeU7QmbJTuZ5B_9V3ns7d67KZLcK229SGc2OWBdCcCLeZ6TqQ () mail ! gmail ! com>
--------------------
On Mon, Feb 27, 2017 at 1:40 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Mon, Feb 27, 2017 at 04:11:44PM +0800, Christopher Li wrote:
>> On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
>> <luc.vanoostenryck@gmail.com> wrote:
>> > I'm missing something?
>> >
>> > If not, then the following simple patch should be correct.
>>
>> This patch is missing a S-O-B. Can you add one?
>
> I did this purposely because it was a RFC.
> Also:
> - I still have some doubts about this patch
> - It won't solve anything, only allow more CSE (but maybe more than
>   really wanted)
> - There is no urgency at all.
>
> So I think it would be better to not include it in the coming release
> and instead let it ripe a little bit.

I am catching up with the patches in the order it was send out. I will
leave this
one alone then.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Wed, 19 Apr 2017 16:32:54 +0000
Message-ID: <CAMHZB6EuT+FqKk7QU9LF6jTnOqbPeTTC+WkJuf21Mc_xE8Q1Rw () mail ! gmail ! com>
--------------------
On Wed, Apr 19, 2017 at 2:32 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Mon, Feb 27, 2017 at 1:40 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> On Mon, Feb 27, 2017 at 04:11:44PM +0800, Christopher Li wrote:
>>> On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
>>> <luc.vanoostenryck@gmail.com> wrote:
>>> > I'm missing something?
>>> >
>>> > If not, then the following simple patch should be correct.
>>>
>>> This patch is missing a S-O-B. Can you add one?
>>
>> I did this purposely because it was a RFC.
>> Also:
>> - I still have some doubts about this patch
>> - It won't solve anything, only allow more CSE (but maybe more than
>>   really wanted)
>> - There is no urgency at all.
>>
>> So I think it would be better to not include it in the coming release
>> and instead let it ripe a little bit.
>
> I am catching up with the patches in the order it was send out. I will
> leave this
> one alone then.
>
> Chris

Yes, please.
I'll return to it later when I'll have looked a bit more closed what
would be the impact.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] CSE: relax type checking in hashing/compare
Date: Wed, 19 Apr 2017 16:32:54 +0000
Message-ID: <CAMHZB6EuT+FqKk7QU9LF6jTnOqbPeTTC+WkJuf21Mc_xE8Q1Rw () mail ! gmail ! com>
--------------------
On Wed, Apr 19, 2017 at 2:32 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Mon, Feb 27, 2017 at 1:40 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> On Mon, Feb 27, 2017 at 04:11:44PM +0800, Christopher Li wrote:
>>> On Fri, Feb 17, 2017 at 8:06 AM, Luc Van Oostenryck
>>> <luc.vanoostenryck@gmail.com> wrote:
>>> > I'm missing something?
>>> >
>>> > If not, then the following simple patch should be correct.
>>>
>>> This patch is missing a S-O-B. Can you add one?
>>
>> I did this purposely because it was a RFC.
>> Also:
>> - I still have some doubts about this patch
>> - It won't solve anything, only allow more CSE (but maybe more than
>>   really wanted)
>> - There is no urgency at all.
>>
>> So I think it would be better to not include it in the coming release
>> and instead let it ripe a little bit.
>
> I am catching up with the patches in the order it was send out. I will
> leave this
> one alone then.
>
> Chris

Yes, please.
I'll return to it later when I'll have looked a bit more closed what
would be the impact.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] rationale for systematic elimination of OP_SYMADDR instructions ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Thu, 09 Mar 2017 14:20:44 +0000
Message-ID: <20170309142044.96408-1-luc.vanoostenryck () gmail ! com>
--------------------
While investigating some problems related to code generation
I realized that OP_SYMADDR are systematically eliminated,
the target address are simply replaced by the symbol itself.

While it's not wrong per se as it all depends to the semantic
we want to give to pseudos and the instructions and how high-
or low-level we want to IR, I don't think it was the intention
to remove them and more importantly I don't think it's desirable.

Those OP_SYMADDR allowed to make a clear separation between a symbol
(a name with a type and info for storage & linkage) and its address
(which can be stored in memory or in a register and on which
arithmetic operations can then be done on it). Once these addresses
are replaced by the symbol itself, those symbols can appears almost
everywhere in the linearized code:
- in calls' arguments,
- in adds and subs (while doing pointer arithmetic),
- in casts,
- in load & stores,
- ...
and they complicate things considerably once you begin to be
interested concretly in things after linearization & simplification
since soon or later you will need the address anyway.

So my question is:
	"is there a good reason to eliminate those instructions?",
and ultimately:
	"is there any objections to the following patch?".


-- Luc Van Oostenryck


---
diff --git a/simplify.c b/simplify.c
index 5d00937f1..a84e4787f 100644
--- a/simplify.c
+++ b/simplify.c
@@ -1159,7 +1159,7 @@ int simplify_instruction(struct instruction *insn)
 	case OP_SYMADDR:
 		if (dead_insn(insn, NULL, NULL, NULL))
 			return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
-		return replace_with_pseudo(insn, insn->symbol);
+		return 0;
 	case OP_CAST:
 	case OP_SCAST:
 	case OP_FPCAST:
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Tue, 25 Apr 2017 19:20:35 +0000
Message-ID: <CANeU7QkhQJrGifw5zvRoN27yVEfmU23B+HG5KQy3R9G3aKWUgw () mail ! gmail ! com>
--------------------
On Thu, Mar 9, 2017 at 10:20 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> While investigating some problems related to code generation
> I realized that OP_SYMADDR are systematically eliminated,
> the target address are simply replaced by the symbol itself.
>
> While it's not wrong per se as it all depends to the semantic
> we want to give to pseudos and the instructions and how high-
> or low-level we want to IR, I don't think it was the intention
> to remove them and more importantly I don't think it's desirable.
>
> Those OP_SYMADDR allowed to make a clear separation between a symbol
> (a name with a type and info for storage & linkage) and its address
> (which can be stored in memory or in a register and on which
> arithmetic operations can then be done on it). Once these addresses
> are replaced by the symbol itself, those symbols can appears almost
> everywhere in the linearized code:
> - in calls' arguments,
> - in adds and subs (while doing pointer arithmetic),
> - in casts,
> - in load & stores,
> - ...
> and they complicate things considerably once you begin to be
> interested concretly in things after linearization & simplification
> since soon or later you will need the address anyway.
>
> So my question is:
>         "is there a good reason to eliminate those instructions?",

This change is introduce in 962279e8 by Linus:

    Remove OP_SETVAL after symbol-pseudo simplification.

    We can just replace all users with the symbol pseudo
    directly.

    This means that we can no longer re-do symbol simplification
    after CSE, and we need to rely on the generic memop simplification.

I can see the reason to do that is simplify the CSE. Before this change,
every reference to the symbol will do a OP_SETVAL (or OP_SYMADDR now
days) to get the address into a new pseudo. That is extra work for the
CSE to discover that:  "Oh,  all those different pseudo are actually the same
address for the same symbol. Let's replace it with the same pseudo."

I haven't understand why things are more complicate after linearization
if we replace all the symbol pseudo into one? Even if we don't do it here,
wouldn't the CSE should do that any way?

The way I see it, the pseudo of the symbol *is* the address of the symbol,
I don't see a problem using the address of the symbol.

Maybe you have some specific usage case in mind. Can you give some
example?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Wed, 26 Apr 2017 02:49:02 +0000
Message-ID: <CAMHZB6EE93YSm0gVUr=dhNpsTZ1vU8acJ9msyh3VSdTOTVUq-w () mail ! gmail ! com>
--------------------
On Tue, Apr 25, 2017 at 9:20 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Thu, Mar 9, 2017 at 10:20 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> While investigating some problems related to code generation
>> I realized that OP_SYMADDR are systematically eliminated,
>> the target address are simply replaced by the symbol itself.
>>
>> While it's not wrong per se as it all depends to the semantic
>> we want to give to pseudos and the instructions and how high-
>> or low-level we want to IR, I don't think it was the intention
>> to remove them and more importantly I don't think it's desirable.
>>
>> Those OP_SYMADDR allowed to make a clear separation between a symbol
>> (a name with a type and info for storage & linkage) and its address
>> (which can be stored in memory or in a register and on which
>> arithmetic operations can then be done on it). Once these addresses
>> are replaced by the symbol itself, those symbols can appears almost
>> everywhere in the linearized code:
>> - in calls' arguments,
>> - in adds and subs (while doing pointer arithmetic),
>> - in casts,
>> - in load & stores,
>> - ...
>> and they complicate things considerably once you begin to be
>> interested concretly in things after linearization & simplification
>> since soon or later you will need the address anyway.
>>
>> So my question is:
>>         "is there a good reason to eliminate those instructions?",
>
> This change is introduce in 962279e8 by Linus:
>
>     Remove OP_SETVAL after symbol-pseudo simplification.
>
>     We can just replace all users with the symbol pseudo
>     directly.
>
>     This means that we can no longer re-do symbol simplification
>     after CSE, and we need to rely on the generic memop simplification.
>
> I can see the reason to do that is simplify the CSE. Before this change,
> every reference to the symbol will do a OP_SETVAL (or OP_SYMADDR now
> days) to get the address into a new pseudo. That is extra work for the
> CSE to discover that:  "Oh,  all those different pseudo are actually the same
> address for the same symbol. Let's replace it with the same pseudo."
>
> I haven't understand why things are more complicate after linearization
> if we replace all the symbol pseudo into one? Even if we don't do it here,
> wouldn't the CSE should do that any way?
>
> The way I see it, the pseudo of the symbol *is* the address of the symbol,
> I don't see a problem using the address of the symbol.
>
> Maybe you have some specific usage case in mind. Can you give some
> example?

Roughly, once you begin to play with code generation, something like
OP_SYMADDR is an operation that you will really do.
Depending on the relocation, it can even be something relatively costly:
I'm thinking static code on a 64bit machine where you can only generate
16bit constants, others cases may be not at all cheaper.
So it's something that soon or later will need to be exposed and
doing CSE on the address is good.
For example, with code as simple as
	extern int a;
	
	void foo(void)
	{
		a = a + 1;
	}

compiled for ARM with GCC:
	foo:
	        movw    r3, #:lower16:a
	        movt    r3, #:upper16:a
	        ldr     r2, [r3]
	        add     r2, r2, #1
	        str     r2, [r3]
	        bx      lr

The first 2 instructions correspond at taking the address of 'a',
it would be the very direct translation of sparse's:
	foo:
	.L0:
		<entry-point>
		symaddr     %r1
		load.32     %r2 <- 0[%r1]
		add.32      %r3 <- %r2, $1
		store.32    %r3 -> 0[%r1]
		ret

If we would have kept the OP_SYMADRR and doing CSE on it.
But for now we have:
	foo:
	.L0:
		<entry-point>
		load.32     %r2 <- 0[a]
		add.32      %r3 <- %r2, $1
		store.32    %r3 -> 0[a]
		ret

whose translation would be:
	        movw    r3, #:lower16:a
	        movt    r3, #:upper16:a
	        ldr     r2, [r3]
	        add     r2, r2, #1
!	        movw    r3, #:lower16:a
!	        movt    r3, #:upper16:a
	        str     r2, [r3]
	        bx      lr
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Wed, 26 Apr 2017 11:33:46 +0000
Message-ID: <CANeU7Q=zV+MAFOA6SzANEF9_7NB0rY719bzkesPnvUS9AqR+hw () mail ! gmail ! com>
--------------------
On Tue, Apr 25, 2017 at 10:49 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Roughly, once you begin to play with code generation, something like
> OP_SYMADDR is an operation that you will really do.
> Depending on the relocation, it can even be something relatively costly:
> I'm thinking static code on a 64bit machine where you can only generate
> 16bit constants, others cases may be not at all cheaper.
> So it's something that soon or later will need to be exposed and
> doing CSE on the address is good.

I see your point. Let me rephrase your claim. Sparse assume getting
the symbol address
is trivial. But on some architecture that is non trivial to generate
symbol address.
Typical case would be, the machine instruction size is smaller than
the address size.
It will take a few machine instruction to generate a symbol address.

I agree with this part.

Now the second part of the claim is that, it would be better to left
the OP_SYMADDR
untouched and let CSE to remove it. That part I disagree.

The reason is that, currently CSE operate on the same basic block. It only
eliminate instruction but it does not relocate instructions.

A very common case is that, the symbol address was referenced in different
basic blocks.

extern int a, d;

if (...)
     a = d;
else if (...)
     a = d + 2;

CSE would not be able to simply remove the OP_SYMADDR for "a",
because they are not in the same basic block. The best result should be,
for all the usage of that symbol in a function, find the closest
common parent basic
block and put the OP_SYMADDR there.

Because getting symbol address is used very often. Let CSE go through a hash
to re-discover that all symbol address can be combined is costly and
not necessary.
And CSE does not cover all the case commit 962279e8 covers.


> If we would have kept the OP_SYMADRR and doing CSE on it.
> But for now we have:
>         foo:
>         .L0:
>                 <entry-point>
>                 load.32     %r2 <- 0[a]
>                 add.32      %r3 <- %r2, $1
>                 store.32    %r3 -> 0[a]
>                 ret
>
> whose translation would be:
>                 movw    r3, #:lower16:a
>                 movt    r3, #:upper16:a
>                 ldr     r2, [r3]
>                 add     r2, r2, #1
> !               movw    r3, #:lower16:a
> !               movt    r3, #:upper16:a

That is because you assume every time "a" was referenced
you need to redo the generate of 32 bit address "a". That is
not necessary true. In sparse IR, "a" already translate into
pseudo, which has the user chain.  It is relative simple for
the back end to find the best place to insert OP_SYMADDR.
The end of the day, it is the back end knows the machine
register allocation and reorder of the instruction if necessary.

So the proper  solution shouldn't be let CSE to discover OP_SYMADDR
yet another time. It should be find the best place to insert OP_SYMADDR.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Wed, 26 Apr 2017 16:15:27 +0000
Message-ID: <CA+55aFxY_yMJxF2rLpBVYHPwNaWnvvXH-P0Ud1tYi8rE1g7tqg () mail ! gmail ! com>
--------------------
On Tue, Apr 25, 2017 at 7:49 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Roughly, once you begin to play with code generation, something like
> OP_SYMADDR is an operation that you will really do.
> Depending on the relocation, it can even be something relatively costly:
> I'm thinking static code on a 64bit machine where you can only generate
> 16bit constants, others cases may be not at all cheaper.
> So it's something that soon or later will need to be exposed and
> doing CSE on the address is good.

Ack. I think the OP_SYMADDR elimination was wrong, and your patch is
the right thing to do.

It was done to roughly approximate the 32-bit x86 code, making the
pseudo-asm that the linearizer outputs look more like x86 address
generation, but you're right, it's bogus.

                 Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Wed, 26 Apr 2017 21:02:21 +0000
Message-ID: <CANeU7Qk7czDA+RJzxyZHRa9zJdvv19s0NYExfDoW+34HmkB4dA () mail ! gmail ! com>
--------------------
On Wed, Apr 26, 2017 at 8:17 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Not especially. The case I showed is related to the ability for the machine
> to generate constants corresponding to an address size (like ARM here
> where instruction = addresses = 32bits but constants can only generated
> 16 bits at a time), this is a simple example you can find on static code.
> The exact same problematic is present on all architecture once you have
> less simple relocations (think -fpic, shared libraries and such).

OK. Points well taken.


>> The reason is that, currently CSE operate on the same basic block. It only
>> eliminate instruction but it does not relocate instructions.
>
> That's not true.
> The capability of CSE to move code around is limited, CSE
> doesn't only operate on the same BB. It relocates instructions in simple cases.
>
> And even if CSE would be limited to work on the same BB, it would
> already be beneficial.
>
>> A very common case is that, the symbol address was referenced in different
>> basic blocks.
>>
>> extern int a, d;
>>
>> if (...)
>>      a = d;
>> else if (...)
>>      a = d + 2;
>>
>> CSE would not be able to simply remove the OP_SYMADDR for "a",
>> because they are not in the same basic block. The best result should be,
>> for all the usage of that symbol in a function, find the closest
>> common parent basic
>> block and put the OP_SYMADDR there.
>
> I invite you to look at the output of:
>         extern int use(int);
>
>         int foo(int a)
>         {
>                 int r;
>
>                 if (a)
>                         r = a + 1;
>                 else {
>                         use(0);
>                         r = a + 1;
>                 }
>
>                 return r;
>         }

I take a look at the output:
foo:
.L0:
<entry-point>
add.32      %r3(r) <- %arg1, $1
cbr         %arg1, .L4, .L2

.L2:
call.32     %r4 <- use, $0
br          .L4

.L4:
ret.32      %r3(r)

So you are right, I am wrong about the CSE did not cross basic block
boundary.

>
> No, it's not the job of the backend to do this sort of things, nor
> is it "relatively simple". Why? because it's the exact same problem
> as CSE. If don't put this OP_SYMADDR in CSE here, you will
> need to reimplement something that is equivalent to CSE later at
> code generation, which is pretty stupid.

I notice Linus ACK the patch as well. I still have a question. Let me
ask this, may be a silly one.

Does the address of the symbol ever change inside a function?
I assume it does not change. If that is the case, can we skip the CSE
and replace all the symbol address reference to one OP_SYMADDR?

For example, for each symbol access in the function we insert OP_SYMADDR
after the entry:
foo:
<entry-point>
        %r1 <- a
        %r2 <- b
...

Then all reference of symbol address of "a" and "b" inside the function
foo will use %r1 and %r2.  Notice that we still keep the OP_SYMADDR
instruction, just move to function entry.

Is that illegal or bad?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Wed, 26 Apr 2017 23:02:43 +0000
Message-ID: <CAMHZB6EvJss-53X2oyXGHTRpAjDnoK8W5dCbng2tqUmjMykORA () mail ! gmail ! com>
--------------------
On Wed, Apr 26, 2017 at 11:02 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Wed, Apr 26, 2017 at 8:17 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> Not especially. The case I showed is related to the ability for the machine
>> to generate constants corresponding to an address size (like ARM here
>> where instruction = addresses = 32bits but constants can only generated
>> 16 bits at a time), this is a simple example you can find on static code.
>> The exact same problematic is present on all architecture once you have
>> less simple relocations (think -fpic, shared libraries and such).
>
> OK. Points well taken.
>
>
>>> The reason is that, currently CSE operate on the same basic block. It only
>>> eliminate instruction but it does not relocate instructions.
>>
>> That's not true.
>> The capability of CSE to move code around is limited, CSE
>> doesn't only operate on the same BB. It relocates instructions in simple cases.
>>
>> And even if CSE would be limited to work on the same BB, it would
>> already be beneficial.
>>
>>> A very common case is that, the symbol address was referenced in different
>>> basic blocks.
>>>
>>> extern int a, d;
>>>
>>> if (...)
>>>      a = d;
>>> else if (...)
>>>      a = d + 2;
>>>
>>> CSE would not be able to simply remove the OP_SYMADDR for "a",
>>> because they are not in the same basic block. The best result should be,
>>> for all the usage of that symbol in a function, find the closest
>>> common parent basic
>>> block and put the OP_SYMADDR there.
>>
>> I invite you to look at the output of:
>>         extern int use(int);
>>
>>         int foo(int a)
>>         {
>>                 int r;
>>
>>                 if (a)
>>                         r = a + 1;
>>                 else {
>>                         use(0);
>>                         r = a + 1;
>>                 }
>>
>>                 return r;
>>         }
>
> I take a look at the output:
> foo:
> .L0:
> <entry-point>
> add.32      %r3(r) <- %arg1, $1
> cbr         %arg1, .L4, .L2
>
> .L2:
> call.32     %r4 <- use, $0
> br          .L4
>
> .L4:
> ret.32      %r3(r)
>
> So you are right, I am wrong about the CSE did not cross basic block
> boundary.
>
>>
>> No, it's not the job of the backend to do this sort of things, nor
>> is it "relatively simple". Why? because it's the exact same problem
>> as CSE. If don't put this OP_SYMADDR in CSE here, you will
>> need to reimplement something that is equivalent to CSE later at
>> code generation, which is pretty stupid.
>
> I notice Linus ACK the patch as well. I still have a question. Let me
> ask this, may be a silly one.
>
> Does the address of the symbol ever change inside a function?
> I assume it does not change. If that is the case, can we skip the CSE
> and replace all the symbol address reference to one OP_SYMADDR?
>
> For example, for each symbol access in the function we insert OP_SYMADDR
> after the entry:
> foo:
> <entry-point>
>         %r1 <- a
>         %r2 <- b
> ...
>
> Then all reference of symbol address of "a" and "b" inside the function
> foo will use %r1 and %r2.  Notice that we still keep the OP_SYMADDR
> instruction, just move to function entry.
>
> Is that illegal or bad?

The address of a symbol will of course not change.
So yes, all the OP_SYMADDR could move to the top of the function.
It wouldn't be illegal and it could be advantageous in some cases.
It would be bad, though, if these addresses are in fact not used
(because of a conditional). I'm thinking to something like:
        if (unlikely(some cond)) a++;
Of course, doing so would also need a register to hold these addresses
so pre-calculated. What if the function access a lot of symbols?

In my opinion, we should handle these OP_SYMADDR just like
any other instructions (in other words: near where they are used).
And if one day, sparse will become smart enough to things like
'loop-invariant code motion' then these symbol addresses will
gain from it like any other calculated values will (but we're not yet there).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Wed, 26 Apr 2017 23:04:55 +0000
Message-ID: <CAMHZB6F95R_Kx6zB3wxfogtX8vjqDWzC0EwHH85_M-xryxqVdA () mail ! gmail ! com>
--------------------
On Wed, Apr 26, 2017 at 6:15 PM, Linus Torvalds
<torvalds@linux-foundation.org> wrote:

> Ack. I think the OP_SYMADDR elimination was wrong, and your patch is
> the right thing to do.
>
> It was done to roughly approximate the 32-bit x86 code, making the
> pseudo-asm that the linearizer outputs look more like x86 address
> generation, but you're right, it's bogus.

OK, thanks.
Now I just need to go hunt the regression I saw when I made and used
the patch. But that's another story.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Thu, 10 Aug 2017 15:01:22 +0000
Message-ID: <CANeU7QkJy-G4EXuJ94KBcmo3Bc0Pei0uQSTeYr-u4DxsSK==uQ () mail ! gmail ! com>
--------------------
On Wed, Apr 26, 2017 at 7:02 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>> Does the address of the symbol ever change inside a function?
>> I assume it does not change. If that is the case, can we skip the CSE
>> and replace all the symbol address reference to one OP_SYMADDR?
>>
>> For example, for each symbol access in the function we insert OP_SYMADDR
>> after the entry:
>> foo:
>> <entry-point>
>>         %r1 <- a
>>         %r2 <- b
>> ...
>>
>> Then all reference of symbol address of "a" and "b" inside the function
>> foo will use %r1 and %r2.  Notice that we still keep the OP_SYMADDR
>> instruction, just move to function entry.
>>
>> Is that illegal or bad?
>
> The address of a symbol will of course not change.
> So yes, all the OP_SYMADDR could move to the top of the function.
> It wouldn't be illegal and it could be advantageous in some cases.
> It would be bad, though, if these addresses are in fact not used
> (because of a conditional). I'm thinking to something like:
>         if (unlikely(some cond)) a++;
> Of course, doing so would also need a register to hold these addresses
> so pre-calculated. What if the function access a lot of symbols?

Sorry for reply to a very old email. Still catching up the my backlogs.

I think the function access a lot of symbols will need to have more
OP_SYMADDR, at least one instruction per symbol if you want to
have the OP_SYMADDR. You can't do better than that.


> In my opinion, we should handle these OP_SYMADDR just like
> any other instructions (in other words: near where they are used).

I think in the current IR, how close it is to be used is not a big issue.

If you want to get it close and have one OP_SYMADDR per symbol.
The OP_SYMADDR should be place at immediate D(N), where N is the
block that use the symbol. In other words, place the OP_SYMADDR
at where N blocks join in the dominator tree. You can't do better than
hat.

Please correct me if I am wrong.  I still think:
1)  OP_SYMADDR can be generated from the symbol node and where
     to place them (immediate D(N)).

2) If one of the back end needs them. Go ahead and generate OP_SYMADDR.
   However, I don't think sparse checker need to use the OP_SYMADDR
   so it will be more optimal  for sparse checker to avoid OP_SYMADDR.

   Am I missing some thing?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Thu, 10 Aug 2017 22:16:18 +0000
Message-ID: <CAExDi1QVzkOVRxe+mdsHEi4=wirRFKrO+UFRDH2498z43oZidw () mail ! gmail ! com>
--------------------
On Thu, Aug 10, 2017 at 5:01 PM, Christopher Li <sparse@chrisli.org> wrote:
>
> Please correct me if I am wrong.  I still think:
> 1)  OP_SYMADDR can be generated from the symbol node and where
>      to place them (immediate D(N)).
>
> 2) If one of the back end needs them. Go ahead and generate OP_SYMADDR.
>    However, I don't think sparse checker need to use the OP_SYMADDR
>    so it will be more optimal  for sparse checker to avoid OP_SYMADDR.
>
>    Am I missing some thing?

I'm not sure to understand exactly what you mean here above, sorry.
But yes, I think you're missing something.

All this have already been explained during the initial discussion but:
* those OP_SYMADDR represent the *calculation* that is needed to get
the address of a symbol.
* depending on the architecture, the kind/linkage/visibility of the symbol,
  compiler flag, ... this calculation can be very simple, like:
  - just a constant (but a big one)
  - just a load at a constant address & a constant address
  - or much more complicated
* the OP_SYMADDR *abstract* away the *details* of this calculation
   but it is important to expose it
* of the reasons we want to expose it is that we *want* to do CSE on
  these calculations
* there is absolutely no reasons why we should process them differently
  than any other instructions. In particular, it would be absurd to:
  - try to put all of them at the top
  - try to place them ourself at some other special place (common parent,
    dominator, ...)
  because CSE will place them automatically at the best place: as near as
  possible from where they are needed.
* it would also be a very bad idea to *not* generate them and only let the
  backend generate them because it would then mean that iether:
  - no CSE on them
  - backend need to reimplement CSE for them
  The backend, just need to *expose the details*, maybe change those
  SYMADDR in the appropriate loads & adds & loads or whatever but
  they need to be already there and processed by the middle-end.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] rationale for systematic elimination of OP_SYMADDR instructions
Date: Fri, 11 Aug 2017 01:17:44 +0000
Message-ID: <CANeU7Q=cN1z6bimq8aK_0KKxMwLvkBgA6A9r8xts67VHb2y7=w () mail ! gmail ! com>
--------------------
First of all, I want to clarify that I ask this question is
to satisfy my curiously why it is done this way,
either it is the best optimal way to do it.

It is not reason to reject your patch. I trust you have good
reason to do it, I will accept the patch even if I don't fully
understand it. I still want to understand it after applying
it.

On Thu, Aug 10, 2017 at 6:16 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> All this have already been explained during the initial discussion but:
> * those OP_SYMADDR represent the *calculation* that is needed to get
> the address of a symbol.

That is fine, nod.

> * depending on the architecture, the kind/linkage/visibility of the symbol,
>   compiler flag, ... this calculation can be very simple, like:
>   - just a constant (but a big one)
>   - just a load at a constant address & a constant address
>   - or much more complicated

Agree so far.

> * the OP_SYMADDR *abstract* away the *details* of this calculation
>    but it is important to expose it

OK. I have the question that sparse checker don't need it.
I will defer to later part of email to ask.

> * of the reasons we want to expose it is that we *want* to do CSE on
>   these calculations

Do CSE do you mean just CSE OP_SYMADDR or CSE the complicated
instruction expand from OP_SYMADDR.

Let say you have code like this, the symbol is assign in different
scope block.

Before CSE there is 3 OP_SYMADDR "a".  After CSE where is those 3
OP_SYMADDR "a" is likely to be combine into one? Where would the
CSE place the OP_SYMADDR if it is not one of the beginning or dominator
etc?


int a;
void fool (void)
{
                ...
               { a = 1 };
           ...
           {a = 2;}
                     ....
                     {a = 3};
}


> * there is absolutely no reasons why we should process them differently
>   than any other instructions. In particular, it would be absurd to:
>   - try to put all of them at the top
>   - try to place them ourself at some other special place (common parent,
>     dominator, ...)
>   because CSE will place them automatically at the best place: as near as
>   possible from where they are needed.

In that case, you might just place it before load or store. You don't seem
to need CSE to do it. Sorry I feel that I am still missing some big picture.
I am desperately trying to fill it.

I also think that you make the OP_SYMADDR a lower level IR than
what I original have in mind writing linearizer. I expect there is a separate
phase where you translate the sparse IR into machine level code, that
is where you can insert the equivalent of OP_SYMADDR. gcc also
have tree-ssa-sink.c which move the instruction closer to the place it is
used. So it is not sparse's IR's job to keep it close. For the same reason
sparse IR don't try to make the warm blocks close together etc. I consider
those are for the level level back end to do.

What I original have in mind is that, IR should contain all information for
back end to generate machine code. The IR should also be minimalism.
Which means that, if any information can be deduced from the IR, the IR don't
have to store them (as on disk byte code format). I am not saying we should
stay that way. I am just saying what I have in mind previously.

> * it would also be a very bad idea to *not* generate them and only let the
>   backend generate them because it would then mean that iether:
>   - no CSE on them
>   - backend need to reimplement CSE for them
>   The backend, just need to *expose the details*, maybe change those
>   SYMADDR in the appropriate loads & adds & loads or whatever but
>   they need to be already there and processed by the middle-end.

OK. For the sparse checker question. The sparse checker does not use
OP_SYMADDR, can it have a global option default to on. Sparse checker
before running any file, turn that option to off? I also feel it strange that
sparse checker don't need the OP_SYMADDR while we force it to see
OP_SYMADDR just to ignore it.

Right now we don't have a real compiler using sparse(yet). However the
checker is the most common usage case. I do want to squeeze any
bit of performance out of sparse checker. So having OP_SYMADDR
can perennially slowdown sparse while nobody is benefiting from it (yet).
It is not speeding up sparse isn't it?

Can we enable OP_SYMADDR when some back end actually start to
use it? That is actually the same as the global option thing. Who needs
OP_SYMADDR turn the option on. It is no extra step as a different pass.

We can still turn the option on for checker for testing purpose. Is that
acceptable to you?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [SPARSE] cast rework (was: Re: Interaction between bitfields and casts) ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: [SPARSE] cast rework (was: Re: Interaction between bitfields and casts)
Date: Sat, 25 Nov 2017 16:18:31 +0000
Message-ID: <20171125161825.64d4s27k57ep3psg () ltop ! local>
--------------------
On Wed, Aug 09, 2017 at 03:44:02PM -0700, Linus Torvalds wrote:
> On Wed, Aug 9, 2017 at 3:06 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > I have but I never posted it yet.
> > Basically, I have specialized them:
> > - TRUNC, ZEXT & SEXT: truncate (may be not neede), zero & sign extend
> > for integers
> 
> Makes sense.
> 
> And yes, I think we could skip TRUNC (casting to a smaller type is one
> of those questionable things we do now).
> 
> Our IR doesn't really have any well-defined form for upper bits anyway
> (ie there's no guarantee that values are zero-extended or
> sign-extended to the full register width in the IR), so "TRUNC"
> doesn't really have any sane semantics.
> 
> > - PTRU & UPTR: conversion pointer from/to unsigned integer (not sure
> > it's needed)
> 
> So this is a separate thing that doesn't take a size?
> 
> So a "int to ptr" conversion on a 64-bit architecture would be a
> combination of SEXT.64 and a UPTR?
> 
> If so, then yes, I think that's the right thing to do (and then in
> basically all cases the PTRU/UPTR just goes away).
> 
> Or, like TRUNC, just say that pointers simply *are* the same thing as
> an integer of the same size, and PTRU/UPTR just doesn't exist at all.
> 
> > - FCVTU & FCVTS: convert float to unsigned/signed integers
> > - UCVTF & SCVTF: convert int to float
> > - FCVTF: float to float convert (maybe even better/simpler with FTRUNC
> > & FEXT ?à)
> >
> > The main objective being to make things more explicit a avoid to have
> > to test the orig-type at each time.
> 
> Yes. I think what you describe is the right thing to do. The current
> casting is just wrong and nasty, and has too much implicit stuff.
> 
>                     Linus

I'm busy to test & polish the patch series corresponding to this and
I discovered an annoying oddball:
   Cast to an union (where the union contains a field of the same
   type as the source).
This is a GCC extension and unlike a normal cast it produces an l-value.
The kernel uses this a few times (at least once as an l-value).
It will need a bit work on sparse side to handle this.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: function designators & function pointers ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: function designators & function pointers
Date: Sun, 26 Nov 2017 21:58:13 +0000
Message-ID: <20171126215812.iswufpk3cssq2hdf () ltop ! local>
--------------------
I've found some problems with the linearization of
function calls and/or their evaluation.
But I would like first to be sure of what is wanted here.

The problems turn around the fact that in the C standards:
1) a function designator is usually implicitly converted to a
   function pointer (C11 6.3.2.1p4)
	"(except with 'sizeof' ...) a function designator with type
	 âfunction returning typeâ is converted to an expression
	  that has type âpointer to function returning typeâ".
2) for function calls (C11 6.5.2.2p1):
	"The expression that denotes the called function
	 (Most often, this is the result of converting an
	 identifier that is a function designator) shall have
	 type 'pointer to function returning ...'"
3) for the '*' operator and functions (C11 6.5.3.2p4):
	"If the operand points to a function, the result is a
	 function designator; ... If the operand has type
	 âpointer to typeâ, the result has type âtypeâ".


So, my understanding of the standard is that the following
function calls are all strictly equivalent (and GCC seems to agree):

	extern int foo(void);

	foo();
	(foo)();
	(*foo)();
	(**foo)();
	(***foo)();
	// and so on

Same for the following ones:
	extern int (*bar)(void);

	bar();
	(bar)();
	(*bar)();
	(**bar)();
	(***bar)();
	// and so on


On both cases we can add as much '*' as we want: each one produces
a function designator that is/should directly be re-converted to
a function pointer (and the function pointer is then used for the
cal in itself).

Currently, sparse doesn't like those 'unneeded dereferences'.
Do we want to accept them?
Do we want to warn on them (because they're really weird, unneeded
and thus maybe the sign of some errors)?

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: function designators & function pointers
Date: Mon, 27 Nov 2017 18:23:03 +0000
Message-ID: <CANeU7QkxM7q50J4k6gz3C6OD0xv7Rp1tacZCOWjku4O2FR4J-w () mail ! gmail ! com>
--------------------
On Mon, Nov 27, 2017 at 5:58 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Currently, sparse doesn't like those 'unneeded dereferences'.
> Do we want to accept them?

I think so. It is valid C after all.

> Do we want to warn on them (because they're really weird, unneeded
> and thus maybe the sign of some errors)?

Unneeded, yes.

Warning about it. I don't feel strongly either way. I guess we
can have a warning default to off.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: master merge plans ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: master merge plans
Date: Mon, 21 Aug 2017 19:39:12 +0000
Message-ID: <CANeU7Q=9nUo+D3R3ypCS=-kND2vD_Qx84ua59_bi0-VGftPuqA () mail ! gmail ! com>
--------------------
Here is the stuff I am considering:

1) gcc attribute update (trivial and safe to merge)
2) Makefile update to enable debug builds.
    This I want to merge first because it impact a lot of
    Makefile, other patches typically add some source file.
    Which is easy to resolve the conflict than the other way
    around.
    I will send out the update soon
3) Luc's SSSA
    Luc has sssa-mini-v2 now. Is that the latest on to be merged?
    I still want to have option to disable SSSA and option to enable
    old code path. That can be done after the merge though.

Any thing else I missed? Please let me know.


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: master merge plans
Date: Tue, 22 Aug 2017 13:32:00 +0000
Message-ID: <CAExDi1QryT9Hc6+yY0_E4Y6opsq3JiYo0KOidSDSj4VGD0J1Nw () mail ! gmail ! com>
--------------------
On Mon, Aug 21, 2017 at 9:39 PM, Christopher Li <sparse@chrisli.org> wrote:
> Here is the stuff I am considering:
>
> 3) Luc's SSSA
>     Luc has sssa-mini-v2 now. Is that the latest on to be merged?
>     I still want to have option to disable SSSA and option to enable
>     old code path. That can be done after the merge though.

I'm busy to make significant changes.
I'll resubmit everything in a few days.

> Any thing else I missed? Please let me know.

Nicolai's constexpr series.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: master merge plans
Date: Tue, 22 Aug 2017 14:47:08 +0000
Message-ID: <CANeU7QkQR6b936UR3VoYuzLGYdiOcTM=SaWtifsRNeF0rKhP+g () mail ! gmail ! com>
--------------------
On Tue, Aug 22, 2017 at 9:32 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Nicolai's constexpr series.
>

Is that constexpr-v4 branch on your git repository you want me to merge?

If you have a newer one, please post the git url.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: master merge plans
Date: Tue, 22 Aug 2017 14:59:54 +0000
Message-ID: <CANeU7QmekgnTBVF_7kZRAL-LB+g2W4MZbchxrApnQVeQk32wDw () mail ! gmail ! com>
--------------------
On Tue, Aug 22, 2017 at 10:53 AM, Dibyendu Majumdar
<mobile@majumdar.org.uk> wrote:
>>
>
> It will be great if the SSSA series is merged and tested a bit before
> merging other changes.

I can create a topic branch for SSSA on sparse repository.

Merge it when it is ready?

Right now I do wish the SSSA has the two options I request
before.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: master merge plans
Date: Tue, 22 Aug 2017 15:51:55 +0000
Message-ID: <CANeU7Qm+LOCG2B7HXBbwsvCLR7bipHTH6nnkXtN7ruR8pNW6bA () mail ! gmail ! com>
--------------------
On Tue, Aug 22, 2017 at 10:47 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Aug 22, 2017 at 9:32 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> Nicolai's constexpr series.
>>
>
> Is that constexpr-v4 branch on your git repository you want me to merge?

There might be a tiny bit slow down due to the constexpr. I will run more test
to see if I can ping point it. The last 3 group in each test was start by
a script. To be continue on this. The current number is not conclusive.

================ master merge constexpr-v4====================
1202.35user 446.83system 1:16.27elapsed 2162%CPU (0avgtext+0avgdata
238104maxresident)k
352inputs+12768outputs (0major+128889305minor)pagefaults 0swaps
1204.87user 447.25system 1:16.28elapsed 2165%CPU (0avgtext+0avgdata
238080maxresident)k
0inputs+12768outputs (0major+128888977minor)pagefaults 0swaps
1202.92user 447.03system 1:16.42elapsed 2158%CPU (0avgtext+0avgdata
238048maxresident)k
0inputs+12768outputs (0major+128888805minor)pagefaults 0swaps
1206.48user 446.75system 1:16.36elapsed 2164%CPU (0avgtext+0avgdata
238072maxresident)k
0inputs+12768outputs (0major+128888959minor)pagefaults 0swaps
1207.37user 447.35system 1:16.57elapsed 2161%CPU (0avgtext+0avgdata
238072maxresident)k
0inputs+12768outputs (0major+128888909minor)pagefaults 0swaps


1204.73user 446.87system 1:16.39elapsed 2161%CPU (0avgtext+0avgdata
238040maxresident)k
0inputs+12776outputs (0major+128889143minor)pagefaults 0swaps
1205.96user 447.91system 1:16.39elapsed 2164%CPU (0avgtext+0avgdata
238080maxresident)k
0inputs+12768outputs (0major+128889529minor)pagefaults 0swaps
1207.49user 448.00system 1:16.37elapsed 2167%CPU (0avgtext+0avgdata
238044maxresident)k
0inputs+12784outputs (0major+128888947minor)pagefaults 0swaps


================ rc5 =====================================
1201.56user 448.22system 1:16.24elapsed 2163%CPU (0avgtext+0avgdata
238048maxresident)k
0inputs+12768outputs (0major+128883583minor)pagefaults 0swaps
1203.27user 447.90system 1:16.22elapsed 2166%CPU (0avgtext+0avgdata
238036maxresident)k
0inputs+12768outputs (0major+128882925minor)pagefaults 0swaps
1201.65user 448.79system 1:16.20elapsed 2165%CPU (0avgtext+0avgdata
238044maxresident)k
0inputs+12768outputs (0major+128883529minor)pagefaults 0swaps

1202.19user 448.79system 1:16.24elapsed 2165%CPU (0avgtext+0avgdata
238192maxresident)k
0inputs+12768outputs (0major+128883477minor)pagefaults 0swaps
1203.38user 449.73system 1:16.33elapsed 2165%CPU (0avgtext+0avgdata
238044maxresident)k
0inputs+12776outputs (0major+128883089minor)pagefaults 0swaps
1203.37user 449.05system 1:16.23elapsed 2167%CPU (0avgtext+0avgdata
238080maxresident)k
0inputs+12768outputs (0major+128883199minor)pagefaults 0swaps

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: master merge plans
Date: Tue, 22 Aug 2017 20:05:27 +0000
Message-ID: <CAMHZB6Hiqca+zi5eX8jN_-v9nZ3Cv2DwkW9isjyOSuUdvEnf6Q () mail ! gmail ! com>
--------------------
On Tue, Aug 22, 2017 at 5:51 PM, Christopher Li <sparse@chrisli.org> wrote:
>>
>> Is that constexpr-v4 branch on your git repository you want me to merge?

Yes.

> There might be a tiny bit slow down due to the constexpr. I will run more test
> to see if I can ping point it. The last 3 group in each test was start by
> a script. To be continue on this. The current number is not conclusive.

At worse these numbers show something like 0.1-0.3%.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: master merge plans
Date: Wed, 23 Aug 2017 20:50:07 +0000
Message-ID: <CANeU7Qm-YdXmeA-rgYa1A+hPb=TEDgXhBJy3m9zJ1m_wP6EpOw () mail ! gmail ! com>
--------------------
On Tue, Aug 22, 2017 at 4:05 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> At worse these numbers show something like 0.1-0.3%.

I am doing some finial stage testing and reviewing the const expr patch.

I have find out that, my server actually do get affect by the CPU temperature.
So I turn off the Intel Turbo Stepping. Allow some rest between test.
Then I have finish write a script to do the testing per each commit.
I include the log in the email.

I can't narrow to one commit cause a big jump. No a reason to against
the patch. I am just interested to see that the measurement can catch
such change in numbers.

Chris

BTW, for testing purpose, I rebase against master. That is *not*
how I am going to merge it.


exp~0 17c0bae constexpr: flag __builtin_bswap() as constexpr

real 1m24.786s
user 20m18.346s
sys 7m24.193s

real 1m18.803s
user 20m55.562s
sys 7m36.994s

real 1m18.827s
user 20m55.731s
sys 7m36.688s

real 1m18.848s
user 20m57.298s
sys 7m35.525s

real 1m18.922s
user 20m56.519s
sys 7m36.264s
exp~1 58d888a give default return type in evaluate_call()

real 1m18.989s
user 20m59.896s
sys 7m35.895s

real 1m18.934s
user 20m58.567s
sys 7m36.808s

real 1m19.037s
user 20m58.249s
sys 7m37.441s

real 1m18.993s
user 20m59.233s
sys 7m36.422s

real 1m19.092s
user 20m58.818s
sys 7m37.009s
exp~2 ba12c3c return an error if too few args

real 1m18.984s
user 20m59.210s
sys 7m37.683s

real 1m18.993s
user 20m58.759s
sys 7m37.619s

real 1m19.133s
user 20m59.426s
sys 7m37.658s

real 1m19.067s
user 21m0.375s
sys 7m36.571s

real 1m19.040s
user 20m59.331s
sys 7m37.687s
exp~3 ace5869 constexpr: treat comparisons between types as integer constexpr

real 1m18.853s
user 20m57.653s
sys 7m37.073s

real 1m18.870s
user 20m56.782s
sys 7m38.441s

real 1m18.949s
user 20m56.683s
sys 7m37.473s

real 1m19.101s
user 20m57.496s
sys 7m37.183s

real 1m18.889s
user 20m57.439s
sys 7m37.235s
exp~4 82f78d2 constexpr: support compound literals as address constants

real 1m18.966s
user 20m56.740s
sys 7m37.477s

real 1m18.882s
user 20m55.245s
sys 7m38.047s

real 1m18.872s
user 20m56.149s
sys 7m37.610s

real 1m19.015s
user 20m54.708s
sys 7m38.447s

real 1m18.831s
user 20m55.296s
sys 7m37.978s
exp~5 df2d126 constexpr: relax some constant expression rules for
pointer expressions

real 1m18.831s
user 20m55.178s
sys 7m37.580s

real 1m18.802s
user 20m55.791s
sys 7m36.577s

real 1m18.920s
user 20m55.301s
sys 7m37.593s

real 1m18.801s
user 20m54.810s
sys 7m37.699s

real 1m18.814s
user 20m55.836s
sys 7m36.516s
exp~6 96f5c7e constexpr: flag builtins constant_p, safe_p and warning
as constexprs

real 1m19.001s
user 20m54.861s
sys 7m39.497s

real 1m18.894s
user 20m54.176s
sys 7m39.225s

real 1m18.955s
user 20m55.225s
sys 7m38.273s

real 1m18.837s
user 20m55.395s
sys 7m38.423s

real 1m19.038s
user 20m56.132s
sys 7m37.417s
exp~7 82ba05e constexpr: examine constness of __builtin_offsetof at
evaluation only

real 1m18.844s
user 20m52.640s
sys 7m38.045s

real 1m18.796s
user 20m52.641s
sys 7m38.324s

real 1m18.908s
user 20m53.584s
sys 7m37.451s

real 1m18.842s
user 20m52.688s
sys 7m38.812s

real 1m18.806s
user 20m53.336s
sys 7m37.414s
exp~8 f585495 constexpr: recognize references to labels as address constants

real 1m18.921s
user 20m53.766s
sys 7m37.205s

real 1m18.784s
user 20m53.527s
sys 7m37.331s

real 1m18.846s
user 20m54.222s
sys 7m36.130s

real 1m18.900s
user 20m53.766s
sys 7m36.899s

real 1m18.676s
user 20m53.485s
sys 7m37.334s
exp~9 c19757f constexpr: recognize string literals as address constants

real 1m19.184s
user 20m54.707s
sys 7m37.612s

real 1m18.782s
user 20m54.507s
sys 7m37.990s

real 1m18.830s
user 20m54.008s
sys 7m38.648s

real 1m18.984s
user 20m53.784s
sys 7m38.611s

real 1m18.770s
user 20m53.433s
sys 7m39.090s
exp~10 a1ba3b8 constexpr: recognize members of static compound objects
as address constants

real 1m19.012s
user 20m53.325s
sys 7m37.647s

real 1m18.815s
user 20m53.541s
sys 7m38.065s

real 1m18.716s
user 20m52.065s
sys 7m39.047s

real 1m18.762s
user 20m52.854s
sys 7m38.205s

real 1m18.867s
user 20m53.234s
sys 7m38.251s
exp~11 89f03a1 constexpr: recognize address constants created through
pointer arithmetic

real 1m18.891s
user 20m56.707s
sys 7m37.824s

real 1m18.944s
user 20m56.198s
sys 7m37.925s

real 1m18.980s
user 20m57.025s
sys 7m37.688s

real 1m18.861s
user 20m56.359s
sys 7m38.265s

real 1m18.927s
user 20m56.978s
sys 7m37.942s
exp~12 add9d6b constexpr: recognize address constants created through casts

real 1m18.827s
user 20m54.727s
sys 7m37.786s

real 1m18.823s
user 20m55.051s
sys 7m37.619s

real 1m18.840s
user 20m55.395s
sys 7m37.611s

real 1m18.828s
user 20m54.439s
sys 7m37.358s

real 1m18.996s
user 20m55.342s
sys 7m37.761s
exp~13 1c5d817 constexpr: recognize static objects as address constants

real 1m18.849s
user 20m55.353s
sys 7m37.570s

real 1m18.951s
user 20m55.800s
sys 7m36.969s

real 1m18.901s
user 20m56.035s
sys 7m37.285s

real 1m19.008s
user 20m54.143s
sys 7m38.469s

real 1m18.851s
user 20m54.583s
sys 7m38.325s
exp~14 5931437 constexpr: check static storage duration objects'
intializers' constness

real 1m18.963s
user 20m57.428s
sys 7m36.810s

real 1m18.992s
user 20m57.136s
sys 7m37.428s

real 1m18.990s
user 20m57.323s
sys 7m36.503s

real 1m18.889s
user 20m57.453s
sys 7m37.012s

real 1m18.916s
user 20m56.250s
sys 7m37.578s
exp~15 3d1f615 constexpr: collect storage modifiers of initializers

real 1m18.620s
user 20m50.093s
sys 7m38.680s

real 1m18.710s
user 20m52.010s
sys 7m37.180s

real 1m18.658s
user 20m51.324s
sys 7m37.858s

real 1m18.708s
user 20m50.750s
sys 7m38.064s

real 1m18.729s
user 20m50.268s
sys 7m38.261s
exp~16 c5b00b9 constexpr: rename handle_simple_initializer() to
handle_initializer()

real 1m18.762s
user 20m53.856s
sys 7m39.205s

real 1m19.032s
user 20m53.479s
sys 7m39.081s

real 1m18.952s
user 20m53.434s
sys 7m39.073s

real 1m18.841s
user 20m53.849s
sys 7m38.662s

real 1m18.876s
user 20m53.638s
sys 7m39.069s
exp~17 ce1284b constexpr: add support for tagging address constants

real 1m18.841s
user 20m53.490s
sys 7m38.805s

real 1m18.808s
user 20m53.957s
sys 7m39.191s

real 1m18.979s
user 20m54.010s
sys 7m38.661s

real 1m18.923s
user 20m53.627s
sys 7m39.547s

real 1m18.837s
user 20m54.008s
sys 7m38.673s
exp~18 ca44c48 constexpr: add support for tagging arithmetic constant
expressions

real 1m18.732s
user 20m52.681s
sys 7m37.328s

real 1m18.795s
user 20m52.313s
sys 7m37.950s

real 1m18.755s
user 20m52.972s
sys 7m37.638s

real 1m18.964s
user 20m52.372s
sys 7m38.090s

real 1m18.906s
user 20m52.971s
sys 7m37.603s
exp~19 1d14279 constexpr: examine constness of conditionals at evaluation only

real 1m18.778s
user 20m52.130s
sys 7m38.598s

real 1m18.781s
user 20m53.484s
sys 7m37.828s

real 1m18.917s
user 20m53.524s
sys 7m37.803s

real 1m18.855s
user 20m52.568s
sys 7m38.649s

real 1m18.880s
user 20m52.250s
sys 7m38.596s
exp~20 d032f28 constexpr: examine constness of preops at evaluation only

real 1m18.670s
user 20m52.232s
sys 7m37.297s

real 1m18.740s
user 20m51.975s
sys 7m37.008s

real 1m18.690s
user 20m51.828s
sys 7m37.761s

real 1m18.874s
user 20m50.968s
sys 7m38.967s

real 1m18.689s
user 20m51.353s
sys 7m37.997s
exp~21 2322e92 constexpr: examine constness of binops and alike at
evaluation only

real 1m18.848s
user 20m52.420s
sys 7m38.549s

real 1m18.964s
user 20m53.504s
sys 7m37.359s

real 1m18.687s
user 20m52.094s
sys 7m39.136s

real 1m18.730s
user 20m52.640s
sys 7m38.264s

real 1m18.738s
user 20m52.135s
sys 7m38.986s
exp~22 63db9df constexpr: examine constness of casts at evaluation only

real 1m18.931s
user 20m52.036s
sys 7m38.964s

real 1m18.781s
user 20m51.949s
sys 7m38.190s

real 1m18.822s
user 20m52.409s
sys 7m38.207s

real 1m18.819s
user 20m51.696s
sys 7m39.160s

real 1m18.939s
user 20m51.307s
sys 7m39.398s
exp~23 3a4d6eb constexpr: init flags at expression allocation

real 1m18.735s
user 20m51.678s
sys 7m37.659s

real 1m18.763s
user 20m51.829s
sys 7m37.649s

real 1m18.878s
user 20m51.538s
sys 7m37.923s

real 1m18.764s
user 20m51.689s
sys 7m37.561s

real 1m18.842s
user 20m50.505s
sys 7m38.146s
exp~24 6b1e4ad constexpr: introduce additional expression constness
tracking flags

real 1m18.821s
user 20m52.272s
sys 7m38.586s

real 1m18.829s
user 20m50.961s
sys 7m39.365s

real 1m18.821s
user 20m52.493s
sys 7m38.452s

real 1m18.850s
user 20m51.705s
sys 7m39.267s

real 1m18.923s
user 20m53.136s
sys 7m37.625s
exp~25 9151ef4 gcc attr: add nonstring warn_if_not_aligned

real 1m18.813s
user 20m51.490s
sys 7m38.610s

real 1m18.703s
user 20m50.492s
sys 7m38.937s

real 1m18.723s
user 20m50.613s
sys 7m38.524s

real 1m18.654s
user 20m52.010s
sys 7m37.222s

real 1m18.790s
user 20m51.441s
sys 7m38.248s
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: master merge plans
Date: Tue, 29 Aug 2017 11:27:51 +0000
Message-ID: <CANeU7Q=M9GWZzqXetXD6Ypj5s-6yv586VFwgsyLHuejcXK5YPw () mail ! gmail ! com>
--------------------
On Wed, Aug 23, 2017 at 4:50 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Aug 22, 2017 at 4:05 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> At worse these numbers show something like 0.1-0.3%.
>
> I am doing some finial stage testing and reviewing the const expr patch.
>

The context expression branch has been merge to master.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: master merge plans
Date: Sun, 03 Sep 2017 19:24:58 +0000
Message-ID: <CAExDi1SSADyF75NXW71WHKA7OVejpE3dOR7ugiEbLZETb8eRCw () mail ! gmail ! com>
--------------------
On Tue, Aug 29, 2017 at 1:27 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Wed, Aug 23, 2017 at 4:50 PM, Christopher Li <sparse@chrisli.org> wrote:
>> On Tue, Aug 22, 2017 at 4:05 PM, Luc Van Oostenryck
>> <luc.vanoostenryck@gmail.com> wrote:
>>>
>>> At worse these numbers show something like 0.1-0.3%.
>>
>> I am doing some finial stage testing and reviewing the const expr patch.
>>
>
> The context expression branch has been merge to master.

That's really great!
Thanks.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: ptrlist-iterator performance on one wine source file ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: ptrlist-iterator performance on one wine source file
Date: Thu, 27 Jul 2017 15:05:38 +0000
Message-ID: <CANeU7QkRxYFB41o9dTMp=n=epsNTZLr1ZsjowW=DigRiVNkPjg () mail ! gmail ! com>
--------------------
Hi Luc,

Per our discussion, here is some test you are interested.
It show some measurable difference in ptrlist-iterator vs the
base before the patch series.

Step to reproduce:

git clone git://source.winehq.org/git/wine.git
cd win/dlls/usp10/tests

The test command:

time sparse -m64 -c -o usp10.o usp10.c -I. -I../../../include
-D__WINESRC__ -D_REENTRANT -fPIC -Wall -pipe -fno-strict-aliasing
-Wdeclaration-after-statement -Wempty-body -Wignored-qualifiers
-Wshift-overflow=2 -Wstrict-prototypes -Wtype-limits
-Wunused-but-set-parameter -Wvla -Wwrite-strings -Wpointer-arith
-Wlogical-op -gdwarf-2 -gstrict-dwarf -g -O2

I run the test on ptrlist-iterator from the git url you send out.
Here is 3 runs each on ptrlist-iterator and the base line commit.

with ptrlist-iterator d55cac721a060882df02f40aab8824d210d9dc6f

real 0m25.764s
user 0m25.430s
sys 0m0.227s

real 0m25.746s
user 0m25.424s
sys 0m0.219s

real 0m25.800s
user 0m25.326s
sys 0m0.201s

with base(rc4) ec3f72e981792a86a9e002471a06d61ecd5c6675

real 0m23.625s
user 0m23.311s
sys 0m0.190s

real 0m23.489s
user 0m23.002s
sys 0m0.195s

real 0m23.321s
user 0m23.043s
sys 0m0.185s


Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 29 Jul 2017 13:01:18 +0000
Message-ID: <20170729130116.b5jd4rvkiwzgsfwt () ltop ! local>
--------------------
On Thu, Jul 27, 2017 at 11:05:38AM -0400, Christopher Li wrote:
> Hi Luc,
> 
> Per our discussion, here is some test you are interested.
> It show some measurable difference in ptrlist-iterator vs the
> base before the patch series.

Interesting.
My measurements showed much smaller differences (around 1-2%
and smaller than the stdev). But I also saw that this difference
was significantly bigger on older/less performant machines
(which is not very surprising).

Anyway, this series in itself won't solve the issues we
currently have with deletion in nested ptrlist walking loops.

Thanks for the numbers.
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 29 Jul 2017 15:53:28 +0000
Message-ID: <CANeU7QnGxae2dw_vU306nc+iUR2CuGczjDjp2fUYB5yPzye22w () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 9:01 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> Interesting.
> My measurements showed much smaller differences (around 1-2%
> and smaller than the stdev). But I also saw that this difference
> was significantly bigger on older/less performant machines
> (which is not very surprising).

I guess my laptop can qualify as older/less performance machines :-)

A wild guess is that the modern CPU are better doing caching and
branch predictions etcs. The iterator is doing a lot of memory store
and load from the iterator struct, and a lot of call to the interator advance
function.

The reason it show up more on this C file is that, sparse is doing a lot
of recursive find domanitor store etc. There are very deep level of nested
ptrlist loop here. The performance penalty on the inner loop will amplify
by the level of nested loop.

BTW, I am writing some code to construct the dominator tree for
basic blocks. I think it will be useful to avoid repeat finding dominator.
It will also help you finding the dominator frontier for the phi locations.

Another possible use is that, we can do incremental remove of dead
blocks without visiting all the blocks. We can just find out what other
blocks dominated by this dead block, mark them for delete and repeat.

Some materials for the next release.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 29 Jul 2017 16:04:46 +0000
Message-ID: <CAExDi1Tkws5eRO1APi6tOdhGTzvaCpuHQ8k9h+T7odD5Yx3W3Q () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 5:53 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Sat, Jul 29, 2017 at 9:01 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> Interesting.
>> My measurements showed much smaller differences (around 1-2%
>> and smaller than the stdev). But I also saw that this difference
>> was significantly bigger on older/less performant machines
>> (which is not very surprising).
>
> I guess my laptop can qualify as older/less performance machines :-)

Hehe, maybe :)

> A wild guess is that the modern CPU are better doing caching and
> branch predictions etcs.

Indeed.

> BTW, I am writing some code to construct the dominator tree for
> basic blocks. I think it will be useful to avoid repeat finding dominator.
> It will also help you finding the dominator frontier for the phi locations.

I don't need it but it's indeed something that is generally needed.

> Another possible use is that, we can do incremental remove of dead
> blocks without visiting all the blocks.

You can't do that once cycles are involved. You need something
like the marking algorithm used by kill_unreachable_bbs() for that.
And it was such a  cycle that created the problem with the false
"crazy programmer" warning.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 29 Jul 2017 16:25:40 +0000
Message-ID: <CANeU7QnHbCmpTmD7ckokE7XezHB6-ZAFzX-h+J8cPe=wWxx3VA () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 12:04 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> You can't do that once cycles are involved. You need something
> like the marking algorithm used by kill_unreachable_bbs() for that.
> And it was such a  cycle that created the problem with the false
> "crazy programmer" warning.

No I don't think so. The find dominator already taking the cycles into
account. By definition if X dominate Y, means every execution flow
from entry point to Y will need to go through X. If X was not reachable,
nor does Y. It does not change where the block get deleted. It just don't
not need to do the marking algorithm. That is the point of dominator tree.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 29 Jul 2017 16:30:16 +0000
Message-ID: <CANeU7Q=gAZ9hQ8AGNkhZ8d_=kL5i9QdPsS_980dq+WHsOVW-oQ () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 12:25 PM, Christopher Li <sparse@chrisli.org> wrote:
> No I don't think so. The find dominator already taking the cycles into
> account. By definition if X dominate Y, means every execution flow
> from entry point to Y will need to go through X. If X was not reachable,
> nor does Y. It does not change where the block get deleted. It just don't
> not need to do the marking algorithm. That is the point of dominator tree.

Hold on I think I make a mistake there. You are right. It only work if
we already know
that block is dead. If there is cycles that block has incoming edges. Let's
me think about it. There should be better way to detect that is back edge.

Thinking.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 29 Jul 2017 19:33:03 +0000
Message-ID: <CANeU7QnRQG84w+e-gTjp2yOZYdwq+itgExg_UTG-zUuRT8FYLg () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 12:35 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>>> You can't do that once cycles are involved. You need something
>>> like the marking algorithm used by kill_unreachable_bbs() for that.
>>> And it was such a  cycle that created the problem with the false
>>> "crazy programmer" warning.
>>
>> No I don't think so. The find dominator already taking the cycles into
>> account. By definition if X dominate Y, means every execution flow
>> from entry point to Y will need to go through X. If X was not reachable,
>> nor does Y. It does not change where the block get deleted. It just don't
>> not need to do the marking algorithm. That is the point of dominator tree.
>
> OK, I misread and misunderstood that you was talking about  the
> dominator *tree*.

I was confused after your misunderstood as well. Well for a few minutes.
The dominator tree does not have back edges. So if the edge on CFG
we are removing is matching the edge on dominator tree. In other words,
we are removing an edge from the dominator tree,  the whole branch
of that tree can be removed as dead code.

> The real problem with such a tree is that you need to maintain it as
> it potentially changes each time there is a change in the CFG.

Right. So far most of the case is removing edges and blocks. That should
be relative trivial to update the dominator tree. I haven't try it so we will
see.

Do we have a case actually *add* edge or block to the CFG?
I don't recall one.

> And of course, building this tree is not linear (in the number of BBs)
> while finding the dead BBs is linear.
Find one round of dead BBs is linear, N number of BBs. Right now we
mark and sweep the CFG for every node removed, total of M dead nodes.
Then the total is M*N.

In the memops finding dominating store is doing a lot worse. That is
why gcc complete that file almost instantly. Sparse takes 30 seconds
on my machine. One big problem is it did not cache the dominating
result. It is redoing the finding again and again.

The algorithm I am using is this one:

Cooper, Keith D.; Harvey, Timothy J.; and Kennedy, Ken (2001).
A Simple, Fast Dominance Algorithm
https://www.cs.rice.edu/~keith/EMBED/dom.pdf

It is O(N^2), in practice it is faster than  Lengauer and Tarjan
which is O(E *log(N)).

Most of the sparse source code I try converge within 3 rounds.
For practical purpose it feels like linear.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 29 Jul 2017 21:47:57 +0000
Message-ID: <CAMHZB6E8PwoeofUFRB_zdVx=HqqHM72UhcqwH1QPDa_U+4V-DQ () mail ! gmail ! com>
--------------------
On Sat, Jul 29, 2017 at 9:33 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Sat, Jul 29, 2017 at 12:35 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>>> You can't do that once cycles are involved. You need something
>>>> like the marking algorithm used by kill_unreachable_bbs() for that.
>>>> And it was such a  cycle that created the problem with the false
>>>> "crazy programmer" warning.
>>>
>>> No I don't think so. The find dominator already taking the cycles into
>>> account. By definition if X dominate Y, means every execution flow
>>> from entry point to Y will need to go through X. If X was not reachable,
>>> nor does Y. It does not change where the block get deleted. It just don't
>>> not need to do the marking algorithm. That is the point of dominator tree.
>>
>> OK, I misread and misunderstood that you was talking about  the
>> dominator *tree*.
>
> I was confused after your misunderstood as well. Well for a few minutes.
> The dominator tree does not have back edges. So if the edge on CFG
> we are removing is matching the edge on dominator tree. In other words,
> we are removing an edge from the dominator tree,  the whole branch
> of that tree can be removed as dead code.

Mmmm, interesting.

>> The real problem with such a tree is that you need to maintain it as
>> it potentially changes each time there is a change in the CFG.
>
> Right. So far most of the case is removing edges and blocks. That should
> be relative trivial to update the dominator tree. I haven't try it so we will
> see.
>
> Do we have a case actually *add* edge or block to the CFG?
> I don't recall one.

We do, more or less.
Once the code is linearized and inlining is done we:
- never add new BBs
- remove some BBs (some removing edges from the CFG)
- do several kinds of branch simplification (that's moving
  edge, so technically it's adding edge to the CFG, not sure it
  change the dom tree though).

>> And of course, building this tree is not linear (in the number of BBs)
>> while finding the dead BBs is linear.
> Find one round of dead BBs is linear, N number of BBs. Right now we
> mark and sweep the CFG for every node removed, total of M dead nodes.
> Then the total is M*N.

Yes, but this calculation is not correct at all.
- each time a node is removed, the total number of nodes is smaller
  and so the next time is a bit faster (this would correspond to a factor
  of 2)
- much more importantly, each time kill_unreachable_bbs() is called
  *all* the currently dead BBs are removed at once. So single call
  can kill several BBs. Of course, it will be different for each CFG/input
  files.

> In the memops finding dominating store is doing a lot worse. That is
> why gcc complete that file almost instantly. Sparse takes 30 seconds
> on my machine. One big problem is it did not cache the dominating
> result. It is redoing the finding again and again.

Uh?
Which input file your talking about?

BTW, two months ago or so, I posted a sort of mini-report about
quadratic behaviour with the current code. This quadratic behaviour
doesn't exist with the series I have for the misplaced phi-nodes.

> The algorithm I am using is this one:
>
> Cooper, Keith D.; Harvey, Timothy J.; and Kennedy, Ken (2001).
> A Simple, Fast Dominance Algorithm
> https://www.cs.rice.edu/~keith/EMBED/dom.pdf
>
> It is O(N^2), in practice it is faster than  Lengauer and Tarjan
> which is O(E *log(N)).
>
> Most of the sparse source code I try converge within 3 rounds.
> For practical purpose it feels like linear.

*smile* Feels like linear?
Did you try with several input files, some with big functions?

> Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sun, 30 Jul 2017 15:12:55 +0000
Message-ID: <20170730151254.xlnz7c4zphhnhump () ltop ! local>
--------------------
On Sun, Jul 30, 2017 at 12:15:40AM -0400, Christopher Li wrote:
> On Sat, Jul 29, 2017 at 5:47 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > We do, more or less.
> > Once the code is linearized and inlining is done we:
> > - never add new BBs
> > - remove some BBs (some removing edges from the CFG)
> > - do several kinds of branch simplification (that's moving
> >   edge, so technically it's adding edge to the CFG, not sure it
> >   change the dom tree though).
> >
> That is merging nodes right? Two nodes combine as one.

I was more thinking to things like done in try_to_simplify_bb().

> Moving block to another place is another story.
> >
> > Yes, but this calculation is not correct at all.
> > - each time a node is removed, the total number of nodes is smaller
> >   and so the next time is a bit faster (this would correspond to a factor
> >   of 2)
> 
> if N >> M then it does not matter much.

Indeed. 

> > - much more importantly, each time kill_unreachable_bbs() is called
> >   *all* the currently dead BBs are removed at once. So single call
> >   can kill several BBs. Of course, it will be different for each CFG/input
> >   files.
> 
> Yes, that would be linear to the number of blocks removed. It still
> need to go through the blocks to clean up the instructions usage etc.

Yes, but that's totally independent of how and how often the detection
of dead code is done. At the end, every dead instructions will need
to be cleaned up (the minimum is removing pseudo usage).

> >> In the memops finding dominating store is doing a lot worse. That is
> >> why gcc complete that file almost instantly. Sparse takes 30 seconds
> >> on my machine. One big problem is it did not cache the dominating
> >> result. It is redoing the finding again and again.
> 
> > Uh?
> > Which input file your talking about?
> 
> This ptrlist testing wine source file that takes  23 second for sparse to run.
> I take a brief look at it, it is doing a lot of dominating search.

Is it possible to have a pathname or a link?

> > *smile* Feels like linear?
> > Did you try with several input files, some with big functions?
> I just try some sparse source file. The largest one is in parse.c.

It's not the size of the file that matter here, it's the size
(and complexity) of the function(s).

> The paper has more detail report on using huge number of nodes.
> Tested on real code and random generated CFG for really large
> number of nodes. I am not going repeat it here.

No, I know about this paper.

> BTW, I just find out LLVM was using the exact same algorithm at
> some point. Not sue what they are using now. They might not build
> the whole tree any more.

It's possible, indeed.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sun, 30 Jul 2017 15:49:16 +0000
Message-ID: <CANeU7Q=5SycRKw4Z1NXHPuza_UbUjSF=E9wy6Ko6UEzSHPO2ng () mail ! gmail ! com>
--------------------
On Sun, Jul 30, 2017 at 11:12 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Sun, Jul 30, 2017 at 12:15:40AM -0400, Christopher Li wrote:
>> On Sat, Jul 29, 2017 at 5:47 PM, Luc Van Oostenryck
>> <luc.vanoostenryck@gmail.com> wrote:
>> >
>> > We do, more or less.
>> > Once the code is linearized and inlining is done we:
>> > - never add new BBs
>> > - remove some BBs (some removing edges from the CFG)
>> > - do several kinds of branch simplification (that's moving
>> >   edge, so technically it's adding edge to the CFG, not sure it
>> >   change the dom tree though).
>> >
>> That is merging nodes right? Two nodes combine as one.
>
> I was more thinking to things like done in try_to_simplify_bb().
>
>> Moving block to another place is another story.
>> >
>> > Yes, but this calculation is not correct at all.
>> > - each time a node is removed, the total number of nodes is smaller
>> >   and so the next time is a bit faster (this would correspond to a factor
>> >   of 2)
>>
>> if N >> M then it does not matter much.
>
> Indeed.
>
>> > - much more importantly, each time kill_unreachable_bbs() is called
>> >   *all* the currently dead BBs are removed at once. So single call
>> >   can kill several BBs. Of course, it will be different for each CFG/input
>> >   files.
>>
>> Yes, that would be linear to the number of blocks removed. It still
>> need to go through the blocks to clean up the instructions usage etc.
>
> Yes, but that's totally independent of how and how often the detection
> of dead code is done. At the end, every dead instructions will need
> to be cleaned up (the minimum is removing pseudo usage).
>
>> >> In the memops finding dominating store is doing a lot worse. That is
>> >> why gcc complete that file almost instantly. Sparse takes 30 seconds
>> >> on my machine. One big problem is it did not cache the dominating
>> >> result. It is redoing the finding again and again.
>>
>> > Uh?
>> > Which input file your talking about?
>>
>> This ptrlist testing wine source file that takes  23 second for sparse to run.
>> I take a brief look at it, it is doing a lot of dominating search.
>
> Is it possible to have a pathname or a link?

It is the very first email I send out:


git clone git://source.winehq.org/git/wine.git
cd win/dlls/usp10/tests

The test command:

time sparse -m64 -c -o usp10.o usp10.c -I. -I../../../include
-D__WINESRC__ -D_REENTRANT -fPIC -Wall -pipe -fno-strict-aliasing
-Wdeclaration-after-statement -Wempty-body -Wignored-qualifiers
-Wshift-overflow=2 -Wstrict-prototypes -Wtype-limits
-Wunused-but-set-parameter -Wvla -Wwrite-strings -Wpointer-arith
-Wlogical-op -gdwarf-2 -gstrict-dwarf -g -O2

I think gcc compile this file very fast but sparse spend a lot of time
on it. My impression it is spending time repeat finding dominating
stores. I did not look at it very deep, but I know sparse did not cache
any dominating information. It do fresh search every time.

> It's not the size of the file that matter here, it's the size
> (and complexity) of the function(s).

Yes, mean the complexity of the functions. How many blocks.
My impression parse.c has the largest one I saw so far. I have't
done it very scientifically. Other file all have relatively small functions.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sun, 30 Jul 2017 16:16:03 +0000
Message-ID: <CAMHZB6Emib_U7AtDLZ5Wc6KGXtZzMwhbT-N+sk-B05PUVbtfNg () mail ! gmail ! com>
--------------------
On Sun, Jul 30, 2017 at 5:49 PM, Christopher Li <sparse@chrisli.org> wrote:

>>> >> In the memops finding dominating store is doing a lot worse. That is
>>> >> why gcc complete that file almost instantly. Sparse takes 30 seconds
>>> >> on my machine. One big problem is it did not cache the dominating
>>> >> result. It is redoing the finding again and again.
>>>
>>> > Uh?
>>> > Which input file your talking about?
>>>
>>> This ptrlist testing wine source file that takes  23 second for sparse to run.
>>> I take a brief look at it, it is doing a lot of dominating search.
>>
>> Is it possible to have a pathname or a link?
>
> It is the very first email I send out:
>
>
> git clone git://source.winehq.org/git/wine.git
> cd win/dlls/usp10/tests
>
> The test command:
>
> time sparse -m64 -c -o usp10.o usp10.c -I. -I../../../include
> -D__WINESRC__ -D_REENTRANT -fPIC -Wall -pipe -fno-strict-aliasing
> -Wdeclaration-after-statement -Wempty-body -Wignored-qualifiers
> -Wshift-overflow=2 -Wstrict-prototypes -Wtype-limits
> -Wunused-but-set-parameter -Wvla -Wwrite-strings -Wpointer-arith
> -Wlogical-op -gdwarf-2 -gstrict-dwarf -g -O2

OK, thanks. I'll take a look once the infinite loop problem will be closed.

> I think gcc compile this file very fast but sparse spend a lot of time on it.

Interesting.
On most input sparse is much faster than gcc, often by a factor or 10
or even more. But of course, if there is a problem with sparse ...

> My impression it is spending time repeat finding dominating stores.
Possible indeed.
> I did not look at it very deep, but I know sparse did not cache
> any dominating information. It do fresh search every time.

Yes. It's even done for each instruction to CSE (but most of the
time it's not much costly, still looking after a few parents though).

>> It's not the size of the file that matter here, it's the size
>> (and complexity) of the function(s).
>
> Yes, mean the complexity of the functions. How many blocks.
> My impression parse.c has the largest one I saw so far. I have't
> done it very scientifically. Other file all have relatively small functions.

I really don't think sparse has any function large enough to worry after
non-linearity (you would need at least a few hundred BBs).
IMO, the thing to look at/worry about is the constant factor.

> Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Tue, 01 Aug 2017 21:09:12 +0000
Message-ID: <CANeU7QkShNBJ2nWh0wvTN3fTvwX710BT-g=aFf+GS1upnD_Gxw () mail ! gmail ! com>
--------------------
--94eb2c13eaa63ad17e0555b78f66
Content-Type: text/plain; charset="UTF-8"

On Tue, Aug 1, 2017 at 4:33 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> When I try the command you gave with -rc4 sparse I get:
>         real    0m3.281s
>         user    0m3.175s
>         sys     0m0.097s
> wich is very far from the 23-30s you got. Dunno what the difference could be.

Did you run it with all the parameter?

If I just run the sort version:

time sparse -m64 -c -o usp10.o usp10.c -I. -I../../../include
-D__WINESRC__ -D_REENTRANT

It is:
real 0m4.532s
user 0m4.436s
sys 0m0.075s

But if I run with all parameter.

sh -x slow.sh

+ sparse -m64 -c -o usp10.o usp10.c -I. -I../../../include
-D__WINESRC__ -D_REENTRANT -fPIC -Wall -pipe -fno-strict-aliasing
-Wdeclaration-after-statement -Wempty-body -Wignored-qualifiers
-Wshift-overflow=2 -Wstrict-prototypes -Wtype-limits
-Wunused-but-set-parameter -Wvla -Wwrite-strings -Wpointer-arith
-Wlogical-op -gdwarf-2 -gstrict-dwarf -g -O2
/usr/include/sys/sysmacros.h:79:1: warning: constant
0xfffff00000000000u is so big it is unsigned long
/usr/include/sys/sysmacros.h:80:1: warning: constant
0x00000ffffff00000u is so big it is unsigned long
...

real 0m24.771s
user 0m24.447s
sys 0m0.213s

Again, I haven't dig very deep with this yet. Might be a bug some where indeed.

Chris

--94eb2c13eaa63ad17e0555b78f66
Content-Type: application/x-sh; name="slow.sh"
Content-Disposition: attachment; filename="slow.sh"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_j5u2pkp40

dGltZSBzcGFyc2UgLW02NCAtYyAtbyB1c3AxMC5vIHVzcDEwLmMgLUkuIC1JLi4vLi4vLi4vaW5j
bHVkZSAtRF9fV0lORVNSQ19fIC1EX1JFRU5UUkFOVCAtZlBJQyAtV2FsbCAtcGlwZSAtZm5vLXN0
cmljdC1hbGlhc2luZyAtV2RlY2xhcmF0aW9uLWFmdGVyLXN0YXRlbWVudCAtV2VtcHR5LWJvZHkg
LVdpZ25vcmVkLXF1YWxpZmllcnMgLVdzaGlmdC1vdmVyZmxvdz0yIC1Xc3RyaWN0LXByb3RvdHlw
ZXMgLVd0eXBlLWxpbWl0cyAtV3VudXNlZC1idXQtc2V0LXBhcmFtZXRlciAtV3ZsYSAtV3dyaXRl
LXN0cmluZ3MgLVdwb2ludGVyLWFyaXRoIC1XbG9naWNhbC1vcCAtZ2R3YXJmLTIgLWdzdHJpY3Qt
ZHdhcmYgLWcgLU8yCg==
--94eb2c13eaa63ad17e0555b78f66--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Tue, 01 Aug 2017 23:37:15 +0000
Message-ID: <CANeU7Qmxc6GR9wReqa-K0YwKXwX1qAxy8A7MMe+G3BxD-at6ZQ () mail ! gmail ! com>
--------------------
On Tue, Aug 1, 2017 at 5:46 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> Here, both give essentially the same time.
> Which is quite normal as none of the 'additional' options
> should make any difference in how sparse is processing
> things: it's just some more flags for warnings and none of
> -fPIC -pipe -fno-strict-aliasing -gdwarf-2 -gstrict-dwarf -g
> has any effects for sparse and the only effect of -O2 is
> to define __OPTIMIZE__.

So you can't reproduce it. Let me dig deeper to see what is going on.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Wed, 02 Aug 2017 22:50:20 +0000
Message-ID: <CAMHZB6E0NYy_bNJftB5n4BFZ4-fNf___n0RN1OPb+jkV4Ry-Dw () mail ! gmail ! com>
--------------------
On Wed, Aug 2, 2017 at 3:17 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Aug 1, 2017 at 5:46 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> has any effects for sparse and the only effect of -O2 is
>> to define __OPTIMIZE__.
>
> Yes, indeed. It is the -O2 make the difference.
>
> I recently upgrade to Fedora 26. I think it is the system header file
> making a difference
> on the __OPTIMIZE__. I attach two files here. O2.c is the one with -O2 flag
> after processor. The 0.c is the one without.
>
> There is huge difference in them.
>
> I confirm with O2.c I am seeing the 24 second delay. And 0.c 4 seconds.
>
> I attach the two files with gzip.

It seems that the email was rejected on the mailing list.

> I think you should be able to reproduce it with O2.c now.

Yes, I can reproduce it now.
The differences in the two file are not big. Basically, in -O2 there is
- a bunch of small functions which have now an inline definition
- a set of strcmp(winetest_platform, "wine") which are replaced
  by a macro of hell.
It's, of course, the last one which creates the problem.
The macro seems to try to optimize the compare using the fact
that the compiler will statically evaluate things like:
- strlen("wine")
- "wine"[0], "wine"[1], ...
but sparse doesn't do this kind of simplification (yet) and this result
in much much more code.

A first inspection of the generated code doesn't show anything
obviously wrong but I don't exclude there is another problem.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Thu, 03 Aug 2017 21:49:08 +0000
Message-ID: <20170803214906.dvvyibtf53j3ah6m () ltop ! local>
--------------------
On Thu, Aug 03, 2017 at 12:50:20AM +0200, Luc Van Oostenryck wrote:
> On Wed, Aug 2, 2017 at 3:17 AM, Christopher Li <sparse@chrisli.org> wrote:
> > On Tue, Aug 1, 2017 at 5:46 PM, Luc Van Oostenryck
> > <luc.vanoostenryck@gmail.com> wrote:
> >> has any effects for sparse and the only effect of -O2 is
> >> to define __OPTIMIZE__.
> >
> > Yes, indeed. It is the -O2 make the difference.
> >
> > I recently upgrade to Fedora 26. I think it is the system header file
> > making a difference
> > on the __OPTIMIZE__. I attach two files here. O2.c is the one with -O2 flag
> > after processor. The 0.c is the one without.
> >
> > There is huge difference in them.
> >
> > I confirm with O2.c I am seeing the 24 second delay. And 0.c 4 seconds.
> >
> > I attach the two files with gzip.
> 
> It seems that the email was rejected on the mailing list.
> 
> > I think you should be able to reproduce it with O2.c now.
> 
> Yes, I can reproduce it now.
> The differences in the two file are not big. Basically, in -O2 there is
> - a bunch of small functions which have now an inline definition
> - a set of strcmp(winetest_platform, "wine") which are replaced
>   by a macro of hell.
> It's, of course, the last one which creates the problem.
> The macro seems to try to optimize the compare using the fact
> that the compiler will statically evaluate things like:
> - strlen("wine")
> - "wine"[0], "wine"[1], ...
> but sparse doesn't do this kind of simplification (yet) and this result
> in much much more code.
> 
> A first inspection of the generated code doesn't show anything
> obviously wrong but I don't exclude there is another problem.

I looked a bit more at this and the problem is not really because of this
evaluation sparse doesn't do. Also I work on a simplified version of the
files keeping nothing after test_ScriptItemize().

1) some numbers:
- GCC compile both preprocessed files in .9s with -O2.
- sparse check the O0 file in 1.93s and O2 file in 13s.
Thus even on the O0 file, the time is already too high because generaly
sparse is roughly 10 times faster than gcc -O2, here is twice as slow.

sparse emits roughly 5 times more BBs for the O2 file than for the O0 one,
it also emits roughly 5 times more instructions and take roughly 5 more
time to generate them (ok, 7 times more).
Thus the processing time and the number of instructions scale well
with the number of BBs emitted (and these BBs are emitted before any
simplification are made), so there is no sign of any non-linearity
nor any oddities with simplification/optimization that would run crazy.

2) I don't think that the lack of static evaluation of strlen("wine") or
   "wine"[0] is a problem here because where present this code is preceded
   by a test __builtin_constant_p(winetest_platform) wich fail.
   All this code is then quickly optimized away (but have first been
   generated as linearized code).

3) the situation with the macro from hell is even worse than I thought:
   it's present 7 times but is in a inline function which is itself
   used 292 times. Thus this code is present 2044 times!
   Some tests show that the time is (roughly) proportional to the
   number of time this inline function is used.

4) if we replace 'inline' by 'inline __attribute__((always_inline))'
   GCC needs roughly 58s to compile the O0 or O2 file.

My conclusion is that most of the problem here comes from the fact that:
   - sparse always inlines function marked as inline
   - and does so very early, before any optimizations (so the extra macro
     code is inlined 2044 times and need to be processed 2044 times).
GCC needs the same time for both file because it inlines functions after
a first optimization pass (I'm guessing here).

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Thu, 03 Aug 2017 22:35:04 +0000
Message-ID: <CA+55aFzif2qNMQ0xniB6ubgGJu67h25K3G9jyGHPHa6o-unjTg () mail ! gmail ! com>
--------------------
On Thu, Aug 3, 2017 at 2:49 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> My conclusion is that most of the problem here comes from the fact that:
>    - sparse always inlines function marked as inline
>    - and does so very early, before any optimizations (so the extra macro
>      code is inlined 2044 times and need to be processed 2044 times).

Yeah, I think that's sadly fairly fundamental to how sparse inlining works.

Sparse inlines things on a tree level, but most optimizations and
simplifications are done on the SSA representation.

That very early inlining was actually a fairly big design decision
originally - at some point I actually wanted to allow sparse to have
inline functions act as untyped "templates" that it inlined, and that
had their types evaluated only within the context of being used.

I have this memory of that actually even working to some degree at
some point (ie you could leave arguments to inline functions untyped,
and they would take their type from the invocation). But that may have
been with special patches.

But yes, for this particular case it's apparently a horrible choice,
exactly because it inlines very early before any actual evaluation of
anything.

                  Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Fri, 04 Aug 2017 00:11:24 +0000
Message-ID: <20170804001122.4ivc2sktypvg2w3i () ltop ! local>
--------------------
On Thu, Aug 03, 2017 at 03:35:04PM -0700, Linus Torvalds wrote:
> On Thu, Aug 3, 2017 at 2:49 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > My conclusion is that most of the problem here comes from the fact that:
> >    - sparse always inlines function marked as inline
> >    - and does so very early, before any optimizations (so the extra macro
> >      code is inlined 2044 times and need to be processed 2044 times).
> 
> Yeah, I think that's sadly fairly fundamental to how sparse inlining works.
> 
> Sparse inlines things on a tree level, but most optimizations and
> simplifications are done on the SSA representation.
> 
> That very early inlining was actually a fairly big design decision
> originally - at some point I actually wanted to allow sparse to have
> inline functions act as untyped "templates" that it inlined, and that
> had their types evaluated only within the context of being used.

Yes, it makes sense.
 
> I have this memory of that actually even working to some degree at
> some point (ie you could leave arguments to inline functions untyped,
> and they would take their type from the invocation). But that may have
> been with special patches.
> 
> But yes, for this particular case it's apparently a horrible choice,
> exactly because it inlines very early before any actual evaluation of
> anything.

Well, if we'll want one day to have some sort of automatic inlining,
like for small functions or functions that are only called once,
we'll need to have inlining on linearized code. One more thing in
the todo list. Otherwise, for 'normal' sane usage, the current
inliner work well enough.

OTOH, I just saw that the heavy inlining is only a marginal part
of the problem here. The real problem is that __builtin_constant_p()
is not expanded because of a type mismatch in a conditional:
one operand is 0 while the other is the inline function which return void.
The type mismatch makes that the expression has no type so no expansion
is done.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Fri, 04 Aug 2017 11:33:30 +0000
Message-ID: <20170804113329.54u5dzon5hrucohg () ltop ! local>
--------------------
On Thu, Aug 03, 2017 at 11:49:08PM +0200, Luc Van Oostenryck wrote:
> 1) some numbers:
> - GCC compile both preprocessed files in .9s with -O2.
> - sparse check the O0 file in 1.93s and O2 file in 13s.
> Thus even on the O0 file, the time is already too high because generaly
> sparse is roughly 10 times faster than gcc -O2, here is twice as slow.
> ...
> 4) if we replace 'inline' by 'inline __attribute__((always_inline))'
>    GCC needs roughly 58s to compile the O0 or O2 file.

With the patch I sent, sparse now need 2.1s to compile the O2 file.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Fri, 04 Aug 2017 14:51:04 +0000
Message-ID: <CANeU7Qm8XKLavw=vWcKDyPkpnLVJ3kva17hkQhYqsi8QHZ2ArQ () mail ! gmail ! com>
--------------------
On Fri, Aug 4, 2017 at 7:33 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> On Thu, Aug 03, 2017 at 11:49:08PM +0200, Luc Van Oostenryck wrote:
>> 1) some numbers:
>> - GCC compile both preprocessed files in .9s with -O2.
>> - sparse check the O0 file in 1.93s and O2 file in 13s.
>> Thus even on the O0 file, the time is already too high because generaly
>> sparse is roughly 10 times faster than gcc -O2, here is twice as slow.
>> ...
>> 4) if we replace 'inline' by 'inline __attribute__((always_inline))'
>>    GCC needs roughly 58s to compile the O0 or O2 file.
>
> With the patch I sent, sparse now need 2.1s to compile the O2 file.

Wow, that is great. You are the man.

I will include that patch, I am going to take a closer look now.
Too tired last night.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Fri, 04 Aug 2017 22:26:48 +0000
Message-ID: <CAExDi1SXUkfR1eNZWLy9cOdEsZSbEb_0rSsEbk6dO8CZkfRxQA () mail ! gmail ! com>
--------------------
On Fri, Aug 4, 2017 at 4:51 PM, Christopher Li <sparse@chrisli.org> wrote:
> On Fri, Aug 4, 2017 at 7:33 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>> On Thu, Aug 03, 2017 at 11:49:08PM +0200, Luc Van Oostenryck wrote:
>>> 1) some numbers:
>>> - GCC compile both preprocessed files in .9s with -O2.
>>> - sparse check the O0 file in 1.93s and O2 file in 13s.
>>> Thus even on the O0 file, the time is already too high because generaly
>>> sparse is roughly 10 times faster than gcc -O2, here is twice as slow.
>>> ...
>>> 4) if we replace 'inline' by 'inline __attribute__((always_inline))'
>>>    GCC needs roughly 58s to compile the O0 or O2 file.
>>
>> With the patch I sent, sparse now need 2.1s to compile the O2 file.

I have investigated a little more because even 2.1 or 1.93s seems
too much to me.

My conclusion is that the file is (really too) big (but see the end).
For example, there is:
- about 1 million calls to clean_up_one_instruction
- and 2.6 million calls to  insn_compare()
OTOH there is only 56000 calls to try_to_cse()
and these results in 82000 calls to bb_dominates()
and 29000 calls to cse_one_instruction().

All this indicate that the CSE is rather efficient:
only 56000 real CSE checks, each calling roughly 3/2
calls to bb_dominates() and 1/2 calls to cse_one_insn().

And in fact, most of these calls are not even really expensive.

The real offending, taking about 75% of CPU time, is bb_dominates()
which while only directly called 82000 is a recursive function which
internally is called more than 71 million of time!
In other words, the mean recursion depth of bb_dominates() is 860,
which means that there are chains of bb->parent as long as 860.

By restricting the bb_dominates() in CSE to a reasonable depth of 32,
the compile time is reduced to .8s without changing a single bit in the
resulting code.

This may be a change we may consider for the future.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 05 Aug 2017 00:23:11 +0000
Message-ID: <CANeU7QkBoEEec=Tj5HyeWPxSqKP9ioGuveODDv8eh+xmbOGHPw () mail ! gmail ! com>
--------------------
On Fri, Aug 4, 2017 at 6:26 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
>
> I have investigated a little more because even 2.1 or 1.93s seems
> too much to me.

Thanks for looking into this.

>
> My conclusion is that the file is (really too) big (but see the end).
> For example, there is:
> - about 1 million calls to clean_up_one_instruction
> - and 2.6 million calls to  insn_compare()
> OTOH there is only 56000 calls to try_to_cse()
> and these results in 82000 calls to bb_dominates()
> and 29000 calls to cse_one_instruction().
>
> All this indicate that the CSE is rather efficient:
> only 56000 real CSE checks, each calling roughly 3/2
> calls to bb_dominates() and 1/2 calls to cse_one_insn().
>
> And in fact, most of these calls are not even really expensive.
>
> The real offending, taking about 75% of CPU time, is bb_dominates()
> which while only directly called 82000 is a recursive function which
> internally is called more than 71 million of time!
> In other words, the mean recursion depth of bb_dominates() is 860,
> which means that there are chains of bb->parent as long as 860.

Yes, that is the impression I get as well for, some where the finding
dominates is taking a lot of time. Also the result is not saved.

>
> By restricting the bb_dominates() in CSE to a reasonable depth of 32,
> the compile time is reduced to .8s without changing a single bit in the
> resulting code.

We can revisit this after the release. I have side project work on finding
the dominatior tree.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: ptrlist-iterator performance on one wine source file
Date: Sat, 05 Aug 2017 10:05:39 +0000
Message-ID: <CAExDi1QW+w0-dHptV5=8Gdw9gv2xya8hznpEgxqr3ija_MTzag () mail ! gmail ! com>
--------------------
On Sat, Aug 5, 2017 at 2:23 AM, Christopher Li <sparse@chrisli.org> wrote:
> On Fri, Aug 4, 2017 at 6:26 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
>>
>> I have investigated a little more because even 2.1 or 1.93s seems
>> too much to me.
>
> Thanks for looking into this.
>
>> The real offending, taking about 75% of CPU time, is bb_dominates()
>> which while only directly called 82000 is a recursive function which
>> internally is called more than 71 million of time!
>> In other words, the mean recursion depth of bb_dominates() is 860,
>> which means that there are chains of bb->parent as long as 860.
>
> Yes, that is the impression I get as well for, some where the finding
> dominates is taking a lot of time. Also the result is not saved.
>
>>
>> By restricting the bb_dominates() in CSE to a reasonable depth of 32,
>> the compile time is reduced to .8s without changing a single bit in the
>> resulting code.
>
> We can revisit this after the release. I have side project work on finding
> the dominatior tree.

Don't forget that asking if this node dominates this other node is not
the same question as asking for the immediate dominator of a node.
In other words, even with the dominator tree you will still need to do
lookups in the tree.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse test failures on ppc32le (and other not so common archs) ===

From: Ramsay Jones <ramsay () ramsayjones ! plus ! com>
To: linux-sparse
Subject: Re: sparse test failures on ppc32le (and other not so common archs)
Date: Thu, 31 Aug 2017 22:43:53 +0000
Message-ID: <c0e4a9fe-05ff-1280-f1ee-0c757ba3310b () ramsayjones ! plus ! com>
--------------------


On 31/08/17 21:55, Uwe Kleine-König wrote:
> On Wed, Aug 30, 2017 at 08:11:49PM -0400, Christopher Li wrote:
>> That is very much like on x86_64 missing define "#weak_define __x86_64__ 1"
>>
>> Does cgcc work for you? In the future we do want to move the archetecture
>> related define from cgcc into sparse by itself. For now you can set
>> "sparse" as "cgcc -no-compile"
> 
> Yes that works. So to address the Debian bug I can do:
> 
>  - move sparse to /usr/lib
>  - teach cgcc about the move of sparse
>  - make /usr/bin/sparse call cgcc -no-compile "$@"

Hmm, I don't think that would be a good idea ...

> or is it easier to teach sparse about the architecture stuff?

I now understand (I think!) that you are building a sparse
package (presumably a .deb) and you are concerned that sparse
does not pass it's own testsuite on those platforms.

As I said before, the additional failures you are seeing are
in the 'llvm backend' code (which, as far as I know, only passes
on x86_64 Linux), and in my opinion the llvm-backend programs should
not be installed. (The Makefile will build them automatically if
you have llvm installed, likewise for c2xml/libxml and test-inspect/gtk).

[I would like to see build variable(s) to allow the user to suppress
the build (or installation) of the other 'non-primary' sparse programs.]

Anyway, if you were to un-install llvm, sparse-llvm etc., would not
be built, and the tests would not be run ... ;-)

Christopher, as the project maintainer, has the joy of making these
kinds of decisions! :-D

ATB,
Ramsay Jones

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse-llvm array size computation issue ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse-llvm array size computation issue
Date: Thu, 28 Dec 2017 21:30:15 +0000
Message-ID: <20171228213014.few7ixr2gaksrt3f () ltop ! local>
--------------------
On Tue, Mar 28, 2017 at 10:14:43PM +0100, Dibyendu Majumdar wrote:
> Hi Luc,
> 
> I think that there is a bug in examine_node_type() in symbol.c - it
> should set the base_type's bit_size perhaps? See the line marked as
> FIX below,
> 
> /* Unsized array? The size might come from the initializer.. */
> if (bit_size < 0 && base_type->type == SYM_ARRAY) {
> struct expression *initializer = get_symbol_initializer(sym);
> if (initializer) {
> struct symbol *node_type = base_type->ctype.base_type;
> int count = count_array_initializer(S, node_type, initializer);
> 
> if (node_type && node_type->bit_size >= 0)
> bit_size = array_element_offset(S->C->target, node_type->bit_size, count);
> base_type->bit_size = bit_size;   /*** FIX set base_type->bit_size ***/
> }
> }

Yes, it's correct and will fix most aspects of the issue but it's
only part of the fix:
- array_size need also to be updated
- the SYM_ARRAY can't be directly updated because it can be
  shared between several nodes, so it need to be duplicated
  before being updated.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse-next and preview of 0.5.1-rc5 ===

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Sat, 15 Jul 2017 18:22:00 +0000
Message-ID: <20170715182159.ltikqlbe6rktxfhz () ltop ! local>
--------------------
On Fri, Jul 14, 2017 at 10:48:57AM -0700, Christopher Li wrote:
> I have push a preview version of 0.5.1-rc5 to sparse-next.
> 
> https://git.kernel.org/pub/scm/devel/sparse/sparse.git/log/?h=sparse-next
> 
> If no big surprise, I will push RC5 to master and tag it tomorrow.

[Sorry, I'm on vacation and very little computer access].

I still object to the kill_unreachable_bbs() patch and I ask
to reconsider it in favor of the original one.

Since this has already been discussed, I can only invite to read
again the original patch and the one it fixes where the situation
is explained, I think, clearly.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Sun, 16 Jul 2017 02:34:46 +0000
Message-ID: <CANeU7Qkt4+QsgrrwUSwiiJ_V77gnJgb5YW0qSwwx1-uu9-GhLw () mail ! gmail ! com>
--------------------
On Sat, Jul 15, 2017 at 2:22 PM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> [Sorry, I'm on vacation and very little computer access].

I am very glad to heard that you are back.

>
> I still object to the kill_unreachable_bbs() patch and I ask
> to reconsider it in favor of the original one.

Of course.  I will hold the RC5 for you. I haven't push the change to
master yet. It is only in sparse-next, I can still roll back the change in we
wants to.

Can you show me some C input file that your original patch will do the
right thing and current one will miss the opportunity to simplify?
Even for the case it is just a suspect of producing worse code is fine.
Just point me to some test case, I will investigate and compare the
results.

My guess is that, there is a good chance some where missing a simplify
opportunity. If it does make a difference and I can't fix it in a timely manner.
Let's use your patch and deal with it after the release. In the long run, I
would prefer not using the two pass deletion of the dead bb, if they can
produce the similar level of optimized result.

> Since this has already been discussed, I can only invite to read
> again the original patch and the one it fixes where the situation
> is explained, I think, clearly.

The original patch does not have test case showing the byte code
difference with this two approach. I need some test examples :-)

Again, glad to know that you are back.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Mon, 17 Jul 2017 01:20:38 +0000
Message-ID: <CANeU7QnL+96T_ngrcgwHREey0TF8a6ENo4ehScKtX2PfBOvnew () mail ! gmail ! com>
--------------------
On Sat, Jul 15, 2017 at 10:34 PM, Christopher Li <sparse@chrisli.org> wrote:

> Of course.  I will hold the RC5 for you. I haven't push the change to
> master yet. It is only in sparse-next, I can still roll back the change in we
> wants to.
>
> Can you show me some C input file that your original patch will do the
> right thing and current one will miss the opportunity to simplify?
> Even for the case it is just a suspect of producing worse code is fine.
> Just point me to some test case, I will investigate and compare the
> results.

Ping. I am still waiting for your test source to compare the two
approach of kill_unreachable_bb(). If both generate the equivalent result,
I prefer the simpler approach.

I will hold the RC5 until Wednesday if I don't have additional input.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Wed, 19 Jul 2017 22:17:40 +0000
Message-ID: <20170719221738.2gkctzmdjajz4uec () ltop ! local>
--------------------
On Sat, Jul 15, 2017 at 10:34:46PM -0400, Christopher Li wrote:
> On Sat, Jul 15, 2017 at 2:22 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > [Sorry, I'm on vacation and very little computer access].
> 
> I am very glad to heard that you are back.

Even now, I'm not really back. Just taking time to reply here
while I have the opportunity to.
 
> > I still object to the kill_unreachable_bbs() patch and I ask
> > to reconsider it in favor of the original one.
> 
> Of course.  I will hold the RC5 for you. I haven't push the change to
> master yet. It is only in sparse-next, I can still roll back the change in we
> wants to.
> 
> Can you show me some C input file that your original patch will do the
> right thing and current one will miss the opportunity to simplify?
> Even for the case it is just a suspect of producing worse code is fine.
> Just point me to some test case, I will investigate and compare the
> results.
> 
> My guess is that, there is a good chance some where missing a simplify
> opportunity. If it does make a difference and I can't fix it in a timely manner.
> Let's use your patch and deal with it after the release. In the long run, I
> would prefer not using the two pass deletion of the dead bb, if they can
> produce the similar level of optimized result.
> 
> > Since this has already been discussed, I can only invite to read
> > again the original patch and the one it fixes where the situation
> > is explained, I think, clearly.
> 
> The original patch does not have test case showing the byte code
> difference with this two approach. I need some test examples :-)

Test cases are test cases and code is code.

I'll copy here verbatim the commit message of the patch that was fixed
by the original patch (the one that had "Fixes: 51cfbc90a5e1462fcd624a1598ecd985a508a5d6
 
	commit 51cfbc90a5e1462fcd624a1598ecd985a508a5d6
	Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
	Date:   2017-04-26 12:21:21 +0200
	
	    fix: kill unreachable BBs after killing a child
	    
	    When simplifying a switch into a simple branch all the now
	    unused children of the current BB must be removed.
	    If one of these children become now orphaned, it is directly
	    killed (it will need to be killed soon or later since it is
	    unreachable).
	    
	    However, if one of the killed children is the header of a loop
	    where some variables are updated this may cause problems.
	    Indeed, by killing the header (which contains the phisrc of
	    the entry value of the variable) the whole loop may become
	    unreachable but is not killed yet, OTOH simplification of
	    the associated OP_PHI may create a cycle which may then be
	    detected later by simplify_one_memop() which will issue a
	    "crazy programmer" warning while the programmer was innocent.
	    
	    This situation can be seen in code like:
	            int *p;
	            switch (i - i) {        // will be optimized to 0
	            case 0:                 // will be the simple branch
	                    return 0;
	            case 1:                 // will be optimized away
	                    p = ptr;
	                    do {            // will be an unreachable loop
	                            *p++ = 123;
	                    } while (--i);
	            }
	    
	    Fix this by calling kill_unreachable_bbs() after having
	    simplified the switch into a branch. This will avoid to
	    create a cycle with because of the removed phisrc in the
	    header and as an added benefit will avoid to waste time
	    trying to simplify BBs that are unreachable.
	    
	    In addition, it's now useless to call kill_bb() for each
	    removed switch's children as kill_unreachable_bbs() will
	    do that too.
	    
	    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>

So, in short, the problem that was solved then (the "crazy programmer"
problem) was that incorrect phi-node simplification was done in 
simplify_one_memop() if the phi-node was part of a loop that was
in fact unreachable (in this case, the situation is exactly as if
the phi-node was for some undefined variable, thus the
"crazy programmer" warning).

The unreachable loop was created by insert_branch() (which can be 
called by simplify_instruction()) and simplify_one_memop() is also
called by simplify_instruction(), in our case here, for an OP_LOAD).

So the only way, you can have the assurance that the problem cannot
happen is to call kill_unreachable_bbs() between call to insert_branch()
which delete a branch *and* the next call to simplify_one_memop().

Calling kill_unreachable_bbs() only *after* clean_up_insns() is
too late.

It's not at all a problem of some missing optimization opportunity.
It's a problem of applying some optimization (OP_PHI simplification)
and then giving a warning for the consequence of this optimization
(the "crazy programmer" warning) in incorrect conditions/wrong
assumption (a variable must not be considered as undefined if it
is part of an unreachable BB, it should just be ignored).

I hope it is clear enough now.

Is it annoying that we have to call kill_unreachable_bbs() there?
Yes, clearly it is.
Wouldn't it be nice if we could move the kill_unreachable_bbs() in
the cleanup_and_cse() loop?
Yes, it is (but then in this case, it should be done between the
clean_up_insns() and the CSE loop).
This would need some fundamental change in the way simplification
are done (like maybe moving the simplification of OP_LOADs out of
the clean_up_insns() loop), nothing for an -rc5.


I also assure that instead of quickly rewriting someone's patch
(because you don't like it and think you can do better) it would
be so much better to simply:
- *say* what you don't like in the patch
- *ask* why things are done like this way
- *ask* if things couldn't be done this other way instead.
It would be much less painfull, save a lot of time, you would look much
wiser and it would be much more respectuous of other's work & time.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Thu, 20 Jul 2017 22:35:57 +0000
Message-ID: <20170720223554.54ohh7pfl7qm43dc () ltop ! local>
--------------------
On Wed, Jul 19, 2017 at 08:19:02PM -0700, Christopher Li wrote:
> On Wed, Jul 19, 2017 at 3:17 PM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> >
> > Even now, I'm not really back. Just taking time to reply here
> > while I have the opportunity to.
> 
> OK. Good to know then guessing
> 
> 
> >> Can you show me some C input file that your original patch will do the
> >> right thing and current one will miss the opportunity to simplify?
> >> Even for the case it is just a suspect of producing worse code is fine.
> >> Just point me to some test case, I will investigate and compare the
> >> results.
> >
> > Test cases are test cases and code is code.
> >
> > I'll copy here verbatim the commit message of the patch that was fixed
> > by the original patch (the one that had "Fixes: 51cfbc90a5e1462fcd624a1598ecd985a508a5d6
> 
> I still don't have a valid test case to difference sparse-next
> and your patch series.

You don't need a test case to *think* about the code or simply read
the explanation I wrote here under.
 
> If your test case is that switch statement, I make a test case
> out of it. Sparse-next and yoru patch show the same result
> bytecode wise:

Of course, it does.
 
> >         commit 51cfbc90a5e1462fcd624a1598ecd985a508a5d6
> >         Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
> >         Date:   2017-04-26 12:21:21 +0200
> >
> >             fix: kill unreachable BBs after killing a child
> >
> >             When simplifying a switch into a simple branch all the now
> >             unused children of the current BB must be removed.
> >             If one of these children become now orphaned, it is directly
> >             killed (it will need to be killed soon or later since it is
> >             unreachable).
> >
> >             However, if one of the killed children is the header of a loop
> >             where some variables are updated this may cause problems.
> >             Indeed, by killing the header (which contains the phisrc of
> >             the entry value of the variable) the whole loop may become
> >             unreachable but is not killed yet, OTOH simplification of
> >             the associated OP_PHI may create a cycle which may then be
> >             detected later by simplify_one_memop() which will issue a
> >             "crazy programmer" warning while the programmer was innocent.
> 
> That sounds very much like the wine dead loop case recently report on
> the mailing list.

These two cases are not at all related.

> >             This situation can be seen in code like:
> >                     int *p;
> >                     switch (i - i) {        // will be optimized to 0
> >                     case 0:                 // will be the simple branch
> >                             return 0;
> >                     case 1:                 // will be optimized away
> >                             p = ptr;
> >                             do {            // will be an unreachable loop
> >                                     *p++ = 123;
> >                             } while (--i);
> >                     }
> >
> >             Fix this by calling kill_unreachable_bbs() after having
> >             simplified the switch into a branch. This will avoid to
> >             create a cycle with because of the removed phisrc in the
> >             header and as an added benefit will avoid to waste time
> >             trying to simplify BBs that are unreachable.
> >
> >             In addition, it's now useless to call kill_bb() for each
> >             removed switch's children as kill_unreachable_bbs() will
> >             do that too.
> 
> The simple patch in sparse-next has the same output result
> 
> > It's not at all a problem of some missing optimization opportunity.
> > It's a problem of applying some optimization (OP_PHI simplification)
> > and then giving a warning for the consequence of this optimization
> > (the "crazy programmer" warning) in incorrect conditions/wrong
> > assumption (a variable must not be considered as undefined if it
> > is part of an unreachable BB, it should just be ignored).
> >
> > I hope it is clear enough now.
> 
> Can you show me a test C code trigger the problem?

OK, it wasn't clear enough.

It will be a few more days before I can access to my usual dev stuff
where my tests and tests results are.

However, using the description here above, it's not very hard to imagine
a situation where the two patch will behave differently.
You can even create a test case from the old test case here above
and removing a single line, the one "p = ptr;". It's also very easy
to create all sort of variants of it.
 
-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Sat, 22 Jul 2017 03:55:09 +0000
Message-ID: <CANeU7QnovxzRQuhjyRHY==B2Vk5qU9Qk08rTDuvdwmARGci4Og () mail ! gmail ! com>
--------------------
On Thu, Jul 20, 2017 at 11:40 PM, Christopher Li <sparse@chrisli.org> wrote:
> int *ptr;
> int foo( int i)
> {
> int *p;
> switch (i - i) {        // will be optimized to 0
> case 0:                 // will be the simple branch
> return 0;
> case 1:                 // will be optimized away
> do {            // will be an unreachable loop
>    *p++ = 123;
> } while (--i);
> }
> return 1;
> }
>
> Which will show "crazy programmer" in sparse-next but not your patch.

I dig out more, before it is showing the crazy programmer. This is the
IR it is working on:

Notice the "add.64      %r6 <- %r6, $4", that is very wrong.
Not valid SSA form at all.

I believe that is the one of the condition triggering the crazy programmer
bug.

This error actually reminds me the wine dead loop bug.
In the wine dead loop IR we have:

 setne.32    %r11 <- %r11, $0

This two bugs might actually be related.

We shouldn't have
"add.64      %r6 <- %r6, $4"
That already screw up very badly.
I confirm that "add.64      %r6 <- %r6, $4" was in your purpose
patch as well. It is just you pack the BB early so it does not
trigger the "crazy programmer".

I think your patch pack the BB early to avoid the "crazy programmer".
That sounds more like a cover up rather than a proper fix up.

If we have the proper SSA form, the "crazy programmer" shouldn't
pop up at all.

BTW, that is exactly why I want to get a test C test file to expose
the bug. From the description of the bug does not show as much
detail as the test C code. Different people will have different
views of how the bug happen and how to fix it. Given enough eye
ball, all the bug will be obvious.

Chris


<entry-point>
phisrc.32   %phi3(i) <- %arg1
br          .L2

.L2:
phisrc.32   %phi1(return) <- $0
br          .L4

.L3:
br          .L5

.L5:
add.64      %r6 <- %r6, $4 <============ this is very wrong
store.32    $123 -> 0[%r6] <========== cause crazy programmer here.
br          .L6

.L6:
phi.32      %r7 <- %phi3(i), %phi4(i)
sub.32      %r8 <- %r7, $1
phisrc.32   %phi4(i) <- %r8
cbr         %r8, .L5, .L7

.L7:
br          .L1

.L1:
phisrc.32   %phi2(return) <- $1
br          .L4

.L4:
phi.32      %r4 <- %phi1(return), %phi2(return)
ret.32      %r4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Wed, 26 Jul 2017 16:10:20 +0000
Message-ID: <CANeU7Q=YQUgzBeKhzOSROdJEobTAjXU1oSbicceB9axg1sFGsg () mail ! gmail ! com>
--------------------
On Wed, Jul 26, 2017 at 5:00 AM, Luc Van Oostenryck
<luc.vanoostenryck@gmail.com> wrote:
> This is typical of situations where undefined pseudos are involved.
> For example this is what Linus wrote on the subject some months ago:
>
>                and.32      %r3 <- %r4, $-65
>                 or.32       %r4 <- %r3, $64
>
>         which *initializes* the pseudo %r4 in the second instruction, but uses
>         it in the first one. That's a classic pattern of uninitialized pseudos
>         in sparse exactly because of the SSA logic.
>
>         But it is all internally consistent, and the simplification is
>         "correct". The simplification phase very much has a "garbage in,
>         garbage out" model.

I think that model is wrong. It is not only "garbage in, garbage out".
It cause sparse freak out due to incorrect SSA form like the wine dead
loop bug. In the above example, %r4 was used *before* it's define,
so there must exist an execution flow loop back to the beginning of
this block. So the proper way should be some thing like:

phi.32 %phi4 <- %phisrc1(VOID), %phisrc2(%r4)
and.32 %r3 <- %phi4, $-65
or.32 %r4 <- %r3, $64
phisrc.32 %phiscrc2 <- %r4

Luc, are you fully back yet?

If you are, please take a look at the wine compile dead loop bug. I
already simplify the test source into minimal form. My guess is that it
is cause by this invalid SSA form as well.

BTW, gcc does not do this kind of invalid SSA form in their IR.

We really should change this model.
>
> Yes, this is what was explained in the original patch description.

OK we are on the same page on cause of the crazy programmer.
Only different view on the SSA form.

 the BB early to avoid the "crazy programmer".
>> That sounds more like a cover up rather than a proper fix up.
>
> Like explained in the original patch description, this situation with
> a self-defined pseudo can happen in unreachable code *even* if the
> pseudo was in fact defined if:
> - the definition was done in a loop header
> - the loop header was deleted by insert_branch()
>   * the definition is then removed, the pseudo become undefined
>   * it shouldn't matter since all it's use is now in dead code
>   * we don't know the that the loop is now dead code before
>     kill_unreachable_bbs() is called.
>   * therefore, kill_unreachable_bbs() must be called:
>     - after a branch have been deleted
>     - before simplify_one_memop() is called and is about to issue the
>       "crazy programmer" warning
>       BECAUSE THE "crazy programmer" WARNING SHOULD NOT BE ISSUED
>       IF THE CONCERNED CODE IS IN FACT DEAD CODE.

I totally get that part. My point is that, the crazy programmer warning
is an ill form of SSA to begin with. We might need to address that illegal
SSA form as well. My impression is that the illegal SSA from cause the
wine dead loop bug as well.

> So, if you really prefer, you can call kill_unreachable_bbs() just before
> the "crazy programmer" check instead of just after the branch delete
> like it was done in my patch but calling kill_unreachable_bbs()
> only after clean_up_insn() like done in your patch is wrong.

I don't think it is wrong. Because even with your patch, there is
other ways to get into "crazy programmer" situation. We need to
address that.

My point is that, "crazy programmer" is an ill form of  SSA it shouldn't
exist in the first place.

>
>> If we have the proper SSA form, the "crazy programmer" shouldn't
>> pop up at all.
>
> See Linus explanation here above.

I am not convinced that is a good enough reason to allow this
kind of ill form of SSA. It save a phi instruction but cost a lot of
trouble down the road.

> I found absolutely incredible the amount of time already wasted
> on this issue and it is even not closed yet.
> I feel really tired and totally disgusted by all this.

Luc, I hope you have a good rest during your time off sparse.

Getting the compiler back end optimization right is hard and
tedious.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Luc Van Oostenryck <luc.vanoostenryck () gmail ! com>
To: linux-sparse
Subject: Re: sparse-next and preview of 0.5.1-rc5
Date: Wed, 26 Jul 2017 19:28:41 +0000
Message-ID: <20170726192840.uw22cwbihmlvjp3a () ltop ! local>
--------------------
On Wed, Jul 26, 2017 at 12:10:20PM -0400, Christopher Li wrote:
> On Wed, Jul 26, 2017 at 5:00 AM, Luc Van Oostenryck
> <luc.vanoostenryck@gmail.com> wrote:
> > This is typical of situations where undefined pseudos are involved.
> > For example this is what Linus wrote on the subject some months ago:
> >
> >                and.32      %r3 <- %r4, $-65
> >                 or.32       %r4 <- %r3, $64
> >
> >         which *initializes* the pseudo %r4 in the second instruction, but uses
> >         it in the first one. That's a classic pattern of uninitialized pseudos
> >         in sparse exactly because of the SSA logic.
> >
> >         But it is all internally consistent, and the simplification is
> >         "correct". The simplification phase very much has a "garbage in,
> >         garbage out" model.
> 
> I think that model is wrong.

I'm not fond of it myself, far from it, but for the moment
it's how sparse is working.

> It is not only "garbage in, garbage out".
> It cause sparse freak out due to incorrect SSA form like the wine dead
> loop bug. In the above example, %r4 was used *before* it's define,
> so there must exist an execution flow loop back to the beginning of
> this block.

I hadn't time to look closely to the wine bug but I'm very aware
of what can happen to undefined pseudos *coupled* to the optimization
that are done on them (basically they are essentially ignored as
phi-sources, this coupled with CSE make that once loops are involved
you have this sort of self-defined pseudos, directly or indirectly).

> So the proper way should be some thing like:
> 
> phi.32 %phi4 <- %phisrc1(VOID), %phisrc2(%r4)
> and.32 %r3 <- %phi4, $-65
> or.32 %r4 <- %r3, $64
> phisrc.32 %phiscrc2 <- %r4
> 
> Luc, are you fully back yet?
> 
> If you are, please take a look at the wine compile dead loop bug. I
> already simplify the test source into minimal form. My guess is that it
> is cause by this invalid SSA form as well.

I had the impression it was something else but as I said I
haven't really looked at it.

> BTW, gcc does not do this kind of invalid SSA form in their IR.

GCC has a very different optimization architecture, for example,
they don't try to reach a fix-point as this would be way too costly.
They simply have a number of passes, in a fixed order, and some of them
can be (optionally) repeadted at some stages (-frerun-cse-after-loop,
-fgcse, -fgcse-after-reload, ...).
 
GCC is also very bad at giving good warnings for undefined variables
(cfr., for example, https://gcc.gnu.org/bugzilla/show_bug.cgi?id=18501)

> We really should change this model.

The patch series I have to solve the problem of misplaced phi-nodes
use an explicit PSEUDO_UNDEF type don't try to do anything with them
(on pupose, so that 1) we can given some warnings about undef vars,
2) we can *decide* to do optimization on them or not).
This is of course not material for a -rc5.

> OK we are on the same page on cause of the crazy programmer.
> Only different view on the SSA form.
> 
>  the BB early to avoid the "crazy programmer".
> >> That sounds more like a cover up rather than a proper fix up.
> >
> > Like explained in the original patch description, this situation with
> > a self-defined pseudo can happen in unreachable code *even* if the
> > pseudo was in fact defined if:
> > - the definition was done in a loop header
> > - the loop header was deleted by insert_branch()
> >   * the definition is then removed, the pseudo become undefined
> >   * it shouldn't matter since all it's use is now in dead code
> >   * we don't know the that the loop is now dead code before
> >     kill_unreachable_bbs() is called.
> >   * therefore, kill_unreachable_bbs() must be called:
> >     - after a branch have been deleted
> >     - before simplify_one_memop() is called and is about to issue the
> >       "crazy programmer" warning
> >       BECAUSE THE "crazy programmer" WARNING SHOULD NOT BE ISSUED
> >       IF THE CONCERNED CODE IS IN FACT DEAD CODE.
> 
> I totally get that part. My point is that, the crazy programmer warning
> is an ill form of SSA to begin with. We might need to address that illegal
> SSA form as well.

OK. In short, undefined pseudos cause this SSA you call illegal and that
Linus call typical of uninitialized pseudos. Different nomenclatures, fine.

But the whole thing about all this discussion is that
- after some optimizations
- in dead/unreachable code
- you *can* have uninitialized pseudos that *were* perfectly initialized
  in the initial code.
- and doing further optimization on this dead code wil then create real
  problems like this false "crazy programmer" warning.

It's of course an unpleasant situation, one that is present since
a long time, sort of at the core of sparse. I can be solved in
severals ways but the only simple one, adequate for an -rc5 is
to avoid doing optimization on those unreachable BBs, like my
patch insure to do in all cases and your version do only some cases.

> My impression is that the illegal SSA from cause the
> wine dead loop bug as well.

I'll take a look at it.

> > So, if you really prefer, you can call kill_unreachable_bbs() just before
> > the "crazy programmer" check instead of just after the branch delete
> > like it was done in my patch but calling kill_unreachable_bbs()
> > only after clean_up_insn() like done in your patch is wrong.
> 
> I don't think it is wrong. Because even with your patch, there is
> other ways to get into "crazy programmer" situation. We need to
> address that.
> 
> My point is that, "crazy programmer" is an ill form of  SSA it shouldn't
> exist in the first place.

The "crazy programmer" warning is a very valid warning.
It has a very bad description but it is simply a warning for
vars. Try on some code like:
	void bad0(void)
	{
		int *a;
		*a++;
	}

It will very legitimately give you one of such "crazy programmer"
warning, which really should be something like:
	warning: (possibly) undefined variable 'a'
In others words, what you call 'illegal SSA form' is, very much
by design, the symptoms of undefined vars and it's the only one we
currently have. It's also fo form of self-consistency check that will
need to stay independently of how undefined vars are treated.

Of course, once we get this situation and this warning on perfectly
valid and defined code because we try to apply some optimizations
on code that have been partially optimized away (the initialization
have been removed but the uses have not), things are very different.

> > I found absolutely incredible the amount of time already wasted
> > on this issue and it is even not closed yet.
> > I feel really tired and totally disgusted by all this.
> 
> Luc, I hope you have a good rest during your time off sparse.
> 
> Getting the compiler back end optimization right is hard and
> tedious.

Absolutely, and I would really appreciate to spend my time on
useful work rather than on these discussions.

-- Luc
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

