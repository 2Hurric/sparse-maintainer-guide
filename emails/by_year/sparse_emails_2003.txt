--- Emails for Year 2003 ---

=== Thread: C string storage ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: C string storage
Date: Mon, 08 Sep 2003 23:57:29 +0000
Message-ID: <3F5D1769.10106 () pobox ! com>
--------------------
To return to a topic of the previous day...  are you thinking that each 
character in a C string initializer would be a different node?  The 
backend is gonna wind up coalescing the constant C string initializers 
into a single '.string "foo"' object anyway, so I was hoping I could 
push you in the direction of an EXPR_STRING or similar...  because at 
the parser level,
	"blah blah"
looks different from
	{ 'b', 'l', 'a', 'h', ... }

and I actually care about that.

	Jeff, hoping :)





-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: C string storage
Date: Tue, 09 Sep 2003 02:34:08 +0000
Message-ID: <Pine.LNX.4.44.0309081932400.10873-100000 () home ! osdl ! org>
--------------------

On Mon, 8 Sep 2003, Jeff Garzik wrote:
>
> To return to a topic of the previous day...  are you thinking that each 
> character in a C string initializer would be a different node? 

No. I'm just saying that the "complete" node does (and should) look like a 
character array of a fixed length with some magic properties (ie it's 
autoamtically part of rodata even if it isn't marked const).

The string initializer data itself is always going to be a special case, I 
just don't think the type system should have to worry about the special 
case (ie make it a special case only for the output routines).

		Linus



================================================================================


################################################################################

=== Thread: CQual 0.99 Released: user/kernel pointer bug finding tool ===

From: "Robert T. Johnson" <rtjohnso () eecs ! berkeley ! edu>
To: linux-kernel
Subject: CQual 0.99 Released: user/kernel pointer bug finding tool
Date: Wed, 10 Sep 2003 23:02:08 +0000
Message-ID: 
--------------------
Download: http://www.cs.umd.edu/~jfoster/cqual/.
Support:  cqual@cs.umd.edu.

CQual is a program verification tool that uses type-qualifier
inference to find bugs in C programs.  This release of CQual includes
support for finding user/kernel pointer bugs in the linux kernel.
CQual has already found user/kernel pointer bugs in source files that
passed through Linus' "sparse" tool without generating any warnings.
Our goals with this release are

- help kernel developers avoid user/kernel bugs
- get feedback from kernel developers for future CQual features

CQual's current main features are:

- It requires _very_ few annotations: we currently use only ~200
- It's sound: CQual verifies the _absence_ of user/kernel bugs
- It generates fewer false warnings than sparse.
- It's context-sensitve: CQual doesn't confuse different calls to the 
  same function.
- CQual allows different instances of a struct type to hold different 
  kinds of pointers (i.e. user vs. kernel)
- It can be easily extended to find new types of bugs by editing a 
  configuration file
- It's fast: CQual analyzes most files in 1-2 seconds.
- It integrates easily into the kernel checking process.

The distribution contains a KERNEL-QUICKSTART to help kernel
developers start finding user/kernel bugs quickly.  We look forward to
hearing your feedback.

CQual is currently developed by Jeff Foster, John Kodumal, Tachio
Terauchi, Rob Johnson, and many others.

Best,
Rob Johnson


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: "Robert T. Johnson" <rtjohnso () eecs ! berkeley ! edu>
To: linux-sparse
Subject: CQual 0.99 Released: user/kernel pointer bug finding tool
Date: Thu, 11 Sep 2003 17:54:25 +0000
Message-ID: <1063302866.9766.22.camel () dooby ! cs ! berkeley ! edu>
--------------------
Download: http://www.cs.umd.edu/~jfoster/cqual/
Support:  cqual@cs.umd.edu.

CQual is a program verification tool that uses type-qualifier
inference to find bugs in C programs.  This release of CQual includes
support for finding user/kernel pointer bugs in the linux kernel.
CQual has already found user/kernel pointer bugs in source files that
passed through Linus' "sparse" tool without generating any warnings.
Our goals with this release are

- help kernel developers avoid user/kernel bugs
- get feedback from kernel developers for future CQual features

CQual's current main features are:

- It requires _very_ few annotations: we currently use only ~200
- It's sound: CQual verifies the _absence_ of user/kernel bugs
- It generates fewer false warnings than sparse.
- It's context-sensitve: CQual doesn't confuse different calls to the 
  same function.
- CQual allows different instances of a struct type to hold different 
  kinds of pointers (i.e. user vs. kernel)
- It can be easily extended to find new types of bugs by editing a 
  configuration file
- It's fast: CQual analyzes most files in 1-2 seconds.
- It integrates easily into the kernel checking process.

The distribution contains a KERNEL-QUICKSTART to help kernel
developers start finding user/kernel bugs quickly.  We look forward to
hearing your feedback.

CQual is currently developed by Jeff Foster, John Kodumal, Tachio
Terauchi, Rob Johnson, and many others.

Best,
Rob Johnson


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: CQual 0.99 Released: user/kernel pointer bug finding tool
Date: Thu, 11 Sep 2003 19:28:57 +0000
Message-ID: <3F60CCF9.4070509 () pobox ! com>
--------------------
Robert T. Johnson wrote:
> Download: http://www.cs.umd.edu/~jfoster/cqual/
> Support:  cqual@cs.umd.edu.
> 
> CQual is a program verification tool that uses type-qualifier
> inference to find bugs in C programs.  This release of CQual includes
> support for finding user/kernel pointer bugs in the linux kernel.
> CQual has already found user/kernel pointer bugs in source files that
> passed through Linus' "sparse" tool without generating any warnings.

Does this mean the tool is based on sparse?


> Our goals with this release are
> 
> - help kernel developers avoid user/kernel bugs
> - get feedback from kernel developers for future CQual features

If you want to address kernel developers, you should probably also CC 
your message to linux-kernel@vger.kernel.org as well...

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: "Robert T. Johnson" <rtjohnso () eecs ! berkeley ! edu>
To: linux-sparse
Subject: Re: CQual 0.99 Released: user/kernel pointer bug finding tool
Date: Fri, 12 Sep 2003 17:17:48 +0000
Message-ID: <1063387072.9765.33.camel () dooby ! cs ! berkeley ! edu>
--------------------
On Thu, 2003-09-11 at 12:28, Jeff Garzik wrote:
> Robert T. Johnson wrote:
> > Download: http://www.cs.umd.edu/~jfoster/cqual/
> > Support:  cqual@cs.umd.edu.
> > 
> > CQual is a program verification tool that uses type-qualifier
> > inference to find bugs in C programs.  This release of CQual includes
> > support for finding user/kernel pointer bugs in the linux kernel.
> > CQual has already found user/kernel pointer bugs in source files that
> > passed through Linus' "sparse" tool without generating any warnings.
> 
> Does this mean the tool is based on sparse?

CQual is completely unrelated to sparse, except that it has similar
goals.

> > Our goals with this release are
> > 
> > - help kernel developers avoid user/kernel bugs
> > - get feedback from kernel developers for future CQual features
> 
> If you want to address kernel developers, you should probably also CC 
> your message to linux-kernel@vger.kernel.org as well...

I did in a seperate mailing, but thanks for the tip.

Best,
Rob




================================================================================


################################################################################

=== Thread: Checking for disjoint scopes? ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Checking for disjoint scopes?
Date: Fri, 12 Sep 2003 16:48:18 +0000
Message-ID: <3F61F8D2.70508 () pobox ! com>
--------------------
Consider

	void doit(int x)
	{
		if (x > 42) {
			int foo;
			...
		} else {
			int bar;
			...
		}
	}

Is there any easy way to tell that 'foo' and 'bar' are from completely 
disjoint scopes, and could potentially share a stack frame location?

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: Re: Checking for disjoint scopes?
Date: Fri, 12 Sep 2003 17:33:15 +0000
Message-ID: <1063387995.3f62035b97638 () www ! mailshell ! com>
--------------------
It seems that your back end only does one pass emit from
the front end symbol tree.

You can do "sub esp, <local_scope_stack_size>" which you see the
begin of scope and remember the current frame depth.
do "add esp, <last_scope_stack_size>", when you leave the current
scope. So foo, and bar will point to the same stack place.

It is not optimized, you can collapse the scope on the second pass.

Chris


>From Jeff Garzik <jgarzik@pobox.com> on 12 Sep 2003:

> Consider
> 
> 	void doit(int x)
> 	{
> 		if (x > 42) {
> 			int foo;
> 			...
> 		} else {
> 			int bar;
> 			...
> 		}
> 	}
> 
> Is there any easy way to tell that 'foo' and 'bar' are from completely 
> disjoint scopes, and could potentially share a stack frame location?
> 
> 	Jeff
> 
> 
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse"
> in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
> 


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Checking for disjoint scopes?
Date: Fri, 12 Sep 2003 18:34:08 +0000
Message-ID: <3F6211A0.3030107 () pobox ! com>
--------------------
chrisl_sparse@cli.mailshell.com wrote:
> It seems that your back end only does one pass emit from
> the front end symbol tree.

Oh, don't think too hard on what my backend does right now ;-)


> You can do "sub esp, <local_scope_stack_size>" which you see the
> begin of scope and remember the current frame depth.
> do "add esp, <last_scope_stack_size>", when you leave the current
> scope. So foo, and bar will point to the same stack place.
> 
> It is not optimized, you can collapse the scope on the second pass.

I'm a big fan of collecting information as I walk the parse tree (first 
pass), then using the emit phase as my second pass.  So, what I was 
hoping for was some way at the parse tree level to see if two symbols 
were in the same scope.  It's something I can keep track of in the 
backend, but would like to avoid duplication of effort if the frontend 
already does this.

Not a big deal, since the backend won't be dealing with this for a 
while.  Just thinking ahead, since the backend will need a stack frame 
handling rewrite _anyway_, so that structs, quads, and other >32-bit 
types can be directly addressed on the stack.

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Checking for disjoint scopes?
Date: Fri, 12 Sep 2003 18:38:09 +0000
Message-ID: <3F621291.9030007 () pobox ! com>
--------------------
chrisl_sparse@cli.mailshell.com wrote:
> You can do "sub esp, <local_scope_stack_size>" which you see the
> begin of scope and remember the current frame depth.
> do "add esp, <last_scope_stack_size>", when you leave the current
> scope. So foo, and bar will point to the same stack place.


Also FWIW, right now the backend generates code that only does a single 
subl (in func prologue) and a single addl (in func epilogue).  I reserve 
stack frame slots in the first pass, and then write a single subl/addl 
pair for the function during the output (aka second) pass.

So, I need only to notice that two stack variables can be stored at the 
same location, or not.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: Re: Checking for disjoint scopes?
Date: Fri, 12 Sep 2003 22:30:10 +0000
Message-ID: <1063405810.3f6248f257e59 () www ! mailshell ! com>
--------------------


>From Jeff Garzik <jgarzik@pobox.com> on 12 Sep 2003:
> stack frame slots in the first pass, and then write a single subl/addl 
> pair for the function during the output (aka second) pass.
> 
> So, I need only to notice that two stack variables can be stored at the 
> same location, or not.

That is what I mean for collapse the scope. You have to go back and modify
the how much to reserve from the stack. BTW, a lot of compiler use
frame base will generate code like this (intel syntax):

push ebp
mov ebp, esp
sub esp, <frame size>

...
In middle of function, you can reference local varible using ebp.

...

at end of function:

mov esp, ebp
pop ebp

It is easier to handle variable size of array like
{
    int array[n];
    ...
}





================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Checking for disjoint scopes?
Date: Fri, 12 Sep 2003 22:40:15 +0000
Message-ID: <3F624B4F.1020305 () pobox ! com>
--------------------
chrisl_sparse@cli.mailshell.com wrote:
> 
>>From Jeff Garzik <jgarzik@pobox.com> on 12 Sep 2003:
> 
>>stack frame slots in the first pass, and then write a single subl/addl 
>>pair for the function during the output (aka second) pass.
>>
>>So, I need only to notice that two stack variables can be stored at the 
>>same location, or not.
> 
> 
> That is what I mean for collapse the scope. You have to go back and modify
> the how much to reserve from the stack.

Yes.  I already have a two-pass system that can "go back".

What I do not know is:  is there an easy way to do

	scopes_are_disjoint(symbol1, symbol2)

?

If not, I will write it.

IOW, I am not asking "how?" but "does it already exist?"


> push ebp
> mov ebp, esp
> sub esp, <frame size>
> 
> ...
> In middle of function, you can reference local varible using ebp.
> 
> ...
> 
> at end of function:
> 
> mov esp, ebp
> pop ebp

My code does this already :)  Without the use of ebp, though.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: Re: Checking for disjoint scopes?
Date: Fri, 12 Sep 2003 23:42:16 +0000
Message-ID: <1063410136.3f6259d8f1b41 () www ! mailshell ! com>
--------------------


>From Jeff Garzik <jgarzik@pobox.com> on 12 Sep 2003:
> Yes.  I already have a two-pass system that can "go back".
> 

You will need "go back" for logical expression. I learn that
in doing the C style asm project before. It is very similar to
what you are doing now.

Where do you plan to play the game of register allocation etc?
I feel that the back end emit x86 instruction too early.
It will be nice to have a level of abstraction do the common
compiler work before emit into x86 instruction. That level is
very thin right now.

> If not, I will write it.

I did not find any thing like that. Linus can give the official
answer.

But why do you need to care two scope is disjoint or not?
In your example, keep track of the maxim depth of the frame
should be good enough.
 

> My code does this already :)  Without the use of ebp, though.

I saw it using esp all the time. Ebp is for function want to have
a frame.

Chris 


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Checking for disjoint scopes?
Date: Sat, 13 Sep 2003 00:03:26 +0000
Message-ID: <3F625ECE.9020807 () pobox ! com>
--------------------
chrisl_sparse@cli.mailshell.com wrote:
> Where do you plan to play the game of register allocation etc?
> I feel that the back end emit x86 instruction too early.
> It will be nice to have a level of abstraction do the common
> compiler work before emit into x86 instruction. That level is
> very thin right now.

Yes, I do not care about register allocation right now.  All temporaries 
are unconditionally stored on the stack.  This is slower but it works.


> But why do you need to care two scope is disjoint or not?

gcc gets it wrong.  In the Linux kernel, stack usage is very important. 
Since gcc sums stack usage of disjoint stack scopes, functions are 
allocated far more stack than they really need.


> In your example, keep track of the maxim depth of the frame
> should be good enough.

Agreed.  This is what I do now.


>>My code does this already :)  Without the use of ebp, though.
> 
> 
> I saw it using esp all the time. Ebp is for function want to have
> a frame.

The kernel builds with "-fomit-frame-pointer", so this is the model I 
prefer.  We can add %ebp later, but I do not see a big need, outside of 
debuggers.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================


################################################################################

=== Thread: IRC discussion about handle_switch ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: IRC discussion about handle_switch
Date: Tue, 09 Sep 2003 16:32:52 +0000
Message-ID: <20030909163252.GC919 () conectiva ! com ! br>
--------------------
Linus, OK?

<jgarzik> acme: all utils but 'compile' are ok with that :)
<acme> consider adding things that are generic to handle_switch and using a
          compile_handle_switch that uses handle_switch, if possible
<jgarzik> acme: well, if you want to be lib-friendly, that won't work.
<jgarzik> acme: for 'compile', it's better to (for example) call
          handle_switch_d(), handle_switch_i(), etc.
<acme> humm
<jgarzik> acme: and do the main getopt(3) in compile.c
<acme> perhaps this is what we should do...
<acme> and have a generic getopt that is good enough for simple utils
<jgarzik> acme: then lib.c would have a generic handle_switch (as it does
          now), which calls those functions
<jgarzik> acme: yep, exactly :)
<acme> jgarzik:  I'll do that

- Arnaldo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: IRC discussion about handle_switch
Date: Tue, 09 Sep 2003 16:47:46 +0000
Message-ID: <Pine.LNX.4.44.0309090947360.17041-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003, Arnaldo Carvalho de Melo wrote:
>
> Linus, OK?

Ok.

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================


################################################################################

=== Thread: Python back end for sparse, step 1 ===

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: Python back end for sparse, step 1
Date: Fri, 26 Sep 2003 01:58:29 +0000
Message-ID: <1064541509.3f739d45a8776 () www ! mailshell ! com>
--------------------
Hi Linus,

I have making some good progress on the python back end for sparse.
No, it does not complain C code to python byte code. Instead, it
compile C code to python module source code, some what like bgen or
SWIG. (In fact, I am using enhanced version of bgen to emit C module).

My first step is get a python module can call to the sparse lib.
So I can use sparse in python.

The second step is using the python sparse module to parse sparse
source file. Automatic generate the python spasrse module source file.
So I get a more complete API of sparse in python. Then I can use the
better API to improve the automatic generate script. It is just like
writing compiler to compile itself.

Now I am pretty close to make python script using result from sparse
module to generate sparse module itself. Ideally, I would like to
submit it when it can self generate.

On the other hand, I found the sparse module is pretty usable now.
So I will try to submit it early. Once it can self generate, it will
grow very big rapidly.

It is a good tool to teach myself about sparse AST tree structure.
I think it might be useful for others to poke around the sparse
AST tree. Of course, once it is completed, it can do more useful
things. e.g. writing some experiment checker. I agree the real checker
should be stay in C for speed though.


Right now the main part of the module is a generated C file:
"_sparse.c" about 74K. It sit in a sub directory of sparse. I will
try to submit the other part of the code (mostly python code) when
I finish step 2.

What do you say? Should I try to send it to mail list or upload it
to some URL?

Thanks

Chris

some example:

e.g. pprint(sym_info(sym)) can show me this about the "struct symbol_op" node:


['SYM_STRUCT',
 'symbol_op',
 ['symlist',
  ['SYM_NODE',
   'evaluate',
   ['SYM_PTR',
    ['SYM_FN',
     ['SYM_BASETYPE', 'MOD_SIGNED align:4 bit: 32'],
     ['args', ['SYM_NODE', ['SYM_PTR', ['SYM_STRUCT', 'expression']]]]]]],
  ['SYM_NODE',
   'expand',
   ['SYM_PTR',
    ['SYM_FN',
     ['SYM_BASETYPE', ' align:0 bit: -1'],
     ['args', ['SYM_NODE', ['SYM_PTR', ['SYM_STRUCT', 'expression']]]]]]]]]

Here is the sym_info function, in python:

def sym_info(sym, expand=1):
    info = [typename[sym.type]]
    sym.ident and info.append(sym.ident.name)
    if sym.type == SYM_BASETYPE:
        ctype = sym.ctype
	mods = " ".join([modname[1<<x] for x in range(32)
					if (1<<x)& ctype.modifiers ])
        info.append("%s align:%d bit: %d"%(mods, ctype.alignment,
                                           sym.bit_size))
	return info
    basetype = sym.ctype.base_type
    basetype and info.append(sym_info(basetype, not basetype.ident or basetype.type != SYM_STRUCT))
    if not expand: return info
    if sym.arguments:
        info.append(['args'] + [ sym_info(x) 
                                 for x in symbol_list(sym.arguments)]) 
    if sym.symbol_list:
        info.append(['symlist'] + [ sym_info(x)
                                    for x in symbol_list(sym.symbol_list)])
    return info


Here is another sample of python version of check.c:

from _sparse import *
from SPARSEDEF import *
import sys

prebuff = """
#define __i386__ 1
#define __linux__ 1
#define __STDC__ 1
#define linux linux
#define cond_syscall(x)
#define __GNUC__ 2
#define __GNUC_MINOR__ 95
#define __func__ \"function\"
#define __extension__
#define __pragma__
#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))
#define __builtin_va_arg(arg,type)  ((type)0)
#define __builtin_va_end(arg)

#define __CHECKER__ 1
extern void *__builtin_memcpy(void *, const void *, unsigned long);
extern void * __builtin_return_address(int);
"""

init_symbols()
#create_builtin_stream()
token = None
fd = open(sys.argv[1])
token = tokenize(sys.argv[1], fd.fileno())
token = tokenize_buffer(prebuff, token)
token = preprocess(token)
used_list = translation_unit(token)

def cleanup_up(sym, parent, flags):
    check_duplicates(sym)
    evaluate_symbol(sym)
    expand_symbol(sym)

symbol_iterate(used_list, cleanup_up, None)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: Weird sparse bug? ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Weird sparse bug?
Date: Sat, 06 Sep 2003 04:47:02 +0000
Message-ID: <Pine.LNX.4.44.0309052139150.1676-100000 () home ! osdl ! org>
--------------------

[ Some other sparse users cc'd, just because once I did the ugly ascii 
  barfic, I decided that I might as well educate others too ]

On Fri, 5 Sep 2003, Jeff Garzik wrote:
> 
> When I evaluate a 1-line C file
> 
> 	short y[3] = { 13, -23, 96 };
> 
> I see
> 
> entry->type = EXPR_VALUE (correct)
> entry->type = EXPR_POS
> entry->type = EXPR_POS

That is correct.

The EXPR_POS is "this is not at offset 0, it is at offset X".

So the initializer _should_ look like

	EXPR_INITIALIZER
	   |
	   +---------------------+-----------------------+
	   |                     |                       |
	EXPR_VALUE            EXPR_POS               EXPR_POS
	   |                     |                       |
	(int) 13                 +---------+             +--------+
	                         |         |             |        |
				off=4   EXPR_VALUE     off=8    EXPR_VALUE
	                                   |                      |
	                                (int) -23               (int) 96

Note that the reason for this is that the initializer _could_ actually 
look like this instead:

	int a[100] = { [2] = 13, [5] = -23, [90] = 96 };

See? In that case there are _three_ EXPR_POS expressions (offsets 8, 20, 
and 360, respectively), since none of them are without offsets.

In fact, you can also do

	int a[3] = { [2] = 1, [1] = 6, [0] = 7 };

and now the _last_ one is the one that doesn't have an EXPR_POS associated 
with it (because now the last one is the one that is offset-less).

Of course, there may be a bug somewhere. I didn't actually test any of 
this ;)

		Linus



================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Weird sparse bug?
Date: Sat, 06 Sep 2003 05:34:39 +0000
Message-ID: <Pine.LNX.4.44.0309052222240.3733-100000 () home ! osdl ! org>
--------------------

On Sat, 6 Sep 2003, Jeff Garzik wrote:
> 
> But the "offset 0 is different from all the rest" threw me.  If I had my 
> druthers, I would have hung EXPR_VALUE for offset 0 underneath an 
> EXPR_POS, too.  Because now it's a special case in my iterator ;-)

I wouldn't mind having an EXPR_POS all the time, if that simplifies the 
back-end. I just felt that since it isn't needed, why generate one?

> If you're curious, I'm writing initializer emit code.  Currently 
> show-parse.c will show bytecode insns instead of just a straight value 
> dump, for initializers not inside a function.

Yes. Broken. But initializers are actually one of the hardest parts of 
the C syntax. I spent a _lot_ of thought on how to efficiently parse 
something like

   int function(int a)
   {
	struct {
		int index;
		char *name;
	} array[1000] = {
		[999] = {
			.index = fn_call(a),
			.name = "finish"
		}
	 };

         ...
   }

which is actually a really hard case to generate good code for too. It's
not a static initializer, and you'd actually like to generate code without 
copying a thousand entries around. Ie, the above _should_ generate 
something like this on x86:

	subl $8000,%esp

	# Zero out the first 999 entries
	movl %esp,%edi
	movl $1998,%ecx
	xorl %eax,%eax
	rep stosl

	pushl 8004(%esp)
	call fn_call
	addl $5,%esp

	movl %eax,7992(%esp)		# array[999].index = retval
	movl $Lxxxx,7996(%esp)		# array[999].name = "finish"


but that's hard as hell to do. Even though it looks like a "simple" 
initializer expression.

You need to sort the initializer list according to EXPR_POS, for example. 
(I'd like that in the front end, since I'd want to do it to be able to 
warn sanely about

	int array[6] = { [3] = 1, [3] = 2 };

kind of duplicate entry things too..

So my "show-parse.c" just punts on it _completely_. I wrote show-parse.c 
just to be able to see that my parse was somewhat successful.

		Linus



================================================================================


################################################################################

=== Thread: [PATCH] Re: IRC discussion about handle_switch ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: [PATCH] Re: IRC discussion about handle_switch
Date: Tue, 09 Sep 2003 17:12:26 +0000
Message-ID: <20030909171226.GD919 () conectiva ! com ! br>
--------------------
Em Tue, Sep 09, 2003 at 09:47:46AM -0700, Linus Torvalds escreveu:
> 
> On Tue, 9 Sep 2003, Arnaldo Carvalho de Melo wrote:
> >
> > Linus, OK?
> 
> Ok.
> 
> 		Linus

Please apply.

You can import this changeset into BK by piping this whole message to:
'| bk receive [path to repository]' or apply the patch as usual.

===================================================================


ChangeSet@1.425, 2003-09-09 17:01:09-03:00, acme@parisc.kerneljanitors.org
  o split handle_switch, to make it more lib friendly
  
  I.e. a more complex tool will need a different handle_switch,
  so make the handling of each switch a function that can be
  used by such specialized handle_switch while keeping handle_switch
  for simpler tools.


 lib.c |  100 ++++++++++++++++++++++++++++++++++++++++--------------------------
 1 files changed, 61 insertions(+), 39 deletions(-)


diff -Nru a/lib.c b/lib.c
--- a/lib.c	Tue Sep  9 17:05:24 2003
+++ b/lib.c	Tue Sep  9 17:05:24 2003
@@ -326,52 +326,74 @@
 	va_end(args);
 }
 
-char **handle_switch(char *arg, char **next)
+char **handle_switch_D(char *arg, char **next)
 {
-	switch (*arg) {
-	case 'D': {
-		const char *name = arg+1;
-		const char *value = "";
-		for (;;) {
-			char c;
-			c = *++arg;
-			if (!c)
-				break;
-			if (isspace(c) || c == '=') {
-				*arg = '\0';
-				value = arg+1;
-				break;
-			}
+	const char *name = arg + 1;
+	const char *value = "";
+	for (;;) {
+		char c;
+		c = *++arg;
+		if (!c)
+			break;
+		if (isspace(c) || c == '=') {
+			*arg = '\0';
+			value = arg + 1;
+			break;
 		}
-		add_pre_buffer("#define %s %s\n", name, value);
-		return next;
 	}
+	add_pre_buffer("#define %s %s\n", name, value);
+	return next;
+}
 
-	case 'E':
-		preprocess_only = 1;
-		return next;
-	case 'v':
-		verbose = 1;
-		return next;
-	case 'I':
-		add_pre_buffer("#add_include \"%s/\"\n", arg+1);
-		return next;
-	case 'i':
-		if (*next && !strcmp(arg, "include")) {
-			char *name = *++next;
-			int fd = open(name, O_RDONLY);
-			include_fd = fd;
-			include = name;
-			if (fd < 0)
-				perror(name);
-			return next;
-		}
-	/* Fallthrough */
+char **handle_switch_E(char *arg, char **next)
+{
+	preprocess_only = 1;
+	return next;
+}
+
+char **handle_switch_v(char *arg, char **next)
+{
+	verbose = 1;
+	return next;
+}
+char **handle_switch_I(char *arg, char **next)
+{
+	add_pre_buffer("#add_include \"%s/\"\n", arg + 1);
+	return next;
+}
+
+char **handle_switch_i(char *arg, char **next)
+{
+	if (*next && !strcmp(arg, "include")) {
+		char *name = *++next;
+		int fd = open(name, O_RDONLY);
+
+		include_fd = fd;
+		include = name;
+		if (fd < 0)
+			perror(name);
+	}
+	return next;
+}
+
+char **handle_switch(char *arg, char **next)
+{
+	char **rc = next;
+
+	switch (*arg) {
+	case 'D': rc = handle_switch_D(arg, next); break;
+	case 'E': rc = handle_switch_E(arg, next); break;
+	case 'v': rc = handle_switch_v(arg, next); break;
+	case 'I': rc = handle_switch_I(arg, next); break;
+	case 'i': rc = handle_switch_i(arg, next); break;
 	default:
-		/* Ignore unknown command line options - they're probably gcc switches */
+		/*
+		 * Ignore unknown command line options:
+		 * they're probably gcc switches
+		 */
 		break;
 	}
-	return next;
+	return rc;
 }
 
 void create_builtin_stream(void)

===================================================================
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================


################################################################################

=== Thread: [PATCH] [SPARSE] enum symbol missing ident ===

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: [PATCH] [SPARSE] enum symbol missing ident
Date: Sat, 20 Sep 2003 21:24:06 +0000
Message-ID: <1064093046.3f6cc5768648e () www ! mailshell ! com>
--------------------
Hi Linus,

I notice that the enum symbol's ident pointer is always NULL. A
short chase show that parse_enum_declaration() did not assign
symbol->ident.

I make it happen in bind_symbol() and simply some calling case.

Chris

===== parse.c 1.108 vs edited =====
--- 1.108/parse.c	Sat Aug 02 19:45:09 2003
+++ edited/parse.c	Sat Sep 20 14:02:08 2003
@@ -60,7 +60,6 @@
 	struct symbol *sym = lookup_symbol(token->ident, ns);
 	if (!sym) {
 		sym = alloc_symbol(token->pos, type);
-		sym->ident = token->ident;
 		bind_symbol(sym, token->ident, ns);
 		if (type == SYM_LABEL)
 			fn_local_symbol(sym);
@@ -645,10 +644,8 @@
 
 	start_symbol_scope();
 	cont = alloc_symbol(stmt->pos, SYM_NODE);
-	cont->ident = &continue_ident;
 	bind_symbol(cont, &continue_ident, NS_ITERATOR);
 	brk = alloc_symbol(stmt->pos, SYM_NODE);
-	brk->ident = &break_ident;
 	bind_symbol(brk, &break_ident, NS_ITERATOR);
 
 	stmt->type = STMT_ITERATOR;
@@ -670,7 +667,6 @@
 
 	start_function_scope();
 	ret = alloc_symbol(sym->pos, SYM_NODE);
-	ret->ident = &return_ident;
 	ret->ctype = sym->ctype.base_type->ctype;
 	ret->ctype.modifiers &= ~(MOD_STORAGE | MOD_CONST | MOD_VOLATILE | MOD_INLINE | MOD_ADDRESSABLE | MOD_NOCAST | MOD_NODEREF | MOD_ACCESSED | MOD_TOPLEVEL);
 	ret->ctype.modifiers |= (MOD_AUTO | MOD_REGISTER);
@@ -704,11 +700,9 @@
 
 	start_symbol_scope();
 	brk = alloc_symbol(stmt->pos, SYM_NODE);
-	brk->ident = &break_ident;
 	bind_symbol(brk, &break_ident, NS_ITERATOR);
 
 	switch_case = alloc_symbol(stmt->pos, SYM_NODE);
-	switch_case->ident = &case_ident;
 	bind_symbol(switch_case, &case_ident, NS_ITERATOR);
 	switch_case->stmt = stmt;
 
@@ -1119,8 +1113,6 @@
 	/* Just a type declaration? */
 	if (!ident)
 		return expect(token, ';', "end of type declaration");
-
-	decl->ident = ident;
 
 	/* type define declaration? */
 	is_typedef = (ctype.modifiers & MOD_TYPEDEF) != 0;
===== symbol.c 1.76 vs edited =====
--- 1.76/symbol.c	Sun Aug 24 16:50:07 2003
+++ edited/symbol.c	Sat Sep 20 13:57:24 2003
@@ -308,6 +308,7 @@
 	sym->namespace = ns;
 	sym->next_id = ident->symbols;
 	ident->symbols = sym;
+	sym->ident = ident;
 	sym->id_list = &ident->symbols;
 
 	scope = block_scope;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [PATCH] [SPARSE] minor fix for use non-initilized pointer ===

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: [PATCH] [SPARSE] minor fix for use non-initilized pointer
Date: Tue, 09 Sep 2003 07:02:17 +0000
Message-ID: <1063090937.3f5d7af999d01 () www ! mailshell ! com>
--------------------
I hit a segment fault on compiling a big header file. This patch fix it.

Chris


===== parse.c 1.108 vs edited =====
--- 1.108/parse.c       Sat Aug 02 19:45:09 2003
+++ edited/parse.c      Sat Sep 06 14:26:08 2003
@@ -954,6 +954,7 @@
 static struct token *parameter_type_list(struct token *token, struct symbol *fn)
 {
        struct symbol_list **list = &fn->arguments;
+       *list = NULL;
        for (;;) {
                struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] [SPARSE] minor fix for use non-initilized pointer
Date: Tue, 09 Sep 2003 16:11:38 +0000
Message-ID: <Pine.LNX.4.44.0309090907140.17041-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003 chrisl_sparse@cli.mailshell.com wrote:
>
> I hit a segment fault on compiling a big header file. This patch fix it.

There's something else wrong here.

This implies that "fn->arguments" was non-NULL when calling into 
"parameter_type_list()". But that "struct symbol" was _just_ allocated 
from within "indirect()" with "alloc_symbol(pos, type);", and all the 
allocation functions should guarantee that their allocations are zeroed 
out. 

So this is either due to an allocator function bug, or due to random 
memory scribbling, and your patch to zero out fn->arguments looks like it 
is just papering over the _real_ bug.

(The current allocators guarantee zeroed memory because "blob_alloc()" 
will do a new private mmap, so that's where the zeroes come from, in case 
you wonder - there is no "memset()" there).

Do you have a test-case for the bug?

		Linus


> --- 1.108/parse.c       Sat Aug 02 19:45:09 2003
> +++ edited/parse.c      Sat Sep 06 14:26:08 2003
> @@ -954,6 +954,7 @@
>  static struct token *parameter_type_list(struct token *token, struct symbol *fn)
>  {
>         struct symbol_list **list = &fn->arguments;
> +       *list = NULL;
>         for (;;) {
>                 struct symbol *sym = alloc_symbol(token->pos, SYM_NODE);
> 

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: Re: [PATCH] [SPARSE] minor fix for use non-initilized pointer
Date: Tue, 09 Sep 2003 20:12:04 +0000
Message-ID: <1063138324.3f5e3414b98df () www ! mailshell ! com>
--------------------


>From Linus Torvalds <torvalds@osdl.org> on 9 Sep 2003:

> 
> On Tue, 9 Sep 2003 chrisl_sparse@cli.mailshell.com wrote:
> 
> So this is either due to an allocator function bug, or due to random 
> memory scribbling, and your patch to zero out fn->arguments looks like
> it 
> is just papering over the _real_ bug.

I saw the memory is not zero out after blob_alloc().

> 
> (The current allocators guarantee zeroed memory because "blob_alloc()" 
> will do a new private mmap, so that's where the zeroes come from, in
> case 
> you wonder - there is no "memset()" there).
> 

Ha, I see. I am using cygwin to compile sparse on windows. The cygwin
version of mmap anonymous pages seems buggy. I haven't look at cygwin's
code but I see some memory allocate from mmap is not zeroed.

It should be a bug of cygwin.

> Do you have a test-case for the bug?

It is compiling the windows header files. I try to build a tool
to generate python module source file from the C header file.
Some thing like bgen (not SWIG).

The good news is that I can compile winddk.h and wdm.h now.

Any chance for sparse to accept some VC compatable features patch
cover by some configure option?

e.g. __asm { mov eax, ebx }; stdcall; cdecl etc.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] [SPARSE] minor fix for use non-initilized pointer
Date: Tue, 09 Sep 2003 20:21:21 +0000
Message-ID: <Pine.LNX.4.44.0309091315380.30594-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003 chrisl_sparse@cli.mailshell.com wrote:
> 
> Any chance for sparse to accept some VC compatable features patch
> cover by some configure option?
> 
> e.g. __asm { mov eax, ebx }; stdcall; cdecl etc.

Sure. As long as the parsing code itself is clean, I don't have any 
trouble with that. It would need to add flags to select the extended parse 
(with the default just being "gcc-like").

As to the cygwin mmap() bug - feel free to add a "memset(xx, 0, size)" to 
the allocators (and it should really be done _there_, because other parts 
of sparse also depend on the fact that allocations are zeroed out 
automatically). 

But make it depend on cygwin brokenness, ie do something like this:

  new file common.h:

	#ifdef __CYGWIN__ /* I have no clue what the marker should be */
	  /* Cygwin mmap() is broken */
	  #define clear_mmap(start, size) memset((start), 0, (size))
	#else
	  /* anonymous mmap's start out zero already */
	  #define clear_mmap(start, size) do { } while (0)
	#endif

and then make the blob functions just use "clear_mmap()".

I hate #ifdef's in source code, so please just make it do different things
like this it through clean abstractions instead.

(And if there are a lot of them, you might want to split up the different 
"architectures" into separate "common-xxx.h files instead, and have the 
configuration phase just create a link or something).

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: <chrisl_sparse () cli ! mailshell ! com>
To: linux-sparse
Subject: Re: [PATCH] [SPARSE] minor fix for use non-initilized pointer
Date: Wed, 10 Sep 2003 17:06:21 +0000
Message-ID: <1063213581.3f5f5a0d46cf1 () www ! mailshell ! com>
--------------------


>From Linus Torvalds <torvalds@osdl.org> on 9 Sep 2003:

> 
> Sure. As long as the parsing code itself is clean, I don't have any 
> trouble with that. It would need to add flags to select the extended
> parse 
> (with the default just being "gcc-like").

Great. I will get back to you on the this and the cygwin mmap fix.

> 
> 	#ifdef __CYGWIN__ /* I have no clue what the marker should be */

This is indeed the correct marker.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================


################################################################################

=== Thread: [PATCH] make compile.c use the generic do_switch and create_builtin_stream ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: [PATCH] make compile.c use the generic do_switch and create_builtin_stream
Date: Tue, 09 Sep 2003 02:22:20 +0000
Message-ID: <20030909022218.GA7451 () conectiva ! com ! br>
--------------------
Linus,

	Please pull from:

bk://kernel.bkbits.net/acme/sparse.acme

- Arnaldo

You can import this changeset into BK by piping this whole message to:
'| bk receive [path to repository]' or apply the patch as usual.

===================================================================


ChangeSet@1.421, 2003-09-09 02:13:20-03:00, acme@parisc.kerneljanitors.org
  o make compile.c use the generic do_switch and create_builtin_stream


 compile.c |   45 ++++++++-------------------------------------
 1 files changed, 8 insertions(+), 37 deletions(-)


diff -Nru a/compile.c b/compile.c
--- a/compile.c	Tue Sep  9 02:14:56 2003
+++ b/compile.c	Tue Sep  9 02:14:56 2003
@@ -25,35 +25,6 @@
 
 extern void emit_unit(const char *basename, struct symbol_list *list);
 
-static void do_switch(char *arg)
-{
-	switch (*arg) {
-	case 'D': {
-		const char *name = arg+1;
-		const char *value = "";
-		for (;;) {
-			char c;
-			c = *++arg;
-			if (!c)
-				break;
-			if (isspace(c) || c == '=') {
-				*arg = '\0';
-				value = arg+1;
-				break;
-			}
-		}
-		add_pre_buffer("#define %s %s\n", name, value);
-		return;
-	}
-
-	case 'I':
-		add_pre_buffer("#add_include \"%s/\"\n", arg+1);
-		return;
-	default:
-		fprintf(stderr, "unknown switch '%s'\n", arg);
-	}
-}
-
 static void clean_up_symbol(struct symbol *sym, void *_parent, int flags)
 {
 	evaluate_symbol(sym);
@@ -63,25 +34,25 @@
 int main(int argc, char **argv)
 {
 	int i, fd;
-	char *basename, *filename = NULL;
+	char *basename, *filename = NULL, **args;
 	struct token *token;
 
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
 
-	// Stupid defines to make various headers happy
-	add_pre_buffer("#define __GNUC__ 2\n");
-	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
+	create_builtin_stream();
 
-	for (i = 1; i < argc; i++) {
-		char *arg = argv[i];
+	args = argv;
+	for (;;) {
+		char *arg = *++args;
+		if (!arg)
+			break;
 		if (arg[0] == '-') {
-			do_switch(arg+1);
+			args = handle_switch(arg + 1, args);
 			continue;
 		}
 		filename = arg;
 	}
-
 
 	basename = strrchr(filename, '/');
 	if (!basename)

===================================================================


================================================================================


################################################################################

=== Thread: [PATCH][SPARSE] remove extern __builtin declarations from create_builtin_stream ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: [PATCH][SPARSE] remove extern __builtin declarations from create_builtin_stream
Date: Tue, 09 Sep 2003 16:16:59 +0000
Message-ID: <20030909161658.GA919 () conectiva ! com ! br>
--------------------
Hi Linus,

	Please consider pulling from:

bk://kernel.bkbits.net/acme/sparse.acme

	Now there are two outstanding changesets there, the previous one just
converted Jeff's compile.c to use create_builtin_stream. Please let me know
if you disagree with any or all of these two changesets.

- Arnaldo

You can import this changeset into BK by piping this whole message to:
'| bk receive [path to repository]' or apply the patch as usual.

===================================================================


ChangeSet@1.422, 2003-09-09 16:08:35-03:00, acme@parisc.kerneljanitors.org
  o remove extern __builtin declarations from create_builtin_stream
  
  They alter the generated output, so I think its better to add it just on
  check.


 check.c |    2 ++
 lib.c   |    2 --
 2 files changed, 2 insertions(+), 2 deletions(-)


diff -Nru a/check.c b/check.c
--- a/check.c	Tue Sep  9 16:09:01 2003
+++ b/check.c	Tue Sep  9 16:09:01 2003
@@ -39,6 +39,8 @@
 	init_symbols();
 
 	create_builtin_stream();
+	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, unsigned long);\n");
+	add_pre_buffer("extern void * __builtin_return_address(int);\n");
 
 	args = argv;
 	for (;;) {
diff -Nru a/lib.c b/lib.c
--- a/lib.c	Tue Sep  9 16:09:01 2003
+++ b/lib.c	Tue Sep  9 16:09:01 2003
@@ -387,8 +387,6 @@
 	add_pre_buffer("#define __func__ \"function\"\n");
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
-	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, unsigned long);\n");
-	add_pre_buffer("extern void * __builtin_return_address(int);\n");
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
 	add_pre_buffer("#define __builtin_va_end(arg)\n");	

===================================================================
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================


################################################################################

=== Thread: [RFC] initstr is mostly ready for prime time! :-) ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: [RFC] initstr is mostly ready for prime time! :-)
Date: Tue, 09 Sep 2003 22:26:21 +0000
Message-ID: <20030909222620.GJ919 () conectiva ! com ! br>
--------------------
Hi,

	I wrote a tool to automatically move strings in __init functions to
__initdata, ditto for __exit/__exitdata, please take a look and please, please
comment on it :-)

	In the next post I'll show some results.

	First the patches (Linus, I'll work on your suggestions, just wanted
to see initstr work first :) ) to sparse, needed to recognize __attribute__
(section...):

===== parse.c 1.108 vs edited =====
--- 1.108/parse.c	Sat Aug  2 23:45:09 2003
+++ edited/parse.c	Tue Sep  9 17:53:06 2003
@@ -213,13 +213,20 @@
 		}
 		return "expected context mask and value";
 	}
+	if (match_string_ident(attribute, "section") ||
+	    match_string_ident(attribute, "__section__")) {
+		if (!expr)
+			return "expected section name";
+		if (expr->type != EXPR_STRING)
+			return "expected a string";
+		ctype->section = expr->string;
+		ctype->modifiers |= MOD_SECTION;
+		return NULL;
+	}
 
 	/* Throw away for now.. */
 	if (match_string_ident(attribute, "format") ||
 	    match_string_ident(attribute, "__format__"))
-		return NULL;
-	if (match_string_ident(attribute, "section") ||
-	    match_string_ident(attribute, "__section__"))
 		return NULL;
 	if (match_string_ident(attribute, "unused") ||
 	    match_string_ident(attribute, "__unused__"))
===== parse.h 1.38 vs edited =====
--- 1.38/parse.h	Sat Aug  2 23:45:09 2003
+++ edited/parse.h	Tue Sep  9 16:30:01 2003
@@ -91,6 +91,9 @@
 extern int show_expression(struct expression *);
 extern void translation_unit(struct token *, struct symbol_list **);
 
+extern struct token *attribute_specifier(struct token *token,
+					 struct ctype *ctype);
+
 extern struct symbol *ctype_integer(unsigned int spec);
 extern struct symbol *ctype_fp(unsigned int spec);
 
===== symbol.h 1.71 vs edited =====
--- 1.71/symbol.h	Sun Aug 24 20:49:00 2003
+++ edited/symbol.h	Tue Sep  9 16:30:01 2003
@@ -54,6 +54,7 @@
 	unsigned long modifiers;
 	unsigned long alignment;
 	unsigned int contextmask, context, as;
+	struct string *section;
 	struct symbol *base_type;
 };
 
@@ -134,6 +135,7 @@
 
 #define MOD_LABEL	0x1000000
 #define MOD_ASSIGNED	0x2000000
+#define MOD_SECTION	0x4000000
 
 /* Basic types */
 extern struct symbol	void_type,

---------------------------------------------------------------------------

And the tool:

/*
 * Add __initstr to strings in __init functions
 *
 * Copyright (C) 2003 Arnaldo Carvalho de Melo
 *
 *  Licensed under the Open Software License version 1.1
 */
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>

#include "token.h"
#include "parse.h"
#include "symbol.h"
#include "expression.h"

static int in_init_data_function;
static int in_exit_data_function;
static int wrapping_string;
static int dont_wrap_section_string;
static int scope;

#if 1
#define INIT_STR_BEGIN "({ static char __str[] __attribute__((__section__" \
		 "(\".init.data\")))="
#define EXIT_STR_BEGIN "({ static char __str[] __attribute__((__section__" \
		 "(\".exit.data\")))="
#define INEXIT_STR_END "; __str;})"
#else
#define INIT_STR_BEGIN "__initstr("
#define EXIT_STR_BEGIN "__exitstr("
#define INEXIT_STR_END ")"
#endif

struct symbol *ident_attribute(struct ident *ident)
{
	struct symbol *sym;

	for (sym = ident->symbols; sym; sym = sym->next_id)
		if (sym->ctype.modifiers & MOD_ATTRIBUTE)
			break;
	return sym;
}

static void handle_ident(struct token *token, struct token *next)
{
	struct ctype ct = { 0, };

	if (!ident_attribute(token->ident))
		goto out;

	attribute_specifier(next, &ct);
	if (ct.modifiers & MOD_SECTION) {
		static char sign_init[] = ".init.text";
		static char sign_exit[] = ".exit.text";

		if (ct.section->length == sizeof(sign_init) &&
		    (!memcmp(ct.section->data, sign_init, sizeof(sign_init)) ||
		     !memcmp(ct.section->data, sign_exit, sizeof(sign_exit)))) {
			in_init_data_function = ct.section->data[1] == 'i'; 
			in_exit_data_function = ct.section->data[1] == 'e'; 
			dont_wrap_section_string = 1;
		}
	}
out:
	printf("%s", show_ident(token->ident));
}

void print_init_wrap(const char *s)
{
	if (!dont_wrap_section_string)
		printf("%s", s);
}

void print_exit_wrap(void)
{
	if (dont_wrap_section_string)
		dont_wrap_section_string = 0;
	else
		printf(INEXIT_STR_END);
}

void initstr_create_builtin_stream(void)
{
	add_pre_buffer("#define __i386__ 1\n");
	add_pre_buffer("#define __linux__ 1\n");
	add_pre_buffer("#define __STDC__ 1\n");
	add_pre_buffer("#define linux linux\n");
	add_pre_buffer("#define __GNUC__ 2\n");
	add_pre_buffer("#define __GNUC_MINOR__ 2.95\n");
}

int main(int argc, char **argv)
{
	int fd;
	char *filename = NULL, **args;
	struct token *token;

	if (fd < 0)
		die("No such file: %s", argv[1]);

	init_symbols();
	
	initstr_create_builtin_stream();

	args = argv;
	for (;;) {
		char *arg = *++args;
		if (!arg)
			break;
		if (arg[0] == '-') {
			args = handle_switch(arg + 1, args);
			continue;
		}
		filename = arg;
	}

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		die("No such file: %s", filename);

	// Tokenize the input stream
	token = tokenize(filename, fd, NULL);
	close(fd);
	// Prepend the initial built-in stream
	token = tokenize_buffer(pre_buffer, pre_buffer_size, token);

	token = preprocess(token);

	while (!eof_token(token)) {
		int prec = 1;
		struct token *next = token->next;
		char *separator = "";

		if (next->pos.whitespace)
			separator = " ";
		if (next->pos.newline) {
			separator = "\n\t\t\t\t\t";
			prec = next->pos.pos;
			if (prec > 4)
				prec = 4;
		}
		switch (token_type(token)) {
		case TOKEN_IDENT:
			handle_ident(token, next);
			break;
		case TOKEN_STRING:
			if (!wrapping_string) {
				wrapping_string = 1;
				if (in_init_data_function)
					print_init_wrap(INIT_STR_BEGIN);
				else if (in_exit_data_function)
					print_init_wrap(EXIT_STR_BEGIN);
				else
					wrapping_string = 0;
			}
			printf("%s", show_string(token->string));
			break;
		case TOKEN_SPECIAL:
			switch (token->special) {
			case '{':
				++scope;
				break;
			case '}':
				--scope;
				if (!scope) {
					in_init_data_function = 0;
					in_exit_data_function = 0;
				} else if (scope < 0)
					die("error: parse error before '}' "
					    "token");
				break;
			case ';':
				if (!scope) {
					in_init_data_function = 0;
					in_exit_data_function = 0;
				}
				break;
			}
			printf("%s", show_special(token->special));
			break;
		default:
			printf("%s", show_token(token));
		}
		printf("%.*s", prec, separator);
		token = next;
		if (wrapping_string &&
		    (eof_token(token) || token_type(token) != TOKEN_STRING)) {
			wrapping_string = 0;
			print_exit_wrap();
		}
	}
	putchar('\n');
	return 0;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [RFC] initstr is mostly ready for prime time! :-)
Date: Tue, 09 Sep 2003 22:38:49 +0000
Message-ID: <Pine.LNX.4.44.0309091535580.10257-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003, Arnaldo Carvalho de Melo wrote:
> 
> 	First the patches (Linus, I'll work on your suggestions, just wanted
> to see initstr work first :) ) to sparse, needed to recognize __attribute__
> (section...):

Hmm.

This was one of my original goals of sparse - to work as a "smart 
pre-processor" to gcc (and eventually, of course, have a back-end that is 
so good that we don't need gcc at all ;)

However, doing so really requires getting the parse right. In particular, 
the fact that we have some preprocessor bugs means that we can't use 
sparse as a front-end: it craps out on pci-names.c and other things. At 
least one of the cases shown in validation/*.c happens in the kernel.

So I'm a bit nervous about it, even if I like the concept.

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: Re: [RFC] initstr is mostly ready for prime time! :-)
Date: Tue, 09 Sep 2003 22:44:36 +0000
Message-ID: <20030909224436.GN919 () conectiva ! com ! br>
--------------------
Em Tue, Sep 09, 2003 at 03:38:49PM -0700, Linus Torvalds escreveu:
> 
> On Tue, 9 Sep 2003, Arnaldo Carvalho de Melo wrote:
> > 
> > 	First the patches (Linus, I'll work on your suggestions, just wanted
> > to see initstr work first :) ) to sparse, needed to recognize __attribute__
> > (section...):
> 
> Hmm.
> 
> This was one of my original goals of sparse - to work as a "smart 
> pre-processor" to gcc (and eventually, of course, have a back-end that is 
> so good that we don't need gcc at all ;)

Jeff is working on this one ;)

> However, doing so really requires getting the parse right. In particular, 

So lets get the parse right! ;)

> the fact that we have some preprocessor bugs means that we can't use 
> sparse as a front-end: it craps out on pci-names.c and other things. At 

Humm, trying out this one now... perhaps blacklisting pci-names.c in initstr? ;)

> least one of the cases shown in validation/*.c happens in the kernel.
> 
> So I'm a bit nervous about it, even if I like the concept.

Great, would you accept a patch to have it in the sparse bk repository?

- Arnaldo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [RFC] initstr is mostly ready for prime time! :-)
Date: Wed, 10 Sep 2003 01:07:55 +0000
Message-ID: <3F5E796B.4060003 () pobox ! com>
--------------------
Linus Torvalds wrote:
> This was one of my original goals of sparse - to work as a "smart 
> pre-processor" to gcc (and eventually, of course, have a back-end that is 
> so good that we don't need gcc at all ;)


I'm a big believer in domain-specific languages.  In the past, I have 
wondered what would happen if Linux kernel hackers could have complete 
control over the language front-end.  So has Ben la Haise, and others 
I'm sure.

The Tru64 compiler kit, both front ends and backend (except the C front 
end) are written in BLISS, a compiler-centric language written 
specifically for the Tru64 kit.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] backend fixes ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend fixes
Date: Wed, 10 Sep 2003 22:24:54 +0000
Message-ID: <20030910222454.GA4334 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c |   41 ++++++++++++++++++++---------------------
 1 files changed, 20 insertions(+), 21 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/10 1.432)
   [be] fixes
   
   * remove bogus "toplevel symbol" check I put in.  Needs reworking.
     (broke Hello, World)
   * Don't emit subl/addl %esp stack frame adjustments, if no
     stack frame exists.

<jgarzik@redhat.com> (03/09/10 1.431)
   [be] Don't emit move based on value returned from a function's
   toplevel STMT_COMPOUND.
   
   If a function returns a value, then the C code must have explicit
   'return' statements.  Since we already emit a move when handling
   return statements, that eliminates the need to ever emit a move for
   the non-'return' case.
   
   Of course, incorrect C code can still omit the return statement, in
   which case you're left with a random %eax return value.

<jgarzik@redhat.com> (03/09/10 1.430)
   [be] fix indirect func calls




diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Wed Sep 10 18:21:03 2003
+++ b/compile-i386.c	Wed Sep 10 18:21:03 2003
@@ -574,13 +574,12 @@
 }
 
 /* function epilogue */
-static void emit_func_post(struct symbol *sym, struct storage *ret_val)
+static void emit_func_post(struct symbol *sym)
 {
 	const char *name = show_ident(sym->ident);
 	struct function *f = current_func;
-	struct storage *val;
 	int pseudo_nr = f->pseudo_nr;
-	char pseudo_const[16], jump_target[16];
+	char jump_target[16];
 
 	if (f->str_list)
 		emit_string_list(f);
@@ -591,24 +590,29 @@
 		printf(".globl %s\n", name);
 	printf("\t.type\t%s, @function\n", name);
 	printf("%s:\n", name);
-	sprintf(pseudo_const, "$%d", pseudo_nr * 4);
-	printf("\tsubl\t%s, %%esp\n", pseudo_const);
 
-	/* function epilogue */
+	if (pseudo_nr) {
+		char pseudo_const[16];
 
-	if (ret_val) {
-		/* FIXME: mem operand hardcoded at 32 bits */
-		emit_move(ret_val, REG_EAX, NULL, NULL, 0);
+		sprintf(pseudo_const, "$%d", pseudo_nr * 4);
+		printf("\tsubl\t%s, %%esp\n", pseudo_const);
 	}
 
+	/* function epilogue */
+
 	/* jump target for 'return' statements */
 	sprintf(jump_target, ".L%d:\n", f->ret_target);
 	push_text_atom(f, jump_target);
 
-	val = new_storage(STOR_VALUE);
-	val->value = (long long) (pseudo_nr * 4);
+	if (pseudo_nr) {
+		struct storage *val;
+
+		val = new_storage(STOR_VALUE);
+		val->value = (long long) (pseudo_nr * 4);
+
+		insn("addl", val, REG_ESP, NULL, ATOM_FREE_OP1);
+	}
 
-	insn("addl", val, REG_ESP, NULL, ATOM_FREE_OP1);
 	insn("ret", NULL, NULL, NULL, 0);
 
 	/* output everything to stdout */
@@ -1180,9 +1184,6 @@
 	struct expression *expr = sym->initializer;
 	struct symbol_private *priv = sym->aux;
 
-	if (sym->ctype.modifiers & (MOD_TOPLEVEL | MOD_EXTERN | MOD_STATIC))
-		expr = NULL;
-
 	if (priv == NULL) {
 		priv = calloc(1, sizeof(*priv));
 		sym->aux = priv;
@@ -1296,11 +1297,9 @@
 	case SYM_FN: {
 		struct statement *stmt = type->stmt;
 		if (stmt) {
-			struct storage *val;
-
 			emit_func_pre(sym);
-			val = x86_statement(stmt);
-			emit_func_post(sym, val);
+			x86_statement(stmt);
+			emit_func_post(sym);
 		}
 		break;
 	}
@@ -1521,7 +1520,7 @@
 		fncall = x86_expression(fn);
 		emit_move(fncall, REG_EAX, fn->ctype, NULL, 0);
 
-		strcpy(s, "\tcall\t*%%eax\n");
+		strcpy(s, "\tcall\t*%eax\n");
 		push_text_atom(f, s);
 	}
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] backend update ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend update
Date: Tue, 09 Sep 2003 02:46:33 +0000
Message-ID: <20030909024633.GA12567 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.hacking

This will update the following files:

 compile-i386.c |  213 ++++++++++++++++++++++++++++++++++++++++++---------------
 1 files changed, 159 insertions(+), 54 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/08 1.422)
   [be] generate code for "x ? 1 : 0" type conditionals

<jgarzik@redhat.com> (03/09/08 1.421)
   [be] comparison, signedness, and operand size update
   
   * rename emit_move() to emit_copy() (it copies stack slotX -> slotY)
   * create a size- and sign-aware emit_move()
   * create opbits(), to help determine instruction suffix
     based on memory operand
   * update emit_compare() to be operand sign- and size-aware
   * update emit_compare() to use SETcc instead of CMOVcc.
     (suggested by Arjan van de Ven)





diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Mon Sep  8 22:43:31 2003
+++ b/compile-i386.c	Mon Sep  8 22:43:31 2003
@@ -132,33 +132,47 @@
 	{ "%ecx" },
 	{ "%edx" },
 	{ "%esp" },
+	{ "%dl" },
 };
 
 static struct storage hardreg_storage_table[] = {
-	{
+	{	/* eax */
 		.type = STOR_REG,
 		.reg = &reg_info_table[0],
 	},
-	{
+
+	{	/* ecx */
 		.type = STOR_REG,
 		.reg = &reg_info_table[1],
 	},
-	{
+
+	{	/* edx */
 		.type = STOR_REG,
 		.reg = &reg_info_table[2],
 	},
-	{
+
+	{	/* esp */
 		.type = STOR_REG,
 		.reg = &reg_info_table[3],
 	},
+
+	{	/* dl */
+		.type = STOR_REG,
+		.reg = &reg_info_table[4],
+	},
 };
 
 #define REG_EAX (&hardreg_storage_table[0])
 #define REG_ECX (&hardreg_storage_table[1])
 #define REG_EDX (&hardreg_storage_table[2])
 #define REG_ESP (&hardreg_storage_table[3])
+#define REG_DL	(&hardreg_storage_table[4])
 
 
+static void emit_move(struct storage *src, struct storage *dest,
+		      struct symbol *ctype, const char *comment,
+		      unsigned long flags);
+static int type_is_signed(struct symbol *sym);
 static struct storage *x86_address_gen(struct expression *expr);
 static struct storage *x86_symbol_expr(struct symbol *sym);
 static void x86_symbol(struct symbol *sym);
@@ -538,8 +552,10 @@
 	push_text_atom(f, jump_target);
 
 	/* function prologue */
-	if (ret_val)
-		insn("movl", ret_val, REG_EAX, NULL, 0);
+	if (ret_val) {
+		/* FIXME: mem operand hardcoded at 32 bits */
+		emit_move(ret_val, REG_EAX, NULL, NULL, 0);
+	}
 
 	val = new_storage(STOR_VALUE);
 	val->value = (long long) (pseudo_nr * 4);
@@ -757,16 +773,13 @@
 	emit_unit_post();
 }
 
-static void emit_move(struct expression *dest_expr, struct storage *dest,
-		      struct storage *src, int bits)
+static void emit_copy(struct storage *src,  struct symbol *src_ctype,
+		      struct storage *dest, struct symbol *dest_ctype)
 {
 	/* FIXME: Bitfield move! */
 
-	/* FIXME: pay attention to arg 'bits' */
-	insn("movl", src, REG_EAX, NULL, 0);
-
-	/* FIXME: pay attention to arg 'bits' */
-	insn("movl", REG_EAX, dest, NULL, 0);
+	emit_move(src, REG_EAX, src_ctype, "begin copy ...", 0);
+	emit_move(REG_EAX, dest, dest_ctype, "... end copy", 0);
 }
 
 static void emit_store(struct expression *dest_expr, struct storage *dest,
@@ -792,45 +805,123 @@
 	stor_sym_init(sym);
 }
 
+static const char *opbits(const char *insn, unsigned int bits)
+{
+	static char opbits_str[32];
+	char c;
+
+	switch (bits) {
+	case 8:	 c = 'b'; break;
+	case 16: c = 'w'; break;
+	case 32: c = 'l'; break;
+	case 64: c = 'q'; break;
+	default: assert(0); break;
+	}
+
+	sprintf(opbits_str, "%s%c", insn, bits);
+
+	return opbits_str;
+}
+
+static void emit_move(struct storage *src, struct storage *dest,
+		      struct symbol *ctype, const char *comment,
+		      unsigned long flags)
+{
+	unsigned int bits;
+	unsigned int is_signed;
+	unsigned int is_dest = (src->type == STOR_REG);
+	const char *opname;
+
+	if (ctype) {
+		bits = ctype->bit_size;
+		is_signed = type_is_signed(ctype);
+	} else {
+		bits = 32;
+		is_signed = 0;
+	}
+
+	if ((dest->type == STOR_REG) && (src->type == STOR_REG)) {
+		insn("mov", src, dest, NULL, 0);
+		return;
+	}
+
+	switch (bits) {
+	case 8:
+		if (is_dest)
+					opname = "movb";
+		else {
+			if (is_signed)	opname = "movsxb";
+			else		opname = "movzxb";
+		}
+		break;
+	case 16:
+		if (is_dest)
+					opname = "movw";
+		else {
+			if (is_signed)	opname = "movsxw";
+			else		opname = "movzxw";
+		}
+		break;
+
+	case 32:			opname = "movl";	break;
+	case 64:			opname = "movq";	break;
+
+	default:			assert(0);		break;
+	}
+
+	insn(opname, src, dest, comment, flags);
+}
+
 static struct storage *emit_compare(struct expression *expr)
 {
 	struct storage *left = x86_expression(expr->left);
 	struct storage *right = x86_expression(expr->right);
-	struct storage *new, *val;
+	struct storage *new;
 	const char *opname = NULL;
+	unsigned int is_signed = type_is_signed(expr->left->ctype); /* FIXME */
+	unsigned int right_bits = expr->right->ctype->bit_size;
 
 	switch(expr->op) {
-	case '<':		opname = "cmovl";	break;
-	case '>':		opname = "cmovg";	break;
-	case SPECIAL_LTE:	opname = "cmovle";	break;
-	case SPECIAL_GTE:	opname = "cmovge";	break;
-	case SPECIAL_EQUAL:	opname = "cmove";	break;
-	case SPECIAL_NOTEQUAL:	opname = "cmovne";	break;
-	default:		assert(0);		break;
-	}
+	case '<':
+		if (is_signed)	opname = "setl";
+		else		opname = "setb";
+		break;
+	case '>':
+		if (is_signed)	opname = "setg";
+		else		opname = "seta";
+		break;
+	case SPECIAL_LTE:
+		if (is_signed)	opname = "setle";
+		else		opname = "setbe";
+		break;
+	case SPECIAL_GTE:
+		if (is_signed)	opname = "setge";
+		else		opname = "setae";
+		break;
 
-	/* init ECX to 1 */
-	val = new_storage(STOR_VALUE);
-	val->value = 1;
-	insn("movl", val, REG_ECX, "EXPR_COMPARE", ATOM_FREE_OP1);
+	case SPECIAL_EQUAL:	opname = "sete";	break;
+	case SPECIAL_NOTEQUAL:	opname = "setne";	break;
+
+	default:
+		assert(0);
+		break;
+	}
 
 	/* init EDX to 0 */
-	insn("xorl", REG_EDX, REG_EDX, NULL, 0);
+	insn("xor", REG_EDX, REG_EDX, "begin EXPR_COMPARE", 0);
 
-	/* FIXME: don't hardcode operand size */
 	/* move op1 into EAX */
-	insn("movl", left, REG_EAX, NULL, 0);
+	emit_move(left, REG_EAX, expr->left->ctype, NULL, 0);
 
-	/* perform comparison, EAX (op1) and op2 */
-	insn("cmpl", right, REG_EAX, NULL, 0);
+	/* perform comparison, RHS (op1, right) and LHS (op2, EAX) */
+	insn(opbits("cmp", right_bits), right, REG_EAX, NULL, 0);
 
-	/* store result of operation, 0 or 1, in EDX using CMOV */
-	/* FIXME: does this need an operand size suffix? */
-	insn(opname, REG_ECX, REG_EDX, NULL, 0);
+	/* store result of operation, 0 or 1, in DL using SETcc */
+	insn(opname, REG_DL, NULL, NULL, 0);
 
-	/* finally, store the result (EDX) in a new pseudo / stack slot */
+	/* finally, store the result (DL) in a new pseudo / stack slot */
 	new = new_pseudo();
-	insn("movl", REG_EDX, new, "end EXPR_COMPARE", 0);
+	emit_move(REG_EDX, new, NULL, "end EXPR_COMPARE", 0);
 
 	return new;
 }
@@ -970,7 +1061,7 @@
 	if (postop) {
 		struct storage *new = new_pseudo();
 
-		emit_move(NULL, new, addr, 1234 /* intentionally bogus */);
+		emit_copy(addr, expr->unop->ctype, new, NULL);
 
 		retval = new;
 	} else
@@ -1002,6 +1093,35 @@
 	return val;
 }
 
+static struct storage *emit_conditional_expr(struct expression *expr)
+{
+	struct storage *cond = x86_expression(expr->conditional);
+	struct storage *true = x86_expression(expr->cond_true);
+	struct storage *false = x86_expression(expr->cond_false);
+	struct storage *new = new_pseudo();
+
+	if (!true)
+		true = cond;
+
+	emit_move(cond,  REG_EAX, expr->conditional->ctype,
+		  "begin EXPR_CONDITIONAL", 0);
+	emit_move(true,  REG_ECX, expr->cond_true->ctype,   NULL, 0);
+	emit_move(false, REG_EDX, expr->cond_false->ctype,  NULL, 0);
+
+	/* test EAX (for zero/non-zero) */
+	insn("test", REG_EAX, REG_EAX, NULL, 0);
+
+	/* if false, move EDX to ECX */
+	insn("cmovz", REG_EDX, REG_ECX, NULL, 0);
+
+	/* finally, store the result (ECX) in a new pseudo / stack slot */
+	new = new_pseudo();
+	emit_move(REG_ECX, new, expr->ctype, "end EXPR_CONDITIONAL", 0);
+	/* FIXME: we lose type knowledge of expression result at this point */
+
+	return new;
+}
+
 static void x86_struct_member(struct symbol *sym, void *data, int flags)
 {
 	if (flags & ITERATE_FIRST)
@@ -1340,7 +1460,7 @@
 	bits = expr->ctype->bit_size;
 	val = x86_expression(expr->right);
 	addr = x86_address_gen(target);
-	emit_move(target, addr, val, bits);
+	emit_copy(val, expr->right->ctype, addr, expr->left->ctype);
 	return val;
 }
 
@@ -1472,21 +1592,6 @@
 	return new;
 }
 
-static struct storage *x86_conditional_expr(struct expression *expr)
-{
-	struct storage *cond = x86_expression(expr->conditional);
-	struct storage *true = x86_expression(expr->cond_true);
-	struct storage *false = x86_expression(expr->cond_false);
-	struct storage *new = new_pseudo();
-
-	if (!true)
-		true = cond;
-	printf("[v%d]\tcmov.%d\t\tv%d,v%d,v%d\n",
-		cond->pseudo, expr->ctype->bit_size, new->pseudo,
-		true->pseudo, false->pseudo);
-	return new;
-}
-
 static struct storage *x86_statement_expr(struct expression *expr)
 {
 	return x86_statement(expr->statement);
@@ -1597,7 +1702,7 @@
 		x86_initializer_expr(expr, expr->ctype);
 		return NULL;
 	case EXPR_CONDITIONAL:
-		return x86_conditional_expr(expr);
+		return emit_conditional_expr(expr);
 	case EXPR_STATEMENT:
 		return x86_statement_expr(expr);
 	case EXPR_LABEL:
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] backend update
Date: Tue, 09 Sep 2003 03:02:07 +0000
Message-ID: <3F5D42AF.1010009 () pobox ! com>
--------------------
Jeff Garzik wrote:
> Linus, please do a
> 
> 	bk pull bk://kernel.bkbits.net/jgarzik/sparse.hacking



Arg.  Should be

	bk pull bk://kernel.bkbits.net/jgarzik/sparse


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend update
Date: Wed, 10 Sep 2003 05:30:15 +0000
Message-ID: <20030910053015.GA23783 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c |   85 +++++++++++++++++++++++++++++++--------------------------
 1 files changed, 47 insertions(+), 38 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/10 1.427)
   [be] fix segfault, emit casts, prettier emit_copy output,
   smarter val storage.
   
   * fix segfault in emit_symbol_expr_init.  we don't yet properly
     reference toplevel variables.  workaround, print out "FIXME!" and
     create a new pseudo.
   * directly inline constants, instead of assigning them stack slots
     as pseudos.
   * properly emit cast expressions; quite easy with my type-aware
     emit_move function.  alas, since we assume values will fit into
     a machine register, emit_move is [known-]broken for 64-bit ints.
   * make asm comments in pseudo-pseudo copy prettier




diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Wed Sep 10 01:27:03 2003
+++ b/compile-i386.c	Wed Sep 10 01:27:03 2003
@@ -826,8 +826,8 @@
 {
 	/* FIXME: Bitfield move! */
 
-	emit_move(src, REG_EAX, src_ctype, "begin copy ...", 0);
-	emit_move(REG_EAX, dest, dest_ctype, "... end copy", 0);
+	emit_move(src, REG_EAX, src_ctype, "begin copy ..", 0);
+	emit_move(REG_EAX, dest, dest_ctype, ".... end copy", 0);
 }
 
 static void emit_store(struct expression *dest_expr, struct storage *dest,
@@ -974,12 +974,9 @@
 	return new;
 }
 
-/*
- * TODO: use new type STOR_VALUE.  This will allow us to store
- * the constant internally, and avoid assigning stack slots to them.
- */
 static struct storage *emit_value(struct expression *expr)
 {
+#if 0 /* old and slow way */
 	struct storage *new = new_pseudo();
 	struct storage *val;
 
@@ -988,6 +985,14 @@
 	insn("movl", val, new, NULL, ATOM_FREE_OP1);
 
 	return new;
+#else
+	struct storage *val;
+
+	val = new_storage(STOR_VALUE);
+	val->value = (long long) expr->value;
+
+	return val;	/* FIXME: memory leak */
+#endif
 }
 
 static struct storage *emit_binop(struct expression *expr)
@@ -1172,15 +1177,21 @@
 	struct expression *expr = sym->initializer;
 	struct symbol_private *priv = sym->aux;
 
-	if (priv == NULL) {
-		if (expr == NULL) {
-			assert(0);
-			return NULL;
-		}
+	if (sym->ctype.modifiers & (MOD_TOPLEVEL | MOD_EXTERN | MOD_STATIC))
+		expr = NULL;
 
+	if (priv == NULL) {
 		priv = calloc(1, sizeof(*priv));
 		sym->aux = priv;
-		priv->addr = x86_expression(expr);
+
+		if (expr == NULL) {
+			struct storage *new = new_pseudo();
+			fprintf(stderr, "FIXME! no value for symbol.  creating pseudo %d (stack offset %d)\n",
+				new->pseudo, new->pseudo * 4);
+			priv->addr = new;
+		} else {
+			priv->addr = x86_expression(expr);
+		}
 	}
 
 	return priv->addr;
@@ -1200,6 +1211,29 @@
 	return new;
 }
 
+static struct storage *emit_cast_expr(struct expression *expr)
+{
+	struct symbol *old_type, *new_type;
+	struct storage *op = x86_expression(expr->cast_expression);
+	int oldbits, newbits;
+	struct storage *new;
+
+	old_type = expr->cast_expression->ctype;
+	new_type = expr->cast_type;
+
+	oldbits = old_type->bit_size;
+	newbits = new_type->bit_size;
+	if (oldbits >= newbits)
+		return op;
+
+	emit_move(op, REG_EAX, old_type, "begin cast ..", 0);
+
+	new = new_pseudo();
+	emit_move(REG_EAX, new, new_type, ".... end cast", 0);
+
+	return new;
+}
+
 static void x86_struct_member(struct symbol *sym, void *data, int flags)
 {
 	if (flags & ITERATE_FIRST)
@@ -1628,31 +1662,6 @@
 	return !(sym->ctype.modifiers & MOD_UNSIGNED);
 }
 
-static struct storage *x86_cast_expr(struct expression *expr)
-{
-	struct symbol *old_type, *new_type;
-	struct storage *op = x86_expression(expr->cast_expression);
-	int oldbits, newbits;
-	int is_signed;
-	struct storage *new;
-
-	old_type = expr->cast_expression->ctype;
-	new_type = expr->cast_type;
-
-	oldbits = old_type->bit_size;
-	newbits = new_type->bit_size;
-	if (oldbits >= newbits)
-		return op;
-	new = new_pseudo();
-	is_signed = type_is_signed(old_type);
-	if (is_signed) {
-		printf("\tsext%d.%d\tv%d,v%d\n", oldbits, newbits, new->pseudo, op->pseudo);
-	} else {
-		printf("\tandl.%d\t\tv%d,v%d,$%lu\n", newbits, new->pseudo, op->pseudo, (1UL << oldbits)-1);
-	}
-	return new;
-}
-
 static struct storage *x86_bitfield_expr(struct expression *expr)
 {
 	return x86_access(expr);
@@ -1746,7 +1755,7 @@
 		warn(expr->pos, "invalid expression after evaluation");
 		return 0;
 	case EXPR_CAST:
-		return x86_cast_expr(expr);
+		return emit_cast_expr(expr);
 	case EXPR_VALUE:
 		return emit_value(expr);
 	case EXPR_STRING:
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend update
Date: Wed, 10 Sep 2003 13:47:06 +0000
Message-ID: <20030910134705.GA13458 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c |   13 ++++++++-----
 1 files changed, 8 insertions(+), 5 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/10 1.428)
   [be] return fixes: move return jump target, emit return value properly
   
   Still needs some work.




diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Wed Sep 10 09:45:48 2003
+++ b/compile-i386.c	Wed Sep 10 09:45:48 2003
@@ -596,15 +596,15 @@
 
 	/* function epilogue */
 
-	/* jump target for 'return' statements */
-	sprintf(jump_target, ".L%d:\n", f->ret_target);
-	push_text_atom(f, jump_target);
-
 	if (ret_val) {
 		/* FIXME: mem operand hardcoded at 32 bits */
 		emit_move(ret_val, REG_EAX, NULL, NULL, 0);
 	}
 
+	/* jump target for 'return' statements */
+	sprintf(jump_target, ".L%d:\n", f->ret_target);
+	push_text_atom(f, jump_target);
+
 	val = new_storage(STOR_VALUE);
 	val->value = (long long) (pseudo_nr * 4);
 
@@ -1134,8 +1134,11 @@
 	struct storage *val = NULL;
 	char s[32];
 
-	if (expr && expr->ctype)
+	if (expr && expr->ctype) {
 		val = x86_expression(expr);
+		assert(val != NULL);
+		emit_move(val, REG_EAX, expr->ctype, "return", 0);
+	}
 
 	sprintf(s, "\tjmp\t.L%d\n", f->ret_target);
 	push_text_atom(f, s);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend update
Date: Wed, 10 Sep 2003 15:28:42 +0000
Message-ID: <20030910152842.GA26174 () gtf ! org>
--------------------
Accidentally pushed before you had pulled... so here's an updated
summary.



Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c |   30 ++++++++++++++++++++++++------
 1 files changed, 24 insertions(+), 6 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/10 1.429)
   [be] In assignments, don't perform a mem->mem copy (two mov's) when
   we don't have to.

<jgarzik@redhat.com> (03/09/10 1.428)
   [be] return fixes: move return jump target, emit return value properly
   
   Still needs some work.





diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Wed Sep 10 11:26:13 2003
+++ b/compile-i386.c	Wed Sep 10 11:26:13 2003
@@ -596,15 +596,15 @@
 
 	/* function epilogue */
 
-	/* jump target for 'return' statements */
-	sprintf(jump_target, ".L%d:\n", f->ret_target);
-	push_text_atom(f, jump_target);
-
 	if (ret_val) {
 		/* FIXME: mem operand hardcoded at 32 bits */
 		emit_move(ret_val, REG_EAX, NULL, NULL, 0);
 	}
 
+	/* jump target for 'return' statements */
+	sprintf(jump_target, ".L%d:\n", f->ret_target);
+	push_text_atom(f, jump_target);
+
 	val = new_storage(STOR_VALUE);
 	val->value = (long long) (pseudo_nr * 4);
 
@@ -1134,8 +1134,11 @@
 	struct storage *val = NULL;
 	char s[32];
 
-	if (expr && expr->ctype)
+	if (expr && expr->ctype) {
 		val = x86_expression(expr);
+		assert(val != NULL);
+		emit_move(val, REG_EAX, expr->ctype, "return", 0);
+	}
 
 	sprintf(s, "\tjmp\t.L%d\n", f->ret_target);
 	push_text_atom(f, s);
@@ -1576,7 +1579,22 @@
 	bits = expr->ctype->bit_size;
 	val = x86_expression(expr->right);
 	addr = x86_address_gen(target);
-	emit_copy(val, expr->right->ctype, addr, expr->left->ctype);
+
+	switch (val->type) {
+	/* copy, where both operands are memory */
+	case STOR_PSEUDO:
+	case STOR_ARG:
+		emit_copy(val, expr->right->ctype, addr, expr->left->ctype);
+		break;
+
+	/* copy, one or zero operands are memory */
+	case STOR_REG:
+	case STOR_SYM:
+	case STOR_VALUE:
+	case STOR_LABEL:
+		emit_move(val, addr, expr->left->ctype, NULL, 0);
+		break;
+	}
 	return val;
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend update
Date: Thu, 11 Sep 2003 04:12:46 +0000
Message-ID: <20030911041246.GA31614 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c |  191 +++++++++++++++++++++++++++++++++------------------------
 1 files changed, 112 insertions(+), 79 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/11 1.435)
   [be] properly emit "regular preops"
   
   * properly emit '!', '~', '-'
   * handle operand size in inc/dec
   * simplify EXPR_ACCESS test in x86_address_gen()

<jgarzik@redhat.com> (03/09/10 1.434)
   [be] move existing (non-working) loop code to its own function

<jgarzik@redhat.com> (03/09/10 1.433)
   [be] Properly load address de-references.





diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Thu Sep 11 00:08:38 2003
+++ b/compile-i386.c	Thu Sep 11 00:08:38 2003
@@ -1106,11 +1106,10 @@
 {
 	struct storage *addr = x86_address_gen(expr->unop);
 	struct storage *retval;
-	const char *opname = expr->op == SPECIAL_INCREMENT ? "incl" : "decl";
-#if 0
-	/* FIXME: don't hardware operand size */
-	int bits = expr->ctype->bit_size;
-#endif
+	char opname[16];
+
+	strcpy(opname, opbits(expr->op == SPECIAL_INCREMENT ? "inc" : "dec",
+			      expr->ctype->bit_size));
 
 	if (postop) {
 		struct storage *new = new_pseudo();
@@ -1238,6 +1237,38 @@
 	return new;
 }
 
+static struct storage *emit_regular_preop(struct expression *expr)
+{
+	struct storage *target = x86_expression(expr->unop);
+	struct storage *new = new_pseudo();
+	const char *opname = NULL;
+
+	switch (expr->op) {
+	case '!':
+		insn("xor", REG_EDX, REG_EDX, NULL, 0);
+		emit_move(target, REG_EAX, expr->unop->ctype, NULL, 0);
+		insn("test", REG_EAX, REG_EAX, NULL, 0);
+		insn("setz", REG_DL, NULL, NULL, 0);
+		emit_move(REG_EDX, new, expr->unop->ctype, NULL, 0);
+
+		break;
+	case '~':
+		opname = "not";
+	case '-':
+		if (!opname)
+			opname = "neg";
+		emit_move(target, REG_EAX, expr->unop->ctype, NULL, 0);
+		insn(opname, REG_EAX, NULL, NULL, 0);
+		emit_move(REG_EAX, new, expr->unop->ctype, NULL, 0);
+		break;
+	default:
+		assert(0);
+		break;
+	}
+
+	return new;
+}
+
 static void x86_struct_member(struct symbol *sym, void *data, int flags)
 {
 	if (flags & ITERATE_FIRST)
@@ -1370,6 +1401,53 @@
 	} END_FOR_EACH_PTR;
 }
 
+static void x86_loop(struct statement *stmt)
+{
+	struct statement  *pre_statement = stmt->iterator_pre_statement;
+	struct expression *pre_condition = stmt->iterator_pre_condition;
+	struct statement  *statement = stmt->iterator_statement;
+	struct statement  *post_statement = stmt->iterator_post_statement;
+	struct expression *post_condition = stmt->iterator_post_condition;
+	int loop_top = 0, loop_bottom = 0;
+	struct storage *val;
+
+	x86_symbol_decl(stmt->iterator_syms);
+	x86_statement(pre_statement);
+	if (pre_condition) {
+		if (pre_condition->type == EXPR_VALUE) {
+			if (!pre_condition->value) {
+				loop_bottom = new_label();
+				printf("\tjmp\t\t.L%d\n", loop_bottom);
+			}
+		} else {
+			loop_bottom = new_label();
+			val = x86_expression(pre_condition);
+			printf("\tje\t\tv%d, .L%d\n", val->pseudo, loop_bottom);
+		}
+	}
+	if (!post_condition || post_condition->type != EXPR_VALUE || post_condition->value) {
+		loop_top = new_label();
+		printf(".L%d:\n", loop_top);
+	}
+	x86_statement(statement);
+	if (stmt->iterator_continue->used)
+		printf(".L%p:\n", stmt->iterator_continue);
+	x86_statement(post_statement);
+	if (!post_condition) {
+		printf("\tjmp\t\t.L%d\n", loop_top);
+	} else if (post_condition->type == EXPR_VALUE) {
+		if (post_condition->value)
+			printf("\tjmp\t\t.L%d\n", loop_top);
+	} else {
+		val = x86_expression(post_condition);
+		printf("\tjne\t\tv%d, .L%d\n", val->pseudo, loop_top);
+	}
+	if (stmt->iterator_break->used)
+		printf(".L%p:\n", stmt->iterator_break);
+	if (loop_bottom)
+		printf(".L%d:\n", loop_bottom);
+}
+
 /*
  * Print out a statement
  */
@@ -1406,52 +1484,10 @@
 		x86_statement(stmt->case_statement);
 		break;
 
-	case STMT_ITERATOR: {
-		struct statement  *pre_statement = stmt->iterator_pre_statement;
-		struct expression *pre_condition = stmt->iterator_pre_condition;
-		struct statement  *statement = stmt->iterator_statement;
-		struct statement  *post_statement = stmt->iterator_post_statement;
-		struct expression *post_condition = stmt->iterator_post_condition;
-		int loop_top = 0, loop_bottom = 0;
-		struct storage *val;
-
-		x86_symbol_decl(stmt->iterator_syms);
-		x86_statement(pre_statement);
-		if (pre_condition) {
-			if (pre_condition->type == EXPR_VALUE) {
-				if (!pre_condition->value) {
-					loop_bottom = new_label();
-					printf("\tjmp\t\t.L%d\n", loop_bottom);
-				}
-			} else {
-				loop_bottom = new_label();
-				val = x86_expression(pre_condition);
-				printf("\tje\t\tv%d, .L%d\n", val->pseudo, loop_bottom);
-			}
-		}
-		if (!post_condition || post_condition->type != EXPR_VALUE || post_condition->value) {
-			loop_top = new_label();
-			printf(".L%d:\n", loop_top);
-		}
-		x86_statement(statement);
-		if (stmt->iterator_continue->used)
-			printf(".L%p:\n", stmt->iterator_continue);
-		x86_statement(post_statement);
-		if (!post_condition) {
-			printf("\tjmp\t\t.L%d\n", loop_top);
-		} else if (post_condition->type == EXPR_VALUE) {
-			if (post_condition->value)
-				printf("\tjmp\t\t.L%d\n", loop_top);
-		} else {
-			val = x86_expression(post_condition);
-			printf("\tjne\t\tv%d, .L%d\n", val->pseudo, loop_top);
-		}
-		if (stmt->iterator_break->used)
-			printf(".L%p:\n", stmt->iterator_break);
-		if (loop_bottom)
-			printf(".L%d:\n", loop_bottom);
+	case STMT_ITERATOR:
+		x86_loop(stmt);
 		break;
-	}
+
 	case STMT_NONE:
 		break;
 
@@ -1473,7 +1509,7 @@
 		break;
 
 	}
-	return 0;
+	return NULL;
 }
 
 static struct storage *x86_call_expression(struct expression *expr)
@@ -1537,33 +1573,30 @@
 	return retval;
 }
 
-static struct storage *x86_regular_preop(struct expression *expr)
-{
-	struct storage *target = x86_expression(expr->unop);
-	struct storage *new = new_pseudo();
-	static const char *name[] = {
-		['!'] = "nonzero", ['-'] = "neg",
-		['~'] = "not",
-	};
-	unsigned int op = expr->op;
-	const char *opname;
-
-	opname = show_special(op);
-	if (op < sizeof(name)/sizeof(*name))
-		opname = name[op];
-	printf("\t%s.%d\t\tv%d,v%d\n", opname, expr->ctype->bit_size, new->pseudo, target->pseudo);
-	return new;
-}
-
-/*
- * FIXME! Not all accesses are memory loads. We should
- * check what kind of symbol is behind the dereference.
- */
 static struct storage *x86_address_gen(struct expression *expr)
 {
-	if (expr->type == EXPR_PREOP)
-		return x86_expression(expr->unop);
-	return x86_expression(expr->address);
+	struct function *f = current_func;
+	struct storage *addr;
+	struct storage *new;
+	char s[32];
+
+	if ((expr->type != EXPR_PREOP) || (expr->op != '*'))
+		return x86_expression(expr->address);
+
+	addr = x86_expression(expr->unop);
+	if (expr->unop->type == EXPR_SYMBOL)
+		return addr;
+
+	emit_move(addr, REG_EAX, NULL, "begin deref ..", 0);
+
+	/* FIXME: operand size */
+	strcpy(s, "\tmovl\t(%eax), %ecx\n");
+	push_text_atom(f, s);
+
+	new = new_pseudo();
+	emit_move(REG_ECX, new, NULL, ".... end deref", 0);
+
+	return new;
 }
 
 static struct storage *x86_assignment(struct expression *expr)
@@ -1630,7 +1663,7 @@
 		return x86_access(expr);
 	if (expr->op == SPECIAL_INCREMENT || expr->op == SPECIAL_DECREMENT)
 		return emit_inc_dec(expr, 0);
-	return x86_regular_preop(expr);
+	return emit_regular_preop(expr);
 }
 
 static struct storage *x86_symbol_expr(struct symbol *sym)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend update
Date: Fri, 12 Sep 2003 20:52:10 +0000
Message-ID: <20030912205209.GA7769 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c       |  425 ++++++++++++++++++++++++++++++++-------------------
 validation/test-be.c |   43 +++++
 2 files changed, 316 insertions(+), 152 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/12 1.441)
   [be] properly emit switch statements.
   
   Also create helpers for emitted labels (emit_label),
   labels based on symbol pointer values (emit_labelsym),
   and creating various struct storage types (new_val, new_labelsym).
   
   Use these new helpers where appropriate.

<jgarzik@redhat.com> (03/09/12 1.440)
   [be] prefer "mov $0, %eax" to "xor %eax, %eax"

<jgarzik@redhat.com> (03/09/12 1.439)
   [be] Store "free() me?" flag in struct storage, where it belongs,
   rather than as multiple flags in struct atom.  This allows us to
   eliminate the final arg passed to {insn, emit_move, stor_op_name}.
   
   Also, fix two memory leaks noticed during the cleanup.

<jgarzik@redhat.com> (03/09/11 1.438)
   [be] temporarily ignore size of a callee func call's return value.
   Now, we just assume it's the ABI size (32 bits) rather than
   care about the distinction between what we want to return up the
   parse tree stack (possibly not 32 bits), and what the ABI gives
   us (32 bits).
   
   Also, add new file validation/test-be.c, to house a growing
   collection of basic sanity checks I can run, to help avoid
   regressions.

<jgarzik@redhat.com> (03/09/11 1.437)
   [be] add to-do list compile-i386.c header

<jgarzik@redhat.com> (03/09/11 1.436)
   [be] clean up binop selection.  add support for shift left/right





diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Fri Sep 12 16:25:41 2003
+++ b/compile-i386.c	Fri Sep 12 16:25:41 2003
@@ -9,6 +9,19 @@
  *
  * x86 backend
  *
+ * TODO list:
+ * in general, any non-32bit SYM_BASETYPE is unlikely to work.
+ * loops
+ * complex initializers
+ * bitfields
+ * global struct/union variables
+ * addressing structures, and members of structures (as opposed to
+ *     scalars) on the stack.  Requires smarter stack frame allocation.
+ * labels / goto
+ * any function argument that isn't 32 bits (or promoted to such)
+ * inline asm
+ * floating point
+ *
  */
 #include <stdarg.h>
 #include <stdlib.h>
@@ -53,6 +66,7 @@
 	STOR_REG,	/* scratch register */
 	STOR_VALUE,	/* integer constant */
 	STOR_LABEL,	/* label / jump target */
+	STOR_LABELSYM,	/* label generated from symbol's pointer value */
 };
 
 struct reg_info {
@@ -61,6 +75,7 @@
 
 struct storage {
 	enum storage_type type;
+	unsigned long flags;
 
 	/* STOR_REG */
 	struct reg_info *reg;
@@ -85,13 +100,17 @@
 		/* STOR_LABEL */
 		struct {
 			int label;
-			unsigned long flags;
+		};
+		/* STOR_LABELSYM */
+		struct {
+			struct symbol *labelsym;
 		};
 	};
 };
 
 enum {
 	STOR_LABEL_VAL	= (1 << 0),
+	STOR_WANTS_FREE	= (1 << 1),
 };
 
 struct symbol_private {
@@ -104,11 +123,6 @@
 	ATOM_CSTR,
 };
 
-enum {
-	ATOM_FREE_OP1	= (1 << 0),
-	ATOM_FREE_OP2	= (1 << 1),
-};
-
 struct atom {
 	enum atom_type type;
 	union {
@@ -124,7 +138,6 @@
 			char comment[40];
 			struct storage *op1;
 			struct storage *op2;
-			unsigned long flags;
 		};
 
 		/* stuff for C strings */
@@ -183,8 +196,7 @@
 
 
 static void emit_move(struct storage *src, struct storage *dest,
-		      struct symbol *ctype, const char *comment,
-		      unsigned long flags);
+		      struct symbol *ctype, const char *comment);
 static int type_is_signed(struct symbol *sym);
 static struct storage *x86_address_gen(struct expression *expr);
 static struct storage *x86_symbol_expr(struct symbol *sym);
@@ -238,7 +250,7 @@
 	stor->sym = sym;
 }
 
-static const char *stor_op_name(struct storage *s, unsigned long flags)
+static const char *stor_op_name(struct storage *s)
 {
 	static char name[32];
 
@@ -259,9 +271,13 @@
 		sprintf(name, "$%Ld", s->value);
 		break;
 	case STOR_LABEL:
-		sprintf(name, "%s.L%d", flags & STOR_LABEL_VAL ? "$" : "",
+		sprintf(name, "%s.L%d", s->flags & STOR_LABEL_VAL ? "$" : "",
 			s->label);
 		break;
+	case STOR_LABELSYM:
+		sprintf(name, "%s.LS%p", s->flags & STOR_LABEL_VAL ? "$" : "",
+			s->labelsym);
+		break;
 	}
 
 	return name;
@@ -336,6 +352,34 @@
 	return stor;
 }
 
+static struct storage *new_labelsym(struct symbol *sym)
+{
+	struct storage *stor;
+
+	stor = new_storage(STOR_LABELSYM);
+
+	if (stor) {
+		stor->flags |= STOR_WANTS_FREE;
+		stor->labelsym = sym;
+	}
+
+	return stor;
+}
+
+static struct storage *new_val(long long value)
+{
+	struct storage *stor;
+
+	stor = new_storage(STOR_VALUE);
+
+	if (stor) {
+		stor->flags |= STOR_WANTS_FREE;
+		stor->value = value;
+	}
+
+	return stor;
+}
+
 static int new_label(void)
 {
 	static int label = 0;
@@ -393,7 +437,7 @@
 }
 
 static void insn(const char *insn, struct storage *op1, struct storage *op2,
-		 const char *comment_in, unsigned long flags)
+		 const char *comment_in)
 {
 	struct function *f = current_func;
 	struct atom *atom = new_atom(ATOM_INSN);
@@ -407,11 +451,36 @@
 
 	atom->op1 = op1;
 	atom->op2 = op2;
-	atom->flags = flags;
 
 	push_atom(f, atom);
 }
 
+static void emit_label (int label, const char *comment)
+{
+	struct function *f = current_func;
+	char s[64];
+
+	if (!comment)
+		sprintf(s, ".L%d:\n", label);
+	else
+		sprintf(s, ".L%d:\t\t\t\t\t# %s\n", label, comment);
+
+	push_text_atom(f, s);
+}
+
+static void emit_labelsym (struct symbol *sym, const char *comment)
+{
+	struct function *f = current_func;
+	char s[64];
+
+	if (!comment)
+		sprintf(s, ".LS%p:\n", sym);
+	else
+		sprintf(s, ".LS%p:\t\t\t\t# %s\n", sym, comment);
+
+	push_text_atom(f, s);
+}
+
 static void emit_unit_pre(const char *basename)
 {
 	printf("\t.file\t\"%s\"\n", basename);
@@ -449,12 +518,12 @@
 
 	if (atom->op2) {
 		char tmp[16];
-		strcpy(tmp, stor_op_name(op1, op1->flags));
+		strcpy(tmp, stor_op_name(op1));
 		sprintf(s, "\t%s\t%s, %s%s\n",
-			atom->insn, tmp, stor_op_name(op2, op2->flags), comment);
+			atom->insn, tmp, stor_op_name(op2), comment);
 	} else if (atom->op1)
 		sprintf(s, "\t%s\t%s%s%s\n",
-			atom->insn, stor_op_name(op1, op1->flags),
+			atom->insn, stor_op_name(op1),
 			comment[0] ? "\t" : "", comment);
 	else
 		sprintf(s, "\t%s\t%s%s\n",
@@ -513,9 +582,9 @@
 	FOR_EACH_PTR(f->atom_list, atom) {
 		if ((atom->type == ATOM_TEXT) && (atom->text))
 			free(atom->text);
-		if (atom->flags & ATOM_FREE_OP1)
+		if (atom->op1 && (atom->op1->flags & STOR_WANTS_FREE))
 			free(atom->op1);
-		if (atom->flags & ATOM_FREE_OP2)
+		if (atom->op2 && (atom->op2->flags & STOR_WANTS_FREE))
 			free(atom->op2);
 		free(atom);
 	} END_FOR_EACH_PTR;
@@ -579,7 +648,6 @@
 	const char *name = show_ident(sym->ident);
 	struct function *f = current_func;
 	int pseudo_nr = f->pseudo_nr;
-	char jump_target[16];
 
 	if (f->str_list)
 		emit_string_list(f);
@@ -601,19 +669,19 @@
 	/* function epilogue */
 
 	/* jump target for 'return' statements */
-	sprintf(jump_target, ".L%d:\n", f->ret_target);
-	push_text_atom(f, jump_target);
+	emit_label(f->ret_target, NULL);
 
 	if (pseudo_nr) {
 		struct storage *val;
 
 		val = new_storage(STOR_VALUE);
 		val->value = (long long) (pseudo_nr * 4);
+		val->flags = STOR_WANTS_FREE;
 
-		insn("addl", val, REG_ESP, NULL, ATOM_FREE_OP1);
+		insn("addl", val, REG_ESP, NULL);
 	}
 
-	insn("ret", NULL, NULL, NULL, 0);
+	insn("ret", NULL, NULL, NULL);
 
 	/* output everything to stdout */
 	fflush(stdout);		/* paranoia; needed? */
@@ -830,8 +898,8 @@
 {
 	/* FIXME: Bitfield move! */
 
-	emit_move(src, REG_EAX, src_ctype, "begin copy ..", 0);
-	emit_move(REG_EAX, dest, dest_ctype, ".... end copy", 0);
+	emit_move(src, REG_EAX, src_ctype, "begin copy ..");
+	emit_move(REG_EAX, dest, dest_ctype, ".... end copy");
 }
 
 static void emit_store(struct expression *dest_expr, struct storage *dest,
@@ -876,8 +944,7 @@
 }
 
 static void emit_move(struct storage *src, struct storage *dest,
-		      struct symbol *ctype, const char *comment,
-		      unsigned long flags)
+		      struct symbol *ctype, const char *comment)
 {
 	unsigned int bits;
 	unsigned int is_signed;
@@ -893,7 +960,7 @@
 	}
 
 	if ((dest->type == STOR_REG) && (src->type == STOR_REG)) {
-		insn("mov", src, dest, NULL, 0);
+		insn("mov", src, dest, NULL);
 		return;
 	}
 
@@ -921,14 +988,14 @@
 	default:			assert(0);		break;
 	}
 
-	insn(opname, src, dest, comment, flags);
+	insn(opname, src, dest, comment);
 }
 
 static struct storage *emit_compare(struct expression *expr)
 {
 	struct storage *left = x86_expression(expr->left);
 	struct storage *right = x86_expression(expr->right);
-	struct storage *new;
+	struct storage *new, *val;
 	const char *opname = NULL;
 	unsigned int is_signed = type_is_signed(expr->left->ctype); /* FIXME */
 	unsigned int right_bits = expr->right->ctype->bit_size;
@@ -960,20 +1027,22 @@
 	}
 
 	/* init EDX to 0 */
-	insn("xor", REG_EDX, REG_EDX, "begin EXPR_COMPARE", 0);
+	val = new_storage(STOR_VALUE);
+	val->flags = STOR_WANTS_FREE;
+	emit_move(val, REG_EDX, NULL, NULL);
 
 	/* move op1 into EAX */
-	emit_move(left, REG_EAX, expr->left->ctype, NULL, 0);
+	emit_move(left, REG_EAX, expr->left->ctype, NULL);
 
 	/* perform comparison, RHS (op1, right) and LHS (op2, EAX) */
-	insn(opbits("cmp", right_bits), right, REG_EAX, NULL, 0);
+	insn(opbits("cmp", right_bits), right, REG_EAX, NULL);
 
 	/* store result of operation, 0 or 1, in DL using SETcc */
-	insn(opname, REG_DL, NULL, NULL, 0);
+	insn(opname, REG_DL, NULL, NULL);
 
 	/* finally, store the result (DL) in a new pseudo / stack slot */
 	new = new_pseudo();
-	emit_move(REG_EDX, new, NULL, "end EXPR_COMPARE", 0);
+	emit_move(REG_EDX, new, NULL, "end EXPR_COMPARE");
 
 	return new;
 }
@@ -986,7 +1055,8 @@
 
 	val = new_storage(STOR_VALUE);
 	val->value = (long long) expr->value;
-	insn("movl", val, new, NULL, ATOM_FREE_OP1);
+	val->flags = STOR_WANTS_FREE;
+	insn("movl", val, new, NULL);
 
 	return new;
 #else
@@ -1004,14 +1074,7 @@
 	struct storage *left = x86_expression(expr->left);
 	struct storage *right = x86_expression(expr->right);
 	struct storage *new;
-	const char *opname;
-	static const char *name[] = {
-		['+'] = "addl", ['-'] = "subl",
-		['*'] = "mull", ['/'] = "divl",
-		['%'] = "modl", ['&'] = "andl",
-		['|'] = "orl", ['^'] = "xorl"
-	};
-	unsigned int op = expr->op;
+	const char *opname = NULL;
 
 	/*
 	 * FIXME FIXME this routine is so wrong it's not even funny.
@@ -1020,33 +1083,38 @@
 	 * and like elsewhere we hardcode the operand size at 32 bits.
 	 */
 
-	opname = show_special(op);
-	if (op < sizeof(name)/sizeof(*name)) {
-		opname = name[op];
-		assert(opname != NULL);
-	} else
-		assert(0); /* FIXME: no operations other than name[], ATM */
+	switch (expr->op) {
+	case '+':			opname = "addl";	break;
+	case '-':			opname = "subl";	break;
+	case '*':			opname = "mull";	break;
+	case '/':			opname = "divl";	break;
+	case '%':			opname = "modl";	break;
+	case '&':			opname = "andl";	break;
+	case '|':			opname = "orl";		break;
+	case '^':			opname = "xorl";	break;
+	case SPECIAL_LEFTSHIFT:		opname = "shll";	break;
+	case SPECIAL_RIGHTSHIFT:	opname = "shrl";	break;
+	default:			assert(0);		break;
+	}
 
 	/* load op2 into EAX */
-	insn("movl", right, REG_EAX, "EXPR_BINOP/COMMA/LOGICAL", 0);
+	insn("movl", right, REG_EAX, "EXPR_BINOP/COMMA/LOGICAL");
 
 	/* perform binop */
-	insn(opname, left, REG_EAX, NULL, 0);
+	insn(opname, left, REG_EAX, NULL);
 
 	/* store result (EAX) in new pseudo / stack slot */
 	new = new_pseudo();
-	insn("movl", REG_EAX, new, "end EXPR_BINOP", 0);
+	insn("movl", REG_EAX, new, "end EXPR_BINOP");
 
 	return new;
 }
 
 static void emit_if_conditional(struct statement *stmt)
 {
-	struct function *f = current_func;
 	struct storage *val, *target_val;
 	int target;
 	struct expression *cond = stmt->if_conditional;
-	char s[16];
 
 /* This is only valid if nobody can jump into the "dead" statement */
 #if 0
@@ -1061,10 +1129,10 @@
 	val = x86_expression(cond);
 
 	/* load 'if' test result into EAX */
-	insn("movl", val, REG_EAX, "begin if conditional", 0);
+	insn("movl", val, REG_EAX, "begin if conditional");
 
 	/* compare 'if' test result */
-	insn("test", REG_EAX, REG_EAX, NULL, 0);
+	insn("test", REG_EAX, REG_EAX, NULL);
 
 	/* create end-of-if label / if-failed labelto jump to,
 	 * and jump to it if the expression returned zero.
@@ -1072,7 +1140,8 @@
 	target = new_label();
 	target_val = new_storage(STOR_LABEL);
 	target_val->label = target;
-	insn("jz", target_val, NULL, NULL, ATOM_FREE_OP1);
+	target_val->flags = STOR_WANTS_FREE;
+	insn("jz", target_val, NULL, NULL);
 
 	x86_statement(stmt->if_true);
 	if (stmt->if_false) {
@@ -1086,20 +1155,19 @@
 		last = new_label();
 		last_val = new_storage(STOR_LABEL);
 		last_val->label = last;
-		insn("jmp", last_val, NULL, NULL, ATOM_FREE_OP1);
+		last_val->flags = STOR_WANTS_FREE;
+		insn("jmp", last_val, NULL, NULL);
 
 		/* if we have both if-true and if-false statements,
 		 * the failed-conditional case will fall through to here
 		 */
-		sprintf(s, ".L%d:\n", target);
-		push_text_atom(f, s);
+		emit_label(target, NULL);
 
 		target = last;
 		x86_statement(stmt->if_false);
 	}
 
-	sprintf(s, ".L%d:\t\t\t\t\t# end if\n", target);
-	push_text_atom(f, s);
+	emit_label(target, "end if");
 }
 
 static struct storage *emit_inc_dec(struct expression *expr, int postop)
@@ -1120,7 +1188,7 @@
 	} else
 		retval = addr;
 
-	insn(opname, addr, NULL, NULL, 0);
+	insn(opname, addr, NULL, NULL);
 
 	return retval;
 }
@@ -1134,17 +1202,18 @@
 {
 	struct function *f = current_func;
 	struct expression *expr = stmt->ret_value;
-	struct storage *val = NULL;
-	char s[32];
+	struct storage *val = NULL, *jmplbl;
 
 	if (expr && expr->ctype) {
 		val = x86_expression(expr);
 		assert(val != NULL);
-		emit_move(val, REG_EAX, expr->ctype, "return", 0);
+		emit_move(val, REG_EAX, expr->ctype, "return");
 	}
 
-	sprintf(s, "\tjmp\t.L%d\n", f->ret_target);
-	push_text_atom(f, s);
+	jmplbl = new_storage(STOR_LABEL);
+	jmplbl->flags |= STOR_WANTS_FREE;
+	jmplbl->label = f->ret_target;
+	insn("jmp", jmplbl, NULL, NULL);
 
 	return val;
 }
@@ -1160,19 +1229,19 @@
 		true = cond;
 
 	emit_move(cond,  REG_EAX, expr->conditional->ctype,
-		  "begin EXPR_CONDITIONAL", 0);
-	emit_move(true,  REG_ECX, expr->cond_true->ctype,   NULL, 0);
-	emit_move(false, REG_EDX, expr->cond_false->ctype,  NULL, 0);
+		  "begin EXPR_CONDITIONAL");
+	emit_move(true,  REG_ECX, expr->cond_true->ctype,   NULL);
+	emit_move(false, REG_EDX, expr->cond_false->ctype,  NULL);
 
 	/* test EAX (for zero/non-zero) */
-	insn("test", REG_EAX, REG_EAX, NULL, 0);
+	insn("test", REG_EAX, REG_EAX, NULL);
 
 	/* if false, move EDX to ECX */
-	insn("cmovz", REG_EDX, REG_ECX, NULL, 0);
+	insn("cmovz", REG_EDX, REG_ECX, NULL);
 
 	/* finally, store the result (ECX) in a new pseudo / stack slot */
 	new = new_pseudo();
-	emit_move(REG_ECX, new, expr->ctype, "end EXPR_CONDITIONAL", 0);
+	emit_move(REG_ECX, new, expr->ctype, "end EXPR_CONDITIONAL");
 	/* FIXME: we lose type knowledge of expression result at this point */
 
 	return new;
@@ -1204,13 +1273,13 @@
 {
 	struct function *f = current_func;
 	int label = new_label();
-	struct storage *new = new_pseudo();
+	struct storage *new;
 
 	push_cstring(f, expr->string, label);
 
 	new = new_storage(STOR_LABEL);
 	new->label = label;
-	new->flags = STOR_LABEL_VAL;
+	new->flags = STOR_LABEL_VAL | STOR_WANTS_FREE;
 	return new;
 }
 
@@ -1229,10 +1298,10 @@
 	if (oldbits >= newbits)
 		return op;
 
-	emit_move(op, REG_EAX, old_type, "begin cast ..", 0);
+	emit_move(op, REG_EAX, old_type, "begin cast ..");
 
 	new = new_pseudo();
-	emit_move(REG_EAX, new, new_type, ".... end cast", 0);
+	emit_move(REG_EAX, new, new_type, ".... end cast");
 
 	return new;
 }
@@ -1240,16 +1309,18 @@
 static struct storage *emit_regular_preop(struct expression *expr)
 {
 	struct storage *target = x86_expression(expr->unop);
-	struct storage *new = new_pseudo();
+	struct storage *val, *new = new_pseudo();
 	const char *opname = NULL;
 
 	switch (expr->op) {
 	case '!':
-		insn("xor", REG_EDX, REG_EDX, NULL, 0);
-		emit_move(target, REG_EAX, expr->unop->ctype, NULL, 0);
-		insn("test", REG_EAX, REG_EAX, NULL, 0);
-		insn("setz", REG_DL, NULL, NULL, 0);
-		emit_move(REG_EDX, new, expr->unop->ctype, NULL, 0);
+		val = new_storage(STOR_VALUE);
+		val->flags = STOR_WANTS_FREE;
+		emit_move(val, REG_EDX, NULL, NULL);
+		emit_move(target, REG_EAX, expr->unop->ctype, NULL);
+		insn("test", REG_EAX, REG_EAX, NULL);
+		insn("setz", REG_DL, NULL, NULL);
+		emit_move(REG_EDX, new, expr->unop->ctype, NULL);
 
 		break;
 	case '~':
@@ -1257,9 +1328,9 @@
 	case '-':
 		if (!opname)
 			opname = "neg";
-		emit_move(target, REG_EAX, expr->unop->ctype, NULL, 0);
-		insn(opname, REG_EAX, NULL, NULL, 0);
-		emit_move(REG_EAX, new, expr->unop->ctype, NULL, 0);
+		emit_move(target, REG_EAX, expr->unop->ctype, NULL);
+		insn(opname, REG_EAX, NULL, NULL);
+		emit_move(REG_EAX, new, expr->unop->ctype, NULL);
 		break;
 	default:
 		assert(0);
@@ -1269,6 +1340,94 @@
 	return new;
 }
 
+static void emit_case_statement(struct statement *stmt)
+{
+	emit_labelsym(stmt->case_label, NULL);
+	x86_statement(stmt->case_statement);
+}
+
+static void emit_switch_statement(struct statement *stmt)
+{
+	struct storage *val = x86_expression(stmt->switch_expression);
+	struct symbol *sym, *default_sym = NULL;
+	struct storage *labelsym, *label;
+	int switch_end = 0;
+
+	emit_move(val, REG_EAX, stmt->switch_expression->ctype, "begin case");
+
+	/*
+	 * This is where a _real_ back-end would go through the
+	 * cases to decide whether to use a lookup table or a
+	 * series of comparisons etc
+	 */
+	FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
+		struct statement *case_stmt = sym->stmt;
+		struct expression *expr = case_stmt->case_expression;
+		struct expression *to = case_stmt->case_to;
+
+		/* default: */
+		if (!expr)
+			default_sym = sym;
+
+		/* case NNN: */
+		else {
+			struct storage *case_val = new_val(expr->value);
+
+			assert (expr->type == EXPR_VALUE);
+
+			insn("cmpl", case_val, REG_EAX, NULL);
+
+			if (!to) {
+				labelsym = new_labelsym(sym);
+				insn("je", labelsym, NULL, NULL);
+			} else {
+				int next_test;
+
+				label = new_storage(STOR_LABEL);
+				label->flags |= STOR_WANTS_FREE;
+				label->label = next_test = new_label();
+				
+				/* FIXME: signed/unsigned */
+				insn("jl", label, NULL, NULL);
+
+				case_val = new_val(to->value);
+				insn("cmpl", case_val, REG_EAX, NULL);
+
+				/* TODO: implement and use refcounting... */
+				label = new_storage(STOR_LABEL);
+				label->flags |= STOR_WANTS_FREE;
+				label->label = next_test;
+				
+				/* FIXME: signed/unsigned */
+				insn("jg", label, NULL, NULL);
+
+				labelsym = new_labelsym(sym);
+				insn("jmp", labelsym, NULL, NULL);
+
+				emit_label(next_test, NULL);
+			}
+		}
+	} END_FOR_EACH_PTR;
+
+	if (default_sym) {
+		labelsym = new_labelsym(default_sym);
+		insn("jmp", labelsym, NULL, "default");
+	} else {
+		label = new_storage(STOR_LABEL);
+		label->flags |= STOR_WANTS_FREE;
+		label->label = switch_end = new_label();
+		insn("jmp", label, NULL, "goto end of switch");
+	}
+
+	x86_statement(stmt->switch_statement);
+
+	if (stmt->switch_break->used)
+		emit_labelsym(stmt->switch_break, NULL);
+
+	if (switch_end)
+		emit_label(switch_end, NULL);
+}
+
 static void x86_struct_member(struct symbol *sym, void *data, int flags)
 {
 	if (flags & ITERATE_FIRST)
@@ -1348,51 +1507,6 @@
 
 static void x86_symbol_init(struct symbol *sym);
 
-static void x86_switch_statement(struct statement *stmt)
-{
-	struct storage *val = x86_expression(stmt->switch_expression);
-	struct symbol *sym;
-	printf("\tswitch v%d\n", val->pseudo);
-
-	/*
-	 * Debugging only: Check that the case list is correct
-	 * by printing it out.
-	 *
-	 * This is where a _real_ back-end would go through the
-	 * cases to decide whether to use a lookup table or a
-	 * series of comparisons etc
-	 */
-	printf("# case table:\n");
-	FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
-		struct statement *case_stmt = sym->stmt;
-		struct expression *expr = case_stmt->case_expression;
-		struct expression *to = case_stmt->case_to;
-
-		if (!expr) {
-			printf("    default");
-		} else {
-			if (expr->type == EXPR_VALUE) {
-				printf("    case %lld", expr->value);
-				if (to) {
-					if (to->type == EXPR_VALUE) {
-						printf(" .. %lld", to->value);
-					} else {
-						printf(" .. what?");
-					}
-				}
-			} else
-				printf("    what?");
-		}
-		printf(": .L%p\n", sym);
-	} END_FOR_EACH_PTR;
-	printf("# end case table\n");
-
-	x86_statement(stmt->switch_statement);
-
-	if (stmt->switch_break->used)
-		printf(".L%p:\n", stmt->switch_break);
-}
-
 static void x86_symbol_decl(struct symbol_list *syms)
 {
 	struct symbol *sym;
@@ -1475,13 +1589,12 @@
 	case STMT_IF:
 		emit_if_conditional(stmt);
 		return NULL;
-	case STMT_SWITCH:
-		x86_switch_statement(stmt);
-		break;
 
 	case STMT_CASE:
-		printf(".L%p:\n", stmt->case_label);
-		x86_statement(stmt->case_statement);
+		emit_case_statement(stmt);
+		break;
+	case STMT_SWITCH:
+		emit_switch_statement(stmt);
 		break;
 
 	case STMT_ITERATOR:
@@ -1501,7 +1614,8 @@
 			struct storage *val = x86_expression(stmt->goto_expression);
 			printf("\tgoto *v%d\n", val->pseudo);
 		} else {
-			printf("\tgoto .L%p\n", stmt->goto_label);
+			struct storage *labelsym = new_labelsym(stmt->goto_label);
+			insn("jmp", labelsym, NULL, NULL);
 		}
 		break;
 	case STMT_ASM:
@@ -1533,7 +1647,7 @@
 
 		/* FIXME: pay attention to 'size' */
 		insn("pushl", new, NULL,
-		     !framesize ? "begin function call" : NULL, 0);
+		     !framesize ? "begin function call" : NULL);
 
 		framesize += size >> 3;
 	} END_FOR_EACH_PTR_REVERSE;
@@ -1550,11 +1664,13 @@
 		}
 	}
 	if (direct) {
-		sprintf(s, "\tcall\t%s\n", show_ident(direct->ident));
-		push_text_atom(f, s);
+		struct storage *direct_stor = new_storage(STOR_SYM);
+		direct_stor->flags |= STOR_WANTS_FREE;
+		direct_stor->sym = direct;
+		insn("call", direct_stor, NULL, NULL);
 	} else {
 		fncall = x86_expression(fn);
-		emit_move(fncall, REG_EAX, fn->ctype, NULL, 0);
+		emit_move(fncall, REG_EAX, fn->ctype, NULL);
 
 		strcpy(s, "\tcall\t*%eax\n");
 		push_text_atom(f, s);
@@ -1564,11 +1680,12 @@
 	if (framesize) {
 		struct storage *val = new_storage(STOR_VALUE);
 		val->value = (long long) framesize;
-		insn("addl", val, REG_ESP, NULL, ATOM_FREE_OP1);
+		val->flags = STOR_WANTS_FREE;
+		insn("addl", val, REG_ESP, NULL);
 	}
 
 	retval = new_pseudo();
-	emit_move(REG_EAX, retval, expr->ctype, "end function call", 0);
+	emit_move(REG_EAX, retval, NULL, "end function call");
 
 	return retval;
 }
@@ -1587,14 +1704,14 @@
 	if (expr->unop->type == EXPR_SYMBOL)
 		return addr;
 
-	emit_move(addr, REG_EAX, NULL, "begin deref ..", 0);
+	emit_move(addr, REG_EAX, NULL, "begin deref ..");
 
 	/* FIXME: operand size */
 	strcpy(s, "\tmovl\t(%eax), %ecx\n");
 	push_text_atom(f, s);
 
 	new = new_pseudo();
-	emit_move(REG_ECX, new, NULL, ".... end deref", 0);
+	emit_move(REG_ECX, new, NULL, ".... end deref");
 
 	return new;
 }
@@ -1624,7 +1741,11 @@
 	case STOR_SYM:
 	case STOR_VALUE:
 	case STOR_LABEL:
-		emit_move(val, addr, expr->left->ctype, NULL, 0);
+		emit_move(val, addr, expr->left->ctype, NULL);
+		break;
+
+	case STOR_LABELSYM:
+		assert(0);
 		break;
 	}
 	return val;
diff -Nru a/validation/test-be.c b/validation/test-be.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/validation/test-be.c	Fri Sep 12 16:25:41 2003
@@ -0,0 +1,43 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#undef PRINT_OUTPUTS
+
+static void test_func_args(int x, int y)
+{
+	if (x == y)
+		exit(1);
+}
+
+static int binop_s32(int x, int y)
+{
+	int a;
+
+	a = a + x;
+	a = a / y;
+	a = a * x;
+	a = a - y;
+
+	return a;
+}
+
+static void test_binops(void)
+{
+	int tmp_s32 = binop_s32(987123, 234);
+
+#ifdef PRINT_OUTPUTS
+	printf("binop_s32(987123, 234) == %d\n", tmp_s32);
+#else
+	if (tmp_s32 != -1470599007)
+		exit(2);
+#endif
+}
+
+int main (int argc, char *argv[])
+{
+	test_func_args(1, 2);
+	test_binops();
+
+	return 0;
+}
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] backend update (Hello, World) ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] backend update (Hello, World)
Date: Wed, 10 Sep 2003 02:14:13 +0000
Message-ID: <20030910021413.GA14157 () gtf ! org>
--------------------
Hello works...

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
		printf("hello, world!\n");
		return 0;
	}

__mode__ is the only thing in the glibc headers that sparse complains
about now.  I'm surprised the parser is doing that well...

bash-2.05b$ ./doit.sh test-hello
warning: /usr/include/_G_config.h:55:57: attribute '__mode__': unknown attribute
warning: /usr/include/_G_config.h:56:57: attribute '__mode__': unknown attribute
warning: /usr/include/_G_config.h:57:67: attribute '__mode__': unknown attribute
warning: /usr/include/_G_config.h:58:67: attribute '__mode__': unknown attribute
hello, world!
"test-hello" return code 0




I did a test pull pasting from the below address to double-check that
the changes are there.  Sigh.


Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.hacking

This will update the following files:

 compile-i386.c |  159 ++++++++++++++++++++++++++++++++++++++-------------------
 compile.c      |    5 +
 evaluate.c     |    7 ++
 3 files changed, 117 insertions(+), 54 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/09 1.428)
   [be] properly emit strings, indirect func calls, and
   func call return values.

<jgarzik@redhat.com> (03/09/09 1.427)
   Fix lost string initializers, in evaluate_string().

<jgarzik@redhat.com> (03/09/09 1.426)
   [be] Kill unused var

<davej@redhat.com> (03/09/09 1.423.1.1)
   Don't crash if no filename specified

<jgarzik@redhat.com> (03/09/09 1.424)
   [be] Handle 'if' using test/jz insns rather than xor/cmp/je
   
   Suggested by Arjan van de Ven.





diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Tue Sep  9 22:09:48 2003
+++ b/compile-i386.c	Tue Sep  9 22:09:48 2003
@@ -40,6 +40,7 @@
 	int pseudo_nr;
 	struct ptr_list *pseudo_list;
 	struct ptr_list *atom_list;
+	struct ptr_list *str_list;
 	struct symbol **argv;
 	unsigned int argc;
 	int ret_target;
@@ -84,10 +85,15 @@
 		/* STOR_LABEL */
 		struct {
 			int label;
+			unsigned long flags;
 		};
 	};
 };
 
+enum {
+	STOR_LABEL_VAL	= (1 << 0),
+};
+
 struct symbol_private {
 	struct storage *addr;
 };
@@ -95,6 +101,7 @@
 enum atom_type {
 	ATOM_TEXT,
 	ATOM_INSN,
+	ATOM_CSTR,
 };
 
 enum {
@@ -119,6 +126,12 @@
 			struct storage *op2;
 			unsigned long flags;
 		};
+
+		/* stuff for C strings */
+		struct {
+			struct string *string;
+			int label;
+		};
 	};
 };
 
@@ -225,7 +238,7 @@
 	stor->sym = sym;
 }
 
-static const char *stor_op_name(struct storage *s)
+static const char *stor_op_name(struct storage *s, unsigned long flags)
 {
 	static char name[32];
 
@@ -246,7 +259,8 @@
 		sprintf(name, "$%Ld", s->value);
 		break;
 	case STOR_LABEL:
-		sprintf(name, ".L%d", s->label);
+		sprintf(name, "%s.L%d", flags & STOR_LABEL_VAL ? "$" : "",
+			s->label);
 		break;
 	}
 
@@ -266,6 +280,18 @@
 	return atom;
 }
 
+static inline void push_cstring(struct function *f, struct string *str,
+				int label)
+{
+	struct atom *atom;
+
+	atom = new_atom(ATOM_CSTR);
+	atom->string = str;
+	atom->label = label;
+
+	add_ptr_list(&f->str_list, atom);	/* note: _not_ atom_list */
+}
+
 static inline void push_atom(struct function *f, struct atom *atom)
 {
 	add_ptr_list(&f->atom_list, atom);
@@ -413,6 +439,8 @@
 {
 	char s[128];
 	char comment[64];
+	struct storage *op1 = atom->op1;
+	struct storage *op2 = atom->op2;
 
 	if (atom->comment[0])
 		sprintf(comment, "\t\t# %s", atom->comment);
@@ -421,12 +449,12 @@
 
 	if (atom->op2) {
 		char tmp[16];
-		strcpy(tmp, stor_op_name(atom->op1));
+		strcpy(tmp, stor_op_name(op1, op1->flags));
 		sprintf(s, "\t%s\t%s, %s%s\n",
-			atom->insn, tmp, stor_op_name(atom->op2), comment);
+			atom->insn, tmp, stor_op_name(op2, op2->flags), comment);
 	} else if (atom->op1)
 		sprintf(s, "\t%s\t%s%s%s\n",
-			atom->insn, stor_op_name(atom->op1),
+			atom->insn, stor_op_name(op1, op1->flags),
 			comment[0] ? "\t" : "", comment);
 	else
 		sprintf(s, "\t%s\t%s%s\n",
@@ -451,10 +479,28 @@
 		case ATOM_INSN:
 			emit_insn_atom(f, atom);
 			break;
+		case ATOM_CSTR:
+			assert(0);
+			break;
 		}
 	} END_FOR_EACH_PTR;
 }
 
+static void emit_string_list(struct function *f)
+{
+	struct atom *atom;
+
+	emit_section(".section\t.rodata");
+
+	FOR_EACH_PTR(f->str_list, atom) {
+		/* FIXME: escape " in string */
+		printf(".L%d:\n", atom->label);
+		printf("\t.string\t%s\n", show_string(atom->string));
+
+		free(atom);
+	} END_FOR_EACH_PTR;
+}
+
 static void func_cleanup(struct function *f)
 {
 	struct storage *stor;
@@ -481,7 +527,6 @@
 /* function prologue */
 static void emit_func_pre(struct symbol *sym)
 {
-	const char *name = show_ident(sym->ident);
 	struct function *f;
 	struct symbol *arg;
 	unsigned int i, argc = 0, alloc_len;
@@ -526,12 +571,6 @@
 
 	assert(current_func == NULL);
 	current_func = f;
-
-	emit_section(".text");
-	if ((sym->ctype.modifiers & MOD_STATIC) == 0)
-		printf(".globl %s\n", name);
-	printf("\t.type\t%s, @function\n", name);
-	printf("%s:\n", name);
 }
 
 /* function epilogue */
@@ -543,15 +582,24 @@
 	int pseudo_nr = f->pseudo_nr;
 	char pseudo_const[16], jump_target[16];
 
-	/* function epilogue */
+	if (f->str_list)
+		emit_string_list(f);
+
+	/* function prologue */
+	emit_section(".text");
+	if ((sym->ctype.modifiers & MOD_STATIC) == 0)
+		printf(".globl %s\n", name);
+	printf("\t.type\t%s, @function\n", name);
+	printf("%s:\n", name);
 	sprintf(pseudo_const, "$%d", pseudo_nr * 4);
 	printf("\tsubl\t%s, %%esp\n", pseudo_const);
 
+	/* function epilogue */
+
 	/* jump target for 'return' statements */
 	sprintf(jump_target, ".L%d:\n", f->ret_target);
 	push_text_atom(f, jump_target);
 
-	/* function prologue */
 	if (ret_val) {
 		/* FIXME: mem operand hardcoded at 32 bits */
 		emit_move(ret_val, REG_EAX, NULL, NULL, 0);
@@ -1006,11 +1054,8 @@
 	/* load 'if' test result into EAX */
 	insn("movl", val, REG_EAX, "begin if conditional", 0);
 
-	/* clear ECX */
-	insn("xorl", REG_ECX, REG_ECX, NULL, 0);
-
 	/* compare 'if' test result */
-	insn("cmpl", REG_EAX, REG_ECX, NULL, 0);
+	insn("test", REG_EAX, REG_EAX, NULL, 0);
 
 	/* create end-of-if label / if-failed labelto jump to,
 	 * and jump to it if the expression returned zero.
@@ -1018,7 +1063,7 @@
 	target = new_label();
 	target_val = new_storage(STOR_LABEL);
 	target_val->label = target;
-	insn("je", target_val, NULL, NULL, ATOM_FREE_OP1);
+	insn("jz", target_val, NULL, NULL, ATOM_FREE_OP1);
 
 	x86_statement(stmt->if_true);
 	if (stmt->if_false) {
@@ -1122,6 +1167,39 @@
 	return new;
 }
 
+static struct storage *emit_symbol_expr_init(struct symbol *sym)
+{
+	struct expression *expr = sym->initializer;
+	struct symbol_private *priv = sym->aux;
+
+	if (priv == NULL) {
+		if (expr == NULL) {
+			assert(0);
+			return NULL;
+		}
+
+		priv = calloc(1, sizeof(*priv));
+		sym->aux = priv;
+		priv->addr = x86_expression(expr);
+	}
+
+	return priv->addr;
+}
+
+static struct storage *emit_string_expr(struct expression *expr)
+{
+	struct function *f = current_func;
+	int label = new_label();
+	struct storage *new = new_pseudo();
+
+	push_cstring(f, expr->string, label);
+
+	new = new_storage(STOR_LABEL);
+	new->label = label;
+	new->flags = STOR_LABEL_VAL;
+	return new;
+}
+
 static void x86_struct_member(struct symbol *sym, void *data, int flags)
 {
 	if (flags & ITERATE_FIRST)
@@ -1369,6 +1447,7 @@
 	struct expression *arg, *fn;
 	struct storage *retval, *fncall;
 	int framesize;
+	char s[64];
 
 	if (!expr->ctype) {
 		warn(expr->pos, "\tcall with no type!");
@@ -1399,23 +1478,26 @@
 		}
 	}
 	if (direct) {
-		char s[64];
 		sprintf(s, "\tcall\t%s\n", show_ident(direct->ident));
 		push_text_atom(f, s);
 	} else {
 		fncall = x86_expression(fn);
-		printf("\tcall\t*v%d\n", fncall->pseudo);
+		emit_move(fncall, REG_EAX, fn->ctype, NULL, 0);
+
+		strcpy(s, "\tcall\t*%%eax\n");
+		push_text_atom(f, s);
 	}
 
 	/* FIXME: pay attention to BITS_IN_POINTER */
 	if (framesize) {
 		struct storage *val = new_storage(STOR_VALUE);
 		val->value = (long long) framesize;
-		insn("addl", val, REG_ESP, "end function call", ATOM_FREE_OP1);
+		insn("addl", val, REG_ESP, NULL, ATOM_FREE_OP1);
 	}
 
 	retval = new_pseudo();
-	printf("\tmov.%d\t\tv%d,retval\n", expr->ctype->bit_size, retval->pseudo);
+	emit_move(REG_EAX, retval, expr->ctype, "end function call", 0);
+
 	return retval;
 }
 
@@ -1571,15 +1653,6 @@
 	return new;
 }
 
-static struct storage *show_string_expr(struct expression *expr)
-{
-	struct storage *new = new_pseudo();
-
-	printf("\tmovi.%d\t\tv%d,&%s\n", BITS_IN_POINTER, new->pseudo,
-		show_string(expr->string));
-	return new;
-}
-
 static struct storage *x86_bitfield_expr(struct expression *expr)
 {
 	return x86_access(expr);
@@ -1632,24 +1705,6 @@
 	} END_FOR_EACH_PTR;
 }
 
-static struct storage *x86_symbol_expr_init(struct symbol *sym)
-{
-	struct expression *expr = sym->initializer;
-	struct symbol_private *priv = sym->aux;
-
-	if (expr)
-		x86_initializer_expr(expr, expr->ctype);
-
-	if (priv == NULL) {
-		fprintf(stderr, "WARNING! priv == NULL\n");
-		priv = calloc(1, sizeof(*priv));
-		sym->aux = priv;
-		priv->addr = new_pseudo(); /* this is wrong! */
-	}
-
-	return priv->addr;
-}
-
 /*
  * Print out an expression. Return the pseudo that contains the
  * variable.
@@ -1685,7 +1740,7 @@
 	case EXPR_POSTOP:
 		return emit_postop(expr);
 	case EXPR_SYMBOL:
-		return x86_symbol_expr_init(expr->symbol);
+		return emit_symbol_expr_init(expr->symbol);
 	case EXPR_DEREF:
 	case EXPR_SIZEOF:
 		warn(expr->pos, "invalid expression after evaluation");
@@ -1695,7 +1750,7 @@
 	case EXPR_VALUE:
 		return emit_value(expr);
 	case EXPR_STRING:
-		return show_string_expr(expr);
+		return emit_string_expr(expr);
 	case EXPR_BITFIELD:
 		return x86_bitfield_expr(expr);
 	case EXPR_INITIALIZER:
diff -Nru a/compile.c b/compile.c
--- a/compile.c	Tue Sep  9 22:09:48 2003
+++ b/compile.c	Tue Sep  9 22:09:48 2003
@@ -33,7 +33,7 @@
 
 int main(int argc, char **argv)
 {
-	int i, fd;
+	int fd;
 	char *basename, *filename = NULL, **args;
 	struct token *token;
 
@@ -53,6 +53,9 @@
 		}
 		filename = arg;
 	}
+
+	if (filename == NULL)
+		die("No file specified");
 
 	basename = strrchr(filename, '/');
 	if (!basename)
diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	Tue Sep  9 22:09:48 2003
+++ b/evaluate.c	Tue Sep  9 22:09:48 2003
@@ -77,13 +77,18 @@
 	struct symbol *sym = alloc_symbol(expr->pos, SYM_NODE);
 	struct symbol *array = alloc_symbol(expr->pos, SYM_ARRAY);
 	struct expression *addr = alloc_expression(expr->pos, EXPR_SYMBOL);
-	int length = expr->string->length;
+	struct expression *initstr = alloc_expression(expr->pos, EXPR_STRING);
+	unsigned int length = expr->string->length;
 
 	sym->array_size = length;
 	sym->bit_size = BITS_IN_CHAR * length;
 	sym->ctype.alignment = 1;
 	sym->ctype.modifiers = MOD_STATIC;
 	sym->ctype.base_type = array;
+	sym->initializer = initstr;
+
+	initstr->ctype = sym;
+	initstr->string = expr->string;
 
 	array->array_size = length;
 	array->bit_size = BITS_IN_CHAR * length;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] extremely minor backend update ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] extremely minor backend update
Date: Tue, 09 Sep 2003 23:41:05 +0000
Message-ID: <20030909234105.GA2471 () gtf ! org>
--------------------

NOTE:  To keep myself from screwing up again, "sparse.hacking" is
now the correct URL.


Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.hacking

This will update the following files:

 compile-i386.c |    7 ++-----
 compile.c      |    5 ++++-
 2 files changed, 6 insertions(+), 6 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/09 1.426)
   [be] Kill unused var

<davej@redhat.com> (03/09/09 1.423.1.1)
   Don't crash if no filename specified

<jgarzik@redhat.com> (03/09/09 1.424)
   [be] Handle 'if' using test/jz insns rather than xor/cmp/je
   
   Suggested by Arjan van de Ven.





diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Tue Sep  9 19:38:13 2003
+++ b/compile-i386.c	Tue Sep  9 19:38:13 2003
@@ -1006,11 +1006,8 @@
 	/* load 'if' test result into EAX */
 	insn("movl", val, REG_EAX, "begin if conditional", 0);
 
-	/* clear ECX */
-	insn("xorl", REG_ECX, REG_ECX, NULL, 0);
-
 	/* compare 'if' test result */
-	insn("cmpl", REG_EAX, REG_ECX, NULL, 0);
+	insn("test", REG_EAX, REG_EAX, NULL, 0);
 
 	/* create end-of-if label / if-failed labelto jump to,
 	 * and jump to it if the expression returned zero.
@@ -1018,7 +1015,7 @@
 	target = new_label();
 	target_val = new_storage(STOR_LABEL);
 	target_val->label = target;
-	insn("je", target_val, NULL, NULL, ATOM_FREE_OP1);
+	insn("jz", target_val, NULL, NULL, ATOM_FREE_OP1);
 
 	x86_statement(stmt->if_true);
 	if (stmt->if_false) {
diff -Nru a/compile.c b/compile.c
--- a/compile.c	Tue Sep  9 19:38:13 2003
+++ b/compile.c	Tue Sep  9 19:38:13 2003
@@ -33,7 +33,7 @@
 
 int main(int argc, char **argv)
 {
-	int i, fd;
+	int fd;
 	char *basename, *filename = NULL, **args;
 	struct token *token;
 
@@ -53,6 +53,9 @@
 		}
 		filename = arg;
 	}
+
+	if (filename == NULL)
+		die("No file specified");
 
 	basename = strrchr(filename, '/');
 	if (!basename)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] fix, clean up comparisons ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 21:29:09 +0000
Message-ID: <20030908212908.GA18505 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse

This will update the following files:

 compile-i386.c |   31 +++++++++----------------------
 1 files changed, 9 insertions(+), 22 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/08 1.419)
   [be] comparison expression update:
   
   * fix comparison order.  was using Intel not AT&T order of operands.
   * replace nested-if tree of string comparisons with a switch
     on expr->op value.



diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Mon Sep  8 17:27:21 2003
+++ b/compile-i386.c	Mon Sep  8 17:27:21 2003
@@ -798,28 +798,15 @@
 	struct storage *right = x86_expression(expr->right);
 	struct storage *new, *val;
 	const char *opname = NULL;
-	static const char *name[] = {
-		['<'] = "cmovl",
-		['>'] = "cmovg",
-	};
-	unsigned int op = expr->op;
 
-	if (op < sizeof(name)/sizeof(*name)) {
-		opname = name[op];
-		assert(opname != NULL);
-	} else {
-		const char *tmp = show_special(op);
-		if (!strcmp(tmp, "<="))
-			opname = "cmovle";
-		else if (!strcmp(tmp, ">="))
-			opname = "cmovge";
-		else if (!strcmp(tmp, "=="))
-			opname = "cmove";
-		else if (!strcmp(tmp, "!="))
-			opname = "cmovne";
-		else {
-			assert(0);
-		}
+	switch(expr->op) {
+	case '<':		opname = "cmovl";	break;
+	case '>':		opname = "cmovg";	break;
+	case SPECIAL_LTE:	opname = "cmovle";	break;
+	case SPECIAL_GTE:	opname = "cmovge";	break;
+	case SPECIAL_EQUAL:	opname = "cmove";	break;
+	case SPECIAL_NOTEQUAL:	opname = "cmovne";	break;
+	default:		assert(0);		break;
 	}
 
 	/* init ECX to 1 */
@@ -835,7 +822,7 @@
 	insn("movl", left, REG_EAX, NULL, 0);
 
 	/* perform comparison, EAX (op1) and op2 */
-	insn("cmpl", REG_EAX, right, NULL, 0);
+	insn("cmpl", right, REG_EAX, NULL, 0);
 
 	/* store result of operation, 0 or 1, in EDX using CMOV */
 	/* FIXME: does this need an operand size suffix? */
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 22:13:30 +0000
Message-ID: <Pine.LNX.4.44.0309081506020.10159-100000 () home ! osdl ! org>
--------------------

On Mon, 8 Sep 2003, Jeff Garzik wrote:
>
>    [be] comparison expression update:
>    
>    * fix comparison order.  was using Intel not AT&T order of operands.
>    * replace nested-if tree of string comparisons with a switch
>      on expr->op value.

Note: you're not getting the sign of the comparison right. I think these 
are all unsigned:

> +	switch(expr->op) {
> +	case '<':		opname = "cmovl";	break;
> +	case '>':		opname = "cmovg";	break;
> +	case SPECIAL_LTE:	opname = "cmovle";	break;
> +	case SPECIAL_GTE:	opname = "cmovge";	break;
> +	case SPECIAL_EQUAL:	opname = "cmove";	break;
> +	case SPECIAL_NOTEQUAL:	opname = "cmovne";	break;
> +	default:		assert(0);		break;

I'm considering making the front-end make separate versions for LT and 
LTU. Comments? Or do you want to do it in the back-end?

You can check with "type_is_signed()" on the subexpressions (don't do it 
on the expression itself: that one should always be a "bool_ctype").

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 22:48:08 +0000
Message-ID: <3F5D0728.6010000 () pobox ! com>
--------------------
Linus Torvalds wrote:
> On Mon, 8 Sep 2003, Jeff Garzik wrote:
> 
>>   [be] comparison expression update:
>>   
>>   * fix comparison order.  was using Intel not AT&T order of operands.
>>   * replace nested-if tree of string comparisons with a switch
>>     on expr->op value.
> 
> 
> Note: you're not getting the sign of the comparison right. I think these 
> are all unsigned:

Known.  I get operand sizes wrong too.  Just assume 32-bit :)

I'm trying to figure out the best way to map this stuff into useful x86 
tools like movsx, movzx, ...

more on this below.


>>+	switch(expr->op) {
>>+	case '<':		opname = "cmovl";	break;
>>+	case '>':		opname = "cmovg";	break;
>>+	case SPECIAL_LTE:	opname = "cmovle";	break;
>>+	case SPECIAL_GTE:	opname = "cmovge";	break;
>>+	case SPECIAL_EQUAL:	opname = "cmove";	break;
>>+	case SPECIAL_NOTEQUAL:	opname = "cmovne";	break;
>>+	default:		assert(0);		break;
> 
> 
> I'm considering making the front-end make separate versions for LT and 
> LTU. Comments? Or do you want to do it in the back-end?

I've been thinking a bit about that.  Haven't really made up my mind though:

gcc (and other compiler texts?) call them machine modes, but I'm a C.S. 
not E.E. geek, and I grew up on C first.  So I think of machine modes as 
C types.  Right now I'm pondering the best way to go from C types to x86 
"types".

The first order of business is storing x86 "type" information for 
entities the backend deals with -- pseudos, global symbols and such. 
I'm wondering how close to C type information I can get.  One 
possibility -- which perhaps answers your question? -- is to ensure that 
sparse _doesn't_ simplify certain statements and operand signedness/size 
conversions.  Then the backend would take over, and choose to either 
generate code or call into sparse lib helpers for further simplification.

For today/week/month, I'm not going to complain when the front-end does 
more work, because the backend is really stupid.  For LT/LTU 
specifically, separating them out would probably make life easier for 
me.  But as time progresses I'll probably want less and less 
simplification and separation like that.


Tangent...
I would like to start moving target.h-type stuff to variables instead of 
constants.  The backend should do something like 
init_sparse(&target_info) to give sparse the info it needs.


Tangent...
Just to ramble a little bit on generalities.  Even though I've never 
written a compiler, even at uni (and it shows!), I've been thinking 
about this stuff for a long time, and reading a lot of Muchnick.  I tend 
to think that a lot of production compilers hit the low level _way_ too 
early.  I wanna see how much I can do at the parse-tree level, or close 
to it.  That's why sparse is really interesting to me.  It gives the 
backend a chance to dive right into a parse tree with _great_ type 
information :)  This will really help when a backend wants to alias 
analysis too, I bet.

But that's a _long_ way off, and probably a different backend.  Another 
goal of mine is simply to have a _small_, _simple_ compiler that builds 
a bootable kernel.  So unless [the phase of the moon] changes, I'll 
probably take compile-i386.c to that level of capability, then let it 
live on a life of its own in your sparse project.  At that point, if I'm 
interested in compiler hacking, I would probably fork it off into a 
more-ambitious compiler project, that links to an already-installed 
sparse lib.


> You can check with "type_is_signed()" on the subexpressions (don't do it 
> on the expression itself: that one should always be a "bool_ctype").

Useful.  Thanks,

	Jeff




-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 23:12:32 +0000
Message-ID: <Pine.LNX.4.44.0309081556110.10331-100000 () home ! osdl ! org>
--------------------

On Mon, 8 Sep 2003, Jeff Garzik wrote:
> 
> I've been thinking a bit about that.  Haven't really made up my mind though:
> 
> gcc (and other compiler texts?) call them machine modes, but I'm a C.S. 
> not E.E. geek, and I grew up on C first.  So I think of machine modes as 
> C types.  Right now I'm pondering the best way to go from C types to x86 
> "types".

Why?

I think the gcc approach is stupid. What's the point of "SI" vs "DI" vs 
"HI" vs "QI"? Wtf? It just doesn't make any sense.

The only thing you care about on a code generation level is

 - size (8, 16, 32, 64, 80, 128, 256, whatever..)
 - type (uint, sint, fp, 4-vector, 8-vector, whatever)

And I don't see any reason to show it any other way. This information is
trivially available in the expression type descriptors: the size is
obviously there (symbol->bit_size) and the type is there too
(ctype.modifiers).

> The first order of business is storing x86 "type" information for 
> entities the backend deals with -- pseudos, global symbols and such. 
> I'm wondering how close to C type information I can get.

See above: you should never care. From a code generation standpoint, "int" 
and "long" are the same if they are the same size.

(From a _type_ standpoint they aren't, but those are all front-end 
issues).

HOWEVER: There are some _operations_ that are different. For example, 
right now "<" can be any number of different kinds of comparisons: it can 
be a FP comparison, it can be unsigned or it can be signed. That was what 
I meant about "expr->op" - I could split that up in the front-end.

> Tangent...
> I would like to start moving target.h-type stuff to variables instead of 
> constants.  The backend should do something like 
> init_sparse(&target_info) to give sparse the info it needs.

That would work for me. Most of it should be ok, with the exception of the 
initializers - right now those depend on the constantness of the sizes.

> Tangent...
> Just to ramble a little bit on generalities.  Even though I've never 
> written a compiler, even at uni (and it shows!), I've been thinking 
> about this stuff for a long time, and reading a lot of Muchnick.  I tend 
> to think that a lot of production compilers hit the low level _way_ too 
> early.  I wanna see how much I can do at the parse-tree level, or close 
> to it.  That's why sparse is really interesting to me.  It gives the 
> backend a chance to dive right into a parse tree with _great_ type 
> information :)  This will really help when a backend wants to alias 
> analysis too, I bet.

There's only so much you _really_ want to do on a tree level, and sparse 
actually does a lot of it already. Basic folding, and inlining. At some 
point the tree format gets too nasty to maintain, and I don't think there 
is much more we want to do on trees. 

I want to do a few more builtin functions (the "tree" level is nice for 
that), but I took care of the one I cared for for correctness already 
(__builtin_constant_p()). 

			Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 23:14:53 +0000
Message-ID: <3F5D0D6D.3090802 () pobox ! com>
--------------------
BTW, feel free to add little nuggets to the 'validation' subdir, for 
interesting signedness/casting/size/whatever test cases I can work on.
(along with a comment about correct results, in case it isn't obvious to 
me...)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 23:32:12 +0000
Message-ID: <Pine.LNX.4.44.0309081625300.10760-100000 () home ! osdl ! org>
--------------------

On Mon, 8 Sep 2003, Jeff Garzik wrote:
>
> BTW, feel free to add little nuggets to the 'validation' subdir, for 
> interesting signedness/casting/size/whatever test cases I can work on.
> (along with a comment about correct results, in case it isn't obvious to 
> me...)

Well, right now even "validation/type1.c" doesn't work. I think Dave Olien 
broke simple initializers.

Dave, you're calling "show_initializer_expr()" on _any_ "sym->initializer"
expression. That's wrong, since "show_initializer_expr()" can only show an 
EXPR_INITIALIZER. And here we have a simple EXPR_DEREF expression as the 
initializer for the function argument.

I think the fix is something like





================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 23:32:59 +0000
Message-ID: <Pine.LNX.4.44.0309081632260.10760-100000 () home ! osdl ! org>
--------------------

[ brainfart ]

On Mon, 8 Sep 2003, Linus Torvalds wrote:
> 
> I think the fix is something like

--- 1.83/show-parse.c	Mon Sep  1 16:45:01 2003
+++ edited/show-parse.c	Mon Sep  8 16:31:06 2003
@@ -918,7 +918,7 @@
 	struct expression *expr = sym->initializer;
 
 	if (expr)
-		show_initializer_expr(expr, expr->ctype);
+		show_expression(expr);
 	return show_symbol_expr(sym);
 }
 

with something similar needed in Jeff's code.

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Mon, 08 Sep 2003 23:35:02 +0000
Message-ID: <3F5D1226.8090700 () pobox ! com>
--------------------
Linus Torvalds wrote:
> Why?
> 
> I think the gcc approach is stupid. What's the point of "SI" vs "DI" vs 
> "HI" vs "QI"? Wtf? It just doesn't make any sense.
> 
> The only thing you care about on a code generation level is
> 
>  - size (8, 16, 32, 64, 80, 128, 256, whatever..)
>  - type (uint, sint, fp, 4-vector, 8-vector, whatever)
> 
> And I don't see any reason to show it any other way.

I suck at communication sometimes.  And I'm an English-only speaker. 
Sigh.  Or maybe C is my second language.  :)

I agree with you 100%.  I think the gcc approach is stupid too, and I 
want to use C type information at the lowest levels of the backend.

Let me see if I can rephrase:  The backend was doing code generation 
using printf 72 hours ago or so.  So, I'm trying to figure out the best 
path of evolution, from current code to what you describe above.  If you 
look closely at my backend's struct storage, most of the stuff in there 
wants to be (or is) a symbol or is at least an expr->value.

Open64's WHIRL intermediate representation provides almost exactly what 
you describe above.  It supports the most complex C types.  As 
successive optimization passes occurs, the complex C types are factored 
into more simple ones (Complex -> u32 pair, bitfields merged into bit 
ops on a scalar), but the type information remains.


Tangent...
A future reworking I am pondering separates the parse-tree walking code 
out and makes it generic.  That will make sparse a lot easier to use, to 
more people, IMO.  Granted there are different walks one may want, but 
the "linearizing walk" is what we have now, and fairly straightforward 
to go from show-parse/compile-i386 to walk.[ch], and a collection of 
useful callbacks.

Using common walker code, it would be easy to get sparse to spit out 
WHIRL, for example :)

WHIRL spec is public:  http://open64.sourceforge.net/documentation.html


> There's only so much you _really_ want to do on a tree level, and sparse 
> actually does a lot of it already. Basic folding, and inlining. At some 
> point the tree format gets too nasty to maintain, and I don't think there 
> is much more we want to do on trees. 

Eventually I will prefer do the folding, even.  Consider constant 
folding for cross-compiled floating point code:  you basically have to 
have a math emulator in your compiler.

But yeah, at some point it's definitely flow-graph time.  And I have 
some interesting SSA-ish ideas in that direction, for situations (as 
with sparse) where a wealth of C type information is available.  Loops 
gives me headaches, though :)

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Tue, 09 Sep 2003 00:31:45 +0000
Message-ID: <3F5D1F71.4000600 () pobox ! com>
--------------------
Linus Torvalds wrote:
> You can check with "type_is_signed()" on the subexpressions (don't do it 
> on the expression itself: that one should always be a "bool_ctype").


Dumb question, Mr. Type Expert :)

Given two sub-expressions, what do I do if one sub-expr is signed, and 
the other is not?

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Tue, 09 Sep 2003 02:35:11 +0000
Message-ID: <Pine.LNX.4.44.0309081934330.10873-100000 () home ! osdl ! org>
--------------------

On Mon, 8 Sep 2003, Jeff Garzik wrote:
> 
> Dumb question, Mr. Type Expert :)
> 
> Given two sub-expressions, what do I do if one sub-expr is signed, and 
> the other is not?

You should never see that. That would be a bug.

The front-end already does all type promotions as per the C standard. So 
the back-end never needs to worry about details like that.

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] fix, clean up comparisons
Date: Wed, 10 Sep 2003 03:49:56 +0000
Message-ID: <3F5E9F64.60703 () pobox ! com>
--------------------
Linus Torvalds wrote:
> --- 1.83/show-parse.c	Mon Sep  1 16:45:01 2003
> +++ edited/show-parse.c	Mon Sep  8 16:31:06 2003
> @@ -918,7 +918,7 @@
>  	struct expression *expr = sym->initializer;
>  
>  	if (expr)
> -		show_initializer_expr(expr, expr->ctype);
> +		show_expression(expr);
>  	return show_symbol_expr(sym);
>  }
>  
> 
> with something similar needed in Jeff's code.


Yep, that's basically what I wound up doing.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] get 'return' working ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] get 'return' working
Date: Sun, 07 Sep 2003 21:18:21 +0000
Message-ID: <20030907211821.GA13691 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse

This will update the following files:

 compile-i386.c |   64 +++++++++++++++++++++++++++++----------------------------
 1 files changed, 33 insertions(+), 31 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/07 1.414)
   [be] get return values and jump targets working






diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Sun Sep  7 17:15:58 2003
+++ b/compile-i386.c	Sun Sep  7 17:15:58 2003
@@ -42,6 +42,7 @@
 	struct textbuf *buf;
 	struct symbol **argv;
 	unsigned int argc;
+	int ret_target;
 };
 
 enum storage_type {
@@ -332,6 +333,7 @@
 	storage_base	=  (struct storage *) mem;
 
 	f->argc = argc;
+	f->ret_target = new_label();
 
 	i = 0;
 	FOR_EACH_PTR(base_type->arguments, arg) {
@@ -359,17 +361,26 @@
 	const char *name = show_ident(sym->ident);
 	struct function *f = current_func;
 	int pseudo_nr = f->pseudo_nr;
-	char s[16];
+	char pseudo_const[16], jump_target[16];
+
+	/* function epilogue */
+	sprintf(pseudo_const, "$%d", pseudo_nr * 4);
+	printf("\tsubl\t%s, %%esp\n", pseudo_const);
+
+	/* jump target for 'return' statements */
+	sprintf(jump_target, ".L%d:\n", f->ret_target);
+	textbuf_push(&f->buf, jump_target);
 
-	sprintf(s, "$%d", pseudo_nr * 4);
-	printf("\tsubl\t%s, %%esp\n", s);
+	/* function prologue */
 	if (val)
 		insn("movl", stor_op_name(val), "%eax", stor_arg_warning(val));
-	insn("addl", s, "%esp", NULL);
+	insn("addl", pseudo_const, "%esp", NULL);
 	insn("ret", NULL, NULL, NULL);
 
+	/* output everything to stdout */
 	textbuf_emit(&f->buf);
 
+	/* function footer */
 	printf("\t.size\t%s, .-%s\n", name, name);
 
 	func_cleanup(f);
@@ -812,6 +823,22 @@
 	return emit_inc_dec(expr, 1);
 }
 
+static struct storage *emit_return_stmt(struct statement *stmt)
+{
+	struct function *f = current_func;
+	struct expression *expr = stmt->ret_value;
+	struct storage *val = NULL;
+	char s[32];
+
+	if (expr && expr->ctype)
+		val = x86_expression(expr);
+
+	sprintf(s, "\tjmp\t.L%d\n", f->ret_target);
+	textbuf_push(&f->buf, s);
+
+	return val;
+}
+
 static void x86_struct_member(struct symbol *sym, void *data, int flags)
 {
 	if (flags & ITERATE_FIRST)
@@ -946,8 +973,6 @@
 	} END_FOR_EACH_PTR;
 }
 
-static void x86_return_stmt(struct statement *stmt);
-
 /*
  * Print out a statement
  */
@@ -957,8 +982,7 @@
 		return 0;
 	switch (stmt->type) {
 	case STMT_RETURN:
-		x86_return_stmt(stmt);
-		return NULL;
+		return emit_return_stmt(stmt);
 	case STMT_COMPOUND: {
 		struct statement *s;
 		struct storage *last = NULL;
@@ -967,15 +991,7 @@
 		FOR_EACH_PTR(stmt->stmts, s) {
 			last = x86_statement(s);
 		} END_FOR_EACH_PTR;
-		if (stmt->ret) {
-			struct storage *addr;
-			int bits;
-			printf(".L%p:\n", stmt->ret);
-			addr = x86_symbol_expr(stmt->ret);
-			bits = stmt->ret->bit_size;
-			last = new_pseudo();
-			printf("\tld.%d\t\tv%d,[v%d]\n", bits, last->pseudo, addr->pseudo);
-		}
+
 		return last;
 	}
 
@@ -1161,20 +1177,6 @@
 	addr = x86_address_gen(target);
 	emit_move(target, addr, val, bits);
 	return val;
-}
-
-static void x86_return_stmt(struct statement *stmt)
-{
-	struct expression *expr = stmt->ret_value;
-	struct symbol *target = stmt->ret_target;
-
-	if (expr && expr->ctype) {
-		struct storage *val = x86_expression(expr);
-		int bits = expr->ctype->bit_size;
-		struct storage *addr = x86_symbol_expr(target);
-		emit_store(NULL, addr, val, bits);
-	}
-	printf("\tgoto .L%p\n", target);
 }
 
 static int x86_initialization(struct symbol *sym, struct expression *expr)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] get 'return' working
Date: Sun, 07 Sep 2003 21:22:19 +0000
Message-ID: <20030907212219.GA13906 () gtf ! org>
--------------------
I was using this quick test:

int main(int argc, char *argv[])
{
        if (argc == 2)
                return 1;
        return 0;
}

You may want to check my assembly.

Note that I was surprised that it generated the correct code for the
argument's stack offset, since that code is definitely incorrect ATM :)

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [bk][sparse] get 'return' working
Date: Sun, 07 Sep 2003 21:29:09 +0000
Message-ID: <Pine.LNX.4.44.0309071428110.21192-100000 () home ! osdl ! org>
--------------------

On Sun, 7 Sep 2003, Jeff Garzik wrote:
> 
> Note that I was surprised that it generated the correct code for the
> argument's stack offset, since that code is definitely incorrect ATM :)

You shouldn't be surprised - it doesn't seem to work.

	./compile test.c > test.s
	gcc test.s
	./a.out 1
	echo $?

results in 0, not 1.

But yeah, it's getting closer.

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [bk][sparse] get 'return' working
Date: Sun, 07 Sep 2003 21:38:57 +0000
Message-ID: <3F5BA571.7010606 () pobox ! com>
--------------------
And I proudly present the first program that works :)

	int main()
	{
	        return 5;
	}


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] minor backend update ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] minor backend update
Date: Thu, 11 Sep 2003 19:54:22 +0000
Message-ID: <20030911195422.GA29256 () gtf ! org>
--------------------

Linus, please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c       |   43 ++++++++++++++++++++++++++++---------------
 validation/test-be.c |   43 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 71 insertions(+), 15 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (03/09/11 1.438)
   [be] temporarily ignore size of a callee func call's return value.
   Now, we just assume it's the ABI size (32 bits) rather than
   care about the distinction between what we want to return up the
   parse tree stack (possibly not 32 bits), and what the ABI gives
   us (32 bits).
   
   Also, add new file validation/test-be.c, to house a growing
   collection of basic sanity checks I can run, to help avoid
   regressions.

<jgarzik@redhat.com> (03/09/11 1.437)
   [be] add to-do list compile-i386.c header

<jgarzik@redhat.com> (03/09/11 1.436)
   [be] clean up binop selection.  add support for shift left/right




diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Thu Sep 11 15:45:59 2003
+++ b/compile-i386.c	Thu Sep 11 15:45:59 2003
@@ -9,6 +9,19 @@
  *
  * x86 backend
  *
+ * TODO list:
+ * loops
+ * 'switch' statements
+ * complex initializers
+ * bitfields
+ * global struct/union variables
+ * addressing structures, and members of structures (as opposed to
+ *     scalars) on the stack.  Requires smarter stack frame allocation.
+ * labels / goto
+ * any function argument that isn't 32 bits (or promoted to such)
+ * inline asm
+ * floating point
+ *
  */
 #include <stdarg.h>
 #include <stdlib.h>
@@ -1004,14 +1017,7 @@
 	struct storage *left = x86_expression(expr->left);
 	struct storage *right = x86_expression(expr->right);
 	struct storage *new;
-	const char *opname;
-	static const char *name[] = {
-		['+'] = "addl", ['-'] = "subl",
-		['*'] = "mull", ['/'] = "divl",
-		['%'] = "modl", ['&'] = "andl",
-		['|'] = "orl", ['^'] = "xorl"
-	};
-	unsigned int op = expr->op;
+	const char *opname = NULL;
 
 	/*
 	 * FIXME FIXME this routine is so wrong it's not even funny.
@@ -1020,12 +1026,19 @@
 	 * and like elsewhere we hardcode the operand size at 32 bits.
 	 */
 
-	opname = show_special(op);
-	if (op < sizeof(name)/sizeof(*name)) {
-		opname = name[op];
-		assert(opname != NULL);
-	} else
-		assert(0); /* FIXME: no operations other than name[], ATM */
+	switch (expr->op) {
+	case '+':			opname = "addl";	break;
+	case '-':			opname = "subl";	break;
+	case '*':			opname = "mull";	break;
+	case '/':			opname = "divl";	break;
+	case '%':			opname = "modl";	break;
+	case '&':			opname = "andl";	break;
+	case '|':			opname = "orl";		break;
+	case '^':			opname = "xorl";	break;
+	case SPECIAL_LEFTSHIFT:		opname = "shll";	break;
+	case SPECIAL_RIGHTSHIFT:	opname = "shrl";	break;
+	default:			assert(0);		break;
+	}
 
 	/* load op2 into EAX */
 	insn("movl", right, REG_EAX, "EXPR_BINOP/COMMA/LOGICAL", 0);
@@ -1568,7 +1581,7 @@
 	}
 
 	retval = new_pseudo();
-	emit_move(REG_EAX, retval, expr->ctype, "end function call", 0);
+	emit_move(REG_EAX, retval, NULL, "end function call", 0);
 
 	return retval;
 }
diff -Nru a/validation/test-be.c b/validation/test-be.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/validation/test-be.c	Thu Sep 11 15:45:59 2003
@@ -0,0 +1,43 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#undef PRINT_OUTPUTS
+
+static void test_func_args(int x, int y)
+{
+	if (x == y)
+		exit(1);
+}
+
+static int binop_s32(int x, int y)
+{
+	int a;
+
+	a = a + x;
+	a = a / y;
+	a = a * x;
+	a = a - y;
+
+	return a;
+}
+
+static void test_binops(void)
+{
+	int tmp_s32 = binop_s32(987123, 234);
+
+#ifdef PRINT_OUTPUTS
+	printf("binop_s32(987123, 234) == %d\n", tmp_s32);
+#else
+	if (tmp_s32 != -1470599007)
+		exit(2);
+#endif
+}
+
+int main (int argc, char *argv[])
+{
+	test_func_args(1, 2);
+	test_binops();
+
+	return 0;
+}
+
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] move the definition of __CHECKER__ only to check.c ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: [bk][sparse] move the definition of __CHECKER__ only to check.c
Date: Fri, 12 Sep 2003 02:07:50 +0000
Message-ID: <20030912020750.GE5575 () conectiva ! com ! br>
--------------------
Linus, please do a

	bk pull bk://kernel.bkbits.net/acme/sparse.acme

	Now there are two outstanding changesets in this tree.

- Arnaldo

You can import this changeset into BK by piping this whole message to:
'| bk receive [path to repository]' or apply the patch as usual.

===================================================================


ChangeSet@1.437, 2003-09-11 23:01:48-03:00, acme@conectiva.com.br
  o move the definition of __CHECKER__ only to check.c


 check.c |    1 +
 lib.c   |    1 -
 2 files changed, 1 insertion(+), 1 deletion(-)


diff -Nru a/check.c b/check.c
--- a/check.c	Thu Sep 11 23:04:51 2003
+++ b/check.c	Thu Sep 11 23:04:51 2003
@@ -39,6 +39,7 @@
 	init_symbols();
 
 	create_builtin_stream();
+	add_pre_buffer("#define __CHECKER__ 1\n");
 	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, unsigned long);\n");
 	add_pre_buffer("extern void * __builtin_return_address(int);\n");
 
diff -Nru a/lib.c b/lib.c
--- a/lib.c	Thu Sep 11 23:04:51 2003
+++ b/lib.c	Thu Sep 11 23:04:51 2003
@@ -402,7 +402,6 @@
 	add_pre_buffer("#define __linux__ 1\n");
 	add_pre_buffer("#define __STDC__ 1\n");
 	add_pre_buffer("#define linux linux\n");
-	add_pre_buffer("#define __CHECKER__ 1\n");
 	add_pre_buffer("#define cond_syscall(x)\n");
 	add_pre_buffer("#define __GNUC__ 2\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");

===================================================================


This BitKeeper patch contains the following changesets:
1.437
## Wrapped with gzip_uu ##


M'XL( ,,I83\  \U576O;,!1]CG[%I7G9&''TY0]Y9'1+RSHZ6,CHV\#(\G7C
M);&"[684_..G."5=0[O@L8<*/]B^TCWGWG,D#>&FQBH>:+-&,H0K6S?QP-@2
M35-LM6?LVDLK%YA;ZP+CA5WC.%V.ZXVN:O2Z52XZTXU9P!:K.AXP3QS^-/<;
MC ?SR\\W7S_."9E,8+K0Y2U^QP8F$]+8:JM767V^2^LUE2[K-38=:GN8V')*
M!15,,"4#(5M?A:%H183,L)3J*,0L0$IV5,Z/B1]G48Q3QJ@4K?2YI.0"F"=%
M"%2,J1HS!ES$E,4R&E'W0N'9I/".PXB23_ _Z4^) 0MKNT5H%@@9YD59-(4M
MP>:0)-.KR^GUY3Q)P):K>X<,9H%FZ1ER#5)R*LGLL;5DU',00C4E'_Y:T*I(
M/7,HAC-?"=5R$2F_]=-0YZF?FC22.J#!\VW[,\-.!Z>$C%K.><!/0#^4NE\J
M:<AW(VB99*Z?*E1*"*T48I:ZCQ? G^1XA/=]RD5GS(<)IVS9B\O>E&ZK%+7Q
MEEB5N/JIG:RVJCU;W1Z1<K04C83K)Y,JZKS)15]KLE=ES7U[O\&H^M4]SFJS
M0[B_2[](!HP,=)8EFPJ3]"[/L7IS-NPHX1,N[$=Y]O9]IVSGNU.Z]K#W"T?-
MD;WWQPSWPRCLI!2RKY041NSU2+G?J$=2=C7_@Y 7DOI.R<,]T<'4=^M)Z@HP
,>8#D-^^)">"8!@  
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [bk][sparse] split handle_switch ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: [bk][sparse] split handle_switch
Date: Fri, 12 Sep 2003 01:47:40 +0000
Message-ID: <20030912014739.GC5575 () conectiva ! com ! br>
--------------------
Linus, please do a

	bk pull bk://kernel.bkbits.net/acme/sparse.acme

- Arnaldo


You can import this changeset into BK by piping this whole message to:
'| bk receive [path to repository]' or apply the patch as usual.

===================================================================


ChangeSet@1.436, 2003-09-11 22:10:43-03:00, acme@conectiva.com.br
  o split handle_switch, to make it more lib friendly
  
  I.e. a more complex tool will need a different handle_switch,
  so make the handling of each switch a function that can be
  used by such specialized handle_switch while keeping handle_switch
  for simpler tools.


 lib.c |  100 ++++++++++++++++++++++++++++++++++++++++--------------------------
 1 files changed, 61 insertions(+), 39 deletions(-)


diff -Nru a/lib.c b/lib.c
--- a/lib.c	Thu Sep 11 22:44:06 2003
+++ b/lib.c	Thu Sep 11 22:44:06 2003
@@ -326,52 +326,74 @@
 	va_end(args);
 }
 
-char **handle_switch(char *arg, char **next)
+char **handle_switch_D(char *arg, char **next)
 {
-	switch (*arg) {
-	case 'D': {
-		const char *name = arg+1;
-		const char *value = "";
-		for (;;) {
-			char c;
-			c = *++arg;
-			if (!c)
-				break;
-			if (isspace(c) || c == '=') {
-				*arg = '\0';
-				value = arg+1;
-				break;
-			}
+	const char *name = arg + 1;
+	const char *value = "";
+	for (;;) {
+		char c;
+		c = *++arg;
+		if (!c)
+			break;
+		if (isspace(c) || c == '=') {
+			*arg = '\0';
+			value = arg + 1;
+			break;
 		}
-		add_pre_buffer("#define %s %s\n", name, value);
-		return next;
 	}
+	add_pre_buffer("#define %s %s\n", name, value);
+	return next;
+}
 
-	case 'E':
-		preprocess_only = 1;
-		return next;
-	case 'v':
-		verbose = 1;
-		return next;
-	case 'I':
-		add_pre_buffer("#add_include \"%s/\"\n", arg+1);
-		return next;
-	case 'i':
-		if (*next && !strcmp(arg, "include")) {
-			char *name = *++next;
-			int fd = open(name, O_RDONLY);
-			include_fd = fd;
-			include = name;
-			if (fd < 0)
-				perror(name);
-			return next;
-		}
-	/* Fallthrough */
+char **handle_switch_E(char *arg, char **next)
+{
+	preprocess_only = 1;
+	return next;
+}
+
+char **handle_switch_v(char *arg, char **next)
+{
+	verbose = 1;
+	return next;
+}
+char **handle_switch_I(char *arg, char **next)
+{
+	add_pre_buffer("#add_include \"%s/\"\n", arg + 1);
+	return next;
+}
+
+char **handle_switch_i(char *arg, char **next)
+{
+	if (*next && !strcmp(arg, "include")) {
+		char *name = *++next;
+		int fd = open(name, O_RDONLY);
+
+		include_fd = fd;
+		include = name;
+		if (fd < 0)
+			perror(name);
+	}
+	return next;
+}
+
+char **handle_switch(char *arg, char **next)
+{
+	char **rc = next;
+
+	switch (*arg) {
+	case 'D': rc = handle_switch_D(arg, next); break;
+	case 'E': rc = handle_switch_E(arg, next); break;
+	case 'v': rc = handle_switch_v(arg, next); break;
+	case 'I': rc = handle_switch_I(arg, next); break;
+	case 'i': rc = handle_switch_i(arg, next); break;
 	default:
-		/* Ignore unknown command line options - they're probably gcc switches */
+		/*
+		 * Ignore unknown command line options:
+		 * they're probably gcc switches
+		 */
 		break;
 	}
-	return next;
+	return rc;
 }
 
 void create_builtin_stream(void)

===================================================================


This BitKeeper patch contains the following changesets:
1.436
## Wrapped with gzip_uu ##


M'XL( .8D83\  ^U6;6_B1A#^C'_%'*<[("]F[34OAE*E/:(6]=1$J>Y#)22T
M7H_!A[&M74,N5^Z_=]:&Y)(CM*G:;T46QCOS//.RSZQY#1\TJD%-R!5:K^'G
M3!>#FLQ2E$6\$;;,5G:@R'"3961H+[(5MH-E6^=":;1+%%FO12$7L$&E!S7'
MYO<KQ5V.@]K-Y4\?WO]P8UFC$;Q;B'2.OV$!HY%59&HCDE!?&%J[4"+5*RS*
MJ-M[QZW+&&?<X8[O=;FW[?B]'M_R/CK2"9CH]S#L(K,^SH7Z'"\O%(8+41RB
M\!V'>:S/NENOZW9\:PR.[?$N,-YF?MMQP'4'#AMX_)SQ 6-@BKMXV@HX=>"<
M63_"OYG[.TM"!CI/X@((&B8XT[<Q-?",PL!*+!'(LLH40A('$*D8R>F.4'1-
M;+1!5%8*GB?XB5!9 K=QDD"*&)(UC*,(%:9/^0FO=Q&*!5;&.)U#%@$*VL#*
MC0BB=4IMR%)R$P5(D4* !%YKH@_N0*^-<XXR%DG\F=8>A8';19P@+!%S0_[(
M1B11ID#')G-59JYMZQ?P.J['K.L'P5CG+_Q8%A/,^O[H3E$[;7F_2Z[3\;F_
M=7G?[VP[04]$02>00=\37=8]K(>O&7S'949C?.MV>OU>J??2_%=:?T$65ID%
M35^LI;U$E6+R4:0QL6L[4_-'Z5!"/NMS(G&[.[US_E*Y=TGOW/]?\/^YX"O-
M7,&YNBTO$O!U)9]_H/PQ=WUPK$EUDPNAX.3D41JS<;-:%FI^!CN/%#\5+0)S
M!QR/T)X'CF.9]X$N=CZI6"&,@%!P"L[PL9$$LC;6>IT,ILKF<-B"/ZQ:K;3+
MH?E%]I/34R(P3W$$S5>R1;]J@4*QW*_%FEXQ$INR!=LMF F"QJA1<=5,SL32
MF+*&\:_MPSXD=<\VYEX77%-*'[A5$V$XRQ7.@K611[/^.L0H3A'>:+JF:?T,
M3'UG4#*VB$AAL58IF,8,K2]$UV'@,N+K^N ]T]G+9SM+V5/T7&42M9YE:7)'
M63O?AID>)MX<(Z:W;Y!I/$QXD&YRC.Z;3IF%.)7).D28UM_H]K1>-FS7] /-
M>J:*^%A8L_?E$[Q]"Z]TH>0J;Y:>]5WP>NLK1>WE2(*JHI)Z:.:CD-:R'--F
MM9U7LYOQU:_O?Z<DIZ5+R30KW:)P^+!$SP:Q5R$Y? >L5&>.2F6JY#.E?OF;
MU1ZK=?>LS$14+)3<[@!I&DA9J!2TJ8UQ8P"EX],A+IE+RB'L)ZB"7!Z&7!Z!
M; Y#-D<@D\.0R1%(?!@2'X*,><\I#S*Z>;0/[1/Z@A.8S%-S_J_399K=IN8]
ML"(R.B]IF+/<'-QZ4'G2,7_7(%>:ND $-'%S*7?'/.K2I6VB>%44<]OOK*+S
9ZOZO+'G+I5ZO1B$GK\@7UI\2=)E^.PL     
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [patch] "silly sparse x86 backend" ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 19:07:25 +0000
Message-ID: <3F5B81ED.9050205 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------090600030807010000010601
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Here's what I have so far.

Comments welcome.  It cannot be considered anywhere near complete, but 
it acts like it generates x86 asm for a bunch of small test cases anyway :)

It started out as show-parse.c.  The emit_xxx stuff is what I have 
converted from show-parse pseudo-code into x86 code generation.  The 
x86_xxx stuff is the stuff that remains.  FIXMEs abound.

I haven't actually tried to assmble anything yet.  Just studying what 
gcc generates, and then what I generate.

A few random notes in closing:

* function-at-a-time

* just does one subl and one addl for stack manipulation, which implies 
that it has to output everything from post-function cleanup pass 
(emit_func_post).

* however, x86_xxx stuff (not yet converted) will still print out 
pseudocode.  So your output will look like
	function header
	psuedocode (i.e. stuff not yet handled)
	real x86 code

If you don't see any pseudocode... you may actually be lucky enough to 
be able to compile your asm ;-)


--------------090600030807010000010601
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

diff -Nru a/Makefile b/Makefile
--- a/Makefile	Sun Sep  7 14:58:08 2003
+++ b/Makefile	Sun Sep  7 14:58:08 2003
@@ -1,9 +1,10 @@
 CC=gcc
 CFLAGS=-g -Wall
+LDFLAGS=-g
 AR=ar
 
 PREFIX=$(HOME)
-PROGRAMS=test-lexing test-parsing obfuscate check
+PROGRAMS=test-lexing test-parsing obfuscate check compile
 
 LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h
 
@@ -24,16 +25,19 @@
 	install -C check $(PREFIX)/bin/sparse
 
 test-lexing: test-lexing.o $(LIB_FILE)
-	gcc -o $@ $< $(LIBS)
+	gcc $(LDFLAGS) -o $@ $< $(LIBS)
 
 test-parsing: test-parsing.o $(LIB_FILE)
-	gcc -o $@ $< $(LIBS)
+	gcc $(LDFLAGS) -o $@ $< $(LIBS)
+
+compile: compile.o compile-i386.o $(LIB_FILE)
+	gcc $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
 
 obfuscate: obfuscate.o $(LIB_FILE)
-	gcc -o $@ $< $(LIBS)
+	gcc $(LDFLAGS) -o $@ $< $(LIBS)
 
 check: check.o $(LIB_FILE)
-	gcc -o $@ $< $(LIBS)
+	gcc $(LDFLAGS) -o $@ $< $(LIBS)
 
 $(LIB_FILE): $(LIB_OBJS)
 	$(AR) rcs $(LIB_FILE) $(LIB_OBJS)
@@ -48,6 +52,8 @@
 symbol.o: $(LIB_H)
 test-lexing.o: $(LIB_H)
 test-parsing.o: $(LIB_H)
+compile.o: $(LIB_H)
+compile-i386.o: $(LIB_H)
 tokenize.o: $(LIB_H)
 
 pre-process.h:
diff -Nru a/compile-i386.c b/compile-i386.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/compile-i386.c	Sun Sep  7 14:58:08 2003
@@ -0,0 +1,1452 @@
+/*
+ * sparse/compile-i386.c
+ *
+ * Copyright (C) 2003 Transmeta Corp.
+ *               2003 Linus Torvalds
+ * Copyright 2003 Jeff Garzik
+ *
+ * Licensed under the Open Software License version 1.1
+ *
+ * x86 backend
+ *
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <assert.h>
+
+#include "lib.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "scope.h"
+#include "expression.h"
+#include "target.h"
+
+
+struct textbuf;
+struct textbuf {
+	unsigned int	len;	/* does NOT include terminating null */
+	char		*text;
+	struct textbuf	*next;
+	struct textbuf	*prev;
+};
+
+struct function {
+	int pseudo_nr;
+	struct ptr_list *pseudo_list;
+	struct textbuf *buf;
+	struct symbol **argv;
+	unsigned int argc;
+};
+
+enum storage_type {
+	STOR_PSEUDO,	/* variable stored on the stack */
+	STOR_ARG,	/* function argument */
+	STOR_SYM,	/* a symbol we can directly ref in the asm */
+};
+
+struct storage {
+	enum storage_type type;
+	union {
+		/* stuff for pseudos */
+		struct {
+			int pseudo;
+		};
+		/* stuff for function arguments */
+		struct {
+			int idx;
+		};
+		/* stuff for symbols */
+		struct {
+			struct symbol *sym;
+		};
+	};
+};
+
+struct symbol_private {
+	struct storage *addr;
+};
+
+struct function *current_func = NULL;
+struct textbuf *unit_post_text = NULL;
+static const char *current_section;
+
+
+static struct storage *x86_address_gen(struct expression *expr);
+static struct storage *x86_symbol_expr(struct symbol *sym);
+static void x86_symbol(struct symbol *sym);
+static struct storage *x86_statement(struct statement *stmt);
+static struct storage *x86_expression(struct expression *expr);
+
+
+static inline unsigned int pseudo_offset(struct storage *s)
+{
+	if (s->type != STOR_PSEUDO)
+		return 123456;	/* intentionally bogus value */
+
+	return ((s->pseudo - 1) * 4);
+}
+
+static inline unsigned int arg_offset(struct storage *s)
+{
+	if (s->type != STOR_ARG)
+		return 123456;	/* intentionally bogus value */
+
+	/* FIXME: this is wrong wrong wrong */
+	return (current_func->pseudo_nr + 1) * 4;
+}
+
+static const char *pretty_offset(int ofs)
+{
+	static char esp_buf[64];
+
+	if (ofs)
+		sprintf(esp_buf, "%d(%%esp)", ofs);
+	else
+		strcpy(esp_buf, "(%esp)");
+
+	return esp_buf;
+}
+
+static void stor_sym_init(struct symbol *sym)
+{
+	struct storage *stor;
+	struct symbol_private *priv;
+
+	priv = calloc(1, sizeof(*priv) + sizeof(*stor));
+	if (!priv)
+		die("OOM in stor_sym_init");
+
+	stor = (struct storage *) (priv + 1);
+
+	priv->addr = stor;
+	stor->type = STOR_SYM;
+	stor->sym = sym;
+}
+
+/* we don't yet properly locate arguments on the stack.  we generate
+ * an offset based on the stack frame at the time the argument is
+ * referenced, which is incorrect, because the stack frame pointer
+ * may change after that point, and before the end of the function.
+ */
+static const char *stor_arg_warning(struct storage *s)
+{
+	static const char warning[32] = "stack offset WRONG!";
+
+	if (s->type != STOR_ARG)
+		return NULL;
+
+	return warning;
+}
+
+static const char *stor_op_name(struct storage *s)
+{
+	static char name[32];
+
+	switch (s->type) {
+	case STOR_PSEUDO:
+		strcpy(name, pretty_offset((int) pseudo_offset(s)));
+		break;
+	case STOR_ARG:
+		strcpy(name, pretty_offset((int) arg_offset(s)));
+		break;
+	case STOR_SYM:
+		strcpy(name, show_ident(s->sym->ident));
+		break;
+	}
+
+	return name;
+}
+
+static struct storage *new_pseudo(void)
+{
+	struct function *f = current_func;
+	struct storage *stor;
+
+	assert(f != NULL);
+
+	stor = calloc(1, sizeof(*stor));
+	if (!stor)
+		die("OOM in new_pseudo");
+
+	stor->type = STOR_PSEUDO;
+	stor->pseudo = ++f->pseudo_nr;
+
+	add_ptr_list(&f->pseudo_list, stor);
+
+	return stor;
+}
+
+static int new_label(void)
+{
+	static int label = 0;
+	return ++label;
+}
+
+static void textbuf_push(struct textbuf **buf_p, const char *text)
+{
+	struct textbuf *tmp, *list = *buf_p;
+	unsigned int text_len = strlen(text);
+	unsigned int alloc_len = text_len + 1 + sizeof(*list);
+
+	tmp = calloc(1, alloc_len);
+	if (!tmp)
+		die("OOM on textbuf alloc");
+
+	tmp->text = ((void *) tmp) + sizeof(*tmp);
+	memcpy(tmp->text, text, text_len + 1);
+	tmp->len = text_len;
+
+	/* add to end of list */
+	if (!list) {
+		list = tmp;
+		tmp->prev = tmp;
+	} else {
+		tmp->prev = list->prev;
+		tmp->prev->next = tmp;
+		list->prev = tmp;
+	}
+	tmp->next = list;
+
+	*buf_p = list;
+}
+
+static void textbuf_emit(struct textbuf **buf_p)
+{
+	struct textbuf *tmp, *list = *buf_p;
+
+	while (list) {
+		tmp = list;
+		if (tmp->next == tmp)
+			list = NULL;
+		else {
+			tmp->prev->next = tmp->next;
+			tmp->next->prev = tmp->prev;
+			list = tmp->next;
+		}
+
+		fputs(tmp->text, stdout);
+
+		free(tmp);
+	}
+
+	*buf_p = list;
+}
+
+static void insn(const char *insn, const char *op1, const char *op2,
+		 const char *comment_in)
+{
+	struct function *f = current_func;
+	char s[128];
+	char comment[64];
+
+	assert(insn != NULL);
+
+	if (comment_in && (*comment_in))
+		sprintf(comment, "\t\t# %s", comment_in);
+	else
+		comment[0] = 0;
+
+	if (op2 && (*op2))
+		sprintf(s, "\t%s\t%s, %s%s\n", insn, op1, op2, comment);
+	else if (op1 && (*op1))
+		sprintf(s, "\t%s\t%s%s%s\n", insn, op1,
+			comment[0] ? "\t" : "", comment);
+	else
+		sprintf(s, "\t%s\t%s%s\n", insn,
+			comment[0] ? "\t\t" : "", comment);
+	textbuf_push(&f->buf, s);
+}
+
+static void emit_unit_pre(const char *basename)
+{
+	printf("\t.file\t\"%s\"\n", basename);
+}
+
+static void emit_unit_post(void)
+{
+	textbuf_emit(&unit_post_text);
+	printf("\t.ident\t\"sparse silly x86 backend (built %s)\"\n", __DATE__);
+}
+
+/* conditionally switch sections */
+static void emit_section(const char *s)
+{
+	if (s == current_section)
+		return;
+	if (current_section && (!strcmp(s, current_section)))
+		return;
+
+	printf("\t%s\n", s);
+	current_section = s;
+}
+
+static void func_cleanup(struct function *f)
+{
+	struct storage *stor;
+
+	FOR_EACH_PTR(f->pseudo_list, stor) {
+		free(stor);
+	} END_FOR_EACH_PTR;
+
+	free_ptr_list(&f->pseudo_list);
+	free(f);
+}
+
+/* function prologue */
+static void emit_func_pre(struct symbol *sym)
+{
+	const char *name = show_ident(sym->ident);
+	struct function *f;
+	struct symbol *arg;
+	unsigned int i, argc = 0, alloc_len;
+	unsigned char *mem;
+	struct symbol_private *privbase;
+	struct storage *storage_base;
+	struct symbol *base_type = sym->ctype.base_type;
+
+	FOR_EACH_PTR(base_type->arguments, arg) {
+		argc++;
+	} END_FOR_EACH_PTR;
+
+	alloc_len =
+		sizeof(*f) +
+		(argc * sizeof(struct symbol *)) +
+		(argc * sizeof(struct symbol_private)) +
+		(argc * sizeof(struct storage));
+	mem = calloc(1, alloc_len);
+	if (!mem)
+		die("OOM on func info");
+
+	f		=  (struct function *) mem;
+	mem		+= sizeof(*f);
+	f->argv		=  (struct symbol **) mem;
+	mem		+= (argc * sizeof(struct symbol *));
+	privbase	=  (struct symbol_private *) mem;
+	mem		+= (argc * sizeof(struct symbol_private));
+	storage_base	=  (struct storage *) mem;
+
+	f->argc = argc;
+
+	i = 0;
+	FOR_EACH_PTR(base_type->arguments, arg) {
+		f->argv[i] = arg;
+		arg->aux = &privbase[i];
+		storage_base[i].type = STOR_ARG;
+		storage_base[i].idx = i;
+		privbase[i].addr = &storage_base[i];
+		i++;
+	} END_FOR_EACH_PTR;
+
+	assert(current_func == NULL);
+	current_func = f;
+
+	emit_section(".text");
+	if ((sym->ctype.modifiers & MOD_STATIC) == 0)
+		printf(".globl %s\n", name);
+	printf("\t.type\t%s, @function\n", name);
+	printf("%s:\n", name);
+}
+
+/* function epilogue */
+static void emit_func_post(struct symbol *sym, struct storage *val)
+{
+	const char *name = show_ident(sym->ident);
+	struct function *f = current_func;
+	int pseudo_nr = f->pseudo_nr;
+	char s[16];
+
+	sprintf(s, "$%d", pseudo_nr * 4);
+	printf("\tsubl\t%s, %%esp\n", s);
+	if (val)
+		insn("movl", stor_op_name(val), "%eax", stor_arg_warning(val));
+	insn("addl", s, "%esp", NULL);
+	insn("ret", NULL, NULL, NULL);
+
+	textbuf_emit(&f->buf);
+
+	printf("\t.size\t%s, .-%s\n", name, name);
+
+	func_cleanup(f);
+	current_func = NULL;
+}
+
+/* emit object (a.k.a. variable, a.k.a. data) prologue */
+static void emit_object_pre(const char *name, unsigned long modifiers,
+			    unsigned long alignment, unsigned int byte_size)
+{
+	if ((modifiers & MOD_STATIC) == 0)
+		printf(".globl %s\n", name);
+	emit_section(".data");
+	if (alignment)
+		printf("\t.align %lu\n", alignment);
+	printf("\t.type\t%s, @object\n", name);
+	printf("\t.size\t%s, %d\n", name, byte_size);
+	printf("%s:\n", name);
+}
+
+/* emit value (only) for an initializer scalar */
+static void emit_scalar(struct expression *expr, unsigned int bit_size)
+{
+	const char *type;
+	long long ll;
+
+	assert(expr->type == EXPR_VALUE);
+
+	if (expr->value == 0ULL) {
+		printf("\t.zero\t%d\n", bit_size / 8);
+		return;
+	}
+
+	ll = (long long) expr->value;
+
+	switch (bit_size) {
+	case 8:		type = "byte";	ll = (char) ll; break;
+	case 16:	type = "value";	ll = (short) ll; break;
+	case 32:	type = "long";	ll = (int) ll; break;
+	case 64:	type = "quad";	break;
+	default:	type = NULL;	break;
+	}
+
+	assert(type != NULL);
+
+	printf("\t.%s\t%Ld\n", type, ll);
+}
+
+static void emit_global_noinit(const char *name, unsigned long modifiers,
+			       unsigned long alignment, unsigned int byte_size)
+{
+	char s[64];
+
+	if (modifiers & MOD_STATIC) {
+		sprintf(s, "\t.local\t%s\n", name);
+		textbuf_push(&unit_post_text, s);
+	}
+	if (alignment)
+		sprintf(s, "\t.comm\t%s,%d,%lu\n", name, byte_size, alignment);
+	else
+		sprintf(s, "\t.comm\t%s,%d\n", name, byte_size);
+	textbuf_push(&unit_post_text, s);
+}
+
+static int ea_current, ea_last;
+
+static void emit_initializer(struct symbol *sym,
+			     struct expression *expr)
+{
+	int distance = ea_current - ea_last - 1;
+
+	if (distance > 0)
+		printf("\t.zero\t%d\n", (sym->bit_size / 8) * distance);
+
+	if (expr->type == EXPR_VALUE) {
+		struct symbol *base_type = sym->ctype.base_type;
+		assert(base_type != NULL);
+
+		emit_scalar(expr, sym->bit_size / base_type->array_size);
+		return;
+	}
+	if (expr->type != EXPR_INITIALIZER)
+		return;
+
+	assert(0); /* FIXME */
+}
+
+static int sort_array_cmp(const struct expression *a,
+			  const struct expression *b)
+{
+	int a_ofs = 0, b_ofs = 0;
+
+	if (a->type == EXPR_POS)
+		a_ofs = (int) a->init_offset;
+	if (b->type == EXPR_POS)
+		b_ofs = (int) b->init_offset;
+
+	return a_ofs - b_ofs;
+}
+
+/* move to front-end? */
+static void sort_array(struct expression *expr)
+{
+	struct expression *entry, **list;
+	unsigned int elem, sorted, i;
+
+	elem = 0;
+	FOR_EACH_PTR(expr->expr_list, entry) {
+		elem++;
+	} END_FOR_EACH_PTR;
+
+	if (!elem)
+		return;
+
+	list = malloc(sizeof(entry) * elem);
+	if (!list)
+		die("OOM in sort_array");
+
+	/* this code is no doubt evil and ignores EXPR_INDEX possibly
+	 * to its detriment and other nasty things.  improvements
+	 * welcome.
+	 */
+	i = 0;
+	sorted = 0;
+	FOR_EACH_PTR(expr->expr_list, entry) {
+		if ((entry->type == EXPR_POS) || (entry->type == EXPR_VALUE)) {
+			/* add entry to list[], in sorted order */
+			if (sorted == 0) {
+				list[0] = entry;
+				sorted = 1;
+			} else {
+				unsigned int i;
+
+				for (i = 0; i < sorted; i++)
+					if (sort_array_cmp(entry, list[i]) <= 0)
+						break;
+
+				/* If inserting into the middle of list[]
+				 * instead of appending, we memmove.
+				 * This is ugly, but thankfully
+				 * uncommon.  Input data with tons of
+				 * entries very rarely have explicit
+				 * offsets.  convert to qsort eventually...
+				 */
+				if (i != sorted)
+					memmove(&list[i + 1], &list[i],
+						(sorted - i) * sizeof(entry));
+				list[i] = entry;
+				sorted++;
+			}
+		}
+	} END_FOR_EACH_PTR;
+
+	i = 0;
+	FOR_EACH_PTR(expr->expr_list, entry) {
+		if ((entry->type == EXPR_POS) || (entry->type == EXPR_VALUE))
+			__list->list[__i] = list[i++];
+	} END_FOR_EACH_PTR;
+
+}
+
+static void emit_array(struct symbol *sym)
+{
+	struct symbol *base_type = sym->ctype.base_type;
+	struct expression *expr = sym->initializer;
+	struct expression *entry;
+
+	assert(base_type != NULL);
+
+	stor_sym_init(sym);
+
+	ea_last = -1;
+
+	emit_object_pre(show_ident(sym->ident), sym->ctype.modifiers,
+		        sym->ctype.alignment,
+			sym->bit_size / 8);
+
+	sort_array(expr);
+
+	FOR_EACH_PTR(expr->expr_list, entry) {
+		if (entry->type == EXPR_VALUE) {
+			ea_current = 0;
+			emit_initializer(sym, entry);
+			ea_last = ea_current;
+		} else if (entry->type == EXPR_POS) {
+			ea_current =
+			    entry->init_offset / (base_type->bit_size / 8);
+			emit_initializer(sym, entry->init_expr);
+			ea_last = ea_current;
+		}
+	} END_FOR_EACH_PTR;
+}
+
+static void emit_one_symbol(struct symbol *sym, void *dummy, int flags)
+{
+	x86_symbol(sym);
+}
+
+void emit_unit(const char *basename, struct symbol_list *list)
+{
+	emit_unit_pre(basename);
+	symbol_iterate(list, emit_one_symbol, NULL);
+	emit_unit_post();
+}
+
+static void emit_move(struct expression *dest_expr, struct storage *dest,
+		      struct storage *src, int bits)
+{
+	/* FIXME: Bitfield move! */
+
+	/* FIXME: pay attention to arg 'bits' */
+	insn("movl", stor_op_name(src), "%eax", stor_arg_warning(src));
+
+	/* FIXME: pay attention to arg 'bits' */
+	insn("movl", "%eax", stor_op_name(dest), stor_arg_warning(dest));
+}
+
+static void emit_store(struct expression *dest_expr, struct storage *dest,
+		       struct storage *src, int bits)
+{
+	/* FIXME: Bitfield store! */
+	printf("\tst.%d\t\tv%d,[v%d]\n", bits, src->pseudo, dest->pseudo);
+}
+
+static void emit_scalar_noinit(struct symbol *sym)
+{
+	emit_global_noinit(show_ident(sym->ident),
+			   sym->ctype.modifiers, sym->ctype.alignment,
+			   sym->bit_size / 8);
+	stor_sym_init(sym);
+}
+
+static void emit_array_noinit(struct symbol *sym)
+{
+	emit_global_noinit(show_ident(sym->ident),
+			   sym->ctype.modifiers, sym->ctype.alignment,
+			   sym->array_size * (sym->bit_size / 8));
+	stor_sym_init(sym);
+}
+
+static struct storage *emit_compare(struct expression *expr)
+{
+	struct storage *left = x86_expression(expr->left);
+	struct storage *right = x86_expression(expr->right);
+	struct storage *new;
+	const char *opname = NULL;
+	static const char *name[] = {
+		['<'] = "cmovl",
+		['>'] = "cmovg",
+	};
+	unsigned int op = expr->op;
+
+	if (op < sizeof(name)/sizeof(*name)) {
+		opname = name[op];
+		assert(opname != NULL);
+	} else {
+		const char *tmp = show_special(op);
+		if (!strcmp(tmp, "<="))
+			opname = "cmovle";
+		else if (!strcmp(tmp, ">="))
+			opname = "cmovge";
+		else if (!strcmp(tmp, "=="))
+			opname = "cmove";
+		else if (!strcmp(tmp, "!="))
+			opname = "cmovne";
+		else {
+			assert(0);
+		}
+	}
+
+	/* init ECX to 1 */
+	insn("movl", "$1", "%ecx", "EXPR_COMPARE");
+
+	/* init EDX to 0 */
+	insn("xorl", "%edx", "%edx", NULL);
+
+	/* FIXME: don't hardcode operand size */
+	/* move op1 into EAX */
+	insn("movl", stor_op_name(left), "%eax", NULL);
+
+	/* perform comparison, EAX (op1) and op2 */
+	insn("cmpl", "%eax", stor_op_name(right), NULL);
+
+	/* store result of operation, 0 or 1, in EDX using CMOV */
+	/* FIXME: does this need an operand size suffix? */
+	insn(opname, "%ecx", "%edx", NULL);
+
+	/* finally, store the result (EDX) in a new pseudo / stack slot */
+	new = new_pseudo();
+	insn("movl", "%edx", stor_op_name(new), "end EXPR_COMPARE");
+
+	return new;
+}
+
+/*
+ * TODO: create a new type STOR_VALUE.  This will allow us to store
+ * the constant internally, and avoid assigning stack slots to them.
+ */
+static struct storage *emit_value(struct expression *expr)
+{
+	struct storage *new = new_pseudo();
+	char s[32];
+
+	sprintf(s, "$%Ld", (long long) expr->value);
+	insn("movl", s, pretty_offset(pseudo_offset(new)), NULL);
+
+	return new;
+}
+
+static struct storage *emit_binop(struct expression *expr)
+{
+	struct storage *left = x86_expression(expr->left);
+	struct storage *right = x86_expression(expr->right);
+	struct storage *new;
+	const char *opname;
+	static const char *name[] = {
+		['+'] = "addl", ['-'] = "subl",
+		['*'] = "mull", ['/'] = "divl",
+		['%'] = "modl", ['&'] = "andl",
+		['|'] = "orl", ['^'] = "xorl"
+	};
+	unsigned int op = expr->op;
+
+	/*
+	 * FIXME FIXME this routine is so wrong it's not even funny.
+	 * On x86 both mod/div are handled with the same instruction.
+	 * We don't pay attention to signed/unsigned issues,
+	 * and like elsewhere we hardcode the operand size at 32 bits.
+	 */
+
+	opname = show_special(op);
+	if (op < sizeof(name)/sizeof(*name)) {
+		opname = name[op];
+		assert(opname != NULL);
+	} else
+		assert(0); /* FIXME: no operations other than name[], ATM */
+
+	/* load op2 into EAX */
+	insn("movl", stor_op_name(right), "%eax", "EXPR_BINOP/COMMA/LOGICAL");
+
+	/* perform binop */
+	insn(opname, stor_op_name(left), "%eax", NULL);
+
+	/* store result (EAX) in new pseudo / stack slot */
+	new = new_pseudo();
+	insn("movl", "%eax", stor_op_name(new), "end EXPR_BINOP");
+
+	return new;
+}
+
+static void emit_if_conditional(struct statement *stmt)
+{
+	struct function *f = current_func;
+	struct storage *val;
+	int target;
+	struct expression *cond = stmt->if_conditional;
+	char s[16];
+
+/* This is only valid if nobody can jump into the "dead" statement */
+#if 0
+	if (cond->type == EXPR_VALUE) {
+		struct statement *s = stmt->if_true;
+		if (!cond->value)
+			s = stmt->if_false;
+		x86_statement(s);
+		break;
+	}
+#endif
+	val = x86_expression(cond);
+
+	/* load 'if' test result into EAX */
+	insn("movl", stor_op_name(val), "%eax",
+	     stor_arg_warning(val) ? stor_arg_warning(val) :
+	     "begin if conditional");
+
+	/* clear ECX */
+	insn("xorl", "%ecx", "%ecx", NULL);
+
+	/* compare 'if' test result */
+	insn("cmpl", "%eax", "%ecx", NULL);
+
+	/* create end-of-if label / if-failed labelto jump to,
+	 * and jump to it if the expression returned zero.
+	 */
+	target = new_label();
+	sprintf(s, ".L%d", target);
+	insn("je", s, NULL, NULL);
+
+	x86_statement(stmt->if_true);
+	if (stmt->if_false) {
+		int last = new_label();
+
+		/* finished generating code for if-true statement.
+		 * add a jump-to-end jump to avoid falling through
+		 * to the if-false statement code.
+		 */
+		sprintf(s, ".L%d", last);
+		insn("jmp", s, NULL, NULL);
+
+		/* if we have both if-true and if-false statements,
+		 * the failed-conditional case will fall through to here
+		 */
+		sprintf(s, ".L%d:\n", target);
+		textbuf_push(&f->buf, s);
+
+		target = last;
+		x86_statement(stmt->if_false);
+	}
+
+	sprintf(s, ".L%d:\t\t\t\t\t# end if\n", target);
+	textbuf_push(&f->buf, s);
+}
+
+static struct storage *emit_inc_dec(struct expression *expr, int postop)
+{
+	struct storage *addr = x86_address_gen(expr->unop);
+	struct storage *retval;
+	const char *opname = expr->op == SPECIAL_INCREMENT ? "incl" : "decl";
+#if 0
+	/* FIXME: don't hardware operand size */
+	int bits = expr->ctype->bit_size;
+#endif
+
+	if (postop) {
+		struct storage *new = new_pseudo();
+
+		emit_move(NULL, new, addr, 1234 /* intentionally bogus */);
+
+		retval = new;
+	} else
+		retval = addr;
+
+	insn(opname, stor_op_name(addr), NULL, NULL);
+
+	return retval;
+}
+
+static struct storage *emit_postop(struct expression *expr)
+{
+	return emit_inc_dec(expr, 1);
+}
+
+static void x86_struct_member(struct symbol *sym, void *data, int flags)
+{
+	if (flags & ITERATE_FIRST)
+		printf(" {\n\t");
+	printf("%s:%d:%ld at offset %ld", show_ident(sym->ident), sym->bit_size, sym->ctype.alignment, sym->offset);
+	if (sym->fieldwidth)
+		printf("[%d..%d]", sym->bit_offset, sym->bit_offset+sym->fieldwidth-1);
+	if (flags & ITERATE_LAST)
+		printf("\n} ");
+	else
+		printf(", ");
+}
+
+static void x86_symbol(struct symbol *sym)
+{
+	struct symbol *type;
+
+	if (!sym)
+		return;
+
+	type = sym->ctype.base_type;
+	if (!type)
+		return;
+
+	/*
+	 * Show actual implementation information
+	 */
+	switch (type->type) {
+
+	case SYM_ARRAY:
+		if (sym->initializer)
+			emit_array(sym);
+		else
+			emit_array_noinit(sym);
+		break;
+
+	case SYM_BASETYPE:
+		if (sym->initializer) {
+			emit_object_pre(show_ident(sym->ident),
+					sym->ctype.modifiers,
+				        sym->ctype.alignment,
+					sym->bit_size / 8);
+			emit_scalar(sym->initializer, sym->bit_size);
+			stor_sym_init(sym);
+		} else
+			emit_scalar_noinit(sym);
+		break;
+
+	case SYM_STRUCT:
+		symbol_iterate(type->symbol_list, x86_struct_member, NULL);
+		break;
+
+	case SYM_UNION:
+		symbol_iterate(type->symbol_list, x86_struct_member, NULL);
+		break;
+
+	case SYM_FN: {
+		struct statement *stmt = type->stmt;
+		if (stmt) {
+			struct storage *val;
+
+			emit_func_pre(sym);
+			val = x86_statement(stmt);
+			emit_func_post(sym, val);
+		}
+		break;
+	}
+
+	default:
+		break;
+	}
+
+	if (sym->initializer && (type->type != SYM_BASETYPE) &&
+	    (type->type != SYM_ARRAY)) {
+		printf(" = \n");
+		x86_expression(sym->initializer);
+	}
+}
+
+static void x86_symbol_init(struct symbol *sym);
+
+static void x86_switch_statement(struct statement *stmt)
+{
+	struct storage *val = x86_expression(stmt->switch_expression);
+	struct symbol *sym;
+	printf("\tswitch v%d\n", val->pseudo);
+
+	/*
+	 * Debugging only: Check that the case list is correct
+	 * by printing it out.
+	 *
+	 * This is where a _real_ back-end would go through the
+	 * cases to decide whether to use a lookup table or a
+	 * series of comparisons etc
+	 */
+	printf("# case table:\n");
+	FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
+		struct statement *case_stmt = sym->stmt;
+		struct expression *expr = case_stmt->case_expression;
+		struct expression *to = case_stmt->case_to;
+
+		if (!expr) {
+			printf("    default");
+		} else {
+			if (expr->type == EXPR_VALUE) {
+				printf("    case %lld", expr->value);
+				if (to) {
+					if (to->type == EXPR_VALUE) {
+						printf(" .. %lld", to->value);
+					} else {
+						printf(" .. what?");
+					}
+				}
+			} else
+				printf("    what?");
+		}
+		printf(": .L%p\n", sym);
+	} END_FOR_EACH_PTR;
+	printf("# end case table\n");
+
+	x86_statement(stmt->switch_statement);
+
+	if (stmt->switch_break->used)
+		printf(".L%p:\n", stmt->switch_break);
+}
+
+static void x86_symbol_decl(struct symbol_list *syms)
+{
+	struct symbol *sym;
+	FOR_EACH_PTR(syms, sym) {
+		x86_symbol_init(sym);
+	} END_FOR_EACH_PTR;
+}
+
+static void x86_return_stmt(struct statement *stmt);
+
+/*
+ * Print out a statement
+ */
+static struct storage *x86_statement(struct statement *stmt)
+{
+	if (!stmt)
+		return 0;
+	switch (stmt->type) {
+	case STMT_RETURN:
+		x86_return_stmt(stmt);
+		return NULL;
+	case STMT_COMPOUND: {
+		struct statement *s;
+		struct storage *last = NULL;
+
+		x86_symbol_decl(stmt->syms);
+		FOR_EACH_PTR(stmt->stmts, s) {
+			last = x86_statement(s);
+		} END_FOR_EACH_PTR;
+		if (stmt->ret) {
+			struct storage *addr;
+			int bits;
+			printf(".L%p:\n", stmt->ret);
+			addr = x86_symbol_expr(stmt->ret);
+			bits = stmt->ret->bit_size;
+			last = new_pseudo();
+			printf("\tld.%d\t\tv%d,[v%d]\n", bits, last->pseudo, addr->pseudo);
+		}
+		return last;
+	}
+
+	case STMT_EXPRESSION:
+		return x86_expression(stmt->expression);
+	case STMT_IF:
+		emit_if_conditional(stmt);
+		return NULL;
+	case STMT_SWITCH:
+		x86_switch_statement(stmt);
+		break;
+
+	case STMT_CASE:
+		printf(".L%p:\n", stmt->case_label);
+		x86_statement(stmt->case_statement);
+		break;
+
+	case STMT_ITERATOR: {
+		struct statement  *pre_statement = stmt->iterator_pre_statement;
+		struct expression *pre_condition = stmt->iterator_pre_condition;
+		struct statement  *statement = stmt->iterator_statement;
+		struct statement  *post_statement = stmt->iterator_post_statement;
+		struct expression *post_condition = stmt->iterator_post_condition;
+		int loop_top = 0, loop_bottom = 0;
+		struct storage *val;
+
+		x86_symbol_decl(stmt->iterator_syms);
+		x86_statement(pre_statement);
+		if (pre_condition) {
+			if (pre_condition->type == EXPR_VALUE) {
+				if (!pre_condition->value) {
+					loop_bottom = new_label();
+					printf("\tjmp\t\t.L%d\n", loop_bottom);
+				}
+			} else {
+				loop_bottom = new_label();
+				val = x86_expression(pre_condition);
+				printf("\tje\t\tv%d, .L%d\n", val->pseudo, loop_bottom);
+			}
+		}
+		if (!post_condition || post_condition->type != EXPR_VALUE || post_condition->value) {
+			loop_top = new_label();
+			printf(".L%d:\n", loop_top);
+		}
+		x86_statement(statement);
+		if (stmt->iterator_continue->used)
+			printf(".L%p:\n", stmt->iterator_continue);
+		x86_statement(post_statement);
+		if (!post_condition) {
+			printf("\tjmp\t\t.L%d\n", loop_top);
+		} else if (post_condition->type == EXPR_VALUE) {
+			if (post_condition->value)
+				printf("\tjmp\t\t.L%d\n", loop_top);
+		} else {
+			val = x86_expression(post_condition);
+			printf("\tjne\t\tv%d, .L%d\n", val->pseudo, loop_top);
+		}
+		if (stmt->iterator_break->used)
+			printf(".L%p:\n", stmt->iterator_break);
+		if (loop_bottom)
+			printf(".L%d:\n", loop_bottom);
+		break;
+	}
+	case STMT_NONE:
+		break;
+
+	case STMT_LABEL:
+		printf(".L%p:\n", stmt->label_identifier);
+		x86_statement(stmt->label_statement);
+		break;
+
+	case STMT_GOTO:
+		if (stmt->goto_expression) {
+			struct storage *val = x86_expression(stmt->goto_expression);
+			printf("\tgoto *v%d\n", val->pseudo);
+		} else {
+			printf("\tgoto .L%p\n", stmt->goto_label);
+		}
+		break;
+	case STMT_ASM:
+		printf("\tasm( .... )\n");
+		break;
+
+	}
+	return 0;
+}
+
+static struct storage *x86_call_expression(struct expression *expr)
+{
+	struct symbol *direct;
+	struct expression *arg, *fn;
+	struct storage *retval, *fncall;
+	int framesize;
+	char s[64];
+
+	if (!expr->ctype) {
+		warn(expr->pos, "\tcall with no type!");
+		return NULL;
+	}
+
+	framesize = 0;
+	FOR_EACH_PTR_REVERSE(expr->args, arg) {
+		struct storage *new = x86_expression(arg);
+		int size = arg->ctype->bit_size;
+
+		/* FIXME: pay attention to 'size' */
+		insn("pushl", stor_op_name(new), NULL,
+		     stor_arg_warning(new) ? stor_arg_warning(new) :
+		     !framesize ? "begin function call" : NULL);
+
+		framesize += size >> 3;
+	} END_FOR_EACH_PTR_REVERSE;
+
+	fn = expr->fn;
+
+	/* Remove dereference, if any */
+	direct = NULL;
+	if (fn->type == EXPR_PREOP) {
+		if (fn->unop->type == EXPR_SYMBOL) {
+			struct symbol *sym = fn->unop->symbol;
+			if (sym->ctype.base_type->type == SYM_FN)
+				direct = sym;
+		}
+	}
+	if (direct)
+		insn("call", show_ident(direct->ident), NULL, NULL);
+	else {
+		fncall = x86_expression(fn);
+		printf("\tcall\t*v%d\n", fncall->pseudo);
+	}
+
+	/* FIXME: pay attention to BITS_IN_POINTER */
+	if (framesize) {
+		sprintf(s, "$%d", framesize);
+		insn("addl", s, "%esp", "end function call");
+	}
+
+	retval = new_pseudo();
+	printf("\tmov.%d\t\tv%d,retval\n", expr->ctype->bit_size, retval->pseudo);
+	return retval;
+}
+
+static struct storage *x86_regular_preop(struct expression *expr)
+{
+	struct storage *target = x86_expression(expr->unop);
+	struct storage *new = new_pseudo();
+	static const char *name[] = {
+		['!'] = "nonzero", ['-'] = "neg",
+		['~'] = "not",
+	};
+	unsigned int op = expr->op;
+	const char *opname;
+
+	opname = show_special(op);
+	if (op < sizeof(name)/sizeof(*name))
+		opname = name[op];
+	printf("\t%s.%d\t\tv%d,v%d\n", opname, expr->ctype->bit_size, new->pseudo, target->pseudo);
+	return new;
+}
+
+/*
+ * FIXME! Not all accesses are memory loads. We should
+ * check what kind of symbol is behind the dereference.
+ */
+static struct storage *x86_address_gen(struct expression *expr)
+{
+	if (expr->type == EXPR_PREOP)
+		return x86_expression(expr->unop);
+	return x86_expression(expr->address);
+}
+
+static struct storage *x86_assignment(struct expression *expr)
+{
+	struct expression *target = expr->left;
+	struct storage *val, *addr;
+	int bits;
+
+	if (!expr->ctype)
+		return NULL;
+
+	bits = expr->ctype->bit_size;
+	val = x86_expression(expr->right);
+	addr = x86_address_gen(target);
+	emit_move(target, addr, val, bits);
+	return val;
+}
+
+static void x86_return_stmt(struct statement *stmt)
+{
+	struct expression *expr = stmt->ret_value;
+	struct symbol *target = stmt->ret_target;
+
+	if (expr && expr->ctype) {
+		struct storage *val = x86_expression(expr);
+		int bits = expr->ctype->bit_size;
+		struct storage *addr = x86_symbol_expr(target);
+		emit_store(NULL, addr, val, bits);
+	}
+	printf("\tgoto .L%p\n", target);
+}
+
+static int x86_initialization(struct symbol *sym, struct expression *expr)
+{
+	struct storage *val, *addr;
+	int bits;
+
+	if (!expr->ctype)
+		return 0;
+
+	bits = expr->ctype->bit_size;
+	val = x86_expression(expr);
+	addr = x86_symbol_expr(sym);
+	// FIXME! The "target" expression is for bitfield store information.
+	// Leave it NULL, which works fine.
+	emit_store(NULL, addr, val, bits);
+	return 0;
+}
+
+static struct storage *x86_access(struct expression *expr)
+{
+	return x86_address_gen(expr);
+}
+
+static struct storage *x86_preop(struct expression *expr)
+{
+	/*
+	 * '*' is an lvalue access, and is fundamentally different
+	 * from an arithmetic operation. Maybe it should have an
+	 * expression type of its own..
+	 */
+	if (expr->op == '*')
+		return x86_access(expr);
+	if (expr->op == SPECIAL_INCREMENT || expr->op == SPECIAL_DECREMENT)
+		return emit_inc_dec(expr, 0);
+	return x86_regular_preop(expr);
+}
+
+static struct storage *x86_symbol_expr(struct symbol *sym)
+{
+	struct storage *new = new_pseudo();
+
+	if (sym->ctype.modifiers & (MOD_TOPLEVEL | MOD_EXTERN | MOD_STATIC)) {
+		printf("\tmovi.%d\t\tv%d,$%s\n", BITS_IN_POINTER, new->pseudo, show_ident(sym->ident));
+		return new;
+	}
+	if (sym->ctype.modifiers & MOD_ADDRESSABLE) {
+		printf("\taddi.%d\t\tv%d,vFP,$%lld\n", BITS_IN_POINTER, new->pseudo, sym->value);
+		return new;
+	}
+	printf("\taddi.%d\t\tv%d,vFP,$offsetof(%s:%p)\n", BITS_IN_POINTER, new->pseudo, show_ident(sym->ident), sym);
+	return new;
+}
+
+static void x86_symbol_init(struct symbol *sym)
+{
+	struct symbol_private *priv = sym->aux;
+	struct expression *expr = sym->initializer;
+	struct storage *new;
+
+	if (expr)
+		new = x86_expression(expr);
+	else
+		new = new_pseudo();
+
+	if (!priv) {
+		priv = calloc(1, sizeof(*priv));
+		sym->aux = priv;
+		/* FIXME: leak! we don't free... */
+		/* (well, we don't free symbols either) */
+	}
+
+	priv->addr = new;
+}
+
+static int type_is_signed(struct symbol *sym)
+{
+	if (sym->type == SYM_NODE)
+		sym = sym->ctype.base_type;
+	if (sym->type == SYM_PTR)
+		return 0;
+	return !(sym->ctype.modifiers & MOD_UNSIGNED);
+}
+
+static struct storage *x86_cast_expr(struct expression *expr)
+{
+	struct symbol *old_type, *new_type;
+	struct storage *op = x86_expression(expr->cast_expression);
+	int oldbits, newbits;
+	int is_signed;
+	struct storage *new;
+
+	old_type = expr->cast_expression->ctype;
+	new_type = expr->cast_type;
+
+	oldbits = old_type->bit_size;
+	newbits = new_type->bit_size;
+	if (oldbits >= newbits)
+		return op;
+	new = new_pseudo();
+	is_signed = type_is_signed(old_type);
+	if (is_signed) {
+		printf("\tsext%d.%d\tv%d,v%d\n", oldbits, newbits, new->pseudo, op->pseudo);
+	} else {
+		printf("\tandl.%d\t\tv%d,v%d,$%lu\n", newbits, new->pseudo, op->pseudo, (1UL << oldbits)-1);
+	}
+	return new;
+}
+
+static struct storage *show_string_expr(struct expression *expr)
+{
+	struct storage *new = new_pseudo();
+
+	printf("\tmovi.%d\t\tv%d,&%s\n", BITS_IN_POINTER, new->pseudo,
+		show_string(expr->string));
+	return new;
+}
+
+static struct storage *x86_bitfield_expr(struct expression *expr)
+{
+	return x86_access(expr);
+}
+
+static struct storage *x86_label_expr(struct expression *expr)
+{
+	struct storage *new = new_pseudo();
+	printf("\tmovi.%d\t\tv%d,.L%p\n",BITS_IN_POINTER, new->pseudo, expr->label_symbol);
+	return new;
+}
+
+static struct storage *x86_conditional_expr(struct expression *expr)
+{
+	struct storage *cond = x86_expression(expr->conditional);
+	struct storage *true = x86_expression(expr->cond_true);
+	struct storage *false = x86_expression(expr->cond_false);
+	struct storage *new = new_pseudo();
+
+	if (!true)
+		true = cond;
+	printf("[v%d]\tcmov.%d\t\tv%d,v%d,v%d\n",
+		cond->pseudo, expr->ctype->bit_size, new->pseudo,
+		true->pseudo, false->pseudo);
+	return new;
+}
+
+static struct storage *x86_statement_expr(struct expression *expr)
+{
+	return x86_statement(expr->statement);
+}
+
+static int x86_position_expr(struct expression *expr, struct symbol *base)
+{
+	struct storage *new = x86_expression(expr->init_expr);
+	struct symbol *ctype = expr->init_sym;
+
+	printf("\tinsert v%d at [%d:%d] of %s\n", new->pseudo,
+		expr->init_offset, ctype->bit_offset,
+		show_ident(base->ident));
+	return 0;
+}
+
+static void x86_initializer_expr(struct expression *expr, struct symbol *ctype)
+{
+	struct expression *entry;
+
+	FOR_EACH_PTR(expr->expr_list, entry) {
+		// Nested initializers have their positions already
+		// recursively calculated - just output them too
+		if (entry->type == EXPR_INITIALIZER) {
+			x86_initializer_expr(entry, ctype);
+			continue;
+		}
+
+		// Ignore initializer indexes and identifiers - the
+		// evaluator has taken them into account
+		if (entry->type == EXPR_IDENTIFIER || entry->type == EXPR_INDEX)
+			continue;
+		if (entry->type == EXPR_POS) {
+			x86_position_expr(entry, ctype);
+			continue;
+		}
+		x86_initialization(ctype, entry);
+	} END_FOR_EACH_PTR;
+}
+
+static struct storage *x86_symbol_expr_init(struct symbol *sym)
+{
+	struct expression *expr = sym->initializer;
+	struct symbol_private *priv = sym->aux;
+
+	if (expr)
+		x86_initializer_expr(expr, expr->ctype);
+
+	if (priv == NULL) {
+		fprintf(stderr, "WARNING! priv == NULL\n");
+		priv = calloc(1, sizeof(*priv));
+		sym->aux = priv;
+		priv->addr = new_pseudo(); /* this is wrong! */
+	}
+
+	return priv->addr;
+}
+
+/*
+ * Print out an expression. Return the pseudo that contains the
+ * variable.
+ */
+static struct storage *x86_expression(struct expression *expr)
+{
+	if (!expr)
+		return 0;
+
+	if (!expr->ctype) {
+		struct position *pos = &expr->pos;
+		printf("\tno type at %s:%d:%d\n",
+			input_streams[pos->stream].name,
+			pos->line, pos->pos);
+		return 0;
+	}
+
+	switch (expr->type) {
+	case EXPR_CALL:
+		return x86_call_expression(expr);
+
+	case EXPR_ASSIGNMENT:
+		return x86_assignment(expr);
+
+	case EXPR_COMPARE:
+		return emit_compare(expr);
+	case EXPR_BINOP:
+	case EXPR_COMMA:
+	case EXPR_LOGICAL:
+		return emit_binop(expr);
+	case EXPR_PREOP:
+		return x86_preop(expr);
+	case EXPR_POSTOP:
+		return emit_postop(expr);
+	case EXPR_SYMBOL:
+		return x86_symbol_expr_init(expr->symbol);
+	case EXPR_DEREF:
+	case EXPR_SIZEOF:
+		warn(expr->pos, "invalid expression after evaluation");
+		return 0;
+	case EXPR_CAST:
+		return x86_cast_expr(expr);
+	case EXPR_VALUE:
+		return emit_value(expr);
+	case EXPR_STRING:
+		return show_string_expr(expr);
+	case EXPR_BITFIELD:
+		return x86_bitfield_expr(expr);
+	case EXPR_INITIALIZER:
+		x86_initializer_expr(expr, expr->ctype);
+		return NULL;
+	case EXPR_CONDITIONAL:
+		return x86_conditional_expr(expr);
+	case EXPR_STATEMENT:
+		return x86_statement_expr(expr);
+	case EXPR_LABEL:
+		return x86_label_expr(expr);
+
+	// None of these should exist as direct expressions: they are only
+	// valid as sub-expressions of initializers.
+	case EXPR_POS:
+		warn(expr->pos, "unable to show plain initializer position expression");
+		return 0;
+	case EXPR_IDENTIFIER:
+		warn(expr->pos, "unable to show identifier expression");
+		return 0;
+	case EXPR_INDEX:
+		warn(expr->pos, "unable to show index expression");
+		return 0;
+	}
+	return 0;
+}
diff -Nru a/compile.c b/compile.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/compile.c	Sun Sep  7 14:58:08 2003
@@ -0,0 +1,134 @@
+/*
+ * Example trivial client program that uses the sparse library
+ * and x86 backend.
+ *
+ * Copyright (C) 2003 Transmeta Corp.
+ *               2003 Linus Torvalds
+ * Copyright 2003 Jeff Garzik
+ *
+ *  Licensed under the Open Software License version 1.1
+ *
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "lib.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+
+extern void emit_unit(const char *basename, struct symbol_list *list);
+
+static void do_switch(char *arg)
+{
+	switch (*arg) {
+	case 'D': {
+		const char *name = arg+1;
+		const char *value = "";
+		for (;;) {
+			char c;
+			c = *++arg;
+			if (!c)
+				break;
+			if (isspace(c) || c == '=') {
+				*arg = '\0';
+				value = arg+1;
+				break;
+			}
+		}
+		add_pre_buffer("#define %s %s\n", name, value);
+		return;
+	}
+
+	case 'I':
+		add_pre_buffer("#add_include \"%s/\"\n", arg+1);
+		return;
+	default:
+		fprintf(stderr, "unknown switch '%s'\n", arg);
+	}
+}
+
+static void clean_up_symbol(struct symbol *sym, void *_parent, int flags)
+{
+	evaluate_symbol(sym);
+	expand_symbol(sym);
+}
+
+int main(int argc, char **argv)
+{
+	int i, fd;
+	char *basename, *filename = NULL;
+	struct token *token;
+
+	// Initialize symbol stream first, so that we can add defines etc
+	init_symbols();
+
+	// Stupid defines to make various headers happy
+	add_pre_buffer("#define __GNUC__ 2\n");
+	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
+
+	for (i = 1; i < argc; i++) {
+		char *arg = argv[i];
+		if (arg[0] == '-') {
+			do_switch(arg+1);
+			continue;
+		}
+		filename = arg;
+	}
+
+
+	basename = strrchr(filename, '/');
+	if (!basename)
+		basename = filename;
+	else if ((basename == filename) && (basename[1] == 0)) {
+		fprintf(stderr, "um\n");
+		exit(1);
+	} else {
+		basename++;
+		if (*basename == 0) {
+			fprintf(stderr, "um\n");
+			exit(1);
+		}
+	}
+
+	fd = open(filename, O_RDONLY);
+	if (fd < 0)
+		die("No such file: %s", argv[1]);
+
+	// Tokenize the input stream
+	token = tokenize(filename, fd, NULL);
+	close(fd);
+
+	// Prepend the initial built-in stream
+	token = tokenize_buffer(pre_buffer, pre_buffer_size, token);
+
+	// Pre-process the stream
+	token = preprocess(token);
+
+	// Parse the resulting C code
+	translation_unit(token, &used_list);
+
+	// Do type evaluation and simplification
+	symbol_iterate(used_list, clean_up_symbol, NULL);
+
+	// Show the end result.
+	emit_unit(basename, used_list);
+
+#if 0
+	// And show the allocation statistics
+	show_ident_alloc();
+	show_token_alloc();
+	show_symbol_alloc();
+	show_expression_alloc();
+	show_statement_alloc();
+	show_string_alloc();
+	show_bytes_alloc();
+#endif
+	return 0;
+}
diff -Nru a/lib.c b/lib.c
--- a/lib.c	Sun Sep  7 14:58:08 2003
+++ b/lib.c	Sun Sep  7 14:58:08 2003
@@ -235,6 +235,23 @@
 	list->nr = nr;
 }
 
+void free_ptr_list(struct ptr_list **listp)
+{
+	struct ptr_list *tmp, *list = *listp;
+
+	if (!list)
+		return;
+
+	list->prev->next = NULL;
+	while (list) {
+		tmp = list;
+		list = list->next;
+		free(tmp);
+	}
+
+	*listp = NULL;
+}
+
 static void do_warn(const char *type, struct position pos, const char * fmt, va_list args)
 {
 	static char buffer[512];
diff -Nru a/lib.h b/lib.h
--- a/lib.h	Sun Sep  7 14:58:08 2003
+++ b/lib.h	Sun Sep  7 14:58:08 2003
@@ -62,6 +62,7 @@
 #define ITERATE_LAST 2
 void iterate(struct ptr_list *,void (*callback)(void *, void *, int), void*);
 extern void add_ptr_list(struct ptr_list **, void *);
+extern void free_ptr_list(struct ptr_list **);
 extern int ptr_list_size(struct ptr_list *);
 extern char **handle_switch(char *arg, char **next);
 extern void add_pre_buffer(const char *fmt, ...);

--------------090600030807010000010601--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 19:09:11 +0000
Message-ID: <3F5B8257.4030202 () pobox ! com>
--------------------
Post script:  I grew up on risc, and sparc/mips asm.  This is my 
learning-x86-asm project.  Please be gentle :)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 20:20:19 +0000
Message-ID: <Pine.LNX.4.44.0309071314070.21192-100000 () home ! osdl ! org>
--------------------

On Sun, 7 Sep 2003, Jeff Garzik wrote:
> 
> Comments welcome.  It cannot be considered anywhere near complete, but 
> it acts like it generates x86 asm for a bunch of small test cases anyway :)

Heh.

It doesn't compile even a simple

	#include <stdio.h>

	int main()
	{
		printf("Hello world!\n");
	}

but I committed it anyway.

Mind trying to make hello world compile?

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 20:34:10 +0000
Message-ID: <3F5B9642.4030408 () pobox ! com>
--------------------
Linus Torvalds wrote:
> On Sun, 7 Sep 2003, Jeff Garzik wrote:
> 
>>Comments welcome.  It cannot be considered anywhere near complete, but 
>>it acts like it generates x86 asm for a bunch of small test cases anyway :)
> 
> 
> Heh.
> 
> It doesn't compile even a simple
> 
> 	#include <stdio.h>
> 
> 	int main()
> 	{
> 		printf("Hello world!\n");
> 	}
> 
> but I committed it anyway.
> 
> Mind trying to make hello world compile?


What do strings look like?  Inside a SYM_NODE symbol somewhere, perhaps?

When I trace through it in the debugger, that's the only symbol that's 
passed to me as printf's argument.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 20:39:31 +0000
Message-ID: <Pine.LNX.4.44.0309071337320.21192-100000 () home ! osdl ! org>
--------------------

On Sun, 7 Sep 2003, Jeff Garzik wrote:
> 
> What do strings look like?  Inside a SYM_NODE symbol somewhere, perhaps?

Yes, they should look like magic non-local nodes (ie they _should_ be 100% 
equivalent to a unnamed static array).

That was important to get things like "sizeof()" semantics right.

But yeah, it's one of those "I never tested it" things, so..

		Linus



================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 20:43:17 +0000
Message-ID: <Pine.LNX.4.44.0309071339370.21192-100000 () home ! osdl ! org>
--------------------

On Sun, 7 Sep 2003, Linus Torvalds wrote:
>
> But yeah, it's one of those "I never tested it" things, so..

I take that back. I tested that sizeof() works, so some of it is tested, 
but it's entirely possible that the string itself is gone.

But even a non-stringy "main()" results in strange things, ie

	int main(char ** argv, int argc)
	{
	        return 6;
	}

results in

	main:
	        addi.32         v2,vFP,$offsetof(return:0x400cf080)
	        st.32           v1,[v2]
	        goto .L0x400cf080
	.L0x400cf080:

which seems to say that the magic "return" variable handling is screwed up 
some way.

Quite possibly in the front-end, of course.

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 20:47:10 +0000
Message-ID: <3F5B994E.6040606 () pobox ! com>
--------------------
Linus Torvalds wrote:
> On Sun, 7 Sep 2003, Jeff Garzik wrote:
> 
>>What do strings look like?  Inside a SYM_NODE symbol somewhere, perhaps?
> 
> 
> Yes, they should look like magic non-local nodes (ie they _should_ be 100% 
> equivalent to a unnamed static array).
> 
> That was important to get things like "sizeof()" semantics right.
> 
> But yeah, it's one of those "I never tested it" things, so..


struct symbol is still a bit impenetrable to me..

What fields do I test, to know that the symbol is a constant string?

And where is the actual value stored?  sym->initializer?

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 20:48:22 +0000
Message-ID: <3F5B9996.90305 () pobox ! com>
--------------------
Linus Torvalds wrote:
> On Sun, 7 Sep 2003, Linus Torvalds wrote:
> 
>>But yeah, it's one of those "I never tested it" things, so..
> 
> 
> I take that back. I tested that sizeof() works, so some of it is tested, 
> but it's entirely possible that the string itself is gone.

heh, ok :)


> But even a non-stringy "main()" results in strange things, ie
> 
> 	int main(char ** argv, int argc)
> 	{
> 	        return 6;
> 	}
> 
> results in
> 
> 	main:
> 	        addi.32         v2,vFP,$offsetof(return:0x400cf080)
> 	        st.32           v1,[v2]
> 	        goto .L0x400cf080
> 	.L0x400cf080:
> 
> which seems to say that the magic "return" variable handling is screwed up 
> some way.

Yeah, return values are on the to-do list.  This should be pretty easy 
to fix up, though...

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [patch] "silly sparse x86 backend"
Date: Sun, 07 Sep 2003 20:59:44 +0000
Message-ID: <Pine.LNX.4.44.0309071351410.21192-100000 () home ! osdl ! org>
--------------------

On Sun, 7 Sep 2003, Jeff Garzik wrote:
> 
> struct symbol is still a bit impenetrable to me..

No kidding. That's the most complex structure of all. It can be both a
"node" (type==SYM_NODE), which implies that it has some kind of "real
life" (ie it's a variable of some kind, although it might be a generated
one), or it can be a "pure type" (any other case).

> What fields do I test, to know that the symbol is a constant string?

It should be a SYM_NODE marked MOD_STATIC, with ctype.base_type pointing
to an "array of type char", also marked MOD_STATIC.

See evaluate.c: "evaluate_string()".

> And where is the actual value stored?  sym->initializer?

It _should_ be there, but probably isn't. Remember: the code was 
originally written just to get the types right, which means that anything 
that isn't relevant for the type (ie actual contents) was not a priority.

I suspect you can fix that by just adding

	sym->initializer = expr;

to evaluate_string(), but I haven't thought it through.

The basic issue is that a string

	"Hello"

should basically look exactly like

	static char unnamed_array[6] = { 'H', 'e', 'l', 'l', 'o', '\0' } 
		__attribute__((__section__(".rodata")));

modulo some simple short-hand.

		Linus



================================================================================


################################################################################

=== Thread: [rmps@joel.ist.utl.pt: sparse/TSCT BitKeeper repository] ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [rmps@joel.ist.utl.pt: sparse/TSCT BitKeeper repository]
Date: Sun, 14 Dec 2003 22:35:50 +0000
Message-ID: <20031214223549.GA3186 () gtf ! org>
--------------------
Forwarding from linux-kernel...

----- Forwarded message from Rui Saraiva <rmps@joel.ist.utl.pt> -----

From: Rui Saraiva <rmps@joel.ist.utl.pt>
To: linux-kernel@vger.kernel.org
Subject: sparse/TSCT BitKeeper repository
Date: Fri, 12 Dec 2003 04:49:46 +0000 (WET)


Where is the sparse BK repository that used to be
bk://kernel.bkbits.net/torvalds/sparse ?
It seems there is an older version at bk://linux-dj.bkbits.net/sparse

Also in the subject, I got lots of "attribute 'alias': unknown attribute"
warnings in the kernel source in lines with module_init(), module_exit()
and others. A simple fix might be

	if (match_string_ident(attribute, "alias"))
		return NULL;

near the end of handle_attribute() in parse.c


Regards,
	Rui Saraiva
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/

----- End forwarded message -----
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse] C strings 0/2 - the problem ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] C strings 0/2 - the problem
Date: Tue, 09 Sep 2003 23:46:05 +0000
Message-ID: <20030909234605.GA2670 () gtf ! org>
--------------------


evaluate_string() takes an EXPR_STRING, 'expr', as input.
It creates a new symbol 'sym'.
It creates a new EXPR_SYMBOL, 'addr', pointing to 'sym'.
It _overwrites_ 'expr' into an EXPR_PREOP, pointing to 'sym' and 'addr'.
	(this clobbers expr->string)
And finally it returns 'sym'.



Slacker solution:  just stick expr->string pointer somewhere.

And IMO you were correct, a "sym->initializer =" statement is needed.



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] C strings 0/2 - the problem
Date: Tue, 09 Sep 2003 23:53:10 +0000
Message-ID: <Pine.LNX.4.44.0309091652280.10257-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003, Jeff Garzik wrote:
> 
> 
> evaluate_string() takes an EXPR_STRING, 'expr', as input.
> It creates a new symbol 'sym'.
> It creates a new EXPR_SYMBOL, 'addr', pointing to 'sym'.
> It _overwrites_ 'expr' into an EXPR_PREOP, pointing to 'sym' and 'addr'.
> 	(this clobbers expr->string)
> And finally it returns 'sym'.

Why not just fix it by saving the current expr->string information, and 
then re-creating an initializer expr that holds the information?

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] C strings 0/2 - the problem
Date: Wed, 10 Sep 2003 00:19:33 +0000
Message-ID: <3F5E6E15.3060409 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------090309000907060800000908
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Linus Torvalds wrote:
> On Tue, 9 Sep 2003, Jeff Garzik wrote:
> 
>>
>>evaluate_string() takes an EXPR_STRING, 'expr', as input.
>>It creates a new symbol 'sym'.
>>It creates a new EXPR_SYMBOL, 'addr', pointing to 'sym'.
>>It _overwrites_ 'expr' into an EXPR_PREOP, pointing to 'sym' and 'addr'.
>>	(this clobbers expr->string)
>>And finally it returns 'sym'.
> 
> 
> Why not just fix it by saving the current expr->string information, and 
> then re-creating an initializer expr that holds the information?


Does this look sane?

I'm still figuring out parse tree structure and ctype/base_type stuff, 
so consider this wrong patch #3 for now :)

	Jeff



--------------090309000907060800000908
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== evaluate.c 1.138 vs edited =====
--- 1.138/evaluate.c	Mon Sep  1 00:01:38 2003
+++ edited/evaluate.c	Tue Sep  9 20:16:12 2003
@@ -77,7 +77,9 @@
 	struct symbol *sym = alloc_symbol(expr->pos, SYM_NODE);
 	struct symbol *array = alloc_symbol(expr->pos, SYM_ARRAY);
 	struct expression *addr = alloc_expression(expr->pos, EXPR_SYMBOL);
-	int length = expr->string->length;
+	struct expression *initz = alloc_expression(expr->pos, EXPR_INITIALIZER);
+	struct expression *initstr = alloc_expression(expr->pos, EXPR_STRING);
+	unsigned int length = expr->string->length;
 
 	sym->array_size = length;
 	sym->bit_size = BITS_IN_CHAR * length;
@@ -93,6 +95,14 @@
 	
 	addr->symbol = sym;
 	addr->ctype = &ptr_ctype;
+
+	initstr->ctype = sym;
+	initstr->string = expr->string;
+
+	initz->ctype = sym;
+	add_expression(&initz->expr_list, initstr);
+
+	sym->initializer = initz;
 
 	expr->type = EXPR_PREOP;
 	expr->op = '*';

--------------090309000907060800000908--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] C strings 0/2 - the problem
Date: Wed, 10 Sep 2003 00:24:27 +0000
Message-ID: <Pine.LNX.4.44.0309091722210.18813-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003, Jeff Garzik wrote:
> 
> Does this look sane?

I'd suggest removing the EXPR_INITIALIZER.

A "symbol->initializer" does _not_ need to be an initializer expression. 
It can be any expression.

An initializer expression is a special expression that is used when there 
are multiple sub-expressions. Ie

	xxx a = { 1, 2, 3 };

is an EXPR_INITIALIZER, but

	xxx a = 1;

is just a regular expression (and will have type EXPR_VALUE).

		Linus



================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] C strings 0/2 - the problem
Date: Wed, 10 Sep 2003 00:33:12 +0000
Message-ID: <Pine.LNX.4.44.0309091725150.18813-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003, Linus Torvalds wrote:
>
> A "symbol->initializer" does _not_ need to be an initializer expression. 

I realize that this sounds complicated, but it isn't. It just sounds that 
way because we have two different meanings of "initializer".

One meaning is the "symbol initializer" - that is just an expression that 
the symbol has. This is just any random expression, and the only important 
thing is that it should be the same _type_ as the symbol itself.

Ie

	int hello(struct some_struct *p)
	{
		struct some_struct xxx = *a;
		...

initializes the xxx with a simple EXPR_DEREF by dereferencing a pointer.

The other meaning is the "initializer expression" - that's just one _form_ 
of an expression - and it happens to be a "complex expression". As an 
example,

	int hello(int value)
	{
		struct some_struct xxx = { .val = value };
		...

initializes the xxx with a much mode complex expression, and this time the 
expression is of type EXPR_INITIALIZER - which itself is nothing more than 
a list of EXPR_POS expressions (with the zero offset being special, as you 
already found out).

So it's perfectly ok to have

	int hello(void)
	{
		char array[] = "hello";

and here we have two levels of initializers:
 - all strings are associated with an "internal symbol", which is 
   basically their "native representation". That internal symbol has a 
   _static_ initializer expression, which is the string itself (ie a
   EXPR_STRING)
 - the variable "array" has a _non_static_ initializer, which is the
   "internal symbol". 

At least this is how it should work.

			Linus


.

================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] C strings 0/2 - the problem
Date: Wed, 10 Sep 2003 00:45:15 +0000
Message-ID: <3F5E741B.3030806 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------010306010804030906080207
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Linus Torvalds wrote:
> On Tue, 9 Sep 2003, Jeff Garzik wrote:
> 
>>Does this look sane?
> 
> 
> I'd suggest removing the EXPR_INITIALIZER.


Cool.  This is certainly my preferred form...  Ok now?

	Jeff



--------------010306010804030906080207
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== evaluate.c 1.138 vs edited =====
--- 1.138/evaluate.c	Mon Sep  1 00:01:38 2003
+++ edited/evaluate.c	Tue Sep  9 20:42:02 2003
@@ -77,13 +77,18 @@
 	struct symbol *sym = alloc_symbol(expr->pos, SYM_NODE);
 	struct symbol *array = alloc_symbol(expr->pos, SYM_ARRAY);
 	struct expression *addr = alloc_expression(expr->pos, EXPR_SYMBOL);
-	int length = expr->string->length;
+	struct expression *initstr = alloc_expression(expr->pos, EXPR_STRING);
+	unsigned int length = expr->string->length;
 
 	sym->array_size = length;
 	sym->bit_size = BITS_IN_CHAR * length;
 	sym->ctype.alignment = 1;
 	sym->ctype.modifiers = MOD_STATIC;
 	sym->ctype.base_type = array;
+	sym->initializer = initstr;
+
+	initstr->ctype = sym;
+	initstr->string = expr->string;
 
 	array->array_size = length;
 	array->bit_size = BITS_IN_CHAR * length;

--------------010306010804030906080207--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] C strings 0/2 - the problem
Date: Wed, 10 Sep 2003 00:49:21 +0000
Message-ID: <Pine.LNX.4.44.0309091748570.18813-100000 () home ! osdl ! org>
--------------------

On Tue, 9 Sep 2003, Jeff Garzik wrote:
> 
> Cool.  This is certainly my preferred form...  Ok now?

Looks fine by me from a pure code view standpoint.

But does it actually _work_?

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] C strings 0/2 - the problem
Date: Wed, 10 Sep 2003 00:52:48 +0000
Message-ID: <3F5E75E0.3030002 () pobox ! com>
--------------------
Linus Torvalds wrote:
> On Tue, 9 Sep 2003, Jeff Garzik wrote:
> 
>>Cool.  This is certainly my preferred form...  Ok now?
> 
> 
> Looks fine by me from a pure code view standpoint.
> 
> But does it actually _work_?


I'll get back to you on that ;-)

I needed to get this straightened out before getting Hello, World 
working :)  So, don't worry about applying that patch, it'll come to you 
with some other stuff.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse] C strings 1/2 - wrong solution #1 ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] C strings 1/2 - wrong solution #1
Date: Tue, 09 Sep 2003 23:46:48 +0000
Message-ID: <20030909234648.GA3359 () gtf ! org>
--------------------

Causes a not-surprised segfault in my code.  Probably the better of the
two solutions, but still ugly and probably wrong.


===== evaluate.c 1.138 vs edited =====
--- 1.138/evaluate.c	Mon Sep  1 00:01:38 2003
+++ edited/evaluate.c	Tue Sep  9 19:30:03 2003
@@ -77,13 +77,14 @@
 	struct symbol *sym = alloc_symbol(expr->pos, SYM_NODE);
 	struct symbol *array = alloc_symbol(expr->pos, SYM_ARRAY);
 	struct expression *addr = alloc_expression(expr->pos, EXPR_SYMBOL);
-	int length = expr->string->length;
+	unsigned int length = expr->string->length;
 
 	sym->array_size = length;
 	sym->bit_size = BITS_IN_CHAR * length;
 	sym->ctype.alignment = 1;
 	sym->ctype.modifiers = MOD_STATIC;
 	sym->ctype.base_type = array;
+	sym->initializer = expr;
 
 	array->array_size = length;
 	array->bit_size = BITS_IN_CHAR * length;
@@ -93,7 +94,9 @@
 	
 	addr->symbol = sym;
 	addr->ctype = &ptr_ctype;
+	addr->string = expr->string;
 
+	/* overwrite current expression's contents... */
 	expr->type = EXPR_PREOP;
 	expr->op = '*';
 	expr->unop = addr;  
===== expression.h 1.30 vs edited =====
--- 1.30/expression.h	Sat Aug  2 22:45:09 2003
+++ edited/expression.h	Tue Sep  9 19:30:43 2003
@@ -55,6 +55,7 @@
 
 		// EXPR_SYMBOL
 		struct /* symbol_arg */ {
+			struct string *string;
 			struct symbol *symbol;
 			struct ident *symbol_name;
 		};
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse] C strings 2/2 - wrong solution #2 ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] C strings 2/2 - wrong solution #2
Date: Tue, 09 Sep 2003 23:47:31 +0000
Message-ID: <20030909234730.GA3389 () gtf ! org>
--------------------

Causes sparse to utter

	warning: test-hello.c:5:9: internal error: strange degenerate array case
	Segmentation fault

so this patch is definitely wrong.


===== evaluate.c 1.138 vs edited =====
--- 1.138/evaluate.c	Mon Sep  1 00:01:38 2003
+++ edited/evaluate.c	Tue Sep  9 19:34:46 2003
@@ -76,8 +76,8 @@
 {
 	struct symbol *sym = alloc_symbol(expr->pos, SYM_NODE);
 	struct symbol *array = alloc_symbol(expr->pos, SYM_ARRAY);
-	struct expression *addr = alloc_expression(expr->pos, EXPR_SYMBOL);
-	int length = expr->string->length;
+	struct expression *preop = alloc_expression(expr->pos, EXPR_PREOP);
+	unsigned int length = expr->string->length;
 
 	sym->array_size = length;
 	sym->bit_size = BITS_IN_CHAR * length;
@@ -91,13 +91,11 @@
 	array->ctype.modifiers = MOD_STATIC;
 	array->ctype.base_type = &char_ctype;
 	
-	addr->symbol = sym;
-	addr->ctype = &ptr_ctype;
+	preop->op = '*';
+	preop->unop = expr;
+	preop->ctype = sym;
+	sym->initializer = preop;
 
-	expr->type = EXPR_PREOP;
-	expr->op = '*';
-	expr->unop = addr;  
-	expr->ctype = sym;
 	return sym;
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse] backend status ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] backend status
Date: Thu, 11 Sep 2003 14:46:17 +0000
Message-ID: <3F608AB9.6000008 () pobox ! com>
--------------------
Just a quick status description of the sparse backend, listing what it 
_doesn't_ do yet.  I was creating this list for myself anyway, so I 
figured I might as well send it to the list.

No doubt I've forgotten an item or two.


* inline asm
* loops
* complex initializers
* global struct/union variables
* addressing structures, and members of structures (as opposed to 
scalars) on the stack.  Requires smarter stack frame allocation.
* floating point
* labels / goto
* bitfields
* any function argument that isn't 32 bits (or promoted to such)
* 'switch' statements

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] backend status
Date: Thu, 11 Sep 2003 14:52:12 +0000
Message-ID: <3F608C1C.3080204 () pobox ! com>
--------------------
Oh yeah.  Non-32bit-sized SYM_BASETYPEs are pretty poorly supported, too.

BTW the following code _does_ work...

	Jeff



struct foo {
         int a;
         int (*barn)(int x);
         int b;
};


int doit(struct foo *foo, int x)
{
         return foo->barn(x);
}

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse] labels as expressions? ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] labels as expressions?
Date: Wed, 10 Sep 2003 04:07:09 +0000
Message-ID: <3F5EA36D.6020901 () pobox ! com>
--------------------
In the C language, do people actually care about the result of an 
EXPR_LABEL?

Is that what calculated gotos are?

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse] working on validation/type1.c ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] working on validation/type1.c
Date: Wed, 10 Sep 2003 23:09:32 +0000
Message-ID: <3F5FAF2C.9050104 () pobox ! com>
--------------------

So many things are EXPR_PREOP it is tough to keep track.  I'm looking 
into validation/type1.c, and creating test cases from the first part of 
it, the deref function.  Here are three variations, and the symbols that 
appear during the tree walk to the leaf of the 'return' expression:
(stupid question follow output)


static const char deref(const char *s)
{
         return *s;
}

SYM_NODE
   ->ctype.base_type == SYM_FN
     STMT_COMPOUND
       ->syms (empty list)
       ->stmts
         STMT_RETURN
           ->ret_value == EXPR_PREOP
             ->op == '*'
             ->unop == EXPR_PREOP
               ->op == '*'
               ->unop == EXPR_SYMBOL
                 ->sym == SYM_NODE
                   ->ctype.base_type == SYM_PTR

static const char *deref(const char *s)
{
         return s;
}

SYM_NODE
   ->ctype.base_type == SYM_FN
     STMT_COMPOUND
       ->syms (empty list)
       ->stmts
         STMT_RETURN
           ->ret_value == EXPR_PREOP
             ->op == '*'
             ->unop == EXPR_SYMBOL
               ->sym == SYM_NODE
                 ->ctype.base_type == SYM_PTR

static const char deref(const char s)
{
         return s;
}

SYM_NODE
   ->ctype.base_type == SYM_FN
     STMT_COMPOUND
       ->syms (empty list)
       ->stmts
         STMT_RETURN
           ->ret_value == EXPR_PREOP
             ->op == '*'
             ->unop == EXPR_SYMBOL
               ->sym == SYM_NODE
                 ->ctype.base_type == SYM_BASETYPE

Why are there EXPR_PREOP for the last two cases, where I'm not actually 
dereferencing anything?
[guesses...]  Does EXPR_PREOP have two modes, (1) when dereferencing and 
(2) when hiding an EXPR_SYMBOL?

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Wed, 10 Sep 2003 23:25:23 +0000
Message-ID: <Pine.LNX.4.44.0309101616220.27019-100000 () home ! osdl ! org>
--------------------

On Wed, 10 Sep 2003, Jeff Garzik wrote:
> 
> So many things are EXPR_PREOP it is tough to keep track.

Yes. On ein particular: the '*' dereference operator, should really be an 
expression type of its own (an "EXPR_ACCESS" thing).

Right now the expressions are EXPR_PREOP just because they _parse_ the 
same way, not because it makes any real sense.

> static const char deref(const char *s)
> {
>          return *s;
> }
> 
> SYM_NODE
>    ->ctype.base_type == SYM_FN
>      STMT_COMPOUND
>        ->syms (empty list)
>        ->stmts
>          STMT_RETURN
>            ->ret_value == EXPR_PREOP
>              ->op == '*'
>              ->unop == EXPR_PREOP
>                ->op == '*'
>                ->unop == EXPR_SYMBOL
>                  ->sym == SYM_NODE
>                    ->ctype.base_type == SYM_PTR

Looks good.  As mentioned, it would probably be more understandable with a
EXPR_ACCESS, but it looks correct as-is.

> static const char *deref(const char *s)
> {
>          return s;
> }
> 
> SYM_NODE
>    ->ctype.base_type == SYM_FN
>      STMT_COMPOUND
>        ->syms (empty list)
>        ->stmts
>          STMT_RETURN
>            ->ret_value == EXPR_PREOP
>              ->op == '*'
>              ->unop == EXPR_SYMBOL
>                ->sym == SYM_NODE
>                  ->ctype.base_type == SYM_PTR
> 
> static const char deref(const char s)
> {
>          return s;
> }
> 
> SYM_NODE
>    ->ctype.base_type == SYM_FN
>      STMT_COMPOUND
>        ->syms (empty list)
>        ->stmts
>          STMT_RETURN
>            ->ret_value == EXPR_PREOP
>              ->op == '*'
>              ->unop == EXPR_SYMBOL
>                ->sym == SYM_NODE
>                  ->ctype.base_type == SYM_BASETYPE
> 
> Why are there EXPR_PREOP for the last two cases, where I'm not actually 
> dereferencing anything?

Think of it as an "access". 

Without the access, a symbol is always just a "pointer". Of course, the 
optimizer may choose to allocate backing store for the symbol in something 
that isn't addressable (ie a hard register), but the point is, it can only 
do so if the symbol is _always_ accessed through the EXPR_PREOP/*.

> [guesses...]  Does EXPR_PREOP have two modes, (1) when dereferencing and 
> (2) when hiding an EXPR_SYMBOL?

No.  EXPR_PREOP/* always means the same thing, and it really reads better 
if you think of it as "EXPR_ACCESS".

You can access a register variable, or you can access a pointer. 

Also, take a look at "lvalue_expression()", and realize what this all
results in: because of this consistency, it is very easy to see if
something is an lvalue or not. There are exactly _two_ kinds of lvalues:  
the "EXPR_BITFIELD" (think of that as "EXPR_ACCESS_BITS"), and
EXPR_PREOP/* (think of that as "EXPR_ACCESS").

(The cast thing is an ugly gcc extension that I actually disagree with, oh
well).

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Wed, 10 Sep 2003 23:44:21 +0000
Message-ID: <3F5FB755.8090807 () pobox ! com>
--------------------
Linus Torvalds wrote:
> Yes. On ein particular: the '*' dereference operator, should really be an 
> expression type of its own (an "EXPR_ACCESS" thing).
> 
> Right now the expressions are EXPR_PREOP just because they _parse_ the 
> same way, not because it makes any real sense.

Makes a lot of sense, now.

Separating "deref" from "access" is precisely what I'm struggling with.


>>static const char deref(const char *s)
>>{
>>         return *s;
>>}
>>
>>SYM_NODE
>>   ->ctype.base_type == SYM_FN
>>     STMT_COMPOUND
>>       ->syms (empty list)
>>       ->stmts
>>         STMT_RETURN
>>           ->ret_value == EXPR_PREOP
>>             ->op == '*'
>>             ->unop == EXPR_PREOP
>>               ->op == '*'
>>               ->unop == EXPR_SYMBOL
>>                 ->sym == SYM_NODE
>>                   ->ctype.base_type == SYM_PTR

My code (and show-parse) hit the first EXPR_PREOP, and go "Access!", and 
keep recursing into the tree.  Which results in the second EXPR_PREOP, 
and we shout "Access!" again.  So I hit the symbol, see it's an 
argument, and return the stack slot presenting the arg's ABI-dictated 
placement on the stack.

My plan (until now) was to detect multiple successive EXPR_PREOPs, but 
distinguishing de-refs would be far better.  i.e. "address" versus "access".

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Thu, 11 Sep 2003 00:13:51 +0000
Message-ID: <Pine.LNX.4.44.0309101707450.27596-100000 () home ! osdl ! org>
--------------------

On Wed, 10 Sep 2003, Jeff Garzik wrote:
> 
> My plan (until now) was to detect multiple successive EXPR_PREOPs, but 
> distinguishing de-refs would be far better.  i.e. "address" versus "access".

No, you have to look what is behing the EXPR_ACCESS. The parse tree 
literally cannot tell if a symbol is an "address" or a register. That is 
clear only after the back-end has done allocation for that particular 
symbol and access.

So there is no "address vs access", there is only "access". 

At some point, the back-end can _collapse_ a "EXPR_ACCESS -> EXPR_SYMBOL"
into a "EXPR_READREG" (or, in the case of assignments, EXPR_WRITEREG).  
But that's outside the scope of the front-end parse tree.

Think of it this way: EXPR_ACCESS (aka "EXPR_PREOP-*" currently) _always_ 
takes an address. And EXPR_SYMBOL _always_ delivers the address of the 
symbol. Combining them as a register access is an optimization, nothing 
more.

I think your confusion is really over EXPR_SYMBOL: you think EXPR_SYMBOL 
has an explicit "access" in it. It doesn't. EXPR_SYMBOL is literally just 
the address of the symbol. Always.

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Thu, 11 Sep 2003 00:38:25 +0000
Message-ID: <3F5FC401.1090509 () pobox ! com>
--------------------
Linus Torvalds wrote:
> Think of it this way: EXPR_ACCESS (aka "EXPR_PREOP-*" currently) _always_ 
> takes an address. And EXPR_SYMBOL _always_ delivers the address of the 
> symbol. Combining them as a register access is an optimization, nothing 
> more.
> 
> I think your confusion is really over EXPR_SYMBOL: you think EXPR_SYMBOL 
> has an explicit "access" in it. It doesn't. EXPR_SYMBOL is literally just 
> the address of the symbol. Always.

No, I get that part.  If I didn't, a lot more things would be broken :)

Now that you have clarified how EXPR_PREOP behaves, it seems clear that 
my code is missing a load (show-parse appears to be ok), and that's the 
root problem.

I get

	EXPR_PREOP -> EXPR_PREOP -> EXPR_SYMBOL == address

when I should get

	EXPR_PREOP -> EXPR_PREOP -> EXPR_SYMBOL == address of address

Ditto for infinite additional number of EXPR_PREOP added to the front of 
that chain.  Currently my code will simply return the value of the 
address of the symbol up the stack... instead of successively 
de-referencing the address.  I could have _sworn_ that stupid load was 
in there...  Instead I was thinking it was a tree walker bug of some sort.

Thanks for all the enlightenment,

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Thu, 11 Sep 2003 01:11:12 +0000
Message-ID: <Pine.LNX.4.44.0309101806480.27596-100000 () home ! osdl ! org>
--------------------

On Wed, 10 Sep 2003, Jeff Garzik wrote:
> 
> Now that you have clarified how EXPR_PREOP behaves, it seems clear that 
> my code is missing a load (show-parse appears to be ok), and that's the 
> root problem.
> 
> I get
> 
> 	EXPR_PREOP -> EXPR_PREOP -> EXPR_SYMBOL == address
> 
> when I should get
> 
> 	EXPR_PREOP -> EXPR_PREOP -> EXPR_SYMBOL == address of address

Each EXPR_PREOP-* should result in one load. So 

	EXPR_PREOP -> EXPR_SYMBOL

should result in something like

	lea symbol, %eax		/* EXPR_SYMBOL */
	movl (%eax), %eax		/* EXPR_PREOP-* aka EXPR_ACCESS */

while

	EXPR_PREOP -> EXPR_PREOP -> EXPR_SYMBOL

should result in

	lea symbol, %eax		/* EXPR_SYMBOL */
	movl (%eax), %eax		/* "inner" EXPR_PREOP */
	movl (%eax), &eax		/* "outer" EXPR_PREOP */

(And of course, even a trivial peep-hole optimizer will collapse the

	lea symbol, %eax
	movl (%eax), %eax

into

	movl symbol, %eax

but that really should be considered an optimization, and not a direct
result of the parse tree)

		Linus



================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Thu, 11 Sep 2003 01:46:16 +0000
Message-ID: <3F5FD3E8.1010300 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------020309040801020109000807
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Linus Torvalds wrote:
> Each EXPR_PREOP-* should result in one load. So 
> 
> 	EXPR_PREOP -> EXPR_SYMBOL
> 
> should result in something like
> 
> 	lea symbol, %eax		/* EXPR_SYMBOL */
> 	movl (%eax), %eax		/* EXPR_PREOP-* aka EXPR_ACCESS */
> 
> while
> 
> 	EXPR_PREOP -> EXPR_PREOP -> EXPR_SYMBOL
> 
> should result in
> 
> 	lea symbol, %eax		/* EXPR_SYMBOL */
> 	movl (%eax), %eax		/* "inner" EXPR_PREOP */
> 	movl (%eax), &eax		/* "outer" EXPR_PREOP */
> 
> (And of course, even a trivial peep-hole optimizer will collapse the
> 
> 	lea symbol, %eax
> 	movl (%eax), %eax
> 
> into
> 
> 	movl symbol, %eax
> 
> but that really should be considered an optimization, and not a direct
> result of the parse tree)

Ok, I've got something working for both deref and non-deref cases, using 
the attached patch.  Look at the FIXME comment removed in the patch-- 
it's straight out of show-parse.c.

I tested several examples I have locally (including good ole hello 
world) and they all seem to generate the correct results.  The output 
winds up looking like your second example (with an additional mov to 
store the %eax result in a stack-based pseudo), such that

/* generates EXPR_PREOP -> EXPR_SYMBOL */
int val(int s)
{
         return s;
}

/* generates EXPR_PREOP -> EXPR_PREOP -> EXPR_SYMBOL */
int deref(int *s)
{
         return *s;
}

currently generates

val:
         movl    4(%esp), %eax           # return
         ret

deref:
         subl    $4, %esp
         movl    8(%esp), %eax           # begin deref ..
         movl    (%eax), %ecx
         movl    %ecx, (%esp)            # .... end deref
         movl    (%esp), %eax            # return
         addl    $4, %esp
         ret

There's definitely still work to be done, in the show_symbol_expr_init() 
area.  I need to get refs to global vars working again, and with your 
clarifications on EXPR_SYMBOL especially, it should be easy.

	Jeff


P.S. Don't apply the patch, it'll be queued.

--------------020309040801020109000807
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== compile-i386.c 1.16 vs edited =====
--- 1.16/compile-i386.c	Wed Sep 10 18:19:40 2003
+++ edited/compile-i386.c	Wed Sep 10 21:13:55 2003
@@ -1555,15 +1555,28 @@
 	return new;
 }
 
-/*
- * FIXME! Not all accesses are memory loads. We should
- * check what kind of symbol is behind the dereference.
- */
 static struct storage *x86_address_gen(struct expression *expr)
 {
-	if (expr->type == EXPR_PREOP)
-		return x86_expression(expr->unop);
-	return x86_expression(expr->address);
+	struct storage *addr;
+	struct storage *new;
+
+	if (expr->type != EXPR_PREOP)
+		return x86_expression(expr->address);
+
+	addr = x86_expression(expr->unop);
+	if (expr->unop->type == EXPR_SYMBOL)
+		return addr;
+
+	emit_move(addr, REG_EAX, NULL, "begin deref ..", 0);
+
+	/* FIXME: operand size */
+	strcpy(s, "\tmovl\t(%eax), %ecx\n");
+	push_text_atom(f, s);
+
+	new = new_pseudo();
+	emit_move(REG_ECX, new, NULL, ".... end deref", 0);
+
+	return new;
 }
 
 static struct storage *x86_assignment(struct expression *expr)

--------------020309040801020109000807--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Thu, 11 Sep 2003 01:53:32 +0000
Message-ID: <Pine.LNX.4.44.0309101850480.27596-100000 () home ! osdl ! org>
--------------------

On Wed, 10 Sep 2003, Jeff Garzik wrote:
> 
> P.S. Don't apply the patch, it'll be queued.

Please don't do this:

+       if (expr->type != EXPR_PREOP)
+               return x86_expression(expr->address);

The thing is, there are plenty of "preops" that are _not_ accesses. 

For example "return -a;" will result in 

	EXPR_PREOP '-'			/* Negate */
		EXPR_PREOP '*'		/* Access */
			EXPR_SYMBOL	/* Address of 'a' */

so I don't think it's ever valid to just compare agaist EXPR_PREOP. You 
have to compare with "PREOP && '*'" (== ACCESS).

		Linus




================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] working on validation/type1.c
Date: Thu, 11 Sep 2003 02:07:36 +0000
Message-ID: <3F5FD8E8.9060605 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------000101070900070005080107
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Linus Torvalds wrote:
> so I don't think it's ever valid to just compare agaist EXPR_PREOP. You 
> have to compare with "PREOP && '*'" (== ACCESS).


Good point, fixed.  While I was fixing this I re-read this show_preop() 
comment, so it should have kicked it into my head :)

         /*
          * '*' is an lvalue access, and is fundamentally different
          * from an arithmetic operation. Maybe it should have an
          * expression type of its own..
          */

Anyway, here's what validation/type1.c looks like now (file head/tail 
snipped for brevity:

test:
         subl    $8, %esp
         movl    12(%esp), %eax          # begin deref ..
         movl    (%eax), %ecx
         movl    %ecx, (%esp)            # .... end deref
         movsxb  (%esp), %eax            # begin cast ..
         movl    %eax, 4(%esp)           # .... end cast
         movl    4(%esp), %eax           # return
         jmp     .L1
         movl    4(%esp), %eax           # return
         jmp     .L1
.L1:
         addl    $8, %esp
         ret


It looks OK to me except for two things:

1) movsxb probably wrong, artifact of my wanna-type-aware emit_move()

2) the inliner didn't eat the 'return' stmt, so my code assumes it's a 
hard return.

	Jeff



--------------000101070900070005080107
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== compile-i386.c 1.16 vs edited =====
--- 1.16/compile-i386.c	Wed Sep 10 18:19:40 2003
+++ edited/compile-i386.c	Wed Sep 10 22:00:15 2003
@@ -1555,15 +1555,31 @@
 	return new;
 }
 
-/*
- * FIXME! Not all accesses are memory loads. We should
- * check what kind of symbol is behind the dereference.
- */
 static struct storage *x86_address_gen(struct expression *expr)
 {
-	if (expr->type == EXPR_PREOP)
-		return x86_expression(expr->unop);
-	return x86_expression(expr->address);
+	struct function *f = current_func;
+	struct storage *addr;
+	struct storage *new;
+	char s[32];
+
+	if ((expr->type != EXPR_PREOP) ||
+	    ((expr->type == EXPR_PREOP) && (expr->op != '*')))
+		return x86_expression(expr->address);
+
+	addr = x86_expression(expr->unop);
+	if (expr->unop->type == EXPR_SYMBOL)
+		return addr;
+
+	emit_move(addr, REG_EAX, NULL, "begin deref ..", 0);
+
+	/* FIXME: operand size */
+	strcpy(s, "\tmovl\t(%eax), %ecx\n");
+	push_text_atom(f, s);
+
+	new = new_pseudo();
+	emit_move(REG_ECX, new, NULL, ".... end deref", 0);
+
+	return new;
 }
 
 static struct storage *x86_assignment(struct expression *expr)

--------------000101070900070005080107--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: initstr sample session ===

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: initstr sample session
Date: Tue, 09 Sep 2003 22:32:37 +0000
Message-ID: <20030909223237.GK919 () conectiva ! com ! br>
--------------------
../sparse.acme/initstr -Wp,-MD,net/ipv4/.xfrm4_tunnel.o.d -D__KERNEL__ -Iinclude -Wall -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2 -march=athlon -Iinclude/asm-i386/mach-default -nostdinc -iwithprefix include -DKBUILD_BASENAME=xfrm4_tunnel -DKBUILD_MODNAME=xfrm4_tunnel -c -o net/ipv4/xfrm4_tunnel.o net/ipv4/xfrm4_tunnel.c  > /tmp/a.c

I.e. replace gcc by initstr as a first pass and trow the results in /tmp/a.c,
I should make initstr use the -o switch to store the tmp file.

gcc -Wp,-MD,net/ipv4/.xfrm4_tunnel.o.d -D__KERNEL__ -Iinclude -Wall -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2.0 -march=athlon -Iinclude/asm-i386/mach-default -nostdinc -iwithprefix include -DKBUILD_BASENAME=xfrm4_tunnel -DKBUILD_MODNAME=xfrm4_tunnel -c -o net/ipv4/xfrm4_tunnel.o /tmp/a.c

I.e. use real gcc in the initstr patched source (/tmp/a.c):

now to see where the strings in __init functions went...

[acme@oops sk_buff-2.6]$ objdump -j .init.data -s net/ipv4/xfrm4_tunnel.o

net/ipv4/xfrm4_tunnel.o:     file format elf32-i386

Contents of section .init.data:
 0000 3c363e69 70697020 696e6974 3a206361  <6>ipip init: ca
 0010 6e277420 61646420 7866726d 20747970  n't add xfrm typ
 0020 650a0000 00000000 00000000 00000000  e...............
 0030 00000000 00000000 00000000 00000000  ................
 0040 3c363e69 70697020 696e6974 3a206361  <6>ipip init: ca
 0050 6e277420 61646420 70726f74 6f636f6c  n't add protocol
 0060 0a00                                 ..
[acme@oops sk_buff-2.6]$

What about the ones in __exit functions?

[acme@oops sk_buff-2.6]$ objdump -j .exit.data -s net/ipv4/xfrm4_tunnel.o

net/ipv4/xfrm4_tunnel.o:     file format elf32-i386

Contents of section .exit.data:
 0000 3c363e69 70697020 636c6f73 653a2063  <6>ipip close: c
 0010 616e2774 2072656d 6f766520 70726f74  an't remove prot
 0020 6f636f6c 0a000000 00000000 00000000  ocol............
 0030 00000000 00000000 00000000 00000000  ................
 0040 3c363e69 70697020 636c6f73 653a2063  <6>ipip close: c
 0050 616e2774 2072656d 6f766520 7866726d  an't remove xfrm
 0060 20747970 650a00                       type..
[acme@oops sk_buff-2.6]$

It seems to work! :-)

- Arnaldo
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: x86 compare q... ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: x86 compare q...
Date: Mon, 08 Sep 2003 01:45:30 +0000
Message-ID: <3F5BDF3A.2020302 () pobox ! com>
--------------------
So, compile generates this output

         .file   "test-cmp.c"
         .text
.globl doit
         .type   doit, @function
doit:
         subl    $4, %esp
         movl    $1, %ecx                # EXPR_COMPARE
         xorl    %edx, %edx
         movl    8(%esp), %eax
         cmpl    %eax, 12(%esp)
         cmovl   %ecx, %edx
         movl    %edx, (%esp)            # end EXPR_COMPARE
         jmp     .L1
.L1:
         movl    (%esp), %eax
         addl    $4, %esp
         ret
         .size   doit, .-doit
         .ident  "sparse silly x86 backend (built Sep  7 2003)"

for this C code

	int doit(int x, int y)
	{
	        return (x < y);
	}

The x86 asm generates weird, but reproducible results:

	bash-2.05b$ ./driver
	doit(0, 0) == 0
	doit(1, 2) == 0
	doit(2, 1) == 1
	doit(433, 433) == 0
	doit(200, 433) == 0
	doit(433, 133) == 1

I was expecting "0, 1, 0", "0, 1, 0", because the 2nd and 5th function 
calls are the only cases when x is less than y.

The intention of the above EXPR_COMPARE asm is to move value $0 into 
(%esp) if the compare "x < y" fails, and value $1 into (%esp) if it 
succeeds.  So, two questions...

1) Am I doing something obviously stupid in the asm?

2) Does "cmovl" need an additional "l" suffix, to indicate operand size?

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: x86 compare q...
Date: Mon, 08 Sep 2003 03:02:49 +0000
Message-ID: <3F5BF159.1050703 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------030808010604080108090306
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Nevermind.  The attached patch fixes comparisons...  I'll be checking it 
in shortly.

I would have thought the RHS operand to "cmp" would be the second one 
listed, but I guess not...

	Jeff



--------------030808010604080108090306
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== compile-i386.c 1.5 vs edited =====
--- 1.5/compile-i386.c	Sun Sep  7 21:29:32 2003
+++ edited/compile-i386.c	Sun Sep  7 22:56:49 2003
@@ -835,7 +835,7 @@
 	insn("movl", left, REG_EAX, NULL, 0);
 
 	/* perform comparison, EAX (op1) and op2 */
-	insn("cmpl", REG_EAX, right, NULL, 0);
+	insn("cmpl", right, REG_EAX, NULL, 0);
 
 	/* store result of operation, 0 or 1, in EDX using CMOV */
 	/* FIXME: does this need an operand size suffix? */

--------------030808010604080108090306--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

