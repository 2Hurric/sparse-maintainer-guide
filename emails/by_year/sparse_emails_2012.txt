--- Emails for Year 2012 ---

=== Thread: [No Subject] ===

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
pile of problems and make things faster.

Cheers,
Ben.
 

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
call back hook to accomplish the same macro dependency
analyse, without significant impact the sparse internals.

If you think the macro_expend hook is not good enough,
please let me know where it is not sufficient.

> Still I try: Tokens dont sit around, they are released when
> the program finishes. Treating the preprocessing stage
> like nonexisting doesnt reflect the way most people use
> a compiler. They always use the preprocessor even if
> there might be the possibility to use the compiler with only
> a preprocessed file. Therefore tokens should sit around.

Yes token should sit around for your macro dependency
analyse. But I like it to be an option rather hard code the
token in the to the AST. Sparse is a library, there are several
program use it.

I see a way to allow your do want you want to do on the
macro dependency while not impact other program. Why
not give it a try? The point is, I don't see it is necessary
to force every one accept the expr->tok->pos. It is straightly
worse for program that don't care about the macro expand
dependency. As long as you can accomplish the same
dependency analyse, why do you care it is using the
"embed token" approach rather than macro_expand hook?

>> It is still too invasive. I don't want to keep<tok>->pos in the statements
>> and expression.
>
>
> If this is invasive a little less than this would mean no change at
> all.

Yes, it would be no change at all from the AST point of view if
we use the macro_expand hook. You just need to maintain
a hash table from old <pos> to new <pos> mapping with the
additional dependency information. You don't even need to
generate the pre-processed file explicitly. I am using that as
the thinking process how to get there.

>> The the second step is just parsing on the pre-processed file. Using
>> the macro expand history to map the position back to the original file.
>> In this way, you can do your dependency analyse with minimal
>> impact to sparse internals. The macro_expand hook can use to
>> do other useful stuff as well. Will that address your need?
>
>
> Thats not what I want, but rather what you want. If you
> want a macro expand history, it would be faster, easier simpler
> if you would hack it yourself, I dont want a macro expand,
> i have my tool htmltag for that already. I want a macro dependency tree.
> With only macro_expand hook and only file-scope <pos> it is not
> possible.

Nope, it is possible, that is what I am purposing. Sorry I previous
explain has been very high level, I haven't explain in the implementation
detail of every stage.

So the first patch would be adding the macro_expand hook into sparse.
After a pre-processor macro expend, it will call the the macro_expand
hook if the user register one. (the hook is not NULL).

In the macro_expand hook, it will receive:
- macro before the expand,
- args for the macro
- replacement tokens after the expand.

This will give your macro dependency program a chance to
exam and manipulate the token before it get insert back
to original token list.


Here is how your macro dependency program can use the
macro_expand hook.

The program should create a internal stream call "<pre-processor>".
The content of the file is just the result of macro expand. One
macro at a line, the the order they are expanded. You can use the
pos->line to index when macro expand it is. Notice that you don't
need to actually write out the stream into disk.

Then, inside the macro_expand hook that receive the macro
expand call back.

There will be an array of data structure keep track of the
macro expand. The first macro expand is on the first element
of the array. Let's call this data structure "struct macro_deps".

Inside "struct macro_deps", it will keep track of the original
macro before the expand. The list of the tokens it depends on.
That is your dependency information.

It will allocate one "struct macro_deps" and fill it out, append
to the end of the array.

Before you macro_expand hook return, it walk the replacement
token. For each "token->pos" in the replacement token, it will
replace the stream number to to "pre-processor", and line number
to the index of the "struct macro_deps" in the array. Before the
replacement, if the original stream is already "<pre-processor>",
that means you are expanding the result from another macro expand.
Using the old pos->line to look up the inner macro expand, add
inner macro's dependency list into the current macro dependency list.

Then after the pre-processor stage. All the token from macro
expand will look as if they are expand from the "pre-processor"
file, line number can be use as index to lookup the array to find
out the detail of this macro expand.

Will that work for your dependency file. I notice that it not 100%
the same with your dependency, but with the intact history. You
should able to find that out.

> And: until I would have come up with something that would fit your
> requirements
> months would be gone. It seems that you know exactly how
> it should  be done, there is no way for me to know how
> you think a noninvasive solution would look like. The communication
> takes too long.

So here it is. I already give you the details of the implementation.
Of course, the first step for macro_expand hook is much smaller
scope. Please let me know that works or not.

>
> If there is no need for the tool i proposed, there is no need.
> At least I tried :-)

I already confirm that is useful. Just how to implement it.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
call back hook to accomplish the same macro dependency
analyse, without significant impact the sparse internals.

If you think the macro_expend hook is not good enough,
please let me know where it is not sufficient.

> Still I try: Tokens dont sit around, they are released when
> the program finishes. Treating the preprocessing stage
> like nonexisting doesnt reflect the way most people use
> a compiler. They always use the preprocessor even if
> there might be the possibility to use the compiler with only
> a preprocessed file. Therefore tokens should sit around.

Yes token should sit around for your macro dependency
analyse. But I like it to be an option rather hard code the
token in the to the AST. Sparse is a library, there are several
program use it.

I see a way to allow your do want you want to do on the
macro dependency while not impact other program. Why
not give it a try? The point is, I don't see it is necessary
to force every one accept the expr->tok->pos. It is straightly
worse for program that don't care about the macro expand
dependency. As long as you can accomplish the same
dependency analyse, why do you care it is using the
"embed token" approach rather than macro_expand hook?

>> It is still too invasive. I don't want to keep<tok>->pos in the statements
>> and expression.
>
>
> If this is invasive a little less than this would mean no change at
> all.

Yes, it would be no change at all from the AST point of view if
we use the macro_expand hook. You just need to maintain
a hash table from old <pos> to new <pos> mapping with the
additional dependency information. You don't even need to
generate the pre-processed file explicitly. I am using that as
the thinking process how to get there.

>> The the second step is just parsing on the pre-processed file. Using
>> the macro expand history to map the position back to the original file.
>> In this way, you can do your dependency analyse with minimal
>> impact to sparse internals. The macro_expand hook can use to
>> do other useful stuff as well. Will that address your need?
>
>
> Thats not what I want, but rather what you want. If you
> want a macro expand history, it would be faster, easier simpler
> if you would hack it yourself, I dont want a macro expand,
> i have my tool htmltag for that already. I want a macro dependency tree.
> With only macro_expand hook and only file-scope <pos> it is not
> possible.

Nope, it is possible, that is what I am purposing. Sorry I previous
explain has been very high level, I haven't explain in the implementation
detail of every stage.

So the first patch would be adding the macro_expand hook into sparse.
After a pre-processor macro expend, it will call the the macro_expand
hook if the user register one. (the hook is not NULL).

In the macro_expand hook, it will receive:
- macro before the expand,
- args for the macro
- replacement tokens after the expand.

This will give your macro dependency program a chance to
exam and manipulate the token before it get insert back
to original token list.


Here is how your macro dependency program can use the
macro_expand hook.

The program should create a internal stream call "<pre-processor>".
The content of the file is just the result of macro expand. One
macro at a line, the the order they are expanded. You can use the
pos->line to index when macro expand it is. Notice that you don't
need to actually write out the stream into disk.

Then, inside the macro_expand hook that receive the macro
expand call back.

There will be an array of data structure keep track of the
macro expand. The first macro expand is on the first element
of the array. Let's call this data structure "struct macro_deps".

Inside "struct macro_deps", it will keep track of the original
macro before the expand. The list of the tokens it depends on.
That is your dependency information.

It will allocate one "struct macro_deps" and fill it out, append
to the end of the array.

Before you macro_expand hook return, it walk the replacement
token. For each "token->pos" in the replacement token, it will
replace the stream number to to "pre-processor", and line number
to the index of the "struct macro_deps" in the array. Before the
replacement, if the original stream is already "<pre-processor>",
that means you are expanding the result from another macro expand.
Using the old pos->line to look up the inner macro expand, add
inner macro's dependency list into the current macro dependency list.

Then after the pre-processor stage. All the token from macro
expand will look as if they are expand from the "pre-processor"
file, line number can be use as index to lookup the array to find
out the detail of this macro expand.

Will that work for your dependency file. I notice that it not 100%
the same with your dependency, but with the intact history. You
should able to find that out.

> And: until I would have come up with something that would fit your
> requirements
> months would be gone. It seems that you know exactly how
> it should  be done, there is no way for me to know how
> you think a noninvasive solution would look like. The communication
> takes too long.

So here it is. I already give you the details of the implementation.
Of course, the first step for macro_expand hook is much smaller
scope. Please let me know that works or not.

>
> If there is no need for the tool i proposed, there is no need.
> At least I tried :-)

I already confirm that is useful. Just how to implement it.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
more descriptive then sure, by all means. Just don't let them grow out
of proportion - keep them simple and succinct.

> On another note, I have a "part two" set of patches for bug.h &
> compiler*.h that does some other stuff (more cleanup & restructuring)
> and this is making me think about that more.  My thought about
> __compiletime_error_fallback is that it should be called only from
> within compiler.h (as in the following patch) and basically just be a
> private macro.  However, we still use the use the negative sized array
> trick for the unoptimized version of BUILD_BUG_ON (which may have
> limited meaning), and we also use a negative bit specifier on a bitfield
> in BUILD_BUG_ON_ZERO and BUILD_BUG_ON_NULL (which I treat some in my
> other patches as well).  But my thought is that it may be helpful to
> encapsulate these tricks into (public) macros in compiler*.h, such as
> "compiletime_assert_negarray" and "compiletime_assert_negbitfiled" and
> then have __compiletime_error_fallback expand to
> compiletime_assert_negarray when it's needed and no-op when it's not.
> 
> This doesn't have to be decided now, but it's just a thought you gave me.

I dunno. I'm thinking that maybe making them more unreadable for no
apparent reason might be simply too much. They're fine the way they are
now, if you ask me.

> And in case you're wondering about the negative bit field,
> BUILD_BUG_ON_{ZERO,NULL} can't call BUILD_BUG_ON in a complex expression
> ({ exp; exp; }) because it is evaluated outside of a function body and
> gcc doesn't like that.  Thus, the following macro would, sadly, result
> in errors:
> 
> #define BUILD_BUG_ON_ZERO(exp) ({BUILD_BUG_ON(exp); 0;})
> 
> However, it would not be an error to call an __alwaysinline function
> that uses BUILD_BUG_ON, so I still have to explore that and make sure it
> works in all scenarios (and compilers).

Ok, I see your point. Think of it this way: if unifying those macros can
only happen at the expense of readability or performance then maybe it
is not worth the trouble. If, OTOH, you can think of something slick and
pretty, then go ahead :).

HTH.

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
more descriptive then sure, by all means. Just don't let them grow out
of proportion - keep them simple and succinct.

> On another note, I have a "part two" set of patches for bug.h &
> compiler*.h that does some other stuff (more cleanup & restructuring)
> and this is making me think about that more.  My thought about
> __compiletime_error_fallback is that it should be called only from
> within compiler.h (as in the following patch) and basically just be a
> private macro.  However, we still use the use the negative sized array
> trick for the unoptimized version of BUILD_BUG_ON (which may have
> limited meaning), and we also use a negative bit specifier on a bitfield
> in BUILD_BUG_ON_ZERO and BUILD_BUG_ON_NULL (which I treat some in my
> other patches as well).  But my thought is that it may be helpful to
> encapsulate these tricks into (public) macros in compiler*.h, such as
> "compiletime_assert_negarray" and "compiletime_assert_negbitfiled" and
> then have __compiletime_error_fallback expand to
> compiletime_assert_negarray when it's needed and no-op when it's not.
> 
> This doesn't have to be decided now, but it's just a thought you gave me.

I dunno. I'm thinking that maybe making them more unreadable for no
apparent reason might be simply too much. They're fine the way they are
now, if you ask me.

> And in case you're wondering about the negative bit field,
> BUILD_BUG_ON_{ZERO,NULL} can't call BUILD_BUG_ON in a complex expression
> ({ exp; exp; }) because it is evaluated outside of a function body and
> gcc doesn't like that.  Thus, the following macro would, sadly, result
> in errors:
> 
> #define BUILD_BUG_ON_ZERO(exp) ({BUILD_BUG_ON(exp); 0;})
> 
> However, it would not be an error to call an __alwaysinline function
> that uses BUILD_BUG_ON, so I still have to explore that and make sure it
> works in all scenarios (and compilers).

Ok, I see your point. Think of it this way: if unifying those macros can
only happen at the expense of readability or performance then maybe it
is not worth the trouble. If, OTOH, you can think of something slick and
pretty, then go ahead :).

HTH.

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Adding default for m64/m32 handle ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Adding default for m64/m32 handle
Date: Thu, 26 Jul 2012 16:57:43 +0000
Message-ID: <CANeU7QnLKv8MMGCkKq-8dsw=xoVExR7oAigvSLSuCFmYKsE9AQ () mail ! gmail ! com>
--------------------
On Thu, Jul 26, 2012 at 4:14 AM, Dan Carpenter <dan.carpenter@oracle.com> wrote:
> Thanks, that works.

OK, no objects so far. I will apply it then.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: False warning from Sparse ===

From: Larry Finger <Larry.Finger () lwfinger ! net>
To: linux-sparse
Subject: False warning from Sparse
Date: Sun, 22 Jul 2012 03:52:54 +0000
Message-ID: <500B7916.6060804 () lwfinger ! net>
--------------------
Hi,

I am getting the following false warning from sparse:

   CHECK   drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c
drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c:1158:13: warning: context 
imbalance in 'rtl92c_dm_refresh_rate_adaptive_mask' - different lock contexts 
for basic block

The only code in that routine that does any locking is the following:

              /* Only the PCI card uses sta in the update rate table
               * callback routine */
              if (rtlhal->interface == INTF_PCI) {
                      rcu_read_lock();
                      sta = ieee80211_find_sta(mac->vif, mac->bssid);
              }
              rtlpriv->cfg->ops->update_rate_tbl(hw, sta,
                                   p_ra->ratr_state);

              p_ra->pre_ratr_state = p_ra->ratr_state;
              if (rtlhal->interface == INTF_PCI)
                      rcu_read_unlock();

Does the warning get output because the code cannot assume that 
rtlhal->interface is the same in both if statements? If that is the case, are 
there any compiler directives that would tell sparse of the situation?

Thanks,

Larry
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Larry Finger <Larry.Finger () lwfinger ! net>
To: linux-kernel
Subject: False warning from Sparse
Date: Sun, 22 Jul 2012 03:52:54 +0000
Message-ID: <500B7916.6060804 () lwfinger ! net>
--------------------
Hi,

I am getting the following false warning from sparse:

   CHECK   drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c
drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c:1158:13: warning: context 
imbalance in 'rtl92c_dm_refresh_rate_adaptive_mask' - different lock contexts 
for basic block

The only code in that routine that does any locking is the following:

              /* Only the PCI card uses sta in the update rate table
               * callback routine */
              if (rtlhal->interface == INTF_PCI) {
                      rcu_read_lock();
                      sta = ieee80211_find_sta(mac->vif, mac->bssid);
              }
              rtlpriv->cfg->ops->update_rate_tbl(hw, sta,
                                   p_ra->ratr_state);

              p_ra->pre_ratr_state = p_ra->ratr_state;
              if (rtlhal->interface == INTF_PCI)
                      rcu_read_unlock();

Does the warning get output because the code cannot assume that 
rtlhal->interface is the same in both if statements? If that is the case, are 
there any compiler directives that would tell sparse of the situation?

Thanks,

Larry
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: False warning from Sparse
Date: Sun, 22 Jul 2012 04:44:21 +0000
Message-ID: <20120722044421.GA3934 () leaf>
--------------------
On Sat, Jul 21, 2012 at 10:52:54PM -0500, Larry Finger wrote:
> I am getting the following false warning from sparse:
> 
>   CHECK   drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c
> drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c:1158:13: warning:
> context imbalance in 'rtl92c_dm_refresh_rate_adaptive_mask' -
> different lock contexts for basic block
> 
> The only code in that routine that does any locking is the following:
> 
>              /* Only the PCI card uses sta in the update rate table
>               * callback routine */
>              if (rtlhal->interface == INTF_PCI) {
>                      rcu_read_lock();
>                      sta = ieee80211_find_sta(mac->vif, mac->bssid);
>              }
>              rtlpriv->cfg->ops->update_rate_tbl(hw, sta,
>                                   p_ra->ratr_state);
> 
>              p_ra->pre_ratr_state = p_ra->ratr_state;
>              if (rtlhal->interface == INTF_PCI)
>                      rcu_read_unlock();
> 
> Does the warning get output because the code cannot assume that
> rtlhal->interface is the same in both if statements?

Correct; sparse does not have enough dataflow analysis to connect the
two if bodies, nor can it verify that nothing between the two changes
rtlhal->interface.

> If that is the
> case, are there any compiler directives that would tell sparse of
> the situation?

No, none of Sparse's directives will let you override this.  However,
you could do something like the following:

              /* Only the PCI card uses sta in the update rate table
               * callback routine */
              if (rtlhal->interface == INTF_PCI) {
                      rcu_read_lock();
                      sta = ieee80211_find_sta(mac->vif, mac->bssid);
                      rtlpriv->cfg->ops->update_rate_tbl(hw, sta, p_ra->ratr_state);
                      p_ra->pre_ratr_state = p_ra->ratr_state;
                      rcu_read_unlock();
              } else {
                      rtlpriv->cfg->ops->update_rate_tbl(hw, sta, p_ra->ratr_state);
                      p_ra->pre_ratr_state = p_ra->ratr_state;
              }

You could wrap those two lines in a function if you don't want to
duplicate them.

If that solution or a similar refactoring doesn't appeal to you, then
you don't currently have any way of making that context warning go away,
short of improving Sparse to handle this situation better.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Fwd: [problem] sparse llvm loop conditions ===

From: Jonathan =?utf-8?Q?Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: Re: Fwd: [problem] sparse llvm loop conditions
Date: Sun, 19 Aug 2012 19:48:15 +0000
Message-ID: <20120819194815.GA2952 () debian ! debian>
--------------------
On Sun, Aug 19, 2012 at 01:21:23PM -0400, Jeff Garzik wrote:
> Hi Jeff,
> 
> Have you seen this already?
> 
> [penberg@tux sparse]$ cat loop.c
> struct list_node {
> 	struct list_node *next;
> };
> 
> int foo(struct list_node *node)
> {
> 	int ret = 0;
> 	while (node) {
> 		node = node->next;
> 		ret++;
> 	}
> 	return ret;
> }
> [penberg@tux sparse]$ ./sparse-llvm loop.c
> loop.c:5:5: warning: symbol 'foo' was not declared. Should it be static?
> sparse-llvm: Instructions.cpp:730: void llvm::BranchInst::AssertOK():
> Assertion `getCondition()->getType()->isIntegerTy(1) && "May only
> branch on boolean predicates!"' failed.
> Aborted

It doesn't print this particular message anymore, but the llvm
verification detects some other things that could cause problems:

> jonathan@debian:~/dev/sparse/validation$ (../sparse-llvm backend/penberg-loop.c | llvm-dis) 2>&1
> backend/penberg-loop.c:5:5: warning: symbol 'foo' was not declared. Should it be static?
> PHI node operands are not the same type as the result!
>   %phi = phi %list_node* [ %0, %L0 ], [ %load_target, %L2 ]
> Instruction does not dominate all uses!
>   %phi = phi %list_node* [ %0, %L0 ], [ %load_target, %L2 ]
>   %cond = icmp ne %list_node* %phi, null
> Instruction does not dominate all uses!
>   %cond = icmp ne %list_node* %phi, null
>   br i1 %cond, label %L2, label %L3
> Broken module found, verification continues.
> PHI node operands are not the same type as the result!
>   %phi = phi %list_node* [ %0, %L0 ], [ %load_target, %L2 ]
> Instruction does not dominate all uses!
>   %phi = phi %list_node* [ %0, %L0 ], [ %load_target, %L2 ]
>   %cond = icmp ne %list_node* %phi, null
> Instruction does not dominate all uses!
>   %cond = icmp ne %list_node* %phi, null
>   br i1 %cond, label %L2, label %L3
> Broken module found, verification continues.
> Broken module found, verification continues.
> ; ModuleID = '<stdin>'
> 
> %list_node = type { %list_node* }
> 
> define i32 @foo(%list_node*) {
> L0:
>   br label %L1
> 
> L1:                                               ; preds = %L2, %L0
>   %phi = phi %list_node* [ %0, %L0 ], [ %load_target, %L2 ]
>   %phi1 = phi i32 [ 0, %L0 ], [ %R5, %L2 ]
>   %cond = icmp ne %list_node* %phi, null
>   br i1 %cond, label %L2, label %L3
> 
> L2:                                               ; preds = %L1
>   %src_i = ptrtoint %list_node* %phi to i32
>   %addr_i = add i32 %src_i, 0
>   %addr = inttoptr i32 %addr_i to i32*
>   %load_target = load i32* %addr
This load instruction should use %list_node*.
>   %R5 = add i32 %phi1, 1
>   br label %L1
> 
> L3:                                               ; preds = %L1
>   ret i32 %phi1
> }

Jonathan
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jonathan =?utf-8?Q?Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: Re: Fwd: [problem] sparse llvm loop conditions
Date: Sat, 18 May 2013 18:42:03 +0000
Message-ID: <20130518184203.GE3154 () debian ! debian>
--------------------
Hi Jeff, Pekka,

On Sun, Aug 19, 2012 at 01:21:23PM -0400, Jeff Garzik wrote:
> Here is a testcase that should get into the mailing list archives...
> 
> 	Jeff
> 
> 
> 
> 
> -------- Original Message --------
> Subject: [problem] sparse llvm loop conditions
> Date: Wed, 23 Nov 2011 08:56:25 +0200
> From: Pekka Enberg <penberg@kernel.org>
> To: Jeff Garzik <jeff@garzik.org>
> 
> Hi Jeff,
> 
> Have you seen this already?
> 
> [penberg@tux sparse]$ cat loop.c
> struct list_node {
> 	struct list_node *next;
> };
> 
> int foo(struct list_node *node)
> {
> 	int ret = 0;
> 	while (node) {
> 		node = node->next;
> 		ret++;
> 	}
> 	return ret;
> }
> [penberg@tux sparse]$ ./sparse-llvm loop.c
> loop.c:5:5: warning: symbol 'foo' was not declared. Should it be static?
> sparse-llvm: Instructions.cpp:730: void llvm::BranchInst::AssertOK():
> Assertion `getCondition()->getType()->isIntegerTy(1) && "May only
> branch on boolean predicates!"' failed.
> Aborted
> 
>                                 Pekka

With my patchset of today, sparse-llvm compiles this code. It turned out
that struct accesses didn't work, because the address computed for
load/store instructions didn't have the right LLVM type.

[ On a side note, array access doesn't work yet. ]

regards,
Jonathan
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Fwd: dependency tee from c parser entities downto token ===

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 23:38:16 +0000
Message-ID: <4FA5B9E8.7010208 () gmail ! com>
--------------------
This is a multi-part message in MIME format.
--------------030706060204040705080306
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit


>> I'll come up with a patch to implement this scheme when I have
>> time to and send it, it might take a while.
>
> Can you keep the change to the core sparse library (e.g. adding
> hook in parser and pre-processor) as a separate patch? You can
> send that part out for review earlier if other part of your dependency
> analyse is not ready yet.

I appended a diff for review. Is this kind of interface ok?
This is kind of not a patch to apply, rather I want to avoid to put
effort in it and you telling me later I am too intrusive...:). So
can you give a ok or comment...

Interface so far:
struct preprocess_hook {
	def      : called when #define is processed
	args_beg : called before argument expasnion
	args_end : called after argument expasnion
	body_beg : called before body expansion
	body_end : called after body expansion
	post     : called after preprocess
};
All of there I found are needed. There might be more to be added...

I also introduce a tokentype TOKEN_M_EMPTY so that I can track
empty expansion. To filter these out again I add the post hook.

-- Konrad








>
> Chris
>


--------------030706060204040705080306
Content-Type: text/plain; charset=ISO-8859-1;
 name="diff.txt"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="diff.txt"

diff --git a/lib.c b/lib.c
index 396e9f1..554d6c4 100644
--- a/lib.c
+++ b/lib.c
@@ -974,7 +974,8 @@ struct symbol_list * __sparse(char *filename)
 	res = sparse_keep_tokens(filename);
 
 	/* Drop the tokens for this file after parsing */
-	clear_token_alloc();
+	if (!PPHOOKEN())
+		clear_token_alloc();
 
 	/* And return it */
 	return res;
diff --git a/pre-process.c b/pre-process.c
index 8a16f8b..99ee5a4 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -30,6 +30,8 @@
 
 static int false_nesting = 0;
 
+struct preprocess_hook *preprocess_hook = NULL;
+
 #define INCLUDEPATHS 300
 const char *includepath[INCLUDEPATHS+1] = {
 	"",
@@ -74,9 +76,10 @@ static const char **dirafter_includepath = includepath + 3;
 static struct token *alloc_token(struct position *pos)
 {
 	struct token *token = __alloc_token(0);
-
-	token->pos.stream = pos->stream;
-	token->pos.line = pos->line;
+	if (PPHOOKEN()) {
+		token->pos.stream = pos->stream;
+		token->pos.line = pos->line;
+	}
 	token->pos.pos = pos->pos;
 	token->pos.whitespace = 1;
 	return token;
@@ -106,7 +109,7 @@ static void replace_with_integer(struct token *token, unsigned int val)
 	token->number = buf;
 }
 
-static struct symbol *lookup_macro(struct ident *ident)
+struct symbol *lookup_macro(struct ident *ident)
 {
 	struct symbol *sym = lookup_symbol(ident, NS_MACRO | NS_UNDEF);
 	if (sym && sym->namespace != NS_MACRO)
@@ -231,28 +234,17 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position
 		} else if (match_op(next, ',') && !nesting && !vararg) {
 			break;
 		}
-		next->pos.stream = pos->stream;
-		next->pos.line = pos->line;
-		next->pos.pos = pos->pos;
+		if (!PPHOOKEN()) {
+			next->pos.stream = pos->stream;
+			next->pos.line = pos->line;
+			next->pos.pos = pos->pos;
+		}
 		p = &next->next;
 	}
 	*p = &eof_token_entry;
 	return next;
 }
 
-/*
- * We store arglist as <counter> [arg1] <number of uses for arg1> ... eof
- */
-
-struct arg {
-	struct token *arg;
-	struct token *expanded;
-	struct token *str;
-	int n_normal;
-	int n_quoted;
-	int n_str;
-};
-
 static int collect_arguments(struct token *start, struct token *arglist, struct arg *args, struct token *what)
 {
 	int wanted = arglist->count.normal;
@@ -476,6 +468,8 @@ static struct token *dup_token(struct token *token, struct position *streampos,
 {
 	struct token *alloc = alloc_token(streampos);
 	token_type(alloc) = token_type(token);
+	alloc->pos.stream = pos->stream;
+	alloc->pos.line = pos->line;
 	alloc->pos.newline = pos->newline;
 	alloc->pos.whitespace = pos->whitespace;
 	alloc->number = token->number;
@@ -618,13 +612,21 @@ static int expand(struct token **list, struct symbol *sym)
 			return 1;
 		if (!collect_arguments(token->next, sym->arglist, args, token))
 			return 1;
+
+		PPHOOK (args_beg, token, nargs, args);
 		expand_arguments(nargs, args);
+		PPHOOK (args_end, token, nargs, args);
 	}
 
 	expanding->tainted = 1;
 
 	last = token->next;
+
+	PPHOOK (body_beg, token, sym->expansion);
+
 	tail = substitute(list, sym->expansion, args);
+	PPHOOK (body_end, token, list, tail);
+
 	*tail = last;
 
 	return 0;
@@ -893,6 +895,8 @@ static int token_list_different(struct token *list1, struct token *list2)
 			return 0;
 		if (!list1 || !list2)
 			return 1;
+		while(PPHOOKEN() && token_type(list1) == TOKEN_M_EMPTY) list1 = list1->next;
+		while(PPHOOKEN() && token_type(list2) == TOKEN_M_EMPTY) list2 = list2->next;
 		if (token_different(list1, list2))
 			return 1;
 		list1 = list1->next;
@@ -1140,6 +1144,8 @@ static int do_handle_define(struct stream *stream, struct token **line, struct t
 
 	ret = 1;
 	sym = lookup_symbol(name, NS_MACRO | NS_UNDEF);
+	PPHOOK (def, left, &expansion);
+	
 	if (sym) {
 		int clean;
 
@@ -1835,6 +1841,7 @@ struct token * preprocess(struct token *token)
 	preprocessing = 1;
 	init_preprocessor();
 	do_preprocess(&token);
+	PPHOOK(post, &token);
 
 	// Drop all expressions from preprocessing, they're not used any more.
 	// This is not true when we have multiple files, though ;/
diff --git a/token.h b/token.h
index cd29233..0111d23 100644
--- a/token.h
+++ b/token.h
@@ -84,6 +84,7 @@ enum token_type {
 	TOKEN_IF,
 	TOKEN_SKIP_GROUPS,
 	TOKEN_ELSE,
+	TOKEN_M_EMPTY,
 };
 
 /* Combination tokens */
@@ -171,6 +172,32 @@ struct token {
 	};
 };
 
+/*
+ * We store arglist as <counter> [arg1] <number of uses for arg1> ... eof
+ */
+
+struct arg {
+	struct token *arg;
+	struct token *expanded;
+	struct token *str;
+	int n_normal;
+	int n_quoted;
+	int n_str;
+};
+
+struct preprocess_hook {
+	void (*def)(struct token *macro, struct token **ex);
+	void (*args_beg)(struct token *macro, int count, struct arg *a);
+	void (*args_end)(struct token *macro, int count, struct arg *a);
+	void (*body_beg)(struct token *macro, struct token *body);
+	void (*body_end)(struct token *macro, struct token **rep, struct token **reptail);
+	void (*post)(struct token **token);
+	
+	
+};
+#define PPHOOK(n, args... ) if (preprocess_hook && preprocess_hook->n) preprocess_hook->n( args );
+#define PPHOOKEN() (preprocess_hook != 0) 
+
 #define MAX_STRING 4095
 
 static inline struct token *containing_token(struct token **p)
@@ -188,7 +215,9 @@ static inline struct token *containing_token(struct token **p)
  */
 extern struct token eof_token_entry;
 #define eof_token(x) ((x) == &eof_token_entry)
+extern struct preprocess_hook *preprocess_hook;
 
+extern struct symbol *lookup_macro(struct ident *ident);
 extern int init_stream(const char *, int fd, const char **next_path);
 extern const char *stream_name(int stream);
 extern struct ident *hash_ident(struct ident *);

--------------030706060204040705080306--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Sun, 06 May 2012 18:34:34 +0000
Message-ID: <CANeU7Qm-M7u0h6MswEMw3KZ7wxaxiikpChXJAuhkV0EzcHkH9A () mail ! gmail ! com>
--------------------
On Sat, May 5, 2012 at 4:38 PM, Konrad Eisele <eiselekd@gmail.com> wrote:
>
> I appended a diff for review. Is this kind of interface ok?
> This is kind of not a patch to apply, rather I want to avoid to put
> effort in it and you telling me later I am too intrusive...:). So
> can you give a ok or comment...
>
> Interface so far:
> struct preprocess_hook {
>        def      : called when #define is processed

Why do you need #define hooks? The macro symbol
should have pos and macro body already.

>        args_beg : called before argument expasnion
>        args_end : called after argument expasnion
>        body_beg : called before body expansion
>        body_end : called after body expansion

I am wondering why is do you need 4 call backs for macro
expand instead of just one like the patch I post previously.
That macro expand give you the name of the macro need to
be expand and the replacement list.  My guess is that you
want the end position of the macro before expand. That
can be add to the macro expand hook. Will that be sufficient?


>        post     : called after preprocess

I don't think the post call back is needed. You can call
the preprocessor directly. It will return when it complete.
Then you can do your post work. You can invoke the parser
separately.  The sparse wrapper function does it all in
one function but that did not stop you it step by step
if you wants to.


> All of there I found are needed. There might be more to be added...
>
> I also introduce a tokentype TOKEN_M_EMPTY so that I can track
> empty expansion. To filter these out again I add the post hook.

What purpose does the token_m_empty if you filter those token later?
Rember where in the stream there is an invisible macro?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Mon, 07 May 2012 06:12:13 +0000
Message-ID: <4FA767BD.8060703 () gaisler ! com>
--------------------
Christopher Li wrote:
> On Sat, May 5, 2012 at 4:38 PM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>>
>> I appended a diff for review. Is this kind of interface ok?
>> This is kind of not a patch to apply, rather I want to avoid to put
>> effort in it and you telling me later I am too intrusive...:). So
>> can you give a ok or comment...
>>
>> Interface so far:
>> struct preprocess_hook {
>>         def      : called when #define is processed
>
> Why do you need #define hooks? The macro symbol
> should have pos and macro body already.

I need to hook to insert a TOKEN_M_EMPTY into the substitution body
if the define is an empty define. The "post" hook is then used to
remove all TOKEN_M_EMPTY again after the preprocessing (or rather
to save it internally).

>
>>         args_beg : called before argument expasnion
>>         args_end : called after argument expasnion
>>         body_beg : called before body expansion
>>         body_end : called after body expansion
>
> I am wondering why is do you need 4 call backs for macro
> expand instead of just one like the patch I post previously.
> That macro expand give you the name of the macro need to
> be expand and the replacement list.  My guess is that you
> want the end position of the macro before expand. That
> can be add to the macro expand hook. Will that be sufficient?

I want to trace the complete macro substitution. Using a before-after
hook for both body and arg I can reconstruct what is done in the
expand (Not just dependencies but the whole of expand).


>
>
>>         post     : called after preprocess
>
> I don't think the post call back is needed. You can call
> the preprocessor directly. It will return when it complete.
> Then you can do your post work. You can invoke the parser
> separately.  The sparse wrapper function does it all in
> one function but that did not stop you it step by step
> if you wants to.

See above. I need the post to filter out the helper TOKEN_M_EMPTY.

>
>
>> All of there I found are needed. There might be more to be added...
>>
>> I also introduce a tokentype TOKEN_M_EMPTY so that I can track
>> empty expansion. To filter these out again I add the post hook.
>
> What purpose does the token_m_empty if you filter those token later?
> Rember where in the stream there is an invisible macro?

See above. I use it as a placeholder. The "post" hook saves the information
then and removes the token again.




>
> Chris
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Mon, 07 May 2012 22:06:49 +0000
Message-ID: <CANeU7Q=nHs+f1wKVM0bGDc-uxubBztPxXjiMvDRpph4RJWPHYg () mail ! gmail ! com>
--------------------
Hi Konrad,

I appreciate all the input. How about this, I am going to implement
the core sparse
part of the API change. You will be the first customer that use that
API. I think this
API is also useful for people want to do source code transformations
using sparse.
They usually want to manipulate the source code stream before the
pre-processing.

Anyway, I am hacking a branch starting from the last patch I send out.
I am adding the test program to demonstrate how to use those hooks to accomplish
different things. You just need to keep telling me what extra feature
you want from
the API. I can try to incorporate them with the demo program.

I will let you know when I have the branch ready.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Wed, 09 May 2012 09:18:56 +0000
Message-ID: <CANeU7QkLrr1p8-Bofx9fnZ82BA2pc7sOxSOa-zim5NhWHXTNQA () mail ! gmail ! com>
--------------------
On Mon, May 7, 2012 at 11:38 PM, Konrad Eisele <konrad@gaisler.com> wrote:
>
> Yea, I think it is better that way. You should implement it yourself first,
> it kind of takes too long otherwise :-). Still I'm kind of
> curious how you can trace macro expansion with just 1 callback
> but I'll like to be surprised.

OK, there is the initial version of the preprocessor hook.
I create an branch "unclean-preprocess-hook" for review.

http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=shortlog;h=refs/heads/unclean-preprocess-hook

I end up use more than one call back, but it is still better that 6.
I also think that is easier for the caller to use. because it receive the
the before and after at the same time.


struct preprocess_hook {
	void (*expand_macro)(struct token *macro, struct symbol *sym,
			     struct token **replace, struct token **replace_tail);
	void (*expand_arg)(struct token *macro, struct symbol *sym, int arg,
			   struct token *orig, struct token *expanded);
};

The demo program expand your example macro with the following
results:

<beginning of 't.c'>
#define D0(d0a0,d0a1) 1 D1(d0a0) 2 D2(d0a1) 3
#define D1(d1a0) 4 d1a0 5
#define D2(d2a0) 6 d2a0 7
#define D3(d3a0) 8 d3a0 9
D0(D3(10),11)<end of 't.c'>
arg0 in D3 :10 -> 10
macro D3 inside D0
expand result: 8 10 9 <untaint: D3>
arg0 in D0 :D3(10) -> 8 10 9
arg1 in D0 :11 -> 11
macro D0 inside <noident>
expand result: 1 D1(8 10 9) 2 D2(11) 3 <untaint: D0>
arg0 in D1 :8 10 9 -> 8 10 9
macro D1 inside D0
expand result: 4 8 10 9 5 <untaint: D1>
arg0 in D2 :11 -> 11
macro D2 inside D0
expand result: 6 11 7 <untaint: D2>
After preprocessing
1 4 8 10 9 5 2 6 11 7 3

A few things. I don't think you need to manipulate the define for empty
body macro any more. You should be able to find out the macro expand
to empty in the hook.

I still haven't fully understand why you need the empty token type. However
there is the untaint token which mark the end of the a macro expand. You
might able to use that as well.

This branch needs cleanup before merge to the upstream.
Please let me know what I miss.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Wed, 09 May 2012 22:50:00 +0000
Message-ID: <CANeU7Q=mq1FsGViTp7L-83Wns6uDLcRKi7usNRiO1D3Ox_Dmww () mail ! gmail ! com>
--------------------
On Wed, May 9, 2012 at 2:48 AM, Konrad Eisele <konrad@gaisler.com> wrote:
> I dont think its practical: If you have a argument that is expanded then
> when using 4 callbacks you get the calls:
>
>  arg-expand-begin(a)
>    body-expand-begin(c)
>    body-expand-end(d)
>  arg-expand-end(b)
>
> When using 2 callbacks you get the calls:
>
>    body-expand(c d)
>  arg-expand-begin(a b)
>
> But "a" is the source to both "c" and "d". The goal of all this is to
> generate a tree. You need to know where a token originated from. The
> tokens in "a" might be duplicated, then in your case you dont have
> enough information to reason about the origin of "c".

I was thinking that you can use the sym->parent to find out you are inside
which macro's scope. If I change the sym->parent to the token type, which
is the token initiated the macro expand. Then you should have all the
information
you need?


> I do it like this: Inside
> arg-expand-begin(a) I "dope" all tokens of "a" by setting
> token.pos.position (which I understood I can use as I want)
> with an unique id (token.pos.stream is my preprocessor stream). When a
> token is duplicated in argument replacement etc. token.pos will also
> be copied. The duplicates of "a" will always retain information where
> they came from.
> Then I can regenerate the tree.

Right, you can still do the the duping with expand_macro call back.

>T think you need to implement this first so that I can see how it could
> be done...

That will take more time. I am hoping you can point out what is missing
in the demo program. Which you did already.

>> I still haven't fully understand why you need the empty token type.
>> However
>> there is the untaint token which mark the end of the a macro expand. You
>> might able to use that as well.
>
>
> I dont think you can, not without patching preprocess.c. And the patching
> would be messier than by introducing a dedicated token.
> Also: TOKEN_M_EMPTY is only used by the hook, it is also
>  removed afterwards

I can only guess how to TOKEN_M_EMPTY in the call back. I only
see the code add into into the stream and removed, not how the client
use it.

Here is another idea. Instead of require the client to register a lot of
callback function. We can have option to insert macro expand annotation token
into the token stream. The annotation token mark the beginning and end of the
macro expansion. In the macro begin annotation, it will preserve the
original stream
before the expansion. Similarly, there will be begin and end
annotation for the argument
replacement.

The client can do a custom pass to consume the annotation token. It should
be able to build the patch tree that lead to the expansion result. The
annotation
token will be consume and removed from the token stream before it get pass to
the parser.

In this way, no call back is required. It is all data structures. The
comments of
the source code can fit nicely into the annotation token as well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Thu, 10 May 2012 06:19:22 +0000
Message-ID: <4FAB5DEA.5060009 () gaisler ! com>
--------------------
Christopher Li wrote:
> On Wed, May 9, 2012 at 2:48 AM, Konrad Eisele<konrad@gaisler.com>  wrote:
>> I dont think its practical: If you have a argument that is expanded then
>> when using 4 callbacks you get the calls:
>>
>>   arg-expand-begin(a)
>>     body-expand-begin(c)
>>     body-expand-end(d)
>>   arg-expand-end(b)
>>
>> When using 2 callbacks you get the calls:
>>
>>     body-expand(c d)
>>   arg-expand-begin(a b)
>>
>> But "a" is the source to both "c" and "d". The goal of all this is to
>> generate a tree. You need to know where a token originated from. The
>> tokens in "a" might be duplicated, then in your case you dont have
>> enough information to reason about the origin of "c".
>
> I was thinking that you can use the sym->parent to find out you are inside
> which macro's scope. If I change the sym->parent to the token type, which
> is the token initiated the macro expand. Then you should have all the
> information
> you need?

You dont get the point. Is there a pointer token.parent? No. How can
you know which macro expansion you _came from_, you only know
where you _end up_. How can you build the _branches_ of a tree? You can
only build _leafs_.
Funny thing is: When you _are_ a commiter you _can_ suddenly add
"sym.parent" when you think it is necessary? All this mess is originally
because you dont think that sym.token can replace sym.position...
Wasnt adding new members a sin ? I guess it actually doesnt matter,
if you are a committer ...:-)

>
>
>> I do it like this: Inside
>> arg-expand-begin(a) I "dope" all tokens of "a" by setting
>> token.pos.position (which I understood I can use as I want)
>> with an unique id (token.pos.stream is my preprocessor stream). When a
>> token is duplicated in argument replacement etc. token.pos will also
>> be copied. The duplicates of "a" will always retain information where
>> they came from.
>> Then I can regenerate the tree.
>
> Right, you can still do the the duping with expand_macro call back.
>
>> T think you need to implement this first so that I can see how it could
>> be done...
>
> That will take more time. I am hoping you can point out what is missing
> in the demo program. Which you did already.

Apply my latest patch any you'll see.

Also: I dont see that you do anything with token.pos. Dont
you remember that you came up with token.pos encoding to avoid adding
a new member to token that my original patch did?
In the last patch I sent this idea is used, as described, I write
an unique id to token.pos.position that then shows the origin...
You seem to have forgotten what we started from.

>
>>> I still haven't fully understand why you need the empty token type.
>>> However
>>> there is the untaint token which mark the end of the a macro expand. You
>>> might able to use that as well.
>>
>>
>> I dont think you can, not without patching preprocess.c. And the patching
>> would be messier than by introducing a dedicated token.
>> Also: TOKEN_M_EMPTY is only used by the hook, it is also
>>   removed afterwards
>
> I can only guess how to TOKEN_M_EMPTY in the call back. I only
> see the code add into into the stream and removed, not how the client
> use it.
>
> Here is another idea. Instead of require the client to register a lot of
> callback function. We can have option to insert macro expand annotation token
> into the token stream. The annotation token mark the beginning and end of the
> macro expansion. In the macro begin annotation, it will preserve the
> original stream
> before the expansion. Similarly, there will be begin and end
> annotation for the argument
> replacement.

This is all the same thing. It doenst matter how, just implement it.
I dont understand: Here you think you can patch 1000 lines in the
original code (which your new idea  would requite ) however you
insist of 2 callbacks (callbacks that normal code would ignore anyway)
because you dont want to grant me 4 extra lines (the begin-end hooks+define+post).
This is greedy at least, I dont get it, I think I'm out of here...

>
> The client can do a custom pass to consume the annotation token. It should
> be able to build the patch tree that lead to the expansion result. The
> annotation
> token will be consume and removed from the token stream before it get pass to
> the parser.

Have fun implementing it :-)
-- Konrad

>
> In this way, no call back is required. It is all data structures. The
> comments of
> the source code can fit nicely into the annotation token as well.
>
> Chris
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Thu, 10 May 2012 06:38:32 +0000
Message-ID: <4FAB6268.7070908 () gaisler ! com>
--------------------
Konrad Eisele wrote:
> Christopher Li wrote:
>> On Wed, May 9, 2012 at 2:48 AM, Konrad Eisele<konrad@gaisler.com> wrote:
>>> I dont think its practical: If you have a argument that is expanded then
>>> when using 4 callbacks you get the calls:
>>>
>>> arg-expand-begin(a)
>>> body-expand-begin(c)
>>> body-expand-end(d)
>>> arg-expand-end(b)
>>>
>>> When using 2 callbacks you get the calls:
>>>
>>> body-expand(c d)
>>> arg-expand-begin(a b)
>>>
>>> But "a" is the source to both "c" and "d". The goal of all this is to
>>> generate a tree. You need to know where a token originated from. The
>>> tokens in "a" might be duplicated, then in your case you dont have
>>> enough information to reason about the origin of "c".
>>
>> I was thinking that you can use the sym->parent to find out you are inside
>> which macro's scope. If I change the sym->parent to the token type, which
>> is the token initiated the macro expand. Then you should have all the
>> information
>> you need?
>
> You dont get the point. Is there a pointer token.parent? No. How can
> you know which macro expansion you _came from_, you only know
> where you _end up_. How can you build the _branches_ of a tree? You can
> only build _leafs_.
> Funny thing is: When you _are_ a commiter you _can_ suddenly add
> "sym.parent" when you think it is necessary? All this mess is originally
> because you dont think that sym.token can replace sym.position...
> Wasnt adding new members a sin ? I guess it actually doesnt matter,
> if you are a committer ...:-)
>
>>
>>
>>> I do it like this: Inside
>>> arg-expand-begin(a) I "dope" all tokens of "a" by setting
>>> token.pos.position (which I understood I can use as I want)
>>> with an unique id (token.pos.stream is my preprocessor stream). When a
>>> token is duplicated in argument replacement etc. token.pos will also
>>> be copied. The duplicates of "a" will always retain information where
>>> they came from.
>>> Then I can regenerate the tree.
>>
>> Right, you can still do the the duping with expand_macro call back.
>>
>>> T think you need to implement this first so that I can see how it could
>>> be done...
>>
>> That will take more time. I am hoping you can point out what is missing
>> in the demo program. Which you did already.
>
> Apply my latest patch any you'll see.
>
> Also: I dont see that you do anything with token.pos. Dont
> you remember that you came up with token.pos encoding to avoid adding
> a new member to token that my original patch did?
> In the last patch I sent this idea is used, as described, I write
> an unique id to token.pos.position that then shows the origin...
> You seem to have forgotten what we started from.
>
>>
>>>> I still haven't fully understand why you need the empty token type.
>>>> However
>>>> there is the untaint token which mark the end of the a macro expand. You
>>>> might able to use that as well.
>>>
>>>
>>> I dont think you can, not without patching preprocess.c. And the patching
>>> would be messier than by introducing a dedicated token.
>>> Also: TOKEN_M_EMPTY is only used by the hook, it is also
>>> removed afterwards
>>
>> I can only guess how to TOKEN_M_EMPTY in the call back. I only
>> see the code add into into the stream and removed, not how the client
>> use it.
>>
>> Here is another idea. Instead of require the client to register a lot of
>> callback function. We can have option to insert macro expand annotation token
>> into the token stream. The annotation token mark the beginning and end of the
>> macro expansion. In the macro begin annotation, it will preserve the
>> original stream
>> before the expansion. Similarly, there will be begin and end
>> annotation for the argument
>> replacement.
>
> This is all the same thing. It doenst matter how, just implement it.
> I dont understand: Here you think you can patch 1000 lines in the
> original code (which your new idea would requite ) however you
> insist of 2 callbacks (callbacks that normal code would ignore anyway)
> because you dont want to grant me 4 extra lines (the begin-end hooks+define+post).
> This is greedy at least, I dont get it, I think I'm out of here...
>
>>
>> The client can do a custom pass to consume the annotation token. It should
>> be able to build the patch tree that lead to the expansion result. The
>> annotation
>> token will be consume and removed from the token stream before it get pass to
>> the parser.

Reading it 2 times and thinking about what kind of thought
drive you: I can only say this is fucking sick:
You oppose adding one little TOKEN_M_EMPTY, now you use my idea
to add 100 new tokens and yeah ... Hello, hello ... How can
you filter them out : You _cannot_ add a "post" hook. :-) Haha...

>
> Have fun implementing it :-)
> -- Konrad
>
>>
>> In this way, no call back is required. It is all data structures. The
>> comments of
>> the source code can fit nicely into the annotation token as well.
>>
>> Chris
>> --
>> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
>> the body of a message to majordomo@vger.kernel.org
>> More majordomo info at http://vger.kernel.org/majordomo-info.html
>>
>>
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at http://vger.kernel.org/majordomo-info.html
>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Thu, 10 May 2012 09:03:30 +0000
Message-ID: <CANeU7QmtKdiF2ZGYXHr1Ti2EYHQMp9yXcn5BkTTE3MisZ1i1gg () mail ! gmail ! com>
--------------------
On Wed, May 9, 2012 at 11:19 PM, Konrad Eisele <konrad@gaisler.com> wrote:
>> I was thinking that you can use the sym->parent to find out you are inside
>> which macro's scope. If I change the sym->parent to the token type, which
>> is the token initiated the macro expand. Then you should have all the
>> information
>> you need?
> You dont get the point. Is there a pointer token.parent? No. How can
> you know which macro expansion you _came from_, you only know

Did you look at my patch? It save the top level expanding macro in
parent variable and the macro expansion active maintains it.
e.g. When you enter the macro, it save the current macro in parent.
When you exit the macro during untainted, it will pop it from the
symbol->parent.

So during the macro expansion. It does remember the upper level
macro and the macro above that all the way to the outside the macro
expand. Where parent will be NULL. My test program demo part of it.

> where you _end up_. How can you build the _branches_ of a tree? You can
> only build _leafs_.
> Funny thing is: When you _are_ a commiter you _can_ suddenly add
> "sym.parent" when you think it is necessary? All this mess is originally
> because you dont think that sym.token can replace sym.position...

Please. Sparse carefully separate out the token from the AST is by
design. So it does not need to carry the token baggage in the later part
of the AST processing. That is a design and I want to keep it. It make
the program run faster as well because it reduce the compiler foot print.

> Wasnt adding new members a sin ? I guess it actually doesnt matter,
> if you are a committer ...:-)

Well, in case you did not notice. The place I add it is part of a union
in side symbol. It will not expand the size of the symbol at all. Other
part of the sparse use similar tricks. There is no extra memory expansion
for that.

It is not about I am the committer so I can do what I want. I did not
commit my branch into the official repository do I? Why do you think
I name the branch "unclean-xxxxx". It is putting it out for review just
like your patches. So that I can receive critic comment like yours.
The goal is find out the better way to incorporate this feature without
much negative  on other clients of sparse. e.g. your patch using
token replacing pos will have such negative impact on other sparse
client that don't care about the macro expand history.


> Also: I dont see that you do anything with token.pos. Dont
> you remember that you came up with token.pos encoding to avoid adding
> a new member to token that my original patch did?
> In the last patch I sent this idea is used, as described, I write
> an unique id to token.pos.position that then shows the origin...
> You seem to have forgotten what we started from.

Of course I remember. That trick is done in the call back. In the client
of the sparse library. I am currently focus on getting the right change for
the core sparse library. Think sparse as a library.
There are many client that use this library. The sparse checker, ctags
and sparse-llvm are all client of the sparse library.

I am trying to get the library support your dependency analyse without
much negative impact of other client of sparse. Your patch is clear
focus on getting your program to run. I have more constrains to consider.

> This is all the same thing. It doenst matter how, just implement it.

It doesn't matter to you. But the detail matters to me.

> I dont understand: Here you think you can patch 1000 lines in the
> original code (which your new idea  would requite ) however you
> insist of 2 callbacks (callbacks that normal code would ignore anyway)
> because you dont want to grant me 4 extra lines (the begin-end
> hooks+define+post).
> This is greedy at least, I dont get it, I think I'm out of here...

A change like that clearly needs more discussion and review
process for feed back. My own patches will need to go through the
same thing. And that is what I am doing.

I am sorry. I understand your frustration trying submit a patch
but haven't able to get it in as early as you hope. I am also
frustrated because I haven't found the clean enough way to
support it. That is why I am having discuss with you to work
it through.

Keeping the project clean and provide review feed backs is
just one of the roles of the maintainer, including rejecting patches
at times.

The question I concern most is weather that is the right thing
to do. A 6 call back API is obvious more complex than a 2 call
back. No call back is obvious simpler than 2 call back. It is just
part of the quest for finding the right interface.

There is no need for such negative attitude.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Thu, 10 May 2012 09:37:09 +0000
Message-ID: <CANeU7Qk-DTs+WL=u2g5WQ1L2J++ZBkCHi8_85bmUWto7rq0-9Q () mail ! gmail ! com>
--------------------
On Wed, May 9, 2012 at 11:38 PM, Konrad Eisele <konrad@gaisler.com> wrote:
>>> The client can do a custom pass to consume the annotation token. It
>>> should
>>> be able to build the patch tree that lead to the expansion result. The
>>> annotation
>>> token will be consume and removed from the token stream before it get
>>> pass to
>>> the parser.
>
>
> Reading it 2 times and thinking about what kind of thought
> drive you: I can only say this is fucking sick:
> You oppose adding one little TOKEN_M_EMPTY, now you use my idea
> to add 100 new tokens and yeah ... Hello, hello ... How can
> you filter them out : You _cannot_ add a "post" hook. :-) Haha...


I only request some clarification on how you use
the TOKEN_M_EMPTY in the call back. Which you don't care to explain.

It is clear that I consider no call back is better than 2 call back, which
is better than 6 call back. I am not too worry about changing internals
of parse, as long as it is "do the right thing".

Where do you get the idea you can't do custom filtering without
a "post" hook? I already explain to you in previous email
you can call preprocessor and parser step by step yourself.


        token = tokenize(filename, fd, NULL, includepath);
	token = preprocess(token);
        token = my_custom_filter(token);
        while (!eof_token(token))
		token = external_declaration(token, &translation_unit_used_list);

Do I need to use your post hook? No.

You doesn't want to listen.

I have nothing against you. It is pure technical merit I am evaluating.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Thu, 10 May 2012 11:25:05 +0000
Message-ID: <CANeU7QnnXk26ybnayuRZ2ZGSArMt1Bne4KGXxt+0d7tBjN=6Kw () mail ! gmail ! com>
--------------------
On Thu, May 10, 2012 at 2:51 AM, Konrad Eisele <konrad@gaisler.com> wrote:
>
> You didnt get it. The "_cannot_" was ironic. There is always
> a way you can fit things. The point is you want to implement it
> yourself, exaclty the way you think it should be done, then do it.
> I've nothing to contribute.
> I've also nothing against you personally, only against this
> ping pong emailing. It takes too much time.

Well, the __cannot__ part is base on your reply you seems don't
wish to continue this discussion.

A change like this is bound to need some careful discussion and
planing. Yes, I am guilt of only accepting patches meet some subjective
stander of mine. But so is to any self respect project maintainers.
I would rather spend some time to do it right than commit some thing
I would regret later on.

I heard you that this discussion is taking long. That is why I offer
to write up the core sparse part of the change myself and let you
provide feed back to shape it the way we both can happy.
That is the agreement we have earlier right?

So I did exactly what I said I am going to do, now you are calling
me my way vs your way?

My evaluation function is straightly technical merit:

- I prefer patch minimize performance impact on other clients don't
use this feature.
- I prefer simpler interface over complicate one.

To me, believe it or not, It is never about my way vs your way.
If you submit a perfect patch, I would more than happy to apply it.
Apply a patch is much easier than writing one myself.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Thu, 10 May 2012 12:14:42 +0000
Message-ID: <4FABB132.1070308 () gmail ! com>
--------------------
On 05/10/2012 01:25 PM, Christopher Li wrote:
> On Thu, May 10, 2012 at 2:51 AM, Konrad Eisele<konrad@gaisler.com>  wrote:
>>
>> You didnt get it. The "_cannot_" was ironic. There is always
>> a way you can fit things. The point is you want to implement it
>> yourself, exaclty the way you think it should be done, then do it.
>> I've nothing to contribute.
>> I've also nothing against you personally, only against this
>> ping pong emailing. It takes too much time.
>
> Well, the __cannot__ part is base on your reply you seems don't
> wish to continue this discussion.
>
> A change like this is bound to need some careful discussion and
> planing. Yes, I am guilt of only accepting patches meet some subjective
> stander of mine. But so is to any self respect project maintainers.
> I would rather spend some time to do it right than commit some thing
> I would regret later on.

Do a B(B(x)) and your sym->parent linked-list will fail.
-- Konrad

>
> I heard you that this discussion is taking long. That is why I offer
> to write up the core sparse part of the change myself and let you
> provide feed back to shape it the way we both can happy.
> That is the agreement we have earlier right?
>
> So I did exactly what I said I am going to do, now you are calling
> me my way vs your way?
>
> My evaluation function is straightly technical merit:
>
> - I prefer patch minimize performance impact on other clients don't
> use this feature.
> - I prefer simpler interface over complicate one.
>
> To me, believe it or not, It is never about my way vs your way.
> If you submit a perfect patch, I would more than happy to apply it.
> Apply a patch is much easier than writing one myself.
>
> Chris
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Thu, 10 May 2012 12:28:23 +0000
Message-ID: <4FABB467.7030703 () gmail ! com>
--------------------

>> A change like this is bound to need some careful discussion and
>> planing. Yes, I am guilt of only accepting patches meet some subjective
>> stander of mine. But so is to any self respect project maintainers.
>> I would rather spend some time to do it right than commit some thing
>> I would regret later on.
>
> Do a B(B(x)) and your sym->parent linked-list will fail.
> -- Konrad

I have to revise my previous assumption though:

#define B(y) A(x)
B(1)

i thought that in the body expansion of B recursion is involved,
so that it would yield:

   expand_macro(A);
expand_macro(B);

but that was wrong, so its

expand_macro(B);
expand_macro(A);

you might be right here. expand() is flat when substituting
the body part of the macro. It might work.

-- Konrad

>
>>
>> I heard you that this discussion is taking long. That is why I offer
>> to write up the core sparse part of the change myself and let you
>> provide feed back to shape it the way we both can happy.
>> That is the agreement we have earlier right?
>>
>> So I did exactly what I said I am going to do, now you are calling
>> me my way vs your way?
>>
>> My evaluation function is straightly technical merit:
>>
>> - I prefer patch minimize performance impact on other clients don't
>> use this feature.
>> - I prefer simpler interface over complicate one.
>>
>> To me, believe it or not, It is never about my way vs your way.
>> If you submit a perfect patch, I would more than happy to apply it.
>> Apply a patch is much easier than writing one myself.
>>
>> Chris
>>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Fri, 11 May 2012 19:40:57 +0000
Message-ID: <CANeU7Q=_uqwk+ePbErQ9gsX3x945_gATUZ_mJeYuTo2SoYhCpQ () mail ! gmail ! com>
--------------------
On Thu, May 10, 2012 at 5:28 AM, Konrad Eisele <eiselekd@gmail.com> wrote:
>
>>> A change like this is bound to need some careful discussion and
>>> planing. Yes, I am guilt of only accepting patches meet some subjective
>>> stander of mine. But so is to any self respect project maintainers.
>>> I would rather spend some time to do it right than commit some thing
>>> I would regret later on.
>>
>>
>> Do a B(B(x)) and your sym->parent linked-list will fail.

You have a valid point that B(B(x)) will break the sym->parent list.
I remove the sym->parent and just use a token_list to maintain the
expanding macro. The macro is append to the list when enter and remove
from the list when untaint token is reached. The change is in the
same review branch.

That should solve this problem?

> I have to revise my previous assumption though:
>
> #define B(y) A(x)
> B(1)
>
> i thought that in the body expansion of B recursion is involved,
> so that it would yield:
>
>  expand_macro(A);
> expand_macro(B);
>
> but that was wrong, so its
>
> expand_macro(B);
> expand_macro(A);

That is right. The macro expansion has 3 stages. The first stage is
expand the arguments list while the caller macro does not consider
"tainted" during the argument expansion. The macro can recursively
appear in the argument list. That is some thing I haven't consider
previously.

The second stage is just replace the expanded arguments into body.

The third stage is rescan the replacement string for macro expand.
In this third stage, the macro itself is consider tainted and can't be
expand again during the rescan.

Can you take a look at this modify version will fit your need or not?
I am curious the part weather that will remove the need to add
empty token to the list for expansion.

In order words, can we design the API clever enough that you
don't need to jump through hoops to handle the empty expansion
token.

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Sat, 12 May 2012 11:02:17 +0000
Message-ID: <CANeU7QnEyUExcxaoVEeamhu1m+Z_pg0TpKBP00hh+gyPgdq66w () mail ! gmail ! com>
--------------------
On Fri, May 11, 2012 at 2:48 PM, Konrad Eisele <eiselekd@gmail.com> wrote:
>
> This seems ok. expanding_macro has to be global not static to be
> used... (?)

The expand_macro call back use the parent argument which get
from expanding_macro list. The caller should be able to create tree
from the leaf node using the parent pointer.

Feel free to change to use the expanding_macro instead if that make
building the tree easier.

> I think the fact that argument expansion is recursive and
> body expansion is non-recursive is one of the things that
> make the preprocessor kindof hard to grasp.

The body expansion can't be recursive on same macro  otherwise
it can result in unlimited expansion. The C stander specify
the macro expand this way.

>
> I cannot say this before I've tried it.
>
> I'd like to straighten things out a bit: My last emails
> where a bit too harsh and I'd like to apologize. Sorry
> for that.

No problem at all. I figure you just want to the patch to
get included.

> The next step then is: I'll write a patch to add a
> test-prog that uses this api to trace the token generation
> and generate a tree for it.
> For a start I'll printout for all tokens of a preprocessor
> run all macros-expansions that generated them.

That is great. I have a test-macro program in that
branch which is very close to print out all the tokens.

> Now, I've learned not to run too fast towards the
> goal, (which is still "dependency tee from c parser entities downto
> token"), maybe you can think about how to achieve the next steps
> in an API :
> - An #include #ifdef #else #endif pushdown-stack
>  to record the nestings for each token

Let me think about this. Just thinking out lound,
The #include and #ifdef can consider as a special kind
of predefine macro as well.

> - How to connect all this to the AST.

For symbol, it relative easy because symbol has pos range
and aux pointer.

Do you need to attach the dependency for the statment and
expression as well?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Sat, 12 May 2012 17:46:48 +0000
Message-ID: <4FAEA208.3090601 () gmail ! com>
--------------------
This is a multi-part message in MIME format.
--------------020101020406000100050005
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

On 05/12/2012 01:02 PM, Christopher Li wrote:
> On Fri, May 11, 2012 at 2:48 PM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>>
>> This seems ok. expanding_macro has to be global not static to be
>> used... (?)
>
> The expand_macro call back use the parent argument which get
> from expanding_macro list. The caller should be able to create tree
> from the leaf node using the parent pointer.
>
> Feel free to change to use the expanding_macro instead if that make
> building the tree easier.
>
>> I think the fact that argument expansion is recursive and
>> body expansion is non-recursive is one of the things that
>> make the preprocessor kindof hard to grasp.
>
> The body expansion can't be recursive on same macro  otherwise
> it can result in unlimited expansion. The C stander specify
> the macro expand this way.
>
>>
>> I cannot say this before I've tried it.
>>
>> I'd like to straighten things out a bit: My last emails
>> where a bit too harsh and I'd like to apologize. Sorry
>> for that.
>
> No problem at all. I figure you just want to the patch to
> get included.
>
>> The next step then is: I'll write a patch to add a
>> test-prog that uses this api to trace the token generation
>> and generate a tree for it.
>> For a start I'll printout for all tokens of a preprocessor
>> run all macros-expansions that generated them.
>
> That is great. I have a test-macro program in that
> branch which is very close to print out all the tokens.

Appended is a test-patch that adds test-mdep testcase.
The file mdep.c is used to record that macro
expansion, each token will have a reference to its
source.
test-mdep.c does pre-process (as test-macro.c) then
prints out the token trace through macros for each
token: @{ } is used to mark the active path.

An example file is added: a.h
$test-mdep a.h
...
0004: 8
      body in D1 :4 @{8} 10 9 5 <untaint: D1>
      arg0 in D1 :@{8} 10 9
      body in D0 :1 @{D1}(8 10 9) 2 D2(11) 3 <untaint: D0>
      a.h:6:6
...
Token nr 4 of the preprocess stream is "8". The
generation path of "8" is marked @{8}...
Not 100%, still, I think already readable. (Actually
the printout order should be reversed (starting from file scope
and drilling down the macro expansions...)

I still dont handle empty expansions. I'll see weather I can come up 
with something here...


>
>> Now, I've learned not to run too fast towards the
>> goal, (which is still "dependency tee from c parser entities downto
>> token"), maybe you can think about how to achieve the next steps
>> in an API :
>> - An #include #ifdef #else #endif pushdown-stack
>>   to record the nestings for each token
>
> Let me think about this. Just thinking out lound,
> The #include and #ifdef can consider as a special kind
> of predefine macro as well.

No, only a linked list that model the nexting levels.
Then a preprocessor hook that can register lookup_macro()
macro lookups inside # preprocessor lines. An example
makes it clear:

#if defined(a) && defined(b)
#if defined(c)
#endif
#if defined(e)
#endif
#endif

Result in:
[a b]+<-[c]
      +<-[e]

This can be easily done with a push-pop brackets
and a callback in lookup_macro().


Also:
#if defined(a)
#elif defined(c)
#endif

[a]+<-[c]

#if defined(a)
#else
#endif

<-[empty]<-[a]

...


Another point I also need is to have an option so that inside
do_handle_define() the symbol structures are never reused but
alloc_symbol() is always used for undef and define, this is
because I need to be able to also track the undef and define
history for a macro at a certain position. I think this should be
easy to add because you just need to define define-undef on
top of each other...


>
>> - How to connect all this to the AST.
>
> For symbol, it relative easy because symbol has pos range
> and aux pointer.

I thought about taking "struct symbol_list *syms = sparse(file)"
as the root. Then mark all elements that are used by them as dependent.
I dont have enough insight to say how I can determine things like
  which "static inline" are used or how to traverse the
"typedef" dependency.
The goal is to have a "shrink" application that can strip away
all c-lines (pre-pre-process level) that are not used by a specific
command invocation of the compiler. Also a tool that can quickly show
for a specific identifier everything that is connected to it, again on
pre-preprocessor source level. kind-of something like:
...
func1() {
	struct string_list *filelist = NULL; int i;
}
..
I point to "string_list" and then all lines that are related
to struct string_list, (#ifdef nestings, macros, all member typedefs)
etc are shown and all the rest stripped away, again on human
readable c source level.


>
> Do you need to attach the dependency for the statment and
> expression as well?
>
> Chris
>


--------------020101020406000100050005
Content-Type: text/plain; charset=ISO-8859-1;
 name="0001-mdep.c-test.patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="0001-mdep.c-test.patch"


================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Sat, 12 May 2012 17:57:16 +0000
Message-ID: <4FAEA47C.6080308 () gmail ! com>
--------------------
On 05/12/2012 07:46 PM, Konrad Eisele wrote:
> On 05/12/2012 01:02 PM, Christopher Li wrote:
>> On Fri, May 11, 2012 at 2:48 PM, Konrad Eisele<eiselekd@gmail.com> wrote:
>>>
>>> This seems ok. expanding_macro has to be global not static to be
>>> used... (?)
>>
>> The expand_macro call back use the parent argument which get
>> from expanding_macro list. The caller should be able to create tree
>> from the leaf node using the parent pointer.
>>
>> Feel free to change to use the expanding_macro instead if that make
>> building the tree easier.
>>
>>> I think the fact that argument expansion is recursive and
>>> body expansion is non-recursive is one of the things that
>>> make the preprocessor kindof hard to grasp.
>>
>> The body expansion can't be recursive on same macro otherwise
>> it can result in unlimited expansion. The C stander specify
>> the macro expand this way.
>>
>>>
>>> I cannot say this before I've tried it.
>>>
>>> I'd like to straighten things out a bit: My last emails
>>> where a bit too harsh and I'd like to apologize. Sorry
>>> for that.
>>
>> No problem at all. I figure you just want to the patch to
>> get included.
>>
>>> The next step then is: I'll write a patch to add a
>>> test-prog that uses this api to trace the token generation
>>> and generate a tree for it.
>>> For a start I'll printout for all tokens of a preprocessor
>>> run all macros-expansions that generated them.
>>
>> That is great. I have a test-macro program in that
>> branch which is very close to print out all the tokens.
>
> Appended is a test-patch that adds test-mdep testcase.
> The file mdep.c is used to record that macro
> expansion, each token will have a reference to its
> source.
> test-mdep.c does pre-process (as test-macro.c) then
> prints out the token trace through macros for each
> token: @{ } is used to mark the active path.
>

To explain mdep.c: There are in fact only 3 lines that
are of interest:

...
137:            n->from = list->pos;
...

...
143:            list->pos.line = id;
144:            list->pos.stream = pps;
...

Line 137 saves the last token.pos , (143+144) insert a new id
into token.pos. This will generate the path for each token through
the expansions.
mdep_trace() traverses the path...


> An example file is added: a.h
> $test-mdep a.h
> ...
> 0004: 8
> body in D1 :4 @{8} 10 9 5 <untaint: D1>
> arg0 in D1 :@{8} 10 9
> body in D0 :1 @{D1}(8 10 9) 2 D2(11) 3 <untaint: D0>
> a.h:6:6
> ...
> Token nr 4 of the preprocess stream is "8". The
> generation path of "8" is marked @{8}...
> Not 100%, still, I think already readable. (Actually
> the printout order should be reversed (starting from file scope
> and drilling down the macro expansions...)
>
> I still dont handle empty expansions. I'll see weather I can come up
> with something here...
>
>
>>
>>> Now, I've learned not to run too fast towards the
>>> goal, (which is still "dependency tee from c parser entities downto
>>> token"), maybe you can think about how to achieve the next steps
>>> in an API :
>>> - An #include #ifdef #else #endif pushdown-stack
>>> to record the nestings for each token
>>
>> Let me think about this. Just thinking out lound,
>> The #include and #ifdef can consider as a special kind
>> of predefine macro as well.
>
> No, only a linked list that model the nexting levels.
> Then a preprocessor hook that can register lookup_macro()
> macro lookups inside # preprocessor lines. An example
> makes it clear:
>
> #if defined(a) && defined(b)
> #if defined(c)
> #endif
> #if defined(e)
> #endif
> #endif
>
> Result in:
> [a b]+<-[c]
> +<-[e]
>
> This can be easily done with a push-pop brackets
> and a callback in lookup_macro().
>
>
> Also:
> #if defined(a)
> #elif defined(c)
> #endif
>
> [a]+<-[c]
>
> #if defined(a)
> #else
> #endif
>
> <-[empty]<-[a]
>
> ...
>
>
> Another point I also need is to have an option so that inside
> do_handle_define() the symbol structures are never reused but
> alloc_symbol() is always used for undef and define, this is
> because I need to be able to also track the undef and define
> history for a macro at a certain position. I think this should be
> easy to add because you just need to define define-undef on
> top of each other...
>
>
>>
>>> - How to connect all this to the AST.
>>
>> For symbol, it relative easy because symbol has pos range
>> and aux pointer.
>
> I thought about taking "struct symbol_list *syms = sparse(file)"
> as the root. Then mark all elements that are used by them as dependent.
> I dont have enough insight to say how I can determine things like
> which "static inline" are used or how to traverse the
> "typedef" dependency.
> The goal is to have a "shrink" application that can strip away
> all c-lines (pre-pre-process level) that are not used by a specific
> command invocation of the compiler. Also a tool that can quickly show
> for a specific identifier everything that is connected to it, again on
> pre-preprocessor source level. kind-of something like:
> ...
> func1() {
> struct string_list *filelist = NULL; int i;
> }
> ..
> I point to "string_list" and then all lines that are related
> to struct string_list, (#ifdef nestings, macros, all member typedefs)
> etc are shown and all the rest stripped away, again on human
> readable c source level.
>
>
>>
>> Do you need to attach the dependency for the statment and
>> expression as well?
>>
>> Chris
>>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Mon, 14 May 2012 10:53:35 +0000
Message-ID: <CANeU7Q=dekYJXU-LKv0R6_ty-u23yJjV-gzE5Et+7u+SMkDSTg () mail ! gmail ! com>
--------------------
On Sat, May 12, 2012 at 10:46 AM, Konrad Eisele <eiselekd@gmail.com> wrote:
> Appended is a test-patch that adds test-mdep testcase.
> The file mdep.c is used to record that macro
> expansion, each token will have a reference to its
> source.
> test-mdep.c does pre-process (as test-macro.c) then
> prints out the token trace through macros for each
> token: @{ } is used to mark the active path.

Here is some feed back for the patch you send out:

>diff --git a/a.h b/a.h
>new file mode 100644

The test file should be in validation/ directory. Please give a.h a
name represent the test as well.

+               if (!strncmp(arg, "buildin", 7)) {
+                       fnobuildin = 1;
+               }

Is there a stand gcc option to handle nobuildin? I haven't found one.
If gcc has one, we can duplicate the gcc behavior. Otherwise,
I don't see it is necessary to add one. The dependence program needs
to able to handle the symbol from built in stream any way.
If it is for easier to debug, your program can trivially skip out the builtin.
stream.

+ * BSD-License
+ * Redistribution and use in source and binary forms are permitted

Can you make it cover by the sparse license file as well? I don't mind you grant
extra license to your code. But please at least make it cover by the
license of the project itself otherwise I won't apply it. It is pure overhead
to figure out what license is compatiable to spase and maintain different
file at different license. Have all file under the project cover by the same
license will keep it simple.

+void mdep_init(void) {
+    preprocess_hook = &pp;
+    pps = init_stream("<pp>", -1, 0);
+}

Please use the same coding standing as the other part of the project.
It is actually the same as linux kernel. The "{" for the function should be
on a new line. Indentation is tab and 8 char wide. There is a lot of those
little one on this file. I am not going to repeat myself here.

+struct hash {
+    struct hash_v *f;
+} h[HASH_LEN];

+struct pp {
+    enum pp_typ t;
+    union {
+        unsigned int argi;
+    };
+    struct pp_e *f;
+    struct symbol *sym;
+    struct token *tok;
+    struct token *s, *d;
+};
+

I hate those one letter member name. You have to guess what it is
all the time. pp_dope_list() is full of those one letter variable name as
well, make it very hard to read. The variable name need to be a little
bit more meaningful.


+       show_tokenstream(token, 0);
Please don't use 0 for NULL pointer.

-void show_tokenstream(struct token *token)
+void show_tokenstream(struct token *token, struct token *end)
-       while (!eof_token(token)) {
+       while (token != end && !eof_token(token)) {

I don't see you use the show_tokenstream with two arguments.
You write your own show_tokenstream for mdep any way.
You can leave it one unchanged.

@@ -194,7 +196,7 @@ void show_tokenstream(struct token *token)
-               printf("%s%.*s", show_token(token), prec, separator);
+               fprintf(stderr,"%s%.*s", show_token(token), prec, separator);

Can't do that, the "-E" will use show_tokenstream() as well. You just
change it to stderr for "-E".


To be continue...

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Tue, 15 May 2012 06:30:20 +0000
Message-ID: <CANeU7QnOtrWFvmd4Od1gU_uHccjSQdD7pNGC4ri4pTCU=GcwLg () mail ! gmail ! com>
--------------------
On Sun, May 13, 2012 at 1:52 AM, Konrad Eisele <eiselekd@gmail.com> wrote:
> I have thought about how to implement empty expansion tracing without
> introducing a new token type. I came up with a solution, however I need
> one callback, I called it substitute_arg(), see patch attached.
> What do you think, is it apply-able?
>

I am very sorry that my speed of absorbing patches is much slower than
your speed of producing it :(

About propagating the empty expansions, may I ask a silly question?
Is that the goal is you are able to track that, after the recursive expansion,
you are able to tell in the result stream, there is an macro expand to nothing
in the this location?

Obviously, if the empty expansion is happen in the top level macro expand,
you can always keep track of where is the original location of the expand using
macro token->pos. The tricky part is the, if the empty expansion happen inside
a multi-level macro expand. Then it is hard to keep track of where that empty
macro should have been landed if it is not empty. Is that the problem you are
trying to solve?

About the two example usage you give. The first one is using the html
to show how macro expand recursively. I like that demo. It only need to remember
at which level the macro expand to empty. It don't need to remember where
the empty macro need to land in the result stream.

For the second usage example, the shrinking program. I think it only need to
remember empty macro expand at the top level. Which is easy because you
have the macro token->pos pointing to where this macro used in the source
stream. For the empty macro expand inside another macro, you only need
to remember it is a dependent of the the top level macro. Because when you
trim the source code, you can't split a top level macro.

I think a lot of the complexity is introduced try to remember where that empty
macro will land, if it is not being empty. However, exactly because the macro
is being empty, it will not show up in the result token list. So where it should
land is actually not very useful information, the parser never see it any way.
We can relax the requirement a little bit, only need to remember where the
empty macro will land in the top level case. That will greatly
simplify the solution.

Is my understanding correct?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Tue, 15 May 2012 07:52:23 +0000
Message-ID: <4FB20B37.8070308 () gaisler ! com>
--------------------
Christopher Li wrote:
> On Sun, May 13, 2012 at 1:52 AM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>> I have thought about how to implement empty expansion tracing without
>> introducing a new token type. I came up with a solution, however I need
>> one callback, I called it substitute_arg(), see patch attached.
>> What do you think, is it apply-able?
>>
>
> I am very sorry that my speed of absorbing patches is much slower than
> your speed of producing it :(
The last patch with mdep.c and test-mdep.c was also nothing to
apply, only a work in progress to go further...
One thing you can see is how I propagate the token sources
using:
137:            n->from = list->pos;
...
143:            list->pos.line = id;
144:            list->pos.stream = pps;

here you get an argument why it is better to have a
(1) ->macro_begin(a)
     ->macro_end(b)
instead of only one
(2) expand_macro(a,b)
If you want to use the preprocessorhooks to output human readable macro
expansion history line similar to LLVM you probably want a pointer
to the "pre-expanded" token location, that is in (a). In (1) you can buildup
the token-source-paths going from post-expand buffer (b) through the pre-expanded buffers (a)
in (2) you only have the paths going through the expanded buffers, can use (a) to reason
about where (b) came from, but  not in a simple way...

>
> About propagating the empty expansions, may I ask a silly question?
> Is that the goal is you are able to track that, after the recursive expansion,
> you are able to tell in the result stream, there is an macro expand to nothing
> in the this location?
>
> Obviously, if the empty expansion is happen in the top level macro expand,
> you can always keep track of where is the original location of the expand using
> macro token->pos. The tricky part is the, if the empty expansion happen inside
> a multi-level macro expand. Then it is hard to keep track of where that empty
> macro should have been landed if it is not empty. Is that the problem you are
> trying to solve?

Kindof something like this:
#define E1
#define E2
#define S1(a) struct a { E1 int d1; };
#define S2(a) struct a { E2 int d2; };
#define xdef S1(sx) S2(sy)
xdef
main() {
	struct sx v;
}

The xdef expands in one-line to "struct sx { int d1; }; struct sy { int d1; };"
main() only uses "struct sx". Therefore the dependency analysis should not
have "E2 and S2" as dependencies. I think you need the location of empty expansions...

>
> About the two example usage you give. The first one is using the html
> to show how macro expand recursively. I like that demo. It only need to remember
> at which level the macro expand to empty. It don't need to remember where
> the empty macro need to land in the result stream.
Do you mean http://cfw.sourceforge.net/htmltag/init_32.c.pinfo.html ? This
is a gcc-based patch even there you need to trace empty expansion positions.

>
> For the second usage example, the shrinking program. I think it only need to
> remember empty macro expand at the top level. Which is easy because you
> have the macro token->pos pointing to where this macro used in the source
> stream. For the empty macro expand inside another macro, you only need
> to remember it is a dependent of the the top level macro. Because when you
> trim the source code, you can't split a top level macro.

See above example.

>
> I think a lot of the complexity is introduced try to remember where that empty
> macro will land, if it is not being empty. However, exactly because the macro
> is being empty, it will not show up in the result token list. So where it should
> land is actually not very useful information, the parser never see it any way.
> We can relax the requirement a little bit, only need to remember where the
> empty macro will land in the top level case. That will greatly
> simplify the solution.

I'm not shure if it works...

>
> Is my understanding correct?
>
> Thanks
>
> Chris
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Tue, 15 May 2012 09:44:49 +0000
Message-ID: <CANeU7QmfxzQ8xXObV+PzLBZ62Amw13dY+-9OEa2K9QLGh4eKRg () mail ! gmail ! com>
--------------------
On Tue, May 15, 2012 at 12:52 AM, Konrad Eisele <konrad@gaisler.com> wrote:
> The last patch with mdep.c and test-mdep.c was also nothing to
> apply, only a work in progress to go further...

OK, I mistaken that as apply request. Never mind some of the
coding style comment then.

> One thing you can see is how I propagate the token sources
> using:
>
> 137:            n->from = list->pos;
> ...
> 143:            list->pos.line = id;
> 144:            list->pos.stream = pps;
>
> here you get an argument why it is better to have a
> (1) ->macro_begin(a)
>    ->macro_end(b)
> instead of only one
> (2) expand_macro(a,b)
> If you want to use the preprocessorhooks to output human readable macro
> expansion history line similar to LLVM you probably want a pointer
> to the "pre-expanded" token location, that is in (a). In (1) you can buildup
> the token-source-paths going from post-expand buffer (b) through the
> pre-expanded buffers (a)
> in (2) you only have the paths going through the expanded buffers, can use
> (a) to reason
> about where (b) came from, but  not in a simple way...

At this point I think  1) is actually better for your requirement.
I start out as hoping the expand_macro() can abstract away the
internal implementation detail of macro expand and just give you the
text before and after the macro expand. But with all this extra
manipulations of the macro tokens, especially the substitute_argument()
is clear indicate tightening into the implementation details.

I would take 1) over substitute_arguments() if 1) don't need call back like
substitute_arguments().


> Kindof something like this:
> #define E1
> #define E2
> #define S1(a) struct a { E1 int d1; };
> #define S2(a) struct a { E2 int d2; };
> #define xdef S1(sx) S2(sy)
> xdef
> main() {
>        struct sx v;
> }
>
> The xdef expands in one-line to "struct sx { int d1; }; struct sy { int d1;
> };"
> main() only uses "struct sx". Therefore the dependency analysis should not
> have "E2 and S2" as dependencies. I think you need the location of empty

That is surprising to me. I previously have different assumptions.
I assume you want to back trace all the way back to the source macro.
I would just say main() depend on xdef, which depend one S1 and S2.
S1 also depend on E1 and S2 depend on E2.

If you bypass xdef and directly extract S1(sx). Why can't you do one
step further bypass S1() as well,  and say main depend on "struct sx {
E1 int d1;}?

This is even more complicated than I original though.
How about this case:

#define S1(a) struct a { E1 int d1; }; E3 struct
#define S2(a) a { E2 int d2; };

The rest is the same. Now xdef will expand to the same text.
What should main() depend on?  S1, E1 and E3?
Notice that without S2, macro expand by S1 can't compile at all.

> Do you mean http://cfw.sourceforge.net/htmltag/init_32.c.pinfo.html ? This
> is a gcc-based patch even there you need to trace empty expansion positions.

Yes. Did that patch submit to gcc? I can see trace empty expansion one level.
You track empty macro pass that one multiple level macro expand as well?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: Fwd: dependency tee from c parser entities downto token
Date: Tue, 15 May 2012 13:03:49 +0000
Message-ID: <4FB25435.1030604 () gmail ! com>
--------------------
On 05/15/2012 11:44 AM, Christopher Li wrote:
> On Tue, May 15, 2012 at 12:52 AM, Konrad Eisele<konrad@gaisler.com>  wrote:
>> The last patch with mdep.c and test-mdep.c was also nothing to
>> apply, only a work in progress to go further...
>
> OK, I mistaken that as apply request. Never mind some of the
> coding style comment then.
>
>> One thing you can see is how I propagate the token sources
>> using:
>>
>> 137:            n->from = list->pos;
>> ...
>> 143:            list->pos.line = id;
>> 144:            list->pos.stream = pps;
>>
>> here you get an argument why it is better to have a
>> (1) ->macro_begin(a)
>>     ->macro_end(b)
>> instead of only one
>> (2) expand_macro(a,b)
>> If you want to use the preprocessorhooks to output human readable macro
>> expansion history line similar to LLVM you probably want a pointer
>> to the "pre-expanded" token location, that is in (a). In (1) you can buildup
>> the token-source-paths going from post-expand buffer (b) through the
>> pre-expanded buffers (a)
>> in (2) you only have the paths going through the expanded buffers, can use
>> (a) to reason
>> about where (b) came from, but  not in a simple way...
>
> At this point I think  1) is actually better for your requirement.
> I start out as hoping the expand_macro() can abstract away the
> internal implementation detail of macro expand and just give you the
> text before and after the macro expand. But with all this extra
> manipulations of the macro tokens, especially the substitute_argument()
> is clear indicate tightening into the implementation details.
>
> I would take 1) over substitute_arguments() if 1) don't need call back like
> substitute_arguments().

substitute_arguments() is because I am not allowed extra token
TOKEN_M_EMPTY. it is unrelated to the upper cases...

>
>
>> Kindof something like this:
>> #define E1
>> #define E2
>> #define S1(a) struct a { E1 int d1; };
>> #define S2(a) struct a { E2 int d2; };
>> #define xdef S1(sx) S2(sy)
>> xdef
>> main() {
>>         struct sx v;
>> }
>>
>> The xdef expands in one-line to "struct sx { int d1; }; struct sy { int d1;
>> };"
>> main() only uses "struct sx". Therefore the dependency analysis should not
>> have "E2 and S2" as dependencies. I think you need the location of empty
>
> That is surprising to me. I previously have different assumptions.
> I assume you want to back trace all the way back to the source macro.
> I would just say main() depend on xdef, which depend one S1 and S2.
> S1 also depend on E1 and S2 depend on E2.

I'm not shure who is wrong here or weather maybe my example is not
general enought, maybe you are right...

>
> If you bypass xdef and directly extract S1(sx). Why can't you do one
> step further bypass S1() as well,  and say main depend on "struct sx {
> E1 int d1;}?
>
> This is even more complicated than I original though.
> How about this case:
>
> #define S1(a) struct a { E1 int d1; }; E3 struct
> #define S2(a) a { E2 int d2; };
>
> The rest is the same. Now xdef will expand to the same text.
> What should main() depend on?  S1, E1 and E3?
> Notice that without S2, macro expand by S1 can't compile at all.
>
>> Do you mean http://cfw.sourceforge.net/htmltag/init_32.c.pinfo.html ? This
>> is a gcc-based patch even there you need to trace empty expansion positions.
>
> Yes. Did that patch submit to gcc? I can see trace empty expansion one level.

Kind-of:-) http://gcc.gnu.org/ml/gcc/2012-03/msg00208.html
It disapears in the gcc list noise however...

> You track empty macro pass that one multiple level macro expand as well?

I dump everything, however I use a perl script to reconstruct...

>
> Chris
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Generic Red-Black Trees: preliminary performance results ===

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Generic Red-Black Trees: preliminary performance results
Date: Tue, 10 Jul 2012 09:58:01 +0000
Message-ID: <4FFBFCA9.2060307 () att ! net>
--------------------
I've completed some rudimentary test code.  It is designed to compile
both in user & kernel space but only currently compiles in userland.  I
ran this on 9 different versions of gcc, all on x86_64 with CFLAGS="-O2
-g3 -pipe -march=k8".  The below summary data shows the % increase in
time consumed (decrease in performance) using my generic red-black trees
over hand-coded functions for insertion.

gcc ver  % decrease in speed
4.7.1       -5.39%
4.6.2        2.60%
4.5.3       18.07%
4.4.6       20.52%
4.3.6       13.53%
4.2.4       11.84%
4.1.2       16.36%
4.0.4       35.70%
3.4.6       47.28%

I don't understand why the generic code ran faster than hand-coded on
gcc 4.7.1 as I haven't examined the assembly output yet.  However, I'm
pretty certain I understand why it was 2% slower on 4.6.  This has to do
with an optimization flaw.  In the hand-coded insert/find functions, I
used  the "if (a->key > b->key) .. else if (a->key < b->key)" construct,
where as the generic code calculates a diff and compares that against
zero and 4.6.2 is adding an unnecessary cmp instruction:

 3f2:   8b 48 18                mov    0x18(%rax),%ecx
 3f5:   8b 7a 18                mov    0x18(%rdx),%edi
 3f8:   48 29 f9                sub    %rdi,%rcx
 3fb:   48 83 f9 00             cmp    $0x0,%rcx
 3ff:   7f df                   jg     3e0 <grbtest_insert+0xb0>
 401:   0f 84 c9 00 00 00       je     4d0 <grbtest_insert+0x1a0>

The test configuration was for a tree that tracks both leftmost,
rightmost and count and uses unique keys where the insert function
replaces an existing object. These tests weren't ideal.  While I
allocated 4096 objects (32 bytes each) to stick in my tree, I used 0xff
for a key mask, so only 256 object would be in the tree at once and I
didn't notice this until I was most of the way through the tests.  My
intention was to run the test with a data set small enough to fit into
the L3 cache, so as to reduce overhead from memory access and isolate
the actual differences in the algorithm.

When I get this all cleaned up, I'll release another patch set with the
test code added.  (This also automates correctness tests for find,
insert, find_near and insert_near). Also, I'm going to experiment with
branch prediction to see if I can squeeze a little more performance out
of the older compilers.

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Killing off __cond_lock() ===

From: Peter Zijlstra <peterz () infradead ! org>
To: linux-sparse
Subject: Killing off __cond_lock()
Date: Sat, 24 Mar 2012 16:23:36 +0000
Message-ID: <1332606216.16159.48.camel () twins>
--------------------
Hi all,

So the kernel has this __cond_lock() crap pile, which is implemented
like:

#define __acquire(x)       __context__(x,1)
#define __cond_lock(x,c)   ((c) ? ({ __acquire(x); 1; }) : 0)

Now the problem with this is that people send ugly patches like:

https://lkml.org/lkml/2012/3/24/57
http://www.spinics.net/lists/mm-commits/msg80386.html

That basically wrap an existing function in an inline function just to
use __cond_lock() on the return value.

It would be ever so much nicer if we could declare such functions like:

struct anon_vma *page_lock_anon_vma(struct page *page)
	__cond_acquires(RCU) 
	__cond_acquires(page_lock_anon_vma(page)->root->lock);

Meaning that if the return value is true (non-zero), it would acquire
that lock/context. One could of course add some shorter means of
referring to the return value, but simply using the function in the
expression should be simple enough.

In order to implement this I guess we need to extend the
__attribute__((context(expr,in,out))) thing. 

Currently in,out are explicit value constants, but I guess if we make
them expressions we could evaluate them and get dynamic behaviour.

Thus allowing something like:

int spin_trylock(spinlock_t *lock)
	__attribute__((context(lock, 0, !!spin_trylock(lock));

meaning that the context would be incremented by 1 if the return value
were true.

Having only briefly looked at the sparse source, is this feasible to
implement or do we get chicken/egg problems wrt using a function before
its declaration is complete, and referring a return value before the
function is part of an expression?

If this yields problems, are there better ways of solving this issue?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Killing off __cond_lock()
Date: Sun, 25 Mar 2012 08:48:30 +0000
Message-ID: <1332665310.3840.8.camel () jlt3 ! sipsolutions ! net>
--------------------
Hi,

> struct anon_vma *page_lock_anon_vma(struct page *page)
> 	__cond_acquires(RCU) 
> 	__cond_acquires(page_lock_anon_vma(page)->root->lock);
> 
> Meaning that if the return value is true (non-zero), it would acquire
> that lock/context. One could of course add some shorter means of
> referring to the return value, but simply using the function in the
> expression should be simple enough.
> 
> In order to implement this I guess we need to extend the
> __attribute__((context(expr,in,out))) thing. 
> 
> Currently in,out are explicit value constants, but I guess if we make
> them expressions we could evaluate them and get dynamic behaviour.
> 
> Thus allowing something like:
> 
> int spin_trylock(spinlock_t *lock)
> 	__attribute__((context(lock, 0, !!spin_trylock(lock));
> 
> meaning that the context would be incremented by 1 if the return value
> were true.
> 
> Having only briefly looked at the sparse source, is this feasible to
> implement or do we get chicken/egg problems wrt using a function before
> its declaration is complete, and referring a return value before the
> function is part of an expression?
> 
> If this yields problems, are there better ways of solving this issue?

I once looked at all of this (which I suspect you saw, given that you're
CC'ing me) but all my changes ended up being reverted since they broke
things so maybe I'm not the right person to ask ... :-)

I played with having a "RETURN" builtin (or something like that) to use
inside here but it didn't really work out well, I don't think that was
what ended up going upstream though.

However, I don't think using the function call etc. is a good idea, to
me that makes it look too much like you could put arbitrary code there,
but since this doesn't even exist at runtime ...

However, note that today sparse doesn't evaluate anything in the
context, it doesn't even look at the first argument. So another thing
you can't really annotate well is things like this:

struct foo_object *get_locked_object(...);

This is why I used RETURN to give the return value a name, so you could
write
	__acquires(&RETURN->lock)


But I was also trying to make sparse actually evaluate the first
argument so it could tell the difference between two locks, which you
might not even care about ... (it would be nice though I think)

johannes

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Johannes Berg <johannes () sipsolutions ! net>
To: linux-sparse
Subject: Re: Killing off __cond_lock()
Date: Mon, 26 Mar 2012 09:00:37 +0000
Message-ID: <1332752437.7081.5.camel () jlt3 ! sipsolutions ! net>
--------------------
On Mon, 2012-03-26 at 10:11 +0200, Peter Zijlstra wrote:

> > However, note that today sparse doesn't evaluate anything in the
> > context, it doesn't even look at the first argument. So another thing
> > you can't really annotate well is things like this:
> > 
> > struct foo_object *get_locked_object(...);
> > 
> > This is why I used RETURN to give the return value a name, so you could
> > write
> > 	__acquires(&RETURN->lock)
> 
> 
> Right, but if it doesn't actually evaluate the expression used in the
> context this is going to be problematic.

It probably could -- but the question is what context to evaluate it in.

> > But I was also trying to make sparse actually evaluate the first
> > argument so it could tell the difference between two locks, which you
> > might not even care about ... (it would be nice though I think)
> 
> Right, so what I thought we could maybe do is inject code in the
> callsites of these functions.
> 
> So after the OP_CALL emit a piece of code that works like the
> __context__ stmt and can reference the return value that exists at that
> point.
> 
> This also makes the conditional thing quite simple to do.

Indeed, but you'd need some sort of expression rewriting. Consider

void lock_obj(obj_t *o) __acquires(&o->lock);

void lock_obj(obj_t *obj)
{
	__acquire(&obj->lock);

	...
}


void foo(void)
{
	...
	lock_obj(&f);
	...
	unlock_obj(&f);
	...
}


Now you suddenly need to replace "&o->lock" with "&(&f)->lock", when
checking the function itself it really is called "obj", not "o". Not
that sparse actually checks that the function behaviour matches the
declaration today though.

johannes


PS: Something else I had wanted to remind you of: the cond_lock thing
only works due to some sort of optimiser pass (is there such a thing?)
in sparse, sometimes it fails mysteriously because the condition isn't
the exact same condition or something.


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () freedesktop ! org>
To: linux-sparse
Subject: Re: Killing off __cond_lock()
Date: Mon, 26 Mar 2012 09:29:35 +0000
Message-ID: <20120326092935.GB21202 () leaf>
--------------------
On Mon, Mar 26, 2012 at 10:11:34AM +0200, Peter Zijlstra wrote:
> On Sun, 2012-03-25 at 10:48 +0200, Johannes Berg wrote:
> > But I was also trying to make sparse actually evaluate the first
> > argument so it could tell the difference between two locks, which you
> > might not even care about ... (it would be nice though I think)
> 
> Right, so what I thought we could maybe do is inject code in the
> callsites of these functions.
> 
> So after the OP_CALL emit a piece of code that works like the
> __context__ stmt and can reference the return value that exists at that
> point.
> 
> This also makes the conditional thing quite simple to do.

For the general case, this seems like roughly the right solution.  That
will also handle slightly more complex conditionals, though
significantly more complex ones will just get sparse complaining that
you can reach later code with multiple contexts.

Similarly, require_context might work better as an expression executed
beforehand, which would ideally have access to the arguments.

I don't know if it makes sense to put an __attribute__((__after_expr__,
arbitrary_expression)) into sparse just to avoid doing the same thing
with a macro or static inline, though.  A macro or static inline
trivially has access to the arguments and return value, and can run
arbitrary statements/expressions either before or after the underlying
function call, including conditionals.

(Even better if sparse could just always do whole-program analysis, so
that you could include the __context__ call inline in the normal
function and have the caller see it, but that won't happen anytime
soon.)

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Loan Offer ===

From: Loan Solution Team <info () loan ! com>
To: linux-edac
Subject: Loan Offer
Date: Tue, 17 Jan 2012 10:34:19 +0000
Message-ID: <20120117183419.66345tfvpy7yu45c () mail ! metalco ! com ! my>
--------------------


-- 
Dear Customer,

Loan Solution Team, help you to change the way you live.Arranging a  
loan with us is simple and straight forward,loans from any amount to  
$5,000 to $2,000,000.00 over 5 to 30 years.we make the process  
convenient and fast.Our interest rate is 3% APR Typical variable and  
this means thatall of our clients pay this rate. Kind Regards,
Mrs.Terry Clerk
Email:loan_solution200@live.com
TEL: +447045755481

----------------------------------------------------------------
This message was sent using IMP, the Internet Messaging Program.

--
To unsubscribe from this list: send the line "unsubscribe linux-edac" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "clark.khadige1" <clark.khadige1 () usj ! edu ! lb>
To: linux-netdev
Subject: Loan Offer
Date: Thu, 26 Jan 2012 02:54:31 +0000
Message-ID: <20120126025317.M90861 () usj ! edu ! lb>
--------------------
Dear Customer, 

Loan Solution Team, help you to change the way you live.Arranging a loan with us is 
simple and straight forward,loans from any amount to $5,000 to $2,000,000.00 over 5 to 
30 years.we make the process convenient and fast.Our interest rate is 3% APR Typical 
variable and this means that all of our clients pay this rate.
FULL NAMES:
COUNTRY:
AGE: 
MONTHLY INCOME:
OCCUPATION:
PHONE NUMBER:
MOBILE PHONE NUMBER:
AMOUNT NEEDED
LOAN DURATION/PERIOD:
PURPOSE OF LOAN:
Email:loan_solution200@live.com
Mrs.Terry Clerk
--
To unsubscribe from this list: send the line "unsubscribe netdev" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Roy Wood <nicolo.cultrera () cnr ! it>
To: linux-netdev
Subject: Loan Offer
Date: Sat, 08 Jul 2017 12:44:31 +0000
Message-ID: <20170708144431.56582nkz05dpuxtb () webmailold ! cnr ! it>
--------------------


Exclusive guaranteed loan offer of any amount at a 3% rate. Contact  
Mr. Roy Wood from Save&Spend and see for yourself that you will be  
satisfied. please contact FCS Directly only via  
roywoodsavingsunitedloans@gmail. com if yes,apply now with your  
details 1.Full Name: 2.Sex: 3.Age: 4. Phone: 5.Fax: 6.Country:  
7.Address 8.Amount needed: 9.Duration Period:
for a try and be satisfied.

+1 (646) 458-4003

----------------------------------------------------------------
This message was sent using IMP, the Internet Messaging Program.


================================================================================


################################################################################

=== Thread: MAIL 10.03.2012 ===

From: "Mr. Richard Tang" <tagnrichard () yahoo ! com ! hk>
To: linux-sparse
Subject: MAIL 10.03.2012
Date: Sun, 11 Mar 2012 10:05:28 +0000
Message-ID: <201203111005.q2BA5TqM006936 () mail ! ucla ! edu>
--------------------
Mail From Tang.

I work with the hang seng Bank Hong Kong.I have a business proposition for you involving a trade in my bank which I know we will be of mutual benefit to both of us, If interested mail me at:tangricad@yahoo.co.jp

Regards,
Richard Tang.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Many warnings when building sparse with MinGW- format specifiers for "printf" ===

From: Tom Schmid <scth2000 () yahoo ! de>
To: linux-sparse
Subject: Many warnings when building sparse with MinGW- format specifiers for "printf"
Date: Fri, 07 Dec 2012 12:07:14 +0000
Message-ID: <1354882034.95572.YahooMailNeo () web29702 ! mail ! ird ! yahoo ! com>
--------------------
Hello, 


it was the first time, that i tried to build sparse on MinGW - I used cygwin in the past. 
Now building sparse on MinGW (GCC 4.6.2) comes up with several of these warnings: 

parse.c:1695:3: warning: unknown conversion type character 'l' in format [-Wformat] 
parse.c:1695:3: warning: too many arguments for format [-Wformat-extra-args] 

See also sourceforge.net/apps/trac/mingw-w64/wiki/gnu printf 

It seems, that MinGW doesn't accept the "old style" format specifiers like "%llu". 
That means, that functions like printf will not work as expected, if these "old style" format specifiers are used. 

Is this a known problem? 
Is there any hint or workaround? 


Regards, 
Thomas Schmid

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Patch: add __builtin_stpcpy and __sync_synchronize to builtin functions ===

From: Frederic Crozat <fcrozat () suse ! com>
To: linux-sparse
Subject: Patch: add __builtin_stpcpy and __sync_synchronize to builtin functions
Date: Thu, 15 Mar 2012 14:15:43 +0000
Message-ID: <1331820943.2720.5.camel () par-r81vxc7 ! par ! novell ! com>
--------------------

--=-YC7Er+jOG8IuPYDixjhK
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 7bit

Hi,

while working on integrating sparse checks in systemd, I noticed some
builtin functions need to be added to sparse list. See attached patch
for the fix.

I've also noted patch from Pekka Enberg
(http://www.spinics.net/lists/linux-sparse/msg02520.html ) is still
needed when running sparse on x86-64. It would be nice to merge it in
git.

-- 
Frederic Crozat <fcrozat@suse.com>
SUSE


--=-YC7Er+jOG8IuPYDixjhK
Content-Disposition: inline;
	filename*0=0001-Add-__builtin_stpcpy-and-__sync_synchronize-to-decla.pat;
	filename*1=ch
Content-Type: text/x-patch;
	name="0001-Add-__builtin_stpcpy-and-__sync_synchronize-to-decla.patch";
	charset="UTF-8"
Content-Transfer-Encoding: 7bit


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Patch: add __builtin_stpcpy and __sync_synchronize to builtin functions
Date: Fri, 23 Mar 2012 08:26:29 +0000
Message-ID: <CANeU7QmikoVWVuVo1nWdgADoKD30iTCSirM+S1c9-aRd7hEa0Q () mail ! gmail ! com>
--------------------
On Thu, Mar 15, 2012 at 7:15 AM, Frederic Crozat <fcrozat@suse.com> wrote:
> while working on integrating sparse checks in systemd, I noticed some
> builtin functions need to be added to sparse list. See attached patch
> for the fix.

Catching up my backlogs. I just find out this patch does not have sign off.

Can you add a sign off line please?

Thanks

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Frederic Crozat <fcrozat () suse ! com>
To: linux-sparse
Subject: Re: Patch: add __builtin_stpcpy and __sync_synchronize to builtin functions
Date: Fri, 23 Mar 2012 09:32:58 +0000
Message-ID: <1332495178.15662.4.camel () par-r81vxc7 ! par ! novell ! com>
--------------------

--=-J+k8viTxJt5JqCGVyafh
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 8bit

Le vendredi 23 mars 2012 Ã  01:26 -0700, Christopher Li a Ã©crit :
> On Thu, Mar 15, 2012 at 7:15 AM, Frederic Crozat <fcrozat@suse.com> wrote:
> > while working on integrating sparse checks in systemd, I noticed some
> > builtin functions need to be added to sparse list. See attached patch
> > for the fix.
> 
> Catching up my backlogs. I just find out this patch does not have sign off.
> 
> Can you add a sign off line please?

Sorry, I didn't knew you needed this.

I've update the patch with adding yet another sync barrier which is now used in systemd.

-- 
Frederic Crozat <fcrozat@suse.com>
SUSE


--=-J+k8viTxJt5JqCGVyafh
Content-Disposition: inline;
	filename*0=0001-Add-__builtin_stpcpy-__sync_synchronize-__sync_bool_.pat;
	filename*1=ch
Content-Type: text/x-patch;
	name="0001-Add-__builtin_stpcpy-__sync_synchronize-__sync_bool_.patch";
	charset="UTF-8"
Content-Transfer-Encoding: 7bit


================================================================================

From: Frederic Crozat <fcrozat () suse ! com>
To: linux-sparse
Subject: Re: Patch: add __builtin_stpcpy and __sync_synchronize to builtin functions
Date: Fri, 23 Mar 2012 10:22:48 +0000
Message-ID: <1332498168.18430.1.camel () par-r81vxc7 ! par ! novell ! com>
--------------------

--=-pPMIKOXoQWtDD4+hg9My
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 8bit

Le vendredi 23 mars 2012 Ã  10:32 +0100, Frederic Crozat a Ã©crit :
> Le vendredi 23 mars 2012 Ã  01:26 -0700, Christopher Li a Ã©crit :
> > On Thu, Mar 15, 2012 at 7:15 AM, Frederic Crozat <fcrozat@suse.com> wrote:
> > > while working on integrating sparse checks in systemd, I noticed some
> > > builtin functions need to be added to sparse list. See attached patch
> > > for the fix.
> > 
> > Catching up my backlogs. I just find out this patch does not have sign off.
> > 
> > Can you add a sign off line please?
> 
> Sorry, I didn't knew you needed this.
> 
> I've update the patch with adding yet another sync barrier which is now used in systemd.

Better version attached, previous one was causing a warning.

-- 
Frederic Crozat <fcrozat@suse.com>
SUSE

--=-pPMIKOXoQWtDD4+hg9My
Content-Disposition: inline;
	filename*0=0001-Add-__builtin_stpcpy-__sync_synchronize-__sync_bool_.pat;
	filename*1=ch
Content-Type: text/x-patch;
	name="0001-Add-__builtin_stpcpy-__sync_synchronize-__sync_bool_.patch";
	charset="UTF-8"
Content-Transfer-Encoding: 7bit


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Patch: add __builtin_stpcpy and __sync_synchronize to builtin functions
Date: Fri, 23 Mar 2012 17:48:08 +0000
Message-ID: <CANeU7Qmff_oivY3W2-wxxyFFa1V9FoeSCgqe9182sdKnD6aNSg () mail ! gmail ! com>
--------------------
On Fri, Mar 23, 2012 at 3:22 AM, Frederic Crozat <fcrozat@suse.com> wrote:
> Better version attached, previous one was causing a warning.

Applied and pushed.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Please be informed! ===

From: =?iso-8859-1?Q?=22Western_Union=AE=22?= <office1231 () uady ! mx>
To: linux-sparse
Subject: Please be informed!
Date: Thu, 05 Apr 2012 06:14:16 +0000
Message-ID: <7cf6466ebc73ba069b36081e17d6e2f4.squirrel () webmail ! uady ! mx>
--------------------
Please be informed that you have $250,000.00 to transfer to you as
Compensation.


-----------------------------------------
   "Universidad Autónoma de Yucatán"
http://www.uady.mx/

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Using c2xml on kernel sources ===

From: Shakthi Kannan <shakthimaan () gmail ! com>
To: linux-sparse
Subject: Using c2xml on kernel sources
Date: Tue, 20 Mar 2012 09:12:18 +0000
Message-ID: <CABG-yt06Kw2uFnmrshcHYjgf_cMgzKVdMPe6BXOP2nryhRjBpg () mail ! gmail ! com>
--------------------
Hi,

I would like to run c2xml on the Linux kernel sources. Is there a
recommended way of using the tool on kernel code?

I tried running it directly on a source file, but, get the
'header-file "unable to open" error.

  $ c2xml linux-3.0.4/net/ethernet/eth.c

  ../linux-3.0.4/net/ethernet/eth.c:40:11: error: unable to open
'linux/module.h'

I have built sparse from git sources (v0.4.4) on Fedora 15 x86_64.

Appreciate any inputs in this regard.

Thanks!

SK

-- 
Shakthi Kannan
http://www.shakthimaan.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () petrovitsch ! priv ! at>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Tue, 20 Mar 2012 09:32:51 +0000
Message-ID: <1332235972.21661.65.camel () thorin>
--------------------
Hi!
On Die, 2012-03-20 at 14:30 +0530, Shakthi Kannan wrote:
[...]
> I would like to run c2xml on the Linux kernel sources. Is there a
> recommended way of using the tool on kernel code?
> 
> I tried running it directly on a source file, but, get the
> 'header-file "unable to open" error.
> 
>   $ c2xml linux-3.0.4/net/ethernet/eth.c
> 
>   ../linux-3.0.4/net/ethernet/eth.c:40:11: error: unable to open
> 'linux/module.h'
> 
> I have built sparse from git sources (v0.4.4) on Fedora 15 x86_64.

Someone probably have to tell c2xml where to look for the .h files
similar to gcc's "-I" parameters.

	Bernd
-- 
Bernd Petrovitsch                  Email : bernd@petrovitsch.priv.at
                     LUGA : http://www.luga.at

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Bernd Petrovitsch <bernd () petrovitsch ! priv ! at>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Tue, 20 Mar 2012 09:32:51 +0000
Message-ID: <1332235972.21661.65.camel () thorin>
--------------------
Hi!
On Die, 2012-03-20 at 14:30 +0530, Shakthi Kannan wrote:
[...]
> I would like to run c2xml on the Linux kernel sources. Is there a
> recommended way of using the tool on kernel code?
> 
> I tried running it directly on a source file, but, get the
> 'header-file "unable to open" error.
> 
>   $ c2xml linux-3.0.4/net/ethernet/eth.c
> 
>   ../linux-3.0.4/net/ethernet/eth.c:40:11: error: unable to open
> 'linux/module.h'
> 
> I have built sparse from git sources (v0.4.4) on Fedora 15 x86_64.

Someone probably have to tell c2xml where to look for the .h files
similar to gcc's "-I" parameters.

	Bernd
-- 
Bernd Petrovitsch                  Email : bernd@petrovitsch.priv.at
                     LUGA : http://www.luga.at

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Shakthi Kannan <shakthimaan () gmail ! com>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Tue, 20 Mar 2012 15:37:48 +0000
Message-ID: <CABG-yt2bs8wGUgTH9=dPgtD22vER8qd5JFZGXgPj9f+NS-OHmQ () mail ! gmail ! com>
--------------------
Hi Dan:

--- On Tue, Mar 20, 2012 at 4:07 PM, Dan Carpenter
<dan.carpenter@oracle.com> wrote:
| make C=2 CHECK="c2xml > foo.xml" net/ethernet/eth.o
\--

That worked!

But, is it really required to generate eth.o? Is it possible to just
parse through the sources, produce the .xml output without having to
generate the object files?

Thanks for your reply,

SK

-- 
Shakthi Kannan
http://www.shakthimaan.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Shakthi Kannan <shakthimaan () gmail ! com>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Tue, 20 Mar 2012 15:37:48 +0000
Message-ID: <CABG-yt2bs8wGUgTH9=dPgtD22vER8qd5JFZGXgPj9f+NS-OHmQ () mail ! gmail ! com>
--------------------
Hi Dan:

--- On Tue, Mar 20, 2012 at 4:07 PM, Dan Carpenter
<dan.carpenter@oracle.com> wrote:
| make C=2 CHECK="c2xml > foo.xml" net/ethernet/eth.o
\--

That worked!

But, is it really required to generate eth.o? Is it possible to just
parse through the sources, produce the .xml output without having to
generate the object files?

Thanks for your reply,

SK

-- 
Shakthi Kannan
http://www.shakthimaan.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dan Carpenter <dan.carpenter () oracle ! com>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Tue, 20 Mar 2012 15:40:48 +0000
Message-ID: <20120320154048.GA7848 () mwanda>
--------------------

--FCuugMFkClbJLl1L
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Tue, Mar 20, 2012 at 08:55:48PM +0530, Shakthi Kannan wrote:
> Hi Dan:
>=20
> --- On Tue, Mar 20, 2012 at 4:07 PM, Dan Carpenter
> <dan.carpenter@oracle.com> wrote:
> | make C=3D2 CHECK=3D"c2xml > foo.xml" net/ethernet/eth.o
> \--
>=20
> That worked!
>=20
> But, is it really required to generate eth.o? Is it possible to just
> parse through the sources, produce the .xml output without having to
> generate the object files?
>=20

No, I can't think of an easy way.

regards,
dan carpenter.


--FCuugMFkClbJLl1L
Content-Type: application/pgp-signature; name="signature.asc"
Content-Description: Digital signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIcBAEBAgAGBQJPaKT/AAoJEOnZkXI/YHqRwn4QAJU71LmmHrHRHHCbM1gxZwuz
ForB1XpZIsJJncz78Uez7fYREWEsyJ8pLpHounwZPhGLsOaQVG/Jk4yPygqznGn7
qAFjYflnoKtnUD6JQ34O2aOA2OTunXHQ71WNk+GA6O1Tczb1LyTOV31QGJ/nS6HP
ecReIa0ycOwyLKzummG/fWZKVizGAnbb51elIGWM1v8AbFtMzjxQHbAugXawcuNM
tbsIEWYxicuotf027oonHSKPDBHVERk2PkLhljoJn2hxcriA8CooY9+ipaGe8/8K
ubh+nXh0CUBwilX4m6FjVOFq+qtyYAkEOObxZezzCLZBoss23pxewB46ncweFt1x
E3PTUGsnC3doWCKOVWGtandIZMh2zPuiwpQC+ahWNy2DBadqB2bFDoWsfuKA3r9e
MgyzZ8AA/a7ozTIu8o0n+4drj2u1vvHKrU2oNLjYAKEiASztxT0O1U7WXsyatIgs
iIaw/Caqff0EZe1JLWWAzFM4B/WREDi/S8MHQ8VdU7CQFXH/TuZIXoT1+DY/YKP9
E39VYFN4dIlJF3MlHu3PL9tUbFpahuhrbZyJqzCwCm4+QggxW61UfmyvdILucdy1
Is5eRTt0eAKiMmt13ucnuumdapSEHxn53jShYnETPsarmZLoEbMkFlGA5AIG++TX
/vQJOxj87i6wXkvrUmEk
=iIri
-----END PGP SIGNATURE-----

--FCuugMFkClbJLl1L--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Shakthi Kannan <shakthimaan () gmail ! com>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Wed, 23 May 2012 10:11:03 +0000
Message-ID: <CABG-yt2rCSESURVA4NOJe6Cwyxj0saTN1oJcMYE3kAgsNtULQA () mail ! gmail ! com>
--------------------
Hi,

Replying to my own post (for future reference):

--- On Tue, Mar 20, 2012 at 08:55:48PM +0530, Shakthi Kannan wrote:
| But, is it really required to generate eth.o? Is it possible to just
| parse through the sources, produce the .xml output without having to
| generate the object files?
\--

I had to use:

MAKEFLAGS+="--dry-run" make C=2 CHECK="c2xml > foo.xml"
net/ethernet/eth.o > output.txt

eval `tail -2 output.txt | head -1`

SK

-- 
Shakthi Kannan
http://www.shakthimaan.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Wed, 23 May 2012 18:30:31 +0000
Message-ID: <CANeU7Q=QCY4mWRhCJ14MyRh_nr3hyP4Yw9M0nYDs8cw2UaxHCA () mail ! gmail ! com>
--------------------
On Wed, May 23, 2012 at 2:59 AM, Shakthi Kannan <shakthimaan@gmail.com> wrote:
>
> MAKEFLAGS+="--dry-run" make C=2 CHECK="c2xml > foo.xml"
> net/ethernet/eth.o > output.txt
>
> eval `tail -2 output.txt | head -1`
>

That is a great tip.

Thanks.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Using c2xml on kernel sources
Date: Wed, 23 May 2012 18:30:31 +0000
Message-ID: <CANeU7Q=QCY4mWRhCJ14MyRh_nr3hyP4Yw9M0nYDs8cw2UaxHCA () mail ! gmail ! com>
--------------------
On Wed, May 23, 2012 at 2:59 AM, Shakthi Kannan <shakthimaan@gmail.com> wrote:
>
> MAKEFLAGS+="--dry-run" make C=2 CHECK="c2xml > foo.xml"
> net/ethernet/eth.o > output.txt
>
> eval `tail -2 output.txt | head -1`
>

That is a great tip.

Thanks.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [GIT PULL] Sparse/LLVM updates ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] Sparse/LLVM updates
Date: Fri, 12 Oct 2012 02:34:04 +0000
Message-ID: <CANeU7Q=O_2UGjo0eUF=r4tqPFey0wpX3ww_g+6SiB_PeejAF-g () mail ! gmail ! com>
--------------------
The change looks good.

It is pull and updated on the github sparse repository.

Thanks

Chris

On Tue, Oct 9, 2012 at 11:35 PM, Pekka Enberg <penberg@kernel.org> wrote:
> Hi Chris,
>
> On Tue, Oct 9, 2012 at 9:34 AM, Pekka Enberg <penberg@kernel.org> wrote:
>> Hi Chris,
>>
>> Please pull the latest Sparse/LLVM tree from:
>>
>>   git@github.com:penberg/sparse-llvm.git llvm/core
>>
>> It contains few LLVM backend fixes from myself and Jonathan Neuschäfer.
>>
>>                         Pekka
>>
>> ------------------>
>
> I have added one more LLVM backend fix from Jonathan to the branch:
>
> The following changes since commit 063236fd3f46bc83b49172f5ecb597e0a91cede8:
>
>   ptrlist.c: fix a typo in a comment (2012-06-26 00:54:24 -0700)
>
> are available in the git repository at:
>   git@github.com:penberg/sparse-llvm.git llvm/core
>
> Jonathan Neuschäfer (3):
>       sparse, llvm: 'Verify' the LLVM module before writing it
>       sparse, llvm: convert the condition of branch/select to bool
>       sparse, llvm: Fix type of loaded values
>
> Pekka Enberg (2):
>       sparse, llvm: Fix SIGSEGV for extern symbols
>       sparse, llvm: Fix 'void' return type code generation
>
>  sparse-llvm.c                         |   38 ++++++++++++++++++++++++++++----
>  validation/backend/extern.c           |   11 +++++++++
>  validation/backend/int-cond.c         |   30 ++++++++++++++++++++++++++
>  validation/backend/load-type.c        |   12 ++++++++++
>  validation/backend/void-return-type.c |   13 +++++++++++
>  5 files changed, 99 insertions(+), 5 deletions(-)
>  create mode 100644 validation/backend/extern.c
>  create mode 100644 validation/backend/int-cond.c
>  create mode 100644 validation/backend/load-type.c
>  create mode 100644 validation/backend/void-return-type.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: [GIT PULL] Sparse/LLVM updates
Date: Tue, 09 Jul 2013 12:21:21 +0000
Message-ID: <CAOJsxLGSp7oPm8-qHEZvS4Oj=nfA2ZgnQAHwT762QxWSUj_JuQ () mail ! gmail ! com>
--------------------
Hi Chris,

Please consider pulling the latest Sparse/LLVM tree:

  git@github.com:penberg/sparse-llvm.git llvm/core

It has various LLVM backend fixes from Jonathan and Xi.

                        Pekka

------------------>

The following changes since commit 5449cfbfe55eea2a602a40122c122b5040d67243:

  Allow forced attribute in function argument (2013-04-26 08:27:41 -0700)

are available in the git repository at:

  git@github.com:penberg/sparse-llvm.git llvm/core

for you to fetch changes up to c0296d71405a97349d82e9909cad82a2af3271c2:

  Fix expression type for floating point negation ('!') (2013-05-27
14:15:56 +0300)

----------------------------------------------------------------
Jonathan Neuschäfer (4):
      sparse, llvm: Fix resulting type of store address calculations
      sparse, llvm: de-duplicate load/store address calculation code
      sparse, llvm: base load/store address type on insn_symbol_type()
      sparse, llvm: add a struct access test case

Pekka Enberg (1):
      sparse, llvm: Use LLVM_HOSTTRIPLE

Xi Wang (12):
      sparse, llvm: fix phi generation
      sparse, llvm: simplify function generation
      sparse, llvm: improve pointer arithmetic handling
      sparse, llvm: set target specification
      sparse, llvm: use LLVM_DEFAULT_TARGET_TRIPLE
      sparse, llvm: fix array size
      sparse, llvm: cache symbol_type() result
      sparse, llvm: fix struct name generation
      sparse, llvm: set more data attributes
      sparse, llvm: die if error
      Fix result type of relational and logical operators
      Fix expression type for floating point negation ('!')

 evaluate.c                         |  17 ++--
 lib.h                              |   2 +
 linearize.c                        |   4 +-
 sparse-llvm.c                      | 488
++++++++++++++++++++++++++++++++++++--------------------------------------------------------
 sparsei                            |  13 +++
 validation/backend/loop2.c         |  14 +++
 validation/backend/store-type.c    |  12 +++
 validation/backend/struct-access.c |  28 ++++++
 validation/backend/struct.c        |   6 ++
 validation/backend/sum.c           |  28 ++++++
 validation/cond_expr3.c            |  17 ++++
 11 files changed, 320 insertions(+), 309 deletions(-)
 create mode 100755 sparsei
 create mode 100644 validation/backend/loop2.c
 create mode 100644 validation/backend/store-type.c
 create mode 100644 validation/backend/struct-access.c
 create mode 100644 validation/backend/sum.c
 create mode 100644 validation/cond_expr3.c
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [GIT PULL] Sparse/LLVM updates
Date: Thu, 25 Jul 2013 16:43:22 +0000
Message-ID: <CANeU7Q=GuZZH8B_wpvUXG4o7TnyC_EZdevcWPq0TYJ2boiC=nw () mail ! gmail ! com>
--------------------
On Tue, Jul 9, 2013 at 5:21 AM, Pekka Enberg <penberg@kernel.org> wrote:
> Hi Chris,
>
> Please consider pulling the latest Sparse/LLVM tree:
>
>   git@github.com:penberg/sparse-llvm.git llvm/core
>
> It has various LLVM backend fixes from Jonathan and Xi.
>

I merge the branch and push at the chrisl repository. Please check if I make it
right. I will make it to the official repository soon.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/10] compiler-gcc4.h: correct verion check for __compiletime_error ===

From: Daniel Santos <daniel.santos () pobox ! com>
To: linux-kernel
Subject: [PATCH 1/10] compiler-gcc4.h: correct verion check for __compiletime_error
Date: Fri, 28 Sep 2012 23:20:02 +0000
Message-ID: <1348874411-28288-2-git-send-email-daniel.santos () pobox ! com>
--------------------
NOTE: this is has already been comitted to -mm

__attribute__((error(msg))) was introduced in gcc 4.3 (not 4.4) and as I
was unable to find any gcc bugs pertaining to it, I'm presuming that it
has functioned as advertised since 4.3.0.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Cc: Michal Marek <mmarek@suse.cz>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
---
 include/linux/compiler-gcc4.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 997fd8a..8721704 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -59,7 +59,7 @@
 #if __GNUC_MINOR__ > 0
 #define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
 #endif
-#if __GNUC_MINOR__ >= 4 && !defined(__CHECKER__)
+#if __GNUC_MINOR__ >= 3 && !defined(__CHECKER__)
 #define __compiletime_warning(message) __attribute__((warning(message)))
 #define __compiletime_error(message) __attribute__((error(message)))
 #endif
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: David Rientjes <rientjes () google ! com>
To: linux-sparse
Subject: Re: [PATCH 1/10] compiler-gcc4.h: correct verion check for __compiletime_error
Date: Wed, 03 Oct 2012 06:25:12 +0000
Message-ID: <alpine.DEB.2.00.1210022324430.12717 () chino ! kir ! corp ! google ! com>
--------------------
On Fri, 28 Sep 2012, Daniel Santos wrote:

> NOTE: this is has already been comitted to -mm
> 
> __attribute__((error(msg))) was introduced in gcc 4.3 (not 4.4) and as I
> was unable to find any gcc bugs pertaining to it, I'm presuming that it
> has functioned as advertised since 4.3.0.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Cc: Michal Marek <mmarek@suse.cz>
> Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

Tested-by: David Rientjes <rientjes@google.com>

Works with 4.3.6.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michal Marek <mmarek () suse ! cz>
To: linux-kernel
Subject: Re: [PATCH 1/10] compiler-gcc4.h: correct verion check for __compiletime_error
Date: Thu, 11 Oct 2012 20:54:03 +0000
Message-ID: <20121011205403.GF16465 () sepie ! suse ! cz>
--------------------
On Tue, Oct 02, 2012 at 11:25:12PM -0700, David Rientjes wrote:
> On Fri, 28 Sep 2012, Daniel Santos wrote:
> 
> > NOTE: this is has already been comitted to -mm
> > 
> > __attribute__((error(msg))) was introduced in gcc 4.3 (not 4.4) and as I
> > was unable to find any gcc bugs pertaining to it, I'm presuming that it
> > has functioned as advertised since 4.3.0.
> > 
> > Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> > Cc: Michal Marek <mmarek@suse.cz>
> > Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
> 
> Tested-by: David Rientjes <rientjes@google.com>
> 
> Works with 4.3.6.

Applied to kbuild.git#kbuild now.

Michal
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Michal Marek <mmarek () suse ! cz>
To: linux-sparse
Subject: Re: [PATCH 1/10] compiler-gcc4.h: correct verion check for __compiletime_error
Date: Thu, 11 Oct 2012 20:54:03 +0000
Message-ID: <20121011205403.GF16465 () sepie ! suse ! cz>
--------------------
On Tue, Oct 02, 2012 at 11:25:12PM -0700, David Rientjes wrote:
> On Fri, 28 Sep 2012, Daniel Santos wrote:
> 
> > NOTE: this is has already been comitted to -mm
> > 
> > __attribute__((error(msg))) was introduced in gcc 4.3 (not 4.4) and as I
> > was unable to find any gcc bugs pertaining to it, I'm presuming that it
> > has functioned as advertised since 4.3.0.
> > 
> > Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> > Cc: Michal Marek <mmarek@suse.cz>
> > Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
> 
> Tested-by: David Rientjes <rientjes@google.com>
> 
> Works with 4.3.6.

Applied to kbuild.git#kbuild now.

Michal
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB ===

From: =?UTF-8?q?Jonathan=20Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Tue, 09 Oct 2012 23:34:35 +0000
Message-ID: <1349825676-1713-1-git-send-email-j.neuschaefer () gmx ! net>
--------------------
This is required for producing valid LLVM bitcode.

Cc: Pekka Enberg <penberg@kernel.org>
Cc: Christopher Li <sparse@chrisli.org>
Cc: Jeff Garzik <jgarzik@redhat.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
---
 sparse-llvm.c              |   17 ++++++++++++++++-
 validation/backend/loop2.c |   13 +++++++++++++
 2 files changed, 29 insertions(+), 1 deletion(-)
 create mode 100644 validation/backend/loop2.c

diff --git a/sparse-llvm.c b/sparse-llvm.c
index 0fc0dae..2048a1b 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -1111,16 +1111,31 @@ static void output_insn(struct function *fn, struct instruction *insn)
 static void output_bb(struct function *fn, struct basic_block *bb, unsigned long generation)
 {
 	struct instruction *insn;
+	struct instruction_list *remaining = NULL;
 
 	bb->generation = generation;
 
+	/*
+	 * LLVM requires the phi instructions to be grouped at the top of each
+	 * basic block.
+	 */
+
 	FOR_EACH_PTR(bb->insns, insn) {
 		if (!insn->bb)
 			continue;
 
-		output_insn(fn, insn);
+		if (insn->opcode == OP_PHI)
+			output_insn(fn, insn);
+		else
+			add_instruction(&remaining, insn);
 	}
 	END_FOR_EACH_PTR(insn);
+
+	FOR_EACH_PTR(remaining, insn) {
+		output_insn(fn, insn);
+	} END_FOR_EACH_PTR(insn);
+
+	free_ptr_list(&remaining);
 }
 
 #define MAX_ARGS	64
diff --git a/validation/backend/loop2.c b/validation/backend/loop2.c
new file mode 100644
index 0000000..4e44a15
--- /dev/null
+++ b/validation/backend/loop2.c
@@ -0,0 +1,13 @@
+extern int op(void);
+
+static void test(void) {
+	int i;
+	for (i = 0; ; i++) {
+		op();
+	}
+}
+
+/*
+ * check-name: Loops with unused counter
+ * check-command: ./sparsec -c $file -o tmp.o
+ */
-- 
1.7.10.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Wed, 10 Oct 2012 06:31:31 +0000
Message-ID: <CAOJsxLF2AqK2N_R876jOOVmkHXyhe_OjyP_xfULUF5PAfKogMw () mail ! gmail ! com>
--------------------
On Wed, Oct 10, 2012 at 3:12 AM, Jeff Garzik <jgarzik@pobox.com> wrote:
> On 10/09/2012 07:34 PM, Jonathan Neuschäfer wrote:
>>
>> This is required for producing valid LLVM bitcode.
>>
>> Cc: Pekka Enberg <penberg@kernel.org>
>> Cc: Christopher Li <sparse@chrisli.org>
>> Cc: Jeff Garzik <jgarzik@redhat.com>
>> Cc: Linus Torvalds <torvalds@linux-foundation.org>
>> Signed-off-by: Jonathan Neuschäfer <j.neuschaefer@gmx.net>
>> ---
>>   sparse-llvm.c              |   17 ++++++++++++++++-
>>   validation/backend/loop2.c |   13 +++++++++++++
>>   2 files changed, 29 insertions(+), 1 deletion(-)
>>   create mode 100644 validation/backend/loop2.c
>
> Looks sane... but I did not verify whether or not this reordering is safe

Ditto. Jonathan, care to explain why you think it is safe? I still
don't know Sparse's linearized IR well enough to convince myself this
is OK.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Fri, 12 Oct 2012 18:25:42 +0000
Message-ID: <CAOJsxLE=UsuonXVPuDxL9jPGQj_M5xdvCUrk5u+m3U-s4Ao-hA () mail ! gmail ! com>
--------------------
On Wed, Oct 10, 2012 at 7:33 PM, Jonathan Neuschäfer
<j.neuschaefer@gmx.net> wrote:
> I can't say with certainty that it's safe either, so I probably should
> have marked the patch with "request for comments".
>
> AFAICT there are three reasons an instruction cannot be moved up or down
> within a basic block:
>  1. If it takes previous SSA values as arguments, it can't be moved
>     above the corresponding intructions.
>  2. If its value is used as an argument of an instruction further down
>     in the BB, it can't be moved below that instruction.
>  3. Swapping two instructions that influence or are influenced by the
>     "global state" (sorry for the loose wording), e.g. by doing memory
>     accesses, performing I/O, or calling functions (which in turn can
>     do about anything in general), is generally unsafe.
>
> Case 1 doesn't apply because PHI nodes don't use values computed in the
> same invocation of their basic block. Case 2 doesn't apply as I'm not
> moving the PHI nodes down. Case 3 doesn't seem to apply either.
>
> That's how I think this patch is safe.

Sounds plausible but I'm still uneasy with the idea that LLVM backend
needs to reshuffle instructions like this.

Would it be possible to solve this in the frontend?

                        Pekka
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Tue, 16 Oct 2012 17:59:27 +0000
Message-ID: <CAOJsxLEEBYMF4qcyBSpS7kaumzpQFm0McNexRtft3UJVwp==Xg () mail ! gmail ! com>
--------------------
On Fri, Oct 12, 2012 at 9:25 PM, Pekka Enberg <penberg@kernel.org> wrote:
> On Wed, Oct 10, 2012 at 7:33 PM, Jonathan Neuschäfer
> <j.neuschaefer@gmx.net> wrote:
>> I can't say with certainty that it's safe either, so I probably should
>> have marked the patch with "request for comments".
>>
>> AFAICT there are three reasons an instruction cannot be moved up or down
>> within a basic block:
>>  1. If it takes previous SSA values as arguments, it can't be moved
>>     above the corresponding intructions.
>>  2. If its value is used as an argument of an instruction further down
>>     in the BB, it can't be moved below that instruction.
>>  3. Swapping two instructions that influence or are influenced by the
>>     "global state" (sorry for the loose wording), e.g. by doing memory
>>     accesses, performing I/O, or calling functions (which in turn can
>>     do about anything in general), is generally unsafe.
>>
>> Case 1 doesn't apply because PHI nodes don't use values computed in the
>> same invocation of their basic block. Case 2 doesn't apply as I'm not
>> moving the PHI nodes down. Case 3 doesn't seem to apply either.
>>
>> That's how I think this patch is safe.
>
> Sounds plausible but I'm still uneasy with the idea that LLVM backend
> needs to reshuffle instructions like this.
>
> Would it be possible to solve this in the frontend?

Linus, Chris, any thoughts on this?
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Xi Wang <xi.wang () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Tue, 16 Oct 2012 20:53:48 +0000
Message-ID: <507DC95C.7010106 () gmail ! com>
--------------------
On 10/16/12 4:14 PM, Jonathan NeuschÃ¤fer wrote:
> Actually, the situation of Phi nodes in LLVM is actually slightly more
> complex: They require "one pair (of value and BB) for each predecessor
> basic block of the current block"[1]. This mean that we'll sometimes
> need to insert phi nodes into BBs that don't directly use a value.

I ran into the same problem before.  I would suggest a simpler and safer
way: don't emit LLVM phi; instead emit load/store (of some alloca).

phi    => load from some alloca
phisrc => store to some alloca

You can find sample code from splay here (emit_phi & emit_phisrc):

https://github.com/xiw/splay/blob/master/function.c#L356

> Consider the following piece of C code:
> 
> 	extern int done(void);
> 	extern void foo(int);
> 
> 	static void test(void) {
> 		int i;
> 		for (i = 0; ; i++) {
> 			if (done())
> 				break;
> 			foo(i);
> 		}
> 	}

This is what splay emits:

define internal void @test() {
entry:
  %0 = alloca i32
  store i32 0, i32* %0
  br label %bb

bb:                                               ; preds = %bb1, %entry
  %1 = call i32 @done()
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %bb2, label %bb1

bb1:                                              ; preds = %bb
  %3 = load i32* %0
  call void @foo(i32 %3)
  %4 = add nsw i32 %3, 1
  store i32 %4, i32* %0
  br label %bb

bb2:                                              ; preds = %bb
  ret void
}

After "-mem2reg" you get:

define internal void @test() {
entry:
  br label %bb

bb:                                               ; preds = %bb1, %entry
  %.0 = phi i32 [ 0, %entry ], [ %2, %bb1 ]
  %0 = call i32 @done()
  %1 = icmp ne i32 %0, 0
  br i1 %1, label %bb2, label %bb1

bb1:                                              ; preds = %bb
  call void @foo(i32 %.0)
  %2 = add nsw i32 %.0, 1
  br label %bb

bb2:                                              ; preds = %bb
  ret void
}

- xi
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Wed, 17 Oct 2012 06:48:17 +0000
Message-ID: <CAOJsxLFXaWXcR8vF_DFPAaJZPJ_BTe47Q9GSkM-2MChaRBqkdw () mail ! gmail ! com>
--------------------
On 10/16/12 4:14 PM, Jonathan Neuschäfer wrote:
>> Actually, the situation of Phi nodes in LLVM is actually slightly more
>> complex: They require "one pair (of value and BB) for each predecessor
>> basic block of the current block"[1]. This mean that we'll sometimes
>> need to insert phi nodes into BBs that don't directly use a value.

On Tue, Oct 16, 2012 at 11:53 PM, Xi Wang <xi.wang@gmail.com> wrote:
> I ran into the same problem before.  I would suggest a simpler and safer
> way: don't emit LLVM phi; instead emit load/store (of some alloca).
>
> phi    => load from some alloca
> phisrc => store to some alloca

Is LLVM able to optimize away the allocas and use registers instead in
the emitted code? If not, that means we'll spill and reload at every
basic block boundary...
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Xi Wang <xi.wang () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Wed, 17 Oct 2012 06:53:48 +0000
Message-ID: <507E55FC.5010202 () gmail ! com>
--------------------
On 10/17/12 2:48 AM, Pekka Enberg wrote:
> Is LLVM able to optimize away the allocas and use registers instead in
> the emitted code?

Yes.  See the last part of my previous email, no load/store/alloca after
LLVM's -mem2reg pass.

- xi
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Wed, 17 Oct 2012 16:41:52 +0000
Message-ID: <CAOJsxLGWCoskGTsKefWoCYPGuR_b5_QsMTnYkzTNX14t0HkKhg () mail ! gmail ! com>
--------------------
On 10/17/12 2:48 AM, Pekka Enberg wrote:
>> Is LLVM able to optimize away the allocas and use registers instead in
>> the emitted code?

On Wed, Oct 17, 2012 at 9:53 AM, Xi Wang <xi.wang@gmail.com> wrote:
> Yes.  See the last part of my previous email, no load/store/alloca after
> LLVM's -mem2reg pass.

Right. Jonathan, does Xi's suggestion sound reasonable to you? I'd
certainly prefer that over instruction reordering.

                                Pekka
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jonathan =?utf-8?Q?Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Wed, 17 Oct 2012 17:44:20 +0000
Message-ID: <20121017174420.GA2922 () debian ! debian>
--------------------
On Wed, Oct 17, 2012 at 07:41:52PM +0300, Pekka Enberg wrote:
> On 10/17/12 2:48 AM, Pekka Enberg wrote:
> >> Is LLVM able to optimize away the allocas and use registers instead in
> >> the emitted code?
> 
> On Wed, Oct 17, 2012 at 9:53 AM, Xi Wang <xi.wang@gmail.com> wrote:
> > Yes.  See the last part of my previous email, no load/store/alloca after
> > LLVM's -mem2reg pass.
> 
> Right. Jonathan, does Xi's suggestion sound reasonable to you? I'd
> certainly prefer that over instruction reordering.

It certainly does. Thanks, Xi!


Jonathan
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Wed, 15 May 2013 12:05:52 +0000
Message-ID: <CAOJsxLGizp=f5RziV2fKFR=wGQXWr+nvVZXLWGoeKa23gD_5Fw () mail ! gmail ! com>
--------------------
Hello,

On Tue, Oct 16, 2012 at 11:53 PM, Xi Wang <xi.wang@gmail.com> wrote:
> On 10/16/12 4:14 PM, Jonathan Neuschäfer wrote:
>> Actually, the situation of Phi nodes in LLVM is actually slightly more
>> complex: They require "one pair (of value and BB) for each predecessor
>> basic block of the current block"[1]. This mean that we'll sometimes
>> need to insert phi nodes into BBs that don't directly use a value.
>
> I ran into the same problem before.  I would suggest a simpler and safer
> way: don't emit LLVM phi; instead emit load/store (of some alloca).
>
> phi    => load from some alloca
> phisrc => store to some alloca
>
> You can find sample code from splay here (emit_phi & emit_phisrc):
>
> https://github.com/xiw/splay/blob/master/function.c#L356
>
>> Consider the following piece of C code:
>>
>>       extern int done(void);
>>       extern void foo(int);
>>
>>       static void test(void) {
>>               int i;
>>               for (i = 0; ; i++) {
>>                       if (done())
>>                               break;
>>                       foo(i);
>>               }
>>       }
>
> This is what splay emits:
>
> define internal void @test() {
> entry:
>   %0 = alloca i32
>   store i32 0, i32* %0
>   br label %bb
>
> bb:                                               ; preds = %bb1, %entry
>   %1 = call i32 @done()
>   %2 = icmp ne i32 %1, 0
>   br i1 %2, label %bb2, label %bb1
>
> bb1:                                              ; preds = %bb
>   %3 = load i32* %0
>   call void @foo(i32 %3)
>   %4 = add nsw i32 %3, 1
>   store i32 %4, i32* %0
>   br label %bb
>
> bb2:                                              ; preds = %bb
>   ret void
> }
>
> After "-mem2reg" you get:
>
> define internal void @test() {
> entry:
>   br label %bb
>
> bb:                                               ; preds = %bb1, %entry
>   %.0 = phi i32 [ 0, %entry ], [ %2, %bb1 ]
>   %0 = call i32 @done()
>   %1 = icmp ne i32 %0, 0
>   br i1 %1, label %bb2, label %bb1
>
> bb1:                                              ; preds = %bb
>   call void @foo(i32 %.0)
>   %2 = add nsw i32 %.0, 1
>   br label %bb
>
> bb2:                                              ; preds = %bb
>   ret void
> }

Ping, anyone interested in turning Xi's suggestion into a patch
against current sparse master?

                        Pekka
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Xi Wang <xi.wang () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 1/2] sparse, llvm: group PHI nodes at the top of each BB
Date: Thu, 16 May 2013 05:28:56 +0000
Message-ID: <CAKU6vybB7MVaxL1uoFCR1k3kNHQBSmOfoDVxTD0i+v3hoCRE9A () mail ! gmail ! com>
--------------------
On Wed, May 15, 2013 at 8:05 AM, Pekka Enberg <penberg@kernel.org> wrote:
> Ping, anyone interested in turning Xi's suggestion into a patch
> against current sparse master?

I'll send a patch.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] ptrlist.c: fix a typo in a comment ===

From: =?UTF-8?q?Jonathan=20Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: [PATCH 2/2] ptrlist.c: fix a typo in a comment
Date: Mon, 18 Jun 2012 21:39:21 +0000
Message-ID: <1340055561-28496-2-git-send-email-j.neuschaefer () gmx ! net>
--------------------
Signed-off-by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
---
 ptrlist.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ptrlist.c b/ptrlist.c
index 2620412..5dc1117 100644
--- a/ptrlist.c
+++ b/ptrlist.c
@@ -35,7 +35,7 @@ int ptr_list_size(struct ptr_list *head)
  *
  * The array to linearize into (second argument) should really
  * be "void *x[]", but we want to let people fill in any kind
- * of pointer array, so let's just call it "void *".
+ * of pointer array, so let's just call it "void **".
  */
 int linearize_ptr_list(struct ptr_list *head, void **arr, int max)
 {
-- 
1.7.10.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] ptrlist.c: fix a typo in a comment
Date: Tue, 26 Jun 2012 07:55:40 +0000
Message-ID: <CANeU7QnOaUgk7LiKyWkHq82R5JxwP9Sh-2Hqz2odZX5yMqzH5A () mail ! gmail ! com>
--------------------
On Mon, Jun 18, 2012 at 2:39 PM, Jonathan Neuschäfer
<j.neuschaefer@gmx.net> wrote:
> Signed-off-by: Jonathan Neuschäfer <j.neuschaefer@gmx.net>

Both 1 and 2 applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Mauro Dreissig <mukadr () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] ptrlist.c: fix a typo in a comment
Date: Thu, 02 Aug 2012 02:59:27 +0000
Message-ID: <5019ED0F.6080507 () gmail ! com>
--------------------
On 06/18/2012 06:39 PM, Jonathan NeuschÃ¤fer wrote:
> Signed-off-by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
> ---
>  ptrlist.c |    2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
> 
> diff --git a/ptrlist.c b/ptrlist.c
> index 2620412..5dc1117 100644
> --- a/ptrlist.c
> +++ b/ptrlist.c
> @@ -35,7 +35,7 @@ int ptr_list_size(struct ptr_list *head)
>   *
>   * The array to linearize into (second argument) should really
>   * be "void *x[]", but we want to let people fill in any kind
> - * of pointer array, so let's just call it "void *".
> + * of pointer array, so let's just call it "void **".
>   */
>  int linearize_ptr_list(struct ptr_list *head, void **arr, int max)
>  {
> 

Hi!

It looks like the comment was left there by mistake. I belive the idea
was to call the second argument void * to avoid warnings when passing
other_type ** to the function without having to cast it to void **.

Reading the comment now only gives the idea that declaring the argument
as void ** instead of void *[] gives different semantics, which is not the case. 

Mauro
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Mauro Dreissig <mukadr () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] ptrlist.c: fix a typo in a comment
Date: Thu, 02 Aug 2012 14:56:34 +0000
Message-ID: <501A9522.8030802 () gmail ! com>
--------------------
On 08/01/2012 11:59 PM, Mauro Dreissig wrote:
> On 06/18/2012 06:39 PM, Jonathan NeuschÃ¤fer wrote:
>> Signed-off-by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
>> ---
>>  ptrlist.c |    2 +-
>>  1 file changed, 1 insertion(+), 1 deletion(-)
>>
>> diff --git a/ptrlist.c b/ptrlist.c
>> index 2620412..5dc1117 100644
>> --- a/ptrlist.c
>> +++ b/ptrlist.c
>> @@ -35,7 +35,7 @@ int ptr_list_size(struct ptr_list *head)
>>   *
>>   * The array to linearize into (second argument) should really
>>   * be "void *x[]", but we want to let people fill in any kind
>> - * of pointer array, so let's just call it "void *".
>> + * of pointer array, so let's just call it "void **".
>>   */
>>  int linearize_ptr_list(struct ptr_list *head, void **arr, int max)
>>  {
>>
> 
> Hi!
> 
> It looks like the comment was left there by mistake. I belive the idea
> was to call the second argument void * to avoid warnings when passing
> other_type ** to the function without having to cast it to void **.
> 
> Reading the comment now only gives the idea that declaring the argument
> as void ** instead of void *[] gives different semantics, which is not the case. 
> 
> Mauro
> 

Ah, I think I get it.. You cant cast something to "void *[]". sry :P
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH 2/2] sparse, llvm: Fix type of loaded values ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [PATCH 2/2] sparse, llvm: Fix type of loaded values
Date: Wed, 10 Oct 2012 00:13:18 +0000
Message-ID: <5074BD9E.9030002 () pobox ! com>
--------------------
On 10/09/2012 07:34 PM, Jonathan NeuschÃ¤fer wrote:
> Instead of making the computed address a pointer to an int type
> large enough to hold a pointer, make it a pointer to the memory
> object being loaded.  This fixes another LLVM warning.
>
> Cc: Pekka Enberg <penberg@kernel.org>
> Cc: Christopher Li <sparse@chrisli.org>
> Cc: Jeff Garzik <jgarzik@redhat.com>
> Cc: Linus Torvalds <torvalds@linux-foundation.org>
> Signed-off-by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
> ---
>   sparse-llvm.c                  |    2 +-
>   validation/backend/load-type.c |   12 ++++++++++++
>   2 files changed, 13 insertions(+), 1 deletion(-)
>   create mode 100644 validation/backend/load-type.c

Acked-by: Jeff Garzik <jgarzik@redhat.com>



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH 2/2] sparse, llvm: Fix type of loaded values
Date: Wed, 10 Oct 2012 06:34:21 +0000
Message-ID: <CAOJsxLGQSGXptwNU36XNvLHNmb1EAYngxavRvvRnQyF95A_=YQ () mail ! gmail ! com>
--------------------
On Wed, Oct 10, 2012 at 3:13 AM, Jeff Garzik <jgarzik@pobox.com> wrote:
> On 10/09/2012 07:34 PM, Jonathan Neuschäfer wrote:
>>
>> Instead of making the computed address a pointer to an int type
>> large enough to hold a pointer, make it a pointer to the memory
>> object being loaded.  This fixes another LLVM warning.
>>
>> Cc: Pekka Enberg <penberg@kernel.org>
>> Cc: Christopher Li <sparse@chrisli.org>
>> Cc: Jeff Garzik <jgarzik@redhat.com>
>> Cc: Linus Torvalds <torvalds@linux-foundation.org>
>> Signed-off-by: Jonathan Neuschäfer <j.neuschaefer@gmx.net>
>> ---
>>   sparse-llvm.c                  |    2 +-
>>   validation/backend/load-type.c |   12 ++++++++++++
>>   2 files changed, 13 insertions(+), 1 deletion(-)
>>   create mode 100644 validation/backend/load-type.c
>
> Acked-by: Jeff Garzik <jgarzik@redhat.com>

Applied, thanks!
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Fri, 05 Oct 2012 19:42:40 +0000
Message-ID: <1349466169-20637-1-git-send-email-daniel.santos () pobox ! com>
--------------------
This helps to keep the file from getting confusing, removes one
duplicate version check and should encourage future editors to put new
macros where they belong.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc4.h |   20 +++++++++++---------
 1 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 8721704..4506d65 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -13,6 +13,10 @@
 #define __must_check 		__attribute__((warn_unused_result))
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
 
+#if __GNUC_MINOR__ > 0
+# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
+#endif
+
 #if __GNUC_MINOR__ >= 3
 /* Mark functions as cold. gcc will assume any path leading to a call
    to them will be unlikely.  This means a lot of manual unlikely()s
@@ -31,6 +35,12 @@
 
 #define __linktime_error(message) __attribute__((__error__(message)))
 
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+#endif /* __GNUC_MINOR__ >= 3 */
+
 #if __GNUC_MINOR__ >= 5
 /*
  * Mark a position in code as unreachable.  This can be used to
@@ -46,8 +56,7 @@
 /* Mark a function definition as prohibited from being cloned. */
 #define __noclone	__attribute__((__noclone__))
 
-#endif
-#endif
+#endif /* __GNUC_MINOR__ >= 5 */
 
 #if __GNUC_MINOR__ >= 6
 /*
@@ -56,10 +65,3 @@
 #define __visible __attribute__((externally_visible))
 #endif
 
-#if __GNUC_MINOR__ > 0
-#define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
-#endif
-#if __GNUC_MINOR__ >= 3 && !defined(__CHECKER__)
-#define __compiletime_warning(message) __attribute__((warning(message)))
-#define __compiletime_error(message) __attribute__((error(message)))
-#endif
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Sat, 06 Oct 2012 17:42:20 +0000
Message-ID: <20121006174220.GB6110 () liondog ! tnic>
--------------------
On Fri, Oct 05, 2012 at 02:42:40PM -0500, danielfsantos@att.net wrote:
> This helps to keep the file from getting confusing, removes one
> duplicate version check and should encourage future editors to put new
> macros where they belong.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>
> ---
>  include/linux/compiler-gcc4.h |   20 +++++++++++---------
>  1 files changed, 11 insertions(+), 9 deletions(-)
> 
> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 8721704..4506d65 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -13,6 +13,10 @@
>  #define __must_check 		__attribute__((warn_unused_result))
>  #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
>  
> +#if __GNUC_MINOR__ > 0
> +# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
> +#endif
> +
>  #if __GNUC_MINOR__ >= 3
>  /* Mark functions as cold. gcc will assume any path leading to a call
>     to them will be unlikely.  This means a lot of manual unlikely()s
> @@ -31,6 +35,12 @@
>  
>  #define __linktime_error(message) __attribute__((__error__(message)))
>  
> +#ifndef __CHECKER__
> +# define __compiletime_warning(message) __attribute__((warning(message)))
> +# define __compiletime_error(message) __attribute__((error(message)))
> +#endif /* __CHECKER__ */
> +#endif /* __GNUC_MINOR__ >= 3 */
> +
>  #if __GNUC_MINOR__ >= 5
>  /*
>   * Mark a position in code as unreachable.  This can be used to
> @@ -46,8 +56,7 @@
>  /* Mark a function definition as prohibited from being cloned. */
>  #define __noclone	__attribute__((__noclone__))
>  
> -#endif
> -#endif
> +#endif /* __GNUC_MINOR__ >= 5 */
>  
>  #if __GNUC_MINOR__ >= 6
>  /*
> @@ -56,10 +65,3 @@
>  #define __visible __attribute__((externally_visible))
>  #endif
>  
> -#if __GNUC_MINOR__ > 0
> -#define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
> -#endif
> -#if __GNUC_MINOR__ >= 3 && !defined(__CHECKER__)

This last hunk doesn't apply since mainline has a "4" above instead of
"3". And it has had a "4" since it got added by 4a3127693001c so unless
I'm missing something, how did the 3 appear in your patches?

> -#define __compiletime_warning(message) __attribute__((warning(message)))
> -#define __compiletime_error(message) __attribute__((error(message)))
> -#endif
> -- 
> 1.7.3.4

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Sat, 06 Oct 2012 17:42:20 +0000
Message-ID: <20121006174220.GB6110 () liondog ! tnic>
--------------------
On Fri, Oct 05, 2012 at 02:42:40PM -0500, danielfsantos@att.net wrote:
> This helps to keep the file from getting confusing, removes one
> duplicate version check and should encourage future editors to put new
> macros where they belong.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>
> ---
>  include/linux/compiler-gcc4.h |   20 +++++++++++---------
>  1 files changed, 11 insertions(+), 9 deletions(-)
> 
> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 8721704..4506d65 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -13,6 +13,10 @@
>  #define __must_check 		__attribute__((warn_unused_result))
>  #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
>  
> +#if __GNUC_MINOR__ > 0
> +# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
> +#endif
> +
>  #if __GNUC_MINOR__ >= 3
>  /* Mark functions as cold. gcc will assume any path leading to a call
>     to them will be unlikely.  This means a lot of manual unlikely()s
> @@ -31,6 +35,12 @@
>  
>  #define __linktime_error(message) __attribute__((__error__(message)))
>  
> +#ifndef __CHECKER__
> +# define __compiletime_warning(message) __attribute__((warning(message)))
> +# define __compiletime_error(message) __attribute__((error(message)))
> +#endif /* __CHECKER__ */
> +#endif /* __GNUC_MINOR__ >= 3 */
> +
>  #if __GNUC_MINOR__ >= 5
>  /*
>   * Mark a position in code as unreachable.  This can be used to
> @@ -46,8 +56,7 @@
>  /* Mark a function definition as prohibited from being cloned. */
>  #define __noclone	__attribute__((__noclone__))
>  
> -#endif
> -#endif
> +#endif /* __GNUC_MINOR__ >= 5 */
>  
>  #if __GNUC_MINOR__ >= 6
>  /*
> @@ -56,10 +65,3 @@
>  #define __visible __attribute__((externally_visible))
>  #endif
>  
> -#if __GNUC_MINOR__ > 0
> -#define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
> -#endif
> -#if __GNUC_MINOR__ >= 3 && !defined(__CHECKER__)

This last hunk doesn't apply since mainline has a "4" above instead of
"3". And it has had a "4" since it got added by 4a3127693001c so unless
I'm missing something, how did the 3 appear in your patches?

> -#define __compiletime_warning(message) __attribute__((warning(message)))
> -#define __compiletime_error(message) __attribute__((error(message)))
> -#endif
> -- 
> 1.7.3.4

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Sat, 06 Oct 2012 17:54:07 +0000
Message-ID: <5070703F.8050004 () att ! net>
--------------------
On 10/06/2012 12:42 PM, Borislav Petkov wrote:
>> @@ -56,10 +65,3 @@
>>  #define __visible __attribute__((externally_visible))
>>  #endif
>>  
>> -#if __GNUC_MINOR__ > 0
>> -#define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
>> -#endif
>> -#if __GNUC_MINOR__ >= 3 && !defined(__CHECKER__)
>
> This last hunk doesn't apply since mainline has a "4" above instead of
> "3". And it has had a "4" since it got added by 4a3127693001c so unless
> I'm missing something, how did the 3 appear in your patches?
These are based against -mm, where another commit is already in that
changes it.  I was told that since that commit was already in -mm, to
not include it in the patch set:

6c620cf1536a0ce6a83ecaaaf05298dcc0f7d440 (committed 2012-09-27)

This was probably (at least partially) the result of the fiasco I had
with my email.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Sat, 06 Oct 2012 17:54:07 +0000
Message-ID: <5070703F.8050004 () att ! net>
--------------------
On 10/06/2012 12:42 PM, Borislav Petkov wrote:
>> @@ -56,10 +65,3 @@
>>  #define __visible __attribute__((externally_visible))
>>  #endif
>>  
>> -#if __GNUC_MINOR__ > 0
>> -#define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
>> -#endif
>> -#if __GNUC_MINOR__ >= 3 && !defined(__CHECKER__)
>
> This last hunk doesn't apply since mainline has a "4" above instead of
> "3". And it has had a "4" since it got added by 4a3127693001c so unless
> I'm missing something, how did the 3 appear in your patches?
These are based against -mm, where another commit is already in that
changes it.  I was told that since that commit was already in -mm, to
not include it in the patch set:

6c620cf1536a0ce6a83ecaaaf05298dcc0f7d440 (committed 2012-09-27)

This was probably (at least partially) the result of the fiasco I had
with my email.

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: David Rientjes <rientjes () google ! com>
To: linux-kernel
Subject: Re: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Thu, 18 Oct 2012 02:26:58 +0000
Message-ID: <alpine.DEB.2.00.1210171926230.30443 () chino ! kir ! corp ! google ! com>
--------------------
On Sat, 6 Oct 2012, Daniel Santos wrote:

> These are based against -mm, where another commit is already in that
> changes it.  I was told that since that commit was already in -mm, to
> not include it in the patch set:
> 
> 6c620cf1536a0ce6a83ecaaaf05298dcc0f7d440 (committed 2012-09-27)
> 
> This was probably (at least partially) the result of the fiasco I had
> with my email.
> 

Yeah, this patch applies fine on linux-next, which is the correct thing to 
do if you're building upon already queued patches.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: David Rientjes <rientjes () google ! com>
To: linux-sparse
Subject: Re: [PATCH v2 01/10] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Thu, 18 Oct 2012 02:26:58 +0000
Message-ID: <alpine.DEB.2.00.1210171926230.30443 () chino ! kir ! corp ! google ! com>
--------------------
On Sat, 6 Oct 2012, Daniel Santos wrote:

> These are based against -mm, where another commit is already in that
> changes it.  I was told that since that commit was already in -mm, to
> not include it in the patch set:
> 
> 6c620cf1536a0ce6a83ecaaaf05298dcc0f7d440 (committed 2012-09-27)
> 
> This was probably (at least partially) the result of the fiasco I had
> with my email.
> 

Yeah, this patch applies fine on linux-next, which is the correct thing to 
do if you're building upon already queued patches.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-kernel
Subject: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Fri, 05 Oct 2012 19:42:42 +0000
Message-ID: <1349466169-20637-3-git-send-email-daniel.santos () pobox ! com>
--------------------
Using GCC_VERSION reduces complexity, is easier to read and is GCC's
recommended mechanism for doing version checks. (Just don't ask me why
they didn't define it in the first place.)  This also makes it easy to
merge compiler-gcc{,3,4}.h should somebody want to.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc3.h |    8 ++++----
 include/linux/compiler-gcc4.h |   14 +++++++-------
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
index 37d4124..7d89feb 100644
--- a/include/linux/compiler-gcc3.h
+++ b/include/linux/compiler-gcc3.h
@@ -2,22 +2,22 @@
 #error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
 #endif
 
-#if __GNUC_MINOR__ < 2
+#if GCC_VERSION < 30200
 # error Sorry, your compiler is too old - please upgrade it.
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 30300
 # define __used			__attribute__((__used__))
 #else
 # define __used			__attribute__((__unused__))
 #endif
 
-#if __GNUC_MINOR__ >= 4
+#if GCC_VERSION >= 30400
 #define __must_check		__attribute__((warn_unused_result))
 #endif
 
 #ifdef CONFIG_GCOV_KERNEL
-# if __GNUC_MINOR__ < 4
+# if GCC_VERSION < 30400
 #   error "GCOV profiling support for gcc versions below 3.4 not included"
 # endif /* __GNUC_MINOR__ */
 #endif /* CONFIG_GCOV_KERNEL */
diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 4506d65..bbfeb13 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -4,7 +4,7 @@
 
 /* GCC 4.1.[01] miscompiles __weak */
 #ifdef __KERNEL__
-# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
+# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
 //#  error Your version of gcc miscompiles the __weak directive
 # endif
 #endif
@@ -13,11 +13,11 @@
 #define __must_check 		__attribute__((warn_unused_result))
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
 
-#if __GNUC_MINOR__ > 0
+#if GCC_VERSION >= 40100
 # define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 40300
 /* Mark functions as cold. gcc will assume any path leading to a call
    to them will be unlikely.  This means a lot of manual unlikely()s
    are unnecessary now for any paths leading to the usual suspects
@@ -39,9 +39,9 @@
 # define __compiletime_warning(message) __attribute__((warning(message)))
 # define __compiletime_error(message) __attribute__((error(message)))
 #endif /* __CHECKER__ */
-#endif /* __GNUC_MINOR__ >= 3 */
+#endif /* GCC_VERSION >= 40300 */
 
-#if __GNUC_MINOR__ >= 5
+#if GCC_VERSION >= 40500
 /*
  * Mark a position in code as unreachable.  This can be used to
  * suppress control flow warnings after asm blocks that transfer
@@ -56,9 +56,9 @@
 /* Mark a function definition as prohibited from being cloned. */
 #define __noclone	__attribute__((__noclone__))
 
-#endif /* __GNUC_MINOR__ >= 5 */
+#endif /* GCC_VERSION >= 40500 */
 
-#if __GNUC_MINOR__ >= 6
+#if GCC_VERSION >= 40600
 /*
  * Tell the optimizer that something else uses this function or variable.
  */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sat, 06 Oct 2012 23:05:59 +0000
Message-ID: <20121006230559.GA3278 () liondog ! tnic>
--------------------
On Fri, Oct 05, 2012 at 02:42:42PM -0500, danielfsantos@att.net wrote:
> Using GCC_VERSION reduces complexity, is easier to read and is GCC's
> recommended mechanism for doing version checks. (Just don't ask me why
> they didn't define it in the first place.)  This also makes it easy to
> merge compiler-gcc{,3,4}.h should somebody want to.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>

Looks correct to me:

Acked-by: Borislav Petkov <bp@alien8.de>

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sat, 06 Oct 2012 23:05:59 +0000
Message-ID: <20121006230559.GA3278 () liondog ! tnic>
--------------------
On Fri, Oct 05, 2012 at 02:42:42PM -0500, danielfsantos@att.net wrote:
> Using GCC_VERSION reduces complexity, is easier to read and is GCC's
> recommended mechanism for doing version checks. (Just don't ask me why
> they didn't define it in the first place.)  This also makes it easy to
> merge compiler-gcc{,3,4}.h should somebody want to.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>

Looks correct to me:

Acked-by: Borislav Petkov <bp@alien8.de>

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sat, 06 Oct 2012 23:10:41 +0000
Message-ID: <20121006231041.GB3278 () liondog ! tnic>
--------------------
On Fri, Oct 05, 2012 at 02:42:42PM -0500, danielfsantos@att.net wrote:
> Using GCC_VERSION reduces complexity, is easier to read and is GCC's
> recommended mechanism for doing version checks. (Just don't ask me why
> they didn't define it in the first place.)  This also makes it easy to
> merge compiler-gcc{,3,4}.h should somebody want to.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>
> ---

[ â¦ ]

> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 4506d65..bbfeb13 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -4,7 +4,7 @@
>  
>  /* GCC 4.1.[01] miscompiles __weak */
>  #ifdef __KERNEL__
> -# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> +# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
>  //#  error Your version of gcc miscompiles the __weak directive

Did I miss something again? This "error" preprocessor function is
commented out here? Why?

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sat, 06 Oct 2012 23:10:41 +0000
Message-ID: <20121006231041.GB3278 () liondog ! tnic>
--------------------
On Fri, Oct 05, 2012 at 02:42:42PM -0500, danielfsantos@att.net wrote:
> Using GCC_VERSION reduces complexity, is easier to read and is GCC's
> recommended mechanism for doing version checks. (Just don't ask me why
> they didn't define it in the first place.)  This also makes it easy to
> merge compiler-gcc{,3,4}.h should somebody want to.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>
> ---

[ â¦ ]

> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 4506d65..bbfeb13 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -4,7 +4,7 @@
>  
>  /* GCC 4.1.[01] miscompiles __weak */
>  #ifdef __KERNEL__
> -# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> +# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
>  //#  error Your version of gcc miscompiles the __weak directive

Did I miss something again? This "error" preprocessor function is
commented out here? Why?

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sun, 07 Oct 2012 18:27:58 +0000
Message-ID: <5071C9AE.2010106 () att ! net>
--------------------
On 10/06/2012 06:10 PM, Borislav Petkov wrote:
> On Fri, Oct 05, 2012 at 02:42:42PM -0500, danielfsantos@att.net wrote:
>> Using GCC_VERSION reduces complexity, is easier to read and is GCC's
>> recommended mechanism for doing version checks. (Just don't ask me why
>> they didn't define it in the first place.)  This also makes it easy to
>> merge compiler-gcc{,3,4}.h should somebody want to.
>>
>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>> Acked-by: David Rientjes <rientjes@google.com>
>> ---
>
> [ â¦ ]
>
>> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
>> index 4506d65..bbfeb13 100644
>> --- a/include/linux/compiler-gcc4.h
>> +++ b/include/linux/compiler-gcc4.h
>> @@ -4,7 +4,7 @@
>>  
>>  /* GCC 4.1.[01] miscompiles __weak */
>>  #ifdef __KERNEL__
>> -# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
>> +# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
>>  //#  error Your version of gcc miscompiles the __weak directive
>
> Did I miss something again? This "error" preprocessor function is
> commented out here? Why?
We'll have to ask Andrew.  Maybe so he can test on those versions of gcc?

commit d3ffe64a1dbcfe18b57f90f7c01c40c93d0a8b92
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Sep 28 00:02:42 2012 +0000

    a
   
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 934bc34..997fd8a 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -5,7 +5,7 @@
 /* GCC 4.1.[01] miscompiles __weak */
 #ifdef __KERNEL__
 # if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
-#  error Your version of gcc miscompiles the __weak directive
+//#  error Your version of gcc miscompiles the __weak directive
 # endif
 #endif


I can provide you a version of these patches rebased against Linus if
you like, which I am using to test since the -mm & -next trees aren't
working on my machine (hardware, .config and/or LVM/RAID setup). I
haven't put Walken's patches underneath them however.


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sun, 07 Oct 2012 19:42:59 +0000
Message-ID: <20121007194259.GA25313 () liondog ! tnic>
--------------------
On Sun, Oct 07, 2012 at 01:27:58PM -0500, Daniel Santos wrote:
> > Did I miss something again? This "error" preprocessor function is
> > commented out here? Why?
> We'll have to ask Andrew.  Maybe so he can test on those versions of gcc?
> 
> commit d3ffe64a1dbcfe18b57f90f7c01c40c93d0a8b92
> Author: Andrew Morton <akpm@linux-foundation.org>
> Date:   Fri Sep 28 00:02:42 2012 +0000
> 
>     a
>    
>     Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
> 
> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 934bc34..997fd8a 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -5,7 +5,7 @@
>  /* GCC 4.1.[01] miscompiles __weak */
>  #ifdef __KERNEL__
>  # if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> -#  error Your version of gcc miscompiles the __weak directive
> +//#  error Your version of gcc miscompiles the __weak directive
>  # endif
>  #endif

Ah, interesting. I think akpm has been redoing -mm couple times recently
so you probably caught a temporary thing.

> I can provide you a version of these patches rebased against Linus if
> you like, which I am using to test since the -mm & -next trees aren't
> working on my machine (hardware, .config and/or LVM/RAID setup). I
> haven't put Walken's patches underneath them however.

Nah, not necessary. I'd simply wait after the merge window closes and
everything settles down and then crank out a patchset against one of
the major trees (say -mm, linus or -next) so we can agree on the final
versions. AFAICT, the general design is fine - it's just the details
that need to be hammered out with precision.

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sun, 07 Oct 2012 20:21:27 +0000
Message-ID: <5071E447.8030404 () att ! net>
--------------------
On 10/07/2012 02:42 PM, Borislav Petkov wrote:
> On Sun, Oct 07, 2012 at 01:27:58PM -0500, Daniel Santos wrote:
>>> Did I miss something again? This "error" preprocessor function is
>>> commented out here? Why?
>> We'll have to ask Andrew.  Maybe so he can test on those versions of gcc?
>>
>> commit d3ffe64a1dbcfe18b57f90f7c01c40c93d0a8b92
>> Author: Andrew Morton <akpm@linux-foundation.org>
>> Date:   Fri Sep 28 00:02:42 2012 +0000
>>
>>     a
>>    
>>     Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
>>
>> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
>> index 934bc34..997fd8a 100644
>> --- a/include/linux/compiler-gcc4.h
>> +++ b/include/linux/compiler-gcc4.h
>> @@ -5,7 +5,7 @@
>>  /* GCC 4.1.[01] miscompiles __weak */
>>  #ifdef __KERNEL__
>>  # if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
>> -#  error Your version of gcc miscompiles the __weak directive
>> +//#  error Your version of gcc miscompiles the __weak directive
>>  # endif
>>  #endif
>
> Ah, interesting. I think akpm has been redoing -mm couple times recently
> so you probably caught a temporary thing.

I was guessing something like that, but I figured he had a reason for
doing it so I didn't dare ask the master! :)

>
>> I can provide you a version of these patches rebased against Linus if
>> you like, which I am using to test since the -mm & -next trees aren't
>> working on my machine (hardware, .config and/or LVM/RAID setup). I
>> haven't put Walken's patches underneath them however.
>
> Nah, not necessary. I'd simply wait after the merge window closes and
> everything settles down and then crank out a patchset against one of
> the major trees (say -mm, linus or -next) so we can agree on the final
> versions. AFAICT, the general design is fine - it's just the details
> that need to be hammered out with precision.
>
> Thanks.
If I had more time & energy for this part, I would try to find all uses
of BUILD_BUG_ON with __builtin_const_p, remove the __OPTIMIZE__ check
from BUILD_BUG_ON, put my BUILD_BUG_ON_NON_CONST macros back into this
patch set and adjust any other code in the kernel to not fail
un-optimized.  Also, I would figure out the reason for this commented
out check (arch/powerpc/kvm/timing.h:52):

    /* The BUILD_BUG_ON below breaks in funny ways, commented out
     * for now ... -BenH
    BUILD_BUG_ON(!__builtin_constant_p(type));
    */

and correct it with the appropriate new macro.  However, one of my
biggest problems is staying on task, perhaps partially due to having
ADHD.  In fact, *this* project (the generic red-black trees) got started
when I was exploring the possibilities of running parts of Wine in the
kernel, when I was dismayed by the lack of genericity in the kernel's
red-black tree code, so it's actually a tangent! :)  Don't get me wrong,
I don't regret it.  It has been a marvelous adventure in the
possibilities of the C language on modern compilers.  But after I finish
this up, I plan on writing up a paper on the "C metaprogramming"
techniques I seem to have discovered and then getting back to my Wine
project.  There are many other nify compile-time tricks that I
discovered in the exploration process that I didn't need to use here,
but which are worth documenting.

So basically, I know that I need to try to get this thing wrapped up.

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Sun, 07 Oct 2012 20:21:27 +0000
Message-ID: <5071E447.8030404 () att ! net>
--------------------
On 10/07/2012 02:42 PM, Borislav Petkov wrote:
> On Sun, Oct 07, 2012 at 01:27:58PM -0500, Daniel Santos wrote:
>>> Did I miss something again? This "error" preprocessor function is
>>> commented out here? Why?
>> We'll have to ask Andrew.  Maybe so he can test on those versions of gcc?
>>
>> commit d3ffe64a1dbcfe18b57f90f7c01c40c93d0a8b92
>> Author: Andrew Morton <akpm@linux-foundation.org>
>> Date:   Fri Sep 28 00:02:42 2012 +0000
>>
>>     a
>>    
>>     Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
>>
>> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
>> index 934bc34..997fd8a 100644
>> --- a/include/linux/compiler-gcc4.h
>> +++ b/include/linux/compiler-gcc4.h
>> @@ -5,7 +5,7 @@
>>  /* GCC 4.1.[01] miscompiles __weak */
>>  #ifdef __KERNEL__
>>  # if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
>> -#  error Your version of gcc miscompiles the __weak directive
>> +//#  error Your version of gcc miscompiles the __weak directive
>>  # endif
>>  #endif
>
> Ah, interesting. I think akpm has been redoing -mm couple times recently
> so you probably caught a temporary thing.

I was guessing something like that, but I figured he had a reason for
doing it so I didn't dare ask the master! :)

>
>> I can provide you a version of these patches rebased against Linus if
>> you like, which I am using to test since the -mm & -next trees aren't
>> working on my machine (hardware, .config and/or LVM/RAID setup). I
>> haven't put Walken's patches underneath them however.
>
> Nah, not necessary. I'd simply wait after the merge window closes and
> everything settles down and then crank out a patchset against one of
> the major trees (say -mm, linus or -next) so we can agree on the final
> versions. AFAICT, the general design is fine - it's just the details
> that need to be hammered out with precision.
>
> Thanks.
If I had more time & energy for this part, I would try to find all uses
of BUILD_BUG_ON with __builtin_const_p, remove the __OPTIMIZE__ check
from BUILD_BUG_ON, put my BUILD_BUG_ON_NON_CONST macros back into this
patch set and adjust any other code in the kernel to not fail
un-optimized.  Also, I would figure out the reason for this commented
out check (arch/powerpc/kvm/timing.h:52):

    /* The BUILD_BUG_ON below breaks in funny ways, commented out
     * for now ... -BenH
    BUILD_BUG_ON(!__builtin_constant_p(type));
    */

and correct it with the appropriate new macro.  However, one of my
biggest problems is staying on task, perhaps partially due to having
ADHD.  In fact, *this* project (the generic red-black trees) got started
when I was exploring the possibilities of running parts of Wine in the
kernel, when I was dismayed by the lack of genericity in the kernel's
red-black tree code, so it's actually a tangent! :)  Don't get me wrong,
I don't regret it.  It has been a marvelous adventure in the
possibilities of the C language on modern compilers.  But after I finish
this up, I plan on writing up a paper on the "C metaprogramming"
techniques I seem to have discovered and then getting back to my Wine
project.  There are many other nify compile-time tricks that I
discovered in the exploration process that I didn't need to use here,
but which are worth documenting.

So basically, I know that I need to try to get this thing wrapped up.

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () linux-foundation ! org>
To: linux-sparse
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Tue, 09 Oct 2012 18:41:58 +0000
Message-ID: <20121009114158.9cdf1378.akpm () linux-foundation ! org>
--------------------
On Sun, 07 Oct 2012 13:27:58 -0500
Daniel Santos <danielfsantos@att.net> wrote:

> We'll have to ask Andrew.  Maybe so he can test on those versions of gcc?
> 
> commit d3ffe64a1dbcfe18b57f90f7c01c40c93d0a8b92
> Author: Andrew Morton <akpm@linux-foundation.org>
> Date:   Fri Sep 28 00:02:42 2012 +0000
> 
>     a
>    
>     Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
> 
> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 934bc34..997fd8a 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -5,7 +5,7 @@
>  /* GCC 4.1.[01] miscompiles __weak */
>  #ifdef __KERNEL__
>  # if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> -#  error Your version of gcc miscompiles the __weak directive
> +//#  error Your version of gcc miscompiles the __weak directive

hm, yeah, sorry, I use various old crufty cross-compilers.

There are quite a number of patches in -mm which aren't included in
linux-next and that's one of them.  The
NEXT_PATCHES_START/NEXT_PATCHES_END markers in the series file identify
the patches which Stephen selects.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-kernel
Subject: Re: [PATCH v2 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Tue, 09 Oct 2012 19:45:51 +0000
Message-ID: <20121009194551.GA3616 () jtriplet-mobl1>
--------------------
On Tue, Oct 09, 2012 at 11:41:58AM -0700, Andrew Morton wrote:
> On Sun, 07 Oct 2012 13:27:58 -0500
> Daniel Santos <danielfsantos@att.net> wrote:
> 
> > We'll have to ask Andrew.  Maybe so he can test on those versions of gcc?
> > 
> > commit d3ffe64a1dbcfe18b57f90f7c01c40c93d0a8b92
> > Author: Andrew Morton <akpm@linux-foundation.org>
> > Date:   Fri Sep 28 00:02:42 2012 +0000
> > 
> >     a
> >    
> >     Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
> > 
> > diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> > index 934bc34..997fd8a 100644
> > --- a/include/linux/compiler-gcc4.h
> > +++ b/include/linux/compiler-gcc4.h
> > @@ -5,7 +5,7 @@
> >  /* GCC 4.1.[01] miscompiles __weak */
> >  #ifdef __KERNEL__
> >  # if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> > -#  error Your version of gcc miscompiles the __weak directive
> > +//#  error Your version of gcc miscompiles the __weak directive
> 
> hm, yeah, sorry, I use various old crufty cross-compilers.

Ah, for build testing where you don't actually care if the resulting
kernel runs?

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH v3 0/10] Cleanup & new features for compiler*.h and bug.h ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v3 0/10] Cleanup & new features for compiler*.h and bug.h
Date: Wed, 24 Oct 2012 16:28:42 +0000
Message-ID: <1351096132-12244-1-git-send-email-daniel.santos () pobox ! com>
--------------------

This patch set is a dependency of the generic red-black tree patch set, which
I have now split up into three smaller sets and is based off of linux-next.

The major aim of this patch set is to cleanup compiler-gcc*.h and improve
the manageability of of compiler features at various versions (when they
are broken, etc.), add some needed features to bug.h and clean that up as
well.

compiler-gcc*.h
o Introduce GCC_VERSION - (e.g., gcc 4.7.1 becomes 40701)
o Reorder all features based upon the version introduced (readability)
o Change all version checks to use GCC_VERSION
o Remove redundant __linktime_error

bug.h
o Improve BUILD_BUG_ON(expr) - now generates compile-time error post-gcc-4.4
o Remove duplicate error messages in some cases.
o Introduce BUILD_BUG_ON_MSG and clean up the implementations of the
  BUILD_BUG* macros.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 02/10] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v3 02/10] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro
Date: Wed, 24 Oct 2012 16:33:53 +0000
Message-ID: <1351096441-12388-2-git-send-email-daniel.santos () pobox ! com>
--------------------
Throughout compiler*.h, many version checks are made.  These can be
simplified by using the macro that gcc's documentation recommends.
However, my primary reason for adding this is that I need bug-check
macros that are enabled at certain gcc versions and it's cleaner to use
this macro than the tradition method:

if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ => 2)

If you add patch level, it gets this ugly:

if __GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
   __GNUC_MINOR__ == 2 __GNUC_PATCHLEVEL__ >= 1))

As opposed to:

if GCC_VERSION >= 40201

While having separate headers for gcc 3 & 4 eliminates some of this
verbosity, they can still be cleaned up by this.

See also:
http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: Borislav Petkov <bp@alien8.de>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc.h |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 6a6d7ae..24545cd 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -5,6 +5,9 @@
 /*
  * Common definitions for all gcc versions go here.
  */
+#define GCC_VERSION (__GNUC__ * 10000 \
+		   + __GNUC_MINOR__ * 100 \
+		   + __GNUC_PATCHLEVEL__)
 
 
 /* Optimization barrier */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v3 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Wed, 24 Oct 2012 16:33:54 +0000
Message-ID: <1351096441-12388-3-git-send-email-daniel.santos () pobox ! com>
--------------------
Using GCC_VERSION reduces complexity, is easier to read and is GCC's
recommended mechanism for doing version checks. (Just don't ask me why
they didn't define it in the first place.)  This also makes it easy to
merge compiler-gcc{,3,4}.h should somebody want to.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc3.h |    8 ++++----
 include/linux/compiler-gcc4.h |   14 +++++++-------
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
index 37d4124..7d89feb 100644
--- a/include/linux/compiler-gcc3.h
+++ b/include/linux/compiler-gcc3.h
@@ -2,22 +2,22 @@
 #error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
 #endif
 
-#if __GNUC_MINOR__ < 2
+#if GCC_VERSION < 30200
 # error Sorry, your compiler is too old - please upgrade it.
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 30300
 # define __used			__attribute__((__used__))
 #else
 # define __used			__attribute__((__unused__))
 #endif
 
-#if __GNUC_MINOR__ >= 4
+#if GCC_VERSION >= 30400
 #define __must_check		__attribute__((warn_unused_result))
 #endif
 
 #ifdef CONFIG_GCOV_KERNEL
-# if __GNUC_MINOR__ < 4
+# if GCC_VERSION < 30400
 #   error "GCOV profiling support for gcc versions below 3.4 not included"
 # endif /* __GNUC_MINOR__ */
 #endif /* CONFIG_GCOV_KERNEL */
diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 8914293..9755029 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -4,7 +4,7 @@
 
 /* GCC 4.1.[01] miscompiles __weak */
 #ifdef __KERNEL__
-# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
+# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
 #  error Your version of gcc miscompiles the __weak directive
 # endif
 #endif
@@ -13,11 +13,11 @@
 #define __must_check 		__attribute__((warn_unused_result))
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
 
-#if __GNUC_MINOR__ > 0
+#if GCC_VERSION >= 40100
 # define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 40300
 /* Mark functions as cold. gcc will assume any path leading to a call
    to them will be unlikely.  This means a lot of manual unlikely()s
    are unnecessary now for any paths leading to the usual suspects
@@ -39,9 +39,9 @@
 # define __compiletime_warning(message) __attribute__((warning(message)))
 # define __compiletime_error(message) __attribute__((error(message)))
 #endif /* __CHECKER__ */
-#endif /* __GNUC_MINOR__ >= 3 */
+#endif /* GCC_VERSION >= 40300 */
 
-#if __GNUC_MINOR__ >= 5
+#if GCC_VERSION >= 40500
 /*
  * Mark a position in code as unreachable.  This can be used to
  * suppress control flow warnings after asm blocks that transfer
@@ -56,9 +56,9 @@
 /* Mark a function definition as prohibited from being cloned. */
 #define __noclone	__attribute__((__noclone__))
 
-#endif /* __GNUC_MINOR__ >= 5 */
+#endif /* GCC_VERSION >= 40500 */
 
-#if __GNUC_MINOR__ >= 6
+#if GCC_VERSION >= 40600
 /*
  * Tell the optimizer that something else uses this function or variable.
  */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v3 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Wed, 24 Oct 2012 19:05:46 +0000
Message-ID: <20121024190546.GA17945 () liondog ! tnic>
--------------------
On Wed, Oct 24, 2012 at 11:33:54AM -0500, danielfsantos@att.net wrote:
> Using GCC_VERSION reduces complexity, is easier to read and is GCC's
> recommended mechanism for doing version checks. (Just don't ask me why
> they didn't define it in the first place.)  This also makes it easy to
> merge compiler-gcc{,3,4}.h should somebody want to.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>
> ---
>  include/linux/compiler-gcc3.h |    8 ++++----
>  include/linux/compiler-gcc4.h |   14 +++++++-------
>  2 files changed, 11 insertions(+), 11 deletions(-)
> 
> diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
> index 37d4124..7d89feb 100644
> --- a/include/linux/compiler-gcc3.h
> +++ b/include/linux/compiler-gcc3.h
> @@ -2,22 +2,22 @@
>  #error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
>  #endif
>  
> -#if __GNUC_MINOR__ < 2
> +#if GCC_VERSION < 30200
>  # error Sorry, your compiler is too old - please upgrade it.
>  #endif
>  
> -#if __GNUC_MINOR__ >= 3
> +#if GCC_VERSION >= 30300
>  # define __used			__attribute__((__used__))
>  #else
>  # define __used			__attribute__((__unused__))
>  #endif
>  
> -#if __GNUC_MINOR__ >= 4
> +#if GCC_VERSION >= 30400
>  #define __must_check		__attribute__((warn_unused_result))
>  #endif
>  
>  #ifdef CONFIG_GCOV_KERNEL
> -# if __GNUC_MINOR__ < 4
> +# if GCC_VERSION < 30400
>  #   error "GCOV profiling support for gcc versions below 3.4 not included"
>  # endif /* __GNUC_MINOR__ */
>  #endif /* CONFIG_GCOV_KERNEL */
> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 8914293..9755029 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -4,7 +4,7 @@
>  
>  /* GCC 4.1.[01] miscompiles __weak */
>  #ifdef __KERNEL__
> -# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> +# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
>  #  error Your version of gcc miscompiles the __weak directive
>  # endif
>  #endif
> @@ -13,11 +13,11 @@
>  #define __must_check 		__attribute__((warn_unused_result))
>  #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
>  
> -#if __GNUC_MINOR__ > 0
> +#if GCC_VERSION >= 40100

I can't seem to recall so did we explain already why ">= 40100" instead
of "> 40000"?

I mean, it is the same, but still...

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v3 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Wed, 24 Oct 2012 19:05:46 +0000
Message-ID: <20121024190546.GA17945 () liondog ! tnic>
--------------------
On Wed, Oct 24, 2012 at 11:33:54AM -0500, danielfsantos@att.net wrote:
> Using GCC_VERSION reduces complexity, is easier to read and is GCC's
> recommended mechanism for doing version checks. (Just don't ask me why
> they didn't define it in the first place.)  This also makes it easy to
> merge compiler-gcc{,3,4}.h should somebody want to.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>
> ---
>  include/linux/compiler-gcc3.h |    8 ++++----
>  include/linux/compiler-gcc4.h |   14 +++++++-------
>  2 files changed, 11 insertions(+), 11 deletions(-)
> 
> diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
> index 37d4124..7d89feb 100644
> --- a/include/linux/compiler-gcc3.h
> +++ b/include/linux/compiler-gcc3.h
> @@ -2,22 +2,22 @@
>  #error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
>  #endif
>  
> -#if __GNUC_MINOR__ < 2
> +#if GCC_VERSION < 30200
>  # error Sorry, your compiler is too old - please upgrade it.
>  #endif
>  
> -#if __GNUC_MINOR__ >= 3
> +#if GCC_VERSION >= 30300
>  # define __used			__attribute__((__used__))
>  #else
>  # define __used			__attribute__((__unused__))
>  #endif
>  
> -#if __GNUC_MINOR__ >= 4
> +#if GCC_VERSION >= 30400
>  #define __must_check		__attribute__((warn_unused_result))
>  #endif
>  
>  #ifdef CONFIG_GCOV_KERNEL
> -# if __GNUC_MINOR__ < 4
> +# if GCC_VERSION < 30400
>  #   error "GCOV profiling support for gcc versions below 3.4 not included"
>  # endif /* __GNUC_MINOR__ */
>  #endif /* CONFIG_GCOV_KERNEL */
> diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> index 8914293..9755029 100644
> --- a/include/linux/compiler-gcc4.h
> +++ b/include/linux/compiler-gcc4.h
> @@ -4,7 +4,7 @@
>  
>  /* GCC 4.1.[01] miscompiles __weak */
>  #ifdef __KERNEL__
> -# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> +# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
>  #  error Your version of gcc miscompiles the __weak directive
>  # endif
>  #endif
> @@ -13,11 +13,11 @@
>  #define __must_check 		__attribute__((warn_unused_result))
>  #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
>  
> -#if __GNUC_MINOR__ > 0
> +#if GCC_VERSION >= 40100

I can't seem to recall so did we explain already why ">= 40100" instead
of "> 40000"?

I mean, it is the same, but still...

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-kernel
Subject: Re: [PATCH v3 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Wed, 24 Oct 2012 21:49:00 +0000
Message-ID: <20121024214900.GA5925 () jtriplet-mobl1>
--------------------
On Wed, Oct 24, 2012 at 09:05:46PM +0200, Borislav Petkov wrote:
> On Wed, Oct 24, 2012 at 11:33:54AM -0500, danielfsantos@att.net wrote:
> > Using GCC_VERSION reduces complexity, is easier to read and is GCC's
> > recommended mechanism for doing version checks. (Just don't ask me why
> > they didn't define it in the first place.)  This also makes it easy to
> > merge compiler-gcc{,3,4}.h should somebody want to.
> > 
> > Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> > Acked-by: David Rientjes <rientjes@google.com>
> > ---
> >  include/linux/compiler-gcc3.h |    8 ++++----
> >  include/linux/compiler-gcc4.h |   14 +++++++-------
> >  2 files changed, 11 insertions(+), 11 deletions(-)
> > 
> > diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
> > index 37d4124..7d89feb 100644
> > --- a/include/linux/compiler-gcc3.h
> > +++ b/include/linux/compiler-gcc3.h
> > @@ -2,22 +2,22 @@
> >  #error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
> >  #endif
> >  
> > -#if __GNUC_MINOR__ < 2
> > +#if GCC_VERSION < 30200
> >  # error Sorry, your compiler is too old - please upgrade it.
> >  #endif
> >  
> > -#if __GNUC_MINOR__ >= 3
> > +#if GCC_VERSION >= 30300
> >  # define __used			__attribute__((__used__))
> >  #else
> >  # define __used			__attribute__((__unused__))
> >  #endif
> >  
> > -#if __GNUC_MINOR__ >= 4
> > +#if GCC_VERSION >= 30400
> >  #define __must_check		__attribute__((warn_unused_result))
> >  #endif
> >  
> >  #ifdef CONFIG_GCOV_KERNEL
> > -# if __GNUC_MINOR__ < 4
> > +# if GCC_VERSION < 30400
> >  #   error "GCOV profiling support for gcc versions below 3.4 not included"
> >  # endif /* __GNUC_MINOR__ */
> >  #endif /* CONFIG_GCOV_KERNEL */
> > diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
> > index 8914293..9755029 100644
> > --- a/include/linux/compiler-gcc4.h
> > +++ b/include/linux/compiler-gcc4.h
> > @@ -4,7 +4,7 @@
> >  
> >  /* GCC 4.1.[01] miscompiles __weak */
> >  #ifdef __KERNEL__
> > -# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
> > +# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
> >  #  error Your version of gcc miscompiles the __weak directive
> >  # endif
> >  #endif
> > @@ -13,11 +13,11 @@
> >  #define __must_check 		__attribute__((warn_unused_result))
> >  #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
> >  
> > -#if __GNUC_MINOR__ > 0
> > +#if GCC_VERSION >= 40100
> 
> I can't seem to recall so did we explain already why ">= 40100" instead
> of "> 40000"?
> 
> I mean, it is the same, but still...

__GNUC_MINOR__ > 0 means __GNUC_MINOR__ >= 1, so that would allow 4.1 or
newer.  However, GCC_VERSION > 40000 would also allow 4.0.n for n > 0.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v3 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Wed, 24 Oct 2012 22:34:13 +0000
Message-ID: <20121024223413.GA8828 () liondog ! tnic>
--------------------
On Wed, Oct 24, 2012 at 02:49:00PM -0700, Josh Triplett wrote:
> > I can't seem to recall so did we explain already why ">= 40100" instead
> > of "> 40000"?
> > 
> > I mean, it is the same, but still...
> 
> __GNUC_MINOR__ > 0 means __GNUC_MINOR__ >= 1, so that would allow 4.1 or
> newer.  However, GCC_VERSION > 40000 would also allow 4.0.n for n > 0.

Ah, sure. In that case

Acked-by: Borislav Petkov <bp@alien8.de>

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v3 03/10] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Wed, 24 Oct 2012 22:34:13 +0000
Message-ID: <20121024223413.GA8828 () liondog ! tnic>
--------------------
On Wed, Oct 24, 2012 at 02:49:00PM -0700, Josh Triplett wrote:
> > I can't seem to recall so did we explain already why ">= 40100" instead
> > of "> 40000"?
> > 
> > I mean, it is the same, but still...
> 
> __GNUC_MINOR__ > 0 means __GNUC_MINOR__ >= 1, so that would allow 4.1 or
> newer.  However, GCC_VERSION > 40000 would also allow 4.0.n for n > 0.

Ah, sure. In that case

Acked-by: Borislav Petkov <bp@alien8.de>

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 04/10] bug.h: directly include linux/compiler.h ===

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v3 04/10] bug.h: directly include linux/compiler.h
Date: Sun, 28 Oct 2012 19:23:21 +0000
Message-ID: <508D8629.4040208 () att ! net>
--------------------
On 10/24/2012 02:55 PM, Borislav Petkov wrote:
> On Wed, Oct 24, 2012 at 11:33:55AM -0500, danielfsantos@att.net wrote:
>> Currently, we are only including asm/bug.h and then expecting that
>> linux/compiler.h will eventually be included to define __linktime_error
>> (used in BUILD_BUG_ON). This patch includes it directly for clarity and
>> to avoid the possibility of changes in <arch>/*/include/asm/bug.h being
>> changed or not including linux/compiler.h for some reason. (Later
>> patches will in this set use more macros defined in compiler*.h.)
>>
>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>> ---
>>  include/linux/bug.h |    1 +
>>  1 files changed, 1 insertions(+), 0 deletions(-)
>>
>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>> index aaac4bb..4bd74d8 100644
>> --- a/include/linux/bug.h
>> +++ b/include/linux/bug.h
>> @@ -2,6 +2,7 @@
>>  #define _LINUX_BUG_H
>>  
>>  #include <asm/bug.h>
>> +#include <linux/compiler.h>
>>  
>>  enum bug_trap_type {
>>  	BUG_TRAP_TYPE_NONE = 0,
>> -- 
>> 1.7.3.4
> Why is this a separate patch and why not add that single line in 6/10
> where you define BUILD_BUG_ON?
>
> Thanks.
Sorry about that.  I think this was originally in another patch with
something else that I moved to another patch set and it ended up by its
self.  I'll squash it and resubmit.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 05/10] compiler{,-gcc4}.h, bug.h: Remove duplicate macros ===

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v3 05/10] compiler{,-gcc4}.h, bug.h: Remove duplicate macros
Date: Thu, 25 Oct 2012 09:26:16 +0000
Message-ID: <20121025092616.GB16601 () liondog ! tnic>
--------------------
On Wed, Oct 24, 2012 at 11:33:56AM -0500, danielfsantos@att.net wrote:
> __linktime_error() does the same thing as __compiletime_error() and is
> only used in bug.h.  Since the macro defines a function attribute that
> will cause a failure at compile-time (not link-time), it makes more
> sense to keep __compiletime_error(), which is also neatly mated with
> __compiletime_warning().
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>

Acked-by: Borislav Petkov <bp@alien8.de>

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 06/10] bug.h: Make BUILD_BUG_ON generate compile-time error ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v3 06/10] bug.h: Make BUILD_BUG_ON generate compile-time error
Date: Wed, 24 Oct 2012 16:33:57 +0000
Message-ID: <1351096441-12388-6-git-send-email-daniel.santos () pobox ! com>
--------------------
Negative sized arrays wont create a compile-time error in some cases
starting with gcc 4.4 (e.g., inlined functions), but gcc 4.3 introduced
the error function attribute that will.  This patch modifies
BUILD_BUG_ON to behave like BUILD_BUG already does, using the error
function attribute so that you don't have to build the entire kernel to
discover that you have a problem, and then enjoy trying to track it down
from a link-time error.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |   24 ++++++++++++++----------
 1 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index a03c3ef..3d4b564 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -43,24 +43,28 @@ struct pt_regs;
  * @condition: the condition which the compiler should know is false.
  *
  * If you have some code which relies on certain constants being equal, or
- * other compile-time-evaluated condition, you should use BUILD_BUG_ON to
+ * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to
  * detect if someone changes it.
  *
  * The implementation uses gcc's reluctance to create a negative array, but
  * gcc (as of 4.4) only emits that error for obvious cases (eg. not arguments
- * to inline functions).  So as a fallback we use the optimizer; if it can't
- * prove the condition is false, it will cause a link error on the undefined
- * "__build_bug_on_failed".  This error message can be harder to track down
- * though, hence the two different methods.
+ * to inline functions).  Luckily, in 4.3 they added the "error" function
+ * attribute just for this type of case.  Thus, we use a negative sized array
+ * (should always create an error pre-gcc-4.4) and then call an undefined
+ * function with the error attribute (should always creates an error 4.3+).  If
+ * for some reason, neither creates a compile-time error, we'll still have a
+ * link-time error, which is harder to track down.
  */
 #ifndef __OPTIMIZE__
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 #else
-extern int __build_bug_on_failed;
-#define BUILD_BUG_ON(condition)					\
-	do {							\
-		((void)sizeof(char[1 - 2*!!(condition)]));	\
-		if (condition) __build_bug_on_failed = 1;	\
+#define BUILD_BUG_ON(condition)						\
+	do {								\
+		extern void __build_bug_on_failed(void)			\
+			__compiletime_error("BUILD_BUG_ON failed");	\
+		((void)sizeof(char[1 - 2*!!(condition)]));		\
+		if (condition)						\
+			__build_bug_on_failed();			\
 	} while(0)
 #endif
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v3 06/10] bug.h: Make BUILD_BUG_ON generate compile-time error
Date: Thu, 25 Oct 2012 09:33:36 +0000
Message-ID: <20121025093336.GC16601 () liondog ! tnic>
--------------------
On Wed, Oct 24, 2012 at 11:33:57AM -0500, danielfsantos@att.net wrote:
> Negative sized arrays wont create a compile-time error in some cases
> starting with gcc 4.4 (e.g., inlined functions), but gcc 4.3 introduced
> the error function attribute that will.  This patch modifies
> BUILD_BUG_ON to behave like BUILD_BUG already does, using the error
> function attribute so that you don't have to build the entire kernel to
> discover that you have a problem, and then enjoy trying to track it down
> from a link-time error.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> ---
>  include/linux/bug.h |   24 ++++++++++++++----------
>  1 files changed, 14 insertions(+), 10 deletions(-)
> 
> diff --git a/include/linux/bug.h b/include/linux/bug.h
> index a03c3ef..3d4b564 100644
> --- a/include/linux/bug.h
> +++ b/include/linux/bug.h
> @@ -43,24 +43,28 @@ struct pt_regs;
>   * @condition: the condition which the compiler should know is false.
>   *
>   * If you have some code which relies on certain constants being equal, or
> - * other compile-time-evaluated condition, you should use BUILD_BUG_ON to
> + * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to
>   * detect if someone changes it.
>   *
>   * The implementation uses gcc's reluctance to create a negative array, but
>   * gcc (as of 4.4) only emits that error for obvious cases (eg. not arguments
> - * to inline functions).  So as a fallback we use the optimizer; if it can't
> - * prove the condition is false, it will cause a link error on the undefined
> - * "__build_bug_on_failed".  This error message can be harder to track down
> - * though, hence the two different methods.
> + * to inline functions).  Luckily, in 4.3 they added the "error" function
> + * attribute just for this type of case.  Thus, we use a negative sized array
> + * (should always create an error pre-gcc-4.4) and then call an undefined

	.... always create an error on gcc versions older than 4.4)

> + * function with the error attribute (should always creates an error 4.3+).  If

					..... always create an error on gcc 4.3 and later)

> + * for some reason, neither creates a compile-time error, we'll still have a
> + * link-time error, which is harder to track down.
>   */
>  #ifndef __OPTIMIZE__
>  #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
>  #else
> -extern int __build_bug_on_failed;
> -#define BUILD_BUG_ON(condition)					\
> -	do {							\
> -		((void)sizeof(char[1 - 2*!!(condition)]));	\
> -		if (condition) __build_bug_on_failed = 1;	\
> +#define BUILD_BUG_ON(condition)						\
> +	do {								\
> +		extern void __build_bug_on_failed(void)			\
> +			__compiletime_error("BUILD_BUG_ON failed");	\
> +		((void)sizeof(char[1 - 2*!!(condition)]));		\
> +		if (condition)						\
> +			__build_bug_on_failed();			\
>  	} while(0)
>  #endif

With the changes above:

Acked-by: Borislav Petkov <bp@alien8.de>

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH v3 08/10] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__ ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v3 08/10] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__
Date: Wed, 24 Oct 2012 16:33:59 +0000
Message-ID: <1351096441-12388-8-git-send-email-daniel.santos () pobox ! com>
--------------------
When __CHECKER__ is defined, we disable all of the BUILD_BUG.* macros.
However, BUILD_BUG_ON was evaluating to nothing in this case, and we
want (0) since this is a function-like macro that will be followed by a
semicolon.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index f8eae31..1b43ea2 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -16,7 +16,7 @@ struct pt_regs;
 #define BUILD_BUG_ON_NOT_POWER_OF_2(n)
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
-#define BUILD_BUG_ON(condition)
+#define BUILD_BUG_ON(condition) (0)
 #define BUILD_BUG() (0)
 #else /* __CHECKER__ */
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 09/10] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v3 09/10] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL
Date: Wed, 24 Oct 2012 16:34:00 +0000
Message-ID: <1351096441-12388-9-git-send-email-daniel.santos () pobox ! com>
--------------------
Add BUILD_BUG_ON_MSG which behaves like BUILD_BUG_ON (with optimizations
enabled), except that it allows you to specify the error message you
want emitted as the third parameter.  Under the hood, this relies on
_BUILD_BUG_INTERNAL, which does the actual work and is pretty-much
identical to BUILD_BUG_ON.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |   22 ++++++++++++++++++++++
 1 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 1b43ea2..f6f81f6 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -16,6 +16,7 @@ struct pt_regs;
 #define BUILD_BUG_ON_NOT_POWER_OF_2(n)
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
+#define BUILD_BUG_ON_MSG(cond, msg) (0)
 #define BUILD_BUG_ON(condition) (0)
 #define BUILD_BUG() (0)
 #else /* __CHECKER__ */
@@ -38,6 +39,27 @@ struct pt_regs;
  */
 #define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))
 
+#define __BUILD_BUG_INTERNAL(condition, msg, line)		\
+	do {							\
+		extern void __build_bug_on_failed_ ## line	\
+			(void) __compiletime_error(msg);	\
+		__compiletime_error_fallback(condition);	\
+		if (condition)					\
+			__build_bug_on_failed_ ## line();	\
+	} while (0)
+
+#define _BUILD_BUG_INTERNAL(condition, msg, line) \
+	__BUILD_BUG_INTERNAL(condition, msg, line)
+
+/**
+ * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied
+ * 		      error message.
+ * @condition: the condition which the compiler should know is false.
+ *
+ * See BUILD_BUG_ON for description.
+ */
+#define BUILD_BUG_ON_MSG(cond, msg) _BUILD_BUG_INTERNAL(cond, msg, __LINE__)
+
 /**
  * BUILD_BUG_ON - break compile if a condition is true.
  * @condition: the condition which the compiler should know is false.
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v3 10/10] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v3 10/10] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG
Date: Wed, 24 Oct 2012 16:34:01 +0000
Message-ID: <1351096441-12388-10-git-send-email-daniel.santos () pobox ! com>
--------------------
Remove duplicate code by converting BUILD_BUG and BUILD_BUG_ON to just
call BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but
also prevents the possibility of code being changed for one macro and
not for the other (which was previously the case for BUILD_BUG and
BUILD_BUG_ON).

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |   17 +++--------------
 1 files changed, 3 insertions(+), 14 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index f6f81f6..c791d2a 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -80,14 +80,8 @@ struct pt_regs;
 #ifndef __OPTIMIZE__
 #define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
 #else
-#define BUILD_BUG_ON(condition)						\
-	do {								\
-		extern void __build_bug_on_failed(void)			\
-			__compiletime_error("BUILD_BUG_ON failed");	\
-		__compiletime_error_fallback(condition);		\
-		if (condition)						\
-			__build_bug_on_failed();			\
-	} while(0)
+#define BUILD_BUG_ON(condition) \
+	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)
 #endif
 
 /**
@@ -97,12 +91,7 @@ struct pt_regs;
  * build time, you should use BUILD_BUG to detect if it is
  * unexpectedly used.
  */
-#define BUILD_BUG()						\
-	do {							\
-		extern void __build_bug_failed(void)		\
-			__compiletime_error("BUILD_BUG failed");\
-		__build_bug_failed();				\
-	} while (0)
+#define BUILD_BUG() BUILD_BUG_ON_MSG(1, "BUILD_BUG failed")
 
 #endif	/* __CHECKER__ */
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 0/10] Cleanup & new features for compiler*.h and bug.h ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v4 0/10] Cleanup & new features for compiler*.h and bug.h
Date: Sun, 28 Oct 2012 20:53:59 +0000
Message-ID: <1351457648-7453-1-git-send-email-daniel.santos () pobox ! com>
--------------------

 include/linux/bug.h           |   59 ++++++++++++++++++++++++++--------------
 include/linux/compiler-gcc.h  |    3 ++
 include/linux/compiler-gcc3.h |    8 +++---
 include/linux/compiler-gcc4.h |   28 +++++++++---------
 include/linux/compiler.h      |    8 ++++-
 5 files changed, 65 insertions(+), 41 deletions(-)

Changes in v4:
o Squash a minor commit (per Borislav Petkov)
o Change some comment text (per Borislav Petkov)
o Add some acks

This patch set is a dependency of the generic red-black tree patch set, which
I have now split up into three smaller sets and is based off of linux-next.

The major aim of this patch set is to cleanup compiler-gcc*.h and improve
the manageability of of compiler features at various versions (when they
are broken, etc.), add some needed features to bug.h and clean that up as
well.

compiler-gcc*.h
o Introduce GCC_VERSION - (e.g., gcc 4.7.1 becomes 40701)
o Reorder all features based upon the version introduced (readability)
o Change all version checks to use GCC_VERSION
o Remove redundant __linktime_error

bug.h
o Improve BUILD_BUG_ON(expr) - now generates compile-time error post-gcc-4.4
o Remove duplicate error messages in some cases.
o Introduce BUILD_BUG_ON_MSG and clean up the implementations of the
  BUILD_BUG* macros.

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 1/9] compiler-gcc4.h: Reorder macros based upon gcc ver ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v4 1/9] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Sun, 28 Oct 2012 20:57:07 +0000
Message-ID: <1351457835-7553-1-git-send-email-daniel.santos () pobox ! com>
--------------------
This helps to keep the file from getting confusing, removes one
duplicate version check and should encourage future editors to put new
macros where they belong.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc4.h |   20 +++++++++++---------
 1 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 412bc6c..8914293 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -13,6 +13,10 @@
 #define __must_check 		__attribute__((warn_unused_result))
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
 
+#if __GNUC_MINOR__ > 0
+# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
+#endif
+
 #if __GNUC_MINOR__ >= 3
 /* Mark functions as cold. gcc will assume any path leading to a call
    to them will be unlikely.  This means a lot of manual unlikely()s
@@ -31,6 +35,12 @@
 
 #define __linktime_error(message) __attribute__((__error__(message)))
 
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+#endif /* __GNUC_MINOR__ >= 3 */
+
 #if __GNUC_MINOR__ >= 5
 /*
  * Mark a position in code as unreachable.  This can be used to
@@ -46,8 +56,7 @@
 /* Mark a function definition as prohibited from being cloned. */
 #define __noclone	__attribute__((__noclone__))
 
-#endif
-#endif
+#endif /* __GNUC_MINOR__ >= 5 */
 
 #if __GNUC_MINOR__ >= 6
 /*
@@ -56,10 +65,3 @@
 #define __visible __attribute__((externally_visible))
 #endif
 
-#if __GNUC_MINOR__ > 0
-#define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
-#endif
-#if __GNUC_MINOR__ >= 3 && !defined(__CHECKER__)
-#define __compiletime_warning(message) __attribute__((warning(message)))
-#define __compiletime_error(message) __attribute__((error(message)))
-#endif
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v4 1/9] compiler-gcc4.h: Reorder macros based upon gcc ver
Date: Tue, 30 Oct 2012 12:02:06 +0000
Message-ID: <20121030120206.GE16455 () liondog ! tnic>
--------------------
On Sun, Oct 28, 2012 at 03:57:07PM -0500, danielfsantos@att.net wrote:
> This helps to keep the file from getting confusing, removes one
> duplicate version check and should encourage future editors to put new
> macros where they belong.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> Acked-by: David Rientjes <rientjes@google.com>

Acked-by: Borislav Petkov <bp@alien8.de>

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================


################################################################################

=== Thread: [PATCH v4 2/9] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v4 2/9] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro
Date: Sun, 28 Oct 2012 20:57:08 +0000
Message-ID: <1351457835-7553-2-git-send-email-daniel.santos () pobox ! com>
--------------------
Throughout compiler*.h, many version checks are made.  These can be
simplified by using the macro that gcc's documentation recommends.
However, my primary reason for adding this is that I need bug-check
macros that are enabled at certain gcc versions and it's cleaner to use
this macro than the tradition method:

if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ => 2)

If you add patch level, it gets this ugly:

if __GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
   __GNUC_MINOR__ == 2 __GNUC_PATCHLEVEL__ >= 1))

As opposed to:

if GCC_VERSION >= 40201

While having separate headers for gcc 3 & 4 eliminates some of this
verbosity, they can still be cleaned up by this.

See also:
http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: Borislav Petkov <bp@alien8.de>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc.h |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 6a6d7ae..24545cd 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -5,6 +5,9 @@
 /*
  * Common definitions for all gcc versions go here.
  */
+#define GCC_VERSION (__GNUC__ * 10000 \
+		   + __GNUC_MINOR__ * 100 \
+		   + __GNUC_PATCHLEVEL__)
 
 
 /* Optimization barrier */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 4/9] compiler{,-gcc4}.h, bug.h: Remove duplicate macros ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v4 4/9] compiler{,-gcc4}.h, bug.h: Remove duplicate macros
Date: Sun, 28 Oct 2012 20:57:10 +0000
Message-ID: <1351457835-7553-4-git-send-email-daniel.santos () pobox ! com>
--------------------
__linktime_error() does the same thing as __compiletime_error() and is
only used in bug.h.  Since the macro defines a function attribute that
will cause a failure at compile-time (not link-time), it makes more
sense to keep __compiletime_error(), which is also neatly mated with
__compiletime_warning().

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/bug.h           |    2 +-
 include/linux/compiler-gcc4.h |    2 --
 include/linux/compiler.h      |    3 ---
 3 files changed, 1 insertions(+), 6 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index aaac4bb..298a916 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -73,7 +73,7 @@ extern int __build_bug_on_failed;
 #define BUILD_BUG()						\
 	do {							\
 		extern void __build_bug_failed(void)		\
-			__linktime_error("BUILD_BUG failed");	\
+			__compiletime_error("BUILD_BUG failed");\
 		__build_bug_failed();				\
 	} while (0)
 
diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 9755029..7f143ac 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -33,8 +33,6 @@
    the kernel context */
 #define __cold			__attribute__((__cold__))
 
-#define __linktime_error(message) __attribute__((__error__(message)))
-
 #ifndef __CHECKER__
 # define __compiletime_warning(message) __attribute__((warning(message)))
 # define __compiletime_error(message) __attribute__((error(message)))
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index b121554..cbf6d9d 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -299,9 +299,6 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 #ifndef __compiletime_error
 # define __compiletime_error(message)
 #endif
-#ifndef __linktime_error
-# define __linktime_error(message)
-#endif
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 5/9] bug.h: Make BUILD_BUG_ON generate compile-time error ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v4 5/9] bug.h: Make BUILD_BUG_ON generate compile-time error
Date: Sun, 28 Oct 2012 20:57:11 +0000
Message-ID: <1351457835-7553-5-git-send-email-daniel.santos () pobox ! com>
--------------------
Negative sized arrays wont create a compile-time error in some cases
starting with gcc 4.4 (e.g., inlined functions), but gcc 4.3 introduced
the error function attribute that will.  This patch modifies
BUILD_BUG_ON to behave like BUILD_BUG already does, using the error
function attribute so that you don't have to build the entire kernel to
discover that you have a problem, and then enjoy trying to track it down
from a link-time error.

Also, we are only including asm/bug.h and then expecting that
linux/compiler.h will eventually be included to define __linktime_error
(used in BUILD_BUG_ON). This patch includes it directly for clarity and
to avoid the possibility of changes in <arch>/*/include/asm/bug.h being
changed or not including linux/compiler.h for some reason.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/bug.h |   30 ++++++++++++++++++------------
 1 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 298a916..03259d7 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -2,6 +2,7 @@
 #define _LINUX_BUG_H
 
 #include <asm/bug.h>
+#include <linux/compiler.h>
 
 enum bug_trap_type {
 	BUG_TRAP_TYPE_NONE = 0,
@@ -42,24 +43,29 @@ struct pt_regs;
  * @condition: the condition which the compiler should know is false.
  *
  * If you have some code which relies on certain constants being equal, or
- * other compile-time-evaluated condition, you should use BUILD_BUG_ON to
+ * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to
  * detect if someone changes it.
  *
- * The implementation uses gcc's reluctance to create a negative array, but
- * gcc (as of 4.4) only emits that error for obvious cases (eg. not arguments
- * to inline functions).  So as a fallback we use the optimizer; if it can't
- * prove the condition is false, it will cause a link error on the undefined
- * "__build_bug_on_failed".  This error message can be harder to track down
- * though, hence the two different methods.
+ * The implementation uses gcc's reluctance to create a negative array, but gcc
+ * (as of 4.4) only emits that error for obvious cases (e.g. not arguments to
+ * inline functions).  Luckily, in 4.3 they added the "error" function
+ * attribute just for this type of case.  Thus, we use a negative sized array
+ * (should always create an error on gcc versions older than 4.4) and then call
+ * an undefined function with the error attribute (should always create an
+ * error on gcc 4.3 and later).  If for some reason, neither creates a
+ * compile-time error, we'll still have a link-time error, which is harder to
+ * track down.
  */
 #ifndef __OPTIMIZE__
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 #else
-extern int __build_bug_on_failed;
-#define BUILD_BUG_ON(condition)					\
-	do {							\
-		((void)sizeof(char[1 - 2*!!(condition)]));	\
-		if (condition) __build_bug_on_failed = 1;	\
+#define BUILD_BUG_ON(condition)						\
+	do {								\
+		extern void __build_bug_on_failed(void)			\
+			__compiletime_error("BUILD_BUG_ON failed");	\
+		((void)sizeof(char[1 - 2*!!(condition)]));		\
+		if (condition)						\
+			__build_bug_on_failed();			\
 	} while(0)
 #endif
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON} ===

From: danielfsantos () att ! net
To: linux-kernel
Subject: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Sun, 28 Oct 2012 20:57:12 +0000
Message-ID: <1351457835-7553-6-git-send-email-daniel.santos () pobox ! com>
--------------------
Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
creating compile-time errors required a little trickery.
BUILD_BUG{,_ON} uses this attribute when available to generate
compile-time errors, but also uses the negative-sized array trick for
older compilers, resulting in two error messages in some cases.  The
reason it's "some" cases is that as of gcc 4.4, the negative-sized array
will not create an error in some situations, like inline functions.

This patch replaces the negative-sized array code with the new
__compiletime_error_fallback() macro which expands to the same thing
unless the the error attribute is available, in which case it expands to
do{}while(0), resulting in exactly one compile-time error on all
versions of gcc.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h      |    4 ++--
 include/linux/compiler.h |    7 +++++++
 2 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 03259d7..da03dc1 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -57,13 +57,13 @@ struct pt_regs;
  * track down.
  */
 #ifndef __OPTIMIZE__
-#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
+#define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
 #else
 #define BUILD_BUG_ON(condition)						\
 	do {								\
 		extern void __build_bug_on_failed(void)			\
 			__compiletime_error("BUILD_BUG_ON failed");	\
-		((void)sizeof(char[1 - 2*!!(condition)]));		\
+		__compiletime_error_fallback(condition);		\
 		if (condition)						\
 			__build_bug_on_failed();			\
 	} while(0)
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index cbf6d9d..84926f2 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -298,6 +298,13 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 #endif
 #ifndef __compiletime_error
 # define __compiletime_error(message)
+# define __compiletime_error_fallback(condition)		\
+	do {							\
+		((void)sizeof(char[1 - 2*!!(condition)]));	\
+	} while (0)
+#endif
+#ifndef __compiletime_error_fallback
+# define __compiletime_error_fallback(condition) do { } while (0)
 #endif
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Tue, 30 Oct 2012 16:19:33 +0000
Message-ID: <20121030161933.GD28499 () liondog ! tnic>
--------------------
On Sun, Oct 28, 2012 at 03:57:12PM -0500, danielfsantos@att.net wrote:
> Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
> creating compile-time errors required a little trickery.
> BUILD_BUG{,_ON} uses this attribute when available to generate
> compile-time errors, but also uses the negative-sized array trick for
> older compilers, resulting in two error messages in some cases.  The
> reason it's "some" cases is that as of gcc 4.4, the negative-sized array
> will not create an error in some situations, like inline functions.
> 
> This patch replaces the negative-sized array code with the new
> __compiletime_error_fallback() macro which expands to the same thing
> unless the the error attribute is available, in which case it expands to
> do{}while(0), resulting in exactly one compile-time error on all
> versions of gcc.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> ---
>  include/linux/bug.h      |    4 ++--
>  include/linux/compiler.h |    7 +++++++
>  2 files changed, 9 insertions(+), 2 deletions(-)
> 
> diff --git a/include/linux/bug.h b/include/linux/bug.h
> index 03259d7..da03dc1 100644
> --- a/include/linux/bug.h
> +++ b/include/linux/bug.h
> @@ -57,13 +57,13 @@ struct pt_regs;
>   * track down.
>   */
>  #ifndef __OPTIMIZE__
> -#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
> +#define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
>  #else
>  #define BUILD_BUG_ON(condition)						\
>  	do {								\
>  		extern void __build_bug_on_failed(void)			\
>  			__compiletime_error("BUILD_BUG_ON failed");	\
> -		((void)sizeof(char[1 - 2*!!(condition)]));		\
> +		__compiletime_error_fallback(condition);		\
>  		if (condition)						\
>  			__build_bug_on_failed();			\

If we're defining a fallback, shouldn't it come second? I.e.:

		if (condition)
			__build_bug_on_failed();
		__compiletime_error_fallback(condition);

Also, the error message from __build_bug_on_failed is much more
informative:

arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
arch/x86/kernel/cpu/amd.c:486:2: error: call to â__build_bug_on_failedâ declared with attribute error: BUILD_BUG_ON failed
make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
make[1]: *** Waiting for unfinished jobs....
make: *** [arch/x86/kernel/cpu/] Error 2

than

arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
arch/x86/kernel/cpu/amd.c:486:2: error: size of unnamed array is negative
make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
make[1]: *** Waiting for unfinished jobs....
make: *** [arch/x86/kernel/cpu/] Error 2

Finally, you need to do:

	bool __cond = !!(condition);

and use __cond so that condition doesn't get evaluated multiple times
(possibly with side effects).

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/

================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Tue, 30 Oct 2012 16:19:33 +0000
Message-ID: <20121030161933.GD28499 () liondog ! tnic>
--------------------
On Sun, Oct 28, 2012 at 03:57:12PM -0500, danielfsantos@att.net wrote:
> Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
> creating compile-time errors required a little trickery.
> BUILD_BUG{,_ON} uses this attribute when available to generate
> compile-time errors, but also uses the negative-sized array trick for
> older compilers, resulting in two error messages in some cases.  The
> reason it's "some" cases is that as of gcc 4.4, the negative-sized array
> will not create an error in some situations, like inline functions.
> 
> This patch replaces the negative-sized array code with the new
> __compiletime_error_fallback() macro which expands to the same thing
> unless the the error attribute is available, in which case it expands to
> do{}while(0), resulting in exactly one compile-time error on all
> versions of gcc.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> ---
>  include/linux/bug.h      |    4 ++--
>  include/linux/compiler.h |    7 +++++++
>  2 files changed, 9 insertions(+), 2 deletions(-)
> 
> diff --git a/include/linux/bug.h b/include/linux/bug.h
> index 03259d7..da03dc1 100644
> --- a/include/linux/bug.h
> +++ b/include/linux/bug.h
> @@ -57,13 +57,13 @@ struct pt_regs;
>   * track down.
>   */
>  #ifndef __OPTIMIZE__
> -#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
> +#define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
>  #else
>  #define BUILD_BUG_ON(condition)						\
>  	do {								\
>  		extern void __build_bug_on_failed(void)			\
>  			__compiletime_error("BUILD_BUG_ON failed");	\
> -		((void)sizeof(char[1 - 2*!!(condition)]));		\
> +		__compiletime_error_fallback(condition);		\
>  		if (condition)						\
>  			__build_bug_on_failed();			\

If we're defining a fallback, shouldn't it come second? I.e.:

		if (condition)
			__build_bug_on_failed();
		__compiletime_error_fallback(condition);

Also, the error message from __build_bug_on_failed is much more
informative:

arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
arch/x86/kernel/cpu/amd.c:486:2: error: call to â__build_bug_on_failedâ declared with attribute error: BUILD_BUG_ON failed
make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
make[1]: *** Waiting for unfinished jobs....
make: *** [arch/x86/kernel/cpu/] Error 2

than

arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
arch/x86/kernel/cpu/amd.c:486:2: error: size of unnamed array is negative
make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
make[1]: *** Waiting for unfinished jobs....
make: *** [arch/x86/kernel/cpu/] Error 2

Finally, you need to do:

	bool __cond = !!(condition);

and use __cond so that condition doesn't get evaluated multiple times
(possibly with side effects).

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Wed, 31 Oct 2012 05:34:45 +0000
Message-ID: <5090B875.7030902 () att ! net>
--------------------
On 10/30/2012 11:19 AM, Borislav Petkov wrote:
> On Sun, Oct 28, 2012 at 03:57:12PM -0500, danielfsantos@att.net wrote:
>> Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
>> creating compile-time errors required a little trickery.
>> BUILD_BUG{,_ON} uses this attribute when available to generate
>> compile-time errors, but also uses the negative-sized array trick for
>> older compilers, resulting in two error messages in some cases.  The
>> reason it's "some" cases is that as of gcc 4.4, the negative-sized array
>> will not create an error in some situations, like inline functions.
>>
>> This patch replaces the negative-sized array code with the new
>> __compiletime_error_fallback() macro which expands to the same thing
>> unless the the error attribute is available, in which case it expands to
>> do{}while(0), resulting in exactly one compile-time error on all
>> versions of gcc.
>>
>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>> ---
>>  include/linux/bug.h      |    4 ++--
>>  include/linux/compiler.h |    7 +++++++
>>  2 files changed, 9 insertions(+), 2 deletions(-)
>>
>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>> index 03259d7..da03dc1 100644
>> --- a/include/linux/bug.h
>> +++ b/include/linux/bug.h
>> @@ -57,13 +57,13 @@ struct pt_regs;
>>   * track down.
>>   */
>>  #ifndef __OPTIMIZE__
>> -#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
>> +#define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
>>  #else
>>  #define BUILD_BUG_ON(condition)						\
>>  	do {								\
>>  		extern void __build_bug_on_failed(void)			\
>>  			__compiletime_error("BUILD_BUG_ON failed");	\
>> -		((void)sizeof(char[1 - 2*!!(condition)]));		\
>> +		__compiletime_error_fallback(condition);		\
>>  		if (condition)						\
>>  			__build_bug_on_failed();			\
> If we're defining a fallback, shouldn't it come second? I.e.:
>
> 		if (condition)
> 			__build_bug_on_failed();
> 		__compiletime_error_fallback(condition);
>
> Also, the error message from __build_bug_on_failed is much more
> informative:
>
> arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
> arch/x86/kernel/cpu/amd.c:486:2: error: call to â__build_bug_on_failedâ declared with attribute error: BUILD_BUG_ON failed
> make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
> make[1]: *** Waiting for unfinished jobs....
> make: *** [arch/x86/kernel/cpu/] Error 2
>
> than
>
> arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
> arch/x86/kernel/cpu/amd.c:486:2: error: size of unnamed array is negative
> make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
> make[1]: *** Waiting for unfinished jobs....
> make: *** [arch/x86/kernel/cpu/] Error 2
Yes, the __build_bug_on_failed message is much more informative.  This
will only increase with these patches.  For example, the line

BUILD_BUG_ON(sizeof(*c) != 4);

emits this error:

arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
arch/x86/kernel/cpu/amd.c:486:2: error: call to
â__build_bug_on_failed_486â declared with attribute error: BUILD_BUG_ON
failed: sizeof(*c) != 4
make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
make: *** [arch/x86/kernel/cpu/amd.o] Error 2

It's true that there is some redundancy in there as well as the
gibberish line number embedded in the function name, but the end of the
line spits out the exact statement that failed.

But as far as rather the fallback is first or the __compiletime_error
function is a matter of asthetics, since it's really an either/or
situation.  Either the __build_bug_on_failedxxx function will be
declared with __attribute__((error(message))) and the fallback will
expand to a no-op, or the fallback will produce code that (presumably
always?) breaks the build.  For insurance, a link-time error will occur
if the fallback code fails to break the build.

Realistically, a single macro could be defined in compiler*.h that
encapsulates the entirety of this mechanism and only exposes a "black
box" macro, that will simply expand to something that breaks the build
in the most appropriate fashion based upon the version of gcc.  In
essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.
>
> Finally, you need to do:
>
> 	bool __cond = !!(condition);
>
> and use __cond so that condition doesn't get evaluated multiple times
> (possibly with side effects).
>
> Thanks.
Big problem!  Very good catch, thank you!  All good programmers know not
use expressions that can have side effects in an assert-type macro, but
this it should certainly be as dummy proof as possible.  That will force
others to get a really *really* good dummy if they want to break it!

Thank you for this! I suppose another justification for having a single
"black box" macro that does this in one place and addresses all of these
tricky issues.

I guess I'll fix it up (and address the emails on the other patches) and
do a v5 then for the whole set? (is that the right way to resubmit with
these corrections?)

Thanks
Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Wed, 31 Oct 2012 05:34:45 +0000
Message-ID: <5090B875.7030902 () att ! net>
--------------------
On 10/30/2012 11:19 AM, Borislav Petkov wrote:
> On Sun, Oct 28, 2012 at 03:57:12PM -0500, danielfsantos@att.net wrote:
>> Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
>> creating compile-time errors required a little trickery.
>> BUILD_BUG{,_ON} uses this attribute when available to generate
>> compile-time errors, but also uses the negative-sized array trick for
>> older compilers, resulting in two error messages in some cases.  The
>> reason it's "some" cases is that as of gcc 4.4, the negative-sized array
>> will not create an error in some situations, like inline functions.
>>
>> This patch replaces the negative-sized array code with the new
>> __compiletime_error_fallback() macro which expands to the same thing
>> unless the the error attribute is available, in which case it expands to
>> do{}while(0), resulting in exactly one compile-time error on all
>> versions of gcc.
>>
>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>> ---
>>  include/linux/bug.h      |    4 ++--
>>  include/linux/compiler.h |    7 +++++++
>>  2 files changed, 9 insertions(+), 2 deletions(-)
>>
>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>> index 03259d7..da03dc1 100644
>> --- a/include/linux/bug.h
>> +++ b/include/linux/bug.h
>> @@ -57,13 +57,13 @@ struct pt_regs;
>>   * track down.
>>   */
>>  #ifndef __OPTIMIZE__
>> -#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
>> +#define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
>>  #else
>>  #define BUILD_BUG_ON(condition)						\
>>  	do {								\
>>  		extern void __build_bug_on_failed(void)			\
>>  			__compiletime_error("BUILD_BUG_ON failed");	\
>> -		((void)sizeof(char[1 - 2*!!(condition)]));		\
>> +		__compiletime_error_fallback(condition);		\
>>  		if (condition)						\
>>  			__build_bug_on_failed();			\
> If we're defining a fallback, shouldn't it come second? I.e.:
>
> 		if (condition)
> 			__build_bug_on_failed();
> 		__compiletime_error_fallback(condition);
>
> Also, the error message from __build_bug_on_failed is much more
> informative:
>
> arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
> arch/x86/kernel/cpu/amd.c:486:2: error: call to â__build_bug_on_failedâ declared with attribute error: BUILD_BUG_ON failed
> make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
> make[1]: *** Waiting for unfinished jobs....
> make: *** [arch/x86/kernel/cpu/] Error 2
>
> than
>
> arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
> arch/x86/kernel/cpu/amd.c:486:2: error: size of unnamed array is negative
> make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
> make[1]: *** Waiting for unfinished jobs....
> make: *** [arch/x86/kernel/cpu/] Error 2
Yes, the __build_bug_on_failed message is much more informative.  This
will only increase with these patches.  For example, the line

BUILD_BUG_ON(sizeof(*c) != 4);

emits this error:

arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
arch/x86/kernel/cpu/amd.c:486:2: error: call to
â__build_bug_on_failed_486â declared with attribute error: BUILD_BUG_ON
failed: sizeof(*c) != 4
make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
make: *** [arch/x86/kernel/cpu/amd.o] Error 2

It's true that there is some redundancy in there as well as the
gibberish line number embedded in the function name, but the end of the
line spits out the exact statement that failed.

But as far as rather the fallback is first or the __compiletime_error
function is a matter of asthetics, since it's really an either/or
situation.  Either the __build_bug_on_failedxxx function will be
declared with __attribute__((error(message))) and the fallback will
expand to a no-op, or the fallback will produce code that (presumably
always?) breaks the build.  For insurance, a link-time error will occur
if the fallback code fails to break the build.

Realistically, a single macro could be defined in compiler*.h that
encapsulates the entirety of this mechanism and only exposes a "black
box" macro, that will simply expand to something that breaks the build
in the most appropriate fashion based upon the version of gcc.  In
essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.
>
> Finally, you need to do:
>
> 	bool __cond = !!(condition);
>
> and use __cond so that condition doesn't get evaluated multiple times
> (possibly with side effects).
>
> Thanks.
Big problem!  Very good catch, thank you!  All good programmers know not
use expressions that can have side effects in an assert-type macro, but
this it should certainly be as dummy proof as possible.  That will force
others to get a really *really* good dummy if they want to break it!

Thank you for this! I suppose another justification for having a single
"black box" macro that does this in one place and addresses all of these
tricky issues.

I guess I'll fix it up (and address the emails on the other patches) and
do a v5 then for the whole set? (is that the right way to resubmit with
these corrections?)

Thanks
Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Wed, 31 Oct 2012 11:06:10 +0000
Message-ID: <20121031110609.GD16410 () liondog ! tnic>
--------------------
On Wed, Oct 31, 2012 at 12:34:45AM -0500, Daniel Santos wrote:
> Yes, the __build_bug_on_failed message is much more informative.  This
> will only increase with these patches.  For example, the line
> 
> BUILD_BUG_ON(sizeof(*c) != 4);
> 
> emits this error:
> 
> arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
> arch/x86/kernel/cpu/amd.c:486:2: error: call to
> â__build_bug_on_failed_486â declared with attribute error: BUILD_BUG_ON
> failed: sizeof(*c) != 4
> make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
> make: *** [arch/x86/kernel/cpu/amd.o] Error 2
> 
> It's true that there is some redundancy in there as well as the
> gibberish line number embedded in the function name, but the end of the
> line spits out the exact statement that failed.

I guess that's as good as it gets. But it's fine IMO, it tells you
exactly what you need to know.

> But as far as rather the fallback is first or the __compiletime_error
> function is a matter of asthetics, since it's really an either/or
> situation.  Either the __build_bug_on_failedxxx function will be
> declared with __attribute__((error(message))) and the fallback will
> expand to a no-op, or the fallback will produce code that (presumably
> always?) breaks the build.  For insurance, a link-time error will occur
> if the fallback code fails to break the build.

Right, but my suggestion was to have the more informative message always
trigger first, if possible and if gcc supports it (practically, more
and more systems will be upgrading gcc which has the error attribute
with time) and have the less informative one be the more seldom one. The
"fallback" naming is just a minor issue.

This way, the error message would be precise on most modern toolchains.
Older toolchains will issue something about negative array size, which
is not really helpful so one would have to fire up an editor and
actually look at the code :).

> Realistically, a single macro could be defined in compiler*.h that
> encapsulates the entirety of this mechanism and only exposes a "black
> box" macro, that will simply expand to something that breaks the build
> in the most appropriate fashion based upon the version of gcc.  In
> essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.

Yes.

> I guess I'll fix it up (and address the emails on the other patches)
> and do a v5 then for the whole set? (is that the right way to resubmit
> with these corrections?)

Well, you could wait a couple of days first to gather feedback from
other people and then resend. This way you give chance to people to take
a look without them seeing too many versions of the patchset and getting
confused.

What I always do is send out the patchset, collect and discuss changes,
add in the required changes and test it while the discussions go on.
After they settle down (and they do in a couple of days, in most cases)
I then send out the newly tested version out.

That whole exercise takes more or less a week if you're doing other
stuff in between :)

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Wed, 31 Oct 2012 11:06:10 +0000
Message-ID: <20121031110609.GD16410 () liondog ! tnic>
--------------------
On Wed, Oct 31, 2012 at 12:34:45AM -0500, Daniel Santos wrote:
> Yes, the __build_bug_on_failed message is much more informative.  This
> will only increase with these patches.  For example, the line
> 
> BUILD_BUG_ON(sizeof(*c) != 4);
> 
> emits this error:
> 
> arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
> arch/x86/kernel/cpu/amd.c:486:2: error: call to
> â__build_bug_on_failed_486â declared with attribute error: BUILD_BUG_ON
> failed: sizeof(*c) != 4
> make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
> make: *** [arch/x86/kernel/cpu/amd.o] Error 2
> 
> It's true that there is some redundancy in there as well as the
> gibberish line number embedded in the function name, but the end of the
> line spits out the exact statement that failed.

I guess that's as good as it gets. But it's fine IMO, it tells you
exactly what you need to know.

> But as far as rather the fallback is first or the __compiletime_error
> function is a matter of asthetics, since it's really an either/or
> situation.  Either the __build_bug_on_failedxxx function will be
> declared with __attribute__((error(message))) and the fallback will
> expand to a no-op, or the fallback will produce code that (presumably
> always?) breaks the build.  For insurance, a link-time error will occur
> if the fallback code fails to break the build.

Right, but my suggestion was to have the more informative message always
trigger first, if possible and if gcc supports it (practically, more
and more systems will be upgrading gcc which has the error attribute
with time) and have the less informative one be the more seldom one. The
"fallback" naming is just a minor issue.

This way, the error message would be precise on most modern toolchains.
Older toolchains will issue something about negative array size, which
is not really helpful so one would have to fire up an editor and
actually look at the code :).

> Realistically, a single macro could be defined in compiler*.h that
> encapsulates the entirety of this mechanism and only exposes a "black
> box" macro, that will simply expand to something that breaks the build
> in the most appropriate fashion based upon the version of gcc.  In
> essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.

Yes.

> I guess I'll fix it up (and address the emails on the other patches)
> and do a v5 then for the whole set? (is that the right way to resubmit
> with these corrections?)

Well, you could wait a couple of days first to gather feedback from
other people and then resend. This way you give chance to people to take
a look without them seeing too many versions of the patchset and getting
confused.

What I always do is send out the patchset, collect and discuss changes,
add in the required changes and test it while the discussions go on.
After they settle down (and they do in a couple of days, in most cases)
I then send out the newly tested version out.

That whole exercise takes more or less a week if you're doing other
stuff in between :)

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Wed, 31 Oct 2012 16:38:48 +0000
Message-ID: <50915418.2030607 () att ! net>
--------------------
On 10/31/2012 06:06 AM, Borislav Petkov wrote:
> On Wed, Oct 31, 2012 at 12:34:45AM -0500, Daniel Santos wrote:
>> Yes, the __build_bug_on_failed message is much more informative.  This
>> will only increase with these patches.  For example, the line
>>
>> BUILD_BUG_ON(sizeof(*c) != 4);
>>
>> emits this error:
>>
>> arch/x86/kernel/cpu/amd.c: In function âearly_init_amdâ:
>> arch/x86/kernel/cpu/amd.c:486:2: error: call to
>> â__build_bug_on_failed_486â declared with attribute error: BUILD_BUG_ON
>> failed: sizeof(*c) != 4
>> make[1]: *** [arch/x86/kernel/cpu/amd.o] Error 1
>> make: *** [arch/x86/kernel/cpu/amd.o] Error 2
>>
>> It's true that there is some redundancy in there as well as the
>> gibberish line number embedded in the function name, but the end of the
>> line spits out the exact statement that failed.
> I guess that's as good as it gets. But it's fine IMO, it tells you
> exactly what you need to know.
Yeah, that's what I'm thinking as well.  Of course, I'm *always* happy
for somebody to come up with a superior solution! :)
>
>> But as far as rather the fallback is first or the __compiletime_error
>> function is a matter of asthetics, since it's really an either/or
>> situation.  Either the __build_bug_on_failedxxx function will be
>> declared with __attribute__((error(message))) and the fallback will
>> expand to a no-op, or the fallback will produce code that (presumably
>> always?) breaks the build.  For insurance, a link-time error will occur
>> if the fallback code fails to break the build.
> Right, but my suggestion was to have the more informative message always
> trigger first, if possible and if gcc supports it (practically, more
> and more systems will be upgrading gcc which has the error attribute
> with time) and have the less informative one be the more seldom one. The
> "fallback" naming is just a minor issue.
>
> This way, the error message would be precise on most modern toolchains.
> Older toolchains will issue something about negative array size, which
> is not really helpful so one would have to fire up an editor and
> actually look at the code :).

lol! :)  Yeah, this is exactly how it should be behaving at this point,
although it's not too clear with the "fallback" macro being defined
elsewhere that it's doing nothing when the error attribute is
available.  I suppose this is another reason to move the whole mechanism
to compiler*.h or add some comments to clarify what's going on.
>> Realistically, a single macro could be defined in compiler*.h that
>> encapsulates the entirety of this mechanism and only exposes a "black
>> box" macro, that will simply expand to something that breaks the build
>> in the most appropriate fashion based upon the version of gcc.  In
>> essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.
> Yes.

Hmmm, this gets tricky.  So I think you are talking about a single
function-like macro that will create the built-time error.  As I see it,
we'll need to move the entirety of __BUILD_BUG_INTERNAL (with the double
evaluation of condition fixed) into compiler*.h, even if we change the
name of the macro.  The alternatives are to a.) further spitting out the
pieces of it into separate little macros (like
__compiletime_error_fallback), which I'm not fond of or b.) allow bug.h
to hold details about compiler functionality, which doesn't seem right
at all.  Let me play with this some and see what I can figure out.

>
>> I guess I'll fix it up (and address the emails on the other patches)
>> and do a v5 then for the whole set? (is that the right way to resubmit
>> with these corrections?)
> Well, you could wait a couple of days first to gather feedback from
> other people and then resend. This way you give chance to people to take
> a look without them seeing too many versions of the patchset and getting
> confused.
>
> What I always do is send out the patchset, collect and discuss changes,
> add in the required changes and test it while the discussions go on.
> After they settle down (and they do in a couple of days, in most cases)
> I then send out the newly tested version out.
>
> That whole exercise takes more or less a week if you're doing other
> stuff in between :)

Ahh, helpful guidelines, thanks so much! :)
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Sat, 03 Nov 2012 18:10:48 +0000
Message-ID: <50955E28.5050609 () att ! net>
--------------------
On 10/31/2012 06:06 AM, Borislav Petkov wrote:
>> Realistically, a single macro could be defined in compiler*.h that
>> encapsulates the entirety of this mechanism and only exposes a "black
>> box" macro, that will simply expand to something that breaks the build
>> in the most appropriate fashion based upon the version of gcc.  In
>> essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.
>
> Yes.

OK, so I have two solutions, one I like and one that I don't.  Both of
these solutions will use the __compiletime_error_fallback macro, but
cleaned up slightly and it will only be used from within compiler.h (so
it becomes a private macro).

#ifndef __compiletime_error
# define __compiletime_error(message)
# define __compiletime_error_fallback(condition) \
        do { ((void)sizeof(char[1 - 2*!!(condition)])); } while (0)
#else
# define __compiletime_error_fallback(condition) do { } while (0)
#endif

And now let me present the solution that I do not like.

// compiler.h (after the above snippet)

#define __compiletime_error_invoke(condition, func)             \
        do {                                                    \
                bool __cond = !!(condition);                    \
                if (__cond)                                     \
                        func();                                 \
                __compiletime_error_fallback(__cond);           \
        } while (0)
#endif


// bug.h
...
#define __BUILD_BUG_INTERNAL(condition, msg, line)              \
        do {                                                    \
                extern void __build_bug_on_failed_ ## line(void)\
                                __compiletime_error(msg);       \
                __compiletime_error_invoke(condition,           \
                                __build_bug_on_failed_ ## line) \
        } while (0)

#define _BUILD_BUG_INTERNAL(condition, msg, line) \
        __BUILD_BUG_INTERNAL(condition, msg, line)

Rather than using __compiletime_error_fallback externally anywhere, we
just use it in another macro in compiler.h. Then, this
__compiletime_error_invoke macro is actually called to invoke the
error.  This problem is that this is highly disjointed; we end up with
large parts of the implementation in both compiler.h and in bug.h.
(also, I think we would need another macro to expand the concatenation
of __build_bug_on_failed_ ## line, I didn't test the above).

If we are going to move this level of detail out of bug.h, I think we
should move *all* of it.

// compiler.h
...

#define __compiletime_assert(condition, msg, __func)                    \
        do {                                                            \
                bool __cond = !!(condition);                            \
                extern void __func(void) __compiletime_error(msg);      \
                if (__cond)                                             \
                        __func();                                       \
                __compiletime_error_fallback(__cond);                   \
        } while (0)

#define _compiletime_assert(condition, msg, __func) \
        __compiletime_assert(condition, msg, __func)

/**
 * compiletime_assert - some documentation...
 */
#define compiletime_assert(condition, msg) \
        __compiletime_assert(condition, msg, __compiletime_assert_ ##
__LINE__)


// bug.h -- remove *BUILD_BUG_INTERNAL macros entirely and just chance this:

#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(cond, msg)

To me, this is much cleaner. It will give all compile-time assertions
the same base function name, but this shouldn't be much of a problem
since the new error attribute will spit out a nice detailed error
message at the point the error occurs and few people (if any?) should be
having to track this down from the link-time error. Even if you are
having to track it down just from a link-time error, it will tell you
the object file that the function was called from and the line number is
embedded in the function name, so it wouldn't be too hard. For example,
it's possible that the link-time error may be the only thing that breaks
on Intel or some other compilers (clang?). Having the full
implementation in compiler*.h allows for easier tweaking to suit various
compilers as well. (I may need to load up intel's latest compiler and
see how it is there).

Anyway, please let me know if you like it.

Daniel

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Sat, 03 Nov 2012 18:10:48 +0000
Message-ID: <50955E28.5050609 () att ! net>
--------------------
On 10/31/2012 06:06 AM, Borislav Petkov wrote:
>> Realistically, a single macro could be defined in compiler*.h that
>> encapsulates the entirety of this mechanism and only exposes a "black
>> box" macro, that will simply expand to something that breaks the build
>> in the most appropriate fashion based upon the version of gcc.  In
>> essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.
>
> Yes.

OK, so I have two solutions, one I like and one that I don't.  Both of
these solutions will use the __compiletime_error_fallback macro, but
cleaned up slightly and it will only be used from within compiler.h (so
it becomes a private macro).

#ifndef __compiletime_error
# define __compiletime_error(message)
# define __compiletime_error_fallback(condition) \
        do { ((void)sizeof(char[1 - 2*!!(condition)])); } while (0)
#else
# define __compiletime_error_fallback(condition) do { } while (0)
#endif

And now let me present the solution that I do not like.

// compiler.h (after the above snippet)

#define __compiletime_error_invoke(condition, func)             \
        do {                                                    \
                bool __cond = !!(condition);                    \
                if (__cond)                                     \
                        func();                                 \
                __compiletime_error_fallback(__cond);           \
        } while (0)
#endif


// bug.h
...
#define __BUILD_BUG_INTERNAL(condition, msg, line)              \
        do {                                                    \
                extern void __build_bug_on_failed_ ## line(void)\
                                __compiletime_error(msg);       \
                __compiletime_error_invoke(condition,           \
                                __build_bug_on_failed_ ## line) \
        } while (0)

#define _BUILD_BUG_INTERNAL(condition, msg, line) \
        __BUILD_BUG_INTERNAL(condition, msg, line)

Rather than using __compiletime_error_fallback externally anywhere, we
just use it in another macro in compiler.h. Then, this
__compiletime_error_invoke macro is actually called to invoke the
error.  This problem is that this is highly disjointed; we end up with
large parts of the implementation in both compiler.h and in bug.h.
(also, I think we would need another macro to expand the concatenation
of __build_bug_on_failed_ ## line, I didn't test the above).

If we are going to move this level of detail out of bug.h, I think we
should move *all* of it.

// compiler.h
...

#define __compiletime_assert(condition, msg, __func)                    \
        do {                                                            \
                bool __cond = !!(condition);                            \
                extern void __func(void) __compiletime_error(msg);      \
                if (__cond)                                             \
                        __func();                                       \
                __compiletime_error_fallback(__cond);                   \
        } while (0)

#define _compiletime_assert(condition, msg, __func) \
        __compiletime_assert(condition, msg, __func)

/**
 * compiletime_assert - some documentation...
 */
#define compiletime_assert(condition, msg) \
        __compiletime_assert(condition, msg, __compiletime_assert_ ##
__LINE__)


// bug.h -- remove *BUILD_BUG_INTERNAL macros entirely and just chance this:

#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(cond, msg)

To me, this is much cleaner. It will give all compile-time assertions
the same base function name, but this shouldn't be much of a problem
since the new error attribute will spit out a nice detailed error
message at the point the error occurs and few people (if any?) should be
having to track this down from the link-time error. Even if you are
having to track it down just from a link-time error, it will tell you
the object file that the function was called from and the line number is
embedded in the function name, so it wouldn't be too hard. For example,
it's possible that the link-time error may be the only thing that breaks
on Intel or some other compilers (clang?). Having the full
implementation in compiler*.h allows for easier tweaking to suit various
compilers as well. (I may need to load up intel's latest compiler and
see how it is there).

Anyway, please let me know if you like it.

Daniel

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v4 6/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Sat, 03 Nov 2012 18:10:48 +0000
Message-ID: <50955E28.5050609 () att ! net>
--------------------
On 10/31/2012 06:06 AM, Borislav Petkov wrote:
>> Realistically, a single macro could be defined in compiler*.h that
>> encapsulates the entirety of this mechanism and only exposes a "black
>> box" macro, that will simply expand to something that breaks the build
>> in the most appropriate fashion based upon the version of gcc.  In
>> essence, the new BUILD_BUG_ON_MSG macro attempts to fill that roll.
>
> Yes.

OK, so I have two solutions, one I like and one that I don't.  Both of
these solutions will use the __compiletime_error_fallback macro, but
cleaned up slightly and it will only be used from within compiler.h (so
it becomes a private macro).

#ifndef __compiletime_error
# define __compiletime_error(message)
# define __compiletime_error_fallback(condition) \
        do { ((void)sizeof(char[1 - 2*!!(condition)])); } while (0)
#else
# define __compiletime_error_fallback(condition) do { } while (0)
#endif

And now let me present the solution that I do not like.

// compiler.h (after the above snippet)

#define __compiletime_error_invoke(condition, func)             \
        do {                                                    \
                bool __cond = !!(condition);                    \
                if (__cond)                                     \
                        func();                                 \
                __compiletime_error_fallback(__cond);           \
        } while (0)
#endif


// bug.h
...
#define __BUILD_BUG_INTERNAL(condition, msg, line)              \
        do {                                                    \
                extern void __build_bug_on_failed_ ## line(void)\
                                __compiletime_error(msg);       \
                __compiletime_error_invoke(condition,           \
                                __build_bug_on_failed_ ## line) \
        } while (0)

#define _BUILD_BUG_INTERNAL(condition, msg, line) \
        __BUILD_BUG_INTERNAL(condition, msg, line)

Rather than using __compiletime_error_fallback externally anywhere, we
just use it in another macro in compiler.h. Then, this
__compiletime_error_invoke macro is actually called to invoke the
error.  This problem is that this is highly disjointed; we end up with
large parts of the implementation in both compiler.h and in bug.h.
(also, I think we would need another macro to expand the concatenation
of __build_bug_on_failed_ ## line, I didn't test the above).

If we are going to move this level of detail out of bug.h, I think we
should move *all* of it.

// compiler.h
...

#define __compiletime_assert(condition, msg, __func)                    \
        do {                                                            \
                bool __cond = !!(condition);                            \
                extern void __func(void) __compiletime_error(msg);      \
                if (__cond)                                             \
                        __func();                                       \
                __compiletime_error_fallback(__cond);                   \
        } while (0)

#define _compiletime_assert(condition, msg, __func) \
        __compiletime_assert(condition, msg, __func)

/**
 * compiletime_assert - some documentation...
 */
#define compiletime_assert(condition, msg) \
        __compiletime_assert(condition, msg, __compiletime_assert_ ##
__LINE__)


// bug.h -- remove *BUILD_BUG_INTERNAL macros entirely and just chance this:

#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(cond, msg)

To me, this is much cleaner. It will give all compile-time assertions
the same base function name, but this shouldn't be much of a problem
since the new error attribute will spit out a nice detailed error
message at the point the error occurs and few people (if any?) should be
having to track this down from the link-time error. Even if you are
having to track it down just from a link-time error, it will tell you
the object file that the function was called from and the line number is
embedded in the function name, so it wouldn't be too hard. For example,
it's possible that the link-time error may be the only thing that breaks
on Intel or some other compilers (clang?). Having the full
implementation in compiler*.h allows for easier tweaking to suit various
compilers as well. (I may need to load up intel's latest compiler and
see how it is there).

Anyway, please let me know if you like it.

Daniel

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v4 8/9] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL ===

From: danielfsantos () att ! net
To: linux-kernel
Subject: [PATCH v4 8/9] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL
Date: Sun, 28 Oct 2012 20:57:14 +0000
Message-ID: <1351457835-7553-8-git-send-email-daniel.santos () pobox ! com>
--------------------
Add BUILD_BUG_ON_MSG which behaves like BUILD_BUG_ON (with optimizations
enabled), except that it allows you to specify the error message you
want emitted as the third parameter.  Under the hood, this relies on
_BUILD_BUG_INTERNAL, which does the actual work and is pretty-much
identical to BUILD_BUG_ON.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |   22 ++++++++++++++++++++++
 1 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 6c38988..3bc1ddf 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -16,6 +16,7 @@ struct pt_regs;
 #define BUILD_BUG_ON_NOT_POWER_OF_2(n)
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
+#define BUILD_BUG_ON_MSG(cond, msg) (0)
 #define BUILD_BUG_ON(condition) (0)
 #define BUILD_BUG() (0)
 #else /* __CHECKER__ */
@@ -38,6 +39,27 @@ struct pt_regs;
  */
 #define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))
 
+#define __BUILD_BUG_INTERNAL(condition, msg, line)		\
+	do {							\
+		extern void __build_bug_on_failed_ ## line	\
+			(void) __compiletime_error(msg);	\
+		__compiletime_error_fallback(condition);	\
+		if (condition)					\
+			__build_bug_on_failed_ ## line();	\
+	} while (0)
+
+#define _BUILD_BUG_INTERNAL(condition, msg, line) \
+	__BUILD_BUG_INTERNAL(condition, msg, line)
+
+/**
+ * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied
+ * 		      error message.
+ * @condition: the condition which the compiler should know is false.
+ *
+ * See BUILD_BUG_ON for description.
+ */
+#define BUILD_BUG_ON_MSG(cond, msg) _BUILD_BUG_INTERNAL(cond, msg, __LINE__)
+
 /**
  * BUILD_BUG_ON - break compile if a condition is true.
  * @condition: the condition which the compiler should know is false.
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v4 8/9] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL
Date: Sun, 28 Oct 2012 20:57:14 +0000
Message-ID: <1351457835-7553-8-git-send-email-daniel.santos () pobox ! com>
--------------------
Add BUILD_BUG_ON_MSG which behaves like BUILD_BUG_ON (with optimizations
enabled), except that it allows you to specify the error message you
want emitted as the third parameter.  Under the hood, this relies on
_BUILD_BUG_INTERNAL, which does the actual work and is pretty-much
identical to BUILD_BUG_ON.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |   22 ++++++++++++++++++++++
 1 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 6c38988..3bc1ddf 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -16,6 +16,7 @@ struct pt_regs;
 #define BUILD_BUG_ON_NOT_POWER_OF_2(n)
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
+#define BUILD_BUG_ON_MSG(cond, msg) (0)
 #define BUILD_BUG_ON(condition) (0)
 #define BUILD_BUG() (0)
 #else /* __CHECKER__ */
@@ -38,6 +39,27 @@ struct pt_regs;
  */
 #define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))
 
+#define __BUILD_BUG_INTERNAL(condition, msg, line)		\
+	do {							\
+		extern void __build_bug_on_failed_ ## line	\
+			(void) __compiletime_error(msg);	\
+		__compiletime_error_fallback(condition);	\
+		if (condition)					\
+			__build_bug_on_failed_ ## line();	\
+	} while (0)
+
+#define _BUILD_BUG_INTERNAL(condition, msg, line) \
+	__BUILD_BUG_INTERNAL(condition, msg, line)
+
+/**
+ * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied
+ * 		      error message.
+ * @condition: the condition which the compiler should know is false.
+ *
+ * See BUILD_BUG_ON for description.
+ */
+#define BUILD_BUG_ON_MSG(cond, msg) _BUILD_BUG_INTERNAL(cond, msg, __LINE__)
+
 /**
  * BUILD_BUG_ON - break compile if a condition is true.
  * @condition: the condition which the compiler should know is false.
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v4 8/9] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL
Date: Tue, 30 Oct 2012 17:17:47 +0000
Message-ID: <20121030171747.GF28499 () liondog ! tnic>
--------------------
On Sun, Oct 28, 2012 at 03:57:14PM -0500, danielfsantos@att.net wrote:
> Add BUILD_BUG_ON_MSG which behaves like BUILD_BUG_ON (with optimizations
> enabled), except that it allows you to specify the error message you
> want emitted as the third parameter.  Under the hood, this relies on
> _BUILD_BUG_INTERNAL, which does the actual work and is pretty-much
> identical to BUILD_BUG_ON.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> ---
>  include/linux/bug.h |   22 ++++++++++++++++++++++
>  1 files changed, 22 insertions(+), 0 deletions(-)
> 
> diff --git a/include/linux/bug.h b/include/linux/bug.h
> index 6c38988..3bc1ddf 100644
> --- a/include/linux/bug.h
> +++ b/include/linux/bug.h
> @@ -16,6 +16,7 @@ struct pt_regs;
>  #define BUILD_BUG_ON_NOT_POWER_OF_2(n)
>  #define BUILD_BUG_ON_ZERO(e) (0)
>  #define BUILD_BUG_ON_NULL(e) ((void*)0)
> +#define BUILD_BUG_ON_MSG(cond, msg) (0)
>  #define BUILD_BUG_ON(condition) (0)
>  #define BUILD_BUG() (0)
>  #else /* __CHECKER__ */
> @@ -38,6 +39,27 @@ struct pt_regs;
>   */
>  #define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))
>  
> +#define __BUILD_BUG_INTERNAL(condition, msg, line)		\
> +	do {							\
> +		extern void __build_bug_on_failed_ ## line	\
> +			(void) __compiletime_error(msg);	\
> +		__compiletime_error_fallback(condition);	\
> +		if (condition)					\
> +			__build_bug_on_failed_ ## line();	\
> +	} while (0)
> +
> +#define _BUILD_BUG_INTERNAL(condition, msg, line) \
> +	__BUILD_BUG_INTERNAL(condition, msg, line)

Stupid question:

can BUILD_BUG_ON and BUILD_BUG_ON_MSG both use __BUILD_BUG_INTERNAL?

In the BUILD_BUG_ON msg will be "BUILD_BUG_ON failed" and line empty.
Can that even work?

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v4 8/9] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL
Date: Tue, 30 Oct 2012 21:57:30 +0000
Message-ID: <20121030215729.GB9558 () liondog ! tnic>
--------------------
On Tue, Oct 30, 2012 at 06:17:47PM +0100, Borislav Petkov wrote:
> can BUILD_BUG_ON and BUILD_BUG_ON_MSG both use __BUILD_BUG_INTERNAL?
>
> In the BUILD_BUG_ON msg will be "BUILD_BUG_ON failed" and line empty.
> Can that even work?

Yes it can, I should simply look at patch 9/9 first :-).

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v4 8/9] bug.h: Add BUILD_BUG_ON_MSG & _BUILD_BUG_INTERNAL
Date: Tue, 30 Oct 2012 21:57:30 +0000
Message-ID: <20121030215729.GB9558 () liondog ! tnic>
--------------------
On Tue, Oct 30, 2012 at 06:17:47PM +0100, Borislav Petkov wrote:
> can BUILD_BUG_ON and BUILD_BUG_ON_MSG both use __BUILD_BUG_INTERNAL?
>
> In the BUILD_BUG_ON msg will be "BUILD_BUG_ON failed" and line empty.
> Can that even work?

Yes it can, I should simply look at patch 9/9 first :-).

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH v4 9/9] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG ===

From: danielfsantos () att ! net
To: linux-kernel
Subject: [PATCH v4 9/9] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG
Date: Sun, 28 Oct 2012 20:57:15 +0000
Message-ID: <1351457835-7553-9-git-send-email-daniel.santos () pobox ! com>
--------------------
Remove duplicate code by converting BUILD_BUG and BUILD_BUG_ON to just
call BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but
also prevents the possibility of code being changed for one macro and
not for the other (which was previously the case for BUILD_BUG and
BUILD_BUG_ON).

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |   17 +++--------------
 1 files changed, 3 insertions(+), 14 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 3bc1ddf..b58ba51 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -81,14 +81,8 @@ struct pt_regs;
 #ifndef __OPTIMIZE__
 #define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
 #else
-#define BUILD_BUG_ON(condition)						\
-	do {								\
-		extern void __build_bug_on_failed(void)			\
-			__compiletime_error("BUILD_BUG_ON failed");	\
-		__compiletime_error_fallback(condition);		\
-		if (condition)						\
-			__build_bug_on_failed();			\
-	} while(0)
+#define BUILD_BUG_ON(condition) \
+	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)
 #endif
 
 /**
@@ -98,12 +92,7 @@ struct pt_regs;
  * build time, you should use BUILD_BUG to detect if it is
  * unexpectedly used.
  */
-#define BUILD_BUG()						\
-	do {							\
-		extern void __build_bug_failed(void)		\
-			__compiletime_error("BUILD_BUG failed");\
-		__build_bug_failed();				\
-	} while (0)
+#define BUILD_BUG() BUILD_BUG_ON_MSG(1, "BUILD_BUG failed")
 
 #endif	/* __CHECKER__ */
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v4 9/9] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG
Date: Tue, 30 Oct 2012 19:19:05 +0000
Message-ID: <20121030191905.GG28499 () liondog ! tnic>
--------------------
On Sun, Oct 28, 2012 at 03:57:15PM -0500, danielfsantos@att.net wrote:
> Remove duplicate code by converting BUILD_BUG and BUILD_BUG_ON to just
> call BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but
> also prevents the possibility of code being changed for one macro and
> not for the other (which was previously the case for BUILD_BUG and
> BUILD_BUG_ON).
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> ---
>  include/linux/bug.h |   17 +++--------------
>  1 files changed, 3 insertions(+), 14 deletions(-)
> 
> diff --git a/include/linux/bug.h b/include/linux/bug.h
> index 3bc1ddf..b58ba51 100644
> --- a/include/linux/bug.h
> +++ b/include/linux/bug.h
> @@ -81,14 +81,8 @@ struct pt_regs;
>  #ifndef __OPTIMIZE__
>  #define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
>  #else
> -#define BUILD_BUG_ON(condition)						\
> -	do {								\
> -		extern void __build_bug_on_failed(void)			\
> -			__compiletime_error("BUILD_BUG_ON failed");	\
> -		__compiletime_error_fallback(condition);		\
> -		if (condition)						\
> -			__build_bug_on_failed();			\
> -	} while(0)
> +#define BUILD_BUG_ON(condition) \
> +	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)

Concatenating "condition" might not be very informative in all cases.
For example:

BUILD_BUG_ON(1);

Having __LINE__ is good enough IMHO.

Thanks.

-- 
Regards/Gruss,
    Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH v4 9/9] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG
Date: Wed, 31 Oct 2012 01:02:32 +0000
Message-ID: <20121031010232.GA18229 () leaf>
--------------------
On Tue, Oct 30, 2012 at 08:19:05PM +0100, Borislav Petkov wrote:
> On Sun, Oct 28, 2012 at 03:57:15PM -0500, danielfsantos@att.net wrote:
> > Remove duplicate code by converting BUILD_BUG and BUILD_BUG_ON to just
> > call BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but
> > also prevents the possibility of code being changed for one macro and
> > not for the other (which was previously the case for BUILD_BUG and
> > BUILD_BUG_ON).
> > 
> > Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> > ---
> >  include/linux/bug.h |   17 +++--------------
> >  1 files changed, 3 insertions(+), 14 deletions(-)
> > 
> > diff --git a/include/linux/bug.h b/include/linux/bug.h
> > index 3bc1ddf..b58ba51 100644
> > --- a/include/linux/bug.h
> > +++ b/include/linux/bug.h
> > @@ -81,14 +81,8 @@ struct pt_regs;
> >  #ifndef __OPTIMIZE__
> >  #define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
> >  #else
> > -#define BUILD_BUG_ON(condition)						\
> > -	do {								\
> > -		extern void __build_bug_on_failed(void)			\
> > -			__compiletime_error("BUILD_BUG_ON failed");	\
> > -		__compiletime_error_fallback(condition);		\
> > -		if (condition)						\
> > -			__build_bug_on_failed();			\
> > -	} while(0)
> > +#define BUILD_BUG_ON(condition) \
> > +	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)
> 
> Concatenating "condition" might not be very informative in all cases.
> For example:
> 
> BUILD_BUG_ON(1);
> 
> Having __LINE__ is good enough IMHO.

While it doesn't always help, it may help sometimes.  Worst case,
BUILD_BUG_ON(1) gives you no less information than it did before; best
case, it gives you useful data.

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v4 9/9] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG
Date: Wed, 31 Oct 2012 05:48:38 +0000
Message-ID: <5090BBB6.6080607 () att ! net>
--------------------
On 10/30/2012 08:02 PM, Josh Triplett wrote:
> On Tue, Oct 30, 2012 at 08:19:05PM +0100, Borislav Petkov wrote:
>> On Sun, Oct 28, 2012 at 03:57:15PM -0500, danielfsantos@att.net wrote:
>>> Remove duplicate code by converting BUILD_BUG and BUILD_BUG_ON to just
>>> call BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but
>>> also prevents the possibility of code being changed for one macro and
>>> not for the other (which was previously the case for BUILD_BUG and
>>> BUILD_BUG_ON).
>>>
>>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>>> ---
>>>  include/linux/bug.h |   17 +++--------------
>>>  1 files changed, 3 insertions(+), 14 deletions(-)
>>>
>>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>>> index 3bc1ddf..b58ba51 100644
>>> --- a/include/linux/bug.h
>>> +++ b/include/linux/bug.h
>>> @@ -81,14 +81,8 @@ struct pt_regs;
>>>  #ifndef __OPTIMIZE__
>>>  #define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
>>>  #else
>>> -#define BUILD_BUG_ON(condition)						\
>>> -	do {								\
>>> -		extern void __build_bug_on_failed(void)			\
>>> -			__compiletime_error("BUILD_BUG_ON failed");	\
>>> -		__compiletime_error_fallback(condition);		\
>>> -		if (condition)						\
>>> -			__build_bug_on_failed();			\
>>> -	} while(0)
>>> +#define BUILD_BUG_ON(condition) \
>>> +	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)
>> Concatenating "condition" might not be very informative in all cases.
>> For example:
>>
>> BUILD_BUG_ON(1);
>>
>> Having __LINE__ is good enough IMHO.

Honestly, __LINE__ is only used to keep the function name unique.  If
anything, I think that having it creates more confusion rather than adds
clarity since the error message will indicate the file and line number
anyway.  So in other words, it is redundant without it being apparent
why.  Of course, it's a very simple and portable mechanism to keep the
symbols unique.  IMO, using __COUNTER__would be better for clarity
(since the number wouldn't relate to the anything real), but it is not
portable across versions of gcc (introduced in 4.4 or some such), so we
are using __LINE__.

> While it doesn't always help, it may help sometimes.  Worst case,
> BUILD_BUG_ON(1) gives you no less information than it did before; best
> case, it gives you useful data.

Yeah, and depending upon what it's fed (and how much pre-processing had
been done on that) it can actually prove helpful because stringifying
condition can reveal pre-processing errors as well.  So if you passed
some macro as the condition and it didn't expand the way you expected,
this error message will print out exactly how it expanded, up to the
point of having been passed to BUILD_BUG_ON.  I don't know how much that
could potentially help, but for troubleshooting, I find extra
information helpful, more often than harmful.

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v4 9/9] bug.h: Convert BUILD_BUG{,_ON} to use BUILD_BUG_ON_MSG
Date: Wed, 31 Oct 2012 05:48:38 +0000
Message-ID: <5090BBB6.6080607 () att ! net>
--------------------
On 10/30/2012 08:02 PM, Josh Triplett wrote:
> On Tue, Oct 30, 2012 at 08:19:05PM +0100, Borislav Petkov wrote:
>> On Sun, Oct 28, 2012 at 03:57:15PM -0500, danielfsantos@att.net wrote:
>>> Remove duplicate code by converting BUILD_BUG and BUILD_BUG_ON to just
>>> call BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but
>>> also prevents the possibility of code being changed for one macro and
>>> not for the other (which was previously the case for BUILD_BUG and
>>> BUILD_BUG_ON).
>>>
>>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>>> ---
>>>  include/linux/bug.h |   17 +++--------------
>>>  1 files changed, 3 insertions(+), 14 deletions(-)
>>>
>>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>>> index 3bc1ddf..b58ba51 100644
>>> --- a/include/linux/bug.h
>>> +++ b/include/linux/bug.h
>>> @@ -81,14 +81,8 @@ struct pt_regs;
>>>  #ifndef __OPTIMIZE__
>>>  #define BUILD_BUG_ON(condition) __compiletime_error_fallback(condition)
>>>  #else
>>> -#define BUILD_BUG_ON(condition)						\
>>> -	do {								\
>>> -		extern void __build_bug_on_failed(void)			\
>>> -			__compiletime_error("BUILD_BUG_ON failed");	\
>>> -		__compiletime_error_fallback(condition);		\
>>> -		if (condition)						\
>>> -			__build_bug_on_failed();			\
>>> -	} while(0)
>>> +#define BUILD_BUG_ON(condition) \
>>> +	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)
>> Concatenating "condition" might not be very informative in all cases.
>> For example:
>>
>> BUILD_BUG_ON(1);
>>
>> Having __LINE__ is good enough IMHO.

Honestly, __LINE__ is only used to keep the function name unique.  If
anything, I think that having it creates more confusion rather than adds
clarity since the error message will indicate the file and line number
anyway.  So in other words, it is redundant without it being apparent
why.  Of course, it's a very simple and portable mechanism to keep the
symbols unique.  IMO, using __COUNTER__would be better for clarity
(since the number wouldn't relate to the anything real), but it is not
portable across versions of gcc (introduced in 4.4 or some such), so we
are using __LINE__.

> While it doesn't always help, it may help sometimes.  Worst case,
> BUILD_BUG_ON(1) gives you no less information than it did before; best
> case, it gives you useful data.

Yeah, and depending upon what it's fed (and how much pre-processing had
been done on that) it can actually prove helpful because stringifying
condition can reveal pre-processing errors as well.  So if you passed
some macro as the condition and it didn't expand the way you expected,
this error message will print out exactly how it expanded, up to the
point of having been passed to BUILD_BUG_ON.  I don't know how much that
could potentially help, but for troubleshooting, I find extra
information helpful, more often than harmful.

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v5 0/9] Cleanup & new features for compiler*.h and bug.h ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 0/9] Cleanup & new features for compiler*.h and bug.h
Date: Tue, 13 Nov 2012 22:09:19 +0000
Message-ID: <1352844568-18826-1-git-send-email-daniel.santos () pobox ! com>
--------------------

 include/linux/bug.h           |   47 ++++++++++++++++++++++------------------
 include/linux/compiler-gcc.h  |    3 ++
 include/linux/compiler-gcc3.h |    8 +++---
 include/linux/compiler-gcc4.h |   28 ++++++++++++------------
 include/linux/compiler.h      |   32 +++++++++++++++++++++++++--
 5 files changed, 76 insertions(+), 42 deletions(-)

Changes in v5:
o Move BUILD_BUG* guts to a new compiletime_assert() macro in compiler.h.
o Fix a double-evaluation problem.
o Fix another bad macro definition when __CHECKER__ defined.

Changes in v4:
o Squash a minor commit (per Borislav Petkov)
o Change some comment text (per Borislav Petkov)
o Add some acks

This patch set is a dependency of the generic red-black tree patch set, which
I have now split up into three smaller sets and is based off of linux-next.

The major aim of this patch set is to cleanup compiler-gcc*.h and improve
the manageability of of compiler features at various versions (when they
are broken, etc.), add some needed features to bug.h and clean that up as
well.

compiler-gcc*.h
o Introduce GCC_VERSION - (e.g., gcc 4.7.1 becomes 40701).
o Reorder all features based upon the version introduced (readability).
o Change all version checks to use GCC_VERSION.
o Remove redundant __linktime_error macro.
o Introduce compiletime_assert() macro.

bug.h
o Improve BUILD_BUG_ON(expr) - now generates compile-time error post-gcc-4.4
o Remove duplicate error messages in some cases.
o Fix double-evaluation problem in BUILD_BUG_ON.
o Fix bad macro definitions when using __CHECKER__.
o Introduce BUILD_BUG_ON_MSG and clean up the implementations of the
  BUILD_BUG* macros.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v5 2/9] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 2/9] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro
Date: Tue, 13 Nov 2012 22:13:34 +0000
Message-ID: <1352844821-18952-2-git-send-email-daniel.santos () pobox ! com>
--------------------
Throughout compiler*.h, many version checks are made.  These can be
simplified by using the macro that gcc's documentation recommends.
However, my primary reason for adding this is that I need bug-check
macros that are enabled at certain gcc versions and it's cleaner to use
this macro than the tradition method:

if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ => 2)

If you add patch level, it gets this ugly:

if __GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
   __GNUC_MINOR__ == 2 __GNUC_PATCHLEVEL__ >= 1))

As opposed to:

if GCC_VERSION >= 40201

While having separate headers for gcc 3 & 4 eliminates some of this
verbosity, they can still be cleaned up by this.

See also:
http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: Borislav Petkov <bp@alien8.de>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc.h |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 6a6d7ae..24545cd 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -5,6 +5,9 @@
 /*
  * Common definitions for all gcc versions go here.
  */
+#define GCC_VERSION (__GNUC__ * 10000 \
+		   + __GNUC_MINOR__ * 100 \
+		   + __GNUC_PATCHLEVEL__)
 
 
 /* Optimization barrier */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v5 3/9] compiler-gcc{3,4}.h: Use GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 3/9] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Tue, 13 Nov 2012 22:13:35 +0000
Message-ID: <1352844821-18952-3-git-send-email-daniel.santos () pobox ! com>
--------------------
Using GCC_VERSION reduces complexity, is easier to read and is GCC's
recommended mechanism for doing version checks. (Just don't ask me why
they didn't define it in the first place.)  This also makes it easy to
merge compiler-gcc{,3,4}.h should somebody want to.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/compiler-gcc3.h |    8 ++++----
 include/linux/compiler-gcc4.h |   14 +++++++-------
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
index 37d4124..7d89feb 100644
--- a/include/linux/compiler-gcc3.h
+++ b/include/linux/compiler-gcc3.h
@@ -2,22 +2,22 @@
 #error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
 #endif
 
-#if __GNUC_MINOR__ < 2
+#if GCC_VERSION < 30200
 # error Sorry, your compiler is too old - please upgrade it.
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 30300
 # define __used			__attribute__((__used__))
 #else
 # define __used			__attribute__((__unused__))
 #endif
 
-#if __GNUC_MINOR__ >= 4
+#if GCC_VERSION >= 30400
 #define __must_check		__attribute__((warn_unused_result))
 #endif
 
 #ifdef CONFIG_GCOV_KERNEL
-# if __GNUC_MINOR__ < 4
+# if GCC_VERSION < 30400
 #   error "GCOV profiling support for gcc versions below 3.4 not included"
 # endif /* __GNUC_MINOR__ */
 #endif /* CONFIG_GCOV_KERNEL */
diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 8914293..9755029 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -4,7 +4,7 @@
 
 /* GCC 4.1.[01] miscompiles __weak */
 #ifdef __KERNEL__
-# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
+# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
 #  error Your version of gcc miscompiles the __weak directive
 # endif
 #endif
@@ -13,11 +13,11 @@
 #define __must_check 		__attribute__((warn_unused_result))
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
 
-#if __GNUC_MINOR__ > 0
+#if GCC_VERSION >= 40100
 # define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 40300
 /* Mark functions as cold. gcc will assume any path leading to a call
    to them will be unlikely.  This means a lot of manual unlikely()s
    are unnecessary now for any paths leading to the usual suspects
@@ -39,9 +39,9 @@
 # define __compiletime_warning(message) __attribute__((warning(message)))
 # define __compiletime_error(message) __attribute__((error(message)))
 #endif /* __CHECKER__ */
-#endif /* __GNUC_MINOR__ >= 3 */
+#endif /* GCC_VERSION >= 40300 */
 
-#if __GNUC_MINOR__ >= 5
+#if GCC_VERSION >= 40500
 /*
  * Mark a position in code as unreachable.  This can be used to
  * suppress control flow warnings after asm blocks that transfer
@@ -56,9 +56,9 @@
 /* Mark a function definition as prohibited from being cloned. */
 #define __noclone	__attribute__((__noclone__))
 
-#endif /* __GNUC_MINOR__ >= 5 */
+#endif /* GCC_VERSION >= 40500 */
 
-#if __GNUC_MINOR__ >= 6
+#if GCC_VERSION >= 40600
 /*
  * Tell the optimizer that something else uses this function or variable.
  */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v5 4/9] compiler{,-gcc4}.h, bug.h: Remove duplicate macros ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 4/9] compiler{,-gcc4}.h, bug.h: Remove duplicate macros
Date: Tue, 13 Nov 2012 22:13:36 +0000
Message-ID: <1352844821-18952-4-git-send-email-daniel.santos () pobox ! com>
--------------------
__linktime_error() does the same thing as __compiletime_error() and is
only used in bug.h.  Since the macro defines a function attribute that
will cause a failure at compile-time (not link-time), it makes more
sense to keep __compiletime_error(), which is also neatly mated with
__compiletime_warning().

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/bug.h           |    2 +-
 include/linux/compiler-gcc4.h |    2 --
 include/linux/compiler.h      |    3 ---
 3 files changed, 1 insertions(+), 6 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index aaac4bb..298a916 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -73,7 +73,7 @@ extern int __build_bug_on_failed;
 #define BUILD_BUG()						\
 	do {							\
 		extern void __build_bug_failed(void)		\
-			__linktime_error("BUILD_BUG failed");	\
+			__compiletime_error("BUILD_BUG failed");\
 		__build_bug_failed();				\
 	} while (0)
 
diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 9755029..7f143ac 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -33,8 +33,6 @@
    the kernel context */
 #define __cold			__attribute__((__cold__))
 
-#define __linktime_error(message) __attribute__((__error__(message)))
-
 #ifndef __CHECKER__
 # define __compiletime_warning(message) __attribute__((warning(message)))
 # define __compiletime_error(message) __attribute__((error(message)))
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index b121554..cbf6d9d 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -299,9 +299,6 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 #ifndef __compiletime_error
 # define __compiletime_error(message)
 #endif
-#ifndef __linktime_error
-# define __linktime_error(message)
-#endif
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v5 5/9] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__ ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 5/9] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__
Date: Tue, 13 Nov 2012 22:13:37 +0000
Message-ID: <1352844821-18952-5-git-send-email-daniel.santos () pobox ! com>
--------------------
When __CHECKER__ is defined, we disable all of the BUILD_BUG.* macros.
However, both BUILD_BUG_ON_NOT_POWER_OF_2 and BUILD_BUG_ON was
evaluating to nothing in this case, and we want (0) since this is a
function-like macro that will be followed by a semicolon.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 298a916..1b2465d 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -12,10 +12,10 @@ enum bug_trap_type {
 struct pt_regs;
 
 #ifdef __CHECKER__
-#define BUILD_BUG_ON_NOT_POWER_OF_2(n)
+#define BUILD_BUG_ON_NOT_POWER_OF_2(n) (0)
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
-#define BUILD_BUG_ON(condition)
+#define BUILD_BUG_ON(condition) (0)
 #define BUILD_BUG() (0)
 #else /* __CHECKER__ */
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v5 5/9] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__
Date: Thu, 15 Nov 2012 15:07:35 +0000
Message-ID: <20121115150735.GE4956 () x1 ! osrc ! amd ! com>
--------------------
On Tue, Nov 13, 2012 at 04:13:37PM -0600, danielfsantos@att.net wrote:
> When __CHECKER__ is defined, we disable all of the BUILD_BUG.* macros.
> However, both BUILD_BUG_ON_NOT_POWER_OF_2 and BUILD_BUG_ON was
> evaluating to nothing in this case, and we want (0) since this is a
> function-like macro that will be followed by a semicolon.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>

Acked-by: Borislav Petkov <bp@alien8.de>

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v5 5/9] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__
Date: Thu, 15 Nov 2012 15:07:35 +0000
Message-ID: <20121115150735.GE4956 () x1 ! osrc ! amd ! com>
--------------------
On Tue, Nov 13, 2012 at 04:13:37PM -0600, danielfsantos@att.net wrote:
> When __CHECKER__ is defined, we disable all of the BUILD_BUG.* macros.
> However, both BUILD_BUG_ON_NOT_POWER_OF_2 and BUILD_BUG_ON was
> evaluating to nothing in this case, and we want (0) since this is a
> function-like macro that will be followed by a semicolon.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>

Acked-by: Borislav Petkov <bp@alien8.de>

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v5 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON
Date: Tue, 13 Nov 2012 22:13:38 +0000
Message-ID: <1352844821-18952-6-git-send-email-daniel.santos () pobox ! com>
--------------------
When calling BUILD_BUG_ON in an optimized build using gcc 4.3 and later,
the condition will be evaulated twice, possibily with side-effects.
This patch eliminates that error.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 1b2465d..ccd44ce 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -58,8 +58,9 @@ struct pt_regs;
 extern int __build_bug_on_failed;
 #define BUILD_BUG_ON(condition)					\
 	do {							\
-		((void)sizeof(char[1 - 2*!!(condition)]));	\
-		if (condition) __build_bug_on_failed = 1;	\
+		bool __cond = !!(condition);			\
+		((void)sizeof(char[1 - 2*!!(__cond)]));		\
+		if (__cond) __build_bug_on_failed = 1;		\
 	} while(0)
 #endif
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v5 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON
Date: Thu, 15 Nov 2012 15:07:27 +0000
Message-ID: <20121115150726.GD4956 () x1 ! osrc ! amd ! com>
--------------------
On Tue, Nov 13, 2012 at 04:13:38PM -0600, danielfsantos@att.net wrote:
> When calling BUILD_BUG_ON in an optimized build using gcc 4.3 and later,
> the condition will be evaulated twice, possibily with side-effects.
> This patch eliminates that error.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> ---
>  include/linux/bug.h |    5 +++--
>  1 files changed, 3 insertions(+), 2 deletions(-)
> 
> diff --git a/include/linux/bug.h b/include/linux/bug.h
> index 1b2465d..ccd44ce 100644
> --- a/include/linux/bug.h
> +++ b/include/linux/bug.h
> @@ -58,8 +58,9 @@ struct pt_regs;
>  extern int __build_bug_on_failed;
>  #define BUILD_BUG_ON(condition)					\
>  	do {							\
> -		((void)sizeof(char[1 - 2*!!(condition)]));	\
> -		if (condition) __build_bug_on_failed = 1;	\
> +		bool __cond = !!(condition);			\
> +		((void)sizeof(char[1 - 2*!!(__cond)]));		\

No need for the !!(__cond) here because you've done it in the line
above. IOW,

	bool __cond = !!(condition);
	((void)sizeof(char[1 - 2 * __cond]));

which is even a bit more readable, as a matter of fact.

> +		if (__cond) __build_bug_on_failed = 1;		\
>  	} while(0)
>  #endif

Thanks.

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v5 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON
Date: Thu, 15 Nov 2012 19:11:15 +0000
Message-ID: <50A53E53.8080404 () att ! net>
--------------------
On 11/15/2012 09:07 AM, Borislav Petkov wrote:
> On Tue, Nov 13, 2012 at 04:13:38PM -0600, danielfsantos@att.net wrote:
>> When calling BUILD_BUG_ON in an optimized build using gcc 4.3 and later,
>> the condition will be evaulated twice, possibily with side-effects.
>> This patch eliminates that error.
>>
>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>> ---
>>  include/linux/bug.h |    5 +++--
>>  1 files changed, 3 insertions(+), 2 deletions(-)
>>
>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>> index 1b2465d..ccd44ce 100644
>> --- a/include/linux/bug.h
>> +++ b/include/linux/bug.h
>> @@ -58,8 +58,9 @@ struct pt_regs;
>>  extern int __build_bug_on_failed;
>>  #define BUILD_BUG_ON(condition)					\
>>  	do {							\
>> -		((void)sizeof(char[1 - 2*!!(condition)]));	\
>> -		if (condition) __build_bug_on_failed = 1;	\
>> +		bool __cond = !!(condition);			\
>> +		((void)sizeof(char[1 - 2*!!(__cond)]));		\
> No need for the !!(__cond) here because you've done it in the line
> above. IOW,
>
> 	bool __cond = !!(condition);
> 	((void)sizeof(char[1 - 2 * __cond]));
>
> which is even a bit more readable, as a matter of fact.
Ah yes. I did notice that at one point, but I think it slipped my mind. 
Also, the kernel has introduced me to the usage of the !! construct, of
which I'm well versed in its affects in various situations and how gcc's
optimizer ends up treating its usage, so probably another reason I
didn't change it immediately. But it's basically shorthand for the
expression (condition ? 1 : 0), correct? Or are there other details in
the C standard that makes it different in some cases?

Thanks,
Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v5 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON
Date: Sat, 17 Nov 2012 14:38:41 +0000
Message-ID: <20121117143840.GB16441 () x1 ! osrc ! amd ! com>
--------------------
On Thu, Nov 15, 2012 at 01:11:15PM -0600, Daniel Santos wrote:
> Ah yes. I did notice that at one point, but I think it slipped
> my mind. Also, the kernel has introduced me to the usage of the
> !! construct, of which I'm well versed in its affects in various
> situations and how gcc's optimizer ends up treating its usage, so
> probably another reason I didn't change it immediately. But it's
> basically shorthand for the expression (condition ? 1 : 0), correct?

I don't think so: "!!" is simply a double negation which turns the
whatever wild construct you have into either 0 or 1, depending on what
it evaluates to.

But I don't know what the standard says so you'll have to check :-)

Thanks.

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v5 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON
Date: Sat, 17 Nov 2012 14:38:41 +0000
Message-ID: <20121117143840.GB16441 () x1 ! osrc ! amd ! com>
--------------------
On Thu, Nov 15, 2012 at 01:11:15PM -0600, Daniel Santos wrote:
> Ah yes. I did notice that at one point, but I think it slipped
> my mind. Also, the kernel has introduced me to the usage of the
> !! construct, of which I'm well versed in its affects in various
> situations and how gcc's optimizer ends up treating its usage, so
> probably another reason I didn't change it immediately. But it's
> basically shorthand for the expression (condition ? 1 : 0), correct?

I don't think so: "!!" is simply a double negation which turns the
whatever wild construct you have into either 0 or 1, depending on what
it evaluates to.

But I don't know what the standard says so you'll have to check :-)

Thanks.

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v5 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON
Date: Tue, 20 Nov 2012 19:10:49 +0000
Message-ID: <50ABD5B9.6020701 () att ! net>
--------------------
On 11/17/2012 08:38 AM, Borislav Petkov wrote:
> On Thu, Nov 15, 2012 at 01:11:15PM -0600, Daniel Santos wrote:
>> Ah yes. I did notice that at one point, but I think it slipped
>> my mind. Also, the kernel has introduced me to the usage of the
>> !! construct, of which I'm well versed in its affects in various
>> situations and how gcc's optimizer ends up treating its usage, so
>> probably another reason I didn't change it immediately. But it's
>> basically shorthand for the expression (condition ? 1 : 0), correct?

Oh, this is embarrassing, The sentence above should have read:

... the kernel has introduced me to the usage of the !! construct, of which I'm *not* well versed in ...

hah! oh well


> I don't think so: "!!" is simply a double negation which turns the
> whatever wild construct you have into either 0 or 1, depending on what
> it evaluates to.
>
> But I don't know what the standard says so you'll have to check :-)

Here we go, from section Â§6.5.3.3:

The result of the logical negation operator ! is 0 if the value of its
operand compares unequal to 0, 1 if the value of its operand compares
equal to 0. The result has type int. The expression !E is equivalent to
(0==E).

I simply wasn't aware that it promised a "true" value to be one
exactly.  Hurray for expanding horizons! :)

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON} ===

From: danielfsantos () att ! net
To: linux-kernel
Subject: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Tue, 13 Nov 2012 22:13:40 +0000
Message-ID: <1352844821-18952-8-git-send-email-daniel.santos () pobox ! com>
--------------------
Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
creating compile-time errors required a little trickery.
BUILD_BUG{,_ON} uses this attribute when available to generate
compile-time errors, but also uses the negative-sized array trick for
older compilers, resulting in two error messages in some cases.  The
reason it's "some" cases is that as of gcc 4.4, the negative-sized array
will not create an error in some situations, like inline functions.

This patch replaces the negative-sized array code with the new
__compiletime_error_fallback() macro which expands to the same thing
unless the the error attribute is available, in which case it expands to
do{}while(0), resulting in exactly one compile-time error on all
versions of gcc.

Note that we are not changing the negative-sized array code for the
unoptimized version of BUILD_BUG_ON, since it has the potential to catch
problems that would be disabled in later versions of gcc were
__compiletime_error_fallback used.  The reason is that that an
unoptimized build can't always remove calls to an error-attributed
function call (like we are using) that should effectively become dead
code if it were optimized.  However, using a negative-sized array with a
similar value will not result in an false-positive (error). The only
caveat being that it will also fail to catch valid conditions, which we
should be expecting in an unoptimized build anyway.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h      |    2 +-
 include/linux/compiler.h |    5 +++++
 2 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index dd4f506..125e744 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -66,7 +66,7 @@ struct pt_regs;
 			__compiletime_error("BUILD_BUG_ON failed");	\
 		if (__cond)						\
 			__build_bug_on_failed();			\
-		((void)sizeof(char[1 - 2*!!(__cond)]));			\
+		__compiletime_error_fallback(__cond);			\
 	} while(0)
 #endif
 
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index cbf6d9d..8e5b9d5 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -298,7 +298,12 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 #endif
 #ifndef __compiletime_error
 # define __compiletime_error(message)
+# define __compiletime_error_fallback(condition) \
+	do { ((void)sizeof(char[1 - 2*!!(condition)])); } while (0)
+#else
+# define __compiletime_error_fallback(condition) do { } while (0)
 #endif
+
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Tue, 13 Nov 2012 22:13:40 +0000
Message-ID: <1352844821-18952-8-git-send-email-daniel.santos () pobox ! com>
--------------------
Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
creating compile-time errors required a little trickery.
BUILD_BUG{,_ON} uses this attribute when available to generate
compile-time errors, but also uses the negative-sized array trick for
older compilers, resulting in two error messages in some cases.  The
reason it's "some" cases is that as of gcc 4.4, the negative-sized array
will not create an error in some situations, like inline functions.

This patch replaces the negative-sized array code with the new
__compiletime_error_fallback() macro which expands to the same thing
unless the the error attribute is available, in which case it expands to
do{}while(0), resulting in exactly one compile-time error on all
versions of gcc.

Note that we are not changing the negative-sized array code for the
unoptimized version of BUILD_BUG_ON, since it has the potential to catch
problems that would be disabled in later versions of gcc were
__compiletime_error_fallback used.  The reason is that that an
unoptimized build can't always remove calls to an error-attributed
function call (like we are using) that should effectively become dead
code if it were optimized.  However, using a negative-sized array with a
similar value will not result in an false-positive (error). The only
caveat being that it will also fail to catch valid conditions, which we
should be expecting in an unoptimized build anyway.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h      |    2 +-
 include/linux/compiler.h |    5 +++++
 2 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index dd4f506..125e744 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -66,7 +66,7 @@ struct pt_regs;
 			__compiletime_error("BUILD_BUG_ON failed");	\
 		if (__cond)						\
 			__build_bug_on_failed();			\
-		((void)sizeof(char[1 - 2*!!(__cond)]));			\
+		__compiletime_error_fallback(__cond);			\
 	} while(0)
 #endif
 
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index cbf6d9d..8e5b9d5 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -298,7 +298,12 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 #endif
 #ifndef __compiletime_error
 # define __compiletime_error(message)
+# define __compiletime_error_fallback(condition) \
+	do { ((void)sizeof(char[1 - 2*!!(condition)])); } while (0)
+#else
+# define __compiletime_error_fallback(condition) do { } while (0)
 #endif
+
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Thu, 15 Nov 2012 15:08:04 +0000
Message-ID: <20121115150804.GF4956 () x1 ! osrc ! amd ! com>
--------------------
On Tue, Nov 13, 2012 at 04:13:40PM -0600, danielfsantos@att.net wrote:
> Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
> creating compile-time errors required a little trickery.
> BUILD_BUG{,_ON} uses this attribute when available to generate
> compile-time errors, but also uses the negative-sized array trick for
> older compilers, resulting in two error messages in some cases.  The
> reason it's "some" cases is that as of gcc 4.4, the negative-sized array
> will not create an error in some situations, like inline functions.
> 
> This patch replaces the negative-sized array code with the new
> __compiletime_error_fallback() macro which expands to the same thing
> unless the the error attribute is available, in which case it expands to
> do{}while(0), resulting in exactly one compile-time error on all
> versions of gcc.
> 
> Note that we are not changing the negative-sized array code for the
> unoptimized version of BUILD_BUG_ON, since it has the potential to catch
> problems that would be disabled in later versions of gcc were
> __compiletime_error_fallback used.  The reason is that that an
> unoptimized build can't always remove calls to an error-attributed
> function call (like we are using) that should effectively become dead
> code if it were optimized.  However, using a negative-sized array with a
> similar value will not result in an false-positive (error). The only
> caveat being that it will also fail to catch valid conditions, which we
> should be expecting in an unoptimized build anyway.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
> ---
>  include/linux/bug.h      |    2 +-
>  include/linux/compiler.h |    5 +++++
>  2 files changed, 6 insertions(+), 1 deletions(-)
> 
> diff --git a/include/linux/bug.h b/include/linux/bug.h
> index dd4f506..125e744 100644
> --- a/include/linux/bug.h
> +++ b/include/linux/bug.h
> @@ -66,7 +66,7 @@ struct pt_regs;
>  			__compiletime_error("BUILD_BUG_ON failed");	\
>  		if (__cond)						\
>  			__build_bug_on_failed();			\
> -		((void)sizeof(char[1 - 2*!!(__cond)]));			\
> +		__compiletime_error_fallback(__cond);			\

We're passing an already evaluated __cond here which gets doubly-negated
again in __compiletime_error_fallback. If __compiletime_error_fallback
is going to be called only from BUILD_BUG_ON, then its definition should
be:

	do { ((void)sizeof(char[1 - 2 * (condition)])); } while (0)

i.e., without the !!.


>  	} while(0)
>  #endif
>  
> diff --git a/include/linux/compiler.h b/include/linux/compiler.h
> index cbf6d9d..8e5b9d5 100644
> --- a/include/linux/compiler.h
> +++ b/include/linux/compiler.h
> @@ -298,7 +298,12 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
>  #endif
>  #ifndef __compiletime_error
>  # define __compiletime_error(message)
> +# define __compiletime_error_fallback(condition) \
> +	do { ((void)sizeof(char[1 - 2*!!(condition)])); } while (0)
> +#else
> +# define __compiletime_error_fallback(condition) do { } while (0)
>  #endif
> +
>  /*
>   * Prevent the compiler from merging or refetching accesses.  The compiler
>   * is also forbidden from reordering successive instances of ACCESS_ONCE(),
> -- 
> 1.7.3.4

Thanks.

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Thu, 15 Nov 2012 19:44:45 +0000
Message-ID: <50A5462D.4060809 () att ! net>
--------------------


On 11/15/2012 09:08 AM, Borislav Petkov wrote:
> On Tue, Nov 13, 2012 at 04:13:40PM -0600, danielfsantos@att.net wrote:
>> Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
>> creating compile-time errors required a little trickery.
>> BUILD_BUG{,_ON} uses this attribute when available to generate
>> compile-time errors, but also uses the negative-sized array trick for
>> older compilers, resulting in two error messages in some cases.  The
>> reason it's "some" cases is that as of gcc 4.4, the negative-sized array
>> will not create an error in some situations, like inline functions.
>>
>> This patch replaces the negative-sized array code with the new
>> __compiletime_error_fallback() macro which expands to the same thing
>> unless the the error attribute is available, in which case it expands to
>> do{}while(0), resulting in exactly one compile-time error on all
>> versions of gcc.
>>
>> Note that we are not changing the negative-sized array code for the
>> unoptimized version of BUILD_BUG_ON, since it has the potential to catch
>> problems that would be disabled in later versions of gcc were
>> __compiletime_error_fallback used.  The reason is that that an
>> unoptimized build can't always remove calls to an error-attributed
>> function call (like we are using) that should effectively become dead
>> code if it were optimized.  However, using a negative-sized array with a
>> similar value will not result in an false-positive (error). The only
>> caveat being that it will also fail to catch valid conditions, which we
>> should be expecting in an unoptimized build anyway.
>>
>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>> ---
>>  include/linux/bug.h      |    2 +-
>>  include/linux/compiler.h |    5 +++++
>>  2 files changed, 6 insertions(+), 1 deletions(-)
>>
>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>> index dd4f506..125e744 100644
>> --- a/include/linux/bug.h
>> +++ b/include/linux/bug.h
>> @@ -66,7 +66,7 @@ struct pt_regs;
>>  			__compiletime_error("BUILD_BUG_ON failed");	\
>>  		if (__cond)						\
>>  			__build_bug_on_failed();			\
>> -		((void)sizeof(char[1 - 2*!!(__cond)]));			\
>> +		__compiletime_error_fallback(__cond);			\
> We're passing an already evaluated __cond here which gets doubly-negated
> again in __compiletime_error_fallback. If __compiletime_error_fallback
> is going to be called only from BUILD_BUG_ON, then its definition should
> be:
>
> 	do { ((void)sizeof(char[1 - 2 * (condition)])); } while (0)
>
> i.e., without the !!.
Yeah, I agree. Also, with the complexity, I think a few more comments
can be helpful in compiler.h to clarify what these macros are for more
specifically.

On another note, I have a "part two" set of patches for bug.h &
compiler*.h that does some other stuff (more cleanup & restructuring)
and this is making me think about that more.  My thought about
__compiletime_error_fallback is that it should be called only from
within compiler.h (as in the following patch) and basically just be a
private macro.  However, we still use the use the negative sized array
trick for the unoptimized version of BUILD_BUG_ON (which may have
limited meaning), and we also use a negative bit specifier on a bitfield
in BUILD_BUG_ON_ZERO and BUILD_BUG_ON_NULL (which I treat some in my
other patches as well).  But my thought is that it may be helpful to
encapsulate these tricks into (public) macros in compiler*.h, such as
"compiletime_assert_negarray" and "compiletime_assert_negbitfiled" and
then have __compiletime_error_fallback expand to
compiletime_assert_negarray when it's needed and no-op when it's not.

This doesn't have to be decided now, but it's just a thought you gave me.

And in case you're wondering about the negative bit field,
BUILD_BUG_ON_{ZERO,NULL} can't call BUILD_BUG_ON in a complex expression
({ exp; exp; }) because it is evaluated outside of a function body and
gcc doesn't like that.  Thus, the following macro would, sadly, result
in errors:

#define BUILD_BUG_ON_ZERO(exp) ({BUILD_BUG_ON(exp); 0;})

However, it would not be an error to call an __alwaysinline function
that uses BUILD_BUG_ON, so I still have to explore that and make sure it
works in all scenarios (and compilers).

But back to *this* patch, I'll make that change now.

Thanks!
Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Thu, 15 Nov 2012 19:44:45 +0000
Message-ID: <50A5462D.4060809 () att ! net>
--------------------


On 11/15/2012 09:08 AM, Borislav Petkov wrote:
> On Tue, Nov 13, 2012 at 04:13:40PM -0600, danielfsantos@att.net wrote:
>> Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
>> creating compile-time errors required a little trickery.
>> BUILD_BUG{,_ON} uses this attribute when available to generate
>> compile-time errors, but also uses the negative-sized array trick for
>> older compilers, resulting in two error messages in some cases.  The
>> reason it's "some" cases is that as of gcc 4.4, the negative-sized array
>> will not create an error in some situations, like inline functions.
>>
>> This patch replaces the negative-sized array code with the new
>> __compiletime_error_fallback() macro which expands to the same thing
>> unless the the error attribute is available, in which case it expands to
>> do{}while(0), resulting in exactly one compile-time error on all
>> versions of gcc.
>>
>> Note that we are not changing the negative-sized array code for the
>> unoptimized version of BUILD_BUG_ON, since it has the potential to catch
>> problems that would be disabled in later versions of gcc were
>> __compiletime_error_fallback used.  The reason is that that an
>> unoptimized build can't always remove calls to an error-attributed
>> function call (like we are using) that should effectively become dead
>> code if it were optimized.  However, using a negative-sized array with a
>> similar value will not result in an false-positive (error). The only
>> caveat being that it will also fail to catch valid conditions, which we
>> should be expecting in an unoptimized build anyway.
>>
>> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
>> ---
>>  include/linux/bug.h      |    2 +-
>>  include/linux/compiler.h |    5 +++++
>>  2 files changed, 6 insertions(+), 1 deletions(-)
>>
>> diff --git a/include/linux/bug.h b/include/linux/bug.h
>> index dd4f506..125e744 100644
>> --- a/include/linux/bug.h
>> +++ b/include/linux/bug.h
>> @@ -66,7 +66,7 @@ struct pt_regs;
>>  			__compiletime_error("BUILD_BUG_ON failed");	\
>>  		if (__cond)						\
>>  			__build_bug_on_failed();			\
>> -		((void)sizeof(char[1 - 2*!!(__cond)]));			\
>> +		__compiletime_error_fallback(__cond);			\
> We're passing an already evaluated __cond here which gets doubly-negated
> again in __compiletime_error_fallback. If __compiletime_error_fallback
> is going to be called only from BUILD_BUG_ON, then its definition should
> be:
>
> 	do { ((void)sizeof(char[1 - 2 * (condition)])); } while (0)
>
> i.e., without the !!.
Yeah, I agree. Also, with the complexity, I think a few more comments
can be helpful in compiler.h to clarify what these macros are for more
specifically.

On another note, I have a "part two" set of patches for bug.h &
compiler*.h that does some other stuff (more cleanup & restructuring)
and this is making me think about that more.  My thought about
__compiletime_error_fallback is that it should be called only from
within compiler.h (as in the following patch) and basically just be a
private macro.  However, we still use the use the negative sized array
trick for the unoptimized version of BUILD_BUG_ON (which may have
limited meaning), and we also use a negative bit specifier on a bitfield
in BUILD_BUG_ON_ZERO and BUILD_BUG_ON_NULL (which I treat some in my
other patches as well).  But my thought is that it may be helpful to
encapsulate these tricks into (public) macros in compiler*.h, such as
"compiletime_assert_negarray" and "compiletime_assert_negbitfiled" and
then have __compiletime_error_fallback expand to
compiletime_assert_negarray when it's needed and no-op when it's not.

This doesn't have to be decided now, but it's just a thought you gave me.

And in case you're wondering about the negative bit field,
BUILD_BUG_ON_{ZERO,NULL} can't call BUILD_BUG_ON in a complex expression
({ exp; exp; }) because it is evaluated outside of a function body and
gcc doesn't like that.  Thus, the following macro would, sadly, result
in errors:

#define BUILD_BUG_ON_ZERO(exp) ({BUILD_BUG_ON(exp); 0;})

However, it would not be an error to call an __alwaysinline function
that uses BUILD_BUG_ON, so I still have to explore that and make sure it
works in all scenarios (and compilers).

But back to *this* patch, I'll make that change now.

Thanks!
Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Sat, 17 Nov 2012 14:39:18 +0000
Message-ID: <20121117143918.GC16441 () x1 ! osrc ! amd ! com>
--------------------
On Thu, Nov 15, 2012 at 01:44:45PM -0600, Daniel Santos wrote:
> Yeah, I agree. Also, with the complexity, I think a few more comments
> can be helpful in compiler.h to clarify what these macros are for more
> specifically.


================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v5 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Sat, 17 Nov 2012 14:39:18 +0000
Message-ID: <20121117143918.GC16441 () x1 ! osrc ! amd ! com>
--------------------
On Thu, Nov 15, 2012 at 01:44:45PM -0600, Daniel Santos wrote:
> Yeah, I agree. Also, with the complexity, I think a few more comments
> can be helpful in compiler.h to clarify what these macros are for more
> specifically.


================================================================================


################################################################################

=== Thread: [PATCH v5 9/9] bug.h, compiler.h: Introduce compiletime_assert & BUILD_BUG_ON_MSG ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v5 9/9] bug.h, compiler.h: Introduce compiletime_assert & BUILD_BUG_ON_MSG
Date: Tue, 13 Nov 2012 22:13:41 +0000
Message-ID: <1352844821-18952-9-git-send-email-daniel.santos () pobox ! com>
--------------------
Introduce compiletime_assert to compiler.h, which moves the details of
how to break a build and emit an error message for a specific compiler
to the headers where these details should be. Following the tradition of
the POSIX assert macro, compiletime_assert creates a build-time error
when the supplied condition is *false*.

Next, we add BUILD_BUG_ON_MSG to bug.h which simply wraps
compiletime_assert, inverting the logic, so that it fails when the
condition is *true*, consistient with the language "build bug on." This
macro allows you to specify the error message you want emitted when the
supplied condition is true.

Finally, we remove all other code from bug.h that mucks with these
details (BUILD_BUG & BUILD_BUG_ON), and have them all call
BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but also
prevents the possibility of code being changed for one macro and not for
the other (which was previously the case for BUILD_BUG and
BUILD_BUG_ON).

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h      |   28 +++++++++++++---------------
 include/linux/compiler.h |   24 ++++++++++++++++++++++++
 2 files changed, 37 insertions(+), 15 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 125e744..31a1310 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -16,6 +16,7 @@ struct pt_regs;
 #define BUILD_BUG_ON_NOT_POWER_OF_2(n) (0)
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
+#define BUILD_BUG_ON_MSG(cond, msg) (0)
 #define BUILD_BUG_ON(condition) (0)
 #define BUILD_BUG() (0)
 #else /* __CHECKER__ */
@@ -39,6 +40,15 @@ struct pt_regs;
 #define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))
 
 /**
+ * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied
+ * 		      error message.
+ * @condition: the condition which the compiler should know is false.
+ *
+ * See BUILD_BUG_ON for description.
+ */
+#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)
+
+/**
  * BUILD_BUG_ON - break compile if a condition is true.
  * @condition: the condition which the compiler should know is false.
  *
@@ -59,15 +69,8 @@ struct pt_regs;
 #ifndef __OPTIMIZE__
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 #else
-#define BUILD_BUG_ON(condition)						\
-	do {								\
-		bool __cond = !!(condition);				\
-		extern void __build_bug_on_failed(void)			\
-			__compiletime_error("BUILD_BUG_ON failed");	\
-		if (__cond)						\
-			__build_bug_on_failed();			\
-		__compiletime_error_fallback(__cond);			\
-	} while(0)
+#define BUILD_BUG_ON(condition) \
+	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)
 #endif
 
 /**
@@ -77,12 +80,7 @@ struct pt_regs;
  * build time, you should use BUILD_BUG to detect if it is
  * unexpectedly used.
  */
-#define BUILD_BUG()						\
-	do {							\
-		extern void __build_bug_failed(void)		\
-			__compiletime_error("BUILD_BUG failed");\
-		__build_bug_failed();				\
-	} while (0)
+#define BUILD_BUG() BUILD_BUG_ON_MSG(1, "BUILD_BUG failed")
 
 #endif	/* __CHECKER__ */
 
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 8e5b9d5..57878f3 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -304,6 +304,30 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 # define __compiletime_error_fallback(condition) do { } while (0)
 #endif
 
+#define __compiletime_assert(condition, msg, __func)			\
+	do {								\
+		bool __cond = !(condition);				\
+		extern void __func(void) __compiletime_error(msg);	\
+		if (__cond)						\
+			__func();					\
+		__compiletime_error_fallback(__cond);			\
+	} while (0)
+
+#define _compiletime_assert(condition, msg, __func) \
+	__compiletime_assert(condition, msg, __func)
+
+/**
+ * compiletime_assert - break build and emit msg if condition is false
+ * @condition: a compile-time constant condition to check
+ * @msg:       a message to emit if condition is false
+ *
+ * In tradition of POSIX assert, this macro will break the build if the
+ * supplied condition is *false*, emitting the supplied error message if the
+ * compiler has support to do so.
+ */
+#define compiletime_assert(condition, msg) \
+	_compiletime_assert(condition, msg, __compiletime_assert_ ## __LINE__)
+
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-kernel
Subject: Re: [PATCH v5 9/9] bug.h, compiler.h: Introduce compiletime_assert & BUILD_BUG_ON_MSG
Date: Thu, 15 Nov 2012 15:08:23 +0000
Message-ID: <20121115150823.GG4956 () x1 ! osrc ! amd ! com>
--------------------
On Tue, Nov 13, 2012 at 04:13:41PM -0600, danielfsantos@att.net wrote:
> Introduce compiletime_assert to compiler.h, which moves the details of
> how to break a build and emit an error message for a specific compiler
> to the headers where these details should be. Following the tradition of
> the POSIX assert macro, compiletime_assert creates a build-time error
> when the supplied condition is *false*.
> 
> Next, we add BUILD_BUG_ON_MSG to bug.h which simply wraps
> compiletime_assert, inverting the logic, so that it fails when the
> condition is *true*, consistient with the language "build bug on." This
> macro allows you to specify the error message you want emitted when the
> supplied condition is true.
> 
> Finally, we remove all other code from bug.h that mucks with these
> details (BUILD_BUG & BUILD_BUG_ON), and have them all call
> BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but also
> prevents the possibility of code being changed for one macro and not for
> the other (which was previously the case for BUILD_BUG and
> BUILD_BUG_ON).
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>

Looks nice and clean.

Acked-by: Borislav Petkov <bp@alien8.de>

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v5 9/9] bug.h, compiler.h: Introduce compiletime_assert & BUILD_BUG_ON_MSG
Date: Thu, 15 Nov 2012 15:08:23 +0000
Message-ID: <20121115150823.GG4956 () x1 ! osrc ! amd ! com>
--------------------
On Tue, Nov 13, 2012 at 04:13:41PM -0600, danielfsantos@att.net wrote:
> Introduce compiletime_assert to compiler.h, which moves the details of
> how to break a build and emit an error message for a specific compiler
> to the headers where these details should be. Following the tradition of
> the POSIX assert macro, compiletime_assert creates a build-time error
> when the supplied condition is *false*.
> 
> Next, we add BUILD_BUG_ON_MSG to bug.h which simply wraps
> compiletime_assert, inverting the logic, so that it fails when the
> condition is *true*, consistient with the language "build bug on." This
> macro allows you to specify the error message you want emitted when the
> supplied condition is true.
> 
> Finally, we remove all other code from bug.h that mucks with these
> details (BUILD_BUG & BUILD_BUG_ON), and have them all call
> BUILD_BUG_ON_MSG.  This not only reduces source code bloat, but also
> prevents the possibility of code being changed for one macro and not for
> the other (which was previously the case for BUILD_BUG and
> BUILD_BUG_ON).
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>

Looks nice and clean.

Acked-by: Borislav Petkov <bp@alien8.de>

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-kernel
Subject: Re: [PATCH v5 9/9] bug.h, compiler.h: Introduce compiletime_assert & BUILD_BUG_ON_MSG
Date: Fri, 16 Nov 2012 23:25:09 +0000
Message-ID: <50A6CB55.7070706 () att ! net>
--------------------
On 11/13/2012 04:13 PM, danielfsantos@att.net wrote:
> +#define __compiletime_assert(condition, msg, __func)			\
> +	do {								\
> +		bool __cond = !(condition);				\
> +		extern void __func(void) __compiletime_error(msg);	\
> +		if (__cond)						\
> +			__func();					\
> +		__compiletime_error_fallback(__cond);			\
> +	} while (0)
> +
> +#define _compiletime_assert(condition, msg, __func) \
> +	__compiletime_assert(condition, msg, __func)
> +
> +/**
> + * compiletime_assert - break build and emit msg if condition is false
> + * @condition: a compile-time constant condition to check
> + * @msg:       a message to emit if condition is false
> + *
> + * In tradition of POSIX assert, this macro will break the build if the
> + * supplied condition is *false*, emitting the supplied error message if the
> + * compiler has support to do so.
> + */
> +#define compiletime_assert(condition, msg) \
> +	_compiletime_assert(condition, msg, __compiletime_assert_ ## __LINE__)
> +

Whoops, this implementation pastes the tokens before allowing them to
expand, it should be something like this:

#define __compiletime_assert(condition, msg, __func) .... stuff
#define _compiletime_assert(condition, msg, prefix, suffix) \
        __compiletime_assert(condition, msg, prefix ## suffix)
#define compiletime_assert(condition, msg) \
        _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

I'll fix that as well.

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Daniel Santos <danielfsantos () att ! net>
To: linux-sparse
Subject: Re: [PATCH v5 9/9] bug.h, compiler.h: Introduce compiletime_assert & BUILD_BUG_ON_MSG
Date: Fri, 16 Nov 2012 23:25:09 +0000
Message-ID: <50A6CB55.7070706 () att ! net>
--------------------
On 11/13/2012 04:13 PM, danielfsantos@att.net wrote:
> +#define __compiletime_assert(condition, msg, __func)			\
> +	do {								\
> +		bool __cond = !(condition);				\
> +		extern void __func(void) __compiletime_error(msg);	\
> +		if (__cond)						\
> +			__func();					\
> +		__compiletime_error_fallback(__cond);			\
> +	} while (0)
> +
> +#define _compiletime_assert(condition, msg, __func) \
> +	__compiletime_assert(condition, msg, __func)
> +
> +/**
> + * compiletime_assert - break build and emit msg if condition is false
> + * @condition: a compile-time constant condition to check
> + * @msg:       a message to emit if condition is false
> + *
> + * In tradition of POSIX assert, this macro will break the build if the
> + * supplied condition is *false*, emitting the supplied error message if the
> + * compiler has support to do so.
> + */
> +#define compiletime_assert(condition, msg) \
> +	_compiletime_assert(condition, msg, __compiletime_assert_ ## __LINE__)
> +

Whoops, this implementation pastes the tokens before allowing them to
expand, it should be something like this:

#define __compiletime_assert(condition, msg, __func) .... stuff
#define _compiletime_assert(condition, msg, prefix, suffix) \
        __compiletime_assert(condition, msg, prefix ## suffix)
#define compiletime_assert(condition, msg) \
        _compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)

I'll fix that as well.

Daniel
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 0/9] Cleanup & new features for compiler*.h and bug.h ===

From: danielfsantos () att ! net
To: linux-kernel
Subject: [PATCH v6 0/9] Cleanup & new features for compiler*.h and bug.h
Date: Tue, 20 Nov 2012 20:42:03 +0000
Message-ID: <1353444132-6809-1-git-send-email-daniel.santos () pobox ! com>
--------------------

 include/linux/bug.h           |   47 ++++++++++++++++++++++------------------
 include/linux/compiler-gcc.h  |    3 ++
 include/linux/compiler-gcc3.h |    8 +++---
 include/linux/compiler-gcc4.h |   28 ++++++++++++------------
 include/linux/compiler.h      |   32 +++++++++++++++++++++++++--
 5 files changed, 76 insertions(+), 42 deletions(-)

Changes in v6:
o Remove extraneous double negation
o Fixed faulty macro expansion in last patch

Changes in v5:
o Move BUILD_BUG* guts to a new compiletime_assert() macro in compiler.h.
o Fix a double-evaluation problem.
o Fix another bad macro definition when __CHECKER__ defined.

Changes in v4:
o Squash a minor commit (per Borislav Petkov)
o Change some comment text (per Borislav Petkov)
o Add some acks

This patch set is a dependency of the generic red-black tree patch set, which
I have now split up into three smaller sets and is based off of linux-next.

The major aim of this patch set is to cleanup compiler-gcc*.h and improve
the manageability of of compiler features at various versions (when they
are broken, etc.), add some needed features to bug.h and clean that up as
well.

compiler-gcc*.h
o Introduce GCC_VERSION - (e.g., gcc 4.7.1 becomes 40701).
o Reorder all features based upon the version introduced (readability).
o Change all version checks to use GCC_VERSION.
o Remove redundant __linktime_error macro.
o Introduce compiletime_assert() macro.

bug.h
o Improve BUILD_BUG_ON(expr) - now generates compile-time error post-gcc-4.4
o Remove duplicate error messages in some cases.
o Fix double-evaluation problem in BUILD_BUG_ON.
o Fix bad macro definitions when using __CHECKER__.
o Introduce BUILD_BUG_ON_MSG and clean up the implementations of the
  BUILD_BUG* macros.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v6 0/9] Cleanup & new features for compiler*.h and bug.h
Date: Tue, 20 Nov 2012 20:42:03 +0000
Message-ID: <1353444132-6809-1-git-send-email-daniel.santos () pobox ! com>
--------------------

 include/linux/bug.h           |   47 ++++++++++++++++++++++------------------
 include/linux/compiler-gcc.h  |    3 ++
 include/linux/compiler-gcc3.h |    8 +++---
 include/linux/compiler-gcc4.h |   28 ++++++++++++------------
 include/linux/compiler.h      |   32 +++++++++++++++++++++++++--
 5 files changed, 76 insertions(+), 42 deletions(-)

Changes in v6:
o Remove extraneous double negation
o Fixed faulty macro expansion in last patch

Changes in v5:
o Move BUILD_BUG* guts to a new compiletime_assert() macro in compiler.h.
o Fix a double-evaluation problem.
o Fix another bad macro definition when __CHECKER__ defined.

Changes in v4:
o Squash a minor commit (per Borislav Petkov)
o Change some comment text (per Borislav Petkov)
o Add some acks

This patch set is a dependency of the generic red-black tree patch set, which
I have now split up into three smaller sets and is based off of linux-next.

The major aim of this patch set is to cleanup compiler-gcc*.h and improve
the manageability of of compiler features at various versions (when they
are broken, etc.), add some needed features to bug.h and clean that up as
well.

compiler-gcc*.h
o Introduce GCC_VERSION - (e.g., gcc 4.7.1 becomes 40701).
o Reorder all features based upon the version introduced (readability).
o Change all version checks to use GCC_VERSION.
o Remove redundant __linktime_error macro.
o Introduce compiletime_assert() macro.

bug.h
o Improve BUILD_BUG_ON(expr) - now generates compile-time error post-gcc-4.4
o Remove duplicate error messages in some cases.
o Fix double-evaluation problem in BUILD_BUG_ON.
o Fix bad macro definitions when using __CHECKER__.
o Introduce BUILD_BUG_ON_MSG and clean up the implementations of the
  BUILD_BUG* macros.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Michel Lespinasse <walken () google ! com>
To: linux-kernel
Subject: Re: [PATCH v6 0/9] Cleanup & new features for compiler*.h and bug.h
Date: Wed, 21 Nov 2012 02:35:26 +0000
Message-ID: <CANN689EqSVGexh7PbrmBNofEPBQn9BZQ3s3ApvX7cBHso1jOXQ () mail ! gmail ! com>
--------------------
On Tue, Nov 20, 2012 at 12:42 PM,  <danielfsantos@att.net> wrote:
>
>  include/linux/bug.h           |   47 ++++++++++++++++++++++------------------
>  include/linux/compiler-gcc.h  |    3 ++
>  include/linux/compiler-gcc3.h |    8 +++---
>  include/linux/compiler-gcc4.h |   28 ++++++++++++------------
>  include/linux/compiler.h      |   32 +++++++++++++++++++++++++--
>  5 files changed, 76 insertions(+), 42 deletions(-)
>
> Changes in v6:
> o Remove extraneous double negation
> o Fixed faulty macro expansion in last patch

Acked-by: Michel Lespinasse <walken@google.com> on the entire v6 series.

-- 
Michel "Walken" Lespinasse
A program is never fully debugged until the last user dies.
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Michel Lespinasse <walken () google ! com>
To: linux-sparse
Subject: Re: [PATCH v6 0/9] Cleanup & new features for compiler*.h and bug.h
Date: Wed, 21 Nov 2012 02:35:26 +0000
Message-ID: <CANN689EqSVGexh7PbrmBNofEPBQn9BZQ3s3ApvX7cBHso1jOXQ () mail ! gmail ! com>
--------------------
On Tue, Nov 20, 2012 at 12:42 PM,  <danielfsantos@att.net> wrote:
>
>  include/linux/bug.h           |   47 ++++++++++++++++++++++------------------
>  include/linux/compiler-gcc.h  |    3 ++
>  include/linux/compiler-gcc3.h |    8 +++---
>  include/linux/compiler-gcc4.h |   28 ++++++++++++------------
>  include/linux/compiler.h      |   32 +++++++++++++++++++++++++--
>  5 files changed, 76 insertions(+), 42 deletions(-)
>
> Changes in v6:
> o Remove extraneous double negation
> o Fixed faulty macro expansion in last patch

Acked-by: Michel Lespinasse <walken@google.com> on the entire v6 series.

-- 
Michel "Walken" Lespinasse
A program is never fully debugged until the last user dies.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v6 0/9] Cleanup & new features for compiler*.h and bug.h
Date: Thu, 22 Nov 2012 13:44:10 +0000
Message-ID: <20121122134410.GE17147 () x1 ! alien8 ! de>
--------------------
On Tue, Nov 20, 2012 at 02:42:03PM -0600, danielfsantos@att.net wrote:
> 
>  include/linux/bug.h           |   47 ++++++++++++++++++++++------------------
>  include/linux/compiler-gcc.h  |    3 ++
>  include/linux/compiler-gcc3.h |    8 +++---
>  include/linux/compiler-gcc4.h |   28 ++++++++++++------------
>  include/linux/compiler.h      |   32 +++++++++++++++++++++++++--
>  5 files changed, 76 insertions(+), 42 deletions(-)

Ok,

this patchset is slowly but surely getting into a mergeable state and
could probably use wider testing in linux-next right about now.

Maybe akpm can pick it up into -mm so that it sees -next and then if all
is fine maybe find its way upstream in the next merge window, AFAICT.

Thanks.

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 2/9] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v6 2/9] compiler-gcc.h: Add gcc-recommended GCC_VERSION macro
Date: Tue, 20 Nov 2012 21:05:00 +0000
Message-ID: <1353445507-7233-2-git-send-email-daniel.santos () pobox ! com>
--------------------
Throughout compiler*.h, many version checks are made.  These can be
simplified by using the macro that gcc's documentation recommends.
However, my primary reason for adding this is that I need bug-check
macros that are enabled at certain gcc versions and it's cleaner to use
this macro than the tradition method:

if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ => 2)

If you add patch level, it gets this ugly:

if __GNUC__ > 4 || (__GNUC__ == 4 && (__GNUC_MINOR__ > 2 || \
   __GNUC_MINOR__ == 2 __GNUC_PATCHLEVEL__ >= 1))

As opposed to:

if GCC_VERSION >= 40201

While having separate headers for gcc 3 & 4 eliminates some of this
verbosity, they can still be cleaned up by this.

See also:
http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: Borislav Petkov <bp@alien8.de>
Acked-by: David Rientjes <rientjes@google.com>
---
 include/linux/compiler-gcc.h |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 6a6d7ae..24545cd 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -5,6 +5,9 @@
 /*
  * Common definitions for all gcc versions go here.
  */
+#define GCC_VERSION (__GNUC__ * 10000 \
+		   + __GNUC_MINOR__ * 100 \
+		   + __GNUC_PATCHLEVEL__)
 
 
 /* Optimization barrier */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 3/9] compiler-gcc{3,4}.h: Use GCC_VERSION macro ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v6 3/9] compiler-gcc{3,4}.h: Use GCC_VERSION macro
Date: Tue, 20 Nov 2012 21:05:01 +0000
Message-ID: <1353445507-7233-3-git-send-email-daniel.santos () pobox ! com>
--------------------
Using GCC_VERSION reduces complexity, is easier to read and is GCC's
recommended mechanism for doing version checks. (Just don't ask me why
they didn't define it in the first place.)  This also makes it easy to
merge compiler-gcc{,3,4}.h should somebody want to.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/compiler-gcc3.h |    8 ++++----
 include/linux/compiler-gcc4.h |   14 +++++++-------
 2 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/include/linux/compiler-gcc3.h b/include/linux/compiler-gcc3.h
index 37d4124..7d89feb 100644
--- a/include/linux/compiler-gcc3.h
+++ b/include/linux/compiler-gcc3.h
@@ -2,22 +2,22 @@
 #error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
 #endif
 
-#if __GNUC_MINOR__ < 2
+#if GCC_VERSION < 30200
 # error Sorry, your compiler is too old - please upgrade it.
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 30300
 # define __used			__attribute__((__used__))
 #else
 # define __used			__attribute__((__unused__))
 #endif
 
-#if __GNUC_MINOR__ >= 4
+#if GCC_VERSION >= 30400
 #define __must_check		__attribute__((warn_unused_result))
 #endif
 
 #ifdef CONFIG_GCOV_KERNEL
-# if __GNUC_MINOR__ < 4
+# if GCC_VERSION < 30400
 #   error "GCOV profiling support for gcc versions below 3.4 not included"
 # endif /* __GNUC_MINOR__ */
 #endif /* CONFIG_GCOV_KERNEL */
diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 8914293..9755029 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -4,7 +4,7 @@
 
 /* GCC 4.1.[01] miscompiles __weak */
 #ifdef __KERNEL__
-# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
+# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
 #  error Your version of gcc miscompiles the __weak directive
 # endif
 #endif
@@ -13,11 +13,11 @@
 #define __must_check 		__attribute__((warn_unused_result))
 #define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
 
-#if __GNUC_MINOR__ > 0
+#if GCC_VERSION >= 40100
 # define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
 #endif
 
-#if __GNUC_MINOR__ >= 3
+#if GCC_VERSION >= 40300
 /* Mark functions as cold. gcc will assume any path leading to a call
    to them will be unlikely.  This means a lot of manual unlikely()s
    are unnecessary now for any paths leading to the usual suspects
@@ -39,9 +39,9 @@
 # define __compiletime_warning(message) __attribute__((warning(message)))
 # define __compiletime_error(message) __attribute__((error(message)))
 #endif /* __CHECKER__ */
-#endif /* __GNUC_MINOR__ >= 3 */
+#endif /* GCC_VERSION >= 40300 */
 
-#if __GNUC_MINOR__ >= 5
+#if GCC_VERSION >= 40500
 /*
  * Mark a position in code as unreachable.  This can be used to
  * suppress control flow warnings after asm blocks that transfer
@@ -56,9 +56,9 @@
 /* Mark a function definition as prohibited from being cloned. */
 #define __noclone	__attribute__((__noclone__))
 
-#endif /* __GNUC_MINOR__ >= 5 */
+#endif /* GCC_VERSION >= 40500 */
 
-#if __GNUC_MINOR__ >= 6
+#if GCC_VERSION >= 40600
 /*
  * Tell the optimizer that something else uses this function or variable.
  */
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 4/9] compiler{,-gcc4}.h, bug.h: Remove duplicate macros ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v6 4/9] compiler{,-gcc4}.h, bug.h: Remove duplicate macros
Date: Tue, 20 Nov 2012 21:05:02 +0000
Message-ID: <1353445507-7233-4-git-send-email-daniel.santos () pobox ! com>
--------------------
__linktime_error() does the same thing as __compiletime_error() and is
only used in bug.h.  Since the macro defines a function attribute that
will cause a failure at compile-time (not link-time), it makes more
sense to keep __compiletime_error(), which is also neatly mated with
__compiletime_warning().

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: David Rientjes <rientjes@google.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/bug.h           |    2 +-
 include/linux/compiler-gcc4.h |    2 --
 include/linux/compiler.h      |    3 ---
 3 files changed, 1 insertions(+), 6 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index aaac4bb..298a916 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -73,7 +73,7 @@ extern int __build_bug_on_failed;
 #define BUILD_BUG()						\
 	do {							\
 		extern void __build_bug_failed(void)		\
-			__linktime_error("BUILD_BUG failed");	\
+			__compiletime_error("BUILD_BUG failed");\
 		__build_bug_failed();				\
 	} while (0)
 
diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h
index 9755029..7f143ac 100644
--- a/include/linux/compiler-gcc4.h
+++ b/include/linux/compiler-gcc4.h
@@ -33,8 +33,6 @@
    the kernel context */
 #define __cold			__attribute__((__cold__))
 
-#define __linktime_error(message) __attribute__((__error__(message)))
-
 #ifndef __CHECKER__
 # define __compiletime_warning(message) __attribute__((warning(message)))
 # define __compiletime_error(message) __attribute__((error(message)))
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index b121554..cbf6d9d 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -299,9 +299,6 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 #ifndef __compiletime_error
 # define __compiletime_error(message)
 #endif
-#ifndef __linktime_error
-# define __linktime_error(message)
-#endif
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 5/9] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__ ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v6 5/9] bug.h: Fix BUILD_BUG_ON macro in __CHECKER__
Date: Tue, 20 Nov 2012 21:05:03 +0000
Message-ID: <1353445507-7233-5-git-send-email-daniel.santos () pobox ! com>
--------------------
When __CHECKER__ is defined, we disable all of the BUILD_BUG.* macros.
However, both BUILD_BUG_ON_NOT_POWER_OF_2 and BUILD_BUG_ON was
evaluating to nothing in this case, and we want (0) since this is a
function-like macro that will be followed by a semicolon.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/bug.h |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 298a916..1b2465d 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -12,10 +12,10 @@ enum bug_trap_type {
 struct pt_regs;
 
 #ifdef __CHECKER__
-#define BUILD_BUG_ON_NOT_POWER_OF_2(n)
+#define BUILD_BUG_ON_NOT_POWER_OF_2(n) (0)
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
-#define BUILD_BUG_ON(condition)
+#define BUILD_BUG_ON(condition) (0)
 #define BUILD_BUG() (0)
 #else /* __CHECKER__ */
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON ===

From: Borislav Petkov <bp () alien8 ! de>
To: linux-sparse
Subject: Re: [PATCH v6 6/9] bug.h: Prevent double evaulation of in BUILD_BUG_ON
Date: Thu, 22 Nov 2012 13:42:50 +0000
Message-ID: <20121122134250.GC17147 () x1 ! alien8 ! de>
--------------------
On Tue, Nov 20, 2012 at 03:05:04PM -0600, danielfsantos@att.net wrote:
> When calling BUILD_BUG_ON in an optimized build using gcc 4.3 and later,
> the condition will be evaulated twice, possibily with side-effects.
> This patch eliminates that error.
> 
> Signed-off-by: Daniel Santos <daniel.santos@pobox.com>

Acked-by: Borislav Petkov <bp@alien8.de>

-- 
Regards/Gruss,
Boris.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 7/9] bug.h: Make BUILD_BUG_ON generate compile-time error ===

From: danielfsantos () att ! net
To: linux-sparse
Subject: [PATCH v6 7/9] bug.h: Make BUILD_BUG_ON generate compile-time error
Date: Tue, 20 Nov 2012 21:05:05 +0000
Message-ID: <1353445507-7233-7-git-send-email-daniel.santos () pobox ! com>
--------------------
Negative sized arrays wont create a compile-time error in some cases
starting with gcc 4.4 (e.g., inlined functions), but gcc 4.3 introduced
the error function attribute that will.  This patch modifies
BUILD_BUG_ON to behave like BUILD_BUG already does, using the error
function attribute so that you don't have to build the entire kernel to
discover that you have a problem, and then enjoy trying to track it down
from a link-time error.

Also, we are only including asm/bug.h and then expecting that
linux/compiler.h will eventually be included to define __linktime_error
(used in BUILD_BUG_ON). This patch includes it directly for clarity and
to avoid the possibility of changes in <arch>/*/include/asm/bug.h being
changed or not including linux/compiler.h for some reason.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
Acked-by: Borislav Petkov <bp@alien8.de>
---
 include/linux/bug.h |   32 +++++++++++++++++++-------------
 1 files changed, 19 insertions(+), 13 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index 98bdbb3d..eb6d715 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -2,6 +2,7 @@
 #define _LINUX_BUG_H
 
 #include <asm/bug.h>
+#include <linux/compiler.h>
 
 enum bug_trap_type {
 	BUG_TRAP_TYPE_NONE = 0,
@@ -42,25 +43,30 @@ struct pt_regs;
  * @condition: the condition which the compiler should know is false.
  *
  * If you have some code which relies on certain constants being equal, or
- * other compile-time-evaluated condition, you should use BUILD_BUG_ON to
+ * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to
  * detect if someone changes it.
  *
- * The implementation uses gcc's reluctance to create a negative array, but
- * gcc (as of 4.4) only emits that error for obvious cases (eg. not arguments
- * to inline functions).  So as a fallback we use the optimizer; if it can't
- * prove the condition is false, it will cause a link error on the undefined
- * "__build_bug_on_failed".  This error message can be harder to track down
- * though, hence the two different methods.
+ * The implementation uses gcc's reluctance to create a negative array, but gcc
+ * (as of 4.4) only emits that error for obvious cases (e.g. not arguments to
+ * inline functions).  Luckily, in 4.3 they added the "error" function
+ * attribute just for this type of case.  Thus, we use a negative sized array
+ * (should always create an error on gcc versions older than 4.4) and then call
+ * an undefined function with the error attribute (should always create an
+ * error on gcc 4.3 and later).  If for some reason, neither creates a
+ * compile-time error, we'll still have a link-time error, which is harder to
+ * track down.
  */
 #ifndef __OPTIMIZE__
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 #else
-extern int __build_bug_on_failed;
-#define BUILD_BUG_ON(condition)					\
-	do {							\
-		bool __cond = !!(condition);			\
-		((void)sizeof(char[1 - 2 * __cond]));		\
-		if (__cond) __build_bug_on_failed = 1;		\
+#define BUILD_BUG_ON(condition)						\
+	do {								\
+		bool __cond = !!(condition);				\
+		extern void __build_bug_on_failed(void)			\
+			__compiletime_error("BUILD_BUG_ON failed");	\
+		if (__cond)						\
+			__build_bug_on_failed();			\
+		((void)sizeof(char[1 - 2 * __cond]));			\
 	} while(0)
 #endif
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH v6 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON} ===

From: danielfsantos () att ! net
To: linux-kernel
Subject: [PATCH v6 8/9] compiler.h, bug.h: Prevent double error messages with BUILD_BUG{,_ON}
Date: Tue, 20 Nov 2012 21:05:06 +0000
Message-ID: <1353445507-7233-8-git-send-email-daniel.santos () pobox ! com>
--------------------
Prior to the introduction of __attribute__((error("msg"))) in gcc 4.3,
creating compile-time errors required a little trickery.
BUILD_BUG{,_ON} uses this attribute when available to generate
compile-time errors, but also uses the negative-sized array trick for
older compilers, resulting in two error messages in some cases.  The
reason it's "some" cases is that as of gcc 4.4, the negative-sized array
will not create an error in some situations, like inline functions.

This patch replaces the negative-sized array code with the new
__compiletime_error_fallback() macro which expands to the same thing
unless the the error attribute is available, in which case it expands to
do{}while(0), resulting in exactly one compile-time error on all
versions of gcc.

Note that we are not changing the negative-sized array code for the
unoptimized version of BUILD_BUG_ON, since it has the potential to catch
problems that would be disabled in later versions of gcc were
__compiletime_error_fallback used.  The reason is that that an
unoptimized build can't always remove calls to an error-attributed
function call (like we are using) that should effectively become dead
code if it were optimized.  However, using a negative-sized array with a
similar value will not result in an false-positive (error). The only
caveat being that it will also fail to catch valid conditions, which we
should be expecting in an unoptimized build anyway.

Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
---
 include/linux/bug.h      |    2 +-
 include/linux/compiler.h |    5 +++++
 2 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/include/linux/bug.h b/include/linux/bug.h
index eb6d715..125e744 100644
--- a/include/linux/bug.h
+++ b/include/linux/bug.h
@@ -66,7 +66,7 @@ struct pt_regs;
 			__compiletime_error("BUILD_BUG_ON failed");	\
 		if (__cond)						\
 			__build_bug_on_failed();			\
-		((void)sizeof(char[1 - 2 * __cond]));			\
+		__compiletime_error_fallback(__cond);			\
 	} while(0)
 #endif
 
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index cbf6d9d..8e5b9d5 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -298,7 +298,12 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
 #endif
 #ifndef __compiletime_error
 # define __compiletime_error(message)
+# define __compiletime_error_fallback(condition) \
+	do { ((void)sizeof(char[1 - 2*!!(condition)])); } while (0)
+#else
+# define __compiletime_error_fallback(condition) do { } while (0)
 #endif
+
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH] Add GCC's byteswap intrinsics ===

From: David Woodhouse <dwmw2 () infradead ! org>
To: linux-sparse
Subject: Re: [PATCH] Add GCC's byteswap intrinsics
Date: Thu, 13 Dec 2012 16:29:31 +0000
Message-ID: <1355416171.19560.47.camel () shinybook ! infradead ! org>
--------------------

--=-dRwFadJInn/QDBqCqXc6
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable

On Thu, 2012-12-13 at 08:11 -0800, Josh Triplett wrote:
>=20
> GCC defines these to use int16_t, int32_t, and int64_t, respectively.
> The first two of those should match up to "short" and "int" without any
> issue, but on 64-bit platforms, stdint.h defines int64_t as "long", not
> "long long".  That could lead to some type incompatibilities.

Are we allowed to use int64_t? Or must we pretend that it's still the
20th century and stdint.h might not be present?

--=20
dwmw2


--=-dRwFadJInn/QDBqCqXc6
Content-Type: application/x-pkcs7-signature; name="smime.p7s"
Content-Disposition: attachment; filename="smime.p7s"
Content-Transfer-Encoding: base64

MIAGCSqGSIb3DQEHAqCAMIACAQExCzAJBgUrDgMCGgUAMIAGCSqGSIb3DQEHAQAAoIIUbjCCBjQw
ggQcoAMCAQICAR4wDQYJKoZIhvcNAQEFBQAwfTELMAkGA1UEBhMCSUwxFjAUBgNVBAoTDVN0YXJ0
Q29tIEx0ZC4xKzApBgNVBAsTIlNlY3VyZSBEaWdpdGFsIENlcnRpZmljYXRlIFNpZ25pbmcxKTAn
BgNVBAMTIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA3MTAyNDIxMDE1NVoX
DTE3MTAyNDIxMDE1NVowgYwxCzAJBgNVBAYTAklMMRYwFAYDVQQKEw1TdGFydENvbSBMdGQuMSsw
KQYDVQQLEyJTZWN1cmUgRGlnaXRhbCBDZXJ0aWZpY2F0ZSBTaWduaW5nMTgwNgYDVQQDEy9TdGFy
dENvbSBDbGFzcyAxIFByaW1hcnkgSW50ZXJtZWRpYXRlIENsaWVudCBDQTCCASIwDQYJKoZIhvcN
AQEBBQADggEPADCCAQoCggEBAMcJg8zOLdgasSmkLhOrlr6KMoOMpohBllVHrdRvEg/q6r8jR+EK
75xCGhR8ToREoqe7zM9/UnC6TS2y9UKTpT1v7RSMzR0t6ndl0TWBuUr/UXBhPk+Kmy7bI4yW4urC
+y7P3/1/X7U8ocb8VpH/Clt+4iq7nirMcNh6qJR+xjOhV+VHzQMALuGYn5KZmc1NbJQYclsGkDxD
z2UbFqE2+6vIZoL+jb9x4Pa5gNf1TwSDkOkikZB1xtB4ZqtXThaABSONdfmv/Z1pua3FYxnCFmdr
/+N2JLKutIxMYqQOJebr/f/h5t95m4JgrM3Y/w7YX9d7YAL9jvN4SydHsU6n65cCAwEAAaOCAa0w
ggGpMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRTcu2SnODaywFc
fH6WNU7y1LhRgjAfBgNVHSMEGDAWgBROC+8apEBbpRdphzDKNGhD0EGu8jBmBggrBgEFBQcBAQRa
MFgwJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3NwLnN0YXJ0c3NsLmNvbS9jYTAtBggrBgEFBQcwAoYh
aHR0cDovL3d3dy5zdGFydHNzbC5jb20vc2ZzY2EuY3J0MFsGA1UdHwRUMFIwJ6AloCOGIWh0dHA6
Ly93d3cuc3RhcnRzc2wuY29tL3Nmc2NhLmNybDAnoCWgI4YhaHR0cDovL2NybC5zdGFydHNzbC5j
b20vc2ZzY2EuY3JsMIGABgNVHSAEeTB3MHUGCysGAQQBgbU3AQIBMGYwLgYIKwYBBQUHAgEWImh0
dHA6Ly93d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwNAYIKwYBBQUHAgEWKGh0dHA6Ly93d3cu
c3RhcnRzc2wuY29tL2ludGVybWVkaWF0ZS5wZGYwDQYJKoZIhvcNAQEFBQADggIBAAqDCH14qywG
XLhjjF6uHLkjd02hcdh9hrw+VUsv+q1eeQWB21jWj3kJ96AUlPCoEGZ/ynJNScWy6QMVQjbbMXlt
UfO4n4bGGdKo3awPWp61tjAFgraLJgDk+DsSvUD6EowjMTNx25GQgyYJ5RPIzKKR9tQW8gGK+2+R
HxkUCTbYFnL6kl8Ch507rUdPPipJ9CgJFws3kDS3gOS5WFMxcjO5DwKfKSETEPrHh7p5shuuNktv
sv6hxHTLhiMKX893gxdT3XLS9OKmCv87vkINQcNEcIIoFWbP9HORz9v3vQwR4e3ksLc2JZOAFK+s
sS5XMEoznzpihEP0PLc4dCBYjbvSD7kxgDwZ+Aj8Q9PkbvE9sIPP7ON0fz095HdThKjiVJe6vofq
+n6b1NBc8XdrQvBmunwxD5nvtTW4vtN6VY7mUCmxsCieuoBJ9OlqmsVWQvifIYf40dJPZkk9YgGT
zWLpXDSfLSplbY2LL9C9U0ptvjcDjefLTvqSFc7tw1sEhF0n/qpA2r0GpvkLRDmcSwVyPvmjFBGq
Up/pNy8ZuPGQmHwFi2/14+xeSUDG2bwnsYJQG2EdJCB6luQ57GEnTA/yKZSTKI8dDQa8Sd3zfXb1
9mOgSF0bBdXbuKhEpuP9wirslFe6fQ1t5j5R0xi72MZ8ikMu1RQZKCyDbMwazlHiMIIHFzCCBf+g
AwIBAgIDBCZ6MA0GCSqGSIb3DQEBBQUAMIGMMQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRD
b20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2lnbmluZzE4MDYG
A1UEAxMvU3RhcnRDb20gQ2xhc3MgMSBQcmltYXJ5IEludGVybWVkaWF0ZSBDbGllbnQgQ0EwHhcN
MTIwNTAxMTI1ODI3WhcNMTMwNTAzMTEzNzIwWjBdMRkwFwYDVQQNExA4Y1VOSzUzMTc0ODRYRjk3
MRwwGgYDVQQDDBNkd213MkBpbmZyYWRlYWQub3JnMSIwIAYJKoZIhvcNAQkBFhNkd213MkBpbmZy
YWRlYWQub3JnMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyYe7wo6MrtrB4uIGGbrY
4IifY/Xsq22pSv605yganL0+uyUdd8rCjrYlH6Q/ra5TVJCQFTgzaepkuqPQc79DC/Cxmzm6Qo+s
wLZy868oFsccsVokL2bPAWIPaRXfNPJKkYR1FTWQfZpWJVQmT+sPf1XFUullVBAK+d9RztopyacI
xWoZ/W/Cmv7mseQbttYTtGKJa0btX73nsQRWl6SgErWXo59zg9friCLTy1GXMXJYB8H+PtnuwX0w
MrAvWDdX1ABgIlA17W3FraCn0eW15ZM46eyu0/amGzJZNtemCWF73P7BAijzeV1jNmiJFXdZ0DT0
w+hmtMO9PxdDUyt78QIDAQABo4IDrjCCA6owCQYDVR0TBAIwADALBgNVHQ8EBAMCBLAwHQYDVR0l
BBYwFAYIKwYBBQUHAwIGCCsGAQUFBwMEMB0GA1UdDgQWBBTkfe5UOr3PcirsjApibyyUEfsyRzAf
BgNVHSMEGDAWgBRTcu2SnODaywFcfH6WNU7y1LhRgjAeBgNVHREEFzAVgRNkd213MkBpbmZyYWRl
YWQub3JnMIICIQYDVR0gBIICGDCCAhQwggIQBgsrBgEEAYG1NwECAjCCAf8wLgYIKwYBBQUHAgEW
Imh0dHA6Ly93d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwNAYIKwYBBQUHAgEWKGh0dHA6Ly93
d3cuc3RhcnRzc2wuY29tL2ludGVybWVkaWF0ZS5wZGYwgfcGCCsGAQUFBwICMIHqMCcWIFN0YXJ0
Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MAMCAQEagb5UaGlzIGNlcnRpZmljYXRlIHdhcyBp
c3N1ZWQgYWNjb3JkaW5nIHRvIHRoZSBDbGFzcyAxIFZhbGlkYXRpb24gcmVxdWlyZW1lbnRzIG9m
IHRoZSBTdGFydENvbSBDQSBwb2xpY3ksIHJlbGlhbmNlIG9ubHkgZm9yIHRoZSBpbnRlbmRlZCBw
dXJwb3NlIGluIGNvbXBsaWFuY2Ugb2YgdGhlIHJlbHlpbmcgcGFydHkgb2JsaWdhdGlvbnMuMIGc
BggrBgEFBQcCAjCBjzAnFiBTdGFydENvbSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTADAgECGmRM
aWFiaWxpdHkgYW5kIHdhcnJhbnRpZXMgYXJlIGxpbWl0ZWQhIFNlZSBzZWN0aW9uICJMZWdhbCBh
bmQgTGltaXRhdGlvbnMiIG9mIHRoZSBTdGFydENvbSBDQSBwb2xpY3kuMDYGA1UdHwQvMC0wK6Ap
oCeGJWh0dHA6Ly9jcmwuc3RhcnRzc2wuY29tL2NydHUxLWNybC5jcmwwgY4GCCsGAQUFBwEBBIGB
MH8wOQYIKwYBBQUHMAGGLWh0dHA6Ly9vY3NwLnN0YXJ0c3NsLmNvbS9zdWIvY2xhc3MxL2NsaWVu
dC9jYTBCBggrBgEFBQcwAoY2aHR0cDovL2FpYS5zdGFydHNzbC5jb20vY2VydHMvc3ViLmNsYXNz
MS5jbGllbnQuY2EuY3J0MCMGA1UdEgQcMBqGGGh0dHA6Ly93d3cuc3RhcnRzc2wuY29tLzANBgkq
hkiG9w0BAQUFAAOCAQEAqDU1FKifNtCFJbLnvOi1BLRfk7mut55PMtPSZLJ4/AnG7AjmJnbBI4U5
DELwvVq3mIpwUpGqZUkqkZMEfBPIbfq517UZB3h4iANtqif+ULfTLhg5XgcK5eF8/T6EtX2c3epq
ylARdleCbj/0FwiUDvPlTsA6PIN4SCekjRLgjKERrL3heFz+Hteq1rtMAvMkNuyL0/0ijyyg2y45
NASAl2Afl9SLes/fnoh9nBwzfNQfb6qDYUFpnglfpGrq/0b1NtaOUb2z1SR+H1tKlb8bVJJIdvpu
mEi27kSRIhzk3h30uTfKkKetgy++ouyldxZ7KZ0PuoLQrBy465EoQLosETCCBxcwggX/oAMCAQIC
AwQmejANBgkqhkiG9w0BAQUFADCBjDELMAkGA1UEBhMCSUwxFjAUBgNVBAoTDVN0YXJ0Q29tIEx0
ZC4xKzApBgNVBAsTIlNlY3VyZSBEaWdpdGFsIENlcnRpZmljYXRlIFNpZ25pbmcxODA2BgNVBAMT
L1N0YXJ0Q29tIENsYXNzIDEgUHJpbWFyeSBJbnRlcm1lZGlhdGUgQ2xpZW50IENBMB4XDTEyMDUw
MTEyNTgyN1oXDTEzMDUwMzExMzcyMFowXTEZMBcGA1UEDRMQOGNVTks1MzE3NDg0WEY5NzEcMBoG
A1UEAwwTZHdtdzJAaW5mcmFkZWFkLm9yZzEiMCAGCSqGSIb3DQEJARYTZHdtdzJAaW5mcmFkZWFk
Lm9yZzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMmHu8KOjK7aweLiBhm62OCIn2P1
7KttqUr+tOcoGpy9PrslHXfKwo62JR+kP62uU1SQkBU4M2nqZLqj0HO/QwvwsZs5ukKPrMC2cvOv
KBbHHLFaJC9mzwFiD2kV3zTySpGEdRU1kH2aViVUJk/rD39VxVLpZVQQCvnfUc7aKcmnCMVqGf1v
wpr+5rHkG7bWE7RiiWtG7V+957EEVpekoBK1l6Ofc4PX64gi08tRlzFyWAfB/j7Z7sF9MDKwL1g3
V9QAYCJQNe1txa2gp9HlteWTOOnsrtP2phsyWTbXpglhe9z+wQIo83ldYzZoiRV3WdA09MPoZrTD
vT8XQ1Mre/ECAwEAAaOCA64wggOqMAkGA1UdEwQCMAAwCwYDVR0PBAQDAgSwMB0GA1UdJQQWMBQG
CCsGAQUFBwMCBggrBgEFBQcDBDAdBgNVHQ4EFgQU5H3uVDq9z3Iq7IwKYm8slBH7MkcwHwYDVR0j
BBgwFoAUU3Ltkpzg2ssBXHx+ljVO8tS4UYIwHgYDVR0RBBcwFYETZHdtdzJAaW5mcmFkZWFkLm9y
ZzCCAiEGA1UdIASCAhgwggIUMIICEAYLKwYBBAGBtTcBAgIwggH/MC4GCCsGAQUFBwIBFiJodHRw
Oi8vd3d3LnN0YXJ0c3NsLmNvbS9wb2xpY3kucGRmMDQGCCsGAQUFBwIBFihodHRwOi8vd3d3LnN0
YXJ0c3NsLmNvbS9pbnRlcm1lZGlhdGUucGRmMIH3BggrBgEFBQcCAjCB6jAnFiBTdGFydENvbSBD
ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTADAgEBGoG+VGhpcyBjZXJ0aWZpY2F0ZSB3YXMgaXNzdWVk
IGFjY29yZGluZyB0byB0aGUgQ2xhc3MgMSBWYWxpZGF0aW9uIHJlcXVpcmVtZW50cyBvZiB0aGUg
U3RhcnRDb20gQ0EgcG9saWN5LCByZWxpYW5jZSBvbmx5IGZvciB0aGUgaW50ZW5kZWQgcHVycG9z
ZSBpbiBjb21wbGlhbmNlIG9mIHRoZSByZWx5aW5nIHBhcnR5IG9ibGlnYXRpb25zLjCBnAYIKwYB
BQUHAgIwgY8wJxYgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwAwIBAhpkTGlhYmls
aXR5IGFuZCB3YXJyYW50aWVzIGFyZSBsaW1pdGVkISBTZWUgc2VjdGlvbiAiTGVnYWwgYW5kIExp
bWl0YXRpb25zIiBvZiB0aGUgU3RhcnRDb20gQ0EgcG9saWN5LjA2BgNVHR8ELzAtMCugKaAnhiVo
dHRwOi8vY3JsLnN0YXJ0c3NsLmNvbS9jcnR1MS1jcmwuY3JsMIGOBggrBgEFBQcBAQSBgTB/MDkG
CCsGAQUFBzABhi1odHRwOi8vb2NzcC5zdGFydHNzbC5jb20vc3ViL2NsYXNzMS9jbGllbnQvY2Ew
QgYIKwYBBQUHMAKGNmh0dHA6Ly9haWEuc3RhcnRzc2wuY29tL2NlcnRzL3N1Yi5jbGFzczEuY2xp
ZW50LmNhLmNydDAjBgNVHRIEHDAahhhodHRwOi8vd3d3LnN0YXJ0c3NsLmNvbS8wDQYJKoZIhvcN
AQEFBQADggEBAKg1NRSonzbQhSWy57zotQS0X5O5rreeTzLT0mSyePwJxuwI5iZ2wSOFOQxC8L1a
t5iKcFKRqmVJKpGTBHwTyG36ude1GQd4eIgDbaon/lC30y4YOV4HCuXhfP0+hLV9nN3qaspQEXZX
gm4/9BcIlA7z5U7AOjyDeEgnpI0S4IyhEay94Xhc/h7Xqta7TALzJDbsi9P9Io8soNsuOTQEgJdg
H5fUi3rP356IfZwcM3zUH2+qg2FBaZ4JX6Rq6v9G9TbWjlG9s9Ukfh9bSpW/G1SSSHb6bphItu5E
kSIc5N4d9Lk3ypCnrYMvvqLspXcWeymdD7qC0KwcuOuRKEC6LBExggNvMIIDawIBATCBlDCBjDEL
MAkGA1UEBhMCSUwxFjAUBgNVBAoTDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsTIlNlY3VyZSBEaWdp
dGFsIENlcnRpZmljYXRlIFNpZ25pbmcxODA2BgNVBAMTL1N0YXJ0Q29tIENsYXNzIDEgUHJpbWFy
eSBJbnRlcm1lZGlhdGUgQ2xpZW50IENBAgMEJnowCQYFKw4DAhoFAKCCAa8wGAYJKoZIhvcNAQkD
MQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTIxMjEzMTYyOTMxWjAjBgkqhkiG9w0BCQQx
FgQUeALyTFeTAGJpFAKYqzLh1j6+pPYwgaUGCSsGAQQBgjcQBDGBlzCBlDCBjDELMAkGA1UEBhMC
SUwxFjAUBgNVBAoTDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsTIlNlY3VyZSBEaWdpdGFsIENlcnRp
ZmljYXRlIFNpZ25pbmcxODA2BgNVBAMTL1N0YXJ0Q29tIENsYXNzIDEgUHJpbWFyeSBJbnRlcm1l
ZGlhdGUgQ2xpZW50IENBAgMEJnowgacGCyqGSIb3DQEJEAILMYGXoIGUMIGMMQswCQYDVQQGEwJJ
TDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlm
aWNhdGUgU2lnbmluZzE4MDYGA1UEAxMvU3RhcnRDb20gQ2xhc3MgMSBQcmltYXJ5IEludGVybWVk
aWF0ZSBDbGllbnQgQ0ECAwQmejANBgkqhkiG9w0BAQEFAASCAQC6/ox4idEGKUhtId0wqJCvLCwe
54lq4atK36O9vgtB52xwzPgmCQFBilbStr6gqd68TaCT9JLfzgiS3JjU/TPFqvnYs+rASWFWkcW9
OfW1fKjWgrhpNFHqH4euQjeTiL7YwfO1sz1kLEDeIMu7wefD9T2EQkSv4mQnueD5XRe2u9shkKXQ
rpRV1wOO7+Dgs1lks1/L+BJKmCWyy6ZZfDSyu8cgDmKOiPM4gqPno4XUJuvtjWm71d8sBiXOcwAZ
0mL5vQlvrrZ5FgbW9k5gFGYW4vwQLxU8o7NZzLb5JKN1TAx2taBt5MUiHOdjI9/kMuwCvRXlPLmN
OUOdgs96LqXQAAAAAAAA


--=-dRwFadJInn/QDBqCqXc6--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add __builtin_stpcpy and __sync_synchronize to
 declare_builtin_functions ===

From: Frederic Crozat <fcrozat@suse.com>
To: Unknown
Subject: [PATCH] Add __builtin_stpcpy and __sync_synchronize to
 declare_builtin_functions
Date: Wed, 29 Feb 2012 15:50:14 +0100
Message-ID: 
--------------------
---
 lib.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index 396e9f1..be0fa8f 100644
--- a/lib.c
+++ b/lib.c
@@ -682,6 +682,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strspn(const char *, const char *);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strcspn(const char *, const char *);\n");
 	add_pre_buffer("extern char * __builtin_strpbrk(const char *, const char *);\n");
+	add_pre_buffer("extern char* __builtin_stpcpy(const char *, const char*);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strlen(const char *);\n");
 
 	/* And bitwise operations.. */
@@ -714,6 +715,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 	add_pre_buffer("extern long __builtin_labs(long);\n");
 	add_pre_buffer("extern double __builtin_fabs(double);\n");
+	add_pre_buffer("extern void __sync_synchronize();\n");
 
 	/* Add Blackfin-specific stuff */
 	add_pre_buffer(
-- 
1.7.7


--=-YC7Er+jOG8IuPYDixjhK--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add __builtin_stpcpy, __sync_synchronize,
 __sync_bool_compare_and_swap to declare_builtin_functions ===

From: Frederic Crozat <fcrozat@suse.com>
To: Unknown
Subject: [PATCH] Add __builtin_stpcpy, __sync_synchronize,
 __sync_bool_compare_and_swap to declare_builtin_functions
Date: Fri, 23 Mar 2012 10:31:01 +0100
Message-ID: 
--------------------
---
 lib.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index 396e9f1..b61a79f 100644
--- a/lib.c
+++ b/lib.c
@@ -682,6 +682,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strspn(const char *, const char *);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strcspn(const char *, const char *);\n");
 	add_pre_buffer("extern char * __builtin_strpbrk(const char *, const char *);\n");
+	add_pre_buffer("extern char* __builtin_stpcpy(const char *, const char*);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strlen(const char *);\n");
 
 	/* And bitwise operations.. */
@@ -714,6 +715,8 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 	add_pre_buffer("extern long __builtin_labs(long);\n");
 	add_pre_buffer("extern double __builtin_fabs(double);\n");
+	add_pre_buffer("extern void __sync_synchronize();\n");
+	add_pre_buffer("extern int __sync_bool_compare_and_swap(void *, void, void);\n");
 
 	/* Add Blackfin-specific stuff */
 	add_pre_buffer(
-- 
1.7.7


--=-J+k8viTxJt5JqCGVyafh--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Frederic Crozat <fcrozat@suse.com>
To: Unknown
Subject: [PATCH] Add __builtin_stpcpy, __sync_synchronize,
 __sync_bool_compare_and_swap to declare_builtin_functions
Date: Fri, 23 Mar 2012 10:31:01 +0100
Message-ID: 
--------------------
Signed-off-by: Frederic Crozat <fcrozat@suse.com>
---
 lib.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/lib.c b/lib.c
index 396e9f1..30ffd89 100644
--- a/lib.c
+++ b/lib.c
@@ -682,6 +682,7 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strspn(const char *, const char *);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strcspn(const char *, const char *);\n");
 	add_pre_buffer("extern char * __builtin_strpbrk(const char *, const char *);\n");
+	add_pre_buffer("extern char* __builtin_stpcpy(const char *, const char*);\n");
 	add_pre_buffer("extern __SIZE_TYPE__ __builtin_strlen(const char *);\n");
 
 	/* And bitwise operations.. */
@@ -714,6 +715,8 @@ void declare_builtin_functions(void)
 	add_pre_buffer("extern long __builtin_alpha_cmpbge(long, long);\n");
 	add_pre_buffer("extern long __builtin_labs(long);\n");
 	add_pre_buffer("extern double __builtin_fabs(double);\n");
+	add_pre_buffer("extern void __sync_synchronize();\n");
+	add_pre_buffer("extern int __sync_bool_compare_and_swap(void *, ...);\n");
 
 	/* Add Blackfin-specific stuff */
 	add_pre_buffer(
-- 
1.7.7


--=-pPMIKOXoQWtDD4+hg9My--

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Documentation/sparse.txt: document context annotations for lock checking ===

From: Ed Cashin <ecashin () coraid ! com>
To: linux-sparse
Subject: [PATCH] Documentation/sparse.txt: document context annotations for lock checking
Date: Thu, 18 Oct 2012 14:27:26 +0000
Message-ID: <1350570446.22036 () cat ! he ! net>
--------------------
The context feature of sparse is used with the Linux kernel
sources to check for imbalanced uses of locks.  Document the
annotations defined in include/linux/compiler.h that tell sparse
what to expect when a lock is held on function entry, exit, or
both.

Signed-off-by: Ed Cashin <ecashin@coraid.com>
---
 Documentation/sparse.txt |   18 ++++++++++++++++++
 1 files changed, 18 insertions(+), 0 deletions(-)

diff --git a/Documentation/sparse.txt b/Documentation/sparse.txt
index 4909d41..eceab13 100644
--- a/Documentation/sparse.txt
+++ b/Documentation/sparse.txt
@@ -49,6 +49,24 @@ be generated without __CHECK_ENDIAN__.
 __bitwise - noisy stuff; in particular, __le*/__be* are that.  We really
 don't want to drown in noise unless we'd explicitly asked for it.
 
+Using sparse for lock checking
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The following macros are undefined for gcc and defined during a sparse
+run to use the "context" tracking feature of sparse, applied to
+locking.  These annotations tell sparse when a lock is held, with
+regard to the annotated function's entry and exit.
+
+__must_hold - The specified lock is held on function entry and exit.
+
+__acquires - The specified lock is held on function exit, but not entry.
+
+__releases - The specified lock is held on function entry, but not exit.
+
+If the function enters and exits without the lock held, acquiring and
+releasing the lock inside the function in a balanced way, no
+annotation is needed.  The tree annotations above are for cases where
+sparse would otherwise report a context imbalance.
 
 Getting sparse
 ~~~~~~~~~~~~~~
-- 
1.7.1

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-doc
Subject: Re: [PATCH] Documentation/sparse.txt: document context annotations for lock checking
Date: Thu, 18 Oct 2012 23:09:49 +0000
Message-ID: <20121018230948.GC10627 () jtriplet-mobl1>
--------------------
On Thu, Oct 18, 2012 at 07:27:26AM -0700, Ed Cashin wrote:
> The context feature of sparse is used with the Linux kernel
> sources to check for imbalanced uses of locks.  Document the
> annotations defined in include/linux/compiler.h that tell sparse
> what to expect when a lock is held on function entry, exit, or
> both.
> 
> Signed-off-by: Ed Cashin <ecashin@coraid.com>

Reviewed-by: Josh Triplett <josh@joshtriplett.org>

>  Documentation/sparse.txt |   18 ++++++++++++++++++
>  1 files changed, 18 insertions(+), 0 deletions(-)
> 
> diff --git a/Documentation/sparse.txt b/Documentation/sparse.txt
> index 4909d41..eceab13 100644
> --- a/Documentation/sparse.txt
> +++ b/Documentation/sparse.txt
> @@ -49,6 +49,24 @@ be generated without __CHECK_ENDIAN__.
>  __bitwise - noisy stuff; in particular, __le*/__be* are that.  We really
>  don't want to drown in noise unless we'd explicitly asked for it.
>  
> +Using sparse for lock checking
> +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> +
> +The following macros are undefined for gcc and defined during a sparse
> +run to use the "context" tracking feature of sparse, applied to
> +locking.  These annotations tell sparse when a lock is held, with
> +regard to the annotated function's entry and exit.
> +
> +__must_hold - The specified lock is held on function entry and exit.
> +
> +__acquires - The specified lock is held on function exit, but not entry.
> +
> +__releases - The specified lock is held on function entry, but not exit.
> +
> +If the function enters and exits without the lock held, acquiring and
> +releasing the lock inside the function in a balanced way, no
> +annotation is needed.  The tree annotations above are for cases where
> +sparse would otherwise report a context imbalance.
>  
>  Getting sparse
>  ~~~~~~~~~~~~~~
> -- 
> 1.7.1
> 
--
To unsubscribe from this list: send the line "unsubscribe linux-doc" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-kernel
Subject: Re: [PATCH] Documentation/sparse.txt: document context annotations for lock checking
Date: Thu, 18 Oct 2012 23:09:49 +0000
Message-ID: <20121018230948.GC10627 () jtriplet-mobl1>
--------------------
On Thu, Oct 18, 2012 at 07:27:26AM -0700, Ed Cashin wrote:
> The context feature of sparse is used with the Linux kernel
> sources to check for imbalanced uses of locks.  Document the
> annotations defined in include/linux/compiler.h that tell sparse
> what to expect when a lock is held on function entry, exit, or
> both.
> 
> Signed-off-by: Ed Cashin <ecashin@coraid.com>

Reviewed-by: Josh Triplett <josh@joshtriplett.org>

>  Documentation/sparse.txt |   18 ++++++++++++++++++
>  1 files changed, 18 insertions(+), 0 deletions(-)
> 
> diff --git a/Documentation/sparse.txt b/Documentation/sparse.txt
> index 4909d41..eceab13 100644
> --- a/Documentation/sparse.txt
> +++ b/Documentation/sparse.txt
> @@ -49,6 +49,24 @@ be generated without __CHECK_ENDIAN__.
>  __bitwise - noisy stuff; in particular, __le*/__be* are that.  We really
>  don't want to drown in noise unless we'd explicitly asked for it.
>  
> +Using sparse for lock checking
> +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> +
> +The following macros are undefined for gcc and defined during a sparse
> +run to use the "context" tracking feature of sparse, applied to
> +locking.  These annotations tell sparse when a lock is held, with
> +regard to the annotated function's entry and exit.
> +
> +__must_hold - The specified lock is held on function entry and exit.
> +
> +__acquires - The specified lock is held on function exit, but not entry.
> +
> +__releases - The specified lock is held on function entry, but not exit.
> +
> +If the function enters and exits without the lock held, acquiring and
> +releasing the lock inside the function in a balanced way, no
> +annotation is needed.  The tree annotations above are for cases where
> +sparse would otherwise report a context imbalance.
>  
>  Getting sparse
>  ~~~~~~~~~~~~~~
> -- 
> 1.7.1
> 
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] Documentation/sparse.txt: document context annotations for lock checking
Date: Thu, 18 Oct 2012 23:09:49 +0000
Message-ID: <20121018230948.GC10627 () jtriplet-mobl1>
--------------------
On Thu, Oct 18, 2012 at 07:27:26AM -0700, Ed Cashin wrote:
> The context feature of sparse is used with the Linux kernel
> sources to check for imbalanced uses of locks.  Document the
> annotations defined in include/linux/compiler.h that tell sparse
> what to expect when a lock is held on function entry, exit, or
> both.
> 
> Signed-off-by: Ed Cashin <ecashin@coraid.com>

Reviewed-by: Josh Triplett <josh@joshtriplett.org>

>  Documentation/sparse.txt |   18 ++++++++++++++++++
>  1 files changed, 18 insertions(+), 0 deletions(-)
> 
> diff --git a/Documentation/sparse.txt b/Documentation/sparse.txt
> index 4909d41..eceab13 100644
> --- a/Documentation/sparse.txt
> +++ b/Documentation/sparse.txt
> @@ -49,6 +49,24 @@ be generated without __CHECK_ENDIAN__.
>  __bitwise - noisy stuff; in particular, __le*/__be* are that.  We really
>  don't want to drown in noise unless we'd explicitly asked for it.
>  
> +Using sparse for lock checking
> +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> +
> +The following macros are undefined for gcc and defined during a sparse
> +run to use the "context" tracking feature of sparse, applied to
> +locking.  These annotations tell sparse when a lock is held, with
> +regard to the annotated function's entry and exit.
> +
> +__must_hold - The specified lock is held on function entry and exit.
> +
> +__acquires - The specified lock is held on function exit, but not entry.
> +
> +__releases - The specified lock is held on function entry, but not exit.
> +
> +If the function enters and exits without the lock held, acquiring and
> +releasing the lock inside the function in a balanced way, no
> +annotation is needed.  The tree annotations above are for cases where
> +sparse would otherwise report a context imbalance.
>  
>  Getting sparse
>  ~~~~~~~~~~~~~~
> -- 
> 1.7.1
> 
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Documentation/sparse.txt: document context annotations for lock checking
Date: Fri, 19 Oct 2012 22:14:22 +0000
Message-ID: <CANeU7QkUdeR6HyDEVF1fkm9EN=SEkcuY0QPyZxpYnGAzDj7+kg () mail ! gmail ! com>
--------------------
On Thu, Oct 18, 2012 at 7:27 AM, Ed Cashin <ecashin@coraid.com> wrote:
> The context feature of sparse is used with the Linux kernel
> sources to check for imbalanced uses of locks.  Document the
> annotations defined in include/linux/compiler.h that tell sparse
> what to expect when a lock is held on function entry, exit, or
> both.
>
> Signed-off-by: Ed Cashin <ecashin@coraid.com>

Signed-off-by: Christopher Li <sparse@chrisli.org>

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-doc
Subject: Re: [PATCH] Documentation/sparse.txt: document context annotations for lock checking
Date: Fri, 19 Oct 2012 22:14:22 +0000
Message-ID: <CANeU7QkUdeR6HyDEVF1fkm9EN=SEkcuY0QPyZxpYnGAzDj7+kg () mail ! gmail ! com>
--------------------
On Thu, Oct 18, 2012 at 7:27 AM, Ed Cashin <ecashin@coraid.com> wrote:
> The context feature of sparse is used with the Linux kernel
> sources to check for imbalanced uses of locks.  Document the
> annotations defined in include/linux/compiler.h that tell sparse
> what to expect when a lock is held on function entry, exit, or
> both.
>
> Signed-off-by: Ed Cashin <ecashin@coraid.com>

Signed-off-by: Christopher Li <sparse@chrisli.org>

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-doc" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-kernel
Subject: Re: [PATCH] Documentation/sparse.txt: document context annotations for lock checking
Date: Fri, 19 Oct 2012 22:14:22 +0000
Message-ID: <CANeU7QkUdeR6HyDEVF1fkm9EN=SEkcuY0QPyZxpYnGAzDj7+kg () mail ! gmail ! com>
--------------------
On Thu, Oct 18, 2012 at 7:27 AM, Ed Cashin <ecashin@coraid.com> wrote:
> The context feature of sparse is used with the Linux kernel
> sources to check for imbalanced uses of locks.  Document the
> annotations defined in include/linux/compiler.h that tell sparse
> what to expect when a lock is held on function entry, exit, or
> both.
>
> Signed-off-by: Ed Cashin <ecashin@coraid.com>

Signed-off-by: Christopher Li <sparse@chrisli.org>

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: [PATCH] Fix wrong array size expression ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Fix wrong array size expression
Date: Wed, 01 Aug 2012 16:35:15 +0000
Message-ID: <CANeU7QmaMSAfNfX14=LjM9jpdWXmFjEyi-vRAQeeOpTdu3xatw () mail ! gmail ! com>
--------------------
Thanks for the good catch. That is simple and obvious correct.

Will apply.

Chris

On Wed, Aug 1, 2012 at 9:07 AM, Mauro Dreissig <mukadr@gmail.com> wrote:
> Signed-off-by: Mauro Dreissig <mukadr@gmail.com>
> ---
>  expression.c | 2 +-
>  1 file changed, 1 insertion(+), 1 deletion(-)
>
> diff --git a/expression.c b/expression.c
> index 0ae3a60..9f45c79 100644
> --- a/expression.c
> +++ b/expression.c
> @@ -655,7 +655,7 @@ static struct token *unary_expression(struct token *token, struct expression **t
>                                 { &__sizeof_ptr___ident, EXPR_PTRSIZEOF },
>                         };
>                         int i;
> -                       for (i = 0; i < 3; i++) {
> +                       for (i = 0; i < ARRAY_SIZE(type_information); i++) {
>                                 if (ident == type_information[i].id)
>                                         return type_info_expression(token, tree, type_information[i].type);
>                         }
> --
> 1.7.11.2
>
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Inherit nocast modifier when referencing  a variable ===

From: Lars-Peter Clausen <lars () metafoo ! de>
To: linux-sparse
Subject: [PATCH] Inherit nocast modifier when referencing  a variable
Date: Wed, 17 Oct 2012 17:12:53 +0000
Message-ID: <1350493973-6210-1-git-send-email-lars () metafoo ! de>
--------------------
The nocast modifier should be inherited when referencing a variable, so add it
to MOD_PTRINHERIT.

E.g. without this patch the following code snippet ...

	typedef int __attribute__((nocast)) test_type;

	static void foo(test_type *a) {}

	static void bar(void)
	{
		test_type a;
		foo(&a);
	}

... incorrectly generates the following sparse warnings:

	nocast_ref.c:8:10: warning: incorrect type in argument 1 (different modifiers)
	nocast_ref.c:8:10:    expected int [nocast] [usertype] *a
	nocast_ref.c:8:10:    got int *<noident>
	nocast_ref.c:8:10: warning: implicit cast to nocast type

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
---
 symbol.h |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/symbol.h b/symbol.h
index 1e74579..c7ec35b 100644
--- a/symbol.h
+++ b/symbol.h
@@ -229,7 +229,8 @@ struct symbol {
 #define MOD_SIZE	(MOD_CHAR | MOD_SHORT | MOD_LONG_ALL)
 #define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
 	MOD_ASSIGNED | MOD_USERTYPE | MOD_ACCESSED | MOD_EXPLICITLY_SIGNED)
-#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE | MOD_NORETURN)
+#define MOD_PTRINHERIT (MOD_VOLATILE | MOD_CONST | MOD_NODEREF | MOD_STORAGE | \
+	MOD_NORETURN | MOD_NOCAST)
 
 
 /* Current parsing/evaluation function */
-- 
1.7.10.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Updated __nocast vs __bitwise documentation ===

From: Shakthi Kannan <shakthimaan () gmail ! com>
To: linux-sparse
Subject: [PATCH] Updated __nocast vs __bitwise documentation
Date: Thu, 10 May 2012 06:56:57 +0000
Message-ID: <CABG-yt2XiduTbyN+tm++Fw1_s9_QvjFy60=5a--tScMwDT443A () mail ! gmail ! com>
--------------------
I have updated the sparse.1 man page including the __bitwise
relevant content, and created Documentation/sparse.txt with the
complete comparison between __nocast vs __bitwise.

Signed-off-by: Shakthi Kannan <shakthimaan@gmail.com>
---
 Documentation/sparse.txt |   39 +++++++++++++++++++++++++++++++++++++++
 sparse.1                 |   14 +++++++++++++-
 2 files changed, 52 insertions(+), 1 deletions(-)
 create mode 100644 Documentation/sparse.txt

diff --git a/Documentation/sparse.txt b/Documentation/sparse.txt
new file mode 100644
index 0000000..37e8916
--- /dev/null
+++ b/Documentation/sparse.txt
@@ -0,0 +1,39 @@
+Sparse
+~~~~~~
+
+__nocast vs __bitwise:
+
+__nocast warns about explicit or implicit casting to different types.
+
+HOWEVER, it doesn't consider two 32-bit integers to be different
+types, so a __nocast 'int' type may be returned as a regular 'int'
+type and then the __nocast is lost.
+
+So "__nocast" on integer types is usually not that powerful. It just
+gets lost too easily. It's more useful for things like pointers. It
+also doesn't warn about the mixing: you can add integers to __nocast
+integer types, and it's not really considered anything wrong.
+
+__bitwise ends up being a "stronger integer separation". That one
+doesn't allow you to mix with non-bitwise integers, so now it's much
+harder to lose the type by mistake.
+
+So the basic rule is:
+
+ - "__nocast" on its own tends to be more useful for *big* integers
+that still need to act like integers, but you want to make it much
+less likely that they get truncated by mistake. So a 64-bit integer
+that you don't want to mistakenly/silently be returned as "int", for
+example. But they mix well with random integer types, so you can add
+to them etc without using anything special. However, that mixing also
+means that the __nocast really gets lost fairly easily.
+
+ - "__bitwise" is for *unique types* that cannot be mixed with other
+types, and that you'd never want to just use as a random integer (the
+integer 0 is special, though, and gets silently accepted iirc - it's
+kind of like "NULL" for pointers). So "gfp_t" or the "safe endianness"
+types would be __bitwise: you can only operate on them by doing
+specific operations that know about *that* particular type.
+
+Generally, you want __bitwise if you are looking for type safety.
+"__nocast" really is pretty weak.
diff --git a/sparse.1 b/sparse.1
index bde6b6d..ae85b54 100644
--- a/sparse.1
+++ b/sparse.1
@@ -53,7 +53,19 @@ arithmetic operations other than bitwise
operations, and on any conversion of
 one restricted type into another, except via a cast that includes
 \fB__attribute__((force))\fR.

-Sparse does not issue these warnings by default.
+__bitwise ends up being a "stronger integer separation". That one
+doesn't allow you to mix with non-bitwise integers, so now it's much
+harder to lose the type by mistake.
+
+__bitwise is for *unique types* that cannot be mixed with other
+types, and that you'd never want to just use as a random integer (the
+integer 0 is special, though, and gets silently accepted iirc - it's
+kind of like "NULL" for pointers). So "gfp_t" or the "safe endianness"
+types would be __bitwise: you can only operate on them by doing
+specific operations that know about *that* particular type.
+
+Generally, you want bitwise if you are looking for type safety. Sparse
+does not issue these warnings by default.
 .
 .TP
 .B \-Wcast\-to\-as
-- 
1.7.7.6
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Shakthi Kannan <shakthimaan () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] Updated __nocast vs __bitwise documentation
Date: Thu, 10 May 2012 11:18:28 +0000
Message-ID: <CABG-yt2yVwF76vHitm-KzKLV4kQ205hEMTCeRcsJF9-doWvW6w () mail ! gmail ! com>
--------------------
Hi Chris:

--- On Thu, May 10, 2012 at 4:20 PM, Christopher Li <sparse@chrisli.org> wrote:
| Looks good. Thanks for doing that.
|
| Can you add some reference (in sparse.txt) to the original Linus email
| where some
| of this document is base on? Just to give credit where it is due. A
link to the
| Linus original email would be perfect.
\--

Is the following reference sufficient if added to the sparse.txt file?

=== sparse.txt ===

Sparse
~~~~~

Copyright (C) 2012 Linus Torvalds

Source: https://lkml.org/lkml/2012/3/22/409

__nocast vs __bitwise:

...
...
...

=== END ===

I will re-submit the patch with the approved changes.

Thanks for your quick response!

SK

-- 
Shakthi Kannan
http://www.shakthimaan.com
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Triplett <josh () joshtriplett ! org>
To: linux-sparse
Subject: Re: [PATCH] Updated __nocast vs __bitwise documentation
Date: Thu, 10 May 2012 18:24:40 +0000
Message-ID: <20120510182440.GA19991 () leaf>
--------------------
On Thu, May 10, 2012 at 04:36:28PM +0530, Shakthi Kannan wrote:
> Source: https://lkml.org/lkml/2012/3/22/409

I've found lkml.org somewhat unreliable.  I'd suggest liking to
http://mid.gmane.org/<the-message-ID> ; in this case,
http://mid.gmane.org/CA+55aFzbhYvw7Am9EYgatpjTknBFm9eq+3jBWQHkSCUpnb3HRQ@mail.gmail.com

- Josh Triplett
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] depend.c: build up a dependency tree from c entities downto tokens: entries in the tree ===

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: [PATCH] depend.c: build up a dependency tree from c entities downto tokens: entries in the tree
Date: Thu, 26 Apr 2012 12:06:44 +0000
Message-ID: <4F993A54.3020706 () gmail ! com>
--------------------
On 04/26/2012 11:13 AM, Christopher Li wrote:
> .
> On Wed, Apr 25, 2012 at 1:16 PM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>> Hello Christopher Li,
>> I'd like to send a patch for review to be included
>> into sparse. The patch builds up a dependency
>> tree from c parse entities downto single token,
>> making it possible to write tools that analyse what
>> token was generated by what macro and which
>> macros it is dependent of.

Thanks for the reply, I'm open for rewrite.

>
> Sorry I just get back from a trip, did not have a chance to
> write a reply during the travel.
>
> I briefly look through the patch, haven't got enough time
> to look at it in the detail level. Here is a few things that
> jump out, I am not going to apply this patch as it is.
>
>>> +void token_allocator_nofree(void)
>>> +{
>>> +       token_allocator.nofree = 1;
>>> +}
>
> What is up with this nofree thing?
> There should be much better way to keep the token
> unfree.

The thing is that you want to maintain the dependency
from c-parsing units downto tokens. So the struct token
should not be free'd after the parsing stage. Also
calls to free_token should actually preserve the struct
token so that it still can be referenced.

>
>>> diff --git a/allocate.h b/allocate.h
>>> index 9f1dc8c..de85320 100644
>>> --- a/allocate.h
>>> +++ b/allocate.h
>>> @@ -12,6 +12,7 @@ struct allocator_struct {
>>>         struct allocation_blob *blobs;
>>>         unsigned int alignment;
>>>         unsigned int chunking;
>>> +       unsigned int nofree;
>
> Nack here as well.

See above.

>
>>> diff --git a/attr.c b/attr.c
>>> new file mode 100644
>>> index 0000000..54c4c21
>>> --- /dev/null
>>> +++ b/attr.c
>>> +#define HASH_LEN (1024*4)
>>> +struct hash {
>>> +       struct hash_v *f;
>>> +} h[HASH_LEN];
>>> +
>>> --- /dev/null
>>> +++ b/depend.c
>>> @@ -0,0 +1,329 @@
>>> +/*
>>> + * Build macros dependency tree
>>> + * Copyright (C) 2012 Konrad Eisele<konrad@gaisler.com,eiselekd@gmail.com>
>>> + * BSD-License
>>> + * Redistribution and use in source and binary forms are permitted
>>> + * provided that the above copyright notice and this paragraph are
>>> + * duplicated in all such forms and that any documentation,
>>> + * advertising materials, and other materials related to such
>>> + * distribution and use acknowledge that the software was developed
>>> + * by the<organization>.  The name of the
>>> + * University may not be used to endorse or promote products derived
>>> + * from this software without specific prior written permission.
>>> + * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
>>> + * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
>>> + * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
>>> + */
>
> Why BSD license? Sparse current is open software license and moving to
> MIT license.

I can set in any License you want. What I dont want is
having to go through the FSF copyleft bureaucracy. BSD is
the easiest I guess, but I'll set in any text.

>
>>> -               struct expression *e = alloc_expression(token->pos, EXPR_STATEMENT);
>>> +               struct expression *e = alloc_expression_tok(token, EXPR_STATEMENT);
>
> Please don't do change like this. It does not have any add on value.

Again, to build up the dependency tree going from c-parse entities
downto tokens I need the struct token, not "pos". It doesnt change
any logic, and the changes I did to the original soucecode are minimal
that way.

The other alternative is of course to switch from "pos" to struct token
in all structures. (And retaint the tokens by default).

>
>
> There are a lot more I want to comment on but I need some time to think about
> what is the best way to do it. I am not oppose to adding feature to track macro
> dependency, but it need to be less intrusive to the code. I want to avoid impact
> the normal code path that does not care about macro dependency. e.g. the
> sparse checker.
>
> I also suspect the hashing is unnecessary.  Give me some time to come up
> with some suggestion.

Without the hashing quite a lot of rewrite of the internal structures
are needed, with the hashing the original structures can be maintained,
which are simple and easy.
The dependency tree caries a lot of extra data with it. "Normal"
cases dont need that. For instance you want for each token pointers to:
"Macro dependency-tree" + "Macro expansion" + "endpos" + "visited" etc.

And even on my slow laptop no difference in speed is noticable with hashing.

An middle way would be to add to each structure a "void *custom_data"
that could be used/extend by the application. Then the data structures
get a bit bigger however you dont need to traverse the hash tree.


-- Konrad


>
> Chris
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] evaluate: reject post-ops on void* ===

From: =?ISO-8859-1?Q?Jan_Pokorn=FD?= <pokorny_jan () seznam ! cz>
To: linux-sparse
Subject: [PATCH] evaluate: reject post-ops on void*
Date: Sun, 22 Jan 2012 23:31:21 +0000
Message-ID: <4F1C9C49.2050707 () seznam ! cz>
--------------------
Following example haven't been linearized correctly:

	static void *inc_ptr(void *a) {
		return ++a;
	}

test-linearize:

	<entry-point>
	add.32      %r2 <- %arg1, $-1
	ret.32      %r2

Apparently, something went wrong with -1 value to be added to the original
pointer.  When void* substituted for int*, the result is as expected
(considering 32b int):

	<entry-point>
	add.32      %r2 <- %arg1, $4
	ret.32      %r2

The proposed patch turns post-ops on void* operand into an error
(taking the same route as with function operand).

When running check with C=2 on my old linux-3.0.6 configuration,
this detected a few occurencies:

	drivers/scsi/scsi_proc.c:405:31: error: bad argument type for ++/--
	drivers/scsi/scsi_proc.c:413:23: error: bad argument type for ++/--
	net/bluetooth/hci_core.c:1545:29: error: bad argument type for ++/--
	net/bluetooth/l2cap_core.c:1825:37: error: bad argument type for ++/--
	net/bluetooth/bnep/core.c:239:13: error: bad argument type for ++/--
	lib/sort.c:25:27: error: bad argument type for ++/--
	lib/sort.c:26:27: error: bad argument type for ++/--
	lib/check_signature.c:21:24: error: bad argument type for ++/--

All of them seems trivially fixable.

Alternatively, I can turn it to emit an warning only (should be
configurable/default?).  To be noted that GCC will only emit an warning,
and only if -pedantic or -Wpointer-arith specified, but I consider
it rather a convenient exception.

When this gets clear, I'll add also the respective test-case.

Signed-off-by: Jan Pokorny <pokorny_jan@seznam.cz>
---
 evaluate.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/evaluate.c b/evaluate.c
index bebe968..b6d706b 100644
--- a/evaluate.c
+++ b/evaluate.c
@@ -1711,7 +1711,8 @@ static struct symbol *evaluate_postop(struct expression *expr)
 		multiply = 1;
 	} else if (class == TYPE_PTR) {
 		struct symbol *target = examine_pointer_target(ctype);
-		if (!is_function(target))
+		/* beside function, reject also void* (due to sizeof(void)) */
+		if (target != &void_ctype && !is_function(target))
 			multiply = bits_to_bytes(target->bit_size);
 	}
 
-- 
1.7.3.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] mdep.c test ===

From: Konrad Eisele <eiselekd@gmail.de>
To: Unknown
Subject: [PATCH] mdep.c test
Date: Sat, 12 May 2012 18:43:16 +0200
Message-ID: 
--------------------
---
 Makefile      |    5 +-
 a.h           |    6 ++
 a2.h          |    2 +
 lib.c         |   19 +++--
 mdep.c        |  248 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 pre-process.c |    3 +-
 test-macro.c  |   10 +-
 test-mdep.c   |   62 ++++++++++++++
 token.h       |    8 ++-
 tokenize.c    |    8 +-
 10 files changed, 351 insertions(+), 20 deletions(-)
 create mode 100644 a.h
 create mode 100644 a2.h
 create mode 100644 mdep.c
 create mode 100644 test-mdep.c

diff --git a/Makefile b/Makefile
index 4abcbdd..b688054 100644
--- a/Makefile
+++ b/Makefile
@@ -44,7 +44,7 @@ PKGCONFIGDIR=$(LIBDIR)/pkgconfig
 
 PROGRAMS=test-lexing test-parsing obfuscate compile graph sparse \
 	 test-linearize example test-unssa test-dissect ctags \
-	 test-macro
+	 test-mdep test-macro 
 
 INST_PROGRAMS=sparse cgcc
 INST_MAN1=sparse.1 cgcc.1
@@ -96,7 +96,8 @@ LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
 	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
 	  sort.o allocate.o compat-$(OS).o ptrlist.o \
-	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o
+	  flow.o cse.o simplify.o memops.o liveness.o storage.o unssa.o dissect.o \
+	  mdep.o
 
 LIB_FILE= libsparse.a
 SLIB_FILE= libsparse.so
diff --git a/a.h b/a.h
new file mode 100644
index 0000000..63da9e8
--- /dev/null
+++ b/a.h
@@ -0,0 +1,6 @@
+//#include <stdio.h>
+#define D0(d0a0,d0a1) 1 D1(d0a0) 2 D2(d0a1) 3
+#define D1(d1a0) 4 d1a0 5
+#define D2(d2a0)
+#define D3(d3a0) 8 d3a0 9
+1 2  D0(D3(10),11) 3 4 
diff --git a/a2.h b/a2.h
new file mode 100644
index 0000000..098fbc2
--- /dev/null
+++ b/a2.h
@@ -0,0 +1,2 @@
+#define A(a,b) b 3 
+A(1,2)
diff --git a/lib.c b/lib.c
index 1876fc9..51879d9 100644
--- a/lib.c
+++ b/lib.c
@@ -577,6 +577,7 @@ static char **handle_switch_ftabstop(char *arg, char **next)
 	return next;
 }
 
+int fnobuildin = 0;
 static char **handle_switch_f(char *arg, char **next)
 {
 	arg++;
@@ -588,6 +589,9 @@ static char **handle_switch_f(char *arg, char **next)
 
 	if (!strncmp(arg, "no-", 3)) {
 		arg += 3;
+		if (!strncmp(arg, "buildin", 7)) {
+			fnobuildin = 1;
+		}
 	}
 	/* handle switch here.. */
 	return next;
@@ -875,7 +879,7 @@ static struct symbol_list *sparse_tokenstream(struct token *token)
 	token = preprocess(token);
 
 	if (preprocess_only) {
-		show_tokenstream(token);
+		show_tokenstream(token, 0);
 		putchar('\n');
 		return NULL;
 	}
@@ -963,12 +967,13 @@ struct symbol_list *sparse_initialize(int argc, char **argv, struct string_list
 		// Initialize type system
 		init_ctype();
 
-		create_builtin_stream();
-		add_pre_buffer("#define __CHECKER__ 1\n");
-		if (!preprocess_only)
-			declare_builtin_functions();
-
-		list = sparse_initial();
+		if (!fnobuildin) {
+			create_builtin_stream();
+			add_pre_buffer("#define __CHECKER__ 1\n");
+			if (!preprocess_only)
+				declare_builtin_functions();
+			list = sparse_initial();
+		}
 
 		/*
 		 * Protect the initial token allocations, since
diff --git a/mdep.c b/mdep.c
new file mode 100644
index 0000000..6af8467
--- /dev/null
+++ b/mdep.c
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2012 Konrad Eisele <eiselekd@gmail.com>
+ * BSD-License
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the <organization>.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include "token.h"
+#include "allocate.h"
+#include "compat.h"
+#include "parse.h"
+#include "symbol.h"
+#include "token.h"
+#include "lib.h"
+
+static void expand_macro(struct token *macro, struct symbol *sym, 
+                         struct token *parent, struct token **replace, 
+                         struct token **replace_tail, struct token *last);
+static void expand_arg(struct token *macro, struct symbol *sym, int arg,
+		       struct token *orig, struct token *expanded);
+struct pp;
+struct pp_e;
+
+struct preprocess_hook pp = {
+    .expand_macro = expand_macro,
+    .expand_arg = expand_arg
+};
+
+unsigned int pps = 0;
+
+void mdep_init(void) {
+    preprocess_hook = &pp;
+    pps = init_stream("<pp>", -1, 0);
+}
+
+enum tags {
+    ATTR_TOK = 1,
+    ATTR_TOKP = 2,
+};
+
+struct hash_v {
+    struct hash_v *n;
+    long key;
+    enum tags tag;
+    void *v;
+};
+
+__DECLARE_ALLOCATOR(struct hash_v, hash_v);
+__ALLOCATOR(struct hash_v, "hash value", hash_v);
+
+#define HASH_LEN (1024*4)
+struct hash {
+    struct hash_v *f;
+} h[HASH_LEN];
+
+static int hash_func(long key, enum tags tag) {
+    unsigned int k = ((unsigned int)key) >> 4;
+    return ((k) ^ (k >> 16) ^ (k >> 24) ^ tag) & (HASH_LEN-1);
+}
+
+void **lookup_attr(long key, enum tags tag, int create) {
+    int i = hash_func(key, tag);
+    struct hash *hp = &h[i];
+    struct hash_v *p;
+    struct hash_v **c = &hp->f;
+    while((p = *c)) {
+        if ((p ->tag == tag)
+            && (p ->key == key)) {
+            return &p->v;
+        }
+        c = &p->n;
+    }
+    if (create) {
+        p = __alloc_hash_v(0);
+        p->key = key;
+        p->tag = tag;
+        p->v = 0;
+        *c = p;
+        return &p->v;
+    }
+    return 0;
+}
+
+enum pp_typ {
+    MARG = 1,
+    MBODY,
+};
+
+struct pp {
+    enum pp_typ t;
+    union {
+        unsigned int argi;
+    };
+    struct pp_e *f;
+    struct symbol *sym;
+    struct token *tok;
+    struct token *s, *d;
+};
+
+struct pp_e {
+    struct pp_e *n;
+    struct pp *p;
+    struct position from;
+    int idx;
+};
+
+__DECLARE_ALLOCATOR(struct pp, pp_v);
+__ALLOCATOR(struct pp, "pp trace", pp_v);
+__DECLARE_ALLOCATOR(struct pp_e, pp_e_v);
+__ALLOCATOR(struct pp_e, "pp trace element", pp_e_v);
+int n_tokid = 1;
+
+void pp_dope_list(struct pp *p, struct token **d, int dope, struct token *list, struct token *end, int prt)
+{
+    struct pp_e **e = &p->f;
+    struct token *n;
+    int idx = 0;
+    while ((!eof_token(list)) && list != end ) {
+        if (dope) {
+            void **v;
+            int id = n_tokid++;
+            struct pp_e *n = __alloc_pp_e_v(0);
+            n->from = list->pos;
+            n->idx = idx;
+            n->n = 0;
+            n->p = p;
+            *e = n;
+            v = lookup_attr(id, ATTR_TOK, 1);
+            *v = n;
+            list->pos.line = id;
+            list->pos.stream = pps;
+            e = &n->n;
+        }
+        n = __alloc_token(0);
+        *n = *list;
+        /*printf(" %s\n", show_token(list));*/
+        n->next = &eof_token_entry;
+        *d = n;
+        d = &n->next;
+        list = list->next;
+        idx++;
+        
+	
+    }
+}
+
+struct pp *new_pp(struct token *m, int t) {
+	struct pp *n = __alloc_pp_v(0);
+	n->t = t;
+	n->f = 0;
+	return n;
+}
+
+static void expand_macro(struct token *macro, struct symbol *sym, struct token *parent,
+			 struct token **replace, struct token **replace_tail, struct token *last)
+{
+    struct pp *p = new_pp(macro, MBODY);
+    p->sym = sym;
+    p->tok = macro;
+    pp_dope_list(p, &p->s, 0, sym->expansion, 0, 0);
+    pp_dope_list(p, &p->d, 1, *replace, last, 0);
+}
+
+static void expand_arg(struct token *macro, struct symbol *sym, int arg,
+		       struct token *orig, struct token *expanded)
+{
+    struct pp *p = new_pp(macro, MARG);
+    p->argi = arg;
+    p->sym = sym;
+    p->tok = macro;
+    pp_dope_list(p, &p->s, 0, orig, 0, 0);
+    pp_dope_list(p, &p->d, 1, expanded, 0, 0);
+}
+
+void mdep_show_tokenstream(struct token *token, struct token *end, int idx)
+{
+    int i = 0;
+    while (token != end && !eof_token(token)) {
+        int prec = 1;
+        struct token *next = token->next;
+        const char *separator = "";
+        if (next->pos.whitespace)
+            separator = " ";
+        if (next->pos.newline) {
+            separator = "\n\t\t\t\t\t";
+            prec = next->pos.pos;
+            if (prec > 4)
+                prec = 4;
+        }
+        if (i == idx) 
+            fprintf(stderr,"@{%s}%.*s", show_token(token), prec, separator);
+        else
+            fprintf(stderr,"%s%.*s", show_token(token), prec, separator);
+        token = next;
+        i++;
+    }
+}
+
+void mdep_trace (struct token *tok, char *pre)
+{
+    void **v; int id; struct position pos = tok->pos;
+    struct pp_e *e; struct pp *p;
+    pre = pre ? pre : "";
+    if(!tok || eof_token (tok)) 
+        return;
+    while(1) {
+        if (pos.stream != pps) {
+            char *name = stream_name(pos.stream);
+            fprintf(stderr, "%s%s:%d:%d\n", pre,
+                    name, pos.line, pos.pos);
+            break;
+        } 
+        id = pos.line;
+        if (!(v = lookup_attr(id, ATTR_TOK, 0))) {
+            break;
+        }
+        e = (struct pp_e *)*v;
+        p = e->p;
+        fprintf(stderr, "%s",pre); 
+        if (p->t == MARG) {
+            fprintf(stderr,"arg%d in %s :", p->argi, show_token(p->tok));
+        } else {
+            fprintf(stderr,"body in %s :", show_token(p->tok));
+        }
+        mdep_show_tokenstream(p->d, 0,e->idx); fprintf (stderr,"\n");
+        pos = e->from;
+    }
+}
+
+/*
+Local Variables:
+c-basic-offset:4
+indent-tabs-mode:nil
+End:
+*/
diff --git a/pre-process.c b/pre-process.c
index fb3430a..4eee864 100644
--- a/pre-process.c
+++ b/pre-process.c
@@ -385,6 +385,7 @@ static void expand_arguments(int count, struct arg *args)
 		struct token *arg = args[i].arg;
 		if (!arg)
 			arg = &eof_token_entry;
+		args[i].expanded = &eof_token_entry;
 		if (args[i].n_str)
 			args[i].str = stringify(arg);
 		if (args[i].n_normal) {
@@ -661,7 +662,7 @@ static int expand(struct token **list, struct symbol *sym)
 	last = token->next;
 	tail = substitute(list, sym->expansion, args);
 	if (preprocess_hook && preprocess_hook->expand_macro)
-		preprocess_hook->expand_macro(token, sym, parent, list, tail);
+		preprocess_hook->expand_macro(token, sym, parent, list, tail, last);
 	*tail = last;
 
 	return 0;
diff --git a/test-macro.c b/test-macro.c
index b30ee50..3115bef 100644
--- a/test-macro.c
+++ b/test-macro.c
@@ -22,9 +22,9 @@
 static void expand_arg(struct token *macro, struct symbol *sym, int i, struct token *orig, struct token *expanded)
 {
 	printf("arg%d in %s :", i, show_token(macro));
-	show_tokenstream(orig);
+	show_tokenstream(orig, 0);
 	printf(" -> ");
-	show_tokenstream(expanded);
+	show_tokenstream(expanded, 0);
 	printf("\n");
 	
 }
@@ -35,7 +35,7 @@ static void expand_macro(struct token *macro, struct symbol *sym, struct token *
 	printf("macro %s inside", show_token(macro));
 	printf(" %s\n", show_token(parent));
 	printf("expand result: ");
-	show_tokenstream(*replace);
+	show_tokenstream(*replace, 0);
 	printf("\n");
 }
 
@@ -55,11 +55,11 @@ void test_macro(char *filename)
 		die("No such file: %s", filename);
 
 	token = tokenize(filename, fd, NULL, includepath);
-	show_tokenstream(token);
+	show_tokenstream(token, 0);
 	printf("\n");
 	token = preprocess(token);
 	printf("After preprocessing\n");
-	show_tokenstream(token);
+	show_tokenstream(token, 0);
 }
 
 int main(int argc, char **argv)
diff --git a/test-mdep.c b/test-mdep.c
new file mode 100644
index 0000000..eca0357
--- /dev/null
+++ b/test-mdep.c
@@ -0,0 +1,62 @@
+/*
+ * Parse and linearize the tree for testing.
+ *
+ * Copyright (C) 2012 Christophre Li
+ *
+ */
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "lib.h"
+#include "allocate.h"
+#include "token.h"
+#include "parse.h"
+#include "symbol.h"
+#include "expression.h"
+
+void test_mdep(char *filename)
+{
+    struct token *token;
+    int fd; int idx = 0;
+    fd = open(filename, O_RDONLY);
+    if (fd < 0)
+        die("No such file: %s", filename);
+	
+    token = tokenize(filename, fd, NULL, includepath);
+    token = preprocess(token);
+    printf("Dump token stream:\n");
+    
+    while (!eof_token(token)) {
+        struct token *next = token->next;
+        printf("%04d: %s\n", idx, show_token(token));
+        mdep_trace (token, "     ");
+        token = next; idx++;
+    }
+    
+}
+
+int main(int argc, char **argv)
+{
+    struct string_list *filelist = NULL;
+    char *file;
+
+    mdep_init();
+	
+    sparse_initialize(argc, argv, &filelist);
+    FOR_EACH_PTR_NOTAG(filelist, file) {
+        test_mdep(file);
+    } END_FOR_EACH_PTR_NOTAG(file);
+    return 0;
+}
+
+/*
+Local Variables:
+c-basic-offset:4
+indent-tabs-mode:nil
+End:
+*/
diff --git a/token.h b/token.h
index 985d1f5..8ddccd5 100644
--- a/token.h
+++ b/token.h
@@ -173,7 +173,7 @@ struct token {
 
 struct preprocess_hook {
 	void (*expand_macro)(struct token *macro, struct symbol *sym, struct token *parent,
-			     struct token **replace, struct token **replace_tail);
+			     struct token **replace, struct token **replace_tail, struct token *last);
 	void (*expand_arg)(struct token *macro, struct symbol *sym, int arg,
 			   struct token *orig, struct token *expanded);
 };
@@ -206,7 +206,7 @@ extern const char *show_special(int);
 extern const char *show_ident(const struct ident *);
 extern const char *show_string(const struct string *string);
 extern const char *show_token(const struct token *);
-extern void show_tokenstream(struct token *token);
+extern void show_tokenstream(struct token *token, struct token *end);
 extern struct token * tokenize(const char *, int, struct token *, const char **next_path);
 extern struct token * tokenize_buffer(void *, unsigned long, struct token **);
 
@@ -223,4 +223,8 @@ static inline int match_ident(struct token *token, struct ident *id)
 	return token->pos.type == TOKEN_IDENT && token->ident == id;
 }
 
+/* mdep.c */
+extern void mdep_init (void);
+extern void mdep_trace (struct token *tok, char *pre);
+
 #endif
diff --git a/tokenize.c b/tokenize.c
index b626f3f..6d0978f 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -127,6 +127,8 @@ const char *show_token(const struct token *token)
 
 	if (!token)
 		return "<no token>";
+	if (token == &eof_token_entry)
+		return "<eof>";
 	switch (token_type(token)) {
 	case TOKEN_ERROR:
 		return "syntax error";
@@ -180,9 +182,9 @@ const char *show_token(const struct token *token)
 	}
 }
 
-void show_tokenstream(struct token *token)
+void show_tokenstream(struct token *token, struct token *end)
 {
-	while (!eof_token(token)) {
+	while (token != end && !eof_token(token)) {
 		int prec = 1;
 		struct token *next = token->next;
 		const char *separator = "";
@@ -194,7 +196,7 @@ void show_tokenstream(struct token *token)
 			if (prec > 4)
 				prec = 4;
 		}
-		printf("%s%.*s", show_token(token), prec, separator);
+		fprintf(stderr,"%s%.*s", show_token(token), prec, separator);
 		token = next;
 	}
 }
-- 
1.7.4.4


--------------020101020406000100050005--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] simplify: conservative handling of casts with pointers ===

From: =?ISO-8859-1?Q?Jan_Pokorn=FD?= <pokorny_jan () seznam ! cz>
To: linux-sparse
Subject: Re: [PATCH] simplify: conservative handling of casts with pointers
Date: Thu, 10 May 2012 12:20:49 +0000
Message-ID: <4FABB2A1.4090503 () seznam ! cz>
--------------------
On 05/10/2012 12:42 PM, Christopher Li wrote:
> The early sparse back end does not care about preserve the
> ctype in the back end. The type has been simplify to bit size.
> So the pointer type conversion which has the same bit size,
> it does not need to generate any back end machine code
> e.g. x86 instruction to perform the conversion. I think that
> is why it is skipped.
> 
> The recent changes, especially the llvm back end care more
> about preserving the ctype in the back end instruction level.

As far as I can tell, the type can be recovered reliably, one way
or the other, and missing pointer cast was one of a few (if not
only one) source of type loss in the instruction stream (e.g., with
those pointers returned by function call as demonstrated).

> The patch is applied.

Thanks.

-- Jan
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse, llvm: 'Verify' the LLVM module before writing it ===

From: =?UTF-8?q?Jonathan=20Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: [PATCH] sparse, llvm: 'Verify' the LLVM module before writing it
Date: Sun, 19 Aug 2012 00:50:22 +0000
Message-ID: <1345337422-22094-1-git-send-email-j.neuschaefer () gmx ! net>
--------------------
In later versions sparse-llvm should stop on wrong llvm code, instead
of outputting it, but for now there are too many warnings being produced
for this to be feasible (I think).

Cc: Pekka Enberg <penberg@kernel.org>
Signed-off-by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
---
 sparse-llvm.c |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/sparse-llvm.c b/sparse-llvm.c
index 5bcc758..e02e212 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -5,6 +5,7 @@
 
 #include <llvm-c/Core.h>
 #include <llvm-c/BitWriter.h>
+#include <llvm-c/Analysis.h>
 
 #include <stdbool.h>
 #include <stdio.h>
@@ -1253,6 +1254,8 @@ int main(int argc, char **argv)
 		compile(module, sparse(file));
 	} END_FOR_EACH_PTR_NOTAG(file);
 
+	LLVMVerifyModule(module, LLVMPrintMessageAction, NULL);
+
 	LLVMWriteBitcodeToFD(module, STDOUT_FILENO, 0, 0);
 
 	LLVMDisposeModule(module);
-- 
1.7.10.4

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse, llvm: Fix 'void' return type code generation ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [PATCH] sparse, llvm: Fix 'void' return type code generation
Date: Sun, 19 Aug 2012 16:47:12 +0000
Message-ID: <50311890.2030801 () pobox ! com>
--------------------
On 08/19/2012 05:28 AM, Pekka Enberg wrote:
> Jonathan NeuschÃ¤fer reports:
>
>    A simple function like this will compile to the following llvm
>    bitcode:
>
>          /* C */
>          void func(void) {
>                  return;
>          }
>
>          /* LLVM */
>          define i8 @func() {
>          L0:
>            ret void
>          }
>
>    The return type of the function and the type in the return instruction
>    don't match.
>
>    I found this inconsistency by running LLVM's bitcode validation on the
>    bitcode produced by sparse-llvm.
>
> Move 'void *' special-casing from sym_basetype_type() to sym_ptr_type()
> to fix the issue.
>
> Reported by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
> Cc: Christopher Li <sparse@chrisli.org>
> Cc: Jeff Garzik <jgarzik@redhat.com>
> Cc: Linus Torvalds <torvalds@linux-foundation.org>
> Signed-off-by: Pekka Enberg <penberg@kernel.org>
> ---
>   sparse-llvm.c                         |   12 ++++++++++--
>   validation/backend/void-return-type.c |   13 +++++++++++++
>   2 files changed, 23 insertions(+), 2 deletions(-)
>   create mode 100644 validation/backend/void-return-type.c
>
> diff --git a/sparse-llvm.c b/sparse-llvm.c
> index e02e212..213d42d 100644
> --- a/sparse-llvm.c
> +++ b/sparse-llvm.c
> @@ -150,7 +150,13 @@ static LLVMTypeRef sym_union_type(LLVMModuleRef module, struct symbol *sym)
>
>   static LLVMTypeRef sym_ptr_type(LLVMModuleRef module, struct symbol *sym)
>   {
> -	LLVMTypeRef type = symbol_type(module, sym->ctype.base_type);
> +	LLVMTypeRef type;
> +
> +	/* 'void *' is treated like 'char *' */
> +	if (is_void_type(sym->ctype.base_type))
> +		type = LLVMInt8Type();
> +	else
> +		type = symbol_type(module, sym->ctype.base_type);
>
>   	return LLVMPointerType(type, 0);
>   }
> @@ -176,10 +182,12 @@ static LLVMTypeRef sym_basetype_type(struct symbol *sym)
>   		}
>   	} else {
>   		switch (sym->bit_size) {
> +		case -1:
> +			ret = LLVMVoidType();
> +			break;
>   		case 1:
>   			ret = LLVMInt1Type();
>   			break;
> -		case -1:	/* 'void *' is treated like 'char *' */
>   		case 8:
>   			ret = LLVMInt8Type();
>   			break;
> diff --git a/validation/backend/void-return-type.c b/validation/backend/void-return-type.c
> new file mode 100644
> index 0000000..b282fde
> --- /dev/null
> +++ b/validation/backend/void-return-type.c
> @@ -0,0 +1,13 @@
> +static void foo(void)
> +{
> +}
> +
> +static void *bar(void *p)
> +{
> +	return p;
> +}
> +

ACK the code...  would prefer that the first testcase included a 
"return;" just to be certain we get that right.

	Jeff




--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse, llvm: Fix SIGSEGV for extern symbols ===

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: [PATCH] sparse, llvm: Fix SIGSEGV for extern symbols
Date: Sun, 05 Aug 2012 19:47:34 +0000
Message-ID: <1344196054-17208-1-git-send-email-penberg () kernel ! org>
--------------------
Jonathan NeuschÃ¤fer writes:

  compiling a little real-world program with sparse-llvm, it segfaulted.
  Using a tool called "delta"[1] and some bash scripting, I managed to
  reduce the code to this test case:

    extern struct foo *foop;
    extern void func(struct foo *f);
    int main(int argc, char **argv) {
        func(foop);
    }

The problem is that pseudo_to_value() does not know abou the extern
symbol because Sparse never calls output_data() on it which registers
globals with LLVMAddGlobal().

As explained by Linus, 'extern' symbols are just names with types. They
don't have any value associated with them, they just have the type and
the name. Therefore we need to explicitly call LLVMAddGlobal() for
symbols we have not encountered in pseudo_to_value().

Reported by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
Cc: Christopher Li <sparse@chrisli.org>
Cc: Jeff Garzik <jgarzik@redhat.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Pekka Enberg <penberg@kernel.org>
---
 sparse-llvm.c               |    8 ++++++++
 validation/backend/extern.c |   11 +++++++++++
 2 files changed, 19 insertions(+), 0 deletions(-)
 create mode 100644 validation/backend/extern.c

diff --git a/sparse-llvm.c b/sparse-llvm.c
index 6b94205..5bcc758 100644
--- a/sparse-llvm.c
+++ b/sparse-llvm.c
@@ -335,6 +335,14 @@ static LLVMValueRef pseudo_to_value(struct function *fn, struct instruction *ins
 			default:
 				assert(0);
 			}
+		} else {
+			const char *name = show_ident(sym->ident);
+
+			result = LLVMGetNamedGlobal(fn->module, name);
+			if (!result) {
+				LLVMTypeRef type = symbol_type(fn->module, sym);
+				result = LLVMAddGlobal(fn->module, type, name);
+			}
 		}
 		break;
 	}
diff --git a/validation/backend/extern.c b/validation/backend/extern.c
new file mode 100644
index 0000000..24cbae5
--- /dev/null
+++ b/validation/backend/extern.c
@@ -0,0 +1,11 @@
+extern unsigned long foo;
+
+static unsigned long bar(void)
+{
+	return foo;
+}
+
+/*
+ * check-name: Extern symbol code generation
+ * check-command: ./sparsec -c $file -o tmp.o
+ */
-- 
1.7.7.6

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jonathan =?utf-8?Q?Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: Re: [PATCH] sparse, llvm: Fix SIGSEGV for extern symbols
Date: Sun, 19 Aug 2012 00:41:14 +0000
Message-ID: <20120819004114.GC2880 () debian ! debian>
--------------------
On Sun, Aug 05, 2012 at 10:47:34PM +0300, Pekka Enberg wrote:
> Jonathan NeuschÃ¤fer writes:
> 
>   compiling a little real-world program with sparse-llvm, it segfaulted.
>   Using a tool called "delta"[1] and some bash scripting, I managed to
>   reduce the code to this test case:
> 
>     extern struct foo *foop;
>     extern void func(struct foo *f);
>     int main(int argc, char **argv) {
>         func(foop);
>     }
> 
> The problem is that pseudo_to_value() does not know abou the extern
> symbol because Sparse never calls output_data() on it which registers
> globals with LLVMAddGlobal().
> 
> As explained by Linus, 'extern' symbols are just names with types. They
> don't have any value associated with them, they just have the type and
> the name. Therefore we need to explicitly call LLVMAddGlobal() for
> symbols we have not encountered in pseudo_to_value().
> 
> Reported by: Jonathan NeuschÃ¤fer <j.neuschaefer@gmx.net>
> Cc: Christopher Li <sparse@chrisli.org>
> Cc: Jeff Garzik <jgarzik@redhat.com>
> Cc: Linus Torvalds <torvalds@linux-foundation.org>
> Signed-off-by: Pekka Enberg <penberg@kernel.org>

This fixes the crash, thanks.

Jonathan
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] sparse: Add 'leaf' to ignored attributes. ===

From: Ethan Jackson <ethan () nicira ! com>
To: linux-sparse
Subject: [PATCH] sparse: Add 'leaf' to ignored attributes.
Date: Tue, 17 Jan 2012 22:47:11 +0000
Message-ID: <1326840431-27368-1-git-send-email-ethan () nicira ! com>
--------------------
This patch adds the 'leaf' GCC attribute to the list of ignored
attributes.  Glibc uses this attribute causing the following
warnings in userspace projects:

  /usr/include/stdlib.h:514:26: error: attribute '__leaf__': unknown attribute

Signed-off-by: Ethan Jackson <ethan@nicira.com>
---
 ident-list.h |    2 ++
 parse.c      |    2 ++
 2 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/ident-list.h b/ident-list.h
index b12d172..35ac6bd 100644
--- a/ident-list.h
+++ b/ident-list.h
@@ -88,6 +88,8 @@ IDENT(dllimport); IDENT(__dllimport__);
 IDENT(dllexport); IDENT(__dllexport__);
 IDENT(restrict); IDENT(__restrict);
 IDENT(artificial); IDENT(__artificial__);
+IDENT(leaf); IDENT(__leaf__);
+
 
 /* Preprocessor idents.  Direct use of __IDENT avoids mentioning the keyword
  * itself by name, preventing these tokens from expanding when compiling
diff --git a/parse.c b/parse.c
index bd42180..f8ade3e 100644
--- a/parse.c
+++ b/parse.c
@@ -519,6 +519,8 @@ const char *ignored_attributes[] = {
 	"__format_arg__",
 	"hot",
 	"__hot__",
+        "leaf",
+        "__leaf__",
 	"l1_text",
 	"__l1_text__",
 	"l1_data",
-- 
1.7.8.3

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add 'leaf' to ignored attributes.
Date: Wed, 18 Jan 2012 07:20:58 +0000
Message-ID: <CAOJsxLGNfSBZ9evmBaV6gN0rYorOUF85JJ9FNKXni01cvD1pVw () mail ! gmail ! com>
--------------------
On Wed, Jan 18, 2012 at 12:47 AM, Ethan Jackson <ethan@nicira.com> wrote:
> This patch adds the 'leaf' GCC attribute to the list of ignored
> attributes.  Glibc uses this attribute causing the following
> warnings in userspace projects:
>
>  /usr/include/stdlib.h:514:26: error: attribute '__leaf__': unknown attribute
>
> Signed-off-by: Ethan Jackson <ethan@nicira.com>

Acked-by: Pekka Enberg <penberg@kernel.org>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ethan Jackson <ethan () nicira ! com>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add 'leaf' to ignored attributes.
Date: Wed, 18 Jan 2012 16:58:40 +0000
Message-ID: <CAEruU62B_FHaiPg5L9jHHMh=Qi0_zQcCYyu_DxLUnSmtsNF5BA () mail ! gmail ! com>
--------------------
Thanks!

Ethan

On Wed, Jan 18, 2012 at 00:33, Christopher Li <sparse@chrisli.org> wrote:
> On Tue, Jan 17, 2012 at 11:20 PM, Pekka Enberg <penberg@kernel.org> wrote:
>> On Wed, Jan 18, 2012 at 12:47 AM, Ethan Jackson <ethan@nicira.com> wrote:
>>> This patch adds the 'leaf' GCC attribute to the list of ignored
>>> attributes.  Glibc uses this attribute causing the following
>>> warnings in userspace projects:
>>>
>>>  /usr/include/stdlib.h:514:26: error: attribute '__leaf__': unknown attribute
>>>
>>> Signed-off-by: Ethan Jackson <ethan@nicira.com>
>>
>> Acked-by: Pekka Enberg <penberg@kernel.org>
>
> Looks good to me too. Will apply.
>
> Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ethan Jackson <ethan () nicira ! com>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add 'leaf' to ignored attributes.
Date: Thu, 07 Jun 2012 23:01:13 +0000
Message-ID: <CAEruU60SVmewoByN8+oL1Tautf+R9t-zMUTGoN8bxPeAg-FWUA () mail ! gmail ! com>
--------------------
Hello, sorry to have left this hanging so long.  Out of curiosity, is
this still planned to be applied to the upstream tree?

Ethan

On Wed, Jan 18, 2012 at 8:58 AM, Ethan Jackson <ethan@nicira.com> wrote:
> Thanks!
>
> Ethan
>
> On Wed, Jan 18, 2012 at 00:33, Christopher Li <sparse@chrisli.org> wrote:
>> On Tue, Jan 17, 2012 at 11:20 PM, Pekka Enberg <penberg@kernel.org> wrote:
>>> On Wed, Jan 18, 2012 at 12:47 AM, Ethan Jackson <ethan@nicira.com> wrote:
>>>> This patch adds the 'leaf' GCC attribute to the list of ignored
>>>> attributes.  Glibc uses this attribute causing the following
>>>> warnings in userspace projects:
>>>>
>>>>  /usr/include/stdlib.h:514:26: error: attribute '__leaf__': unknown attribute
>>>>
>>>> Signed-off-by: Ethan Jackson <ethan@nicira.com>
>>>
>>> Acked-by: Pekka Enberg <penberg@kernel.org>
>>
>> Looks good to me too. Will apply.
>>
>> Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ethan Jackson <ethan () nicira ! com>
To: linux-sparse
Subject: Re: [PATCH] sparse: Add 'leaf' to ignored attributes.
Date: Sat, 09 Jun 2012 04:50:52 +0000
Message-ID: <CAEruU61yQ1b4_x5LA+vZ4HooAMggMGmwfB5DizF_NeGauC82wA () mail ! gmail ! com>
--------------------
Ah great, I'll clone from there for now on.  Thanks!

Ethan

On Fri, Jun 8, 2012 at 9:46 PM, Christopher Li <sparse@chrisli.org> wrote:
>
>
> On Thursday, June 7, 2012, Ethan Jackson wrote:
>>
>> Hello, sorry to have left this hanging so long.  Out of curiosity, is
>> this still planned to be applied to the upstream tree?
>
>
> Yes.
>
> Already apply to chrisl repository a while back.
>
> http://git.kernel.org/?p=devel/sparse/chrisl/sparse.git;a=commit;h=b0b4886be5f668959b8c75c9c811059e07b1073a
>
> Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] unssa: track use of newly added pseudo ===

From: =?ISO-8859-1?Q?Jan_Pokorn=FD?= <pokorny_jan () seznam ! cz>
To: linux-sparse
Subject: [PATCH] unssa: track use of newly added pseudo
Date: Thu, 03 May 2012 14:59:11 +0000
Message-ID: <4FA29D3F.3000905 () seznam ! cz>
--------------------
Currently, it is a completely "isolated island" from backend
point of view as it also lacks pseudo->def information.

Signed-off-by: Jan Pokorný <pokorny_jan@seznam.cz>
---
 unssa.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/unssa.c b/unssa.c
index 3eea9b2..382095d 100644
--- a/unssa.c
+++ b/unssa.c
@@ -55,7 +55,7 @@ static void replace_phi_node(struct instruction *phi)
 	track_phi_uses(phi);
 
 	phi->opcode = OP_COPY;
-	phi->src = tmp;
+	use_pseudo(phi, tmp, &phi->src);
 
 	// FIXME: free phi->phi_list;
 }
-- 
1.7.3.4
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] unssa: track use of newly added pseudo
Date: Thu, 03 May 2012 20:31:24 +0000
Message-ID: <CANeU7Q=LaKEp4RAPKmJUCCYpYNrAVTLeP56LwOE2Gu9oKWUBCQ () mail ! gmail ! com>
--------------------
On Thu, May 3, 2012 at 7:59 AM, Jan Pokorný <pokorny_jan@seznam.cz> wrote:
> Currently, it is a completely "isolated island" from backend
> point of view as it also lacks pseudo->def information.

Thanks, applied.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Thu, 02 Feb 2012 00:09:43 +0000
Message-ID: <CANeU7Q=3mA3sjaj+rV=79qZxM_bYxDBUdMV4dECHprpKzey1Lg () mail ! gmail ! com>
--------------------
On Wed, Feb 1, 2012 at 1:55 AM, Pekka Enberg <penberg@kernel.org> wrote:
> From: Linus Torvalds <torvalds@linux-foundation.org>
>
> On Tue, Aug 30, 2011 at 10:43 AM, Jeff Garzik <jeff@garzik.org> wrote:
>> * if someone knows how to access a function declaration, I can solve the
>> varargs problem
>
> Hmm. Right now we do not have access to the function declaration at
> linearize time. We've checked that the arguments match, and we've cast
> the arguments to the right types (evaluate.c), so the thinking was
> that you just use the arguments as-is.

Ok, this patch definitely works. However, I think there is ways to get the
type without this patch. The more general question is, how to get type of
any given pseudo register. Currently it is a bit twisted but that information
should be accessible. I believe that has been discuss on the mail list
before. That is why we have insn->type. LLVM want to know every type
of every value in the back end any way. If we are going to do proper
llvm style "get element pointer" in the back end, we need to access type
of every pesudo register.

The current twisted way to get type from the pseudo register is some thing like
this (totally untested code):

swtich (pseudo->type) {
     case PSEDUO_REG:
          return pseudo->def->type;
     case PSEUDO_ARG:
     case PSEUDO_SYMBOL:
          return psuedo->symbol;
     ....

}

Now think about it for a little bit, instead of this patch, how about
I make a counter RFC:

Move the insn->type into pseudo->type. Then you can use use
pseudo->type to access
the type of any pseudo. I estimate the memory usage should be similar,
if not smaller.
It make the pesudo struct larger, however, it make the insn struct
smaller. There is more
instruction than pesudo register in general, because not all
instruction resulting an output
pesudo register. Even consider some pseudo does not generate from
instructions, it is
likely a saving in memory foot print overall.

The plus side, you can have easy access of type for all pseudo. We
might able to get
rid of insn->size as well. Over all I feel it is cleaner.

Suggestions and feed back please?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Thu, 02 Feb 2012 01:03:29 +0000
Message-ID: <4F29E0E1.3000504 () garzik ! org>
--------------------
On 02/01/2012 07:09 PM, Christopher Li wrote:
> Ok, this patch definitely works. However, I think there is ways to get the
> type without this patch. The more general question is, how to get type of
> any given pseudo register.


That is useful, yes.  But it does not address this specific problem.

We need the function declaration remembered, rather than what we have 
now -- a list of arguments with full type information, specific to its 
callsite.

You cannot deduce that a function call is/not varargs presently, even 
with a working pseudo->type setup.

varargs is just one of those annoying areas where the compiler needs to 
have rather specific knowledge, in order to properly construct a call

	Jeff


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Benjamin Herrenschmidt <benh () kernel ! crashing ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Thu, 02 Feb 2012 01:22:04 +0000
Message-ID: <1328145724.28487.95.camel () pasglop>
--------------------
On Wed, 2012-02-01 at 20:03 -0500, Jeff Garzik wrote:
> On 02/01/2012 07:09 PM, Christopher Li wrote:
> > Ok, this patch definitely works. However, I think there is ways to get the
> > type without this patch. The more general question is, how to get type of
> > any given pseudo register.
> 
> 
> That is useful, yes.  But it does not address this specific problem.
> 
> We need the function declaration remembered, rather than what we have 
> now -- a list of arguments with full type information, specific to its 
> callsite.
> 
> You cannot deduce that a function call is/not varargs presently, even 
> with a working pseudo->type setup.
> 
> varargs is just one of those annoying areas where the compiler needs to 
> have rather specific knowledge, in order to properly construct a call

And there could be more. For example specific attributes on the
declaration may affect the ABI for the call (think asmlinkage or good
old pascal calling conventions on old macos :-)

Not something we absolutely need to sort out right now but another
reason why we really need to base the LLVM side definition based on the
declaration.

I'll try to toy a bit more this week-end see if the patches work for all
cases I can think of. We really have two different things (represented
by the two different hunks) which we might try to better factor:

The case of a function call where we are after the declaration, and the
case of creating an llvm type containing a function pointer (which can
happen as part of the first one if an argument is a function pointer)
for which we are looking at the base_type.

We should at least make it a single piece of code that takes a symbol
and shoots out a llvm ref.

Cheers,
Ben.


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Thu, 02 Feb 2012 01:22:47 +0000
Message-ID: <CANeU7Q=Dqtg8gyh2uoe4Md9s3_tVc1fAabmZy_fVo13ZwRYgGA () mail ! gmail ! com>
--------------------
On Wed, Feb 1, 2012 at 5:03 PM, Jeff Garzik <jeff@garzik.org> wrote:
> That is useful, yes.  But it does not address this specific problem.
>
> We need the function declaration remembered, rather than what we have now --
> a list of arguments with full type information, specific to its callsite.
>
> You cannot deduce that a function call is/not varargs presently, even with a
> working pseudo->type setup.

I am not trying do deduce function call/varargs from the call. I am
trying to get
it from call_insn->func->type directly. Similar to Linus' patch,
instead of store fntype
at call_insn->fntype, store it at call_insn->func->type directly. It should work
the similar way as Linus's patch, no?

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Thu, 02 Feb 2012 01:33:24 +0000
Message-ID: <CANeU7QnDStpUovGKpLdV1zw=jJc0X1LrdmeAS2x-e8xdX+J6og () mail ! gmail ! com>
--------------------
On Wed, Feb 1, 2012 at 5:22 PM, Benjamin Herrenschmidt
<benh@kernel.crashing.org> wrote:
> And there could be more. For example specific attributes on the
> declaration may affect the ABI for the call (think asmlinkage or good
> old pascal calling conventions on old macos :-)
>
> Not something we absolutely need to sort out right now but another
> reason why we really need to base the LLVM side definition based on the
> declaration.

Yes, that is what I am talking about too. Notice that insn->func is a pseudo
not a symbol. Pseudo can be result from another expression. That is my
suggestion in the counter RFC, put the full symbol type into pseudo->type.
You should have access of that information.

>
> I'll try to toy a bit more this week-end see if the patches work for all
> cases I can think of. We really have two different things (represented
> by the two different hunks) which we might try to better factor:
>
> The case of a function call where we are after the declaration, and the
> case of creating an llvm type containing a function pointer (which can
> happen as part of the first one if an argument is a function pointer)
> for which we are looking at the base_type.
>
> We should at least make it a single piece of code that takes a symbol
> and shoots out a llvm ref.

Do you mean take a pseudo then shoot out a llvm ref? The pseudo is
the more general form, a pseudo can come from symbol node or
expressions (function pointers).

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Benjamin Herrenschmidt <benh () kernel ! crashing ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Thu, 02 Feb 2012 01:50:19 +0000
Message-ID: <1328147419.28487.96.camel () pasglop>
--------------------
On Wed, 2012-02-01 at 17:33 -0800, Christopher Li wrote:
> 
> Do you mean take a pseudo then shoot out a llvm ref? The pseudo is
> the more general form, a pseudo can come from symbol node or
> expressions (function pointers). 

But in both cases the type itself is a struct symbol isn't it ? Either a
function def as Linus patch provides or base_type which is a struct
symbol too....

Sure if we have a consistent pseudo->type that covers both cases then we
can just pass that along, I don't mind.

Cheers,
Ben.


--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Thu, 02 Feb 2012 06:28:49 +0000
Message-ID: <alpine.LFD.2.02.1202020828210.1771 () tux ! localdomain>
--------------------
On Thu, 2 Feb 2012, Benjamin Herrenschmidt wrote:
> We also should probably store the LLVM Ref of the type once "converted"
> into the original struct symbol so that we don't have to re-create it or
> all the time (thinking especially of typedef'ed function pointers) or
> search for it by name (functions).

Agreed. We already do this for LLVMValueRefs which are stored in ->priv 
field of pseudo_t.
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Fri, 03 Feb 2012 09:09:37 +0000
Message-ID: <CAOJsxLHku6vzYbaOf9tPOY0VwMEcJ3Te63DYqvs+S2+-W9oFdA () mail ! gmail ! com>
--------------------
On Thu, Feb 2, 2012 at 4:10 AM, Christopher Li <sparse@chrisli.org> wrote:
> Yes, that is the point my counter RFC. When you look at it, the
> insn->fntype is really type of the insn->func pseudo. That is a one off
> thing for call instruction. Store type inside pseudo provide the same
> functionality and unify how to get type from pseudo.

Ping? I'd really like to have this bug fixed because it affects basic
"hello, world" on x86-64 and PPC.

                        Pekka
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Benjamin Herrenschmidt <benh () kernel ! crashing ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Fri, 03 Feb 2012 11:31:22 +0000
Message-ID: <1328268682.30631.1.camel () pasglop>
--------------------
On Fri, 2012-02-03 at 11:09 +0200, Pekka Enberg wrote:
> On Thu, Feb 2, 2012 at 4:10 AM, Christopher Li <sparse@chrisli.org> wrote:
> > Yes, that is the point my counter RFC. When you look at it, the
> > insn->fntype is really type of the insn->func pseudo. That is a one off
> > thing for call instruction. Store type inside pseudo provide the same
> > functionality and unify how to get type from pseudo.
> 
> Ping? I'd really like to have this bug fixed because it affects basic
> "hello, world" on x86-64 and PPC.

Yeah I don't know sparse well enough to have an informed preference of
one way vs. the other, so just pick one that works :-)


================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Sat, 04 Feb 2012 12:56:30 +0000
Message-ID: <alpine.LFD.2.02.1202041455230.1744 () tux ! localdomain>
--------------------
On Sat, 4 Feb 2012, Christopher Li wrote:
> Sorry I get really spaced. Can you continue apply that into your sparse-llvm
> repository?

Of course. Linus are you OK with the changes I did to your patch? Can I 
have your signoff before I merge it?

 			Pekka
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Sat, 04 Feb 2012 15:27:41 +0000
Message-ID: <CA+55aFzd1VPDWewi7d-3kPCo-5M6ZCbZBQrgYgFbPBf9Ao7PBg () mail ! gmail ! com>
--------------------
On Sat, Feb 4, 2012 at 4:56 AM, Pekka Enberg <penberg@kernel.org> wrote:
>
> Of course. Linus are you OK with the changes I did to your patch? Can I have
> your signoff before I merge it?

Sure, just add my signed-off, that patch is fine (nor do I mind the
other approach that makes it a type of a pseudo)

                Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 1/2] sparse, llvm: Make function declaration accessible to backend
Date: Sat, 04 Feb 2012 15:34:38 +0000
Message-ID: <alpine.LFD.2.02.1202041733480.4562 () tux ! localdomain>
--------------------
On Sat, Feb 4, 2012 at 4:56 AM, Pekka Enberg <penberg@kernel.org> wrote:
>> Of course. Linus are you OK with the changes I did to your patch? Can I have
>> your signoff before I merge it?

On Sat, 4 Feb 2012, Linus Torvalds wrote:
> Sure, just add my signed-off, that patch is fine (nor do I mind the
> other approach that makes it a type of a pseudo)

Applied and pushed. Ben, "hello world" should work for you in master now.

 			Pekka
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC/PATCH 2/2] sparse, llvm: Fix varargs functions ===

From: Jeff Garzik <jeff () garzik ! org>
To: linux-sparse
Subject: Re: [RFC/PATCH 2/2] sparse, llvm: Fix varargs functions
Date: Wed, 01 Feb 2012 13:58:19 +0000
Message-ID: <4F2944FB.7090905 () garzik ! org>
--------------------
On 02/01/2012 05:47 AM, Benjamin Herrenschmidt wrote:
> On Wed, 2012-02-01 at 11:55 +0200, Pekka Enberg wrote:
>> From: Benjamin Herrenschmidt<benh@kernel.crashing.org>
>>
>> We need to tell llvm about it or it won't generate the proper
>> stack frame&  argument list on some architectures.
>>
>> Cc: Christopher Li<sparse@chrisli.org>
>> Cc: Jeff Garzik<jgarzik@redhat.com>
>> Cc: Linus Torvalds<torvalds@linux-foundation.org>
>> Signed-off-by: Benjamin Herrenschmidt<benh@kernel.crashing.org>
>> [ penberg@kernel.org: Fix function pointer calls ]
>> Signed-off-by: Pekka Enberg<penberg@kernel.org>
>> ---
>>   sparse-llvm.c |    4 ++--
>>   1 files changed, 2 insertions(+), 2 deletions(-)
>>
>> diff --git a/sparse-llvm.c b/sparse-llvm.c
>> index a291a0d..9226a21 100644
>> --- a/sparse-llvm.c
>> +++ b/sparse-llvm.c
>> @@ -79,7 +79,7 @@ static LLVMTypeRef sym_func_type(LLVMModuleRef module, struct symbol *sym)
>>   		arg_type[idx++] = symbol_type(module, arg_sym);
>>   	} END_FOR_EACH_PTR(arg);
>>   	func_type = LLVMFunctionType(ret_type, arg_type, n_arg,
>> -				     /* varargs? */ 0);
>> +				     sym->ctype.base_type->variadic);
>>
>>   	return func_type;
>>   }
>
> Is the above hunk correct ? It was really just a guess, I haven't tested
> that code path :-)

I was wondering that, myself :)  Need coffee, then testing, I suppose :)

	Jeff




--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [RFC] evaluate: pointer arithmetics on plain void* (was: [PATCH] evaluate: reject post-ops on vo ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [RFC] evaluate: pointer arithmetics on plain void* (was: [PATCH] evaluate: reject post-ops on vo
Date: Tue, 24 Jan 2012 10:54:45 +0000
Message-ID: <CANeU7Q=jtJ=cVcgKdidA_8Fds3qVX980M_-Q0OkiiOvvo-MRBA () mail ! gmail ! com>
--------------------
On Mon, Jan 23, 2012 at 2:32 AM, Jan Pokorný <pokorny_jan@seznam.cz> wrote:
> Hm, I was talking about post-ops only, the example showed a failing pre-op
> ...both is a single case as evaluate_preop boils down to evaluate_postop.
>
> I went through evaluate.c again and I think these cases should be somehow
> unified (stating current state):

I am leaning towards make the explicit sizeof(void) as error.
Implicate sizeof(void) used in the pointer arithmetic are (optional) warnings.
The question is we give warning or not. Hmm.

However, forcing the type cast to get rid of the warning is very ugly.
"(void*)(++(char*)a)" is harder to read than "++a".

It is too late tonight for me to look at the patch right now. I will
take a closer look
tomorrow.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [problem] sparse llvm loop conditions ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Fwd: [problem] sparse llvm loop conditions
Date: Sun, 19 Aug 2012 17:21:23 +0000
Message-ID: <50312093.5050207 () pobox ! com>
--------------------
Here is a testcase that should get into the mailing list archives...

	Jeff




-------- Original Message --------
Subject: [problem] sparse llvm loop conditions
Date: Wed, 23 Nov 2011 08:56:25 +0200
From: Pekka Enberg <penberg@kernel.org>
To: Jeff Garzik <jeff@garzik.org>

Hi Jeff,

Have you seen this already?

[penberg@tux sparse]$ cat loop.c
struct list_node {
	struct list_node *next;
};

int foo(struct list_node *node)
{
	int ret = 0;
	while (node) {
		node = node->next;
		ret++;
	}
	return ret;
}
[penberg@tux sparse]$ ./sparse-llvm loop.c
loop.c:5:5: warning: symbol 'foo' was not declared. Should it be static?
sparse-llvm: Instructions.cpp:730: void llvm::BranchInst::AssertOK():
Assertion `getCondition()->getType()->isIntegerTy(1) && "May only
branch on boolean predicates!"' failed.
Aborted

                                 Pekka



--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: dependency tee from c parser entities downto token ===

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: dependency tee from c parser entities downto token
Date: Tue, 24 Apr 2012 09:54:45 +0000
Message-ID: <4F967865.60809 () gaisler ! com>
--------------------
Hi, I'd like to extend sparse so that I can preserve a
dependency tree that goes from c parse entities all
the way down to single tokens. There are several places
this can be useful:
  1. If you have :
    "#include <stdio.h> int main() {}"
    and add for instance
    "#include <stdio.h> int main() {FILE *f;}"
    what are the macros and structs that are used for this single "FILE *f;"?
    (With macros and all #ifdef nesting macros dependencies and their dependendies
     and macros in macro arg/body substitutions and also macros in c parse entities
     that FILE (struct _IO_FILE) c-depends on)
  2. If you have a compilation with a fixed options-line, calculate
    a minimal c sourcefile that is "pre pre-processor" that compiles correctly.
    This would save time in compilation, stripping away all unneeded
    macros defines and declarations.
  3. You could also use it to write tools to show the
    dependency tree of macros at a particular location of the source...
    something all c-coders long for (at least me :-).

For case (1.) I have created a dirty prototype that on sourceforge
does this

$git clone git://git.code.sf.net/p/decpp/code decpp
$cd decpp
$make
$./shrinkc t1.c

The output is below ("output of "shrinkc"").

Before I start to submit patches I'd like to as weather
there is there is interest for such a development, or better
weather there is interest of such a development if I do
the work, as maybe you rather want to do it yourself, I
also first ask because otherwise I'll put time in it
and none will apply the patches in the end anyway.

Here is how i'd do it:

- Try to not mess with basic structs like "struct token" etc.
   by adding a little hash based attibute tagging to void * pointers
   so that additional information can be stored for each sparse
   entity in seperate stuctures.
- modify pre-processor.c to not overwrite already created  tokens
   but instead duplicate them. Of course also avoid freeing tokens.
   Also preserve the undef/define history of macros (by not reusing
   the macro symbols)
- Buildup the macro dependency tree created from macros expansion
   and #if statements
- Tag all tokens with extra informations: macro dependency as well
   as source-stream end location (to be able to reconstruct).
- write a traversal that descends from translation-units through the
   dependency tree down to the tokens and marks them as used. Or maybe
   downto a "used-char" bitfield in streams.

Opon that, useful tools (as I think) could be built up.

-- Konrad



============= output of "shrinkc" ===============

eiselekd+~/tmp/>shrinkc t1.c

********* builtin *********


********* preprocessor *********


********* t1.c *********

int main(int argc, char **argv) {
         FILE *f;
};

********* preprocessor *********


********* /usr/include/stdio.h *********

#ifndef _STDIO_H
#if !defined __need_FILE && !defined __need___FILE
# define _STDIO_H       1
# define __need_FILE
# define __need___FILE
#endif /* Don't need FILE.  */
#if !defined __FILE_defined && defined __need_FILE
struct _IO_FILE;
typedef struct _IO_FILE FILE;
#endif /* FILE not defined.  */
#if !defined ____FILE_defined && defined __need___FILE
typedef struct _IO_FILE __FILE;
#endif /* __FILE not defined.  */
#ifdef  _STDIO_H

********* /usr/include/features.h *********


********* /usr/include/sys/cdefs.h *********


********* /usr/include/bits/wordsize.h *********


********* /usr/include/gnu/stubs.h *********


********* /usr/include/bits/wordsize.h *********


********* /usr/include/gnu/stubs-32.h *********


********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stddef.h *********

#endif
#endif

********* /usr/include/bits/types.h *********


********* /usr/include/bits/wordsize.h *********


********* /usr/include/bits/typesizes.h *********


********* /usr/include/libio.h *********

#ifndef _IO_STDIO_H
#ifdef _G_NEED_STDARG_H
#endif
# else
struct _IO_jump_t;  struct _IO_FILE;
# else
#else
typedef void _IO_lock_t;
#endif
struct _IO_marker {
   struct _IO_marker *_next;
   struct _IO_FILE *_sbuf;
   int _pos;
};
enum __codecvt_result
{
   __codecvt_ok,
   __codecvt_partial,
   __codecvt_error,
   __codecvt_noconv
};
struct _IO_FILE {
   int _flags;           /* High-order word is _IO_MAGIC; rest is flags. */
   char* _IO_read_ptr;   /* Current read pointer */
   char* _IO_read_end;   /* End of get area. */
   char* _IO_read_base;  /* Start of putback+get area. */
   char* _IO_write_base; /* Start of put area. */
   char* _IO_write_ptr;  /* Current put pointer. */
   char* _IO_write_end;  /* End of put area. */
   char* _IO_buf_base;   /* Start of reserve area. */
   char* _IO_buf_end;    /* End of reserve area. */
   char *_IO_save_base; /* Pointer to start of non-current get area. */
   char *_IO_backup_base;  /* Pointer to first valid character of backup area */
   char *_IO_save_end; /* Pointer to end of non-current get area. */
   struct _IO_marker *_markers;
   struct _IO_FILE *_chain;
   int _fileno;
#if 0
#else
   int _flags2;
#endif
   _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */
   unsigned short _cur_column;
   signed char _vtable_offset;
   char _shortbuf[1];
   _IO_lock_t *_lock;
#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001
   _IO_off64_t _offset;
# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
# else
   void *__pad1;
   void *__pad2;
   void *__pad3;
   void *__pad4;
   size_t __pad5;
# endif
   int _mode;
   char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
#endif
};
#endif /* _IO_STDIO_H */

********* /usr/include/_G_config.h *********

#ifndef _G_config_h
#define __need_mbstate_t
typedef struct
{
   __off_t __pos;
   __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
   __off64_t __pos;
   __mbstate_t __state;
} _G_fpos64_t;
#define _G_off_t        __off_t
#define _G_off64_t      __off64_t
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
#define _G_NEED_STDARG_H 1
#define _G_IO_IO_FILE_VERSION 0x20001

********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stddef.h *********

#endif
#endif
#endif
#endif /* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) */
#endif /* _STDDEF_H or __need_size_t.  */
#endif

********* /usr/include/wchar.h *********

#ifndef _WCHAR_H
#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__
# define __need_wint_t
#if (defined _WCHAR_H || defined __need_mbstate_t) && !defined __mbstate_t_defined
typedef struct
{
   int __count;
   union
   {
# ifdef __WINT_TYPE__
     __WINT_TYPE__ __wch;
# else
# endif
     char __wchb[4];
   } __value;            /* Value so far.  */
} __mbstate_t;
#endif
#endif /* ISO C99 or GCC and GNU.  */
#endif /* GCC and use GNU.  */
#endif /* Use ISO C95, C99 and Unix98. */
#endif
#endif
#endif  /* _WCHAR_H defined */
#endif /* wchar.h  */

********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stddef.h *********

#endif
#endif
#endif
#endif /* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) */
#endif /* _STDDEF_H or __need_size_t.  */
#endif
#endif
#endif /* __WCHAR_T__ */
#endif /* __wchar_t__ */
#endif /* _STDDEF_H or __need_wchar_t.  */
#if defined (__need_wint_t)
#ifndef _WINT_T
#ifndef __WINT_TYPE__
#define __WINT_TYPE__ unsigned int
#endif
typedef __WINT_TYPE__ wint_t;
#endif
#endif
#endif /* __sys_stdtypes_h */

********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stdarg.h *********

#ifndef _STDARG_H
#ifndef _ANSI_STDARG_H_
#ifndef __GNUC_VA_LIST
typedef __builtin_va_list __gnuc_va_list;
#endif
#else /* not __svr4__ || _SCO_DS */
#endif
#endif /* not _VA_LIST_, except on certain systems */
#endif /* not __svr4__ */
#endif /* _STDARG_H */
#endif /* not _ANSI_STDARG_H_ */
#endif /* not _STDARG_H */

********* /usr/include/bits/stdio_lim.h *********


********* /usr/include/bits/sys_errlist.h *********
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Mon, 30 Apr 2012 22:58:30 +0000
Message-ID: <CANeU7Qku=Zk3OfY3h45M+ecu11A6eTH0Y0+9wwj9Fmu8TyWwRw () mail ! gmail ! com>
--------------------
On Tue, Apr 24, 2012 at 2:54 AM, Konrad Eisele <konrad@gaisler.com> wrote:
> Hi, I'd like to extend sparse so that I can preserve a
> dependency tree that goes from c parse entities all
> the way down to single tokens. There are several places
> this can be useful:

Sorry for the delay. I take a some time to think about this problem.

May I ask some high level questions? I am trying to understand why
this this token level dependency is useful. One alternative is that,
you do a per-processor stage on the source file. Then you have one
big post processed source. The current sparse can run on that processed
source file and get all the symbol dependency.

Because each symbol has "pos" and "endpos" member. You only need
to recursively walk the ctype of the symbols you can get the shrink version
of the source code. The draw back with that is, all the macro has been
expended, you will not able to see the macro names etc.

Also, if you change the source file, the shrinking process has to be redone
because it might use new macros. So the shrinking + compiling is not
necessary a saving compare to directly compiling without the shrinking.
I figure you might have a slightly different usage module in mind to justify
the shrinking. Please help me understand how you intend to use it.

I think if the source file doesn't need pre-processing. Sparse can do symbol
dependency already. What you really want is actually being able to back
trace in the pre-processing stage, what macro has been expand and what
is the original form on the expanded value.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Mon, 30 Apr 2012 22:58:30 +0000
Message-ID: <CANeU7Qku=Zk3OfY3h45M+ecu11A6eTH0Y0+9wwj9Fmu8TyWwRw () mail ! gmail ! com>
--------------------
On Tue, Apr 24, 2012 at 2:54 AM, Konrad Eisele <konrad@gaisler.com> wrote:
> Hi, I'd like to extend sparse so that I can preserve a
> dependency tree that goes from c parse entities all
> the way down to single tokens. There are several places
> this can be useful:

Sorry for the delay. I take a some time to think about this problem.

May I ask some high level questions? I am trying to understand why
this this token level dependency is useful. One alternative is that,
you do a per-processor stage on the source file. Then you have one
big post processed source. The current sparse can run on that processed
source file and get all the symbol dependency.

Because each symbol has "pos" and "endpos" member. You only need
to recursively walk the ctype of the symbols you can get the shrink version
of the source code. The draw back with that is, all the macro has been
expended, you will not able to see the macro names etc.

Also, if you change the source file, the shrinking process has to be redone
because it might use new macros. So the shrinking + compiling is not
necessary a saving compare to directly compiling without the shrinking.
I figure you might have a slightly different usage module in mind to justify
the shrinking. Please help me understand how you intend to use it.

I think if the source file doesn't need pre-processing. Sparse can do symbol
dependency already. What you really want is actually being able to back
trace in the pre-processing stage, what macro has been expand and what
is the original form on the expanded value.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Wed, 02 May 2012 07:27:26 +0000
Message-ID: <CAEjhO7+EKvFHmpcFHrweGQEa4SHf62AAy5_SyhSxD1bcguafyw () mail ! gmail ! com>
--------------------
2012/5/1 Christopher Li <sparse@chrisli.org>:
> On Tue, Apr 24, 2012 at 2:54 AM, Konrad Eisele <konrad@gaisler.com> wrote:
>> Hi, I'd like to extend sparse so that I can preserve a
>> dependency tree that goes from c parse entities all
>> the way down to single tokens. There are several places
>> this can be useful:
>
> Sorry for the delay. I take a some time to think about this problem.
>
> May I ask some high level questions? I am trying to understand why
> this this token level dependency is useful. One alternative is that,
> you do a per-processor stage on the source file. Then you have one
> big post processed source. The current sparse can run on that processed
> source file and get all the symbol dependency.
>
> Because each symbol has "pos" and "endpos" member. You only need
> to recursively walk the ctype of the symbols you can get the shrink version
> of the source code. The draw back with that is, all the macro has been
> expended, you will not able to see the macro names etc.

But this is the point. All macros are expanded. They disappear completely in
the pre-processing step. There is no tool at all right now that
preserves the macro-dependency. Even in IDEs like Eclipse you have tools to show
macros expansions, but you have no tool to show you in a simple
way for i.e.:
#define a
#ifdef a
#define b 1
#endif
that "#define b 1" is dependent of "#define a" even the "#ifdef a" is
lost and you have to deduce it yourself from the #line comments.

I think not very many people know really how (not where) i.e. "size_t" gets
defined. There are too many "#ifdef" cases around, too many
#include.



>
> Also, if you change the source file, the shrinking process has to be redone
> because it might use new macros. So the shrinking + compiling is not
> necessary a saving compare to directly compiling without the shrinking.
> I figure you might have a slightly different usage module in mind to justify
> the shrinking. Please help me understand how you intend to use it.

Yes that is true. Still, for a fixed configuration in most cases you
can achieve a speedup. Also you would have a tool to really benchmark
source that doesnt draw in too much dependency.

>
> I think if the source file doesn't need pre-processing. Sparse can do symbol
> dependency already. What you really want is actually being able to back
> trace in the pre-processing stage, what macro has been expand and what
> is the original form on the expanded value.

The information for this is in "struct macro_expansion" of the patch and one can
build aroung it a trace of the macro expansion. I've done that with a patch for
gcc and could do it for sparse also. A example is at:
http://cfw.sourceforge.net/htmltag/init_32.c.pinfo.html
source at : http://cfw.sourceforge.net/htmltags.html
i.e. go in init_32.c.pinfo.html to mark_rodata_ro() and click on
virt_to_page (). A help in in the left pannel.

-- Konrad


>
> Chris
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Thu, 03 May 2012 23:52:18 +0000
Message-ID: <CANeU7QkWbvT-NN5vm=JXnmfDpbzNzTjNYxkB8GJsKCysiOe8tQ () mail ! gmail ! com>
--------------------
On Wed, May 2, 2012 at 12:27 AM, Konrad Eisele <eiselekd@gmail.com> wrote:
> But this is the point. All macros are expanded. They disappear completely in
> the pre-processing step. There is no tool at all right now that
> preserves the macro-dependency. Even in IDEs like Eclipse you have tools to show
> macros expansions, but you have no tool to show you in a simple
> way for i.e.:
> #define a
> #ifdef a
> #define b 1
> #endif
> that "#define b 1" is dependent of "#define a" even the "#ifdef a" is
> lost and you have to deduce it yourself from the #line comments.

Sure, so the usage case is mostly for people to understand how
the macro get expanded.

> The information for this is in "struct macro_expansion" of the patch and one can
> build aroung it a trace of the macro expansion. I've done that with a patch for
> gcc and could do it for sparse also. A example is at:
> http://cfw.sourceforge.net/htmltag/init_32.c.pinfo.html
> source at : http://cfw.sourceforge.net/htmltags.html
> i.e. go in init_32.c.pinfo.html to mark_rodata_ro() and click on
> virt_to_page (). A help in in the left pannel.

I agree this is useful. However I feel the original patch is a bit invasive.
How about do it in a step by step way. Make a small patch to allow register
call backs when the macro expands. That way the application using sparse
get notify of the pre-processor macro expands. I can take a look at how to
implement this small patch as well.

If needed, we can make one option that pre-processor don't free the tokens.
In this case, very few changes in the caller side. I feel it cleaner
than changing
the free function behavior.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Thu, 03 May 2012 23:52:18 +0000
Message-ID: <CANeU7QkWbvT-NN5vm=JXnmfDpbzNzTjNYxkB8GJsKCysiOe8tQ () mail ! gmail ! com>
--------------------
On Wed, May 2, 2012 at 12:27 AM, Konrad Eisele <eiselekd@gmail.com> wrote:
> But this is the point. All macros are expanded. They disappear completely in
> the pre-processing step. There is no tool at all right now that
> preserves the macro-dependency. Even in IDEs like Eclipse you have tools to show
> macros expansions, but you have no tool to show you in a simple
> way for i.e.:
> #define a
> #ifdef a
> #define b 1
> #endif
> that "#define b 1" is dependent of "#define a" even the "#ifdef a" is
> lost and you have to deduce it yourself from the #line comments.

Sure, so the usage case is mostly for people to understand how
the macro get expanded.

> The information for this is in "struct macro_expansion" of the patch and one can
> build aroung it a trace of the macro expansion. I've done that with a patch for
> gcc and could do it for sparse also. A example is at:
> http://cfw.sourceforge.net/htmltag/init_32.c.pinfo.html
> source at : http://cfw.sourceforge.net/htmltags.html
> i.e. go in init_32.c.pinfo.html to mark_rodata_ro() and click on
> virt_to_page (). A help in in the left pannel.

I agree this is useful. However I feel the original patch is a bit invasive.
How about do it in a step by step way. Make a small patch to allow register
call backs when the macro expands. That way the application using sparse
get notify of the pre-processor macro expands. I can take a look at how to
implement this small patch as well.

If needed, we can make one option that pre-processor don't free the tokens.
In this case, very few changes in the caller side. I feel it cleaner
than changing
the free function behavior.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 07:33:09 +0000
Message-ID: <4FA38635.5060300 () gaisler ! com>
--------------------
Christopher Li wrote:
> On Wed, May 2, 2012 at 12:27 AM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>> But this is the point. All macros are expanded. They disappear completely in
>> the pre-processing step. There is no tool at all right now that
>> preserves the macro-dependency. Even in IDEs like Eclipse you have tools to show
>> macros expansions, but you have no tool to show you in a simple
>> way for i.e.:
>> #define a
>> #ifdef a
>> #define b 1
>> #endif
>> that "#define b 1" is dependent of "#define a" even the "#ifdef a" is
>> lost and you have to deduce it yourself from the #line comments.
>
> Sure, so the usage case is mostly for people to understand how
> the macro get expanded.

Yes, and in a human readable way, that is, the output is from
before the pre-procesing step. Otherwise it is meaningless.

>
>> The information for this is in "struct macro_expansion" of the patch and one can
>> build aroung it a trace of the macro expansion. I've done that with a patch for
>> gcc and could do it for sparse also. A example is at:
>> http://cfw.sourceforge.net/htmltag/init_32.c.pinfo.html
>> source at : http://cfw.sourceforge.net/htmltags.html
>> i.e. go in init_32.c.pinfo.html to mark_rodata_ro() and click on
>> virt_to_page (). A help in in the left pannel.
>
> I agree this is useful. However I feel the original patch is a bit invasive.
> How about do it in a step by step way. Make a small patch to allow register
> call backs when the macro expands. That way the application using sparse
> get notify of the pre-processor macro expands. I can take a look at how to
> implement this small patch as well.
>
> If needed, we can make one option that pre-processor don't free the tokens.
> In this case, very few changes in the caller side. I feel it cleaner
> than changing
> the free function behavior.

The minimum original-code-base change that I see would be:
  - "struct position <pos>" is removed in all structures except "struct token" and
    replaced with "struct token *<tok>". When <pos> is needed <tok>->pos is
    used instead. This implies that tokens are not freed by default.
  - struct statement *, struct expression *, struct *token
    all get a extra "void *custom" pointer. This pointer can be used for
    tools to save their own data.
I think this is not too far off: 4 bytes more for each struct and  "<tok>->pos"
instead of "pos", that is not a massive change. the <tok>->pos would be
a boilerplate refactoring.

Should I implemnt a patch for that as a first step?

After that I can build upon that.

-- Konrad

Ps: I post again the link for my "shrinkc" app. I think
it is very impressive. I never had en overview about stdlib.h
and could see for that first time the dependencies for i.e.
FILE *f. Ok the ouput is still raw, "#include" lines are missing,
but still you can really see what is going on. And frankly,
isnt it strange that all c-programmers use stdlib.h without
really knowing what is going on? Maybe I am the only one that
has no clue though...
$git clone git://git.code.sf.net/p/decpp/code decpp
$cd decpp
$make
$./shrinkc t1.c



============= output of "shrinkc" ===============

eiselekd+~/tmp/>shrinkc t1.c

********* builtin *********


********* preprocessor *********


********* t1.c *********

int main(int argc, char **argv) {
         FILE *f;
};

********* preprocessor *********


********* /usr/include/stdio.h *********

#ifndef _STDIO_H
#if !defined __need_FILE && !defined __need___FILE
# define _STDIO_H       1
# define __need_FILE
# define __need___FILE
#endif /* Don't need FILE.  */
#if !defined __FILE_defined && defined __need_FILE
struct _IO_FILE;
typedef struct _IO_FILE FILE;
#endif /* FILE not defined.  */
#if !defined ____FILE_defined && defined __need___FILE
typedef struct _IO_FILE __FILE;
#endif /* __FILE not defined.  */
#ifdef  _STDIO_H

********* /usr/include/features.h *********


********* /usr/include/sys/cdefs.h *********


********* /usr/include/bits/wordsize.h *********


********* /usr/include/gnu/stubs.h *********


********* /usr/include/bits/wordsize.h *********


********* /usr/include/gnu/stubs-32.h *********


********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stddef.h *********

#endif
#endif

********* /usr/include/bits/types.h *********


********* /usr/include/bits/wordsize.h *********


********* /usr/include/bits/typesizes.h *********


********* /usr/include/libio.h *********

#ifndef _IO_STDIO_H
#ifdef _G_NEED_STDARG_H
#endif
# else
struct _IO_jump_t;  struct _IO_FILE;
# else
#else
typedef void _IO_lock_t;
#endif
struct _IO_marker {
   struct _IO_marker *_next;
   struct _IO_FILE *_sbuf;
   int _pos;
};
enum __codecvt_result
{
   __codecvt_ok,
   __codecvt_partial,
   __codecvt_error,
   __codecvt_noconv
};
struct _IO_FILE {
   int _flags;           /* High-order word is _IO_MAGIC; rest is flags. */
   char* _IO_read_ptr;   /* Current read pointer */
   char* _IO_read_end;   /* End of get area. */
   char* _IO_read_base;  /* Start of putback+get area. */
   char* _IO_write_base; /* Start of put area. */
   char* _IO_write_ptr;  /* Current put pointer. */
   char* _IO_write_end;  /* End of put area. */
   char* _IO_buf_base;   /* Start of reserve area. */
   char* _IO_buf_end;    /* End of reserve area. */
   char *_IO_save_base; /* Pointer to start of non-current get area. */
   char *_IO_backup_base;  /* Pointer to first valid character of backup area */
   char *_IO_save_end; /* Pointer to end of non-current get area. */
   struct _IO_marker *_markers;
   struct _IO_FILE *_chain;
   int _fileno;
#if 0
#else
   int _flags2;
#endif
   _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */
   unsigned short _cur_column;
   signed char _vtable_offset;
   char _shortbuf[1];
   _IO_lock_t *_lock;
#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001
   _IO_off64_t _offset;
# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
# else
   void *__pad1;
   void *__pad2;
   void *__pad3;
   void *__pad4;
   size_t __pad5;
# endif
   int _mode;
   char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
#endif
};
#endif /* _IO_STDIO_H */

********* /usr/include/_G_config.h *********

#ifndef _G_config_h
#define __need_mbstate_t
typedef struct
{
   __off_t __pos;
   __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
   __off64_t __pos;
   __mbstate_t __state;
} _G_fpos64_t;
#define _G_off_t        __off_t
#define _G_off64_t      __off64_t
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
#define _G_NEED_STDARG_H 1
#define _G_IO_IO_FILE_VERSION 0x20001

********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stddef.h *********

#endif
#endif
#endif
#endif /* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) */
#endif /* _STDDEF_H or __need_size_t.  */
#endif

********* /usr/include/wchar.h *********

#ifndef _WCHAR_H
#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__
# define __need_wint_t
#if (defined _WCHAR_H || defined __need_mbstate_t) && !defined __mbstate_t_defined
typedef struct
{
   int __count;
   union
   {
# ifdef __WINT_TYPE__
     __WINT_TYPE__ __wch;
# else
# endif
     char __wchb[4];
   } __value;            /* Value so far.  */
} __mbstate_t;
#endif
#endif /* ISO C99 or GCC and GNU.  */
#endif /* GCC and use GNU.  */
#endif /* Use ISO C95, C99 and Unix98. */
#endif
#endif
#endif  /* _WCHAR_H defined */
#endif /* wchar.h  */

********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stddef.h *********

#endif
#endif
#endif
#endif /* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) */
#endif /* _STDDEF_H or __need_size_t.  */
#endif
#endif
#endif /* __WCHAR_T__ */
#endif /* __wchar_t__ */
#endif /* _STDDEF_H or __need_wchar_t.  */
#if defined (__need_wint_t)
#ifndef _WINT_T
#ifndef __WINT_TYPE__
#define __WINT_TYPE__ unsigned int
#endif
typedef __WINT_TYPE__ wint_t;
#endif
#endif
#endif /* __sys_stdtypes_h */

********* /usr/lib/gcc/i486-slackware-linux/4.2.4//include/stdarg.h *********

#ifndef _STDARG_H
#ifndef _ANSI_STDARG_H_
#ifndef __GNUC_VA_LIST
typedef __builtin_va_list __gnuc_va_list;
#endif
#else /* not __svr4__ || _SCO_DS */
#endif
#endif /* not _VA_LIST_, except on certain systems */
#endif /* not __svr4__ */
#endif /* _STDARG_H */
#endif /* not _ANSI_STDARG_H_ */
#endif /* not _STDARG_H */

********* /usr/include/bits/stdio_lim.h *********


********* /usr/include/bits/sys_errlist.h *********


>
> Chris
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 09:25:47 +0000
Message-ID: <CANeU7QnVjEmZC2SNX-arWP7ovRx1mgNRyQSe7N2STGa-5u=i7A () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 12:33 AM, Konrad Eisele <konrad@gaisler.com> wrote:
>> I agree this is useful. However I feel the original patch is a bit
>> invasive.
>> How about do it in a step by step way. Make a small patch to allow
>> register
>> call backs when the macro expands. That way the application using sparse
>> get notify of the pre-processor macro expands. I can take a look at how to
>> implement this small patch as well.
>>
>> If needed, we can make one option that pre-processor don't free the
>> tokens.
>> In this case, very few changes in the caller side. I feel it cleaner
>> than changing
>> the free function behavior.
>
>
> The minimum original-code-base change that I see would be:
>  - "struct position <pos>" is removed in all structures except "struct
> token" and
>   replaced with "struct token *<tok>". When <pos> is needed <tok>->pos is
>   used instead. This implies that tokens are not freed by default.

No, that would be a no go. I don't mind allow dependence program
have the option to keep the token around. However, for other C back
ends, the token serve no purpose. It just sit there waste memory. So
I don't want the token become mandatory.

>  - struct statement *, struct expression *, struct *token
>   all get a extra "void *custom" pointer. This pointer can be used for
>   tools to save their own data.
> I think this is not too far off: 4 bytes more for each struct and
>  "<tok>->pos"
> instead of "pos", that is not a massive change. the <tok>->pos would be
> a boilerplate refactoring.

It is still too invasive. I don't want to keep <tok>->pos in the statements
and expression.

Instead, how about using the macro_expand I purposed in previous
email. Make dependence program a two step. The first step is pure
pre-processing, the dependants program using the macro_expand hook
to keep track of macro expand details. The end result is the pre-processed
file and the program remember how the file map into original file using the
macro expand history.

The the second step is just parsing on the pre-processed file. Using
the macro expand history to map the position back to the original file.
In this way, you can do your dependency analyse with minimal
impact to sparse internals. The macro_expand hook can use to
do other useful stuff as well. Will that address your need?

BTW, have you take a look at the ctags program come with sparse?
It can find symbols created by macro expansion as well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 09:25:47 +0000
Message-ID: <CANeU7QnVjEmZC2SNX-arWP7ovRx1mgNRyQSe7N2STGa-5u=i7A () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 12:33 AM, Konrad Eisele <konrad@gaisler.com> wrote:
>> I agree this is useful. However I feel the original patch is a bit
>> invasive.
>> How about do it in a step by step way. Make a small patch to allow
>> register
>> call backs when the macro expands. That way the application using sparse
>> get notify of the pre-processor macro expands. I can take a look at how to
>> implement this small patch as well.
>>
>> If needed, we can make one option that pre-processor don't free the
>> tokens.
>> In this case, very few changes in the caller side. I feel it cleaner
>> than changing
>> the free function behavior.
>
>
> The minimum original-code-base change that I see would be:
>  - "struct position <pos>" is removed in all structures except "struct
> token" and
>   replaced with "struct token *<tok>". When <pos> is needed <tok>->pos is
>   used instead. This implies that tokens are not freed by default.

No, that would be a no go. I don't mind allow dependence program
have the option to keep the token around. However, for other C back
ends, the token serve no purpose. It just sit there waste memory. So
I don't want the token become mandatory.

>  - struct statement *, struct expression *, struct *token
>   all get a extra "void *custom" pointer. This pointer can be used for
>   tools to save their own data.
> I think this is not too far off: 4 bytes more for each struct and
>  "<tok>->pos"
> instead of "pos", that is not a massive change. the <tok>->pos would be
> a boilerplate refactoring.

It is still too invasive. I don't want to keep <tok>->pos in the statements
and expression.

Instead, how about using the macro_expand I purposed in previous
email. Make dependence program a two step. The first step is pure
pre-processing, the dependants program using the macro_expand hook
to keep track of macro expand details. The end result is the pre-processed
file and the program remember how the file map into original file using the
macro expand history.

The the second step is just parsing on the pre-processed file. Using
the macro expand history to map the position back to the original file.
In this way, you can do your dependency analyse with minimal
impact to sparse internals. The macro_expand hook can use to
do other useful stuff as well. Will that address your need?

BTW, have you take a look at the ctags program come with sparse?
It can find symbols created by macro expansion as well.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 10:36:58 +0000
Message-ID: <4FA3B14A.3070609 () gaisler ! com>
--------------------
Christopher Li wrote:
> On Fri, May 4, 2012 at 12:33 AM, Konrad Eisele<konrad@gaisler.com>  wrote:
>>> I agree this is useful. However I feel the original patch is a bit
>>> invasive.
>>> How about do it in a step by step way. Make a small patch to allow
>>> register
>>> call backs when the macro expands. That way the application using sparse
>>> get notify of the pre-processor macro expands. I can take a look at how to
>>> implement this small patch as well.
>>>
>>> If needed, we can make one option that pre-processor don't free the
>>> tokens.
>>> In this case, very few changes in the caller side. I feel it cleaner
>>> than changing
>>> the free function behavior.
>>
>>
>> The minimum original-code-base change that I see would be:
>>   - "struct position<pos>" is removed in all structures except "struct
>> token" and
>>    replaced with "struct token *<tok>". When<pos>  is needed<tok>->pos is
>>    used instead. This implies that tokens are not freed by default.
>
> No, that would be a no go. I don't mind allow dependence program
> have the option to keep the token around. However, for other C back
> ends, the token serve no purpose. It just sit there waste memory. So
> I don't want the token become mandatory.

If it is a no-go it is a no-go.
If there is no need for the tool i proposed, there is no need. :-)
Still I try: Tokens dont sit around, they are released when
the program finishes. Treating the preprocessing stage
like nonexisting doesnt reflect the way most people use
a compiler. They always use the preprocessor even if
there might be the possibility to use the compiler with only
a preprocessed file. Therefore tokens should sit around.

>
>>   - struct statement *, struct expression *, struct *token
>>    all get a extra "void *custom" pointer. This pointer can be used for
>>    tools to save their own data.
>> I think this is not too far off: 4 bytes more for each struct and
>>   "<tok>->pos"
>> instead of "pos", that is not a massive change. the<tok>->pos would be
>> a boilerplate refactoring.
>
> It is still too invasive. I don't want to keep<tok>->pos in the statements
> and expression.

If this is invasive a little less than this would mean no change at
all.

>
> Instead, how about using the macro_expand I purposed in previous
> email. Make dependence program a two step. The first step is pure
> pre-processing, the dependants program using the macro_expand hook
> to keep track of macro expand details. The end result is the pre-processed
> file and the program remember how the file map into original file using the
> macro expand history.
>
> The the second step is just parsing on the pre-processed file. Using
> the macro expand history to map the position back to the original file.
> In this way, you can do your dependency analyse with minimal
> impact to sparse internals. The macro_expand hook can use to
> do other useful stuff as well. Will that address your need?

Thats not what I want, but rather what you want. If you
want a macro expand history, it would be faster, easier simpler
if you would hack it yourself, I dont want a macro expand,
i have my tool htmltag for that already. I want a macro dependency tree.
With only macro_expand hook and only file-scope <pos> it is not
possible.
And: until I would have come up with something that would fit your requirements
months would be gone. It seems that you know exactly how
it should  be done, there is no way for me to know how
you think a noninvasive solution would look like. The communication
takes too long.

If there is no need for the tool i proposed, there is no need.
At least I tried :-)

-- Thanks Konrad

>
> BTW, have you take a look at the ctags program come with sparse?
> It can find symbols created by macro expansion as well.
>
> Chris
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <konrad () gaisler ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 10:36:58 +0000
Message-ID: <4FA3B14A.3070609 () gaisler ! com>
--------------------
Christopher Li wrote:
> On Fri, May 4, 2012 at 12:33 AM, Konrad Eisele<konrad@gaisler.com>  wrote:
>>> I agree this is useful. However I feel the original patch is a bit
>>> invasive.
>>> How about do it in a step by step way. Make a small patch to allow
>>> register
>>> call backs when the macro expands. That way the application using sparse
>>> get notify of the pre-processor macro expands. I can take a look at how to
>>> implement this small patch as well.
>>>
>>> If needed, we can make one option that pre-processor don't free the
>>> tokens.
>>> In this case, very few changes in the caller side. I feel it cleaner
>>> than changing
>>> the free function behavior.
>>
>>
>> The minimum original-code-base change that I see would be:
>>   - "struct position<pos>" is removed in all structures except "struct
>> token" and
>>    replaced with "struct token *<tok>". When<pos>  is needed<tok>->pos is
>>    used instead. This implies that tokens are not freed by default.
>
> No, that would be a no go. I don't mind allow dependence program
> have the option to keep the token around. However, for other C back
> ends, the token serve no purpose. It just sit there waste memory. So
> I don't want the token become mandatory.

If it is a no-go it is a no-go.
If there is no need for the tool i proposed, there is no need. :-)
Still I try: Tokens dont sit around, they are released when
the program finishes. Treating the preprocessing stage
like nonexisting doesnt reflect the way most people use
a compiler. They always use the preprocessor even if
there might be the possibility to use the compiler with only
a preprocessed file. Therefore tokens should sit around.

>
>>   - struct statement *, struct expression *, struct *token
>>    all get a extra "void *custom" pointer. This pointer can be used for
>>    tools to save their own data.
>> I think this is not too far off: 4 bytes more for each struct and
>>   "<tok>->pos"
>> instead of "pos", that is not a massive change. the<tok>->pos would be
>> a boilerplate refactoring.
>
> It is still too invasive. I don't want to keep<tok>->pos in the statements
> and expression.

If this is invasive a little less than this would mean no change at
all.

>
> Instead, how about using the macro_expand I purposed in previous
> email. Make dependence program a two step. The first step is pure
> pre-processing, the dependants program using the macro_expand hook
> to keep track of macro expand details. The end result is the pre-processed
> file and the program remember how the file map into original file using the
> macro expand history.
>
> The the second step is just parsing on the pre-processed file. Using
> the macro expand history to map the position back to the original file.
> In this way, you can do your dependency analyse with minimal
> impact to sparse internals. The macro_expand hook can use to
> do other useful stuff as well. Will that address your need?

Thats not what I want, but rather what you want. If you
want a macro expand history, it would be faster, easier simpler
if you would hack it yourself, I dont want a macro expand,
i have my tool htmltag for that already. I want a macro dependency tree.
With only macro_expand hook and only file-scope <pos> it is not
possible.
And: until I would have come up with something that would fit your requirements
months would be gone. It seems that you know exactly how
it should  be done, there is no way for me to know how
you think a noninvasive solution would look like. The communication
takes too long.

If there is no need for the tool i proposed, there is no need.
At least I tried :-)

-- Thanks Konrad

>
> BTW, have you take a look at the ctags program come with sparse?
> It can find symbols created by macro expansion as well.
>
> Chris
> --
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 12:36:40 +0000
Message-ID: <4FA3CD58.80809 () gmail ! com>
--------------------
>>
>> No, that would be a no go. I don't mind allow dependence program
>> have the option to keep the token around. However, for other C back
>> ends, the token serve no purpose. It just sit there waste memory. So
>> I don't want the token become mandatory.
>

Ok, one more try:
   Your question is: Why is is meaningful to
   have tokens saved even in the parse stage.
I tried to come up with some meaningful example.

Take the 2 files b.c and a.h.

vvvvvv b.c vvvvv
#define d1
#include "a.h"
struct s0 { int x; };
int main(int a, char **b) {
   struct s0 v;
   d2(m);
};
^^^^^^ b.c ^^^^^^

vvvvvv a.h vvvvv
#ifdef d2
#define m v
#else
#define m n
#endif

#ifdef d1
#define d2(a) while(a.x) { }
#endif
^^^^^^ a.h ^^^^^^

Now use sparse and you get:
$./sparse b.c
b.c:6:3: error: cannot dereference this type

The error was that you forgot in b.c:
+#define d2
  #define d1
  ...

When you have a dependency tree what you can printout is:

$./sparse b.c
b.c:6:3: error: cannot dereference this type
  +macro expansion of d2 defined in a.h:8
    + defined because of #ifdef d1 in a.h:7
     + dependent of d1 defined at b.c:1
  +> argument 0 expansion at b.c:6
    + macro expansion m defined in a.h:4
      + defined because of else of #ifdef d2
        + dependend of d2 (not defined)

Or you can print it out human readable:

$./sparse b.c
b.c:6:3: error: cannot dereference this type
#define d1
#include "a.h"
  #ifdef d2
  #else
  #define m n
  #endif
  #ifdef d1
  #define d2(a) while(a.x) { }
  #endif

I've improviced a bit, the "human readable" ouput
is the whole of a.h and b.c because there is
no nondependent part to strip...

Now tell me that this is not useful and this is the
last post on this subject. Dont you think that gcc's
...
  In file included from ./b.c:3:0:
  In file included from ./x.c13:0:
...
is useful? With macro dependency saved you can
printout all.

-- Konrad




--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 12:36:40 +0000
Message-ID: <4FA3CD58.80809 () gmail ! com>
--------------------
>>
>> No, that would be a no go. I don't mind allow dependence program
>> have the option to keep the token around. However, for other C back
>> ends, the token serve no purpose. It just sit there waste memory. So
>> I don't want the token become mandatory.
>

Ok, one more try:
   Your question is: Why is is meaningful to
   have tokens saved even in the parse stage.
I tried to come up with some meaningful example.

Take the 2 files b.c and a.h.

vvvvvv b.c vvvvv
#define d1
#include "a.h"
struct s0 { int x; };
int main(int a, char **b) {
   struct s0 v;
   d2(m);
};
^^^^^^ b.c ^^^^^^

vvvvvv a.h vvvvv
#ifdef d2
#define m v
#else
#define m n
#endif

#ifdef d1
#define d2(a) while(a.x) { }
#endif
^^^^^^ a.h ^^^^^^

Now use sparse and you get:
$./sparse b.c
b.c:6:3: error: cannot dereference this type

The error was that you forgot in b.c:
+#define d2
  #define d1
  ...

When you have a dependency tree what you can printout is:

$./sparse b.c
b.c:6:3: error: cannot dereference this type
  +macro expansion of d2 defined in a.h:8
    + defined because of #ifdef d1 in a.h:7
     + dependent of d1 defined at b.c:1
  +> argument 0 expansion at b.c:6
    + macro expansion m defined in a.h:4
      + defined because of else of #ifdef d2
        + dependend of d2 (not defined)

Or you can print it out human readable:

$./sparse b.c
b.c:6:3: error: cannot dereference this type
#define d1
#include "a.h"
  #ifdef d2
  #else
  #define m n
  #endif
  #ifdef d1
  #define d2(a) while(a.x) { }
  #endif

I've improviced a bit, the "human readable" ouput
is the whole of a.h and b.c because there is
no nondependent part to strip...

Now tell me that this is not useful and this is the
last post on this subject. Dont you think that gcc's
...
  In file included from ./b.c:3:0:
  In file included from ./x.c13:0:
...
is useful? With macro dependency saved you can
printout all.

-- Konrad




--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 18:02:06 +0000
Message-ID: <CANeU7Q=5T2aV2NBwoC5hgtYHaNR1ndELtyy6t-s7C1bNgdTT0A () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 3:36 AM, Konrad Eisele <konrad@gaisler.com> wrote:
> If it is a no-go it is a no-go.
> If there is no need for the tool i proposed, there is no need. :-)

I think you miss my point.  It is two separate thing. I already
confirm your macro dependency is useful. I want sparse
to support it.

My suggestion is merely how to support it. You purpose
embed the token inside AST. I purpose allow a macro_expand
call back hook.


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 18:02:06 +0000
Message-ID: <CANeU7Q=5T2aV2NBwoC5hgtYHaNR1ndELtyy6t-s7C1bNgdTT0A () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 3:36 AM, Konrad Eisele <konrad@gaisler.com> wrote:
> If it is a no-go it is a no-go.
> If there is no need for the tool i proposed, there is no need. :-)

I think you miss my point.  It is two separate thing. I already
confirm your macro dependency is useful. I want sparse
to support it.

My suggestion is merely how to support it. You purpose
embed the token inside AST. I purpose allow a macro_expand
call back hook.


================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 21:46:37 +0000
Message-ID: <4FA44E3D.6020504 () gmail ! com>
--------------------
>
> I think you miss my point.  It is two separate thing. I already
> confirm your macro dependency is useful. I want sparse
> to support it.
>

Nice to hear this.
When I talk about macro dependency I mean not only the
macro expansion trace. I mean:
  1. The #if (and #include) nestings (with dependencies
     pointing to the macros used in the proprocessor line)
  2. The macro expansion trace
  3. The connection 1+2 into the AST.
Your macro_expand() hook addresses (2) only, but I cant
see how all the extra context for each token can be saved
in that sheme.
In my patch I have modeled (2) using 2 structs:
struct macro_expansion {
	int nargs;
	struct symbol *sym;
	struct token *m;
	struct arg args[0];
};
struct tok_macro_dep {
	struct macro_expansion *m;
	unsigned int argi;
	unsigned int isbody : 1;
	unsigned int visited : 1;
};
Each token from a macro expansion gets tagged with
tok_macro_dep. If it is an macro argument, <argi> shows the
index, if it is from the macro body <isbody> is 1.
Now, I didnt already think about special cases like
token concaternation, even more data is needed to
model this. Also when an macro argument is again used as an
macro argument inside the body expansion, then I kindof
loose the chain: I would also need a "token *dup_of" pointer
to point to the original token that the token is a copy
of (when arguments are created...) etc.

I have read your macro_expand() hook idea, however
when I understand it right you want to reuse position.stream and
position.line as a kind of pointer (to save the extra 4 bytes).
(Your goal is to minimize codebase change, however I wonder
weather you dont change semantic of struct position and then
need to change the code that uses struct position anyway...)
Maybe it is possible like this...I doubt it, where should
all the extra context, that each token has, be saved and
extracted from? using that sheme...

Maybe it is possible but I dont want to have as a design
goal to save 4 bytes (I'd use the void *custom sheme to
save all my extra data, also the pointers to tokens to
"sit around") and adujust everything else to
that. The consequence is that the code-complexity would
grow on the other end.

Here is my compromise then:
Keep the orignial "pos". But still grant me for
each struct a "void *custom" pointer that I can use
to store extradata i.e. pointer to token.

-- Konrad

> My suggestion is merely how to support it. You purpose
> embed the token inside AST. I purpose allow a macro_expand
> call back hook.
>
>> From my point of view, I can see using the macro_expand
> call back hook to accomplish the same macro dependency
> analyse, without significant impact the sparse internals.
>
> If you think the macro_expend hook is not good enough,
> please let me know where it is not sufficient.
>
>> Still I try: Tokens dont sit around, they are released when
>> the program finishes. Treating the preprocessing stage
>> like nonexisting doesnt reflect the way most people use
>> a compiler. They always use the preprocessor even if
>> there might be the possibility to use the compiler with only
>> a preprocessed file. Therefore tokens should sit around.
>
> Yes token should sit around for your macro dependency
> analyse. But I like it to be an option rather hard code the
> token in the to the AST. Sparse is a library, there are several
> program use it.
>
> I see a way to allow your do want you want to do on the
> macro dependency while not impact other program. Why
> not give it a try? The point is, I don't see it is necessary
> to force every one accept the expr->tok->pos. It is straightly
> worse for program that don't care about the macro expand
> dependency. As long as you can accomplish the same
> dependency analyse, why do you care it is using the
> "embed token" approach rather than macro_expand hook?
>
>>> It is still too invasive. I don't want to keep<tok>->pos in the statements
>>> and expression.
>>
>>
>> If this is invasive a little less than this would mean no change at
>> all.
>
> Yes, it would be no change at all from the AST point of view if
> we use the macro_expand hook. You just need to maintain
> a hash table from old<pos>  to new<pos>  mapping with the
> additional dependency information. You don't even need to
> generate the pre-processed file explicitly. I am using that as
> the thinking process how to get there.
>
>>> The the second step is just parsing on the pre-processed file. Using
>>> the macro expand history to map the position back to the original file.
>>> In this way, you can do your dependency analyse with minimal
>>> impact to sparse internals. The macro_expand hook can use to
>>> do other useful stuff as well. Will that address your need?
>>
>>
>> Thats not what I want, but rather what you want. If you
>> want a macro expand history, it would be faster, easier simpler
>> if you would hack it yourself, I dont want a macro expand,
>> i have my tool htmltag for that already. I want a macro dependency tree.
>> With only macro_expand hook and only file-scope<pos>  it is not
>> possible.
>
> Nope, it is possible, that is what I am purposing. Sorry I previous
> explain has been very high level, I haven't explain in the implementation
> detail of every stage.
>
> So the first patch would be adding the macro_expand hook into sparse.
> After a pre-processor macro expend, it will call the the macro_expand
> hook if the user register one. (the hook is not NULL).
>
> In the macro_expand hook, it will receive:
> - macro before the expand,
> - args for the macro
> - replacement tokens after the expand.
>
> This will give your macro dependency program a chance to
> exam and manipulate the token before it get insert back
> to original token list.
>
>
> Here is how your macro dependency program can use the
> macro_expand hook.
>
> The program should create a internal stream call "<pre-processor>".
> The content of the file is just the result of macro expand. One
> macro at a line, the the order they are expanded. You can use the
> pos->line to index when macro expand it is. Notice that you don't
> need to actually write out the stream into disk.
>
> Then, inside the macro_expand hook that receive the macro
> expand call back.
>
> There will be an array of data structure keep track of the
> macro expand. The first macro expand is on the first element
> of the array. Let's call this data structure "struct macro_deps".
>
> Inside "struct macro_deps", it will keep track of the original
> macro before the expand. The list of the tokens it depends on.
> That is your dependency information.
>
> It will allocate one "struct macro_deps" and fill it out, append
> to the end of the array.
>
> Before you macro_expand hook return, it walk the replacement
> token. For each "token->pos" in the replacement token, it will
> replace the stream number to to "pre-processor", and line number
> to the index of the "struct macro_deps" in the array. Before the
> replacement, if the original stream is already "<pre-processor>",
> that means you are expanding the result from another macro expand.
> Using the old pos->line to look up the inner macro expand, add
> inner macro's dependency list into the current macro dependency list.
>
> Then after the pre-processor stage. All the token from macro
> expand will look as if they are expand from the "pre-processor"
> file, line number can be use as index to lookup the array to find
> out the detail of this macro expand.
>
> Will that work for your dependency file. I notice that it not 100%
> the same with your dependency, but with the intact history. You
> should able to find that out.
>
>> And: until I would have come up with something that would fit your
>> requirements
>> months would be gone. It seems that you know exactly how
>> it should  be done, there is no way for me to know how
>> you think a noninvasive solution would look like. The communication
>> takes too long.
>
> So here it is. I already give you the details of the implementation.
> Of course, the first step for macro_expand hook is much smaller
> scope. Please let me know that works or not.
>
>>
>> If there is no need for the tool i proposed, there is no need.
>> At least I tried :-)
>
> I already confirm that is useful. Just how to implement it.
>
> Chris
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 21:46:37 +0000
Message-ID: <4FA44E3D.6020504 () gmail ! com>
--------------------
>
> I think you miss my point.  It is two separate thing. I already
> confirm your macro dependency is useful. I want sparse
> to support it.
>

Nice to hear this.
When I talk about macro dependency I mean not only the
macro expansion trace. I mean:
  1. The #if (and #include) nestings (with dependencies
     pointing to the macros used in the proprocessor line)
  2. The macro expansion trace
  3. The connection 1+2 into the AST.
Your macro_expand() hook addresses (2) only, but I cant
see how all the extra context for each token can be saved
in that sheme.
In my patch I have modeled (2) using 2 structs:
struct macro_expansion {
	int nargs;
	struct symbol *sym;
	struct token *m;
	struct arg args[0];
};
struct tok_macro_dep {
	struct macro_expansion *m;
	unsigned int argi;
	unsigned int isbody : 1;
	unsigned int visited : 1;
};
Each token from a macro expansion gets tagged with
tok_macro_dep. If it is an macro argument, <argi> shows the
index, if it is from the macro body <isbody> is 1.
Now, I didnt already think about special cases like
token concaternation, even more data is needed to
model this. Also when an macro argument is again used as an
macro argument inside the body expansion, then I kindof
loose the chain: I would also need a "token *dup_of" pointer
to point to the original token that the token is a copy
of (when arguments are created...) etc.

I have read your macro_expand() hook idea, however
when I understand it right you want to reuse position.stream and
position.line as a kind of pointer (to save the extra 4 bytes).
(Your goal is to minimize codebase change, however I wonder
weather you dont change semantic of struct position and then
need to change the code that uses struct position anyway...)
Maybe it is possible like this...I doubt it, where should
all the extra context, that each token has, be saved and
extracted from? using that sheme...

Maybe it is possible but I dont want to have as a design
goal to save 4 bytes (I'd use the void *custom sheme to
save all my extra data, also the pointers to tokens to
"sit around") and adujust everything else to
that. The consequence is that the code-complexity would
grow on the other end.

Here is my compromise then:
Keep the orignial "pos". But still grant me for
each struct a "void *custom" pointer that I can use
to store extradata i.e. pointer to token.

-- Konrad

> My suggestion is merely how to support it. You purpose
> embed the token inside AST. I purpose allow a macro_expand
> call back hook.
>
>> From my point of view, I can see using the macro_expand
> call back hook to accomplish the same macro dependency
> analyse, without significant impact the sparse internals.
>
> If you think the macro_expend hook is not good enough,
> please let me know where it is not sufficient.
>
>> Still I try: Tokens dont sit around, they are released when
>> the program finishes. Treating the preprocessing stage
>> like nonexisting doesnt reflect the way most people use
>> a compiler. They always use the preprocessor even if
>> there might be the possibility to use the compiler with only
>> a preprocessed file. Therefore tokens should sit around.
>
> Yes token should sit around for your macro dependency
> analyse. But I like it to be an option rather hard code the
> token in the to the AST. Sparse is a library, there are several
> program use it.
>
> I see a way to allow your do want you want to do on the
> macro dependency while not impact other program. Why
> not give it a try? The point is, I don't see it is necessary
> to force every one accept the expr->tok->pos. It is straightly
> worse for program that don't care about the macro expand
> dependency. As long as you can accomplish the same
> dependency analyse, why do you care it is using the
> "embed token" approach rather than macro_expand hook?
>
>>> It is still too invasive. I don't want to keep<tok>->pos in the statements
>>> and expression.
>>
>>
>> If this is invasive a little less than this would mean no change at
>> all.
>
> Yes, it would be no change at all from the AST point of view if
> we use the macro_expand hook. You just need to maintain
> a hash table from old<pos>  to new<pos>  mapping with the
> additional dependency information. You don't even need to
> generate the pre-processed file explicitly. I am using that as
> the thinking process how to get there.
>
>>> The the second step is just parsing on the pre-processed file. Using
>>> the macro expand history to map the position back to the original file.
>>> In this way, you can do your dependency analyse with minimal
>>> impact to sparse internals. The macro_expand hook can use to
>>> do other useful stuff as well. Will that address your need?
>>
>>
>> Thats not what I want, but rather what you want. If you
>> want a macro expand history, it would be faster, easier simpler
>> if you would hack it yourself, I dont want a macro expand,
>> i have my tool htmltag for that already. I want a macro dependency tree.
>> With only macro_expand hook and only file-scope<pos>  it is not
>> possible.
>
> Nope, it is possible, that is what I am purposing. Sorry I previous
> explain has been very high level, I haven't explain in the implementation
> detail of every stage.
>
> So the first patch would be adding the macro_expand hook into sparse.
> After a pre-processor macro expend, it will call the the macro_expand
> hook if the user register one. (the hook is not NULL).
>
> In the macro_expand hook, it will receive:
> - macro before the expand,
> - args for the macro
> - replacement tokens after the expand.
>
> This will give your macro dependency program a chance to
> exam and manipulate the token before it get insert back
> to original token list.
>
>
> Here is how your macro dependency program can use the
> macro_expand hook.
>
> The program should create a internal stream call "<pre-processor>".
> The content of the file is just the result of macro expand. One
> macro at a line, the the order they are expanded. You can use the
> pos->line to index when macro expand it is. Notice that you don't
> need to actually write out the stream into disk.
>
> Then, inside the macro_expand hook that receive the macro
> expand call back.
>
> There will be an array of data structure keep track of the
> macro expand. The first macro expand is on the first element
> of the array. Let's call this data structure "struct macro_deps".
>
> Inside "struct macro_deps", it will keep track of the original
> macro before the expand. The list of the tokens it depends on.
> That is your dependency information.
>
> It will allocate one "struct macro_deps" and fill it out, append
> to the end of the array.
>
> Before you macro_expand hook return, it walk the replacement
> token. For each "token->pos" in the replacement token, it will
> replace the stream number to to "pre-processor", and line number
> to the index of the "struct macro_deps" in the array. Before the
> replacement, if the original stream is already "<pre-processor>",
> that means you are expanding the result from another macro expand.
> Using the old pos->line to look up the inner macro expand, add
> inner macro's dependency list into the current macro dependency list.
>
> Then after the pre-processor stage. All the token from macro
> expand will look as if they are expand from the "pre-processor"
> file, line number can be use as index to lookup the array to find
> out the detail of this macro expand.
>
> Will that work for your dependency file. I notice that it not 100%
> the same with your dependency, but with the intact history. You
> should able to find that out.
>
>> And: until I would have come up with something that would fit your
>> requirements
>> months would be gone. It seems that you know exactly how
>> it should  be done, there is no way for me to know how
>> you think a noninvasive solution would look like. The communication
>> takes too long.
>
> So here it is. I already give you the details of the implementation.
> Of course, the first step for macro_expand hook is much smaller
> scope. Please let me know that works or not.
>
>>
>> If there is no need for the tool i proposed, there is no need.
>> At least I tried :-)
>
> I already confirm that is useful. Just how to implement it.
>
> Chris
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 22:30:21 +0000
Message-ID: <CANeU7QkoHY_L9oQ4WuxPFUABwFznTfAMWMSRz7-Pe98dSiuiGQ () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 1:53 PM, Konrad Eisele <eiselekd@gmail.com> wrote:
> make C=2:
>
> original sparse:
> real    17m54.997s
> user    15m25.181s
> sys     2m11.281s
>
> decpp-sparse from "git clone git://git.code.sf.net/p/decpp/code decpp "
> real    18m29.748s
> user    16m18.155s
> sys     2m13.221s
>
> But decpp is not written with performance in common cases in mind.
> The 2 runs probably also depend on other factors too.
> I cant think that 4 bytes extra for each token can have a big impact,
> if I would implement it that way (it is not in decpp).

The deal breaker is not able to free token list if other program using
sparse don't need it. I believe that I have an alternative approach
allow you do want you want while keeping the impact to sparse
internal small. In my mind, that is straightly better than your
current patch. I can share more details if you found a missing link.

> I understand. Actually the code to demonstrate is
> git://git.code.sf.net/p/decpp/code , then do a
> $make
> $./shrinkc t1.c
> That is kind of the goal.
> And - it does require some  internal structure
> change. You dont get this kind of functionality
> for free. You have to be invasive, isnt this
> something that is obvious?. And in my view, it
> can come with penalty. The preprocessing stage

That doesn't mean that we should pay any penalty
for it. Especially I believe there is better alternative
approach to allow you do what you want and keep
the API clean. You need to be a little patient here
to understand my alternative suggestions. I did spend
some time here to come up with the approach to make
it works for you and keep myself happy about the internals.

You dismiss the my suggestion too eagerly without
considering how to make it work. You are pretty much saying,
"Nah, this is not going to work, I am calling in the big hammers."
You should at least consider it, point out where you think
it doesn't work, so that I can provide addition details how
to make it work. I did notice that I have some detail left out in
my suggestions, mostly due to time constrain to write it up.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 22:30:21 +0000
Message-ID: <CANeU7QkoHY_L9oQ4WuxPFUABwFznTfAMWMSRz7-Pe98dSiuiGQ () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 1:53 PM, Konrad Eisele <eiselekd@gmail.com> wrote:
> make C=2:
>
> original sparse:
> real    17m54.997s
> user    15m25.181s
> sys     2m11.281s
>
> decpp-sparse from "git clone git://git.code.sf.net/p/decpp/code decpp "
> real    18m29.748s
> user    16m18.155s
> sys     2m13.221s
>
> But decpp is not written with performance in common cases in mind.
> The 2 runs probably also depend on other factors too.
> I cant think that 4 bytes extra for each token can have a big impact,
> if I would implement it that way (it is not in decpp).

The deal breaker is not able to free token list if other program using
sparse don't need it. I believe that I have an alternative approach
allow you do want you want while keeping the impact to sparse
internal small. In my mind, that is straightly better than your
current patch. I can share more details if you found a missing link.

> I understand. Actually the code to demonstrate is
> git://git.code.sf.net/p/decpp/code , then do a
> $make
> $./shrinkc t1.c
> That is kind of the goal.
> And - it does require some  internal structure
> change. You dont get this kind of functionality
> for free. You have to be invasive, isnt this
> something that is obvious?. And in my view, it
> can come with penalty. The preprocessing stage

That doesn't mean that we should pay any penalty
for it. Especially I believe there is better alternative
approach to allow you do what you want and keep
the API clean. You need to be a little patient here
to understand my alternative suggestions. I did spend
some time here to come up with the approach to make
it works for you and keep myself happy about the internals.

You dismiss the my suggestion too eagerly without
considering how to make it work. You are pretty much saying,
"Nah, this is not going to work, I am calling in the big hammers."
You should at least consider it, point out where you think
it doesn't work, so that I can provide addition details how
to make it work. I did notice that I have some detail left out in
my suggestions, mostly due to time constrain to write it up.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 23:05:56 +0000
Message-ID: <CANeU7QmzTDarO9xD7NiRsaSasQnVQug6LFCCp9ud0vuBcekS8Q () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 2:46 PM, Konrad Eisele <eiselekd@gmail.com> wrote:
>
> Nice to hear this.
> When I talk about macro dependency I mean not only the
> macro expansion trace. I mean:
>  1. The #if (and #include) nestings (with dependencies
>    pointing to the macros used in the proprocessor line)
>  2. The macro expansion trace
>  3. The connection 1+2 into the AST.
> Your macro_expand() hook addresses (2) only, but I cant
> see how all the extra context for each token can be saved
> in that sheme.

That is much better. There is two separate problem here.
One is keep track of all the macro expand history so you can
trace back the token back to the original form. I believe my
description of the macro_expand hook should take care of that.

Now how to connect the AST tree with those information is a
very good question. Notice the symbol->aux pointer? That is
the place to attach extra context or back end related data
to symbols.

Because each symbol has "pos" and "endpos". If the symbol
is expand from macro, using the previous scheme, the pos
should point to a line in the "<pre-processor>" stream.

However, if the macro expand is happen between "pos" and
"endpos", you will not able to access the token that contain
the macro expand "pos" easily.

For that, we could, just thinking it out loud, add a parser
hook for declares when a symbol is complete building.
That would a very small and straight forward change.
If the hook is not NULL, the call back function will be call
with the symbol that just get defined, and the start and end
token of that symbol.

So your dependence program just need to register the
symbol parsing hook. In side the call back function, walk
the token from start to end. Look up macro expand information
is needed. Build up the dependency struct and store that in
symbol->aux.

BTW, unrelated to this patch, I can see other program might
be able to use the same parser hook to perform source code
transformations as well.

Make sense? In this way, you don't even need the hash
table to attach a context into the token. You can get it directly
from symbol->aux.

> In my patch I have modeled (2) using 2 structs:
> struct macro_expansion {
>        int nargs;
>        struct symbol *sym;
>        struct token *m;
>        struct arg args[0];
> };
> struct tok_macro_dep {
>        struct macro_expansion *m;
>        unsigned int argi;
>        unsigned int isbody : 1;
>        unsigned int visited : 1;
> };
> Each token from a macro expansion gets tagged with
> tok_macro_dep. If it is an macro argument, <argi> shows the
> index, if it is from the macro body <isbody> is 1.
> Now, I didnt already think about special cases like
> token concaternation, even more data is needed to
> model this. Also when an macro argument is again used as an
> macro argument inside the body expansion, then I kindof
> loose the chain: I would also need a "token *dup_of" pointer
> to point to the original token that the token is a copy
> of (when arguments are created...) etc.
>
> I have read your macro_expand() hook idea, however
> when I understand it right you want to reuse position.stream and
> position.line as a kind of pointer (to save the extra 4 bytes).
> (Your goal is to minimize codebase change, however I wonder
> weather you dont change semantic of struct position and then
> need to change the code that uses struct position anyway...)

Nope, because the position.stream change is only happen on
your dependency analyse program. It is the dependency program
register the hook to it. This behaviour is private to the dependency
analyse program. Other program that use sparse library don't see
it at all, because they don't register macro_expand hooks to perform
those stream manipulations. It will receive the exact AST as before.

> Maybe it is possible like this...I doubt it, where should
> all the extra context, that each token has, be saved and
> extracted from? using that sheme...

Two places, one is symbol->aux. Also the macro_expand
can be lookup by pos->line. That will index into the macro_expand
array which store the context.

Having this two should be enough to put the exact same
dependency result as you are doing right now.

> Maybe it is possible but I dont want to have as a design
> goal to save 4 bytes (I'd use the void *custom sheme to
> save all my extra data, also the pointers to tokens to
> "sit around") and adujust everything else to
> that. The consequence is that the code-complexity would
> grow on the other end.

It is not only about saving 4 bytes. It is about other program
don't have to suck in the full token struct if they don't need to.
It is about re-usable macro hooks and parser hooks that
external program can do more fancy stuff like source code transformations
without impacting the other user of the sparse lib.

> Here is my compromise then:
> Keep the orignial "pos". But still grant me for
> each struct a "void *custom" pointer that I can use
> to store extradata i.e. pointer to token.

symbol->aux.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Fri, 04 May 2012 23:05:56 +0000
Message-ID: <CANeU7QmzTDarO9xD7NiRsaSasQnVQug6LFCCp9ud0vuBcekS8Q () mail ! gmail ! com>
--------------------
On Fri, May 4, 2012 at 2:46 PM, Konrad Eisele <eiselekd@gmail.com> wrote:
>
> Nice to hear this.
> When I talk about macro dependency I mean not only the
> macro expansion trace. I mean:
>  1. The #if (and #include) nestings (with dependencies
>    pointing to the macros used in the proprocessor line)
>  2. The macro expansion trace
>  3. The connection 1+2 into the AST.
> Your macro_expand() hook addresses (2) only, but I cant
> see how all the extra context for each token can be saved
> in that sheme.

That is much better. There is two separate problem here.
One is keep track of all the macro expand history so you can
trace back the token back to the original form. I believe my
description of the macro_expand hook should take care of that.

Now how to connect the AST tree with those information is a
very good question. Notice the symbol->aux pointer? That is
the place to attach extra context or back end related data
to symbols.

Because each symbol has "pos" and "endpos". If the symbol
is expand from macro, using the previous scheme, the pos
should point to a line in the "<pre-processor>" stream.

However, if the macro expand is happen between "pos" and
"endpos", you will not able to access the token that contain
the macro expand "pos" easily.

For that, we could, just thinking it out loud, add a parser
hook for declares when a symbol is complete building.
That would a very small and straight forward change.
If the hook is not NULL, the call back function will be call
with the symbol that just get defined, and the start and end
token of that symbol.

So your dependence program just need to register the
symbol parsing hook. In side the call back function, walk
the token from start to end. Look up macro expand information
is needed. Build up the dependency struct and store that in
symbol->aux.

BTW, unrelated to this patch, I can see other program might
be able to use the same parser hook to perform source code
transformations as well.

Make sense? In this way, you don't even need the hash
table to attach a context into the token. You can get it directly
from symbol->aux.

> In my patch I have modeled (2) using 2 structs:
> struct macro_expansion {
>        int nargs;
>        struct symbol *sym;
>        struct token *m;
>        struct arg args[0];
> };
> struct tok_macro_dep {
>        struct macro_expansion *m;
>        unsigned int argi;
>        unsigned int isbody : 1;
>        unsigned int visited : 1;
> };
> Each token from a macro expansion gets tagged with
> tok_macro_dep. If it is an macro argument, <argi> shows the
> index, if it is from the macro body <isbody> is 1.
> Now, I didnt already think about special cases like
> token concaternation, even more data is needed to
> model this. Also when an macro argument is again used as an
> macro argument inside the body expansion, then I kindof
> loose the chain: I would also need a "token *dup_of" pointer
> to point to the original token that the token is a copy
> of (when arguments are created...) etc.
>
> I have read your macro_expand() hook idea, however
> when I understand it right you want to reuse position.stream and
> position.line as a kind of pointer (to save the extra 4 bytes).
> (Your goal is to minimize codebase change, however I wonder
> weather you dont change semantic of struct position and then
> need to change the code that uses struct position anyway...)

Nope, because the position.stream change is only happen on
your dependency analyse program. It is the dependency program
register the hook to it. This behaviour is private to the dependency
analyse program. Other program that use sparse library don't see
it at all, because they don't register macro_expand hooks to perform
those stream manipulations. It will receive the exact AST as before.

> Maybe it is possible like this...I doubt it, where should
> all the extra context, that each token has, be saved and
> extracted from? using that sheme...

Two places, one is symbol->aux. Also the macro_expand
can be lookup by pos->line. That will index into the macro_expand
array which store the context.

Having this two should be enough to put the exact same
dependency result as you are doing right now.

> Maybe it is possible but I dont want to have as a design
> goal to save 4 bytes (I'd use the void *custom sheme to
> save all my extra data, also the pointers to tokens to
> "sit around") and adujust everything else to
> that. The consequence is that the code-complexity would
> grow on the other end.

It is not only about saving 4 bytes. It is about other program
don't have to suck in the full token struct if they don't need to.
It is about re-usable macro hooks and parser hooks that
external program can do more fancy stuff like source code transformations
without impacting the other user of the sparse lib.

> Here is my compromise then:
> Keep the orignial "pos". But still grant me for
> each struct a "void *custom" pointer that I can use
> to store extradata i.e. pointer to token.

symbol->aux.

Chris
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 08:54:46 +0000
Message-ID: <4FA4EAD6.1040206 () gmail ! com>
--------------------
On 05/05/2012 01:05 AM, Christopher Li wrote:
> On Fri, May 4, 2012 at 2:46 PM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>>
>> Nice to hear this.
>> When I talk about macro dependency I mean not only the
>> macro expansion trace. I mean:
>>   (1). The #if (and #include) nestings (with dependencies
>>        pointing to the macros used in the proprocessor line)
>>   (2). The macro expansion trace
>>   (3). The connection 1+2 into the AST.
>> Your macro_expand() hook addresses (2) only, but I cant
>> see how all the extra context for each token can be saved
>> in that sheme.
>
> That is much better. There is two separate problem here.
> One is keep track of all the macro expand history so you can
> trace back the token back to the original form. I believe my
> description of the macro_expand hook should take care of that.

Ok, I'll try to implement it the way you suggest, coding macro-
expansion into token.pos See (Concerning (2)). Tell me weather
I can start implementing the scheme stated below (at least for
(Concerning (2)). I would add 3 hooks as stated in "Conclusion:" of
section "Concerning (2)". Can you give the ok to go?

Concerning (1): You didnt comment on this point.
------------------------------------------------

I would need a list-based-pushdown-stack. Each entry would
register calls to lookup_macro() when inside a # preprocessor
line. Then an mechanism has to be implemented to tag each
token with an entry in the pushdown stack (which builds up a
tree). I guess that you dont want a pointer in struct token :-)
so maybe the pushdown stack can define start-pos and when popped
end-pos and use these "ranges" to match tokens.

I would need hooks for this in the # preprocessor line locations.

Concerning (2): Macro expansion trace using token.<pos>
-------------------------------------------------------

I've thought about how to fit in macro_expand and stuffing
macro trace into <pos>. Below is my sketch how I would record
a macro expansion. p[] is the array of preprocessor-"lines",
rather, it is an array of PP_struct (see below) with extra info
needed for each line. PP_struct.copy is the copy of the array of
tokens involved.

Annotation: p[x] denotes the stuffing of the macrotrace into
position.stream==preprocess,position.line==pp-line.
Tokenlists are written with "." between: tok0 . tok1 . ...
Under the tokenlists I have written below each token its
token.pos in p[x] notation, when token.pos is from file-scope
I have written a range, i.e [a.h:1:23..a.h:1:45] so not to
have write it for each token.

Note that a reference to p[] in p[x] notation only references
the "start" of the  PP_struct.copy. An uique identification
of the "source" token might not always be possible because
of disambiguities, so when doing a copy of the  tokens in
PP_struct.copy I might use an extended version of struct token
to also include an offset.

----- file a.h start -----
#define D0(d0a0,d0a1) 1 D1(d0a0) 2 D2(d0a1) 3
#define D1(d1a0) 4 d1a0 5
#define D2(d2a0) 6 d2a0 7
#define D3(d3a0) 8 d3a0 9
D0(D3(10),11)
----- file a.h end   .....

Preprocessor output (gcc -E a.h): "1 4 8 10 9 5 2 6 11 7 3"

PreProcessor macro trace on p[]:

p[0]:mdefn_body[D0]     :1.D1.(.d0a0.).2.D2.(.d0a1.).3
                          [ a.h:1:23     ..   a.h:1:45]
p[1]:mdefn_body[D1]     :4   .   d1a0   .    5
                          [ a.h:2:18..a.h:2:25]
p[2]:mdefn_body[D2]     :6   .   d2a0   .    7
                          [ a.h:3:18..a.h:3:25]
p[3]:mdefn_body[D3]     :8   .   d3a0   .    9
                          [ a.h:4:18..a.h:4:25]
p[4]:minst_arg0[D0]     :D3  . (  .   10 . )
                          [ a.h:5:4..a.h:5:9]
p[5]:minst_arg1[D0]     :11
                          [a.h:5:11]
p[6]:minst_arg0[D3]     :10
                          p[4]
p[7]:(args)expand[p[3]] :8    .  10   .  9
                          p[3]    p[4]    p[3]
p[8]:minst_arg0[d2]     :11
                          p[5]
p[9]:(body)expand[p[2]] :6   .   11   .    7
                          p[2]    p[5]      p[2]
p[10]:(body)expand[p[0]]:1  .4  .8  .10 .9  .5  .2  .6  .11 .7  .3
                          p[0]p[1]p[7]p[7]p[7]p[1]p[0]p[9]p[9]p[9]p[0]


p[0]-p[3] are build up when the macro is defined.
           A p[] entry is needed to destinguish between
           the different sources of tokens.
p[4],p[5] is build in collect_arguments() for D0(D3(10),11)
p[6]      is build in collect_arguments() for D3(10)
p[7]      is build in call to macro_expand() hook with flag that
           it is a (args)expand
p[8]      is build in collect_arguments() for D2(11)
           (inside D0's expansion
p[9]      is build in call to macro_expand() hook with flag that
           it is a (body)expand (of D2)
p[10]     is build in call to macro_expand() hook with flag that
           it is a (body)expand (of D0)

PP_struct {
           enum {minst_arg, expand_body, expand_arg, mdef_body} typ;
	  uint argidx;
           struct symbol *macro;
	  struct token copy[];
};

Conclusion:
-----------
Apart from the macro_expand() hook I also need hooks
in macro definition and also in collect_arguments() or expand().


Concerning (3) How to connect (1) and (2) to the AST
----------------------------------------------------

can maybe wait for later iteration. There are more complex parts
involved...


>
> Now how to connect the AST tree with those information is a
> very good question. Notice the symbol->aux pointer? That is
> the place to attach extra context or back end related data
> to symbols.
>
> Because each symbol has "pos" and "endpos". If the symbol
> is expand from macro, using the previous scheme, the pos
> should point to a line in the "<pre-processor>" stream.
>
> However, if the macro expand is happen between "pos" and
> "endpos", you will not able to access the token that contain
> the macro expand "pos" easily.
>
> For that, we could, just thinking it out loud, add a parser
> hook for declares when a symbol is complete building.
> That would a very small and straight forward change.
> If the hook is not NULL, the call back function will be call
> with the symbol that just get defined, and the start and end
> token of that symbol.
>
> So your dependence program just need to register the
> symbol parsing hook. In side the call back function, walk
> the token from start to end. Look up macro expand information
> is needed. Build up the dependency struct and store that in
> symbol->aux.
>
> BTW, unrelated to this patch, I can see other program might
> be able to use the same parser hook to perform source code
> transformations as well.
>
> Make sense? In this way, you don't even need the hash
> table to attach a context into the token. You can get it directly
> from symbol->aux.
>
>> In my patch I have modeled (2) using 2 structs:
>> struct macro_expansion {
>>         int nargs;
>>         struct symbol *sym;
>>         struct token *m;
>>         struct arg args[0];
>> };
>> struct tok_macro_dep {
>>         struct macro_expansion *m;
>>         unsigned int argi;
>>         unsigned int isbody : 1;
>>         unsigned int visited : 1;
>> };
>> Each token from a macro expansion gets tagged with
>> tok_macro_dep. If it is an macro argument,<argi>  shows the
>> index, if it is from the macro body<isbody>  is 1.
>> Now, I didnt already think about special cases like
>> token concaternation, even more data is needed to
>> model this. Also when an macro argument is again used as an
>> macro argument inside the body expansion, then I kindof
>> loose the chain: I would also need a "token *dup_of" pointer
>> to point to the original token that the token is a copy
>> of (when arguments are created...) etc.
>>
>> I have read your macro_expand() hook idea, however
>> when I understand it right you want to reuse position.stream and
>> position.line as a kind of pointer (to save the extra 4 bytes).
>> (Your goal is to minimize codebase change, however I wonder
>> weather you dont change semantic of struct position and then
>> need to change the code that uses struct position anyway...)
>
> Nope, because the position.stream change is only happen on
> your dependency analyse program. It is the dependency program
> register the hook to it. This behaviour is private to the dependency
> analyse program. Other program that use sparse library don't see
> it at all, because they don't register macro_expand hooks to perform
> those stream manipulations. It will receive the exact AST as before.
>
>> Maybe it is possible like this...I doubt it, where should
>> all the extra context, that each token has, be saved and
>> extracted from? using that sheme...
>
> Two places, one is symbol->aux. Also the macro_expand
> can be lookup by pos->line. That will index into the macro_expand
> array which store the context.
>
> Having this two should be enough to put the exact same
> dependency result as you are doing right now.
>
>> Maybe it is possible but I dont want to have as a design
>> goal to save 4 bytes (I'd use the void *custom sheme to
>> save all my extra data, also the pointers to tokens to
>> "sit around") and adujust everything else to
>> that. The consequence is that the code-complexity would
>> grow on the other end.
>
> It is not only about saving 4 bytes. It is about other program
> don't have to suck in the full token struct if they don't need to.
> It is about re-usable macro hooks and parser hooks that
> external program can do more fancy stuff like source code transformations
> without impacting the other user of the sparse lib.
>
>> Here is my compromise then:
>> Keep the orignial "pos". But still grant me for
>> each struct a "void *custom" pointer that I can use
>> to store extradata i.e. pointer to token.
>
> symbol->aux.
>
> Chris
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 08:54:46 +0000
Message-ID: <4FA4EAD6.1040206 () gmail ! com>
--------------------
On 05/05/2012 01:05 AM, Christopher Li wrote:
> On Fri, May 4, 2012 at 2:46 PM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>>
>> Nice to hear this.
>> When I talk about macro dependency I mean not only the
>> macro expansion trace. I mean:
>>   (1). The #if (and #include) nestings (with dependencies
>>        pointing to the macros used in the proprocessor line)
>>   (2). The macro expansion trace
>>   (3). The connection 1+2 into the AST.
>> Your macro_expand() hook addresses (2) only, but I cant
>> see how all the extra context for each token can be saved
>> in that sheme.
>
> That is much better. There is two separate problem here.
> One is keep track of all the macro expand history so you can
> trace back the token back to the original form. I believe my
> description of the macro_expand hook should take care of that.

Ok, I'll try to implement it the way you suggest, coding macro-
expansion into token.pos See (Concerning (2)). Tell me weather
I can start implementing the scheme stated below (at least for
(Concerning (2)). I would add 3 hooks as stated in "Conclusion:" of
section "Concerning (2)". Can you give the ok to go?

Concerning (1): You didnt comment on this point.
------------------------------------------------

I would need a list-based-pushdown-stack. Each entry would
register calls to lookup_macro() when inside a # preprocessor
line. Then an mechanism has to be implemented to tag each
token with an entry in the pushdown stack (which builds up a
tree). I guess that you dont want a pointer in struct token :-)
so maybe the pushdown stack can define start-pos and when popped
end-pos and use these "ranges" to match tokens.

I would need hooks for this in the # preprocessor line locations.

Concerning (2): Macro expansion trace using token.<pos>
-------------------------------------------------------

I've thought about how to fit in macro_expand and stuffing
macro trace into <pos>. Below is my sketch how I would record
a macro expansion. p[] is the array of preprocessor-"lines",
rather, it is an array of PP_struct (see below) with extra info
needed for each line. PP_struct.copy is the copy of the array of
tokens involved.

Annotation: p[x] denotes the stuffing of the macrotrace into
position.stream==preprocess,position.line==pp-line.
Tokenlists are written with "." between: tok0 . tok1 . ...
Under the tokenlists I have written below each token its
token.pos in p[x] notation, when token.pos is from file-scope
I have written a range, i.e [a.h:1:23..a.h:1:45] so not to
have write it for each token.

Note that a reference to p[] in p[x] notation only references
the "start" of the  PP_struct.copy. An uique identification
of the "source" token might not always be possible because
of disambiguities, so when doing a copy of the  tokens in
PP_struct.copy I might use an extended version of struct token
to also include an offset.

----- file a.h start -----
#define D0(d0a0,d0a1) 1 D1(d0a0) 2 D2(d0a1) 3
#define D1(d1a0) 4 d1a0 5
#define D2(d2a0) 6 d2a0 7
#define D3(d3a0) 8 d3a0 9
D0(D3(10),11)
----- file a.h end   .....

Preprocessor output (gcc -E a.h): "1 4 8 10 9 5 2 6 11 7 3"

PreProcessor macro trace on p[]:

p[0]:mdefn_body[D0]     :1.D1.(.d0a0.).2.D2.(.d0a1.).3
                          [ a.h:1:23     ..   a.h:1:45]
p[1]:mdefn_body[D1]     :4   .   d1a0   .    5
                          [ a.h:2:18..a.h:2:25]
p[2]:mdefn_body[D2]     :6   .   d2a0   .    7
                          [ a.h:3:18..a.h:3:25]
p[3]:mdefn_body[D3]     :8   .   d3a0   .    9
                          [ a.h:4:18..a.h:4:25]
p[4]:minst_arg0[D0]     :D3  . (  .   10 . )
                          [ a.h:5:4..a.h:5:9]
p[5]:minst_arg1[D0]     :11
                          [a.h:5:11]
p[6]:minst_arg0[D3]     :10
                          p[4]
p[7]:(args)expand[p[3]] :8    .  10   .  9
                          p[3]    p[4]    p[3]
p[8]:minst_arg0[d2]     :11
                          p[5]
p[9]:(body)expand[p[2]] :6   .   11   .    7
                          p[2]    p[5]      p[2]
p[10]:(body)expand[p[0]]:1  .4  .8  .10 .9  .5  .2  .6  .11 .7  .3
                          p[0]p[1]p[7]p[7]p[7]p[1]p[0]p[9]p[9]p[9]p[0]


p[0]-p[3] are build up when the macro is defined.
           A p[] entry is needed to destinguish between
           the different sources of tokens.
p[4],p[5] is build in collect_arguments() for D0(D3(10),11)
p[6]      is build in collect_arguments() for D3(10)
p[7]      is build in call to macro_expand() hook with flag that
           it is a (args)expand
p[8]      is build in collect_arguments() for D2(11)
           (inside D0's expansion
p[9]      is build in call to macro_expand() hook with flag that
           it is a (body)expand (of D2)
p[10]     is build in call to macro_expand() hook with flag that
           it is a (body)expand (of D0)

PP_struct {
           enum {minst_arg, expand_body, expand_arg, mdef_body} typ;
	  uint argidx;
           struct symbol *macro;
	  struct token copy[];
};

Conclusion:
-----------
Apart from the macro_expand() hook I also need hooks
in macro definition and also in collect_arguments() or expand().


Concerning (3) How to connect (1) and (2) to the AST
----------------------------------------------------

can maybe wait for later iteration. There are more complex parts
involved...


>
> Now how to connect the AST tree with those information is a
> very good question. Notice the symbol->aux pointer? That is
> the place to attach extra context or back end related data
> to symbols.
>
> Because each symbol has "pos" and "endpos". If the symbol
> is expand from macro, using the previous scheme, the pos
> should point to a line in the "<pre-processor>" stream.
>
> However, if the macro expand is happen between "pos" and
> "endpos", you will not able to access the token that contain
> the macro expand "pos" easily.
>
> For that, we could, just thinking it out loud, add a parser
> hook for declares when a symbol is complete building.
> That would a very small and straight forward change.
> If the hook is not NULL, the call back function will be call
> with the symbol that just get defined, and the start and end
> token of that symbol.
>
> So your dependence program just need to register the
> symbol parsing hook. In side the call back function, walk
> the token from start to end. Look up macro expand information
> is needed. Build up the dependency struct and store that in
> symbol->aux.
>
> BTW, unrelated to this patch, I can see other program might
> be able to use the same parser hook to perform source code
> transformations as well.
>
> Make sense? In this way, you don't even need the hash
> table to attach a context into the token. You can get it directly
> from symbol->aux.
>
>> In my patch I have modeled (2) using 2 structs:
>> struct macro_expansion {
>>         int nargs;
>>         struct symbol *sym;
>>         struct token *m;
>>         struct arg args[0];
>> };
>> struct tok_macro_dep {
>>         struct macro_expansion *m;
>>         unsigned int argi;
>>         unsigned int isbody : 1;
>>         unsigned int visited : 1;
>> };
>> Each token from a macro expansion gets tagged with
>> tok_macro_dep. If it is an macro argument,<argi>  shows the
>> index, if it is from the macro body<isbody>  is 1.
>> Now, I didnt already think about special cases like
>> token concaternation, even more data is needed to
>> model this. Also when an macro argument is again used as an
>> macro argument inside the body expansion, then I kindof
>> loose the chain: I would also need a "token *dup_of" pointer
>> to point to the original token that the token is a copy
>> of (when arguments are created...) etc.
>>
>> I have read your macro_expand() hook idea, however
>> when I understand it right you want to reuse position.stream and
>> position.line as a kind of pointer (to save the extra 4 bytes).
>> (Your goal is to minimize codebase change, however I wonder
>> weather you dont change semantic of struct position and then
>> need to change the code that uses struct position anyway...)
>
> Nope, because the position.stream change is only happen on
> your dependency analyse program. It is the dependency program
> register the hook to it. This behaviour is private to the dependency
> analyse program. Other program that use sparse library don't see
> it at all, because they don't register macro_expand hooks to perform
> those stream manipulations. It will receive the exact AST as before.
>
>> Maybe it is possible like this...I doubt it, where should
>> all the extra context, that each token has, be saved and
>> extracted from? using that sheme...
>
> Two places, one is symbol->aux. Also the macro_expand
> can be lookup by pos->line. That will index into the macro_expand
> array which store the context.
>
> Having this two should be enough to put the exact same
> dependency result as you are doing right now.
>
>> Maybe it is possible but I dont want to have as a design
>> goal to save 4 bytes (I'd use the void *custom sheme to
>> save all my extra data, also the pointers to tokens to
>> "sit around") and adujust everything else to
>> that. The consequence is that the code-complexity would
>> grow on the other end.
>
> It is not only about saving 4 bytes. It is about other program
> don't have to suck in the full token struct if they don't need to.
> It is about re-usable macro hooks and parser hooks that
> external program can do more fancy stuff like source code transformations
> without impacting the other user of the sparse lib.
>
>> Here is my compromise then:
>> Keep the orignial "pos". But still grant me for
>> each struct a "void *custom" pointer that I can use
>> to store extradata i.e. pointer to token.
>
> symbol->aux.
>
> Chris
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 08:59:54 +0000
Message-ID: <4FA4EC0A.30304 () gmail ! com>
--------------------
On 05/05/2012 02:32 AM, Josh Triplett wrote:
> On Fri, May 04, 2012 at 03:30:21PM -0700, Christopher Li wrote:
>> On Fri, May 4, 2012 at 1:53 PM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>>> make C=2:
>>>
>>> original sparse:
>>> real    17m54.997s
>>> user    15m25.181s
>>> sys     2m11.281s
>>>
>>> decpp-sparse from "git clone git://git.code.sf.net/p/decpp/code decpp "
>>> real    18m29.748s
>>> user    16m18.155s
>>> sys     2m13.221s
>>>
>>> But decpp is not written with performance in common cases in mind.
>>> The 2 runs probably also depend on other factors too.
>>> I cant think that 4 bytes extra for each token can have a big impact,
>>> if I would implement it that way (it is not in decpp).
>>
>> The deal breaker is not able to free token list if other program using
>> sparse don't need it.
>
>> From the top of token.h:
>
> /*
>   * Basic tokenization structures. NOTE! Those tokens had better
>   * be pretty small, since we're going to keep them all in memory
>   * indefinitely.
>
> Has that changed?  If so, perhaps the comment needs fixing.  If not, I
> suspect the problem lies elsewhere; perhaps in the extra levels of
> indirection introduced by the patch, rather than in the extra memory
> usage.

The benchmarking of decpp's sparse is not based on the patch I sent,
rather decpp's sparse does a lot more tagging to every token with a lot
of extra data. And without performance in mind.Programmed with the
common cases performance in mind it shouldnt have an impact at all...
I think I understood Christophers suggestion now and migh implement
it that way..
-- Konrad



>
> - Josh Triplett
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 08:59:54 +0000
Message-ID: <4FA4EC0A.30304 () gmail ! com>
--------------------
On 05/05/2012 02:32 AM, Josh Triplett wrote:
> On Fri, May 04, 2012 at 03:30:21PM -0700, Christopher Li wrote:
>> On Fri, May 4, 2012 at 1:53 PM, Konrad Eisele<eiselekd@gmail.com>  wrote:
>>> make C=2:
>>>
>>> original sparse:
>>> real    17m54.997s
>>> user    15m25.181s
>>> sys     2m11.281s
>>>
>>> decpp-sparse from "git clone git://git.code.sf.net/p/decpp/code decpp "
>>> real    18m29.748s
>>> user    16m18.155s
>>> sys     2m13.221s
>>>
>>> But decpp is not written with performance in common cases in mind.
>>> The 2 runs probably also depend on other factors too.
>>> I cant think that 4 bytes extra for each token can have a big impact,
>>> if I would implement it that way (it is not in decpp).
>>
>> The deal breaker is not able to free token list if other program using
>> sparse don't need it.
>
>> From the top of token.h:
>
> /*
>   * Basic tokenization structures. NOTE! Those tokens had better
>   * be pretty small, since we're going to keep them all in memory
>   * indefinitely.
>
> Has that changed?  If so, perhaps the comment needs fixing.  If not, I
> suspect the problem lies elsewhere; perhaps in the extra levels of
> indirection introduced by the patch, rather than in the extra memory
> usage.

The benchmarking of decpp's sparse is not based on the patch I sent,
rather decpp's sparse does a lot more tagging to every token with a lot
of extra data. And without performance in mind.Programmed with the
common cases performance in mind it shouldnt have an impact at all...
I think I understood Christophers suggestion now and migh implement
it that way..
-- Konrad



>
> - Josh Triplett
>

--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 11:12:37 +0000
Message-ID: <CANeU7QnNemo=iyx3+VJBgEzf4kOacxOx9JTsbu5Of46+3NkAJA () mail ! gmail ! com>
--------------------
--001636c5abbe59763f04bf481d1f
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable

On Sat, May 5, 2012 at 1:54 AM, Konrad Eisele <eiselekd@gmail.com> wrote:
>>
>>
>> That is much better. There is two separate problem here.
>> One is keep track of all the macro expand history so you can
>> trace back the token back to the original form. I believe my
>> description of the macro_expand hook should take care of that.
>
>
> Ok, I'll try to implement it the way you suggest, coding macro-
> expansion into token.pos See (Concerning (2)). Tell me weather
> I can start implementing the scheme stated below (at least for
> (Concerning (2)). I would add 3 hooks as stated in "Conclusion:" of
> section "Concerning (2)". Can you give the ok to go?
>
> Concerning (1): You didnt comment on this point.

Oh, obviously you can register the preprocess hook to notifify
of the ifdef and include. I consider adding this kind of the call back
function less invasive because program that only use the stander
preprocessor don't need to pay the price for it.

I attach a patch I am playing with the macro expand hook ideas.
It compiles but I haven't did any more test beyond that.
Feel free to use or modify it as you see fit.


> ------------------------------------------------
>
> I would need a list-based-pushdown-stack. Each entry would
> register calls to lookup_macro() when inside a # preprocessor
> line. Then an mechanism has to be implemented to tag each
> token with an entry in the pushdown stack (which builds up a
> tree). I guess that you dont want a pointer in struct token :-)
> so maybe the pushdown stack can define start-pos and when popped
> end-pos and use these "ranges" to match tokens.

I consider how to track the the macro dependency belongs to
internal behaviour of the shrink program. Spase is a library used
by this program. I want to make sure the API provide by spase
library is good enough information to allow dependency analyse.

As program that call into the sparse library, I don't have strong
opinion on how those program should implement. I care more
about the plumbing part of the sparse library, what API sparse
should provide to enable this kind of analyse.

> I would need hooks for this in the # preprocessor line locations.

Sure. Add it as one of the preprocessor hooks.

>
> Concerning (2): Macro expansion trace using token.<pos>
> -------------------------------------------------------
>
> I've thought about how to fit in macro_expand and stuffing
> macro trace into <pos>. Below is my sketch how I would record
> a macro expansion. p[] is the array of preprocessor-"lines",
> rather, it is an array of PP_struct (see below) with extra info
> needed for each line. PP_struct.copy is the copy of the array of
> tokens involved.
>
> Annotation: p[x] denotes the stuffing of the macrotrace into
> position.stream=3D=3Dpreprocess,position.line=3D=3Dpp-line.
> Tokenlists are written with "." between: tok0 . tok1 . ...
> Under the tokenlists I have written below each token its
> token.pos in p[x] notation, when token.pos is from file-scope
> I have written a range, i.e [a.h:1:23..a.h:1:45] so not to
> have write it for each token.

Again, as long as it is part of the program and not the sparse
library. You are relative free to chose your implementation
within your program. It should not have impact on other
program that use sparse library any way. I use <pos> to make
a point that macro_expand hook can work.

I am not sure I understand your range representation yet.

To be continue...

Chris


>
> Note that a reference to p[] in p[x] notation only references
> the "start" of the =A0PP_struct.copy. An uique identification
> of the "source" token might not always be possible because
> of disambiguities, so when doing a copy of the =A0tokens in
> PP_struct.copy I might use an extended version of struct token
> to also include an offset.
>
> ----- file a.h start -----
> #define D0(d0a0,d0a1) 1 D1(d0a0) 2 D2(d0a1) 3
> #define D1(d1a0) 4 d1a0 5
> #define D2(d2a0) 6 d2a0 7
> #define D3(d3a0) 8 d3a0 9
> D0(D3(10),11)
> ----- file a.h end =A0 .....
>
> Preprocessor output (gcc -E a.h): "1 4 8 10 9 5 2 6 11 7 3"
>
> PreProcessor macro trace on p[]:
>
> p[0]:mdefn_body[D0] =A0 =A0 :1.D1.(.d0a0.).2.D2.(.d0a1.).3
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [ a.h:1:23 =A0 =A0 .. =A0=
 a.h:1:45]
> p[1]:mdefn_body[D1] =A0 =A0 :4 =A0 . =A0 d1a0 =A0 . =A0 =A05
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [ a.h:2:18..a.h:2:25]
> p[2]:mdefn_body[D2] =A0 =A0 :6 =A0 . =A0 d2a0 =A0 . =A0 =A07
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [ a.h:3:18..a.h:3:25]
> p[3]:mdefn_body[D3] =A0 =A0 :8 =A0 . =A0 d3a0 =A0 . =A0 =A09
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [ a.h:4:18..a.h:4:25]
> p[4]:minst_arg0[D0] =A0 =A0 :D3 =A0. ( =A0. =A0 10 . )
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [ a.h:5:4..a.h:5:9]
> p[5]:minst_arg1[D0] =A0 =A0 :11
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 [a.h:5:11]
> p[6]:minst_arg0[D3] =A0 =A0 :10
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 p[4]
> p[7]:(args)expand[p[3]] :8 =A0 =A0. =A010 =A0 . =A09
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 p[3] =A0 =A0p[4] =A0 =A0p=
[3]
> p[8]:minst_arg0[d2] =A0 =A0 :11
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 p[5]
> p[9]:(body)expand[p[2]] :6 =A0 . =A0 11 =A0 . =A0 =A07
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 p[2] =A0 =A0p[5] =A0 =A0 =
=A0p[2]
> p[10]:(body)expand[p[0]]:1 =A0.4 =A0.8 =A0.10 .9 =A0.5 =A0.2 =A0.6 =A0.11=
 .7 =A0.3
> =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 =A0 p[0]p[1]p[7]p[7]p[7]p[1]p=
[0]p[9]p[9]p[9]p[0]
>
>
> p[0]-p[3] are build up when the macro is defined.
> =A0 =A0 =A0 =A0 =A0A p[] entry is needed to destinguish between
> =A0 =A0 =A0 =A0 =A0the different sources of tokens.
> p[4],p[5] is build in collect_arguments() for D0(D3(10),11)
> p[6] =A0 =A0 =A0is build in collect_arguments() for D3(10)
> p[7] =A0 =A0 =A0is build in call to macro_expand() hook with flag that
> =A0 =A0 =A0 =A0 =A0it is a (args)expand
> p[8] =A0 =A0 =A0is build in collect_arguments() for D2(11)
> =A0 =A0 =A0 =A0 =A0(inside D0's expansion
> p[9] =A0 =A0 =A0is build in call to macro_expand() hook with flag that
> =A0 =A0 =A0 =A0 =A0it is a (body)expand (of D2)
> p[10] =A0 =A0 is build in call to macro_expand() hook with flag that
> =A0 =A0 =A0 =A0 =A0it is a (body)expand (of D0)
>
> PP_struct {
> =A0 =A0 =A0 =A0 =A0enum {minst_arg, expand_body, expand_arg, mdef_body} t=
yp;
> =A0 =A0 =A0 =A0 =A0uint argidx;
> =A0 =A0 =A0 =A0 =A0struct symbol *macro;
> =A0 =A0 =A0 =A0 =A0struct token copy[];
> };
>
> Conclusion:
> -----------
> Apart from the macro_expand() hook I also need hooks
> in macro definition and also in collect_arguments() or expand().
>
>
> Concerning (3) How to connect (1) and (2) to the AST
> ----------------------------------------------------
>
> can maybe wait for later iteration. There are more complex parts
> involved...
>
>
>
>>
>> Now how to connect the AST tree with those information is a
>> very good question. Notice the symbol->aux pointer? That is
>> the place to attach extra context or back end related data
>> to symbols.
>>
>> Because each symbol has "pos" and "endpos". If the symbol
>> is expand from macro, using the previous scheme, the pos
>> should point to a line in the "<pre-processor>" stream.
>>
>> However, if the macro expand is happen between "pos" and
>> "endpos", you will not able to access the token that contain
>> the macro expand "pos" easily.
>>
>> For that, we could, just thinking it out loud, add a parser
>> hook for declares when a symbol is complete building.
>> That would a very small and straight forward change.
>> If the hook is not NULL, the call back function will be call
>> with the symbol that just get defined, and the start and end
>> token of that symbol.
>>
>> So your dependence program just need to register the
>> symbol parsing hook. In side the call back function, walk
>> the token from start to end. Look up macro expand information
>> is needed. Build up the dependency struct and store that in
>> symbol->aux.
>>
>> BTW, unrelated to this patch, I can see other program might
>> be able to use the same parser hook to perform source code
>> transformations as well.
>>
>> Make sense? In this way, you don't even need the hash
>> table to attach a context into the token. You can get it directly
>> from symbol->aux.
>>
>>> In my patch I have modeled (2) using 2 structs:
>>> struct macro_expansion {
>>> =A0 =A0 =A0 =A0int nargs;
>>> =A0 =A0 =A0 =A0struct symbol *sym;
>>> =A0 =A0 =A0 =A0struct token *m;
>>> =A0 =A0 =A0 =A0struct arg args[0];
>>> };
>>> struct tok_macro_dep {
>>> =A0 =A0 =A0 =A0struct macro_expansion *m;
>>> =A0 =A0 =A0 =A0unsigned int argi;
>>> =A0 =A0 =A0 =A0unsigned int isbody : 1;
>>> =A0 =A0 =A0 =A0unsigned int visited : 1;
>>> };
>>> Each token from a macro expansion gets tagged with
>>> tok_macro_dep. If it is an macro argument,<argi> =A0shows the
>>> index, if it is from the macro body<isbody> =A0is 1.
>>> Now, I didnt already think about special cases like
>>> token concaternation, even more data is needed to
>>> model this. Also when an macro argument is again used as an
>>> macro argument inside the body expansion, then I kindof
>>> loose the chain: I would also need a "token *dup_of" pointer
>>> to point to the original token that the token is a copy
>>> of (when arguments are created...) etc.
>>>
>>> I have read your macro_expand() hook idea, however
>>> when I understand it right you want to reuse position.stream and
>>> position.line as a kind of pointer (to save the extra 4 bytes).
>>> (Your goal is to minimize codebase change, however I wonder
>>> weather you dont change semantic of struct position and then
>>> need to change the code that uses struct position anyway...)
>>
>>
>> Nope, because the position.stream change is only happen on
>> your dependency analyse program. It is the dependency program
>> register the hook to it. This behaviour is private to the dependency
>> analyse program. Other program that use sparse library don't see
>> it at all, because they don't register macro_expand hooks to perform
>> those stream manipulations. It will receive the exact AST as before.
>>
>>> Maybe it is possible like this...I doubt it, where should
>>> all the extra context, that each token has, be saved and
>>> extracted from? using that sheme...
>>
>>
>> Two places, one is symbol->aux. Also the macro_expand
>> can be lookup by pos->line. That will index into the macro_expand
>> array which store the context.
>>
>> Having this two should be enough to put the exact same
>> dependency result as you are doing right now.
>>
>>> Maybe it is possible but I dont want to have as a design
>>> goal to save 4 bytes (I'd use the void *custom sheme to
>>> save all my extra data, also the pointers to tokens to
>>> "sit around") and adujust everything else to
>>> that. The consequence is that the code-complexity would
>>> grow on the other end.
>>
>>
>> It is not only about saving 4 bytes. It is about other program
>> don't have to suck in the full token struct if they don't need to.
>> It is about re-usable macro hooks and parser hooks that
>> external program can do more fancy stuff like source code transformation=
s
>> without impacting the other user of the sparse lib.
>>
>>> Here is my compromise then:
>>> Keep the orignial "pos". But still grant me for
>>> each struct a "void *custom" pointer that I can use
>>> to store extradata i.e. pointer to token.
>>
>>
>> symbol->aux.
>>
>> Chris
>>
>

--001636c5abbe59763f04bf481d1f
Content-Type: application/octet-stream; name="0001-macro-expand-hook.patch"
Content-Disposition: attachment; filename="0001-macro-expand-hook.patch"
Content-Transfer-Encoding: base64
X-Attachment-Id: f_h1uipd9w0

RnJvbSBkZDljMzA4NTQzZGE1MzEzOGQxMmJiMDQyNjFkNjJiOGFkYzExMmE4IE1vbiBTZXAgMTcg
MDA6MDA6MDAgMjAwMQpGcm9tOiBDaHJpc3RvcGhlciBMaSA8c3BhcnNlQGNocmlzbGkub3JnPgpE
YXRlOiBTYXQsIDUgTWF5IDIwMTIgMDM6MDk6MTggLTA3MDAKU3ViamVjdDogW1BBVENIXSBtYWNy
byBleHBhbmQgaG9vawoKLS0tCiBwcmUtcHJvY2Vzcy5jIHwgICAgNCArKysrCiB0b2tlbi5oICAg
ICAgIHwgICAgNSArKysrKwogMiBmaWxlcyBjaGFuZ2VkLCA5IGluc2VydGlvbnMoKyksIDAgZGVs
ZXRpb25zKC0pCgpkaWZmIC0tZ2l0IGEvcHJlLXByb2Nlc3MuYyBiL3ByZS1wcm9jZXNzLmMKaW5k
ZXggOGExNmY4Yi4uNjNjZDUwOSAxMDA2NDQKLS0tIGEvcHJlLXByb2Nlc3MuYworKysgYi9wcmUt
cHJvY2Vzcy5jCkBAIC0zMCw2ICszMCw4IEBACiAKIHN0YXRpYyBpbnQgZmFsc2VfbmVzdGluZyA9
IDA7CiAKK3N0cnVjdCBwcmVwcm9jZXNzX2hvb2sgKnByZXByb2Nlc3NfaG9vayA9IE5VTEw7CisK
ICNkZWZpbmUgSU5DTFVERVBBVEhTIDMwMAogY29uc3QgY2hhciAqaW5jbHVkZXBhdGhbSU5DTFVE
RVBBVEhTKzFdID0gewogCSIiLApAQCAtNjI1LDYgKzYyNyw4IEBAIHN0YXRpYyBpbnQgZXhwYW5k
KHN0cnVjdCB0b2tlbiAqKmxpc3QsIHN0cnVjdCBzeW1ib2wgKnN5bSkKIAogCWxhc3QgPSB0b2tl
bi0+bmV4dDsKIAl0YWlsID0gc3Vic3RpdHV0ZShsaXN0LCBzeW0tPmV4cGFuc2lvbiwgYXJncyk7
CisJaWYgKHByZXByb2Nlc3NfaG9vayAmJiBwcmVwcm9jZXNzX2hvb2stPmV4cGFuZCkKKwkJcHJl
cHJvY2Vzc19ob29rLT5leHBhbmQodG9rZW4sIGxpc3QsIHRhaWwpOwogCSp0YWlsID0gbGFzdDsK
IAogCXJldHVybiAwOwpkaWZmIC0tZ2l0IGEvdG9rZW4uaCBiL3Rva2VuLmgKaW5kZXggY2QyOTIz
My4uMjM0NDkzMiAxMDA2NDQKLS0tIGEvdG9rZW4uaAorKysgYi90b2tlbi5oCkBAIC0xNzEsNiAr
MTcxLDEwIEBAIHN0cnVjdCB0b2tlbiB7CiAJfTsKIH07CiAKK3N0cnVjdCBwcmVwcm9jZXNzX2hv
b2sgeworCXZvaWQgKCpleHBhbmQpKHN0cnVjdCB0b2tlbiAqbWFjcm8sIHN0cnVjdCB0b2tlbiAq
KnJlcGxhY2UsIHN0cnVjdCB0b2tlbiAqKnJlcGxhY2VfdGFpbCk7Cit9OworCiAjZGVmaW5lIE1B
WF9TVFJJTkcgNDA5NQogCiBzdGF0aWMgaW5saW5lIHN0cnVjdCB0b2tlbiAqY29udGFpbmluZ190
b2tlbihzdHJ1Y3QgdG9rZW4gKipwKQpAQCAtMTg4LDYgKzE5Miw3IEBAIHN0YXRpYyBpbmxpbmUg
c3RydWN0IHRva2VuICpjb250YWluaW5nX3Rva2VuKHN0cnVjdCB0b2tlbiAqKnApCiAgKi8KIGV4
dGVybiBzdHJ1Y3QgdG9rZW4gZW9mX3Rva2VuX2VudHJ5OwogI2RlZmluZSBlb2ZfdG9rZW4oeCkg
KCh4KSA9PSAmZW9mX3Rva2VuX2VudHJ5KQorZXh0ZXJuIHN0cnVjdCBwcmVwcm9jZXNzX2hvb2sg
KnByZXByb2Nlc3NfaG9vazsKIAogZXh0ZXJuIGludCBpbml0X3N0cmVhbShjb25zdCBjaGFyICos
IGludCBmZCwgY29uc3QgY2hhciAqKm5leHRfcGF0aCk7CiBleHRlcm4gY29uc3QgY2hhciAqc3Ry
ZWFtX25hbWUoaW50IHN0cmVhbSk7Ci0tIAoxLjcuNy42Cgo=
--001636c5abbe59763f04bf481d1f--
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 16:59:39 +0000
Message-ID: <CAEjhO7JqWNwGzEYX+xr2gvuCTcnNPovNgk3X1q69E5_CMPnSTw () mail ! gmail ! com>
--------------------
>
> I am not sure I understand your range representation yet.
>

You need to view it with a fixed width font. Its not rocket science,
token lists (or arrays) are viewed as dotted lists. The token.pos
field is listed below each token as p[x] or as the file-location
in file-scope.

I'll come up with a patch to implement this scheme when I have
time to and send it, it might take a while.
-- Konrad

> To be continue...
>
> Chris
>
>
>>
>> Note that a reference to p[] in p[x] notation only references
>> the "start" of the  PP_struct.copy. An uique identification
>> of the "source" token might not always be possible because
>> of disambiguities, so when doing a copy of the  tokens in
>> PP_struct.copy I might use an extended version of struct token
>> to also include an offset.
>>
>> ----- file a.h start -----
>> #define D0(d0a0,d0a1) 1 D1(d0a0) 2 D2(d0a1) 3
>> #define D1(d1a0) 4 d1a0 5
>> #define D2(d2a0) 6 d2a0 7
>> #define D3(d3a0) 8 d3a0 9
>> D0(D3(10),11)
>> ----- file a.h end   .....
>>
>> Preprocessor output (gcc -E a.h): "1 4 8 10 9 5 2 6 11 7 3"
>>
>> PreProcessor macro trace on p[]:
>>
>> p[0]:mdefn_body[D0]     :1.D1.(.d0a0.).2.D2.(.d0a1.).3
>>                         [ a.h:1:23     ..   a.h:1:45]
>> p[1]:mdefn_body[D1]     :4   .   d1a0   .    5
>>                         [ a.h:2:18..a.h:2:25]
>> p[2]:mdefn_body[D2]     :6   .   d2a0   .    7
>>                         [ a.h:3:18..a.h:3:25]
>> p[3]:mdefn_body[D3]     :8   .   d3a0   .    9
>>                         [ a.h:4:18..a.h:4:25]
>> p[4]:minst_arg0[D0]     :D3  . (  .   10 . )
>>                         [ a.h:5:4..a.h:5:9]
>> p[5]:minst_arg1[D0]     :11
>>                         [a.h:5:11]
>> p[6]:minst_arg0[D3]     :10
>>                         p[4]
>> p[7]:(args)expand[p[3]] :8    .  10   .  9
>>                         p[3]    p[4]    p[3]
>> p[8]:minst_arg0[d2]     :11
>>                         p[5]
>> p[9]:(body)expand[p[2]] :6   .   11   .    7
>>                         p[2]    p[5]      p[2]
>> p[10]:(body)expand[p[0]]:1  .4  .8  .10 .9  .5  .2  .6  .11 .7  .3
>>                         p[0]p[1]p[7]p[7]p[7]p[1]p[0]p[9]p[9]p[9]p[0]
>>
>>
>> p[0]-p[3] are build up when the macro is defined.
>>          A p[] entry is needed to destinguish between
>>          the different sources of tokens.
>> p[4],p[5] is build in collect_arguments() for D0(D3(10),11)
>> p[6]      is build in collect_arguments() for D3(10)
>> p[7]      is build in call to macro_expand() hook with flag that
>>          it is a (args)expand
>> p[8]      is build in collect_arguments() for D2(11)
>>          (inside D0's expansion
>> p[9]      is build in call to macro_expand() hook with flag that
>>          it is a (body)expand (of D2)
>> p[10]     is build in call to macro_expand() hook with flag that
>>          it is a (body)expand (of D0)
>>
>> PP_struct {
>>          enum {minst_arg, expand_body, expand_arg, mdef_body} typ;
>>          uint argidx;
>>          struct symbol *macro;
>>          struct token copy[];
>> };
>>
>> Conclusion:
>> -----------
>> Apart from the macro_expand() hook I also need hooks
>> in macro definition and also in collect_arguments() or expand().
>>
>>
>> Concerning (3) How to connect (1) and (2) to the AST
>> ----------------------------------------------------
>>
>> can maybe wait for later iteration. There are more complex parts
>> involved...
>>
>>
>>
>>>
>>> Now how to connect the AST tree with those information is a
>>> very good question. Notice the symbol->aux pointer? That is
>>> the place to attach extra context or back end related data
>>> to symbols.
>>>
>>> Because each symbol has "pos" and "endpos". If the symbol
>>> is expand from macro, using the previous scheme, the pos
>>> should point to a line in the "<pre-processor>" stream.
>>>
>>> However, if the macro expand is happen between "pos" and
>>> "endpos", you will not able to access the token that contain
>>> the macro expand "pos" easily.
>>>
>>> For that, we could, just thinking it out loud, add a parser
>>> hook for declares when a symbol is complete building.
>>> That would a very small and straight forward change.
>>> If the hook is not NULL, the call back function will be call
>>> with the symbol that just get defined, and the start and end
>>> token of that symbol.
>>>
>>> So your dependence program just need to register the
>>> symbol parsing hook. In side the call back function, walk
>>> the token from start to end. Look up macro expand information
>>> is needed. Build up the dependency struct and store that in
>>> symbol->aux.
>>>
>>> BTW, unrelated to this patch, I can see other program might
>>> be able to use the same parser hook to perform source code
>>> transformations as well.
>>>
>>> Make sense? In this way, you don't even need the hash
>>> table to attach a context into the token. You can get it directly
>>> from symbol->aux.
>>>
>>>> In my patch I have modeled (2) using 2 structs:
>>>> struct macro_expansion {
>>>>        int nargs;
>>>>        struct symbol *sym;
>>>>        struct token *m;
>>>>        struct arg args[0];
>>>> };
>>>> struct tok_macro_dep {
>>>>        struct macro_expansion *m;
>>>>        unsigned int argi;
>>>>        unsigned int isbody : 1;
>>>>        unsigned int visited : 1;
>>>> };
>>>> Each token from a macro expansion gets tagged with
>>>> tok_macro_dep. If it is an macro argument,<argi>  shows the
>>>> index, if it is from the macro body<isbody>  is 1.
>>>> Now, I didnt already think about special cases like
>>>> token concaternation, even more data is needed to
>>>> model this. Also when an macro argument is again used as an
>>>> macro argument inside the body expansion, then I kindof
>>>> loose the chain: I would also need a "token *dup_of" pointer
>>>> to point to the original token that the token is a copy
>>>> of (when arguments are created...) etc.
>>>>
>>>> I have read your macro_expand() hook idea, however
>>>> when I understand it right you want to reuse position.stream and
>>>> position.line as a kind of pointer (to save the extra 4 bytes).
>>>> (Your goal is to minimize codebase change, however I wonder
>>>> weather you dont change semantic of struct position and then
>>>> need to change the code that uses struct position anyway...)
>>>
>>>
>>> Nope, because the position.stream change is only happen on
>>> your dependency analyse program. It is the dependency program
>>> register the hook to it. This behaviour is private to the dependency
>>> analyse program. Other program that use sparse library don't see
>>> it at all, because they don't register macro_expand hooks to perform
>>> those stream manipulations. It will receive the exact AST as before.
>>>
>>>> Maybe it is possible like this...I doubt it, where should
>>>> all the extra context, that each token has, be saved and
>>>> extracted from? using that sheme...
>>>
>>>
>>> Two places, one is symbol->aux. Also the macro_expand
>>> can be lookup by pos->line. That will index into the macro_expand
>>> array which store the context.
>>>
>>> Having this two should be enough to put the exact same
>>> dependency result as you are doing right now.
>>>
>>>> Maybe it is possible but I dont want to have as a design
>>>> goal to save 4 bytes (I'd use the void *custom sheme to
>>>> save all my extra data, also the pointers to tokens to
>>>> "sit around") and adujust everything else to
>>>> that. The consequence is that the code-complexity would
>>>> grow on the other end.
>>>
>>>
>>> It is not only about saving 4 bytes. It is about other program
>>> don't have to suck in the full token struct if they don't need to.
>>> It is about re-usable macro hooks and parser hooks that
>>> external program can do more fancy stuff like source code transformations
>>> without impacting the other user of the sparse lib.
>>>
>>>> Here is my compromise then:
>>>> Keep the orignial "pos". But still grant me for
>>>> each struct a "void *custom" pointer that I can use
>>>> to store extradata i.e. pointer to token.
>>>
>>>
>>> symbol->aux.
>>>
>>> Chris
>>>
>>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Konrad Eisele <eiselekd () gmail ! com>
To: linux-sparse
Subject: Re: dependency tee from c parser entities downto token
Date: Sat, 05 May 2012 16:59:39 +0000
Message-ID: <CAEjhO7JqWNwGzEYX+xr2gvuCTcnNPovNgk3X1q69E5_CMPnSTw () mail ! gmail ! com>
--------------------
>
> I am not sure I understand your range representation yet.
>

You need to view it with a fixed width font. Its not rocket science,
token lists (or arrays) are viewed as dotted lists. The token.pos
field is listed below each token as p[x] or as the file-location
in file-scope.

I'll come up with a patch to implement this scheme when I have
time to and send it, it might take a while.
-- Konrad

> To be continue...
>
> Chris
>
>
>>
>> Note that a reference to p[] in p[x] notation only references
>> the "start" of the  PP_struct.copy. An uique identification
>> of the "source" token might not always be possible because
>> of disambiguities, so when doing a copy of the  tokens in
>> PP_struct.copy I might use an extended version of struct token
>> to also include an offset.
>>
>> ----- file a.h start -----
>> #define D0(d0a0,d0a1) 1 D1(d0a0) 2 D2(d0a1) 3
>> #define D1(d1a0) 4 d1a0 5
>> #define D2(d2a0) 6 d2a0 7
>> #define D3(d3a0) 8 d3a0 9
>> D0(D3(10),11)
>> ----- file a.h end   .....
>>
>> Preprocessor output (gcc -E a.h): "1 4 8 10 9 5 2 6 11 7 3"
>>
>> PreProcessor macro trace on p[]:
>>
>> p[0]:mdefn_body[D0]     :1.D1.(.d0a0.).2.D2.(.d0a1.).3
>>                         [ a.h:1:23     ..   a.h:1:45]
>> p[1]:mdefn_body[D1]     :4   .   d1a0   .    5
>>                         [ a.h:2:18..a.h:2:25]
>> p[2]:mdefn_body[D2]     :6   .   d2a0   .    7
>>                         [ a.h:3:18..a.h:3:25]
>> p[3]:mdefn_body[D3]     :8   .   d3a0   .    9
>>                         [ a.h:4:18..a.h:4:25]
>> p[4]:minst_arg0[D0]     :D3  . (  .   10 . )
>>                         [ a.h:5:4..a.h:5:9]
>> p[5]:minst_arg1[D0]     :11
>>                         [a.h:5:11]
>> p[6]:minst_arg0[D3]     :10
>>                         p[4]
>> p[7]:(args)expand[p[3]] :8    .  10   .  9
>>                         p[3]    p[4]    p[3]
>> p[8]:minst_arg0[d2]     :11
>>                         p[5]
>> p[9]:(body)expand[p[2]] :6   .   11   .    7
>>                         p[2]    p[5]      p[2]
>> p[10]:(body)expand[p[0]]:1  .4  .8  .10 .9  .5  .2  .6  .11 .7  .3
>>                         p[0]p[1]p[7]p[7]p[7]p[1]p[0]p[9]p[9]p[9]p[0]
>>
>>
>> p[0]-p[3] are build up when the macro is defined.
>>          A p[] entry is needed to destinguish between
>>          the different sources of tokens.
>> p[4],p[5] is build in collect_arguments() for D0(D3(10),11)
>> p[6]      is build in collect_arguments() for D3(10)
>> p[7]      is build in call to macro_expand() hook with flag that
>>          it is a (args)expand
>> p[8]      is build in collect_arguments() for D2(11)
>>          (inside D0's expansion
>> p[9]      is build in call to macro_expand() hook with flag that
>>          it is a (body)expand (of D2)
>> p[10]     is build in call to macro_expand() hook with flag that
>>          it is a (body)expand (of D0)
>>
>> PP_struct {
>>          enum {minst_arg, expand_body, expand_arg, mdef_body} typ;
>>          uint argidx;
>>          struct symbol *macro;
>>          struct token copy[];
>> };
>>
>> Conclusion:
>> -----------
>> Apart from the macro_expand() hook I also need hooks
>> in macro definition and also in collect_arguments() or expand().
>>
>>
>> Concerning (3) How to connect (1) and (2) to the AST
>> ----------------------------------------------------
>>
>> can maybe wait for later iteration. There are more complex parts
>> involved...
>>
>>
>>
>>>
>>> Now how to connect the AST tree with those information is a
>>> very good question. Notice the symbol->aux pointer? That is
>>> the place to attach extra context or back end related data
>>> to symbols.
>>>
>>> Because each symbol has "pos" and "endpos". If the symbol
>>> is expand from macro, using the previous scheme, the pos
>>> should point to a line in the "<pre-processor>" stream.
>>>
>>> However, if the macro expand is happen between "pos" and
>>> "endpos", you will not able to access the token that contain
>>> the macro expand "pos" easily.
>>>
>>> For that, we could, just thinking it out loud, add a parser
>>> hook for declares when a symbol is complete building.
>>> That would a very small and straight forward change.
>>> If the hook is not NULL, the call back function will be call
>>> with the symbol that just get defined, and the start and end
>>> token of that symbol.
>>>
>>> So your dependence program just need to register the
>>> symbol parsing hook. In side the call back function, walk
>>> the token from start to end. Look up macro expand information
>>> is needed. Build up the dependency struct and store that in
>>> symbol->aux.
>>>
>>> BTW, unrelated to this patch, I can see other program might
>>> be able to use the same parser hook to perform source code
>>> transformations as well.
>>>
>>> Make sense? In this way, you don't even need the hash
>>> table to attach a context into the token. You can get it directly
>>> from symbol->aux.
>>>
>>>> In my patch I have modeled (2) using 2 structs:
>>>> struct macro_expansion {
>>>>        int nargs;
>>>>        struct symbol *sym;
>>>>        struct token *m;
>>>>        struct arg args[0];
>>>> };
>>>> struct tok_macro_dep {
>>>>        struct macro_expansion *m;
>>>>        unsigned int argi;
>>>>        unsigned int isbody : 1;
>>>>        unsigned int visited : 1;
>>>> };
>>>> Each token from a macro expansion gets tagged with
>>>> tok_macro_dep. If it is an macro argument,<argi>  shows the
>>>> index, if it is from the macro body<isbody>  is 1.
>>>> Now, I didnt already think about special cases like
>>>> token concaternation, even more data is needed to
>>>> model this. Also when an macro argument is again used as an
>>>> macro argument inside the body expansion, then I kindof
>>>> loose the chain: I would also need a "token *dup_of" pointer
>>>> to point to the original token that the token is a copy
>>>> of (when arguments are created...) etc.
>>>>
>>>> I have read your macro_expand() hook idea, however
>>>> when I understand it right you want to reuse position.stream and
>>>> position.line as a kind of pointer (to save the extra 4 bytes).
>>>> (Your goal is to minimize codebase change, however I wonder
>>>> weather you dont change semantic of struct position and then
>>>> need to change the code that uses struct position anyway...)
>>>
>>>
>>> Nope, because the position.stream change is only happen on
>>> your dependency analyse program. It is the dependency program
>>> register the hook to it. This behaviour is private to the dependency
>>> analyse program. Other program that use sparse library don't see
>>> it at all, because they don't register macro_expand hooks to perform
>>> those stream manipulations. It will receive the exact AST as before.
>>>
>>>> Maybe it is possible like this...I doubt it, where should
>>>> all the extra context, that each token has, be saved and
>>>> extracted from? using that sheme...
>>>
>>>
>>> Two places, one is symbol->aux. Also the macro_expand
>>> can be lookup by pos->line. That will index into the macro_expand
>>> array which store the context.
>>>
>>> Having this two should be enough to put the exact same
>>> dependency result as you are doing right now.
>>>
>>>> Maybe it is possible but I dont want to have as a design
>>>> goal to save 4 bytes (I'd use the void *custom sheme to
>>>> save all my extra data, also the pointers to tokens to
>>>> "sit around") and adujust everything else to
>>>> that. The consequence is that the code-complexity would
>>>> grow on the other end.
>>>
>>>
>>> It is not only about saving 4 bytes. It is about other program
>>> don't have to suck in the full token struct if they don't need to.
>>> It is about re-usable macro hooks and parser hooks that
>>> external program can do more fancy stuff like source code transformations
>>> without impacting the other user of the sparse lib.
>>>
>>>> Here is my compromise then:
>>>> Keep the orignial "pos". But still grant me for
>>>> each struct a "void *custom" pointer that I can use
>>>> to store extradata i.e. pointer to token.
>>>
>>>
>>> symbol->aux.
>>>
>>> Chris
>>>
>>
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: help needed: document __nocast vs __bitwise (Was: [PATCH 00/16] mm: prepare for converting vm->vm_fl ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: help needed: document __nocast vs __bitwise (Was: [PATCH 00/16] mm: prepare for converting vm->vm_fl
Date: Fri, 23 Mar 2012 18:17:10 +0000
Message-ID: <CANeU7Q=GAcLy121eKQhuSkgKo06wRkpmLQTWc5WQgPN3RcjMjw () mail ! gmail ! com>
--------------------
Linus has a very nice write up about __nocast vs __bitwise.

Can any one help to integrate the write up to a patch
against man page sparse.1?

I would much rather hitting the apply button than hacking
documents. But if nobody wants to do it, it would have to
be me then.

Yes, I am a lazy baster :-)

Thanks

Chris

---------- Forwarded message ----------
From: Linus Torvalds <torvalds@linux-foundation.org>
Date: Thu, Mar 22, 2012 at 3:08 PM
Subject: Re: [PATCH 00/16] mm: prepare for converting vm->vm_flags to 64-bit
To: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>, Konstantin Khlebnikov
<khlebnikov@openvz.org>, Minchan Kim <minchan@kernel.org>,
"linux-mm@kvack.org" <linux-mm@kvack.org>,
"linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>, Hugh
Dickins <hughd@google.com>, KOSAKI Motohiro
<kosaki.motohiro@jp.fujitsu.com>, Ben Herrenschmidt
<benh@kernel.crashing.org>, "linux@arm.linux.org.uk"
<linux@arm.linux.org.uk>


On Thu, Mar 22, 2012 at 2:41 PM, Andrew Morton
<akpm@linux-foundation.org> wrote:
>>
>> Use __bitwise for that - check how gfp_t is handled.
>
> So what does __nocast do?

__nocast warns about explicit or implicit casting to different types.

HOWEVER, it doesn't consider two 32-bit integers to be different
types, so a __nocast 'int' type may be returned as a regular 'int'
type and then the __nocast is lost.

So "__nocast" on integer types is usually not that powerful. It just
gets lost too easily. It's more useful for things like pointers. It
also doesn't warn about the mixing: you can add integers to __nocast
integer types, and it's not really considered anything wrong.

__bitwise ends up being a "stronger integer separation". That one
doesn't allow you to mix with non-bitwise integers, so now it's much
harder to lose the type by mistake.

So basic rules is:

 - "__nocast" on its own tends to be more useful for *big* integers
that still need to act like integers, but you want to make it much
less likely that they get truncated by mistake. So a 64-bit integer
that you don't want to mistakenly/silently be returned as "int", for
example. But they mix well with random integer types, so you can add
to them etc without using anything special. However, that mixing also
means that the __nocast really gets lost fairly easily.

 - "__bitwise" is for *unique types* that cannot be mixed with other
types, and that you'd never want to just use as a random integer (the
integer 0 is special, though, and gets silently accepted iirc - it's
kind of like "NULL" for pointers). So "gfp_t" or the "safe endianness"
types would be __bitwise: you can only operate on them by doing
specific operations that know about *that* particular type.

Generally, you want __bitwise if you are looking for type safety.
"__nocast" really is pretty weak.

                 Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: loan offer ===

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-raid
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-raid" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-btrace
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-btrace" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-scsi
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-scsi" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-ide
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-ide" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-ext4
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-ext4" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-ia64
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-ia64" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-sparse
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-msdos
Subject: loan offer
Date: Fri, 07 Dec 2012 09:29:25 +0000
Message-ID: <46aad18e-11f0-477b-9c0f-9a6cff1c222b () novo ! ifam ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-msdos" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <aruma () ifam ! edu ! br>
To: linux-netdev
Subject: loan offer
Date: Fri, 07 Dec 2012 09:40:57 +0000
Message-ID: <f1c6529c-f5de-49e6-a0e4-3b350e81b018 () novo ! ifam ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe netdev" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <a.orsini () ausl ! fo ! it>
To: dccp
Subject: loan offer
Date: Fri, 07 Dec 2012 22:48:04 +0000
Message-ID: <1205101367.1049978.1354920484988.JavaMail.root () ausl ! fo ! it>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe dccp" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-netdev
Subject: loan offer
Date: Sat, 08 Dec 2012 00:49:40 +0000
Message-ID: <572517058.39986.1354927780117.JavaMail.root () ufcg ! edu ! br>
--------------------

Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe netdev" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-sparc
Subject: loan offer
Date: Sat, 08 Dec 2012 01:27:58 +0000
Message-ID: <1494154318.40825.1354930078408.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe sparclinux" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-m68k
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-m68k" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-sparse
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-ext4
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-ext4" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-ia64
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-ia64" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-fsdevel
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-fsdevel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-arch
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-arch" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-msdos
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-msdos" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: SEC Capitals Loan <dcssrh () ufcg ! edu ! br>
To: linux-raid
Subject: loan offer
Date: Sat, 08 Dec 2012 01:36:06 +0000
Message-ID: <420191693.40931.1354930566788.JavaMail.root () ufcg ! edu ! br>
--------------------


Loan Offer at 3%, Feel Free to REPLY back to us for more info
--
To unsubscribe from this list: send the line "unsubscribe linux-raid" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse-llvm segfaults when passing a struct pointer ===

From: Linus Torvalds <torvalds () linux-foundation ! org>
To: linux-sparse
Subject: Re: sparse-llvm segfaults when passing a struct pointer
Date: Fri, 20 Jul 2012 20:12:51 +0000
Message-ID: <CA+55aFx9nhVkD7oEKR2SRjVomf4a-WV7tb69PfRJzWkMgfzhyg () mail ! gmail ! com>
--------------------
On Fri, Jul 20, 2012 at 1:21 AM, Pekka Enberg <penberg@kernel.org> wrote:
>
> Linus, Jeff, how does the sparse frontend deal with externs? Why isn't
> "foop" visible after linearize_symbol()?

'extern' symbols are just names with types. They don't have any value
associated with them, they just have the type and the name.

What else would you expect sparse to have?

              Linus
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse-llvm: pseudo_to_value: Assertion `sym->ident == ((void *)0)' failed ===

From: Pekka Enberg <penberg () kernel ! org>
To: linux-sparse
Subject: Re: sparse-llvm: pseudo_to_value: Assertion `sym->ident == ((void *)0)' failed
Date: Mon, 13 Feb 2012 13:34:29 +0000
Message-ID: <CAOJsxLFnSKkfaeTKkoN-RM5iRfunmktwDUwDOtTjKQ-U_65SXg () mail ! gmail ! com>
--------------------
On Mon, Feb 13, 2012 at 9:17 AM, Benjamin Herrenschmidt
<benh@kernel.crashing.org> wrote:
> Hi folks !
>
> Haven't had a chance to investigate further today (and probably won't)
> so I'm shooting this here just in case ;-)
>
> I was tracking down what looks like an LLVM bug with sign extension from
> 1-bit integers while playing with llvmpipe (gallium llvm backend) and
> out of curiosity decided to look at what sparse generated when
> sign-extending a bool :-)
>
> So I added to my earlier hello.c some statements to that effect, and
> trying to compile it results in:
>
> sparse-llvm.c:311: pseudo_to_value: Assertion `sym->ident == ((void *)0)' failed.
>
> The new hello.c is:
>
> #include <stdio.h>
> #include <stdbool.h>
>
> int main(void)
> {
>        int i;
>        double f1,f2;
>        bool eq;
>
>        printf("Hello World !\n");
>
>        for (i = 0; i < 10; i ++)
>                printf("I can count to %d\n", i);
>
>        printf("f1=");
>        scanf("%f",&f1);
>        printf("f2=");
>        scanf("%f",&f2);
>
>        eq = f1 == f2;
>
>        printf("f1==f2: %d\n", (int)eq);
>        return 0;
> }

I can reproduce the issue with this minimal test case:

#include <stdio.h>

int main(int argc, char *argv[])
{
	float f;

	scanf("%f", &f);

	return 0;
}

It looks like we need to teach pseudo_to_value() about ident symbols.

                        Pekka
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse-llvm: void return type compiles to i8 ===

From: Jonathan =?utf-8?Q?Neusch=C3=A4fer?= <j.neuschaefer () gmx ! net>
To: linux-sparse
Subject: sparse-llvm: void return type compiles to i8
Date: Sun, 19 Aug 2012 00:32:00 +0000
Message-ID: <20120819003159.GB2880 () debian ! debian>
--------------------
Hi!

A simple function like this will compile to the following llvm bitcode:

	/* C */
	void func(void) {
		return;
	}

	/* LLVM */
	define i8 @func() {
	L0:
	  ret void
	}

The return type of the function and the type in the return instruction
don't match.

I found this inconsistency by running LLVM's bitcode validation on the
bitcode produced by sparse-llvm.


Greetings,
Jonathan NeuschÃ¤fer
--
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

